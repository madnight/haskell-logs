00:00:24 <jle`> therealhunt: certain functionality just wasn't envisioned by the writers of the Haskell Report and people in 2010
00:00:31 <augur> haasn: hm. maybe its not possible. thats curious
00:00:39 <jle`> well maybe people in 2010.
00:00:40 <augur> i couldve sworn ive written things like that before
00:00:47 <haasn> class Functor m => Monad m where return :: a -> m a; (>>=) :: (a -> m b) -> m a -> m b -- is also valid Haskell98
00:00:59 <jle`> 1998 was ...
00:01:02 <jle`> > 2014 - 1998
00:01:03 <lambdabot>  16
00:01:05 <jle`> years ago
00:02:00 <therealhunt> haha jle`
00:02:51 <haasn> augur: I think the only way to do what that may have meant is by using MPTCs, optionally with FunDeps
00:03:24 <therealhunt> augur, this is turning out quite strange. im not sure what the implications of what i was tring to write earlier are but what i have now is a simple (class Functor f => Matrix f  where 	rows :: f a -> Int ...) going on
00:03:42 <augur> therealhunt: you should use names like numRows not rows
00:03:50 <augur> rows suggests its giving you back a list of rows, not the count
00:03:56 <therealhunt> augur, ah good point
00:04:12 <augur> tho also you probably should just return a list of rows too
00:04:25 <augur> since counting isnt really core, to maybe it is, i dont know
00:04:31 <haasn> rowCount?
00:04:41 <augur> length.rows
00:04:52 <haasn> lengthOf rows
00:05:50 <therealhunt> im definitely going to scrap this class soon
00:06:09 <therealhunt> theres no way i have time to flesh it out to the point of actually worth being a class tongiht
00:06:14 <therealhunt> and do my project
00:06:26 <haasn> possibly useful advice: always try designing an abstraction without the use of classes first
00:06:53 <therealhunt> haasn: i have
00:07:13 <therealhunt> i have all the functionality i wanted for my implementation of matrices working, now i was working on the calss
00:07:47 <augur> therealhunt: no no
00:07:56 <augur> implementing functionality is designing an implementation
00:08:05 <augur> designing an abstraction is figuring out the functionality first
00:08:32 <augur> and very often you want to do that by creating some type signatures
00:08:37 <therealhunt> augur, im deisigning a class based on the implementation and with general functionality in mind
00:08:47 <augur> Matrix :: * -> *   ;   numRows :: Matrix a -> Int   ;   ...
00:09:26 <augur> and then once you've defined that, you write your module however (eg newtype Matrix a = Matrix [[a]]), export those pieces only
00:10:08 <augur> thats your first (and here, only) abstraction barrier to design
00:10:14 <bitemyapp> therealhunt: I mean, if you're just learning and won't use any libraries godspeed
00:10:17 <augur> a type class is a further generalization that isnt necessary
00:10:40 <bitemyapp> therealhunt: I could tell you how to write a more efficient representation of a matrix but I'm not sure if you'd consider Data.Vector or Data.Array a "library"
00:10:47 <jle`> an MVector constructor has two fields
00:10:50 <jle`> er
00:10:56 <jle`> three fields, Int Int mutable array
00:11:00 <therealhunt> bitemyapp, its for a graphics class so were sort of building our way up, im going to use libraries if it doesnt take away from that
00:11:07 <jle`> what are the two ints? the index boundaries?
00:11:27 <bitemyapp> therealhunt: matrix manipulation isn't generally the interesting part of graphics and half-assing it isn't going to make your life easier.
00:11:59 <therealhunt> bitemyapp, sure id be interested, is there anywhere i can look at the implementation of .Vector
00:12:35 <therealhunt> bitemyapp, no its not but its what were working with right now and im not going to use the library until i have a good grip on how were using matrices, which is the point of the class atm
00:13:14 <therealhunt> bitemyapp, graphics class in the sense of theres an instructor
00:13:20 <therealhunt> bitemyapp, not a haskel
00:13:40 <augur> incidentally, i think good docs for abstraction barriers are really missing in haskell
00:14:37 <therealhunt> augur, abstraction barriers are probably one of the coolest traits ive seen in haskell so far
00:14:51 <augur> therealhunt: all languages have abstraction barriers, usually
00:15:00 <augur> i mean, C has them via header files
00:15:01 <therealhunt> augur, sure but haskells implementation is what i meanth
00:15:30 <augur> haskell's implementation isnt entirely special
00:15:33 <therealhunt> specifically the simplicity (two abstractions) that still feels under control
00:15:45 <augur> modular abstraction barriers are old
00:16:04 <augur> type classes are a clean way of getting lots of power from data-oriented programming
00:16:18 <augur> or whatever SICP calls it
00:17:31 <augur> data-directed programming, thats it
00:18:01 <augur> and/or generic operations
00:18:39 <augur> dispatching on types is older than haskell, but haskell's type classes do it especially well precisely because they're generative
00:20:56 <augur> functional languages have generally excelled at abstraction, fwiw, because of the commonality of first class functions
00:22:05 <augur> most lisp systems handle this stuff in-code rather than at the compiler level, using "type" tags and so forth to manually dispatch
00:22:37 <augur> but it has its limitations (lack of generativity)
00:23:12 <augur> (also lack of type-operator-based classes)
00:27:34 <xintron> I'm running a http fetch in it's own thread, is it bad to not catch potential exceptions for fetching the data here (just letting the thread "die" instead)?
00:27:37 <therealhunt> augur, that is i think what i meant, that theyre generative
00:28:11 <anon_555> guys i wanted to start haskell but always failed
00:28:12 <anon_555> :D
00:28:21 <anon_555> what is the easy way to read haskell
00:28:36 <Iceland_jack> @where lyah
00:28:36 <lambdabot> http://www.learnyouahaskell.com/
00:28:42 <Iceland_jack> anon_555: Go through LYAH
00:30:59 <ezrios> @pl (\x -> if all isDigit x then Just (read x :: Int) else Nothing)
00:30:59 <lambdabot> flip (ap (if' . all isDigit) (Just . (:: Int) . read)) Nothing
00:31:29 <therealhunt> anon_555 im learning haskell too, for me working on a project in it is a really good motivator
00:31:33 <ezrios> wow, didn't know you could section type bindings
00:32:13 <xpika> is their alternative of tuple with type data A = Data a a?
00:32:22 <Iceland_jack> ezrios: You can't, it's not an operator
00:32:28 <Iceland_jack> > (:: Int) 5
00:32:29 <lambdabot>  <hint>:1:2: parse error on input `::'
00:32:34 <xpika> instead of Data a b ?
00:32:42 <ezrios> Iceland_jack: how is it being composed then?
00:32:56 <Iceland_jack> ezrios: @pl is interpreting it as an operator
00:33:04 <ezrios> ah
00:33:22 <ezrios> @pl (\x -> if all isDigit x then Just (read x) else Nothing)
00:33:22 <lambdabot> flip (ap (if' . all isDigit) (Just . read)) Nothing
00:33:47 <Iceland_jack> xpika: https://hackage.haskell.org/package/tup-functor-0.2.0.3/docs/Data-Tup.html
00:33:53 <[2]grant> :t parse
00:33:53 <lambdabot> Not in scope: `parse'
00:34:03 <[2]grant> :t Text.Parsec.parse
00:34:04 <lambdabot> Text.Parsec.Prim.Stream s Identity t => Text.Parsec.Prim.Parsec s () a -> Text.Parsec.Pos.SourceName -> s -> Either Text.Parsec.Error.ParseError a
00:36:27 <therealhunt> @pl let bottom = bottom in bottom
00:36:27 <lambdabot> fix id
00:36:36 <therealhunt> fix id?
00:36:53 <Iceland_jack>     fix id ≡ id (id (id (id (id …))))
00:37:00 <therealhunt> ah lol
00:37:03 <therealhunt> that was the intent
00:37:11 <Iceland_jack> @src fix
00:37:11 <lambdabot> fix f = let x = f x in x
00:37:11 <therealhunt> @pl a = a
00:37:11 <lambdabot> a = fix id
00:37:59 <xpika> Iceland_jack: thanks
00:38:03 <therealhunt> @pl fix 1
00:38:03 <lambdabot> fix 1
00:42:48 <therealhunt> is it possible to have a type synonym for Functor f => f Int?
00:43:39 <gamegoblin> In Parsec, it says
00:43:40 <gamegoblin> ParsecT s u m a is a parser with stream type s, user state type u, underlying monad m and return type a
00:43:45 <gamegoblin> What is user state type u?
00:45:59 <ski> therealhunt : try with `{-# LANGUAGE LiberalTypeSynonyms,Rank2Types #-}' at the head of the module ?
00:46:24 <ski> therealhunt : i.e. with something like `type Foo f = Functor f => f Int'
00:46:43 <ski> (if you want to quantify `f', then you want to quantify `f' ..)
00:47:11 <ski> gamegoblin : and type the user wants to use for a state ?
00:53:54 <gamegoblin> I have a Stream instance that looks like:
00:54:05 <gamegoblin> Stream TimeoutStream IO Char
00:54:14 <gamegoblin> what would my call to runPT look like?
00:55:08 <haasn> gamegoblin: you can think of the user stat u as a StateT u layered on top of the parsec
00:55:11 <ski> @hoogle runPT
00:55:12 <lambdabot> Text.Parsec.Prim runPT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
00:55:25 <haasn> it's provided for convenience
00:55:39 <haasn> well, layered on top of the parsec's underlying moand m
00:55:42 <haasn> monad*
00:57:26 <gamegoblin> So anyone have any idea what my runPT call should be? I can't figure it out. Been staring at types for 10 minutes now.
00:58:07 <gamegoblin> right now it's
00:58:10 <ski>   runPT myParser currentAgeOfUniverseInSeconds "this is a dream" myTimeoutStream
00:58:12 <gamegoblin> runPT requestLine () "" timeoutstream
00:58:18 <ski> perhaps something like that ^ ?
00:58:39 <johnw> only 10 minutes?
00:58:44 <ski> gamegoblin> :t requestLine
00:59:18 <jle`> anyonle know why my modules in Hackage don't have links? :/
00:59:20 <jle`> http://hackage.haskell.org/package/tagged-binary-0.1.0.0/candidate
00:59:35 <jle`> it is my babby's first hackage library
00:59:53 <Twey> jle`: The Haddock generation happens as part of a batch job every so often
01:00:06 <jle`> Twey: ah, so i don't need to change anything to get it to show up?
01:00:07 <Twey> jle`: So long as your Haddock is syntactically valid, you'll get Haddock and links to it later
01:00:32 <Twey> Otherwise, http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
01:00:37 <gamegoblin> ski: How can I find out its type?
01:00:51 <jle`> it compiles fine on cabal install --haddock-html
01:00:54 <jle`> and it looks fine locally
01:00:56 <ski> gamegoblin : by typing `:t requestLine' into your interactor ?
01:00:57 <jle`> that should be good right?
01:01:09 <ski> (or `:type' instead of `:t', if you prefer)
01:01:13 <Twey> jle`: Probably; check your build log if you're worried
01:01:36 <jle`> Twey: where do I find that?
01:01:50 <Twey> Otherwise, http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
01:02:09 <ski> should that be in a `where' ?
01:03:11 <Fuuzetsu> also see https://gist.github.com/stbuehler/7068764
01:03:25 <jle`> Twey: hm there doesn't seem to be anything there. probably because it's a candidate
01:04:07 <jle`> i guess that's ok
01:04:14 <Twey> jle`: Yeah, it just hasn't built yet, then
01:04:21 <Twey> Give it an hour or so
01:04:42 <jle`> ah that too
01:04:44 <jle`> thanks :)
01:04:56 <therealhunt> whats a good way to take a list [a,b,c,d] and group into 3s
01:05:05 <Twey> No problem
01:05:55 <Twey> > map (take 3) . takeWhile (not . null) $ iterate (drop 3) [1 .. 21]
01:05:56 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21]]
01:06:11 <haasn> > chunksOf 3 [a,b,c,d]
01:06:12 <lambdabot>  [[a,b,c],[d]]
01:06:33 <therealhunt> @src chunksOf
01:06:33 <lambdabot> Source not found. Wrong!  You cheating scum!
01:06:38 <therealhunt> where is chunksOf
01:06:42 <Twey> Data.List.Split
01:06:51 <Twey> It's not standard but it's part of the Platform
01:06:51 <bartavelle> it is a useful package
01:07:21 <therealhunt> ah damn i dont have it installed
01:07:32 <Twey> Install it then ☺
01:07:43 <therealhunt> eh not tongight
01:07:55 <Twey> ‘cabal install split’
01:07:58 <therealhunt> ive got to move this program in between spaces and i dont want to have to install stuff elsewhere today
01:08:13 <Twey> You should really have at least the Platform everywhere
01:08:23 <therealhunt> its weird that i dont have it here
01:08:24 <Twey> It's designed as a globally available build target
01:08:33 <therealhunt> i thought i installed the platform
01:08:38 <osa1> hi all. I'm trying to install RC2 but "make install" fails: http://lpaste.net/101050 any ideas why?
01:11:28 <gamegoblin> ski: having a lot of trouble using GHCI... never much used it
01:12:38 <ski> gamegoblin : Hugs ?
01:13:17 <gamegoblin> I'm in GHCI, and my parser bit imports from another part of the package
01:13:23 <gamegoblin> when I try to :add my/parser/file.hs
01:13:35 <gamegoblin> it says it can't find the module I want
01:13:47 <gamegoblin> the module it tries to import that is
01:14:38 <gamegoblin> Weirdly though it doesn't error on some imports from the same package beforehand...
01:16:29 <gamegoblin> Here is the compile error I am getting, though
01:16:30 <gamegoblin>     No instance for (Stream TimeoutStream (Either a0) Char)
01:16:30 <gamegoblin>       arising from a use of `requestLine'
01:16:41 <gamegoblin> on the line runPT requestLine () "" timeoutstream
01:17:04 <gamegoblin> timeout stream's Stream declaration is Stream TimeoutStream IO Char
01:17:13 <gamegoblin> What's the stuff about Either a0 it wants?
01:17:27 <ski> sounds like the error isn't quite at that point
01:17:36 <ski> could you paste the context ?
01:17:43 <zenkeku> Hey, so cabal fails to install the package xmonad-extras stating that it might break some other packages. Paste: http://pastie.org/8910729
01:17:47 <ski> @paste
01:17:47 <lambdabot> Haskell pastebin: http://lpaste.net/
01:18:12 <adimit> Is there support for type holes in the new GHC?
01:18:34 <adimit> the newest RC doesn't seem to have it yet.
01:19:05 <gamegoblin> ski: http://lpaste.net/101051
01:19:37 <zenkeku> Also, running "cabal install cabal-install" and then "cabal update" results in cabal wanting to install its current version over and over.
01:26:48 <gamegoblin> ski: I'm actually about to lose my bloody mind doing this and I'm going to sleep now, sorry
01:29:23 * ski annotated "No title" with "use `IO'" at <http://lpaste.net/101051>
01:29:30 <ski> gamegoblin : try something like that ^ ?
01:29:31 <johnw> gamegoblin: don't let the feeling discourage you
01:29:40 <johnw> gamegoblin: you're actually laying mental groundwork for future insights :)
01:29:50 <zenkeku> Welp. -- I'm going to be going to bed. I'll be asking this question tomorrow, then.
01:42:04 <bartavelle> a preview video of Meijer FP mooc : https://twitter.com/headinthebox/status/443519748798566400
01:42:23 <bartavelle> (or youtube link https://www.youtube.com/watch?v=-BY84BeQQZw )
01:42:46 <ChongLi> hi
01:42:54 <ChongLi> I was just looking at Data.Set
01:43:04 <ChongLi> why isn't there a lookupEQ function?
01:43:13 <ChongLi> there's LT, GT, LE, GE
01:43:59 <bartavelle> ChongLi, it's member :)
01:44:08 <ChongLi> member returns Bool, not Maybe a :)
01:44:09 <jle`> ChongLi: it's id :P
01:44:12 <jle`> or Just
01:44:39 <ChongLi> I know it's trivial to do myself, but it seems like it ought to exist for convenience/completion :)
01:44:58 <jle`> because the item that is equal to itself would just be that item
01:45:02 <jle`> hm
01:45:05 <jle`> ah i see your point
01:45:41 <Iceland_jack> bartavelle: Looks good :)
01:45:42 <ChongLi> honestly, what am I supposed to do with a Bool anyway? :)
01:45:44 * hackagebot HLearn-classification 1.0.1.2 -   http://hackage.haskell.org/package/HLearn-classification-1.0.1.2 (MikeIzbicki)
01:45:44 * hackagebot MFlow 0.4.1 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.1 (AlbertoCorona)
01:46:22 <bartavelle> Iceland_jack, he certainly is funny, but I think there needs to be an audio-only version for LSD-impaired people :p
01:47:04 <jle`> ChongLi: be blind?
01:47:25 <ChongLi> yeah, that was my line of thinking :)
01:48:31 <ChongLi> that Erik Meijer video is great :)
01:48:42 <ski> @tell gamegoblin see my "use `IO'" annotation on <http://lpaste.net/101051>
01:48:42 <lambdabot> Consider it noted.
01:48:52 <ChongLi> I love that his shirt interferes with the chromakey
01:48:57 <bartavelle> yes
01:49:09 <jle`> lookupEQ x = bool (Just x) Nothing . member x
01:50:37 <ChongLi> jle`: bool-extras huh?
01:50:39 * hackagebot egison 3.3.1 - Programming language with non-linear pattern-matching with backtracking  http://hackage.haskell.org/package/egison-3.3.1 (SatoshiEgi)
01:51:06 <jle`> ChongLi: it's in Data.Bool for 7.8 :)
01:51:12 <ChongLi> ohhh, nice
01:51:57 <jle`> lambdabot always had one too
01:51:59 <jle`> :t if
01:52:00 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:52:04 <jle`> er
01:52:15 <jle`> @pl \x y z -> if x then y else z
01:52:15 <lambdabot> if'
01:52:18 <jle`> :t if'
01:52:19 <lambdabot>     Not in scope: if'
01:52:19 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
01:52:24 <jle`> i guess only pl has it
01:53:03 <jle`> oh, it's different order of parameters too
01:53:40 <jle`> personally i would prefer lambda-encoded booleans
01:53:55 <therealhunt> is there a built in function to convert from radians to degrees
01:54:31 <jle`> > let true = const; false = flip const in (true 8 9, false 8 9)
01:54:32 <lambdabot>  (8,9)
01:55:03 <ChongLi> ahh, nice
01:55:09 <kaikokaur> I need HashMap that keeps also ordering. It means toList should result elements in order they were inserted. Is there any?
01:55:25 <ski> @type (180 / pi *)  -- therealhunt, maybe ?
01:55:26 <lambdabot> Floating a => a -> a
01:55:40 * hackagebot fixed-vector 0.6.3.1 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.3.1 (AlexeyKhudyakov)
01:55:40 <jle`> > let not' = flip; true = const in (not' true) 8 9
01:55:41 <lambdabot>  9
01:55:42 <ChongLi> kaikokaur: ordering on keys or values?
01:55:53 <kaikokaur> ChongLi: keys
01:55:53 <ChongLi> oh nvm
01:55:54 <jle`> perhaps on insertion order?
01:55:57 <ChongLi> insertion order
01:56:09 <ChongLi> I'm not aware of such a thing
01:56:09 <jle`> if you want ordering on keys just use Data.Set
01:56:19 <jle`> er
01:56:21 <jle`> Data.Map
01:56:28 <ChongLi> hashing does not preserve insertion order
01:57:01 <jle`> some hashmap implementations (like the one in the ruby spec) preserve insertion order
01:57:07 <kaikokaur> ChongLi: sry, not keys. I know, but is there any library that also keeps ordering? Data.Map doesn't (it sort keys)
01:57:32 <ChongLi> kaikokaur: how about an assoc list?
01:57:44 <jle`> not quite O(1) lookup though
01:57:59 <ChongLi> O(1) is a lie anyway :)
01:58:58 <kaikokaur> CongLi: Can't find any
01:58:59 <ChongLi> even the venerable unordered-containers are O(log n) lookup
01:59:09 <ChongLi> kaikokaur: it's in the prelude
01:59:12 <jle`> still better than O(n)
01:59:17 <ChongLi> :t lookup
01:59:18 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
01:59:50 <kaikokaur> Usual list is _really_ slow :)
01:59:57 <ChongLi> it's linear time
02:00:08 <ChongLi> but it gives you the properties you want with a minimum of complexity
02:00:20 <kaikokaur> Ok, I undrestand that I have to manage ordering by myself. Just ... more work todo then
02:00:24 <ChongLi> (implementation, not computational)
02:00:40 <ChongLi> lists are insertion-ordered automatically
02:01:05 <jle`> yeah, you don't have to manage much for the ordering
02:01:12 <jle`> all you have to do is just tuple the map and the list together
02:01:17 <jle`> and write your own toList i guess
02:01:40 <ChongLi> what do you need the map for?
02:02:36 <kaikokaur> Creating my own small programming language for template system
02:03:14 <ChongLi> hmmm
02:03:28 <ChongLi> what is this a map of? symbols to values?
02:04:48 <kaikokaur> key can be number or text and value have any most common types (bool, float, int ...)
02:06:50 <ChongLi> how often do you make use of the insertion order vs just looking up keys?
02:07:25 <ChongLi> it may make sense to just roll your own tuple type to store both the map and a list of keys in insertion order
02:10:20 <kaikokaur> It was my next plan.
02:10:38 <kaikokaur> I can't answer that as this template language for others, not to me
02:16:15 <erisco_> does anyone know what this cabal conflict is about? http://lpaste.net/101056
02:18:24 <erisco_> ah okay silly me... instructions said to install ghc 7.8 first
02:18:32 <ChongLi> erisco_: the version of binary you have installed (0.5) is too old
02:23:04 <erisco_> not sure where I grab the 7.8 source
02:23:40 <ChongLi> http://www.haskell.org/ghc/dist/7.8.1-rc1/
02:23:56 <jle`> rc2 is out too
02:24:02 <ChongLi> oh, good point
02:24:05 <erisco_> how bad is it on windows?
02:24:53 <ChongLi> depends on how proficient you are at setting up your windows dev environment
02:25:21 <ChongLi> have you installed many libraries with external C dependencies?
02:25:47 <erisco_> haskell libraries?
02:26:01 <ChongLi> haskell libraries with C dependencies
02:26:07 <erisco_> none
02:26:14 <ChongLi> you've never done it before?
02:26:20 <erisco_> no
02:26:28 <erisco_> I am not sure which tar file I should get either
02:26:28 <ChongLi> okay
02:27:04 <ChongLi> those are just different compression formats
02:27:37 <erisco_> I know. I mean I do not know whether I need windows-extra-src, or what
02:27:50 <erisco_> or just -src? no idea
02:28:48 <ChongLi> I don't know what windows-extra-src does
02:28:54 <ChongLi> it's pretty big though
02:29:23 <ChongLi> let me download it and have a lok
02:31:24 <ChongLi> ahh, windows-extra-src includes mingw, mingw64
02:31:33 <ChongLi> and perl
02:31:42 <ChongLi> you likely want those
02:32:42 <erisco_> maybe I can check out what this vagrant thing is
02:32:59 <erisco_> maybe it will be easier to install there... they seem to prioritize the linux support first
02:33:06 <b0bbi10> morning, how should I read this: :t minBound, minBound :: Bounded a => a. is minBound a function that takes one parameter? (or is 'a' the return value?)
02:33:24 <ChongLi> b0bbi10: minBound is just a value
02:34:03 <b0bbi10> ah ok
02:34:07 <ChongLi> type class methods need not be functions; they can be values as well
02:34:30 <b_jonas> > minBound :: Int -- let's try that
02:34:31 <lambdabot>  -9223372036854775808
02:34:34 <jle`> :t ['a','b',minBound]
02:34:34 <lambdabot> [Char]
02:34:36 <ChongLi> functions are just values anyway :)
02:34:40 <jle`> ['a','b',minBound]
02:34:46 <jle`> > ['a','b',minBound]
02:34:47 <lambdabot>  "ab\NUL"
02:35:01 <jle`> > minBound `asTypeOf` 'a'
02:35:02 <lambdabot>  '\NUL'
02:35:27 <bitemyapp> jle`: welp.
02:35:42 <jle`> :|
02:35:56 * bitemyapp scribbles a paranoid note to self about chars and minBound
02:36:02 <b0bbi10> no clue what this is all about guys ;D
02:36:09 <bitemyapp> :t minBound
02:36:09 <lambdabot> Bounded a => a
02:36:14 <bitemyapp> :info Char
02:36:17 <bitemyapp> :info Int
02:36:21 <bitemyapp> oh, okay, I see how it is.
02:36:29 <bitemyapp> b0bbi10: Char and Int are both Bounded.
02:36:57 <erisco_> ChongLi, when I ask cabal list bin-package-db it says there is no such package
02:37:02 <bitemyapp> b0bbi10: minimum bound of Char is \NUL, Int is apparently signed.
02:37:16 <b0bbi10> bitemyapp: yeah
02:37:22 <ChongLi> erisco_: bin-package-db is not a package
02:37:36 <erisco_> oh =\
02:37:38 <ChongLi> it's the package database of your installed packages
02:37:43 <bitemyapp> > minBound  :: Bool
02:37:44 <lambdabot>  False
02:37:52 <bitemyapp> > minBound  :: ()
02:37:53 <lambdabot>  ()
02:37:59 <bitemyapp> seriously?
02:38:03 <bitemyapp> why...why?
02:38:08 <ChongLi> > maxBound :: Word16
02:38:09 <lambdabot>  65535
02:38:11 <merijn> bitemyapp: Why not?
02:38:21 <jle`> > [()..]
02:38:22 <lambdabot>  [()]
02:38:28 <jle`> > [()..()]
02:38:29 <lambdabot>  [()]
02:38:37 <jle`> > succ ()
02:38:38 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
02:38:56 <jle`> it's kind of unsettling that there are so many partial functions in prelude
02:39:00 <bitemyapp> > minBound  :: Any
02:39:01 <lambdabot>  Any {getAny = False}
02:39:01 <shiona> bitemyapp: well, () has a limited number of possible values, so it is bounded
02:39:03 <b0bbi10> why's that? () is a type member of Eq, why is there no succ?
02:39:17 <jle`> b0bbi10: succ of the maximum element is spec'd as error
02:39:19 <merijn> b0bbi10: What does succ have to do with Eq?
02:39:36 <Iceland_jack> b0bbi10: 'succ' has nothing to do with Eq but rather Enum
02:39:40 <Iceland_jack> :t succ
02:39:41 <lambdabot> Enum a => a -> a
02:39:43 <jle`> > pred 0
02:39:44 <lambdabot>  -1
02:39:47 <b0bbi10> merijn: sorry, meant Enum
02:39:54 <shiona> succ would mean there is a next, greater element. () is the single element so there cannot be a greater one
02:39:54 <jle`> > pred False
02:39:55 <lambdabot>  *Exception: Prelude.Enum.Bool.pred: bad argument
02:40:02 <Iceland_jack> () is the only element of () so there is no succ or pred of ()
02:40:04 <merijn> b0bbi10: Well, what's the successor of the maximum element?
02:40:07 <bitemyapp> shiona: that makes sense, I just wasn't operating on a sufficient broad notion of "bounded". the directionality seems mostly arbitrary.
02:40:24 <bitemyapp> shiona: also, doesn't that mean any dependent type is bounded?
02:40:26 <b0bbi10> merijn: maximum + 1? ^^
02:40:34 <jle`> infinity times infinity
02:40:43 <bitemyapp> > (maxBound :: Int) + 1 :: Int
02:40:44 <lambdabot>  -9223372036854775808
02:40:45 * hackagebot sqlite-simple 0.4.5.2 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.5.2 (JanneHellsten)
02:40:53 <bitemyapp> sweet wraparound.
02:40:54 <jle`> > last ['\NUL'..]
02:40:54 <lambdabot>  '\1114111'
02:40:58 <bitemyapp> > (maxBound :: Int) + 0 :: Int
02:40:59 <lambdabot>  9223372036854775807
02:41:10 <jle`> > last [minBound..] :: Char
02:41:11 <lambdabot>  '\1114111'
02:41:16 <jle`> > last [minBound..] :: Int
02:41:19 <shiona> bitemyapp: I'm sorry but my theory is lacking on that end. I'll need to refresh on the notion of dependent type
02:41:20 <lambdabot>  mueval-core: Time limit exceeded
02:41:22 <haasn> > maxBound + 1 :: Integer
02:41:23 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
02:41:23 <lambdabot>    arising from a use of `GHC.Enum.maxBound'
02:41:23 <lambdabot>  Possible fix:
02:41:23 <lambdabot>    add an instance declaration for
02:41:23 <lambdabot>    (GHC.Enum.Bounded GHC.Integer.Type.Integer)
02:41:27 <shiona> I guess someone will give you an answer in the meantime
02:41:30 <bitemyapp> shiona: ADTs on steroids.
02:41:37 <bitemyapp> shiona: are all ADTs/sum types bounded?
02:41:41 <b0bbi10> you're confusing me more than helping me ;p anyway, try go go on with LYAH ;)
02:41:48 <jle`> heh
02:41:52 <\u> it
02:41:53 <bitemyapp> or is max/min notion neeed?
02:42:10 <bitemyapp> b0bbi10: *shrug*
02:42:20 <haasn> bitemyapp: what's the bound of ([()] -> Bool)?
02:42:21 <bitemyapp> none of this is hard, it's just easy to miss.
02:42:23 <jle`> also i don't like that Fractionals are Enum'd by +/- 1
02:42:29 <jle`> what gives
02:42:45 <bitemyapp> haasn: it's 0439 my time, don't make me think.
02:42:47 <jle`> also if there was a Real class I would hope it is not Enum
02:42:57 <bitemyapp> jle`: shouldn't it be +/- 1 of the numerator?
02:43:00 <jle`> *Real type
02:43:22 <haasn> although you could argue that one should be (const False) and (const True) :P
02:43:24 <jle`> bitemyapp: well not all Fractionals have a meaningful numerator/denominator concept...like Double
02:43:25 <bitemyapp> succ (succ 1/2 -> 2/2) -> 3/2
02:43:32 <haasn> successor gets more difficult though
02:43:55 <bitemyapp> jle`: really?
02:43:59 <bitemyapp> such as?
02:44:08 <jle`> > succ (1 :: Double)
02:44:09 <lambdabot>  2.0
02:44:16 <jle`> > succ 1.5 :: Double
02:44:16 <lambdabot>  2.5
02:44:28 <merijn> Enum instance of Double is evil
02:44:56 <jle`> why do non-integrals even have an Enum instnace :|
02:45:04 <ski> bitemyapp : where did the "dependent type" part come from ?
02:45:07 <quicksilver> because Enum isn't about enumeration
02:45:10 <quicksilver> it's entirely misnamed
02:45:12 <quicksilver> it's about ranges.
02:45:19 <shiona> jle`: how that's ugly
02:45:22 <erisco_> I feel like something is messed up... when I installed cabal 1.19.2 it installed to a completely different directory
02:45:22 <shiona> now*
02:45:25 <haasn> quicksilver: what does succ/pred have to do with ranges
02:45:26 <bitemyapp> ski: the conversation made me think of sum types, then I took it a step further.
02:45:30 <erisco_> and I think the databases are being confused
02:45:33 <quicksilver> > [1.1,1.2..]
02:45:34 <lambdabot>  [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.59999999...
02:45:44 <haasn> oh, those things
02:45:46 <ski> bitemyapp : sum types aren't that related to dependent types, in particular
02:45:50 <haasn> enumFromThen yeah
02:45:57 <ChongLi> quicksilver: now that's a thing of beauty; a succession of rounding errors
02:45:58 <haasn> > maxBound :: Double
02:45:59 <bitemyapp> ski: all the same.
02:45:59 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
02:45:59 <lambdabot>    arising from a use of `GHC.Enum.maxBound'
02:45:59 <lambdabot>  Possible fix:
02:45:59 <lambdabot>    add an instance declaration for (GHC.Enum.Bounded GHC.Types.Double)
02:46:01 <ski> bitemyapp : not anymore than product types or function types
02:46:03 <haasn> oh come on
02:46:10 <haasn> > succ (1/0 :: Double)
02:46:11 <lambdabot>  Infinity
02:46:16 <haasn> :(
02:46:18 <quicksilver> haasn: succ is used in principle in [1..]
02:46:31 <quicksilver> although not in practice
02:46:45 <quicksilver> the class is a conflation of two ideas but the range part has the lion's share
02:46:58 <quicksilver> it would be much better if there were two classes, Range and Enum
02:47:05 <quicksilver> but, then, hindsight is always easy :)
02:47:05 <shiona> > [1.1, 1.2 ..] :: [CReal]
02:47:07 <lambdabot>  [1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9...
02:47:27 <haasn> hmm. I don't quite see what the real difference between the terms is though; don't ranges basically exist to enumerate a list of values?
02:47:35 <haasn> nobody says it has to be a total order
02:47:47 <bitemyapp> sigh. I just typed ['\NUL' ..] in my ghci. I am not a clever man.
02:47:53 <quicksilver> it would be useful to have a type which was actually for completly enumerating types
02:48:02 <erisco_> is there some environment variable or something that cabal uses to locate the database?
02:48:12 <quicksilver> it might even be useful to have one for finite enumerations and one for infinite ones
02:48:14 <haasn> > ['\NUL' ..]
02:48:15 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
02:48:37 <quicksilver> whereas ranges make sense even for types we don't think of as enumerable
02:48:41 <bitemyapp> haasn: it just keeps going...
02:48:44 <haasn> bitemyapp: ^C
02:48:48 <haasn> erisco_: http://www.vex.net/~trebla/haskell/sicp.xhtml
02:48:54 <bitemyapp> haasn: I know, but I felt silly anyway.
02:48:55 <ski> > "\SO" ++ "HO"
02:48:55 <lambdabot>  "\SO\&HO"
02:49:04 <haasn> ski: cute
02:49:16 <merijn> bitemyapp: It'll stop...eventually :p
02:49:23 <merijn> bitemyapp: After enumerating all unicode xD
02:49:31 <erisco_> haasn, oh that might be why... when I installed the Haskell platform I probably did a global install
02:49:40 <ski> > last ['\NUL' ..]
02:49:41 <lambdabot>  '\1114111'
02:49:47 <jle`> > ['a'..'z']
02:49:48 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
02:49:49 <erisco_> haasn, whereas when I installed cabal 1.19.2 it must have installed locally
02:50:03 <ski> > filter isAlpha ['\NUL' ..]
02:50:04 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
02:50:32 <haasn> > text $ filter isAlpha ['\0'..]
02:50:33 <jle`> > last [minBound..] :: Int
02:50:33 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzªµºÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔ...
02:50:36 <lambdabot>  mueval-core: Time limit exceeded
02:50:46 <bitemyapp> you made it mad.
02:50:49 <jle`> i wish there was a shorthand for [minBound..maxBound]
02:51:02 <Iceland_jack> it should be [..]
02:51:12 <haasn> and unrelated to Bounded
02:51:15 <Iceland_jack> There should also be a shorthand for [..n]
02:51:46 <zettablade> isn't [..n] already shorthand-y?
02:52:00 <jle`> > [..'a']
02:52:01 <lambdabot>  <hint>:1:2: parse error on input `..'
02:52:13 <jle`> > [minBound..'a']
02:52:14 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
02:52:32 <CindyLinz> > [minBound..7]
02:52:33 <lambdabot>  No instance for (GHC.Show.Show t0)
02:52:33 <lambdabot>    arising from a use of `M14900746799960651073520.show_M14900746799960651073...
02:52:33 <lambdabot>  The type variable `t0' is ambiguous
02:52:33 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:52:33 <lambdabot>  Note: there are several potential instances:
02:52:35 <Iceland_jack> zettablade: no
02:52:36 <jle`> i will use my time machine to travel to the report authors
02:52:37 <CindyLinz> > [minBound..7.0]
02:52:38 <lambdabot>  No instance for (GHC.Show.Show t0)
02:52:38 <lambdabot>    arising from a use of `M14050681768374061203531.show_M14050681768374061203...
02:52:39 <lambdabot>  The type variable `t0' is ambiguous
02:52:40 <CindyLinz> XD
02:52:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:52:43 <lambdabot>  Note: there are several potential instances:
02:52:48 <Iceland_jack> You can't write
02:52:48 <Iceland_jack> > [..'a']
02:52:49 <lambdabot>  <hint>:1:2: parse error on input `..'
02:52:49 <Iceland_jack> to mean
02:52:53 <Iceland_jack> > [minBound..'a']
02:52:54 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
02:53:07 <erisco_> well I set --package-db explicitly and no change... sigh
02:53:10 <jle`> Iceland_jack: he means that [..n] is the shorthand, [minBound..n] is what the shorthand is for
02:53:12 <haasn> zettablade: no, it's way too long - it should be n̈
02:53:37 <Iceland_jack> right, it's not actual Haskell though
02:53:46 <haasn> jle`: you mean (enumTo n)
02:53:49 <ChongLi> erisco_: I think vagrant may really help here
02:53:58 <ChongLi> get a nice clean VM running
02:54:05 <ChongLi> and install ghc 7.8 in that
02:54:17 <jle`> > enumTo 'a'
02:54:18 <lambdabot>  Not in scope: `enumTo'
02:54:18 <lambdabot>  Perhaps you meant `enum' (imported from Control.Lens)
02:54:27 <jle`> :t enum
02:54:28 <lambdabot> (Enum a, Functor f, Profunctor p) => p a (f a) -> p Int (f Int)
02:54:33 <jle`> oh yes of course
02:54:36 <erisco_> ChongLi, hopefully... I'll try that next
02:54:54 <haasn> jle`: I mean; if [..n] was actual syntax it should be (enumTo n) and *not* [minBound..n]
02:55:02 <erisco_> ChongLi, I don't really like VMs because all my dev tools are on the host machine
02:55:03 <haasn> Bounded should never have anything to do with Enum..
02:55:12 <erisco_> ChongLi, and it is a pain to shift files around to compile
02:55:13 <haasn> and certainly not with built-in syntax like that
02:55:19 <jle`> that makes sense
02:55:22 <jle`> i can agree
02:55:25 <ChongLi> erisco_: just share a directory
02:55:42 <jle`> > map (digitToInt . isDigit) (enumFrom minBound)
02:55:43 <lambdabot>  Couldn't match type `GHC.Types.Bool' with `GHC.Types.Char'
02:55:43 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Types.Char
02:55:43 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Bool
02:55:49 <erisco_> ChongLi, hopefully I can... when I tried it years ago with Ubuntu it constantly had problems
02:55:51 <ChongLi> and use putty to ssh into the VM for compiling
02:56:12 <ChongLi> you likely don't want a graphical install anyway
02:56:14 <jle`> > map digitToInt . filter isDigit . enumFrom $ minBound
02:56:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
02:56:31 <haasn> afaik the only rule related Enum and Bounded says your program should crash if you use them together.
02:56:35 <haasn> relating*
02:56:46 <jle`> haasn: haha
02:57:17 <haasn> oh, it does seem like enumFrom x = enumFromTo x maxBound -- must hold
03:01:32 <haasn> huh. Apparently (:~:) is an instance of Enum and Bounded.
03:01:39 <haasn> for what purpose I cannot possibly imagine
03:01:49 <ski> @hoogle (:~:)
03:01:49 <lambdabot> No results found
03:02:09 <haasn> ski: data a :~: b where Refl :: a :~: a
03:03:49 <ski> oh, equality
03:04:37 <ski> i presume it's `a :~: a' which is an instance
03:05:22 <quicksilver> minBound = Refl; maxBound = Refl; Refl == Refl = True;
03:05:32 <quicksilver> not much choice on the instances really
03:05:39 <Iceland_jack> quicksilver: Exactly
03:05:59 <Iceland_jack> but presumably for the same reasons as () being an instance of Bounded, etc
03:07:53 <b_jonas> what's this :~: thing? it's in what modile?
03:08:09 <haasn> quicksilver: fromInt 0 = Refl; fromInt _ = undefined;  succ _ = undefined; pred _ = undefined -- this one is the sillier thing
03:08:21 <b_jonas> apparently multiple, according to Hayoo
03:08:40 <haasn> b_jonas: base 4.7
03:08:44 <haasn> Prelude
03:08:47 <haasn> err, not Prelude
03:08:55 <haasn> Data.Type.Equality
03:08:56 <quicksilver> > succ ()
03:08:57 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
03:09:15 <Iceland_jack> b_jonas: It's type-level equality
03:09:16 <quicksilver> haasn: seems consistent with ()
03:09:29 <haasn> quicksilver: I guess so
03:09:35 <Iceland_jack> defined as
03:09:35 <Iceland_jack>     data a :~: b where
03:09:35 <Iceland_jack>       Refl :: a :~: a
03:09:40 <b_jonas> hmm
03:09:42 <Iceland_jack> So propositional equality
03:09:45 <haasn> quicksilver: I can't fathom a use case for instance (a ~ b) => Enum (a :~: b) though
03:09:52 <haasn> quicksilver: about as little as I can fathom a use case for instance Enum (), to be fair
03:10:10 <ski> quicksilver : well, i suppose there's a choice between `instance Bounded (a :~: a)' and `instance a ~ b => Bounded (a :~: b)'
03:10:29 <haasn> ski: it's the latter instance
03:10:34 <Iceland_jack> b_jonas: ‘a :~: b’ is inhabited implies that ‘a’ and ‘b’ are the same types
03:10:37 <haasn> the former one is just worse for resolution
03:10:47 <Iceland_jack> inhabited by a value that isn't bottom
03:10:54 <ski> haasn : and imo, it ought to be `succ Refl = undefined, &c.
03:11:08 <haasn> ski: imo, it shouldn't be an instance
03:11:18 <ski> so that if you pass `error "blah"', that gets blamed
03:11:22 <b_jonas> so it's like a type of proofs that a and b are the same type?
03:11:29 <Iceland_jack> b_jonas: yes
03:11:30 <ski> haasn : hm, ok. why ?
03:11:37 <haasn> ski: why would it be an instance?
03:11:42 <ski> why not ?
03:11:55 <ski> `a :~: a' is iso to `()'
03:12:02 <haasn> I don't see why () should be an instance either
03:12:19 <ski> @instances Bounded
03:12:19 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
03:12:24 <jle`> for [()..] of course.
03:12:40 <jle`> hm.
03:12:46 <jle`> @instances Ord
03:12:47 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:12:47 <ski> you have `instance (Bounded a,Bounded b) => Bounded (a,b)', so it only makes sense to also have `instance Bounded ()'
03:13:23 <jle`> is [a] really ord? i never noticed
03:13:24 <haasn> Hmm, perhaps if only to satisfy OCD
03:13:30 <ski> jle` : really ?
03:13:32 <haasn> jle`: never compared strings?
03:13:33 <jle`> > [2,2,5] < [2,2,4}
03:13:34 <lambdabot>  <hint>:1:17: parse error on input `}'
03:13:36 <jle`> > [2,2,5] < [2,2,4]
03:13:37 <lambdabot>  False
03:13:38 <jle`> ah yeah
03:13:40 <jle`> i have compared strings
03:13:48 <jle`> > compare [2,2,5] [2,2,4]
03:13:49 <lambdabot>  GT
03:14:07 <ski> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")  -- jle`, you missed this ?
03:14:08 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
03:14:16 <haasn> to be fair, I don't think I've ever used Enum on a type where it doesn't make sense and I doubt I ever will; the type class is too broken by design to be of much use
03:14:18 <b_jonas> crazy
03:14:33 <jle`> ski: i might have learned it when learning haskell but i never consciously used it
03:14:33 <haasn> I've used it for numerics and characters and that's about it
03:14:43 <jle`> although i probably use it with Data.Map
03:14:47 <jle`> with strings as keys
03:14:51 <haasn> > [(1,1)..(3,3)]
03:14:52 <lambdabot>  No instance for (GHC.Show.Show t1)
03:14:52 <lambdabot>    arising from a use of `M37469408725757679253683.show_M37469408725757679253...
03:14:52 <lambdabot>  The type variable `t1' is ambiguous
03:14:52 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
03:14:52 <lambdabot>  Note: there are several potential instances:
03:14:55 <Iceland_jack> b_jonas: It's standard in dependently-typed languages
03:15:15 <ski> (Iceland_jack : ooc, what is ?)
03:15:25 <haasn> ski: oh, there isn't an instance Enum (a,b) after all - just Bounded
03:15:26 <jle`> > [(1,1)..(3,3)] :: [(Int,Int)]
03:15:27 <lambdabot>  No instance for (GHC.Enum.Enum (GHC.Types.Int, GHC.Types.Int))
03:15:27 <lambdabot>    arising from the arithmetic sequence `(1, 1) .. (3, 3)'
03:15:27 <lambdabot>  Possible fix:
03:15:27 <lambdabot>    add an instance declaration for
03:15:27 <lambdabot>    (GHC.Enum.Enum (GHC.Types.Int, GHC.Types.Int))
03:15:30 <Iceland_jack> Defining propositional equality as a data type
03:15:37 <b_jonas> ski: (Data.Type.Equality.:~:)
03:15:37 <jle`> wut
03:15:47 <ski> haasn : yes
03:15:58 <ski> b_jonas : oh, right
03:16:31 <ski> > range ((1,1),(3,3))
03:16:32 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:16:43 <Iceland_jack> b_jonas: It becomes necessary for example when parsing from an untyped format to certain types of GADTs
03:17:09 <haasn> :t range
03:17:10 <lambdabot> Ix a => (a, a) -> [a]
03:17:15 <haasn> > range ('a','z')
03:17:15 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
03:17:26 <haasn> a replacement for Enum that actually makes sense?!
03:17:28 <Iceland_jack> Like if you plan on parsing
03:17:28 <Iceland_jack>     IfThenElse ∷ Expr Bool → Expr a → Expr a → Expr a
03:17:28 <Iceland_jack> you need a proof that the then/else branches have the same type
03:17:35 <ski> `Ix' is for arrays
03:17:52 <ski> i suppose `range' could be said to give an interval
03:18:04 <b_jonas> not really
03:18:18 <b_jonas> > range ((0,0),(3,3))
03:18:20 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
03:19:07 <ski> b_jonas : in the sense of "interval" in order theory, for an arbitrary partial order
03:19:16 <haasn> ski: seems pretty equivalent to “fromEnum” to me; the only thing that's really missing is open ranges eg. [1..]
03:19:22 <Iceland_jack> > let (...) = (,) in range ((0,0)...(3,3))
03:19:23 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
03:19:36 <b_jonas> ski: hmm, maybe
03:19:44 <haasn> > range (9,1)
03:19:45 <lambdabot>  []
03:20:11 <jle`> > let (...) = (,) in (,2) 3
03:20:12 <lambdabot>  (3,2)
03:20:17 <jle`> > (,2) 3
03:20:18 <lambdabot>  can't find file: L.hs
03:20:33 <ski> so the (closed) interval between ⌜a⌝ and ⌜b⌝ is the subset ⌜{x | a ≤ x ≤ b}⌝
03:20:33 <jle`> wait what just happened
03:20:40 <haasn> > quickCheck $ \x y -> rangeSize (x,y::Int) == max 0 (fromEnum y - fromEnum x)
03:20:41 <lambdabot>  <IO ()>
03:20:45 <haasn> ... :(
03:20:46 <jle`> > let (...) = (,) in (...2) 3
03:20:47 <lambdabot>  (3,2)
03:20:49 <ski> jle` : race condition, probably
03:20:56 <jle`> > (,2) 3
03:20:56 * hackagebot ixmonad 0.1 - Indexed monads library  http://hackage.haskell.org/package/ixmonad-0.1 (DominicOrchard)
03:20:57 <lambdabot>  (3,2)
03:20:59 <b_jonas> > range ((LT,LT),(EQ,EQ))
03:21:00 <lambdabot>  [(LT,LT),(LT,EQ),(EQ,LT),(EQ,EQ)]
03:21:10 <jle`> does the (...3) work without tuple sections?
03:21:11 <b_jonas> > enumFromTo (LT,LT) (EQ,EQ)
03:21:11 <lambdabot>  No instance for (GHC.Enum.Enum
03:21:12 <lambdabot>                     (GHC.Types.Ordering, GHC.Types.Ordering))
03:21:12 <lambdabot>    arising from a use of `GHC.Enum.enumFromTo'
03:21:12 <lambdabot>  Possible fix:
03:21:12 <lambdabot>    add an instance declaration for
03:21:16 <haasn> > range ((),())
03:21:17 <lambdabot>  [()]
03:21:24 <ski> @check \x y -> rangeSize (x,y::Int) == max 0 (fromEnum y - fromEnum x)
03:21:25 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
03:21:25 <haasn> this is really a better Enum. I like it
03:21:26 <lambdabot>  0 0
03:21:28 <ski> haasn ^
03:21:38 <haasn> ski: ah, okay
03:21:46 <haasn> > range (0,0)
03:21:47 <lambdabot>  [0]
03:21:50 <haasn> different semantics here
03:21:52 <haasn> > [0..0]
03:21:53 <lambdabot>  [0]
03:21:57 <haasn> or not!
03:22:35 <therealhunt> if i have a main file
03:22:36 <quicksilver> Ix and Enum overlap considerably
03:22:43 <therealhunt> with a simple type declared
03:22:47 <quicksilver> but a key difference is in their semantics for tuples
03:22:54 <ski> b_jonas : aiui, `Enum' assumes a total order
03:23:00 <therealhunt> like data Bound = Bound {width::Int,height::Int}
03:23:07 <therealhunt> how can i use this type in non main fyles
03:23:09 <therealhunt> files
03:23:10 <haasn> @check \x y i -> inRange (x,y) (i::Int) == (fromEnum i >= fromEnum x && fromEnum i <= fromEnum y)
03:23:11 <lambdabot>  +++ OK, passed 100 tests.
03:23:18 <quicksilver> > range ((1,1),(3,3))
03:23:20 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:23:25 <b_jonas> > (LT,GT)<(EQ,EQ)
03:23:26 <lambdabot>  True
03:23:29 <quicksilver> > [(1,1)..(3,3)]
03:23:30 <lambdabot>  No instance for (GHC.Show.Show t1)
03:23:30 <lambdabot>    arising from a use of `M4619257673021980093961.show_M4619257673021980093961'
03:23:30 <lambdabot>  The type variable `t1' is ambiguous
03:23:30 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
03:23:30 <lambdabot>  Note: there are several potential instances:
03:23:30 <b_jonas> ^ ski: total order
03:23:54 <ski> b_jonas : but that's not using `Enum'
03:24:13 <b_jonas> sure
03:24:47 <quicksilver> therealhunt: you can 'import Main' in the other module although that's not the normal way
03:24:50 <jle`> therealhunt: you would import Main...i think...
03:24:53 <jle`> but...
03:24:56 <jle`> yeah
03:24:58 <jle`> see quicksilver
03:25:06 <quicksilver> therealhunt: the normal way is to put the data type in anothr module, which you import into Main (and whereever else)
03:25:27 <jle`> main should be where you import everything else and then wrap everything up
03:25:39 <quicksilver> ski: Enum is compatible with the Ord order
03:25:47 <quicksilver> ski: Ix also defines a total order but a different one
03:25:47 <jle`> besides...if you import Main in a module...you can't import that other module into Main
03:25:48 <johnw> my projects already start with a file named Types.hs
03:25:51 <jle`> so there isn't really any point
03:25:53 <johnw> always*
03:25:53 <quicksilver> ski: (on tuples in particular)
03:25:57 * hackagebot tasty-rerun 1.1.2 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.1.2 (OliverCharles)
03:26:06 <quicksilver> jle`: according to the language standard you can :)
03:26:07 <jle`> since whatever you import Main with, can't be eventually used to build the binary (Main can't import it)
03:26:12 <jle`> quicksilver: ah, really?
03:26:16 <quicksilver> unfortunately(?) GHC makes you jump through hoops
03:26:17 <haasn> johnw: mine start with “import Control.Lens”
03:26:27 <quicksilver> the haskell language explicitly permits recursive imports
03:26:36 <jle`> mine start with import Prelude ()
03:26:43 <quicksilver> but the GHC implementation of it is cumbersome
03:26:50 <merijn> I hate GHC not supporting recursive imports
03:26:50 <jle`> quicksilver: really? i'll look into that
03:26:56 <jle`> that sounds interesting
03:26:58 <haasn> merijn: maybe that should be a GSOC project :)
03:26:59 <merijn> quicksilver: GHC doesn't have an implementation of recursive imports
03:27:01 <jle`> but i wonder how the semantics would even work
03:27:05 <merijn> quicksilver: It has a lame ass workaround
03:27:10 <johnw> GHC allows the use of boot files
03:27:11 * quicksilver shrugs
03:27:15 <quicksilver> it's an implementation
03:27:17 <johnw> which I do use, and they are awkward
03:27:18 <quicksilver> it's not an automatic one
03:27:47 <haasn> I wonder how easily boot files could be auto-generated from the source files
03:28:00 <haasn> just extract all the known type sigs and data type declarations?
03:28:01 <therealhunt> can i import Data.List into a module and import that module to main
03:28:08 <merijn> haasn: Yes, now I just need to find a gullible student to implement it for me :p
03:28:14 <jle`> therealhunt: yes you can
03:28:30 <merijn> haasn: The problem is mutually recursive types
03:28:35 <haasn> that way the user would only have to intervene for exported values with an unknown signature
03:28:49 <jle`> but you would have to import Data.List into Main as well to use functions from Data.List.  unless you exported explicitly from your other module
03:29:01 <haasn> merijn: only when type inferencing, no?
03:29:13 <quicksilver> I seem to recall that java has a non-confluent implementation of recursive imports
03:29:16 <therealhunt> ok followup question
03:29:18 <quicksilver> or maybe it used to
03:29:28 <merijn> haasn: Stuff like "data Foo = Foo (Maybe Bar)" and "data Bar = Bar (Maybe Foo)"
03:29:34 <therealhunt> if i have a polymorphous data type can i put a constraint on it?
03:29:34 <quicksilver> so you could get into a state which was only possible due to the sequence of code changes and recompiles you had done
03:29:41 <quicksilver> and couldn't be reached on a clean compile
03:29:46 <merijn> therealhunt: Define "put a constraint on it"
03:29:49 <jle`> therealhunt: you can with a language extension but you shouldn't
03:29:53 <merijn> therealhunt: What should the constraint do
03:30:02 <therealhunt> i have a bound type that i only want to contain nums
03:30:02 <quicksilver> you can put a constraint on values of it, though
03:30:19 <ski> quicksilver : hm, example of "Ix also defines a total order but a different one" ?
03:30:25 <merijn> jle`: It's deprecated, so he still shouldn't
03:30:53 <jle`> therealhunt: what kind of usage did you have in mind?
03:31:05 <ski> "non-confluent implementation of recursive imports" ?
03:31:11 <therealhunt> using the ratio between two bounds to convert numbers
03:31:18 <therealhunt> jle` ^
03:31:22 <ski> hm
03:31:28 <jle`> therealhunt: typically the solution is to enforce the constraint at the actual function that uses it
03:31:43 <jle`> so have the constraint for the converting function
03:31:55 <therealhunt> jle` oh actually that makes sense, and ive done that, i jsut havent slept tonight or something
03:32:03 <jle`> therealhunt: np :)
03:32:17 <jle`> Data.Map does this
03:32:46 <jle`> your keys can be of any values technically but you can only insert, lookup, etc. with Ord k
03:33:06 <ski> @type Data.Map.empty
03:33:07 <jle`> and functions that don't involve k (like fmap) don't need the constraint
03:33:07 <lambdabot> M.Map k a
03:33:22 <jle`> that too
03:33:40 <quicksilver> ski: hmm well it's a compatible order. But a way of identifying specific subset of it.
03:33:44 <ski> (/me prefers saying s/functions/operations/ in such contexts, for this reason)
03:34:00 <quicksilver> ski: range ((1,1),(3,3)) is well defined and produces a list which is Ord-ordered
03:34:05 <ski> yes
03:34:14 <quicksilver> ski: but [(1,1)..(3,3)] is not defined
03:34:35 <quicksilver> ski: and the unwritten rule - I think - is that any implementation of Enum must respect Ord
03:34:39 <jle`> (1..3) x (1..3)
03:34:48 <ski> however i think of it as some topological sort of the corresponding partial order, that happens to be `Ord'-compatible in this case, for convenience(?) probably
03:34:55 <quicksilver> ski: so there is no possible implementation of Enum for (Integer,Integer)
03:35:16 <ski> quicksilver : i dislike such interactions between classes where one isn't a subclass of the other
03:35:24 <quicksilver> the unfair diagonal ones will enumerate
03:35:28 <quicksilver> but they will violate Ord
03:35:39 <ski> (since it has the third-party problem)
03:35:49 <quicksilver> ski: it's a fair point, and I can't claim to reconstruct the committee's train of thought as they broke these classes up :)
03:35:57 <quicksilver> I'm just abducting from data points
03:36:02 * ski nods
03:37:04 <quicksilver> ski: on the non-confluent compilation in Java: If A <--> B, then if you modify both A *and* B and recompile, then 'A' would recompile against the interface of the *old* B.
03:37:28 <quicksilver> ski: with careful deliberate recompilation and understanding of how the inliner works, you could sneak all kinds of weird stuff in
03:37:52 <quicksilver> that was probably Java 1.0 / 1.1 and they may well have fixed it.
03:37:57 <ski> that's bad
03:38:07 <quicksilver> very bad, yes.
03:38:54 <quicksilver> they also broke separate compilation because the inliner would simplify method dispatch into a function call, where it could see they were never overridden by subclasses
03:39:15 <quicksilver> so when you later added a subclass, previously compiled code didn't notice the subclass and exhibited 'impossible' behaviour.
03:39:25 <quicksilver> turns out that writing new languages and compilers in a hurry is quite hard.
03:40:39 <tdammers> quicksilver: considering that, javascript isn't that bad
03:40:50 <quicksilver> yes, javascript really isn't bad at all
03:41:12 <quicksilver> the implicit local scope being an object / ability to modify local scope is horrendous
03:41:20 <quicksilver> from a security perspective
03:41:23 <quicksilver> other than that...
03:41:24 <tdammers> of course
03:41:38 <tdammers> I mean, it's a dynamic language... they're all pretty horrible in that regard
03:41:41 <quicksilver> it's probably my favourite of the perl/python/lua/ruby/javascript school.
03:41:55 <tdammers> same here
03:42:06 <tdammers> I have to dive deeper into ruby to form a final opinion there
03:42:11 <tdammers> but it does beat the rest of the bunch
03:42:38 <jle`> ruby/js definitely stand out out of the gang to me
03:43:14 <jle`> ruby seems to be a language that combines the best of all of the paradigms in a way that isn't horrible
03:43:32 <ski> of all which paradigms ?
03:43:33 <jle`> so from a design standpoint i kind of appreciate it
03:44:05 <jle`> er, the best parts of many useful languages
03:44:10 <jle`> sorry, not paradigms.
03:44:49 <tdammers> they're all very similar, really
03:44:56 <luite> hmm
03:45:05 <tdammers> ruby and js just sit in two different sweet spots
03:45:18 <jle`> it's the best of perl, the 'best of lisp', the best of traditional oop
03:45:37 <jle`> smalltalk inspired
03:45:52 <jle`> but at this point i'm just parroting yegge
03:46:14 <quicksilver> I have prejudices which make it hard for me to like ruby
03:46:15 <jle`> javascript has some nice language design choices in its own way
03:46:22 <quicksilver> I should probalby get over them and look at it properly some day
03:47:14 <tdammers> ruby has had enough proper thought put into it; javascript was made in such a hurry that there simply wasn't time to go overboard, and keeping it utterly simple was the only hope
03:47:42 <tdammers> python also had a lot of thought put into it, but for some reason, the result seems less pleasant
03:48:01 <jle`> at least javascript idioms are commonly functional, and the entire language style revolves around continuation passing
03:48:12 <tdammers> yes, indeed
03:48:20 <quicksilver> tdammers: perhaps mere thought isn't enough, perhaps it depends who is doing the thinking ;)
03:48:26 <jle`> quicksilver: :P
03:48:28 <bartavelle> quicksilver, +1
03:48:28 <tdammers> quicksilver: certainly
03:48:53 <bartavelle> ruby is just about the worst language to have applications written with in production
03:49:10 <bartavelle> it might be pleasant for developpers, but it's a nightmare to me
03:49:10 <tdammers> bartavelle: challenge accepted
03:49:14 <bartavelle> heh
03:49:19 <tdammers> I raise you PHP
03:49:19 <jle`> i never could really come to appreciate python.  the community is one of the strongest though, it's a shame and for such a great community they deserve a better language
03:49:29 <tdammers> jle`: could not agree more
03:49:30 <benj_> ha
03:49:35 <bartavelle> tdammers, PHP is reasonnably fast, and you can specify a maximum amount of memory it can use
03:49:43 <tdammers> bartavelle: PHP is not fast
03:49:55 <bartavelle> compared to ruby it's extremely fast
03:49:55 <tdammers> bartavelle: PHP wins speed by sacrificing correctness
03:49:59 <bartavelle> with a good code cache
03:50:13 <tdammers> would you please just shut up about caching
03:50:32 <bartavelle> I am not arguing PHP is a nice thing to have in production, but it's miles ahead of ruby
03:50:38 <tdammers> php folks are all like "yeah, I know, it's slow, but that doesn't matter, we'll just cache it"
03:50:45 <tdammers> so, anyway
03:50:55 <tdammers> PHP is a nightmare from a security perspective
03:51:00 * hackagebot bson 0.2.4 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.4 (MaximMitroshin)
03:51:01 <tdammers> way too much attack surface
03:51:01 <bartavelle> so isruby
03:51:08 <tdammers> way too many places to configure it
03:51:09 <bartavelle> all deserialization has code execution by default
03:51:20 <jle`> is the problem with php or with apache?
03:51:35 <jle`> (i really do not know enough about the ecosystem)
03:51:49 <tdammers> both, really, and especially how they are commonly tied together
03:51:58 <bartavelle> well PHP has terrible security features, it is probably worse on that front than ruby
03:52:23 <tdammers> for starters, there's the weird way PHP relies on apache for its routing
03:52:26 <jle`> i still get alerts all the time from a new deserialization bug in ruby that makes all ruby apps vulnerable
03:52:44 <tdammers> it's not like you have one process that sits behind apache and receives all the requests
03:52:51 <bartavelle> tdammers, I also like how if you fork a PHP process you retain all of apache file handles
03:52:51 <jle`> i mean it really shouldn't be that hard to parse a number, come on.
03:53:02 <therealhunt> how do i export value constructors with the same name as their type?
03:53:19 <tdammers> jle`: there's an accepted standard solution for this, called JSON
03:53:21 <jle`> therealhunt: you export constructors with Foo(Bar,Baz) etc.
03:53:23 <bartavelle> jle`, most of those are features. Apparently it seems like a good idea to most ruby developper to add code evaluation everywhere they can
03:53:33 <jle`> therealhunt: you can export all with Foo(..)
03:53:34 <therealhunt> jle` thanks again
03:54:09 <bartavelle> tdammers, well, the yaml library used in RoR had arbitrary code execution as a feature, not so far from JSON :)
03:54:27 <tdammers> yaml is an order of magnitude more complex
03:54:33 <ski> therealhunt : or `module Blah (Foo (Foo,Bar))'
03:54:36 <tdammers> json is simple on purpose
03:54:53 <bartavelle> oh sorry it also affected JSON
03:54:55 <ski> (oh, missed jle`s first answer)
03:55:01 <bartavelle> https://www.rapid7.com/db/modules/exploit/multi/http/rails_json_yaml_code_exec
03:55:03 <tdammers> then the JSON implementation was broken
03:55:10 <bartavelle> well yes, obviously
03:55:12 <jle`> tdammers: json the spec is, implementation is a different story
03:55:15 <bartavelle> but it was a *feature* to them
03:55:29 <tdammers> then the problem is in the culture, not the language
03:55:36 <tdammers> but then, the same can be said about PHP
03:55:38 <bartavelle> true
03:55:50 <bartavelle> that's why I am saying ruby applications are a nightmare to support
03:55:56 <cleatoma> I'm not sure it's that useful to separate the two. But then that's probably why I'm a python programmer...
03:56:15 <bartavelle> the language itself is pretty horrendous with monkey patching, code blocks that can access variables from the context they are called ...
03:56:30 <bartavelle> anyway, all of this is probably off topic
03:56:42 <jle`> monkey patching is kind of silly but when ruby was new everyone was doing it like it was the best thing ever
03:57:05 <tdammers> in all fairness, I monkey-patch Javascript objects all the tie
03:57:07 <tdammers> *time
03:58:06 <haasn> Hmm.. I'm awfully curious about how well hs-boot files actually work in practice
03:58:14 <haasn> Can you specify multiple boot files?
03:58:25 <haasn> for a single module, that is
03:59:54 <haasn> And how well do they work in the presence of DataKinds?
04:00:10 <fly2web> divideByTen :: (Floating a) => a -> a
04:00:10 <fly2web> divideByTen = (/10)
04:00:18 <fly2web> ----> how can it take parameter?
04:00:28 <fly2web> like divideByTen 300
04:00:52 <bartavelle> fly2web, just like "divideByTen 300" ?
04:01:08 <bartavelle> or is your question "how does that work?"
04:01:12 <}}}> any advice on reducing ghc binary size?
04:01:33 <fly2web> it is not like 'divideByTen x' but just 'kivideByTen'
04:01:45 * haasn .oO( is }}} beaky? )
04:01:47 <fly2web> divideByTen
04:02:11 <quicksilver> fly2web: yes, that doesn't matter
04:02:22 <fly2web> why?
04:02:25 <quicksilver> you don't need to specify the parameter name to define a function
04:02:33 <bartavelle> fly2web: "divideByTen x = x / 10" and "divideByTen = (/10)" and "divideByTen = \x -> x / 10" are the same thing
04:02:43 <quicksilver> add2 x = 2 + x; add2 = (2+); -- two ways of saying the same thing
04:02:47 <fly2web> oh i see. thanks
04:03:05 <fly2web> thanks bartavelle and quicksilver
04:03:50 <}}}> is partial function application like ctors in oop
04:04:20 <tdammers> }}}: no
04:04:57 <tdammers> it's like taking a function and turning it into another function that has some of the arguments filled in already
04:05:10 <tdammers> in a c-ish language, it'd look something like this:
04:05:19 <tdammers> g = partial(f, 1, 2, 3); g(4);
04:05:31 <tdammers> which would be equivalent to f(1, 2, 3, 4)
04:05:41 <}}}> so its more like std::bind in c++
04:05:59 <tdammers> I'd have to look that up
04:06:03 <haasn> yep, looks like }}} is beaky
04:06:04 <tdammers> haven't done a lot of C++ lately
04:06:04 <quicksilver> yes, it is
04:06:14 <quicksilver> it's std::bind but with less syntax
04:06:41 <}}}> its incredible how little syntax there is in haskell compared to e.g. java or C
04:06:45 <}}}> or C++*
04:06:56 <haasn> bartavelle: modulo DMR
04:07:54 <}}}> doing functional programming in those other languages would be a pain
04:09:24 <haasn> fsvo “c-ish”
04:09:56 <bartavelle> DMR ? (d* monomorphic restriction ?)
04:10:02 <haasn> dreaded
04:10:03 <byorgey> Dreaded
04:10:05 <bartavelle> ah !
04:10:05 <}}}> denis richie
04:10:11 <}}}> oh
04:10:38 <byorgey> haha, is Dennis Ritchie's middle initial M? that would be a funny coincidence
04:10:57 <byorgey> hah, it is!
04:10:58 <haasn> byorgey: Dennis MacAlistair Ritchie
04:11:02 <bartavelle> :)
04:11:28 <bartavelle> in 7.8, there is a change of behaviour, does that affect what I claimed ?
04:12:37 <haasn> what is this change of behavior you are referencing?
04:13:35 <bartavelle> hassn, not sure, got it from this link: http://www.reddit.com/r/haskell/comments/1zfz5m/a_superficial_exploration_of_haskell_part_2_lazy/cftbedk?context=3
04:13:47 <bartavelle> ah it's in ghc*i*
04:13:56 <quicksilver> just a change of the ghci default
04:14:00 <quicksilver> not a change to the language per se
04:14:06 <bartavelle> yes, I thought this affected GHC too
04:14:13 <quicksilver> it's always been a flag
04:14:19 <quicksilver> you're just looking at a change of *default*
04:14:43 <bartavelle> yeah, I knew it was a default change, but I thought it affected GHC, potentially affecting all programs
04:14:53 <bartavelle> but it seems it's just ghci
04:15:10 <quicksilver> GHC is pretty conservative about changes which would affect already written code
04:15:21 <quicksilver> changes which affect an interactive environment are probably lower-impact
04:15:32 <quicksilver> (although they are still annoying because they affect people following online tutorials etc)
04:15:43 <bartavelle> well, as I am still a bit foggy on how useful the DMR is, I can't really know how big an impact this makes
04:16:03 <bartavelle> (I mean I have no clue at all)
04:18:04 <jle`> DMR's useful cases are rarer in ghci
04:18:10 <jle`> or at least, you care a lot less
04:18:11 <haasn> “Haskell uses lazy evaluation by default” should be “GHC uses lazy evaluation by default”
04:18:16 <jle`> sorry, mixed that up
04:18:22 <jle`> DMR's harmful cases, you care about a lot less in ghcji
04:18:25 <jle`> it's late
04:18:28 <jle`> :|
04:18:45 <jle`> wait
04:19:02 <jle`> okay
04:19:24 <jle`> DMR's harmful cases are a lot more annoying in normal ghci usage
04:19:43 <haasn> “Laziness is the separation of equation from execution.” is it really? doesn't the equation happen when I type it into my text editor? or GHC reads the source file? What does execution have to do with evaluation?
04:19:47 <jle`> DMR's useful cases matter slightly less in ghci
04:19:48 <haasn> I don't think I like the linked article :
04:19:51 <haasn> :(
04:20:01 <quicksilver> haasn: haskell requires non-strict semantics but I recall the online report does imply full laziness in a couple of places
04:20:29 <haasn> quicksilver: I'd be interested to know if you have any examples
04:22:07 <haasn> “However, we notice the value 20 is fully evaluated as the head of list1 - this particular evaluation was necessary in order to construct the thunk (+1) 20.” was it really?
04:22:30 <ski> haasn : it's the separation of instantiation from computation (or rather, one way in which to effect such separation)
04:23:07 <haasn> ski: that sounds reasonable; I think I would try to define it in terms of reduction from the outside in
04:23:41 <ski> haasn : note that in logic programming, variable binding is separated from instantiation
04:24:50 <ski> binding is introducing the variable into the scope. instantiation is connecting the variable to a computation. and finally you perform the computation at some later time
04:26:06 <haasn> “The process of generating the thunks (+1) 25 through (+1) 70 will require all elements of list1 to be fully evaluated.” I do not think this is the case
04:26:20 <haasn> I think list1 gets evaluated because of “fromEnumTo” comparing it with the upper bound.
04:27:21 <haasn> if generating a thunk required evaluation then it wouldn't be lazy
04:29:48 <haasn> bartavelle: I'm quite sure the DMR primarily exists due to performance considerations (sharing work, inlining classes, etc.)
04:29:53 <quicksilver> haasn: outside-in, which is generally called "normal-order" doesn't require non-eager evaluation, though
04:30:02 <quicksilver> it's just a choice of ordering
04:30:05 <haasn> bartavelle: GHCi isn't really big on performance in the first place (or inlining)
04:30:13 <quicksilver> you can certainly have a normal-order language which is fully eager
04:30:38 <haasn> quicksilver: what about normal-order + nonstrictness?
04:30:45 <quicksilver> what about it?
04:30:46 <haasn> though I guess you could still stop at an error
04:30:53 <bartavelle> hassn: thanks, I always thought this was related to type inference implementation details
04:31:25 <haasn> bartavelle: there's also a type inferencing aspect of it. I imagine it would be possible to construct a scenario that compiles with the DMR but does not compile without it (with an ambiguous type error)
04:31:34 <ski> it's related to class constraints, and lack of type signature
04:31:54 <haasn> something like “a = read "hello"”, “b = show a”
04:32:11 <quicksilver> I believe it is just about expectation of sharing
04:32:46 <quicksilver> fibs = << Num-polymorphic definition of fibs here >>
04:32:58 <quicksilver> if that was indeed polymorphic then it couldn't be shared
04:33:03 <haasn> no, that wouldn't compile even with the DMR
04:33:06 <quicksilver> so each access would be expensive
04:33:18 <haasn> unless you have extended defaulting rules
04:33:26 <quicksilver> haasn: with the DMR it defaults to Integer
04:33:54 <quicksilver> without, it compiles fine as Num-polymorphic
04:33:56 <quicksilver> but gets no sharing
04:34:08 <haasn> wait, what happened to defaulting rules in GHCi? I thought GHCi defaulted everything as ()?
04:34:17 <haasn> (that did not fall under some other defaulting rule)
04:34:29 <quicksilver> the haskell committee felt that the lack of sharing of a non-function value was too surprising
04:34:34 <bartavelle> how does that work anyway ? I always thought that Num-polymorphic functions (for example) are compiled with a specialized copy for each type used in a program, is that the case ?
04:34:45 <haasn> bartavelle: only if you specialize them manually
04:34:47 <quicksilver> I think it's surprising that they thought that, because the haskell standard doesn't specify anything about sharing anyway
04:34:54 <quicksilver> bartavelle: it compiles to polymorphic code
04:35:00 <haasn> bartavelle: otherwise, GHC uses dictionary passing or something like it
04:35:04 <bartavelle> haasn, isn't that an optimizer's duty ?
04:35:08 <bartavelle> ok
04:35:09 <quicksilver> in GHC's implementation it takes a Num dictionary as a hidden parameter
04:35:11 <haasn> bartavelle: it is, yes
04:35:17 <quicksilver> other implementations exist.
04:35:48 <bartavelle> so the penalty is in finding the proper function in the Num dictionary and then jumping to it ?
04:36:33 <ski> hm, i suppose one could consider memoing on the constraint evidence
04:37:26 <quicksilver> bartavelle: there isn't any penalty for 'finding' it.
04:37:34 <quicksilver> it's always in the same place, it's a record access
04:37:38 <quicksilver> it's just another indirect jump
04:37:53 <quicksilver> the penalty is mostly in having to generate actual function calls
04:37:53 <bartavelle> ok
04:37:55 <quicksilver> rather than inlining.
04:39:26 <haasn> bartavelle: but re: optimizers keep in mind polymorphic functions which are exported across module/package boundaries, etc.
04:39:47 <bartavelle> yeah, that was my followup question :)
04:39:56 <haasn> you'd have to retroactively specialize them all for every use case; and there are also cases eg. rank-2 types in which is is simply not possible because you *need* to provide a polymorphic function
04:40:12 <bartavelle> as I thought everything was specialized, I did not understand how this worked with imported modules
04:40:16 <haasn> bartavelle: but with regards to specialization, have a look in the GHC user manual at the SPECIALIZE pragma
04:40:44 <Heather> someone knows if idris has something alike ForM_ ?
04:42:11 * hackagebot bson 0.2.4 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.2.4 (MaximMitroshin)
04:42:11 * hackagebot MFlow 0.4.2 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.2 (AlbertoCorona)
04:44:17 <bahamas> I have a function that takes several arguments and I receive those arguments in the form of a list. how can I apply the function to the args?
04:44:47 <bahamas> I'd use foldl, but I don't know what accumulator to use. this function returns IO ()
04:46:18 <quicksilver> you have to unpack the list
04:46:28 <quicksilver> let [a,b,c,d] = ls in f a b c d
04:46:31 <quicksilver> for example
04:52:26 <bahamas> quicksilver: ah. ok, thanks
04:53:01 <quicksilver> haskell doesn't have a polymorphic "apply list to function" function because that doesn't really make sense in haskell's type system
04:53:25 <quicksilver> javascript call/apply; LISP apply
04:54:45 <bahamas> I didn't know I could do let [a,b,c,d]. that's good to know
04:55:44 <quicksilver> you'll get a runtime error if you list isn't exactly 4 elements
04:55:52 <quicksilver> you might want to check that and handle it better
04:56:00 <quicksilver> but maybe you already know it has the right number of elements
04:56:12 <quicksilver> > let [a,b,c,d] = [1..5] in d
04:56:13 <lambdabot>  *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern [a,...
04:58:37 <bahamas> quicksilver: yeah, I check before
05:01:54 <vozz> Trying to learn some more advanced features of haskell, just learned about Monad Transformers and implementing your own Typeclasses... what else should I look into?
05:02:04 <khyperia> > let [a,b,c,d] = [1..4] in d
05:02:05 <lambdabot>  4
05:04:52 <quchen> vozz: There are lots of libraries to look at. Lens, Pipes, QuickCheck, STM, ST
05:05:42 <vozz> Is that pretty much it for advanced language features then? I'll give them a look
05:06:32 <Iceland_jack> vozz: What do you mean ‘is that it’? That's not an exhaustive list, they aren't even language features but libraries
05:07:07 <Iceland_jack> You can learn about all the extensions (DataKinds, TypeFamilies, …), learn about Core and read papers until you drop :)
05:07:18 <quchen> vozz: Monad transformers aren't a language feature. They're something useful you can make out of Haskell's language features.
05:08:11 <vozz> True... I don't really know what I'm asking
05:08:18 <quchen> Once you're through the first half of LYAH, you've learned pretty much the entirety of Haskell's language features.
05:08:27 <quchen> The rest is learning how to apply them.
05:08:54 <vozz> Are typeclasses not a language feature?
05:09:01 <quchen> Typeclasses are.
05:09:29 <vozz> I didn't mean 'is that it' in a bad way, was just wondering if it was just libraries from here on in
05:09:59 <vozz> Ah, I'll have a look into the extensions, thanks :)
05:10:45 <quchen> There are lots of libraries that use interesting concepts to do something useful. Learning these concepts may help you later on.
05:11:17 <Iceland_jack> vozz: You may also want to look at languages with more powerful type systems liked Idris, Agda, Coq, …
05:12:18 <vozz> It's not that I want more features or something, I'm very happy using haskell, it's just I want to learn enough to understand other people's code better
05:12:42 <Iceland_jack> They are a better place to learn about propositional equality like in
05:12:42 <Iceland_jack>     data a :~: b where
05:12:42 <Iceland_jack>         Refl :: a :~: a
05:12:42 <Iceland_jack> from Data.Type.Equality
05:13:09 <Iceland_jack> There is also a course called Advanced Functional Programming taught at Chalmers that you can look at
05:13:34 <vozz> Thanks a lot, I'll have a look
05:13:39 <Iceland_jack> also Data types à la carte
05:13:47 <Iceland_jack> and how to create your own embedded DSL
05:14:26 <vozz> This course looks really good
05:14:47 <Iceland_jack> You can then try to work on the assignments
05:14:53 <Iceland_jack> and make turtles and shit
05:15:03 <vozz> heh
05:27:21 <davd> @djinn a -> b
05:27:22 <lambdabot> -- f cannot be realized.
05:27:49 <davd> @djinn [a]
05:27:49 <lambdabot> Error: Undefined type []
05:28:35 <quchen> [].
05:28:45 <davd> :)
05:29:04 <c_wraith> djinn can't work on recursive types.  They break its algorithm
05:29:10 <Hafydd> @djinn a
05:29:11 <lambdabot> -- f cannot be realized.
05:31:47 <quchen> @djinn a -> (b -> a) -> Maybe b -> a
05:31:47 <lambdabot> f a b c =
05:31:47 <lambdabot>     case c of
05:31:47 <lambdabot>     Nothing -> a
05:31:47 <lambdabot>     Just d -> b d
05:33:16 <quchen> The first attempted Djinn proof above (for a->b) tried to prove that anything implies anything, and Hafydd's proof of "a" means that anything is true.
05:33:47 <ski> @djinn Not (Either a b) -> (Not a,Not b)
05:33:47 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
05:34:31 <therealhunt> how do i end getContents in ghci
05:34:33 <ChongLi> could djinn be extended to support bounded recursion with type level naturals?
05:34:40 <therealhunt> crtld is escaped
05:34:41 <Guest44832> In Shakspere templates there is $forall to iterate over a list. How can I iterate over a Data.Map.Map?
05:35:16 <ChongLi> Guest44832: turn it into a list :)
05:35:19 <quchen> Guest44832: Using its Functor/Traversable instance
05:35:24 <quchen> And doN't turn it into a list.
05:35:28 <ChongLi> hahaha
05:35:47 <therealhunt> does anyone know how to submit getContents inside ghci? ctrl d doesnt wor
05:35:48 <therealhunt> k
05:36:09 <quchen> ^C
05:36:15 <therealhunt> it closes ghci
05:36:51 <Guest44832> If I have "m :: Map k v" and I want to type something like "$forall m <- k v
05:37:04 <ski> Guest44832 : iterate over it, doing what ? making a new map where each value has been changed in some way ? combining values from multiple associations together in some way ? outputting some information from each association ?
05:37:33 <Guest44832> If I have "m :: Map k v" and I want to use something like "$forall m <- k v\n <li>${k} – ${v}", what shall I type?
05:37:52 <quchen> therealhunt: Doesn't for me, http://imgur.com/RXAEMmE
05:37:53 <therealhunt> what are you writing Guest44832?
05:38:30 <usrx> hello, has anyone watched Erik Meijer's FP introduction videos and recommend them?
05:38:41 <quchen> Guest44832: It's easier to help if you explain what you want to do instead of providing code in some other language.
05:39:52 <Guest44832> Okay, I have "m = Map.fromList [(1,2), (2,3)]" and I want to produce "<li>1 – 2</li><li>2 – 3</li>" how can I do it?
05:40:50 <ski>   forM_ m $ \(k,v) -> do
05:41:02 <ski>     putStr "<li>"
05:41:20 <ski>     putStr (show k)
05:41:23 <ski>     putStr " - "
05:41:25 <ski>     putStr (show v)
05:41:29 <ski>     putStr "</li>"
05:41:41 <ski> of course you can use instead a single `putStr' :
05:42:01 <ski>     putStr ("<li>" ++ show k ++ " - " ++ show v ++ "</li>")
05:42:13 <Guest44832> forM_ m $ \(k,v) -> do
05:42:19 <ski> Guest44832 : use `forM_' from the module `Data.Foldable'
05:42:28 <Guest44832>     <li>${k} – ${v}
05:42:38 <Guest44832> will ist also work in shakespere?
05:42:46 <Guest44832> will it also work in shakespere?
05:42:49 <ski> as quchen suggested `Data.Traversable' might also be useful to you, depending on what you want
05:43:05 * ski doesn't know what "Shakespere" is
05:43:10 <therealhunt> why is getContents so difficult to use in ghci
05:43:14 <therealhunt> i still cant get it to work
05:43:41 <quchen> I only know the esoteric programming language, and that's certainly not it.
05:43:59 <ski> Guest44832 : perhaps you can elaborate ?
05:44:45 * therealhunt needs to getcontent in ghci so he doesnt have to write a unit test
05:44:55 <Okasu> Guest44832: Join #yesod.
05:45:08 <Guest44832> okay
05:45:45 <quchen> GHCi is not a substitute for tests.
05:45:58 <therealhunt> no but itll help me avoid writing one right now
05:46:13 <tdammers> there is no law that says you need to write unit tests
05:46:21 <tdammers> they're a tool
05:46:25 <tdammers> know your tools
05:46:29 <therealhunt> but i need to because i dont know if everything here works
05:46:44 <tdammers> define "works"
05:46:54 <therealhunt> produces the output i want
05:47:08 <tdammers> and you need getContent for what?
05:47:19 <therealhunt> its parsing strings and producing data
05:47:32 <tdammers> but getContent isn't related to either, really
05:47:34 <therealhunt> getcontent lets me write a bunch of strings really easily
05:47:46 <quchen> > "This is how to write a string really easily"
05:47:47 <lambdabot>  "This is how to write a string really easily"
05:47:51 <therealhunt> a list of strings
05:48:13 <tdammers> ["This", "is", "how", "you", "write", "a", "list", "of", "strings" ]
05:48:19 <therealhunt> but was it easy?
05:48:22 <tdammers> yes
05:48:31 <therealhunt> i want to copy and paste
05:48:36 <therealhunt> a block of text
05:48:40 <tdammers> yes, so?
05:48:41 <quchen> > words "This is how to write a string really easily"
05:48:42 <lambdabot>  ["This","is","how","to","write","a","string","really","easily"]
05:48:46 <quchen> tdammers: :-þ
05:48:48 <Hafydd> [] -- this is how you write a list of strings.
05:49:06 <therealhunt> i want to thing <- getcontents; lines thing; magic
05:49:37 <tdammers> .msg lambdabot > fix ("this is how you write \"" ++)
05:49:40 <tdammers> eh
05:50:00 <Hafydd> Heh.
05:50:01 <tdammers> > fix ("this is how you write \"" ++)
05:50:01 <lambdabot>  "this is how you write \"this is how you write \"this is how you write \"thi...
05:50:03 <quchen> I think your problem is not related to getContents at all. But without further information (such as code) we can't do anything.
05:50:50 <tdammers> anyway
05:51:15 <tdammers> there's shelltestrunner
05:51:19 <therealhunt> my problem isthat i dont want to comma seperate
05:51:24 <tdammers> maybe that's close enough to a solution
05:52:19 <tdammers> also, quickcheck maybe
05:56:09 <therealhunt> how can i write a multi line string in my .hs, do i have to replace all newlines with \n
05:56:28 <TweyII> So who's having Fun this Afternoon?
05:56:38 * therealhunt is in party central
06:00:06 <therealhunt> guards within guards?
06:00:11 <therealhunt> possible?
06:01:41 <tdammers> there's a TH string quasiquoter somewhere IIRC
06:04:55 <k00mi> therealhunt: you can do this: unlines ["first line",\n "second line"]
06:19:41 <therealhunt>  how can i read a float that doesnt have preceeding 0
06:19:46 <therealhunt> like ".4 .3 .2"
06:21:03 <c_wraith> if you want to use read, fix it.
06:21:36 <c_wraith> > map read . map ('0':) . words $ ".4 .3 .2" :: [Double]
06:21:37 <lambdabot>  [0.4,0.3,0.2]
06:22:41 <therealhunt> ah thats simple
06:22:52 <therealhunt> ty
06:23:51 <t7> > read "05.5" :: Double
06:23:51 <lambdabot>  5.5
06:25:51 <therealhunt> doesnt work for negatives t7, c_wraith
06:26:12 <c_wraith> oh, true.
06:26:49 <c_wraith> You'll have to do something more clever, then.  (honestly, read is a pretty bad parser for floating point numbers anyway)
06:26:58 <t7> wait
06:27:19 <c_wraith> "0-.7" doesn't parse as a double, for some reason. :)
06:27:23 <t7> oh -.5 will be input ?
06:28:29 <therealhunt> t7, yea it can be
06:28:39 <therealhunt> im just going with two ifs
06:28:47 <t7> 2?
06:30:34 <tdammers> wrap atof() in an FFI call :P
06:32:04 <therealhunt> (\(a:as) -> if a == '.' then '0':a:as else if a == '-' then a:'0':as else a:as)
06:33:24 <c_wraith> (\(a:as) -> case a of '.' -> ... ; '-' -> ... ; _ -> ... )
06:33:51 <c_wraith> therealhunt: pattern matching is usually more concise.
06:33:58 <therealhunt> c_wraith thats much nicer i havent done cases inhaskell yet though
06:34:23 <therealhunt> c_wraith also how do you pattern match in anonymous functions (besides off the get go)?
06:34:26 <therealhunt> oh case
06:34:32 <therealhunt> i need to sleep
06:34:33 <c_wraith> therealhunt: have you written functions with multiple equations?  case is the same thing, as an expression.
06:35:09 <therealhunt> c_wraith: yea i get the concept i just havent encountered the word case yet
06:35:17 <therealhunt> thanks
06:43:38 <jcristovao> hi! I was just wondering, is there a 'simpler' functor, something like (a -> a) -> f' a -> f' a
06:46:10 <quchen> jcristovao: Functor can do that.
06:46:26 <quchen> :t fmap :: Functor f => (a -> a) -> f a -> f a
06:46:27 <lambdabot> Functor f => (a -> a) -> f a -> f a
06:47:46 <quchen> jcristovao: If you're looking for "fmap for Text" for example, have a look at the mono-traversable package.
06:48:12 <jcristovao> actually, functor does not apply in some cases
06:48:29 <jcristovao> for example, you can't derive a functor for a parameterless newtype
06:53:13 <c_wraith> jcristovao: but then that type signature doesn't make sense.  It doesn't have the type paramater
06:53:30 <c_wraith> jcristovao: it'd be more like (a -> a) -> b -> b
06:53:37 * quchen mentions mono-traversable again
06:53:54 <quchen> class MonoFunctor where omap :: (Element mono -> Element mono) -> mono -> mono
06:53:54 <c_wraith> mono-traversable is one approach.  I like the lens approach better
06:53:59 <jcristovao> c_wraith: you're right, of course :)
06:55:44 <jcristovao> quchen: I guess you're right, it would be just another MonoFunctor instance
06:56:07 <jcristovao> c_wraith: and what would be the lens approach?
06:58:16 <quchen> Oh nice, partial type sigs: https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures
06:58:37 <quchen> (The proposal was just posted to @ghc-devs)
06:59:43 <augur> this Julia-is-not-dependently-typed convo on github is completely calm, and yet carter and "tknopp" (whoever that is here) are treating it like its heated o.O
07:00:03 <c_wraith> augur: eh, some of the early comments were pretty rude.
07:00:11 <c_wraith> jcristovao: the lens approach is creating a traversal between the two types that you can use with any of the lens combinators.
07:00:17 * quchen doesn't understand how this is Haskell news anyway.
07:00:52 <jcristovao> c_wraith: ok, tks
07:00:54 <fizbin> Is there something that is the generalization of "mapMaybe" that goes over an arbitrary Traversable or Foldable?
07:00:55 <augur> c_wraith: do you think so? the rudest thing i can see is the claim that its name dropping
07:01:06 <quchen> fizbin: for?
07:01:10 <c_wraith> :t mapMaybe
07:01:11 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:01:17 <quchen> :t for
07:01:18 <lambdabot>     Not in scope: `for'
07:01:18 <lambdabot>     Perhaps you meant one of these:
07:01:18 <lambdabot>       `T.for' (imported from Data.Traversable),
07:01:20 <quchen> :t T.for
07:01:21 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
07:01:42 <c_wraith> That doesn't look like it'll unify
07:02:03 <quchen> Hmmmmm. But I was so sure there was such a function.
07:02:15 <c_wraith> fizbin: the problem with generalizing it is that it sort of depends on the property that lists can be filtered cheaply.
07:02:27 <c_wraith> fizbin: you can't just throw elements out of a tree trivially, for instance
07:03:00 <c_wraith> fizbin: that said, I do remember someone was working on some sort of Filterable class a while back.
07:03:28 <fizbin> True. The generalization I want is something like (a -> Maybe b) -> f a -> [b]
07:03:46 <c_wraith> ah.  then Foldable would suffice.
07:04:00 <c_wraith> I don't know that anyone's written that anywhere, though.
07:04:09 <usrx> is [20..1] interpreted as "get successor of 20, upper bound is 1, hence empty list"?
07:04:18 * quchen thinks of pipes' `each` and `mapFoldable` functions, that's why I thought of Foldable/Traversable.
07:04:28 <fizbin> c_wraith: Foldable's concatMap is almost that.
07:04:32 <MagneticDuck> hey guys, say I want to parse a fairly large text file, for instance to find all of the links to user submitted images on a page of reddit... it seems like readFile <downloaded file> >>= <parser function> might not be the best way, eh?
07:04:44 <quchen> fizbin: concatMap = foldMap
07:04:58 <MagneticDuck> is there a faster, cooler way or something?
07:05:11 <Kinnison> MagneticDuck: so long as your parser function is written to stream well, lazy IO should make things sane
07:05:18 <fizbin> quchen: I suppose it is, at that.
07:05:24 <c_wraith> Hmm.  Yes, that is foldMap, *if* you change the signature to Foldable f => (a -> [b]) -> f a -> [b]
07:05:30 <MagneticDuck> Kinnison: alright http://ix.io/b3o
07:06:01 <MagneticDuck> It's just that... when I compile the program and try to run it.. I get a cool error message
07:06:10 <Kinnison> I'm afraid I'm not great at these things :-)
07:06:23 <MagneticDuck> http://ix.io/b3p
07:07:11 <MagneticDuck> entirety of the silly little program's source -> http://ix.io/b3q
07:07:17 <MagneticDuck> I wrote it last night so it's probably pretty terrible =P
07:08:02 <MagneticDuck> (it takes as commandline argument something like "www.reddit.com/r/funny")
07:08:31 <MagneticDuck> I wrote this for fun, and to learn to appreciate parsec more :D
07:08:54 <quchen> You don't clean up /tmp after reading.
07:09:08 <c_wraith> :t F.foldMap . (maybeToList .) -- fizbin: if you want to be dumbly concise. :)
07:09:09 <lambdabot> Foldable t => (a -> Maybe a1) -> t a -> [a1]
07:09:15 <MagneticDuck> quchen: hmm?
07:09:36 <MagneticDuck> quchen: "clean up /tmp"?
07:09:49 <MagneticDuck> I don't think I'm doing anything in /tmp besides writing that file
07:09:52 <quchen> You write stuff to /tmp but don't delete it when you're done. Just a remark.
07:10:25 <MagneticDuck> quchen: okay, but I didn't think I was doing anything to /tmp besides wgetting and reading the file....
07:10:29 <MagneticDuck> line no?
07:11:59 <quchen> The "downloadPage" function wgets to /tmp/reddit, it reads that file, and then it's left orphaned.
07:12:29 <quchen> (What's all this --{{{ noise by the way?)
07:12:43 <MagneticDuck> quchen: fold markers
07:12:47 <MagneticDuck> xD
07:18:05 <quchen> Maybe the foldr overflows in your headerSearch function.
07:18:29 <MagneticDuck> well that would be a sound conclusion, because there's no other recursion in headerSearch
07:18:29 <quchen> It looks like you're folding over a long String, and when 'acc' isn't sufficiently lazy that might blow up.
07:18:44 <MagneticDuck> so, how would one make acc lazier?
07:18:56 <quchen> I don't know, I can't read the code.
07:19:03 <MagneticDuck> xD sorry
07:19:13 <MagneticDuck> I wrote this out of a kind of necessity last night
07:19:17 <quchen> headerS, curS, cur, appChar, no documentation.
07:19:19 <MagneticDuck> wasn't thinking about code reusability
07:19:34 <MagneticDuck> (or anything other than getting it to work actually)
07:19:42 <darthdeus> guys i'm getting an error when i try to install the hstats package http://hackage.haskell.org/package/hstats-0.3/docs/Math-Statistics.html http://lpaste.net/101068 ... anyone has any idea why that might be happening?
07:19:52 <MagneticDuck> darthdeus: post your error
07:19:55 <darthdeus> i've tried updating cabal and also did cabal install cabal-install, but doesn't help
07:19:58 <darthdeus> http://lpaste.net/101068
07:20:12 <c_wraith> darthdeus: packages can't depend on both base and haskell98 anymore
07:20:22 <c_wraith> darthdeus: looks like hstats hasn't been updated in forever
07:20:41 <darthdeus> uhm, any tips for another library that can calculate standard deviation?
07:20:46 <MagneticDuck> there are quite a few orphaned / broken projects out there :<
07:20:49 <darthdeus> and no i dont wanna do it myself :P
07:21:01 <darthdeus> i sort of want to verify that i'm doing it properly by checking against another library
07:21:06 <MagneticDuck> you're so lazy
07:21:12 <c_wraith> darthdeus: http://hackage.haskell.org/package/statistics
07:21:13 <darthdeus> waa?
07:21:15 <MagneticDuck> oh
07:21:18 <MagneticDuck> never mind
07:21:20 <c_wraith> darthdeus: that's what criterion uses
07:21:20 <darthdeus> :D
07:21:23 <darthdeus> thanks
07:21:42 <darthdeus> MagneticDuck: i'm trying to write a monoid that calculates stddev, and i want to have something as a base for my testing
07:21:58 <c_wraith> darthdeus: also, remember that "lazy" isn't necessarily an insult in haskell-land. :)
07:21:58 <MagneticDuck> yeah
07:22:05 <MagneticDuck> true
07:22:06 <darthdeus> c_wraith: haha
07:29:15 <therealhunt> how important is it that i actually learn monoids
07:29:38 <therealhunt>  / how much would it help with statey parsing
07:30:07 <augur> therealhunt: it can be important
07:30:12 <augur> but crucially, its not that hard
07:30:22 <augur> therealhunt: a monoid is:
07:30:27 <therealhunt> augur: should i get some sleep before trying to learn it
07:30:46 <augur> class Monoid a where { mempty :: a ; mappend :: a -> a -> a }
07:31:13 <tdammers> monoids are easy
07:31:25 <augur> that behaves kind of like lists do, in that mempty is kind of an empty thing  (ie   mempty `mappend` x == x == x `mappend` mempty)
07:31:31 <augur> and mappend is associative
07:31:37 <augur> lists are the canonical monoid
07:31:42 <augur> mempty = [], mappend = (++)
07:32:26 <therealhunt> augur: how are the functions in {}
07:32:49 <augur> therealhunt: im just using the (semi?)standard inline notation for blocks
07:33:05 <MagneticDuck> therealhunt: it's called a typeclass
07:33:22 <augur> sometimes in haskell you have these multi-line things that have to be indented the same but you want to put them on one line
07:33:28 <augur> so you use { ... ; ... ; ... }
07:33:34 <augur> instead of using newlines and indentation
07:33:43 <MagneticDuck> ahk
07:33:55 <therealhunt> right ok
07:34:00 <MagneticDuck> never mind, thought he didn't understand the "class" notation
07:34:07 <MagneticDuck> s/notation/syntax
07:34:09 <therealhunt> na it was the crazy braces
07:34:12 <MagneticDuck> kk
07:34:15 <MagneticDuck> =P
07:34:18 <augur> same with do, therealhunt:
07:34:19 <MagneticDuck> they are truely terrible
07:34:25 <MagneticDuck> maaad braces
07:34:30 <augur> do { foo ; x <- bar ; return baz }
07:34:32 <augur> as opposed to
07:34:47 <augur> do foo
07:34:47 <augur>     x <- bar
07:34:47 <augur>     return baz
07:35:24 <MagneticDuck> therealhunt: any haskell module can be writtin on one line
07:35:29 <MagneticDuck> just, cool thing to keep in mind =P
07:35:38 <therealhunt> is learn you a haskell a good place to learn about monoids
07:35:44 <MagneticDuck> yes
07:35:46 <therealhunt> magnetic: lol if youre a massochist
07:35:53 <MagneticDuck> therealhunt: yes
07:36:05 <augur> better than being a masslessochist
07:38:15 <therealhunt> augur, is it?
07:38:43 <MagneticDuck> yes
07:38:57 <augur> therealhunt: masslessochists always travel at the speed of light, and therefore experience no time, and thus cant get anything done!
07:39:03 <MagneticDuck> yes
07:39:09 <tdammers> monoids are really really easy. A monoid has a neutral element and one operator; for the operator, ordering matters.
07:39:13 <tdammers> that's about it.
07:39:38 <tdammers> there's a bit more to it, formally, but for the intuition, think string concatenation
07:40:10 <fizbin> The main additional formal bit is the existence of an identity element.
07:40:30 <byorgey> I think that's what tdammers meant by "neutral element".
07:40:33 <tdammers> yeah
07:40:40 <byorgey> The real main additional formal bit is that the binary operator has to be associative.
07:40:46 <fizbin> Actually, maybe that isn't so important. The important thing is that the operation is asso... right.
07:40:57 <tdammers> hehe
07:41:13 <fizbin> Gotta work on my typing speed.
07:42:30 <fizbin> Anyway, being associative means that for things like foldMap the monoid operation can be performed in whatever sequence makes sense for the Foldable.
07:42:35 <augur> fizbin: also gotta get one of those computers that lets you delete things you've already typed
07:42:51 <fizbin> Yeah, yeah.
07:42:55 <c_wraith> yeah, associativity turns out to be *really* powerful.
07:43:17 <c_wraith> byorgey wrote a whole paper about that!  (and some associated library, or something)
07:43:18 <fizbin> Which can give nice performance boosts in some cases.
07:43:39 <augur> associativity = traversable in any direction or no direction at all
07:44:00 <augur> = can be broken down into arbitrarily many parts, parallel processed, then recomposed
07:44:13 <c_wraith> augur: it's really nice for parallel computations, too, because it means you can break down the work into a tree easily.
07:44:37 <c_wraith> oh.
07:44:39 <augur> x3
07:44:41 <c_wraith> you said that while I was typing
07:44:43 <c_wraith> darn it!
07:44:44 <c_wraith> :)
07:44:53 <MagneticDuck> fizbin: http://play.typeracer.com/?rt=trmagneticduck ;D
07:44:56 <MagneticDuck> lols
07:45:00 <MagneticDuck> I haven't done typeracer in a while
07:45:01 <fizbin> augur: Thing is, since my wpm is stuck in the high 30s on a good day, each line takes me so long that I'm loathe to wipe it our.
07:45:09 <fizbin> Out, even
07:45:22 <MagneticDuck> ah
07:45:27 <MagneticDuck> :<
07:45:32 <MagneticDuck> I have around 100 WPM on typeracer
07:45:33 <MagneticDuck> lols
07:45:59 <MagneticDuck> muslce memory!
07:46:02 <MagneticDuck> muscle*
07:46:24 <fizbin> Yeah, I've tried those games. typeracer has for me all the fun of an asthmatic out for a friendly jog with a bunch of olympic marathon runners.
07:46:26 <augur> fizbin: http://www.longleaf.net/mandala/sweeping-large1.jpg
07:47:51 <augur> http://phoboslab.org/ztype/ < best typing game
07:48:15 <augur> ztype is actually quite addictive just as a game
07:48:52 <MagneticDuck> lol fizbin :D
07:48:57 <MagneticDuck> yes, it's a bit like that
07:49:30 <cleatoma> <MagneticDuck> I have around 100 WPM on typeracer  <--  Confirmed. I got 102 and still lost the race.
07:51:02 <MagneticDuck> =P
07:51:12 <MagneticDuck> ducks don't lie about typing speeds
07:51:17 <bartavelle> :)
07:52:14 <MagneticDuck> ducks are FAST.
07:52:30 <augur> :V
07:52:38 <rindolf> Hi all. http://lpaste.net/101070 - can anyone help with this?
07:53:39 <Jaak_> rindolf: looks like you are trying to have unboxed Integer arrays
07:53:40 <MagneticDuck> rindolf: nice variable names :D
07:53:59 <Lindrian> test
07:54:01 <rindolf> MagneticDuck: yes, sorry about that, but I needed them in the original program.
07:54:27 <rindolf> MagneticDuck: the problem is with before_bump_recurse though at the bottom.
07:54:31 <SimonB_> a
07:54:59 <Jaak> try with boxed arrays
07:55:07 <rindolf> Jaak: where are the good old arrays that can accumulate Integers into Integers?
07:55:09 <rindolf> Jaak: ah.
07:55:41 <Jaak> i think just Data.Array
07:56:15 <MagneticDuck> Jaak: you don't need fast arrays to do project euler
07:56:21 <MagneticDuck> the problems aren't supposed to be very computationally intensive
07:56:35 <monochrom> you need number theory, yes
07:56:42 <Jaak> i'm just trying to solve the immediate problem
07:56:49 <monochrom> take a number theory course in your university
07:57:32 <kwstas> it seems that some functions in prelude are not implemented with the most efficient way (like sum, genericLenth etc). Why, even thought these problems are identified, future library releases do not correct them?
07:57:43 <MagneticDuck> kwstas: sum isn't implemented efficently?
07:58:00 <opqdonut> maybe he means that it's lazy
07:58:10 <opqdonut> which means it's suboptimal for strict number types
07:58:14 <MagneticDuck> mm
07:58:18 <opqdonut> however ghc strictness analysis fixes that
07:58:44 <opqdonut> kwstas: sum and genericLength are implemented as they are to remain generic
07:58:49 <kwstas> MagneticDuck: according to Gabriel Gonzalez post (www.haskellforall.com/2013/08/composable-streaming-folds.html), sum leaks space
07:58:58 <MagneticDuck> huh.
07:59:26 <opqdonut> kwstas: it doesn't if you compile with optimizations
07:59:28 <opqdonut> IIRC
08:00:19 <opqdonut> yep, I just verified that
08:00:48 <opqdonut> anyway, sum and genericLength are implemented like they are to retain generality for lazy number types
08:00:55 <rindolf> Jaak: thanks! It compiles now, but there's a calculation bug.
08:01:40 <Jaak> nps
08:03:02 <kwstas> opqdonut: ok, so it's not that they are not implemented efficiently. They have to be implemented with a sub-optimal way in other to support different use cases
08:03:36 <opqdonut> kwstas: right. and compiler optimizations take care of at least the sum inefficiency. for genericLength you can always use the more efficient length
08:05:46 <kwstas> opqdonut: ok thanks. I didn't know that there are lazy nums.
08:06:18 <opqdonut> kwstas: well I'm not sure anybody uses lazy number types for anything, but here's an example: http://www.haskell.org/haskellwiki/Peano_numbers
08:11:51 <rindolf> https://bitbucket.org/shlomif/project-euler/src/8d8afed8d9cdceb56dbcb63be43994f24d6310f5/project-euler/158/?at=default - can anyone tell me here why the Haskell function does not yield the same results as the Perl programs (both the same one algorithmically as the Haskell version and the brute force version)?
08:12:06 <rindolf> I can translate the Perl program to a different language if needed.
08:16:47 <quchen> Evil SPJ sends out a mail named "GHC 7.8 release" that discusses RC2 :-(
08:17:05 <quchen> "Yipeeeeeooohhhh.....:-("
08:17:21 <tdammers> trolling like a boss
08:19:41 <quchen> edwardk: KindHoles sounds like an insult :-þ
08:19:51 <edwardk> it was a bit
08:22:22 <quchen> Makes me wonder what kind of hole "x@_" is.
08:26:24 <bartavelle> rindolf, the program doesn't make much sense to me on first glance, but you seem not to be using "multiplier" in "after_bump_recurse"
08:27:04 <Hafydd> rindolf: that's a pretty unreadable program. Do your variable names have to be so long?
08:28:33 <rindolf> bartavelle: yes, I found it already.
08:29:04 <rindolf> Hafydd: I originally used these variable names so I will be able to discern their meaning by writing.
08:29:16 <rindolf> s/by writing/when writing/
08:29:27 <klrr> can you link to code discussed?
08:29:43 <bartavelle> rindolf, that was the problem ?
08:30:15 <rindolf> bartavelle: I didn't multiply by multiplier. :-)
08:30:23 <napping> seems like it should have something close to a closed form
08:30:30 <bartavelle> then I'll tell you that you should always use -Wall :)
08:30:58 <klrr> can someone link the code?
08:30:59 <rindolf> Another question: how can I take a list and return a list of (index,VALUE) tuples?
08:31:10 <napping> zip [0..]
08:31:14 <rindolf> Like each(@array) in recent versions of perl.
08:31:18 <klrr> rindolf: can you link
08:31:20 <rindolf> napping: ah, I see.
08:31:27 <rindolf> klrr: link what?
08:31:39 <geekosaur> they're looking for your original message to the channel
08:31:48 <geekosaur> [12 15:08] <rindolf> https://bitbucket.org/shlomif/project-euler/src/8d8afed8d9cdceb56dbcb63be43994f24d6310f5/project-euler/158/?at=default - can anyone tell me here why the Haskell function does not yield the same results as the Perl programs (both the same one algorithmically as the Haskell version and the brute force version)?
08:31:58 <geekosaur> klrr ^
08:31:59 <klrr> thanks
08:32:01 <rindolf> klrr: https://bitbucket.org/shlomif/project-euler/src/d273008ed0a66d061816a7f4ceb4061c2a1f0aa0/project-euler/158?at=default - here is the up-to-date version.
08:32:15 <klrr> omg
08:32:37 <klrr> rindolf: i suggest using less verbose variables, also camel case is quite standard when writing haskell
08:36:07 <rindolf> klrr: OK.
08:36:23 <rindolf> klrr: camelCase or CamelCase?
08:36:37 <julianb> Hi!, I'm trying to make a binary tree using existential quantification (to avoid having Ord a functions), my type definition is like: data Tree a = forall a. (Ord a) => Node a (Tree a) (Tree a) | Empty deriving (Eq). However, I'm getting: Can't make a derived instance of `Eq (Tree a)'
08:36:40 <klrr> CamelCase for datatypes, camelCase for variables
08:37:56 <tdammers> PascalCase for concrete types (type level) and constructors (value level)
08:38:19 <tdammers> camelCase for type variables (type level) and variables (value level)
08:38:59 <napping> julianb: that looks strange - aren't you shadowing the a? The problem is that's an existential type, so two values of type Tree Int might have different inner a types
08:40:08 <julianb> napping, what do you mean by shadowing?
08:40:22 <napping> the a in "Tree a" and the a bound by "forall a . " are different as
08:40:38 <napping> If you changed the start to just "data Tree = " it should compile with the same error
08:40:54 <dwcook> I'm guessing I should just ignore the GHC crash message saying to report a bug if it came about from mucking about with unsafeCoerce, is that right?
08:40:55 <julianb> oh!, right, I forgot!
08:40:59 <napping> In other words, do you expect all Nodes in a Tree Int to contain Int?
08:41:14 <julianb> yes, I do
08:41:29 <napping> then you should be able to just drop the forall bit entirely
08:41:46 <julianb> but how can I make sure that a is Ord then?
08:41:55 <napping> Why do you need to?
08:42:08 <quchen> julianb: How about using GADTs to do this? `data Tree a where Empty :: Tree a; (Ord a) => Node a (Tree a) (Tree a)` will allow you to pattern match on Node without introducing an Ord constraint.
08:42:21 <julianb> because it wouldn't make sense to implement a binary tree without Ord?
08:42:26 <quchen> Eh wait, that syntax is off.
08:42:28 <julianb> well, it wouldn't in the context I'm using them
08:42:31 <quchen> Anyway, GADTs suggestion.
08:42:40 <prophile> julianb: generally the context is put on the operations and instances rather than on the data type
08:43:04 <napping> If you can see the "a" in the type "Tree a", then you can just write all the functions with types like "(Ord a) => ... -> Tree a -> ..."
08:43:26 <prophile> julianb: look at http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Set.html for instance
08:43:37 <prophile> the data type itself doesn't have constraints on it, the Ord constraints are put on the various operations
08:44:31 <julianb> oh, that makes a lot of sense...
08:45:35 <napping> If you want binary search trees, just requiring Ord in the data type isn't enough to guarantee if it's well formed
08:45:58 <napping> (Node 2 (Node 1 Empty Empty) (Node 1 Empty Empty))
08:47:07 <napping> If you do want to build the Ord constraint into the tree quchen has the right idea
08:47:17 <julianb> but how can you guarantee that much? (I've seen some source code using DataKinds and whatnot, but its kind of over me)
08:47:30 <quchen> Example code: http://lpaste.net/101074
08:47:35 * hackagebot Hclip 1.0.0.3 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-1.0.0.3 (JensThomas)
08:47:36 <julianb> alright, I'll check out GADTs
08:47:52 <julianb> thanks a lot
08:48:08 <napping> I doubt you can reasonably guarantee that a tree is properly constructed in Haskell
08:48:26 <prophile> napping: depends
08:48:28 <napping> Using GADTs like that rarely helps
08:48:47 <prophile> you couldn't construct an invalid Tree () :3
08:48:50 <quchen> If by Haskell you mean standard Haskell, then no. But there are implementations of red-black trees that are statically safe.
08:48:59 <quchen> Those rely on extensions though.-
08:49:06 <prophile> are there?
08:49:06 <napping> statically balanced, or statically ordered as binary search trees?
08:49:19 <prophile> I thought that just enforced the red-black constraint, rather than the ordering
08:49:22 <julianb> you mean something like this? http://hackage.haskell.org/package/avl-static-0.1.0.0
08:49:22 <napping> the depth requirement isn't so tricky
08:49:28 <quchen> Found the Gist: https://gist.github.com/rampion/2659812
08:49:36 <quchen> "red-black trees in haskell, using GADTs and Zippers"
08:50:09 <napping> that seems to be just balance
08:51:23 <napping> The point is, if you want to ensure that trees are actually search trees you'll almost certainly need to hide the constructors, and then you might as well just put the constraint on the operations like Data.Map
08:51:35 <prophile> quchen: let subtree = R Leaf 1 Leaf in B subtree 2 subtree
08:51:44 <prophile> lo and behold, not a valid binary search tree
08:52:16 <napping> It's much more rarely necessary to make a constraint part of the datatype itself, but if you do GADTs (or at least GADT syntax) are probably what you need
08:52:41 <prophile> or use idris :)
08:53:02 <djahandarie> Well, you can require a less-than-or-equal proof in the constructor, but those aren't always so nice in Haskell.
08:53:13 <napping> in other words, don't bother with fancy data type declarations, and let type inference sort it out
08:53:40 <djahandarie> I think I have a half-implementation of binary search trees where you require LTE proofs in the constructors somewhere...
08:53:42 <napping> insert will get an inferred type like Ord a => a -> Tree a -> Tree a
09:00:40 <quchen> Right, false alarm, sorry
09:06:56 <pikaren> i want to learn haskell because i just feel bored with imperative or oop languages.. is it alright
09:07:06 <Yaniel> sure
09:07:09 <Iceland_jack> pikaren: It's more than alright :)
09:07:11 <Iceland_jack> @where lyah
09:07:11 <lambdabot> http://www.learnyouahaskell.com/
09:07:16 <Iceland_jack> pikaren: ↑ that's a good place to start
09:07:26 <Yaniel> good a reason as any
09:07:46 <Iceland_jack> You can also evaluate Haskell expressions here by prefacing it with '> '
09:07:46 <Iceland_jack> > "hello " ++ "world"
09:07:47 <lambdabot>  "hello world"
09:08:45 <pikaren> hmm thanks.. ill read through learnyouahaskell
09:08:50 <haasn> quchen: there's one in the GHC tree, actually
09:09:06 <haasn> quchen: http://git.haskell.org/ghc.git/blob/HEAD:/testsuite/tests/polykinds/RedBlack.hs
09:12:12 <quchen> haasn: That's the same
09:12:16 <haasn> ah okay
09:12:32 <quchen> I think it was used as a test case because it was just too compelling
09:16:14 <guymann> h
09:19:11 <Kron> interestingly I think haskell is the only functional language I know that explicitly avoids OOP
09:19:27 <Kron> even common lisp does it, and ocaml even has it in its name
09:19:53 <haasn> I think “avoids OOP” is the side effect
09:20:13 <haasn> I would look at it from the other direction, “embraces elegance”
09:21:03 <napping> O'Caml style polymorphic records would fit in well enough
09:21:08 <Iceland_jack> Kron: Common Lisp has CLOS but the Lispers I knew didn't really use them
09:21:13 <Iceland_jack> *use classes
09:21:19 <Kron> ah, well, I used to use CLOS quite a lot
09:21:28 <Iceland_jack> ah I see
09:21:40 <Kron> not java-style with everything I built, but anywhere I had to define my own structs or de facto types I turned to CLOS
09:22:32 <Kron> haasn: I still have difficulty understanding why OOP is not elegant
09:22:40 <Kron> is it because it kind of bakes type data into the runtime?
09:22:50 <haasn> it's because it's a needless abstraction
09:22:59 <napping> because classes do less to constraint implementations
09:23:13 <napping> or give you properties, rather
09:23:20 <average> Kron: if I may ask, is it possible to avoid OOP while using Haskell ?
09:23:20 <Kron> typeclasses do exist in most OOP languages as interfaces I think
09:23:32 <tdammers> Kron: not the same, really
09:23:39 <Kron> average: well, I'm not even sure
09:23:41 <Kron> I assume it's possible
09:23:42 <average> Kron: or is it solved by types being the .. sort-of replacement for classes.. ?
09:23:55 <tdammers> I think the closest to Haskell typeclasses would be implicit interfaces at the template level in C++
09:24:00 <Kron> I do find myself wishing for heterogenous lists
09:24:03 <napping> and algebraic data type gives you an initial algebra, which usually tells you something halfway useful about possible values
09:24:15 <Iceland_jack> Kron: You can have those, but what do you really need them for?
09:24:19 <Kron> but I understand that's a slippery slope especially to a language designed with such incredible type safety in mind
09:24:32 <napping> a class type - at least if you have subtyping - basically just tells you that values are in the terminal coalgebra, which tells you almost nothing
09:24:43 <Kron> basically, extendable code
09:24:48 <Kron> if you have a game with, say, monsters
09:25:03 <Kron> and you want to add in a new monster type into the map array which is like that other monster but has acid breath
09:25:04 <Iceland_jack>     data HList ∷ '[★] → ★ where
09:25:04 <Iceland_jack>         HNil  ∷ HList '[]
09:25:04 <Iceland_jack> 	HCons ∷ t → HList ts → HList (t ': ts)
09:25:12 <Iceland_jack> oops,
09:25:12 <Iceland_jack>         HCons ∷ t → HList ts → HList (t ': ts)
09:25:20 <tdammers> Kron: several choices there
09:25:25 <Kron> it's... kind of automatic with OOP
09:25:33 <tdammers> it's not automatic
09:25:37 <Kron> yeah I know, several choices, all somewhat nonintuitive to me (which I understand is subjective)
09:25:40 <napping> Then there are incidentals, just how you have == and isinstance killing parametricity, which isn't really the fault of OOP
09:25:45 <average> Kron: how can you get the benefits of classes in Haskell ?
09:25:53 <Kron> but I do appreciate there being a single right way to do something. Ironically it's a property I really enjoy about haskell
09:26:06 <Kron> in haskell I often feel like there's a 'right way' to do any given thing and it pushes you to doing it that way
09:26:38 <tdammers> once you realize how purity plays into it, you can leverage functions and closures in interesting ways
09:27:10 <Kron> yeah, purity
09:27:42 <Kron> for all my lisp experience, I was never really impressed with the usefulness of purity until I ran into haskell
09:27:57 <average> tdammers: don't closures bring about more uncertainty to the GC about when some data structure should be freed ?
09:27:57 <Iceland_jack> average: OO classes have a lot of features (mutability, state, encapsulation, …) depending on your definition and there are many: you can use many different Haskell features but which ones you use depend on your problem
09:28:00 <mrmonday> why might I end up with this error? (my code is in libstd, they should be the same types...) error: mismatched types: expected: `io::net::raw::NetworkInterface` but found `std::io::net::raw::NetworkInterface` (expected struct io::net::raw::NetworkInterface but got std::io::net::raw::NetworkInterface)
09:28:19 <mrmonday> (sorry if the error is slightly wrong, copy/paste doesn't seem to be working for me right now)
09:28:41 <Iceland_jack> mrmonday: Isn't that Rust?
09:29:06 <mrmonday> oh, sorry, wrong channel
09:29:07 <bjz> mrmonday: wrong channel?
09:29:09 <bjz> heh
09:29:11 <bjz> :)
09:29:45 <Kron> hahaha
09:29:49 <Iceland_jack> Rust is very exciting for me as a Haskeller
09:29:54 <mrmonday> coulda sworn I was in #rust, oopsie :<
09:30:08 <Kron> I find ATS quite exciting too
09:30:19 <Kron> the idea of dependently typing C appeals to me in a really masochistic way
09:30:30 <Iceland_jack> Kron: What about dependently typed assembly?
09:30:37 <Kron> Tell me more. D:
09:30:39 <Iceland_jack> That's the most exciting part!
09:30:48 <Iceland_jack> I guess nobody works on that anymore
09:31:02 <Iceland_jack> but there were quite a few papers on typed assembly language
09:31:09 <Kron> I'm not sure if the concept of types is even meaningful at the assembly level
09:31:15 <Kron> there aren't variables of expressions down there
09:31:22 <Kron> though I'm probably wrong
09:31:24 <Iceland_jack> Kron: Read Advanced Topics in Types and Programming Languages and find out :)
09:32:58 <bjz> Kron: ATS looks cool, but as much as I try to separate looking at surface syntax as opposed to semantics, I can only go so far
09:33:08 <bjz> :P
09:33:28 <Iceland_jack> Kron: Mind you I haven't seen much work on that in the last 15 years
09:33:38 <Kron> yeah, I know :P
09:33:43 <Kron> so we sit around here in haskell
09:33:48 <bjz> Kron: I'm pushing it with Rust, but it has me over the line, and is 'good enough'
09:34:25 <Iceland_jack> Kron: But one of the cool stuff you could do with a dependently typed assembly language is making bounds checks concrete and restrict where you can jump and so forth
09:35:14 <Iceland_jack> it's not too unrelated to proof-carrying code where you can transmit the typed assembly which contains certain claims about what the code does
09:35:27 <Iceland_jack> since you could*
09:35:42 <Kron> I do like the idea of dependently type checking programs to make sure they can't possibly do anything bad or violate their memory section
09:36:03 <Kron> presumably you can then relax OS security checks on virtual memory operations and just let the program operate faster unhindered
09:36:15 <Iceland_jack> Yes, or making it a target language for a compiler
09:36:19 <Kron> right
09:37:06 <Kron> something I find really funny about this kind of dependent type security thing is that it gives a pretty strong advantage to open source code (at least as I understand it)
09:37:25 <Kron> since to use this feature you have to compile the code on the system itself while it watches
09:37:38 <Kron> ... or I guess you could hand over binaries heavily authenticated by some keys or something. Hmm.
09:37:49 <bjz> I really hope that better type systems will allow for faster than C performance
09:37:54 <Kron> yeah same
09:37:58 <bjz> dunno if that is possible
09:38:06 <Kron> for the longest time I used to think that was ultimately kind of impossible?
09:38:08 <bjz> Rust might be able to do it
09:38:12 <Kron> But I distinctly remember
09:38:12 <Iceland_jack> Kron: Well I wrote a project in Haskell for doing something not too different
09:38:21 <Kron> a few months into learning haskell
09:38:40 <bjz> after they work on optimising it
09:38:41 <Kron> I kind of finally 'got' lazy programming, when I realized that there wasn't really a function call stack
09:38:54 <Kron> not as I normally understood it, and functions don't actually process return values and hand them over
09:39:05 <Kron> which then opened my mind to all sorts of bizarre non-C program topologies
09:39:22 <bjz> interesting
09:39:26 <Kron> I assume it ultimately does work with some hidden Core stack and stuff
09:39:36 <Kron> but I do think it's possible to 'do better' I guess
09:39:41 <Iceland_jack> Kron: You could have a function
09:39:41 <Iceland_jack>     foobar ∷ String → Restr (Stout :+ Time) ()
09:39:41 <Iceland_jack>     foobar = …
09:39:41 <Iceland_jack> which can only output text to stdout and check the time
09:39:51 <Kron> oooh
09:39:52 <Kron> that's nice
09:39:54 <Iceland_jack> this would be perfect for extensions for browsers or editors
09:40:04 <prophile> you can do that sort of restriction with arrows though
09:40:10 <bjz> Kron: definitely far more room in the combinatorial space of PL design
09:40:16 <bennofs> Why do you need arrows? :O
09:40:21 <Iceland_jack> prophile: You don't need arrows
09:40:30 <Iceland_jack> Just monads
09:40:36 <bjz> Kron: more room to explore I mean
09:40:37 <milfjord> mmh, Stout
09:40:53 <prophile> I seem to recall it's not possible with monads, but that it is with arrows
09:41:04 <Iceland_jack> prophile: You may be talking about something different
09:41:18 <Iceland_jack> since I've made the library :)
09:41:27 <Iceland_jack> and I don't think I used arrows!
09:41:28 <prophile> statically annotating a computation with a list of types of side effect?
09:41:32 <mr-> prophile: you could just model it as a free monad on those restricted operations, couldn't you?
09:41:47 <Iceland_jack> what mr-- said
09:41:48 <prophile> ah, we are talking about something different then
09:41:55 <mr-> (If you understand IO to be the free monad on everything IOish)
09:41:55 <bennofs> prophile: This is about doing it in the type system. If you want to analyze a computation with some sort of static value *at runtime*, then you need to use arrows
09:42:13 <prophile> bennofs: yes, thanks
09:42:44 <prophile> the example I remembered involved keeping a list of read or written files as part of the arrow
09:42:58 <Iceland_jack> prophile: Yes but that's not a static property of the system
09:43:27 <Iceland_jack> I'm talking about being able to outsource your code and statically know what effects it will have without having to audit the code
09:43:40 <prophile> well, it's still static
09:43:48 <mr-> Iceland_jack: is that how you implemented your library? Time is a set of operations, Stout is a set of operations, :+ just puts them together and Restr is the free monad over those things?
09:43:51 <prophile> it's just not in the type system
09:43:57 <prophile> regardless, we ARE talking about different things
09:43:59 <Iceland_jack> mr-: Yes
09:44:04 <mr-> Cool
09:44:55 <Iceland_jack> mr-: It was a proof of concept that turned into a Hackage package conceived in a Language-Based Security course, I'm surprised why this feature of Haskell (restricted monads) isn't emphasized a lot more
09:44:56 <mr-> Unfortunately Haskell has unsafe* to circumvent..
09:45:12 <Iceland_jack> mr-: SafeHaskell? :)
09:45:40 <Kron> is there some sort of GHC flag to abjure any unsafe* commands inside the file?
09:45:50 <Kron> so you can make sure that your production version isn't secretly insane
09:46:17 <Iceland_jack> Kron: Safe Haskell
09:47:10 <mr-> Iceland_jack: I've been wondering about that too.. (And I still don't know how App-stores manage those restrictions for Apps ;-)
09:47:45 <Iceland_jack> it makes the types "honest" so you can't write
09:47:45 <Iceland_jack>     justAnInt ∷ Int
09:47:45 <Iceland_jack>     justAnInt = unsafePerformIO (putStrLn "VIRUS" >> return 5)
09:48:02 <Kron> hmmm
09:48:03 <Kron> fascinating
09:48:13 <Kron> anyway, I gtg now
09:48:16 <Kron> thanks
09:48:25 <stolaruk> My first "serious" Haskell project is starting to get off the ground and I've realized that I really need to start adding tests. Presently is there a de-facto test framework to help group and execute tests? (QC and HUnit) Hopefully something relatively simple and straightforward?
09:48:27 <Iceland_jack> Hope you found it interesting Kron :)
09:48:44 <Kron> stolaruk: quickcheck?
09:48:47 <Iceland_jack> stolaruk: QuickCheck is the one I use the most by far
09:48:56 <Kron> http://en.wikipedia.org/wiki/Quickcheck
09:48:58 <stolaruk> Yes I want to use QuickCheck and HUnit
09:48:59 --- mode: ChanServ set +o shachaf
09:49:00 <byorgey> stolaruk: these days you should probably look at tasty, http://hackage.haskell.org/package/tasty
09:49:01 <Kron> it's so powerful and popular
09:49:09 <Kron> that many other languages are implementing their own versions of it
09:49:10 --- mode: shachaf set +b Maxuma!*@*
09:49:10 --- kick: Maxuma was kicked by shachaf (Maxuma)
09:49:14 --- mode: shachaf set -o shachaf
09:49:17 <haasn> byorgey: interesting!
09:49:22 <Kron> haskell's probably got the best programmatic test system I know
09:49:22 <Iceland_jack> (and don't forget monadic QuickCheck!)
09:49:33 <stolaruk> I'm aware of test-framework and tasty... Looks like Tasty is the new thing?
09:49:49 <byorgey> yes, test-framework is pretty much unmaintained now
09:50:01 <stolaruk> My question is regarding the choice between test-framework and other similar packages
09:50:17 <Kron> anyway, toodles
09:50:35 <stolaruk> ok will look into tasty then
09:51:15 <stolaruk> is there a good tutorial on how to get it up and running?
09:51:48 <byorgey> stolaruk: http://documentup.com/feuerbach/tasty
09:52:10 <bennofs> stolaruk: http://ocharles.org.uk/blog/posts/2013-12-03-24-days-of-hackage-tasty.html
09:52:11 <stolaruk> Great thanks!
09:52:19 <guymann> h
09:53:00 <mebaran151> quit testing question actually: are there any examples of programmatically creating many tests (I have a series of test files with desired output and would like to put together a little test suite to test their output)
09:54:25 <byorgey> mebaran151: maybe check out http://hackage.haskell.org/package/tasty%2Dgolden
09:57:44 * hackagebot hsc3-server 0.8.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.8.0 (StefanKersten)
10:01:39 <b__> Is 'data Void a' or something similar in any package?
10:02:54 <Iceland_jack> yes, in void
10:02:56 <Iceland_jack> @hackage void
10:02:57 <lambdabot> http://hackage.haskell.org/package/void
10:05:50 <supki> Iceland_jack: I don't see  data Void a  there
10:06:47 <ion> supki: Perhaps you can emulate it with (Void, a)
10:07:21 <ion> or Tagged a Void
10:13:25 <ikervagyok> hi, i have a question - how can i use guards with the double value NaN? because I would like to filter all calculations, which result in NaN
10:13:55 <Kron> hmmm, do any haskell computations return NaN?
10:13:58 <ikervagyok> like 	reduceNW x@(min, max) 		| min == NaN	= Nothing 		| otherwise		= Just x
10:14:01 <geekosaur> NaN isnt a value /per se/
10:14:09 <Iceland_jack> > 0/0
10:14:10 <lambdabot>  NaN
10:14:10 <asmyers> :t isNaN
10:14:11 <lambdabot> RealFloat a => a -> Bool
10:14:18 <milfjord> > isNaN (0/0)
10:14:19 <lambdabot>  True
10:14:30 <ikervagyok> thanks :D
10:14:37 <ikervagyok> that should work :D
10:14:39 <armlesshobo> > isNaN(-0/0)
10:14:40 <geekosaur> (it's a bunch of different values, some of which may contain useful information about where they came from)
10:14:40 <lambdabot>  True
10:26:14 <hunt> what are my options for real time graphics?
10:27:11 <MagneticDuck> OpenGL
10:27:14 <MagneticDuck> =P
10:37:37 <joaoportela> > filterM (\x -> [True, False]) [1,2,3]
10:37:38 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
10:37:48 * hackagebot snaplet-persistent 0.3 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.3 (DougBeardsley)
10:37:49 <joaoportela> :t filterM
10:37:50 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:41:50 <byorgey> joaoportela: http://byorgey.wordpress.com/2007/06/26/deducing-code-from-types-filterm/
10:42:26 <milfjord> > filterM (return [True, False]) "wat"
10:42:27 <lambdabot>  ["wat","wa","wt","w","at","a","t",""]
10:42:39 <ion> [False,True]
10:42:51 <milfjord> > filterM (return [minBound .. maxBound]) "wat"
10:42:52 <lambdabot>  ["","t","a","at","w","wt","wa","wat"]
10:46:45 <bennofs> :t filterM
10:46:46 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:47:56 <hunt> so what should i use for real time graphics
10:49:21 <allspark> How do you make `error` work with non ascii characters, like this error "Cant call head on an empty list, dummy!"
10:49:40 <milfjord> why would you want to?
10:50:03 <ion> Also: worksforme
10:50:33 <cwvh> hunt: I would start with this blog and go from there: http://www.arcadianvisions.com/blog/?p=388
10:51:16 <allspark> curiosity. To rephrase the question, why doesn't it work with none ascii characters?
10:52:26 <ion> worksforme
10:52:26 <c_wraith> allspark: it does.  Is your terminal misconfigured?
10:54:51 <allspark> I get the same thing when running from the editor. I copied the text from LYAH.
10:55:51 <allspark> your client could be messing with that character
10:57:48 <geekosaur> or your browser could have messed with it
10:57:50 <allspark> It barfs after printing the first three character. Gives this error, test.hs: <stdout>: commitBuffer: invalid argument (invalid character)
10:58:03 <allspark> I'm not using a browser
10:58:06 <c_wraith> allspark: sounds like your terminal is misconfigured
10:58:10 <geekosaur> you copied it from lyah
10:58:18 <geekosaur> lyah is a printed book or it is a website
10:58:18 <allspark> the pdf doc
10:58:30 <milfjord> allspark: what OS are you on?
10:58:35 <geekosaur> pdf. if anything that's worse
10:58:37 <allspark> windoze
10:58:46 <[swift]_> this complains that "Could not deduce (Bounded a1) arising from a use of `minBound'", but I don't see why: https://gist.github.com/sethfowler/b6c55f199e773e4e7a23
10:59:03 <allspark> geekosaur: how's that?
10:59:05 <geekosaur> "chcp 65280" or some such?
10:59:11 <[swift]_> shouldn't the combo of ScopedTypeVariables and the "Bounded a" in the context of the outer function make this work?
10:59:27 <ion> swift: You need “forall a.” for ScopedTypeVariables to do its thing AFAIR.
10:59:39 <geekosaur> yes, you need to declare it as scoped with forall
11:00:45 <[swift]_> ion/geekosaur: sure enough, that fixed it. thanks!
11:01:32 <allspark> geekosaur: are you referring to the encoding?
11:02:05 <hunt> so according to cabal i already have OpenGL and OpenGLRaw installed, but when i try and import anything from Graphics (specifically Graphics.UI.GLUT) i get "Could not find module . . .".. help?
11:02:20 <geekosaur> actually it looks like the code page is 65001
11:02:38 <allspark> that's utf
11:02:45 <geekosaur> why yes it is
11:03:12 <ion> swift: Are you sure you need a type annotation for minBound at all?
11:04:04 <hunt> does anyone know about these OpenGL pains?
11:05:12 <allspark> oh well, it wasn't that important
11:06:50 <hunt> ah ok i know why gluts not showing up, but i depserately need help besides that. I've compiled my own ghc 7.8 and it appears to not be accessing the haskell platform, does anyone know how to fix this? (please!)
11:09:29 <hunt> nobody? im really lost here
11:10:12 <jle`> hunt: ghc doesn't come with haskell platform i think
11:10:33 <jle`> did you still the relevant modules?
11:10:45 <jle`> all packages have to be compiled for 7.8 separately
11:10:48 <hunt> jle` i have an older ghc from the haskell platform which when used can find Graphics.*, but my ghc7.8 cant,
11:11:01 <hunt> oh i guess
11:11:05 <jle`> 7.8 can't use 7.6 packages
11:11:05 <hunt> should i cabal install the platform?
11:11:13 <jle`> you should just cabal install the relevant packages :)
11:11:28 <jle`> i ahve forgotten what the platform was anyway
11:11:33 <hunt> cabal reinstall?
11:11:40 <hunt> so that they get compiled with new ghcs?
11:12:05 <jle`> if the new ghc is in your PATH, cabal install will work
11:12:09 <jle`> unless it is already installed
11:12:14 <jle`> in which case you have bigger problems
11:12:33 <jle`> if new ghc is in your PATH, cabal will not remember anything you did in old ghc
11:12:49 <jle`> see in .ghc/ there should be two folders, one for old ghc and one for new ghc
11:12:53 <jle`> ~/.ghc
11:13:28 <hunt> yea there are
11:13:36 <hunt> ghc is currently pointing to the new one
11:13:40 <hunt> but i dont know how that happenned
11:13:50 <hunt> oh i brew installed it
11:14:01 <jle`> if you cabal install opengl, what happens?
11:14:04 <jle`> (with new ghc)
11:14:25 <hunt> it failed on the last step with permission denied
11:14:28 <hunt> so im redoing it with sudo
11:15:16 <jle`> that's interesting
11:15:25 <jle`> but i have never tried installing on mac before
11:15:38 <geekosaur> dont use cabal with sudo
11:16:00 <hunt> ok so i reinstalled opengl
11:16:10 <hunt> and ghc still cant find Graphics.*?
11:16:25 <geekosaur> you redid it with sudo
11:16:35 <hunt> will old ghc still can
11:16:36 <geekosaur> so it's installed in *root's* ghc libraries
11:16:38 <geekosaur> not global ones
11:16:58 <hunt> shouldnt my new ghc also be in root's ghc
11:17:18 <geekosaur> your ~/.ghc is not root's ~/.ghc, no
11:17:25 <hunt> where is my roots .ghc
11:17:26 <geekosaur> or if it is, no wonder you have permission errors
11:17:30 <hunt> i dont have a /.ghc
11:17:40 <geekosaur> usually /root. don't expect to copy stuff from there
11:17:47 <gfredericks> does self-hosting imply turing completeness?
11:17:54 <hunt> i have no /root either
11:18:07 <geekosaur> oh wait, you're on os x. not sure where it would end up
11:18:30 <hunt> is there any command to check?
11:18:58 <geekosaur> /var/root apparently
11:19:10 <geekosaur> (dscl . read Users/root)
11:19:20 <hunt> i have no /var/root/.ghc
11:20:05 <hunt> jle` do you have any ideas?
11:20:40 <jle`> did you ever use sudo when installing ghc/cabal in the first place?
11:20:49 <geekosaur> other possibilities might be that it landed in yours but the package config isn't readable because you ran as root. (another reason not to use sudo: depending on local config and command line options, it might run in your config or root's, or potentially scattered over both if some things use lookup by uid and others use envars and ...)
11:20:53 <jle`> and did opengl work with your old ghc?
11:22:04 <hunt> jle` i dont think so and yes it did
11:22:54 <hunt> my .ghc folder for the new ghc has configuration files for OpenGL
11:23:05 <}}}> why is haskell not as popular as e.g. java
11:23:17 <hunt> whereas my ,ghc folder for old ghc only has config for Cabal
11:23:25 <jle`> }}}: the typical answer is 'marketing'
11:23:32 <hunt> although my new .ghc has no config for Cabal
11:24:43 <}}}> how do i learn haskell?
11:25:02 <jle`> hunt: hm what cabal version do ou have?
11:25:06 <jle`> }}}: lyah
11:25:10 <jle`> @where lyah
11:25:11 <lambdabot> http://www.learnyouahaskell.com/
11:25:37 <hunt> jle` 1.16.0
11:25:46 <klrr> cabal install cabal-install
11:25:52 <klrr> 18 has sandboxes :D
11:25:55 <jle`> hunt: try cabal update; cabal install cabal-install
11:26:00 <jle`> i'm not sure if it will make a big difference
11:26:03 <klrr> ^ yeah
11:26:12 <jle`> but also having done something in sudo might have messed things up possibly
11:26:18 <jle`> maybe
11:26:35 <jle`> i haven't tried doing it on mac
11:27:59 <hunt> jle` ok its installing, although i did cabal update -> install right before statring this
11:28:08 <skypers> @hoogle [a] -> Bool
11:28:09 <lambdabot> Prelude null :: [a] -> Bool
11:28:09 <lambdabot> Data.List null :: [a] -> Bool
11:28:09 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
11:28:09 <hunt> weird
11:28:13 <hunt> so ive installed the new cabal
11:28:18 <skypers> @pl not . null
11:28:18 <lambdabot> not . null
11:28:19 <hunt> but cabal still is version 1.16
11:28:42 <jle`> hunt: what does which cabal point to?
11:29:22 <jle`> try hash -d cabal
11:29:22 <hunt> shared with ghc in /usr/local/bin/cabal
11:29:42 <jle`> what does /usr/local/bin/cabal --version say?
11:29:43 <hunt> hash -d reported nothign
11:30:05 <jle`> sometimes the shell caches the old binary location even when there is a new one
11:30:05 <hunt> 1.16
11:30:09 <jle`> hm
11:30:15 <milfjord> is there a ~/.cabal/bin/cabal?
11:30:15 <jle`> how about ~/.cabal/bin/cabal ?
11:30:26 <hunt> lo
11:30:42 <hunt> there is
11:30:52 <jle`> ~/.cabal/bin should be in your path anyway
11:30:54 <hunt> version 1.18
11:31:11 <byorgey> by default, cabal installs things into ~/.cabal/bin
11:31:20 <hunt> :/ wont that cause an error with 2 cabals on the same path
11:31:31 <jle`> well
11:31:32 <hunt> why is my cabal pointing to the rot one instead of this one
11:31:34 <jle`> binaries shouldn't care
11:31:37 <byorgey> no. Just make sure ~/.cabal/bin comes earlier in your path.
11:31:55 <jle`> hunt: it migh be because either you don't have the home one in your path
11:32:04 <jle`> er well it probably is
11:32:26 <jle`> also you shouldn't have two cabals
11:32:29 <jle`> only one that works for both
11:32:38 <jle`> cabal doesn't care about the ghc version
11:32:45 <hunt> so why do i? this is strange
11:32:51 <geekosaur> it's not strange
11:33:02 <hunt> also is the ebst practice for mac paths to include an export in .bashrc?
11:33:03 <geekosaur> one came from your haskell platform install (homebrew?)
11:33:11 <geekosaur> one came from using `cabal install`
11:33:13 <jle`> yeah i have a cabal there too, go figure
11:33:15 <hunt> i wish i remembered exactly how installed
11:33:26 <geekosaur> the latter will never --- and should never --- overwrite stuff instaleld by package managers
11:33:26 <hunt> ah ok, thats not so bad then
11:34:10 <fizbin> Anyone here understand GADTs ? Is there a real use to them if you aren't dealing with recursive data types?
11:34:36 <jle`> probably to feel smarter about yourself. (or stupider if that's your deal)
11:34:54 <hunt> this probably isnt going to fix the lack of Graphics though, is it?
11:35:33 <jle`> hunt: who knows :)
11:36:23 <hunt> it didnt ;_;
11:36:36 <hunt> at least i hvae version 1.18
11:36:57 <orzo> fizbin: yes
11:36:58 <geekosaur> fizbin: bringing constraints into scope maybe
11:37:14 <orzo> its usefull for data instances too i believe
11:37:14 <fizbin> geekosaur: How so?
11:38:11 <hunt> oh man this is such a clusterfuck
11:38:40 <geekosaur> constraints of the form `data Foo a = Bar a => Foo a` don't do what people expect (bring the Bar constraint into scope when pattern matching a Foo), and can't. the GADT formulation, however, does
11:38:45 <geekosaur> (IIRC)
11:38:57 <geekosaur> also why the former requires an extension now
11:40:10 <hunt> im reinstalling again and maybe i will achieve salvation
11:40:24 <hunt> lend me your hearts
11:41:04 <hunt> what is -lHStext-1.1.0.0-ghc7.8.0.20140219
11:41:10 <hunt> it just failed because that wasnt found
11:41:58 <jle`> it's the linker
11:42:04 <hunt> oh god
11:42:10 <jle`> it might be because you used 1.16 before, i had that problem
11:42:24 <geekosaur> specifically it means it can't find the implementation library for the "text" package for ghc 7.8
11:42:41 <hunt> so what do i do? my skills are: panicking
11:42:45 <hunt> panicing
11:42:57 <hunt> panicking
11:43:22 <hunt> jle` what did you do?
11:43:28 <jle`> heh
11:43:31 <jle`> um
11:43:43 <jle`> i ghc-dpk'd everything i think
11:43:59 <jle`> er, ghc-pkg unregister
11:44:14 <jle`> there is a script here http://stackoverflow.com/questions/12048352/my-cabal-packages-are-fubar-how-can-i-purge-them-and-start-over
11:44:20 <jle`> but it'll also reset your old ghc packages too
11:44:30 <hunt> so ill be back to ghc 7.8?
11:44:37 <hunt> or ghc 7.6 wont work either?
11:44:49 <jle`> you can also just rm the .ghc/7.8 folder
11:44:51 <jle`> and try everything again
11:46:06 <hunt> jle` so after i do that, do i need to reinstall cabal install
11:46:07 <hunt> ?
11:47:18 <jle`> you should cabal update and cabal install cabal-install again just in case
11:47:22 <jle`> and make sure you're using 1.18
11:47:57 * hackagebot language-puppet 0.12.3 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.12.3 (SimonMarechal)
11:48:11 <hunt> ok im working on it, any idea why this whole process smashed my libs?
11:48:18 <hunt> something to do with that sudo way back?
11:50:36 <hunt> jle` http://pastebin.com/Pr6tZNqk this doesnt look good :|
11:50:51 <hunt> that came after zlib
11:51:52 <hunt> holy hell why doesnt openfile exist?
11:53:00 <sipa> "holy hell"... that's an uncommon one
11:54:24 <hunt> sipa, good point lol
11:55:13 <geekosaur> openfile exists, the file it tried to open didn't, try running it again with "cabal -v3 ..." to get more information
11:59:14 <athan> Would conduits be a good idea for streaming audio data (to JACK audio, specifically?), or for realtime audio synthesis?
11:59:40 <athan> Or really, what are some good real-time applications of haskell?
11:59:50 <hunt> geekosaur, from what i understand cabal downloads text and then immediately fails http://pastebin.com/dFt8wmF6
12:02:09 <hunt> oh gosh i hate packaage management
12:05:56 <ReinH> athan: DSP is generally on the harder end of soft realtime. Buffers allow flexibililty but introduce latency, etc.
12:06:06 <orzo> yes, cabal is inferior as a pckage manager
12:06:14 <hunt> guys, i cant cabal install text because when i do it says "/Users/me/.cabal/packages/hackage.haskell.org/text/1.1.0.1/text-1.1.0.1.tar.gz.etag does not exist" and it doesnt, only 1.1.0.0 exists
12:06:18 <hunt> what do i do
12:06:21 <ReinH> Well, it isn't one, so I guess that makes sense
12:06:33 <hunt> i cant really compile anything until i get around this
12:06:33 <orzo> the linux distros have superior package managers built in, that ideally would have been leveraged for haskell
12:06:50 <orzo> there could be an apt source for all hackage packages
12:06:52 <geekosaur> because of course only linuxers run ghc
12:06:55 <ReinH> orzo: how would that have worked?
12:06:59 <geekosaur> especially when talking to someone trying to build on os x
12:07:05 <hunt> <- this guy
12:07:11 <joelteon> ^ that guy
12:07:21 <orzo> well i said "ideally"
12:07:21 <ReinH> orzo: you would need n versions of each package and package maintainers would not have to deal with n different distributions
12:07:25 <ReinH> Sounds terrible to me
12:07:31 <orzo> in my ideal world everyone uses linux
12:07:40 <ReinH> You'd have n different dependency resolution mechanisms
12:07:56 <geekosaur> presumably by linux you also mean some debian derivative
12:07:57 <hunt> in my ideal world were all emotionless plant life
12:07:59 * hackagebot damnpacket 0.5.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.5.0 (JoelTaylor)
12:08:04 <geekosaur> ,y f19 work box scoffs at your apt
12:08:04 <orzo> heh
12:08:25 <ReinH> You wouldn't be able to ship haskell platform at all
12:08:35 <hunt> seriously though what the hell do i do, i cant install text
12:08:40 <hunt> does anyone have a clue
12:09:04 <orzo> actually, an debian source for hackage is a good idea, theres's tools to turn cabal packages into debian ones effortlessly
12:09:21 <ReinH> Or if you did you'd ship it for n different package managers. Again taking an immense but decentralized maintenance burden and centralizing it.
12:09:24 <hunt> i already have a tar for 1.1.0.0
12:09:31 <orzo> cabal-debian
12:10:00 <hunt> i cant even fetch text
12:10:06 <geekosaur> not even certain why you're trying to run an unreleased compiler version (for which some packages have not yet been updated)
12:10:13 <orzo> the auto-building aspects would be useful to hackage authors too
12:10:17 <hunt> is say this tar.gz.etag does not exist
12:10:26 <ReinH> I can't even imagine maintianing haskell packages for yum o_O
12:10:45 <centrx> Is there a good Haskell tutorial for someone coming from Ruby (and C, etc.)?
12:10:52 <hunt> geekosaur: i was told to update by someone else here a while back to get around bugs preventing use of certain packages
12:11:03 <ReinH> @where lyah
12:11:03 <lambdabot> http://www.learnyouahaskell.com/
12:11:11 <ReinH> centrx: ^
12:11:24 <hunt> geekosaur: i cant even fetch the text
12:11:25 <geekosaur> the problem with that is that you can't yet get some packages for 7.8 because it's still a release candidate
12:11:39 <hunt> geekosaur: but fetching doesnt seem like a ghc error to me?
12:11:48 <geekosaur> and some packages won't be updated until the final release
12:12:11 <Iceland_jack> centrx: Learn You a Haskell is a good resource
12:12:30 <centrx> Thanks
12:12:35 <Iceland_jack> Here's a minimal "hello, world!" program
12:12:35 <Iceland_jack>     main = putStrLn "Hello, world!"
12:12:35 <geekosaur> no, it's not. it may be a "this package version is not yet available" although I would expect to find that out from thepackage index saying it doesn't exist...
12:12:35 <Iceland_jack>  
12:13:04 <hunt> geekosaur: is there anyway to install the text 1.1.0.0 tar i already have with the new ghc?
12:13:24 <jle`> woo hoo submitted my first hackage package :)
12:13:32 <geekosaur> this may iundicate that for some reason hackage's packge index is out of sync with the actual packages, and nobody had noticed because they're not trying to install those packages for an unreleased compiler version
12:13:35 <hunt> jle` nice! what is it
12:13:39 <ski> hunt : re your <http://pastebin.com/UbvsrZCJ> from two days ago, i think there's no point in making a type class for that
12:13:58 <hunt> ski: looks removed to me
12:14:42 <ski> hunt : if you copied the `<' or the `>' into your browser, please remove them from the URL
12:14:44 <geekosaur> --constraint='text == 1.1.0.0' cabal option might help. then again it might report that it can't install that version because it's not compatible
12:14:52 <dwcook> No it's Freenode webchat, it includes the >
12:15:03 <ski> (and if your IRC client or terminal automatically copied any of them, then i think they are broken)
12:15:11 <dwcook> which I believe is a bug since I don't think > is a valid url char
12:17:01 <ski> dwcook : yes, see e.g. <http://tools.ietf.org/html/rfc3986#appendix-C>, or "Thus, only alphanumerics, the special characters \"$-_.+!*'(),\", and reserved characters used for their reserved purposes may be used unencoded within a URL." at <http://tools.ietf.org/html/rfc1738>
12:17:03 <hunt> geekosaur: building...
12:17:52 <hunt> ski: i ended up not having a vector class, but it would be useful precisely to allow for complex matrix functions accross implementations, probably better as a type then a class
12:18:00 * hackagebot tagged-binary 0.1.0.0 - Provides tools for serializing data tagged with type  information.  http://hackage.haskell.org/package/tagged-binary-0.1.0.0 (jle)
12:18:02 <geekosaur> and if that works then there is a problem with hackage, specifically that packages it lists in its index are not actually downloadable
12:18:46 <hunt> geekosaur: it did work :O
12:18:49 <matheus23> is there something in haskell that has 2x the bits of Int?
12:19:03 <milfjord> (Int, Int)
12:19:12 <dv-> ha
12:19:17 <hunt> :t Int64
12:19:17 <lambdabot> Not in scope: data constructor `Int64'
12:19:32 <geekosaur> hunt: many ghc builds have 64-bit Int even on 32-bit systems
12:20:06 <matheus23> milfjord: Preferebly something that implements 'Num' and is only packed 1 time :)
12:20:15 <Hrumph2> hi
12:20:20 <hunt> geekosaur: so what do we do now that it turns out there might be a hackage problem
12:20:22 <dwcook> matheus23, why not Integer, which is arbitrary precision?
12:20:23 <milfjord> matheus23: what for?
12:20:41 <matheus23> dwcook: counting the progressed milliseconds in a game
12:20:46 <Hrumph2> anyone know of a a function of type (a->b) -> [Maybe a] -> [b]    ?
12:20:57 <dwcook> matheus23, so?
12:21:01 <Hrumph2> the idea is that it operates only on the Just x members of the list
12:21:08 <hunt> how many bytes does Integer take as it increases
12:21:12 <fizbin> @pl curry (join . uncurry (flip fmap))
12:21:12 <lambdabot> curry (join . uncurry (flip fmap))
12:21:21 <hunt> :t curry
12:21:22 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:21:32 <fizbin> @pl let f mv fcn = join (fmap fcn mv) in f
12:21:32 <lambdabot> (join .) . flip fmap
12:21:36 <matheus23> dwcook: an int (2^30) only allows for 298 hours of gameplay until overflowing :D
12:21:39 <hunt> :t uncurry
12:21:40 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:21:44 <apples`> Hrumph2: map f . catMaybes ?
12:22:03 <dwcook> matheus23, I think you might have confused who asked you what. I said "Why not Integer?" It sounds like you responded to milfjord's question to me.
12:22:18 <matheus23> yeah sorry ^^
12:22:26 <ClaudiusMaximus> [ f x | Just x <- xs ] -- Hrumph2
12:22:27 <matheus23> yes. Integer might be a good idea.
12:22:36 <fizbin> Hrumph2: map f . catMaybes id
12:22:39 <matheus23> I only do it once a frame anyways ^^
12:22:43 <milfjord> matheus23: Int isn't 2^30
12:23:02 <matheus23> milfjord: Oh. It might be 2^29 (only counting positive) (or maybe 2^29-1)
12:23:04 <milfjord> matheus23: Int is either 32 or 64 bits, and there's an Int64 if you want to make sure
12:23:08 <geekosaur> well, that is interesting. 1.1.0.1 is listed on hackage and seems to exist. but I have no idea what the etag thing is about
12:23:09 <hunt> jle` whats your package
12:23:12 <milfjord> matheus23: 2^32
12:23:16 <fizbin> :t let tstfunc f = map f . catMaybes id in tstfunc
12:23:17 <lambdabot>     Couldn't match expected type `a0 -> [a1]' with actual type `[a2]'
12:23:17 <lambdabot>     In the return type of a call of `catMaybes'
12:23:17 <lambdabot>     Probable cause: `catMaybes' is applied to too many arguments
12:23:23 <geekosaur> matheus23, the haskell standard defines that to be a minimum size
12:23:28 <matheus23> milfjord: The Haskell98 standard specifies Int to have _at least_ 2^30 bits
12:23:32 <prinsen> is something like this possible to do: http://lpaste.net/101081
12:23:40 <Kaidelong> milfjord: the standard requires it to be bigger than 2^30, it is allowed to be bigger
12:23:51 <Kaidelong> equal to or bigger than*
12:23:53 <milfjord> Kaidelong: thank you for your interest
12:24:07 <fizbin> Oh, right. I was thinking mapMaybes. What apples` said, Hrumph2)
12:24:15 <athan> Do you think FP complete should have certifications for Haskell? I feel like it's such a powerful tool that isn't just taught in schools, and it's such a foreign language to management that a cert might be a good option. Any ideas?
12:24:23 <milfjord> matheus23: that's technically wrong but what I said applies to ghc
12:25:18 <hunt> so i reinstalled all of this, i cabal installed opengl, and ghc STILL doesnt find it
12:25:23 <matheus23> milfjord: What is technically wrong? ôo
12:25:25 <hunt> should i just quit haskell?
12:25:44 <Kaidelong> matheus23: can you think of a situation where you need to store 2^32 frames? You can probably allow it to roll over and still report accurate times?
12:25:56 <milfjord> matheus23: 30 bits, not 2^30 bits
12:25:59 <Kaidelong> by looking at the earliest previous frame
12:26:16 <Kaidelong> it's unlikely that someone will play more than 300 hours in a single sitting
12:26:20 <milfjord> > maxBound :: Word
12:26:21 <lambdabot>  18446744073709551615
12:26:23 <Kaidelong> so you could just assume it rolled over only once
12:26:27 <matheus23> milfjord: ugh, yeah my mistake ^^
12:26:30 <geekosaur> in any case Int will have either 32 or 64 bits in ghc, you can query ghci for maxBound :: Int
12:27:02 <hunt> :k Word
12:27:02 <lambdabot> *
12:27:03 <matheus23> Kaidelong: It's also about running a server (which runs permanently), and I don't store frames, I simply count my time
12:27:03 <fizbin> @type mapMaybe . fmap -- Hrumph2
12:27:04 <lambdabot> (a -> b) -> [Maybe a] -> [b]
12:27:27 <geekosaur> maybe you just want Integer
12:27:31 <Kaidelong> matheus23: in that case maybe you should consider using real-time or a purpose-built time type
12:27:36 <matheus23> geekosaur: Yeah I thought so too :)
12:27:46 <dwcook> matheus23, out of curiosity, do you count ticks on each frame or do you subtract start time from current time?
12:27:52 <dwcook> Or something else?
12:27:52 <Kaidelong> rather than counting it in terms of frames
12:28:16 <dwcook> s/ticks on each frame/frames/
12:30:50 <matheus23> dwcook: not quite so easy. I (simplyfied) have a function "draw time :: Int -> IO ()" where "time" is in milliseconds, and interpolates between the last and next gamestate "getGameState tick :: Int -> IO ()" then "draw time = drawGameState $ interpolate (getGameState (time `div` 25)) (getGameState (time `div` 25))"
12:31:47 <matheus23> It's simplified. getGameState is not called everytime again, it's buffered somewhere, of course
12:32:12 <matheus23> And the "time" is synchronized between server and clients
12:32:52 <Kaidelong> is that supposed to be time `div` 25 for both?
12:33:23 <hunt> is there any way i can test if cabal installed packages are actually being seen by ghc
12:33:31 <hunt> like with a basic package
12:33:42 <dwcook> matheus23, is it dependent on the system clock? If so, you might run into problems.
12:33:43 <matheus23> Kaidelong: nope :D
12:33:45 <Kaidelong> hunt: you can try importing in ghci
12:33:55 <Cale> hunt: Use ghc-pkg list <packagename>
12:34:09 <dwcook> matheus23, e.g., what happens when someone changes the system time a year ahead?
12:34:21 <dwcook> (Ideally it would have no effect)
12:34:58 <matheus23> dwcook: I could (instead of using the milliseconds time) use the tick time...
12:35:00 <Cale> hunt: If the package shows up as blue, it is hidden, which means it's available only if explicitly loaded with -package flags to GHC or via cabal dependencies
12:35:04 <matheus23> (with use I mean synchronize)
12:35:31 <Cale> (and you can hide or expose packages using ghc-pkg)
12:36:10 <Cale> If it's red, that means that it is broken, probably because one or more of its dependencies had been replaced after the fact, and it needs to be rebuilt
12:36:40 <Cale> ("ghc-pkg check" can tell you more about problems like that)
12:36:49 <hunt> ok so if i have this http://pastebin.com/JWvxyhyL ghc-pkg seems to recognize the opengl exists, but ghc doesnt
12:36:54 <hunt> what does that imply?
12:37:03 <hunt> my ghc version is 7.8.0...
12:37:07 <matheus23> dwcook: I guess, that wouldn't change much, but I somehow need to have a common notion of time between server and client... (I could simply say "It's your fault, when one client decides to change his system clock by a year")
12:38:46 <hunt> Cale: could it be that the package just doesnt support my version of ghc?
12:39:49 <Cale> hunt: GLUT is in the GLUT package
12:40:00 <Kaidelong> hunt: what exactly is happening to make you think ghc can't find it?
12:40:00 <Cale> It's separate from OpenGL
12:40:11 <Kaidelong> are you maybe just missing an import in your .cabal file?
12:40:12 <Cale> If you  cabal install GLUT
12:40:18 <Cale> then you should be able to import that library
12:40:40 <Cale> (i.e. this one http://hackage.haskell.org/package/GLUT)
12:41:05 <Kaidelong> if it really can't find it, do you perhaps have multiple versions of the haskell platform installed?
12:41:28 <hunt> HAHAHA YES!!!!!! CALE YOURE THE BEST! I'd like to thank geekosaur, jle`, and the haskell community for their patience, Kaidelong for the words of wisdom as i set out on this new chapter in my life, and my mother for cooking me hot pockets
12:41:37 <hunt> in other words, everything is swell now
12:41:41 <Cale> lol :)
12:44:08 <hunt> > 1 + 1
12:44:09 <lambdabot>  2
12:45:05 <milfjord> > a + b
12:45:06 <lambdabot>  a + b
12:47:32 <quchen> Is there some way of defining new kinds without having a type associated to it?
12:48:16 <quchen> (And then maybe later add some)
12:48:49 <joaoportela> > sqrt 4761
12:48:50 <lambdabot>  69.0
12:49:19 * joaoportela is very mature
12:49:54 <dwcook> quchen, like a void kind?
12:50:10 * dwcook wonders what that'd be useful for
12:51:00 <ReinH> Cale: so I ended up doing my entire talk on monoids.
12:51:08 <Cale> ReinH: cool
12:51:08 <zenkeku> So, I'm having an issue with installing xmonad-extras. Here is a paste bin: http://pastie.org/8910729 -- Any ideas?
12:51:15 <ReinH> Cale: it went well
12:51:25 <quchen> dwcook: Possibly. With DataKinds I always get "kinds with associated types". Would it make sense to have kinds where you can later specify which types have it? Suppose for example I want two different natural number types that both have kind Nat.
12:51:42 <quchen> Wait, would that even typecheck? Anyway, I was just wondering.
12:52:15 <quchen> ReinH: What talk?
12:52:22 <ReinH> quchen: I gave a talk on math at a Ruby conference
12:53:47 <Cale> zenkeku: hmm, it might be worth making a sandbox to build xmonad and xmonad-extras in. Of course, you can also just reinstall those 3 packages that are going to get broken (and hope that doesn't break a whole bunch of other things in turn)
12:54:22 <Cale> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:54:25 <geekosaur> xmonad and sandboxes don't mix very well
12:54:27 <zenkeku> Cale: Could this possibly be related to cabal wanted to install a lower version of itself?
12:54:35 <Cale> geekosaur: oh, hmm
12:54:59 <geekosaur> there's this problem with stuff that runs while setting up uyour user session, when you need the user session to exist before setting up the sandbox
12:55:19 <darthdeus> guys what would be the best way to write 500 million zeroes into a file?
12:55:23 <geekosaur> so you could do it but you'd have to build your xmonad config from the sandbox always
12:55:57 <milfjord> darthdeus: what for?
12:56:13 <darthdeus> milfjord: just learning, i'm trying to find the most optimal way to do this using haskell
12:56:24 <milfjord> what do you mean by "zeroes"?
12:56:35 <darthdeus> \0
12:56:47 <milfjord> seek, then write one byte
12:57:08 <darthdeus> but i want to write 500 million of those
12:57:18 <milfjord> why?
12:57:30 <ReinH> This doesn't seem like a good way to learn haskell. Or any other language.
12:57:34 <ChongLi> darthdeus: the operating system VFS will write the zeroes for you
12:57:39 <`^_^v> what is the name of the thing where you can write functions like odd (x + 1) = even x
12:57:40 <ChongLi> or the API
12:57:40 <milfjord> or to create files
12:57:51 <Cale> `^_^v: n+k patterns
12:57:54 <`^_^v> thanks
12:58:02 <Cale> They're deprecated
12:58:08 <Rarrikins> They're evil
12:58:11 <geekosaur> zenkeku: I think I'd use --constraint='ghc-mtl installed, parsec installed, text installed'
12:58:14 <zenkeku> http://lpaste.net/101082 <-
12:58:14 <Cale> I wouldn't say they're evil
12:58:18 <ChongLi> it's not going to fill your file with garbage data from whatever's on disk
12:58:19 <Rarrikins> I would
12:58:21 <darthdeus> ReinH: why isn't it a good way? it seems completely reasonable to be able to generate a ton of garbage in an optimal way
12:58:26 <Cale> The translation to support them is straightforward
12:58:36 <`^_^v> is there a more general term for it, that could be applicable in non-haskell contexts
12:58:41 <ReinH> darthdeus: because it doesn't teach you anything meaningful about Haskell
12:58:41 <milfjord> darthdeus: I told you the optimal way
12:58:53 <darthdeus> milfjord: you said to write a zero, not how to write 500 million of them
12:59:05 <milfjord> darthdeus: that's what the seek is for
12:59:14 <darthdeus> milfjord: seek is to move the cursor, no?
12:59:16 <milfjord> you only write the last one
12:59:41 <Rarrikins> You can probably write a strict bytestring several times.
12:59:43 <ReinH> darthdeus: you might learn how file systems work; you are unlikely to learn much about how Haskell works.
12:59:47 <darthdeus> ah lol, but i want to really write them :P like assume it's not zero but a character i'm getting form a random generater
12:59:54 <Cale> `^_^v: Well, n+k patterns exist to try to mimic how structural recursion on natural numbers looks, but with more general numeric types.
13:00:14 <milfjord> darthdeus: no, this is boring
13:00:27 <`^_^v> right
13:00:32 <darthdeus> i dont care about filesystems, i want to optimally generate a big blob of data, \0 was just a simple example
13:00:54 <milfjord> darthdeus: the optimal way to generate data is not to do it
13:01:00 <milfjord> hence laziness
13:01:13 <darthdeus> milfjord: well if the data would have to be random then i would have to generate it
13:01:22 * ReinH sighs
13:01:23 <Cale> There actually used to be an even more general version: c*n + k patterns :)
13:01:25 <milfjord> nah, you can just read from /dev/urandom
13:02:01 <Cale> So you could write  even (2 * n) = True; even (2 * n + 1) = False
13:02:05 <darthdeus> milfjord: no you can't, i'm not looking for a way of getting a random number, but for dumping a blob of data into a file
13:02:08 <darthdeus> that's a different thing
13:02:40 <milfjord> darthdeus: BS.writeFile
13:03:01 <seanparsons> With view patterns is there a way of expressing what this would do if it wasn't wrong (I want to match the result of B.length against the previous parameter):
13:03:01 <seanparsons> validSuffixContent index (B.length -> index) = True
13:03:01 <Rarrikins> hPut is probably better if darthdeus is writing the same thing over and over.
13:03:19 <darthdeus> milfjord: but ByteString must contain all of the data at once, no?
13:03:20 <ReinH> darthdeus: you said you can't use the seek method becauese you want random data. You said you can't use /dev/urandom because you don't want random data. Which is it?
13:03:28 <Cale> seanparsons: Perhaps you'd prefer to use a pattern guard?
13:03:29 <milfjord> darthdeus: yes, why?
13:03:49 <darthdeus> ReinH: i'm looking for a general solution in haskell, not a special device i can read the data from
13:04:05 <darthdeus> milfjord: because i don't want to have 500MB of data in memory if i'm generating it :P
13:04:08 <milfjord> darthdeus: you don't even have a problem. how can you look for a solution?
13:04:18 <milfjord> darthdeus: you keep changing your requirements
13:04:18 <Cale> seanparsons:  validSuffixContent index n | k <- B.length index, n == k = True
13:04:31 <darthdeus> because you keep giving me solutions which arent really real solutions
13:04:38 <dwcook> darthdeus, if you want randomness, try System.Random.
13:04:46 <ReinH> darthdeus: if you want real solutions, try giving us real problems.
13:04:59 <Iceland_jack> Cale: I'm wondering if you could allow mixfix operators for matching only with pattern synonyms..
13:05:03 <ReinH> Seeking and writing a byte is a completely real solution to your original problem.
13:05:11 <seanparsons> Cale: Yeah, I was just hoping to avoid that. :)
13:05:12 <darthdeus> milfjord: ok let's say i have   writeFile "derp" map something [0..500000000], but not in a way that it reads the whole thing into memory
13:05:24 <ReinH> So use pipes.
13:05:33 <milfjord> darthdeus: ok.
13:05:33 <Iceland_jack> so you could have
13:05:33 <Iceland_jack>     pattern 2*_+1 <- ...
13:05:33 <Iceland_jack>     pattern 2*_   <- ...
13:05:33 <Iceland_jack> instead of having it built in
13:05:33 <darthdeus> ReinH: what pipes?
13:05:36 <seanparsons> Cale: It seemed like it would be quite elegant if I could express it using a view pattern.
13:05:38 <ReinH> @hackage pipes
13:05:38 <lambdabot> http://hackage.haskell.org/package/pipes
13:05:49 <darthdeus> ReinH: thank you :P that's what i was looking for
13:06:09 <ReinH> darthdeus: then why didn't you just ask for it to begin with?
13:06:11 <Cale> Iceland_jack: Well, it also didn't just work for 2, but for all moduli
13:06:17 <Cale> Iceland_jack: But yeah, that's an idea
13:06:45 <darthdeus> ReinH: i did, you were too busy giving me workaround solutions for a different problem :P
13:06:52 <jle`> hunt: congrats :)
13:06:54 <ReinH> darthdeus: protip: if you want to know how to write a large file without keeping the contents in memory, just ask for that. Don't ask a bunch of other vaguely similar questions.
13:07:03 <ReinH> darthdeus: no. You didn't.
13:07:07 <Cale> You can certainly use view patterns to do the same thing as c*n+k patterns, and probably the definable patterns will be just as flexible
13:07:15 <Cale> (But I don't know much about that)
13:07:16 <ReinH> darthdeus: you asked a bunch of other questions, which we gave you answers for.
13:07:18 <milfjord> darthdeus: also, don't ask for "optimal"
13:07:42 <Iceland_jack> Cale: I think that patterns are one aspect of Haskell with exciting opportunities to innovate!
13:07:52 <jle`> hunt: if you try to cabal install i would think it would tell you what packages are not in your .cabal file that you are trying to import?  also ghc-mod would too i think :)
13:07:53 <hunt> does anyone know offhand a way to draw pixel by pixel in haskell opengl
13:08:04 <Iceland_jack> I have an idea of first-class patterns that I may sketch out one day
13:08:10 <darthdeus> jesus i'm not 10 years old, if i ask an open ended question, you don't have to be down right "you're stupid this obviously can be solved without haskell"
13:08:11 <jle`> aw i missed seeing my new package get posted by hackagebot live
13:08:34 <troydm> this: http://tinyurl.com/oqpnd49
13:08:37 <troydm> is IORef a safe functional way to do it?
13:08:41 <hunt> jle` congrats on the package
13:08:46 <milfjord> darthdeus: you asked for an optimal solution. the optimal solution has no code.
13:08:48 <troydm> i'm not familiar with it
13:08:53 <ReinH> darthdeus: Haskell folks are smart but I'm pretty sure we can't read minds. If you want an answer to a question, it's best to ask *that* question rather than other questions.
13:09:00 <jle`> hunt: ty :)
13:09:08 <seanparsons> Cale: I just attached the guard to the view pattern with a little tweak and that seems like it will do for now.
13:09:18 <darthdeus> milfjord: i asked in #haskell, so i sort of expect an answer related to haskell
13:09:24 <dwcook> troydm, if you've got only one thread accessing it, it's probably fine
13:09:38 <jle`> troydm: IORef makes sense in a functional context when you are modeling a computation that affects mutable state
13:09:42 <milfjord> darthdeus: you can call seek and write from haskell
13:09:46 <jle`> modeling? specifying?
13:10:08 <ReinH> At least, I don't think we can read minds over the internet. Maybe soon.
13:10:24 <dwcook> troydm, actually even if you've got more than one… meh, ignore me
13:10:28 <jle`> too much drama in #haskell today
13:11:01 <Iceland_jack> darthdeus: Let's assume good faith :) I at least hope that nobody was being malicious
13:11:27 <ReinH> Iceland_jack: I think we were trying to answer the questions we were given. :)
13:11:35 <jle`> troydm: the article in question gives a good rational for deciding to use IORefs to model state instead of the more familiar State monad solution
13:11:50 <jle`> it is important to remember that either way you are functionally and purely building up a stateful computation
13:12:09 <troydm> jle`: isn't State monad a safer way to do it?
13:12:13 <Iceland_jack> ReinH: Hooray for the XY problem :)
13:12:22 <jle`> IORefs/IO monad is no more impure than explicit state with State monad
13:12:30 <ReinH> Iceland_jack: indeed, but you know what they say about assumptions. :)
13:12:32 <jle`> troydm: what sort of 'safe' do you mean?
13:13:00 <ReinH> Iceland_jack: (That they make an ASS out of U and MPTION, of course)
13:13:01 <jle`> thread-safe?
13:13:05 <klrr> should i always use UNPACK if i got a datatype of several Int/Double?
13:13:05 <Iceland_jack> ReinH: Yes, they aren't just a river in ... oh right :)
13:13:09 <Cale> darthdeus: Have you tried simply using  writeFile "foo" (replicate 500000000 '\0')  ?
13:13:18 <troydm> jle`: wen pure computation is seperated from an impure evil I/O world
13:13:45 <jle`> troydm: IO is not impure :)  or at least any more impure than the state monad
13:13:53 <jle`> or well
13:13:54 <jle`> the IO monad is not impure
13:13:55 <Iceland_jack> ReinH: (I don't believe I've heard the variant of making an ass out of 'MPTION')
13:13:57 <jle`> IO is impure
13:14:08 <ReinH> Iceland_jack: (that's the joke)
13:14:12 <Iceland_jack> ;)
13:14:12 <Cale> darthdeus: It seems to work for me, anyway
13:14:24 <Cale> darthdeus: and it doesn't take too long or too much space
13:14:31 <Iceland_jack> Just like 'assistance' makes an ass out of ... wait
13:14:32 <darthdeus> Cale: yes i have, but it takes a loong time, so i thought it's doing it in a non-optimal way
13:14:37 <Cale> what?
13:14:37 <Rarrikins> klrr: If them being strict isn't a bad thing in any cases, probably.
13:14:52 <jle`> troydm: but yes now your program cannot have guaruntees about the ways it can interact with the world
13:14:53 <Cale> darthdeus: Maybe you didn't compile with optimisations?
13:15:00 <darthdeus> Cale: nah i just ran it in ghci :)
13:15:03 <Rarrikins> klrr: If you might need laziness in them, no.
13:15:09 <darthdeus> i'll try optimizing
13:15:18 <Cale> darthdeus: How long are we talking about?
13:15:20 <jle`> so with the state monad/ST monad, you have "mutable" state but you know that when you runST or runState, it will only do the narrow band of mutable things allowed by it
13:15:28 <Cale> It takes about 10 seconds here
13:15:28 <Iceland_jack> > zipWith (\a b -> a ++ " and " ++ b) (tails "istance") (inits "istance")
13:15:29 <lambdabot>  ["istance and ","stance and i","tance and is","ance and ist","nce and ista",...
13:15:35 <jle`> troydm: with IO monad you cannot runIO (ie, execute a program) with the same assurance
13:15:37 <darthdeus> Cale: 20 seconds by a wild estimate
13:15:53 <darthdeus> Cale: took 1-2 seconds using dd/head though, so i sort of expected a same number :P
13:15:59 <darthdeus> but maybe that assumption is wrong
13:16:29 <Cale> Well, obviously that's not going to be as efficient as something which works with raw bytes instead of 32 bit unicode characters.
13:16:41 <ReinH> jle`: you also can't runIO at all, so I agree in as much as your case is a specific instance of mine. ;)
13:16:45 <Cale> But it gets the job done :P
13:16:48 <troydm> jle`: yeah, i kinda understand
13:16:59 <darthdeus> Cale: i guess you're right
13:17:03 <Cale> I suppose we could try the lazy bytestring solution
13:17:06 <jle`> ReinH: isn't executing a program "runIO main" ?
13:17:08 <jle`> :P
13:17:23 <jle`> in an abstract sense
13:17:40 <darthdeus> Cale: is there an easy way to build a lazy bytestring from a sequence?
13:17:49 <klrr> Rarrikins: hmm, i think i need to read up on laziness, i thought it had to do with evaluation
13:17:52 <Cale> 6.8 seconds here
13:17:57 <Cale> main = BS.writeFile "foo" (BS.replicate 500000000 0)
13:18:10 <jle`> troydm: you actually kind of might be able to imagine a bunch of different, separate IO monads, with different ranges of functionality -- an IO monad that can only print, an IO monad that can only talk to IORefs, an IO monad that can only read files
13:18:28 <jle`> troydm: and actually, this functionality can be implemented fairly easily using free monads and even hand-rolled monads
13:18:43 <jle`> but it just wasn't the way that IO originally thought of for haskell
13:19:24 <darthdeus> Cale: compiled with -O3, running 13 seconds, wow
13:19:36 <Cale> -O3 doesn't exist
13:19:40 <troydm> jle`: i don't think i'm quite sure i understand what you are saying but let's say that i don't want ppl to think that i'm stupid so i'll pretend that i've understood everything
13:19:41 <darthdeus> :X
13:19:46 <Cale> It *should* clamp to 2
13:19:51 <jle`> troydm: here is a blog post where the author makes an "IO monad" that only has the ability to read and put to stdin/stdout
13:19:53 <jle`> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
13:20:17 <Cale> At one point it would just ignore the argument altogether if you used -O3 though :)
13:20:19 <jle`> troydm: so now you have a "IO monad" where if you run it, you can be *sure* that it will never do anything like launch missiles or overwrite your hard drive
13:20:46 <jle`> it will only read/put to stdin/stdout
13:20:55 <Cale> darthdeus: Is that for the String or ByteString version?
13:21:17 <darthdeus> import qualified Data.ByteString.Lazy as BS ... 13.64s
13:21:19 <jle`> so in this way you have all of the purity of the IO monad as well as the safety of a ST/State monad
13:21:36 <Cale> huh, twice as long as my machine took
13:21:44 <jle`> unfortunately it's quite a bit of work because there aren't any libraries already made that partition IO in this way for you for your specific use case
13:21:48 <jle`> actually, are there?
13:21:56 <darthdeus> my machine is ssd and i7 quad core :\
13:22:03 <Cale> darthdeus: It takes 0.252s here if I write to /dev/shm
13:22:10 <geekosaur> are you doing this in ghci?
13:22:12 <Cale> So, I suspect it's just I/O bound
13:22:42 <darthdeus> maybe my SSD is dying
13:22:45 <Cale> (maybe try that on your own machine, set the filename to /dev/shm/foo or something)
13:22:52 <darthdeus> 21.7 seconds with String, so ByteString is 2x faster
13:22:55 <Cale> My disk isn't even an SSD
13:23:02 <troydm> jle`: ic, i get it
13:23:16 <Cale> But I do have a lot of memory, so I have lots of space for I/O buffers
13:23:19 <jle`> troydm: you were right that the problem with IO isn't because it's impure but because it can do arbitrarily bad things without you knowing, if you don't have control of all the source code you are using.  this partitioning method gives all of the benefits and also with that security
13:23:28 <jle`> i wonder if people have already made libraries with pre-partitioned IO?
13:23:46 <jle`> everyone always rolls their own
13:23:51 <jle`> for their particular project
13:24:07 <Cale> darthdeus: That's actually underwhelming, I'd usually expect ByteString to be at least 4x faster
13:24:12 <troydm> jle`: i don't think that i've heard of any library that does that
13:24:40 <Cale> But yeah, seems about 2x faster here too
13:24:41 <jle`> you might want to look at http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html if you want to read more into this
13:24:43 <darthdeus> Cale: btw i dont have /dev/shm
13:25:23 <darthdeus> but with /dev/null it takes 0.1s
13:25:39 <jle`> but yes for a goal like 'write scheme in 48 hours', this might not be in the scope of the tutorial :P
13:27:21 <troydm> jle`: yeah, actually i'm not blindly following tutorial
13:27:53 <troydm> jle`: i'm doing some enchancments and i'm planning to make R7RS-small interpreter in haskell based on that tutorial
13:28:24 <jle`> troydm: ah :) well if you have time and are feeling adventurous, you might want to try writing a partitioned IO monad using the the techniques from chris taylor or gabriel gonzalez
13:28:31 <troydm> jle`: so i've already changed some stuff like parsec to attoparsec and String to Text
13:28:58 <jle`> actually i don't really see the advantage of using Control.Monad.Free instead of directly definining  (>>=) and return, which seem to be the same thing
13:29:16 <jle`> someone here may be able to correct me
13:29:40 <jle`> tekmo is usually online to prove me wrong but he is too busy changing the world at twitter
13:30:08 <klrr> haskell at twitter? =o
13:30:09 <jle`> (especially when it directly relates to his own article)
13:30:25 <jle`> klrr: well, he's programming scala
13:30:39 <Cale> My connection to freenode is flaking out, so I'm not sure what you got there
13:30:59 <klrr> okey
13:31:24 <isaacbw> where can I find the implementation of Maybe in prelude?
13:31:28 <klrr> would be cool if both facebook and twitter used haskell, could maybe convince my dad dwelling in haskell is not waste of time ^^
13:31:35 <jle`> klrr: facebook does use haskell
13:31:37 <jle`> for specific domains
13:31:41 <klrr> i know
13:31:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html#Maybe
13:32:04 <jle`> isaacbw: hoogle should be able to tell you :)
13:32:05 <Cale> isaacbw: Got that by finding Maybe here and clicking the source link on the right: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
13:32:10 <isaacbw> ah, thank you Cale!
13:32:22 <isaacbw> jle`: not sure what hoogle is, but I'll check it out
13:32:29 <klrr> isaacbw: search in hoogle then click "source" in haddock documentation
13:32:41 <jle`> isaacbw: ah, hoogle is your best friend :)
13:32:52 <klrr> isaacbw: http://www.haskell.org/hoogle/?hoogle=Maybe
13:32:58 <jle`> @hoogle (a -> m b) -> [a] -> m [b]
13:32:59 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:32:59 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:32:59 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:33:07 <klrr> @source Maybe
13:33:08 <lambdabot> Unknown command, try @list
13:33:08 <Cale> You might also enjoy http://www.haskell.org/onlinereport/standard-prelude.html
13:33:11 <klrr> @list
13:33:11 <lambdabot> What module?  Try @listmodules for some ideas.
13:33:15 <klrr> @listmodules
13:33:15 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:33:22 <Cale> which is partly pseudocode, but for the most part is quite informative
13:33:30 <klrr> @source Maybe
13:33:30 <lambdabot> Unknown command, try @list
13:33:32 <klrr> =o
13:33:46 <jle`> @src
13:33:46 <lambdabot> src <id>. Display the implementation of a standard function
13:33:48 <Cale> (in the real implementation, things are frequently implemented in an uglier fashion for performance sake)
13:33:58 <klrr> @src Maybe
13:33:58 <lambdabot> data Maybe a = Nothing | Just a
13:34:03 <klrr> :D
13:34:06 <jle`> :D
13:35:25 <darthdeus> Cale: btw i just tried /dev/null with String and it's 6 seconds and 0.1s for bytestring, so it's way faster if we ignore the I/O
13:36:21 <Cale> yeah
13:38:58 <jle`> is there any way to have ghc emit a warning if someone uses your library in the wrong way and tries to compile it?  sort of user-specified compile time warnings?
13:39:38 <merijn> jle`: Wrong in what way?
13:39:53 <merijn> darthdeus: String is terribad :p
13:39:55 <jle`> things that i am too lazy to enforce at the type level
13:39:58 <jle`> :)
13:40:04 <hunt> :t (<-)
13:40:05 <lambdabot> parse error on input `<-'
13:40:21 <dwcook> hunt, <- is part of do and comprehension syntax
13:40:28 <jle`> actually yeah these things probably cannot be detected at compile time, what i am thinking of
13:40:36 <jle`> nevermind.
13:40:49 <hunt> dwcook, isnt do syntax defined in haskell moniod?
13:41:06 <jle`> hunt: :|
13:41:11 <dwcook> hunt, it desugars to uses of (>>=) and (>>) if that's what you mean.
13:41:19 <hunt> thats what i mean
13:41:19 <dwcook> But it's still syntax and not an operator on its own.
13:41:28 <hunt> still havent learnt monoids, doing that maybe today
13:41:35 <dwcook> That's Monad, not Monoid.
13:41:41 <MagneticDuck> hunt: as we told you earlier....
13:41:45 <MagneticDuck> Monoids are pretty trivial
13:41:58 <MagneticDuck> mappend, mempty
13:41:59 <hunt> i know but ive got so much else i need to do / get a grip on
13:42:03 <jle`> well so are Monads...so trivial maybe isn't the best word here :)
13:42:13 <dwcook> () is trivial
13:42:15 <dwcook> :P
13:42:20 <jle`> monads are trivial... just return and join
13:42:22 <jle`> psh.
13:42:26 <byorgey> Calling Things Trivial Considered Harmful
13:42:29 <merijn> hunt: I can tell you already know at least three monoids :)
13:42:42 <Platz> say, if i have something like: liftA3 myjoin p q r $ x; myjoin a b c = a ++ b ++ c; is there a good way to avoid defining myjoin?
13:42:50 <Iceland_jack> jle`: Like with so many things, ‘trivial’ definitions but far-reaching consequences :)
13:42:53 <Cale> Though, actually saying much about the structure of monoids is really difficult
13:42:57 <hunt> merijn: case do and ?
13:43:16 <jle`> hunt: you probably are used to treating integers as a monoid under addition
13:43:19 <MagneticDuck> Cale: that's what I meant
13:43:21 <jle`> given two integers, you can add them
13:43:22 <Cale> By contrast, the theory of groups is much simpler (and even it's really quite complicated)
13:43:25 <jle`> to make a new integer
13:43:25 <Iceland_jack> Platz: liftA3 (\a b c -> a ++ b ++ c) p q r?
13:43:32 <merijn> hunt: Natural numbers with addition mappend is + and identity is 0, natural numbers with multiplication, where mappend is * and mempty is 1 and lists
13:43:37 <jle`> and there also exists an integer that does not change something when you add it to anything
13:43:48 <jle`> 1 + 2     ----> bam, new integer! 3!
13:43:50 <merijn> hunt: List have [] (empty list) as mempty and ++ (list concatenation is mappend)
13:43:54 <byorgey> why are we talking about monoids?
13:44:07 <hunt> is that actually how lists are implemented?
13:44:14 <MagneticDuck> hunt: x|
13:44:15 <Iceland_jack> #haskell always talks about monoids on Wednesdays
13:44:19 <dwcook> hunt, what do you mean by "that"?
13:44:33 <jle`> hunt: a monoid is actually not an implementation but a mathematical concept :)
13:44:34 <hunt> the monoidic mepmty [] and mappend ++
13:44:36 <MagneticDuck> no, they are implemented with [] and (:) :: a -> [a] -> [a]
13:44:44 <hunt> oh god i said i wasnt going to learn this yet
13:44:50 <MagneticDuck> hunt: why say that
13:44:52 <jle`> maybe the word math is scary?
13:44:53 <MagneticDuck> I mean
13:44:57 <merijn> byorgey: Why wouldn't we talk about monoids? I love monoids, they're so easy!
13:45:01 <hunt> because im in the middle of writing something
13:45:03 <hunt> and i need to finish
13:45:04 <jle`> ah
13:45:05 <dwcook> hunt, no, that's not part of the definition of lists. You can think of it as an interface they satisfy.
13:45:06 <jle`> haha
13:45:12 <MagneticDuck> hunt: ... I mean... why not just LEARN IT :D
13:45:14 <Platz> Iceland_jack: maybe if there's some function that concats all the args into a list, i can just compose that with concat?
13:45:21 <hunt> MagneticDuck its so tempting
13:45:25 <MagneticDuck> then do it
13:45:39 <hunt> no no im shutting this down its too distracting
13:45:41 <MagneticDuck> well I gtg have fun with typeclasses and math hunt
13:45:44 <MagneticDuck> lol hunt
13:45:49 <MagneticDuck> what is this distracting you from
13:45:53 <hunt> haskell
13:45:54 <jle`> monoids are just things that you can "combine" somehow, and that there is one identity element.
13:45:55 <Iceland_jack> Platz: yes you could do that, but you'd need a different composition
13:45:59 <}}}> what is haskell
13:45:59 <MagneticDuck> there couldn't possibly be something more interesting than learning math
13:46:05 <hunt> what is love
13:46:06 <jle`> also the operation has to be associative
13:46:10 <MagneticDuck> }}}: what is life
13:46:14 <jle`> :{{
13:46:15 <matheus23> }}}: what a good question to ask on #haskell :D
13:46:29 <hunt> > let haskell = haskell in haskell
13:46:29 <Eduard_Munteanu> :t (fmap concat .) . sequence
13:46:33 <lambdabot> [a -> [[a1]]] -> a -> [[a1]]
13:46:35 <jle`> @pl \x y -> [x,y]
13:46:36 <}}}> hunt: my brain just melted
13:46:37 <lambdabot>  mueval-core: Time limit exceeded
13:46:39 <lambdabot> (. return) . (:)
13:46:51 <jle`> @pl \x y z -> [x,y,z]
13:46:52 <lambdabot> (. ((. return) . (:))) . (.) . (:)
13:46:54 <jle`> aw.
13:46:59 <Iceland_jack> We should have list sections
13:46:59 <Iceland_jack>     [,,,] ∷ a → a → a → a → [a]
13:47:02 <MagneticDuck> hunt: > let haskell = let f x = f (f x) in f haskell
13:47:03 <MagneticDuck> or something
13:47:05 <jle`> lmao
13:47:11 <MagneticDuck> I'm not thinking, but that should get your mind working xD
13:47:11 <jle`> that would be al right.
13:47:22 <jle`> actually it might not be too bad especially with the new overloaded list literals
13:47:31 <matheus23> > let haskell = Nothing
13:47:32 <Eduard_Munteanu> :t (fmap mconcat .) . Data.Traversable.sequence
13:47:32 <lambdabot>  not an expression: `let haskell = Nothing'
13:47:32 <lambdabot> (Traversable t, Monoid b) => t (a -> [b]) -> a -> t b
13:47:33 <jle`> you can use list sections to make size-N Maps
13:47:33 <hunt> MagneticDuck What the hell
13:47:33 <Platz> also found myjoin = (. (++)) . (.) . (++) but this sucks
13:47:38 <Iceland_jack>     ([,'o','o',,'a','r'] ∶ Char → Char → String) 'f' 'b'
13:47:39 <Iceland_jack>     ⇒ "foobar"
13:48:08 <Eduard_Munteanu> Platz: when you have a bunch of (++) you might benefit from concat
13:48:26 <jle`> Eduard_Munteanu: for some reason he has to get them as a list of arguments
13:48:30 <jle`> he can't just put them in a list
13:48:36 <Platz> Eduard_Munteanu: but in the context of liftA3?
13:48:37 <matheus23> let haskell = Just "poop"
13:48:46 <matheus23> > let haskell = Just "poop"
13:48:47 <lambdabot>  not an expression: `let haskell = Just "poop"'
13:48:49 <jle`> let haskell = fix error in haskell
13:48:53 <jle`> > let haskell = fix error in haskell
13:48:53 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:49:03 <matheus23> lol
13:49:04 <jle`> but i thought haskell was supposed to fix my errors :/
13:49:16 <fizbin> > 1:2:3:4:5:[]
13:49:17 <lambdabot>  [1,2,3,4,5]
13:49:22 <Iceland_jack> jle`: It's lazy, it will get to it when it finishes evaluating that to normal form :)
13:49:24 <Iceland_jack> > let haskell = Just "poop" in haskell
13:49:24 <matheus23> @type fix
13:49:25 <lambdabot> (a -> a) -> a
13:49:25 <lambdabot>  Just "poop"
13:49:35 <Iceland_jack> > let haskell = Just "poop" in fmap reverse haskell
13:49:36 <lambdabot>  Just "poop"
13:49:36 <jle`> Iceland_jack: :P
13:50:12 <Iceland_jack> (I normally shy away from 'lazy' jokes wrt Haskell, they're lazy humour (god I did it again))
13:50:19 <jle`> > let haskell = Just "poop"; everythingelse = Nothing in max haskell everythingelse
13:50:19 <lambdabot>  Just "poop"
13:50:43 <Iceland_jack> An obvious truism
13:50:43 <Iceland_jack> > Just "poop" > Nothing
13:50:44 <lambdabot>  True
13:51:01 <jle`> > Just Nothing > Nothing
13:51:02 <lambdabot>  True
13:51:10 <jle`> :O
13:51:17 <Iceland_jack> jle`: That has interesting complications :)
13:51:18 <jle`> what have i done.
13:51:22 <matheus23> let isBetterThan = > in (Just "poop") isBetterThan Nothing
13:51:26 <Eduard_Munteanu> :t (:) <$> ?x <*> ((:) <$> ?x' <*> ?xs)
13:51:27 <lambdabot> (Applicative f, ?x::f a, ?x'::f a, ?xs::f [a]) => f [a]
13:51:29 <xpika> what's the difference between undefined and a Hole ("_")
13:51:33 <xpika> ?
13:51:39 <jle`> matheus23: before you > that, remember you have to (>)
13:51:46 <Iceland_jack> xpika: _ is not a hole, it's a pattern wildcard
13:51:48 <matheus23> > let isBetterThan = (>) in (Just "poop") isBetterThan Nothing
13:51:49 <lambdabot>  Couldn't match expected type `(a0 -> a0 -> GHC.Types.Bool)
13:51:49 <lambdabot>                                -> Data.Maybe.Maybe a1 -> t0'
13:51:49 <lambdabot>              with actual type `Data.Maybe.Maybe [GHC.Types.Char]'
13:51:53 <ion> iceland_jack: _ is a hole in GHC 7.8
13:51:55 <Iceland_jack> 'I have an answer, that answer is nothing' is better than 'I don't have an answer'
13:52:09 <jle`> xpika: matheus23 you need `` to use a function with letters as an operator
13:52:14 <Eduard_Munteanu> xpika: are you referring to the GHC 7.8 holes or simply the '_' in patterns?
13:52:16 <matheus23> ups forgot that
13:52:21 <matheus23> > let isBetterThan = (>) in (Just "poop") `isBetterThan` Nothing
13:52:22 <lambdabot>  True
13:52:22 <Iceland_jack> I shouldn't assume
13:52:33 <dagle> C++ makes me feel sad... why am I forced to use it...
13:52:42 <b0bbi10> hi, using the '`' char in Haskell is really annoying. how are you supposed to to `elem` without getting the e with an apostrophe?
13:52:50 <jle`> #haskell is definitely not a time sink at al.
13:52:53 <matheus23> > let isBetterThan = (>) in (show ((Just "poop") `isBetterThan` Nothing) ++ " Story")
13:52:53 <Iceland_jack> b0bbi10:
13:52:53 <Iceland_jack> > elem 'a' "hello"
13:52:54 <jle`> b0bbi10: is it annoying?
13:52:54 <lambdabot>  "True Story"
13:52:54 <lambdabot>  can't find file: L.hs
13:53:03 <Iceland_jack> > elem 'a' "hello"
13:53:04 <ion> xpika: undefined will compile silently and crash in runtime, _ with type holes will not compile silently and it will tell you the type the _ should have and also potentially useful values in scope to come up with an expression to fill the hole.
13:53:04 <lambdabot>  False
13:53:06 <zebr> b0bbi10: you mean with a grave accent?
13:53:14 <Iceland_jack> b0bbi10: You can also do (∈) = elem :)
13:53:29 <zebr> cos i don't see how ` -> '
13:53:31 <jle`> is ` any more annoying than ', "?
13:53:32 <b0bbi10> jle`, for me, it is
13:53:33 <Iceland_jack> > let (∈) = elem in 'a' ∈ "fan"
13:53:34 <lambdabot>  True
13:53:43 <zebr> jle`: well, on some keyboards it's a dead key
13:53:48 <jle`> ah, really
13:53:51 <jle`> well that is annoying.
13:53:55 <zebr> `a = à &c
13:53:58 <geekosaur> b0bbi10, you use a keyboard layout without dead keys, or bind ` the character somewhere
13:54:21 <xpika> ion: so it just gives you a different compiler message?
13:54:25 <fizbin> > text$(++)<*>show$"> text$(++)<*>show$"
13:54:25 <jle`> you can import Prelude.Unicode to automatically give you unicode elem
13:54:26 <lambdabot>  > text$(++)<*>show$"> text$(++)<*>show$"
13:54:42 <jle`> fizbin: nice
13:54:46 * geekosaur has right-alt bound to Multi_key, so è is rightAlt-` e and ` is just `
13:54:54 <matheus23> jle`: It's especially annoying on a German keyboard, where you have to Shift-Press a key TWICE to get that character
13:54:57 <ion> xpika: As in, “gives you a compiler message at all”
13:54:59 <Eduard_Munteanu> It's often a good idea to just write code in English rather than mix English syntax with names localized to your language. :)
13:55:01 <b0bbi10> geekosaur, I remember seeing that setting somewhere. will have a look, thanks
13:55:34 <zebr> matheus23: i think programming on any non-English keyboard is a bit of a bother. when i've tried programming on a norwegian keyboard it's been a nightmare.
13:55:36 <Eduard_Munteanu> jle`: er... Prelude.Unicode? Is that in 'base'?
13:55:41 <fizbin> Eduard_Munteanu: I recall a nasty case of local language identifiers leaking into error messages in PHP.
13:55:51 <matheus23> zebr: I hate me for having learned the german keyboard layout
13:55:52 <Iceland_jack> b0bbi10: You can always just use it as a regular function rather than infix
13:55:54 <jle`> Eduard_Munteanu: not in base :/
13:56:10 <jle`> http://hackage.haskell.org/package/base-unicode-symbols
13:56:17 <Eduard_Munteanu> Ah, thanks.
13:56:27 <fizbin> T_PAAMAYIM_NEKUDOTAYIM
13:56:50 <geekosaur> sadly that's not NLS, just PHP being weird
13:56:51 <jle`> i have given some serious consideration to using η = return
13:56:58 <geekosaur> they actually call the token that :/
13:57:19 <matheus23> geekosaur: fizbin: Oh PHP is weird.. yeah...
13:57:22 <Iceland_jack> jle`: Do you mean in actual code?
13:57:24 <zebr> geekosaur: yep, and decided not to explain in the error...
13:57:24 <jle`> do { x <- η 5; η (x + 3) }
13:57:33 <Iceland_jack> eek..
13:57:41 <jle`> your eyes just need to get used to it ;D
13:57:50 <Iceland_jack> jle`: It's not my eyes that I'm worried about :)
13:57:57 <fizbin> I remember when I was at Google doing a search over the internal codebase for non-ascii used outside of strings.
13:58:07 <zebr> the error now explains that they're expecting :: or whatever it is, but the token is still called that
13:58:15 <jle`> > let η = return in print $ do { x <- Just 5; η (x+3) }
13:58:16 <lambdabot>  <IO ()>
13:58:22 <jle`> > let η = return in do { x <- Just 5; η (x+3) }
13:58:23 <lambdabot>  Just 8
13:58:25 * Eduard_Munteanu tries to remember whether unary prefix/postfix operators were allowed.
13:58:30 <Iceland_jack> I'm very guity of using unicode in my own coding, but Haskell is viewed as intimidating enough already ;)
13:58:40 <Iceland_jack> Eduard_Munteanu: You need an extension for Postfix
13:58:53 <zebr> i have used é in haskell variable names, but that's about it
13:58:58 <fizbin> Non-ascii in code anyone else ever has to read is asking for trouble.
13:59:03 <Iceland_jack> Eduard_Munteanu: I actually found quite a charming use for it while I was chatting with a musician friend + Haskeller
13:59:14 <jle`> yes but return is so badly named
13:59:25 <zebr> fizbin: i think that's a shame, though. it's 2014. you would have expected utf8 uptake to be a little more than it is.
13:59:27 <jle`> the only solution is to return to our math roots
13:59:29 <jle`> and use η
13:59:30 <FireFly> fizbin: I dunno, I could see it being useful for mathematical identifiers and things
13:59:31 <Iceland_jack>     (♯) ∶ Note → ...
13:59:31 <Iceland_jack>     (C♯)
13:59:31 <fizbin> Using it as part of a public interface is just mind-boggling. (And yes, I found one such case when I did my search)
13:59:43 <Eduard_Munteanu> > let (η) = return in η Just 3 :: Either () (Maybe Integer)
13:59:44 <lambdabot>  Couldn't match type `a0 -> Data.Maybe.Maybe a0'
13:59:44 <lambdabot>                with `Data.Either.Either
13:59:44 <lambdabot>                        () (Data.Maybe.Maybe GHC.Integer.Type.Integer)'
13:59:44 <lambdabot>  Expected type: a1
13:59:44 <lambdabot>                 -> Data.Either.Either
13:59:54 <fizbin> I found non-ascii as local variables really only in go-language programs.
13:59:55 <jle`> it doesn't change precedence rules
13:59:55 <Iceland_jack> jle`: 'wrap' or 'pure' or 'make' or 'construct' or ....
14:00:10 <fizbin> And sure, it's all over comments and strings.
14:00:10 <Iceland_jack> :) most are bad, but better than η imo
14:00:20 <jle`> (was being slightly tongue in cheek :) )
14:00:22 <Eduard_Munteanu> Iceland_jack: heh... he might like Agda, it has both sharps and flats :)
14:00:31 <Iceland_jack> Eduard_Munteanu: She might!
14:00:34 <jle`> also can we get a better syntax construct that does not make me do things like (... :))
14:00:37 <Eduard_Munteanu> Ah.
14:00:38 <jle`> (for english)
14:00:40 <Iceland_jack> jle`: It's hard to tell with Haskellers!
14:00:59 <jle`> Iceland_jack: Poe's law, is it?
14:01:00 <Eduard_Munteanu> > let (η) = return in Just 3 η :: Either () (Maybe Integer)
14:01:01 <lambdabot>  Couldn't match expected type `(a1 -> m0 a1)
14:01:01 <lambdabot>                                -> Data.Either.Either
14:01:01 <lambdabot>                                     () (Data.Maybe.Maybe GHC.Integer.Type.Int...
14:01:01 <lambdabot>              with actual type `Data.Maybe.Maybe a0'
14:01:05 <Eduard_Munteanu> :(
14:01:20 <fizbin> I did find one case in the entire codebase of non-ASCII in a public interface. A java enum constant had a É in it/
14:01:22 <matheus23> Eduard_Munteanu: You're missing the Right
14:01:28 <Eduard_Munteanu> Er.
14:01:30 <Iceland_jack> jle`: Haskell's Poe's law would be ‘we should teach Agda to beginner programmers’
14:01:41 <Eduard_Munteanu> matheus23: am I?
14:01:46 <Iceland_jack> or have them code in Core!
14:01:56 <FireFly> fizbin: I wonder how it made its way there..
14:02:04 <matheus23> Eduard_Munteanu: I'm confused about your code... :D
14:02:19 <jle`> arithmetic at the data/value level?  why not just use type nats?
14:02:20 <matheus23> > let (η) = return in Right $ Just 3 :: Either () (Maybe Integer)
14:02:21 <lambdabot>  Right (Just 3)
14:02:37 <Iceland_jack> > let (♯) = return in (5 ♯) :: Maybe Int
14:02:38 <lambdabot>  Just 5
14:02:40 <matheus23> But I don't get what you want to do with the (η)
14:02:49 <fizbin> FireFly: I forget the full details, but the name of the enum constant was based on a non-English word, and that word had an accented E at that spot.
14:02:49 <jle`> > let η = return in η (η 3) :: Either () (Maybe Integer)
14:02:50 <lambdabot>  Right (Just 3)
14:03:02 <matheus23> > 5 return
14:03:03 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> m0 a0) -> t))
14:03:03 <lambdabot>    arising from the ambiguity check for `e_15'
14:03:03 <lambdabot>  from the context (GHC.Base.Monad m, GHC.Num.Num ((a -> m a) -> t))
14:03:03 <lambdabot>    bound by the inferred type for `e_15':
14:03:04 <Eduard_Munteanu> matheus23: I was trying to see if it parses as a pre/postfix operator, that is, η (Just 3) or (Just 3) η
14:03:04 <jle`> matheus23: η is eta, from category theory monoids
14:03:05 <lambdabot>               (GHC.Base.Monad m, GHC.Num.Num ((a -> m a) -> t)) => t
14:03:12 <fizbin> FireFly: So... cut-and-paste, maybe?
14:03:13 <jle`> *monads
14:03:18 <FireFly> fizbin: oh, I suppose
14:03:38 <matheus23> Eduard_Munteanu: jle`: Oh okay. I know nothing about that and postfix operators ^^
14:03:53 <jle`> matheus23: η is just return in haskell
14:04:07 <jle`> but return is so badly named and leads to so much confusion
14:04:07 <fizbin> In any case, that constant wasn't referred to from anywhere else when I found it, which is probably why it survived so long.
14:04:08 <Iceland_jack> matheus23: This is just a discussion about changing the names
14:04:18 <matheus23> > let (η) = return in return (Just 3) :: Either () (Maybe Integer)
14:04:19 <lambdabot>  Right (Just 3)
14:04:38 <matheus23> > let (η) = return in (Just 3) η :: Either () (Maybe Integer)
14:04:39 <Iceland_jack> jle`: I'm wondering why I haven't heard of anyone getting confused by 'pure' since IO is an Applicative
14:04:39 <lambdabot>  Couldn't match expected type `(a1 -> m0 a1)
14:04:39 <lambdabot>                                -> Data.Either.Either
14:04:39 <lambdabot>                                     () (Data.Maybe.Maybe GHC.Integer.Type.Int...
14:04:39 <lambdabot>              with actual type `Data.Maybe.Maybe a0'
14:04:54 <Iceland_jack> I feel that if return were named 'pure' that would confuse people even more
14:05:02 <Iceland_jack> “pure makes a pure value out of an.. impure value?”
14:05:13 <jle`> Iceland_jack: i don't know...i like pure...it is a pure computation that always returns that thing
14:05:18 <Eduard_Munteanu> Agda, given it has mixfix, lets you define prefix operators which behave like functions except they bind less tightly to arguments than function application.
14:05:30 <jle`> maybe "purely" is better
14:05:33 <jle`> :)
14:05:43 <dwcook> or "just". Wait…
14:05:48 <Iceland_jack> jle`: mkMonadic and mkApplicative ;)
14:05:56 <fizbin> Iceland_jack: On the other hand, they wouldn't think that "pure" had exit-the-function-now semantics, as can happen with return
14:06:05 <Eduard_Munteanu> e.g. if you declare foo_, you can write foo succ 2 and you get foo (succ 2)
14:06:06 <dwcook> Iceland_jack, or Monad.new(), why not
14:06:17 <Iceland_jack> dwcook: oh gosh..
14:06:17 <jle`> hahaha
14:06:23 <fizbin> "liftValue"
14:06:28 <jle`> lift0
14:06:36 <geekosaur> gimme
14:06:38 <fizbin> Ooh. lift0M ...
14:06:40 <Eduard_Munteanu> " ".join(...)
14:06:41 <dwcook> Those are legit
14:06:59 <jle`> still sticking with η
14:07:02 <matheus23> I'm pro mkMonadic or packM
14:07:06 <Iceland_jack> fizbin: I believe there wouldn't be as much confusion if the names were swapped :) return for Applicative and pure for Monad
14:07:17 <SwashBuckla> :t error
14:07:18 <lambdabot> [Char] -> a
14:07:28 <Iceland_jack> matheus23: packM for join?
14:07:30 <dwcook> Iceland_jack, only because people pay lots more attention to Monad and think it's imperative return :P
14:07:31 <matheus23>  η Says nothing to me :D I don't even know how to type that character ^^
14:07:31 <jle`> :t read
14:07:31 <lambdabot> Read a => String -> a
14:07:36 <matheus23> Iceland_jack: for return
14:07:48 <jle`> matheus23: it says nothing, so you bring in no previous misconceptions/baggage of the word :)
14:07:51 <Iceland_jack> matheus23: not such a bad suggestion tbh
14:07:54 <fizbin> jle`: can you then rename "join" to mu ? (Not going through the contortions to type that on this keyboard)
14:08:06 <Eduard_Munteanu> Often saying nothing is better than saying something as misleading as "return". :)
14:08:24 <jle`> error and read have the same type. coincidence?
14:08:29 <Iceland_jack> dwcook: I'll disagree slightly, I think it doesn't help that with monads and do-notation you have a much more imperative feel
14:08:29 <jle`> (almost)
14:08:49 <Iceland_jack> dwcook: With applicatives, there is really little sense in “returning” in the imperative sense
14:09:00 <jle`> Occupy Monad
14:09:30 <fizbin> Speaking of, when's Applicative becoming a declared superclass of Monad?
14:09:36 <jle`> fizbin: 7.10
14:09:42 <jle`> 7.8 compilations already give a warning
14:09:48 <Platz> settled on concat . mapM id [p, q, r] $ x
14:09:50 <jle`> * 7.10...hopefully
14:10:17 <jle`> mapM id?
14:10:21 <jle`> @src mapM
14:10:21 <lambdabot> mapM f as = sequence (map f as)
14:10:21 <fizbin> jle`: What do they warn on? Incompatible Applicative definitions?
14:10:38 <jle`> mapM id = sequence
14:10:49 <Iceland_jack> > sequence [succ, id, pred] 'a'
14:10:50 <lambdabot>  "ba`"
14:10:53 <Eduard_Munteanu> Platz: I suspect you want 'fmap concat'
14:10:58 <jle`> fizbin: it warns if your thing is an instance of monad but not an instance of applicative
14:11:21 <jle`> and says that it will be an error some day
14:11:28 <Platz> concat . sequence works
14:11:31 <fizbin> Ah, ok
14:11:32 <Platz> fmap concat doesn't
14:12:02 <Iceland_jack> Platz: It's not the most readable solution though, you'll have to weight that
14:12:03 <Eduard_Munteanu> Oh, yeah, you have a plain list.
14:12:12 <Eduard_Munteanu> > concat . sequence [succ, id, pred] $ 'a'
14:12:13 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[a0]'
14:12:13 <lambdabot>  Expected type: GHC.Types.Char -> [a0]
14:12:13 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.CharCouldn't match type `GHC.Type...
14:12:13 <lambdabot>  Expected type: GHC.Types.Char -> [a0]
14:12:13 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.CharCouldn't match type `GHC.Type...
14:12:25 <jle`> :t sequence [succ,id,pred]
14:12:26 <lambdabot> Enum a => a -> [a]
14:13:13 <hunt> could i do something like iterate getLine and keep parsing line by line until i see an end
14:13:13 * hackagebot c2hs 0.16.6 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.16.6 (IanRoss)
14:13:17 * Iceland_jack shys away from Monad instance of (r →) when possible, maybe wrongly
14:13:26 <hunt> in the stile of an infinite list [String]
14:13:28 <hunt> style
14:13:39 <Eduard_Munteanu> hunt: yes, but often it's easier to just do hGetContents and apply 'lines' on the result
14:14:36 <hunt> Eduad_Munteanu actually yea i guess i could just use getcontents
14:14:45 <jle`> because it's lazy and all
14:14:55 <jle`> but lazy io gives me the heebie jeebies
14:15:02 <Iceland_jack> :t sequence (repeat getLine) -- !
14:15:03 <lambdabot> IO [String]
14:15:20 <Eduard_Munteanu> That's going to error out once it runs past EOF.
14:15:27 <Iceland_jack> Eduard_Munteanu: Hence the !
14:15:32 <Eduard_Munteanu> :)
14:16:03 <stolaruk> I'm trying to install tasty w/ "cabal install tasty" and I'm getting an error and 4 warnings when it tries to build "unbounded-delays-0.1.0.6". The error is "invalid preprocessing directive" in "Control/Concurrent/Timeout.hs:5:4". Anyone seen this before?
14:16:06 <merijn> Iceland_jack: That will never return
14:16:16 <quchen> Didn't you see the "!"
14:16:18 <quchen> ಠ_ಠ
14:16:21 <geekosaur> stolaruk, you are on OS X, yes?
14:16:25 <stolaruk> indeed I am
14:16:36 <geekosaur> from the /topic: XCode 5 issues? http://is.gd/H4sEub
14:17:19 <nomeata> Hi. I am playing around with the haskell platform in wine. Most stuff works nicely, but cabal is not able to download anything. Any ideas?
14:17:21 <Iceland_jack> merijn: What it if reaches the end of the list? :)
14:17:33 <stolaruk> geekosaur: Thanks so much!
14:17:43 <merijn> Iceland_jack: getLine reads from stdin, which normally doesn't end
14:17:55 <Iceland_jack> merijn: I meant the infinite list
14:18:04 <jle`> nomeata: does cabal update work?
14:18:13 <Iceland_jack> (as a joke)
14:18:20 <nomeata> jle`: no, that fails as well
14:18:23 <monochrom> cabal in wine, I have not thought of that :)
14:18:26 <nomeata> "cabal.exe: failed"
14:18:27 <jle`> does any sort of network stuff work?
14:18:48 <nomeata> jle`: al least nothing in cabal
14:19:00 <jle`> how about non-cabal networking?
14:19:47 <nomeata> jle`: hmm, I need to think of a way to test that...
14:19:53 <jle`> ping?
14:19:58 <jle`> wget?
14:20:03 <jle`> oh yeah
14:20:05 <jle`> windows
14:20:17 <acowley> Windows Update
14:20:19 <monochrom> a LAN game :)
14:20:54 <monochrom> Windows Update in wine, now that is unimaginable :)
14:21:29 <acowley> I'm the H.P. Lovecraft of network testing.
14:21:50 <nomeata> jle`: yes, other programs in wine can use the network
14:22:01 <davidfetter> iaaa! iaaa!
14:22:01 <Eduard_Munteanu> nomeata: do you get any Wine debug messages?
14:22:31 <Eduard_Munteanu> You might want to make sure WINEDEBUG isn't set.
14:23:02 <nomeata> Eduard_Munteanu: no error or debug message, WINEDEBUG is unset
14:25:33 <Eduard_Munteanu> nomeata: is it a 32bit prefix and Platform binary?
14:26:56 <nomeata> Eduard_Munteanu: not sure what you mean by prefix, but everything (cabal.exe and wine) is 32 bit
14:26:56 <fizbin> Hey, can anyone tell me why this ends up aborting with "***Exception: <<loop>>" in ghci?
14:26:58 <fizbin> take 3 $ fix $ \x -> 1:1: getZipList((+) <$> ZipList (drop 1 x) <*> ZipList (drop 2 x))
14:28:01 <fizbin> > getZipList $ (+) <$> ZipList [1,2,3,4] <*> ZipList [100,200,300,400]
14:28:02 <lambdabot>  [101,202,303,404]
14:28:21 <Eduard_Munteanu> nomeata: "prefix" means ~/.wine. A purely 32bit Wine will create a 32bit prefix, while mixed 32/64bit builds of Wine will create a 64bit prefix by default, which runs both but tends to break stuff in certain cases.
14:29:02 <ReinH> nomeata: I guess I shouldn't ask why you're using it inside wine?
14:29:07 <ion> fizbin: “drop 2 x” will drop the two “1”s and try to get another item which depends on the “drop 2 x”.
14:29:26 <fizbin> ion: Oh, right.
14:29:32 <Eduard_Munteanu> nomeata: you'll have to recreate the prefix, you can't just convert it.
14:29:40 <ion> > let xs = 0 : 1 : getZipList ((+) <$> ZipList xs <*> ZipList (drop 1 xs)) in xs
14:29:40 <nomeata> ReinH: I’d like to provide a binary to users to avoid having them install GHC and libraries
14:29:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:29:43 <fizbin> Right, duh. I screwed that up.
14:29:45 <Eduard_Munteanu> Though often it's recommended you keep one app per prefix.
14:29:53 <fizbin> ion: exactly.
14:30:07 <nomeata> Eduard_Munteanu: right. I was lazy this time and installed it into my general purpose prefix; I could try re-installing the platform in a new prefix
14:30:10 <Eduard_Munteanu> ReinH: it's a cheap and effective way to get a cross-compiler for Windows.
14:30:15 <ReinH> Eduard_Munteanu: that's fair
14:31:09 <Eduard_Munteanu> nomeata: you'll have to set WINEARCH=win32 while ~/.wine does not exist or WINEPREFIX points to some other nonexistent dir, for the first Wine command you run.
14:32:04 <Eduard_Munteanu> nomeata: btw, you can check if it has a Program Files (x86), if it does, it's 64bit.
14:33:00 <nomeata> Eduard_Munteanu: it doesn't; I am quite confident I never ran wine64 with that prefix
14:33:33 <Eduard_Munteanu> nomeata: you should try with a clean prefix nevertheless
14:34:02 <ski> hunt : what kind of differing implementations did you have in mind ?
14:34:15 <khyperia> fizbin, I liked that so much I had to write a blog entry on it, haha. http://khyperia.blogspot.com/2014/03/haskell-quine.html
14:35:25 <ski> hunt : your `dotProduct :: (Vector a,Num a) => [a] -> [a] -> a' is always using lists, instead of say arrays or some other representation
14:35:37 <fizbin> khyperia: Note that some people would make it a bit shorter by using "ap" instead of "<*>"
14:36:13 <ski> khyperia : interesting :)
14:36:14 <khyperia> Oh, true. One character :P
14:36:15 <fizbin> > ap(++)show$"ap(++)show$"
14:36:16 <lambdabot>  "ap(++)show$\"ap(++)show$\""
14:36:30 <hunt> ski: how do you filter out the messages to you in irc?
14:36:50 <ski> khyperia : i assume you're familiar with the `lambda' and `let' based quines in lisps ?
14:37:05 <khyperia> no, I'm not, mind sharing?
14:37:10 <fizbin> Also, the import becomes Control.Monad which is much shorter than Control.Applicative.
14:37:32 <ski> hunt : my IRC client highlights lines in which my nickname is mentioned, and highlights channels in which there has been a highlighting since i last looked at it
14:37:57 <hunt> ski: so you just scroll all the way up throuhg the logs until you see highlihgt?S
14:38:00 <ski> hunt : some IRC clients only highlights in case a message line *starts* with one's nickname, though
14:38:07 <nomeata> Eduard_Munteanu: clean prefix, same thing
14:38:25 <ski> hunt : well, recently i also added a "highlight" window with logs the highlighted messages
14:38:39 <ski> s/with/which/
14:38:49 <fizbin> I once upon a time (~18-19 years ago) had a page with a bunch of quines (I called them "self replicating programs" at the time). The ones I had there later got lifted and can now be found on the "quine" page.
14:39:01 <fizbin> (Which is good, because my ancient pages are gone)
14:39:03 <ski> (though i didn't use that window in this case)
14:39:08 <Eduard_Munteanu> nomeata: IIRC, HP ships mingw, can you try and see if gcc is functional? I remember a bug a few years ago.
14:39:30 <ski> fizbin : which "quine" page ?
14:40:09 <nomeata> Eduard_Munteanu: I can compile stuff without problems, I just have to use my non-wine cabal to download and unpack it first...
14:40:41 <Eduard_Munteanu> Hm.
14:40:51 <fizbin> ski: http://www.nyx.net/~gthompso/quine.htm
14:40:52 <Eduard_Munteanu> nomeata: does unpacking alone fail too?
14:41:06 <ski> fizbin : ty
14:41:30 <nomeata> Eduard_Munteanu: hmm, to test that I’d have to put the tarball where cabal would expect to find it...
14:42:02 <ski> @. run where quine
14:42:03 <lambdabot>  "ap (++) show \"ap (++) show \""
14:42:18 <Eduard_Munteanu> nomeata: if downloading alone fails perhaps installing a native 'wininet' with 'winetricks' might help
14:42:28 <fizbin> That includes my pascal quine (which I think is valid ISO standard pascal, not just TP) which I think is one of the most readable quines I've ever seen. Search for "Program Dolly" in http://www.nyx.net/~gthompso/self_pasc.txt
14:42:41 <Eduard_Munteanu> nomeata: btw, do you ever get any debugging messages from Wine?
14:43:02 <ski> fizbin : i'm not sure i had seen that before. i had seen <http://www.madore.org/~david/computers/quine.html>, though
14:43:19 * hackagebot adjunctions 4.0.2 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.0.2 (EdwardKmett)
14:43:27 <Eduard_Munteanu> nomeata: some distros may ship Wine binaries stripped of debugging stuff (messages included)
14:43:36 <ski> (David Madore is also known for <http://www.madore.org/~david/computers/callcc.html>)
14:44:04 <fizbin> ski: What I pointed at is listed as a reference at the bottom of what you pointed at.
14:44:42 <ski> fizbin : ok, probably must have been added since i last looked at that page (years ago)
14:49:38 <eacameron> I just built the exact same cabal project on both windows and linux. The windows binary is 2MB and the Linux one is 7MB! any idea why?
14:50:09 <Eduard_Munteanu> eacameron: GHC links some stuff dynamically by default on Windows in particular
14:50:20 <geekosaur> your linux ghc may be configured to build static; it may also be including symbols
14:50:45 <eacameron> Eduard_Munteanu: but I can give my win build to others who don't have GHC and it works fine
14:51:56 <eacameron> geekosaur: wouldn't the cabal file specify such things?
14:52:32 <Eduard_Munteanu> eacameron: hence my use of "some" :)
14:52:46 <ski> re the classic "Reflections on Trusting Trust" (Turing Award lecture) by Ken Thompson in 1984 at <http://cm.bell-labs.com/who/ken/trust.html>,<http://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf>
14:52:59 <Eduard_Munteanu> If it's a small project, likely 2MiB indicates there's at least some static linking.
14:53:06 <eacameron> Eduard_Munteanu: interesting; well I never thought I'd be happier with Haskell on Win than on something not Win...
14:53:22 <Eduard_Munteanu> eacameron: try compiling with -dynamic on Linux
14:53:33 <Eduard_Munteanu> eacameron: and Windows, and compare
14:53:39 <ski> "Countering Trusting Trust through Diverse Double-Compiling" by David A. Wheeler in 2005 at <http://www.acsa-admin.org/2005/abstracts/47.html> is interesting
14:53:48 <geekosaur> eacameron, it may specify it for cabal builds, most probably it does not so much specify by default as document it and default to what the installed ghc does
14:54:03 <geekosaur> (that is, it has a commented-out entry saying what mode to use to build stuff)
14:54:13 <geekosaur> striping otoh I think is not specified there
14:54:20 <geekosaur> *strip-ing
14:54:38 <ski> and ezyang's "The new Reflections on Trusting Trust" in 2011-10 at <http://blog.ezyang.com/2011/10/the-new-reflections-on-trusting-trust/> is also a bit interesting
14:55:11 <ski> khyperia,fizbin : ^ those are a bit related to quines
14:55:51 <fizbin> ski: I've read the classic paper of course, but not the new ones.
14:56:06 <Eduard_Munteanu> geekosaur: perhaps HP libraries are already stripped, say for non-profiling builds?
14:56:17 <Eduard_Munteanu> On Windows, I mean.
14:56:43 <ski> fizbin : just one new paper
14:56:47 <geekosaur> Eduard_Munteanu, I think symbols just work differently on Windows
14:57:05 <[swift]> will there be a PPA with updated ubuntu packages when GHC 7.8 and the matching new haskell platform are released?
14:57:05 <ski> Bruce Schneier mentioned it in 2006-01-23 at <https://www.schneier.com/blog/archives/2006/01/countering_trus.html>
14:57:14 <geekosaur> Unix stuffs debug symbols into the object / library, Windows doesn't
14:57:29 <matheus23> Is there something like mapM_ for Data.Map (or Data.Map.Strict)?
14:57:41 <[swift]> ISTR that i couldn't find one for the current haskell platform when i was stuck on an ubuntu release with an older HP packaged
14:57:42 <Kaidelong> well for C stuff it still has to be built into the binary I think
14:57:44 <geekosaur> (and then there's recent Linux --- at least Red Hat --- debuginfo stuff which works more like Windows)
14:57:47 <Eduard_Munteanu> matheus23: mapM_ :)
14:57:50 <ski> fizbin : ezyang's post is more about how proof-carrying code and dependently typed languages can possibly help a bit
14:58:02 <Eduard_Munteanu> matheus23: the one from Data.Foldable
14:58:07 <Kaidelong> but at least in the .NET world the debug symbols can be in an entirely separate file
14:58:19 <jchee> is it just me or would it be useful for cabal to search "up" the filesystem for a sandbox, rather than just searching .cabal-sandbox, kind of like git does?
14:58:21 * hackagebot zeromq4-haskell 0.3.1 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.3.1 (ToralfWittner)
14:58:25 <Eduard_Munteanu> :t Data.Foldable.mapM_
14:58:25 <matheus23> ah so what do I need to import? import Data.Foldable () ?
14:58:26 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
14:58:29 <b0bbi10> from LYAH "Anyway, if we try to get a length of a list and then add it to 3.2, we'll get an error because we tried to add together an Int and a floating point number." if length returns an Int, why can't the compiler cast it to a Float? I mean, 1 + 3.2 works too, right?
14:58:44 <nomeata> Eduard_Munteanu: wininet did not help either. But thanks anyways! I managed to install the required packages manually and won’t worry for now
14:58:45 <Iceland_jack> b0bbi10: The compiler doesn't cast anything
14:58:49 <geekosaur> Kaidelong, it does not *have* to be, that's where most Unix tools currently expect it but see Red Hat debuginfo
14:59:16 <Iceland_jack> b0bbi10: If you look at the type of (+) you'll see that both operands must have the same type
14:59:21 <geekosaur> since you generally want the debug symbols in gdb, their gdb knows how to use the lookaside debuginfo files instead of requiring them to be in executables / libraries
14:59:23 <Iceland_jack> @ty (+)
14:59:23 <Eduard_Munteanu> matheus23: you'll likely have to import Data.Foldable and hide the plain mapM_
14:59:24 <lambdabot> Num a => a -> a -> a
14:59:37 <b0bbi10> Iceland_jack, ah ok, that's it, thanks :)
14:59:37 <Iceland_jack> > (1 :: Int) + (3.2 :: Float) -- b0bbi10
14:59:38 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
14:59:39 <lambdabot>              with actual type `GHC.Types.Float'
14:59:52 <geekosaur> (they still have *dynamic* symbols, as do Windows DLLs, but that information is much more compact)
15:01:17 <Iceland_jack> b0bbi10: When you have an integer numeral in Haskell code (nota bene: not a Haskell value of type Integer) it is the same as applying fromInteger to that value *as* an Integer
15:01:34 <Iceland_jack> so '15' in your code is
15:01:34 <Iceland_jack>     fromInteger (15 :: Integer)
15:01:36 <Eduard_Munteanu> b0bbi10: what happens is number literals are overloaded... e.g. 5 :: Num a => a
15:01:48 <merijn> Iceland_jack: I would say "numeric literal" instead of "integer numeral"
15:02:00 <Eduard_Munteanu> b0bbi10: so it's simply a matter of picking the right representation for the number, which is forced by (+)'s type
15:02:02 <matheus23> Eduard_Munteanu: thanks!
15:02:07 <ski> @tell fizbin also see "Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers" (Ph. D. dissertation) by David A. Wheeler in 2009 at <http://www.dwheeler.com/trusting-trust/>
15:02:07 <lambdabot> Consider it noted.
15:02:12 <ski> khyperia ^
15:02:17 <Iceland_jack> merijn: Yeah but that applies to both floating numerals and integer numerals, I'm just going by the report
15:02:19 <b0bbi10> I see
15:02:24 <khyperia> cool, thanks
15:02:27 <ski> @where trust
15:02:27 <lambdabot> I know nothing about trust.
15:02:29 <ski> @where trusting-trust
15:02:29 <lambdabot> I know nothing about trusting-trust.
15:02:48 <geekosaur> @where rott
15:02:48 <lambdabot> I know nothing about rott.
15:02:58 <matheus23> @where you
15:02:58 <lambdabot> I'm right here, silly.
15:03:02 <ski> @where+ trusting-trust the classic "Reflections on Trusting Trust" Turing Award lecture by Ken Thompson in 1984 at <http://cm.bell-labs.com/who/ken/trust.html>,<http://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf>
15:03:02 <lambdabot> Okay.
15:03:03 <Iceland_jack> b0bbi10: Similarly, when you have a floating numeral: it's the same as applying fromRational to that value as a Rational
15:03:07 <matheus23> hahahahahaha! awesome!!
15:03:49 <Iceland_jack> so
15:03:49 <Iceland_jack> > 1 + 3.2
15:03:49 <Iceland_jack>  
15:03:49 <Iceland_jack>  
15:03:50 <lambdabot>  4.2
15:03:57 <Iceland_jack> is
15:04:00 <Iceland_jack> > fromInteger (1 :: Integer) + fromRational (16 % 5 :: Rational)
15:04:01 <lambdabot>  4.2
15:04:18 <Iceland_jack> At no point is an Int/Integer added to a floating-point number
15:06:23 <Iceland_jack> b0bbi10: Hope that makes sense :) tl;dr no casting
15:11:58 <b0bbi10> Iceland_jack, I think I have understood it ;)
15:14:13 <c_wraith> holy crap.  text grew a billion modules since I last looked.
15:14:54 <ski> @tell fizbin you might perhaps also find ijp's "Fun with Self-Reproducing Programs" in 2013-09-25 at <http://shift-reset.com/blog/2013/9/25/Fun%20with%20Self-Reproducing%20Programs/> interesting, re "trusting trust" and quines
15:14:54 <lambdabot> Consider it noted.
15:15:00 <ski> khyperia ^
15:16:32 <ski> @where SafeHaskell
15:16:32 <lambdabot> I know nothing about safehaskell.
15:17:01 <ski> @where+ SafeHaskell <http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html>,<https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell>,<http://safehaskell.scs.stanford.edu/>
15:17:01 <lambdabot> It is forever etched in my memory.
15:17:38 <merijn> I guess one problem with haskell is that lacking a compiler other than GHC we have no way to do trusted double compilation :p
15:17:59 <ReinH> merijn: doesn't matter when you can just dope the cpu :p
15:18:00 <merijn> Although I think trusted double compilation requires deterministic code generation anyway, no?
15:18:23 * hackagebot linear 1.9 - Linear Algebra  http://hackage.haskell.org/package/linear-1.9 (EdwardKmett)
15:18:27 <ReinH> trusting trust has been made irrelevant :)
15:18:29 <merijn> ReinH: I know, I have a paper on implementing malicious hardware lying around :p
15:18:40 <ReinH> merijn: :p
15:18:43 <c_wraith> is GHC not deterministic, given arch/os/flags/libraries the same?
15:19:09 <geekosaur> not entirely, sadly
15:19:11 <merijn> c_wraith: GHC might be, but you need deterministic compilation in the sense of two compilers given the same code will produce the same binary
15:19:13 <geekosaur> known bug
15:19:23 <Iceland_jack> c_wraith: GHC also uses backends which needn't be deterministic
15:19:34 <merijn> c_wraith: Although I'm not sure that's needed per se for trusted double compilation
15:19:41 <merijn> I don't remember the details of it
15:20:16 <merijn> c_wraith: The idea is that you compile code with two compilers and compare output. Which is hard if both compilers generate different output for the same input
15:20:22 <zenkeku> Why is the else clause indented like this? http://lpaste.net/101086
15:20:44 <matheus23> I want some kind of a Queue that can be indexed and that can be "push"-ed, but only stores a limited ammount of data's. Kind of like a history for changes with a size limit. How would you create such a data-structure?
15:20:48 <merijn> zenkeku: Because whoever wrote that is a horrible person
15:20:58 <monochrom> I don't know, but you can indent it however you like
15:21:03 <c_wraith> merijn: well, yes.  I suppose it is.  But that's awfully hard to do when you've got any kind of optimization going on.
15:21:10 <merijn> zenkeku: Seriously, that code made me sad :(
15:21:11 <Iceland_jack> Here's a proof sketch that GHC can be trusted: it wouldn't make much sense to spend resources making GHC untrusted because nobody uses Haskell (/s ?)
15:21:27 <merijn> c_wraith: Well, yeah
15:21:35 <merijn> c_wraith: No one said it was *practical*
15:21:36 <zenkeku> merijn: I found it on a tutorial listed on the haskell website. Also, my text editor won't allow it to be indented any other way.
15:21:49 <merijn> zenkeku: Really? Which tutorial?
15:22:12 <Iceland_jack> zenkeku: that is some funky code
15:22:39 <zenkeku> merijn: http://en.wikibooks.org/wiki/Haskell/YAHT
15:22:44 <merijn> monochrom: Pretty sure that's not legal haskell98
15:22:59 <zenkeku> merijn: It runs as it is supposed to, however.
15:23:03 <merijn> Perhaps not even 2010 as the lining up of else with if is only in do
15:23:26 <monochrom> I disagree
15:23:27 <matheus23> Tene: I think it's clearer why (I guess) they do that when you add a newline: http://lpaste.net/101086
15:23:37 <merijn> zenkeku: The most recommend intro to haskell these days is Learn You a Haskell
15:23:40 <merijn> @where lyah
15:23:40 <lambdabot> http://www.learnyouahaskell.com/
15:23:42 <napping> if doesn't start an indentation level
15:23:58 <matheus23> (Ups, wrong username) zenkeku: I think it's clearer why (I guess) they do that when you add a newline: http://lpaste.net/101086
15:24:08 <merijn> napping: I know, but line continuations need to be indented further than the initial line?
15:25:04 <monochrom> the only initial line is "mySignum x ="
15:25:10 <napping> no: http://lpaste.net/101086
15:25:21 <zenkeku> Maybe I should change my indentation rules..
15:25:28 <merijn> monochrom: Ah, because that only applies in layout mode and nothing in that code triggers layout?
15:26:07 <napping> line 1 is either triggering or conforming to layout (if you imagine it's in a larger file)
15:26:24 <zenkeku> napping: I can post the entire file, if you'd like.
15:26:27 <napping> but as long as you ident more than the "m" you're fine
15:26:56 <napping> I don't see why that would help
15:27:07 <napping> The code you pasted is legal
15:27:18 <napping> did something autoindent like that?
15:27:39 <zenkeku> napping: emacs with haskell-mode
15:28:16 <ski> "Stealthy Dopant-Level Hardware Trojans" by Georg T. Becker,Francesco Regazzoni,Christof Paar,Wayne Burleson in 2013-08 at <http://people.umass.edu/gbecker/BeckerChes13.pdf>
15:28:19 <monochrom> there are many versions of haskell-mode, and every version comes with 3 indenters, not 1.
15:28:20 <ski> "Stealthy Dopant-Level Hardware Trojans: extended version" by Georg T. Becker,Francesco Regazzoni,Christof Paar,Wayne Burleson in 2014 at <http://link.springer.com/content/pdf/10.1007%2F978-3-642-40349-1_12.pdf>
15:28:25 <ski> ReinH : i assume you mean that ^
15:29:01 <zenkeku> monochrom: Correct. I'm currently switching over to a different indent style to see if it fixes it.
15:29:30 <matheus23> I want some kind of a Queue that can be indexed and that can be "push"-ed, but only stores a limited ammount of data's. Kind of like a history for changes with a size limit. How would you create such a data-structure?
15:31:51 <merijn> matheus23: Multithreaded or just single threaded application?
15:31:59 <matheus23> single
15:32:20 <zenkeku> Every single indent style indents that function exactly the same.
15:32:35 <merijn> matheus23: I would just append values to a list and whenever you inspect it do "take x myQueue" and at the end store what's left of that?
15:33:14 <merijn> zenkeku: Autoindentation for haskell doesn't work very well in my experience as it's fairly ambiguous how haskell code should be indented
15:33:31 <zenkeku> merijn: So, you think I should just indent it myself?
15:33:58 <matheus23> merijn: Yeah... I should stop overcomplicating things. I was thinking of mutable arrays and such again... thank you :)
15:34:36 <zenkeku> merijn: Nope, haskell-mode does not support that.
15:39:04 <zenkeku> Is there a real difference between using guards and using if's?
15:39:23 <Iceland_jack> zenkeku: no
15:39:33 <Iceland_jack> in guards you can pattern match and do some funky stuff
15:39:53 <Iceland_jack> but otherwise it's just a different way of expressing conditional branches
15:41:34 <Iceland_jack>     sig n = if n < 0 then -1 else (if n > 0 then 1 else 0)
15:41:34 <Iceland_jack> versus
15:41:34 <Iceland_jack>     sig n | n <  0    = -1
15:41:34 <Iceland_jack>           | n == 0    = 0
15:41:37 <Iceland_jack>           | otherwise = 1
15:42:06 <Iceland_jack> or
15:42:06 <Iceland_jack>     sig n = case compare n 0 of
15:42:06 <Iceland_jack>         LT -> -1
15:42:06 <Iceland_jack>         EQ -> 0
15:42:09 <Iceland_jack>         GT -> 1
15:42:31 <quchen> There is an important difference: if all guards fail, the next definition will be used.
15:42:58 <quchen> sig n | n < 0 = -1 | n == 0 = 0; sig _ = 1
15:43:00 <Iceland_jack> quchen: yes there are some differences, but you could emulate that with other syntax
15:43:40 <quchen> I don't think you could emulate it that easily. You can start a new (possibly different) pattern match, for example.
15:43:46 <b0bbi10> how would I interpret this: error :: [Char] -> a ? error takes a String and returns any type? Oo
15:43:57 <quchen> b0bbi10: error also makes your program crash.
15:44:20 <Iceland_jack> b0bbi10: It doesn't produce a 'value' since an error isn't a value :)
15:44:46 <Iceland_jack> b0bbi10: just like
15:44:46 <Iceland_jack>     something :: a
15:44:46 <Iceland_jack>     something = something
15:44:46 <Iceland_jack> has type 'a' since something never produces a value
15:45:03 <quchen> b0bbi10: This is similar to how an infinite loop has any type: `let x = x in x` has type `a`.
15:45:18 <zenkeku> Iceland_jack: Alright, thanks. I hate how it is being indented.
15:45:33 <Iceland_jack> zenkeku: How what is being indented?
15:45:34 <b0bbi10> weird stuff ;D
15:45:37 <b0bbi10> thanks guys
15:54:49 <zenkeku> Iceland_jack: http://lpaste.net/101086
15:56:07 <Iceland_jack> I see what you mean..
15:57:21 <quchen> I'm pretty sure proper indentation requires strong AI.
15:57:40 <quchen> Or I.
16:01:15 <danilo2> Hello! I'm looking for somethink monad-like, but which would allow me to track multiple state separately. I want to define a data flow (lets consider image processing like this one: http://snag.gy/gq90K.jpg).
16:01:17 <danilo2> readImage reads the image **from current frame** (a state). the "timeShift" operation, affects only the connected data in such way, what it is taken from another frame - so as a result, the operation "readImage" is computed twice - for current and shifted time.
16:01:37 <danilo2> Is there anything in Haskell, which allows for simmilar things?
16:02:40 <quchen> State (a,b) lets you track multiple states separately.
16:03:41 <quchen> Oh, you mean the "computed twice" part is what's hard, so you don't want to start with the same thing, just apply similar function pipelines to your initial data?
16:06:51 <danilo2> quchen: yes - the node "timeShift" affects the data it process, so it uses different state (in this case idfferent time, for the whole datagraph) - does it make sense?
16:07:51 <danilo2> quchen: so exactly - the "hard part" is the "compute twice" part - without redefining the flow again
16:10:18 <merijn> quchen: It requires prescience
16:10:40 <merijn> quchen: As semantics depend on indentation, so auto-indenting haskell requires you to know the desired semantics
16:21:44 <quchen> merijn: Even more, nice indentation is a matter of some form of aesthetics.
16:21:58 <quchen> When to align the "="?
16:26:45 <crondog> hi all, im trying to get cabal-install built for an arm device but i am running into this error http://hastebin.com/kigufoyexa.vhdl Are there any known solutions?
16:34:15 <joelteon> in GHC 7.10, if' should be in Prelude
16:36:05 <peddie> joelteon: what is if' besides un-googleable?
16:36:48 <Taneb> peddie, if' cond a b = if cond then a else b
16:36:48 <Iceland_jack> Presumably
16:36:48 <Iceland_jack>     if' True  a b = a
16:36:48 <Iceland_jack>     if' False a b = b
16:36:54 <Taneb> Like "if" but a function
16:36:55 <peddie> ahhhh
16:36:59 <peddie> wonderful
16:37:15 <merijn> I thought people were still (like always) bikeshedding syntax?
16:37:32 <joelteon> yeah, that's my contribution
16:38:14 <Iceland_jack> Will 7.10 have if'? 7.8 RC2 has 'bool :: a -> a -> Bool -> a'
16:38:20 <Iceland_jack> will both be included?
16:38:29 <joelteon> oh I didn't know about that
16:50:25 <xpika_> exit
16:50:26 <xpika_> quit
16:52:04 <xpika> what is the quickest way to get ghc head on linux?
16:54:28 <merijn> xpika: Install binary distro of GHC, check out head from GHC git repo, follow install instructions to build and install HEAD
17:01:38 <Kron> is there any reason why Control.Lens can't be imported safely/
17:02:32 <hunt> where do you put the logic in haskell opengl
17:12:15 <chas> confused: No instance for (A.FromJSON T.Text) arising from a use of `.:'
17:12:27 <chas> A is Data.Aeson, T is Data.Text
17:13:14 <erisco> what language extensions do I need to compile the last example on this netwire readme? http://hub.darcs.net/ertes/netwire/browse/README.md
17:13:21 <pavonia> chas: What is the full code?
17:13:44 <chas> data Foo = Foo { t :: T.Text }
17:13:54 <chas> > instance A.FromJSON Foo where parseJSON (A.Object v) = Foo <$> v .: "t"; parseJSON _ = mzero
17:13:54 <lambdabot>  <hint>:1:1: parse error on input `instance'
17:14:49 <erisco> I thought that OverloadedStrings would be necessary, but after enabling I get swaths of ambiguous type errors
17:15:04 <chas> sorry I do have :set -XOverloadedStrings as well
17:15:29 <erisco> so I am missing something still
17:16:26 <dmj`> chas: use generics
17:16:32 <dmj`> esp w/ a data type that simple
17:17:27 <chas> I have also tried with generics and get the same error, in fact when I try the first few lines of the fp complete tutorial http://goo.gl/d84RzG I get the same error
17:17:47 <dmj`> {-# LANGUAGE DeriveGeneric     #-}; import GHC.Generics(Generic); data Foo = Foo { t :: T.Text } deriving (Generic); instance FromJSON Foo
17:18:57 <dmj`> instance [incoherent] FromJSON Text
17:18:57 <dmj`>   -- Defined in `aeson-0.6.2.1:Data.Aeson.Types.Class
17:19:05 <dmj`> chas: it's there
17:19:09 <pavonia> (.:) isn't the usual compostion operator here, is it?
17:20:29 <chas> dmj yes that is why I'm confused I'm sure it's user error somehow
17:20:41 <chas> thx I guess I will keep  pounding on it
17:21:31 <dmj`> chas: http://lpaste.net/101091
17:23:42 * hackagebot newsynth 0.2 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.2 (PeterSelinger)
17:23:47 <chas> dmj: $ ghc -o lpaste lpaste.hs [1 of 1] Compiling LPaste           ( lpaste.hs, lpaste.o )  lpaste.hs:12:10:     No instance for (FromJSON Text)       arising from a use of `aeson-0.7.0.1:Data.Aeson.Types.Class.$gdmparseJSON'     Possible fix: add an instance declaration for (FromJSON Text)
17:24:11 <chas> that is your lpaste with the addition of a "module LPaste where" line
17:25:14 <dmj`> chas: paste your entire copmilation error on lpaste.net and link it here
17:26:44 <chas> http://lpaste.net/101095
17:31:25 <dmj`> chas: strange, try creating a new sandbox cabal install -j aeson, and recompile the example
17:31:32 <dmj`> chas: works for me w/ latest aeson
17:34:47 <tautologico> what's the best option for unboxed arrays?
17:36:18 <t4nk232> @pl \y -> [length y, head y]
17:36:18 <lambdabot> liftM2 (:) length (return . head)
17:36:26 <chas> dmj yeah all this worked for me too a few days ago - sandbox same error: http://lpaste.net/101099
17:36:58 <chas> so strange
17:37:09 <erisco> testWire undefined (for 3 . pure "yes")       error: Num type is ambiguous...    testWire undefined (for (3 :: Double) . pure "yes")     could not deduce HasTime Double s0
17:37:22 <erisco> no idea what I am supposed to do... the compiler suggested Double as such an instance
17:37:53 <jle`> erisco: try (3 :: Double) ?
17:38:15 <erisco> jle`, is that not what I did?
17:38:17 <t4nk232> @pl \a b -> a * 10^b
17:38:18 <lambdabot> (. (10 ^)) . (*)
17:38:48 <dmj`> chas: I use hsenv, seems to work better for me
17:38:58 <erisco> jle`, oh it did not like the undefined
17:39:03 <t4nk232> @pl \b a -> b * 10^a
17:39:04 <lambdabot> (. (10 ^)) . (*)
17:39:44 <jle`> erisco: are you following a tutorial?
17:40:02 <chas> dmj: ok thx will try hsenv
17:40:16 <erisco> jle`, well there is only the README as far as I can tell... and I cannot get most of the stuff to compile
17:40:28 <jle`> erisco: the 5.0 README?
17:40:31 <erisco> yes
17:40:37 <jle`> yeah i actually never really used that testWire :|
17:40:42 <jle`> try using mine
17:40:45 <jle`> i'll link it
17:40:48 <erisco> for example the last example demonstrating recursion I cannot make happy
17:40:56 <erisco> compiler keeps barfing with ambiguous type problems
17:41:40 <jle`> https://github.com/mstksg/netwire-experiments/blob/master/src/Utils/Wire/TestWire.hs
17:41:49 <jle`> erisco: are you giving type signatures?
17:43:10 <jle`> erisco: i wrote those docs a while ago, 'error' should be 'inhibition'
17:43:59 <erisco> I am just copying and pasting the netwireIsCool function wholesale
17:44:06 <erisco> adding the imports, and trying to compile
17:45:01 <jle`> try adding some types then
17:45:09 <jle`> do you know what the parameters in the Wire constructor represent?
17:45:10 <t4nk232> @pl f b a = b * 10^a
17:45:10 <lambdabot> f = (. (10 ^)) . (*)
17:45:27 <t4nk232> @pl f a b = b * 10^a
17:45:27 <lambdabot> f = (*) . (10 ^)
17:45:28 <erisco> nope
17:45:49 <jle`> Wire s e m a b
17:45:57 <jle`> do you know anything about Arrows/Categories?
17:46:19 <erisco> yes but I do not see how that is relevant at the moment
17:46:34 <hunt> how do i get a window size in opengl
17:46:37 <jle`> Wire s e m is an Arrow and a Category
17:46:51 <jle`> in an abstract sense it takes a type `a` as input and a type `b` as output
17:46:55 <erisco> yes I know that
17:47:03 <jle`> Wire s e is a monad transformer
17:47:07 <jle`> m is the underlying monad
17:47:17 <jle`> e is the inhibition type
17:47:22 <erisco> there are the compiler errors http://lpaste.net/101100
17:47:39 <jle`> all netwire Wire results are Either e b
17:47:48 <jle`> so e is the type of the Left, the inhibitions
17:47:59 <jle`> e usually has to be a monoid because combining inhibiting wires combines the inhibiting values
17:48:08 <jle`> most people just use()
17:48:23 <jle`> s parameterizes the time
17:48:40 <jle`> time used to be always Double, but i think someone asked for parameterized time for some reason and so netwire added it
17:48:54 <jle`> s is also a Wire
17:49:09 <jle`> an s that comes with the library is Timed a t
17:49:26 <jle`> it's an Auto, but not quite a wire in the same way as Wire
17:49:35 <jle`> so you can put (Timed () Double) as your s
17:49:40 <jle`> er let me check to make sure
17:49:46 <erisco> okay, but, I cannot even get the example compiled
17:50:38 <jle`> sorry, Timed Double ()
17:50:41 <jle`> okay let me look at the error
17:51:12 <jle`> erisco: you need to specify the inhibition type, that's what it's complaining about
17:52:05 <jle`> try something like
17:52:45 <jle`> netwireIsCool :: Wire (Timed Double ()) () IO () String
17:54:11 <erisco> oh the inferrence was expecting many more constraints
17:54:27 <t4nk232> @pl x = [1] : map (concatMap (\y -> [head y, length y]) . group) x; f xs = sum $ zipWith (\a b -> a * 10 ^ b) (reverse xs) [0..]; y = map f x; g n = take n y; main = readLn >>= print . g
17:54:27 <lambdabot> (line 1, column 63):
17:54:27 <lambdabot> unexpected ';'
17:54:27 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
17:54:37 <t4nk232> x = [1] : map (concatMap (\y -> [head y, length y]) . group) x; f xs = sum $ zipWith (\a b -> a * 10 ^ b) (reverse xs) [0..]; y = map f x; g n = take n y
17:54:41 <t4nk232> @pl x = [1] : map (concatMap (\y -> [head y, length y]) . group) x; f xs = sum $ zipWith (\a b -> a * 10 ^ b) (reverse xs) [0..]; y = map f x; g n = take n y; main = readLn >>= print . g
17:54:42 <lambdabot> (line 1, column 63):
17:54:42 <lambdabot> unexpected ';'
17:54:42 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
17:54:48 <t4nk232> @pl x = [1] : map (concatMap (\y -> [head y, length y]) . group) x; f xs = sum $ zipWith (\a b -> a * 10 ^ b) (reverse xs) [0..]; y = map f x; g n = take n y
17:54:48 <lambdabot> (line 1, column 63):
17:54:48 <lambdabot> unexpected ';'
17:54:48 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
17:54:56 <erisco> so if I follow allong with the errors I get to   netwireIsCool :: (Fractional t, Semigroup t, IsString t, Monad m, HasTime t s) => Wire s () m a t
17:55:16 <erisco> but then it complains no instance for Semigroup NominalDiffTime ... also IsString t and Fractional t together looks wrong
17:56:15 <danilo2> Hello! does anybody knows why the code "data MyFree f a = MyPure a | MyFree (f (MyFree f a)) deriving Typeable" results in compilation error " ... `MyFree' must only have arguments of kind `*'", while in the FreeMonad library exactly the same code compiles? (http://hackage.haskell.org/package/free-4.2/docs/src/Control-Monad-Free.html#Free) ?
17:58:00 <jle`> erisco: they are different t's
17:58:05 <jle`> just set your last parameter to String
17:58:14 <jle`> Fractional t refers to the time parameter
17:58:20 <jle`> in HasTime t s
17:58:25 <erisco> I worked it out to   Wire (Timed NominalDiffTime ()) () Identity a String   using your suggestion to help
17:58:36 <jle`> congrats
17:58:44 <erisco> and it ran, so good fun
17:58:46 * hackagebot Hclip 2.0.0.0 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-2.0.0.0 (JensThomas)
17:58:46 <jle`> yeah looking at the docts, testWire needs Identity
17:59:23 <erisco> I'll be spending more time to aquaint myself with the types now but I needed to get something to play with to start
17:59:42 <erisco> also, why does the readme steer me away from doing gui stuff?
17:59:44 <jle`> usually the compiler is kind enough
17:59:54 <jle`> does the readme steer you away?
17:59:56 <jle`> hm
18:00:01 <jle`> well if you're doing GUI stuff, like actual GUI
18:00:05 <jle`> netwire might not be the best pick
18:00:16 <jle`> netwire is for real-time things like simulations, games, animations
18:00:22 <erisco> oh sorry I was thinking of the haskell wiki page
18:00:31 <jle`> for callback-based discrete things like gui's
18:00:33 <erisco> "If you can sensibly break your application down into frames, then Netwire is for you. For other kinds of reactive applications like widget-based UIs you may want to look into reactive-banana instead."
18:00:40 <jle`> more typically you would use sodium, reactive-banana
18:00:44 <jle`> yeah
18:01:21 <erisco> mm well what is inadequate about events in netwire?
18:01:37 <jle`> they are sort of both different realizations of FRP
18:02:00 <jle`> the frp abstraction that netwire is built on is driven by clock ticks
18:02:10 <jle`> it is designed around that idea
18:02:30 <jle`> so it wasn't quite designed for things like callbacky/gui stuff
18:02:45 <jle`> it doesn't make too much sense in the context of netwire's frp
18:02:52 <erisco> well any game is going to have gui. I don't understand the idea that it is not suitable
18:03:05 <danilo2> Here is a code snippet and error (http://lpaste.net/101102). I would be very thnakful if somebody could look into it :)
18:03:21 <jle`> erisco: you can do GUI/UI stuff in netwire
18:03:30 <jle`> but
18:03:40 <jle`> if all you are doing is gui/ui then reactive-banana or sodium is a better pick
18:04:14 <erisco> I wish that I had a better basis to see this on
18:04:15 <jle`> you can twist sodium into doing frame-driven stuff, but it is not 'baked into' the system like it is for netwire
18:04:57 <jle`> you can do real-time rendering of gui/ui...and that works
18:05:03 <jle`> (on netwire)
18:05:24 <jle`> you can also mix/match, and use sodium/reactive for your gui and netwire for your animation
18:06:20 <jle`> i am sort of speaking a bit abstractly, sorry.
18:06:35 <chas> dmj`: fyi cabal reinstalls seems to have fixed it - some kind of cabal hell I slipped into mysteriously, thx for your time
18:06:38 <jle`> i'm developing some netwire games and i haven't quite approached the ui thing yet.
18:06:52 <jle`> but there is no problem with sort of mixing the two system either
18:07:06 <jle`> outsourcing to sodium for gui, using netwire to drive your frame-driven realtime stuff
18:07:19 <jle`> or using sodium for your gui and using netwire to render animations underneath somewhere
18:07:22 <erisco> how would you describe the use of netwire events?
18:07:37 <jle`> do you have experience with sodium/reactive-banana events?
18:07:43 <erisco> you say no
18:07:46 <erisco> sorry
18:07:48 <erisco> *no
18:07:58 <jle`> ah. well
18:08:29 <jle`> the 'model frp' that netwire follows is that behaviors can be described as functions :: t -> a
18:08:39 <jle`> and that events are lists [(t, a)]
18:08:56 <centrinia> How do I @let a multiline function for lambdabot?
18:08:57 <jle`> behaviors are continuously time-varying things, and events are discrete lists of points in time and values
18:09:26 <jle`> in the netwire implementation, both behaviors and events are implemented by Wire
18:09:41 <jle`> Behavior a having type Wire b a
18:09:43 <danilo2> Ah I know! It is allowed from GHC-7.7 up
18:09:45 <danilo2> :)
18:09:47 <jle`> Events having Wire b (Event a)
18:10:02 <erisco> and you suggest this model is not suitable for GUIs? or is it something else about netwire that makes it less than ideal?
18:10:04 <jle`> where data Event a = NoEvent | Event a, but don't tell anybody that
18:10:15 <jle`> erisco: that's not what makes it not suitable, no
18:10:28 <jle`> it's just the fact that it's frame-driven
18:10:31 <jle`> and most gui's aren't frame-driven
18:10:34 <erisco> okay, the other thing you mentioned was it was based on a clock tick
18:10:34 <jle`> they are event-driven
18:10:58 <jle`> you can use netwire to write event-driven animations and things
18:11:00 <erisco> what about being driven by a clock tick makes the model unsuitable?
18:11:08 <jle`> when you think of a GUI
18:11:12 <jle`> it's usually something that waits for input
18:11:17 <jle`> then as soon as it receives input, something happens
18:11:20 <jle`> and then it waits again
18:11:29 <jle`> the 'action' is driven by events, user input
18:11:37 <jle`> in netwire, something happens at every frame
18:11:48 <jle`> at every frame, things are being updated, changing continuously
18:11:59 <erisco> how does it decide that there is work to do?
18:12:11 <jle`> erisco: a good example might be a physics simulation
18:12:15 <jle`> if you have a ball falling
18:12:20 <jle`> at every tick, it will move the ball down a bit
18:12:23 <jle`> depending on gravity
18:12:26 <jle`> etc.
18:12:35 <erisco> sure but the ball falling is dependent on time
18:12:36 <c_wraith> is any FRP framework suitable for discrete simulation?
18:13:04 <erisco> consider a GUI though. what work is being done if the wire is waiting for an event?
18:13:04 <jle`> c_wraith: mm_freak's new wire abstraction is supposed to be for arbitrary-topology time
18:13:27 <chas> a frame-driven game will probably have a frame-driven gui
18:14:07 <jle`> erisco: wires can react to input as external events, and decide to change course based on those events.  if you had a GUI, you would basically "wait" on every frame tick and not do anything, and then make stuff start happening discretely when you receive an event
18:14:16 <jle`> the clock is never-ceasing, eternal
18:14:34 <jle`> as for the cost...it's actaully not too costly to do it this way
18:14:41 <jle`> you don't pay too much, performance-wise
18:14:48 <jle`> maybe you do, maybe you don't
18:14:53 <jle`> depending on how smart you are with your redrawing
18:15:08 <jle`> the main thing is that it's just a lot less 'natural' than it is for sodium/reactive-banana type frp
18:15:44 <jle`> where you get this sort of waiting, react on this only, etc. for free
18:16:02 <jle`> and its abstractions are designed to make that kind of behavior easy to model
18:20:17 <erisco> jle`, hm, I have a clearer understanding of the difference now, thanks
18:20:46 <jle`> erisco: i encourage you to explore some of this yourself, too
18:21:09 <jle`> i do not have much working experience of the push-pull frp stuff besides what i have read in papers and talks and some code samples
18:21:11 <erisco> well I don't really have the time to explore more than one library
18:21:23 <jle`> but this is what i've gathered from my readings and from my time working with netwire
18:22:38 <erisco> what is most important ATM is sufficient documentation... and it is proving hard to find that for reactive banana
18:22:48 <erisco> all the examples 404
18:24:52 <jle`> heh
18:25:13 <jle`> try sodium?  the maintainer is pretty active i think
18:25:27 <jle`> https://github.com/kentuckyfriedtakahe/sodium/blob/master/haskell/examples/games/freecell.hs is a sample event-driven game
18:25:40 <jle`> and http://weblog.luite.com/wordpress/?p=127 uses sodium for ghcjs
18:25:58 <erisco> yeah it is ghcjs that I am using too actually
18:26:49 <jle`> nice
18:26:53 <jle`> so you've seen those examples i'd imagine?
18:27:36 <erisco> yes I have that page open but it is not a sodium tutorial
18:27:50 <erisco> though it will be useful once I know the sodium library
18:31:07 <pavonia> What module is liftIO from?
18:31:34 <geekosaur> Control.Monad.Trans, I think?
18:31:35 <erisco> pavonia, hoogle is a good way to figure that out
18:31:53 <pavonia> @hoogle liftIO
18:31:53 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
18:31:53 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
18:31:53 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
18:32:52 <jle`> erisco: may i ask what your eventual project is? out of curiosity
18:33:03 <pavonia> geekosaur: Ah, mtl, thanks! I thought there was a version in base
18:33:19 <erisco> jle`, other than GUI, synchronization of data between a server and client
18:33:38 <jle`> erisco: ah. what kind of channel?
18:33:40 <jle`> websockets?
18:34:01 <erisco> no idea. at the moment it is just pulling from the server using ajax
18:34:13 <jle`> i see
18:34:18 <jle`> well, best of luck :)
18:34:31 <erisco> not sure how well supported websockets are... but that is a possibility
18:35:31 <erisco> I don't think I can understand sodium from the api docs
18:37:22 <jle`> erisco: i'm writing a websockets library
18:37:34 <jle`> so far it works pretty well
18:37:46 <erisco> in all major browsers?
18:37:59 <jle`> that support websockets :P
18:38:03 <jle`> i thought you meant ghcjs support
18:38:13 <jle`> but yeah browser support is...passable these days
18:38:43 <jle`> http://caniuse.com/#search=websockets
18:38:57 <erisco> aha... sync (pure 5)   will give me pure 5 in IO
18:39:09 <erisco> there is a start lol
18:39:42 <jle`> http://html5please.com/#websockets
18:39:54 <jle`> erisco: :D
18:40:18 <erisco> not supported by mobile devices... well I guess it is long-polling then
18:41:43 <zomg> works on iOS >5 but Android support is kinda limited iirc
18:41:51 <erisco> I don't know how to get from Event to Reactive
18:42:03 <erisco> ah, well there is count
18:42:18 <erisco> but it is deprecated
18:42:25 <zenkeku> Alright, I'm clearly retarded. Would one of you fantastic persons help me add a window spacing to my layout hook?
18:42:40 <geekosaur> zenkeku, do you know about #xmonad?
18:42:44 <zenkeku> Oh.
18:42:46 <zenkeku> Ohh
18:42:48 <zenkeku> I'm not in that channel.
18:42:50 <zenkeku> Whoops.
18:48:46 <erisco> jle`, wow just the "count the button clicks" example compiles to 60,000 LoC
18:49:08 <jle`> erisco: well...are you counting the entire ghc runtime?
18:49:16 <erisco> no, just out.js
18:50:04 <jle`> hm. don't know enough about this to be able to say anything intelligent, but i would think out.js has more than just the counting logic.
18:52:21 <erisco> jle`, afaik that goes into other files. (rts.js I think... there was a table explanining it somewhere)
18:53:27 <erisco> compiling the second example gives 70k LoC, and it is only twice as long (in Haskell source)
18:55:21 <erisco> that is a ratio ~1:300 lol
18:55:33 <jle`> heh
18:55:41 <jle`> try looking at the report?
18:55:56 <jle`> it'll probably show you what percentage of the outputted code is what
18:56:17 <jle`> it's out.stats i think
18:56:29 <erisco> this makes me nervous... I know they are working on reducing the output size, but I don't know by how much
18:57:02 <erisco> and at this rate, by the time the project is a few thousand lines (which it already is in another language) then the client will be far too large
18:58:17 <erisco> main is 23484 (bytes I presume)
18:59:33 <erisco> and it is 60 lines, so that is a third of a KB per line
19:01:12 <jle`> it might not be exactly linear
19:01:22 <jle`> it might level off
19:12:05 <hunt> hey haskell
19:12:14 <hunt> im trying to write a program with haskell opengl
19:12:26 <hunt> and i want it to draw the same image each frame
19:12:33 <hunt> unless it can getline
19:12:41 <hunt> is that possible?
19:12:55 <hunt> i dont want the getline to freeze the program until its completed
19:15:33 <pavonia> In gtk2hs, what is the preferred way for a container to layout the size and position of one of its widgets? There's widgetSizeAllocate but that doesn't seem to be available, as the Allocation type is defined in a hidden module
19:16:07 <pavonia> hunt: Span a new thread?
19:16:51 <pavonia> *Spawn
19:18:37 <hunt> pavonia: thats what i figured i should do but i have 0 experience with threads and dont know where to start
19:21:09 <pavonia> hunt: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html might be good start (haven't read it yet)
19:21:34 <hunt> pavonia: damn, was hoping for a simpler solution
19:22:18 <pavonia> Btw, why do you want to draw the *same* image each frame?
19:24:51 <hunt> well the frame only changes if the user enters a command that changes whats being displayed, its like a real time object constructor sort of
19:24:56 <hunt> pavonia ^
19:25:03 <hunt> also its amazing how quiet haskell gets after 9
19:28:12 <pavonia> hunt: Hhm, but what's the problem with getLine if the image doesn't change?
19:34:38 <[swift]> with a GUI program blocking for input on the same thread that handles the GUI event loop is bad
19:35:11 <hunt> pavonia: you cant resize the window while its blocked
19:35:34 <[swift]> hunt: take a look at Control.Async. it's very pleasant to use
19:36:08 <hunt> <[swift]> thanks, is there a standard place to learn about it?
19:36:34 <[swift]> read the docs. it's pretty straightforward
19:46:42 <hunt> <[swift]> cool man
19:52:36 <nolrai66> Hey so if I wanted to make a 2d game are there good libraries available? I was messing around with Elm and found it fairly easy to use, but am not really interested in compiles-to-javascript.
19:54:51 <edwardk> Is there anyone here interested in registering for gsoc as either a mentor or student?
19:55:21 * edwardk decides to just ask around more directly.
20:02:15 <pavonia> Re my layout question, if you can't import the module defining Allocation, can you at least construct a value of that type from a given size?
20:03:16 <average> edwardk: erm hi ?
20:08:08 <average> nolrai66: compile-to-js would allow you to run stuff in the browser, which is nice
20:08:25 <hunt> any cool haskell irc clients?
20:08:39 <average> nolrai66: if there's anything that would compile haskell code using opengl to webgl for the browser that be real awesome too
20:09:02 <average> nolrai66: but for 2d games, have you looked at rainycat ? it's written entirely in Haskell
20:09:03 <hunt> isaacbw: hire you for what
20:10:17 <nolrai66> average: Thanks. That's exactly what I wanted, an idea of what the ecosystem is like. When I last looked (in ..2000 I think?) things were pretty rudimentary.
20:10:38 <hunt> nolrai66: holy shit have you been using haskel for 14 years?
20:11:23 <nolrai66> Hmm. Maybe? I might be missremembering.
20:12:00 <hunt> average: no raincat for os x?
20:12:04 <nolrai66> I am not good at dates. Often get my birthdate off by 11 years. Though thats just dyslexia.
20:12:25 <average> hunt: if you have all the libs you can build raincat
20:12:25 <hunt> nolrai66: is it hard to program with dyslexia
20:12:39 <hunt> average: many libs?
20:13:04 <average> hunt: a few :)
20:13:13 <nolrai66> Honestly what I have isn't bad. Worse for math, get pluss and times confused. Maybe thats why I liked geometry..
20:13:49 <hunt> nolrai66: i loved geometry
20:13:59 <pavonia> Aha, for the logs: Allocation is a synonym for Rectangle which is has a visible constructor of the same name
20:14:02 * hackagebot thyme 0.3.1.1 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.1.1 (LiyangHu)
20:14:43 <nolrai66> hunt: If I was a mathmatitian I would probobly work in finite geometry. I just find messing around with differnt axioms really cool.
20:15:41 <hunt> i love conceptual math so much more than arithmetic stuff
20:16:48 <hunt> average: why does it import so many modules from hidden (Maybe, IO ...)?
20:17:36 <nolrai66> hunt: from hidden?
20:17:49 <edwardk> nolrai66: have you read albrecht beutelspacher's finite geometry stuff?
20:18:03 <hunt> nolrai66: the built in stuff like haskell98 and ghc
20:19:00 <ski> edwardk : fano plane ?
20:19:05 <nolrai66> Probobly to make the code cleaner. I basicly always import everything these days. Just ends up being easier for me conceptually, then remember what portions of things are in the Prelude.
20:19:06 <roboguy_> hunt: I got raincat to run on os x a while ago
20:19:12 <edwardk> nolrai66: for me that was when finite geometry really clicked, but then his projective geometry text with ute rosenbaum largely defined my thinking on projective geometry.
20:20:04 <yamadapc> hey... I've just finished learn you a haskell. Is the standard for Zipper unit's naming actually something-"crumb"?
20:20:24 <roboguy_> hunt: in fact, I probably have my patches for it somewhere
20:20:49 <edwardk> ski: http://www.amazon.com/Theory-Finite-Linear-Spaces-Combinatorics/dp/0521333172
20:20:58 <edwardk> ski: but yes, that is an example =)
20:21:27 <nolrai66> I still find it wierd that there doesn't seem to be anything about what happens when you _really_ mess with geometry, like try to have circles or other three point curves as the foundation. But maybe it just doesn't lead anywhere useful.
20:21:36 <hunt> roboguy_ howd you do it?
20:21:36 <edwardk> yamadapc: not typically
20:21:54 <roboguy_> hunt: I don't remember specifically. I just went through each error and updated it to work with modern ghc
20:22:03 <yamadapc> (*units') oh... and btw.. a while back I was going through jekor's "Redo from scratch" (or something), and the project doesn't build correctly in OSX (in about step 4)
20:22:21 <yamadapc> edwardk: what would you name it then?
20:22:44 <edwardk> circles work fine, even under the linear algebraic interpretation. that way lies conformal geometric algebra though.
20:23:10 <yamadapc> it had something to do with ghc not working when piping its output to a file
20:23:13 <yamadapc> (weird)
20:23:34 <Kron> Does anyone know why Control.Lens can't be imported Safely?
20:23:39 <ski> nolrai66 : hm, there's non-commutative geometry
20:24:08 <nolrai66> Oh I should look into that.
20:24:52 <edwardk> Kron: Honestly? It is because getting SafeHaskell urned on correctly across 800+ modules is a pain in the ass. I'm happy to take patches that fix each of lens' dependencies in turn, but it'll be a rather long slog.
20:25:04 <Kron> edwardk: gotcha, not judging
20:25:07 <edwardk> Kron: We had it working briefly around 3.9 or 3.10
20:25:17 <Kron> I was just a bit curious because I only learned about Safe compiling today
20:25:28 <edwardk> Kron: then elliott lost interest in fighting with it
20:25:33 <Kron> and the only packages GHC freaked on where Debug.Trace (expected) and Control.Lens (what?)
20:25:35 <nolrai66> Gah, not sure I can justify 113 dollars for what is basically a hobby now.
20:25:46 <yamadapc> I've a copy of real world haskell and am going through haskell's 99-problems, but... are there any suggestions on where should I go to next?
20:25:52 <roboguy_> Kron: you might be able to import some of the submodules that way
20:25:57 <Kron> I was wondering if there was some secret dark coercian ritual or something going on behind the scenes
20:25:59 <Kron> yeah, maybe
20:26:00 <edwardk> Kron: Control.Lens supplies instances for a lot of non-safe packages, like Vector
20:26:02 <roboguy_> Control.Lens imports just about everything, I think
20:26:13 <Kron> hmmm, I think I just want lens itself...
20:26:20 <Kron> https://github.com/Kronosynth/haskell-libraries/blob/master/QuadTree.hs
20:26:22 <Kron> Lens' and lens
20:26:28 <edwardk> Kron: you can reason through how Trustworthy the individual modules are or can be
20:26:30 <Kron> the most basic lens functions there are
20:27:01 <edwardk> Kron: Control.Lens.Type is Safe
20:27:05 <Kron> gotcha
20:27:06 <Kron> thanks!
20:27:07 <edwardk> that supplies Lens
20:27:28 <dmj`> yamadapc: I found the typeclassopedia helpful
20:27:34 <edwardk> Control.Lens.Lens exports lens, and should be Trustworthy
20:27:50 <roboguy_> what's the difference between Safe and Trustworthy?
20:27:57 <Kron> I think they're synonyms?
20:28:04 <Kron> the documentation treated them as similar at least
20:28:12 <edwardk> Safe is 'you on't have to trust the author'. Trustworthy is the author claims it is safe.
20:28:20 <Kron> ahhh, okay
20:28:27 <roboguy_> edwardk: meaning it might use unsafePerformIO and stuff like that?
20:28:34 <roboguy_> or is that still not allowed?
20:28:36 <edwardk> lens uses unsafeCoerce tricks to get performance that are safe in the trustworthy sense
20:28:39 <yamadapc> dmj`: neat... thanks
20:29:02 <edwardk> in that we can provide prtty compelling evidence that the optimizations we do are sound.
20:29:06 <nolrai66> hmm. If I use fpcompleate then I don't have to install a linux on my laptop..but my trial expires in 6 days, and I won't have a credit card for ~14 days.
20:29:35 <Kron> nolrai66: invent a time machine
20:29:46 <edwardk> Basically you can think of 'Trustworthy' modules are forming the trusted computing core of your application.
20:29:47 <roboguy_> yamadapc: after typeclassopedia, lens is pretty cool
20:30:05 <edwardk> a Safe module can use a Trustworthy one, but you have to trust the trustworthy ones
20:30:10 <nolrai66> kron: :p
20:30:12 <Kron> I really like the sheer number of Compiler Things you can do
20:30:17 <edwardk> you can configure trust
20:30:27 <Kron> back in common lisp I could just place type annotations, or maybe ask it to optimize for speed or space
20:30:36 <Kron> in haskell you can do all sorts of things, extending to custom rewrite rules
20:30:41 <Kron> which are the greatest thing ever
20:30:52 <Kron> roll your own compiler bits!
20:31:34 <yamadapc> roboguy_: you mean reading the source, right? looks cool too, thanks! I think I'm going to go through this (http://jamiltron.com/2012/07/Code_Us_Some_Roguelike_in_Haskell.html) later today, too
20:32:11 <hunt> Kron: i didnt know you could write anything for the compiler to do at all? where can i learn about this?
20:32:15 <dmj`> yamadapc_: lens gets mentioned at the traversable part in typopedia w/ links
20:32:21 <roboguy_> yamadapc: I wouldn't start by reading the source of lens. I'd suggest just learning how to use it first (after you understand typeclassopedia)
20:32:33 <Kron> hunt: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/rewrite-rules.html
20:32:42 <Kron> basically, if you know something about your code that your compiler doesn't
20:32:44 <Kron> you can teach it
20:32:49 <nolrai66> Oh, hmm. $35 including shiping is a lot more reasonable. Man that's a 30% for used vs. new. Fiction is usually only like 50%.
20:32:54 <Kron> so it can use that delicious potentially-mathy knowledge in its optimizations
20:33:11 <heatsink> Unless lambdas are involved
20:33:21 <Kron> also I think you can import rules and stuff too, so I guess you can write whole files that are nothing but rewrite rules
20:33:27 <Kron> which would be pretty funny
20:34:17 <roboguy_> yamadapc: lens's internals can be sort of non-intuitive but it's not too bad to get started learning *how* to use it
20:34:51 <edwardk> lens' internals are counter-intuitive to everyone, even the designer ;)
20:35:07 <roboguy_> edwardk: haha, that's reassuring to hear
20:35:27 <Kron> they were so nonintuitive to me that I kind of just gave up and resorted to "A lens is a combination of a getter and a setter" party lines
20:35:36 <Kron> I wrote a giant getter and a giant setter and roped it into a lens
20:35:39 <Kron> so ugly
20:35:52 <Kron> bet I could've used recursive lens composition to make it much much neater
20:35:52 <roboguy_> I think there was actually a class this semester on lenses, but I'm not a grad student (yet)
20:36:04 <roboguy_> that was the rumor anyway
20:36:06 <yamadapc> haha...
20:36:18 <Redz> why do  (²) x = x^2  not work but other unicode chars do?
20:36:45 <edwardk> there'll likely be a tutorial at CUFP this summer on them
20:37:06 <haasn> > generalCategory '²'
20:37:07 <lambdabot>  OtherNumber
20:37:23 <haasn> > let hello² = () in hello²
20:37:24 <lambdabot>  ()
20:37:39 <pyon> @hoogle generalCategory
20:37:40 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
20:37:40 <lambdabot> Data.Char data GeneralCategory
20:37:54 <roboguy_> > ²
20:37:55 <lambdabot>  <hint>:1:1: lexical error at character '\178'
20:37:56 <haasn> Redz: because ² is a number, it 1. can't be used in operators and 2. can't be used at the start of a name
20:38:18 <roboguy_> it looks like it's both a number and not a number
20:38:19 <fly2web> http://lpaste.net/101109  <---- why error occurs?
20:38:31 <haasn> it's a number but it's not part of a valid number literal
20:38:34 <pyon> > generalCategory '2'
20:38:35 <lambdabot>  DecimalNumber
20:38:37 <roboguy_> right
20:38:46 <Kron> fly2web: there are two separate functions called map
20:38:48 <hunt> is there a subsitute for sdl-mixer for sdl2?
20:38:48 <Kron> that you've imported
20:38:49 <haasn> > isNumber '²'
20:38:50 <Redz> interesting.
20:38:50 <lambdabot>  True
20:38:51 <Kron> which one do you want to use?
20:39:02 <Kron> oh I see
20:39:06 <Kron> are you writing your own map function?
20:39:14 <fly2web> yes
20:39:16 <Kron> you want to give it a new name to not overlap the existing map
20:39:21 <Kron> call it map' or something
20:39:25 <fly2web> i mad it on my vim file.
20:39:33 <roboguy_> Redz: also, I don't think you can have postfix operators like that
20:39:36 <Kron> alternatively, you can replace the existing map by putting this on top of your file:
20:39:37 <haasn> fly2web: the Prelude is implicitly imported in all haskell files, and the Prelude contains map (among other functions)
20:39:40 <Kron> import Prelude hiding (map)
20:39:45 <fly2web> map is interal function?
20:39:46 <Kron> this will skip map
20:39:47 <Kron> yes!
20:39:47 <haasn> fly2web: I would suggesting importing Prelude without map, yes
20:39:49 <roboguy_> Redz: if it worked, you probably would have to use it like (²) 5
20:39:50 <Kron> map is an internal function
20:39:53 <Kron> and you are trying to redefine it
20:39:58 <Kron> you can skip importing it
20:40:00 <Kron> and just make your own
20:40:02 <haasn> roboguy_: you could do it as (5²) with PostfixOperators
20:40:04 <Kron> or you can rename your version
20:40:09 <haasn> but only as a section
20:40:11 <roboguy_> haasn: huh I didn't know that
20:40:13 <haasn> roboguy_: of course, assuming ² was a symbol
20:40:16 <roboguy_> yeah
20:40:20 <fly2web> Kron: thanks
20:40:26 <hunt> > 5^2
20:40:27 <lambdabot>  25
20:40:40 <haasn> > let (n!) = product [1..n] in (5!) -- lambdabot should have it enabled
20:40:41 <lambdabot>  <hint>:1:6: Parse error in pattern: n !
20:40:46 <haasn> > let (!) n = product [1..n] in (5!) -- lambdabot should have it enabled
20:40:47 <lambdabot>  120
20:40:51 <Redz> or is ² part of the unicode extension?
20:41:05 <Redz> ähm
20:41:05 <haasn> > ord '²'
20:41:06 <lambdabot>  178
20:41:33 <haasn> Redz: not sure what you're asking; are you referencing the UnicodeSyntax extension?
20:41:43 <Redz> i mean, this thing that allow to use real char arrows instead of -> in functions and stuff.
20:41:47 <haasn> the extension doesn't affect the interpretation of ², unfortunately
20:41:54 <haasn> (among other things it doesn't do)
20:41:58 <roboguy_> edwardk: I'll probably not be able to make that. are they planning on recording it?
20:42:17 <haasn> Redz: it also won't let you use eg. ¬ for not
20:42:27 <haasn> Redz: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax here's a list of things it treats specially
20:42:59 <haasn> (although I'm suddenly unsure where >- is used)
20:43:07 <edwardk> roboguy_: As both program chair and guy giving the tutorial I'm all for recording it ;)
20:43:19 <roboguy_> edwardk: awesome!
20:43:25 <nolrai66> haasn: in the do notation for arrows. I think.
20:43:42 <haasn> nolrai66: that involves -< and -<< but I'm not sure about where >- shows up
20:44:11 <haasn> (which means we should totally roll out libraries that export (>-) and abuse UnicodeSyntax on them!)
20:44:39 <haasn> .. then again, we could always roll out libraries that export (↣). And abuse UnicodeSyntax even more
20:45:29 <edwardk> haasn: arrow notation
20:47:25 <nolrai66> Man I read that paper on interpreting inverse and negative types in a linear type environment and I still don't understand the difference between them semantically.  Like when I see the difference in his abstraction..but when I try to actually implement an 'interpreter' they end up being the same thing.
20:47:45 <roboguy_> haasn: it looks like arrow notation uses both
20:48:01 <haasn> roboguy_: what does it do in arrow notation?
20:48:20 <roboguy_> haasn: I'm not sure, but enabling -XArrows seems to recognize it
20:48:30 <roboguy_> > proc x -> undefined >- undefined
20:48:31 <lambdabot>  <hint>:1:8: parse error on input `->'
20:48:34 <roboguy_> aw
20:48:39 <hunt> should i use sdl or sdl2 in my haskell
20:49:37 <haasn> Interesting, many parts of xkcd's website backend are written in Haskell
20:49:47 <hunt> haasn, really? thats awesome
20:50:00 <haasn> http://www.reddit.com/r/haskell/comments/uved7/waldo_the_haskell_powered_codebase_behind_xkcds/
20:50:07 <roboguy_> haasn: didn't he do a comic about no one using haskell haha
20:50:19 <haasn> “Haskell is used so much over here because of its safety and low surprise factor. The community is made up primarily of contributors who tend to care about the details of their respective problem domain and craft APIs to match. While libraries can be scarce the ones that are available are crafted with an attention to detail often lacking in other languages.”
20:50:22 <sevak> hello guys, in Exercise 5 in the following document, in the second step of the 3 mentioned near the bottom of that page, whose to say that the top disck is still on peg a? The 3 steps don't make sense to me. Thanks http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
20:50:40 <roboguy_> hunt: sdl2 is more low-level and sdl is higher-level
20:50:54 <roboguy_> I think I had more trouble getting sdl to work on os x, but I figured it out eventually
20:51:53 <roboguy_> hunt: you need a little bit of c code or os x's graphical system doesn't like it (just a small wrapper)
20:52:12 <roboguy_> I'm not sure if sdl2 has the problem as well or not, actually
20:52:30 <hunt> roboguy_ you wrote it for raincat?
20:52:46 <roboguy_> hunt: I didn't write raincat, I just downloaded raincat and got it to work
20:52:57 <hunt> roboguy_ i mean to get it to work you wrote the wrapper?
20:52:57 <edwardk> haasn: about 75% of their homegrown infrastructure is in haskell
20:52:57 <roboguy_> (eventually)
20:53:07 <roboguy_> hunt: oh, no. all that stuff was fine
20:53:29 <roboguy_> hunt: the main problems with raincat, as I remember, are pre-hierarchical imports etc
20:53:31 <hunt> roboguy_ ah phew this is supposed to be a fun adventure not a c
20:53:39 <joxn> sevak: it's still on peg a because you haven't moved it yet, by definitino
20:54:42 <joxn> sevak: it might help to get a stack of four coins and try to work it out physically
20:55:00 <joxn> quarter, nickle, penny, dime, if you're using US money
20:57:17 <sevak> joxn: but isn't the top disc the firt one one would move? Also, I've been using this: http://www.mathsisfun.com/games/towerofhanoi.html
20:58:23 <sevak> so for example, with 3 disks, step 1 is to move the top disk to another peg
20:58:44 <hunt> guys im trying to install sdl on os x and i got: Graphics/UI/SDL/Events.hsc:56:23:     Module ‛Data.Typeable’ does not export ‛Typeable(typeOf)
20:58:48 <hunt> what can i do
20:59:52 <sevak> joxn: or by saying the "top disk" does it mean the last disk on peg a?
21:00:09 <joxn> sevak: it means the top disk on peg a, which could also be the last disk.
21:00:20 <joxn> the top disk of the disks on peg a
21:00:34 <sevak> hmm ok, for some reason I was taking that to mean the smallest disk
21:00:57 <joxn> yeah, it would be clearer if it said "move the top disk of the disks that are left"
21:01:44 <sevak> joxn: thanks
21:02:19 <roboguy_> hunt: I'd start be removing the (typeOf) part
21:02:31 <roboguy_> hunt: what ghc version do you have/
21:02:39 <hunt> 7.8.0
21:02:57 <dmj`> Data.Typeable does export typeof tho
21:03:02 <dmj`> typeOf
21:04:08 * hackagebot core-haskell 0.6 - A subset of Haskell using in UCC for teaching purpose  http://hackage.haskell.org/package/core-haskell-0.6 (happlebao)
21:04:22 <hunt> > typeOf
21:04:23 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
21:04:23 <lambdabot>    arising from a use of `M29367809636324789599789.show_M29367809636324789599...
21:04:23 <lambdabot>  The type variable `a0' is ambiguous
21:04:23 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:04:23 <lambdabot>  Note: there are several potential instances:
21:04:35 <hunt> so what the hell
21:05:03 <roboguy_> hunt: they changed Typeable
21:05:04 <NemesisD> hey guys. how can i get around of the issue of sum types with multiple constructors and different field names creating partial functions
21:05:15 <roboguy_> hunt: are you looking at the 7.8 docs?
21:05:31 <hunt> roboguy_ no im not but damnit!
21:05:39 <hunt> roboguy_ i guess this mission is a bust then
21:05:42 <NemesisD> on the one hand, doing pure pattern matching of unnamed fields is cumbersome, and fields with the same types are easy to mix up
21:05:51 <NemesisD> i.e. Foo String String, which string field is what
21:05:53 <roboguy_> hunt: well, I don't think they changed it *that* much
21:06:35 <hunt> roboguy_ they did change it though to the point of fubarring sdl
21:06:36 <roboguy_> hunt: oh, huh. it looks like it still should export typeOf..
21:06:47 <dmj`> > typeOf "ok"
21:06:48 <hunt> roboguy_ ... :'(
21:06:48 <lambdabot>  [Char]
21:06:55 <roboguy_> hunt: if you want to, you can do "cabal unpack sdl" and edit the code
21:07:01 <roboguy_> (that's what I'd try to do)
21:08:17 <hunt> well it hasnt retreived the full source
21:08:27 <hunt> particularly the error ridden source
21:08:27 <roboguy_> hunt: ?
21:08:40 <hunt> i dont have all of the sdl package installed because its failing
21:08:46 <hunt> so i can unpack only the stuff thats working
21:08:48 <dmj`> NemesisD: why not make them records? data A = Z { a :: String } | Y { a :: String }
21:08:58 <roboguy_> hunt: you can unpack anything you want to working or not...
21:09:14 <roboguy_> that's the main reason I use it, actually
21:09:19 <hunt> roboguy_ well event.hs is not there so im not sure what to make of it
21:09:19 <enthropy> seems nemesis' issue is more like data S = A { _a, _b :: String } | B { _b :: String }
21:09:27 <NemesisD> enthropy: exactamundo
21:09:34 <enthropy> so _a can fail
21:09:39 <NemesisD> the best i've found to avoid that is to break out the differing fields into diff types
21:09:45 <roboguy_> hunt: are you sure Events.hs isn't there? did you do something like "find . | grep Events" in the src directory?
21:10:14 <hunt> ah its .hsc
21:10:24 <NemesisD> data S = A A | B B; data A = MkA { _a, _ab :: String }; data B = MkB { _bb :: String }
21:11:36 <roboguy_> hunt: I see the problem. typeOf is a function now, not a method of Typeable
21:11:42 <roboguy_> it's in the same module though
21:11:43 <hunt> yea i see that!
21:11:49 <hunt> i literally just changed it as you messaged me
21:11:58 <hunt> i love it when things are synchronous on the haskell irc
21:12:00 <roboguy_> haha, good work
21:12:26 <haasn> NemesisD: by using lenses
21:12:37 <hunt> so how do i install my modified package? just cabal build? cabal install .?
21:12:42 <NemesisD> i'm wondering if *hand waving* type families or gadts would help
21:12:48 <roboguy_> hunt: just "cabal install"
21:13:04 <NemesisD> haasn: meaning prisms?
21:13:06 <roboguy_> hunt: that uses the .cabal file in the current directory
21:13:10 <haasn> NemesisD: I'm not sure what lens will actually autogenerate here but ideally you'd want _b to be a Lens' S String and _a to be a Traversal' S String
21:13:29 <hunt> its so cool that haskell has replacements for pretty much everything
21:13:30 <roboguy_> hunt: incidentally, cabal is handy for personal projects. I'd recommend it
21:13:33 <hunt> even unneccessarrily
21:13:39 <haasn> NemesisD: you could also use prisms _A :: Prism' S (String,String) and _B :: Prism' S String -- but then you're left with the same issue in the first example
21:13:46 <hunt> roboguy_ is there a good tutorial? is it at all simliar to using git?
21:14:04 <haasn> Oh, I wonder if pattern synonyms can actually define record-like syntax
21:14:20 <heatsink> cabal is a build system, not a VCS
21:14:30 <NemesisD> haasn: so don't derive my lenses but roll them by hand to handle the partial case?
21:14:33 <heatsink> hunt: cabal is analogous to configure/make
21:15:02 <haasn> Oh no, parse error on input {   :(
21:15:06 <NemesisD> actually i'm starting to kind of like the idea of breaking out these constructors into different types
21:15:07 <haasn> so pattern synonyms can't define records, shame!
21:15:13 <NemesisD> so you pattern match to an extent
21:15:17 <heatsink> hunt: Tutorial for using Cabal packages, or creating Cabal packages?
21:15:19 <haasn> NemesisD: I think deriving lenses should work automatically either way
21:15:25 <haasn> NemesisD: but yeah, rolling them out would be the easiest way
21:15:44 <hunt> heatsink ah ok, idk i suppose i could google it. doesnt ghc manage to compile pretty much everything you need on its own?
21:15:50 <edwardk> NemesisD: I basically do that these days
21:16:12 <roboguy_> hunt: you still need to give it some direction, list dependencies etc
21:16:18 <roboguy_> to make a proper package
21:16:24 <edwardk> NemesisD: then you can mak an AsFoo class that lets you get a prism to that constructor, and you can use its members as lenses when used directly or as traversals when used on a larger sum
21:16:35 <edwardk> NemesisD: takes some work, but can be quite nice
21:16:37 <heatsink> hunt: If your package depends on an uninstalled module, GHC won't tell you why it's missing or what to do about it
21:16:53 <NemesisD> edwardk: you break them out into different types?
21:17:04 <hunt> ah that is very true
21:17:15 <hunt> ok on an irrellevant note
21:17:20 <NemesisD> yeah that does sound pretty cool
21:17:27 <heatsink> hunt: For creating Cabal packages, there's a user's guide at haskell.org/cabal/
21:17:37 <hunt> do you guys as experienced developers in haskell find that you can write haskell code super quickly
21:17:51 <edwardk> NemesisD: yes, mostly for big records + sums
21:17:52 <NemesisD> hunt: *points at edwardk*
21:17:54 <hunt> because so far ive found that i write much slower but thats its *usually* much more enjoyable
21:18:23 <edwardk> hunt: for me it has been a matter of slowly snowballing momentum
21:18:31 <NemesisD> edwardk: i'm trying to map a datatype to amazon's cloud formation template format and seeing if i can make invalid templates unrepresentable
21:19:05 <NemesisD> so params have a field for type valid values, regex, etc. lots of the fields are invalid for non-string types
21:19:10 * hackagebot core-haskell 0.6.1 - A subset of Haskell using in UCC for teaching purpose  http://hackage.haskell.org/package/core-haskell-0.6.1 (happlebao)
21:19:14 <heatsink> hunt, when I write code the result is clearer.  That helps when I need to figure out what I did a year later.
21:19:24 <hunt> this is strange, when installing sdl-image the configure phase is telling me the c compiler doesnt work/ cannot create executables
21:19:42 <NemesisD> so that encourages the idea of breaking the string-oriented attributes to a separate type
21:19:57 <hunt> heatsink: i still get a little bit nervous that i might just go for a lazy approach to some functions, because although its harder than in other languages its still super possible
21:20:24 <hunt> is there a way to specify which gcc executable to use for cabal install?
21:20:31 <edwardk> NemesisD: you may want to look at the way the old 3.10 version of lens handled http://hackage.haskell.org/package/lens-3.10.2/docs/System-IO-Error-Lens.html
21:21:01 <edwardk> NemesisD: you can view an IOException as a type in its own right or as a 'case' of SomeException
21:21:17 <edwardk> when you know the thing is an IOException you can use the fields of it as a lens
21:21:28 <NemesisD> edwardk: interesting
21:21:33 <edwardk> when it is merely some SomeException that _could_ be an IOException you get a traversal.
21:21:38 <edwardk> is it worth it? not sure
21:21:40 <heatsink> hunt, --with-gcc=/bin/bash
21:21:42 <NemesisD> edwardk: why'd that api get deprecated
21:21:48 <edwardk> in 4.0 we went to a simpler approach
21:22:00 <edwardk> easier to explain the types, less magical
21:22:15 <edwardk> easier to work with parametrically
21:22:16 <haasn> and all you save is a single extra _IOException, right?
21:22:25 <edwardk> haasn: yes
21:22:48 <edwardk> but it was neat to me that it was possible at all =)
21:23:08 <haasn> the old method lets you write eg.  “catching location”
21:23:10 <haasn> which simply does not make sense
21:23:18 <haasn> as opposed to “catching (_IOException.location)”
21:23:53 <edwardk> well, location is in System.IO.Error.Lens so you could import tat module qualified
21:24:08 <edwardk> and get similar self-documenting
21:24:39 <edwardk> the catching someFold generally doesn't read right anyways =)
21:26:52 <hunt> im still getting "c compiler cannot create executables" and i dont fully grasp why. in sdl-image config it looks like they test against a wide variety of conditions and im fairly certain my compiler works so maybe i can just disable the config?
21:27:17 <NemesisD> are there types like type level naturals that have an upper bound?
21:27:27 <NemesisD> i can't think of how you'd implement that
21:27:47 <haasn> NemesisD: on the type level? Or the value levle?
21:28:23 <NemesisD> haasn: as in you cannot represent a number < 1 and > n
21:29:12 * hackagebot damnpacket 0.6.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.6.0 (JoelTaylor)
21:29:50 <haasn> NemesisD: on the value level I'd probably just use a smart constructor and special addition etc. functions
21:30:01 <dmj`> hunt: what pkg are you trying to install on osx?
21:30:06 <haasn> NemesisD: on the type level, I can't think of a way other than a hand-rolled enumeration type that covers every possible value..
21:30:18 <andkore> Is the list syntax just a completely special case? Or is it taking advantage of some more general feature in Haskell?
21:30:26 <geekosaur> hunt: is this sdl-image?
21:30:29 <geekosaur> yes
21:30:31 <geekosaur> I see it is
21:30:39 <hunt> yea it is, youve tried it before?
21:30:39 <geekosaur> the problem is you're missing sdl-image C library
21:30:44 <haasn> andkore: are you talking about list comprehension syntax? eg. [foo | x <- xs, ...]
21:30:45 <hunt> ahhhhh
21:30:45 <hunt> ofc
21:30:52 <NemesisD> hashcat: what would the type of the smart constructor be
21:31:02 <geekosaur> and the configure script pushes that into the compiler test so it fails if you lack the C library but reports it as broken compiler
21:31:04 <andkore> haasn: Yeah.
21:31:11 <haasn> NemesisD: :: Integer -> MyInt
21:31:21 <haasn> (or Int, even)
21:31:33 <haasn> andkore: list comprehension syntax is closely related to do notation aka monad syntax
21:31:59 <haasn> andkore: there are extensions linking the two, eg. with MonadComprehensions you can use list syntax for other monads as well - so it's not 100% a special case
21:32:24 <NemesisD> haasn: is MyInt a newtype over Maybe Int? what is myInt -1
21:32:49 <andkore> haasn: OK, thanks. I must say, I'm not a fan of that. What if you wanted to implement your own list type and use it instead?
21:32:50 <haasn> NemesisD: oh, I was thinking it'd just get truncated to the range; but you're right, a Maybe may be (ha.) more principled
21:33:00 <NemesisD> hehe
21:33:07 <andkore> Why should the built in list get privileged syntax...
21:33:32 <hunt> how do i specify that i was to use SDL-0.6.5? :: ‛Graphics.UI.SDL.Types’:       it was found in multiple packages: sdl2-1.0.2 SDL-0.6.5
21:33:37 <NemesisD> these would be pretty low value types. they are like max length
21:33:48 <haasn> andkore: if you write a monad instance for your own list type you could use it with MonadComprehensions. Otherwise, you'd be out of luck - Haskell also does not let you redefine what [a,b,c] gets desugared to
21:33:52 <NemesisD> truncation is probably fine
21:34:07 <dmj`> hunt: do you need both? o/w unregister one. ghc-pkg unregister sdl2
21:34:20 <haasn> andkore: the simple answer is that lists are useful and built-in, many built-in types get some degree of special treatment, mainly, for syntax sugar
21:34:31 <hunt> dmj` i could just unregister for compile time and then be good later?
21:34:41 <hunt> dmj` also whats with all the special trailing characters in nicks
21:34:54 <heatsink> hunt: if you might want to use it later, then hide it instead of unregistering it
21:35:15 <heatsink> also if you have packages that depend on it
21:35:23 <haasn> andkore: however, this is not usually a problem in practice since it tends to be easy to just from Foo.fromList [ etc ]
21:35:33 <haasn> to just use*
21:35:46 <andkore> haasn: yes, I get the point, and I'm sure it's more practical
21:35:47 <haasn> eg. Set.fromList [ x | x <- somethingElse, foo x, etc. ]
21:36:07 <NemesisD> haasn: smart constructor can also be easily typechecked :)
21:36:23 <andkore> this is just a sort of aesthetic quibble
21:36:39 <andkore> I like how Scala doesn't give the built-in types privileged syntax
21:36:54 <andkore> Anyway, it's a tradeoff, and probably a good one.
21:37:24 <hunt> is there a cheap way to cast doubles as GLdoubles?
21:37:30 <haasn> Yeah, it's mainly a convenience thing. Even the more general case of do-notation is still intrinsically tied to the Monad class
21:37:41 <hunt> and similarly for GLint etc
21:37:49 <heatsink> Sometimes I wish there were a way to define custom variable-binding syntax
21:37:50 <haasn> taking that out of haskell would force us to write everything in terms of (>>=)
21:38:20 <hunt> heatsink that would be super cool
21:38:20 <ski> which is how part of GHC was written
21:39:00 <ski> heatsink : that's what macros are (mainly) for
21:39:07 <andkore> haasn: Scala gives privileged syntax to map/flatMap, too
21:39:13 * hackagebot simple 0.8.0.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.8.0.0 (AmitLevy)
21:39:15 * hackagebot simple-templates 0.7.0.2 - A basic template language for the Simple web framework  http://hackage.haskell.org/package/simple-templates-0.7.0.2 (AmitLevy)
21:39:17 * hackagebot simple-session 0.8.0 - Cookie-based session management for the Simple web framework  http://hackage.haskell.org/package/simple-session-0.8.0 (AmitLevy)
21:39:19 * hackagebot simple-postgresql-orm 0.8.0 - Connector package for integrating postgresql-orm with the Simple web framework  http://hackage.haskell.org/package/simple-postgresql-orm-0.8.0 (AmitLevy)
21:39:28 <haasn> andkore: but without preferring any built-in types?
21:39:33 <heatsink> Are there macros in Haskell, ski?
21:39:40 <ski> heatsink : no
21:39:55 <ski> with TH, you can sortof fake it i think
21:39:57 <haasn> heatsink: the closest you can get is TemplateHaskell which allows you to compute slices at compile time
21:40:30 <andkore> haasn: Honestly I have no idea. I don't know much about monads and such yet. I was just saying that even on that issue Scala provides some built-in syntactic sugar.
21:40:41 <roboguy_> hunt: aren't double and GLdouble effectively the same?
21:40:43 <haasn> heatsink: but using TH/QQ for syntax sugar is generally not popular
21:40:46 <ski> the computational part of macros is staged (meta-)programming
21:41:17 <ski> but to make it not as ugly, one needs to make the surface syntax sufficiently nice
21:41:25 <andkore> err s/even on//
21:41:38 <hunt> roboguy_ yea they are except they throw up compiler erros if you use the wrong one
21:41:49 <hunt> roboguy_ and im hesitant to change the type signatures of any of raincats functions
21:42:04 <andkore> rather, just the "even". jeez I can't write. Anyway, thanks for the help haasn.
21:42:11 <haasn> andkore: well, with regards to what I said: There is actually an extension, named RebindableSyntax, that changes the way some syntax in haskell gets desugared. For example, do notation will end up using whatever names (>>=) and (>>) are in scope - even if they're your own (or local!); rather than referring to the built-in functions (Prelude.>>=) and (Prelude.>>) from the built-in Prelude.Monad class
21:42:27 <ski> in the lisps, macro applications are written the same as primitive syntax constructions .. which makes sense since macros are just syntax which is user-defined, instead of defined by the implementation
21:42:46 <haasn> andkore: and numeric literals in Haskell are also somewhat liberated from built-in numeric types; though the abstraction is still through the built-in class Num
21:42:50 <roboguy_> hunt: I think that's what I did
21:42:57 <haasn> (and Fractional)
21:43:04 <ski> now, in the lists, macro application *also* looks like ordinary procedure combination (operator applied to operands), which is more questionable
21:43:08 <andkore> haasn: Interesting, thanks.
21:43:15 <hunt> > snd (1,2) + 1
21:43:16 <lambdabot>  3
21:43:35 <hunt> roboguy_ converted or changed signatures?
21:43:41 <ski> in OCaml, there's Camlp4/Camlp5 where we can actually extend the concrete syntax parser with new constructions, plus then translating the new AST nodes into old ones
21:43:55 <ski> s/the lists/the lisps/
21:44:12 <heatsink> I don't know how camlp4 works but it seems pretty powerful
21:44:31 <roboguy_> hunt: I think I just changed either double -> gldouble or gldouble -> double until it worked
21:44:34 <ski> (Dylan has macros inspired by the lisps, even though it doesn't use sexp-based concrete syntax. i should sometime check out how that works)
21:45:22 <haasn> andkore: you might like Agda though, which afaik has very little dependence on built-in types. I think the list syntax sugar actually uses whatever “type-that-looks-like-lists” is in scope, and iirc even numeric literals can use whatever “type-that-looks-like-peano-nats” is in scope! but I could be misremembering
21:49:28 <andkore> haasn: Thanks (again). Interesting stuff. It's a very minor issue, and like I said, it's probably a good tradeoff. I was just a tiny bit surprised, since to me Haskell seems very "correct"ly designed, and this seems like a case of trading a little "correctness" for convenience.
21:49:48 <haasn> andkore: there are far worse places in Haskell where correctness is dropped for convenience
21:49:56 <hunt> wbat do you guys suspect is the point of this line:     texImage2D Nothing NoProxy 0 RGBA' surfaceSize 0 pixelData |||| where you see nothing goes a TwoDimensionalTextureTarget, of which maybe is NOT an interface
21:50:12 <andkore> Dependent typing seems interesting. I'll have to look into that more... (re: Agda)
21:50:13 <hunt> how the hell am i going to unfuck this
21:50:46 <roboguy_> hunt: what's wrong with it?
21:51:28 <hunt> roboguy_ the nothing is supposed to be an instance of TwoDimensionalTextureTarget, but theres no instance for TwoDimensionalTextureTarget (Maybe a)
21:58:16 <roboguy_> hunt: maybe you could use one of the TextureTarget2D constructors
21:58:27 <roboguy_> unmaintained code can be a pain
21:58:56 <hunt> roboguy_ i replaced it with Texture2d, now im rewriting pretty much every Double to be a GLdouble. fun times!
22:01:22 <dmj`> hunt: what pkg is this?
22:02:56 <hunt> dmj` raincat, its a game. trying to get it to work on os x
22:04:16 * hackagebot lio 0.11.4.1 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.4.1 (DeianStefan)
22:04:18 * hackagebot lio-fs 0.0.1.2 - Labeled File System interface for LIO  http://hackage.haskell.org/package/lio-fs-0.0.1.2 (DeianStefan)
22:05:57 <hunt> is there an "isNothing" function or is == Nothing a fine option
22:06:13 <roboguy_> hunt: well, == Nothing depends on the Eq typeclass
22:06:16 <roboguy_> there is an isNothing funciton
22:06:32 <hunt> where is it?
22:06:36 <roboguy_> Data.Maybe
22:06:40 <hunt> ah ok
22:06:43 <hunt> thank
22:06:43 <hunt> u
22:07:08 <hunt> how old is this game anyways
22:08:18 <hunt> where is hGetLine
22:09:17 * hackagebot lio-simple 0.0.0.1 - LIO support for the Simple web framework  http://hackage.haskell.org/package/lio-simple-0.0.0.1 (DeianStefan)
22:11:09 <roboguy_> :hoogle hGetLine
22:11:15 <roboguy_> @hoogle hGetLine
22:11:16 <lambdabot> System.IO hGetLine :: Handle -> IO String
22:11:16 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
22:11:16 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
22:11:25 <roboguy_> hunt: ^
22:14:17 * hackagebot smtp-mail 0.1.4.5 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.5 (JasonHickner)
22:17:36 <hunt> roboguy_ ah cool
22:17:44 <hunt> what is the "\\" operator from?
22:17:49 <hunt> @hoogle (\\)
22:17:49 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
22:17:49 <lambdabot> Data.IntMap.Strict (\\) :: IntMap a -> IntMap b -> IntMap a
22:17:49 <lambdabot> Data.IntMap.Lazy (\\) :: IntMap a -> IntMap b -> IntMap a
22:18:54 <hunt> @hoogle ExitException
22:18:54 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
22:19:49 <roboguy_> hunt: I'm not sure if lambdabot has all the 7.8 stuff yet. this one does though (if you select 7.8 from the drop down) https://www.fpcomplete.com/hoogle
22:20:19 <hunt> roboguy_ is fpcomplete good? i saw it for the first time today
22:20:46 <roboguy_> hunt: I think it is. there's a bunch of different aspects to it though, so it partially depends on what you mean
22:21:18 <roboguy_> there's a collection of articles that people have written (and continue to write) in the "School of Haskell" section, for example
22:21:46 <hunt> :t forall
22:21:47 <lambdabot>     Not in scope: `forall'
22:21:47 <lambdabot>     Perhaps you meant `forAll' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
22:21:52 <hunt> :t forAll
22:21:53 <lambdabot> (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
22:22:13 <hunt> roboguy_ its kind of a haskell hub then
22:22:31 <roboguy_> hunt: sort of, yeah. they also have their own web-based haskell IDE
22:23:43 <hunt> roboguy_ wow thats awesome
22:23:52 <hunt> roboguy_ haskell feels like its picking up speed
22:23:59 <roboguy_> hunt: is the forall that you're looking for in a type signature?
22:24:05 <roboguy_> hunt: yeah, I think it is too
22:24:15 <roboguy_> it has a few nice web frameworks, which will help
22:24:24 <fly2web> filter null [[1,2,3],[],[3,4,5],[2,2],[],[],[]] ---> this is possible filter (not null) [[1,2,3],[],[3,4,5],[2,2],[],[],[]] --> this is not possible?
22:24:41 <roboguy_> fly2web: you want not . null
22:24:48 <hunt> roboguy_ im not sure, i think it might be a compiler function or something
22:24:54 <roboguy_> fly2web: not . null is the same as (\x -> not (null x))
22:25:07 <roboguy_> hunt: well, I mean, what makes you look for it?
22:25:15 <roboguy_> it can mean a few different things
22:25:21 <fly2web> thanks roboguy_
22:29:25 <zenkeku> Is there file similar to python's PEP 8 file for haskell?
22:29:47 <hunt> roboguy_ i thought it was a syntax magic operator so i got curious, have you seen it?
22:30:48 <roboguy_> hunt: well, like I said, it depends on the context. there are libraries that provide a function with that name. it also means something different in a type signature (the RankNTypes, ExistentialQuantification and ScopedTypeVariables all use a "forall" "keyword" in type signatures)
22:31:44 <hunt> roboguy_ oh yea i meant in a type signature
22:32:09 <roboguy_> hunt: then you probably want one of those extensions. they do different things
22:32:12 <hunt> so ive gotten rain cat to compile, but sdl is telling me it cant recognize the music format, for an mp3 i think
22:33:30 <jle`> not.null is calling the null method of the not object
22:34:00 <roboguy_> hunt: I think I converted it to a wav, haha
22:34:08 <hunt> omg lol
22:34:21 <roboguy_> and then rewrote part of the code to change the file extension
22:34:25 <roboguy_> jle`: ?
22:34:25 <joelteon> does it matter what order monad transformers are composed in?
22:34:29 <roboguy_> joelteon: yeah
22:34:36 <joelteon> why
22:34:37 <roboguy_> there is no IOT
22:34:38 <roboguy_> for one
22:35:07 <roboguy_> some things are a monad when composed one way but not the other. I don't know enough about it to give examples off the top of my head though
22:35:12 <joelteon> ok
22:35:45 <startling> [] is a good example.
22:35:51 <startling> sorry, ListT
22:36:30 <jle`> joelteon: you should sort of think of the semantics
22:36:32 <roboguy_> startling: isn't there a "good" ListT and a "bad" ListT?
22:36:55 <jle`> ErrorT/EitherT and WriterT are a good example
22:37:06 <jle`> if you compose it one way, you get just a Right/Left
22:37:24 <jle`> if you compose it another way, you get a log up until the point of the failure
22:37:46 <startling> roboguy_, I think pipes claims to provide a "correct implementation of ListT" but I've never cared enough to figure out what that means.
22:37:48 <jle`> you just have to think about what the runSomethings do
22:37:56 <jle`> startling: i think it has to do with strictness
22:38:30 <roboguy_> startling: I care because when you compose the "incorrect" ListT with some monads, you don't get a monad
22:38:44 <startling> roboguy_: yeah, but I've never wanted a ListT anyhow. :)
22:38:57 <roboguy_> startling: haha, actually neither have I. if I did, *then* I would care
22:39:02 <roboguy_> I should have said
22:39:14 <startling> yeah, agreed.
22:39:16 <startling> http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes.html#t:ListT
22:40:10 <roboguy_> I've thought about giving pipes a shot, but I haven't done much streaming IO stuff yet. once I work on a project like that, I think I'll give it a try
22:40:42 <startling> yeah, same here.
22:41:03 <startling> + having a more mature ecosystem could help.
22:43:20 <hunt> roboguy_ http://imgur.com/XyYDVpI WE DID IT!!
22:43:33 <roboguy_> hunt: nice!
22:43:34 <hunt> roboguy_ macs are made for hardcore gaming
22:43:38 <roboguy_> haha
22:48:22 <erisco> with sodium how can I set the value of a behaviour inside of a listen callback?
22:48:50 <erisco> the callback must return IO(), but the set function returns Reactive ()
22:54:56 <erisco> ah the type I can use is sync... Reactive a -> IO a, but it explicitly says that you cannot use sync inside of the listen callback
22:55:07 <erisco> and indeed if I try, the program behaves incorrectly at runtime
22:55:11 <fly2web> filter ((`mod` 3829) == 0) [100000, 99999..]  <---- this is not possible?
22:55:55 <erisco> fly2web, well that isn't quite how you eta-reduce the argument
22:56:18 <erisco> @pl \x -> (x `mod` 3829) == 0
22:56:18 <lambdabot> (0 ==) . (`mod` 3829)
22:56:30 <fly2web> thanks
23:00:06 <mniip> wait so one can write (`op`133) ?
23:01:22 <hunt> are there any semi-serious haskell games
23:01:25 <jle`> mniip: yes
23:01:29 <jle`> hunt: i'm writing an rts :)
23:01:34 <jle`> there's fraps
23:01:37 <ChongLi> jle`: oh yeah?
23:01:37 <no-n> > (`max`4) 5
23:01:38 <lambdabot>  5
23:01:38 <jle`> the quake-based fps
23:01:50 <jle`> mniip: yeah, people use it as a 'free' flip
23:01:51 <ChongLi> what libs are you using?
23:01:57 <jle`> ChongLi: i'm using netwire
23:02:07 <mniip> > (`map`[1,2,3]) (*4)
23:02:08 <ChongLi> what about graphics?
23:02:08 <lambdabot>  [4,8,12]
23:02:10 <ChongLi> lambdacube?
23:02:16 <hunt> jlejle` fraps?
23:02:24 <hunt> jle` i cant find anything about haskell fraps
23:02:39 <ChongLi> fraps is a tool for recording your screen during a video game
23:02:47 <hunt> ChongLi in haskell?
23:02:50 <ChongLi> no
23:02:51 <jle`> ChongLi: still figuring it out, i'm using generic backends for now so i swap between SDL and GLUT
23:02:53 <hunt> i know what it is
23:02:56 <jle`> hunt: sorry, i meant Frag
23:02:59 <jle`> http://www.haskell.org/haskellwiki/Frag
23:03:00 <hunt> i didnt think it was written in haskell
23:03:01 <hunt> ah
23:03:15 <jle`> ChongLi: actually right now
23:03:22 <jle`> i am seriously considering making an HTML5 frontend
23:03:32 <jle`> i have been working on a ghcjs websockets abstraction
23:03:32 <ChongLi> jle`: webgl or canvas?
23:03:56 <jle`> it's flexible, still working on the game logic for now with minimal stuff to test
23:04:08 <jle`> i am expecting webgl
23:04:12 <jle`> cause of its hardware accelerated stuff
23:04:18 <ChongLi> so are you writing a reusable game engine to handle the generic backends?
23:04:35 <hunt> @hoogle Data.HashTable
23:04:36 <lambdabot> Data.HashTable module Data.HashTable
23:04:36 <lambdabot> Data.HashTable data HashTable key val
23:04:36 <lambdabot> package hashtables
23:04:43 <jle`> ChongLi: 'reusable' for me for now :P  basically all of the interface to the graphics is abstracted
23:04:50 <jle`> and i've written multiple graphics backend adapters
23:05:01 <jle`> i've even written a gnuplot one so i can look at frame by frame animations
23:05:06 <ChongLi> nice
23:05:18 <hunt> jle` is it fast?
23:05:22 <jle`> it's mostly a playground for now but i hope to have a product i can show off to my friends
23:05:36 <jle`> hunt: it's not slow :)
23:05:49 <jle`> i haven't done any benchmarking
23:05:53 <ChongLi> do you mess around with the GC at all?
23:06:00 <ChongLi> deliberately trigger GC or something?
23:06:09 <jle`> ChongLi: most of what i have been doing now has been very high-level
23:06:25 <jle`> using the FRP abstractions
23:06:29 <jle`> i plan on benchmarking and optimizing later
23:06:34 <jle`> but so far it is decently performant
23:06:44 <luite> jle`: there's a game that stephen blackeath showed me a few days ago that uses sodium+webgl, there's some memleak somewhere though that i'll be trying to fix in the coming days
23:06:50 <luite> should make a decent example
23:06:58 <jle`> luite: hunt was looking for games
23:07:03 <luite> 2d platform game and 2d sodium game engine
23:07:06 <hunt> luite, how do end up with a mem leak in haskell
23:07:07 <jle`> nice though
23:07:09 <ChongLi> luite: nice
23:07:38 <luite> hunt: hehe that's pretty easy actually
23:07:53 <hunt> luite: sodium== event based?
23:08:06 <hunt> luite: seriously? how
23:08:07 <ChongLi> sodium is an FRP lib
23:08:08 <luite> hunt: not being strict enough in many cases, although here it might be some bug in the ghcjs rts that makes it hold on to more data than it should
23:08:58 <luite> hunt: i already changd/fixed a few things in ghcjs to make memory management more accurate, but i'll just need to investigate
23:09:22 <luite> hunt: well with frp you can easily accumulate thunks that get bigger and bigger with each incoming event, and never force thm
23:09:36 <hunt> @moogle hashable
23:09:37 <lambdabot> Maybe you meant: hoogle google
23:09:56 <hunt> @hoogle google
23:09:57 <lambdabot> Google rocks!
23:09:57 <lambdabot> package google-html5-slide
23:09:57 <lambdabot> package google-mail-filters
23:09:58 <ChongLi> Kupo!
23:10:33 <hunt> luite, are you the author of ghcjs?
23:10:49 <luite> hunt: yeah of most of the latest version at least
23:12:14 <LambdaFan> jekor: you in?
23:12:16 <hunt> @hoogle Data.HashTable
23:12:17 <lambdabot> Data.HashTable module Data.HashTable
23:12:17 <lambdabot> Data.HashTable data HashTable key val
23:12:17 <lambdabot> package hashtables
23:12:24 <Redz> is there a nicer way to describe  f xs = zip (concatMap (replicate (length xs)) xs) (cycle xs)
23:13:27 <hunt> luite, thats pretty rad, its probably going to be huge in a few months when haskel blows up
23:13:42 <hunt> where is HashTable for Frag
23:13:42 <apples`> Redz, f xs = (,) <$> xs <*> xs perhaps?
23:14:23 <jle`> when should i use -O2 for my libraries?
23:14:30 <jle`> hackage yells at me when I do
23:14:32 <jle`> but everyone seems to do it
23:14:43 <johnw> do it if you've proven that it helps
23:14:56 <jle`> johnw: aw you mean i have to actually benchmark
23:14:58 <johnw> a lot of time, it barely helps at all, but it makes compile time much worse
23:15:00 <jle`> :)
23:15:10 <Redz> thank you apples` . i completely forgot to check applicative lists. ;)
23:15:35 <johnw> if you don't want to brenchmark, that's fine, then don't add -O2 :)
23:15:57 <jle`> johnw: fair enough
23:16:05 <jle`> apples`: hello my fellow backtick
23:16:10 <apples`> heh, oops :)
23:16:30 <jle`> aw :(
23:16:33 * jle` is forever aline
23:16:35 <jle`> alone
23:20:10 <luite> hunt: i'm trying to fix as many bugs as possible before ghc 7.8 is out :)
23:21:30 <luite> hunt: unfortunately, sodium strains the memory manager pretty hard, with its heavy use of weak refs, so i'll probably need to do some more work to make this run smoothly
23:30:43 <LambdaFan> testing
23:30:50 <LambdaFan> weoird
23:32:55 <chas> I notice the Haskell Platform comes with a lot of cabal packages that are seriously out of date... for example, text-0.11.3.1... do people typically just blow all this away somehow?
23:59:30 * hackagebot hen 0.1.3 - Haskell bindings to Xen hypervisor interface  http://hackage.haskell.org/package/hen-0.1.3 (FedorGogolev)
