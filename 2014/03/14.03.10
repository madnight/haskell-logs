00:04:25 <ski> @type (=<<)
00:04:26 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:26:35 <joneshf-laptop> is it just me, or is there a whole mess of repetition?
01:27:03 <joneshf-laptop> like concatMap seems to be a specific version of (=<<)
01:27:06 <joneshf-laptop> :t concatMap
01:27:07 <lambdabot> (a -> [b]) -> [a] -> [b]
01:27:10 <joneshf-laptop> :t (=<<)
01:27:11 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:28:05 <ski> and `map',`fmap', yes
01:29:03 <joneshf-laptop> sequence and stuff
01:29:14 <joneshf-laptop> it seems like mostly list stuff
01:29:40 <joneshf-laptop> like most of the list functons are just specializations for more generic functions
01:29:42 <ski> @type Data.Traversable.sequence
01:29:43 <ski> @type Data.Traversable.sequenceA
01:29:43 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:29:44 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
01:29:57 <joneshf-laptop> is this an artifact of things not having the proper hierarchy initially?
01:30:03 <joneshf-laptop> or something else maybe?
01:30:24 <ski> in some cases, it's the other way around. the generalization came later
01:30:33 <notdan> @type Data.Foldable.foldMap
01:30:34 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:30:34 <joneshf-laptop> right
01:30:50 <notdan> also can be seen as a generalization of concatMap
01:30:54 <joneshf-laptop> but why do these specific versions stay around?
01:31:08 <ski> in case of `map' and `fmap', it's ostensibly for didactic reasons ?
01:31:53 <notdan> joneshf-laptop: in some cases it's useful that some functions stay monomorphic
01:32:05 <ski> pre-H98, iirc, `fmap' was named `map', and `mappend' was named `(++)' ?
01:32:12 <notdan> monomorphic functions don't have cryptic error messages, for example
01:32:27 <ski> in some cases it can be nicer to read a more specific name, yes
01:33:03 <ski> (i suppose the question then is to what extent to do that)
01:33:12 <joneshf-laptop> not to discount the validity of that, but surely theres a better reason than error messages
01:34:18 <pavonia> removing these functions would certainly break a lot of all Haskell code
01:34:45 <ski> generalizing would probably break less
01:34:45 <joneshf-laptop> notdan, are the monomorphic versions easier to work with when the type can't be resolved by inference for a polymorphic version or something
01:34:46 <joneshf-laptop> ?
01:35:20 <joneshf-laptop> how long has Traverable been around?
01:36:31 <ski> i don't recall exactly. not that many years, though
01:38:59 <joneshf-laptop> hmm
01:39:38 <joneshf-laptop> guess it takes fairly long to deprecate things
01:48:27 <jle`> i think that error messages was the main reason why map was turned to work on only lists
01:48:49 <jle`> imagine starting out haskell and having a type error when using map
01:48:55 <jle`> instaed of it being an error about Lists
01:48:58 <jle`> it was an error about Functor
01:49:00 <jle`> ?
01:51:14 <joneshf-laptop> taht assumes the error messages are comprehendable when starting out
01:52:04 <joneshf-laptop> as far as i can remember is they all said the same thing, "You messed up".
01:54:08 <certainty> i remember an error message that was surprisingly helpful. I had a typo in my code and used the wrong name for a function, the error suggested that I might have meant a function with another name (but with the same type), which was actually the case. That was nice :)
01:59:36 <augur> http://www.reddit.com/r/haskell/comments/2019i4/comments_wanted_alpha_conversion_and/
03:03:09 * hackagebot jwt 0.2.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.2.0 (StefanSaasen)
03:07:33 <prinsen> I have a big data type with a ToJSON instance. If I want another ToJSON instance that only includes limited information, do I use newtype?
03:11:00 <quicksilver> prinsen: Yes.
03:11:07 <quicksilver> prinsen: (that sounds like the most likely solution)
03:12:31 <cizra> What's the status with running Haskell on mobile phones? Last I heard, there is support for ARM in GHC (This means that
03:12:55 <cizra> ARM is now a fully supported target platform for GHC), quoted from http://www.mail-archive.com/haskell-cafe@haskell.org/msg99529.html. How easy or hard would it be to actually write an Android app?
03:13:19 <zipper> How come fmap is able to perform such operations as `fmap (+) (Just 3)` yet its signiture says that the first argument should be (a -> b) and not (a -> a -> a).
03:13:40 <zipper> *signature
03:13:54 <merijn> cizra: ARM is supported, but not as a tier 1 platform yet (it's tier 2, but it might move to tier 1 with 7.8?)
03:14:11 <erisco> zipper, in (a -> b) the 'b' gets inferred as (Num c) => (c -> c)
03:14:33 <Liskni_si> cizra: Not exactly relevant to your question, but I've been using ghci (as a fancy calculator) on both Nokia N900 and Samsung Galaxy S3 for quite some time without problems.
03:14:36 <merijn> cizra: I know people have build iPhone apps in haskell, but there is no streamlined workflow yet, I think? 7.8 should have better cross-compilation support, thus simplifying things, though
03:15:11 <merijn> zipper: Because "a -> a -> a" is the same as "a -> (a -> a)"
03:15:31 <cizra> Liskni_si: Relevant enough :-)
03:15:37 <merijn> zipper: And the "b" in fmap's "a -> b" can thus be "a -> a"
03:15:38 <cizra> merijn: Thanks a lot!
03:16:21 <makalu> does anyone know why Bryan O'Sullivan does math stuff (mwc-random, statistics, math-functions)? Does he work somewhere where it's needed?
03:16:25 <merijn> cizra: See also: http://www.haskell.org/haskellwiki/ARM
03:16:38 <merijn> makalu: He's at Facebook nowadays, so maybe?
03:16:46 <cizra> merijn: Saw that, it wasn't very informative, unfortunately.
03:17:03 <merijn> cizra: Might be better of asking around in #ghc or the mailing list when you get stuck
03:17:18 <merijn> cizra: A lot of information is just floating around in people's minds without being written down anywhere
03:17:20 <makalu> merijn: why does Facebook need those things?
03:18:06 <merijn> makalu: I dunno, I don't work at facebook :) I'm not even sure he developed them for facebook, maybe it's just development in his own time
03:18:36 <merijn> Although I can see plenty of uses for statistics at facebook
03:18:46 <makalu> those libraries have been useful in my work (I haven't used statistics yet though)
03:23:14 <zipper> I see
03:23:28 <merijn> :t fmap (+) (Just 1)
03:23:29 <lambdabot> Num a => Maybe (a -> a)
03:23:36 <merijn> :t (+) 1
03:23:37 <lambdabot> Num a => a -> a
03:24:08 <merijn> zipper: Remember that due to currying all functions in haskell are one argument functions (that potentially return functions)
03:29:51 <Guest58117> hello, i'm a haskell noob and i was wondering if someone could help why i cannot compose 'decode' and 'encode' together as it says it's missing type information
03:33:30 <merijn> Guest58117: Which encode and decode are you talking about?
03:33:59 <Guest58117> hi, from Data.Binary
03:34:18 <merijn> Guest58117: then the problem is most likely that it cannot infer the return type of decode anywhere
03:34:47 <Guest58117> yeah, but shouldn't it infer it though?
03:34:49 <merijn> Guest58117: Decode, like 'read' is polymorphic in the return value, i.e. the compiler decides which implementation of decode to use based on the type
03:35:07 <merijn> Guest58117: It should infer it, *if* you actually use the result of decode
03:35:21 <merijn> Guest58117: paste the code on lpaste.org?
03:35:53 <artyomkazak> Guest58117: are you just trying to use “encode . decode”?
03:36:15 <Guest58117> yeah
03:36:29 <Guest58117> ok, ill paste the code
03:36:35 <bahamas> is pattern matching possible on Map?
03:37:12 <merijn> bahamas: No, the constructors of Map are not exposed to prevent you from constructing invalid Maps (i.e. wrong ordering)
03:37:32 <artyomkazak> well, Haskell doesn't know what type use “in the middle”. Should it convert to Int and then back to ByteString, or to Maybe and then to ByteString, or..?
03:37:53 <artyomkazak> it can't look into what you're trying to decode and determine what type it is inside
03:38:33 <bahamas> merijn: ah, maps are ordered. thanks
03:39:05 <merijn> artyomkazak: If he composes "decode . encode" like he implied, that should work
03:39:30 <artyomkazak> merijn: I asked if it was “encode . decode” and ne said yes
03:39:36 <merijn> artyomkazak: ah
03:39:38 <Guest58117> http://lpaste.net/100950
03:39:47 <artyomkazak> ...kay
03:40:08 <merijn> Guest58117: How is it supposed to know which decode function to use?
03:41:21 <Guest58117> oh, there's more one decode? i thought it would call this one: http://hackage.haskell.org/package/binary-0.4.1/docs/src/Data-Binary.html#decode
03:41:24 <artyomkazak> :t decode . encode
03:41:25 <lambdabot> Not in scope: `decode'
03:41:25 <lambdabot> Not in scope: `encode'
03:41:38 <artyomkazak> :t Data.Binary.decode . Data.Binary.encode
03:41:39 <lambdabot> (Data.Binary.Binary c, Data.Binary.Binary a) => a -> c
03:42:13 <artyomkazak> Guest58117: see, it can potentially turn anything encodeable into anything else encodeable
03:42:27 <Guest58117> ahhh i see
03:42:32 <artyomkazak> so your `j` doesn't necessarily have to be Int
03:42:59 <artyomkazak> and then you're using `show` on it, which doesn't require it to be Int, and Haskell is confused again
03:43:34 <bahamas> I'm trying to do an exercise in lyah, which asks me to figure out how the instance of functor for Map is defined. this is my attempt and the error I get when I tried to load the file in ghci. http://lpaste.net/100952. can anyone tell me what I'm doing wrong?
03:43:46 <Guest58117> i guess i need to be more explicit with what package the 'decode' and 'encode' functions come from.... but i though it would know from my import statement at the top
03:44:03 <Guest58117> is there a encode/decode function in the prelude?
03:44:11 <artyomkazak> nope
03:44:15 <Fuuzetsu> bahamas: you imported Data.Map qualified as Map, so you need to refer to the type as Map.Map
03:45:08 <Fuuzetsu> oh, or maybe I'm just silly and didn't read properly; AFAIK the Map type constructor isn't exposed so you can't refer to it
03:45:32 <bahamas> Fuuzetsu: then there's no way to define an instance for Map, is it?
03:45:52 <bahamas> I mean, I would just have to guess, or recreate my own type that mimics Map
03:46:05 <quicksilver> Map isn't a data constructor.
03:46:13 <Fuuzetsu> bahamas: Well, you could use one of the predefined functions that lets you map over map but that'd effectively be using existing instance. Can you link to the exercise?
03:46:21 <quicksilver> so the syntax "fmap f (Map k)" is wrong.
03:46:35 <quicksilver> your idea looks corret
03:46:51 <bahamas> Fuuzetsu: that's all there is to it: "Try figuring out how Map k is made an instance of Functor by yourself!"
03:46:55 <quicksilver> but you need to remember that fromList/toList return maps of pairs
03:47:04 <quicksilver> and you only want to be changing the right-half of the pairs
03:47:14 <quicksilver> and you need to stop using (Map k) like that was a data constructor
03:47:15 <Fuuzetsu> bahamas: oh, well, you have the right idea ;)
03:47:16 <quicksilver> just call it 'm'
03:47:47 <quicksilver> for example fmap f m | Map.null m = Map.empty
03:48:42 <Guest58117> ok, thanks people for your help.. i am more clearer as to what my problem was.... cheers
03:48:51 <Guest58117> ;)
03:49:09 <bahamas> quicksilver: just to understand something. Map.Map is a type constructor that takes two variables, no?
03:49:22 <bahamas> Data.Map.Map I mean
03:49:39 <jle`> :k Map
03:49:40 <lambdabot>     Not in scope: type constructor or class `Map'
03:49:40 <lambdabot>     Perhaps you meant `M.Map' (imported from Data.Map)
03:49:43 <jle`> :k M.Map
03:49:44 <lambdabot> * -> * -> *
03:49:52 <bahamas> so yes
03:53:11 <quicksilver> bahamas: yes, and it's not a data constructor at all.
03:56:05 <bahamas> quicksilver: my assumption was that if Data.Map.Map is a type constructor that takes two arguments. (Data.Map.Map k) would apply the constructor to k and return a new type constructor
03:56:15 <bahamas> like (Either a) for example
03:57:19 <merijn> bahamas: Right
03:58:30 <bahamas> merijn: so what I tried wasn't working because the Map type constructor isn't exposed?
03:58:52 <merijn> bahamas: You seem to be confused
03:58:58 <merijn> bahamas: Map's type constructor is exposed
03:59:07 <merijn> Map's *data* constructors are not exposed
03:59:14 <merijn> So you can't pattern match on Map
03:59:18 <merijn> You can still doo
03:59:53 <bahamas> merijn: instance Functor (Map k) where is pattern matching?
04:00:07 <merijn> "instance Ord k => Functor (Map k) where fmap f map = {- use whatever functions that work on maps here -}"
04:00:10 <merijn> bahamas: No
04:00:20 <merijn> bahamas: Instances are defined for types
04:00:36 <merijn> Data.Map.Map is a type
04:00:47 <merijn> You don't know what it's constructors are, because they are hidden
04:06:05 <bahamas> merijn: ok, the lights are on. I realized the difference
04:06:25 <bahamas> instance Functor expects a type but fmap f expects a value
04:06:51 <bahamas> like in the case of (Either a), fmap matches for Right and Left
04:07:51 <quicksilver> bahamas: yes.
04:07:56 <quicksilver> bahamas: and you don't need to know the constructors
04:08:05 <bahamas> this is my final version http://lpaste.net/100952
04:08:06 <quicksilver> because, as you already worked out, you can do it all using fromList/toList
04:08:52 <quicksilver> bahamas: almost. That should give you an error on Map.fromList
04:09:07 <quicksilver> because you've thrown away the left halves of the pair
04:09:11 <quicksilver> the keys
04:09:41 <bahamas> quicksilver: yup. I understood that part. I was just confused because although we use the type in the instance definition, the functions match for values
04:10:25 <bahamas> quicksilver: ah, map (\(k,v) -> (k,f v)) list
04:11:08 <merijn> bahamas: Yeah
04:11:37 <bahamas> thanks for you help and patience, guys
04:14:26 <quicksilver> bahamas: it is confusing. From one perspective it is confusing that so many types *do* use the same name or syntax for types and values
04:14:48 <quicksilver> bahamas: it's quite common in a one-constructor type to use the same name for the constructor as the type
04:15:04 <quicksilver> and of course (Int,Bool) is the same syntax as (4,True)
04:15:19 <quicksilver> while [Int] is related to but not the sme as [3,4,5]
04:27:46 <bahamas> quicksilver: yeah, using the same name for types and data constructors is very confusing
04:36:04 <Kron> in Haskell, is quicksort still faster than mergesort?
04:36:22 <Kron> without using the ST monad and in-place sorting, I mean
04:37:56 <RichyB> It's not believed to be. The current implementation of Data.List.sort is a merge-sort.
04:38:55 <bahamas> does lyah take pull requests or something like that? I think some things could be better clarified
04:39:08 <Fuuzetsu> bahamas: no
04:39:23 <Kron> RichyB: thanks
04:39:29 <RichyB> Kron, nitpick: Quicksort isn't believed to be the fastest possible sort in quite a few places, though. A bunch of programming languages now use Timsort to sort mutable arrays.
04:39:39 <Kron> That's fascinating, I've never heard of it
04:39:47 <artyomkazak> Kron: and a rather cunning one, outperforming even vector-algoritms's mergesort *on vectors*
04:40:00 <Kron> could you point me at some information on timsort?
04:40:04 <artyomkazak> well, on semi-sorted vectors at least
04:40:06 <merijn> Kron: The main advantage of quicksort is fast because it's in place (saving space), but since Haskell is purely functional most updates require copying anyway, so in place isn't that interesting
04:40:30 <merijn> Kron: timsort is named after Tim Peters, a Python core programmer, so probably the python source should have more info
04:40:46 <RichyB> There's a pretty good wikipedia article on Timsort.
04:41:19 <Kron> I have a toy quadtree implementation I'm working on, and I want to be able to extract out all the elements of a (QuadTree a) in a large sorted sequence with some (a -> Ordering)
04:41:25 <quicksilver> in-place doesn't just save space, for quicksort; it also saves work, it's reasonably good at not moving elements which don't need to be moved in almost-sorted arrays
04:41:31 <Kron> at the moment my current implementation is to just implement a Foldable instance for my quadtree
04:41:34 <Kron> and sort . toList
04:41:35 <RichyB> It was invented with the specific goal of minimising the number of comparisons that get performed, the rationale being that the comparisons themselves involve doing some method dispatching in CPython, which makes them relatively expensive.
04:41:38 <Kron> is that a bad idea?
04:42:26 <julia> @help
04:42:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:42:33 <julia> @help pl
04:42:34 <lambdabot> pointless <expr>. Play with pointfree code.
04:42:48 <Kron> I really really like the non strict evaluation semantics behind haskell
04:43:00 <julia> @help list
04:43:01 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
04:43:04 <Kron> I've even worked on lisp a lot in the past, so the basic idea of functional programming is not that new to me
04:43:11 <julia> @list
04:43:12 <lambdabot> What module?  Try @listmodules for some ideas.
04:43:13 <Kron> but the consistent laziness makes everything so composable
04:43:27 <RichyB> Kron, that depends how fast you want/need your program to go. If you're happy with your toList taking O(n*log n) time, which isn't horrendous, then that might be alright for you, even if it's not the fastest conceivable algorithm for the purpose.
04:43:48 <Kron> I'm not sure if I can do better than O(n log n) anyway in raw scalability terms
04:44:02 <julia> @pretty fromMaybe (error errmsg) (find ((== _id) . feedId))
04:44:02 <lambdabot>  fromMaybe (error errmsg) (find ((== _id) . feedId))
04:44:16 <Kron> and at the moment I'm happy with just using the ostensibly highly optimized [a] sorting algorithm, until I can come up with a better one myself
04:44:26 <Kron> I guess some sort of 4-way mergesort using all the branches
04:44:29 <RichyB> (That said, I don't know what the performance difference between generate-and-sort and generate-in-sorted-order will be in practice for you. Take the above only as generic advice re: performance vs how much effort does the program take to write?)
04:45:11 <Kron> I just want to make sure I'm not making any significant cognitive errors
04:45:24 <Kron> designing my initial working code using composable Foldable functions
04:45:44 <Kron> thanks for your help!
05:01:18 <Kron> heh, is there a neater way of writing "go (go (go (go z d) c) b) a"?
05:01:51 <Kron> "go ?? a $ go ?? b $ go ?? c $ go ?? d"?
05:02:04 <Kron> well, with a z at the end I suppose
05:02:15 <Guest3683> go . go . (go z d) $ c b a ? not sure, I'm dead tired
05:02:36 <Guest3683> oh no that's wrong, nvm
05:02:54 <Kron> to be fair the go expression isn't that long or hard to read
05:03:01 <Kron> I'm just wondering if I'm missing some trivial composition pattern
05:03:10 <neurocyte> cizra, there are at least two Android apps available that are built with ghc that I know of.
05:03:29 <cleatoma> I'm a beginner and might be wrong, but it looks like a fold to me.
05:04:06 <neurocyte> cizra, there is very little support for calling the Android API though, so writing an Android app means a lot of FFI to JNI code.
05:04:13 <Guest3683> foldl go z [d, c, b, a]
05:04:20 <Guest3683> ?
05:04:30 <neurocyte> Which is quite possible, but not exactly what i would call *easy*.
05:04:57 <Guest3683> cleatoma: nice catch, foldl go z [d, c, b, a]
05:05:14 <Guest3683> Kron: ^
05:05:30 <Kron> hmmmm
05:05:34 <Kron> yeah I quite like that
05:05:36 <Kron> I'll use foldr
05:05:44 <Kron> but thanks!
05:06:02 <Kron> ironically, this was a part of quadtree folding code :P
05:06:05 <Kron> so I should've seen it coming
05:07:28 <cizra> neurocyte: I wonder what it'd take to unify the Android, iPhone and Windows Phone into a cross-platform mobile dev package?
05:12:13 <Kron> hmmmm
05:12:34 <Kron> while this does work as a foldl, is there any way to right-fold across a tree where each node has 4 subnodes?
05:21:26 <Kron> http://www.haskell.org/haskellwiki/Foldl_as_foldr
05:21:38 <Kron> I'm having great difficulty parsing how foldl can be written as a foldr o_o
05:21:46 <Kron> why is it taking 4 arguments?
05:22:52 <johnw> essentially you are using foldr to change : into lambdas, which when that is evaluated at the end, has the left-associativity of foldl
05:22:56 <merijn> Kron: It's rather tricky to see, the best way I think is to grab a pencil and perform substitution by hand to see what's going on
05:23:21 <Guest3683> Kron: diagram!
05:24:13 <Kron> hmmm
05:24:29 <Kron> if it just stacks lambdas I'm not sure if it's better than foldl in any efficiency estimates?
05:24:37 <johnw> no, it should be identical
05:25:02 <Kron> I'm just wondering if it's possible to make a steady right fold over a 4-branch quadtree without having to evaluate the whole tree before you can access a single element
05:25:22 <Kron> it's just... uncomposable to left fold the whole thing
05:25:38 <merijn> Kron: It depends on the order your fold should have
05:25:47 <Kron> hmm
05:26:17 <Kron> I'm trying to fold some function "fn" over a (Node a b c d) with some zero value z
05:26:30 <Kron> something like...     foldr fn (foldr fn (foldr fn (foldr fn z d) c) b) a
05:26:33 <Kron> will obviously work
05:26:35 <Kron> but it's a left fold
05:26:43 <Kron> and I can't process a right fold equivalent
05:26:47 <merijn> > foldr f z [a,b,c,d]
05:26:48 <lambdabot>  f a (f b (f c (f d z)))
05:27:10 <Kron> hmmmm
05:28:56 <Fuuzetsu> are there any resources on setting up benchmarking for Haskell programs/libs?
05:29:02 <yitz> Kron: a fold works over a list. something like Node a b c d is more like a tuple, with a fixed number of elements. you would apply the function to each of the elements manually for that.
05:29:07 <johnw> Fuuzetsu: criterion
05:29:17 <Fuuzetsu> I'll have a look
05:29:24 <johnw> in conjunction with cabal support for benchmark programs
05:29:49 <Kron> the difference ultimately being the zero element
05:29:51 <Kron> right?
05:30:00 <Kron> if it's a QuadTree a
05:30:06 <Kron> and the zero element is just some "a"
05:30:21 <merijn> Does criterion also make the raw source data available (or is that the main output and is the fancy HTML generated by an extra program?)
05:30:21 <Kron> then to make it a right fold I'll need to rephrase the zero element as a kind of virtual QuadTree
05:30:34 <merijn> Kron: Huh? No
05:30:37 <merijn> @src foldr
05:30:37 <lambdabot> foldr f z []     = z
05:30:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:30:47 <merijn> :t foldr
05:30:48 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:31:02 <Kron> :t foldl
05:31:03 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:31:03 <merijn> Kron: The type of 'f' is "a -> b -> b" and the type of zero is "b" too
05:31:18 <yitz> Kron: to fold over a tree, you flatten the tree into a list, and then fold over that list. see, for example, the Foldable instance for Data.Tree.
05:31:37 <merijn> Kron: The type of the zero is completely unrelated to the data structure you're folding over
05:31:54 <pyr> hi haskellites!
05:32:02 <Kron> hmmm
05:32:17 <pyr> I'm hitting a wall with Network.Protocol.NetSNMP
05:32:41 <Kron> but even looking at the lambdabot type signatures
05:32:44 <Kron> the functions are different
05:32:50 <Kron> it's a -> b -> b versus a -> b -> a
05:32:53 <merijn> Kron: Yes
05:33:01 <pyr> For some SNMP queries, I receive OIDs containing (Integer32 signed_value) where it should be unsigned
05:33:01 <merijn> Kron: Because foldl and foldr are different
05:33:06 <merijn> > foldr f z [a,b,c,d]
05:33:08 <lambdabot>  f a (f b (f c (f d z)))
05:33:13 <merijn> > foldl f z [a,b,c,d]
05:33:14 <lambdabot>  f (f (f (f z a) b) c) d
05:33:20 <pyr> comparing the output against an snmp walk yields the signed version of the unsigned value.
05:33:34 <Kron> can I see the Data.Tree implementation?
05:33:42 <pyr> I wonder if there's a way to swap it back to an unsigned value from haskell
05:33:58 <yitz> Kron: yes. it's in the containers library, on hackage.
05:34:13 <merijn> Kron: http://hackage.haskell.org/package/containers-0.5.4.0/docs/src/Data-Tree.html#Tree
05:34:15 <Kron> i'm not sure how to-
05:34:16 <Kron> oh thank you!
05:34:26 <merijn> Kron: The hackage docs have a "source" link on the right
05:34:57 <yitz> Kron: search for "instance Foldable"
05:35:04 <Kron> instance Foldable Tree where
05:35:05 <Kron>     foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts
05:35:07 <Kron> ...
05:35:08 <Kron> uh.
05:35:16 <Kron> this is a monoid fold of some sort?
05:35:25 <merijn> :t foldMap
05:35:26 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:35:49 <Kron> yeah this is even more confusing than the earlier foldr code
05:36:01 <merijn> Kron: Well, lets take a concrete example
05:36:08 <merijn> toList :: Tree a -> [a]
05:36:09 <dwat3r> hi guys,i have trouble installing ThreadScope , it says it misses ghc-events,however i installed it.
05:36:17 <yitz> merijn: sorry about that. didn't remember that the Foldable instance uses foldMap...
05:36:56 <merijn> Kron: Actually, my explanation probably won't clarify a lot I just realised :\
05:37:06 <Kron> Hmm :x
05:37:07 <Kron> okay
05:37:08 <merijn> Well, maybe, let's try
05:37:28 <troydm> how do i match a list that might have 2 or more elements ?
05:37:33 <troydm> with pattern matching
05:37:37 <Kron> (x:xs)
05:37:48 <merijn> Kron: "toList (Node x ts) = x : concatMap toList ts" (ts is a list of Node)
05:37:51 <troydm> [_,_,..] or something?
05:37:54 <Kron> I think the basic idea behind toList is just foldr (:) []
05:37:55 <Kron> right?
05:38:14 <Kron> hmm
05:38:17 <merijn> Kron: Right OR toList is "foldMap (:[])"
05:38:31 <Kron> oh,troydm: You'll have to match it one element at atime
05:38:42 <Kron> unlike Prolog haskell pattern matching is based on the type constructors
05:38:57 <Kron> a list only has two; empty and cons... [] and (thing:thing)
05:39:02 <troydm> Kron: ahh, ic
05:39:03 <Kron> so you'll have to pick out each element one by one
05:39:07 <merijn> "foldMap :: (a -> m) -> t a -> m" with (:[]) gives "a -> [a]" as type for "a -> [a]" which makes foldMap "(a -> [a]) -> t a -> [a]"
05:39:11 <Kron> I was confused cause I had some prolog experience too
05:39:56 <Kron> yeah merijn this is just confusing, I don't have all that much monoidal experience
05:40:01 <Kron> sorry!
05:40:05 <SLi> Hey, if there's a default implementation for a class function so that you can write just (say) instance ToJSON SomeType, is it somehow possible to write an implementation for that function that uses the default implementation? For example, only define a custom implementation for some values of a disjunctive type?
05:40:17 <Kron> I'll try staring at the lambda expansions until I get it
05:40:57 <merijn> Kron: Yeah, if it's any consolation everyone is really confused by fold at the start and it's mostly a matter of 1) meditate on types 2) manual substitution on paper 3) repeat 1 and 2 until enlightenment
05:41:05 <supki> troydm: (x:y:ys)
05:41:18 <troydm> supki: yeah i've figured it :)
05:41:36 <Kron> oh
05:41:40 <Kron> : is right associative?
05:41:43 <Kron> ... I didn't know that
05:42:14 <Kron> in retrospect I should've at least come up with (x:(y:z))
05:42:15 <merijn> Kron: There's an easy way to check, use ":info" (or :i for short) in ghci
05:42:35 <Fuuzetsu> SLi: I don't think so.
05:42:38 <Kron> it's more that I forgot that type constructors count as functions and operators with all associated rules
05:42:40 <SLi> Fuuzetsu: ok.
05:42:50 <merijn> Kron: That prints the fixity of operators (unfortunately it leaves it out if the fixity is default, so you just need to remember that default fixity is infixl 9)
05:42:52 <Kron> the fact that (:) could even /have/ an associativity was what was lost to me
05:42:53 <Fuuzetsu> (it took me a while to understand what you're asking)
05:43:04 <byorgey> Kron: =)
05:43:12 <merijn> Kron: Fun fact, even infix use of normal function can have fixity!
05:43:19 <merijn> Kron: i.e. "infixl 4 `elem`"
05:43:52 <byorgey> elem is infix, not infixl =)
05:43:59 <merijn> Whatever >.>
05:44:04 <merijn> I was guessing from memory
05:44:20 <byorgey> in that case, I'm impressed you got the 4 right.
05:44:29 <neurocyte> cizra, do you mean something that would take one source tree and build packages for all three mobile targets?
05:44:36 <merijn> byorgey: So am I :)
05:45:06 <byorgey> > (5 `elem` [1..10]) `elem` [False]   -- it's too bad, really, because it would be so nice to be able to write this without parens ;)
05:45:08 <lambdabot>  False
05:45:31 <neurocyte> cizra, that probably possible, at least for apps that mostly use cross platform apis like opengl es. But you would have to write quite a lot of api wrapping code.
05:46:14 <neurocyte> and the end result would be a lowest-common-denominator type app
05:46:28 <neurocyte> which is not usually that great
05:48:18 <ski> byorgey : doesn't seem to be a particularly strong case for left-associativity
05:49:14 * byorgey feigns surprise and indignation
05:49:53 * ski makes a case for comparative operator precedence to be transitive
05:51:07 <Kron> anyway, thanks for all your help, gtg now
05:52:12 <ski> Kron : i don't think it makes that much sense to think about "right-fold" for trees
05:52:27 <ski> for it to make sense, you have to select a traversal ordering
05:55:48 <dropdrive> How might I express via types that a vector of integers is sorted, so that, say, I know it's okay to do binary search, or sorting should be a no-op, etc.?  Do I make a new type?
05:56:36 <johnw> if you just want to "tag" the value as sorted, with no proof that it is so, then a newtype is fine
05:57:00 <johnw> if you want the compiler to prove it, you'll need a fair bit of fancy machinery
05:57:14 <dropdrive> johnw: Thanks, no, no proof necessary.
05:57:21 <johnw> i wonder even if singletons is up to that sort of proof...
05:57:22 <ski> dropdrive : the only way to do it without dependent types is to do an abstract data type, i think
05:57:28 <merijn> johnw: Or just newtype with a smart constructor of "MyNewtype . sort" :p
05:57:37 <johnw> merijn: true!
05:58:16 <ski> it would be nice if one could export constructors for matching, but not for constructing
05:58:17 <merijn> GHC sort is optimised for order subsequences so "sort xs" where xs is sorted should be only O(n)
05:58:23 <ski> OCaml has that as an extension
05:58:41 <ski> that would simplify simulating subtypes via abstract data types
05:58:41 <merijn> ski: Won't the new view patterns allow you to do something similar?
05:58:47 <Walther> Hm, any hakyll users around? I'm wondering if it would be possible / sane to offer a site as html generated from the markdown at domain.tld/page and offer all the original markdown files at plain.domain.tld/page
05:58:48 <johnw> ski: file a GHC ticket
05:59:06 <Walther> (for all values of "page", ofc.)
05:59:18 <merijn> Walther: I'm doing something similar for my literate haskell source, so yes
05:59:23 <ski> merijn : i don't think you get exhaustiveness and non-dead-case checking with that ?
05:59:37 <merijn> ski: Mayhaps
06:00:11 <ski> (s/non-dead/unreachable/, i suppose i should say)
06:00:30 <merijn> Walther: The way I do it is just use the fileCopy compiler to copy the source straight to a different target directory in your case you'd want an additional in your webserver that maps plain.domain.tld/page to that new directory instead of the "standard" directory for page
06:00:36 <cizra> neurocyte: OK, thanks for the info
06:01:11 <merijn> Walther: So this is more of a webserver config issue than a Hakyll issue :)
06:01:25 <Walther> merijn: ha, fileCopy compiler is the thing i was looking for. Of course, the rest is just apache/whatever.
06:03:30 * hackagebot cantor 0.2 - Analiza Java source code  http://hackage.haskell.org/package/cantor-0.2 (klangner)
06:06:04 <Fuuzetsu> how can I splice in some stuff using CPP into an expression? I can do stuff like #if __GLASGOW_HASKELL__… and put stuff under it but I can't do something like main = putStrLn $ "This is " ++ __GLASGOW_HASKELL__
06:06:34 <beaky> hello
06:06:40 <johnw> beaky!
06:06:42 <beaky> i am building haskell and i iget this error: /tmp/ghc32219_0/ghc32219_0.lm_s: openBinaryFile: does not exist (No such file or directory)
06:07:21 <merijn> Fuuzetsu: You can, but __GLASGOW_HASKELL__ might be lacking quotes and thus causing a type error?
06:07:48 <Fuuzetsu> yes, type error is the problem; OH!
06:07:53 <Fuuzetsu> Okay, I see what's happening ;P
06:08:01 * ski thinks there's some way to "stringify" stuff in CPP ?
06:08:11 <merijn> ski: Yeah, I think so, but I forget
06:08:11 <mniip> #
06:08:15 <johnw> ski: I wish
06:08:15 <beaky> im building final stage of haskell
06:08:20 <vlatkoB> I have a computation run with runReaderT which downloads files from a list, but it is not lazy.
06:08:20 <vlatkoB> Can it be lazy?
06:08:28 <johnw> ski: #foo doesn't work in GHC
06:08:31 <mniip> #define stringize(x) #x
06:08:43 <Fuuzetsu> “Compiler version is __GLASGOW_HASKELL__” … that's not what I wanted after all ;P
06:08:54 <Twey> vlatkoB: It involves side effects, so while it can be lazy, it probably shouldn't be
06:08:55 <mniip> But that's cpp
06:09:07 <Twey> vlatkoB: You could use pipes instead, though
06:09:31 <merijn> johnw, Fuuzetsu: https://stackoverflow.com/questions/6852920/how-do-i-turn-a-macro-into-a-string-using-cpp
06:09:38 <vlatkoB> I'm just trying to take a few from the list, but it does the full list first before it come to 'take'
06:10:11 <vlatkoB> yeshuah, I know for pipes, but I'd like to see what can be done here.
06:10:26 <merijn> vlatkoB: unsafeInterleaveIO, but beware of dragons
06:11:10 <Fuuzetsu> merijn: that gives parse error on #
06:11:25 <merijn> Fuuzetsu: Then GHC is bollockins the CPP :)
06:11:28 <vlatkoB> so, none RWS transformer can't be lazy if there are side effects?
06:11:45 <johnw> I went on a long journey once to enable token pasting with CPP
06:11:47 <merijn> vlatkoB: Not without use of unsafe* functions, no
06:11:49 <Fuuzetsu> merijn: uh, I just wanted to know the value of the token ;_;
06:11:56 <johnw> it is actually documented in an old article that it's not supported
06:12:25 <Twey> I don't understand how it's not supported
06:12:33 <vlatkoB> merijn: thanks
06:12:47 <johnw> http://www.lochan.org/keith/publications/hspp-hw99.ps.gz‎
06:12:52 <johnw> this document talks about the limitations
06:12:55 <merijn> vlatkoB: Hence why those unsafe things exist :)
06:13:02 <Fuuzetsu> that's very disappointing
06:13:03 <Twey> vlatkoB: The problem is not the RWS, it's the IO involved in downloading files
06:13:53 <Twey> vlatkoB: You can take just a few things from the list and download them (mapM download . take aFew), but I feel that's not what you're asking for
06:14:04 <johnw> Fuuzetsu: tell me about it
06:14:13 * Fuuzetsu tells johnw about it
06:14:21 <Twey> The correct solution to ‘how can I download only the bits that I need, when I need them?’ is pipes
06:14:32 <Fuuzetsu> or perhaps I should have used @tell johnw it
06:14:36 <johnw> Fuuzetsu: there are other weird little limitations too
06:14:51 <johnw> the last time I tried to use CPP in any serious way (as I might have with C++ code), I finally gave up
06:14:52 <vlatkoB> Twey: no, it's actually some testing and don't want to wait for all the downloads. :-)
06:15:13 <Fuuzetsu> Sounds sub-par. Wasn't carter working on something to do with CPP? carter, does your work encompass any of this?
06:16:06 <merijn> Why doesn't GHC just ship its own CPP? Shouldn't be that hard to implement and we'd have avoided this OSX 10.9 mess
06:16:09 <johnw> Fuuzetsu: I suppose you could always use the pgmF flag to use the real cpp as a program formatter
06:16:24 <Twey> merijn: Or it could just make use of TH instead.
06:16:47 <merijn> Twey: Seems very inconvenient for things like ifdef'ing versions
06:17:04 <Fuuzetsu> johnw: I don't care that much, for this particular purpose #if __GLASGOW_HASKELL__ == 709 will do just fine, I was just wondering how to splice in the compiler version this way
06:17:15 <Twey> merijn: Shouldn't be hard to define a helper function, surely?
06:17:26 <Fuuzetsu> famous last words
06:17:29 <Twey> Heheh
06:17:47 <merijn> Twey: Are you volunteering to implement that stuff? :p
06:18:03 <Fuuzetsu> merijn: I think carter is doing something with it, pester him
06:18:04 <Twey> ifDef "GLASGOW_HASKELL" [| import Data.Foo |] [| import Foo |]
06:18:06 <merijn> Twey: Also, consider a lot of community stuff currently relies on CPP so it'll be years before it can be phased out, if at all
06:18:14 <Twey> Yeah, that's true
06:18:45 <merijn> Does TH have a way to access line/column number?
06:19:16 <bennofs> merijn: I think it does, monad-logger uses it I think
06:19:34 <merijn> oh, that's cool, I really should learn TH better at some point
06:19:36 <bennofs> let me check
06:19:46 <donri> It does
06:19:56 <bennofs> qLocation
06:20:30 <bennofs> http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH-Syntax.html#v:qLocation
06:20:33 <beaky> how do i fix this error: /tmp/ghc5491_0/ghc5491_0.lm_s: openBinaryFile: does not exist (No such file or directory)
06:20:42 <donri> There's even a package mimicking CPP constants with TH
06:22:16 <donri> $__FILE__ :)
06:26:14 <eacameron> I don't understand why this is acting so strict, it runs "f" on all "as" even though I'm calling "safeHead" on it: "first f as = (safeHead . catMaybes) <$> mapM f as"
06:26:51 <merijn> eacameron: Because mapM is strict?
06:27:07 <eacameron> merijn: it is?
06:27:18 <merijn> eacameron: mapM f will first evaluate f for ALL entries, THEN you fmap safeHead over things
06:27:34 <merijn> eacameron: Yes, "mapM f" is just "sequence . map f"
06:27:45 <merijn> In fact, that's the entire point of mapM :)
06:27:50 <merijn> eacameron: If you want lazy loops
06:27:54 <merijn> @hackage monad-loops
06:27:54 <lambdabot> http://hackage.haskell.org/package/monad-loops
06:27:54 <eacameron> merijn: but why is it stict?
06:28:09 <Philonous> I'm surprised and confused that I can use overloaded strings in patterns. Isn't "foobar" supposed to be (fromString "foobar") ?
06:29:13 <eacameron> merijn: haha....that's great! monad-loops has "firstM" which is almost what I'm trying to do
06:31:17 <spacekitteh> is there a type level "nat" corresponding to infinity?
06:31:34 <spacekitteh> by which i mean x < infinity for all x
06:32:08 <merijn> spacekitteh: Do you want "infinifty < infinity" to hold?
06:32:17 <spacekitteh> i don't really mind
06:32:20 <merijn> spacekitteh: You can trivial define a type family for that then
06:32:41 <Philonous> Never mind, the ghc documentation cleared it up. It's still surprising.
06:32:54 <spacekitteh> merijn: i don't even know what a type family is :I
06:33:33 <merijn> spacekitteh: Ah, you might wanna read up on those first if you plan to muck around on the type level with things like nat then :)
06:33:45 <merijn> spacekitteh: I recommend the "Fun with Type Functions" paper
06:33:55 <fizbin> I seem to remember that there's a language extension to do what I want, but can't remember what it is:
06:34:03 <merijn> spacekitteh: Essentially type families are type level functions
06:34:16 <spacekitteh> merijn: yeah, i'm reading up on them now. i'm trying to create a n-dimensional vector type where n is stored in the type
06:34:30 <eacameron> so sequence being strict is news to me, but I'm guessing there's good reason for it?
06:34:34 <merijn> spacekitteh: Fun with Type Functions has a bunch of neat example applications for them
06:34:43 <spacekitteh> oh cool
06:34:47 <merijn> spacekitteh: And my personal favorite example is: https://gist.github.com/merijn/6130082
06:35:13 <haasn> I tried infinity = 1 + infinity but GHC isn't smart enough to handle that
06:35:17 <haasn> oh well :(
06:35:21 <ski> johnw : ok
06:35:27 <spacekitteh> merijn: as is the list of disallowed types?
06:35:48 <fizbin> I have a signature for the whole function that includes unbound variables, something like: fooeyInt :: (Foo f) => Int -> f Int.  In the "where" bit underneath that, I want to refer to "f" and have it mean the same "f" as in the top-level signature.
06:35:49 <merijn> spacekitteh: Yeah
06:35:54 <spacekitteh> woah
06:35:58 <fizbin> What language extension is that?
06:36:09 <merijn> fizbin: ScopedTypeVariables
06:36:20 <fizbin> merijn: Thanks.
06:36:28 <merijn> fizbin: Requires an explicit "fooeyInt :: forall f . (Foo f) => Int -> f Int"
06:36:32 <ski> fizbin : you used to be able to use `PatternSignatures'. now only what merijn said works, you need to say `forall f.' in the signature
06:36:46 <merijn> Since it only scopes explicitly mentioned variables
06:36:59 <fizbin> Why doesn't PatternSignatures work anymore?
06:37:05 * ski thinks this is backwords
06:37:14 <spacekitteh> merijn: i started creating my library a month or so ago and was teaching myself haskell at the same time. i have to change so much now to incorporate this i think >.<
06:37:37 <haasn> what happened to the injective TF ghc had for Nats?
06:37:42 <merijn> spacekitteh: I wouldn't worry, you can't learn all cool advanced tricks at once :)
06:37:43 <ski> fizbin : for some reason, `ScopedTypeVariables' was deemed to superset `PatternSignatures' or something like that
06:37:44 <haasn> Did they remove that?
06:37:50 * ski would like `PatternSignatures' back
06:37:55 <merijn> haasn: There is a builtin Nat kind now
06:38:18 <merijn> haasn: Part of DataKinds, together with the Symbol kind for type level strings
06:38:22 <c_wraith> merijn: but no injective type families for them
06:38:36 <haasn> merijn: yes, those have been around for a while
06:38:51 <merijn> c_wraith: I always get confused what injective means in this context, so I dunno
06:39:11 <haasn> merijn: but in GHC 7.7 I remember there being an injective TF that you can use to pattern match against them
06:39:32 <c_wraith> merijn: GHC doesn't know that n + 1 ~ m + 1 => n ~ m
06:39:42 <merijn> Right
06:40:12 <merijn> injective is that the input to output mapping is unique, no?
06:40:41 <merijn> Actually, hmm, I'm confused what that sentence even means :p
06:40:44 <bennofs> merijn: no, I think that means that the output to input mapping is unique too
06:40:47 <merijn> Lemme rethink what I meant
06:40:57 <ski> `f' being injective means `forall y. exists_at_most_one x. y = f x'
06:41:13 <ski> `f' being surjective means `forall y. exists_at_least_one x. y = f x'
06:41:27 <merijn> ski: Right
06:42:08 <c_wraith> GHC 7.10 is supposed to have a solver that can know these sorts of things about Nat.  Do we know what it's based on, so we can know what its limits are going to be?
06:43:38 <b0bbi10> hey, just wanna say that Haskell is so weird, I have to read every chapter in LYAH several times before understanding what is going on :/
06:43:41 <thoughtpolice> haasn: I believe most of what you're referring to was pushed out of 'base' and into separate libraries, 7.8 features some new type-level programming APIs, but a lot of it was under revision a few months ago
06:44:06 <ski> b0bbi10 : that's because you're learning new things, not just learning new syntax for old things
06:44:09 <pjdelport> b0bbi10: It's good to stretch your brain.
06:44:28 <thoughtpolice> haasn: i'm not exactly sure what the current status is i'm afraid. Richard Eisenberg and Gabor Lehel probably know the exact details, you can always email ghc-devs and ask.
06:44:32 <Twey> ski, fizbin: The functionality of PatternSignatures is still there.  It just comes as part of ScopedTypeVariables now.
06:44:36 <spacekitteh> b0bbi10: stretching your brain will reduce the chances of dementia and alzheimers in later life
06:44:46 <spacekitteh> b0bbi10: so in a very real sense, learning haskell is healthy :)
06:44:52 <thoughtpolice> c_wraith: the new implementation is not merged yet, and Iavor has not written down a complete design for the improved solver yet
06:45:15 <tdammers> spacekitteh: of course, getting rid of the tv alone leads to a huge leap in quality of life
06:45:21 <b0bbi10> wondering if people are confused when their first programming language would be Haskell
06:45:34 <tdammers> b0bbi10: confused; no. disgusted; yes.
06:45:36 <spacekitteh> b0bbi10: if they are coming from mathematics, probably not
06:45:37 <thoughtpolice> c_wraith: i imagine he'll get around to it sometime in the next coming months. the feature is pretty well-desired now that there's some basic evaluation going on, so i'm sure there will be plenty of discussion about the design and whatnot.
06:45:38 <fizbin> Crud. I can't get this to compile even with ScopedTypeVariables. Okay, abandoning generic type approach...
06:45:44 <haasn> b0bbi10: probably less confused than when coming from other languages
06:45:52 <Guest6961> b0bbi10: my uni is teaching haskell as first programming language and I can confirm that lots of people get confused
06:45:56 <c_wraith> thoughtpolice: ok.  I dream of someday being able to write an Eq instance for a recursive type with its size as part of the type. :)
06:46:15 <thoughtpolice> (and i'm sure the email thread on ghc-devs will be gigantic with some bikeshedding sprinkled on top ;P)
06:46:26 <haasn> Guest6961: to be fair, my uni is teaching java as first programming language and I can confirm that lots of people get confused
06:46:30 <c_wraith> thoughtpolice: (well, without unsafeCoerce, which I do know to be perfectly safe in this case, so I *could* write the instance)
06:46:48 <thoughtpolice> c_wraith: right, unsafeCoerce is never really satisfying :)
06:47:05 <Guest6961> haasn: haha then I guess it's programming in general that confuses people (though we have java this semester and people seem to understand better than haskell)
06:47:06 <b0bbi10> OOP and imperative programming are more 'natural' than functional programming
06:47:17 <Fuuzetsu> satisfyinglyUnsafeCoerce
06:47:23 <merijn> b0bbi10: I disagree, even though I leanred both OOP and imperative first
06:47:23 <Twey> ski, fizbin: I think it's because PatternSignatures introduce a scoped type variable
06:47:33 <c_wraith> b0bbi10: what definition of "natural" are you using?  "what I'm familiar with"?
06:47:34 <ski> Twey : yes, but i want to be able to use the former without the latter
06:47:43 <b0bbi10> I hope I got the discipline struggle with Haskell more than a week ;D
06:48:02 <Twey> ski: Why would you ever want to not use ScopedTypeVariables?  :þ
06:48:04 <ski> Twey : also i want to be able to use result type ascriptions, as one used to be able to
06:48:14 <ski> Twey : because it's completely backwards ?
06:48:18 <b0bbi10> c_wraith: yeah, and 'how things are in reality'
06:48:24 <Twey> ski: Backwards?
06:48:27 <ski> yes
06:48:38 <Twey> Scoping type variables seems like a good thing to me
06:48:54 <ski> if i say `foo :: forall a. ..a..', then i expect this `a' to be in scope *only* in that `..a..' part of the type, not anywhere else
06:48:58 <Twey> If anything, my main complaint is that you have to use a ∀ to enable it, rather than having it on by default
06:49:12 <Twey> Hm
06:49:16 <tdammers> Guest6961: java doesn't make programming easier to understand, it just dumbs it down so you can get away without properly understanding stuff
06:49:22 <ski> it seems very weird that there should be an exception to this, in case the `forall' is on the top-level of the signature
06:49:36 <Guest6961> tdammers: couldn't agree more
06:50:03 <Guest6961> tdammers: like PHP / javascript in a slightly better way
06:50:06 <ski> if anything, i'd want `a' to be in scope in the body *only* if i instead said `foo :: ..a..' (and used `ScopedTypeVariables', of course), with *no* explicit quantifier on `a'
06:50:07 <tdammers> Guest6961: and IMO, the conclusion that java is easier and should therefor be used to teach programming is a dangerous one
06:50:16 <ski> because then i could interpret this as really being
06:50:17 <ski>   forall a.
06:50:22 <ski>     foo :: ..a..
06:50:26 <ski>     foo = ..a..
06:50:28 <tdammers> Guest6961: not really, no. Also PHP is wrong on an entirely different plane of existence
06:50:37 <tdammers> Javascript isn't so bad. But PHP really is.
06:50:39 <Twey> ski: I guess there should at least be an exception for (∀ a. …a…), with the type explicitly bracketed
06:50:59 <Guest6961> tdammers: I mean that in both you can get away with adding integers to strings etc
06:51:22 <beaky> I am compiling teh glorious glasgow haskell compilation system for armv6 on my armv6 platform (raspberry pi model b rev. 2) with 512MB of RAM and 8GiB of SD storage and on the final bootstrap stage I am facing the following error message: /tmp/ghc32219_0/ghc32219_0.lm_s: openBinaryFile: does not exist (No such file or directory). Rebooting or running does not resolve my issue nor does swapping my RAM. Here is the build log: http://lpaste.net/100957
06:51:41 <c_wraith> b0bbi10: Honestly, if you think that OO and functional are opposites, you're not looking closely enough. They're almost entirely orthogonal. What makes Haskell great isn't that it's functional. Being functional is more or less a side note. What's important is the type system and purity.
06:51:43 <beaky> maybe i need to edit some code in the compiler or build scirpt?
06:52:16 <Fuuzetsu> beaky: I doubt you can compiler GHC with 512MB. In fact, I'm pretty sure there were like 20 people asking the same thing on this channel in the past.
06:52:17 <thoughtpolice> beaky: hm, oh wow. so the reason that's happening is because you actually seem to have triggered a segfault in LLVM!
06:52:18 <Twey> c_wraith: You don't consider purity an aspect of being functional?
06:52:20 <tdammers> Guest6961: isn't that true for every unityped language, really?
06:52:22 <thoughtpolice> (yay for C++)
06:52:29 <Fuuzetsu> thoughtpolice: C++ the greatest
06:52:33 <thoughtpolice> Fuuzetsu: it's possible, with swap. but it takes days on an RPi, IIRC
06:52:40 * Fuuzetsu had a Python program segfault last night
06:52:42 <beaky> Fuuzetsu: it took me a day to compile :(
06:52:43 <thoughtpolice> (literally like 2-3, I think someone reported)
06:52:45 <ski> Twey : there's also the fact that the type signature, if any, can be separated from the definition of the operation, and can even be a shared type signature for a sequence of operations with a common type
06:53:00 <Twey> tdammers: For some version of ‘let’.  E.G. Python will allow you to run a program that does that, but if you actually hit the operation it will throw an error.
06:53:08 <Guest6961> tdammers: it is and that's why they are somewhat easier to grasp. Java also does some implicit conversions
06:53:16 <b0bbi10> c_wraith: Java has a type system, too (don't know for purity though...)
06:53:39 <Guest6961> tdammers: but I completely agree with what you are saying on java and javascript
06:53:41 <Twey> ski: All that you say is true.  But I would still rather have scoped type variable behaviour than not, no matter the syntax
06:53:45 <haasn> b0bbi10: last time I checked reality has about as little to do with objects, inheritance and message passing as it does with functions, ADTs and static type systems. I'm not sure where that argument tend to comes from
06:53:52 <c_wraith> b0bbi10: java's type system is kind of like a bad joke compared to haskell.  What matters isn't "having a type system".  What matters is "what the type system can do for you".
06:53:54 <b0bbi10> c_wraith: I don't really think of OOP and FP as opposites since I don't really know what the opposite of each other is :(
06:54:19 <beaky> i love lambdas
06:54:20 <tdammers> Guest6961: they are not easier to grasp. You *think* you grasp them, but really you're only riding their lies. It takes much longer to realize that you have been programming in a world of make-believe, carefully hiding the truth from you, until the abstraction leaks and bites you in the face.
06:54:32 <thoughtpolice> beaky: so yeah, that's a pretty nasty one that you're probably not going to be able to easily fix yourself. can you do me a favor and report this as a bug? https://ghc.haskell.org/trac/ghc/newticket?type=bug
06:54:45 <thoughtpolice> you can use the login 'guest/guest' for a username/password, if you do not want to register
06:54:55 <Fuuzetsu> beaky: don't we all λ♥
06:55:06 <tdammers> haasn: objects look a bit like entities in a corporate setting to a naive observer
06:55:10 <ski> b0bbi10 : programming is only partly concerned with reality
06:55:14 <tdammers> haasn: that's why corporate management types love them so much
06:55:15 <Fuuzetsu> I wonder if ♥ is a valid variable name
06:55:18 <c_wraith> Twey: Not at all.  Of course, the problem is that "functional" is ill-defined.  But I read it as "functions are first-class values", with no further implication.  In particular, I don't think it implies any properties about functions being mathematical functions.
06:55:20 <thoughtpolice> please just include: your OS, the GHC version you are bootstrapping with (i.e. the one installed from the RPi package repos, just 'ghc --version'), and the LLVM version
06:55:25 <thoughtpolice> beaky: ^^
06:55:38 <beaky> wow so its a legitimate bug?
06:55:46 <Fuuzetsu> gasp!
06:55:48 <thoughtpolice> beaky: oh, and a copy of the thing you put on lpaste
06:55:53 <thoughtpolice> beaky: correct
06:55:54 <beaky> "TICKET_CREATE privileges are required to perform this operation. You don't have the required permissions."
06:55:59 <beaky> maybe its a bug with llvm
06:55:59 <tdammers> c_wraith: "functional" means more than just "first-class functions" - it means "functions as in mathematical functions, as much as possible"
06:56:07 <thoughtpolice> beaky: right, login with 'guest' and 'guest'
06:56:09 <tdammers> purity is an important aspect of this
06:56:09 <thoughtpolice> or you can register
06:56:13 <Twey> c_wraith: Alright; that's a consistent definition, I suppose
06:56:18 <beaky> maybe i should try building the latest llvm first
06:56:26 <tdammers> C has first-class functions.
06:56:29 <thoughtpolice> beaky: if you could, that would be great too. maybe they already fixed
06:56:30 <thoughtpolice> it
06:56:34 <c_wraith> tdammers: not if you ask a lisp programmer.  Or a scala programmer.  Or an Erlang programmer.  Or basically any language other than Haskell.
06:56:39 <osfameron> some people do use the phrase "purely functional programming" which does suggest that function doesn't imply purity...
06:56:46 <thoughtpolice> beaky: note that the problem is probably an upstream LLVM bug. but it's probably worth us to keep track of
06:56:54 <beaky> right
06:56:57 <merijn> Fuuzetsu: Only one way to test :p
06:57:03 <tdammers> c_wraith: well, languages differ in how far they support and/or enforce this notion
06:57:03 <Twey> tdammers: Not quite — it has no means of creating functions
06:57:06 <thoughtpolice> beaky: also, you can get detailed LLVM version info by running 'llc -version'
06:57:15 <merijn> > let ♥ = 1 in ♥ + ♥
06:57:16 <tdammers> Twey: that's not a requirement for "first-class"
06:57:16 <lambdabot>  <hint>:1:5: parse error on input `♥'
06:57:19 <merijn> aww
06:57:20 <ski> b0bbi10 : to a large extent, programming is concerned with finding the right abstractions to structure things, inventing models and concepts and layers that work well together, and that are useful to reason about things, whether or not they are actually physically accurate (if applicable)
06:57:22 <Twey> tdammers: You can only pass them around, which makes them decidedly second-class compared to other values
06:57:24 <Fuuzetsu> lambdabot breaks my heart
06:57:27 <Guest6961> I am curious: what do you guys think about lisp family languages? I haven't tried any of them; is it worth it? and whichone if any?
06:57:30 <Fuuzetsu> > let α = 5 in α
06:57:31 <lambdabot>  5
06:57:33 <tdammers> Twey: as compared to what? integers?
06:57:40 <Twey> tdammers: For example, yes
06:57:43 <tdammers> Twey: you can't create new integers in C either
06:57:45 <beaky> my llvm is version 3.0
06:57:53 <beaky> which is probably ancient?
06:57:54 <haasn> > generalCategory '♥' -- Fuuzetsu
06:57:55 <lambdabot>  OtherSymbol
06:57:58 <Twey> tdammers: Sure you can, with an integer literal for example
06:58:11 <haasn> Fuuzetsu: which means it works as an operator
06:58:15 <Fuuzetsu> @hoogle generalCategory
06:58:16 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
06:58:16 <lambdabot> Data.Char data GeneralCategory
06:58:20 <Fuuzetsu> haasn: sweet
06:58:20 <haasn> λ let (♥) = (+) in 3 ♥ 4
06:58:21 <ski> Guest6961 : Scheme is worth learning, imho. because of continuations, and hygienic macros
06:58:22 <haasn> 7
06:58:34 <thoughtpolice> beaky: hm, damn, that's true. you can build a new LLVM version, but it's a bit tricky to get GHC to cooperate with it right now
06:58:37 <ski> .. and possibly because of SICP
06:58:46 <Twey> tdammers: If you have two instances of the number 3, they're different objects in a way that functions can't be
06:58:46 <tdammers> Twey: but those have to be declared at compile time just like functions (playing devil's advocate here...)
06:58:54 <Fuuzetsu> > let ♥ = (+); λ = 5 in λ ♥ λ
06:58:55 <lambdabot>  <hint>:1:5: parse error on input `♥'
06:59:01 <Fuuzetsu> > let (♥) = (+); λ = 5 in λ ♥ λ
06:59:03 <lambdabot>  10
06:59:04 <b0bbi10> ski: I get what you mean, but having analogies to the real world makes thing easier to understand
06:59:07 <tdammers> also, the instances of those integer numbers are completely volatile
06:59:25 <ski> b0bbi10 : maybe, maybe not
06:59:26 <tdammers> they may not even appear anywhere in RAM at any point during execution
06:59:27 <Twey> tdammers: That's not true: I can read an integer from the user and use + 1 to create a new integer based on that integer
06:59:45 <tdammers> Twey: now we're getting somewhere
06:59:48 <ski> b0bbi10 : it might give you a *sense* of security. that may be a false one, though
06:59:51 <Twey> (if I may bend the rules of your definition a little)
07:00:13 <Twey> tdammers: There's no similar concept of creation or alteration for functions
07:00:33 <osfameron> you can compose functions
07:00:35 <tdammers> you can't easily build higher-order functions in C, no
07:00:42 <ski> b0bbi10 : in some cases it's better to not start with analogies, or at least very clearly show that the analogies that one uses are broken, only partial
07:00:46 <tdammers> unless you do some low-level machine code hackery
07:00:50 <Twey> osfameron: Standardly?
07:00:57 <tdammers> which is perfectly possible, of course, but arguably no longer C programming
07:01:02 <merijn> Twey: Sure, just use CPP :D
07:01:11 <Fuuzetsu> stop right there, merijn
07:01:16 <Twey> Heheh
07:01:29 <Walther> Hmm. Is it possible with hakyll to have the markdown files compiled to html *without
07:01:29 <merijn> Fuuzetsu: Oh, you don't like my CPP template programming? :(
07:01:43 <merijn> Walther: without what?
07:01:44 <ski> Twey : of course with RTCG you can generate a copy of a function as well
07:01:45 <Walther> *without code highlighting* done by pandoc
07:01:49 <Twey> Right, you can always write your own machine code or use closures, but both those things are not standard C
07:01:56 <Walther> I'm wishing to use hilight.js instead for reasons
07:02:02 <tdammers> anyway, I'd argue that the concept of a function as a mapping between two sets is kind of central to FP; first-class functions and purity follow from that
07:02:08 <merijn> Walther: Configure pandoc not to hilight code?
07:02:12 <osfameron> Twey: in haskell, certainly.  And that's as well defined an operation as addition
07:02:13 <thoughtpolice> Fuuzetsu: isn't it "Stop right there, criminal scum" ?
07:02:14 <ski> Twey : it's just that most languages don't support RTCG
07:02:22 <merijn> Walther: You can alter the writ config of pandoc in hakyll
07:02:23 <t7> @hoogle char -> Int
07:02:24 <lambdabot> Did you mean: Char -> Int
07:02:24 <Twey> Walther: Use pandocCompilerWith to pass your own options to Pandoc
07:02:24 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
07:02:24 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
07:02:31 <Fuuzetsu> thoughtpolice: Yes but I'm lazy.
07:02:31 <merijn> Walther: use hakyllWith instead of hakyll
07:02:36 <t7> @hoogle Num a => Char -> a
07:02:36 <ski> (.. depending on what you mean exactly)
07:02:36 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:02:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:02:36 <lambdabot> Prelude abs :: Num a => a -> a
07:02:39 <b0bbi10> ski: I'll try to consider that aspect when learning Haskell from now on (though I am not sure if I can neglect the impact of OOP/ imperative entirely) ;)
07:02:58 <tdammers> we need to do I/O at some point, and most "FP" languages solve this dilemma by violating purity
07:03:08 <tdammers> but that doesn't mean it remains a central value
07:03:22 <Fuuzetsu> I wonder how many days of my life has cabal + GHC stolen from me on compilation times… ;_;
07:03:23 <ski> b0bbi10 : you shouldn't neglect it, you need it as well (well, at least some parts of it). you should learn new ways of thinking about code
07:04:07 <Twey> tdammers, c_wraith: Anyway, back to ‘functional’ vs. ‘pure’: I think most e.g. Lisp programmers have a strong intuition for when some code is ‘functional’, which includes purity as one of its criteria
07:04:15 <ski> @type Data.Char.ord
07:04:16 <lambdabot> Char -> Int
07:04:23 <Walther> Twey: Are there some default options I should be aware of when switching from pandocCompiler to pandocCompilerWith?
07:04:24 <ski> t7 ^ ?
07:04:38 <Twey> tdammers, c_wraith: E.G. I don't think most people would argue that a bunch of side-effecting lambdas called in sequence inside a PROGN count as ‘functional’ code, even though it's making use of first-class functions
07:04:49 <tdammers> Twey: indeed.
07:04:50 <merijn> Walther: Yes, but you can quickly check the hakyll source to see which defaults it uses
07:04:59 <Twey> Walther: The Pandoc reader and writer options are instances of Default, so the default options are ‘def’ for both
07:05:15 <tdammers> Twey: just because a language allows impure constructs, you can still avoid them for the most part and program in a pure functional style
07:05:30 <ski> Twey : that's probably try to a greater extent for Scheme programmers, than for Common Lisp programmers
07:05:34 <ski> s/try/true/
07:06:07 <Twey> tdammers: Right, but c_wraith claimed that the presence of first-class functions was sufficient to make the code/language ‘functional’, which I don't think is the common definition
07:06:20 <tdammers> Twey: I agree
07:06:25 <Twey> ski: Probably true, but I think even most CL programmers have some concept of it
07:06:30 <ski> yes
07:06:38 <Guest6961> ski: I'll give it a shot; thanks!
07:07:18 <ski> Guest6961 : you could try looking at the SICP textbook, and the accompanying videos, and see how you like them
07:07:36 <Twey> It's a good textbook
07:07:38 <ski> Guest6961 : there's also another book HtDP, and there's a #scheme channel
07:07:42 <ski> @where SICP
07:07:42 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
07:07:50 <Twey> Perhaps worth learning Scheme for
07:07:53 <ski> the first two links here
07:08:45 <Guest6961> ok!
07:08:47 <ski> anyway, continuations, including the more recent delimited/composable continuations, are good to grok, imho
07:08:50 <Kron> a concept of what?
07:09:00 <ski> Kron, sorry ?
07:09:07 <Kron> as a person who used to primarily program in CL I think I have a basic idea of what CLers think like
07:09:19 <Kron> "but I think even CL programmers have some concept of it"
07:09:40 <t7> > let f = sum . map ((subtract (ord 'a')) . ord . toLower); a ♥ b = show (round ((realToFrac ((f a + f b) `mod` 26) / 26) * 100)) ++ "% match" in "Dave" ♥ "Betty"
07:09:41 <lambdabot>  "65% match"
07:09:41 <Twey> Kron: Of ‘functional’ code
07:10:02 <Kron> yeah, they/we do
07:10:22 <Kron> we can progn but we try to avoid it I guess
07:10:39 <Twey> Kron: That involves more than just using first-class functions (e.g. a string of side-effecting lambdas run in a PROGN would not count as ‘functional’)
07:10:40 <ski> Kron : of immutability, and also of a function giving the same outputs for the same inputs in all environments
07:10:59 <Kron> referential transparency, etc.
07:11:07 <Kron> that took a lot longer for me to learn in haskell
07:11:20 <Kron> but the basic idea was always just good programming practice in CL
07:11:37 <Kron> immutability especially
07:11:39 <ski> and of using some efficiency tricks like in-place reversal or sort or append of a list that won't be used anymore
07:11:43 <Kron> CL's extremely impure
07:11:52 <Kron> it's built into the language
07:11:53 <Kron> rplaca, etc.
07:12:07 <ski> i think it's easier to avoid in Scheme
07:12:22 <ski> of course there's `set-car!' and `set!' as well
07:12:32 <Kron> I agree, scheme makes it a lot more obvious and ugly when you do modifications
07:12:35 <ski> but basic looping by `do' e.g. doesn't use mutation
07:13:34 <ski> (nor does more advanced looping macros like Riastradh's foof-loop, modelled partially after the CL `loop' (though foof-loop is arguably more lispy), and partially after a paper by Olin Shivers)
07:15:45 <ski> "foof-loop: A Simple, Extensible Scheme Looping Facility" by Riastradh at <http://mumble.net/~campbell/scheme/foof-loop.txt>
07:16:14 <Fuuzetsu> t7: slap it in a module and you have acme-lovematch ;P
07:16:41 <ski> "Yow! LOOP macros are LOOPY!" by foof on <news:comp.lang.scheme> in 2006-09-06 at e.g. <https://groups.google.com/forum/#!topic/comp.lang.scheme/DLkZdLw1qGw>
07:16:52 <ski> Kron : see those ^, if you're interested
07:17:59 <ski> "The anatomy of a loop: a story of scope and control" by Olin Shivers in 2005-09 at <http://www.ccs.neu.edu/home/shivers/citations.html#loop> is the relevant paper in question
07:18:46 <Kron> hmmm, i might
07:19:58 <Fuuzetsu> Is there an easy way to see why the hell is trying to pull in a package version from 6 years ago instead of the latest one? Some kind of a way to display what makes it fall back.
07:20:24 <donri> -v3 or so?
07:20:32 <c_wraith> Fuuzetsu: that information is generally included with -v, but the output will drown you
07:20:45 <c_wraith> Maybe it does need -v3
07:20:46 <bennofs> Fuuzetsu: use --constraint "package > the version it wants to use"
07:21:01 <bennofs> Fuuzetsu: that will display why installing with a newer version fails
07:21:03 <donri> not sure what level it needs :)
07:21:28 <donri> oh yeah bennofs' method is better
07:21:45 <donri> maybe add --dry-run because it might not fail
07:21:57 <carter> merijn: Twey  johnw  yeah the right solution is "haskell cpp"
07:22:05 <Fuuzetsu> bennofs: so say vty-4.7.3 is the newest one and it tries to pull in 3.0.2, what would that look like?
07:22:05 <Fuuzetsu> damn, GHC guys changed some TH and now everything breaks
07:22:06 <carter> as its own proper thing
07:22:13 <carter> Fuuzetsu: jah
07:22:13 <Fuuzetsu> bennofs: no, I mean what the command would look like
07:22:29 <donri> --constraint 'vty > 3.0.2'
07:22:35 <bennofs> Fuuzetsu: cabal install <the package you want to install> --constraint "vty > 3.0.2"
07:22:35 <Fuuzetsu> ah, ok
07:24:10 <donri> also try --upgrade-dependencies, although I'm not completely sure how that will behave
07:24:38 <bennofs> donri: what does that do?
07:25:02 <donri> it supposedly makes cabal prefer latest versions over already-installed versions
07:25:03 <carter> i think upgrade-deps is deprecated though....
07:25:18 <carter> i could be wrong
07:25:26 <dcoutts> carter: no, the upgrade command is deprecated
07:26:10 <dcoutts> --upgrade-dependencies is the replacement, but less tempting for people who don't understand it
07:26:34 <merijn> I propose renaming to --potentially-break-dependencies :p
07:26:47 <donri> upgrade == install world --upgrade-dependencies? :P
07:26:56 <Walther> Hmm. Using hakyll, if i create a dir called "scripts" and copy the default "copyFileCompiler" rule for "images/*" renamed as "scripts/*" ...i'm still not getting the .js files served.
07:27:10 <dcoutts> donri: actually it was just cabal install --upgrade-dependencies
07:27:18 <donri> oh
07:27:51 <dcoutts> donri: oh, hmm, no you're right, without any target given it defaulted to trying all installed, so that's approximately like the world target
07:28:02 <donri> aha
07:28:13 <dcoutts> wasn't a good idea :-)
07:28:43 * hackagebot music-util 0.7 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.7 (HansHoglund)
07:28:51 <donri> but is it really a bad idea in itself, or merely not that compatible with current cabal implementation? :P
07:29:10 <dcoutts> donri: without pinning the core libs it's a bad idea
07:29:21 <donri> oh it tried to upgrade core libs too?
07:29:28 <dcoutts> sure
07:29:37 <dcoutts> they're just dependencies, nothing special :-)
07:29:37 <donri> i think those should be pinned by default anyway, always, for all operations ...
07:30:07 <dcoutts> well that's the problem, just pinning the core ones is too few, and pinning the cores ones is also too many
07:30:16 <donri> :)
07:30:22 <dcoutts> so you actually need a more flexible mechanism
07:30:57 <donri> i guess it's only really a problem if you link libghc, but that may happen transitively ...
07:32:03 <donri> (of course, which libs are core depends on the compiler, so any default pinning would need do know about that as well...)
07:33:07 <bennofs> Does bytestring come with GHC?
07:33:16 <donri> it's a core lib yes
07:33:27 <donri> ghc links bytestring
07:34:15 <bennofs> Should I use blaze-builder with aeson? (-DUSE_BLAZE_BUILDER)
07:34:43 <donri> if your bytestring doesn't have Builder, probably yes
07:34:55 <donri> it's not a great idea to upgrade bytestring without upgrading ghc
07:35:02 <dcoutts> bah
07:35:08 * dcoutts has several versions of bytestring installed
07:35:12 <donri> :)
07:35:12 <dcoutts> :-)
07:35:12 <bennofs> so either -DUSE_NEW_BYTESTRING or -DUSE_BLAZE_BUILDER?
07:35:37 <donri> dcoutts: but you'll get scary linker errors if anything in your dep chain links ghc :)
07:35:55 <Fuuzetsu> does Daniel Gorin come on IRC?
07:35:57 <dcoutts> donri: only if you load in ghci
07:36:04 <donri> bennofs: i doubt you're supposed to use -D yourself?
07:36:16 <bennofs> donri: oops, I meant as cabal flags
07:36:27 <donri> dcoutts: oh? but isn't linking ghc akin to loading in ghci
07:36:48 <bennofs> flag blaze-builder or flag new-bytestring-builder
07:37:07 <donri> bennofs: those aren't manual flags, cabal should figure it out for you i think
07:37:25 <dcoutts> donri: no, TH is equiv to loading in ghci, but just linking against the ghc package is like linking any other ordinary package (only quirk is ghc package is not upgradeable)
07:37:50 <bennofs> donri: I'm packaging it for nixos, so I need to know the dependencies upfront.
07:38:13 <donri> dcoutts: i meant together with a different bytestring. it's obviously fine to have multiple installed and let cabal select the one ghc wants
07:38:44 * hackagebot language-openscad 0.1.3 - A simple parser for OpenSCAD  http://hackage.haskell.org/package/language-openscad-0.1.3 (BenGamari)
07:38:54 <donri> bennofs: in that case it depends on whether you can satisfy build-depends: bytestring >= 0.10 without forcing an upgrade
07:39:11 <dcoutts> bennofs: cabal install --dry-run is good for that, let it figure them out for you, fiddle 'til you're happy, and then freeze those into your nix description
07:39:35 <donri> doesn't nix have some semiautomatic tool for cabal packaging?
07:39:43 <dcoutts> yes
07:40:00 <bennofs> yes, but I need to know which flag to enable :p
07:40:43 <donri> not sure i see why
07:41:27 <bennofs> donri: because the semiautomatic tool reads the cabal file and decides the dependencies based on that. If I don't say which flag to enable, it won't enable the flag or install the dependencies
07:41:48 <donri> ah, it works by parsing the spec file rather than calling out to cabal?
07:42:07 <bennofs> Yes
07:42:27 <bennofs> I just wonder if it's good to enable either blaze-builder or new-bytestring-builder?
07:42:47 <donri> not sure what the best/easiest way to do this here is but one way could be to try the flags with --constraint 'bytestring installed' and see what passes
07:43:09 <dcoutts> bennofs: just try it both ways with cabal install --dry-run and see which you like the look of
07:43:11 <bennofs> donri: for new-bytestring-builder, I'd also need text 1.1, and I don't have that
07:43:27 <donri> text isn't core though, i don't think anyway...
07:43:38 <bennofs> donri: So the choice is: no flag at all or blaze-builder?
07:44:10 <donri> depends on how smart the nix tool is :) does it handle flag defaults and else-fallbacks?
07:45:14 <haasn> how smart is GHC at folding constants?
07:46:31 <tomejaguar> Does anyone know why Data.Map.insert takes the key as the first argument, whereas everything else seems to take the k as the second?
07:47:48 <dcoutts> tomejaguar: most other functions in Data.Map are the same, what are you comparing against?
07:48:40 <dcoutts> haasn: you probably want to be more specific with your Q
07:49:59 <tomejaguar> Oh I suppose the 'insert...With...' actually do fit the pattern.
07:50:17 <tomejaguar> I presumed that since 'adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a' then insert would take 'a' first and 'k' second.
07:51:43 <dcoutts> tomejaguar: the way to look at is rather the other way round, last arg is the map, then value, key, and first any combining function
07:51:58 <dcoutts> because that's the order you typically partially overload
07:52:35 <donri> bennofs: oh hm there's tree options here? blaze, old-style "Lazy" builder and new-style plain Builder? maybe
07:52:36 <donri> (they're all lazy, but they moved the module hierarchy)
07:52:36 <donri> s/tree/three/
07:52:38 <donri> dcoutts: is there an option to get cabal-install to print what flags it selected? perhaps some -v level?
07:52:42 <bennofs> donri: from looking at the cabal file, it seems that it's also possible to enable no flag at all, so that I neither use new bytestring nor blaze-builder? http://hackage.haskell.org/package/aeson-0.7.0.2/aeson.cabal
07:52:43 <merijn> There should be a law that states that if you're gonna fork a hackage package and upload it to hackage that you at least mention what's different >.>
07:53:09 <donri> bennofs: no i think you'll have to install one of blaze-builder or a recent bytestring
07:53:48 <tomejaguar> dcoutts: Yeah I don't think 'insert' fits that pattern though.  The new value 'a' is actually quite like a combining value and seems like it should come first.
07:53:58 <tomejaguar> *combining function
07:54:08 <dcoutts> tomejaguar: the point is you use a key + val together
07:54:26 <dcoutts> tomejaguar: but you may well partially apply, e.g. alter (+1)
07:54:37 <bennofs> donri: is there any performance difference between blaze and old-style?
07:55:02 <bennofs> haasn: I remember hearing that GHC is pretty bad at low-level optimizations like constant folding
07:55:03 <bennofs> donri: how does that follow from the cabal file?
07:55:14 <dcoutts> bennofs, donri: if you look at the .cabal file you'll see that all combinations of the two flags are permitted and make sense
07:55:16 <donri> bennofs: i think it's all basically the same code. blaze-builder got ported to bytestring proper, and then later they renamed the module
07:55:28 <donri> dcoutts: in deed
07:56:15 <dcoutts> bennofs: it depends what you mean by constant folding
07:56:19 <donri> bennofs: all that matters is what bytestring version you have, and i don't think you're supposed to pick these flags manually under normal circumstances
07:58:21 <donri> bennofs: you'll want blaze-builder if bytestring < 0.10, and new-bytestring-builder if bytestring >= 0.10.4.0
08:01:15 <donri> although there's also the possible scenario that you have bytestring >= 0.10.4.0 but text < 1.1.0.0, in which case either upgrade text or go with "old-bytestring-builder" (ie. no flags, or both explicitly false)
08:02:09 <donri> there are compatibility layers with deprecation notices in the newer bytestring versions
08:02:22 <donri> so it should still work
08:05:55 <Walther> With hakyll, how do i use the pandocCompilerWith? It apparently requires some options, and I don't want all the defaults (namely, I don't want pandoc to handle code hilighting, just slam the code in <pre><code> tags
08:06:54 <Selwyn> Hello, is there any way to give True or False on string containing decimals. I now have this: containsDigit xs = elem True[isDigit x | x <- xs] but that only works on strings like "100" "47". I need it to give True on "a300" and False on "abc" anybody knows how?
08:08:08 <shiona> > any isDigit "a300"
08:08:09 <lambdabot>  True
08:08:21 <dcoutts> Selwyn: it does work already for "a300" and "abc"
08:09:33 <dcoutts> Selwyn: but shiona has the right suggestion for a better way to write it
08:09:34 <dcoutts> :type any
08:10:19 <Selwyn> oh I see
08:10:38 <Selwyn> Yes it works I  just made a mistake myself
08:10:41 <Selwyn> thanks for the support
08:15:35 <Galactic> what does  ill  mean?
08:16:06 <Galactic> like in,  ill typed
08:16:14 <Galactic> is it null?
08:16:39 <tomejaguar> "Ill typed" means not well typed.
08:17:56 <merijn> Galactic: "Ill typed" means "doesn't type check"
08:18:15 <Selwyn> What would be the best way transform string "abc584selwyn47" to 584 47
08:18:26 <merijn> Galactic: For example "True + 1" is ill typed, because + doesn't allow adding Bool to Int
08:18:33 <Galactic> aa ok ty
08:19:04 <Kiemo> hi, why can i compose monad computations of different type? E.g I can use functions with type State Foo Bar insside "do" block with type State Foo Quiz.
08:19:15 <Galactic> :t True + 1
08:19:16 <lambdabot>     No instance for (Num Bool) arising from a use of `+'
08:19:16 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
08:19:16 <lambdabot>     In the expression: True + 1
08:19:22 <dwcook> @type (>>=)
08:19:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:19:34 <dwcook> Kiemo, ^ That function allows you to pick a new type, basically
08:19:54 <Kiemo> State Foo Bar and State Foo Quiz are from same type family but actually still different types.
08:20:14 <JonyBoy> Hallo guys
08:20:23 <dwcook> There's also (>>), which is just a specialization of that
08:20:24 <dwcook> @type (>>)
08:20:25 <lambdabot> Monad m => m a -> m b -> m b
08:20:40 <dwcook> Those do the brunt of the work of do blocks
08:20:57 <Kiemo> dwcook: ah, so "m" persists but "a" can vary.
08:21:01 <dwcook> Indeed
08:23:27 <ski> Hallo, Herr JonyBoy
08:29:17 <Kiemo> how can i transform [m a] to m [a]?
08:29:41 <merijn> :t sequence
08:29:42 <lambdabot> Monad m => [m a] -> m [a]
08:29:46 <Kiemo> thanks
08:29:59 <merijn> Kiemo: Also, you can search Hoogle for type signatures
08:30:06 <merijn> @hoogle [m a] -> m [a]
08:30:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:30:07 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:30:07 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
08:30:24 <merijn> @where hoogle
08:30:24 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:31:12 <Kiemo> merijn: ah, right, my type signature was precie enough for hoogle, sorry.
08:35:10 <hunt> hey
08:35:24 <hunt> im trying to implement dotproducts for arrays of nums
08:35:32 <hunt> and im getting some errors i dont understand
08:35:47 <JonyBoy> decimalCount :: String -> Int
08:36:02 <JonyBoy> I have a problem guys
08:36:10 <hunt> http://pastebin.com/0D4cgakG
08:36:26 <hunt> gives errors when i run dotProduct [1,2,3] [2,3,4]
08:36:29 <hunt> anyone can help?
08:36:48 <JonyBoy> I want to get a list of numbers in a string
08:36:55 <tomejaguar> hunt: In general it's helpful to paste the error too.
08:36:58 <JonyBoy> getDecimals :: String -> [Int]
08:37:31 <JonyBoy> if I have a string like "Ha11o"
08:37:41 <JonyBoy> i want to get only  11
08:37:47 <hunt> tomejaguar: sure, sorry 1 sec
08:37:53 <dwcook> JonyBoy, integers, or decimal numbers too, or some other format?
08:38:04 <tomejaguar> hunt: In this case you probably want 'instance Num a => Vector a where'
08:38:09 <tomejaguar> for some value of "want"
08:39:08 <JonyBoy> dwcook == if is have a String like ha11o 1'm Jony. I want to get something like this ( 11, 1)
08:39:36 <dwcook> JonyBoy, that doesn't answer my question, but I'll assume you mean just integers. You might implement it with
08:39:39 <dwcook> @type groupBy
08:39:40 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:40:00 <JonyBoy> yes Integerrs
08:40:12 <dwcook> Wait that might be wrong
08:40:14 <dwcook> Let me try
08:40:29 <JonyBoy> getDecimals :: String -> [Int]
08:40:29 <JonyBoy> getDecimals :: String -> [Int]
08:40:29 <JonyBoy> getDecimals :: String -> [Int]
08:40:29 <JonyBoy> getDecimals :: String -> [Int]
08:40:29 <JonyBoy> String -> Int
08:41:16 <fizbin> JonyBoy: If you have the string "a2b2c2d", do you want the integer 222 ?
08:41:41 <dwcook> > groupBy (\x y -> isDigit x == isDigit y) "a12bdsfsde35423sadf"
08:41:42 <lambdabot>  ["a","12","bdsfsde","35423","sadf"]
08:41:45 <JonyBoy> (2,2,2)
08:41:58 <dwcook> That's a start, then you can use a combination of filter and map
08:41:58 <hunt> tomejaguar: i get illegal instance declaration if i use Num a => Vector a, but not if i use Num a => Vector [a]
08:42:32 <Iceland_jack> > groupBy ((==) `on` isDigit) "a12bdsfsde35423sadf"
08:42:32 <lambdabot>  ["a","12","bdsfsde","35423","sadf"]
08:42:33 <JonyBoy> I want something like this (2,2,2) if I have "a2b2c2d"
08:42:44 <hunt> anyone else have any tips with this implementation? http://pastebin.com/UbvsrZCJ
08:42:48 <hunt> i trying to do dotproducts
08:42:59 <fizbin> I see, but if you have "a22b", you just want 22?
08:43:28 <JonyBoy> yes
08:43:36 <JonyBoy> but if I have
08:44:07 <JonyBoy> "a22bc22" I want to get ( 22, 22)
08:44:58 <ski> hunt : why do you use a type class at all here ?
08:45:23 <hunt> ski: idk i feel like vector should be a class
08:45:33 <Iceland_jack> > map read (filter (all isDigit) (groupBy ((==) `on` isDigit) "a22bc22")) :: [Integer]
08:45:34 <lambdabot>  [22,22]
08:45:34 <Iceland_jack> lazy way
08:46:13 <Iceland_jack> JonyBoy: You're not going to get (2, 2) and (2, 2, 2) from a function returning a type [Int]
08:46:39 <fizbin> Iceland_jack: I assumed he meant lists, not tuples.
08:46:42 <dwcook> Well JonyBoy mentioned above wanting a list, so I assumed [2, 2] or [2, 2, 2]
08:46:45 <Iceland_jack> Yeah me too
08:47:19 <Iceland_jack> My case is needlessly expensive but that's par for the course of asking Internet strangers for code :)
08:47:31 <fizbin> > groupBy ((==) `on` isDigit) "
08:47:32 <lambdabot>  <hint>:1:30:
08:47:32 <lambdabot>      lexical error in string/character literal at end of input
08:47:42 <fizbin> > groupBy ((==) `on` isDigit) ""
08:47:43 <lambdabot>  []
08:48:02 <dwcook> Optimization is for later
08:48:11 <tomejaguar> hunt: What you've written is rather confused.  I'd suggest avoiding typeclasses for now.  Try this: http://lpaste.net/100962
08:51:38 <JonyBoy> sorry I dont understand map read
08:51:53 <Iceland_jack> JonyBoy: map read turns a list of strings into a list of something else
08:52:02 <Iceland_jack> > ["123", "345"]
08:52:03 <lambdabot>  ["123","345"]
08:52:05 <JonyBoy> Im using haskell winGhCI
08:52:06 <Iceland_jack> > map read ["123", "345"] :: [Int]
08:52:07 <lambdabot>  [123,345]
08:52:21 <Kiemo> are there any libraries for pretty printing records?
08:53:28 <bergmark> Kiemo: groom, and another one i forget the name of
08:54:53 <JonyBoy> @Iceland_jack: Can you fix my code en paste it here ? http://haste.devbin.nl/
08:54:54 <lambdabot> Unknown command, try @list
08:54:57 <Kiemo> bergmark: thanks, i'll check groom
08:55:00 <Krakarn> tomejaguar: I think you missed a dot in the beginning there
08:55:22 <JonyBoy> it must use getDecimals :: String -> [Int]
08:55:53 <JonyBoy> getDecimals xs =
08:56:56 <tomejaguar> Krakarn: Thanks, corrected.
08:56:59 <Kiemo> heh, goom works quite badly on UUID values, e.g "75102 f2 - ef0b - 45000.0 - b9ac - 43 aad5798eb5"
08:58:00 <dwcook> JonyBoy, is this a homework assignment?
08:59:02 <JonyBoy> yes
08:59:06 <JonyBoy> and im stuck
08:59:22 <dwcook> JonyBoy, then it would be best if you asked what you were unclear about and we could help you understand
09:01:14 <JonyBoy> if I have this
09:01:15 <JonyBoy> digitCount :: String -> Int
09:01:15 <JonyBoy> digitCount xs = length (filter isDigit xs)
09:01:38 <JonyBoy> this check if contains digit
09:01:40 <JonyBoy> if so
09:01:52 <JonyBoy> count the lenght
09:01:55 <frontend1oader> wish i had Haskell homework at school.
09:02:11 <Iceland_jack> @let digitCount xs = length (filter isDigit xs)
09:02:13 <lambdabot>  Defined.
09:02:16 <Iceland_jack> > digitCount "12324abcsd"
09:02:18 <lambdabot>  5
09:02:42 <JonyBoy> nou I want to get a lijst of digits that contains in the string
09:03:02 <JonyBoy> like "a1b2c3" = [ 1,2,3]
09:03:13 <JonyBoy> and I dont know how
09:03:27 <Iceland_jack> JonyBoy: No idea what to do?
09:03:40 <JonyBoy> no no idea
09:03:55 * hackagebot abcnotation 1.6 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.6 (HansHoglund)
09:03:57 * hackagebot lilypond 1.6 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.6 (HansHoglund)
09:03:59 * hackagebot music-pitch-literal 1.6 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.6 (HansHoglund)
09:04:01 * hackagebot music-dynamics-literal 1.6 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.6 (HansHoglund)
09:04:03 * hackagebot music-score 1.6 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.6 (HansHoglund)
09:04:09 <Iceland_jack> JonyBoy: Did the above code not give you any clues?
09:04:33 <Iceland_jack> > groupBy ((==) `on` isDigit) "a1b2c3"
09:04:34 <lambdabot>  ["a","1","b","2","c","3"]
09:05:11 <Iceland_jack> It can be made simpler if you only want single digit numbers
09:05:33 <Iceland_jack> i.e.
09:05:33 <Iceland_jack>     "a1b22c3"
09:05:33 <Iceland_jack> returning
09:05:33 <Iceland_jack>     [1,2,2,3] rather than [1,22,3]
09:09:05 * hackagebot music-pitch 1.6 - Abstract representation of musical pitch.  http://hackage.haskell.org/package/music-pitch-1.6 (HansHoglund)
09:09:06 <Gothmog_> is it possible with template haskell to splice the name of a declaration?
09:09:07 * hackagebot music-dynamics 1.6 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.6 (HansHoglund)
09:09:09 * hackagebot music-articulation 1.6 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.6 (HansHoglund)
09:09:10 <Gothmog_> like in [d| $(liftM VarP $ newName "f") = ... |]
09:09:11 * hackagebot music-parts 1.6 - To be written.  http://hackage.haskell.org/package/music-parts-1.6 (HansHoglund)
09:09:13 * hackagebot music-preludes 1.6 - Some useful preludes for the Music Suite.  http://hackage.haskell.org/package/music-preludes-1.6 (HansHoglund)
09:14:15 * hackagebot music-graphics 1.6 - Diagrams-based visualization of musical data structures.  http://hackage.haskell.org/package/music-graphics-1.6 (HansHoglund)
09:14:17 * hackagebot music-sibelius 1.6 - To be written.  http://hackage.haskell.org/package/music-sibelius-1.6 (HansHoglund)
09:14:19 * hackagebot musicxml2 1.6 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.6 (HansHoglund)
09:14:21 * hackagebot BlogLiterately 0.7.1.5 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.5 (BrentYorgey)
09:15:17 <dfeuer> I've been puzzling my way through Mihaesau and Tarjan's "Notes on Catenable Deques", and I realized yesterday that they don't seem likely to share the pleasant nested type structure of Okasaki's lazy amortized version because of the (too complicated for me to fully understand as yet) way the tree structure is decomposed. Is my thinking correct?
09:15:21 <dfeuer> @where ops
09:15:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
09:15:26 <JonyBoy> Thx Guys ,, but it did't work
09:16:03 <byorgey> dfeuer: uh, why did you just summon the ops?
09:16:28 <dfeuer> byorgey, sorry, I didn't realize just what that command would do.
09:16:44 <byorgey> dfeuer: ok, no worries
09:17:06 <Iceland_jack> JonyBoy: What is your proficiency with Haskell? Can you solve slightly simpler problems recursively?
09:17:07 --- mode: ChanServ set +o byorgey
09:17:11 <shapr> byorgey HAS THE POWER!
09:17:19 * byorgey flexes
09:17:27 * shapr grins
09:17:28 <Iceland_jack> using something of the form
09:17:28 <Iceland_jack>     function []     = ...
09:17:28 <Iceland_jack>     function (x:xs) = ...
09:17:44 --- mode: ChanServ set -o byorgey
09:18:04 <shapr> byorgey: I've spoken to several people in the southeast who read the typeclassopedia for fun in their spare time.
09:18:11 <shapr> They were impressed that I had actually met you :-)
09:18:13 <byorgey> shapr: =)
09:18:29 <byorgey> haha
09:18:43 * shapr basks in the reflected fame
09:18:57 * hackagebot creatur 5.2.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.2.1 (AmyDeBuitleir)
09:19:11 * ski should think they ought to be more impressed that byorgey has met shapr
09:19:14 * dfeuer wonders if he accidentally distracted everyone so that they never read his question.
09:19:18 * shachaf wonders how one comes to be aware of the existence of "@where ops" but not of its function.
09:19:23 <quicksilver> to be fair you probably didn't meet the *real* byorgey, shapr. People as famous as him hire actors to do conferences and social engagements.
09:19:31 <shapr> quicksilver: oh, that makes sense
09:19:41 <shapr> ski: Heh, I don't think there's a total order or anything.
09:19:52 <shapr> I think people do awesome stuff, and they get remembered for that.
09:19:55 <quicksilver> dfeuer: I think you just rolled a dice. The odds of finding someone who has read Mihaesau and Tarjan and remembers the details aren't that great.
09:19:55 <byorgey> hire actors?? please, I program my own automata
09:20:00 * ski computes the lub
09:20:26 <shachaf> It's a partial order, but still bounded.
09:20:28 <quicksilver> (they're probably better here than in most randomly selected gruops of people but even so ;)
09:21:07 <dfeuer> quicksilver, the same question would apply to the earlier Kaplan and Tarjan version, I think.
09:21:24 <quicksilver> I'm not sure that changes your odds all that much.
09:21:52 <geekosaur> shachaf, someone not understanding the point of the /topic
09:22:01 <shachaf> Oh, it's in the topic. OK.
09:22:05 * shapr bounds cheerfully
09:24:28 <ski> @dice 7d24
09:24:28 <lambdabot> ski: 93
09:25:05 <dfeuer> OK, point taken. The trouble is that nested types don't let you "skip down" multiple levels the way the structure requires. At least not easily.
09:25:20 <Zariel> @dice 2d6
09:25:20 <lambdabot> Zariel: 5+4 => 9
09:25:58 <ski> @dice 4d10+6
09:25:58 <lambdabot> ski: 23 + 6 => 29
09:27:10 <bennofs> what does @dice xdy+z mean? (for arbitrary x,y,z)
09:27:47 <ski> @help dice
09:27:48 <lambdabot>  @dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
09:27:57 <dwcook> bennofs, roll x y-sided dice and add z to the result
09:28:13 <dwcook> It comes from Dungeons & Dragons
09:28:59 <davidfetter_disq> so are the dice actually modeled in a physics engine?
09:29:18 <ski> no, it's just a call to `randomR' or `randomRIO'
09:29:33 <davidfetter_disq> oh, well
09:29:47 <dwcook> The randomness has to come from somewhere even in the physics engine
09:29:56 <ski> (or several, or a call to `randomRs', perchance)
09:30:03 * davidfetter_disq stopped playing D&D at age 12 or so
09:30:05 <dwcook> In fact using a physics engine is more likely than not to make it less random :P
09:30:33 <ski> (less close to uniformly random)
09:30:37 <dfeuer> What's the smallest possible expected number of (uniform, white) random bits needed to choose 6 *distinct* digits uniformly randomly?
09:30:39 <davidfetter_disq> perhaps closer to the actual outcomes of throwing dice, though
09:30:54 <dwcook> Perhaps
09:31:08 <ski> digits in which base ?
09:31:16 <dfeuer> Sorry, ski, base 10.
09:31:38 <dwcook> Which base 10?</facetious>
09:31:46 <dfeuer> Base ten.
09:31:50 <dwcook> :D
09:31:53 <davidfetter_disq> heh
09:31:54 <ski> > logBase 2 (10 ^ 6)
09:31:55 <lambdabot>  19.931568569324174
09:32:19 <dwcook> > ceil (logBase 2 (10 ^ 6))
09:32:20 <lambdabot>  Not in scope: `ceil'
09:32:23 <dwcook> > ceiling (logBase 2 (10 ^ 6))
09:32:25 <lambdabot>  20
09:32:39 <ski> i suppose `19' or `20' binary choices would have to be made, in the best case
09:33:00 <dfeuer> ski, I don't think that is the answer. The six digits must be distinct. I guess I want logBase 2 (10 `p` 6) ?
09:33:08 <ski> oh, forgot about distinct
09:33:11 <davidfetter_disq> you can't actually get the 6 digits with 19 bits
09:33:14 <dwcook> Sampling without replacement?
09:33:44 <ski> > logBase 2 (product [10 - i | i <- [0 .. 5]])
09:33:45 <lambdabot>  17.206098613995795
09:34:02 <dfeuer> Yes, dwcook. To be more precise, I'm talking about setting a 6-digit combination on a lock. The digits should be distinct to avoid excessive wear on any of the number keys.
09:34:10 <ski> davidfetter_disq : not always, at least
09:34:18 <dfeuer> (because those keys actually do wear out)
09:34:23 <davidfetter_disq> ski, fair enough
09:35:08 <ski> you could try building a binary tree by partitioning the set into two roughly equinumerous halves each time
09:35:11 <davidfetter_disq> dfeuer, so you're eschewing the silliness of frequent credential changes for the sake of changing them. good for you!
09:35:29 <ski> depending on which branch of the tree you follow, you might need one more or one less random bit
09:35:54 <cleatoma> It depends how important it is to you that it's completely uniform.
09:36:14 <cleatoma> If you don't mind some combinations being half as likely as others, then the binary tree approach would be great.
09:36:19 <ski> yes
09:37:27 <ski> i suppose one could leave some tree path open, it being an infinite path, to get the exact right uniform distribution
09:38:08 <dfeuer> That logarithm you gave looks real fishy, ski, because of the fact that 10P6 is not a power of two....
09:38:13 <ski> (it would be quite uncommon to exceed the one-bit variation, though)
09:38:18 <dfeuer> There's no upper bound on the number of bits you might need.
09:38:31 <dfeuer> But the expected number should not be large.
09:38:43 * ski agrees
09:38:48 <cleatoma> I believe it costs you one or two extra bits on average.
09:38:59 * hackagebot cheapskate 0.1.0.1 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1.0.1 (JohnMacFarlane)
09:39:01 * hackagebot bitset 1.4.8 - A space-efficient set data structure.  http://hackage.haskell.org/package/bitset-1.4.8 (FedorGogolev)
09:43:24 <cleatoma> Yes, if you generate a binary fraction between 0 and 1, one bit at a time, and then stop once every number starting that way falls into the same 1/100000th of the line, then you'll need 18 bits plus each extra bit will give you a 50% chance of being done.
09:44:09 <cleatoma> Hold up, not 100000, but ski's answer.
09:44:22 <dwcook> ski's constant
09:44:27 <cleatoma> So it'll be 19-20 bits on expectation.
09:44:47 * ski 's variable
09:44:51 <dwcook> sounds like it should be something important in mathematics
09:45:34 <dwcook> Or physics – ski's constant is the friction coefficient of a snow-covered hill
09:46:35 <jonyBoy> can someone help me
09:46:39 <jonyBoy> I have
09:46:39 <jonyBoy> getDecimal xs = groupBy (\x y -> isDigit x == isDigit y) xs
09:46:50 <Iceland_jack> jonyBoy: Do you understand it?
09:47:02 <jonyBoy> yes
09:47:04 <jonyBoy> getDecimal "ikbend1d334fsf"
09:47:05 <jonyBoy> ["ikbend","1","d","334","fsf"]
09:47:12 <jonyBoy> if I put this
09:47:19 <jonyBoy> I get a list
09:47:19 <Iceland_jack> Yes
09:47:32 <Iceland_jack> Do you know how to write a recursive function?
09:47:56 <jonyBoy> but how can I get only the nnombres
09:48:06 <ion> filter (all isDigit)
09:48:18 <jonyBoy> I'll try
09:48:33 <Iceland_jack> jonyBoy: You haven't answered my question twice now :)
09:48:41 <jonyBoy> sorry
09:48:50 <Iceland_jack> You can use higher order functions like ion suggests or you can use a simple function which picks out every second element
09:48:51 <jonyBoy> I did't see It
09:48:52 <ion> Filtering by the first character being a digit will work, too, given the semantics of groupBy.
09:50:06 <Iceland_jack> jonyBoy: (I offered a solution to your problem earlier and you even referred to it, was there some problem with it?)
09:50:52 <jonyBoy> Sorry I did'nt  unterstand your solution
09:50:56 <jonyBoy> Im new @ this
09:51:08 <jonyBoy> but now I have something working
09:51:19 <jonyBoy> but I can put the filter in
09:51:25 <jonyBoy> I dont know how
09:51:32 <jonyBoy> getDecimal xs = filter ( all isDigit) allgroupBy (\x y -> isDigit x == isDigit y) xs
09:51:34 <Iceland_jack> Okay, maybe next time either mention that you don't understand the solution or ask for an explanation on it
09:51:44 <jonyBoy> I'll
09:51:51 <Iceland_jack> jonyBoy: You need parentheses around the argument of 'filter (all isDigit)'
09:54:45 <jonyBoy> so something like this  getDecimal xs =  filter ((all isDigit)   groupBy (\x y -> isDigit x == isDigit y) xs) ?
09:55:06 <Iceland_jack> no
09:55:31 <jonyBoy> losing my mind over this
09:55:36 <Iceland_jack> It might be beneficial to check out some foundations in Haskell before attempting to write something non-trivial then :)
09:55:38 <Iceland_jack> @where lyah
09:55:38 <lambdabot> http://www.learnyouahaskell.com/
09:55:52 <Iceland_jack> Look at the first chapters of Learn You a Haskell and you'll be able to solve this
09:56:06 <jonyBoy> I did look at it
09:56:10 <jonyBoy> on youtube
09:56:14 <jonyBoy> and the book it self
09:56:35 <Iceland_jack> jonyBoy: Is this your first time programming?
09:56:43 <jonyBoy> In haskell yes
09:56:48 <ion> filter (predicate) (list), not filter ((predicate) (list)). predicate = all isDigit, list = groupBy…
09:56:52 <Iceland_jack> but not in general?
09:57:03 <jonyBoy> I program in java/php basic
09:57:42 <Iceland_jack> Okay, then you just need to think about the problem a bit
09:57:45 <Iceland_jack> You currently have this
09:57:45 <Iceland_jack> > groupBy (\x y -> isDigit x == isDigit y) "ikbend1d334fsf"
09:57:46 <lambdabot>  ["ikbend","1","d","334","fsf"]
09:57:57 <Iceland_jack> You want every second element in that list, right?
09:58:57 <ReinH> > groupBy ((==) `on` isDigit) "ikbend1d334fsf" -- just for fun
09:58:57 <lambdabot>  ["ikbend","1","d","334","fsf"]
09:59:11 <Iceland_jack> ReinH: Already been posted :)
09:59:15 <JakeE> Is there an extension to haskell that allows one to exclude functions exported from a module rather than list all functions that should expoted? That seems like a much easier task in many cases
09:59:16 <ReinH> Iceland_jack: :(
09:59:26 <jonyBoy> I dont want any letters
09:59:46 <cleatoma> > filter (all isDigit)  (groupBy (\x y -> isDigit x == isDigit y) "ikbend1d334fsf")
09:59:47 <lambdabot>  ["1","334"]
09:59:48 <Iceland_jack> jonyBoy: Right, and the letters are elements 0, 2, 4, ...
09:59:48 <dwcook> JakeE, no extension, just import Foo hiding (whatever)
09:59:49 <timmy_tofu> JakeE: see hiding
10:00:01 <cleatoma> You had it above, you just had your () wrong.
10:00:01 <ReinH> maybe just use parsec?
10:00:06 <ski> dwcook,timmy_tofu : not what they asked for
10:00:07 <ion> iceland_jack: Or 1, 3, 5, … depending on the input
10:00:10 <ReinH> or a fold?
10:00:17 <dwcook> Oh, *exports*
10:00:18 <dwcook> Sorry
10:00:19 <JakeE> no that isn't what I mean. I'm talking about the module cluase
10:00:29 <Iceland_jack> ion: True, I think they specified the input format earlier though
10:00:30 <timmy_tofu> oh, I see
10:00:42 <jonyBoy> doesnt work  filter (all isDigit)  (groupBy (\x y -> isDigit x == isDigit y) "ikbend1d334fsf")
10:01:00 <Iceland_jack> I guess this will just end with use giving the answer away
10:01:51 <JakeE> "module Foo !(bar, baz) where" would be really nice way to say "export everything EXCEPT foo and bar
10:03:06 <ski> JakeE : a construct like the SML `local'-`in'-`end' would also be useful
10:04:18 <JakeE> that would suffice to solve my probloem if I understand it correctly
10:05:11 <Fuuzetsu> Agda-like modules WHEN?
10:05:31 <JakeE> worst case senerio you could have all not exportedfunctions go in the local block and all exported functions go in the 'in' block. Better case you could add some organization to the mix
10:06:45 <timmy_tofu> looks like if you hide
10:06:53 <timmy_tofu> and then reexport the module
10:07:03 <timmy_tofu> it will work
10:07:14 <JakeE> bleh...two files sounds icky
10:07:27 <timmy_tofu> so, make your module, then make an accessor module which imports the real module, hiding whatever
10:07:37 <timmy_tofu> and have that accessor module reexport the inner module
10:07:45 <JakeE> creative solution however!
10:07:47 <timmy_tofu> yeah, well, it's easy at least
10:08:42 <bennofs> I think that's actually what most projects do. Make a module Module.Internal, and reexport that from Module modulo the things to hide
10:08:50 <benzrf_> hey yohanobs
10:08:52 <benzrf_> *yo
10:09:00 <benzrf_> i had an idea
10:09:07 <bennofs> This has the advantage that it still allows the user to access the internal stuff, if he really needs to (debugging, etc)
10:09:26 <benzrf_> if there  were some way of doing away with newtype wrappers but maintain separate instances
10:09:50 <benzrf_> it would be real nice if you could do 'foo bar <- baz' instead of 'foo <- baz\n\bar ->'
10:09:51 <doomlord__> any C++ or Rust users here, (yes I know its haskell. )
10:09:57 <JakeE> bennofs: intresting. Surly someone must have preposed to fix this little detail. Either that or I'm mising somthing about the great issues at hand here
10:10:00 <bjz> doomlord__: o/
10:10:07 <doomlord__> hah hi
10:10:08 <benzrf_> doomlord__: what do u need help with?
10:10:21 <JakeE> doomlord__: I quite like C++
10:10:27 <johnyBoy> Thnx guys
10:10:28 <johnyBoy> getDecimal xs = filter (all isDigit) (groupBy (\x y -> isDigit x == isDigit y) xs)
10:10:28 <bjz> JakeE: +1
10:10:31 <johnyBoy> works just fine
10:10:37 <johnyBoy> have a nice time
10:10:45 <bjz> JakeE: parts of it at least
10:10:52 <Iceland_jack> Wasn't it supposed to be String -> [Int]?
10:10:56 <ski> JakeE : sometimes i'd really like a `local' in Haskell :/
10:11:24 <doomlord__> i have a longrunning IRC argument with someone who insists Rust is "just c++ with a different personal style", and that OOP classes are the one true way of coding.
10:11:34 <doomlord__> over here would be the opposite extreme i imagine
10:11:34 <benzrf_> ski: what would that do p:
10:11:39 <Iceland_jack> doomlord__: C++ is quite different from Rust
10:11:39 <Iceland_jack>  
10:11:43 <benzrf_> ¬_¬
10:11:59 <bjz> Iceland_jack: or Rust is quite different to C++
10:12:14 <Iceland_jack> :)
10:12:27 <benzrf_> doomlord__: i would hold that many forms of programming are functionally equivalent (i.e. objects v closures) but are nonetheless best used in different ways
10:12:29 <JakeE> doomlord: find the many times bjarna has talked about how C++ is multiparadigm; not just OOP or generic or systems etc...
10:12:55 <ski> benzrf_ : "Restricted type synonyms" <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> is sortof what you were talking about, i think
10:12:56 <benzrf_> doomlord__: i certainly don't agree that 'objects are superior to closures because x and y therefore use objects instead of closures always' or vice versa
10:13:05 <doomlord__> JakeE sure - i'm well aware C++ is multiparadigm and I prefer a mixed style over pure OOP design patterns..
10:13:07 <benzrf_> ski: my idea wasnt ThatOtherPerson
10:13:08 <benzrf_> *that
10:13:17 <benzrf_> ski: my ide was that, if we had something like that
10:13:21 <bjz> benzrf_: +1. like the stuff covered in the Oz book
10:13:29 <benzrf_> ski: then you could replace:
10:13:31 <ski> @where CTM
10:13:31 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
10:13:39 <eacameron> monochrom: WHY ON EARTH does cabal auto upgrade your existing packages for you???
10:13:39 <benzrf_> do {foo <- bar; \baz -> thingy}
10:13:39 <benzrf_> with
10:13:41 <doomlord__> its' situation and domain dependant, its possible personality comes into it,
10:13:45 <benzrf_> do {foo baz <- bar; thingy}
10:13:59 <benzrf_> i.e. multi-arg lambas for ur patterns
10:14:07 <benzrf_> *do-patterns
10:14:21 <eacameron> monochrom: (been reading your article on cabal)
10:14:22 <benzrf_> atm thats not rly feasible given that you need to sandwich a wrapper in between emma
10:14:25 <benzrf_> *em
10:14:50 <ski> benzrf_ : the environment monad ?
10:15:05 <benzrf_> hm?
10:15:06 <dcoutts> eacameron: in general it doesn't, it prefers installed instances, but sometimes new things need new versions of deps
10:15:13 <benzrf_> well there are multiple function monads
10:15:13 <JakeE> doomlord__: there are quite a few diffrences and if this guy is as obbsessed with OOP as it sounds I doubt you can really convice him of anything.
10:15:18 <benzrf_> and most of them require lambdas ;-;
10:15:22 <benzrf_> even in do-notation
10:15:29 <benzrf_> unless you split em up into a bunch of sub functions
10:15:29 <ski> @type do {foo <- ?bar; \baz -> ?thingy foo baz}
10:15:30 <JakeE> if he can't see the diffrences I doubt you could convice him either
10:15:30 <lambdabot> (Monad ((->) t1), ?bar::t1 -> t, ?thingy::t -> t1 -> b) => t1 -> b
10:15:44 <benzrf_> ski: no, i mean
10:15:57 <benzrf_> ski: foo <- bar; baz => bar >>= \foo -> baz
10:16:03 <benzrf_> so add such that
10:16:21 <benzrf_> foo bar <- baz; quux => baz >>= \foo bar ->quux
10:16:30 <eacameron> dcoutts: then why does it not just install both versions and leave your old one alone?
10:16:38 <benzrf_> altho itd only be useful if we could do away with wrapper
10:16:40 <benzrf_> s
10:16:46 <ski> benzrf_ : you can say `(foo,bar) <- baz' ..
10:17:35 <ski> doomlord__ : which variant of OOP ?
10:17:36 <dcoutts> eacameron: it does if it's a different version, the problem is we currently cannot have two instances of the same version of the same package installed at once. That's what we need to be able to upgrade things without modifying any existing package.
10:17:42 <ski> @where object-oriented
10:17:42 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
10:18:07 <dcoutts> eacameron: and note that we all agree that that'd be the right thing to do, but it's quite a bit of work, and we've been gradually moving in that direction over several years
10:18:45 <eacameron> dcoutts: (sorry for the ALL CAPS before; monochrom's article makes cabal seem scary)
10:18:55 <benzrf_> ski: yeah, that doesnt work with state monads
10:18:55 <benzrf_> or reader monads
10:18:58 <benzrf_> or cont monads
10:18:58 <dcoutts> eacameron: he points out all the tricky corner cases
10:19:03 <ski> benzrf_ : why not ?
10:19:04 * hackagebot ghc-mtl 1.1.0.0 - An mtl compatible version of the Ghc-Api monads  and monad-transformers.  http://hackage.haskell.org/package/ghc-mtl-1.1.0.0 (DanielGorin)
10:19:10 <eacameron> dcoutts: why do we need multiple installations of the same version?
10:19:13 <dcoutts> eacameron: which is a useful thing! :-)
10:19:21 <benzrf_> because the type of >>= requires 2 args, not a tuple
10:19:31 <dcoutts> eacameron: iirc, it's covered somewhere in that article
10:19:36 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
10:19:37 <lambdabot>  Defined.
10:19:38 <klugez> eacameron: They may be built agains different versions of their dependencies.
10:19:53 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
10:19:54 <lambdabot>  Defined.
10:20:03 <eacameron> dcoutts: klugez: ohhh (light bulb)
10:20:20 <dcoutts> eacameron: but klugez has the summary, the article can probably give you an example
10:20:35 <eacameron> dcoutts: is there an end in sight?
10:20:46 <dcoutts> eacameron: yes, we did a GSoC project on it
10:20:51 <dcoutts> made a lot of progress
10:21:26 <eacameron> dcoutts: great!!
10:21:44 <eacameron> dcoutts: is this a common packaging problem?
10:22:03 <eacameron> dcoutts: seems like the solution would be found by someone by now
10:22:13 <dcoutts> eacameron: yes, we're copying the nix solution
10:22:24 <benzrf_> i wanted to do gsoc but you have to be a college student
10:22:40 <benzrf_> and i didnt find out about the code-in until after it was over
10:22:41 <benzrf_> ;-;
10:22:49 <ski> > evalCont $ do (x,y) <- liftM2 (,) (cont (`any` [0 .. 9])) (cont (`any` [0 .. 9])); return (x^2 == y)
10:22:50 <lambdabot>  True
10:23:00 <ski> > evalCont $ do (x,y) <- liftM2 (,) (cont (`any` [0 .. 2])) (cont (`any` [4 .. 9])); return (x^2 == y)
10:23:02 <lambdabot>  True
10:23:04 <ski> > evalCont $ do (x,y) <- liftM2 (,) (cont (`any` [0 .. 2])) (cont (`any` [5 .. 9])); return (x^2 == y)
10:23:05 <lambdabot>  False
10:23:13 <willem> hello, i have a question regarding the glpk-hs package (bindings to the gnu linear programming kit), is there anyone here who would like to think along with me?
10:23:26 <dcoutts> eacameron: and another "solution" is that linux distros do a lot of hard work to patch things so that everything uses at most one version of each package
10:23:34 <ski> benzrf_ : seems to work just fine with continuation monads ..
10:23:53 <eacameron> dcoutts: that's good news!
10:23:55 <benzrf_> ohhh, liftM2 (,)
10:24:05 <benzrf_> :t any
10:24:05 <lambdabot> (a -> Bool) -> [a] -> Bool
10:24:05 * hackagebot hint 0.4.0.0 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.0.0 (DanielGorin)
10:24:16 <benzrf_> ?
10:24:22 <benzrf_> ahihi:
10:24:22 <benzrf_> *ah
10:24:23 <willem> the code and error can be found here: http://lpaste.net/100972
10:24:48 <ski> benzrf_ : so we get from two `Cont Bool Integer's, to a `Cont Bool (Integer,Integer)', which we execute and bind to `(x,y)'
10:24:58 <benzrf_> :I
10:25:05 <ski> @type cont (`any` [0 .. 2])
10:25:06 <lambdabot> (Enum a, Num a) => Cont Bool a
10:25:08 <benzrf_> this is not what i referred to
10:25:16 <benzrf_> i meant, when m a is a function
10:25:17 <benzrf_> you get
10:25:27 <willem> if anyone's willing to look at it, i already have a feeling what might be the problem but i'm not exactly sure how i should go about solving it
10:25:30 <benzrf_> a -> m b becomes a -> something -> b, or something
10:25:36 <benzrf_> 2 args
10:25:51 <benzrf_> so with the current thing you need to do a <- /and/ a lambdabot
10:25:55 <benzrf_> *lambda
10:25:57 <ski> benzrf_ : ok, so you *are* talking about environment monads, then ..
10:26:05 <benzrf_> because <- dont allow multiple args for the resulting lambdas
10:26:07 <benzrf_> *lambda
10:26:17 <benzrf_> ski: any monad where m b is a function
10:26:25 <benzrf_> that includes reader
10:26:26 <ski> (benzrf_ : you seem to often nick-complete at the end of a message ?)
10:26:30 <pavonia> willem: What'S the type of varBds?
10:26:31 <benzrf_> yeah <_<
10:26:38 <benzrf_> i have a habit of pressing tab then backsp
10:26:43 <ski> benzrf_ : it doesn't include state, does it ?
10:27:06 <benzrf_> :t state
10:27:07 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
10:27:12 <ski> i mean state monads
10:27:19 <benzrf_> :t StateT
10:27:20 <lambdabot> (s -> m (a, s)) -> StateT s m a
10:27:28 <benzrf_> ^is a function
10:27:28 <eacameron> what are the top 10 things that would help a non-haskeller be able to read haskell?
10:27:32 <willem> pavonia: it's varBds :: (Ord v, Ord c, MonadState (LP v c) m) => v -> c -> c -> m ()
10:27:35 <benzrf_> eacameron: learning haskell
10:27:36 <ski> (if i meant `state' or `StateT', i would have said so)
10:27:46 <eacameron> aside from benzrf_'s suggestion
10:27:56 <benzrf_> eacameron: maybe learnin ML
10:28:00 <ski> benzrf_ : i don't think "is a function" or "is not a function" is very useful here
10:28:08 <quchen> evalCont = runCont id?
10:28:10 <eacameron> I'm trying to actually be helpful here! ;)
10:28:21 <eacameron> "be a genius" would work too
10:28:25 <ski> benzrf_ : `(a,a)' is iso to `Bool -> a', yet one "is a function", while the other isn't
10:28:30 <eacameron> the point is to help, not to ridicule
10:28:31 <ski> quchen : of course
10:28:41 <willem> pavonia: i think the problem is that i can't have integral variables if i have a non-integral objective function...
10:28:53 <benzrf_> eacameron: what else did you expect to hear
10:28:59 <ski> <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
10:29:03 <ski> <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
10:29:08 <benzrf_> i mean that's like asking how a non-latin speaker can read latin
10:29:10 <quchen> Ah, it's a local definition.
10:29:35 <benzrf_> ski: it's merely a syntactic trick
10:29:42 <benzrf_> i wasnt saying anything about semantics
10:29:42 <benzrf_> o.o
10:30:04 <ski> eacameron : learning functional programming idioms
10:30:20 <eacameron> ski: perfect! any examples?
10:30:25 <ski> learning pattern-matching, types, recursion
10:30:32 <willem> pavonia: maybe the library is simply too limited
10:30:52 <ski> eacameron : immutability
10:31:02 <benzrf_> eacameron: ski  is basically telling you to learn haskell
10:31:09 <ski> eacameron : worker-wrapper, accumulator, continuation-passing-style
10:31:15 <ski> benzrf_ : not necessarily
10:31:15 <eacameron> benzrf_: I disagree: non-haskellers know how how to program; just not in haskell
10:31:25 <pavonia> willem: I think you just need to convert from Int to Double, try "varBds x 1.0 $ fromIntegral $ length vals"
10:31:41 <eacameron> benzrf_: maybe so, but he has hard examples ;)
10:31:48 <eacameron> *concrete
10:32:15 <ski> eacameron : typeful programming
10:32:17 <eacameron> my goal is for "reading" not being flueint
10:32:32 <eacameron> reading is much easier to accomplish than writing
10:32:36 <eacameron> ski: ohh, good one
10:32:36 <benzrf_> eacameron: if you want to read python code without learning python you need to learn something like python
10:32:39 <benzrf_> eacameron: i.e. java
10:32:55 <willem> pavonia: i have already tried that :( x shouldn't have non-integral bounds anyway, because it's an integral variable
10:33:02 <benzrf_> eacameron: if you want to read haskell code without learning haskel lyou need to learn something like haskell
10:33:05 <benzrf_> i.e. mljsimone|off
10:33:05 <benzrf_> *ML
10:33:09 <benzrf_> or just haskell itself
10:33:15 <ski> Clean
10:33:17 <ski> Mercury
10:33:19 <benzrf_> why learn ML when you could learn Haskell, if your target is haskell?
10:33:19 <ski> Erlang
10:33:20 <noprompt> 983
10:33:31 <ski> SML or OCaml, or even F#
10:33:37 <pavonia> willem: x is a String, no?
10:33:45 <eacameron> benzrf_: I see your point, but for basic stuff, I think it's possible to map things from the python world to the Haskell world
10:33:48 <ski> benzrf_ : because of the great module system in the MLs ?
10:33:49 <benzrf_> eacameron: youll need to learn the ideas anyway to understand it, so all you need to know left over is your synta
10:33:51 <benzrf_> x
10:33:51 <benzrf_> eacameron: no it isn't
10:33:53 <eacameron> not all, for sure, but enough to help
10:33:56 <benzrf_> ski: ;p
10:34:04 <benzrf_> eacameron: haskell is incredibly different from python
10:34:06 * hackagebot amqp 0.8.2 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.8.2 (HolgerReinhardt)
10:34:15 <benzrf_> moreso than python from c anyway
10:34:18 <benzrf_> by a big margin
10:34:30 <willem> pavonia: it is indeed a string, but its VarKind has also been set to IntVar (setVarKind x IntVar)
10:34:46 <ski> eacameron : it's probably not that much use to try to map details of algorithms and program logic from Python to Haskell
10:34:56 <benzrf_> eacameron: if you understand the ideas well enough to make out the languge, then that means you know the language
10:34:58 <ski> eacameron : over-all structure, perhaps
10:35:09 <eacameron> ski: that's what I'm getting at
10:35:24 <pavonia> willem: What error do you get if you change the code to what I suggested above?
10:35:36 <eacameron> I want non-haskellers to basically understand some of the ideas in my code, not necessarily know *how* or *why*
10:38:41 <willem> pavonia: i have annotated the new error at http://lpaste.net/100972
10:39:27 <pavonia> willem: No, use fromIntegral directly
10:39:56 <Fuuzetsu> edwardk: src/Control/Lens/Internal/TupleIxedTH.hs:66:18: Not in scope: ‘equalP’, GHC 7.9.20140308, latest Hackage lens
10:39:56 <Fuuzetsu>  
10:40:09 <ski> eacameron : ok
10:40:16 <edwardk> haven't tried there. open to fixes
10:40:56 <willem> pavonia: that seems to fix it, thanks...! ...but still, i hope this won't cause it to become an incorrect integer linear program
10:41:43 <Fuuzetsu> oh, I imagine it has to do with the same thing I've been chasing all day, change of Pred type, I'll have a look
10:42:48 <willem> pavonia: in any case, thank you for looking at this program...!
10:42:56 <pavonia> willem: Not sure what you're programming but if you want to calculate with Integers, why do you use LP String Double in the result type?
10:43:28 <willem> pavonia: because the objective function of the integer linear program can take values of type Double
10:43:53 <benzrf_> :t (>>=) `asAppliedTo` state undefined
10:43:53 <lambdabot> MonadState s m => m a -> (a -> m b) -> m b
10:44:06 <benzrf_> ¬_¬
10:44:16 <pyon> :t asAppliedTo
10:44:17 <lambdabot> (a -> b) -> a -> a -> b
10:44:46 <benzrf_> :t (>>=) `asAppliedTo` StateT undefined
10:44:47 <lambdabot> Monad m => StateT s m a -> (a -> StateT s m b) -> StateT s m b
10:44:53 <benzrf_> :{
10:45:03 <benzrf_> (a -> (a1, b)) -> (a1 -> b -> c) -> a -> c
10:45:10 <benzrf_> ^ state bind, right?
10:45:54 <willem> pavonia: i'm trying to solve MEP inference in bayesian networks using integer linear programs... i've already worked out the maths, only need to program it now. at first i was using python, but python's linear programming libraries seemed crappy so i rewrote it to haskell
10:47:26 <ski> benzrf_ : not quite
10:47:27 <willem> pavonia: so the objective function signifies the bayesian network's associated probability distribution
10:47:51 <ski> or, i suppose more generalized than warranted
10:48:00 <benzrf_> ski: how so?
10:48:15 <benzrf_> oh wait
10:48:23 <pavonia> willem: Oh, well, I don't know what these things are :) I guess "setVarKind x IntVar" will do the correct thing internally, though
10:48:25 <benzrf_> derp
10:48:37 <ski> (also, you're doing indexed state)
10:48:45 <rusk101> Can somebody please take a look at my algorithm for converting string to integer? http://lpaste.net/100930 I am getting the wrong output
10:48:56 <willem> pavonia: thanks for helping me out ;)
10:48:59 <benzrf_> ski: indexed?
10:49:03 <pavonia> no problem
10:49:04 <benzrf_> @pl bind f g = uncurry g . f
10:49:04 <lambdabot> bind = flip ((.) . uncurry)
10:49:12 <ski> changing the state type during the computation
10:50:27 <benzrf_> oh
10:50:28 <ski> rusk101 : `xs' is unused in `str2Integer'
10:50:35 <benzrf_> @src State (>>=)
10:50:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:50:41 <benzrf_> :{
10:51:41 <rusk101> ski: I feel like it's gettings used in the variable y
10:52:26 <ski>   runState (ma >>= amb) s0 = runState (amb a) s1
10:52:27 <ski>               where (a,s1) = runState   ma    s0
10:52:56 <ski> rusk101 : no, `y' is defined to be simply `5'
10:53:25 <rusk101> ski: I updated it. That's only the annotation
10:54:18 <ski> oh
10:54:26 <rusk101> ski: I made it base 7 so I can easily compute the string Hello
10:54:41 * ski is confused by this new update & revision business
10:55:24 <ski> rusk101 : what are you passing as inputs to `str2Integer' ?
10:55:50 <rusk101> str2Integer ['h','e','l','l','o']
10:56:07 <benzrf_> rusk101: you have it backwards
10:56:12 <benzrf_> wait no
10:56:13 <benzrf_> nvm sorry
10:56:26 <benzrf_> hold on yes u do
10:56:47 <benzrf_> rusk101: you're multiplying the next part by 7
10:56:51 <benzrf_> which is wrong
10:57:06 <benzrf_> you'd multiply by 7 if you were using an accumulator
10:57:10 <ski> rusk101 : `ord' of those characters aren't less than seven
10:57:26 <benzrf_> but with non-tail recursion, you do /not/ want to multiply the rest by 7
10:57:29 <rusk101> so i need to multiply by 7 the 2nd part? fromIntegral (ord x)?
10:57:35 <benzrf_> no
10:57:40 <benzrf_> just switch to a fold
10:58:03 <benzrf_> do you see what you're doing wrong?
10:58:03 <oOiAiOo> who use haskell?
10:58:09 <Fuuzetsu> who haskell here?
10:58:09 <benzrf_> oOiAiOo: becoz its awesome
10:58:24 <benzrf_> oOiAiOo: haskell will like
10:58:25 <benzrf_> blow ur mind
10:58:26 <oOiAiOo> ? benzrf_ what mean?
10:58:27 <rusk101> not really benzrf.
10:58:28 <benzrf_> n shit
10:58:35 <oOiAiOo> oh mistake
10:58:48 <oOiAiOo> who use Qolloquy?
10:58:58 <oOiAiOo> colloquy?
10:59:01 <Flonk> hmm.. I want to roll a "instance Alternative f => Alternative (->f a) where" instance, but get a parse error at the -> symbol. How do I denote that correctly?
10:59:16 <oOiAiOo> why there is not seen number of person?
10:59:19 <benzrf_> rusk101: well
10:59:22 <benzrf_> take "hello"
10:59:32 <benzrf_> Flonk: you want ((->) f a)
10:59:38 <benzrf_> rusk101: you're taking "ello"
10:59:41 <benzrf_> multiplying it by 7
10:59:45 <benzrf_> and adding "h"
10:59:57 <Flonk> benzrf_: wouldn't that be the same as (f a->) though?
10:59:58 <benzrf_> that's wrong innit
11:00:05 <benzrf_> Flonk: yes, but haskell doesnt support that syntax
11:00:09 <rusk101> so do i replace the str2Integer xs with str2Integer(x:xs)?
11:00:10 <benzrf_> no type sections :\
11:00:12 <joelteon> Flonk: you can't section type operators
11:00:24 <Flonk> benzrf_: I'm looking for (->f a) though
11:00:31 <benzrf_> rusk101: n-no
11:00:32 <Flonk> joelteon: thats too bad..
11:00:40 <joelteon> happens
11:00:41 <benzrf_> Flonk: ((->) f a)
11:00:49 <joelteon> benzrf_: that makes f a the first argument of (->)
11:00:54 <benzrf_> ?
11:01:00 <benzrf_> that's what you want isn't it
11:01:01 <joelteon> Flonk wants it to be the second argument
11:01:03 <joelteon> correct?
11:01:06 <rusk101> str2Integer head xs
11:01:11 <Flonk> joelteon, benzrf_ exactly
11:01:24 <joelteon> and to be completely honest, I'm not sure how to do that
11:01:26 <joelteon> I don't know if you can
11:01:45 <quchen> Maybe `type Flip f a b = f b a`  with -XTypeSynonymInstances works.
11:01:49 <Flonk> Wrapping the whole thing in a newtype seems so cumbersome..
11:01:55 <benzrf_> :{
11:01:56 <Flonk> quchen: Oh, thats cool
11:02:10 <benzrf_> there's partial application for types
11:02:19 <benzrf_> use that w/ a regular type
11:02:25 <benzrf_> *its an extension
11:03:09 <benzrf_> rusk101: i would just use a fold
11:03:12 <benzrf_> somethin like
11:03:41 <benzrf_> foldl (\acc digit -> acc * 7 + ord digit) 0
11:04:37 <rusk101> why the 0 at the end?
11:04:45 <benzrf_> that's the starting accumulator
11:04:47 <benzrf_> :t foldl
11:04:48 <lambdabot> (a -> b -> a) -> a -> [b] -> a
11:05:12 <joelteon> > foldl f a [b,c,d]
11:05:13 <lambdabot>  f (f (f a b) c) d
11:05:44 <oOiAiOo> (Show a) <------- what mean?
11:06:07 <joelteon> oOiAiOo: a is an instance of Show
11:06:21 <rusk101> could you annotate my code with that please?
11:06:22 <rusk101> http://lpaste.net/100930
11:06:25 <joelteon> you can pass a value of type 'a' to the function 'show'
11:06:26 <oOiAiOo> what is show?
11:06:28 <joelteon> and get a String back
11:06:35 <willem> or foldM (\acc digit -> let o = ord digit in if 47 < o && o < 58 then return acc * 7 + o else Left "parse error") 0
11:07:17 <oOiAiOo> joelteon: oh good thanks
11:07:45 <oOiAiOo>      :    :
11:07:51 <oOiAiOo> oOiAiOo
11:09:02 * geekosaur has itchy op finger...
11:09:26 <joelteon> geekosaur: lotion
11:12:08 <rusk101> thanks man
11:12:12 <rusk101> i got it
11:15:59 <benzrf_> @pl \a -> g a c
11:15:59 <lambdabot> flip g c
11:16:02 <benzrf_> dur
11:17:26 <rusk101> benzrf, one questions. why the digit in the (\acc digit -> ...
11:17:50 <oOiAiOo> Num is function?
11:17:51 <benzrf_> rusk101: that's the 2nd arg
11:17:57 <benzrf_> rusk101: do you know how folds worj?
11:18:00 <benzrf_> *work
11:18:13 <rusk101> foldl f a [b,c,d]
11:18:18 <rusk101> yea i saw that and i get it
11:18:28 <rusk101> f (f (f a b) c) d
11:19:55 <benzrf_> i tend to think of it as like
11:20:01 <benzrf_> the function is a machine
11:20:11 <benzrf_> that eats elements of the list one by one, adding them to its internal storage
11:20:12 <benzrf_> or something
11:20:13 <rusk101> i thought 0 was the 2nd argument
11:20:17 <benzrf_> it is
11:20:30 <benzrf_> i didnt put a list in the code i wrote
11:20:37 <oOiAiOo> benzrf_: Num is function?
11:20:40 <benzrf_> oOiAiOo: it is notdan
11:20:42 <benzrf_> *not
11:20:47 <benzrf_> it's a typeclass
11:22:16 <oOiAiOo> (Show a) <---- you can pass a value of type 'a' to the function 'show'??? you are wrong? benzrf_
11:22:24 <oOiAiOo> Show is just type class?
11:22:24 <benzrf_> what
11:22:29 <benzrf_> show is a typeclass
11:22:36 <benzrf_> :k Show
11:22:37 <lambdabot> * -> Constraint
11:22:53 <oOiAiOo> joelteon is said.
11:23:02 <oOiAiOo> oh my mistake benzrf_
11:23:17 <oOiAiOo> Show a <----- then Show is typeclass?
11:23:22 <joelteon> yep
11:23:36 <oOiAiOo> joelteon: you said it function
11:23:53 <oOiAiOo> who is right?
11:24:06 <zomg> oOiAiOo: show is a function, Show is a type class (note character case difference)
11:24:09 <ParahSailin> @src Show
11:24:09 <lambdabot> class  Show a  where
11:24:09 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:24:09 <lambdabot>     show      :: a   -> String
11:24:09 <lambdabot>     showList  :: [a] -> ShowS
11:24:31 <oOiAiOo> oh thanks zomg.
11:25:28 <oOiAiOo> show and Show ok i see.
11:25:43 <donri> Show is a type-level function that returns a Constraint given a type ;)
11:25:47 * donri helpful
11:26:29 <oOiAiOo> dori: i m confused.
11:26:33 <oOiAiOo> who right?
11:26:38 <quchen> Ignore what donri said.
11:26:53 <oOiAiOo> ok i see.
11:26:55 <fizbin> oOiAiOo: donri is just being cute and difficult.
11:27:08 <Kiemo> is it possible to make emacs haskell-mode to show type of function near cursor? e.g slime for lisp shows what arguments function accpets under modeline
11:27:09 <donri> <3
11:27:11 <oOiAiOo> ok i see
11:27:22 <levi> Some things that are not wrong are also not very helpful. ;)
11:27:28 <donri> Kiemo: ghc-mod does that i think
11:27:32 <peddie> Kiemo: I think ghc-mod does that for me
11:27:47 <Kiemo> donri, peddie thanks!
11:28:00 <benzrf_> Kiemo: i set that u in vim using ghc-mod-vim
11:28:09 <benzrf_> *ghcmod-vim
11:28:58 <solarus> Kiemo: just load the file with C-c C-l then do C-c C-t to get the type under point
11:29:06 <levi> Kiemo: It may take a bit of configuration to get it to display automatically for all functions. I think my emacs currently only looks up the type of a user-defined expression when I hit C-c C-t
11:29:16 <rusk101> Is there a function in Haskell that breaks apart an integer into a list of integers of size n? for example, breakList 3 123456789 = [123,456,789]?
11:29:32 <solarus> dosent work for let bound variables etc
11:30:02 <quchen> rusk101: You can write it yourself using unfoldr
11:30:14 <donri> solarus: you sure? should work for local expr...
11:30:30 <levi> I'm pretty sure it does work for local expressions
11:31:02 <levi> ghc-mod and hdevtools tend to break on me after a while, though. :/
11:31:18 <solarus> donri: probably with a newer version of haskell-mode than I have then :)
11:31:36 <donri> duno haskell-mode, but ghc-mod should handle it
11:31:46 <rusk101> I dont think i have unfoldr in my ghci
11:31:57 <donri> @hoogle unfoldr
11:31:58 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:31:58 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
11:31:58 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
11:33:15 <rusk101> <interactive>:11:1:     Not in scope: `unfoldr'     Perhaps you meant `foldr' (imported from Prelude)
11:33:48 <rusk101> nvm
11:33:50 <rusk101> thanks
11:34:03 <Flonk> quchen: I'm at a loss
11:34:37 <Flonk> quchen: "Alternative f => Alternative (Flip (->) (f a))" doesn't parse because Flip only has 2 type parameters, and Alternative of course needs kind * -> *
11:35:29 <levi> solarus: ghc-mod has its own minor mode that augments haskell-mode, actually. It's the 'ghc' minor mode.
11:37:23 <quchen> Flonk: Hmm right, type synonyms need to be fully applied. Well then you'll need to wrap your type I think.
11:41:05 <peteretep> data HTTPResponse a = HTTPResponse Int a -- how do I constrain a to say it needs to be an instance of Show?
11:42:26 <quchen> You don't restrict data types with constraints, you restrict the functions.
11:42:46 <peteretep> fine, thanks
11:44:18 <Haskell_Noob> Hello all... I have a tricky question at hand
11:46:03 <Haskell_Noob> Let's say I have a list [[1,2,3], [1,2,3]]. I want to write function that takes an operation (eg. * or +) and applies it to the elements of the list.
11:46:15 <Haskell_Noob> Basically I want to rewrite ZipWith
11:46:24 <fizbin> @type Data.Text.pack
11:46:25 <lambdabot> String -> Data.Text.Internal.Text
11:46:58 <fizbin> > Data.Text.pack "asdf"
11:46:59 <lambdabot>  Not in scope: `Data.Text.pack'
11:46:59 <stelleg> @src getLine
11:46:59 <lambdabot> getLine = hGetLine stdin
11:47:03 <quchen> Haskell_Noob: That's not a tricky question. In fact you didn't evenask a question :-þ
11:47:09 <peteretep> Haskell_Noob: Do your operations and list types form monoids?
11:47:11 <stelleg> @src hGetLine
11:47:11 <lambdabot> Source not found. It can only be attributed to human error.
11:47:30 <quchen> Haskell_Noob: Did you try something already we can help you with? It's hard to guess where to help without spoiling the solution of how zipWith is implemented.
11:47:31 <hseg> Is there a function reify :: (forall a. Eq a => S a -> T a) -> (forall a. (a -> a -> Bool) -> S a -> T a), or some way to write it?
11:47:34 <ricky_clarkson> :t zipWith
11:47:35 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:47:50 <benzrf_> Haskell_Noob: are you trying to do it for functions of arbitrary arity?
11:47:53 <ricky_clarkson> Haskell_Noob: Does your type differ from zipWiths?
11:48:22 <peteretep> Let the man finish!
11:49:01 <hseg> I do know that the inverse is possible, it's ($(==))
11:49:12 <hseg> :t ($(==))
11:49:13 <lambdabot> Eq a => ((a -> a -> Bool) -> b) -> b
11:49:46 <beaky> hello
11:49:52 <hseg> Hey beaky
11:49:55 <beaky> how do i apply functional programming techniques in other languages like java
11:49:56 <supki> hseg: do you want to construct Eq instance in runtime from a (:: a -> a -> Bool) function?
11:49:58 <beaky> which are dysfunctional
11:50:19 <peteretep> http://lpaste.net/100979 -- I understand the problem but not the solution
11:50:22 <hseg> supki: Yeah.
11:50:25 <peteretep> quchen: ^^ any advice appreciated
11:50:31 <supki> hseg: take a look at reflection package
11:50:35 <supki> it does basically this
11:50:38 <hseg> supki: Or reify a function into a class instance.
11:50:40 <supki> @hackage reflection
11:50:40 <lambdabot> http://hackage.haskell.org/package/reflection
11:51:01 <hseg> supki: Question: would I have to rewrite the function I'm passing the dictionary to?
11:51:18 <fizbin> beaky: Stop badmouthing non-functional stuff as "dysfunctional", then if you really care about java look into all the ways to use the guava library.
11:52:41 <fizbin> peteretep: You need a (Show a) => after the word "instance" on line 3.
11:53:05 <peteretep> fizbin: perfick, thanks
11:53:20 <supki> hseg: I guess it would be something like (forall a. Reifies s (Eq_ a) => Proxy s -> S a -> T a)
11:53:55 <supki> hseg: where  newtype Eq_ a = Eq_ { eq :: a -> a -> Bool }
11:54:00 <hseg> supki: Specifically, my function is choose :: [[a]] -> a -> [[a]]
11:54:05 <ricky_clarkson> beaky: The functionaljava library might be worth a glance too, but it's used by far fewer people and not maintained as well as guava is.
11:54:17 <hseg> supki: s/::/:: Eq a =>/
11:54:19 <ricky_clarkson> beaky: If you can, look at Java 8's streams too.
11:56:19 <ski> peteretep,fizbin : or `Show a => '
11:56:55 <fizbin> Is it possible to turn a string into a Text in what lambdabot knows about?
11:57:21 <Rarrikins> fizbin: What?
11:57:31 <fizbin> @type Data.Text.pack
11:57:32 <lambdabot> String -> Data.Text.Internal.Text
11:57:42 <Rarrikins> > Data.Text.pack "zomg"
11:57:42 <fizbin> > Data.Text.pack "What?"
11:57:43 <lambdabot>  can't find file: L.hs
11:57:44 <lambdabot>  Not in scope: `Data.Text.pack'
11:58:21 <Rarrikins> Lies!
11:58:21 <fizbin> > text "what?"
11:58:21 <lambdabot>  what?
11:58:21 <fizbin> Ha.
11:59:53 <fizbin> > text$ap(++)show"> text$ap(++)show"
11:59:54 <lambdabot>  > text$ap(++)show"> text$ap(++)show"
12:00:22 <fizbin> Good thing lambdabot puts an extra space in front of the output. Or that it doesn't listen to itself.
12:01:00 <haskellelephant> It seems that DisambiguateRecordFields  acts weird, what is the problem here: http://lpaste.net/8062
12:01:19 <Rarrikins> > text$ap(++)show"zomg"
12:01:20 <lambdabot>  zomg"zomg"
12:02:18 <haskellelephant> >putStrLn "> putStrLn \"no recursion\""
12:02:32 <haskellelephant> > putStrLn "> putStrLn \"no recursion\""
12:02:33 <lambdabot>  <IO ()>
12:02:42 <fizbin> Nice try...
12:03:20 <haskellelephant> > putStrLn "WAT"
12:03:21 <lambdabot>  <IO ()>
12:03:37 <haskellelephant> > show "WAT"
12:03:38 <lambdabot>  "\"WAT\""
12:03:39 <fizbin> lambdabot isn't ghci.
12:04:03 <haskellelephant> lambdabot treats show and putStrLn differently also...
12:04:24 <Rarrikins> > show . show . show $ "WAT"
12:04:25 <lambdabot>  "\"\\\"\\\\\\\"WAT\\\\\\\"\\\"\""
12:04:58 <triliyn> haskellelephant: show and putStrLn are completely different things
12:05:02 <fizbin> haskellelephant: Well, why shouldn't it? show and putStrLn have totally different types.
12:05:16 <triliyn> :t show
12:05:17 <lambdabot> Show a => a -> String
12:05:20 <triliyn> :t putStrLn
12:05:20 <lambdabot> String -> IO ()
12:05:40 <oOiAiOo> i don't understand it    (Ord a) => a -> a -> Ordering    what is Ordering?
12:05:40 <Rarrikins> :t print
12:05:41 <lambdabot> Show a => a -> IO ()
12:05:55 <geekosaur> @src Ordering
12:05:56 <lambdabot> data Ordering = LT | EQ | GT
12:05:59 <Rarrikins> oOiAiOo: data Ordering = LT | EQ | GT
12:06:05 <fizbin> data Ordering = LT | EQ | GT 	-- Defined in `ghc-prim:GHC.Types'
12:06:30 <fizbin> > print "WAT"
12:06:31 <lambdabot>  <IO ()>
12:06:39 <fizbin> See? All is right.
12:06:52 <Rarrikins> > text "hello"
12:06:53 <lambdabot>  hello
12:06:55 <oOiAiOo> oh i see Ordering is GT or EQ or LT?
12:06:58 <oOiAiOo> ok good.
12:07:02 <certainty> so i'm looking at "Real World Haskell" Chapter 11. It's about testing with quickcheck. The examples generate a Doc. Isn't there a chance that the generation runs forever because it repeates to create unions or concatenations of docs?
12:07:41 <stelleg> if a function has a # at the end of it then its an STG primitive in GHC, right?
12:07:57 <stelleg> and by function I mean variable
12:08:14 <triliyn> certainty: assuming it chooses a constructor independently at each step, the probability of running for n steps vanishes as n approaches infinity
12:13:37 <peteretep> http://lpaste.net/100980 -- I could do with a hand again if anyone has a minute
12:13:47 <peteretep> I don't really understand what (a ~ HTML) means
12:14:00 <levi> It's a type equality constraint
12:14:02 <certainty> triliyn: i see that, but in reality it may hit a limit much quicker maybe because it ran long enough to fill up all memory. I'm just asking because i'm doing something similar in another language and I do have that kind of problem :)
12:14:11 <Cale> peteretep: It means that the type variable a is equal to HTML
12:14:12 <klrr_> i think it means that a is not HTML, but needs to be
12:14:21 <Cale> I don't really know why they went with ~ instead of = for that
12:14:30 <peteretep> ah, so, line 10 needs to be uncommented for that to happen
12:14:44 <peteretep> (for that error to throw)
12:14:46 <Cale> peteretep: It means your type signature is too generic
12:14:50 <Kiemo> how function for cyclying monadic stuff is called? bascially i want something like sequence.cycle
12:15:06 <Cale> peteretep: You said that it should work for any type a, but apparently your implementation only works when a = HTML
12:15:10 <haskellelephant> fizbin: Sorry, I was thinking about print, had a brainfart
12:15:13 <quchen> Kiemo: There's `forever`, but that discards intermediate results.
12:15:17 <triliyn> certainty: if you're actually having that problem, of course, that trumps my intuitive speculation. It seems strange to me that the problem would arise though!
12:15:28 <peteretep> Cale: I would like it to work for any `a` and don't see why my definition forces it to be `HTML`
12:15:49 <triliyn> I guess if there are many more types of "continuable" constructors than there are "finished" constructors, the probability of stopping at any given step is low
12:15:49 <peteretep> oh, maybe I do
12:15:56 <haskellelephant> Is it possible to use DisambiguateRecordFields  on fields in the same module?: http://lpaste.net/8062
12:16:08 <triliyn> And at any given time there are multiple places you could continue from...
12:16:14 <Umschwung> To those interested, I made a Haskell wallpaper: http://imgur.com/FYvbuZD.
12:16:26 <peteretep> If I try and work out what the type signature of ct would be
12:16:27 <certainty> triliyn: could well be an error on my side :) i'll investigate more
12:16:29 <certainty> thanks
12:16:30 <peteretep> I start to understand my issue
12:16:52 <peteretep> Umschwung: I like that
12:17:01 <dwat3r> hi guys,can you give a hint how to think about implementing quicksort via parallel computations?
12:17:16 <Cale> peteretep: Actually, that is sort of confusing, looking at it. Let me try this.
12:17:32 <peteretep> Cale: Thanks. I feel less confused now, but I'm probably wrong
12:17:35 <dwat3r> I'm trying to use the par monad :)
12:17:58 <Cale> peteretep: Which library are wrap, B and S from?
12:18:09 <peteretep> Cale: I've defined them earlier up my file
12:18:28 <peteretep> Please ignore the Q&A format, it's all my own work:
12:18:29 <peteretep> http://lpaste.net/100981
12:18:46 <Cale> peteretep: Well, if I comment out sample, then the code fragment you gave there will compile for me
12:18:48 <Kiemo> quchen: yeah, but i need result
12:18:55 <Cale> peteretep: So something weird is going on.
12:19:12 <peteretep> Cale: Have you uncommented -- ct (HTML_
12:19:16 <Cale> oh
12:19:19 <Cale> No :)
12:19:24 <peteretep> sorry!
12:19:37 <Cale> If you match against HTML there, then for sure ct will have to take a parameter of type HTML
12:19:43 <peteretep> I feel like I would struggle to define a valid type signature for `ct`
12:19:53 <Cale> (or whatever type it is that the HTML data constructor comes from)
12:19:55 <peteretep> Cale: I think I understand that
12:20:16 <peteretep> Cale: See: http://lpaste.net/100982 for my whole file
12:20:40 <Cale> peteretep: If you want to make this printHTTPResponse behave differently at different types 'a', then you'll want to define a type class.
12:21:00 * peteretep was thinking an alias one
12:21:30 <peteretep> uh, I mean: using `type` rather than `data
12:21:31 * peteretep tries it
12:22:28 <Cale> class (Show a) => MIME a where mimeType :: a -> String; instance MIME HTML where mimeType _ = "text/html"; instance MIME String where mimeType _ = "text/plain"
12:22:50 <peteretep> yes yes yes
12:22:55 <peteretep> I misread what you wrote at first
12:23:01 <peteretep> and then thought "I could define a new type class"
12:23:04 <peteretep> and then realized you'd done that
12:23:06 <peteretep> Thanks :D
12:23:18 <peteretep> I might make defining that Q2 instead
12:23:45 <Cale> Or obviously, you could just add a parameter to printHTTPResponse for the MIME type
12:23:54 <peteretep> nah
12:23:59 <peteretep> less fun
12:24:06 <Cale> The type class just helps make that choice automatic
12:24:30 <peteretep> This is only ever going to be a toy. I'm trying to build it up to serve very simple HTTP requests
12:27:42 <quchen> peteretep: Semi-related, this might be helpful: https://github.com/for-GET/http-decision-diagram/blob/master/httpdd.png
12:27:48 <quchen> Depending on your definition of "simple".
12:28:31 <peteretep> quchen: Dramatically simpler :D
12:28:48 <peteretep> quchen: I am a bit ahead of my dev team at learning Haskell, and I am writing myself and them simple exercises to solve
12:29:04 <peteretep> quchen: We've done a bunch of Monad ones, and now I am trying to get more and more "real world" problems solved
12:29:10 <peteretep> The format is simple exercises and simple answers
12:29:11 <quchen> Then stay the hell away from that picture I sent you :-þ
12:29:16 <peteretep> got it
12:30:19 <peteretep> :r
12:30:22 <quchen> I just added a section about constrained types to my FAQ because of your question earler, by the way. I'm just not sure how right it is, but thanks for asking it anyway.
12:30:45 <quchen> It was one of those "we get this question a lot" questions, but I didn't realize it until an hour ago :-)
12:30:45 <peteretep> Illegal instance declaration for `MIME String' -- I have a memory that this is a PITA to solve and I don't want to
12:30:53 <peteretep> quchen: Excellent :)
12:32:36 <peteretep> oh oh, I know the solution
12:32:42 <peteretep> Turns out I need to read error messages better
12:34:21 <quchen> … or get used to the error messages more. "No instance X for <something with '->' in it>" most likely means "you forgot an argument", for example. :-)
12:34:46 <peteretep> In this case I am trying to make a string an instance of a type class and running in to inflexible instances
12:35:58 <quchen> peteretep: String = [Char], literally.
12:36:20 <peteretep> quchen: I know. But then the second part bites me
12:36:47 <peteretep> instance MIME [Char] where mt = "text/plain" -- disallowed
12:37:10 <quchen> You should probably be using Text instead of String here anyway.
12:37:30 <peteretep> where: data Text = Text String ?
12:37:47 <quchen> Where Text is from the 'text' module. It's for storing text.
12:37:54 <peteretep> oh
12:38:22 <quchen> String really just exists because it's easily defined and used in basic Haskell, but a singly linked list of single characters is just an awful way of dealing with text.
12:39:10 <quchen> Text is widely used and mature, so don't hesitate from using it. The API is fairly similar to how you would manipulate String as well.
12:39:22 <peteretep> thanks
12:39:46 * mr- wonders if Text uses String internally :-)
12:40:31 <oOiAiOo> http://lpaste.net/100983
12:40:36 <oOiAiOo> i don't know it?
12:41:06 <quchen> mr-: No.
12:42:00 <merijn> mr-: Text uses dense UTF-16 encoded binary blobs internally
12:42:38 <mr-> Yeah, I've just checked. There's some ByteArray# going on
12:42:52 <Earnestly> If it's UTF-16, how does it deal with surrogates?
12:43:20 <quchen> Earnestly: It's *internally* UTF-16. The API is independent of that.
12:43:31 <Earnestly> Hmm
12:44:04 <quchen> Earnestly: For generating Text from binary sources, there are various encoding functions, see the Text.Encoding module.
12:44:21 * hackagebot reform 0.2.4 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.4 (JeremyShaw)
12:45:33 <oOiAiOo> http://lpaste.net/100983   <----- what's wrong. i don't know it?
12:46:53 <Earnestly> quchen: I see
12:46:55 <Earnestly> Thanks
12:47:00 <oOiAiOo>   : :
12:47:02 <oOiAiOo> oOiAiOo
12:47:26 <ReinH> oOiAiOo: don't do that
12:47:34 <oOiAiOo> ok i see.
12:47:49 <ReinH> oOiAiOo: if your function is in a module then you might not have exported it
12:48:03 <ski> oOiAiOo : also `(x:_) -> x' can be simplified to `x:_ -> x'
12:49:02 <oOiAiOo> :(
12:50:57 <acomar> hey all
12:51:30 <acomar> trying to get this toy dfa example to compile, but I can't figure out what type signature I need to give to make it work: https://gist.github.com/arjuncomar/9472834
12:52:15 <acomar> (I would love to move startNode into the DFA class, but that causes even more issues)
12:52:28 <c_wraith> acomar: could you put the error message in a comment at the end?
12:52:35 <acomar> yea, one sec
12:53:02 <acomar> added
12:54:13 <ski> `acceptNodes :: S.Set n' doesn't mention `i'
12:54:14 <c_wraith> acomar: ack.  markdown interfered with the printing of the messages.
12:54:15 <acomar> adding a type signature to acceptNodes does not fix the issue, it simply magnifies it as the types fail to unify
12:54:53 <ski> acomar : you might want to normalize your relations
12:55:13 <acomar> ski: I figured that was the answer, I was hoping to avoid it :/
12:55:28 <acomar> ski: this seems like the most natural interface
12:55:46 <c_wraith> acomar: you could fake it with a functional dependency.
12:55:55 <benzrf> i managed to figure out the Cont monad about 80% on my own based on learning about delimited continuations from the ruby lib
12:55:57 <benzrf> =D
12:55:58 <benzrf> i feel smart
12:56:10 <c_wraith> acomar: class DFA n i | n -> i where ...
12:56:30 <acomar> c_wraith: thanks, I had a feeling that's what I needed
12:56:35 <c_wraith> acomar: Honestly, I wouldn't involve a class in that at all.
12:56:40 <ski> acomar : one version is adding a functional dependency. another is to decompose your relation into two (4NF decomposition or something ?)
12:56:43 <Umschwung> Here's the wallpaper I mentioned earlier in various resolutions: http://umschwung.deviantart.com/art/Keep-Calm-and-Curry-On-439527452.
12:56:48 <acomar> c_wraith: how so?
12:57:15 <benzrf> Umschwung: jesus christ that meme is overdone
12:57:22 <ski> acomar : since you only use one instance here, it's not clear you actually need any type class
12:57:27 <c_wraith> acomar: I'd make DFA a record that stores two functions, instead of a class.
12:57:35 <Umschwung> benzrf: Then don't use the wallpaper, simple as that. ;)
12:57:43 <benzrf> c_wraith: DFA?
12:57:52 <ski> Deterministic Finite Automatoc
12:57:53 <benzrf> Umschwung: =p
12:57:56 <ski> s/toc/ton/
12:57:56 <benzrf> o:
12:58:00 <c_wraith> acomar: that has the benefit of allowing multiple different DFAs that work on the same types
12:58:02 <acomar> c_wraith: yea, I'll write up that version as well. This is mostly for self-educational purposes
12:58:15 <acomar> not for anything pratical
12:58:21 <acomar> *practical
12:58:37 <c_wraith> acomar: remember, classes make the most sense when there's only a single meaningful instance for types that implement them.
12:58:42 <ski> self-edification isn't practical ?
12:58:53 <acomar> ski: fair enough :)
12:59:00 <acomar> c_wraith: good point, thanks!
12:59:40 <c_wraith> acomar: admittedly, most classes don't meet that criterion - but it's something to keep in mind. :)
13:00:06 <quchen> c_wraith: The line is blurry though. Consider PrimMonad, which is IO and ST.
13:00:48 <benzrf> primmonad?
13:00:49 <c_wraith> quchen: that's the opposite - there are only 2 types that make sense, not being multiple ways it can make sense for each type
13:00:52 <benzrf> also
13:00:55 <benzrf> wtf is a module
13:00:58 <benzrf> *like in ml
13:01:01 <benzrf> i hear about them o.o
13:03:02 <ski> benzrf : imagine a module taking another module as an argument
13:04:40 <benzrf> i confuse
13:04:55 <benzrf> o wait
13:05:00 <levi> benzrf: ML modules are like Haskell modules, except you can parameterize them.
13:05:02 <benzrf> so kind of like a struct
13:05:05 <benzrf> ?
13:05:26 <levi> Well, 'struct' is one of the keywords for building ML modules
13:05:31 <benzrf> lol
13:05:36 <merijn> benzrf: A struct that can be parameterised over one or more other structs
13:05:39 <benzrf> ski: so they're like maps of functions, but with first-class syntax?
13:05:59 <ski> not related to syntax
13:06:10 <ski> they're maps over modules
13:06:11 <levi> They're a separate language for building module-level stuff at compile-time.
13:06:21 <ski> where modules can include both values and types
13:06:33 <levi> (except in more advanced forms where you have first-class modules)
13:06:41 <benzrf> i confuse :[
13:06:45 <ski> (OCaml, and i think SML/NJ, also experimentally allows constructing modules at run-time)
13:07:00 <isaacbw> what's the live-coding tooling like? Anything similar to lisp's swank/slime? I saw IHaskell. I suppose an emacs repl+mode could be built on top of it?
13:07:11 <levi> benzrf: OK, step back and start with the Haskell concept of a module.
13:07:30 <benzrf> a namespace for values
13:07:41 <levi> benzrf: Now, imagine that you want to create a module that implements the concept of a map/dictionary.
13:08:01 <benzrf> uhmm
13:08:05 <benzrf> like Data.Map, you meandi_ ?
13:08:07 <benzrf> *mean
13:08:08 <levi> Yeah
13:08:30 <benzrf> ok
13:09:24 <ski> isaacbw : i (unfortunately) don't think there's anything comparable to Slime. "Types and Reflection" by Lauri Emil Alanko in 2004 at <http://lambda-the-ultimate.org/node/219> might be interesting, though
13:09:25 <merijn> isaacbw: Personally I mostly just use ghci and occasionally ":r" (reload) the file after I edit stuff
13:09:29 <levi> Except you don't want to fix the types it uses; you want to be able to specify *at the use site* which concrete types are being used. So, instead of just importing the module, you'd import it with a bit of syntax that says which types will be used.
13:10:01 <HowToAdd> Hi everyone!
13:10:09 <ski> isaacbw : lambdabot obviously has something to allow it to (compile and) load code send to it interactively
13:10:13 <Iceland_jack> Hey HowToAdd
13:10:19 <Iceland_jack> Is that your question? :)
13:10:24 * ski multiplies HowToAdd
13:10:53 <HowToAdd> haha
13:10:59 <HowToAdd> no actually
13:11:02 <benzrf> levi: hmm, i think i see
13:11:08 <HowToAdd> Here's my code: http://lpaste.net/737374785834582016
13:11:13 <benzrf> levi: so kinda like generic classes in javawizard ?
13:11:14 <benzrf> *java
13:11:17 <levi> benzrf: So your module has to define the set of parameters it needs to be instantiated; in this case, you probably need the key type, the value type, and perhaps an ordering function or hash function on the key types.
13:11:30 <HowToAdd> My second line is where the trouble is
13:11:41 <Iceland_jack> HowToAdd: Why do you do 'head x'?
13:11:46 <Iceland_jack> What do you suppose the type of 'x' is
13:11:59 <HowToAdd> That's what I was wondering
13:12:02 <levi> benzrf: You describe the ones you want to use at the use site, and the module system ensures that the implementation of the module at the use site then uses those types.
13:12:02 <HowToAdd> a is a number
13:12:13 <HowToAdd> Iceland_jack: a is a number, x is a list
13:12:22 <HowToAdd> Iceland_jack: how can I add a to [x]?
13:12:28 <merijn> HowToAdd: So you fold only works on lists of lists?
13:12:32 <merijn> *your
13:12:34 <Iceland_jack> HowToAdd: You probably want to omit the 'head'
13:12:45 <isaacbw> merijn: the nice thing about swank/nrepl is that you can leave the process running and reconnect
13:12:50 <isaacbw> to it later
13:12:58 <Iceland_jack> When you do
13:12:58 <Iceland_jack>     foo [x] = ...
13:12:58 <Iceland_jack> 'x' is the first (and only) element of [x]
13:12:58 <levi> benzrf: You can see how Haskell solves this sort of problem via type classes and a weaker module system, but sometimes it's nice to be able to explicitly parameterize modules the ML way.
13:13:17 <benzrf> mmaruseacph2:
13:13:18 <benzrf> *mm
13:13:29 <HowToAdd> Iceland_jack: I see!
13:13:38 <Iceland_jack> > let [x] = [102] in x -- HowToAdd
13:13:39 <lambdabot>  102
13:14:03 <Iceland_jack> So what you're really doing when you say 'head x' is telling Haskell that [x] is a list of lists
13:14:22 <HowToAdd> Iceland_jack: ohhhh
13:14:34 <HowToAdd> Iceland_jack: Thanks, I'll make some tweaks
13:15:02 <hseg> Trying to understand the reflection package. Brain has been broken over and over by the attempts.
13:15:04 <Iceland_jack> HowToAdd: Please do! :) and try removing the last case and see if it works as expected for the two base cases
13:15:36 <merijn> isaacbw: I don't really understand the advantage of that?
13:15:39 <hseg> Can someone suggest a source to read up on using Rank-2 types, especially for ST and reflection?
13:15:51 <HowToAdd> Iceland_jack: Will do :)
13:15:53 <q66> l
13:16:27 <HowToAdd> Iceland_jack: Modified code: http://lpaste.net/5864758738673467392
13:16:42 <levi> benzrf: I'm not familiar with javawizard.
13:16:51 <merijn> hseg: This seems a reasonable quick intro: http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
13:16:52 <hseg> Or the other stuff I should know before I look at these kind of things? I understand what Rank-2 types *are*, just not the way they're used in ST and reflection.
13:17:01 <HowToAdd> Iceland_jack: Running foldL (+) 2 [1] gives this error: No instance for (Num [a0]) arising from a use of `+'
13:17:02 <merijn> hseg: Oh, that's easier
13:17:22 <benzrf> levi: i meant java
13:17:29 <benzrf> levi: javawizard is a user, autocomplete mistake =p
13:17:29 <merijn> hseg: All ST operations are polymorphic in 's', right?
13:17:46 <merijn> hseg: The trick is the type of runST
13:17:51 <hseg> Right. Well, at least as far as I could tell. Nothing uses s
13:18:02 * javawizard is also a sorcerer of coffee
13:18:09 <ski> hseg : perhaps check out "Lazy Functional State Threads" by John Launchbury,Simon L. Peyton Jones in 1994-04-10 at <http://research.microsoft.com/en-us/um/people/simonpj/Papers/lazy-functional-state-threads.ps.Z> for `ST' ?
13:18:23 <merijn> hseg: Actually, yes, follow ski's link
13:18:35 <merijn> hseg: Because I'd just be summarising it badly anyway :)
13:18:44 <hseg> That could work. How do I read such a file? It's a .ps.Z
13:18:58 <ski> Evince can probably read it
13:19:11 <merijn> .ps is just postscript
13:19:12 <HowToAdd> Iceland_jack: do I need to cast [x] as a number?
13:19:15 <ski> `gv' can read it for sure
13:19:25 <ski> hseg : there is no cast in Haskell
13:19:29 <ski> er
13:19:29 <merijn> citeseer has a cached PDF link, though
13:19:31 <ski> HowToAdd ^
13:19:31 <merijn> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=C0CAB2C2C726F98583A3A05C54D666F4?doi=10.1.1.50.3299&rep=rep1&type=pdf
13:19:54 <Iceland_jack> HowToAdd: My connection is wonky, wait a sec
13:19:59 <merijn> hseg: For future reference, Google Scholar is pretty good at finding free PDFs for papers
13:19:59 <benzrf> javawizard: i thought there werent sourcerers anymore?
13:20:00 <benzrf> :)
13:20:03 <hseg> merijn: Thanks.
13:20:19 <javawizard> benzrf: Just the one
13:20:20 <levi> benzrf: Well, generics in Java are more like parametric polymorphism in Haskell and ML. Modules in ML have parametric polymorphism, but for types in module signatures.
13:20:24 <HowToAdd> ski: Interesting
13:20:24 <javawizard> And now you've met him. Feel proud.
13:21:06 <benzrf> levi: it just seemed to me that classes are more like haskell's modules than its types
13:21:32 <HowToAdd> Iceland_jack: alright thanks
13:21:35 <Zenkeku> Does anybody here use haskell-mode for emacs?
13:21:42 <davidfetter_disq> is there a n00b version of the differences among different functional languages?
13:21:45 <Zenkeku> I have a question related to that.
13:22:07 <davidfetter_disq> so far, anecdotally, i have: Agda: for people who think Haskell is too popular
13:22:10 <levi> benzrf: If you are talking about Java classes, then it's true that OOP classes tend to conflate a bunch of things that don't necessarily need to be connected.
13:22:43 <benzrf> mhm
13:22:44 <levi> davidfetter_disq: That's not a really fair assessment of Agda.
13:22:50 <ski> davidfetter_disq : some are strict, some are non-strict. some are statically typed, some are not. some have side-effects, some doesn't. some have pattern-matching built-in, some doesn't
13:22:57 <geekosaur> there are undoubtedly snarky ones like that around
13:23:20 <Iceland_jack> HowToAdd: So you're returning different types
13:23:27 <levi> benzrf: Classes in Java are a module/namespace thing, a type-generating thing, supply subtyping polymorphism, etc.
13:23:29 <HowToAdd> Iceland_jack: Really?
13:23:31 <davidfetter_disq> levi, i was not presenting it as fair or accurate. it's what i've got so far, which is clearly inadequate
13:23:43 <haasn> @seen illissius
13:23:43 <lambdabot> ilLISSIuS
13:23:46 <haasn> Oh no
13:23:49 <haasn> that's @leet?
13:23:51 <ski> there is no `seen'
13:23:55 <Iceland_jack> In the empty-case you're returning an empty list: []
13:23:55 <Iceland_jack> In the singleton-case you want to return a number: 2 + 1
13:23:58 <haasn> and preflex isn't here either. Now what?
13:24:24 <levi> davidfetter_disq: Agda is one of a set of dependently-typed functional languages, which happens to have a more Haskell-like syntax than some others.
13:24:26 * hackagebot wai-predicates 0.3 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.3 (ToralfWittner)
13:24:40 <geekosaur> you lose, apparently. lambdabot lost @seen years ago (it was rather broken)
13:24:41 <Iceland_jack> HowToAdd: You can fix that by returning a singleton list in the second case
13:24:41 <Iceland_jack>     foldL f a [x] = [f a x]
13:24:41 <Iceland_jack>  
13:24:44 <HowToAdd> Iceland_jack: I should return in the empty-case then
13:24:51 <HowToAdd> Iceland_jack: I should return 0**
13:24:59 <Iceland_jack> HowToAdd: Normally you let the user specify that
13:25:04 <HowToAdd> Iceland_jack: Oh I see
13:25:10 <pavonia> haasn: http://ircbrowse.net/browse/haskell?events_page=1&q=illissius
13:25:16 <haasn> pavonia: thanks!
13:25:17 <Iceland_jack> Since different operations have different 'zeros' (identities)
13:25:28 <Iceland_jack> > foldl (+) 0 [1,2,3,4] -- summing would have 0
13:25:29 <lambdabot>  10
13:25:31 <HowToAdd> Iceland_jack: Yes I just realized
13:25:42 <Iceland_jack> > foldl (*) 1 [1,2,3,4] -- but finding the product..
13:25:43 <lambdabot>  24
13:26:03 <levi> benzrf: Anyway, ML's 'struct' is a bit like Haskell's 'module', except that 'module' also has an export specification built into its syntax, while ML has 'sig' as a separate syntactic construct for describing the exported interface.
13:26:04 <Iceland_jack> We wouldn't want a product whose base case is 0 :)
13:26:16 <ski> > foldr (&&) True ([True,True,False] ++ repeat True)
13:26:17 <lambdabot>  False
13:26:21 <HowToAdd> Iceland_jack: haha yeah that makes total sense
13:26:57 <HowToAdd> Iceland_jack: what if I wanted to return a number instead of a list?
13:27:15 <Iceland_jack> Then you change the base case
13:27:23 <Iceland_jack> (empty list [])
13:27:26 <levi> benzrf: And ML additionally has the 'functor' construct in this module language, which is like a compile-time function from structs to structs.
13:27:31 <Iceland_jack> You can return 'a' and make that the identity
13:27:57 <HowToAdd> Iceland_jack: that's a great point about the identity
13:27:58 <HowToAdd> Thanks
13:28:03 <HowToAdd> :)
13:28:09 <Iceland_jack> Glad it helped
13:28:56 <levi> benzrf: And the 'functor' construct is how you'd specialize a Map module to a Map from Strings to Ints that uses alphabetic comparison of the strings for ordering, for example.
13:28:57 <ReinH> Iceland_jack: monoids ftw
13:29:16 <rand_> hello all, could someone give advice on how to find source of function for some package on hackage?
13:29:26 <levi> benzrf: Hopefully that makes sense.
13:29:38 <mr-> rand_: what package?
13:29:55 <geekosaur> cabal unpack packagename
13:29:56 <rand_> http-conduit, function "http" - can't find it in source
13:30:03 <edwardk> davidfetter_disq: agda is a proof assistant you can occasionally use to run real code. haskell is a general purpose programming language. the former incudes things that would be painful to program with every day in haskell. compared to say, coq, i find that agda code tends to be better factored because you write proofs by hand, but more brittle, because if you make structural changes in the code old proofs are often unsalvageable
13:30:03 <edwardk>  unlike old tactics
13:30:04 <ion> rand: http://hackage.haskell.org/package/base or whatever the package is, click on module, click on “Source”. Or hoogle for the function, https://www.fpcomplete.com/hoogle
13:30:05 <levi> benzrf: For how that sort of thing might play out in Haskell, take a look at the Backpack papers.
13:30:12 <ion> rand: Or what geekosaur said
13:30:31 <edwardk> davidfetter_disq: that said, i'm not an expert in coq or agda, so my experience may not be indicative
13:30:46 <rand_> ion - seems like this function is not in source file - maybe reexported?
13:30:56 <ski> isaacbw : does that help ?
13:31:48 <ski> benzrf,levi : it's possible to simulate functors in Haskell, sortof, by using existentials
13:31:56 <edwardk> davidfetter_disq: in my experience agda code is really really nice to read, while, say, coq, seems to survive the vagaries of use more, if you can stomach the tactic language and style.
13:32:11 <ReinH> edwardk: hai
13:32:15 <edwardk> heya ReinH
13:32:24 <isaacbw> ski: I haven't read through it yet, but the summary looks promising
13:34:00 <ski> isaacbw : i suppose if you have specific questions about the paper, Lor seems to be online here
13:34:01 <mr-> rand_: it's from http://hackage.haskell.org/package/http-streams-0.7.1.1/docs/Network-Http-Client.html
13:34:27 * hackagebot happstack-server 7.3.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.4 (JeremyShaw)
13:34:29 <geekosaur> rand_:
13:34:32 <geekosaur> @where hayoo
13:34:32 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
13:34:34 <mr-> Oh no.. it isn't
13:34:56 <ski> isaacbw : if you learn anything of interest, it could be nice if you tell this channel ..
13:35:51 <isaacbw> ski: hah, definitely! I'll read through it when I finish this SPJ talk
13:37:50 <ski>   data SetOps a = forall s. SO {empty :: s,singleton :: a -> s,union :: s -> s -> s,select :: s -> Maybe (a,s)}
13:39:00 <ski>   makeListSet :: (a -> a -> Bool) -> SetOps a
13:39:11 <ski>   makeTreeSet :: (a -> a -> Ordering) -> SetOps a
13:39:42 <ski> is roughly how you can simulate ML functors
13:44:42 <Eduard_Munteanu> Are there some preprocessors for Haskell that could help me deal with repetitive stuff like pragmas and qualified imports?
13:45:42 <Eduard_Munteanu> Well, other than the obvious CPP. :)
13:47:55 <geekosaur> none I know of for pragmas but there are some tools on hackage for managing import lists I think?
13:48:56 <activeaspect> template haskell has an open feature request for adding imports - https://ghc.haskell.org/trac/ghc/ticket/1475
13:50:05 <Shammah> it it possible to pattern match an in-between elements in a list? myFunc (x:y:z) where x = [1,2], y = 3, z = [4,5]
13:50:06 <Eduard_Munteanu> Interesting.
13:50:27 <Earnestly> (There is always mcpp which is a bit more… useful)
13:50:29 <Eduard_Munteanu> Shammah: yes, but your example has a type error
13:51:14 <ZioCrocifisso>  is there an efficient structure like a two-dimensional where every element can be modified with a function basing on the adjacent elements?
13:51:39 <ZioCrocifisso> *two-dimensional array
13:51:50 <c_wraith> ZioCrocifisso: repa has stencil convolutions for exactly that.
13:52:09 <ZioCrocifisso> thanks.
13:52:12 <c_wraith> ZioCrocifisso: also, being repa, it does them in parallel.
13:52:17 <k00mi> Eduard_Munteanu: you can compile with -XFoo instead of {-# Language Foo #-}
13:52:54 <activeaspect> Eduard_Monteanu: imo an ide plugin that added imports/pragmas would be good. is that what you mean or something more programatic or runtime context sensitive?
13:52:59 <ZioCrocifisso> yes, i tried to do it with traverse (failing) because i didn't know of that.
13:53:29 <Eduard_Munteanu> k00mi, activeaspect: I'm sort of interested in putting qualified imports and perhaps pragmas in a separate Prelude-like module.
13:53:33 <pseudolio> Eduard_Munteanu: You could put all your LANGUAGE stuff in a .cabal, instead of the individual files, if you don't care about per-file uses of each feature.
13:54:14 <Eduard_Munteanu> Yeah, I think the .cabal stuff does for pragmas, I should've mentioned this earlier.
13:54:53 <k00mi> I suppose you could have a Imports.hs that just reexports a bunch of common modules
13:55:10 <Eduard_Munteanu> k00mi: not qualified exports though
13:55:18 <k00mi> hrm right
13:56:51 <Eduard_Munteanu> Shammah: myFunc (a:3:b:5:c:d:es) would be a valid thing
13:57:13 <Shammah> Heh, I worked my way around such guard ;)
13:57:44 <Eduard_Munteanu> Note that only matches lists of size 6 or greater.
13:58:05 <skypers> hey
13:58:14 <guymann> hi
13:58:19 <skypers> why isn’t Data.IntMap implemented with balanced tree?
13:59:50 <skypers> I heard radix trees have worst insertions
14:00:07 <skypers> like O(k) against O(log n) for balanced trees
14:06:47 <merijn> skypers: Because IntMap is much more efficient than a balanced tree?
14:07:34 <skypers> merijn: why?
14:07:44 <skypers> radix trees might not
14:08:07 <merijn> skypers: Patricia trees have better average case and worst case performance than something like red-black trees, etc.
14:08:29 <merijn> radix trees only work for limited numbers of input keys
14:09:12 <skypers> oh?
14:09:19 <skypers> it’s interesting
14:09:29 <skypers> is there a more general version than IntMap?
14:09:32 <merijn> Actually, I'm not even sure what a radix tree means
14:09:40 <merijn> Are you thinking of a trie?
14:09:40 <skypers> since a typeclass could exist for that
14:09:43 <skypers> yes
14:09:51 <skypers> radix trees are patricia trees
14:09:54 <skypers> they’re the same name
14:10:57 <merijn> skypers: The IntMap docs link to two papers on the subject, FYI
14:11:57 <ZioCrocifisso> c_wraith: it only works with numbers.
14:12:23 <ZioCrocifisso> maybe i'm asking too much, i will try with st arrays.
14:13:18 <catsup> q
14:13:25 <prophile> something to run by #haskell: is it true that for some kind of algebraic structure S over a set B, it's isomorphic to a function from the free S on B to B? (for example, a monoid on S is isomorphic to some [S] -> S)?
14:14:52 <c_wraith> ZioCrocifisso: oh, so it is.  Somehow, I'd missed that in all my previous examinations.
14:15:57 <johnw> prophile: I wouldn't say isomorphic, since you can't go from the function S B -> B back to the free S
14:16:22 <prophile> ah, you can't?
14:16:31 <johnw> how would you write it?  the free S is in negative position
14:16:53 <johnw> taking your [S] -> S for example.  How can that be used to recover a [S]?
14:17:15 <prophile> I'm not certain, but I couldn't immediately think of any [S] -> S examples which couldn't be written as (S, S -> S -> S)
14:17:31 <johnw> I think you could certainly say that it is *adjoint*, since your particular algebra is going to "forget" the free structure
14:17:39 <archblob> has anyone tried building the current IHaskell from git ?
14:18:30 <johnw> you are correct that any algebra [S] -> S can be expressed generally as the F-algebra (A, F A -> A) (for the case of monoid, this is a generalization of (S, () -> S, S -> S -> S))
14:19:09 <johnw> but your algebra function is essentially a forgetful function
14:19:47 <archblob> it keeps failing with an Ambiguous occurrence for head and tail in Eval/Parser.hs even though head and tail from ClassyPrelude are hidden
14:20:05 <prophile> the reason I suggested isomorphism is that you can go from f : [s] -> s to (s, s -> s -> s) with (f [], \x y -> f [x, y]) and from (s, s -> s -> s) to [s] -> s via foldr
14:20:14 <johnw> and [S] -> S is generally said to be a catamorphism, which is a "natural transrfomation from an initial algebra (for your monoid, in this example) to any other algebra"
14:20:15 <prophile> if you'll forgive my being incredibly informal there ^
14:20:24 <archblob> and there is an explicity inport from Prelude
14:20:32 <archblob> *eplicit
14:20:46 <archblob> *explicit :-P
14:20:52 <johnw> prophile: I see
14:21:01 <johnw> prophile: I think we say catamorphism here, not isomorphism
14:21:19 <prophile> I fear I may have betrayed a lack of understanding of category theory :)
14:21:22 <prophile> okay
14:21:34 <johnw> you can go from the initial algebra (free monoid) to any other algebra
14:21:37 <johnw> but not the other way around
14:21:50 <johnw> that requires anamorphism
14:21:56 <johnw> which requires a coalgebra
14:22:09 <johnw> (if that's even correct)
14:22:19 * prophile scribbles down notes
14:22:20 <johnw> coalgebra may not get you back to an initial algebra at all, I'd have to look that up
14:22:35 <johnw> oh, I see
14:22:41 <johnw> it gets you back to the terminal algebra
14:22:50 <johnw> which in Haskell happens to *be* the initial algebra as well
14:23:12 <johnw> so Haskell is conflating some things here that make the categorial underpinnings a bit harder to differentiate
14:23:31 <skypers> what do you think of XPath / XQuery?
14:23:40 <skypers> am I the only one who think it’s totall crap?
14:23:57 <johnw> XPath is decent in the absence of better alternatives :)
14:24:19 <skypers> johnw: what do you use it for?
14:24:22 <skypers> I don’t understand
14:24:33 <skypers> in Perl for instance, I can transform an .XML into a hash
14:24:37 <johnw> i use it for querying XML trees
14:24:39 <skypers> and directly access my nodes
14:24:47 <quchen> The axiom of XML choice: on any ordered list of technologies, there is an XML alternative such that if there are no better ones, it's the best.
14:24:54 <skypers> johnw: why don’t you directly access it?
14:25:08 <johnw> you mean, write code to walk the tree?
14:25:08 <skypers> quchen: :)
14:25:12 <skypers> yes johnw
14:25:13 <Clint> xml-conduit
14:25:15 <johnw> for the same reason I use regexp sometimes instead of writing a parser
14:26:10 <skypers> oh
14:26:15 <skypers> johnw: I like that explaination then
14:26:18 <skypers> it makes sense now
14:26:20 <skypers> thank you
14:26:24 <HowToAdd> Hi everyone, quick question!
14:26:29 <skypers> I think I’ll just stay from that
14:26:35 <skypers> (I don’t use regexp :))
14:26:42 <skypers> it was very quick HowToAdd
14:26:44 <HowToAdd> in an if-then-else statement, how can I make "else" return nothing
14:26:51 <davidfetter_disq> now you don't have two problems...
14:26:58 <HowToAdd> skypers: I tried my best :/
14:27:01 <skypers> :)
14:27:09 <skypers> HowToAdd: return ()?
14:27:15 <skypers> what’s your function signature
14:27:16 <skypers> ?
14:27:16 <HowToAdd> skypers: that's a thing?
14:27:21 <tomboy64> hmm. noob question. How do i turn this into an Int?
14:27:24 <tomboy64> minVal = (floor $ (10 ** ((length (thisList !! 0))-1)))
14:27:38 <HowToAdd> skypers: what do you mean by that?
14:27:45 <skypers> tomboy64:
14:27:46 <skypers> :t floor
14:27:47 <lambdabot> (Integral b, RealFrac a) => a -> b
14:27:50 <tomboy64> i tried adding ::Int but it still gives me errors with RealFrac
14:28:03 <skypers> so compose with fromIntegral :)
14:28:10 <tomboy64> -.-
14:28:13 <tomboy64> right
14:28:18 <fizbin> @type fromIntegral
14:28:19 <lambdabot> (Integral a, Num b) => a -> b
14:28:23 <skypers> :t (floor $ (10 ** ((length (thisList !! 0))-1)))
14:28:24 <lambdabot> Not in scope: `thisList'
14:28:31 <skypers> :t (floor $ (10 ** ((length ([] !! 0))-1)))
14:28:32 <lambdabot>     Could not deduce (RealFrac Int) arising from a use of `floor'
14:28:32 <lambdabot>     from the context (Integral b)
14:28:32 <lambdabot>       bound by the inferred type of it :: Integral b => b at Top level
14:28:37 <skypers> ok, you’ll try ;) :D
14:28:43 <skypers> HowToAdd: well
14:29:00 <fizbin> :t (fromIntegral . floor $ (10 ** ((length ([] !! 0))-1)))
14:29:01 <lambdabot>     Could not deduce (RealFrac Int) arising from a use of `floor'
14:29:01 <lambdabot>     from the context (Num c)
14:29:01 <lambdabot>       bound by the inferred type of it :: Num c => c at Top level
14:29:12 <skypers> > if True then Just 3 else Nothing
14:29:13 <lambdabot>  Just 3
14:29:16 <skypers> ^ HowToAdd
14:29:18 <HowToAdd> skypers: for reference: http://lpaste.net/5575070878254759936
14:29:34 <HowToAdd> skypers: Here's the type: helper :: Num a => (a -> Bool) -> a -> a
14:29:35 <tomboy64> still doesn't work: http://bpaste.net/show/187347/
14:29:37 <tomboy64> :/
14:29:40 <skypers> what is a type?
14:29:44 <skypers> I mean
14:29:51 <skypers> a, what’s its type?
14:29:57 <HowToAdd> skypers: it's a number
14:30:01 <skypers> ok
14:30:11 <skypers> so you want a function to return a number if something is ok
14:30:16 <skypers> otherwise, nothing
14:30:20 <HowToAdd> skypers: exactly
14:30:22 <skypers> so you have to change your function signature
14:30:28 <skypers> you can’t directly return a number
14:30:31 <skypers> see:
14:31:35 <skypers> > let helper :: (Int -> Bool) -> Int -> Maybe Int; helpr f a = if not (f a) then Just a else Nothing
14:31:36 <lambdabot>  not an expression: `let helper :: (Int -> Bool) -> Int -> Maybe Int; helpr f...
14:31:40 <skypers> oops :)
14:31:49 <orzo> Control.Concurrent has forkIO and forkOS.  forkOS requres -threaded and makes an OS thread explicitly.  But I believe with -threaded, forkIO threads can and will be OS threads occasionally.  Is there a way to explicitly tell it not to use a bound thread?
14:31:49 <skypers> @let helper :: (Int -> Bool) -> Int -> Maybe Int; helpr f a = if not (f a) then Just a else Nothing
14:31:50 <lambdabot>  .L.hs:149:1:
14:31:50 <lambdabot>      The type signature for `helper' lacks an accompanying binding
14:31:59 <skypers> @let helper :: (Int -> Bool) -> Int -> Maybe Int; helper f a = if not (f a) then Just a else Nothing
14:32:00 <lambdabot>  Defined.
14:32:12 <skypers> > helper even 3
14:32:14 <lambdabot>  Just 3
14:32:18 <c_wraith> orzo: forkOS and forkIO are nearly the same.  The only difference is how they interact with FFI calls.
14:32:23 <skypers> > helper even 2
14:32:25 <lambdabot>  Nothing
14:32:29 <skypers> see HowToAdd?
14:32:31 <HowToAdd> skypers: woah cool
14:32:37 <skypers> you have to wrap your value in a Maybe
14:32:56 <skypers> don’t forget Haskell is strongly typed
14:33:01 <skypers> you can’t return Int
14:33:11 <HowToAdd> skypers: "Just" and "Nothing"... what are those?
14:33:12 <skypers> because you don’t know what to return “nothing Int”
14:33:22 <skypers> they define the Maybe a type
14:33:25 <HowToAdd> skypers: Yeah that makes sense
14:33:29 <skypers> they’re type constructors
14:33:34 <skypers> @src Maybe
14:33:34 <lambdabot> data Maybe a = Nothing | Just a
14:33:36 <skypers> :)
14:33:41 <c_wraith> skypers: value constructors
14:33:47 <skypers> yeah
14:33:49 <skypers> sorry
14:33:56 <skypers> constructors.
14:33:57 <skypers> :)
14:34:03 <skypers> you consider them like functions, HowToAdd
14:34:04 <skypers> BUT
14:34:08 <skypers> you can pattern match on them
14:34:23 <HowToAdd> skypers: oohhh OK
14:34:25 <orzo> c_wraith: i've been going along nicely without -threaded until i needed haskell code to resume while an FFI call is in progress. Only the thread with the FFI call needs to be forkOS.  I'm not sure -threaded is what i want, because of other things it does.  I liked the lightweight single-thread nature of my code prior.
14:34:41 <skypers> > let l = [Just 3, Just 2, Nothing, Just 1, Nothing] in [Just x | x <- l]
14:34:43 <lambdabot>  [Just (Just 3),Just (Just 2),Just Nothing,Just (Just 1),Just Nothing]
14:34:53 <skypers> ahah, the fail.
14:35:20 <skypers> > let l = [Just 3, Just 2, Nothing, Just 1, Nothing] in [x | Just x <- l]
14:35:21 <lambdabot>  [3,2,1]
14:35:23 <skypers> much better :)
14:35:49 <HowToAdd> skypers: ohh OK. I was worried it wouldn't return a number and would always have "Just" in the return value
14:36:29 <tobbra> does lambdabot detect infinite loops?
14:36:32 <Axman6> that's catMaybes btw
14:36:33 <HowToAdd> skypers: wait it does... :(
14:36:39 <tobbra> > let x = x
14:36:40 <lambdabot>  not an expression: `let x = x'
14:36:51 <skypers> > let x = x in x
14:36:54 <HowToAdd> map (helper (< 3)) [1,2,3]
14:36:54 <lambdabot>  mueval-core: Time limit exceeded
14:36:59 <tobbra> ah
14:37:07 <skypers> add a > in front of your line HowToAdd
14:37:12 <HowToAdd> > map (helper (< 3)) [1,2,3]
14:37:13 <skypers> lambdabot will evaluate it
14:37:14 <lambdabot>  [Nothing,Nothing,Just 3]
14:37:21 <Axman6> tobbra: it detects anything that runs too long. detecting infinite loops in general is impossible
14:37:32 <HowToAdd> skypers: Ideally I would want [3]
14:37:38 <tobbra> does it print lazily?
14:37:42 <skypers> HowToAdd:
14:37:43 <HowToAdd> skypers: instead of [Nothing, Nothing, Just 3]
14:37:47 <tobbra> > let x = 1:x in x
14:37:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:37:54 <tobbra> yes it does
14:37:57 <skypers> > filter (<2) [1..3]
14:37:58 <lambdabot>  [1]
14:38:01 <skypers> huh
14:38:03 <tobbra> that's cool
14:38:13 <skypers> HowToAdd: ok
14:38:13 <skypers> so
14:38:17 <Axman6> HowToAdd: then you can't use map, it always must return the same number of elements as in the input list
14:38:18 <skypers> simple
14:38:22 <skypers> :t catMaybes
14:38:22 <lambdabot> [Maybe a] -> [a]
14:38:39 <quchen> :t listToMaybe . catMaybes
14:38:40 <lambdabot> [Maybe a] -> Maybe a
14:38:52 <skypers> > catMaybes . map (helper (< 3)) $ [1,2,3]
14:38:55 <lambdabot>  [3]
14:38:59 <skypers> you have it now :)
14:39:08 <HowToAdd> skypers: WOAH! What is that??
14:39:10 <HowToAdd> :D
14:39:10 <Axman6> what's the point of helper?
14:39:16 <skypers> see above
14:39:20 <skypers> I defined it
14:39:23 <skypers> HowToAdd: well
14:39:27 <hexagoxel> for comonads, the law "extract =>= f = f" corresponds to "extend extract = id", correct?
14:39:28 <skypers> catMaybes fold your list
14:39:36 <skypers> and extract all Just values
14:39:56 <skypers> > let l = map (helper (< 3)) [1,2,3] in [x | Just x <- l]
14:39:58 <lambdabot>  [3]
14:40:02 <skypers> like this one as well
14:40:05 <skypers> that*
14:40:15 <skypers> it’s more intuitive to use catMaybes
14:40:16 <skypers> though
14:40:21 <skypers> I already said that
14:40:25 <tobbra> what modules does lambdabot have imported? just the Prelude?
14:40:26 <skypers> it should be named justs
14:40:36 <HowToAdd> skypers: amazing. thank you
14:40:43 <skypers> you’re welcome HowToAdd
14:40:49 <quchen> tobbra: I think it has most of Base and then some.
14:41:00 <MrRacoon> win 12
14:41:05 <quchen> tobbra: Some of them are qualified, like Foldable.
14:41:05 <skypers> you have Parsec, Lens, Control.*
14:41:07 <skypers> and so on
14:41:21 <skypers> :t between
14:41:22 <lambdabot> Not in scope: `between'
14:41:23 <tobbra> > putStrLn "hello?"
14:41:24 <lambdabot>  <IO ()>
14:41:26 <skypers> ok we don’t have parsec.
14:41:36 <edwardk> hexagoxel: looks right to me
14:41:45 <HowToAdd> skypers: do I need to import anything to use catMaybes?
14:41:50 <skypers> tobbra: lambdabot doesn’t execute IO values
14:41:54 <skypers> yes
14:41:56 <tobbra> apparently
14:41:59 <skypers> Data.Maybe
14:41:59 <Clint> @hoogle catMaybes
14:41:59 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:42:08 <quchen> @index catMaybes
14:42:08 <lambdabot> Data.Maybe
14:42:13 <skypers> :)
14:42:27 <isaacbw> what's multithreading like in haskell? Is it something that happens automatically by the compiler?
14:42:27 <HowToAdd> Cool :)
14:42:40 <hexagoxel> edwardk: and i bet there is a good reason that the lines in the comonad doc are switched..
14:42:44 <Axman6> isaacbw: no, but it is very awesome
14:43:00 <tobbra> > Foldable.fold ["abc", "def"]
14:43:01 <lambdabot>  Not in scope: `Foldable.fold'
14:43:05 <skypers> @src helper
14:43:05 <lambdabot> Source not found. :(
14:43:13 <skypers> lambdabot doesn’t show our sources?
14:43:16 <skypers> how bad is that
14:43:32 <Axman6> isaacbw: http://chimera.labs.oreilly.com/books/1230000000929 you can read all about it for free online
14:43:32 <quchen> Static database.
14:43:35 <tobbra> > Data.Foldable.fold ["abc", "def"]
14:43:35 <lambdabot>  "abcdef"
14:43:40 <tobbra> yes :-)
14:43:40 <edwardk> hexagoxel: not really =)
14:43:40 <isaacbw> cool! Thanks Axman6
14:43:43 <quchen> Very Haskell, very immutable.
14:43:46 <edwardk> hexagoxel: i'll take a patch if you want
14:43:50 <skypers> :t fold
14:43:51 <lambdabot> (Foldable t, Monoid m) => t m -> m
14:44:03 <skypers> I didn’t know that one
14:44:13 <skypers> > concat ["abc","def"]
14:44:14 <lambdabot>  "abcdef"
14:44:18 <Axman6> isaacbw: basically, it's extremely nice to use, and extremely fast
14:44:50 <skypers> > fold (Just "hi")
14:44:51 <lambdabot>  "hi"
14:45:02 <skypers> hm
14:45:22 <fizbin> Any people here programming decently large haskell programs for pay?
14:45:33 <skypers> no, but I’d love to
14:45:35 <edwardk> yes
14:45:36 <tobbra> the monoid has a natural zero and a function to combine two values, so you don't need to provide those
14:45:52 <skypers> edwardk: what did you wrote for large pay?
14:45:53 <skypers> write*
14:46:43 <fizbin> If so, how do you handle the idea that crap goes wrong everywhere? In java or python I can just deal with stuff that shouldn't happen and throw an exception, but in Haskell I end up with this Either creep all over.
14:47:02 <Axman6> haskell also has exceptions...
14:47:15 <quchen> Haskell also has the silly way. It also also has other ways.
14:47:28 <skypers> fizbin: I handle exceptions through EitherT
14:47:32 <skypers> and MonadError
14:47:34 <skypers> it’s transparent
14:47:37 <skypers> and elegant
14:47:41 <Yaniel> at what point does Fail come into play?
14:47:41 <Axman6> but we have much nicer ways to deal with things too, such as using {Maybe|Either}T?
14:47:47 <fizbin> No, it isn't transparent.
14:47:48 <skypers> Yaniel: no idea
14:47:51 <edwardk> skypers: i work in finance on a compiler for a haskell like language
14:48:05 <isaacbw> woah, quicktest
14:48:05 <skypers> ok edwardk, might be fun!
14:48:05 <fizbin> It craps up the entire program with Either all over the place.
14:48:16 <skypers> fizbin: huh?
14:48:17 <isaacbw> I feel like may brain is being completely flooded with awesome right now
14:48:25 <skypers> no, only the error-prone part
14:48:38 <skypers> isaacbw: welcome in Haskell! :)
14:48:39 <quchen> I don't like using functions with numbers in Haskell, it craps up my code with Int everywhere. Haskell is stupid
14:48:43 <johnw> fizbin: I use exceptions
14:48:49 <skypers> quchen: +1
14:48:57 <skypers> fizbin: quchen got the point
14:48:57 <johnw> fizbin: in a "decently large Haskell program for pay"
14:48:59 <Axman6> johnw: you're a monster D:
14:49:06 <johnw> I don't see anything wrong with exceptions
14:49:08 <fizbin> johnw: Isn't that just either in another type wrapper?
14:49:16 <skypers> johnw: you can’t catch them anywhere but IO
14:49:18 <edwardk> fizbin: my usual pattern is to make a custom monad for what i want to work with, nd handle my set of exceptions through the set of cases in my monad. if i need it extensible i use lens tricks
14:49:20 <skypers> they’re terrible.
14:49:23 <johnw> Either cannot express async exceptions
14:49:25 <Axman6> fizbin: no, haskell has real exceptions
14:49:28 <johnw> ah, I don't use exceptions in pure code
14:49:47 <skypers> johnw: what are async exceptions?
14:49:55 <Axman6> > error "This throws an exception"
14:49:56 <lambdabot>  *Exception: This throws an exception
14:49:57 <johnw> exception that are not thrown by your code
14:50:03 <edwardk> skypers: i can throw an exception at another thread
14:50:08 <johnw> for example, if you "kill <PID>" your process from the command-line
14:50:11 <edwardk> skypers: those are async exceptions
14:50:25 <johnw> you can also throw your own async exceptions from one thread to another, as edwardk mentioned
14:50:34 <skypers> I see
14:50:40 <johnw> async exceptions can *always* occur, even if your own code is totally exception-handling free
14:50:44 <skypers> well, it’s very exceptional I guess
14:50:47 <edwardk> throwTo someProcess DieDieDie
14:50:55 <johnw> so in production quality code, you end up needing to deal with the reality of exceptions no matter what, so might as well use them to good effect
14:51:06 <skypers> yeah
14:51:18 <skypers> what happens if you’re in pure code when the exception occurs?
14:51:31 <johnw> so for me, that means Either/Maybe for pure code (i.e., I like total functions), and exceptions for IO-based code
14:51:39 <fizbin> Okay, but I just keep slamming into things where in other languages I'd add in error checking and assertions all over but in Haskell a failed assert (like head on an empty list) is immensely less debuggable than anywhere else, so...
14:51:44 <Axman6> it gets caught by the first exception handler
14:51:58 <Earnestly> johnw: By handling `kill`, do you really mean handling signals, and do you need exceptions for that?
14:51:59 <Axman6> if you've wrappeed the code you';re running in catch, that will catch it
14:52:09 <edwardk> on the other hand, maybe 5% of your code needs to be structured around async exceptions, if you are careful about how you set up your loops/blocking, etc.
14:52:09 * Earnestly gueses you do
14:52:14 <johnw> Earnestly: signals are modeled in Haskell as asynchronous exceptions, which I think is awesome
14:52:45 <tobbra> > $([| "I support Template Haskell" |])
14:52:46 <lambdabot>  <hint>:1:1: parse error on input `$'
14:52:49 <Earnestly> I'm just trying to think how else it could be done, a kill can come at any time
14:53:00 <johnw> the only special handling you get for free regarding async exceptions is that they cannot occur within a catch handler
14:53:02 <Earnestly> johnw: I mean, how else would you model it?
14:53:16 <johnw> Earnestly: by registering signal handlers, the way C does it
14:53:21 <Earnestly> Oh right
14:53:30 <Earnestly> Yeah, exceptions sound better heh
14:53:33 <skypers> callbacks…
14:53:41 <skypers> we don’t total FRP OS!!
14:53:42 <skypers> :)
14:53:48 <henk> I wrote a module for converting seconds (given as Integers) to HH:MM:SS notation: http://lpaste.net/8633661649745608704 Would anyone mind taking a look and giving me feedback about it? I appreciate any feedback you find worth mentioning, whether it’s coding style, readability, best practice, performance or whatever.
14:53:48 <skypers> need*
14:54:29 <fizbin> And so I have this large chunk of input, and I think "Okay, I've run my validation checks, now build up the graph I need out of this input" and during that graph-building I keep running into spaces where I'm pretty sure these functions that are typed as returning Maybe will find stuff, but I'm juggling enough that I'm not certain enough to completely forgo error checking.
14:54:33 <johnw> henk: formatTime defaultTimeLocale "%H:%M:%S" . posixSecondsToUTCTime
14:54:57 <skypers> woh
14:55:00 <skypers> :t printf
14:55:01 <lambdabot> PrintfType r => String -> r
14:55:02 <fizbin> So I wind up with Either all over my code, and have to go back and change the signature of everything that might be calling this...
14:55:03 <benmachine> henk: it's pretty good
14:55:08 <skypers> what is that?
14:55:10 <skypers> TH?
14:55:15 <benmachine> skypers: no, just clever
14:55:20 <skypers> ?
14:55:21 <benmachine> skypers: not very type-safe though
14:55:28 <skypers> I don’t understand
14:55:39 <skypers> I thought variadic functions can’t be constructed in Haskell
14:55:47 <johnw> fizbin: EitherT could make your life a lot easier
14:55:47 <benmachine> skypers: you learnt something new today!
14:55:58 <johnw> or rather, just the Either monad
14:56:00 <fizbin> The approach to dealing with less-than-perfect data (or less than perfect me!) just has been so heavywieght.
14:56:01 <benmachine> skypers: unfortunately the number of arguments can't be checked at compile time
14:56:03 <edwardk> skypers: you can construct them with typeclass trickery for many cases
14:56:06 <geekosaur> they can. they're highly painful and play havoc with type inference
14:56:15 <skypers> edwardk: hm
14:56:17 <benmachine> skypers: so it's usually better to just use a list or something anyway
14:56:21 <skypers> so hm
14:56:28 <skypers> it represents arguments as functions I guess?
14:56:33 <skypers> with low arity?
14:56:38 <skypers> well
14:56:40 <skypers> precedence*
14:56:42 <skypers> not arity
14:56:45 <Eduard_Munteanu> skypers: or using heterogenous lists
14:57:03 <skypers> yeah
14:57:07 <skypers> but I mean in the construct
14:57:08 <benmachine> henk: one comment that I'd make is that fromString is quite permissive
14:57:13 <edwardk> skypers: consider what r could be. as a base case it could be IO ()
14:57:15 <skypers> how does it work?
14:57:24 <skypers> well
14:57:25 <fizbin> johnw: I need to learn how to use EitherT. Or rather, how to stack monad transformers in general; most of the code I'm griping about now is all buried in State.
14:57:30 <skypers>    > printf "%s %s\n" "Hello" "World"
14:57:33 <skypers> in that case
14:57:36 <skypers> it’s…
14:57:41 <skypers> it’s what.
14:57:42 <skypers> :D
14:57:45 <skypers> something like
14:57:50 <benmachine> henk: and fromString explodes on invalid input, perhaps it shouldn't
14:57:51 <henk> johnw: It’s not posix time, but just a number of seconds, e.g. 124 becomes 00:02:04. I think your solution is for something different, isn’t it?
14:57:54 <edwardk> skypers: on the other hand, say you wanted to pass it an Int argumnt, now you'd want it to be Int -> r   for some 'r' that is a valid PrintfType
14:57:59 <Eduard_Munteanu> :t printf "%s %s\n"
14:58:00 <lambdabot> PrintfType r => r
14:58:05 <Eduard_Munteanu> :t printf "%s %s\n" "Hello"
14:58:06 <lambdabot> PrintfType ([Char] -> t) => t
14:58:12 <skypers> yeah
14:58:14 <Eduard_Munteanu> :t printf "%s %s\n" "Hello" "World"
14:58:15 <lambdabot> PrintfType ([Char] -> t) => t
14:58:20 <skypers> that’s what I thought then
14:58:23 <edwardk> you could do that with instance PrintfType r => PrintfType (Int -> r)
14:58:25 <Axman6> there's an instance for (PrintfArg a, PrintfType r) => PrintfType (a -> r)
14:58:26 <quchen> henk: See the annotation on the paste
14:58:32 <skypers> PrintfType needs a type to be transformed into a function
14:58:34 <fizbin> Monad transformers are something that I always just play the "keep trying different things until it typechecks" game with.
14:58:38 <johnw> fizbin: EitherT e (State s) a will discard your state in the case of an error; StateT s Either a will keep it
14:58:40 <fizbin> Which is not a fun game.
14:58:41 <johnw> henk: correct
14:58:41 <edwardk> but now you have to use flexible instances. you can fix that by making _another_ class
14:58:49 <prinsen> I get "when expecting a String, encountered Object instead" when parsing large JSON structures, Im at a loss and need more info, is there any way to get that?
14:58:51 <edwardk> which is PrintfArg
14:58:57 <skypers> I see edwardk
14:58:58 <benmachine> fizbin: I enjoy that game :P
14:59:08 <skypers> what happens if you pass incorrect typed values?
14:59:11 <edwardk> instance (PrintfArg a, PrintfType r) => PrintfType (a -> r)
14:59:24 <benmachine> > printf "%d" "hello"
14:59:25 <lambdabot>  No instance for (Text.Printf.PrintfType a0)
14:59:25 <lambdabot>    arising from a use of `e_1'
14:59:25 <lambdabot>  The type variable `a0' is ambiguous
14:59:25 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
14:59:25 <lambdabot>  Note: there are several potential instances:
14:59:29 <benmachine> hmm.
14:59:29 <edwardk> skypers: saly this doesn't check that the format and the arguments are well formed
14:59:31 <benmachine> > printf "%d" "hello" :: String
14:59:32 <lambdabot>  "*Exception: Printf.printf: bad argument
14:59:36 <benmachine> there we go
14:59:44 <skypers> what’s the point of that function then?
14:59:47 <fizbin> benmachine: Then you play it. Me, I spent twenty minutes this morning trying to figure out that the expression I wanted was "fmap fst get" (or "gets fst")
14:59:52 <fizbin> Not fun.
15:00:00 <henk> benmachine: Thank you very much. Yes, fromString is very permissive. Would you consider making it "fromString :: String -> Maybe HMSTime" a good solution?
15:00:00 <Axman6> skypers: it's really handy?
15:00:00 <skypers> oh god
15:00:05 <skypers> exception
15:00:15 <skypers> I rather like putStrLn :D
15:00:19 <henk> johnw: ok, thank you
15:00:23 <benmachine> henk: I would consider that a good thing, but not a solution to the permissiveness
15:00:25 <edwardk> skypers: well, c in general doesn't check your format strings either! it is a compiler trick offered when the string is known
15:00:29 <Eduard_Munteanu> prinsen: aeson? Run the parser manually and inspect the error result.
15:00:30 <skypers> at least it’s compile time checked
15:00:33 <edwardk> but it isn't required
15:00:40 <edwardk> skypers: only for a constant string
15:00:45 <skypers> ?
15:00:53 <tobbra> > getEnvironment
15:00:54 <lambdabot>  Not in scope: `getEnvironment'
15:01:03 <Earnestly> The formatters don't have to match in C, most decent compilers will warn you though
15:01:05 <skypers> you can write something like
15:01:17 <skypers> putStrLn $ "value: " ++ show myInt
15:01:19 <edwardk> skypers: i thought you were referring to printf in c being compile time checked, guess you meant putStrLn
15:01:20 <skypers> instead of
15:01:20 <benmachine> henk: I more meant that if I give a string like "091234:432423:4324:43434:4343:4343" it will try to give me an answer
15:01:30 <skypers> printf "value: %d" i
15:01:30 <benmachine> henk: whereas really I think it ought to go "nope"
15:01:36 <benmachine> henk: i.e. Nothing in the new improved world
15:01:38 <Earnestly> printf("%d, %s" 3); -> compiles just fine, "C: Hur dur, boss, whatever you say!"
15:01:40 <skypers> nono edwardk
15:01:51 <skypers> I was talking about putStrLn, yes
15:01:56 <henk> benmachine: ah, yes, that’s what I meant (: Use guards to return Nothing if the input is invalid …
15:02:15 <tobbra> :t unsafePerformIO
15:02:15 <lambdabot> Not in scope: `unsafePerformIO'
15:02:24 <edwardk> anyways you can concoct a strongly typed 'format'. we had one we were experimenting with for lens at one point using 'now' and 'later'
15:02:29 <benmachine> henk: right. but there are some inputs for which you /can/ give an answer, but I claim you shouldn't :P
15:02:56 <Eduard_Munteanu> You could just use a HList.
15:02:59 <edwardk> shachaf probably has the code handier than i d
15:03:01 <benmachine> OCaml has typed printf, but it's (a) bizarre and (b) baked into the language itself
15:03:02 <edwardk> er do
15:03:04 <benmachine> which is pretty silly
15:03:19 <skypers> yeah benmachine
15:03:26 <skypers> sounds to
15:03:44 <skypers> I feel quite conformtable with print / putStrLn
15:03:51 <Eduard_Munteanu> Then all you need to do is provide a type signature if anything.
15:03:52 <fizbin> johnw: Also, with stacking EitherT String (State s), I find that I end up fighting the type system and needing to fling around "lift" in ways I don't always understand.
15:04:11 <Eduard_Munteanu> fizbin: don't, use MonadState et al. classes
15:04:12 <skypers> when I discovered Haskell two years ago
15:04:22 <skypers> I didn’t really get the advantage of strongly typed
15:04:29 <benmachine> fizbin: it's not usually necessary to use "lift" as long as you're using mtl instead of just transformers
15:04:34 <skypers> now, I just can’t imagine something without that
15:04:57 <Earnestly> skypers: To be fair, most people think of C's type system when you say typed
15:05:07 <TallerGhostWalt> What is the GHC extention that allows instances to not end in where?
15:05:10 <edwardk> skypers: anyways something like http://hackage.haskell.org/package/holey-format-2.0.0/docs/Text-Format-Holey.html  can be made that works with formats with gaps
15:05:14 <skypers> Earnestly: huh?
15:05:17 <TallerGhostWalt> instance IsRecord U1 False
15:05:20 <TallerGhostWalt> like that
15:05:23 <Earnestly> skypers: (And by C, I mean, all of it's decendents.)
15:05:24 <Eduard_Munteanu> TallerGhostWalt: it isn't an extension
15:05:28 <TallerGhostWalt> oh
15:05:40 <skypers> Earnestly: what would you call Haskell type system then?
15:05:41 <TallerGhostWalt> Eduard_Munteanu: so you can just do that?
15:05:43 <edwardk> skypers: format ("Person's name is " %text% ", age is " %hex) "Dave" 54
15:05:43 <skypers> it’s strongly typed
15:05:47 <Earnestly> skypers: Good ;p
15:05:48 <Eduard_Munteanu> TallerGhostWalt: yes
15:05:49 <fizbin> Eduard_Munteanu, benmachine: I can't figure out which one of those I'm using here...
15:05:51 <TallerGhostWalt> lol
15:05:54 <skypers> Earnestly: :D
15:05:58 <TallerGhostWalt> oh haskell, you devil you
15:06:01 <skypers> edwardk: I see
15:06:05 <benmachine> fizbin: do your module imports have Trans in? then transformers
15:06:14 <benmachine> fizbin: if they're Control.Monad.State ish, then mtl
15:06:58 <fizbin> mtl doesn't seem to have EitherT?
15:07:02 <skypers> no
15:07:06 <skypers> it’s in either
15:07:10 <benmachine> it has ErrorT, though, doesn't it?
15:07:15 <skypers> yes
15:07:15 <benmachine> which is basically the same
15:07:23 <skypers> huh no
15:07:26 <skypers> ErrorT sucks.
15:07:30 <Eduard_Munteanu> skypers: data HList :: [*] -> * where Nil :: HList '[]; Cons :: a -> HList as -> HList (a ': as)   lets you do something like   printf :: HList as -> String; foo = printf (Cons 3 (Cons False Nil) :: HList '[Integer, Bool])   with DataKinds
15:07:49 <Eduard_Munteanu> Depends on your purposes.
15:07:53 <skypers> Eduard_Munteanu: weird :D
15:07:56 <benmachine> skypers: it sucks a bit, but we can make do
15:08:03 <johnw> fizbin: you could use MonadCatch and MonadState, avoiding the need to lift everywhere
15:08:13 <skypers> benmachine: ErrorT has an annoying Error constraint on the error type
15:08:18 <benmachine> skypers: I know
15:08:21 <skypers> whereas EitherT doesn’t
15:08:22 <Eduard_Munteanu> skypers: the type signature isn't needed though, just there as your "format string" but can be omitted :)
15:08:37 <skypers> I also advise using the errors package
15:08:45 <skypers> which exports a lot of good stuff :)
15:08:48 <skypers> like hush, note, and so on
15:09:02 <johnw> fizbin: by using MonadCatch and MonadState, rather than directly giving EitherT and State in your type, you give yourself both some convenience and flexibility
15:09:27 <Eduard_Munteanu> ErrorT is slightly useful in case you want to use partial pattern-matching in monadic code, like 'Just x <- something'.
15:09:46 <johnw> your pure function ends up looking like: foo :: (MonadCatch m, MonadState s m) => m Int, which you would execute using runState and runEitherT
15:10:02 <henk> quchen: Regarding your comments about Integer vs Int: diffSeconds from Data.DateTime returns an Integer, which is why I used Integers everywhere … Can I convert that somehow?
15:10:03 <Eduard_Munteanu> Since it wires the Monad 'fail' to the Error.
15:10:07 <skypers> I’d use MonadError
15:10:12 <skypers> instead of MonadCatch
15:10:17 <johnw> henk: use NominalDiffTime in your code, rather than Integer
15:10:18 <skypers> but yes
15:10:20 <fizbin> Wait, so is EitherT from either a transformer like the ones from mtl that doesn't need lift to change levels, or one like transformers that does?
15:10:20 <skypers> something like
15:10:36 <skypers> runEitherT . flip runState yourState $ {- your code here -}
15:10:37 <johnw> MonadCatch is a much newer development
15:10:42 <quchen> henk: yes, fromIntegral does that
15:10:58 <quchen> It's probably the most used conversion function so remember it well :-)
15:11:17 <Eduard_Munteanu> fizbin: the instance isn't EitherT-specific
15:11:31 <benmachine> quchen: I disagree with the use of Int except where performance is a concern
15:11:58 <quchen> Yeah wastefulness is the only argument here. Which probably doesn't matter.
15:12:11 <benmachine> it's not even that wasteful, I don't think
15:12:13 <fizbin> I am now thoroughly confused.
15:12:27 <johnw> fizbin: show me a function you are wrestling with
15:12:29 <quchen> Okay, it's a non-issue. :-s
15:12:54 <benmachine> quchen: well, if you ARE worried about performance, it can be a big deal
15:13:00 <johnwalker> hi, whats the idiomatic way to use queues in haskell?
15:13:09 <benmachine> quchen: but Int overflows are a really irritating kind of bug to have, you know?
15:13:21 <johnwalker> it looks like its data.sequence, but it's a bit more abstract than i need
15:13:26 <Eduard_Munteanu> fizbin: instance (MonadError e m) => MonadError e (SomeOtherUnrelatedT m)
15:13:50 <Eduard_Munteanu> johnwalker: Data.Sequence is a reasonable queue, yes.
15:13:58 <fizbin> johnw: It will take some time to remove all the guesswork and half-finished stuff I currently have there, and scrub it of proprietary info.
15:14:01 <johnwalker> thanks
15:14:01 <Eduard_Munteanu> johnwalker: why too abstract?
15:14:40 <johnwalker> well, i'm new to haskell so take everything i say with a grain of salt
15:15:05 <johnwalker> the reason i said that was because i spent a few hours on it yesterday and couldn't come up with a great way to destructure the seqs
15:15:18 <benmachine> johnwalker: you need to know about the Foldable interface
15:15:26 <benmachine> and viewl/viewr
15:15:28 <k4r1m> Trying to write my own (!!) and I'm getting a "Non-exhaustive patterns in function" erro.  itemAt (x:xs) 0 = x;  itemAt (x:xs) n = itemAt xs (n-1) Any ideas?
15:15:31 <Eduard_Munteanu> johnwalker: usually cons and viewr for queue-like behavior
15:15:38 <johnwalker> thats right, i did wind up using viewl/viewr
15:15:55 <benmachine> k4r1m: itemAt [] 0 = ???
15:16:08 <benmachine> k4r1m: is it actually an error or a warning
15:16:13 <johnwalker> great, thanks for the help
15:16:17 <quchen> k4r1m: The error also tells you which pattern isn't matched.
15:16:29 <k4r1m> It's an exception
15:16:34 <Eduard_Munteanu> johnwalker: you might like ViewPatterns, it lets you write f (viewr -> xs :> x) = ...
15:16:36 <k4r1m> *** Exception: questions2.hs:101:1-33: Non-exhaustive patterns in function itemAt
15:16:44 <quchen> k4r1m: Compile with -W and you'll get a warning.
15:16:55 <quchen> Or ":set -W" in GHCi
15:16:56 <Eduard_Munteanu> (IIRC the symbols)
15:17:04 <johnw> fizbin: anyway, I recommend the mtl approach
15:17:09 <Axman6> k4r1m: you don't handle the empty list at all
15:17:09 <johnwalker> yes, i had a question about that too
15:17:26 <johnwalker> currently the right way to use viewpatterns is to put an annotation at the top of the source file using the extension right?
15:17:30 <fizbin> MonadCatch, huh? Hrm...
15:17:31 <benmachine> yes
15:17:35 <benmachine> er
15:17:36 <benmachine> johnwalker: yes
15:17:42 <Eduard_Munteanu> johnwalker: yeah, the LANGUAGE pragma
15:17:51 <johnwalker> whats the price for using the extension?
15:18:09 <benmachine> johnwalker: minimal
15:18:11 <Axman6> it's the same as using a case statement
15:18:17 <Axman6> but nicer
15:18:18 <Eduard_Munteanu> johnwalker: none really, aside from portability but that's seldom a concern since GHC is pretty much the only good compiler
15:18:27 <fizbin> johnw: Annoyningly, the "catch" package isn't included in the fp complete IDE...
15:18:38 <benmachine> extensions are more liable to change in future than standardised stuff, as well
15:18:41 <k4r1m> Ok so it's the empty, let me try it. Another question, is there a limit on function pattern matching? as far declaring a number of functions
15:18:46 <benmachine> but that's also not a big concern, ViewPatterns has been around a while
15:18:49 <fizbin> (Which we're using internally - the private VPS version)
15:18:52 <Eduard_Munteanu> johnwalker: you can also use pattern guards
15:18:55 <johnwalker> cool
15:19:04 <johnw> fizbin: then I'd use MonadError
15:19:15 <Eduard_Munteanu> johnwalker: f xss | xs :> x <- viewr xss = ...
15:19:35 <johnw> fizbin: and wrap it up in a constraint synonym
15:19:59 <Eduard_Munteanu> That needs PatternGuards instead, though.
15:19:59 <johnwalker> how do you read :> ?
15:20:05 <johnw> type MonadFoo m = MonadError MyErrorType (StateT MyStateType m)
15:20:14 <prinsen> Eduard_Munteanu: I have entered GHCI now and has a file with the failing JSON, how do I run the parser manually?
15:20:17 <johnw> sorry
15:20:21 <benmachine> Eduard_Munteanu: actually PatternGuards is in Haskell2010 I think
15:20:27 <benmachine> so will be default-on as of... some version
15:20:32 <johnw> type MonadFoo m = (MonadError MyErrorType m, MonadState MyStateType m)
15:20:33 <benmachine> 7.something
15:20:34 <Eduard_Munteanu> johnwalker: usually some mental oompf, I don't read this stuff out loud to others :)
15:20:42 <Eduard_Munteanu> Hm.
15:20:58 <johnwalker> Eduard_Munteanu: lol
15:21:15 <Eduard_Munteanu> johnwalker: snoc might be a good name though
15:21:29 <benmachine> all GHC 7 had pattern guards by default I think
15:21:30 <Eduard_Munteanu> (the dual of cons)
15:21:34 <johnwalker> is that cons backwards?
15:21:40 <Eduard_Munteanu> Yes.
15:21:41 <johnwalker> oh no lol!
15:21:59 <Eduard_Munteanu> johnwalker: some other packages use that funny convention too
15:22:26 <Eduard_Munteanu> However that's the viewl/viewr representation, you might want to disambiguate.
15:22:40 <Eduard_Munteanu> (not the actual cons/snoc operation, that is)
15:22:56 <Eduard_Munteanu> Perhaps consed / snocced. :)
15:23:29 <johnwalker> i'm sure there are very good reasons for having two kinds of cons's
15:24:50 <Eduard_Munteanu> johnwalker: you can't possibly have it any other way, you can't define Seq's inductively as list-like things.
15:25:34 <Eduard_Munteanu> johnwalker: and pattern-matching would only work for data constructors
15:26:04 <Eduard_Munteanu> johnwalker: instead, viewl/viewr convert the Seq to a list-like type and you pattern-match on that
15:26:29 <johnwalker> ahh, gotcha
15:26:34 <Eduard_Munteanu> Seq is in fact a tree internally.
15:26:56 <johnwalker> how much more expensive would it be to just use a list as a queue?
15:26:57 <Eduard_Munteanu> :t Data.Sequence.cons
15:26:58 <lambdabot> Not in scope: `Data.Sequence.cons'
15:27:11 <benmachine> johnwalker: it's unpleasant to append to immutable lists
15:27:24 <johnwalker> gotcha
15:27:36 <benmachine> johnwalker: lists are great when you're faffing about near the head, because the long tail can be shared
15:27:38 <Eduard_Munteanu> johnwalker: it would perform quite badly... it would need to traverse the whole list to look at its end
15:27:48 <benmachine> but if you go replace the end of that tail with something else, you screw all that up
15:28:10 <k4r1m> just rewrote it to this http://lpaste.net/100988 but there is an issue and im not sure how to deal it with, i [] 0 = [] is the wrong return type. What am I suppose to return if its empty ?
15:28:14 <Eduard_Munteanu> johnwalker: it's also annoying to use compared to Seq.
15:28:25 <benmachine> k4r1m: you can't
15:28:30 <benmachine> k4r1m: !! just explodes in that case
15:28:48 <benmachine> k4r1m: a better solution might be to change your return type so that you can acknowledge the possibility of failure
15:28:58 <johnw> k4r1m: one way is to return Maybe t
15:29:00 <dwcook> k4r1m, there are no values of type t you have access to in that case. A better return type would be Maybe t, maybe.
15:29:12 <Eduard_Munteanu> k4r1m: there's no way you can always return the nth element of an arbitrarily-sized list
15:29:15 <johnwalker> ok, i'm going to go learn Data.Sequence then. thanks for the help benmachine, Eduard_Munteanu
15:29:20 <k4r1m> ah Monads, not there yet fellas.
15:29:28 <benmachine> k4r1m: no monads
15:29:29 <dwcook> k4r1m, you don't need to care about monads to use Maybe.
15:29:33 <benmachine> just data
15:29:40 <Eduard_Munteanu> k4r1m: this use of Maybe has nothing to do with monads
15:29:42 <benmachine> if you can do lists you can do Maybe
15:29:48 <k4r1m> why doesn't  i _ 0 = _ work?
15:29:51 <benmachine> Maybe is just like a list but... shorter
15:29:53 <Eduard_Munteanu> Lists are monads too. :)
15:29:58 <benmachine> k4r1m: _ is a pattern, not an expression
15:30:03 <enthropy> johnwalker: type Queue a = ([a], [a]) -- can be a sensible FIFO queue, since you only have to reverse the input list when the output list is empty which is not very often
15:30:06 <benmachine> k4r1m: you can match things against it but it doesn't have any value
15:30:14 <enthropy> but Data.Sequence is probably easier
15:30:26 <k4r1m> benmachine: the pattern of anything with 0, return that 'anything'?
15:30:40 <prinsen> How do I run the parser manually?
15:30:45 <benmachine> k4r1m: that's i x 0 = x
15:30:46 <dwcook> k4r1m, _ matches literally any value and throws it away.
15:31:15 <benmachine> k4r1m: and that doesn't work because the types are wrong
15:31:34 <k4r1m> benmachine: yeah true
15:31:56 <k4r1m> I guess !! is a little more complicated than I thought
15:32:11 <dwcook> k4r1m, a little less safe than you thought, more like; it crashes when it can't get an element.
15:32:16 <k4r1m> thanks for the help boys... and girls.
15:33:16 <dwcook> (If you're unsure of the gender of who you're talking to, using ungendered referents such as "everyone" is a reasonable way to go.)
15:33:16 <prinsen> if I run fromJSON in GHCI, I get the same error
15:34:06 <dwcook> references*
15:34:36 <henk> quchen: thank you (:
15:35:27 <k4r1m> l@(x:xs) gives the list, head and rest correct?
15:35:39 <Axman6> yep
15:36:01 <k4r1m> cool
15:36:21 <Rarrikins> xxs@(x:xs) is what the cool kids use, though.
15:36:59 * k4r1m writes it down
15:37:22 <monochrom> the only problem with lowercase l is that many fonts make it look like 1 or I or both :)
15:37:53 <henk> johnw: I did consider that, but can’t figure out why I chose not to, right now … Do I gain anything else from that?
15:37:57 <k4r1m> Haskell is turning out to be  pretty cool. Too bad the majority of "professors" have no idea how to teach it.
15:38:23 <benzrf> hey
15:38:24 <monochrom> anyway, you can pronounce "@" as "as". in fact, SML uses the word "as". fun f (l as (x::xs)) = ...
15:38:40 <Axman6> k4r1m: when it's used at university, it's not being taught to teach you haskell, it's being used to teach you other concepts
15:38:43 <dwcook> I find it funny you say that since I don't think I've ever noticed any language taught worse than JavaScript is.
15:38:51 <benzrf> are there any FP or Haskell conventions/conferences in north america that are open to minors?
15:39:19 <Axman6> they're all 18+, too many hookers
15:39:19 <monochrom> I think pretty much only local meetups are open to minors
15:39:26 <benzrf> aw.
15:39:29 <jle`> is there a meaningful way to serialize a TypeRep
15:39:40 <dwcook> Why are other things limited to adults?
15:39:58 <Axman6> I would guess they have a Binary instance jle` because they can be used with cloud haskell
15:40:31 <k4r1m> Axman6: true but they're easier ways to learn those concept without Haskell. Easier functional languages.
15:40:31 <jle`> there is none that comes with Data.Typeable :/
15:40:39 <monochrom> I don't actually know. to tell you the truth, I have not seen an explicit age requirement on academic conferences. perhaps they are open to minors too.
15:40:44 <k4r1m> and no not javascript.
15:40:48 <johnw> henk: I don't know your problem well enough to say
15:40:56 <Axman6> k4r1m: not sure I agree
15:41:05 <jle`> Axman6: I am looking at distributed-process's source though
15:41:14 <Axman6> haskell forces you to learn inportant copncepts, other languages let you do hacky crap
15:41:38 <monochrom> trade shows, of course, have all sorts of requirements and red tape to ensure a closed club
15:41:42 <benzrf> :o
15:41:46 <k4r1m> I found racket really easy
15:42:04 <benzrf> i was thinking of something where i could attend talks or meet people
15:42:09 <benzrf> probs not a trade show
15:42:29 <monochrom> although, there is no Haskell trade show, so we need not worry about that case yet :)
15:42:36 <benzrf> hue
15:42:46 <henk> johnw: No problems, the code I have works (: I’m looking for optimisations of any kind to make my code more robust, sensible, readable, etc.
15:42:55 <k4r1m> Axman6: offtopic, where/when are these confs with hookers?
15:43:18 <Axman6> I'll tell you when you're older
15:43:31 <Axman6> and we finally manage to convince some hookers to attend
15:43:36 <johnw> henk: well, readability is always enhanced by having a specialized type rather than just Int; and people already know what to do with a NominalDiffTime
15:44:52 <henk> johnw: ack, good points
15:47:56 <benzrf> is it just me or is the state monad basically just composition of 2-arg 2-output funcs
15:48:08 <dwcook> benzrf, s -> (a, s)
15:48:26 <henk> But how can I do a divMod on a NominalDiffTime to get the hours and minutes from it? Or should I be using different method there??
15:49:55 <dwcook> @type state
15:49:56 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
15:49:59 <dwcook> @type runState
15:50:00 <lambdabot> State s a -> s -> (a, s)
15:50:09 <Luke> is there a way to see haddock status for hackage packages or something?
15:50:13 <dwcook> benzrf, those two functions form an isomorphism
15:50:20 <dwcook> or witness an isomorphism, I should say
15:50:26 <benzrf> :I
15:50:35 <dwcook> Where m = State s
15:50:43 <dwcook> Um.
15:51:23 <dwcook> Maybe "bijection" would've been less scary?
15:51:32 <henk> johnw: Now that you mention it and I ask this question: I have no idea what to do with NominalDiffTime, but I know what to do with Integers (;
15:52:22 <johnw> fromIntegral, applied to NominalDiffTime, returns an amount in seconds
15:52:30 <henk> argh
15:52:32 <monochrom> "composing 2-arg 2-output functions" is right for the State Kleisli arrow, but not the State monad per se. you have to convert to Kleisli arrow, and then you get that symmetry.
15:53:08 <johnw> henk: using toRational, you get picosecond granularity
15:54:37 <henk> johnw: hrm, are you sure? I get an error: No instance for (Integral NominalDiffTime)
15:55:40 <johnw> let me check
15:55:58 <geekosaur> you have to import some module iirc
15:56:13 <geekosaur> not the one that defines NominalDiffTime but from the same package
15:56:24 <geekosaur> which .. o.O
15:56:27 <johnw> as, you are right
15:56:31 <johnw> ah*
15:56:32 <jfischoff> johnw: I think you want floor
15:56:39 <johnw> i know that "show" displays it as a fraction of seconds
15:56:48 <johnw> right, floor is what you want
15:57:19 <jfischoff> I can never remember how to use NominalDiffTime either :p
15:57:22 <johnw> internally, NominalDiffTime is like a Rational, or a floating-point with 10^-12 precision.  What it really is, only Data.Time knows
15:57:40 <johnw> plus, you can upgrade to using Data.Thyme, which is faster and gives you some cool lenses
15:57:56 <johnw> namely, it makes NominalDiffTime an instance of AdditiveGroup
15:58:05 <johnw> and it becomes a VectorSpace
15:58:15 <johnw> all of this is much cooler than a plain old Int :)
15:58:49 <henk> johnw, jfischoff: ah, cool, thank you very much
15:59:25 <henk> Yes, definitely better, much more expressive and sane.
15:59:43 * hackagebot zmcat 0.3 - Command-line tool for ZeroMQ.  http://hackage.haskell.org/package/zmcat-0.3 (LucasDiCioccio)
16:01:21 <johnw> henk: what I'd still like to see is a formatting function that displays a NominalDiffTime as a "duration".  Like "1h 2m", or just "1h", with a trunction if I don't care about seconds.  I don't think that's in any library yet
16:01:49 <johnw> aka, human-readable NominalDiffTime with better units than just seconds
16:01:54 <henk> benmachine: What kinds of inputs do you mean besides invalid ones?
16:03:02 <henk> johnw: That’s more or less what that module is about, just not (yet) flexible at all, only made for my usecase …
16:04:44 * hackagebot wai-routing 0.5 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.5 (ToralfWittner)
16:10:13 <henk> johnw: Latest annotation in http://lpaste.net/8633661649745608704 is what it looks now. What you need should more or less already be possible, isn’t it? Maybe allow passing a printf-string to the toString function …
16:11:48 <johnw> henk: so, more than likely I'm only going to convert to HMSTime to print it; so why even bother with that data type?
16:15:49 <henk> johnw: I have no idea … Maybe I thought it was helpful in some way. Or I was^Wam too much of a programming noob to be able to take shorter ways (:
16:22:30 <henk> hrm, complete module reduced to one function …
16:22:38 <isaacbw> what's the haskell graph situation like? Would I have a hard time working with and manipulating large networks with haskell?
16:28:16 <henk> johnw: Thank you very much for pointing that out, I condensed everything into this now: http://lpaste.net/100993
16:29:48 * hackagebot bindings-sophia 0.2.0.2 - Low-level bindings to sophia library  http://hackage.haskell.org/package/bindings-sophia-0.2.0.2 (EyalLotem)
16:32:55 <tapuu> Anyone here experienced with using the cereal library?
16:41:35 <kalevra> newbie question, how do you index into a tuple,  doing this (8,1,25,335) !! 3 doesn't work
16:42:57 <shepheb> kalevra: pattern matching, in haskell98
16:43:07 <pavonia> > (\(_, _, x, _) -> x) (8,1,25,335)
16:43:08 <lambdabot>  25
16:43:17 <shepheb> the lens library has _1, _2 etc. lenses.
16:43:33 <geekosaur> tuples are not lists, you do not index them like with (!!)
16:44:15 <pordan30> if your tuples are carrying that much information, it's probably better to replace them with a record; then you get named fields and such.
16:46:07 <johnw> henk: looks good!
16:46:20 --- mode: ChanServ set +o johnw
16:46:20 --- mode: johnw set +b *!~ircap@80.30.151.134nil
16:46:20 --- kick: away_ was kicked by johnw (Spamming)
16:46:25 --- mode: johnw set -o johnw
16:47:45 <johnw> kalevra: anything higher than a 2-tuple should be a record, it pays off in the end
16:49:13 <kalevra> honestly I wasn't thinking that far. I just wanted to get the remainder from `divMod`
16:49:44 <dwcook> snd
16:49:47 <dwcook> @type snd
16:49:47 <lambdabot> (a, b) -> b
16:50:12 --- mode: ChanServ set +o johnw
16:50:12 --- mode: johnw set +b *!*@80.30.151.134nil
16:50:12 --- kick: away_ was kicked by johnw (Kicked)
16:50:17 --- mode: johnw set -o johnw
16:50:37 <henk> johnw: thanks (: Now I’m on to the next module. My plan is to have less code for actual function than for commandline option parsing. If all my code can be condensed as much as the HMSTime module, that should be no problem (;
16:51:13 <geekosaur> you have garbage on your ban
16:51:17 <johnw> I see that, thanks
16:51:19 --- mode: ChanServ set +o johnw
16:52:19 --- mode: johnw set +b *!*@80.30.151.134
16:53:04 <prinsen> Shouldn't Producer >-> ( do { i <- await; forever $ yield i } >-> Consumer run Consumer forever?
16:53:33 <prinsen> Right now it just run once
17:00:24 <dwcook> prinsen, that looks like it infinitely yields the first element of the given producer. Is that not what it does?
17:00:35 <dwcook> @where ops
17:00:35 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:00:38 <dwcook> away_ is at it again
17:00:48 <copumpkin> at what?
17:00:50 <Rarrikins> away_ is still in the room.
17:00:58 --- mode: ChanServ set +o copumpkin
17:01:03 <Rarrikins> copumpkin: johnw banned away_ for spam.
17:01:09 <copumpkin> oh, PM spam?
17:01:12 <dwcook> copumpkin, spamming by PM. See above where Cale kicked them
17:01:12 <Rarrikins> Yes.
17:01:17 <geekosaur> tried to at least
17:01:26 --- mode: ChanServ set +o geekosaur
17:01:27 --- kick: away_ was kicked by copumpkin (go away)
17:01:27 <dwcook> johnw I mean
17:01:29 --- mode: copumpkin set -o copumpkin
17:01:34 --- mode: ChanServ set +o copumpkin
17:01:34 --- mode: geekosaur set -o geekosaur
17:01:44 --- mode: copumpkin set +b away_!*@*
17:01:51 <geekosaur> presumably switched addresses or something
17:01:55 <copumpkin> probably won't keep them out :/
17:02:07 <copumpkin> oh wait
17:02:12 <copumpkin> johnw just messed up the ban hostmask
17:02:42 <geekosaur> suggest a ban on *!~ircap@ since that seems to be common for these bots (but not yet lemme check the channel list)
17:03:12 <prinsen> dwcook: im guessing that the pipe fails downstream, checking atm
17:04:19 --- mode: copumpkin set -o copumpkin
17:04:22 <prinsen> dwcook: ah, I had misunderstood pipes, downstream only awaits one value, so it only runs once
17:04:44 <prinsen> dwcook: need some kind of loop
17:04:51 <dwcook> Yep
17:07:12 <haasn> Why does Data.Map have a mapKeys but not a traverseKeys (and no, I don't have access to lens)
17:07:16 <haasn> I really need it :(
17:07:29 <haasn> I can't even traverse over pairs. It seems to me I have to go through toList/fromList
17:12:06 <copumpkin> haasn: traverseWithKey?
17:12:13 <copumpkin> oh, you want to change the keys?
17:12:42 <haasn> copumpkin: yep
17:17:36 <prinsen> dwcook: im using for, but it wants \a -> Effect m () as its second argument. However, none of my components has () as return type
17:36:31 <peddie> anyone here familiar with hsc2hs?  it seems to be cutting off certain struct field names when I use the #field macro
17:43:33 <dwcook> prinsen, for has a more general type than that
17:43:42 <dwcook> @type Pipes.for
17:43:42 <lambdabot> Couldn't find qualified module.
17:44:58 <dwcook> prinsen, http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes.html#v:for
17:45:25 <dwcook> Oh, I see what you mean
17:46:05 <dwcook> You've probably just got some of the types wrong
17:46:24 <dwcook> I'd have to take a look to be more specific or at least see an error message
18:01:36 <colDrMcBeardman> is there a way to make ghci never ever ring the system bell?
18:03:15 <byorgey> colDrMcBeardman: yes, don't run it
18:03:31 <byorgey> (I'm not sure =)
18:04:01 <enthropy> configure the terminal to not ring it?
18:04:10 <colDrMcBeardman> enthropy, it's a.... baroque terminal.
18:04:39 <Eduard_Munteanu> Mute the bell then.
18:04:46 <colDrMcBeardman> it actually prints a little bell instead, which is annoying because I'm tempted to delete it.
18:04:55 <colDrMcBeardman> there's no noise.
18:04:55 <Eduard_Munteanu> Ah.
18:04:56 <hpc> sed the bell terminal to ''!
18:05:06 <hpc> use the pipes luke
18:05:14 <dwcook> Is it one of those typewriter terminals?
18:05:29 <dwcook> That'd be pretty cool to use for like five minutes
18:05:36 <hpc> i feel like readline would have trouble with those
18:06:17 <mmmm> Does it print like a unicode bell symbol or what?
18:06:38 <colDrMcBeardman> mmmm: yes, I believe so
18:07:31 <colDrMcBeardman> dwcook, actually, it's 9term
18:07:50 <colDrMcBeardman> hpc, oh it does. I set TERM=dumb, but that only solves some things.
18:14:47 <shepheb> on a scale from id to unsafeCoerce, how scared should I be of UndeciableInstances?
18:15:50 <gamegoblin> The monad instance of the Free monad is
18:15:54 <gamegoblin>  instance (Functor f) => Monad (Free f) where     return = Pure     (Free x) >>= f = Free (fmap (>>= f) x)     (Pure r) >>= f = f r
18:16:29 <gamegoblin> Is the f in the bind decalaration the same f as in the first line? I.e is it a functor?
18:17:07 <gamegoblin> Or are they in different namespaces
18:17:50 <acowley> Does cabal run not pass +RTS flags to the executable?
18:18:35 <gamegoblin> Nevermind figured it out
18:19:25 <acowley> shepheb: Not too scared
18:28:13 <peddie> is anyone around familiar with hsc2hs?  I'm getting parse errors from stuff its macros generated, and I'm having a hard time figuring out what's gone wrong
18:28:27 <c_wraith> shepheb: UndecidableInstances is entirely safe. It relaxes some restrictions that structurally guarantee the type-checker terminates, but that's it.
18:28:52 <c_wraith> shepheb: and furthermore, the typechecker will still terminate because it has a recursion depth limit - an extra non-structural limit.
18:29:22 <c_wraith> peddie: It's often useful to dig up the C file it creates, and take a look at it.
18:30:27 <shepheb> solid. that's what I thought, just wanted to check
18:30:36 <peddie> c_wraith: I thought it generates a .hs file?
18:30:59 <shepheb> I'm writing some pretty experimental API stuff right now, and it's pushing my knowledge of what the typchecker will accept.
18:31:00 <c_wraith> peddie: it does both.  It generates a C file that generates that .hs file.  Yes, it's kind of bizarre.
18:31:25 <geekosaur> that's how you be certain that you have the C struct access aligned right in Haskell
18:31:28 <peddie> c_wraith: oh my goodness
18:31:31 <geekosaur> anything else is unreliable
18:31:37 <peddie> any idea where cabal might be putting that C file?
18:31:51 <c_wraith> peddie: somewhere in dist/build, iirc
18:32:14 <peddie> c_wraith: hmm, I don't have any c files in there, just a .hs file that it's apparently generated
18:32:41 <peddie> c_wraith: the parse error gives a line in the .hsc file, not any of its byproducts
18:33:10 <c_wraith> hmm.  I don't recall, then.  You could still look to see what's in the generated .hs file, but sometimes the intermediate .c file is helpful too
18:33:12 <geekosaur> need -k I think
18:33:23 <geekosaur> or run by hand with --no-compile
18:33:34 <akurilin2> Hey guys quick question: I just added a source to cabal from a local repository and I'm not quite sure it's picking it up. How do I know if it's working?
18:33:46 <akurilin2> Is there a way to force re-fetching of the package?
18:33:57 <akurilin2> (cabal sandbox)
18:34:37 <peddie> geekosaur: are you talking to me?
18:34:48 <geekosaur> about hsc2hs, yes
18:38:20 <peddie> geekosaur: what step of the process are you talking about?  I'm using cabal to run hsc2hs, so I'm not sure what all the different stages are
18:39:01 <geekosaur> to see the generated C file you need to tell cabal to pass -k to hsc2hs
18:39:31 <noprompt> 983
18:39:32 <geekosaur> probably with --hsc2hs-option=k
18:39:33 <geekosaur> er
18:39:35 <geekosaur> probably with --hsc2hs-option=-k
18:39:46 <peddie> OK, I see
18:39:48 <peddie> thanks
18:44:38 <peddie> ah, apparently this troublesome macro comes from bindings-DSL
18:46:43 <peddie> any bindings-DSL users around?
18:47:05 <c_wraith> I *have* used it, but I can't say as I remember much at this point.
18:48:10 <enthropy> you need to #include a header that bindings-DSL provides
18:48:43 <enthropy> bindings.dsl.h
18:49:15 <peddie> enthropy: yeah, I've got that one -- c2hsc put that in for me
18:50:13 <peddie> it's not a missing definition or anything; it's a parse error in a #starttype declaration, which apparently comes from bindings-DSL
19:02:32 --- mode: johnw set -o johnw
19:11:46 <shepheb> I can't seem to define a Monad instance for a type synonym.
19:12:04 <geekosaur> you need FlexibleInstances for that
19:12:10 <shepheb> if I leave off an argument, I get an error that partially applied synonyms are not allowed, and if I provide it, of course, it fails because Monad needs * -> *
19:12:22 <shepheb> I have FlexibleInstances
19:12:50 <geekosaur> then you need parens probably. Monad (Foo a) not Monad Foo a
19:14:13 <shepheb> got em. let me paste
19:14:46 <enthropy> did you define the type synonym?
19:15:13 <enthropy>  type RST r s m = ReaderT r (StateT s m)
19:15:20 <enthropy>  type RST r s m a = ReaderT r (StateT s m) a -- bad
19:15:50 <shepheb> oh I see.
19:16:23 <shepheb> well, not quite
19:16:27 <enthropy> if you actually need to rearrange type parameters, you probably have to define a newtype / data
19:16:40 <shepheb> that extra parameter is a dummy here, or to put it another way it's always ()
19:16:53 <shepheb> see http://lpaste.net/100996
19:18:58 <shepheb> really I should probably just change the DAO type class to use :: ... d -> m ((), d) and then it becomes isomorphic to StateT d m
19:19:54 <enthropy> @unmtl StateT d m a
19:19:54 <lambdabot> d -> m (a, d)
19:20:57 <enthropy> maybe you mean  d -> m (x, d)
19:36:38 <peddie> johnw: are you the author of bindings-DSL and c2hsc?
19:36:53 <johnw> I am the maintainer of the former, and author of the latter
19:37:07 <peddie> got time for a question or two?
19:37:11 <johnw> sure
19:37:28 <peddie> I'm trying to use bindings-DSL to create bindings to the libastro library from xephem
19:37:49 <peddie> and I've run into two issues so far, both to do with some of these crazy macros
19:37:49 <johnw> and you're using c2hsc to generate the first round?
19:37:56 <peddie> yeah
19:37:56 <johnw> ah, macros
19:38:03 <johnw> c2hsc doesn't handle macros well
19:38:17 <peddie> oh, no, I mean in the bindings-dsl macros like #field and #starttype and so on
19:38:26 <johnw> ahh
19:38:28 <johnw> ok, what's the issue?
19:38:58 <peddie> there's an object with fields called things like 'b_2compute' and 'b_nbp'
19:39:13 <johnw> can you show me what you're looking at, and the error you're seeing?
19:39:17 <peddie> sure
19:39:55 <peddie> https://github.com/brandon-rhodes/pyephem/blob/master/libastro-3.7.5/astro.h#L220 see these fields?
19:40:03 <johnw> yes
19:40:10 <peddie> https://github.com/brandon-rhodes/pyephem/blob/master/libastro-3.7.5/astro.h#L465
19:40:16 <peddie> they get redefined for some unknown reason
19:40:43 <peddie> but I guess that means I have some trouble when I try to run hsc2hs, because the #defines overwrite the names of the fields
19:40:56 <johnw> you'll have to edit your .hsc files and fix this there
19:41:10 <peddie> that's what I've done to work around this problem
19:41:16 <johnw> yep, that's the right way
19:41:20 <peddie> I didn't know if there was something I was missing
19:41:23 <peddie> OK, well, thanks
19:41:29 <johnw> whenever cpp is involved, you generally have to fix up the .hsc manually
19:41:37 <peddie> one more problem; this one has to do with #starttype I think
19:41:42 <johnw> c2hsc is to be considered a "best guess" at the .hsc contents
19:42:25 <peddie> I run c2hsc on astro.h and get Astro.hsc, which is fine, but when I go to build it with cabal, I get src/Bindings/Libastro/Internal/Astro.hsc:370:1:
19:42:27 <peddie>     parse error on input `}'
19:42:50 <peddie> line 370 is the beginning of the struct for ObjPl, so it's a #starttype
19:42:57 <johnw> show me?
19:43:02 <peddie> let me paste it
19:43:04 <peddie> one sec
19:44:01 <peddie> http://lpaste.net/100997
19:44:31 <johnw> and what is the error?
19:44:44 <peddie> parse error on input `}' on line 730 column 1
19:44:53 <peddie> err
19:44:54 <johnw> ah, I was looking at 370
19:44:55 <peddie> 370
19:45:00 <peddie> sorry, 370 is right
19:45:10 <johnw> hmm
19:45:14 <peddie> I looked at the definition of #starttype and it definitely doesn't start with a }
19:45:31 <johnw> try deleting the comment there
19:45:36 <johnw> oh, wait
19:45:39 <johnw> look at line 341
19:45:40 <peddie> that seems to give the same error
19:45:51 <peddie> ahhhh it skipped one!
19:46:06 <peddie> that's a union type; is there anything useful I can tell hsc2hs there?
19:46:08 <johnw> it didn't translate that union at all
19:46:16 <johnw> I'm pretty sure Bindings-DSL supports union types
19:48:17 <peddie> the Detailed Documentation on the Bindings-DSL wiki seems to be empty; is documentation about things like unions somewhere else?
19:48:28 <johnw> let me check
19:49:51 <jrmithdobbs> oh this sounds fun: http://plv.mpi-sws.org/backpack/
19:50:07 <johnw> you could define a union type outside, using "#starttype union HiddenUnion", and then make u be of type HiddeUnion
19:50:12 * hackagebot husk-scheme 3.16.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.16.1 (JustinEthier)
19:50:27 <peddie> ok, yeah, I was starting to write out my own definition for that union, because it's anonymous in the original header
19:50:52 <johnw> i see that it supports nested anonymous structs, but I don't see docs related to nested anynomous unions
19:51:53 <peddie> are there docs about non-anonymous unions?  it's not apparent to me how to make a sum type using #starttype and #stoptype
19:52:10 <tbelaire> Hi, I'm trying to use the Sing singleton type in GHC.TypeLits
19:52:18 <jrmithdobbs> is this actually in a usable state I wonder
19:52:33 <tbelaire> and it keeps saying 'sing is not in scope'
19:52:45 <johnw> peddie: "#starttype union <Name>"
19:53:12 <peddie> johnw: thanks!  I can't find this in any docs, but I can carry on with that and see how I do :)
19:53:22 <johnw> it mentions it here: https://github.com/jwiegley/bindings-dsl/wiki/Types
19:53:29 <jrmithdobbs> in fact, i don't see any code outside of the paper ... um wtf =/
19:53:33 <johnw> oh, see also https://github.com/jwiegley/bindings-dsl/wiki/TipsAndQuestions
19:53:36 <johnw> the first question :)
19:53:46 <peddie> Oh!  I didn't see any of those pages
19:53:57 <johnw> yeah, they aren't linked from the home page for some reason :(
19:54:02 <johnw> i'll make a note to fix that
19:54:11 <peddie> hehe
19:54:16 <peddie> johnw: thanks very much for your help
19:54:18 <peddie> this is great
19:54:23 <peddie> and for writing c2hsc!
19:54:34 <johnw> you're welcome!  I'm around for many hours yet, so if you have questions I'll be here
19:54:46 <peddie> thanks, will be sure to ask if I get stuck again
20:00:13 * hackagebot ripple 0.2 - Ripple payment system library  http://hackage.haskell.org/package/ripple-0.2 (StephenWeber)
20:07:57 <dsamperi> help
20:07:57 <dsamperi> ?
20:08:21 <dwcook> dsamperi, ask your question
20:08:25 <c_wraith> You'll need to be more specific than that.
20:14:53 <haasn> (I think those were commands directed at his IRC client!)
20:15:36 <c_wraith> Oh.  That would make sense.
20:16:19 <dwcook> ls
20:16:38 <heatsink> bin
20:16:42 <heatsink> home
20:16:43 <heatsink> usr
20:17:04 <monochrom> do_not_open.exe
20:17:13 <haasn> sudo wine do_not_open.exe
20:17:15 <monochrom> here_be_dragons.png
20:17:16 <dwcook> mono do_not_open.exe
20:17:40 <jrmithdobbs> tor-ssh urhouse
20:17:53 <monochrom> http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
20:18:05 <newtohaskell> I feel like there must be a better way to write this, but I can't seem to figure it out
20:18:09 <newtohaskell> http://lpaste.net/100999
20:18:25 <jrmithdobbs> monochrom: heh
20:18:32 <peddie> ~
20:18:39 <newtohaskell> It's an exercise from Beginning Haskell
20:19:01 <newtohaskell> I'd appreciate a little guidance if I'm doing something obviously wrong
20:19:08 <heatsink> The only difference between the case branches is the ClientKind value
20:19:11 <jrmithdobbs> please don't use Kind in the name like that it's confusing
20:19:21 <newtohaskell> jrmithdobbs: It's in the book.
20:19:26 <jrmithdobbs> that's horrible
20:19:31 <haasn> newtohaskell: you could use a fold instead of “manually” folding
20:19:35 <heatsink> You could split that into code that converts a Client to a ClientKind, and code that calls insert
20:19:59 <dwcook> So many words people use generically are taken – type, kind, category, class
20:20:09 <jrmithdobbs> set
20:20:09 <dwcook> I think even sort is
20:20:11 <haasn> newtohaskell: instead of a Map for a measly 3 different “kinds” (which can also optionally be missing, note) I'd just use a 3-tuple or a record
20:20:12 <heatsink> sort, variety
20:20:24 <jrmithdobbs> collection is still free in haskell i think ;p
20:20:33 <jrmithdobbs> only one i can think of related to that category ;p
20:20:34 <newtohaskell> haasn: I'm just doing what the book says. I imagine it's just a toy example
20:21:03 <monochrom> I know how to simplify it, but my simplification requires non-Haskell things such as predicate subtypes or refinement types.
20:21:07 <haasn> I would rewrite all of this using lenses. But that's not beginner-friendly :(
20:22:23 <newtohaskell> haasn: Annotated with the text of the exercise: http://lpaste.net/101001
20:22:24 <monochrom> I think Data.Map has some functions for precisely updates like this
20:22:34 <haasn> something like foldr (\x -> ix (kindOf x).contains x .~ True)
20:23:39 <monochrom> look for insertWith
20:23:40 <haasn> (even if you really want a map, I think a MultiMap would be more idiomatic than a Map to a Set, because of the ambiguity between Nothing and Just Set.empty)
20:24:47 <johnw> i converted from a Map to Set to a MultiMap recently, and it was a good move
20:25:26 <newtohaskell> monochrom: Hmm. So maybe insertWith (S.insert something)?
20:25:50 <jrmithdobbs> multimap is just hashmap without unique constraint right?
20:25:55 <monochrom> yeah
20:26:15 <haasn> jrmithdobbs: s/hashmap/map/
20:26:20 <heatsink> newtohaskell: My suggestions are to define global functions for 'empty' and 'insert' on your data type; to fold over the list in classifyClients; and to define a function that gets a client's kind.  classifyClients should be a one-liner.
20:27:22 <haasn> newtohaskell: I'd think something like insertWith S.union ... $ S.singleton x
20:27:32 <haasn> but I guess yours works
20:27:57 <newtohaskell> haasn: Oh, that's a good thought
20:28:11 <ian_mi> I might use something like one the partition functions to split a set into subsets
20:28:59 <haasn> newtohaskell: actually I might rewrite the whole thing as a list comprehension
20:30:00 <haasn> S.fromList [ g | g@GovOrg {} <- xs ] -- ditto for the other two
20:32:16 <ian_mi> setOf (folded . govOrg) xs
20:32:40 <jrmithdobbs> wonder why hslua hasn't updated to 5.2 =/
20:32:49 <Tehnix> is there an equivalent of running `python -c "print 22"` for haskell?
20:33:06 <Tehnix> i.e. execute this command, in say, ghci?
20:33:21 <jrmithdobbs> Tehnix: ghci < <(echo 'putStrLn "what"'); assuming a modern bash
20:33:22 <Tehnix> just returning the output of it
20:33:52 <Tehnix> jrmithdobbs: hmm, any way to get rid of all the "Loading package.." etc?
20:34:34 <jrmithdobbs> Tehnix: no because someone put an unnecessary check in runhaskell
20:34:45 <jrmithdobbs> $ runhaskell <(echo 'putStrLn "what"')
20:34:46 <jrmithdobbs> *** Exception: /dev/fd/63: hFileSize: inappropriate type (not a regular file)
20:34:54 <Tehnix> :(
20:35:11 <haasn> ghc -e ?
20:35:28 <samba1> Would anybody be willing to do a little code review for me? Of an assignment for a class I followed online?
20:35:29 <haasn> eg. ghc -e 'print 22'
20:35:37 <samba1> http://www.seas.upenn.edu/~cis194/lectures.html - Assignment 12
20:35:38 <Tehnix> ah, thanks! :9
20:35:39 <jrmithdobbs> oh hey
20:35:43 <Tehnix> :)*
20:35:44 <samba1> http://lpaste.net/2204267457865056256
20:36:19 <samba1> the top is given, the bottom is my code, I think battle and successProb could be more idiomatic... or any commentary
20:36:27 <jrmithdobbs> samba1: i approve of your game choice if nothing else ;p
20:36:28 <heatsink> Why is it in Optima?
20:37:11 <samba1> ha, the assingments choice, not mine. i had heard of risk before but it's not so popular in china i don't think
20:38:20 <monochrom> oh, risk! I once painstakingly wrote a program to calculate all sorts of probabilities of it, yeha
20:38:22 <heatsink> Can you use any library functions?
20:38:24 <haasn> samba1: 1. GeneralizedNewtypeDeriving is not safe in general. It's fine here, but you may want to know that. 2. ‘first’ already exists in Control.Arrow. 3. if you use a smart constructor for DV that ensures it's always in the range 1-6, you don't need the extra check on randomR
20:38:39 <haasn> oh
20:38:41 <monochrom> actually I calculated expected values, not probabilities
20:38:41 <haasn> that's not your code :P
20:40:13 <samba1> I suppose I can use anything... it's not actually my class, just an old class I was refered to
20:40:14 <jrmithdobbs> haasn: GeneralizedNewtypeDeriving is safe in 7.8!
20:40:16 <haasn> heatsink: rollFor' is replicateM
20:40:20 <haasn> jrmithdobbs: oh?!
20:40:24 <jrmithdobbs> haasn: yes!
20:40:33 <ian_mi> woohoo
20:40:36 <haasn> heatsink: replicateM n die -- that is
20:40:53 <heatsink> haasn: should we tell samba1?
20:40:57 <haasn> jrmithdobbs: that's pretty cool; how'd they fix it?
20:41:05 <haasn> heatsink: sorry! cc samba1
20:41:06 <samba1> i see
20:41:07 <jrmithdobbs> haasn: i forget the details but it's awesome ;p
20:41:18 <haasn> heatsink: colors got me confused, you two have the same :(
20:41:47 <heatsink> I see
20:42:50 <samba1> can battle be made less messy? so many tuples
20:43:26 <samba1> and the if thne in successProb, i know it's not nice, but at that point it seemed the clear way
20:44:23 <haasn> well.. you *could* rewrite (if d == 0 then 1 else 0) as (case d of 0 -> 1; _ -> 0)..
20:46:40 <haasn> that entire function could be something like (%1000) . length . filter (==0) <$> replicateM 1000 (invade bf)
20:47:01 <haasn> slightly different check actually
20:47:12 <jroesch_> Is there anyway write an instance declaration for a type class given the type is a type family type synonym?
20:47:59 <haasn> jroesch_: I don't quite follow; you want to write an instance SomeClass MyTypeFamilySyn  or do you want to write an instance SynonymForSomeClass SomeType?
20:48:32 <peddie> johnw: any suggestions on how to handle the bit-packed struct at https://github.com/brandon-rhodes/pyephem/blob/master/libastro-3.7.5/satlib.h#L18
20:49:23 <haasn> Huh, I thought the former would actually be possible with TypeSynonymInstances
20:49:23 <jroesch_> haasn: the first I want to be able to be able to write `instance (Serialize a) => Serialize (MyTypeFamilySyn a)`
20:49:32 <haasn> but it seems like it's just flat-out illegal now
20:50:02 <jroesch_> haasn: I read as much but was hoping someone had another suggestion
20:50:04 <haasn> jroesch_: oh, that wouldn't be possible either way; type family synonyms aren't injective
20:50:43 <johnw> peddie: hmm.. you may need to handle that with getter/setter functions
20:50:51 <levi> Ew, C bitfields.
20:51:05 <peddie> johnw: so just leave them all as CUint and deal with it myself
20:51:08 <jroesch_> yeah unfortunately is makes sense the other piece of code isn't mine and was trying to serialize it, time to figure out alternatives
20:51:09 <peddie> that's palatable
20:51:17 <haasn> jroesch_: consider:  type family Foo a where Foo Int = Blah; Foo String = Blah
20:51:28 <haasn> jroesch_: what does a “Serializable Blah” constraint resolve to?
20:51:52 <peddie> thanks :)
20:51:59 <johnw> peddie: yeah; the 'bits' library should give you some very convenient ways to deal with the Haskell side
20:52:14 <peddie> johnw: great!
20:52:20 <johnw> or you could write the accessors as C function in the .hsc.c file
20:52:44 <jroesch_> haasn: right it makes perfect sense
20:52:56 <peddie> .hsc.c = the output file that writes the .hs file?
20:53:10 <enthropy> you may be able to write:   instance (Serialize a, MyTypeFamilySyn a ~ b) => Serialize b
20:53:23 <haasn> enthropy: with overlapping instances only
20:53:23 <Hermit> bos: are you around?
20:53:36 <haasn> (which is just not good)
20:53:42 <peddie> oh no, johnw I'm getting Satlib.hsc:45:5: error: cannot take address of bit-field ‘catno’
20:53:49 <enthropy> yes it overlaps
20:54:00 <peddie> even though I've instructed it to use CUint
20:54:09 <haasn> enthropy: also that still doesn't work; ‘a’ is ambiguous
20:54:28 <haasn> there's no way to “solve” this if there's no clear semantics on what it *should* be doing
20:56:22 <levi> C bitfield packing is implementation-defined. :(
20:56:24 <enthropy> pick at random
20:56:58 <Welkin> huffman coding
20:57:03 <peddie> levi: yeah . . . this is the code I have to work with . . .
20:57:10 <enthropy> more seriously, it is possible to add more constraints that will calculate the inverse of MyTypeFamilySyn
20:57:26 <pavonia> Would such an instance be possible with data families?
20:57:39 <geekosaur> peddie, CUInt won't help there
20:57:55 <geekosaur> bitfields are not addressible, no matter what base type
20:58:10 <peddie> geekosaur: yeah . . . I think I need to use #array_field se_id , CUInt and deal with it myself
20:58:55 <jrmithdobbs> who was it that gave that talk about type <-> untyped boundaries or w/e recently?
20:59:07 <haasn> enthropy: assuming MyTypeFamilySyn is invertible, I guess you could define your own “inverse” TF and use it as instance Serializable (MyTypeFamilySynInv a) => Serializable (NewtypeWrapper a)
20:59:09 <levi> I want Bitdata in Haskell.
20:59:42 <peddie> johnw: geekosaur: thanks for your help
21:00:27 <geekosaur> levi: a somewhat common request, with some stuff on hackage that doesn't quite scratch the itch, is something like Erlang's way of handling it
21:01:12 <Rylee> Hi, is there any way to make http://lpaste.net/101002 return true?
21:01:48 <Rylee> I was joking around wiht my boyfriend, who said "5^2 is always greater than 3^2", to which I retorted "for most values of 2!"
21:02:11 <pavonia> haasn, enthropy: Would "instance Foo a => Foo (Func a)" be possible with a data family Func?
21:02:26 <enthropy> did you try?
21:02:31 <pavonia> no
21:02:40 * enthropy guesses no
21:02:45 <haasn> maybe
21:02:53 <enthropy> but you can put the stuff into a constraint
21:02:57 <enthropy> for sure
21:03:09 <haasn> pavonia: yes, it is possible
21:03:13 <geekosaur> Rylee: mathematically I would have to say no
21:03:22 <haasn> pavonia: data families are injective \o/
21:03:31 <geekosaur> unless you want to get into weird corners of math
21:03:47 <geekosaur> (the most obvious such corner won't work because complex numbers can't be meaningfully compared)
21:03:48 <levi> geekosaur: I'm having trouble parsing your statement; could you rephrase it?
21:04:28 <geekosaur> levi: Erlang has a nice syntax for bit-oriented types. People have tried to make something similar in Haskell, mostly with shortcomings or ugly syntax
21:04:39 <levi> geekosaur: OK, I follow you now.
21:04:55 <jrmithdobbs> can we steal the actor impl before the bit twiddling? thanks
21:05:00 <jrmithdobbs> ;p
21:05:31 <levi> Mark Jones' HASP group has done a bunch of work on Bitdata, but most of the recent work has been in a Haskell-inspired language rather than Haskell.
21:05:46 <levi> jrmithdobbs: Cloud Haskell?
21:05:50 <Welkin> playing with bits is a pain in anything other than assembly
21:06:33 <levi> As a frequent programmer of device drivers and network protocols, I am highly annoyed when people call C 'portable assembly language'.
21:07:51 <levi> All the assembly-level stuff is implementation defined and thus non-portable. And it sucks terribly as a high-level language. There just aren't any reasonable alternatives at the moment in its niche. :/
21:08:00 <Welkin> I sometimes refer to C as "macro-assembly"
21:08:10 <Welkin> but that is only because of the style of C used for microcontrollers
21:08:24 <Welkin> C can still only work with bytes as the smallest unit of data, unfortunately
21:08:29 <jrmithdobbs> levi: depends on how a legal department defines a distribution event i guess since plugins is lgplv2 if you ship a binary ...
21:09:08 <geekosaur> Welkin: Erlang is actually quite good at it, since one of the things it's used for is working with bit-oriented data intended for hardware interfacing
21:09:10 <jrmithdobbs> levi: but ya it's looking interesting so far
21:09:12 <geekosaur> (phone switches)
21:09:34 <levi> Well, microcontroller C was traditionally done with a compiler supplied by your microcontroller manufacturer, so portability was not a concern and they optimized all the primitives for their particular architecture.
21:10:02 <levi> And there's inline asm anyway.
21:10:08 <Welkin> yeah
21:10:12 <Welkin> inline asm is always fun
21:10:26 <Welkin> I wish I could do that in all my C programs
21:10:35 <levi> But you write macro-assembler-style C in gcc and turn the optmizer on, and you are likely to get burnt.
21:11:55 <levi> Anyway, not the place for C rants. The Bitdata stuff described in the Habit language report sounds lovely to me.
21:13:47 <levi> Apparently Galois has implemeted a subset of it as a quasiquoter for their Ivory eDSL in Haskell.
21:14:17 <levi> https://github.com/GaloisInc/ivory/blob/master/ivory-bitdata/docs/ivory-bitdata.md
21:22:32 <carter> levi: i think C is terrible at using hardware ight
21:22:35 <carter> *right
21:22:47 <carter> levi: also, i think the right "bit data" proposal
21:22:51 <carter> would totally get into ghc
21:22:55 <carter> and i'd be happy to help
21:22:59 <carter> if you wanted to make it happen
21:23:00 <johnw> carter: oh, you're not going to argue that nothing can be better than hand-written C?
21:23:07 <geekosaur> C was good at it for its time
21:23:09 <carter> C is shitty
21:23:18 <carter> and doesn't let me use modern hardware nicely
21:23:22 <geekosaur> problem is, its time was the 1970s
21:23:24 <carter> unless i use lots and lots of intrinsics
21:23:25 <carter> yes
21:23:39 <carter> I have 4-6 levels of memory, no 1
21:23:41 <carter> *not 1
21:23:45 <FOSScookie> I am trying to build a list of programming languages I should learn and I would like to know why I should add Haskell to that list. Currently my list is as follows: C++, Java, Python
21:23:53 <carter> FOSScookie: yes
21:24:02 <FOSScookie> What benefits would Haskell bring?
21:24:17 <carter> FOSScookie: you'll have people say "hey, wannna try patching the compiler"
21:24:20 <jrmithdobbs> FOSScookie: because your list is boring and not fun
21:24:23 <carter> and you'll learn math
21:24:31 <carter> and write crazy parallel code
21:24:35 <FOSScookie> jrmithdobbs: But very realistic too.
21:24:35 <carter> and learn new things
21:24:41 <jrmithdobbs> FOSScookie: and will make you think programming is boring and stupid
21:24:43 <pordan30> whether and why you should learn haskell depends on why you believe you should learn hasell
21:24:46 <carter> FOSScookie: its a good list for meeting HR checklsits
21:24:49 <carter> which is valuable
21:24:53 <geekosaur> on the practical side, there are companies that look for Haskell experience even though they don't use Haskell, because proficiency in Haskell usually translates to much greater proficiency in other languages
21:24:54 <carter> income is a nic ehting
21:25:14 <geekosaur> Haskell teaches you how to *think* better as a programmer
21:25:24 <haasn> Haskell makes programming fun for me
21:25:30 <haasn> I do not like boring things
21:25:34 <haasn> they tend to bore
21:25:34 <pordan30> it makes programming in other languages a chore, so that's a point against haskell, i suppose
21:25:47 <johnw> Haskell encourages computing as a science
21:25:50 <jrmithdobbs> it may also lead to getting yelled at by style guideline nazis in projects written in other languages
21:25:53 <jrmithdobbs> fair warning
21:26:09 <FOSScookie> Would it be too much if I add in C along with Haskell? Would that be too much?
21:26:19 <FOSScookie> 5 langs?
21:26:26 <johnw> you already have C++
21:26:37 <johnw> then I wouldn't bother with C
21:26:37 <copumpkin> FOSScookie: you should maximize the information gain by learning languages that are as different as possible.
21:26:46 <jrmithdobbs> you should drop c++ and java and add erlang, cl, and ruby
21:26:58 <jrmithdobbs> or s/ruby/rust/
21:26:58 <johnw> in fact, I'd recommend dropping C++ from your list and learning C instead; and drop Java and learn Lisp instead
21:27:00 <pordan30> your list is missing a logic language
21:27:16 <pordan30> you're
21:27:27 <copumpkin> your
21:27:33 <levi> carter: I hope you didn't get the impression that I *like* C, or that I think it's a particularly good language.
21:27:34 <haasn> I would personally endorse a list like:
21:27:47 <pordan30> ugh...it's late
21:27:52 <indigo> FOSScookie: Try to learn a language from each language "family"
21:27:59 <carter> levi: :)
21:28:02 <carter> i dind't say that
21:28:03 <jrmithdobbs> and then add lua
21:28:04 <FOSScookie> These guys mention them:
21:28:05 <FOSScookie> https://www.youtube.com/watch?v=LR8fQiskYII
21:28:05 <FOSScookie> https://www.youtube.com/watch?v=NvWTnIoQZj4
21:28:06 <jrmithdobbs> because it's fun
21:28:17 <FOSScookie> Well, how about a list of 20 then.
21:28:25 <levi> Lua is indeed fun, and easy to learn.
21:28:47 <jrmithdobbs> and quite handy
21:28:48 <levi> It's like a sane Javascript.
21:29:00 <jrmithdobbs> i prefer "fast ruby" but same idea
21:29:03 <jrmithdobbs> ;p
21:29:11 <haasn> 1. ML-style language with strong static ADT-based type system, parametric polymorphism and ideally also purity. Good examples are Haskell, Agda or Idris; 2. Lisp-family language with metacirciular evaluation, equivalence of code and data, absence of a type system and homogeneous system. Good examples are Scheme and its various variants/implementations; 3. Block-based imperative language with control flow,
21:29:13 <haasn> pointers and array-based memory access. Good examples would be C, Go or any of billions of others of languages. 4. Logical programming language based on unification and constraint solving. Good examples are Prolog.. and uh.. Mercury, I guess? 5. Low-level machine assembly language. A good example is MIPS due to its relative simplicity
21:29:28 <bjz> FOSScookie: well bjarne *would* say C++, because he designed it
21:29:29 <haasn> You might also want to look into object oriented programming though it's not really that special. Smalltalk or JavaScript could be good examples for that
21:29:29 <bjz> :D
21:29:42 <haasn> Anyway, that's my personal “list” :)
21:29:54 <bjz> FOSScookie: personally I have learned far more about memory management from Rust than C
21:30:07 <jrmithdobbs> haasn: why not MIX
21:30:10 <johnw> I think C++ requires you to learn a *lot* of syntax and special cases, for little actual conceptual gain
21:30:31 <haasn> jrmithdobbs: haven't heard of it before, what's cool about it?
21:30:33 <jrmithdobbs> erm SMix w/e knuths is called
21:30:46 <johnw> it's MIX
21:30:48 <bjz> FOSScookie: C++ is interesting in terms of its zero-cost abstractive capabilities
21:30:49 <haasn> ah, I see; it's a simple “machine” language?
21:31:09 <bjz> FOSScookie: templates are fascinating
21:31:15 <jrmithdobbs> haasn: ya simpler than mips and best documented asm ever considering tehre's no phys impl
21:31:25 <haasn> jrmithdobbs: great to know about, thanks
21:31:26 <levi> bjz: Well, "zero-cost"... there's a little bit of implementation overhead and a lot of cognitive overhead, since all abstractions are leaky.
21:31:36 <bjz> levi: indeed
21:31:43 <haasn> bjz: I prefer classes and type families :)
21:31:44 <bjz> levi: I would not dispute that
21:32:08 <bjz> FOSScookie: if C++, this is a good set of lectures: https://www.youtube.com/playlist?list=PLHxtyCq_WDLXryyw91lahwdtpZsmo4BGD
21:32:17 <johnw> i might even argue that runtime costs are among the least interesting kinds of costs
21:32:23 <bjz> FOSScookie: by the guy who did the STL
21:32:25 <levi> I'd prefer D or Rust for doing things at the C++ level, though C++ is certainly far more widely used.
21:32:28 <jrmithdobbs> indeed
21:32:55 <bjz> levi: yeah, D is amazing when it comes to duck typed templates - much cleaner than C++
21:33:08 <bjz> levi: I stick with Rust though
21:33:19 <levi> johnw: Sometimes they're the least interesting, except in the few cases where they're not.
21:33:26 <johnw> levi: right :)
21:34:41 <levi> It's hard to argue with the guys who are writing game engine inner loops and can't afford gc pauses there, though I think a lot of them haven't looked well enough into the varieities of garbage collectors available.
21:35:03 <jrmithdobbs> i hate that argument
21:35:05 <bjz> FOSScookie: if you want to do a "tour models of computation" and explore how they relate to each other, then the Oz book is great
21:35:21 <haasn> levi: what about parallel gc?
21:35:24 <jrmithdobbs> most big name games run most of their logic through lua today already ;p
21:35:24 * hackagebot Boolean 0.2.1 - Generalized booleans and numbers  http://hackage.haskell.org/package/Boolean-0.2.1 (ConalElliott)
21:35:26 * hackagebot scientific 0.2.0.2 - Arbitrary-precision floating-point numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.2.0.2 (BryanOSullivan)
21:36:23 <levi> jrmithdobbs: I'm pretty sure lua isn't plugged into the inner loop of the rendering pipelines.
21:36:25 <bjz> FOSScookie: rather than learning a ton of different langs, it starts off with a small, pure functional kernal lang and gradually adds/removes things to demonstrate how that effects the semantics
21:36:26 <jrmithdobbs> there's like 2000 people in the world writing 3d rendering engines anyone will ever actually see, chances are you aren't one
21:36:44 <levi> Although lua does give you reasonable control over when gc runs.
21:38:17 <jrmithdobbs> so yes, the render pipeline probably needs to be something lower level that drives the rest of the app, but noone making that argument is ever the guy writing the former
21:38:22 <jrmithdobbs> levi: figured it was easier to finish my thought than respond, make sense now? ;p
21:38:58 <haasn> levi: I have never really looked closely at Rust; does it have ADTs / sum types judging by the presence of what seems to be pattern matching?
21:39:09 <bjz> haasn: correct
21:39:43 <bjz> haasn: its type system has its roots in the ML/Haskell tradition as opposed to Algol
21:39:45 <haasn> interesting; and it seems to be designed with safety in mind. I hope it replaces C!
21:39:55 <levi> FOSScookie: The book he's talking about is 'Concepts, Techniques, and Models of Computer Programming' and it's a really good one to read if you're trying to understand the basic underlying paradigms of computer languages.
21:40:07 <levi> jrmithdobbs: Yeah. :)
21:40:20 <bjz> haasn: I'm hoping they formalise the type system before 1.0, but I think they are working on that
21:40:30 <bjz> haasn: but yeah I use it a lot
21:40:40 <haasn> bjz: here's me hoping they get higher order types
21:40:43 <levi> haasn: It does, and it has a type-class mechanism as well.
21:40:49 <bjz> haasn: that is planned
21:40:54 <bjz> haasn: post 1.0 though
21:40:56 <haasn> bjz: awesome!
21:41:07 <haasn> bjz: so how long until they basically arrive at Haskell + syntax sugar? :)
21:41:14 <bjz> haasn: hah!
21:41:22 <levi> haasn: It's not likely to, it seems.
21:41:25 <haasn> oh, they'd need purity and nonstrictness for that. Come to think of it, they probably have neither
21:41:27 <bjz> haasn: believe me, lots of us wish for that
21:41:43 <levi> At the moment, it's actually more of a simplified and more principled C++.
21:41:51 <FOSScookie> Doesn't Elixir have syntax sugar and is functional?
21:41:54 <bjz> haasn: but we think the semantics are compelling enough that we endure it
21:42:09 <bjz> levi: the core semantics are simple, and principled
21:42:25 <haasn> bjz: certainly seems better than using an outdated language whose very existence is the reason basically all software is vulnerable
21:42:33 <jrmithdobbs> haasn: it almost has enough to implement generic functors/applicative/monads
21:42:34 <haasn> </opinions>
21:43:10 <bjz> haasn: indeed. Rust was created to research new ways to build concurrent browsers sefely
21:43:13 <bjz> *safely
21:43:16 <jrmithdobbs> haasn: missing higher order kinds and partial application (removed in favor of explicit lambda/closure use) ... it's surpsingly complete for something intended for what it is
21:43:39 <ricky_clarkson> haasn's opinions look like facts to me.
21:43:41 <levi> As far as I understand it, Rust's polymorphism is more akin to template instantiation than it is to parametric polymorphism in the ML family.
21:44:06 <bjz> levi: well, the way it inlines and monomorphises is like templates
21:44:25 <jrmithdobbs> levi: but that's an impl detail
21:44:29 <bjz> levi: but it is checked at the call site, like ML-style parametric polymorphism
21:44:48 <FOSScookie> Some one mentioned prolog. How would that be useful anyway?
21:44:49 <bjz> levi: https://gist.github.com/bjz/9220415
21:45:00 <jrmithdobbs> FOSScookie: it wouldn't
21:45:02 <bjz> FOSScookie: to get you to think differently
21:45:07 <jrmithdobbs> well other than that
21:45:20 <haasn> FOSScookie: to help you think backwards ;)
21:45:49 <levi> jrmithdobbs: I recall reading some threads where Haskell-oriented folks were asking about moving towards parametricty, and there was a lot of pushback against it.
21:45:51 <bjz> levi: my attempt to compare templates and rust's parametric polymorphism. didn't mention inlining though
21:45:54 <jrmithdobbs> FOSScookie: write some non-trivial things in sh too ... it's also quite fun
21:46:17 <haasn> (Does somebody know the link to that clojure video about taking the description of some reduction rule and using it to generate a set of possible programs that produce a certain answer?)
21:46:28 <Welkin> since I started learning haskell, other languages seem lacking
21:46:31 <haasn> (By simply plugging the logic solver in reverse)
21:46:41 <levi> Some things that were mentioned included some pervasive type-of operations that aren't mentioned in traits, etc.
21:47:15 <FOSScookie> So, basically I should change my view of computer science from HR stuff more to theory then?
21:47:23 <haasn> jrmithdobbs: “fun” :)
21:47:23 <FOSScookie> And changing how I think?
21:47:23 <levi> It seems that a lot of the code relies on monomorphizing things, in other words.
21:47:36 <haasn> FOSScookie: if you want to be a computer scientist, yes
21:47:37 <jrmithdobbs> haasn: not facetious at all, sh gets a bad rap
21:47:37 <Welkin> HR?
21:47:52 <FOSScookie> Welkin: Human Resources
21:47:58 <haasn> science is about questioning the way we think
21:48:12 <Welkin> philosophy is as well
21:48:13 <jrmithdobbs> FOSScookie: i don't know what other answer you expected out of #haskell really
21:48:15 <jrmithdobbs> heh
21:48:19 <levi> Welkin: All languages are lacking. :)
21:48:27 <carter> bjz: i think its totally possible to work out adding support for rust style semantics as a haskell sublanguage thtingy
21:48:28 <carter> *thingy
21:48:29 <haasn> levi: except lisp
21:48:38 <carter> me
21:48:40 <carter> *mebe
21:48:42 <levi> lisp too :P
21:49:06 <haasn> carter: which semantics in particular?
21:49:16 <carter> well
21:49:18 <haasn> carter: doesn't stuff like MonadSafe basically give you safe resource access and stuff? or what are you thinking about?
21:49:27 <jrmithdobbs> carter: including the ABI bits? because that's one of the coolest features
21:49:44 <carter> jrmithdobbs: maybeee
21:49:48 <carter> haasn: jrmithdobbs
21:49:50 <carter> first
21:49:51 <jrmithdobbs> there's several things about rust that are quite nifty ;p
21:50:11 <carter> phase 0:  work out "{-# LANGUAGE Strict #-}"
21:50:25 <Welkin> I was amused to find that my favorite parts of python (list comprehensions, generators, first-class functions) are a fundamental component of haskell
21:50:35 <Welkin> partial application is just the coolest thing ever
21:50:41 <carter> then a lot of those follow on questions become tractable
21:50:48 <jrmithdobbs> Welkin: python has partial application too
21:50:49 <carter> theres definitely a receptivity to figuring out Strict Haskell
21:50:58 <Welkin> I know, with closures/decorators
21:51:00 <jrmithdobbs> Welkin: all you need for partial application are lambdas and closures
21:51:07 <FOSScookie> Is this sufficient then:
21:51:07 <haasn> Welkin: if only it was the same in reverse :(
21:51:07 <FOSScookie> C++ Java Python Haskell Prolog
21:51:31 <jrmithdobbs> why c++ *and* java?
21:51:42 <jrmithdobbs> there's not much value to learn from one you don't from the other
21:51:44 <Welkin> I avoid c++ and java
21:51:48 <haasn> I would remove C++ and Java personally!
21:52:02 <levi> FOSScookie: Lose C++, add Racket/Scheme.
21:52:02 <jrmithdobbs> and c is more useful than c++ if you're going for practicality
21:52:06 <haasn> python already captures block-based programming, imperative semantics, control flow etc.
21:52:06 <Welkin> functional style is so much more elegant
21:52:28 <haasn> I would include esolangs ;)
21:52:44 <johnw> C++ just isn't worth the expenditure to learn it well, unless you are being paid to know it
21:52:46 <heatsink> Unlambda is so much more elegant than brainfuck.
21:52:49 <jrmithdobbs> c99, lua, rust, haskell, erlang
21:52:50 <jrmithdobbs> go
21:52:56 <jrmithdobbs> go as in start, do not use golang
21:52:56 <levi> C++ is a huge and complex language and you only really need to learn it if someone's paying you to do it.
21:53:36 <pordan30> i don't know whether prolog is particularly useful, but it's certainly enlightening. it's a relatively small language build around backtracking, structured data, and pattern matching. because of its unique computational model, its easy to write programs that solve problems involving relations between and properties of collections of structured data.
21:53:45 <Welkin> I heard a lot of praise for Go so I checked it out
21:53:49 <Welkin> it was disappointing
21:53:56 <Welkin> and surprisingly clumsy
21:55:03 <levi> My picks: Scheme (pick up miniKanren there for a taste of logic programming instead of Prolog), Haskell, Rust, Java (for practicality's sake; otherwise Smalltalk)
21:55:48 <haasn> heatsink: unlambda considered harmful
21:55:54 <haasn> heatsink: recommend using lazy-k instead
21:56:30 <dfeuer> jrmithdobbs, I think the best reason to learn C++ is probably so that when you're working with just about any other language, you're grateful that it's not C++.
21:56:37 <levi> Also, work through 'Software Foundations' to learn Coq along with some of the mathematics underlying programming language theory.  And because playing with automated proof assistants can be fun!
21:56:40 <haasn> dfeuer: then you should pick up PHP
21:56:46 <jrmithdobbs> levi: i dunno, you don't have to stoop to java for practicality
21:56:55 <Welkin> haha
21:57:07 <haasn> levi: that sounds interesting, thanks for the idea
21:57:23 <jrmithdobbs> levi: i meant that less badly than it came out ... but there's lots of ruby/python/c/objc about
21:57:24 <Welkin> python is very practical without the clumsiness and restrictions of java
21:57:27 <jrmithdobbs> as far as work
21:57:33 <levi> jrmithdobbs: It's both simpler and safer than C++, and there are about a billion jobs available. It's also currently the 'canonical' object oriented language, for better or worse.
21:58:31 <levi> Even if you hate Java, it's good to know it reasonably well.
21:58:46 <dfeuer> jrmithdobbs, I've heard rather bad things about PHP, but at least it doesn't have a type system that's *both* undecidable and *also* fairly close to worthless.
21:58:52 <bjz_> FOSScookie: Rust, Haskell, Prolog, Erlang, Factor
21:59:07 <dfeuer> Sorry, I meant to say haasn.
21:59:11 <bjz_> FOSScookie: that should get your brain in knots
21:59:18 <haasn> dfeuer: on the other hand, it has a standard library that's undecisive and equally close to worthless :)
21:59:24 <jrmithdobbs> dfeuer: don't insult c++ like that, php really is worse than everyone says
21:59:42 <bjz_> FOSScookie: but everyone will say different things
22:00:06 <levi> C also has a standard library that's close to worthless and a type system of similar quality. :P
22:00:07 <haasn> function is insecure? introduce a new function with the correct behavior, keep the old one in there for backwards compatibility ;)
22:00:38 <jrmithdobbs> levi: at least C doesn't pretend otherwise re: it's type system though, and if you cast it it's your own damned fault ;p
22:01:08 <FOSScookie> Couldn't I just use this for logic: https://github.com/logpy/logpy
22:01:19 <jrmithdobbs> that's the part about c++ that always infuriated me, it seems like the type system should be useful and it's ... not
22:01:47 <levi> Well, it inherited that "quality" from C.
22:02:30 <levi> C++ is actually a bit pickier about types than plain C.
22:02:47 <jrmithdobbs> in unexpected ways when you already know c
22:03:09 <levi> void * in C is compatible with any pointer; in C++ you must cast it explicitly.
22:03:35 <dfeuer> My biggest gripe about Java's type system is that Generics were introduced without any change to the JVM, which forced the system into rather strong erasure properties, which produced counter-intuitive and highly annoying restrictions on what you can do.
22:03:38 <jrmithdobbs> levi: thought that changes with c99?
22:04:39 <levi> C++ also has a story for resource management. C punts it off to libraries.
22:04:56 <geekosaur> C punts everything to libraries
22:05:02 <geekosaur> it doesn't really have a choice in the matter
22:05:05 <jrmithdobbs> at least it's consistent
22:05:15 <dfeuer> levi, C++'s resource management is pretty much no better than C's once you get down to actually using it...
22:05:24 <jrmithdobbs> also that
22:05:47 <jrmithdobbs> c++ is the wrong turn everyone has been trying to overcorrect from for 20 years
22:06:13 <levi> dfeuer: No, I think 'new' and constructors/destructors offer a distinct advantage over malloc/free.
22:06:15 <heatsink> C++ has a history of inventing ways to do things, then using them for completely unrelated things.
22:06:26 <FOSScookie> Could I add basic? Instead of C? (Yes, I said BASIC please don't hurt me.)
22:06:34 <levi> FOSScookie: No. :)
22:06:35 <heatsink> Like using object finalization for safe exception handling
22:06:42 <jrmithdobbs> FOSScookie: no
22:06:50 <dfeuer> I wouldn't go quite that far. I suspect most language designers with any common sense have avoided paying any attention to C++ for fear of brain injury.
22:06:53 <haasn> FOSScookie: only if it's a haskell EDSL ;)
22:07:00 <jrmithdobbs> FOSScookie: sh is a better language than basic
22:07:05 <haasn> http://augustss.blogspot.de/2009/02/more-basic-not-that-anybody-should-care.html
22:07:32 <nisstyre> heatsink: C++ programmers are very creative
22:07:46 <dfeuer> When I mucked around with Perl years ago, its horribly inconsistent syntax reminded me very much of BASIC.
22:07:50 <jrmithdobbs> creative about mundane things that noone else has to think about
22:07:51 <jrmithdobbs> heh
22:07:58 <haasn> nisstyre: haskell programmers get quite creative when we meet our type system's limits ;)
22:07:59 <FOSScookie> Is this list looking better:
22:07:59 <FOSScookie> C Python Haskell Prolog
22:08:15 <nisstyre> what is that a list of?
22:08:18 <Hafydd> It would look better if it didn't have C or Python.
22:08:31 <johnw> FOSScookie: I'd call that a decent list
22:08:33 <FOSScookie> What is wrong with you people! ;)
22:08:33 <heatsink> I think it's good to have C in the list
22:08:36 <dfeuer> heatsink, I was about to say something like what haasn said.... if you want to see functional language abuse, just look for anything by Oleg Kiselyov.
22:08:38 <johnw> it's sad it's missing Lisp
22:08:42 <Welkin> FOSScookie, what is this list for?
22:08:44 <haasn> nisstyre: list of languages FOSScookie wants to learn to gain a broad understanding of paradigms
22:08:45 <jrmithdobbs> FOSScookie: you really need a lisp-like on there
22:08:48 <johnw> I'd say: C Lisp Haskell Prolog
22:09:00 <Welkin> oh
22:09:00 <nisstyre> I'd recommend looking at Kanren over Prolog
22:09:05 <nisstyre> then you can learn Scheme in parallel
22:09:06 <jrmithdobbs> i think that's actually a pretty decent list
22:09:12 <Hafydd> I don't think Python will really give you a good understanding of any paradigm.
22:09:21 <FOSScookie> nisstyre: https://github.com/logpy/logpy What about this?
22:09:29 <jrmithdobbs> a neutered version of several and a complete version of none
22:09:42 <haasn> Hafydd: if it's the first and only imperative language you ever see? :)
22:09:48 <johnw> FOSScookie: better: C Smalltalk Haskell Lisp Prolog
22:09:51 <nisstyre> FOSScookie: at a glance that looks pretty simplistic
22:09:54 <jrmithdobbs> actually i'll take that back, twisted is a great reactor impl
22:09:57 <FOSScookie> Hafydd: For practicality, so I can write useful stuff and interact with databases.
22:09:59 <haasn> might contradict with “good” I guess
22:10:03 <johnw> because without Python, you'd have no OO langauges
22:10:12 <nisstyre> FOSScookie: seems to cite Kanren though
22:10:18 <Hafydd> Maybe.
22:10:32 <nisstyre> but it kinda defeats the purpose if you use it in anything other than a lisp
22:10:36 <jrmithdobbs> johnw: that's why i'd thrown lua in earlier ;p
22:10:38 <johnw> FOSScookie: you could learn Objective-C too
22:10:40 <dfeuer> I don't think C is terribly good for the brain.  If you want an imperative language, why not try something like Forth?
22:10:44 <johnw> instead of C+Python
22:10:45 <jrmithdobbs> oo in lua is refreshing
22:10:46 <FOSScookie> nisstyre: So it is sufficient?
22:11:09 <dfeuer> Or Scheme, for that matter.
22:11:10 <jrmithdobbs> forth is months and months of fun ;p
22:11:14 <Welkin> I chose Scheme as my Lisp dialect
22:11:19 <nisstyre> dfeuer: I find C rather elegant personally, yeah it's not type safe, however it is at least possible to reason about the execution of your code
22:11:27 <nisstyre> modulo undefined behaviour
22:11:47 <levi> I just checked re: type compatibility of void * in C vs C++ changing in C99; it did not.  C and C++ are still different in this respect.
22:11:48 <haasn> jrmithdobbs: fun months forth is
22:11:48 <nisstyre> FOSScookie: sufficient for what?
22:12:00 <FOSScookie> nisstyre: Logic. I can remove prolog then.
22:12:08 <nisstyre> FOSScookie: yes
22:12:14 <dfeuer> nisstyre, it's a lot harder to reason about the execution of C code than about the execution of code in a stack-based language, or even a strict mostly-functional language like SML or Scheme.
22:12:18 <Welkin> it was a choice between Clojure or Scheme
22:12:28 <nisstyre> FOSScookie: probably implementing your own logic language is best
22:12:37 <jrmithdobbs> Welkin: why wasn't CL a choice?
22:12:41 <pordan30> so kanren has first-class predicates and purely logical semantics?
22:12:53 <nisstyre> dfeuer: I didn't claim it was easier
22:12:54 <dfeuer> Maybe because CL is a HUGE language?
22:12:57 <pordan30> 'the art of prolog
22:12:58 <carter> Welkin: yeah, dr racket is awesome
22:13:19 <dfeuer> And Scheme has syntax-case macros.
22:13:36 <levi> Racket is awesome, full-stop.
22:13:41 <nisstyre> anyway, Scheme is my favourite language
22:13:53 <nisstyre> but Racket is useful if you want to get anything done
22:14:08 <dfeuer> Racket pattern matching is not nearly as nice as Haskell or SML pattern matching.
22:14:16 <nisstyre> dfeuer: I would say it's better
22:14:16 <levi> Some other Schemes are awesome too; but Racket is Scheme plus a bunch of other useful stuff.
22:14:19 <nisstyre> it can do more
22:14:20 <pordan30> 'the art of prolog' book by sterling and shapiro is a great introduction to logic programming, if you go down that route (it also covers the execution model and semantics: resolution, unification, herbrand models, etc...)
22:14:34 <nisstyre> Racket patterns can actually search data structures
22:14:43 <nisstyre> and you can throw in arbitrary predicates
22:14:45 <Welkin> jrmithdobbs, I wanted a lisp-1 variant, not lisp-2
22:14:51 <FOSScookie> Clojure or Scheme? (for lisp)
22:15:14 <nisstyre> levi: Racket is more like a collection of languages
22:15:22 <dfeuer> nisstyre, I think you can do a good bit of that with GHC extensions, but I seem to recall Racket patterns being a bit on the verbose side.
22:15:29 <jrmithdobbs> racket looks nifty
22:15:35 <nisstyre> dfeuer: no more verbose than Racket itself
22:15:38 <levi> nisstyre: Yeah, I'm well aware of what it is. :)
22:16:23 <nisstyre> dfeuer: I think view patterns work for some of that but I don't think we've unified say, lenses and pattern matching yet
22:16:24 <nisstyre> have we?
22:16:36 <levi> nisstyre: Matthew Flatt attends our local functional programming meetup, along with some other local Racketeers, and they've given some cool presentations on it.
22:16:54 <haasn> nisstyre: fsvo “unified”, perhaps
22:17:00 <levi> Will Byrd was there last time, too.
22:17:05 <nisstyre> haasn: yeah fair enough
22:17:19 <haasn> nisstyre: prisms give you a projection to Maybe a, which you can then pattern match on fairly trivially. Combine it with view patterns!
22:17:22 <haasn> Combine that with pattern synonyms!
22:17:29 <haasn> wait, can you mix pattern synonyms and viewpatterns?
22:17:32 * haasn tries it
22:18:13 <jrmithdobbs> damn you whoever mentioned racket, i don't have time to play with this
22:18:23 <FOSScookie> Would clojure be acceptable for lisp?
22:18:34 <jrmithdobbs> it involves the jvm, so no imho
22:18:53 <levi> FOSScookie: If you really want to learn it, no one is going to stop you!
22:18:57 <FOSScookie> jrmithdobbs: What is wrong with the jvm?
22:19:03 <jrmithdobbs> what isn't?
22:19:10 <FOSScookie> :)
22:19:32 <haasn> nisstyre: IT WORKS!
22:19:57 <nisstyre> haasn: come up with some cool examples
22:20:11 <levi> FOSScookie: I would recommend Racket over Clojure, most definitely, but Clojure currently has a very nice community.
22:20:59 <haasn> nisstyre: pattern (xs :> x) <- (reverse -> x:xs)
22:21:05 <carter> racket is amaing
22:21:05 <carter> *amzing
22:21:05 <carter> i realize people like clojure
22:21:07 <haasn> matches against a list, backwards ;)
22:21:10 <carter> but racket is amazing
22:21:11 <carter> use it
22:21:41 <FOSScookie> Here we go again: C Python Haskell Racket
22:21:41 <FOSScookie> Prolog is now gone in favor of logpy with python.
22:22:00 <FOSScookie> Better?
22:22:01 <haasn> FOSScookie: who are you trying to please, incidentally? :P
22:22:04 <levi> FOSScookie: No no. Forget logpy. Use miniKanren with Racket.
22:22:19 <FOSScookie> Okay.
22:22:20 <nisstyre> that's what I suggested
22:22:31 <nisstyre> and get the book as well (The Reasoned Schemer)
22:22:42 <nisstyre> and probably Little and Seasoned as well
22:22:45 <nisstyre> since you're new to Scheme
22:23:03 <haasn> nisstyre: pattern SomePrism a <- preview _SomePrims -> Just a
22:23:14 <Welkin> what about SICP for scheme?
22:23:15 <haasn> nisstyre: pattern SomePrism a b c <- preview _SomePrism -> Just (a,b,c)
22:23:36 <nisstyre> Welkin: yeah, might as well look at it
22:24:06 <levi> Welkin: SICP is an excellent book, and it does use Scheme, but it is not really *about* Scheme.
22:24:14 <jrmithdobbs> and now that you've got rid of logpy, ditch python for erlang or lua
22:24:29 <FOSScookie> I'll add just one more, five is enough. Now taking suggestions (as I brace myself for what is to come)
22:24:39 <jrmithdobbs> lua keeps the OO stuff in a very elegant way if that's what you were after with python
22:24:53 <jrmithdobbs> and erlang is erlang ;p
22:25:30 * hackagebot Win32 2.3.0.2 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.3.0.2 (BryanOSullivan)
22:26:00 <levi> Honestly, for pedagogical purposes, you don't need much outside of Racket.
22:26:42 <haasn> there's a niggling suspicion in the back of my head that tells me overuse pattern synonyms are going to make libraries nigh incomprehensible
22:26:42 <levi> Or Oz, perhaps, but at least there are non-pedagogical purposes for Racket. :)
22:26:46 <haasn> I vote we abuse the hell out of them
22:27:09 <jrmithdobbs> FOSScookie: tbqh, the trick is to pick a handful of different languages and somehow figure out how to learn them without getting bogged in the differences between build/etc systems, good luck with that part as it's a good 6 months by itself with a list like that ;p
22:28:09 <FOSScookie> Maybe java for practical stuff.
22:28:33 <levi> FOSScookie: The alternative to the laundry list of languages is to pick up 'Concepts, Techniques and Models of Computer Programming' and just read that; then you'll be able to spot the underlying concepts in any language you care to learn.
22:29:00 <FOSScookie> levi: I will do that.
22:29:25 <haasn> levi: and maybe pick up something like Oz? :)
22:29:36 <levi> haasn: Well, Oz is used by the book.
22:29:38 <jrmithdobbs> best intro to lisp text *ever*
22:29:40 <jrmithdobbs> http://docs.racket-lang.org/quick/index.html
22:29:48 <jrmithdobbs> (not facetious)
22:29:49 <haasn> levi: ah :)
22:30:02 <Welkin> most people start with whatever their school teaches
22:30:20 <Welkin> or whatever is easily available (unfortunately, php)
22:31:08 <dfeuer> levi, Racket is not what I'd choose for learning about static typing, although there is a sublanguage that has some.
22:31:32 <jrmithdobbs> is php->anything really worse than basic->c when it comes down to it? heh
22:31:58 <haasn> I started with QBASIC and quickly moved on to GML and PHP.
22:32:04 <haasn> I do not recommend that path.
22:32:07 <levi> dfeuer: Well, Typed Racket might not be the *best* example to learn static typing from, but I think it might be sufficient to start with it.
22:32:18 <jrmithdobbs> FOSScookie: tbqh, all of the above is pretty irrelevent, use what people you know use it will work out best this way
22:32:34 <levi> haasn: Dijkstra does not approve!
22:33:05 <jrmithdobbs> i had to move away from austin before i started agreeing with that guy so damned much ;p
22:33:50 <Welkin> haha
22:34:06 <nisstyre> TR is good but no global inference, which is okay but might be confusing if you've come from an ML derivative
22:34:59 <Welkin> I think that assembly is important to understand how the computer processes your data
22:35:32 <nisstyre> Welkin: I agree
22:36:05 <nisstyre> everyone should at least understand basic things like registers, memory, pointers, jump tables, and branches
22:36:55 <Welkin> and the most fun part: no-ops!
22:37:06 <nisstyre> yeah
22:37:17 <Welkin> generating no-ops in C is just an empty for/while loop
22:37:24 <Welkin> so, not as fun
22:37:33 <FOSScookie> Welkin: Was that thing about assembly for my benefit?
22:37:39 <Welkin> yes
22:37:49 <Welkin> assembly is very simple and concrete
22:37:53 <Welkin> abstractions are minimal
22:38:23 <jrmithdobbs> do not try and learn x86 (especially modern x86_64) asm as a first go, though, for the love of god
22:38:36 <Welkin> I learned Motorola Freescale ASM
22:38:38 <nisstyre> find a nice emulator or something
22:38:45 <Welkin> learn asm on a microcontroller
22:38:53 <nisstyre> or an old computer
22:38:54 <jrmithdobbs> ya arduinos are cheap
22:39:12 <levi> IIRC, Freescale is basically 68k ASM, right?
22:40:10 <levi> It's a reasonble ASM to hand-code. Some modern RISC architectures are a bit of a headache, though for entirely different reasons than x86.
22:41:29 <levi> There are materials online for a 'NAND to Tetris' course that would be a good complement to studying high-level languages.
22:42:25 <levi> There are any number of reasonable routes through the levels of computing systems; whichever you take, keep in mind that the one you took is not the only one. :)
22:42:51 <nisstyre> levi: I've heard great things about that book
22:43:03 <nisstyre> coding that in something like QEMU would be fun
22:43:12 <newtohaskell> haasn: So I managed to clean that up a fair bit: http://lpaste.net/101004
22:43:12 <Welkin> I used this one: https://en.wikipedia.org/wiki/Freescale_68HC12#HCS12/MC9S12_derivatives
22:43:42 <FOSScookie> levi: You said earlier that Racket was all that was needed for pedagogical purposes. Could Racket serve as a replacement for Haskell then?
22:43:56 * haasn .oO( “NAND to TypeFamilies: Implementing a hardware Haskell interpreter from first principles” )
22:44:02 <nisstyre> :D
22:45:53 <haasn> newtohaskell: that doesn't look correct to me; S.fromList l will insert the entire list in that position, including ones of other “Kind”s
22:46:00 <haasn> newtohaskell: S.singleton x should do the trick, though
22:46:14 <haasn> newtohaskell: anyway, I much prefer the list comprehension I gave earlier :)
22:46:33 <newtohaskell> Ah, you're right. Fixed that
22:46:56 <mniip> :o someone has to come up with a functional cpu
22:47:02 <levi> FOSScookie: Not as a replacement for Haskell, but you could learn about static typing, functional programming, and lazy evaluation in isolation or in different combinations as they have in Haskell in Racket.
22:47:04 <mniip> With lazy assembly
22:47:08 <dmj`> i wrote the jack compiler for nand to tetris in haskell using parsec, first haskell project ever, code was pretty bad
22:47:08 <haasn> mniip: http://thorn.ws/reduceron/Reduceron/Practical_Reduceron.html
22:47:24 <haasn> dmj`: please don't remind me of my first haskell projects ;)
22:47:34 <haasn> newtohaskell: food for thought:
22:47:35 <enthropy> does anybody here use the units package?
22:47:42 <haasn> enthropy: which one?
22:47:45 <jrmithdobbs> mniip: we call them gpus
22:47:46 <dmj`> haasn: haha try writing a compiler w/o a state monad ;)
22:47:47 <enthropy> @hackage units
22:47:47 <lambdabot> http://hackage.haskell.org/package/units
22:48:06 <haasn> enthropy: oh. No, but I use my “units” which is quite similar to it ;)
22:48:09 <mniip> jrmithdobbs, that's different
22:48:13 <enthropy> seems to be a fad to use really common names for things
22:48:15 <jrmithdobbs> mniip: kinda not ;p
22:48:36 <enthropy> haasn: where is that one?
22:48:53 <levi> My first haskell project was a compiler, too. Also full of not-so-great code, but I did figure out enough to re-implement half of Parsec (couldn't use any supplied libraries for parsing :P )
22:49:12 <dmj`> haasn: is nand to type families a real thing?
22:49:14 <haasn> newtohaskell: classify :: ClientKind -> [Client a] -> Set (Client a); classify k = S.fromList . filter (\x -> getKind x == k)
22:49:20 <haasn> dmj`: sadly not :(
22:49:21 <rusk101> hey guys can anybody give me an example on using unfoldr function to break up an integer into a list of integers size x?. for example subLists 2 12345678 = [12,34,56,78]?
22:49:29 <haasn> enthropy: https://github.com/haasn/units
22:49:32 <enthropy> seems to be I can't really build up a constraint that says a+b=c using the things in there
22:50:38 <enthropy> such a thing was already done with dimensional, and very straightforward to do with dimensional-tf
22:52:09 <levi> rusk101: Well, first you are going to have to think about the steps involved. If you think about how you've phrased the problem, you'll see some issues with it.
22:52:15 <FOSScookie> Thanks guys, I have a lot to consider. :)
22:52:46 <haasn> enthropy: dimensional unfortunately is fairly limited iirc
22:52:48 <levi> FOSScookie: Learn stuff. have fun. Come back if you have Haskell questions!
22:52:51 <rusk101> levi: can you just give me an example of a line using unfoldr?
22:52:56 <haasn> enthropy: SI-centric and also using really ugly TC hacks
22:53:03 <enthropy> well the funny thing is that type inference is better with that one
22:53:03 <haasn> enthropy: I'm not sure what exactly you're trying to achieve, though
22:53:07 <newtohaskell> haasn: Yeah, that's the second implementation the exercise calls for
22:53:09 <rusk101> :t unfoldr
22:53:10 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:53:13 <levi> rusk101: What do you mean by "a line using unfoldr"?
22:53:16 <newtohaskell> I came to a similar conclusion
22:53:21 <rusk101> just something that works
22:53:35 <haasn> > unfoldr (const Nothing) ()
22:53:37 <lambdabot>  []
22:54:43 <haasn> enthropy: you mean you want to write a polymorphic function that has some parameters a, b, c and uses these in ways that requrie a+b = c ?
22:55:16 <rusk101> haasn: thanks but that doesnt help me at all.
22:55:23 <levi> The idea behind unfoldr is to generate a list from some starting point.
22:55:33 <haasn> enthropy: with my units, you should just be able to write: f :: (a+b ~ c) => t :@ a -> t :@ b -> t :@ c -> ...
22:55:39 <enthropy> I mean that when you actually work with units there are cases where you have  let c = a*b, and the type of a is unknown
22:56:33 <haasn> enthropy: but I would probably write that as f :: t :@ a -> t :@ b -> t :@ a+b -> ...
22:56:37 <haasn> (I think that should work, at any rate)
22:56:44 <dmj`> > map read (chunksOf 2 (show 12345678)) :: [Int]
22:56:45 <lambdabot>  [12,34,56,78]
22:56:54 <dmj`> Data.List.Split
22:56:59 <haasn> enthropy: yeah I don't think my library will complain about that
22:57:03 <mniip> well that's cheating
22:57:07 <dmj`> :)
22:57:09 <enthropy> you allow user-defined units?
22:57:21 <levi> The first argument is the generating function and the second argument is the starting point.  The function is called repeatedly, and for each Just (a, b) response the a is collected in the output while the b serves as the next input to the generator.
22:57:21 <haasn> enthropy: it should infer as something like :: forall a. t :@ a -> t :@ a*B where B is some known type
22:57:22 <rusk101> that is cheating lol
22:57:23 <mniip> Besides only works for powers of 10
22:57:33 <dmj`> rusk101: why?
22:57:41 <haasn> enthropy: yes, all the built in units are “user-defined”, see https://github.com/haasn/units/blob/master/src/Units/SI.hs
22:57:53 <enthropy> https://github.com/aavogt/DimMat/blob/units/DimMat/Internal.hs#L420 fails sometimes
22:57:56 <rusk101> because Im a begginer and dont want to cheat
22:58:18 <enthropy> probably because there is a Normalize and Reorder involved in the @~ and @+ and @-
22:58:43 <haasn> enthropy: what is @~, actually?
22:58:55 <enthropy> it is from Eisenberg's units package
22:59:11 <levi> rusk101: Is there some reason why you want to do it via unfoldr?  You don't seem to have a strategy in mind aside from "use unfoldr"
22:59:32 <haasn> enthropy: aha
22:59:34 <enthropy>  a @~ b says that the units of 'a' are equal to the units of 'b'
22:59:39 <haasn>   a @~ b = (Normalize (Reorder a b) ~ Normalize b)
22:59:46 <enthropy> exactly
22:59:49 <mniip> rusk101, you just have to write a lambda which returns Nothing when there are no more digits, and Just (listelement, nextvalue) if there is
23:00:01 <haasn> enthropy: this is a major deviation from the way I do things in my library
23:00:04 <mniip> But you should've read that from docs of unfoldt
23:00:08 <mniip> unfoldr
23:00:16 <levi> rusk101: dmj's solution doesn't strike me as 'cheating', but that may be because you haven't explained your specifications very precisely yet.
23:00:21 <haasn> enthropy: in my library, there is only one possible form any unit can have, so I use regular old ~
23:00:25 <haasn> enthropy: and GHC can work with ~ very well
23:00:36 <haasn> forwards, backwards, left to right, transitively, etc.
23:00:45 <enthropy> so currently things get stuck with ambiguous types y0 like Data.Dimensions.DimSpec.Reorder y0 '['Data.Dimensions.DimSpec.D Second ('P ('P ('P 'Zero)))]
23:01:12 <haasn> enthropy: I'd be curious to see how well it fares. I haven't put it through *heavy* benchmarking though I do use it for personal calculations
23:02:03 <rusk101_> plus, I dont have Data.List.Split
23:02:17 <levi> rusk101: The big question, based on how you explained your problem, is "What does the operation 'size of x' mean for a number?" If you can explain that precisely, you will be well on your way to a solution.
23:02:22 <dmj`> it's in the latest haskell platform I think
23:02:34 <rusk101_> oh ok
23:02:38 <rusk101_> thx
23:03:04 <levi> Are you really performing a numeric operation?
23:03:15 <rusk101_> no
23:03:33 <rusk101_> Im just taking x elements of a number
23:03:37 <levi> So, what kind of data are you performing an operation on?
23:03:40 <rusk101_> first x elements and so on
23:03:45 <rusk101_> Integer
23:03:59 <haasn> Integer doesn't have a concept of “elements”
23:03:59 <mniip> rusk101_, what's an "element" of a number
23:04:14 <levi> If you're performing an operation on an Integer, it is by definition a numeric operation; you correctly said you aren't performing a numeric operation though!
23:04:16 <MrRacoon> rusk101_: from the beggining?
23:04:21 <rusk101_> digit0, digit1, digit2, ...
23:04:37 <mniip> Digits. Not elements
23:04:57 <haasn> rusk101_: base 10 digits?
23:05:00 <jrmithdobbs> that sounds like a string representation of an integer, not an integer
23:05:20 <haasn> it sounds like a base 10 representation, anyway
23:05:21 <rusk101_> oh, you are right
23:05:24 <rusk101_> right
23:05:36 <haasn> rusk101_: so first you need to get from an Integer to a base 10 representation of an Integer
23:05:45 <rusk101_> divide by 10 get remainder, put it in tail, repeat?
23:05:46 <MrRacoon> rusk101_: like 'x `mod`10' for the last number, and 'x `div` 10' for the init
23:05:50 <haasn> rusk101_: “show” :)
23:05:59 <dmj`> haasn: that's what I say :)
23:06:01 <haasn> > show 123456789
23:06:03 <lambdabot>  "123456789"
23:06:06 <enthropy> haasn: thanks, I'll have a go at it tomorrow maybe
23:06:07 <haasn> > take 2 $ show 123456789
23:06:08 <lambdabot>  "12"
23:06:23 <haasn> enthropy: awesome, leave me any feedback you come up with :) but be wary, it's probably not *very* user friendly
23:06:37 <levi> rusk101_: I'm not sure if you saw, but I suggested that dmj''s solution wasn't actually cheating; hopefully you understand what I meant now.
23:06:38 <mniip> easiest will be, show . (map (:[])) . (map read)
23:06:42 <rusk101_> show 125412
23:06:43 <MrRacoon> > (x `div` 10, x `mod` 10)
23:06:45 <lambdabot>  (x `div` 10,x `mod` 10)
23:06:50 <MrRacoon> derp
23:06:55 <MrRacoon> > (123 `div` 10, 123 `mod` 10)
23:06:57 <lambdabot>  (12,3)
23:07:00 <haasn> enthropy: it was actually written for a programming competition so I tried to make it as pretty and flashy as possible to the end-user..
23:07:09 <enthropy> it should be no worse than the other ones
23:07:13 <haasn> good point :)
23:07:58 <levi> I love the monkey-face function: (:[])
23:08:23 <MrRacoon> levi: awe man... I'll never be able to unsee it now..
23:08:45 <haasn> MrRacoon: pure
23:08:49 <haasn> (problem solved)
23:09:22 <Ayadew> MrRacoon also SQL sadface );
23:09:39 <MrRacoon> lol
23:09:46 <haasn> rusk101_: oh, but feel free to implement it using divide by 10/100 semantics as an exercise!
23:10:33 <Ayadew> SQL self-reinforces itself as a perpetual state of depression
23:10:34 <MrRacoon> my prof loves this route ^
23:10:54 <haasn> enthropy: be wary of type errors, they like to blow up beyond proportion and become nigh incomprehensible. I implemented strings from scratch
23:11:20 <enthropy> this is before Symbol?
23:11:24 <rusk101_> I still dont get how you can use map (take 2 $) 12345
23:11:46 <haasn> enthropy: no, but before Symbol can do anything other than look pretty
23:11:53 <haasn> enthropy: to be more precise: I can't “sort” a list of symbols
23:11:54 <dmj`> rusk101_: what is the type of take?
23:12:13 <rusk101_> ok. map (take 2 $) [1234455]
23:12:17 <enthropy> I think you still cannot sort symbols
23:12:18 <rusk101_> using show 1234455
23:12:23 <haasn> enthropy: basically I'd need a kind-level “Ord Symbol” constraint to keep my things in unique representations
23:12:37 <haasn> enthropy: very likely, yes :( I haven't seen anything related to string pattern matching / comparison either
23:13:40 <haasn> enthropy: otherwise the library would be a lot prettier and more efficient! I hand-rolled a Char that covers the alphabet and that's about it...  I tried switching to type-level peano nats that represent Unicode but that turned out hilariously slow beyond belief
23:14:07 <haasn> maybe this would work again with 7.9's Nats? back in 7.7 when it was written they were about as useless as Symbol
23:14:18 <Iceland_jack> rusk101_: What are you trying to do?
23:14:44 <haasn> should work, actually; we can't inductively pattern match I think but we sure as hell can compute (a::Nat) + (b::Nat)
23:14:53 <haasn> and (a::Nat) <=? (b::Nat)
23:15:13 <haasn> enthropy: if the library ends up working for you I may update it for that :)
23:15:48 <dmj`> Iceland_jack: given 12345678, produce [12,34,56,78] using unfoldr
23:16:00 <rusk101_> Iceland_Jack: break apart an integer into a list of subNumbers likes str2Integer 2 [123124125] = [12,31,24,12,5]
23:16:25 <rusk101_> I dont want to use unfoldr because I am unfamiliar with it
23:16:46 <pordan30> rusk101_: do you have to use unfoldr? mapAccumL might be a better fit
23:16:48 <rusk101_> but if theres no other way then I guess thats how it must be done
23:17:55 <pordan30> > mapAccumL (\n p -> (n `mod` 10^p, n `div` 10^p)) 654321 [5,4,3,2,1,0]
23:17:56 <lambdabot>  (0,[6,5,4,3,2,1])
23:18:17 <rusk101_> sorry guys. Im just frustrated. I know I have to do this on my own. But ive spent about 2 hours trying to do this.
23:18:26 <Iceland_jack> > reverse $ unfoldr (\n -> if n == 0 then Nothing else Just (swap (quotRem n 100))) 12345678
23:18:27 <lambdabot>  [12,34,56,78]
23:18:45 <enthropy> haasn: there was a patch for a <=.? :: Symbol -> Symbol -> Bool or so related to http://www.haskell.org/haskellwiki/CTRex
23:19:06 <enthropy> but such a thing doesn't seem to have made it into ghc-7.8 rc1 at least
23:19:45 <rusk101_> swap not in scope?
23:19:46 <haasn> enthropy: okay
23:19:55 <haasn> enthropy: cool though, once that hits I'll be able to nuke the cruft!
23:19:58 <Iceland_jack> rusk101_: swap is from Data.Tuple
23:20:04 <Iceland_jack> @hoogle swap
23:20:04 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
23:20:04 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
23:20:04 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
23:20:15 <Iceland_jack>     swap (x, y) = (y, x)
23:20:16 <Iceland_jack> :)
23:20:30 <rusk101_> cool. thanks.
23:20:45 <rusk101_> what happens if n==0?
23:20:50 <rusk101_> Nothing? lol
23:20:50 <Iceland_jack> Then you stop
23:20:59 <rusk101_> oh ok
23:21:00 <rusk101_> gotcha
23:21:09 <Iceland_jack> If you have 12345678 you get
23:21:09 <Iceland_jack> > quotRem 12345678 100
23:21:10 <lambdabot>  (123456,78)
23:21:14 <rusk101_> cuz of the quotRem
23:21:19 <Iceland_jack> So you collect 78, and carry on with 123456
23:21:26 <Iceland_jack> Then you do
23:21:26 <Iceland_jack> > quotRem 123456 100
23:21:27 <lambdabot>  (1234,56)
23:21:30 <Iceland_jack> So you collect 56, and carry on with 1234
23:21:34 <Iceland_jack> Then you do
23:21:34 <Iceland_jack> > quotRem 1234 100
23:21:35 <lambdabot>  (12,34)
23:21:36 <Iceland_jack> Etc. Etc.
23:21:49 <Iceland_jack> Until you reach 12
23:21:49 <Iceland_jack> > quotRem 12 100
23:21:50 <lambdabot>  (0,12)
23:21:57 <Iceland_jack> and then 0
23:22:02 <Iceland_jack> > quotRem 0 100
23:22:03 <lambdabot>  (0,0)
23:22:04 <Iceland_jack> and then you stop
23:22:16 <rusk101_> what happens with odd number of digits? it just gives the 0..9 at the end?
23:22:25 <Iceland_jack> rusk101_: Why don't you try? :)
23:22:27 <rusk101_> quotRem 1 100
23:22:39 <rusk101_> how come lambdabot dont like me
23:22:44 <haasn> rusk101_: you need the >
23:22:45 <levi> Use > in front if you want lambdabot to run it
23:22:47 <haasn> (and a space)
23:22:55 <rusk101_> > quotRem 1 100
23:22:56 <lambdabot>  (0,1)
23:23:00 <rusk101_> coo thx
23:23:22 <levi> rusk101_: Do you see how unfoldr works now?
23:23:28 <dmj`> > unfoldr (maybe Nothing (\x -> Just . (read *** readMaybe) . splitAt 2 . show $ x :: Maybe (Int, Maybe Int))) (Just 12345678)
23:23:29 <lambdabot>  Not in scope: `readMaybe'
23:23:46 <dmj`> import Text.Read
23:24:18 <dmj`> how can lambdabot not have readMaybe
23:24:40 <rusk101_> > reverse $ unfoldr (\n -> if n == 0 then Nothing else Just (swap (quotRem n 100))) [12345678]
23:24:41 <lambdabot>  No instance for (GHC.Show.Show t0)
23:24:41 <lambdabot>    arising from a use of `M496806144266958726730670.show_M4968061442669587267...
23:24:41 <lambdabot>  The type variable `t0' is ambiguous
23:24:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:24:41 <lambdabot>  Note: there are several potential instances:
23:26:25 <levi> rusk101_: foldr and unfoldr provide the basic 'recursion schemes' for lists. The 'foldr' function takes a summarizing function and an initial value and consumes the list; the 'unfoldr' takes a generating function and an initial value and generates the list.
23:26:27 <rusk101_> tytytyty
23:26:43 <Iceland_jack> rusk101_: You added brackets aruond the number [...]
23:26:49 <dmj`> foldr shouldn't be used tho :)
23:27:02 <levi> dmj`: What?
23:27:03 <rusk101_> i understand. I just wanted to see what happens
23:27:10 <Iceland_jack> ah that's fine :)
23:27:17 <dmj`> levi: thunk build up
23:27:32 <levi> dmj`: Maybe you're thinking of foldl?
23:27:38 <rusk101_> str2Integer xs = foldl (\acc digit -> acc*maxChar + fromIntegral (ord digit)) 0 xs HERE is one of my functions that uses foldl and i didnt want to use it. its for RSA
23:28:06 <dmj`> @src foldr
23:28:06 <lambdabot> foldr f z []     = z
23:28:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:28:23 <dmj`> It's not forcing the value
23:28:23 <dmj`> @src foldl'
23:28:23 <lambdabot> foldl' f a []     = a
23:28:23 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:28:29 <levi> rusk101_: For a tail-recursive function, foldl' is usually what you want.
23:28:45 <dmj`> seq forces eval
23:29:01 <rusk101_> @hoogle swap
23:29:02 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
23:29:02 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
23:29:02 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
23:29:26 <levi> dmj`: Yes, but we're in Haskell; we don't want to force everything all the time.
23:29:43 <Iceland_jack> > swap (True, "hello")
23:29:44 <lambdabot>  ("hello",True)
23:30:14 <Iceland_jack> > swap (swap (True, "hello"))
23:30:14 <lambdabot>  (True,"hello")
23:30:35 <haasn> foldr and foldl are not equal
23:30:43 <haasn> there is nothing that can replace foldr if a right-associative fold is what you want
23:34:08 <levi> You can write any fold as a foldr; you can't write a foldr in terms of foldl, though.  But when you *want* a left-associative fold with an accumulator, you probably want foldl' instead of foldl.
23:34:08 <rusk101_> muchos gracias seniores. Long Live Haskell
23:36:35 <haasn> saying that after his death is a bit ironic
23:37:47 <Welkin> haha
23:37:52 <Welkin> he meant the language
23:38:27 <haasn> Oh, I wouldn't worry too much about that; I'm sure we'll have linguists in 10,000 years studying the cryptic modes of communication used in our times ;)
23:41:45 <dmj`> funny how many freak out over haskell's quicksort not being in-place, when the author of quicksort says haskell is "doomed to succeed"
23:42:34 <adelbertc> dmj`: i get called out on that often whenever i show the canonical quicksort
23:42:36 <Welkin> is it possible to implement shell sort in haskell?
23:42:55 <Hafydd> It's possible to implement any sorting algorithm efficiently, if you use ST.
23:44:46 <dmj`> adelbertc: even RWH mentions it and quickly notes it's not in-place. Someone should just do it in ST, or just call into qsort() using the ffi ;)
23:49:08 <levi> Hafydd: Well, not sorting algorithms that rely on randomness. You could write those in IO, though.
23:49:19 <haasn> “quicksort”
23:50:49 <haasn> it's actually a tree sort
23:50:56 <haasn> convert it to BST then traverse
23:51:07 <haasn> quicksort is by definition a different algorithm
23:52:06 <Hafydd> levi: fair point.
23:53:09 <haasn> (or by passing it a pure RNG)
