00:00:05 <ski> tac : what do you want to do in case of `Nothing'
00:00:17 <tac> ski: The obvious thing, of course :)
00:00:23 <ski> which is ?
00:00:31 <Cale> alex______: There's a monoid instance on Ordering
00:00:34 <BasDirks> SLi: SourceGraph ?
00:00:46 <tac> I can't tell you what is obvious to you, ski. Only you know that :)
00:00:55 <SLi> BasDirks: Interesting, didn't know about that. Thanks.
00:00:59 <BasDirks> np
00:01:00 <Cale> Ordering is the three element type  data Ordering = LT | EQ | GT used to represent the results of comparisons
00:01:07 <ski> tac> :t maybeStuff
00:01:36 <alex______> Cale yes
00:01:38 <Cale> The monoid operation says that EQ <> y = y and x <> y = x otherwise
00:01:52 <tac> ski: Thinking of these things as record access
00:01:55 <Cale> So, take the result of the first comparison, unless they're equal, in which case use the second result
00:02:04 <tac> I want a Nothing anywhere in the chain to propagate down the chain
00:02:11 <Cale> There's also an instance of Monoid for functions whose codomain is an instance of Monoid
00:02:32 <ski> tac : sounds like `Maybe' monad/idiom
00:02:36 <Cale> and applying that twice gets us that for any type e, the type e -> e -> Ordering is an instance of Monoid
00:02:45 <tac> ski: yes, but I'm working with lenses
00:02:58 <Cale> and that's exactly the type of functions we pass to sortBy
00:03:02 * ski doesn't know about combining those with those
00:03:21 <tac> I got the answer I needed in #haskell-lens
00:03:24 <tac> The trick is to use traverse
00:03:32 <tac> which I don't know what traverse does
00:03:33 <tac> but w/e
00:03:41 <Cale> So, you can use this to combine partial orderings in order of importance to refine the ordering that you want
00:03:56 <tac> the important thing is my stuff compiles, so I'm just assuming it's correct :)
00:04:37 <Cale> > sortBy (comparing length <> compare) (words "here are some words to be sorted by length and then alphabetically")
00:04:39 <lambdabot>  ["be","by","to","and","are","here","some","then","words","length","sorted","...
00:05:19 <tac> a mistake... I'm getting an error and I have no idea where it's coming from....
00:06:23 <tac> but unrelated after all
00:07:00 <alex______> sortBy (comparing isNothing) [Just 5, Nothing, Just 3, Nothing]
00:07:26 <alex______> > sortBy (comparing isNothing) [Just 5, Nothing, Just 3, Nothing]
00:07:27 <lambdabot>  [Just 5,Just 3,Nothing,Nothing]
00:07:41 <tac> *** Exception: Failed reading: satisfy
00:07:53 <alex______> ok so this works because False < True
00:08:07 <alex______> > False < True
00:08:08 <lambdabot>  True
00:08:29 <ski> yep
00:08:33 <tac> stupid Aeson. Syntax error in the JSON and it doesn't tell you
00:08:40 <alex______> and if both are isNothing (or not), compare is used
00:08:53 <alex______> clever
00:12:54 <WraithM> Does anybody know about something like mapConcurrently that works in other monads? I have a ReaderT r IO a, and I want to mapConcurrently using that. mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b). I want something like: Traversable t => (a -> ReaderT r IO b) -> t a -> ReaderT r IO (t a)
00:12:59 <WraithM> Does this make sense?
00:13:05 <zipper> How can I \n in haskell?
00:13:20 <Hafydd> > '\n'
00:13:21 <lambdabot>  '\n'
00:13:31 <Cale> WraithM: It'd be less trouble just to do an ask beforehand and liftIO the mapConcurrently
00:13:38 <zipper> Hafydd: didn't seem to work but will try again.
00:14:02 <Cale> WraithM: but you could wrap that up into its own definition if you like
00:14:32 <WraithM> Cale: And then runReaderT for the Readers that I'm running concurrently?
00:14:37 <Cale> yeah
00:14:38 * hackagebot pipes-binary 0.4.0 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.0 (RenzoCarbonara)
00:14:38 * hackagebot yaml 0.8.7.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.7.2 (MichaelSnoyman)
00:14:43 <WraithM> Hm
00:15:06 <brokell> hi
00:15:08 <WraithM> Yeah, I was doing that, and then I felt wrong about it.
00:15:18 <WraithM> Thanks!
00:15:20 <Cale> WraithM: I'd feel wrong about using ReaderT :P
00:15:33 <WraithM> Yeah?
00:15:44 <Cale> On its own, ReaderT is rarely worth its weight
00:16:20 <Cale> If you're *already* going to the trouble of transforming some monad, then throwing in a ReaderT isn't going to cost you much additional trouble
00:16:38 <Cale> But having to lift things explicitly usually is more trouble than the parameter passing you save.
00:17:01 <WraithM> I've got a bunch of TVars and TChans that I want to carry around. Also, I need some things like usernames and passwords carried around.
00:17:12 <Cale> and then you run into things involving higher order functions on IO, and you get sad
00:17:27 <WraithM> Yes.
00:17:32 <alex______> j
00:17:37 <WraithM> Yes, I do.
00:17:52 <Cale> WraithM: Of course, you can still package all that stuff up as one parameter, and pass it where it's needed
00:18:05 <WraithM> Yeah :/
00:18:09 <Cale> anyway, that's just my usual outlook on things
00:18:51 <Cale> Unless you're *really* going to go to the trouble of packaging up your monad in a newtype and defining some very restricted set of things which are allowed in it
00:19:07 <Cale> and perhaps not even allow liftIO outside of a small module
00:19:17 <WraithM> That's actually more like what I'm doing.
00:19:23 <Cale> ah, okay
00:19:27 <WraithM> That's sort of why I went this way
00:19:35 <WraithM> It's sorta DSL-ish-y
00:19:36 <WraithM> I guess
00:19:36 <alex______> any way to make it even more concise? sortBy ((comparing (isNothing . lookitup)) <> (comparing lookitup)) where lookitup = lookup field . fields
00:19:41 <Cale> Well, in that case, that's fine
00:20:01 <Cale> You just have to endure the pain of lifting mapConcurrently to your new monad once.
00:20:15 <treehouse> I wrote "succ max 1 2" .. got an error. Why, lord, why?
00:20:26 <WraithM> Yeah, I guess I'll make my little lifter for mapConcurrently
00:20:35 <alex______> > succ (max 1 2)
00:20:36 <lambdabot>  3
00:20:37 <WraithM> Thanks!
00:20:57 <ilmig> > succ $ max 1 2
00:20:59 <lambdabot>  3
00:21:18 <Cale> treehouse: because that means the successor function applied to the three arguments max, 1 and 2
00:21:19 <alex______> treehouse: the way you did it, you passed three arguments to succ: max, 1 and 2
00:21:56 <treehouse> ah, thnx
00:21:59 <Cale> > succ (max 1 2)
00:22:00 <lambdabot>  3
00:22:11 <alex______> space binds stongest!!
00:22:14 <ilmig> I would write succ $ max 1 2
00:22:20 <alex______> strongest
00:23:19 <Cale> alex______: I would be careful and always stick "<> compare" on the end of the chain of comparisons to break ties, otherwise you might get funny random behaviour depending on the sorting algorithm
00:23:31 <treehouse> + is always infix?
00:23:56 <ski> treehouse : yes, but `(+)' isn't
00:24:00 <Cale> treehouse: unless you wrap it in parens
00:24:05 <ski> > (+) 2 3
00:24:06 <lambdabot>  5
00:24:25 <ski> > map ((+) 2) [3,5,7]
00:24:26 <lambdabot>  [5,7,9]
00:24:28 <Madarc> ski, no
00:24:34 <Madarc> > + 2 2
00:24:35 <lambdabot>  <hint>:1:1: parse error on input `+'
00:24:39 <alex______> Cale: in this case though I cant see what would that funny behavior be? lookitup returns Ord a => Maybe a
00:24:41 <Madarc> sorry
00:24:46 <Madarc> > (+ 2 2)
00:24:46 * ski blinks
00:24:47 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
00:24:47 <lambdabot>    arising from the ambiguity check for `e_122'
00:24:47 <lambdabot>  from the context (GHC.Num.Num a,
00:24:47 <lambdabot>                    GHC.Num.Num (a1 -> a),
00:24:47 <lambdabot>                    GHC.Num.Num a1)
00:25:06 <ski> > map ((^) 2) [3,5,7]
00:25:07 <lambdabot>  [8,32,128]
00:25:11 <ski> > map (^ 2) [3,5,7]
00:25:11 <alex______> and we eliminated Nothings
00:25:12 <lambdabot>  [9,25,49]
00:25:15 <ski> > map (2 ^) [3,5,7]
00:25:16 <lambdabot>  [8,32,128]
00:25:23 <Cale> alex______: if you're projecting out a small piece of your data, then you can tell the difference on the rest, the sort will tend to shuffle the values which otherwise match
00:25:29 <Madarc> i could have sworn that worked...
00:25:44 <ski> Madarc : perhaps you were dreaming in a Lisp ?
00:25:54 <Cale> (and how it shuffles will then depend on the exact implementation of sortBy, because you didn't supply a total ordering)
00:26:39 <verement> Cale: I think sort is required to be stable?
00:26:46 <alex______> Cale why? isnt compare x y  always the same as compare (Just x) (Just y)?
00:27:08 <ski> that's not an instance of "projecting out a small piece of your data"
00:27:28 <Cale> verement: oh, perhaps it is
00:28:03 <Cale> alex______: I'm talking about the lookitup stuff
00:28:38 <alex______> so my code is fine?
00:28:59 <Cale> alex______: I guess
00:29:26 <Cale> alex______: I would just tend to avoid supplying a non-total ordering to sortBy, though I suppose if it's required to be stable, you don't need to worry
00:30:30 <Cale> You could do something like  sortBy (comparing ((isNothing &&& id) . lookitup))
00:30:50 <Cale> Using (&&&) from Control.Arrow
00:31:37 <Cale> Or of course, that's the same thing as  sortBy (comparing (\x -> (isNothing x, x)))
00:31:40 <alex______> love the conciseness, but I am starting to wonder if the code is getting too smart :)
00:31:54 <Cale> oh, oops
00:32:24 <Cale> sortBy (comparing ((\x -> (isNothing x, x)) . lookitup))
00:32:25 <Cale> rather
00:33:46 <Cale> Also, if lookitup is doing a lookup in a Map, you *might* prefer to actually do this beforehand, rather than in the middle of the comparison
00:33:55 <Cale> because it'll repeat the lookup for each comparison
00:34:23 <alanz> Can anyone tell me what 'x-uses-tf' does in a cabal file?
00:35:40 <alex______> Cale you mean it will do it twice instead of once?
00:36:00 <Cale> alex______: It'll do it however many times the sort compares that element with other elements
00:36:05 <alex______> I thought ghc is smart enough to optimize it away
00:36:21 <Cale> It's also smart enough not to
00:36:35 <Cale> Because if you memoise every function like that, you never garbage collect anything
00:37:24 <Cale> (and there's no way for it to know without very careful analysis that it might need the result of that lookup ever again)
00:38:16 <Cale> alanz: Maybe something to do with test-framework?
00:38:45 <Cale> alanz: I googled for it, and noticed that custom field only shows up in cabal files which also depend on test-framework.
00:39:00 <WraithM> :t \f t -> do { r <- ask; liftIO $ mapConcurrently (\x -> runReaderT (f x) r) t }
00:39:01 <lambdabot> Not in scope: `mapConcurrently'
00:39:30 <alex______> not every function, just those you call more than once locally (within a same function)
00:40:17 <Cale> alex______: But the sorting algorithm is not physically applying the function to the same arguments, and your code isn't either :)
00:40:51 <Cale> and even then, ghc will not optimise (f x, f x) to let y = f x in (y,y), just because of the space concerns
00:41:23 <Cale> (It's actually very annoying if some optimisation accidentally does this kind of thing to you sometimes, it can lead to exponential blowup in space usage)
00:42:16 <Cale> consider something like   subsequences [] = [[]]; subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
00:42:51 <Cale> If GHC were to be clever and optimise this to  subsequences (x:xs) = let ys = subsequences xs in ys ++ map (x:) ys
00:43:02 <Cale> now the algorithm requires exponential space in the length of xs
00:43:41 <Cale> Because ys can't be GC'd until you start going through the second half of the list
00:45:14 <Cale> So sometimes it's vitally important to have the same expression physically occur twice and not be commoned up into a single value
00:45:44 <alex______> Cale hmm
00:46:11 <Cale> and you can always do that optimisation yourself, but it's very tricky to undo it if GHC is doing it to you automatically
00:47:09 <Cale> The *only* case where GHC will do common subexpression elimination is when you have nested case expressions and the scrutinee of the cases is the exact same expression
00:47:38 <Cale> This won't likely occur in code you write yourself, but it can occur after optimisation and expansion of syntax
00:48:51 <Cale> (e.g. one case I believe it shows up is when you have view patterns which examine the same expression)
00:50:15 <alanz> Cale: yes, that is what I found too. But could not find it in the ghc source or the cabal install source, or the cabal manual
00:51:13 <Cale> alanz: well, I believe cabal will just ignore fields that start with x-
00:51:34 <alanz> And if I take it out then ghc complains about the opening paren in '#if ! MIN_VERSION_base(4,6,0)'
00:51:36 <Cale> alanz: similar to mail headers that start with x-...
00:51:57 <Cale> huh
00:52:10 <alanz> or rather ghci does
00:53:10 <Cale> alanz: maybe lpaste your .cabal?
00:54:34 <alanz> Cale: https://github.com/haskell-distributed/distributed-process-platform/blob/development/distributed-process-platform.cabal
00:55:02 <alanz> Cale: if I cabal repl without it it loads fine, straight ghci complains
00:55:31 <Cale> Where's the CPP macro?
00:56:21 <alanz> Cale: https://github.com/haskell-distributed/distributed-process-platform/blob/development/tests/TestManagedProcess.hs#L22
00:57:12 <Cale> alanz: Try adding {-# LANGUAGE CPP #-} to the top of that file, just in case
00:57:45 <alanz> Cale: this is actually what I copied, hold on I will push my WIP showing the current
00:59:22 <Cale> alanz: Oh, well, in any case, you'll have trouble building that code without cabal
00:59:51 <alanz> Cale: it is https://github.com/alanz/hroq/blob/master/hroq.cabal and https://github.com/alanz/hroq/blob/master/tests/TestStatsGatherer.hs#L23
01:00:06 <Cale> alanz: because MIN_VERSION_<packagename>(A,B,C) will only be defined when Cabal is building the code
01:00:33 <Cale> (It defines those macros based on the dependencies of your package)
01:00:35 <alanz> and i am trying to get it working in emacs haskell-mode/ghc-mo
01:01:18 <Reite> Any pointers on how I should go about receiving mail in my haskell app? I want to be able to send emails to a specific address that the haskell application will accept and process
01:01:20 <alanz> I think I know what it does, it is just frustrating not to find any reference to it anywhere
01:01:35 <Cale> I still have no idea what x-uses-tf does
01:01:47 <Cale> I don't think it's actually something built in to cabal
01:02:04 <Cale> But I suppose it could be, that would be strange
01:04:44 <alanz> Cale:I will just put it down to an oddity and carry on. Thanks.
01:06:08 <Cale> alanz: You might ask dcoutts about it if he's around at some point.
01:06:58 <alanz> Cale:ok
02:04:14 <jdnavarro_> I'm trying ghc-7.8.0, and I'm seeing it's using `base-4.7.0.0`, is the documentation for these new packages coming with 7.8.0 built somewhere online?
02:09:51 * hackagebot websockets 0.8.2.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.2.0 (JasperVanDerJeugt)
02:21:16 <seanparsons> So following on from my shenanigans yesterday with cabal it would appear it's not only picking up on user installed packages but system wide installed packages too. Which is kinda insane, anyone know if I can get it to ignore those?
02:22:00 <merijn> seanparsons: How is it insane to look at system-wide installed packages?
02:22:24 <merijn> seanparsons: Isn't the definition of "system-wide install" that it's visible "system-wide"?
02:24:48 <seanparsons> merijn: That means that I have to manually do reinstalls into whatever sandbox for a project where the dependencies conflict with those installed by applications written in Haskell.
02:26:31 <merijn> seanparsons: This is a bug in your package manger
02:26:59 <merijn> seanparsons: Some linux packagers insist on making cabal install globally. Making cabal install globally is widely considered undesirable
02:26:59 <seanparsons> merijn: Apt has a bug in it?
02:27:09 <merijn> seanparsons: Well, as social bug, but yes
02:27:16 <c_wraith> yes, apt's setup for haskell is completely  broken
02:27:18 <c_wraith> don't use it
02:27:34 <merijn> seanparsons: The apt maintainers insist on installing globally (like many package managers), the result is it breaks the environment for any haskell dev
02:27:53 <merijn> seanparsons: Most haskell devs just install all haskell programs directly using cabal instead of something like apt to avoid this
02:28:25 <seanparsons> merijn: Well that's the conclusion I'm very quickly coming to myself.
02:28:29 <c_wraith> apt also insists on not installing profiling libs for ghc by default, which means that attempting to make profiling builds just breaks mysteriously in a ways that it doesn't on any system where ghc is installed correctly
02:28:40 <c_wraith> *a way
02:28:50 <seanparsons> So is there a sensible way to install ghc on Linux then?
02:29:05 <c_wraith> grab the pre-built linux binary.  install it.  done.
02:29:25 <merijn> seanparsons: I would just grab a binary from the GHC website, soon there will be a prebuilt cabal binary too and then you're set
02:29:28 <c_wraith> Well, ok, you probably should also grab cabal from source.
02:29:37 <merijn> c_wraith: Not for long :)
02:29:46 <ilmig> I didn't have any problems with the debian's haskell packages so far
02:30:03 <merijn> c_wraith: afaict from the mailing list consensus has been reached that there will be prebuilt cabal binary too
02:30:17 <ilmig> true, you have to manually install the profiling packages, but this shouldn't be too hard
02:30:23 <seanparsons> Probably the docs shouldn't advise you to install it from apt then: http://www.haskell.org/ghc/distribution_packages#ubuntu
02:30:34 <c_wraith> yeah, the docs are wrong.
02:30:46 <c_wraith> you usually don't want the platform, either
02:30:49 <c_wraith> but they claim you do
02:30:55 <merijn> c_wraith: Depends
02:31:02 <merijn> c_wraith: On OSX the platform is perfectly fine
02:31:11 <merijn> On windows too
02:31:16 <c_wraith> except for installing everything in bizarre locations on os x
02:31:27 <merijn> c_wraith: You say bizarre, I say expected
02:31:43 <merijn> c_wraith: It just puts everything in the same places all other tools go on OSX
02:32:30 <merijn> The OSX/Windows binaries of platform have always Just Worked(TM) for me
02:32:36 <c_wraith> If you use no other developer tools on os x, it's just hiding the things it installs for no good reason.
02:33:28 <alex______> Cale, how did you mean I would avoid lookup? by zipping that list with looked up elements?
02:33:37 <alex______> multiple lookup*
02:36:00 <seanparsons> Sounds like I'm gonna need to do some shenanigans when I get home tonight then to get some decent install rigged up for all these bits.
02:36:02 <seanparsons> Cheers all.
02:38:00 <merijn> seanparsons: Basically all you need is a binary ghc and cabal and then you can do the rest via cabal. I remember some people here having a guide for that on linux, but I forgot where
02:38:43 <seanparsons> Yeah, that was pretty much my plan. Even if I've got to figure out how to get there myself. :)
02:47:09 <merijn> seanparsons: Feel free to yell at the package managers for breaking things, maybe they'll stop :p
03:03:55 <pranz> is there a non-infix version of <*> ?
03:06:52 <mm_bureau> pranz: (<*>)
03:07:02 <verement> :t (<*>)
03:07:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:07:16 <verement> :t ap
03:07:16 <lambdabot> Monad m => m (a -> b) -> m a -> m b
03:13:19 <greg`> currently munching through the typeclassopedia
03:13:34 <greg`> oohm nom nom
03:17:43 <Tekmo> let f a b = \x -> snd ([a,x],b)
03:17:44 <Tekmo> Oops
03:26:19 <greg`> Tekmo does that typecheck?
03:45:03 * hackagebot text-stream-decode 0.1.0 - Streaming decoding functions for UTF encodings.  http://hackage.haskell.org/package/text-stream-decode-0.1.0 (MichaelSnoyman)
03:52:39 <Taneb> @pl \f -> foldr (.) id (repeat f) undefined
03:52:40 <lambdabot> flip (foldr (.) id . repeat) undefined
03:53:18 <Taneb> Ooh, that's better than what I had by hand
03:53:24 <alex_______> is there already a built in parser in parsec to parse a double? (ideally it should be able to oarse "1" "1.0", "1e10")
03:58:52 <Taneb> > foldl f x [a,b,c]
03:58:55 <lambdabot>  f (f (f x a) b) c
03:59:31 <calrf> hola alguien habÒa espaÒol?
03:59:42 <Taneb> > foldl (\a b -> (1:)) undefined [0..]
03:59:43 <lambdabot>  <[Integer] -> [Integer]>
03:59:52 <Taneb> > foldl (\a b -> (1:)) undefined [0..] []
03:59:57 <lambdabot>  mueval-core: Time limit exceeded
04:00:04 <Taneb> Thought as much
04:05:06 * hackagebot conduit 1.0.14 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.14 (MichaelSnoyman)
04:05:08 * hackagebot network-conduit 1.0.2.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.2.2 (MichaelSnoyman)
04:20:07 * hackagebot stm-firehose 0.1.4 - Conduits and STM operations for fire hoses.  http://hackage.haskell.org/package/stm-firehose-0.1.4 (SimonMarechal)
04:22:08 <maxs`> what determines the order of incoherent instances? I need to reverse it
04:32:00 <allsystemsarego> Hi all, I believe I encountered my first space leak: http://lpaste.net/99857 - any advice on how to deal with it?
04:35:15 <mr-> allsystemsarego: unrelated to the space leak, but get_result is sometimes called (!!)
04:36:32 <allsystemsarego> point taken :D
04:37:55 <mr-> allsystemsarego: you could try with https://groups.google.com/forum/#!topic/haskell-cafe/1nQZzKlLcec
04:38:21 <allsystemsarego> thanks, I'll have a look
04:40:58 <sipa> nn/qgm
04:41:02 <sipa> ugh
04:47:34 <skypers_> hi
04:47:49 <skypers_> I‚Äôm looking for an abstraction over mempty
04:47:54 <skypers_> do you know some categories for that?
04:49:14 <skypers_> juste like Monoid but with no binary op
04:50:12 <Twey> skypers_: It's called a pointed set
04:50:12 <Twey> allsystemsarego: not_exactly_fib is a list, a non-function type, which means it will be memoized
04:50:12 <skypers_> Twey: thank you
04:50:12 <Twey> allsystemsarego: I.E. all previous results are stored
04:50:19 <Twey> skypers_: It's arguable to what extent that can be called ‚Äòmempty‚Äô, of course, because it doesn't have to have the identity properties mempty has with respect to the monoid operation
04:50:35 <Twey> skypers_: But e.g. the Data.Default.Default class from the ‚Äòdefault‚Äô package might be relevant
04:50:36 <skypers_> Twey: yeah I‚Äôm just thinking about that
04:50:41 <skypers_> yes it‚Äôs default that I need
04:53:07 <allsystemsarego> Twey, thanks, I just saw on haskell-cafe that the solution is to use zipWith' instead of zipWith
04:54:06 <Twey> Oh, right, shouldn't be on the stack, yeah.
04:54:10 <allsystemsarego> oh wait, no
04:55:20 <Twey> allsystemsarego: I'd expect that code to give you O(n) memory usage for the nth Fibonacci number
04:55:34 <Twey> But not stack usage
04:55:36 <allsystemsarego> hmmm
04:55:57 <allsystemsarego> so the solution is to use the State monad then?
04:56:47 <Twey> If you don't want the O(n) memoization overhead, then yes, something like that
04:57:14 <allsystemsarego> yeah, I want constant space
04:58:16 <Twey> allsystemsarego: You can also just trivially make your fibs a function instead of a value
04:58:29 <Twey> not_quite_fibs ‚à∑ Integer ‚Üí Integer
04:59:04 <Twey> Or Int ‚Üí Int works here too, I suppose
04:59:26 <allsystemsarego> Twey, by using until?
04:59:36 <allsystemsarego> and a succesor function
04:59:40 <allsystemsarego> ?
05:00:34 <Twey> allsystemsarego: I don't think until is helpful; you can just use direct recursion
05:00:46 <allsystemsarego> oh ok
05:01:07 <Twey> until is for when you're looking for a specific property of the result
05:01:44 <Twey> (also, it's a little evil, since it's non-terminating if your (a ‚Üí a) doesn't even yield something that matches the predicate)
05:02:14 <Aetherspawn> dist/build/Language/C/Parser/Lexer.hs:522:50:
05:02:15 <Aetherspawn>     Couldn't match expected type ‚ÄõBool‚Äô with actual type ‚ÄõInt#‚Äô
05:02:19 <Aetherspawn> blah! it was bound to happen
05:02:49 <Aetherspawn> w.r.t the new primops in 7.8 use Ints not bools
05:03:29 <Twey> Aetherspawn: Why?
05:03:42 <Aetherspawn> optimization
05:03:53 <Twey> Ints are more optimizable than Bools?
05:04:13 <Twey> Oh, well, I suppose Int#s are
05:04:14 <Aetherspawn> yeah there was quite a large win
05:04:36 <Aetherspawn> anyway this error happens when installing c2hs
05:05:14 * hackagebot hslogstash 0.3.7 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.7 (SimonMarechal)
05:09:06 <Axman6> Twey: they allow avoiding branching code by having large boolean expressions working bitwise and then checking their result at the end. currently things like many (||)'s will form large case statements which aren't optimised easily
05:10:09 <Axman6> Twey: https://ghc.haskell.org/trac/ghc/wiki/PrimBool
05:20:15 * hackagebot hslogstash 0.3.7.1 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.3.7.1 (SimonMarechal)
05:22:00 <Twey> Axman6: Ah, clever!
05:24:07 <otulp> Does a package with a high performance (i.e. zero-copy) binary instance for Data.Vector.Storable exist? I tried using vector-binary-instances, but had performance problems. I then started writing my own instance, but it's getting a little messy and I'm not quite confident alignment will be handled properly.
05:24:54 <linduxed> for haskellites in Stockholm: http://www.meetup.com/Haskell-Stockholm/events/164112842/
05:28:03 <rgr> that was a good exercise. installing from darcs and building .. but next time remebing to use ghc-pkg hide/expose before hand so I dont need to rebuild if I deregister the darcs version. All coming together.
05:34:44 <eacameron> is there a standard infix for (fmap . fmap) ?
05:35:05 <supki> no
05:36:27 <Cale> eacameron: some people like to call it .: from what I've seen
05:37:00 <eacameron> Cale: I thought that was for (.) . (.) only
05:37:57 <eacameron> I've been calling it <$$>  does that conflict with anything common?
05:39:12 <supki> there's <**> which is  flip (<*>)  so I'd assume <$$> is the flipped version of <$>
05:43:39 <pranz> :t M.singleton
05:43:43 <lambdabot> k -> a -> M.Map k a
05:44:07 <Twey> :t let (...) = fmap . fmap in (...)
05:44:08 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:45:19 <supki> (...) is taken by lens though
05:47:26 <Twey> supki: Is anything not?  :√æ
05:47:52 <supki> I think (....) is still free
05:48:07 <Twey> eacameron: You might as well go all the way and use fmap fmap fmap; you could call it <$$$> or something
05:48:30 <Twey> We should really establish some kind of global conventions for operators
05:49:44 <Twey> I guess the idea that meaning . reverse $ horizontalFlip op = flip op is pretty well-established
05:50:24 <eacameron> Twey: yeah good point.
05:51:07 <eacameron> supki: yeah...but I've never liked that one ;)
05:51:28 <eacameron> supki: wish it were something like >*<   ;)
05:55:38 <Twey> eacameron: What does that mean?
05:55:53 <Twey> <*> is ‚Äògeneralized *‚Äô where * is function application
05:56:09 <Twey> Hardships of flexible syntax: operator naming is hard ‚òπ
05:57:01 <maybefbi> which algebraic structure is ideal for a representing a point and figure chart?
05:57:51 <eacameron> Twey: I'm mostly joking; (<**>) = flip (<*>) and I've never liked that; If <*> is not commutative, then I wish it would make that more obvious, like >>= does
06:03:04 <pjdelport> I wonder if colored Haskell could ever catch on
06:03:13 <pjdelport> a la colorForth
06:03:17 <tdammers> colored haskell?
06:03:24 <tdammers> with escape sequences in your source code?
06:03:38 <pjdelport> give operators a color, to indicate commutativity, or whatever else
06:04:02 <tdammers> I get a weird Perl taste in my mouth
06:04:09 <pjdelport> tdammers: well, the mechanism isn't important, just the idea of semantic colors
06:04:35 <tdammers> I guess it would be easier to set up syntax highlighting to give you the colors you want
06:04:56 <tdammers> like, make the IDE aware of commutativity, and use that information to color operators accordingly
06:05:13 <tdammers> my guess is that it's not worth it though
06:05:33 <pjdelport> tdammers: well, the idea is that the color determines the semantics, not the other way around (so commutativity isn't the best example)
06:05:48 <pjdelport> yeah; it's just an thought experiment
06:05:48 <grohne> actually what you propose should be relatively easy when using agda2-mode, since that mode already has semantic information about all the identifiers.
06:06:22 <tdammers> pjdelport: I think entering that color information is going to be an utter hassle
06:06:44 <tdammers> pjdelport: how would you do that anyway? code in Word? HTML? terminal escape sequences?
06:06:51 <tdammers> none of those sounds all that tempting
06:08:42 <grohne> unicode character modifiers? ;-)
06:11:24 <tdammers> grohne: yeah, let's use those. Or let's not.
06:11:37 <tdammers> speaking of unicode
06:11:53 <grohne> it was a joke
06:11:59 <Twey> eacameron: Oh, right.  Yes, <*> should be directed
06:12:09 <tdammers> we need a programming language that uses everything *but* ASCII
06:12:41 <tromp> and call it incontrol ?
06:12:42 <Twey> Hm
06:12:47 <Twey> APL doesn't use *much* ASCII
06:13:29 <grohne> I have had my share of unicode issues in agda, specifically a) zero-width white space characters and distinguishing -> (function type), -> (equality preserving function type)
06:13:33 <pjdelport> tdammers: The mechanism isn't important: I'm not sure if you're familiar with colorForth, but the idea there is that color replaces the role of punctuation in various ways: red indicates a word definition, green compilation, yellow execution, magenta variable definition, etc.
06:13:54 <pjdelport> tdammers: so you change the meaning of a word by changing its color
06:14:00 <tdammers> I don't know colorForth, but I think I get the idea
06:14:22 <tdammers> apart from usability for the color blind, my main gripe is that current tooling is inadequate
06:14:29 <pjdelport> it's slightly analogous to how Haskell distinguishes constructors by capitalization
06:15:08 <pjdelport> tdammers: that's addressed in colorForth; you can use fonts, italics, sound, or various other mechanisms to represent the same things as the color, too
06:15:22 * hackagebot tkyprof 0.2.2 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.2.2 (MitsutoshiAoe)
06:15:24 * hackagebot text-stream-decode 0.1.0.1 - Streaming decoding functions for UTF encodings.  http://hackage.haskell.org/package/text-stream-decode-0.1.0.1 (MichaelSnoyman)
06:15:41 <pjdelport> (or traditional punctuation, for that matter)
06:15:47 <tdammers> pjdelport: plain text files support neither of those
06:16:01 <pjdelport> tdammers: nobody said it had to be plain text :)
06:16:04 <tdammers> and I'd rather not leave my beloved vim behind
06:16:16 <rgr> Ive generated all my own .hoo databases from sources installed from darcs and combined them and stored them in .hoogle/default.hoo - theres nothing in the manpage  that shows how to tell hoogle to use this (assumed it would default). If I "cd" there it works.I checked the "local install" info https://github.com/ndmitchell/hoogle/blob/master/docs/Local-Install.md but nothing there about how hoogle finds its files
06:16:16 <rgr> either. http://neilmitchell.blogspot.de/2008/08/hoogle-database-generation.html says to use the "--include" command line - but that doesnt exist anymore. Ideas?
06:17:15 <pjdelport> but it's interesting to think about how that can be used for Haskell: for example, imagine you could import one library as red, and another as green
06:18:31 <allsystemsarego> Twey, http://lpaste.net/99860 when using the State monad it still leaks
06:18:48 <tdammers> it strikes me as mostly weird and not very useful
06:19:41 <tdammers> IMO the strongest point of using ASCII for code is that it's as close as you can get to manipulating raw bytes while at the same time maintaining human readability
06:25:08 <mbrock> "20-20 vision is required for fighter pilots. I have no qualms about requiring color vision for programmers. Everyone does not need to be a programmer."
06:26:16 <mbrock> I'm both both color blind and a fan of Chuck Moore, and I find that statement bizarrely funny...
06:26:53 <tdammers> well, considering the state of the industry, it does appear that everyone does actually need to be a programmer
06:27:10 <tristan__> what industry
06:27:21 <tdammers> software?
06:27:30 <tristan__> o...
06:27:47 <impredicative> What's the best way to get cabal to use libraries in /usr/include/sys? extra-libraries: sys/ttycom.h doesn't seem to work
06:28:09 <tdammers> that's a header, not a library
06:28:13 <impredicative> Good point
06:28:34 <impredicative> Sorry, didn't mean to have the '.h' on the end
06:29:08 <impredicative> Crucially, the headers/libraries are in /usr/{lib,include}/sys
06:29:37 <impredicative> Actually, I don't know where the libraries are. They're system libraries...
06:29:45 <impredicative> This may be my problem :-)
06:31:05 <geekosaur> some of the stuff defined in /usr/include/sys, depending on platform, may only exist within the kernel
06:31:24 <Twey> mbrock: Haha, have you read the ‚ÄòType Theory in Color‚Äô paper?
06:33:33 <impredicative> Okay, reformulating my question: I am writing bindings to things in /usr/include/sys/{ttycom.h, ioctl.h} - what library(ies) should I specify in 'extra-libraries' to get that?
06:34:34 <mbrock> Twey: no, looks fun though :)
06:34:41 <mbrock> everyone loves colors...
06:35:05 <mbrock> I recently discovered that I can put emojis into my programs, which is even better
06:37:42 <allsystemsarego> Hi all, http://lpaste.net/raw/99861 - any advice on how to deal with a space leak? I'm using the State monad in this version of my code
06:40:25 * hackagebot text-stream-decode 0.1.0.2 - Streaming decoding functions for UTF encodings.  http://hackage.haskell.org/package/text-stream-decode-0.1.0.2 (MichaelSnoyman)
06:41:15 <quicksil1er> allsystemsarego: let y = sum_mod modulo_value a b; y `seq` put (b,y)
06:41:22 <quicksil1er> I suspect that's it, at least.
06:44:45 <allsystemsarego> quicksil1er, thanks, I'll try that
06:44:46 <quchen> allsystemsarego: Try the annotation. http://lpaste.net/99861
06:45:59 <allsystemsarego> quchen, thanks, I'll try this too
06:46:19 <quchen> By the way, `rem` is usually faster than `mod`, I recommend using the latter if you're not dealing with negative numbers (for positive ones they're identical)
06:47:02 <quchen> And  (x+y) `mod` m  == (x `mod` m) + (y `mod` m)  where the latter doesn't overflow that easily
06:49:29 <quchen> And even furthermore, you can calculate the n-th Fibonacci number in O(log(n)) multiplications, which might save you some time. Your current implementation does O(n) multiplications.
06:50:08 <quicksil1er> quchen: your version requires the BangPatterns extension.
06:50:17 <quchen> Yes.
06:50:57 <quchen> I think GHC suggests the extension when you use bang patterns without it, does it not?
06:51:08 <quchen> ("Illegal bang pattern, you forgot -XBangPatterns" or something)
06:51:08 <quicksil1er> and is otherwise identical to mine, except you waste CPU time on `seq`ing "a" as well, and you refactore the get/put into a modify.
06:53:57 <impredicative> Has anyone seen this error in c2hs? GenBind.evalConstCExpr: Casts are not implemented yet. Seems to be todo with enum define statements
07:12:31 <shergill> more and more that i've been tinkering with coq in the last couple of months, the more i want to write it as a library/edsl in haskell
07:16:21 <Swizec> I would love it if everyone could read this and tell me I totally missed the point: http://swizec.com/blog/week-15-a-tutorial-on-the-expresiveness-and-universality-of-fold/swizec/6514
07:18:41 <HugoDaniel> Swizec: "Take heed of the lesser programmer and remember that many functions you rewrite as a fold, you will not be able to read in six months" :D
07:18:55 <Swizec> HugoDaniel it's true!
07:20:14 <supki> Swizec: foldr is not right-to-left
07:20:20 <HugoDaniel> why the parenthesis on the definition ?
07:20:22 <supki> in fact, fold = foldr
07:21:06 <Swizec> supki really? well fuck :D
07:21:18 <shergill> edwardk: you were right wrt your prediction that i was probably going to revisit my stance wrt coq ‚Üë
07:21:34 <supki> > foldr f z [a,b,c]
07:21:35 <lambdabot>  f a (f b (f c z))
07:21:46 <supki> > foldl f z [a,b,c]
07:21:47 <companion_cube> shergill: what's wrong with coq?
07:21:47 <lambdabot>  f (f (f z a) b) c
07:22:16 <Swizec> well I hope the rest of my summary fares better ...
07:22:35 <kqr> can someone clear this up for me? http://www.reddit.com/r/ProgrammerHumor/comments/1xjxdp/the_joke_that_refuses_to_be_the_joke_that_refuses/cfcvg8d?context=3
07:22:43 <kqr> it's about the difference between recursion and corecursion
07:26:13 <HugoDaniel> Swizec: why the parenthesis in fold :: (a -> b -> b) -> b -> ([a] -> b) ?
07:26:31 <Swizec> HugoDaniel I don't know, that's what hte original paper had
07:26:44 <kqr> HugoDaniel, a -> b -> c can be interpreted as a -> (b -> c)
07:27:01 <HugoDaniel> oh
07:27:02 <shergill> companion_cube: extensibility is an issue. basically for tactics beyond a certain complexity you have to implement it as a coq plugin i.e., you have to shift to ocaml
07:27:06 <kqr> HugoDaniel, in this case, it highlights that if you give fold a combining function and an identity value, it will give you back a function that turns a list into a value
07:27:25 <companion_cube> shergill: I'm a bit surprised, very big developments have been written in coq
07:27:59 <HugoDaniel> very good, i didn't knew it was equivalent, in my mind i just thought that with parent. i would be enforcing a single value out
07:28:02 <shergill> companion_cube: i don't doubt it. take a look at their code from the point of software reuse and extensibility however
07:28:08 <HugoDaniel> but yeah, being a function, currying takes care of the rest
07:28:10 <HugoDaniel> amzing
07:28:20 <HugoDaniel> thanks :)
07:28:25 <companion_cube> shergill: there are modules and functors (in the ML sense)
07:28:31 <companion_cube> but I'm really no expert, so...
07:29:35 <shergill> companion_cube: specifically it doesn't seem easy to share code between value level programs and their proofs
07:29:43 <kqr> HugoDaniel, becomes very cool when you realise map is really (a -> b) -> ([a] -> [b])
07:30:11 <shergill> i.e., code reuse between theorems and values in the Set universe
07:31:07 <shergill> there's also the issue regd the extensibility of the extracted code, which i know for haskell is not ideal, but i've not looked at output of the extracted ocaml program
07:31:49 <Twey> kqr: I think you've pretty much got it covered
07:32:02 <kqr> Twey, oh cool
07:32:07 <kqr> Twey, didn't realise it would be that simple
07:33:49 <Twey> kqr: A recursive definition is one that ‚Äòshrinks‚Äô data down into some base case, then handles that case (thereby terminating with some finite answer).  A co-recursive definition is one that starts from some base ‚Äòseed‚Äô and produces more and more data (thereby not terminating, but always producing output).  They look the same in Haskell because of laziness.
07:34:07 <kqr> ah i see
07:34:21 <Twey> See also: fold vs. unfold
07:34:28 <HugoDaniel> cofold :)
07:40:23 <Eduard_Munteanu> Is there a better way to convert Data.Bytestring to String, other than map chr . unpack?
07:40:32 * hackagebot ViennaRNA-bindings 0.1.1.1 - ViennaRNA v2 bindings  http://hackage.haskell.org/package/ViennaRNA-bindings-0.1.1.1 (ChristianHoener)
07:41:09 <Eduard_Munteanu> Without any encoding, that is.
07:41:44 <cdk> I see Criterion runs a single timed iteration of a benchmark in order to estimate how long (single benchmark) * (# of samples) will take. Unfortunately that first timed sample completely ruins the rest of the benchmarks for me. Is there any way to turn that off? I'm looking at Criterion.Config, but I don't see anything related.
07:42:32 <shergill> in haskell (+ extensions), is there a way to run arbitrary computations during type-checking. or rather is there a way to do so in a manageable manner (since haskell with extensions is has a turing complete type-system)?
07:42:39 <pvt_petey> hello
07:42:45 <pvt_petey> a general question
07:42:56 <Eduard_Munteanu> shergill: Template Haskell can run any Haskell code at compile-time
07:43:01 <pvt_petey> how does fib (n+2) a0 a1 = fib (n+1) (a0+a1) a0 evaluate (http://pastebin.com/PEsWX0ZJ) ?
07:43:09 <pvt_petey> at runtime
07:43:30 <pvt_petey> i think the conditions for 1 and 0 make sense
07:43:57 <HugoDaniel> pvt_petey: its fibonacci not fibonachi
07:43:59 <shergill> Eduard_Munteanu: right, but i'm looking specifically for ways to enforce fancier and fancier constraints. template haskell on its own doesn't, but a library which uses it in the right manner might
07:44:15 <shergill> hmm i guess somewhat related would be dependent types in haskell
07:44:22 <pvt_petey> typo sry
07:45:06 <Eduard_Munteanu> shergill: well, things like DataKinds, PolyKinds, UndecidableInstances etc. definitely make it more expressive
07:45:28 <Eduard_Munteanu> pvt_petey: can you be a bit more specific about your question?
07:46:33 <Eduard_Munteanu> pvt_petey: btw, that's an n+k pattern and it's obsolete in H2010
07:46:50 <pvt_petey> it's just what my professor set :)
07:46:58 <pvt_petey> soo.. i could believe it
07:47:58 <pvt_petey> well for fib (n+2) a0 a1 = fib (n+1) (a0+a1) a0. is a0 and a1 always 1 ?
07:48:10 <shergill> Eduard_Munteanu: right. but each is implemented in ghc. i was wondering if you could define such extensions without modifying ghc proper. you could potentially have something based on template haskell, which provides you with these constructs so that such plugins can reside outside of ghc
07:48:50 <pvt_petey> I read that as if we put in 10 it would be (10+1) * (1+1)
07:49:10 <pvt_petey> but clearly that's wrong
07:49:11 <pvt_petey> :)
07:50:04 <Eduard_Munteanu> shergill: you can extend syntax using quasiquotation, but not very nicely if you expect to implement extensions as they currently are
07:51:00 <Eduard_Munteanu> pvt_petey: no, they aren't
07:51:38 <Eduard_Munteanu> pvt_petey: as the first argument goes towards 0, a0 accumulates the result
07:52:25 <Eduard_Munteanu> shergill: it might be useful to discuss a specific example if you have something in mind
07:52:26 <pvt_petey> because of the preceding term for n=0?
07:52:44 <Eduard_Munteanu> pvt_petey: no, because of the last equation
07:52:57 <pvt_petey> fib (n+2) a0 a1 = fib (n+1) (a0+a1) a0 ?
07:53:08 <shergill> Eduard_Munteanu: i don't at the moment, but i can try and characterize the issue better
07:53:09 <Eduard_Munteanu> pvt_petey: yep.. you can expand that further
07:53:43 <Eduard_Munteanu> shergill: Haskell's typesystem isn't Turing-complete by default, really.
07:53:55 <shergill> Eduard_Munteanu: agreed
07:54:14 <shergill> Eduard_Munteanu: let's take PolyKinds for instance. now iiuc that's implemented in haskell since ghc is written in it, correct?
07:54:21 <Eduard_Munteanu> shergill: and even when it is, it might be rather poor
07:55:19 <Eduard_Munteanu> shergill: yes, but that's implementing a typechecker, not expressing something in Haskell's typesystem.
07:55:59 <shergill> Eduard_Munteanu: right, i understand
07:56:04 <Eduard_Munteanu> shergill: for example, Agda is a dependently-typed language implemented in Haskell. That doesn't mean Haskell's typesystem is as expressive as Agda's.
07:56:08 <shergill> just doing basic sanity checks right now
07:56:23 <shergill> of course
07:57:22 <Eduard_Munteanu> It's actually a very very poor type the one that corresponds to Agda... IO (). :)
07:57:58 <pvt_petey> Eduard_Munteanu : sorry you might need to give me more of a hint :)
07:58:04 <shergill> Eduard_Munteanu: so say i have this new project that i want to work on. i want to prove certain properties for the code in this project. given haskell with extensions is turing complete i can theoretically do it, but like you pointed out it's not very usable at times in the raw form
07:59:41 <Eduard_Munteanu> pvt_petey: take fib 3 a0 a1 = fib 2 (a0 + a1) a0 = fib 1 (a0 + a1 + a0) (a0 + a1) = a0 + a1 + a0
07:59:46 <shergill> Eduard_Munteanu: so to help state and prove said properties i decide to extend haskell's type-checker as it were. except that i don't want to do that by modifying ghc
08:02:06 <shergill> i want an extensible type system. or rather helpers to be able to express arbitrary constraints at the type level
08:02:07 <Eduard_Munteanu> shergill: think of it another way... the typesystem as it is now is much like arithmetic axioms. They're considered rather consistent, but if you decide to extend that, the burden of proof is on you.
08:03:07 <Eduard_Munteanu> shergill: that might or might not result in a consistent type system
08:03:12 <shergill> Eduard_Munteanu: right. i would want to do it in an automated way. hence the bit about helpers
08:05:08 <Eduard_Munteanu> shergill: you could look into Hoare logic if you're interested in somewhat adhoc pre/postconditions
08:06:05 <Eduard_Munteanu> shergill: anyway, something like that can be implemented in TH, but you end up with a rather adhoc thing.
08:07:12 <shergill> Eduard_Munteanu: you can trivially (not in terms of implementation complexity) do something much better. say write type-system extensions in coq
08:08:01 <shergill> i just want coq to be implemented as a haskell library
08:08:20 <Eduard_Munteanu> shergill: assuming the base typesystem is already encoded in a richly-typed Coq program.
08:08:37 <Eduard_Munteanu> shergill: that won't help much
08:09:19 <Eduard_Munteanu> shergill: if you want to write DT code and interface with Haskell, use Agda.
08:09:20 <shergill> or rather a self-hosting coq
08:10:57 <shergill> so if coq had an implementation of ocaml, that would be sufficient i believe
08:12:48 <Eduard_Munteanu> shergill: well, not necessarily... it depends how much you prove of your target language. You can write a compiler without proving the resulting typesystem is consistent, even in Coq.
08:13:32 <Eduard_Munteanu> shergill: and the semantics of things like Ocaml and Haskell are rather icky to reason about
08:14:56 <Eduard_Munteanu> Though the typesystem alone may be more manageable.
08:15:01 <shergill> Eduard_Munteanu: well yeah you only get guarantees for things you do prove
08:15:18 <shergill> Eduard_Munteanu: and that's what i'm thinking of, only the type-system for now
08:15:27 <shergill> which is more well-formed and does admit reasoning
08:16:52 <Eduard_Munteanu> shergill: still, even Haskell's type system extensions have been reasoned about, perhaps not in a manner that's machine-checkable. You can do that with your extensions as well, and if you write that in Coq that requires a proof too. :)
08:18:04 <shergill> Eduard_Munteanu: well of course it does, but you at least get an answer as to the soundness of your custom extension
08:18:35 <shergill> assuming you've taken care to encode the core assumptions of the base type system
08:20:04 <Eduard_Munteanu> Yeah, I think picking a more specific thing you might want in the typesystem would be better to discuss.
08:38:49 <Eduard_Munteanu> Is there a better way to convert Data.Bytestring to String, other than map chr . unpack?
08:40:02 <c_wraith> I usually go via Text
08:40:04 <johnw> isn't that quite possibly the worst way to do it?
08:40:09 <johnw> I do it via Text too
08:40:16 <c_wraith> T.unpack . decodeUTF8
08:40:27 <Eduard_Munteanu> I don't want any decoding/encoding
08:40:31 <johnw> in any case, converting it to String implies making a decision about the ByteString's encoding
08:40:46 <johnw> in that case use Data.ByteString.Char8.unpack
08:40:48 <Eduard_Munteanu> AFAIU, String can represent raw data, no?
08:41:14 <Twey> Eduard_Munteanu: String is a list of Char; Char is a Unicode codepoint
08:41:36 <Twey> While you technically *can* fit a byte into a Char and therefore represent raw binary data, I don't advise it
08:41:54 <Eduard_Munteanu> Twey: and don't the first 256 codepoints correspond to plain 8-bit stuff?
08:42:00 <Eduard_Munteanu> Hm.
08:42:01 <Twey> ‚Ä¶ for roughly the same reasons as I don't advise representing it as a hex string
08:42:03 <Twey> Eduard_Munteanu: No
08:42:11 <johnw> there are many different 8-bit encodings
08:42:14 <Twey> The first 128 codepoints are the same as the 128 ASCII characters
08:42:18 <Twey> In UTF-8
08:42:19 <johnw> haha, Twey is ahead of me
08:42:30 <haasn> What do you mean by ‚Äúconvert‚Äù?
08:42:41 <Twey> (I mean, the codepoints are always the same, but the encodings of the codepoints may not be in encodings other than UTF-8)
08:42:42 <Eduard_Munteanu> Twey: I was talking about Char contents, not bytes in particular
08:42:43 <haasn> there are many isomorphisms between Data.ByteString and String, which one do you want?
08:43:23 <Eduard_Munteanu> haasn: the one that makes IO functions write/read that as it is :)
08:43:46 <Twey> Eduard_Munteanu: There is no ‚Äòplain 8-bit stuff‚Äô.  ASCII is pretty standard, but ASCII only goes up to seven bits (the eighth was originally a parity bit) and there are about two or three hundred competing standards for what the other 128 values represent
08:44:08 <Twey> Eduard_Munteanu: Unicode is consistent with Latin-1
08:44:25 <haasn> overloaded ‚Äúas it is‚Äù; ByteString can mean many things. It could mean raw ASCII values, it could mean UTF-8 encoded material, it could mean UTF-32 encoded material
08:44:32 <Twey> That's not only not the only common eight-bit ASCII-based encoding, it's not even the only one for English
08:44:42 <haasn> It could mean SHIFT-JIS encoded bytes
08:45:04 <Eduard_Munteanu> Twey: I mean the 0-255 raw bytes really, not ASCII or anything
08:45:10 <haasn> There's not enough information without context to decide which of these ways is the correct
08:45:18 <haasn> Eduard_Munteanu: do you want to convert ByteString to a list of raw 0-255 bytes?
08:45:36 <haasn> Because that's what unpack :: ByteString -> [Word8] does
08:45:43 <Twey> Eduard_Munteanu: Then I don't understand your question.  Chars 0 through 255 are isomorphic to the numbers 0 through 255, yes.
08:46:21 <Eduard_Munteanu> The actual use case is I read paths from the filesystem and I want to keep them as they are. But many System.* modules don't like bytestrings
08:46:41 <Eduard_Munteanu> So I'm trying to convert to/from String.
08:46:54 <johnw> what do you mean by "convert"?
08:47:00 <Twey> Eduard_Munteanu: If something takes a String then it expects that String to be decoded: you're supposed to have decoded it from the system locale before handing it to them
08:48:06 <Eduard_Munteanu> johnw: basically if I read a path, make it into a Bytestring, convert it back to String, it should be the exact same path
08:48:19 <haasn> Eduard_Munteanu: that's actually worrisome, filesystem paths tend to be ByteStrings, not Strings!
08:48:30 <Twey> haasn: Not on Windows :-\
08:48:45 <Eduard_Munteanu> haasn: exactly, but System.* is annoyingly using String.
08:48:55 <haasn> Submit a bug report for System.* :)
08:49:09 <Eduard_Munteanu> Twey: still, Bytestring is probably the most sensible thing there too
08:49:12 <haasn> alternatively, yes, use the system-wide encoding and hope it's correct
08:49:18 <maskell> are there any real haskell projects?
08:49:26 <Twey> Eduard_Munteanu: Mm, maybe
08:49:28 <Eduard_Munteanu> haasn: er, I don't want to encode/decode at all.
08:49:39 <haasn> Eduard_Munteanu: if System.* doesn't work with ByteString there's no way around it, unfortunately
08:49:49 <Twey> Eduard_Munteanu: I think String is appropriate on Windows
08:49:53 <bartavelle> maskell, yes http://hackage.haskell.org/packages/
08:49:54 <haasn> Eduard_Munteanu: can you provide a specific example of a function you need to use that requires String?
08:49:55 <johnw> Eduard_Munteanu: In your case I would use RawFilePath, and the packages which operate on RawFilePath.  Or, see system-filepath
08:50:08 <Twey> Eduard_Munteanu: (or Text, better)
08:50:16 <Eduard_Munteanu> haasn: doesFileExist, createProcess ...
08:50:24 <johnw> Both of those avoid the requiring of decoding into a String, which is very difficult to do in a cross-platform way
08:50:35 <johnw> Eduard_Munteanu: then see system-filepath and system-fileio
08:50:39 <Twey> Eduard_Munteanu: Windows does things like case-insensitivity, which is locale-dependent and requires you to know the characters
08:51:23 <Eduard_Munteanu> Twey: if I get a path from the filesystem then I don't have to know about encoding at all.
08:51:30 <haasn> I concur with johnw. I did not know those alternatives existed. If a correct alternative exist, use it
08:51:51 <haasn> Eduard_Munteanu: that is correct, it seems like system-filepath and system-fileio will let you avoid encoding
08:51:56 <Twey> Eduard_Munteanu: Maybe.  It rather depends what you want to do with it.
08:51:58 <Eduard_Munteanu> johnw, haasn: any idea of a similar thing for System.Process? Annoyingly it insists on using strings too.
08:52:52 <Eduard_Munteanu> Twey: I think the more reasonable thing is to let fromString or other function decode/encode path literals
08:53:09 <Twey> Eduard_Munteanu: You can't do it purely
08:53:23 <Twey> It's environment-dependent
08:53:41 <johnw> Eduard_Munteanu: Hmm... I'm not finding something for creating a process which doesn't require String...
08:53:44 <Eduard_Munteanu> Twey: you mean it's locale-dependent?
08:53:51 <Twey> Eduard_Munteanu: Specifically, yes
08:54:29 <Eduard_Munteanu> Twey: still, if you get the locale in IO code, you can use that.
08:54:41 <johnw> Eduard_Munteanu: system-filepath does offer you a decodeString function
08:54:42 <haasn> http://hackage.haskell.org/package/unix-2.7.0.0/docs/System-Posix-Process-ByteString.html has some alternatives to System.Process
08:54:49 <Twey> Eduard_Munteanu: Right, but fromString will be a pure function String ‚Üí FilePath
08:54:58 <johnw> "The contents of this string are platform‚Äêdependent, and are not guaranteed to be human‚Äêreadable."
08:55:02 <Eduard_Munteanu> Ah yeah, fromString is likely inappropriate.
08:55:07 <Twey> You need either String ‚Üí IO FilePath or Locale ‚Üí String ‚Üí FilePath
08:55:48 <Eduard_Munteanu> Twey: yeah, I was thinking of the latter... the 'encoding' package seems to go that way, except the locale is an implicit parameter for convenience
08:56:40 <johnw> http://hackage.haskell.org/package/system-filepath-0.4.9/docs/Filesystem-Path-CurrentOS.html#decodeString
08:56:58 <haasn> johnw: ‚Äúplatform-dependent‚Äù shouldn't they be locale dependent as well?
08:57:13 <johnw> well, it also says "Attempt to parse a FilePath from a string suitable for use with functions in System.IO."
08:57:26 <haasn> what happens if I change my locale during the runtime of such a program? Does ‚ÄúdecodeString‚Äù behave impurely?
08:57:27 <johnw> so it should be the most appropriate String for use with createProcess, from that documentation
08:57:31 <haasn> err, encodeString
08:59:37 <johnw> haasn: I don't think your locale affects how the path is encoded on disk, does it?
08:59:47 <Eduard_Munteanu> johnw: system-filepath uses String internally
09:00:39 <johnw> on W
09:00:41 <johnw> indows it does
09:00:43 * hackagebot cereal-plus 0.3.2 - An extended serialization library on top of "cereal"  http://hackage.haskell.org/package/cereal-plus-0.3.2 (NikitaVolkov)
09:00:47 <johnw> on other operating systems it uses different types
09:00:56 <johnw> on Linux or OS X it uses ByteString
09:01:00 <johnw> (I never remember which)
09:01:19 <Eduard_Munteanu> I'm writing my own filepath stuff.
09:01:45 <Eduard_Munteanu> With a richer type.
09:01:51 <johnw> yes, on Linux it's ByteString, on Windows and OS X it's Text
09:02:14 <johnw> really?  you want to roll your own?
09:03:24 <Eduard_Munteanu> johnw: yeah, system-filepath and base's FilePaths are obnoxious. I want to get type-safe paths.
09:03:40 <johnw> why is system-filepath obnoxious?
09:03:42 <Eduard_Munteanu> Also disallowing '/' and relative paths.
09:04:15 <supki> johnw: wait, does system-filepath really use different types in API for different platforms?
09:04:21 <johnw> yes, it does
09:04:27 <johnw> it uses internally whatever is native to each platform
09:04:43 <supki> ..are you supposed to write client code with #ifdefs then?
09:04:53 <Eduard_Munteanu> johnw: they're rather unsafe, especially for scripting purposes. Also try this...   head (splitDirectories "/foo/bar") == "/"   (it yields False)  :)
09:05:40 <Eduard_Munteanu> johnw: I want to make sure you can only copy from a source-tagged to a destination-tagged directories, such that you don't do it in reverse, for example
09:06:25 <Eduard_Munteanu> Also no more . and .. and / and other stuff.
09:06:57 <haasn> johnw: you're correct in that locale is irrelevant from how the path is on-disk (except for the case where you do something like ‚Äútouch ‚òÉ‚Äù, but in this case I think it's actually the terminal emulator that decides how to send ‚òÉ to the shell in the first place, and from there on it's all just bytes); however doesn't all of the Haskell Prelude involving FilePath=String use the system locale to go
09:06:59 <haasn> to/from String?
09:07:15 <haasn> Same as we used the system locale for String-based I/O
09:08:09 <Eduard_Munteanu> BTW, isn't Data.ByteString.Char8 morally wrong for this purpose?
09:08:42 <Eduard_Munteanu> Since I'm holding raw data, not 8-bit chars.
09:08:53 <haasn> Eduard_Munteanu: correct! That will *not* work
09:08:58 <haasn> it will most likely break
09:09:07 <haasn> I ran this experiment, for example:
09:09:17 <haasn> cd /mem; touch ‚òÉ; ghci
09:09:30 <haasn> getDirectoryContents "/mem" gives me [".","..","\9731"]
09:09:37 <haasn> And doesFileExist "/mem/9731" returns True
09:09:42 <prophile> touching snowmen is the moral wrong here
09:09:43 <haasn> "/mem/\9731" I mean
09:09:44 <Eduard_Munteanu> Ouch.
09:09:53 <haasn> My system locale is UTF-8
09:10:44 * hackagebot generic-maybe 0.3.0.4 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.3.0.4 (JonathanFischoff)
09:10:49 <haasn> the UTF-8 encoding of ‚òÉ is [226,152,131] (as obtained from Data.ByteString.UTF8)
09:11:17 <haasn> Which .Char8 gives me back as the string "\226\152\131"
09:11:28 <haasn> doesFileExist "/mem/\226\152\131" => False
09:11:34 <joelteon> yeah, that's the string
09:11:35 <joelteon> uh
09:11:54 <HugoDaniel> :)
09:11:57 <haasn> Eduard_Munteanu: so you do *never* want to use .Char8 especially seeing as modern platforms are almost all UTF-8
09:12:01 <joelteon> well, the last two aren't printable (I think?) so it's an a with a caret
09:12:02 <geekosaur> hrrrm
09:12:24 <geekosaur> you do realize that (if you're lucky) "/mem/\226\152\131" is what is actually in the filesystem?
09:12:26 <Eduard_Munteanu> :t map chr . BS.unpack
09:12:27 <lambdabot>     Couldn't match type `Word8' with `Int'
09:12:27 <geekosaur> on posix
09:12:27 <lambdabot>     Expected type: BSC.ByteString -> [Int]
09:12:27 <lambdabot>       Actual type: BSC.ByteString -> [Word8]
09:12:47 <Eduard_Munteanu> :t map (chr . fromIntegral) . BS.unpack
09:12:48 <lambdabot> BSC.ByteString -> [Char]
09:13:20 <geekosaur> the haskell runtime is telling a bunch of lies here and this actually opens the potential for security holes or unexpected behavior (consider a file named with a non-normalized grapheme)
09:14:45 <geekosaur> gtk+ tries to push the false idea that posix filesystems are unicode compliant, and this means if you open a file with a non-normalized grapheme and then save it it will be saved with the normalized codepoints, sitting next to the original
09:14:58 <geekosaur> then good luck distinguishing those two in a file chooser or ls output
09:15:08 <Eduard_Munteanu> Heh.
09:15:37 <dwcook> One of those times a graphical file manager can come in handy
09:16:01 <geekosaur> you failed to understand
09:16:18 <geekosaur> the gui file manager will show you two files with "the same name"
09:16:31 <dwcook> No, I do understand. But they're distinguished by position rather than by what you must type
09:16:45 <geekosaur> again you hope
09:17:15 <geekosaur> since at some point it builds a filename to pass to open(), and if you're unlucky it normalizes so opening the non-normalized one actually gets you the normalized one
09:17:36 <dwcook> Oh, fun
09:18:14 <colDrMcBeardman> you would have thought that the GNU/Linux folks would have changed things now that we can afford 16 bits per character.
09:18:40 <colDrMcBeardman> then you'd realize they're all writing in C and how much of a PITA it is not to make everything a char*
09:19:06 <geekosaur> they are not yet so insane as to think they can rewire the entire VFS interface and all file-manipulating syscalls to force normalization everywhere (note that to work reliably the normalization has to be enforced by the filesystem code)
09:19:19 <geekosaur> new non-POSIX APIs needed all over the place
09:19:53 <colDrMcBeardman> geekosaur, if things weren't already terribly complicated, switching to UTF8 would be rather trivial
09:20:10 <colDrMcBeardman> but we have to be compatible all the way back to VAXen and the dawn of time, so.
09:20:54 <geekosaur> you mean if "gnu/linux" were the only os anyone used anywhere
09:21:00 <geekosaur> I have freebsd and smartos
09:21:09 <colDrMcBeardman> and don't forget darwin and win32
09:21:27 <colDrMcBeardman> all of which have more syscalls than they should
09:21:33 <geekosaur> (and yes os x has most of the same pretends-to-be-unicode-and-fails problems)
09:22:09 <stelleg> @src printf
09:22:09 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:22:23 <stelleg> @src Text.printf
09:22:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:22:25 <geekosaur> and windows tries to deal with it but fails because it's mutant and broken utf16, so the same problems come back when you start using codepoints outside of 16 bits
09:23:56 <colDrMcBeardman> geekosaur, i don't understand why it is seemingly so difficult to have width-extensible unicode support.
09:24:07 <colDrMcBeardman> does the standard make it difficult?
09:24:38 <geekosaur> no, lazy implementers make it difficult
09:25:02 <geekosaur> windows had the chance to get this right and botched it (as did java in pretty much the same way, I'm given to understand)
09:25:10 <colDrMcBeardman> I would have thought that it would be as simple as having a magic value for every byte that says, check the next byte for codepoint in next-highest range.
09:25:42 <pvt_petey> So Eduard_Muneanu all a0+a1 does is accumulate everything from the statement ? Each time it executes you accumulate an a0 ?
09:25:44 <geekosaur> you have more or less described utf8. you have not addressed normalization
09:25:59 <colDrMcBeardman> geekosaur, by which you mean?
09:26:06 <pvt_petey> *Eduard_Munteanu
09:26:22 <colDrMcBeardman> going from >8 bytes to chars?
09:26:37 <geekosaur> no
09:26:52 <Sculptor> ucs hell
09:27:00 <geekosaur> consider √º
09:27:24 <geekosaur> there are two ways to encode this *as unicode codepoints*, before you even consider how to encode those as bytes
09:27:35 <colDrMcBeardman> oh, you mean the fact that there's duplication
09:27:36 <pjdelport> colDrMcBeardman: https://en.wikipedia.org/wiki/Unicode_equivalence
09:27:49 <Eduard_Munteanu> pvt_petey: unfold the definition like I did, should be obvious
09:28:23 <geekosaur> U+00FC and U+0075 + U+0308
09:28:56 <colDrMcBeardman> ah. that's something i don't think is any of unicode's business.
09:29:08 <pvt_petey> hmm it was so long ago I can't see it in the chat history
09:29:18 <pvt_petey> if I recall correctly:
09:29:30 <colDrMcBeardman> either make everything combining chars, or don't. you can't mix. that's just opening up security holes.
09:29:43 <geekosaur> so there's a whole section of the unicode standard defining various kinds of normal forms. and then there is the fact that utf8 technically allows various characters to be encoded in multiple ways, which was resolved by fiat by declaring particular encodings to be canonical and the others illegal
09:29:46 <dwcook> pvt_petey, logs are available in the topic
09:30:01 <pjdelport> colDrMcBeardman: that's entirely Unicode's business: Unicode defines how to normalize them
09:30:18 <geekosaur> colDrMcBeardman, you're welcome to fight that one again with the Unicode Consortium. I suspect they will ignore you as they have already made their decision
09:30:28 <geekosaur> it is made, implementers must deal
09:30:46 <colDrMcBeardman> geekosaur, naturally. all bugs must be supported once you have users.
09:31:56 <geekosaur> anyway yes, Unicode sucks in many many ways. but we have to live with it :(
09:32:02 <mtiaji> :t !!
09:32:03 <lambdabot> parse error on input `!!'
09:32:07 <geekosaur> :t (!!)
09:32:08 <lambdabot> [a] -> Int -> a
09:32:31 <mtiaji> geekosaur: Thanks
09:32:47 <mreh> Haskell could have made (!!) 1 based and saved millions of keystrokes around the world
09:32:56 <mreh> why?????
09:32:59 <[swift]_> does anyone know if there's a data type on the Haskell side that can easily be marshalled to an array of strings (char** + length) on the C side?
09:33:11 <geekosaur> does anyone except fortran and msbasic use 1-based any more?
09:33:13 <ystael> mreh: because the natural numbers are the free commutative monoid on one generator
09:33:32 <mreh> :)
09:33:42 <mreh> I'll take your word for it
09:34:13 <mreh> [swift]_ Haskell as pointers
09:34:16 <mreh> has*
09:35:07 <mreh> from what I can remember from when I was marshalling stuff into C code
09:36:05 <[swift]_> mreh: well, i have a working solution now that walks a Haskell-side [String] and converts and allocates each of the strings as CStrings, then creates malloc'd buffer with pointers to each string
09:36:21 <[swift]_> mreh: however, it's a bit ugly, and i don't think it's especially efficient
09:36:25 <Eduard_Munteanu> [swift]_: yse bytestring
09:36:31 <geekosaur> but the straightforward answer to why it's not 1-based is that Haskell will generally take the natural mathematical form, and that happens to be 0-based.
09:36:39 <Eduard_Munteanu> @hoogle useAsCString
09:36:40 <lambdabot> Data.ByteString useAsCString :: ByteString -> (CString -> IO a) -> IO a
09:36:40 <lambdabot> Data.ByteString.Char8 useAsCString :: ByteString -> (CString -> IO a) -> IO a
09:36:41 <lambdabot> Data.ByteString useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
09:36:46 <Eduard_Munteanu> [swift]_: ^^
09:36:55 <[swift]_> mreh: since this is used in a function that will be called very frequently, i'd prefer to find a solution where the data can be kept on the haskell side in a format that is usable, but where marshalling is cheaper
09:36:56 <mreh> interesting you use the word natural
09:37:02 <mreh> and 0 isn't a natural number
09:37:36 <mreh> [swift]_ see what Eduard_Munteanu said
09:37:36 <jophish> Yo yo yo
09:37:37 <geekosaur> (this is pretty much why everyone else does it as well, but the constraining factor they use is that that's what the CPU does natively and it's the CPU that is using the mathematical one because it's easier and faster to implement)
09:37:54 <jophish> The link to the video here is broken: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
09:38:03 <jophish> Is there anywhere else I can find it?
09:38:04 <colDrMcBeardman> mreh, some people do include 0 in N
09:38:29 <colDrMcBeardman> http://mathworld.wolfram.com/NaturalNumber.html
09:38:33 <colDrMcBeardman> it's dreadfully confusing.
09:38:35 <[swift]_> Eduard_Munteanu: hmm, that seems extremely straightforward for each individual string. is there a clever solution for the outer array, or is there no better option than recreating it every time i need to marshall?
09:38:51 <geekosaur> "natural" has many meanings, "natural numbers" and "natural mathematical formulation" only relate if the mathematical formulation in question is *about* the natural numbers
09:39:00 <pjdelport> Erlang, Lua, and Julia use 1-based indexing
09:39:08 <geekosaur> sorry for english using the same word in a billion different ways
09:39:14 <jophish> I'd consider 0 a natural number
09:39:38 <mreh> most people don't though
09:39:41 <mreh> anyway
09:39:52 <colDrMcBeardman> geekosaur, but mathematicians have used "natural numbers" to mean both "non-negative ints" and "positive ints"
09:39:52 <ski> `0' is pretty natural as an answer to "how many ?"
09:39:53 <mreh> it always seemed more intuitive to me for it to be 1 based
09:39:57 <colDrMcBeardman> mreh, halmos did.
09:40:13 <mreh> but I'm sure mathematicians might have more insight than most
09:40:16 <jophish> I've always seen N representing [0..] and N+ the positive natural numbers = [1..
09:40:35 <colDrMcBeardman> mreh, without zero, addition has no identity, which to some i suppose seems unnatural.
09:40:47 * hackagebot optimization 0.1.4 - Numerical optimization  http://hackage.haskell.org/package/optimization-0.1.4 (BenGamari)
09:40:48 <ski> "Why numbering should start at zero" by Edsger Wybe Dijkstra in 1982-08-11 at <https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html>
09:40:56 <mreh> haha
09:41:07 * mreh kneels
09:41:14 <colDrMcBeardman> oh, i didn't even notice that pun. genius.
09:42:01 <geekosaur> (and why are you still projecting your worry about natural numbers onto what I said)
09:42:13 <notdan> which pun :(
09:42:19 <geekosaur> if I'd meant \bbb{N} I'd have said that...
09:42:57 <skypers> hm
09:43:29 <colDrMcBeardman> notdan, talking about natural numbers and i said some people find (+) without 0 "unnatural"
09:43:30 <skypers> @let type MonadFailure m = (MonadError String m, MonadWriter String m)
09:43:31 <lambdabot>  .L.hs:143:1:
09:43:31 <lambdabot>      Illegal constraint synonym of kind: `Constraint'
09:43:31 <lambdabot>        (Use -XConstraintKinds to permit this)
09:43:31 <lambdabot>      In the type declaration for `MonadFailure'
09:43:41 <skypers> @let set -XConstraintKinds
09:43:41 <lambdabot>  Parse failed: TemplateHaskell is not enabled
09:43:45 <skypers> dammit :(
09:44:01 <skypers> I have an issue with ConstraintKinds
09:44:03 <geekosaur> wouldn't you have to use a pragma, not set?
09:44:10 <colDrMcBeardman> geekosaur, because there isn't even agreement on what \bbb{N} contains?
09:44:13 <skypers> considering the MonadFailure just above
09:44:14 <notdan> colDrMcBeardman: ah
09:44:24 <skypers> I can‚Äôt derive it with GeneralizedNewtypeDeriving
09:44:26 <skypers> any clue?
09:44:33 <geekosaur> siiiigh. fine, the sole topic is natural numbers and I said something that was not related to anything before
09:44:42 <bennofs> Is there a monad similar to the IO monad but only allowing MVar / STM / IORef operations (memory operations) ?
09:44:51 <dagle> Hmm. Cabal noob here. Installed http-conduit but when I want to import it can't find Network.HTTP.Conduit and ghc-pkg list lists it.
09:44:54 <Eduard_Munteanu> bennofs: STM
09:45:02 <notdan> bennofs: STM allows only stm operations
09:45:11 <notdan> bennofs: also you might want to take a look at the ST monad
09:45:28 <notdan> you can't operate IORefs/MVars in it, but you can use STVars
09:45:31 <geekosaur> I'll try to notice next time someone decides the only conceivable interpretation of the word "natural" is with respect to natural numbers
09:45:33 <ski> `MVar' isn't much use without concurrency
09:45:42 <Eduard_Munteanu> STRef
09:45:56 <skypers> do I guess correctly if I say we can‚Äôt derive more than one stuff at the same time?
09:46:01 <notdan> erm, yes STRef
09:46:38 <Eduard_Munteanu> skypers: derive classes? No.
09:46:50 <skypers> newtype ‚Ä¶ deriving (MonadError String, MonadWriter String) works perfectly whereas newtype ‚Ä¶ deriving (MonadFailure) with type MonadFailure m = (MonadError String m, MonadWriter String m)
09:46:56 <skypers> Eduard_Munteanu: what a pity
09:48:04 <Eduard_Munteanu> skypers: deriving expects a class, not an arbitrary constraint
09:48:25 <supki> dagle: what's "it" in "it can't find"?
09:48:44 <skypers> Eduard_Munteanu: well here there‚Äôre just two classes
09:49:15 <skypers> I‚Äôm actually experiencing the issue of designing my whole lib only with Monad* typeclasses
09:49:17 <Eduard_Munteanu> skypers: that's a constraint, not two classes
09:49:25 <skypers> and let the structure being defined later
09:50:02 <Eduard_Munteanu> skypers: why that newtype? What does it represent?
09:50:09 <skypers> well
09:50:28 <skypers> I have a lot of functions (stateful computations, computations that need logging, computations that need both)
09:50:45 <skypers> I use MonadWriter and MonadError for the interface
09:50:56 <skypers> then I have to write my own monad to use those functions
09:51:20 <skypers> do you understand ?
09:51:33 <pvt_petey> another question : how does it know to stop at fib 1?
09:51:39 <Eduard_Munteanu> skypers: do you want to hide MonadReader and MonadWriter?
09:51:49 <skypers> I already hide them
09:51:56 <skypers> I have a type for that
09:51:59 <skypers> in my lib
09:52:09 <pvt_petey> I'm still a bit confused even after looking at how it's unpacked, in truth
09:52:18 <Eduard_Munteanu> pvt_petey: it doesn't recurse anymore, look at the right-hand-side of the definition
09:52:22 <ski> pvt_petey : because of `fib 1 a0 a1 = a0' ?
09:52:30 <skypers> for instance
09:52:33 <mreh> > [1..10]
09:52:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:52:36 <skypers> I have a type for errors, SkyError
09:52:45 <skypers> then, MonadFailure is just MonadError SkyError
09:53:12 <Eduard_Munteanu> skypers: that's not quite hiding, though, said function can still use them
09:53:22 <pvt_petey> and that means until you reach a0 decrement ?
09:53:25 <skypers> yeah, it‚Äôs more like aliasing
09:53:47 <skypers> I just state
09:53:50 <Eduard_Munteanu> skypers: anyway... why not just runReaderT and runWriterT? You don't really need a separate monad.
09:54:05 <skypers> ‚ÄúOk, my functions need MonadError SkyError, which is MonadFailure‚Äù
09:54:23 <skypers> Eduard_Munteanu: sure, I do that for a function like
09:54:23 <skypers> wait
09:54:28 <skypers> I‚Äôm gonna show you, quite simple
09:54:51 <Eduard_Munteanu> skypers: foo :: (MonadFailure m) => ... -> m ()   ?
09:55:19 <skypers> Eduard_Munteanu: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Utils/CLIScanner.hs#L55
09:55:26 <skypers> see the cliScan function
09:55:28 <skypers> it‚Äôs quite simple
09:55:30 <dagle> supki: ghci/ghc.
09:55:38 <skypers> and I call it with runWriterT
09:55:42 <skypers> it‚Äôs very nice to use
09:55:52 <skypers> now, when things get complex
09:56:06 <Eduard_Munteanu> skypers: ok, why not do the same above?
09:56:11 <skypers> https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Scene/Resource.hs#L226
09:56:12 <dagle> supki: Even "ghc-pkg field http-conduit exposed-modules" lists the module but I can't import it.
09:56:25 <skypers> how should I run that without a newtype and a special monad like ResourceLoading?
09:57:28 <skypers> MonadResource is MonadState ResourceManager and MonadLogger, which is MonadWriter LogQueue
09:57:46 <skypers> I‚Äôm currently implementing such a monad with RWST + EitherT, but that‚Äôs quite painful
09:58:30 <Eduard_Munteanu> skypers: er, have you tried just chaining runStateT, runWriterT and so on?
09:58:39 <skypers> I think it won‚Äôt work
09:58:42 <skypers> because of lifting
09:59:06 <pvt_petey> Why is it n+2 on the lhs and n+1 on the rhs? I thought the fibonacci sequence was normally calculated with n-1 and n-2 ?
09:59:07 <skypers> :t runWriter . runEitherT
09:59:08 <lambdabot>     Not in scope: `runEitherT'
09:59:08 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
09:59:13 <skypers> :t runWriter . runReader
09:59:14 <lambdabot>     Couldn't match type `r0 -> a1' with `WriterT w0 Identity a0'
09:59:14 <lambdabot>     Expected type: Reader r0 a1 -> Writer w0 a0
09:59:14 <lambdabot>       Actual type: Reader r0 a1 -> r0 -> a1
09:59:21 <skypers> :t runWriterT . runReaderT
09:59:22 <lambdabot>     Couldn't match type `r0 -> m1 a1' with `WriterT w0 m0 a0'
09:59:22 <lambdabot>     Expected type: ReaderT r0 m1 a1 -> WriterT w0 m0 a0
09:59:22 <lambdabot>       Actual type: ReaderT r0 m1 a1 -> r0 -> m1 a1
09:59:54 <Eduard_Munteanu> :t runWriterT . (`runStateT` ?r)
09:59:55 <lambdabot> (?r::s) => StateT s (WriterT w m) a -> m ((a, s), w)
10:00:13 <Eduard_Munteanu> skypers: there's no lifting involved
10:00:24 <Eduard_Munteanu> Not explicitly.
10:00:29 <skypers> Eduard_Munteanu: hm
10:00:35 <skypers> so you think with that
10:00:51 <skypers> I automatically derive both the typeclasses?
10:00:54 <skypers> I‚Äôm not really sure
10:01:18 <Eduard_Munteanu> skypers: er, no, there's nothing to derive
10:01:24 <skypers> Eduard_Munteanu: I mean
10:01:35 <skypers> that yields a type, you agree?
10:01:48 <Eduard_Munteanu> skypers: no
10:02:08 <skypers> what‚Äôs the type of that?
10:02:36 <skypers> does this it conform to MonadWriter AND MonadState?
10:02:39 <skypers> I‚Äôm not sure
10:02:44 <skypers> -it
10:03:21 <Eduard_Munteanu> skypers: the above? The argument can be generalized to   (MonadState s m, MonadWriter w m) => m a
10:03:39 <skypers> Eduard_Munteanu: huh?
10:03:46 <skypers> why do we need lifting then?
10:03:53 <Eduard_Munteanu> skypers: you don't :)
10:04:01 <dagle> Sometimes I wonder if the haskell toolchain is NP-hard. :/
10:04:48 <Eduard_Munteanu> > runWriterT . (`runStateT` 1) . runIdentityT $ do { modify (+1); tell =<< get }
10:04:49 <lambdabot>  Not in scope: `runIdentityT'
10:04:49 <lambdabot>  Perhaps you meant `runIdentity' (imported from Control.Monad.Identity)
10:04:57 <Eduard_Munteanu> > runWriterT . (`runStateT` 1) . runIdentity $ do { modify (+1); tell =<< get }
10:04:58 <lambdabot>  Couldn't match type `()'
10:04:58 <lambdabot>                with `Control.Monad.Trans.State.Lazy.StateT
10:04:59 <lambdabot>                        s0 (Control.Monad.Trans.Writer.Lazy.WriterT w0 m0) a0'
10:04:59 <lambdabot>  Expected type: s1
10:04:59 <lambdabot>                 -> Data.Functor.Identity.Identity
10:05:05 <Eduard_Munteanu> Bleh.
10:05:25 <Eduard_Munteanu> > runWriterT . (`runStateT` 1) . runIdentity $ do { modify (+1); tell . (:[]) =<< get }
10:05:26 <lambdabot>  Couldn't match type `()'
10:05:26 <lambdabot>                with `Control.Monad.Trans.State.Lazy.StateT
10:05:26 <lambdabot>                        s0 (Control.Monad.Trans.Writer.Lazy.WriterT w0 m0) a0'
10:05:26 <lambdabot>  Expected type: [s1]
10:05:26 <lambdabot>                 -> Data.Functor.Identity.Identity
10:06:29 <jfischoff> if I have: ffi_foo ptr >>= \x -> return (x, ptr)
10:07:15 <Eduard_Munteanu> > runIdentity . runWriterT . (`runStateT` 1) $ do { modify (+1); tell . (:[]) =<< get }
10:07:16 <lambdabot>  (((),2),[2])
10:07:20 <Eduard_Munteanu> skypers: ^^
10:07:27 <skypers> how is it possible?
10:07:43 <supki> dagle: I can't imagine what can go wrong. Could you post your code, command you run, and the error message?
10:07:47 <jfischoff> where ptr is being modified in the foriegn function foo, am I assured that evaluate the result will execute foo_ffi before ptr
10:08:01 <Eduard_Munteanu> skypers: there are extra instances like...
10:08:05 <jfischoff> or is it possible to see ptr as a garbage value?
10:08:25 <Eduard_Munteanu> skypers: instance (MonadState s m) => MonadState s (t m)
10:08:35 <skypers> I see‚Ä¶
10:08:44 <Eduard_Munteanu> Er, where 't' is a specific transformer, not the variable.
10:08:46 <skypers> this will help me a lot then!
10:08:55 <skypers> thank you :)
10:08:59 <Eduard_Munteanu> skypers: http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-State-Class.html#t:MonadState
10:09:07 <Eduard_Munteanu> skypers: look at the instances
10:09:14 <c_wraith> jfischoff: Err.  ptr is of type Ptr?
10:09:31 <skypers> Monad m => MonadState s (StateT s m)
10:09:35 <jfischoff> eyah
10:09:43 <skypers> why are there two occurences for that?
10:10:06 <skypers> oh
10:10:11 <skypers> Lazy and Strict
10:10:12 <c_wraith> jfischoff: I'm not completely sure what your worry is - concurrent view of an incomplete value, or premature garbage collection?
10:10:12 <skypers> ok
10:10:46 <skypers> I suppose it‚Äôs the same thing for EitherT?
10:10:54 <skypers> like
10:11:26 <jfischoff> I worried that if I had called snd on the returned tuple, it might for the execution of the first part of the tuple, which would mean that the ptr would be garbage
10:11:32 <skypers> instance (MonadError e m) => MonadError e (EitherT e)
10:11:35 <skypers> or something like that
10:11:46 <jfischoff> s/it might for/it might not force
10:11:53 <Eduard_Munteanu> skypers: likely, haven't checked... there's also ErrorT in standard libs
10:12:03 <skypers> ok
10:12:05 <Eduard_Munteanu> @src ErrorT
10:12:05 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
10:12:06 <skypers> runErrorT, ok
10:12:16 <skypers> great
10:12:29 <Eduard_Munteanu> skypers: though ErrorT sort of imposes additional constraints, vs EitherT
10:12:35 <skypers> the more I‚Äôm digging in typeclasses along with transformers, the more I feel amazed
10:12:46 <skypers> Eduard_Munteanu: yeah, I don‚Äôt like ErrorT
10:12:53 <skypers> the Error constraint is just stupid
10:13:15 <c_wraith> jfischoff: you've been corrupted by lazy IO.  unless ffi_foo calls unsafeInterleaveIO somehow, that's not something that can happen.  The ffi call will complete before >>= passes control to its right argument
10:13:16 <x12> https://www.youtube.com/watch?v=G7hE0c2rD54
10:13:29 <Eduard_Munteanu> skypers: note you still need to liftIO for IO, by default. You can add a MonadIO constraint for 'm' though, then it's not needed.
10:13:41 <jfischoff> okay cool
10:14:20 <c_wraith> jfischoff: (that's an easy way to get mixed up, by the way.  I was mixed up about that for about 4 weeks as I started to really think about the rules of IO carefully)
10:15:11 <jfischoff> c_wraith: I would say I am still mixed up, its not something I deal with much :s
10:15:49 <c_wraith> jfischoff: just remember that the only time laziness wrt to IO effects happens is when unsafeInterleaveIO is involved
10:16:04 * jfischoff nods
10:16:12 <c_wraith> ...  "wrt to".  good job, me.
10:16:30 <colDrMcBeardman> c_wraith, atm machine?
10:16:33 <colDrMcBeardman> pin number?
10:17:04 <tomejaguar> Does lazy IO break referential transparancy?
10:17:25 <notdan> no
10:18:02 <jfischoff> tomejaguar: I think you have to abuse handles or something
10:18:33 <tomejaguar> But can't it cause IO operations to happen dependent upon whether a supposedly pure value is forced or not?
10:18:58 <jfischoff> yeah but that is different
10:19:10 <dagle> supki: What command? To install? cabal install http-conduit
10:19:23 <tomejaguar> Isn't that a violation of referential transparancy?
10:19:29 <johnw> haasn: Maybe you're right, I'm not really sure as far as System.IO goes
10:19:58 <notdan> tomejaguar: hm, can you provide an example?
10:20:09 <notdan> You can't produce a pure value from an IO valeu
10:20:20 <notdan> unless you are using `unsafePerformIO` or something similar
10:20:34 <Kaidelong> tomejaugar: IO is not referentially transparent
10:20:36 <shachaf> "something similar" like unsafeInterleaveIO, which lazy I/O is based on?
10:20:47 <Kaidelong> when you're in IO references can be distinguished from values
10:20:52 * hackagebot chunked-data 0.1.0.0 - Typeclasses for dealing with various chunked data representations  http://hackage.haskell.org/package/chunked-data-0.1.0.0 (MichaelSnoyman)
10:20:54 * hackagebot classy-prelude 0.8.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.0 (MichaelSnoyman)
10:20:56 * hackagebot classy-prelude-conduit 0.8.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.8.0 (MichaelSnoyman)
10:20:58 * hackagebot classy-prelude-yesod 0.8.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.8.0 (MichaelSnoyman)
10:21:00 * hackagebot conduit-combinators 0.1.0.0 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.1.0.0 (MichaelSnoyman)
10:21:05 <shachaf> tomejaguar: I don't know if there's a precise meaning to "referential transparency".
10:21:11 <tomejaguar> Ah well that's a good point.
10:21:21 <johnw> shachaf: I thought there was
10:21:25 <shachaf> Lazy I/O certainly causes problems.
10:21:44 <notdan> shachaf: is lazy I/O == unsafeInterleaveIO?
10:21:54 <Kaidelong> as far as I knew all "referentially transparent" really means is that foo, *foo, **foo, etc are all the same thing
10:22:02 <notdan> I thought that lazy I/O is just "regular" Haskell IO, without tricks like iteratees and stuff
10:22:06 <tomejaguar> But if you do 'getContents' and pass the resulting to a pure function 'f', the file that 'getContents' was run on may be read or not depending on whether 'f' forces the string.
10:22:07 <johnw> from what I've read, a function is said to be referentially transparent if, within the body of that function, you can replace sub-expressions with the results of their evaluation and not change the meaning of that function
10:22:17 <notdan> but if it means using function that starts wqith the word "unsafe" then I am not sure
10:22:23 <tomejaguar> Oh no lazy IO is much more naughty than that.
10:22:30 <Kaidelong> although to make things referentially transparent you really have to be pure
10:22:33 <johnw> lazy I/O is one of the few things that breaks this
10:22:55 <Kaidelong> regular IO breaks it too
10:23:01 <Eduard_Munteanu> notdan: yes, it uses unsafeInterleaveIO
10:23:04 <johnw> regular IO evaluates to IO actions
10:23:09 <prophile> regular IO doesn't break referential transparency
10:23:12 <nadirs> johnw, Kaidelong: though someone would say IO is pure :P
10:23:13 <prophile> that's sort of the point
10:23:16 <johnw> execution is another matter
10:23:29 <colDrMcBeardman> tomejaguar, I would think that since if you read a file, and applied a function to the contents and then did so again a little while later, in the meantime the file contents could change, then referential transparency is gone.
10:23:58 <notdan> Referential transparency is when we can replace 't' in a expression 'e' with let x = t in [t/x]e
10:23:59 <haasn> geekosaur: \226\152\131 is nowhere near \9731 though, the latter gets encoded using [195,162,194,152,194,131] in UTF-8; I'm not sure what relevance this has
10:24:08 <allsystemsarego> Hi all, I can't wrap my head around this space leak: http://lpaste.net/99867 - I've tried several approaches, including a few suggested by Twey, quchen and quicksilver. In this latest one I'm using the IO monad. Any suggestions are appreciated.
10:24:26 <Eduard_Munteanu> You can already get nasty effects like hGetContents getting tripped by hClose.
10:24:30 <joelteon> haasn: \226\152\131 is utf-8 encoded \9731
10:24:35 <nadirs> colDrMcBeardman: I think the ref. transparency is save because since the IO monad is different, it's as if the argument of a function is different
10:24:58 <tomejaguar> Lazy IO is where an IO action returns a supposedly pure value, but evaluating the pure value runs the IO actions that are required to produce it.
10:24:58 <haasn> joelteon: if by \226\152\131 you mean [226,152,131] which is nowhere near the same thing, yes
10:25:11 <joelteon> yeah
10:25:14 <prophile> colDrMcBeardman: think of IO a as Universe -> (a, Universe)
10:25:17 <geekosaur> wat
10:25:19 <joelteon> \226\152\131 is what bytestring-char8 produces
10:25:32 <haasn> yeah, and .char8 is broken beyond help
10:25:37 <joelteon> why does it exist?
10:25:58 <haasn> I don't know. The only times I've seen it have been when spending hours debugging encoding issues
10:25:58 <Kaidelong> prophile: if you say that IO doesn't break referential transparency then lazy IO wouldn't either though, the *meaning of the programs* are still constant in both cases
10:26:02 * hackagebot mono-traversable 0.3.0.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.3.0.0 (MichaelSnoyman)
10:26:10 <geekosaur> haasn: so how do you propose to represent \9731 in octets, since you apparently have decided [226,152,131] can't possibly be it?
10:26:12 <skypers> I think I got what listen is for
10:26:16 <skypers> :t listen
10:26:17 <lambdabot> MonadWriter w m => m a -> m (a, w)
10:26:22 <skypers> yeah
10:26:25 <prophile> Kaidelong: lazy IO is cheaty and cruel, though :)
10:26:27 <skypers> that‚Äôs quite interesting
10:26:27 <geekosaur> hint, \9731 is too big to fit in an octet
10:26:28 <Kaidelong> prophile: if you "dereference" values in IO you can change the behavior of functions inside IO
10:26:33 <haasn> geekosaur: with UTF8? [226,152,131]
10:26:35 <johnw> with lazy I/O, where x and y represent lazy IO actions, x == y might not be substitutable with y == x without changing the meaning of the program, whereas ordinarily one can depend on the equality of x == y with y == x
10:26:40 <Kaidelong> using say unsafePerformIO
10:26:51 <geekosaur> haasn: then I have no idea what you are trying to ask
10:26:57 <prophile> as soon as the word "unsafe" appears, all bets are off
10:27:01 <tomejaguar> colDrMcBeardman: Lazy IO is something quite different to that.
10:27:06 <geekosaur> maybe you need to sit down with a unicode reference...
10:27:13 <haasn> geekosaur: my point is that [226,152,131] and "\226\152\131" are not to be confused with one another
10:27:19 <haasn> because they are not the same thing nor will they ever be
10:27:29 <skypers> > runWriter . listen $ tell "hello, this is dawg" >> return 3
10:27:30 <lambdabot>  ((3,"hello, this is dawg"),"hello, this is dawg")
10:27:33 <tomejaguar> allsystemsarego: Are you sure it's not just overflowing Int?
10:27:36 <Eduard_Munteanu> allsystemsarego: that's essentially a non-strict foldl
10:27:42 <haasn> (unless you ask .Char8)
10:27:44 <skypers> arg, it injects it the parent monad
10:28:07 <skypers> is there the same function but that justs ‚Äúsees‚Äù the monoid and doesn‚Äôt mappend it?
10:28:08 <allsystemsarego> tomejaguar, I'm not usre
10:28:25 <skypers> it might just be (Monoid w) => State w, but just to know
10:28:27 <geekosaur> haasn: or unless you are using String to access an octet encoding like POSIX filepaths, and yes that is completely broken and why I pushed so hard for the .ByteString interfaces to be added
10:28:27 <Eduard_Munteanu> allsystemsarego: I think adding some strictness would help
10:28:32 <Kaidelong> johnw: == works on pure values, it's commutative
10:28:33 <allsystemsarego> Eduard_Munteanu, so the solution is to use foldM then?
10:28:42 <shergill> so template haskell currently doesn't allow you to generate annotations, correct? are there any other limitations people know off the top of their head?
10:29:00 <johnw> Kaidelong: but not if those values are actually from lazy I/O
10:29:01 <geekosaur> because paths (and envars and parameters and several other things) are natively ByteString in POSIX
10:29:07 <Kaidelong> johnw: what you might mean is that { y <- f() ; x <- g() } may work differently from { x <- g() ; y <- f() }
10:29:10 <tomejaguar> allsystemsarego: Best not to involve IO.  I doubt very much that helps.
10:29:14 <Kaidelong> but this is true of ANY IO
10:29:15 <Eduard_Munteanu> allsystemsarego: more like doing    b `seq` get_result input n (a, b)
10:29:22 <haasn> geekosaur: depends on your system locale, though; in my locale (UTF8) I get "\9731" when accessing what is [226,152,131] on the hard drive
10:29:27 <Eduard_Munteanu> allsystemsarego: or a bang pattern on 'b'
10:29:29 <skypers> if I run an application in runWriterT and use a forever function inside to daemonize, will I eventually run out of memory because of the monoid?
10:29:31 <Kaidelong> not just lazy IO
10:29:34 <johnw> no, I mean x == y might be different from y == x, if x and y are the results of evaluating an expression which returns lazy I/O
10:29:36 <geekosaur> haasn: no, you get something decided
10:29:38 <geekosaur> *decoded
10:29:43 <geekosaur> what is ON DISK is the octets
10:29:44 <allsystemsarego> tomejaguar, Eduard_Munteanu thanks
10:29:54 <colDrMcBeardman> johnw, you can already have that with nan
10:29:55 <geekosaur> because POSIX paths are octet strings
10:30:04 <colDrMcBeardman> without IO
10:30:06 <johnw> Kaidelong: edsko gives an example of this in his talk about effectful streaming with iostreams and pipes
10:30:10 <Ptival> I get an overlapping pattern error in a place where I would not expect, does anyone see my mistake? http://paste.awesom.eu/o56
10:30:13 <ski> johnw : i think of lazy I/O as similar to concurrency
10:30:25 <skypers> anyone?
10:30:26 <Eduard_Munteanu> skypers: it depends
10:30:48 <skypers> Eduard_Munteanu: I won‚Äôt use the monoid outside of runWriterT
10:30:50 <geekosaur> Ptival, I think we need to see the code too
10:30:53 * hackagebot JuicyPixels 3.1.3.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.3.3 (VincentBerthoux)
10:30:54 <Ptival> I get an overlapping pattern error in a place where I would not expect, does anyone see my mistake? http://paste.awesom.eu/o56 (the code: http://paste.awesom.eu/ca1 )
10:30:59 <skypers> but I might use listen to print it to IO on the fly
10:31:06 <Ptival> geekosaur: yes sorry, was about to post it
10:31:22 <joelteon> geekosaur: is there not a library like `directory' with ByteStrings?
10:31:27 <ski> johnw : when you execute `unsafeInterleaveIO act', it's a bit similar to forking off a thread to perform `act' for you. you don't know for sure when it's going to happen
10:31:42 <johnw> ski: that's a good way of looking at it
10:31:44 <Kaidelong> oh I think I see what you are talking about
10:32:23 <Kaidelong> the values are demanded at the point of the call to (x == y)
10:32:41 <geekosaur> joelteon, no, because System.Directory wants to be system agnostic and ByteString is the wrong representation for win32
10:32:47 <joelteon> oh
10:32:48 <Kaidelong> I can see how it might be surprising, I guess I just tend to think of lazy IO working that way anyway
10:32:50 <joelteon> what's win32?
10:32:55 <Eduard_Munteanu> skypers: it should work
10:33:00 <johnw> whereas with an asynchronous library like async, the use of async/wait forces you to consider such asynchronous effects when reasoning about code, lazy I/O can arbitrarily change the semantics of your program in ways you can't predict beyond where those values were obtained
10:33:03 <geekosaur> the unix library has POSIX interfaces
10:33:06 <ski> johnw : so the nondeterminism could be said to reside in the execution of the `unsafeInterleaveIO act' action, not in the resulting values
10:33:08 <joelteon> oh
10:33:11 <geekosaur> the win32 library has Windows interfaces
10:33:12 <haasn> geekosaur: according to System.Posix.Directory.ByteString I have [226,152,131] on my disk. According to System.Directory I have "\9731"
10:33:15 <joelteon> what does win32 use, though
10:33:20 <haasn> which supports exactly what I was saying
10:33:32 <geekosaur> which are mutant broken UTF16
10:33:49 <johnw> ski: right
10:33:53 <geekosaur> (that screws up with codepoints that don't fit in 16 bits)
10:34:11 <johnw> ski: it's just that the types don't let downstream consumers of those values know about the introduction of the asynchronous behavior
10:34:12 <Kaidelong> I'm not really sure if that's a problem or not
10:34:26 <Eduard_Munteanu> skypers: actually I don't think so, I don't see how you can listen and forever at the same time
10:34:30 <skypers> Eduard_Munteanu: it‚Äôs interesting, I‚Äôll go profiling that
10:34:33 <Kaidelong> the return value is still restricted to IO
10:34:42 <joelteon> geekosaur: so does directory do "the right thing"?
10:34:50 <skypers> well, using listen inside forever
10:34:59 <Eduard_Munteanu> skypers: if you want to write it to IO, just do it directly
10:35:17 <geekosaur> haasn: I still do not understand what you are saying, unless it's that System.Directory is hopelessly broken by trying to serve both unix and win32 when they're not really compatible as soon as you get outside [\0-\127]
10:35:38 <geekosaur> joelteon, what is "the right thing"?
10:35:55 <johannesbodannes> Does anyone know of any papers that specifically address the application of FRP to video games?
10:35:59 <joelteon> that's what I'm wondering
10:36:02 <geekosaur> I would argue no because there's no way to guarantee whoever created the fle you're looking at was using a utf8 locale
10:36:07 <skypers> johannesbodannes: I knew one
10:36:14 <skypers> maybe the one about the quake 3 port
10:36:25 <johannesbodannes> oh let me google that
10:36:28 <skypers> using yampa and I don‚Äôt know what
10:36:40 <skypers> reactive-banana maybe
10:36:44 <skypers> not sure
10:36:51 <geekosaur> crap that assumes that no really everything is guaranteed to be utf8 tends to dump core or behave brokenly if it was actually in iso8859-1, or big5 or etc.
10:36:52 <haasn>  geekosaur: I'm simply saying that System.Directory uses your system locale to try and make sense of the file path
10:37:10 <alcabrera> johannesbodannes, skypers: This seems to be that project you mentioned: http://www.haskell.org/haskellwiki/Frag
10:37:22 <geekosaur> because pathnames do not have locales associated with them and worst case different components of a path may have been written with different encoding
10:37:35 <johannesbodannes> aha, here we go! thanks!
10:37:40 <Kaidelong> the frag paper was good
10:37:44 <geekosaur> and you have no way to detect this much less do anything sane about it
10:37:46 <Kaidelong> although yampa is a little bit outdated now
10:37:55 * alcabrera adds it to reading list :D
10:38:04 * mreh wants reactive to be fixed
10:38:12 <mreh> *sad face*
10:38:53 <geekosaur> (except watch your filenames fail to decode as utf8 and then try to guess what the correct encoding is)
10:43:14 <davd> hey guys, I'm having trouble compiling the pipes-http example - http://lpaste.net/99868
10:43:21 <tomejaguar> allsystemsarego: Fixed it for you: http://lpaste.net/99867 (It was Eduard_Munteanu correct diagnosis, really)
10:44:10 <geekosaur> davd: the types there sugest you have multiple versions of pipes installed
10:44:22 <davd> oh, shit. thanks!
10:45:16 <allsystemsarego> tomejaguar, Eduard_Munteanu many thanks
10:45:58 <tomejaguar> You're welcome.  Space leaks can be very annoying.
10:46:44 <shachaf> At least you aren't an astronaut.
10:46:59 <tomejaguar> With a burrito for a space suit.
10:49:01 <skypers> oh god
10:49:10 <skypers> I‚Äôm getting a lot of ld errors
10:49:13 <skypers> /home/skypers/dev/demo/ultrasky/.cabal-sandbox/lib/x86_64-linux-ghc-7.4.1/skyoralis-0.1.0.0/libHSskyoralis-0.1.0.0.a(Shader.o): In function `s96d_info':
10:49:16 <skypers> (.text+0x435): undefined reference to `skyoraliszm0zi1zi0zi0_GraphicsziRenderingziSkyziGLziSafe_zdwgl_info'
10:49:19 <skypers> I did nothing special
10:49:23 <skypers> just cabal build
10:49:28 <skypers> how could I fix that?
10:52:37 <joelteon> Are there any haskell code coverage tools?
10:52:54 <pvt_petey> another example : http://pastebin.com/dc27RGmL . is it right to say that 1 calls 3, then each x is added to a list ys
10:53:09 <pvt_petey> i guess that is where the reversal comes in ?
10:53:13 <pvt_petey> on line 3
10:53:49 <colDrMcBeardman> joelteon, www.haskell.org/haskellwiki/Haskell_program_coverage
10:55:03 <lpsmith> etabot is malfunctioning
10:55:10 <lpsmith> somebody needs to kick it
10:55:24 <lpsmith> (I don't mean kick from the channel,  a proverbial kick)
10:55:29 <shachaf> What's etabot?
10:55:40 <lpsmith> I dunno,  who runs etabot?
10:56:07 <joelteon> so hpc is a bit complicated
10:56:35 <lpsmith> anyway,  64MAADLPJ 5EXAAJO7F and 36DACG77E are all etabot instances that are running erroneously
10:56:40 <shachaf> I've never heard of etabot.
10:57:12 <shachaf> Oh, it's the #snapframework bot.
10:58:06 <lpsmith> oh,  5EXAAJO7F is apparently not etabot
10:58:12 <lpsmith> although some other bot?
10:58:31 <colDrMcBeardman> joelteon, i don't think so? you can just pass -fhpc to ghc.
10:58:52 <colDrMcBeardman> hpc markup Module will give you an html report.
10:59:19 <joelteon> at what point?
10:59:22 <joelteon> building?
10:59:59 <colDrMcBeardman> i think you need to run the program after building with -fhpc
11:00:06 <colDrMcBeardman> although maybe just after it's built.
11:02:27 <joelteon> so after I've built with -fhpc, how do I produce a coverage report
11:02:57 <johnw> run "hpc report"
11:03:16 <joelteon> so running the program is supposed to produce a .tix file somewhere?
11:03:21 <johnw> yep
11:03:24 <joelteon> that's probably my problem
11:03:34 <johnw> it may be in a subdir
11:03:38 <joelteon> yeah
11:03:43 <joelteon> find . -name '*.tix' returns nothing
11:03:52 <johnw> yeah, that's the problem then :)
11:05:02 <evincar> I find "hpc markup" more useful.
11:05:16 <johnw> yeah, I use that too
11:05:28 * hpc markup
11:05:34 <stevejb> hello, I have a question about some code I am writing. Particularly, I have defined a custom data type which has 3 Integers. I am trying to make that type of class Ord so I can use it as keys in a Data.Map. http://lpaste.net/99870
11:05:52 <evincar> It's useful to discover test coverage. :P
11:06:50 <johnw> instance Ord where compare (RCPoint x y z) (RCPoint a b c) = compare x a <> compare y b <> compare z c?
11:07:18 <evincar> stevejb: instance Ord RCPoint where compare (RCPoint a b c) (RCPoint d e f) = compare (a, b, c) (d, e, f)
11:07:29 <shachaf> You wrote deriving Ord
11:07:39 <shachaf> Is there a problem with it?
11:07:54 <stevejb> shachaf: yeah it does not want to do it on its own
11:08:00 <evincar> Oh right. If there is, these instances aren't good.
11:08:02 <shachaf> (Yes, but you should say what the error is so that people can help you.)
11:08:11 <stevejb> johnw: does that and the results together of simply comparing every field?
11:08:24 <stevejb> evincar: thank you
11:08:25 <johnw> stevejb: it's pretty much the same thing that evincar wrote
11:08:45 <stevejb> johnw: okay great.
11:08:48 <shachaf> None of these are the solution to stevejb's problem. :-(
11:08:56 <shachaf> deriving Ord will make exactly the same instance.
11:09:04 <shapr> Looks heath and me are disorganizing Nashkell, the Nashville Haskell con. We're aiming for October. Anyone want to show up?
11:09:34 <stevejb> shachaf: what do you mean?
11:09:56 <shachaf> stevejb: deriving Ord generates more or less the code that people wrote.
11:10:17 <shachaf> If it isn't working, you should @paste the error message too.
11:10:33 <stevejb> shachaf: actually, I think I need to make it derive Eq first. Let me try that
11:10:54 <shachaf> Yes, that's the answer.  You can't deriving (Ord), you have to deriving (Eq, Ord)
11:10:56 <stevejb> shachaf: ah, okay, if I add Eq and Ord to the list, that seems to work.
11:11:05 <shachaf> Yes.
11:11:39 <johnw> shachaf: how hard would it have been to say that from the start?
11:11:47 <shachaf> I guess reading the error yourself works as well as @pasting it.
11:12:09 <stevejb> I was working on this late last night. I think my mind was a little fuzzy. I should have reread the error before coming :)
11:12:35 <stevejb> I have a second up question. In the code, I want to make a Data.Map where the keys are RCPoint objects. I would like to be able to have something that finds the
11:12:41 <shachaf> I think it's a reasonable question, but if something isn't working posting the error is a good habit.
11:12:42 <jfischoff> I don't really understand how the download numbers on hackage work, seeing as they can go up and down on a day to day basis
11:12:42 <stevejb> closest RCPoint object
11:13:00 <jfischoff> I assumed they are measuring total downloads, are they?
11:13:14 <shapr> stevejb: Are you @stevej ?
11:13:18 <stevejb> and, my current method works, but I am worried about it being somewhat inefficient, as it needs to process the entire list of RCPoints
11:13:40 <stevejb> shapr: I don't think so. I've always used stevejb.
11:13:56 <stevejb> https://twitter.com/stevej this guy? no
11:13:57 <shachaf> lookup{LT,GT,LE,GE} from http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Map-Lazy.html might work.
11:14:02 <shapr> stevejb: ok, just wondering
11:14:41 <colDrMcBeardman> stevejb, if you have an unsorted list, any distance filter will have complexity on the order of the length of the list.
11:14:46 <colDrMcBeardman> there's no way around that.
11:15:50 <shachaf> Fortunately that's not what stevejb has.
11:17:34 <stevejb> shachaf: I think I will try to do some performance profiling on it first before I try to optimize it too much. Perhaps it won't be as big a deal as I think.
11:17:41 <x77686d> newbie academic question: Is it proper to say that getLine and getChar are functions?
11:18:15 <shachaf> I would not say it, because I like to mean "something of type ... -> ..." by "function".
11:18:18 <colDrMcBeardman> stevejb, if the list is sorted, then bsearch will give you O(log n)
11:18:30 <shachaf> But the Report says it. If you say it, people will understand what you mean.
11:18:43 <pjdelport> x77686d: in Haskell terms, it's closer to say that they are values, or IO actions
11:18:49 <shachaf> But if you're missing a word, try "value" or "action".
11:18:52 <shachaf> Yes.
11:20:18 <pjdelport> x77686d: you can also say that Haskell does not make a distinction between a "value" and a "zero-argument function": they're pretty much the same thing
11:20:27 <joelteon> Is there a cabal builtin for running hpc and generating markup?
11:20:29 <x77686d> I was trying to write this sentence: <blank>s that do I/O, like getLine and putStrLn are called actions.
11:20:33 <pjdelport> so what you call it depends more on what connotation you want to have
11:20:34 <joelteon> or an example of someone doing that with a custom build setup
11:20:38 <joelteon> because that would be cool
11:20:52 <pjdelport> x77686d: "values" works there
11:21:17 <x77686d> True...
11:21:57 <colDrMcBeardman> joelteon, cabal configure has a '--enable-library-coverage' option that does hpc, IIRC
11:23:07 <joelteon> oh, cool
11:23:56 <stevejb> colDrMcBeardman: thank you. That may not be too bad. What I have been doing is, for point x and list [points], I am doing map (\y -> abs (x - y)) points. So, I still pass over the list
11:24:04 <pjdelport> x77686d: or "values and functions that entail doing I/O, like ...", if you want to be more proper still
11:24:30 <x77686d> pj: I like that
11:25:16 <ski> x77686d : "operations"
11:25:25 <colDrMcBeardman> stevejb, yes, since you have Ord instance now, bsearch will cut out some time complexity. but again, you can't use that if/when you have to deal with unsorted lists.
11:25:26 <stevejb> colDrMcBeardman: and clearly finding the min of the list I just described
11:25:42 <x77686d> ski: perfect!
11:25:51 <ski> x77686d : though strictly speaking `putStrLn' isn't an (`IO'-)action, it's a function that returns one
11:26:24 <stevejb> colDrMcBeardman: so, do I get bsearch just by using Ord or do I have to call a particular function?
11:27:14 <colDrMcBeardman> stevejb, i'm not sure where you would find a bsearch algorithm in haskell.
11:27:27 <pjdelport> stevejb: the Map implementation is already a search tree under the hood; the lookup functions traverse and search it for you
11:27:35 <stevejb> ok great
11:27:59 <pjdelport> you'll probably want lookupLE or lookupGE
11:28:45 <stevejb> pjdelport: oh cool! That looks like exactly what I need
11:29:31 <pjdelport> (stevejb: that's what shachaf linked you to earlier, FWIW :)
11:30:06 <stevejb> shachaf: thank you as well!
11:37:08 <raphie> is it possible to view the C-- my code compiles into?
11:37:14 <raphie> I'd like to take a peek at the process
11:39:06 <Yaniel> it compiles to C--?
11:40:00 <raphie> Yaniel: from WIkipedia: The back end of the compiler transforms Core code into an internal representation of C--
11:40:13 <Yaniel> just reading
11:41:20 <k00mi> raphie: -ddump-cmm
11:43:45 <kristof> I assume that's -ddump-llvm for the other kind of backend, yeah?
11:43:51 <kristof> I could always just man ghc :P
11:45:10 <fryguybob> The section of the manual about this is here: http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-debugging.html#dumping-output
11:45:24 <fryguybob> There is also the ghc-core tool that makes it look nicer
11:45:29 <fryguybob> @hackage ghc-core
11:45:29 <lambdabot> http://hackage.haskell.org/package/ghc-core
11:46:41 <raphie> thanks guys, that did the trick!
11:49:18 <Forgetaboutit> How do I write a type signature for a function in a way that I can specialize a type signature *inside* the function using a type parameter?
11:50:21 <Forgetaboutit> I need to write a function which parses JSON internally and returns a wrapped Data.Aeson.Value.  However, I want the function to work on all types that are an instance of ToJSON.
11:51:13 <kristof> Forgetaboutit: what's the type signature of your outer function?
11:51:42 <johnw> ToJSON a => a -> Value?
11:51:55 <Forgetaboutit> I found that I probably need to use XScopedTypeVariables for that, but I can't figure out how to make it compile because the specializing type is neither present in the arguments neither the return type.
11:52:43 <Forgetaboutit> kristof: It's complicated :D.  I'm working inside a Yesod route.  Pasting would blow up my chat window.
11:52:45 <johnw> Forgetaboutit: can you paste some code?
11:52:54 <johnw> use a pasting service
11:53:03 <guesting> Is it possible to read in a string "(3, Hi)" like so: read x :: (Int, String)?
11:53:06 <kristof> Forgetaboutit: http://hastebin.com/
11:53:10 <Forgetaboutit> johnw: Do you have a link for one?
11:53:31 * pavonia points to topic
11:53:40 <Forgetaboutit> pavonia: Thanks :)
11:54:05 <Forgetaboutit> http://lpaste.net/99871
11:54:15 <frx> guesting it would be easier if it was "(3, \"Hi\""
11:54:19 <frx> )
11:54:38 <Forgetaboutit> the second type signature got in by accident, it's not correct either.
11:54:40 <frx> is that what you meant?
11:54:52 <kristof> dear god, look at that type signature
11:55:08 <Forgetaboutit> kristof: Don't say I didn't warn you :)
11:55:59 <Forgetaboutit> kristof: I only understand a very small piece of it, but I believe most of it is actually not related to my problem/idea.
11:56:36 <kristof> so you didn't write this code?
11:56:44 <guesting> frx: Right now I would have to parse by splitting on the comma and reading the tail of the head and the init of the tail.
11:57:15 <Forgetaboutit> I didn't write the type signature --  GHC spat out that monstrosity.
11:57:41 <dhrosa> > read "(3, \"Hi\")" :: (Int, String)
11:57:42 <lambdabot>  (3,"Hi")
11:58:50 <Forgetaboutit> kristof: The original function looks like this : http://lpaste.net/99872
11:59:11 <Forgetaboutit> kristof: I hope you get the idea of what I'm trying to achieve.
11:59:22 <scshunt> what's the lens function for "Find me an a, I don't care where"?
11:59:22 <pavonia> Forgetaboutit: What's the problem with that code?
12:00:05 <kristof> Forgetaboutit: *shrug*
12:00:06 <Eduard_Munteanu> scshunt: 'a' being what?
12:00:21 <guesting> frx: Oh wait, it does work
12:00:23 <Forgetaboutit> pavonia: I'd have to repeat that over and over.  It's basically the same for a lot of functions with the difference being the signature for `selectList`.
12:00:50 <kristof> Oh, that type signature reminds me of a question I have
12:00:58 <kristof> How do I group a lot of typeclasses together?
12:01:02 <bergmark> scshunt: sounds like universeBi in uniplate
12:01:21 <pavonia> Forgetaboutit: So your question is how to make that type signature smaller?
12:01:29 <Eduard_Munteanu> @hoogle plate
12:01:30 <lambdabot> package ctemplate
12:01:30 <lambdabot> package data-accessor-template
12:01:30 <lambdabot> package data-lens-template
12:02:08 <Forgetaboutit> pavonia: No, actually the signature in the first paste doesn't even compile.
12:02:12 <Eduard_Munteanu> kristof: group for what purpose?
12:02:30 <kristof> pavonia: He wants to express some type constraints of variables that are neither arguments nor return values.
12:02:54 <Forgetaboutit> kristof: Exactly
12:03:03 <kristof> Eduard_Munteanu: (Keyword a) => signature where Keyword a specifies a typeclass constraint of ClassA, ClassB, ClassC...
12:03:31 <supki> scshunt: *plate things
12:03:52 <kristof> Forgetaboutit: I'm just not sure what that means, though, because if you're not explicitly passing a value in, how can you do anything about its type... or care about it?
12:04:11 <kristof> Forgetaboutit: you have to go deeper into the function and pry out the piece of code that *does* do the type discernment, and then impose the constraint there.
12:04:23 <supki> scshunt: Data.Data.Lens
12:04:44 <Forgetaboutit> kristof: Hmm, the problem is that basically everything in this function is library stuff.
12:04:50 <shergill> regd template haskell, does the current feature set differ from the one described in <http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf>?
12:05:02 <Eduard_Munteanu> kristof: type Keyword a = (ClassA a, ClassB b, ...)  ?
12:05:15 <Eduard_Munteanu> Er, s/ b/ a/
12:05:25 <kristof> Eduard_Munteanu: that's a type synonym for a tuple, though
12:05:28 <kristof> OH
12:05:30 <Forgetaboutit> kristof: `selectList` of course doing the work of retrieving stuff from the database.
12:05:32 <kristof> is that how => works?!
12:05:37 <Eduard_Munteanu> kristof: no, it's a constraint synonym
12:05:42 <kristof> oh
12:05:42 <kristof> :/
12:05:45 <kristof> ok
12:05:54 <kristof> Eduard_Munteanu: I trust you!
12:06:00 <Eduard_Munteanu> kristof: you need ConstraintKinds
12:06:02 <scshunt> supki: thanks
12:06:12 <pavonia> Forgetaboutit: Where do you know the concrete type of e from?
12:06:12 <kristof> Eduard_Munteanu: Ah, so it's not standard haskell yeah?
12:06:32 <Eduard_Munteanu> kristof: well, a lot of stuff isn't standard Haskell :)
12:07:02 <Eduard_Munteanu> Much of the libraries shipped by HP aren't strictly H2010.
12:07:26 <kristof> Eduard_Munteanu: Well, I'll keep this library in mind, thank you.
12:07:37 <Eduard_Munteanu> kristof: er, it's not a library
12:07:46 <kristof> extension
12:07:47 <kristof> whatever!
12:08:16 <Forgetaboutit> pavonia: I'd know from the caller.  I'd like to call `genericGets :: SomeRandomType` and it'd figure out what type to use for `selectList`
12:09:03 <skypers> ok, can someone help me to resolve a very weird behavior?
12:09:19 <skypers> I compile a program with my package; it‚Äôs okay
12:09:27 <Forgetaboutit> pavonia: However, `genericGets` should be able to impose constraints on this type in order to make sure it will work.
12:09:52 <skypers> now, when I use a function, ghc complains that ld fails to resolve symbols to symbols that the function doesn‚Äôt even use nor its module
12:09:55 <skypers> any idea?
12:10:00 <skypers> it‚Äôs a side-effect! :)
12:10:06 <johnw> show me the output?
12:10:24 <pavonia> Forgetaboutit: I don't think that is possible without mentioning e either in the result type or in of the arguments types
12:10:45 <skypers> johnw: wait
12:11:09 <pavonia> Forgetaboutit: You could add a dummy argument that value is ignored in the function definition
12:11:12 <skypers> johnw: http://lpaste.net/8551543545788366848
12:11:37 <johnw> did you include that module in your .cabal?
12:11:43 <Forgetaboutit> pavonia: Great idea, that could work.  Brb, have to try ...
12:11:51 <johnw> Graphics.Rendering.Sky.LG.Safe
12:12:03 <skypers> johnw: in the lib or the application?
12:12:13 <johnw> either one
12:12:24 <johnw> it looks like GHC found it, but Cabal isn't including it
12:12:33 <skypers> oooh
12:12:33 <johnw> that's why you can compile but not link
12:12:38 <colDrMcBeardman> does anyone know how to get the source plugin to work on a local lambdabot?
12:12:49 <skypers> I forgot to add it to the exposed-modules, indead
12:12:52 <skypers> indeed*
12:12:56 <skypers> thank you :)
12:13:03 <johnw> sure, I run into this pretty often :)
12:13:04 <skypers> it‚Äôs just weird it fails that way
12:13:12 <colDrMcBeardman> i'd like to use lambdabot for my team but I'm just having a terrible time getting everything to work...
12:13:15 <skypers> I‚Äôm not even using Shader stuff
12:13:19 <skypers> really strange
12:13:30 <Forgetaboutit> pavonia: Can I also pass a type as an argument?
12:13:57 <johnw> Forgetaboutit: you can pass a proxy for a type
12:14:22 <Forgetaboutit> johnw: what does that mean?
12:14:36 <johnw> it fixes the type variable based on the proxy argument the caller passes
12:15:10 <johnw> foo :: proxy a -> b, foo (Proxy :: Proxy Bar), would fix a to Bar without actually needing to construct a Bar value
12:15:19 <johnw> (I'm using Data.Proxy from the 'tagged' package)
12:15:29 <skypers> what is it for?
12:15:35 <johnw> for just that scenario :)
12:15:36 <skypers> phantom typing?
12:15:40 <johnw> yeah, usually
12:15:56 <skypers> or do the same thing as (undefined :: a)?
12:16:11 <johnw> yes, very similar
12:16:14 <skypers> ok
12:16:16 <johnw> but in a bit more principled way
12:16:20 <skypers> I don‚Äôt feel the need for it yet
12:16:21 <Forgetaboutit> phew, that sounds interesting but also complicated
12:16:55 <johnw> well, if you ever define type classes without using functional dependencies where you have just this one method that doesn't use every type variable in an argument position, proxies can rescue you from "a does not match a1" type errors
12:17:27 <johnw> it's rarely needed, but when you need it, you really need it
12:17:54 <skypers> johnw: oh, btw
12:17:58 <shachaf> That sounds much more complicated than it needs to.
12:18:03 <skypers> what are those function dependencies in typeclasses?
12:18:11 <johnw> shachaf: feel free to simplify
12:18:16 <shachaf> Proxy is a solution to the "using undefined is ugly" problem.
12:18:18 <skypers> I sometimes have error about that
12:18:19 <johnw> skypers: how do you mean?
12:18:24 <shachaf> class Typeable a where typeOf :: a -> TypeRep
12:18:47 <shachaf> typeOf (undefined :: Int) -- "ew, undefined"
12:18:49 <kristof> Forgetaboutit: With respect to what you told me, why don't you wrap the library function in another function that has a stricter type signature?
12:18:50 <skypers> shachaf: this still requires undefined
12:18:51 <skypers> yeah
12:19:02 <shachaf> So we define data Proxy a = Proxy
12:19:05 <johnw> right, we mentioned the "better than undefined" approach
12:19:17 <johnw> I was adding some more scenarios beyond just undefined where it can be useful
12:19:23 <skypers> johnw: well, what is functional dependency for typeclasses?
12:19:40 <johnw> skypers: for multi-parameter type classes, it fixes a relation between types
12:19:44 <shachaf> Is your scenario different from accepting an 'a' argument and then passing undefined?
12:19:46 <johnw> take class Foo a b | a -> b, for example
12:19:58 <skypers> I don‚Äôt know the | a -> b syntax
12:20:00 <skypers> I often read that
12:20:04 <johnw> this says that instances can only be defined for unique pairs of a, b
12:20:06 <skypers> and never tried to understand
12:20:09 <skypers> my shame
12:20:22 <johnw> without the functional dependency, you can have multiple dependencies for one 'a' and multiple 'b's
12:20:29 <johnw> s/dependencies/instances
12:20:38 <skypers> johnw: ooh
12:20:40 <skypers> ok
12:20:47 <skypers> that means
12:20:52 <johnw> to take a real example: MonadReader r m | m -> r
12:20:56 <skypers> the instance Foo Int b is unique?
12:21:04 <johnw> the functional dependency means that knowing 'm'  is enough to know what 'r' must be
12:21:15 <skypers> yes, I know the principle
12:21:15 <Forgetaboutit> kristof: Hm, I probably would get stuck as well.  I could write a simpler wrapper, but in essence I still need to get a Data.Aeson.Value (wrappen in some monad transformer).
12:21:22 <skypers> just wondered how it applies to typeclasses
12:21:26 <skypers> that‚Äôs great :)
12:21:26 <johnw> that's all it is, it's very simple
12:21:27 <skypers> thank you
12:21:49 <skypers> is there a way to write more complex one?
12:21:53 <skypers> like a <-> b?
12:21:57 <skypers> or
12:22:05 <Eduard_Munteanu> skypers: a -> b, b -> a
12:22:05 <skypers> class Foo a b c | a -> b, c -> b
12:22:10 <johnw> yeah
12:22:12 <Eduard_Munteanu> Yes.
12:22:13 <skypers> ok, coma then
12:22:33 <Forgetaboutit> kristof: The problem is that no matter how simple the wrappers, it boils down to specializing the type of an internal function
12:22:36 <shachaf> I'm not sure what "unique pairs of a, b" means but it looks too symmetric to mean the same thing as the functional dependency.
12:22:38 <skypers> comma*
12:23:02 <Eduard_Munteanu> skypers: also, 'a b -> c' and 'a -> b c'
12:23:13 <skypers> yeah but I studied functional dependencies for relational algebra (DBMS)
12:23:17 <Eduard_Munteanu> The latter is like 'a -> b, a -> c'
12:23:18 <skypers> it takes sense now
12:23:28 <merijn> skypers: That's exactly where the idea came from
12:23:36 <skypers> :)
12:23:50 <merijn> skypers: databases are explicitly mentioned in the paper :)
12:24:00 <johnw> shachaf: perhaps so, then I mean that any given a will have exactly one b
12:24:25 <johnw> though multiple different 'a' could all have the same b
12:24:27 <skypers> merijn: for databases it‚Äôs great to express normal forms, but what‚Äôs it great for typeclasses?
12:24:31 <skypers> consistency?
12:24:50 <skypers> a -> b c
12:24:54 <pjdelport> skypers: have you read the examples on http://www.haskell.org/haskellwiki/Functional_dependencies by the way?
12:24:55 <Eduard_Munteanu> skypers: instance resolution
12:24:55 <skypers> this always blew my mind
12:25:02 <skypers> multi-valuable relations
12:25:19 <skypers> pjdelport: nope
12:25:27 <Eduard_Munteanu> skypers: for example you can write a class that combines two types and "returns" a result...
12:25:41 <cstrahan> Hi, all.
12:26:11 <Eduard_Munteanu> skypers: class Foo a b c | a b -> c    instance Foo a b (a, b)
12:27:19 <cstrahan> Quick question: when using `ghc -ddump-splices` in a cabal-sandboxed directory, how can I point ghc to the sandboxed packages?
12:27:22 <Eduard_Munteanu> skypers: this makes it obvious to the compiler which things are treated as givens
12:27:56 <skypers> I see
12:27:59 <skypers> sounds awesome
12:28:17 <shachaf> So given "class Foo a b | a -> b", why can't I write "foo :: (Foo a b, Foo a c) => a -> b -> c; foo _ x = x"?
12:28:22 <skypers> it requires MultiParamTypeClasses I guess?
12:28:39 <Eduard_Munteanu> skypers: sure, but that's very common
12:28:56 <cstrahan> trying to pick up Yesod. whenever I try -ddump-splices, ghc complains because I don't have yesod installed globally, and thus can't find the necessary packages: "Could not find module `Yesod.Core.Types'"
12:29:14 <skypers> Eduard_Munteanu: sure it is :)
12:29:25 <shachaf> cstrahan: I'd say: Find out what command cabal is running, then run that command yourself.
12:29:38 <shachaf> But I don't use cabal-sandbox.
12:30:12 <shachaf> (-v or something along those lines might help.)
12:30:26 <cstrahan> shachaf: yeah, i was about to start down that path... but figured someone might be able to spare me a (probably nontrivial) amount of time :)
12:30:52 <shachaf> Set ghc-options: -ddump-splices in your .cabal file?
12:30:59 <shachaf> I think cabal build has a ghc-options flag, too.
12:31:12 * hackagebot RNAdesign 0.1.2.1 - Multi-target RNA sequence design  http://hackage.haskell.org/package/RNAdesign-0.1.2.1 (ChristianHoener)
12:31:25 <merijn> cstrahan: Pretty sure you can specify additional paths for GHC to search using -i
12:31:39 <merijn> cstrahan: Check the GHC user manual for the exact flag
12:31:55 <merijn> Or add it to ghc-options in cabal, yeah
12:34:06 <johnw> 14:23 <shachaf> So given "class Foo a b | a -> b", why can't I write "foo :: (Foo a b, Foo a c) => a -> b -> c; foo _ x = x"?  ==> It cannot deduce that b ~ c, but if you add that constraint you can
12:34:34 <shachaf> Those are both true statements.
12:34:40 <shachaf> Why can it not deduce that b ~ c?
12:35:20 <johnw> ah, I see what you're asking, because it simply returns x
12:35:36 <johnw> and by the functional dependency, you'd think that it could
12:35:37 <cstrahan> (re: my previous question, for the curious) This answers my question, I think: https://mappend.net/posts/ghc-and-cabal-sandbox-playing-ni
12:35:50 <johnw> (or at least, I'd think that it could)
12:35:59 <johnw> so am I missing something about functional dependencies here, or is this just a general question?
12:36:00 <cstrahan> merijn, shachaf: thanks for the tips!
12:36:40 <Eduard_Munteanu> shachaf: it can't deduce that from the fundep unless you have an actual instance which sets 'b' from 'a'.
12:36:51 <shachaf> Eduard_Munteanu: Why?
12:37:31 <Eduard_Munteanu> shachaf: suppose there's no instance whatsoever of Foo, how could it deduce 'Foo a b' ?
12:37:47 <shachaf> Then I couldn't use the function. But I'm asking why I can't define it.
12:38:19 <Forgetaboutit> johnw: Ok, I officially give up for now.  Thank you for your help anyway!
12:39:27 <johnw> Forgetaboutit: what did you end up with?
12:40:22 <Saizan> shachaf: fundeps never implied that axiom because they were always just seen as a way to improve type inference rather than having a true impact on the types
12:41:03 <shachaf> Saizan: OK.
12:41:12 <Saizan> shachaf: and now it's a bit hard to add because of stuff like Overlapping (and maybe even Undecidable?) making that axiom not quite sound
12:41:19 <shachaf> Aha. OK.
12:41:22 <johnw> shachaf: great question though
12:41:39 <Eduard_Munteanu> shachaf: I don't think it's reasonable to expect you can use a fundep unless there is a specific instance that applies in that case
12:41:54 <Forgetaboutit> johnw: I'm still using the previous function ( http://lpaste.net/99872 ) and now I have to change `Handler [Entity Expense]` to `Handler [Entity WhatEver]` for every type I get from the database.
12:42:23 <shachaf> Eduard_Munteanu: Why not?
12:45:05 <pavonia> The definition works if you use type families, btw
12:45:42 <shachaf> Using type families it just ends up being :: Foo a => FooT a -> FooT a, doesn't it?
12:46:17 <skypers> http://isocpp.org/blog/2014/02/find-the-bug
12:46:18 <shachaf> a ->
12:46:24 <skypers> reminds me wrong times‚Ä¶ :)
12:46:32 <pavonia> shachaf: I meant foo :: (b ~ Foo a, c ~ Foo a) => a -> b -> c
12:46:51 <shachaf> It's not particularly surprising that that works.
12:47:19 <pavonia> Well, I'd expect the same result as with your fundeps example
12:48:05 <johnw> skypers: is it that _vec and names could be referring to the same thing?
12:48:25 <shachaf> Your type doesn't have a whole lot to do with type families, though. It's constraining b and c to be equal to the same thing.
12:48:57 <skypers> johnw: I don‚Äôt really know
12:49:14 <skypers> but it states something important to me: I fu***** love Haskell and purity
12:50:10 <johnw> you mean, when you aren't using mutable vectors? :)
12:50:24 <skypers> I never use them
12:50:31 <skypers> I never use mutable containers
12:50:33 <johnw> they can be handy
12:50:38 <shackleford_> Does anyone have any tips for porting a small Python project to Haskell? Specific dos/don'ts?
12:50:39 <skypers> what for?
12:51:08 <johnw> conduit has a new "sinkVector" function for draining a producer into a fixed-size container, which is *much* faster than dumping into a list
12:51:15 <johnw> so, for sped
12:51:17 <johnw> speed
12:52:28 <skypers> johnw: yeah, I‚Äôll look forword to that
12:52:36 <Eduard_Munteanu> shachaf: hm, I admit I can't come up with a good argument, but it seems reasonable because you can translate the fundep into equality constraints in the *instance* (assuming you don't care about resolution aspects)
12:53:32 <pjdelport> shackleford_: Python idioms don't necessarily map to Haskell idioms; ask frequent questions to make sure you keep a reasonable approach in the Haskell code
12:54:23 <Eduard_Munteanu> shachaf: instance Foo A B  in the fundep variant gives you    instance (b ~ A) => Foo A b   if that's an instance for a class without the fundep.
12:54:34 <pjdelport> shackleford_: you can explain the gist of your program, if you'd like some concrete advice
12:54:43 <Eduard_Munteanu> Er, b ~ B.
12:55:54 <osa1> why doesn't ghc-pkg unregister delete executables in .cabal/bin ?
12:56:13 <johnw> because it only affects the package database
12:56:15 <johnw> use this: https://github.com/iquiw/cabal-delete
12:56:22 <shackleford_> pjdelport: It's a suite of tools to quickly generate random content for tabletop RPGs (D&D, GURPS, and the like.) Right now the only part that is reasonably serviceable is a generator for random names.
12:56:35 <osa1> johnw: this looks great. thanks.
12:57:22 <shackleford_> pjdelport: Very crude, really. Just throws together random indices from a file full of syllables.
12:58:16 * ski fwiw thinks `foo :: (Foo a b, Foo a c) => a -> b -> c; foo _ x = x' ought to be allowed
12:59:19 <zrho> only if Foo a b | a -> b
12:59:20 <pjdelport> shackleford_: Sounds fun! As general advice, comping from Python, you'll want to think of your program as much as possible in terms of values (in the mathematical sense), and transformations, rather than processes and state.
13:00:19 <Eduard_Munteanu> I think that essentially makes the fundeps equivalent to type families
13:00:38 <pjdelport> (That goes for any functional programming, but if you're stuck trying to translate some Python code or concept to Haskell, specifically, try to think how the concept can be represented as a plain value, and go from there.)
13:01:43 <pjdelport> shackleford_: If you're working with stuff like a file full of syllables, always try to separate the code that does actual IO from the code that actually works with names.
13:01:55 * shachaf agreeski, though maybe the thing Saizan said makes it unreasonable
13:04:07 <shackleford_> pjdelport: I try to do that anyway, regardless of language. My professor for my first programming class drilled separation of concerns into me hardcore!
13:04:11 <pjdelport> shackleford_: Oh, and be aware that Haskell lists aren't quite the same as Python lists: think of Haskell lists more as the loop control structure.
13:04:34 <jophish_> Is it ok to say that type variables have an arity. For example could I say "in foo:: a b -> b, a has an arity of 1 and b has an arity of 0'
13:04:44 <jophish_> rather than "a has kind (*->*) and b has kind (*)
13:04:57 <pjdelport> If you need to repeatadly index a list of names, like you'd do in Python, you'd use an Array in Haskell instead.
13:05:00 <yan_> can someone help me rewrite the following in a point-free style?: (f a) `g` (f b)
13:05:10 <shackleford_> pjdelport: I was actually about to ask about lists! Since you have to go through it one link at a time to get to index n, would something like ArrayST be more practical?
13:05:11 <jophish_> Can that kind information even be inferred, for example couldn't b have a kind "Nat"?
13:05:12 <shachaf> yan_: It's already in point-free style.
13:05:13 <Eduard_Munteanu> jophish_: yeah, but it's a general thing about type operators
13:05:24 <yan_> shachaf: a and b are explicit arguments, no?
13:05:33 <dhrosa> liftM2 g f f ?
13:05:38 <Saizan> shachaf: it would really help when reasoning about fundeps, though it'd probably get in the way of some nice tricks, otoh the tricks might be better suited as distinct features
13:05:40 <Eduard_Munteanu> :t ?g `on` ?f
13:05:41 <dhrosa> or g <$> f <*> f?
13:05:41 <lambdabot> (?g::b -> b -> c, ?f::a -> b) => a -> a -> c
13:05:43 <shachaf> yan_: They don't look like arguments.
13:05:49 <zrho> @pl \a b -> (f a) `g` (f b)
13:05:49 <lambdabot> (. f) . g . f
13:05:59 <dhrosa> wait oops
13:06:00 <dhrosa> nvm
13:06:07 <yan_> zrho: that looks like it, thanks
13:06:10 <jophish_> Eduard_Munteanu: sorry, could you elaborate a little on that, please?
13:06:21 <pjdelport> shackleford_: You can use plain immutable arrays (just Array), not necessarily mutable arrays (ArrayST)
13:06:22 <shachaf> Eduard_Munteanu's answer was more useful, if you allow "on".
13:06:23 <shachaf> @src on
13:06:23 <lambdabot> (*) `on` f = \x y -> f x * f y
13:06:35 <shachaf> If that's what you were getting at, anyway.
13:06:58 <yan_> shachaf: yeah, 'on' is what i forgot existed
13:07:04 <dhrosa> > let f = (+) `on` (*2) in f 1 2
13:07:05 <lambdabot>  6
13:07:15 <Eduard_Munteanu> jophish_: type variables can stand for any type, including type functions
13:07:19 <shackleford_> pjdelport: Much better idea. Thanks for that!
13:07:28 <Eduard_Munteanu> jophish_: and arity is a property of types / type functions
13:07:36 <jophish_> that's good
13:07:54 <pjdelport> shackleford_: The Array API can be a little bit imposing, if you've never worked with it before, so feel free to ask questions.
13:08:27 <pjdelport> The main points are that you can choose what combinations of boxed/unboxed, mutable/immutable, etc. you want
13:10:52 <mniip> can someone explain me why isn't this expression lazy:
13:10:52 <mniip> main = (liftM nub $ sequence $ take 5 $ repeat $ getLine) >>= sequence_ . (map putStrLn)
13:10:52 <Eduard_Munteanu> jophish_: you can avoid discussing arity if you stick to showing kinds, though... e.g. say its kind is '* -> *'
13:10:52 <shackleford_> pjdelport: Oh, I'll be here all the time once it gets rolling.
13:10:52 <Eduard_Munteanu> mniip: what laziness are you expecting?
13:10:52 <pjdelport> and that the index type is actually flexible: you're not limited to indexing arrays by integers, but by any type that can be enumerated
13:10:52 <pjdelport> (that's why the type signatures can seem complex at first)
13:10:52 <mniip> Eduard_Munteanu, it is supposed to output a string as soon as it is input
13:10:52 <jophish_> Eduard_Munteanu: I can see how this works with Kind = Star | Fun Kind Kind. I'm not sure how this works if Kind can be Nat or Symbol as in DataKinds
13:10:52 <mniip> (except when the string has already been seen)
13:10:52 <Eduard_Munteanu> mniip: that's not possible, not only because of 'nub' but also perhaps buffering
13:10:52 <ski> shachaf : i'm not sure how `Overlapping' (or (i assume they meant) `Incoherent' ?) would interact here
13:10:52 <jophish_> for example: foo :: a b -> a. What should the error be? a has kind (Nat -> *) or a has kind (*->)
13:10:52 <jophish_> s/(*->)/(*->*)
13:10:52 <ski> jophish_ : you could say a type has an arity (just a value may have one). but it says less than the kind of it says
13:10:56 <mniip> Eduard_Munteanu, sequencing getLine>>=putStr works fine, it can't be buffering
13:11:00 <yan_> shachaf: among those same lines, how can i remove the mention of the accumulator here: cmp acc = acc .|. xor `on` ord
13:11:14 <mniip> Eduard_Munteanu, besides, i tested nub$cycle[1,2,3], nub is lazy
13:11:21 <jophish_> ski: exactly, I'm not sure if it's possible to infer that extra information
13:11:35 <shachaf> yan_: I'm not sure how to parse that. Which way do the parentheses go?
13:11:59 <ski> jophish_ : in general in `foo :: a b -> b' you can infer `b :: *' and `a :: k -> *', for some kind `k' (ignoring unboxed stuff)
13:12:02 <yan_> shachaf: sorry, it should be: cmp acc = (acc .|. (xor `on` ord))
13:12:13 <yan_> i.e. this is a lambda that runs on a list of tuples, taking ord of each value, then xoring them
13:12:18 <yan_> and accumulating via bitwise or
13:12:20 <pjdelport> shackleford_: Feel free to post some code for critique or advice, by the way.
13:12:35 <johnw> @pl cmp acc = (acc .|. (xor `on` rod))
13:12:35 <lambdabot> cmp = (.|. (xor `on` rod))
13:12:42 <shachaf> yan_: acc and (xor `on` ord) are arguments to (.|.)?
13:12:47 <yan_> yea
13:12:53 <zipper> Can I say something?
13:12:57 <jophish_> ski: I wonder how complicated the kind solver in ghc is
13:13:01 <johnw> zipper: certainly
13:13:17 <shachaf> OK, then what lambdabot said.
13:13:25 <zipper> You can, you will we will resent you for wasting our time but don't let that stop you.
13:13:40 <zipper> johnw: That was the reply to the question
13:14:02 <mniip> Eduard_Munteanu, any other things that could take the laziness
13:15:01 <mniip> I'm not seeing how would evaluating the first element of the sequence_ require evaluation of anything but the first getLine
13:15:35 <Eduard_Munteanu> :t take 5 $ repeat $ getLine
13:15:35 <lambdabot> [IO String]
13:15:53 <Eduard_Munteanu> > take 5 $ repeat $ getLine
13:15:54 <lambdabot>  [<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>]
13:17:12 <ski> @type sequence (take 5 (repeat getLine))
13:17:13 <lambdabot> IO [String]
13:17:18 <jophish_> Style question. In most Haskell, are function names always verbs? This is certainly the nicest way of doing things in lots of other languages. I've seem lots of haskell where this isn't the case
13:17:23 <ski> @type replicateM 5 getLine
13:17:24 <x0l> Hi all, first time here. I was trying to solve problem 14 of ProjectEuler in Haskell, my code: http://lpaste.net/99876. I'm trying to optimize it along the lines described in Real World Haskell but I could not make ghc use unboxed type. Can someone give me a hint in the right direction ?
13:17:24 <lambdabot> IO [String]
13:17:47 <mniip> ski, initially there was going to be no 'take 5'
13:17:48 <jophish_> for example getting the length of a snake, one could have: getSnakeLength, or just snakeLength
13:17:50 <mniip> just repeat
13:17:53 <jophish_> I've seen examples of both
13:18:06 <mniip> but that never ends, because of laziness failure of some kind
13:18:49 <shachaf> I think verbs make awful function names for the most part.
13:19:08 <shachaf> getLength :: [a] -> Int?
13:19:09 <pjdelport> jophish_: verbs are probably more common for IO or other action-like types
13:19:09 <joneshf-laptop> jophish_, i think it depends on how you represent your snake, if it's a list, why use a different function?
13:19:10 <Eduard_Munteanu> jophish_: might have something to do with imperativeness... bossing your computer around, "do this", "do that" ... :)
13:19:24 <ski> mniip : *executing* (not evaluating) `sequence (repeat getLine)' means first executing all the (infinitely many `getLine' in the list (in order), then returning with a list containing all the respective results (in order)
13:19:43 <mniip> but why
13:19:53 <shachaf> (length "hello") is the length of "hello"
13:19:54 <joneshf-laptop> if it's not, a list, then surely there's a sufficently general way to represent length
13:20:01 <ski> mniip : because that's how bind in `IO' works
13:20:01 <joneshf-laptop> right?
13:20:10 <jophish_> It was just an example
13:20:19 <jophish_> but why on earth would a snake be represented by a list?
13:20:24 <ski> mniip : for `State' or `Lazy.ST', this wouldn't happend
13:20:38 <ski> (or for `Writer' or `Reader')
13:20:38 <jophish_> I suppose it could be a list of colors along the body
13:20:40 <mniip> ski, but sequence is nothing but foldl1 (>>), is it
13:20:52 <jophish_> thanks
13:20:53 <joneshf-laptop> if it's foldable or traversable there's gotta be something, right?
13:21:14 <mniip> oh wait,
13:21:21 <mniip> no, that's not sequence
13:21:47 <ski> mniip : and to execute `ma >> mb' (assumed to be an `IO'-action) you *first* need to execute `ma' (ignoring the result value), *then* execute `mb', and the result value of the whole is the result value of that execution of `mb'
13:21:54 <ski> @src sequence
13:21:54 <lambdabot> sequence []     = return []
13:21:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:21:54 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:21:58 <ski> @src sequence_
13:21:58 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:22:20 <evincar> jophish_: I would argue that function names should describe behaviour. If that means *doing* something, it should be a verb; if that means *observing* something, it should be a noun and read with "of".
13:22:51 <mniip> so
13:22:55 <joneshf-laptop> jophish_, it really depends on what you're doing
13:22:56 <evincar> And typically pure things don't do. They observe.
13:23:03 <evincar> You aren't "getting" the length of the list.
13:23:14 <ski> @type lookup
13:23:15 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:23:29 <mniip> I have an IO String which i need to execute infinitely many times while nubbing over results and outputting them lazily. How would i do that then?
13:23:30 <x0l> @src seq
13:23:30 <lambdabot> Source not found. You type like i drive.
13:23:30 <ski> @type sort
13:23:31 <lambdabot> Ord a => [a] -> [a]
13:23:46 <ski> x0l : do you know about using `!' in patterns ?
13:23:57 <x0l> ski: i tried that too
13:24:09 <ski> mniip : `unsafeInterleaveIO' ?
13:24:13 <Eduard_Munteanu> mniip: I'd use a Set instead of nub
13:24:17 <merijn> x0l: seq doesn't have a source, it's not implementable in Haskell
13:24:20 <jophish_> evincar: so you'd argue that to get the length of a snake the function should be lengthOfSnake
13:24:25 <x0l> ski: i'm not too worry at the moment with lazy eval just getting ghc to use unboxed int
13:24:26 <ski> x0l : it would work like `seq !_ b = b'
13:24:30 <jophish_> that's certainly another thing to consider
13:24:36 <x0l> merijn: thanks
13:24:51 <evincar> jophish_: No, "length snake" or "snakeLength snake", pronounced "length of snake".
13:24:55 <ski> of course, `!' in turn is explained in terms of `seq'
13:24:57 <joneshf-laptop> jophish_, if you're modeling things as objects, that really shouldn't be objects then it's going to end up awkward,
13:25:17 <jophish_> joneshf-laptop: ?
13:25:18 <joneshf-laptop> jophish_, but really, shouldn't this be in the type somewhere that you could pattern match on?
13:25:26 <mniip> ski, so, at what point do i plug it?
13:25:35 <jophish_> evincar: ah I see
13:25:37 <mniip> directly after getline?
13:25:40 <jophish_> that's nicer I think
13:25:45 <ski> mniip : before is better
13:26:03 <joneshf-laptop> i mean when it really comes down to it
13:26:09 <joneshf-laptop> it doesn't matter what you name the function
13:26:16 <joneshf-laptop> you can't really know what it does based on the name
13:26:19 * hackagebot gnome-keyring 0.3.1 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.3.1 (JohnMillikin)
13:26:44 <jophish_> joneshf-laptop: I disagree, I think that it should be clear what a function does based on the name
13:26:50 <ski> mniip : start from `repeatIO :: IO a -> IO [a]; repeatIO act = unsafeInterleaveIO (liftM2 (:) act (repeatIO act))', and add your nubbing ?
13:26:59 <yan_> @pl (((==) `on` length) a b) && (0 == (foldl1 (.|.) (zipWith (xor `on` ord) a b)))
13:26:59 <lambdabot> ((==) `on` length) a b && 0 == foldl1 (.|.) (zipWith (xor `on` ord) a b)
13:27:19 <jophish_> and there are plenty of good examples to support this
13:27:19 <dhrosa> @hoogle on
13:27:19 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:27:20 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
13:27:20 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
13:27:57 <cstrahan> So, after digging around, and looking at hsenv,
13:28:20 <cstrahan> i've figured out a way to wrap ghc to make it aware of the sandboxed packages:
13:28:22 <cstrahan> https://gist.github.com/cstrahan/8984109
13:29:12 <cstrahan> So that answers my question earlier. Hopefully someone will find it useful.
13:30:43 <joneshf-laptop> jophish_, i think we're going to have to agree to disagree, names might giveyou some superficial intuition about what a function MIGHT do, but it's really just that. and besides, you can't sufficiently describe what a function does witha name unless you want to end up in the java world
13:31:07 <Yaniel> or objc
13:31:12 <yan_> can someone comment on whether or not this is stylistically alright?: http://lpaste.net/99878
13:31:27 <jophish_> joneshf-laptop: I can give you a two letter example, 'id'
13:31:36 <yan_> (just trying to constant-time compare two strings. first, reducing the lists via xor, then 'or'ing up the values)
13:32:09 <Eduard_Munteanu> yan_: what's && 0 supposed to do? :/
13:32:30 <yan_> Eduard_Munteanu: if the two lists are the same size, and their 'or' reduces to 0
13:32:31 <kristof> Eduard_Munteanu: produce a contradiction
13:32:35 <mniip> ski, more interesting stuff,
13:32:43 <mniip> main = ((liftM nub) $ sequence $ take 10000 $ repeat $ unsafeInterleaveIO $ getLine) >>= sequence_ . (map putStrLn) -- this works
13:32:54 <Saizan> Eduard_Munteanu: you parsed it wrong
13:32:59 <mniip> but if i take the 'take 10000' out, it becomes non-lazy again
13:33:09 <Eduard_Munteanu> Oh, I misread, yeah... I thought it was a guard.
13:33:32 <Saizan> yan_: this won't be constant time, btw
13:33:50 <yan_> Saizan: hm?
13:34:08 <yan_> Saizan: it should be constant time with regards to their length, not their content
13:34:08 <jophish_> yan_: it's not possible to compare strings in constant time
13:34:18 <Saizan> yan_: it'll take time proportional to the length of the list
13:34:22 <yan_> Saizan: that's fine
13:34:28 <shackleford_> Hey guys, is this a good length function I wrote here? http://lpaste.net/99879
13:34:29 <yan_> Saizan: that's the goal
13:35:08 <Eduard_Munteanu> shackleford_: you don't need Enum
13:35:29 <Saizan> yan_: ok, but so will (==) for String, anyhow the code looks fine
13:35:46 <yan_> Saizan: it won't bail early if they're different in the first char?
13:35:47 <Eduard_Munteanu> shackleford_: well, you don't need Eq either
13:36:02 <yan_> Saizan: the goal is to have "asdf" and "asdf" take the same amount of time as "asdf" and "bsdf"
13:36:20 * hackagebot anonymous-sums 0.2.0.0 - Anonymous sum types  http://hackage.haskell.org/package/anonymous-sums-0.2.0.0 (OmariNorman)
13:36:24 <yan_> Saizan: this is a proof of concept to compare password hashes, eventually
13:36:42 <shackleford_> Eduard_Munteanu: I originally wrote it with guards and using ==. Forgot to take it out.
13:37:09 <Eduard_Munteanu> yan_: why all that xor-ing?
13:37:53 <yan_> Eduard_Munteanu: the function is intended to compare two strings and not bail early if they differ early
13:38:10 <joneshf-laptop> jophish_, like I said, what does that do? I can think of two interpretations: one where it takes a value and returns it, the other where it takes a value and gives back some identifier. we both know what it does, because we have used it/looked at the implementation, but the point remains, without any previous knowledge of what the function actually does, the name doesn't give you anything but a superficial intuition
13:38:25 <joneshf-laptop> jophish_, as another example, what about `return`?
13:39:05 <kristof> ...I think return should be renamed to "wrap"
13:39:15 <kristof> which parallels comonad's "extract"
13:39:21 <jophish_> joneshf-laptop: I never claimed that there are not badly named functions. You claimed that every function was badly named.
13:39:41 <jophish_> for some badly
13:39:51 <kristof> Yawn, hair splitting.
13:39:57 <merijn> yan_: Much simpler: http://lpaste.net/99878
13:40:03 <Kaidelong> is there any way, in glasgow haskell, to make a sum type out of every instance of a certain typeclass?
13:40:08 <Hafydd> exists badly. forall functions f. f is badly named
13:40:11 <prophile> I think it should be renamed to 'retour' to acknowledge haskell users in french canada
13:41:18 <Saizan> yan_: ah, now i see what you meant, i'm curious of why that's important though
13:41:19 <joneshf-laptop> jophish_, i didn't claim that all functions are badly named, all I said was that the name doesn't actually help you as much as we all like to think (myself included). Again, i think it's best to just agree to disagree.
13:41:26 <merijn> Saizan: To avoid timing attacks
13:41:33 <Eduard_Munteanu> Saizan: it's useful to avoid side-channel leaks
13:41:41 <kristof> Kaidelong: why don't you just impose a typeclass restraint? That's exactly what that is, kind of
13:41:49 <merijn> Saizan: Although I wouldn't want to guarantee side-channel freeness in haskell
13:41:56 <Eduard_Munteanu> yan_: I'd call out to a library for stuff like that
13:42:04 <merijn> yan_: Why not use NaCl and outsource all the safety/crypto?
13:42:07 <yan_> Saizan: when comparing password hashes, it's important to do that in constant time, otherwise you can leak informationa bout the stored hash
13:42:09 <kristof> (Typeclass a) => signature == signature with InstanceA | InstanceB | InstanceC . . .
13:42:16 <merijn> yan_: And/or use scrypt
13:42:23 <kristof> Someone please correct me if my interpretation is wrong
13:42:28 <Kaidelong> kristof: the problem is that to meet this specification with the design I had in mind I need to be able to generate "the universe of all values of types that are generable"
13:42:30 <yan_> Eduard_Munteanu, merijn: i wasn't away haskell stdlib provides constant time compare
13:42:36 <Saizan> Eduard_Munteanu, yan_: thanks
13:42:54 <yan_> merijn: well, ideally you'd scrypt to derive the 'hash'
13:42:57 <merijn> yan_: It doesn't, afaik, but laziness makes it really hard to guarantee timing anyway
13:44:14 <yan_> merijn: sure, but written this way you can guarantee it won't abandon earlier at least
13:44:23 <yan_> merijn: i'd hand-wave that this leaks less data than a normal ==
13:44:37 <Kaidelong> I'm not actually sure if there's a way to set it up so that "programmer can write generators all over the place but universe generator knows about all the generators" in haskell, in the declarative top level
13:44:54 <Eduard_Munteanu> yan_: you could spawn the computation on a separate thread and make sure it finishes after a very specific time length
13:45:22 <merijn> yan_: Sure, but take a look at the one I linked, it's much more straightforward: http://lpaste.net/99878
13:45:45 <rgr> how do I reindex the documentation on my system in cabal? I removed the system ghc-doc and want the .cabal/share/doc/uindex updated
13:46:04 <yan_> Eduard_Munteanu: that is way too much effort to just make sure a function doesn't bail early :)
13:46:28 <merijn> yan_: Actually, in haskell that's surprisingly little effort
13:46:32 <Kaidelong> maybe I should just discard the idea of the "set of all values" entirely just because it's not idiomatic haskell (and I'm not sure how useful it is)
13:46:56 <Eduard_Munteanu> Saizan: it's pretty scary if you look at the attack on Intel's hyperthreading, they recover a bit of information from cache hits and misses, just by running the malicious code alongside a victim process
13:47:19 <Eduard_Munteanu> yan_: not really, it generalizes more easily
13:48:28 <x0l> can u really make a timing attack on comparing a 256 bytes long string ??
13:48:52 <yan_> x0l: yes, even smaller than 256 bytes ( i assume you mean bits?)
13:48:56 <Eduard_Munteanu> yan_: in fact you can just apply that to the entire crypto task instead of individual operations
13:49:23 <x0l> yan_: how can u measure time so precisely ?
13:49:42 <shachaf> Recently someone suggested the approach of (compare `on` hmac k), where k is secret.
13:50:02 <Eduard_Munteanu> x0l: you can't measure it very precisely, but it still gives you much better odds than brute force.
13:50:05 <yan_> x0l: well a few ways. you first create other work on the machine to increase the number of times your 'target' will be preempted. you then run this compare a few hundreds of thousands of times, and look for irregularities
13:50:41 <Eduard_Munteanu> x0l: e.g. you may recover a fraction of the password by observing a few runs
13:50:43 <yan_> x0l: even easier, you first pick a target hash that starts with byte 0, try authenticating 1000 times. then, with next byte, and so on. one of those 256 authentication clusters will be faster
13:50:57 <x0l> ok, you have to have a lot of rights on the target computer
13:51:14 <yan_> x0l: yes, this is likely not going to work over a cellular network to a machine you don't control
13:51:18 <x0l> hehe
13:51:20 <yan_> but it might
13:51:33 <Eduard_Munteanu> x0l: it works over noisy channels too, like Ethernet
13:51:38 <x0l> i can't imagine it working over a network, latency would kill everything
13:51:47 <yan_> x0l: it's still possible
13:51:49 <zeiris> jitter
13:52:04 <merijn> x0l: I shall blow your mind
13:52:12 <x0l> really ?
13:52:13 <yan_> x0l: check out 'silence on the wire'
13:52:14 <Eduard_Munteanu> OS kernels are noisy too, mind.
13:52:15 <yan_> that book is amazing
13:52:16 <merijn> x0l: Last year there was a paper on sidechannel attacks
13:52:21 <yan_> for passive attacks
13:52:44 <merijn> x0l: They showed that they could attack 4096 bit PGP keys...BY LISTENING TO THE SOUND PRODUCED BY THE CPU WHILE DECODING
13:52:49 <yan_> x0l: http://en.wikipedia.org/wiki/Silence_on_the_Wire
13:52:53 <x0l> yup but sound is much more precise
13:52:55 <yan_> x0l: if you're interested in this style of attacks
13:52:59 <yan_> that book will blow your mind
13:53:02 <merijn> x0l: Worse, they didn't use some forensic microphone, they use a cellphone microphone...
13:53:13 <Eduard_Munteanu> @google tempest for eliza
13:53:14 <lambdabot> http://www.erikyyy.de/tempest/
13:53:14 <lambdabot> Title: Tempest for Eliza
13:53:22 <Eduard_Munteanu> x0l: ^^
13:53:29 <Eduard_Munteanu> Pretty old one.
13:53:36 <remaxerdeviator> If you would like to accept a challenge, download Candy Invasion on Play Store and TRY to beat the highscore of 3150
13:53:52 <yan_> ahh TEMPEST
13:54:01 <merijn> Public Service Announcement: NaCl was designed to be side channel free and provide high speed encoding/decoding, you should consider using it if you need crypto in the future
13:54:10 <yan_> merijn: ++
13:54:17 <x0l> tempest :) does it work with LCD ?
13:54:28 <yan_> merijn: agree absolutely, but this is after you get your NaCl'ed hash
13:54:28 <shachaf> thoughtpolice: How're those NaCl bindings going?
13:54:34 <zipper> Real World Haskell is a really big book. How long does a beginner take to finish it like on average?
13:54:41 <Eduard_Munteanu> x0l: not really, not as much
13:54:42 <yan_> and more of a proof of concept than a suggestion for a deployed system
13:54:47 <merijn> shachaf: They were mostly done last time I asked, usable but lacking polish
13:54:49 <x0l> ;) thought so
13:54:53 <johnw> zipper: you don't need to read it all straight through
13:54:57 --- mode: ChanServ set +o shachaf
13:55:01 --- mode: shachaf set +b *!*remaxer@*.ip206.fastwebnet.it
13:55:01 --- kick: remaxerdeviator was kicked by shachaf (remaxerdeviator)
13:55:03 --- mode: shachaf set -o shachaf
13:55:12 <x0l> but really cool thanks for the link
13:55:19 <zipper> johnw: Really? Can I just read the parts that look fun?
13:55:26 <johnw> zipper: why not?
13:55:47 <merijn> zipper: Yes, but they will assume some more advanced haskell knowledge, if you only read RWH you might get lost
13:55:58 <zipper> johnw: Because I thought it was like LYAH. You can't skip about in one IMO
13:56:12 <merijn> zipper: If you've read LYAH, you can easily skip around in RWH
13:56:19 <yan_> zipper: well try skipping first, if you don't understand something, go back and find where they explain it. repeat
13:56:22 <zipper> merijn: easily?
13:56:35 <merijn> zipper: Well, depending on how hard you found LYAH :)
13:56:38 <dagle> I'm using Aeson.TH to derive some json parsers. But I feel like Aeson reorders my structure and my json gets "backwards" (paste to explain it:
13:56:40 <rgr> currently my cabal doc index references html files installed as part of the ghc-doc package. Is there anything I can cabal install which produces cabal local versions of these docs?
13:56:49 <dagle> http://lpaste.net/5862929271583932416
13:56:49 <zipper> Also I am thinking of watching haskell from scratch right after LYAH
13:56:56 <zipper> A series on you tube
13:56:58 <jrmithdobbs> merijn: also worth looking at libsodium (usable nacl) and https://github.com/catid/tabby which is similar stuff using grp6a vhash and xchacha instead of curve2559/ploy1305 and xslasa
13:57:05 <merijn> zipper: RWH actually explains less haskell stuff than LYAH, it just explains more libraries
13:57:06 <x0l> zipper: read the part u need as u need them :)
13:57:43 <zipper> merijn: Have you watched those haskell from scratch videos?
13:57:59 <merijn> zipper: No, so I can't give any judgement on them
13:58:19 <jrmithdobbs> dagle: why do you care what order an underored list of tuples are in exactly?
13:58:45 <zipper> @seen jekor
13:58:45 <lambdabot> jExor
13:58:55 <zipper> WHat?
13:59:05 <zipper> This bot is weird
13:59:32 <x77686d> newbie still struggling with "action": It is correct to say, "getLine is an action; putStr is a function that returns an action."?
13:59:54 <zrho> Is there a way of combining two traversals of the same type to one, which traverses both ways?
14:00:05 <hpc> x77686d: yes
14:01:26 <merijn> zipper: lambdabot doesn't have a seen command, it autocorrect to @leet
14:01:34 <Twey> x77686d: That is absolutely correct
14:02:06 <Twey> :t putStr
14:02:07 <lambdabot> String -> IO ()
14:02:22 <Twey> x77686d: ‚ÄòIO a‚Äô is the type of IO actions that return a result of type a.
14:02:44 <merijn> x77686d: WHich also shows why haskell is pure (in the "functions always return the same result for the same argument" sense), because 'putStr "foo"' always returns the same action (one that prints "foo" when executed)
14:03:31 <x0l> x77686d: i would also say that getLine is a function that returns an action, it just takes () as it argument
14:03:48 <pjdelport> x0l: that's not quite right
14:03:50 <thoughtpolice> shachaf: i need to return and finish off one or two minor parts of the API, but the current GitHub repo is in a pretty good place and easier to use than the last one.
14:04:02 <x0l> pjdelport: regarding lazyness ?
14:04:39 <pjdelport> x0l: no, it's just that a nullary function (or value) is distinct from a unary function of ()
14:04:59 <pjdelport> if getLine took () as argument, you'd have to say "getline ()"
14:05:04 <x77686d> hpc and Twey: Thanks!  merijn -- your comment made me "get it"  THANKS!
14:05:05 <pjdelport> not just "getLine"
14:05:25 <x0l> pjdelport: what's the true difference ?
14:05:25 <thoughtpolice> shachaf: I think mainly I need to finish writing some docs, the scrypt integration for key-stretching, and the top-level Key API (which is mostly just some re-exports and maybe a tiny bit of shuffling stuff)
14:05:26 <jrmithdobbs> it's not a nullary function
14:05:29 <jrmithdobbs> it's a value
14:05:35 <dagle> jrmithdobbs: It doesn't really matter but I'm just wondering why... and it doesn't seem to matter if I reoder the datatype either.
14:05:38 <jrmithdobbs> the difference is it's not a function
14:05:41 <scott> getLine is simply an IO action that yields a String. It is not a function any more than the number 2 is.
14:06:10 <scott> You could say 2 is really a function that takes () and returns 2. But that would be wrong for the same reason.
14:06:25 <x0l> scott: why would that be wrong ?
14:06:26 <thoughtpolice> shachaf: oh, actually i think i finished the scrypt integration. but i also wanted to write a convenience API to encrypt files under AES-HMAC or somesuch with scrypt as a KDF (so you can e.g. trivially encrypt a secret key under a password.)
14:06:28 <jrmithdobbs> dagle: because the ordering is generated algorithmically without requiring an Enum constraint on the type
14:06:29 <pjdelport> :t getLine
14:06:30 <lambdabot> IO String
14:06:36 <pjdelport> :t let foo () = getLine in foo
14:06:37 <lambdabot> () -> IO String
14:06:45 <pjdelport> x0l: that's the difference, basically
14:06:46 <scott> x0l: There is no (->) in the type of getLine or 2. So neither are functions.
14:07:00 <jrmithdobbs> dagle: look at the derive functions in Data.Aeson.TH and becomes clearer why it seems to be arbitrary ordering
14:07:07 <shachaf> thoughtpolice: Are you sure all of that belongs in a NaCl package?
14:07:16 <jrmithdobbs> dagle: the "why" is because "it shouldn't matter"
14:07:18 <Twey> :t getLine
14:07:19 <lambdabot> IO String
14:07:24 <x0l> that's strange, i would have imagined that nullary function are totally equivalent to values
14:07:32 <pjdelport> x0l: they are
14:07:36 <merijn> x0l: You might wanna read this
14:07:39 <Twey> x0l: If it were a function that took a (), it would be of type () ‚Üí IO String
14:07:43 <zipper> OMFG! RWH has a part on STM
14:07:47 <merijn> @google conal Everything is a function in haskell
14:07:50 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
14:07:50 <lambdabot> Title: Conal Elliott ¬ª ‚ÄúEverything is a function‚Äù in Haskell?
14:07:50 <pjdelport> x0l: a function that takes () is unary, not nullary
14:07:52 <jrmithdobbs> scott: you could say that, but you'd be wrong
14:08:02 <scott> jrmithdobbs: Hmm?
14:08:05 <pjdelport> () is a value like any other
14:08:06 <Twey> x0l: A function that takes () is *equivalent* to a value, but that's not the *same thing* as a value
14:08:30 <Twey> (for some value of ‚Äòequivalent‚Äô)
14:08:32 <zipper> Everything is a function while everything is a file in Unix
14:08:49 <ndeine> therefore, files are functions
14:08:54 <merijn> x0l: That blog post is a quite nice overview over the confusion that "everything is a function" in haskell
14:09:01 <zipper> ndeine: No way jose
14:09:07 <ndeine> zipper: /joke
14:09:12 <zipper> ndeine: lol
14:09:19 <x0l> merijn: thanks
14:09:19 <jrmithdobbs> scott: misread
14:10:41 <thoughtpolice> shachaf: there are a small amount of out-of-band additions, mostly scrypt and some extra hashes. none of the extras (except for scrypt) are exported by default and you have to opt into them explicitly. IMO, adding an easy-to-use KDF is fairly reasonable 'default' addition, since people will want it (and they could use it for password hashing too, for example.)
14:11:10 <thoughtpolice> otherwise the API essentially matches what NaCl itself offers quite closely, and the default primitives are all the exact same
14:11:41 <merijn> Which makes sense, since teh NaCl API is already fairly high level :)
14:11:42 <shachaf> I think a second package for these things wouldn't be so bad.
14:11:45 <jrmithdobbs> thoughtpolice: with libsodium? because that's not really true depending on which bindings you're using
14:11:47 <jfischoff> zipper: it does, but simon marlow's book is the best way to learn about it I've found
14:11:50 <thoughtpolice> jrmithdobbs: no
14:12:29 <jophish_> One can use Foldable and Traversable to go over the leaves of a tree like structure. What's the name for something which goes over the nodes and the leaves in a depth first order?
14:12:39 <shachaf> thoughtpolice: What's "encrypt files under AES-HMAC"?
14:12:48 <jophish_> depthFirstTraverseStoppingAtBranches?
14:12:56 <thoughtpolice> jrmithdobbs: libsodium in the same vein does not change the defaults from the selected nacl defaults either AFAIK. they should all be compatible when using the default API selections
14:13:12 <thoughtpolice> although libsodium has a few more additions too
14:13:16 <zipper> In the case of Line buffering, IO and laziness. We have thunk in memory then when we want to work on the data in a file. So we get a line and store it in memory then process it? I fail to understand buffers in I/O.
14:13:24 <jrmithdobbs> thoughtpolice: it does now, it changes the hashes to blake2 and uses the updated dh stuff from supercop
14:13:51 <jrmithdobbs> thoughtpolice: (not bad things)
14:13:54 <zipper> jfischoff: Is that a book I can read right after LYAH?
14:14:22 <thoughtpolice> i have BLAKE2 support. i'm still not changing the default
14:14:45 <thoughtpolice> as for improved DH, i assume you mean curve25519-donna. i am also using this implementation
14:15:02 <thoughtpolice> (which is exactly compatible with the default version, just a lot faster)
14:15:39 <jrmithdobbs> thoughtpolice: err, not the dh function, the crypto_box asym stuff
14:15:49 <biscarch> Can anyone take a look at this FromJSON instance? https://gist.github.com/ChristopherBiscardi/330aac423f32f1c4d780#file-gistfile1-hs
14:16:00 <awestroke> how do I get packages? I want to use http://hackage.haskell.org/package/mbox-0.1/docs/Data-MBox.html . Should I just copy the source file into my project?
14:16:22 <geekosaur> cabal install mbox-0.1
14:16:22 <merijn> awestroke: "cabal install <package name>"
14:16:24 * hackagebot chell 0.3.2 - A simple and intuitive library for automated testing.  http://hackage.haskell.org/package/chell-0.3.2 (JohnMillikin)
14:16:30 <merijn> awestroke: So in this case "cabal install mbox"
14:16:31 <biscarch> I'm trying to pass the entire object to create two different datatypes, one of which is polymorphic.
14:17:21 <biscarch> Ideally constrained by (FromJSON a), but I'm not sure if that should be part of the data declaration
14:18:45 <Thulsadum> :t scanl
14:18:46 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
14:19:07 <dagle> jrmithdobbs: Took some time to make sense of it. :)
14:20:42 <thoughtpolice> jrmithdobbs: i'm not sure what you mean. sodium still uses curve25519-XSalsa/20-Poly1305. it's unlikely this will ever change based on some of the things i've seen said from Frank (the author)
14:21:25 <thoughtpolice> in any case, i'm not using sodium for the benefit of windows users so they don't have to subject themselves to autoconf. my library is just composed of portable C code
14:21:35 <zipper> I swear this you tube video just changed my life! https://www.youtube.com/watch?v=hO8MwBZl-Vc
14:21:41 <thoughtpolice> (it could constitute a reasonably fast, no-nonsense NaCl implementation in itself. the code is mostly from SUPERCOP and NaCl itself.)
14:21:42 <zipper> Leadership From A Dancing Guy
14:22:01 <zipper> I don't care what anyone says anymore!
14:22:09 <awestroke> merijn: thanks
14:22:19 <schell> what's the difference between isomorphic and zygomorphic?
14:22:19 <biscarch> here it is with the error (forgot the error before) http://lpaste.net/1063917202274516992
14:25:31 <awestroke> do you guys think it's ok to scrape the latest mboxes on http://www.haskell.org/pipermail/beginners/ every day or so?
14:31:14 <x77686d> I'm wresting more with pure functions and actions.  Is it correct to say that 'twice x = putStr x >> putStr x' is pure because that for a given value of x it always returns the same action?
14:32:17 <monochrom> I say yes
14:32:28 <monochrom> but I don't consider it important.
14:32:44 <scshunt> x77686d: It depends on your perspective
14:33:20 <scshunt> if you view it in terms of returning an action, then yes, since as you noted the action depends only on the inputs
14:33:45 <scshunt> but it does still have side-effects when evaluated in an IO context
14:33:53 <monochrom> this is the only important point I care: if a program is full of "putStr haha >> putStr haha", and I replace them by "twice haha", that does not change behaviour, especially I/O "side effect" behaviour. and vice versa.
14:34:13 <pjdelport> x77686d: In the sense of referential transparency, everything in Haskell is pure (modulo things that explicitly break the rules, like unsafePerformIO)
14:34:22 <yan_> monochrom: i believe that's a pretty important facet of type systems in general.. the rewriting rule
14:34:36 <yan_> monochrom: either type systems or abstract interpretation.. some papers i've been reading are jumbled in my head :)
14:34:45 <kadoban_> x77686d: if you're getting into it that deep, you probably understand well enough for any practical purpose. there isn't going to be a quiz at the end with a bunch of trick questions on it
14:35:09 <monochrom> I don't care about what means "pure" and what means "referential transparency" etc. I only care about substituting equal for equal. it is the most basic reasoning tool.
14:35:21 <monochrom> http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
14:35:50 <scshunt> monochrom: that's referential transparency
14:36:05 <monochrom> well ok, but I know that other people disagree
14:36:07 <scshunt> it means that a function and its result are interchangeable
14:36:20 <monochrom> discuss with ski
14:36:53 <pjdelport> schell: What do you mean?
14:36:55 <monochrom> and read that huge thread on stackoverflow where people become polarized on what it means
14:37:12 <monochrom> apparently, "referential transparency" is not referentially transparent!
14:37:52 <schell> oh - i was just reading the haskell wiki and it mentioned a zygomorphism, which i then looked up - which means 'bilaterally symmetrical', which kinda sounds like an isomorphism
14:38:04 <schell> isomorphism is one to one mapping, right?
14:38:10 <monochrom> it is why I decided to ditch it and just focus on Leibniz's law. it's so much simpler and more obvious.
14:38:28 <schell> "this thing wholly represents this other thing"
14:38:55 <schell> and zygomorphism seems to mean "mirror image" but i don't know how that applies to code
14:38:57 <pjdelport> schell: I think that sense of "zygomorphism" is from botany, and isn't really applicable to Haskell.
14:39:17 <schell> right - i just can't find any other definition
14:39:26 <pjdelport> There is such a thing as a zygomorphism in Haskell and category theory, but it's a lot more technical
14:40:05 <pjdelport> I don't think it's comparable to the concept of isomorphism.
14:41:00 <pjdelport> schell: See e.g. http://comonad.com/reader/2008/elgot-coalgebras/
14:41:31 <schell> pjdelport: thanks :)
14:42:19 <StoneCypher> is there any kind of obscure language feature that could legitimately be called "thanks"
14:42:29 <StoneCypher> i figure if anyone's going to know it's going to be you people or the ocaml crowd
14:43:03 <merijn> x77686d: I would argue the following are all pure, as they can all be substituted for each other without change "\x -> putStr x >> putStr x", "let twice x = x >> x in \x -> twice (putStr x)", "let printTwice x = putStr x >> putStr x in \x -> printTwice x"
14:43:15 <pjdelport> StoneCypher: maybe if someone hybridizes Intercal and Haskell
14:43:53 <monochrom> finalizers can be called "thanks". because "thank God it's over". :)
14:44:08 * StoneCypher wants to write a library called obama and needs something to put into it
14:44:08 <ion> Intercurry
14:44:34 <monochrom> hascal
14:44:44 <StoneCypher> monochrom: :O
14:44:53 <ocfx> lol hascal
14:45:12 * monochrom is a genius
14:45:17 <ocfx> havascript
14:45:40 <Scorchin> Hello. I'm trying to create a simple card shuffler program in Haskell. So far, I have my suits: data Suit = Club | Diamond | Heart | Spade deriving (Ord, Enum, Bounded, Eq, Show) ... but I'm not sure how best to define my ranks. Can you do something like the following in Haskell? type Rank = Ace | King | Queen | Jack | Value of int(2..10) deriving (Ord,
14:45:40 <Scorchin> Enum, Bounded, Eq, Show)
14:45:43 <Scorchin> type Rank = Ace | King | Queen | Jack | Value of int(2..10) deriving (Ord, Enum, Bounded, Eq, Show)
14:45:51 <Scorchin> Any help would be much appreciated
14:46:53 <pantsman> haskbol
14:47:36 <pjdelport> Scorchin: not like that; you'll have to write the ranks out, or just use integers
14:48:28 <pranz> Scorchin: data Rank = Ace | King | ... | Unclothed Int
14:49:06 <pranz> Scorchin: but you can't restrict the Int
14:49:25 <Scorchin> pranz: okay, thanks
14:49:26 <pranz> Scorchin: I would recommend to represent the rank with only integers
14:49:56 <pranz> and then have a custom show function that would prettyprint the rank, if that's what you want
14:50:31 <pjdelport> Scorchin: Why not just write them out? They are symbolic in this context, after all.
14:50:58 <Scorchin> pranz: can you mix between the two? So Queen | Jack | 10 | 9 ?
14:51:05 <Scorchin> Or is that not allowed?
14:51:29 <pranz> Scorchin: no, since 10 and 9 is a different data type
14:51:58 <Scorchin> Okay, thanks
14:52:21 <merijn> pranz, Scorchin: More correctly, that's not allowed because 10 and 9 are not valid names for constructors
14:53:04 <merijn> pranz, Scorchin: Constructors must be all text (including numbers) or all operators and start with either a capital letter or a :
14:53:23 <Scorchin> merijn, pranz: Thanks!
14:54:09 <pjdelport> Scorchin: Ten | Nine | ... or Rank10 | Rank9 | ...
14:54:26 <Twey> Neither can start with a number, of course
14:54:35 <pjdelport> or R10, R9, ...
14:54:53 <Twey> ' behaves the same as a number; _ works like a lower-case letter
14:55:47 <Twey> Scorchin: You can have, e.g. data Rank = King | Queen | Jack | Number Int
14:56:16 <nooodl> ew :(
14:56:21 <Twey> But I don't advise it; it would be better to define one constructor for each rank, since then your ranks fit exactly in your datatype
14:56:49 <Twey> Oh, I see pranz already suggested that
14:57:30 <erisco> particularly you do not want to give the potential for "Rank 11" or "Rank -1" or something else nonsensical
14:57:48 <Twey> Indeed
14:58:10 <Twey> I miss Fin ‚òπ
14:58:51 <rgr> I underetanmd the ghc.types is tightly integrated with the ghc compiler but is there a way to install the relevant files via cabal so that I can generate local .cabal html info for ghc.types?
14:59:33 <Twey> rgr: Sure, you can get the GHC source and generate documentation for it
15:01:01 <rgr> there#s no cabal install? maybe I'm not seeing the correct boundary between cabal and ghc here.
15:01:36 <rgr> obviously I can install ghc-doc but I really want to distance myself from the debian packaging.
15:01:37 <Twey> rgr: You can't cabal install ghc, no
15:01:52 <Twey> But you can download the GHC source and run ‚Äòcabal haddock‚Äô
15:02:07 <Twey> (in the appropriate directory)
15:02:22 <rgr> I guess I can then configure cabal to find those docs for the update of index.html?
15:03:03 <rgr> (Id like to be able to tar up .cabal and .ghc for a complete documented setup)
15:03:29 <Twey> I'm not sure how Haddock finds things to link to
15:03:33 <Twey> Fuuzetsu probably knows
15:03:57 <Twey> But I don't really advise archiving your .ghc, since it's going to be quite machine-specific
15:05:05 <rgr> ok thanks. I'll keep it in mind.
15:07:02 <rgr> but why haskell-platform download doesnt seem to include ghc I'm not sure. maybe its not made by default.
15:07:59 <merijn> rgr: Linux?
15:08:04 <rgr> yes
15:08:25 <merijn> rgr: Linux package managers have a tendency to strip out haskell docs, profiling libraries, etc.
15:08:41 <merijn> My OSX install of platform shipped with docs for GHC libraries by default
15:09:20 <rgr> yeah I know. But I want to move away from the debian packages. I assumed a downloaded haskell-platform would include ghc too.
15:09:37 <rgr> I want to have .cabal local docs for the base.
15:10:29 <Clint> debian has -dev, -doc, and -prof .debs
15:14:21 <Fuuzetsu> have I been summoned?
15:18:08 <Twey> Fuuzetsu: rgr was interested in knowing some stuff about Haddock, but you're too late
15:20:47 <Scorchin> I've got the following, but I want to shuffle the deck of cards. Any ideas on how I can do that?
15:21:18 <Scorchin> https://www.irccloud.com/pastebin/vrphZ3rW
15:21:35 <Scorchin> Also appreciate any thoughts on how it can be improved
15:22:00 <Clint> Scorchin: http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
15:22:16 <c_wraith> I really don't like that package
15:23:00 <Twey> Why?
15:23:18 <c_wraith> It gets the type signature of shuffle' wrong
15:23:43 <Clint> you want gen first?
15:23:54 <Scorchin> Clint: do I need to implement my own shuffler?
15:24:03 <Scorchin> That suggests it's only available for Int
15:24:04 <Twey> shuffle' ‚à∑ RandomGen g ‚áí gen ‚Üí [a] ‚Üí [a] ?
15:24:22 <c_wraith> shuffle' :: RandomGen g => [a] -> g -> ([a], g)
15:24:29 <Twey> Scorchin: You're misreading it
15:24:39 <Twey> Scorchin: The [a] is the input data
15:24:41 <c_wraith> you know, so that it works properly with everything else that uses RandomGen values
15:24:46 <Clint> fair enough
15:24:56 <Twey> c_wraith: True that
15:25:06 <Twey> I guess shuffleM is okay
15:25:12 <Twey> ‚Ä¶ wait
15:25:39 <Twey> Heh
15:26:09 <joelteon> does anybody know what this is? http://hackage.haskell.org/package/haskell-src-exts-1.14.0.1/docs/Language-Haskell-Exts-Syntax.html#v:GenPragma
15:26:10 <Scorchin> Should that be in the standard library? I'm getting the following error: Could not find module `System.Random.Shuffle'
15:26:11 <Twey> ¬´ shuffle' wrapped in a random monad ¬ª ‚Äî except it's not, because shuffle' doesn't return the new generator
15:26:25 <Twey> Scorchin: It's not, it's in the random-shuffle package
15:27:14 <c_wraith> Also, that problem can be solved more efficiently with ST, so it sort of bugs me that it doesn't use ST.
15:27:37 <Twey> The MonadRandom can use ST
15:28:27 <Twey> joelteon: Huh, never seen that before.  Doesn't seem to be documented.
15:28:43 <c_wraith> Twey: that's the wrong thing. :)
15:28:59 <joelteon> not so well
15:29:02 <Twey> c_wraith: Why?
15:29:25 <c_wraith> Twey: It still calls shuffle, so it will still construct a tree, rather than do an array-based shuffle in ST
15:29:37 <Twey> Oh, right!
15:29:45 <Twey> That's not what I thought you meant.
15:30:00 <Twey> I think this is pre-ST
15:30:14 <c_wraith> ...  ST came from the same paper that IO did. :P
15:30:16 <ski> x77686d,scshunt : `putStr x' has no side-effects, it has (I/O) effects
15:30:23 <ski> yan_ : that rewriting is about axiomatic (or perhaps operational) semantics, not about type systems or (at least directly) abstract interpretation
15:30:26 <ski> scshunt : properly speaking, "referential transparency" is a property of a *context* (not of an expression)
15:30:46 <Twey> c_wraith: We haven't had it in Haskell all that long, though, have we?
15:31:11 <Twey> Needs Rank2Types
15:31:14 <c_wraith> Dunno.  It predates me, but I started at about the same time GHC 6.10 came out.
15:31:25 <c_wraith> All told, GHC 6.10 is pretty recent
15:31:30 <Twey> Yeah
15:31:52 <Twey> I've been in it since (I think?) about GHC 6.2, and I remember hearing about ST a fair bit later
15:32:08 <Twey> Though that's no indication of when it actually went in, just when it got popular :√æ
15:32:31 <c_wraith> Scorchin: Give me an hour and I'll have an efficient and lazy shuffle using ST and vector. :)
15:32:51 <Scorchin> I have no idea what you're talking about, but okay
15:33:00 <Scorchin> :)
15:34:37 <erisco> Scorchin, vectors are stored in sequential memory and have constant access time. ST is a monad that allows one to work with mutable state. Together, you can implement a Fisher-Yates shuffle in constant space and linear time
15:34:59 <c_wraith> Not quite constant space since you need to copy the list to a vector to start with
15:35:25 <Scorchin> erisco: Is that something that I implement or something that gets opimised out by the compiler? I can't see how code I write in haskell would express that detail. Unless it's a very verbose statement.
15:35:33 <erisco> well I was presuming we were starting with a mutable vector, but if coming from a list, then yes, linear space is needed for copying
15:35:42 <Scorchin> Worth saying, there's a good chance I'm missing something. I'm new to all of this.
15:35:43 <c_wraith> Scorchin: well, stick around and check out my code in a bit. :)
15:36:20 <erisco> Scorchin, I am not sure what you are asking about in particular. I was explaining the relevance of ST and what algorithm c_wraith was likely after
15:39:34 <kazagistar> is there any way to resolve this ambiguity? (I tried to keep only the related bits) http://lpaste.net/99884
15:41:11 <merijn> kazagistar: Since there is no 'a' in the outer signature it can't decide which "a" the operation is supposed to work on
15:41:35 * hackagebot hOpenPGP 1.0 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.0 (ClintAdams)
15:41:55 <merijn> kazagistar: The easiest way would probably be to add a "Proxy a" argument to storeOp to force which 'a' it selects
15:41:55 <Eduard_Munteanu> kazagistar: perhaps you want Operation o ()?
15:42:05 <merijn> Eduard_Munteanu: That seems pointless
15:42:39 <Eduard_Munteanu> Hm, I was looking at his storeOp type
15:42:49 <Eduard_Munteanu> Yeah, I guess I misread.
15:43:09 <ski> kazagistar : it doesn't know the number of elements in the list until run-time
15:43:10 <Scorchin> I think I'm out of my depth for this one. If I have a list holding a type 'Card'. How do I shuffle the list?
15:43:20 <Scorchin> I've imported the right module: import System.Random
15:43:25 <merijn> kazagistar: i.e. make it: "storeOp :: (Operation o a, Storable a) => Proxy a -> o -> [Address] -> Instruction ()" and it should work
15:43:27 <Scorchin> which means shuffle must be available
15:44:05 <Eduard_Munteanu> Scorchin: an easy way is to generate a list of numbers, zip it with the cards list and sort
15:44:14 <ski> kazagistar : also, is there any reason to not make it work for arbitrary length lists ?
15:44:29 <merijn> Scorchin: The simplest most accurate shuffle is "\randomList -> map snd . sortBy (comparing fst) . zip randomList"
15:44:45 <ski> hm
15:45:05 <[swift]> Scorchin: i see shuffle in System.RAndom.Shuffle, which is in the random-shuffle package
15:45:20 <[swift]> maybe that's what you were looking for?
15:45:26 <ski> kazagistar : oh, i suppose you wanted the provided operation to determine the expected length of the list
15:45:27 <Twey> merijn: Adding a Proxy a still wouldn't help, would it?  You'd need to pass it to either liftOp or save'
15:45:56 <ski> Twey : why ?
15:45:57 <merijn> Twey: It should, the Proxy would force the instance selection of Operation
15:46:10 <merijn> Twey: Once the instance is selected GHC can propagate it no problem
15:46:11 <Twey> Oh, right, forgot about Operation.  Never mind.
15:46:26 <Scorchin> I'm using v7.6.3. Maybe I'm out of date?
15:46:32 <kazagistar> ski: well, the lists represent which addresses to load data from when you lift a function into an Instruction
15:46:43 <merijn> Scorchin: random-shuffle is a separate package, it doesn't come with GHC
15:47:03 <merijn> kazagistar: The problem is that your type works for any 'a' and GHC doesn't know which 'a' you want
15:47:14 <ski> kazagistar : i suspect you want to express `Operation' recursively, and get a better base case than `Operation b b√§
15:47:20 <Twey> Scorchin: You'll need to cabal install random-shuffle, then import System.Random.Shuffle.  But I'd wait for c_wraith's Vector version.
15:47:28 <merijn> kazagistar: My Proxy solution explictily refers to 'a', thus solving the indecision of GHC
15:47:35 <ski> kazagistar : yeah, i just (above) realized you passed in the function to apply
15:47:38 <Scorchin> Ah, that explains it
15:47:50 <c_wraith> I'm way overengineering this.  This is going to be silly, sorry.
15:48:09 <ski> kazagistar : what is the typical types of your operation functions ?
15:48:13 <Twey> c_wraith: We don't engineer things in Haskell, we *abstract* them.
15:48:27 <c_wraith> No, this is definitely engineering.
15:48:44 <merijn> c_wraith: It involves concrete and drawings?
15:48:52 <kazagistar> ski:  MInt -> MInt -> MInt
15:48:57 <c_wraith> and rebar
15:49:00 <Twey> Heh.
15:49:22 <kazagistar> merijn: so its just an extra parameter that holds the desired type?
15:49:32 <hpc> kazagistar: for a minty fresh clean API
15:50:26 <ski> kazagistar : would `instance Operation MInt MInt' work as a base case then ?
15:51:08 <ski> kazagistar : with `instance (Storable a,Operation b c) => Operation (a -> b) c' as recursive case ?
15:52:39 <kazagistar> ski: the problem is, the result is the one part that does not always have to be MInt, or even storable, but that looks like it might work
15:53:02 <merijn> kazagistar: Yes, Proxy is just a nicer alternative to passing "undefined :: MyType" as an argument
15:53:45 <merijn> kazagistar: The only thing it does in my example is force GHC into seeing which 'a' (and thus which instance of the Operation typeclass!) you wanted
15:54:15 <kazagistar> merijn: something about that bothers me, but I guess I can deal with it‚Ä¶
15:54:35 <merijn> kazagistar: The problem is the "Operation" instance is selected from the type
15:54:51 <merijn> kazagistar: And since 'a' isn't mentioned in the type GHC is allowed to pick *any* 'a'
15:54:59 <ski> kazagistar : if there's a fixed finite number of possible result types. you could enumerate
15:55:10 <ski> kazagistar : but first try merijn's suggestion
15:55:22 <merijn> kazagistar: So rather than try and guess what you meant, it complains and says "this ambiguous" (i.e. I don't understand what you want from me)
15:56:01 <kazagistar> ski: the number of storables will never change from 3
15:56:07 <ski> hm, i wonder whether there should be an FD `o -> a' on `Operation o a'
15:56:25 <merijn> ski: Yeah, I figured there might be a FunDep way to solve it
15:56:38 <ski> adding an FD would avoid the `Proxy' business
15:56:42 <merijn> ski: But it's later, I spent the entire day writing so I couldn't be arsed to try and think of one :)
15:57:00 <ski> kazagistar : is the type of an operation meant to determine the return type ?
15:57:00 <merijn> kazagistar: Check out the "Fun with Fun Deps" paper for more on that approach
15:57:17 <merijn> kazagistar: It looks like it'll probably work, but I'm to tired to be sure :)
15:57:21 <ski> kazagistar : or can the same operation usefully be considered as having several distinct return types here ?
15:58:25 <ski> kazagistar : e.g. `MInt -> MInt -> MInt' being viewed as taking two `MInt's and returning an `MInt', or alternatively being regarded as `MInt -> (MInt -> MInt)', so taking a single `MInt', and returning an `MInt -> MInt' (to be stored at the address in question) ?
16:21:13 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
16:21:13 --- topic: set by monochrom on [Sat Nov 23 20:32:31 2013]
16:21:26 <greg`> and made an instance of the arbitary class
16:23:00 <greg`> there was an interesting problem with STM that they raised
16:23:59 <greg`> apparently, if you want to read a large amount of data atomically while others are continually updating it you get starved out
16:25:11 <Twey> greg`: STM works by running the whole atomic computation over and over (reversing it when it fails) until you get through it all without someone updating your value halfway through
16:25:21 <Twey> It's not an elegant solution, just convenient :√æ
16:26:02 <greg`> yeah but there was some talk saying that because the data structures are immutable you should be able to read only
16:26:04 <Scorchin> Aha! I think I've finally got it:
16:26:09 <Scorchin> https://www.irccloud.com/pastebin/dXYJGDXw
16:26:16 <Scorchin> that's a card shuffler using random-shuffle
16:26:20 <Scorchin> thanks all!
16:26:24 <kazagistar> the new intel chips support hardware transactional memory which is actually pretty neat
16:26:51 <Twey> That's cool
16:26:55 <Twey> Does GHC take advantage of that?
16:27:21 <greg`> whats the chip called
16:27:51 <kazagistar> greg`: Haswell has it I think
16:28:19 <kazagistar> http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions
16:28:23 <greg`> if ghc isnt taking advantage of it now , i imagine it will soon
16:29:52 <Twey> I wonder how that will work via the LLVM generator
16:30:11 <greg`> Schorchin or you could make Card and instance of RandomGen
16:30:12 <Twey> Does LLVM provide facilities to access hardware-specific features?
16:30:27 <greg`> delegate to StdGen mostly
16:30:30 <Twey> greg`: That's not quite the same thing as a shuffle
16:30:57 <greg`> ah thats true
16:31:05 <Twey> greg`: randoms will give you duplicates, and isn't guaranteed to ever give you a full set of the possibilities
16:32:54 <greg`> anyone from the uk online?
16:33:30 <Twey> greg`: Hello
16:34:16 <greg`> oh hello! :) just wondered how well the uk haskell contingent is represented in irc
16:34:43 <Twey> Pretty well, I think.
16:34:45 <greg`> do you work with haskell
16:34:55 <Twey> In a manner of speaking ‚Äî I'm a student
16:35:40 <greg`> ah ok not that many haskell jobs on at the moment
16:36:05 <Twey> Not jobs, no
16:36:09 <Twey> Plenty of research positions, though
16:36:50 <greg`> oh really ?! sounds good, where do you see those/
16:37:40 <erisco> jeepers HXT is huge
16:38:07 <greg`> erisco: whats HXT
16:38:29 <erisco> http://www.haskell.org/haskellwiki/HXT
16:38:55 <Twey> greg`: Well, I've heard there are.  The UK seems to be big on Haskell in research in general.  I know SPJ was looking to recruit people to explore session types in Haskell recently.
16:39:01 <jrmithdobbs> whoever fixed GND really deserves a hug or something. newtype ... deriving (Data,Typeable,NFData,Hashable,Monoid) makes me so very happy.
16:39:05 <Twey> erisco: It is, and rather memory-hungry
16:39:30 <erisco> honestly all I need is to read a well-formed HTML document and to get a parse tree. nothing else
16:39:44 <erisco> I'll keeping prodding away at HXT if there is nothing else viable
16:39:45 <AlainODea> greg`: Haskell jobs get posted fairly regularly to https://twitter.com/functionaljobs
16:40:01 <jrmithdobbs> erisco: well-formed html parse tree? i see what you did there
16:40:06 <erisco> I am sure it is not difficult with HXT at all but finding the functions is difficult
16:40:11 <Twey> Hey, there's a whole Twitter feed?
16:40:45 <erisco> jrmithdobbs, what, did I imply that HTML is not typically well-formed or something? :)
16:41:05 <jrmithdobbs> erisco: no you pretended like it ever was, there's the problem ;p
16:41:13 <jrmithdobbs> s/was/is/
16:41:31 <Twey> erisco: You might prefer something like HandsomeSoup
16:41:44 * hackagebot hopenpgp-tools 0.4.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.4.1 (ClintAdams)
16:42:46 * ski . o O ( "Propositions as Sessions" by Philip Wadler in 2012 at <http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-sessions/propositions-as-sessions.pdf> )
16:44:29 <zxtx> anybody around I can ask ad question to
16:44:30 <Twey> ski: Propositions = games = sessions = types = spaces‚Ä¶ exciting times!
16:44:55 <zxtx> I have no idea about all these types I
16:45:00 <zxtx> I'm getting tangled in
16:45:40 <ski> Twey : it's a fun paper :)
16:45:50 * ski did a presentation based on it
16:46:21 <ski> zxtx : just ask your question ?
16:46:45 <zxtx> so I am trying to autodiff the gamma function
16:46:52 <zxtx> Both from Math.Gamma
16:46:59 <zxtx> and math-functions
16:48:38 <Twey> ski: Ha, I was actually just playing about with session types and a œÄ-calculus
16:48:42 <c_wraith> Scorchin: This is dumbly overengineered, but...  http://lpaste.net/99888
16:48:52 <zxtx> I get these errors http://lpaste.net/99889
16:49:10 <zxtx> now gamma and logGamma are both of type Double -> Double
16:49:37 <zxtx> and I don't get why (diff sin) works even though sin is also Double -> Double
16:49:40 <ski> @type sin
16:49:53 <lambdabot> Floating a => a -> a
16:53:13 <pavonia> zxtx: What is diff?
16:53:13 <zxtx> diff is from ed kmett's automatic differentiation library
16:53:13 <ski>   diff :: Num a => (forall s. Mode s => AD s a -> AD s a) -> a -> a
16:53:13 <edwardk> :t sin
16:53:13 <lambdabot> Floating a => a -> a
16:53:13 <edwardk> notice diff works for any Floating a
16:53:13 <ski> `diff' requires a (sufficiently) polymorphic function as argument
16:53:13 <zxtx> Num a =>     (forall (s :: * -> *). Mode s => AD s a -> AD s a) -> a -> a
16:53:13 <edwardk> AD s a  is Floating if a is Floating and s is a Mode
16:53:13 <Scorchin> c_wraith: I think I'll use that to
16:53:13 <zxtx> how do I make it work with a Double -> Double
16:53:13 <edwardk> zxtx: you don't
16:53:13 <edwardk> Double -> Double is too specific for me to plumb the metainformation about derivatives through
16:53:13 <zxtx> so how to do I auto-diff gamma
16:53:13 <Scorchin>  c_wraith I think I'll use that to learn more Haskell on my journey. Not really sure what it does at the moment.
16:53:13 <ski>   gamma :: Gamma a => a -> a  -- where `class (Eq a, Floating a, Factorial a) => Gamma a'
16:53:14 <zxtx> when I tried with Math.Gamma, I says I need to make a instance of some internal AD type
16:53:32 <c_wraith> Scorchin: it's smashing the standard imperative fisher-yates shuffle with haskell's lazy lists.
16:53:50 <edwardk> zxtx: what is needed is an instance (Mode s, Gamma a) => Gamma (AD s a)    but i'll be honest, it'd be pretty hard to write with the current exposed API for ad 3.4
16:54:07 <zxtx> where is the difficulty?
16:54:26 <erisco> how does one handle document errors with HXT? I cannot find this documentation
16:54:57 <edwardk> zxtx: long story short with ad 3.4 it is very hard to define new 'primitive' operations with known jacobians
16:54:57 <edwardk> gamma would be such a primitive operation
16:55:00 <nect> Would anyone be willing to help me out in casting / unpacking 4 bytes received over a network socket to an Int32?  I'm fairly new to writing haskell.  The four bytes are a message length prefix.  http://lpaste.net/99886
16:55:17 <edwardk> given just the information in Gamma, you don't have enough to write the instance of Gamma for AD s a
16:55:28 <edwardk> we don't have the derivative of the gamma function for instance
16:55:45 <edwardk> it is just a big black box that spits out an approximately correct number
16:56:04 <zxtx> but the point of AD is I don't need to know the derivative of gamma
16:57:01 <edwardk> and that is the case if gamma is made up of more primitive operations. but it isn't written that way
16:57:03 <edwardk> if gamma was defined in terms of parts we already knew you could do just that
16:57:27 <zxtx> well Math.Gamma seems to be http://hackage.haskell.org/package/gamma-0.7.0.1/docs/src/Math-Gamma.html
16:57:33 <edwardk> the type is too restricted for AD to see inside to use the operations it uses to approximate gamma
16:57:33 <rgr> lambdabot build ... downloading "brainfuck"... nice.
17:39:35 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
17:39:35 --- topic: set by monochrom on [Sat Nov 23 20:32:31 2013]
17:39:59 <edwardk> the prism is just something i felt i should offer as the laws then enforce the injectivity
17:40:01 <Rotaerk_> though maybe I should consider that as a possibility... it may open up an architecture possibility
17:41:11 <Rotaerk_> what I'm trying to do is have a bunch of concept-based components that are composed into a game... each component provides its own events, and the game itself has an event type that is a union of all the components' events
17:42:05 <Rotaerk_> so the game-level logic is responsible for routing the component-specific events to the right place
17:42:18 <Rotaerk_> haven't figured out how to do that without a lot of boilerplate
17:42:33 <Rotaerk_> but haven't actually written it yet...
18:02:14 <ddere> are there any instructive examples of web apps written in Fay out there that anyone can point me too? I want to get into it
18:05:01 <jle`> ddere: full web apps? or scripts and assorted things like that
18:05:25 <ddere> "full" web apps, i'm looking for inspiration about how oo build bigger things with it
18:05:49 <orzo> is there some way to tell cabal to use a different output directory for teh build than the default dist/ ?
18:06:09 <dhrosa> @pl \x n -> n + 1
18:06:09 <lambdabot> const (1 +)
18:06:18 <ddere> orzo: --builddir=DIR
18:06:28 <orzo> ddere: to what? configure?
18:06:34 <ddere> cabal build
18:06:39 <ddere> or install
18:06:45 <orzo> ddere: I'd like to set a default in .cabal/config if that's possible
18:07:12 <ddere> hmm it looks liek cabal configure accepts it too
18:07:19 <ddere> ah i see
18:07:23 <zrho> ah, I love Haskell. I needed a union-find library, installed some random one from hackage and it works on the first try.
18:08:45 <augur> is there a version of lines that can deal with funky encodings like using \r instead of \n
18:10:13 <zrho> Is there a library for manipulating sketches (the category theory ones), and possibly generating Hask models or test properties for them?
18:11:00 <djahandarie> There's a bit of an elephant in the room regarding that.
18:11:05 <ddere> orzo: try adding `builddir` to your cabal config file, i've never tried it but it looks like it probably works
18:11:56 <ddere> jle`: "full" web apps, i'm looking for inspiration about how oo build bigger things with it
18:12:38 <orzo> ddere: tried already, no go
18:12:46 <ddere> orzo: :(
18:13:13 <ddere> orzo: why do you need to do it?
18:13:19 * ski 94
18:13:22 <augur> oookay, this is confusing
18:13:43 <augur> im loading a file which explicitly has \n for lines, at least according to my editor
18:13:47 <orzo> well i have chroots with different versions of ghc and libraries, and i want to be able to build on both conveniently
18:13:56 <augur> but reading the file nto haskell shows \r
18:14:28 <geekosaur> amke sure your editor isn't lying, a lot of them do these days
18:14:50 <ddere> orzo: oh i see and so you want to send the builds to diff dirs
18:14:55 <orzo> yeah
18:15:03 <Luke> hvr: where will snippets show up in the packaged release of haskell-mode?
18:16:05 <orzo> cabal already is configured to be able to use the ghc version in its installation paths for locally installed packages
18:16:28 <ddere> orzo: sorry, I don't have any helpful suggestions :(
18:16:31 <orzo> it should allow similar capability for building things in place
18:16:41 <ddere> yeah you would think so
18:16:45 <alang> edwardk: any ideas about what to do with AD?
18:17:46 <edwardk> alang: i need to page in all the results we found when we did our 4.0 attempt last time
18:18:03 <alang> yea i kind of forgot where we were at
18:20:53 <alang> iirc, we had something that worked but required a lot of type sigs in user code
18:31:58 * hackagebot courier 0.1.0.10 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.10 (PhilHargett)
18:32:00 * hackagebot penny 0.32.0.0 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.0 (OmariNorman)
18:32:13 <Rotaerk_> can anyone explain these errors?  http://lpaste.net/99892
18:32:53 <Rotaerk_> I would expect it to make the deductions that it's saying it can't... because of my functional dependencies indicating there's a 1:1 correspondence of event to model type
18:52:01 * hackagebot hOpenPGP 1.0.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.0.1 (ClintAdams)
18:57:09 <c_wraith> Ok, I know that ST has some type inference issues, but the way this one is manifesting is baffling.
18:57:39 <c_wraith> If I remove an unsafeInterleaveST from my code, it fails to compile.
18:58:50 <Eduard_Munteanu> @hoogle unsafeInterleaveST
18:58:50 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
18:58:51 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
18:59:17 <Eduard_Munteanu> c_wraith: perhaps there's a special case for it like there's for ($)
19:00:01 <Eduard_Munteanu> c_wraith: if it's anywhere near a runST and you're composing functions
19:00:30 <c_wraith> It's on a recursive call inside a helper function in a where clause.
19:01:32 <Eduard_Munteanu> c_wraith: sounds like impredicative instantiation issues indeed
19:02:52 <Eduard_Munteanu> c_wraith: assuming you're set up like   foo = ... where recurse = foo . unsafeInterleaveST
19:03:04 <Rotaerk__> bleh, webchat malfunctioned; did anyone respond?
19:03:13 <c_wraith> Eduard_Munteanu: no compositions involved.
19:03:21 <Eduard_Munteanu> Rotaerk__: no
19:03:23 <c_wraith> oh, let me try something
19:03:25 <Rotaerk__> k
19:03:42 <zq> how do i test this sat solver
19:07:52 <intrados`> Is there a way to have `a ^? failable1 . failable 2` return {Right b, Left fail1 or Left fail2} rather than {Just b or Nothing}
19:09:25 <zq> i have a top level, k :: Eq a, Num a => [a] -> [[a]] -> Maybe a
19:09:41 <zq> then i declared another top level j = k []
19:10:01 <zq> but now j :: [[Integer]] -> Maybe Integer
19:10:07 <geekosaur> zq: with no type signature my guess is you just met the monomorphism restriction
19:10:08 <zq> is this the monomorphic restriction
19:10:21 <zq> ah all those hindley milners paid off
19:10:34 <zq> geekosaur: thanks.
19:11:00 <geekosaur> basiclaly if an Integer or Double (or in ghci, ()) appears suddenly where you expect a type variable, suspect the monomorphism restriction somewhere
19:11:18 <geekosaur> and look carefully at any bindings without parameters
19:11:21 <zq> feels kinda like ml messing with my polymorphism
19:12:05 <geekosaur> you can turn it off but it's usually easier to just be explicit with type signatures
19:12:31 <zq> geekosaur: well i kinda wanted j to stay polymorphic too
19:12:37 <geekosaur> conveniently, they also help with debugging type errors in general since the compiler will often infer things you never considered, leading to weird type errors in unexpected places
19:12:49 <geekosaur> right, so give it a type signature
19:13:32 <geekosaur> (Eq a, Num a) => [[a]] -> Maybe a
19:13:36 <zq> oh oh
19:13:49 <zq> totally forgot about type vars
19:14:09 <geekosaur> you can also turn off the monomorphism restriction, but that can lead to other nasty surprises
19:15:22 <geekosaur> and explicit type signatures can make tracking down type errors much easier in general, so they're just a good idea regardless.
19:16:09 <zq> word
19:17:04 * hackagebot hopenpgp-tools 0.5 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.5 (ClintAdams)
19:20:19 <jrmithdobbs> how do you define --with-rtsopts= properly in a cabal file to set default gc options and such?
19:22:34 <jrmithdobbs> space separated like --with-rtsopts="-H32M -A1M -w -c" throws an error, comma separated doesn't throw an error but doesn't seem to actually set anything ... using dyn if that matters
19:26:50 <jle`> i giggled to myself today when using getSum
19:27:26 <jle`> for a longer period than i am comfortable admitting
19:28:21 <bitemyapp> jle`: that's hilarious.
19:28:30 <jle`> thank you.
19:28:33 <bitemyapp> jle`: the only appropriate way to laugh at this is: HUE HUE HUE HUE HUE HUE
19:28:39 <bitemyapp> gib jok pls
19:29:23 <maxDem> is haskell good for artificial intelligence ?
19:29:34 <bitemyapp> maxDem: it's good for making you an artificially intelligent programmer.
19:29:41 <jle`> :P
19:30:04 <Rotaerk__> this article compares the pros and cons of FDs and TFs http://www.haskell.org/haskellwiki/Functional_dependencies_vs._type_families
19:30:08 <jle`> i know there is a decent sized body of researchers using haskell for AI research
19:30:16 <Rotaerk__> suggesting they're equivalent ...
19:30:17 <Rotaerk__> are they?
19:30:32 <darkpassenger> useless_input::[shit] -> Bool
19:30:43 <Cale> Rotaerk__: they're close
19:30:46 <darkpassenger> sorry i overflowed
19:31:11 <darkpassenger> I guess my real question is what is the usage for haskell in life ?
19:31:15 <darkpassenger> as a programming language...
19:31:15 <treehouse> DarkFox: yeah, you went a little to far YOU LITTLE PIECE OF SHIT!
19:31:16 <treehouse> >:(
19:31:40 <bitemyapp> treehouse: easy there killer.
19:31:45 <darkpassenger> is there such a thing as embedded haskell ?
19:31:47 <Cale> darkpassenger: Well anything which your computer can do can pretty much be done in Haskell.
19:31:49 <treehouse> darkpassenger: code easy to maintain, and fast development, I guess. Some applications utilizes it
19:32:05 <Eduard_Munteanu> @hackage atom
19:32:05 <lambdabot> http://hackage.haskell.org/package/atom
19:32:09 <Eduard_Munteanu> darkpassenger: ^^
19:32:11 <oakwhiz> darkpassenger: http://ajhc.metasepi.org/
19:32:12 <Cale> darkpassenger: There are people using Haskell as a metalanguage for constructing embedded applications
19:32:19 <treehouse> bitemyapp: yeah, I went a little too far when I said taht he's a piece of shit :/
19:32:30 <jle`> i use haskell for web stuff?  and scientific computing
19:32:35 <jle`> and game development
19:32:36 <treehouse> it can also be used for fast prototyping
19:32:47 <jle`> and for street cred
19:32:48 <Cale> darkpassenger: Your ability to actually run Haskell code in an embedded setting will depend a lot on what you consider the word "embedded" to mean
19:32:48 <bitemyapp> darkpassenger: you can do...*waves magic wand* anything you want.
19:32:50 <treehouse> jle`: wow.. really? S
19:33:03 <darkpassenger> i know that :P
19:33:06 <haasn> Cale: they aren't equivalent?
19:33:08 <treehouse> Haskell has its limitations.
19:33:14 <darkpassenger> im just wondering what is it most used for kind of
19:33:23 <haasn> Cale: oh, closed type families can't be simulated with classes I think
19:33:26 <darkpassenger> its a programming language , of course you can make it do whatever you want.
19:33:27 <treehouse> You don't code critical stuff with it.
19:33:29 <DarkFox> treehouse: Why you tabfail :(
19:33:34 <haasn> maybe with OverlappingInstances? I don't know
19:33:43 <Rotaerk__> I can't make it do what I want >_>
19:33:45 <haasn> Also classes can do things that are less specific than FDs
19:33:46 <Cale> haasn: and there are certain functional dependencies which are hard to approximate with TFs
19:33:50 <darkpassenger> because I like to code in haskell
19:33:57 <haasn> Cale: alright, points taken :)
19:33:59 <bitemyapp> jle`: please tell me there is something better than hOpenGL
19:34:02 <bitemyapp> jle`: please dear god
19:34:03 <darkpassenger> and I wonder what kind of job I can get
19:34:31 <bitemyapp> darkpassenger: 1. Be awesome 2. join a small company 3. Rewrite their stuff in Haskell 4. Don't be not-awesome
19:34:32 <Cale> darkpassenger: http://www.haskell.org/haskellwiki/Haskell_in_industry
19:34:53 <jle`> bitemyapp: well...i don't really like to deal with the graphics stuff >.>  i abstract it all away
19:35:04 <Cale> I don't know how up-to-date that page is, but it should give some ideas
19:35:12 <bitemyapp> jle`: ?_?
19:35:14 <Cale> There are lots of other things starting to show up now
19:35:21 <jrmithdobbs> i use haskell because conduit lets me write one-off data transforms that i can actually shove into a sh pipeline correctly without 200 lines of boilerplate signal handling/eventloop nonsense
19:35:22 <DarkFox> treehouse: You may write a prototype or concept in Haskell. Then use the functional writing from the code to then write a C alternate for the raw performance.
19:35:41 <DarkFox> Very good language to show conceptual code, while it's a working example.
19:35:53 <Cale> DarkFox: Are you talking about embedded applications?
19:35:54 <DarkFox> (For real-time mission-critical things)
19:36:03 <darkpassenger> thx
19:36:10 <DarkFox> Cale: To treehouse 's message in which he tabfailed me in.
19:36:19 <treehouse> DarkFox: you don't run real-time mission-critical things in haskell though
19:36:24 <jle`> bitemyapp: haven't actually finished anything presentable yet, just mostly working on game logic and backend.  i have a working frontend that renders things for me so i can see what goes on but i haven't put too much work into that side of things yet
19:36:36 <darkpassenger> haskell not nasa safe ? come on...
19:36:38 <jle`> i'm using GLUT
19:36:40 <DarkFox> treehouse: As I said; you can use it to build a prototype to get the pure concept...
19:36:46 <jle`> only fortran will ever be good enough for NASA
19:36:57 <jle`> all other languages are toys
19:37:00 <geekosaur> oh please, nasa's already using java...
19:37:06 * hackagebot text-stream-decode 0.1.0.3 - Streaming decoding functions for UTF encodings.  http://hackage.haskell.org/package/text-stream-decode-0.1.0.3 (MichaelSnoyman)
19:37:12 <geekosaur> I think haskell would not be a problem :p
19:37:12 <darkpassenger> java ? why dont they use plain C . . .
19:37:22 * treehouse urinates on geekosaur :3
19:37:31 <treehouse> darkpassenger: who?
19:37:43 <jle`> is lambdabot a janitor as well
19:37:43 <geekosaur> (well, I don't think they run java on e.g. rovers...)
19:37:48 <Cale> DarkFox, treehouse: actually, you can often write your Haskell program in such a way that you have some embedded domain specific language for specifying your problem, and then you have both an interpreter for that language in Haskell, as well as a code generator using LLVM or C code generation.
19:37:57 <Cale> That approach can be quite effective
19:38:04 <jrmithdobbs> geekosaur: but at the same time would not be entirely shocked if they did
19:38:04 <DarkFox> Cale: Indeed
19:38:21 <DarkFox> I'd rather work with LLVM/C + HS.
19:38:30 <geekosaur> jrmithdobbs, any gc language is pretty much contraindicated there, I think
19:38:37 <darkpassenger> treehouse: the nasa
19:38:40 <geekosaur> it's like the early days of embedded systems still
19:39:32 <geekosaur> this is where you use haskell via things like atom
19:39:45 <geekosaur> use haskell to write programs that write programs, effectively
19:40:03 <DarkFox> Cale: Would be awesome if someone made a processor that was made for purly functional code.
19:40:10 <treehouse> darkpassenger: supposedly, they could use haskell for some things. Not critical and important things (where more 'safer' software and methods are in use, most probably).
19:40:18 <DarkFox> Cale: Like FPGA, dedicated to the function
19:40:24 <Cale> DarkFox: Reduceron
19:40:35 * DarkFox doesn't know this word
19:40:42 * DarkFox is in English class atm and doesn't know that word
19:40:43 <DarkFox> :P
19:40:44 <jrmithdobbs> geekosaur: funny, i was asking about --with-rtsopts like 30m ago specifically to get the runtime to stop allocating TOO MUCH by default for something ;p
19:40:46 <verement> relevant: http://forums.udacity.com/questions/12000321/nasa-is-coding-in-python
19:40:48 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
19:40:55 * DarkFox can't click links atm
19:41:07 <treehouse> yeah, I think that link answers your question darkpassenger
19:41:11 <treehouse> the python link
19:41:20 <Cale> DarkFox: It's an fpga implementation of a processor for combinator reduction.
19:41:31 <DarkFox> Cale: OH
19:41:32 <oakwhiz> I've heard of a CPU design called the "Mill" architecture. I wonder if it would be amenable to functional code
19:41:41 <DarkFox> I might check this out when I'm home in ~1.5hrs
19:41:46 <oakwhiz> http://ootbcomp.com/topic/introduction-to-the-mill-cpu-programming-model-2/
19:41:52 <DarkFox> Thanks Cale
19:42:01 <bitemyapp> oakwhiz: maybe after it gets an LLVM backend.
19:42:23 <bitemyapp> oakwhiz: i'm sure vectorized ops against Mill would be cool, but not everybody thinks that should happen in the backend either.
19:42:26 <Cale> DarkFox: and the implementation of the processor description is also in Haskell, using a library called York Lava to lay out the gates
19:42:48 <Cale> (it's a library which can generate VHDL)
19:44:20 <oakwhiz> Cale: Haskell sure is good at bootstrapping itself :-)
19:44:34 <DarkFox> Cale: :O
19:45:02 <DarkFox> Cale: Be awesome to have that in our laptops :-0
19:45:04 <darkpassenger> I find haskell very friendly
19:45:05 <DarkFox> :-) *
19:45:10 <jrmithdobbs> does --with-rtsopts not do anything if the runtime is linked dynamically?
19:45:14 <DarkFox> Haskell accelerator! :P
19:45:15 <oakwhiz> It's things like this that make haskell seem like "the one language to rule them all"
19:46:32 <geekosaur> jrmithdobbs, I don't see why it wouldn't (aside from bugs?)
19:46:36 <Cale> DarkFox: Yeah, if you have an FPGA card, you can use it. Unfortunately, it will take quite a lot of work before it can really challenge GHC, but it's able to get fairly comparable performance out of a chip running at a few hundred MHz to GHC compiled native code on a processor running at a couple GHz.
19:46:44 <geekosaur> however note that you need to enable rtsopts to use with-rtsopts
19:47:02 <geekosaur> because you can't specify very much in the way of rtsopts by default
19:47:21 <jrmithdobbs> geekosaur: so this should work? ghc-options: -O2 -Wall -rtsopts -with-rtsopts=-H2M,-M2M,-A768K,-w,-c
19:48:06 <Cale> DarkFox: (because, up to some restrictions, it's pretty much able to do an entire lambda application by template instantiation every clock cycle)
19:48:07 <oakwhiz> Cale: Do you happen to know if there is there a way to get GHC to compile Haskell for MicroBlaze CPUs?
19:48:07 <DarkFox> Cale: I don't have an FPGA, I'll have to check out this processor you refferenced. Happen to be designing a concept laptop for the use for hacking, and gaming. (Dual market)
19:48:10 <geekosaur> mm, not sure of that, I think it takes the same format as the RTSOPTS envar, so no commas?
19:48:56 <geekosaur> sorry GHCRTS not RTSOPTS
19:49:04 <oakwhiz> I have a friend that works with hardware quite a bit but I think he has trouble with the software side
19:49:06 <Cale> oakwhiz: No, not directly as such.
19:49:18 <jrmithdobbs> geekosaur: ya where is format for that defined? i usually pass them on the commandline
19:49:21 <geekosaur> the example at http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-opts-compile-time shows spaces not commas
19:49:31 <geekosaur> which is what I would expect
19:49:45 <Cale> oakwhiz: I think at some point there was some minimal support for mips
19:49:59 <Cale> (I don't know, it may still exist)
19:50:14 <DarkFox> Also; anyone here running current aurora? (firefox-nightly) ... Damn looks like chromium now D:
19:50:17 <Cale> But that'd be the closest thing to DLX codegen.
19:50:40 <oakwhiz> but ARM support is decent, right?
19:50:43 <Cale> yes
19:50:54 <jrmithdobbs> if I change it to spaces in the cabal file it doesn't parse right (tried quoting with '' and "" =/)
19:50:55 <DarkFox> Armv7 works; not v5 iirc.
19:50:59 <DarkFox> Or something along the lines
19:51:10 <oakwhiz> I have a couple of ARM Cortex boards kicking around...
19:52:13 <geekosaur> mm, that would be a cabal issue, maybe ping dcoutts about it
19:53:09 <jrmithdobbs> there it is, silly me assuming it would understand sh quoting and that -with-rtsopts="opts" instead of -with-rtsopts "opts" would work
20:23:14 <Iloiny_> String of whitespace delimited integers -> list of integers - any clues?
20:23:56 <simpson> > read $ words "1 2 3 4 5 10 42" :: [Int]
20:24:00 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
20:24:00 <lambdabot>  Expected type: GHC.Base.String
20:24:00 <lambdabot>    Actual type: [GHC.Base.String]
20:24:10 <simpson> > map read $ words "1 2 3 4 5 10 42" :: [Int]
20:24:11 <lambdabot>  [1,2,3,4,5,10,42]
20:24:14 <simpson> Note that I am a horrible person.
20:26:25 <Iloiny_> thanks nonetheless
20:27:11 <johnw> with attoparsec: parse (many decimal) "1 2 3 4 5 10 42"
20:27:12 * hackagebot xsd 0.5.0.0 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.5.0.0 (TonyMorris)
20:27:39 <johnw> err: parse (many decimal <* some space) "1 2 3 4 5 10 42"
20:29:36 <kristof> So why do people talk about lenses in here all the time but I hardly ever hear anything about pipes? :(
20:30:34 <kristof> that was accidentally phrased as an instigatory question, sorry
20:31:11 <kristof> I am just wowed by the compositional freedom obtained with pipes! These things are really cool!
20:31:37 <kristof> it's a lot like the joy of stringing together a bunch of little unix programs in a shell script
20:31:51 <oakwhiz> Pipes seem like a decent concurrency/parallelism model
20:33:02 <CaptainK> is the pipe in haskell similar to *nix style?
20:33:32 <kristof> CaptainK: a little, if you think of unix programs as text consumers and producers
20:33:58 <kristof> CaptainK: but haskell pipes are better because of the laziness
20:34:26 <CaptainK> like ls | more? can be [1..10] | function x
20:35:55 <levi> kristof: unix pipes are 'lazy' in a sense, too.
20:36:31 <ion> The Unix pipes comparison is popular exactly because they‚Äôre lazy, too.
20:36:43 <jrmithdobbs> it's just usually implemented via blocking on a default 4k buffer
20:37:28 <oakwhiz> I was thinking of maybe using the pipe model to increase the speed of a typical video game render loop.
20:38:14 <levi> oakwhiz: In what way were you thinking the pipe model would help you there?
20:38:48 <oakwhiz> levi: In exchange for adding a few extra frames of delay between user input and displayed graphics, you could pipeline the different stages of building frames on different threads.
20:39:04 <jrmithdobbs> actually, | in sh is both function and stream composition in a sense
20:39:06 <oakwhiz> A game might have input, logic, physics, and rendering
20:39:46 <oakwhiz> If we made the game like this: input | logic | physics | rendering
20:40:05 <oakwhiz> then the CPU could work on those 4 tasks at once instead of sequentially
20:40:07 <darkpassenger> im installing docker on debian...
20:40:49 <oakwhiz> The problem with this is that the user is basing their input on a picture of the game from about 4/60ths of a second ago.
20:40:56 <levi> unix pipes are a great model as long as you mostly work with more-or-less linear streams of text. :)
20:42:08 <jrmithdobbs> levi: or just use bash and then you can even fudge that quite a bit. sh/bash are underappreciated ;p
20:42:45 <kristof> unix pipes are lazy?
20:42:49 <levi> oakwhiz: It doesn't seem like a linear pipeline is necessarily what you want there, though the idea of farming tasks to various CPUs (and GPUs) seems like a good idea.
20:43:00 <jrmithdobbs> kristof: implicitly due to how the software used in them works, yes
20:43:04 <pikhq_> kristof: Amazingly, yes.
20:43:11 <levi> kristof: In much the same way Pipes is lazy.
20:43:15 <kristof> ok.
20:43:16 <jrmithdobbs> kristof: everything blocks on 4k buffered pipes along the pipeline
20:43:18 <levi> Or lazy bytestrings.
20:43:26 <ski> s/lazy/demand-driven/
20:43:37 <jrmithdobbs> it's a form of laziness
20:43:58 <pikhq_> ski: Let's go with "superficially resembles lazy String IO".
20:44:16 <ski> laziness to me imples by-need, iow caching of values so as to not recompute
20:44:24 <ski> s/imples/implies/
20:45:16 <jrmithdobbs> well it's a more restricted model, yes, since you're typically performing transforms along the pipeline though, it turns out not to matter much in practice
20:47:00 <levi> If you tee a unix pipeline, the consumers don't have to re-compute the inputs.
20:47:19 <levi> But it's definitely an imperfect comparison.
20:48:27 <jrmithdobbs> ski: the way the pipes work, assuming well-behaved things in the chain, the moment anything down or upstream terminates the other end gets a SIGPIPE and falls off, so the failures cascade in both directions terminating computation
20:49:25 <jrmithdobbs> ski: so if something downstream just closes the pipe downstream before the whole pipeline inits, nothing actually happens and except (especially in bash usually just one) failed fork and some signal handling
20:51:14 <jrmithdobbs> but it *is* a rudimentary form of inversion of control (and the runtime doesn't parallelize anything for you, good luck, that's fun to do)
20:54:16 <ski> levi : hm, point
20:54:26 <ski> jrmithdobbs : ok
20:55:08 <kristof> jrmithdobbs: what happens if you use gnu parallel to run a bunch of tasks at the same time and make them communicate with one another?
20:55:24 <kristof> That question doesn't sound as good when I say it aloud. ...never mind.
21:00:58 <jrmithdobbs> kristof: well behaved was a caveat, it's not pure so obviously you have all sorts of side effects to think about ;p
21:07:31 * hackagebot xsd 0.5.0.1 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.5.0.1 (TonyMorris)
21:17:10 <shackleford> This has been killing me for the past 20 minutes and I can't find a good answer on Google. How do I read a file into a list without resorting to Unsafe?
21:18:19 <enthropy> is readFile unsafe?
21:18:24 <djahandarie> shackleford, hmm? Like the first result for "haskell read file into list" seems to have some good explanations and code.
21:18:30 <djahandarie> http://stackoverflow.com/questions/215748/haskell-inserting-every-line-from-a-file-into-a-list
21:18:38 <djahandarie> Is something from there not clear?
21:25:23 <levi> shackleford: You can't do it without an IO action; IO is not pure, but it's generally safe.
21:28:15 <shackleford> Okay, so if I enter the IO monad, the function which is presently being called upon must return an IO a? Am I getting this right?
21:28:51 <shackleford> I can't have a function which both performs IO and returns [String]?
21:29:19 <johnw> it could return an IO action and a [String]
21:29:45 <johnw> or an IO action which returns a [String]
21:29:51 <shackleford> johnw: I don't follow.
21:30:05 <johnw> foo :: IO [String], or foo :: (IO a, [String])
21:31:16 <haasn> shackleford: have you read an introduction to how IO works in Haskell (eg. as part of Learn You A Haskell or Real World Haskell)?
21:31:33 <haasn> or see http://www.haskell.org/haskellwiki/Introduction_to_IO
21:39:08 <kristof> shackleford: You're thinking of procedural style "do this, then return that"
21:39:29 <kristof> shackleford: In C, expressions are special cases of statements. In Haskell, statements are special cases of expressions.
21:39:47 <kristof> shackleford: An IO value is something that represents a computation which will happen when it is passed to the main function.
21:40:07 <shachaf> "In C, expressions are special cases of statements."?
21:40:19 <kristof> shackleford: yeah
21:40:22 <kristof> er
21:40:24 <kristof> schell: ^
21:40:34 <startling> Can I do have something like data Sum fs v = Elem f fs => f v?
21:40:50 <startling> I mean type-level lists of higher-kinded type constructors.
21:41:03 <startling> shachaf: yeah. Every expression in C is also a statement.
21:41:17 <johnw> startling: that construction is deprecated, albeit allowed with an extension
21:41:20 <startling> I'm not sure about "In Haskell, statements are special cases of expressions" though.
21:41:27 <shackleford> kristof: So, if I have an IO [a], it will be treated as a [a] when referenced in main?
21:41:32 <startling> johnw, that's not what I'm talking about.
21:41:34 <kristof> Tabbing sucks. :( shachaf: If I write something like "return foo;" in C, I'm writing a special kind of statement that yields a value to whoever called the routine. All I was doing was illustrating the interesting difference between procedural and functional.
21:42:15 <kristof> shackleford: IO [a] means that you have performed some input/output stuff and you also happened to retrieve a pure value of type [a]. You could represent this in a do block as myList <- getListFromFile or something
21:42:21 <startling> data Sum fs v = forall f. Elem f fs => f v, if you're that hung up about it.
21:42:39 <shachaf> johnw: What's deprecated?
21:42:54 <shachaf> It's a syntax error, but if you're talking about the thing that has the constraint right after "data", that's not it.
21:43:05 <startling> ^ yeah
21:43:07 <johnw> shachaf: data Foo = SomeConstraint a => a
21:43:18 <johnw> I thought that was considered a "misfeature"
21:43:28 <startling> johnw, it's irrelevant to my question.
21:43:38 <johnw> see https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/data-type-extensions.html
21:43:41 <johnw> startling: I'm just responding to shachaf
21:43:49 <johnw> "This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension DatatypeContexts."
21:43:52 <startling> johnw, sigh.
21:43:59 <startling> johnw, mine is an existential.
21:44:03 <johnw> ok
21:44:14 <johnw> I'm probably wrong aynway
21:44:54 <shachaf> johnw: Yes. Look at the syntax.
21:45:32 <shackleford> kristof: That's the part I'm not getting. If I understand correctly, `value <- expression` is not an expression in itself, so after that, I'd need `return value` or some other expression, right? And this would yield an IO, since we'd be in the IO monad?
21:45:33 <startling> so yeah, can I have type-level lists? :)
21:45:52 <startling> I guess data Sum as = forall a. Elem a as => a would be the simpler case.
21:46:42 <startling> shackleford: yeah.
21:46:45 <shachaf> startling: You're missing a constructor in all of these examples.
21:46:49 <kristof> shackleford: I think there are lots of little conceptual holes that you need to fill in and I think you need to 1) go read Learn You a Haskell and then 2) go read Real World Haskell, and then come back and ask questions. You can ask questions about those two things while you're reading them but I doubt you'll need to.
21:46:53 <shachaf> At least, that's my best guess.
21:47:00 <startling> shachaf: oh, yeah, you're right.
21:48:40 <startling> data Sum as = forall a. Elem a as => Sum as, then.
21:50:11 <startling> so, my question is: does an Elem like that exist? can it be written?
21:50:31 <startling> My use-case is a generalized Either -- something like Sum [Int, Char, String]
21:52:57 <startling> well, a general case higher-kinded Either: specifically I want something like Sum [Map, [], Set] Int
21:54:51 <jmcarthur> startling: yes, that is doable
21:55:03 <carter> o/ jmcarthur  :)
21:55:05 <startling> jmcarthur: in Haskell> :)
21:55:13 <startling> jmcarthur: in Haskell? :)
21:55:18 <jmcarthur> startling: in Haskell + a ton of extensions
21:55:24 <startling> jmcarthur: sure.
21:55:34 <jmcarthur> maybe i missed some context
21:55:47 <startling> I hope not.
21:55:51 <carter> startling: yeah, you can dotally do it
21:56:04 <jmcarthur> if haskell + a ton of extensions is acceptable, i'll throw together an example
21:56:13 <shachaf> I don't think you need a lot of extensions.
21:56:14 <startling> jmcarthur: it's exactly what I'm asking for.
21:56:29 <jmcarthur> okay, give me a few minutes
21:56:49 <shachaf> E.g. something like data Sum :: [*] -> * where { Sum :: Either t (Sum ts) -> Sum (t ': ts) } ?
21:56:51 <carter> per se doesn't constraint kinds give you something ismilar too?
21:57:01 <startling> oh typefamilies might be a way to do it.
21:57:11 <carter> theres several ways
21:57:13 <startling> shachaf: oh, that's a decent way.
21:59:17 <shachaf> data Sum :: [*] -> * where { Yes :: t -> Sum (t ': ts); No :: Sum ts -> Sum (t ': ts) }
21:59:25 <jmcarthur> startling: since shachaf used a GADT, i went with a type family: http://lpaste.net/99895
21:59:29 <startling> why can't I use (:) in an instance declaration?
21:59:56 <startling> jmcarthur: ooh, interesting
22:00:20 <shachaf> Of course, it's just Foldr Either Void
22:00:29 <jmcarthur> heh
22:00:46 <startling> https://gist.github.com/startling/856da560ba66967d02d3 <- this was my approach, apparently a syntax error
22:00:52 <jmcarthur> ugh, now i have to implement Foldr
22:02:03 <shachaf> data Foldr :: (* -> * -> *) -> * -> [*] -> * where { Z :: z -> Foldr f z '[]; F :: f x (Foldr f z xs) -> Foldr f z (x ': xs) }
22:02:12 <shachaf> Or with polykinds if you prefer.
22:02:58 <shachaf> type Sum = Foldr Either Void
22:03:06 <shachaf> type Product = Foldr (,) ()
22:03:47 <jmcarthur> http://lpaste.net/99895
22:04:11 <startling> What are ': and '[]?
22:04:16 <shachaf> DataKinds
22:04:19 <shachaf> Lifted (:) and []
22:04:23 <jmcarthur> type level list constructors
22:04:24 <startling> ah, interesting
22:04:35 <shachaf> You can also define data Cons a as; data Nil
22:04:41 <shachaf> But this way you get more kind safety.
22:04:53 <startling> mhm.
22:04:54 <tero-> is there a way to identify a symbolic link that points to a non-existing file without catching the exception thrown by getSymbolicLinkStatus?
22:05:34 <shachaf> GADTs and TypeFamilies can be used to do similar things.
22:05:40 <johnw> tero-: I'd just use 'try'
22:05:49 <johnw> even though that's also catching the exception
22:06:03 <tero-> johnw: ok. are exceptions computationally costly in haskell?
22:06:11 <jmcarthur> similar, but not exactly the same, to be clear
22:06:28 <johnw> i doubt they're more costly than doing a kernel context switch to get a file descriptor's status
22:06:46 <jmcarthur> i think my Foldr might be wrong
22:07:05 <tero-> johnw: ok. thanks
22:07:22 <shachaf> Wrong how?
22:08:05 <jmcarthur> or at least my Sum in terms of Foldr is wrong
22:08:30 <shachaf> Why?
22:08:41 <shachaf> Hmm, the 'impossible' happens when I paste your thing into ghci.
22:09:20 <startling> uh-oh.
22:09:43 <jmcarthur> it's about this time that i would normally switch to GADTs :)
22:09:52 <jmcarthur> except when i'm playing around like this
22:10:37 <jmcarthur> oh, my Sum is definitely wrong
22:10:53 <jmcarthur> it doesn't actually work for type constructors, i think
22:11:21 <shachaf> Oh, you were doing the higher-kinded sum.
22:11:29 <shachaf> I see now. Right.
22:11:37 <shachaf> I thought you were just doing the boring one that I was.
22:11:45 <shachaf> You'll need (:+:) and Void1 or something.
22:11:48 <jmcarthur> yeah
22:12:30 <carter> if you made ghci crash, shoudl someone file a ticket?
22:13:37 <enthropy> depends what you were doing
22:14:11 <jmcarthur> startling, shachaf: corrected http://lpaste.net/99897
22:14:35 <shachaf> Right. Same idea.
22:16:06 <johnw> jmcarthur: what are you using this for?
22:16:25 <carter> in fact: type families and GADTs are complimentary, not just similar
22:16:39 <jmcarthur> johnw: startling had asked about whether something like that would possible (at least the Sum type), and then the idea was mentioned to generalize it with Foldr
22:16:50 <jmcarthur> s/with Foldr/to Foldr/
22:17:28 <johnw> I wonder what startling will do with it then
22:17:35 <jmcarthur> no idea :)
22:18:13 <shachaf> It's a reasonable type to want.
22:19:00 <shachaf> If you like writing sum [1, 2, 3, 4] instead of (1 + 2 + 3 + 4), you might as well like to write Sum [Int, Char, Bool, String] instead of (Int `Either` Char `Either` Bool `Either` String)
22:19:33 <johnw> fair enough
22:19:35 <startling> Yeah.
22:19:43 <startling> Specifically I'm doing AST transforms.
22:19:53 <startling> e.g. AST [Let] v -> AST [] v
22:20:42 <startling> or, AST (Let ': as) -> AST as v
22:21:38 <shachaf> So if I type these things into ghci, the 'impossible' happens:
22:21:54 <shachaf> type family Foo (f :: * -> *) x
22:21:57 <shachaf> type instance Foo f () = ()
22:21:59 <shachaf> type instance Foo f (Id x) = f (Foo f x)
22:22:08 <shachaf> 7.6.3 for x86_64-unkown-linux
22:22:25 <shachaf> Is this reproducible?
22:23:06 <carter> <interactive>:5:22:
22:23:06 <carter>     Not in scope: type constructor or class ‚ÄõId‚Äô
22:23:06 <carter>     Perhaps you meant ‚ÄõIO‚Äô (imported from Prelude)
22:23:10 <carter> whats in scope?
22:23:11 <startling> ^
22:23:21 <shachaf> data Id a = Id a
22:23:26 <shachaf> Or you can use Maybe or anything else.
22:23:37 <startling> shachaf: yeah, the impossible happens here too.
22:23:39 <carter> works fine in 7.8
22:23:48 <shachaf> OK, then I don't care.
22:23:56 <startling> ghc: panic! (the 'impossible' happened)
22:23:56 <startling>   (GHC version 7.6.3 for x86_64-apple-darwin):
22:23:56 <startling> 	Util: foldl2
22:24:23 <startling> But yeah, "works fine in 7.8" is reasonable.
22:25:28 <carter> :)
22:25:41 <carter> i just entered only that 3 line type family
22:26:02 <carter> mine you, i'm using a slightly pre RC1 custom perf build
22:26:04 <carter> but yeah
22:26:18 <startling> GHC hotrodding
22:26:38 <johnw> mah tricked-out GHC build
22:26:58 <carter> jmcarthur: startling  i did try building ghc with a patch numerical prelude a few months ago
22:27:05 <carter> only failed like 2-3 tests in the test suite :)
22:27:12 <carter> * johnw
22:27:20 <startling> johnmcw
22:27:30 <carter> i miss cmcaann
22:27:44 <startling> is that like cmcanaan?
22:27:58 <carter> i can't spell
22:28:05 <startling> how ironical.
22:28:24 <Hafydd> jmcaanther
22:29:06 <startling> Can I export a type family such that new type instances may not be added?
22:29:23 <carter> startling: in 7.8 yes
22:29:24 <carter> :)
22:29:40 <carter> not in ealrier
22:29:42 <startling> ok, I'll just trust that no one adds anything evil to my Sum.
22:29:46 <carter> :)
22:30:01 * johnw begins crafting evil instances for startling's Sum
22:30:09 * startling upgrades
22:30:40 <pdxleif> Why would something compile fine from ghc, but then from "cabal build" tell me: "Unexpected semi-colons in conditional: if eof then return Nothing; else Just <$> hGetLine h Perhaps you meant to use -XDoAndIfThenElse?"?
22:31:34 <pdxleif> The code in question: https://github.com/LeifW/online-typechecker/blob/master/IdrisClient.hs#L19
22:32:42 <startling> is there a better way to write a typeclass instance for a higher-kinded Void than 'undefined'?
22:33:08 <startling> specifically there's a default implementation, so if I just say "instance X Y" it tries to use that.
22:33:35 <startling> you know, what I really need are type-level sets.
22:37:34 <kate_r> hi
22:38:16 <kate_r> is the curry-howard isomorphism that proofs-as-programs applicable to only functional programs? or is it also relevant to imperative programs and algorithms?
22:38:40 <carter> kate_r: its true for  both
22:38:41 <carter> BUT
22:38:52 <carter> the logics for reasoning about imperative programs are a bit gnarly
22:39:01 <carter> kate_r: would you like some example such logics?
22:39:08 <supki> pdxleif: the only reason I can think of is that ghc defaults to Haskell2010 and cabal defaults to Haskell98
22:39:15 <carter> i think the main two are "hoare logic"
22:39:23 <carter> and a more modern one is "seperation logic"
22:39:24 <kate_r> carter, i just wonder if it's applicable to even something like C programs
22:39:27 <carter> it is
22:39:36 <Cale> kate_r: *kind of*
22:39:38 <carter> but its not as "mathy" a logic
22:39:41 <carter> theres a lgoic there
22:39:54 <carter> but not one you'd think of when you think of "mathy lotgic"
22:39:56 <carter> *logic
22:40:10 <Cale> Well, also, C's type system isn't exactly itself a logic, you have to put some extra formalism on top there.
22:40:21 <carter> yeah
22:40:30 <carter> eg
22:40:34 <carter> the YNOT project
22:40:36 <carter> or Idris
22:40:37 <Cale> But there is some weirdo "logic" which C programs are proofs in.
22:41:24 <carter> yeah
22:41:38 <carter> and theres valid ccrazy logics for "sound" imperative programs
22:42:15 <levi> You can theoretically give a denotational semantics to C as well; it was originally developed to talk about imperative programs, as there wasn't much in the way of purely functional languages.
22:42:18 <Cale> But by and large it does make more sense to apply CH in a functional setting, I think everyone would agree.
22:43:43 <carter> likewise
22:44:03 <carter> you can have a Curry Howard for imperative Standard ML
22:44:12 <carter> and if you focus on the first order subset
22:44:15 <carter> you get hoare logic
22:44:25 <carter> and I think seperation logic works for even higher order stuff
22:44:27 <carter> but i forget
22:44:31 <carter> scars and trauma and such
22:44:42 <startling> this 'Bound' class is surprisingly deep.
22:45:24 <carter> you mean the bound lib?
22:45:25 <carter> yeah
22:45:26 <carter> its nice
22:45:29 <levi> Well, I think the practical benefit of Curry-Howard only comes when working in a language where the native type system and its checker are powerful enough to express interesting logical propositions.
22:45:36 <startling> carter: I mean the class Bound in that library.
22:45:47 <carter> yeah
22:45:51 <startling> https://gist.github.com/startling/8996300
22:45:52 <carter> i need to use bound more :)
22:45:59 <Cale> levi: I would agree with that
22:46:07 <levi> You could invent a fancy type system for C, but then you'd be using 'C with extra fancy types', not really C.
22:47:16 <startling> are Typeable{2,3,...} poly-kinded?
22:47:42 <levi> Interpreted as logical propositions, C types basically say that various widths of data exist. :P
22:47:52 <carter> startling: in 7.8 theres only typeable
22:47:56 <carter> no need for the higher rank ones
22:47:57 <startling> carter: oh, nice
22:48:05 <carter> theres a legacy old typeable
22:48:07 <carter> but its boring
22:48:10 <carter> and lame
22:48:22 * startling looks up what he'd need to switch to 7.8
22:49:51 <carter> startling: what os?
22:50:23 <startling> carter, OS X
22:50:30 <startling> snow leopard, which is apparently not supported
22:50:32 <carter> ahhh
22:50:43 * startling tries the lion binaries anyway
22:51:19 <carter> startling: i like my mavericks binary
22:51:22 <carter> startling: its easy to build
22:51:31 <startling> binaries are generally easy to build
22:51:40 <startling> :<
22:58:52 <carter> true
23:05:54 <startling> carter: do you know offhand how the new Typeable works?
23:06:04 <carter> everything is typeable :)
23:06:06 <carter> ALL OF IT
23:06:10 <startling> haha
23:06:27 <carter> well, theres 1-2 corner cases where it may act funny, but assume those are bugs and report them
23:06:39 <startling> I mean: is there a general way to abuse * -> * kinded things as other kinds?
23:06:44 <carter> nope
23:06:46 <carter> type safe
23:06:48 <startling> got it.
23:06:55 <carter> unsafe coerce is a great tool though
23:07:03 <carter> lets you build all sorts of proofs :)
23:07:18 * startling writes data Either3 l r f a = Left3 (l f a) | Right3 (r f a)
23:08:01 <carter> cool
23:08:03 <carter> https://ghc.haskell.org/trac/ghc/ticket/8486
23:08:07 <carter> is one current ticket
23:08:23 <startling> cool, good to know
23:12:22 <zipper> What are you guys doing for Valentine's day?
23:12:58 <carter> hanging with fam and friends in SF and such
23:13:10 <zipper> carter: SF?
23:13:25 <carter> visiting san franscico / bay area for a week
23:13:32 <Hafydd> I'm going to express my love for my significant other (myself) in a tangible form.
23:13:40 <zipper> I'll read LYAH for valentines day. :(
23:13:52 <carter> zipper: its just a hallmark holiday
23:13:56 <zipper> Hafydd: lol I will probably do that too.
23:15:33 <Hafydd> Actually, I think my Prolog interpreter would have accepted if I'd asked it out, but I'd feel bad, because I'm not sure I really love it.
23:16:05 <pdxleif> supki: That seems to have been it - thanks!
23:17:24 <haasn> Can I gift chocolates to lambdabot?
23:17:36 <notdan> aww
23:20:00 <startling> @botsnack
23:20:01 <lambdabot> :)
23:20:25 <Hafydd> I didn't know those contained chocolate. That must be unhealthy.
23:24:02 <zipper> :t zipWith
23:24:03 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
23:24:28 <zipper> hmmmmm
23:25:07 <thebnq> @src huggle
23:25:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:25:52 <zipper> @src zipWith
23:25:52 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:25:52 <lambdabot> zipWith _ _      _      = []
23:27:59 <zipper> <3 lambdabot
23:44:00 <shachaf> A more common name for "Product" is "HList".
23:50:08 <startling> shachaf, oh, neat
23:56:12 <startling> carter, the 7.8 lion package seems to install fine on snow leopard
23:56:28 <startling> and e.g. ghci seems sane
