00:04:48 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
00:04:48 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
00:13:50 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
00:13:50 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
00:30:32 * hackagebot tree-view 0.4 - Render trees as foldable HTML and Unicode art  http://hackage.haskell.org/package/tree-view-0.4 (EmilAxelsson)
00:30:32 * hackagebot egison 3.2.12 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.12 (SatoshiEgi)
02:52:13 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
02:52:13 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:59 2013]
03:07:17 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
03:07:17 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
03:11:31 <ij> What does Data.Serialize's get/put do?
03:11:32 <ij> > -- does freenode even work?
03:11:32 <lambdabot>  not an expression: `-- does freenode even work?'
03:11:48 <ivanm> ij: it's a binary serialisation
03:11:52 <ivanm> specifically, get and put are low-level functions operating in their respective monads to get and put part of a data structure
03:11:52 <ivanm> @hoogle get
03:11:53 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
03:11:53 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
03:11:53 <lambdabot> Control.Monad.Trans.RWS.Lazy get :: (Monoid w, Monad m) => RWST r w s m s
03:11:53 <ivanm> @type get
03:11:53 <lambdabot> MonadState s m => m s
03:11:54 <ivanm> @type put
03:11:54 <lambdabot> MonadState s m => s -> m ()
03:11:55 <ivanm> OK, we've got mtl types here rather than binary/cereal
03:12:59 <ij> Do I use decode rather than those two?
03:13:51 <ivanm> you typically use get and put to define how a data structure is encoded/decoded
03:14:21 <ivanm> and then encode to actually perform it for a known type
03:14:21 <ij> Ah.
03:14:22 <ivanm> note that binary and cereal don't necessarily use the most efficient method of encoding a data type
03:14:24 <ivanm> as they're typically a straight transformation from the constructors
03:14:35 <ivanm> (but due to backwards-compatibilty, we can't change them)
03:16:36 <ij> ivanm, Okay. Thanks!
03:16:37 <ivanm> np
03:24:51 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
03:24:51 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
03:24:51 -hubbard(freenode.net)- [freenode-info] please register your nickname...don't forget to auto-identify! http://freenode.net/faq.shtml#nicksetup
08:00:42 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
08:00:42 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:59 2013]
08:04:16 <ownclo_> Cale: the problem is that they are perfectly fine with 'case', 'while' and the like. That is the way C rolls. I think that my attempts are rather pointless. I just cannot imagine a way to demonstrate flexibility and readability to a man not willing to see it
08:04:43 <ownclo_> Thank you very much, anyway!
08:09:01 * hackagebot PastePipe 1.5 - CLI for pasting to lpaste.net  http://hackage.haskell.org/package/PastePipe-1.5 (RoganCreswick)
08:15:33 <ownclo_> > 2 + 2
08:15:34 <lambdabot>  4
08:29:00 <eacameron> there are so many functions like isJust and isNothing...is there a generic one that does "is X" and checks against a data type constructor?
09:53:35 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
09:53:35 --- topic: set by monochrom on [Sat Nov 23 20:32:31 2013]
09:53:36 <eacameron> johnw: even more beautiful
09:53:48 <eacameron> thank you
09:53:54 <levi> eacameron: -XDerivingFunctor is required, I think.
09:55:12 <eacameron> -XDeriveFunctor did the trick, thank you!
09:55:39 <levi> Ah, yeah, that's the name.
10:06:01 <levi> johnw: You could use the 'maybe' function to clean up some of your error case analysis. Actually a 'flip maybe' would let you supply the default error value second, which might look cleaner.
10:06:15 <k0ral> Hi, I'm writing a library in which I'd like several sections of the code to be completely replaceable by users; how would you suggest I design this behavior ? Comments following:
10:06:40 <levi> johnw: I didn't read it in depth, but overall it looks very nice.
10:07:27 <k0ral> 1/ the replaceable code sections are deep down the call stack in the library, therefore passing around a set of continuation functions is boilerplate
10:07:37 <johnw> levi: did you mean to address that to benzrf?
10:07:49 <levi> Oh! Sorry, yes.
10:08:10 <levi> benzrf: See the comments I accidentally addressed to johnw. :)
10:08:48 <benzrf|class> oh, ok
10:08:53 <k0ral> 2/ I've read this post: http://www.haskellforall.com/2012/12/the-continuation-monad.html ; as pointed out in the comments, it doesn't work well when multiple 'holes' have distinct signatures, so I gave up continuation monad
10:09:05 <dhrosa> I want to parse a string using parsec that must start with a letter, but the rest can be alphanumeric
10:09:08 <levi> k0ral: Wrapping the functions in a structure and supplying them via a Reader monad could alleviate #1
10:09:10 <benzrf|class> bbl
10:09:14 <dhrosa> so far I have liftA2 (:) letter (many1 alphaNum)
10:09:29 <dhrosa> the problem is that doesn't match single letter string, how would I match that  succinctly?
10:09:36 <k0ral> levi: see my incoming 3/
10:09:37 <dhrosa> or do I have to switch to using try and/or do?
10:09:58 <23LAA3NP0> :t many
10:09:59 <lambdabot> Alternative f => f a -> f [a]
10:10:03 <23LAA3NP0> @hoogle many
10:10:03 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
10:10:03 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
10:10:03 <lambdabot> Text.Parsec.Prim many :: ParsecT s u m a -> ParsecT s u m [a]
10:10:11 <23LAA3NP0> dhrosa: ^
10:10:15 <carter> is the netisplit over?
10:10:20 <geekosaur> hah
10:10:45 <dhrosa> oh
10:10:52 <dhrosa> I was only looking in Text.ParserCombinators.Parsec
10:11:06 <johnw> dhrosa: I think we all make that mistake at least once
10:11:13 <23LAA3NP0> i think parsercombinators is the older v2 api
10:11:21 <23LAA3NP0> text.parsec.* is v3
10:11:30 <dhrosa> oh
10:11:47 <23LAA3NP0> .msg nickserv hi
10:12:12 <dhrosa> .msg 23LAA3NP0 this is not the nickserv you're looking for
10:12:50 <k0ral> 3/ I already have a ReaderT in my transformer stack for configuration parameters; as I can't stack multiple MonadReader, I'd  have to bundle both parameters and replaceable code sections into a single structure; that doesn't feel right to me, as both parts are completely unrelated; besides, I plan to add more layers with their own readable parameters, and the idea of gathering everything into a single huge
10:12:52 <k0ral> structure really makes me sad
10:15:37 <johnw> k0ral: use a tuple?
10:15:52 <levi> Hierarchical structures can be made easier to deal with. The details of how the reader stuff is stored are irrelevant to the interface.
10:15:56 <johnw> (onebigstructure, anotherbigstructure)
10:16:27 <k0ral> I have 2 objections to this, this may be long to describe so please bear with me
10:16:30 <carter> johnw: isn't that how postgres-simple allows really really big rows?
10:16:35 <johnw> ganging up data into a Reader is not a bad thing
10:16:57 <levi> Reader provides an 'environment'. Environments sometimes have a lot of things in them.
10:17:10 <carter> like a MAP
10:17:14 <ski> (having the structures "automerge" would be nicer)
10:17:15 <carter> with STRINGS
10:17:22 <carter> :p
10:17:24 * carter ducks
10:17:28 <johnw> when I want to run a Reader within a Reader, I do: withReader (,env), where env is the thing I want to add
10:17:30 <k0ral> 1/ as I said, gathering unrelated big structures to make an even bigger all-knowing one feels really bad to me; reminds me of the "god class" from imperative-OO paradigm
10:17:38 <dmj`> does Writer cause space leaks? or has that been fixed
10:17:46 <carter> i just don't use monad transformer sthat much :)
10:18:00 <johnw> dmj`: you had more questions about aws for me?
10:18:12 <Maior> yay aws
10:18:54 <levi> k0ral: Building bigger things by composing smaller things is what programming is all about. Composing a bigger environment from two smaller ones is a perfectly elegant solution.
10:19:05 <dhrosa> does anyone have advice on making a type-safe DSL?
10:19:16 <johnw> dhrosa: first above all, make sure it's type-safe :)
10:19:25 <dhrosa> my DSL will involve 8, 16, and 22-bit types, and I don't want any mixing (except with special functions, like LOW)
10:19:37 <johnw> dhrosa: maybe GADTs are just what the doctor ordered
10:19:54 <carter> dhrosa: whats your problem domain?
10:19:55 <dhrosa> hmm
10:19:58 <hank> In haddock (>>) has a type of »forall a b. m a -> m b -> m b«. What is "forall" exactly? What does the dot in "b." do?
10:19:59 <carter> sounds like music stuff?
10:20:02 <dhrosa> nope
10:20:13 <dhrosa> I'm making a simulator for AVR microcontrollers, I'm implementing a command interface
10:20:16 <levi> dhrosa: The 'finally tagless' style has a good story about taking advantage of host types to provide type safety for a DSL.
10:20:30 <carter> dhrosa: https://github.com/alphaHeavy/llvm-general-typed may be relevant :)
10:20:34 <ParahSailin> looks like a bug in newest pipes, or at least pipes-parse
10:20:51 <ski> k0ral : not quite sure what what you want to do for the 2/, but perhaps you could use GADTs ?
10:20:51 <carter> ParahSailin: what bug?
10:21:19 <dhrosa> carter: what is that repo?
10:21:19 <ParahSailin> "Module `Pipes.Internal' does not export `closed'; Failed to install pipes-parse-3.0.0"
10:21:36 <carter> dhrosa: that one is a typed DSL for nicely generating llvm IR
10:21:38 <k0ral> 2/ more importantly, suppose you have N sets of readable parameters (called S1, S2, ..., SN); say you gather them into S = (S1, ..., SN); each function f of your library needs to read from some of them only; therefore writing f :: (MonadReader S m) => m a is wrong as it suggests f needs all of S, but it never does
10:22:09 <johnw> k0ral: you can use this: (MonadReader S m, HasFoo S)
10:22:20 <johnw> then make a type class, HasFoo, which knows how to pick Foo out of different aggregates
10:22:22 <dhrosa> except I want to parse this language from a string, does that change this at all?
10:22:32 <johnw> that way, your API surface is not multi-layer, even though S maybe be at runtime
10:22:35 <carter> dhrosa: theres also stuff liek feldspar http://hackage.haskell.org/package/feldspar-language, copilot,
10:22:40 <carter> dhrosa: well
10:22:44 <carter> first make it a DSL
10:22:44 <k0ral> exactly, and this bothers me because you have to declare any tuple of S1, ..., SN as instance of HasSX
10:22:49 <carter> then do a nicer syntax
10:23:04 <carter> so you can punt on writing  your own type checker til later
10:23:05 <k0ral> there are many combinations so this is horrible
10:23:16 <johnw> k0ral: you do, but if you structure it right, it's can be easier than it sounds
10:23:30 <johnw> for example, if you used a Map of environments (assuming N could be large)
10:23:45 <jle`> hank: the dot separates the forall from the rest of the type signature
10:23:45 <dhrosa> carter: hmm, sounds like a good idea
10:24:05 <carter> dhrosa: focus first on modelling solving the problem domain in a way you feel happ with
10:24:08 <dhrosa> carter: when I come around to parsing it, how do I deal with the fact that "+" could mean a 8-bit or 16-bit addition?
10:24:10 <carter> then making it pretty and stand alone
10:24:13 <k0ral> johnw: you mean using a data Key = Env1 | Env2 | ... | EnvN as key to the map ?
10:24:22 <carter> dhrosa: TYPE SYSTEMS AND TYPE INFERENCE AND CHECKING :)
10:24:34 <carter> dhrosa: hence why start with a DSL that lets you do it in haskel or idris
10:24:54 <johnw> k0ral: sure
10:24:56 <carter> dhrosa: trapping +, wrapping + or saturating +?
10:25:08 <johnw> k0ral: and an aggregate ADT for wrapping the heterogeneous value types
10:25:22 <hank> jle`: oh ok, thanks
10:25:23 <dhrosa> what does trapping mean, error on overflow?
10:25:26 <carter> yes
10:25:36 <dhrosa> either trapping or wrapping, more likely wrapping
10:25:39 <johnw> k0ral: you do the leg work once, and you get the flexible (and speed benefits) of only ever having a single Reader layer in your transformer stack
10:25:44 <carter>  plus :: SignedInt wraptype size  ->  SignedInt wraptype size  -> SignedInt wraptype size  -
10:25:48 <carter> is how i'd do it in haskell
10:25:57 <carter> or something
10:26:03 <ski> (flip argument order ?)
10:26:27 <k0ral> johnw: looks better than the tuple, still I'm worrying about the following:
10:26:38 <dhrosa> hmm, thanks, I'll start with making it fully in haskell before I futz around with parsing
10:26:40 <carter> why do we have fake accounts like 14WAB1N1Q  and stuff on channel?
10:26:45 <carter> dhrosa: yeah
10:26:47 <carter> dhrosa: also
10:26:51 <carter> GADTS are AMAZING
10:27:08 <triliyn> carter: the netsplits yesterday renamed lots of people for some reason
10:27:11 <simpson> carter: DDoS cruft; this channel doesn't have +r set
10:27:25 <carter> whats +r do?
10:27:31 * ski still wonders what k0ral wanted to do with 2/
10:28:04 <piezoid> how am i supposed to give default options to ghc in cabal config file ?
10:28:07 <piezoid> cabal-install version 1.19.2 says : Unrecognized field ghc-options
10:28:11 <k0ral> johnw: suppose you get to build S1, ..., SN progressively through the code; at the beginning, you would create a Map with only few of them; however, the Map is instance of any HasSX, even if it is not completely filled
10:28:17 <simpson> carter: Forbids /joins from connections which aren't identified with services.
10:28:27 <simpson> #python has used it to great effect.
10:28:32 <jle`> hank: in this case i'm not totally sure, but without more context, a forall in an isolated type signature like that is mostly redundant.  it just means that (>>) is m a -> m b -> m b, for all (type) values of a and b
10:28:35 <johnw> k0ral: yes, it would be partial
10:28:36 <carter> simpson: so i should do that for any channels i admin?
10:29:03 <johnw> k0ral: to combat that, put it behind an API with strict controls on how that map can be created and used, then you remove the potential for it to be used in an invalid way
10:29:36 <johnw> k0ral: for example, the only way to add/remove elements from the map would be a call like: withEnvironment Env1 (mkEnv1 ...) $ do ...
10:29:53 <jle`> hank: the docs give the reason for forall'ing (>>)
10:30:03 <hank> jle`: I’m just now trying to understand the haskell report on declarations, but I think I’m missing some basics … I should probably start reading the report from the beginning soon.
10:30:04 <jle`> hank: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#%3E%3E
10:30:07 <k0ral> johnw: how would you even implement the instance HasSX (Map Key ...) ? what if the map is empty ?
10:30:18 <romm> Can anyone point me to a large, well designed, open source Haskell project?
10:30:19 <simpson> carter: Up to you. It's pretty useful though.
10:30:29 <carter> romm: ermine
10:30:30 <carter> and lens
10:30:33 <johnw> k0ral: just raise an error, your API will enforce the invariant
10:30:52 <dhrosa> does xmonad count?
10:30:56 <jle`> romm: pandoc?
10:30:56 <carter> yes
10:30:59 <carter> yes
10:31:03 <carter> ghc :)
10:31:06 <carter> heeheheh
10:31:07 <jle`> :P
10:31:10 <carter> its pretty good for its age
10:31:18 <k0ral> johnw: I understand one can enforce safety through the API, but getting it through the type system would be so much better :) but maybe I'm too idealistic
10:31:26 <carter> simpson: is there any down side to +r?
10:31:35 <carter> k0ral: its a power weight ratio
10:31:52 <k0ral> ski: what about 2/ ?
10:32:11 <romm> Hmm... Pandoc seems to fit, thanks guys.
10:32:35 <hank> jle`: hm, you mean s/docs/sources/ right? And yes, they do seem to give a reason, I just don’t understand it (yet) (;
10:32:46 <ski> carter : "-!- cmode      +r     - Registered users only.  Only users identified to services may join."
10:32:52 <carter> ok
10:32:55 <johnw> k0ral: the Map trick is to save boilerplate at the cost of totality; if you use type aggregates, you gain all the type safety, at the expense of writing a lot of instances; it's a trade-off, as carter said
10:33:16 <carter> k0ral: you may wanna look at UR/lang and Ermine to see how they do it
10:33:25 <carter> they have some cute tricks because of better record support
10:33:25 <ski> k0ral : i'm wondering what you wanted to achieve there (and how continuations was supposed to help)
10:33:29 <k0ral> tuples offer a typesafe but boilerplate implementation, while maps offer elegant but unsafe one
10:33:51 <ski> (also, in what sense are maps unsafe here ?)
10:33:56 <simpson> carter: Well, yes, there's the obvious downside that many people simply won't be in the channel if they have to work with services to do so. #python-unregistered has hundreds of people in it.
10:34:05 <levi> romm: chrisdone has a number of small/medium sized interesting projects he's done on github.
10:34:41 * ski 'd prefer not having `+r', except perhaps temporarily
10:34:44 <hank> jle`: Thanks for the pointer, I’ll go read the report now (:
10:34:45 <johnw> ski: instance HasFoo (Map Environments EnvironmentData) where hasFoo m = fromMaybe (error "uh oh") $ lookup Foo m
10:35:01 <jle`> hank: fair warning, i'm not sure that forall is a part of the haskell report
10:35:03 <jle`> i know it's not in 98
10:35:21 <ski> johnw> :t hasFoo
10:35:29 <k0ral> ski: the 'holes' described by the article are like my 'replaceable code sections'; you can see I posted a comment for this article regarding that question
10:35:40 <romm> levi: I'm just trying to get a "feel" of how does a large Haskell project look like
10:35:48 <johnw> ski: oh, you're right
10:35:54 <ski> (i am ?)
10:36:03 <johnw> well, at least in one respect here
10:36:07 <ski> k0ral : where ?
10:36:11 <romm> levi: So small tools are not exactly what I'm looking for.
10:36:23 <levi> romm: Well, what does "large" mean to you?
10:36:25 * ski is atm just trying to comprehend the situation
10:36:41 <k0ral> oh right, not under my pseudo: 'chahine'
10:36:47 <k0ral> ski: ^
10:36:49 <johnw> or maybe not; I don't have the time to sketch out the whole implementation, since I'm not even sure it's really what will solve k0ral's problem
10:37:13 <carter> k0ral: look at ermine
10:37:15 <carter> and ur/lang
10:37:24 <carter> also jonsterlings type level records thing
10:37:30 <k0ral> carter: sure, thanks for the pointer
10:37:44 <carter> vinyl records I think its called
10:38:02 <hank> jle`: http://www.haskell.org/onlinereport/decls.html mentions and uses it in the examples, I just have no idea what it’s saying because I’m missing basics or backgrounds (I guess) …
10:38:38 <levi> carter: By "ur/lang" do you mean "ur/web"?
10:38:48 <ski> k0ral : i'm suspecting GADTs perhaps can help with "but what about variable return types ?"
10:38:55 <romm> levi: Probalby >20k or something? Nothing concrete.
10:38:57 <carter> ur/web is a specific realization of ur
10:39:10 <carter> ski: closed type familes  :)
10:39:32 <levi> carter: It's the only realization as of yet, isn't it?
10:39:37 <carter> no clue
10:39:48 <sm> romm: darcs is another
10:39:58 <carter> hackage-server
10:40:01 <carter> cabal-install
10:40:46 * ski isn't quite yet getting how this parameterization ties in with continuations
10:40:56 <levi> yi is pretty big, though I'm not sure if it's a great example of code organization.
10:41:40 <levi> ski: I think they just happened to be the kind of thing he wanted to parameterize over.
10:41:53 <carter> hoodle is a neat one too
10:41:56 <carter> i've never used it
10:42:06 <ski> also i suspect indexed continuations might be better in this parameterization context thing
10:43:29 <sm> darcs is about 32k, hackage-server: 15k, cabal-install: 17k, Agda: 55k
10:43:53 <levi> Idris is probably a big chunk of haskell code, too.
10:43:54 <carter> also very very different applications all
10:43:57 <carter> yup
10:44:08 <carter> though idris code isn't necessarily a role mode
10:44:10 <levi> And, as someone else suggested, Ermine.
10:44:12 <carter> *model
10:44:25 <carter> levi: ermine is REALLY good modern haskell code
10:44:29 * hackagebot BlogLiterately 0.7.1.4 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.4 (BrentYorgey)
10:45:04 <levi> carter: I'm sure; but how much of a background in advanced haskell does one need to comprehend it?
10:45:42 <carter> idk, read it and look up stuff when you're stuck
10:46:48 <levi> I've tried to read through many of edwardk's libraries and had to sit there scratching my head for long periods of time.
10:47:37 <levi> A good exercise, sure, but it will be a long time before *I* could put things together that way.
10:48:01 <carter> levi: solution, each time youre stuck, ask for help
10:48:16 <k0ral> ermine is quite above my understanding capabilities right now...
10:48:29 <carter> k0ral: why?
10:48:29 <romm> The more I read about Haskell the less enthusiastic I am about it, carter. Everyone uses many extensions, which usually add synatctic sugar and make the code more terse.
10:48:46 <carter> romm: is that romey?
10:48:53 <romm> It's not a fun language to learn, I'll tell you that.
10:48:59 <carter> romm: which stuff have you tried to read?
10:49:04 <carter> and have you asked for help when confused?
10:49:07 <carter> are you asking now? :)
10:49:08 <sm> romm: not everyone.. look at a number of different code bases/types of project/author
10:49:13 <levi> Depends on what you think is fun, I guess. :)
10:49:16 <carter> theres SOOO MANY different styles
10:49:29 * hackagebot blaze-svg 0.3.3.1 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.3.1 (BrentYorgey)
10:49:29 <carter> romm: please please tell me you weren't looking at yesod
10:49:32 <romm> ^ That is not entirely a plus for beginners, carter.
10:49:48 <carter> romm: are you a begiiner? have you tried reading learn you a haskell?
10:50:07 <ski> hm, instead of `data Hole = Swing Int | Attack Target', to be combined with `swingBack :: Int -> IO (); damage :: Target :: IO ()', for `unitAttack :: Target -> ContT () IO Hole'
10:50:16 <carter> k0ral: what are you confused by
10:50:29 <ski> k0ral : what's the intended types for `???_1' and `???_2' ?
10:50:33 <romm> carter: Yes, I finished it (mostly. I have some Monad functions / examples left at the end)
10:50:36 <carter> ok
10:50:47 <piezoid> why it's not possible to use closed type families in instance head ?
10:50:48 <carter> romm: what are some specific code basees you've looked at and disliked?
10:50:55 <carter> piezoid: playing with 7.8 RC?
10:51:05 <piezoid> carter: yes =)
10:51:09 <ski> k0ral : i assume `???_2 :: Target -> IO ()' actually. and probably then `???_1 :: Int -> IO Bool', or something similar
10:51:27 <carter> piezoid: because the instance head needs to be injective
10:51:33 <carter> right?
10:51:42 <carter> open/closed type families reduce!
10:51:48 <k0ral> carter: for now, nothing in particular, it's just too much an amount of information to process at one time to be able to understand it; "I'm just not ready to spend that much time to figure it out right now" would have been a better wording than "is above my understanding capabilities"
10:52:01 <levi> Actually, now that I look at the ermine repository, there's plenty to learn from it without having to understand much about how the code itself works.
10:52:18 <carter> k0ral: levi  yeah, its got lots of good idea nuggets
10:52:28 <piezoid> oh, closed TF are injective too ?
10:52:32 <carter> nope
10:52:34 <carter> data familes are
10:52:35 <levi> Looks very well-organized.
10:52:46 <carter> levi: yuip
10:53:19 <ski> k0ral : given that, i wonder if we could make `data Hole :: * -> * where TrySwing :: Int -> Hole Bool; Attack :: Target -> Hole ()', or something like that (i'm not sure what you intended `???_1' to model here)
10:53:29 <piezoid> carter: ok, it make sense...
10:53:34 <k0ral> ski: sure, those signatures work; I just wanted to point out that the constraint of having the same return type for continuation holes is a big one
10:53:36 <carter> piezoid: it took me a while to get that too
10:53:47 <carter> piezoid: basically data families are awesome and your friend
10:53:54 <ski> k0ral : i agree. i think GADTs and indexed monads can help with that one
10:54:05 <ski> hm
10:54:14 <k0ral> adding GADTs and indexed monads to the list of stuff I have to learn
10:54:21 <ski> hehe
10:54:34 <ski> k0ral : anyway, just pondering around whether one could make this work out
10:54:34 <piezoid> carter: never used them, i'll take a look
10:54:41 <levi> I am continuing to like haskell, despite the long learning curve, because it is very good at exposing my poor thinking to me and making me fix it. And it *helps* me fix it correctly.
10:54:42 <carter> piezoid: have you used vector?
10:55:09 <carter> piezoid: vector is probably the most widely used exemplar of data familes
10:55:17 <ski> k0ral : so, let's start from `unitAttack :: Target -> ContT () IO Hole', being code for `unitAttack :: Target -> (Int -> IO ()) -> (Target -> IO ()) -> IO ()'
10:55:22 <k0ral> ski: if you figure a way, please let me know :D
10:55:37 <ski> k0ral : now we want `unitAttack :: Target -> (Int -> IO Bool) -> (Target -> IO ()) -> IO ()' instead, afaict
10:57:08 <ski> uncurrying gets us an argument of type `(Int -> IO Bool,Target -> IO ())' -- now since the result type isn't the same any more, we can't any longer convert from `(Int -> IO (),Target -> IO ())' to `Either Int Target -> IO ()' (which in the article is `Hole -> IO ()')
10:57:21 <ski> however, what is a `Hole -> IO ()' ?
10:57:39 <piezoid> carter: i've scratched the surface, those V looked interesting
10:57:56 <ski> well, a `Hole' can either be `Swing n' for `n :: Int' or `Attack t' where `t :: Target'
10:58:14 <romm> carter: I actually don't remember which code based made me confused. I'll look at pandoc and hackage-server and get back to you.
10:58:21 <ski> so `Hole' just enumerates some possible choices of action, with some adjoining info for each choice
10:58:23 <carter> romm: why those?
10:58:30 <carter> romm: hackage-server isn't a *good* example
10:58:32 <carter> lib
10:58:38 <carter> pandoc is a good example though
10:58:44 <carter> very very well done code
10:58:51 <romm> Okay, pandoc then.
10:58:53 <ski> and then a `Hole -> IO ()' is basically a table of `IO ()'-actions, saying what should be done for each such action
10:58:58 <ski> k0ral : following ?
10:59:01 <k0ral> ski: the same way, I was bothered by this use of 'Hole', as it makes you implement a dispatcher, which isn't a nice thing
10:59:10 <k0ral> ski: following, yes
10:59:11 <ski> k0ral : ok, noted
10:59:43 <ski> (i'm not really sure whether this continuation approach is really what you want here, just attempting to follow the idea of the article, extending it somewhat)
10:59:56 <k0ral> ski: I basically don't like the "continue :: Hole -> IO ()" function, as it doesn't scale well
11:00:15 <ski> so, by GADT magic, we can express `(Int -> IO Bool,Target -> IO ())' as `forall a. Hole a -> IO a'
11:00:35 <ski> this allows each choice in the `Hole' datatype to express the intended return type
11:00:48 <ski> remember that we had `data Hole :: * -> * where TrySwing :: Int -> Hole Bool; Attack :: Target -> Hole ()'
11:01:13 <k0ral> I wouldn't be surprised to see you conclude continuations don't make any sense in my case, I was just mesmerized by the hole-filling description of the author and wondered whether this could be generalized truly
11:01:32 <levi> romm: I believe pandoc was started early in jgm's haskell career, so I'm not sure how much of it is organized the way it would be if he started out fresh today. The code itself is pretty readable, though.
11:01:33 <ski> so the `TrySwing' "tag" says that an action (callback) implementing this ought to return a `Bool' (after doing I/O) (since that's what the code calling the callback expects as a result)
11:01:54 <ski> hm, so this leaves us at what ?
11:02:17 <k0ral> I don't know GADT but I see the point, yes
11:02:22 <ski> `unitAttack :: Target -> (forall a. Hole a -> IO a) -> IO ()'
11:02:51 <ski> k0ral : ordinarily, when you specify a parameterized datatype, the result types of the constructors have to be distinct type variables
11:02:54 <ski> @src Maybe
11:02:54 <lambdabot> data Maybe a = Nothing | Just a
11:02:57 <ski> gives you
11:03:02 <ski>   Nothing :: Maybe a
11:03:09 <ski>   Just    :: a -> Maybe a
11:03:17 <romm> levi: The lack of OOP classes really takes a toll on my brain :)
11:03:37 <ski> k0ral : with GADTs, you can explicitly specify the parameters on the return type of the data constuctors to be any (valid) types you want
11:03:38 <k0ral> romm: you have to unlearn what you have learned :)
11:03:57 <ski> k0ral : you can use this to "attach extra information" on the constructors, telling in what situations they apply
11:04:09 <ski> it's pretty powerful, for some kinds of situations
11:04:09 <levi> romm: It does take a different way of looking at things. I never did get my brain completely re-wired to OOP, though, as I mostly do low-level C programming.
11:04:20 <romm> k0ral: Can't take that risk yet. I'm currently using what I learned :)
11:04:45 <sm> patch it in! more wire!!
11:04:49 <ski> k0ral : if you have a `Hole a', and pattern-match on `TrySwing n', then if this match succeeds, you *know* that the type `a' is actually `Bool'
11:04:57 <levi> Haskell's type classes correspond better to the ways that people actually do C-level abstraction than OO classes do.
11:05:05 <levi> At least IMHO.
11:05:13 <k0ral> romm: well, as far as I can tell, learning the purely-functional way made me a better OO programmer
11:05:46 <nadirs> romm: I often hear saying that XMonad is an example of excellent Haskell design
11:06:24 <joelteon> How do I determine if my GHC is profiled or not?
11:07:12 <romm> nadirs: I'll take a look.
11:07:48 <romm> By the way, what does !X mean, for some type X?
11:07:59 <joelteon> Strict field
11:07:59 <geekosaur> evaluate to WHNF
11:08:07 <ski> k0ral : hm, actually i'm not sure atm whether indexed monads would be appropriate here
11:08:09 <shachaf> It means nothing on its own. In a data type declaration it means a strict field.
11:08:52 <joelteon> also means if you create a record without that field initialized, it's a compile error instead of a compile warning
11:08:55 --- mode: morgan.freenode.net set +o ChanServ
11:08:57 <ski> k0ral : anyway, i suspect that perhaps <http://hackage.haskell.org/package/MonadPrompt> might also be relevant to what you're trying to do
11:09:14 <ski> hm .. can we even make this `(forall a. Hole a -> IO a) -> IO ()' stuff into a monad ?
11:09:43 <ownclo> > 2 + 2
11:09:44 <lambdabot>  4
11:09:54 <ski> ownclo : why do you do that ?
11:10:54 <romm> joelteon: "also means"? Isn't that the definition of strict?
11:11:22 <joelteon> "strict" usually means "evaluate to WHNF", it doesn't have anything to do with compiler errors vs warnings
11:11:24 <joelteon> as far as I know
11:11:35 <romm> WHNF?
11:11:41 <ski> `f' being strict means `f _|_ = _|_'
11:11:43 <joelteon> weak head normal form
11:11:46 <romm> (Sorry, I'm new)
11:11:47 <geekosaur> "weak head normal form", i.e. to the first data constructor
11:12:14 <geekosaur> in particular, for a list this means it evaluates to [] or (:), and does not evaulate any values *within* the list
11:12:43 <ski> iow, if you pass an expression which doesn't evaluate to a value to `f', then this expression (the application of `f') also won't evaluate to a value
11:12:47 <geekosaur> `strictField = undefined` fails, but `strictField = (undefined : [])` does not
11:12:48 <levi> joelteon: So, constructing a record with bottoms in it forces the whole record to bottom, which the compiler tells you will *definitely* be an error instead of just possibly leading to an error.
11:13:18 <joelteon> ok, if you say so
11:13:31 <nadirs> levi: but doesn't it contradict what geekosaur just said?
11:13:51 <geekosaur> levi was speaking loosely
11:13:53 <ownclo> ski,  I am rather new at IRC channels, and today I constantly get kicked out (ddos?) and it makes me nervous when I see no messages other than join/quit. So that was a test whether IRC is responsive.
11:14:12 <jle`> > const 1 undefined
11:14:12 <lambdabot>  1
11:14:17 <geekosaur> and meant what I said, more or less. you cannot force "deep evaluation"
11:14:22 <joelteon> > const 1 $! undefined
11:14:23 <lambdabot>  *Exception: Prelude.undefined
11:14:27 <ski> ownclo : you could try `/msg lambdabot > ()' .. or `/msg NickServ info ownclo'
11:14:33 <ownclo> ski, I thought that lambdabot messages are private by default. Sorry for that
11:14:34 <Fuuzetsu> how do I get hoogle to do what I want? See http://fuuzetsu.co.uk/images/1391454636.png , it doesn't make sense to me.
11:14:41 <levi> In geekosaur's example, there's a list containing a bottom in the strict field, which is not the same as having a bottom in the strict field because lists are lazy.
11:14:49 <ski> ownclo : no worry, just wondering what you were up to
11:15:05 <ski> (also you didn't get "kicked out")
11:15:19 <nadirs> geekosaur, levi: ok, thanks for clarifying :)
11:15:52 <Fuuzetsu> oh, searching for ':: BufferM String' helps.
11:17:26 <ski> (ownclo : to clarify, (presumably) your connection to the IRC network got broken a few times, due to the DDoS making the network a bit unresponsive)
11:17:34 <geekosaur> (there *is* a way to do deep evaluation but it is not part of the language like ! strict fields are. see NFData / deepseq)
11:20:08 <levi> There's also -XBangPatterns; also not deep evaluation, but another option for making some things strict.
11:22:12 <k0ral> ski: thank you for the link, sorry for the late answer, I was afk
11:22:30 <maurer> Is there an easy way to do integer division which rounds up?
11:22:45 <maurer> I only see quot and div, which are not the right rounding modes
11:23:58 <joelteon> you can convert to floating point, use (/), then ceiling on the result
11:24:13 <maurer> OK. I saw that, it just seemed silly
11:24:23 <shachaf> maurer: Add n-1 before dividing, or something along those lines?
11:24:37 <Fuuzetsu> uh, I have code like this: do { p <- foo; something $ other p }
11:24:49 <Fuuzetsu> but when I desugar it to: foo >>= something . other
11:24:54 <Fuuzetsu> I get a type error
11:25:10 <Fuuzetsu> in this case:    Couldn't match type `BufferImpl syntax0 -> Point' with `forall syntax. BufferImpl syntax -> Point'
11:25:15 <simpson> @undo do { p <- foo; something $ other p }
11:25:15 <lambdabot> foo >>= \ p -> something $ other p
11:25:22 <Fuuzetsu> how does existential quantification affect this?
11:25:29 <simpson> @pl \p -> something $ other p
11:25:29 <lambdabot> something . other
11:25:48 <ski> Fuuzetsu : what's the type of `foo' and what is `p' ?
11:25:52 <simpson> Oh, it's probably DMR. See if turning it off helps.
11:26:01 * geekosaur thinks impredicative types strike again?
11:26:24 <Fuuzetsu> DMR?
11:26:42 <simpson> Dreaded Monomorphism Restriction.
11:26:57 <romm> ...Is this a real thing?
11:27:08 <chirpsalot> joelteon: converting to float seems like a bad idea.
11:27:15 <simpson> Yes, it's a real thing.
11:27:16 <Fuuzetsu> oh
11:27:17 <joelteon> yeah, it's quite epensive
11:27:30 <joelteon> but that's the only way I could think of off the top of my head
11:27:35 <joelteon> maybe there's a library for it
11:28:06 <chirpsalot> joelteon: also inaccuracies! What shachaf suggested is surely a better idea? i.e., (x + n - 1) `div` n?
11:28:21 <joelteon> oh, I didn't think of that
11:28:35 <joelteon> I wouldn't think floating-point inaccuracy would be an issue if you're going to round up the result anyway
11:28:44 <Fuuzetsu> ski: actualy code: https://github.com/yi-editor/yi/blob/master/yi/src/library/Yi/Buffer/Misc.hs#L1134
11:28:53 <shachaf> Floating point division is the scow of division.
11:29:15 <chirpsalot> Scow?
11:30:06 <chirpsalot> joelteon: iunno, I think you might run into issues with larger integers, but I will admit I am not sure. Floating point arithmetic is not to be trusted, though :P.
11:30:15 <shachaf> garbage scow. it's the worst.
11:30:57 <chirpsalot> joelteon: it's kind of like converting a 32-bit int to a 16-bit int... You can do it, but you might lose some accuracy?
11:31:08 <davidfetter_disq> much worse
11:32:06 <joelteon> You know, now that shachaf's suggested that, I'm going to go back into my code and find places where I've been doing exactly that ^
11:32:09 <joelteon> and turn it into a div
11:32:22 <chirpsalot> joelteon: haha :).
11:32:34 <chirpsalot> joelteon: onwards, to mathematical rigor! Ho!
11:33:21 <joelteon> I decided on comp sci so I wouldn't have to do math ):
11:33:44 <chirpsalot> joelteon: everything comes back to math eventually :D.
11:33:45 <geekosaur> uh huh
11:34:15 * geekosaur is reminded that CMU's undergrad comp sci includes discrete math
11:34:22 <geekosaur> just try to get away
11:35:11 * davidfetter_disq wants to study indiscrete math
11:35:21 <levi> If there's an accredited CS program somewhere that *doesn't* include discrete math and linear algebra somehow, I'd be surprised.
11:35:45 <davidfetter_disq> levi, you are heading for heavy disappointment :(
11:36:05 <chirpsalot> levi: I feel like linear algebra, oddly enough, is not always required.
11:36:24 <levi> Possibly.
11:36:26 <ownclo> geekosaur, you try to get away from math while using haskell
11:36:48 <chirpsalot> ownclo: try to get away from math in any programming language.
11:36:49 <davidfetter_disq> chirpsalot, could you elucidate a bit? so many things depend on matrices and similar objects that i don't see how you get around it
11:37:08 <levi> I'm pretty sure you get some discrete math, though, even if it's not the name of the course.
11:37:21 <ownclo> chipdude, I agree
11:37:52 <grady_player> I have had to learn more about discreet math in solving projecteuler.net problems than I ever got in formal education
11:37:52 <chirpsalot> davidfetter_disq: yeah, but I feel like a lot of CS students don't actually take linear algebra courses. It's not technically required in some CS programs.
11:38:04 <romm> How odd.
11:38:39 <davidfetter_disq> chirpsalot, ah, you're talking about the required coursework, not the need for the knowledge. got it. :)
11:39:24 <joelteon> well I haven't gone to university yet
11:39:24 * ReinH shrugs
11:39:26 <ReinH> math is awesome, why flee it?
11:39:34 <joelteon> the most high-level math I've done is AP calculus BC
11:39:39 <ReinH> math *education*, on the other hand... :/
11:39:50 <chirpsalot> davidfetter_disq: pretty sure it's not required for mine. It might be a prerequisite, but in most cases you barely need any understanding of linear algebra in a lot of the CS courses. You can hack your way through without a full foundation of it. And generally the profs explain any time there is a vector or matrix.
11:40:19 <ski> Fuuzetsu :  solPointB = queryBuffer . solPoint' =<< pointB  ?
11:40:32 <chirpsalot> davidfetter_disq: not that I would recommend avoiding linear algebra :P.
11:40:37 <romm> chirpsalot:  Must be a problem in the graphics courses :)
11:40:51 <davidfetter_disq> chirpsalot, well, it's been a long, long time since college for me
11:40:56 <davidfetter_disq> ...and i didn't study CS
11:41:02 <chirpsalot> romm: graphics isn't a required course :P -- I think here they just do 3DSMax anyway >_<
11:41:19 <Fuuzetsu> ski: Hm? That's no different than what I posted before that does not work, except with =<< and not >>=
11:41:20 <ski> @wn scow
11:41:23 <lambdabot> *** "scow" wn "WordNet (r) 3.0 (2006)"
11:41:23 <lambdabot> scow
11:41:23 <lambdabot>     n 1: any of various flat-bottomed boats with sloping ends
11:41:23 <lambdabot>     2: a barge carrying bulk materials in an open hold
11:41:36 <Fuuzetsu> well, I reversed the commit already anyway, I know why it doesn't work now
11:42:26 <ski> Fuuzetsu : hm
11:42:28 <ski>   queryBuffer :: (forall syntax. BufferImpl syntax -> x) -> BufferM x
11:42:29 <ski> i see
11:43:16 <ski> Fuuzetsu> :t solPoint'
11:43:50 <chirpsalot> romm: I did write my first raytracer without really knowing linear algebra, though? I mean, I used it obviously, but I didn't know it was "linear algebra" at the time?
11:45:19 <romm> chirpsalot: Well, in the first ray tracer I wrote I messed with uniform distributions on the sphere and other funny stuff. Had I not known linear algebra I would be dead :)
11:46:53 <chirpsalot> romm: for rays to spherical lamps?
11:47:07 <Eduard_Munteanu> How bad is throwing exceptions (of the Control.Exception sort) from pure code? I'm considering doing that for some parsing functions and things that should abort execution on error conditions.
11:47:39 <ownclo> seems that everybody wrote a number of raytracers around there
11:47:41 <romm> chirpsalot: Yep.
11:47:47 <romm> chirpsalot: Soft shadows, etc.
11:52:08 <ownclo> Eduard_Munteanu, I think that it is generally a good idea to avoid using exceptions in pure code. Did you try using existing parser combinator libraries instead of creating your own parsing functions?
11:52:24 <c_wraith> Eduard_Munteanu: the main opinion is that you should only get exceptions from pure code if you violate a precondition that the code documents - ie, programmer error
11:53:06 <Eduard_Munteanu> ownclo: it's really simple stuff that's nicer to parse with Text combinators
11:54:09 <Eduard_Munteanu> c_wraith: IOW, when exceptions are (fatal) errors as opposed to flow control devices?
11:55:04 <chirpsalot> romm: it is kind of silly how non trivial it is to get a uniform distribution on a sphere :P.
11:55:22 <c_wraith> Eduard_Munteanu: well, at a higher level you might decide they're not fatal - say in a web server main loop. It shouldn't crash just because of some bad code.  But that's an entirely different concern than control flow.
11:56:18 <Eduard_Munteanu> Hm. I'm basically translating a bash script to Haskell here, not writing a library, so I guess it's fine.
11:56:37 <Eduard_Munteanu> s/translating/reimplementing
11:56:41 <c_wraith> if that's what you're doing, why aren't you using a library specifically designed for it?
11:57:22 <c_wraith> like the stuff in the errors package
11:57:32 <jrmithdobbs> how do you make haddock not choke on CPP decls? am I missing something?
11:57:33 <Eduard_Munteanu> c_wraith: like Shelly? I'll have a look at it sometime but right now the shell / execution bits are reasonable
11:57:42 <c_wraith> Eduard_Munteanu: no, like errors
11:57:49 <jrmithdobbs> :2:2: parse error on input `#'
11:58:04 <c_wraith> Eduard_Munteanu: that is, something designed for handling errors in a quick and somewhat dirty way, but with a clean interface
11:58:27 <ReinH> +1 shelly for... shell scripts
11:59:01 <Eduard_Munteanu> c_wraith: heh, that looks like my setup basically, except I use   MonadIO io, MonadError Text io   :)
11:59:01 <MarcWebe1> jrmithdobbs: Maybe it has to know that it should run CPP ?
11:59:22 <jrmithdobbs> MarcWebe1: there's a {-# LANGUAGE CPP #-}
11:59:26 <jrmithdobbs> so it should?
11:59:55 <MarcWebe1> jrmithdobbs: I don't know, sry. I never cared much about it - it was just an idea.
12:00:07 <MarcWebe1> try haddock --help or such to see whether there are additional options or such.
12:00:19 <MarcWebe1> CPP adds line preserving hints, thus there should be no issue IMHO.
12:03:22 <joelteon> do LANGUAGE pragmas have to be at the top of the file?
12:03:48 <c_wraith> yes
12:04:10 <c_wraith> they have to be before the module line (or where it would be, if it's implicit)
12:04:42 <c_wraith> the rules might even be more strict than that
12:05:31 <Eduard_Munteanu> BTW, can you #include pragmas with {-# LANGUAGE CPP #-}\n#include "mypragmafile.hs"   ?
12:05:45 <romm> chirpsalot: It's trivial once you know the solution :)
12:08:11 <Twey> Eduard_Munteanu: Throwing exceptions is always bad, but sometimes less work (for you or for the caller) than making your function total
12:09:14 <chirpsalot> romm: isn't everything? :)
12:09:59 <Eduard_Munteanu> Twey: I'm just getting annoyed by the monad-y bits in otherwise pure functions
12:10:41 <Twey> Eduard_Munteanu: You can catch exceptions in something like Either, which is pure
12:11:44 <Eduard_Munteanu> Twey: yeah, that's what I have right now, it complicates types a bit
12:16:35 <jrmithdobbs> aha! if I put it in module-extensions: instead of other-extensions: in the .cabal haddock magically works
12:17:33 <dcoutts> jrmithdobbs: when you had it in other-extensions, did you also have {-# LANGUAGE CPP #-} in the relevant .hs files?
12:17:41 <jrmithdobbs> dcoutts: yes
12:17:54 <jrmithdobbs> dcoutts: everything built fine haddock just spit out errors when it hit the generated cpp stuff
12:19:16 <dcoutts> jrmithdobbs: hrm, odd since it's using the same cpp stuff as ghc (indeed it's using the ghc frontend)
12:19:25 <dcoutts> jrmithdobbs: got an example?
12:21:02 <jrmithdobbs> dcoutts: not that i can share, it was nothing exotic just a -- | at top of module and a couple of int #defines then 3 functions with -- | ... with CPP in other-modules and LANGUAGE pragma it barfs, throw it in module-extensions and it worked fine ... adding it to ghc-options as -cpp or -XCPP didn't matter either
12:55:56 <`Jake`> I don't suppose there is a way of doing this where run has the type signature IO () ? http://lpaste.net/99410
12:56:48 <Clint> `Jake`: you mean without the argument?
12:56:56 <`Jake`> Clint: yeah
12:57:09 <Clint> then what would it be printing?
12:57:42 <studmuf> Suppose we have the following type of binary search trees with keys of type k and values of type v:
12:57:42 <studmuf> data BST k v = Empty |
12:57:42 <studmuf>                Node k v (BST k v) (BST k v)
12:57:44 <studmuf> Write a val function that returns Just the stored value at the root node of the tree. If the tree is empty, val returns Nothing.
12:57:46 <studmuf> val :: BST k v -> Maybe v
12:57:48 <studmuf> Example:
12:57:50 <studmuf> > val Empty
12:57:50 <`Jake`> I just thought there might possibly be a way of giving it that information through the context in which the function is used
12:57:51 <lambdabot>  Not in scope: `val'
12:57:51 <lambdabot>  Perhaps you meant one of these:
12:57:51 <lambdabot>    `Sym.var' (imported from Data.Number.Symbolic),
12:57:51 <lambdabot>    `var' (imported from Debug.SimpleReflect),
12:57:51 <lambdabot>    `ival' (imported from Data.Number.Interval)Not in scope: data constructor ...
12:57:52 <studmuf> Nothing
12:57:54 <studmuf> > val (Node 0 23 Empty Empty)
12:57:55 <lambdabot>  Not in scope: `val'
12:57:55 <lambdabot>  Perhaps you meant one of these:
12:57:56 <studmuf> Just 23
12:57:57 <lambdabot>    `Sym.var' (imported from Data.Number.Symbolic),
12:57:58 <studmuf> Hey I was wondering what is the best way to implement ?
12:57:59 <lambdabot>    `var' (imported from Debug.SimpleReflect),
12:58:00 <studmuf> This
12:58:01 <lambdabot>    `ival' (imported from Data.Number.Interval)Not in scope: data constructor ...
12:58:12 <haasn> please don't paste in here
12:58:30 <`Jake`> http://lpaste.net/new/haskell
12:59:15 <nicoo> @quote monads
12:59:15 <lambdabot> spb says: [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
12:59:19 <nicoo> @quote monads
12:59:19 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
12:59:27 <nicoo> @quote monads endofunctors
12:59:27 <lambdabot> No quotes for this person. And you call yourself a Rocket Surgeon!
12:59:34 <subleq> does ##freenode-social still exist?!?
12:59:36 <nicoo> :(
12:59:39 <subleq> i thought it was gone for many years
12:59:45 <nicoo> @quote endofunctors
12:59:45 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
12:59:49 <nicoo> @quote endofunctors
12:59:49 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one example of such a product. <mauke> I have no idea what you just said
13:00:01 <nicoo> @quote endofunctors
13:00:02 <lambdabot> ciaranm says: a comonad is just a comonoid in the category of endofunctors. what's the coproblem?
13:01:14 <osa1> in a function application "f x" are there special names given to "f" and "x"?  (in mathematics or PL theory)
13:01:49 <nicoo> « function » and « argument » ?
13:02:05 * nicoo used French quotation marks, again :(
13:02:28 <osa1> nicoo: I was looking for something like "applicand" or  something like that. I remember hearing that somewhere but can't be sure.
13:02:34 <ownclo> osa1, 'x' can sometimes be called a 'domain'
13:02:56 <pavonia> `Jake`: In what context do you want to print what?
13:03:17 <nicoo> ownclo: “x” isn't the domain. It is an *element* of the domain.
13:03:37 <nicoo> (Or codomain, I always get confused wrt. which is which)
13:04:32 <`Jake`> pavonia: Well, it's a contrived problem based on a real problem. Basically, I want to import that module and use run in another file where I define the type of that class. I don't think actually think it's possible w/o the argument, though.
13:04:59 <ownclo> nicoo, ow, that's true. sorry
13:05:54 <eacameron> is (:=) a built in symbol? or, why cannot I not use it for my own function?
13:06:41 <prophile> eacameron: starts with a colon
13:06:53 <prophile> operators starting with colon are for data constructors
13:06:55 <Twey> eacameron: Colons are uppercase ;)
13:07:13 <flebron> heh
13:07:13 <eacameron> wow...never knew that before
13:07:19 <Twey> eacameron: Plenty of things use (=:) for that
13:07:22 <eacameron> totally changes the way I sort text ;)
13:07:27 <Twey> Hehe
13:07:37 <Twey> eacameron: $= is also popular
13:07:50 <flebron> > toUpper ':'
13:07:51 <lambdabot>  ':'
13:07:52 <eacameron> that's it...I'm resorting to Unicode
13:08:01 <ReinH> Twey: heh I never figured that out
13:08:03 <prophile> ∶= might work
13:08:06 <Twey> Yes, one more on the side of the light
13:08:19 <Twey> ReinH: Figured what out?
13:08:25 <eacameron> > toUpper '$'
13:08:26 <lambdabot>  '$'
13:08:28 <ReinH> Twey: that : is uppercase
13:08:43 <Twey> Haha, oh
13:08:50 <triliyn> > fix toUpper
13:08:54 <lambdabot>  mueval-core: Time limit exceeded
13:08:57 <prophile> oh, here we go
13:08:57 <Twey> There used to be a running joke that : is ‘uppercase punctuation’
13:09:06 <prophile> eacameron: use ≔
13:09:15 <ReinH> Twey: right, it's a clever way to remember that : is for infix type constructors ;)
13:09:24 <eacameron> prophile: thanks, that's what I need!
13:09:32 <`Jake`> so toLower ':' == '.' should actually be True?
13:09:33 <Twey> ReinH: Infix data constructors, too
13:09:38 <Twey> (wxWidgets does that one)
13:09:45 <Twey> (sorry, Gtk2Hs)
13:09:47 <eacameron> `Jake`: haha
13:09:49 <ReinH> yep, so does Comonad.Cofree iirc
13:10:04 <Twey> What for?
13:10:05 <prophile> eacameron: you're welcome
13:10:08 <prophile> as a matter of practicality
13:10:13 <ReinH> Twey: http://hackage.haskell.org/package/free-2.0.2/docs/Control-Comonad-Cofree.html
13:10:13 <prophile> when you get murdered by people maintaining your code
13:10:18 <prophile> would you like to be buried or cremated?
13:10:23 <ReinH> data Cofree f a = a :< f (Cofree f a)
13:10:28 <prophile> (assuming there's enough of you left for the former :3)
13:10:44 <Twey> Oh, right — yeah, that's not (:=) though :þ
13:10:59 <ReinH> Twey: ah, I was just referring to infix data construtors
13:11:05 <eacameron> prophile: don't worry, the won't be able to find me, because my contact info will also be in Unicode
13:11:11 <Twey> Gtk2Hs has an action like setAttribs someWidget [oneAttrib := a, otherAttrib := b]
13:11:16 <prophile> hah
13:11:18 <ReinH> ah ha
13:12:00 <Twey> (:<) is a very in-demand operator
13:12:13 <Twey> I've used it for two different things today alone
13:12:23 <eacameron> the only serious downside to such extensible operators in Haskell is that Google won't help you search for them
13:12:33 <Twey> eacameron: Hoogle will, though
13:12:42 <eacameron> Twey: true...
13:12:47 <geekosaur> or symbolhound
13:13:08 <Twey> geekosaur: Cool, hadn't met that one
13:13:13 <ReinH> Twey: hah
13:13:16 <etandel> (:<) is such an unhappy face
13:13:26 <eacameron> geekosaur: wow, a search JUST for that, awesome
13:13:27 <ReinH> etandel: and (:[]) is of course a monkey face
13:13:35 <etandel> lol
13:13:45 <Twey> Yeah, the top results on SymbolHound are all :< as a sad-face :þ
13:14:14 <etandel> thanks, ReinH, for me, cons will never be the same anymore. =P
13:14:26 <ReinH> etandel: :D
13:14:37 <eacameron> symbolhound actually found a good answer: http://stackoverflow.com/questions/6444303/haskell-operator
13:15:36 <Twey> It finds a few, but they're scattered amongst the sad-faces
13:16:15 <Twey> Is it safe to upgrade to 7.8 yet?  Is my system going to break horribly?
13:19:33 <studmuf> so if i wanted to traverse a BST and grab the contents of root in haskell using this data type, > data BST k v = Empty | Node k v (BST k v) (BST k v) and using this type declaration > val :: BST k v -> Maybe v. How would I do it?
13:20:31 <Cale> val Empty = Nothing; val (Node k v l r) = Just v
13:20:52 <Twey> Not really traversal, mind
13:21:04 <studmuf> Cale: thank you
13:21:13 <studmuf> Twey: you're right it's not
13:21:34 <studmuf> Twey: I'm still very new to functional programming
13:21:51 <Twey> studmuf: But that is the function you wanted?
13:21:58 <studmuf> Yea
13:22:09 <studmuf> I believe so
13:22:13 <Twey> It's all good then ☺
13:22:16 <studmuf> let me run it
13:25:31 <Cale> You could do an actual traversal like:  lookup k Empty = Nothing; lookup k (Node k' v l r) = case compare k k' of LT -> lookup k l; EQ -> Just v; GT -> lookup k r
13:26:54 <studmuf> Interesting. ill try that as well.
13:26:58 <studmuf> how would a crate a BST using this data type (also a vary noob question)?
13:27:05 <studmuf> *I
13:28:21 <jle`> studmuf: create? as in, build?
13:29:19 <jle`> well, an empty tree would be Empty
13:29:49 <jle`> inserting a root would be Node rootKey rooVal Empty Empty
13:29:51 * hackagebot BiobaseXNA 0.8.1.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.8.1.0 (ChristianHoener)
13:29:53 * hackagebot ADPfusion 0.2.1.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.2.1.0 (ChristianHoener)
13:30:01 <Cale> studmuf: Well, getting it balanced is another thing, but you could do something "bad" easily like  fromList [] = Empty; fromList ((k,v):xs) = Node k v (fromList small) (fromList big) where (small,big) = partition ((< k) . fst) xs
13:30:38 <studmuf> jle`: I think so. I'm using ghci and want to instantiate a Tree using to test the funcitons suggested by Cale
13:30:49 <studmuf> Emtpy was easy
13:31:10 <Cale> studmuf: Oh, you can just write one using the constructors as functions
13:31:17 <jle`> you can do arbitrary trees by replacing Empty's with Nodes
13:31:30 <jle`> but that won't guaruntee BST ordering of course
13:31:44 <Cale> Node 2 "hi" (Node 1 "there" Empty Empty) (Node 3 "world" Empty Empty)
13:31:47 <jle`> Node rootKey rootVal (Node leftKey leftVal Empty Empty) (Node rightKey rightVal Empty Empty)
13:31:55 <studmuf> Cale: jle`: thanks
13:32:03 <jle`> there's a nice text on tree data structurs in functional/pure languages
13:32:05 <jle`> http://www.amazon.com/dp/0521663504/ref=pe_385040_30332200_pe_309540_26725410_item
13:32:27 <jle`> keep in mind that a lot of its performance analyses are based on implicit strictness assumptions
13:32:46 <jle`> but it should help you get started with how to work with your tradiational data structures in functional programming, plus more
13:33:17 <jle`> and also things to remember when working with data structures in a functional/pure language
13:33:24 <studmuf> jle`: awesome. I'll order it up
13:33:36 <jle`> it was ten dollars about a month ago..i wonder what happened
13:33:52 <studmuf> School started
13:33:59 <jle`> heh
13:34:12 <Twey> 41 used from $5.39
13:34:14 <Cale> and/or too many people looked at the amazon page for it
13:34:36 <jle`> it was $10 for the official amazon distributor
13:34:41 <jle`> but yeah there are nice used ones
13:34:51 * hackagebot pandoc-types 1.12.3.2 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.3.2 (JohnMacFarlane)
13:35:04 <jle`> BST's actually might be a good intermediate-ish haskell data structure to implement, but you should sort of know how to work with normal binary trees first
13:36:13 <studmuf> agreed
13:36:48 <studmuf> I'm currently using the web version of learn you a haskell as my main resource
13:36:53 <Cale> (You should also learn about Data.Set and Data.Map which are internally implemented as balanced binary tree structures, but even ignoring that, do what you usually would want from such a structure anyway)
13:38:31 <ReinH> Cale: I... thought they were unbalanced
13:38:52 <byorgey> win 17
13:39:00 <byorgey> urgh, sorry
13:39:01 <Cale> ReinH: Well, they're not *perfectly* balanced
13:39:05 <ReinH> oh no, I'm thinking of Data.Tree
13:39:13 <studmuf> I'm getting the following error when attempting to instantiate a tree using Cale's approuch
13:39:15 <studmuf> <interactive>:61:6: Not in scope: `rootKey'
13:39:18 <Cale> ReinH: But you have to do something about balance in order to guarantee log time lookups
13:39:25 <jle`> studmuf: replace that with what you want to be the root key ;)
13:39:28 <Cale> studmuf: use my example
13:39:31 <ReinH> Maps are "bounded balance" or some such iirc, yes
13:39:36 <studmuf> hahah
13:39:42 <studmuf> i'm an idiot
13:39:46 <ReinH> studmuf: false
13:39:48 <jle`> not an idiot :)
13:39:48 <studmuf> thanks jle`
13:39:50 <Cale> Node 2 "hi" (Node 1 "there" Empty Empty) (Node 3 "world" Empty Empty)
13:40:00 <Cale> ^^ this ought to work
13:40:31 <jle`> i don't know what's so amazing about the world that we want to say hello to it all the time
13:41:18 <ReinH> well, it is the world
13:41:36 <jle`> hm.
13:43:05 <studmuf> jle`: your line gave me a two errors. the first looks like i need a declaration for (Show (BST k0 [Char]))
13:43:56 <jle`> hm.
13:44:07 <jle`> when you defined your BST data strcture
13:44:08 <studmuf> I saw a comment earlier about NOT pasting into this channel
13:44:11 <jle`> add "deriving (Show)"
13:44:17 <jle`> after the definition
13:44:17 <studmuf> gottcha
13:46:11 <ski> la la la
13:46:13 <jle`> ghci uses the `print` function to print out things, so you have to either manually define your print function or let GHC write one automatically for you using deriving (Show)
13:46:24 <jle`> you can also say deriving (Show, Eq), to derive equality tests for BST's...but i recommend trying to implement that yourself :)
13:46:29 <ski> you can't manually define `print' for GHCi to use, afaik ?
13:46:44 <ski> (hm, perhaps with some option ?)
13:46:53 <jle`> you can instance Show within ghci
13:46:56 <ski> yes
13:47:01 <jle`> but in this case it's probably easier to just do the deriving
13:47:11 <jle`> esp since he is just starting out with Haskell
13:47:13 <ski> btw, who are we talking to ?
13:47:20 <jle`> studmuf
13:49:46 <studmuf> jle`: trying to derive (Show) and receiving this error. parse error on input `('
13:50:04 <jle`> did you put it on the same line as your definition?
13:50:13 <jle`> (or on a deeper indent level)
13:50:39 <jle`> data BST k v = Empty | Node k v (BST k v) (BST k v) deriving (Show)
13:51:01 <studmuf> jle`: works missing indent
13:51:11 <studmuf> jle`: thanks
13:51:14 <studmuf> agin
13:51:16 <studmuf> *again
13:51:33 <jle`> np, people often get bitten by haskell's indent rules at first :|
13:52:02 <jle`> the rules are actually pretty simple and unambiguous
13:52:05 <ski> @let data BST k v = Empty | Node k v (BST k v) (BST k v) deriving Show
13:52:06 <studmuf> jle`: I should be use to it because I love python
13:52:07 <lambdabot>  Defined.
13:52:21 <jle`> studmuf: haha
13:52:26 <ski> > show (Node () () Empty Empty)
13:52:27 <lambdabot>  Ambiguous occurrence `Node'
13:52:28 <lambdabot>  It could refer to either `L.Node', defined at L.hs:144:16
13:52:28 <lambdabot>                        or `Data.Tree.Node', imported from `Data.Tree' at L.hs...
13:52:35 <ski> > show (L.Node () () Empty Empty)
13:52:37 <lambdabot>  "Node () () Empty Empty"
13:52:39 <jle`> in this case i guess the important thing was just that your deriving had to be on the same "line"
13:53:05 <studmuf>  28 data BST k v = Empty |
13:53:06 <studmuf>  29                Node k v (BST k v) (BST k v)
13:53:06 <studmuf>  30     deriving (Show)
13:53:17 <studmuf> that's how I derived it
13:53:29 <jle`> oh one haskell style thing
13:53:33 <jle`> that you might find out soon
13:53:38 <studmuf> yea
13:53:42 <jle`> is that haskellers like to put our separators starting on the next line
13:54:01 <studmuf> oh ok so like so
13:54:01 <jle`> [ "hello"
13:54:04 <Cale> (some of them anyway)
13:54:04 <jle`> , "world" ]
13:54:15 <Cale> I don't always do the comma thing with lists
13:54:29 <Cale> But | in data declarations is pretty consistently a beginning-of-line thing
13:54:34 <jle`> acknowledge Cale
13:54:51 <jle`> data BST k v = Empty
13:54:53 <studmuf>  28 data BST k v = Empty
13:54:54 <studmuf>  29                | Node k v (BST k v) (BST k v)
13:54:54 <studmuf>  30     deriving (Show)
13:54:58 <studmuf> ?
13:55:00 <jle`> hm
13:55:03 <jle`> | under the equals sign
13:55:05 <studmuf> sorry for pasting?
13:55:08 <Cale> It'll look pretty if you line up the | and the = sign
13:55:10 <jle`> so that the actual constructors line up
13:55:16 <jle`> so that Node and Empty line up
13:55:36 <studmuf> Haha
13:55:39 <studmuf>  28 data BST k v = Empty
13:55:40 <studmuf>  29              | Node k v (BST k v) (BST k v)
13:55:40 <studmuf>  30     deriving (Show)
13:55:49 <studmuf> much prettier
13:55:50 <jle`> beautiful
13:56:05 <jle`> i usually put the deriving on the same level as the |'s
13:56:13 <jle`> but i don't think it's as big of a deal
13:56:29 <jle`> or maybe the same level as the constructors?
13:56:35 <jle`> it's not even worth mentioning heh
13:56:44 <jle`> just pick one and stick with it :)
13:56:52 <lpjhjdh> Anyone had any luck cross compiling ghc stage2?
13:56:59 * ski doesn't like `deriving (Show)' ..
13:57:14 <jle`> ski: ?
13:57:26 <ski> unnecessary brackets :)
13:57:34 <jle`> ah
13:57:38 <jle`> heh
13:57:49 <eacameron> does anyone know of a way to optimize filter for sorted lists? For example: filter (<5) [1..] cannot complete, but with enough info it should
13:57:52 <ski> (same issue with `elem :: (Eq a) => a -> [a] -> Bool')
13:57:53 <jle`> i usually just leave them in becuase i hate adding them when i add more things to derive :|
13:57:59 <lpjhjdh> Compiling StgStartup.cmm ghc-stage1 says "hGetContents: invalid argument (invalid byte sequence)"
13:58:04 <shachaf> eacameron: takeWhile?
13:58:30 <shachaf> I guess by "sorted list" you mean that the predicate's value is monotonic.
13:58:56 <eacameron> shachaf: but it doesn't necessary start with matching elements: this is better: filter (\x -> x > 2 && x < 5) [1..]
13:59:04 <studmuf> So trying to call val on jle` 's tree but I think i'm doing it wrong
13:59:06 <studmuf> *Main> val Node 2 "hi" (Node 1 "there" Empty Empty) (Node 3 "world" Empty Empty)
13:59:15 <jle`> you might need parentheses somewhere
13:59:45 <jle`> remember that function calls associate tightly and from left to right
13:59:48 <Cale> eacameron: takeWhile
13:59:53 <ski> studmuf> :t val
13:59:56 <eacameron> shachaf: I suppose dropWhile (not p) . takeWhile p
14:00:04 <jle`> so you are doing (val Node) "hi" ... etc.
14:00:10 <jle`> but you want val (Node "hi"... etc.)
14:00:20 <studmuf> ski: val :: BST k v -> Maybe v
14:00:30 <benzrf> heyduck:
14:00:31 <benzrf> *hey
14:00:34 <benzrf> is there an IOT?
14:00:39 <eacameron> Cale: I see that now; with a little dropWhile mixed in, it should do the trick
14:00:39 <Cale> eacameron: oh, I guess I see what you mean, though that's really something a bit different from your initial question :)
14:00:52 <eacameron> Cale: sorry...
14:00:56 <ski> @let val :: BST k v -> Maybe v; val (Node _ v _ _) = Just v; val Empty = Nothing
14:00:57 <lambdabot>  .L.hs:151:6:
14:00:57 <lambdabot>      Ambiguous occurrence `Node'
14:00:57 <lambdabot>      It could refer to either `L.Node', defined at .L.hs:144:16
14:00:57 <lambdabot>                            or `Data.Tree.Node',
14:00:58 <lambdabot>                               imported from `Data.Tree' at .L.hs:104:1-16
14:01:15 <shachaf> eacameron: Do you mean that the sublist of the list where the predicate is true is contiguous?
14:01:21 <Cale> Silly Data.Tree
14:01:24 <eacameron> shachaf: yes!
14:01:25 <hakujin> are there any performance differences with GHC between linux and freebsd? RTS dependencies that don't scale well, threading constructs, etc?
14:01:28 <ski> > val (L.Node 2 "hi" (L.Node 1 "there" Empty Empty) (L.Node 3 "world" Empty Empty))
14:01:30 <lambdabot>  Just "hi"
14:01:33 <jrmithdobbs> Cale: Data.Tree is gr8
14:01:45 <ski> benzrf : no
14:01:48 <ski> can't be
14:01:51 <x77686d> Is there a way to lookup a function binding given a string?  (lookup "length") would return the length function, for example.
14:01:53 <benzrf> why notdan ?
14:01:54 <benzrf>  *not
14:02:09 <ski> benzrf : what would `IOT []' do ?
14:02:17 <benzrf> oh hmm
14:02:23 <jle`> x77686d: lookup as in in your source code...?
14:02:25 <shachaf> eacameron: OK, then the thing you said with dropWhile and takeWhile should probably work.
14:02:25 <ski> it would require access to multiple universes
14:02:31 <jle`> or like a tool?
14:02:34 <jle`> @hoogle length
14:02:34 <lambdabot> Prelude length :: [a] -> Int
14:02:34 <lambdabot> Data.List length :: [a] -> Int
14:02:34 <lambdabot> Data.ByteString length :: ByteString -> Int
14:02:40 <ReinH> x77686d: no
14:02:42 <benzrf> ski: fair point
14:02:43 <benzrf> ;p
14:02:49 <benzrf> ok, is there an EitherT?
14:02:56 <ski> x77686d : given a map, yes
14:02:58 <benzrf> i need either & state & io
14:03:04 <studmuf> ski: jle`: thanks
14:03:28 <jrmithdobbs> benzrf: transformers has one i thought
14:03:45 <benzrf> oh let me check
14:03:57 <benzrf> nope
14:04:04 <ski> > case M.lookup "length" (M.fromList [("length",length)]) of Just f -> show (f "abc"); Nothing -> "sorry, mate"  -- x77686d
14:04:06 <lambdabot>  "3"
14:04:27 <jrmithdobbs> benzrf: ya just looked too but here's what you want: http://hackage.haskell.org/package/either-4.1/docs/Control-Monad-Trans-Either.html
14:04:49 <ski> benzrf : i believe so
14:05:12 <x77686d> ski: I'm needing something that would work out of the blue -- no pre-built map.
14:05:16 <jle`> > M.lookup "length" (M.fromList [("length",length)]) <*> Just "abc"
14:05:17 <lambdabot>  Just 3
14:05:22 <x77686d> s/needing/wanting/ :)
14:05:24 <benzrf> thanks jrmithdobbs
14:05:30 <ski> x77686d : then no
14:05:51 <ski> x77686d : it seems you want staged programming, then
14:06:03 <ski> (like MetaML and MetaOCaml)
14:06:05 <jrmithdobbs> benzrf: don't thank me thank ekmett
14:06:07 <jrmithdobbs> ;p
14:06:18 <ownclo> benzrf, error package re-exports EitherT from 'either' as well
14:06:37 <jrmithdobbs> Control.Lens does too i think
14:06:48 <benzrf> ah. thanks
14:06:53 <benzrf> jrmithdobbs: man he made that too?!
14:07:00 <benzrf> is there anything he didnt make
14:07:16 <benzrf> who is behind mtl?
14:07:20 <x77686d> ski: "Staged programming" -- very interesting -- I hadn't heard that term but looked it up.
14:07:36 <jle`> you might be able to use something like Eval
14:08:08 <jle`> http://hackage.haskell.org/package/plugins-1.5.1.3/docs/System-Eval-Haskell.html
14:08:24 <jrmithdobbs> jle`: notice licensing before you get too excited :(
14:08:51 <jrmithdobbs> jle`: don't think it's possible to legally use plugins without writing gpl3 code, definitely not with default platform ghc :(
14:09:11 <jle`> jrmithdobbs: what is this in response to? :|
14:09:21 <jrmithdobbs> jle`: link to it's docs?
14:09:57 <jle`> oh
14:10:00 <jle`> plugins the package
14:10:28 <Twey> Oh no, not more free software!
14:10:33 <jrmithdobbs> and actually this isn't the gpl3 dynamic code loading one i was thinking of ... it's only lgplv2 but same applies with default platform ghc :(
14:10:51 <jrmithdobbs> but hackage incorrectly lists it as bsd3
14:11:15 <jle`> but i just made billions on b2b software using plugins :/
14:11:22 <x77686d> Looks like System.Eval.Haskell would work for my needs!  Very good!
14:11:59 <jle`> x77686d: it's a very narrow set of needs :)
14:12:08 <jle`> eval is generally considered a bad idea
14:12:12 <Twey> Why are all the GHC ‘nightlies’ from four months ago?
14:12:39 <x77686d> jle`: I know, but I'm just playing around with ideas.
14:12:40 <ski> x77686d : there's a saying, "you shouldn't use `eval' unless you know why you shouldn't use it"
14:13:03 <x77686d> good quote!
14:13:07 <jrmithdobbs> yes all the normal goto rules apply
14:13:09 <jle`> x77686d: fair enough :)  i am just morally obligated to provide a disclaimer
14:13:14 <jle`> just doing my job
14:14:15 <jle`> is there any Haskell library that provides a generic interface for multiple graphics/display backends?
14:14:39 <jle`> i have been sort of writing this interface myself and i was wondering if either one exists or if i could/should publish it/push it to hackage
14:14:43 <hakujin> are there any performance differences with GHC between linux and freebsd? RTS optimizations, MIO in 7.8, etc?
14:15:10 <jle`> i use it to make my program render using GLUT, SDL, GLFW, etc. interchangeably
14:15:47 <jle`> it is quite some effort to consolidate all of their separate event data types and stuff
14:16:00 <bitemyapp> hakujin: it seems unlikely that they would be identical, but it's my understanding that MIO is using FreeBSD's kqueue or whatever it's called.
14:16:36 <hakujin> bitemyapp: I read that and it made me wary there might be more perf differences under the hood; hoping for some experience before I spend the rest of the day answering my own question
14:16:41 <Twey> jle`: Isn't that what those libraries are for in the first place?  :þ
14:16:53 <Twey> jle`: Why abstract over that instead of just, say, including GLFW as a dependency?
14:17:19 <jle`> Twey: because i can't get one thing to compile on all of the systems i am deploying/testing on :|
14:17:29 <jle`> also it let me make a neat gnuplot backend heh
14:17:37 <jle`> so i can chose to render static animation stills
14:17:39 <jle`> or plots
14:18:32 <magicman> Yo dawg, etc. We put an abstraction around your abstractions.
14:18:44 <jle`> well isn't that what Persistent does :|
14:19:08 <jle`> its postgres backend is based on postgresql-simple
14:19:20 <jle`> which is an abstraction over postgres
14:19:25 <magicman> Abstracting things is what Haskell is good at. I'm not surprised to see it pop up every so often.
14:19:37 <magicman> (and what programming is all about <_<)
14:19:39 <ij> Why can't I pattern-match with "f [] = id"; "f (x:y) e = blablabla"?
14:19:48 <magicman> (at least, that's how I see things >_>)
14:19:50 <Twey> jle`: It abstracts over different database backends, not over different libraries that abstract the same database backend :þ
14:19:50 <jle`> and i don't want to rewrite all of haskell glfw's and glut's and etc.'s bindings
14:19:54 <hakujin> isn't postgresql-simple mostly just a thin wrapper over libpq?
14:20:21 <jle`> hakujin: yeah, and Haskell's GLUT is a thin wrapper over the GLUT library in the same way i think
14:20:27 <jle`> or maybe not
14:20:31 <Saizan> ij: mostly for simplicity
14:20:43 <jle`> Twey: well i wouldn't just be using OpenGL
14:20:44 <ij> :[ okay
14:20:54 <benzrf> wait you can't do that?
14:21:07 <jle`> i'd also want to make a HTML5 campus backend
14:21:11 <jle`> so i can use the same code
14:21:13 <jle`> to do OpenGL
14:21:17 <jle`> and also WebGL/Javascript
14:21:20 <Twey> jle`: If you're using GNUPlot as well you're going to need some logic to deal with that in your code — that's a fundamentally different kind of backend
14:21:21 <prophile> campus backend
14:21:22 <jle`> using ghcjs when it eventually comes out
14:21:50 <jle`> Twey: i've already done it; gnuplot backend renders the frames or properties about the frames as a plot or sequence of stills
14:21:52 <magicman> ij: No theoretical reasons. Just an implementation thing. I think the compiler wants a static arity in order to compile partially applied things consistently, or something.
14:21:57 <jle`> and never has any Events
14:22:26 <Twey> I imagine the OpenGL bindings will get some way to compile into WebGL with ghcjs?  I don't know
14:22:38 <jle`> oh and i should note that all of these take netwire Wires
14:22:51 <Twey> Abstracting over OpenGL vs. GNUPlot and maybe WebGL is reasonable; abstracting over GLUT and GLFW and SDL is less so
14:23:11 <jle`> also just plain ol' HTML5 Canvas too
14:23:28 <jle`> is there something that already does this?
14:23:42 <Twey> Because at that point you're just making another OpenGL abstraction library next to those ones :þ  (with the exception of SDL, which is different if you're using audio &c.)
14:23:55 <jle`> Twey: heh yeah, true
14:23:57 <jle`> haha
14:24:04 <jle`> i didn't realize
14:24:30 <Twey> You might be interested in rendering to diagrams or Gloss, as well
14:24:31 <jle`> so you don't know of a library that already does this?
14:25:07 <jle`> isn't gloss an OpenGL abstraction?
14:25:11 <Twey> I know libraries whose goals are compatible with it
14:25:21 <Twey> Gloss is a 2D picture-drawing abstraction
14:25:29 <Twey> It's not inherently tied to OpenGL
14:25:52 <jle`> i did not know that
14:26:02 <Twey> diagrams is likewise a diagram-drawing abstraction, but not inherently tied to GNUplot (it does Cairo via OpenGL too)
14:26:23 <Twey> I think Gloss currently only renders to OpenGL, but diagrams renders to a few different backends
14:26:36 <jle`> i thought diagrams uses haskell's native svg stuff?
14:27:01 <jle`> does Gloss ever intend to allow swapping out OpenGL?
14:27:15 <Twey> That's one of its backends
14:27:30 <Twey> SVG, Cairo, GTK, PS
14:27:50 <Twey> I don't think it does currently
14:27:59 <Twey> I imagine they'd at least be interested in a WebGL backend, though
14:29:12 <jle`> hm it looks like diagrams is similar to what i am trying to do then, looking at it more, except not for interactive animations/games?
14:29:30 <jle`> and gloss is similar except it doesn't intend to expand to multiple backends
14:30:02 <Twey> AFAIK interaction is an intended feature for diagrams, but there's none yet
14:30:25 <jle`> "diagrams for games/3d graphics"
14:30:35 <Twey> There's also Chart, though, which provides pick functions
14:30:47 <Twey> (and outputs to diagrams)
14:31:05 <Aetherspawn> wtb> intelligent shell script where you provide a library on hackage and it produces pipes/conduit bindings automatically
14:31:34 <jle`> ah i see
14:31:46 <ij> magicman, figured so, am sad, thanks for input
14:31:49 <bitemyapp> Aetherspawn: let me know when we solve the halting problem :P
14:32:03 <Twey> jle`: There's a #diagrams channel; you might be interested in it
14:32:08 <jle`> so i think it's safe-ish to say that if i put more effort into polishing this, i wouldn't be wasting my time?
14:32:11 <jle`> or well
14:32:16 <jle`> i might be wasting my time becuase nobody would need it
14:32:18 <Aetherspawn> bitemyapp: halting? :o
14:32:23 <jle`> but i wouldn't be wasting my time because there is already someone who did it
14:32:35 <jle`> Twey: good tip, i'll check it out
14:32:37 <Twey> jle`: You'll probably want to at least produce ‘interactive’ and ‘non-interactive’ backends for your program, because those are different things
14:33:09 <Twey> But I advise against GLUT/GLFW/SDL (if you're not using SDL-specific  features) abstractions
14:33:18 <jle`> Twey: thanks
14:33:27 <jle`> i probably will use OpenGL instead of GLUT/GLFW
14:33:31 <Twey> You could do interactive via Gloss or Chart and non-interactive via diagrams, for example
14:33:38 <Aetherspawn> bitemyapp: I don't think I've heard of that before, can you explan?
14:34:04 <jle`> Twey: as in have a Gloss backend and a diagrams backend?
14:34:24 <jle`> Aetherspawn: the halting problem? it's basically that you can't use static analysis to tell whether a program will terminate
14:34:38 <jle`> in general
14:34:46 <Aetherspawn> oh
14:34:57 <jle`> you can do so for a subset of all programs
14:35:01 <jle`> but you can't find a general way to tell
14:35:05 <platz> for svg  I hear there's blaze-svg as well
14:35:09 <Aetherspawn> maybe not to terminate, but supercompilation can analyze recursive lets
14:35:17 <Aetherspawn> not far off, I don't think/
14:35:24 <jle`> for example, consider the collatz conjecture
14:35:40 <jle`> the 3n+1 thing
14:35:47 <Twey> jle`: The libraries used aren't the issue here.  The thing you need to abstract over (it sounds like) is whether you're producing a representation of your data that is interactive or not.  Once you've done that you can choose a library appropriately for actually outputting that representation — Gloss and diagrams sound like good choices for what you want to do, but it's not my program.
14:35:55 <jle`> and the conjecture says that if you fallow the hailstone sequence, you'll reach 1 eventually
14:36:10 <Aetherspawn> heh. The only way to detect that is to probably execute it.
14:36:13 <jle`> so you can write a program that searches all integers until it finds one that doesn't reach one
14:36:20 <Twey> Aetherspawn: You can't detect it even by execution
14:36:30 <Twey> (necessarily)
14:37:04 <jle`> you can use your brain and logic and algorithms and stuff but there won't ever be a general algorithm that works for all cases.
14:37:11 <Aetherspawn> How do humans determine if a program will terminate
14:37:12 <Twey> Aetherspawn: If a program runs for n seconds without terminating, does that mean that it won't terminate, or that it will terminate in n + 1 seconds?
14:37:36 <jle`> Aetherspawn: well humans can't determine in general either
14:37:40 <Twey> Aetherspawn: We run it through a bunch of test cases and declare it good enough ;)
14:37:51 <Aetherspawn> we determine it won't terminate in n seconds
14:37:52 <bitemyapp> Aetherspawn: this is why people are trying to propagate the understanding regarding "least power" principle. The more we get away from unnecessary turing completeness, the more amenable our systems are to static analysis.
14:37:52 <jle`> if we could then we'd solve the halting problem with our chemical machine brains :)
14:37:55 <Aetherspawn> and we don't care enough to try for n+1 :)
14:38:22 <jle`> there are unprovable theorems in mathematics
14:38:24 <danharaj> who is coming to the NYC hackathon?
14:38:30 <jle`> fsvo 'in mathematics'
14:38:52 <jle`> before i get into a big debate :P
14:39:03 <Twey> Aetherspawn: Most programs people write are provably terminating, but there are programs that are terminating but can't be proven terminating
14:39:19 <geekosaur> Gödel and Cantor walk into a bar...
14:39:23 <Twey> Heh
14:39:57 <zett_zelett> What happens then, geekosaur?
14:40:03 <jle`> Twey: hm i would just want the user to be able to specify that backend that they want, and configure that backend using the configuration that that backend offers
14:40:07 <jle`> zett_zelett: indeterminable
14:40:37 <Aetherspawn> whats the aim of termination analysis anyway
14:40:46 <Aetherspawn> why cant the humans just tag things as not terminating if they won't
14:40:51 <Aetherspawn> and just assume everything terminates
14:41:21 <jle`> it's mostly a problem in tcs
14:41:34 <jle`> every once in a while it becomes a practical issue
14:41:37 <Twey> Aetherspawn: Of course, real machines aren't Turing-complete: they have a limited memory and therefore state-space.  So you can theoretically check at runtime whether a program will never terminate by waiting some finite amount of time and checking that its state (and the state of every other system that interacts with it) is exactly the same as it was at some point in the past.  But programs are big enough
14:41:38 <thebnq> its important in realtime systems
14:41:40 <Twey> that that takes a long time.
14:42:26 <Aetherspawn> thats an interesting thought, state.
14:42:45 <Twey> Aetherspawn: Termination is nice because it makes your type system consistent.  :þ
14:42:52 <hulk{-_-}> Haskell laziness fascinate hulk. Haskell wonder why other languages prefer strict evaluation.
14:43:00 <bitemyapp> Aetherspawn: thought experiment, do you need turing completeness to sort an array?
14:43:09 <hulk{-_-}> s/Haskell/Hulk
14:43:20 <hulk{-_-}> I am terrible at this :(
14:43:23 <bitemyapp> hulk{-_-}: are you ripping off a twitter account on IRC? seriously?
14:43:32 <jle`> other languages like to be able to actually reason about their performance costs
14:43:33 <c_wraith> hulk{-_-}: strict evaluation is easier for computers, so it's what early programming languages did.  most popular languages are still only slightly tweaked versions of algol
14:43:38 <Twey> Aetherspawn: There are languages (e.g. Idris, ATS) where you can choose whether to prove termination, or to mark the function as non-terminating, as you suggest
14:43:40 <hulk{-_-}> bitemyapp: I'm a fan.
14:43:54 <jle`> bitemyapp: i'm sure everyone appreciates the reference :)
14:44:04 <Aetherspawn> bitemyapp: I would say no.
14:44:10 <Aetherspawn> or, rather, depends.
14:44:16 <bitemyapp> Aetherspawn: okay, lets take quicksort.
14:44:30 <Twey> jle`: I don't like that argument.  Haskell (worst-case) performance is pretty amenable to analysis.
14:44:43 <hulk{-_-}> jle`: Are you saying that laziness lowers performance?
14:45:00 <jle`> laziness makes performance analysis harder
14:45:10 <jle`> Twey: it is, but how often is worst-case performance relevant?
14:45:19 <bitemyapp> Aetherspawn: what do we need to prove to know that it's not turing complete and will terminate for sure?
14:45:20 <jle`> in that case...you're already strict
14:45:20 <bitemyapp> think of a basic property that sorting algorithms might have.
14:45:22 <jle`> right?
14:45:29 <hulk{-_-}>  performance analysis hmmm
14:45:32 <bitemyapp> laziness means more sources of non-determinism
14:45:41 <jle`> how much time/space does (++) actually take?
14:45:47 <bitemyapp> I love laziness, but lets be realistic, it adds chaos in some respects.
14:46:08 <Twey> jle`: Well, it's only ever going to be as bad as the strict case (asymptotically).  So if you can reason about strict code, you can reason about the worst case of lazy code, and you'll be — at worst — correct.  ;)
14:46:20 <hulk{-_-}> bitemyapp: Really? Why chaos?
14:46:40 <hulk{-_-}> I like laziness because I feel that it computes only when it has to
14:46:44 <jle`> Twey: haha. actaully that's fair enough.  you're saying to just pretend it's strict?
14:46:56 <jle`> for analysis
14:46:58 <Aetherspawn> uh, iunno.
14:47:02 <hulk{-_-}> Working with infinity is something I would never have imagines doing.
14:47:08 <`Jake`> does (a ++ b ++ c) go through a twice?
14:47:26 <Twey> jle`: It's an approximation that will get you as far as it will in strict code.  The apparent cost of strict code is rarely what it appears to be, either — compilers will always optimize.
14:47:30 <jle`> does ++ even go through the entire firs tlist once?
14:47:38 <geekosaur> yes
14:47:39 <bitemyapp> hulk{-_-}: it shifts resource lifecycles from a locally identifiable action to a non-deterministic and globally propagating thunks.
14:47:47 <bitemyapp> it's hard to know when or where anything happens
14:47:50 <`Jake`> @src ++
14:47:50 <lambdabot> []     ++ ys = ys
14:47:50 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:47:50 <lambdabot> -- OR
14:47:50 <lambdabot> xs ++ ys = foldr (:) ys xs
14:47:56 <bitemyapp> Aetherspawn: okay, how does quicksort work?
14:47:58 <Aetherspawn> `Jake`: it gets rewritten by a RULE
14:48:03 <Aetherspawn> into
14:48:05 <bitemyapp> Aetherspawn: why is it n log n?
14:48:07 <Aetherspawn> a ++ (b ++ c)
14:48:15 <`Jake`> Aetherspawn: ah, thanks
14:48:47 <`Jake`> what about (a ++ b) ++ c? does that also get rewrittenL
14:48:49 <hulk{-_-}> bitemyapp: Well thunks are better than trying to store some large values in memory don't you think?
14:48:51 <`Jake`> s/L/?
14:48:57 <Aetherspawn> `Jake`: that's the same thing
14:49:06 <bitemyapp> hulk{-_-}: not if you want deterministic resource management, no, it isn't.
14:49:06 <`Jake`> oh, right
14:49:07 <Aetherspawn> bitemyapp: hold on, I'm reading about it
14:49:08 <`Jake`> oops
14:49:09 <Twey> jle`: Now, the *real* argument against lazy evaluation is that it makes it hard to predict what the machine will be doing *at a given moment* (which I guess is a strongly-related concern).
14:49:19 <bitemyapp> hulk{-_-}: also the thunks (closures) can capture references and make memory leaks easier to make happen.
14:49:40 <bitemyapp> hulk{-_-}: even if you don't even plan to ever evaluate the thunks, so you have another layer of reference-capture and memory leaks to think about and be careful with.
14:50:07 <Twey> jle`: Which starts to matter when the constants do, e.g. in real-time or low-level code
14:50:09 <benmachine> Twey: the trouble with "analyse my program as if it were strict" is when you get O(\infty) running time :P
14:50:11 <Aetherspawn> in general `Jake` it's rewritte to use linear time
14:50:14 <Aetherspawn> rather than quadratic time
14:50:21 <`Jake`> ok, I see
14:50:22 <Aetherspawn> GHC is pretty smart :)
14:50:22 <jle`> Twey: ah, yeah. that might actaully be a practical concern that isn't too helpful with the worst-case trick
14:50:33 <bitemyapp> hulk{-_-}: further, it dissociates eval of an action from its lexical location which makes it harder to reason about when actions "occur", this is grievously damaging to high level reasoning about code or systems.
14:50:34 <Twey> benmachine: That's not a problem, it's a bonus :þ
14:51:11 <hulk{-_-}> bitemyapp: but you will think about evaluation when you actually need to
14:51:20 <Aetherspawn> bitemyapp: are you talking about the fact we don't know the data input?
14:51:27 <Aetherspawn> so we can't reason about the complexity
14:51:43 <Twey> jle`: It also obscures the relationship between data and codata, which is a bit unfortunate computationally
14:51:57 <bitemyapp> Aetherspawn: no, I'm talking about sub-structural folding/iteration.
14:52:16 <bitemyapp> Aetherspawn: if you know every loop across a data structure will be < than the previous one, you know it'll terminate.
14:52:18 <hulk{-_-}> bitemyapp: I really thought the point of being garbage collected was to stop us from worrying about memory leaks
14:52:27 <Twey> Basically, laziness makes your *program* easier to reason about but its *execution* harder — it's an abstraction away from the execution environment
14:52:35 <bitemyapp> hulk{-_-}: welcome to reality, there is no free lunch.
14:52:38 <bitemyapp> hulk{-_-}: memory leaks can and do happen anywhere in any language, GC or no.
14:53:03 <Aetherspawn> they are easier in haskell, because thunks are full of swag
14:53:04 <Twey> hulk{-_-}: GC isn't perfect, it's just a lot better than manual memory-management :þ
14:53:32 <bitemyapp> hulk{-_-}: if you have a lexical closure capturing a pointer that never gets evaluated, and the pointer is for X bytes of data, you're going to leak X bytes of data everytime that thunk is generated.
14:53:34 <hulk{-_-}> bitemyapp: but here it doesn't have to terminate and that doesn't have to be an issue.
14:53:46 <bitemyapp> you don't need lazy eval by default to have these problems, just closures and GC.
14:53:51 <bitemyapp> hulk{-_-}: it's definitely an issue.
14:54:01 <bitemyapp> hulk{-_-}: are you in school?
14:54:12 <hulk{-_-}> bitemyapp: Yes, why?
14:54:28 <bitemyapp> talking to you is like talking to an enthusiastic socialist that never lived in a communist country
14:54:44 <bitemyapp> I love Haskell but lets not pretend there are design tradeoffs here.
14:55:08 <hpc> pretend there aren't*
14:55:12 <Aetherspawn> #haskell is only for professors who have taken the blood oath and researchers, sorry :(
14:55:19 <hulk{-_-}> bitemyapp: I feel that generating thunks is much better than storing large data structures
14:55:22 <bitemyapp> hpc: yep.
14:55:26 <scriptor> that gc somehow solves all memory leaks seems to be something cs 101 professors love to say
14:55:35 * jle` silently files a report on bitemyapp to the ministry of truth
14:55:36 <bitemyapp> hulk{-_-}: you're wrong.
14:55:37 <scriptor> as they introduce java
14:55:47 <bitemyapp> hulk{-_-}: deterministic resource management is more important for day-to-day programming.
14:56:06 <jle`> actually this would be the ministry of love wouldn't it
14:56:06 <bitemyapp> I write programs that don't actually ever "end", a memory leak of any kind is unacceptable.
14:56:16 <hulk{-_-}> I can imagine that strong a thunk of [1..2344544] is much easier than storing the result of the computation.
14:56:16 <Aetherspawn> Remember that it only leaks if you leak the thunk
14:56:25 <Twey> bitemyapp: I don't think that's true — the thunk will only store enough memory for the structure.  And it's only *leaked* if the thunk can't be referenced any more, which is (I think) pretty hard in GHC Haskell.
14:56:33 <Twey> Er, for the pointer**
14:56:35 <bitemyapp> hulk{-_-}: you're working with a very limited mental model of the problem.
14:56:53 <`Jake`> hulk{-_-}: you should have used [1..]
14:56:55 <bitemyapp> hulk{-_-}: google, "haskell space leaks" to see the practical outcomes of the design tradeoff.
14:57:09 <bitemyapp> also, laziness isn't useful because you can directly express things like [1..]
14:57:16 <Aetherspawn> space leaks are pretty common
14:57:17 <hulk{-_-}> bitemyapp: As in where you know how much of the resources x will take and y will take and we are able to therefore optimise?
14:57:18 <bitemyapp> you don't need lazy-by-default semantics for that at all.
14:57:32 <Aetherspawn> you can generally avoid them by using a forcibly streaming model
14:57:33 <bitemyapp> laziness is useful because it lets you eschew macros in functional languages.
14:57:36 <Aetherspawn> ie, all of Gabriels libraries
14:57:43 <Aetherspawn> pipes/folds/and such
14:57:45 <hulk{-_-}> `Jake`: lol I felt that would be extreme lol
14:57:52 <bitemyapp> and write functions that are more general and powerful than strict ones.
14:57:56 <Twey> bitemyapp: Laziness-by-default is useful because you can evaluate functions at that list and reasonably assume your program will still terminate :þ
14:58:22 <bitemyapp> Twey: my point is that it allows functions to eat up about 80% of the useful space macros covered.
14:58:26 <Aetherspawn> laziness is expressed in disciple which is strict
14:58:33 <Aetherspawn> we just apply an extra () argument as the last parameter
14:58:34 <Aetherspawn> :)
14:58:57 <jle`> Aetherspawn: and add in memoization :)
14:59:14 <jle`> although i guess not, technically
14:59:28 <hulk{-_-}> bitemyapp: http://alpmestan.com/2013/10/02/oh-my-laziness/
14:59:49 <Aetherspawn> it's more complex than that, and it's actually not done yet, but it blew my mind when I realized a lot of the GHC transforms are *much* more powerful when in a strict core
14:59:52 <Aetherspawn> than they are in a lazy core
14:59:54 <hulk{-_-}> Ok I feel that laziness scales
14:59:57 <bitemyapp> hulk{-_-}: stop.
15:00:01 <Twey> bitemyapp: You can do that with explicit iterators too, though.  It just tends to be a little syntactically clumsy.
15:00:09 <bitemyapp> hulk{-_-}: if you don't do work in the field, I don't really care what you think. I'm sorry.
15:00:30 <Aetherspawn> the laziness in GHC core produces a lot of problems with determinism of whether you transformed the program in a non-negative way
15:00:34 <hulk{-_-}> bitemyapp: Have you depolyed haskell programs?
15:00:35 <bitemyapp> Twey: welcome to Clojure.
15:00:42 <bitemyapp> hulk{-_-}: and clojure, yes.
15:00:50 <bitemyapp> so I've seen both sides of lazy/pure and strict/impure FP.
15:01:05 <hulk{-_-}> bitemyapp: Is clojure strict?
15:01:05 <bitemyapp> my perfect world is a mixture of strict and lazy with purity.
15:01:09 <Twey> bitemyapp: …, Python, Java, C++, ML, … :þ
15:01:21 <hulk{-_-}> but you can force strictness in haskell
15:01:22 <Aetherspawn> bitemyapp: explicit laziness or explicit strictness?
15:01:23 <bitemyapp> Twey: the list is much longer than that, I was keeping the nouns germane to the conversation.
15:01:24 <scriptor> clojure uses lazy seqs, but is otherwise pretty much strict
15:01:30 <hulk{-_-}> at least that's what I am reading
15:01:42 <bitemyapp> Aetherspawn: I haven't decided, it would depend too much on the nature of the hypothetical language.
15:01:47 <`Jake`> didn't SPJ say that the next Haskell would be strict or something like that?
15:01:47 <bitemyapp> Idris is strict.
15:01:57 <bitemyapp> `Jake`: right, he's recognized the same tradeoffs I'm talking about.
15:02:03 <`Jake`> ok
15:02:24 <hulk{-_-}> I still can't believe that people named a language ML
15:02:26 <Aetherspawn> you throw away a LOT when moving to strict though
15:02:28 <bitemyapp> for day to day use, you probably only want to sprinkle laziness optionally on some functions that would otherwise require the use of macros.
15:02:31 <danharaj> SPJ is wrong and I can find enough to industry professionals to give credible counterweight. :P
15:02:45 <Aetherspawn> like, for example
15:02:48 <Aetherspawn> idiomatically
15:02:54 <Aetherspawn> maybe (error "it's wrong") foo bar
15:02:55 <hulk{-_-}> bitemyapp: I don't know what macros are :(
15:03:02 <Aetherspawn> that would suck in a strict language...
15:03:07 <bitemyapp> I'm not even saying laziness isn't a valid option/default, just that it's not free of tradeoffs.
15:03:16 <Aetherspawn> it would need to be (const $ error ...) with a unit application
15:03:19 <scriptor> hulk{-_-}: just curious, how far are you into your cs program?
15:03:36 <hulk{-_-}> scriptor: lol guess
15:03:36 <`^_^v> if i want to combine the Error monad and the State monad, does it make a big difference in design whether I use StateT or ErrorT?
15:03:48 <platz> what is the 'next haskell' ?
15:03:49 <scriptor> hulk{-_-}: first or second year?
15:03:57 <danharaj> The tradeoffs of laziness can be drastically ameliorated with supercompilation and whole program optimization. The state of the art hasn't been integrated into GHC.
15:04:04 <Aetherspawn> `^_^v: whichever one you use more should be the transformer
15:04:10 <danharaj> And the tradeoffs aren't that big to begin with.
15:04:11 <Aetherspawn> since you'll need to lift to reach the inner monad
15:04:12 <hulk{-_-}> scriptor: Second year BSc. Informatics
15:04:23 <Aetherspawn> lift actually has a performance impact
15:04:33 <hulk{-_-}> scriptor: Why? Is there hope for me?
15:04:54 <`Jake`> platz: If I remember correctly, it was hypothetically speaking how a new language like haskell would look if they would develop one today
15:04:56 <Twey> danharaj: Do you know what happened to Neil Mitchell's Haskell supercompiler?
15:04:57 <scriptor> ok, so macros, in really really simple terms, let you take code as syntax tress, so you can manipulate them however you want, and then spit back new code
15:05:14 <Aetherspawn> danharaj: have you read all the supercompilation papers? :)
15:05:15 <danharaj> Twey: Not sure. I think Max Bolingbroke's work is still technically alive.
15:05:18 <Aetherspawn> they are so very cool
15:05:26 <danharaj> They are cool!
15:05:29 <platz> `Jake`: that makes sense.
15:05:38 <Aetherspawn> in most cases they see ridiculous speedups, like 50%!
15:05:45 <Aetherspawn> the problem is machines are dumb and don't know when to stop.
15:05:53 <Aetherspawn> more research into termination, needed.
15:06:08 <hulk{-_-}> scriptor: uh that was a really high level explanation
15:06:13 <`Jake`> I think he said it in this talk https://www.youtube.com/watch?v=7NPBrWDzO2A&list=PLUWfjhrIRed8X8CbKbiIab6gfzqfqJmux
15:06:20 <scriptor> hulk{-_-}: high level how?
15:06:39 <scriptor> as in you want me to go into more detail or you want something easier to understand?
15:07:02 <hulk{-_-}> scriptor: uh high level as in less detail
15:07:22 <Aetherspawn> the fact supercompilation can do map/map rewriting is really appealing
15:07:27 <hulk{-_-}> scriptor: Can't I have more detail that is easy to understand?
15:07:50 <Aetherspawn> because I'm sure 90% of fusing is in loops that people have written and not written rules for
15:08:00 <Twey> Doesn't supercompilation on a strict language also provide most of the benefits of laziness?
15:08:10 <scriptor> alright, so at least as far as lisps go, code is data, meaning that your code can be represented in the same data structures you'd otherwise use
15:08:26 <Aetherspawn> supercompilation on a strict language, from what I've seen, is more brute forcey
15:08:27 <scriptor> '(print "hello world") is a list with two elements, print and the string
15:08:40 <Aetherspawn> ie moreso NP -hard.
15:08:48 <scriptor> let's say you have some macro foo
15:08:51 <danharaj> Twey: That's a possibility. I don't know much about that. I doubt it is the case though because lazy semantics makes strictly more programs terminate.
15:08:53 <Twey> Hm
15:08:54 <Aetherspawn> but I've only read wikipedia and a few papers
15:08:58 <danharaj> And you don't want a supercompiler that changes your semantics.
15:09:13 <hulk{-_-}> scriptor: go on
15:09:14 <scriptor> doing (foo (print 123)) will cause a list of two elements to be passed to the macro foo
15:09:15 <Twey> danharaj: Hm, I see your point
15:09:50 <ownclo> I'd like to have a pretty tool that highlights some potential problems with laziness. Profiling is just not a good solution! Actually, laziness is a cross-cutting concern in Haskell. What if we had some kind of aspect-oriented programming technique for it
15:09:50 <ddere> hmm anyone here use Yesod? is http-client-tls broken atm?  cabal update; cabal install http-client-tls fails for me (with sandbox)
15:10:04 <Aetherspawn> ddere: did you cabal update ?
15:10:04 <hulk{-_-}> scriptor: What you call a list is clearly not what I call a list but go on.
15:10:13 <scriptor> hulk{-_-}: how so?
15:10:17 <scriptor> oh right
15:10:18 <danharaj> I don't know what is more overstated, the problems with records or the problems with laziness in Haskell.
15:10:20 <ddere> Aetherspawn: yes
15:10:27 <scriptor> yes, we're using heterogenous lists here
15:10:27 <danharaj> (Perhaps the problems with cabal :P)
15:10:38 <Aetherspawn> sorry, don't know :(
15:10:40 <Aetherspawn> cabal --version ?
15:10:45 <`Jake`> and lisp list notation simply looks like (a b c)
15:10:59 <ddere> 1.16.0.2
15:11:07 <Aetherspawn> oof, that's pretty old.
15:11:10 <scriptor> hulk{-_-}: anyway, so foo can do whatever it wants with the list, so maybe it inserts an element, and you get a list: (print "foo" 123)
15:11:13 <Aetherspawn> thats the haskell platform version
15:11:40 <Aetherspawn> I'll tell you what, I'll try and install it on my mac
15:11:43 <Aetherspawn> and I'll let you know if it works
15:11:47 <scriptor> this new list is then returned, then your compiler will take that list and consider it the code it needs to run
15:12:06 <ddere> % cabal --version\n cabal-install version 1.16.0.2\n using version 1.16.0 of the Cabal library
15:12:19 <ddere> Aetherspawn: thanks
15:12:45 <Aetherspawn> seemed to work fine
15:12:46 <monochrom> oh w00t, GHC 7.8.1 is RCing!
15:12:54 <ddere> ugh ok
15:12:59 <Aetherspawn> sorry ddere, it's something on your end :(
15:13:05 <ddere> the error i got didnt seem cabal related
15:13:11 <ddere> ok, thanks :)
15:13:16 <Aetherspawn> what was the error?
15:13:36 <talios> monochrom oh woo - which release also fixes the OSX mavericks issues right?
15:13:40 <hulk{-_-}> scriptor: and then it will finally print "foo" and 123 ?
15:13:41 <dmj`> monochrom: how far off would a haskell-platform release be?
15:13:47 <scriptor> hulk{-_-}: exactly
15:13:48 <Aetherspawn> dmj`: forever
15:13:55 <monochrom> I don't know. both questions.
15:13:57 <geekosaur> dmj`: april
15:14:02 <Aetherspawn> yeah, forever :C
15:14:03 <scriptor> hulk{-_-}: this is useful, because you can define new syntactic constructs
15:14:07 <geekosaur> at least that's the current plan
15:14:18 <dmj`> I'd like to use 7.8.1 but dunno how the packages I'm using would handle it..
15:14:19 <scriptor> like writing a 'when' macro on top of 'if'
15:14:21 <Aetherspawn> Hey, since haskell platform is becoming 64-bit only
15:14:24 <platz> I wonder if it would be possible to have a tool generate all the commutative diagrams for Hask for a given program
15:14:28 <Aetherspawn> that means
15:14:30 <monochrom> I guess: after 7.8 finishes RCing, 2 months more for haskell platform.
15:14:33 <ddere> Aetherspawn: http://lpaste.net/99412
15:14:33 <Aetherspawn> Windows can't use LLVM anymore.
15:14:51 <Twey> Aetherspawn: Why's that?
15:15:00 <Aetherspawn> Twey: LLVM doesn't work on windows 64-bit
15:15:02 <Twey> Oh
15:15:08 <Aetherspawn> the asm mangler doesn't mangle it properly
15:15:44 <Aetherspawn> or something.
15:15:52 <Aetherspawn> I posted a ticket, but it's a known issue for *years*.
15:16:20 <Aetherspawn> ddere: this is after cabal update? :(
15:16:31 <dmj`> does haskell have pattern matching fall through? like case "a" of { "" -> ; "b" -> print "b or empty"; "a" -> print "a"; _ -> print "something else" }
15:16:32 <Aetherspawn> thats definately an error with the source
15:16:42 <Aetherspawn> dmj`: yes
15:16:59 <ivanm> dmj`: as in Java, etc. where you need to use break?
15:17:00 <Aetherspawn> although, you wouldn't do that like that
15:17:02 <dmj`> Aetherspawn: where "" and "b" emit the same result
15:17:02 <Aetherspawn> you'd do it like
15:17:09 <Aetherspawn> oh, no.
15:17:10 <ivanm> Aetherspawn: I thought it didn't...
15:17:28 <dmj`> maybe that's what pattern synonyms will be used for...
15:17:31 <ivanm> you'd need to use guards
15:17:32 <Aetherspawn> I interpreted that as catch-all and thought you were emphasizing the _ sorry
15:17:59 <Aetherspawn> yeah, you can use guards for that
15:18:04 <Aetherspawn> PatternGuards is haskell 2010 standard
15:18:27 <Aetherspawn> ddere: if you're not too attached to your config
15:18:35 <ivanm> Aetherspawn: I think dmj` was referring to the new pattern synonyms in 7.8
15:18:38 <Aetherspawn> you can just nuke ~/.cabal and ~/.ghc
15:18:44 <Aetherspawn> and try installing it clean
15:18:46 <dmj`> Aetherspawn: super cool didn't know about pattern gaurds
15:19:46 <ivanm> ddere: but backup ~/.cabal/config if you want to keep any settings
15:19:47 <Aetherspawn> I'd personally recommend upgrading to cabal 1.18
15:19:51 <dmj`> wait, I'm not sure this will do what I want
15:19:52 <Aetherspawn> using cabal install cabal-install
15:19:55 <Aetherspawn> since it has paralell build
15:20:13 <Aetherspawn> nuking .cabal and .ghc takes *hours* less.
15:20:32 <ivanm> Aetherspawn: didn't 0.16 have parallel build?
15:20:49 <Aetherspawn> I didn't get it until I upgraded to 18 on windows
15:20:58 <Aetherspawn> so if it had it, it wasn't turned on or something
15:21:01 <ParahSailin> how often does everyone here nuke .ghc
15:21:10 <Aetherspawn> ParahSailin: every 3 months at least
15:21:12 * ivanm doesn't
15:21:12 <ParahSailin> id say i average about twice a month
15:21:14 <Aetherspawn> or after installing crypto-*
15:21:21 <Aetherspawn> since every damn module name conflicts.
15:21:23 <ivanm> but now with sandboxes you have less of a reason to
15:22:05 <ivanm> dcoutts: is the cabal-install changelog not being updated deliberately, or have people just forgotten to do it? :p
15:22:28 <dmj`> Aetherspawn: http://lpaste.net/99413
15:22:41 <dmj`> was wondering if I could abstract out that pattern
15:23:05 <dmj`> oh, the type sig is wrong, disregard that
15:23:09 <Aetherspawn> hmm, let's try
15:23:41 <platz> I think npm had a good idea with making sandboxes the default
15:23:58 <dmj`> and so is the lambdacase, the '->' shouldn't be there
15:24:00 <jle`> mm_freak: i have managed to get an implementation of multiple archers and multiple arrows all flying around and killing each other...but it involves basically having a 'watcher' wire for every single archer-arrow pair.  the 'hitted' wire sends an event to the archer and arrow it is watching when they collide, with information on who hit who.  is htis...the wrong way to do this?
15:24:02 <ivanm> platz: though they _did_ have the benefit of hindsight
15:24:18 <platz> yeah weren't exactly the first ones on the block
15:24:45 <ivanm> I sometimes wish though that sandboxes could go "oh, hey, the library you want to install is already in the global context with the same build flags, so I'll use that and save you some build time"
15:25:00 <jle`> mm_freak: now archers and arrows and stuff are their own self-contained wires that can do whatever they want, and output Just thing and then await a Hit event that switches them to be Nothings.
15:25:06 <ivanm> because when you need something like criterion in a few packages, it can get repetitive getting it in each and every sandbox
15:25:17 <scott_> dmj`: Can't you do \case -> ip : port : _ -> return (ip, port); _ -> retry?
15:25:42 <jle`> mm_freak: it works but i remember you saying that the proper approach does not require events and only needs inhibition...is this similar to it or am i doing it all wrong?
15:25:46 <platz> I'm happy with build times IMHO now that -j for multicore is supported
15:25:56 <dmj`> scott_: I guess you could yes
15:26:34 <bergey> ivanm: Isn't that the goal of the hermetic build stuff?
15:26:46 <Aetherspawn> I think the idea here is to use guards and ||
15:27:03 <Aetherspawn> if you have a situation which doesn't fold like scott_ said
15:27:16 <Aetherspawn> fallthrough case is an imperative thing though
15:27:22 <Aetherspawn> it doesn't really make sense in a functional setting
15:27:40 <ivanm> bergey: I suppose, but since we have some common packages that require (transitively) a lot of deps, it can take some time updating going to a new machine and creating new sandboxes for every package you're hacking on
15:28:01 <Aetherspawn> woah
15:28:08 <ivanm> and AFAIK cabal-install - even with sandboxes - still can't automatically update packages you installed without "cabal sandbox add-source"
15:32:54 <benzrf> hey
15:33:16 <benzrf> if i have a triple MT, the inner value type will appear twice in the signature, right?
15:34:08 <jle`> benzrf: hm?
15:34:18 <jle`> can you show an example
15:34:22 <jle`> i don't think it should
15:34:26 <jle`> but i could be misunderstanding you
15:34:43 <benzrf> hmm
15:34:46 <jle`> remember that monads have to have kind * -> *, so if your monad type can't be expressed as m a, then you are doing somethjing wrong
15:34:50 <jle`> m being some type synonym
15:34:53 <benzrf> ohh right
15:34:54 <benzrf> derp
15:34:57 <benzrf> ok, got it :)
15:36:34 <ski> "triple MT" ?
15:36:49 <ddere> Aetherspawn: sorry i was afk, yeh its after a cabal update, I havent tried nuking my ,ghc/cabal yet, guess i'll give that a try
15:36:53 <benzrf> monad transformer
15:37:02 <benzrf> type LispState = StateT Env (EitherT String IO) LispVal
15:37:42 <ski> perhaps you wanted `type LispState = StateT Env (EitherT String IO)', and then to use `LispState LispVal' (usually) ?
15:37:59 <benzrf> nope, it's always lispval
15:38:25 <benzrf> when would it be something else?
15:38:30 <jle`> hm
15:38:31 <ddere> Aetherspawn: (and thanks)
15:38:34 <ski> `LispState Bool' e.g.
15:38:49 <ski> (when extracting some property for use with `when' e.g.)
15:39:10 <benzrf> well i havent seen the need yet :y
15:39:16 <benzrf> perhaps i will change it later
15:40:10 <ski> (i don't understand what you meant by "the inner value type will appear twice in the signature", either)
15:40:33 <benzrf> i was confused
15:40:42 <jle`> aren't we all
15:40:47 <benzrf> i was thinking that the 2nd arg to StateT was of kind * not * -> *
15:41:54 <ownclo> do you think that LispState is a good name? that an entire computation (with IO and logging), after all
15:42:10 <ownclo> s/that/that is/
15:42:18 <benzrf> w/e
15:42:20 <ski> perhaps you could use `LispM'
15:42:36 <benzrf> doing that :)
15:45:18 <benzrf> :t right
15:45:19 <lambdabot> ArrowChoice a => a b c -> a (Either d b) (Either d c)
15:45:24 <benzrf> wrong one...
15:45:50 <`Jake`> :t rights
15:45:50 <lambdabot> [Either a b] -> [b]
15:45:57 <`Jake`> that one?
15:46:16 <haasn> :t _Right -- that one?
15:46:18 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either c a) (f (Either c b))
15:46:38 <ivanm> @index _Right
15:46:38 <lambdabot> bzzt
15:46:43 <ivanm> @hoogle _Right
15:46:44 <lambdabot> Prelude undefined :: a
15:46:44 <lambdabot> Test.QuickCheck discard :: a
15:46:44 <lambdabot> Data.Function fix :: (a -> a) -> a
15:46:58 * ivanm scratches his head at what @hoogle came out with
15:47:41 <`Jake`> @hoogle _Test
15:47:41 <lambdabot> Prelude undefined :: a
15:47:41 <lambdabot> Test.QuickCheck discard :: a
15:47:41 <lambdabot> Data.Function fix :: (a -> a) -> a
15:47:44 <geekosaur> (the default) hoogle knows nothing of _Right and took the most general alternative it could think of which is a
15:48:00 <Qett> is there a way to fill in an arbitrary argument for a function and create a new function?
15:48:23 <Qett> such as (f arg1) but for an arbitrary argument, not just the first one
15:48:36 <benedikt_> http://lpaste.net/6968120989313925120 # Couldn't match expected type `m0 Integer` with actual type `Integer`
15:48:37 <k00mi> geekosaur: I don't think that's what happened
15:48:39 <benzrf> Qett: lambda
15:48:39 <geekosaur> there is no shorthand partial application form for other than the first parameter (or, with infix application only, the second)
15:48:40 <haasn> \a b c -> f a b c x -- proof that the answer is “yes”
15:48:45 <k00mi> @hoogle doesntexist
15:48:45 <lambdabot> No results found
15:49:16 <benedikt_> works if i change the type signature to Int -> IO Integer and skip unsafePerformIO, but it has the type declrataion IO a -> a.
15:49:19 <geekosaur> k00m: I think it is, *but* it understood _whatever to be a type, not a value
15:49:25 <haasn> you can use (f ?? x) for filling in the second argument, or (f ?? x ?? y) for filling in the second and third, etc.; that's the only short hand I know of
15:49:32 <benzrf> :t ??
15:49:33 <lambdabot> parse error on input `??'
15:49:35 <benzrf> :t (??)
15:49:36 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:49:52 <k00mi> geekosaur: ah, that seems to be correct
15:50:12 <jle`> Qett: the special case is the second parameter
15:50:32 <shachaf> haasn: Multiple uses of (??)? That's terribly misleading. :-(
15:51:07 <jle`> (`f` b) will give you a function waiting for the first parameter
15:51:26 <Qett> ah
15:52:09 <benzrf> > (Just (+1) ?? 3
15:52:10 <lambdabot>  <hint>:1:16:
15:52:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:52:14 <benzrf> > (Just (+1)) ?? 3
15:52:15 <lambdabot>  Just 4
15:52:45 <`Jake`> @pl \x -> f a b x
15:52:45 <lambdabot> f a b
15:53:01 <benzrf> @pl \f x -> f <*> pure x
15:53:01 <lambdabot> (. pure) . (<*>)
15:53:03 <benzrf> meh
15:53:10 <benzrf> :t \f x -> f <*> pure x
15:53:11 <lambdabot> Applicative f => f (a -> b) -> a -> f b
15:53:19 <benzrf> @src (??)
15:53:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:53:20 <ski> @pl \x -> f <*> pure x
15:53:20 <lambdabot> (f <*>) . pure
15:53:28 <benzrf> :t (??)
15:53:29 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:53:32 <c_wraith> woo!  release candidate!
15:53:33 <jle`> it's a little more general
15:53:34 <haasn> f ?? x = fmap ($ x) f
15:53:39 <benzrf> ah
15:53:40 <jle`> because you can't pure a functor
15:53:43 <benzrf> right
15:54:11 <ski> @type \f x -> ($ x) <$> f
15:54:12 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:54:15 <jle`> i always wondered if there was a typeclass with pure but no (<*>)
15:54:23 <jle`> sometimes i would find it handy
15:54:33 <haasn> jle`: Pointed but it's not really as useful as you might think
15:54:33 <jle`> mostly when i am too lazy to write (<*>) but when there is a trivial pure, heh.
15:54:39 <c_wraith> jle`: one thing you left out of your discussion on auto, is that a function can return a different function, rather than just itself with a different closure.
15:55:13 <c_wraith> jle`: that is hard to build examples of, though..  It doesn't make much sense unless you have a bunch of different macro states.
15:55:21 <ownclo> I'm implementing a reversible marshalling library (https://github.com/ownclo/unify/blob/master/unify.hs). I would be happy if you could give some hints about perspectives of the approach used.
15:55:34 <jle`> c_wraith: yeah :| i read krajkevski's post and he said pretty much the exact thing although not directed directly at me
15:55:51 <jle`> krajcevski
15:56:02 <c_wraith> jle`: not that anything you said was wrong - just that it's one more detail that would have been nice to point out.
15:56:32 <jle`> i could just add it in.
15:56:38 <jle`> the post was already obscenely long
15:56:57 <c_wraith> Yeah, it's not wrong to leave it out...  Maybe just throw it into the next post, if it makes sense.
15:57:04 <jle`> but anyone using netwire or afrp has to really internalize that idea
15:57:14 <jle`> same as how you internalize first class functions in fp
15:57:27 <jle`> i might just throw it in as a foot note or something to think about
15:58:31 <jle`> thanks for the heads up
15:58:54 <jle`> when did it become 3:55...my midterm is in five minutes heh.
15:59:00 <jle`> gotta run.
16:01:02 <joelteon> How do I figure out where an instance is defined?
16:01:28 <c_wraith> joelteon: I don't know of any way other than :info in ghci
16:04:37 <adnam> joelteon: use :i in ghci
16:04:40 <benzrf> :t left
16:04:41 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
16:04:43 <joelteon> thanks, that helped
16:04:44 <benzrf> huh
16:06:04 <int-e> it helps to read the 'a' as an infix operator: ArroyChoice (~>) => (b ~> c) -> (Either b d ~> Either c d)
16:06:36 <int-e> (operator -> type constructor. -> instead of ~> works, btw)
16:21:08 <piezoid> i'm factoring two GADT terms, so i need to manually bring to scope the proof of equality between existential types ?
16:22:52 <ski> perhaps paste ?
16:23:13 <benzrf> @hoogle Functor f => a -> f b -> f a
16:23:14 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
16:23:14 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
16:23:14 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
16:23:18 <benzrf> dang
16:23:23 <benzrf> no alphanum name
16:23:24 <benzrf> :(
16:24:03 <dwcook> @type fmap . const
16:24:04 <lambdabot> Functor f => b -> f a -> f b
16:24:36 <benzrf> meh
16:24:39 <benzrf> a section is still less verbose
16:36:40 <piezoid> ski: http://lpaste.net/99416
16:37:23 <piezoid> sorry, i don't have time to trim all the type noise...
16:38:19 <piezoid> this kinda work, but i need to get rid of type families in the GADT
16:39:22 <Redz> could it lead to a performance problem, when feeding lots of Channels without reading them? just to make channels readable, as an option.
16:42:43 <dwcook> Redz, which Channel are you referring to?
16:42:49 <ski> piezoid : hm, i wonder whether it would be possible to somehow make `RevD' a data family ..
16:43:05 <Redz> dwcook: Control.Concurrent.Chan.Chan
16:44:08 <dwcook> Redz, those are non-strict, so you might be building up thunks, but I don't know about performance
16:45:05 <randomclown> How do you guys deal with `Defined but not used` errors on record fields?
16:45:42 <dwcook> randomclown, prefixing with a _ indicates to the compiler you don't plan to use it
16:45:42 <ski> piezoid : hmm
16:45:59 <randomclown> oh really
16:46:02 <ski> piezoid : perhaps you should call another (mutually recursive) function in the `Rev' case
16:46:03 <dwcook> If I recall correctly
16:46:06 <dwcook> Give it a shot
16:46:37 <randomclown> dwcook: where is this documented?
16:46:40 <randomclown> it works
16:46:44 <piezoid> i should learn Idris, to get this the hard way.
16:46:48 <dwcook> randomclown, the Haskell 2010 standard
16:47:30 <dwcook> Though it's described there as a suggestion
16:47:48 <dwcook> I've never read the GHC docs in any depth
16:47:49 <ski> piezoid : since `simeq' wants two arrows from a common domain, but deconstructing the `Rev' case, you get two arrows with a common codomain
16:51:45 <piezoid> ski: ok, I had not thought about that...
16:54:12 <piezoid> it's funny how i get deep implications of the model by using GADTs
17:00:52 <ski> perhaps pattern guards would look nicer
17:04:39 <piezoid> ski: compared to do notation ? or toplevel patterns ?
17:04:58 <ski> instead of the `case'
17:06:03 <ski> (i suppose one could use them instead of the `do's as well)
17:06:46 <piezoid> ski: ok, thanks for the advice
17:07:10 <dmwit> tommd: I have a few months left, and high hopes that I will succeed at that time. =)
17:07:21 <dmwit> tommd: You hiring? ;-)
17:08:41 <benzrf> @pl \f x -> f (snd x)
17:08:41 <lambdabot> (. snd)
17:09:15 <piezoid> the problem with do notation, is that it's ordered. If I flip the two binds in the last statement, it no longer typecheck
17:09:38 <ivanm> how is that a problem?
17:09:59 <ivanm> that makes sense if the last line doesn't have the correct type
17:10:41 <dmwit> tommd: (Sorry for the days-long reply lag. I've been avoiding IRC in the interest of Getting Stuff Done...)
17:12:19 <nikki93> what do you guys use with emacs? haskell-mode, ghc-mod, or ...?
17:12:41 <ivanm> haskell-mode, smh
17:12:56 <`Jake`> @pl \f (a, b) -> (a, f b)
17:12:56 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
17:12:59 <`Jake`> oh
17:13:02 <ivanm> I tried ghc-mod but there were some issues with it; it doesn't like empty files :s
17:16:04 <nikki93> ivanm: have you found inferior-haskell-mode or haskell-interactive-mode to be better?
17:16:25 <ivanm> I'm using haskell-interactive-mode
17:16:36 <dhrosa> @pl f a b c = b a c
17:16:37 <lambdabot> f = flip id
17:16:39 <ivanm> there are a couple of issues with it atm that I'm trying to track down though
17:16:52 <ivanm> nikki93: but if you're going to use cabal sandboxes you probably want interactive-mode
17:17:08 <nikki93> ivanm: for now I think I'm just doing simple scripts
17:17:14 <dhrosa> @pl f a b = f b a
17:17:14 <lambdabot> f = fix flip
17:17:26 <ivanm> nikki93: note also that interactive-mode isn't being maintained as much
17:17:52 <nikki93> ivanm: you mean haskell-interactive-mode?
17:18:01 <ivanm> yes
17:18:27 <nikki93> ivanm: oh, I thought it was the newer one
17:18:42 <ivanm> sorry, I'm getting mixed up
17:18:49 <ivanm> _inferior_ isn't being maintained much
17:19:17 <nikki93> so basically
17:19:25 <nikki93> haskell-interactive-mode is the way to go
17:19:31 <Tekmo> ParahSailin: Are you there?
17:19:39 <ivanm> yup
17:19:57 <ParahSailin> Tekmo: hey
17:19:58 <bitemyapp> ParahSailin: I would forget that person existed, were it not for your name.
17:20:14 <Tekmo> ParahSailin: I saw your issue.  Can you quickly check to see what version of `pipes` you have installed?
17:20:30 <ParahSailin> Tekmo: this occured when i upgraded to pipes 4.1.0
17:20:41 <Tekmo> ParahSailin: It should compile against `4.1.0`
17:20:55 <Tekmo> ParahSailin: Only `pipes` versions older than that don't have `closed`
17:21:16 <Tekmo> ParahSailin: On my computer I have it successfully compiled against 4.1.0
17:21:44 <ParahSailin> Tekmo: ok hang on, i've nuked .ghc a couple times trying to get this to work, ill nuke one more time
17:21:46 <Tekmo> ParahSailin: The easy way to check is to do `ghc-pkg list | grep pipes`
17:21:53 <`Jake`> @pl \a a -> a a
17:21:53 <lambdabot> const (join id)
17:22:37 <benzrf> :t \a a -> a a
17:22:37 <lambdabot>     Conflicting definitions for `a'
17:22:37 <lambdabot>     Bound at: <interactive>:1:2
17:22:37 <lambdabot>               <interactive>:1:4
17:22:41 <benzrf> Watcher7:
17:22:54 <benzrf> :t const $ join id
17:22:55 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
17:22:55 <lambdabot>     Expected type: a1 -> a1 -> a0
17:22:55 <lambdabot>       Actual type: a1 -> a1
17:22:58 <benzrf> huh
17:23:17 <`Jake`> @pl \a b -> b b
17:23:17 <lambdabot> const (join id)
17:23:25 <pavonia> I think @pl treats 'a' as the same variable here
17:23:34 <`Jake`> well, it overwrites it
17:23:49 <zrho> nice, new toys! didn't know about pl^^
17:24:04 <pavonia> @pl \a b -> a b b
17:24:04 <lambdabot> join
17:24:16 <zrho> @pl \a b c -> a b c
17:24:16 <lambdabot> id
17:24:21 <zrho> @pl \a b c -> a c b
17:24:21 <lambdabot> flip
17:24:25 <zrho> @pl \a b c -> b a c
17:24:25 <lambdabot> flip id
17:24:33 <prophile> fun fact: all lambdabot's commands work in PM as well
17:24:58 <zrho> oh, my bad
17:25:11 <prophile> np :)
17:25:24 <benzrf> wait, will `flip id' typecheck
17:25:26 <c_wraith> yes
17:25:31 <c_wraith> flip id is flip ($)
17:25:33 <`Jake`> :t flip id
17:25:34 <lambdabot> b -> (b -> c) -> c
17:25:50 <benzrf> hmm
17:25:53 <benzrf> :t flip
17:25:54 <lambdabot> (a -> b -> c) -> b -> a -> c
17:26:04 <benzrf> id can have type a -> b -> c?
17:26:10 <c_wraith> Sure
17:26:20 <c_wraith> It can have type (a -> b) -> (a -> b)
17:26:25 <benzrf> ohhhh
17:26:46 <c_wraith> which, by the way, is the same type as ($)
17:27:01 <ParahSailin> Tekmo: yeah ok nevermind, it was pipe-attoparsec looking for pipe-parse==2.0.* after i had upgraded
17:27:24 <ParahSailin> Tekmo: while you're here, can you think of a reason why this would take up huge amounts of memory? https://gist.github.com/rcallahan/7a20e3057907d3ae5a46
17:28:00 <Tekmo> ParahSailin: Yeah, `pipes-attoparsec` has not been upgraded to use the new `pipes-parse` API yet
17:28:15 <Tekmo> ParahSailin: That's why I'm still sitting on the `pipes-parse` announcement post until REnzo upgrades his libraries
17:28:19 <Tekmo> ParahSailin: I will check out your example
17:29:25 <Tekmo> ParahSailin: You can make your example more efficient if your first function produces a `Producer ByteString m r` instead of a `Producer [Word8] m r`
17:30:14 <ParahSailin> Tekmo: ok, i could put a pack in there, but this is taking on the order of hundred of MB ram
17:30:16 <Tekmo> ParahSailin: My initial guess is that the use of `sequence` is the problem.  How many handles are you using?
17:30:30 <ParahSailin> Tekmo: about 40 in my test case
17:30:44 <ParahSailin> @src sequence
17:30:46 <lambdabot> sequence []     = return []
17:30:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:30:50 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:30:55 <Tekmo> ParahSailin: It's not the lack of pack so much as the use of sequence
17:31:29 <Tekmo> ParahSailin: Both `sequence` and `mapM` are anti-patterns
17:31:42 <Tekmo> ParahSailin: Also, `replicateM` is an anti-pattern, too
17:32:01 <malarbol> hi everybody, anyone having solve the problem with ld and xcode5 ?
17:32:13 <Tekmo> ParahSailin: I don't know if that explains the leak, though.  I'm still studying the code to see if there are any other culprits
17:32:26 <prophile> they're eaten before a full italian meal
17:32:43 <ParahSailin> so, rewrite that zipMany without sequence
17:33:40 <Tekmo> ParahSailin: That's what I'm doing right now
17:33:46 <ParahSailin> i wouldnt have expected sequence to be too harmful
17:33:55 <Tekmo> So there a couple of reasons it is harmful
17:35:05 <stephenmac7> Do I still need this patch? https://ghc.haskell.org/trac/ghc/wiki/Building/ARMLinuxGnuEABI
17:35:11 <stephenmac7> Or, the one linked to there
17:39:27 <schell> ParahSailin: awesome name, lol
17:40:01 <ParahSailin> in my culture it is pretty standard given name
17:40:53 <Tekmo> ParahSailin: Actually, it might be a separate problem
17:42:33 <Twey> Tekmo: An antipattern?  Why?
17:43:01 <Tekmo> Twey: It's an anti-pattern because it loads the entire list into memory
17:43:28 <Tekmo> Twey: This means you cannot begin processing any results until it computes all of the results
17:43:41 <Twey> Ah, for pipes
17:43:45 <BMeph_> Tekmo: Have you written a blog article on this already? :)
17:43:49 <Tekmo> BMeph_: I will, soon
17:43:59 <Tekmo> It's in my queue of posts to write :)
17:44:16 * BMeph_ waits patiently for Tekmo's article...for about 20 seconds...
17:44:17 <ParahSailin> i guess the sequences could be taken out in favor of ST monad mutation of bytearray
17:44:40 <Tekmo> :)
17:44:54 <ReinH> Tekmo: less irc more writing
17:44:55 <ReinH> come on dude
17:45:07 <Tekmo> Haha
17:45:32 <Tekmo> I was just coming on here to help ParahSailin diagnose the problem installing `pipes-parse`
17:45:43 <Tekmo> Then I got sucked into this interesting space leak
17:45:54 <BMeph> Tekmo: Maybe you should just "lecture" your article on some IRC channel that is auto=logged... ;)
17:46:06 <Tekmo> I prefer the blog post format
17:46:21 <Tekmo> IRC is not very friendly for browsing or googling
17:46:21 <BMeph> :(...
17:46:25 <ParahSailin> Tekmo: i was regretting posting an issue displaying my incompetence with cabal, but if that's what got you here, it was worth it
17:46:32 <Tekmo> ParahSailin: :)
17:46:36 <Tekmo> Don't worry
17:46:44 <Tekmo> Either way you caught a small bug in `pipes-parse`
17:46:53 <Tekmo> I'll update the lower bounds on `pipes` for `pipes-parse`
17:47:16 <ParahSailin> my .ghc has been a mess ever since i rebuilt modern ghc starting from 6.6 on a machine with prehistoric libc
17:48:12 <Tekmo> ParahSailin: So you get a leak with just the `zipMany` function, too, right?
17:48:32 <ParahSailin> Tekmo: i confess i didnt profile yet
17:48:43 <Tekmo> It's alright
17:49:25 <ReinH> ParahSailin: no it isn't. How could you?
17:49:35 <ReinH> Shame.
17:50:14 <ParahSailin> i wouldnt send an email without profiling, but i would post a gist on irc
17:50:54 <`Jake`> Is it standard practice to use liftM instead of fmap for IO?
17:51:41 <randomclown> `Jake`: no
17:51:49 <`Jake`> randomclown: thanks
17:52:03 <randomclown> fmap everything haha
17:52:08 <randomclown> <$>
17:52:19 <randomclown> unless it's clearer with liftM
17:52:21 <randomclown> then liftM
17:52:37 <Tekmo> ParahSailin: I have to head out right now, but I will continue to work on this
17:52:52 <`Jake`> alright, well, it's just a single line function, so I guess it doesn't really matter anyway
17:52:54 <ParahSailin> Tekmo: where did you leave off
17:53:15 <ParahSailin> i will probably write a less general zipmany with st mutation of bytearray
17:53:37 <`Jake`> I am gonna use <$> though. Saves me a bracket
17:53:53 <`Jake`> or a parantheses pair, rather
17:54:27 <benzrf> :t (&&&)
17:54:28 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
17:54:34 <benzrf> right
17:57:00 <ReinH> periodic suggestion to generalize (.) = fmap
17:59:12 <malarbol> Hi there. anyone using Xmonad on os X ?
18:00:20 <`Jake`> ReinH: A suggestion for the standard library or for me?
18:00:37 <Fuuzetsu> periodic refute about being harder to teach
18:00:54 <Twey> ReinH: Heh, ‘periodic’; I see what you did there
18:01:20 <Twey> I'd rather have (.) from Category
18:01:24 <geekosaur> malarbol, I missed you in #xmonad
18:01:31 <malarbol> oh!
18:01:34 <geekosaur> you use macports or homebrew?
18:01:46 <malarbol> ... both :S
18:02:02 <geekosaur> the iconv thing is an infamous issue because apple ships an ancient iconv library and both macports and homebrew use more recent ones with renamed symbols
18:02:23 <`Jake`> Can I use Category.. like fmap?
18:02:31 <geekosaur> which leads to that link error if you mix libraries expecting the system iconv (like the xquartz installer) with ones that expect the macports or homebrew libs
18:02:41 <Twey> `Jake`: For functions; it's not the same thing in general
18:02:48 <malarbol> oh
18:02:53 <geekosaur> (they rename the symbols because otherwise you find out when your programs dump core on startup)
18:02:53 <`Jake`> okay, I see
18:03:39 <malarbol> ok, that explains why this only happens when I try to install things that use x11 (related to xmonad)
18:04:20 <geekosaur> you want to make sure that your ghc installation, your xquartz libs (macports and homebrew both have their own versions of the xquartz libs), and any other libraries all come from the same place
18:04:21 <malarbol> but I managed to install xmonad, and I'm using it right know...
18:04:54 <geekosaur> having both macports and homebrew at the same time may complicate this, because even if it works it may break when you upgrade one but not the other...
18:05:31 <malarbol> ok
18:06:45 <geekosaur> xmonad-contrib uses more libraries than core xmonad does
18:07:11 <geekosaur> in particular it will usually pull in Xft
18:07:28 <malarbol> totally makes sense yeah...
18:07:32 <geekosaur> (and all its dependencies, which is quite a lot)
18:08:58 <malarbol> is there any "hack" to tell ghc where to look for x11 libs ? (like changing the gcc compiler in Library/.../.../settings) when the xcode5 thing ?
18:09:42 <ParahSailin> LD_LIBRARY_PATH?
18:10:09 <geekosaur> not on OS X
18:10:50 <malarbol> ho... I did set it to look for macports library, for nothing i guess :)
18:10:53 <geekosaur> well, you can set it and it does things. but it does the wrong things and will generally just cause problems
18:11:02 <ParahSailin> gcc doesnt look at LD_LIBRARY_PATH on osx?
18:11:16 <geekosaur> LD_LIBRARY_PATH is not a gcc-ism
18:11:19 <ParahSailin> sorry, i mean LDFLAGS
18:11:20 <geekosaur> it's an ld.so-ism
18:12:11 <geekosaur> I will say that one local patch I make to the haskell x11 bindings is to configure them to use pkg-config, then make sure macports' pkg-config is in $PATH
18:13:57 <geekosaur> (or homebrew if you prefer to use its libraries. just make sure everything is using the same libraries)
18:14:24 <geekosaur> (otherwise at best you get that link error and at worst you get successful compilation but everything dumps core when run)
18:14:54 <benzrf> hey, is there a vim plugin or somethin I can use to see the types of exprs?
18:15:08 <malarbol> If I'm not mistaking, macports pkg-config is /opt/local/bin/pkg-config ?
18:15:12 <benzrf> i.e. i give it a motion or highlight something and it tells me
18:15:13 <benzrf> ?
18:15:55 <geekosaur> malarbol, yes
18:16:49 <malarbol> ok, so, it is indeend in my path (I mean, /opt/local/bin) , so how do I change haskell x11 bindings ?
18:16:53 <geekosaur> http://lpaste.net/99421 is the patch to X11.cabal
18:17:20 <geekosaur> just replacing the extra-libraries with pkgconfig-depends (alas, the two use different formats)
18:17:46 <Tekmo> ParahSailin: I'm back
18:18:02 <Tekmo> ParahSailin: To answer your question, I'm trying to define a more general `transpose` function for `Producer`s
18:18:21 <Tekmo> ParahSailin: transpose :: Producer (Producer a m ()) () -> Producer (Producer a m ()) ()
18:18:23 <ParahSailin> transpose?
18:18:41 <geekosaur> pkg-config will then make sure everything matches up, since both of them (macports and homebrew) make sure to search only their pkgconfig registries
18:18:53 <Tekmo> ParahSailin: Basically the `Producer` analog of `Data.List.transpose`
18:19:51 <geekosaur> (but, again, you also have to make sure your ghc also comes from the same place; the official HP package won't be able to use either macports or homebrew libs successfully because of iconv)
18:21:44 <geekosaur> btw I will mention one other issue you'll run into: xmonad uses XRestackWindows(), which doesn't play well with xquartz's rootless mode --- you will find X11 windows vanishing under Aqua windows somewhat regularly
18:21:53 <malarbol> you mean I should re-install the x11 package changing this line in the original cabal file ?
18:21:57 <geekosaur> yes
18:22:07 <geekosaur> and then you'll need to reinstall xmonad and xmonad-contrib
18:22:26 <malarbol> yeah... cabal-hell
18:22:33 <malarbol> (kind of)
18:22:54 <geekosaur> not just cabal hell but also that if you don't reinstall them then they'll keep using the old X11 bindings with the broken paths
18:23:03 <geekosaur> and you'll still have the iconv errors
18:23:42 <malarbol> ok
18:23:58 <geekosaur> (or worse they'll try to find the old version and fail and blow up with weird type errors)
18:24:40 <malarbol> no, no, I would definitely re-install all the modules depening on x11
18:24:51 <jfischoff> @define spiral f a = b where (b, as) = f (a : as)
18:24:53 <lambdabot>  Defined.
18:24:59 <jfischoff> :t spiral
18:25:00 <lambdabot> ([a] -> (t, [a])) -> a -> t
18:25:07 <geekosaur> (because "cabal hell" is actually "ghc hell" and ghc is downright strange when you change things out from under it)
18:25:15 <jfischoff> @undef spiral
18:25:15 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
18:25:22 <geekosaur> cabal's just the messenger
18:25:32 <jfischoff> ok then
18:25:36 * dwcook shoots cabal
18:25:51 <malarbol> :)
18:26:54 <malarbol> well, thank you for your help!
18:27:33 <malarbol> I'll see if I go through
18:27:43 <malarbol> bye
18:28:06 <ivanm> is there a GHC extension or something that would minimise having to do things like: \ a b c -> foo a b c bar ?
18:28:33 <ivanm> i.e. a function to set specific arguments for a function when I know what the others would be
18:38:03 <AshyIsMe> like named arguments or something?
18:38:06 <verement> ivanm: Sometimes it can help to reorder the arguments to your function, so e.g. you can pass 'foo bar' around and other bits of code can add the rest of the arguments
18:39:52 <ivanm> verement: yeah, it's not really possible in this case
18:40:19 <verement> otherwise, you have options like 'flip foo' or (`foo` bar) to help with the first few arguments, but not much I'm aware except lambdas beyond that
18:40:28 <ivanm> AshyIsMe: I was thinking more of a function equivalent of being able to do this:
18:40:36 <ivanm> @type (1,,"hi")
18:40:39 <lambdabot> Num t => t1 -> (t, t1, [Char])
18:40:54 <ivanm> verement: yeah, I'm trying to cut down on my lambdas for readability purposes :/
18:41:33 <AshyIsMe> just give them names and make them little helper functions?
18:41:53 <verement> yeah, maybe it's worth writing some helper functions to get the arguments in a better order
18:42:14 <ivanm> not really possible in this instance
18:42:23 <ivanm> (it's a longish CPS-based function)
18:49:05 <verement> ivanm: maybe it could be rewritten to use the Cont monad so you don't have to explicitly pass the continuation around?
19:04:26 <Dcoder> hello
19:05:07 <Dcoder> had a question, but ended up figuring it out: addIntC# in GHC.Prim has a rather misleading description
19:05:22 <Dcoder> it computed the signed overflow of the sum, not the carry
19:05:27 <Dcoder> or what is usually meant by carry
19:08:26 <byorgey> ivanm: honestly, a plain old lambda seems way more readable to me than any possible syntax there might be to do that =P
19:08:33 <byorgey> (there isn't)
19:09:28 <carter> Dcoder: hrmmm
19:10:06 <ReinH> or, as mentioned, write the method so that the arguments that change the least often come first
19:10:13 <ReinH> which is a good general rule of thumb
19:10:26 <carter> Dcoder: how would those two differ?
19:10:36 <ReinH> and also totally not what, say, lookup does.
19:11:09 <carter> Dcoder: (i'm just a bit fuzzy on what the different would be wrt signed overflow vs "carry")
19:11:20 <Dcoder> carter: signed overflow happens when two operands have the same sign but the result has a different sign
19:11:27 <Dcoder> e.g. adding two positives giving a negative
19:11:28 <carter> ahh
19:11:32 <carter> well
19:11:52 <carter> so how is the signed over flow value different from the carry?
19:12:00 <carter> Int (currently) has wrap around semantics
19:12:05 <jrmithdobbs> Dcoder: Integer is a bignum type in haskell in every impl i've seen
19:12:21 <carter> though per se, h98/2010 don't specify what the heck over/underflow should mean :)
19:12:27 <Dcoder> carry is when the unsigned value overflows 2^n
19:12:33 <carter> yes
19:12:45 <carter> does the signed overflow carry disagree ?
19:12:46 <carter> or no
19:13:02 <Dcoder> it does
19:13:06 <carter> when
19:13:07 <carter> how
19:13:11 <carter> educate me
19:13:18 <carter> i need definitions and examples
19:13:25 <carter> ('cause i'm hleping clean up the int story :))
19:13:30 <Dcoder> example: 16282728709903842810 18300341342965825020
19:13:38 <carter> ok
19:14:05 <jrmithdobbs> carter: oh? sweet
19:14:10 <Dcoder> adding those two results in a >2^64 result, but it does not trigger the sign overflow
19:14:15 <carter> Dcoder: yes
19:14:17 <jrmithdobbs> carter: for 7.10?
19:14:19 <carter> yes
19:14:25 <carter> Dcoder: what does the carry # give you
19:14:26 <carter> i know
19:14:31 <carter> ghc doesn't error on that
19:14:35 <carter> is has wrapp around sillies
19:14:40 <Dcoder> addIntC gives 0 on that
19:14:53 <Dcoder> and it makes sense, considering it's Int#
19:15:14 <Dcoder> if there was a addWordC#, i'd understand that one would give signed overflow and the other unsigned
19:15:27 <Dcoder> but addWordC# does not exist
19:15:31 <carter> Dcoder:
19:15:35 <carter> that is a valid feature request
19:15:43 <carter> could you please throw a ticket on ghc trac
19:15:55 <carter> and you can hassle me about adding addWordC# for 7.10? :)
19:16:06 <carter> i'm happy to make sure that (reasonable) op is there
19:16:10 <carter> are you sure its not?
19:16:19 <carter> huh, i gues snot
19:16:39 <Dcoder> wait
19:16:41 <Dcoder> hmm
19:16:51 <Dcoder> it's called "plusWord2"
19:17:00 <Dcoder> at least by the type signature it looks like it
19:17:01 <carter> huh
19:17:10 <carter> looks right
19:17:11 <carter> :)
19:17:17 <carter> i was suprirised
19:18:49 <studmuf> Hey if I wanted to count the number of nodes in a BST with the type declaration
19:18:49 <studmuf> size :: BST k v -> Int
19:18:49 <studmuf> How would I do it?
19:19:51 <ReinH> studmuf: fold over it, summing nodes
19:20:36 <pavonia> What is BST?
19:20:48 <thirsteh_> is there a more efficient way of embedding arrays in source files than e.g. Vector.fromList? I've noticed it slows down compile times quite a bit
19:20:49 <adelbertc> binary search tree im guessing
19:21:06 <adelbertc> studmuf - fold
19:21:16 <thirsteh_> e.g. foo :: V.Vector; foo = V.fromList [1,2,3,4,5]
19:21:23 <studmuf> pavonia: Binary Search Tree
19:21:36 <studmuf> ReinH: adelbertc: Thanks
19:21:38 <slack1256> Hi, I am trying to understand the following line of the singleton package
19:21:43 <slack1256> type KindOf (a :: k) = ('KProxy :: KProxy k)
19:21:59 <prophile> getSum . foldMap (const (Sum 1))
19:22:00 <slack1256> Can we really pattern match on the Kind of a promoted Type?
19:22:01 <prophile> presumably
19:22:09 <prophile> :t getSum . foldMap (const (Sum 1))
19:22:10 <lambdabot> (Num c, Foldable t) => t a -> c
19:22:29 <ReinH> > foldr ((+) . const 1) 0 [1,2,3,4,5,6,7] -- same thing
19:22:30 <lambdabot>  7
19:25:52 <japesinator> So, I'm trying to count the number of positions in a nested array which have something other than zero in them
19:26:14 <ReinH> japesinator: nested array?
19:26:21 <slack1256> an array of arrays right?
19:26:22 <japesinator> nested list, sorry
19:26:28 <japesinator> :: [[a]]
19:26:49 <slack1256> more easy! what do you want to do?
19:27:20 <ReinH> length . filter (\= 0) . concat would be the naive solution
19:27:26 <japesinator> right now I'm using numSquaresPlayed list = foldl (\acc x -> if x /= 0 then 1 + acc else acc) (concat list)
19:27:35 <ReinH> and depending on how well it fuses, might be sufficient
19:27:41 <japesinator> ReinH:  Thanks, that's what I'm looking for
19:27:59 <japesinator> but can someone tell me why my fold wasn't working?
19:28:15 <ReinH> :t foldl
19:28:16 <lambdabot> (a -> b -> a) -> a -> [b] -> a
19:28:16 <slack1256> no base case
19:28:18 <ReinH> you need an initial value
19:28:27 <slack1256> foldl (\acc x -> if x /= 0 then 1 + acc else acc) 0 (concat list)
19:28:30 <slack1256> should work
19:29:07 <japesinator> Oh okay.  I was using foldl1, so if the first number wasn't 1, it didn't work
19:47:55 <flebron> Say I want to compute x^2 `mod`p. Is there an efficient way of doing this, knowing both x and p are huge (about two hundred digits)?
19:48:00 <danny> how to get started with haskell?
19:48:12 <dwcook> @where lyah
19:48:13 <flebron> Is there a way to tell GMP "please be fast, 'cause I don't care about the remainders"?
19:48:13 <lambdabot> http://www.learnyouahaskell.com/
19:48:15 <dwcook> danny, ^
19:48:24 <danny> thanks
19:49:10 <dwcook> flebron, I don't remember much of it myself, but picking up a book on number theory might be of help
19:49:18 <dwcook> (There are free ones online)
19:51:44 <ParahSailin> flebron: gmp is slow for that?
19:52:01 <peddie> > let x = read $ replicate 200 '2'; y = read $ replicate 195 '3' in x^2 `mod` y
19:52:02 <lambdabot>  1111111111111111111111111111111111111111111111111111111111111111111111111111...
19:55:58 <ReinH> flebron: http://en.wikipedia.org/wiki/Modular_exponentiation ?
19:56:26 <flebron> ReinH: Unfortunately this is the base case there :p
19:56:36 <flebron> I'm still benchmarking to see if GMP is really the bottleneck.
19:57:33 <ParahSailin> flebron: i dont think the ^2 `mod` p is triggering the modpow integer-gmp primop
19:57:47 <flebron> ParahSailin: Can I make it so?
19:58:06 <flebron> (I'll try dumping the llvm bytecode to see if I can find that out, though.)
19:58:11 <ParahSailin> only if you call me number one
19:58:35 <flebron> OK, your number is 1, pirate.
19:59:23 <melonmechanic> i'm looking for some help making a functor instance. I'm getting a kind mis-match error http://lpaste.net/99423
19:59:43 <dwcook> melonmechanic, you're applying too many arguments to Auto
20:00:04 <melonmechanic> @dwcook ok, but when i take the type arguments off it complains that it needs type arguments
20:00:04 <lambdabot> Unknown command, try @list
20:00:06 <dwcook> The Functor typeclass includes things of kind * -> * but you're providing *
20:00:16 <dwcook> Well just take off one
20:00:59 <ParahSailin> well that kinda sucks, does integer-gmp not hook and expose the modmul functions? https://raw.github.com/ghc/packages-integer-gmp/master/GHC/Integer.lhs
20:01:29 <melonmechanic> @dwcook ok but why does it work with 1 argument and not both?
20:01:29 <lambdabot> Unknown command, try @list
20:01:44 <ParahSailin> https://github.com/ghc/packages-integer-gmp/blob/master/GHC/Integer/GMP/Prim.hs
20:01:54 <ParahSailin> powModInteger#
20:01:58 <dwcook> melonmechanic, because a fully applied type has kind *, but Functors should have kind * -> *, which are type constructors that take one concrete type and give you a new concrete type
20:02:05 <dwcook> s/a fully/the fully/
20:02:27 <melonmechanic> that makes sense. thanks for the help
20:02:31 <dwcook> @src class Functor
20:02:31 <lambdabot> Source not found. stty: unknown mode: doofus
20:02:33 <dwcook> @src Functor
20:02:33 <ParahSailin> try https://github.com/ghc/packages-integer-gmp/blob/master/GHC/Integer/GMP/Internals.hs GHC.Integer.GMP.Internals.powModInteger
20:02:34 <lambdabot> class  Functor f  where
20:02:34 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:02:49 <dwcook> Not sure if it helps to see that
20:03:06 <dwcook> but basically the f is inferred to have kind * -> * because it's seen in the method signature applied to a single type
20:03:26 <ReinH> :k Functor
20:03:27 <lambdabot> (* -> *) -> Constraint
20:05:39 <dwcook> melonmechanic, something else it might help to look at: Load up that module in ghci and do: :k Auto
20:05:57 <melonmechanic> well it's not in a module
20:06:05 <dwcook> Sure it is, every Haskell source file is a module
20:06:29 <melonmechanic> i'm following along to this. http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and
20:06:46 <melonmechanic> so Auto is one of the types that's in this article
20:07:16 <melonmechanic> i'm new enough to haskell that i haven't done much with writing my own instances yet but this finally clicked so i wanted to try it
20:08:09 <melonmechanic> ah i see what you mean though
20:08:23 <dwcook> What kind does it give you?
20:08:26 <melonmechanic> iAuto :: * -> * -> *
20:08:39 <melonmechanic> Auto :: * -> * -> *
20:08:49 <dwcook> Yep. So if you apply Auto to a single concrete type, you end up with a * -> *
20:08:54 <dwcook> which is what Functor instances take
20:09:25 <melonmechanic> yeah that makes sense. So if i had some other type Foo a b c then in order to do a functor instance i would have to do "instance Functor Foo a b where ..." right?
20:09:31 <dwcook> Yep
20:09:50 <dwcook> You can also fix the a and the b if you like, depending on your needs
20:09:58 <ReinH> melonmechanic: for instance, look at the Functor instances for tuples
20:10:24 <dwcook> @src instance Functor (a ,)
20:10:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:10:25 <ReinH> heh pun intended
20:10:32 <dwcook> @src Functor (a ,)
20:10:33 <lambdabot> Source not found. Do you think like you type?
20:10:40 <dwcook> Not sure how to lambdabot that
20:10:46 <dhrosa> thanks to whoever introduced me to GADTs, they're wonderful
20:11:01 <melonmechanic> instance Functor ((,) a)
20:11:02 <ReinH> instance Functor ((,) a) where fmap f (a,b) = (a,f b)
20:11:26 <ReinH> melonmechanic: why can't I write fmap f (a,b) = (f a,b)?
20:11:29 <dwcook> Oh right, forgot tuple sections aren't standard
20:12:43 <melonmechanic> ReinH not sure, but probably has something to do with the fact that theres only 1 type parameter
20:12:53 <dwcook> Not so much that
20:13:02 <dwcook> Not that at all, really
20:13:48 <dwcook> It might help to note that the thing the Functor "contains"/"computes" is just the last type applied
20:17:16 <melonmechanic> ah so ((,) a) :: b -> (a,b) so it can only operate on the b
20:19:27 <dwcook> It might be kind of confusing that (,) is both the type constructor and the data constructor
20:19:45 <dwcook> What's important is that in the type (a, b), b is the last one applied
20:19:59 <dwcook> (a, b) is the same as (,) a b
20:20:09 <jle`> melonmechanic: are you familiar with the Functor instance for functions? ( (->) a )
20:20:40 <melonmechanic> jle no not really
20:21:00 <jle`> ah. nvm, proceed with this :)
20:21:10 <jle`> one thing that helped me was thinking about type variables
20:21:25 <jle`> you know how they always specify Functors in functions as "f a -> ..." etc?
20:21:25 <Aetherspawn> @pl (\end name = sendMessage_ end name >>= yield)
20:21:26 <lambdabot> (line 1, column 12):
20:21:26 <lambdabot> unexpected "="
20:21:26 <lambdabot> expecting pattern or "->"
20:21:32 <jle`> :t fmap
20:21:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:21:37 <Aetherspawn> @pl (\end name -> sendMessage_ end name >>= yield)
20:21:37 <lambdabot> flip flip yield . ((>>=) .) . sendMessage_
20:21:41 <Aetherspawn> bah
20:21:46 <Aetherspawn> @pl is no good anymore
20:21:46 <lambdabot> is no good anymore
20:21:51 <Aetherspawn> haha.
20:22:03 <jle`> well, "f" "can be anything", as long as it takes an a and yields a concrete type.
20:22:21 <jle`> if is Maybe, you have (a -> b) -> Maybe a -> Maybe b
20:22:32 <dwcook> I wonder if this is in lambdabot
20:22:34 <dwcook> @src Flip
20:22:34 <jle`> if f is Either String
20:22:34 <lambdabot> Source not found.
20:22:50 <jle`> then you have (a -> b) -> (Either String) a -> (Either String) b
20:23:03 <jle`> that's for f ~ (Either String)
20:23:07 <qrada> hey, admittedly havn't googled for this, wondering if someone knows right of top... so i have two data type's with an "id" method.. and i'm getting conflicts, multiple declarations etc... is it possible to have two data types with that same id field, or would I have to define them in separate modules
20:23:11 <jle`> note that Either is not a functor
20:23:12 <carter> ddere:  but you're not in #haskell.au too
20:23:20 <qrada> id field even
20:23:21 <qrada> not method
20:23:22 <jle`> because it doesn't make sense (a -> b) -> Either a -> Either b
20:23:34 <jle`> it only makes sense (a -> b) -> (Either String) a -> (Either String) b
20:23:40 <qrada> usually ghc suggests me a workaround, not this time tho
20:23:45 <melonmechanic> yeah i can see that now
20:23:49 <jle`> same for State s
20:23:51 <jle`> Reader e
20:24:05 <ddere> carter: ah, I'm really new to the whole participating in the dev community thing, i'll fix that
20:24:12 <carter> hehe
20:24:13 <melonmechanic> i think its the hardest for me because i'm used to seeing variables for values instead of types
20:24:18 <dwcook> qrada, yeah, separate modules. Also, I'd suggest not reuising identifiers from the Prelude if you can help it.
20:24:21 <carter> ddere: what sort of stuff do you do?
20:24:31 <jle`> melonmechanic: welcome to Haskell ;)
20:24:34 <pyon> what's the command for running ghci using the packages installed in the local sandbox?
20:24:39 <qrada> ah ya forgot about prelude with id.. didnt get that warning yet because others errors preventing it from getting there hehe
20:24:41 <melonmechanic> haha. Well i definitely have the bug
20:24:42 <qrada> thanks
20:24:50 <melonmechanic> just trying to remap the brain now
20:25:10 <dwcook> qrada, then you can import qualified Foo as F ; import qualified Bar as B
20:25:13 <jle`> reasoning with type functions and kind signatures is definitely something that you don't exercise in other languages haha
20:25:34 <qrada> ya
20:25:35 <jle`> well, normal languages
20:25:37 <jle`> heh
20:25:51 <melonmechanic> yeah i primarily do c# for work
20:25:52 <jle`> one day when Idris and Coq are the new Haskell...we'll be talking differently.
20:25:59 <dwcook> melonmechanic, the good news is that often, if you sort out the types correctly, everything else just falls into place
20:26:02 <melonmechanic> so i'm pretty set in the ways of imperativeness
20:26:14 <melonmechanic> dwcook yeah i've noticed that
20:26:24 <melonmechanic> not a lot of complicated issues when the code actually compiles
20:26:39 <jle`> :)
20:26:45 <jle`> it really is like learning how to program all over again haha
20:27:21 <melonmechanic> yeah. the whole recursion for everything and laziness is especially challenging since coming from languages that don't handle that well you pretty much beat it out of your head to use recursion
20:27:21 <dwcook> I still feel way better about my ugly code in Haskell than about my beautiful code in JavaScript
20:27:33 <dwcook> Recursion actually isn't used a lot in practice
20:27:45 <jfischoff> dwcook: at least you can refactor
20:27:58 <melonmechanic> ok, well if you use map do you count that as recursion?
20:28:01 <dwcook> jfischoff, yep!
20:28:13 <dwcook> melonmechanic, nope. Even if it's implemented that way, it's all the same to you
20:28:19 <melonmechanic> i know you might not "write" recursive functions much, but it's still that way under the hood
20:28:21 <melonmechanic> yeah
20:28:58 <melonmechanic> the stream and auto stuff in that article i linked to is probably the first time a concept has clicked for me in haskell
20:29:09 <melonmechanic> usually i can follow it, but then to try and do anything with it i'm lost
20:29:11 <ReinH> yay lightbulbs!
20:29:23 <melonmechanic> haha indeed
20:30:46 <jrmithdobbs> melonmechanic: i had a "wait, i can actually use that stuff i remember because the stack probably wont blow out because ... wait compilers can solve this SON OF " moment at one point
20:32:24 <jfischoff> What is a Haskell concept that would make more sense if there was animation showing how it worked?
20:33:29 <melonmechanic> well thanks for the help everyone. I'm going back to tinkering now :)
20:33:30 <dwcook> Stepping through a non-strict evaluation, maybe?
20:33:47 <ddere> yeah I'd second that
20:33:51 <jfischoff> dwcook: yeah maybe an infinite map
20:34:08 <jfischoff> like map with an infinite list and a take after it
20:34:22 <dwcook> Sounds like a reasonable example
20:34:51 <jfischoff> cool
20:36:43 <Cale> I wouldn't count using map as recursion.
20:36:54 <Cale> Implementing it, well, it depends :)
20:37:08 <sclv> folds are pretty good to step through
20:37:28 <jfischoff> I was folder too
20:37:49 <jfischoff> I don't think I would want to step through all the steps … too slow
20:39:29 <Cale> It's actually very good practice to do some lazy evaluation by expression rewriting like that at least once in your life :)
20:40:15 <Cale> It can help to build an understanding about time and space performance.
20:40:17 <pyon> so i have a sandbox in which i have installed some packages - how do i start ghci and tell it to use those packages instead of the default ones installed in ~/.cabal ?
20:40:31 <jle`> it also helps you see that all Haskell is just expression rewriting
20:40:45 <Cale> Well, the evaluation part of Haskell is, anyway :)
20:41:03 <jle`> :P
20:41:25 <Cale> (execution of IO actions has a different character to it)
20:42:41 <Cale> pyon: cabal repl
20:43:17 <pyon> ah thanks
20:46:07 <dhrosa> how do you get parsec and gadts to play nicely with eachother?
20:46:14 <dhrosa> I'm having rigid type errors galore
20:49:51 <Cale> dhrosa: Have your parser construct a value of an existential wrapper type.
20:51:24 <Cale> Like  data SomeExpr where SE :: forall a. Expr a -> SomeExpr
20:51:33 <Cale> Where Expr is your GADT
20:52:00 <Cale> You can then recover information about the actual type of Expr through pattern matching.
20:53:03 <heatsink> Can anyone suggest packages that use Template Haskell a lot?  I want to profile the interpreter.
20:53:44 <td123> heatsink: yesod maybe?
20:54:59 <heatsink> Whoa... that depends on >100 packages
20:57:32 <dhrosa> hmm, I think I see, let's try this
20:59:43 <bitemyapp> I can't get strict-concurrency to build for the life of me.
21:00:00 <bitemyapp> it keeps saying OldException doesn't exist, but the range allowed for base is 4-5
21:04:44 <bitemyapp> Could not find module `Control.OldException' :|
21:05:02 <td123> heatsink: something smaller might be lens, but I'm not sure if it uses a lot of TH, I know there is some though
21:05:23 <c_wraith> bitemyapp: yes, the upper bound is wrong.  People get lazy about upper bounds
21:05:39 <td123> heatsink: you could also choose the components that do use TH a lot
21:05:43 <Cale> Well, not just lazy, but the PVP requires you to be prophetic
21:06:29 <heatsink> td123, I'll check out lens
21:06:36 <Cale> (I think upper bounds where you don't explicitly know them don't make any sense.)
21:06:50 <dhrosa> Cale:   Add :: (Num a) => Expr a -> Expr a -> Expr a
21:06:51 <dhrosa> woops
21:07:14 <heatsink> Also, the shakespeare package used by yesod provides TH functions
21:07:19 <Cale> bitemyapp: So, the right thing to do would be to update the package to use the new Control.Exception.
21:08:14 <Cale> All that you'd have to do is import Control.Exception instead, and in each of the catches, where the handler function is (\e -> ...) replace that by (\(SomeException e) -> ...)
21:09:17 <heatsink> Not as bad as yesod.  lens only needs 22 packages.
21:10:29 <jfischoff> Cale: I think you mean (\(e :: SomeException)
21:10:43 <Cale> jfischoff: hm?
21:11:04 <Cale> Well, that would likely work as well, but it'd require an extension.
21:11:08 <Cale> My way doesn't.
21:11:24 <bitemyapp> c_wraith: yeah I'd just figured that out.
21:11:33 <bitemyapp> Cale: does anybody still use strict-concurrency? if not, why not?
21:11:41 <bitemyapp> I'm trying to figure out how/why the library fell out of date.
21:12:00 <jfischoff> Cale: touche.
21:12:02 <Cale> bitemyapp: All that library does is seq the things you're putting in the MVar or Chan
21:12:12 <c_wraith> well, it deepseqs them
21:12:13 <Cale> Or deepseq, rather
21:12:14 <Cale> yeah
21:12:21 <c_wraith> But it's something you can do yourself easily enough
21:12:30 <c_wraith> Which was Cale's point, I believe
21:12:35 <Cale> yeah
21:12:46 <c_wraith> Also, deepseq is usually *too* much of a hammer
21:12:47 <Cale> and it's not all *that* common to care so much about it
21:12:52 <c_wraith> Usually you want something more precise
21:12:57 <dhrosa> Cale: let's say I have data Expr a where Lit8 :: (Integral a) => a -> Expr Word8, and data AnyExpr where AnyExpr :: Expr a -> AnyExpr
21:13:04 <bitemyapp> Cale: I don't actually care about strict-concurrency, it was on the way to other things.
21:13:19 <bitemyapp> I'm just going to back off and forget it for now :\
21:13:48 <dhrosa> Cale: how would I pattern match on an AnyExpr containing a Lit8, let f (AnyExpr (Lit n)) = n causes a "could not deduce" error
21:13:49 <bitemyapp> but I did learn more about the dangers of sloppy upper-bounds in packaging.
21:13:56 <Cale> It's too bad that cabal has permissions now, or I'd just fix the package myself
21:14:14 <bitemyapp> Cale: it's a dons library, couldn't you just ping him about it?
21:14:16 <Cale> bitemyapp: Well, the trouble with upper bounds is that they're impossible to determine when you write anything.
21:14:21 <bitemyapp> Right.
21:14:39 <Cale> and I don't think hackage lets you adjust them after the fact even
21:14:50 <Cale> Well, maybe you could reupload old versions of your packages
21:15:00 <Cale> But I don't think anyone even does that.
21:16:12 <heatsink> That pattern matching should work, dhrosa.  But you probably want Lit8 to have the signature Word8 -> Expr Word8
21:17:31 <Cale> dhrosa: Either heatsink's suggestion, or I suppose you could use fromIntegral n there.
21:17:58 <dhrosa> hmm, changing it to Word8 is fine
21:18:01 <Cale> But also, you may need to give an explicit signature to f
21:18:26 <Cale> Inferring the types of things which operate on GADTs is sometimes tricky/ambiguous/impossible
21:20:55 <dhrosa> Cale: even if I give an explicit type signature, like f :: AnyExpr -> Word8, or f :: (Integral a) => AnyExpr -> a, I get a "could not deduce" error
21:21:01 <dhrosa> Cale: with my polymorphic Lit8
21:22:10 <Cale> dhrosa: Well, if you take something of an arbitrary Integral type, you can't use it as a Word8 unless you explicitly convert using fromIntegral
21:22:42 <dhrosa> aha
21:23:01 <Cale> and vice versa
21:23:05 <dhrosa> I forgot that because of how GADTs work, the type contained in my Lit8 isn't actually a Word8
21:23:09 <dhrosa> so yeah fromIntegral
21:23:31 <Cale> and if you have something of an unknown Integral type, you similarly can't use it as a value of a specific possibly different Integral type
21:23:45 <Cale> (as in what happens with the second type signature for f there)
21:30:44 <dhrosa> Cale: so if I use AnyExpr, how do I go about useing my GADTs with Parsec's expression parser, do you know?
21:32:00 <Cale> I haven't really used Parsec's expression parser thingy much. I tend to just write parsers directly when I need them.
21:32:23 <Cale> dhrosa: But it shouldn't be much different than in any other case, I would think.
21:33:06 <Cale> (i.e. it shouldn't be any different than with a non-GADT type as far as I can tell)
21:33:16 <dhrosa> hmm, let's see what happens
21:46:14 <flebron> Is there a backdoor into GMP functions one can use with Integer for performance?
21:47:54 <flebron> Also known as: I've profiled my application and 98% of the time is spent in Math.NumberTheory.Moduli.invertMod, I'm inverting about a million numbers modulo some prime p, p is about 150 digits.
21:49:44 <copumpkin> no, it's a bit of a pain unfortunately
21:49:55 <copumpkin> you need to do some work to bind to other GMP functions
21:51:53 <Cale> Well, not to mention that Integer actually has two constructors internally (one for GMP and one for machine ints), so you'll end up writing things for every combination of those.
21:52:49 <flebron> Do you guys have any ideas on how to optimize this sort of thing? Specifically, I'm inverting g^0, g^1, ..., g^k (mod p)
21:53:13 <Cale> Find g^-1, and compute the rest by multiplication
21:53:21 <copumpkin> Cale: a lot of the gmp functions support small operands
21:53:22 <flebron> ... I'm stupid.
21:53:45 <flebron> Cale: Thanks. xP
21:53:49 <Cale> no problem :)
21:55:44 <flebron> pre-#haskell Runtime: 3m20s.
21:55:56 <flebron> post-#haskell Runtime: 12.4s.
21:56:06 <Cale> hah, nice :)
21:57:21 <bitemyapp> flebron: noice.
21:58:49 <adelbertc> looking for hash-table like data structure, is unordered-containers the library i want?
21:59:00 <copumpkin> what do you want out of it?
21:59:18 <copumpkin> Data.Map is generally a reasonable default
22:01:15 <adelbertc> copumpkin - adjacency list for large graphs (thinking millions of nodes)
22:01:34 <copumpkin> I'd probably reach for an IntMap
22:01:56 <copumpkin> it's a bit trie without a hash function in front of it
22:02:23 <copumpkin> if your graph is big enough you might want to start thinking about ways to keep it flat in memory though
22:02:32 <copumpkin> or not even keep it all in memory at once
22:02:35 <Jookia> Hey, I'm finding a really weird problem with my code. Also I've managed to crash GHC?
22:02:54 <Jookia> http://sprunge.us/eOMZ?hs
22:03:32 <adelbertc> hm. was trying to go for more general than restricted node ID's to Int's, but now that you mention it might not be worth it, given most graph ID's can be keyed by int's anyways.
22:04:20 <adelbertc> copumpkin - fair enough.
22:04:28 <adelbertc> now.. how does one go about removing a dependency in a cabal project (sandboxed)
22:07:38 <adelbertc> newbie question: how does one know what versions of a library are OK to depend on? e.g. currently i'm saying containers == 0.5.4.0 but i'm guessing i don't need to be quite that strict?
22:13:55 <Kneiva> I guess >= {version you used} is generally ok, unless you know that some newer versions do not work with your code
22:18:50 <adelbertc> Kneiva - fair enough
22:18:51 <adelbertc> thanks
22:49:50 <dhrosa> :t f
22:49:56 <lambdabot> FromExpr a => a
22:55:31 <Twey> Jookia: Nice!  Submit a bug report?
22:56:36 <dhrosa> http://lpaste.net/99428 Can anyone show me how I would go about using parsec and gadts? my expr function is what it would look like if I weren't using AnyExpr, but I'm not sure how to make it work with AnyExpr
22:58:13 <Twey> adelbertc: If your program compiles with 0.5.4.0, the versioning conventions say that 0.5.4.0 up to (but not including) 0.6.0.0 should be safe to use
22:58:16 <dhrosa> hmm
22:58:46 <Twey> adelbertc: (i.e. we bump the first two digits for API-breaking changes)
22:58:56 <dhrosa> @pl g (f a b)
22:58:57 <lambdabot> g (f a b)
22:59:01 <dhrosa> err
22:59:04 <adelbertc> Twey - got it, cheers
22:59:05 <dhrosa> @pl \a b -> g (f a b)
22:59:05 <lambdabot> (g .) . f
22:59:39 <Twey> dhrosa: Some people like to define an operator (.:) = (.) . (.), so that you can say g .: f
23:00:14 <supki> Twey: that's only safe if you import every symbol explicitly
23:00:35 <Twey> Or use qualified imports, aye
23:01:12 <Twey> But you'll probably be alright unless you're rather unlucky; if you think your names are likely to crash later on then stick to 0.5.4.x
23:01:24 <Twey> clash** dammit
23:02:38 <ReinH> such netsplit wow
23:02:46 <adelbertc> what should i be looking for if i want set-like behavior (e.g. uniqueness) but also O(1) (or close to) random access?
23:02:56 <Twey> dhrosa: What's the problem you're having, exactly?
23:03:04 <ReinH> adelbertc: Data.Set?
23:03:28 <Twey> adelbertc: Data.Set is O(log n), which may be ‘close to’ depending on your purposes
23:03:46 <ReinH> log n is pretty close
23:04:02 <dhrosa> Twey: I can't figure out how to  make my parser take  two AnyExprs and an infix operator "+", and return an AnyExpr containing an (Add left right)
23:04:17 <dhrosa> and I don't understand how the Num a constraint works with the type-erasing of AnyExpr
23:04:22 <ReinH> Twey: fuck yeah trees
23:04:22 <adelbertc> ReinH Twey - yeah fair enough, didn't think that question through. i'll go with Data.Set for now and benchmark later
23:04:30 <dhrosa> sorry afk
23:04:41 <Twey> adelbertc: If it's not close enough there's a Data.HashTable, but it will probably be okay
23:04:58 * ReinH coughs and it sounds like "premature optimization"
23:05:15 <adelbertc> :-)
23:05:20 <Twey> Heh
23:05:23 <ReinH> =)
23:06:29 <Twey> dhrosa: I think you're missing a call to AnyExpr
23:07:17 <Twey> (string "+" >> return (\x y → AnyExpr $ Add x y))
23:07:43 <Twey> No implicit conversions around here!
23:09:19 <adelbertc> hm i have NoImplicitPrelude and that hides Int. so i tried import GHC.Types (Int) and now i'm getting Could not find module `GHC.Types'It is a member of the hidden package `ghc-prim'
23:09:22 <adelbertc> o_O
23:10:29 <bitemyapp> okay, what's going on with Freenode?
23:10:30 <Twey> dhrosa: Oh, but your lit8 gives you an AnyExpr too, so there's no guarantee that you can use Add (the two existential ‘a’s inside those AnyExprs may not be the same)
23:10:35 <Twey> bitemyapp: DDoS
23:10:50 <bitemyapp> why would you DDoS a publicly useful utility?
23:11:06 <Twey> dhrosa: You probably want your lit8 to not do the AnyExpr thing
23:11:40 <prophile> bitemyapp: amusement
23:11:56 <Jookia> Twey: Dunno if it's fixed in GHC 7.8. I still have the error when removing the crash code though
23:12:19 <Twey> Ugh
23:12:48 <Twey> dhrosa: This is highly unpleasant.  You've thrown away your type information with that existential and now you want to get it back again to use with Parsec.
23:15:21 <Twey> dhrosa: You should probably not throw it away at all; but if you do, you should store a type tag so you can get it back later
23:16:37 <ReinH> bitemyapp: some people just want to watch the world burn
23:16:53 <ReinH> adelbertc: ... maybe don't hide the prelude then? :p
23:17:05 <Twey> adelbertc: You can get Int from Data.Int
23:17:08 <adelbertc> hm, isn't it good practice to do NoImplicitPrelude
23:17:18 <ReinH> adelbertc: not really?
23:17:22 <bitemyapp> adelbertc: wha?
23:17:24 <Twey> adelbertc: Or you can import it explicitly as ‘import Prelude (Int)’
23:17:26 <ReinH> Prelude is pretty useful
23:17:29 <Twey> adelbertc: Absolutely not
23:17:38 <bitemyapp> the only time I avoid Prelude is when I'm doing heavy-duty numerics or I'm writing Fay
23:17:38 <ReinH> It's full of... you know... stuff you want
23:17:50 <Twey> NoImplicitPrelude is for if you want to replace the standard Prelude with an alternative, like NumericPrelude or AwesomePrelude
23:17:53 <bitemyapp> both have fairly specialized reasons for eschewing prelude. One of them isn't, strictly speaking, Haskell.
23:18:00 <ReinH> that's... you know... why that stuff is in Prelude
23:18:20 <adelbertc> mostly following this https://twitter.com/HaskellTips/status/429311965849075712
23:18:24 <adelbertc> (albeit blindly)
23:18:28 <adelbertc> perhaps i shouldn't hide it then
23:18:36 <ReinH> adelbertc: You *can*. Doesn't mean you should.
23:18:42 <adelbertc> fair enough
23:18:45 <bitemyapp> adelbertc: you're looking at a pro-tip, not an amateur-tip.
23:18:50 <adelbertc> :-(
23:19:00 <Jookia> harsh
23:19:02 <bitemyapp> I didn't mean any offense :(
23:19:06 <prophile> the tip of a pro
23:19:22 <prophile> when sharpened, it can be used as a makeshift vegetable knife
23:19:22 <bitemyapp> it's just that more experienced Haskell users are a lot finickier and more patient with customizing the language/environment to suit their preferences.
23:19:40 <bitemyapp> if you're just getting rolling, don't fuck with it whatever doesn't have to be fucked with.
23:19:45 <adelbertc> bitemyapp - heh yeah i get what you're saying
23:19:47 <ReinH> Well, I haven't yet had a reason to use that pragma
23:19:51 <bitemyapp> adelbertc: entropy REIGNS
23:19:55 <bitemyapp> ReinH: Fay.
23:20:02 <ReinH> bitemyapp: well I don't use Fay so :p
23:20:05 <Twey> ReinH: NumericPrelude
23:20:09 <bitemyapp> ReinH: come join me in the Hell that is front-end.
23:20:11 <ReinH> Twey: Well I haven't used that so :p
23:20:15 <ReinH> bitemyapp: NO THANKS
23:20:15 <bitemyapp> ReinH: the magma's warm, I promise.
23:20:15 <Twey> :þ
23:20:27 <bitemyapp> ReinH: BATHE WITH ME IN MY DEMONIC MAGMA POOL NOW
23:20:42 <ReinH> Twey: I would rather like to switch to the Prelude that makes Functor < Applicative < Monad though :p
23:20:49 <bitemyapp> yeah so uh, this is why I flipped over to 90%++ backend work at my day job.
23:21:02 <ReinH> bitemyapp: NO IM GOOD THANKS
23:21:04 <Twey> ReinH: That's not in Prelude :þ
23:21:16 <ReinH> Twey: THAT'S THE JOKE :( :( :( (
23:21:19 <Twey> ReinH: (it's in base, though, 7.8)
23:21:20 <ReinH> (It's not very funny)
23:21:25 <bitemyapp> Twey: wait really?
23:21:28 <ReinH> Twey: can't wait to upgrade :D
23:21:30 <Twey> So I hear
23:21:35 <bitemyapp> ReinH: RC is up yo.
23:21:37 <ReinH> also dat io manager
23:21:38 <bitemyapp> you can install it right now.
23:21:47 <ReinH> such spinlock wow
23:21:49 <ReinH> etc
23:21:51 <Twey> I'll just be over here hugging my working packages.
23:21:52 <bitemyapp> ReinH: yeah I'd like to see the IO manager get used in the next techempower.
23:21:56 <ReinH> Twey: yeah right?
23:22:06 <bitemyapp> Twey: after the time I spent unfucking somebody else's cabal file today, I feel that.
23:22:26 <ReinH> having just completely reinstalled haskell platform I'm pretty happy with my current non-cabal hell working packages environment
23:22:38 <Twey> I usually use my package manager and it keeps my packages mostly unfucked, but there's no ebuild for 7.8 yet
23:22:46 <ReinH> heh "package manager" heh
23:22:53 <ReinH> "package installer"
23:22:54 <ReinH> :p
23:23:01 <Twey> Maybe it's time to switch to NixOS
23:23:02 <prophile> is Applicative < Monad a good thing without default superclass instances?
23:23:03 <ReinH> "package installer most if the time"
23:23:04 <bitemyapp> {-# LANGUAGE GeneralizedNewtypeDeriving #-} -- oh yeah this'll end well
23:23:19 <bitemyapp> deriving ..., MonadIO, ... -- brave.
23:23:22 <ReinH> prophile: it is what ought to be, current practice notwithstanding
23:23:23 <Twey> bitemyapp: GeneralizedNewtypeDeriving is fine and useful.  Except when it's not.
23:23:32 <ReinH> bitemyapp: whatever I derive that all the time
23:23:48 <Twey> But you have to try fairly hard to make it be not, I think.
23:23:52 <bitemyapp> ReinH: this is from the codebase of a game engine that didn't bother to constrain a single version in the build-depends.
23:23:56 <ReinH> hasn't bitten me yet
23:23:58 <bitemyapp> Not a single range or specific version.
23:24:04 <bitemyapp> I don't trust anything this person does anymore.
23:24:09 <ReinH> game engine for what?
23:24:25 <prophile> it seems to me it might just be a matter of broken backwards compatibility for not much tangible benefit for most people
23:24:28 <bitemyapp> mein kraft dinner apparently.
23:24:33 <ReinH> just saying I haven't had any problems deriving MonadState, MonadIO, etc for my newtype monad stacks
23:24:51 <bitemyapp> it is a newtype. it'll probably be fine, I'm just leery of it.
23:25:13 <ReinH> whyyyyy
23:25:24 <bitemyapp> ReinH: hatred and fear
23:25:25 <ReinH> irrational fear is irrational :p
23:25:44 <bitemyapp> I have no problem with this.
23:26:04 <ReinH> Pretty standard
23:26:18 <bitemyapp> ReinH: http://i.imgur.com/3TAQFEZ.jpg
23:26:19 <ReinH> prophile: yeah, that's true, but it's a source of some frustration
23:26:28 <bitemyapp> ReinH: I'm a wizard, harry. I'll warm up to it eventually.
23:26:32 <ReinH> heh
23:26:43 <bitemyapp> ReinH: I use Clojure at work, bravery is not in short supply.
23:26:49 <prophile> ReinH: seems like it's a source of frustration either way, just to different groups of people
23:27:00 <ReinH> prophile: pretty much but one group is RIGHT. ;)
23:27:19 <prophile> granted, but the other group is bigger :)
23:27:23 <bitemyapp> I didn't know anybody was actually arguing against it.
23:27:31 <ReinH> prophile: pssh ;)
23:27:55 <ReinH> success at all costs my friend
23:27:56 <ReinH> join me
23:28:06 <ReinH> oh wait that's not quite right
23:28:24 <prophile> that dastardly simon marlow sowed the seeds of doubt in that haskellcast episode
23:28:45 <ReinH> prophile: I am familiar with that haskellcast episode
23:29:02 <prophile> I figured :)
23:29:09 <ReinH> since I'm the one that interviewed him :p
23:29:29 <Twey> prophile: No well-behaved code should be a Monad without being an Applicative or an Applicative without being a Functor anyway, so only broken code will be broken
23:29:42 <ReinH> yes, yes, join us
23:29:42 <Twey> This was deemed acceptable collateral damage
23:29:48 <bitemyapp> edwardk: welcome back to yet another day of DDoS
23:29:54 <prophile> turn to the applicative side
23:29:54 <ReinH> join us over here in correct land
23:30:00 <Malar> how can i refactor this? http://lpaste.net/99429
23:30:14 <ReinH> Malar: holy indent batman
23:30:14 <prophile> seems like default superclass instances would be a good solution for both groups
23:30:14 <bitemyapp> ReinH: I've met people that will argue against correctness in the past. It was bizarre.
23:30:27 <ReinH> bitemyapp: the correct is the enemy of the good
23:30:30 <ReinH> no wait that's not right either
23:30:37 <Twey> Malar: I think step one is to stop using those huge tabs :þ
23:30:42 <Ralith_> Malar: by presseng return more often
23:30:45 <Ralith_> pressing
23:30:53 <ReinH> Malar: use a parser
23:30:55 <bitemyapp> Malar: clean your keyboard, your tab key is sticking.
23:31:08 <Malar> :P it is some vim plugin
23:31:17 <bitemyapp> "some vim plugin" summarizes most of vim.
23:31:49 <ReinH> anyway use parsec
23:31:58 <Malar> other than indentation?
23:32:03 <bitemyapp> Malar: what ReinH said.
23:32:21 <Malar> instead of pattern match?
23:32:54 <ReinH> you wanted suggestions for refactoring
23:32:59 <ReinH> my suggestion is to use parsec
23:33:26 <bitemyapp> Malar: unless you want this to be you in 6 months when you come back to the code: http://i.imgur.com/emxJAgO.jpg
23:33:37 <Ralith> Malar: normally people insert a newline after 'of'
23:34:12 <Tekmo> ParahSailin: I have the `transpose` function for you (and `zipMany` built on top of `transpose`, too)
23:34:47 <Tekmo> ParahSailin: http://lpaste.net/99431
23:35:01 <Twey> Malar: Here's a naïve reformatting: http://lpaste.net/99429
23:35:33 <ReinH> Twey: oh god yes my eyes hurt less now
23:36:04 <Twey> Malar: But really, the whole fact that you're using strings like this indicates there's something funky in your design.  You should have used a more informative data-type, or if you have to have a string for some reason, you should have parsed it into something better long before it makes it anywhere near your business logic
23:36:22 <Twey> (possibly using Parsec :þ)
23:36:52 <bitemyapp> Twey: but strings make the compiler stop yelling at me ;_;
23:36:57 <Ralith> heh
23:36:59 <bitemyapp> Twey: I don't wanna get yelled at ;_;
23:37:15 <ReinH> Twey: parsing it by... perhaps... using Parsec :D
23:37:29 <ReinH> Twey: fuck that everything is lists. Lists everywhere.
23:38:01 <Tekmo> They're not bad if you use them as control structures
23:38:02 <bitemyapp> ReinH: lists and strings.
23:38:04 <ReinH> And as quickly as possible turn those lists into booleans
23:38:15 <ReinH> and operate on booleans
23:38:16 <bitemyapp> Tekmo: we're not talking about free monads right now.
23:38:25 <Tekmo> Lists can be control structures, too
23:38:27 <ReinH> no lists are perfectly good control structures
23:38:34 <ReinH> A list is a loop that hasn't looped yet
23:38:37 <Tekmo> ^
23:38:41 <bitemyapp> Tekmo: stop trying to talk about free monads.
23:38:44 <bitemyapp> >:)
23:38:45 <Tekmo> bitemyapp: :)
23:38:46 <ReinH> hahaha
23:38:54 <ReinH> also free monads are perfectly good lists
23:39:03 <ReinH> which are perfectly good control structures
23:39:03 <bitemyapp> ReinH: ITYM applicatives.
23:39:11 <ReinH> nope
23:39:47 <bitemyapp> ReinH: actually come to think of it, if I wanted something like an AST without using an icky [] + ADT, would free monads be a good fit?
23:40:06 <ReinH> yep
23:40:11 <bitemyapp> thinking along the lines of a DSL or structured query language (I don't mean SQL the QL, just generally) or something.
23:40:16 <Tekmo> bitemyapp: Depends on what you mean
23:40:27 <Malar> Twey: it is the button label which is a string and i don't have control over it :P
23:40:38 <ReinH> pretty much, although free-operative might provide a nicer interface (while still being essentially a free monad)
23:40:42 <Tekmo> bitemyapp: Free monads are mainly appropriate when you want to provide a monadic interface to a DSL
23:41:00 * bitemyapp nods
23:41:06 <ReinH> but Tekmo knows more than I do
23:41:26 <bitemyapp> thank you both.
23:41:27 <Tekmo> bitemyapp: There are other possible interfaces, lists and applicatives being some examples
23:41:31 <bitemyapp> it's been on my mind lately.
23:41:44 <Tekmo> bitemyapp: More generally, free objects are the general concept for interfaces that support multiple interpreters/backends
23:41:58 <bitemyapp> Tekmo: I worked on libraries in Clojure that in some cases meant having a DSL or QL somewhere, I was just trying to translate those experiences to Haskell.
23:42:13 <Tekmo> bitemyapp: Generally figure out what interface you want and then just prepend that with "free"
23:42:13 <bitemyapp> Tekmo: that doesn't disagree with my mental model for free monads so far. Cool.
23:42:27 <Tekmo> bitemyapp: i.e. if you want a monoid-like interface then use the "free monoid" (i.e. lists)
23:42:28 <ReinH> Tekmo: well I guess that's a valid interpretation :)
23:42:54 <Tekmo> bitemyapp: If you want an Applicative interface you use free applicatives
23:43:01 <Tekmo> bitemyapp: If you want a monadic interface you use free monads
23:43:06 <Malar> Thanks Ralith and Twey looks better now. :0
23:43:34 <Twey> Malar: 1) Why are you performing conditional logic on a button label?  2) You can still parse it into a more informative data type before it gets to your logic
23:43:38 <Tekmo> bitemyapp: Free monads and lists are mainly the two most popular free objects because Haskell has syntactic sugar for monads and lists
23:43:52 <Twey> http://lpaste.net/99429 — this is a better-formatted version of that code, by the way
23:44:03 <Malar> Twey, ok
23:44:20 <Tekmo> bitemyapp: You can also have free categories and free `Arrow`s, for example
23:45:13 <ReinH> Tekmo: generated by a graph, yay!
23:45:59 <bitemyapp> Tekmo: I clearly don't understand the subject that well, I don't have any intuition for what a free category would be like and very little for free arrows.
23:46:01 <prophile> people use binary trees sometimes
23:46:08 <prophile> those are free magmas, right?
23:46:17 <ReinH> bitemyapp: a free category is the category generated by a directed multigraph
23:46:33 <ReinH> where edges are arrows and composition is connecting edges in the obvious way
23:47:00 <danny> how to have a string literal that extends over multiple lines?
23:47:23 <Tekmo> ReinH: Nice! :)
23:47:25 <ReinH> danny: use \ or template haskell or unlines ["first line", "second line"]
23:47:28 <ReinH> Tekmo: ?
23:47:41 <ReinH> er not template haskell, quasiquotes
23:47:56 <Tekmo> bitemyapp: Think of "free X" as an X-like interface that preserves as much syntax as possible
23:48:08 <Twey> There's a proposal to remove string gaps; didn't that make it into H2010?
23:48:21 <Tekmo> bitemyapp: At least, the syntax relevant to X
23:48:36 <bitemyapp> Sure.
23:48:50 <bitemyapp> I had that much, it just doesn't give me a good intuition for arbitrary examples.
23:48:55 <Twey> Isn't a ‘free X’ an X that has all the X laws as free theorems of the type of the original construct?
23:49:07 <ReinH> or think of a free x as being produced by a functor that is left adjoint to a forgetful functor from X to some other category :p
23:49:35 <Tekmo> Or a terminal object in a comma category
23:49:44 <ReinH> the adjoint relationship defines "free" in non-hand-wavey terms ;)
23:49:54 <Tekmo> There are multiple ways to think about it.  Different interpretations suit different people
23:50:15 <prophile> somehow I'm reminded of http://cokmett.github.io/cokmett/
23:50:46 <ReinH> hahaha
23:50:59 <adelbertc> got myself a function called "reverse" in my module, trying to export it but it clashes with Prelude. qualifying it with the modulename doesn't seem to work...
23:51:13 <bitemyapp> I'm an idiot and didn't intuit that contravariant functors were cofunctors.
23:51:14 <ReinH> adelbertc: either hide it when importing Prelude or import it qualified
23:51:16 <bitemyapp> sadface :(
23:51:25 <ReinH> bitemyapp: *but they point the other way* :p
23:51:36 <bitemyapp> RIGHT
23:51:45 <bitemyapp> thank you for highlighting what about it made me feel dumb.
23:51:54 <ReinH> bitemyapp: it's ok! I feel dumb CONTINUOUSLY :)
23:52:01 <ReinH> I am feeling dumb right now about other stuff :D
23:52:14 <Twey> adelbertc: You'll have to hide the one from Prelude
23:52:23 <ReinH> bitemyapp: that's probably not the kind of reassurance you were hoping for...
23:52:24 <adelbertc> Twey ReinH - worked, cheers
23:52:27 <Twey> adelbertc: import Prelude hiding (reverse)
23:52:59 <Twey> adelbertc: You can then ‘import qualified Prelude as Pre’ and get Pre.reverse back, if you want it
23:53:06 <bitemyapp> ReinH: I think feeling dumb/frustrated continuously is how you know you're improving.
23:53:09 <adelbertc> cool beans
23:53:17 <ReinH> bitemyapp: also sums are coproducts *MIND SPLODE*
23:53:32 <Twey> ReinH: Only disjoint sums
23:53:35 <ReinH> bitemyapp: this feeling means it's working!
23:53:40 <Tekmo> Reminds me of Courage Wolf: If life gets harder it means you recently leveld up
23:53:44 <ReinH> Twey: as in sum types, yes
23:53:54 <ReinH> Tekmo: :)
23:54:02 <Twey> Category theory is pretty neat
23:54:06 <ReinH> Twey: truly
23:54:15 <Twey> I especially like how it seems to be mostly pictures
23:54:27 <bitemyapp> ReinH: oh pish. I already knew cosums were products.
23:54:29 <ReinH> of simple shapes and arrows
23:54:36 <bitemyapp> ReinH: I was teaching somebody in this channel about it the other week.
23:54:40 <Twey> Yes — it makes it friendly :þ
23:54:53 <ReinH> Twey: I like how category theorists use the term "obvious" ;)
23:55:00 <ReinH> as in "obvious if you are a category theorist"
23:55:11 <Twey> I don't think that's restricted to category theorists :þ
23:55:12 <ReinH> similar to "trivial" but slightly different in a way I quite enjoy
23:56:17 <Twey> ReinH: I mention it because *non*-disjoint sum types are also a thing, and they're weird
23:56:26 <ReinH> Twey: hmm, yes indeed
23:56:37 <bitemyapp> THE PROOF IS TRIVIAL
23:57:01 <Twey> bitemyapp: Proof by induction. ∎
23:57:12 <Tekmo> lol
23:57:16 <ReinH> trivial, adj. 1) known to me
23:57:49 <bitemyapp> tell me you people have read Surely you're joking Mr. Feynman?
23:57:52 <Tekmo> This is why I'm glad that Agda and Homotopy type theory are improving
23:58:00 <Twey> It's great
23:58:05 <ReinH> bitemyapp: ofc
23:58:07 <Twey> … both of those things are great
23:58:16 <bitemyapp> no love for idris? :(
23:58:19 <Tekmo> Hopefully people will begin implementing proofs and getting them mechanically checked
23:58:48 <Tekmo> I've never used Idris so I can't comment
23:58:59 <Tekmo> I'll take your word for it
23:59:18 <ReinH> "There are exactly two types of trye mathematical propositions: trivial ones, and those which have not yet been proven." Feynman
23:59:20 <Twey> Tekmo: Making formalized proofs the norm also allows open-source mathematics, which should hopefully drastically increase the total mathematical output of the human race
23:59:21 <ReinH> ;)
23:59:23 <ReinH> that's what I was referring to
23:59:27 <bitemyapp> Tekmo: oh god, don't. I only use it occasionally to answer queries of the form, "can I do this with dependent types? Oh, right, of course I can. Carry on."
23:59:28 <ReinH> *true
23:59:44 <Tekmo> Twey: Yes!
23:59:50 <bitemyapp> don't take my word on it for anything related to Idris though, I have no idea what I'm doing.
23:59:57 <Tekmo> bitemyapp: Alright :)
