00:11:53 <carter> startling: cool
00:12:58 <startling> carter: thought it might be useful to know, since you seem to be go-to GHC-on-OSX guy
00:13:07 <carter> :)
00:13:14 <carter> i know less than you do :)
00:13:16 <carter> i bet
00:13:18 <carter> i know nothing
00:13:26 <carter> i want to forget this stuff and just play with math
00:14:04 <startling> hehe
00:17:15 <Iloiny_> "Couldn't match expected type `[String]' with actual type `String -> [String]' " but isn't this the same type?
00:17:39 <startling> Iloiny_, no
00:17:52 <startling> Iloiny_: `[String]` is a different type from `String -> [String]`.
00:18:14 <startling> Iloiny_: GHC is saying "you gave me a function when I expected a list of strings"
00:18:24 <Iloiny_> ah
00:40:06 <athan> Hello everybody
00:40:26 <athan> I've got some questions regarding corecursion if anyone is interested
00:41:38 <athan> I see the design of corecursion to be perfect for streams of data. I'd really like to write an audio synthesizer this way
00:41:52 <athan> that could be manipulated through ghci
00:42:26 <athan> my question would be this: How difficult would it be to have the audio expression running, write a new synthesizer, have ghci compile and link it, then switch over to the new expression?
00:42:52 <funfunctor> http://i.imgur.com/P0d7v7z.jpg :)
00:42:54 <athan> Would it be possible if the audio sink simply discarded the lazilly evaluated values?
00:42:56 * hackagebot enclosed-exceptions 1.0.0.1 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.0.1 (jcristovao)
00:45:10 <haasn> funfunctor: hGetContents :(
00:45:22 <haasn> add pipes and I will be happy this valentine's day!
00:45:42 <funfunctor> haasn: yea well I was looking for something for my gf :p
00:45:51 <haasn> pipes.
00:46:04 <funfunctor> hard to come by good valentine functions these days..
00:46:24 <thebnq> they're all impure (:
00:46:37 <bartavelle> heh
00:46:45 <lieven_> haasn: no need to turn this into an adult channel :)
00:55:30 <rawtass> I have a list of a data structure (foo :: [Foo]) with member bar. I could access it by: map bar foo, but is it possible to do without bar, as well in a streaming way like Control.Foldl ?
01:06:33 <Cale> rawtass: map will do it in a streaming way, and I'm not sure what you mean by "without bar"
01:07:07 <startling> hvr, you around? I've got a question about cabal repl in emacs-mode
01:07:16 <startling> er, haskell-mode
01:11:36 <rawtass> Cale: without map I meant..
01:12:37 <dmj`> is it safe to start using 7.8 in production apps
01:13:49 <startling> rawtass: what do you mean "in a streaming way"?
01:14:12 <rawtass> lazy, or not allocating the memory for the whole list
01:14:20 <startling> rawtass: yes, map will do that.
01:14:31 <rawtass> ok
01:15:03 <AshyIsMe> random question, has anyone here  done anything significant with j before?  (the apl language)
01:59:21 <startling> is there a name for foldr (.) id ?
01:59:39 <startling> it turns out I don't really want a generalized sum type.
01:59:44 <startling> I want something more like
01:59:57 <startling> type (Apply []) = Identity
02:00:05 <startling> type (Apply (a
02:00:16 <startling> er
02:00:21 <startling> type (Apply []) a = a
02:00:41 <startling> type (Apply (f ': fs)) a = f (Apply fs a)
02:00:48 <startling> oh, is that Foldr?
02:01:24 <startling> almost but not quite. interesting.
02:03:17 <shachaf> You can call it Foldr (.) Id
02:03:24 <shachaf> Or (:.:) or something.
02:03:26 <startling> haha, true.
02:04:27 <shachaf> Foo [F, G, H] A = F (G (H A))
02:04:37 <startling> yeah.
02:05:15 <shachaf> It's the hidden bonus way to make the category of endofunctors monoidal!
02:06:05 <startling> analogously to Endo, I guess?
02:06:27 <shachaf> Is it?
02:06:40 <startling> I mean, Endo is a monoid on endomorphisms.
02:07:17 <startling> and this is a monoid on endofunctors.
02:07:29 <shachaf> In addition to (:+:),Void and (:*:),() you have (:.:),Id
02:08:04 <shachaf> I guess it's analogous, sure.
02:53:32 <x0l> Hi ! Still trying to optimize http://lpaste.net/99901 (n = 1e6). I'm now doing the computation in constant space but performance hasn't improved much. How can I get ghc to use unboxed types ?
02:54:54 <troydm> x0l: wait, i don't see any boxed types except tuple
02:55:16 <x0l> i hoped ghc would optimize it by himself
02:55:35 <x0l> you mean i should delete all type annotations ?
02:55:36 <troydm> i'm no expert on haskell but usually using newtype means it doesn't do any boxing
02:55:51 <troydm> but idk if u can use newtype in combination with tuples
02:55:59 <troydm> x0l: no no no
02:56:19 <troydm> x0l: type annotations are okey
02:56:37 <x0l> I mean I hoped to see unboxed Int in the Core dump
02:57:35 <troydm> x0l: wait a little bit for expert answer, i'm still learning haskell myself :)
02:57:41 <x0l> :0
02:57:44 <x0l> :)
02:58:34 <x0l> troydm: really nice language, i hope i have the opportunity to use profesionnally one day
02:59:17 <troydm> x0l: yeah indeed, prof i use Java since i'm Java Developer thou
02:59:33 <troydm> x0l: also i'm writing some small compile in Ocaml now
02:59:43 <troydm> *compiler*
02:59:59 <troydm> x0l: but that's just an hobby for this week
03:00:06 <startling> x0l, are you using the optimization flags?
03:00:11 <x0l> -O2
03:00:20 <startling> ok, that's all I've got. :)
03:00:41 <x0l> my code runs 6 times slower than it's 6 counter part, which i believe should not be the case :)
03:00:52 <x0l> * it's C counterpart
03:01:06 <Hafydd> My code runs slower than c.
03:01:12 <troydm> x0l: usual story for haskell
03:01:36 <x0l> for such simple code, i really hoped the compiler could optimize away all types
03:01:53 <troydm> x0l: ocaml has a slight advantage in this regard
03:02:12 <x0l> troydm: what's the type system in ocaml ?
03:03:48 <troydm> x0l: well it's fp language with strict parametric type system (err.. idk i'm no expert)
03:03:57 <troydm> x0l: but your code will be still slower in ocaml
03:04:17 <x0l> i'll try to use Int# direclty and see what happens
03:04:22 <troydm> x0l: since ocaml has an 1 bit overhead on integers for gc purpose
03:05:01 <pjdelport> x0l: the overhead is maybe from the tuples not being optimized away?
03:05:10 <x0l> yeah that's life can have both perf and high level programming
03:05:24 <x0l> pjdelport: neither are the Int actually
03:10:18 <Saizan> is fgl still the standard graph library?
03:18:43 <SLi> Argh, too many command line parser implementations :P I wish there was something like Debian's popcon for hackage to get the idea of popularity of packages. (In fact even seeing how many other hackage packages depend on a given package might help?)
03:18:55 <b__> Is it possible with parsec to say parse anything that is not parser p?
03:19:40 <startling> SLi, optparse-applicative is nice
03:19:58 <SLi> startling: thanks. In fact I had just decided to give it a try :)
03:20:03 <startling> heh
03:21:31 <quicksilver> SLi: http://packdeps.haskellers.com/reverse
03:30:23 <x0l> ok i got ghc to use unboxed typed everywhere http://lpaste.net/99902 , but performance hasn't moved an inch :)
03:33:18 * hackagebot separated 0.0.6 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.6 (TonyMorris)
03:36:18 <startling> x0l, try some {-# INLINE ... #-} pragmas
03:42:30 <x0l> startling: can only inline the collatz function, to no use
03:43:00 <x0l> profiler give     collatzLength Main                    106   132434423   66.3    0.0    98.8    0.0
03:43:00 <x0l>       collatz      Main                    107   131434424   32.5    0.0    32.5    0.0
03:44:32 <startling> x01, no further ideas, sorry
03:53:04 <supki> x0l: replace  div  with  quot  and  even n  with  Data.Bits.testBit n 0
03:53:10 <supki> that should give an improvement
03:53:39 <x0l> thanks
03:55:40 <merijn> hmm, is there any recommended OpenCL library for Haskell?
03:56:58 <x0l> supki: testBit does not work but using quot instead of div really help :) 4.2s -> 2.5s
03:57:07 <supki> x0l: I'd also suggest to store known collatz lengths in a map or something instead of recalculating them every time
03:57:16 <x0l> that's algorithmic
03:57:25 <supki> x0l: how does it not work?
03:57:25 <x0l> i'm just trying to get close to c perf
03:57:37 <supki> oh, you'll need to invert then/else branches
03:57:47 <x0l> oh right :)
03:58:54 <alpounet> merijn: there's an opencl backend for accelerate IIRC
03:59:09 <merijn> alpounet: No, that's not what I want
03:59:21 <x0l> supki: yeah :) with testbits i've got c performance
03:59:25 <merijn> alpounet: I don't want to compile haskell to OpenCL
03:59:30 <supki> :)
03:59:31 <x0l> supki: many thanks
03:59:44 <merijn> alpounet: I just want to run OpenCL code from Haskell
04:00:00 <supki> it's really sad ghc can't figure out these low level optimizations itself
04:00:10 <x0l> supki: definitely :) how did you ?
04:00:39 <alpounet> merijn: the basic FFI of the package i mentionned above is http://hackage.haskell.org/package/OpenCL i believe
04:00:45 <supki> I've done a couple of pe challenges too ;)
04:01:46 <alpounet> err, actually it seems to be this one: http://hackage.haskell.org/package/hopencl
04:01:51 <x0l> supki: though i knew ghc ought to be able to get as fast as C on this
04:03:22 * hackagebot HGamer3D-Data 0.3.0 - Game Engine for the Haskell Programmer - Data Definitions and Utilities  http://hackage.haskell.org/package/HGamer3D-Data-0.3.0 (PeterAlthainz)
04:03:24 * hackagebot HGamer3D-Enet-Binding 0.3.0 - Enet Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.3.0 (PeterAlthainz)
04:03:26 * hackagebot HGamer3D-CEGUI-Binding 0.3.0 - A Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.3.0 (PeterAlthainz)
04:03:28 * hackagebot HGamer3D-Ogre-Binding 0.3.0 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.3.0 (PeterAlthainz)
04:03:30 * hackagebot HGamer3D-SDL2-Binding 0.3.0 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.3.0 (PeterAlthainz)
04:04:17 <merijn> alpounet: Ah, that looks promising
04:06:58 <x0l> supki: well, at least i can replace my pair by standard pair dropping the -funbox-strict-fields and still get the same perf
04:08:32 * hackagebot HGamer3D-SFML-Binding 0.3.0 - SFML Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.3.0 (PeterAlthainz)
04:08:34 * hackagebot HGamer3D-Audio 0.3.0 - Audio Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Audio-0.3.0 (PeterAlthainz)
04:08:36 * hackagebot HGamer3D-Graphics3D 0.3.0 - 3D Graphics Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Graphics3D-0.3.0 (PeterAlthainz)
04:08:38 * hackagebot HGamer3D-GUI 0.3.0 - GUI Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-GUI-0.3.0 (PeterAlthainz)
04:08:40 * hackagebot HGamer3D-InputSystem 0.3.0 - Joystick, Mouse and Keyboard Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-InputSystem-0.3.0 (PeterAlthainz)
04:13:42 * hackagebot HGamer3D-Network 0.3.0 - Networking Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Network-0.3.0 (PeterAlthainz)
04:13:44 * hackagebot HGamer3D-WinEvent 0.3.0 - Windowing and Event Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-WinEvent-0.3.0 (PeterAlthainz)
04:13:46 * hackagebot HGamer3D 0.3.0 - A Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.3.0 (PeterAlthainz)
04:20:05 <Wizek> Good morning.
04:26:53 <merijn> What's the easiest way to install cabal-install from source? (Actually, binary would be okay if those exist)
04:30:07 <startling> merijn: the source has pretty good instructions
04:31:22 <x0l> WTF :) Using -fllvm my haskell code runs consistently faster than my c code
04:31:24 <bergmark> yeah the cabal-install bootstrap works well
04:31:31 <startling> x0l: haha
04:31:49 <x0l> startling: that was unexpected haha
04:32:53 <x0l> and my c code is compiled with clang ... I really don't get it now
04:33:18 <startling> x0l, could you put up the final versions of the C and haskell code?
04:33:25 <x0l> sure
04:33:26 * hackagebot HGamer3D 0.3.1 - A Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.3.1 (PeterAlthainz)
04:34:34 <SLi> Is it possible to specify using optparse-applicative that there must be (exactly) one of --foo/--bar/--baz on the command line? I'm looking into the "command" thing, but then I don't need any kind of subparser.
04:35:07 <x0l> Haskell http://lpaste.net/99904  / C http://lpaste.net/99905
04:35:29 <x0l> compiled with -O2 -fllvm and clang -O3
04:35:50 <x0l> using llvm 3.4
04:37:15 <startling> x0l, using longs in C might be a little unfair. I'm not totally sure though.
04:37:27 <supki> SLi: asum?
04:37:35 <startling> ghc might be better at loop unrolling?
04:37:49 <x0l> startling: with int it blows off
04:38:00 <supki> SLi: e.g.  asum [ strOption (long 'foo'), strOption (long 'bar'), ... ]
04:38:00 <x0l> maybe uint
04:38:00 <startling> x0l: but it doesn't in Haskell? that's odd.
04:38:23 <x0l> kinda yeah
04:38:44 <startling> I'd suspect a bug.
04:39:15 <supki> s/'/"/g
04:39:19 <SLi> supki: hmm, thanks, looking into that.
04:40:10 <x0l> with unsigned int things are going better for c :)
04:40:13 <startling> asum is just foldr (<|>) empty
04:40:22 <startling> i.e., that code is foo <|> bar <|> baz
04:40:28 <SLi> Ah.
04:40:32 <startling> which isn't exactly "only one of those flags"
04:40:50 <startling> can you do not-flags?
04:41:18 <SLi> You mean do I need to support flags like --no-something on the command line? No.
04:42:01 <supki> startling: how is it different?
04:42:33 <startling> supki, if --foo and --bar are passed the foo case happens.
04:42:39 <startling> SLi: no, that's not what I mean.
04:43:25 <SLi> So basically what I would like is to define something like data Operation = Op1 | Op2 | Op3 and then write a oper :: Parse Operation which succeeds iff exactly one of --op1, --op2, --op3 has been passed and in that case returns the corresponding Operation.
04:44:12 <startling> I'm not sure that operation can be done with Applicative.
04:44:45 <SLi> Ok... Maybe I need to just gather the list of --opN passed and handle the fail case outside of the parser then.
04:45:17 <startling> yeah, I think that's the way to do it
04:45:24 <SLi> Ok, thank you :)
04:45:49 <startling> i.e. to have the parser fail, you'd need to choose an applicative action (empty) based on the result of another applicative action
04:45:54 <startling> that's (>>=).
04:46:34 <SLi> Right.
04:46:54 <x0l> startling: using Word in haskell and unsigned int everywhere in C, performance are nearly identical (best timings is only a few ms better for c)
04:46:57 <x0l> all is well :)
04:47:04 <startling> x0l: haha
04:47:18 <startling> x0l: good to know re: -fllvm, though!
04:47:19 <x0l> but using -fllvm is a huge boost
04:47:37 <merijn> x0l: signed int is usually optimised better by C compilers
04:47:38 <x0l> 0.68s -> 0.47s
04:47:58 <startling> merijn: x0l claims that a signed int overflows
04:48:02 <merijn> x0l: The LLVM backend is really good at doing low level numerical optimisation
04:48:12 <startling> I'm not sure I believe them though.
04:48:20 <x0l> it does :)
04:48:21 <merijn> startling: Well, that's usually why signed int is faster in C
04:48:44 <startling> x0l, but Int didn't overflow in the Haskell code? that makes no sense.
04:48:47 <merijn> startling: signed int overflow is undefined behaviour, which allows the compiler to optimise away cases
04:49:03 <x0l> startling: yeah i'm a bit puzzled too by this
04:49:12 <merijn> startling: If he's using 64bit haskell Int might very well be 64 bit
04:49:27 <merijn> Whereas for some C compilers int on 64bit is still 32bit
04:49:29 <startling> merijn: sure. I was just explaining why x0l switched to unsigned ints
04:49:33 <startling> merijn: oh, good point
04:50:37 <x0l> how do i check Int lenght in haskell ?
04:51:21 <startling> maxBound :: Int will tell you indirectly
04:51:25 <x0l> thanks
04:51:51 <x0l> up 64 bits
04:52:04 <x0l> so i'll compare with longs in C
04:54:09 <x0l> Well haskell performs better with Ints than C with longs :) haha
04:54:54 <startling> x0l, well, what's sizeof int in your C code?
04:55:08 <x0l> 32 i guess since it blows off
04:55:52 <startling> x0l, did you check?
04:55:59 <x0l> just did
04:56:09 <merijn> hmm
04:56:19 <merijn> Running "cabal update" produces: "cabal: fromFlag NoFlag. Use fromFlagOrDefault"
04:56:50 <dcoutts> merijn: probably some unexpected thing in the ~/.cabal/config
04:57:10 <dcoutts> merijn: that's an internal error from the command line / config file system
04:57:24 <dcoutts> in theory should never happen of course
04:57:24 <x0l> if i had the will, i would compare output llvm code
04:58:31 <merijn> dcoutts: Running bootstrap.sh didn't produce a config file so I copied the one from my OSX machine, must have bollocks something :\
04:58:40 <merijn> dcoutts: How do I get a "clean" config?
04:58:45 <dcoutts> merijn: delete it
04:58:46 <startling> x0l: hm. try int64_t from stdint.h?
04:58:57 <dcoutts> merijn: it'll generate one as soon as you do anything that needs one
04:59:39 <dcoutts> merijn: generating a config on install is impossible in general, so we don't do it that way
04:59:55 <merijn> dcoutts: I'm guessing the bootstrap script also doesn't install profiled versions of the dependencies it builds?
05:00:19 <dcoutts> merijn: right, it just does enough to give you the binary
05:00:22 <x0l> startling: does not change anything
05:00:24 <merijn> blah
05:00:35 <dcoutts> merijn: really it ought to use a local db and not install anything at all
05:00:47 <startling> x0l: weiiird
05:00:50 <startling> ok, going to sleep.
05:00:54 <startling> x0l: good luck!
05:01:00 <x0l> thanks for your help ! gn
05:01:50 <merijn> dcoutts: What's the best way to added profiling version of all the dependcies it installed? just "cabal install --reinstall" after I set "library-profiling: True"?
05:02:17 <dcoutts> merijn: unregister the things it installed, and then yes use library-profiling: True
05:02:46 <dcoutts> merijn: or reinstall the things it installed
05:03:16 <merijn> dcoutts: ok, thanks
05:11:53 <x0l> ok found the difference in C, llvm does not optimize % 2 into & 1
05:16:11 <x0l> glad to know haskell can perform as well bare c :)
05:28:59 <anshbansal> What simple practice can be done by Haskell beginner?
05:29:05 <merijn> @where exercises
05:29:06 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
05:32:44 <x0l> anshbansal: NICTA course on github
05:41:20 <anshbansal> Hi. I am new on freenode. Been trying to learn Haskell and FP for some time in spare time. Any suggestions on practice?
05:42:06 <pvt_petey> in a pattern such as this : http://pastebin.com/DBxELcHH for f (n+2) a0 a1 = f (n+1) (a0+a1) a0
05:42:08 <pvt_petey>  how can I print out the values of a0 and a1 each time it's recursively executed >
05:42:10 <pvt_petey> ?
05:42:44 <x0l> pvt_petey: http://hackage.haskell.org/package/base-4.6.0.1/docs/Debug-Trace.html maybe
05:43:54 <Apocalisp> Any experience with Data.Configurator? Does it give decent error messages?
05:50:01 <pvt_petey> hmm
05:50:09 <pvt_petey> x01 it doesn't seem to like the syntax
05:50:15 <pvt_petey> x0l
05:52:01 <x0l> pvt_petey: what is it complaining about ?
05:52:17 <jophish_> anshbansal: Learn you a Haskell and Real World Haskell seem to get good reviews
05:53:05 <pvt_petey> this yields a syntax error http://pastebin.com/RP09g5T5
05:53:14 <pvt_petey> unexpected symbol "$")
05:53:31 <pvt_petey> not really sure where to use it within a pattern
05:53:44 <edsko> any happstack experts here? under which circumstances does implSite_ not return a value?
05:54:47 <anshbansal> jsphish I am currently going through Learn You a Haskell. The problem is practice. I got the minimum comfort in python by practicing. In Haskell I just am not getting comfort due to lack of practice
05:55:37 <x0l> pvt_petey: try http://lpaste.net/99919
05:56:27 <pvt_petey> Undefined variable "traceShow"
05:58:50 <Tehnix> Is there any documentation or information regarding the talk about how iOS support in GHC 7.8?
06:00:22 <jophish_> anshbansal: Is there a particular project you'd like to do with Haskell?
06:00:56 <jophish_> There's probably something like Project Euler
06:01:13 <jophish_> a little more targeted at functional languages
06:01:20 <x0l> pvt_petey: http://lpaste.net/99919
06:01:30 <pvt_petey> just worked it out :)
06:01:37 <pvt_petey> thx x0l
06:01:38 <pvt_petey> :)
06:01:43 <x0l> yw
06:02:10 <anshbansal> jophish In Python I did around 50. https://github.com/anshbansal/general   In Haskell I am always thinking if the way is correct.
06:03:53 <anshbansal> jjophish_: Is project euler easier using functional languages?
06:05:11 <jophish> anshbansal: I think everything's easier in Haskell
06:05:22 <Dtgr> jophish: :D
06:05:25 <Dtgr> i disagree
06:05:39 <jophish> for some definition of easier
06:06:02 <anshbansal> jophish: so its a matter of practice??
06:06:16 <jophish> anshbansal: most things are
06:06:45 <jophish> anshbansal: if you've already done lots of project euler in python doing it in Haskell should be excellent practice
06:07:13 <supki> @quote everything.is.hard
06:07:13 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in haskell ;) <kmc> that's a pretty good summary
06:07:24 <Tehnix> anshbansal: If you're looking for project ideas, you could dive straight into building toying with making an IRC bot (http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot), or make a website using something like Yesod or Snap
06:07:36 <Tehnix> s/building//
06:08:18 <anshbansal> jophish: Most things are but.. I just don't know
06:08:27 <anshbansal> Tehnix: That's a good suggestion
06:08:52 <Tehnix> For yesod there's http://yannesposito.com/Scratch/fr/blog/Yesod-tutorial-for-newbies/ or Snap http://snapframework.com/docs/tutorials/snap-api .. my personal favourite is Yesod, but you should look at both :)
06:10:13 <Kinnison> .win 20
06:13:02 <merijn> jophish, anshbansal: I think Project Euler is actually terrible practice for beginners
06:13:13 <jophish> I've heard you say that before
06:13:15 <merijn> It focus on codegolfing, complex arithmetic, etc.
06:13:40 <jophish> but if one already has the solutions in another language
06:13:44 <merijn> It doesn't help you practice what "real" haskell programs look like and forces you to work in corners that are counterintuitive to beginners (i.e. the need for fromIntegral, etc.)
06:14:19 <anshbansal|2> I lost internet for a few minutes.
06:14:33 <merijn> I believe the exercises links are more productive practice and for someone that's already familiar with programming I usually recommend things like multi-threaded servers to show how much simpler they are than in other languages
06:15:00 <anshbansal|2> And now my name is coming with a 2 :D
06:15:02 <merijn> Haskell's strong suits are high-level coding and concurrency, so I believe it's more interesting to start playing in areas where haskell is strong
06:15:06 <callumacrae> 1.2GB 0_o
06:15:29 <merijn> callumacrae: ?
06:15:54 <callumacrae> Haskell for OS X is 1.2GB, seems huge
06:16:33 <Tehnix> callumacrae: Haskell Platform?
06:16:43 <merijn> callumacrae: That includes GHC and 52 libraries in both binary *and* profiled binary format
06:16:49 <callumacrae> Ah, fair enough
06:17:04 <merijn> Possible it also includes static *and* dynamic variants
06:17:20 <merijn> callumacrae: See also things like: https://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
06:22:19 <akegalj_> i am going to try ghcjs... has anyone tryed it. How big output is if minified for "hello world" program?
06:23:38 * hackagebot morfette 0.3.6 - A tool for supervised learning of morphology  http://hackage.haskell.org/package/morfette-0.3.6 (GrzegorzChrupala)
06:25:33 <notdan> akegalj_: it's pretty big as of now
06:25:50 <notdan> IIRC the output size for non-concurrent programs can be reduced
06:27:51 <akegalj_> notdan: for non-concurrent programs is it order of MB or Kb ?
06:28:11 <luite> about a megabyte unminified i think
06:28:17 <luite> oh, that's concurrenty
06:29:18 <akegalj_> luite: thnx :)
06:29:22 <notdan> luite: did you manage to hack on the non-concurrent runtime?
06:29:53 <zq> happy valentine's day haskell
06:30:10 <luite> notdan: no it's still way out of date, i didn't get much done this week unfortunately.
06:31:28 <notdan> ugh I really should build the VM
06:31:32 <luite> notdan: also with some small changes, concurrent runtime output can be reduced a lot (in particular some standard rts things, like all the partial application thunks), haven't really done too much about that since it's all static code (the same for every program), and gzips to ~40kB or so
06:31:42 <notdan> is the prebuilt vm out of date?
06:31:46 <luite> yeah a lot
06:31:54 <notdan> k
06:32:13 <luite> i pushed some updates last week to mak everything build with ghc 7.8 rc, i should rebuild the prebuilt from those
06:32:46 <luite> notdan: other than an updated jmacro you should be able to build everything without special tooling now
06:34:16 <notdan> сщщд
06:34:19 <notdan> cool
06:44:42 <rawtass> I am lookin at an example https://github.com/kolmodin/binary/pull/41/files where the author uses BL.chunk (from bytestream lazy), but that does not exist. Any ideas how I can change this example?
06:51:23 <hpc> i have a lambdabot-ish implementors question
06:51:39 <hpc> someone on another channel wants me to add ghci's :sprint to my bot
06:52:39 <hpc> for the unaware, let x = [1,2,3]; :sprint x; sum x; :sprint x -- shows how var x is evaluated, with thunks represented by _
06:52:57 <hpc> my thinking is that the syntax would be something like
06:53:12 <hpc> :sprint (x = [1,2,3]) (sum x)
06:53:29 <hpc> and then in ghci it would run
06:53:41 <hpc> let x = [1,2,3]; show (sum x); :sprint x
06:54:04 <hpc> the show would shield against IO nefariousness
06:54:17 <hpc> and there are already perl modules to deal with killing processes after a timeout
06:54:23 <hpc> are there any problems here?
06:57:43 <keep_learning> Hello all
06:57:50 <keep_learning> Could some one please tell me
06:58:19 <keep_learning> why this code is showing conflicting definitions error http://lpaste.net/99923
06:58:39 <dhrosa> keep_learning: because the fmap function already exists
06:58:50 <dhrosa> as part of the Functor typeclas
06:59:12 <dhrosa> rename it to something else, like fmap', or  maybe you can import Prelude hiding (fmap)
06:59:19 <dhrosa> oy myfmap
06:59:53 <supki> keep_learning: you can't bind two values to  a  in pattern match
07:00:21 <dhrosa> oops I didn't even look at the error
07:00:34 <supki> line 20 should be e.g.  fmap f (Pair a b) = Pair (f a) (f b)
07:00:38 <keep_learning> supki: Oh Now I see
07:00:41 <jophish> Why do fixities use Integers instead of fractional values?
07:00:43 <keep_learning> supki: Thank you
07:01:39 <harasskell> @pl mean xs = sum xs / length xs
07:01:40 <lambdabot> mean = liftM2 (/) sum length
07:01:46 <hpc> jophish: it's easier to implement and you shouldn't ever need the extra power anyway
07:01:54 <hpc> reading complex infix expressions is hard enough already ;)
07:02:26 <x0l> any good reason why a monad is not a functor ?
07:02:41 <merijn> x0l: Hysterical raisins
07:02:43 <hpc> x0l: no; only bad reasons
07:02:45 <merijn> x0l: Will be fixed in 7.10
07:02:49 <merijn> @where amp
07:02:50 <lambdabot> I know nothing about amp.
07:02:52 <merijn> aww
07:03:08 <x0l> how could this happened in the first place ?
07:03:12 <merijn> x0l: See: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
07:03:22 <hpc> x0l: Monad predates Functor
07:03:38 <merijn> x0l: Pretty sure it doesn't?
07:03:46 <merijn> x0l: Monad predates Applicative
07:03:49 <merijn> eh
07:03:52 <merijn> s/x0l/hpc
07:04:02 <hpc> oh, well it's before my time
07:04:16 <hpc> that would make more sense then
07:04:19 <merijn> x0l: The reasoning was thus: Making library authors implement a Functor instance if they've already implemented a Monad instance is annoying, let's not require that
07:04:24 <merijn> hpc: See above
07:04:52 <merijn> x0l: Only later did people realise that the effort of implementing Functor is nothing, compared to the annoyance of not being able to mix monad and functor syntax
07:05:16 <merijn> x0l: Then it stayed like this for a couple of years for backwards compatibilit and social inertia reasons
07:05:19 <hpc> if they made Monad use join and applied the whole hierarchy of classes, it'd be a piece of cake to implement
07:05:38 <merijn> Last year someone started a fresh campaign to make Applicative (and thus Functor) a superclass of Monad
07:05:46 <hpc> instance Functor M where fmap = ...; instance Applicative M where pure = ...; (<*>) = ...; instance Monad m where join = ...
07:05:58 <x0l> merjin: well odd given that's a comittee designed lang
07:06:03 <merijn> x0l: That proposal was accepted and 7.8 will generate warnings for missing instances
07:06:29 <merijn> x0l: 7.10 the actualy change of requiring Applicative for Monad will be made and then all will be well with the universe
07:06:36 <hpc> also, it's possible to derive Functor iirc?
07:06:40 <x0l> :)
07:07:06 <merijn> hpc: Yes
07:07:15 <merijn> With {-# LANGUAGE DeriveFunctor #-}
07:08:07 <harasskell> @pl mean b xs = foldl (+) 0 (map (^b) xs) / ((length xs) ^ b)
07:08:08 <lambdabot> mean = ap (ap . (((/) . foldl (+) 0) .) . map . flip (^)) (flip ((^) . length))
07:08:56 <hpc> merijn: any thoughts on my :sprint implementation above?
07:08:57 <dhrosa> I like then the pf is longer than the original
07:09:08 <hpc> (before it gets lost in scrollback and i have to ask again)
07:09:51 <joneshf-laptop> question about rose trees and comonads
07:10:05 <joneshf-laptop> i haven't looked at the default impl in the comonad package
07:10:59 <joneshf-laptop> so when you cojoin, do you take the entire tree, and shove it in the "node" part, then for each of the subtrees of the original tree make them trees themselves in the "branches" part?
07:11:59 <joneshf-laptop> or just take the subtrees of the original and leave them as they are in the "branches" part?
07:12:04 <harasskell> @pl derivative f x = limit (\h -> (f (x+h) - f x) / h) 0
07:12:05 <lambdabot> derivative = flip flip 0 . (limit .) . flip flip id . (liftM2 (/) .) . (ap =<< ((flip . ((-) .)) .) . (. (+)) . (.))
07:13:45 <harasskell> @type flip flip 0
07:13:48 <lambdabot> Num b => (a -> b -> c) -> a -> c
07:14:47 <ilmig> hi, I got stuck with one function of the NICTA course: https://github.com/NICTA/course/
07:15:05 <ilmig> it is an implementation of filter, which uses a predicate which returns an applicative functor
07:15:08 <ilmig> filtering :: Applicative f => (a -> f Bool) -> List a -> f (List a)
07:15:35 <harasskell> Can Haskell do symbolic mathematics?
07:15:38 <ilmig> I just can't wrap my head around this, so I would aprreciate any tips
07:17:09 <x0l> ilmig: http://lpaste.net/99926
07:17:51 <ilmig> x0l: thanks!
07:18:08 <ilmig> wow, that was easy (as it always is)...
07:18:18 <x0l> ilmig: :) it hurt my head a bit though
07:18:21 <ilmig> my brain is still too much damaged by imperative thinking :(
07:19:49 * hodapp patpats ilmig
07:19:52 <ilmig> interestingly I had a few ideas which where going into the right direction, but I just couldn't put it all together...
07:19:54 <hpc> ilmig: just give it some time and eventually it will be damaged by functional thinking
07:20:02 <harasskell> @pl filter f (x:xs) = if f x then x : filter f xs else filter f xs
07:20:03 <lambdabot> filter = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . (ap =<< ((flip . (ap .)) .) . liftM2 ap (((.) . if') .) . (flip ((.) . (:)) .)))
07:20:13 <hodapp> harasskell: well, pretty much any language can, at some level
07:20:45 <harasskell> @pl \a b -> (a,b)
07:20:46 <lambdabot> (,)
07:20:58 <harasskell> > (,2,) 1 3
07:21:01 <lambdabot>  (1,2,3)
07:21:02 <hpc> harasskell: lambdabot works in a PM
07:22:15 <x0l> ilmig: it's fun to have to think *before* writing any code :)
07:22:21 <harasskell> @pl iterate f x = x : iterate f (f x)
07:22:21 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
07:23:05 <x0l> haraskell is a bot designed to harass the lambdabot :)
07:23:37 <harasskell> > fix ((ap (:) .) . ((.) =<<)) ((*2).(-2)) 3
07:23:41 <lambdabot>  No instance for (GHC.Show.Show c0)
07:23:41 <lambdabot>    arising from a use of `M41331838786169002686151.show_M41331838786169002686...
07:23:41 <lambdabot>  The type variable `c0' is ambiguous
07:23:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:23:41 <lambdabot>  Note: there are several potential instances:
07:23:57 <harasskell> @type fix ((ap (:) .) . ((.) =<<))
07:23:59 <lambdabot> (a -> a) -> a -> [a]
07:24:29 <harasskell> @type let fix f = f . fix $ f in fix
07:24:30 <lambdabot> (b -> b) -> b
07:25:01 <harasskell> @pl \fix f -> f (fix f)
07:25:02 <lambdabot> ap id
07:25:22 <harasskell> @unpl fix (ap id)
07:25:22 <lambdabot> fix (\ f e -> (f >>= \ b -> return ((\ a -> a) e b)) e)
07:25:38 <harasskell> @type fix (ap id)
07:25:40 <lambdabot> (a -> a) -> a
07:25:53 <harasskell> >fix (ap id) (1:)
07:26:18 <novochar> Hi, how would you typicall resolve this issue? https://gist.github.com/novodinia/1a5bd866e052e9782c6b/raw/bc1c71e16aacbd0d89765ecd3f74699435c02cc5/gistfile1.txt
07:26:18 <harasskell> > fix (ap id) (1:)
07:26:20 <ilmig> x0l: yeah, I agree. Although I was hoping that programming haskell wouldn't require that much effort and hard thinking once one gets used to it...
07:26:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:26:26 <ilmig> does it ever get easier?
07:26:55 <ilmig> I like thinking, but sometimes it's nice to just write a few hundred lines of python without too much effort...
07:27:00 <x0l> eventually one develops some intuition about this, it's like math
07:27:18 <harasskell> @pl fix f = let x = f x in x
07:27:18 <lambdabot> fix = fix id
07:27:33 <simpson> ilmig: Ideally, programming should always be effort; you shouldn't have to write things that are trivial.
07:27:38 <x0l> depends on what you'e trying to achieve :) i like the confidence haskell gives me... if i can compile, it's already mostly correct
07:28:05 <harasskell> What are arrows
07:28:24 <supki> novochar: relax bounds on base in distributed-process-demos.cabal and retry
07:28:48 <supki> novochar: hopefully, that would just fix the build, otherwise, figure out how to fix the errors
07:30:23 <m1185> whois m1185
07:33:50 <novochar> supki: How do you relax bounds? Change `base == 4.5.*` to `4.*.*`?
07:34:33 <supki> novochar: you can safely delete "== 4.5.*"
07:36:33 <supki> if it wasn't base, I'd change it to  base >= 4.5
07:42:13 <pdpi> /join #Ghost
07:42:25 <pdpi> eh
07:42:51 <novochar> supki: https://gist.github.com/novodinia/7de6501a082942bba72d/raw/d97d8a6e5a00b544448b85d4906c1ba0630c8eb4/gistfile1.txt
07:43:04 <novochar> That was after changing it to >= 4.5
07:43:31 <supki> uhm, that does not look right
07:43:35 <novochar> supki: https://gist.github.com/novodinia/d0bf66985a017313ee28/raw/d97d8a6e5a00b544448b85d4906c1ba0630c8eb4/gistfile1.txt
07:43:48 <novochar> That is after removing the base dependency
07:44:24 <supki> novochar: what command do you run?
07:44:44 <novochar> supki: cabal install
07:45:41 <supki> novochar: just  cabal install?
07:45:47 <novochar> yes
07:45:57 <byorgey> novochar: please paste your complete .cabal file
07:46:05 <byorgey> those error messages look like nothing has been changed.
07:46:42 <novochar> https://gist.github.com/novodinia/86fea90a30f9563e2954/raw/fb99581fd504fbc5c0c727827e72978959be539c/distributed-process-demos.cabal
07:47:15 <byorgey> novochar: note there are many places in that file with  base ==4.5.*
07:47:18 <byorgey> you have to change all of them
07:47:29 <novochar> Oh!
07:48:35 <novochar> cabal install now yields this:
07:48:35 <novochar> cabal: distributed-process-demos.cabal:4: Construct not supported at this
07:48:36 <novochar> position: F 4 "name" "distributed-process-demos"
07:48:50 <bennofs> when an async exception is thrown in the middle of a writeIORef, will the IORef still be in a consistent state? (Containing the value of either the old or the new value)
07:49:53 <byorgey> novochar: uh, that is very strange.  Perhaps you accidentally added some stray characters to the beginning of the file?
07:50:06 <byorgey> or some spaces or tabs?
07:50:17 <byorgey> also, what is the output of 'cabal --version'?
07:50:56 <novochar> Changing them all to >= 4.5 allows the dependency fetching to take place
07:51:03 <novochar> Thank you supki and byorgey for your patience
07:51:37 <PatientZero> Hi guys
07:51:38 <novochar> cabal-install version 1.16.0.2
07:51:45 <PatientZero> Code review question here
07:51:46 <PatientZero> http://lpaste.net/99938
07:51:56 <PatientZero> is some Haskell code I wrote to do some linear interpolation
07:52:14 <PatientZero> but it seems that there clearer and/or more elegant way to do this
07:52:31 <PatientZero> there ought to be a clearer and more elegant way
07:53:34 <PatientZero> The function takes a list of x,y pairs and, for any x value, gives you the y value by linearly interpolating the appropriate point
07:53:44 <PatientZero> needs to linearly extrapolate if it's outside the range of the specified points
07:55:01 <PatientZero> I'd also like it to not be explicitly recursive if possible - can it be re-written as some sort of fold?
07:56:33 <joneshf-laptop> PatientZero, you could use guards i guess?
07:56:55 <joneshf-laptop> PatientZero, in particular, which part do you not think is clean?
07:57:33 <PatientZero> jonesh - the pattern matching bit makes my head hurt, for one thing
07:57:43 <Yuu-chan_> PatientZero: when I need to do bitwise operations of list elements, I usually use zipWith list (tail list)
07:57:53 <PatientZero> but also I don't like the explicit recursion
07:57:59 <Yuu-chan_> *zipWith op list (tail list)
07:58:00 <PatientZero> Yuu-chan ahah that is an interesting idea
07:59:03 <Yuu-chan_> > let diffs l = zipWith (-) (tail l) l in diffs $ map (^2) [1 .. 7]
07:59:07 <lambdabot>  [3,5,7,9,11,13]
07:59:55 <PatientZero> Yuu-chan_ that's a great idea! that will help a lot
08:00:10 <Yuu-chan_> It loses the first or the last element, but you can add it explicitly or add a fake neutral element to the initial list
08:00:12 <eacameron> what backend wiki software dose the haskellwiki use?
08:00:23 <quicksilver> mediawiki I believe eacameron
08:00:46 <eacameron> quicksilver: ah, ok. it's a wonder it's not written in haskell ;)
08:00:46 <Yuu-chan_> PatientZero: I hope it will help :)
08:00:51 <joneshf-laptop> PatientZero, hmm, are you missing a case in there?
08:01:13 <quicksilver> eacameron: well the haskell wiki has been around for very many years and there are not such mature haskell-based wiki frameworks
08:01:26 <joneshf-laptop> PatientZero, ah, i guess not so long as you have at least two elements
08:02:06 <eacameron> quicksilver: yeah, I guess it's a technology that does have tons of room for growth; although semantic-media wiki could really go places
08:02:23 <eacameron> quicksilver: does *not* have
08:02:38 <x77686d> I know that the function passed to filter et al. is called a predicate.  Is there a similar name for the function passed to the folding functions?
08:03:13 <byorgey> x77686d: not really
08:03:32 <eacameron> x77686d: good question, the fold operator??
08:04:18 <quicksilver> x77686d: it is sometimes called the accumulator
08:04:29 <eacameron> quicksilver: ahh yeah, I've heard that before
08:04:47 <quicksilver> although that name is also given to the value which is accumulated
08:04:55 <quicksilver> :t foldr
08:05:00 <lambdabot> (a -> b -> b) -> b -> [a] -> b
08:05:06 <quicksilver> the 'b' in that type sig
08:05:12 <pranz> :t F.foldr
08:05:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:05:21 <quicksilver> I din't think there is a commonly used name
08:08:41 <x77686d> All: Thanks for those comments!
08:18:50 <hakujin> currently in cabal hell on win32 after trying to install new versions of bytestring & text
08:19:26 <hakujin> effectively breaks bloody everything, with parts like time and network failing to reinstall due to ./configure scripts and incompatibility with win32
08:19:32 <monochrom> yes, possessing multiple versions is a recipe for hell
08:19:48 <monochrom> and overriding what comes with GHC is another
08:20:18 <hakujin> monochrom: what is the correct strategy here? I'd like to use the new versions of bytestring & text with attoparsec for example
08:20:32 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon . in fact, read the whole thing
08:20:55 <geekosaur> hakujin, bytestring being a library that comes with ghc, the right strategy is to upgrade ghc :/
08:21:25 <hakujin> monochrom: I am that cat
08:27:57 <Eduard_Munteanu> Is there a TaggedT (monad transformer version of Tagged)?
08:31:39 <nf7> My Emacs isn't syntax highlighting .hs source files, is that just me or is Haskell syntax not built in to Emacs!?
08:32:33 <mirpa> nf7: do you have haskell mode installed?
08:32:35 <ocfx> you have to install haskell-mode package
08:32:52 <geekosaur> most emacs does not come with it preinstalled, there may be an OS package for it
08:33:13 <geekosaur> or see http://marmalade-repo.org/packages/haskell-mode
08:37:43 <nf7> mirpa: I tried to install Haskell mode through Debian's package manager and I couldn't get it working, but I just did it through Emacs own package manager, don't know why I didn't just do that in the first place!
08:38:20 <nf7> "/alias hidelevels.set set activity_hide_level parts joins quits nicks modes"
08:38:24 <nf7> sorry
08:41:10 <mirpa> nf7: try this http://lpaste.net/99939
08:41:58 <Forgetaboutit> johnw: Remember my issue from yesterday where you suggested using a proxy?  I finally solved it :)  http://lpaste.net/99940
08:43:27 <nf7> mirpa: It's alright, I figured it out. Thanks for the help
08:44:27 <mirpa> nf7: http://haskell.github.io/haskell-mode/manual/latest/
08:44:45 <Forgetaboutit> johnw: And thanks again for the help!  You made me dig into the right hole.
08:45:17 <adelbertc> if i want to read the Haskell report, should i just read 2010 or read 1998 as well
08:45:34 <quchen> 2010
08:45:50 <quchen> There aren't many differences anyway though
08:47:02 <adelbertc> quchen - cool, cheers
08:48:25 <johnw> Forgetaboutit: nice; yeah, that's essentially how you "pass in a type"
08:49:18 <bennofs> when an async exception is thrown in the middle of a writeIORef, will the IORef still be in a consistent state? (Containing the value of either the old or the new value)
08:49:23 <Forgetaboutit> johnw: As far as I understand, a proxy does the same thing as `undefined :: Something`, doesn't it?
08:49:29 <johnw> yep
08:49:35 <johnw> Proxy :: Proxy Something
08:49:44 <johnw> and gives you some helper functions
08:50:27 <monochrom> yes bennofs
08:50:33 <Forgetaboutit> johnw: that's really nifty.  I'll try to understand its source.
08:50:37 <bennofs> monochrom: ok, thanks
08:50:41 <supki> proxy does the same thing as undefined except it does not explode in runtime
08:51:18 <quchen> And you can safely unsafeCoerce it :-)
08:51:23 <Forgetaboutit> supki: Why should `undefined` blow up if I never evaluate it?
08:51:46 <quchen> Forgetaboutit: You can evaluate that undefined value. You cannot evaluate the thing of the phantom type in a Proxy.
08:52:31 <Forgetaboutit> quchen: Interesting, how does it 'do' that?
08:53:46 <quchen> There's no way of getting the "a" out of a "Proxy a". Values of type "Proxy a" aren't bottom, but still have the generic "a" type attached to it; contrary to that, "undefined" has a generic "a" type, but the value of undefined is ⊥.
08:55:00 <quchen> Evaluating a Proxy value is similar to evaluating a Just value. Nothing can crash.
08:55:33 <Forgetaboutit> quchen: *mind blown*
08:56:01 <quchen> Note that Proxy is like Maybe without a Just constructor
08:57:46 <quchen> Anyway, whenever you think "hm, here a `undefined :: MyType` would be useful", then a Proxy/Tagged might be what you're looking for.
08:59:00 <Forgetaboutit> Ok, that's cool.  And I would use it like `(Proxy :: Proxy Foo)`, if I understand it correctly.
08:59:27 <quchen> Yes.
09:02:52 <supki> Forgetaboutit: you can go even further and take ... :: p e -> ... as input instead of ... :: Proxy e -> ... That way I can call you function with  Proxy :: Proxy Foo  or even  Nothing :: Maybe Foo if I don't like to depend on Proxy
09:04:24 <johnw> supki: neat, I hadn't thought of that
09:04:44 <quchen> ^ that's why some functions in tagged have weird types like "proxy s -> Proxy t" (sic)
09:09:22 <Forgetaboutit> supki: so I just have to replace `e` with `p e` and that's it?
09:09:41 <johnw> yep
09:09:46 <johnw> or "proxy e", or whatever you want to call 'p'
09:11:57 <PatientZero> http://lpaste.net/99942
09:12:03 <PatientZero> Yuu-chan here is my latest attempt
09:12:15 <PatientZero> now at least there is no explicit recursion
09:12:39 <PatientZero> I'm not sure if it cannot still be improved...
09:12:56 <Forgetaboutit> supki: interesting, that's even cooler.
09:17:36 <quchen> PatientZero: Using head/tail is usually not a good idea, unless you can prove they are never called on an empty list.
09:17:46 <PatientZero> Thanks quchen
09:17:55 <PatientZero> although in this case the list should always have 2 elements
09:19:08 <PatientZero> That is, ps should always have 2 elements, and so zipped should always have at least one element
09:19:15 <PatientZero> because it's an interpolator after all
09:19:35 <PatientZero> it needs two points so as to know how to extrapolate
09:19:52 <quchen> `zip ps (tail ps)` is safe. But the filter can create an empty list out of it, and then the head call fails in the next line.
09:20:08 <quchen> Oh wait, nevermind.
09:20:20 <quchen> Okay, your use of head/tail is safe but not pretty ;-)
09:20:34 <quchen> Alternative version at the bottom: http://lpaste.net/99942
09:21:07 <quchen> Not sure what to return in the Nothing case. Probably a default value would be better.
09:21:15 <quchen> (It's if your value is out of interpolation range.)
09:22:06 <quchen> The (>= x) check should be refined a bit anyway, because that only ensures that you're not running off your dataset on one end.
09:22:55 <quchen> Also I didn't test the code or think much about it, it's getting buggier the more I look at it ;-) But Haskell-wise this would be one way of avoiding the head/tail stuff.
09:26:23 <pvt_petey> hello
09:26:38 <pvt_petey> I can't seem to wrap my head around the haskel implementation of a BST (http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures)
09:26:53 <pvt_petey> how exactly is left and right declared and defined ?
09:27:12 <Iceland_jack>     data Either a b = Left a | Right b
09:27:16 <Eduard_Munteanu> pvt_petey: what do you mean "BST"?
09:27:28 <pvt_petey> binary sort tree
09:27:31 <Iceland_jack> Probably means the tree
09:28:06 <Iceland_jack> pvt_petey: data Tree a = EmptyTree | Node a (Tree a) (Tree a)
09:28:23 <joelteon> @src Either
09:28:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:28:29 <Iceland_jack> This says that a tree is either
09:28:29 <Iceland_jack>     empty
09:28:29 <Iceland_jack> or
09:28:29 <Iceland_jack>     a node eith two subtrees
09:28:30 <PatientZero> Thanks quchen - will take a look
09:28:32 <Iceland_jack> *with
09:28:57 <pvt_petey> in plain english I read this as there is some orderable a greater than or equal to a which must become a tree that has a. If tree is empty return the singleton, else.. ?
09:29:26 <Iceland_jack> pvt_petey: Where do you get “orderable” from?
09:29:38 <pvt_petey> (Ord)
09:29:39 <pvt_petey> ?
09:29:46 <pvt_petey> i assume that's what it means
09:29:55 <Eduard_Munteanu> @src Ord
09:29:55 <lambdabot> class  (Eq a) => Ord a  where
09:29:56 <lambdabot>     compare      :: a -> a -> Ordering
09:29:56 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
09:29:56 <lambdabot>     max, min         :: a -> a -> a
09:29:58 <Iceland_jack> That's not part of the Tree definition pvt_petey
09:30:23 <pvt_petey> it's in the treeInsert function below
09:30:34 <Iceland_jack> pvt_petey: That's not part of the data definition
09:30:49 <Iceland_jack> Which function are you looking at in particular?
09:30:55 <pvt_petey> treeInsert
09:31:06 <pvt_petey> for traversal
09:31:14 <Iceland_jack> right
09:31:36 <Iceland_jack> pvt_petey: If you want to insert 'a' into an empty tree, what do you get?
09:31:42 <pvt_petey> a
09:31:50 <Iceland_jack> yes, a singleton tree
09:32:15 <Iceland_jack> what if the tree is non-empty?
09:32:28 <pvt_petey> then you need to traverse the tree
09:32:33 <pvt_petey> and find the right position
09:32:49 <Iceland_jack> yes so you need to pick the right subtree to insert into
09:33:03 <pvt_petey> so
09:33:24 <pvt_petey> the definition Node a (Tree a) (Tree a) can be read as Node a left right
09:33:35 <dazed_and_amused> > putStrLn "Hi"
09:33:37 <lambdabot>  <IO ()>
09:33:48 <merijn> dazed_and_amused: Lambdabot doesn't do IO, for obvious security reasons
09:33:51 <Iceland_jack> you can think of it like that pvt_petey
09:33:52 <dazed_and_amused> :(
09:34:01 <monochrom> the only way to get putStrLn to work is: putStrLn "<IO ()>"
09:34:10 <Iceland_jack> monochrom: haha
09:34:11 <Eduard_Munteanu> dazed_and_amused: you can 'show' things though
09:34:17 <Eduard_Munteanu> > show 5
09:34:18 <lambdabot>  "5"
09:34:33 <dazed_and_amused> hmm
09:34:38 <dazed_and_amused> > "hello"
09:34:40 <lambdabot>  "hello"
09:34:43 <dwcook> Has anyone thought about integrating chrisdone's pure IO into lambdabot?
09:34:57 <merijn> dazed_and_amused: FYI, lambdabot also works in private messsage (which avoids spamming the channel)
09:35:07 <Iceland_jack> pvt_petey: when you have a value of the form (Node val l r) then ‘l’ is the left-subtree, ‘r’ is the right-subtree
09:35:09 <pvt_petey> ok so .... how does Node x left right imply that you should do nothing ? (if the tree already contains something then it shouldn't have anything inserted)
09:35:15 <dazed_and_amused> merijn: oh cool...sory about that
09:35:28 <merijn> pvt_petey: Well, think about what doing nothing means
09:35:28 <dwcook> Though I wonder how getLine would function
09:35:49 <Iceland_jack> pvt_petey: if you're trying to insert 'a' into a tree that already contains 'a' you don't need to change it
09:36:03 <monochrom> Node x left right does not imply that I should do nothing. (what does that sentence even mean?)
09:36:45 <Iceland_jack> monochrom: pvt_petey is talking about the '| x == a = Node x left right' case I think
09:37:11 <monochrom> then it is "x==a" that implies things
09:37:15 <Iceland_jack> yes
09:37:22 <merijn> monochrom: I treat ill-specified questions like a C compiler treats undefined behaviour. I make up whatever interpretation suits me best and answer that :p
09:37:35 <Iceland_jack> pvt_petey: It seems like your problem lies with something a bit more fundamental than trees, can you implement the same function for lists?
09:38:00 <pvt_petey> I can have a go ...
09:38:04 <monochrom> FWIW "Node x left right" is not even a boolean, therefore it cannot imply or not-imply. it's like "how does a car paint you"
09:39:19 <koertig> How do those statements correlate?
09:39:27 <monochrom> anyway, I certainly did apply a random interpretation too. it's why I could even say "does not imply".
09:40:25 <koertig> Do you mean how does a car paint you has no implication?
09:40:40 <hakujin> I seem to be a magnet for cabal issues this morning. reinstalled haskell-platform to get back to a known good state and am trying to 'cabal install cabal-install' on windows. getting: http://lpaste.net/99944
09:40:48 <castor3> Hi
09:41:04 <monochrom> koertig, "how does Node x left right imply ___" :: "how does a car paint ___".
09:41:08 <Erstarrung> I'm currently programming a little app with reactive-banana
09:41:20 <Erstarrung> And I have an issue with the "changes" function
09:41:28 <hakujin> basically 'Configuring Cabal-1.18.1.2...; setup.exe: does not exist"
09:41:36 <koertig> Ah, ok. Thank you for that clarification
09:41:57 <Erstarrung> I want to display the different values taken by a Behavior bu using the changes function
09:41:59 <Erstarrung> by*
09:42:19 <pvt_petey>  Iceland_jack in my lecture notes it's defined as ' data list = Nil | cons Integer deriving show ' if that seems correct
09:42:25 <Erstarrung> But it gives me an Event (Future a) and not an Event a
09:42:32 <Erstarrung> So I can't use the object in it
09:42:37 <Iceland_jack> pvt_petey: it does not
09:42:50 <pvt_petey> (for a list)
09:42:56 <Iceland_jack> It's incorrect
09:43:30 <dwcook> pvt_petey, your lecture notes say that verbatim? o_0
09:43:35 <Iceland_jack> If you want a list of only Integers (monomorphic) then its definition is
09:43:35 <Iceland_jack>     data IntegerList = Nil | Cons Integer IntegerList
09:43:59 <Iceland_jack> If you want a list of any possible value (polymorphic) then it's
09:43:59 <Iceland_jack>     data List a = Nil | Cons a (List a)
09:44:11 <pvt_petey> http://pastebin.com/Mv3LZZa5
09:44:12 <dwcook> pvt_petey, oh, you mean stuff that you yourself wrote, not like notes your professor posted?
09:44:12 <Iceland_jack> sprinkle ‘deriving (Eq, Show, …)’ to taste
09:44:26 <pvt_petey> no the professor
09:44:29 <Iceland_jack>     data List = Nil | Cons Integer List
09:44:31 <Iceland_jack> This is correct
09:44:41 <merijn> pvt_petey: I see *at least* 3 errors in the definition from your notes
09:45:04 <Iceland_jack> This is incorrect
09:45:04 <Iceland_jack>     data list = Nil | cons Integer deriving show
09:45:30 <pvt_petey> ah
09:45:37 <dwcook> The definition in that link you posted is like [Integer] using the built-in []
09:45:40 <pvt_petey> i think I misread sorry
09:46:01 <Iceland_jack> No problem pvt_petey, do you understand how defining data types work?
09:46:19 <Iceland_jack> @src Bool
09:46:20 <lambdabot> data Bool = False | True deriving (Eq, Ord)
09:46:20 <pvt_petey> afaik it looks a lot like a context free grammar
09:46:30 <Iceland_jack> That's right
09:46:37 <pvt_petey> you're trying to get to the terminals
09:46:55 <pvt_petey> although in the list example
09:47:04 <pvt_petey> I'm not quite sure how it aggregates into a list
09:47:15 <Iceland_jack> pvt_petey: Okay! Good!
09:47:15 <Iceland_jack>     
09:47:19 <Iceland_jack> Let's get you to understand that
09:47:25 <dwcook> Well Haskell can actually have lists that have no end
09:47:33 <dwcook> > let xs = 1:xs in xs
09:47:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:47:42 <Iceland_jack> Let's use
09:47:42 <Iceland_jack>     data List = Nil | Cons Integer List
09:47:42 <Iceland_jack> as an example
09:47:48 <Iceland_jack> pvt_petey: How do you construct the empty list?
09:48:03 <pvt_petey> List Nill ?
09:48:06 <Iceland_jack> no
09:48:31 <Iceland_jack> let's go to the Bool example
09:48:31 <Iceland_jack> @src Bool
09:48:31 <lambdabot> data Bool = False | True deriving (Eq, Ord)
09:48:59 <Iceland_jack> > False
09:49:00 <lambdabot>  False
09:49:00 <Eduard_Munteanu> pvt_petey: List a  ~  Nil | Cons a (List a)  ~  Nil | Cons a (Nil | Cons a (List a))  ~  ...
09:49:14 <merijn> Might want to move this to -overflow once someone else starts asking questions
09:49:34 <Iceland_jack> merijn: true
09:49:47 <Eduard_Munteanu> Er, the first '~' should be another symbol. :)
09:49:51 <Iceland_jack> pvt_petey: True is a way of constructing a value of type Bool
09:49:56 <pvt_petey> so you're saying that instead of saying List <something> you should just declare the terminal ?
09:50:00 <Iceland_jack> yes
09:50:07 <Iceland_jack> Just like ‘Nil’ is a way of constructing a value of type List
09:50:19 <Iceland_jack> Let's define List here
09:50:21 <Iceland_jack> @let data List = Nil | Cons Integer List deriving Show
09:50:22 <lambdabot>  Defined.
09:50:28 <Iceland_jack> This is the empty list
09:50:28 <Iceland_jack> > Nil
09:50:30 <lambdabot>  Nil
09:50:59 <Iceland_jack> pvt_petey: How do you construct a singleton list containing 'e'?
09:51:04 <Iceland_jack> oops
09:51:08 <Iceland_jack> containing 5
09:53:10 <pvt_petey> i'd say '5' but clearly that's wrong
09:53:30 <Iceland_jack> You have to use the constructors we just defined
09:53:34 <Iceland_jack> from
09:53:34 <Iceland_jack>     data List = Nil | Cons Integer List
09:53:34 <Iceland_jack>  
09:54:44 <Iceland_jack> 'Nil' is one constructor, 'Cons' is another
09:54:54 <Iceland_jack> The type of Nil is
09:54:54 <Iceland_jack> @ty Nil
09:54:55 <lambdabot> List
09:54:56 <pvt_petey> Cons 6 ?
09:55:01 <Iceland_jack> The type of Cons is
09:55:01 <Iceland_jack> @ty Cons
09:55:02 <lambdabot>     Ambiguous occurrence `Cons'
09:55:02 <lambdabot>     It could refer to either `L.Cons',
09:55:02 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:144:13
09:55:31 <Iceland_jack> @let data List = Nil | Cons' Integer List
09:55:32 <Iceland_jack> sigh
09:55:32 <lambdabot>  Defined.
09:55:36 <Iceland_jack> pvt_petey: That's close
09:55:44 <saep> @ty Cons' 6
09:55:45 <lambdabot> List -> List
09:55:49 <Iceland_jack> Note that the second paramter of 'Cons' is a new list
09:56:11 <Iceland_jack> you need to cons 5 to the empty list (Nil)
09:58:11 <pvt_petey> actually I'm getting a few errors at the moment
09:58:27 <merijn> Is there a convenient way to have multiple case-of branches point to the same body? Or should I just define a name for the body and list that in those branches?
09:58:48 <monochrom> no, there is still no convenient way
09:58:49 <johnw> the latter
09:58:54 <merijn> Bah
09:59:06 <merijn> OCaml has this, why can't we have nice things :(
09:59:12 <johnw> yeah, there are times when I want "fall through", but then I smack myself
09:59:22 <merijn> johnw: Ocaml doesn't have fallthrough
09:59:25 <monochrom> I think someone is working on it
09:59:28 <johnw> what does it do?
09:59:47 <merijn> johnw: It lets you write "match w with pattern1 | pattern 2 | pattern3 -> blah"
09:59:54 <johnw> ah
09:59:57 <Iceland_jack> You can do something like
09:59:57 <Iceland_jack>     case a of
09:59:57 <Iceland_jack>         foo | bar,
09:59:57 <Iceland_jack>               Just x <- ... -> blah
10:00:10 <merijn> johnw: Basically, if you leave the "-> val" branch of, it uses the one of the next branch
10:00:21 <dwcook> I think you have to have the same set of bindings or it complains though
10:00:28 <merijn> dwcook: Sure
10:00:35 <johnw> in Haskell wouldn't "bar" be interpreted as a predicate there?
10:00:45 <merijn> johnw: Yes
10:00:51 <merijn> johnw: We'd need some other syntax
10:01:52 <pvt_petey> ok well - I'm getting an error "Syntax error in data type declaration (unexpected symbol "show")" for this : http://pastebin.com/804jgMgN
10:02:00 <merijn> I guess I could get away with "x | x == foo; | x == bar" guards
10:02:03 <Iceland_jack> pvt_petey: Show, not show
10:02:14 <Yuu-chan> http://www.haskell.org/haskellwiki/MultiCase
10:02:16 <merijn> pvt_petey: Case matters
10:02:29 <pvt_petey> thanks
10:02:42 <Eduard_Munteanu> merijn: you can just define a function in a let/where clause and call it directly instead of 'case'.
10:03:01 <dwcook> pvt_petey, all type constructors, data constructors, and typeclasses have names starting with a capital letter (unless they're syntax).
10:03:17 <pvt_petey> hmm ok - didn't know that
10:03:30 <Iceland_jack> :==:
10:03:34 <Eduard_Munteanu> Capital symbol.
10:03:43 <pvt_petey> actually I'm learning haskell as my first functional language
10:03:46 <merijn> Eduard_Munteanu: That doesn't help
10:03:48 <pvt_petey> it's a bit hair-raising
10:03:50 <dwcook> Woops, yeah, I overgeneralized
10:03:53 <Iceland_jack> :)
10:04:00 <merijn> Eduard_Munteanu: I'd still have to duplicate the body for every value that has the same body
10:04:15 <Iceland_jack> pvt_petey: Good luck!
10:04:21 <Iceland_jack> @src []
10:04:21 <lambdabot> data [] a = [] | a : [a]
10:04:22 <pvt_petey> thxx :)
10:04:29 <Iceland_jack> This is “kind of” how lists are defined in Haskell
10:04:31 <merijn> pvt_petey: It's actually rather nice, because it means you can instantly tell whether something is a constructor or a function
10:04:31 <Eduard_Munteanu> merijn: if you have a function you can have guards sharing the same 'where' clause
10:04:42 <Iceland_jack> [] is Nil, (:) is Cons
10:04:44 <mangaba_leitosa> Yuu-chan: is http://www.haskell.org/haskellwiki/MultiCase already available?
10:04:53 <merijn> Eduard_Munteanu: Right, but that doesn't get me anything over let binding + case :)
10:05:02 <pvt_petey> i'm sure I will appreciate it in time Merijn
10:05:02 <Eduard_Munteanu> Ah, probably. :)
10:05:03 <pvt_petey> :)
10:05:46 <Iceland_jack> > []           -- pvt_petey: this is empty list Nil
10:05:46 <Iceland_jack>  
10:05:47 <lambdabot>  []
10:05:49 <Iceland_jack> > 5:[]         -- this is singleton list (Cons 5 Nil)
10:05:51 <lambdabot>  [5]
10:05:51 <Iceland_jack> > 1:2:[]       -- this is list of length two (Cons 1 (Cons 2 Nil))
10:05:53 <lambdabot>  [1,2]
10:05:56 <pvt_petey> Cons 5 Nill ?
10:06:04 <Iceland_jack> 'Cons 5 Nil', yes
10:06:10 <Iceland_jack> That's how you create a singleton list
10:06:15 <pvt_petey> ok
10:06:26 <dwcook> There's also convenient syntax for that. [5] means the same as 5:[]
10:06:28 <pvt_petey> i think that makes sense
10:06:33 <Iceland_jack> good
10:06:48 <Iceland_jack> and like dwcook said, it's rather unpleasant to write
10:06:48 <Iceland_jack> > 1:2:3:4:5:6:[]
10:06:50 <lambdabot>  [1,2,3,4,5,6]
10:06:57 <Iceland_jack> so we get to write
10:06:57 <Iceland_jack> > [1,2,3,4,5,6]
10:06:57 <Iceland_jack> instead
10:06:58 <lambdabot>  [1,2,3,4,5,6]
10:07:14 <Iceland_jack> As syntactic sugar
10:08:08 <pvt_petey> although I didn't think to use list on the outside...
10:08:21 <Yuu-chan> mangaba_leitosa: no, seems like an extension proposition only :(
10:08:34 <Iceland_jack> pvt_petey: What do you mean 'use list on the outside'?
10:08:39 <pvt_petey> as in
10:08:40 <mangaba_leitosa> Yuu-chan: I always wondered why such a trivial thing is not available
10:08:48 <pvt_petey> List(Cons 5 Nil)
10:08:53 <pvt_petey> instead of Cons 5 Nil
10:09:04 <Iceland_jack> Okay so it's good to make something clear pvt_petey
10:09:09 <Iceland_jack> List is the tyoe of 'Cons 5 Nil'
10:09:15 <Iceland_jack> *type
10:09:19 <Iceland_jack> List is the type of 'Nil'
10:09:33 <Iceland_jack> If we define
10:09:33 <Iceland_jack> @let data List = Nil | Cons' Integer List deriving Show
10:09:34 <lambdabot>  Defined.
10:09:38 <pvt_petey> although it's telling me "ERROR - Undefined data constructor "List""
10:09:39 <Iceland_jack> Then we write
10:09:39 <Iceland_jack> > Nil :: List
10:09:40 <lambdabot>  Nil
10:09:48 <Iceland_jack> pvt_petey: Yes, because it's wrong
10:09:55 <Iceland_jack> You don't use List like that, it's the type
10:10:12 <Iceland_jack> Why do you want to write 'List(Cons 5 Nil)' rather than the correct 'Cons 5 Nil'?
10:10:24 <Iceland_jack> > Cons 5 Nil :: List
10:10:25 <lambdabot>  Couldn't match expected type `a0 -> L.List -> L.List'
10:10:26 <lambdabot>              with actual type `Math.OEIS.Types.Keyword'
10:10:28 <Iceland_jack> > Cons' 5 Nil :: List
10:10:30 <lambdabot>  Cons' 5 Nil
10:10:47 <Iceland_jack> > Cons' 4 (Cons' 5 Nil) :: List
10:10:49 <lambdabot>  Cons' 4 (Cons' 5 Nil)
10:12:52 <pvt_petey> ok I think that makes more sense now
10:13:01 <Iceland_jack> Okay
10:13:08 <Iceland_jack> you can omit ':: List'
10:13:14 <Iceland_jack> Since Haskell can infer the type
10:13:30 <Iceland_jack> pvt_petey: Can you define a function which returns the length of a List?
10:14:11 <pvt_petey> so basically you have to put there terminator (bill) into any list to know when you've got to the end like with a cstring. Why is cons always mentioned in the 'show' : - it feels redundant.
10:14:23 <pvt_petey> I can certainly have a go
10:14:56 <Iceland_jack> pvt_petey: Because that's how Haskell derives Show for any data type
10:15:13 <pvt_petey> ok
10:15:19 <Iceland_jack> you can define your own Show instance which pretty-prints 'Cons 1 (Cons 2 (Cons 3 Nil))' as [1,2,3]
10:15:32 <pvt_petey> righht ok
10:15:40 <pvt_petey> :)
10:15:54 <Iceland_jack> But you would never use your own definition of a List like that, you'd just use the built-in one
10:16:39 <Iceland_jack> This is just for pedagogical purposes
10:25:28 <tromp> anyone here have a linux/osx machine with 20 or more cpu-threads?
10:25:50 <njcomsec> oh there is a haskell room
10:26:04 <njcomsec> and it's huge
10:26:57 <pvt_petey> Iceland_jack : this isn't correct but hopefully it's in the right direction http://pastebin.com/UXPutgxy\
10:27:34 <xeorex> I wonder if anyone can point me in the right direction. I am doing the most simple thing ever. I start ghci, try a = 5, I get "<interactive>:24:4: parse error on input `='"
10:27:46 <jfischoff> let a = 5
10:27:48 <Iceland_jack> xerlet a  = 5
10:27:52 <Iceland_jack> *let a = 5
10:27:57 <xeorex> ty
10:28:01 <Iceland_jack> pvt_petey: this is a good start
10:28:23 <Iceland_jack> since we define List as
10:28:23 <Iceland_jack>     data List = Nil | Cons Integer List
10:28:23 <Iceland_jack> there are only *two* cases to pattern match on
10:28:35 <Iceland_jack> Nil and (Cons i is)
10:28:56 <Iceland_jack> so your definition should have the form
10:28:56 <Iceland_jack>     length Nil         = ...
10:28:56 <Iceland_jack>     length (Cons i is) = ...
10:29:05 <Iceland_jack> (a:as) *only* works for lists
10:29:11 <pvt_petey> wait Cons i is ?
10:29:20 <Iceland_jack> yes, or what ever variable names you prefer
10:29:46 <Iceland_jack> When you write definitions for lists, (a:as) is the same as (Cons a as) for your own List
10:29:53 <pvt_petey> ahh ok
10:30:18 <pvt_petey> I'd only every seen the (x:xs) declaration before
10:30:24 <Iceland_jack> if you want to translate a function
10:30:24 <Iceland_jack>     foo :: [Integer] ->
10:30:24 <Iceland_jack>     foo []     = ...
10:30:24 <Iceland_jack>     foo (a:as) = ...
10:30:29 <Iceland_jack> to List
10:30:47 <Iceland_jack> you write
10:30:47 <Iceland_jack>     foo :: List -> ...
10:30:47 <Iceland_jack>     foo Nil         = ...
10:30:47 <Iceland_jack>     foo (Cons a as) = ...
10:30:54 <pvt_petey> even so I get an error : Equations give different arities for "length"
10:31:06 <merijn> Wait, the stateful Parsec monad isn't an instance of MonadState? :(
10:31:12 <Iceland_jack> pvt_petey: yes, because there shouldn't be anything after Nil
10:31:22 <Iceland_jack> Look at your code and compare it to what I wrote exactly, please
10:31:35 <Iceland_jack> You probably still have ‘ac’ trailing the Nil
10:31:44 <Iceland_jack> and remove the third case
10:32:25 <Iceland_jack> also ‘length 0’ doesn't make any sense
10:33:04 <johnw> merijn: maybe it predates the mtl?
10:33:15 <merijn> johnw: :(
10:33:37 <pvt_petey> I thought to define it recursively
10:33:38 <johnw> orphan instances to the rescue!
10:33:43 <Iceland_jack> pvt_petey: Yes
10:33:52 <Iceland_jack> but ‘length 1’ makes no sense
10:33:53 <pvt_petey> therefore it must increment from 0?
10:34:15 <Iceland_jack> pvt_petey: You're a bit confused
10:34:23 <Iceland_jack> I suggest you read the beginning of LYAH
10:34:23 <merijn> Iceland_jack: heh, a bit :)
10:34:25 <Iceland_jack> @where lyah
10:34:25 <lambdabot> http://www.learnyouahaskell.com/
10:34:50 <Iceland_jack> you lack some fundamentals for the the chapter you posted originally
10:35:32 <Iceland_jack> To spoil the fun, here is the actual definition of ‘myLength’ using [a]
10:35:33 <Iceland_jack>     myLength :: [a] -> Int
10:35:33 <Iceland_jack>     myLength []     = 0
10:35:33 <Iceland_jack>     myLength (x:xs) = 1 + length xs
10:35:37 <Iceland_jack> (which is recursive)
10:35:51 <pvt_petey> ok  - yes I'm trying to skim around to get a sense of what the lecture notes are on about
10:36:18 <Iceland_jack> oops, the recursive case should be myLength, not length
10:36:27 <Iceland_jack> and the definition of ‘myLength’ on the data type you defined
10:36:27 <Iceland_jack>     myLength :: List -> Int
10:36:27 <Iceland_jack>     myLength Nil         = 0
10:36:27 <Iceland_jack>     myLength (Cons x xs) = 1 + myLength xs
10:36:33 <Iceland_jack> The definitions are basically the same
10:36:46 <Iceland_jack> Both are recursive
10:37:38 <FreeFull> You can write a definition in terms of a catamorphism
10:37:50 <Iceland_jack> FreeFull: Yes I'm sure that will help pvt_petey
10:38:02 <Iceland_jack> :) who doesn't know how to define a data type or define length..
10:38:10 <pvt_petey> D:
10:38:26 <Iceland_jack> pvt_petey: ignore catamorphisms
10:38:31 <FreeFull> I suppose it is a bit early for those
10:38:37 <Iceland_jack> A bit.. :)
10:38:48 <pvt_petey> uh what should I concentrate on
10:38:48 <FreeFull> How about a fold?
10:39:05 <Iceland_jack> FreeFull: pvt_petey should be reading the first chapters of LYAH so I'd say no
10:39:16 <FreeFull> LYAH is a good place to start out at
10:39:36 <Iceland_jack> pvt_petey: LYAH is a good place, do you understand the ‘myLength’ function for example?
10:39:43 <Iceland_jack> Do you understand why ‘length 0’ doesn't make sense?
10:40:07 <pvt_petey> let me look again
10:41:50 <pvt_petey> because it conflicts with the empty list definition, mainly
10:41:54 <pvt_petey> but yes that does make more sense
10:41:57 <Iceland_jack> pvt_petey: no
10:42:06 <Iceland_jack> ‘length’ takes a *list* as its argument
10:42:07 <merijn> pvt_petey: No, it doesn't make sense because 0 is not a list
10:42:08 <Iceland_jack> not a number
10:42:29 <Iceland_jack> It doesn't make sense to ask ‘how long is this list’ when referring to 0
10:42:47 <merijn> But I would like to suggest that even in the absence of other questions this has now become a topic for -overflow :)
10:42:55 <Iceland_jack> yes, I'm leaving anyway :)
10:43:00 <Iceland_jack> good luck pvt_petey
10:43:05 <pvt_petey> sorry to drive you away ;)
10:43:12 <pvt_petey> but thx for the help :)
10:43:29 <merijn> pvt_petey: I would strongly advice starting from the start of LYAH and not skipping around
10:43:52 <merijn> pvt_petey: Haskell is (as you've noticed) very much unlike other languages and skipping the basics will leave you *very* confused
10:43:53 <Iceland_jack> You're welcome pvt_petey, and I strongly advice the same as merijn :)
10:44:06 <Iceland_jack> #haskell is full of strong advice :)
10:44:10 <pvt_petey> ok D:
10:44:23 <pvt_petey> yes the force is strong in #haskell
10:50:31 <schell> is it possible to send a "control-c" to a process created with System.Process.createProcess?
10:51:42 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:interruptProcessGroupOf note portability constraints
10:51:57 <geekosaur> (basically this is not entirely meaningful on Windows)
10:52:54 <schell> geekosaur: thanks - i must have glossed over that one because it had 'Group' in the name...
10:53:18 <geekosaur> yes, the whole notion of control-c is tied to process groups on both windows and unix
10:53:48 <geekosaur> you may be looking for lower level signal handling on unix, but a control-c is sent to a process group
11:04:11 * hackagebot smtLib 1.0.7 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.7 (IavorDiatchki)
11:04:28 <schell> geekosaur:thanks - that coupled with some threadDelay did the trick
11:16:40 <nf7> Hi, I'm trying to get the first element of an infinite list, how can I write a predicate take will stop the list generation when the length of the list is 1 or greater?
11:16:58 <nf7> I don't know how to refer to the list being generated
11:17:48 <haasn> I don't understand what you mean
11:17:50 <haasn> @src head
11:17:50 <lambdabot> head (x:_) = x
11:17:50 <lambdabot> head []    = undefined
11:18:04 <haasn> > head [2,4..]
11:18:05 <lambdabot>  2
11:18:57 <geekosaur> nf7: either you are not accessing the list lazily or you don't understand laziness, I think
11:19:24 <nf7> geekosaur: I probably don't understand it. I just started Haskell today.
11:19:40 <geekosaur> so see that last example that haasn used
11:19:51 <nf7> geekosaur: I'm just doing some early Project Euler problems to get used to list comprehensions. Which are amazing by the way.
11:19:53 <geekosaur> if you don't touch anything but the head of a list, the rest won't be generated
11:20:26 <FreeFull> nf7: What languages are you familiar with?
11:20:26 <geekosaur> however this may require some care because there are things that *do* try to traverse the whole list
11:20:44 <nf7> FreeFull: Python and C++
11:21:03 <verement> nf7: lists are generated on demand, so you only see as much of the list as you inspect
11:21:22 <nf7> verement: Awesome
11:21:31 <Iceland_jack> > [1..] -- nf7: this is an ‘infinite’ list
11:21:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:21:42 <Iceland_jack> > head [1..] -- nf7: this is the first element of that list
11:21:43 <lambdabot>  1
11:21:55 <nf7> Is code run in the interpretive mode (GHCI) significantly slower than compiled code?
11:22:02 <haasn> depends on the code
11:22:03 <haasn> sometimes, yes
11:22:06 <Iceland_jack> generally yes
11:22:11 <haasn> GHCi is essentially unoptimized
11:22:16 <nf7> ok
11:23:12 <FreeFull> ghci also is threaded by default, while compiled code will be single-threaded unless you compile with --threaded
11:23:51 <nf7> I just have a single list, something like: head [ x | x <- [20,40..], bunch of predicates ], I can't figure out how to just get that line to print in a compiled source file! I know I need main = but I don't really understand it past that
11:24:23 <Iceland_jack> nf7:
11:24:23 <Iceland_jack>     main = print [1,2,3]
11:24:23 <nf7> I don't really want to skip ahead in my tutorial, I just want to see this one thing compiled
11:24:45 <Iceland_jack> write it to a file ‘print123.hs’ and do
11:24:45 <Iceland_jack>     ghc print123.hs
11:25:42 <Iceland_jack> should produce a print123{,.o,hi} file
11:26:09 <Iceland_jack> where you can of course replace [1,2,3] with any list of your choosing
11:26:44 <nf7> Awesome thanks a lot! I'm getting a problem in C++ done in .2 sec and in Haskell in 3.0 sec. Does that sound about right? Obviously I'm better at coding C++ at this moment.
11:26:54 <Iceland_jack> depends on the problem
11:28:10 <nf7> Of course.
11:28:18 <nf7> Thanks for the help
11:28:31 <nf7> I don't think I've ever had so much fun learning a language
11:28:33 <Iceland_jack> Do you want to share the problem you implemented in C++ and Haskell? :)
11:28:46 <Iceland_jack> nf7: (it never stops, I promise) :)
11:28:50 <nf7> I'm slightly embaressed to show the haskell code hahah
11:29:02 <Iceland_jack> pf, it's just a chance to learn
11:29:21 <nf7> Iceland_jack: One moment, I'll paste them
11:29:28 <Iceland_jack> @where lpaste
11:29:28 <lambdabot> http://lpaste.net/new/haskell
11:31:30 <merijn> nf7: Immediate suspects: Are you compiling with optimisations? Are you using String?
11:31:44 <nf7> Haskell (don't make fun of me): http://lpaste.net/raw/3381230316789170176 , C++: https://gist.github.com/anonymous/dcff17aab75719e1fa7c
11:33:14 <chirpsalot> nf7: #haskell is actually like the friendliest programming channel ever. Nobody will make fun of you, especially when you're learning.
11:33:48 <nf7> awesome
11:33:59 <nf7> Any tips of getting rid of that horrendous set of predicates?
11:34:16 <merijn> nf7: Yes, I was working on one
11:34:18 <chirpsalot> nf7: hmmmmm. That's a lot of mods... I'm a newbie too, but I think you can do something better with that. Maybe put them all in a list and use map to check all of them?
11:34:33 <Iceland_jack> @ty all
11:34:33 <lambdabot> (a -> Bool) -> [a] -> Bool
11:34:34 <FreeFull> zipWith mod [20,40..] [2..]
11:34:42 <mangaba_leitosa> nf7: if you replace first '20' with '20::Int', it will work as fast in C++
11:34:51 <FreeFull> Actually, hmm
11:34:54 <merijn> nf7: You can probably compact those mod using some math
11:34:58 <merijn> FreeFull: That's completely different
11:35:00 <FreeFull> That wouldn't be too useful on its own
11:35:24 <bennofs> all (\num -> mod x num == 0) [2..20]
11:35:29 <nf7> At first I thought you could do something like: head [ x | x <- [20,40..], x `mod` [2..20] == 0]
11:35:30 <chirpsalot> mangaba_leitosa: are Haskell's big ints that slow for small numbers?
11:35:43 <Iceland_jack> what bennofs wrote
11:36:07 <mangaba_leitosa> chirpsalot: well, I just tried it on nf7 code and the execution time dropped drom 3 sec to 0.3 :-)
11:36:12 <nf7> bennofs: Could you show me a paste of that written into the code? I'm not sure what it should look like
11:36:14 <FreeFull> > map fst (filter snd (zipWith (\x y -> (x,x `mod` y == 0)) [20,40..] [2..]))
11:36:18 <lambdabot>  mueval-core: Time limit exceeded
11:36:27 <FreeFull> > take 10 (map fst (filter snd (zipWith (\x y -> (x,x `mod` y == 0)) [20,40..] [2..])))
11:36:31 <lambdabot>  mueval-core: Time limit exceeded
11:36:35 <FreeFull> > take 10 (map fst (filter snd (zipWith (\x y -> (x,x `mod` y == 0)) [20,40..] [2..])))
11:36:37 <chirpsalot> mangaba_leitosa: damn. I find that a bit surprising... I believe you -- I know big ints can be slow... But still.
11:36:39 <lambdabot>  mueval-core: Time limit exceeded
11:36:41 <bennofs> nf7: [ x | x <- [20,40..], all (\num -> mod x num == 0) [2..20] ]
11:36:47 <Iceland_jack> nf7: 'all even [1,2,3]' has type Bool
11:36:52 <bennofs> > [ x | x <- [20 :: Int,40..], all (\num -> mod x num == 0) [2..20] ]
11:36:55 <FreeFull> Oh, that's wrong too
11:36:56 <lambdabot>  mueval-core: Time limit exceeded
11:37:06 <Iceland_jack> so you can use it as a predicate for your list comprehension
11:37:40 <chirpsalot> mangaba_leitosa: hold up. Now I'm curious. I know it's a bit apples to oranges, but I wonder how Python3 will compare (it defaults to some big ints too). Gimme a sec.
11:37:46 <Iceland_jack> > [ name | name <- ["JOHN", "Sally", "AMANDA"], all isUpper name ]
11:37:47 <lambdabot>  ["JOHN","AMANDA"]
11:38:09 <Eduard_Munteanu> What's a good antonym for "lift", like the one in monad transformers?
11:38:16 <catalyst> slide? xD
11:38:17 <Iceland_jack> nf7: (does the above example make sense?)
11:38:17 <`^_^v> putDown
11:38:20 <Iceland_jack> Eduard_Munteanu: drop?
11:38:33 <Iceland_jack> dubStep is the dual of lifting..
11:38:47 <Eduard_Munteanu> Perhaps "fall" if we're going that way. :)
11:38:49 <Iceland_jack> dump :)
11:38:51 <nf7> I'm having trouble understanding. I'll catch on with a few more hours of study. I've got to run now though, thanks for all the help!
11:39:00 <roconnor> Eduard_Munteanu: comonad transformers call it "lower"
11:39:10 <Eduard_Munteanu> Interesting, thanks.
11:40:00 <bennofs> Eduard_Munteanu: kan-extensions also has liftCoyoneda <-> lowerCoyoneda
11:40:08 <Eduard_Munteanu> Well, this isn't about monads, but about named filepaths. More specifically lifting 'Path' into 'Tagged t Path'.
11:40:31 <Eduard_Munteanu> I guess lower is fine here as well.
11:40:58 <Iceland_jack> Eduard_Munteanu: Out of curiosity, what might the path be tagged with?
11:41:13 <bennofs> Eduard_Munteanu: Isn't Tagged a Comonad? Then the reverse is just extract?
11:41:27 <edwardk> tagged is a comonad
11:41:43 <Eduard_Munteanu> Iceland_jack: one specific application is tagging whether paths are sources or destinations, in operations like "copyFiles"
11:42:22 <Iceland_jack> that's interesting..
11:42:22 <Eduard_Munteanu> Iceland_jack: which you can use to avoid overwriting your source paths, for example
11:42:26 <edwardk> Eduard_Munteanu: return :: Path -> Tagged t Path
11:42:46 <merijn> vim-hdevtools question: If I don't add "-g-optP-include -g-optPdist/build/autogen/cabal_macros.h" to the flags then it breaks on files using version macros, however if I *do* add it, hdevtools breaks on files/cabal packages that don't have cabal_macros.h
11:42:50 <merijn> Any suggestions?
11:42:59 <Eduard_Munteanu> edwardk: yeah, I was looking at making an IsPath class that provided that sort of lifting
11:43:09 <Eduard_Munteanu> Instead of using Tagged directly.
11:44:12 <Eduard_Munteanu> edwardk: btw, is there a TaggedT transformer somewhere?
11:45:27 <edwardk> Eduard_Munteanu: http://hackage.haskell.org/package/tagged-transformer-0.6.1/docs/Data-Functor-Trans-Tagged.html
11:45:37 <chirpsalot> mangaba_leitosa: okay, Python clocked in at about 17 seconds for me. Maybe bit ints are just slower than I thought (of course I would expect Python to be slower than Haskell and C++ anyway, so who knows)
11:45:41 <Eduard_Munteanu> Nice, thanks.
11:46:46 * Eduard_Munteanu is also getting rid of '/' and relative paths
11:46:48 <bennofs> merijn: I wrote https://github.com/bennofs/hdevtools (partly as a fun project for using pipes :)), though I'm now using https://github.com/bennofs/ghc-server [which only does syntax checking atm, not the other things that hdevtools currently does]. My hdevtools still has some space leaks, iirc. So I can't exactly recommend that :p
11:46:57 <Eduard_Munteanu> You can represent relative paths as functions anyway.
11:48:12 <bennofs> merijn: but those two checkers have better cabal support than bitc/hdevtools
11:48:45 <mangaba_leitosa> chirpsalot: I think it makes sense that doing arithmetics by single cpu instructions is faster than implementing the same in a library
11:48:55 <supki> merijn: add this option only if cabal_macros.h exists?
11:49:10 <merijn> supki: Very smart, how do I do that? :p
11:49:39 <mangaba_leitosa> chirpsalot: btw I tried the same code on 64-bit Linux instead of 32-bit and the '::Int' version is 3 times slower there
11:49:47 <chirpsalot> mangaba_leitosa: oh absolutely. I just kind of thought Haskell big ints might essentially use machine ints until an overflow? Which would still be slower, but I assumed a bit faster maybe?
11:50:01 <mangaba_leitosa> chirpsalot: I'm not sure
11:50:01 <supki> merijn: vimscript can check if file exists ;)
11:50:25 <frx> mangaba_leitosa Int was 3 times slower than Integer?
11:50:29 <merijn> supki: Yes, but hdevtools is being called by syntastic in my case
11:50:35 <chirpsalot> mangaba_leitosa: like... 9 seconds instead of 3?
11:50:42 <merijn> supki: So that means hacking all the relevant extensions, which is a lot of work
11:50:48 <supki> uhm?
11:50:49 <chirpsalot> mangaba_leitosa: or 0.9 seconds instead of the 0.3s you got?
11:51:00 <mangaba_leitosa> frx: no, Int using 64-bit ghcc slower than Int on 32-bit
11:51:02 <frx> or Int version was 3 times slower on 64 bit linux than on 32-bit ?
11:51:04 <Saizan> chirpsalot: ghc does stick to machine ints until it needs something bigger
11:51:05 <frx> ah ok
11:51:06 <supki> syntastic respects g:hdevtools_options
11:51:23 <merijn> supki: Yes, and how do I get that to dynamically update based on which file I have open?
11:51:32 <mangaba_leitosa> chirpsalot: 3 seconds is bigint (Integer). Int is 0.3 seconds on 32-bit and 1 second on 64-bit
11:51:36 <chirpsalot> Saizan: oh, wait. What about ghci? Was nf7 using the interpreter, maybe?
11:52:24 <chirpsalot> mangaba_leitosa: interesting... Is Int maybe the same on the 64-bit and 32-bit systems so the ints aren't optimal for the 64-bit machine?
11:52:25 <merijn> bennofs: Will your hdevtools be merged back into the original hdevtools at some point?
11:52:32 <supki> merijn: oh, for that I have .vim.custom file in every project's root, which is loaded by ~/.vimrc
11:52:33 <Saizan> chirpsalot: well, ghci calls the same library code, but the interpreted code can be way slower and less able to make use of low level optimizations
11:52:57 <peddie> chirpsalot: even if it uses machine ints until overflow, it still needs to check for overflow
11:53:03 <bennofs> merijn: I pretty much gave up developing it, so I guess not :| Also, I don't know if that pipes port was really such a good idea. It just makes stuff more complicated
11:53:27 <merijn> bennofs: I'm afraid it'll just bitrot then :\
11:55:25 <mangaba_leitosa> chirpsalot: 64-bit programs usually allocate twice at much heap
11:55:43 <mangaba_leitosa> chirpsalot: so memory allocation and garbage collection is slower
11:56:40 <mangaba_leitosa> chirpsalot: for this code compiled using ghc -with-rtsopts="-sstderr", I get "465,638,236 bytes allocated in the heap" for 32-bit and "931,231,416 bytes allocated in the heap" for 64-bit
11:57:08 <Saizan> mangaba_leitosa: are you compiling with -O2 ?
11:57:13 <mangaba_leitosa> Saizan: yes
11:57:32 <cariveri> Hi. does ghc evaluate hex coded charaters in to strings?
11:57:35 <merijn> bennofs: I'll put patching and merging back into hdevtools for cabal support on my TODO yak shaving list
11:58:04 <merijn> > '\x53'
11:58:06 <lambdabot>  'S'
11:58:15 <merijn> > "\x53top"
11:58:16 <lambdabot>  "Stop"
11:58:20 <chirpsalot> mangaba_leitosa: yeah, I was just thinking of the kind of C style replace the integers and don't allocate more memory approach with mutable variables. Wasn't considering the heap. C fried my brain long ago :(
11:58:27 <merijn> cariveri: So, yes
11:58:46 <chirpsalot> mangaba_leitosa: that does make a lot of sense, though.
11:59:00 <merijn> bennofs: But since I'm already yak shaving atm, I won't add a new yak until I finish this...
11:59:00 <Eduard_Munteanu> cariveri: that only holds for literal strings, actual strings aren't interpreted at all
11:59:22 <bennofs> merijn: be careful though to not update GHC's dynflags too often. IIRC, they leak space
11:59:27 <chirpsalot> peddie: yeah, I know it would need to check for overflow and stuff... I was just not expecting that to make everything 15 times slower?
11:59:28 <Eduard_Munteanu> > concat ['\\','x','5','3']
11:59:29 <lambdabot>  Couldn't match expected type `[a0]'
11:59:29 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match expected type `[...
11:59:29 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match expected type `[...
11:59:29 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match expected type `[...
11:59:29 <lambdabot>              with actual type `GHC.Types.Char'
11:59:38 <merijn> bennofs: dynflags?
11:59:44 <peddie> chirpsalot: heh, me neither :)
11:59:46 <Eduard_Munteanu> Er.
11:59:49 <Eduard_Munteanu> > ['\\','x','5','3']
11:59:50 <lambdabot>  "\\x53"
12:00:17 <Eduard_Munteanu> cariveri: ^
12:00:18 <bennofs> merijn: The GHC API uses DynFlags to store the "dynamic flags" (flags given on the command line)
12:00:39 <cariveri> thanks guys. no wI know that i had the wrong key it seems. \x53 was in deed displayed normaly , but not \x83 as intended
12:00:55 <merijn> bennofs: I have no clue how hdevtools works atm, so this doesn't mean much to me :)
12:01:03 <merijn> > '\x83'
12:01:04 <lambdabot>  '\131'
12:01:16 <merijn> cariveri: Oh, duh
12:01:36 <bennofs> merijn: oh, ok :)
12:01:52 <merijn> cariveri: x83 is bigger than 127 so it's not ASCII, not sure whether unicode codepoint x83 is printable
12:02:06 <merijn> cariveri: What did you expect it to be?
12:02:17 <chirpsalot> peddie: as a Haskell newbie I just assume that GHC is the absolute pinnacle of magic and will always produce assembly that's more or less equivalent to a similar C program that I would write, even if the Haskell program is like O(n^2) and the C one was O(n). This is irrational :P.
12:03:05 <cariveri> merijn: i wanted something like a funtional "f"  ƒ   or a lambda.
12:03:20 <Iceland_jack> chirpsalot: GHC is actually one of the few compilers that improve the complexity of your solutions! even transforms NP-hard problems into linear time
12:03:24 <merijn> cariveri: Why not just write that character?
12:03:37 <merijn> cariveri: Haskell source is utf-8 and strings are *proper* unicode
12:03:43 <chirpsalot> Iceland_jack: really? Got a link? SO MY ASSUMPTIONS ARE VALIDATED! (kind of)
12:03:52 <merijn> cariveri: So just writing "ƒ" in the source should work
12:04:02 <merijn> > "ƒ" -- this might fail due to IRC not having an encoding
12:04:04 <lambdabot>  "\402"
12:04:18 <Iceland_jack> chirpsalot: There is only a link in the fairy land of sufficiently smart compilers!
12:05:12 <chirpsalot> Iceland_jack: I think it's that Haskell is "math" enough as opposed to something like C that I throw the efficiency stuff out the window and just think about things as I would in a math course where every function is instant! :P
12:05:34 <peddie> chirpsalot: heh, yeah, there's some impressive stuff under the hood, but it's not magic for every program
12:05:40 <peddie> chirpsalot: it's always getting better, though
12:06:53 <cariveri> merijn: yes it does work. i somehow thought feeding the code is more direct.
12:07:56 <chirpsalot> Iceland_jack: wait. I just realized that you were joking -- obviously NP-hard problems aren't going to become linear :P. I know there is some research in detecting like, for example, something like bubble sort and replacing it with a better sort algorithm at compile time... But I don't think there's much on that at all?
12:08:47 <Iceland_jack> Real compilers never alter the actual algorithm as far as I'm aware
12:09:01 <Iceland_jack> that's up to the programmer
12:09:03 <mangaba_leitosa> chirpsalot: BTW I just tried nf7's C++ code and it is also 2+ times slower on 64-bit
12:09:13 <chirpsalot> peddie: GHC is very impressive. It's nice when I get a program that I wrote in C that worked okay for small instances but actually works better in a Haskell version because of lazy evaluation or whatever.
12:09:55 <chirpsalot> Or the naive Haskell version doesn't explode like the naive C version because the naive C version just allocates too much memory :P.
12:11:14 <ReinH> chirpsalot: it's kind of rare for me that the naive Haskell version uses *less* memory :p
12:11:21 <chirpsalot> Iceland_jack: yeah, I don't think it would be practical. I mean, ideally if the result is the same you would want to use the quicker algorithm, but I don't see how you would do it. I guess it was just a research question or something from one of the profs here.
12:11:25 <ReinH> Since I usually left a leak in somewhere
12:12:31 <Iceland_jack> chirpsalot: It would be hard to detect the algorithm being used, how would you even choose what to replace it with?
12:12:34 <rawtass> What's the best haskell plotting lib for plotting matrices?
12:12:47 <chirpsalot> ReinH: it was some program for brute forcing a problem... In the C version I just allocated a giant array for all of the data because it was way easier, but Haskell could drop things that were no longer used more easily? I'll dig it up and see if I can remember. I think it was a question in a group theory class.
12:13:12 <Iceland_jack> Some algorithms work better on smaller inputs, special inputs that are almost sorted e.g.
12:13:41 <chirpsalot> Iceland_jack: yeah, I know :P. I assumed it was black magic and wouldn't work. Which is why I was so surprised when you said GHC did it -- completely missing that it was a joke :P.
12:13:50 <Iceland_jack> If you consider trivial algorithms for summing numbers, sure compilers can optimze that into a formula actually
12:14:01 <Iceland_jack> but those need to be hard-coded
12:14:32 <mm_freak_> i don't see laziness as an optimization, but as a paradigm
12:15:13 <chirpsalot> mm_freak_: I wouldn't say it's an optimization, but in some problems it can really help speed things up. I think that's probably rare, thougH?
12:15:20 <ReinH> chirpsalot: I love using laziness for things like that
12:15:23 <ifthenelse> This isn't necessarily Haskell related, but you people are smart: How can I map a binary tree to a 2D coordinate system? Like, the height (y) is straightforward, but how would I do x? This is before I have the tree--I need to assign x as I start from root and go down the tree. Is it possible or do I need the entire tree?
12:15:34 <ReinH> chirpsalot: for instance game tree evaluation: you only evaluate the parts of the tree that you evaluate, saving space
12:16:10 <ReinH> ifthenelse: There are lots of ways to do that, BSPs for one
12:16:10 <callumacrae> It's going to take me a while to get used to lazy evaluation!
12:16:15 <callumacrae> I just ran let b = 1:b
12:16:18 <callumacrae> It did not like that
12:16:18 <chirpsalot> ReinH: yeah, I think my problem was vaguely similar to that if you squint a bunch. Same idea anyway -- only had to evaluate some of it so you saved a lot of space.
12:16:26 <ReinH> chirpsalot: yep!
12:16:32 <mm_freak_> chirpsalot: in general laziness makes things slightly slower…  the optimal eager program will be at least as good as the optimal lazy program
12:16:48 <mm_freak_> but it enables you to have infinite data structures and first class actions
12:16:48 <ReinH> callumacrae: sure it does
12:16:50 <ReinH> > let b = 1:b in take 5 b
12:16:51 <lambdabot>  [1,1,1,1,1]
12:16:51 <Iceland_jack> chirpsalot: If I recall LLVM does a sort of optimization where if it realizes you're trying to find a partial sum of the natural numbers it will basically replace it with n(n+1)/2
12:16:52 <Eduard_Munteanu> ifthenelse: if the tree nodes can be totally ordered you could use a space-filling curve
12:16:52 <chirpsalot> ReinH: which is why the C program exploded and the Haskell one didn't :P
12:16:57 <Iceland_jack> *recall correctly
12:17:04 <ReinH> callumacrae: mindblown.gif :)
12:17:18 <chirpsalot> Iceland_jack: hmmmm. That's cool. I bet a lot of programmers explicitly write sums too :P.
12:17:21 <ifthenelse> ReinH: That looks promising
12:17:22 <mm_freak_> so it trades a bit of performance for better code
12:17:46 <ReinH> ifthenelse: there are lots of options. edwardk knows them all.
12:17:48 <callumacrae> ReinH: b !! 9000 is pretty awesome
12:17:50 <ifthenelse> Eduard_Munteanu: Totally ordered? The tree is not complete, but each node has a unique numbering if that's what you mean...
12:18:31 <Eduard_Munteanu> ifthenelse: yeah, I mean if you can assign each node some numeric value, even for infinite trees
12:18:39 <ReinH> ifthenelse: oh you're working the other way: you have a tree and want to put it in a space?
12:18:47 <chirpsalot> mm_freak_: I think you're right. Technically speaking lazy evaluation is less efficient if you have to evaluate everything anyway, but if you can skip a bunch of computations with laziness you can get some nice speed ups with little thought.
12:19:04 <mm_freak_> ifthenelse: if this is about visualizing the tree, first map the 'BTree a' to a 'BTree (Pos, a)'
12:19:07 <ifthenelse> ReinH: I am creating a binary tree, starting from the root, and I want to assign each node an x value (with the height)
12:19:20 <mm_freak_> ifthenelse: this is a simple recursive map that understands spacing
12:19:29 <Iceland_jack> chirpsalot: It's not necessarily less efficient if you have strictness analysis
12:19:29 <ReinH> ifthenelse: look at Data.Tree's pretty printing functions
12:19:35 <ReinH> they're probably very close to what you want
12:19:39 <ifthenelse> mm_freak_: How so?
12:19:41 <ReinH> in terms of how they indent children
12:19:41 <edwardk> my favorite way to project k-ary _trees_ onto a screen is to use the poincare projection of the hyperbolic half-plane and subdivide angles. it ensures i always have room to lay everything out and all things are reachable with one mousemovement. but its not quite what you are asking for ;)
12:19:51 <ReinH> edwardk: aaaand there it is
12:19:53 <mm_freak_> chirpsalot: if GHC detects that you have to evaluate everything anyway, it will usually not do lazy evaluation at all
12:20:09 <mm_freak_> chirpsalot: nowadays GHC is very good at these low level optimizations
12:20:22 <edwardk> let me see if an old project of mine is online still so i can show what that means
12:20:37 <ReinH> edwardk: are you talking about this? http://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model
12:20:40 <chirpsalot> Iceland_jack: mm_freak_ yes, but then technically that's not lazy evaluation?
12:20:49 <Iceland_jack> chirpsalot: sure it is
12:20:50 <mm_freak_> chirpsalot: exactly
12:20:53 <ReinH> edwardk: oh this? http://en.wikipedia.org/wiki/Poincar%C3%A9_half-plane_model
12:20:58 <edwardk> well, ys, that is the underlying space. et me how you the visualization
12:21:07 <Iceland_jack> if it sees that it will need to evaluate something anyway, it evaluates it
12:21:17 <mm_freak_> chirpsalot: GHC doesn't implement lazy evaluation…  it does eager evaluation when it detects that it doesn't change semantics
12:21:35 <ifthenelse> mm_freak_: It's not necessarily about visualizing the tree, I just need an x and y for each node
12:21:52 <edwardk> ReinH: I used it on http://multitree.linguistlist.org/   apologies for the html 5 crap
12:21:56 <edwardk> er java crap
12:22:14 <chirpsalot> mm_freak_: yeah.
12:22:20 <ReinH> edwardk: ah yes
12:22:26 <ReinH> aternatively you can use a force directed layout, etc
12:22:40 <ReinH> d3js actually has a lot of layout engines that might be useful
12:22:56 <mm_freak_> ifthenelse: yeah, that sounds like a recursive function to me…  there are multiple ways to do it, and for a binary tree it's usually just:  figure out the width of the subtrees, allocate space
12:23:16 <mm_freak_> ifthenelse: two recursive functions:  one for getting the area of a node, one for allocating space
12:23:31 <ReinH> e.g. https://github.com/mbostock/d3/wiki/Force-Layout
12:23:33 <edwardk> yeah, the problem with force directed layouts is that they don't scale
12:23:38 <ifthenelse> mm_freak_: The nodes have no size here
12:23:54 <mm_freak_> ifthenelse: that's what the first recursive function is for…  it assigns a size to each node
12:23:57 <ifthenelse> mm_freak_: And I don't know the subtrees under it
12:24:02 <edwardk> if you have  tree that has 20 children at each node, 2-3 layers down, there isn't enough 'space' to lay everything out in without terrible bunching
12:24:20 * hackagebot smallcaps 0.4.1.3 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4.1.3 (StefanBerthold)
12:24:26 <edwardk> the poincare disk model is for a hyperbolic space, and so there is more space around each thing to lay more stuff out in
12:24:36 <jrmithdobbs> is there a decent cheatsheat for haddock quoting semantics somewhere? besides randomly swapping "/'/@ to remember i mean? ;p
12:24:39 <edwardk> so you can have a constant fanout tree forever, and always have enough room to draw the new nodes
12:24:52 <mm_freak_> jrmithdobbs: the haddock documentation
12:24:58 <jrmithdobbs> so no
12:25:05 <mm_freak_> =)
12:25:14 <ifthenelse> mm_freak_: Is the width of the subtree the number of leaves?
12:26:08 <mm_freak_> ifthenelse: size (Branch xs ys) = size xs ~+~ size ys
12:26:21 <mm_freak_> ifthenelse: where (~+~) is up to you
12:26:43 <mm_freak_> and size (Node x) = someSizeProbablyBasedOn x
12:27:13 <ifthenelse> mm_freak_: Which in my case, size (Node x Empty Empty) = 1
12:27:27 <mm_freak_> whatever 1 means there =)
12:27:35 <mm_freak_> pixels, centimeters, …
12:27:47 <mm_freak_> or just units
12:27:54 <ifthenelse> mm_freak_: Just a unit :)
12:28:11 <ifthenelse> mm_freak_:I plan to scale everything later for a density analysis
12:28:21 <mm_freak_> btw, this will be horribly inefficient
12:28:31 <mm_freak_> inefficient:  size :: BTree a -> Size
12:28:39 <mm_freak_> efficient:  size :: BTree a -> BTree (Size, a)
12:29:01 <mm_freak_> because then you can use sharing instead of recalculating the sizes all the time
12:29:31 <jrmithdobbs> mm_freak_: re: what you were saying about ghc automagically doing the right thing usually re: optimizations ... it's so much so that I swapped out a list for a Seq in some code to avoid a swap and performance stayed exactly the same because ghc was delaying the reverse until the right place any how
12:29:36 <jrmithdobbs> mm_freak_: i was impressed.
12:29:50 <jrmithdobbs> err to avoid a reverse*
12:30:11 <edwardk> wow. i just realized i don't know how to java any more. i can't unblock the security settings to run my own application. screw it
12:30:37 <ReinH> hahaha
12:30:41 <jrmithdobbs> edwardk: no they pushed some fixes to the code signing stuff that were like a decade over due so now you actually have to setup exceptions and such ;p
12:30:43 <mm_freak_> =)
12:30:54 <ifthenelse> mm_freak_: And then the x is just size/2, right?
12:30:58 <mm_freak_> edwardk: you did understand java?  i could never make sense of it
12:31:00 <jrmithdobbs> edwardk: it's not just you =/
12:31:01 <ifthenelse> mm_freak_: For that specific node?
12:31:12 <mm_freak_> ifthenelse: 'x'?
12:31:23 <edwardk> jrmithdobbs: my point is i can't run it in chrome on a mac, so i installed firefox. i installed java, and i can't find the settings to configure the exception list, and when i put it in something i thought was the exception list it didn't help
12:31:45 <ifthenelse> mm_freak_: If I want to map the binary tree to a 2d coordinate system, y is the height of the node and x is the horizontal placement
12:31:53 <edwardk> mm_freak_: i was a sun certified enterprise architect back in the day and used to make a living selling a java cryptography engine ;)
12:32:00 <jrmithdobbs> edwardk: right, it's not just you, i have the details from a coworker having same issues with some appliances' webuis if you want the location of the list ;p
12:32:03 <edwardk> mm_freak_: so once upon a time i understood this crap
12:32:05 <mm_freak_> ifthenelse: for b-trees that's probably okay, but there are better layouts
12:32:24 <edwardk> jrmithdobbs: i don't actually care. i just wanted to see some code i ran 8 years ago and play with it
12:32:43 <edwardk> jrmithdobbs: was going to try to run it myself before pasting a link to it for ReinH
12:32:46 <mm_freak_> ifthenelse: if your tree is deep and your picture is rectangular, you will find a lot of space wasted
12:32:59 <ifthenelse> mm_freak_: Oh? My ultimate goal is to find out where a collection of leaves are on the tree. It's HUGE, so I was going to do a density thing.
12:33:09 <jrmithdobbs> edwardk: the only correct response is "thanks again larry" really.
12:33:12 <jrmithdobbs> that guy.
12:33:20 <ifthenelse> mm_freak_: I was going to scale it to 0 to 1 height and 0 to 1 width
12:33:25 <edwardk> jrmithdobbs: all this has done is ensure i'll never actually bother to install the java plugin on my machine again.
12:33:57 <ifthenelse> mm_freak_: The reason for the scaling is that the height is REALLY SMALL compared to the width
12:33:57 <edwardk> ReinH: anyways, in theory http://multitree.linguistlist.org/trees/Niger-Congo%3A%20Ethnologue%202005 shows off the poincare layout. i can't check ;)
12:34:00 <jrmithdobbs> edwardk: same. only reason i know about it is said coworker wanted me to test something because I hadn't upgraded the jvm ... because it turned out i'd never installed it so couldn't test anyways ;p
12:34:05 <mm_freak_> ifthenelse: it would be my first attempt to make it work and see results…  you can employ better layouts later
12:34:05 <ReinH> ha
12:34:08 <edwardk> and i have no idea what they've done with it in the intervening years
12:34:18 <magicman> I once said. "Okay. This weekend, I'll spend the entire two days to install an actual later version of java, and fix this whole security thing."
12:34:20 <ReinH> oh lol Java not even once
12:34:21 * hackagebot chatty 0.1.4.0 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.1.4.0 (implementation)
12:34:26 <ReinH> edwardk: apparently I don't even have it installed
12:34:29 <magicman> I ended up with an older version of Java than I had in the first place <_<
12:35:06 <ReinH> edwardk: http://www.jasondavies.com/poincare-disc/
12:35:14 <ifthenelse> mm_freak_: Good point--I'm just not aware of other layouts at the moment :P
12:35:20 <mm_freak_> ifthenelse: btw, for the actual visualization you may be interested in the diagrams library =)
12:35:22 <ifthenelse> mm_freak_: Thank you for your help!!
12:35:33 <ifthenelse> mm_freak_: In haskell?
12:35:39 <notdan> Wtf, why is brainpickings.org banned in my country?..
12:35:52 <mm_freak_> ifthenelse: alternatively for live animated visualization you can use gloss (it allows you to move through the diagram and zoom in/out)
12:35:56 <mm_freak_> ifthenelse: yeah
12:36:41 <notdan> oops, sorry wrong chan
12:36:41 <ifthenelse> mm_freak_: Oh my. I don't know if visualizing this tree is a good idea without scaling, though
12:37:14 <mm_freak_> ifthenelse: you don't really need to worry about scaling…  both libraries use vector graphics
12:37:15 <callumacrae> The beginners tutorial I'm reading just casually mentioned infix functions and then moved straight on
12:37:19 <callumacrae> .-.
12:37:45 <jrmithdobbs> not much reason to linger, you can turn any function into one by surrounding its name with ``
12:37:54 <ifthenelse> mm_freak_: But the tree is extremely wide :/
12:37:57 <mm_freak_> ifthenelse: gloss uses opengl with Float, so you may hit the precision barrier, if your tree is really that large =)
12:37:59 <jrmithdobbs> what else is there to say until you're worried about precedence?
12:37:59 <callumacrae> Yep I googled it!
12:38:57 <ifthenelse> mm_freak_: I mean, compared to the height. So it looks like a 1D line on my screen.
12:39:28 <mm_freak_> ifthenelse: well, you can scale by applying a scaling function
12:39:40 <mm_freak_> it's vectors
12:40:41 <ifthenelse> mm_freak_: I'll see how it goes haha
12:54:28 * hackagebot bytestring-from 0.1 - A type-class to convert values from ByteString.  http://hackage.haskell.org/package/bytestring-from-0.1 (ToralfWittner)
12:55:57 <acowley> Wow, naming that package bytestring-from seems like a bit of a miss. I'm looking forward to the serialization counterpart called from-bytestring.
12:58:22 <wyager> Hi guys. New to Haskell. Haskell complains that it expects an argument to "Region" in line 6. I just want it to work with any kind of region. http://pastebin.com/kWhVXmup
12:59:03 <Iceland_jack> wyager: Region is not a type but a type class
12:59:04 <eacameron> how can I find a list of all "top level" library groups? Like Data, Control, etc
12:59:26 <wyager> Iceland_jack: Right, so is there any way to make a datatype that will work with any type in a type class?
12:59:27 <adelbertc> eacameron - inspect base?
12:59:41 <wyager> Or rather, what is the proper way to do what I intend?
12:59:41 <adelbertc> eacameron - http://hackage.haskell.org/package/base
12:59:49 <Iceland_jack> wyager: Normally you don't do that, you make the data type polymorphic and constrain the functions that work with them
12:59:56 <mm_freak_> wow, the OpenAL bindings are a wonderful example of how to do documentation right!
13:00:00 <eacameron> adelbertc: oh interesting
13:00:13 <eacameron> adelbertc: That'll do, thanks!
13:00:26 <adelbertc> np
13:00:40 <mm_freak_> i've never seen such a well-documented haskell library
13:00:44 <wyager> Iceland_jack: Meaning, in the definition of the "Region" type, I would have to list every kind of Region?
13:01:00 <wyager> *"Region" data type
13:01:48 <wyager> I figured that there might be really complex kinds of Regions, so I wanted to be able to define their behaviors separately
13:02:10 <wyager> If I understand what you're saying, it sounds like I would have to define what each function does to every kind of Region in the same place
13:02:57 <Iceland_jack> wyager: I'm sorry, I have to bolt: hopefully someone else can help
13:03:06 <wyager> Thanks. Anyone?
13:06:19 <ski> wyager : may a region contain more information than what points it covers ?
13:06:58 <wyager> ski: They may be arbitrarily complex. Some will be geometric shapes, some will be intersections or exclusions or unions of other regions. Some may be defined by complicated topological formulas.
13:07:08 <mm_freak_> wyager: your 'Region' type class seems fine for what it does, except that i would have called it 'Subset'
13:07:19 <ski> wyager : ok. that didn't answer my question, though :)
13:07:33 <wyager> ski: I suppose so. I don't plan on doing that, though
13:08:12 <wyager> mm_freak_: OK, but I'm still not sure how to make an Intersection Data Type that holds 2 regions of any other type
13:08:19 <ski> wyager : stated another way, would `newtype Region = MakeRegion {contains :: Point -> Bool}' be too restrictive ?
13:08:28 <mm_freak_> wyager: the idea of Intersection works, except that i would have used (,) instead of a custom type
13:08:43 <mm_freak_> wyager: then:  instance (Region a, Region b) => Region (a, b)
13:09:22 <mm_freak_> (s1, s2) `contains` p = s1 `contains` p || s2 `contains` p
13:10:03 <ski> wyager : with my approach, you'd get `intersection :: Region -> Region -> Region'
13:10:29 <wyager> Hmm
13:10:36 <mm_freak_> wyager: what ski is saying a value of a Region type is really just a function from points to bools
13:10:42 <wyager> I see
13:11:01 <mm_freak_> so here is the type of all regions:  newtype Region = Region { contains :: Point -> Bool }
13:11:31 <ski> wyager : if you want to be able to extract any other information from a region than, for each point, whether it contains it, you couldn't use my approach, at least not straight off
13:12:01 * ski already did the `newtype', though
13:12:22 <mm_freak_> also if you do intersections a lot, then the approach doesn't scale well
13:14:04 <wyager> I guess I'm having trouble grasping what you guys are suggesting
13:14:16 <wyager> I mean, I get the idea of having a function that returns a boolean as a region
13:14:26 <wyager> but I'm not sure how I would polymorphically use something like that
13:14:48 <wyager> Let me try writing it out
13:15:24 <ski> no need for polymorphism in the indicator function case. the `Region' type already contains every possible region
13:16:29 <ski> wyager : another approach might be `data Region = Intersection Region Region | GeometricShape ... | Union Region Region | Except Region Region | TopologicalFormulae ...'
13:16:56 <Iceland_jack> wyager: (back) it depends on whether you want a deeb or shallow embedding
13:16:57 <Iceland_jack> *deep
13:17:10 <wyager> What does embedding mean here?
13:17:17 <mm_freak_> wyager: a picture can be thought of in two ways:  either as an array of colors or as a function from points to colors
13:17:21 <ski> with that, you fix before hand which primitive possible ways you have of making a region (possibly out of other regions)
13:17:30 <mm_freak_> wyager: what you're having is a monochrome picture
13:17:40 <mm_freak_> so it's a function from points to booleans
13:17:46 <Iceland_jack> wyager: of a problem into Haskell, a sort of embedded domain-specific language for evaluating regions
13:18:55 <Iceland_jack> wyager: http://www.cse.chalmers.se/edu/course/afp/lectures/lecture2/Shape/Shallow.hs.html versus http://www.cse.chalmers.se/edu/course/afp/lectures/lecture2/Shape/Deep.hs.html
13:19:29 <Iceland_jack> The shallow version says that 'Shape = Point → Bool'
13:19:58 <ski> wyager : "deep embedding" means you represent each (or most) of the possible ways to construct values of your type as data constructors
13:20:32 <Iceland_jack> where each operation is written as a function
13:20:32 <Iceland_jack>     empty = const False
13:20:33 <wyager> I see
13:20:34 <mm_freak_> wyager: it's fancy vocabulary for distinguishing "as a function" and "as (recursive) data" =)
13:20:35 <Iceland_jack> The deep version represents those as actual primitives
13:20:39 <ski> wyager : "shallow embedding" means that you think hard about the intended behaviour of your type, and implement it as any instance of that behaviour
13:21:06 <mm_freak_> wyager: of course that's a simplistic view, but it suffices as an intuition
13:21:08 * ski originally learned "deep vs. shallow" the other way around
13:21:09 <Iceland_jack> Shallow embeddings are trickier to come up with and can be much trickier to work with (if badly designed)
13:21:25 <Iceland_jack> but they're generally more elegant
13:22:24 <mm_freak_> deep natural numbers:  data Nat = Zero | Succ Nat
13:22:48 <mm_freak_> shallow natural numbers:  newtype Nat = Nat (forall a. a -> a)
13:23:09 <mm_freak_> uhm
13:23:11 <ski> itym `newtype Nat = Nat (forall a. (a -> a) -> (a -> a))'
13:23:15 <acowley> I think I learned deep and shallow the other way around, too
13:23:15 <mm_freak_> shallow natural numbers:  newtype Nat = Nat (forall a. (a -> a) -> (a -> a))
13:23:17 <mm_freak_> rather that
13:23:37 <mm_freak_> according to the source codes Iceland_jack referenced
13:23:40 <ski> acowley : in my case, our teacher taught it the other way around
13:23:48 <wyager> OK, I think I'm getting the difference. Let me write the region thing as a shallow version and you guys can tell me if it makes sense
13:24:17 <acowley> ski: I won't blame anyone other than myself, I probably got it backwards. However, I think all these terms are of somewhat limited utility
13:24:56 <mm_freak_> wyager: as an exercise implement a circle as a region…  you must not enumerate the points when doing that =)
13:24:57 <ski> deep vs. shallow seems related to variant vs. record (or, to put it crudely, FP vs. OOP)
13:25:06 <acowley> You start out writing some data structures, then you call it an AST for a DSL, but since you're coding it up, you say it's an EDSL, then you qualify that yet again ... six months later you tell somebody you wrote a library.
13:25:30 <mm_freak_> btw, i think i've never needed the distinction
13:27:15 <acowley> I think the way you said it, "as a function" vs "as data" is pretty helpful
13:29:54 <wyager> OK, so here's a potential advantage of using data versus a function that I just ran into. You can't make a function derive Show, can you?
13:30:21 <acowley> That's one result of not being able to pattern match on them in general
13:30:55 <Iceland_jack> wyager: You can
13:31:04 <Iceland_jack> it's just of limited use
13:31:21 <Iceland_jack> If the domain is an instance of Enum and Bounded you could enumerate every element in the Domain and.. hm
13:32:38 <Saizan> what you'd do is have a String representation as one of the outputs of your function
13:32:50 <Saizan> like having a toString method in OO
13:35:31 <wyager> OK, here's my attempt at a shallow version. How is this? http://pastebin.com/LWPUg7yx
13:37:15 <ski>   circle :: Point -> Float -> Region
13:37:35 <ski> `(x - x2)*(x-x2)' is `(x - x2)^2'
13:37:48 <quchen> And squaring is much faster than sqrt
13:37:52 <wyager> I see
13:37:54 <wyager> Good point
13:37:56 <wyager> let me revise
13:38:00 <ski> `(sort (...)) < radius' is `sort (...) < radius'
13:38:37 <ski> well, since this is floating-point, `(x - x2) ** 2', i suppose
13:39:00 <quchen> > (2.0 :: Double)^2
13:39:01 <lambdabot>  4.0
13:39:03 <wyager> OK
13:39:03 <wyager> http://pastebin.com/HM2QatSh
13:39:24 <quchen> ski: ** is required if you want non-integer exponents
13:39:31 <wyager> Damn
13:39:40 <ski> > 2.0 ^ 2 :: Expr
13:39:41 <ski> > 2.0 ** 2 :: Expr
13:39:41 <lambdabot>  2.0 * 2.0
13:39:42 <lambdabot>  2.0**2
13:39:50 <ski> quchen : i know
13:39:52 <wyager> Are you sure? I just did 9.9^2 and it gave me the right answer
13:40:16 <ski> `2' is an integer
13:41:28 <wyager> OK, now let me implement it deeply
13:41:31 <ski> btw, `type Region = (Point -> Bool)' could be written `type Region = Point -> Bool'
13:41:43 <wyager> Thought the parens were clearer
13:42:05 * ski isn't overfly fond of redundant brackets :)
13:42:07 <ski> (ymmv)
13:42:14 <ski> s/overfly/overly/
13:42:42 * ski evades the overfly, overflying it
13:43:33 <ski> wyager : note that the shallow embedding here gives more opportunities for optimization
13:44:25 <mm_freak_> when using xmonad GLUT and GLFW don't go into fullscreen properly…  any ideas?
13:44:44 <ski> wyager : er, sorry, s/shallow/deep/
13:44:59 * ski stares crosseyed at channel
13:45:16 <wyager> deep means actually storing as a recursive data structure?
13:45:27 <wyager> right?
13:45:35 <ski> more or less (doesn't *have* to be recursive, though usually is)
13:46:03 <ski> the main point is using a data constructor for each "primitive means of constructing"
13:46:12 <ski> (where "primitive" is up to interpretation)
13:46:52 <ski> btw, another variant of a shallow embedding is `newtype Region = MakeRegion {contains :: Point -> Bool,intersection :: Region -> Region}' (note that this would be a recursive *shallow* embedding)
13:47:38 <wyager> I'm still not sure what that means
13:47:43 <ski> which ?
13:47:52 <wyager> I don't really get newtype vs data
13:48:00 <wyager> That's the first I've seen of newtype
13:48:03 <wyager> very new to this :)
13:48:08 <ski> erp, sorry, s/newtype/data/ :)
13:48:28 * ski displayes a strained smile
13:51:44 <byorgey> a shallow embedding is any algebra for your language. a deep embedding is the initial algebra.
13:51:54 * byorgey realizes this is not helpful to wyager =)
13:52:57 <wyager> Haha yeah I have no idea what that means
13:53:22 <ski> the question there is what operations are allowed into the signature of the algebra
13:55:21 <acowley> The hsdevtools github page says it can get type information on expressions. Is there any UI for this from within emacs?
13:55:45 <levi> byorgey: I was just pondering the difference between shallow and deep embeddings; that's nice concise way to put it. As long as you know what it means, of course.
13:55:54 <byorgey> levi: right =)
13:56:51 <byorgey> another (equivalent) way to put it is that shallow embeddings are folds over a deep embedding.  I learned this from Jeremy Gibbons.
13:57:19 <byorgey> he has a nice writeup with some observations about shallow vs. deep embeddings, but I don't think it's published yet
13:57:48 <byorgey> ski: yes, good point
13:57:54 <levi> acowley: I have figured out how to hook up on-the-fly error reporting with hdevtools, but not type queries. On the other hand, ghc-mod has a nice emacs mode (the ghc package) that makes it easy.
13:58:20 <acowley> levi: Yes, I use ghc-mod and am a big fan
13:58:34 <byorgey> acowley: I think chrisdone's structured-haskell-mode can do that?  I haven't actually tried it out yet
13:58:37 <acowley> levi: However, speed is an issue with some packages I work on
13:58:45 <levi> byorgey: That makes sense, since the fold over an algebra provides an interpretation of it.
13:59:13 <acowley> byorgey: I spent a week with shm and submitting issues and such, but I needed to take a break from it
13:59:13 <levi> I think SHM primarily catches syntactic issues, unless it's been upgraded very recently.
13:59:23 <byorgey> levi: right.  in particular, the existence of a fold is what witnesses the fact that the initial algebra is initial.
13:59:27 <byorgey> acowley: ah, fair enough =)
13:59:30 <acowley> byorgey: But it doesn't do all these things on its own
13:59:34 <wyager> OK, wrote it with deep embedding. How is this? http://pastebin.com/BFzz4b6R
13:59:39 <acowley> the main choices are ghc-mod and hsdevtools
13:59:46 <acowley> one is full of features, one is fast
14:00:50 <byorgey> fast, featureful, not broken: choose any two
14:01:53 <levi> byorgey: I answered a Stack Overflow question at one point and ended up finding some nice papers about the duality (in this very sense) between the Peano-encoding of numbers and the Chruch-encoding.  I guess it's the basic expression of this idea.
14:02:29 <ski> wyager : nice
14:02:49 <ski> wyager : fyi, you can omit the brackets around `Circle (x,y) radius' (and in the other case as well)
14:03:18 <wyager> huh
14:03:42 <ski>   Circle (x,y) radius `contains` (x2,y2) = (x-x2)^2 + (y-y2)^2 < radius^2
14:03:48 <ski>   Intersection s1 s2  `contains` point = (s1 `contains` point) && (s2 `contains` point)
14:04:14 <quchen> You can also leave the parentheses around the `contains` away.
14:04:28 <quchen> Default fixity is infixl 9.
14:04:29 <wyager> True. I guess I'm a sucker for explicit parenthiation
14:04:41 <wyager> (what's the correct word?)
14:04:51 <acowley> (not parenthiation)
14:05:01 <wyager> (no kidding)
14:05:01 <byorgey> levi: right
14:05:04 <quchen> Parentesization?
14:05:14 <acowley> parent size nation?
14:05:19 <acowley> parenthesization
14:05:20 <wyager> parenthesization
14:05:26 <wyager> Ugh
14:05:34 <wyager> we need to make a better word for that
14:05:35 <levi> And on a not-entirely unrelated tangent, today while procrastinating real work I ran across Bob Atkey's paper applying Reynolds' relational parametricity to equations in classical mechanics, which turns out to give conservation laws as a result of free theorems.
14:05:57 <byorgey> levi: ah yes, I've been meaning to read that
14:06:18 <byorgey> it's such a beautiful idea
14:06:37 <kristof> Theorems for free!
14:06:51 <kristof> I don't know why some people are so averse to having mathematical concepts rule their programming when you get FREE STUFF
14:06:56 <kristof> who doesn't like free stuff?
14:07:04 <hpc> you get what you pay for ;)
14:07:45 <prophile> as Martin Luther King said, "thank God almighty we are left adjoint to a forgetful functor at last"
14:08:25 <levi> byorgey: I actually just read his slides on it; they're sparse but pretty and I probably wouldn't have been inclined to dig into the meat of it anyway. :)
14:08:37 <quchen> kristof: The price of free theorems is you have to know about free theorems.
14:08:41 <byorgey> levi: fair enough =)
14:09:35 <levi> The first rule of free theorems is you don't talk about free theorems. :P
14:09:39 <ski> > (circle (-1,1) 2 `intersection` circle (1,1) 2) `L.contains` (2,2)
14:09:41 <lambdabot>  False
14:09:46 <ski> > (circle (-1,1) 2 `intersection` circle (1,1) 2) `L.contains` (0,0)
14:09:48 <lambdabot>  True
14:10:16 <bennofs> Why is there no modifyM :: (a -> m a) -> StateT a m () ?
14:10:34 <kristof> quchen: People programming in OO look up design patterns every so often. So it's not unreasonable that people would open up a type-pedia saying "hmm, does this type signature give me any theorems for free?"
14:10:49 <hpc> :t (>>= put)
14:10:49 <lambdabot> MonadState a m => m a -> m ()
14:11:07 <quchen> kristof: There is a giant industry around OO though, not so much around languages that support free theorems
14:11:14 <levi> byorgey: I did read through the paper he published around the same time with Conor McBride about "Productive Coprogramming", which was also pretty interesting in a much more practical (to me) sense.
14:11:36 <bennofs> :t StateT . fmap (fmap (swap . return))
14:11:37 <lambdabot> (Monad ((,) a), Functor f) => (a -> f b) -> StateT a f b
14:11:38 <kristof> quchen: If I may evangelize for a second, I think people are really interested in very CORRECT software.
14:11:46 <kristof> quchen: And Haskell does that best.
14:11:58 <bennofs> :t StateT . fmap (fmap return)
14:11:59 <lambdabot> (Monad ((,) a), Functor f) => (a1 -> f a1) -> StateT a1 f a
14:12:00 <kristof> well Agda does that best, but . . .
14:12:14 <ski> @type MakeRegion
14:12:15 <lambdabot> (Point -> Bool) -> (Region -> Region) -> Region
14:12:37 <Rylee> @hoogle circle
14:12:38 <lambdabot> package circle-packing
14:12:44 <Rylee> @src circle
14:12:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:12:54 <quchen> kristof: If only.
14:13:07 <ski> Rylee : try define it yourself ?
14:13:13 <quchen> (For the "people are interested in correct software" part)
14:13:46 <kristof> quchen: Not "if only", people really are interested in that. Look at how much money goes to fixing random bugs.
14:14:06 <kristof> quchen: Dependently typed systems are going to seal the deal and people are going to invest in these technologies even more.
14:14:36 <quchen> People build flappy bird clones with Javascript. That's what happens.
14:14:53 <kristof> quchen: And I don't care how "hard" these tools are. Nobody complains that a person can't fly a plane after training, so why are we so dependent on critical software tools being munged together with awful tools?
14:15:02 <kristof> *after only a month of training
14:15:57 <levi> There are definitely places where people are interested in correct software, but for the vast majority of products it's deemed too expensive so far. But I think dependently typed languages probably will help strike a new cost/benefit balance in favor of more safety.
14:16:12 <ryantrinkle> is there any way to limit the heap and/or CPU usage of a particular thread or computation?
14:16:34 <quchen> ryantrinkle: You can use ulimit to cap memory size iirc
14:16:39 <quchen> Check ulimit -a
14:16:41 <luite> ryantrinkle: ezyang is working on resource limits for that
14:17:10 <ryantrinkle> quchen: hmm; i was hoping to have it in the same process
14:17:11 <luite> ryantrinkle: dunno about the current state, it's not in stable ghc, he talked about it at the haskell symposium
14:17:20 <ryantrinkle> ah, ok
14:17:25 <ryantrinkle> so probably will be a while, then :P
14:17:38 <quchen> luite: I'm sure it will be merged into 7.8 soon ಠ_ಠ
14:17:49 <ryantrinkle> are there any weird issues with forking haskell processes?
14:18:05 <quchen> What's forking a Haskell process?
14:18:17 <ryantrinkle> like, using unix's fork()
14:18:28 <luite> ryantrinkle: forkOS? yeah that's tricky with the threaded runtime, kills other capabilities. i could only get it to work reliably with the singlethreaded runtime
14:18:32 <ryantrinkle> i've got big immutable caches, which i'd like the resource-limited things to share
14:18:45 <ryantrinkle> but if the only way to limit resources is using OS processes
14:18:54 <ryantrinkle> that'll be troublesome
14:19:36 <quchen> luite: Is GHCJS still in active development? Haven't heard much of it since a couple of months ago, which amounted to "7.8 will make a release possible"
14:20:10 <ijp> someone on #scheme was asking about the names foldl and foldr. I've managed to trace them back to at least Bird and Wadlers "introduction to functional programming" in 1988. anyone know of those names being used earlier?
14:20:26 <luite> quchen: yeah it is, it's been a bit quiet for a while because i had some other work to do, but i'm working on it again now
14:20:44 <luite> quchen: i updated everything ot make it build with ghc 7.8 rc last week
14:20:51 <luite> and am debugging some problems now
14:21:08 <quchen> luite: GHCJS is STG -> JS, isn't it?
14:21:36 <luite> quchen: i'm going to new zealand in a few days, where i'll have more time to hack on it, an dhopefully be able to have a talk at the wellington and sydney user groups
14:21:43 <luite> quchen: yeah
14:22:05 <quchen> I was wondering about how much GHC code GHCJS can compile. I remember you talked about a GHCJS Platform, but that's your-last-talk time ago.
14:22:30 <ijp> byorgey: I have a bunch of corrections (mostly typos) to Software Foundations. Where should I send them to?
14:22:33 <levi> ijp: I'm fairly sure they go back further, but I'd have to dig a bit more to be sure.
14:22:55 <luite> quchen: you mean code of the GHC compiler itself?
14:22:58 <ijp> (I ask because I see your name on the cover :)
14:23:11 <quchen> luite: No, as in "What part of GHC-buildable code can GHCJS build"
14:23:23 <luite> quchen: oh, quite a bit actually
14:23:53 <quchen> I remember how amazed I was when you compileg Gloss stuff with GHCJS. That looked like magic.
14:24:07 <luite> quchen: gloss is pretty simple actually
14:24:28 <quchen> luite: Sure, but it's OpenGL. How does that translate to JS?
14:24:31 <luite> quchen: threading, STM, IO (with buffering) etc all work, gloss uses none of that
14:24:36 <quchen> Or did you use some gloss-js package
14:24:55 <luite> quchen: oh, i used a custom backend that translates the gloss primitives to canvas calls
14:25:11 <luite> quchen: mapping OpenGL to WebGL is not impossible, just a bit more work
14:25:25 <levi> ijp: As it's hosted on Benjamin Pierce's web space, he'd probably be the right one to send them to.
14:25:28 <quchen> Aah, that answers my #1 mystery with GHCJS :-)
14:25:50 <byorgey> ijp: you can send them to me
14:26:22 <quchen> luite: So what parts of GHC can't GHCJS work with yet? What's missing for feature completeness?
14:26:31 <byorgey> levi: Benjamin isn't teaching it this semester, actually
14:26:36 <bennofs> Does seq have any effect on functions?
14:26:41 <luite> quchen: there are two ways you can interact with JavaScript, either you use the "foreign import javascript" syntax and splice snippets of JS directly in your haskell, or you leave the "foreign import ccall" things, and for every imported C function, you write a JS wrapper
14:26:45 <quchen> (I asked this already some time ago, mainly to follow up with "can we expect a JS CG merge")
14:26:53 <Forgetaboutit> speaking of GHCJS, what's the current status?  Is it any good?
14:27:06 <hpc> ijp: http://scholar.google.com/scholar?start=10&q=foldr&hl=en&as_sdt=0,47&as_ylo=1980&as_yhi=1985 -- scholar search for "foldr" from 1980 to 1985
14:27:10 <levi> byorgey: Ah, you guys swap maintainership according to who's actively teaching from it?
14:27:18 <luite> Forgetaboutit: it's almost possible to install it with weird virtual machines etc!
14:27:26 <quchen> bennofs: Sure
14:27:38 <Forgetaboutit> luite: hehe
14:27:38 <hpc> ijp: "Parton distribution functions for twist 4" looks like the earliest use of it as a mathematical identifier
14:27:39 <quchen> > (undefined :: a -> b) `seq` ()
14:27:42 <lambdabot>  *Exception: Prelude.undefined
14:27:51 <byorgey> levi: not really, I just mean Benjamin is probably focusing on other things this semester.  There are actually quite a lot of people with push access.
14:27:51 <quchen> > (id :: a -> a) `seq` ()
14:27:52 <lambdabot>  ()
14:27:57 <luite> quchen: no major features are missing, but some of the Haskell <-> JS interaction API would probably need to be expanded
14:27:57 <levi> There are sure a lot of partially-worked copies of Software Foundations hanging out on github.
14:28:18 <Forgetaboutit> luite: not sure if I'd enjoy the experience ;)
14:28:24 <luite> quchen: all primitives are supported except single precision float (which gets upgraded to double precision silently)
14:28:36 <jophish> Yo yo yo
14:28:44 <hpc> ijp: the first reference that's related to functional programming is this in 1985
14:28:48 <hpc> ijp: http://books.google.com/books?hl=en&lr=&id=AiMwYZs-TGkC&oi=fnd&pg=PA1&dq=foldr&ots=psob_Gmo2a&sig=WB5REQCkbVcJECL4l4wDJ9FLXU4#v=onepage&q=foldr&f=false
14:28:51 <luite> quchen: and there are some limitations around Addr# (used in Ptr), since JS doesn't have real pointers
14:28:59 <jophish> What vim plugin can people recommend for jumping to a definition?
14:29:04 <hpc> which talks about miranda
14:29:12 <luite> quchen: and `par` can't be used effectively since JS is single threaded
14:29:41 <luite> quchen: there are some issues left with memory management and weak references, but that's more a bug than a missing feature
14:29:49 <hpc> (that puts the book being published in the same year as miranda's first public release)
14:29:49 <quchen> luite: So the whole STM/MVar features are only virtual? Like when compiling with GHC without -threaded?
14:30:08 <ijp> hpc: hmm, I should have figured it was miranda
14:30:40 <luite> quchen: yeah, but the haskell threads work like those in hative haskell code in the single-threaded runtime, i.e. forkIO threads are transparently preemptively scheduled
14:30:59 <hpc> if i had a uni IP i would read that first paper and see wtf is going on
14:31:12 <luite> quchen: and you can block a forkIO thread on an AJAX call while other thread continue to run
14:31:22 <hpc> because it's dated 1983 and appears in a nuclear physics journal
14:31:30 <luite> quchen: and for example kill that blocked thread with throwTo
14:31:35 <hpc> anyway, scholar.google.com ftw
14:32:34 <luite> quchen: i'm not sure that's possible with the single threaded runtime and ccall imports
14:32:42 <hpc> google's preview stops right at the word "foldr"
14:32:49 <hpc> "y''=foldr..."
14:32:51 <hpc> >:(
14:33:52 <acowley> hdevtools did not grok my sandbox. Quick end to that experiment.
14:34:19 <luite> quchen: actual parallellism would be possible with web workers, and the runtime does support copying computations to another worker, but there's no application using that functionality at the moment
14:34:24 <quchen> luite: "If you are from the future, you have GHC 7.8 or higher installed, and Cabal 1.18, run the following:" hehe
14:34:41 <luite> quchen: yeah make that a Cabal 1.20 or something, missed the deadline
14:35:18 <quchen> Have you compared GHCJS performance to idiomatic JS, or is that still just barely on the horizon?
14:36:00 <luite> quchen: that said, with the Cabal branch from the ghcjs repo and teh most recent ghcjs master, it's only a few commands to get it up and running
14:36:04 <luite> outside a vm
14:37:12 <luite> quchen: hard to compare, since it's hard to write something that's actually doing the same thing
14:38:21 <luite> quchen: compared to native GHC some things are pretty fast, fib n = fib (n-2) + fib (n-1) runs ~7x slower than the native code compiled with -O2
14:38:43 <luite> quchen: but when more allocation is involved things get slower in JS
14:39:23 <quchen> Still sounds like the same order of magnitude at least
14:39:25 <luite> and the integer library (JSBN) is a lot slower than GMP
14:39:44 <jophish> Is there a way to keep tag files in ~/.vim
14:40:17 <Forgetaboutit> luite: do you also have any idea of how big the compiled JS is compared with the Haskell code?
14:40:24 <jophish> oops, wrong channel
14:41:04 <luite> Forgetaboutit: it's a lot bigger than the haskell code since it includes lots of RTS things
14:42:27 <Forgetaboutit> luite: Hm, as long as you can get a reasonably complex program to weigh under ~500kB, it'd be great
14:43:11 <Forgetaboutit> luite: reasonably complex ~> 500 lines or so
14:43:41 <luite> Forgetaboutit: uncompressed/unminified it's bigger at the moment, but there's still lots of room for improvement (for example the rts includes lots of functions that are hardly used, and can easily be replaced by one, slightly slower, generic function, and all programs include a lot of the standard GHC buffered IO dependencies that also handle locale, character encoding)
14:43:47 <luite> both can be cut without much effort
14:44:33 <jfischoff> luite: the RTS is a one time cost though. What is the overhead in general compared to hand rolled, what's your guesstimate?
14:45:00 <luite> jfischoff: to hand rolled js?
14:45:27 <Forgetaboutit> luite: that'd be great!  I honestly don't like the current options in the browser so far.  Even though a lot of languages target JS by transpiling somehow, it never really feels right.
14:45:49 <luite> jfischoff: hmm, still hard to say, sorry, still pretty big though i guess
14:48:24 <luite> jfischoff: the concurrency support adds a lot of weight unfortunately, to force some thunk you can't call a function that forces it, you have to do it indirectly, pushing state on the stack. that adds to the code size
14:48:46 <luite> jfischoff: although i've explored an alternate runtime that does just direct calls, but it's not yet in the current ghcjs
14:48:58 <luite> you lose preemptive threads there obviously
14:50:06 <levi> ijp: Are you interested specifically in 'foldl' and 'foldr' or the general use of 'folding' as a name for a recursion operation?
14:52:24 <luite> jfischoff: but i suspect many stack frames do exactly the same thing with very minor variations, so there can be big gains in identifying that
14:53:29 <ijp> levi: the latter
14:54:38 <jfischoff> cool
14:54:54 <ijp> based on the miranda paper above, I reckon there is a good chance it was in one of turners earlier languages
14:56:00 <ijp> yep, sasl language manual has it
14:56:41 <ijp> hmm, assuming it was not added in the second version
14:57:05 <levi> ijp: The earliest reference I can find is R. M. Burstall and J. Darlington, "A Transformation System for Developing Recursive Programs"
14:58:55 <levi> This was cited in Lambert Meertens' "Algorithmics" as the source of the terminology he used.
15:01:56 <levi> Anyway, the Burstall and Darlington paper was dated '75.
15:02:59 <edwardk> lambert meertens is the source of all the early faux greek/roman  cata-morphism, ana-morphism, hylo-morphism stuff
15:03:26 <edwardk> regarding 'fold' itself, i'm not sure
15:03:55 <levi> edwardk: Like I said, the citation I found was in Meertens' book as the source of the 'folding' terminology.
15:04:08 <edwardk> fair nuff
15:04:12 <JuanDaugherty> quick googling indicates hylomorphism, the term is due to aristotle
15:04:23 <JuanDaugherty> guess like leibniz and monads
15:04:40 <levi> JuanDaugherty: I'm pretty sure Aristotle was not talking about a recursion scheme, though. :)
15:04:41 <JuanDaugherty> zounds wooden
15:05:03 <edwardk> JuanDaugherty: different derivation of the term
15:05:15 <monochrom> and leibniz, not the fmap-pure-join triple :)
15:05:46 <suppi> hi
15:05:52 <levi> Not many of the references you find in 70s papers are available online.
15:06:11 <JuanDaugherty> well not in the public internet
15:06:11 <suppi> I'm new to haskell and i'm trying to compile a program with ghc
15:06:19 <monochrom> yeah, I painstakingly photocopied those papers from the university library
15:06:20 <JuanDaugherty> depends on what you mean by online
15:06:25 <Iceland_jack> hi suppi
15:06:25 <levi> There are some interesting titles, though: "Characterizations of flowchartable recursions"
15:06:26 <suppi> and I get "Could not find module 'System.IO.Strict'
15:06:45 <levi> "Flowchartable" is not something you hear much today. :)
15:06:47 <suppi> hi Iceland_jack
15:06:59 <monochrom> flowchartable recursion is going to be tail recursion
15:07:30 <JuanDaugherty> accessible at any major university library vs. freely accessible anonymously on the open intenet
15:07:33 * monochrom drew a few flowcharts when learning and using BASIC!
15:08:06 <suppi> I don't really know how to solve this, is System.IO.Strict not a part of the "standard library"?
15:08:22 <suppi> do I need to download the package from somewhere?
15:08:38 <JuanDaugherty> r
15:08:40 <monochrom> it is not part of the standard library. find it in "strict-io" IIRC
15:09:12 <monochrom> http://hackage.haskell.org/package/strict-io may be the one
15:09:44 <suppi> thanks. i'll check it out
15:09:53 <levi> From the beginning of a paper by Gordon Plotkin: "If let loose, resolution theorem-provers can waste time in many ways."
15:10:22 <JuanDaugherty> he had no idea did he?
15:11:27 <JuanDaugherty> maybe up to a certain point all animal existence is wasted time, or after one
15:11:35 <Eduard_Munteanu> What's a nice convention for naming CPS-style functions? I'm thinking of foo |-> fooing
15:11:36 <suppi> thanks and good night
15:11:52 <monochrom> resolution is hard. let's go model elimination. :)
15:12:46 <JuanDaugherty> in that nasty/brutish stretch between lang/thought and not being an animal anymore
15:13:05 <monochrom> HOL4's CPS-style functions use the naming scheme foo |-> foo_THEN
15:14:00 <ijp> levi: yes, that burstall paper seems to be the original of the terminology, if not the function
15:14:18 <monochrom> actually FOO |-> FOO_THEN, they're all uppercase. (uppercase for theorem-proving functions. lowercase for other functions.)
15:14:27 <ijp> levi: the plotkin quote is interesting because edinburgh was the home of resolution theorem-proving for a while
15:14:28 <Eduard_Munteanu> Ouch.
15:14:50 <monochrom> but you, you can certainly go foo_then or fooThen or foo'then
15:14:51 <Eduard_Munteanu> This is for CPS-encoded existentials, more specifically.
15:15:59 <monochrom> at least, Plotkin did not say, "if let loose, researchers of resolution theorem-provers can waste a lot of grant money" :)
15:16:20 <levi> Darlington's 1972 Ph.D thesis is available online. It talks about "converting definitions of algorithms given as recursion equations using high level primitives into lower level flow chart programs."
15:16:29 <Eduard_Munteanu> My types are starting to get rather lens-y... listingR :: forall path io a. (IsPath path File, IsPath path Directory, MonadIO io, MonadPlus io) => path Directory -> (forall t. (IsRelative path t) => Relative path t -> io a) -> io [a]
15:16:39 <monochrom> I think fooThen is a good name even for CPS-encoded existentials
15:16:50 <edwardk> nah, no lens type would have unnecessary parens in it like that ;)
15:17:12 <monochrom> so many nominolos!
15:17:19 <edwardk> listingR :: forall path io a. (IsPath path File, IsPath path Directory, MonadIO io, MonadPlus io) => path Directory -> (forall t. IsRelative path t => Relative path t -> io a) -> io [a]
15:17:25 <Eduard_Munteanu> edwardk: they're not unnecessary, I like them :P
15:17:27 * edwardk leaves Eduard_Munteanu to find hem
15:17:33 <edwardk> =P
15:17:48 <levi> He mentions rewriting of shared structure... I wonder if he's doing lazy evaluation?  Must read on....
15:17:56 <Eduard_Munteanu> edwardk: hem?
15:18:00 <edwardk> them
15:18:03 <Eduard_Munteanu> Ah.
15:18:11 <edwardk> my keyboard sticks and my typing is rough to begin with ;)
15:19:11 <monochrom> levi: may also be memoization such as those that collapse a dumb exponential algorithm back to a smarter linear-time algorithm
15:19:22 <Eduard_Munteanu> I sort of prefer pointfree-oriented types sometimes... as in  fmap :: (Functor f) => (a -> b) -> (f a -> f b)
15:20:04 <Eduard_Munteanu> Well, fmap is well-known, but it's handy in more complicated types.
15:20:09 <monochrom> some parentheses emphasize my perspective, yeah
15:20:45 <edwardk> i pretty much ruthlessly eliminte any parens that aren't required for syntax, but YMMV =)
15:21:17 <monochrom> http://lpaste.net/99842 has some helpful redundant parentheses
15:23:19 <levi> "We believe that there is a growing divergence between the program structures that enable programmers to clearly and concisely specify computations and structures that are suitable for efficient implementation on present day computers."
15:23:34 <levi> Well, he got that one right. :)
15:24:06 <jfischoff> redundant parentheses can make the code clearer but not 733t3|2 ;)
15:24:22 <hpc> clearly we need to make inefficient implementations of hardware that let us program more elegantly
15:24:40 <ocfx> levi: who said that
15:24:59 <levi> hpc: No, clearly we need to make compilers that know more about how to transform programs in meaning-preserving ways.
15:25:01 <ocfx> i saw a talk with carmack from quakecon last year where he talks about haskell, its pretty cool, he likes it a lot
15:25:07 <benzrf> hello !
15:25:19 <levi> ocfx: From a 1972 PhD thesis.
15:25:37 <ocfx> oh i see
15:25:44 <levi> ocfx: By John Darlington
15:28:04 <monochrom> I am pessimistic. I believe that there is a growing divergence between our want of clear and concise specification of objectives and most programmers want of clear and concise specification of execution control flow.
15:28:37 <monochrom> that is, we want higher level, they want lower level.
15:29:12 <monochrom> how do I know? the moment I hear a beginner here ask "what is the control flow?", I know
15:29:22 <johnw> but it would seem that machines are beginning to prove complex enough that some are finally admitting they can't be successful at trying to outthink the machine to determine what the most optimal control flow should be
15:29:51 <benzrf> monochrom: its just because of people being used to imperativeness
15:30:34 <monochrom> I am not convinced that you said the cause. I am inclined to believe that you said the effect.
15:31:02 <mm_freak_> remember that most haskell programmers don't learn haskell as their first language
15:31:36 <mm_freak_> so i do expect most beginners to approach haskell with certain biased assumptions about how programming works
15:32:05 <benzrf> monochrom: keep in mind that most people are average, because that is the definition of average, and most people includes you
15:32:12 <mm_freak_> and many of them welcome the new perspective
15:32:25 <benzrf> if you are good enough to see from this viewpoint, there is no real reason to assume other people are so much more unfocused
15:33:58 <levi> mm_freak_: Well, there are notions other than rewriting based on recursion schemes that have to be significantly re-written by a compiler before they become at all efficient.
15:34:34 <mm_freak_> levi: of course
15:35:22 <mm_freak_> a lazily evaluated language like haskell is known to be difficult to compile into efficient machine code
15:36:04 <monochrom> benzrf: I don't understand why you bring up "average" and "good". but it seems that you are confirming my belief, not casting doubt.
15:36:14 <levi> A language like Smalltalk as well, to take a rather different example.
15:36:24 <benzrf> ~_~
15:36:36 <benzrf> monochrom: all that i am saying is ThatOtherPerson
15:36:46 <benzrf> if you know that this way has big advantages
15:36:50 <scshunt> hey all. anyone familiar with lenses know if there's a lens-y way to construct records that were done with makeLens?
15:37:02 <benzrf> and you look at people who question it and go 'oh they think at a lower level, they dont like this way'
15:37:14 <benzrf> you're being awfully presumptuous about your ability and level of thinking
15:37:15 <mm_freak_> sure…  haskell and smalltalk have one thing in common:  they primarily optimize programming, not execution
15:37:18 <monochrom> I said, "I'm pessimistic, I believe X and Y diverge." the more you explain why X and Y diverge, the more you're confirming my belief.
15:37:18 <Eduard_Munteanu> scshunt: like initialize records? Not really.
15:37:25 <benzrf> .......
15:37:32 <benzrf> i am not saying why x and y diverge...
15:37:41 <monochrom> I don't understand "ThatOtherPerson"
15:37:57 <shachaf> In general no.
15:38:12 <shachaf> There's a scow way where you define a default value and then change the fields you want in it.
15:38:13 <Eduard_Munteanu> scshunt: I'm working on something like that, basically a way to use lenses as coverage-checked initializers
15:38:19 <levi> mm_freak_: Well, not just that. They're also based around a fairly pure model for programs, neither of which looks anything like the way a typical computer works.
15:39:11 <mm_freak_> levi: yes, and the motivation is to optimize programming, although haskell and smalltalk go into different directions there
15:39:17 <monochrom> benzf, "higher level" refers to "high level language", not "high level intelligence". similarly "low level". methinks you are presumptious and condescending on me.
15:39:20 <mm_freak_> also they seem to disagree about "pure" =)
15:39:39 <benzrf> hmmm maybe i misunderstood
15:39:40 <benzrf> i am sorry :|
15:40:23 <levi> mm_freak_: Yes, I'm not disagreeing, just elaborating.
15:40:56 <mm_freak_> levi: ah
15:40:58 <levi> Well, Haskell is 'pure functions' and Smalltalk is 'pure message passing'
15:41:09 <mm_freak_> ah, ok
15:41:44 <briennetheblue> what's a good name for a :: Iso' (Bool, a) (Either a, Either a)
15:41:46 <levi> I.e. arithmetic and conditionals are just message sends between objects.
15:41:49 <mm_freak_> i understood the advantage of smalltalk to be a sort of "live modelling"…  IIRC a smalltalk program can't be fully derived from its source code
15:42:07 <Eduard_Munteanu> briennetheblue: those Eithers seem wrong
15:42:15 <mm_freak_> briennetheblue: TypeError
15:42:17 <simpson> levi: Note the lessons of Self; Smalltalk and kids don't have to be slow.
15:42:23 <briennetheblue> errr Either a a
15:42:24 <ski> mm_freak_ : kind error
15:42:27 <briennetheblue> you know what i meant!
15:42:27 <benzrf> ll
15:42:31 <benzrf> i didnt o-o
15:42:49 <levi> simpson: Thanks to meaning-preserving program transformations, which is the point of the thesis I was reading.
15:42:52 <benzrf> briennetheblue: how about side, or someting
15:42:59 <benzrf> *asSide
15:43:07 <ski> briennetheblue : perhaps "distributeOnBool" ?
15:43:18 <benzrf> or ThatOtherPerson
15:43:19 <mm_freak_> ski: in my dependently typed mind KindError and TypeError collapse into TypeError =)
15:43:19 <benzrf> *that
15:43:54 * ski . o O ( mind error )
15:44:07 <Eduard_Munteanu> Sort of error. :P
15:44:18 <briennetheblue> hm
15:44:43 <simpson> levi: Yeah. I like the lesson that E provides, which is that if you keep an AST around instead of bytecode, you have *even more* information available for the compiler.
15:44:48 * hackagebot anansi 0.4.6 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.6 (JohnMillikin)
15:44:50 * hackagebot anansi-hscolour 0.1.2 - Colorized looms for Anansi  http://hackage.haskell.org/package/anansi-hscolour-0.1.2 (JohnMillikin)
15:44:52 <simpson> But nobody's made a fast E yet.
15:45:19 <mm_freak_> briennetheblue: twoTimesAEqualsAPlusA
15:45:28 <briennetheblue> ._.
15:45:43 <levi> simpson: Well, that was sort of the problem with Self. It proved how to make dynamic dispatch fast, but then the guys that figured it out all got hired to make Java fast instead of Smalltalk. :)
15:45:52 <mm_freak_> can't think of a good name for that iso
15:46:20 <Eduard_Munteanu> "lemma" is always a good misc-sounding name. :)
15:46:31 <mm_freak_> lilEmma
15:46:37 <simpson> levi: We're going to have E's revenge soon. :3
15:46:37 <levi> simpson: You should make a fast E!
15:46:52 <simpson> levi: Yes! And while we're at it, we're fixing a couple syntactic warts.
15:46:58 * ski . o O ( Fermat's little llama )
15:47:01 <bennofs> pack is always a nice iso name
15:47:24 <mm_freak_> packed
15:47:27 <scshunt> Eduard_Munteanu: Given that I use makeLenses, I suppose that TH magic could be applied to make it work
15:47:27 <Eduard_Munteanu> I wonder if a lemma about bools and either is actually a dilemma.
15:47:28 <burbul> How can I have two overlapping projects, i.e. sharing some number of files but each with a different 'Main.hs'? (Or even better, how can I have a project generate two executables?)
15:47:34 <levi> I believe some Oberon systems kept some sort of encoded AST around as their primitive format as well.
15:48:18 <Eduard_Munteanu> scshunt: how are you going to supply the values to a TH function?
15:49:05 <mada> The wiki says that the 'algebraic' part of algebraic data types stems from an algebraic data type being created by 'algebraic' operations, namely sum and product
15:49:50 <monochrom> burbul: cabal allows multiple executables. use multiple "executable" sections and the "main-is" field
15:49:56 <mada> now, I don't see how a sum type (data P = I Int | D Double) is an 'algebraic operation'
15:50:03 <scshunt> Eduard_Munteanu: I can think of a number of ideas... it really depends what interface you want
15:50:16 <scshunt> makeLenses could generate the mecessary metadata
15:50:31 <Eduard_Munteanu> scshunt: my approach was a bit different, I make lenses with Tagged Field functor and a initializer GADT that's a bit like HList.
15:50:32 <mada> Maybe I'm looking at it from a very particular algebra, where sum and product are different things
15:50:43 <mada> what's algebraic about a 'sum type'?
15:50:44 <thebnq> mada: sum as in disjoint union
15:51:09 <Eduard_Munteanu> scshunt: and some typeclass checks whether all fields have been initialized
15:51:09 <levi> mada: Well, it's not exactly like a numeric sum, but it does precisely fit a different kind of algebraic sum.
15:51:26 <Eduard_Munteanu> scshunt: it requires a bit of TH though, but it's not the main thing
15:51:45 <levi> mada: And it even fits in a numeric sense if you consider the number of inhabitants of the types involved.
15:51:54 <burbul> <monochrom>: thanks!!
15:52:04 <monochrom> mada, "data Q = Q1 Int Bool | Q2 Char Double" is analogous to (Int x Bool) + (Char x Double)
15:52:52 <monochrom> pardon me for using "x" rather than "×" :)
15:52:55 <levi> At least the number of fully-defined inhabitants. :)
15:53:09 <mada> levi: inhabitants are the possible values?
15:53:37 <scshunt> Eduard_Munteanu: actually, now that I think about it
15:53:39 <levi> mada: Yes, the values that inhabit the types are the set of all values that belong to the type.
15:53:51 <scshunt> all that's really wanted/needed is a way to easily slice lenses
15:53:59 <scshunt> or setters, specifically
15:54:19 <mada> I saw that by that analogy from the data Q to (Int x Bool) + (Char x Double), algebraic manipulation maintains a relationship in the data type "interpretation"
15:54:24 <monochrom> but, you could perhaps argue that "data L = N | C Int L" = "L = 1 + Int × L" is transcendental, not algebraic :)
15:54:31 <Eduard_Munteanu> scshunt: slice? Are you looking for makeFields / makeClassy?
15:54:41 <bennofs> scshunt: slice lenses? what's that?
15:55:10 <mada> I guess what I don't grok are the consequences of a data type being 'algebraic'
15:56:03 <scshunt> Eduard_Munteanu: I can't figure out exactly what those do anywhere :/
15:56:05 <Eduard_Munteanu> mada: it usually means it can be written as a polynomial in one or multiple variables
15:56:43 <monochrom> I don't think it has earth-shattering consequences anyway.
15:57:07 <scott> mada: As I understand it, they are what enable pattern matching over values (and ensuring the patterns cover all the cases). Somebody correct me if I'm wrong.
15:57:24 <levi> mada: Well, the consequences of casting things into algebraic form aren't always obvious at first, but they tend to have surprisingly useful results on occasion due to the funny way that math has of making bizarre things profoundly useful.
15:57:32 <scshunt> Eduard_Munteanu: I don't think so
15:57:59 <Eduard_Munteanu> scshunt: makeFields gives you a typeclass for each field of a record, and the names can be reused.
15:58:01 <mada> how are the type systems of other languages not-algebraic?
15:58:14 <levi> mada: Most languages don't have sum types, for one thing.
15:58:19 <mada> couldn't a C union be a disjoint union?
15:58:44 <levi> No, it's not discriminated unless you manually add a tag.
15:58:49 <scott> A C union can't be disjoint. You need a marker telling you which of the 'cases' your value actually is. (So, you can use a C struct with a tag and a union.)
15:59:03 <papna> Why is the 'pure' function called that?
15:59:03 <mada> right
15:59:04 <papna> (in the context of applicative functors)
15:59:17 <monochrom> instead, I think this way. if a language supports "data Q = Q1 Int Bool | Q2 Char Double", I am not impressed, I call it merely minimum requirement for a half-decent language. if a language doesn't suport it, now that's outrageous, I call that language garbage.
15:59:19 <Eduard_Munteanu> scshunt: e.g. if data Foo = Foo { ... fooBar :: Baz ... }, you get a class and instance  HasBar Foo Baz where bar :: Lens ...
15:59:46 <levi> papna: It's a direct lifting of a value into the applicative context without adding any extra "effects" or whatever you're modeling.
16:00:01 <monochrom> so, algebraic data type does not have much consequence for me. but, lacking algebraic data type, that has dire consequences.
16:01:05 <mada> thank you all
16:01:40 <Eduard_Munteanu> scshunt: this lets you write things like    f :: (MonadReader r m, HasBar r Baz, HasBeep r Boo) => ...
16:01:43 <levi> mada: One fun and surprisingly useful property of algebraic data types is that you can take their derivatives to form a new type which is a "one-hole context" with which you can keep track of where another thing needs to be placed.
16:02:17 <scshunt> wait a minut
16:02:24 <scott> mada: You might want to read http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
16:02:28 <scshunt> I think I'm just being dumb
16:03:02 <scshunt> yes, I am
16:03:52 <briennetheblue> can you integrate types to heal over any holes that they have :p
16:04:43 <mada> scott: I watched Chris Taylor's talk about the algebra in algebraic data types
16:05:07 <mada> he did take the derivative of some types as levi said, and derived the zippers for those structures
16:05:11 <mada> pretty neat
16:05:41 <levi> Conor McBride has a few papers on the idea as well.
16:07:16 <scott> I find even the basic stuff neat as well. e.g. () corresponds to 1 and Bool corresponds to 2, so Either () Bool corresponds to 1 + 2 = 3 and so Either () Bool has three values (Left (), Right False, Right False).
16:07:44 <mada> scott:  :D
16:07:44 <levi> But the basic idea came from type theory, which was developed to model the foundations of mathematics. And if you're going to borrow the idea of function from mathematics, why not the mathematical tools for modeling values as well?
16:08:34 <mada> I'm short on type theory. At 0
16:09:08 <levi> The world of functional programming has always been very tied up with logic and theorem-proving.
16:09:22 <Eduard_Munteanu> mada: do you known about cardinality, countable sets and this sort of stuff in math?
16:09:33 <Eduard_Munteanu> *know
16:10:11 <mada> Eduard_Munteanu: I guess, as far as cardinality and countable sets
16:10:21 <levi> Type theory is kind of like set theory, but tries to give things more structure so as to avoid some of the paradoxes that could be constructed in set theory.
16:10:43 <scott> More interestingly, x+x = 2*x, so Either a a === (Bool, a). Or x*x === x^2, so (a, a) === Bool -> a.
16:11:29 <briennetheblue> exactly, i just found a practical example of that in Language.Haskell.Exts.Parse :)
16:11:38 <mada> scott: what's the interpretation of x^2 as Bool -> a?
16:11:54 <nooodl> a^b is B -> A
16:11:57 <levi> Exponential types are functions.
16:12:05 <scott> mada: a -> b always corresponds to b^a, since you can make b^a different functions from a -> b.
16:12:06 <levi> Or function types, rather.
16:12:13 <mada> so Bool -> a == 2^a
16:12:25 <mada> ===*
16:12:33 <Eduard_Munteanu> mada: no, a^2
16:12:42 <mada> right
16:13:04 <scott> mada: A simple example is Bool -> Bool, which has 2^2 = 4 possible values (there are 4 unique Bool -> Bool functions).
16:13:10 <mada> a times a possible values
16:13:42 <mada> this is interesting
16:14:41 <scott> The way (a, a) corresponds to Bool -> a is that instead of having a pair (x, y) you have a function that returns x when given True and y when given False (or vice versa, it doesn't matter).
16:14:47 <nooodl> another cool result: c^(a*b) = (c^b)^a  <=>  (A, B) -> C === A -> (B -> C)
16:14:56 <nooodl> which is just currying
16:15:04 <scott> Yeah, that's a good one. =)
16:15:33 <mada> nooodl: that's really cool indeed
16:16:00 <scott> And you can find the same thing by the correspondence between types and logic... (A and B) implies C === A implies (B implies C)
16:16:02 <briennetheblue> i wanted a prism into (Bool, a) when the boolean is true so compose the iso with _Right... i just need a good name for the iso...
16:16:18 <Eduard_Munteanu> mada: if you let A U+ B = { (S, x) | x \in A U B, S = A if x \in A, B otherwise }, then | A U+ B | = |A| + |B|, which is like Either A B.
16:16:27 <mada> it's great that there is an isomorphism between both representations, and that it's kept when operating with algebraic operations
16:16:37 <scott> The correspondence between types and logic is called the Curry-Howard correspondence if you want to look at that, too.
16:16:50 <Eduard_Munteanu> Er, my definition of a disjoint union sucks.
16:17:30 <mada> Eduard_Munteanu: I'm slowly trying to parse it
16:17:31 <levi> The a^2 form of type membership is the 'indicator function' or 'characteristic function' representation.
16:17:59 <scott> levi: Do you mean 2^a?
16:18:20 <scott> A function a -> Bool identifies a subset of a, which is a characteristic function, right?
16:18:24 <levi> Probably. My brain is fried right now.
16:18:25 <Eduard_Munteanu> mada: A U+ B is like A U B, except each element is tagged with the set it originates from, and you don't squash out common elements.
16:18:27 <scott> :P
16:18:54 <copumpkin> a^2 = (a, a) :)
16:19:15 <briennetheblue> how i remember a^b is that the arrow points from smaller to bigger
16:19:18 <silasm> Eduard_Munteanu: for invertibility?
16:19:32 <Eduard_Munteanu> mada: e.g. A = {1, 2}, B = {1, 'c'} gives A U+ B = { (A, 1), (A, 2), (B, 1), (B, 'c') }
16:20:06 <mada> Eduard_Munteanu: I see
16:20:19 <mada> I couldn't get the definition of 'tagged' (also U+)
16:20:28 <scshunt> Eduard_Munteanu: so I was being dumb and forgot that I can just use the field lenses... only caveat is that then it warns for uninitialized fields
16:20:31 <scshunt> would be nice if I could turn that off
16:20:41 <scshunt> (but only selectively)
16:20:50 <Eduard_Munteanu> silasm: are you asking why you don't squash out elements?
16:21:21 <silasm> Eduard_Munteanu: well why implement like that in general, sorry I just rejoined and was interested.
16:21:46 <Eduard_Munteanu> silasm: the tag can be anything as long as it lets you figure out the origin set
16:22:10 <scott> If they weren't disjoint sums, then Int + Int would just be Int, since you couldn't tell which side it came from. It'd be like Either Int Int where you can't tell Left from Right.
16:22:20 <silasm> actually I'm seeing where you defined it now nevermind
16:22:31 <Eduard_Munteanu> scshunt: yes, that's the first thing I was telling you about... the only way you can do that currently is to make a big function and set all values at once.
16:23:04 <Eduard_Munteanu> silasm: my definition is wrong though.
16:23:45 <Eduard_Munteanu> It should be more like   A U+ B = { (S, x) | S in {A, B}, x in S }
16:23:49 <Eduard_Munteanu> Comprehension-like.
16:23:52 <silasm> Eduard_Munteanu: I was more curious about the motivation than the definition; I'm gathering it from reading backwards.
16:24:31 <silasm> saw that and thought it was linear logic or something though, since that would let you get back to the arguments unless I'm forgetting something.
16:24:35 <Eduard_Munteanu> silasm: type theory usually doesn't allow normal unions
16:25:45 <Eduard_Munteanu> silasm: I was trying to explain algebraic data types in terms of ordinary math sets.
16:26:57 <silasm> Eduard_Munteanu: yeah, I was slowly gathering that. Thanks.
16:29:53 * hackagebot anansi-pandoc 0.1.2 - Looms which use Pandoc to parse and produce a variety of formats.  http://hackage.haskell.org/package/anansi-pandoc-0.1.2 (JohnMillikin)
16:34:39 <briennetheblue> i think beside :: Iso' (Bool, a) (Either a a) is a decent name
16:34:56 <briennetheblue> as inspired by benzrf's suggestion
17:00:24 <suOya> .
17:00:51 <benzrf> neat
17:06:23 <Rotaerk_> I've got a code architectural question.  It's kind of long so I put it here:  http://lpaste.net/7971663960862621696
17:09:58 <benzrf> Rotaerk_: i, the least qualified person in the channel to answer questions, shall attempt a response!!!
17:10:01 <benzrf> let me just read it hold on
17:10:39 <benzrf> Rotaerk_: ok, so
17:10:52 <Rotaerk_> k
17:11:01 <benzrf> data Model = Model Event State (Event -> State -> State)
17:11:01 <benzrf> ?
17:11:40 <benzrf> ousado: ?
17:11:42 <benzrf> * Rotaerk_
17:12:16 <Rotaerk_> benzrf: nope
17:12:28 <benzrf> Let's say I have a "model" that includes: 1) a state data type 2) an event data type 3) an update function of signature event -> state -> state
17:12:31 <benzrf> ???
17:12:50 <Rotaerk_> with that, all models' event and state types are the same, the only difference is the values
17:13:00 <benzrf> ahihi:
17:13:01 <benzrf> *ah
17:13:25 <benzrf> data Model e s = Model e s (e -> s -> s)
17:13:46 <benzrf> ?
17:13:49 <Rotaerk_> benzrf: yea, a model could be represented that way.
17:14:11 <__sebastian__> @hoogle Integer -> Text
17:14:12 <benzrf> OK
17:14:13 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
17:14:13 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
17:14:13 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
17:14:20 <__sebastian__> hm
17:14:38 <benzrf> sohum:
17:14:38 <benzrf> *s
17:14:40 <benzrf> ughhh
17:14:49 <benzrf> 1 sec
17:14:59 * hackagebot yajl 0.3.2 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.2 (JohnMillikin)
17:15:01 * hackagebot network-protocol-xmpp 0.4.6 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.6 (JohnMillikin)
17:15:09 <ThatOtherPerson> benzrf: :P
17:15:27 <Rotaerk_> that means each model has a different type.  type FooModel = Model FooEvent FooState;  type BarModel = Model BarEvent BarState
17:15:38 <benzrf> ah, ok p:
17:16:01 <Rotaerk_> and then an aggregate model should be able to contain both a FooModel and a BarModel
17:16:07 <ThatOtherPerson> benzrf: Well that was good for a laugh
17:17:13 <benzrf> data Aggregate s s' e e' = Aggregate (s, s') (Either e e') (Either e e' -> (s, s') -> (s, s'))
17:17:16 <benzrf> yeah?
17:17:37 <benzrf> ...ish.
17:17:56 <Rotaerk_> sure, except the aggregate should be able to have an arbitrary number of them in it, and adding one to it should only require specifying the component by name
17:18:17 <benzrf> OK
17:18:18 <Rotaerk_> i.e. as opposed to making manual tweaks to the aggregate's state type, event type, and update function
17:18:40 <benzrf> i feel like you should unify states and events
17:18:54 <benzrf> that way you can just do
17:18:54 <benzrf> data Model = Model Event State (Event -> State -> State)
17:18:56 <benzrf> and
17:19:00 <benzrf> type Aggregate = [Model]
17:19:10 <benzrf> *unify states and unify events
17:19:22 <Rotaerk_> that would be convenient and simple to represent, but it doesn't fit the bill
17:19:27 <benzrf> why notdan ?
17:19:29 <benzrf> *not
17:19:36 <benzrf> ughhh my tab completion is out of control
17:19:38 <benzrf> ;-;
17:19:59 * hackagebot libxml-sax 0.7.5 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7.5 (JohnMillikin)
17:20:46 <Rotaerk_> well let's say FooEvent = FooA | FooB | FooC, and BarEvent = BarA | BarB
17:21:07 <Rotaerk_> in order to make them the same type, I'd have to have one type:  Event = FooA | FooB | FooC | BarA | BarB
17:21:32 <Rotaerk_> that's not very modular.  that would mean that every time I define a new model, I would have to edit the preexisting Event and State types
17:21:48 <benzrf> hmmm, that's true
17:22:00 <benzrf> I know!!
17:22:03 <benzrf> EXISTENTIAL TYPES
17:22:30 <Cale> Or even not existential types
17:22:31 <benzrf> but more seriously, why not just tie events to another type, like strings
17:22:40 <Sgeo> Are there any Lens-like types that allow setting but not modifying of their focus (is that the right term?)? (Background: Considering implementing a lens-like thing in a dynamically typed language, using the trivial structure of getter + modifier idea)
17:22:42 <Sgeo> Need to know if I need to have setter in there too
17:22:43 <Cale> Just figure out which operations you want to be able to perform on your type
17:23:00 <Cale> and then replace the values of the type with records of the implementation of those operations
17:23:05 <benzrf> Cale: lists thomasschroeter
17:23:06 <benzrf> *tho
17:23:08 <Rotaerk_> benzrf: encoding events as strings isn't very typesafe, also events can carry information that I don't want to have to parse out of a string
17:23:32 <Rotaerk_> also that doesn't address the state type
17:23:51 <Cale> Rotaerk_: What things do you need to be able to do with an Event?
17:24:00 <Rotaerk_> did you see my paste?
17:24:32 <Rotaerk_> within the context of this problem, the "update" function is the only use for the event.  I will have more uses later, but I figured I'd leave them out for simplicity
17:24:35 <amalloy> Sgeo: setting but not modifying?
17:24:50 <benzrf> Rotaerk_: seems like a typeclass thing
17:24:59 <Cale> Rotaerk_: Okay, then why not just say  type Event = State -> State
17:25:02 <benzrf> but then youd need existential types for aggregates
17:25:02 <benzrf> :\
17:25:20 <Sgeo> amalloy: as in, on the focus, you're not allowed to base the new value on what's already there
17:25:20 <Cale> Or:  data Event = Ev (State -> State)
17:25:39 <Cale> Rotaerk_: does that work?
17:25:52 <Sgeo> If there's no such use case, then I can just have my struct have a getter and modifier, since a setter can easily be made based on the modifier
17:26:01 <Cale> If we define it by record syntax:
17:26:11 <Cale> data Event = Ev { update :: State -> State }
17:26:18 <Cale> then we get  update :: Event -> State -> State
17:26:46 <Rotaerk_> Cale: ah so that's why you asked.  well an event needs to carry information because the other use for this event type will be that other components listen for it and have logic based on the description of the event
17:27:05 <Rotaerk_> I suppose it could carry the transform itself within it though... *in addition to* the description
17:27:14 <Cale> indeed!
17:28:00 <Cale> You might also have some operations which alter an Event based on some input
17:28:19 <Cale> and you could do something like:
17:28:46 <Cale> data Event = Ev { update :: State -> State; changeMe :: Something -> Event }
17:29:50 <Rotaerk_> hmm well this is nice and all, and it may be a piece of the solution... but
17:30:18 <Rotaerk_> there's still distinct event types for each model
17:30:23 <Cale> then all of what used to be cases just become separately defined values, and extensibility in that sense is easy
17:30:32 <Rotaerk_> hmm
17:31:28 <Rotaerk_> data Event state description = Event { update :: state -> state; description :: description }
17:32:39 <Cale> sure, if you like
17:33:38 <Cale> That sort of approach will be most meaningful in the case where you have operations which don't care about what the description type or what the state type are.
17:33:38 <Rotaerk_> all this really does is eliminate the "update" function from being global
17:34:02 <Cale> If you *do* care what the descriptions consist of, you could just build them in
17:34:31 <Cale> I have very little sense of what you're trying to accomplish from your paste, so it's a little tricky to know what to suggest
17:35:00 <Rotaerk_> hmm I thought my paste was clear; would code samples help?
17:35:07 <Cale> Rotaerk_: It lets you specify what the update function does on a value-by-value basis
17:35:29 <Cale> Well, your paste is talking about very abstract things
17:35:37 <Cale> What is your program actually doing when you run it?
17:35:49 <Cale> Or what kind of thing is your library about?
17:37:18 <Rotaerk_> basically, given an initial state, and a stream of events, transform the state for each event until you get to the final state
17:37:31 <Rotaerk_> *but* I want to be able to modularly extend this state and the set of events
17:37:51 <Rotaerk_> so partition the state into components, and give each component a corresponding subset of the events which can modify it
17:37:55 <Cale> uhhh
17:38:27 <Cale> Well, how about this: what *is* your actual state type?
17:38:32 <Cale> Is this for a game?
17:38:43 <Cale> Or a simulation of some sort?
17:38:48 <Rotaerk_> the overall state type is a game, yes
17:38:56 <Cale> Or what problem are you actually solving? :)
17:38:58 <Cale> okay
17:39:55 <Rotaerk_> one model is EntityRegistryModel, with EntityRegistryState = a list of entity IDs, and EntityRegistryEvent = AddEntity id | RemoveEntity id
17:40:44 <Rotaerk_> another model is StageModel (representing a 2D grid of tiles where entities can be placed)
17:42:24 <Rotaerk_> StageState = a 2D array of Maybe EntityId,  StageEvent = PlaceEntity EntityId TileIndex | MoveEntity EntityId TileIndex | RemoveEntityFromStage EntityId
17:43:18 <Rotaerk_> then the aggregate, there's GameModel, with GameState = { entityRegistry :: EntityRegistryState, stage :: StageState }
17:43:41 <Rotaerk_> GameEvent = EntityRegistryEvent EntityRegistryEvent | StageEvent StageEvent
17:44:12 <Cale> There is of course quite a bit you could do with lenses, with respect to applying functions to nested components of structures
17:44:39 <Rotaerk_> right, I'm familiar with them to some degree; used a little
17:44:56 <Rotaerk_> but they don't solve this in any obvious way
17:45:43 <merijn> Rotaerk_: It sounds like you're trying to solve the expression problem
17:47:11 <fragamus> how does one open a private chat to do @pl
17:47:53 <geekosaur> depends on the client, but /msg or /privmsg sends an individual message and /query typically opens a dedicated window/tab depending on client
17:48:22 <Rotaerk_> oh, and for GameModel, there's: update gameEvent = case gameEvent of { EntityRegistryEvent e -> entityRegistry %~ EntityRegistry.update e; StageEvent e -> stage %~ Stage.update e }
17:49:10 <Rotaerk_> so basically, if I need to add a new model to the game... I have to add a field to GameState, add a constructor to GameEvent, and add a rule to the update function's case expression
17:50:26 <Rotaerk_> merijn: maybe? I'll have to think about how this problem relates to the expression problem
17:50:31 <alex_______> can someone explain how let x = 1:x in x works? I am not getting it
17:50:50 <alex_______> > let x = 1:x in x
17:50:52 <Rotaerk_> merijn: it's solvable here, it's just my solution involves *generating* GameState, GameEvent, and Game.update
17:50:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:50:59 <Rotaerk_> using template haskell
17:51:10 <Eduard_Munteanu> alex_______: you know that x is 1 : x, which is 1 : (1 : x) ...
17:51:18 <aji> > [1..]
17:51:19 <Rotaerk_> was wondering if there's another kind of abstraction I could use for this
17:51:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:51:41 <benzrf> alex_______: do you know what a thunk is?
17:52:07 <fragamus> @pl (\ray ->        (raybase +) <$> (raycos ^*) <$> ((headMay . sort . rayToTorusIntersections) ray) )
17:52:08 <lambdabot> (((raybase +) <$> (raycos ^*)) <$>) . headMay . sort . rayToTorusIntersections
17:52:34 <Eduard_Munteanu> alex_______: IOW, instead of 'x', you could write '1 : x' everywhere and it would be the same thing. Also 1 : 1 : x etc
17:52:48 <alex_______> Eduard_Munteanu: and what about next step? 1 : 1 : (1 : x)   or  1 : 1 : (1 : 1 : x) ?
17:53:00 <alex_______> benzrf: vaguely
17:53:08 <Eduard_Munteanu> alex_______: replace x by '1 : x' again :)
17:53:24 <alex_______> Eduard_Munteanu: why not by 1 : 1 : x ?
17:53:48 <Eduard_Munteanu> alex_______: or 1 : 1 : x, same thing
17:54:40 <alex_______> same result, but for fully undertanding it I wonder how it gets expanded the second time
17:54:45 <Eduard_Munteanu> alex_______: but normally Haskell expands the variable to the let definition
17:55:08 <Rotaerk_> merijn: I suppose it's similar, because I'm attempting to make both the interface and data model of the "game model" simultaneously extensible.  however, I'm doing so in a restricted fashion that, i think, makes it not a victim of the expression problem
17:55:25 <Eduard_Munteanu> alex_______: well, the 'x' is bound in the let to '1 : x', so that's how it works operationally
17:55:26 <alex_______> but isnt x = 1:1:x  before second expansion?
17:56:03 <merijn> alex_______: Do you know C?
17:56:08 <Eduard_Munteanu> alex_______: it isn't the definition that gets expanded in place
17:56:20 <alex_______> merijn: yes, first language I learned
17:56:31 <Eduard_Munteanu> alex_______: rather, every use of 'x' is expanded to the rhs of the definition
17:56:41 <merijn> alex_______: Right, imagine the "x" being a pointer back to "1:x"
17:56:55 <benzrf> all dese underscores
17:56:55 <benzrf> o-o
17:56:56 <Rotaerk_> the expression problem I believe assumes that all operations have access to all aspects of the data model.  in this case, though, the set of operations and the data model can each be partitioned, and then a one-to-one mapping made between them
17:57:31 <benzrf> alex_______: like a looped linked list
17:57:36 <Eduard_Munteanu> alex_______: and the "expansion" happens when you evaluate the result.
17:57:37 <benzrf> which is, in fact, exactly what it Iskarlar
17:57:38 <alex_______> i see
17:57:39 <benzrf> *is
17:57:41 <merijn> alex_______: Or "struct LIST { int val; struct LIST *next; };" with "struct LIST ones = { 1, &ones };"
17:58:10 <alex_______> a lot clearer that way yes
17:59:25 <merijn> alex_______: Since names in haskell are just labels for values, they can function very much like pointers at time
17:59:32 <Eduard_Munteanu> alex_______: imagine stepping through 'x'. First it expands to '1:x' when you look at the head of the list. Then if you look at the tail you find it's 'x', which you expand again.
17:59:33 <merijn> *times
17:59:36 <alex_______> for some reason I expected x in the second and subsequent expansions to refer to the updated value of x
17:59:50 <benmachine> that's not an unreasonable expectation
18:00:07 <Eduard_Munteanu> alex_______: it's not a variable assignment
18:00:07 <benmachine> if you write, say x = 4 + 7 and then later use x in expressions
18:00:13 <benmachine> 4 + 7 will only be computed once
18:00:20 <benmachine> and from then on, x will be 11
18:00:33 <benmachine> wherever and whenever you use it
18:00:41 <benmachine> so there is some updating that goes on
18:01:12 <Eduard_Munteanu> alex_______: it's more like an equation; actually even more specific, a binding: it tells you x expands to 1:x, but the converse isn't specified (1 : x to x).
18:01:12 <benmachine> of course it's a little tricky to talk about this stuff because it is in the nature of non-strictness and purity that it doesn't really matter whether you update or not
18:01:50 <alex_______> yeah makes sense, so x is always 1:x, and we just keep replacing x with it
18:02:04 <Iloiny_> hm can i increment an element on a list when accessing it by !! ?
18:02:06 <merijn> alex_______: That's a reasonable way of seeing it
18:02:20 <merijn> Iloiny_: You can't, lists are immutable like everything else
18:02:24 <Eduard_Munteanu> Yes, where "is" is more like "evaluates to".
18:02:43 <benmachine> Eduard_Munteanu: I actually like "is"
18:03:03 <benmachine> after all, if you see 1:x elsewhere in your code, it is safe to replace it with x
18:03:06 <Eduard_Munteanu> Yeah, it's nice to pretend it's some sort of equation.
18:03:06 <merijn> Iloiny_: You'd have to copy the entire list with the "updated" value copied in
18:03:20 <benmachine> Eduard_Munteanu: pretend? they really are equal terms
18:03:24 <Rotaerk_> Cale: lose interest, get distracted, run out of ideas, still thinking about it?
18:03:26 <Iloiny_> merijn, I see
18:03:30 <Eduard_Munteanu> benmachine: I mean it's not the same operationally
18:03:40 <benmachine> Eduard_Munteanu: operationally schmoperationally :P
18:04:04 <benmachine> but I see what you mean
18:04:15 <merijn> Iloiny_: The closest thing would be like this
18:04:16 <benmachine> but I think both points of view are important
18:04:22 <Eduard_Munteanu> Yeah.
18:04:36 <merijn> > let x = [0..10] in take 4 x ++ 9 : drop 5 x
18:04:37 <lambdabot>  [0,1,2,3,9,5,6,7,8,9,10]
18:04:48 * Eduard_Munteanu wasn't being sarcastic when saying "it's nice to pretend" :)
18:05:06 * hackagebot dbus 0.10.6 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.6 (JohnMillikin)
18:06:13 <benmachine> Eduard_Munteanu: I'm still not sure I agree with you about the operational behaviour of x = 1:x actually
18:07:22 <benmachine> Eduard_Munteanu: it *is* the case that after computation, the content of a variable binding can be updated
18:07:33 <benmachine> I mean, that's lazy evaluation, that's how it works
18:08:33 <Eduard_Munteanu> benmachine: I'm saying reduction proceeds from x to 1:x.
18:09:23 <benmachine> Eduard_Munteanu: ok, but it's not clear to me that the binding of x is not then updated to reflect this reduction
18:09:28 <Eduard_Munteanu> > let 1:x = x in x
18:09:32 <lambdabot>  mueval-core: Time limit exceeded
18:09:48 <benmachine> Eduard_Munteanu: to be clear, denotationally it makes no difference whatsoever, it's not observable
18:09:57 <benmachine> but if we're talking about operationally
18:10:15 <Eduard_Munteanu> benmachine: ah, sure, I'm sort of thinking of beta generally, not how it actually works in GHC/Haskell.
18:10:38 <benmachine> Eduard_Munteanu: fair enough
18:11:00 <Eduard_Munteanu> I mean the textbook kind of beta. :)
18:11:14 <benmachine> sure
18:11:41 <benmachine> I think I was just a little unclear on the point you were making about x = 1 : x vs. x = 1 : 1 : x
18:11:44 <Eduard_Munteanu> GHC probably produces a bunch of 1s as it goes and they get garbage collected
18:12:06 <Rotaerk_> hmm I'll just go with the template haskell approach for now
18:12:15 <benmachine> I think in x = 1 : x there's only ever one 1
18:12:30 <benmachine> but when you take 30 you get that one 30 times :P
18:12:39 <benmachine> x = map id (1 : x), however...
18:12:39 <Eduard_Munteanu> Also 1 : x = 1 : 1 : x doesn't give you 1 : x -> 1 : 1 : x, though
18:12:49 <n^izzo> [TL:DR How do I perminantly change my prompt?] hey all, I have just started on the learn you a haskell 'book' and it tells me to change my prompt from "Prelude>" --> "ghci>" then I thought it would be more fun to have it as "λ " so I changed it. Just as a test I closed ghci and opened it again and found that it had reverted to Prelude> so, how do I make a permanent change?
18:13:08 <Eduard_Munteanu> So lhs -> rhs isn't quite true generally.
18:13:10 <benmachine> n^izzo: .ghci file
18:13:37 <n^izzo> in my user folder
18:13:40 <Eduard_Munteanu> Yeah, I guess it's the same 1.
18:13:51 <benmachine> Eduard_Munteanu: you mean, where the first thing is a pattern binding and the second thing is a reduction rule?
18:13:58 <Eduard_Munteanu> Unless you take some now and some more later and GC steps in-between.
18:14:51 <Eduard_Munteanu> benmachine: yeah, let 1:x = 1:1:x rather gives you a x -> 1:x reduction, not as the let tell you.
18:15:25 <benmachine> Eduard_Munteanu: but that gives you a 1 : x -> 1 : 1 : x reduction :P
18:15:38 <Eduard_Munteanu> Yeah, just not single step :)
18:15:49 <benmachine> I suppose
18:16:56 <Eduard_Munteanu> Same case for let x@(1:_) = 1:x, I suppose (the at pattern gives a 'let x = 1:_')
18:17:02 <shergill> hmm what happened to lisk?
18:17:35 <jfischoff> Is it possible to generate RecordWildCard patterns with template Haskell?
18:24:06 <n^izzo> benmachine: I added :set prompt "λ " to the empty .ghci file in my user directory sadly it has had no effect
18:24:36 <Eduard_Munteanu> jfischoff: hm, interesting question, have you tried RecP r [VarP (mkName "..")] ?
18:24:37 <startling> n^izzo, have you started a new ghci?
18:24:44 <n^izzo> yes
18:24:49 <startling> hrm
18:25:16 <bitemyapp> n^izzo: what's the exact path to your .ghci?
18:25:18 <jfischoff> Eduard_Munteanu: no but I suppose that is possible
18:25:49 <n^izzo> ~/.ghci
18:25:54 <Eduard_Munteanu> WildP most likely is C { _ }, which is different... or wait a minute...
18:26:01 <startling> n^izzo, is XDG_CONFIG_HOME set to something unusual?
18:26:11 <n^izzo> I dont know
18:26:15 <startling> echo $XDG_CONFIG_HOME
18:26:19 <startling> probably not if you don't know.
18:26:27 <Eduard_Munteanu> jfischoff: WildP might do, since empty patterns for records are like C { }, not C { _ }.
18:26:28 <n^izzo> I just did the apt-get install 2 hours agao
18:27:22 <Earnestea> startling: I wish .ghci and .cabal used XDG, ;/
18:27:45 <n^izzo> startling: echo $XDG_CONFIG_HOME returned nothing
18:27:54 <n^izzo> just a blank new line
18:27:55 <Eduard_Munteanu> Especially since RecP Name [FieldPat], where the list may contain more than one pattern.
18:28:00 <startling> Earnestea, heh.
18:28:12 <startling> n^izzo: yeah, looks like it's not that.
18:28:19 <Eduard_Munteanu> Er.
18:28:20 <Earnestea> n^izzo: (That's fine, those variables shouldn't be set by default unless you explicitly set them.)
18:28:38 <Eduard_Munteanu> Nevermind... FieldPat = (Name, Pat)
18:29:17 <n^izzo> Earnestea: thanks
18:30:16 <n^izzo> so this is what I have...
18:30:16 <n^izzo> xanth@X-VBoxTux:~➤➤➤ cat .ghci
18:30:16 <n^izzo> :set prompt "λ "
18:31:38 <jfischoff> Eduard_Munteanu: I'll try somethings, if I can't get it to work no biggie
18:32:08 <n^izzo> ahhhh I found the problem "*** WARNING: /home/xanth/.ghci is writable by someone else, IGNORING!"
18:32:23 <Earnestea> n^izzo: .ghc/ghci.conf
18:32:44 <n^izzo> So I guess I need to change the read write permissions
18:33:04 <Eduard_Munteanu> The question is why they're the way they are now. :)
18:33:32 <geekosaur> linux likes to treat groups as users, most non-linux-originated stuff understands the theory behind that is flawed and refuses to accept it
18:33:37 <geekosaur> (chmod g-w ~/.ghci)
18:34:17 <n^izzo> should I move the file into ghc
18:34:33 <Eduard_Munteanu> geekosaur: normally only the user himself has +w
18:34:41 <geekosaur> I expect you could but yu'd still have the permissions error
18:35:04 <n^izzo> ok ill just do the chmod
18:35:11 <geekosaur> Eduard_Munteanu, Debian in particular, which invented the groups-as-users nonsense, uses umask 002 by default (that is files are created group writable)
18:35:23 <Eduard_Munteanu> Ew.
18:35:51 <Eduard_Munteanu> geekosaur: you mean the fact each user gets his own group with the same name as the username?
18:36:30 <geekosaur> that's just part of it
18:36:35 <Eduard_Munteanu> Wouldn't be the first annoying thing Debian does, though.
18:36:41 <n^izzo> geekosaur: Thanks, it worked ◕ ◡ ◕
18:36:49 <geekosaur> Ian's grand vision had that the uid woud not actually be used by anything, the group id would be
18:36:58 <geekosaur> broken workaround for lack of ACLs
18:37:10 <geekosaur> creating a group per user was just part of that
18:37:29 <alex______> is this how fibs example gets evaluated?
18:37:53 <Eduard_Munteanu> User homes should really be 0077 masked by default.
18:38:08 <alex______> (autopaste not working, moment)
18:38:15 <Eduard_Munteanu> A lot of distros stick to world-readable homes.
18:39:20 <alex______> is this how that neat fibs definition gets evaluated? http://lpaste.net/99971
18:39:23 <geekosaur> ultimately debian ended up using groups in the normal way, because they're kinda necessary for device access security and such and because group vectors are too small and files still have only one group identity so you still need real ACLs
18:40:40 <Eduard_Munteanu> alex______: yes
18:41:24 <Eduard_Munteanu> alex______: well, you skipped a few non-essential steps, but generally that's the idea
18:41:44 <alex______> which are those? just curious
18:42:03 <Eduard_Munteanu> alex______: fibs, tail fibs, the zipWith begin as thunks too
18:42:21 <alex______> ah
18:44:17 <alex______> starta as 'fibs = 0 : 1 : <thunk>'  or as  'fibs = <thunk>' ?
18:44:18 <Eduard_Munteanu> alex______: by the way, it matters how you read the result.
18:44:22 <alex______> starts*
18:44:45 <alex______> not sure I get that last sentence
18:45:46 <Eduard_Munteanu> alex______: fibs !! n might not behave nicely
18:47:10 <n^izzo> thanks all, I ended up setting it to "\ESC[31mλ \ESC[m" now I have a nice little orange lambda
18:47:42 <alex______> Eduard_Munteanu: why not?
18:47:42 <Eduard_Munteanu> alex______: well, either of those answers is correct, depends what the compiler does, it's not essential
18:47:58 <BMeph> Has there been much discussion of sigfpe's latest blog post?
18:48:08 <alex______> why may fibs !! n not behave nicely?
18:50:15 <Eduard_Munteanu> alex______: fibs !! n = (0 : 1 : zipWith ...) !! n = (0 : 1 : (0 + 1) : (1 + (0 + 1)) : ... ) !! n
18:50:53 <Eduard_Munteanu> alex______: it can happen fibs !! n is a big thunk
18:51:42 <alex______> which will result in what? my head is spinning ^_^
18:51:43 <Eduard_Munteanu> alex______: like "scanl (+) 0 [1..] !! n" can overflow the stack
18:51:51 <alex______> oh
18:52:05 <alex______> that is a shame
18:53:35 <Eduard_Munteanu> alex______: an easy fix is to string things together with seqs inbetween
18:53:57 <alex______> I see
18:54:13 <Eduard_Munteanu> alex______: in fact you only need to make the spine of the list tied to the cell contents evaluation-wise
18:54:24 <alex______> how would that look? I dont know a lot about seq
18:54:45 <Eduard_Munteanu> e.g. takeWhile (`seq` True) might be enough
19:14:39 <Axman6> Eduard_Munteanu: is there no scanl'?
19:16:03 <ezrios> Is it possible to modify previous entries in the Writer monad?
19:16:11 <ezrios> I have my entries being produced in reverse order
19:16:25 <Eduard_Munteanu> Axman6: mm, I don't think so... probably because scanl ... !! n can be rewritten as foldl' ... [0..n] in many cases
19:16:59 <Axman6> @hoogle scanl'
19:17:00 <lambdabot> No results found
19:17:04 <Axman6> hmm
19:17:51 <Eduard_Munteanu> ezrios: no. But if you reverse the list only once, it might not be bad.
19:18:14 <ezrios> ugg
19:18:27 <ezrios> Hackerrank challenges were really not designed for haskell
19:18:29 <Axman6> and you almost certainly want to be putting things on the front of the list
19:18:29 <ezrios> ._.
19:18:42 <Eduard_Munteanu> ezrios: or you could newtype your monoid and change it (though you may lose productivity if it's like lists)
19:18:55 <startling> wow, closed type families are so powerful.
19:19:46 <Eduard_Munteanu> startling: are they much different from type families + UndecidableInstance?
19:19:57 <Eduard_Munteanu> I mean, much besides the obvious.
19:20:14 <startling> Eduard_Munteanu, I don't know. It feels much nicer though. :)
19:20:14 * hackagebot quickcheck-instances 0.3.7 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.7 (AntoineLatter)
19:21:27 <Eduard_Munteanu> startling: possibly, I was forced to use typeclasses instead of type families on more than a few occasions because the latter were less powerful recursion-wise.
19:21:44 <heatsink> startling: What use you it for?
19:22:34 <Eduard_Munteanu> If it can do a type-level SplitOn more nicely, I'm interested. :)
19:23:04 <Eduard_Munteanu> Or even Elem.
19:23:43 <startling> heatsink, https://dl.dropboxusercontent.com/u/23845001/doc/soot/Language-Soot-Extra-Trans.html
19:23:51 <Eduard_Munteanu> Normal type families don't like overlapping instances.
19:23:55 <startling> n-ary Either and Maybe transformers. :)
19:24:15 <n^izzo> I want to install cable but the cable install page says do "apt-get install ghc6" but isnt ghc up to 7.6
19:24:45 <Eduard_Munteanu> Call the cable company. :P
19:24:52 <n^izzo> lol
19:25:07 <Axman6> cabal ;)
19:25:22 <heatsink> Hmm.  Not sure what those type parameters mean.
19:25:43 * heatsink can't view the source for some reason
19:25:51 <heatsink> Oh wait
19:25:54 <heatsink> that's not hackage :)
19:26:02 <startling> heatsink, Sum [WriterT, ReaderT, MaybeT] IdentityT a
19:26:06 <Eduard_Munteanu> Heh.
19:26:21 <startling> definitely not hackage. :)
19:26:39 <startling> er, Sum [WriterT, ReaderT, MaybeT] Identity a
19:26:40 <Eduard_Munteanu> startling: I think that's already doable with type families
19:26:54 <startling> Eduard_Munteanu, I'm doing it with type families.
19:27:04 <Eduard_Munteanu> I mean non-closed.
19:27:13 <startling> oh, sure, it's just not right without them. :)
19:27:37 <Eduard_Munteanu> type family FoldCst (css :: [Constraint]) :: Constraint; type instance FoldCst (c ': cs) = (c, FoldCst cs)
19:27:39 <startling> why doesn't cabal haddock add source links?
19:27:47 <heatsink> So you're generalizing some code over a fixed set of monad transformers?
19:27:56 <Eduard_Munteanu> startling: ah you mean since it's total anyway? Yeah, and checking that would be nice.
19:28:36 <startling> heatsink, ish. I'm writing an AST that allows arbitrary transformers and doing e.g. AST '[Where, Let] v -> Ast '[Let] v -> AST '[] v
19:28:52 <startling> or that's the idea anyway.
19:29:16 <startling> not sure why my AST isn't getting haddocked.
19:29:48 <heatsink> interesting
19:30:23 <startling> oh, it's not in exposed-modules, oops
19:30:29 <heatsink> That reminds me.  Is there a haskell-mode for emacs that doesn't interpret single-quotes in types as the beginning of a character literal?
19:30:38 <heatsink> it messes up indentation
19:32:13 <startling> https://dl.dropboxusercontent.com/u/23845001/doc/soot/index.html <- with the AST
19:32:16 <enthropy> you can leave off the ' often
19:32:23 <startling> (source, too)
19:32:30 <startling> heatsink, I don't have a problem with that.
19:32:34 <startling> in haskell-mode + shm
19:32:39 <startling> perhaps update haskell-mode?
19:32:47 <pavonia> startling: How can you apply Either2 to six type variables when the data definition only takes four?
19:32:52 <heatsink> It has been a few years since I updated it.
19:33:43 <enthropy> pavonia: the first couple variables are kind variables
19:33:51 <enthropy> it's a bit confusing at first
19:34:00 <startling> pavonia: I was wondering about that too, heh
19:34:12 <startling> it's not like that in the source
19:34:24 <startling> oh, but {-# LANGUAGE PolyKinds #-}
19:35:03 <pavonia> enthropy: Can you elaborate?
19:35:29 <Eduard_Munteanu> pavonia: Foo (x :: k) shows up as Foo k x
19:35:35 <startling> enthropy, see the instance Functor (VoidT k * f)
19:35:42 <startling> er
19:35:44 <startling> pavonia: ^
19:35:48 <pavonia> Oh, that's really confusing
19:36:17 <startling> it says "VoidT is a functor for a parameter f of any kind k and taking an argument of any kind *"
19:36:22 <startling> it is odd.
19:36:27 <startling> PolyKinds does it automatically.
19:36:41 <enthropy> there doesn't seem to be a way to connect which kind variable is attached to which type variable from what haddock/ghc print out
19:36:49 <startling> yeah.
19:38:50 <startling> I'm so proud of "N-ary transformer transformers.". 8)
19:40:54 <Eduard_Munteanu> enthropy: also the lack of kind synonyms is getting annoying
19:41:20 <startling> I've noticed that.
19:41:53 <startling> type Transformer :: (* -> *) -> * -> * would be useful.
19:41:55 <Eduard_Munteanu> I've used rather big definitions to work with e.g. categories, and it gets rather awful at some point.
19:42:59 <jle`> uncurry . uncurry
19:43:02 <jle`> good idea or bad idea?
19:43:05 <startling> heh
19:43:36 <jle`> when carrying the arguments to a three-parameter function in a list
19:44:14 <jle`> map ((uncurry . uncurry) f) [((1,2),3),...]
19:44:28 <jle`> maybe i should just unzip and zipwith
19:45:45 <Eduard_Munteanu> e.g. something like  data CategoryK ob arr star = CategoryT (ob -> arr) (ob -> ob -> arr) (arr -> star)  is alright, but when I need to talk about functors and what not, it gets really bad.
19:46:50 <Eduard_Munteanu> An workaround is to interpose a GADT (and get constraints when you pattern-match the constructor), but it still sucks.
19:48:13 <heatsink> Is there a particular obstacle to extending all type-level features to kinds and higher levels of the hierarchy?
19:50:01 <Eduard_Munteanu> heatsink: even syntax would be an issue I think
19:53:15 <heatsink> Hmm.
19:53:36 <ezrios> can I not have a where clause across multiple pattern matches?
19:53:38 <Eduard_Munteanu> heatsink: if you look at Agda, things seem way neater than Haskell's long string of kludges to enable type trickery.
19:54:28 <Eduard_Munteanu> ezrios: you can attach a 'where' clause to any definition, so you could use it on an inner let
19:54:33 <geekosaur> ezrios, you can but might need to be careful about indentation depending on what else is there
19:54:59 <OspiteCGI846> is there a lens equivalent for (!! n)?
19:55:00 <Eduard_Munteanu> You may be able to use braces to make things more clear.
19:55:03 <heatsink> ezrios: It is not shared across equations.  You can rewrite multiple equations using case
19:55:13 <ezrios> geekosaur: I am matching against the empty list and (x:xs)
19:55:20 <edwardk> > "hello" ^? ix 2
19:55:22 <Eduard_Munteanu> OspiteCGI846: indexed lenses, I think
19:55:23 <ezrios> but I have a function that I want to use in both pattern match clauses
19:55:23 <lambdabot>  Just 'l'
19:55:36 <ezrios> I suppose I could just lift this out to top level
19:55:40 <edwardk> > "hello" ^?! ix 2
19:55:41 <lambdabot>  'l'
19:55:54 <heatsink> ezrios: f xs = case xs of {...} where ...
19:55:55 <OspiteCGI846> over (ix 2) 10 [1..5]
19:55:58 <OspiteCGI846> > over (ix 2) 10 [1..5]
19:55:59 <lambdabot>  Could not deduce (Control.Lens.Internal.Indexed.Indexable
19:55:59 <lambdabot>                      GHC.Types.Int p0)
19:56:00 <lambdabot>    arising from the ambiguity check for `e_121015'
19:56:00 <lambdabot>  from the context (GHC.Enum.Enum t,
19:56:00 <lambdabot>                    GHC.Num.Num (p t t),
19:56:05 <OspiteCGI846> oops
19:56:17 <Eduard_Munteanu> ezrios: perhaps you can unify those two pattern cases and make an inner case?
19:56:29 <haasn> edwardk: I wonder what would happen if we benchmark (!! i) against (^?! ix i)
19:56:31 <OspiteCGI846> how would it work with a function? I find it easier to understand it like that at first
19:56:40 <haasn> against (^?! folded.index i)
19:57:15 <edwardk> haasn: (!!n) would win
19:57:26 <edwardk> the recursive stuff is where lens loses
19:57:47 <haasn> recursive stuff?
19:58:09 <Eduard_Munteanu> edwardk: because of typeclass dictionaries?
19:59:08 <haasn> time to test it
19:59:32 <OspiteCGI846> > set (ix 2) 10 [1..5]
19:59:34 <lambdabot>  [1,2,10,4,5]
19:59:46 <OspiteCGI846> cool
20:00:44 <zzo38> How can I make a GADT to implement Hofstadter's MIU system?
20:01:47 <ezrios> Eduard_Munteanu: I just lifted the function out to top level
20:01:53 <ezrios> woo, babby's first RWST
20:02:09 <ezrios> I now know what the hell a transformer is
20:02:34 <ski> zzo38 : dunno what that is
20:02:46 <haasn> edwardk: (!! i) and (^?! ix i) are identical
20:02:52 <haasn> edwardk: folded.index i is an order of magnitude slower
20:03:07 <edwardk> better than expected
20:03:13 <haasn> (about 5x actually)
20:03:24 <edwardk> folded.index i doesn't know it can stop
20:03:30 * geekosaur suddenly realizes he copy of _GEB_ is gone :(
20:03:33 <geekosaur> *his
20:03:33 <haasn> I sort of expected ‘ix’ and (!!) to be the same because the Const stuff gets inlined and eliminated, right?
20:03:41 <haasn> so it's not much different from (!!)'s recursive definition
20:03:58 <edwardk> haasn: it was mostly about whether it could figure that out about the recursive function
20:04:23 <edwardk> the various iterated etc combinators are where we suffer a big hit
20:04:43 <syllogismos> -- | Do anything other than reverse a list.
20:04:43 <syllogismos> --
20:04:43 <syllogismos> -- >>> notReverse Nil
20:04:43 <syllogismos> -- []
20:04:43 <syllogismos> --
20:04:43 <syllogismos> -- prop> let types = x :: List Int in notReverse x ++ notReverse y == notReverse (y ++ x)
20:04:48 <haasn> ah, makes sense
20:05:11 <syllogismos> what does notReverse do?
20:05:21 <geekosaur> (even if it does siuffer from the usual problems when someone tries to use math to argue philosophy...)
20:05:26 <zzo38> ski: It is a system where every string must start with "M", and other than that contains "I" and "U". If "x" and "y" can represent arbitrary strings, the rules are: xI -> xIU, Mx -> Mxx, xIIIy -> xUy, xUUy -> xy.
20:06:00 <zzo38> geekosaur: How did it get gone?
20:06:41 <geekosaur> all my books were in storage. brother in law moved them to non-climate-controlled storage. now they're masses of mold
20:07:08 <startling> geekosaur: aw. :(
20:07:47 <jfischoff> Eduard_Munteanu: I can't get anything to work as RecordWildCard pattern and I don't think I will be able to
20:08:03 <Eduard_Munteanu> :(
20:08:13 <syllogismos> https://github.com/NICTA/course/blob/master/src/Course/List.hs#L303 from here..
20:08:17 <jfischoff> trace out the this [|\(Foo {..}) -> x|] show that TH expands the pattern
20:08:18 <c_wraith> zzo38: it looks awfully tough.  the production rules involve arbitrary bits from the middle.
20:09:21 <jfischoff> I'm surprised how few TH utility libraries have been written
20:09:42 <geekosaur> many people find TH painful
20:09:45 <c_wraith> zzo38: is that the full set of rules?  It doesn't look right.  I can't see how to have a valid string other than M with those rules.
20:10:00 <zzo38> c_wraith: Well, there is one more: You start by MI.
20:10:13 <jfischoff> I end up rewriting the same functions a lot
20:10:14 <c_wraith> zzo38: ok, that's the missing piece that makes the whole thing work.
20:10:22 <jfischoff> I should put something together
20:10:33 <jfischoff> at least there are lenses/prisms now
20:11:28 <haasn> zzo38: you could do certainly do it with (undecidable) TFs
20:12:03 * geekosaur suspects this is not the ideal way to try to derive MU...
20:12:12 <c_wraith> zzo38: interesting, the M is completely irrelevant, except as a delimiter.  Every rule could be written without it.
20:12:13 <haasn> perhaps not :)
20:12:47 <geekosaur> afaik it's only in there to get MU since he was going on about the Zen "mu" all the time
20:12:50 <c_wraith> but yes, then you lose the pun that you can't get to MU
20:13:06 <zzo38> c_wraith: Yes it is true the M is only the delimiter
20:14:32 <zzo38> haasn: What does "TFs" mean?
20:14:42 <haasn> zzo38: type families
20:14:45 <zzo38> OK
20:15:06 <zzo38> I don't see how type families can do it either.
20:15:49 <thebnq> > (+1) <$ Nothing <*> Just 0 <* Nothing --why isn't this working as i think i should
20:15:51 <lambdabot>  Nothing
20:16:10 <zzo38> thebnq: What do you think it should?
20:16:15 <zzo38> And why?
20:16:28 <thebnq> Just 1, i assume it should drop the last
20:16:43 <haasn> I was thinking something like AxiomIII :: SplitIII s x y => MU s -> MU (x ++ '[U] ++ y)
20:16:45 <zzo38> Nothing is the correct answer, because if you combine a Just and Nothing in this way, you get Nothing.
20:16:45 <Eduard_Munteanu> (+1) <$ Nothing <*> Just 0
20:16:48 <Eduard_Munteanu> > (+1) <$ Nothing <*> Just 0
20:16:49 <lambdabot>  Nothing
20:16:50 <Axman6> syllogismos: I'm pretty sure that the point of that code is for you to figure out what it does ;)
20:16:56 <haasn> But I'm not sure if you can actually define SplitIII in a backtracking fashion like that
20:17:30 <thebnq> weird i was pretty sure i tried just that and it gave me just 1
20:17:53 <haasn> eg. instance SplitIII (I ': I ': I ': xs) '[] xs;  instance SplitIII s xs ys => SplitIII (x ': s) (x ': xs) ys
20:17:54 <Eduard_Munteanu> thebnq: the missing '>' in '<$' and '<*' refers to the action result, not its "side-effects"
20:18:04 <zzo38> thebnq: Well, I am pretty sure it isn't supposed to give you Just 1.
20:18:19 <Axman6> syllogismos: that said, I can't think of an implementation that works for those properties
20:18:27 <haasn> I'm not sure that will work. I'd love to know!
20:18:33 <Eduard_Munteanu> :t (<$)
20:18:33 <thebnq> I thnk i misunderstood <4
20:18:34 <lambdabot> Functor f => a -> f b -> f a
20:18:44 <thebnq> @src <$
20:18:45 <lambdabot> (<$) = (<$>) . const
20:18:50 <zzo38> The <$ means replace the value with the value given on the left; since Nothing has no value, it remains Nothing.
20:19:44 <zzo38> > 'x' <$ [1,2,3,4,5] -- This is another example how it work
20:19:45 <lambdabot>  "xxxxx"
20:19:47 <Eduard_Munteanu> You can specialize it to  a -> f () -> f a  if you like.
20:20:09 <Eduard_Munteanu> :t (>>)
20:20:10 <lambdabot> Monad m => m a -> m b -> m b
20:21:11 <Eduard_Munteanu> :t (*>)
20:21:12 <lambdabot> Applicative f => f a -> f b -> f b
20:21:14 <zzo38> It happens to be the same *> as >> except that >> is for a monad and *> is applicative. And then there is <* which uses the result on the left instead of the result on the right.
20:21:56 <zzo38> And then <*> which uses both, and uses the left one as having the function you need to apply, using the one on the right as its argument, to make up the result.
20:21:59 <Eduard_Munteanu> Also note  flip (<*)  isn't the same as  (*>)
20:22:35 <zzo38> Yes, it isn't same, because in all cases the "action" on left is at first, and then the one on the right. (However, applicative can be turned backwards, to make another applicative. This isn't the case with monads.)
20:22:58 <haasn> I want backwards IO :(
20:23:04 <syllogismos> Axman6 yeah its a weird function.. I don't know what the author is trying to tell me..
20:23:46 <zzo38> haasn: Well, there isn't any way you will be able to use such a thing, since it is possible to make it a Applicative, but not a Monad, so you cannot join the result into the next effect.
20:23:55 <startling> > 1 <$ [0, 2, 4]
20:23:56 <lambdabot>  [1,1,1]
20:24:15 <Axman6> syllogismos: i feel it may not be, you can ask dibblego when he's here though ;)
20:24:21 <Eduard_Munteanu> > (flip (<*) (Just 1) Nothing, Just 1 *> Nothing)
20:24:22 <lambdabot>  (Nothing,Nothing)
20:24:31 <Eduard_Munteanu> Er.
20:24:53 <Eduard_Munteanu> > (flip (<*) (Just 1) n, Just 1 *> n)
20:24:55 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a0'
20:24:55 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
20:24:55 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
20:24:55 <haasn> zzo38: you could still <*> on it, to be fair
20:25:04 <Eduard_Munteanu> Bleh, nevermind.
20:25:07 <zzo38> Maybe is a commutative Applicative, though.
20:25:19 <Eduard_Munteanu> Yeah. :)
20:25:21 <zzo38> haasn: Yes, you could, but it wouldn't help.
20:25:59 <startling> has anyone written a github webhook thing that rebuilds haddock docs and pushes them to gh-pages?
20:26:29 <startling> edwardk: do you rebuild the lens haddocks by hand?
20:27:20 <Eduard_Munteanu> startling: how about a git hook?
20:29:23 <startling> Eduard_Munteanu: that would be a pain for e.g. pull request merges, I think
20:30:24 * hackagebot monad-parallel 0.7.1.2 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.7.1.2 (MarioBlazevic)
20:45:26 * hackagebot yes-precure5-command 5.0.1 - Extended yes command to reproduce phrases in Yes! Precure 5  http://hackage.haskell.org/package/yes-precure5-command-5.0.1 (igrep)
20:49:14 <phyre> Is there a claner method of implementing this? Or should I just stick with the one-liner that looks better (in my opinion)? http://lpaste.net/7418413375035539456
20:52:15 <jle`> how...does that one liner...look better...in any universe
20:53:03 <Axman6> agreed...
20:53:08 <enthropy> it's not complete either
20:53:09 <phyre> oh man, that hurts
20:53:18 <enthropy> blah blah stands for something I hope
20:53:22 <dwcook> phyre, I would suggest avoiding the needlessly partial function (!!).
20:53:35 <phyre> yeah, it just continues listing more numbers (one for each month)
20:53:36 <dwcook> Especially since you don't guard its use.
20:53:44 <haasn> (!!) has little reason to exist
20:54:05 <phyre> Hmm, what other method exists that does the same?
20:54:05 <jle`> its name is kinda scary but it doesn't really stop people
20:54:26 <haasn> if it did the same that other method wouldn't have any reason to exist either
20:55:15 <jle`> lists aren't meant for rancom access etc.
20:55:59 <phyre> I also thought about zipping up months with their values, but i found that to be easier
21:01:10 <DrAwesomeClaws> either I'm wrong or the Haskell type system is wrong.  Must be the type system, as my logic is assumed impeccable
21:10:51 <haasn> DrAwesomeClaws: good, use unsafeCoerce to show it who's right
21:11:07 <stephenmac7_> How would I use an applicative with a variable number of lists?
21:11:39 <DrAwesomeClaws> using unsafe prefixed functions just shows how good a programmer i am.  Unsafe things don't scare me
21:12:06 <prophile> stephenmac7_: what kind of thing do you have in mind to do?
21:12:32 <stephenmac7_> prophile: Find every combination of the elements in seperate lists
21:12:35 <prophile> (I suspect the answer, given that "variable number of lists" ~ "list of lists", is "use the monad instance")
21:12:44 <haasn> stephenmac7_: sequence?
21:12:55 <haasn> > sequence ["abc", "XYZ", "12"]
21:12:57 <lambdabot>  ["aX1","aX2","aY1","aY2","aZ1","aZ2","bX1","bX2","bY1","bY2","bZ1","bZ2","cX...
21:13:19 <stephenmac7_> Is there a sequence which allows you to manually give a function that combines the values?
21:13:26 <stephenmac7_> Like (\(g1, r1) (g2, r2) -> ([g1, g2], r1 * r2))
21:13:51 <stephenmac7_> (For two lists I do this: (\(g1, r1) (g2, r2) -> ([g1, g2], r1 * r2)) <$> a <*> c )
21:13:53 <prophile> stephenmac7_: map on the result?
21:13:55 <startling> stephenmac7_, I'm not sure what you're asking for.
21:14:08 <stephenmac7_> It's hard to explain
21:14:13 <stephenmac7_> I'm sorry about that
21:14:47 <kusut> why cant ghc-mod find Hakyll on emacs (syntax error)? All deps are all setup correctly and my app can be buit
21:14:53 <stephenmac7_> haasn: Anything like a sequenceWith?
21:15:04 <haasn> stephenmac7_: I'm not sure what that would do
21:15:05 <haasn> :t sequence
21:15:06 <prophile> stephenmac7_: there's traverse which is a bit like it
21:15:06 <lambdabot> Monad m => [m a] -> m [a]
21:15:24 <haasn> hmm, come to think of it
21:15:26 <haasn> :t liftM3
21:15:27 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
21:15:32 <haasn> stephenmac7_: ^
21:15:50 <haasn> > liftM3 (,,) "abc" "XYZ" [1,2]
21:15:51 <lambdabot>  [('a','X',1),('a','X',2),('a','Y',1),('a','Y',2),('a','Z',1),('a','Z',2),('b...
21:15:58 <stephenmac7_> Hm.
21:16:02 <stephenmac7_> That might work
21:16:06 <ski> > pure (\x y -> concat [show x," * ",show y," = ",show (x * y)]) <*> [2,3,4] <*> [5,6]
21:16:08 <lambdabot>  ["2 * 5 = 10","2 * 6 = 12","3 * 5 = 15","3 * 6 = 18","4 * 5 = 20","4 * 6 = 24"]
21:16:21 <ski> > liftM2 (\x y -> concat [show x," * ",show y," = ",show (x * y)]) [2,3,4] [5,6]
21:16:22 <lambdabot>  ["2 * 5 = 10","2 * 6 = 12","3 * 5 = 15","3 * 6 = 18","4 * 5 = 20","4 * 6 = 24"]
21:16:25 <haasn> oh, of course, applicative sugar would work well here too
21:16:41 <ski> > (\x y -> concat [show x," * ",show y," = ",show (x * y)]) <$> [2,3,4] <*> [5,6]
21:16:42 <lambdabot>  ["2 * 5 = 10","2 * 6 = 12","3 * 5 = 15","3 * 6 = 18","4 * 5 = 20","4 * 6 = 24"]
21:17:27 <enthropy> @hackage applicative-quoters
21:17:27 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
21:17:33 <stephenmac7_> :t liftM3
21:17:34 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
21:17:42 <stephenmac7_> :t liftM2
21:17:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:18:16 <haasn> stephenmac7_: [f x y z | x <- list1, y <- list2, z <- list3 ]  also works
21:18:28 <stephenmac7_> I don't know how many lists I have
21:18:53 <stephenmac7_> So I can't do liftM3
21:18:55 <haasn> then you're left with map f . sequence
21:19:03 <stephenmac7_> :t map f . sequence
21:19:04 <lambdabot> (Show a, FromExpr b) => [[a]] -> [b]
21:19:10 <haasn> :t map ?f . sequence
21:19:12 <lambdabot> (?f::[a] -> b) => [[a]] -> [b]
21:19:32 <stephenmac7_> Example?
21:20:52 <haasn> > map sort $ sequence ["123","abc","cba"]
21:20:53 <lambdabot>  ["1ac","1ab","1aa","1bc","1bb","1ab","1cc","1bc","1ac","2ac","2ab","2aa","2b...
21:21:00 <ski> stephenmac7_ : all lists have the same type ?
21:21:04 <stephenmac7_> Yes
21:26:12 <augur_> thats an interesting type
21:26:19 <augur_> (?f :: [a] -> b) => [[a]] -> [b]
21:26:39 <stephenmac7_> haasn: That worked
21:26:42 <stephenmac7_> Thanks!
21:26:48 <augur_> :t ?x
21:26:49 <lambdabot> (?x::t) => t
21:27:07 <stephenmac7_> Even though the code is now incomprehensible
21:27:09 <haasn> augur_: the (?x::t) stuff?
21:27:13 <augur_> haasn: yeah
21:27:15 <augur_> :t ?x + ?x
21:27:16 <lambdabot> (Num a, ?x::a) => a
21:27:26 <prophile> -XImplicitParams
21:27:28 <haasn> augur_: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
21:27:29 <augur_> very interesting :)
21:28:56 <augur_> haasn: its very much like implicit arguments in agda
21:29:05 <augur_> and very much like type classes too
21:29:21 <augur_> except that it seems to not be dependent on global existence, but only local existence
21:29:39 <haasn> they're a fascinating beast, certainly
21:30:05 <augur_> they're also what i accidentally invented for this NLUI thing im doing
21:30:15 <augur_> well, nearly
21:31:01 <augur_> the existence is in the type, rather than the value, which is probably a better option
21:31:09 <Shin-LaC> how do I avoid the following error when using ^2 ? Warning: Defaulting the following constraint(s) to type `Integer'
21:31:25 <startling> Shin-LaC, ^ (2 :: Integer)
21:31:33 <startling> :t (^)
21:31:34 <lambdabot> (Integral b, Num a) => a -> b -> a
21:31:39 <startling> :t (**)
21:31:40 <lambdabot> Floating a => a -> a -> a
21:31:45 <startling> :t (^^)
21:31:46 <lambdabot> (Fractional a, Integral b) => a -> b -> a
21:32:09 <startling> Shin-LaC: do you see why that happens?
21:32:39 <Shin-LaC> 2 could be various types, right?
21:32:55 <startling> yeah; any type implementing Num.
21:33:32 <startling> there's a 'default' Num, Integer, but it's widely-considered a bad idea to rely on its existence
21:33:32 <haasn> augur_: I'm reasonably confident you can emulate it using something like a class Exists (s :: Symbol) (t :: *)
21:33:43 <haasn> oh, but then you can't generate local instances
21:33:44 <haasn> Hmm.
21:33:48 <haasn> that + reflection, then ;)
21:33:56 <Shin-LaC> startling: any type implement Integral, you mean, right?
21:34:13 <startling> :t (^) -- no
21:34:14 <lambdabot> (Integral b, Num a) => a -> b -> a
21:34:22 <startling> the second argument has Num.
21:34:37 <augur_> haasn: :p
21:35:14 <Shin-LaC> oh
21:35:30 <Shin-LaC> so I should be using **, maybe?
21:35:54 <startling> Shin-LaC: nah?
21:36:12 <Shin-LaC> I want the square of a Double x
21:36:17 <Shin-LaC> what's the preferred way to do it?
21:36:28 <startling> Shin-LaC: what you have is fine.
21:36:29 <Shin-LaC> x*x or x^(2::Int) or x**2 ?
21:36:42 <startling> > (2 :: Double) ^ (2 :: Int)
21:36:43 <lambdabot>  4.0
21:40:02 <Shin-LaC> what's a good choice for defining a sum operator for vectors?
21:40:07 <Shin-LaC> I'm using .+ at the moment
21:41:33 <startling> Shin-LaC, have you seen 'linear' on Hackage?
21:43:53 <harasskell> @pl quicksort [] = []; quicksort (x:xs) = quicksort (filter (\n -> n < x) xs) ++ [x] ++ quicksort (filter (\n -> n > x) xs)
21:43:53 <haasn> Shin-LaC: x*x
21:43:53 <lambdabot> (line 1, column 15):
21:43:53 <lambdabot> unexpected " "
21:43:53 <lambdabot> expecting operator
21:50:28 <Shin-LaC> hrm
21:50:35 <Shin-LaC> startling: I'll check it out
21:50:40 <Shin-LaC> can I have a class without operations?
21:51:58 <haasn> Shin-LaC: yes, you can even leave off the “where” part of the syntax
21:52:44 <Shin-LaC> if I have a number of different geometric shapes, is it better to have them as different types, instances of a shape class? or as different constructors of a single type shape?
21:53:09 <Shin-LaC> I will want to have some operations that require a specific type of shape, though
21:53:24 <Shin-LaC> I guess they could take a Shape type, but not be defined for some constructors
21:53:54 <startling> that's bad practice (unless the result is in Maybe or something)
21:54:29 <Shin-LaC> ok, then they should be different types
21:54:48 <startling> you could do data Polygon = Polygon [V2 Int] or something. 8)
21:54:53 <haasn> Shin-LaC: you could also consider having an abstract “shape” record that doesn't define what kind of shape it is, but rather how it responds to various queries
21:55:23 <randomclown> @pl \acc x -> f $ acc <> x
21:55:23 <lambdabot> (f .) . (<>)
21:55:29 <randomclown> ewww
21:55:37 <haasn> eg. data Shape = Shape { area, boundingDiamater, circumference :: Int, translate :: (Int,Int) -> Shape }
21:55:48 <startling> :t let (.:) = (.) . (.) in \f -> f .: (<>)
21:55:49 <lambdabot> Monoid b => (b -> c) -> b -> b -> c
21:56:11 <haasn> Shin-LaC: or even data Circle = Circle ...; data Square = Square ...
21:56:22 <haasn> and then functions :: Circle -> Shape, Square -> Shape
21:56:29 <haasn> (instead of using a type-class)
21:56:30 <Shin-LaC> I'm trying to do data Circle = Circle Point Double, etc
21:56:42 <Shin-LaC> but I need an intersect function between any two shapes
21:56:42 <startling> Shin-LaC: a class is a reasonable way, then.
21:56:45 <haasn> it really depends on the specifics of what kinds of abstractions you end up needing
21:56:49 <haasn> there's no stock answer
21:56:53 <startling> oh, hrm, that's tricky.
21:56:55 <Shin-LaC> how can I define a class with no operation?
21:57:06 <augur_> Shin-LaC: an intersect function?
21:57:06 <startling> Shin-LaC, class Oops a
21:57:09 <augur_> that does what?
21:57:21 <Shin-LaC> augur_: checks if two shapes intersect
21:57:53 <startling> Shin-LaC, data Shape = Polygon [V2 Int] | Circle (V2 Int) Int | Intersection Shape Shape | Union Shape Shape
21:58:05 <haasn> startling: apparently that's not what he meant :(
21:58:19 <augur_> Shin-LaC: you might want to use some generic n-gon sort of thing. or like, a bezier path thing.
21:58:41 <haasn> startling: if you just need to intersect and union like that you could also consider Shape = Coords -> Bool and using liftA2 (&&) and liftA2 (||)
21:59:06 <alskdj> does this look like the most reasonable way to delete an element from a list?  delete x l = uncurry (++) $ second (drop 1) $ splitAt x l
21:59:30 <Shin-LaC> <startling>	 Shin-LaC, data Shape = Polygon [V2 Int] | Circle (V2 Int) Int | Intersection Shape Shape | Union Shape Shape <- this is what I had
21:59:34 <augur_> @src delete
21:59:34 <lambdabot> delete = deleteBy (==)
21:59:43 <augur_> @src deleteBy
21:59:43 <lambdabot> deleteBy eq x []        = []
21:59:43 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
21:59:44 <Shin-LaC> but I also want to have some operations that are only defined on a specific type of shape
22:00:02 <augur_> alskdj: i think that looks like the mose reasonable way to delete an element from a list
22:00:08 <alskdj> augur_, it is deleting by index, not equality
22:00:13 <startling> haasn: heh, neat idea
22:00:21 <startling> also makes rendering simple (if not efficient)
22:00:25 <Shin-LaC> for example, a function to get the distance between a point and a line
22:00:28 <augur_> alskdj: l is the index?
22:00:30 <augur_> or x?
22:00:38 <alskdj> x is the index, l is the list
22:00:39 <Shin-LaC> I guess I could define the distance between a point and any shape, though I don't really need it
22:00:51 <startling> Shin-LaC: is that well-defined?
22:01:04 <Shin-LaC> in theory, yes
22:01:06 <startling> there are potentially multiple distances between a point and a line
22:01:10 <augur_> alskdj: then why not something like   deleteIndex i xs = take i xs ++ drop (i+1) xs
22:01:27 <haasn> > [1..10 ^.. folded.indices (/= 5) -- :)
22:01:28 <lambdabot>  <hint>:1:39:
22:01:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:01:29 <alskdj> that looks nicer
22:01:33 <haasn> > [1..10- ^.. folded.indices (/= 5)
22:01:34 <lambdabot>  <hint>:1:9: parse error on input `^..'
22:01:40 <haasn> typing is not my strong point today
22:01:44 <haasn> > [1..10] ^.. folded.indices (/= 5)
22:01:46 <lambdabot>  Couldn't match expected type `(a0
22:01:46 <lambdabot>                                 -> Control.Lens.Internal.Getter.Accessor
22:01:46 <lambdabot>                                      (Data.Monoid.Endo [a0]) a0)
22:01:46 <lambdabot>                                -> t0
22:01:46 <lambdabot>                                -> Control.Lens.Internal.Getter.Accessor
22:01:50 <augur_> @hoogle Int -> [a] -> [a]
22:01:51 <lambdabot> Prelude drop :: Int -> [a] -> [a]
22:01:51 <lambdabot> Data.List drop :: Int -> [a] -> [a]
22:01:52 <lambdabot> Prelude take :: Int -> [a] -> [a]
22:02:11 <augur_> no deleteIndex :(
22:02:17 <haasn> bleh that code works here
22:02:25 <startling> :t dropAt -- ? I think it's spelled like this
22:02:26 <haasn> I think lambdabot's folded is unindexed
22:02:26 <lambdabot>     Not in scope: `dropAt'
22:02:27 <lambdabot>     Perhaps you meant one of these:
22:02:27 <lambdabot>       `drop' (imported from Data.List),
22:02:38 <augur_> @hoogle dropAt
22:02:38 <lambdabot> No results found
22:02:45 <startling> hrm.
22:03:04 <augur_> how clever would it be if you could do
22:03:10 <startling> > [1..10] ^.. ifolded . indices (/= 5)
22:03:11 <lambdabot>  Couldn't match expected type `(a0
22:03:11 <lambdabot>                                 -> Control.Lens.Internal.Getter.Accessor
22:03:12 <lambdabot>                                      (Data.Monoid.Endo [a0]) a0)
22:03:12 <lambdabot>                                -> p0 t0 (Control.Lens.Internal.Getter.Accessor
22:03:12 <lambdabot>                                            (Data.Monoid.Endo [a0]) t0)'
22:03:23 <augur_> well i dont know what it would be
22:03:24 <haasn> startling: ifolded is not indexing folded
22:03:34 <haasn> > [1..10] ^.. indexing folded . indices (/= 5)
22:03:36 <lambdabot>  Couldn't match expected type `(a0
22:03:36 <lambdabot>                                 -> Control.Lens.Internal.Getter.Accessor
22:03:36 <lambdabot>                                      (Data.Monoid.Endo [a0]) a0)
22:03:36 <lambdabot>                                -> p0 t0 (Control.Lens.Internal.Getter.Accessor
22:03:36 <lambdabot>                                            (Data.Monoid.Endo [a0]) t0)'
22:03:38 <haasn> Oh no :(
22:03:40 <augur_> something where you defined dropAt in terms of a kind of dual to (!!)
22:04:07 <haasn> oh, indices is not from Lens
22:04:29 <startling> :t (++) <$> take 2 <*> drop 3 $ [1, 2, 3, 4]
22:04:30 <lambdabot> Num a => [a]
22:04:39 <startling> > (++) <$> take 2 <*> drop 3 $ [1, 2, 3, 4]
22:04:41 <lambdabot>  [1,2,4]
22:04:58 <augur_> insertAt i (dropAt i xs) (xs !! i) == xs
22:05:09 <haasn> > [1..10] ^.. indexing folded . Lens.indices (/=5) -- startling: finally!
22:05:10 <lambdabot>  [1,2,3,4,5,7,8,9,10]
22:05:28 <startling> haasn: ahh
22:05:35 <augur_> im sure this is some kind of property of a version of an algebraically specified list type
22:05:52 <startling> augur_, zippers into lists can do that nicely
22:06:31 <augur_> startling: yes, indeed
22:06:49 <augur_> im just thinking of funky specifications of languages via non-trivial equations
22:07:19 <augur_> like, defining map, say, as   (map f xs) !! i = f (xs !! i)
22:07:31 <augur_> which is a kind of copattern i guess
22:08:08 <augur_> but you could go further, i think
22:08:26 <haasn> augur_: type [a] = Natural -> a -- done
22:08:39 <augur_> haasn: ??
22:08:40 <haasn> I'm guessing that's not all of what you wanted :)
22:08:49 <augur_> im not sure what you're suggesting
22:08:50 <haasn> well, if you define (representable) structures like that, you can define functions like that
22:09:07 <haasn> map f xs = (\i -> f (xs i)) -- in that system
22:09:20 <haasn> doesn't extend, of course :P
22:09:43 <augur_> haasn: sure, but thats just one instance, and you have to define it _like that_, rather than using the observational equations
22:09:51 <joelteon> @pl \f xs -> (\i -> f (xs i))
22:09:52 <lambdabot> (.)
22:09:55 <haasn> yeah, I see what you mean
22:09:57 <joelteon> oh so map is (.)
22:10:00 <joelteon> that is clever
22:10:03 <haasn> (.) is also fmap
22:10:05 <haasn> which is cute
22:10:06 <startling> type Vect n a = Fin n -> a
22:10:36 <startling> type List a = exists n. Vect n a ?
22:10:37 <augur_> its also not strictly true that [a] ~ Nat -> a
22:10:42 <haasn> hypothesis: fmap is like (.) for all representable structures
22:10:43 <augur_> you need the existential
22:10:47 <augur_> like startling has
22:10:53 <haasn> augur_: oops, yes
22:10:55 <augur_> Stream a  ~  Nat -> a
22:11:30 <startling> yeah.
22:12:06 <haasn> oh! this is actually a Representable law
22:12:09 <startling> this is an interesting formulation though
22:12:11 <haasn> fmap f . tabulate = tabulate . fmap f
22:12:16 <startling> makes certain things really nice.
22:12:24 <augur_> startling: which what
22:12:25 <haasn> (the latter fmap is (.))
22:12:33 <haasn> cc joelteon
22:12:57 <joelteon> heh, not sure what representable is
22:13:03 <augur_> i wouldnt be surprised if this is somehow an instance of yoneda with the discrete category |Nat being involved somehow
22:13:07 <haasn> joelteon: http://hackage.haskell.org/package/representable-functors-3.2.0.2/docs/Data-Functor-Representable.html
22:13:15 <startling> take = const :)
22:13:25 <startling> for Vect, anyway.
22:13:25 <haasn> joelteon: basically, ‘f’ is representable if (f a) is the same as (r -> a) for some r
22:13:42 <augur_> startling: no, that wouldnt be right
22:13:51 <startling> augur_: you need a type signature.
22:14:01 <joelteon> oh cool
22:14:16 <Shin-LaC> the main problem I have with using a type class without operations is that it messes up syntax coloring in my editor
22:15:09 <augur_> startling: take 5 xs   =   const 5 xs   =   5
22:15:11 <augur_> surely
22:15:19 <augur_> on your suggestion
22:15:24 <startling> augur_: oh right, heh
22:15:26 <startling> flip const
22:15:37 <augur_> take 5 xs = const xs 5 = xs
22:15:41 <startling> augur_, yep.
22:16:01 <augur_> startling: take 5 xs !! 10 = const xs 5 !! 10 = xs !! 10
22:16:06 <joelteon> can someone give me an example of a representable functor that isn't [a]
22:16:19 <haasn> joelteon: [a] isn't representable ;) Do you mean Stream a?
22:16:21 <startling> augur_: < startling> augur_: you need a type signature.
22:16:22 <Shin-LaC> oh man, this is awful
22:16:28 <joelteon> yep stream a
22:16:31 <haasn> joelteon: Identity a ~ (() -> a)
22:16:42 <joelteon> that's not a very interesting instance
22:16:43 <startling> with take :: (n : Nat) -> Vect m a -> if n > m then Vect 0 a else Vect n a -- or something
22:16:56 <haasn> joelteon: (a,a) ≅ Bool -> a
22:17:02 <augur_> startling: ah yes, right, the type should constrain it to be a type error that way
22:17:06 <joelteon> oh, that's kinda cool
22:17:06 <startling> augur_: yeah.
22:17:31 <haasn> joelteon: Reader r a ≅ r -> a -- okay, that one is pretty boring too :)
22:17:48 <augur_> startling: tho you will need some kind of conversion between Fin m and Fin n on the sizes
22:18:15 <Shin-LaC> ok, now I have separate types for each shape, and I define intersect like this:
22:18:16 <Shin-LaC> intersect :: (Shape a, Shape b) => a -> b -> Bool
22:18:16 <haasn> joelteon: in general, any type that has a “fixed” form, eg. a type with only one constructor (and only parameters which also satisfy this property)
22:18:24 <joelteon> Maybe a ~ Bool -> Maybe a
22:18:25 <startling> augur_, it depends how Fin is defined I guess
22:18:26 <joelteon> c:
22:18:33 <Shin-LaC> but the compiler complains when I do: intersect (Circle c r) line@(Line _ _) =
22:18:52 <augur_> startling: well, no matter how its defined, youll need a coercion
22:18:53 <haasn> joelteon: 1. Bool -> Maybe a  is not Bool -> a so this does not make it representable
22:19:00 <Shin-LaC> Couldn't match type `Circle' with `Line'
22:19:07 <joelteon> oh, -> a
22:19:09 <joelteon> whoops
22:19:12 <haasn> 2. Maybe a is not Bool -> Maybe a; the latter has more forms
22:19:18 <Shin-LaC> I don't understand what it's trying to do
22:19:19 <augur_> you could do it cheaply ofcourse, but only for Fin
22:19:25 <startling> yeah.
22:19:40 <joelteon> but (,) isn't a Functor, is it?
22:19:42 <startling> you could have some idea of subtypes/supertypes though
22:19:45 <startling> joelteon: sure it is.
22:19:47 <augur_> startling: it wouldnt work for other index types
22:19:52 <haasn> joelteon: (1+a)² = 1+2*a+a² as many, in fact
22:19:52 <augur_> oh god, subtyping, startling? horrible
22:19:56 <startling> augur_: haha
22:20:05 <augur_> better to be explicit
22:20:05 <joelteon> I thought ((,) a) was a Functor
22:20:08 <joelteon> (,) has the wrong kind
22:20:09 <haasn> joelteon: (,) x is a Functor, but (,) is not
22:20:10 <Axman6> Shin-LaC: you've picked a and b to be specific types there, you can't do that with the type signature you have
22:20:16 <startling> joelteon, oh, yeah, you're right.
22:20:26 <augur_> (,) is a bifunctor tho!
22:20:34 <haasn> joelteon: but newtype Pair a = Pair (a,a) -- is also a functor
22:20:37 <joelteon> so for (a,a) to be Representable
22:20:41 <haasn> Pair a ~ Bool -> a
22:20:42 <joelteon> you'd have to use Pair
22:20:48 <haasn> exactly
22:20:51 <Shin-LaC> Axman6: how do I get around that? I need to be able to define "intersect" for shapes of different types
22:21:01 <haasn> joelteon: have a look at http://covariant.me/notes/rep-functors.html for more intuition
22:21:08 <joelteon> ok thanks
22:21:17 <Shin-LaC> do I need a "shape pair" type class?
22:21:32 <Axman6> that could be one way
22:21:59 <Shin-LaC> can I define the intersect operation in the shape type class?
22:22:07 <startling> not really
22:22:07 <Axman6> or just have all shapes be part of the same type
22:22:21 <startling> well
22:22:24 <joelteon> so there aren't very many "interesting" representable functors
22:22:47 <Axman6> Shin-LaC: do you have a good reason to have each Shape be its own type?
22:23:09 <Shin-LaC> Axman6: only because I wanted to have some functions that only take a specific type of shape
22:23:16 <Shin-LaC> I guess I could leave them undefined for other types
22:23:29 <dwcook> undefined is evil
22:23:58 <augur_> haasn: man that link is funny
22:24:05 <augur_> "Bla In this case ..."
22:24:10 <augur_> "Only vectors (of definite and un-varying length) and strnnnnnnneams (lists of infinite length) are representable."
22:24:16 <Shin-LaC> for example
22:24:27 <Shin-LaC> I need an "edges" function that gives me the edges of a polygon
22:24:34 <Shin-LaC> but it doesn't make sense for a circle
22:24:36 <Shin-LaC> or a line
22:24:42 <augur_> notdan: were you drunk when you wrote that? :D
22:24:42 <haasn> augur_: heh
22:24:45 <augur_> strnnnnnnneams
22:24:56 <startling> lovely
22:27:55 <Shin-LaC> dammit
22:28:21 <Shin-LaC> if I define "intersect" as an operation on Shape
22:28:39 <Shin-LaC> then I do instance Shape Circle where
22:28:44 <Shin-LaC> intersect (Circle c r) line@(Line _ _) =
22:28:51 <Shin-LaC> Couldn't match type `Circle' with `Line'
22:28:53 <Shin-LaC> again
22:29:23 <Shin-LaC> is there any way to have a polymorphic function with two different instances of the same type class?
22:30:00 <dwcook> Shin-LaC, maybe you want a multi-parameter type class
22:30:17 <Shin-LaC> dwcook: you mean a "shape pair" type class?
22:30:26 <dwcook> That works too, I suppose
22:30:34 <Shin-LaC> ok, I don't want that
22:30:38 <Shin-LaC> what's the alternative
22:31:00 <dwcook> Is that undesirable for the same reason as what I suggested? And if so, why is that?
22:31:40 <Shin-LaC> what I said was my interpretation of what you suggested, but it sounds like it's different
22:31:47 <Shin-LaC> what you're thinking of is probably better
22:32:02 <Shin-LaC> I just don't want to have to call intersect (circle, line)
22:32:02 <dwcook> class Foo a b where …
22:32:03 <Shin-LaC> with a tuple
22:32:28 <Shin-LaC> what would you call "Foo" in this case?
22:32:35 <dwcook> The typeclass name.
22:32:46 <dwcook> Weren't you already trying to define a typeclass?
22:32:58 <Shin-LaC> my type class was called "Shape"
22:32:59 <dwcook> Your Shape, that is
22:33:05 <Shin-LaC> Shape a b?
22:33:09 <startling> is there a nice way to keep track of the history of a recursive structure?
22:33:26 <dwcook> Well, you might not want it in the same typeclass as the single-shape-related things
22:33:34 <startling> it'd be nice to be able to say "this tree has an error; it was generated from this other tree during process x"
22:33:35 <Shin-LaC> ShapePair a b?
22:33:55 <startling> (for arbitrary subtrees)
22:34:29 <Shin-LaC> but then don't I have to make a (Circle, Line) tuple an instance of ShapePair? and then I have to call "intersect (circle, line)" instead of "intersect circle line"? or is there a way around it?
22:34:32 <dwcook> Something like that. Though in retrospect I'm not sure that's a great idea either
22:34:42 <dwcook> Why are you making tuples of things?
22:35:04 <Shin-LaC> well, I need something to be a ShapePair, right?
22:35:10 <dwcook> What is ShapePair?
22:35:19 <Shin-LaC> the type class where I define intersect
22:35:36 <dwcook> I'm not seeing why you think you need tuples
22:36:05 <startling> Shin-LaC, describe your algorithm for intersections
22:36:25 <Shin-LaC> ok, let me see if I can make it work without tuples
22:36:39 <Shin-LaC> startling: there is a different algorithm for each different pair of shapes, yes
22:36:52 <Shin-LaC> (unordered pair, naturally)
22:37:26 <dwcook> That would be one problem with this particular approach – Theoretically you'd want intersect a b to be the same as intersect b a
22:37:39 <dwcook> so you might have slight duplication
22:38:23 <startling> Shin-LaC, ok! so, data Shape = Circle' Circle | Polygon' Polygon
22:38:32 <startling> intersection :: Shape -> Shape
22:38:46 <startling> intersecton (Circle' c, Polygon' p) = ...
22:38:55 <startling> intersection (x, y) = intersection (y, x)
22:39:12 <dwcook> startling, how is (x, y) :: Shape?
22:39:20 <startling> oops
22:39:22 <Shin-LaC> dwcook: you were right, I don't have to use a tuple
22:39:40 <startling> should be intersection :: (Shape, Shape) -> Shape but you should probably curry it too
22:39:49 <Shin-LaC> somehow I was under the impression that you needed to have some single thunk that "is" an instance of the class
22:40:04 <pavonia> Can't you transform your Shape's perimeter information into a fixed set of primitives that are used for calculation the intersection?
22:40:15 <Shin-LaC> but in this case two separate arguments can be used without even having to put them in a tuple
22:40:20 <startling> That's the other approach, yeah.
22:40:29 <dwcook> I'd say pavonia's suggestion would be ideal
22:40:43 <startling> but it's hard to see what those primitives would be at first glance
22:40:55 <Shin-LaC> I'm happy with what I have now with {-# LANGUAGE MultiParamTypeClasses #-}
22:41:00 <dwcook> Indeed – Maybe a certain degree of approximation is in order
22:41:13 <startling> yeah. everything being polygons would be the best way, I think.
22:41:27 <startling> and have circles be 100gons or something
22:41:56 <startling> anyway I'm sure this is a well-studied problem
22:42:03 <dwcook> or n-gons, where n is however many necessary to make the approximation negligible
22:42:32 <startling> hm, yes
22:42:47 <startling> circle :: MonadReader Int m => m Polygon
22:43:50 <dwcook> I'm curious why you're doing that rather than Int -> Polygon
22:44:41 <no-n> which is considered better form? filter ((==x) . f) or filter (==x) . map f ?
22:45:25 <nooodl> those don't do the same thing
22:46:09 <startling> dwcook: heh
22:46:23 <startling> anyway I think the constructive geometry approach is probably nicer
22:46:41 <startling> i.e. data Shape = ... | Union Shape Shape | Intersection Shape Shape
22:46:45 <no-n> they don't? :I
22:46:45 <dwcook> startling, what's the "heh"?
22:46:52 <dwcook> nooodl, example?
22:47:13 <nooodl> > filter ((==3) . (+1)) [1,2,3]
22:47:14 <lambdabot>  [2]
22:47:22 <nooodl> > (filter (==3) . map (+1)) [1,2,3]
22:47:23 <lambdabot>  [3]
22:47:23 <startling> with the caveat that checking whether an intersection exists is O(n) for the number of nested shapes
22:47:29 <notdan> augur_: ugh ok I just noticed
22:47:37 <notdan> som eof the drunkishness in the article
22:47:46 <notdan> I have no idea how it got there though
22:47:50 <startling> no-n: I don't think it matters.
22:47:59 <no-n> brb
22:48:08 <harasskell> @pl \f g a b -> f (g a b)
22:48:08 <lambdabot> (.) . (.)
22:49:47 <nooodl> no-n: "filter (p . f) xs" gets you the list of "x" values for which "p" holds over "f x"
22:50:01 <startling> I should rephrase that -- approximating the area is O(n) for the depth of the tree.
22:50:12 <nooodl> no-n: "(filter p . map f) xs" calculates a list of "f x" values first then filters the ones for which "p" holds
22:50:40 <startling> nooodl: not really.
22:51:00 <startling> (lists are lazy)
22:51:12 <nooodl> okay yeah. that's a pretty handwavey explanation
22:51:15 <dwcook> startling, the example illustrates well what they're talking about
22:51:27 <dwcook> Oh, that's what you meant.
23:02:25 <no-n> nooodl: oh, of course
23:02:42 <augur_> notdan: i think we all know how it got in there, drunkdan
23:03:11 <notdan> :D
23:03:40 <harasskell> @pl \f g x y z -> f (g x y z)
23:03:40 <lambdabot> (.) . (.) . (.)
23:04:06 <augur_> whoever you are that mentioned implicit params, thank you again
23:04:09 <augur_> i think that was you haasn
23:04:46 <haasn> you're welcome :)
23:04:50 * ski . o O ( <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> )
23:05:11 <augur_> ski: you!
23:05:22 <augur_> implicit params are these things ive been telling you about in natural language!
23:05:31 <ski> they are ?
23:05:37 <augur_> ski: yes!
23:05:37 <harasskell> > .2
23:05:38 <lambdabot>  <hint>:1:1: parse error on input `.'
23:05:55 * ski can't recall any relevant conversation
23:06:05 <harasskell> @pl (.2) f g m n = f (g m n)
23:06:06 <lambdabot> (line 1, column 15):
23:06:06 <lambdabot> unexpected " "
23:06:06 <lambdabot> expecting operator
23:06:13 <ski> oh, perhaps you mean presuppositions
23:06:26 <augur_> ski: yes. assuming you can do fancier implicits than you actually can in haskell, you have
23:06:51 <thebnq> could implicit params be a considered slightly more explicit context
23:06:59 <harasskell> @pl (<||) f g a b = f (g a b)
23:06:59 <lambdabot> (line 1, column 16):
23:06:59 <lambdabot> unexpected " "
23:07:00 <lambdabot> expecting operator
23:07:09 <augur_> ski: the :: (?x :: Entity) => (pred :: Entity -> Constraint) -> (pred ?x) => Entity
23:07:20 <ski> harasskell : the `pl' parser is a bit dumb
23:07:30 <augur_> the pred = ?x
23:08:49 <harasskell> augur_ What is `the` in your type signature?
23:08:54 <augur_> ski: i mean, obviously you need some dependency as well, to make that work.
23:09:01 <augur_> harasskell: `the` is the word the!
23:09:10 <ski> determiner
23:09:16 <ski> "the pred = ?x" ?
23:09:30 <ski> however `pred ?x' doesn't ensure uniqueness
23:09:43 <augur_> ski: no, but the (?x :: Entity) => ... should
23:10:03 <augur_> i mean, if it doesnt, we could add something else in probably
23:10:06 <ski> surely that doesn't ensure there's at most one element of `Entity' satisfying `pred'
23:10:31 <augur_> the :: (?x :: Entity) => (pred :: Entity -> Constraint) -> (Unique pred ?x) => Entity
23:11:28 <ski> with `Unique p x' being defined as `forall y. x = y <-> p y', i suppose
23:11:29 <harasskell> augur_: Is that syntactically valid?
23:11:39 <ski> harasskell : not in Haskell
23:11:44 <L8D> @pl filter id
23:11:44 <lambdabot> filter id
23:12:06 <augur_> ski: p y -> x = y is fine
23:12:22 <augur_> since the other direction is a consequence of equality
23:12:22 <L8D> length . filter id . zipWith f [2..] . take 14 . repeat
23:12:27 <L8D> @pl length . filter id . zipWith f [2..] . take 14 . repeat
23:12:27 <lambdabot> length . filter id . zipWith f [2..] . take 14 . repeat
23:12:30 <augur_> harasskell: nope! :D
23:12:34 <augur_> we make it up as we go
23:13:01 <augur_> im convinced i should make my little semantic system type safe
23:13:13 <ski> augur_ : no, the `forall y. x = y -> p y' direction is the one ensuring `x' has property `p'
23:13:39 <augur_> ski: oh, well, i wouldve actually done
23:14:12 <augur_> Unique pred ?x = pred ?x /\ (forall y. p y -> x = y)
23:14:32 <augur_> but really i'd just make Unique primitive
23:14:43 <ski> but `forall y. x = y <-> p y' is much prettier :)
23:14:57 * ski likes adjunctiony expressions
23:15:05 <augur_> lol
23:15:16 <L8D> @pl flip (`showIntAtBase` intToDigit) ""
23:15:17 <lambdabot> flip (`showIntAtBase` intToDigit) []
23:15:49 <augur_> :t (?x,?y)
23:15:50 <lambdabot> (?x::t, ?y::t1) => (t, t1)
23:15:59 <harasskell> > let (..) f g a b =f(g a b) in (product .. enumFromTo) 10
23:16:00 <lambdabot>  <hint>:1:6: parse error on input `..'
23:16:15 <ski> (e.g. `forall y. x =< y <-> p y' expresses that `x' is the least element satisfying `p', under the presupposition that `p' is upper/monotone)
23:16:29 <augur_> :t   ((?x :: (?x :: a) => a), (?y :: (?y :: b) => b))
23:16:30 <lambdabot> (?x::t, ?y::t1) => (t, t1)
23:16:39 <augur_> interesting
23:16:53 <L8D> @pl flip (flip showIntAtBase intToDigit) ""
23:16:53 <lambdabot> flip (flip showIntAtBase intToDigit) []
23:17:01 <augur_> isnt that interesting, ski
23:17:21 <ski> harasskell : if there's nothing you'd like to show or ask about, with those queries, it's also possible to query lambdabot in private
23:17:30 <augur_> i wonder if there's anything with the type   ((?x :: a) => a, (?y :: b) => b)
23:17:41 <harasskell> @unpl \f g -> (f .) . g
23:17:41 <lambdabot> \ f g d i -> f (g d i)
23:18:02 <L8D> (flip . flip) showIntAtBase intToDigit []
23:18:05 <ski> augur_ : hm
23:18:06 <L8D> @pl (flip . flip) showIntAtBase intToDigit []
23:18:06 <lambdabot> showIntAtBase intToDigit []
23:18:29 <ski> @type (?x,?y) :: ((?x :: a) => a, (?y :: b) => b)
23:18:30 <lambdabot>     Illegal polymorphic or qualified type: (?x::a) => a
23:18:30 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
23:18:30 <lambdabot>     In an expression type signature: (?x :: a => a, ?y :: b => b)
23:18:41 <shachaf> harasskell: Please use /msg to communicate with lambdabot unless you're showing something to other people.
23:19:49 <ski> augur_ : yeah, works
23:19:54 <augur_> @djinn (?x :: a) => a
23:19:55 <lambdabot> Cannot parse command
23:19:58 <augur_> :(
23:20:07 <augur_> ski: oh does it? so i wonder then if the types are equivalent
23:20:14 <augur_> and how that interacts with type checking
23:20:57 <ski> augur_ : i don't think `((?x :: a) => a, (?y :: b) => b)' is equivalent with `(?x :: a, ?y :: b) => (a, b)'
23:21:36 <augur_> ski: suppose we have   p :: ((?x :: a) => a, (?y :: b) => b)
23:21:42 <augur_> then fst p :: (?x :: a) => a
23:22:16 <augur_> which should resolve to an a in a context with ?x :: a
23:22:20 <ski> certainly the former is convertible to the latter
23:22:28 <augur_> and vice versa too, i think
23:22:48 <augur_> :t   fst (p :: (?x :: a, ?y :: b) => (a,b))
23:22:49 <lambdabot>     Couldn't match expected type `(a, b)' with actual type `Expr'
23:22:49 <lambdabot>     In the first argument of `fst', namely
23:22:49 <lambdabot>       `(p :: (?x :: a, ?y :: b) => (a, b))'
23:23:06 <augur_> :t fst
23:23:07 <lambdabot> (a, b) -> a
23:23:13 <augur_> o_O
23:23:27 <ski> (or, at least it would seem possible to have such a conversion)
23:23:53 <augur_> ski: but crucially, when you observe either, you get the same thing, i think
23:24:07 <augur_> so observationally they're equivalent, but type-wise they're not i guess?
23:24:14 <augur_> but also you now have ambiguous syntax
23:24:18 <ski> in `(?x :: a, ?y :: b) => (a, b)', both parts of the pair may depend on both `?x' and `?y'
23:24:19 <haasn> augur_: p is undefined
23:24:22 <augur_> (?x,?y) could have either scoping
23:24:25 <ski> in `((?x :: a) => a, (?y :: b) => b)', not so
23:24:26 <haasn> or, rather, p :: Expr
23:24:37 <ski> for `(?x,?y)', i agree
23:24:39 <augur_> :t   fst (?p :: (?x :: a, ?y :: b) => (a,b))
23:24:40 <lambdabot>     Could not deduce (?p::(a1, b1))
23:24:40 <lambdabot>       arising from a use of implicit parameter `?p'
23:24:41 <lambdabot>     from the context (?x::a, ?y::b)
23:24:51 <augur_> blegh
23:25:05 <augur_> ski: true true
23:25:06 <haasn> > let p = (?x,?y) in fst (p :: (?x :: a, ?y :: b) => (a,b))
23:25:07 <lambdabot>  mueval-core: internal error: PAP object entered!
23:25:07 <lambdabot>      (GHC version 7.6.3 for x86_64_unknown_linux)
23:25:07 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
23:25:10 <haasn> Hah!
23:25:19 <ski> @type \p -> fst (p :: (?x :: a, ?y :: b) => (a,b))
23:25:20 <lambdabot>     Could not deduce (t ~ (a1, b1))
23:25:20 <lambdabot>     from the context (?x::a, ?y::b)
23:25:20 <lambdabot>       bound by the inferred type of it :: (?x::a, ?y::b) => t -> a
23:25:47 * hackagebot data-ordlist 0.4.6 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.6 (LeonSmith)
23:25:56 <haasn> ski: isn't that a rank-2 type?
23:26:30 <ski> i suppose
23:26:47 <augur_> @type \(p :: (?x :: a, ?y :: b) => (a,b)) -> fst p
23:26:48 <lambdabot> (?x::a, ?y::b) => ((?x::a, ?y::b) => (a, b)) -> a
23:28:21 <augur_> this is very interesting
23:28:57 <ski> implicit params are more or less dynamic scoping, which is more or less dependent variables, as used in e.g. analysis
23:29:18 <augur_> ski: indeed
23:29:25 <augur_> they're also of course instance args in agda
23:29:30 <ski> it's also connected to referential transparency
23:29:39 <augur_> uh oh, there's that phrase :)
23:29:44 <augur_> i hope you're using it correctly!
23:29:47 <L8D> @pl length . filter id
23:29:48 <lambdabot> length . filter id
23:29:54 <augur_> lol L8D
23:29:55 <L8D> :t length . filter id
23:29:57 <lambdabot> [Bool] -> Int
23:30:10 <L8D> augur_: I keep thinking there is a function for that kind of thing
23:30:22 <augur_> L8D: for what kind of thing?
23:30:29 <haasn> lengthOf (folded.only True)
23:30:34 <L8D> augur_: Counting the number of Trues in a list
23:30:48 <augur_> @hoogle [Bool] -> Int
23:30:49 <lambdabot> Prelude length :: [a] -> Int
23:30:49 <lambdabot> Data.List length :: [a] -> Int
23:30:49 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
23:30:58 <augur_> apparently there isnt!
23:31:43 <Cale> Was someone looking for me? This tab was highlighted, but I don't see the reason in my scrollback.
23:32:25 <shachaf> Perhaps 17:58 <Rotaerk_> Cale: lose interest, get distracted, run out of ideas, still thinking about it?
23:32:28 <augur_> hah. i was about to say "use the logs, Cale" in an obi-wan-esque sense
23:32:32 <augur_> and oubiwann just left
23:32:36 <augur_> what timing :)
23:32:46 <Axman6> heh
23:33:17 <ski> augur_ : i'm using it to apply to a context
23:33:38 <augur_> ski: :D
23:33:44 <augur_> ski: could you elaborate then on what you mean?
23:34:41 <ski> augur_ : more or less like in "Referential transparency, definiteness and unfoldability" by Harald Søndergaard,Peter Sestoft in 1990 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf>
23:35:10 <augur_> ski: ah, i never finished that paper
23:35:16 <augur_> ski: wait, i mean
23:35:22 <augur_> yes their sence of RefTrans is correct
23:35:31 <augur_> but do they talk about implicits?
23:35:39 <augur_> thats what i meant when i asked for elaboration
23:36:22 <augur_> ski: query Rel. Rel implicits reftrans
23:37:34 <ski> augur_ : sorry ?
23:37:56 <augur_> whats the intended relationship between implicits and referential transparency
23:43:29 <ski> augur_ : anyway, consider a context ⌜L : ((?x : α) ⇒ β) → ((?x : α) ⇒ γ)⌝ (really, ⌜L⌝ applied to a hole is a context)
23:43:47 <ski> augur_ : i call ⌜L⌝ ref. transp. iff ⌜∀ v : α. ∀ e : (?x : α) ⇒ β. (let ?x = v in L e) = (let ?x = v in L) (let ?x = v in e)⌝
23:43:55 <ski> augur_ : which can also be expressed as ⌜∀ v : α. ∀ e : (?x : α) ⇒ β. (let ?x = v in L e) = (let ?x = v in L (let ?x = v in e))⌝
23:44:06 <harasskell> @unpl fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
23:44:07 <lambdabot> (fix ((((<$>) <$> ((:))) <*> ((((\ l m -> m >>= l) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ f -> (\ d -> d) ((+) f) f)) 1))
23:44:30 <augur_> so the context is   L {! !}   where L has that type
23:44:38 <harasskell> > fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
23:44:39 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
23:44:42 <augur_> ski: ^
23:45:14 <augur_> let me parse what you say after that lots of stuff going on there
23:46:05 <ski> (augur_ : where you may think of ⌜let ?x = v in e⌝ as an alternative notation for the substitution ⌜e [?x ↦ v]⌝, if you like)
23:46:28 <ski> augur_ : yes
23:47:13 <augur_> ski: now see thats not what i would call referential transparency
23:47:16 <augur_> but it might be equivalent
23:47:36 <ski> this is an alternative notion, yes
23:47:41 <augur_> no no i mean
23:48:19 <augur_> i would say L {! !} is ref. transp. iff   forall e e' : (?x : a) => b. e = e' => L e = L e'
23:48:35 <ski> the point is that the context ⌜L⌝ is transparent in ⌜?x⌝ -- it refers to the same thing inside and outside the context
23:48:39 <augur_> thats usually how RT is stated
23:49:45 <augur_> ski: well, depends on what L is surely
23:49:47 <ski> augur_ : yes, that's a sort of total version. i'm only here talking about how it behaves wrt ⌜?x⌝. it might be RO wrt other identifiers
23:50:03 <augur_> L p = let ?x = x0 in p   ???
23:50:41 <augur_> L can have an implicit let in it, which destroys transparency
23:50:46 <ski> yes
23:50:48 <ski> exactly
23:51:02 <ski> and then my property doesn't hold
23:51:23 <augur_> this is actually a gorgeous example of how haskell isn't RT, and how its a property of contexts too
23:51:27 <augur_> without going into quotational issues
23:51:28 <augur_> :D
23:51:52 <ski> you mean `let x = blah = ...' contexts ?
23:52:28 <augur_> yeah, i suppose lets in general do that.
23:52:34 <ski> er, `let x = blah in ...'
23:52:36 <augur_> thats good, i can use that in the future
23:53:21 <augur_> binders in general create opacity
23:53:26 <ski> yes
23:53:38 <augur_> but i guess the typical places where RT is mentioned dont even have binders
23:54:00 <augur_> ahh this is a good thing to know. the only systematic opaque contexts in NL are attitude verbs
23:54:16 <augur_> so its good to have a systematic opaque context in haskell as a go-to example
23:55:38 <harasskell> @pl forever a = a >> forever a
23:55:38 <lambdabot> forever = fix (ap (>>))
23:55:41 <ski> however, it's easy to locally spot instances of the above opacity, by looking at whether the context surrounding the hole mentions binders for identifiers free in the expression to substitute
23:55:52 <augur_> boy you're quick on the draw, harasskell
23:56:06 <augur_> harasskell: why are you so interested in @pl?
23:56:25 <shachaf> harasskell: Did you see my message before? You should send lambdabot private messages for things like this.
23:56:31 <augur_> ski: sure, just like its easy to see if a context is opaque by looking for attitude verbs! :)
23:56:32 <ski> augur_ : anyway, my property above can be generalized from the environment monad to any monad
23:56:45 <augur_> ski: ?
