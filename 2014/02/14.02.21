00:00:07 <supki> yeah, it's pretty harmless
00:00:22 <supki> aeson uses far worse extensions itself ;)
00:08:41 * hackagebot HTTP 4000.2.11 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.11 (GaneshSittampalam)
00:08:41 * hackagebot network-api-support 0.0.8 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.8 (MarkHibberd)
00:16:02 <merijn> codygman: FlexibleInstances is probably one of the least controversial extensions ever :)
00:17:18 <codygman> supki, merijn: Thanks. I just want to be sure I'm not using something so complicated I can't debug it.
00:46:00 <haasn> FlexibleInstances on their own aren't too bad, as long as you don't go into OverlappingInstances-zone
00:47:03 <haasn> the worst that will happen to you an ambiguous type error if used incorrectly
00:51:52 <makalu> does putStrLn evaluate and store in memory the whole string it's passed or element by element?
00:52:24 <johnw> what elements are there?
00:52:41 <johnw> you mean the characters?
00:52:45 <makalu> yes
00:52:51 <johnw> i really have no idea
00:53:03 <johnw> i would expect it to do it element by element
00:53:54 <shachaf> That depends on the buffering behavior of the Handle.
00:58:10 <dv-> bah i can't get gtk or wx to work. some things never change
01:01:45 <haasn> hmm
01:02:16 <haasn> do hSetBuffering stdout $ BlockBuffering (Just 3); putStrLn $ "foobar" ++ undefined
01:02:30 <haasn> I would expect this to output "foo" followed by "bar" followed by an undefined exception, but it just throws the exception
01:03:37 <dv-> hPutStrLn?
01:03:51 <haasn> Looks like there's a minimum size on the buffer
01:03:58 <haasn> if I change "foobar" to something longer I get output
01:05:03 <haasn> 2048 is the minimum number of characters, apparently
01:06:18 <haasn> But if I change the length of the string to 3000 and the buffer size to 4096, I still get 2047 characters (why 2047? null terminator?) of output
01:07:21 <haasn> “An implementation is free to flush the buffer more frequently, but not less frequently, than specified above.”
01:07:43 <haasn> In other words: choosing a smaller buffer size than requested is always valid, but choosing a larger one never is?
01:16:48 <haasn> More importantly: Is this behavior a violation of the Haskell specification on GHC's part?
01:17:19 <navaati> hi
01:19:32 <navaati> if i write a function like f a b x y = a*x+b*y, and then i define g = f 1 (-1), can i expect the compiler to statically specialize g to be x-y ? I mean, at the C/assembly level ?
01:19:44 <pjdelport> does hSetBuffering actually control POSIX buffering, or buffering inside GHC?
01:21:53 <haasn> navaati: looks like it just updates the GHC Handles
01:22:28 <navaati> haasn: wrong guy, it's pjdelport:)
01:22:37 <haasn> err, pjdelport :)
01:22:52 <pjdelport> navaati: It probably depends on whether you specialize the type signatures from Num or not
01:23:29 <pjdelport> for g :: Num a => a -> a -> a, that optimization isn't *necessarily* valid
01:23:37 <navaati> pjdelport: let's suppose i specialize for, let's say, Double, would it do ?
01:23:58 <shachaf> If you strace a program that does hPutStr stderr "foo", you'll see three write() system calls, one per character.
01:24:17 <pjdelport> navaati: i'm not sure
01:24:18 <shachaf> There's no other easy way to get the behavior you'd want otherwise.
01:26:50 <haasn> hm, with buffer size 4096, outputting 10,000 characters turns into one write( call with 6141 characters and one with 2047
01:27:21 <haasn> that is actually not what I'd expected, I wonder what governs that behavior. It seems to merge multiple buffers together?
01:27:47 <pjdelport> haasn: ah, so it is a GHC-interal buffer
01:34:33 <pjdelport> haasn: there seems to be quite a bit to GHC's implementation, with chains of buffers
01:34:41 <pjdelport> so, probably something like that
02:02:38 <bennofs> Can I use a MVar from the parent process when I use forkProcess (from the unix package) ?
02:02:56 <ezyang> No, MVars do not IPC
02:03:24 <bennofs> ok, thanks.
02:03:42 <Axman6> that would be... quite fun to implement
02:04:03 <bennofs> This is wrong then? http://stackoverflow.com/questions/238379/how-would-one-share-data-between-a-parent-and-forked-child-process-in-haskell
02:04:09 <ezyang> It's basically Cloud Haskell
02:04:31 <johnw> the answers on that page are about threads, not processes
02:04:49 <bennofs> But the question says: "How would I even go about forking a child process using Haskell in the first place?
02:04:56 <johnw> yeah, i see that
02:05:01 <bennofs> Oh, I misread it.
02:05:04 <bennofs> Sorry
02:05:08 <Axman6> yeah those are not good answers...
02:06:32 <johnw> i'm surprised there isn't an IPCVar library somewhere, for doing same-host IPC ala MVar
02:07:39 <bennofs> Is there anything else I could use except unix pipes to do communication between child and parent on linux?
02:07:45 <Axman6> I think it would be a lot more difficult to implement, especially iwth the semantics of MVar (which works well because of the RTS's supervision of everything)
02:07:47 <johnw> this question has a better ansewr: http://stackoverflow.com/questions/9167867/is-there-some-standard-haskell-library-dealing-with-process-communication
02:07:53 <ezyang> johnw: It is difficult, because marshalling arbitrary data types is difficult
02:08:25 <Axman6> ezyang: should be a lot easier with a restriction on Storable then
02:08:54 <ezyang> Yes, but then that's basically some sort of pipes
02:09:02 <Axman6> right
02:09:20 <johnw> I'd prefer a restriction on Serialize
02:09:36 <bennofs> I guess using pipes works best for me.
02:09:45 <johnw> yeah, should be just fine
02:10:01 <Axman6> bennofs: yeah pipes and sending Serializable things will work fine
02:10:07 <bennofs> Axman6: I don
02:10:11 <ezyang> Remember this is Haskell, don't be afraid to build your own abstractions
02:10:30 <bennofs> Axman6: I don't even need Serializable, because all I'm passing is strings/bytestrings :)
02:11:00 <johnw> bennofs: then use process-conduit :)
02:11:19 <johnw> gives you a nice streaming interface for the communication
02:11:51 <johnw> and then if you do need Serialize, cereal-conduit makes shuffling data across a stream super easy
02:11:56 <johnw> (once you get the hang of it)
02:11:57 <bennofs> johnw: I'm not spawning an external process, so I cannot give a command
02:12:20 <johnw> those are Haskell libraries
02:12:52 <bennofs> I know, but process-conduit only works if I'm spawning an external process, it takes a file name.
02:13:02 <johnw> oh, I see what you mean
02:13:16 <johnw> think i'd use sourceHandle and sinkHandle, from Data.Conduit.Binary
02:13:36 <Axman6> bennofs: what's this process you're spawning anyway? why not use threads?
02:14:06 <bennofs> Axman6: I want to use the system's scheduler, not GHC's scheduler
02:14:51 <Axman6> why? o.O
02:14:55 <Axman6> GHC's is excellent
02:15:10 <bennofs> Axman6: but it's stop-the-world when GC occurs
02:15:25 <Axman6> don't make much garbage then :P
02:15:43 <bennofs> I tried that, didn't succeed :)
02:15:52 <Axman6> what're you making?
02:15:52 <Adeon> or make a lot of garbage that gets collected right away
02:15:59 <Axman6> that also
02:16:08 <ezyang> There are certainly good reasons to use separate processes, but GC pauses are not one of them.
02:16:11 <johnw> bennofs: did you try with -I0?
02:16:26 <bennofs> johnw: yes, didn't help.
02:16:38 <bennofs> I think GC pauses of ~0.3 seconds are pretty high?
02:16:45 <Axman6> yes...
02:16:57 <ezyang> (after all, the separated processes are still going to GC...)
02:16:57 <Axman6> I've never seen anything near that big
02:17:43 <bennofs> ezyang: yes, but I don't care if the parent process gc's. In the child process, I can try to avoid gc's because it does much less work.
02:17:54 <joelteon> run with +RTS -b
02:18:35 <bennofs> joelteon: what does that do=
02:18:48 <joelteon> bell every time GC runs
02:18:55 <bennofs> joelteon: That's -B.
02:18:59 <joelteon> my mistake
02:19:11 <Axman6> @hoogle traceShow
02:19:12 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
02:19:28 <bennofs> joelteon: Unfortunaly, my laptop doesn't seem to support the system bell (at least I don't hear anything)
02:19:38 <joelteon> damn
02:19:44 <ezyang> bennofs: OK, if you think your workload acts like that then process separation might be useful
02:19:54 <johnw> bennofs: have you use threadscope?
02:19:55 <ezyang> joelteon, bennofs: You can make the bell show up visually instead
02:21:01 <bennofs> johnw: Hmm. I have, does threadscope also have kind of a "live" mode? Or maybe I should just insert some custom events to see where in my program I am ...
02:22:23 <aleator> Hi, can anyone tell me why ghc nowadays prints out some error messages in the form "Could not deduce (a ~ [a])" instead of just the usual "Couldn't match expected type a with actual type [a]"?
02:23:55 <ezyang> Not useful answer: Probably SPJ and co rewrote the typechecker (again) and it emits the new messages
02:24:13 <ezyang> More useful answer: Might just be a usability thing, might be worth reporting.
02:24:34 <cinimod> Does anyone know where I get usage statistics on Haskell? E.g. how many downloads of ghc, how many downloads of the Haskell Platform, how many subscribers to #haskell, how many subscribers to haskell-cafe.
02:25:14 <bennofs> cinimod: there are currently 1185 people online on #haskell :)
02:25:28 <Adeon> more than I can count with my fingers
02:25:47 <bennofs> hmm or maybe that's not the current number, that was when I joined the channel
02:26:47 <cinimod> bennofs: how did you obtain that number?
02:26:55 <cinimod> just /names?
02:26:57 <bennofs> cinimod: my client displays it when joining
02:27:11 <utkarsh> Why isn't this code running in constant memory? https://gist.github.com/4a2705cf9c4f4f7b4223
02:27:22 <utkarsh> It calculates the frequency of every char in a file.
02:27:45 <ezyang> utkarsh: Use a strict map.
02:28:03 <Algebr> Why does Data.Map need to have orderable keys, hash tables shouldn't care about if the keys are orderable
02:28:15 <joelteon> it's not a hash table
02:28:16 <Axman6> Data.Map isn;t a hashtable
02:28:19 <joelteon> it's a btree
02:28:31 <joelteon> Data.HashMap is a hashtable
02:28:37 <Axman6> b-tree or binary tree?
02:29:04 <joelteon> self-balancing binary tree
02:29:16 <utkarsh> ezyang, worked, thanks
02:29:21 <Algebr> ah, thanks!
02:32:35 <Algebr> Apparently Data.HashTable is deprecated and I should I use hashtables package?
02:34:55 <Axman6> Algebr: you should use the unordered-containers package
02:34:58 <Peaker> Hey, looking at some parser libraries (parsec, attoparsec, trifecta), it seems only parsec supports a "transformer" mode.  I am wondering if there's a good way to implement "include" files that may affect parsing state?
02:35:16 <Peaker> (without being a transformer over IO)
02:35:42 <Algebr> Axman6, so are packages also used by regular imports? And imports are statements or expressions?
02:36:14 <Axman6> you import modules from packages with import... statements? I guess
02:38:02 <supki> I think the report calls them declarations
02:38:30 <Algebr> The reports are like the definitive specs on the language, right?
02:39:00 <supki> yes
02:39:21 <ezyang> Peaker: include like #include preprocessor directive?
02:39:31 <Peaker> ezyang, yeah
02:39:32 <Axman6> bah, why isn't (^) a part of the Num class. if you're defining something with a specialised square function, it makes sense to be able to use that
02:39:47 <Peaker> ezyang, I'm implementing a Makefile parser which does have such "include" directives
02:40:27 <ezyang> Ah, well, I have no idea how Make's syntax works
02:40:47 <ezyang> But if it was C-preprocessor directives, I would have told you to do a preprocessing step first and then parse.
02:41:35 <skuggi_> Axman6: maybe you could use a rewrite rule
02:41:54 <Axman6> yeah that's not a terrible idea
02:42:29 <skuggi_> Axman6: ^ even has rewrite rules for a few cases: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Real.html#^
02:42:41 <bennofs> @ty (^)
02:42:43 <lambdabot> (Integral b, Num a) => a -> b -> a
02:42:57 <Peaker> ezyang, doing a 2nd phase for the real parsing is often a possibility, but then the first phase has to be very liberal and potentially generate more unstructured data. Then the 2nd parsing phase is harder to maintain the positions in the original file
02:44:22 <ezyang> It is probably best to write the parser in nearly the same way the reference implementation does it
02:51:34 <Axman6> @src (^)
02:51:35 <lambdabot> x ^ 0            =  1
02:51:35 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
02:51:35 <lambdabot>   where f _ 0 y = y
02:51:35 <lambdabot>         f x n y = g x n
02:51:35 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
02:51:36 <lambdabot>                       | otherwise = f x (n-1) (x*y)
02:51:38 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
03:03:26 <bennofs> What flags do I need to use to get user events from ghc's eventlog?
03:04:15 <bennofs> i used traceEventIO, compiled with -rtsopts -threaded -eventlog, and ran with +RTS -lsgu
03:14:56 <bennofs> Ah, I need to use traceEventIO $ "START <someEventName>", not just traveEventIO "SOme message"
03:27:50 <Axman6> hmm, anyone know of Haskell has an ldexp function (lexpr(x,exp) = x * 2^exp, with x :: Double)
03:28:32 <Kinnison> Sounds easy enough to define if it doesn't
03:29:04 <Peaker> like a shift, for doubles?
03:29:21 <Axman6> sure, but math.h provides it for a reason
03:29:24 <Axman6> Peaker: exactly
03:29:45 <quicksilver> Axman6: http://hackage.haskell.org/package/cmath-0.3/docs/Foreign-C-Math-Double.html
03:30:06 <Axman6> so it should be just an integer add of exp << 51 to the double value as an int
03:30:24 <Axman6> quicksilver: thanks, shame it's not something provided by GHC
03:32:57 <bennofs> Hmm, I'm now using traceEventIO "START request" and traceEventIO "STOP request", but it still doesn't work. Any idea what I could be doing wrong?
03:34:23 <mceier> Axman6: lexpr x exp = scaleFloat exp x
03:34:23 <Axman6> quicksilver: looks like it'll need some patching before I can use it, it can't find unsafePerformIO
03:34:45 <Axman6> mceier: oh excellent, thanks!
03:36:10 <Algebr> So I while I can't rebind names to objects at the module level, I can do it in function scope?
03:37:46 <Axman6> @hoogle infinity
03:37:47 <lambdabot> package infinity
03:37:47 <lambdabot> System.Posix.Resource ResourceLimitInfinity :: ResourceLimit
03:38:15 <Axman6> > 1/0
03:38:17 <lambdabot>  Infinity
03:38:31 <Axman6> is that an appropriate value for an IEEE-754 infinity?
03:39:12 <navaati> can i expect f a b x y = a*x+b*y; g = f 1 (-1) to be optimized so that g = a-b (at the assembly/C level) ?
03:39:13 <no-n> I don't like that answer
03:39:42 <quicksilver> navaati: there is no C level.
03:39:50 <Axman6> Algebr: you want to use the name name twice?
03:39:55 <Axman6> same name*
03:39:58 <navaati> quicksilver: meh, C-- if you want
03:40:00 <quicksilver> navaati: but yes, that should probably work.
03:40:19 <Kinnison> navaati: more g = x - y
03:40:23 <Algebr> Axman, no just trying to get a handle on naming.
03:40:23 <navaati> really ? oh great
03:40:30 <navaati> (oh, uh, yep)
03:40:31 <Axman6> navaati: assuming ghci inlines f into g, I'd guess both LLVM and the NCG will optimise that correctly
03:40:42 <quicksilver> they might not unbox it entirely
03:40:51 <quicksilver> but it should certainly inline
03:40:55 <Kinnison> You can probably hint it to do so though
03:41:21 <navaati> quicksilver: if i specialize it to, say, Double, will it unbox ?
03:42:01 <Axman6> @hoogle infty
03:42:02 <lambdabot> No results found
03:42:03 <Twey> Axman6: Yes, that will be an IEEE +infinity
03:42:12 <Twey> > -1/0 -- this exists too
03:42:15 <lambdabot>  -Infinity
03:42:38 <Axman6> Twey: yeah, I'm just wondering if there's a better constant defined anywhere (the librtary I'm working off is using std::numeric_limits<double>::infinity();
03:42:57 <quicksilver> navaati: I don't think functions ever get unboxed per se.
03:43:08 <quicksilver> navaati: it might be unboxed at point of use, which is different.
03:43:16 <Twey> Axman6: Not AFAIK
03:43:16 <quicksilver> also, I might be wrong :)
03:43:32 <Axman6> quicksilver: it's also ptobably dependand on compiler version
03:43:35 <Axman6> t*
03:43:40 <Axman6> aefk.hadjkvh
03:45:43 <kalloc> Axman6: it's your password?
03:46:08 <Axman6> no, it's me maching the keyboard
03:46:13 <Axman6> mashing even
03:46:15 <Algebr> So if I do "import Something.Another" and if Another has a function called map, will map then overwrite the builtin map?
03:46:40 <Axman6> Algebr: no, the compiler won't know how to resolve the name map when used
03:47:08 <Kinnison> You'd either have to hide Prelude's map, or qualify the import of one or the other in some manner
03:47:56 <Algebr> So prelude is always imported for you even if not explicity asking for it? An alternative to always having to do #include <stdio.h> and friends?
03:48:24 <Kinnison> Prelude is always implicitly imported
03:48:28 <Axman6> you can turn that off with NoImplicitPrelude
03:48:29 <Kinnison> But you an override the implicit import
03:48:35 <no-n> are Data.Map.Maps ordered?
03:48:37 <Kinnison> as Axman6 says :-)
03:48:44 <Algebr> thanks all
03:48:55 <Axman6> no-n: sure
03:49:13 <no-n> ahhh
03:49:19 <Axman6> since it only has an Ord constraint, it makes sense for things to be stored in an ordered order
03:49:29 <no-n> in python i had to say from collections import OrderedDict
03:49:32 <Axman6> so you can use it to wort stuff if you like (like Data.Set)
03:49:34 <Peaker> can a .cabal file describe the build of a .so file from a .c file?
03:49:43 <Peaker> Or perhaps simply embed an arbitrary build command?
03:49:48 <ion> no-n: You and Axman6 seem to be talking about different kinds of “ordered”.
03:49:57 <Axman6> no-n: the Haskell equivalent of a python map would probably be Data.HashMap
03:50:15 <Axman6> oh, what did you mean by ordered then?
03:50:34 <Algebr> Axman6, are there significant performance differences between the Map and Hashtable?
03:50:36 <ion> no-n: Map is ordered by key, OrderedDict is ordered by insertion order IIRC.
03:50:50 <no-n> that fromList [(1,2)(3,4)] will always be just that and not fromList [(3,4),(1,2)]
03:51:22 <no-n> ahh
03:51:32 <no-n> then it's fine for this particular use-case
03:52:00 <Axman6> so OrderedDict is more like [(k,v)]?
03:52:36 <ion> Conceptually, yeah.
03:52:47 <no-n> but with unique keys
03:52:50 <ion> Except there aren’t unique keys.
03:52:57 <ion> uh. duplicate
03:53:45 <Axman6> yeah
03:55:42 <Axman6> hmmmm, if k = scaleFloat 16 1.0 and ik = 1/k, doesn't ik == scaleFloat (-16) 1.0?
03:56:15 <Axman6> yes apparently...
03:59:42 <Algebr> Having trouble understanding this: "map digitToInt . filter isDigit"
04:00:06 <Algebr> Is it like map(digitToInt(filter(isDigit(x))))
04:00:19 <Algebr> where x is a list
04:00:20 <srh> no
04:00:23 <Axman6> first it filters out only characters which are digits, then it turns each character into the Int represented by that character
04:00:27 <srh> it is like (map digitToInt) . (filter isDigit)
04:00:41 <srh> so it is like \x -> ((map digitToInt) . (filter isDigit)) x
04:00:54 <srh> so it is like \x -> (map digitToInt) ((filter isDigit) x)
04:00:57 <Axman6> Algebr: remember, arguments are passed to functions by juxtaposition (by sticking a space between them)
04:01:01 <srh> so it is like \x -> map digitToInt (filter isDigit x)
04:01:17 <Axman6> so f x y would be ()roughly) equivalent to f(x,y) in many other languages
04:01:44 <Algebr> srh, so which of the three is the correct one?
04:01:52 <Axman6> Algebr: do you understand function composition using (.)
04:02:04 <Axman6> so: they're all the same really
04:02:09 <Algebr> yea, I think so. f . g is like f(g(x))
04:02:12 <Axman6> -so:
04:02:17 <Axman6> right
04:02:36 <Axman6> so replace f with (map digitToInt) and g with (filter isDigit) and there uou have it
04:02:47 <Algebr> ah!, awesome.
04:03:05 <mmmm> . is just a function which is defined to do that Algebr
04:07:04 <Axman6> So I'm using a trick I learned ages ago but never had a good use for until now. The use of Identity to emulate mutation of variables when translating from some imperative code. Makes the translation much more mechanical
04:07:33 <lieven_> Axman6: how does that work?
04:07:53 <exicer_> How can I turn IO (Either a b) into EitherT a IO b ?
04:08:07 <bennofs> exicer_: use the EitherT constructor
04:08:13 <Axman6> do { r <- return foo; r <- return $ r + 28; return r }
04:08:23 <Axman6> :t EitherT
04:08:28 <lambdabot> Not in scope: data constructor `EitherT'
04:08:36 <Axman6> bah
04:08:41 <Axman6> @hoogle EitherT
04:08:42 <lambdabot> package EitherT
04:08:48 <Axman6> >_<
04:09:05 <lieven_> Axman6: nice.
04:09:29 <Axman6> lieven_: this code redefines the same variables many times, which is making life quite hard
04:10:41 <bennofs> Axman6: the newer package is either
04:10:50 <lieven_> it's a nice way to stop you from having to do let r=...; r'=....; r''=... and keeping track of all the differences
04:11:24 <Axman6> lieven_: yeah, that's what I had. when I got to things called q0''', p0''' I decided to stop the nonsense ;)
04:13:00 <Algebr> Wow! The where clause can also introduce function definitions??
04:13:12 <Axman6> yep
04:13:52 <lieven_> in some sense haskell as only functions. values are functions that don't take any parameters :)
04:13:57 <lieven_> *has
04:14:04 <Axman6> it's also quite useful for pulling apart values: foo where (QD a0 a1 a2 a3) = a gives you access to the four variables inside a
04:14:17 <Algebr> lieven_, I've been repeated told here that that wasn't the case
04:14:30 <lieven_> then I'm wrong
04:15:31 <Axman6> it's not a terrible way to look at it when understanding why where clauses can do so much though (i'm sure there are others who'd disagree with me though)
04:16:00 <Algebr> So do people prefer let or where?
04:16:03 <Algebr> usually
04:16:46 <Axman6> depends on the situation. the code I'm writing at the moment uses both for quite similar things
04:17:13 <Twey> Algebr: When given the choice I usually prefer ‘where’
04:17:17 <bennofs> Does threadscope have a function "jump to next user event" ?
04:17:25 <Axman6> I often like writing functions as foo x y = z where\na = g x y; z = a^3
04:17:31 <Peaker> Axman6, prefer where, use "let" only in "do" when it depends on previous binds
04:17:32 <Twey> It lets you write/read the code ‘top-down’, writing the general structure of the function then filling in the details in a where
04:17:44 <navaati> is there a way to know the list of fusions operated by the vector package ? like, i want to know if a scan after a scan will fusion, for example
04:17:55 <Axman6> Peaker: I'm sure that was directed at Algebr, but I tend to agree =)
04:18:02 <Peaker> oops
04:19:10 <Twey> lieven_: Your wrongness is to do with the definition of ‘function’.  In strict languages like Python or Scheme, a ‘function’ is often used to delay execution, and in that sense all Haskell values are ‘functions’.  But that's not really a useful distinction to make in a lazy language, so we use ‘function’ in its mathematical sense of a value that depends on a value to be passed in
04:19:37 <Twey> lieven_: So things that don't take arguments are trivially not functions
04:20:19 <Axman6> the fact that we can have things in haskell that don't look like functions which are can be confusing though
04:20:27 <navaati> it's actually the other way around : everything is a value
04:20:53 <navaati> but certain values can be applied to other values
04:20:54 <Axman6> constructors being one I guess, the other being things which contain functions but whose type doesn't suggect they do (like DList)
04:21:07 <Algebr> So the value of an unexectued function is...undetermined?
04:21:10 <Axman6> I'm not sure I agree with that navaati
04:21:22 <Axman6> Algebr: functions have no value
04:21:31 <Peaker> Axman6, functions are values
04:21:35 <Axman6> heh, that was more deep that I expected it to be
04:23:55 <mangaba_leitosa> also, there are things that look like functions, but are not. Such as getLine :-0
04:24:37 <skypers_> hi
04:24:43 <skypers_> I have a situation with WriterT
04:24:56 <Axman6> getLine doesn't look like a function to me, it takes no arguments
04:25:04 <skypers_> I have a WriterT over IO, and a WriterT over Maybe
04:25:22 <skypers_> I think Control.Monad.Trans.Writer lacks a function to absorb monoids
04:25:25 <skypers_> something like
04:25:38 <mangaba_leitosa> well, let's say things that are usually expected to be functions in other languages
04:25:38 <skypers_> (a,w) -> m a
04:26:09 <navaati> Axman6: well, right, it's a value
04:26:12 <skypers_> @hoogle (MonadWriter m) => (a,w) -> m a
04:26:13 <lambdabot> Did you mean: MonadWriter m a => (a, w) -> m a
04:26:13 <lambdabot> Control.Monad.Writer.Class writer :: MonadWriter w m => (a, w) -> m a
04:26:13 <lambdabot> Control.Monad.Writer.Lazy writer :: MonadWriter w m => (a, w) -> m a
04:26:29 <skypers_> ok it sounds to be writer then
04:27:51 <no-n> so the main attraction with Data.hashMap is speed?
04:28:05 <Axman6> yes
04:28:11 <Axman6> and memory usage for large maps
04:28:17 <Algebr> b-trees are faster than hashtables?
04:28:18 <no-n> *nod*
04:28:31 <Maior> :t getLine
04:28:33 <lambdabot> IO String
04:29:50 <Axman6> Algebr: well, HashMap is a hash array mapped trie (HAMT), somewhat simular to a B-tree (which is not a binary tree by the way)
04:32:53 <zebr> hi all. would you say that spj's 'the implementation of functional programming languages' is still a good text to use to learn about how e.g. haskell is implemented? it's pretty old, and talks about miranda, but so long as not that much has changed since, it ought to be ok, don't you think?
04:33:36 <zebr> (if there's been a better book since, please let me know :p)
04:35:10 <Algebr> does a module's name have to be the same as its file name?
04:35:53 <skypers_> yes, Algebr
04:39:38 <navaati> isn't there some kind of scan function in repa ? something like "postscanl :: (a -> b -> a) -> a -> Vector b -> Vector a" in vector ?
04:43:31 <alpounet> zebr: yes, it has a lot of interesting material in it, and globally the research papers revolving around GHC and the GHC Commentary have all the great references to understand how GHC implements something
04:44:12 <zebr> alpounet: great, thanks :)
04:44:14 <merijn> zebr: Well, much has changed, but most of the changes are incremental
04:44:31 <merijn> zebr: So you still need to know most of that to understand what's changed anyway
04:44:43 <merijn> zebr: So as an intro it's still good
04:44:50 <zebr> yeah, i'm mostly worried that i'll learn to do something a certain way, and it'll turn out that the whole approach is completely outdated.
04:44:59 <zebr> but that probably won't happen, you think?
04:45:05 <merijn> zebr: See also Types and Programming Languages for in-depth explanation of how to implement type systems
04:45:29 <alpounet> zebr: it won't be implemented in the complete opposite way, although many things have evolved or been refined
04:45:49 * zebr nods
04:45:56 <merijn> Exactly
04:47:11 <zebr> PS. it would be fantastic if someone were to write a kind of sequel with the newer stuff in :p
04:47:59 <merijn> zebr: A sequel will probably be written at some point
04:48:18 <merijn> zebr: Books are sort of "major checkpoints" with papers improving on them, until a new book is written
04:48:46 <merijn> So I'd view the book as a starting point for being able to read the research papers, until a new books is written which incorporates all the papers since the last book
04:49:26 <zebr> merijn: yeah, that makes sense.
04:51:45 <alpounet> Yeah, you do have a lot of material in the code itself and the GHC commentary though, in addition to the publications
04:55:57 <Fuco> is there a function [a] -> a -> [[a]] that would "split" a list into sublists at an element, but leave this out? e.g: foo "a,b,c" ',' => ["a","b","c"]
04:56:16 <merijn> @hoogle Eq a => a -> [a] -> [[a]]
04:56:17 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
04:56:18 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
04:56:18 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
04:56:21 <merijn> hmm
04:56:29 <merijn> @hoogle (a -> Bool) -> [a] -> [[a]]
04:56:30 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
04:56:30 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
04:56:30 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
04:56:42 <Fuco> it's also commonly called "split-string", but I want it for lists (in haskell that doesn't matter though)
04:56:48 <merijn> Fuco: I was sure there was one, check Data.List
04:56:56 <Fuco> yea i'm looking
04:57:15 <Fuco> well it's like generalized 'words'
04:57:31 <merijn> Fuco: Or the Data.List.Split module in the split package
04:57:35 <no-n> how do you pattern match for a Data.Map.Map? can you get the first item and the rest of the map?
04:57:43 <merijn> no-n: You don't
04:57:49 <no-n> ok
04:57:53 <merijn> no-n: The constructors aren't exported (for a reason)
04:58:02 <merijn> no-n: Otherwise you could construct invalid maps
04:58:20 <Fuco> merijn: oh ys, it's called 'splitOn' there. Thanks, I wasn't aware of that package
04:58:22 <no-n> agh, of course
04:58:38 <no-n> ahh*
04:58:47 <krgn> hellau! I wonder if anyone has a quick hint: I have a "cabal sandbox" with some deps but sadly ghc-mod doesn't seems to pick them up. any ideas what could be wrong?
05:09:00 * hackagebot http-test 0.1.1 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.1 (glutamate)
05:11:15 <osa1> what is c type variable in gfoldl type? (from Data.Data)
05:11:57 <Axman6> @type gfoldl
05:11:59 <lambdabot> Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
05:12:32 <bennofs> I remember that I once understood this type, but I forgot :(
05:12:59 <Axman6> yeah that's not exactly an easy type to understand
05:13:15 <osa1>  (forall g. g -> c g) I don't understand this part also
05:13:26 <osa1> to me it looked it it should have been (g -> c a)
05:13:30 * Axman6 pokes edwardk and quicksilver as people who could more than likely answer the question
05:16:00 <merijn> osa1: No, those are not the same
05:16:11 <merijn> osa1: "forall g .  g -> c g" is a Rank2Type
05:16:18 <osa1> merijn: do you have any examples uses of gfoldl?
05:16:33 <osa1> merijn: I know, I'm just saying that that type does not make sense to me
05:16:34 <merijn> osa1: The difference is *who* gets to pick what the value of 'g' is
05:16:49 <merijn> osa1: I'm not familiar with gfoldl, so I can't explain it
05:17:04 <merijn> I can explain the Rank2Type
05:19:14 <osa1> I'm trying to count nodes in an AST type, am I on wrong track?
05:19:47 <kusut> krgn: I experience the same thing
05:20:25 <krgn> kusut: I think its becuase the plugin for vim I use (neco-ghc) does not include the local sandbox dir
05:20:41 <krgn> kusut: if thats what you're using, as well
05:20:54 <kusut> krgn: ugh I use emacs :(
05:21:10 <alpounet> the 'scrap your boilerplate' covers gfoldl, doesn't it?
05:21:14 <merijn> kusut: I'm not sure whether ghcmod supports sandboxes atm
05:21:22 <osa1> syb library has that, yeah
05:21:26 <krgn> kusut: ah its likely a similar thing where it needs to pass some option to ghc
05:22:01 <krgn> I think it does support it generally (just testing straight from the terminal)
05:22:08 <osa1> I don't understand how can this type work forall d b. Data d => c (d -> b) -> d -> c b ... I'm getting "Not in scope: type variable `c'"
05:22:11 <kusut> merijn: iirc I read somewhere that it supports it
05:22:49 <bennofs> @let import Data.Data
05:22:52 <lambdabot>  Defined.
05:24:57 <bennofs> > getConst $ gfoldl (\(Const x) _ -> Const $ x + 1) (\_ -> Const 0) $ Just 4 -- Counts the number of arguments the data constructor takes
05:24:59 <lambdabot>  1
05:25:33 <merijn> osa1: If you have an explicit forall, then *all* type variables must be explicitly introduced by a forall
05:25:40 <bennofs> osa1: so what do you want to count?
05:25:41 <merijn> osa1: Right now you only mention d and b and not c
05:26:06 <skypers_> http://devskypers.blogspot.fr/2014/02/logging-flow-activity.html
05:26:11 <skypers_> tell me what do you think ^
05:26:22 <osa1> bennofs: constructors in a sum type
05:26:32 <osa1> constructors in any sum type, let's say
05:26:35 <bennofs> osa1: you don't need Data.Data for that
05:26:43 <osa1> bennofs: what do I need for that?
05:27:15 <bennofs> osa1: wait, what do you mean by constructors? What should countConstructors $ Left ()     give ?
05:27:16 <merijn> osa1: Probably Generic would be a good approach for that?
05:27:46 <osa1> let me check Generic
05:28:04 <osa1> where is Generic?
05:28:09 <bennofs> ah no, you really need Data.Data :|
05:28:16 <osa1> bennofs: yeah
05:28:39 <utkarsh> Is there any simple example of using trifecta to parse an indented language?
05:28:40 <utkarsh> Apparently there was something for that in earlier versions of trifecta: http://ircbrowse.net/browse/haskell?id=12481063&timestamp=1321133845#t1321133845 but I don't see anything like that in the current version of either trifecta or the `parsers` package.
05:28:54 <osa1> utkarsh: Idris
05:29:18 <osa1> utkarsh: Idris parser is written using Trifecta and it's syntax is indentation sensitive.
05:30:20 <osa1> I was expecting this to be super easy using Data.Data but that gfoldl type ....
05:31:15 <osa1> utkarsh: Trifecta does not have indentation sensitive parsing combinators, you gotta roll your own functions for that. (like in Idris)
05:33:42 <alpounet> osa1: do you need the full power of folding over your value's constructor? what's your use case?
05:34:02 * hackagebot bytes 0.14 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14 (EdwardKmett)
05:34:02 <alpounet> constructors*
05:34:29 <haasn> > lengthOf each $ Just 4
05:34:33 <lambdabot>  1
05:34:35 <haasn> > lengthOf each $ Nothing
05:34:37 <lambdabot>  0
05:36:28 <syllogismos_> line 170 http://lpaste.net/7689956269938966528
05:37:25 <syllogismos_> it is always returning Empty, so the if statement is always returning false
05:37:42 <osa1> alpounet: I just have a huge AST and I want to count AST nodes
05:38:54 <merijn> syllogismos_: That's not a question
05:39:41 <osa1> alpounet: any ideas on how to do this easily?
05:40:00 <syllogismos_> so for a list [1,1,2] it should be Full 1, instead of Empty, Empty is Nothing and Full is Just here
05:40:22 <syllogismos_> so what i wrote is obviously wrong..
05:40:48 <osa1> maybe I can use show to generate String of my AST and then count capital first letters of words :P
05:40:59 <Axman6> ReinH: you understand that the then return (Full x) line does nothing right?
05:41:09 <Axman6> return is not like return in C or Java
05:41:15 <alpounet> osa1: yeah, that's worth a PhD thesis, and you could find a cool name
05:41:27 <Axman6> hmm, actually maybe it is working right there....
05:41:41 <Axman6> bleh, sorry ReinH, meant syllogismos_
05:41:50 <merijn> syllogismos_: Your current layout is confusing and makes it hard to see what the code is doing
05:41:55 <Axman6> syllogismos_: why not use do notation btw?
05:42:06 <alpounet> osa1: let me read up a bit
05:42:11 <osa1> alpounet: you serious?
05:42:23 <osa1> gfoldl should provide some ways to do that
05:42:25 <alpounet> no i wasn't sorry if it wasn't obvious :p
05:42:37 <alpounet> it does, we just have to figure out the right invokation
05:42:42 <osa1> yeah
05:42:47 <merijn> syllogismos_: The problem you have is the following
05:42:55 <syllogismos_> i dont have do notation available for me.. they want me to implement all typeclasses from groud up.. its a introductory haskell thing
05:43:02 <merijn> syllogismos_: You recurse using "addElement x >>= \_ -> return (firstRepeat xs)"
05:43:15 <bennofs> osa1: can you give an example ast (small) and the expected result?
05:43:19 <merijn> syllogismos_: The base case of "firstRepeat xs" is Empty
05:43:31 <merijn> syllogismos_: i.e. once you reach the end of the list it will return Empty
05:43:34 <bennofs> osa1: Maybe just using Either/(,) ?
05:43:40 <osa1> bennofs: can't share my code but I can provide you an example
05:43:43 <Axman6> syllogismos_: if you have Monad defined, then you can use do notation
05:43:44 <osa1> okay
05:44:05 <merijn> syllogismos_: Actually, I'm not even sure anymore, this code is really confusing :\
05:44:12 <osa1> bennofs: countConstrs (Just (Just (Just (Just Nothing)))) = 5
05:44:22 <syllogismos_> i know sorry. all of the types are custom..
05:44:29 <syllogismos_> even list, maybe etc
05:44:31 <Axman6> ah
05:44:35 <merijn> syllogismos_: It's not the custom types that are confusing
05:44:40 <osa1> countConstrs [1, 2, 3] = 4
05:44:51 <osa1> bennofs: ^
05:44:53 <merijn> syllogismos_: It's the mix of runState with monadic operations inside the if that's confusing
05:45:42 <merijn> syllogismos_: If you use your custom state, I would put that into a separate where clause using do notation
05:45:45 <bennofs> @let countNodes :: Data d => d -> Int; countNodes n = getConst $ gfoldl (\(Const x) d -> Const $ x + countNodes d) (\_ -> Const 1) n
05:45:47 <lambdabot>  Defined.
05:45:56 <bennofs> > countNodes $ Just $ Just $ Just Nothing
05:45:58 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:45:58 <lambdabot>    arising from a use of `L.countNodes'
05:45:58 <lambdabot>  The type variable `a0' is ambiguous
05:45:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
05:45:58 <lambdabot>  Note: there are several potential instances:
05:46:02 <bennofs> > countNodes $ Just $ Just $ Just ()
05:46:02 <osa1> bennofs: I'm away for 5 mins
05:46:04 <lambdabot>  4
05:46:15 <Axman6> merijn: can you use do notation with NoImplicitPrelude?
05:46:17 <bennofs> > countNodes [1,2,3]
05:46:20 <lambdabot>  mueval-core: Time limit exceeded
05:46:26 <osa1> what
05:46:32 <syllogismos_> yeah sorry.. i myself am new to state monad.. so i just make sure types are compatible in the end
05:46:37 <osa1> wow
05:46:48 <Axman6> syllogismos_: where'd you get this course from btw? is it dibblego's? (tony morris)
05:47:16 <syllogismos_> https://github.com/NICTA/course/blob/master/src/Course/State.hs
05:47:24 <osa1> what module has getCons?
05:47:27 <merijn> Axman6: I think so?
05:47:33 <bennofs> osa1: Control.Applicative
05:47:46 <Axman6> yeah, that's Tony's. did you do his course recently or did you just find the code?
05:48:07 <merijn> syllogismos_: This would already be easier to read: http://lpaste.net/5181522376382218240
05:48:18 <bennofs> osa1: countNodes [1,2,3] == 7 though (because each application of (:) counts as a new node)
05:48:23 <syllogismos_> some one on here suggested that i do this after luah
05:48:25 <alpounet> > countNodes $ Just $ Just $ Just (Nothing :: Maybe Int)
05:48:29 <lambdabot>  mueval-core: Time limit exceeded
05:48:35 <merijn> syllogismos_: And now it's really obvious to see why it fails
05:48:36 <syllogismos_> i didn't do any of his courses..
05:48:48 <Axman6> ah right
05:48:50 <merijn> syllogismos_: You use "get" to inspect the Set of values, right?
05:49:03 <syllogismos_> yes..
05:49:19 <bennofs> > countNodes (1, 2)
05:49:23 <lambdabot>  3
05:49:25 <Axman6> oh, I think I see it!
05:49:26 <merijn> syllogismos_: Oh, wait addElement does a "put", so it works
05:49:58 <Axman6> you're calling firstRepeat recursively, but in an odd way which means the state isn't theaded through
05:50:03 <merijn> I think your base case is wrong, but I have to decipher how you get it
05:50:06 <bennofs> > countNodes 1
05:50:10 <lambdabot>  1
05:50:13 <merijn> oh!
05:50:18 <merijn> Axman6: Good catch
05:50:27 <osa1> bennofs: this is like magic, I should study this code
05:50:27 <merijn> Axman6: Wow, that's really subtle
05:50:31 <Axman6> syllogismos_: you need to factor the State computation out, and then have it call itself
05:50:32 <osa1> bennofs: thank you very much, btw
05:50:40 <Axman6> merijn: yeah, sure is!
05:50:50 <osa1> bennofs: (I didn't try the code on my AST yet but hopefully it'll work)
05:50:59 <merijn> Or rather, not subtle, but very non-obvious with the way it's written :)
05:51:36 <Axman6> syllogismos_: firstRepeat xs = fst $ runState (foo xs) S.empty where foo Nil = return Empty; foo (x :. xs) = ...
05:51:46 <Axman6> and ... needs to call foo at the end
05:51:49 <bennofs> osa1: Well, it might return some weird results, because if you use lists, countNodes [1,2,3] = countNodes (1 : (2 : (3 : []))) = 7
05:53:33 <merijn> syllogismos_: Your problem is that you do all this effort to pass the state, but since "firstRepeat" is not in the State monad, your recursive call starts again with a fresh state of S.empty
05:53:52 <bennofs> countNodes (1 : (2 : (3 : []))) = 1 + countNodes 1 + countNodes (2 : (3 : [])) = 1 + 1 + (1 + countNodes 2 + countNodes (3 : []) = 4 + countNodes (3 : []) = 4 + (1 + countNodes 3 + countNodes []) = 4 + 3 = 7
05:54:04 <bennofs> osa1: ^^ That's how the result is calculated
05:54:42 <bennofs> Each constructor counts 1
05:54:51 <bennofs> + the value of all the sub-values
05:55:16 <syllogismos_> ohhhhhhh
05:55:41 <edwardk> utkarsh: there was a bug in the old version's indentation parsing. we fixed the bug in the scala version of the trifecta combinators to ship Ermine, but never backported it. Rather than dal with al the bug reports I was getting about it, I ripped it out until it could be done correctly... and promptly forgot about it
06:02:17 <krgn> :w
06:04:56 <bennofs> Using ghc-events-analyze, I get "ghc-events-analyze: _shutdown not set". Does anyone now how to solve this issue?
06:05:35 <dabd> just finished reading lyah. I hardly coded anything while reading it (the book has almost no exercises). What do you recommend as a next step?
06:06:13 <Maior> dabd: Real World Haskell
06:06:37 <dabd> i was thinking about reading that next but isn't it slightly outdated?
06:07:51 <Axman6> it's only a few years old. most of the topics are still relevant (and people will tell you when you use something that's been replaced by something bigger and better)
06:07:53 <Maior> dabd: shrug
06:08:23 <Maior> dabd: I found it useful for "actual usage"; even if the libraries/tools have moved on, it's a good transition from "hey here's this theory" to "I built a Thing"
06:08:38 <syllogismos_> awesome.. it worked Axman6
06:08:50 <Axman6> syllogismos_: glad to hear =)
06:09:04 <dabd> ok i also bought a recent book "beginning haskell a project based approach" but some people say the author is not very well known
06:09:09 * hackagebot haskell-names 0.3.2.5 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.3.2.5 (RomanCheplyaka)
06:09:11 * hackagebot haskell-packages 0.2.3.4 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.3.4 (RomanCheplyaka)
06:09:28 <c_wraith> dabd: personally, I'd recommend just writing some code.  Write small programs that do things.
06:09:50 <dabd> ok and what about following this course: http://www.cis.upenn.edu/~cis194/lectures.html
06:10:04 <Sornaensis> I've been using haskell to do CS homework
06:10:23 <bergmark_> Feuerbach: ah 7.8 nice :-) i was going to ask you what to do about type-eq
06:10:26 <c_wraith> dabd: the list of topics looks good - who's the instructor?
06:10:36 <dabd> brent yorgey
06:10:48 <syllogismos_> dabd exercism.io is also good.. it helped me..
06:10:50 <dabd> author of the diagrams library
06:10:50 <c_wraith> ah.  should be very good, then
06:10:58 <c_wraith> dabd: he's also a regular in here
06:11:23 <dabd> i'm a bit overwhelmed about the amount of learning material for haskell
06:11:55 <bergmark_> dabd: that must be a good thing :-)
06:12:17 <merijn> dabd: Haskell has a high skill ceiling, you can always keep learning more advanced things
06:12:20 <thebnq> its makes sense since you generally get more in less code :D
06:13:10 <merijn> dabd: Also, Real World Haskell (skip the first few chapters, they just repeat LYAH) has some good overviews of interesting libraries, like Parsec
06:13:23 <merijn> dabd: You can also try "Write Yourself a Scheme in 48 Hours"
06:13:30 <syllogismos_> merijn its an understatement.. i feel so dumb sometimes.. it takes me lot of time to understand seemingly basic things.. every new monad is an adventure to me
06:13:45 <bergmark_> i don't think write a scheme is suited for beginners
06:13:55 <merijn> bergmark_: Well, he finished LYAH already
06:13:58 <bergmark_> oh
06:14:25 <merijn> bergmark_: It seems a good place to start for actually writing code that feels non-trivial
06:15:04 <bergmark> i read YAHT and then started on that and got stuck because you had to finish the exercises before continuing
06:15:06 <merijn> syllogismos_: It helps to keep things as (syntactically) simple as possible, i.e. compare your version vs my update. Same code, but much clearer. I advice liberal use of where-clauses to simplify your code
06:16:12 <syllogismos_> I want do notation.. can i make my monad typeclass to work with do?
06:16:33 <merijn> syllogismos_: do notation is syntactic sugar, it gets converted into >>= and >>
06:16:45 <merijn> syllogismos_: So if you have a monad instance it already automatically supports do-notation
06:17:15 <merijn> @undo do { x <- foo; let y = bar x; baz x; return y }
06:17:15 <lambdabot> <unknown>.hs: 1: 36:Parse error: ;
06:17:25 <syllogismos_> I know that.. but in this particular course.. I dont have monad typeclass from prelude or what ever.. i have my own monad typeclass
06:17:31 <merijn> @undo do { x <- foo; let y = bar x; baz x; return y; }
06:17:31 <lambdabot> <unknown>.hs: 1: 36:Parse error: ;
06:17:33 <merijn> hmmm
06:17:37 <merijn> I suck, apparently
06:17:46 <merijn> syllogismos_: Ah, that's a bummer
06:17:53 <thebnq> i think the let gets stuck in the {}
06:17:56 <geekosaur> let needs braces
06:18:03 <bergmark> syllogismos_: you can use RebindableSyntax, then you don't need a base Monad instance
06:18:22 <syllogismos_> yeah.. when i want to cheat i look for source codes in hackage and most of them are implemented with do notation.. and
06:18:34 <bennofs> osa1: I just found out that there is an alternative, much easier definition: let countNodes :: Data d => d -> Int; countNodes = gmapQl (+) 1 countNodes
06:18:45 <bergmark> let MyMonad (>>=) (>>) return = m in do ...
06:19:46 <bergmark> or let MyMonad{..} = m in do ... if you add RecordWildCards
06:20:12 <bennofs> > countNodes [1,2,3,4] -- It also seems to be more performant
06:20:13 <lambdabot>  9
06:20:21 <syllogismos_> where do i put it bergmark
06:20:48 <bergmark> syllogismos_: here's an example https://github.com/faylang/fay/blob/master/examples/Cont.hs
06:20:52 <syllogismos_> like in my MyMonad.hs?
06:24:57 <osa1> bennofs: awesome!
06:39:12 * hackagebot classy-prelude 0.8.0.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.8.0.1 (MichaelSnoyman)
06:39:14 * hackagebot mime-mail-ses 0.2.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.2 (MichaelSnoyman)
06:40:56 <eternauta> hi! i'm make a class container, and i've and error that i'm understand but i don't know how to fix that... http://lpaste.net/100239
06:45:40 <c_wraith> eternauta: The standard ways of dealing with that are either associated types or a multivariable type class with functional dependencies
06:46:48 <c_wraith> eternauta: more or less, you need to add sufficient information that you can express the Ord dependency.
06:46:51 <eternauta> mmm can you give me and example or any link?
06:47:18 <eternauta> sorry, but i'm new in haskell and in functional programming
06:47:21 <alpounet> eternauta: the thing is, you're using (<=) there, in your instance
06:47:33 <eternauta> yes, i'm understand that
06:47:33 <alpounet> but <= belongs to the Ord typeclass
06:47:53 <merijn> I don't think fundeps/type families are really helpful things for a beginner :)
06:48:07 <alpounet> but you haven't specified anywhere that you were using things from Ord
06:48:09 <c_wraith> They're not the most helpful things for a beginner, no
06:48:12 <eternauta> but i need that by the university
06:48:13 <eternauta> =)
06:48:20 <k00mi> eternauta: can you change the definition of Container?
06:48:24 <merijn> eternauta: The short answer is, you can do this, but it is non-trivial and perhaps not the best thing to attempt as a beginner
06:48:25 <eternauta> yes
06:48:41 <c_wraith> alpounet: There's no place to add the Ord constraint with that definition of Container.
06:48:51 <eternauta> i can change the definition of Container
06:48:54 <alpounet> c_wraith: I know, i'm just explaining why GHC complains.
06:49:10 <c_wraith> alpounet: that's what the whole question was.  "I understand why I'm getting this error, but I don't see how to fix it"
06:49:11 <eternauta> i undestand why ghc complains
06:49:31 <alpounet> oh, I misread then, nevermind :)
06:49:42 <eternauta> no problem =)
06:49:59 <eternauta> how you change the class container ofr support order?
06:50:04 <eternauta> sorry
06:50:15 <alpounet> eternauta: you have to make "the constraints" part of the instance somehow
06:50:21 <eternauta> the class container don't need suport order, but ListAssocOrd yesw
06:50:36 <alpounet> because different containers may have different constraints on their values
06:50:41 <eternauta> like this?
06:50:46 <c_wraith> All the ways I can think of to solve this are relatively advanced.
06:51:03 <alpounet> eternauta: like c_wraith says, pretty much all the solution are far from trivial
06:51:05 <c_wraith> And none use haskell 98.  Or even 2010
06:51:10 <eternauta> instanciate (Ord a) => Conatiner (ListAssoc a b)
06:51:11 <eternauta> ?
06:51:38 <k00mi> are there instances that don't require the Ord constraint?
06:51:51 <eternauta> yes
06:52:00 <eternauta> AssocList
06:52:20 <c_wraith> eternauta: So, you said this was a university project.  What are the constraints on the assignment??
06:52:42 <c_wraith> eternauta: are you expected to know about and use GHC extensions?
06:52:50 <eternauta> one moment, i search the pdf and tell you
06:52:50 <alpounet> eternauta: the problem is that even with that instanciation, you won't respect your typeclass methods' types
06:53:03 <alpounet> because for ListAssocOrd, some of them will have type: Ord a => ...
06:53:17 <eternauta> but the pdf is in spanish so haha
06:53:30 <alpounet> but that's not the type you had in 'Container'
06:53:44 <eternauta> http://www.cs.famaf.unc.edu.ar/~hoffmann/algo1/2013-2/proyectos/proy3.pdf
06:53:48 <eternauta> ponit 11
06:53:53 <eternauta> point 11
06:54:14 <alpounet> so you're providing functions that have a more restricted type, as definitions for the typeclass methods, so GHC is unhappy
06:54:45 <alpounet> to fix this, you can, for example, in addition to associating some methods to a typeclass instance, associate a "constraint type"
06:55:01 <c_wraith> eternauta: Hmm, yeah.  This looks to be a relatively introductory course.  Neither of the things I mentioned are appropriate.
06:55:04 <alpounet> this uses fairly advanced extensions, though.
06:55:37 <eternauta> it's a first course in functional programming
06:55:54 <eternauta> not advanced issues it's expected
06:56:37 <c_wraith> In that case, I'd take this question to your professor or teaching aide.  It's an excellent question for the level you're at, and it's not clear to me what the solution they want you to find is.
06:57:00 <c_wraith> your question is an excellent one, I mean.  The problem is less excellent. :)
06:57:05 <eternauta> thank you everyway
06:57:33 <eternauta> the people is very nice in this place
07:16:00 <merijn> dcoutts: Does cabal-install (or Cabal) expose a library/module for parsing .cabal files?
07:16:10 <dcoutts> yes
07:17:17 <merijn> dcoutts: \o/ Where? (Or maybe better, I remember seeing a "source overview" for cabal-install, but I can't find it again?
07:19:18 <mr-> merijn: https://github.com/haskell/cabal/wiki/Source-Guide that?
07:19:50 <merijn> mr-: Quite possibly, I just suck at Google, I guess
07:20:02 <kusut> dabd: I also just started learning haskell. this could be an alternative https://gist.github.com/bitemyapp/8739525
07:20:24 <mr-> merijn: possibly. I have it as a bookmark
07:20:48 <merijn> kusut: May want to add a link to this actual cheat sheet: http://blog.codeslower.com/static/CheatSheet.pdf
07:21:31 <the_berserker> A Java programmer who is also a Haskell guru: The code runs fine on the server tonight, not an error to be seen. Extend this please
07:21:50 <kusut> merijn: thanks
07:26:32 <Feuerbach> bergmark: actually, these were just minor .cabal fixes requested by Michael Snoyman. Are there any problems with 7.8? type-eq was fixed a long time ago
07:29:26 <the_berserker> http://m.youtube.com/watch?v=moSFlvxnbgk
07:29:47 <the_berserker> http://youtube.com/watch?v=moSFlvxnbgk does this remind you of programming in Haskell?
07:30:03 <bergmark> Feuerbach: last time i tried it failed to compile
07:30:31 <Feuerbach> bergmark: let me check
07:38:42 <Feuerbach> bergmark: yeah, there are a couple of problems. I'll look into them
07:51:22 <Feuerbach> bergmark: haha, looks like a cpphs bug (and ghc has recently switched to cpphs)
07:55:30 <sm> nominolo: hi, I see you updated the https://code.google.com/p/ideah/ plugin for intellij. I'm trying to install the latest, would you have any tips for building it ? eg what java/libs are required
08:01:39 <sm> with the java 1.6 on osx I get errors like "package org.apache.commons.lang does not exist" and "type javax.swing.JComboBox does not take parameters"
08:04:24 * hackagebot gravatar 0.5.4 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.5.4 (PatrickBrisbin)
08:04:26 * hackagebot yesod-auth-oauth2 0.0.2 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.2 (PatrickBrisbin)
08:06:52 <Feuerbach> bergmark: http://www.haskell.org/pipermail/ghc-devs/2014-February/004081.html
08:08:43 <haasn> I will never understand how http://lpaste.net/100242 manages to be so incredibly fast despite being so incredibly stupidly
08:09:08 <c_wraith> stupidly?
08:09:13 <haasn> naively, perhaps
08:09:28 <haasn> it uses [[a]] all over the place, stuff like O(n²) nodups for validity checking
08:09:46 <haasn> (++) in every step to update the grid
08:09:57 <haasn> yet it solves the “world's hardest sudoku” in 0.050ms
08:09:59 <haasn> s*
08:10:18 <haasn> despite many other solutions taking like a second for that one despite optimization
08:10:46 <c_wraith> better algorithms help, even on sketchy data structures
08:10:53 <haasn> and it doesn't even do anything magical as far as the search space and higher-order logic is concerned; it literally just brute-forces with dead ends and back tracking
08:11:35 <haasn> (although it does prune the set of available choices quite nicely, which covers the majority of “easy” sudokus)
08:14:07 <c_wraith> that last step actually looks significant
08:14:26 * hackagebot git-annex 5.20140221 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140221 (JoeyHess)
08:15:03 <c_wraith> solve4 looks like it has some subtly *really important* logic going on.
08:18:28 <jmct> is anyone here familiar with implementing strictness analysis (via abstract interpretation)?
08:20:34 <merijn> jmct: That seems like the kind of in-depth question that may get better response on the mailing lists
08:20:52 <merijn> jmct: The odds of anyone knowing that around are much smaller than them reading it on the mailing list :)
08:21:04 <jmct> fair enough :) just thought I'd try
08:28:28 <magneticduck> I got a new error today
08:28:35 <magneticduck> "pattern syntax in expression context"
08:28:37 <magneticduck> yay
08:28:44 <magneticduck> I can kind of guess what it means =P
08:28:48 <magneticduck> but I'm kind of suprised that I got it
08:29:51 <jmct> Taneb: you around?
08:30:29 <merijn> Hackage doesn't index the GHC modules? :(
08:30:41 <merijn> Anyone know which package GHC.runGhc comes from?
08:30:51 <Feuerbach> ghc, probably
08:30:51 <alpounet> 'ghc' I think
08:31:00 <magneticduck> alright I can't figure it out xD http://ix.io/
08:31:03 <magneticduck> oops wrong link
08:31:14 <merijn> @hackage ghc
08:31:14 <lambdabot> http://hackage.haskell.org/package/ghc
08:31:26 <merijn> That doesn't exist >.>
08:31:26 <Feuerbach> it's not on hackage
08:31:29 <Feuerbach> it's the ghc api
08:31:40 <bennofs> http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/
08:31:47 <merijn> Feuerbach: Right, and my question was: Why isn't it
08:31:49 <magneticduck> http://ix.io/aE3
08:32:05 <magneticduck> anyway, problem occurs right at line 7 in that file
08:32:09 <alpounet> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.3/index.html <- it's there too
08:32:11 <merijn> bennofs: Ah, thanks
08:32:16 <magneticduck> returns the entire lambda expression as error context
08:32:26 <Feuerbach> merijn: because ghc is not cabalized
08:33:25 <bxc_> argh hdbc-mysql not building with recent cabal is doing my head in.
08:33:27 <merijn> Ah, right
08:33:51 <magneticduck> any ideas about my problem x|
08:33:56 <magneticduck> for some reason I'm not really seeing the light
08:34:48 <bergmark> Feuerbach: aha, also we submitted a PR to type-eq so it would always use cpphs because of Mavericks
08:34:52 <Feuerbach> magneticduck: did you miss lambda i.e. \?
08:35:16 <magneticduck> lol
08:35:21 <magneticduck> I was a bit confused by the error I supose
08:35:23 <magneticduck> suppose*
08:35:25 <magneticduck> yes
08:36:24 <Feuerbach> bergmark: aha! it's your fault, then :)
08:36:34 <Feuerbach> so ghc doesn't always use cpphs
08:36:39 <Feuerbach> it's just type-eq
08:38:05 <bergmark> :-(
08:38:41 <magneticduck> btw, bit curious, is there a type synonym of something like "type Transform a = (a -> a)" defined in any base / well-used libraries?
08:38:50 <Feuerbach> yes, Endo
08:38:54 <Feuerbach> in Data.Monoid
08:38:59 <Feuerbach> it's a newtype, not a synonym
08:39:16 <magneticduck> oh
08:39:27 <magneticduck> :/
08:39:31 <magneticduck> would like a synonym
08:39:32 <bergmark> Feuerbach: but do you need to use type-eq at all in 7.8?
08:39:44 <magneticduck> making a newtype for something like that was used to make it an instance of some class right?
08:39:57 <magneticduck> I'd kind of like a synonym, sometimes it's helpful
08:40:24 <Feuerbach> bergmark: I need compatibility code, and I'd rather had that code in type-eq
08:40:45 <bergmark> Feuerbach: yeah that makes sense
08:41:05 <Feuerbach> magneticduck: yes, Monoid
08:41:43 <magneticduck> yeah =P
08:49:34 * hackagebot amqp 0.8.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.8.1 (HolgerReinhardt)
09:21:15 <dhrosa> are there any packages that combine the use of random and state? I find myself writing functions that use System.Random and the State monad a lot
09:22:12 <geekosaur> MonadRandom/MonadRandomLazy is canonical, I believe
09:23:31 <dhrosa> geekosaur: thanks!
09:29:23 <mm_freak> is there an extension for kind aliases?
09:29:37 * hackagebot yesod-auth-oauth2 0.0.3 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.3 (PatrickBrisbin)
09:57:42 <tpsinnem> is there something that just frigging works for jumping to a source file where a name under the cursor is defined? hothasktags and others have failed to generate stuff of parts of the code i'm interested in. something ghc-mod based perhaps?
09:59:06 <tpsinnem> ^ in vim that is
10:05:23 <PythonNut> @pl \x -> null [q | q<-[3, 5..floor $ sqrt $ fromIntegral x], rem x q == 0]
10:05:23 <lambdabot> null . ap ((:) . ((q | q) <-) . enumFromThenTo 3 5 . floor . sqrt . fromIntegral) (return . (0 ==) . flip rem q)
10:06:11 <PythonNut> @pl ((<x) . (^2))
10:06:12 <lambdabot> (< x) . (^ 2)
10:06:41 <PythonNut> @px \x -> null $ filter (\y -> rem x y == 0) $ takeWhile ((<x) . (^2)) [3,5..]
10:06:41 <lambdabot> null . ap (filter . flip flip 0 . ((==) .) . rem) (flip takeWhile [3,5..] . (. (^ 2)) . flip (<))
10:10:34 <pjdelport> tpsinnem: http://www.haskell.org/haskellwiki/Tags#Haskell_tag_generators ?
10:10:51 <PythonNut> Are there any plans to include stream fusion in the GHC Platform by default?
10:11:15 <PythonNut> Or is it already there and I have just missed it :)
10:11:34 <Iceland_jack> There are still problems with concatMap
10:12:05 <Iceland_jack> It already has a limited form of fusion though through build/destroy
10:12:18 <Iceland_jack> You can also use libraries which support stream fusion
10:12:32 <Iceland_jack> http://hackage.haskell.org/package/stream-fusion
10:12:33 <PythonNut> More generally, assuming that all of the bugs are squished at some point in the future, will the libraries be shipped in the platform?
10:12:55 <Iceland_jack> Presumably yes
10:13:06 <Iceland_jack> You may want to read https://ghc.haskell.org/trac/ghc/ticket/915
10:13:14 <PythonNut> I'm trying to avoid extra libraries when I can, I wan't my code to be run on a stock system.
10:13:31 <Iceland_jack> What is your use case?
10:13:53 <PythonNut> Writing examples of Haskell for friends
10:14:10 <PythonNut> Who won't have the libraries
10:14:42 <Iceland_jack> Have you benchmarked your code to be too slow or do you want to show case stream fusion to them in particular?
10:15:00 <Iceland_jack> ByteString and Vector already use fusion
10:15:05 <PythonNut> I have a function that's tail recursive (basically manual fusion), but it's almost like I'm just porting from imperative, rather than using Haskell for what it is.
10:15:40 <Iceland_jack> Do you need fusion?
10:16:34 <PythonNut> It would make my code much simpler.
10:16:49 <Iceland_jack> Let me rephrase, is your code too slow without it?
10:17:06 <PythonNut> 2x slower than tail-recursion
10:17:19 <lpsmith> edwardk, how would you feel about making bracket,  bracket_,  and bracketOnError part of the MonadCatch typeclass in exceptions?
10:17:20 <PythonNut> I'm trying to show parity with C, so that won't do. :(
10:17:21 <Iceland_jack> Is speed needed to showing code to your friends?
10:17:34 <Iceland_jack> If you want speed, use the right libraries
10:17:40 <Iceland_jack> s/libraries/tools/
10:17:53 <lpsmith> edwardk, especially considering the existence of bracketSnap and friends?
10:18:33 <edwardk> lpsmith: throw an issue on the repository? that'd get snoyman and johnw into the discussion
10:18:39 <joneshf-laptop> is there a cleaner way to do this: \x -> either (const $ either Error Bar (parseBar x)) Baz (parseBaz x)
10:18:41 <edwardk> lpsmith: i'm not particularly against it
10:18:53 <PythonNut> And another question, how can I make an infinite vector containing odd numbers? Is that even possible?
10:18:59 <PythonNut> And can it be unboxed?
10:19:08 <joneshf-laptop> basically I want either but i want the left not to fail early
10:19:28 <johnw> lpsmith: indeed it would!
10:19:32 <prophile> joneshf-laptop: might look nicer with a case-lambda
10:19:41 <Eduard_Munteanu> PythonNut: that'd be a function, not a vector :)
10:19:41 <prophile> as in -XLambdaCase
10:20:04 <prophile> otherwise, iunno
10:20:05 <Eduard_Munteanu> PythonNut: all odd numbers are 2k + 1 for some k
10:20:18 <joneshf-laptop> prophile, i'm not familiar with that, lemme see
10:20:35 <prophile> looks a lot like the equivalent of mplus for Maybe
10:20:51 <PythonNut> Hm... I want to filter it lazily though. I guess I'll do something else then.
10:20:59 <prophile> you could try Error/ErrorT rather than Either
10:21:15 <lpsmith> edwardk, ok, I should be sending a pull request in a few minutes
10:21:21 <edwardk> k
10:21:26 <joneshf-laptop> prophile, oh, maybe it is monadplus
10:21:33 <PythonNut> So Vectors (from Data.Vector) fuse? (Unmodified in GHC)
10:21:54 <joneshf-laptop> except either has no instance
10:21:57 <joneshf-laptop> Either*
10:23:24 <Eduard_Munteanu> PythonNut: what do you mean filter?
10:24:09 <PythonNut> Something like "V.null . V.filter (\x -> ...) $ ...big vector here..."
10:24:30 <pjdelport> PythonNut: [1,3..] ?
10:24:44 <PythonNut> And I want it to short-circut as soon as anything is found.
10:25:02 <PythonNut> pjdelport, no that's a list (if I'm not mistaken)
10:25:03 <tpsinnem> pjdelport: i think i've tried all of those at some point -- i see that https://github.com/dag/vim2hs supports 'fast-tags' and i guess i'll try it with that
10:25:19 * Iceland_jack . o O ( OverloadedLists )
10:25:27 <pjdelport> PythonNut: why do you want a vector, specifically?
10:25:40 <tpsinnem> btw general apologies for the grumpiness of the question!
10:25:56 <Iceland_jack> grumpiness++
10:26:09 <PythonNut> I want it to be unboxed (for speed, I'm using Int) and fused. Afaik vanilla lists don't fuse.
10:26:30 <Iceland_jack> They do fuse things
10:26:40 <Iceland_jack> There are many different types of fusion
10:27:20 <pjdelport> PythonNut: fusion is more about avoiding big unnecessary intermediate data structures
10:27:21 <Eduard_Munteanu> PythonNut: arrays can't really be infinite
10:27:32 <pjdelport> PythonNut: using a list in this case avoids the intermediate data structures :)
10:27:50 <Eduard_Munteanu> PythonNut: you could make a list of arrays to reduce overhead, though
10:28:34 <Eduard_Munteanu> It's what ByteString and Text do, btw.
10:28:41 <pjdelport> PythonNut: If that form is suitable for your problem, have you tried it?
10:28:45 <PythonNut> Hm... I read somewhere that certain kinds of fusion can optimize to zero data-structures
10:28:47 <triliyn> PythonNut: with lists it will also automatically short circuit because of laziness
10:29:12 <pjdelport> GHC may well optimize the list and boxing away
10:29:18 <triliyn> (And because null should short circuit)
10:29:38 <Eduard_Munteanu> If the list fuses, yeah.
10:29:53 <Eduard_Munteanu> PythonNut: take a look at the 'stream-fusion' package
10:30:08 <Iceland_jack> Eduard_Munteanu: PythonNut said they didn't want to use libraries..
10:31:48 <PythonNut> How do I generate a vector list-range style
10:32:22 <Iceland_jack> check out Enumeration
10:32:31 <Eduard_Munteanu> Er, no, you misunderstood I think.
10:32:46 <Eduard_Munteanu> PythonNut: making a vector of odd numbers isn't a good approach
10:33:27 <Eduard_Munteanu> Of all odd numbers, that is.
10:33:28 <PythonNut> Okay, let me rephrase this qustion: What is the optimal Trial-By-Division primality test in pure Haskell?
10:33:48 <PythonNut> null [q | q<-2:[3, 5..floor $ sqrt $ fromIntegral x], rem x q == 0]
10:33:58 <PythonNut> is about 2.5x slower than tail-recursion
10:34:39 <Eduard_Munteanu> PythonNut: have you compiled with optimizations turned on?
10:34:49 <PythonNut> Yes
10:35:01 <alpounet> -O2?
10:35:14 <PythonNut> -O3 (though -O2 is about the same) and -fllvm
10:35:20 <Eduard_Munteanu> -O3 doesn't exist
10:35:24 <makalu> is there any usable web server that has less dependencies than happstack, snap, warp? Efficiency is not important
10:35:31 <tpsinnem> perhaps this is more of a vim question but i haven't come across this in other contexts: for some reason the folds automatically generated by vim2hs are start off as being closed. anyone know if there's a way to change that behavior?
10:35:32 <alpounet> -O3 is a synonym for -O2, for convenience
10:35:34 <PythonNut> Also tried the flags found at http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
10:35:44 <PythonNut> But also made little difference
10:35:49 <Eduard_Munteanu> makalu: do you need a Haskell web server?
10:35:51 <alpounet> makalu: scotty is nice
10:36:00 <makalu> scotty uses warp
10:36:30 <makalu> Eduard_Munteanu: yes. Something where I write my own handlers and link it to my program.
10:36:31 <alpounet> yes, but warp happens to be the faster server we have, afaik
10:37:03 <alpounet> so you just want a really lightweight one
10:38:01 <makalu> yes
10:38:16 <stepcut> makalu: as far as I know, the only http backends are happstack, snap, and warp. There is also acme-http -- which doesn't implement most of the standard.
10:38:22 <tpsinnem> ^ .. ok i think this solves the default folding question: http://stackoverflow.com/questions/8316139/vim-how-to-set-the-default-to-unfolded-when-you-open-a-file
10:38:49 <stepcut> eventually hyperdrive will be another option -- but not today
10:38:59 <makalu> hyperdrive?
10:39:47 <Eduard_Munteanu> PythonNut: is that in ghc or ghci?
10:40:00 <PythonNut> Anyway, C++ gets 0.3s on average (TOD seiving all primes < a million), and the fastest I've got Haskell is 0.5s for a tail-recursive function. A null . filter ... function almost reads like the mathematical definition of a prime and I'm wondering how I can get good performance with that.
10:40:07 <PythonNut> ghc
10:40:16 <tac> Is it possible to have GHC compile Core-language source files?
10:40:34 <tac> say, if I wanted to leverage GHC's optimization pipeline for a toy language?
10:40:42 <Iceland_jack> -fext-core ?
10:40:45 <Eduard_Munteanu> PythonNut: the lists in Prelude are pretty bad at fusion, yeah
10:41:03 <Eduard_Munteanu> PythonNut: just write a recursive function
10:41:07 <makalu> I wonder how difficult would it be to write an inefficient, insecure but basically complete HTTP server
10:41:31 <makalu> with few dependencies (attoparsec, network and stuff are OK)
10:41:39 <Eduard_Munteanu> makalu: why not use lighttpd or something else?
10:41:50 <PythonNut> But that makes the Haskell harder to understand than C++, which makes Haskell look pretty lame.
10:41:59 <triliyn> PythonNut: I've seen someone build up a list of primes as they do this so they didn't need to test divisibility by composite numbers
10:41:59 <PythonNut> I could just be being unreasonable :)
10:42:03 <Eduard_Munteanu> PythonNut: how did you write it?
10:42:37 <PythonNut> Erm... how does code work on IRC?
10:42:42 <Iceland_jack> @paste
10:42:42 <lambdabot> Haskell pastebin: http://lpaste.net/
10:42:48 <alpounet> http://www.haskell.org/haskellwiki/Prime_numbers#Bitwise_prime_sieve_with_Template_Haskell hah
10:42:52 <Eduard_Munteanu> PythonNut: what Iceland_jack said
10:43:05 <PythonNut> http://lpaste.net/100244
10:43:14 <PythonNut> @paste
10:43:15 <lambdabot> Haskell pastebin: http://lpaste.net/
10:43:24 <subleq> can you turn a value like ((),1),2) into the list [2,1]?
10:43:41 <Eduard_Munteanu> PythonNut: if you want to demonstrate Haskell, I suggest you add paralellism to the mix.
10:43:44 <Iceland_jack> subleq: sure..
10:43:59 <dmwit> subleq: Define "like".
10:44:10 <Eduard_Munteanu> PythonNut: which is generally more annyoing to do in C
10:44:11 <tac> > let (((), x), y) = (((),1),2) in [y, x]
10:44:14 <lambdabot>  [2,1]
10:44:17 <subleq> i thought it would be unfold () = []; unfold (xs, x) = x : unfold xs
10:44:20 <Iceland_jack>  
10:44:20 <Iceland_jack>     turnAValueLike (((), a), b) = [b, a]
10:44:22 <PythonNut> And how would I do that? My attempts have failed so far. I'm really curious to see Haskell paralell in action.
10:44:23 <mm_freak> subleq: whatever converts the value to a list, write its type signature first
10:44:31 <Iceland_jack> > turnAValueLike (((), 1), 2)
10:44:34 <mm_freak> tupleToList :: ?
10:44:35 <lambdabot>  [2,1]
10:44:40 <tac> subleq: You probably wouldn't want to talk about tuples and lists together.
10:44:52 <tac> Unless you only cared about fixed-length lists
10:45:05 <subleq> no, it could be of any length
10:45:09 <mm_freak> i don't think subleq is helped by writing ready-made functions for him, because this sounds like they didn't think this through =)
10:45:15 <Iceland_jack> PythonNut: Check out ‘Parallel and Concurrent Programming in Haskell’
10:45:18 <mm_freak> s/him/them/
10:45:19 <subleq> isn't that structure a normal linked list?
10:45:19 <Iceland_jack> by Simon Marlow
10:45:24 <mm_freak> subleq: no
10:45:31 <dmwit> I'm with mm_freak. Not everyone here is being helpful.
10:45:52 <Iceland_jack> Yes my answer was more of a joke, I should've given actual advice
10:46:08 <mm_freak> subleq: write the type signature for the conversion function…  it will reveal that you have a misconception about tuples =)
10:46:19 <subleq> i can't figure out what the type would be
10:46:27 <mm_freak> subleq: what's the target type?
10:46:30 <dmwit> I don't think mm_freak is being helpful, either. Just because it's hard in Haskell doesn't mean it's a misconception. ;-)
10:46:43 <PythonNut> I did, but checking if n<1000000 is prime is so fast that the overhead of a thread is much higher.
10:46:52 <mm_freak> let me be more specific then:  you may have a misconception about haskell tuples =)
10:46:54 <jrmithdobbs> PythonNut: i'm confused, you're saying the tail recursive version is less readable than the same in c++? because i don't see it
10:46:54 <Iceland_jack> PythonNut: It wouldn't use a thread
10:47:14 <Iceland_jack> also threads in Haskell are not heavyweight anyway
10:47:15 <subleq> mm_freak: [a] where the tuples are (b, a)
10:47:26 <merijn> PythonNut: Haskell threads are pretty lightweight
10:47:27 <mm_freak> subleq: ok, so you need a function from b to a first
10:47:42 <dmwit> subleq: In Haskell, there is a tradeoff between tuples and lists: lists can have runtime-chosen length, but all elements must be the same type; tuples can have elements of different type, but the "length" must be chosen at compile time.
10:47:48 <mm_freak> so far we have:  convert :: (b -> a) -> (b, a) -> [a]
10:47:51 <PythonNut> And breaking th problem into chunks make the code (currently a dozen lines) much less acessible.
10:47:53 <dmwit> subleq: So it is not easy to translate back and forthe between them in a natural way in Haskell.
10:48:06 <subleq> dmwit: but the length is always 2
10:48:17 <dmwit> subleq: If you always want length 2, then it is easy.
10:48:20 <Iceland_jack> PythonNut: Yes, parallelism is trickier than non-parallelism :)
10:48:25 <subleq> no, the length of each individual tuple is 2
10:48:25 <dmwit> subleq: And everybody was telling you how to do it. =)
10:48:26 <Iceland_jack> at least, good parallelism
10:48:26 <Eduard_Munteanu> PythonNut: not that, split the dataset into a fixed number of pieces, not for every n. Besides, Haskell threads aren't OS threads, they're lighter.
10:48:29 <PythonNut> Yes, but I'm doing ~100k primes a second. No thread on earth is that light.
10:48:32 <mm_freak> subleq: in that case the 'b' is still a problem, because lists are homogenous
10:48:42 <subleq> but they can be nested arbitrarily
10:48:56 <Iceland_jack> PythonNut: Like I said, it wouldn't use threads.. feel free to read the book
10:49:06 <dmwit> subleq: Right. So what I'm saying is that in Haskell, the structure of tuples is fixed at compile-time.
10:49:14 <dmwit> subleq: And that fact is what you are butting your head against.
10:49:18 <jrmithdobbs> subleq: why do you think a tuple is a rosetree
10:49:29 <Iceland_jack> subleq: Tuples aren't used like that :)
10:49:37 <PythonNut> If I break it down, into chunks I lose the practically one-liner feel of the code. :( But I think I'll try it anyway.
10:50:08 <Eduard_Munteanu> PythonNut: you can still make it a one-liner, more or less
10:50:08 <dmwit> subleq: This is a limitation of Haskell, to be sure. But it does have its upsides: making this restriction eases type inference considerably, so there's a lot less work for the programmer in almost all common cases.
10:50:55 <mm_freak> subleq: try to explain your application instead
10:51:07 <mm_freak> it sounds like tuples simply don't solve your problem =)
10:51:08 <dmwit> subleq: Other languages make other choices, of course; for example, you might like to look at Agda, Idris, or Coq, where there is no practical difference between tuples and lists.
10:51:08 <jrmithdobbs> subleq: I'm pretty sure you can easily build the structure you want, it's just not a tuple
10:51:14 <subleq> yeah, when thinking about my application i'm pretty sure it's nonsensical
10:51:39 <subleq> i'm trying to play with this: http://www.codecommit.com/blog/cat/the-joy-of-concatenative-languages-part-3
10:51:40 <Iceland_jack> subleq: Do you want to create a new datatype/structure/record?
10:51:41 <Eduard_Munteanu> PythonNut: DPH might also be of interest to you, although it's not really ready, last time I checked.
10:51:43 <mm_freak> i don't think dmwit is helpful by suggesting to look at agda =P
10:51:49 * dmwit shrugs
10:51:56 <dmwit> It depends on his goals.
10:52:07 <subleq> and i wanted a function to turn the stack at the end into a list, but that doesn't make sense because the stack is not homogeneous
10:52:11 <dmwit> I tried to ask about them, but he wouldn't answer. So I have to present the options and why you might choose them.
10:52:26 <Eduard_Munteanu> These days even Haskell does HLists decently.
10:52:29 <Iceland_jack> mm_freak: I've seen too many people suggesting ‘free monoids’ when explaining linked lists to newbies, I've stopped bothering anymore :)
10:52:38 <mm_freak> subleq: note that lists themselves are stacks
10:53:15 <jrmithdobbs> Iceland_jack: well lists are a great example of lists after all ;p
10:53:20 <mm_freak> subleq: but understand that in haskell you really get two types of stacks:  type stacks (as in tuples) and value stacks (as in lists)
10:53:29 <subleq> mm_freak: no, my stack is heterogenous
10:53:36 <subleq> mm_freak: i don't understand what type stack means
10:53:47 <dmwit> me neither
10:53:56 <mm_freak> subleq: well, it's a stack structure, but it vanishes after compilation
10:53:59 <Iceland_jack> jrmithdobbs: Yes but the term ‘free monoid’ shouldn't ever come up when someone doesn't understand basic consing
10:54:00 <subleq> jrmithdobbs: what's a rosetree?
10:54:16 <Eduard_Munteanu> subleq: an arbitrary n-ary tree
10:54:19 <dmwit> subleq: It's just a tree with arbitrary branching at each level.
10:54:23 <mm_freak> subleq: for example you can have something like "MyType (a, (b, (c, ())))" that represents a function that takes some arguments
10:54:35 <Eduard_Munteanu> Not a fixed 'n'.
10:54:40 <mm_freak> subleq: then 'apply' would have the following type:  apply :: MyType (a, b) -> a -> MyType b
10:54:59 <mm_freak> this mechanism of what i called "type stack" above is used often in haskell DSLs
10:55:09 <mm_freak> for example in the boomerang library
10:55:48 <nooodl> @let unfoldMaybe f = takeWhile isJust . iterate (>>= f) . Just
10:55:50 <lambdabot>  Defined.
10:56:25 <nooodl> > let half x | even x = Just (div x 2) | otherwise = Nothing in unfoldMaybe half 24
10:56:28 <lambdabot>  [Just 24,Just 12,Just 6,Just 3]
10:56:39 <nooodl> ^ is there some nicer way to write "unfoldMaybe"?
10:56:55 <Eduard_Munteanu> :t unfoldMaybe
10:56:56 <lambdabot> (a -> Maybe a) -> a -> [Maybe a]
10:57:04 <nooodl> oh uh that should be [a]
10:57:09 <nooodl> and return [24,12,6,3]
10:57:13 <nooodl> i guess i need "nicer and correct"
10:57:15 <Fuuzetsu> PythonNut: I'm unsure what answers you're expecting. You want to use functionality that libraries provide you but don't want to use libraries… You want to do something more complicated than one-liner but using a one-liner… It's not magic. Also, if your friends are going to grab the platform anyway, why not use libraries? AFAIK it comes with cabal-install and they can just cabal-install your package and get all the libs pulled in for
10:57:15 <Fuuzetsu> them.
10:57:19 <Iceland_jack> nooodl: heh
10:57:29 <Eduard_Munteanu> nooodl: what is the correct type?
10:57:37 <nooodl> (a -> Maybe a) -> a -> [a]
10:57:39 <Iceland_jack> (a -> Maybe a) -> a -> [a]
10:57:49 <nooodl> i guess "map fromJust . ..." would do the trick but ewww
10:57:58 <triliyn> Isn't there an unfoldr already that does this?
10:58:08 <Iceland_jack> yes there is
10:58:08 <Eduard_Munteanu> nooodl: sequence
10:58:10 <Iceland_jack> basically
10:58:12 <dmwit> :t until
10:58:13 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
10:58:19 <jrmithdobbs> something . catMaybes
10:58:20 <dmwit> > until odd (`div` 2) 24
10:58:21 <lambdabot>  3
10:58:28 <dmwit> Okay, not quite. =P
10:58:29 <Eduard_Munteanu> Er, right, you don't want sequence.
10:58:35 <dmwit> :t unfoldr
10:58:35 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:59:00 <triliyn> oh, so it's not quite the same
10:59:11 <jrmithdobbs> foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
10:59:14 <nooodl> > unfoldr (fmap (join (,)) . half) 4
10:59:17 <lambdabot>  [2,1]
10:59:18 <jrmithdobbs> that's what you *really* want probably
10:59:25 <nooodl> close
10:59:32 <jrmithdobbs> (lens >=4)
10:59:37 <dmwit> > unfoldr (\x -> let (d, m) = divMod x 2 in guard (m == 0) >> return d) 24
10:59:38 <lambdabot>  Occurs check: cannot construct the infinite type: a1 = (a0, a1)
10:59:58 <nooodl> dmwit: i'd like a solution for any (a -> Maybe a)
11:00:01 <nooodl> not just `half`
11:00:04 <Geraldus_RU> Hello everybody!
11:00:24 <dmwit> nooodl: Oh, that's even easier.
11:00:56 <nooodl> > unfoldr (fmap (join (,)) . half) 4 -- this was pretty close, and i could just (:) the initial value in front, but maybe there's something nicer?
11:00:59 <lambdabot>  [2,1]
11:00:59 <Eduard_Munteanu> Geraldus_RU: hi
11:01:04 <merijn> nooodl: "map fromJust" ಠ_ಠ ಠ_ಠ ಠ_ಠ
11:01:09 <dmwit> > let iter f = unfoldr (\x -> join (,) <$> f x) in iter (\x -> if even x then Just (x `div` 2) else Nothing) 24
11:01:11 <lambdabot>  [12,6,3]
11:01:37 <nooodl> merijn: but i'm "takeWhile isJust"-ing before that!! :)
11:01:41 <dmwit> But why Maybe?
11:01:56 <PythonNut> @Fuuzetsu I'm a newbie at Haskell, so I guess I'm just try to see how far the awesomeness extends :)
11:01:56 <lambdabot> Unknown command, try @list
11:01:59 <dmwit> > takeWhile even (iterate (`div` 2) 24)
11:02:00 <tpsinnem> is there a way to make hothasktags or lushtags make use of whichever extensions are specified in the relecant .cabal file?
11:02:00 <lambdabot>  [24,12,6]
11:02:07 <tpsinnem> relevant
11:02:23 <merijn> tpsinnem: Not as of yet
11:02:39 <merijn> tpsinnem: If you're willing to hack it in, that'd be great :p
11:03:19 <Eduard_Munteanu> @hoogle iterateM
11:03:20 <lambdabot> No results found
11:03:27 <merijn> Sounds like a job for
11:03:31 <merijn> @hackage monad-loops
11:03:31 <lambdabot> http://hackage.haskell.org/package/monad-loops
11:03:33 <Fuuzetsu> PythonNut: Not that far (for your task) if you're refusing to use libraries.
11:03:36 <Eduard_Munteanu> Yeah.
11:03:43 <dmwit> > let iter f x = x : maybe [] (iter f) (f x) in iter (\x -> guard (even x) >> return (x `div` 2)) 24
11:03:44 <lambdabot>  [24,12,6,3]
11:03:45 <tpsinnem> merijn: i suspect that in order to acquaint myself with the relevant codebases in order to be able to implement that feature, i'd first need that feature :P
11:03:53 <johnw> @src mconcat
11:03:53 <lambdabot> Source not found. :(
11:03:58 <dmwit> nooodl: This is my favorite way so far.
11:04:02 <johnw> @src mconcat Sum
11:04:02 <lambdabot> Source not found. Are you typing with your feet?
11:04:04 <mm_freak> does anyone actually use monad-loops?  i mean, by now we have really good stream processing abstractions
11:04:12 <merijn> tpsinnem: I know, that's why I started to work on making hdevtools cabal + sandbox aware 30 mins ago :p
11:04:25 <merijn> mm_freak: I do for my "shell script haskell" things
11:04:28 <nooodl> dmwit: cool!
11:04:44 <mm_freak> merijn: i'd probably use pipes even there
11:04:47 <merijn> mm_freak: i.e. I just want a quick throw away script to mince some bash output or whatever
11:04:52 <Geraldus_RU> I'm using GHCJS now. It's inside Vagrant VM now, there is GHC version 7.7.20130908, but I found it's kind unhandy. Main GHC version installed in my OS is 7.6.3. And I'm thinking now to upgrade my OS-wide CGH to have ability to use GHCJS without VM. What possible disadvantages I will gain?
11:04:56 <merijn> mm_freak: Yes, but you're like a pipes guru by now :p
11:05:15 <dmwit> > let iter f = go where go x = x : maybe [] go (f x) in iter (\x -> guard (even x) >> return (x `div` 2)) 24 -- make that worker-wrapper transform a habit, mate!
11:05:17 <lambdabot>  [24,12,6,3]
11:05:19 <Eduard_Munteanu> Unfortunately, Haskell's overuse of String in System.* libs is annoying.
11:05:22 <tpsinnem> merijn: neat
11:05:24 <merijn> Geraldus_RU: Biggest problem would be "not all libraries working with 7.7 yet"
11:05:34 <mm_freak> merijn: it's easy to become one…  write one almost regular IO action that 'yield's, and another one that 'await's…  that's pretty much it =)
11:05:34 <Gary> Hey there !
11:05:48 <merijn> Geraldus_RU: Also, slightly less tested compiler, not any big problems, tbh
11:05:48 <Gary> Hey there !
11:05:52 <Geraldus_RU> merijn: what about Yesod? Do you know?
11:05:52 <Guest63433> Hey there !
11:06:03 <merijn> Geraldus_RU: I've never tried yesod, so no clue
11:06:21 <merijn> There's a #yesod, I think? Probably they know
11:06:25 <Geraldus_RU> merijn: thank you
11:06:52 <Eduard_Munteanu> Geraldus_RU: not sure how Yesod fits here
11:07:32 <Geraldus_RU> Eduard_Munteanu: you mean on this channel? Or with 7.7 compiler?
11:07:34 <Eduard_Munteanu> Geraldus_RU: aside from julius templating it doesn't really provide anything JS-wise
11:07:51 <Eduard_Munteanu> I was talking about the Yesod question.
11:08:16 <Geraldus_RU> Eduard_Munteanu: I want use Yesod and write JS code using GHJS and Sodium
11:08:19 <dmwit> Guest824: We'd be happy to talk to you about Haskell, if you have a question.
11:08:32 <Eduard_Munteanu> Geraldus_RU: that should be fine
11:08:55 <Geraldus_RU> Eduard_Munteanu: Looks like the best way is to try myself )
11:09:29 <Eduard_Munteanu> I want to try it myself too... what's a reasonable Haskell -> JS thing that doesn't involve templating JS?
11:10:13 <Geraldus_RU> Eduard_Munteanu: reactive applications I suppose
11:11:09 <Eduard_Munteanu> Geraldus_RU: uh, I just want to avoid coding JS :)
11:13:11 <Geraldus_RU> Eduard_Munteanu: so do I though I find JS fun, that's because I studying GHCJS now.
11:13:33 <tpsinnem> merijn: do you happen to know if there's something using hdevtools to jump to the sourcefile+location of the definition of a name under the cursor in vim (whether that involves building a separate tags file or not)?
11:14:03 <Eduard_Munteanu> JS would be fun as a low-level representation you compile to. :)
11:14:16 <merijn> tpsinnem: Yes, IFF the source is in the same package
11:15:09 <PythonNut> @pl \x -> linesBy (=='\n') x
11:15:09 <lambdabot> linesBy ('\n' ==)
11:15:17 <merijn> tpsinnem: There's the ":HdevtoolsInfo" command, it will show type signature, definition (and constructors) for the symbol you're mousing over
11:15:37 <merijn> tpsinnem: This includes the location of the module it's defined in, and if that's in the same package you can hit enter to jump to it
11:15:49 <merijn> tpsinnem: It's not as fast as, say, ctags, but it's ok
11:15:51 <tpsinnem> merijn: ok, sweet
11:16:17 <tpsinnem> in that case i'm quite looking forward to your cabally hdevtools :)
11:16:48 <PythonNut> Does anyone know if semantic Haskell auto-complete exists?
11:16:55 <PythonNut> For emacs that is
11:19:15 <augur_> kosmikus: are there major differences between Simply Easy! and A Tutorial Implementation?
11:19:33 <tpsinnem> merijn: may i further pester you by asking if you're able to predict when it might be ready? :D
11:21:10 <merijn> tpsinnem: I was hoping later tonight >.>
11:21:17 <tpsinnem> gosh
11:21:35 <merijn> But I've never used cmdargs before, so I'm wrestling with figuring out how to make that do what I want
11:24:54 * hackagebot yesod-auth-oauth2 0.0.4 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.4 (PatrickBrisbin)
11:28:02 <xintron> I'm playing around with an IRC-bot and wondered how "expensive" it is to use forkIO. Currently I run forkIO for each incomming message (to run a bunch of hooks to be executed).
11:28:03 <bennofs> In GHC, is Gen 0 the younger generation or Gen 1?
11:28:13 <monochrom> forkIO is cheap
11:28:23 <bennofs> xintron: GHC has it's own scheduler, so forkIO is very cheap
11:28:43 <xintron> So instead of having one thread running forM_ I could do forM_ and fork each run?
11:29:33 <Eduard_Munteanu> xintron: alternatively use a Chan and a single handler thread
11:29:51 <Eduard_Munteanu> Writes to Chan don't block since it's unbounded.
11:30:07 <xintron> I'm using channels for sending data back over the handle (from each hook)
11:30:49 <xintron> But yeah, maybe it would be better to use a chan to initiate the running of the hooks as well. Although that would make the state-handling a lot more complex with teh current solution.
11:31:03 <xintron> Oh well, seeing that forkIO is cheap this will do for now :)
11:31:07 <xintron> Thanks!
11:31:13 <Eduard_Munteanu> xintron: why would it? You run a plain forM on the reader end.
11:31:35 <monochrom> I would use one thread to dequeue, run hooks, repeat
11:31:49 <Eduard_Munteanu> That's what I meant, yeah.
11:32:22 <kosmikus> augur_: not major, IIRC. "A Tutorial Implementation" is the latest version, however, and probably the most polished.
11:32:37 <xintron> Yeah, I'll look into that solution. Should be a bit faster for most cases I guess
11:32:38 <augur_> kosmikus: k :)
11:32:42 <monochrom> it is more about what I want than what is cheap
11:33:28 <xintron> Well, I love the chan concept so it's been on my todo-list but I just wanted to hear if I could leave it be for now
11:33:36 <xintron> Depending on if forkIO was cheap or not :)
11:33:39 <Eduard_Munteanu> xintron: oh, definitely
11:34:17 <PythonNut> How do I profile stream fusion?
11:34:25 <PythonNut> It says I don't have the profiling libraries for it
11:34:32 <xintron> Should polish up this code and put it on the web so I could get some feedback, seeing as this is my first proper Haskell project.
11:34:46 <PythonNut> But cabal install does not list anything onder stream-fusion
11:35:30 <monochrom> PythonNut, you may need my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
11:35:45 <merijn> Any cmdargs users? My problem is the following, I want a "--with-foo=BAR" flag (I know how to do that), but if it's unspecified I want to default to a value from an IO action (I dunno how to run an IO action in relation to cmdargs) AND provide a --without-foo flag that stops this IO action from running. Any suggestions? The docs seem rather sparse
11:38:34 <PythonNut> Actually, that didn't seem to fix it.
11:38:36 <bennofs> merijn: maybe you could just return an IO action from cmdargs, and then run it after executing cmdargs? The --without-foo flag then just sets the IO action to return () or something similar
11:41:31 <merijn> bennofs: I think I'm stuck doing something ugly like "Maybe (Maybe FilePath)" :\
11:42:05 <monochrom> IO (Maybe FilePath)
11:42:22 <merijn> monochrom: I don't actually want a filepath
11:42:51 <monochrom> IO (Maybe (Maybe FilePath))
11:42:55 <merijn> monochrom: Basically, the option should set a filepath to read, if absent it should read from a default, if "--without" then it should not do anything
11:43:38 <merijn> I can think of a 10 different ways to do this, I just dunno how to tie them into cmdargs
11:43:57 <supki> data Read = Read FilePath | Default | No
11:43:58 <supki> ?
11:45:02 <merijn> supki: How does this help with my cmdargs issue?
11:45:20 <merijn> i.e. how do I get cmdargs to accept two different flags for the option which returns that
11:45:55 <merijn> Whether I define Read or use Maybe (Maybe FilePath) is all essentially identical
11:46:03 <merijn> That's not where I'm stuck :)
11:46:15 <Eduard_Munteanu> Maybe lazy IO?
11:47:15 <merijn> Right, I'll try struggling with the docs again
11:48:03 <monochrom> I did not even know that cmdargs or optparse-applicative or getopts were designed with the pair --with-x and --without-x in mind
11:48:15 <merijn> monochrom: They probably aren't
11:48:49 <merijn> monochrom: But I don't feel rewriting the option parsing of someone else program to add the functionality I want is very productive are going to help getting a patch accepted
11:49:01 <bennofs> Hmm, shouldn't Gen 0 be smaller than Gen 1 in GHC? But giving +RTS -S always shows about the same number for the column "Live bytes", regardless of the generation being displayed in the parentheses at the end of the line
11:49:25 <bennofs> Or is that number the total number of live bytes?
11:52:01 <bennofs> Also, can I tune the GC to avoid collection of the 2nd generation whenever possible?
11:52:40 <monochrom> oh! I think I know how to do that in optparse-applicative. it uses Alternative.
11:54:28 * bxc_ wonders how flakey using -V0 will make his HDBC-mysql using program be.
11:55:05 <enthropy> merijn: fitting that into cmdargs probably involves adding another named field in the data that the args get put into
11:55:47 <monochrom> for example, strOption (long "with-x" <> ...) <|> strOption (long "without-x" <> ...)
11:56:10 <augur_> kosmikus: can i just say, the ::^ and ::v notation is really perplexing for me
11:56:40 <augur_> kosmikus: ::^ feels like it should be check, but its synthesize, and vice versa for ::v
11:57:03 <enthropy>  data X = X { with_x :: String, without_x :: Bool }
11:58:25 <bennofs> Or alternatively, if I have enough memory available, can I tell GHC to just disable GC completely?
11:58:39 <PythonNut> Is it possible to use onboxed stream fusion?
11:58:55 <bennofs> PythonNut: what is onboxed?
11:58:56 <PythonNut> :s/on/un
11:59:00 <monochrom> enthropy, I refuse to use that data structure. it is broken.
11:59:01 <bennofs> ah :)
11:59:29 <monochrom> people do that in C and Java. that is fine, C and Java lack Maybe. this is Haskell, we do better.
12:00:18 <geekosaur> but can optparse be introspective enough to generate with and without options seeing a Maybe?
12:00:19 <enthropy> monochrom: yes. But optparse-applicative doesn't figure out for you that   myProgra --with-x=1 --without-x
12:00:33 <enthropy> is something to tell users that they are bad
12:00:41 <enthropy> or does it?
12:01:10 <bennofs> opt-parse-monad :)
12:01:32 <monochrom> I do not know. if it does not, I have yet another card to play, you will still not need the broken data structure
12:01:32 <bennofs> enthropy: maybe with the arrow interface?
12:01:53 <enthropy> dunno. The uu-parsinglib does something kind of like that
12:02:14 <augur_> kosmikus: is it possible to replace annotation of terms with annotation of vars in lambda?
12:02:34 <enthropy> but depending on what you write, it'll say "Got x but was expecting [variable, variable, variable, variable, variable, variable]"
12:03:11 <enthropy> which is pretty redundant
12:04:39 <merijn> enthropy: Sure, I just dunno how
12:05:24 <monochrom> (nullOption (long "with-x") *> nullOption (long "without-x") *> infoOption "contradiction" empty) <|> strOption (long "with-x" <> ...) <|> strOption (long "without-x" <> ...)
12:06:03 <rzpa> multithreading, this is a little to generally stated perhaps, but im quite new with multithreading and find using semaphores quite ugly and if you use it a little here and there it becomes hard to reason about and messy. Is it generally a good idea to centralize all synchronization to one place? thus doing all sync in one place -> easier to oversee and reason about and thus less error prone
12:06:04 <rzpa> and easier to change.
12:06:06 <monochrom> that is, <|> of 3 cases. case 1: if both are present, abort with message. case 2: if with-x is present. case 3: if without-x is present.
12:06:46 <augur_> kosmikus: aha, the paper answers the question for me. :)
12:07:13 <merijn> monochrom: Yes, but that requires some library using applicatives for option parsing
12:07:27 <enthropy> http://lpaste.net/1811045270427795456
12:07:33 <levi> rzpa: It's hard to give general answers to questions like that. Have you looked at Parallel and Concurrent Programming in Haskell?
12:07:46 <monochrom> that is a low requirement. optparse-applicative already exists.
12:07:53 <levi> rzpa: http://chimera.labs.oreilly.com/books/1230000000929
12:08:18 <merijn> monochrom: Except that I've already stated that I'm stuck with cmdargs as that is what existing code uses and I'm not going to reimplement all the option parsing
12:09:01 <monochrom> then consider my monologue as a monologue
12:11:25 <enthropy> monochrom: that does look better
12:13:12 <johnw> rzpa: in some cases, very much so
12:13:33 <johnw> in others, that imposes an additional maintenance burden that is unnecessary
12:20:52 <levi> Not to mention performance tradeoffs among various ways of doing things.
12:21:09 <levi> Which are not always obvious.
12:21:24 <xintron> Can I unset OverloadedStrings in ghci somehow?
12:21:39 <shachaf> The same way you set it. It's off by default.
12:21:42 <geekosaur> ":set +XOverloadedStrings"?
12:21:46 <enthropy> xintron: :set -XNoOverloadedStrings
12:21:47 <geekosaur> hm, no
12:21:51 <geekosaur> yeh that
12:21:54 <xintron> ah!
12:22:01 <shachaf> :set -X has tab completion
12:22:16 <xintron> Yeah, know that. Didn't know about the whole "No*" section though :)
12:22:30 <xintron> and -XOv<tab> didn't give what I was looking for
12:22:34 <xintron> So, thanks!
12:27:25 <peterhil> Hi! I want to output some audio from Haskell, and it's bindings expect ALUT to be found as a framework packaged dynamic library. So how do I compile it as a framework on Mac OS X Mavericks?
12:29:42 <peterhil> I mean, I try to use http://www.haskell.org/haskellwiki/ALUT. I remember having quite some trouble with Common Lisp bindings also, and maybe ended up using just OpenAL.
12:30:09 <avaritia> hey i'm trying to learn arrows, could someone explain to me why my implementation of
12:30:14 <avaritia> Kleisli arrow is not working? http://lpaste.net/8577799715955933184
12:31:12 <c_wraith> avaritia: your class is Category, not Arrow
12:31:13 <avaritia> it's even not compiling, and the reason why kinda challenges my mental abilities
12:31:36 <avaritia> c_wraith: ok but why it does not compile?
12:32:07 <avaritia> c_wraith: i mean the >>> operator for Kleisli seems to take the same arguments as the one for functions
12:32:20 <avaritia> c_wraith: and still in one case the compiler complains and in other it doesnt
12:32:28 <c_wraith> Oh, no, that's not category.  Too powerful.
12:33:14 <c_wraith> anyway, if you want advice on compile errors, include the error
12:34:21 <c_wraith> avaritia: anyway, the problem is that you're not rewrapping the result in the Kleisli wrapper.
12:34:25 <geekosaur> peterhil: https://developer.apple.com/library/mac/qa/qa1504/_index.html#//apple_ref/doc/uid/DTS10004191
12:34:41 <c_wraith> avaritia: if you'd included the error message, I would have solved that in about 1/4 of the time
12:35:55 <avaritia> c_wraith: thank you
12:36:29 <monochrom> that is not the end. (f >>> g) a = Kleisli (whatever) is still going to be wrong
12:36:50 <monochrom> it has to be: f >>> g = Kliesli (\a -> ...)
12:38:05 <avaritia> monochrom: thank you :)
12:45:00 <peterhil> geekosaur: Yes, I just found that also. And this: https://ghc.haskell.org/trac/ghc/ticket/2067
12:45:11 <peterhil> So, ay good suggestions on getting audio out?
12:45:31 <peterhil> Or getting the freealut C library to compile as a framework?
13:02:08 <johnw> b#fpco
13:02:10 <johnw> sorry
13:15:50 <pjdelport> Which version of LLVM is preferable as a GHC backend, 3.2 or 3.3?
13:26:03 <kardboardb> When I run "cabal configure" on a project, I get dependency version warnings like these: http://lpaste.net/100247
13:26:37 <kardboardb> But both fgl and yaml-light depend on "containers -any"... yet cabal seems to be picking different versions for them.
13:26:43 <kardboardb> Anyone know why?
13:30:43 <enthropy> kardboardb: did you check those exact versions of fgl/yaml-light?
13:30:56 <supki> kardboardb: do you have multiple containers versions installed?
13:32:00 <supki> kardboardb: you can check it with  ghc-pkg list containers
13:33:29 <supki> kardboardb: if a dependency of fgl is installed against containers-0.4.2.1 and a dependency of yaml-light is installed against containers-0.5.3.1, you'll see this error message
13:34:57 <enthropy> usually the message has a /installed in there
13:39:16 <kardboardb> enthropy: Those exact versions of the packages depend on "containers -any", so that's not it.
13:39:36 <kardboardb> supki: I have 0.4.2.1 and 0.5.3.1 installed.
13:40:07 <kardboardb> supki: None of fgl's dependencies (base, mtl, containers, array) are forcing it to go down to that version.
13:41:16 <johnw> kardboardb: try adding --constraint 'containers == 0.5.3.1' (or whichever one you want to build against), and seeing what error you get
13:42:29 <jle`> is anyone else worried that overloaded list literals will lead to more cryptic error messages for new users?  instead of saying the type is not a list, it'll say no instance for IsList Something.  but i guess it is not an enabled-by-default thing so newcomers probably wouldn't use it
13:42:32 <kardboardb> johnw: Got back the same thing. Looks like it ignored my constraint?
13:42:58 <johnw> try installing fgl again with just that constraint
13:43:02 <jrmithdobbs> jle`: those two messages seem fairly equivilant any how
13:43:22 <kardboardb> johnw: Ah, okay. Trying now.
13:43:33 <johnw> kardboardb: btw, I keep constraints like this in my ~/.cabal/config, when I realize I never want an older version of a given package
13:43:40 <johnw> johnw
13:44:27 <jle`> also i would like an extension where if you add an -s after a type, it automatically is a type synonym for a list of that type
13:44:33 <kardboardb> johnw: That's a good idea!
13:44:39 <jle`> type Integers = [Integer]
13:44:50 <Iceland_jack> jle`: haha..
13:44:55 <Iceland_jack> what about things with irregular plurals? :)
13:45:05 <Iceland_jack> I feel it should account for those
13:45:12 <jle`> you can have some kind of localization thing built into the compiler
13:45:13 <Iceland_jack>     type Indices = [Index]
13:45:16 <Iceland_jack> :) great
13:45:18 <jle`> actually it could just be a template haskell thing
13:45:26 <jle`> there are a lot of localization libraries that can do that kind of stuff
13:45:27 <jrmithdobbs> jle`: that smells like rails
13:45:34 <jrmithdobbs> and i mean that in the worst possible way, to be clear.
13:45:34 <jle`> jrmithdobbs: was going to reference it actually haha
13:45:42 * Iceland_jack . o O ( actually you could just write ‘type <plural> = [<singular>] )
13:45:47 <Iceland_jack> ’
13:45:56 <jle`> but for everything?
13:45:57 <Iceland_jack> I'm not going to lie though, I've thought of this very thing myself :)
13:46:09 <jle`> oh
13:46:09 <Iceland_jack> jle`: How many things do you really need that for
13:46:27 <jle`> i figured that if it was a real feature, i would use it a lot
13:46:35 <jle`> it'd turn everthing into plural :)
13:46:50 <jle`> :D
13:46:51 <kardboardb> johnw: That worked! Thank you.
13:46:56 <antithesis> Should I learn Scheme or Haskell as my first programming language?
13:46:57 <Iceland_jack> How would it work with exports jle`?
13:47:04 <jrmithdobbs> jle`: maybe in db middleware but seemslike extra convolution for the sake of convolution to do it for everything
13:47:07 <Iceland_jack> antithesis: There is no right answer to that
13:47:22 <antithesis> But is there a wrong one?
13:47:34 <jrmithdobbs> antithesis: yes, anything with the acronym basic in it
13:47:50 <jle`> basic was my first language :|
13:48:03 <jrmithdobbs> and you still probably agree with the sentiment
13:48:04 <jrmithdobbs> ;p
13:48:12 <Iceland_jack> jle`: If I have a module that defines “data Bit = O | I” would the compiler automatically export “type Bits = [Bit]”?
13:48:34 <jle`> Iceland_jack: it would be less like a conversion and more like syntactical sugar
13:48:43 <jle`> as in, Bits would be desugared as [Bit]
13:48:53 <Iceland_jack> Okay, so it would only happen if Bits is used within the program?
13:48:59 <jle`> yes
13:49:01 <kristof> What
13:49:05 <jrmithdobbs> jle`: what would happen when you have data Token a = a Tokens;
13:49:08 <kristof> GHC recognizes... plural type synonyms?
13:49:34 <Iceland_jack> and if Bits is not already defined?
13:49:47 <jrmithdobbs> jle`: and what about data Token a = a [Tokens]
13:49:49 <jle`> if Bits is not already defined then you have no problem
13:49:52 <triliyn> kristof: no, they're just discussing hypothetical functionality
13:49:55 <Iceland_jack> kristof: Absolutely not :)
13:50:04 <antithesis> "Haskell is questionable as a first language, though, just because it's so big that it takes years to really get and it's so heavily based in type theory."
13:50:07 <antithesis> Is this true?
13:50:07 <jle`> if Bits is already defined then...compiler warning :D  and the defined one is used.
13:50:19 <jle`> i...don't think Haskell is too heavily based in type theory
13:50:22 <jle`> and i don't think it's really that big
13:50:26 <kristof> triliyn: well that's silly
13:50:27 <Iceland_jack> antithesis: It's not heavily based on type theory
13:50:48 <jrmithdobbs> learning haskell seems to be more about learning which parts of old papers to ignore than anything
13:50:49 <jle`> whoever wrote that probably doesn't use haskell i'd imagine
13:50:50 <Iceland_jack> Unless you have a strange definition of being ‘based’ on, the type is system is
13:51:02 <antithesis> I want to learn a functional programming language first because I hear it makes you a good programmer, but I'm just not sure if Haskell is as newb-friendly as Scheme is
13:51:07 <kristof> triliyn: For instance, we wouldn't want type Brasss = [Brass]
13:51:17 <Iceland_jack> kristof: Already been solved ;)
13:51:19 <jle`> no that would be Brasses
13:51:26 <jle`> due to localization stuff
13:51:34 <Iceland_jack> Plurals are probably not injective
13:51:35 <jrmithdobbs> antithesis: if you have zero points of reference i think erlang or forth would be fun starting points
13:51:39 <jrmithdobbs> antithesis: but i'm a bit demented
13:51:51 <Iceland_jack> so you could have two singular nouns sharing a plural
13:51:51 <Rembane> antithesis: Try reading through LYAH and see what you think.
13:51:51 <triliyn> type Brasss = [[[Bra]]]
13:51:56 <Rembane> antithesis: And return here with questions.
13:52:11 <antithesis> Well, I've done a little programming in basic as a kid (sorry) and I write bash scripts now and then
13:52:18 <antithesis> One of them is actually in the AUR lol
13:52:19 <Iceland_jack> also
13:52:19 <Iceland_jack>     type Octopodes = [Octopus]
13:52:19 <Iceland_jack> and using
13:52:19 <Iceland_jack>     Octopi
13:52:22 <Iceland_jack> recursively deletes your project
13:52:31 <jle`> and your home directory too
13:52:32 <Rembane> antithesis: Then I think you will find Haskell quite fun.
13:52:33 <antithesis> But it's all very simple stuff. I wouldn't call myself a 'programmer'
13:52:43 <Iceland_jack> antithesis: How about giving you a short excerpt of Haskell code?
13:52:43 <jrmithdobbs> antithesis: then something that isn't haskell will probably be easier to start with ... sh is actually a lot like lisp/scheme in many many ways
13:52:57 <jle`> antithesis: just read through LYAH, it's a quick read
13:53:00 <jle`> no harm.
13:53:06 <Iceland_jack> antithesis:
13:53:06 <Iceland_jack>     length :: [a] -> Int
13:53:06 <Iceland_jack>     length []     = 0
13:53:09 <Iceland_jack>     length (x:xs) = 1 + length xs
13:53:17 <jle`> it's not like picking one or the other will severely damage your ability to learn how to program in the future
13:53:17 <Iceland_jack> Just to give you a feel for the language
13:53:40 <yogurt_truck> antithesis: there's really no robust argument against haskell for learning. there's plenty of FUD out there, but the fact is that with the right resources and approach, it's as easy to learn as any other language, as long as you leave your prejudices at the door. I'd say just go get started with LYAH and if after sometime you find it to difficult, then come here and ask for help, and finally if you're still stuck, then check out s
13:53:41 <yogurt_truck> omething else
13:53:54 <jle`> unless you believe this guy http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
13:54:02 <jle`> (it's a joke post btw)
13:55:25 <tpsinnem> antithesis: i'd argue that if you want to write code for other people to use, you'll eventually want to use a language with static types anyhow -- i don't see any issue with learning that from the start, and http://learnyouahaskell.com/ is a very nice free intro
13:56:32 <Iceland_jack> Of course the problem with asking people on #haskell whether to use Haskell or $LANG is problematic :) especially when $LANG is dynamically typed: you won't find very many proponents of dynamic typing here
13:56:36 <jle`> the only thing that might be worrisome is that starting with haskell doesn't give you a strong background from which to conquer the very common mutable data structures found in many real world programming contexts.  but that's okay because we have better data structures :)
13:56:40 <antithesis> tpsinnem why can't I write dynamic code for others to use?
13:56:40 <Twey> antithesis: I'd probably say types make learning programming easier.  Even in languages without (interesting) types, you usually want to be thinking about what the type of the result will be.  Learning with a language that makes that explicit is probably a good idea.
13:56:55 <Iceland_jack> antithesis: you can
13:57:03 <jrmithdobbs> Iceland_jack: hey i straight up said if he's familiar and comfortable with sh that lisp/scheme are the natural next step ;p
13:57:16 <jle`> if you learned languages with dynamic typing then you probably end up annoytating the types yourself in comments or in your head
13:57:20 <Twey> Iceland_jack: Well, http://ro-che.info/ccc/17
13:57:23 <Iceland_jack> jle`: Very true
13:57:31 <tpsinnem> antithesis: static typechecking makes it easier to catch errors before your users do
13:57:31 <jle`> you reason with them in your head and hold them all in the air
13:57:38 <jle`> better to just let the compiler handle it for you automatically
13:57:40 <Iceland_jack> Twey: That was written by a Haskeller though ;Þ
13:57:48 <jrmithdobbs> or you abuse things like #kind_of?
13:58:08 <jle`> remember that types in haskell are inferred so you never have to manually annotate them if you don't feel like it :)  but the compiler magically knows and keeps track of them for you
13:58:29 <jle`> it's actually very very big cognitive burden being lifted off of the programmer, if you have ever used a dynamic language like ruby or python
13:58:42 <jle`> also the big burden being lifted off of forced explicit typing, which is just a nuisance.
13:58:43 <Twey> Iceland_jack: It's true, though
13:58:53 <yogurt_truck> Iceland_jack: but arguments should be evaluated based on their content alone, not on the person who's making them.
13:59:06 <Iceland_jack> yogurt_truck: Yes, and there is no content in that comic :)
13:59:17 <Twey> Iceland_jack: People who actually know what types are *and* support dynamic typing are few and far between (although pretty interesting to talk to when you find them)
13:59:41 <yogurt_truck> Twey: who are these people?
14:00:13 <jrmithdobbs> Twey: i really want to know what came of that stuff what's his face was talking about re: demarking typed/untyped abis (or something like that), something about blaming etc
14:00:20 <Twey> yogurt_truck: Good question :þ  I've run into some interesting comments on LtU, though I can't remember who wrote them
14:00:22 <yogurt_truck> Twey: would you say erik meijer knows what types are? because I saw him in a video talking about types, and my head almost exploded from all his fallacies, etc.
14:00:39 <jrmithdobbs> Twey: seemed interesting but haven't seen follow up
14:00:46 <Twey> yogurt_truck: No idea, never seen anything by him
14:00:58 <Twey> jrmithdobbs: I don't think I've seen this
14:01:00 <Twey> jrmithdobbs: Link?
14:01:01 <jrmithdobbs> yogurt_truck: yes that's who i'm talking about, lol
14:01:05 <Twey> Oh, right.
14:01:52 <yogurt_truck> http://research.microsoft.com/apps/video/dl.aspx?id=150045
14:02:01 <Twey> Thanks
14:02:14 <Twey> Oh, that
14:02:30 <jrmithdobbs> ya has anything concrete actually come of that?
14:02:39 <Twey> Ha, I was watching that yesterday but got interrupted halfway through and forgot about it; thanks for reminding me
14:03:01 <jle`> is it fair to say that for associative operations, foldr is preferred over foldl?
14:03:11 <jrmithdobbs> i'm thinking about trying to implement something based on that blame concept using the aeson types as the "generics"
14:03:25 <jrmithdobbs> instead of defining it within the confines of a new language
14:03:30 <johnw> jle`: I wouldn't say it's about associativity
14:03:55 <johnw> jle`: if your function is not strict in the second argument, then foldr preferable
14:04:02 <johnw> otherwise, foldl'
14:04:12 <jle`> ah
14:04:49 <johnw> and if you always need to know the "full answer", then foldl'
14:05:14 <jle`> thanks
14:05:22 <jle`> what about mapAccumR and mapAccumL ?
14:06:34 <johnw> not sure, I don't use those
14:07:52 <jle`> yeah, me neither.
14:07:55 <jle`> oh well.
14:08:45 <jle`> thanks
14:10:12 * hackagebot tianbar 0.2.2.1 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.2.2.1 (AlexeyKotlyarov)
14:25:14 * hackagebot lens 4.0.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.4 (EdwardKmett)
14:35:15 * hackagebot directed-cubical 0.1.1.0 - Finite Directed Cubical Complexes and associated algorithms  http://hackage.haskell.org/package/directed-cubical-0.1.1.0 (mmisamore)
15:00:16 * mm_freak moves from OpenGL to OpenGLRaw
15:00:28 <bitemyapp> mmb: that bad?
15:01:19 <mm_freak> bitemyapp: ever tried to send a matrix into a uniform variable? =)
15:03:48 <mm_freak> i've already transposed my M44 (from the linear package), because OpenGL wants a matrix of columns, and constructed a storable vector to feed into uniformv
15:03:54 <mm_freak> turns out that it's impossible
15:04:57 <mm_freak> because a UniformComponent instance for GLfloat is not enough…  you need to actually have the data wrapped in a Vertex* or something
15:05:07 <bitemyapp> mm_freak: I'm dealing with dumber problems than that, mostly to do with graphing/plotting libraries.
15:05:15 <bitemyapp> documentation is apparently very expensive to produce :|
15:06:03 <mm_freak> bitemyapp: what's your impression of Chart?
15:06:24 <bitemyapp> mm_freak: I'm sure it works for people that understand it, but it needs freakin' documentation and examples that work.
15:06:31 <bitemyapp> mm_freak: also cairo is agonizing to install.
15:06:36 <mm_freak> ah
15:06:55 <mm_freak> there is diagrams, which is very well documented, but not by itself a graphing/plotting library
15:07:10 <bitemyapp> it's usually chart + diagrams
15:07:18 <mm_freak> ah
15:07:40 <mm_freak> i've only done a few simple experiments with diagrams =)
15:07:52 <bitemyapp> the problem is the moment you just want to plot something, you have to use chart which sucks.
15:08:05 <bitemyapp> but even a goodly amount of diagrams example code is broken
15:08:08 <bitemyapp> for plotting stuff
15:09:27 <mm_freak> that's the point when you realize that you want to write a custom solution =)
15:11:04 <bitemyapp> mm_freak: no :|
15:11:18 <bitemyapp> mm_freak: matplotlib and ggplot work fine in their respective environments, I just want roughly those libraries in Haskell.
15:12:10 <pavonia> Btw, do you know a drawing library where you can set individual pixels? I've tried cairo with mini-rectangles but it's incredibly slow if you draw many pixels that way
15:12:29 <mm_freak> pavonia: someone has recommended gloss-raster or something like that
15:12:34 <mm_freak> haven't tried it myself yet
15:12:52 <mm_freak> alternative you can always use SDL or set up a GTK window with a canvas
15:14:39 <mm_freak> pavonia: gloss-raster likely does OpenGL with textures…  to make this efficient, you may have to get down to OpenGL level
15:14:55 <mornfall> pushing pixels is almost never efficient
15:14:58 <mornfall> CPUs suck at that
15:15:22 <mm_freak> pushing /lots/ of pixels actually is efficient enough
15:16:09 <pavonia> Hhm, type Point = (Float, Float), is that really suited for drawing single pixels?
15:16:32 <mm_freak> pavonia: what coordinate system do you want?
15:16:34 <khyperia> Hmm... I'm making an IRC bot for another chat, how easy is it to rip out the stuff I don't want out of lambdabot and add my own stuff?
15:16:57 <mm_freak> khyperia: even connecting to an IRC server is a plugin in lambdabot ;)
15:17:11 <mornfall> also, it's probably the simplest part of the thing
15:18:30 <ion> mm_freak: Btw, what’s the meaning and etymology of your nick? :-)
15:18:38 <Iceland_jack> monster magic!
15:18:42 <pavonia> mm_freak: (Int, Int) ideally
15:19:03 <Iceland_jack> pavonia: Are you concerned about space or efficiency?
15:19:16 <Iceland_jack> You can make them strict and unpack them
15:19:20 <mm_freak> pavonia: that didn't really answer my question…  i would use a coordinate system where (-1, -1) corresponds to the lower left corner of my screen and (1, 1) corresponds to upper right
15:19:25 <khyperia> are there any docs on running lambdabot and adding plugins, or not?
15:19:35 <mm_freak> pavonia: and i would use V3 Float, i.e. 3-dimensional homogenous coordinates
15:19:43 <mm_freak> the V3 type is in the 'linear' package
15:20:15 <pavonia> Iceland_jack: More about speed, not so much about memory
15:20:39 <mm_freak> pavonia: then use V2 or V3 from 'linear'
15:20:57 <pavonia> mm_freak: I'd prefer something like a canvas of size (w, h) :: (Int, Int)
15:21:01 <mm_freak> use V3 if you intend to apply matrix transformations to your vectors, otherwise V2 is mostly sufficient
15:21:23 <mm_freak> pavonia: and i'd prefer V2 w h :: V2 Int, if i'd really choose to use Int ;)
15:21:36 <mm_freak> (which i wouldn't)
15:21:38 <ion> Yeah, linear is nice.
15:22:06 <mm_freak> pavonia: what is your application?
15:22:33 <carter> khyperia: the haddocks? :)
15:22:35 <pavonia> mm_freak: I don't really understand, if I have said vectors, how to get the graphics then?
15:22:59 <pavonia> mm_freak: Implementing Bresehham an such
15:23:10 <khyperia> I'll try, but it looks like a lot of API stuff and not a lot of running it. Then again, I didn't check the main module :P
15:23:19 <pavonia> *Bresenham and
15:23:46 <mm_freak> pavonia: well, it depends on how low level you want to get…  SDL gives you a Ptr into the video buffer, which is about the lowest level you can have
15:23:52 <enthropy> khyperia: the easiest may be to take a plugin that does similar things, and just replace the guts
15:24:49 <mm_freak> pavonia: i would then use said (-1, -1) - (1, 1) coordinate system with V3 vectors…  then i would use a matrix to transform between that and the window coordinate system…  finally i would perform rasterizing
15:24:51 <khyperia> I'm more looking for how to create a plugin, but it looks like this page - https://github.com/mokus0/lambdabot/tree/master/lambdabot-core - explains it pretty well
15:24:54 <pavonia> mm_freak: I want to get the graphics on a Gtk canvas/display it in a Gtk application
15:25:45 <mm_freak> pavonia: that's going to be horribly inefficient, if you want to implement things like bresenham yourself
15:26:39 <pavonia> But there must be a way to do it efficiently. Maybe I could manipulate a pixbuf directly?
15:28:26 <mm_freak> pavonia: you can set up your own framebuffer by using, for example, the 'vector' library
15:28:35 <mm_freak> use Data.Vector.Storable
15:29:00 <mm_freak> then you can turn that into a PixBuf
15:30:52 <mm_freak> especially for drawing and postprocessing you may want to look into store comonads
15:31:14 <mm_freak> for the rasterizing step that is
15:31:44 <pavonia> mm_freak: Do you know how to do the conversion Vector -> PixBuf?
15:32:27 <mm_freak> a storable vector has an associated Ptr…  unsafeWith gives you that pointer…  keep in mind not to write to that pointer
15:32:47 <mm_freak> in other words, perform all drawing operations in vector land
15:34:16 <pavonia> So it's basically casting Vector to PixBuf?
15:37:17 <mm_freak> pavonia: no, there is no casting and no conversion…  it's marshalling
15:37:40 <mm_freak> you get the Ptr to the underlying array and use it as a source to copy from
15:37:46 <mm_freak> it's a Foreign-style operation
15:38:08 <PythonNut_> @pl \xs = foldl (\x y -> 10*x + y) 0 xs
15:38:09 <lambdabot> (line 1, column 5):
15:38:09 <lambdabot> unexpected "="
15:38:09 <lambdabot> expecting operator, pattern or "->"
15:38:14 <PythonNut_> @pl \xs -> foldl (\x y -> 10*x + y) 0 xs
15:38:15 <lambdabot> foldl ((+) . (10 *)) 0
15:38:33 <mm_freak> PythonNut_: foldl (\x y -> 10*x + y) 0
15:38:45 <ion> foldl' rather
15:39:06 <mm_freak> and yeah, foldl is wrong 99.9999999% of the time
15:39:12 <PythonNut_> Just checking the pattern, don't really care about the actuall functions
15:39:14 <PythonNut_> :)
15:39:47 <pavonia> mm_freak: I've never done anything with Ptr. The idea is to have an Vector that internal structure is identical to one of a PixBuf, and then just treating the Vector as a PixBuf, no?
15:39:57 <mm_freak> pavonia: have you done C/C++?
15:40:10 <pavonia> Yes, years ago :)
15:40:41 <mm_freak> haskell's 'Ptr a' corresponds to C's 'a *' about as directly as it can =)
15:40:55 <mm_freak> the Storable class gives you peek and poke
15:41:29 <mm_freak> a storable vector is a vector that has an associated underlying array in memory that you can get a Ptr into
15:42:50 <mm_freak> so you get the good old C arrays, but with a nice vector interface with all the usual advantages like stream fusion =)
15:43:53 <pavonia> But isn't that just like casting the array into a PixBuf object?
15:44:36 <mm_freak> this operation is called marshalling…  you're not casting to another haskell type, but getting a pointer to the underlying memory
15:45:02 <mm_freak> you can then pass this pointer to GTK+ to create a pixmap from
15:45:17 <mm_freak> or perhaps even blit the array directly into a drawable
15:45:56 <mm_freak> but i don't know how to do this…  i have no experience with GTK
15:46:51 <pavonia> mm_freak: Okay, I think I get the idea. Thanks for the help! :)
15:47:05 <shiona> I have an assignment to make something of the sort "maximumBy x . filter y" using the writer monad. I have no idea how to make any use of it. Am I stupid or is it the assignment?
15:48:33 <Twey> shiona: Mm, you'll need State (or equivalent) for maximum(By)
15:48:49 <Twey> You can certainly do filter with Writer, though
15:49:00 <shiona> true
15:49:29 <shiona> so far that's my thoughts exactly
15:49:55 <PythonNut> @pl \xs b -> foldl (\x y -> b*x + y) 0 xs
15:49:56 <lambdabot> flip (flip foldl 0 . ((+) .) . (*))
15:50:05 <PythonNut> @pl \b xs-> foldl (\x y -> b*x + y) 0 xs
15:50:05 <lambdabot> flip foldl 0 . ((+) .) . (*)
15:50:45 <Twey> (`foldl` 0) . fmap (+) . (*)
15:53:25 <ion> pythonnut: I’m not sure what you’re trying to do. @pl consistently makes those expressions much worse.
15:54:02 <Iceland_jack> Just one of those days when your code is too readable :)
15:56:16 <Twey> That one's not too bad
15:57:17 <ion> twey: It is. :-P
15:57:52 <Twey> ion: It's not — it's a nice simple composition pipeline, easy to read from right to left
15:58:15 <Twey> Those are the good kinds of point-free expressions :þ
15:59:26 <PythonNut> Sometims @pl spits out something beautiful I want to be there when it does. :)
15:59:45 * Clint chortles.
15:59:48 <Iceland_jack> We should make a ‘Best of’ of @pl
15:59:59 <Iceland_jack> And a ‘Worst of’…
16:00:11 <johnw> let's have a context for the longest @pl output from the shortest input
16:00:14 <johnw> contest
16:00:23 <Iceland_jack> I like it!
16:00:24 <Twey> I thought that was already solved
16:00:27 <Ralith> me too
16:00:38 <PythonNut> They already have an interesting list of conbinators. I have a hard time reading them though.
16:00:41 <Twey> @pl \a b c d → (d, c, b, a)
16:00:41 <lambdabot> (line 1, column 11):
16:00:41 <lambdabot> unexpected "\134"
16:00:41 <lambdabot> expecting pattern or "->"
16:00:45 <Twey> @pl \a b c d -> (d, c, b, a)
16:00:46 <lambdabot> flip (flip . (flip .) . flip (flip . flip (,,,)))
16:00:58 <ion> @pl \a b c d e f g -> c a b b a g e
16:00:58 <lambdabot> (((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id)
16:01:07 <Twey> Heheh
16:01:59 <PythonNut> @pl \a b c d e -> e+d-c*a^b
16:01:59 <lambdabot> (((flip (flip . ((-) .) . (+)) .) . (*)) .) . (^)
16:02:02 <Twey> @pl \a b c d e f -> d e a d b e e f
16:02:02 <lambdabot> (const .) . flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip
16:02:05 <ion> pythonnut: Re: your PM, you should avoid fold*1.
16:02:31 <PythonNut> I know, I should be using foldl1' right?
16:02:39 <ion> No, avoid that one, too.
16:02:40 <Twey> @pl \a b c d e f -> c a f e b a b e
16:02:42 <lambdabot> ((const .) .) . flip flip id . ((flip . (liftM2 flip .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id)
16:02:48 <ion> All the “1” variants.
16:02:49 <PythonNut> Really? Why>
16:02:56 <Twey> PythonNut: Because they're partial
16:02:58 <ion> It will crash if applied to an empty list.
16:03:20 <PythonNut> What if I can guarantee that the list isn't empty?
16:03:36 <PythonNut> Is that still bad form?
16:03:37 <ion> Then use a data type that guarantees that using the type system.
16:03:52 <Twey> PythonNut: Then you should be using a special fold for your non-empty–list data type :þ
16:04:03 <PythonNut> Ahh. I see Haskell == Theorem Proving System
16:04:09 <Twey> Hardly
16:04:17 <ion> Or just use non-“1” fold and do the right thing for empty lists anyway.
16:04:24 <Twey> type NonEmptyList a = (a, [a])
16:04:47 <Clint> http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html#t:NonEmpty
16:04:59 <Iceland_jack> Twey: That doesn't even require type-level naturals!
16:05:45 <Twey> Indeed — trivial!
16:05:48 <PythonNut> I meant, the way Haskell is written is to always be well defined and as strongly typed as possible (and extra information that can should be contained in the type system). So the compiler can catch it when you don't.
16:05:59 <Twey> PythonNut: Right
16:06:14 <PythonNut> Which is awesome.
16:06:17 <Twey> If you have an invariant, it wants be in the type system
16:06:23 <PythonNut> Coming from a math background like me
16:06:38 <Iceland_jack> > head [] :: a -- help me types!
16:06:39 <Twey> Whether it's worthwhile to invest the time and complexity to encode it is another matter, of course, but this one's pretty trivial
16:06:40 <lambdabot>  *Exception: Prelude.head: empty list
16:07:17 <PythonNut> Speaking of which, I parse commandline arguments by getting the head of getArgs
16:07:42 <PythonNut> And I append a default list to ensure that it's no empty
16:07:54 <PythonNut> Is there any better way?
16:08:07 <Clint> yes, parse the arguments properly
16:08:08 <Twey> PythonNut: I usually define a function: run [arg1, arg2, arg3] = …; run _ = printUsage;
16:08:25 <Iceland_jack> PythonNut: Are you looking for Maybe?
16:08:25 <Iceland_jack> @src Maybe
16:08:25 <lambdabot> data Maybe a = Nothing | Just a
16:08:30 <Twey> But that's just a quick hack for small programs with simple argument schemes; you should use a proper argument parser in general, indeed
16:08:56 <ion> I’m not sure Maybe applies here.
16:09:28 <PythonNut> How is that done. Everywhere I've looked I've seen getArgs used
16:09:37 <ion> With listToMaybe you’ll still have the same problem of having to handle two cases.
16:09:40 <PythonNut> And the concept of default arguments is never covred.
16:09:59 <Twey> PythonNut: Use something like http://hackage.haskell.org/package/console-program or whatever's cool these days
16:10:37 <shiona> I have Control.Monad.State in monads-tf-0.1.0.1 and mtl-2.1.2. Ideas which/what to remove or what?
16:10:41 <PythonNut> Oh... parsec. I suppose I should learn that too.
16:11:26 <Clint> PythonNut: optparse-applicative is popular here
16:11:38 <Clint> and so is cmdargs to a lesser extent
16:12:16 <PythonNut> So I basically need to install a library?
16:13:56 <PythonNut> Sorry, I suppose libraries aren't that bad in Haskell (where GHC isn't required at runtime), but in Python every library you use needs to be present on every target system ==> major headache. I can't get over the feeling. :(
16:15:20 <Twey> PythonNut: Haskell has cabal-install, Python has pip; you should never be reinventing the wheel because you don't want to install libraries.  Worry about deployment later.
16:15:46 <Iceland_jack> PythonNut: You have some fear of libraries
16:15:48 <Twey> (or better, don't worry about it and let the user's package manager do its job)
16:16:38 <PythonNut> No, but in python every person who runs the code also needs to pip install whatever packages I use. With Haskell, It's all bundled in the executable, so it's completely painless.
16:17:01 <clintm> It's almost like it's a self-contained program!
16:17:03 <clintm> :)
16:17:11 <PythonNut> Sorry, only beeen doing Haskell for about a day. Still reeling from all the new concepts.
16:17:17 <Twey> PythonNut: That's not a good way of doing things, since your executable ends up being huge.  Better to use dynamic linking.
16:18:14 <PythonNut> Doesn't that destroy portability?
16:18:24 <Twey> PythonNut: No
16:18:39 <PythonNut> How is that possible?
16:18:47 <clintm> Since 7.8.1 isn't released yet (err, right?) I'm using 7.6.3... Does anyone know what branch of the cabal repo I should expect to be able to build and use?  I don't think I've tried them all, but I think it's close.
16:18:57 <Cale> Well, you have to include the dynamically linked libraries with your binary then
16:18:57 <Twey> PythonNut: Python also has frozen packages, but the same caveat applies.  The dependencies should be installed when the user installs the package: if they pip install it then it should get all its dependencies via pip; if they cabal-install it they should get all its dependencies via cabal-install; if they install it via their system's package manager then they should get all its dependencies via that
16:19:11 <Cale> I honestly don't see much advantage in having small binaries
16:19:39 <PythonNut> As long as it's not excessive, right?
16:19:41 <Cale> The difference might be a couple orders of magnitude, but it's hard to end up with an executable of a nontrivial size
16:19:44 <Twey> PythonNut: It's not up to you to manage your users' dependency system
16:20:53 <Twey> Cale: Depends a lot on the libraries.  If you're bundling something like Qt or GTK with every library, it quickly gets inconvenient.
16:21:08 <PythonNut> But GTK+ I can see being linked.
16:21:15 <Twey> Cale: But it's also just horribly inelegant to have a couple of hundred copies of a commonly-used library
16:21:42 <PythonNut> Something small like a command line parser I cannot. It can't be very big, can it?
16:21:55 <Twey> PythonNut: There are perfectly good tools in place to manage this problem.  Let them do their job and stop worrying about it.
16:21:56 <Cale> PythonNut: No, it generally won't be large
16:22:12 <Clint> and you can't share the ram
16:22:23 <Twey> Oh, yeah, that's quite important too
16:22:40 <Cale> I think until Haskell actually takes over the world, it's a bit silly to worry about dynamically linking libraries
16:22:55 <Twey> Cale: It's sillier to worry about *not* dynamically linking libraries
16:22:56 <Cale> If *everything* on your system was written in Haskell, then sure.
16:23:04 <Twey> Just let the compiler do its thing
16:23:36 <johnw>  1G executables have a certain gravitas.  They *must* be doing something important
16:23:45 <Cale> But until that point, it's more convenient to statically link everything and not have any kind of worry about dependencies.
16:24:05 <Twey> Cale: You don't have any kind of worry anyway.  The package managers will take care of it.
16:24:14 <Twey> That's what they're for.
16:24:41 <Twey> johnw: And 12 GB executables must be doing something a dozen times as important?
16:24:42 <Cale> Twey: Most of the Haskell libraries you'd want to use won't be in distributions' package managers
16:24:53 <Twey> Cale: They're on Hackage
16:24:57 <PythonNut> Therefore Visual Studio is the greatest program of them all!
16:25:15 <Clint> 98% of the ones i want to use are
16:25:39 <Cale> Sure, if you're going to recompile the program on every system where you run it, then you don't have to worry about the difference between dynamic and statically linking the libraries.
16:25:50 <Twey> Cale: Everyone knows that installing Hackage packages via apt is asking for trouble, anyway :þ
16:26:09 <Clint> i don't
16:26:17 <Twey> Clint: It's asking for trouble.
16:26:24 <clintm> totally asking for trouble
16:26:25 <Clint> i have 0 non-.deb haskell libraries installed
16:26:28 <Cale> But if the point is to produce a binary which you send to some other machine to run, static linking can save you a bit of trouble.
16:26:36 <clintm> hehe
16:26:57 <PythonNut> Which is what I will be doing.
16:27:25 <Twey> Eventually, maybe.  It's a deployment concern (‘how do I get this program to run on that system?’) not a design concern (‘I won't use this library in case I can't get it to work on that system’).
16:27:40 <Cale> Typically, you'll end up with binaries which are tens of megabytes at the largest, or maybe a couple hundred if you really have a lot of dependencies, but that's a trivial amount of space in this day and age.
16:28:29 <Twey> Cale: Then this happens: http://en.wikipedia.org/wiki/Side-by-side_assembly
16:28:41 <Twey> (and it quickly becomes significant :þ)
16:29:05 <clintm> just add another side or two
16:31:26 <S11001001> Twey, PythonNut: You can also significantly reduce your binary size without mucking with dynamic linking by using split-objs, at the cost of increased compile time.
16:32:11 <S11001001> You need to clean out and rebuild your libraries with split-objs too for any real benefit; there's a cabal option to turn it on globally when building stuff.
16:34:53 <Cale> As a concrete example, skedge.me's backend (which uses the Snap web framework and has around 65 direct dependencies) statically linked is ~80 MB.
16:36:04 <S11001001> Cale: and that is without split-objs right?
16:36:32 <Cale> yeah
16:36:51 <PythonNut> How big is warp? I imagine it uses libraries when it can.
16:38:50 <mm_freak> in 'linear', is there an easier way from V2 x y to V3 x y 1?
16:39:05 <mm_freak> easier than \(V2 x y) -> V3 x y 1
16:39:06 <mm_freak> that is =)
16:39:33 <mm_freak> similarly i need:  \(V3 x y w) -> V2 (x/w) (y/w)
16:44:12 <Twey> mm_freak: No T_T
16:44:42 <mm_freak> hmm, ok
16:44:59 <Twey> mm_freak: At least, I never found one and there's code doing it manually in the package
16:50:39 <mm_freak> Twey: thanks for looking
16:51:38 <mm_freak> Linear.Matrix seems mostly written for 3D stuff
16:51:47 <mm_freak> even 'translation' is specialized to 3D
16:52:14 <no-n> can you not use the type keyword on types of functions? I get Malformed head of type or class declaration.
16:52:34 <mm_freak> no-n: could you show your code?
16:52:48 <no-n> give me a moment
16:52:57 <mm_freak> if it's one line, just paste it here =)
16:53:03 <no-n> it's not
16:56:21 <no-n> mm_freak http://lpaste.net/6437207935687852032
16:56:59 <no-n> oh, derp
16:57:02 <Iceland_jack> no-n: You probably want to flip CommandFunction aroudn
16:57:03 <no-n> i've got i back to front
16:57:03 <Iceland_jack> *around
16:57:07 <no-n> yeah
16:57:08 <no-n> lol
16:57:14 <mm_freak> hehe
16:57:32 <Iceland_jack> type <a> = <b> is not commutative (sadly?) :)
16:57:46 <no-n> hehe
16:58:41 <FreeFull> Iceland_jack: Yeah, you can't write   type Int = Meow    and have it work
16:58:50 <FreeFull> This isn't Prolog =P
16:59:12 <Iceland_jack> Well maybe it should! /s
16:59:56 <no-n> it should be one way to prevent confusion
16:59:58 <mm_freak> Iceland_jack: it is commutative in principle, which is why when you flip the two, you can just flip again =P
17:00:21 <Iceland_jack> The best kind of commutativity :) involuted commutativity
17:01:42 <mm_freak> hehe
17:01:50 <mm_freak> of course by that standard even 'replicate' is commutative =P
17:02:06 <Iceland_jack> Yes, by which I mean not commutative at all :)
17:10:00 <cdk_> does anyone use ghcmod/hdevtools and feel like commenting on their advantages/disadvantages vs. each other?
17:10:10 <johnw> ghc-mod is slower
17:10:15 <johnw> hdevtools is faster
17:10:16 <johnw> i like
17:10:32 <Twey> There's an alternative to ghc-mod?
17:10:33 * hackagebot tianbar 0.3.0.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.3.0.0 (AlexeyKotlyarov)
17:10:44 <cdk_> Twey: I just stumbled on it myself, hdevtools
17:10:51 <Twey> Interesting
17:10:59 <johnw> I've only used hdevtools for the last year
17:11:14 <johnw> it's now quite awkward when I have to edit code in modules where it doesn't work
17:12:02 <levi> Yes, hdevtools annoys me with its usefulness and its failure to universally work.
17:12:17 <johnw> but to be fair, when hdevtools fail to work, usually even plain GHC does
17:12:23 <cdk_> what kinds of modules does it fail in? hsc/lhs?
17:12:31 <johnw> it's much more complicated than that
17:12:37 <no-n> with TypeSynonymInstances, should I use FlexibleInstances or UndecidableInstances?
17:12:39 <Twey> Is it just flycheck?  ghc-mod also gives you various information and manipulation tools
17:12:47 <johnw> i think hdevtools has type info now
17:12:51 <Twey> no-n: No
17:12:59 <no-n> oh
17:13:12 <Twey> no-n: TypeSynonymInstances are generally a bad idea to start with
17:13:18 <no-n> why?
17:13:47 <johnw> because they break the "type quality" that is the central idea behind type synonyms
17:13:50 <johnw> equality
17:13:50 <Twey> no-n: Because type synonyms are interchangeable, so TypeSynonymInstances means your program can behave differently depending on the name you give its type
17:14:02 <johnw> yeah, just what Twey said
17:14:17 <no-n> okay
17:14:27 <johnw> if I want to have a Text which is not a Monoid, I use newtype; never type
17:14:31 <Twey> Make a newtype wrapper if you want to give something a different instance
17:14:49 <no-n> okay i'll look into newtype
17:14:51 <no-n> thanks
17:15:01 <Iceland_jack> johnw: Why would you want a Text which is not a Monoid
17:15:05 <Twey> You can use GeneralizedNewtypeDeriving to ease most of the pain of that
17:15:10 <johnw> newtype CityName = CityName Text
17:15:16 <johnw> joining two city names does not make a new city name
17:15:39 <Twey> Huh, I've never really thought about that.  Seems right, though.
17:16:10 <Iceland_jack> Sure but you'd make it a newtype regardless, the reason isn't to remove the Monoid instance but rather to have a particular type
17:16:22 <Iceland_jack> Maybe that's a pedantic point but still
17:16:34 <pavonia> Can you have different instances for say String and FilePath with TypeSynonymInstances?
17:16:41 <johnw> i had a case very much like this bite me just a couple weeks ago; I was unintentionally mappend'ing pathnames deep within another Monoid instance, not realizing that mappended pathnames yield non-existent paths
17:16:41 <Twey> pavonia: Yes
17:16:48 <pavonia> Oh
17:17:02 <Twey> (FilePath should be a newtype, though ☹)
17:17:26 <dmj> anyone know if the bindSplice function exists in heist-0.13.0.2? can't find it in the docs. http://hackage.haskell.org/package/heist-0.13.0.2
17:19:15 <Eduard_Munteanu> Any chance someone built a configuration management system in Haskell?
17:19:34 <bennofs> Eduard_Munteanu: You mean like nix, in haskell?
17:19:47 <Eduard_Munteanu> bennofs: no, like Chef, Puppet...
17:20:02 <dmj> like a deployment system?
17:20:10 <Eduard_Munteanu> Nope. :)
17:20:32 <dmj> What would you call Chef and puppet then?
17:20:40 <johnw> configuration management systems
17:20:46 <Eduard_Munteanu> What johnw just said. :)
17:21:04 <johnw> and what Eduard_Munteanu said before :)
17:21:13 <Eduard_Munteanu> Heh.
17:21:38 <Twey> Eduard_Munteanu: No, but there are bindings to Puppet
17:21:52 <bennofs> "import Debug.Trace
17:21:54 <bennofs> :O
17:22:04 <johnw> Eduard_Munteanu: check out language-puppet
17:22:09 <johnw> it's not just bindings to Puppet
17:22:16 <johnw> it aims to rewrite Puppet in Haskell
17:22:25 <Eduard_Munteanu> bennofs, dmj: shortly, they let admins write a recipe to configure a system for particular tasks, instead of installing packages and updating configuration manually
17:22:27 <Twey> I thought it was an EDSL that compiled to Puppet
17:22:36 <johnw> i think it's that too
17:22:41 <Eduard_Munteanu> Cool.
17:22:42 <johnw> but he want to have an all-Haskell CMS
17:22:43 <Twey> Eduard_Munteanu: Nix can do that :þ
17:22:55 <bennofs> Eduard_Munteanu: that sounds like nix is a configuration management system too :)
17:23:09 <mm_freak> Eduard_Munteanu: nix
17:23:14 <mm_freak> oh, well
17:23:19 <mm_freak> it's not in haskell, but it works =P
17:23:22 <Twey> Heh
17:23:24 <Eduard_Munteanu> Isn't Nix a package manager and distro?
17:23:30 <mm_freak> Eduard_Munteanu: it's an *
17:23:46 <Eduard_Munteanu> To some extent some package managers do offer CMS features.
17:23:55 <mm_freak> i use it for system configuration, xmonad configuration, package management, haskell development, deployment, …
17:24:04 <johnw> there is Nix and then there is NixOS
17:24:10 <Eduard_Munteanu> mm_freak: would that require me to use NixOS?
17:24:21 <johnw> no, Nix works independently
17:24:21 <mm_freak> Eduard_Munteanu: nope
17:24:23 <johnw> it even works on OS X
17:24:33 <Eduard_Munteanu> Now this sounds promising, thanks. :)
17:24:37 <mm_freak> but yeah, if you like nix, then NixOS is a natural choice =)
17:24:43 <bennofs> Not haskell though :|
17:24:48 <johnw> no, C++
17:25:03 <Twey> I'm looking forward to Guix
17:25:17 <bennofs> Huix!
17:28:02 <cdk_> damn, looks like the GHC API changed quite a bit between 7.6.3 to 7.8-RC. hdevtools doesn't build :(
17:28:35 <mm_freak> well, it has its kinks, but GNU's answer was to write guix and thus change from statically typed C++ to guile, from haskell-like nix to guile, …
17:28:58 <mm_freak> you get the idea
17:29:40 <mm_freak> '((('((now ((packages) 'look))) like '(this))))
17:30:14 <simpson> (nope (nope nope) nope (nope) (nope) (nope) nope nope ((nope)))
17:30:36 * hackagebot directed-cubical 0.1.1.1 - Finite directed cubical complexes and associated algorithms  http://hackage.haskell.org/package/directed-cubical-0.1.1.1 (mmisamore)
17:35:50 <dsrx> i always thought )))))))))) was a weak argument against lisps. once you grok paredit, who cares
17:36:02 <johnw> dsrx: agreed
17:36:05 <Twey> Indeed
17:36:19 <Twey> And the uniformity of syntax is worth it
17:36:22 <simpson> I just want to know why mexprs never happened.
17:36:37 <dsrx> well, there was Logo right
17:37:33 <Twey> There's also http://srfi.schemers.org/srfi-49/srfi-49.html
17:43:13 <geekosaur> dsrx: it was weak in the 60s even, interlisp had ]
17:46:05 <dmj> ooo new snap book :)
17:46:18 <Nafai> dsrx: reminds me of this: https://twitter.com/jonjensen0/status/436591025633509376
17:46:23 <dmj> http://snapforbeginners.com/
17:47:02 <Twey> Heh
18:00:26 * no-n hugs haskell
18:00:28 <no-n> <3
18:02:26 * khyperia is tempted to `/nick haskell` and hug back
18:02:29 <dsrx> Nafai: ha
18:02:40 <dsrx> Nafai: i'm switching between writing clojure and ruby and .... yeah
18:03:38 <no-n> hehe
18:04:21 * FreeFull hugs khyperia
18:05:10 <Nafai> dsrx: And by sharing, I'm not digging Ruby in particular, it's just showing the sillyness of the complaint. :)
18:06:04 <dsrx> right
18:12:20 <vvvroom>  
18:26:18 <Axman6> hmm, is there a way to show a Rational as a floating point number to as much precision as it has?
18:26:47 <Axman6> @hoogle Rational -> String
18:26:48 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:26:48 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
18:26:48 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
18:28:26 <pjdelport> :t fromRational
18:28:27 <lambdabot> Fractional a => Rational -> a
18:29:31 <Axman6> well for what I'm doing I need more precision than a Double
18:29:49 <Axman6> and I don't really want to use something like CReal
18:32:47 * S11001001 messes with ghc 7.8 holes; they are neat
18:33:23 <pjdelport> Axman6: would arbitrary fixed precision work?
18:33:30 <pjdelport> there's Data.Fixed for that
18:33:41 <Axman6> hmm, perhaps
18:34:13 <pjdelport> (In general, you'll most likely have to choose a fixed limit anyway, to accomodate rationals with infinite decimal expansions)
18:36:07 <prooftechnique> stepcut: Is there anywhere to look at the progress of Happstack 8, by any chance?
18:36:27 <Axman6> pjdelport: I don't think that should be a problem here, since the number I'm converting to a Rational has a limited precision (it's four Doubles a la the qd C/C++ package)
18:37:59 <carter> Axman6: you'd want something with Rational->Int -> String
18:38:06 <carter> because repeating decimals are a thing :)
18:38:21 <Axman6> yeah, I probably do
18:38:38 <Axman6> though I'll see what the stuff in Numeric can do for me
18:40:09 <byorgey> Axman6: I had some code lying around somewhere for extracting the precise decimal representation of a Rational
18:40:17 <byorgey> let me see if I can find it
18:43:24 <byorgey> Axman6: http://lpaste.net/100253
18:44:03 <Axman6> thanks
18:44:51 <byorgey> I forget exactly how it works but I'm sure you can figure it out if you play with it a bit
18:45:32 <Axman6> I"ll hold onto that and see if I end up needing it. I'm hoping there's something in GHC already (seems showFloat might be what I'm after, just need to implement RealFloat
18:46:52 <byorgey> I don't think RealFloat makes much sense for Rational
18:46:56 <byorgey> unless you ignore most of the methods
18:47:39 <Axman6> well, it's not really for Rational, I was hoping that'd be an easy way to turn my type into something that should be shown to a large precision
18:49:08 <ezrios> how are let statements in do notation desugared?
18:49:36 <ion> do { let { blah }; baz } → let { blah } in do { baz }
18:49:54 <yng> is there such thing as lambda function with zero argument in haskell?
18:50:14 <roboguy_> yng: no
18:50:32 <roboguy_> the closest would be "\() -> ..." but that still has an argument
18:50:42 <hiptobecubic> yng, that's just a value.
18:50:43 <carter> theres the magic lazy function
18:50:44 <roboguy_> all functions in Haskell take exactly one argument. o more, no less
18:50:48 <roboguy_> *no more, no less
18:51:06 <carter> +/- 0
18:51:17 <yng> roboguy_: ya that kinda make sense
18:55:49 <jrmithdobbs> roboguy_: is there a way to express a lambda that doesn't evaluate it's argument at all?
18:55:59 <jrmithdobbs> roboguy_: \ _ ->
18:56:08 <roboguy_> jrmithdobbs: yeah
18:56:13 <roboguy_> I'd use const though
18:57:21 <jrmithdobbs> > (\ _ -> 1 :: Int) "a"
18:57:22 <lambdabot>  1
18:57:31 <roboguy_> > (\_ -> 1) undefined
18:57:32 <jrmithdobbs> i did not realize that parsed, ha
18:57:32 <lambdabot>  1
18:57:42 <roboguy_> > (const 1) undefined
18:57:44 <lambdabot>  1
18:57:57 <roboguy_> if you don't use an argument, it doesn't get evaluated
18:58:02 <geekosaur> it's a pattern, _ is a valid pattern
18:58:06 <roboguy_> > (\x y z -> x + z) 1 undefined 3
18:58:07 <lambdabot>  4
18:58:21 <amalloy> const is the only possible function with the type signature a -> b -> b, right? ignoring type-unsafe stuff like unsafeCoerce
18:58:37 <amalloy> er, and of course it's a -> b -> a, but same question applies
18:58:38 <roboguy_> amalloy: if we also ignore seq and par, yes
18:59:00 <amalloy> :t par
18:59:01 <lambdabot>     Not in scope: `par'
18:59:02 <lambdabot>     Perhaps you meant one of these:
18:59:02 <lambdabot>       `Sym.var' (imported from Data.Number.Symbolic),
18:59:05 <roboguy_> :t seq
18:59:06 <lambdabot> a -> b -> b
18:59:09 <amalloy> what's par?
18:59:12 <geekosaur> :t Control.Concurrent.par
18:59:13 <lambdabot> Not in scope: `Control.Concurrent.par'
18:59:18 <geekosaur> hm, right, wrong module
18:59:22 <roboguy_> it's for parallel execution
18:59:34 <roboguy_> well, parallel evaluation
18:59:36 <jrmithdobbs> but ya, const is why i'd never noticed that (\_ -> x) was valid :)
18:59:40 <amalloy> it's a version of seq that runs one of them in the background or something?
18:59:54 <roboguy_> it runs them both at once
19:00:00 <byorgey> amalloy: right, more precisely, it gives a hint to the runtime that it might want to consider running one of them in the background
19:00:01 <jrmithdobbs> *may
19:00:01 <roboguy_> on a multiprocessor machine with -threaded
19:00:05 <byorgey> but it's not required to.
19:05:41 <roboguy_> jrmithdobbs: \_->x is one character shorter if you're doing code golf, haha
19:06:34 <ezyang> Hm, that's weird, the free monad on the constant functor is not isomorphic to the constant monad
19:08:20 <roboguy_> ezyang: should it be?
19:08:37 <Saizan> try the free monad on Maybe :O
19:09:33 <roboguy_> one of these days I need to actually try using free monads
19:09:45 <roboguy_> the concept sort of makes sense to me though
19:11:32 <no-n> @src randomRIO
19:11:32 <lambdabot> Source not found. Whoa.
19:11:35 <no-n> Whoa.
19:14:10 <Rarrikins> Whoa from the future.
19:19:20 <ezyang> roboguy_: Well, maybe.
19:19:35 <ezyang> Saizan: Is the free monad on maybe iso to maybe? It feels like it should be.
19:20:11 <roboguy_> isn't it isomorphic to a partial computation?
19:20:28 <roboguy_> or doesn't it represent a computation with steps?
19:20:39 <Saizan> the free monad on maybe is closer to naturals than maybe
19:20:46 <ezyang> ah yes, that's right
19:23:47 <kristof> what surreal conversations that occur in this channel...
19:24:53 <ezyang> It goes tick tick tick tick "ding! Your result is ready."
19:26:56 <roboguy_> I think Free Identity is similar but it must have a result (or be an infinite loop)
19:33:12 <dolio> Free (1 + Id) A = Free Id (1 + A)
19:34:21 <johnw> I have a need for free monads right now: to serialize some logic that I can execute on the server.  Just need to craft up the boilerplate to get it done
19:50:05 <levi> How come nobody ever talks about Free Magmas?
19:50:48 <johnw> a data structure with no unit and that cannot be append asoscitiavely?
19:51:48 <tpsinnem> hm. might anyone have a clue for me -- i don't understand this pattern given this type signature:
19:51:52 <tpsinnem> prep_fill :: Name -> [Name] -> RunTactic
19:51:52 <tpsinnem> prep_fill f as ctxt env (Bind x (Hole ty) sc) =
19:52:09 <johnw> RunTactic is likely a type synonym for a function
19:52:15 <johnw> (type)
19:52:20 <tpsinnem> johnw: ah
19:52:23 <tpsinnem> i'll look into that
19:52:25 <tpsinnem> thanks
19:52:29 <roboguy_> levi: magma doesn't imply any structure other than closure does it?
19:52:48 <levi> roboguy_: Yup.
19:53:00 <roboguy_> what would a free magma do then?
19:53:19 <levi> It's a binary tree with labeled leaves.
19:53:33 <levi> The operator joins two trees at their roots.
19:54:25 <ezyang> data FreeMagma A = Leaf A | Node (FreeMagma A) (FreeMagma A)
19:55:01 <roboguy_> do you need Leaf?
19:55:10 <roboguy_> to be a magma
19:55:26 <roboguy_> oh, labeled leaves
19:55:29 <levi> That's where the values are.
19:56:18 <ezyang> without the leaf the type is uninhabited
19:56:26 <ezyang> well, it is in a lazy language
19:56:50 <roboguy_> I meant could it be Node-labeled rather than leaf labeled
19:57:07 <roboguy_> with only one constructor
19:59:35 <roboguy_> I guess it would have to be infinite in that case
20:00:41 <ezyang> Node-labeled is not right, I think.
20:02:23 <lxn> hello
20:03:10 <levi> Labeled leaves are the values, node pairs represent the application of the binary operator.
20:03:41 <levi> lxn: Hi!
20:04:32 <lxn> I'm reading "Functional programming with Bananas, Lenses, Envelopes and Barbed Wire" and I'm trying yo implement map using a catamorphism with recursive type
20:05:01 <roboguy_> levi: ah, that makes sense
20:06:08 <lxn> it shouldn't be difficult but GHC always gives me back an error, can someone help me understand what I'm doing wrong?
20:06:29 <levi> Could you paste your code?
20:06:33 <levi> @paste
20:06:34 <lambdabot> Haskell pastebin: http://lpaste.net/
20:08:11 <Axman6> @hoogle showFloat
20:08:12 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
20:08:14 <lxn> http://lpaste.net/100255
20:09:01 <lxn> I'm not using f on purpose trying to diagnose the problem
20:09:21 <amalloy> Axman6: what does the "Numeric" there mean?
20:09:32 <Axman6> it's the module it comes from
20:09:39 <Axman6> http://hackage.haskell.org/package/base-4.6.0.1/docs/Numeric.html
20:10:10 <levi> lxn: And what error are you getting?
20:10:29 <roboguy_> lxn: you didn't wrap it in InF
20:10:30 <lxn> Occurs check: cannot construct the infinite type: a = ListF a1 a
20:10:55 * hackagebot pipes-text 0.0.0.9 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.9 (MichaelThompson)
20:10:59 <levi> Oh yeah, you can't do recursive types with 'type'
20:11:14 <roboguy_> lxn: you need InF Nil, etc
20:12:05 <roboguy_> in phi
20:12:57 <lxn> ok, I've added the relevant InF to Nil and Cons and now the function works as expected
20:14:08 <lxn> thank you very much
20:14:40 <roboguy_> no problem!
20:24:34 <Axman6> anyone know how GHC takes a floating point literal (eg:1246735684.687657e28) and turns it into a Rational for use in fromRational when parsing files?
20:27:19 <carter> Axman6: lets read the source!
20:27:31 <carter> Axman6: look in integer-simple for a bsd version
20:27:39 <johnw> it probably just asks GMP to do it
20:28:29 <carter> https://github.com/ghc/packages-integer-simple/blob/master/GHC/Integer/Type.hs#L181
20:28:30 <carter> nah
20:28:36 <carter> its even simpler
20:28:41 <carter> https://github.com/ghc/packages-integer-simple/blob/master/GHC/Integer/Type.hs#L181
20:28:51 <carter> oh
20:29:02 <Axman6> not quite what I'm after
20:29:03 <carter> a literal is just a decimal number times a power of 10
20:29:06 <carter> right?
20:29:16 <Axman6> sure
20:29:23 <carter> thats how it parses em
20:29:27 <carter> to a rational
20:29:32 <Axman6> I just want to read a decimal number as a Rational and then convert it to my type
20:29:35 <carter> yea
20:29:54 <carter> so  aaaaaa.bbbbbb * 10 ^k
20:30:02 <carter> you treat ats
20:30:04 <carter> as
20:30:10 <Axman6> sure, I understand how it would be done, I just want access to the code that actually does it
20:30:14 <carter> oh
20:30:17 <carter> thats in ghc
20:30:21 <carter> lets see
20:30:23 <carter> probably in base
20:30:40 <Axman6> hmm, seems readFloat should do what I'm after
20:31:15 <carter> jah
20:31:35 <carter> http://shoup.net/ntb/ is a fun relavant book
20:33:32 <Axman6> whoot!
20:34:20 <Axman6> readSigned readFloat is exactly what I'm after
20:34:51 <carter> happy hacking
20:35:51 <Axman6> somewhat annoying that you can't read floating point strings as Rationals. but makes sense, Show and Read should be dual
20:36:15 <carter> you should be able to ...
20:36:21 <carter> when they don't have the enumber
20:36:21 <jrmithdobbs> why isn't there a "show and read considered harmful"
20:36:22 <carter> bits
20:36:24 <jrmithdobbs> ;p
20:36:25 <carter> jrmithdobbs: they are
20:36:34 <carter> only good for ghetto deubgging
20:36:49 <carter> you can write stringy coerce with em
20:38:00 <Axman6> > read "123,456" :: Rational
20:38:02 <lambdabot>  *Exception: Prelude.read: no parse
20:38:56 <carter> :p
20:43:17 <hiptobecubic> seems like read should be Maybe a, not a
20:43:26 <Axman6> indeed
20:43:39 <Axman6> well, ReadS is probably what you want in that situation
20:43:46 <Axman6> @hoogle ReadS
20:43:47 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
20:43:47 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
20:43:47 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
20:52:42 <syllogismos> @hoogle (a -> b) -> f (a, t) -> f (b, t)
20:52:43 <lambdabot> Data.Text.Internal firstf :: (a -> c) -> Maybe (a, b) -> Maybe (c, b)
20:52:43 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
20:52:43 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:53:29 <syllogismos> how do I do this? (a -> b) -> f (a, t) -> f (b, t) --f is a functor
20:53:53 <Axman6> fmap . first
20:54:00 <Axman6> :t fmap . first
20:54:01 <syllogismos> :t fmap first
20:54:02 <lambdabot> Functor f => (b -> c) -> f (b, d) -> f (c, d)
20:54:02 <lambdabot> (Functor f, Arrow a) => f (a b c) -> f (a (b, d) (c, d))
20:54:12 <carter> slick
20:54:19 <Axman6> @hoogle first
20:54:19 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
20:54:19 <lambdabot> Text.PrettyPrint.HughesPJ first :: Doc -> Doc -> Doc
20:54:19 <lambdabot> package first-class-patterns
20:54:37 <Axman6> it's the top one (but trivially defined for (->)
20:54:37 <syllogismos> ohh the first is from arrow, I am thinking fst..
20:54:45 <Axman6> aye
21:08:46 <copumpkin> the problem with these pickler combinators is that they don't really compose nicely
21:09:32 <orzo> I need something like a TChan that can be written-to and cloned/duped, but not read from without unlocking, and each clone can only be unlocked once
21:09:43 <PythonNut> @pl \x y -> rem x y == 0
21:09:43 <lambdabot> flip flip 0 . ((==) .) . rem
21:09:58 <orzo> its simple enough to roll my own, but i ask here to see if its a common already-implemented pattern
21:12:55 <Axman6> huh... maybe showFloat isn't exactly what I want... 1.1 in my type shows as "1.1", 1.0 shows as "0.0000...001e63" and is the same for all integers
21:13:38 <roboguy_> PythonNut: "((.).(.)) (== 0) rem" looks little better than what pl gave
21:14:35 <pavonia> Axman6: What about printf?
21:15:06 <Axman6> you have to implement it for your own type, and I need more precision than converting to Double will allow
21:15:51 <Axman6> I must've buggered up something somewhere. probably in decodeFloat
21:15:55 <roboguy_> :t (fmap.fmap) (== 0) rem
21:15:57 <lambdabot> Integral a => a -> a -> Bool
21:28:03 <catsup> orzo: can you quit it with the porn links already?
21:28:32 <Axman6> eh?
21:28:39 <catsup> he keeps pming me porn links
21:28:47 <catsup> really nasty stuff too
21:28:58 <Axman6> ...
21:29:10 <johnw> why are you talking to him in this channel then?  PM him back
21:30:40 <mm_freak> /ignore works, too
21:32:13 <syllogismos> how do i get a type of something inside a big expression? i saw someone doing that earlier using @type
21:32:28 <syllogismos> :t let p x = (\s -> (const $ pure (x == 'c')) =<< put (1+s)) =<< get in runState (fiterM p $ ['a'..'h']) 0
21:32:30 <lambdabot>     Not in scope: `fiterM'
21:32:30 <lambdabot>     Perhaps you meant one of these:
21:32:30 <lambdabot>       `filterM' (imported from Control.Monad.Writer),
21:32:36 <syllogismos> :t let p x = (\s -> (const $ pure (x == 'c')) =<< put (1+s)) =<< get in runState (filterM p $ ['a'..'h']) 0
21:32:37 <lambdabot> Num s => ([Char], s)
21:32:55 <syllogismos> i want say the type of pure in that expression
21:33:33 <pavonia> :t let p x = (\s -> (const $ ?foo (x == 'c')) =<< put (1+s)) =<< get in runState (filterM p $ ['a'..'h']) 0
21:33:35 <lambdabot> (Num s, ?foo::Bool -> StateT s Identity Bool) => ([Char], s)
21:33:46 <syllogismos> :t let p x = (\s -> (const $ ?pure (x == 'c')) =<< put (1+s)) =<< get in runState (filterM p $ ['a'..'h']) 0
21:33:47 <lambdabot> (Num s, ?pure::Bool -> StateT s Identity Bool) => ([Char], s)
21:33:50 <syllogismos> thank u
21:34:41 <syllogismos> it doesnt work in ghci? :(
21:35:16 <pavonia> :set -XImplicitParameters
21:36:05 <pavonia> Err, -XImplicitParams apparently
21:36:55 <PythonNut> Hello I have a piece of code that runs fast on the first execution and 2x slower for all executions after that.
21:37:01 <PythonNut> What is going on?
21:37:17 <PythonNut> GHC with a lot of optimization arguments.
21:38:10 <Tekmo> PythonNut: Can you show us the program?
21:38:49 <PythonNut> yes
21:39:17 <PythonNut> http://lpaste.net/100260
21:40:00 <PythonNut> ghc -o haskell_test test.hs -Odph -fllvm -fforce-recomp -optlo-O2 -optlo-globalopt -optlo-loop-unswitch -optlo-mem2reg -optlo-prune-eh -funbox-strict-fields
21:40:40 <Tekmo> Any reason for those specific options?
21:40:46 <Tekmo> Why not just `-O2 -fllvm`?
21:41:04 <PythonNut> They were found to be fast here http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
21:41:11 <PythonNut> And indeed it is faster.
21:41:26 <PythonNut> With just -O2 it's dependably slow.
21:42:06 <roboguy_> did you run it through the profiler?
21:42:24 <Tekmo> So which prime function runs fast on the first execution and slower on subsequent executions?
21:42:43 <PythonNut> Prime4, the only one that is actually used
21:43:49 <Tekmo> What do you mean when you say it is faster on subsequent executions?
21:43:52 <Tekmo> *slower
21:44:12 <PythonNut> It averages 0.5s on the first run
21:44:15 <roboguy_> are you rerunning the entire program or it slower in calls later in the same program?
21:44:21 <PythonNut> 1.0s on all subsequent runs
21:44:31 <PythonNut> Of the entire program
21:44:42 <Tekmo> I only see one run
21:44:59 <PythonNut> No, I manually call the program ./haskell_test multiple times
21:45:28 <roboguy_> it looks like it's pretty consistent for me
21:45:50 <PythonNut> http://lpaste.net/100261
21:46:34 <Tekmo> PythonNut: What happens if you `touch haskell_test.hs` and recompile it?
21:46:41 <Tekmo> PythonNut: Does it speed up again and then slow down again?
21:47:10 <PythonNut> Whoa, no, it doesn't
21:47:29 <PythonNut> It stays exactly at 0.75s
21:47:33 <PythonNut> average
21:47:38 <mm_freak> Tekmo: hi there…  i'm resorting to ResourceT far too often, simply because it has 'allocate'
21:47:42 <Tekmo> Do you have any other processes running in the background that might be putting load on your system
21:47:50 <roboguy_> I'm getting a variation of at most about 0.01 s between runs
21:47:54 <Tekmo> mm_freak: Yes, I'm considering offloading `pipes-safe` to `resourcet`
21:47:59 <PythonNut> No, not really
21:48:42 <mm_freak> Tekmo: that would make sense…  SafeT is really just ResourceT in disguise anyway =)
21:48:47 <Tekmo> mm_freak: Yes, it is
21:48:48 <PythonNut> The C++ program I'm comparing it to is gegular like clockwork
21:48:58 <PythonNut> :s/ge/re/g
21:49:01 <roboguy_> I'm using ghc head though, so that *could* be a factor (I doubt it though)
21:49:27 <PythonNut> And a bit slower, I might add (haha!)
21:49:37 <Tekmo> PythonNut: It's pretty unusual for a program to have a different running time on the order of 0.1 seconds
21:49:53 <Tekmo> PythonNut: I've never seen that behavior for my Haskell programs
21:49:55 <PythonNut> Much less 0.5s
21:50:28 <roboguy_> this feels familiar, but I can't quite remember what was going on...
21:50:35 <PythonNut> Okay, I guess it's just extreme runtime variation
21:50:41 <PythonNut> Not nececarrily the first run
21:50:48 <PythonNut> Although that seems to be the trend
21:50:57 <levi> PythonNut: What's your allocation rate?
21:51:39 <PythonNut> Alloc rate    68,211,009 bytes per MUT second
21:52:07 <PythonNut> +- 4GB per MUT second
21:52:09 <mm_freak> i'm glad that none of those is called "sieve" =)
21:52:25 <PythonNut> Because none of them are a seive???
21:52:31 <mm_freak> PythonNut: yes, thank you
21:52:53 <PythonNut> I'm also glad the're not called "sum_of_factorials". :D
21:53:16 <mm_freak> you'd be surprised how many trial division "sieves" we get =)
21:53:21 <Tekmo> PythonNut: You might want to read this if you haven't already: http://www.haskell.org/haskellwiki/Prime_numbers
21:53:41 <PythonNut> Have read it
21:54:00 <PythonNut> Although I'm not interested in better algorithims ATM
21:54:18 <PythonNut> I just want to prove than loop-fusion is as fast as a C++ loop
21:54:19 <levi> I'm guessing that programs that allocate like mad that way have greater runtime variation than those that aren't quite so reliant on garbage collection.
21:54:21 <PythonNut> Which it is
21:54:30 <mm_freak> too bad…  an actual sieve is about a five-liner in haskell =)
21:54:35 <PythonNut> Okay, I suppose I'll have to deal with it.
21:54:42 <PythonNut> Not really a big issue
21:55:10 <levi> Are you sure you've got loop fusion going on?
21:55:18 <PythonNut> A a really fast sieve is really more like a dozen lines.
21:55:34 <PythonNut> At least if I read the paper on prime sieves correctly.
21:55:47 <Tekmo> PythonNut: If you had loop fusion I think there would be less allocation
21:55:57 <PythonNut> Anyway. I'm part of a programming community that has basically zero exposure to Haskell
21:56:17 <PythonNut> They're all Java / Python people because of the Python / Java classes they have there
21:56:27 <Tekmo> PythonNut: We all are :)
21:56:37 <PythonNut> I'm hoping to propose Haskell as a expressive alternative that also happens to be very fast.
21:56:52 <PythonNut> Hence my compiler shootout with C++
21:57:19 <Tekmo> You can reasonably compete with Java using Haskell.  Beating C++ regularly will take some effort
21:57:42 <PythonNut> Yes, so I hear
22:00:11 <Tekmo> Also, reading your code more closely, I would steer clear of `((.) . (.))` if you want to convince them Haskell is expressive
22:00:16 <PythonNut> I don't really care about "beating" C++ so much because a lot of them are Python programmers and already get that raw performance isn't the only metric for a language implementation
22:02:04 <PythonNut> Random Q: Why is bash a language choice for lpaste? If bash is a functional language, I'm a flying octopus.
22:02:49 <Tekmo> PythonNut: It's not just for functional languages
22:03:01 <roboguy_> assembly is a choice too
22:03:30 <PythonNut> Ah, I see now.
22:03:33 <mm_freak> PythonNut: i've just written an implementation of the sieve of eratosthenes…  it's not optimized very well, but finds all primes < 100M in 8.3 secs
22:03:50 <PythonNut> I just saw Lambda, a lot of functional languages, and asumed... :facepalm:
22:04:07 <PythonNut> :s/as/ass/
22:04:10 <mm_freak> http://lpaste.net/100262
22:04:50 <PythonNut> What do you guys think about Haskell as a competition language
22:04:51 <PythonNut> ?
22:05:22 <mm_freak> competition?
22:05:46 <jle`> you mean like hackathon/speed style competitions?
22:05:48 <PythonNut> USACO style, (though USACO dosn't support Haskell :( )
22:05:53 <mm_freak> uyyyy is spamming
22:06:19 <roboguy_> probably would be good. sometimes I mess around with project euler and hackerrank and I almost always use haskell
22:07:28 <PythonNut> That's what I'm hoping. I'm really loving Haskell it's amost like my mathematical ideas fly into my editor and just work.
22:07:30 <mm_freak> btw, beating C++ isn't that hard when it comes to processing a lot of data and/or parallelism
22:07:41 <PythonNut> Thank for your help everyone!
22:08:03 <mm_freak> haskell has the property that it can migrate tasks between threads, which makes it often more efficient that C-like languages for parallelism
22:08:07 <levi> You could show them this: http://lpaste.net/100242
22:08:10 <mm_freak> not always, but often
22:10:09 <roboguy_> levi: that's a good example
22:11:45 <mm_freak> http://lpaste.net/77575
22:11:53 <mm_freak> i have yet to see a C implementation that beats this =)
22:12:14 <mm_freak> and i haven't even optimized it to its full potential ;)
22:13:00 <PythonNut> What algorithm is that?
22:13:23 <mm_freak> finding safe primes with a presieving step
22:13:45 <mm_freak> it gives you these:  http://lpaste.net/94331
22:14:09 <mm_freak> compile it with -threaded and invoke like this:  ./primes {500..600} +RTS -N
22:14:20 <PythonNut> I know arithmoi is awesomely fast (test if a probable prime before full testing, so it only needs to do apreciable work 0.3% of the time) etc....
22:14:26 <mm_freak> it well make your rusty cores do some work =)
22:14:57 <mm_freak> yeah, arithmoi is fast, but in this case it's not arithmoi that makes it fast
22:15:14 <mm_freak> it's the presieving step + the parallelization
22:15:49 <PythonNut> I'll come back to it after I learn Haskell in-depth
22:16:28 <levi> It's a bit beyond beginner level, but not too far beyond.
22:16:54 <PythonNut> I'm very very much a beginner. (~1.5 days with Haskell)
22:17:40 <levi> Ahh. Well, best advice I can give is: Don't Panic. :)
22:18:11 <PythonNut> Does anyone know of a pure, lazy LISP (out of curiosity)
22:18:18 <mm_freak> right now i'm writing an FRP-based OpenGL+OpenAL rendering engine, and i won't be happy until it displays at least 500k polygons at 60Hz while playing music =)
22:20:19 <levi> I don't know of any pure, lazy languages in common use today aside from Haskell. There were a few others that were its predecessors, and probably a few experimental or toy implementations, but I'm not aware of anything remotely at Haskell's level of maturity.
22:22:08 <PythonNut> Thanks I'll take note of that too.
22:22:21 <levi> Actually, I take that back. I think there's a pure + lazy variant of Racket.
22:22:26 <mm_freak> PythonNut: laziness doesn't interact too well with side effecting languages, so lisp-like languages are pretty much out
22:22:47 <mm_freak> there is liskell, but i don't think anyone uses it
22:22:57 <PythonNut> http://docs.racket-lang.org/lazy/
22:23:43 <Fuuzetsu> I can only imagine that it's as much of an abomination as typed racket
22:23:55 <PythonNut> Anyway, thanks to everyone for your combined knowlege and effort! Thanks!
22:24:59 <levi> Maybe the lazy Racket is not completely pure. I don't think it's very widely used, anyway.
22:27:06 <carter>  FYI ALL, SINGLETONS ARE AMAZING
22:27:09 <carter> https://github.com/wellposed/hOpenBLAS/commit/f427f262a33a902feb01a3efcb2d2d54687eaf14
22:27:11 <levi> Racket tends to less mutation than most Lisps, anyway.
22:28:32 <Platz> some people will claim clojure has lazy features, but I think they confuse data laziness (streams) with computational laziness
22:28:37 <roboguy_> carter: haskell singletons?
22:28:39 <carter> https://github.com/wellposed/hOpenBLAS/commit/f427f262a33a902feb01a3efcb2d2d54687eaf14
22:28:42 <carter> yess
22:28:50 <roboguy_> I assume it's not the singleton I'm familiar with from OO
22:29:03 <carter> nope
22:30:37 <Fuuzetsu> carter: >+data instance Sing ( x :: Orientation) where
22:30:51 <Fuuzetsu> shame that now you have to go out and fix that spurious whitespace
22:31:17 <carter> Fuuzetsu: PRs welcome :)
22:31:23 <levi> Are Singletons some sort of dependent type thing?
22:31:40 <ezyang> levi: Yeah
22:31:41 <carter> levi: a restricted sort that doesn't mess with type inference if used carefully
22:32:02 <levi> Nifty.
22:32:05 <carter> jah
22:32:10 <carter> in this case they make my ffi nicer :)
22:34:22 <Fuuzetsu> Can a staffer kick out ‘uyyyy’, it's a bot sending spam links through PM; #freenode suggests that it gets kickbanned out of channels so it can't find people that way.
22:35:26 <carter> @where ops
22:35:26 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:35:35 --- mode: ChanServ set +o copumpkin
22:35:41 <carter> Fuuzetsu: hopefully that got someones attention :)
22:35:42 --- mode: ChanServ set +o Cale
22:35:45 --- mode: copumpkin set +b *!~ircap@14.Red-81-32-230.dynamicIP.rima-tde.net
22:35:45 --- kick: uyyyy was kicked by copumpkin (No. Bad.)
22:35:55 --- mode: copumpkin set -o copumpkin
22:35:59 <carter> yeah, i got some bot pestering from that bot too
22:35:59 <m3ga> awesome!
22:36:00 <Fuuzetsu> Well, I'm unsure whether that much attention was necessary but thanks I guess.
22:36:01 <carter> thanks
22:36:06 <Cale> oh, too late :)
22:36:07 <carter> Fuuzetsu: i was getting the mssages too
22:36:11 <carter> o/ m3ga
22:36:17 <m3ga> hey carter!
22:36:26 <carter> m3ga: i'm using singletons in my ffi
22:36:27 --- mode: Cale set -o Cale
22:36:28 <carter> its great!
22:36:35 <carter> also gives me an excuse to drop 7.4 support :)
22:36:59 <carter> no 6.10 compat for me!
22:37:02 <m3ga> carter: yeah, was just about to look at the link from the other channel
22:37:06 <carter> you should
22:37:10 <carter> happy to walk yah through it
22:37:58 <carter> whether here or on #numerical-haskell
22:38:00 <m3ga> oh, i sees immediately what its doing. daom cool!
22:38:04 <carter> yeahhhhh
22:38:12 <carter> it removes some boiler plate
22:38:16 <m3ga> transpose made it really obvious
22:38:30 <carter> yeah
22:38:34 <carter> i was using GADTs
22:38:54 <carter> and getting annoyed with all the cases
22:39:04 <carter> so i moved the GADT index into its own wee singleton
22:39:16 <carter> and i'm REALLY happy with that design choice
22:39:26 <m3ga> and those gadts were being evaluated at run time, the singletons are not, right?
22:39:40 <carter> ehh, still have runtime thigns
22:39:51 <carter> but the pattern matching aint a perf issue
22:40:11 <roboguy_> wait they're a sort of gadt replacement thing?
22:40:11 <carter> considering this is me over doing a BLAS ffi as a warm up :)
22:40:13 <carter> yes
22:40:17 <carter> look at the diff :)
22:40:33 <carter> i'm using singletons to replaces a multiplicative number of cases
22:40:36 <carter> with an additive
22:40:53 <carter> so i could have several varying params in my type that i could do with a GADT
22:40:58 <m3ga> in my integer stuff, that pattern matching can be an issues when the integers are relatively small. means I need to mininize the number of constructors.
22:40:59 <carter> but only have to case on the indces i cares about
22:41:05 <carter> yeah
22:41:19 <carter> i minimize the number of constructors so i can make fewer mistakes
22:41:35 <carter> puting the gadt like types in singletons lets me reduce the engineering complexity
22:41:42 <carter> i've not seen that before
22:41:44 <carter> have you?
22:42:05 <m3ga> nope, i've never used a gadt in anger :-)
22:42:24 <carter> its a * -> + complexity reduction
22:42:26 <carter> what i did
22:42:31 <carter> if you had
22:42:44 <carter> data MyGADT :: T1 -> T2 -> *
22:42:54 <carter> you could have just a single constructor
22:43:00 <carter> instead of 2-4 or more
22:43:12 <YayMe> Can I parameterize a type owner like type Something a = Something (a String Int) wherein it just requires a to be of kind * -> * -> *
22:43:31 <carter> though in my case, all the pairs of types are valid
22:43:32 <carter> YayMe: yup
22:43:54 <YayMe> carter: any special extensions I need?
22:43:59 <YayMe> Or will it infer it?
22:44:00 <carter> none
22:44:04 <carter> should just wokr
22:44:32 <carter> m3ga: but yeah, for my use case this singletons trick instead of gadts is great
22:46:29 <carter> anyways, i'm happy with how it worked out
22:46:42 <carter> also i got hlearn dude mikeizbicki on #numerical-haskell :)
22:46:47 <carter> o/ mikeizbicki
22:47:51 <syllogismos> \o
23:04:57 <jle`> is there a good way to count the number of True's in a list?
23:05:11 <jle`> i feel like length . filter id might be redundant
23:05:40 <jle`> @src length
23:05:40 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
23:05:57 <jle`> actually hm it might work.
23:06:02 <randomclown> can somebody find me a cringeworty "powered by haskell" banner
23:06:08 <randomclown> I want to put it on my site
23:06:36 <randomclown> I want everyone to know that it's haskell backend
23:06:46 <jle`> randomclown: there was a wiki page on cringe-y haskell logos
23:06:48 <carter> theres the hakyll link
23:06:48 <jle`> have you seen that one?
23:07:00 <randomclown> jle`: link me
23:10:11 <jle`> hm can't find it atm
23:10:13 <carter> :t bind
23:10:15 <lambdabot>     Not in scope: `bind'
23:10:15 <lambdabot>     Perhaps you meant one of these:
23:10:15 <lambdabot>       `BS.find' (imported from Data.ByteString),
23:10:23 <carter> :t (>>=)
23:10:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:10:35 <carter> ok, so i'm not that out of it
23:10:36 <carter> phwe
23:10:39 <jle`> but skim through this http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
23:11:51 <jle`> there are some obvious joke ones
23:12:51 <randomclown> hmm I'll probably just pick one, fade it and background-image
23:13:16 <jle`> i always liked http://www.haskell.org/wikiupload/7/75/Pure_Devil_Haskell.png
23:13:42 <jle`> The rationality behind my draft: (1) Haskell is considered powerful but feared. (2) Reversed Biblical logic: condemned to purity to be saved by monads, which according to Leibniz "are arranged by God in a perfect order which ascends to God, the supreme monad". (3) With great respect for Haskell Curry there are other people whom the language owes, thus it is only fair to encourage alternative interpretations
23:13:43 <randomclown> ewww
23:13:44 <jle`> for the name.
23:14:23 <jle`> this one is vaguely suggestive http://www.haskell.org/wikiupload/thumb/d/d0/Lambdanimal.png/150px-Lambdanimal.png
23:14:46 <jle`> this one very deep http://www.haskell.org/wikiupload/4/43/Haskell-tao.png
23:24:04 <no-n> @src comparing
23:24:05 <lambdabot> Source not found. You untyped fool!
23:31:33 <c_wraith> :t comparing
23:31:34 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:31:38 <c_wraith> :t on compare
23:31:38 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
23:32:59 <thebnq> haha flipped letters, weird
23:38:08 <carter> WOAH, big error message https://gist.github.com/cartazio/9150085
23:39:10 <zzo38> Do you know the type of a function to receive a natural number, and to result in a natural number which is not greater than the input number?
23:39:28 <roboguy_> zzo38: Nat -> Nat?
23:39:39 <dmwit> zzo38: That constraint can't easily be expressed in Haskell.
23:40:05 <dmwit> It can be expressed with a lot of work with type-level numbers, but I don't recommend it.
23:40:17 <dmwit> Or it can be expressed easily in a language with contract types or dependent types.
23:40:30 <zzo38> I think the type is (forall a. [a] -> Maybe a)
23:40:58 <dmwit> huh?
23:40:59 <roboguy_> zzo38: ?
23:40:59 <mm_freak> it can be expressed somewhat straightforwardly with singletons
23:41:03 <zzo38> roboguy_: That doesn't have the constraint
23:41:12 <roboguy_> how could that be the type...?
23:41:15 <zzo38> mm_freak: How does that work?
23:41:29 <dmwit> Okay, I like that type.
23:41:37 <dmwit> Neat idea.
23:42:01 <roboguy_> hmm I don't think I understand
23:42:07 <dmwit> roboguy_: The "number" is the length of the list. The result is the index of the value that function returns.
23:42:38 <dmwit> roboguy_: And the polymorphism ensures that it returns one of the values in the input list.
23:42:38 <mm_freak> zzo38: forall (x y :: Nat). (x <= y) => Sing x -> Sing y
23:42:44 <mm_freak> using GHC.TypeLits
23:42:52 <mm_freak> you could also define that yourself, which probably has some advantages
23:43:07 <zzo38> mm_freak: I didn't know about GHC.TypeLits
23:43:09 <mm_freak> oh, wait
23:43:13 <mm_freak> that's wrong
23:43:49 <mm_freak> zzo38: forall (x :: Nat). Sing x -> (forall (y :: Nat). (x <= y) => Sing y -> a) -> a
23:43:53 <mm_freak> rather like that
23:44:02 <mm_freak> alternatively you can use an existential
23:44:12 <zzo38> mm_freak: Ah, OK
23:44:45 <mm_freak> forall (x :: Nat). Sing x -> (exists (y :: Nat). (x <= y) *> Sing y)
23:45:19 <mm_freak> use your usual ExistentialQuantification magic to wrap the existential =)
23:47:00 <mm_freak> data Exists :: (* -> Constraint) -> * where Exists :: (c a) => a -> Exists c
23:47:22 <zzo38> O, OK
23:47:38 <zzo38> I don't know a lot about all the new stuff they added into Haskell
23:48:15 <mm_freak> well, what they didn't add is totality checking, so agda is probably still a better choice ;)
23:48:18 <mm_freak> at least for proving stuff
23:48:22 <mm_freak> for programming there is idris
23:48:49 <mm_freak> and for getting stuff done there is haskell =)
23:50:08 <zzo38> So I just used the type I mentioned above, instead
23:51:30 <zzo38> Do you know that, in many kind of mathematical structures, defined as a tuple consisting of sets of nodes, sets of whatever, and other things referencing them, is the implementation of those such thing added in newer Haskell or Agda compilers?
23:52:16 <dmwit> I'm not sure I understand the question.
23:52:18 <mm_freak> you mean like a dependent tuple?  aka dependent sum
23:52:19 <zzo38> Some of the set is just "elements" (without giving any type), and other things can refer to them.
23:52:39 <mm_freak> zzo38: in agda dependent sums are straightforward
23:52:54 <mm_freak> and yes, every dependently typed language has that
23:52:58 <mm_freak> but haskell doesn't
23:53:09 <zzo38> I can give an example, such as a directed graph is a pair (V,A) where V is set of elements called nodes and A is set of ordered pairs of elements of V.
23:53:43 <zzo38> The set V here is just "a set of elements".
23:54:14 <triliyn> mm_freak: that would be dependent product, wouldn't it?
23:54:23 <mm_freak> triliyn: no, the dependent product is just the function arrow
23:54:29 <mm_freak> (A : Set) -> B A
23:54:34 <dmwit> Although the definition of a graph doesn't need to inspect V, normally particular graphs are a bit useless if there are no visible V operations.
23:54:44 <triliyn> hmmm, right... that is interesting
23:54:54 <dmwit> It's also sometimes called a dependent product.
23:54:56 <mm_freak> you have dependent products in haskell, btw, just a very restricted form of it =)
23:55:03 <mm_freak> forall (a :: *). B a
23:55:09 <zzo38> Or a quiver, is perhaps a somewhat better example. Two sets V and E, and two functions V->E
23:55:10 <dmwit> When trying to draw a parallel to non-dependent products, e.g.
23:55:55 <dmwit> (it = dependent sums, so I mean dependent sums are also sometimes called dependent products.)
23:56:06 <triliyn> Are they somehow sums in the sense of "sum type"?
23:56:19 <mm_freak> they are usually called products when they are independent
23:56:28 <dmwit> triliyn: yes
23:56:45 <mm_freak> triliyn: yes, it's just not a sum of 2 =)
23:57:00 <dmwit> triliyn: Think of having a sum with one injection for each element of the first half of the tuple.
23:57:02 <mm_freak> view the first component as an index
23:57:13 <zzo38> I have come up with things like    singletonSetOf :: forall a. (forall b. SetType b => SetOf b -> b -> a) -> a; filterSetOf :: forall s. SetType s => (s -> Bool) -> SetOf s -> SetOf s;   and so on, but I don't know if that is actually the proper way or not at all.
23:57:27 <dmwit> triliyn: So the first half of the tuple is the "tag" (like Left or Right) and the second half is the contained value, whose type may depend on which tag you picked.
23:57:45 <triliyn> ahhh
23:57:49 <zzo38> I have seen a Haskell program using dependent sum types.
23:57:49 <triliyn> I think I see how that works
23:57:54 <mm_freak> triliyn: see also the pi-sigma calculus
23:57:57 <triliyn> Interesting
23:57:59 <dmwit> (Just like the thing inside Left or Right depends on whether you chose Left or Right.)
23:58:13 <mm_freak> where you don't get algebraic data types, but only dependent sum and dependent product
23:58:27 <triliyn> Thanks!
23:58:29 <triliyn> That's really cool
23:59:20 <mm_freak> Either e a = Sum Bool (\b -> if b then a else e)
23:59:40 <mm_freak> Sum : (A : Set) -> (A -> Set) -> Set
23:59:44 <triliyn> hmmm... so I've heard that independent function arrow is analogous to exponentiation in the same way that Either and tuples are analogous to addition and multiplication
