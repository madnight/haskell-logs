00:00:58 <haasn> Sometime during the implementation process of type families, GHC switched to the syntax “type family Foo .. where { .. }”, from the previous “type instance where { ... }”
00:01:20 <haasn> It's not entirely obvious to me how I'm supposed to define multiple closed instances of the same type family with the former syntax. Does anybody know?
00:01:24 <ski> augur_ : for ⌜L : m β → m γ⌝ (⌜⟨m,η,(≫=)⟩⌝ a monad), the property that ⌜∀ e : m β. L e = e ≫= λ v ↦ L (η b)⌝
00:02:51 <augur_> ski: ah
00:03:10 <augur_> you and your unicode :)
00:05:01 <ski> augur_ : which amounts to saying that ⌜L : m β → m γ⌝ can be represented by ⌜f : β → m γ⌝, with ⌜L = (≫= f)⌝. or if you prefer, that ⌜L = (≫= L ∘ η)⌝
00:05:38 <ski> (s/η b/η v/)
00:12:11 * hackagebot yes-precure5-command 5.0.1 - Extended yes command to reproduce phrases in Yes! Precure 5  http://hackage.haskell.org/package/yes-precure5-command-5.0.1 (igrep)
00:12:11 * hackagebot data-ordlist 0.4.6 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.6 (LeonSmith)
00:16:55 <augur_> ski: so i think then what we have is something like dynamic dependent type theory with implicits, or something like that
00:17:01 <augur_> for NL
00:17:23 <augur_> which i think has been somewhat suggested
00:17:48 <augur_> ive seen dependent types for NL, but i dont know about its dynamicity or its implicits
00:18:06 <ski> mhm
00:18:10 <haasn> Has Sing been removed from GHC itself in favor of ‘singletons’ again, or what? It used to be in GHC.TypeLits!
00:19:36 <ivanm> what's the distinction between parametric and polymorphic wrt Haskell? is it that "show" is parametric because it's behaviour is dependent on the type, but length is polymorphic because it deals with multiple types?
00:19:59 <startling> ivanm: that sounds right
00:20:18 <startling> I think you could argue that length is parametric too though.
00:20:59 <ivanm> because I've got a cool name for a library involving "parametric", but I'm not sure if it's actually technically parametric or polymorphic in its behaviour...
00:21:09 <ski> ivanm : sortof the other way around ?
00:21:38 <ivanm> ski: heh
00:21:48 <ski> `length' is parametric, because its free theorem holds
00:22:12 <startling> yeah.
00:22:18 <ski> in type systems with polymorphism/generics, but where you can "typecase", such polymorphism probably wouldn't be parametric
00:22:18 <ivanm> free theorem being?
00:22:48 <ski> @google theorems for free
00:22:50 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
00:22:51 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract Fro...
00:22:53 <ivanm> oh, just found the polymorphism page on the haskell wiki
00:22:56 <startling> something like length . map f = length ?
00:23:03 <ski> @free length
00:23:04 <lambdabot> length = length . $map f
00:23:08 <startling> heh
00:23:21 <ivanm> and it seems that IIUC, my library is actually ad-hoc polymorphic rather than parametic polymorphic :(
00:23:34 <augur_> oh, i didnt know @free acted on values too
00:23:34 <augur_> huh
00:23:40 <augur_> @free [a] -> Int
00:23:40 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
00:23:46 <startling> oops.
00:23:50 <augur_> or does it only work on values o_O
00:24:05 <augur_> i thought @free worked on types
00:24:10 <augur_> @help free
00:24:10 <lambdabot> free <ident>. Generate theorems for free
00:24:14 <startling> @free id
00:24:15 <lambdabot> f . id = id . f
00:24:24 <startling> @free const
00:24:25 <lambdabot> f . const x = const (f x) . g
00:24:28 <augur_> @free (f :: [a] -> Int)
00:24:28 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
00:24:31 <ski> @free f :: [a] -> Int
00:24:31 <lambdabot> f = f . $map g
00:24:32 <augur_> how strange
00:24:42 <augur_> ahh well. there you go then
00:24:58 <augur_> i guess thats what ive seen in the past
00:25:05 <ivanm> so, would something like "sum" be parametric or ad-hoc polymorphic?
00:25:33 <ski> ivanm : if you take the constraint into account, i think one can argue it's also parametric
00:25:34 <startling> @free sum
00:25:35 <lambdabot> Extra stuff at end of line in retrieved type "Num a => [a] -> a"
00:25:41 <startling> uh
00:25:55 <ivanm> heh
00:25:55 <ski> however `free' doesn't know how to handle constraints, i think
00:26:41 <startling> Is there a free theorem for sum?
00:27:15 <startling> Would it be something like "mapping any f that preserves the results of the Num operations and then summing is equal to summing"?
00:27:59 <startling> "sum is invariant under Num homomorphisms", I guess?
00:28:04 <ski> a free theorem for `lookup' would presumably be similar to
00:28:05 <ski> @free lookup :: (a -> a -> Bool) -> a -> [(a,b)] -> Maybe b
00:28:06 <lambdabot> (forall x. h x = k (f x) . f) => $map_Maybe g . lookup h y = lookup k (f y) . $map ($map_Pair f g)
00:28:06 <ivanm> so if I have a parsing library that's actually polymorphic in the type (as in you use the same parser and combinators for all types that are instances of the class) rather than needing to import a different module ala parsec/attoparsec, would that then be parametric polymorphism?
00:28:22 <ivanm> it is from my understanding of what you are all saying and what I've read so far in the paper
00:28:33 <ski> perhaps the laws of the class should be taken into account somehow, though
00:28:51 <startling> does Num have laws?
00:29:09 <ivanm> @hoogle Num
00:29:09 <lambdabot> Prelude class (Eq a, Show a) => Num a
00:29:09 <lambdabot> Numeric module Numeric
00:29:10 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexArrays type NumArrayIndices = GLsizei
00:29:16 <ivanm> bah, wanted the actual link to it
00:29:19 <ski> startling : well, it ought to have
00:29:25 <startling> ski, heh
00:29:43 <ski> of course, what's really needed is a redesign there
00:29:48 <startling> sure.
00:29:57 <ivanm> the haddock docs don't list any laws...
00:30:05 <ivanm> except for signum and abs
00:30:29 <ski> for a reasonable interpretation of `sum', you want at least a monoid
00:30:43 <ski> possibly an abelian one
00:31:23 <startling> @free f :: m -> (m -> m -> m) -> [m] -> m
00:31:24 <lambdabot> (forall y. g . h y = k (g y) . g) => g . f x h = f (g x) k . $map g
00:31:51 <ski> @free f :: m -> (a -> m -> m) -> [a] -> m
00:31:51 <lambdabot> (forall y. g . k y = p (h y) . g) => g . f x k = f (g x) p . $map h
00:33:35 <ski> ivanm : anyway, at least in a shallow meaning of the word, i think it is
00:34:03 <ivanm> *nod*
00:34:26 <ivanm> it's just that "paraphrase" sounds like a cool name for a parsing library, but I don't want to talk about it being a "parametric parsing library" if that's not true :p
00:34:48 <ivanm> hmmmm.... or maybe I could make that "parametrised", which is IIUC more technically correct :p
00:36:50 <startling> paramedic
00:38:02 <tectonic> is there a good haskell library for distributed systems?
00:38:32 <bitemyapp> tectonic: that's not really a one-off thing.
00:38:42 <startling> there's that one thing
00:38:45 <startling> what's it called
00:38:48 <bitemyapp> tectonic: distributed systems is a vast field. That's like saying, "is there a good Haskell library for algorithms?"
00:38:57 <bitemyapp> startling: don't, shrink first.
00:38:57 <tectonic> fair enough
00:39:00 <bitemyapp> startling: don't feed bad questions.
00:39:05 <bitemyapp> shrink scope, then suggest.
00:39:14 <startling> I don't know. there's a certain class of problems you get when you want to write distributed systems.
00:39:16 <tectonic> ok, any recommended tutorials or books about networking and haskell?
00:39:17 <bitemyapp> tectonic: what problem are you looking to solve?
00:39:50 <tectonic> want to learn haskell and need a motivating problem
00:39:58 <startling> @hackage distributed-static -- this is what I was thinking of
00:39:59 <lambdabot> http://hackage.haskell.org/package/distributed-static -- this is what I was thinking of
00:40:28 <bitemyapp> tectonic: motivating problems work better when they're more specific.
00:40:39 <ivanm> startling: heh
00:40:46 <bitemyapp> tectonic: would something like an IRC bot or server be interesting to you?
00:41:07 <bitemyapp> tectonic: perhaps a goal of an IRC server sufficiently functional to be able to talk to yourself over irssi?
00:41:11 <tectonic> bitemyapp: yea, it would.  or distributed voting algos
00:41:34 <bitemyapp> tectonic: start with the IRC client or server.
00:41:47 <bitemyapp> tectonic: most straight-forward way to go is to use the vanilla bytestring based networking stuff.
00:41:50 <tectonic> ok.  any ideas on tutorials or books?
00:41:53 <bitemyapp> think it's all in IO
00:42:09 <bitemyapp> tectonic: I don't know of any, but you shouldn't count on such things anyway
00:42:14 <bitemyapp> tectonic: learn you break down your problems.
00:42:28 <bitemyapp> tectonic: if you wanted to start writing a simple IRC client, where do you need to begin?
00:42:51 <tectonic> learn more about haskell IO than I know now
00:45:23 <bitemyapp> tectonic: but specific to the problem
00:45:31 <bitemyapp> tectonic: what do you think would be a good place to start?
00:45:45 <bitemyapp> tectonic: stop making it about generic "learning", what concrete step could you take towards being able to implement an IRC client?
00:46:21 <Yaniel> I wonder if it would make sense to write a terminal emulator in haskell
00:46:54 <tectonic> I'd setup a client that could connect to a remote port and output the result to a console, like netcat
00:47:14 <bitemyapp> tectonic: good call. Start there.
00:47:26 <bitemyapp> tectonic: I recommend writing test-cases for the IRC protocol parsing parts.
00:47:52 <startling> irc is a terrible way to learn a language
00:48:10 <startling> well, unless the language you're trying to learn is "the irc protocol"
00:48:28 <haasn> Yaniel: https://github.com/nandykins/nanoterm :)
00:48:31 <bitemyapp> startling: I wanted a simple textual protocol for a server/client architecture
00:48:56 <bitemyapp> startling: textual server/client protocols are an excellent way to begin with distributed systems and networking
00:49:06 <Yaniel> haasn: that looks like cheating!
00:49:38 <Yaniel> haske-vte  doesn't though :)
00:50:05 <bitemyapp> startling: jumping into anything more complicated in a language you don't know is a good way to get burnt out.
00:50:10 <startling> ime textual protocols encourage sloppiness
00:50:38 <haasn> IRC leaves lots of room for sloppiness
00:51:23 <Yaniel> but I at least learn better when I have a motivating project to work with
00:53:28 <bitemyapp> startling: this is an exercise in learning enough to be able to work on hypothetical networking problems not in engineering discipline.
00:53:50 <bitemyapp> sloppy but human readable textual protocols have helped a lot of newbies get their feet wet over the years.
00:53:59 <bitemyapp> engineering discipline notwithstanding
00:56:57 <BasDirks> Is there no variation of putStr or am I blind?
00:57:09 <BasDirks> no variation that flushes*
00:57:24 <Iceland_jack> just flush manually
00:57:29 <Iceland_jack> @hoogle hFlush
00:57:29 <lambdabot> System.IO hFlush :: Handle -> IO ()
00:57:29 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
00:57:29 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
00:58:18 <BasDirks> yeah that's what I do now
00:58:30 <BasDirks> cheers
00:59:08 <Iceland_jack> No real need for a separate function, flushing is expensive
01:00:07 <bitemyapp> Iceland_jack: wasn't that why C++ << is so slow?
01:00:16 <Shin-LaC> how do I use listOf in quick check?
01:00:19 <BasDirks> Iceland_jack: good to know
01:00:44 <bitemyapp> Shin-LaC: listOf appears to be a generator combinator
01:01:07 <Shin-LaC> I guess I just do "listOf arbitrary"
01:01:09 <Iceland_jack> bitemyapp: I believe that was std::endl versus '\n'?
01:01:45 <bitemyapp> Iceland_jack: prolly, but I remember <<'s semantics specifically being slower than what a typical programmer would do in C.
01:01:54 <bitemyapp> endl does flush tho, you're right.
01:02:07 <bitemyapp> which is a bit weird for a language that's supposed to be for "systems" programming.
01:02:12 <Shin-LaC> I guess to check properties of a class with several instances I need to write a separate property per instance?
01:02:17 <bitemyapp> probably just contributes to the widespread distrust C++ programmers have for the STL and stdlib.
01:02:27 <Iceland_jack> Shin-LaC: That's unnecessary
01:02:46 <Iceland_jack> @ty arbitrary :: Arbitrary a => Gen a
01:02:47 <lambdabot> Arbitrary a => Gen a
01:02:50 <Iceland_jack> @ty arbitrary :: Arbitrary a => Gen [a]
01:02:51 <lambdabot> Arbitrary a => Gen [a]
01:02:59 <Iceland_jack> @ty listOf arbitrary
01:02:59 <lambdabot> Arbitrary a => Gen [a]
01:04:19 <Shin-LaC> Iceland_jack: but it complains that it's ambiguous
01:04:49 <Iceland_jack> Try
01:04:49 <Iceland_jack>     sample (arbitrary :: Gen [Int])
01:04:49 <Iceland_jack> in ghci
01:04:59 <Iceland_jack> is that what you want?
01:05:25 <Shin-LaC> no
01:05:42 <Iceland_jack> You don't want lists of arbitrary values?
01:05:55 <Iceland_jack> (‘sample’ is just a way of displaying them)
01:06:10 <Shin-LaC> I have three types: Circle, Line, Polygon
01:06:16 <Shin-LaC> they are all instances of Shape
01:06:33 <n^izzo> can infix functions be used the in the repl
01:06:41 <Iceland_jack> n^izzo: yes absolutely
01:06:43 <Iceland_jack> > 3 + 5
01:06:45 <lambdabot>  8
01:06:52 <Iceland_jack> > 3 `elem` [1..10]
01:06:53 <Shin-LaC> actually, never mind
01:06:54 <lambdabot>  True
01:06:58 <Shin-LaC> I no longer have a Shape class
01:07:16 <Shin-LaC> but I have a ShapePair class that lets me define an intersect function that takes any pair of shapes
01:07:30 <Shin-LaC> now I need to check that the intersect function is symmetric
01:07:53 <Shin-LaC> prop_symmetric a b = a `intersect` b == b `intersect` a
01:07:53 <n^izzo> strange div 90 10 works but not 90 'div' 10
01:08:20 <Shin-LaC> it complains because the type variables are ambiguous
01:08:25 <n^izzo> >div 90 10
01:08:39 <n^izzo> :(
01:08:42 <copumpkin> > 90 `div` 10
01:08:43 <lambdabot>  9
01:08:47 <aleksejs_> > div 90 10
01:08:48 <lambdabot>  9
01:09:02 <codygman> I've been using scotty. I recently tried to do readFile inside of an ActionM like this:  http://lpaste.net/99974 So you can only use IO inside of the "right" monads?
01:09:32 <copumpkin> n^izzo: you're using single quotes and need to use backticks
01:09:46 <n^izzo> ohhhh thanks
01:09:56 <copumpkin> :)
01:09:57 <n^izzo> copumpkin: I feel dumb right now
01:10:20 <zomg> codygman: you probably need to lift the IO function
01:10:26 <bitemyapp> n^izzo: it's okay, it's just silly stuff.
01:11:34 <Shin-LaC> http://stackoverflow.com/a/10038020/151238 <- this is the solution
01:12:14 <bitemyapp> Shin-LaC: cool :)
01:14:09 <Shin-LaC> hurf... is there any way to assert that a polygon must have at least 3 vertices?
01:14:21 <Shin-LaC> right now I just have Polygon [Point]
01:15:08 <bitemyapp> Shin-LaC: could make a constructor that requires at least 3
01:15:32 <codygman> zomg: I kind of knew that, but how would I do it? You mean lift from Control.Monad.State?
01:15:56 <zomg> codygman: there's `liftIO` in Control.Monad.IO.Class which usually does the trick
01:16:57 <burbul> can anyone help with this error? http://lpaste.net/99975
01:17:37 <Iceland_jack> Shin-LaC: Triangle Point Point Point
01:18:34 <Iceland_jack> Unless you want to mess with type-level naturals or possibly smart constructors, that's good enough
01:18:44 <oakwhiz> Shin-LaC: If you assert that polygons must be composed of at least 1 triangle, then since a triangle must be exactly 3 points, you're good
01:18:54 <codygman> zomg: So liftIO (if the typeclass is defined) lifts a monad into the current monad context?
01:19:07 <Iceland_jack>     | Polygon [Triangle] -- :)
01:19:34 <oakwhiz> You can make any polygon out of triangles... obviously
01:19:56 <Shin-LaC> I see
01:20:15 <bitemyapp> codygman: well just take a look: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-IO-Class.html
01:20:26 <bitemyapp> codygman: signature is liftIO :: IO a -> m a
01:20:32 <Shin-LaC> oakwhiz: but then you have to guarantee that there is at least one triangle
01:20:33 <bitemyapp> codygman: doesn't that seem pretty much like what you wanted?
01:20:43 <Iceland_jack> MonadIO m =>
01:20:43 <Shin-LaC> like Iceland_jack hinted, you could have an empty list of triangles
01:20:45 <burbul> I've tried to add a second executable using main-is, but
01:20:52 <burbul> get Warning: output was redirected with -o, but no output will be generated because there is no Main module.
01:21:08 <oakwhiz> Does that mean that polygons are monoids?
01:21:14 <zomg> codygman: yeah assuming `m` has MonadIO defined, liftIO will lift any IO computation to `m`
01:21:15 <oakwhiz> I wonder.
01:21:24 <bitemyapp> Right. Good catch.
01:21:45 <Shin-LaC> can I concatenate generators in arbitrary?
01:21:57 <Iceland_jack> what does it mean to ‘concatenate’ them?
01:22:05 <burbul> Ah, fixed it!
01:22:12 <codygman> bitemyapp: Yes, exactly what I wanted. I'm checking it out now and kind of sort of get the mechanics ;)
01:22:15 <codygman> zomg: Thanks!
01:22:35 <Shin-LaC> Iceland_jack: I could combine vectorOf 3 and listOf
01:22:39 <Shin-LaC> to get a list of at least 3
01:22:57 <Iceland_jack> So lists of lists of length 3?
01:23:04 <Iceland_jack> that's possible
01:23:06 <oakwhiz> Shin-LaC: http://hackage.haskell.org/package/NonEmptyList
01:23:16 <Shin-LaC> not lists of lists
01:23:17 <oakwhiz> A list that must be >1
01:23:24 <Shin-LaC> just generate two lists and concatenate them
01:23:30 <Iceland_jack> oh of course Shin-LaC
01:23:35 <Iceland_jack> liftM2 (++)
01:23:40 <codygman> How does everyone else import Data.Text.IO? I've been doing it qualified as "TIO".
01:24:12 <Iceland_jack> (liftA2 works just as well)
01:24:32 <oakwhiz> if a Polygon is a NonEmpty Triangle, and a Triangle is exactly 3 points, that seems like it would work
01:24:34 <Shin-LaC> ah, thanks
01:24:35 <Iceland_jack> if you want to make sure that a list is non-empty it's as simple as
01:24:35 <Iceland_jack>     (:) <$> arbitrary <$> arbitrary
01:24:55 <Iceland_jack> *<*> arbitrary
01:25:16 <startling> I'm not sure that works.
01:25:27 <Iceland_jack> why not?
01:25:34 <bitemyapp> codygman: there's a really easy way to empirically verify idioms: https://github.com/search?q=%22import+Data.Text.IO%22+in%3Afile&type=Code&ref=searchresults
01:25:35 <startling> oh, it does if you're not defining arbitrary; got it.
01:25:47 <bitemyapp> codygman: choose the sample size you're comfortable with. So far, TIO seems popular.
01:26:01 <bitemyapp> codygman: we're programmers. automation is the point, you can embrace it for testing/verifying assumptions too :)
01:26:11 <codygman> bitemyapp: I don't know why I didn't think about that... thanks :)
01:26:12 <n^izzo> is there any way to make a temporary function in the repl?
01:26:24 <bitemyapp> codygman: over a decade of being a lazy arse has its benefits.
01:26:44 <Iceland_jack> n^izzo: let plusTwo x = x + 2
01:26:52 <codygman> bitemyapp: I shall learn from your lazy arsedness lol
01:26:55 <n^izzo> thank you
01:27:22 <Iceland_jack>     > quickCheck $ forAll ((:) <$> arbitrary <*> arbitrary :: Gen [Int]) (not . null)
01:27:22 <Iceland_jack>     +++ OK, passed 100 tests.
01:30:34 <bitemyapp> codygman: https://github.com/scotty-web/scotty/blob/master/Web/Scotty/Types.hs note the derived MonadIO instances for ScottyT and ActionT
01:32:50 <codygman> bitemyapp: Yes! I'm actually reading it now along with the definition of liftIO
01:33:32 <bitemyapp> codygman: thank the luhd for derivation eh?
01:33:38 <bitemyapp> all that boilerplate... *poof*
01:35:29 <bitemyapp> codygman: also you should decompose the route and handler out of main and check the types.
01:35:41 <bitemyapp> codygman: querying the types might help lend some intuition for what to expect.
01:35:50 <bitemyapp> codygman: if needed, I can paste the code.
01:37:17 <bitemyapp> codygman: specifically, query the handler's type with and without the IO.
01:40:52 <bitemyapp> codygman: thanks for sharing your problem, I'm going to use it when I teach my class Tuesday.
02:03:53 <ivanm> would it make sense to have a strict version of (.) ? i.e. (f .! g) x = f $! g x
02:05:09 <shachaf> You can write ((f $!) . g)
02:05:11 <x0l> Hi. What does the st stand for in GenParser Char st [[String]] ? It's not properly explained in RWH
02:05:24 <shachaf> x0l: Probably "state".
02:05:57 <x0l> i guessed so but shouldn't it be St with a capital letter it were a type ?
02:06:09 <Saizan> x0l: it's a type variable
02:06:15 <shachaf> Not when it's polymorphic, i.e. any type, you get to choose.
02:06:25 <shachaf> Or you can give ($!) a prefix name like strict. (strict f . g)
02:07:04 <rawtass> > fromJust <$> (Just 1, Just 2)
02:07:05 <lambdabot>  (Just 1,2)
02:07:18 * hackagebot language-javascript 0.5.9 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.9 (AlanZimmerman)
02:07:18 <rawtass> why does this keep the first just?
02:07:30 <Saizan> x0l: basically parsec's monad includes a feature like the (State st) monad, for convenience
02:07:32 <c_wraith> rawtass: there's nothing else it can do
02:07:45 <Saizan> x0l: this made more sense before parsec got turned into a transformer
02:07:50 <c_wraith> rawtass: types that are instances of Functor have only one type variable
02:07:52 <OceanSpray> rawtass: because (Maybe a,) is the functor
02:08:28 <awestroke> > fromJust <$> [Just 1, Just 2]
02:08:29 <lambdabot>  [1,2]
02:08:39 <rawtass> how should I do it when I have a tuple then?
02:09:09 <Iceland_jack> You should use fromJust in general
02:09:25 <c_wraith> *shouldn't
02:09:38 <Iceland_jack> right, shouldn't :)
02:09:41 <rawtass> ok, I am just doing it for printing
02:09:43 <rawtass> IO
02:09:49 <Iceland_jack> > let tup = (Just 5, Just 10) in liftM2 (,) (fst tup) (snd tup)
02:09:50 <rawtass> to not print the Just
02:09:50 <lambdabot>  Just (5,10)
02:10:10 <awestroke> Iceland_jack: why shouldn't fromJust be used?
02:10:25 <Iceland_jack> awestroke: What happens when it's Nothing? Run-time error, that's what :)
02:10:36 <c_wraith> > uncurry (liftM2 (,)) (Just 1, Just 2)
02:10:37 <lambdabot>  Just (1,2)
02:10:42 <Iceland_jack> unless you're 100% sure about it never being Nothing and people aren't good at those
02:10:43 <Saizan> rawtass: there isn't a good combinator for mapping on both components of a tuple in the stdlib, you can do (f *** f) with Control.Arrow (just using the Arrow (->) instace), or use something from lens.. or just write your own
02:10:55 <awestroke> Iceland_jack: ah... how do I filter a list on only Just values?
02:11:11 <Iceland_jack> Not sure what you're asking, sequence or msum probably
02:11:16 <Saizan> > catMaybes [Just 1, Nothing]
02:11:16 <Iceland_jack> > sequence [Just 1, Just 2, Just 3]
02:11:17 <c_wraith> or catMaybes
02:11:18 <lambdabot>  can't find file: L.hs
02:11:18 <lambdabot>  [1]
02:11:27 <Iceland_jack> > sequence [Just 1, Just 2, Just 3]
02:11:28 <lambdabot>  Just [1,2,3]
02:11:31 <Iceland_jack> > sequence [Just 1, Nothing, Just 2, Just 3]
02:11:32 <lambdabot>  Nothing
02:11:47 <Iceland_jack> awestroke: ‘sequence’ returns Nothing is a single element is a Nothing
02:11:58 <Cale> > [x | Just x <- [Just 1, Nothing, Just 2, Just 3]]
02:11:59 <lambdabot>  [1,2,3]
02:12:05 <Cale> > catMaybes [Just 1, Nothing, Just 2, Just 3]
02:12:06 <lambdabot>  [1,2,3]
02:12:16 <Iceland_jack> What Cale posted (which is catMaybes) is when you want to filter out the Nothings
02:12:19 <Iceland_jack> from Data.Maybe
02:12:27 <awestroke> ah thanks
02:12:39 <Iceland_jack> msum gets the first Just value
02:12:42 <x0l> Saizan: thanks, I just checked the type of parse which defines the state as (), I was missing that
02:12:56 <Iceland_jack> > msum [Nothing, Nothing, Just "FIRST", Nothing, Just "second :(", Nothing]
02:12:57 <lambdabot>  Just "FIRST"
02:22:55 <Sgeo> Typo in lens docs
02:22:55 <Sgeo>  -- baz :: Lens (Foo a) (Foo b) a b
02:22:56 <Sgeo>  quux :: Functor f => (a -> f b) -> Foo a -> f (Foo b)
02:23:02 <Sgeo> http://ekmett.github.io/lens/frames.html
02:24:34 <Cale> Sgeo: what?
02:24:58 <Cale> oh
02:24:59 <Cale> I see
02:25:01 <Cale> hah
02:40:50 <skypers> hm
02:41:17 <skypers> between spaces spaces (p <* eol) makes p always fail
02:41:19 <skypers> anyidea?
02:41:39 <skypers> I guess it’s because eol can be matched with spaces
02:41:40 <johtso> Hey, I'm trying to go through the 99 haskell problems, and writing tests as a go along, but I'm having some trouble with HUnit. Not really sure how to decipher this error: http://lpaste.net/8552253302018932736
02:41:55 <skypers> yeah it’s that, dammit…
02:42:09 <skypers> I might be looking for a white space
02:42:24 <skypers> something like
02:42:33 <skypers> many (char ' ')
02:43:14 <c_wraith> johtso: [] is a polymorphic value, of type [a].  That error message is complaining it doesn't know *what* a is, just that it needs to be instances of Show and Eq
02:43:55 <merijn> johtso: Basically, assertEqual uses the Show and Eq instances of it's arguments, which it finds out through the types
02:44:10 <c_wraith> johtso: because of the instances, the type it chooses does matter, so help it out.  replace [] with something like ([] :: [Int]), or whatever the right type is, in one of the spots you're using it.
02:44:11 <johtso> hmm, okay
02:44:14 <merijn> johtso: But since [] is polymorphic GHC doesn't know which Show/Eq instance to pick
02:44:36 <merijn> johtso: The solution to deconfuse GHC is explicitly tell it which type to use
02:45:24 <johtso> that makes sense, thank you for the explanations!
02:45:53 <skypers> no one for the parsec spaces stuff?
02:46:12 <merijn> johtso: To decipher the error, it's basically saying "[] :: [a0]", and "Show [a0]" requires "Show a0", but because a0 is ambiguous (i.e. there's no type I can infer) I dunno which show instance to use
02:47:42 <merijn> You can see the same thing happening with
02:48:02 <merijn> > (show . read) "5"
02:48:03 <lambdabot>  "*Exception: Prelude.read: no parse
02:48:06 <merijn> oh
02:48:13 <merijn> Bah, stupid extended defaulting
02:48:18 <c_wraith> well, you could if lambdabot didn't use extended defaulting
02:48:31 <merijn> That'd break in GHCi :p
02:48:38 <c_wraith> no it wouldn't
02:48:43 <c_wraith> ghci also uses extended defaulting
02:48:47 <merijn> :(
02:49:00 <c_wraith> that's why the extension was created - to make ghci "work" more often
02:49:04 <merijn> It breaks in my mind!
02:50:10 <c_wraith> To be honest, I think most of the extended defaulting rules should be the normal rules.  The one I don't think should be in the normal rules is the fallback to ()
02:51:12 <c_wraith> which is what (show . read) uses!
02:54:22 <startling> > show . read $ "()"
02:54:24 <lambdabot>  "()"
02:54:27 <startling> heh.
02:59:42 <grooble> peace to all haskellers
03:02:01 <Sgeo> I want to be careful not to be too literal when translating stuff from Haskell to elsewhere
03:06:06 <Kosmos> How does 'flip' work?
03:06:46 <ziman> @source flip
03:06:46 <lambdabot> Unknown command, try @list
03:06:51 <ziman> @src flip
03:06:52 <lambdabot> flip f x y = f y x
03:07:07 <zcd> @list
03:07:07 <lambdabot> What module?  Try @listmodules for some ideas.
03:07:15 <nadirs> it swaps the arguments of a two arguments' functions
03:07:32 <nadirs> so you can partially apply it
03:07:43 <nadirs> (I'm afraid I'm using the wrong wording, though)
03:08:06 <Kosmos> Thanks, I got it now. However, I can't find any situation in which it would be useful.
03:08:48 <nadirs> Kosmos: for instance, when you pass a function to higher-order one
03:09:30 <nadirs> you might want to pass a function with its "second" argument already applied
03:10:19 <Kosmos> ah right.
03:11:32 <merijn> For example, when mapping
03:11:38 <nadirs> > map (flip div 2) [2,4..10]
03:11:40 <lambdabot>  [1,2,3,4,5]
03:11:55 <merijn> Of course, I'd recommend infix syntax for this in practice
03:12:03 <merijn> > map (`div`2) [2,4..10]
03:12:04 <lambdabot>  [1,2,3,4,5]
03:12:27 <merijn> Kosmos: It's just one of those utility functions that you occasionally need to make other higher order functions do what you want
03:12:28 <nadirs> merijn: I do too. But I tend to avoid it since when someone told me flip is preferable
03:12:31 <merijn> like id and const
03:12:33 <merijn> :t id
03:12:34 <lambdabot> a -> a
03:12:36 <merijn> :t const
03:12:37 <lambdabot> a -> b -> a
03:12:55 <nadirs> though sections look far more readable to me
03:12:57 <merijn> nadirs: I don't see why flip would be preferable
03:13:08 <merijn> I wonder who told you that
03:13:18 <nadirs> merijn: I can't remember :P
03:13:36 <nadirs> Though it was certainly someone more experienced than me so
03:14:42 <merijn> nadirs: I say ignore them and just use infix if/when it's clearer
03:15:40 <nadirs> merijn: now I can listen to you and stop fighting my feel for readability :D
03:25:13 <Kosmos> Reading the prelude, I am confused about the Tuples section. If you search for 'fst' there is a comment on top of it saying "Not legal Haskell; for illustration only" can someone explain this?
03:26:08 <Kosmos> Forgot to provide a link, sorry: http://www.haskell.org/onlinereport/standard-prelude.html
03:26:45 <apples> i think it's referring to the statement above it, not below
03:27:19 <Kosmos> confusing
03:31:31 <merijn> Kosmos: Yes, it refers to the code above
03:32:13 <Kosmos> merijn; were you able to guess because of your knowledge of Haskell or because it was obvious?
03:33:12 <bitemyapp> Kosmos: you could just copy-paste that fst definition and see what it worked.
03:33:27 <merijn> Kosmos: Well, the syntax above it is very obviously (to me) illegal haskell
03:33:31 <bitemyapp> Prelude> let myFst (a, b) = a
03:33:31 <bitemyapp> Prelude> myFst (1, 2) 1
03:33:39 <bitemyapp> boom. it worked.
03:33:48 <Cale> Kosmos: It would be legal Haskell except that you're not actually allowed to name a type or data constructor ()
03:34:04 <Cale> Kosmos: Those are built in
03:34:15 <bitemyapp> Kosmos: can you think of any other examples where there is built-in syntax you can't really directly re-appropriate in Haskell>?
03:34:16 <ivanm> when using INLINABLE instead of INLINE, is a SPECIALISE pragma needed for every single function then?
03:34:23 <merijn> Kosmos: It's illegal in the same way "data [a] = [] | a:[a]" is illegal
03:34:43 <bitemyapp> gerd dermert.
03:35:10 <merijn> Kosmos: That syntax isn't allowed in that place, the reason list syntax "works" is because it's built-in to GHC, the same goes for tuple syntax
03:35:53 <Kosmos> alright.
03:36:34 <bitemyapp> Kosmos: that having been said, putzing around with the Prelude is good for getting the basics of List-y Haskell but you'll eventually want to promote yourself to the typeclassopedia stuff.
03:36:56 <merijn> Kosmos: If you'd define your own version you'd have to use "data Tuple2 a b = Tuple2 a b", "data Tuple3 a b c = Tuple3 a b c", much like you'd define list as "data List a = Nil | Cons a (List a)"
03:36:59 <bitemyapp> give it time and you'll make vague gestures, mutter something about Foldable and Traversable, and poof - working code.
03:37:14 <merijn> Kosmos: The reason those have special syntax built-in is because, well, it looks nice :)
03:37:27 <bitemyapp> merijn: nicer than defining a recursive constructor.
03:37:35 <bitemyapp> with a manually terminated Nil
03:37:42 <Kosmos> bitemyapp; typeclassopedia?
03:37:58 <bitemyapp> Kosmos: da
03:38:10 <merijn> Kosmos: It's an intermediate haskell tutorial (i.e. if you're done with LYAH/RWH it's a good place to learn more)
03:38:17 <Kosmos> I understand nothing you guys are talking about (foldable, traversable). I started learning Haskell today :)
03:38:27 <bitemyapp> Kosmos: https://gist.github.com/bitemyapp/8739525
03:38:30 <Kosmos> Okay, thanks
03:38:32 <merijn> Kosmos: Then you should probably avoid it for a while longer :)
03:38:37 <bitemyapp> Kosmos: that's my learner's tutorial to Haskell
03:39:14 <merijn> bitemyapp: You forgot ghcjs in your JS overview :p
03:39:49 <bitemyapp> merijn: there's not an official stable version out yet.
03:39:59 <bitemyapp> merijn: I'll give my official thumbs up/thumbs down when GHC 7.8 goes stable.
03:40:11 <bitemyapp> I'm not going to tell noobies to do/use anything that requires a non-stable version of GHC.
03:40:19 <bitemyapp> not consciously.
03:53:24 <no-n> what's a better way to write x >>= return . \x -> f x y z
03:55:44 <supki> fmap (\t -> f t y z) x
04:00:07 <no-n> thanks
04:03:21 <dv-> or \t -> f t y z `fmap` x
04:04:50 <intui-pyon-istic> dv-: IIRC lambdas bind as far right as possible.
04:05:05 <no-n> ya they do
04:05:29 <intui-pyon-istic> Well, in that case, the infix fmap suggestion does not work.
04:05:48 <dv-> oh yeah :| sorry
04:07:03 <no-n> (\x -> f x y z) <$> x
04:34:38 <merijn> alternatively "f <$> x <*> pure y <*> pure z"
04:37:43 <no-n> interesting. i haven't seen <*> or pure yet though.
04:39:02 <merijn> no-n: They're from Control.Applicative
04:39:14 <merijn> no-n: Might want to look into Typeclassopedia
04:39:19 <no-n> *nod*
04:51:44 <skypers> how do you call ' '?
04:51:49 <skypers> I’d say space
04:51:51 <skypers> but in parsec
04:52:05 <skypers> space is ' ', '\n', '\r', '\t' and so on
04:53:06 <skypers> ok, it’s a mistake having a function called isSpace
04:53:10 <skypers> it should be isWhite
04:53:40 <skypers> > isSpace '\t'
04:53:41 <lambdabot>  True
04:54:28 <Yaniel> isBlank?
04:54:56 <skypers> :t isBlank
04:54:58 <lambdabot> Not in scope: `isBlank'
04:55:12 <skypers> @hoogle isBlank
04:55:12 <lambdabot> No results found
04:55:30 <Yaniel> well man 3 isspace says
04:55:47 <Yaniel> "checks for white-space characters.  In the "C" and "POSIX" locales, these are: space, form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t'), and vertical tab ('\v')."
04:56:14 <Yaniel> I suppose isSpace internally just calls that
04:56:46 <skypers> yeah
04:56:59 <skypers> why isn’t there a isBlank then?
04:59:26 <ivanm> isSpace is defined in Data.Char
04:59:43 <merijn> In parsec ' '  is just "char ' '", isn't it?
04:59:49 <ivanm> yeah
04:59:58 <ivanm> > isSpace '\v'
04:59:59 <lambdabot>  True
05:00:06 <ivanm> huh, I didn't know it did \v
05:00:19 <merijn> vertical tab, no?
05:00:21 <ivanm> but I think it's defined in Data.Char, not calling some C function
05:00:23 <ivanm> merijn: yeah
05:00:31 <ivanm> I just thought it did ' ', \n \r and \t
05:00:39 <ivanm> > isSpace '\f'
05:00:41 <lambdabot>  True
05:01:13 <skypers> ok, I just made blank = oneOf " \t", blanks = many blank and blanks1 = many1 blank
05:04:30 <skypers> > ['0'..] !! 5
05:04:31 <lambdabot>  '5'
05:04:36 <skypers> > ['0'..] !! 80
05:04:37 <lambdabot>  '\128'
05:04:42 <skypers> > ['a'..] !! 80
05:04:43 <lambdabot>  '\177'
05:04:59 <skypers> > toEnum $ ['a'..] !! 80
05:05:01 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
05:05:01 <lambdabot>              with actual type `GHC.Types.Char'
05:05:16 <skypers> > ['a'..] !! 30
05:05:17 <lambdabot>  '\DEL'
05:05:30 <merijn> skypers: What are you trying to do?
05:06:09 <skypers> merijn: casting to something visible
05:06:15 <skypers> > print $ ['a'..] !! 30
05:06:16 <lambdabot>  <IO ()>
05:06:22 <skypers> > show $ ['a'..] !! 30
05:06:24 <lambdabot>  "'\\DEL'"
05:06:26 <skypers> ok…
05:06:51 <callumacrae> egh my head hurts :(
05:07:45 <skypers> > take 58 ['A'..]
05:07:46 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
05:08:07 <callumacrae> My head hurts even more
05:08:09 <callumacrae> egh haskell
05:08:16 <skypers> callumacrae: ?
05:08:23 <skypers> what’s hard with that snippet?
05:09:00 <skypers> > toEnum 80 :: Char
05:09:02 <lambdabot>  'P'
05:09:08 <callumacrae> Nah it's the thing I'm reading
05:09:18 <skypers> ok
05:09:32 <callumacrae> Haskell is my first functional language and I only started yesterday, still haven't entirely got my head round it
05:09:43 <skypers> :)
05:09:45 <merijn> skypers: "toEnum 80" is very different from "['a'..] !! 90", FYI
05:10:10 <skypers> > map fromEnum "callumacrae"
05:10:11 <lambdabot>  [99,97,108,108,117,109,97,99,114,97,101]
05:10:22 <merijn> callumacrae: Well, one day is a rather unrealistic standard to hold yourself to :p
05:10:40 <merijn> s/90/80
05:11:15 <callumacrae> I'm on list comprehensions right now and wtf xD
05:11:23 <skypers> callumacrae: I never use the
05:11:24 <skypers> m
05:11:42 <skypers> sometimes just for fun, but I don’t really think they’re a good feature
05:12:11 <callumacrae> I'll learn them anyway :)
05:12:44 <callumacrae> > [ fromEnum x | x <- "callumacrae" ]
05:12:45 <lambdabot>  [99,97,108,108,117,109,97,99,114,97,101]
05:12:53 <merijn> callumacrae: Do you know any other languages already?
05:13:03 <callumacrae> JavaScript, PHP, Java
05:13:29 <callumacrae> JavaScript is getting a bit more functional programming stuff recently, but everything is still very different
05:13:33 <merijn> Shame, I was hoping python, as python has list comprehensions too ;)
05:13:50 <callumacrae> I've written Python, but never learned it
05:14:28 <merijn> callumacrae: But maybe translating that comprehension to python syntax would clarify "[ fromEnum x | x <- "callumacrae" ]" is the same as python's "[ fromEnum(x) for x in "callumacrae"]"
05:14:42 <nk777> coffeescript has list comprehensions too
05:15:06 <callumacrae> I can read the Python one! Thanks :D
05:15:31 <no-n> B)
05:15:53 <merijn> callumacrae: They're just "repeat everything left of '|' for every value on the right, with individual variables replaced appropriately"
05:16:25 <merijn> Which, is the same as
05:16:32 <merijn> > map fromEnum "callumacrae"
05:16:33 <lambdabot>  [99,97,108,108,117,109,97,99,114,97,101]
05:16:46 <callumacrae> That's the example I stole in the first place :)
05:20:35 <callumacrae> Is there any difference between elem x ['A'..'Z'] and isUpper x?
05:20:43 <callumacrae> The tutorial is using the former and I don't get why
05:21:33 <merijn> callumacrae: Yes
05:21:41 <merijn> isUpper works for any unicode
05:22:03 <merijn> "elem x ['A'..'Z']" only looks at ascii uppercase letters
05:22:18 <callumacrae> Huh, that seems more like a reason to use isUpper, not manually
05:22:27 <merijn> > isUpper 'Λ'
05:22:28 <lambdabot>  True
05:22:31 <callumacrae> Oh I don't think this tutorial has actually told me about isUpper yet
05:22:37 <merijn> > elem 'Λ' ['A'..'Z']
05:22:38 <lambdabot>  False
05:22:48 <callumacrae> Aha
05:23:31 <merijn> callumacrae: Haskell String's are actually proper unicode*, unlike many other languages
05:24:08 <merijn> * - Well, *almost*, some Char function don't work quite correctly, their Text cousins do, though
05:25:15 <callumacrae> Cool, thanks!
05:36:28 <jophish> > toLower 'Σ'
05:36:30 <lambdabot>  '\963'
05:37:48 * hackagebot anonymous-sums 0.2.2.0 - Anonymous sum types  http://hackage.haskell.org/package/anonymous-sums-0.2.2.0 (OmariNorman)
05:42:17 <merijn> jophish: unicode output over IRC doesn't work in lambdabot due to IRC not having an encoding
05:42:34 <jophish> merijn: I get the same in ghci
05:43:04 <merijn> jophish: Because ghci uses the "show" instance of Char
05:43:17 <nadirs> > putStrLn . (:[]) . toLower $ 'Σ'
05:43:17 <merijn> jophish: Try: "putStrLn [(toLower 'Σ')]"
05:43:18 <lambdabot>  <IO ()>
05:43:52 <jophish> I wonder how many libraries take care when making Sigma lowercase
05:44:05 <merijn> Or: putStrLn $ map toLower "Σ"
05:44:49 <merijn> jophish: The Data.Char functions are okay-ish with unicode, but if you need locale dependent stuff like proper lowercase sigma version you'll want Text and text-icu
05:45:09 <merijn> jophish: There are other edge conditions that Data.Char doesn't/can't handle
05:45:22 <jophish> I don't need anything like that :) Just curious
05:45:36 <jophish> thanks, merijn
05:45:58 <merijn> jophish: For example
05:45:59 <skypers> how would I transform oneOf " \t" to return ()?
05:46:05 <merijn> > toUpper 'ﬃ'
05:46:06 <skypers> I don’t want to use >> return ()
05:46:06 <lambdabot>  '\64259'
05:46:16 <skypers> maybe with satisfy?
05:46:17 <merijn> skypers: void
05:46:20 <merijn> :t void
05:46:21 <lambdabot> Functor f => f a -> f ()
05:46:27 <skypers> satisfy (elem " \t")
05:46:32 <skypers> +flip
05:46:37 <skypers> I know void merijn
05:47:01 <merijn> jophish: The proper uppercasing of 'ﬃ' would be "FFI", but that's multiple characters and "toUpper :: Char -> Char" so it doesn't work
05:47:02 <skypers> what’s the best thing between sastify + elem and void . oneOf?
05:47:22 <Kosmos> Why is this wrong? : capital :: (String a) => a -> a
05:47:26 <jophish> merijn: of course, the same with sigma, one needs to know the subsequent character
05:47:31 <skypers> Kosmos: String is a type
05:47:43 <skypers> you want capital :: String -> String
05:47:47 <merijn> > Data.Text.toUpper (Data.Text.pack "ﬃ")
05:47:48 <lambdabot>  Not in scope: `Data.Text.toUpper'
05:47:49 <lambdabot>  Perhaps you meant `Data.Char.toUpper' (imported from Data.Char)Not in scope:...
05:47:51 <merijn> aww
05:48:02 <merijn> jophish: Try that one in ghci, it works as it should :)
05:48:09 <skypers> merijn: map it over the text
05:48:16 <skypers> > map toUpper (pack "lol")
05:48:18 <lambdabot>  Not in scope: `pack'
05:48:18 <lambdabot>  Perhaps you meant one of these:
05:48:18 <lambdabot>    `BS.pack' (imported from Data.ByteString),
05:48:18 <lambdabot>    `BSL.pack' (imported from Data.ByteString.Lazy),
05:48:18 <lambdabot>    `BSLC.pack' (imported from Data.ByteString.Lazy.Char8)
05:48:25 <jophish> merijn: awesome
05:48:32 <skypers> > map toUpper (Data.Text.pack "lol")
05:48:33 <lambdabot>  Not in scope: `Data.Text.pack'
05:48:33 <Kosmos> skypers: I thought the parentheses thing inside the function declaration was meant to alias and save typing. what is it then? a typeclass?
05:48:44 <jophish> there's a character for "lol" ?!
05:48:46 <skypers> Kosmos: no
05:48:48 <merijn> Kosmos: They are typeclasses
05:48:53 <skypers> it’s a typeclass
05:49:07 <skypers> a typeclass is a set of constraints on a type
05:49:21 <skypers> for instance, the tyclass Eq states that the type should have a methode (==) and (/=)
05:49:34 <merijn> Kosmos: For example, you can read "foo :: Eq a => a -> a -> Bool" as "IF 'a' is an instance of Eq, THEN foo has type "a -> a -> Bool""
05:50:03 <skypers> method*
05:50:15 <merijn> Kosmos: The implicit ELSE being "if 'a' is not an instance of Eq, then using foo is a type error"
05:50:37 <Kosmos> I don't get you merijn
05:50:51 <skypers> @let foo :: (Eq a) => a -> a -> a; foo a b c = (a == b) && (b != c)
05:50:51 <lambdabot>  .L.hs:174:28:
05:50:52 <lambdabot>      Not in scope: `!='
05:50:52 <lambdabot>      Perhaps you meant one of these:
05:50:52 <lambdabot>        `!' (imported from Data.Array), `M.!' (imported from Data.Map),
05:50:52 <lambdabot>        `IM.!' (imported from Data.IntMap)
05:50:55 <skypers> ahah :)
05:50:59 <skypers> @let foo :: (Eq a) => a -> a -> a; foo a b c = (a == b) && (b /= c)
05:50:59 <lambdabot>  .L.hs:174:1:
05:51:00 <lambdabot>      Could not deduce (a ~ (a -> Bool))
05:51:00 <lambdabot>      from the context (Eq a)
05:51:00 <lambdabot>        bound by the type signature for foo :: Eq a => a -> a -> a
05:51:02 <lambdabot>        at .L.hs:161:8-28
05:51:09 <skypers> @let foo :: (Eq a) => a -> a -> a -> Bool; foo a b c = (a == b) && (b /= c)
05:51:11 <lambdabot>  Defined.
05:51:23 <skypers> > foo "ahah" "ahah" "hihi"
05:51:25 <lambdabot>  True
05:51:28 <skypers> > foo 1 1 3
05:51:29 <haasn> Is there a unicode package somewhere? One that eg. counts the number of characters in a String, or reverses it, or converts it to uppercase, etc. etc.
05:51:30 <lambdabot>  True
05:51:31 <skypers> and so on…
05:51:42 <merijn> haasn: Yes, it's called "text"
05:51:46 <benmachine> haasn: does it have to be in a String? I'd just convert to Text
05:51:59 <haasn> merijn: text does not handle characters
05:52:01 <haasn> merijn: just codepoints
05:52:11 <benmachine> text-icu?
05:52:17 <merijn> haasn: Are you sure?
05:52:23 <haasn> > T.reverse $ T.pack "noe\776l"
05:52:24 <lambdabot>  Not in scope: `T.reverse'
05:52:25 <lambdabot>  Perhaps you meant one of these:
05:52:25 <lambdabot>    `P.reverse' (imported from Prelude),
05:52:25 <lambdabot>    `BS.reverse' (imported from Data.ByteString),
05:52:25 <lambdabot>    `T.traverse' (imported from Data.Traversable)Not in scope: `T.pack'
05:52:28 <merijn> Also, text-icu, yes
05:52:34 <haasn> Well, it returns "l\776eon" on my machine
05:52:44 <haasn> which is l̈eon
05:52:51 <haasn> and not lëon
05:53:22 <haasn> text-icu looks interesting, thanks
05:53:27 <Kosmos> skypers, what if you just wrote a, instead of Eq a, what would be the difference?
05:53:47 <grooble> any haskellers in london?
05:54:01 <benmachine> grooble: some
05:54:04 <Kosmos> skypers; nevermind.
05:54:09 <Kosmos> never mind*
05:54:31 <benmachine> haasn: I don't promise text-icu can help you, but it's where I'd start looking
05:54:56 <merijn> grooble: I remember talking to a few guys running a haskell company in London, so yes
05:55:09 <merijn> Also, isn't Lennart in London?
05:55:11 <Maior> grooble: several
05:55:20 <skypers> Kosmos: I couldn’t have use the (==) and (/=) operators
05:55:23 <Maior> grooble: including but not limited to myself and benmachine
05:55:42 <Maior> and the other 399 at http://www.meetup.com/London-Haskell/
05:55:46 <Kosmos> skypers; yeah just tried defining the function and it throws an error
05:55:51 <skypers> :)
05:55:58 <skypers> :i Eq
05:56:03 <skypers> oh?
05:56:18 <skypers> lambdabot doesn’t have :info?
05:56:29 <benmachine> Maior: actually I think that's 400 more
05:57:13 <skypers> Kosmos: typeclasses are only used to create constraints; some dudes also use them to create “able” stuff but it’s a common mistake I guess
05:57:14 <benmachine> skypers: correct
05:57:16 <Maior> benmachine: in astronomical terms, they're the same
05:57:27 <benmachine> skypers: re: :info I mean
05:57:35 <skypers> benmachine: I got it :)
05:57:35 <grooble> calling  all heroes
05:57:39 <grooble> https://hackpad.com/UK-Flood-Help-February-2014-QFpKPE5Wy6s
05:57:43 <Kosmos> skypers; what do you mean with constraints?
05:58:03 <grooble> im going i want haskellers to be there too
05:58:15 <skypers> Kosmos: a constraint is put on a polymorphic types to express “yeah ok, it could be whatever, but it has to have this and this and that”
05:58:19 <skypers> -s
05:58:23 <aloiscochard> hey, could someone help me to remove the uglyness of line 28 here: http://lpaste.net/99977 ?
05:58:41 <aloiscochard> I could not make the do notation solve the thing, so I use two 'return', that doesn't sounds right to me
05:58:41 <skypers> I like seeing that as a “list of features” a type must match :)
05:58:52 <skypers> for instance:
05:58:53 <skypers> :t sort
05:58:54 <lambdabot> Ord a => [a] -> [a]
05:58:58 <skypers> huh
05:59:19 <skypers> yeah well
05:59:35 <skypers> you can see that the sort function can be used on _any_ types that is in the class Ord
05:59:40 <skypers> i.e. you can order them
05:59:41 <Kosmos> skypers; so for example, in C you could be having 2 different functions to add integers and another one to add floating points, but in haskell you just put the Num typeclass and you are assured that no matter if its integer or floating point, the'll get added? (even with a mix of integer and floating point?)
06:00:02 <skypers> Kosmos: correct but not the last part
06:00:10 <skypers> you can’t mix types
06:00:16 <Kosmos> so I can't do this: add 1 2.444
06:00:25 <skypers> no you can’t
06:00:29 <Kosmos> why?
06:00:29 <merijn> Kosmos: Well, you can, but only if 1 is a floating point :p
06:00:32 <merijn> > 1 + 2.4
06:00:33 <lambdabot>  3.4
06:00:38 <skypers> > (1 :: Int) + (2.4 :: Float)
06:00:39 <merijn> > (1 :: Int) + 2.4
06:00:40 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
06:00:40 <lambdabot>              with actual type `GHC.Types.Float'
06:00:40 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
06:00:41 <lambdabot>    arising from the literal `2.4'
06:00:41 <lambdabot>  Possible fix:
06:00:41 <skypers> see
06:00:42 <lambdabot>    add an instance declaration for (GHC.Real.Fractional GHC.Types.Int)
06:00:43 <skypers> you can’t
06:00:48 <skypers> merijn: you’re stupid. :D
06:01:08 <skypers> Kosmos: what merijn did works because 1 is a polymorphic values, it could be Int, Float, and so on
06:01:26 <skypers> whereas 2.4 is can be only Float or Double
06:01:26 <Kosmos> skypers; so if you don't specifically define types Haskell assumes they are both floating points?
06:01:34 <benmachine> no
06:01:35 <skypers> it that case yes
06:01:39 <Kosmos> uhh
06:01:42 <skypers> benmachine: sure
06:01:48 <benmachine> in this case, you're adding together two literals, one of which is clearly floating point
06:01:49 <skypers> :t 1 + 3.4
06:01:50 <lambdabot> Fractional a => a
06:01:52 <Kosmos> I'll give lambdabot a try
06:01:53 <skypers> well ok
06:01:56 <skypers> Fractionnal
06:01:57 <skypers> not Floating
06:02:00 <benmachine> since they have to be the same type for you to add them together the other is made that type too
06:02:22 <benmachine> then defaulting kicks in, which is a special mechanism basically designed for exactly this exactly
06:02:25 <benmachine> er example
06:02:29 <Kosmos> > let add :: (Num a) => a -> a -> a; add x y = x + y
06:02:30 <lambdabot>  not an expression: `let add :: (Num a) => a -> a -> a; add x y = x + y'
06:02:48 <skypers> Kosmos: it’s @let
06:02:52 <benmachine> basically 1 + 3.4 is technically ambiguous, but people thought having simple arithmetic expressions result in ambiguous type errors was bad press
06:03:00 <skypers> @let add :: (Num a) => a -> a -> a; add = (+)
06:03:02 <lambdabot>  Defined.
06:03:13 <benmachine> so if there are unresolved types in the Rational typeclass, they're sort of squidged into Double
06:03:14 <Kosmos> > add 1 2.44
06:03:16 <lambdabot>  3.44
06:03:23 <benmachine> this is one of the very few occasions on which Haskell guesses what you mean
06:03:30 <benmachine> instead of just knowing
06:03:32 <skypers> :t add 1 2.44
06:03:34 <lambdabot> Fractional a => a
06:03:38 <skypers> :t add 1 2.44 :: Float
06:03:39 <lambdabot> Float
06:03:44 <skypers> :t add 1 2.44 :: Double
06:03:45 <lambdabot> Double
06:03:47 <skypers> :)
06:04:05 <ski> @type add 1 2.44 :: Rational
06:04:06 <lambdabot> Rational
06:04:19 <ski> > add 1 2.44 :: Rational
06:04:20 <lambdabot>  86 % 25
06:04:33 <Kosmos> > :t add
06:04:34 <lambdabot>  <hint>:1:1: parse error on input `:'
06:04:38 <Kosmos> > t add
06:04:39 <lambdabot>  Couldn't match expected type `(a0 -> a0 -> a0) -> t0'
06:04:40 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
06:04:43 <Kosmos> :t add
06:04:44 <lambdabot> Num a => a -> a -> a
06:04:50 <skypers> Kosmos: see the signature
06:04:58 <skypers> it takes two value of the same type
06:05:04 <skypers> and returns something of the same type
06:05:13 <skypers> if you want to add something different
06:05:20 <waidmann> why does "let f = reverse . init" work without specifying "let f xs = (reverse . init) xs" sorry for trivial question
06:05:21 <skypers> you’d need a signature like a -> b -> ?
06:05:41 <Kosmos> ohh nice
06:06:07 <Kosmos> > @let add :: (Num a) => a -> b -> ?; add a b = a + b
06:06:08 <lambdabot>  <hint>:1:1: parse error on input `@'
06:06:11 <skypers> no :D
06:06:14 <skypers> the ? was a true question
06:06:17 <benmachine> waidmann: why wouldn't it? you're saying "this function is equal to this other function"
06:06:19 <haasn> waidmann: functions are just values, you're defining the value ‘f’ to be equivalent to (reverse . init)
06:06:20 <skypers> what type would you put there?
06:06:27 <haasn> waidmann: Haskell has no problem with this
06:06:28 <applicative> Tekmo: ping ?
06:06:32 <benmachine> waidmann: just like if you wrote let x = 5 you're saying this number is equal to this other number
06:06:54 <waidmann> what I mean is does haskell just figure out
06:06:57 <skypers> Kosmos: for instance imagine you want to concatenate two different types as a String
06:07:04 <waidmann> if you are putting in one list
06:07:10 <waidmann> as an argument
06:07:28 <haasn> waidmann: haskell figures out from (reverse . init) that ‘f’ must be a function
06:07:34 <haasn> type inference
06:07:44 <haasn> :t reverse . init
06:07:45 <lambdabot> [a] -> [a]
06:08:03 <haasn> so we know that f is a function that takes a list of type [a] and produces another list of type [a]
06:08:13 <waidmann> cool, so we can use type inference with function composition to save having to specify an input
06:08:23 <Kosmos> skypers; how would you be able to add 2 types that belonged to Num and were defined as different? (also how do you strictly define a value's type?)
06:08:26 <waidmann> and haskell just works it out from the types of the composed functions
06:08:33 <skypers> @let bar :: (Show a, Show b) => a -> b -> String; bar a b = show a ++ show b
06:08:34 <lambdabot>  Defined.
06:08:46 <haasn> waidmann: even without a type system it would be valid, though
06:08:46 <skypers> >bar "lol" (Just 3)
06:08:50 <benmachine> Kosmos: it doesn't necessarily make sense to add two different things together
06:08:54 <skypers> > bar "lol" (Just 3)
06:08:56 <lambdabot>  "\"lol\"Just 3"
06:08:59 <benmachine> Kosmos: in fact it frequently doesn't
06:09:10 <skypers> > bar 3 1
06:09:12 <lambdabot>  "31"
06:09:20 <skypers> > bar (3 :: Int) (3.14 :: Float)
06:09:20 <benmachine> Kosmos: however, you will often be able to convert both to a type you can add
06:09:21 <lambdabot>  "33.14"
06:09:23 <Kosmos> benmachine; to me it makes a lot of sense that you can add numbers
06:09:34 <benmachine> Kosmos: e.g. if you have a Double and a Float you can convert both to Rational and then add them
06:09:40 <aloiscochard> does any one know how I can avoid doing things like `(return . return $ Nothing)` there -> http://lpaste.net/99977 ? I'm sure there must be a better way... innit?
06:09:40 <haasn> waidmann: the type system is mainly there for telling haskell that f takes exactly *one* argument, and that that argument must be a list
06:09:58 <Kosmos> skypers; I see
06:10:13 <haasn> waidmann: apart from that, it's just the principle of rewriting
06:10:40 <waidmann> ahh right I see, I will experiment with it and see what else I can produce
06:10:40 <benmachine> Kosmos: to me you cannot add an integer to a rational number
06:10:41 <haasn> waidmann: f [1,2,3] is the same as (reverse . init) [1,2,3] because that's how ‘f’ is defined
06:10:51 <benmachine> Kosmos: you can however easily convert an integer into a rational number, then add two rational numbers
06:10:55 <haasn> (reverse . init) [1,2,3] is the same as reverse (init [1,2,3]) because that's how (.) is defined
06:10:57 <haasn> @src (.)
06:10:57 <lambdabot> (f . g) x = f (g x)
06:10:58 <lambdabot> NB: In lambdabot,  (.) = fmap
06:11:06 <benmachine> @type (.)
06:11:07 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:11:11 <benmachine> NB: lambdabot lies
06:11:43 <haasn> waidmann: had we instead written “f xs = reverse (init xs)” then f [1,2,3] would actually get rewritten to (\xs -> reverse (init xs)) [1,2,3]
06:11:49 <haasn> which would then get applied as reverse (init [1,2,3])
06:11:56 <haasn> does that make sense?
06:12:16 <Kosmos> benbangert; I understand now, thanks
06:12:30 <skypers> :)
06:12:40 <lpsmith> hmm, how do you formalize what's going on in this function,  now that I've generalized the type?   http://hackage.haskell.org/package/data-ordlist-0.4.6/docs/Data-List-Ordered.html#v:isectBy
06:12:59 <waidmann> haasn: yeah it makes perfect sense, great description
06:13:05 <lpsmith> Previously the function had easy-to-state preconditions and properties
06:13:37 <waidmann> haasn: I think it will take a while to become good with it but that clears up my understanding
06:13:37 <haasn> waidmann: the principle for this is called “eta equivalence”; we can quite easily see that \xs -> f xs  and f  are the same thing;  since (\xs -> f xs) x  = f x due to function application
06:13:49 <lpsmith> I think the change is good,  all I did was change the type,  and you can deduce more about the behavior of the function (i.e. that it's left biased) and can use the function in a few more cases more easily and efficiently...
06:14:26 <haasn> so in principle, we could rewrite any function “f x = (...) x” as “f = (...)”, in the real world there are some differences but they're of less importance than this realization
06:14:29 <lpsmith> but,  the obvious (to me) formal statement of what it does would be overly operational in nature
06:16:06 <mniip> Trying to do binary IO in haskell... There are like 80 types of BinaryString, who let that madness even exist?
06:16:08 <waidmann> haasn: it seems a lot more powerful than I initially thought in that case
06:16:16 <merijn> mniip: There's only two
06:16:23 <merijn> mniip: ByteString and ByteString.Lazy
06:16:52 <haasn> waidmann: if you want more inspiration, look at the formal lambda calculus
06:16:53 <merijn> mniip: The first being strict and the second (obviously) lazy
06:17:44 <merijn> mniip: They have different usecases, but the fact that they were named the same as a bit inconvenient and confusing at time
06:18:02 <waidmann> haasn: I will search for it, thanks for you help
06:18:11 <merijn> mniip: On the upside, it usually means switching from one to the other is a matter of changing a single import, you have to avoid trying to mix them, though
06:18:12 <mniip>     Couldn't match type `GHC.Word.Word8' with `Char' :|
06:18:24 <mniip> merijn, somehow i ended up using both
06:18:27 <merijn> mniip: Did you import ByteString.Char8?
06:18:54 <merijn> mniip: If so, that's god punishing you for your sins
06:19:23 <lpsmith> It would seem to me that a formal definition of isectBy would need to be in the form     if "as" is a list ordered by cmpA,  and "bs" is a list ordered by cmpB,  and cmpAB has the right relationship between cmpA and cmpB,  then ....
06:20:07 <merijn> mniip: The one difference between ByteString and ByteString.Char8 is that the former has "pack :: [Word8] -> ByteString", the latter has "pack :: [Char] -> ByteString", this latter type is filled with the unholy evil of the world-beyond and should not be used
06:20:32 <merijn> mniip: Do you have a minimal example that fails you can lpaste?
06:22:26 <mniip> merijn, for some reason, putByteString takes a ByteString, and runPut returns a ByteString.Lazy
06:24:13 <merijn> mniip: Ah, you're using binary?
06:24:23 <lpsmith> Hmm,  would    if  a' < a,  and b < b',   then   a < b  implies a' < b' suffice?     I.e. "respects transititivity"
06:24:29 <mniip> Data.Binary.Put? yes
06:25:14 <merijn> mniip: If you want to work with strict ByteStrings you probably want cereal (there were plans to merge these two to have a universal interface for serialisation with both lazy and strict bytestrings, but it hasn't happened yet)
06:25:37 <merijn> mniip: binary parses/produces lazy ByteString, cereal parses/produces strict ByteString
06:26:31 <merijn> mniip: Oh, actually
06:26:34 <merijn> mniip: Potentially simpler
06:26:47 <merijn> mniip: Data.Binary.Put docs mention "putLazyByteString"
06:26:55 <syllogismos>  f (a -> b) -> f a -> f b where f = (->) r is r -> (a -> b) -> (r -> a) -> (r -> b) am I correct?
06:27:29 <merijn> syllogismos: No, you misparenthesised
06:27:45 <syllogismos> is there a difference between (r -> a -> b) and r -> (a -> b)?
06:28:01 <grooble> flood
06:28:11 <merijn> syllogismos: There's no difference between "(r -> a -> b)" and "(r -> (a -> b))"
06:28:36 <merijn> syllogismos: But the way you wrote it no is a function that takes an 'r', 'a -> b', 'r -> a' argument
06:29:13 <merijn> So it should be "(r -> (a -> b)) -> (r -> a) -> (r -> b)" which is the same as "(r -> a -> b) -> (r -> a) -> (r -> b)"
06:30:13 <syllogismos> but (r -> a -> b) is ((r -> a) -> b)?
06:30:18 <merijn> syllogismos: No
06:30:26 <syllogismos> hmm
06:30:27 <merijn> syllogismos: (->) is right associative
06:30:49 <merijn> "a -> b -> c -> d" -> "a -> (b -> (c -> d))"
06:31:42 <syllogismos> (+) 2 3 == (+) (2 3) ?
06:31:56 <merijn> heh?
06:32:19 <merijn> syllogismos: Function application is left associative, but the type operator is right associative
06:32:25 <syllogismos> ohh okay
06:32:28 <merijn> "f a b" -> "(f a) b"
06:32:45 <syllogismos> yeah thats what I meant..
06:33:10 <merijn> syllogismos: Look at the type "a -> (b -> (c -> d))" that should illustrate why "f a" returning a function that takes a 'b' makes sense
06:33:16 <syllogismos> function applicatin is left and -> is right.. got it..
06:39:15 <syllogismos> > ap (+) (+1) 1
06:39:17 <lambdabot>  3
06:39:33 <syllogismos> > ap (*) (+4) 5
06:39:34 <lambdabot>  45
06:40:16 <syllogismos> can someone explain this?
06:40:30 <syllogismos> :t ap
06:40:31 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:40:40 <Clint> which part?
06:41:01 <syllogismos> how ap works in case of reader monad..
06:42:08 <merijn> Is there a non-infix of Control.Applicative.<|> ?
06:42:20 <merijn> I need it in a module that's already using Parsec's <|>
06:44:08 <mniip> merijn, gah, another problem, writeFile doesn't accept lazy bytestrings
06:44:22 <merijn> syllogismos: m = "r ->", so "m (a -> b) -> m a -> m b" becomes "(r -> (a -> b)) -> (r -> a) -> (r -> b)" so it's just "ap f g r = f r (g r)"
06:44:24 <pjdelport> syllogismos: You can think of it as it as normal application, ($), but passing the environment to each argument first
06:45:30 <luite> mniip: use Data.ByteString.Lazy.writeFile
06:45:52 <merijn> mniip: Use Data.ByteString.Lazy.hPut together with one of the "FilePath -> IO Handle" functions
06:46:05 <merijn> mplus == <|>, right?
06:46:07 <pjdelport> syllogismos: so ap (*) (+4) 5 wil apply each of its argument to 5 (the environment), giving (5*) and (5+4)
06:46:58 <pjdelport> syllogismos: then it applies (5*) to (5+4) as normal, giving 5 * 9 → 45
06:50:40 <syllogismos> I got it in that specific case .. but my box anology is failing me now in case of reader monad.. thanks for the explanation though..
06:52:03 <pjdelport> syllogismos: in terms of the box analogy, a reader monad value is just a box expecting a value
06:52:48 <merijn> I don't think you should attempt to fix the box analogy
06:52:54 <merijn> It's a rather poor analogy anyway
06:53:07 <pjdelport> remember that the reader monad is effectively any function of a common environment, (e ->)
06:53:36 <pjdelport> so (*) is a "box" expecting a number, and (+4) is a "box" expecting a number
06:54:48 <pjdelport> (*) `ap` (+4) applies the two boxes by combines them into one box, that expects a number and passes it to both
06:55:00 <pjdelport> not the best analogy, as merijn says, but that's how you'd see it in terms of that
06:56:49 <pjdelport> syllogismos: another way to see it is to consider that for the reader monad, (f `ap` g) becomes \r -> (f r $ g r)
06:57:04 <pjdelport> note the correspondence between `ap` and $
06:57:11 <pjdelport> both are application
07:02:57 * hackagebot dwarf-el 0.2 - Parser for DWARF debug format.  http://hackage.haskell.org/package/dwarf-el-0.2 (EyalLotem)
07:02:59 * hackagebot dwarfadt 0.2.0.0 - High-level wrapper around the dwarf library  http://hackage.haskell.org/package/dwarfadt-0.2.0.0 (EyalLotem)
07:05:34 <pjdelport> syllogismos: consider if you had more than two functions
07:05:39 <pjdelport> > let f = (,,,) `fmap` (1+) `ap` (10*) `ap` negate `ap` show in f 5
07:05:40 <lambdabot>  (6,50,-5,"5")
07:06:00 <pjdelport> or equivalently,
07:06:48 <pjdelport> let f = (,,,) <$> (1+) <*> (10*) <*> negate <*> show in f 5
07:08:20 <pjdelport> what's happening there is that the application is lifted into the reader monad: aside from the leading (,,,), each argument becomes a function of the environment (5)
07:08:41 <pjdelport> (,,,) just collects the results into a tuple, for easy visualization
07:10:03 <skypers> hey, do you think abstracting things with typeclasses would result in worse runtime performance?
07:12:05 <bernalex> is there something in base that gives you the checksum and blockcount of a file?
07:14:09 <merijn> skypers: It depends
07:14:35 <skypers> merijn: if the type for the typeclass is given explicitely in the code
07:14:43 <skypers> can ghc optimize it away?
07:16:19 <merijn> skypers: Yes
07:16:37 <merijn> skypers: GHC can and does inline typeclass function lookups if they're statically known
07:16:44 <ronbrz> Hey #haskell, I'm trying to install gtk2hs on my system and am running into some trouble. I'm running fedora, and following the installation instructions listed here http://projects.haskell.org/gtk2hs/download/ . When I run "cabal install gtk" It fails to install the package
07:17:07 <ronbrz> any of you have any advice for me? :^)
07:17:22 <skypers> merijn: hm
07:17:28 <skypers> I think I want to marry ghc.
07:17:30 <skypers> :)
07:18:29 <absence> skypers: with that many devs exploring her .. internals?
07:19:06 <skypers> absence: she?
07:21:04 <Feuerbach> ronbrz: you should start by lpasting the output of cabal install
07:21:36 <Feuerbach> (also, read it yourself, if you haven't)
07:22:21 <absence> skypers: for some reason female pronouns are sometimes used on things people build, like boats :)
07:22:36 <bernalex> uhm OK, are there *any* libraries out there that gets the checksum and blocksize of a file?
07:22:36 <skypers> oh, ok
07:22:39 <skypers> funny fact :)
07:23:15 <pjdelport> bernalex: blocksize?
07:23:19 <Feuerbach> bernalex: there are plenty of libraries for checksumming, just choose the algorithm
07:23:25 <ronbrz> oh, of course, here's a pastebin of the output http://pastebin.com/KgmTM7pj
07:24:10 <ronbrz> the important line seems to be "cannot satisfy -package-id mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62:
07:24:10 <ronbrz>     mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62 is shadowed by package mtl-2.1.2-82086cac9073862cbe01e44b81ec8b9b"
07:24:34 <bernalex> pjdelport: block count.
07:24:36 <Feuerbach> ronbrz: right. I'd recommend either doing that in a sandbox, or cleaning your package db
07:25:14 <ronbrz> ok, how do you recommend cleaning my package db?
07:26:15 <ronbrz> sorry, haven't used cabal that much, so I'm learning
07:26:18 <pjdelport> bernalex: https://hackage.haskell.org/package/cryptohash implements a bunch of hash functions, which you can use as reliable checksums
07:26:28 <bernalex> Feuerbach: pjdelport nice, thanks
07:26:41 <pjdelport> the block count depends on what you mean by "block"
07:26:45 <Feuerbach> ronbrz: something like rm -rf ~/.ghc/*/package.conf.d
07:27:00 <pjdelport> filesystem blocks aren't really a standard or exposed detail, for this kind of thing
07:27:03 <pjdelport> what do you want it for?
07:27:11 <ronbrz> ok awesome, thank you for your help :^)
07:27:45 <bernalex> Feuerbach: I meant bsdsum for the record.
07:28:06 <bernalex> pjdelport: 1K blocks
07:28:35 <bernalex> pjdelport: oh, that package doesn't have bsdsum
07:29:00 <bernalex> I should have specified that in the first place, obviously, sorry
07:29:30 <Feuerbach> yeah, I don't see any package implementing bsdsum
07:30:35 <bernalex> I thought I said bsd checksum, but I only said checksum, so that was probably confusing you. my bad. :-P
07:30:56 <Feuerbach> as for the block count, it's provided by the stat syscall, but doesn't seem to be exposed in the unix package
07:31:09 <Feuerbach> so it looks like you'll have to write FFI bindings for both
07:31:38 <bernalex> ok thanks
07:33:06 <aleksejs_> this is interesting http://www.frontiersin.org/Journal/10.3389/fnhum.2014.00068/abstract
07:35:00 <joneshf-laptop> hmm, has anyone implemented idiom brackets with a quasiquoter?
07:35:29 <johnw> http://hackage.haskell.org/package/applicative-quoters
07:36:09 <joneshf-laptop> nice
07:40:21 <stephenmac7_> Is there a better way to do this?
07:40:27 <stephenmac7_> map (flip (,) (1%4)) [zip f1 m1, zip f1 m2, zip f2 m1, zip f2 m2]
07:41:12 <joneshf-laptop> speaking of
07:41:37 <Eduard_Munteanu> stephenmac7: what is it supposed to achieve?
07:41:46 <joneshf-laptop> > zip <$> [1,2,3] <*> [4,5,6]
07:41:47 <lambdabot>  No instance for (GHC.Show.Show b0)
07:41:48 <lambdabot>    arising from a use of `M11810543747999799213343.show_M11810543747999799213...
07:41:48 <lambdabot>  The type variable `b0' is ambiguous
07:41:48 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:41:48 <lambdabot>  Note: there are several potential instances:
07:41:54 <joneshf-laptop> > pure zip <$> [1,2,3] <*> [4,5,6]
07:41:55 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
07:41:56 <lambdabot>    arising from a use of `M333169403621434183413352.show_M3331694036214341834...
07:41:56 <lambdabot>  The type variable `a0' is ambiguous
07:41:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:41:56 <bernalex> what's the neatest way of handling multiple possible exceptions? I want to handle both "no such directory" and "directory not empty"
07:41:57 <lambdabot>  Note: there are several potential instances:
07:41:58 <joneshf-laptop> bleh
07:42:25 <supki> bernalex: Control.Exception.catches
07:43:05 <bernalex> supki: I want to catch them to different functions, if this matters, which I guess it might do
07:43:16 <stephenmac7> Eduard_Munteanu: I'm trying to find combinations of pieces of two tuples
07:43:33 <bernalex> basically "good" old: try foo; catch errortype1: do stuff; catch errortype2: do stuff;
07:43:39 <stephenmac7> joneshf-laptop: That might work
07:44:03 <joneshf-laptop> > pure zip <$> [[1,2,3], [4,5,6]] <*> [[7,8,9],[10,11,12]]
07:44:04 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
07:44:04 <lambdabot>    arising from a use of `M768919163998697624813361.show_M7689191639986976248...
07:44:04 <lambdabot>  The type variable `b0' is ambiguous
07:44:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:44:04 <lambdabot>  Note: there are several potential instances:
07:44:07 <bernalex> supki: right, the catches example looks useful, thanks.
07:44:37 <supki> bernalex: actually, since IO exceptions share the type, case/if may be enough
07:44:43 <joneshf-laptop> oh for f's sake
07:44:46 <joneshf-laptop> > zip <$> [[1,2,3], [4,5,6]] <*> [[7,8,9],[10,11,12]]
07:44:47 <lambdabot>  [[(1,7),(2,8),(3,9)],[(1,10),(2,11),(3,12)],[(4,7),(5,8),(6,9)],[(4,10),(5,1...
07:44:49 <joneshf-laptop> there
07:44:54 <supki> catches is more useful when exceptions have different types
07:45:17 <bernalex> supki: do you mean like: removeDirectory `catch` omgfail; omgfail e = case e of... ?
07:45:21 <joneshf-laptop> or idiom notation
07:45:41 <joneshf-laptop> > [i| zip [[1,2,3], [4,5,6]]  [[7,8,9],[10,11,12]] |]
07:45:41 <supki> bernalex: yeah, something like that, possibly with guards from System.IO.Error
07:45:42 <lambdabot>  <hint>:1:51: parse error on input `]'
07:46:32 <bernalex> supki: right. I'll go read the docs for exceptions now to figure out how to figure out what kind of exception I'm getting.
07:47:17 <Eduard_Munteanu> > let p = [1,2,3]; q = [4,5,6]; p' = map (*10) p; q' = map (*10) q in [ (a, b) | t <- [p, q], u <- [p', q'], a <- t, b <- u ]
07:47:18 <lambdabot>  [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30),(1,40),(1,50...
07:47:38 <Eduard_Munteanu> stephenmac7: you might want a comprehension to express things like that, it's often rather nice
07:47:50 <stephenmac7> Eduard_Munteanu: I'll try that
07:48:27 <bernalex> supki: hm, is show e and parsing the text really the best/only way?
07:49:08 <Eduard_Munteanu> Is GHC.TypeLits.IsZero a misnomer? http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-TypeLits.html
07:49:42 <bernalex> given how utterly lololol 'case (show e) of "removeDirectory: does not exist (No such file or directory)"' looks, I'm sort of assuming there's some sane way of doing it that I'm not seeing
07:49:49 <stephenmac7> Eduard_Munteanu: How would I do that with a tuple?
07:50:15 <merijn> bernalex: Yes, use the Typeable instance to match types
07:50:16 <stephenmac7> I'm unzipping a list and then trying to zip it back up again with another unzipped list
07:50:31 <Eduard_Munteanu> stephenmac7: what form do you have the tuple in? Literal, a value passed in as a tuple?
07:50:49 <stephenmac7> Eduard_Munteanu: ([], [])
07:50:59 <stephenmac7> Er
07:51:01 <merijn> bernalex: All exceptions are Typeable instances: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html
07:51:04 <stephenmac7> ([a], [a])
07:51:19 <papna> stephenmac7: You have a tuple of two lists?
07:51:21 <Eduard_Munteanu> stephenmac7: and you have two of those?
07:51:25 <stephenmac7> Yes
07:51:33 <papna> stephenmac7: What are you going to unzip?
07:51:39 <stephenmac7> That's unzipped
07:51:49 <bernalex> merijn: I don't understand how to use this. Typeable IOException, so uh, how do I figure out what kind of IOException it is using typable?
07:51:53 <stephenmac7> I start with
07:51:54 <dario> bernalex: not sure i understood your problem right, but System.IO.Error has all kinds of isXYError :: IOError -> Bool checks
07:52:07 <Eduard_Munteanu> stephenmac7: then you could write it as   f (p, q) (p', q') = [ ... ]
07:52:09 <stephenmac7> [(a, a)]
07:52:14 <bernalex> I guess I can just check on beforehand
07:52:25 <merijn> bernalex: Ah, you mean which IOException is it, use dario's example
07:52:45 <papna> stephenmac7: You start with [(a, b)] and [c] and want to end up with [(a, c)]?
07:52:48 <bernalex> I dislike trycatch programming anyway. might as well actually figure out if the directory exists/is empty before I try to remove it.
07:52:56 <merijn> bernalex: No!
07:53:05 <merijn> bernalex: That's a bug in your code
07:53:12 <bernalex> oh right, nonatomic
07:53:15 <merijn> Right
07:53:25 <bernalex> dario: thanks
07:53:30 <stephenmac7> papna: More like [(a, a)] -> [(a, a)] -> [[(a, a)]]
07:54:31 <stephenmac7> Or,
07:54:34 <bernalex> so is there a way to use case with this?
07:54:45 <bernalex> like case e of isDoesNotExistError -> ...
07:54:57 <stephenmac7> [(a, a)] -> [(a, a)] -> [([(a, a)], Rational]
07:55:07 <stephenmac7> *al)]
07:55:24 <bernalex> or is there another neat way to structure it? using elseif would be horrible
07:55:40 <supki> bernalex: guards/multiway if
07:55:52 <bernalex> oh yes I could use guards of course
07:57:56 <Eduard_Munteanu> > let u = uncurry (liftA2 (,)) in curry (u *** u) ([1,2,3], [4,5,6]) ([10,20,30], [40,50,60])
07:57:58 <lambdabot>  ([(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)],[(10,40),(10,50),(1...
07:59:08 <bernalex> hm, there was no isNotEmptyError =/
08:00:26 <bernalex> anyone know how to identify an error that's "unsatisified constraints (Directory not empty)"?
08:00:39 <bernalex> i.e. an IOError
08:00:47 <flebron> so when thinking of an Algebra over a Functor, f a -> a, my go-to example is data Expr = ..., and the algebra being evaluation. what is another example of such an algebra with another type?
08:02:29 <Saizan> flebron: with f = [] and Monoid a, it can be mconcat
08:04:02 <Eduard_Munteanu> Hm, I don't get it... 'isZero :: Sing n -> IsZero n' isn't about zero in particular at all.
08:04:13 <Eduard_Munteanu> It's just an inductive witness for Nat.
08:05:01 <Eduard_Munteanu> It should really be called IsNat or something.
08:05:18 <supki> bernalex: print its IOErrorType
08:05:39 <johnw> what is the definition of IsZero?  Isn't it something like zero :: Zero and notZero :: Sing n?
08:06:14 <Eduard_Munteanu> johnw: data IsZero where IsZero :: IsZero 0; IsSucc :: !(Sing n) -> IsZero (n + 1)
08:06:43 <johnw> so, it's only IsZero if it's zero -- doesn't that say something about the zeroness of any particular Nat?
08:06:57 <Eduard_Munteanu> johnw: I meant the type constructor name is misleading
08:07:09 <johnw> ah
08:07:32 <bernalex> supki: uhm how do I get that?
08:08:32 <Eduard_Munteanu> It's pretty much isomorphic to Nat except inductive. :)
08:08:42 <Algebr> Is there like a gdb for Haskell? Does something like gdb make sense for Haskell?
08:09:01 <Eduard_Munteanu> Algebr: ghci has debugging commands
08:09:17 <Eduard_Munteanu> Algebr: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
08:09:30 <Algebr> But I mean, can I step through haskell program?
08:09:37 <supki> bernalex: I think System.IO.Error.ioeGetErrorType will get it
08:09:39 <Algebr> Eduard, thank you will read the ghci docs.
08:09:47 <Eduard_Munteanu> Algebr: yes but not really useful generally
08:09:48 <bernalex> supki: kthnx
08:10:17 <Eduard_Munteanu> Algebr: ghci's debugger is one of the last things you'd reach for
08:11:06 <Algebr> So how do I debug? putStrLn?
08:11:31 <Eduard_Munteanu> Algebr: check out Debug.Trace
08:11:34 <Eduard_Munteanu> :t trace
08:11:35 <lambdabot> Not in scope: `trace'
08:11:39 <Eduard_Munteanu> @hoogle trace
08:11:40 <lambdabot> Debug.Trace trace :: String -> a -> a
08:11:40 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
08:11:40 <lambdabot> package trace-call
08:12:19 <Algebr> Neat, thanks
08:12:31 <Eduard_Munteanu> Algebr: but the main line of defense, to say so, is testing (pure) functions in isolation
08:12:49 <Algebr> Like Unit tests?
08:13:28 <bernalex> supki: OK according to show, it's an unsatisified constraints error, but Eq IOErrorType. how do I use this?
08:13:41 <bernalex> i.e. is there a list of each variant of IOError somewhere?
08:13:57 <Eduard_Munteanu> Algebr: not necessarily, I mean you can just call your functions in ghci. Given general-enough types, chances are off-by-one or strange errors aren't very likely.
08:14:41 <Algebr> Eduard, thank you.
08:14:41 <bernalex> ah, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-IO-Exception.html#IOError might have what I need
08:15:30 <Algebr> I thought that Haskellers didn't actually use ghci, that it was more likely used as a pedagogocial (sp?) tool
08:15:34 <Eduard_Munteanu> Algebr: that is, polymorphism not only gives you generality, but prevents mistakes too
08:15:52 <bernalex> or so I thought
08:16:18 <bernalex> uhm, how do I import UnsatisfiedConstraints as per http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/src/GHC-IO-Exception.html#IOError ?
08:16:42 <Eduard_Munteanu> Algebr: ghci is quite used in development. Perhaps not as much on finished projects since compiled code is faster, but haskell-mode and other IDEs would use ghci for interacting with code.
08:16:53 <Eduard_Munteanu> Algebr: unless you're mistaking ghci for hugs
08:17:12 <sebastian_> Hi all, is there a way to hide text reencodings? for example form Lazy Bytestring to Strict text or from Lazy Bytestring to Strict Bytestring to Strict Text to Lazy Text ?
08:17:21 <heatsink> Algebr: I use ghci for interactively analyzing data.  I read input files and use different commands to analyze them.  Since I don't know what commands will give useful results, interactive programming is useful.
08:17:23 <benmachine> bernalex: to import constructor C of type T in module M you do import M (C (T))
08:17:38 <Eduard_Munteanu> sebastian_: for what purpose?
08:17:38 <benmachine> bernalex: weirdly, you can't import the constructor without importing the type
08:17:40 <bernalex> benmachine: that's what I thought but it didn't work exactly
08:17:40 <sebastian_> I'm tired of things like "TE.decodeUtf8 $ urlEncode False $ TE.encodeUtf8 r"
08:17:41 <benmachine> bernalex: oh, that's T (C)
08:17:49 <bernalex> I have import System.IO.Error (IOErrorType (UnsatisfiedConstraints), ioeGetErrorType, isDoesNotExistError)
08:17:55 <sebastian_> or " >>= return . TE.decodeUtf8 . BL.toStrict"
08:18:21 <Eduard_Munteanu> sebastian_: for literal strings or values you get passed?
08:18:29 <bernalex> benmachine: I get a doesnotexport error
08:18:39 <benmachine> bernalex: that's because it does not export it
08:18:48 <benmachine> bernalex: see the export list http://hackage.haskell.org/package/base-4.6.0.1/docs/src/System-IO-Error.html
08:18:49 <bernalex> benmachine: uhm so what do I do then?
08:18:55 <sebastian_> Eduard_Munteanu: I'm having conversions all over the place
08:19:22 <benmachine> bernalex: not sure, maybe GHC.IO.Exception exports it
08:19:32 <heatsink> sebastian_: The usual approach is to write a type class with conversions to and from a common format.  Then you can make a generic conversion function that converts between any two representations.
08:19:40 <Eduard_Munteanu> sebastian_: it depends quite a bit what you're doing with it, hiding the conversion might not be a good idea after all
08:19:42 <heatsink> The vector library does this (unstream . stream)
08:20:04 <heatsink> And Enum does as well (toEnum . fromEnum) though that is rarely useful
08:20:26 <bernalex> benmachine: kthnks I'll look for it.
08:20:27 <Eduard_Munteanu> sebastian_: if you have specific things that have to be bytestrings of a given kind, I suggest you make a newtype wrapper for them instead of using bytestrings directly.
08:20:28 <sebastian_> heatsink: Eduard_Munteanu, I'm the only one wiht this problem?
08:21:08 <Eduard_Munteanu> sebastian_: e.g. newtype Url = Url StrictBytestring
08:21:10 <sebastian_> I'm using different Libraries with different flavours of text
08:21:36 <bernalex> benmachine: ohlol. I was misreading something. of course it's not exported by  System.IO.Error. my bad. sorry.
08:21:56 <alpounet> sebastian_: i think there's a package that tries to give a "solution" (rather workaround?) to this problem
08:23:21 <sebastian_> alpounet: you know the name?
08:23:34 <alpounet> sebastian_: sorry, had to google around to find it again. http://hackage.haskell.org/package/string-conversions
08:23:57 <Eduard_Munteanu> sebastian_: there's the option of going for the least common denominator, which might be lazy bytestring in your case. Perhaps encoding-specific too.
08:24:07 <alpounet> it assumes utf8 encoded bytestrings when decoding them but in practice it's handy, sincerely
08:24:35 <alpounet> it also exposes (<>) for concatenating any of those string types
08:24:48 <bernalex> so anyone happen to know how to test whether my unsatisified constraint is an ENOEMPTY or not?
08:25:36 <sebastian_> alpounet: thanks
08:26:40 <alpounet> i've found it to be quite useful when developping dealing with all kinds of string types with the usual libraries: aeson, cassava, postgresql-simple, blaze-html, etc
08:27:52 <bernalex> "No results found for ghc unsatisfiedconstraints enoempty". hmm...
08:28:49 <jophish> Is there a way to make cabal silent when running build, except for errors?
08:29:09 <Algebr> I just use ghci, is hugs basically dead then?
08:29:33 <heatsink> Hmm.  I wonder why string-conversions doesn't define instance ConvertibleStrings a a where convertString = id
08:29:53 <heatsink> Instead there are a bunch of identity conversion instances
08:30:24 <Eduard_Munteanu> heatsink: it's not quite a canonical instance
08:30:45 <heatsink> What does canoncial mean, Eduard_Munteanu?
08:30:56 <Eduard_Munteanu> ConvertibleStrings Foo Foo would result in overlap if you already have that.
08:31:36 <Eduard_Munteanu> Also possibly   (IsFoo a, IsBar b) => ConvertibleStrings a b
08:31:48 <heatsink> Oh, yeah
08:32:12 <heatsink> Actually, is that a shortand for (a ~ b) => ConvertibleStrings a b ?
08:32:29 <heatsink> ConvertibleStrings a a  == (a ~ b) => ConvertibleStrings a b
08:33:07 <heatsink> If so, then that instance would match any types
08:33:19 <benmachine> I don't think it's a shorthand for that
08:33:29 <Eduard_Munteanu> heatsink: the type equality checking is deferred to the call site, I think
08:33:31 <benmachine> but I don't really understand how such instances work
08:33:43 <benmachine> so I could be wrong
08:35:23 <Eduard_Munteanu> instance (a ~ b) => Foo a b where foo :: ... a ... b ...  gives you a    foo :: (a ~ b) => ... a ... b ...
08:35:28 <Eduard_Munteanu> More or less.
08:36:38 <heatsink> Huh.  So there's something subtle going on
08:39:41 <Eduard_Munteanu> heatsink: generally it's best to minimize naked type variables in instance parameters
08:39:44 <heatsink> In type checking as I understand it, equality constraints and class constraints can't affect which instance matches a given call site
08:39:49 <Eduard_Munteanu> Especially if there's no fundep.
08:41:08 <Eduard_Munteanu> heatsink: well, you can't write such an instance in Haskell2010
08:41:11 <heatsink> Right, to avoid overlap between different useful instances
08:41:35 <Eduard_Munteanu> You need at least FlexibleInstances I think.
08:42:14 <heatsink> Oh, now I recall.  When you write something like data Foo a b where Con1 :: a -> Foo a a, there's an implicit equality constraint
08:42:32 <heatsink> That's why I'm expecting an equality constraint to appear in instance Foo a a
08:43:08 <heatsink> But I guess it could work differently
08:43:17 <Eduard_Munteanu> heatsink: yeah, for GADTs that is a  Con1 :: forall a b. (b ~ a) => a -> Foo a b   but GADTs are manual resolution, to say so.
08:43:24 <merijn> heatsink: Why would there be an "implicit equality constraint" there?
08:44:06 <heatsink> merijn: Eduard_Munteanu expanded out the data constructor type to show the constraint
08:44:56 <Eduard_Munteanu> That's how they're represented in the compiler actually, the type constructor application thingy is sugar.
08:47:07 <Eduard_Munteanu> heatsink: anyway, for GADTs, an "instance" is a value, and "methods" are fields. The constraint is brought into scope as soon as you pattern-match the constructor.
08:48:30 <Eduard_Munteanu> f (Con1 a) = ... results in b ~ a getting checked part of typechecking that clause.
08:49:00 <Eduard_Munteanu> It must succeed, it's a type error otherwise, not just a failed pattern-match.
08:50:50 <Eduard_Munteanu> So f :: ... Foo a b ...  with no constraint a ~ b can't match Con1.
08:50:53 <sebastian_> alpounet: thanks for string-conversions
08:51:59 <Eduard_Munteanu> Er, well, that's not quite true.
08:53:25 <Eduard_Munteanu> The constraint can be compatible with the rest of f's type, in which case pattern-matching can bring a ~ b into the clause's scope.
08:53:43 <Eduard_Munteanu> But Foo () Void will not be able to match Con1.
08:54:47 <heatsink> Using a data constructor means the constructor's signature must be compatible with the current type environment, so constraints can be added immediately
08:55:29 <heatsink> Using an overloaded method means that an instance should be chosen that matches the method, so the constraints can be used in selecting the instance instead of being added to the context?
08:55:44 <Eduard_Munteanu> It's a bit awful Haskell GADTs don't distinguish parameters from indices though.
08:56:14 <heatsink> Do parameters and indices behave differently?
08:57:01 <heatsink> They do for type functions
08:57:29 <Eduard_Munteanu> heatsink: instance resolution is recursive and must be decidable, so it's a bit different
08:58:30 <Eduard_Munteanu> heatsink: they should... AFAIU they're sort of a fundep semantically. Parameters are picked by the caller of the type constructor, while indices are picked by a particular data constructor.
09:00:30 <Eduard_Munteanu> heatsink: I'd expect all constructors parametric in some variables to be accessible for all choices of those parameters
09:02:21 <heatsink> So the valid constructors at a given type can vary with the type indices, but not with parameters
09:03:05 <ski> i think so
09:03:22 <Eduard_Munteanu> heatsink: yeah, but 'valid' is a bit vague. You can talk about pattern-matching them, more precisely, I think.
09:03:29 <ski> it could matter for exhaustiveness checking
09:03:35 <heatsink> ok
09:04:29 <Eduard_Munteanu> Constraints brought in by indices should influence clauses, while those brought in by parameters would appear into the type (would be checked part of the type constructor application).
09:04:57 <merijn> 1 yak down, 300 to go!
09:05:09 <Eduard_Munteanu> Though I think we don't have any constraints that can be brought in by parameters.
09:06:30 <Eduard_Munteanu> It matters in Agda when you have a type parametrised and/or indexed by things that imply constraints.
09:07:18 <harasskell> @pl f *** g = let second f = arr swap >>> first f >>> arr swap in first f >>> second g
09:07:18 <lambdabot> (line 1, column 10):
09:07:18 <lambdabot> unexpected " "
09:07:18 <lambdabot> expecting operator
09:08:10 <Eduard_Munteanu> In Haskell, if you could have lifted GADTs, it might make a difference for   data Foo (x :: a) (y :: b) (e :: Equal a b) :: *  vs   data Foo (x :: a) (y :: b) :: Equal a b -> *
09:08:16 * hackagebot twitter-feed 0.1.0.0 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.0.0 (jsl)
09:08:51 <harasskell> @pl f *** g = in first f >>> (arr swap >>> first g >>> arr swap)
09:08:51 <lambdabot> (line 1, column 10):
09:08:51 <lambdabot> unexpected " "
09:08:51 <lambdabot> expecting operator
09:09:08 <harasskell> @pl f *** g = first f >>> (arr swap >>> first g >>> arr swap)
09:09:09 <lambdabot> (line 1, column 10):
09:09:09 <lambdabot> unexpected " "
09:09:09 <lambdabot> expecting operator
09:09:45 <harasskell> @pl combine f g = first f >>> ((arr swap >>> first g) >>> arr swap)
09:09:45 <lambdabot> combine = (. ((>>> arr swap) . (arr swap >>>) . first)) . (>>>) . first
09:10:23 <harasskell> @pl second f = arr swap >>> first f >>> arr swap
09:10:24 <lambdabot> second = (arr swap >>>) . (>>> arr swap) . first
09:11:20 <Eduard_Munteanu> I expect f :: forall (x :: a) (y :: b). ... Foo x y Refl ... would get an implied constraint (a ~ b) in the first case.
09:12:09 <Eduard_Munteanu> Whereas the second would not, but it would limit f's ability to pattern-match Foo, AFAIU.
09:12:29 <harasskell> @pl cl f g = arr (\b -> (b,b)) >>> (f *** g)
09:12:29 <lambdabot> cl = ((arr (join (,)) >>>) .) . (***)
09:12:48 <merijn> harasskell: FYI, lambdabot also responds to private messages
09:13:35 <harasskell> merijn: How?
09:14:10 <Eduard_Munteanu> Well, assuming that kind equality can be expressed at all.
09:15:10 <merijn> harasskell: In most IRC clients you'd use "/msg lambdabot <whatever message/command here>"
09:15:44 <Eduard_Munteanu> harasskell: usually you'd use  /query lambdabot   to open a window where you can send multiple messages
09:16:00 <harasskell> merijn: I am asking "How lambdabot responds to private messages?"
09:16:23 <Eduard_Munteanu> harasskell: just like anyone can reply to a private message
09:16:35 <zipper> I wonder why haskell association lists cam't just act like dicts in imperative languages like python which are also immutable.
09:16:47 <zipper> I found those easy to work with
09:16:52 <pjdelport> zipper: what do you mean?
09:17:02 <pjdelport> Python dicts aren't immutable
09:17:06 <zipper> and every language has a name for dictionaries
09:17:20 <Eduard_Munteanu> zipper: Data.Map perhaps?
09:17:29 <geekosaur> you haven't worked with C, have you?
09:17:32 <zipper> pjdelport: Really? Ok the key - value pairs are
09:17:39 <pjdelport> association lists can give you the same API as dicts, but obviously not the same performance characteristics as a hash table
09:17:43 <zipper> geekosaur: No I haven't
09:17:52 <zipper> Eduard_Munteanu: Ruby calls them maps
09:18:08 <zipper> I wonder why they have a different name all the time.
09:18:12 <pjdelport> zipper: no, they're mutable
09:18:15 <pjdelport> (in Python)
09:18:24 <geekosaur> there is no native dictionary-like type. there's a couple of bad implementations in libc, there are various better ones provided by many libraries, none standard
09:18:41 <Eduard_Munteanu> zipper: a real associative list isn't very fast unless the callee first transforms it to a map
09:18:43 <harasskell> @pl forever a = a >>> forever a
09:18:43 <lambdabot> forever = fix (ap (>>>))
09:18:55 <Eduard_Munteanu> I mean [(k, a)].
09:19:01 <merijn> zipper: Python key values are mutable too, just look at the following: myDict[5] = "test"
09:19:01 <zipper> hash tables, maps, dictionaries, association lists all look the same to me.
09:19:06 <pjdelport> the only requirement that Python dicts have are that the key objects hash consistently (and both mutable and immutable objects can meet this requirement)
09:19:13 <merijn> zipper: That sets key 5 to "test", so clearly mutable
09:19:18 <hpc> zipper: you should look more closely ;)
09:20:10 <pjdelport> zipper: they all share a very similar high-level interface, yes, but the performance characteristics of different implementation algorithms differ greatly
09:20:12 <zipper> hpc: but from far they all seem the same, no?
09:20:53 <zipper> pjdelport: I guess I will learn what's different in them and therefore understand them
09:21:17 <pjdelport> and they also have different requirements of the keys: hash tables require hashable keys, search trees require a consistent ordering, association lists just require an equality check
09:21:22 <hpc> to start, in an associative list indexing is O(n) wrt number of keys
09:21:53 <hpc> hash tables "usually" are O(1)
09:21:57 <zipper> Eduard_Munteanu: In LYAH association lists are under Data.Map
09:22:02 <hpc> (hash tables are a bit odd when it comes to evaluating performance)
09:22:10 <hpc> trees are O(logn)
09:22:54 <merijn> hpc: hash tables are more like O(k+n) where k is operations needed to hash and n is the number of collisions (on average)
09:23:01 <zipper> hpc: What is n?
09:23:09 <pjdelport> zipper: have you read about how e.g. binary search tree and hash table algorithms work?
09:23:12 <pjdelport> that would be a start
09:23:17 <zipper> pjdelport: hashable as in crypto?
09:23:26 <pjdelport> zipper: no
09:23:28 <ilmig> zipper: the number of keys
09:23:30 <zipper> pjdelport: I have read the BST in LYAH
09:23:45 <zipper> *BST implementation
09:24:06 <pjdelport> zipper: it's a much weaker sense of hashing: see https://en.wikipedia.org/wiki/Hash_function#Hash_tables
09:24:49 <pjdelport> zipper: generally, the only requirement of a hash table's hash function is that it always consistently maps the same object to the same integer
09:24:54 <hpc> zipper: good exercise for seeing quite visibly the effect of different implementations, write something that loads /usr/share/dict into associative type of your choice
09:25:11 <hpc> zipper: then for many different words look up if they exist
09:25:23 <hpc> for an associative list, will be very slow
09:25:32 <pjdelport> it can map several objects to the same integer hash value, but it can't return differing hash values for them
09:26:01 <zipper> hpc: Sounds like fun
09:26:26 <monochrom> the word "function" already stands for that requirement :)
09:26:39 <zipper> hpc: but haskell has only associations
09:26:51 <pjdelport> monochrom: yes, well, not in heathen languages :P
09:27:04 <zipper> pjdelport: Heathen languages? lol
09:27:15 <monochrom> package "unordered-containers" is an interesting hybrid. it comes with the Haskell Platform
09:27:34 <monochrom> yeah, screw heathen languages :)
09:27:43 <pjdelport> hpc: Haskell has implementations of hash tables, search trees, and pretty much everything else, too
09:27:50 <pjdelport> err, zipper -^
09:28:01 <zipper> hpc: what about http://book.realworldhaskell.org/read/data-structures.html
09:28:28 <benmachine> monochrom: in fairness one might require that e.g. two trees which represent the same Data.Set must also hash to the same value
09:28:51 <merijn> zipper: What do you base "Haskell has only associations" on?
09:29:04 <merijn> zipper: There's like a billion different Map/Tree datatypes in haskell
09:29:11 <monochrom> now, that gets deep into "what is 'equal'"
09:29:11 <zipper> merijn: They are all I have seen being used ;)
09:29:33 <merijn> zipper: That's just because association list are simple to show to people
09:29:41 <merijn> zipper: In reality you'd use Data.Map
09:29:46 <zipper> merijn: Oh I see
09:30:14 <merijn> zipper: Which "Map k v" with "lookup :: Ord k => k -> Map k v -> Maybe v"
09:30:33 <monochrom> on a tangent, part of why people get so polarized on "what is referential transparency" is that they have different "equal"s in mind and talk past each other
09:30:53 <zipper> They say hash tables are types of associative arrays but among associative array qualities we have
09:31:04 <zipper> "the modification of the values of existing pairs"
09:31:10 <zipper> https://en.wikipedia.org/wiki/Associative_array
09:36:22 <merijn> zipper: But no, you can't add a new pair to an association list, you can only create a new association list that includes the new pair
09:36:44 <merijn> zipper: On account of everything, including association lists, being immutable in haskell
09:42:18 <ryantrinkle> i just saw appendFile fail with "file is locked"
09:42:22 <ryantrinkle> how do i avoid that?
09:42:42 <Eduard_Munteanu> ryantrinkle: sounds filesystem / OS-specific
09:42:58 <Eduard_Munteanu> ryantrinkle: on Windows opened files are commonly locked
09:43:03 <ryantrinkle> Eduard_Munteanu: fair enough; it's ubuntu
09:43:25 <ryantrinkle> there shouldn't be anything else in the system writing that file, other than other "appendFile" calls from the same process
09:43:38 <ryantrinkle> maybe concurrent appendFiles don't play nicely?
09:43:45 <Eduard_Munteanu> ryantrinkle: and it's not a NFS filesystem or something like that?
09:44:01 <merijn> There was a runtime bug that caused "file is locked" failures
09:44:06 <merijn> I forgot what it was, though
09:44:28 <ryantrinkle> Eduard_Munteanu: nope; standard local filesystem
09:44:30 <Eduard_Munteanu> Normal Linux filesystem don't have file locks.
09:44:31 <ryantrinkle> GHC 7.6.3
09:44:46 <ryantrinkle> Eduard_Munteanu: that's what i thought!
09:44:50 <ryantrinkle> especially appendFile
09:45:01 <ryantrinkle> i'm wondering if the error is not accurate
09:45:23 <Eduard_Munteanu> Might be what merijn said.
09:46:04 <Eduard_Munteanu> ryantrinkle: could you try strace-ing it?
09:46:19 <ryantrinkle> Eduard_Munteanu: ehhh, not really
09:46:27 <ryantrinkle> this is a production server that's screwing up, unfortunately
09:46:37 <ryantrinkle> very annoying environment to debug in
09:46:48 <ryantrinkle> i'll probably have to come back to it later
09:46:54 <ryantrinkle> for now i can just catch the error and ignore it
09:47:20 <johnw> Eduard_Munteanu: what do you mean they don't have locks?  ext3 and ext4 certainly do support file locking
09:48:06 <ryantrinkle> johnw: but would those locks be taken by either 1) appendFile, or 2) me using "tail -f" or "less"?
09:48:11 <Eduard_Munteanu> johnw: if you mean atomic renames + lock files, that's different from the Windows situation.
09:48:13 <ryantrinkle> that's why i'm confused
09:48:18 <Eduard_Munteanu> johnw: in that it's not mandatory
09:49:06 <Eduard_Munteanu> ryantrinkle: you can filter strace's output with -e and redirect it to a log, maybe it catches something on the open syscalls to that file
09:50:33 <jrmithdobbs> the TypeHole stuff is one of the most awesome features ever.
09:50:51 <Eduard_Munteanu> Indeed.
09:51:05 <Eduard_Munteanu> Does haskell-mode support it already?
09:51:23 <jrmithdobbs> ghci does now by default, I don't use emacs
09:51:46 <Eduard_Munteanu> Ah, I was hoping it could present them like Agda holes.
09:52:00 <jrmithdobbs> it's nice to just completely change the type of something in a structure and the put . _ in a few places and the compiler tells you the iso you need to create ;p
09:52:00 <Eduard_Munteanu> And let you interactively complete the goal.
09:52:33 <Eduard_Munteanu> Sounds useful for my xmonad config, so I don't have to use existentials for layout types. :)
09:53:06 <Eduard_Munteanu> But yeah, fancier types sometimes have irrelevant stuff in them.
09:53:24 * hackagebot canonical-filepath 1.0.0.3 - Abstract data type for canonical file paths.  http://hackage.haskell.org/package/canonical-filepath-1.0.0.3 (ThomasSchilling)
09:56:08 <Eduard_Munteanu> Weird, I wonder why nobody bothered making stricter paths.
09:56:32 <Eduard_Munteanu> Stuff isomorphic to strings is terribly useless safety-wise.
09:57:05 <ski> monochrom : yes
10:00:01 <pjdelport> vile paths
10:00:50 <merijn> Eduard_Munteanu: System.Posix.FilePath or something like that?
10:01:07 <monochrom> \∩/
10:02:05 <Eduard_Munteanu> merijn: nah, I'm working on it myself... absolute, tagged paths without any sort of string interpretation, like slashes or such.
10:02:09 <khyperia> I just discovered this article - http://dev.stephendiehl.com/hask/ - and I learned a bunch from it and wanted to share :)
10:04:28 <Eduard_Munteanu> merijn: basically I want to write things like rsync :: Path Source Directory -> Path Target Directory -> IO () in a way that prevents mistakes (e.g. reversing source and target)
10:04:29 <benmachine> Eduard_Munteanu: pathtype
10:04:38 <benmachine> Eduard_Munteanu: http://hackage.haskell.org/package/pathtype
10:04:44 <stephenmac7> @pf
10:04:44 <lambdabot> Maybe you meant: pl bf
10:04:47 <benmachine> it's a really lovely package that sadly never caught on
10:05:02 <stephenmac7> @pl \x -> and $ map (flip elem x) "aeiouy"
10:05:02 <lambdabot> and . flip map "aeiouy" . flip elem
10:05:04 <benmachine> I think partially because it tied itself to the design decisions of System.FilePath
10:05:30 <ski> Eduard_Munteanu : what is the significance of `Source' and `Target', outside of `rsync' ?
10:05:32 <benmachine> Eduard_Munteanu: pathtype only solves one of your problems, admittedly
10:05:36 <benmachine> but it's cool nonetheless
10:06:00 <benmachine> Eduard_Munteanu: the problem you suggest is addressed in OCaml by having named arguments
10:06:05 <mniip> stephenmac7, I am guessing, http://codegolf.stackexchange.com/q/20936/7162 ?
10:06:12 <Eduard_Munteanu> benmachine: interesting... I pretty much dealt away with relative paths because they have awful semantics, and defined a  type Relative path t = path Directory -> path t
10:06:19 <stephenmac7> mniip: How did you know?
10:06:24 <benmachine> rsync ~source:path1 ~target:path2
10:06:49 <mniip> stephenmac7, because what you poinless-ed is the solution to the task, obviously
10:07:00 <benmachine> Eduard_Munteanu: that's not a bad approach, although your Relative type is waaay bigger than just relative paths
10:07:00 <stephenmac7> :P
10:07:14 <Eduard_Munteanu> ski: it needn't, you can use typeclasses instead:  rsync :: (IsSource s, IsTarget t) => Path s Directory -> Path t Directory -> IO ()   since Source/Target are arbitrary tags
10:07:34 <ski> Eduard_Munteanu : that also sounds strange to me
10:07:45 <benmachine> hmm
10:07:53 <Eduard_Munteanu> They're not strings, btw.
10:07:53 <ski> also, what's considered a target in one part of the program may be considered a source in another part
10:07:59 <stephenmac7> mniip: Yup http://codegolf.stackexchange.com/a/20975/16498
10:08:01 <benmachine> I suppose you'd have a 'source' function to attach the Source tag to an arbitrary path?
10:08:13 <Eduard_Munteanu> ski: yup, but in that case you want to alter the tag manually using a conversion function
10:08:13 <benmachine> ski: sure, that's fine, offer conversions
10:08:18 <benmachine> just make people do that explicitly
10:08:34 <stephenmac7> main = interact $ unlines . filter (and . flip map "aeiouy" . flip elem) . lines
10:08:36 <Eduard_Munteanu> benmachine: data Path :: k -> Type -> * where ....   right now
10:08:53 <ski> this `source' and `target' business sounds reminiscent of insts in Mercury
10:09:06 <Eduard_Munteanu> I'm still not decided whether I should use Tagged or the Path parameter instead.
10:09:33 <Eduard_Munteanu> ski: with DataKinds you can also use lists of tags
10:09:56 <cinimod> I made the mistake of upgrading to Mavericks
10:10:03 <cinimod> Now ghc doesn't work
10:10:12 <geekosaur> see end of /topic
10:10:13 <johnw> google and you'll find tons of answers to that problem
10:10:19 <cinimod> There is much advice
10:10:34 <cinimod> Which particular advice should I follow?
10:10:50 <JuanDaugherty> cinimod, yeah that's why I've avoided it, though it's free
10:10:51 <johnw> the one that involves modifying your settings file to point to gcc4.2
10:10:53 <Eduard_Munteanu> Or perhaps Symbol to provide a base path, but right now I'm not planning on using that.
10:11:02 <stephenmac7> mniip: You can remove whitespace in haskell?
10:11:02 <JuanDaugherty> expectation of much breakage
10:11:12 <mniip> stephenmac7, not all, but a lot of it
10:11:19 <cinimod> johnw: thanks
10:11:29 <mniip> stephenmac7, basically only leave spaces between word characters
10:12:22 <stephenmac7> mniip: How's main=interact$unlines.filter(and.flip map "aeiouy".flip elem).lines
10:12:42 <mniip> yeah
10:13:00 <mniip> that's about it. -14 characters though. Oh, and add the char count in the title
10:13:31 <stephenmac7> mniip: Done
10:13:38 <mniip> i see
10:13:38 <stephenmac7> 67
10:13:53 <stephenmac7> First code-golf I've done
10:13:58 <stephenmac7> Thanks
10:15:00 <flebron> there's no algebra over the IO monad is there? (because that'd mean IO a -> a, and other than unsafePerformIO...)
10:15:24 <ski> Eduard_Munteanu : i see "source" and "target" there above (with `rsync') as names describing the roles that the given arguments will have in a call to (specifically) `rsync', so i'm not sure whether it'd be useful to attach those tags to the values, prior and exterior to the call itself
10:15:35 <mniip> IMHO, haskell is worse than pascal at codegolf
10:15:44 <Cale> flebron: Well, it would mean IO A -> A for some specific type A
10:15:54 <flebron> right right
10:15:59 <mniip> because if you golf haskell, you won't be able to read anything in the mess you create
10:16:05 <Cale> flebron: There ought to be some, but they'll either be trivial, or will somehow involve IO
10:16:06 <flebron> IO a -> a would technically be a natural transformation right?
10:16:06 <ski> (e.g. `A' being `()')
10:16:17 <flebron> for every object a, there's a morphism IO a -> a
10:16:17 <ski> only if you add `forall a.'
10:16:34 <stephenmac7> mniip: At least it's better than those mathematica/javascript solutions
10:16:36 <Eduard_Munteanu> ski: yep, you'd mostly rely on type inference, since it's mostly useful in functions doing multiple filesystem operations
10:17:00 <mniip> stephenmac7, golfscript or J, at least, are still readable when golfed
10:17:02 <ski> Eduard_Munteanu : "rely on type inference" for what ?
10:17:12 <Eduard_Munteanu> ski: as far as I'm interested now, I want "Source" to mean it doesn't alter said files.
10:17:19 <stephenmac7> Golfscript is interesting
10:17:38 <ski> Eduard_Munteanu : ok, that's more interesting them (and sounds similar to the Mercury `in' mode)
10:17:59 <ski> (s/them/then/)
10:18:27 * hackagebot cblrepo 0.11 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.11 (MagnusTherning)
10:18:37 <Eduard_Munteanu> ski: in a larger function you'd probably do like  let src = Root :/: "src"  :: Path Source Directory,  then :/: will thread along that Source tag.
10:19:28 <Eduard_Munteanu> ski: if you try to apply any children of 'src' to a function expecting a target, you'd get a type error
10:20:36 <yesthisisuser> I have created a project for client-side "one-page application" development using Haskell based on UHC-JS: http://johanneshilden.github.io/liquid-epsilon/
10:20:43 <Eduard_Munteanu> Right now I have   data Path :: k -> Type -> * where Root :: Path k Directory; (:/:) :: Path k Directory -> ByteString -> Path k Directory; (:/) :: .... -> Path k File
10:21:16 <yesthisisuser> it is still at an early stage
10:21:27 <stephenmac7> mniip: Performance is good
10:21:40 <mniip> stephenmac7, performace of what
10:21:46 <Eduard_Munteanu> I might want  data Path :: Type -> *  plus (</>) :: Tagged k (Path Directory) ...   instead
10:21:47 <stephenmac7> Haskell solution
10:22:20 <stephenmac7> But I'm not sure whether performance is important in code gold
10:22:22 <stephenmac7> *golf
10:22:44 <monochrom> no algebra IO a -> a. but iO Int -> Int is easy. :)
10:23:01 <stephenmac7> 0.092s for haskell solution, 1.513s for golfscript solution
10:23:21 <monochrom> in general, HasDefault a => IO a -> a is easy :)
10:23:42 <Shin-LaC> I am testing my program with quickCheck, but I'd also like to have some specific test cases
10:23:48 <Shin-LaC> should I use HUnit to do the latter?
10:24:04 <Shin-LaC> or should I have parameterless quickCheck properties?
10:24:07 <ski> Eduard_Munteanu : "if you try to apply any children of 'src' to a function expecting a target, you'd get a type error" -- yes, but possibly the same path should be treated as read-only in some operations and not in others
10:24:41 <Eduard_Munteanu> ski: then you'd promote it to a Target manually
10:25:25 <ski> Eduard_Munteanu : i'm not convinced you'd want to share the tag on the same path often enough between different calls for it to be worthwhile
10:26:10 <twiceler> so I am trying to implement a resizable array in Haskell
10:26:22 <Eduard_Munteanu> ski: I'm working on a Haskell "script" that installs a bunch of files froma source directory into a target one, possibly altering them.
10:26:30 <twiceler> And I am using StablePtrs for elements to make that happen
10:26:34 <cinimod> geekosaur: I downloaded the script, ran it but I still get the same problems
10:26:45 <twiceler> I am wondering if that's a good idea - I'm pretty unfamiliar with StablePtrs
10:27:01 <Eduard_Munteanu> ski: and I don't want to accidentally lose data in the source dir
10:27:12 <ski> twiceler : why not `IORef's or some of the concurrent variants ?
10:27:40 <cinimod> Hmmm the Mavericks patch has patched the wrong ghc: PATCHED: /Library/Frameworks/GHC.framework/Versions/7.4.1-x86_64/usr/lib/ghc-7.4.1/settings
10:27:40 <cinimod>  
10:27:57 <twiceler> ski: I am trying to use realloc, so I need my references to be Storable, and unforunately, IORef doesn't seem to be Storable
10:27:59 <geekosaur> you shouldn't have that installed still
10:28:00 <cinimod> I wonder why it didn't patch 7.6.2
10:28:20 <ski> `Storable' is for marshalling over the FFI, really
10:28:23 <twiceler> ski: (which does surprise me a bit)
10:28:45 <ski> twiceler : what if you'd want to store `(Int,Int)'s in your arrays, e.g. ?
10:28:56 <Eduard_Munteanu> ski: alternative I guess I could use a Writable tag, then   rsync :: (Writable t) => Path s Directory -> Path t Directory -> IO ()
10:29:14 <twiceler> ski: Well I can make a StablePtr to anything
10:29:25 <ski> Eduard_Munteanu : that sounds somewhat better in my ears
10:29:44 <ski> Eduard_Munteanu : anyway, i acknowledge the problem, just not convinced of the solution
10:29:48 <twiceler> ski: Well, I'm using "realloc" for resizing the array, which is C-like and so needs the fixed size stuff. I couldn't think of a better way for dynamic resizing
10:30:07 <geekosaur> cinimod, /Library/Haskell/bin/uninstall-hs to remove older versions, things do tend to break with more than one ghc installed
10:30:31 <twiceler> twiceler: I could just use the GHC arrays and then copy the array entirely when I resize, I guess. I just thought that seemed less efficient
10:31:12 <monochrom> you must copy when resize. there is no other way
10:31:44 <monochrom> not limited to GHC or Haskell. Java has to do it. C has to do it.
10:32:05 <Eduard_Munteanu> monochrom: well, not with realloc() in C
10:32:20 <hpc> realloc will copy too, iirc
10:32:29 <Eduard_Munteanu> hpc: not always
10:32:41 <Eduard_Munteanu> It does that if it can't extend the current region.
10:32:43 <twiceler> I think realloc tries to keep the memory in the same place. I don't know how often it succeds, thgouh!
10:32:48 <monochrom> the only case when you don't have to do it is when you have a Turing machine of unbounded number of tapes
10:33:13 <hpc> also, if you don't mind oodles of implementation complexity you can try fragmenting your stuff
10:33:32 <ski> twiceler : `StablePtr' is to be able to pass off a Haskell value to foreign land, without Haskell attempting to GC it or move it
10:33:57 <twiceler> hpc: I think I'd rather just do the whole array copy
10:34:05 * Eduard_Munteanu thinks twiceler could be better off using something other than an array
10:34:10 <twiceler> ski: So I did already implement it using StablePtrs. It does seem to be working
10:34:33 <twiceler> Eduard_Munteanu: I'm making a heap. Do you have a suggestion that may be better?
10:34:45 <Eduard_Munteanu> Most of the times I've used realloc() was because I was feeling lazy about doing something else more properly.
10:35:24 <ski> twiceler : btw, how did you use `realloc' with your `StablePtr' ?
10:35:43 <twiceler> I'm making a mutable heap, and I want to have immediate access to any element
10:35:50 <ski> `deRefStablePtr', then `realloc' ?
10:35:55 <twiceler> ski: So I have any array of StablePtrs
10:36:02 <Eduard_Munteanu> twiceler: Data.Map? Not sure what heap you actually want, for memory allocation?
10:37:01 <cinimod> geekosaur: Thanks - now the script to fix Mavericks tells me I don't have the Haskell Platform - lol
10:37:02 <twiceler> type Heap e = IORef (Ptr (StablePtr e)))
10:37:33 <twiceler> Eduard_Munteanu: I'm making a priority queue. Really I'm actually making this sort of data structure: https://github.com/clojure/data.priority-map
10:37:38 <geekosaur> aaands that makes me wonder if you followed its directions properly, or if you have other installs (macports/homebrew/etc.) confusing it
10:37:52 <geekosaur> in any case it seems clear you had preexisting problems
10:37:58 <twiceler> Eduard_Munteanu: Which is basically a map combined with a heap
10:39:04 <cinimod> geekosaur: ok but everything worked before Mavericks and I could use both versions of ghc
10:39:22 <twiceler> Everything is working, but I'm wondering if there is a neater way, because I'm afraid of these StablePtrs.
10:39:36 <cinimod> geekosaur: where is the settings file the script talks about
10:39:40 <geekosaur> I am pretty sure it's not expected that things work reliably with more than one version installed
10:40:08 <cinimod> geekosaur: they should otherwise how can one test things work on two versions of the compiler?
10:40:36 <cinimod> geekosaur: Do you happen to know where the settings file alongside the compiler the script talks about?
10:40:38 <geekosaur> they "should" but apple made os x "special" (asyou're currently finding out)
10:40:58 <cinimod> geekosaur: I have
10:41:00 <twiceler> (Also, using these C-like functions, I get to avoid bounds-checking!)
10:41:00 <cinimod> ~/Downloadable/DataScienceLondon/ParkingWestminster $ which -a ghc
10:41:00 <cinimod> /usr/local/bin/ghc
10:41:00 <cinimod> /usr/local/bin/ghc
10:41:03 <cinimod>  
10:41:11 <cinimod> But no settings file
10:41:19 <geekosaur> settings=`ls -1 /Library/Frameworks/GHC.framework/Versions/7*/usr/lib/ghc-7*/settings 2>/dev/null`
10:41:31 <geekosaur> this is only going to work sanely with a single ghc version installed
10:41:32 <kazagistar> here is my latest attempt at writing this particular piece of code [ http://lpaste.net/99984 ]. I am trying to make it simple to lift functions into a machine context of sorts using fundeps
10:42:17 <geekosaur> and it's telling you the path to the settings file (multiple files in your case which is confusing it)
10:42:36 <cinimod> geekosaur: I uninstalled 7.4.1 which removed GHC.framework
10:42:53 <geekosaur> then where did you have 7.6.3 installed?
10:43:08 <cinimod> /usr/local/bin/ghc
10:43:32 <geekosaur> then it's not the haskell platform installer that that script is designed to work with. where did you get /usr/local/bin/ghc?
10:43:49 <geekosaur> because whoever provided it must also provide the xcode fix applicable to their ghc install
10:44:09 <cinimod> Dunno - I have had it for about a year
10:44:10 <geekosaur> if it's from homebrew, you probably want to talk to carter
10:44:24 <kazagistar> my question being "it doesn't work?" since I it seems to me that it should be possible to infer the types from the given code… [ http://lpaste.net/99984 ]
10:44:37 <geekosaur> if you installed it yourself from the ghc binary tarball then you're on your own as far as I know
10:45:03 <cinimod> I think brew installed 7.4.2
10:45:10 <cinimod> Which is still there
10:45:23 <geekosaur> ok, you're running homebrew, talk to carter
10:45:26 <cinimod> Is there any advice
10:45:34 <cinimod> Ok I'll try carter
10:45:51 <cinimod> Or give up with Haskell for the job I am currently doing :-(
10:46:08 <geekosaur> or get your haskell from somewhere else
10:46:30 <cinimod> And rebuild the world? I have many packages I use :-(
10:46:33 <cinimod> Oh well
10:46:50 <geekosaur> the script works for the official haskell platform installer (assuming only one version installed, that might be reportable as a bug but again I don't think they expect multiple concurrent versions to work)
10:46:58 <cinimod> carter: you around?
10:47:10 <geekosaur> if you used macports then you'd have gotten the mavericks fix automatically. I have no idea how homebrew handles it
10:47:24 <Cale> Well, you'll have to reinstall them when you upgrade GHC anyway
10:47:53 <cinimod> I'd rather not upgrade - I am trying to do some data analysis at the moment
10:48:05 <cinimod> I am quite happy with 7.6.2
10:48:41 <kazagistar> I use homebrew. I had to purge haskell platform and ghc (and manually deleted the folders), reinstall from scratch, and apply the fixes
10:51:07 <cinimod> kazagistar: what version of ghc are you on
10:51:49 <kazagistar> cinimod: 7.6.3
10:53:11 <kazagistar> running osx 10.9.1
10:53:30 <kania> hi
10:53:31 * hackagebot int-cast 0.1.0.0 - Checked conversions between integral types  http://hackage.haskell.org/package/int-cast-0.1.0.0 (HerbertValerioRiedel)
10:53:37 <cinimod> Cool - that is the osx I am on
10:53:47 <kazagistar> and I used homebrew to install mostly everything
10:54:07 <cinimod> Me too but maybe my 7.6.2 predates my change to homebrew
10:55:07 <kazagistar> I had to manually patch the configurations on my system though to point compiling to gcc42 instead of llvm
10:55:46 <geekosaur> ...and people wonder why I stick with what just works...
10:55:47 <cinimod> I don't have gcc42
10:56:13 <burbul> Is there some automated way to set up a zipper for an arbitrary ADT? (I know it's related to differentiation... I'm asking a more practical question, about how one does this in Haskell.)
10:56:17 <cinimod> Well I needed 7.6 because a numeric library I was using required it
10:56:34 <monochrom> I don't wonder why. I stick with what just works, too
10:56:50 <kazagistar> cinimod: brew install apple-gcc42, its in this guide https://gist.github.com/cartazio/7131371
10:57:06 <cinimod> Cool - thanks
10:57:22 <cinimod> I knew I shouldn't have upgraded to Mavericks
10:57:46 <kazagistar> yeah, it nuked Java pretty hard too
10:57:47 <johnw> it's a 30 second change after installing gcc42
10:58:31 <skuggi> is there a framework for testing stuff that's generated with template haskell?
10:59:54 <skuggi> I mean where the TH-generated stuff would have to be compiled for each test.
10:59:56 <enthropy> skuggi: what kinds of things is a framework going to help you with that problem?
11:00:53 <enthropy> you can write a DecsQ that writes test1 through test100
11:00:58 <heath> https://github.com/codeparty/racer
11:01:02 <heath> Anything like this in haskell land?
11:01:09 <burbul> I have an ADT for, basically, first order logic: http://lpaste.net/99986
11:01:33 <enthropy> and the hunit/hspec or whatever that tells you about the testN that failed
11:01:48 <burbul> And I need to nondeterministically pick one term inside a given formula and do something to it.
11:02:08 <burbul> So an example we could print out a formula repeatedly, with each copy having one term bolded.
11:02:28 <burbul> It feels like there should be a slick way of doing this, and AFAICS zippers must be part of the answer...
11:02:39 <burbul> Though I've never used them in anger before.
11:02:40 <skuggi> enthropy: yeah, i guess that would work pretty well. I was hoping that there was something to make it a little nicer.
11:03:47 <Shin-LaC> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Structure_of_a_simple_project <- this says that HUnit should be used only to test impure code
11:04:26 <Shin-LaC> so if I want to test some known-good cases of a pure function, should I shoehorn them into a quick check property?
11:04:39 <cinimod> kazagistar: brew tells me that gcc42 and apple-gcc42 are not available
11:05:13 <kazagistar> cinimod: did you brew update?
11:05:21 <cinimod> yes
11:05:24 <johnw> cinimod: you're not reading the things we're linking to
11:05:32 <cinimod> gcc48 seems to exist
11:05:34 <johnw> the last link you were given clearly says brew tap homebrew/versions
11:06:07 <cinimod> johnw: which link - I went to the topic as suggested
11:06:14 <johnw> check your scrollback
11:06:47 <skuggi> enthropy: you don't know of any way of compiling a TH expression and running it at runtime? then i could use quickcheck :)
11:06:56 <monochrom> Shin-LaC: usually quickcheck, but if you prefer HUnit go ahead, I don't usually care what other people think
11:07:27 <Shin-LaC> I'm already using quickcheck
11:07:38 <cinimod> johnw: I searched backward for cinimod but I didn't find anything
11:08:00 <johnw> 12:51 <kazagistar> cinimod: brew install apple-gcc42, its in this guide https://gist.github.com/cartazio/7131371
11:08:06 <monochrom> otoh whenever laws are available, I care less about test cases
11:08:24 <Shin-LaC> I'm just wondering if it's considered "wrong" to have something like prop_test_1 = (Circle 0 0 5) `intersect` (Line 0 0 0 1)
11:08:26 <cinimod> Ok found it
11:08:37 <monochrom> test cases are for when you can't write down laws that cover those test cases and infinitely more
11:09:05 <Shin-LaC> but sometimes it's hard to write a property that doesn't just do exactly what the function being tested does
11:09:21 <monochrom> in other words, test cases are a confession of failure
11:09:45 <Shin-LaC> I have a function that checks whether a line intersects a circle
11:09:48 <Shin-LaC> how would I test that?
11:10:03 * geekosaur will just be amused at what homebrew folks are willing to put up with to avoid something that just works and is therefore uncool
11:10:29 <joelteon> machomebrew?
11:10:39 <kazagistar> geekosaur: what "just works"?
11:10:46 <Shin-LaC> to make a law, I'd have to find a different way to check intersection
11:10:51 <enthropy> skuggi: no
11:10:52 <monochrom> in that case I too confess failure
11:10:57 <Shin-LaC> then I could write c intersects l if c intersects2 l
11:11:00 <Shin-LaC> but it's not always easy
11:11:05 <Shin-LaC> ok
11:11:11 <Shin-LaC> so I guess I'll have some concrete cases too
11:11:29 <joelteon> i'd just go with four or five basic test cases
11:11:30 <monochrom> but only because I'm too lazy to work on it. "lazy" means "not paid enough"
11:11:47 <joelteon> actually 3 might be enough
11:14:19 <enthropy> skuggi: you can still use methods from Arbitrary to generate those definitions you're generating
11:14:31 <enthropy> but I guess shrink is not really reasonable
11:15:01 <skuggi> yeah, shrink would be difficult
11:15:50 <cinimod> johnw: I think I have followed the instructions: xcode-select --install ; brew tap homebrew/versions; brew install apple-gcc42
11:16:08 <cinimod> But no dice: Error: No available formula for apple-gcc42
11:17:28 <johnw> not sure what's going on there; I have apple-gcc42 installed
11:17:56 <cinimod> brew tap homebrew/dupes seemed to fix it
11:18:07 <cinimod> I have no idea why
11:18:11 <johnw> hmm
11:18:14 <johnw> i do have that tapped also
11:18:17 <johnw> maybe carter should be told
11:18:37 <pantsman> ugh, I don't like functions where the name only makes sense if you use it infix, like a `using` b, it's horrible
11:18:43 <cinimod> Spoke too soon
11:18:51 <cinimod> Error: The `brew link` step did not complete successfully
11:20:05 <cinimod> Something to do with fortran (well I did say I was doing numerical stuff)
11:20:08 <monochrom> that's a fundamental property of transitive words
11:20:15 <aloiscochard> why there isn't something like `eitherToMaybe = either (const Nothing) Just` in the library? is it considered evil?
11:20:16 <monochrom> er, transitive verbs
11:20:30 <monochrom> and I am not sure that you could avoid transitive verbs at all
11:20:40 <johnw> aloiscochard: I'm pretty sure that's called 'hush'
11:20:42 <johnw> :t hush
11:20:43 <lambdabot> Not in scope: `hush'
11:21:10 <aloiscochard> johnw: I ask hoogle, but found nothing
11:21:14 <aloiscochard> asked*
11:21:18 <johnw> yes, here: http://hackage.haskell.org/package/errors-1.4.5/docs/Control-Error-Util.html
11:21:27 <theorbtwo> In English, anyway.  They could be worse -- they could act like seperable verbs in German!
11:22:24 <kazagistar> aloiscochard: there is a generic form of it called simply "either"
11:22:51 <aloiscochard> kazagistar: yeah but it's not cool in term of syntax in that specific case, or am I missing something?
11:23:26 <kazagistar> aloiscochard: either Just (\_->Nothing)
11:23:49 <griffins> what colors would you say is associated with start and finish? a start flag would be what color? and a finish flag? (this is for a haskell agem)
11:24:06 <aloiscochard> kazagistar: yeah, which is basically how I defined eitherToMaybe in my example
11:24:22 <khyperia> Hmm... my dad had a good point about functional and testing. Say for example you have a phoneCall method that has a usage of callBilly, and you want to test the callBilly method (but not actually call billy). How would you pass in an nonspecific-implementation of phoneCall that's testable? Pass as a function parameter, or typeclass, or what?
11:24:25 <aloiscochard> kazagistar: any reason not having the specific form?
11:25:58 <kazagistar> aloiscochard: it seems like typing eitherToMaybe is not much better then typing (either Just (\_->Nothing))? keeps things simple, and you would have to define a eitherToMaybe left and right side
11:27:01 <aloiscochard> kazagistar: the method name could be just 'left' and 'right'
11:27:06 <aloiscochard> that's how it's done in scala
11:27:18 <aloiscochard> s/method/fuctions
11:27:24 <aloiscochard> sorry for the blasphemery ;-)
11:27:46 <aloiscochard> kazagistar: there is 'lefts' and 'rights'
11:27:53 <aloiscochard> I would love the singular equivalent
11:27:55 <khyperia> aloiscochard, isn't that the exact same as lens _Left/_Right? (I just started learning lens, not sure)
11:28:13 <aloiscochard> khyperia: oh, interesting.
11:28:27 <aloiscochard> khyperia: I haven't yet played with Lens, but that might be there indeed. would make sense
11:28:31 <shachaf> preview _Left :: Either a b -> Maybe a
11:29:02 <aloiscochard> shachaf: what is that? it's from lens?
11:29:08 <khyperia> yeah, it's from lens
11:29:18 <aloiscochard> awesome, thanks shachaf and khyperia
11:30:28 <khyperia> there's a few concepts of getters/setters in lens, two of which are "will succeed in get/set" and "might succeed in get/set", Maybe is of the latter type. A former type might be a tuple - the get/set will always be there.
11:30:45 <khyperia> err, *Either is of the latter type
11:31:56 <pantsman> monochrom, the problem stems from trying too hard to make code read like English, not from transitive verbs. It's the COBOL disease.
11:32:58 <monochrom> ok, do you support using symbols instead of words?
11:33:00 <pantsman> I'm not railing against anyone ever using transitive verbs for function names, it's just irritating when an author thinks, "oh I'll use that word just so I can do a cute infix syntax"
11:33:38 <BrianHV>  /j #scotty
11:33:41 <BrianHV> er...
11:33:55 <cinimod> Woohoo - thanks everyone for your help - sorry for being so annoying
11:34:05 <BrianHV> and it's not even a real channel...
11:35:04 <pantsman> it means that the illusion of the DSL falls apart if you don't want to use infix
11:35:33 <pantsman> the operands turn out to be the wrong way round
11:36:11 <pantsman> sorry, rant over
11:36:57 <theorbtwo> Symbols are ungooglable, non-self-documenting, and likely to conflict with each-other.
11:37:04 <aloiscochard> btw, if some have an idea about how to fix a TODO in there: http://lpaste.net/99991 ...
11:37:16 <aloiscochard> I have the feeling I could avoid that 'return . return' in some way
11:37:25 <aloiscochard> s/some/someone/
11:37:39 <theorbtwo> The middle one can sometimes be overcome, of course, if there's a well-recognized symbol in the community of interest for something, but still only sometimes.
11:38:01 <theorbtwo> ...and it can't be too well recognized, or it'd be easy to type, and thus already used for something else.
11:38:02 <kazagistar> theorbtwo: symbols require custom search, that is why I bookmarked hoogle as soon as I started learning haskell
11:38:17 <Maior> :t return . return
11:38:18 <lambdabot> (Monad m, Monad m1) => a -> m (m1 a)
11:38:24 <theorbtwo> Want to make a $ operator that actually works with dollars?  Too bad, $ already means something else.
11:38:37 <pantsman> we can do better than make Google our standard for code documentation search
11:39:40 <aloiscochard> Maior: do you think that could be avoided?
11:40:43 <kazagistar> theorbtwo: how would you use $ as a currency thing? You cannot use it as a prefix, and it makes no sense as an infix, right?
11:41:01 <theorbtwo> kazagistar: You do have a certian point...
11:42:16 <plhk> any idea why cabal is trying to downgrade text? http://lpaste.net/99992
11:43:17 <monochrom> yes, read my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon , in fact read the whole thing
11:43:49 <td123> plhk: because pipes-attoparsec depends on text < 1.1
11:44:13 <Maior> aloiscochard: not seeing an obvious way, sorry
11:44:43 <aloiscochard> Maior: thanks for trying
11:45:13 <kazagistar> ill re-ask my question from earlier… I am trying to figure out how to make something like this work, where address can be used to load and save storables from specific locations the machine: op :: (Storable a, Storable b, ... Storable n) => (a -> b -> ... -> n) -> Address -> Address -> ... -> Address -> State Machine ()
11:45:19 <merijn> aloiscochard: You could eliminate it with MaybeT transformer, but that seems overkill here, better of with just "return.return", I think
11:45:34 <kazagistar> here is my code attempt: http://lpaste.net/99984
11:45:38 <plhk> td123: ah, i see, thanks
11:45:55 <aloiscochard> merijn: I see, I had a gut feeling that the response will include "Transformer"
11:46:04 <Maior> aloiscochard: I sort of want to play around with that function and break it down more though; I've got dinner to make, but I'll try to find some time to jiggle it
11:46:13 <aloiscochard> merijn: thanks, I'll read on that for general knowledge anyway
11:46:26 <merijn> kazagistar: So you're trying to write an "op" function that will work for any number of arguments as long as they're statically known at compile time?
11:46:34 <aloiscochard> Maior: that would be awesome :-) I'm mostely always on IRC please ping if you find something!
11:47:10 <kazagistar> merijn: yes
11:47:37 <monochrom> "MaybeT IO a" is just a newtype for "IO (Maybe a)". you only gain 1% shorter syntax and no improvement in semantics
11:47:38 <merijn> kazagistar: I did something like that once
11:47:59 <merijn> kazagistar: See the apply function in: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs
11:48:06 <johtso> Does anyone use SublimeHaskell? I'm having trouble getting started with it on OSX, when I try to "Run" my code it tells me there is nothing to run
11:48:33 <johtso> I'm probably doing something stupid when it comes to cabal, assuming it uses that to work out what to run
11:48:40 <merijn> kazagistar: I have a heterogeneous list defined in https://github.com/merijn/SNet2.0/blob/master/SNet/Pattern.hs and then verify that the list matches the arguments of a function and then apply them all
11:48:52 <kazagistar> merijn: in the worst case, if I don't get it to work, I will just write a lot of specific functions up to "how many I think I might need", like the tuple functions
11:48:59 <merijn> kazagistar: Maybe that'll inspire a solution in you
11:49:00 <johnw> monochrom: how is that true?
11:49:07 <aloiscochard> monochrom: still, that look better to me :-) I'll give a try to see how it look
11:49:17 <johnw> monochrom: with MaybeT, if you "x <- foo" where foo returns a Nothing, evaluation stops.  With IO (Maybe a), evaluation would not stop
11:49:26 <johnw> i mean, execution, sorry
11:49:34 <aloiscochard> oh
11:50:21 <merijn> kazagistar: In general I think you can do what you want, but you probably need typefamilies (or rather, that's what I'd use, I find type families more intuitive than fundeps)
11:50:21 <johtso> "cabal run" works
11:50:23 <monochrom> I forgot that part
11:50:31 <aloiscochard> interesting
11:51:31 <monochrom> now I have to call it either "50% shorter syntax, no change in semantics" or "1% short syntax, different semantics"
11:52:53 <monochrom> the former can be rationalized by: suppose you use IO (Maybe a) but you always write like "x <- foo; case x of Nothing ... Just ..."
11:53:39 <johnw> I use MaybeT every once in a while, when the alternative would be case statements nested 4-5 deep
11:53:54 <monochrom> yes
11:54:17 <johnw> what's annoying is when you use actual IO (Maybe a) actions with it
11:54:54 <johnw> no, not that
11:54:57 <johnw> there was something else
11:55:10 <johnw> pure Maybe a?  MaybeT $ return $ foo
11:55:10 <johnw> yeah
11:55:27 <johnw> seems like there should be a helper function for that
11:56:08 <roconnor__> maybe mzero return $ foo
11:56:10 <Eduard_Munteanu> johnw: x <- MaybeT $ ioActionReturningMaybe   ?
11:56:16 <johnw> right
11:56:27 <johnw> now how about pureFunctionReturningMaybe, where you want the short-circuiting
11:56:30 <jfischoff> is there a reason that there is no FakeQuasi for testing template haskell code?
11:56:34 <Eduard_Munteanu> You can use liftIO too though.
11:57:44 <roconnor__> jfischoff: I think mfold foo works
11:57:45 <roconnor__> er
11:57:47 <roconnor__> sorry
11:57:54 <roconnor__> johnw: I think (mofld foo) works
11:57:58 <roconnor__> *mfold
11:58:07 <jfischoff> if only that was all I needed ;)
11:58:07 <roconnor__> also mfromMaybe
11:58:07 <bennofs> @ty mfold
11:58:08 <lambdabot>     Not in scope: `mfold'
11:58:08 <lambdabot>     Perhaps you meant one of these:
11:58:08 <lambdabot>       `fold' (imported from Data.Foldable),
11:58:09 <Eduard_Munteanu> 'arr' perhaps?
11:58:11 <johnw> what is mfold?
11:58:17 <bennofs> @ty F.mfold
11:58:19 <lambdabot> Couldn't find qualified module.
11:58:21 <Eduard_Munteanu> :t foldM
11:58:21 <roconnor__> mfold :: (MonadPlus m, Foldable t) => t a -> m a
11:58:22 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:59:06 * roconnor__ makes no claims about efficency
11:59:47 <roconnor__> oh wait, this is from some library called monadplus
11:59:51 <roconnor__> sorry
11:59:53 <merijn> The wikibook mentions 2 functor laws "fmap id x == id x" and "fmap (f . g)  ==  fmap f . fmap g", but doesn't the second follow from the first?
12:01:31 <monochrom> something about parametricity helps you derive one of them, yes. but parametricity is too specific. an arbitrary category may lack it.
12:01:33 <roconnor__> merijn: If you invoke parametericity, I think it does.
12:01:59 <Eduard_Munteanu> merijn: no, in CT this would look like    F(id_A) = id_B   F(f o g) = F(f) o F(g)
12:02:26 <cinimod> merijn: this certainly isn't true in general
12:02:33 <Eduard_Munteanu> F(id_A) = id_F(A), rather
12:02:42 <merijn> I'm not asking about in general, I'm asking about Haskell
12:02:54 <monochrom> then you are right
12:02:59 <shachaf> merijn: If F is a Functor, and foo :: (a -> b) -> F a -> F b, and foo id = id, then foo (f . g) = foo f . foo g
12:02:59 <merijn> ok
12:03:29 <monochrom> but I still appreciate explicating the "redundant" law because it is far far far from obvious to me
12:03:33 <merijn> shachaf: Yeah, that's what I thought, hence my confusion on every web page insisting on two laws
12:03:39 <cinimod> What's your proof?
12:03:48 <shachaf> I haven't seen a proof that doesn't assume that F is a Functor. So maybe there exists a non-Functor F and function foo :: (a -> b) -> F a -> F b and foo id = id without the other law.
12:03:56 <shachaf> merijn: Well, ==monochrom
12:04:57 <shachaf> @free foo :: (a -> b) -> F a -> F b
12:04:57 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
12:05:05 <merijn> cinimod: Well, logicall if "fmap id == id" then "fmap f . fmap id" must be the same as "fmap f . id" must be the same as "fmap f"
12:05:35 <shachaf> Oh, that's hardly sufficient.
12:05:42 <merijn> cinimod: And since we know that "fmap f" can't change the structure (because "fmap id == id"), then "fmap f . fmap g" must be "fmap (f.g)"
12:05:55 <cinimod> How does that prove that fmap f . fmap g == fmap (f . g)?
12:06:17 <shachaf> OK, so you're using a parametricity sort of argument too.
12:06:32 <merijn> cinimod: Well, how could they *not* be the same?
12:06:50 <merijn> cinimod: We know 2 things 1) fmap can't change the structure, or "fmap id == id" wouldn't hold
12:07:04 <merijn> cinimod: 2) fmap *must* affect all values, because else the type is wrong
12:07:48 <monochrom> parametricity is very tricky to explain. so far, most intuitive explanations (except mine) are based on lack of imagination.
12:08:08 <cinimod> merijn: I think I'd like a bit more detail
12:08:23 <cinimod> There's plenty of famous proofs that turned out not to be proofs after all
12:08:26 <merijn> cinimod: If the structure doesn't change, then "first applying g to every leaf in a structure preserving way, then applying f to every leaf in a structure preserving way" must be the same as "applying (f.g) to every leaf in a structure preserving way"
12:09:01 <merijn> cinimod: Well, the fact that there can only be on valid fmap for a given type is a free theorem
12:09:01 <Shin-LaC> I want to restrict the objects generated by an Arbitrary instance in quickcheck
12:09:04 <shachaf> monochrom: What is yours?
12:09:12 <Shin-LaC> I am generating polygons, but I only want to generate non-self-intersecting ones
12:09:18 <Shin-LaC> I have the self-intersection check
12:09:27 <Shin-LaC> how can I "filter" the arbitrary instance?
12:09:48 <roconnor__> Shin-LaC: guard?
12:09:53 <monochrom> mine is "you are not allowed type-case or equivalent". so, rather than me lacking imagination, I confine your imagination.
12:10:16 <monochrom> it's slightly better because I make explicit what you should lack
12:10:17 <cinimod> merijn: ok - I just looked at Wadler's original paper
12:10:40 <Shin-LaC> roconnor__: I don't find "guard" in the quick check documents
12:10:45 <merijn> cinimod: Basicall "fmap f . fmap g" NOT being equal to "fmap (f.g)" means there MUST be a structural change
12:10:46 <roconnor__> @type guard
12:10:47 <Eduard_Munteanu> monochrom: I think some form persists even with typecase
12:10:47 <lambdabot> MonadPlus m => Bool -> m ()
12:11:05 <Shin-LaC> oh
12:11:11 <merijn> cinimod: Because, f and g are pure functions, so first applying f and then g or doing it one go is irrelevant, they always produce the same result, no?
12:11:24 <roconnor__> Shin-LaC: ah gen isn't a monad plus
12:11:24 <Shin-LaC> where would I place that?
12:11:33 <merijn> cinimod: So the specific values returned by "f first, then g" must be the same as from "f.g"
12:11:36 <roconnor__> Shin-LaC: My plan is foiled
12:11:52 <Shin-LaC> hm
12:11:58 <merijn> cinimod: Any difference must come from the additional fmap, which can only impact anything if fmap affects the structure of the data
12:12:11 <Shin-LaC> there is suchThat
12:12:12 <merijn> cinimod: However, "fmap id == id" already disallows structural change
12:12:36 <merijn> cinimod: Make sense?
12:12:39 <shachaf> MonadPlus is a monoid in the two different categories of endofunctors.
12:12:44 <shachaf> s/the //
12:12:59 <roconnor__> Shin-LaC: suchThat sounds good
12:14:26 <kazagistar> I just had to implement an attempt to break the rule to get it
12:15:15 <kazagistar> http://lpaste.net/99993
12:15:32 <cinimod> merijn: it makes sense but I still feel uneasy as it certainly isn't true in general. What is it about Haskell that makes it true? It would be nice to make this explicit somehow.
12:15:40 <cinimod> That's not a request for a proof
12:15:46 <cinimod> Just thinking out loud
12:17:08 <BMeph> cinimod: Wait, what isn't true in general?
12:17:15 <kazagistar> cinimod: its because the only thing you can "do" in a function is what you have been given, and fmap has not been given almost anything, which limits it at an intuitive level
12:17:49 <bennofs> How would you write this function for non-empty lists (for example, semigroups provides NonEmpty): insertAfter :: (a -> Bool) -> a -> NonEmpty a -> NonEmpty a, which inserts 'a' after the element for which the condition is true.
12:17:59 <cinimod> In a general category fmap id == id does not implu fmap (g . f) == fmap g . fmap f
12:20:13 <bennofs> I was not able to write the function without duplicating the code for empty lists too or using unsafe functions (NonEmpty.fromList)
12:20:14 <merijn> cinimod: I dunno, I'm not a CT person, so I dunno why it *doesn't* hold in CT
12:20:38 <merijn> cinimod: If you explain my why it doesn't hold in CT, maybe I can clarify why the same problem doesn't happen in haskell
12:21:58 <Rotaerk__> Cale: here's some code demonstrating what I was talking about yesterday  http://lpaste.net/6834453648488005632
12:22:41 <kazagistar> is it possible to have incomplete functions in CT perhaps? where fmap is only defined for some functions but not for others?
12:23:03 <cinimod> merijn: I am trying to think of an example
12:23:38 <Eduard_Munteanu> kazagistar: that wouldn't be a functor
12:24:18 <cinimod> How about a function which goes from Set to Group
12:24:21 <kazagistar> Eduard_Munteanu: thats the point of the discussion though, we are defining what the rules are for a Functor, right?
12:24:27 <Rotaerk__> Cale: I'd just need to add some kind of metadata component to each of the concepts, and then create some template haskell function for generating the Game aggregate
12:24:35 <Rotaerk__> functions* most likely..
12:24:36 <cinimod> Then the identity function is a group homomorphims
12:24:58 <Eduard_Munteanu> kazagistar: I mean Functor wouldn't fit a CT functor then.
12:24:58 <merijn> cinimod: Is it maybe that all haskell functors are endofunctors?
12:25:03 <cinimod> Not that doesn't work
12:25:22 <johnw> is there a way to have cabal build tests (as with --enable-tests), but not run them when installing?
12:25:38 <simukis_> How can I promote groupBy :: (a -> a -> Bool) -> [a] -> [[a]] to groupByMish :: Monad m => (a -> a -> m Bool) -> [a] -> m [[a]]?
12:25:40 <Eduard_Munteanu> merijn: all Functors, but not all functors
12:25:54 <cinimod> :)
12:26:10 <Eduard_Munteanu> merijn: you can define generic functors
12:26:39 <Eduard_Munteanu> Hask-based / enriched, which may be rather pure compared to Set.
12:26:46 <shachaf> I think it was obvious what merijn meant.
12:26:47 <Eduard_Munteanu> s/pure/poor/
12:26:50 <cinimod> merijn: I should really go back to work
12:27:22 <merijn> cinimod: I'd say the same, but I'd be lying :p
12:27:23 <cinimod> shachaf: I agree
12:27:28 <cinimod> lol
12:27:29 <shachaf> merijn: Take a monoid homomorphism as an example.
12:27:54 <shachaf> I.e. a function f : M -> N where f(1) = 1 and f(ab) = f(a)f(b)
12:28:22 <shachaf> You can -- hmm, the example I was thinking of was backwards.
12:28:29 <merijn> I'm not smart and/or drunk enough for this :\
12:28:32 <cinimod> I know what merijn is saying but I'd like to know what distinguishes Haskell from a general category
12:28:36 <monochrom> simukis_: I am not convinced that it is a promotion, or that it is easy. when you go from "... -> [[a]]" to "... -> m [[a]]", it's an easy promotion, I agree. but at the same time you also go from "(a->a->Bool) -> ..." to "(a->a-> m Bool) -> ...", that's a demotion
12:29:16 <cinimod> Anyhow I really really should do some work
12:29:29 <cinimod> Or my colleagues will be disappointed
12:29:45 <Eduard_Munteanu> cinimod: well, type theoretic universes are quite restricted compared to usual sets, e.g. you can't union them, you can't talk about certain constructions...
12:30:35 <cinimod> Eduard_Munteanu: agreed - the mathematician in me wants to know the minimum assumptions
12:30:42 <simukis_> monochrom: I basically want to do monadic action inside the (a -> a -> Bool) part. That's the only sensible type I could think of. Currently am trying to spin of a custom function instead but if there was a simple solution I would really appreciate it.
12:30:48 <cinimod> Maybe some day someone will write a paper
12:30:57 <cinimod> Perhaps it has already been written
12:31:00 <Eduard_Munteanu> cinimod: those assumptions are the basic typesystem axioms
12:31:10 <monochrom> there is no simple solution for that reason. a custom function is as good as you can get
12:31:44 <BMeph> :t mapM
12:31:45 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:33:06 <kazagistar> I suspect haskell cannot do function matching, which is the difference? "instance Functor T where fmap (id) = id" ie, fmap only defined for the function id but nothing else would satisfy the first constraint but violate the second?
12:34:25 <BMeph> kazagistar: If there are no examples, then there are no violating example, no? ;)
12:34:36 <Eduard_Munteanu> kazagistar: that 'fmap' would be partial
12:36:31 <kazagistar> Eduard_Munteanu: is that an additional constraint then?
12:37:57 <rawtass> > fmap (\x -> x * 0.1) [1 .. 10]
12:37:59 <lambdabot>  [0.1,0.2,0.30000000000000004,0.4,0.5,0.6000000000000001,0.7000000000000001,0...
12:38:04 <merijn> kazagistar: You're right you can't match on functions
12:38:15 <rawtass> why is the result varying like that?
12:38:27 <merijn> rawtass: Because floating point
12:39:11 <merijn> rawtass: The answer to any question of the form "Why does X happen when I use floating points?" is answered by "Becase IEEE754 says so."
12:39:40 <rawtass> merijn: yes.. right..
12:41:59 <johnw> but do note that how floating point numbers are rendered to decimal can vary from library to library
12:42:21 <johnw> IEEE754 defines binary floating-point, not decimal conversion requirements
12:42:41 <kazagistar> > fmap (\x -> x * 0.1) [1 .. 10] :: [Ratio Integer]
12:42:42 <lambdabot>  [1 % 10,1 % 5,3 % 10,2 % 5,1 % 2,3 % 5,7 % 10,4 % 5,9 % 10,1 % 1]
12:42:47 <kazagistar> problem solved ;)
12:43:36 <Shin-LaC> ok, I think I have enough quick check tests
12:43:45 <Shin-LaC> I found several bugs
12:43:51 <johnw> kazagistar: if you need them, the 'numbers' library can give you better floating points in decimal.  It would give you 0.3 instead of that monster up above
12:43:53 <Shin-LaC> in a bunch of edge cases
12:43:55 <Shin-LaC> quickcheck is great
12:45:08 <merijn> Also Data.Fixed
12:45:38 <johnw> well, Data.Fixed is for when you know how many places of precision you'll want
12:45:47 <Forgetaboutit> so what type would you use for financial calculations?
12:45:52 <johnw> Rational Integer
12:45:57 <johnw> Ratio Integer, sorry, aka Rational
12:46:15 <johnw> *unless* you're accounting requires fixed precision accounting
12:46:24 <johnw> but that's not the most common
12:47:23 <kazagistar> doesn't accounting do continuously compounding interest sometimes? Ratio Integer is not enough to deal with that
12:47:35 <johnw> why not?
12:47:40 <johnw> you can compute the interest at any point in time
12:47:50 <kazagistar> cause E is irrational?
12:48:14 <johnw> i don't follow
12:49:41 <kazagistar> continuous compounding formulas require the use of the variable e, which is an irrational number, and thus cannot be represented as a Ratio Integer and cannot be used in the same formulas?
12:49:48 <LnL> v
12:49:58 <kazagistar> s/variable/constant/
12:51:19 <Eduard_Munteanu> kazagistar: you can just compute when needed, instead of accumulating errors
12:53:21 <kazagistar> right, but if you need results from those continuous compoundings in other computations, then you will have to store those results in non-rational data types, and carry along error anyways
12:54:58 <kazagistar> irrational numbers taint your computation, so anything that uses the result of a computation that has an irrational number as an input must itself be capable of representing an irrational number
12:55:36 <c_wraith> I've never seen accounting do continually compounding interest.  It always has dates where interest is due, and calculated at that time.
12:56:01 <kazagistar> I suspect that is because of this to some extent :P
12:56:37 <c_wraith> anyway, this is all simple, let's just do accounting with CReal
12:56:54 <shachaf> You don't need to be able to represent every irrational number just to represent things involving e.
12:57:12 <c_wraith> CReal can't represent most irrational numbers!
12:57:59 <shachaf> That supports my point.
12:58:18 <c_wraith> Nothing can represent most irrational numbers.
12:58:28 <c_wraith> ...  in finite memory, anyway
12:58:44 <kazagistar> lazily evaluated computations?
12:58:45 <shachaf> From the perspective of a consumer of CReal, though...
12:59:06 <c_wraith> kazagistar: that's what CReal is.  Computable Real
12:59:24 <kazagistar> cool, I didn't know about that one, seems legit
12:59:24 <c_wraith> kazagistar: but most irrational numbers aren't computable
12:59:33 <shachaf> CReal can't even represent all computable reals.
12:59:34 <hodapp> that kinda means nothing can represent most numbers.
12:59:47 <Forgetaboutit> c_wraith: I eat cereal for breakfast ;).
12:59:49 <FireFly> shachaf: what a misnomer
12:59:50 <hodapp> since, when you get down to it, most numbers are irrational.
12:59:52 <startling> c_wraith, symbolic math?
13:00:04 <c_wraith> hodapp: assuming you call the incredibly-poorly-named "real numbers" numbers.
13:00:05 <StoneSurfer> hodapp: given that those ones don'
13:00:14 <StoneSurfer> hodapp: given that those ones don't really get used, I doubt that's a practical problem
13:00:17 <kazagistar> c_wraith: any number that is not computable is not particularly relevant in programming, right?
13:00:31 <hodapp> kazagistar: go tell that to Gregory Chaitin!
13:00:37 <c_wraith> kazagistar: there are a few that are, by constructure, like Chaitin's constant
13:00:41 <c_wraith> *construction
13:00:46 <hodapp> c_wraith: I name-dropped him first, I win
13:01:09 <shachaf> Lots of uncomputable things would be great for programming. Like a solution to the halting problem.
13:01:22 <shachaf> By which I mean something like the thing c_wraith said.
13:01:26 <c_wraith> calculating chaitin's constant is solving the halting problem, yes.
13:02:38 <kazagistar> just to make it clear, computing in this context means "computing a representation that is arbitrarily close the the actual value", right?
13:02:45 <c_wraith> kazagistar: yes
13:03:51 <kazagistar> c_wraith: also, I think our definition of "relevant to programming" is different. I only meant numbers that are actually things you can use in a program, so my statement was meant as a tautology
13:04:26 <c_wraith> Yes, I was just making an oblique point based on your exact wording.  You obviously can't compute in a meaningful way with noncomputable numbers.
13:04:55 <hodapp> c_wraith: You possibly could still do some level of computation, if you can define some aspects of that number's properties.
13:05:16 <c_wraith> I mean, you can do polynomials where x = Chaitin's constant to "compute with non-computable numbers".  But that's just treating it the same as if it was an unknown.
13:06:21 <jmcarthur> for what it's worth, we can't represent most rational numbers either.
13:06:31 <c_wraith> that's just a memory issue.
13:06:36 <jmcarthur> doesn't mean we can't do useful things involving rational numbers
13:06:55 <shachaf> We can represent them in the sense that there exists a Haskell program that represents them.
13:06:58 <shachaf> Even if we can't run it.
13:07:14 <ski> simukis_ : `groupBy' doesn't contain enough information to be able to derive `groupByMish' from it
13:07:17 <hodapp> And if dealing with rationals at some level of abstraction is fine, other levels of abstraction of dealing with quantities that are certain levels of uncomputable might still be useful
13:11:07 <kazagistar> where do uncomputable irrationals fit into CT? they seem like a slightly different thing, less like a Number and more like a Something -> Number?
13:11:47 * hodapp shrugs
13:11:48 <jmcarthur> there are even some rational numbers for which the smallest possible haskell programs to represent them are too large to fit into memory.
13:11:56 <jmcarthur> and so on
13:12:28 <ski> kazagistar : not sure it has much in particular to do with CT
13:13:00 <kazagistar> jmcarthur: for proof see pigeonhole principle, right?
13:13:05 <shachaf> jmcarthur: By "exists" I don't mean "fits in memory".
13:13:16 <jmcarthur> shachaf: understood
13:13:38 <jmcarthur> kazagistar: that seems a reasonable approach
13:14:16 <jmcarthur> i wonder what the largest number one could represent as a tweetable haskell expression is
13:14:38 <jmcarthur> and i wonder if this could be the basis of some weird sort of language wars :P
13:15:10 <kazagistar> jmcarthur: I am SURE you could get far far past grahams number
13:15:20 <shachaf> There was such a contest for pseudo-C.
13:15:31 <johnw> kazagistar; import Data.Number.Natural; x = infinity
13:15:51 <kazagistar> I think the "finite" restriction was implied
13:16:01 <shachaf> jmcarthur: http://djm.cc/bignum-results.txt
13:16:13 <jmcarthur> johnw: i'm going to say it must be a rational number
13:16:34 <shachaf> Why not Integer?
13:16:43 <jmcarthur> shachaf: integers are rational, so that would be fine
13:18:28 <hodapp> jmcarthur: I have a feeling that this problem itself is undecidable...
13:18:44 <hodapp> that of finding the largest number a tweetable Haskell expression can represent
13:18:54 <hodapp> sounds similar to the busy beaver function
13:20:35 <jmcarthur> hodapp: i think you are probably right, but it would be a neat contest at least :)
13:21:02 <hodapp> jmcarthur: would you say that it's the rightest that a person could be in the number of characters I used?
13:23:36 <jfischoff> Is there a simple XML library like 'xml' that uses Text instead of String?
13:26:30 <jfischoff> look xml-conduit might be my best bet
13:28:48 * hackagebot pipes-text 0.0.0.7 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.7 (MichaelThompson)
13:29:37 <jmcarthur> off the top of my head:   let f g=g.g in(f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f)(^9)9
13:29:43 <jmcarthur> it even makes the type checker unhappy
13:29:59 <rtpg> I feel like people seem to enjoy making libraries with extremely low version numbers
13:30:08 <burbul> @pf anyOf rs t = concat [r t | r <- rs]
13:30:08 <lambdabot> Maybe you meant: pl bf
13:30:13 <burbul> @pl anyOf rs t = concat [r t | r <- rs]
13:30:13 <lambdabot> anyOf = (join .) . flip flip [] . ((:) .) . flip ((<-) . (| r) . r)
13:30:31 <burbul> I feel like there should be a nicer way of writing that...
13:30:57 <bennofs> burbul: anyOf rs = any ($ t) rs
13:31:03 <burbul> thanks!
13:31:16 <bennofs> hmm, wait, maybe not
13:31:28 <burbul> concatmap ($ t) rs?
13:31:37 * BMeph nods
13:31:52 <bennofs> I got confused by the name anyOf :p
13:32:07 <BMeph> rs >>= ($ t) ;þ
13:33:14 <bennofs> :t flip $ concatMap . flip ($)
13:33:15 <lambdabot> [a -> [b]] -> a -> [b]
13:33:43 <BMeph> :t ((>>=).flip id)
13:33:44 <lambdabot> a -> (c -> (a -> c) -> b) -> (a -> c) -> b
13:34:14 <bennofs> burbul: I think anyOf = mconcat might also work
13:34:35 <bennofs> :t mconcat :: [a -> [b]] -> a -> [b]
13:34:36 <lambdabot> [a -> [b]] -> a -> [b]
13:34:48 <bennofs> a -> [b] is a monoid
13:35:19 <jmcarthur> better   let f g=g.g in f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f f(join(^))9
13:35:20 <BMeph> So, flip mconcat
13:35:43 <BMeph> ...sigh. Never mind! :)
13:35:45 <bennofs> BMeph: no, the original version took the list first too
13:37:55 <theorbtwo> It seems to me that undecidedability of the busy beaver problem makes the busy tweeting beaver problem harder and more interesting to play.
13:38:22 <copumpkin> jmcarthur: is there some benefit to making f g = g.g.g and sacrificing a call or two?
13:38:25 <theorbtwo> No matter how good a 140-character haskell program to compute a very large number is, you cannot prove that it is the largest such number.
13:38:28 <burbul> thanks!
13:38:37 <burbul> mconcat is very nice
13:38:41 <dwcook> Purely out of curiosity – Is there a way to get rid of the unsafePerformIO here? http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Unique.html
13:38:55 <dwcook> i.e., make the library behave the same but without using that.
13:39:09 <copumpkin> no
13:39:11 <jmcarthur> copumpkin: i'm not sure. i doubt it. every two characters i add to the definition of f could have doubled the previous one with only one more application of f.
13:39:30 <copumpkin> yeah, but each of them could be triple-composing?
13:39:53 <jmcarthur> i'm not sure
13:39:55 <copumpkin> sounds like you need to move to agda
13:39:58 <copumpkin> and prove yours is bigger than mine
13:40:00 <copumpkin> >_>
13:40:09 <Eduard_Munteanu> dwcook: you could use an implicit instead of that
13:40:20 <jmcarthur> i could just count them with succ instead of join(^)
13:40:25 <dwcook> Eduard_Munteanu, what do you mean?
13:40:32 <copumpkin> jmcarthur: it'll still be impossibly large
13:40:48 <jmcarthur> i could do it for smaller numbers and guess from the trend
13:40:53 <jmcarthur> maybe
13:41:19 <theorbtwo> OTOH, you need to add some sort of rule to make the programs computable in the pratical sense -- they need to be able to be run to completion, returning the number, in a period of time not approaching the heat death of the universe.
13:41:34 <ksison> >
13:41:38 <Eduard_Munteanu> dwcook: newUnique :: (?uniqSource :: IORef Integer) => IO Unique,    withUnique :: IO Unique -> IO Unique
13:41:57 <jmcarthur> copumpkin: i think you are correct
13:42:21 <copumpkin> those self-applications of composition operators are always confusing
13:42:23 <dwcook> Eduard_Munteanu, is that constraint the "implicit" you were referring to? I'm not familiar with that.
13:42:32 <Eduard_Munteanu> dwcook: yes
13:42:38 <jmcarthur> copumpkin: (let f g=g.g in f f f f succ 9) == 65545, but (let f g=g.g.g in f f f succ 9) stack overflows in ghci
13:42:49 <copumpkin> I figured it out once and then forgot which ended up being bigger
13:43:08 <Eduard_Munteanu> Er, withUnique :: IORef Integer -> IO a -> IO a
13:43:20 <copumpkin> jmcarthur: now the question is what the right balance is between .g.g.g and f calls!
13:43:24 <jmcarthur> yeah
13:43:50 <theorbtwo> Also, the limit should be <140 characters, so it can include a trailing #haskellbusybeaver, so that a bot can find the entrants.
13:44:06 <Eduard_Munteanu> dwcook: and use it like   main = newIORef 0 >>= \us -> withUnique us $ let ?uniqSource = us in do  ...
13:44:45 <dwcook> Eduard_Munteanu, so it does actually end up changing the library interface?
13:44:56 <jmcarthur> copumpkin: it's so hard to reason about for me. i don't have the mental tools :(
13:45:43 <Eduard_Munteanu> dwcook: yeah, less intrusive than a ReaderT though
13:46:27 <dwcook> Yeah, it's probably a reasonable change anyway.
13:48:49 <burbul> Is there a standard lib. funciton which maps [1,2,3,4] |-> [([],1,[2,3,4]), ([1],2,[3,4]), ([1,2],3,[4]), ([1,2,3],4,[]) and so on?
13:49:02 <benmachine> theorbtwo: I think if you require the programs to be practically-computable, the bound is *easily* the available resources
13:49:19 <benmachine> like, 2^2^64 is already gigantically hugely massive
13:49:25 <kazagistar> how do we evaluate applicants? is the size of the computed numbers even reasonable to compute?
13:49:25 <burbul> It seems like zippers should be useful here...
13:49:37 <Eduard_Munteanu> > zipWith (,) <$> inits <*> tails
13:49:38 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
13:49:38 <lambdabot>    arising from a use of `M1502496490087656514026.show_M1502496490087656514026'
13:49:38 <lambdabot>  The type variable `a0' is ambiguous
13:49:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:49:38 <lambdabot>  Note: there are several potential instances:
13:49:43 <Eduard_Munteanu> > zipWith (,) <$> inits <*> tails $ [1,2,3,4]
13:49:44 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
13:49:59 <burbul> thanks -- that's close enough!
13:50:17 <benmachine> theorbtwo: I think you just have to make it "not only do you provide the number, you also provide a proof it is bigger than the other thing"
13:51:00 <burbul> :t zipWith (,)
13:51:02 <lambdabot> [a] -> [b] -> [(a, b)]
13:51:03 <burbul> :t zip
13:51:04 <lambdabot> [a] -> [b] -> [(a, b)]
13:51:24 <Eduard_Munteanu> Er, yeah, I had that off the top my head.
13:51:24 <burbul> same thing? or am i confused?
13:51:29 <burbul> no prob.
13:51:32 <nooodl> burbul: same thing
13:52:25 <theorbtwo> benmachine: Yeah, you are right.  Shame.
13:52:57 <bennofs> post it on codegolf stackexchange :)
13:53:00 <jmcarthur> benmachine: the goal is to write an expression which would evaluate to some number given an arbitrary, finite amount of time and memory
13:53:01 <benmachine> theorbtwo: maybe it would be possible to have a biggest-number contest if you crippled yourself in some other way
13:53:06 <benmachine> like using brainfuck or something
13:53:29 <FireFly> jmcarthur: my contestant is  let x = iterate (9^) 9 !! 999 in iterate (x^) x !! x  or some such
13:53:31 <benmachine> jmcarthur: when you say "arbitrary" do you mean "fixed per-contest" or "as large as it needs to be"?
13:53:42 <jmcarthur> benmachine: as large as it needs to be
13:53:46 <benmachine> ah, right, yeah
13:53:49 <benmachine> that was my thinking
13:54:03 <copumpkin> jmcarthur: yeah, the three version grows pretty fast
13:54:11 <benmachine> but you run into the difficulty that very large numbers are hard to compare
13:54:15 <copumpkin> the 2 version is x_(i + 1) = 2^x_i
13:54:25 <benmachine> so I say, make the entrant do that work
13:54:51 <copumpkin> jmcarthur: I'd guess that thrice thrice thrice succ 0 = 3^27
13:54:53 <FireFly> copumpkin: in general it seems to be  iterate (k^) 0  where k is the number of compositions
13:54:57 <copumpkin> yu
13:54:58 <copumpkin> p
13:55:06 <kazagistar> are you sure it is even possible to compare?
13:55:19 <copumpkin> which means that calling succ 7625597484987 times is unlikely to complete in a while
13:55:45 <kazagistar> or rather, does there exist a program which can decide which program will produce a bigger number, assuming both programs are proven to terminate?
13:55:58 <copumpkin> sure :P
13:56:04 <copumpkin> if they're both terminating, run them both and see
13:56:09 <jmcarthur> FireFly: i get a negative exponent exception from yours...
13:56:24 <FireFly> umm
13:56:31 <copumpkin> might be using a bounded Int type?
13:56:36 <copumpkin> oh, it has to be
13:56:36 <jmcarthur> indexing
13:56:42 <kazagistar> copumpkin: I mean, one that we can run reasonably on our machines, given the input programs are 100 characters or whatever
13:56:59 <copumpkin> kazagistar: if they're constrained to certain patterns like the ones we're writing, sure
13:57:03 <copumpkin> in general, I doubt it
13:57:09 <copumpkin> we could still write proofs of the fact
13:57:16 <copumpkin> but I don't think anything could automatically decide it
13:57:28 <jmcarthur> yeah i think most entries would need proofs rather than just running them
13:57:57 <jmcarthur> and the ones that run in any reasonable amount of time probably don't win ;)
13:57:59 <johtso> Is anyone successfully using Leksah on OSX? I'm not sure how to get it to find my GHC, it gives me this error "cabal: The program ghc version >=6.4 is required but it could not be found."
13:58:17 <FireFly> So, in order to compete, prove that your thing yields a number bigger than the current leader?
13:58:41 <jmcarthur> yes
13:59:13 <aristid>  is there a single-byte utf-8 decoder somewhere?:D
13:59:25 <copumpkin> jmcarthur: have you seen scott aaronson's post on the topic?
14:00:50 <jmcarthur> copumpkin: nope, but i'm reading now
14:01:02 <burbul> Could you explain the zip <$> inits <*> tails?  Is something happening in the ((->) a) instance of Applicative?
14:01:08 <copumpkin> :)
14:01:33 <burbul> :t liftA2 zip inits tails
14:01:34 <lambdabot> [a] -> [([a], [a])]
14:01:55 <theorbtwo> Link, please?
14:02:17 <jmcarthur> theorbtwo: http://www.scottaaronson.com/writings/bignumbers.html
14:02:38 <burbul> oh, wait, it's Applicative [],
14:03:10 <burbul> right?
14:04:36 <johnw> I'm pretty sure it's ((->) a)
14:04:46 <burbul> :t liftM2 zip inits tails
14:04:47 <lambdabot> [a] -> [([a], [a])]
14:04:49 <johnw> zip <$> inits <*> tails $ x  ==>  zip (inits x) (tails x)
14:05:09 <johnw> yes, the type signature is right
14:05:17 <johnw> but that doesn't mean it's Applicative []
14:06:46 <burbul> I think I don't understand why  ((->) a) is an instance of Applicative/Monad.
14:06:58 <burbul> (I just found it via hoogle)
14:07:04 <johnw> why wouldn't it be?
14:07:33 <burbul> I'm not asking a deep q, I'm just confused, I think
14:07:40 <johnw> f <*> x = \y -> f y (x y)
14:07:45 <burbul> ((->) a) b is (b -> a)
14:07:55 <johnw> the other way around
14:07:56 <johnw> it's a -> b
14:08:08 <burbul> oops -- was thinking of sections
14:08:30 <burbul> like (+ 2)
14:09:05 <jmcarthur> burbul: if the section syntax were legal here, it would be (a ->)
14:09:55 <burbul> ok, that makes sense
14:10:05 <burbul> If I call it (z ->) then
14:10:18 <burbul> ma -> (a -> mb) -> mb
14:10:20 <burbul> becomes
14:10:32 <burbul> (z -> a) -> (a -> z -> b) -> (z -> b)
14:10:40 <burbul> which makes sense
14:11:43 <burbul> thanks
14:12:16 <burbul> it's some kind of 'pointwise' combination
14:12:45 <monochrom> it is always informative to concretely work out the symbols rather than abstractly argue by intuition
14:12:54 <monochrom> "let the symbols do the work"
14:47:16 <richo> So I'm writing a compiler with parsec, and using an IORef to store global bindings. It seems that my IORef isn't actually being updated because I'm unable to ever get values back out of it. Is there some neat way to dump it's internal state that I can use to diagnose?
14:48:49 <pavonia> richo: Why don't you use a State for passing that information around?
14:49:17 <richo> because I didn't know it existed. Let me read the docs and see if it's a better fit
14:50:10 <richo> (I am flying by the seat of my pants. parsec is amazing for generating parsers, and using data constructors for my internal types makes this really easy to reason about, but this is largely the result of reading Write You A Scheme twice and then diving in)
14:51:55 <richo> pavonia: so it seems like I'd use State to wrap a Data.HashMap and use it to encapsulate the updates, instead of threading the HashMap through all my frames?
14:56:57 <ryantrinkle> is there any known issue where profiling interferes with multithreading?
14:57:04 <pavonia> richo: Well, if there's no good reason for using IORefs, yes
14:57:23 <ryantrinkle> i have a multithreaded server that's capping out at just over 1 core when profiling, even though it happily uses 30 cores when not profiling
14:57:56 <pavonia> richo: I think parsec 3 already supports a user state and functions for manipulating it
14:58:05 <richo> I'm essentially just composing the primitives from the book, tbh.
15:00:35 <pavonia> richo: Ah, they seem to use the simplified Parser monad, you'll want to look at ParsecT
15:01:12 <richo> pavonia: I'm reading http://hackage.haskell.org/package/parsec-3.1.1/docs/Text-Parsec-Prim.html#v%3aupdateParserState and it seems that this is meant to refer to parser state?
15:01:24 <benmachine> a different question: why are you storing bindings while parsing?
15:01:39 <richo> ok, so I maybe didn't explain well
15:01:48 <richo> I'm writing a lisp which compiles to posix shell
15:02:02 <richo> the only valid toplevel forms are (define name datum) and (export name)
15:02:28 <richo> but to implement (define ...) I need a big hashtable to store the defined names in. I was trying to use a hashtable. This is ahppening at eval time, not parse time.
15:04:01 <pavonia> Do you need to read the hashtable while parsing?
15:04:19 <richo> nope
15:04:28 <richo> only when evaluating the ast
15:04:55 <pavonia> Okay, then you don't need a user state ;)
15:05:04 <benmachine> ok, so by the time you're worrying about your IORef or whatever, Parsec is already out of your hair?
15:08:59 * hackagebot hyperloglog 0.2.1 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2.1 (EdwardKmett)
15:09:01 <richo> benmachine: yeah, basically. Sorry I was trying to offer context about what I was actually doing
15:09:25 <richo> I'm super new to haskell, but I'm typically the guy people at work come to saying "How do I do <very specific thing>" instead of saying "I'm trying to <solve problem>"
15:09:33 <richo> just trying to avoid doing that
15:10:03 <bitemyapp> richo: http://www.perlmonks.org/?node_id=542341
15:11:00 <richo> exactly
15:15:04 <skypers> funny
15:15:12 <skypers> I compiled a program
15:15:19 <skypers> it’s 11Mo heavy
15:15:27 <skypers> I run strip -s on it
15:15:31 <skypers> it’s 6.1Mo
15:15:36 <skypers> then sstrip -z on it
15:15:41 <skypers> still 6.1Mo
15:20:54 <absence> skypers: ghc makes huge executables
15:22:04 <richo> ok, either way I'll have a peek at the state monad. It looks like it might be a better fit
15:22:15 <richo> and hopefully will mean I don't need to stuff this whole thing inside IO
15:23:36 <pavonia> richo: Why don't you combine the parsed definitions in a Data.Map? I don't see a need for State or IO here
15:24:18 <skypers> 00:15 < absence> skypers: ghc makes huge executables
15:24:23 <skypers> I wonder why
15:24:36 <skypers> I wonder how we could fix that
15:24:42 <skypers> I think it’s RT-related
15:24:45 <johnw> i think it does module-level linking, not function-level
15:24:57 <skypers> johnw: there’s a flag for that
15:24:57 <richo> pavonia: I probably *could* thread an immutable map through, tbh though I'm trying to change this codebase in small parsable chunks while I'm learning
15:25:02 <skypers> something like split-obj
15:25:06 <johnw> yeah, but it requires rebuilding the whole world
15:25:21 <richo> having a big mutable hashmap that I thread through without worrying about stack unwinding blowing away context makes my life a lot easier right now
15:25:22 <skypers> not a problem to me, I use sandboxes
15:25:41 <richo> brb, moving cafes.
15:27:17 <chrisdotcode> hi everyone
15:27:32 <Sculptor> hi dr. nick riviera
15:29:06 <sipa> hi dr. /nick
15:33:09 <pavonia> @tell richo def :: Parser (String, Value); defs :: Parser (Map String Value); defs = fromList <$> many def <-- Something like that is what I was thinking about
15:33:09 <lambdabot> Consider it noted.
15:36:03 <chrisdotcode> guys, are the two functions:
15:36:16 <chrisdotcode> f Just a _ = a
15:36:16 <chrisdotcode> and
15:36:16 <chrisdotcode> f _ Just a = a
15:36:16 <chrisdotcode> the same thing?
15:36:48 <simpson> chrisdotcode: Did you mean f (Just a) _ = a?
15:37:01 <simpson> chrisdotcode: In that case, they're similar, but their arguments are in different order.
15:37:05 <chrisdotcode> simpson: yes, my mistake. but my question is does the pattern matching oder matter?
15:37:14 <chrisdotcode> so order *does* matter?
15:37:41 <ion> > "foo" ++ "bar"
15:37:44 <lambdabot>  "foobar"
15:37:45 <ion> > "bar" ++ "foo"
15:37:46 <lambdabot>  "barfoo"
15:37:49 <tac> chrisdotcode: Yes... it's like the difference between "hello" ++ " world" and " world" ++ "hello"
15:37:50 <ion> Well, does the order matter?
15:37:52 <tac> ion: beat me to it
15:37:52 <jmcarthur> chrisdotcode: those are not the same function in that they have different types
15:38:13 <jmcarthur> :t ((\(Just a) _ -> a), (\_ (Just a) -> a))
15:38:15 <lambdabot> (Maybe t1 -> t -> t1, t2 -> Maybe t3 -> t3)
15:38:52 <tac> jmcarthur: You can unify them to the same type, of course. And even when the types are the same, they are different functions.
15:39:03 <chrisdotcode> okay, cool. I knew order mattered for functions, I just wanted to know whether or not the compiler did something to the order of pattern matching
15:39:47 <tac> chrisdotcode: ostensibly, the other of different cases doesn't matter
15:40:05 <tac> but the order of the parameters virtually always does
15:40:22 <tac> (and I say ostensibly because the order becomes significant if you have overlapping patterns or overlapping guards)
15:40:46 <chrisdotcode> I was mostly wondering if there was a shortcut to do both cases of a pattern match. like, instead of having to write out both:
15:40:47 <chrisdotcode> f (Just 5) (Just 7) = 5 and
15:40:47 <chrisdotcode> f (Just 7) (Just 5)
15:40:47 <chrisdotcode> that there would be a shortcut.
15:41:07 <chrisdotcode> *f (Just 7) (Just 5) = 5
15:41:16 <chrisdotcode> see, I'm making mistakes already! :)
15:41:28 <chrisdotcode> I was hoping that the compiler could derive the reverse case for me, but I guess not.
15:41:40 <simpson> chrisdotcode: What are you building?
15:42:05 <chrisdotcode> a "status" data type
15:42:15 <chrisdotcode> data Status = Rejected | Pending | Accepted
15:42:22 <chrisdotcode> and I was building the monoid instance
15:42:59 <bitemyapp> chrisdotcode: what does a mappend of Accepted and Pending mean?
15:43:19 <chrisdotcode> Accepted `mappend` Accepted = Accepted, Pending `mappend` Pending = Pending, Rejected `mappend` _ = Rejected, and _ `mappend` Rejected = Rejected.
15:43:43 <bitemyapp> chrisdotcode: Pending `mappend` Accepted = ?
15:43:43 <chrisdotcode> the last two are the same with just different argument order, so that's why I was asking if I could have the compiler do it for me.
15:43:57 <chrisdotcode> right, Pending `mappend` Accepted = Pending
15:44:03 <chrisdotcode> and then Accepted `mappend` Pending = Pending
15:44:08 <chrisdotcode> so I'd be writing a lot of "same" cases
15:44:17 <sipa> mappend = max
15:44:25 <bitemyapp> chrisdotcode: so you have an ordering.
15:44:25 <sipa> if you make it an ord instance :)
15:44:28 <chrisdotcode> yup
15:44:32 <chrisdotcode> I derived Eq
15:44:32 <bitemyapp> sipa: lol read my mind
15:44:43 <chrisdotcode> but I wasn't smart enough to see the connection until you just just said it >_>
15:44:48 <bitemyapp> chrisdotcode: you could just instance Ord and define the Monoid in terms of that.
15:45:11 <bitemyapp> chrisdotcode: well that's why I interrogated the logic of what you were doing, it wasn't eminently obvious what mappending different conditions would mean.
15:45:20 <chrisdotcode> right, right.
15:45:29 <bitemyapp> bonus is you get one nice, anonymous and clean definition for your mappend
15:46:36 <chrisdotcode> so mappend would be min, then, not max as sipa suggested, because Pending `mappend` Accepted = Pending.
15:46:47 <chrisdotcode> so it takes the "lesser" of the two
15:46:55 <chrisdotcode> but that's a really clean solution :)
15:47:22 <bitemyapp> chrisdotcode: see how much thinking can net you?
15:47:35 <bitemyapp> chrisdotcode: btw thanks for sharing this, I'm incorporating this little example into my Haskell classes.
15:47:46 <chrisdotcode> awesome! :)
15:47:47 <bitemyapp> as a way to leverage typeclasses with a bit of forethought :)
15:48:05 <chrisdotcode> bitemyapp: and yeah, I thought, but my haskell chops are still in the process of growing :)
15:48:25 <chrisdotcode> levering the Ordering typeclass to provide the Monoid instance seems really cool to me
15:49:19 <bitemyapp> chrisdotcode: it's a common pattern for 0-arity sum types.
15:49:56 <chrisdotcode> and so the only way to get an Accepted is where they're both accepted, then, correct?
15:50:13 <bitemyapp> chrisdotcode: seems so.
15:51:12 <chrisdotcode> okay, excellent!
15:51:17 <chrisdotcode> thanks again guys :)
15:51:27 <chrisdotcode> and bitemyapp, I'd like to read your write-up when you finish with it :)
15:55:36 <joeyh> I'm struggling with pipes-safe.. how would I connect together the Producer and Consumer in this paste? http://lpaste.net/100007
15:59:11 <johnw> is it: runSafeT $ runPipe $ getj >-> showj?
15:59:28 <johnw> that's essentially what you'd do with conduit and ResourceT
16:00:14 <Clint> s/Pipe/Effect/
16:00:43 <hc> can you recommend an article to understand arrows from a practical point of view? for someone who understands monads?
16:00:56 <richo> Is Data.HashMap in core? ghc can't seem to find it, but it seems like the kind of thing that would ship with the runtime/compiler
16:01:17 <DrAwesomeClaws> damnit, i'm addicted to haskell.  I have C# work to do and can't stop hacking on this haskell irc bot side project
16:01:29 <joeyh>     Couldn't match type `IO' with `SafeT m0'
16:01:33 <benmachine> richo: no, although it is (I believe) in the haskell platform
16:01:57 <joeyh> afaics there is no IO instance in the safe stuff (which may make sense...)
16:02:04 <dwcook> joeyh, sounds like you're missing a lift
16:02:39 <joeyh> possibly, it's neither lift nor liftIO though :)
16:03:00 <dwcook> Or no, depends on where it's giving you that error
16:03:09 <tac> DrAwesomeClaws: What's your IRC bot do?
16:03:13 <dwcook> You might need to runEffect
16:03:17 <joeyh> perhaps the thing to do is run it inside a Reader, which does have an instance and get a value out
16:03:57 <dwcook> joeyh, on your finished pipe composition, are you using runEffect?
16:04:09 <Maior> can I get GHCI to annotate intermediate bindings inside a function with types for me?
16:04:18 <joeyh> above error is from: runSafeT $ runEffect $ getj >->  showj
16:04:28 <Forgetaboutit> richo: I believe it's in 'unordered-containers' in case you want to install it
16:04:58 <dwcook> joeyh, you're passing an IO action to runSafeT. Get rid of the runSafeT if you're not using SafeT
16:05:04 <DrAwesomeClaws> tac: it takes rss feeds from specified sources and posts updates to a channel
16:05:10 <tac> neat
16:05:17 <richo> Forgetaboutit: thanks. ghc asked me if I meant HashSet from ordered-containers
16:05:28 <richo> what I want isn't actualla set though, unless I'm missing something?
16:05:31 <joeyh> well the first action does use safe, that's the problem
16:05:48 <DrAwesomeClaws> yeah, was my first haskell project beyond reading about functional programming lightly as a general interest
16:06:10 <DrAwesomeClaws> but even with the shit code i threw at it, it just works
16:06:21 <tac> DrAwesomeClaws: I, too, have a Haskell bot, and it is, too, the only sizable thing I ever wrote in Haskell
16:06:26 <Forgetaboutit> richo: GHC probably only tries to be helpful :)
16:06:33 <dwcook> @type (>->)
16:06:34 <DrAwesomeClaws> tac: nice, what does yours do?
16:06:35 <lambdabot>     Not in scope: `>->'
16:06:35 <lambdabot>     Perhaps you meant one of these:
16:06:35 <lambdabot>       `>>' (imported from Control.Monad.Writer),
16:07:03 <DrAwesomeClaws> https://github.com/NucHorseStudios/HaskellDevBot  that's mine so far.  need to add some proper admin to it tonight
16:07:06 <dwcook> joeyh, no, it doesn't, since showj is constrained to IO
16:07:24 <tac> DrAwesomeClaws: Mostly pull pictures of cats from reddit. He also knows how to text me and a handful of my friends, send email, and pull updates from a particular artist subreddit and post the new submissions to the channel
16:07:28 <Maior> (I'm not even really sure what to google)
16:07:53 <dwcook> joeyh, even if it uses SafeT internally, it's not expressed in the type, so you don't need the runSafeT
16:07:54 <DrAwesomeClaws> tac: nice, sounds similar to what this one does, haha
16:08:13 <tac> DrAwesomeClaws: oh, and I ripped out mueval from lambdabot, so my bot can do haskell eval too
16:08:15 <joeyh> dwcook: MonadSafe m ...
16:08:47 <DrAwesomeClaws> i need to take a look at lambda bot.  I've just been going off haskell wiki and "real world haskell" mostly
16:09:00 <Forgetaboutit> tac: the pictures may be helpful one day ... ( https://xkcd.com/512/ ) ;)
16:09:40 <dwcook> joeyh, that isn't the same thing as saying it uses SafeT. Look at (>->)'s type, and look at showj's, and you can see m = IO.
16:10:29 <dwcook> joeyh, okay, ignore everything else for a moment: Ask the compiler what the type is of the expression that's passed to runSafeT.
16:11:16 <richo> ok, so is hashmap actually a thing that I want?
16:11:45 <dwcook> richo, I'd use Map first unless you have a good reason not to
16:11:47 <richo> I basically just want a big queriable set of key-value pairs. Immutability is ok, because I can trap the whole show in the State monad, if I understand correctly
16:12:18 <Forgetaboutit> richo: definitely a case for map imho
16:12:51 <DrAwesomeClaws> i think my next project will be a shitty bitcoin implementation.  Seems like trying to model the blockchain w/ haskell type system would be a good exercise, even if i fail miserably
16:12:53 <richo> ok, thanks.
16:13:21 <Maior> DrAwesomeClaws: check out gitcoin from stripe ctf3
16:13:22 <avpx> Hmm. Looks like the hashmap from unordered-containers is O(log(n)) for most of its operations
16:13:30 <hamishmack> johtso: Add GHC to your PATH in your ~/.profile file
16:13:36 <richo> I'll be paying all the time at compile time anyway
16:13:37 <richo> no runtime
16:13:38 <rawtass> I have x and y of type Vector a, and I want to plot them using http://hackage.haskell.org/package/plot-0.2.2/docs/Graphics-Rendering-Plot-Figure.html#t:Dataset How do I put this toghether for Dataset?
16:13:41 <DrAwesomeClaws> thanks Maior
16:13:41 <richo> so I don't know that I entirely case
16:13:43 <richo> care*
16:14:14 <avpx> richo: If you have an ordering, you probably want Map. If you don't have ordering but do have hashing, then I guess you want HashMap
16:15:14 <richo> I don't have ordering, but O(n) traversal of the set won't kill me
16:15:34 <avpx> Then you probably want a list of pairs :p
16:15:39 <johtso> hamishmack, I have GHC both in /etc/paths (a last resort) and put on my path by my ZSH profile
16:15:53 <dwcook> Even an arbitrary but consistent ordering works. If you don't have that, there's always Prelude's lookup and (:) :)
16:16:13 <Clint> joeyh: runSafeP perhaps?
16:16:18 <pavonia> richo: Didn't you say your mapping strings to some values?
16:16:24 <pavonia> *you're
16:17:41 <newsham> ?type safePerformIO
16:17:42 <lambdabot> Not in scope: `safePerformIO'
16:17:57 <dwcook> newsham, haha, if only :)
16:18:24 <newsham> cant blame me for trying
16:18:51 <richo> pavonia: I am, but there's no reason that couldn't me implemented as an alist (which is what I'm assuming a map is under the hood?)
16:19:14 <dwcook> richo, Map is implemented as a BST, iirc
16:19:50 <dwcook> Anyway, String has an ordering, so you can use Map String blah
16:22:57 <pavonia> Where ordering means it has an Ord instance
16:23:10 <pavonia> > "foo" > "bar"
16:23:10 <richo> ok, so after importing Data.Map `map` is ambiguous. Do I remember some qualified import thing?
16:23:11 <lambdabot>  True
16:23:39 <dwcook> richo, try import qualified Data.Map as M
16:24:03 <richo> dwcook++ perfect, thanks
16:25:39 <avpx> richo: Usually you'll "import qualified" modules that expose data structures
16:25:44 <avpx> richo: Just FYI
16:26:03 <richo> avpx: yeah, that makes a lot of sense. State is now colliding with parsec too, but that' smanagemenable
16:27:47 <hakujin> richo: also note something like import Prelude hiding (map)
16:28:05 <hakujin> if you know you won't be using certain exported functions
16:28:50 <hakujin> but import qualified Data.Map as M is what you want here
16:29:01 <dwcook> You'd also need to hide lookup, for instance, though
16:29:07 <hakujin> yep agreed
16:29:39 <Maior> personally, I'd use qualified for everything
16:30:23 <dwcook> I like to import every binding explicitly, hiding things that conflict that I don't need; or if I need two things of the same name, import qualified.
16:30:33 <dwcook> That way it's obvious where everything came from.
16:30:52 <hakujin> dwcook: that helps so much when reading library code you didn't write
16:35:11 <avpx> dwcook: Wait, you mean import Data.Map (Map), not import Data.Map hiding (...), right?
16:35:11 <richo> Am I missing something? I'm reading the docs for Data.Map and actually creating one is escaping me
16:35:24 <avpx> richo: M.empty
16:35:42 <avpx> richo: Also check out fromList
16:35:49 <richo> avpx: ok, maybe I'm confused then. I have type Env = M.Map String LispVal to Create a Map of String -> LispVal pairs
16:35:57 <richo> or am I Doing It Wrong
16:36:13 <avpx> No, that's the right type.
16:36:13 <dwcook> avpx, yeah, I was slightly ambiguous – E.g., if I need Data.Map.lookup, and I don't need Prelude.lookup, I import Prelude hiding (lookup).
16:36:23 <avpx> dwcook: Ah, I see.
16:36:40 <dwcook> Along with explicitly listing lookup in the import list from Data.Map.
16:36:43 <richo> but I do M.empty to get an empty one? That seems odd. Shouldn't I nee dot pass Env into my contrucutor to tell it what type of map it returns?
16:37:15 <dwcook> richo, no, the type system handles that, a value isn't needed
16:37:26 <avpx> richo: Type inference ;)
16:37:34 <Eduard_Munteanu> > M.empty () Int
16:37:35 <lambdabot>  Not in scope: data constructor `Int'
16:37:35 <lambdabot>  Perhaps you meant one of these:
16:37:35 <lambdabot>    `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
16:37:35 <lambdabot>    `InR' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
16:37:39 <Eduard_Munteanu> > M.empty () Integer
16:37:40 <lambdabot>  Not in scope: data constructor `Integer'
16:37:43 <richo> avpx, dwcook So is the type inferred from the return value of my constructor?
16:37:45 <Eduard_Munteanu> Er,
16:37:51 <Eduard_Munteanu> > M.empty :: Map () Integer
16:37:52 <lambdabot>  Not in scope: type constructor or class `Map'
16:37:52 <lambdabot>  Perhaps you meant `M.Map' (imported from Data.Map)
16:37:58 <richo> eg; nullEnv :: Env; nullEnv = M.empty
16:38:00 <dwcook> richo, it's inferred from how it's used
16:38:00 <avpx> > M.empty :: M.Map () Integer
16:38:02 <lambdabot>  fromList []
16:38:05 <richo> does that then work out that I must have wanted and Env ?
16:38:17 <avpx> richo: It should.
16:38:27 <shachaf> It's not very different from "foo :: [Int]; foo = []"
16:38:37 <richo> that's a good analogy
16:38:41 <dwcook> Say you do lookup "hey" empty; then it's known that empty :: Map String a because of lookup's type.
16:38:58 <dwcook> @type Data.Map.lookup
16:38:59 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
16:39:38 <dwcook> See how k appears twice in the signature? It must be the same in both places, thus, the Map's type is constrained based on the first parameter's type.
16:40:15 <richo> That makes complete sense. I'm hoping that with time this will get more intuitive
16:41:12 <avpx> > let fromList = foldl (\m (k,v) -> M.insert k v m) M.empty in fromList [("hello", 1), ("world", 2)]
16:41:14 <lambdabot>  fromList [("hello",1),("world",2)]
16:41:31 <avpx> Point being that you could create any map you wanted with M.empty and M.insert
16:41:36 <Eduard_Munteanu> > show . read $ []
16:41:37 <lambdabot>  "*Exception: Prelude.read: no parse
16:41:44 <Eduard_Munteanu> Bleh.
16:41:47 <avpx> Eduard_Munteanu: read . show?
16:42:08 <avpx> richo: It will :)
16:42:09 <Eduard_Munteanu> > read . show $ []
16:42:11 <lambdabot>  *Exception: Prelude.read: no parse
16:42:14 <Eduard_Munteanu> :(
16:42:27 <Eduard_Munteanu> Them defaulting rules.
16:42:27 <dwcook> @type show . read
16:42:28 <Axman6>  read . show $ ()
16:42:28 <lambdabot> String -> String
16:42:32 <Axman6> > read . show $ ()
16:42:33 <lambdabot>  ()
16:42:33 <dwcook> @type read . show
16:42:35 <lambdabot> (Read c, Show a) => a -> c
16:42:45 <Axman6> the problem is read defaulting to ()
16:42:53 <Eduard_Munteanu> I wanted to illustrate you'll get warned if types are ambiguous.
16:43:04 <richo> I've been learning rust and it "feels like haskell", so I figure I must have learned something on my last haskell bender
16:43:34 <avpx> richo: I like not having to think about pointers.
16:44:10 * hackagebot yesod-pagination 0.1.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.1.0.0 (JoelTaylor)
16:44:24 <jophish> Yo yo yo
16:45:12 <jophish> does a class have a kind. For example, does Eq have kind (k -> *)?
16:45:18 <jophish> I don't know if that really makes sense
16:45:30 <Eduard_Munteanu> jophish: not by Haskell98/2010
16:45:37 <dwcook> :k Monad
16:45:38 <lambdabot> (* -> *) -> Constraint
16:45:50 <dwcook> :k Eq
16:45:51 <lambdabot> * -> Constraint
16:46:04 <Eduard_Munteanu> If you enable ConstraintKinds, that is.
16:46:29 <jophish> ahh
16:46:30 <jophish> of course
16:46:34 <avpx> Hmm, I had never thought about that, but that's interesting
16:46:47 <jophish> This would make my Kind checker a little nicer I think
16:47:01 <jophish> What are constraint kinds used for?
16:47:29 * jophish wonders how much code can be shared between the kind checker and the type checker
16:47:31 <Eduard_Munteanu> jophish: synonyms for a bunch of constraints is one example
16:48:00 <enthropy> without them you can't talk about Eq without it being fully applied (and to the left of a =>)
16:48:10 <Eduard_Munteanu> type MonadJophish m = (MonadReader Book m, MonadError Phail m, MonadIO m)
16:48:51 <jophish> Eduard_Munteanu: oh, that's very cool
16:49:00 <enthropy> in template haskell you have  type Kind = Type
16:49:05 <dwcook> Kind of silly to call it "type" at this point though :)
16:49:06 <jophish> enthropy: when would you want to do taht?
16:49:08 <Eduard_Munteanu> You can also use Constraint wherever you use kinds, like typeclass parameters.
16:49:15 <Eduard_Munteanu> *other kinds
16:49:41 <jophish> Eduard_Munteanu: DoubleConstraint c1 c2 a = (c1 a, c2 a) for example?
16:49:54 <Eduard_Munteanu> jophish: that too
16:50:03 <enthropy> we use them in https://github.com/aavogt/DimMat/blob/master/DimMat/Internal.hs
16:50:07 <Eduard_Munteanu> dwcook: it is a type if you think about PolyKinds
16:50:11 <jophish> This seems like the kind of thing which would be easier not to implement
16:50:30 <jophish> err, the opposite of that
16:51:06 <monokrome> oy
16:51:08 <Eduard_Munteanu> dwcook: e.g. is it less of a type than Tagged :: k -> * -> *?
16:52:00 <Eduard_Munteanu> Or the lifted types.
16:52:07 <dwcook> Eduard_Munteanu, I don't know, I just don't have a good intuition of how to unite types and constraints
16:52:32 <monokrome> Does anyone here use the Yi text editor? I'm considering moving from Vim to a smaller/simpler editor that is more simple to extend with custom plugins, and Haskell seems like a great language for this. I'm wondering if the editor is stable enough to use on a day-to-day basis, or if there is any specific place to find extensions / tools for it?
16:53:00 <joelteon> I have not found it to be stable
16:53:09 <monokrome> And no, I'm not monochrom :)
16:53:19 <joelteon> well, that's not the main concern; the documentation for it isn't great
16:53:36 <monokrome> I had planned on reading through the source code
16:53:56 <monokrome> But if it isn't very stable, then maybe it is not the best editor choice.
16:54:20 <enthropy> try it out
16:54:32 <monokrome> I have been L)
16:54:33 * enthropy found it decent years ago
16:55:14 <Eduard_Munteanu> dwcook: constraints are sort of a type-level commutative monoid (() is the unit and (a, b) the multiplication)... other than that and the places where Constraint are expected, there isn't much.
16:56:46 <dwcook> Eduard_Munteanu, what's one way you could use a Constraint the same way as something of any other kind?
16:57:51 <Eduard_Munteanu> dwcook: they can be parameters to typeclasses or GADTs for example
16:58:32 <Eduard_Munteanu> dwcook: you can write a type family to apply a list of Constraints if you like, with DataKinds.
16:58:43 <dwcook> Hmm… interesting. So does this mean you could write a generalized Functor that allows Set to be one?
16:59:36 <Eduard_Munteanu> dwcook: Functor requires a * -> *
16:59:40 <Eduard_Munteanu> :t fmap
16:59:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:59:58 <dwcook> @type Data.Set.map
17:00:00 <lambdabot> (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
17:00:07 <dwcook> The problem is the Ord constraints
17:00:22 <dwcook> So if the instance could accept a constraint, you might be able to do it
17:00:41 <richo> https://gist.github.com/richo/9027624
17:00:49 <richo> I am confused, can someone tell me what I've done wrong here?
17:01:11 <Eduard_Munteanu> dwcook: it can't really be a functor if it doesn't take all arguments in its domain (which Ord limits)
17:01:15 <dwcook> richo, you're using Prelude's lookup rather than Data.Map's
17:01:15 <richo> Oh, I think maybe I'm using the wrong lookup?
17:01:24 <richo> Hah, so close. Thanks dwcook
17:02:08 <dwcook> Eduard_Munteanu, I'm not looking for "real functor" in the categorical sense
17:02:30 <dwcook> Just "something like Haskell's Functor except that fmap can be constrained"
17:02:50 <richo> Whoever told me to look at State: THANKYOU. Suddenly I don't have to thread everything through IO and I can udnerstand what the hell is happening again.
17:03:30 <Eduard_Munteanu> dwcook: not sure that's better than another class OrdFunctor.
17:04:10 <dwcook> Eduard_Munteanu, what would be the advantage of this OrdFunctor?
17:05:58 <jophish> :k Functor
17:05:59 <lambdabot> (* -> *) -> Constraint
17:06:05 <jophish> just as I suspected
17:06:11 <Eduard_Munteanu> dwcook: not better, just simpler
17:06:21 <jophish> :k (,)
17:06:22 <lambdabot> * -> * -> *
17:07:08 <Eduard_Munteanu> dwcook: another approach might be defining non-Hask functors, that might be nicer
17:07:19 <dwcook> Eduard_Munteanu, like what?
17:07:22 <jophish> Eduard_Munteanu: I composed two constraints earlier with (,). DoubleConstraint c1 c2 a = (c1 a, c2 a). Does this mean (,) is overloaded to be Constraint -> Constraint -> Constraint?
17:07:30 <pavonia> :k (~)
17:07:32 <lambdabot> * -> * -> Constraint
17:07:36 <dwcook> jophish, that , is syntax
17:07:44 <jophish> ah
17:07:53 <dwcook> Well, the other (,) is too, but different
17:07:54 <jophish> pavonia: what's (~)?
17:08:05 <pavonia> unification I think
17:08:58 <Eduard_Munteanu> dwcook: Functor gives you Hask -> Hask endofunctors, but you might be able to generalize it to other categories in order to limit the domain
17:09:02 <jophish> safeCoerce :: (a ~ b) => a -> b
17:09:05 <jophish> something like that?
17:09:11 <pavonia> :t undefined :: ((a, Int) ~ (String, b)) => (a, b)
17:09:12 <lambdabot> (String, Int)
17:09:28 <jophish> ah I see
17:09:35 <jophish> I wonder where that's useful
17:10:09 <dwcook> Eduard_Munteanu, how would you do that? And they'd still have to be subcategories of Hask, right?
17:10:21 <pavonia> jophish: It useful sometimes with type families
17:10:24 <khyperia> Hmm... I'm trying to write some lens stuff, if I have a Rectangle with width and height, and I'm inside a State Rectangle _, how would I concisely get the area of the rectangle?
17:10:49 <Eduard_Munteanu> dwcook: something like  class GeneralFunctor p q f where gmap :: p a b -> q (f a) (f b)
17:11:12 <Eduard_Munteanu> dwcook: sort of, depends how you interpret stuff
17:11:12 <dwcook> Eduard_Munteanu, oh I see what you mean. q = (->) is Functor
17:11:14 <khyperia> right now I have "area <- (*) <$> ((^. width) <$> get) <*> ((^. height) <$> get)" which is just... nasty-nasters-verobse-confusing
17:11:22 <dwcook> And p = (->)
17:11:49 <Eduard_Munteanu> dwcook: yeah
17:12:27 <jophish> Thank's for the answers today, everyone
17:12:31 <jophish> goodnight
17:12:39 <jophish> Thanks*
17:12:47 <jophish> I don't know what's wrong with me
17:17:26 <Eduard_Munteanu> dwcook: or even gmap :: p (f a) (f b) -> q (g a) (g b), with f, g :: k -> l  and  p, q :: l -> l -> *. Now you can index objects by things like Nats and you could use that to make the domain category smaller than Hask.
17:22:30 <Rotaerk__> could someone explain this overlapping instances error?  http://lpaste.net/3652771794353389568
17:22:56 <Rotaerk__> I'm not sure how the Subtype t t instance would overlap with itself
17:23:16 <johnw> it's not
17:23:22 <johnw> Subtype t t overlaps with every other instance
17:23:45 <Rotaerk__> it shouldn't overlap with Subtype Foo Baz
17:23:59 <johnw> well, every other instance with the same two types
17:24:02 <johnw> in this case, Bar Bar
17:24:12 <johnw> which it looks like upcast requires
17:24:15 <Rotaerk__> there is no instance for Bar Bar
17:24:20 <johnw> yeah, that's odd
17:24:34 <mm_freak> is there something like ex-pool/pool-conduit, but with names resources?  for managing things like textures
17:24:42 <khyperia> ahh, just figured out that view works in a Reader monad as well (I've got absolutely no idea how, but I'll just go with it...), is there a way to make it work in the State monad?
17:25:07 <Cale> Actually, that error message is really weird. It only lists that same instance 4 times
17:25:09 <mm_freak> withResource :: Pool k a -> k -> (a -> IO b) -> IO b
17:25:19 <Rotaerk__> Cale: yea, confused about that
17:25:24 <mm_freak> something like that
17:25:42 <Eduard_Munteanu> :t view
17:25:42 <Cale> However, that instance will probably overlap with everything anyway, given how it's being interpreted with the type equality constraint
17:25:43 <lambdabot> MonadReader s m => Getting a s a -> m a
17:25:53 <Eduard_Munteanu> :t use
17:25:54 <lambdabot> MonadState s m => Getting a s a -> m a
17:25:56 <Cale> Instance resolution doesn't check constraints, only the structure of the type
17:25:57 <Eduard_Munteanu> khyperia: ^^ ?
17:26:02 <khyperia> Ah, thanks!
17:26:18 <Cale> The constraints get checked *after* committing to the instance.
17:26:31 <Rotaerk__> is there any way to do what I'm trying to accomplish?
17:26:40 <Rotaerk__> i.e. declare all types a subtype of themselves
17:26:54 <Eduard_Munteanu> Cale: not always... it will follow constraints if nothing else matches
17:27:12 <Eduard_Munteanu> I mean you can make instances like that.
17:27:18 <zRecursive> :t (->)
17:27:19 <lambdabot> parse error on input `->'
17:27:22 <Cale> Eduard_Munteanu: i.e. it commits to the instance, and then checks them :)
17:27:26 <khyperia> so... that thing I ignored... why does "view someLens someData" work? What witchcraft is going on behind the scenes?
17:27:29 <zRecursive> :k (->)
17:27:30 <lambdabot> * -> * -> *
17:27:55 <Cale> Rotaerk__: Well, you could turn on OverlappingInstances, and see what happens
17:27:59 <Eduard_Munteanu> Cale: hmm... I guess I had UndecidableInstances in mind, it's probably fair for Haskell2010.
17:28:03 <Cale> You'll probably need more than that
17:28:08 <Rotaerk__> oh, will try
17:28:09 <khyperia> oh, is there an instance for monadreader that's (r ->)... oh, wait, that IS reader
17:28:12 <Cale> (UndecidableInstances more likely)
17:28:25 * khyperia 's brain just asploded
17:29:49 <dwcook> Eduard_Munteanu, I'm having trouble grasping what your second gmap "allows" that the first doesn't
17:29:51 <ezyang> Hm, so, if a binary starts repeatedly doing major GC, does that mean it's deadlocked?
17:30:56 <dwcook> Eduard_Munteanu, can you phrase their difference in categorical terms?
17:31:37 <flebron> What's the sense under which a polymorphic function like length :: [a] -> Int is a natural transformation? From the [] functor to the Identity functor?
17:31:38 <Rotaerk__> interesting...
17:32:08 <Rotaerk__> those lines under "test code" were not in Subtype.hs.  I had entered those manually into GHCi
17:32:15 <Eduard_Munteanu> dwcook: in normal CT you can just build categories by saying what they consist of. In Haskell and many other typesystems, you can't just build sets of objects and such.
17:32:19 <Rotaerk__> if I move them into Subtype.hs itself, the upcast works fine
17:32:28 <Rotaerk__> without OverlappingInstances and whatnot
17:33:15 <flebron> And how does Hask deal with quantifiers for such polymorphic functions? i.e. if id :: forall a. a -> a is a morphism, what's its source and what's its target?
17:33:20 <dwcook> Eduard_Munteanu, right… so how does that connect to those gmaps?
17:33:23 <Eduard_Munteanu> dwcook: instead you can make a collection using an index function that sends types to types your set consists of
17:33:57 <dwcook> Sorry, I might have sounded impatient there, but I wasn't being
17:34:40 <Eduard_Munteanu> dwcook: for example, if I want to build the 2 category, I probably want some f :: k -> l such that all 'f x'es give me something that looks like 2.
17:34:43 <Rotaerk__> johnw, Cale: must be a GHCi quirk
17:35:10 <Rotaerk__> moving all code into files, and doing only the upcast attempt in GHCi works
17:35:59 <Eduard_Munteanu> dwcook: with DataKinds, I can conveniently use an f :: Bool -> Bool (where Bool is a kind)
17:36:11 <Ymesio>   Ambiguous module name `Control.Monad.Writer':
17:36:34 <Ymesio> How do I import the right writer?
17:37:09 <johnw> do you want WriterT, or MonadWriter?
17:37:34 <Eduard_Munteanu> dwcook: and there are some restrictions... every inhabited type is in *, so clearly I can't use the usual fmap definition
17:38:00 <dwcook> Does that mean * effectively is Hask?
17:38:11 <Eduard_Munteanu> dwcook: well, that's by definition :)
17:38:17 <dwcook> Or rather, its objects
17:38:29 <Ymesio> johnw: I think it's a monadWriter
17:38:42 <dwcook> Yeah, I'm sometimes unclear on definitions is all
17:39:13 <johnw> Ymesio: are you referencing some package other than mtl which is providing that module?
17:39:17 * hackagebot flamethrower 0.0.2.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.2.0 (charmander)
17:39:59 <Ymesio> johnw: Hm, not really, I just copied some example from LYAH to a .hs file, and now want to run it in ghci
17:40:06 <Eduard_Munteanu> dwcook: also things like  gmap :: p a b -> q a b  might not let me specify how the functor maps objects well enough.
17:40:07 <johnw> ah, ghci
17:40:16 <johnw> you probably have both mtl and monads-tf installed or something
17:40:23 <dwcook> Eduard_Munteanu, why is that?
17:40:27 <johnw> you can try hiding the other package, like ghc-pkg hide monads-tf
17:41:26 <Ymesio> johnw: That kind of worked
17:41:27 <haasn> flebron: I think this means that ‘id’ represents a natural morphism in Hask, with instantiations for every object (type)
17:42:00 <Eduard_Munteanu> dwcook: it might be inconvenient to get, for example, the normal Functor from that, even if you let p = q = (->).
17:42:20 <zRecursive> After `googling haskell maxima`, i get https://github.com/danbst/hsmaxima ...  then i am curious if there is a CAS developed using haskell ?
17:42:49 <dwcook> Eduard_Munteanu, well if you let p = q = (->), then gmap has to be id, doesn't it? (barring bottom)
17:42:51 <Ymesio> Now it says: Not in scope: data constructor `Writer' Perhaps you meant `WriterT' (imported from Control.Monad.Writer)
17:42:53 <Eduard_Munteanu> dwcook: instead your q might need to be a   newtype Q a b = Q (F a -> F b)   but that's getting a bit different from Functor.
17:43:17 <Ymesio> johnw: Should I just used something other than ghci to run the examples?
17:43:21 <Eduard_Munteanu> dwcook: yeah
17:43:34 <johnw> Ymesio: no, that's fine
17:44:59 <zRecursive> Because, Haskell is famous for his feeling with mathematics ...
17:45:13 <dwcook> Eduard_Munteanu, okay, so then how about the other option? Why can't we just pick an appropriate q to get what we want?
17:45:34 <no-n> .help
17:46:12 <no-n> how do I talk to the bot here?
17:46:16 <carter> johnw: i'll add that to the directions
17:46:19 <carter> @help
17:46:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:46:23 <no-n> ty
17:46:33 <carter> no-n: no, thank you for trying to learn! ;)
17:46:38 <johnw> carter: thanks!
17:46:41 <no-n> :>
17:46:43 <Eduard_Munteanu> dwcook: it might not be a nice q, the Q above isn't a plain function anymore
17:47:05 <Eduard_Munteanu> dwcook: also p and q there are meant to form arrows, not objects
17:47:21 <Ymesio> johnw: Any idea what to do with  'Not in scope: data constructor `Writer' Perhaps you meant `WriterT' (imported from Control.Monad.Writer)' ?
17:47:40 <johnw> Ymesio: can you show me the code?
17:48:12 <carter> johnw: i met the pandoc author today
17:48:14 <carter> cool guy
17:48:17 <Eduard_Munteanu> dwcook: and I think people would expect p and q to be provided by source and target categories, rather than the functor itself.
17:48:31 <johnw> carter: where at?
17:48:42 <carter> at a coffee shop in berkeley
17:48:57 <carter> i've been helping him patch pandoc for each new ghc major version for  a few years now
17:49:02 <carter> ifgured i could talk him into coffee
17:49:02 <Ymesio> johnw: http://lpaste.net/100008
17:49:18 * hackagebot flamethrower 0.0.2.1 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.2.1 (charmander)
17:49:30 <johnw> in logNumber, that's not what you want to do
17:49:46 <johnw> logNumber x = tell ["Got number: "++ show x] >> return x
17:49:48 <carter> charmander wrote a flamethower lib?
17:50:00 <carter> wait
17:50:14 <carter> since when did we allow not real person names for author on hackage?!
17:50:23 <dwcook> Eduard_Munteanu, so basically it would be conflating things that ought not be conflated
17:50:54 <charmander> > Most contributors to Hackage attach their real name to their packages and contributions. However, we have no wish to discourage contributors with personal or professional reasons for wanting pseudonymity. We ask only that such people choose a name (and username) that looks at home among a collection of real names; we will be unwilling to add Kittenlover97 to the package uploader group.
17:50:55 <lambdabot>  <hint>:1:97: parse error on input `,'
17:51:13 <carter> oh cool
17:51:16 <carter> that makes sense
17:51:30 <carter> charmander: wheres it say that?
17:51:55 <charmander> at https://hackage.haskell.org/users/register-request
17:51:57 <Eduard_Munteanu> dwcook: yeah, I'm also unsure myself what's the nicest and flexible way to define arbitrary categories.
17:52:01 <Ymesio> johnw: Thanks, that worked
17:52:09 <carter> cool
17:52:23 <carter> woah
17:52:27 <carter> when did we get a web based form?
17:52:48 <johnw> or:  logNumber x = x <$ tell ["Got number: "++ show x]
17:52:50 <carter> charmander: so am i allowed to make pokemon battle jokes?
17:52:54 <johnw> if you want to get fancier
17:53:00 <charmander> You are allowed five. Use them wisely.
17:53:02 <carter> charmander: hows your lib differ form blaze?
17:53:07 <carter> *blaze-html
17:53:23 <charmander> For better or for worse, it’s entirely Template Haskell
17:53:28 <carter> :/
17:53:30 <carter> thats cool
17:53:33 <carter> but there are tradeoffs
17:53:40 * ski . o O ( "Templar Haskell" )
17:53:40 <Ymesio> johnw: Thank you, will play with it
17:53:54 <carter> like, wont work for ghc-ios
17:54:04 <carter> who wants to help make TH work for  cross compilers?
17:54:15 <carter> (helll. just having multi target ghc period!)
17:54:17 <jle`> mm_freak: what is the purpose of the wire generators that ignore the timestep?  they seem to inherently break frp to me
17:54:37 <jle`> mm_freak: but i guess if you are making your own wires then all bets are off
17:54:52 <Eduard_Munteanu> carter: is there a port of GHC to iOS?
17:54:56 <carter> YES
17:55:08 <carter> its actually kinda a Tier 1 platform now
17:55:13 <Eduard_Munteanu> carter: then perhaps you can run the native compiler in a VM?
17:55:18 <carter> nope
17:55:25 <jle`> i always forget what direction is what in (<$) :|
17:55:32 <jle`> is there some sort of convention/mneumonic?
17:55:33 <jle`> pneumonic?
17:55:38 <jle`> pneumatic?
17:55:43 <jle`> menominic
17:55:56 <Eduard_Munteanu> jle`: it's missing the right '>', which is the value it ignores
17:56:07 <jle`> :t (<$)
17:56:09 <lambdabot> Functor f => a -> f b -> f a
17:56:12 <jle`> oh
17:56:14 <ion> @type (<*)
17:56:15 <lambdabot> Applicative f => f a -> f b -> f a
17:56:15 <ski> mnemoralic
17:56:19 <khyperia> carter, I would probably be of no help but that sounds like fun
17:56:21 <carter> Eduard_Munteanu: do you really really want to have to do crazy vm hacks when writing protable code
17:56:25 <jle`> okay and the functor goes on the same side as it would for (<$>)
17:56:25 <carter> khyperia: well
17:56:28 <dwcook> Hmm, I seem to remember someone, probably edwardk, having a GFunctor class, but Hoogle can't find it. What package is that in?
17:56:37 <carter> dwcook: you mean GArrows?
17:56:38 <jle`> i keep on thinking it's like an "insert into this functor" arrow
17:56:47 <dwcook> carter, I don't think so.
17:56:54 <carter> http://www.cs.berkeley.edu/~megacz/garrows/
17:56:55 <ion> Compare the types of (<*>) vs. (<$>) and (<*) vs. (<$)
17:56:57 <carter> its realted mind you
17:57:02 <carter> *related
17:57:03 <Eduard_Munteanu> carter: it's usually the most reliable way, and this isn't a Haskell-specific statement.
17:57:18 <carter> Eduard_Munteanu: youre perhaps right
17:57:30 <carter> but it'd not be haskell if we didn't reach for nice things
17:57:37 <jle`> ty all
17:57:53 <carter> khyperia: well
17:57:54 <Eduard_Munteanu> carter: AFAIK getting a cross-GHC is rather complicated
17:57:59 <carter> Eduard_Munteanu: yes
17:58:05 <khyperia> carter, well
17:58:06 <carter> so the idea is to make it less complicated :)
17:58:11 <carter> indeed
17:58:24 <carter> khyperia: sooo, phase 0: getting you more comfy hacking ghc!
17:58:35 <carter> i spoke with you some time ago right?
17:58:58 <khyperia> Indeed! I've been busy with life recently, kind of dropped off of haskell, but yeah, I got a commit in and such because of your nudging me :)
17:59:12 <carter> oh seeet!
17:59:14 <carter> *sweet
17:59:19 * hackagebot ghci-lib 0.1.0.0 - A library for interactively evaluating Haskell code.  http://hackage.haskell.org/package/ghci-lib-0.1.0.0 (gibiansky)
17:59:20 <carter> didn't you just finish highs cool?
17:59:21 * hackagebot ghc-parser 0.1.1.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.1.0 (gibiansky)
17:59:23 * hackagebot ihaskell 0.3.0.4 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.3.0.4 (gibiansky)
17:59:27 <johnw> jle`: It's kind of the opposite of what you'd normally expect
17:59:28 <carter> *high school
17:59:46 <khyperia> Still in high school, I graduate this spring.
17:59:51 <johnw> jle`: <$ points to the value to keep, like <*, but it does *not* point to the side with "context"
18:00:17 <jle`> johnw: yeah that's usually what trips me up
18:00:19 <johnw> but x <$ == pure x <*, if that helps
18:00:25 <jle`> but i think if i remember that the order is the same as for (<$>)
18:00:27 <jle`> it might help me
18:00:32 <johnw> (and it only has a Functor constraint)
18:00:56 <jle`> also i forget if it's ($>) or (<$) but that's another problem altogether
18:00:59 <jle`> heh
18:01:30 <carter> khyperia: you were doing cuda stuff recently right?
18:02:00 <khyperia> yeah, my job is GPU programming, I've been fiddling around with it ever since I've started coding.
18:02:11 <carter> well
18:02:14 <carter> then you know mroe than me
18:02:34 <carter> khyperia: you should start lurking on #numerical-haskell (as should others who like mathy stuff on computers or want to)
18:03:29 <pabs3> how do I spawn an external process without running it in a shell?
18:03:47 <Eduard_Munteanu> pabs3: createProcess from System.Process, using 'proc'
18:04:11 <Eduard_Munteanu> pabs3: or one of the alternatives in there
18:04:19 * hackagebot twitter-feed 0.1.0.1 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.0.1 (jsl)
18:09:20 * hackagebot purescript 0.4.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.0 (PhilFreeman)
18:11:31 <no-n> is there a way to hide functions from `import Module`?
18:11:49 <Eduard_Munteanu> no-n: import Module hiding (foo)
18:12:08 <no-n> I meant automatically, when I just use `import Module`
18:12:29 <Eduard_Munteanu> no-n: make another module that re-exports part of Module
18:12:50 <no-n> ok
18:13:07 <Eduard_Munteanu> no-n: module ModuleReexport (module E) where     import qualified Module hiding (foo, bar) as E
18:13:22 <no-n> how do I make a directory of modules? (like a "package" in Python)
18:13:26 <Eduard_Munteanu> ("qualified" isn't necessary though)
18:13:59 <Eduard_Munteanu> no-n: if you mean a part of the module hierarchy, it's just directories and files ending in .hs.
18:14:32 <no-n> ok
18:14:34 <Eduard_Munteanu> no-n: e.g. you can have Module as Module.hs, and Module.Internal as Module/Internal.hs
18:14:52 <no-n> ahhh, great
18:15:02 <Eduard_Munteanu> no-n: you might want to use 'cabal init' to build a project skeleton
18:16:10 <no-n> all right
18:17:38 <tac> does cabal sandbox not work if you invoke GHC directly?
18:21:03 <c_wraith> tac: it does not
18:21:14 <c_wraith> tac: ghc doesn't pay attention to cabal-specific stuff
18:21:38 <jle`> is there a good library for working with colors?
18:21:38 <c_wraith> tac: this is why there's an open ticket to add a cabal sandbox exec command
18:21:45 <tac> That's what I figured
18:21:55 <c_wraith> or at least cabal exec
18:23:50 <mm_freak> jle`: you mean state delta generators?
18:24:28 <jle`> mm_freak: the mk*** functions that are :: (\a -> ...) instead of (\s a -> ...)
18:24:38 <jle`> from Control.Wire.Core
18:24:59 <mm_freak> jle`: ah…  some wires don't need time information
18:25:02 <mm_freak> consider fmap
18:25:04 <mm_freak> or filterE
18:25:18 <jle`> ah
18:25:30 <jle`> and those wires might even have state
18:25:32 <jle`> like...
18:25:38 <jle`> notyet
18:25:50 <mm_freak> yeah
18:25:58 <jle`> that makes sense
18:26:00 <jle`> thanks
18:26:07 <mm_freak> you're welcome =)
18:26:12 <jle`> as i look into the source code
18:26:18 <jle`> it confirms :)
18:27:52 <jle`> i however am definitely abusing it
18:27:54 <jle`> with my usage
18:29:26 <mm_freak> jle`: don't abuse too much…  the new abstraction won't give you much room for abuse =)
18:29:42 <jle`> heh
18:29:47 <jle`> i live life ont he edge :)
18:29:54 <jle`> i need a way to 'tag' an event with a random number
18:30:22 <mm_freak> jle`: fmap
18:30:32 <jle`> so i made a couple :: Wire s e m () b -> Wire s e m (Event a) (Event (a,b))
18:30:44 <jle`> and i made a wire that made a new random number on demand
18:30:51 <jle`> hm. fmap?
18:31:02 <mm_freak> that seems unnecessarily complicated
18:31:17 <jle`> well i wanted a generic solution :/
18:31:24 <jle`> hm
18:31:27 <jle`> how would i do this using fmap?
18:31:35 <mm_freak> n <- noise -< ();  let taggedEv = fmap (, n) ev
18:31:50 <mm_freak> where ev :: Event A
18:32:48 <jle`> is this the same noise from FRP.nEtwire.Noise?
18:33:07 <jle`> or is it my noisy wire that i made that plops out a new random number every time it is stepped
18:33:30 <jle`> (but that solution does seem a lot better than mine >.> i guess i got a little carried away with wire combinators)
18:37:03 <b2coutts> does/can lazy evaluation allow haskell to automatically parallelize purely functional code?
18:37:25 <b2coutts> i.e., when calculating (foo a b c), a, b, and c can all be evaluated in parallel instead of serially
18:38:11 <richo> So I have an alist, and I'd like to update a given value in it and return it. Where do I find the docs for this? I found lookup in prelude which seems to operate on the same data structure
18:38:16 <richo> but I'm not finding how to do oter operations on it
18:38:56 <b2coutts> richo: is there a reason you're using an alist instead of Data.Map?
18:39:23 * hackagebot yesod-pagination 0.2.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.2.0.0 (JoelTaylor)
18:39:23 <richo> b2coutts: sort of. The advice in this channel was good (Use State Map String LispVal, instead of my IORef)
18:39:25 * hackagebot monad-unify 0.2.0.1 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.2.0.1 (PhilFreeman)
18:39:37 <richo> that said, I found the bug in my IORef implementation so I'm using that for the time being while I work out what I'm doing
18:39:50 <mm_freak> jle`: ideally you pick one of the predefined noise wires
18:39:58 <richo> actually, I think I can just put a Map in my IORef instead
18:40:10 <mm_freak> jle`: your custom one exposes discrete time
18:40:34 <b2coutts> richo: I don't know of a function in Prelude which does what you want, but if all you want is a key-value store, Data.Map is both more efficient and supports a bunch of operations you may want (like insertion)
18:41:24 <richo> yeah, I think the port will be pretty straightforward
18:41:35 <jle`> mm_freak: so do you mean to use (hold . noise 0.1 g) ?
18:41:58 <jle`> it seems that like that would needlessly cycle through unused random numbers
18:43:17 <mm_freak> jle`: it's the only way to do it properly
18:43:29 <jle`> mm_freak: i see
18:43:49 <mm_freak> jle`: at least in netwire's FRP abstraction
18:44:07 <mm_freak> i have a few ideas about fast random numbers, but you will have to be patient
18:44:19 <jle`> no worries
18:52:08 <flebron> How does Hask deal with quantifiers for polymorphic functions? i.e. if id :: forall a. a -> a is a morphism in Hask, what's its source object and what's its target object?
18:52:43 <copumpkin> it's a natural transformation
18:52:56 <copumpkin> from the identity functor to itself
18:53:02 <flebron> So it's not a morphism in Hask?
18:53:16 <copumpkin> well, an NT is an indexed family of morphisms
18:53:21 <copumpkin> so it's lots and lots of them :P
18:53:46 <flebron> Right, I'm clear on that, I'm just trying to be as precise as possible, since I'm setting up a "discussion space" on funcitonal programming back in uni, wanted to get all my terms straight :)
18:54:05 <copumpkin> yeah, it isn't a particular morphism
18:54:07 <flebron> Something like length :: [a] -> Int would be a nt from the [] functor to the Const Int functor, right?
18:54:28 <copumpkin> yeah
18:55:51 <flebron> So when I have something like Rank2Types, how does f :: (forall a. a -> a) -> a -> a work? Is "forall a. a -> a" somehow "added" to Hask?
18:56:00 <flebron> Or is the formalism just thrown out the window when you add these things?
18:56:54 <copumpkin> not actually sure. Cale might know
18:57:28 <khyperia> Does anyone here use Sublime Text / Sublime Haskell? It's not doing the ModuleInspector thing and my autocomplete isn't working.
18:58:00 <mm_freak> flebron: in category theory you usually write 'id_A' to mean the identity of A
18:58:10 <mm_freak> so id itself is a function from objects to identity morphisms
18:58:21 <mm_freak> in a dependently typed language this becomes more clear
18:58:31 <mm_freak> id : (A : Set) → (A → A)
18:58:41 <flebron> Right
18:59:53 <flebron> Oh, dumb question perhaps but, I understand the definition of a Monad as a monoid in the category of endofunctors thing, but there's also a definition as a pair of adjointed functors. What would these functors be in, say, Either a?
19:01:01 <copumpkin> they're a lot less obvious for some monads than others
19:01:21 <copumpkin> they don't necessarily stay in "Hask"
19:01:38 <flebron> Ah, so they needn't be endofunctors for their composition to be
19:01:59 <copumpkin> yeah
19:02:04 <copumpkin> just means the comonad might be in another category
19:02:09 <copumpkin> State is an obvious one though
19:04:20 <copumpkin> I did a few of them in Agda a while back
19:04:21 <copumpkin> http://lpaste.net/68257
19:05:21 <copumpkin> https://gist.github.com/copumpkin/2663881 and https://gist.github.com/copumpkin/2659444 too
19:05:46 <copumpkin> flebron: make sure your monad as monoid understanding is actually the right one, since there's a "competing" understanding floating around that's kind of wrong
19:05:55 <Eduard_Munteanu> They don't need to be expressible in Haskell either.
19:06:11 <copumpkin> yeah, my List example above goes through the category of monoids
19:06:17 <copumpkin> somewhat unsurprisingly
19:06:19 <jfischoff> copumpkin: way to rub it in ;)
19:06:36 <copumpkin> jfischoff: lol it's not just you. I've been calling that one out for years
19:06:46 <jfischoff> :)
19:09:10 <no-n> How do I avoid "Module imports form a cycle"? Do I have to import from a 3rd module if I want 2 modules to share things?
19:09:59 <pavonia> That's usually the best option, yes
19:10:35 <Eduard_Munteanu> no-n: it's common to have a separate Types module for example
19:12:04 <no-n> okay
19:12:50 <flebron> Well, I understand it as a pair (mu, eta), or (join, return), where if I have M (M (M a)), I can remove the parentheses in any order I like (that is, join . fmap join = join . join), and return does nothing (that is, join . return = id = join . fmap return), though I'm sure I've got uncountable type errors there :)
19:13:12 <copumpkin> oh, that's fine
19:13:19 <flebron> The first one wanting associativity, the second one wanting identity of return
19:13:22 <copumpkin> or at least looks fine :)
19:15:00 <flebron> What's the competing interpretation?
19:15:40 <copumpkin> "the kleisli category of a monad is indeed a category" is how I like to put it
19:18:39 <Eduard_Munteanu> flebron: or you can think of a monoid object, that is something like 1 --eta--> M <--mu-- M x M, literally a monoid in the category of endofunctors.
19:19:07 <flebron> The last time I tried to understand the commutative diagram on Wiki for monoidal category I think I had an aneurism :)
19:19:24 <flebron> Then I went to the nLab, guess how that turned out ;)
19:19:36 <dwcook> You swore off CT altogether?
19:20:12 <flebron> My conviction that I belong in CS and not the Math dept. was renewed
19:20:37 <dwcook> I think Haskell is a good demonstration of how deeply related they are though
19:21:04 <Eduard_Munteanu> flebron: yeah, those diagrams seem like too much, but it's really just formality to pin down the properties of a monoidal category.
19:22:02 <bitemyapp> flebron: I have a hick's understanding of CT but still find it useful for informing intuition about how it all fits together.
19:26:21 <nolrai66> can someone give me an example of how to actually use Data.Reflection?
19:28:53 <Eduard_Munteanu> nolrai66: for what purpose?
19:30:39 <nolrai66> I have a bunch of functions that all have a timeStep paramater, that is only used at the lowest level, and I would prefer not to explicitly thread it through, or use the reader monad.
19:31:26 <nolrai66> (Honestly given the scale..I could just just explicitly thread it through for _this particular_ problem, but it seems like it might be a useful thing to understand.
19:32:32 <Eduard_Munteanu> nolrai66: mind you're going to depend on Reifies or some other form of carrying it around in types
19:33:36 <Eduard_Munteanu> nolrai66: the basic idea is to have your type reference that information such that 'reflect' can recover it.
19:35:40 <Eduard_Munteanu> nolrai66: e.g. foo :: Proxy MyConfig -> ...  and you call reflect on that proxy.
19:36:09 <nolrai66> So how is it better then just passing around the value you need?
19:36:35 <Eduard_Munteanu> nolrai66: you can't change it. Also MyConfig is just phantom, it can have no constructors.
19:37:06 <nolrai66> hmm. Okay so its solving a slightly differnt problem then I thought it was.
19:38:05 <Eduard_Munteanu> nolrai66: the term "configuration" in the original paper refers to data that's figured out at the start of a program and it's kept the same throughout.
19:38:54 <Eduard_Munteanu> It's not really meant to give you a global variable or anything like that.
19:39:28 <nolrai66> Eduard_Munteanu: So you still have to write "foo p = bar p `op` baz p" instead of "foo = bar `op` baz"
19:40:35 <FreeFull> Probably  foo = liftM2 op bar baz
19:40:35 <Eduard_Munteanu> nolrai66: er, no, my previous statements were confusing... you can generate the 'p' with Proxy
19:40:50 <FreeFull> Or maybe not
19:41:30 <nolrai66> FreeFull: that would work too I think.
19:41:53 <nolrai66> Maybe I should just use the reader monad, I understand that.
19:42:15 <Eduard_Munteanu> > Proxy :: Bool
19:42:18 <lambdabot>  Not in scope: data constructor `Proxy'
19:42:21 <Eduard_Munteanu> Bleh.
19:43:14 <Eduard_Munteanu> nolrai66: it's enough to say 'Proxy' to get a 'Proxy s', however you'll need to fix 's' somehow
19:44:32 <Eduard_Munteanu> nolrai66: so while it might not be threaded around in the value, it still is in the type
19:45:08 <Eduard_Munteanu> nolrai66: one possible solution is to tag one parameter of your function with it
19:48:33 <nolrai66> Eduard_Munteanu: I need to see an actual example. Like if I changed "foo par z c = baz par z (bar par c); baz par z c = (z / par) + c; bar par c = c {arg1 = arg1 c + arg2 c / par}"  to reflect par what would it look like? (And yes I could just make baz and bar local instead).
19:49:24 <nolrai66> @kind Proxy
19:49:26 <lambdabot> Not in scope: type constructor or class `Proxy'
19:53:13 <Eduard_Munteanu> nolrai66: you can make foo :: (Reifies s Env) => ... -> Tagged s Something;  foo z c = let par = reflect (Proxy `asTaggedTypeOf` foo z c) in ... return something
19:53:49 <Eduard_Munteanu> nolrai66: which would get you a  par :: Env
19:53:59 <b2coutts> I'm trying to install wx with cabal, but when I try to install wxc-0.90.0.4, it fails during the configure step, with the exception "ExitFailure 1". Anyone know how I can figure out why it's failing?
19:54:09 <nolrai66> Hmm. Okay thanks!
19:56:49 <Eduard_Munteanu> Actually let par = reflect (proxy (foo z c)) is better
20:01:32 <TravisD> Is the difference between strict evaluation and lazy evaluation the same as the difference between applicative evaluation order and normal evaluation order?
20:02:00 <jmcarthur> TravisD: not exactly
20:02:36 <jmcarthur> TravisD: applicative evaluation order does have strict semantics, but normal evaluation order has "non-strict" semantics, not necessarily lazy
20:02:49 <jmcarthur> TravisD: "lazy" generally means non-strict with sharing
20:03:12 <TravisD> jmcarthur: Ah, so the main difference is that normal evaluation doesn't necessarily mean that you are sharing values
20:03:12 <jmcarthur> TravisD: or sometimes somebody might mean normal order with sharing
20:03:21 <jmcarthur> right
20:03:28 <Eduard_Munteanu> An optimized form of call-by-need, you may say.
20:03:45 <TravisD> Yeah, that makes sense - no point recalculating everything
20:04:21 <Eduard_Munteanu> Though it's not very meaningful semantically, this difference.
20:04:36 <jmcarthur> TravisD: i should have said lazy means normal order with sharing, not non-strict with sharing. the latter conflates denotation with operation
20:05:07 <Axman6> man opt
20:05:09 <Axman6> whoops
20:05:47 <TravisD> So sharing values only shortens the running time? (And does not change whether a procedure terminates or not?)
20:05:54 <jmcarthur> correct
20:06:13 <jmcarthur> in fact, applicative order already has the sharing which you would ordinarily lose by switching to normal order
20:06:22 <jmcarthur> lazy evaluation tries to retain the advantages of both
20:07:14 <TravisD> Yeah, right. That's pretty cool! I'm reading SICP for the first time. I don't think I really understood the difference between lazy and strict before
20:07:27 <TravisD> like, I had some idea about not doing calculations until you needed them, etc
20:07:30 <Eduard_Munteanu> As a sidenote, non-strictness would itself be of no consequence semantically (or an optimization) in a total language.
20:07:44 <jmcarthur> TravisD: i should emphasize that "lazy" is not the exact opposite of "strict"
20:07:48 <bitemyapp> Eduard_Munteanu: that'd never occurred to me before. Neat.
20:07:58 <TravisD> What is a total language? One where all procedures terminate?
20:08:12 <bitemyapp> TravisD: kinda? technically?
20:08:18 <Eduard_Munteanu> TravisD: yeah, like dependently-typed theorem provers
20:08:26 <jmcarthur> correct. a total language is strongly normalizing.
20:08:45 <jmcarthur> although you can kind of weaken that a bit with codata
20:08:46 <bitemyapp> TravisD: It means you know they'll terminate statically, but you can still model continuous/event-driven computation
20:08:46 <Eduard_Munteanu> Termination is too strict though, since you might want codata too.
20:08:54 <bitemyapp> TravisD: right, with codata.
20:09:22 <bitemyapp> the main limitation that bites most people is probably sub-structural recursion.
20:09:25 <jmcarthur> in a total language, when working with data you must prove termination, but when working with codata you must prove productivity, instead.
20:09:28 <Eduard_Munteanu> Yeah, without codata you don't really have non-strict devices like infinite lists.
20:09:44 <Eduard_Munteanu> So it would be a trivial thing.
20:09:46 <jmcarthur> well, codata isn't exactly necessary to express such things
20:10:02 <TravisD> Ah, that sounds cool. I've never really heard of codata before. A friend of mine was telling me about it in the contex of Coq, but I didn't really follow
20:10:04 <Eduard_Munteanu> No? :/
20:10:14 <jmcarthur> you could write a program which represents a seed and a step function to be interpreted by the runtime, similarly to the way IO works in haskell
20:10:35 <Eduard_Munteanu> jmcarthur: that requires a corecursive wrapper of some sort, though
20:10:38 <richo> So I have a data type `List` which is [LispVal]. I'm recieving one to this function, but when I try to append to the start and use that result, it's now [LispVal], instead of LispVal. How can I force it to be treated as List, which is a LispVal?
20:10:45 <bitemyapp> jmcarthur: I was working on modelling a simulation similarly not too long ago.
20:10:48 <Eduard_Munteanu> Well, maybe not strictly coinductive types.
20:10:49 <jmcarthur> Eduard_Munteanu: right, but the point is you don't have to work with corecursion in the language
20:10:56 <richo> code, if it helps: https://gist.github.com/eeb929d34eb28c9a3576
20:10:57 <jmcarthur> Eduard_Munteanu: just like you don't have to work with side effects in haskell
20:11:02 <no-n> is there another way to write > x == y = f x == f y
20:11:05 <Eduard_Munteanu> Hm, yeah.
20:11:38 <Eduard_Munteanu> :t (==) `on` f
20:11:39 <lambdabot>     Could not deduce (Eq b0) arising from a use of `=='
20:11:40 <lambdabot>     from the context (Show a)
20:11:40 <lambdabot>       bound by the inferred type of it :: Show a => a -> a -> Bool
20:11:47 <Eduard_Munteanu> :t (==) `on` ?f
20:11:48 <lambdabot> (Eq b, ?f::a -> b) => a -> a -> Bool
20:11:50 <TravisD> Anyways, thanks :) That was interesting. Back to reading!
20:11:54 <Eduard_Munteanu> no-n: ^^
20:12:23 <no-n> hehe. thanks
20:12:30 <Eduard_Munteanu> no-n: if you're writing an Ord instance, you might like to use "comparing f"
20:12:38 <Eduard_Munteanu> :t comparing ?f
20:12:39 <lambdabot> (Ord a, ?f::b -> a) => b -> b -> Ordering
20:12:41 <no-n> not Ord, just Eq
20:13:01 <TravisD> Hmm, actually - is there a language with Haskell's notation but with applicative order evaluation?
20:13:04 * Axman6 feels there should also be a function equating
20:13:06 <no-n> just comparing records for by their id
20:13:10 <no-n> -for
20:13:23 <Eduard_Munteanu> Axman6: heh, yeah, I wanted something like that
20:13:29 <Eduard_Munteanu> Wished for, rather.
20:13:32 <jmcarthur> me too
20:13:59 <Axman6> Haskell2014 proposal: * Add equating to Data.Eq (nothing else)
20:14:07 <jmcarthur> but i wish for sortOn and groupOn even more, totally eliminating the need for comparing and equating
20:14:22 <jmcarthur> sortOn :: Ord b => (a -> b) -> [a] -> [a]
20:14:23 <Eduard_Munteanu> Axman6: that might be enough for a release of a new standard :)
20:14:33 <Axman6> Ord b => (a ->b) -> [a] -> [a]?
20:14:33 <jmcarthur> groupOn :: Eq b => (a -> b) -> [a] -> [[a]]
20:14:44 <jmcarthur> yes
20:14:47 <Axman6> yeah
20:14:56 <Axman6> @where stereo
20:14:57 <lambdabot> I know nothing about stereo.
20:15:05 <Axman6> bleh, how do I lambdabot
20:15:22 <jmcarthur> and another benefit being that the function could be somewhat expensive. it could do the map to tuples, sort tuples, map out original components optimization
20:15:39 <Axman6> yeah, I've wanted that too
20:15:39 <jmcarthur> although it's not always an optimization, i guess
20:15:47 <Axman6> sortBy hash for example
20:16:04 <Axman6> fortBy and sortBy' would make sense
20:16:11 <Axman6> s*
20:16:47 <Eduard_Munteanu> :t (unzip .) . zip  -- I'd call it "cut"
20:16:48 <lambdabot> [a] -> [b] -> ([a], [b])
20:16:52 <jmcarthur> along the same lines, a combined sort/group function would be nice, especially for this optimization
20:17:41 <jmcarthur> (map.map) snd . groupBy ((==) `on` fst) . sortBy (comparing fst) . map (f &&& id)   -- really common
20:18:00 <Eduard_Munteanu> jmcarthur: S.toList . S.fromList  is generally a nice alternative
20:18:17 <jmcarthur> Eduard_Munteanu: except when you want to sort/group on some transformed versions of the elements
20:18:18 <Eduard_Munteanu> Or a Map variant.
20:18:30 <jmcarthur> yeah, Map would be more equivalent i guess
20:18:44 <jmcarthur> however, you lose some laziness with that
20:18:53 <Eduard_Munteanu> Oh, hm, right.
20:19:35 <jmcarthur> also, Map and Set are not in base
20:19:43 <jmcarthur> although at least they are included with ghc
20:21:29 <Eduard_Munteanu> Would be nice to get some more fusion and perhaps streams in base.
20:26:33 <NemesisD> does anyone use flycheck when working on haskell stuff?
20:26:39 <NemesisD> i think my configuration is faulty
20:26:54 <jmcarthur> i do, but i don't remember what i did. i think it's an old ghc-mod configuration
20:27:19 <jmcarthur> oh i might be thinking flymake
20:27:23 <jmcarthur> i don't remember the difference
20:27:53 <NemesisD> flycheck is a newer one from what i gather. doesn't come bundled with emacs, supposed to be faster and overall nicer
20:30:12 <ski> @pl \a b -> f b a
20:30:12 <lambdabot> flip f
20:30:21 <ski> @pl \a b c -> f c a b
20:30:23 <lambdabot> flip . flip f
20:30:26 <ski> @pl \a b c -> f c b a
20:30:30 <lambdabot> flip (flip . flip f)
20:30:36 <ski> hrm, too ugly
20:30:46 <haasn> \a b c -> f c a b  = f ?? a ?? b
20:31:05 <haasn> but using ?? with multiple arguments like that is incredibly misleading and should probably be avoided
20:31:40 <haasn> err, \a b -> f ?? a ?? b
20:32:00 <haasn> going more pointless than that is pointless either way
20:32:21 <ski> i wanted the last of the three
20:35:36 <ski> @type \f a b c -> f c b a
20:35:38 <ski> @type \f a b c -> (flip `flip` a) (f `flip` b) c
20:35:55 <lambdabot> (t1 -> t2 -> t3 -> t) -> t3 -> t2 -> t1 -> t
20:35:55 <lambdabot> (a -> b1 -> b -> c) -> b -> b1 -> a -> c
20:36:25 <ski> seems the best i can manage, but it's still ugly and very hard to follow (as opposed to taken on faith)
20:40:43 <ski> @type \f a b c -> ((flip . flip f) `flip` a) b c
20:41:07 <lambdabot> (a1 -> a -> b -> c) -> b -> a -> a1 -> c
20:41:08 <ski> is perhaps slightly better
20:46:39 <dyeprii> do you guys happen to know some good resources about network programming in general?
20:53:10 <Axman6> dyeprii: what do you want to know?
20:54:00 <dyeprii> nothing in particular
20:54:28 <Axman6> any particular system? (*nix or windows)?
20:55:54 <dyeprii> I have a running arch linux.
20:56:45 <Axman6> I haven't used it myself, but this looks promising: http://www.tenouk.com/cnlinuxsockettutorials.html
20:57:05 <Axman6> (Haskell makes this stuff much much nicer than doing it in C IMO)
20:58:00 <Axman6> http://en.wikipedia.org/wiki/Berkeley_sockets should jive you an overview of the basics
20:59:22 <dyeprii> thanks thanks. I might want to learn C (ain't that hard?)
20:59:26 <dyeprii> haha
20:59:32 <Axman6> heh, indeed
21:00:18 <Axman6> I'd guess most languages probvides a berkeley sockets interface in one form or another though. C isn't a prereq
21:03:13 <Axman6> dyeprii: that said, a good foundation in C is very useful in using many languages.
21:04:27 <dyeprii> I've read that k&r book some time ago, but stopped, due to heavy school works. I am not an it/comsci major really.
21:05:13 <suOya_> I'm taking the Computer Networks -course on Coursera right now before I attempt to dive into network programming
21:05:17 <suOya_> It's a great course
21:05:45 <Axman6> excellent idea
21:06:38 <suOya_> Too many acronyms and protocols to learn by trial and error so might as well learn them in one bundle
21:06:49 <suOya_> That's how I feel right now
21:07:18 <dyeprii> suOya_: still ongoing? I might enroll.
21:07:30 <joneshf-laptop> if you have a kind * -> * ->  * can you implement pure by taking a tuple of the first two arguments or something?
21:08:20 <suOya_> dyeprii: It's on week 6 already (halfway through), but you can still enroll although you won't get internet points due to passed deadlines ;)
21:08:48 <suOya_> dyeprii: https://www.coursera.org/course/comnetworks
21:08:57 <Axman6> no internet points? what's the point then? You don't just learn things for nothing!@
21:09:25 <suOya_> Agreed.
21:09:33 <suOya_> The points are the point!
21:09:53 <Axman6> tryna tick ya inta lernin!
21:10:24 <suOya_> How's network programming in Haskell btw?
21:10:28 <shachaf> joneshf-laptop: People are probably not answering you because they can't make any sense of your question. At least, that's why I wasn't answering. Try rephrasing your question.
21:10:29 <suOya_> I haven't even looked
21:10:50 <dyeprii> suOya_: there are 'points' in coursera?
21:11:13 <Axman6> suOya_: quite nice, and quite high performance thanks to GHC's excellent IO manager
21:11:19 <suOya_> dyeprii: The points which tell you how well you passed a certain course, if you care about them
21:11:20 <dyeprii> i only know certificates but you have to pay for them
21:11:24 <Axman6> (epoll/kqueue based)
21:11:34 <suOya_> dyeprii: Screw the certs
21:11:34 <haasn> suOya_: it gets cooler once you start using higher level abstractions
21:11:45 <suOya_> dyeprii: Learning is all ^^
21:11:46 <dyeprii> suOya_: haha!
21:12:27 <suOya_> Axman6: I'm looking forward to it then
21:12:54 <joneshf-laptop> shachaf, haha
21:13:00 <joneshf-laptop> one sec
21:13:09 <Iskander> Haskell noob here, is there any predefined module for working with FIFO/LIFO structures?
21:13:20 <Iskander> I'm thinking queues/stacks
21:13:26 <suOya_> Streams?
21:13:45 <Taneb> Iskander, well, for stacks you can just use []
21:13:47 <Axman6> well LIFO is just list no?
21:13:55 <Taneb> Queues are more difficult
21:14:04 <Axman6> you can use Seq for queues though
21:14:05 <joneshf-laptop> http://lpaste.net/100015
21:14:15 <joneshf-laptop> where does that fall down?
21:14:41 <Iskander> Thank you
21:14:44 <Taneb> :t pure
21:14:45 <lambdabot> Applicative f => a -> f a
21:14:49 <shachaf> What is the type of pure here?
21:14:55 <shachaf> Where does a tuple get into it?
21:15:13 <joneshf-laptop> can't you unify `a` with `(a1, a2)` or somehing?
21:15:33 <Taneb> joneshf-laptop, not always
21:15:36 <Taneb> a could be Int
21:15:39 <no-n> I have an (f :: Foo -> Bool) and an (x :: IO Foo), how do I condition a guard on (f x)?
21:16:09 <shachaf> You don't get to choose a.
21:16:20 <joneshf-laptop> so if i want an applicative it has to work with EVERY haskell value?
21:16:54 <shachaf> Do you mean every type?
21:17:02 <joneshf-laptop> sure
21:17:47 <no-n> anyone?
21:18:07 <Axman6> no-n: ?
21:18:25 <haasn> there's no constraint on ‘a’ here, so the instance is valid for any ‘a’
21:19:02 <haasn> if it were instance a ~ (b,c) => Applicative (Foo a) where ... -- you'd have the constraint that ‘a’ must be a tuple. But in the general case, that's simply not always true
21:19:52 <joneshf-laptop> how would that work?
21:20:33 * ski thinks he just invented an idiom for named `let' (one argument) with matching
21:20:48 <joneshf-laptop> wouldn't that mean i wanted `Foo (b, c) -> d -> Foo (b, c) d` ?
21:20:55 <joneshf-laptop> erm
21:20:57 <pavonia> no-n: fmap f x? Not sure if that's what you're asking for
21:21:00 <joneshf-laptop> wouldn't that mean i wanted `Foo :: (b, c) -> d -> Foo (b, c) d` ?
21:21:22 <no-n> sorry, I mean (f whats_inside_x)
21:21:25 <joneshf-laptop> ski, do tell
21:21:43 <no-n> pavonia: tried that first but didn't work
21:22:05 <pavonia> no-n: What result value do you expect?
21:22:11 <pavonia> *result type
21:22:15 <no-n> Bool
21:22:21 <pavonia> That's not possible
21:22:26 <no-n> oh
21:22:32 <shachaf> haasn: Hmm?
21:22:45 <shachaf> haasn: You can never get a guarantee that pure's argument will be a tuple, with Applicative.
21:22:50 <shachaf> You can't put a constraint on that type.
21:23:13 <Guest66903> Hi. Is it possible to declare the same module across different files and each file would have its own list of export?
21:23:50 <ski>   foo x = ... $ (`fix` y) $ \case
21:23:54 <ski>     bar (Y0 ...) -> ...
21:23:56 <ski>     bar (Y1 ...) -> ...
21:24:03 <ski> joneshf-laptop : like that
21:24:16 <haasn> shachaf: oops, I was reading joneshf-laptop's statement about unifying a with (a1,a2) and thought that was what he was doing - you're right, that won't make line 4 valid in any way shape or form
21:24:32 <no-n> eh, will just make the enclosing function Foo -> IO Foo instead of IO Foo -> IO Foo
21:24:49 <shachaf> That's the trouble with alpha-renaming. It should be illegal.
21:25:12 <joneshf-laptop> IO isn't a comonad?
21:25:18 <ski> (the interesting part is the part after the first `$' .. the previous part was just included to get an idea how one could layout it a bit similar to defining `bar' in a `where'-clause)
21:25:25 <ski> joneshf-laptop : it's not a comonad
21:26:02 <b2coutts> Is there a way to make a function that "modifies" a single parameter of a custom datatype? i.e., an implementation of http://lpaste.net/100016
21:26:21 <ski> (whether I/O is a comonad, otoh, was a question pondered by Kieburtz(?) -- i think our conclusion was that it doesn't work, unless possibly we have uniqueness types)
21:27:00 <Axman6> b2coutts: that's exactly what record syntax does. also lenses
21:27:18 <joneshf-laptop> ski, hmm, where's it break, if you remember? does it have a `coreturn`?
21:28:18 <richo> I'm confused. If I have a call that returns a different type than the function the call is in, why is that an error? it shouldn't be return to return that from the function
21:28:19 <geekosaur> b2coutts, if you're using that form then your best bet is \(Thing _ b c d e f) -> Thing 0 b c d e f
21:28:31 <joneshf-laptop> ski, oh, you're mentioning two different concepts...i think
21:28:31 <ski> no-n : if possible (without contorsions) it's probably better to have a type `A -> M B', rather than `M A -> M B' for a function, where `M' is a monad
21:28:44 <no-n> ski: yeah
21:29:08 <b2coutts> Axman6: geekosaur I'm using record syntax in my actual code; does record syntax define such functions? I thought it only provided "getter" functions
21:29:24 <geekosaur> b2coutts, if you use record syntax, you can use a record update (\x -=> x {a = 0})
21:29:32 <Axman6> richo: that question doesn't make much sense...
21:29:34 <geekosaur> er typo
21:29:35 <ski> (no-n : namely, if the first thing the function of type `M A -> M B' does is execute the argument action, then never touch that action again)
21:29:50 <ski> joneshf-laptop : you were asking about two things :)
21:29:52 <geekosaur> richo, can you show what you mean? what you said doesn't mean much without context
21:29:57 <richo> sure, one sec
21:30:04 <geekosaur> (and seems slightly confuded although I can't tell if it's typo or thinko)
21:30:39 <geekosaur> b2coutts, in any case you want record update syntax
21:30:46 <joneshf-laptop> hmm, so is  the only  way around this `pure` situation to constrain it with a Monoid or somehting that has a unit? so you can magic one of the types out of `mempty`?
21:30:52 <geekosaur> foo {field = newval}
21:31:45 <joneshf-laptop> instance Monoid a => Applicative (Foo a) where {pure x = Foo mempty x}
21:31:46 <joneshf-laptop> or something
21:31:58 <richo> Axman6, geekosaur https://gist.github.com/eeb929d34eb28c9a3576
21:31:59 <b2coutts> geekosaur: awesome, thanks
21:32:55 <Axman6> richo: you want mapM or mapM_
21:32:57 <Axman6> :t mapM
21:32:58 <geekosaur> richo: you are looking for mapM_
21:32:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:32:59 <Axman6> :t mapM_
21:33:00 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
21:33:10 <richo> Ah, that makes sense.
21:33:13 <richo> thankyou
21:33:49 <Kaidelong> does GHC have a facility for a kind of ad hoc overloading?
21:34:11 <Kaidelong> I'm wondering if it's possible to do something for top level bindings like you can do for typeclass methods that have defaults
21:34:33 <Kaidelong> "I know this already exists but if you encounter this specific type, use me instead, I'm better"
21:34:53 <geekosaur> Kaidelong, maybe you are looking for the RULES pragma?
21:34:55 <hakujin> rewrite rules maybe?
21:35:08 <Kaidelong> I was thinking rewrite rules might be sufficient
21:35:37 <Kaidelong> it seems like a roundabout way to point to a specialized implementation though
21:39:45 <geekosaur> Kaidelong, there used to be a SPECIALIZE syntax to do that but SPECIALIZE creates a RULE these days so you're better off just using a RULE
21:40:08 <Kaidelong> Yeah, I just found it
21:40:34 <Kaidelong> thanks
21:42:23 <ski> joneshf-laptop : it's been a while, but .. but looking at <http://comments.gmane.org/gmane.comp.lang.haskell.cafe/812>, it's obviously a problem that `w' is used more than once
21:43:54 <ski> joneshf-laptop : if we visualize `OI a' as `(RealWorld,RealWorld -> a)', then we want to disallow `RealWorld', and (almost surely) therefore also disallow copying such `OI'-passions
21:45:00 <no-n> is there Haskell for Android?
21:45:25 <ski> joneshf-laptop : istr i also had some other issue with it, but i don't recall it atm
21:45:56 <ski> joneshf-laptop : did you follow the named `let' thing ?, btw ?
21:46:41 <no-n> no-n: lmgtfy
21:47:14 <ski> hmm
21:49:45 * hackagebot hit 0.5.5 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.5 (VincentHanquez)
22:01:24 <satc> Any thoughts why type of members of a class can not be kind restricted. http://lpaste.net/100018
22:02:01 <platz> it looks like there's a good cross compiler for ghc to iOS
22:04:49 * hackagebot yesod-pagination 0.3.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.3.0.0 (JoelTaylor)
22:05:31 <haasn> satc: using ‘m’ as a parameter to a function requires it have kind * (or # or ## if that even still exists, technically; but those are not really relevant here)
22:06:28 <haasn> satc: there can't possibly be a value that has a type of kind ‘Mode’, so m -> TypeRep is a kind error
22:06:42 <satc> haasn: Thanks..
22:09:33 <ivanm> when using associated types (i.e. type families), is there a way of saying something like: if `a' has an Eq instance, then so must `Foo a'?
22:10:11 <ivanm> because when I try and use (Foo a) inside another data structure, I can't derive instances for it :/
22:11:14 <haasn> ivanm: you could make Eq a :- Eq (Foo a) a method of your class (see http://hackage.haskell.org/package/constraints-0.3.4.2/docs/Data-Constraint.html)
22:11:22 <haasn> Or just :: Eq a => (Foo a => b) -> b
22:11:27 <haasn> if you want to avoid the edwardk dependency :)
22:11:33 <ivanm> heh
22:12:17 <ivanm> what's the `b' there?
22:12:47 <ivanm> wait, and edwardk library with only one dependency that doesn't come with GHC? :o
22:13:57 <haasn> the ‘b’ whatever you wish to construct in the context (Eq (Foo a))
22:14:06 <haasn> I typo'd, I meant :: Eq a => (Eq (Foo a) => b) -> b
22:14:11 <ivanm> I have "class Bar a where type Foo a", are you saying to add that to the Bar clas?
22:14:12 <haasn> But come to think of it, I'm not sure either of these do what you want
22:14:29 <haasn> this way just means that you will always have to ensure (Foo a) is Eq, but you can have access to Eq a if you want
22:14:59 <haasn> that's the closest thing I can think of to simulating what you wanted at any rate
22:15:01 <haasn> and yes
22:15:56 <ivanm> hmmm....
22:16:23 <ivanm> what I'm really trying to do is "data Baz a = Baz (Foo a) deriving (Eq)", but GHC doesn't like that :s
22:17:16 <ivanm> even though the way I'm using it, it's for cases like "Foo [a] = a"
22:17:27 <haasn> oh, yes, my approach won't help you with that (in fact, it also wouldn't even be necessary, since you can just replace every (Eq a) by (Eq a, Eq (Foo a)) manually where needed)
22:17:36 <haasn> But maybe you could try this:
22:17:57 <haasn> {-# LANGUAGE StandaloneDeriving #-} data Baz a = Baz (Foo a); deriving instance Eq (Foo a) => Eq (Baz a)
22:18:24 <ivanm> hmmmmm....
22:19:28 <ivanm> it also wanted FlexibleContexts and UndecidableInstances :s
22:19:47 <haasn> ouch!
22:20:08 <ivanm> Flexible because of the Foo  in the constraint
22:20:11 <haasn> yeah
22:20:17 <haasn> And UndecidableInstances because it's no smaller?
22:20:21 <ivanm> yeah
22:20:36 <haasn> I suppose it makes sense
22:20:42 <haasn> what if you have somewhere that Foo x = Bar x
22:20:48 <haasn> for some x
22:22:09 <ivanm> yeah
22:22:12 <ivanm> even though I won't...
22:22:20 <ivanm> (unless, of course, some stupid user does so...)
22:24:51 * hackagebot yesod-platform 1.2.7 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.7 (MichaelSnoyman)
22:27:54 <jle`> isn't it cool that we can turn anything into a monoid using List
22:28:11 <johnw> that's what being a free monoid is all about
22:28:27 <johnw> you can turn anything into a monad with the free monad, etc.
22:28:27 <jle`> need something with a Monoid instance, but don't want to worry about the actual operator/implementing it for now?
22:28:36 <jle`> just throw it into a list! free Monoid instance
22:28:39 <jle`> life is good.
22:28:54 <johnw> the freeness is exactly this "decide later" semantics
22:29:11 <jle`> let us take a moment then to thank whoever invented free monoids.
22:29:13 <johnw> the operators simple exist and obey the laws, but they don't *do* anything
22:29:19 <johnw> free objects in general!
22:29:26 <jle`> huzzah!
22:30:08 <jle`> although i have found less use for free monads than for free monoids but maybe i am looking in the wrong places
22:30:33 <johnw> i haven't used them much either
22:30:39 <levi> There tend to be more uses for things with less structure.
22:31:47 <jle`> fair enough
22:34:56 <platz> There was a presentation about free monads and a guest commented that it wasn't a truly 'deep embedding' in the DSL sense since you loose the ops that construct the monad values.. so the presenter suggested free applicatives.. those sound harder to use for some reason though
22:35:53 <platz> or maybe not.. might just have to build an example first
22:49:33 <jle`> i don't even think i could quote the applicative laws off the top of my head
22:51:34 <thebnq> applicatives are composable too
22:52:24 <bitemyapp> jle`: identity, composition, homomorphism, interchange
23:00:08 <jle`> bitemyapp: bravo
23:00:24 <jle`> i think i still haven't internalized the significance of the applicative laws
23:00:45 <jle`> i mean...i see that the monad laws are just the category laws for the kleisli category
23:01:06 <jle`> and that the functor laws represent...fundamental functorness...for lack of a better word
23:01:13 <jle`> but the applicative laws seem kinda arbitrary to me
23:01:15 <thebnq> just.. =/
23:01:43 <jle`> =\
23:02:26 <thebnq> i think i'm comfortable only with the functor laws :)
23:02:45 <bitemyapp> jle`: the only unfamiliar ones should be homomorphism or interchange.
23:02:52 <bitemyapp> jle`: you get identity and composition right?
23:03:15 <jle`> i understand the laws in and of themselves
23:03:23 <jle`> but i do not see how they constitute, together, fundamental applicativeness
23:03:29 <bitemyapp> jle`: that's what I'm getting at.
23:03:33 <jle`> ah okay
23:03:35 <jfischoff> IIRC the lax monoidial version of applicatives laws are simpler
23:03:44 <jle`> then yes
23:03:47 <bitemyapp> jle`: I do all of this stuff by intuition. Thumb held up to moon.
23:04:02 <jle`> okay, proceed :)
23:04:05 <bitemyapp> I'm not a robot repeating ncatlab articles.
23:04:24 <jfischoff> http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
23:04:25 <bitemyapp> jle`: okay so basically, you know how when you have multiple objects interacting
23:04:35 <bitemyapp> jle`: it increases the number of possible interactions?
23:04:51 <bitemyapp> if you increase the number of discrete objects.
23:05:06 <bitemyapp> jle`: don't try to make what I'm saying too literal, just tell me if you know what I mean or not.
23:05:37 <jle`> i follow so far
23:06:15 <bitemyapp> jle`: okay so, I work on a somewhat...silly appreciation of the typeclassopedia and what it all means (personally) and I think my view on it would make some people (stronger math background) seethe.
23:06:38 <bitemyapp> jle`: but I see the laws as being a way to ensure the basic principles of the "faculty" hold despite the introduction of more possible interactions
23:06:49 <bitemyapp> jle`: with that in mind, lets think about the progression.
23:07:28 <bitemyapp> jle`: where in the case of simple function application you have f and x, possibly another g if you want to make a point about composition right?
23:07:54 <jle`> sure
23:07:58 <bitemyapp> jle`: functors are really a simple extension of function application (lifting to type)
23:08:15 <bitemyapp> jle`: concordantly, the laws have a nice symmetry with what you expect out of typical function application
23:08:35 <bitemyapp> jle`: but applicatives are in some respects, reifying the "container" or minimal type constructor.
23:08:47 <bitemyapp> jle`: this introduces another "object" to contend with in this "space"
23:09:28 <bitemyapp> jle`: with that in mind, you can see interchange as addressing what invariants hold for that.
23:10:21 <bitemyapp> jle`: homomorphism about the containers, namely that they won't suddenly change what things mean. again, just lifting.
23:10:55 <jle`> hm
23:10:59 <jle`> i see what you mean
23:11:16 <jle`> but i need more convincing that these laws represent the fundamental invariants
23:11:41 <jle`> cause i feel like they are just 'some' of them
23:12:21 <jle`> i expect those things to hold for typical function application
23:12:24 <bitemyapp> jle`: hum, the applicative laws specifically are what's desirable in "Hask"
23:12:52 <bitemyapp> jle`: the applicative laws are stem from either the functor laws or the monoidal functor laws from CT itself.
23:12:53 <jle`> but why is 'those things' able to characterize function application in all meaningful ways
23:13:27 <jle`> i think the monoidal functor laws are interesting
23:13:33 <bitemyapp> jle`: if you're asking for fundamentals, you need to just learn the category theory and read up on strong and lax monoidal functors
23:13:59 <jle`> heh
23:14:01 <bitemyapp> jle`: my more pragmatic perspective is that the CT is critical, but you don't need it to justify a reasonable definition of a "well behaved" applicative.
23:14:20 <jle`> i see that the laws capture some of the expectations of applicatives
23:14:27 <bitemyapp> jle`: I offered you that "pragmatic" (not even really the right term) perspective then you flipped it around and suddenly wanted hard & fast immutable laws of mathematics.
23:14:37 <jle`> but i was not too convince that they captured 'all' of the expectations
23:14:47 <jle`> convinced
23:14:51 <bitemyapp> jle`: what expectation do you think should be covered that isn't?
23:14:53 <jle`> like i said, they seemed kinda arbitrary
23:14:59 <bitemyapp> jle`: I can provide a counter-point related to monoids.
23:15:09 <jle`> well...i cannot say what expectations that i did not expect to be covered but did not
23:15:13 <jle`> but i did not feel that sense of finality
23:15:22 <jle`> as an "ah, this is it."
23:15:22 <bitemyapp> jle`: blah. I have an example for nonoids.
23:15:24 <bitemyapp> monoids*
23:15:26 <bitemyapp> just bear with me.
23:15:26 <jle`> like i do for the monad laws
23:15:40 <bitemyapp> jle`: monoids aren't required to be commutative (abelian group). I think that's fine and that's not what a monoid is anyway.
23:15:51 <jle`> i have no intent to offend or waste your time :|
23:16:20 <bitemyapp> jle`: requiring them to be commutative would have some nice properties for modelling things like parallel computation (folds) but we'd still end up needing non-commutative monoids for filling out the typeclassopedia.
23:16:43 <jle`> what is this counter-point addressing?
23:16:45 <bitemyapp> so, I just provided an example of a possibly "desirable" additional "law" that isn't actually a good idea as a universal constraint.
23:17:03 <bitemyapp> with that in mind, absent some kind of concrete objection, I cannot do anything about your "feelings"
23:17:12 <bitemyapp> except perhaps suggest you get a mug of hot chocolate and write some code.
23:17:31 <bitemyapp> I find that makes everything better :)
23:18:03 <jle`> :)
23:18:38 <jle`> in practicality i don't think that not understanding the applicative laws has ever stopped me from using applicatives everywhere
23:18:47 <jle`> except for in those dark corners of life
23:18:58 <jle`> from which i hope not to return
23:19:36 <bitemyapp> jle`: I still don't have a good meaning for your notion that you don't understand the applicative laws.
23:19:49 <bitemyapp> jle`: I can look at them, in Haskell code form, and simply nod my head and say - "yes, makes sense"
23:19:52 <jle`> hm.
23:20:05 <bitemyapp> jle`: when I began to explain them, you then professed your understanding of the applicative laws you just expressed discomfort with.
23:20:24 <bitemyapp> jle`: then when I offered the intuitive appreciation of the why/what of the laws, you moved onto hard/fast mathematical fundamentals.
23:20:33 <bitemyapp> jle`: you are a chameleon and do not seem to have a specific objection.
23:21:00 <bitemyapp> the laws let us define good behavior that can be easily encoded as invariants in QuickCheck. Boom. Bang. End of story. There's your pragmatism.
23:21:22 <bitemyapp> monoidal functors themselves operate on a spectrum of laws in CT from my understanding, applicatives are somewhere in there.
23:23:17 <jle`> well, we have expectations about what application inside containers should look like.  the laws kind of put them down on paper...but it is not immediately obvious that the laws encapsulate *all* of our expectations about applications inside containers.  like, if i were to sit down and write down the applicative laws by hand, i might write three of them and then one day think 'oh, what about this?' and write
23:23:19 <jle`> a fourth.  but i wouldn't know inherently from writing that fourth down that four was all there was
23:23:37 <jle`> maybe one day i'll think of a fifth?
23:24:01 <jle`> however, for the monad laws, the monad laws are literally just the category laws for kleisli
23:24:30 <jle`> and if i understand that the category laws are all there are, then the three monad laws are really everything there is to the idea of monad-ness
23:25:11 <jle`> and i can be confident that there is nothing missing in the monad laws
23:25:31 <jle`> nothing missing about something i expect monads to behave but were not in the laws, and i won't walk around and all of a sudden think of a fourth monad law some day
23:27:36 <jle`> i...might have perhaps said the same thing one day in the tenth grade when learning about the "laws" of equality ... transitivity, reflexivity, identity...
23:27:54 <jle`> but maybe i just got used to it over time
23:28:18 <jle`> or were able to understand equivalence/equality as nothing 'more' than those three laws, and it wasn't too much of a jump
23:33:52 <bitemyapp> jle`: Still nothing to work with. I don't know what's out of place or missing.
23:36:32 <jle`> perhaps the question was then why are there four laws, and not five?  why are these four laws enough to completely describe and anticipate all of our expectations of applications inside containers?
23:36:57 <jle`> i guess...it's not altogether a concrete or too answerable of a question
23:43:53 <platz> jle`: looking back at mcbride's applicative paper, it says the applicative law are the laws from functor plus those from monoidal
23:45:18 <platz> and i guess just like monads are typically defined asymetrically which obscures their kliesli nature, applicatives are also defined asymetrically and make more sense when defined symetrically
23:46:07 <platz> hrmm, but i don't get any of that - need to study further
23:48:57 <jle`> i guess this is also a pragmatic concern too...because what if i define something/use something that obeys all four laws --- how can i be sure that it won't bite me some day and there will be a use case which i 'expect' to behave like function application inside a container, but actually isn't?  how can i know that those four QuickCheck tests cover all my expectations?
23:49:06 <jle`> for real life usage.
23:50:16 <levi> When you talk about an algebraic structure like a Monoid, the laws are what define what it is to be that structure. If there were more, it would be called something else.
23:50:49 <jle`> levi: well, it's perhaps different because monoids do not profess or claim to be anything semantically different from just what their laws state
23:51:01 <jle`> monoids are just...monoids, things which obey these three laws
23:51:14 <levi> The same thing can be said of Monad and Applicative.
23:51:19 <jle`> applicative functors are 'things that obey these laws', but they also carry a claim to semantics
23:51:31 <jle`> which bitemyapp went through a lot of trouble explaining
23:51:42 <jle`> applicative functors claim a semantic interpretation/meaning
23:51:46 <jle`> independent of their laws
23:52:34 <ivanm> haasn: it also appears that any data type that I have that value in _also_ needs to use standalone deriving rather than being able to derive the classes :s
23:52:42 <jle`> if you try to explain to someone what a monoid is
23:53:01 <jle`> you would not be able to say anything more than just their laws
23:53:26 <jle`> but when you explain applicative functors, you have the magical *ability* to explain them by their semantics
23:53:39 <jle`> if you so choose
23:53:42 <jle`> instead of just by their laws
23:58:15 <levi> Applicatives and Monads are just different sorts of monoidal functors.
23:59:31 <platz> if applicatives are 'strong lax monoidal functors', what kind of monoidal fuctors are monads?
