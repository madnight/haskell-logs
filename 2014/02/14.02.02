00:01:13 <tac> How is "conjugation" by a function useful as a default?
00:01:15 <tac> o__O
00:01:16 <levi> > appEndo (Endo (+1) <> Endo (+1) <> Endo id) 3
00:01:17 <lambdabot>  5
00:01:40 <jle`> ^^
00:01:51 <jle`> it's similar to the default monoid instance for Maybe actually
00:02:02 <tac> Or perhaps that instance is a weird one that isn't standard. I don't see it in the docs
00:02:41 <jle`> it's defined in Data.Monoid
00:02:46 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Monoid.html
00:02:53 <jle`> ctrl+f "a -> b"
00:04:05 <tac> ah, I see
00:04:05 <amalloy> is there a nice way to write this without do-notation? do {foo <- f x; return (x `g` y)}. it seems to me like that's basically f x <$> (`g` y) assuming that i can treat my monad like a functor, but i'm pretty confused about it
00:05:11 <amalloy> :t <$>
00:05:11 <lambdabot> parse error on input `<$>'
00:05:18 <jle`> um
00:05:23 <jle`> you don't use foo anywhere
00:05:34 <jle`> besides where you bound it
00:05:38 <levi> The normal (a -> b) instance of Monoid does a mappend of the return values, with the constraint that b has a Monoid instance. It doesn't work with Int functions because Int doesn't have a Monoid instance.
00:05:41 <amalloy> oh, sorry. that's what i get for editing
00:05:56 <amalloy> do {foo <- f x; return (foo `g` y)}
00:06:02 <jle`> oh
00:06:15 <jle`> g <$> f x <*> pure y
00:06:17 <jle`> or
00:06:22 <jle`> flip g y <$> f x
00:06:37 <amalloy> ugh, i just got the argument order for <$> backwards, didn't i
00:06:52 <jle`> <$> is just fmap
00:06:57 <jle`> `fmap`
00:07:03 <jle`> :t (<$>)
00:07:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:07:08 <jle`> @src (<$>)
00:07:09 <lambdabot> f <$> a = fmap f a
00:07:22 <amalloy> yeah, i know. i get confused when i use it infix, even though i know its order prefix-style :P
00:07:34 <jle`> :)
00:07:37 <jle`> i think of it as
00:07:41 <jle`> "$ but inside"
00:07:47 <jle`> > (*2) $ 3
00:07:48 <lambdabot>  6
00:07:52 <jle`> > (*2) <$> Just 3
00:07:53 <lambdabot>  Just 6
00:08:04 <zett_zelett> http://lpaste.net/99341 Running `head solutions` on this thing takes nearly 10 minutes on my machine. This fugly Java version http://lpaste.net/99362 accomplishes the same task in less than a second. – Is this all because of thunk overhead or why is Haskell so slow heree?
00:08:20 <jle`> so it's kind of semantically the same as ($)...except it applies it inside a functor
00:08:34 <zett_zelett> Or is it the use of direct computation and arrays in the Java version?
00:09:22 <amalloy> jle`: yeah, i know that in theory, but when i was attempting to restructure someone else's do-notation i just...put the first part on the left and the second part on the right
00:09:34 <jle`> amalloy: fair enough :) my apologies
00:09:42 <amalloy> no, thanks for reminding me!
00:10:46 <jle`> there is an internal war inside every haskell programmer
00:10:52 <jle`> between reading things left to right
00:10:58 <jle`> and reading things right to left
00:11:19 <jle`> do notation mirrors usage of (>>=)
00:11:25 <jle`> which is left to right
00:11:46 <erisco> <<=
00:11:54 <jle`> but typical usage of pure functions (and functions that aren't (>>=), (>>), etc.) is right to left
00:11:55 <erisco> :t (=<<)
00:11:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:11:57 <tac> @type (<==<)
00:11:57 <erisco> yeah that one
00:11:57 <lambdabot>     Not in scope: `<==<'
00:11:58 <lambdabot>     Perhaps you meant `<=<' (imported from Control.Monad.Writer)
00:12:03 <tac> @type (<=<)
00:12:04 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
00:12:10 <jle`> so there is this internal struggle we must face every day
00:13:04 <jle`> zett_zelett: for one, that isn't really the best place to use a list comprehension
00:13:07 <jle`> :)
00:14:37 <jle`> not that that changes your performance issues
00:21:07 <enthropy> zett_zelett: what kind of hardware do you have? I get an answer in 11s
00:21:19 <enthropy> also, you're compiling with -O2?
00:21:53 <zett_zelett> No, I’m not.
00:21:56 <zett_zelett> Should I?
00:22:17 <enthropy> the other thing, is you should have the loops go in the same order to make a more fair comparison
00:22:44 <zett_zelett> Yeah.
00:23:13 <zett_zelett> I actually have, it’s an old version.
00:29:17 <zett_zelett> enthropy: model name	: Intel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz
00:30:16 <enthropy> ok I have something slower (Intel(R) Core(TM)2 Duo CPU     T7100  @ 1.80GHz)
00:30:46 <enthropy> so you're probably within 10x?
00:31:28 <amalloy> zett_zelett: one thing i notice is that the java version tests for duplicates first, while the haskell version checks if the sums add up first
00:31:36 <ocharles> edwardk: what may be ocharles? :)
00:31:39 <ocharles> "[05:13:46] <edwardk:#haskell> it may be ocharles"
00:31:53 <amalloy> insofar as i'm understanding the haskell version, anyway
00:32:21 <enthropy> amalloy: java evaluates the right side of && before the left side? Or are we looking at different versions?
00:32:29 <zett_zelett> That’s a good point.
00:32:58 <amalloy> no, i think you're right, enthropy
00:33:31 <jle`> is there an official "chunksOf" list splitter in base?
00:35:07 <enthropy> the split package is in the platform
00:35:08 <ocharles> edwardk: oh, yes - @HaskellLens is me
00:53:30 <dv-> i need to do some java. is there a java for haskell programmers guide?
00:54:04 <peddie> dv-: "cry"
00:55:33 <dv-> i've made my peace with it. i just don't want a book that explains for loops on page 200
00:56:21 <peddie> sorry, I don't have anything helpful to offer, just snarky comments
01:02:03 <notdan> haasn: argh I uploaded my draf about representable functors http://covariant.me/notes/rep-functors.html in case you are still interested
01:02:11 <haasn> nice, thanks
01:02:21 <notdan> it's rather dry though :( I am sorry, I am terrible at writing
01:04:00 <koala_man> I have a hundred separate, independent functions that each examine a value and output 0 or more results in no particular order. is there a better representation than T -> Writer [Result] (), i.e. that doesn't impose an ordering?
01:05:31 <zipper> When I am using ghci in tmux and fail to type anything into it for a while it seems to freeze or something. Has anyone else experienced this?
01:08:12 <amalloy> koala_man: why Writer [Result] () rather than just [Result], and use concatMap?
01:11:00 <amalloy> like, concatMap ($ x) (fs :: [T -> [Result]])
01:12:24 <koala_man> amalloy: mainly to allow the functions to build up their result lists conditionally via when/tell
01:16:01 <koala_man> what are good ways of doing that with just [Result]? I imagine I'd be doing a bunch of (if foo then ["foo"] else []) ++ ["bar"]
01:18:55 <amalloy> koala_man: listWhen test x = if test then x else [], concat [(listWhen foo ["foo"]), (listWhen bar ["baz", "sam"]), ...]?
01:21:33 <mm_freak_> koala_man: i think the Writer approach is fine
01:21:55 <koala_man> I was thinking especially wrt parallelization
01:23:12 <mm_freak_> you can parallelize writers very well, but you have to do the plumbing yourself
01:23:49 <mm_freak_> you could probably write a parWriterMapM_ that uses the associativity of the underlying monoid to parallelize
01:25:02 <mm_freak_> parWriterMapM_ :: Strategy l -> [Writer l a] -> Writer l ()
01:25:05 <mm_freak_> something along those lines
01:26:49 <mm_freak_> (the name isn't really appropriate)
01:27:06 <mm_freak_> parWrite :: Strategy l -> [Writer l a] -> Writer l ()
01:29:51 <zipper> Offtopic but this is a good place to ask.
01:29:53 <zipper> Do medium ground v finely ground coffee have a difference in taste and quality?
01:30:22 <koala_man> worst case I guess I could just map (snd . runWriter) in parallel
01:30:44 <koala_man> mm_freak_: thanks!
01:32:36 <mm_freak_> koala_man: snd . runWriter . sequence_
01:32:41 <mm_freak_> and i think there is…
01:32:43 <mm_freak_> :t evalWriter
01:32:44 <lambdabot>     Not in scope: `evalWriter'
01:32:44 <lambdabot>     Perhaps you meant one of these:
01:32:44 <lambdabot>       `execWriter' (imported from Control.Monad.Writer),
01:32:47 <mm_freak_> :t execWriter
01:32:48 <lambdabot> Writer w a -> w
01:32:55 <mm_freak_> koala_man: so:
01:33:02 <mm_freak_> :t execWriter . sequence_
01:33:03 <lambdabot> Monoid c => [WriterT c Identity a] -> c
01:33:17 <koala_man> oh, neat
01:33:23 <mm_freak_> that's (as "sequence" suggests) the sequential version =)
01:34:15 <mm_freak_> for the parallel version i've made best experiences with a depth-limited divide-and-conquer
01:34:41 <mm_freak_> divide 100 to [50,50], then to [[25, 25], [25, 25]]
01:34:54 <mm_freak_> do that for a few levels, then apply the sequential version
01:36:34 <mm_freak_> if the order doesn't matter, use a transposed split instead of a splitAt
01:36:52 <mm_freak_> i.e. turn "abcde" into ["ace", "bd"] instead of ["abc", "de"]
01:37:21 <mm_freak_> (or simply use a Vector instead of a list)
01:38:06 <koala_man> good tips, thanks
01:40:45 <mm_freak_> koala_man: and a final tip:  read The Book =)
01:40:53 <mm_freak_> http://chimera.labs.oreilly.com/books/1230000000929
01:41:59 <randomclown> is there a better way to write nested if statements in monadic code?
01:42:11 <koala_man> I have, and I even tried before, but I didn't get a speedup. now I'm trying again
01:42:11 <randomclown> I always endup nesting several layers deep and it's ugly as hell
01:42:23 <Sornaensis> Hello
01:42:53 <Sornaensis> Is there a simple way to create geometric sequences in haskell
01:42:55 <Sornaensis> ?
01:43:15 <c_wraith> > iterate (*2) 1
01:43:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
01:43:23 <c_wraith> that's a geometric sequence, right?
01:43:25 <mm_freak_> koala_man: the guidelines above should give you almost maximum parallelization
01:43:50 <mm_freak_> with my four cores i usually get around 390% CPU usage and about a 3.5x speedup
01:43:58 <haasn> :t iterate . (*) -- all geometric sequences have this form don't they?
01:43:59 <lambdabot> Num a => a -> a -> [a]
01:44:00 <Sornaensis> ah
01:44:21 <Sornaensis> cool
01:45:33 <c_wraith> randomclown: use fewer ifs?  if is very rare in haskell code I write.
01:45:41 <AshyIsMe> so memoization
01:46:03 <AshyIsMe> is there a  drop in way to set a function to memoize it's results in haskell?
01:46:24 <c_wraith> there are libraries that allow you to do nearly that.
01:46:54 <mm_freak_> AshyIsMe: use your browser search here: http://hackage.haskell.org/packages/
01:46:57 <mm_freak_> just search for "memo"
01:47:16 <randomclown> c_wraith: lpaste.net/99363
01:47:49 <randomclown> very short snippet, not sure how to improve
01:48:01 <mm_freak_> you will get many results…  you can (mentally) sort your search results by upload date
01:48:24 <c_wraith> randomclown: Are you ok with using a GHC 7.6 specific extension?  Or would you prefer something portable?
01:48:45 <randomclown> c_wraith: show me my options :)
01:48:51 <AshyIsMe> yeah i should have searched sorry, guess i was asking if anyone has a favourite or any experience with them
01:51:35 <c_wraith> randomclown: I'd probably just go with http://lpaste.net/99363 , it's the portable version
01:51:50 <c_wraith> (the annotation)
01:51:51 <haasn> c_wraith: wikipedia says [a, ar, ar², ar³]
01:52:00 <haasn> > iterate (*r) a :: [Expr] -- :)
01:52:01 <lambdabot>  [a,a * r,a * r * r,a * r * r * r,a * r * r * r * r,a * r * r * r * r * r,a *...
01:53:10 <randomclown> c_wraith: I'm guessing the other version is MultiwayIf?
01:53:14 <c_wraith> yep
01:53:36 <c_wraith> actually, it could be formatted better
01:54:28 <c_wraith> http://lpaste.net/99365 should be valid layout, and it's clearer
01:56:40 <randomclown> hmm ok, thanks
02:00:36 <skypers> is there a way to import a hiding?
02:00:48 <skypers> I define in a Log module the log function, and I hide log from Prelude
02:00:58 <skypers> I’d like to automatically hide it when importing my Log module
02:01:21 <skypers> I can also change my log function name, but hm, I like log
02:02:56 * hackagebot classy-prelude 0.6.0.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.6.0.1 (MichaelSnoyman)
02:03:21 <haasn> notdan: Why use alpha and beta when you can use α and β? ;)
02:04:45 <haasn> notdan: you have a typo: “isomoprhic”
02:05:28 <notdan> yeah, I guess I'll use unicode next time I try to rite something :) thanks for the typo correction
02:07:56 * hackagebot text-latin1 0.3 - Latin-1 (including ASCII) utility functions  http://hackage.haskell.org/package/text-latin1-0.3 (MikhailVorozhtsov)
02:07:58 * hackagebot text-printer 0.4 - Abstract interface for text builders/printers.  http://hackage.haskell.org/package/text-printer-0.4 (MikhailVorozhtsov)
02:08:00 * hackagebot data-textual 0.2 - Human-friendly textual representations.  http://hackage.haskell.org/package/data-textual-0.2 (MikhailVorozhtsov)
02:08:02 * hackagebot data-timeout 0.3 - 64-bit timeouts of nanosecond precision  http://hackage.haskell.org/package/data-timeout-0.3 (MikhailVorozhtsov)
02:08:04 * hackagebot network-ip 0.2.1 - Internet Protocol data structures  http://hackage.haskell.org/package/network-ip-0.2.1 (MikhailVorozhtsov)
02:16:15 <haasn> notdan: and a stray “Bla” in the Case 1 of the proof why Maybe isn't representable :)
02:18:09 <skypers> is there a way to alias MonadIO and adding a constraint?
02:18:09 <skypers> like
02:18:31 <skypers> type IOState m = (MonadIO m, StateT m) => m
02:18:31 <skypers> ?
02:19:21 <opqdonut> type synonyms can't have constraints unfortunately
02:19:52 <skypers> arf
02:20:00 <Feuerbach> skypers: with constraintkinds you can do type IOState s m = (MonadIO m, MonadState s m)
02:20:03 <skypers> so I’ll have to embed the (MonadIO m, StateT m) everywhere?
02:20:09 <opqdonut> you could use a newtype and generalized deriving
02:20:25 <opqdonut> (generalized deriving for the monad instance)
02:20:30 <Feuerbach> and then write foo :: IOState s m => ...
02:20:56 <skypers> hm
02:21:20 <simpson> skypers: Do you *actually* want to generalize this, or did you have a specific monad in mind?
02:21:26 <simpson> Also does your editor have copy and paste? :3
02:23:05 <monoidal> opqdonut: they can
02:23:10 <skypers> I don’t want to generalize it
02:23:26 <skypers> I have a monad I’d just like to use everywhere
02:23:35 <skypers> because it defines normalized logging and errors handling
02:23:41 <simpson> skypers: So what is that monad, specifically? Why not just type that, instead?
02:23:52 <skypers> it’s a monad transformer
02:23:53 <Feuerbach> skypers: then type M = StateT MyState IO
02:23:59 <simpson> foo :: SkypersAwesomeMonad
02:24:04 <simpson> ^^^
02:24:29 <skypers> it’s something like StateT LogQueue (EitherT SkyError m) a
02:24:38 <skypers> in some cases
02:24:43 <skypers> I want m to be MonadIO
02:24:54 <skypers> now, I just write my functions like
02:24:55 <haasn> notdan: I'm not sure if Maybe a being isomorphic to Either a () is relevant, but MAybe being isomorphic to Either () certainly is
02:24:56 <Feuerbach> skypers: why not make it IO?
02:24:57 <simpson> What are those cases?
02:24:59 <simpson> Why not IO?
02:25:06 <skypers> foo :: (MonadIO) => SkyT m a
02:25:17 <Feuerbach> IO belongs to MonadIO
02:25:32 <haasn> notdan: I'm also not sure what “strnnnnnnneams” are supposed to be ;)
02:25:33 <skypers> because I prefer working with MonadIO instead of IO, since it’s more permissive
02:25:57 <skypers> if someday I have another monad that wraps IO
02:26:04 <skypers> and want to log / handle errors
02:26:11 <skypers> I’ll have my SkyT monad transformer
02:26:22 <haasn> notdan: any way, cool and useful!
02:26:48 <skypers> at first I thought of existential quantification
02:26:52 <skypers> I thought it was the case for that
02:26:53 <skypers> like
02:27:15 <Feuerbach> I'd advise against that premature generalization, although it's not impossible
02:27:16 <skypers> type SkyIO m a = forall m . (MonadIO m) => SkyT m a
02:27:29 <Feuerbach> it's not existential. it's universal
02:27:33 <Feuerbach> and yes, that can work
02:27:38 <Feuerbach> just wrap it in a newtype
02:27:44 <Feuerbach> and define instances for that
02:27:50 <monoidal> it should be either
02:27:57 <monoidal> type SkyIO a = forall m . (MonadIO m) => SkyT m a
02:27:59 <monoidal> or
02:28:05 <monoidal> type SkyIO m a = (MonadIO m) => SkyT m a
02:28:51 <skypers> monoidal: RankNTypes?
02:28:55 <Feuerbach> newtype SkyIO a = SkyIO (forall m . MonadIO m => StateT LogQueue (EitherT SkyError m) a)
02:29:02 <monoidal> skypers: you're shadowing 'm'
02:29:45 <Saizan> frankly I'd just stick to putting the MonadIO m constraint on your functions
02:29:57 <skypers> Saizan: ahah
02:30:02 <skypers> I have something like 100+ functions
02:30:07 <skypers> I say how about no.
02:30:09 <skypers> :)
02:30:21 <monoidal> if it's just MonadIO m, seems sensible.
02:30:22 <skypers> the solution of monoidal works
02:30:31 <skypers> sensible?
02:30:33 <skypers> what do you mean?
02:30:37 <Saizan> i'm sure there's a lot of repetition in the type signatures anyway :)
02:31:03 <monoidal> essentially forall m. MonadIO m => ... is the same as IO
02:31:15 <zipper> nitrix: Kikoo
02:31:22 <skypers> monoidal: ?
02:31:34 <skypers> EitherT s IO a is in MonadIO
02:31:37 <skypers> it’s not IO at all
02:31:42 <Saizan> but yeah, the type synonym will work as long as it's in a positive position
02:31:55 <skypers> what do you mean positive position?
02:31:56 <monoidal> ^^ the point is about negative position
02:32:39 <monoidal> the only way to construct a value of type forall m. MonadIO m => ... is using liftIO
02:32:44 <Saizan> skypers: i mean on the right aside of an even number of arrows
02:33:02 <monoidal> left side
02:33:14 <skypers> monoidal: sure
02:33:41 <Saizan> the positive position is on the right side, i.e. in a -> b the b is in a positive position
02:34:03 <monoidal> if your function takes a value of type SkyIO a, you will have to put IO value there using liftIO. no EitherT s IO a or anything different
02:34:47 <skypers> yes
02:34:48 <Feuerbach> Saizan: monoidal means left side of an even number of arrows
02:35:07 <Feuerbach> (right side = 0)
02:35:15 <skypers> with hindsight, IO should be ok
02:35:25 <skypers> all functions I call in my monad are actually plain IO
02:35:37 <skypers> (it’s not really SkyIO, but SkyGL, and gl functions are just IO)
02:35:42 <skypers> so
02:35:51 <skypers> type SkyGL = SkyT IO
02:35:55 <Saizan> Feuerbach: mh, maybe that works
02:35:55 <skypers> it might just be ok
03:21:59 <Fuco> so >>= is called bind, what is >> called?
03:22:28 <ilmig> Fuco: sometimes it's called "then"
03:22:45 <Fuco> okey, that would work
03:25:39 <Fuco> I'm writing a silly monad thing for emacs lisp (:D) so I need some names hehe
03:26:01 <ion> How about >>= and >>? :-P
03:26:22 <Fuco> yea I'll add those as aliases, but some lisp people like foo-bar-baz names instead
03:27:13 <eflister> is there a named algebraic structure for types a that have an f :: a -> b -> a that always eventually leads to some fixed point a' ?
03:28:23 <randomclown> is there a way to timeout a takeMVar?
03:28:53 <randomclown> I suppose the easiest way would be just to put a value in after a delay
03:29:03 <Saizan> iirc there's a timeout wrapper somewhere
03:29:13 <Saizan> ?hogle timeout
03:29:13 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
03:29:14 <lambdabot> package timeout-control
03:29:14 <lambdabot> package timeout-with-results
03:29:33 <Feuerbach> takeMVar is interruptible (as any other blocking call), so you can use System.Timeout or similar with it
03:30:18 <eflister> hey Saizan, you've been a big help to me in the past, does my question above make sense?
03:31:36 <Saizan> eflister: i guess so, but i don't know of such a thing
03:32:46 <eflister> Saizan: it seems like a common pattern -- "do the same kind of thing repeatedly until there is no more to do" -- am i wrong to be surprised it isn't as famous as MonadPlus?  it's almost the dual if i'm thinking about it right...
03:33:02 <Saizan> eflister: something like f is usually called "b acting on a" (or the other way around?)
03:33:32 <Feuerbach> eflister: not sure I understand. What's the role of b there?
03:33:43 <Saizan> eflister: what are some examples you're thinking of?
03:34:31 <eflister> Saizan: it started as showing 'hangman' to a friend to demo why haskell is cool.  keep acting on a game state with chars until the state == Solved
03:35:02 <eflister> Saizan: also, work through items in a collection til it's empty, etc.
03:35:58 <eflister> Feuerbach: so b is IO Char in the hangman example
03:36:52 <Saizan> eflister: http://hackage.haskell.org/package/reducers-3.10.1.1/docs/Data-Semigroup-Reducer.html <- seems related
03:37:53 <Feuerbach> so it looks like just a mapping from `b` to a subset of `a -> a` where each result has a fixed point
03:38:19 <Feuerbach> (note that if we're talking about Haskell then any `a -> a` has a fixed point, although not necessarily total one)
03:38:48 <Kaidelong> . o O (why use reducer instead of just using a newtype?)
03:42:39 <Kaidelong> oh I see, I guess the idea is that Reducer instances are used for doing distributed/parallel stuff, but why not just require Semigroup and feed newtypes
03:42:53 <Kaidelong> if you actually need it
03:45:08 <eflister> Saizan: hm, i am not fluent enough in edwardk-isms to grok reducer
03:46:29 <eflister> Feuerbach: i'm probably abusing terms, but i am thinking of it like a' is the fixed point in a for all b's under f
03:47:28 <Wizek> Morning!
03:48:12 <eflister> Feuerbach: and it seems like it crops up at least as often as MonadPlus...
03:49:43 <Wizek> > (read ::  String -> Integral a) "1112"
03:49:44 <lambdabot>  Predicate `GHC.Real.Integral a' used as a type
04:01:15 <eflister> mzero disappears when combined with anything else; mFixedPoint would make anything combined with it disappear
04:05:20 <eflister> what's the dual of an identity?  a fixed point?
04:21:27 <haasn> the dual of an identity is an identity
04:21:46 <haasn> id ∘ id = id
04:22:05 <haasn> well actually that's the inverse. But in this case they're the same
04:22:36 <FreeFull> identity is identity is identity
04:23:55 <haasn> http://ncatlab.org/nlab/show/opposite+category says C^op has the same identity-assigning map as C
04:24:43 <mcjohnalds> Does anyone know of any full-on haskell opengl tutorials? (preferably ones that don't use deprecated functionality)
04:25:05 <mcjohnalds> I wanted to learn opengl, but don't feel like learning c/c++
04:26:26 <JuanDaugherty> why not?
04:26:43 <JuanDaugherty> it's the fundamental combined assembly and algol of this time
04:26:57 <JuanDaugherty> the most "engineering" lang
04:27:20 <quchen> @quote kmc Fortran
04:27:21 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
04:27:21 <mcjohnalds> I sort of know c++, it's just so boring
04:27:57 <JuanDaugherty> all parochial lang cultures are variously insufferable
04:28:23 <JuanDaugherty> the c/c++ one of today is an especially nasty case unfortunately
04:28:46 <mcjohnalds> Oh well, it's something I have to learn eventually anyway
04:29:02 <JuanDaugherty> money is usually a major souring factor in any lang's culture and it plays very heavily there
04:29:29 <mcjohnalds> Why is haskell popular anyway? It's so fun to write code in!
04:29:33 <mcjohnalds> isn't*
04:29:45 <quchen> Giant barrier of entry.
04:29:54 <mcjohnalds> true
04:29:59 <JuanDaugherty> yeah, "fun" or related concepts
04:30:09 <quchen> Well, "giant" compared to learning Ruby after knowing Python.
04:30:26 <quchen> Which is arguably not even a new language. It's like learning a new dialect of your mother tongue.
04:30:45 <quchen> Some words may be funny, some sentences are structured differently, but the way of thinking is identical.
04:30:48 <JuanDaugherty> i guess there are two categories of why the fun category and the serious category
04:31:08 <JuanDaugherty> in the serious category it's the conceit of math as a model of computation
04:31:16 <FireFly> quchen: I wonder if those would also write "Java/JavaScript"
04:31:29 <quchen> FireFly: Good one, haven't even thought of that :-)
04:32:07 <JuanDaugherty> there also should maybe be a category that includes what you said barrier to entry and various emanations from the academic and corporate snake pits
04:32:18 <JuanDaugherty> *a third category
04:33:28 <JuanDaugherty> i.e, neither fun nor serious, but typical human reasons why
04:33:36 <quchen> It took me some time to realize Haskell is not only pretty to write code in, but actually useful for most things.
04:33:59 <quchen> Same thing for the way of thinking: it's not as different as I had thought initially at all.
04:34:06 <quchen> Here I am, back at writing loops ;-)
04:34:22 <JuanDaugherty> computing is computing
04:34:31 <JuanDaugherty> at some level the lang is irrelevant
04:34:47 <quchen> Not really, no. Haskell and C have vastly different computational models.
04:35:18 <JuanDaugherty> haskell resolves to C/C++ in most implementations FWIU
04:35:42 <quchen> 1. There is no C/C++.
04:35:49 <JuanDaugherty> a custom llvm backend recently also dunno how many people use it
04:35:50 <quchen> 2. Haskell has C-- as an intermediate form.
04:35:51 <quchen> (GHC)
04:36:15 <quchen> You can break both of them down to ASM, but that doesn't make them similar. Pigs and tomatos consist of carbon-based organics. Pigs and tomatos are not the same on any level relevant to using them.
04:36:21 <JuanDaugherty> are you chinese?
04:36:27 <quchen> Close, but no.
04:36:57 <JuanDaugherty> just wondering how much haskell there might be there
04:37:21 <quchen> If you meant Singapore, there are a couple of companies making heavy use of it.
04:38:02 <JuanDaugherty> pigs and tomatoes have a great many similiarities and are very close regarded against the whole range of phenomena/objects of experience
04:38:03 <quchen> Also, "being Chinese" means you can be separated by language and a whole continent from other Chinese Haskell users. :-þ
04:38:23 <JuanDaugherty> right I meant mainland
04:38:34 <JuanDaugherty> PRC
04:38:35 <quchen> So did I.
04:39:41 <haasn> GHC is the minority in not going via C, isn't it?
04:39:51 <haasn> But I don't really know the other implementations too well
04:39:57 <JuanDaugherty> general rules for dealing with edible objects and other related thinking are relevant to both pigs and tomatoes
04:40:18 <haasn> JuanDaugherty: in that C, C++, Haskell and C-- are all programming languages? :)
04:40:40 <JuanDaugherty> right and I suppose here the c langs are the pig
04:41:51 <JuanDaugherty> I'm over 60 though, when I started regular commercial programming in assembler was quite common
04:42:41 <quchen> haasn: The only other Haskell implementation I know is Hugs, and that was written in C. No idea about the other compilers.
04:43:16 <Fuuzetsu> UHC
04:43:38 <JuanDaugherty> although it was on its' way out
04:43:39 <quchen>  ?HC all exist I feel
04:44:05 <Fuuzetsu> http://mirror.seize.it/report.html shootout
04:44:39 <quchen> "Nothing compiles on anything than GHC."
04:44:45 <quchen> But that's for 6.12, which was like 2010?
04:45:00 <JuanDaugherty> today c/c++ fills that niche, and it seems infinitely richer to me than the machine langs of yore
04:45:02 <AshyIsMe> JuanDaugherty: are you still coding or have you retired?
04:45:54 * JuanDaugherty yes, in fact I'm going back to some c++ ietf protocol work right now so I don't hear the topic klaxon
04:46:28 * JuanDaugherty (just turned 60 about a month ago)
04:55:11 <Wizek> does http-conduit-browser support POST request?
04:55:26 <Wizek> (also, https)
05:02:03 <exicer> When should I use lazy vs strict bytestrings etc ?
05:02:17 <exicer> Should I generally use one or the other, except in specific casees ?
05:06:44 <AshyIsMe> man building ghc from source takes a while
05:09:39 <quchen> ~ 1 hour
05:09:43 <int-e> exicer: lazy bytestrings are good for processing large inputs and outputs incrementally. if you know that your strings are short, or that you will keep them around fully evaluated, then strict bytestrings are preferable. in any case, lazy bytestrings should perform quite well even in those cases, so they are a good default.
05:10:34 <quchen> The overhead of unnecessarily using lazy BS should be pretty small anyway, no?
05:10:43 <int-e> yes.
05:10:52 <quchen> It's basically evaluating BS:[] instead of BS
05:13:14 <int-e> quchen: I'd feel slightly bad about using lazy bytestrings as keys in a map. That's about the only case where I would avoid them without thinking further.
05:14:43 <fugyk> How should I start learning haskell
05:14:54 <fugyk> I know some basics
05:15:18 <fugyk> and I want to dive somewhat deeper in haskell
05:15:54 <quchen> fugyk: LYAH, learnyouahaskell.com
05:16:14 <quchen> int-e: Why would that be bad?
05:18:08 <mm_freak> quchen: since maps are spine-strict you're really just throwing away memory
05:18:16 <mm_freak> and probably some speed as well
05:18:57 <mm_freak> although you may not have to compare the whole strings, but still i'm pretty sure that the result is slower
05:19:16 <int-e> quchen: it's not really bad. it's a slight waste of memory, and some extra pattern matches. But using strict bytestrings instead of lazy ones as keys will usually help slightly and almost never hurt. The second part is important.
05:19:16 <quchen> What do you mean with memory? The BS cons cells?
05:19:25 <mm_freak> quchen: yes
05:19:37 <quchen> Lazy BS as keys can also save memory because they don't have to be fully evaluated to be compared, on the other hand
05:19:58 <quchen> i.e. the strict spine does not require all the keys to be NF
05:20:31 <hpc> the keys do have to be evaluated enough that you can `compare` them
05:20:42 <mm_freak> quchen: if your keys are very long, this may make a difference, but "abcd" : THUNK requires more memory than "abcdefgh"
05:21:11 <int-e> I'm making the assumption that things that are stored in the map will actually be looked up.
05:21:49 <mm_freak> quchen: also over time your map will have evaluated everything, unless you don't look up most of it
05:22:02 <mm_freak> every looked up key will be fully evaluated
05:22:24 <quchen> Hmm, right.
05:23:15 <int-e> And in any case ... the simple answer is that lazy bytestrings are a good default, and that you need to understand how your strings are used before deciding to use strict ones, in order to gain a small bit of performance.
05:23:35 <Hulk{-_-}> Hulk <3 haskell but Haskell no <3 Hulk. HULK SMASH!!! HULK SMASH!!
05:23:51 <mm_freak> int-e: i found that in most of the use cases for ByteString, the lazy variant is simply wrong to use
05:24:12 <hpc> PLT hulk, is that you?
05:24:41 <quchen> mm_freak: Funny, I had the opposite experience. But I use them mostly for networking right now. (Maybe I'm wrong though)
05:25:04 <mm_freak> quchen: with your favorite streaming abstraction you would use the strict variant
05:25:25 <mm_freak> this is true for every streaming abstraction i know, except for lazy I/O
05:25:26 <int-e> mm_freak: My answer would be different if the performance difference were bigger.
05:25:55 <mm_freak> int-e: if you're dealing with a lot of small strings with a lot of sharing, the difference is huge
05:26:29 <mm_freak> note that evaluation of a lazy ByteString does not make it strict…  it remains in the chunked representation, so sharing is complicated
05:26:52 <mm_freak> with a lot of indirection that is
05:27:59 <int-e> Well, typically you'll only be referring to a single chunk. So the overhead is a single cons cell.
05:28:12 <Hulk{-_-}> hpc: No Hulk{-_-} is inspired by PLT hulk but for Haskell.
05:28:31 <hpc> security hulk is best hulk ;)
05:29:29 <Hulk{-_-}> hpc: Hulk no hear of Security Hulk! Hulk need security friends
05:29:30 <mm_freak> int-e: not if you use take*, drop*, break*, span*, split*, splicing, …
05:29:52 <mm_freak> int-e: i'm using wildcards, because the enumeration of all functions exceeds the allowed line length of IRC =)
05:30:26 <mm_freak> Hulk{-_-}: many security!
05:31:24 <PL_kolek> Hello! I'm trying to pick up FRP. I'm learning, but as my only source is this post: http://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html, and it's using oder version of Netwire, I don't know how to implement collisions without accumT.
05:31:53 <mm_freak> PL_kolek: check out ocharles' asteroids post
05:32:22 <mm_freak> PL_kolek: http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
05:33:06 <mm_freak> huh?
05:33:16 <mm_freak> wait, it's using netwire 4
05:34:18 <mm_freak> but ocharles has many netwire-based projects, so check this out:  https://github.com/ocharles?tab=repositories
05:34:36 <int-e> mm_freak: checking ... 'drop' will do the right thing: drop chunks until it reaches a chunk that has to be split; then use 'drop' for strict bytestrings. And then it creates a new cons cell to prepend that chunk to the remainder of the lazy BS.
05:35:53 <int-e> mm_freak: take* and span*, of course, will produce longer lists of chunks, if your strings are big.
05:36:03 <mm_freak> int-e: the trouble is when you have ["abc", "def"] and you drop 2
05:36:18 <mm_freak> then basically every string operation will have to pass the chunk barrier
05:36:53 <mm_freak> and the resulting string will take a multiple of the memory it would take in the strict case
05:37:06 <mm_freak> even if the second chunk isn't evaluated
05:37:14 <PL_kolek> mm_freak, Thanks, I've seen both this post and repository, but I only glanced over it, and headed to that introductory post to grasp the basics. It seems, I'll have to dig deeper for those wall collisions ;).
05:37:35 <mm_freak> PL_kolek: have you read the netwire introduction?
05:37:52 <mm_freak> PL_kolek: http://hub.darcs.net/ertes/netwire/browse/README.md
05:39:04 <mm_freak> it explains netwire 5
05:39:57 <PL_kolek> mm_freak, Yes, I have, I'll have to reread it though. At first it didn't tell me anything, because it seemed for me to assume that I am familiar with FRP.
05:40:33 <PL_kolek> I asked here, because maybe somebody could point me to the right function or something I haven't found yet
05:40:50 <Kaidelong> the theoretical advantage of FRP is very tight control of memory use, right? Has any haskell FRP library actually achieved that?
05:43:12 <mgsloan> From what I've seen of the development history of some FRP libraries, I'd say that controlling memory use is the main thing that makes FRP hard
05:44:01 <Kaidelong> for the programmer or for the implementers?
05:44:17 <mgsloan> I think the main theoretical advantage of FRP is being more declarative about handling callbacks, in such a way that things like the order of registration of callbacks isn't significant
05:44:59 <Kaidelong> mm, I guess modern FRP libraries allow rewiring at runtime too
05:45:26 <mgsloan> Either the programmer needs to understand the pitfalls of the particular FRP they're using, or the implementor needs to omit features that lead to memory leaks
05:45:26 <Kaidelong> which probably nukes the early predictions of being able to easily determine how much memory is used just by looking at the source code
05:45:36 <ocharles> FRP you say.
05:45:44 <ocharles> Kaidelong: not just modern FRP libraries, that's almost a requirement of FRP. FRP = Behaviours + Events, and the behaviours have to change in response to events
05:45:49 <ocharles> so that is dynamic rewiring
05:47:20 <Kaidelong> ocharles: didn't grapefruit actually not go any further than ArrowChoice?
05:47:33 <Kaidelong> so the amount of alternative paths end up reflected in the types
05:48:09 <ocharles> Kaidelong: I don't think you need much more than Arrow to get the dynamism, but I could be wrong. Essentially the dynamic parts come from the 'switch' operators, which take wire's and switch to new wires
05:49:03 <mm_freak> PL_kolek: yes, netwire does in general assume familiarity with FRP
05:49:18 <mm_freak> Kaidelong: FRP has nothing to do with memory control
05:49:30 <mm_freak> it has to do with complexity of event management
05:49:41 <PL_kolek> mm_freak, And I'm trying to learn both FRP and Netwire, huh.
05:49:59 <Kaidelong> mm_freak: but reactive values gives a declarative way to deal with destruction
05:50:57 <ocharles> PL_kolek: I find the Yampa papers translate well to Netwire
05:50:59 <Kaidelong> all the data dependencies are known and the changes can propogate so that you can get rid of old values
05:51:35 <mm_freak> PL_kolek: well, FRP can be explained with an exercise
05:51:58 <mm_freak> PL_kolek: pick a small application you would like to write, for example a very simple particle simulation
05:52:08 <mm_freak> then express it in terms of the following two primitive types:
05:52:12 <mm_freak> type Behavior a = Time -> a
05:52:17 <mm_freak> type Event a = [(Time, a)]
05:52:33 <mm_freak> where you can define Time to be Double or any other approximation of the real numbers
05:54:33 <nadirs> Hello! Does anyone have the time and will to help me figure out the approximate order of complexity for a function I wrote?
05:55:16 <nadirs> It's supposed to be a sieve of Sundaram
05:56:52 <nadirs> http://lpaste.net/99368
05:58:03 <mm_freak> Kaidelong: traditional FRP implementations suffered from a problem known as 'time leaks'
05:58:39 <mm_freak> those are memory leaks caused by accidentally referring to out of date values
05:58:58 <hpc> nadirs: it looks n**2 to me
05:59:04 <hpc> also your function names are doublePlusGood
05:59:36 <mm_freak> Kaidelong: in any case FRP has really nothing to do with memory…  AFRP helps you to avoid a certain class of memory leaks, but this is really just a nice side-effect of the implementation and not a feature of the abstraction
05:59:43 <hpc> er no, n**3
06:00:48 <hpc> you have the list [0 .. (n `div` 3)], and you fold over it with (union . thresholds n), which is n**2 because of (\\)
06:01:17 <nadirs> hpc: ok
06:01:37 <nadirs> hpc: I find it hard to see when a chain of higher-order functions are "collapsable"
06:02:00 <hpc> you can make exclude O(n), which will help
06:02:02 <nadirs> and when, instead, they imply a new "loop" over the passed list
06:02:07 <hpc> exclude n [] = []
06:02:15 <PL_kolek> Thank you for your help, I hope I'll get it now.
06:02:23 <hpc> exclude n (x:xs) = if x < n then x:(exclude n xs) else exclude n xs
06:02:52 <hpc> or rather, <= - still waking up ;)
06:03:23 <nadirs> hpc: you're still order of brilliance higher than me :D
06:03:30 <nadirs> *orders
06:03:43 <hpc> er, actually
06:03:50 <hpc> you already have a faster exclude
06:04:05 <hpc> exclude n = filter (<= n) -- as used on the line above
06:05:01 <hpc> i have no idea how that actually finds primes, though ;)
06:05:12 <hpc> too much math for my morning brain
06:05:49 <mm_freak> btw, to get anywhere near the expected O(n * log n), you need to use actual bit arrays with actual destructive update =)
06:06:08 <nadirs> «<hpc> exclude n = filter (<= n) -- as used on the line above» so I already embedded it in the `thresholds` function! I didn't realize it :P
06:08:27 <nadirs> hpc: so, to recap: the «[1..(n `div` 3)]» is the "first N", then the second N is «thresholds», and finally mapping doublePlusOne is the last N
06:10:23 <hpc> yes, except for "and finally ..."
06:11:40 <Kaidelong> netwire's README.md seems to reply on OverloadedStrings, but it doesn't say it does
06:12:09 <Kaidelong> unless String is somehow an instance of Category
06:12:23 <Kaidelong> which would be impossible due to not being the right kind of type
06:12:35 <Kaidelong> rely on*
06:16:44 <mm_freak> Kaidelong: "First of all it is handy that there are many convenience instances, including Num…"
06:16:54 <mm_freak> i could be more explicit about it, though
06:19:19 <nadirs> hpc: I also just realized «filter(<= n)» is not equivalent to «(\\) [1..n]». What "exclude" does is taking the first N nat numbers excluding the ones yielded by the "thresholds" filter
06:21:10 <Kaidelong> mm_freak: I think it's not a bad idea, even if right now you are writing the readme with experienced haskell developers in mind it might evolve over time into something more useful to people who may not know what OverloadedStrings does yet
06:21:41 <Kaidelong> mm_freak: also overloaded strings makes hacking harder because it means more explicit typing so I don't always use it when I'm doing quick and dirty
06:22:43 <Tekmo> o = fromString
06:22:50 <Tekmo> o"I'm an overloaded string"
06:23:23 <Kaidelong> that's pretty much what I end up doing, yes
06:31:35 <mm_freak> Kaidelong: to be honest i don't think you can use netwire without a certain amount of haskell experience
06:37:01 <Kaidelong> mm_freak: this may not still be true in the future if haskell idioms start to contaminate other languages and people are used to netwire-like libraries already
06:44:12 <mm_freak> Kaidelong: people aren't used to FRP even in haskell land yet =)
06:44:41 <mm_freak> much less to AFRP
06:45:45 <Kaidelong> AFRP?
06:49:08 <mm_freak> Kaidelong: animas, netwire and yampa implement Arrowized FRP
06:49:29 <mm_freak> the implication is that there is no Behavior type
06:49:38 <mm_freak> instead of 'Behavior Int' you get just 'Int'
06:50:35 <jmcarthur> that's not how i think of it. i don't understand that point of view
06:51:03 <jmcarthur> FRP behaviors: T->a    AFRP signal transformers: (T->a)->(T->b)
06:51:44 <jmcarthur> oh, i think maybe i see what you mean
06:52:09 <jmcarthur> in AFRP you can never hold a time dependent value
06:52:31 <jmcarthur> only either some snapshot of the value or a full blown signal transformer
06:53:06 <jmcarthur> well, signal transformers are sort of time dependent, in that they could be seen as:   T -> ((T -> a) -> b)
06:53:20 <jmcarthur> e.g.   Behavior (Behavior a -> b)
06:55:18 <carter> o/ jmcarthur
06:55:35 <jmcarthur> \o carter
06:56:13 <nadirs> what's up with those symbols?
06:56:45 <nadirs> "o/" versus "\o"
06:56:55 <jmcarthur> nadirs: o/ is somebody waving (o is the head, / is the arm)
06:57:08 <jmcarthur> nadirs: and i just reversed it as an acknowledgement
06:57:25 <nadirs> jmcarthur: I see, thanks for the explanation :)
06:57:34 <jmcarthur> nadirs: similarly, \o/ is a head and two arms in the air, usually to express celebration
06:57:50 <nadirs> jmcarthur: that's indeed more familiar
06:57:53 <carter> d0 might be a hat
06:58:06 <carter> though theres probably some clever unicode thing
06:58:45 <nadirs> carter: like haskell libraries, there's a unicode for anything I guess
06:59:02 <dennda> """ghc-cabal: At least the following dependencies are missing: terminfo -any""" -- If you get that on OS X, what do you do? I installed terminfo via cabal.
06:59:19 <carter> dennda: are you trying to build ghc?
06:59:24 <dennda> carter: Si
07:00:45 <carter> ./sync-all get ; ./sync-all pull ; ./sync-all checkout ghc-7.8 ; perl boot ; ./configure --with-gcc=YOURCCC ; cp mk/mk-osmething-sample  mk/mk-something
07:00:53 <carter>  edit the build type
07:00:59 <carter> then make -j2
07:01:30 <defanor_> what's the standard way to dig haskell sources? i'm hoogling them, guessing package names when need to find modules used by module i'm looking into, but it does not seem nice
07:01:54 <carter> dennda: did you forget one of those?
07:02:27 <carter> dennda: hayoo is great
07:02:31 <carter> defanor_: hayoo
07:02:42 <carter> boo http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:03:08 <carter> its down
07:03:21 <carter> defanor_: whats your use case?
07:05:43 <ToJans> Hello
07:05:55 <carter> dennda: that help?
07:06:04 <carter> defanor_: lets start with whats the problem you're trying to solve
07:06:04 <ToJans> I've been here a while ago; I'm a Haskell noob trying to solve the Zalora task
07:06:24 <ToJans> i.e. http://functionaljobs.com/jobs/8678-haskell-developer-at-zalora
07:06:28 <ToJans> with that context
07:06:37 <ToJans> I have a question
07:07:17 <ToJans> here's the code: https://gist.github.com/ToJans/8670469
07:07:39 <ToJans> but if I compile this
07:07:44 <ToJans> I get  Expected type: Data.Text.Lazy.Internal.Text    Actual type: String
07:07:49 <ToJans> Which makes sense
07:07:57 <ToJans> but how do I convert this?
07:08:05 <ToJans> Or is there a better way to do this?
07:08:10 <carter> ToJans: pack
07:08:30 <ToJans> aha
07:08:33 <ToJans> let's try
07:08:48 <ToJans> the err is in line 45BTW
07:08:56 <carter> i'm not reading your code :)
07:09:00 <ToJans> ah :p
07:09:17 <ToJans> so, if shoes is the data structure and I'm using scotty
07:09:18 <carter> telephone debugging requires less owkr
07:09:26 <ToJans> I could probably do this:
07:09:36 <carter> is this the dl the pages and do stuff?
07:09:40 <ToJans> text . pack . show shoes
07:09:46 <carter> use http-client
07:09:53 <ToJans> nope, it's a simple web)serv
07:09:59 <carter> ah
07:11:33 <defanor_> carter: sorry, got to go afk. i have recv function here, want to inspect it. getting a message on error, so want to figure out where it comes from; i'm using network-simple, it uses network-bytestring, and have not checked further yet
07:11:56 <carter> whats the error
07:12:00 <int-e> ToJans: is that a string literal? perhaps you need to enable the OverloadedStrings extension.
07:12:11 <carter> or use pack :)
07:12:12 <carter> but yeah
07:12:14 <ToJans> I have Overloadedstrings enabled
07:12:17 <defanor_> carter: "recv: resource vanished (Connection reset by peer)"
07:12:24 <ToJans> OverloadedStrings
07:12:37 <carter> defanor_: is your code online?
07:12:57 <int-e> ToJans: oh. yes, use (Text.)pack as carter said
07:13:03 <defanor_> carter: nope. but it happens when connection goes down; it's an expected error
07:13:13 <int-e> @type Data.Text.pack
07:13:13 <defanor_> i just want to see the code
07:13:13 <carter> oh ok
07:13:14 <lambdabot> String -> Data.Text.Internal.Text
07:13:18 <carter> defanor_: network
07:13:21 <carter> and network bytestring
07:13:29 <carter> defanor_: to the hackage!
07:13:35 <carter> @hackage network
07:13:36 <lambdabot> http://hackage.haskell.org/package/network
07:13:41 <carter> @hackage network-bytestring
07:13:41 <lambdabot> http://hackage.haskell.org/package/network-bytestring
07:13:52 <ToJans> ah, text.pack
07:13:57 <carter> defanor_: apparently you should use network not network-bytestring
07:13:58 <carter> :)
07:14:09 <carter> defanor_: http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-Socket-ByteString.html
07:14:28 <int-e> ToJans: text . pack . show shoes is a type error; text . pack . show $ shoes  would work.
07:15:01 <defanor_> carter: but i checked network.simple's sources and looks like it works with network bytestring. probably that works with network
07:15:11 <dennda> carter: I think I did those, but the issue persists
07:15:13 <defanor_> but anyway, i want to figure out how to dig it in general
07:15:25 <carter> defanor_: lets zoom out
07:15:27 <ToJans> So, I now use Data.Text.pack
07:15:29 <carter> whats the goal you ana do
07:15:35 <carter> defanor_: do a fresh clone
07:15:42 <mm_freak> jmcarthur: AFRP is not (T -> a) -> (T -> a)
07:15:44 <carter> * dennda
07:15:54 <dennda> carter: I might have copied that .mk file into the wrong place :)
07:15:57 <mm_freak> jmcarthur: because in AFRP implementation you will find that Event ≃ Maybe
07:16:00 <ToJans> And I'm closer
07:16:02 <ToJans> Expected type: String -> Data.Text.Lazy.Internal.Text   Actual type: String -> Data.Text.Internal.Text
07:16:15 <ToJans> So it's a lazy string
07:16:17 <carter> dennda: ddi you read the directions ont he ghc wiki?
07:16:48 <defanor_> carter: goal is to know how to check sources; at least in other languages it's needed from time to time. and fresh clone will work, yep, but how could i find, say, package name by it's module name on hackage?
07:16:58 <dennda> carter: Yeah, that's what I'm following. The sentence about the .mk file is a bit misleading though: GHC requires you to write a mk/build.mk file — we've integrated the correct configuration into build.mk.sample, so just copy/rename that to build.mk and uncomment the line:
07:17:24 <ToJans> I've updated the gist and highlighted the line : https://gist.github.com/ToJans/8670469#file-main-hs-L46
07:17:30 <carter> defanor_: well, you .cabal file will tell you exactly the packages that are used
07:17:45 <carter> and you look up the relevent one on hcakge
07:17:54 <defanor_> carter: oh, nice, thanks
07:17:55 <carter> dennda: which directions?
07:18:25 <ToJans> Does this matter: it's in an IO action
07:18:40 <mm_freak> jmcarthur: in fact over years of AFRP implementation experience i've learned one thing:  deciding what interface to expose to users is a very delicate task
07:19:49 * tojans follows the convention :D
07:21:09 <mm_freak> i'd go as far as claiming that netwire 5 is the only AFRP implementation on hackage that follows continuous time semantics
07:21:25 <carter> dennda: also #ghc is good for "how do build ghc" questions
07:21:42 <aristid> mm_freak: ah you're at 5 now
07:21:53 <tojans> !! it works
07:22:20 <dennda> carter: ah thanks
07:22:22 <tojans> I had to use Data.Text.Lazy.
07:22:27 <carter> dennda: i've not had breakfast yet
07:22:35 <piezoid> hi
07:22:37 <tojans> @type Data.Text.Lazy.pack
07:22:38 <lambdabot> String -> Data.Text.Lazy.Internal.Text
07:22:45 <mm_freak> aristid: since almost three months, yeah =)
07:22:58 <dennda> carter: go have some cereal? :)
07:22:58 <piezoid> I keep having this type error : http://lpaste.net/99370
07:23:39 <piezoid> can someone give me a hint, please ?
07:29:47 <aristid> piezoid: would this actually work if t is not a type constructor?
07:30:35 <piezoid> aristid: it has to be since the kind is * -> * -> *
07:31:04 <piezoid> or i am missing something ?
07:32:49 <aristid> piezoid: it has to be a type constructor? i don't see that
07:33:46 <piezoid> what t :: * -> * -> * can be otherwise ?
07:34:57 <aristid> piezoid: let's say something like type T f g = Int?
07:35:13 <aristid> hmm maybe i was misexpressing myself though
07:36:02 <piezoid> a type can't be partially applied
07:36:17 <hpc> data T a b c d = ...
07:36:23 <hpc> (T a) :: * -> * -> *
07:36:34 <hpc> er, (T a b)
07:36:57 <hpc> aristid: can't be a type alias because they can't be partially applied
07:37:41 <piezoid> i tried with newtype VoidPair a b = VoidPair ()
07:37:49 <piezoid> it doesn't work...
07:38:41 * hackagebot cabal-debian 4.0.6 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.0.6 (DavidFox)
07:40:55 <tojans> ok, another question
07:41:02 <tojans> where do I find basic functionality
07:41:10 <tojans> like f.e. base64
07:41:16 <tojans> if i look on hoogle
07:41:23 <tojans> I get refs to external packages
07:41:33 <tojans> but I'd assume some internal need to exist?
07:41:56 <hpc> nope
07:41:58 <hpc> http://hackage.haskell.org/package/base64-string-0.2/docs/src/Codec-Binary-Base64-String.html#encode
07:42:02 <hpc> base64 is pretty simple
07:42:13 <jmcarthur> mm_freak: Event a ~ Bag (T, a) ~ (T, a) -> N ~ T -> (a -> N) ~ T -> Bag a   so it's not actually that far of a stretch to go to   T -> Maybe a
07:42:40 <tojans> ah ok
07:42:41 <jmcarthur> it's just 0 or 1 instead of an arbitrary number
07:43:01 <hpc> you'd be surprised the things in haskell that don't have built-ins and are just plain-jane code
07:43:08 <mm_freak> jmcarthur: T -> Maybe a is too powerful
07:43:26 <tojans> hpc: I assumed I was missing something
07:43:26 <jmcarthur> i'm just saying this is the model, not that it's not junky
07:43:37 <tojans> hpc: but apparently I am not
07:43:41 * hackagebot cabal-debian 4.1 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.1 (DavidFox)
07:43:43 <jmcarthur> we already know that both FRP and AFRP are junky
07:44:08 <mm_freak> jmcarthur: firstly i disagree about that, secondly you can model FRP with AFRP
07:44:35 <jmcarthur> sure, AFRP is basically the same as FRP, just with an extra hoop to jump through for the sake of efficiency
07:44:44 <jmcarthur> i don't mean that to be a knock
07:45:00 <tojans> hpc: So, is there a convention on which one to pick (i.e. the first usually), or is it just like other packages (i.e. nodejs/python etc)
07:45:22 <mm_freak> jmcarthur: it has both advantages and disadvantages…  one important advantage is that the Behavior wrapper disappears
07:45:42 <mm_freak> jmcarthur: but i'd like to know why you think that FRP is junky
07:45:44 <hpc> tojans: basically, pick whatever matches the types you are using
07:46:00 <tojans> hpc: ok, thanks
07:47:02 <athan> Does anyone know what it means for a mapping to be considered "onto"?
07:47:16 <athan> Does it just mean there is a connection between set elements?
07:47:24 <jmcarthur> mm_freak: basically because the model implies you can do things that you can't
07:47:31 <mm_freak> athan: look into surjections on wikipedia…  the picture should explain it
07:47:34 <athan> speaking in the context of basic set theory stuff
07:47:39 <athan> thanks mm_freak
07:47:44 <haasn> piezoid: works with newtype T t a b = T (t a b)
07:47:45 <jmcarthur> mm_freak: arbitrary time shifting, for example
07:47:46 <haasn> maybe a bug?
07:47:47 <benmachine> athan: the word "onto" typically means that every element of the codomain is hit
07:47:59 <mm_freak> jmcarthur: huh?  no
07:48:07 <benmachine> athan: imo this is an abuse of English and I avoid the word, preferring "surjective" instead
07:48:10 <haasn> it's weird that it works with the newtype but not the type isomorphic to it
07:48:41 * hackagebot cabal-debian 4.1.1 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.1.1 (DavidFox)
07:48:42 <athan> Oh okay I see
07:48:51 <jmcarthur> mm_freak: sure it does.   shiftBackward delta behavior t = behavior (t + delta)
07:49:00 <athan> so surjectivity means that the codomain is fully comprehended by the function
07:49:02 <piezoid> haasn: thnks ! oh yes it's really strange...
07:49:09 <jmcarthur> mm_freak: shiftBackward :: D -> Behavior a -> Behavior a
07:49:45 <benmachine> athan: I don't know what you mean by comprehended
07:49:52 <mm_freak> jmcarthur: continuous time is just semantics…  obviously an actual implementation will have some discreteness, but when expressing the events and behaviors you can pretend that this discreteness does not exist…  for the same reason you don't get time shifts in actual implementations
07:49:59 <mm_freak> neither forward nor backward
07:50:09 <mm_freak> (although backward is in principle possible)
07:50:10 <athan> Oh! wait, okay!
07:50:19 <jmcarthur> mm_freak: "just semantics" is the model, which is all i've tried to talk about.
07:50:22 <athan> benmachine: it has full coverage
07:50:34 <benmachine> athan: the formal statement would be f : A -> B is surjective if for all b in B there exists a in A such that f(a) = b
07:50:48 <jmcarthur> mm_freak: and i didn't say anything about continuous time. it makes no difference whether time is continuous for FRP to be junky
07:50:57 <mm_freak> jmcarthur: if it's just the model, what's wrong with going back in time?
07:50:59 <athan> benmachine: _at least_ one
07:51:05 <benmachine> athan: right
07:51:06 <athan> benmachine: injection is _at most_ one
07:51:13 <benmachine> athan: right
07:51:24 <athan> benmachine: awesome, just checking my knowledge haha. Thanks
07:51:32 <benmachine> athan: hence bijection is exactly one :)
07:51:44 <mm_freak> jmcarthur: a reactive system "is"…  going forward in time would correspond to running it, and going backward would be looking at past values
07:51:49 <jmcarthur> mm_freak: nothing, according to the model. it's junky because not everything expressible in the model is denotable in the interface
07:51:50 <mm_freak> there is nothing inherently wrong about that
07:52:00 <athan> benmachine: == isomorphism, correct?
07:52:18 <benmachine> athan: isomorphism of sets
07:52:23 <benmachine> to be unambiguous
07:52:58 <mm_freak> jmcarthur: ok, let me put it this way…
07:53:20 <athan> benmachine: -which has this interesting srjective/injective pattern. Ie: at least one from the domain for surjective, at most one for injective, etc. Do you see this in any other categories?
07:53:22 <mm_freak> jmcarthur: there are functions from behaviors and events to netwire wires
07:53:42 <mm_freak> so what exactly in the model cannot be exposed by an actual implementation?
07:53:58 <piezoid> haasn: my bad, it work too : newtype VoidPair a b = VoidPair ()
07:54:16 <athan> benmachine: Actually nevermind >M
07:54:18 <athan> ><*
07:55:42 <bernalex> how do I do putStrLn $ zip getContents [1..]?
07:56:25 <mm_freak> bernalex: do c <- getContents; print (zip c [1..])
07:56:37 <bernalex> mm_freak: right, I meant w/o do notation, sorry.
07:57:00 <mm_freak> bernalex: fmap (\c -> zip c [1..]) >>= print
07:57:06 <mm_freak> bernalex: fmap (\c -> zip c [1..]) getContents >>= print
07:57:13 <jmcarthur> mm_freak: you're kind of arguing on a technicality. for all practical purposes, time shifting from future to past is a causality violation, and even if there happens to be no data dependency that goes cyclic you still end up having to stall parts of the system until the future data is available, which is unacceptable enough for most use cases that library authors try to be careful not to expose this
07:57:15 <jmcarthur> capability
07:57:20 <benmachine> getContents >>= \c -> print (zip c [1..])
07:57:34 <jmcarthur> s/unacceptable/confusing/   <-- at best
07:58:19 <bernalex> mm_freak: ah, I see. so print automatically does show or something?
07:58:22 <mm_freak> jmcarthur: i understand that…  if you have such a causality violation, this corresponds to a <<loop>>, and in fact all implementations expose this
07:58:32 <mm_freak> jmcarthur: either through MonadFix or through ArrowLoop
07:58:41 <bernalex> too bad you can't do [show 1..], heh.
07:58:42 * hackagebot tidal 0.2.10 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.10 (AlexMcLean)
07:58:53 <mm_freak> bernalex: print = putStrLn . show
07:59:02 <bernalex> mm_freak: oh! neat. thanks a lot.
07:59:10 <athan> oh!
07:59:12 <jmcarthur> mm_freak: for what it's worth, obviously i could just implement the model directly. this isn't about whether such an implementation can exist, but about whether practical implementations can be junk free
07:59:45 <mm_freak> jmcarthur: well, a direct implementation of the model wouldn't be very useful
07:59:48 <athan> isn't it faster to use Data.Text than String?
07:59:53 <jmcarthur> agreed
08:00:18 <piezoid> haasn: if the T wrapper is inside the GADT, the original signature typechecks, so it's an acceptable workaround
08:00:38 <haasn> piezoid: interesting
08:00:51 <Kaidelong> isn't part of the point of reactive systems to define away the whole idea of casuality and view the program as something unchanging but having a dimension in time?
08:01:09 <mm_freak> Kaidelong: f t = f (t - 1)
08:01:51 <mm_freak> Kaidelong: regardless, every time you define a behavior in terms of an event, you have a causal relationship
08:02:13 <mm_freak> especially when you introduce event-based switching
08:02:16 <jmcarthur> mm_freak: http://conal.net/blog/posts/garbage-collecting-the-semantics-of-frp   i think my point is best characterized by this: "What is a simple and adequate formal model of interactive behavior that reaches neither into the past nor into the future, and yet still allows the past to influence the present?"
08:02:19 <Kaidelong> yeah, the ideal breaks down if you want to do anything really useful with it
08:02:30 <jmcarthur> mm_freak: the answer to that question is not FRP, unfortunately
08:03:01 <mm_freak> jmcarthur: what's the alternative?
08:03:08 <jmcarthur> mm_freak: it is as yet unknown
08:05:04 <jmcarthur> ha, there are comments from me on that blog post totally misunderstand what "junk" means
08:05:08 <jmcarthur> *misunderstanding
08:06:02 <Kaidelong> jmcarthur: what about random access machines?
08:06:31 <Kaidelong> or just about anything with state transitions, IO, and destructive updates
08:06:52 <Kaidelong> you can probably show that the past can influence the present but you can't reach arbitrarily far into both the past and the future
08:06:57 <joe9>  I am trying to rewrite this better: http://codepad.org/flzs29I2 ,  and came up with this: http://codepad.org/Q5KTv8J8 but it does not compile.
08:07:01 <joe9> Is there an andM?
08:07:03 <mm_freak> jmcarthur: well, actually there is a model that avoids this junk, but you need dependent types to express it
08:07:10 <jmcarthur> Kaidelong: "simple" is also in that question. ;)
08:07:23 <jmcarthur> mm_freak: oh, yeah, i remember that paper
08:07:29 <joe9> this is the error : http://codepad.org/wWUDZ2UE
08:07:40 <Kaidelong> jmcarthur: I think there are simple abstract models for imperative programming out there!
08:07:48 <Kaidelong> they're just not nice to programmers
08:08:12 <hpc> that looks like a job for ErrorT
08:08:14 <mm_freak> jmcarthur: the basic idea is that behaviors and events have time-indexed types
08:08:31 <jmcarthur> mm_freak: my main beef with that one is that it's just FRP with an extra constraint. maybe that's the best we can do, but it seems... unsatsifying.   also, i kind of wish we had a model that more naturally expressed stuff like integration
08:08:43 <Kaidelong> dependent types would get rid of so many headaches
08:08:57 <Kaidelong> has anyone worked on migrating the haskell ecosystem to idris?
08:09:22 <mm_freak> jmcarthur: well, not just that…  the time index allows you to have correct switching
08:09:41 <mm_freak> switch :: Behavior t a -> Event t (forall t. Behavior t a) -> Behavior t a
08:09:45 <jmcarthur> right
08:10:19 <jmcarthur> and in fact in practice, using that function works out fine. it's just kind of awkward looking.
08:10:32 <bernalex> mm_freak: OK so now I have stdin <- getContents; let enumerated = zip [1..] $ lines stdin -- what is a neat way to print "1 firstline\n2 secondline" etc?
08:10:55 <mm_freak> bernalex: mapM_ print
08:11:28 <bernalex> mm_freak: right, but that will print tuples, not 1 lineone, so I'll need a lambda for that or something
08:11:52 <mm_freak> bernalex: mapM_ (uncurry $ printf "%d %n\n")
08:11:56 <mm_freak> import Text.Printf
08:12:00 <bernalex> oh, I can just use uncurry of course
08:12:06 <bernalex> yeh, I know about printf. thanks!
08:13:00 <mm_freak> jmcarthur: this is actually an interesting problem…  most AFRP libraries provide integrals, and they are cheap and nice to work with…  but they are illegal in the model
08:13:11 <jmcarthur> yeah
08:13:27 <mm_freak> i've been pondering about that for a while and one possible solution is to formulate a functor from Hask to Top
08:13:40 <mm_freak> i already view time as a topological space in my model
08:13:44 * hackagebot regex-tdfa 1.2.0 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.2.0 (ChrisKuklewicz)
08:13:46 * hackagebot tidal 0.2.11 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.11 (AlexMcLean)
08:14:34 <mm_freak> then behaviors are continuous maps from time
08:14:56 <mm_freak> if you want jumping, use the discrete topology for the codomain
08:15:05 <mm_freak> if you want integrals, use open balls
08:15:23 <joe9> it would be cool to have xmonad in idris.
08:15:32 <bernalex> OK apparently I can't do let enumerated = zip [0..] $ lines stdin -- because no instance for Enum a0? how do I solve this?
08:15:34 <jmcarthur> joe9: so write it!
08:16:03 <bernalex> oh, I forgot []
08:16:13 <bernalex> so :: [(Int, String)]works
08:17:37 <mm_freak> jmcarthur: the impression is that if you combine that with time index, you get rid of the causality problems and get integrals, too
08:18:28 <joe9> it would be cool to have it with Effects.
08:18:55 <jmcarthur> mm_freak: yeah, i've also put some thought into models like this one, but i'm just not educated enough in the right areas of mathematics to reason about it effectively.
08:19:45 <mm_freak> jmcarthur: it's mainly thought experiments right now, but if this turns into an actual model, you can expect me to write a library =)
08:19:58 <jmcarthur> i hope it works out then!
08:20:15 <mm_freak> not sure what to call it though
08:20:26 <mm_freak> HoFRP =)
08:21:09 <Fuuzetsu> is it a FRP library which gets you all the hos?
08:24:05 <Fernandos> hi
08:25:21 <haasn> bernalex: I want a lens for that :(
08:25:40 <bernalex> haasn: for what? [show 1..]?
08:25:55 <haasn> bernalex: a fold into the words/lines of a string
08:26:07 <Kaidelong> is it really a problem if integrals can't be implemented by the end user and they just have the use the ones provided by the library?
08:26:11 <bernalex> haasn: ah. write one. ;-)
08:26:17 <Fernandos> just need a quick guide on how I install the whole haskell environment without root with cabal
08:26:17 <haasn> bernalex: which would make your code basically  stdin ^@.. to lines.folded -- but with a better name for to lines.folded ;)
08:27:09 <Kaidelong> I mean it'd be nice to have a more general system but are the tradeoffs worth it and how much can practically be got done with what already exists
08:30:10 <grady_player> I am learning haskell (very beginner) and I have a flow control question, is this an appropriate forum?
08:30:18 <tojans> Another question: how do you use hoogle?
08:30:26 <Kaidelong> yes
08:30:28 <tojans> this doesn't work apparently:
08:30:29 <tojans> http://www.haskell.org/hoogle/?hoogle=String+-%3E+Data.Text.Lazy.Internal.String
08:30:41 <mm_freak> Kaidelong: that's not the problem (it's that way anyway)
08:30:47 <tojans> i.e. how can I search for specific casts
08:30:58 <haasn> grady_player: what do you mean by “flow control”?
08:31:03 <mm_freak> Kaidelong: the problem is that you can't integrate a function of time in haskell
08:31:23 <grady_player> I have an infinite list.. [1..]
08:31:53 <grady_player> I then want  a list that is only 1.. f(x)==some numnber
08:32:02 <mm_freak> Kaidelong: in other words the formal model of FRP does not support calculus
08:32:17 <mm_freak> but by moving it from Hask to Top calculus becomes possible
08:32:26 <grady_player> so my thought was: s (x:xs) = if (f x < 4000000) then f x : s xs else (what goes here)
08:32:32 <haasn> I wonder if it's possible to auto-integrate functions like you can auto-differentiate them
08:32:45 <mm_freak> and one simple functor from Hask to Top maps types to spaces with the discrete topology
08:33:19 <mm_freak> but then you don't get integration for free
08:33:37 <mm_freak> you actually need to start within Top to get integration
08:33:54 <mm_freak> haasn: sure
08:34:09 <Kaidelong> grady_player: looks like it should be []
08:34:11 <haasn> grady_player: first things first, there's no control flow when evaluating haskell expressions, because there's no control. Expressions have values, not effects. Anyhow, that depends entirely on what you want the semantics of ‘s’ to be. What is the result of s [x,y,z] supposed to be when f x > 4000000?
08:34:12 <k00mi> grady_player: takeWhile (< 4000000) . map f
08:34:25 <bernalex> how can I write "let enumerated = enumerate contents; mapM_ (uncurry $ printf "\t%d %s\n") enumerated" in one line?
08:35:01 <quchen> mapM_ (uncurry $ printf "\t%d %s\n") (enumerate contents)
08:35:08 <Kaidelong> no control flow? Really?
08:35:14 <bernalex> oh right that was simpler than I thought
08:35:20 <bernalex> I was overthinking things =/
08:35:33 <quchen> Yes.
08:35:51 <quchen> You can always trivially inline non-recursive let bindings.
08:36:24 <bernalex> so what about making this one line: stdin <- getContents; mapM_ (uncurry $ printf "\t%d %s\n") $ enumerate stdin
08:36:26 <haasn> Kaidelong: nothing that I would call that, no
08:36:40 <Kaidelong> wasn't one of the biggest gripes (and strengths) about haskell a lack of distinction between control structures and data structures?
08:36:44 <bernalex> I just need to repeat doing stuff like this until it sticks
08:37:04 <quchen> getContents >>= mapM_ (...) . enumerate
08:37:16 <Kaidelong> I remember a blog post to the effect of "I don't want to teach my students haskell because lists are not really control structures and they are not in ML"
08:37:36 <quchen> Lists are not control strucutures?
08:37:40 <quchen> That sounds odd.
08:37:47 <haasn> but lists aren't controlling anything; they're just data structures. I think it would be more appropriate to cite the lack of control structures
08:37:51 <quchen> Lists are also not not control strucutres.
08:37:55 <hpc> they aren't data structures either
08:38:07 <hpc> the only valid things to teach are arrays, hash tables, and B-trees
08:38:16 <quchen> ಠ_ಠ
08:38:19 <haasn> Oh no, we may have gotten ourselves into a bit of a terminology mess :(
08:38:27 <hpc> next semester, 6 weeks of learning how page faults work!
08:38:57 <bernalex> quchen: that's what I thought, but that doesn't work: Couldn't match expected type `(String -> [(Int, String)]) -> IO ()'
08:39:16 <hpc> Kaidelong: that sounds a lot like something harper would say
08:39:19 <bernalex> alsoCouldn't match type `(a0, b0)' with `Char'
08:39:50 <bernalex> enumerate :: String -> [(Int, String)] FTR
08:40:07 <Kaidelong> haskell lists essentially structure control flow, if you match the pattern you (!x:xs) compute a value and fetch a continuation to get the next value
08:40:48 <haasn> nonstrict evaluation makes control structures out of data structures!
08:40:53 <Kaidelong> yes
08:40:54 <grady_player> thanks Kaidelong that seems to work, I will try to get the takeWhile approach to work, as that seems more idomatic
08:41:06 <Kaidelong> it is more idiomatic
08:41:13 <dolio> You could write ML programs that way, if it were pure.
08:41:22 <dolio> And the compiler did deforestation.
08:41:28 <dolio> But it doesn't, because it can't.
08:41:44 <quchen> bernalex: Works. http://lpaste.net/99377
08:42:21 <bernalex> quchen: riiight. I forgot to chance $ -> .
08:42:28 <quchen> Fear the $
08:42:44 <bernalex> thanks!
08:42:53 <dolio> So instead you have to use 'control structures' to get things to happen in the order you want, instead of writing what happens to the values, and the natural evaluation order being the desired one (in this case).
08:43:13 <quchen> bernalex: For the record, the "do" version is pretty much equivalent to what I pasted.
08:43:40 <quchen> "do" has zero overhead anyway, so use whatever is more readable.
08:44:06 <bernalex> quchen: I was undoing two dos to spot the common patterns and abstract them into wheres. now it's actually more readable without dos.
08:44:28 <bernalex> I just have "getContents >>= output . enumerate" and "concat <$> mapM readFile files >>= output . enumerate", which I enjoy.
08:47:55 <exicer> Is there a function to convert a strict bytestring to a lazy bytestring ?
08:48:08 <hpc> :t BS.fromChunks
08:48:09 <lambdabot> Couldn't find qualified module.
08:48:14 <hpc> :t BSS.fromChunks
08:48:15 <lambdabot> Couldn't find qualified module.
08:48:19 <hpc> :t fromChunks
08:48:20 <lambdabot>     Not in scope: `fromChunks'
08:48:20 <lambdabot>     Perhaps you meant one of these:
08:48:20 <lambdabot>       `BSLC.fromChunks' (imported from Data.ByteString.Lazy.Char8),
08:48:27 <hpc> ugh
08:48:28 <haasn> bernalex: that <$> has got to be reduceable via some monad law
08:48:34 <hpc> well, one of those
08:48:49 <tojans> hpc: have to go; thanks for the help!
08:48:50 * hackagebot warp 2.0.2.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.2.1 (MichaelSnoyman)
08:48:52 <Fuuzetsu> @hoogle fromStrict
08:48:52 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
08:48:52 <lambdabot> Data.ByteString.Lazy.Char8 fromStrict :: ByteString -> ByteString
08:48:52 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
08:48:56 <Fuuzetsu> there you go
08:48:59 <exicer> hpc: Ah, cool. Will have a look
08:49:02 <exicer> Fuuzetsu: Thanks!
08:49:04 <haasn> bernalex: mapM readFile files >>= output . enumerate . concat
08:50:00 <bernalex> haasn: feel free to explain more in-depth
08:51:23 <haasn> bernalex: fmap f x >>= g  →  x >>= \a -> return (f a) >>= g  →  x >>= \a -> g (f a)  →  x >>= g . f
08:51:31 <haasn> (those are the full steps invoking only monad laws)
08:52:13 <bernalex> haasn: feel free to explain what specifically was wrong with my code and why it was wrong rather than general cases using monad laws
08:52:23 <haasn> there was nothing wrong
08:52:44 <haasn> it's just slightly more verbose/confusing than it needs to be :)
08:52:50 <bernalex> haasn: OIC
08:52:52 <benmachine> haasn: I'm a little concerned that you used associativity without saying so
08:53:04 <haasn> bernalex: oh, good point
08:53:10 <haasn> that should be an extra step
08:53:13 <haasn> benmachine: *
08:53:18 <benmachine> mm
08:53:24 <benmachine> I'm pretty sure it's still true, so I'm not that concerned :P
08:54:00 <bernalex> haasn: I applied it though because getting rid of a <$> is a win in there
08:54:17 <haasn> bernalex: especially because I can never remember whether <$> or >>= binds more tightly
08:56:24 <haasn> Hmm
08:57:31 <benmachine> personally I'd leave concat <$> mapM f xs as it is, because you're really thinking "concatMapM" so IMO the concat and the map should stay textually near each other
08:58:32 <hc> i'm using the following statement to repeatedly run some io code:   forkIO . sequence_ . repeat $ (functon call here)
08:58:40 <hc> can that be a cause for a memory leak?
09:00:41 <haasn> sequence _ repeat = forever
09:00:46 <haasn> sequence_ . repeat = forever
09:02:27 <exicer> stupid question: I'm in a MaybeT IO ByteString do block, and I want to get the value out of a function taht returns Maybe ByteString. What do I do ?
09:02:40 <benmachine> hc: I don't believe so, but I'm not an expert on memory usage
09:02:41 <haasn> hc: not on its own
09:02:55 <hc> okay. then my memory leak is elsewhere
09:03:18 <haasn> sequence_ will happily consume everything repeat produces and throw it away. But it might be the case that the IO action you're repeating does something weird. I'm not an expert on memory usage, either
09:03:41 <monochrom> to get a value out of a function, pass a parameter to the function
09:03:41 <quchen> exicer: MaybeT . return
09:03:42 <hc> i'm using a channel and duplicate it for each network connection
09:03:52 * hackagebot yesod-core 1.2.6.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.6 (MichaelSnoyman)
09:03:54 * hackagebot yesod-form 1.3.5 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.5 (MichaelSnoyman)
09:03:56 * hackagebot yesod-bin 1.2.5.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.8 (MichaelSnoyman)
09:04:09 <hc> then i'm passing every message received on that channel to every network socket currently open... that's all i'm doing basically
09:04:39 <haasn> monochrom: do you pass parameters to functions, or do you apply functions to parameters?
09:04:48 <monochrom> I do both
09:05:49 <hc> hGetLine is strict, right?
09:05:59 <exicer> quchen: Thanks. I had tried that before, but had a bracket in the wrong place. doh.
09:07:31 <tristan__> I usually stay away form APress, anyoen know if Beginning Haskell: A Project-Based Approach is good?
09:07:36 <derekv> this haskell podcast is good
09:08:43 <finster> tristan__: "Learn you a haskell for great good" is currently serving me well in learning Haskell
09:09:12 <nadirs> hpc: Hours later I managed to rewrite the sieve of Sundaram. Thank you because "exclude" was definitely a bottleneck;
09:09:14 <nadirs> also the function in its whole wasn't completely correct.
09:09:20 <nadirs> Now it's faster than before, although it seems still at least quadratic.
09:09:30 <finster> tristan__: there's also a free online-version
09:11:07 <japesinator> I'm trying to set up ghc-mod and hdevtools in vim, but I keep getting weird errors on startup and write
09:11:09 <tristan__> finster: yea. I don't really need a beginner book. But I like to purchase new functional language books if they are decent, to move the numbers up so more books get written :)
09:11:09 <nadirs> hpc: here it is how I rewrote it → http://lpaste.net/99368
09:11:13 <japesinator> http://pastebin.com/grt1qu2q
09:11:21 <japesinator> Anyone know how to fix this?
09:12:46 <nadirs> japesinator: does the user running Vim have "x" permissions on hdevtools and ghcmod?
09:13:48 <japesinator> I'm not sure
09:13:52 <nadirs> japesinator: what's the output for → ls -lah `which hdevtools`
09:14:22 <nadirs> japesinator: and what's the output for → ls -lah `which ghc-mod`
09:15:00 <japesinator> ls: found: No such file or directory
09:15:01 <japesinator> ls: hdevtools: No such file or directory
09:15:01 <japesinator> ls: not: No such file or directory
09:15:12 <japesinator> I ran cabal install hdevtools
09:15:32 <monochrom> I guess PATH doesn't have $HOME/.cabal/bin yet
09:18:10 <japesinator> ./cabal only has config and config.platform in it, not bin
09:28:53 <Fernandos> it's awesome that (almost [none that I know of]) no haskell library has external system dependencies other than other haskell libs, contrary to python.
09:29:26 <hpc> it's rather revealing the reason so many python libs have outside dependencies, too
09:30:31 <bergmark> "Recode Python functions in C. As reddit [scaled] they pulled out repetitive functions [into] C."
09:31:05 <Fernandos> Indeed. Basically that python is mostly used for something it wasn't meant for and "performance reasons", forced it to include external libraries, maybe also because the language didn't evolve to increase in performance, but features only.
09:31:56 <Fernandos> bergmark: Using C from the beginning and writing a python C DSL would have been wiser then.
09:32:32 <Fernandos> they could've created a mini-vm in C for python too for that purpose.
09:32:42 <Fernandos> I mean for strong typing support.
09:34:54 <Fuuzetsu> Fernandos: some people *cough*Twey*cough* would rather have third party libs or use system commands to call executables…
09:35:16 <qwitwa> What about http://cython.org/
09:37:16 <Fernandos> qwitwa: I know about it, it's still far from reaching Haskell's performance and just underlines the idea of a mini-vm and using C where you need C. I'm just learning and have no clue how the experienced amongst you can tune haskell programs to achieve C lke speed (or more).
09:38:04 <japesinator> How do I make commands installed via cabal executable?  I ran `cabal install hdevtools` but I can't run hdevtools from the command line and vim says it isn't executable?
09:38:36 <hpc> japesinator: it's installed to your user
09:38:41 <hpc> on linux, ~/.cabal/bin
09:38:41 <geekosaur> what does `type hdevtools` report?
09:38:56 * hackagebot hOpenPGP 0.14 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.14 (ClintAdams)
09:39:10 <geekosaur> (I am inclined to think you have a file/directory named hdevtools somewhere, rather than the executable)
09:39:58 <japesinator> I don't have a directory called bin in .cabal
09:40:05 <hpc> hmm
09:40:24 <Peaker> Fernandos: Haskell can reach C-like performance "in-the-small", in relatively small inner loops. But I think the constant factor of efficient mutable data structures vs. persistent data structures and the less pointer-chasing/more control over cache locality you have in C is generally unattainable in Haskell.  That said, most C programs are written without any of that in mind so Haskell can achieve that kind of performance
09:40:53 <japesinator> I do have an executable in ~/Library/Haskell/ghc-7.6.3/lib/hdevtools-0.1.0.5/bin
09:41:30 <Peaker> GC is going to be more expensive than good manual memory management (again, most C programs don't do good manual MM)
09:41:49 <Fernandos> Peaker: hmm isn't that more or less "easily" possible to add as a non-feature feature to GHC? I mean in a similar vain as asm.js did for javascript, by removing extranous types and reducing the language to a minimum.
09:42:07 <Fuuzetsu> what's the point
09:42:24 <Peaker> Fernandos: Using mutable structures pervasively wouldn't be Haskell anymore
09:42:55 <geekosaur> japesinator: do you have one in ~/Library/Haskell/bin?
09:42:56 <Peaker> Fernandos: Easier and more fine-grained control over memory allocations would be welcome, though
09:43:05 <Fernandos> Fuuzetsu: to keep writing only haskell, even where you need C's performance without having to tune programs for hours
09:43:30 <geekosaur> (if not... this is a bug I keep seeing but have not quite understood, it's supposed to copy the binary to ~/Library/Haskell/bin but sometimes doesn't)
09:43:40 <Peaker> Fernandos: If optimal performance is needed, use C/C++/Rust
09:43:49 <Peaker> (well, probably not Rust just yet :) )
09:44:04 <Peaker> If acceptable/good performance is needed, use Haskell
09:45:12 <Fernandos> Peaker: I know of other languages that have higher performance than C and don't argue against C (really like it), but think it makes sense to allow the compiler to run in --bare mode.
09:45:26 <Peaker> Fernandos: which other languages?
09:45:41 <Fernandos> ASN.1, *ASM ie.
09:46:02 <Peaker> Fernandos: is ASN.1 a programming language? I thought it was more of a data structure description DSL?
09:46:28 <Fuuzetsu> Fernandos: but you wouldn't be writing only Haskell, you'd be writing some small bastardisation of it which sacrifices the reasons why we actually use Haskell to begin with for some performance. If you really need that much performance, just use C or something
09:46:55 <Peaker> Fernandos: ASM doesn't have much better performance than C -- at least on modern x86/64/etc  because the bottleneck is almost purely memory access (random latency first, and throughput second), and ASM doesn't help much with minimizing those compared with C
09:46:57 <Fernandos> Peaker: no you're right, but it allows to improveme performance. Her's a library http://bellard.org/ffasn1/
09:47:55 <Peaker> Fernandos: Well, a strict-variant of Haskell can be easier to optimize and get better performance. But with GC and pervasive immutability, a significant gap over C will remain, IMO
09:48:27 <qwitwa> Fernandos: That link seems to be a compile that compiles to C code.
09:48:47 <qwitwa> A compiler to C is not going to get better performance than C by definition!
09:49:23 <Fernandos> qwitwa: yep, it helps writing more efficient code in C. It's not easy to write faster code in C just because C is low-level. That's where structuring logic and generating code can help.
09:50:06 <jmcarthur> a coworker of mine made a finely tuned C program to reduce latency compared to the program he was replacing. it really pulled out a lot of tricks a shortcuts. yesterday i made a haskell implementation that's actually faster and has half the lines of code.
09:50:18 <jmcarthur> it's anecdotal, i know, but you really can write quite efficient haskell these days
09:51:20 <mornfall> jmcarthur: that really depends on how good that other guy actually was :-)
09:51:37 <qwitwa> Fernandos: But that's what compilers are for. I don't /need/ to hyper optemise my C so long as I don't make any fundamental design errors, since the compiler will figure out the fastest way to do what I want.
09:51:58 <jmcarthur> mornfall: he's good. it was a fine C program. it didn't take advantage of crazy compiler intrinsics or anything, but it was designed for cache awareness, avoiding bad system calls, etc.
09:52:22 <jmcarthur> s/cache awareness/good cache locality/
09:52:41 <jmcarthur> it barely does any system calls at all, in fact
09:52:43 <Fernandos> jmcarthur exactly that's the point. It really makes sense to invest time into structure and logic, rather than micro-optimizing loops. Altough both give benefits at some time. But haskell has the advantage that functional constructs allow easier (per lines of code) optimization
09:52:44 <mornfall> jmcarthur: so do you have some idea where the haskell program wins? because the GC overhead in haskell is certainly non-negligible, and all other things being equal, C would easily win on that alone
09:53:58 * hackagebot shelly 1.4.3.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.3.1 (GregWeber)
09:54:02 <Fernandos> jmcarthur I remember trying to make the fastest hello world possible with C for a day, to let it saturate a benchmark tool.
09:54:03 <jmcarthur> mornfall: actually the GC overhead is quite negligible. my final version performs very few allocations and spends <1% on GC.
09:54:31 <jmcarthur> mornfall: even an earlier version of mine which did a lot more allocations was faster though
09:54:48 <jmcarthur> mornfall: i think the win is that i fused my loops better
09:54:56 <Fernandos> I have heard of such efficiency only from one-pass algorithms
09:55:17 <jmcarthur> no, i have a couple intermediate arrays in this algorithm, too
09:55:46 <jmcarthur> that don't get fused away, that is
09:56:15 <mornfall> jmcarthur: well, you really want C++ for fusion I guess :) C is a lot of trouble in that respect
09:56:42 <Fernandos> I've not tested it yet, but anic claims to be faster than typical c. http://code.google.com/p/anic/
09:56:43 <jmcarthur> i'm not a very experience C++ programmer. what kind of fusion can i expect from it?
09:56:58 <thorkilnaur> spacekitteh, Concerning http://lpaste.net/99332, you are using something like:
09:56:59 <jmcarthur> or do you just mean that it's easier to manually fuse in C++ than in C?
09:57:12 <jmcarthur> due to iterators and such?
09:57:47 <thorkilnaur> > let newtonRootIter n a x = x + (a/x - x)/fromIntegral n in iterate (newtonRootIter 3 27.0) 1.0
09:57:48 <lambdabot>  [1.0,9.666666666666666,7.375478927203065,6.137245691728451,5.557953002663583...
09:57:52 <mornfall> jmcarthur: let me look up a paper (I only recall it vaguely, so it may take a while)
09:58:56 <thorkilnaur> spacekitteh, ... which will converge (somewhat slowly, if n is large) to the square root, whereas you really need something like:
09:58:58 * hackagebot shelly 1.4.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.4 (GregWeber)
09:59:32 <thorkilnaur> > let newtonRootIter n a x = x + (a/x^(n-1) - x)/fromIntegral n in iterate (newtonRootIter 3 27.0) 1.0
09:59:33 <lambdabot>  [1.0,9.666666666666666,6.540758356453956,4.570876778578707,3.478019233386796...
10:00:44 <Fernandos> hmm.. newb question... is haskell actually cross-platform?
10:00:59 <Hafydd> GHC is.
10:01:07 <jmcarthur> define cross-platform
10:01:20 <Hafydd> in that it runs on more than one major platform.
10:01:32 <Hafydd> (and compiles programs for such platforms)
10:01:52 <geekosaur> ajhc compiled programs should work on any platform that has an ANSI C compiler, although it is itself written in ghc
10:02:01 <Fernandos> for me it would be cross-platform if it ran on arm and x86 versions of linux,windows and current macs
10:02:20 <geekosaur> ghc *should* be able to run on many platforms but getting it cross-compiled can be painful
10:02:30 <jmcarthur> then ghc is or soon will be cross platform
10:02:39 <Fernandos> so does it runs on windows and linux, or not?
10:02:59 <jmcarthur> however, as with almost every language (or language implementation) i know, you do often still have to write platform specific code for certain non-trivial kinds of programs
10:03:07 <jmcarthur> it does
10:03:16 <dario|> Fernandos: https://ghc.haskell.org/trac/ghc/wiki/Platforms
10:04:51 <Fernandos> jmcarthur hmm I think platform specific optimizations could maybe eliminated by reflecting/translating ghc with quemu to create code that runs on other platforms. I don't know the original link where fabrice bellard said he writing such a compilter, but know of another paper, if you're curious.
10:05:14 <Fernandos> dario|: thank you
10:07:28 <jmcarthur> Fernandos: not optimizations. functionality.
10:07:43 <jmcarthur> Fernandos: e.g. differences in various system calls
10:08:51 <mornfall> jmcarthur: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf -- here Haskell beats C, but C++ beats Haskell by a similar margin
10:08:56 <Fernandos> Fernandos: hmm idk. if quemu can help to optimize, but that's right, it can help to reflect the compiler to generate code that works on other platforms
10:09:21 <Fernandos> what you said. syscalls..
10:10:13 <mornfall> jmcarthur: the point is, C++ can be programmed in a way to fuse loops -- it may need more expertise than coding haskell fusibly (although I find that arguable), but the results are quite spectacular
10:10:42 <Fernandos> jmcarthur http://infoscience.epfl.ch/record/149975/files/x86-llvm-translator-chipounov_2.pdf
10:11:06 <jmcarthur> Fernandos: i mean specialized stuff, like mmap.
10:11:09 <mornfall> jmcarthur: (check figure 12 -- eigen is a C++ package with fusion... especially note the dropoffs on 10^7 working set size)
10:11:30 <jmcarthur> Fernandos: things whose semantics are usually reflected in your code directly
10:14:01 <Fernandos> does haskell-updater contain cabal?
10:15:15 <Fernandos> mhhk.. looks like cabal is separate in dev-haskell/cabal
10:17:03 <jmcarthur> mornfall: ah, the trick in C++ is to pass your intermediates along as const references instead of as values. that makes sense if you think about it, but it is very unfortunate that you can't just think of them as values.
10:17:10 <qwitwa> I'm not knowledgable enough to understand all this talk about fusion.
10:17:35 <jmcarthur> mornfall: but this does remaind me to try my program with vector HEAD
10:17:37 <benzrf> hey
10:17:43 <qwitwa> Looking loop fusion up in wikipedia it seems to suggest that for some platforms loop fission is actually an optemization.
10:17:51 <benzrf> does the makelenses macro create prisms depending on context
10:17:55 <benzrf> or do I need to be precise
10:18:19 <qwitwa> Which would imply that sort of thing should be figured out by the compiler.
10:18:59 <jmcarthur> qwitwa: it's hard for the compiler to do it for arbitrary code, so it is beneficial to code in certain styles which make it easier for the compiler, but such that you hopefully don't break other nice properties of your code
10:19:12 <mornfall> jmcarthur: the trick is somewhat different, it implements actual loop fusion by using "lazy" evaluation... it's not just about passing things as references; in this case, references are important because passing an intermediate by value will force it into existence
10:19:41 <jmcarthur> mornfall: right. the compiler is able to see that the value isn't needed until some time later
10:19:42 <mornfall> jmcarthur: when you pass it as a reference, it behaves as a thunk
10:19:50 <jmcarthur> mornfall: this is why i said it makes sense
10:19:58 <jmcarthur> mornfall: because i actually understood it ;)
10:20:33 <qwitwa> jmcarthur: Would these styles be platform specific?
10:20:52 <jmcarthur> qwitwa: it depends on the language/compiler/fusion-technique
10:21:02 <jmcarthur> qwitwa: in haskell they generally are not platform specific
10:21:14 <jmcarthur> i would say most are not platform specific
10:22:02 <benzrf> help ;-;
10:22:11 <benzrf> is anybody good at lens here
10:22:20 <mornfall> qwitwa: sometimes lambda lifting is an optimisation, and othertimes is lambda dropping... make your call ;-)
10:22:37 <notdan> benzrf: a bit
10:23:10 <mornfall> qwitwa: it doesn't only depend on a platform, also on the loop (program)
10:23:18 <benzrf> notdan: how can I generate prisms automatically with lens
10:23:21 <benzrf> the macros i mean
10:23:24 <benzrf> is there a makePrisms?
10:23:34 <mornfall> qwitwa: and it's quite undecidable to figure out which cases are which
10:24:37 <notdan> benzrf: there us makePrisms, yes
10:24:39 <notdan> s/us/yes/
10:24:48 <benzrf> yay
10:24:51 <benzrf> is there like
10:24:53 <benzrf> makeTraversals
10:25:02 <benzrf> for when you have a nonreversible with failure?
10:25:09 <notdan> traversals are created automatically with makeLenses I think
10:25:16 <benzrf> oh good
10:25:23 <notdan> benzrf: http://hackage.haskell.org/package/lens-4.0/docs/Control-Lens-TH.html
10:25:25 <qwitwa> mornfall: Mathematically undecidable, or simply currently undecidable? Is it concievable that problem will be solved by more compiler research?
10:26:05 <jmcarthur> for stream fusion in ghc, the trick is to (1) try to express your algorithm in such a way that you only use an intermediate array once, unless you can't get out of it; (2) use the higher level combinators provided by the array library instead of writing your own loops; (3) be aware of allocation rates; (3.5) help the worker wrapper transformation by pointing out to ghc where its strictness analysis is
10:26:07 <mornfall> qwitwa: it's undecidable in principle; you can come up with better or worse heuristics, or cut down on your language to make it decidable
10:26:08 <jmcarthur> failing
10:26:34 <qwitwa> The wikipedia page for lambda lifting is a wondeful mess. I'm gonna have to sit down with it at some point and enjoy myself ;P
10:26:51 <jmcarthur> the (3.5) is important because ghc can't unbox unless it knows that the value is used strictly
10:30:45 <benzrf> ok
10:30:55 <mornfall> jmcarthur: well, most of those things follow from seeing under the hood of the compiler fairly well (even if you only have inferred that inside knowledge by observing it on the outside)
10:30:55 <benzrf> I wrote the following for my basic lisp impl
10:31:07 <mornfall> jmcarthur: works the same way for C++, or any other language, really
10:31:07 <benzrf> notice any way to eliminate the repitition, or otherwise make it less ugly?
10:31:09 <benzrf> http://bpaste.net/show/174855/
10:32:09 <mornfall> jmcarthur: I doubt you'd be able to pull it off after a week with the language :-)
10:33:43 <Peaker> benzrf: why fmap the Maybe value if you're casing it anyway? just apply the function on the content of the Just?
10:33:57 <Peaker> is preview = ^? ?
10:34:09 <benzrf> yeah
10:34:22 <Peaker> I find the operators much more readable, but then, I got used to them :)
10:34:27 <benzrf> Peaker: hm
10:34:29 <jmcarthur> mornfall: sure, it still unfortunately requires a pretty deep understanding of the language, compiler, and libraries
10:34:43 <benzrf> Peaker: it is because in the higher-arg ones I am applicativing
10:34:47 <benzrf> and I want them to look consistent
10:34:50 <mornfall> jmcarthur: I'm wondering if that ever changes :-) for any language
10:35:22 <Peaker> with lambda-case, you can use \case of ...
10:35:40 <jmcarthur> mornfall: i think a language could be constructed which makes it more painful to break with good practices, but never in such a way that it just totally solves the problem.
10:35:44 <benzrf> what's the review operator?
10:35:54 <bennofs> (#)
10:35:56 <Peaker> #
10:36:15 <Peaker> benzrf: you could do the same thing that Applicative does to avoid the repetition
10:36:26 <Peaker> benzrf: oops, I might be confused, reading more :)
10:36:47 <benzrf> :T (#)
10:36:51 <benzrf> :t (#)
10:36:52 <lambdabot> parse error on input `)'
10:36:55 <benzrf> bah
10:37:16 <Peaker> benzrf: your types don't seem like they're the most general ones -- if you only use "review" on last param, and only "preview" on first params -- you don't need full-fledged Prisms for either
10:37:34 <Peaker> benzrf: this is where the lens hierarchy diagram is useful :)
10:37:45 <Fernandos> this is outdated right http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable ?
10:37:47 <benzrf> oh?
10:39:03 * hackagebot bibtex 0.1.0.4 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.1.0.4 (HenningThielemann)
10:39:18 <Peaker> benzrf: you only need Review on the result, and Getting or Fold on the params
10:40:10 <monochrom> yes Fernandos
10:40:32 <benzrf> sorry but i only barely grok lenses
10:40:45 <benzrf> i do not feel like messing with fancy schmancy type classes until i really get the basics
10:40:48 <benzrf> ~_~
10:40:50 <Peaker> benzrf: maybe I can help with this code later, it seems like it should lend itself, with some refactoring, to just being defined as the applicative combinators or even a true type with Applicative instance
10:40:58 <monochrom> reading != messing
10:41:21 <benzrf> Peaker: LispVal is not parameterized
10:41:30 <benzrf> so it's the wrong kind for applicative
10:41:32 <Peaker> benzrf: you could refactor this without lens as a first step
10:41:37 <benzrf> yeah?
10:41:45 <Peaker> benzrf: if you're more comfortable with that
10:42:25 <tertl3> whats the difference   between a monad and applicative ?
10:42:29 <tertl3> :t
10:42:32 <Fernandos> what's the current stable version of ghc then?
10:42:32 <Peaker> benzrf: 2 problems here: How to optimally use lens.   How to eliminate applicative-style duplication.     Solve just one at a time :)
10:42:44 <tertl3> >:t Monad.IO
10:42:47 <Fernandos> the frontpage also seems outdate
10:43:07 <tertl3> > false
10:43:08 <lambdabot>  Not in scope: `false'
10:43:15 <tertl3> > False
10:43:16 <lambdabot>  False
10:43:44 <benzrf> tertl3: applicatives cannot make decisions
10:43:46 <tertl3> just what I suspected
10:43:54 <tertl3> oops
10:44:00 <tertl3> that wasnt for you benzrf
10:46:08 <tertl3> benzrf: and how does a functor fit into those 2?
10:46:31 <bergmark> Fernandos: ghc 7.6.3 is the latest
10:47:26 <benzrf> tertl3: functors do not let you use multi arg funcs
10:48:01 <dwcook> Sure they do, just the type it's parameterized by will be a function
10:48:17 <dwcook> Unless I misunderstood what you meant
10:50:33 <Javran> is there any "monad definition" that violates exactly one monad law?
10:50:57 <dwcook> Javran, with which formulation of the monad laws?
10:51:04 <tertl3> Javran: thats a antimonad :P
10:51:09 <jle`> Javran: I'm sure you can make one by construction
10:51:25 <dwcook> You could argue the bad ListT does
10:51:40 <hpc> if there's any two laws you can't break independently, they are collapsable into one law
10:52:45 <Fernandos> thanks bergmark
10:54:03 <Javran> I'm not sure if I can make one.
10:54:03 <monochrom> "data Strict a = S !a" is a useful monad that violates the monad laws slightly. "return ⊥ >>= \_ -> return ()" does not equal "return ()"
10:54:41 <monochrom> but I am not keen on counting the number of laws and judge "this is 1 law", "these are 2 laws", "this is 0.1 laws"
10:55:33 <Javran> I meant left/right identity and associativity
11:00:03 <ReinH> monochrom: I have judged your monad and found it... wanting.
11:04:37 <mgaut72> Hi.  New(ish) to haskell, very new to web/API stuff.  I am wondering if there are tutorials to implemeting a REST API in haskell.  thoughts?
11:05:10 <hpc> http://hackage.haskell.org/package/restful-snap -- most likely something like this will be what you need
11:05:41 <hpc> there's a tutorial here, for snap itself: http://snapframework.com/
11:05:50 <tertl3> where are the jjobs in Haskll?
11:05:57 <mgaut72> thanks, ill look into it
11:06:08 <hpc> tertl3: over there -->
11:06:12 <hpc> doh, you just missed them
11:07:15 <hpc> there's haskell jobs at google in a few places
11:07:31 <hpc> microsoft does research with haskell that eventually makes its way to F#
11:07:42 <hpc> then there's companies like galois
11:08:01 <piezoid> @hoogle (a -> Bool) -> a -> Maybe a
11:08:02 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:08:02 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:08:02 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:09:54 <piezoid> any equivalent to using this in view patterns : check p a = if p a then Just a else Nothing ?
11:10:35 <Fernandos> lol.. this is so stupid and ironic .. "Facebook uses some Haskell internally for tools. lex-pass is a tool for programmatically manipulating a PHP code base via Haskell."
11:10:47 <MedDev> tertl3, if finance is your thing (or could be) there are more than a few financial institutions that use haskell in their trading platforms
11:10:47 <c_wraith> facebook doesn't use lex-pass anymore
11:10:58 <c_wraith> according to the haskell folk there
11:11:37 <c_wraith> current haskell use at facebook is writing backend data manipulation utilities
11:13:11 <dwcook> How about a tool to convert PHP code into appropriate Haskell? That'd be handy
11:13:24 <zomg> dwcook: I wrote one...
11:13:24 <zomg> :D
11:13:37 <dwcook> Of course it'd take some thought if you wanted something more than having some type PHPValue with all your data
11:13:37 <zomg> It's not exactly 100% functional but it does *something* at least
11:13:40 <dwcook> zomg, neat, link?
11:14:14 <zomg> https://github.com/jhartikainen/hs-language-php/blob/master/CodeGen.hs
11:14:20 <Fernandos> dwcook: and you're not hired by facebook already?
11:14:27 <dwcook> Fernandos, I didn't write any such thing
11:14:27 <zomg> I wrote that project mostly as an exercise for writing parsers in haskell
11:14:31 <dwcook> Fernandos, you mean zomg?
11:14:40 <Fernandos> ah yeah indeed
11:14:45 <zomg> The generator does sorta work, but the performance is pretty shit =)
11:15:09 <Fernandos> zomg: I should sell you over xD and cash the headhunter provision *joking*
11:15:13 <zomg> haha
11:15:20 <zomg> Facebook already tried to recruit me once
11:15:29 <Fernandos> how did they fail?
11:15:30 <zomg> but I wasn't (and still aren't) interested in moving to the US
11:15:49 <Fernandos> haha okay, got it, that was a country fail
11:16:19 <dwcook> Kind of interesting how many of these web service companies still require you to be in a specific geographical location
11:16:32 <zomg> dwcook: yeah
11:16:39 <EvanR2> working remotely is hard
11:16:42 <hpc> it's for legal reasons
11:16:44 <EvanR2> hiring remotely is hard
11:16:48 <zomg> There are some companies who've told me they'd hire me on the spot if I just moved to their location
11:16:51 <hpc> oh, hiring
11:16:52 <zomg> but I'm not interested in moving
11:17:05 <Fernandos> dwcook: simple reason, you're either working remotely, or you chit-chat together, but not both
11:17:11 <hpc> web service companies sometimes require /customers/ to be in a geographic location too
11:17:36 <Fernandos> zomg: Which country are you living in? Why is it better there?
11:18:17 <zomg> Fernandos: Finland.. because everything really. Only thing that I don't like about being here is that in winter it's cold
11:18:20 <zomg> lol
11:18:52 <Fernandos> zomg: I guess the climate-change will be welcomed by you then :D
11:19:03 <zomg> haha, possibly =)
11:19:05 <Fernandos> zomg: unless it doesn't drawn you
11:19:10 <Fernandos> :P
11:20:37 <f-a> functional greetings, people. Tomorrow I will receive a new laptop. I planned to install cabal and before gettina any packate, modifying config file with 'library-profiling: True' and 'documentation: True'. Are there any drawbacks to these choices?
11:20:39 <Fernandos> I have a skewed impression of Finland. Thinking that more than 80% of finland is working as a developer, engineer or other higher than average job. Is there any truth to it?
11:20:55 <zomg> haha nah :P
11:21:04 <dcoutts_> f-a: just that building takes longer
11:21:26 <zomg> out of the people I went to school with and currently know what they do, I don't think there's almost any engineers or people working in software
11:21:27 <dcoutts_> f-a: build using -j2 or however many cores you have
11:21:36 <grady_player> everyone in finland is a computer programmer or rally car driver
11:21:47 <f-a> dcoutts_: awesome. I was unamused when I could not profile a little think I made because I forgot to set that flag in the past
11:21:49 <zomg> grady_player: or F1
11:21:51 <zomg> haha
11:21:54 <Fernandos> grady_player: hahah linus converted them
11:21:57 <hpc> most are all three
11:22:12 <grady_player> sure, kimi is a Fin right?
11:22:16 <zomg> yep
11:25:22 <Fernandos> how do I install all haskell packages (how large is it?)?
11:26:03 <hpc> Fernandos: you probably can't
11:26:21 <dwcook> Fernandos, it would probably take days on compilation alone
11:26:38 <Fernandos> hpc: hmm ok, nvm then. what flags should I set ot install stuff in to ~/.bin etc. ?
11:27:05 <hpc> you'll want to add ~/.cabal/bin to your path for binary stuff
11:27:08 <Fernandos> dwcook: whew.. ok.. I definitely underestimated the size of the haskell pacakge library
11:27:14 <dwcook> Or weeks even
11:27:15 <hpc> libraries just work, usually
11:27:21 <Fernandos> hpc: done
11:27:45 <hpc> cabal can smell fear, so be prepared for things to not work ;)
11:28:57 <Fernandos> hpc: just --user would default to the right flags for installation in $HOME right?
11:29:17 <hpc> nothing at all and it assumes user install
11:29:26 <hpc> (with a default cabal config)
11:29:57 <hpc> there's probably someone else here who can explain it better
11:31:42 <haasn> piezoid: the reason your program didn't work was a GHC bug
11:31:45 <haasn> It's already been fixed in HEAD
11:32:03 <haasn> there's a much simpler way to reproduce it in 7.6.x: foo :: (f a ~ f b) => p f -> a -> b; foo _ x = x
11:32:24 <haasn> GHC can't infer (f a ~ f b) :- (a ~ b)
11:32:43 <b_jonas> haasn: how's f declared?
11:32:52 <haasn> b_jonas: f is a variable
11:33:07 <dwcook> haasn, I thought a ~ b meant a unifies with b? And in that case, why not just use a single type variable?
11:33:09 <b_jonas> then it shouldn't infer that I think
11:34:02 <haasn> dwcook: it's just a minimal example for purposes of triggering the bug. It arose in practice with some GADT stuff
11:34:24 <dwcook> haasn, I mean, I don't understand why that constraint syntax is present at all
11:34:37 <c_wraith> b_jonas: no, that inference is correct.  f is a type constructor. if f a ~ f b, then a ~ b
11:34:46 <Fuco> what is the part after | here: class Monad m => MonadError e m | m -> e where
11:34:48 <haasn> b_jonas: it should, f can't be a type family here
11:34:55 <haasn> and non-type families are injective
11:34:55 <hpc> f isn't a type constructor, it's a type variable
11:34:59 <c_wraith> Fuco: functional dependency
11:35:04 <piezoid> haasn: thank you, I'll wait for 7.8 :)
11:35:08 <Fuco> c_wraith: which means?
11:35:12 <b_jonas> c_wraith: but haasn said it's a type variable, not a tycon
11:35:28 <c_wraith> Fuco: that the type e is specified by the type m
11:35:45 <c_wraith> Fuco: that is, in some way or another, the type m contains enough information to construct the type e
11:35:53 <haasn> http://lpaste.net/99385 another example of the same bug involving GADTs
11:35:56 <haasn> and no silly constraints :)
11:36:40 <c_wraith> Fuco: it tells the compiler that whenever it knows m, e is not an ambiguous type variable.
11:36:47 <dwcook> haasn, sorry, I was unclear: Why would you ever need to specify a ~ constraint?
11:36:56 <Fuco> c_wraith: right, sort of makes sense
11:37:28 <c_wraith> Fuco: also, it makes it a compile error to have multiple instances with the same m and different e types
11:37:31 <hpc> dwcook: you generally don't; they come into scope when you match on a GADT and it helps to have some way of talking about them
11:37:49 <dwcook> Ahh.
11:38:07 <dwcook> So, in essence, it mainly exists for the sake of type inference?
11:38:10 <hpc> (the notion of type equality is also useful in type checking, so they appear in a few other places as well)
11:38:28 <haasn> dwcook: I understand; a simple example would be involving type families I think
11:38:29 <dwcook> s/inference/checking/
11:38:40 <haasn> dwcook: forall x. (Family x ~ y) => ...
11:39:02 <haasn> You can't do that by just “reusing the same variable”
11:39:10 * hackagebot fpnla 0.1 - A library for NLA operations  http://hackage.haskell.org/package/fpnla-0.1 (mblanco)
11:39:14 <dwcook> I'm not that familiar with type families, I guess I'll go read about that
11:39:40 <c_wraith> dwcook: a type family is more or less a function from a type to a type.
11:39:44 <Fernandos> do people implement crypto algorithms more often in C or Haskell? (currently I have the impression it's C, but I'm not sure)
11:39:47 <haasn> dwcook: there's another use case: class instances
11:39:54 <dwcook> Oh, okay. I think I know what those are then.
11:39:58 <c_wraith> Fernandos: C is much more common.
11:39:59 <haasn> dwcook: there's a difference between  instance (a ~ b) => Class (X a b)
11:40:01 <nadirs> Considering foldl and foldr: what are some simple functions that can show clearly the different result whether you pass them to foldl or foldr (given that you "flip" the function accordingly)?
11:40:02 <haasn> and instance Class (X a a)
11:40:17 <Fernandos> c_wraith: that's only because of performance reasons, or does it have other reasons?
11:40:36 <dwcook> haasn, does that matter when you don't have overlapping instances?
11:40:50 <x77686d> nadirs: (++) is one example
11:41:07 <c_wraith> Fernandos: performance, and the fact that many languages can bind to C libraries, so they're more compatible across multiple languages.  And more code is written in C than haskell in the first place
11:41:33 <nadirs> x77686d: but the result is the same, isn't it?
11:41:35 <c_wraith> x77686d: err.  (++) is associative.
11:41:53 <Fernandos> c_wraith: thanks :)
11:42:01 <x77686d> oops!
11:42:02 <c_wraith> nadirs: you need any non-associative function.  div or (/) will do
11:42:11 <Maior> Fernandos: normalising for relative populations or not?
11:42:39 <steven_is_false> Hi. I heard that associated type families have some advantages over multiparameter type classes and functional dependencies. Is it possible to convert this example http://pastebin.com/r0cb9X8S over to use type families?
11:42:39 <c_wraith> > (foldr (/) 1 &&& foldl (/) 1) [1..10]
11:42:40 <lambdabot>  (0.24609375,2.7557319223985894e-7)
11:42:57 <haasn> dwcook: yes; suppose you want to make an instance (a ~ b) => Monoid (a -> b) -- without overlapping anything. Ie, assume the current instance doesn't exist
11:43:33 <darthdeus> how can i do  :t liftM foo  in ghci and at the same time tell liftM to use a particular monad?
11:43:48 <nadirs> c_wraith: that's a nice example. I'd like a total function, since I'm working with automated tests, but I guess I can just prepend a non-zero condition
11:44:10 * hackagebot fpnla-examples 0.1 - Example implementations for FPNLA library  http://hackage.haskell.org/package/fpnla-examples-0.1 (mblanco)
11:44:14 <darthdeus> for example something like  :t (liftM :: IO) map ... but that doesn't work ofc
11:44:18 <c_wraith> nadirs: well, any non-associative function will do.  I just chose that one because it's the most obvious one from arithmetic
11:44:25 <Fernandos> Maior: interesting tangent, yes relatively. I don't think that it has a  difference.
11:44:43 <haasn> with that instance definition, “mempty undefined” type checks, but with the definition “instance Monoid (a -> a)” “mempty undefined” is ambiguous
11:46:00 <haasn> because in the latter case, GHC can't auto-select the instance based purely on the fact that it's a function; it has to know a ~ b before it can uniquely select the instance
11:46:11 <nadirs> c_wraith: thanks for the input :)
11:46:13 <c_wraith> steven_is_false: you would change the class definition to something like...  class Signal a where type Result a :: * ; poll :: a -> IO (Result a) ; ...
11:46:15 <haasn> In the former, the instance covers all functions (and the context is forced)
11:46:52 <steven_is_false> c_wraith: let me look at that
11:47:19 <twanvl> ?type (liftM :: (a -> b) -> IO a -> IO b) map
11:47:20 <lambdabot> IO (a -> b) -> IO ([a] -> [b])
11:47:47 <c_wraith> steven_is_false: and then the instance would be something like...  instance Signal (ConstSignal a) where type Result (ConstSignal a) = a ; ...
11:47:58 <Fernandos> any idea why compilation fails? http://hastebin.com/dapohaxura.hs
11:48:20 <dwcook> haasn, I'm not sure how that follows. There might be some information I'm missing.
11:48:39 <darthdeus> sweet :)
11:48:44 <steven_is_false> c_wraith: But then I can't do  position :: a -> Object (Signal (Integer, Integer))?
11:49:40 <c_wraith> steven_is_false: that's true..  The kinds don't allow you to specify something like that anymore.
11:50:09 <c_wraith> steven_is_false: well, they don't allow you to specify exactly that.  You can probably get close to it.  let me think a moment.
11:50:14 <Maior> Fernandos: I think it absolutely makes a difference
11:51:07 <steven_is_false> c_wraith: I think   position :: (Signal s, Result s ~ (Integer, Integer)) => a -> s might work for my needs
11:51:29 <c_wraith> steven_is_false: yeah.  That's what I was looking for - a use of a ~ constraint
11:54:15 <steven_is_false> c_wraith: Actually, I want something like   position :: a -> (forall s. (Signal s, Result s ~ (Integer, Integer)) => s -> b) -> b
11:54:29 <haasn> dwcook: not sure how else to explain it
11:54:41 <haasn> dwcook: GHC selects instances solely by looking at the instance head
11:54:56 <haasn> dwcook: so ghc sees the instances “Monoid (a -> a)” in one scenario, and “Monoid (a -> b)” in the other
11:55:08 <c_wraith> steven_is_false: well, if it works... that's how it looks.  It's up to you to decide if it's actually better.
11:55:09 <haasn> The former can only be selected for things that have type :: a -> a;  the latter can be selected for all functions
11:55:27 <steven_is_false> c_wraith: I'll think about it a bit. Thanks for the help.
11:56:29 <dwcook> haasn, but would you still be able to declare an instance for any function if it had an (a ~ b) constraint?
11:56:38 <jfischoff> I'm getting a .hp file that is cut off at the end
11:56:56 <jfischoff> I get an error like hp2ps: ... integer must follow identifier
11:57:04 <jfischoff> when I try to make a ps with it
11:57:18 <jfischoff> any suggestions for getting a clean dump?
11:57:28 <haasn> dwcook: sure (you could technically define a silly broken instance even without the constraint, too - which wouldn't affect instance resolution)
11:58:10 <dwcook> haasn, then what good does the (a ~ b) do?
11:59:12 <haasn> gives you access to the context (a ~ b) within the instance body; eg. letting you write “where mempty = id”. since mempty :: Monoid a => a, that becomes “mempty :: a -> b”, but thanks to the instance context that's “mempty :: (a ~ b) => a -> b” which is equal to “mempty :: a -> a” which id type-checks as
12:02:44 <dwcook> Okay, I think I see.
12:06:01 <Feuerbach> jfischoff: it happens when the program is killed. Was it the case?
12:06:38 <jfischoff> Feuerbach: the server was killed
12:06:45 <Feuerbach> right
12:06:57 <jfischoff> I'm pretty sure I've killed stuff before and it came out fine
12:07:11 <Feuerbach> it depends on how you kill it
12:07:24 <Feuerbach> e.g. on UNIX TERM is fine, KILL is probably not
12:07:47 <jfischoff> do you SIGTERM the signal?
12:07:52 <jfischoff> do you mean
12:07:52 <Feuerbach> yes
12:08:24 <jfischoff> I looked at the help for killall and it said it was using SIGTERM I'll double check
12:08:40 <jfischoff> FYI, there is some logic in the app for catching signals
12:08:47 <Feuerbach> so did you simply killall it? then I'm somewhat surprised
12:08:59 <yoeight> Hi there, I think I'm doing something wrong but having no clue. I got a lot of alloc in GHC.IO.Handle.FD while using Data.Text
12:09:06 <jfischoff> Maybe it is preventing the rts from cleaning up properly
12:09:13 <jfischoff> yeah just a killall
12:09:14 <yoeight> Here's the prof files
12:09:17 <yoeight> https://gist.github.com/YoEight/8773962
12:09:52 <yoeight> any lead on this please ?
12:10:16 <Feuerbach> jfischoff: also, you can try to cut a few lines in the end of the hp file (it has a text format, IIRC) until it starts to parse
12:10:33 <Feuerbach> but the file is probably truncated already, so you may not get the full picture
12:10:52 <yoeight> some info. I'm not reading any file on the FS
12:11:18 <steven_is_false> c_wraith: This almost works http://pastebin.com/061SzDM8 . I'm not sure how to fix it though.
12:11:44 <c_wraith> steven_is_false: could you include the errors?
12:12:20 <Feuerbach> yoeight: why does it bother you? It doesn't look like it's taking any significant time
12:13:04 <yoeight> the pourcentage bother me actually
12:13:22 <steven_is_false> c_wraith: alright http://pastebin.com/rh8LYmzT
12:13:38 <Feuerbach> yoeight: why?
12:13:42 <jfischoff> Feuerbach: I tried that, no luck, but maybe if I take more lines ...
12:14:04 <yoeight> Feuerbach:Don't know doesn't feel right, I guess ?
12:14:39 <yoeight> Feuerbach: 38% is pretty hight for what I'm doing
12:15:05 <yoeight> Feuerbach: Do you think I too suspicious ?
12:17:28 <Feuerbach> yoeight: I guess it would be fun to figure out what's actually going on there. But unless you have an actual problem of CPU usage or memory growth, there's nothing to worry about.
12:17:30 <spacekitteh> thorkilnaur: re: lpaste.net/99332 yeah, thanks, i figured it out :)
12:19:20 <yoeight> Feuerbach: not I'm aware of. I computing the edit distance of two Strings
12:19:38 <c_wraith> steven_is_false: I *think* that's an injectivity error of some sort, but you're beyond the point where I can understand what GHC is saying.
12:19:48 <yoeight> Feuerbach: Here's the code: https://github.com/YoEight/spellcheck/blob/master/lib/Data/Spellcheck/Distance.hs#L66
12:20:00 <steven_is_false> c_wraith: Well thanks for the help then.
12:20:32 <yoeight> Feuerbach: Suggestions are welcome of course :)
12:21:57 <Feuerbach> yoeight: and where's your 'main'?
12:22:08 <Maior> sooo, threadDelay takes us, not ms
12:22:13 <Maior> suddenly it all makes sense
12:22:33 <yoeight> Feuerbach: main = print $ editDistance False "sitting" "kitten"
12:22:34 <byorgey> hehehe
12:23:34 <benzrf> hey
12:23:37 <benzrf> I tried to install djinn and I got:
12:23:38 <benzrf> gcc: error: unrecognized command line option ‘-Wl’
12:23:46 <benzrf> as a result of
12:23:47 <benzrf> Linking dist/build/djinn/djinn ...
12:23:56 <Feuerbach> yoeight: is that all? for that kind of program even a small amount of allocation may be a big percent
12:24:52 <Feuerbach> indeed, your total alloc is just 90k
12:26:32 <yoeight> Feuerbach: Yes, it's my entire main function
12:27:21 <Ralith> benzrf: are you on osx
12:27:42 <benzrf> ubuntu
12:27:43 <yoeight> Feuerbach:Alright, thanks for your tip
12:28:08 <benzrf> Ralith: http://bpaste.net/show/174886/
12:28:16 <yoeight> Feuerbach: I expected something like 90% of efficency
12:28:44 <yoeight> Feuerbach:Even it that small prog
12:28:45 <Ralith> weird
12:28:59 <yoeight> Feuerbach:Thanks again
12:30:00 <Feuerbach> yoeight: just try a bigger benchmark, it will give you more meaningful numbers
12:31:26 <yoeight> Feuerbach:Alright, I finish to implement my program then
12:31:50 <dyn> hi.. I'd like to ask about the new haskell book, Beginning Haskell
12:32:05 <benzrf> sup dyn
12:32:06 <dyn> anyone had a chance to read it already, seen a review about it, etc?
12:32:09 <benzrf> i have not
12:32:50 <countoren> hello any help with this???? http://lpaste.net/99387
12:34:14 <benzrf> > from _Left $ 3
12:34:15 <lambdabot>  Could not deduce (GHC.Num.Num
12:34:15 <lambdabot>                      (p (Data.Either.Either b c0) (f (Data.Either.Either a c0...
12:34:15 <lambdabot>    arising from the ambiguity check for `e_13'
12:34:15 <lambdabot>  from the context (GHC.Base.Functor f,
12:34:15 <lambdabot>                    GHC.Num.Num
12:34:17 <benzrf> oh wait
12:34:23 <benzrf> > preview (from _Left) 3
12:34:24 <lambdabot>  No instance for (Data.Profunctor.Choice
12:34:24 <lambdabot>                     (Control.Lens.Internal.Iso.Exchange a0 a0))
12:34:24 <lambdabot>    arising from a use of `e_13'
12:34:24 <lambdabot>  Possible fix:
12:34:25 <lambdabot>    add an instance declaration for
12:34:26 <benzrf> > view (from _Left) 3
12:34:27 <lambdabot>  No instance for (Data.Profunctor.Choice
12:34:28 <benzrf> bah
12:34:29 <lambdabot>                     (Control.Lens.Internal.Iso.Exchange a0 a0))
12:34:31 <lambdabot>    arising from a use of `e_13'
12:34:33 <lambdabot>  Possible fix:
12:34:35 <lambdabot>    add an instance declaration for
12:34:43 <shachaf> Please experiment with lambdabot in /msg.
12:34:48 <benzrf> sorry wasnt thinking o_o
12:34:57 <benzrf> what's from for prisms?
12:35:11 <benzrf> also, is there an operator version of hash?
12:35:13 <benzrf> *has
12:38:55 <darthdeus> is there a pattern that encapsulates doing N number of "iterations" while passing around the state from previous to the next? currently i'm doing this via `map f (replicate n 1)`, but it feels a bit hacky
12:39:12 <darthdeus> i mean for carrying the state i'd use fold, but you get the idea
12:39:19 <dyn> I wish I could understand how a book's paperback version can be sold for $35 and the kindle edition is $43 (looking at Beginning Haskell)
12:39:39 <zomg> dyn: because publishers don't understand ebooks :P
12:39:57 <zomg> oh sorry, the correct answer is because bits are expensive to chop down and manufacture
12:40:07 <dyn> zomg: that just screams 'kill those trees'
12:40:13 <dyn> yeah, I guess so
12:40:37 <darthdeus> yeah every time i see that i wanna cry for how stupid the world is
12:40:41 <byorgey> darthdeus: if you actually have a computation in the State monad, you can use  'replicateM n'
12:41:02 <edwardk> > view (re _Left) 3
12:41:04 <lambdabot>  Left 3
12:41:25 <edwardk> 'from' only works with a full Iso
12:41:29 <darthdeus> byorgey: ha thanks! i see that there's also generate and generateM :)
12:41:35 <edwardk> because you can from . from an get back where you started
12:41:42 <edwardk> but re lets you turn a prism around into a getter
12:41:52 <byorgey> darthdeus: I've never heard of generate and generateM, what do they do?
12:42:06 <edwardk> if we went with pure profunctor lenses re and from would unify into one thing, but then nobody could use lenses without depending on the package
12:42:18 <edwardk> and traversals and what have you would be harder to write
12:42:19 <darthdeus> > :t generate
12:42:20 <lambdabot>  <hint>:1:1: parse error on input `:'
12:42:30 <byorgey> :t generate
12:42:31 <lambdabot> Not in scope: `generate'
12:42:33 <benzrf> profunctors man
12:42:42 <darthdeus> :t Data.Vector.generate
12:42:43 <lambdabot> Int -> (Int -> a) -> Data.Vector.Vector a
12:42:48 <darthdeus> O(n) Construct a vector of the given length by applying the function to each index
12:42:52 <countoren> hello any help with this???? http://lpaste.net/99387
12:43:27 <byorgey> darthdeus: oh, from Data.Vector
12:43:37 <byorgey> cool
12:44:03 <darthdeus> hmm replicateM is in Control.Monad too, cool
12:44:10 <derekv> as a build system, seems like it'd be nice if cabal would detect nessisary dependant steps (configure, build, install, test ..) and (re)run them as nessisary
12:44:18 * hackagebot atomic-primops 0.5.0.2 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.5.0.2 (RyanNewton)
12:45:06 <byorgey> derekv: yes, the HEAD version of cabal does a much better job of that
12:45:09 <benzrf> hmm
12:45:17 <copumpkin> (n : Nat) -> (Fin n -> a) -> Vector n a
12:45:19 * copumpkin coughs
12:45:40 <benzrf> @djin ((a, b) -> c) -> (a, b) -> (a, c)
12:45:40 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
12:45:44 <benzrf> @djinn ((a, b) -> c) -> (a, b) -> (a, c)
12:45:44 <lambdabot> f a (b, c) = (b, a (b, c))
12:45:56 <benzrf> @hoogle ((a, b) -> c) -> (a, b) -> (a, c)
12:45:56 <lambdabot> No results found
12:46:28 <derekv> byorgey: ok cool! I was going to ask, if there was no paticular reason why it didn't.. maybe I could contribute
12:46:34 <Maior> so, er, String->String that strips leading/following whitespace?
12:46:50 <copumpkin> :t \f -> fst &&& uncurry f
12:46:50 <lambdabot> (a -> b -> c) -> (a, b) -> (a, c)
12:46:53 <Tekmo> Maior: There is a `Text` version of that
12:46:55 <byorgey> derekv: there are lots of ways you can contribute to cabal
12:46:56 <copumpkin> :t \f -> fst &&& curry f
12:46:57 <lambdabot> (((a, b), b1) -> c) -> (a, b) -> (a, b1 -> c)
12:47:00 <copumpkin> grr
12:47:06 <steven807> Hey folks, a question about "Show": is it okay to show "pretty", simplified versions of things, or in well-written Haskell, should (read . show) == id?
12:47:15 <benzrf> steven807: i think that is the idea of Shw
12:47:17 <benzrf> *Show
12:47:25 <benzrf> steven807: if you are familiar with Python, show is more like repr than str
12:47:26 <Tekmo> steven807: The rule of thumb is that you should use the derived `Show` instance
12:47:29 <copumpkin> :t \f -> fst &&& f
12:47:30 <lambdabot> ((a, b) -> c') -> (a, b) -> (a, c')
12:47:34 <benzrf> steven807: or in ruby, inspect instead of to_s
12:47:42 <benzrf> anybody have a more elegant way of writing:
12:47:42 <benzrf> createEnv = Map.fromList . map converter where converter (name, func) = (name, HaskellFunc name func)
12:47:49 <copumpkin> :t (fst &&&)
12:47:50 <lambdabot> ((a, b) -> c') -> (a, b) -> (a, c')
12:47:51 <derekv> byorgey: browsing the code now
12:47:53 <copumpkin> benzrf: ^
12:48:06 <benzrf> :t (&&&)
12:48:07 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:48:18 <Maior> Tekmo: mmh ok cheers
12:48:22 <steven807> That's what I figured, but, e.g. Data.Text doesn't show as "pack ...", it just shows the string
12:48:27 <darthdeus> byorgey: replicateM works much better than what i had :D https://gist.github.com/8774659
12:48:53 <Tekmo> steven807: In that case it's pretending as if you have the "OverloadedStrings" extension enabled
12:49:20 <steven807> I'm happy to do either, but I feel like I've seen multiple relatively standard libraries where they don't follow that convention.  But okay, that's why i asked -- so far everyone here has said that indeed, show . read = id.  So I'll define a separate "pretty" class or something.  Thanks!
12:53:05 <benzrf> :t (&&&)
12:53:06 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
12:53:27 <benzrf> :t (&&&) `asAppliedTo` (undefined :: a -> b)
12:53:28 <lambdabot> (a -> b) -> (a -> c') -> a -> (b, c')
12:54:10 <benzrf> ah ok
12:55:08 <benzrf> > ((+1), (+2)) <*> (0, 0)
12:55:09 <lambdabot>  No instance for (GHC.Num.Num (a0 -> a0))
12:55:09 <lambdabot>    arising from a use of `e_11200'
12:55:09 <lambdabot>  Possible fix:
12:55:09 <lambdabot>    add an instance declaration for (GHC.Num.Num (a0 -> a0))No instance for (D...
12:55:09 <lambdabot>    arising from a use of `M150043247778679168413303.show_M1500432477786791684...
12:55:25 <benzrf> > ((++"one"), (++"two")) <*> ("thing ", "thing ")
12:55:26 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
12:55:26 <lambdabot>              with actual type `[GHC.Types.Char]'
12:56:01 <benzrf> what's wrong with that?
12:56:08 <benzrf> oh wait...
12:56:09 <benzrf> derp
13:00:19 <haasn> > (True, (++"two")) <*> (False, "thing ")
13:00:20 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
13:00:20 <lambdabot>    arising from a use of `Control.Applicative.<*>'
13:00:20 <lambdabot>  Possible fix:
13:00:20 <lambdabot>    add an instance declaration for (Data.Monoid.Monoid GHC.Types.Bool)
13:00:28 <haasn> ah
13:01:25 <benzrf> @pl \(a, f) -> f a
13:01:26 <lambdabot> uncurry (flip id)
13:06:05 <joelteon> @pl \(a, f) -> ((a,), f)
13:06:06 <lambdabot> (line 1, column 15):
13:06:06 <lambdabot> unexpected ","
13:06:06 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
13:06:11 <joelteon> @pl \(a, f) -> ((,) a, f)
13:06:11 <lambdabot> first (,)
13:06:37 <benzrf> :t first
13:06:38 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
13:09:21 <joelteon> @pl \(a,f) -> (a,f,f a)
13:09:22 <lambdabot> uncurry (liftM2 ap (,,) (flip id))
13:11:28 <dhrosa> flip id?...
13:12:18 <haasn> :t uncurry (&)
13:12:19 <lambdabot> (a, a -> c) -> c
13:15:50 <pranz> :t flip id
13:15:50 <lambdabot> b -> (b -> c) -> c
13:16:12 <pranz> dhrosa: see, consider a function f :: (b -> c)
13:17:00 <dhrosa> b `f` c = flip id f?
13:17:00 <pranz> dhrosa: id on a value of that type would infer id's type to be (b -> c) -> b -> c
13:17:11 <dhrosa> well not quite
13:17:20 <dhrosa> b `f` c = flip id f b c?
13:17:23 <pranz> dhrosa: flip that, and you get b -> (b -> c) -> c
13:17:31 <pranz> in other words, function application
13:18:00 <pranz> dhrosa: yeah, because flip id = ($)
13:18:09 <pranz> ($) f x = f x
13:19:41 <benzrf> @hoogle replace
13:19:41 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
13:19:42 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
13:19:42 <lambdabot> Data.Text.Encoding.Error replace :: b -> OnError a b
13:20:05 <mzarella> When would you use :module +Data.List and when would you use import Data.List, is there a difference?
13:20:20 <benzrf> > replace "foo" "bar" "this is foo ok"
13:20:21 <lambdabot>  Not in scope: `replace'
13:20:21 <lambdabot>  Perhaps you meant `replay' (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
13:20:29 <benzrf> > Data.Text.replace "foo" "bar" "this is foo ok"
13:20:30 <lambdabot>  Not in scope: `Data.Text.replace'
13:20:32 <benzrf> pfft
13:20:48 <pranz> >Data.Text.replace "foo" "bar" "this is foo ok"
13:20:54 <pranz> > Data.Text.replace "foo" "bar" "this is foo ok"
13:20:54 <lambdabot>  Not in scope: `Data.Text.replace'
13:20:59 <pranz> eh
13:24:22 * hackagebot inserts 0.1.0.0 - Stupid simple bytestring templates.  http://hackage.haskell.org/package/inserts-0.1.0.0 (JosephAbrahamson)
13:24:24 * hackagebot inserts 0.1.0.1 - Stupid simple bytestring templates.  http://hackage.haskell.org/package/inserts-0.1.0.1 (JosephAbrahamson)
13:25:04 <adek> I am trying to make any work with monads. I want something likt (a -> m Bool) -> [a] -> m Bool. Is there any way to transform any to work like that?
13:26:28 <benzrf> :t any
13:26:29 <lambdabot> (a -> Bool) -> [a] -> Bool
13:27:02 <pavonia> @hackage monad-loops  -- adek
13:27:02 <lambdabot> http://hackage.haskell.org/package/monad-loops  -- adek
13:27:12 <benzrf> adek: well, there is sequence and mapM
13:27:17 <benzrf> :t mapM
13:27:17 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:27:28 <benzrf> given b as boo
13:27:29 <benzrf> l
13:27:53 <benzrf> hmm
13:28:04 <benzrf> :t fmap any . mapM
13:28:05 <lambdabot>     Couldn't match type `[b0]' with `Bool'
13:28:05 <lambdabot>     Expected type: (a1 -> a0 -> b0) -> [a1] -> a0 -> Bool
13:28:05 <lambdabot>       Actual type: (a1 -> a0 -> b0) -> [a1] -> a0 -> [b0]
13:28:19 <benzrf> buh
13:28:24 <merijn> benzrf: Or just monad-loops
13:28:27 <benzrf> ;p
13:28:29 <merijn> benzrf: That already has anyM
13:28:37 <benzrf> i wanna figure this out tho
13:29:04 <haasn> Can I access a copy of the GHC API's documentation anywhere online?
13:29:07 <merijn> :t \f -> fmap any . mapM f
13:29:07 <lambdabot>     Couldn't match type `[b0]' with `a0 -> Bool'
13:29:08 <lambdabot>     Expected type: [a0] -> f0 (a0 -> Bool)
13:29:08 <lambdabot>       Actual type: [a0] -> f0 [b0]
13:29:14 <benzrf> :t fmap and . mapM
13:29:14 <lambdabot>     Couldn't match type `[b0]' with `Bool'
13:29:15 <lambdabot>     Expected type: (a0 -> [b0]) -> [a0] -> [Bool]
13:29:16 <lambdabot>       Actual type: (a0 -> [b0]) -> [a0] -> [[b0]]
13:29:17 <benzrf> hmm
13:29:22 <benzrf> oh wait that's or anyway
13:29:28 <merijn> benzrf: You're missing the function argument to "mapM"
13:30:01 <benzrf> point-free
13:30:27 <benzrf> :t mapM
13:30:28 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:30:30 <benzrf> :t fmap or
13:30:31 <lambdabot> Functor f => f [Bool] -> f Bool
13:30:38 <piezoid> :t any
13:30:39 <lambdabot> (a -> Bool) -> [a] -> Bool
13:31:24 <benzrf> :t fmap or. (mapM :: (a -> m Bool) -> [a] -> m [Bool])
13:31:24 <lambdabot>     No instance for (Monad m) arising from a use of `mapM'
13:31:25 <lambdabot>     Possible fix:
13:31:25 <lambdabot>       add (Monad m) to the context of
13:31:33 <benzrf> :t fmap or . (mapM :: Monad m => (a -> m Bool) -> [a] -> m [Bool])
13:31:34 <lambdabot>     Couldn't match type `[Bool]' with `Bool'
13:31:34 <lambdabot>     Expected type: (a0 -> [Bool]) -> [a0] -> [Bool]
13:31:34 <lambdabot>       Actual type: (a0 -> [Bool]) -> [a0] -> [[Bool]]
13:31:37 <benzrf> bah
13:31:48 <Tekmo> benzrf: What are you trying to do?
13:31:53 <piezoid> :t \p -> fmap (foldr (||) False) . mapM p
13:31:54 <lambdabot> (Monad f, Functor f) => (a -> f Bool) -> [a] -> f Bool
13:32:05 <benzrf> :|
13:32:14 <benzrf> ohhh i was thinking monad was a superclass of functor
13:32:17 <benzrf> >_<
13:32:26 <benzrf> although im not sure that was the prob...
13:32:33 <benzrf> :t (mapM :: Monad m => (a -> m Bool) -> [a] -> m [Bool])
13:32:33 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [Bool]
13:32:48 <benzrf> :t fmap or . (mapM :: (Functor f, Monad m) => (a -> m Bool) -> [a] -> m [Bool])
13:32:49 <lambdabot>     Couldn't match type `[Bool]' with `Bool'
13:32:49 <lambdabot>     Expected type: (a0 -> [Bool]) -> [a0] -> [Bool]
13:32:49 <lambdabot>       Actual type: (a0 -> [Bool]) -> [a0] -> [[Bool]]
13:32:52 <benzrf> wat?
13:32:59 <adek> :t liftM or . mapM
13:32:59 <lambdabot>     Couldn't match type `[b0]' with `Bool'
13:33:00 <lambdabot>     Expected type: (a0 -> [b0]) -> [a0] -> [Bool]
13:33:00 <lambdabot>       Actual type: (a0 -> [b0]) -> [a0] -> [[b0]]
13:33:01 <benzrf> :t fmap or . (mapM :: (Functor m, Monad m) => (a -> m Bool) -> [a] -> m [Bool])
13:33:02 <lambdabot>     Couldn't match type `[Bool]' with `Bool'
13:33:03 <lambdabot>     Expected type: (a0 -> [Bool]) -> [a0] -> [Bool]
13:33:03 <lambdabot>       Actual type: (a0 -> [Bool]) -> [a0] -> [[Bool]]
13:33:17 <benzrf> :t fmap
13:33:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:33:21 <benzrf> :t mapM
13:33:22 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:33:28 <Tekmo> adek: Do you want your function to behave like `any` or `all`?
13:33:34 <adek> any
13:33:38 <frx> :t \f -> liftM or . mapM f
13:33:38 <benzrf> :t (mapM :: (Functor m, Monad m) => (a -> m Bool) -> [a] -> m [Bool])
13:33:39 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m Bool
13:33:39 <lambdabot> (Monad m, Functor m) => (a -> m Bool) -> [a] -> m [Bool]
13:33:47 <benzrf> that works...
13:33:59 <benzrf> so why can't I compose it with or?!
13:34:00 <adek> Oh, I forgot f in my last try. COol!
13:34:11 <benzrf> oh fuck
13:34:15 <Tekmo> yourFunction f as = Pipes.Prelude any (each as >-> Pipes.Prelude.mapM f)
13:34:16 <benzrf> I forgot args don't work right
13:34:18 * benzrf headdesks
13:34:38 <benzrf> thx frx
13:34:56 <Tekmo> adek: The `pipes`-based solution will not leak memory.  The `mapM` solution will
13:35:21 <frx> welcome. I did have a couple of fails in lambdabot :)
13:35:24 <adek> Tekmo: so I should use the one from monad-loops?
13:35:43 <Tekmo> adek: Let me check how the one from `monad-loops` works
13:37:51 <benzrf> is there a has operator in lens
13:42:11 <dseit> how do I combine two predicates? something like this: andp, orp :: (a - Bool) -> (a -> Bool) -> a -> Bool
13:42:14 <adek> Tekmo: also I will be thankful if you could explain me why mapM will leak...
13:42:26 <benzrf> dseit: liftA2 / liftM2
13:42:32 <Tekmo> adek: mapM is a Haskell anti-pattern
13:42:41 <Tekmo> adek: The reason why is that it does not return any results until it processes the entire list
13:42:55 <Tekmo> adek: This means that it has to store all results in memory until the computation completes
13:42:59 <benzrf> > (liftA2 (&&) (>10) (<100)) 30 -- dseit
13:43:00 <lambdabot>  True
13:43:04 <benzrf> > (liftA2 (&&) (>10) (<100)) 102 -- dseit
13:43:05 <lambdabot>  False
13:43:12 <dseit> nice
13:43:17 <adek> Oh... so this is also inefficient
13:43:19 <benzrf> dseit: do you know your lifts?
13:43:29 <Tekmo> dseit: You can use the `foldl` library to combine multiple folds into a single pass
13:43:44 <Tekmo> adek: Yes
13:43:49 <Tekmo> adek: There is another difference, too
13:43:55 <dseit> benzrf yes, but I did not figure that one out
13:44:08 <Tekmo> adek: `anyM` and the `pipes` solution are lazy, meaning that they will stop processing results when they find a `True`
13:44:12 <benzrf> np, it's not super obvious :)
13:44:16 <benzrf> i had it told to me as well
13:44:20 <Tekmo> adek: The `mapM` solution will process the list, even after it finds a `True`
13:44:25 * hackagebot pipes-rt 0.4.2 - A few pipes to control the timing of yields  http://hackage.haskell.org/package/pipes-rt-0.4.2 (imalsogreg)
13:44:30 <adek> Tekmo: yeah, that is the way I expected that to work...
13:44:35 <dseit> we are using a function Functor there?
13:44:40 <benzrf> dseit: applicative
13:44:51 <adek> Tekmo: but since mapM is not lazy then it breaks everything
13:44:55 <Tekmo> adek: Right
13:45:01 <Tekmo> adek: Note that `mapM_` is an okay function to use
13:45:05 <benzrf> btw, if you see yourself doing 'do {a <- ma; b <- ba; c <- ca; return $ f a b c}'
13:45:06 <adek> Tekmo: Cool! Thanks!
13:45:09 <Tekmo> adek: But `mapM` without the underscore is the one you should avoid
13:45:15 <dseit> yeah function applicative is a bit of a mystery to me still.
13:45:18 <Tekmo> adek: Same thing for `sequence` and `replicateM`
13:45:19 <benzrf> turn that into 'f <$> ma <*> mb <*> mc'
13:45:23 <Tekmo> adek: Only use the underscore versions
13:45:38 <benzrf> dseit: applicatives are mainly for mapping across multiple functor values
13:45:44 <benzrf> as i just pointed out :u
13:46:04 <adek> Tekmo: that makes a lot of sense
13:46:16 <benzrf> dseit: you only need monads if you want to change what to map next based on the 'result' of a previous monad
13:46:33 <benzrf> dseit: if you just want to apply a function across multiple monads, you really want applicatives
13:47:17 <silasm_> dseit: function applicative is neat because <$> is K and <*> is S, iirc
13:48:01 <shachaf> <$> is not K. You're probably thinking of pure.
13:48:05 <dseit> liftA2 (+) maybe1 maybe2  makes sense to me, but I am still trying to grook how your code works
13:48:11 <silasm_> shachaf: right, my bad
13:48:28 <shachaf> When you say "multiple monads" you probably don't mean that -- there's only one monad involved here.
13:48:49 <amalloy> wait, why is mapM bad? i can't figure it out from the scrollback
13:48:50 <benzrf> I mean multiple monadic values
13:48:52 <benzrf> sorry
13:48:55 <benzrf> ;p
13:49:07 <benzrf> i tend to call monadic values monads <_<
13:49:12 <jmcarthur> silasm_: pure/return is K. <$> is B. join is W. <*> is S.
13:49:25 * hackagebot doctest 0.9.10.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.10.1 (SimonHengel)
13:49:28 <shachaf> amalloy: It isn't bad. It's good for specific things.
13:49:43 <shachaf> Quite a few things.
13:49:49 <haasn> of course, <$> is S . K
13:51:24 <haasn> I wonder: When comparing “main = mapM f xs” vs “main = mapM_ f xs”, how much of the former will GHC optimize away?
13:53:20 <shachaf> haasn: Do you mean whether it'll figure out that it doesn't need to keep the list of b values because the result of main is being ignored?
13:53:59 <haasn> shachaf: yes
13:54:45 <pranz> haasn: I don't think the former will typecheck
13:54:57 <shachaf> haasn: I really doubt it.
13:55:16 <shachaf> pranz: main can be of any IO type, not just IO ().
13:55:28 <pranz> schell: oh
13:55:43 <haasn> Looks like mapM's cmm output is a bit larger, at any rate
13:56:41 <shachaf> Well, it's not getting inlined, is it?
13:57:01 <shachaf> I doubt just comparing the cmm output for Main.hs will tell you much.
13:58:14 <haasn> Any better ideas on how to find out?
13:59:23 <benzrf> @pl \f g a b = f (g a b)
13:59:23 <lambdabot> (line 1, column 10):
13:59:23 <lambdabot> unexpected "="
13:59:23 <lambdabot> expecting pattern or "->"
13:59:28 <benzrf> @pl \f g a b -> f (g a b)
13:59:28 <lambdabot> (.) . (.)
13:59:29 <shachaf> Well, if it's not getting inlined, that probably means you can look at that mapM code on its own and see what it allocates and so on.
13:59:31 <benzrf> o_o
13:59:36 <benzrf> :t \f g a b -> f (g a b)
13:59:37 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
13:59:45 <benzrf> how i do
14:00:22 <benzrf> @hoogle (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
14:00:22 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
14:00:23 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
14:00:23 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:00:24 <benzrf> ugh
14:00:38 <benzrf> oh hmm
14:00:54 <benzrf> @src on
14:00:54 <lambdabot> (*) `on` f = \x y -> f x * f y
14:00:59 <benzrf> oh
14:01:12 <benzrf> w/e
14:01:35 <benzrf> there should really be higher-arity .
14:02:26 <kristof> I still think Haskell's missing variadic arity, currying be damned
14:02:55 <tac_> kristof: You know about the trick with typeclasses and variadic functions, right?
14:03:04 <hpc> i would not mind variadic stuff in haskell if it is exploited for benefits the way perl's has been
14:03:07 <kristof> tac_: nay, I ne'er heard o' that
14:03:25 <tac_> kristof: http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
14:04:15 <tac_> kristof: It's one of those horrifying things that kinda works and you don't quite know how to feel about it
14:04:24 <hpc> (though not the particular 'benefits' perl has taken)
14:04:45 <kristof> tac_: It makes sense if you don't think about it
14:04:50 <tac_> It does
14:04:51 <kristof> tac_: Does this only work with IO?
14:04:53 <ion> I feel http://hackage.haskell.org/package/th-printf-0.2.0.1/docs/Text-Printf-TH.html is better.
14:04:59 <tac_> No. It's totally pure
14:05:05 <hpc> i know how i feel about printf
14:05:09 <kristof> Well I meant IO ()
14:05:24 <hpc> it's the one reasonable example of variadic functions that is used as precedent for the very worst of variadic functions
14:05:40 <hpc> it takes a string and then one or more parameters
14:05:54 <hpc> then produces either a String of the result, or an action that prints the result string
14:05:59 <kristof> To be honest, I can do without variadic functions
14:06:07 <kristof> I use currying to get away from using optional args
14:06:16 <kristof> but the one thing I will never accept is the lack of named arguments :'(
14:06:19 <tac_> It strikes me that the PrintfType typeclass has a non-strictly-positive element to it
14:06:57 <tac_> kristof: The lack of named arguments is not an intrinsic limitation. It's just something Haskell hasn't decided to do (yet?)
14:07:13 <hpc> kristof: just use implicit parameters!
14:07:15 <tac_> As long as everything gets a default value, you could have named params without a problem
14:07:40 <merijn> implicit parameters are pretty much the same as named arguments
14:07:46 <bitemyapp> has anyone looked at the Mio paper?
14:07:52 <bitemyapp> the benchmark numbers are *nuts*
14:07:57 <kristof> hpc: I think they cover different domains. Also, I would be happier if Oleg's "Delimited Dynamic Binding" were part of standard Haskell
14:08:02 <hpc> merijn: except the part where
14:08:12 <merijn> bitemyapp: Yes and yes
14:08:31 <bitemyapp> merijn: relevant to my interests because I do I/O heavy backend stuff.
14:08:33 <hpc> > let f x = y; y = ?a + 1 in (let ?a = 5 in f 17)
14:08:34 <lambdabot>  6
14:08:39 <bitemyapp> can't wait for GHC 7.8 :)
14:08:48 <hpc> merijn: where implicit params fall through inner function calls
14:08:57 <hpc> ("function" calls)
14:09:08 <kristof> tac_: Negatory. I'd rather semantics like so: (\ x y z . BODY) z:=argvalue == \ x y . BODY-with-z-substituted
14:09:51 <hpc> entertainingly, named params are the main benefit of perl's variadic functions
14:10:09 <merijn> > let f x = ?a + x in (let ?a = 3 in f 2)
14:10:10 <lambdabot>  5
14:10:13 <tac_> Idris can do proper variadics
14:10:16 <tac_> In a typesafe way, even
14:10:20 <tac_> Amazing!
14:10:23 <kristof> I'd like to see that
14:10:30 <pranz> dependent types can cure cancer
14:10:31 <bitemyapp> merijn: but seriously, beating nginx? dafuq.
14:10:36 <hpc> idris can do quite a few things
14:10:44 <hpc> i need to ever do real code with it
14:10:49 <bitemyapp> pranz: I kinda wish they'd been named precise types, then muggles would know what it means.
14:10:49 <hpc> or any <.<
14:10:52 <merijn> bitemyapp: nginx doesn't scalle up to multiple cores very well, afaik
14:11:04 <tac_> pranz: Cancer is a lack of type safety at the cellular level.
14:11:14 <bitemyapp> merijn: it's not mind-blowing, but it does improve in the presence of more cores.
14:11:29 <JuanDaugherty> fwiu nginix doesn't do anything apache can't properly configured
14:11:40 <JuanDaugherty> the reverse obviously isn't true
14:11:48 <tac_> oh, here we go http://stackoverflow.com/questions/17905537/dependently-typed-printf-in-idris
14:12:30 <hpc> yes please!
14:13:03 <tac_> Not the most elegant version of it, but good enough
14:13:27 <hpc> i think that's my new example of why dependent types should be learned
14:14:03 <tac_> I like using Vect and safe division as my goto examples
14:14:18 <tac_> div : (n d : Nat) -> d /= 0 -> Nat
14:14:35 <copumpkin> and now your callers have to do way more work!
14:14:56 <hpc> div : n d : Nat -> n `productOf` d -> Nat
14:15:03 <tac_> copumpkin: The alternative is risk destroying the universe.
14:15:09 <copumpkin> :)
14:16:03 <triliyn> copumpkin: the callers should be doing that work anyway; now they just need to tell the compiler what they've done!
14:16:09 <copumpkin> yeah :)
14:16:19 <tac_> The other thing is, stuff like Template Haskell can (in principle) be done entirely in-language.
14:16:25 <copumpkin> but many people don't grasp how much work that might be
14:17:09 <triliyn> (Of course, it's not usually quite that simple...)
14:17:39 <tac_> Even if you had lies all over your program, you could at least keep tabs of where you're lying.
14:24:13 <kristof> I'm still looking for a good reason to have run-time type checking
14:24:16 <kristof> I can't find one
14:24:29 * hackagebot haskelm 0.0.2 - Elm to Haskell translation  http://hackage.haskell.org/package/haskelm-0.0.2 (jeremondi)
14:24:30 <kristof> besides "prototyping", or hotloading code
14:25:03 <benzrf> hmm
14:25:17 <benzrf> if I'm using prisms for runtime typechecking
14:25:25 <benzrf> [implementing a lisp, calm down]
14:25:52 <benzrf> traverse . _Prism will say yes if there is even one element matching
14:26:00 <benzrf> is there a way to make it try all?
14:26:33 <jrmithdobbs> :t toListOf
14:26:34 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
14:26:47 <benzrf> hmm?
14:26:49 <jrmithdobbs> aka ^..
14:27:02 <jrmithdobbs> that will give you an empty list or all
14:27:13 <benzrf> hmm
14:27:19 <benzrf> how can i use that, for example, to verify that every member of a list is a Left and not a Right?
14:27:36 <jrmithdobbs> you wouldn't
14:27:43 <benzrf> then what /would/ I
14:28:33 <jrmithdobbs> you'd fmap whatever list; or return $ lefts list >>= map errors; or bimap ... depending on what you want specifically
14:29:00 <benmachine> > traverse (^?_Left) [Left 3, Left 4, Left 5]
14:29:01 <lambdabot>  Just [3,4,5]
14:29:09 <benmachine> > traverse (^?_Left) [Left 3, Left 4, Left 5, Right 6]
14:29:10 <lambdabot>  Nothing
14:29:18 <benzrf> hmmm
14:29:25 <benzrf> :t traverse
14:29:26 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:29:30 <jrmithdobbs> it depends on what behaviour you're after do you want to fail if there's any lefts? do you just want to report lefts, etc
14:29:36 <benmachine> traverse is basically mapM
14:29:39 <benzrf> fail if theres any lefts
14:30:03 <benzrf> i want to verify that all of the values in lambda's first arg are symbols
14:30:06 <benzrf> and that it is a list, ofc
14:30:06 <benmachine> I'm sure there's something even more clever if all you want is a boolean, instead of a list of the things inside
14:30:33 <benmachine> > all (has _Left) [Left 3, Left 4, Left 5, Right 6]
14:30:34 <lambdabot>  False
14:30:36 <benmachine> > all (has _Left) [Left 3, Left 4, Left 5]
14:30:38 <lambdabot>  True
14:30:46 <benzrf> I'd like to be able to compose it though
14:31:02 <benmachine> compose it with what?
14:31:08 <benzrf> other prisms
14:31:25 <benmachine> who says you can't?
14:32:01 <benzrf> o_o
14:32:07 <benmachine> I mean
14:32:10 <merijn> Isn't the ability to compose prisms the reason prisms exist/are cool in the first place?
14:32:11 <benmachine> I don't really understand the question :P
14:32:27 <benzrf> I want something like
14:32:36 <benzrf> traverse . allMatch _Left
14:32:42 <benzrf> which is a prism that matches a list of entirely lefts
14:32:59 <benzrf> vs
14:33:00 <benmachine> oh, you want a Prism itself
14:33:03 <benzrf> yeah
14:33:13 <benzrf> > traverse . _Left ^? [Right 1, Left 2, Left 3]
14:33:14 <lambdabot>  Couldn't match type `[Data.Either.Either a2 b1]'
14:33:15 <lambdabot>                with `(a0
14:33:15 <lambdabot>                       -> Control.Lens.Internal.Getter.Accessor (Data.Monoid.F...
14:33:15 <lambdabot>                      -> ((a1 -> f0 b0)
14:33:15 <lambdabot>                          -> t0 (Data.Either.Either a1 c0)
14:33:26 <benzrf> > (traverse . _Left) ^? [Right 1, Left 2, Left 3]
14:33:27 <lambdabot>  Couldn't match type `[Data.Either.Either a2 b1]'
14:33:27 <lambdabot>                with `(a0
14:33:27 <lambdabot>                       -> Control.Lens.Internal.Getter.Accessor (Data.Monoid.F...
14:33:27 <lambdabot>                      -> ((a1 -> f0 b0)
14:33:27 <lambdabot>                          -> t0 (Data.Either.Either a1 c0)
14:33:33 <benzrf> oops
14:33:33 <benmachine> well, I barely know what I'm doing, so I don't think I'm much help :P
14:33:36 <benzrf> > (traverse . _Left) ^.. [Right 1, Left 2, Left 3]
14:33:37 <lambdabot>  Couldn't match type `[Data.Either.Either a2 b1]'
14:33:38 <lambdabot>                with `(a0
14:33:38 <lambdabot>                       -> Control.Lens.Internal.Getter.Accessor
14:33:38 <lambdabot>                            (Data.Monoid.Endo [a0]) a0)
14:33:38 <lambdabot>                      -> ((a1 -> f0 b0)
14:33:39 <benzrf> wat?
14:33:46 <benmachine> benzrf: maybe test in GHCi first
14:33:51 <benzrf> right
14:34:30 * hackagebot snaplet-sqlite-simple 0.4.6 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.6 (JanneHellsten)
14:34:32 <zz_tomp> Does anybody know of any HTTP clients that will decode the response body (ByteString) to a Text based on the response's content-type?
14:34:56 <zz_tomp> (Or keep it as ByteString if it can't decode to Text)
14:35:09 <hpc> ooh, good question
14:37:51 <hpc> i don't know of any, and can't find any in a brief search of hackage
14:38:01 <schell> is it possible to expose functions of the same name from different modules and have cabal build it?
14:38:13 <zz_tomp> hpc: Yes, nor I, that's a shame. Thanks for looking.
14:38:14 <merijn> schell: Yes
14:38:36 <merijn> schell: Just take a look at Data.Set, Data.Map and Prelude which all share lots of functions with the same name
14:39:03 <merijn> schell: People importing both modules will need to either do it qualified OR hide the function from all but one of the modules, though
14:39:11 <schell> that's what i was thinking, but i'm getting an esoteric error
14:39:16 <schell> ld: illegal text reloc in '_cj4z_info' to '_drawzmapizm0zi1zi0zi0_GraphicsziRenderingziDrawziShaderziTextziTypes_TextShaderProgram_con_info' for architecture x86_64
14:39:19 <hpc> you should think before you do that though, because it's a huge nuisance to deal with Map/Set/Prelude all at once
14:39:27 <merijn> hpc: Word
14:39:45 <schell> seems that if i rename some record names that would otherwise clash, that error goes away
14:40:02 <merijn> schell: That doesn't seem right
14:40:23 <merijn> schell: If it fails it should produce a compile time error...can you try to make a minimal case?
14:40:34 <schell> yeah
14:40:51 <merijn> I need to go soon, but if this is indeed happening with a link time error, rather than a compile error then that sounds like a GHC bug
14:41:04 <schell> i think it might be
14:41:07 <schell> i'll set up a test case
14:41:30 <schell> and it only happens building as a library
14:41:51 <merijn> schell: If you have a test case you can ask #ghc if that's supposed to happen and/or file a ticket on Trac
14:41:56 <schell> so maybe it's cabal(or me) not giving the correct flags?
14:42:03 <schell> kk
14:42:20 <merijn> schell: Don't forget to use cabal with "-v3" to see if that reports anything interesting
14:42:27 <schell> will do
14:43:54 <schell> merijn: nothing pops out at me as interesting with -v3
14:46:05 <Earnestly> Silly question; do you like starting `main` above or below all your function definitions and such?
14:46:33 <bobobo1618> Personally, above.
14:46:40 <bobobo1618> I'm a newb so I'm probably doing it wrong.
14:47:49 <Earnestly> an important bikeshed for sure
14:48:51 <dwcook> Earnestly, I like to define everything else in separate modules and use main as the glue for it all
14:49:44 <jfischoff> I seem to remember a package on Hackage for parsing .hp files, but I can't find it
14:49:49 <jfischoff> anyone know of one?
14:49:54 <Earnestly> dwcook: And so the file containing main would essentially just contain that and nothing else (except for imports)?
14:50:30 <dwcook> Earnestly, other than maybe a where clause, yeah
14:50:30 <Feuerbach> jfischoff: http://hackage.haskell.org/package/hp2any-core ?
14:51:10 <dwcook> Although, I guess the where clause could just as well be split out into top-level definitions
14:51:49 <jfischoff> Feuerback: I thought there was one that was just a parser, but I could have made that up
14:52:22 <dwcook> Still, I like to define the most abstract things first in a module
14:54:32 * hackagebot language-typescript 0.0.4 - A library for working with TypeScript Definition files  http://hackage.haskell.org/package/language-typescript-0.0.4 (PhilFreeman)
15:02:00 <Fernandos> any idea why I can't install any package with cabal install --user ? Doesn't work even without the --user flag (without sudo)
15:02:12 <benzrf> hey
15:02:34 <benzrf> how can I use makeLenses when only some of my data constructors use record syntax
15:03:31 <pavonia> Fernandos: What happens when you try?
15:04:59 <Fernandos> pavonia: cabal: Error: some packages failed to install: lifted-base-0.2.1.1 failed during the configure step. The exception was: ExitFailure 127
15:05:19 <benzrf> hmm is there something that turns a record accessor into a traversal
15:05:26 <Fernandos> happens for cabal install lifted-base  and cabal install --user lifted-base
15:07:37 <pavonia> Fernandos: Can you try again with the -v flag and paste the output?
15:09:23 <AfC> Does tail call optimization happen if your recursive call is in the then of an if-then-else, rather than the else?
15:09:34 <Fernandos> pavonia: http://hastebin.com/fafatufame.txt
15:09:45 <c_wraith> AfC: all that matters is "can this be converted to a loop?"
15:10:18 <c_wraith> AfC: that is, "at any point in the evaluation of this function, does it become evaluating itself with different arguments?"
15:11:33 <Fernandos> pavonia: does that help?
15:11:40 <nonconvergent> What determine's cabal's paths? I renamed my user (and moved his home) and now it keeps looking for the old one's path.
15:11:48 <pavonia> Fernandos: Hhm, not really
15:12:03 <AfC> c_wraith: that makes sense. Thanks. I was under the impression the requirements were more strict (heh ^W) pedantic than that
15:12:09 <Fernandos> pavonia: ~/.cabal/logs/lifted-base-0.2.1.1.log doesn't contain anything useful too.
15:12:35 <AfC> Next question: what does the "(...)" in  functionName.(...) mean in profiling output?
15:13:39 <pavonia> Fernandos: No idea, sorry
15:14:34 <Fernandos> I wiped ~/.cabal and ran cabal update && cabal install --user -v lifted-base => Still getting the same error
15:15:09 <dhrosa> Fernandos: you might also  want to check our your ~/.ghc dir
15:15:50 <Fernandos> k, wiped both, re-running
15:17:52 <Fernandos> dhrosa: I also removed $HOME/.cabal/bin from the path, restart the shell and ran the commands again. But still the same.
15:19:02 <Fernandos> Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.2 Using binary package database: /usr/lib64/ghc-7.6.3/package.conf.d/package.cache
15:19:21 <edwardk> benzrf: 'upon'
15:19:31 <benzrf> upon?
15:19:33 <benzrf> :t upon
15:19:34 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
15:19:35 * hackagebot pipes-network 0.6.2 - Use network sockets together with the pipes library.  http://hackage.haskell.org/package/pipes-network-0.6.2 (RenzoCarbonara)
15:19:37 * hackagebot haskelm 0.0.3 - Elm to Haskell translation  http://hackage.haskell.org/package/haskelm-0.0.3 (jeremondi)
15:19:38 <benzrf> ah, thank you :)
15:19:38 <edwardk> > (1,2) & upon fst .~ 100
15:19:40 <lambdabot>  (100,2)
15:19:52 <edwardk> > [1,2,3,4] & upon last .~ 100
15:19:53 <lambdabot>  [1,2,3,100]
15:20:17 <edwardk> > [1,2,3] & upon tail %~ reverse
15:20:19 <lambdabot>  [1,3,2]
15:20:45 <edwardk> benzrf: it is rather too magic for me to encourage its use, but it is there for the sheer absurdity of it
15:21:01 <benzrf> well it came in handy for me here ;)
15:21:14 <edwardk> benzrf: be warned it is slow =)
15:21:20 <benzrf> this is not a real program dw
15:22:37 <benzrf> edwardk: btw, is there a way to make a traversal that matches lists where each element matches a prism?
15:22:46 <benzrf> i.e.
15:23:00 <benzrf> matchAll _left `has` [Left 1, Left 2]
15:23:02 <edwardk> > [Left 3, Left 4, Right 4] ^.. traverse.filtered (has _Left)
15:23:04 <lambdabot>  [Left 3,Left 4]
15:23:09 <nonconvergent> Any idea where cabal/ghc set its $HOME? I renamed my user and moved his home and now my ghc packages keeps looking for the old home path, which doesn't exist, so all the files are missing to it.
15:23:27 <benzrf> hmmm
15:23:38 <edwardk> Control.Lens.Extras gives you 'is' if you prefer how that reads ;)
15:24:08 <Earnestly> nonconvergent: /etc/passwd (probably getpwname(), POSIX)
15:24:09 <dcoutts_> nonconvergent: the package db lives under ~/.ghc/ and contains lots of absolute paths, but you can use something like sed to change them all
15:24:22 <Earnestly> So gross :P
15:24:31 <Fernandos> nonconvergent: $PATH
15:24:48 <benzrf> dcoutts_: well, what I want is not to target all of the Lefts
15:24:48 <Earnestly> But all compilers are pretty much behind the times when it comes to littering ~/ with "dotfiles"
15:24:52 <benzrf> * @ edwardk
15:25:04 <benzrf> I want to match only if they are /all/ Lefts
15:25:06 <benzrf> or w/e the prism is
15:25:08 <eflister> hey haasn - you responded to my musings "is the dual of an identity a fixed point?" with "the identity of identity is identity" -- i don't mean the function "id", i mean the value identity, which is the value, for some function f, maps other values to themselves, like 0 for addition, 1 for multiplication, or [] for append.  i was asking if a fixed point is its dual -- the value, for some f, that maps all other values to itself.
15:25:16 <edwardk> benzrf: ah
15:25:45 <edwardk> below _Left
15:25:45 <nonconvergent> Fernandos: Nope.
15:25:52 <nonconvergent> dcoutts_: This sounds likely.
15:25:54 <edwardk> below :: Traversable f => APrism' s a -> Prism' (f s) (f a)
15:26:23 <benzrf> ?
15:26:33 <benzrf> I am not good at reading lens types, sorry :|
15:26:50 <edwardk> below _Left :: Prism' [Either a b] [a]
15:27:12 <benzrf> > below _Left ^? [Right 1, Left 2]
15:27:13 <lambdabot>  Not in scope: `below'
15:27:13 <edwardk> replace [] with any Traversable functor you want and it works
15:27:17 <benzrf> no below?
15:27:35 <edwardk> it'd be [Right 1, Left 2] ^? below _Left  -- but below was added in lens 4
15:28:19 <benzrf> hmm
15:28:22 <benzrf> how do I check my lens version?
15:28:23 <edwardk> [Left 3, Left 4]^?below _Left     ==> Just [3,4]
15:28:37 <benzrf> edwardk: and if there were any Rights, it'd be nothign?
15:28:39 <benzrf> *Nothing
15:28:49 <edwardk> ghc-pkg describe lens
15:28:52 <edwardk> correct
15:29:15 <benzrf> it's like you can anticipate my use cases 8D
15:29:28 <edwardk> i try =)
15:29:35 <benzrf> aw man i have 3.9
15:29:37 <benzrf> how do upgrade?
15:29:40 <edwardk> you can also construct with it, as it is a prism
15:29:46 <edwardk> cabal update; cabal install lens
15:30:00 <Datsundere> so apparently a relative of mine got h1n1
15:30:05 <Datsundere> oh shit wrong channel
15:30:08 <Datsundere> sorry #haskell
15:30:18 <edwardk> below _Left # [2,3,4,5]     ==> [Left 2, Left 3, Left 4, Left 5]
15:30:53 <nonconvergent> dcoutts_: Just swap and replace old user path with new user path for everything under package.conf.d
15:30:56 <nonconvergent> ?
15:30:58 <benzrf> edwardk: given a sum type of kind * where only 2 of its constructors use record syntax, and they share an accessor
15:31:21 <benzrf> is there any better way to get a traversal onto that accessor's field than with upon?
15:31:28 <edwardk> makeLenses just skips the constructors it doesn't understand, no?
15:31:37 <edwardk> at least in 4
15:31:41 <edwardk> not sure about 3.9 or 3.10
15:31:41 <benzrf> oh
15:31:47 <benzrf> well that explains why it didnt work before :)
15:32:18 <edwardk> usually i just recommend writing the lenses by hand, its just a little boilerplate
15:32:30 <jrmithdobbs> the more i use do syntax the more i find myself just factoring it back out, is that bad?
15:32:30 <edwardk> _2 f (a,b) = (,) a <$> f b
15:32:34 <benzrf> pfft why should I use a library if it makes me write code to make it work???
15:33:11 <benzrf> btw, how do you write prisms?
15:33:21 <benzrf> I tried to make one
15:33:29 <benzrf> it worked fine with the one it matches
15:33:41 <benzrf> but it gave a non-exhaustive pattern error with non-matching
15:33:47 <benzrf> I probably misunderstood something important o_O
15:34:14 <jrmithdobbs> benzrf: because you can do things like write ~6 lines of boilerplate and then reflect back and forth through prisms on aeson json representations and parsed representations of them to do generics without generics, so internal passing is using same code paths as to external consumers/producers
15:34:19 <jrmithdobbs> benzrf: lens is p powerful
15:35:14 <benzrf> jrmithdobbs: i was being ironical
15:35:25 <jrmithdobbs> ;p
15:35:51 <benzrf> I am getting:ghc: could not execute: cpphs
15:35:56 <benzrf> what is this
15:36:04 <benzrf> cpphs --help yields a help message
15:37:03 <carter> benzrf: what are you trying to do?
15:37:53 <benzrf> update lens
15:38:07 <benzrf> Preprocessing library lens-4.0...
15:38:08 <benzrf> ghc: could not execute: cpphs
15:38:14 <carter> benzrf: the patches for using cpphs with ghc aren't in yet
15:38:19 <benzrf> gah
15:38:22 <benzrf> how do I fix?
15:38:32 <carter> do you have cpphs installed?
15:38:34 <benzrf> yes
15:38:42 <benzrf> not sure when it happened, but I can run it
15:38:55 <carter> 2 --ghc-options="-pgmP cpphs -optP --cpp"
15:39:35 <benzrf> 2?
15:39:46 <carter> 1)
15:39:47 <carter> 2)
15:39:49 <carter> :)
15:39:51 <benzrf> oh
15:40:05 <benzrf> er, im not sure what you mean
15:40:06 <benzrf> I saw no 1
15:40:13 <carter> 1) do you ahve cpphs isntalled
15:40:26 <Earnestly> It was implicit ;o
15:40:28 <carter> yes
15:40:29 <benzrf> oh
15:40:29 <carter> that
15:40:59 <benzrf> put those flags after the cabal install
15:41:00 <benzrf> ?
15:41:04 <benzrf> i tried that just now and it still errors
15:41:11 <benzrf> aha
15:41:14 <benzrf> cpphs is not in root's path
15:41:17 <benzrf> welp
15:41:20 <carter> benzrf: why not use GCC
15:41:21 <carter> use gcc
15:41:31 <benzrf> huh
15:41:31 <benzrf> ?
15:41:35 <carter> benzrf: you're on a mac
15:41:37 <carter> or bsd
15:41:42 <benzrf> no, I'm on ubuntu
15:41:46 <carter> then why not use gcc
15:41:48 <carter> for CPP
15:41:55 <benzrf> i dunno, I didn't choose this..
15:42:05 <carter> benzrf: give us context or no one can help you :)
15:42:11 <benzrf> I did 'sudo cabal install lens'
15:42:15 <benzrf> it gave me that error about cpphs
15:42:20 <carter> why sudo?
15:42:26 <benzrf> so that it would install
15:42:32 <carter> why not cabal install lense
15:42:40 <benzrf> because then it errors because no perms
15:42:46 <edwardk> too many es ;)
15:42:57 <carter> eeeeeh
15:43:06 <carter> benzrf: cabal sandbox!
15:43:06 <edwardk> benzrf: basically once you sudo cabal install anything you are in a world of pain
15:43:18 <benzrf> too late
15:43:23 <benzrf> that's how ive installed everything
15:43:24 <benzrf> >_>
15:43:27 <edwardk> benzrf: then you are in a world of pain ;)
15:43:30 <benzrf> :(
15:43:33 <carter> yeah, never sudo
15:43:41 <benzrf> fu i like global installs
15:43:47 <dcoutts_> benzrf: don't install for your own user as root, then you have loads of files under your $HOME that are owned by root
15:43:48 <benzrf> they're MORE CONVENIENT
15:43:50 * benzrf ducks
15:44:05 <dcoutts_> benzrf: use --global with sudo, for system-wide installs
15:44:15 <dcoutts_> default is --user
15:44:17 <benzrf> oh
15:44:38 <benzrf> sht
15:44:39 <benzrf> *shit
15:44:51 <nonconvergent> local installs are pretty easy to handle too.
15:45:05 <dcoutts_> benzrf: just fix it with a suitable sudo chown -R
15:45:08 <nonconvergent> just need to pass the local cabal path to everything that needs it.
15:45:31 <benzrf> ha, I fixt it
15:45:31 <benzrf> sudo bash -c "PATH='$PATH' cabal install lens"
15:45:32 <benzrf> B)
15:45:35 <nonconvergent> Took me a while to figure out I needed to pass it to .xsessionrc
15:45:44 <benzrf> ^VERY GOOD & SANE SOLUTION
15:46:39 <rs0_> shouldn't cabal detect and warn about its own misuse instead of silently doing something that doesn't make complete sense?
15:47:16 <dcoutts_> rs0_: patches accepted
15:47:59 <dcoutts_> iirc it's a bit harder than it looks to detect the bad situation properly
15:48:42 <carter> dcoutts_: btw schell  may have a bug that *might* be cabal related, or it *probably* is opengl related
15:49:48 <rs0_> dcoutts_: can cabal default to a --global install when getuid returns 0?
15:50:09 <carter> rs0_: generally  you should never use --global by accident
15:55:55 <jfischoff> Why ever use --global?
15:56:05 <bernalex> what's the simplest/best opts parser? I want to be able to easily specify short and long opts that are bound to functions which are arg -> IO a. if it has builtin --help output, that is a big advantage, though not necessary.
15:56:18 <ParahSailin_> optparse-applicative
15:56:47 <schell> carter,dcoutts: it's in cabal i'm pretty sure now - i'll have a test case on github soon
15:56:56 <carter> schell: yay
15:56:58 <aleksejs_> Hi, how do I fix this? http://vpaste.net/p2XGG
15:57:33 <hpc> something is amiss indeed!
15:57:42 <carter> ?
15:57:54 <bernalex> ParahSailin_: thanks.
15:58:16 <jfischoff> alekseks_: what is the output of `ghc-pkg list | grep template-haskell`
15:58:43 <carter> o/ jfischoff
15:59:00 <jfischoff> \o carter
15:59:30 <benzrf> edwardk: if I want to specify something that works with ^?
15:59:31 <benzrf> do I use
15:59:33 <benzrf> Getting (Data.Monoid.First a) s a
15:59:57 <jfischoff> aleksejs_: I spelled your name wrong but do you see my response?
16:00:03 <Cale> jfischoff: I can only assume it might be useful for multi-user machines where there were multiple people using the same packages.
16:00:08 <aleksejs_> $ ghc-pkg list | grep template-haskell
16:00:08 <aleksejs_>     template-haskell-2.7.0.0
16:00:08 <aleksejs_>     template-haskell-2.8.0.0
16:00:20 <jfischoff> Cale: ah
16:00:25 <Cale> jfischoff: But yeah, I never use --global myself
16:00:29 <edwardk> if you just want to define a Getter? Define a Getter s a, if you want to accept something as an argument that you'll pass to ^? then use Getting (First a) s a, yes.
16:00:48 <jfischoff> aleksejs_: you should only have one, the lower probably
16:01:05 <jfischoff> what version of ghc do you have?
16:01:30 <jfischoff> or do a ghc-pkg list and see what version of template-haskell is in the global section
16:01:40 <jfischoff> that's one you want
16:03:00 <aleksejs_> global is /var/lib/ghc?
16:03:52 <jfischoff> sounds right, user would be in a ~/.ghc folder most likely. Also is that the first one listed?
16:04:02 <jfischoff> global comes first I think
16:04:36 <aleksejs_> yes, the second was ~/
16:04:46 <aleksejs_> $ ghc-pkg unregister --force template-haskell-2.8.0.0
16:04:47 <aleksejs_> unregistering template-haskell-2.8.0.0 would break the following packages: reflection-1.4 PBKDF2-0.3.1.3 Crypto-4.2.5.1 QuickCheck-2.6 (ignoring)
16:05:00 <jfischoff> don't force
16:05:24 <aleksejs_> $ ghc-pkg unregister template-haskell-2.8.0.0
16:05:24 <aleksejs_> ghc-pkg: cannot find package template-haskell-2.8.0.0
16:05:27 <aleksejs_> :)
16:05:41 <jfischoff> yeah but those other packages are broken
16:05:49 <carter> aleksejs_: you wanna unregister the local one
16:05:50 <jfischoff> better to recursively uninstall and reinstall
16:06:33 <jfischoff> I would unregister those other packages
16:07:33 <aleksejs_> now something new while compiling:
16:07:36 <aleksejs_> Ambiguous module name `Control.Monad.Trans':
16:07:36 <aleksejs_>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.1
16:07:57 <schell> carter, dcoutts : https://github.com/haskell/cabal/issues/1664
16:08:23 <jfischoff> well that happens, you need to pick one or hide one -hide-package monads-tf-0.1.0.1
16:08:55 <dcoutts_> schell: so you mean the bug is that it doesn't complain that you've not listed all modules?
16:09:02 <jfischoff> also if you use a cabal file and cabal repl you don't run into this
16:09:18 <schell> dcoutts_: yes, i guess so - haha - i'll add that
16:09:55 <schell> dcoutts_: i really just didn't know what an illegal text reloc is - chased it all over the place
16:10:29 <carter> schell: and we appreciate that effort!
16:11:41 <schell> carter: yeah, no prob
16:11:59 <carter> schell: no, its a lot fo time an effort
16:12:18 <carter> schell: lets me honest, me very very loudly thanking you makes you more like do it again :)
16:12:28 <schell> haha - true
16:12:44 <schell> who should i invoice for these billable hours? ;)
16:12:47 <schell> jk
16:12:54 <carter> nope
16:13:09 <carter> schell: invoice them to karma
16:13:13 <aleksejs_> jfischoff, do I always need to add that "-hide-package"?
16:13:35 <carter> nope, just when you have a crazy pkg setup :)
16:13:42 <aleksejs_> :)
16:13:44 <carter> or dont use sandboxes :)
16:14:05 <bitemyapp> don't use sandboxes? horror.
16:14:34 <carter> *doesn't use
16:14:59 <aleksejs_> if I unregister that monads-tf* would it help?
16:16:42 <nonconvergent> dcoutts_: I tried what you said and now this happens:         While parsing "/home/neuromancer/.ghc/x86_64-linux-7.4.1/package.conf.d/package.cache": too few bytes. Failed reading at byte position 23037
16:17:05 <dcoutts_> nonconvergent: run ghc-pkg recache
16:17:42 <defanor_> i'm trying to handle exceptions in this function - http://lpaste.net/3654461434487635968, and getting this error - http://lpaste.net/3261308851290374144. not even sure what type of strTry should there be; i want to handle all the exceptions at once. is it a wrong approach, and/or is there a way to do it?
16:18:45 <jfischoff> aleksejs_: if you use ghci or ghc --make and you have to packages that have the same modules you get that error. Just do `cabal init` setup a cabal file and then cabal repl
18:59:51 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
18:59:51 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
18:59:51 --- names: list (clog gridaphobe prinsen shachaf bcoppens Earnestly etabot mononofu sdx23 levi m3ga milieu The_third_man tixxit qz morolin StillInSyros Mortomes kfish brisbin reizuki__ mkpai mami jbauman michael jamwt1 arrdem MitchW shepheb caumeslasal moop fabjan rawtass amontez otulp dju julian kaol Kruppe simpson cmears Licenser passiveobserver lemao liori MasseR valdyn zerokarmaleft Enigmagic pingu mechairoi IanKelling ArcTanSusan bbee emma Sourceless vnz exicer shesek)
18:59:51 --- names: list (kosmikus federkasten gienah yggr nocturne777 jang mshroyer rodrigovidal FliPPeh pieter ddellacosta Dashkal KorriX annulus Gunni hamilyon sski)
21:35:41 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
21:35:41 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:59 2013]
21:35:41 --- names: list (clog randomclown1 Meistarin Mortomes reizuki__ bholst acfoltzer structuralist paz helmut Sgeo kalloc LeNsTR Martty_ liori vikraman jlouis killy9999 rmunroe thunderrd bbee sebastian npcomp gseitz Derander Spaceghost MarcWeber geal omefire RogueShadow Eliel mgdixon)
