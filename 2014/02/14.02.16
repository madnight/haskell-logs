00:00:46 <levi> I don't know if there's a term like that to describe them, because they're called monads instead.
00:01:14 <levi> Supposedly 'monad' comes from 'monoid' and 'triad'.
00:01:21 <levi> Or something like that.
00:02:14 <levi> Or there's also the "Monads are Monoids in the category of endofunctors..." description.
00:03:29 <narain> quick question: i have a bunch of boolean-like data types in my program, like for example  data Side = Front | Back
00:03:40 <levi> The usefulness that they carry for describing semantics of programming languages is due to the monoidal multiplication that happens when composing them.
00:03:52 <narain> to keep the program easy to read i define custom data types for each of them instead of just reusing Bool
00:03:54 <no-n> @src (.)
00:03:54 <lambdabot> (f . g) x = f (g x)
00:03:54 <lambdabot> NB: In lambdabot,  (.) = fmap
00:04:20 <narain> but now i need a  not  function on each of them
00:04:42 <narain> is there an appropriate ready-made type class i should make them an instance of?
00:04:49 <Cale> platz: Monads are lax 2-functors from the 1-point category to Cat
00:04:55 <c_wraith> narain: have them derive Enum, have the function work on that?
00:05:46 <c_wraith> narain: Eh, maybe not.  Enum is a bit sketchy.
00:05:47 <narain> c_wraith: that's what i thought at first, but apparently  succ maxBound  is defined to be an error
00:05:52 <no-n> hi
00:06:09 <platz> thanks.  interesting, at least now I have some more direction in which to investigate further
00:06:20 <Cale> http://ncatlab.org/nlab/show/lax+functor
00:06:39 <platz> instead of aimless turtles all the way down
00:09:27 <arahjafaar> Hallo!
00:09:37 <narain> i suppose i could define my own  succ'  with  succ' maxBound = minBound  …hey, that would work
00:11:49 <jle`> narain: actaully jfischoff was thinking about doing a package of Generic Bool functions
00:11:51 <jle`> i think
00:12:05 <jle`> he might have abandoned it because the idea of going that far out of the way was a little silly
00:12:27 <jle`> where you would define a generic not function that worked on all bool-likes
00:12:31 <jle`> using deriving Generic
00:13:08 <narain> hmm, i don't know what Generic is
00:13:13 <narain> let me look it up
00:13:45 <jle`> http://hackage.haskell.org/package/generic-maybe
00:14:08 <jle`> it's probably slightly overkill though
00:16:44 <narain> thanks for the pointer! unfortunately it's too late at night here for me to try to understand right now :)
00:17:21 <jle`> for now the easiest way would probably to derive Enum
00:17:41 <narain> yeah, that's what i'm going to do
00:18:26 <narain> i probably have to derive Bounded too so that i can override  succ  on the last one
00:19:19 <narain> thanks for the suggestions, all!
00:19:25 <jle`> i don't think you can define succ' like you typed earlier
00:19:30 <narain> no?
00:19:35 <jle`> that will always return minBound
00:19:42 <jle`> because maxBound is a variable binding
00:19:45 <jle`> in that context
00:20:07 <narain> ah right
00:20:08 <jle`> it's the same as succ' x = minBound
00:20:19 <jle`> so...you might have to derive Eq and use guards
00:21:01 <narain> i'm deriving Eq already, so no big deal
00:21:36 <jle`> then you don't even need Enum i think
00:22:06 <jle`> not' x | x == maxBound == minBound | otherwise = maxBound
00:22:24 <jle`> might be a better way though heh.
00:22:35 <narain> that makes sense too
00:22:55 <narain> i was going to do  succ' x | x == maxBound = minBound; succ' x = succ x
01:24:05 <Wizek> Good Morning. How can I make hspec to run whenever I save a .hs file?
01:27:46 <verement> inotify?
01:40:38 <jtcwang> I'm defining multiple newtypes, but the compiler is complaining about having the the same name for the accessor function
01:40:39 <jtcwang> http://lpaste.net/100020
01:41:06 <jtcwang> is there a way around this other than the answer presented here? http://stackoverflow.com/questions/4799251/multiple-declarations-of-mymodule-mytypeclassfunction
01:43:46 <emjsw> Can I, and if so, how do I use folds in Data.Vector.Generic to sum a Data.Vector.Generic.Mutable? I'm working in the ST monad with unboxed vectors.
01:53:23 <c_wraith> emjsw: no, you can't.
01:55:03 <merijn> c_wraith, emjsw: Well, you can if you put them in different module and then only use them qualified, but other than that, no.
01:55:04 <Wizek> verement, Do you know of a nice executable tool that uses inotify internally?
01:55:23 <c_wraith> emjsw: however, if you want to live dangerously, you can combine unsafeFreeze and a fold
01:55:37 <verement> Wizek: yes, there's inotifywatch
01:56:08 <c_wraith> merijn: the problem is that mutable vectors and immutable vectors are different types.  It has nothing to do with imports
01:56:14 <Wizek> verement thanks, will look into it
01:56:19 <merijn> oh
01:56:21 <merijn> whoops
01:56:23 <merijn> wrong name
01:56:27 <merijn> I meant jtcwang >.>
01:56:35 <merijn> I blame the early morning
01:56:43 <c_wraith> mornings are the devil
01:56:53 <verement> Wizek: or inotifywait, both part of inotify-tools
01:57:00 <jtcwang> merijn, aw ok
01:57:40 <Wizek> Is this supposed to work with the lens library? https://gist.github.com/Wizek/9031925
01:57:44 <c_wraith> emjsw: If you use fold an unsafeFreeze directly, in ST, you're probably guaranteed to avoid cases of undefined behavior - but it's not a case that's documented to work, so it's living on the edge.
01:57:44 <merijn> jtcwang: usually people use the name of the newtype inside the function
01:58:00 <jtcwang> yeah i guess, like num58 in my case
01:58:08 <merijn> jtcwang: Like I would probably write "newtype SafeString = SafeString { getSafeString :: String }"
01:58:20 <jtcwang> right
01:58:22 <Wizek> Two records with the same field name. I would assume that the TemplateHaskell magic in the background would take care of the  chash. Does it?
01:58:42 <c_wraith> emjsw: also, you need to be sure to force the fold to complete before modifying the vector again, otherwise laziness adds undefined behavior.
01:58:51 <jtcwang> that makes sense, but i wouldn't hurt to have 'unwrap' everywhere and let the compiler figure out the types
01:58:56 <c_wraith> emjsw: If all of this sounds scary, it's because it is. :)
01:59:17 <jtcwang> with how stuff is like if we implement it using Class + Data
02:00:39 <merijn> jtcwang: There is a "better record" proposal in progress by a GSoC guy supervised by SPJ
02:01:03 <merijn> Maybe 7.10?
02:01:05 <emjsw> c_wraith: Thanks for the answer. I might try something else.
02:16:41 <supki> Wizek: No. There are TH helpers (e.g. makeFields) to share lenses' names between records, but record accessors will have unique names anyway
02:17:39 <Wizek> supki so it is possible to use the same accessor for two different records?
02:18:29 <supki> no
02:19:13 <supki> well, unless they're in the different modules and you call them qualified, that is
02:21:27 <supki> lens can give you a lens that's polymorphic enough to be used with different records
02:21:59 <jtcwang> merijn, that's good to hear ;)
02:24:13 <Wizek> merijn When do you think that will be released?
02:24:22 <merijn> jtcwang: Before you know it, you end up like the bleeding edge GHC dummies running HEAD
02:24:36 <merijn> Wizek: Not any time soon, 7.8 just had it's first release candidate
02:24:51 <Wizek> 2 years?
02:24:53 <jtcwang> haha i'm not that advanced yet
02:25:00 <jtcwang> but i could see myself doing that :P
02:25:10 <jtcwang> stability is for pussies
02:25:40 <merijn> Wizek: Something like that?
02:52:08 <no-n> @src elem
02:52:09 <lambdabot> elem x    =  any (== x)
03:03:17 <jle`> @src any
03:03:17 <lambdabot> any p =  or . map p
03:03:25 <jle`> @src or
03:03:25 <lambdabot> or    =  foldr (||) False
03:03:39 <milfjord> @src map
03:03:40 <lambdabot> map _ []     = []
03:03:40 <lambdabot> map f (x:xs) = f x : map f xs
03:03:44 <milfjord> aw, no foldr?
03:03:48 <jle`> hm
03:03:59 <jle`> doesn't this mean that elem doesn't work on infinite lists?
03:04:06 <jle`> er well
03:04:13 <jle`> i mean it won't work in general
03:04:25 <jle`> but one would expect it to return true as soon as it finds a match
03:05:01 <merijn> jle`: It does
03:05:02 <milfjord> > elem 42 [0 ..]
03:05:05 <lambdabot>  True
03:05:23 <jle`> oh, foldr
03:05:26 <jle`> not foldl
03:05:36 <jle`> my bad
03:13:46 <no-n> was lambdabot written in Haskell?
03:13:54 <milfjord> yes
03:14:10 <no-n> i'm considering writing a bot
03:21:31 <totimkopf> does anybody know if there is a clckwrks channel somewhere?
03:33:53 <identity> no-n: You should take a look at number-six(it's on jaspervdj's github)
03:33:59 <identity> It's neatly designed
03:34:09 <no-n> thank you
03:39:52 <no-n> will ghc(i) execute something given from the command line like python's -c option?
03:40:01 <milfjord> ghc -e
03:40:06 <no-n> ty
03:50:10 <mrpantou1le> @&&&
03:50:11 <lambdabot> Unknown command, try @list
03:50:17 <mrpantou1le> @source &&&
03:50:17 <lambdabot> Unknown command, try @list
03:50:35 <mrpantou1le> @src &&&
03:50:35 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
03:50:48 <mrpantou1le> @src arr
03:50:49 <lambdabot> Source not found. Where did you learn to type?
03:50:54 <mrpantou1le> @src ***
03:50:55 <lambdabot> f *** g = first f >>> second g
03:51:36 <merijn> mrpantou1le: @src is not very reliable, especially not for typeclass functions like arr
03:58:08 <rgr> haskell-mode emacs user? I'm getting a freeze calling inferior-haskell-send-decl from a .hs buffer  C-x C-d : it freezes. I need to C-g and then move to the ghci buffer and manually enter a newline before switching back and running it again. Any ideas?
04:00:42 <Guest23233> I've created two modules: Foo/Bar.hs and Foo/Bar/Baz.hs.  (The latter imports the former.)  When I try to run ghci Baz from the Foo/Bar directory, ghci can't find the Foo/Bar module.  Is there a workaround?
04:02:05 <merijn> Guest23233: Explicitly pass the search path to ghci
04:03:05 <anon_555> hi
04:03:06 <merijn> Guest23233: Normally ghci/ghc will look for module Foo.Bar.Baz in ./Foo/Bar/Baz, so if your working directory is in Foo/Bar, you'll have to use the -i flag to specify where to search
04:03:18 <anon_555> i am having trouble in getting into Haskell
04:03:24 <anon_555> i have done oop
04:03:30 <anon_555> only
04:03:33 <milfjord> in what language?
04:03:34 <Guest23233> merijn: I've tried the -i flag, but ghci couldn't find the other modules (which are installed system wide) in that case.
04:03:37 <anon_555> how can i get to functional
04:04:12 <anon_555> Is there any good books or material to start with
04:04:33 <anon_555> that is absolute for begineer's who donot have knowledge in functional programming
04:04:39 <Guest23233> merijn: Oh, it works now. Thank you.
04:04:41 <Forgetaboutit> anon_555: "Learn you a Haskell for great good" is pretty good
04:04:47 <milfjord> @where lyah
04:04:48 <lambdabot> http://www.learnyouahaskell.com/
04:05:16 <anon_555> yes but they move to advance and donot give any basic
04:05:22 <anon_555> i wanto understand the basic
04:05:25 <anon_555> at first
04:05:26 * hackagebot chatty 0.2.0.0 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.2.0.0 (implementation)
04:05:39 <milfjord> what basics?
04:06:15 <anon_555> functional programming
04:06:57 <milfjord> what
04:07:53 <sipa> lyah starts really basic
04:08:25 <sipa> and i don't think you can learn any kind of programming without actually learning and using a programming language
04:12:21 <lllllllllllll> mm_freak_, is http://ertes.de/new/tutorials/arrows.html available anywhere else? This domain is not available anymore
04:12:38 <rgr> try the tutorials at fpcomplete.https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics
04:14:46 <lllllllllllll> i want this exact one :)
04:19:28 <haasn> me too!
04:23:52 <rgr> I must admit that the statement "all functions have only one argument" has me baffled.
04:24:14 <sipa> why?
04:25:52 <rgr> I guess if you dont know why then you wont be able to help. It is very alien to anyone coming from pretty much any other languages. (addInts 2 3) seems to be two parameters.
04:26:21 <milfjord> that's parsed as ((addInts 2) 3)
04:26:26 <rgr> sure.
04:26:29 <milfjord> function application is left associative
04:26:34 <Forgetaboutit> (addInts 2 3) is just syntax
04:26:54 <rgr> which in itself is weird since the addInts *seems* to be only called once. I guess its some syntax thing I'm finding it hard to understand.
04:27:08 <milfjord> rgr: f(x)(y)
04:28:17 <Forgetaboutit> rgr: if you know JavaScript, for example, you'd write it like milfjord just did
04:28:59 <rgr> I do know js and I'm still not seeing it. mental block maybe. Maybe you could explain it terms of an example here which apparently takes two parameters:
04:29:00 <rgr> f x y = x*x + y*y
04:29:10 <lllllllllllll> rgr: python has partial() for example to be able to have the same awesome thing but much mor clumsy
04:29:14 <milfjord> that's syntactic sugar for f = \x -> \y -> x*x + y*y
04:29:33 <milfjord> which in javascript would be f = function (x) { return function (y) { return x*x + y*y; }; };
04:30:03 <rgr> ok. I need to chew on that for a minute.
04:30:39 <JuanDaugherty> rgr this is the opposite of alien to someone with a 4 year university degree in CS
04:30:51 <JuanDaugherty> they would have certainly heard of currying
04:30:54 <milfjord> .oO( predator? )
04:31:18 <rgr> JuanDaugherty: good for you.
04:31:23 <rgr> milfjord: thanks. appreciated.
04:31:28 <JuanDaugherty> and the aesthetics of it should be immediately apparent from basic math of cs training
04:31:38 <milfjord> JuanDaugherty: uh. ok
04:31:44 <JuanDaugherty> common since the late 70s or 80s
04:31:45 <rgr> JuanDaugherty: dont take up a teaching job. You sound like an arrogant moron.
04:31:49 <rgr> see you.
04:32:21 <JuanDaugherty> funny how being factual and in fact helpful gets perceived that way
04:32:28 <milfjord> JuanDaugherty: that wasn't helpful at all
04:32:35 <JuanDaugherty> sure it was
04:32:38 <milfjord> how?
04:32:56 <JuanDaugherty> I was clueing him in so he could operate effectively here
04:33:04 <milfjord> what?
04:33:08 <milfjord> [citation needed]
04:33:14 <JuanDaugherty> lol
04:34:01 <JuanDaugherty> he thought something most here consider very fundamental and basic was exotic and bizarre
04:34:16 <milfjord> and what did you do to help?
04:34:29 <JuanDaugherty> explained to him how and why that wasn't the case
04:34:36 <milfjord> no, you didn't
04:35:16 <JuanDaugherty> yes, I did. Maybe not the way you wanted me to.
04:35:36 <JuanDaugherty> but a quick and effective way
04:35:49 <JuanDaugherty> appropriate to the times
04:35:55 <milfjord> "I think this is bizarre."  "No, you don't."
04:35:59 <milfjord> ^ not helpful
04:36:49 <lllllllllllll> hellom is this #education?
04:37:03 <milfjord> "I think this is bizarre."  "Well, if you'd bothered to study CS in university like any good person you wouldn't have this problem."
04:37:07 <milfjord> ^ not helpful either
04:37:29 <JuanDaugherty> funny how you are twisting what was actually said into these supposed quotes
04:38:09 <milfjord> the first version is what you just described
04:38:09 <JuanDaugherty> this is text, that doesn't work so well here
04:38:20 <milfjord> the second version is how what you actually said came across
04:38:57 <JuanDaugherty> it's your reading. From here: =;
04:39:23 <milfjord> mine and apparently rgr's reading
04:40:02 <lllllllllllll> but not mine, can't make it right for everyone
04:40:24 <teneen> do lazy values incur any cost after they've been fully evaluated?
04:40:31 <milfjord> I still don't see how that was supposed to be helpful even if your paraphrasing was correct
04:40:54 <teneen> is there always a check for whether they've been evaluated or not?
04:40:55 <milfjord> as in: what was the problem you were trying to solve?
04:40:56 <sipa> ~
04:41:10 <lllllllllllll> #
04:41:13 <sipa> JuanDaugherty: in what way do you think you helped him?
04:42:04 <haasn> teneen: GHC will rewrite evaluated thunks with their results; that said there's no guarantee that the same expression won't be represented in two distinct thunks
04:42:13 <milfjord> teneen: I think values have an associated piece of machine code that's responsible for generating a result
04:42:38 <haasn> teneen: eg. if you apply the same function to the same parameter twice in difference places, GHC will most likely evaluate that twice
04:42:50 <JuanDaugherty> sipa, by addressing the root cause of his confusion, making clear what the general reception in this channel really was, and the matter of fact with respect to the query.
04:43:13 <sipa> JuanDaugherty: i wish i could kick you now
04:43:19 <milfjord> JuanDaugherty: wait. elaborate on "root cause of his confusion"
04:43:32 <milfjord> what is the root cause?
04:44:01 <milfjord> teneen: when you evaluate something for the first time, that code pointer is updated to just return the result immediately
04:44:09 <sipa> to me it sounds like you said "you misunderstand because you were educated incorrectly"
04:44:11 <haasn> teneen: I'm pretty sure there are various ways of inspecting the representation of values at runtime in GHC, search through some of the libraries and you might find it
04:44:13 <milfjord> teneen: there's also some stuff with pointer tagging but I don't know how that works
04:44:25 <sipa> off topic here, actually
04:45:10 <teneen> milfjord: so after evaluating the first time, the next time there will be not any branch in the code when retrieving its value?
04:45:34 <JuanDaugherty> sipa, I'm OK with that.
04:45:44 <milfjord> teneen: I think so, yes
04:46:33 <teneen> milfjord: how can this be implemented?
04:46:57 <milfjord> what do you mean?
04:48:05 <sipa> JuanDaugherty: people come here to learn, please don't yell them away if they want to do so
04:49:01 <JuanDaugherty> sipa, acknowledged. I didn't yell, but I regret not pm'ing the individual instead. I could defend the course taken though.
04:50:02 <milfjord> JuanDaugherty: I think you've completely misunderstood the issue
04:50:35 <sipa> to me you just sound elitist
04:51:37 <Maior> well this doesn't sound like the #haskell I remember
04:52:05 <milfjord> didn't we used to have Smerdyakov in here?
04:52:10 <JuanDaugherty> depending on how you define that I may be. I'm not an academic though and there are 1200 others in this channel many if not most of whom are
04:52:40 <haasn> @where ops
04:52:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:52:45 <milfjord> haasn: yes?
04:54:21 <haasn> milfjord: I'm not sure whether JuanDaugherty is trying to intentionally aggravate, I wanted an op to decide
04:55:23 <JuanDaugherty> I am not.
04:55:24 <milfjord> I've been on the other side of the fence before so benefit of the doubt, etc
04:55:27 <rgr> JuanDaugherty: now Ive simmered off a little. (1) I have a electronics/cs degree from a while back but that  is NOT the issue. The issue is that I asked a Q and people were helping. Yuor comments were insulting and a put down. You have no idea who I am, what my experiecnes are in the same way I have zero interested in your 4 year CS degreee.
04:55:31 * hackagebot timezone-olson 0.1.3 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.3 (YitzGale)
04:56:08 <rgr> my typing reflects my annoyance. Anyway. Water under the bridge. Over.
04:56:15 <JuanDaugherty> rgr, I didn't mean them to be and you can consult the log. The discussion since you left has been about my attempt to help you.
04:56:57 <JuanDaugherty> you may want to look at the wikipedia article on currying
04:56:59 <milfjord> rgr: my impression is that JuanDaugherty really thinks he was helpful, which only makes sense to me if he's completely misunderstood the problem
04:57:18 <milfjord> so ¯\(°_o)/¯
04:57:31 <rgr> He obviously did. Im sure he feels he was being helpful. I feel he was rude and condescending. But its over now and no hard feelings.
04:57:41 <JuanDaugherty> great
04:58:26 <sipa> rgr: you could do this: let add2 = add 2 in add2 5
04:58:36 <sipa> rgr: which would result in 7
04:59:00 <sipa> (add 2) on itself returns a function, which again takes an integer
04:59:18 <sipa> you can give that function a new name even
04:59:28 <jophish> There is a lot of shared code between my kind checker and my type checker
04:59:37 <haasn> jophish: go the Agda route and unify them
04:59:49 <jophish> haasn: That would be quite a modification to Haskell98
04:59:52 <Iceland_jack> @let add = (+) :: Int -> Int -> Int
04:59:53 <lambdabot>  Defined.
04:59:54 <Iceland_jack> @ty add
04:59:55 <lambdabot> Int -> Int -> Int
04:59:58 <Iceland_jack> @ty add 2
04:59:59 <lambdabot> Int -> Int
05:00:01 <Iceland_jack> @ty (add 2) 5
05:00:02 <lambdabot> Int
05:00:08 <haasn> jophish: {-# LANGUAGE Agda #-}? :)
05:00:09 <Iceland_jack> rgr: Does that make sense?
05:00:13 <skypers> @source add
05:00:13 <lambdabot> Unknown command, try @list
05:00:16 <skypers> @src add
05:00:16 <lambdabot> Source not found.
05:00:21 <milfjord> skypers: IT'S RIGHT THERE
05:00:25 <Iceland_jack> skypers: 'add = (+) :: Int -> Int -> Int' :)
05:00:30 <jophish> haasn: perhaps once Haskell98 is done :)
05:00:40 <skypers> I didn’t know we could leave a function without a binding
05:00:42 <rgr> I'll have to save this and come back. Sunday walk beckons. Thanks folks.
05:00:43 <skypers> milfjord: no it’s not
05:00:49 <milfjord> yes, it is
05:00:52 <haasn> skypers: add = (+)
05:00:53 <skypers> oh
05:00:54 <skypers> yeah
05:00:56 <milfjord> <Iceland_jack> @let add = (+) :: Int -> Int -> Int
05:01:04 <skypers> weird way of declaring a function
05:01:21 <sipa> it's not declaring a function
05:01:23 <milfjord> depends on what you mean by declaring
05:01:28 <sipa> it's defining add
05:01:44 <haasn> sipa: I don't see a meaningful distinction between those terms
05:02:03 <sipa> add :: Int -> Int -> Int
05:02:05 <milfjord> what, declaring and defining?
05:02:10 <sipa> would be a type declaration
05:02:21 <haasn> function declarations are declarations too
05:02:24 <haasn> and they define functions
05:02:29 <sipa> the definition above is just taking (+) and giving it the name add
05:02:31 <milfjord> declarations generally don't define
05:02:40 <skypers> we don’t care guys…
05:02:48 <milfjord> skypers: but we do
05:03:00 <skypers> stop masturbating on everything dammit!
05:03:01 <skypers> :)
05:03:09 <haasn> The top level of a module consists of a collection of declarations, of which there are several kinds, all described in Chapter 4. Declarations define things such as ordinary values, datatypes, type classes, and fixity information.
05:03:11 <haasn> straight out of the report
05:03:21 <sipa> hmm, ok
05:03:28 <milfjord> yeah, different vocabulary
05:03:29 <sipa> seems my terminology is wrong then
05:03:34 <haasn> it's all fine :)
05:03:49 <haasn> terms are flexible
05:03:50 <milfjord> sipa seems to be using the C terms (because that's what I do)
05:03:56 <sipa> yeah
05:03:57 <Iceland_jack> #haskell seems strange today
05:04:01 <Rembane> +1
05:04:07 <Rembane> Something in the air...
05:04:22 <sipa> it's that februari 16 smell
05:04:24 <milfjord> you think that's air you're breathing?
05:04:35 <sipa> ha
05:04:37 <Rembane> milfjord: That might explain a lot.
05:05:35 <milfjord> http://youtu.be/lVj7J-78Gu8
05:07:07 <rgr> ok ghci/analysis Q .. I couldt leave it. I get it now. BUT lets say I have (ghci): let mm= max 1
05:07:38 <milfjord> :t max 1
05:07:39 <lambdabot> (Num a, Ord a) => a -> a
05:07:45 <sipa> @let mm = max 1
05:07:46 <lambdabot>  Defined.
05:07:49 <Iceland_jack> > mm 0
05:07:52 <lambdabot>  1
05:07:53 <Iceland_jack> > mm 1
05:07:55 <lambdabot>  1
05:07:55 <Iceland_jack> > mm 2
05:07:56 <lambdabot>  2
05:08:02 <Iceland_jack> > mm 52 -- etc.
05:08:04 <lambdabot>  52
05:08:07 <rgr> cna I later "see" (as in debugging type mode) what mm is? Some sort of "inspect". ":t mm" gives me what I want and as expected .. afunction taking an int and returning an int.
05:08:08 <milfjord> > map mm [-3 .. 3]
05:08:10 <lambdabot>  [1,1,1,1,1,2,3]
05:08:12 <Iceland_jack> rgr: :type?
05:08:13 <haasn> rgr: :i
05:08:27 <Iceland_jack> :info (:i) also works
05:08:47 <sipa> :type mm
05:09:00 <bennofs> rgr: :i gives you the place of defintion
05:09:19 <rgr> yeah that shows me where defined and type but is there an inspector which shows immiedtately that its "really" a partial function "max 4"
05:09:41 <haasn> rgr: I don't think so
05:09:45 <Iceland_jack> rgr: You want to see the function source, that's not possible
05:09:45 <rgr> (I probably wont need it I just wanted to query it after I realised what you guys were explaining)
05:09:56 <rgr> ok. thans.
05:10:05 <bennofs> rgr: I don't think there is such a think. In optimized code, this won't work anyway, because it might be inlined
05:10:13 <bennofs> s/think/thing/
05:10:19 <rgr> sure nothing works in optimised code in any lanuage ;)
05:10:22 <sipa> it's not a partial function!
05:10:39 <sipa> > id max 2 5
05:10:41 <lambdabot>  5
05:10:45 <rgr> sipa: explain the vocab I would use there?
05:11:05 <milfjord> rgr: "partially applied"
05:11:06 <haasn> sipa: “partial” tends to mean “returns undefined for some input values (other than undefined)”
05:11:09 <Iceland_jack> partial application
05:11:12 <haasn> err, rgr
05:11:19 <rgr> ok thats what I should have said I guess, thanks.
05:11:34 <sipa> > id max 2 e
05:11:35 <Iceland_jack> It was clear from context what you meant rgr
05:11:36 <lambdabot>  max 2 e
05:11:40 <rgr> I thought so.
05:11:42 <sipa> ha
05:11:58 <Iceland_jack> As an aside note rgr, head is a ‘partial function’ since it's not defined for the empty list
05:12:00 <Iceland_jack> > head []
05:12:02 <lambdabot>  *Exception: Prelude.head: empty list
05:12:20 <sipa> rgr: yeah, i was jusr commenting on the terminology, it was clear
05:12:47 <rgr> and you are right to. Its important to get it right from day one. Now walk then reread then reconfused then light on!
05:12:58 <haasn> (of course, since all functions have exactly one parameter it would be just as right to claim that “partial applications” don't exist in Haskell)
05:13:16 <sipa> ^ that is what i wanted to say
05:13:24 <milfjord> it all depends on the level of abstraction you're thinking at
05:13:49 <user_1> hi
05:13:53 <haasn> operator sections certainly look like it.
05:14:01 <sipa> for operators i guess you can talk about partial applications at the syntax level
05:14:12 <Iceland_jack> hi user_1
05:14:32 <sipa> as the normal way of calling them takes two arguments
05:14:53 <user_1> is haskell good for GUI?
05:14:57 <bennofs> rgr: if you load the definition from a file (using ghci <filename>.hs), you can use :list <identifier> to show the source code. I don't know why this doesn't work for let bindings inside GHCi
05:15:05 <user_1> can one build word processors with it
05:15:13 <user_1> for example
05:15:19 <bennofs> user_1: yi is a haskell editor
05:15:19 <erthalion_> ~
05:15:41 <haasn> user_1: I think the only usable bindings to GUI toolkits are for Gtk and wxwidgets, and I'm not sure how well they work cross-platform
05:15:45 <haasn> that is a point of concern
05:16:36 <bennofs> There is also threepenny-gui, which works using the browser as a display
05:16:56 <Iceland_jack> GUI's are not Haskell's strong suit
05:17:24 <user_1> I was wondering because of the functional language bit
05:17:24 <haasn> I sort of have the feeling it would be easier to design a nice GUI using one of haskell's various web platforms than using Gtk etc :)
05:17:44 <haasn> user_1: it's not a manner of principle, it's more that nobody has really made nice GUI bindings yet
05:17:59 <user_1> ah
05:17:59 <haasn> user_1: afaik most of development is held up because there's not an optimal cross-platform GUI framework in place to base it on
05:18:18 <user_1> openGL?
05:18:34 <Yaniel> opengl is not a GUI framework
05:18:49 <bennofs> openGL is bad because it does not integrate with other desktop apps
05:19:07 <ilmig> Qt comes pretty close, though...
05:19:08 <Yaniel> that could get better with wayland?
05:19:09 <bennofs> theming is difficult to get right, I don't know about things such as copy-paste / drag and drop
05:19:12 <user_1> bennofs what do you mean by integrate?
05:19:24 <haasn> ilmig: there are no stable qt bindings for haskell yet I think
05:19:55 <ilmig> yes, unfortunately
05:20:24 <bennofs> user_1: well, I don't know how you could make an OpenGL gui that matches the desktop look & feel (theming, etc)
05:20:39 <bennofs> asrt890ß+
05:20:46 <user_1> ah
05:20:48 <ilmig> but if there were, writing cross-platfrom gui applications in haskell would be possible (and probably quite easy)
05:22:03 <haasn> bennofs: assuming, of course, that there even is a “desktop look & feel” on the platform :)
05:22:15 <ilmig> although I don't know how good Qt's OO style would map to FRP...
05:22:27 <ilmig> this would probably be one of the main challenges
05:22:35 <haasn> isn't Qt's API based on C++ or something?
05:22:46 <bennofs> There is a QtQuick binding for haskell, though
05:23:22 <Yaniel> but QtQuick is almost its own language isn't it?
05:24:04 <bennofs> yes, it is. But it can be used to write a GUI for a haskell application, so you can use haskell as the backend
05:24:11 <user_1> but what about things like responsiveness, threading, and stuff like that?
05:24:32 <haasn> user_1: Haskell is quite good at threading and other concurrent models
05:24:55 <haasn> user_1: Haskell is also good at abstracting these things away via stuff like arrows (or monads)
05:24:58 <Iceland_jack> user_1: Very good
05:25:05 <ilmig> user_1: one would probably use functional reactive programming
05:25:21 <ilmig> see http://www.haskell.org/haskellwiki/Functional_Reactive_Programming for instance
05:26:09 <Iceland_jack> FRP probably won't help user_1 much, I suggest user_1 looks at LYAH if they want to familiarize themselves with Haskell a bit
05:26:09 <Iceland_jack> @where lyah
05:26:09 <lambdabot> http://www.learnyouahaskell.com/
05:27:12 <bennofs> @hackage hsqml -- The QtQuick binding I mentioned, the darcs repo has a commit from 2 days ago, so I guess it's maintained (even supports Qt5! :)
05:27:13 <lambdabot> http://hackage.haskell.org/package/hsqml -- The QtQuick binding I mentioned, the darcs repo has a commit from 2 days ago, so I guess it's maintained (even supports Qt5! :)
05:28:38 <user_1> I think this FRP is what I wondered about
05:30:37 <user_1> but, yes, it is hard to understand this monad stuff
05:30:59 <Iceland_jack> Have you written any Haskell code before user_1?
05:30:59 <haasn> if you're new to haskell I suggest not stressing over monads too much
05:31:00 <user_1> each time I tried to learn haskell, I quitted when I got to that part
05:31:11 <ilmig> user_1: I think you would need an intermediate knowledge and unterstanding about haskell to really understand and use FRP, though.
05:31:44 <haasn> spend time familiarizing yourself with data types and type classes first and monads will more than not click into place eventually
05:32:15 <user_1> i know data types stuff
05:32:30 <user_1> and type classes
05:32:33 <Ikarus> what is a decent tool for writing small parsers in haskell ?
05:32:56 <haasn> Ikarus: attoparsec is a popular choice for small, lightweight, fast parsers
05:33:09 <haasn> Ikarus: parsec is the more standard parsing library
05:33:12 <erthalion> __
05:33:42 <Ikarus> and any alternatives to those two ? (I didn't quite enjoy tinkering with either of them previously)
05:34:20 <bennofs> parsers (which abstracts over which one to use by using typeclasses), tifecta
05:34:27 <b__> what libraries can I use for tile-based games besides OpenGL/GLUT?
05:34:28 <bennofs> polyparse
05:34:40 <bennofs> b__: Maybe gloss?
05:34:46 <bennofs> b__: or SDL?
05:34:46 <Ikarus> cool, I'll go read up on them, thanks :)
05:34:52 <haasn> Ikarus: there are a few I can think of but they're mostly based on same or similar APIs with different capabilities here and there; trifecta comes to mind as a very powerful parser. Another thing that comes to mind is stuff like binary/cereal which is for working with binary input
05:35:03 <b__> bennofs: cool! lemme google that for myself
05:35:16 <haasn> eg. if you were to write a parser for the file header of some format, binary would probably be more useful than parsec
05:35:17 <bennofs> b__: there are also SFML bindings for haskell
05:35:28 <haasn> +1 to gloss :)
05:35:45 <haasn> you could probably even use diagrams! but I have no idea if getting the interactive would work well ;)
05:36:00 <haasn> them*
05:36:01 <Ikarus> haasn: I am working with a braindead simple little language, so I am mostly trying to avoid spending too much time working on figuring out the parsing lib :)
05:36:14 <b__> bennofs, haasn: great, thanks
05:36:28 <haasn> Ikarus: oh, definitely spend time figuring it out, it will most likely come in handy often!
05:36:52 <Ikarus> haasn: yes, but not right now :P
05:37:04 <haasn> Ikarus: parsec has a very small overhead, there's nothing wrong with defining a Parser for something that's fundamentally very simple, either; ie. you don't have to write a 30-line boilerplate wrapper or anything
05:37:07 <Ikarus> haasn: I've got the rest of the code written, I just need to get a parse tree to feedit :P
05:37:08 <haasn> ah, okay :p
05:39:41 <haasn> the simplest way to write a solid parser using Parsec is to define an ADT for your language and write a Parser for each type involved, eg. data Expr = Foo Expr Expr | Bar Expr;  exprParser = text "foo" *> (Foo <$> exprParser <*> exprParser)  <|>  text "bar" *> (Bar <$> exprParser)
05:39:48 <haasn> not sure how much that will help you if you don't know the API
05:39:58 <haasn> (although most of that is just Control.Applicative syntax)
05:42:59 <Ikarus> haasn: anyway, this is actually the first time I needed a parser in Haskell, despite having tinkered with it quite a bit, but I am a polyglot, so I tend to grab Perl or C (bison is delicious0, or Python if I have to do parsing
05:43:15 <Ikarus> but we'll see, I might use it moree
05:45:00 <haasn> I've started using applicative parsec-style parsers in other languages as well, heh :)
05:46:07 <Ikarus> I'm at the point that I am starting to write patches for Bison and wishing it would behave a little more and do type resolution and such....
05:46:46 <Ikarus> (that is one hell of a patch, but it might grow out of my current patch for implementing impotent/omnipotent choices)
05:50:36 * hackagebot dns 1.1.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.1.0 (KazuYamamoto)
05:58:17 <rgr> could someone patiently  explain the error on the definition of myPartMax = myMax 4. I dont see it. Why doesnt Ord suffice? http://dpaste.com/1625494/
05:59:02 <milfjord> what's the error?
05:59:44 <Twey> rgr: The type of myMax is Ord t ⇒ t → (t → t).  In myPartMax you've provided it with a t and expected a t back, but it will give you (t → t) back.
06:00:00 <Twey> Oh, wait, misread, sorry
06:00:20 <milfjord> ... this is why you should include the error message
06:00:22 <haasn> rgr: you can't ‘print’ a function
06:00:33 * milfjord sighs
06:00:34 <haasn> rgr: specifically, there's no Show instance for functions
06:00:44 <haasn> oh
06:00:45 <Twey> Nope
06:00:48 <Twey> It's not a function
06:00:49 <haasn> yes, he should include an error :)
06:00:59 <Twey> rgr: You've used a literal ‘4’ in the place of a ‘t’
06:01:29 <haasn> Twey: is right
06:01:29 <Twey> rgr: That means that t must be Num, since only Num things can be written as numerals, but you haven't specified the Num constraint in the context
06:01:38 <Twey> :t 4
06:01:40 <lambdabot> Num a => a
06:01:50 <rgr> Twey: you'll need to elaborate there .. sorry.. I thought that it would auto "bind it" to an Ord type.
06:02:14 <haasn> rgr: Many things are instances of Ord; for example String:
06:02:16 <milfjord> rgr: you still haven't pasted the error message
06:02:18 <haasn> > "hello" < "world"
06:02:20 <lambdabot>  True
06:02:37 <haasn> rgr: since your function can be instantiated to any ‘t’ which is an instance of Ord, I could call it on a string too
06:03:11 <haasn> but 4 isn't a String (more specifically: String isn't an instance of Num)
06:03:34 <milfjord> > 4 :: String
06:03:35 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
06:03:35 <lambdabot>    arising from the literal `4'
06:03:35 <lambdabot>  Possible fix:
06:03:35 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Base.String)
06:03:52 <Twey> (you can write a Num instance for it, but that's evil :þ)
06:04:07 <rgr> thats what I thought. Hmm.
06:04:23 <milfjord> you may get a better error if you nail down the type of 4 to (4 :: Integer) or something
06:04:47 <haasn> you can also look at what GHC infers for the type of “myPartMax” and compare it to what you have written
06:04:59 <haasn> :t max 4
06:05:00 <lambdabot> (Num a, Ord a) => a -> a
06:05:11 <milfjord> that'll be monomorphed down, though
06:05:23 <milfjord> DMR, etc
06:06:29 --- mode: ChanServ set +o milfjord
06:06:29 --- mode: milfjord set +b emma!*@*
06:06:49 * Twey blinks.
06:07:39 <rgr> ok, so myPartMax :: (Num t, Ord t) => t -> t "fixed" it. I need to go through that again ;) Clearyl I'm a while away from full type mastery..
06:08:01 <milfjord> basically: the caller chooses t
06:08:21 <milfjord> if you omit Num t, the caller is free to choose a t that has nothing to do with numbers
06:08:29 --- mode: milfjord set -o milfjord
06:08:30 <milfjord> but you can't compare that to 4
06:08:59 <milfjord> > max 4 "hello"
06:09:00 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
06:09:00 <lambdabot>    arising from the literal `4'
06:09:00 <lambdabot>  Possible fix:
06:09:00 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
06:09:53 <haasn> Sometimes I wonder if it would be a good idea to augment GHC with a list of instances that *shouldn't* be recommended as possible fixes
06:10:53 <milfjord> > max (4 :: Integer) "hello"
06:10:54 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
06:10:54 <lambdabot>              with actual type `[GHC.Types.Char]'
06:11:15 <zipper> Ping anyone?
06:11:20 <zipper> Am I online?
06:11:23 <milfjord> zipper: no
06:16:31 <haasn> I guess he took your reply literally
06:17:12 <milfjord> his client was already unresponsive to ctcp ping/version
06:17:44 <haasn> then it looks like your answer was accurate :)
06:17:59 <beckenrandposer> Hi. I thought I'd take the ghc 7.8 RC for a spin. However, I'm not sure how to proceed with cabal-install. I read somewhere that the RC should play nicely with the old cabal-install... but packages that I had previously installed can no longer be found. Reinstalling them creates a new ghc-7.8 folder in the respective .cabal/lib directory which makes sense, but ghc still does not find the package. Any hints?
06:23:03 <hpc> beckenrandposer: run "cabal update" to get the package db again
06:25:39 * hackagebot chatty 0.2.0.1 - Some monad transformers and typeclasses to simplify I/O on a transformer stack.  http://hackage.haskell.org/package/chatty-0.2.0.1 (implementation)
06:25:41 * hackagebot pipes-attoparsec 0.4.0.1 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.4.0.1 (RenzoCarbonara)
06:26:41 <Taneb> @hoogle [a -> Maybe b] -> a -> Maybe [b]
06:26:42 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:26:43 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
06:26:43 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
06:27:08 <Taneb> > mapM [const Nothing, const $ Just "hi"] 4
06:27:09 <lambdabot>  Couldn't match expected type `a0 -> m0 b0'
06:27:09 <lambdabot>              with actual type `[b1 -> Data.Maybe.Maybe [GHC.Types.Char]]'
06:27:18 <Taneb> > mapM [const Nothing, const $ Just "hi"] [4]
06:27:19 <lambdabot>  Couldn't match expected type `a0 -> m0 b0'
06:27:19 <lambdabot>              with actual type `[b1 -> Data.Maybe.Maybe [GHC.Types.Char]]'
06:27:30 <Taneb> :(
06:27:52 <Taneb> > mapM ($ 4) [const Nothing, const $ Just "hi"]
06:27:53 <lambdabot>  Nothing
06:27:55 <Taneb> :D
06:28:08 <no-n> :}
06:28:13 <no-n> > Nothing
06:28:14 <lambdabot>  Nothing
06:28:17 <no-n> :D
06:28:28 * no-n dances
06:28:53 <beckenrandposer> hpc: thanks, but I already did that. ghci tells me to check for "dyn" libraries. As far as I now ghc moved to dynamic linking, right? So do I have to somehow tell cabal that I want to dynamically link against the libraries in question?
06:36:28 <cmiller_> Hi all I'm getting a strange error when compiling some code I wrote.
06:36:30 <cmiller_> ghc: panic! (the 'impossible' happened)
06:36:31 <cmiller_>   (GHC version 7.6.2 for x86_64-unknown-linux):
06:36:33 <cmiller_>         Simplifier ticks exhausted
06:36:35 <cmiller_> Any ideas?
06:38:05 <hpc> cmiller_: reduce your code to the simplest thing that reproduces the bug
06:38:13 <hpc> panics are always bugs
06:38:32 <cmiller_> It's an optimization thing right?
06:38:45 <cmiller_> Cause it only happens with -O2
06:39:00 <merijn> Oh
06:39:14 <merijn> Naah, it's not a bug, well depending on your definition
06:39:24 <cmiller_> A me bug or a GHC bug?
06:39:34 <hpc> a ghc bug
06:39:36 <cmiller_> kk.
06:39:45 <merijn> cmiller_: To avoid GHC from infinite looping when there's a lot inlining there's a maximum tick count for time it's allowed to optimise
06:39:51 <merijn> cmiller_: And it ran out
06:40:18 <merijn> cmiller_: It *could* be a GHC bug, but more likely your code has a lot of inlined things (especially if you've used the inline pragma)
06:40:50 <cmiller_> I tried setting -fsmpl-tick-factor=Insane and it ran out of memory. I have no explicit inlines. It's just some code that wraps around a fortran library.
06:41:12 <merijn> cmiller_: Right, at any rate, may wanna bring it up with the guys in #ghc
06:41:36 <hpc> merijn: the fact that it says panic makes it a bug
06:41:37 <cmiller_> KK I'll futz a little first.
06:41:49 <hpc> if it's something that potentially happens with normal code, it should have a nicer error
06:43:00 <merijn> hpc: Well, it's not supposed to happen
06:43:20 <yitz> hpc: it might not happen with normal code if you don't say -fsmpl-tick-factor=Insane
06:43:22 <merijn> But usually it happens when people get INLINE trigger happy
06:53:54 <cmiller_> Seems to be triggered by lot's of mallocs.
07:01:53 <skypers> do you know an alias for map ($ a)?
07:02:01 <skypers> or fmap ($ a)?
07:02:22 <skypers> edwardk: I know you have something like && in lens, but I don’t want lens yet :D
07:02:31 <skypers> :t (<&&>)
07:02:33 <lambdabot>     Not in scope: `<&&>'
07:02:33 <lambdabot>     Perhaps you meant one of these:
07:02:33 <lambdabot>       `<&>' (imported from Control.Lens),
07:02:37 <skypers> :t (<&>)
07:02:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:02:44 <skypers> not that
07:02:48 <bennofs> :t (&)
07:02:49 <lambdabot> a -> (a -> b) -> b
07:03:17 <skypers> no functor involved, bennofs
07:03:46 <skypers> let l = [(+1),(*2),negate] in map ($ 43) l
07:03:49 <bennofs> skypers: I figured :)
07:03:51 <skypers> > let l = [(+1),(*2),negate] in map ($ 43) l
07:03:53 <lambdabot>  [44,86,-43]
07:04:05 <skypers> > let l = [(+1),(*2),negate] in l <*> pure 43
07:04:06 <lambdabot>  [44,86,-43]
07:04:15 <skypers> I think something might exist for that
07:04:42 <bennofs> :t (??)
07:04:43 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:04:52 <skypers> > let l = [(+1),(*2),negate] in l ?? 43
07:04:55 <lambdabot>  [44,86,-43]
07:04:57 <skypers> nice
07:05:01 <skypers> @index (??)
07:05:01 <lambdabot> bzzt
07:05:06 <skypers> @hoogle (??)
07:05:07 <lambdabot> No results found
07:05:09 <skypers> COME ON
07:05:20 <skypers> is this from lens?
07:05:32 <bennofs> yes
07:05:45 <skypers> dammit
07:06:08 <skypers> isn’t there a way to add that into Data.Functor?
07:06:14 <skypers> well
07:06:19 <skypers> Control.Applicative maybe
07:07:49 <skypers> > Just length ?? "hello"
07:07:50 <lambdabot>  Just 5
07:07:52 <skypers> ahah great
07:08:00 <dwcook> Why Control.Applicative? All it requires is Functor
07:08:14 <bennofs> skypers: It's particular useful with the ((->) a) functor :)
07:08:22 <skypers> because f (a -> b) is Applicative to me
07:08:36 <skypers> > (+1) ?? 1
07:08:38 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
07:08:38 <lambdabot>    arising from a use of `M44458805732113307218282.show_M44458805732113307218...
07:08:38 <lambdabot>  The type variable `b0' is ambiguous
07:08:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:08:38 <lambdabot>  Note: there are several potential instances:
07:08:45 <Rylee> :t (??)
07:08:45 <bennofs> > const ?? 4 $ 5  -- ??  looks like a hole
07:08:46 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:08:46 <lambdabot>  5
07:08:50 <Rylee> :i (??)
07:08:53 <skypers> > (+1) ?? 1 :: Int
07:08:54 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
07:08:55 <lambdabot>              with actual type `(a0 -> b0) -> b0'
07:09:02 <skypers> what.
07:09:21 <dwcook> Having a function inside a functor doesn't imply applicative. Applicative means you can combine things inside two functorial values.
07:09:29 <dwcook> @type (<*>)
07:09:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:09:32 <skypers> you’re right yes
07:10:33 <dwcook> You could instead have made this the method with the same end: f a -> f b -> f (a, b)
07:10:49 <skypers> > (??) (+) 2 1
07:10:51 <lambdabot>  3
07:11:03 <dwcook> (And to retrieve (<*>) from that you just fmap)
07:15:40 <notdan> :t (??)
07:15:41 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:17:10 <notdan> @src (??_)
07:17:10 <lambdabot> Source not found. My brain just exploded
07:17:12 <notdan> @src (??)
07:17:12 <lambdabot> Source not found. :(
07:18:02 <bennofs> notdan: f ?? a = fmap ($ a) f
07:20:43 * hackagebot tamarin-prover-theory 0.8.6.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-theory-0.8.6.0 (SimonMeier)
07:21:57 <osa1> cabal install --dependencies-only says all dependencies are already installed, but cabal build says there are some missing dependencies. how does that work?
07:22:42 <sm> maybe you need to cabal configure again, or cabal clean ?
07:22:42 <bennofs> osa1: did you configure with --enable-tests?
07:23:04 <bennofs> osa1: if yes, you need to use cabal install --enable-tests --only-dependencies to also install the test deps
07:23:22 <osa1> interesting. cabal clean and then cabal build worked, I guess.
07:23:28 <osa1> let me see if compilation ends successfully.
07:25:44 * hackagebot tamarin-prover 0.8.6.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.6.0 (SimonMeier)
07:40:33 <mm_freak_> which library gives me a simple canvas, in which i can blit arrays of pixels?
07:41:36 <Yaniel> sdl
07:42:18 <haasn> mm_freak_: I wonder if gloss-raster could help
07:43:04 <mm_freak_> indeed, gloss-raster seems perfect…  it even uses repa =)
07:43:08 <mm_freak_> thanks
07:47:10 <utkarsh> I have `data Value = I Integer | S String`; what's the best way to filter/select all `I` from a list of `Value`?
07:48:07 <utkarsh> I'm using `filter` and `isI (I _) = True
07:48:07 <utkarsh> isI _ = False` right now.
07:48:20 <dwcook> utkarsh, what's wrong with that?
07:48:22 <skypers> filter isI
07:48:32 <skypers> yeah, what’s wrong with that?
07:48:40 <utkarsh> was just wondering if there's a better/shorter way...
07:48:59 <skypers> shorter than “filter isI”? :)
07:49:06 <skypers> I think it’s pretty straight-forward
07:49:17 <milfjord> [ x | I x <- values ]
07:49:41 <utkarsh> skypers, shorter than defining a separate function "isI" for it..
07:49:53 <skypers> I guess what milfjord quoted
07:49:55 <skypers> but it’s limited
07:49:59 <ion> > filter (has _Just) [Just 4, Nothing, Just 5]
07:50:01 <lambdabot>  [Just 4,Just 5]
07:50:15 <skypers> if you want to express predicates, your isI will just be great
07:50:27 <skypers> I think it’s important to write that function, utkarsh
07:50:27 <dwcook> skypers, limited how? It seems to do basically what was asked
07:50:33 <milfjord> isI :: Value -> Maybe Integer
07:50:35 <skypers> dwcook: in future needs
07:50:52 <ion> milfjord: That’s a bad name for that. :-P
07:51:07 <milfjord> isI :: Value -> a -> (Integer -> a) -> a
07:51:20 <skypers> furthermore utkarsh, you should consider adding a map function
07:51:21 <skypers> like
07:51:47 <skypers> mapIS :: (Int -> a) -> (String -> a) -> Foo -> a
07:51:52 <skypers> well it’s not realy a map function
07:52:00 <skypers> it’s just convenient to use
07:52:01 <dwcook> That's a fold
07:52:03 <skypers> yeah
07:52:05 <skypers> a fold
07:52:09 <Twey> It's an eliminator
07:52:14 <skypers> a terminator.
07:52:16 <skypers> a T1000
07:52:19 <Twey> Not really a fold — there's no recursion involved
07:52:23 <dwcook> Though it's probably overkill unless you had some other use for it
07:52:34 <skypers> Twey: is there recursion on folding a Maybe a?
07:52:50 <Twey> skypers: No, there's no fold for a Maybe a
07:52:54 <skypers> dwcook: just saying, I have a similar data
07:53:01 <skypers> and use such a fold to express a lot of things
07:53:06 <utkarsh> skypers, milfjord, thanks :)
07:53:08 <skypers> Twey: huh?
07:53:12 <milfjord> :t fold
07:53:12 <dwcook> Twey, I think of a fold as something that replaces cases of a type. Lists *are* recursive, and so is their fold.
07:53:14 <lambdabot> (Foldable t, Monoid m) => t m -> m
07:53:36 <milfjord> > fold (Just "hi")
07:53:38 <lambdabot>  "hi"
07:54:13 <dwcook> Twey, though I couldn't really attest that meaning of "fold", it's just how I think of it.
07:54:32 <hpc> > fold Nothing
07:54:34 <lambdabot>  ()
07:54:41 <Twey> dwcook: Sure, but consider the difference between fold ∷ (a → b → a) → a → [b] → a  and  list ∷ (a → [a] → b) → b → [a] → b
07:54:49 <skypers> :t list
07:54:51 <lambdabot>     Not in scope: `list'
07:54:51 <lambdabot>     Perhaps you meant one of these:
07:54:51 <lambdabot>       `last' (imported from Data.List),
07:54:56 <djahandarie> > fold (Nothing :: Maybe String)
07:54:57 <lambdabot>  ""
07:55:24 <hpc> i like how it has to be Monoid m, too
07:55:24 <dwcook> Twey, that's fair. I think a good question is: Given an arbitrary type, how do you define a fold on it?
07:55:37 <hpc> even though mappend is never used, you need its laws to decide what to default to
07:55:38 <notdan> Fold is just mconcat . toList, I guess
07:55:41 <notdan> @src fold
07:55:41 <lambdabot> Source not found. Abort, Retry, Panic?
07:55:44 <notdan> eh
07:55:45 * haasn likes ion's solution best
07:55:54 <haasn> although ‘has’ should be ‘is’ :(
07:55:55 <dwcook> If the method of forming a fold happens to come up with the same thing as maybe on Maybe, then maybe maybe is also a fold :)
07:56:16 <hpc> dwcook: maybe is the fold
07:56:20 <hpc> :t maybe
07:56:21 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:56:22 <Twey> dwcook: I think the usual answer is ‘you can't, unless the type is inductively defined’
07:57:04 <Twey> There's a difference between the concepts of eliminator and catamorphism
07:57:12 <dwcook> Twey, okay, then is there some mechanical way of deriving a fold for any inductively defined type?
07:57:29 <milfjord> church and scott?
07:57:41 <notdan> `fold` is not about catamorphisms IIRC
07:57:51 <dwcook> hpc, that's what I would have contended and what Twey seems to disagree with. I'm open to being convinced either way.
07:58:23 <hpc> dwcook: so, let's assume foldr is a fold, just for the sake of obviousness ;)
07:58:24 <hpc> :t foldr
07:58:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
07:58:37 <hpc> (a -> b -> b) is the "case" for (:)
07:59:07 <hpc> replace instances of the type parameter with 'a' and inductive parts with 'b'
07:59:14 <dwcook> I would be willing to call maybe and list eliminators regardless though, at least for the sake of clarity.
07:59:28 <hpc> result type 'b' (same for the next 'b', which is for [])
07:59:29 <Twey> hpc's got it
07:59:35 <milfjord> maybe is both
07:59:41 <hpc> then the list itself, [a]
07:59:45 <hpc> result is the folded 'b'
08:00:00 <milfjord> if the type isn't recursive, the two folds coincide
08:00:12 <ion> @type GHC.Exts.build
08:00:12 <skypers> :t contramap
08:00:13 <Twey> milfjord: *nod* For non-inductive types the ‘fold’ is trivially just the eliminator
08:00:13 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
08:00:13 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
08:00:16 <dwcook> milfjord, that was my intuition, but I wouldn't know how to state it formally.
08:00:17 <hpc> foldr (:) [] = id -- take the fold, list the constructors as parameters and get a fold that does nothing - important
08:00:22 <Twey> milfjord: I just don't think this is/should be called a fold
08:00:29 <hpc> dwcook: you can go through the same logic for maybe
08:00:30 <hpc> :t maybe
08:00:30 <dwcook> Twey, I'm confused. Did you change your mind then?
08:00:31 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:00:48 <haasn> but is it a catamorphism?
08:00:53 <Twey> That's a better question
08:00:56 <hpc> maybe Nothing Just = id -- same law, with the constructors in the opposite order because haskell is sometimes not as theoretically nice as we would like
08:01:03 <Twey> Don't we have any category theorists around today?  :þ
08:01:16 <haasn> I'll try and figure it out as soon as I wake up.
08:01:24 <Twey> Alright
08:01:45 <bernalex> if I have foo = ["fu", "bar", "baz"], how do I split the members with length > 2? so that we'd get ["fu", "ba", "r", "ba", "z"]?
08:01:53 <hpc> dwcook: whether you can do it for any inductive type mechanically is a good question
08:02:06 <hpc> my intuition says "yes", but i don't know how to deal with things like
08:02:12 <notdan> (Maybe a -> b) is an F-algebra for a functor `Maybe`, right? But (Maybe a -> b) is also (b, a -> b)
08:02:16 <dwcook> hpc, are you saying that a fold is a function such that when supplied with the type's constructors in the correct places it gives id?
08:02:17 <hpc> data Foo a b = Foo a (Foo b a)
08:02:52 <ion> bernalex: Can you think of a way to get [["fu"], ["ba", "r"], ["ba", "z"]]? Then it’s just a concat away.
08:03:12 <milfjord> concatMap (chunksOf 2)
08:03:20 <hpc> dwcook: yes, except that's not really the defining characteristic
08:03:24 <milfjord> > concatMap (chunksOf 2) ["fu", "bar", "baz"]
08:03:25 <lambdabot>  ["fu","ba","r","ba","z"]
08:03:26 <Twey> hpc: You unfold it one step
08:03:47 <hpc> foldr _ _ = id -- this isn't a fold
08:04:00 <dwcook> Ah, of course.
08:04:03 <ion> > chunksOf 2 =<< ["fu", "bar", "baz"]  -- bernalex: Ignore this.
08:04:04 <lambdabot>  ["fu","ba","r","ba","z"]
08:04:12 <hpc> a fold is a replacing of data constructors with passed functions
08:04:19 <no-n> is Haskell Haskell?
08:04:19 <hpc> replacing the constructors with themselves is a nop
08:04:39 <ion> no-n: is “is” “is”?
08:04:43 <hpc> dwcook: er, passed functions and values
08:04:49 <no-n> :D
08:05:30 <hpc> fun fact: ($) is the fold for Identity
08:05:39 <dwcook> hpc, accepting that foldr is a fold, is list :: (a -> [a] -> b) -> b -> [a] -> b ?
08:05:44 <Twey> hpc: Foo a b = Foo a (Foo b a) = Foo a b (Foo a b)
08:05:51 <Twey> hpc: Then proceed as normal
08:05:55 <hpc> Twey: ah, good call
08:06:29 <hpc> there's probably a paper in that unfold operation somewhere
08:06:38 <Twey> (it's easier in algebraic notation, Foo(a, b) = a × Foo(b, a) = a × b × Foo(a, b))
08:06:40 <dwcook> And then maybe the greater question: What's so special about folds (e.g., as opposed to eliminators)?
08:07:02 <Twey> hpc: I don't think so, it's subsumed by W/M types
08:08:26 <hpc> dwcook: googling "haskell eliminator" brings up examples of folds, so i am a bit confused myself too
08:09:25 <hpc> dwcook: anyway, folds are special because in some sense they represent a function for doing any possible computation on a data type
08:09:37 <hpc> dwcook: just pass in a couple of things of the right type and away you go!
08:09:56 <no-n> what is a fold?
08:10:18 <hpc> no-n: scroll up a bit, i explain it about 50 lines up
08:10:33 <hpc> no-n: start with "so, let's assume foldr is a fold, just for the sake of obviousness"
08:11:18 <benmachine> Twey: ok, now do data BT a = Leaf a | Branch (BT (a,a))
08:11:24 <milfjord> writing tail in terms of foldr is annoying
08:11:34 <dwcook> hpc, we could say the same of eliminators in general
08:11:44 <Twey> benmachine: I didn't say it worked for any type :þ
08:11:48 <dwcook> Are we basically just equating folds and eliminators then?
08:11:51 <benmachine> hpc: defining tail with foldr is possible but annoying
08:11:58 <hpc> milfjord: easy, it's just a nested fold ;)
08:12:04 <benmachine> Twey: :P
08:12:04 <hpc> milfjord: (it's not actually easy)
08:12:27 <benmachine> oh how did milfjord say literally the same thing as me and I didn't notice until just now
08:12:30 <benmachine> sorry
08:12:37 <piezo> this reprentation of fold is interesting, but it blew my mind : http://blog.functorial.com/posts/2012-02-02-Polykinded-Folds.html
08:12:39 <benmachine> it's relatively easy, but it's not efficient
08:12:50 <dwcook> tail = foldr (flip const) undefined -- :P
08:13:09 <dwcook> woops
08:13:12 <dwcook> That's totally wrong
08:13:19 <benmachine> heh, phew
08:13:19 <dwcook> milfjord, I see what you mean
08:13:22 <benmachine> you confused me for a moment
08:13:43 <dwcook> Confusion propagates!
08:13:44 <benmachine> you can do it but basically by defining the eliminator and then using that
08:14:00 <hpc> what is the eliminator?
08:14:04 <dwcook> Oh wait, tail is easy in terms of *list*
08:14:10 <benmachine> right
08:14:12 <dwcook> That's what I was thinking of
08:14:18 <dwcook> tail = list (flip const) undefined
08:14:22 <benmachine> hpc: the list :: (a -> [a] -> b) -> b -> [a] -> b thing
08:14:27 <hpc> oh i see
08:14:32 <hpc> @src list
08:14:33 <skypers> :t eithers
08:14:33 <lambdabot> Source not found. Where did you learn to type?
08:14:34 <lambdabot>     Not in scope: `eithers'
08:14:34 <lambdabot>     Perhaps you meant `either' (imported from Data.Either)
08:14:40 <benmachine> hpc: it's not a standard thing
08:14:41 <skypers> where did I see that function
08:14:47 <skypers> @index eithers
08:14:47 <lambdabot> bzzt
08:14:58 <milfjord> skypers: what would it do?
08:15:02 <skypers> @index [Either e a] -> [a]
08:15:02 <lambdabot> bzzt
08:15:16 <skypers> milfjord: it filter on isRight
08:15:19 <skypers> filters*
08:15:25 <skypers> and extract the values
08:15:28 <benmachine> skypers: perhaps you want partitionEithers?
08:16:05 <milfjord> @hoogle rights
08:16:05 <lambdabot> Data.Either rights :: [Either a b] -> [b]
08:16:06 <lambdabot> Graphics.UI.GLUT.Window RightSide :: Cursor
08:16:06 <lambdabot> Language.Haskell.Lexer RightSquare :: Token
08:16:17 <benmachine> ok, so, in the past I did this and decided that absolutely the clearest way to write this was
08:16:17 <skypers> yeah
08:16:20 <skypers> it’s rigts…
08:16:20 <benmachine> uncons = foldr (\x -> Just . (,) x . maybe [] (uncurry (:))) Nothing
08:16:23 <skypers> rights
08:16:26 <skypers> thank you milfjord
08:16:27 <benmachine> I don't really know what that is
08:16:41 <benmachine> see also: drop n xs = foldr (\x dp n -> if n <= 0 then x : dp 0 else dp (n - 1)) (const []) xs n
08:16:48 <notdan> http://paste.hskll.org/get/1042 <-- relation between Maybe, maybe and catamorphism
08:16:54 <notdan> and folds
08:16:58 <skypers> why @index[Either e a] -> [a] fails?
08:17:17 <dwcook> benmachine, if you were going to go that far you might as well remove the x binding as well :P
08:17:21 <notdan> basically, if you have `maybe`, you can express a catamorphism function speciallized to Maybe
08:17:26 <milfjord> skypers: because you don't know what @index does
08:17:53 <skypers> I thougth it gave the module for the symbol
08:18:04 <skypers> thought*
08:18:10 <milfjord> yes
08:18:16 <milfjord> [Either e a] -> [a] is not a symbol
08:18:22 <benmachine> dwcook: yeah I dunno
08:19:04 <benmachine> ah, this is what I was looking for
08:19:33 <benmachine> :t let g x ~(_, xs) = (f x xs, x : xs) in fst . foldr g (z, [])
08:19:34 <lambdabot> Show a => [a] -> Expr
08:19:35 <skypers> 17:11 < benmachine> uncons = foldr (\x -> Just . (,) x . maybe [] (uncurry  (:))) Nothing
08:19:38 <benmachine> er, wups
08:19:38 <skypers> omg…
08:19:45 <notdan> sorry im late to the party, but yeah, you can derive folds for "all" ADTs
08:19:57 <notdan> but the automatic way of doing this is ugly, iirc
08:20:05 <notdan> it's also harder for GADTs
08:20:12 <benmachine> :t let list f z = fst . foldr g (z, []) where g x ~(_, xs) = (f x xs, x : xs)
08:20:13 <lambdabot> <no location info>:
08:20:13 <lambdabot>     not an expression: `let list f z = fst . foldr g (z, []) where g x ~(_, xs) = (f x xs, x : xs)'
08:20:16 <benmachine> :t let list f z = fst . foldr g (z, []) where g x ~(_, xs) = (f x xs, x : xs) in list
08:20:16 <lambdabot> (a -> [a] -> c) -> c -> [a] -> c
08:20:19 <benmachine> there we go.
08:20:36 <notdan> Tim Williams had a post on the subhject
08:20:38 <skypers> what is ~(_,xs) again?
08:20:41 <skypers> the ~
08:20:44 <benmachine> skypers: lazy pattern
08:20:55 <skypers> like ! is for strict one?
08:21:00 <notdan> http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html
08:21:00 <benmachine> yes
08:21:06 <prophile> it's an irrefutable pattern
08:21:11 <skypers> benmachine: it’s lazy as default
08:21:13 <prophile> the laziness sort of just comes with the territory
08:21:19 <skypers> why using a special explicit symbol for that
08:21:27 <milfjord> > case error "zomg" in ~(_,xs) -> ()
08:21:28 <lambdabot>  <hint>:1:19: parse error on input `in'
08:21:33 <milfjord> > case error "zomg" of ~(_,xs) -> ()
08:21:35 <lambdabot>  ()
08:21:41 <benmachine> skypers: pattern matching is strict by default
08:21:45 <milfjord> > case error "zomg" of ~(_,xs) -> ("actually using", xs)
08:21:47 <lambdabot>  ("actually using",*Exception: zomg
08:21:56 <milfjord> > case error "zomg" of (_,xs) -> ()
08:21:57 <lambdabot>  *Exception: zomg
08:22:08 <notdan> benmachine: um, what does that mean?
08:22:09 <benmachine> skypers: well, to be precise, pattern-matching using "case" is strict by default
08:22:36 <notdan> evaluation can be strict or non-strict, but I am not sure I understand how a patern matching can be strict or lazy
08:22:42 <skypers> what’s about let in ?
08:22:47 <notdan> pattern matching as in syntactic construction?
08:22:49 <benmachine> notdan: I mean that f x = case x of (a,b) -> (a,b) is a strict function
08:23:06 <notdan> Usual terminology, from what I've heard, is that ~(..) is an irrefutable pattern match
08:23:10 <benmachine> skypers: let is lazy
08:23:15 <skypers> ok
08:23:19 <dwcook> Irrefutable pattern matching makes it so that the pattern is only evaluated when one of the things it binds needs to be
08:23:23 <skypers> it’s about case of then
08:24:01 <benmachine> skypers: but also function pattern matching, because that's kind of the same thing
08:24:12 <dwcook> And also it always succeeds, but you could end up with bottom if it didn't end up matching
08:24:36 <dwcook> You don't need to worry about that as much for tuples though, which have only one case outside of bottom
08:24:37 <notdan> I guess they are called Lazy patterns after all! http://www.haskell.org/tutorial/patterns.html#tut-lazy-patterns
08:24:42 <notdan> sorry for the noise
08:25:48 * hackagebot aivika 1.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-1.1 (DavidSorokin)
08:25:50 * hackagebot aivika-experiment 1.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-1.1 (DavidSorokin)
08:25:52 * hackagebot aivika-experiment-chart 1.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-1.1 (DavidSorokin)
08:26:22 <Twey> skypers, benmachine: Lazy patterns and strict patterns are quite different.  Lazy patterns actually change semantics (even modulo ⊥)
08:26:37 <Twey> notdan: Pattern-matching is evaluation :þ
08:27:33 <Twey> notdan: To pattern-match on something is to evaluate it to WHNF and switch on the constructor
08:27:52 <Twey> In fact, that's almost the only time evaluation happens in Haskell
08:28:01 <milfjord> how do they change semantics?
08:29:38 <benmachine> milfjord: in terms of case [] of ~(x:xs) -> blah; [] -> blee will take a different branch
08:29:57 <Twey> milfjord: f ~(Just x) = x; f Nothing = 0 -- f Nothing will error
08:30:25 <Twey> > let { f ~(Just x) = x; f Nothing = 0 } in f Nothing
08:30:27 <lambdabot>  *Exception: <interactive>:3:7-36: Irrefutable pattern failed for pattern (Da...
08:30:38 <milfjord> ah, right
08:35:49 * hackagebot mono-traversable 0.3.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.3.0.1 (MichaelSnoyman)
08:35:51 * hackagebot conduit 1.0.15 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.15 (MichaelSnoyman)
08:41:03 <benmachine> notdan: if it makes you feel better, the haskell report refers to ~pat as an irrefutable pattern
08:42:04 <benmachine> notdan: it also says "Matching an irrefutable pattern is non-strict: the pattern matches even if the value to be matched is ⊥. Matching a refutable pattern is strict: if the value to be matched is ⊥ the match diverges. The irrefutable patterns are as follows: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable (see Section 4.2.3), var@apat where
08:42:10 <benmachine> apat is irrefutable, or of the form ~apat (whether or not apat is irrefutable). All other patterns are refutable."
08:42:13 <benmachine> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
08:45:16 <bernalex> ion: milfjord: chunksOf worked great, thanks!
08:47:14 <joneshf-laptop> if i hide a data constructor and only want to export smart constructors, how can i test this with ghci without creating a whole cabal thing and installing it? If I use `:l foo.hs`, it grabs all the constructors and makes them available, and I can't do `:m FooModule` ebcause it's not loaded
08:47:40 <milfjord> compile the file
08:47:57 <bernalex> is there some function that lets me do unlines . f . lines? I find myself often needing to do unlines . lines (and sometimes the reverse)
08:48:30 <joneshf-laptop> milfjord, geez, so simple
08:48:35 <joneshf-laptop> milfjord, thanks!
08:50:10 <Rotaerk_> I didn't find anything on hoogle for this... is there a function with signature (a->Bool)->(a->b)->(a->b)->a->b that operates like an if-then
08:50:29 <Rotaerk_> but where the predicate and the two result clauses get fed the input to the overall function
08:50:54 <Rotaerk_> or something of a different signature that would serve the same purpose
08:51:00 <milfjord> that looks like liftM3 if'
08:51:48 <dwcook> @type if'
08:51:49 <lambdabot>     Not in scope: if'
08:51:49 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
08:51:58 <dwcook> milfjord, if'?
08:52:05 <Rotaerk_> if' doesn't seem to be standard, but I guess I can define it
08:52:20 <Rotaerk_> of  course I could also define the function I'm looking for as well
08:52:26 <Rotaerk_> just wanted to see if there's a standard one
08:52:46 <Twey> Rotaerk_: bool f t p = if p then t else f
08:53:02 <Twey> I think it's defined in a package somewhere, but the definition is as many LoC as the import, so :þ
08:53:10 <dwcook> Twey, missing the (a ->)'s
08:53:10 <Rotaerk_> heh
08:53:20 <Twey> Oh, right
08:53:29 <Twey> chrisdone put that very function in a package somewhere
08:53:46 <Twey> @let bool f t p = if p then t else f
08:53:48 <lambdabot>  Defined.
08:53:55 <dwcook> @type liftM3 bool
08:53:56 <lambdabot> Monad m => m r -> m r -> m Bool -> m r
08:54:03 <Twey> Yeah, I was just going to do that :þ
08:54:05 <notdan> benmachine: yeah, I was confused because "pattern matching" can refer (at least I tend to thingk so) to both evaluation rule, and to the syntactic construct "case .. of "
08:54:10 <Twey> :t liftA3 bool
08:54:11 <lambdabot> Applicative f => f d -> f d -> f Bool -> f d
08:54:31 <milfjord> :t liftA3 bool `asAppliedTo` id
08:54:32 <lambdabot> (a -> a) -> (a -> a) -> (a -> Bool) -> a -> a
08:54:44 <milfjord> :t liftA3 bool `asAppliedTo` unsafeCoerce
08:54:45 <lambdabot> Not in scope: `unsafeCoerce'
08:55:02 <Rotaerk_> the order of your parameters to "bool" seems odd to me
08:55:08 <Twey> Rotaerk_: Ah, here it is: http://hackage.haskell.org/package/bools-0.1.0/docs/Bools.html
08:55:09 <Rotaerk_> also the name
08:55:17 <milfjord> Rotaerk_: maybe, either
08:55:18 <dwcook> It's actually a fold/eliminator for Bool
08:55:27 <Twey> Rotaerk_: The order is for ease of currying
08:55:41 <Twey> Or partial application, rather
08:55:45 <Rotaerk_> hmm k
08:56:03 <Twey> You usually want to produce a function over the predicate; and you almost always want to provide at least a default ‘false’ value
08:56:03 <Rotaerk_> thanks
08:57:25 <Twey> :t liftA3 bool `asAppliedTo` (undefined :: a → b)
08:57:26 <lambdabot> lexical error at character '\134'
08:57:31 <Twey> Hm?
08:57:33 <Twey> Oh
08:57:35 <Twey> :t liftA3 bool `asAppliedTo` (undefined :: a -> b)
08:57:36 <lambdabot> (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
08:57:40 <Rotaerk_> :t cond
08:57:42 <lambdabot>     Not in scope: `cond'
08:57:42 <lambdabot>     Perhaps you meant one of these:
08:57:42 <lambdabot>       `cons' (imported from Control.Lens),
08:57:51 <Twey> haasn: Are you awake yet?  :þ
09:02:10 <dwcook> Was that a lambdabot or compiler lexical error?
09:02:17 <Twey> haasn, notdan, hpc, milfjord, dwcook: http://www.haskell.org/haskellwiki/Catamorphisms — by this definition I think maybe is not a catamorphism/fold
09:02:34 <Twey> dwcook: lambdabot has UnicodeSyntax turned on for @src but off for @type, for some reason
09:48:45 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
09:48:45 --- topic: set by monochrom on [Sat Nov 23 20:32:31 2013]
09:48:45 --- names: list (clog Rarrikins AndroUser2 Itkovian angerman massudaw llllllllllllll negatratoron dagnachew ademidov foxnorth matessim authchir Mongey x77686d pvt_petey mmmm_ seschwar ericmathison khyperia killerswan hiroakip _derek Dawgmatix mithsv johtso Lethalman S11001001 ndrei [[zz]] NemesisD kayloos linduxed kilian0815 tych0 mikeI obiwahn canta avaritia meoblast001 coeus alexherbo2 m3ga ologNation cdidd epta funfunctor estebistec razieliyo_ nullcone adek Swizec xahry)
09:48:45 --- names: list (cow-orker oleo b__ BasDirks_ nemesit|- sigma914 jhinkle_ [1]Endy igro MercurialAlchemi johannesbodannes GodsDeceiver innertracks1 Boney_ asQuirr__ ulfdoz xplat_ lzm_ Corey_ Guest72638 jackhill_ saarin Saizan Kron__ confound_ lattenwald earthy_ maurer_ magicman_ mrpantoufle subleq_ ciaranm sunnavy_ copton_ fiddlerw1aroof carum_ Aetherspawn Atran_ srcerer_ tromp__ ananthakumaran1 iXeno_ arpunk` stevejb` maexono_ grady_player rtmt pantsman- yarou_)
09:48:45 --- names: list (favetelinguis|3 mlen Revenrof user_1_ cwraith kcj skuggi_ twanvl recycle _boegel_ mreh Mortomes bsqrd jrmithdobbs psychicist_ Rotaerk_ David elton_ _halleck_ shesek mizu_no_oto uvelichitel phischu voxpopuli anRch redwire Watcher7 enthropy Zihao prophile tiffany quchen_ ZioCrocifisso nataren Feuerbach trism edwardk phienone sShintah rtpg S_T_A_N shock_one zimmermann smerz darthdeus chidy Soft doomlord_ bergey lieven_ bananagram nadirs ndeine xinming)
09:48:45 --- names: list (colDrMcBeardman kotk squimmy alpounet desheng joe9 dgpratt JohnTortugo timemage Reite Vince_Juicy hiptobecubic armyriad peterhil hpc cmiller_ epsilonhalbe ps-auxw xcthulhu dougdougdoug timmot Noldorin jro_ snhmib YOLO tromp_ Sorella beckenrandposer piezo goldkatze emma paper randomclown PJBoy dwcook jxv Thulsadum jetho Ikarus mirpa pfurla derdon Betal klaut r444 edsko ec ioanel JobV gthorslund rgr Philonous alang yorick OlegYch lemao sellout- no-n ceii)
09:48:45 --- names: list (Freeman42 Jeanne-Kamikaze jesyspa ls__ Ralith ronbrz nomeata thunderrd jophish tg ompaul Okasu Thooms Fabianius poulson boegel|work Dodek KorriX killy9999 cjsarette mornfall yesthisisuser jackneill sepp2k d__ wuqq filo3sofie m1dnight gelardi_ MindlessDrone _sebastian_ Irrenhaus3 kludge` Roklobsta tomboy64 phyrex1an mm_freak_ matheus23 snuderl fikusz_ shintah netogallo nkoep SoupE catalyst jbauman vernon_ nichtdiebohne noam dzhus ktosiek_ maximumsteve)
09:48:45 --- names: list (totimkopf Wizek aleksejs_ wrb ersran9 silver synonymous |tch alanz MrWoohoo hvr dolio treehouse ckw Shin-LaC nisstyre jefimenko Zalami nilg` saiko-chriskun bytbox vili Khisanth Neqoxec percival__ tessier binq Raynos seanparsons kcliu Cerise augur ft caligula milfjord otto_s natte richo pranz ttuegel ijp tdammers ryanbooker docsis sweeks ``rawr_ joshsz lacrosse shanse jzelinskie donri zachmassia posco__ Scorchin seliopou thasc cognominal ido Excureo tv)
09:48:45 --- names: list (b2coutts apaku knigitz q66 gunn Nyyx sxn ezyang akurilin ousado monokrome xymox Olive` oakwhiz_ predator117 araujo ParahSailin aqa enolan ixti marsam jle` __jim__ suOya_ waterlaz jmbto ggherdov sirdancealot LnL puzza007_ DarkLinkXXXX__ yumike_ tabemann Kobata guampa orzo Plasmastar nilg pgavin zz_robj_ Igloo dv- chirpsalot plhk jibi tavelram ryantrinkle tlevine SamuraiMark sleuth_ Enigmagic lpsmith jakutis jizanthapus arrdem centrinia japesinator dsirenko_)
09:48:45 --- names: list (t7 Sonderblade Yaniel milessabin whaletechno maaku pjdelport TheBrayn Kruppe l4u heaumer hackagebot keyvan verement nus dilinger saep MK_FG Sauvin Sculptor ivan\ codesoup brushlandBhai ejls isaacd wollw bjz ormaaj gibsonfs Axman6 gspr speckle Sgeo hamishmack wchun sclv jcurbo papna zalzane joneshf-laptop tomprince l0st1 purefn hellome c_14 jack_rabbit gemelen jedai Pullphinger arnihr DrAwesomeClaws asQuirreL ikkebr sm DasIch deni Dashkal omefire1 FreeFull)
09:48:45 --- names: list (superjudge et|kkl helmut ccasin zoktar effy merijn kylcarte Twey majoh qz Iceland_jack integral erikl_ supki jlouis ski hongminhee drAgda ahf npcomp jaffachief bobobo1618 byorgey wting zerokarmaleft callumacrae Liskni_si dqd fryguybob u_ dreixel iNode000 niko krakrjak hpd mrmonday Shou voyd bhek AleXoundOS ryanakca mniip julmac kragniz Syneh uncleBlazer simpson katis eyenx`off _d3f HalfWayMan kshannon defanor mikeplus64 tpsinnem tov rasmusto mirsal yriw)
09:48:45 --- names: list (mtlatif_ TakSuyu bounb Bigcheese gereedy Vbitz carter passiveobserver leifw divyansr__ petantik bxc heath mandu levi shutdown_-h_now mm_bureau buckmaster zomg bbloom dropdrive ZsoL bd_ Martingale cross monochrom jaimef cmears keithflower stbuehler estewei1 theorbtwo ConstantineXVI yan_ j2j osa1 skypers bjorkintosh nwf buttpirate etabot Guest51919 shergill lamilami kxra mixi ezrios waxjar adlan AntiSpamMeta DT`` ixian gienah jlamothe slobo utkarsh davorb)
09:48:45 --- names: list (stelleg Hafydd bernalex finnrobi dflemstr korpse_ jlewis stephenmac7 BrianHV ibab Jello_Raptor lightquake neurocyte robinbb _janne prototrout saurik wagle Paks catsup qwandor rs0 gislik jonke albel727 marienz juhp dh Biohazard colah Rylee copumpkin tristan__ scshunt absence edunham bartavelle relrod eagleflo uniquenick cyphase boggle hodapp pdxleif valdyn mokus rhodesd shiona __class__ pikhq_ karls johnw ashooby luigy xrq``` lispy paulschellin StoneToad)
09:48:45 --- names: list (KitB mendez yeshuah eribeiro si14 AlainODea kennycaosn aloiscochard idnar jodaro Xebia rawtass lahwran notdan drmegahertz gbarboza zarul aural tiqs alderz_ rola dabradley bezik udoprog ginmania1 Draggor mattp__ kfish rieper sunhay mgaare popx Adeon eevar Nimatek sajith ninzine macron jmob vnz FliPPeh dixie_ gargawel liori felixsch yusukesuzuki__ dfmr JesuZ pharaun joshbohde tadeo2 martin pp^ froztbyte FireFly Tarential ValicekB adelbertc peder exicer_)
09:48:45 --- names: list (blast_hardcheese drbean raek necroyeti Elision ocfx johntromp d3lxa lambdabot benbangert dmwit MitchW zabirauf mjo stiell hive-mind quicksilver kloeri bsmt Jaak d-snp cpa xaimus_ mrshoe aford Madarc jliikka_ radioxid dj_ryan_ frontend1oader yhager ReinH srhb cdk dsantiago Cr8 vmesons AncientPC guymann Spockz topi`_ zso_ grohne nik_89 zymurgy munro tixxit_ Shozan sykora lenstr Tesseraction newsham pyykkis jj2baile morolin Kabaka frihd_1 chrra solirc mietek)
09:48:45 --- names: list (pqmodn Clint orbital Razz \q liyang mceier lab-notes bens ion SaBer mr- tburns_ franka chipdude bduc mephx spion kakos kav_ go|dfish Jonno_FTW ahihi cjay mike2 Hyphen-ated LeaChim noteventime Maior stevely bitemyapp adimit DigitalKiwi Eridius vhz mangaba_leitosa kittensoup jfhall jang honza Chousuke kaw_ lulf Squid_Tamer GaveUp XMunkki statusfailed thoughtpolice ckey` epsylon Sibi__ Athas Ornedan_ fabjan ortmage pfoetchen Yawgmoth tekacs Mortomes_ Ceryn)
09:48:45 --- names: list (ricky_clarkson solarus mami_ Laney smarter zpconn `^_^v xorox90__ NobbZ mikecaruso1 joachifm geekosaur zeroskillor joeyh cschneid vendethiel uu1101 dyreshark Rockj tomejaguar kosmikus ljhms_ neptunepink mak` tridactyla vikraman yano GGMethos deevus Iloiny_ Cale Rembane tobyp mrb_bk etrepum jagtalon thomasschroeter ibid christiaanb LordDeath cods cryzed AleXoundOS__ Deewiant flux troydm s_e_zz Maxdamantus og01 ofan jrw aristid kmicu _arch wrunt obcode int-e)
09:48:45 --- names: list (SegFaultAX knyppeldynan twn evax paz_ ninegrid bgyss numberten majackson djahandarie edk wjlroe averell ocharles pnielsen_ thirsteh_ noddy2OOO Myk267 apples iteratee avdi davidbe__ upgrayeddd tautologico CADD_ bicgena lpaste BlankVerse_ lostman PatrickRobotham bluesm DarthArachides ircbrowse wilfredh vobi zoglesby shennyg tomh- ehamberg samrat__ xrl__ dan64 jroesch jmct fergusnoble Svedrin haasn mnbernstein dested ethercrow tamiko n-dolio sam_d ilmig vlopez)
09:48:45 --- names: list (dp_wiz stass bobry akraut hdevalence dumbhat lopex uiop tyler_robertson stepcut Gracenotes mlh dagle xnyhps so DarkFox hiredman vvv bgamari Natch ccs4ever conehead__ stephe_ keelo_ tril zw01 vpm raid bearclaw harski iross_ cowtown otulp Dtgr lusory_ nsno Tene pierreghz tsou Adios tinyghost Nafai wayne ivanm __main__ mortberg PHO_ CaveJohnson Walther drbop SLi hattmammerly finster heikkih h_chiro scott Xorlev serge nkpart liesen__ simonnn DexterLB warpy)
09:48:45 --- names: list (opqdonut zq andyo KaneTW andrewsw Lindrian Blkt shepheb CosmicRay Spaceghost bitraten peltchu Baughn jamwt1 aninhumer mlinksva Phlogistique jzl Ke td123 jmcarthur ByronJohnson Drezil shelf ChongLi WarzoneCommand mbrock tomaw tippenein satshaba1 cmsd2 mero felipe_ `0660 Fubar^ yam fnordbert shapr egads qpls boyscared eL_Bart0 adnap Iskarlar dario pyrtsa TK009 cwvh ghorn iron_houzi Internet13 zeroXten phryk Hardolaf helgikrs crs_ flori codehotter [mth]_away)
09:48:45 --- names: list (keko_ Eagle_Erwin ernst wto ziman b_jonas mimi_vx Brando753 peddie Javafant bogner flebron Raynes AshyIsMe socksy taruti jrib Cryovat dcoutts OrangeDuck mononofu jrslepak wereHams1er jchee bcoppens melter banjiewen aszlig deavid derekv udevd jcp FUZxxl amontez bholst Fuco sipa barrucadu dawik koala_man zaphar_ps Guest43550 sdx23 Derander osfameron rk[wrk] franksh brixen lokydor spaceships 5EXAAJO7F yeltzooo duairc eyck aseidl jorendorff_away brainproxy)
09:48:45 --- names: list (annulus mrowe_away betawaffle myme NickHu M-ou-se Sornaensis CindyLinz Nshag dsrx dschoepe inan0 Ulrar mmaruseacph2 MasseR thorstadt bigos k00mi indigo mmb otterdam k4nar_ henk cynick klugez leroux RogueShadow michaelpj drewr DustyDingo theDon mshroyer dlundy Zariel powellc edwtjo_ sleepynate kqr honkfestival identity kloplop321 Licenser joefiorini wormphlegm davean raphie maskt kaol stvc bind2 saiam gridaphobe Taneb tristero Eliel dustinswan1 acfoltzer)
09:48:45 --- names: list (RevJohnnyHealey JPohlmann joelteon sa1 Erstarrung jayne hc @ChanServ iulian benmachine necronian idoru s4msung Nickeeh hungryblank kini jonathanj MarcWeber Lemmih_ Kinnison Kneiva Ptival Martty__ brandonw vital_ davorak_ elgot_ aegray_ helgar larsrh kadoban_ kipras`away tmssgrdn amiller zeiris dhrosa brisbin rgrinberg aji ivan` geal _flow_ alexdoom Sagi inr petanqk kbotnen dmilith bergmark sohum nurupo Nahra flazz_gone xintron nicoo Ezku Cheery bstrie)
09:48:45 --- names: list (Excedrin horlicks_ BlastHardcheese anders^^ mjrosenb jix_ aoh Gothmog_ Vq jb55_ dju Vorpal asjo robbert pi8027 minsa4 asm89 oubiwann-home Nik05 zenzike zebr bambams demolith1 moop sordina1 [swift] profmakx Arnar_ luite dennda mantovani mrd koninkje_away thebnq companion_cube gseitz inarru yggr Belgarion0 bunzen jaspervdj Paprikachu FreakyPenguin Reiser fall_ fayden burp thorkilnaur leocassarani descender Valodim Will| tero-)
09:48:58 <aloiscochard> seanparsons: ah yeah great idea, that lib do all what I need, ty!
09:49:39 <authchir> johannesbodannes: Yeah, but it still looks strange to me to convert from a data structure to an other just to traverse it
09:49:55 <authchir> johannesbodannes: it looks like an unnecessary extra step
09:50:10 <milfjord> lists are reified loops
09:50:23 <pjdelport> authchir: it helps to think of lists as a control structure for looping, not as a data structure
09:51:48 <johannesbodannes> with that said, stuff like this is exactly why lots of people feel that it's hard to reason about performance in haskell
09:51:48 <johannesbodannes> XD
09:57:15 <burbul> I have a vague memory of a fn called foldAccumL, but can't find it via hoogle. Is there such a thing? (Fold which also 'logs' data.) I guess I could use foldM with a Writer monad, but if there's a standard function I'd rather use it...
09:58:00 <copumpkin> mapAccumL?
09:58:09 <copumpkin> that's some combination of map and fold
09:58:24 <copumpkin> :t mapAccumL
09:58:26 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:00:39 <burbul> Hmm...
10:00:48 <burbul> I have an initial value :: a
10:00:51 <burbul> and a fn
10:00:57 * hackagebot Wheb 0.1.0.0 - The frictionless WAI Framework  http://hackage.haskell.org/package/Wheb-0.1.0.0 (hansonkd)
10:00:58 <burbul> f :: a -> (a,b)
10:00:59 * hackagebot wheb-mongo 0.0.1.0 - MongoDB plugin for Wheb  http://hackage.haskell.org/package/wheb-mongo-0.0.1.0 (hansonkd)
10:01:11 <supki> :t unfoldr
10:01:13 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:01:21 <burbul> I want to compute f, f(a), f(f(a)), etc., and accumulate the corresponding bs.
10:01:31 <copumpkin> ah
10:01:34 <burbul> I could roll my own thing
10:01:38 <burbul> but I'm sure this has a name...
10:01:50 <copumpkin> iterate composed with a pair constructor? :)
10:01:54 <burbul> and i want to get used to useing the std fns
10:02:24 <supki> :t unfoldr . (Just .)
10:02:25 <lambdabot> (b -> (a, b)) -> b -> [a]
10:03:24 <burbul> unfoldr looks like exactly what I want -- thanks!
10:04:03 <pjdelport> wouldn't the a / b need to be flipped?
10:04:36 <identity> I'm having some trouble with a recursive function that is calling itself that is using up all my stack space pretty fast. I'm not generating any lists or anything, and I'm used to ghc just optimizing such code into constant space usage
10:04:46 <identity> What should I be looking at as the culprit?
10:05:23 <aloiscochard> seanparsons: the way they can be composed is just so straightforward, I'll have hard time getting back to scala (without z) tomorrow morning ;-)
10:05:42 <seanparsons> Huzzah!
10:06:01 <nadirs> identity: sounds like the recursive function's base case is never triggered?
10:06:36 <identity> nadirs: It's supposed to be calling itself indefinitely, basically. I'm playing around with generating sha512 hashes, trying to find the lowest, etc.
10:06:55 <nadirs> maybe the function is not tail-recursive.
10:09:14 <identity> nadirs: WHat is required for it to be deemed such, so that it optimizes to constant space usage?
10:10:36 <supki> tail-recursive functions are actually more likely to stack overflow, if you're not careful with the accumulator
10:10:43 <benmachine> identity: the recursive call should be the last thing that occurs in the function, so that none of the function's stuff has to hang around once that call happens
10:10:56 <benmachine> supki makes a good point though, check your accumulators
10:12:53 <benmachine> and don't accidentally chew through 80% of your RAM with GHC trying and failing to make this point in ghci
10:12:57 <benmachine> (whoops)
10:13:14 <identity> ah, it was indeed my accumulator. I was incrementing an Integer counter, but since it only reached something like .. a few hundred thousand when it ran out of memory I figured that wasn't the problem
10:13:22 <identity> but Int64 is more than enough
10:15:37 <identity> Hmm. Now it took much longer to run out of space but it still did. Thought they problem went away :(
10:16:15 <Guest72638> identity: progress :)
10:16:24 <alpounet> is your accumulator strict?
10:16:56 <identity> alpounet: Nope, let me throw a bangpattern in there.
10:17:06 <identity> Guest90249: Indeed :)
10:20:09 <identity> It seems that did the trick, as it's still running and ram isn't really going anywhere. It should already have exhausted the 8 mb stack by now
10:20:17 <identity> Thanks for the help!
10:26:06 <joelteon> why is this only using one core? http://lpaste.net/100026
10:26:55 <Fuuzetsu> are you running with the threaded flag &c
10:26:58 <identity> joelteon: haha, you did the same eh?
10:27:12 <joelteon> i did indeed
10:27:18 <joelteon> Fuuzetsu: running? I compiled with it
10:27:21 <joelteon> do I have to do that too?
10:27:59 <Fuuzetsu> try +RTS -threaded
10:28:16 <Fuuzetsu> or +RTS -N
10:28:51 <Fuuzetsu> also, why are you using forkOS and not forkIO?
10:28:54 <alpounet> identity: cool! So the issue was just storing all the operations done on the accumulator instead of evaluating them as you "recurse"
10:29:03 <joelteon> oh, -N is what it needed
10:29:08 <joelteon> Fuuzetsu: just an attempt to get it to run on multiple cores
10:29:12 <joelteon> I'll change it back now that we've solved that
10:29:17 <identity> alpounet: that would seem to be the case
10:30:19 <joelteon> but it doesn't seem to want to use more than 3 cores now
10:30:25 <benmachine> do you have 4?
10:30:41 <joelteon> I have 8
10:30:43 <joelteon> 4 HT
10:30:45 <benmachine> oh
10:30:50 * benmachine shrug
10:30:56 <benmachine> you could try +RTS -N7
10:31:05 <benmachine> iirc there's some reason why it wants to avoid using one of the cores
10:31:13 <joelteon> nah, still capping at about 309%
10:31:14 <benmachine> never really understood it though
10:31:30 <joelteon> well I think the competition is over anyway so it's not really a big deal
10:31:30 <benmachine> well, you've exhausted my expertise on the topic :P
10:31:41 <joelteon> well I would like to get this thing working with 7 cores at least
10:31:59 <Fuuzetsu> benmachine: it's to not degrade performance by constantly fighting with the OS for the last core
10:32:04 <Maior> joelteon: gitcoin? ;)
10:32:06 <joelteon> It does not want to use more than 3 cores
10:32:13 <joelteon> maybe it thinks I have 4
10:32:27 <benmachine> maybe
10:32:30 <johannesbodannes> what OS are you using, sorry?
10:32:34 <Fuuzetsu> joelteon: IIRC -N doesn't county hyperthreaded cores and there's an alternative way to get those going…
10:32:37 <joelteon> OSX Mavericks
10:32:47 <joelteon> Fuuzetsu: Well, if I run ghci +RTS -N and getNumCapabilities, it gives me 8 :/
10:33:07 <benmachine> huh
10:33:16 <benmachine> maybe you're just not saturating your cores?
10:33:24 <joelteon> "You should use a -N value equal to the number of CPU cores on your machine (not including Hyper-threading cores)."
10:33:42 <joelteon> well that's not very helpful
10:33:50 <Fuuzetsu> joelteon: I don't know then.
10:33:54 <joelteon> benmachine, that could be true, but it's in the 298-309% range
10:34:03 <joelteon> it feels like it's just using 3 and no more
10:34:31 <monochrom> yeah, 300% is a bit strange
10:34:33 <identity> joelteon: Thanks for pointing out the SHA2 package. It's much faster than the pure one I found
10:35:22 <joelteon> yeah I figured for a performance-related task, I should use C bindings
10:35:40 <benmachine> joelteon: maybe try GHC.Conc.forkOn
10:35:40 <joelteon> I'll ask #ghc
10:35:45 <benmachine> to really make things run on different threads
10:35:50 <benmachine> at least for debugging
10:35:55 <benmachine> er, *processors
10:35:57 <benmachine> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Conc.html
10:35:59 <joelteon> ok, cool
10:37:47 <joelteon> Heh, that didn't help either
10:41:59 <rqwerr> Is there a way to bind the optional parser to a variable in Parsec?  For example, do sign <- optional (char '-'); integer <- many1 digit; return (sign:integer).
10:42:09 <rqwerr> (I don't want to use optionMaybe.)
10:43:04 <joelteon> side note: the theme on lpaste is really pretty. is that available somewhere?
10:44:56 <djahandarie> joelteon, https://github.com/chrisdone/lpaste/tree/master/static ?
10:45:07 <skypers> ok I found my bug about the lambda stuff I was speaking about earlier
10:45:13 <joelteon> oh, ok
10:45:16 <skypers> return . VertexStreamProc $ \m -> do
10:45:18 <skypers> that fails
10:45:23 <skypers> whereas this wins:
10:45:27 <joelteon> thanks djahandarie
10:45:29 <skypers> return $ VertexStreamProc $ \m -> do
10:45:33 <skypers> why?!
10:45:35 <skypers> for me
10:45:38 <skypers> a $ b $ c $ d
10:45:40 <skypers> is the same as
10:45:43 <skypers> a . b . c $ d
10:45:58 <skypers> oh
10:45:59 <skypers> wait
10:45:59 <unsymbol> greets
10:46:00 <skypers> yeah
10:46:01 <skypers> got it
10:46:06 <monochrom> rqwerr: optional does not do what you want. use optionMaybe.
10:46:09 <skypers> return . VertexStreamProc $ \m -> do
10:46:34 <rqwerr> monochrom: OK.
10:46:52 <skypers> it would require (VertexStreamProc $ \m -> do) to have have a sig a -> a
10:46:54 <skypers> which is not
10:46:57 <skypers> ok :)
10:47:06 <Rotaerk_> hmm I made a function:  assertp pred f a = assert (pred a) (f a)
10:47:28 <Rotaerk_> but when the assertion fails, the location of the failure that it tells me is the assertp definition
10:47:35 <dhrosa> if you have a number of functions which all have the same arg, it makes sense to leave that arg last so that you can take advantage of the (r->) monad, right?
10:47:45 <Rotaerk_> is there a way to make it report the callsite of assertp instead
10:48:11 <monochrom> maybe if you strongly encourage inlining, it will be better
10:48:47 <benbangert> trying to make a twitter client, and I see code with findWithDefault like here, http://hackage.haskell.org/package/hoauth-0.3.5/docs/Network-OAuth-Consumer.html, yet I'm having difficulty locating where to import findWithDefault from.... the Data.Map one doesn't seem right
10:49:15 <monochrom> but otherwise, assert itself is a bit of magic, you can't easily do it to your own definitions
10:50:14 <speckle> I realize I might get biased answers here, but is Haskell good for parsing/compiling/etc DSLs, relative to something like OCaml?
10:50:24 <Rotaerk_> thanks, will try that
10:50:28 <joelteon> absolutely
10:51:12 <Twey> speckle: Yes: Haskell's syntax is more flexible for EDSLs, its type system is more powerful so you can enforce invariants on your EDSL, and its laziness gives you more control over the behaviour of your EDSL
10:51:51 <alpounet> benbangert: it seems to come from: http://hackage.haskell.org/package/hoauth-0.3.5/docs/Network-OAuth-Http-Request.html -> just ctrl+f "findWithDefault" on that page
10:52:03 <benbangert> ahh
10:52:18 <Rotaerk_> hmm looks like inlining won't work, because I never fully apply assertp
10:52:26 <speckle> EDSL?  Ooh, I haven't heard of that term before, but that's probably what I meant.  Thanks!
10:52:39 <Rotaerk_> guess I'll just abandon assertp, and do lambdas containing assertions
10:52:39 <speckle> It might also work well as a linter for existing languages!
10:59:18 <Rotaerk_> is there some alternative mechanism to assert that's less.. magical
10:59:26 <skypers> @hoogle [Maybe a] -> [a]
10:59:27 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:59:28 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:59:28 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:59:48 <skypers> oh
10:59:49 <skypers> sequence
10:59:51 <skypers> interesting
11:00:00 <skypers> > sequence [Just 3, Nothing, Just 1]
11:00:02 <lambdabot>  Nothing
11:00:03 <copumpkin> that won't do it
11:00:13 <skypers> yeah because of bind
11:00:22 <skypers> > catMaybes [Just 3, Nothing, Just 1]
11:00:23 <lambdabot>  [3,1]
11:00:26 <skypers> ok, great
11:00:51 <skypers> the name for that function is nonsense to me
11:00:55 <skypers> “cat”, seriously?
11:01:03 <skypers> justs would have been better
11:01:07 <skypers> just as rights
11:01:24 <dhrosa> cat as in concatenate?
11:01:31 <Twey> speckle: That's possible, though you'd probably have to embed them in Haskell first
11:01:40 <geekosaur> someone's unix was showing :p
11:02:42 <Twey> > concat [[3], [], [1]] -- skypers: it's like concat, but with Maybe instead of [] inside
11:02:43 <lambdabot>  [3,1]
11:06:07 <pranz> :t maybe
11:06:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:06:22 <Rotaerk_> think I'll make my own assertion functions in terms of error
11:07:41 <pranz> join . fmap (maybe [] return) $ [Just 3, Nothing, Just 1]
11:07:48 <pranz> > join . fmap (maybe [] return) $ [Just 3, Nothing, Just 1]
11:07:49 <lambdabot>  [3,1]
11:09:03 <skypers> :58 < Twey> > concat [[3], [], [1]] -- skypers: it's like concat, but with  Maybe instead of [] inside
11:09:07 <skypers> not convinced
11:09:11 <benmachine> I do think justs is a better name
11:09:12 <skypers> it should be justs to me
11:09:19 <skypers> yes
11:09:19 <benmachine> but maybe no-one thought of it at the time
11:09:33 <skypers> it’d be great to change that
11:09:35 <benmachine> also what's the corresponding lens thing, I know there must be one
11:09:38 <skypers> but, I know
11:09:46 <skypers> “it’d break existent code!!”
11:09:50 <supki> benmachine: folded._Just
11:10:10 <pranz> :t folded
11:10:12 <lambdabot> (Applicative f1, Foldable f, Contravariant f1) => (a -> f1 a) -> f a -> f1 (f a)
11:10:29 <supki> > [Just 3, Nothing, Just 1] ^.. folded._Just
11:10:30 <pranz> :t _Just
11:10:31 <lambdabot>  [3,1]
11:10:31 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
11:10:55 <skypers> hm, I have want to build a list of values and use a typeclass method on that
11:11:03 <skypers> is there a way to do that without existential quantification?
11:11:22 <skypers> the type system infers to a random type
11:11:30 <pranz> :t traversed
11:11:31 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
11:11:37 <skypers> I’d like it to infer to (TheClass a) => a
11:12:50 <skypers> I don’t want to build a Any type
11:12:53 <skypers> it’s annoying
11:13:01 <skypers> I guess I can just flatten the list
11:13:17 <pranz> skypers: just specify it's type
11:13:34 <pranz> skypers: but if you want a heterogenous list you'll need existenial quantification
11:13:46 <skypers> pranz: I need another type then?
11:13:56 <Rotaerk_> just to confirm... error/assert are the recommended ways to report invariants broken by the programmer, right?
11:14:08 <Rotaerk_> (i.e. when it's not encodable in the typesystem itself)
11:14:49 <pranz> skypers: I don't know exactly what you want, but if you want a homogenous list where the type has a class constraint there's no problem
11:15:01 <pranz> :t [1,2,3] --skypers
11:15:02 <lambdabot> Num t => [t]
11:15:05 <skypers> no
11:15:12 <skypers> I have a typeclass (Shader)
11:15:20 <skypers> I want to build a list of Shaders
11:15:29 <skypers> I know existential quantification
11:15:40 <skypers> but it’d require me to create a SomeShader universal type
11:15:42 <skypers> and it’s quite boring
11:16:16 <pranz> skypers: I don't know any way around that, maybe if you have ConstraintSynonyms and TypeInstances?
11:17:27 <pranz> dunno if constraintsynonyms was the name but there was some extension that allowed you to do that
11:19:39 <rgr> in LYAH section introducing pattern matching there is an example '[a+b | (a,b) <- xs]' and the line directly after says 'Should a pattern match fail, it will just move on to the next element.'. I'm not sure that means anything in the context. Am I overthinking it or is it saying something important here.
11:21:02 <pavonia> rgr: Yeah, it doesn't make much sense with that example
11:21:28 <skypers>     Expected type: Maybe SomeShader
11:21:28 <skypers>       Actual type: Maybe VertexShader
11:21:29 <skypers> dammit
11:21:30 <supki> rgr: no, (a, b) pattern can't fail to match a pair
11:21:36 <rgr> exactly.
11:21:41 <Javran> @hoogle (a -> Bool) -> (a -> Maybe a)
11:21:42 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:21:42 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:21:42 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:21:49 <skypers> this is just wrong
11:21:56 <supki> > let f xs = [ x | Just x <- xs ] in f [Just 3, Nothing, Nothing, Just 4]
11:21:57 <lambdabot>  [3,4]
11:21:57 <sipa> rgr: make it [a+b | Just (a,b) <- xs ]
11:21:58 <skypers> I don’t like existential problems :D
11:21:58 <Twey> ConstraintKinds, pranz?  But it doesn't help skypers here: they need an existential type.  TypeInstances is a bit evil.
11:22:03 <rgr> so just skip it for now. I dare say I'll come across such a case soon.
11:22:12 <supki> but you can do tricks like that with other types
11:22:26 <Twey> Well, (a, b) can't fail to match a pair and terminate
11:22:47 <Javran> is there something that can convert if expressions to maybe?
11:22:55 <rgr> 1:2:§[]
11:22:59 <rgr> oops
11:23:08 <Twey> > [ a + b | (a, b) ← [undefined] ]
11:23:10 <lambdabot>  *Exception: Prelude.undefined
11:23:21 <Twey> Javran: guard?
11:23:37 <Twey> :t guard
11:23:38 <lambdabot> MonadPlus m => Bool -> m ()
11:23:50 <supki> skypers: are you sure Shader should be a typeclass and not a record of functions, for example?
11:23:55 <Twey> > guard (3 < 5)
11:23:56 <lambdabot>  No instance for (Control.Monad.MonadPlus m0)
11:23:56 <lambdabot>    arising from a use of `e_135'
11:23:57 <lambdabot>  The type variable `m0' is ambiguous
11:23:57 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:23:57 <lambdabot>  Note: there are several potential instances:
11:23:59 <Twey> > guard (3 < 5) ∷ Maybe ()
11:24:00 <lambdabot>  Just ()
11:24:01 <skypers> supki: not at all!
11:24:04 <skypers> and in the end
11:24:10 <skypers> I think I’m gonna use a simple type
11:24:14 <skypers> the same way I do for Renderable
11:24:20 <Rotaerk_> hmm this file-location package seems interesting
11:24:23 <skypers> just a data that hosts some functions
11:24:23 <supki> right, heterogeneous lists are a pain
11:24:34 <skypers> sure they are :D
11:25:03 <cmiller_> is there currently a de facto standard testing framework for Haskell? I use HTF but it hasn't been supported in forever.
11:25:11 <Javran> Twey: I'd like a function that behaves like: `f x = if odd x then Just x else Nothing`
11:25:37 <Twey> Javran: Not as far as I know.  There might be a way to concoct one
11:25:40 <geekosaur> cmiller_, not currently but there are some contenders, tasty being the most recent
11:26:20 <Twey> :t 3 <$ guard (odd 3)
11:26:21 <lambdabot> (Functor f, Num a, MonadPlus f) => f a
11:26:29 <Javran> I guess the signature would look like (a -> Bool) -> a -> Maybe a, but not found on hoogle
11:26:30 <Twey> > 3 <$ guard (odd 3) ∷ Maybe Int
11:26:31 <lambdabot>  Just 3
11:26:37 <cmiller_> kk ty will take a look
11:26:46 <Javran> :t (<$)
11:26:48 <lambdabot> Functor f => a -> f b -> f a
11:27:08 <rgr> orcrist300167*
11:27:21 <Twey> :t join ((<$) . guard . odd)
11:27:22 <lambdabot> (Integral (f b), Functor f, MonadPlus m) => f b -> f (m ())
11:27:39 <Twey> :t join (flip (<$) . guard . odd)
11:27:41 <lambdabot> (Integral a, Functor f, MonadPlus f) => a -> f a
11:28:33 <Javran> @pl \f x -> if f x then Just x else Nothing
11:28:34 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
11:28:59 <Twey> @pl is never going to give you anything sensible :þ
11:28:59 <lambdabot> is never going to give you anything sensible : þ
11:29:05 <Twey> Ha
11:29:14 <Javran> lol
11:29:28 <simpson> :t \x -> guard $ even x
11:29:29 <lambdabot> (Integral a, MonadPlus m) => a -> m ()
11:29:39 <simpson> Oh, I see that Twey already went down that road.
11:30:48 <Twey> :t join . fmap (flip (<$) . guard)
11:30:49 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
11:31:08 <supki> :t ap (<$) . (guard .)
11:31:09 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
11:31:11 <Twey> (shame there's no ($>))
11:31:14 <Twey> Ah, nice
11:31:19 <Twey> Yes
11:32:04 <Twey> Javran: So there you go
11:32:35 <Javran> Twey: I see..
11:32:41 <Twey> :þ
11:33:07 <YOLO> Much to my surprise wolfram alpha had a result for:
11:33:18 <Twey> @let toMonadPlus = ap (<$) . (guard .)
11:33:19 <lambdabot>  .L.hs:144:18:
11:33:19 <lambdabot>      No instance for (Functor f0) arising from a use of `<$'
11:33:19 <lambdabot>      The type variable `f0' is ambiguous
11:33:19 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
11:33:19 <lambdabot>      Note: there are several potential instances:
11:33:20 <YOLO> "The power of positive thinking in watts"
11:33:27 <Twey> Ehh.
11:33:58 <Javran> Twey: I have to write down `((ap (<$) . (guard .)) odd 9 ) :: Maybe Int` to make it work though..
11:34:17 <Twey> @let toMonadPlus ∷ (Functor f, MonadPlus f) ⇒ (a → Bool) → a → f a; toMonadPlus = ap (<$) . (guard .)
11:34:17 <lambdabot>  Parse failed: Illegal character ''\136''
11:34:18 <Peaker> Had a bit of a depressing discussion/argument today about deciding what language to write testing automation framework in..
11:34:20 <Twey> Bah
11:34:37 <Twey> Javran: Only in isolation; if you use the value as a Maybe it'll be inferred
11:34:53 <Twey> Javran: (and if you're not using the value, what's it for?)
11:35:01 <Peaker> Previous company we both saw Python in use and it turned out to be a disaster, but Haskell is not an option because how would you hire 7-10 automation engineers who would be willing to work in a language that doesn't add to their hire-ability?
11:35:10 <Javran> Twey: good point
11:36:07 <Twey> Peaker: ‘Be Facebook’
11:36:30 <Peaker> Twey, well, we're a storage startup
11:36:46 <Twey> Might be less successful
11:36:49 <Peaker> I'm thinking of suggesting C# if all else fails, would make sneaking F# in later easy, perhaps
11:37:02 <Twey> Also I think most Haskell programmers are less likely to be happy as automation engineers
11:37:19 <Peaker> Will automation engineers be less happy to use Haskell though?
11:37:31 <Twey> Similarly there's the Java → Clojure/Scala route
11:37:41 <Twey> Peaker: Not implicitly, I guess
11:37:46 <Peaker> Clojure/Scala don't appeal to me much..
11:37:50 <Peaker> F# seems nice though
11:38:15 <Twey> If you allowed them some getting-up-to-speed time I would imagine they wouldn't mind too much
11:38:21 <speckle> Peaker, why was Python a disaster?  I realize the weakness of its type system, but I haven't heard it being that bad in practice.
11:38:23 <Javran> :t (<$)
11:38:24 <lambdabot> Functor f => a -> f b -> f a
11:38:43 <Twey> Peaker: I've always been a bit turned off F# due to how much of a pain it is to set up/use on Linux
11:38:59 <Earnestly> speckle: (It would be nice if there wasn't two versions)
11:39:02 <speckle> and why don't you like Clojure/Scala?
11:39:17 <Javran> > (<$) 10 $ replicate 3 undefined
11:39:19 <lambdabot>  [10,10,10]
11:39:20 <Peaker> speckle, well, the python infrastructure started out great.  in many senses it was great. Very comprehensive and easy to use. However, the development cycles with it were tediously slow and maintaining the large Python codebase was very difficult. Even the gurus couldn't touch many aspects of it
11:40:10 <Twey> Peaker: Why were the development cycles slow?
11:40:12 <speckle> yeah Earnestly, Python's versioning in general is its biggest weak spot, IMO, including third-party modules.  But if you manage to deploy all the right modules, I don't think the language itself is that bad.
11:40:17 <Peaker> speckle, new people who tried to dive into the Python code were overwhelmed by the large, undocumented-by-types code, that had only partial UT coverage, and grepping was the only tool to get around, which was very weak due to various overloaded names
11:40:34 <Peaker> Twey, it took more than a minute to just start the Python testing infrastructure before it did anything :(
11:40:39 <jcande> is it possible to pattern match minBound and maxBound? As in, f minBound = maxBound ; f x = pred x
11:40:43 <Twey> Huh.
11:40:46 <Twey> jcande: No
11:40:52 <jcande> dag, oh well
11:40:52 <Peaker> jcande, you can use an Eq instance constraint
11:41:00 <Peaker> jcande, and just compare in a guard
11:41:04 <speckle> Python should be written *entirely* different from Haskell, IMO. You shouldn't try to force any invariants anywhere, just keep everything decoupled so that it's easy to analyze what's wrong.
11:41:06 <Twey> jcande: Or a view pattern
11:41:17 <Peaker> Twey, well, it started out quick enough -- Python just doesn't scale well, and as projects grow, the burden grows
11:41:22 <jcande> alright, thanks guys
11:41:39 <simpson> speckle: Well, people don't know about the good libraries. When's the last time you saw Python code using zope.interfaces?
11:41:41 <burbul> :t odd
11:41:42 <lambdabot> Integral a => a -> Bool
11:41:52 <burbul> guard (odd 3) >> just 3
11:41:56 <burbul> > guard (odd 3) >> just 3
11:41:58 <lambdabot>  Not in scope: `just'
11:42:01 <burbul> > guard (odd 3) >> Just 3
11:42:02 <lambdabot>  Just 3
11:42:04 <Peaker> speckle, the problem is scalability in code maintenance (larger and larger project with no types as documentation and more and more cross-references) -- and scalability in performance (more code runs with time, and Python is very very slow)
11:42:07 <burbul> > guard (odd 4) >> Just 4
11:42:09 <lambdabot>  Nothing
11:42:10 <speckle> Trying to enforce even basic invariants in Python, like immutable class fields, inevitably turns the code into a mess.  Just go with the flow of the language.
11:42:28 <speckle> simpson, I haven't even heard of that one before
11:42:28 <cmiller_> Peaker: I too have had problems with scaling up python. The "It's eaiser to beg for forgiveness" thing really breaks down when you're asking for forgiveness over billions of lines.
11:42:32 <Peaker> speckle, the guys writing that system were not Haskellers, they were Pythoneers
11:42:40 <jmcarthur> my beef with python is just that it's next to impossible to gain confidence in any sizable amount of code
11:42:55 <Peaker> cmiller_, yeah, and when you take a look at a piece of code, there's so little you can know about anything in it
11:42:56 <structuralist> Is Haskell with strictness annotations everywhere effectively a strict language? I suspect the answer is no, but why not?
11:43:23 <speckle> Peaker, would you say it's worse than a Java codebase of a similar size?
11:43:24 <Twey> speckle: ‘You shouldn't try to enforce any invariants anywhere’ sounds like a recipe for absolute disaster
11:43:26 <Peaker> cmiller_, and when you try to understand it by diving in to its dependents or dependencies, they're not understandable either.. it becomes a wild goose chase in a large-enough project
11:43:26 <simpson> speckle: It's interfaces. In Python. There's an entire subcommunity of people in the Python community dedicated to writing good software, but its total footprint is only around 1% of all Python deployments and shops.
11:43:37 <jmcarthur> structuralist: lazy by default is more composable by default. opting out of laziness explicitly doesn't remove the benefits of all that lazy code you're still depending on.
11:43:45 <Peaker> speckle, I've not done large Java, but I'd venture so.. Java would scale much better in performance and types would help maintainability
11:44:24 <jmcarthur> structuralist: and even in a module with strictness annotations nearly everywhere is probably still using laziness in a few places
11:44:25 <simpson> Large Java suffers from being Java. I wouldn't recommend it.
11:44:31 <Twey> structuralist: If *everywhere*, yes
11:44:36 <structuralist> jmcarthur: ok, but suppose I wasn't importing any modules including Prelude
11:44:41 <speckle> Java has a weak type system that inevitably turns sufficiently abstract code into FactoryFactories, but you think it's still better than Python... hmm.
11:44:41 <Peaker> anyway, if he's right and we can't get people who want to do Haskell automation, I'm guessing C# is the next best thing which is mainstream..
11:45:08 <Peaker> speckle, I'm guessing it would be better, I'm unsure since I haven't done that much Java
11:45:29 <Peaker> speckle, it would be more painful than Python, at least until it's large enough for Python to become painful
11:45:47 <speckle> Large Java is a mess, but at least it's limited enough that local changes don't seem to unpredictably break the whole system.
11:45:50 <speckle> I think...
11:45:51 <rgr> someone at Amazon seriously needs a slap. I can read the LYAH free web book and cut and paste code great into emacs in pane on my desktop. But from the Kindle book inside a web browse? Nope. Who seriously thought stopping "copy" was a good DRM measure?!?!
11:45:58 <jmcarthur> structuralist: most languages are actually somewhere in between. if you take it to its most extreme then you would evaluate every branch of every conditional, which probably makes the exercise pointless.
11:46:31 <Twey> rgr: Problem exists between company and wallet
11:46:36 <speckle> Yeah, rgr, I've heard horrible things about Kindle book readability lately.  Books by The Little Schemer's author are actually unreadable.
11:46:38 <Peaker> speckle, at least you have some types as documentation, even if those types kinda suck.  You look at a piece of code and you know *something*
11:47:17 <Peaker> speckle, Look at some Python code and without good documentation and UT (which IME are lacking even in good projects) -- you know virtually nothing about anything in that code
11:47:30 <rgr> Its a real pain in the tits. You cant even quote a section anymore to eg FB or twitter or "whatever". Howeber you Can Google search from hilitde text - thus you can THEN copy the text. Totally pointless limitation that does nothing by inconvenience the user.
11:47:34 <Twey> jmcarthur: Well, you can always introduce lambdas; evaluating under binders is a totally different thing to strictness
11:47:55 <Peaker> speckle, when it's small enough you can simply look at user instances and often they are at the very edges that you already know -- and bam, you understand.  This is not possible if you're in the middle of a huge Python project
11:48:13 <jmcarthur> Twey: sure, then you have things like   (&&) :: Bool -> (() -> Bool) -> Bool
11:48:26 <Twey> jmcarthur: Right.  It *works*.  :þ
11:48:54 <speckle> Peaker, I guess what also makes Java easy is the fact that you can very easily navigate around the code with a good IDE.  Haskell should eventually have better IDEs due to its stronger type system, but doesn't seem to have anything as good as IntelliJ yet.
11:48:56 <Peaker> (&&) :: Bool -> Thunk Bool -> Bool
11:49:06 <Peaker> speckle, yeah, that too
11:49:33 <jmcarthur> Twey: i wouldn't say that it's unrelated to strictness though. it's just that it depends on what you consider a value form. it just happens that functions are value forms in ghc.
11:50:52 <speckle> Also, Peaker, C# seems like a nice language, but I've avoided it because the FOSS implementation seems to trail heavily behind the proprietary ecosystem.  I think vendor lockin is more dangerous than using a language like Python.  We're lucky enough that Haskell combines language niceties with an open platform, though.
11:52:47 <Twey> jmcarthur: Functions are always going to be values (… in languages with first-class functions, anyway).  There's the question of whether you want to evaluate e.g. (\x → f . g $ x) into (\x → f (g x)) before you consider that particular function to be a value, but that's separate from (but arguably related to, okay) strictness.
11:53:38 <prinsen> What is the equivalence of Applicative.Alternative for monads?
11:53:49 <Twey> prinsen: MonadPlus?
11:53:49 <dwcook> prinsen, MonadPlus
11:54:15 <Peaker> speckle, even startups are wary of picking up Haskell -- they're afraid candidates will all refuse to work with it
11:54:16 <dwcook> Types that are both Applicative and Monad and have either should theoretically have the other as well
11:54:28 <speckle> Peaker, I'll be blunt: LYAH is nice, but not as nice as The Little Schemer for Scheme.  We need a "The Little Haskeller."  Maybe it will catch on in the mainstream, then.
11:54:34 <Twey> We have far too many -Plus/-Choice/-Alternative types
11:54:38 <prinsen> Twey: dwcook Im working with Yesod forms, any familiarity with that? Not sure that Im tackeling my problem from the right direction
11:55:02 <dwcook> prinsen, no, do you have a larger question that that pertains to?
11:55:03 <Peaker> speckle, I think a good IDE will make it catch on, and I'll get right back on that after bootstrapping this startup :)
11:55:12 <Peaker> Twey, btw, did you get a chance to take a look at Lamdu since?
11:55:36 <Twey> Peaker: Have any tried it?  I feel like they might get a few really good programmers out of it, at least if they're in a tech-friendly location
11:56:02 <Peaker> Twey, We're in Israel, which is extremely tech friendly. I think whole of Israel has about ~20 Haskellers maybe
11:56:22 <Twey> Peaker: I've tried out a few different variations of type systems, but I'm not sure what to do with the records vs. dependent sums issue.  Trying to find a nice solution with the benefits of both.
11:57:10 <Twey> Peaker: If you were e.g. in the middle of Silicon Valley or the UK I feel you might collect Haskellers and hobbyist programmers from around the area
11:57:40 <speckle> haha, 20? where are all the people in this channel coming from if Haskellers are so few? or do other countries have more?
11:57:42 <Twey> Probably not very many, but they'd presumably be good programmers
11:58:25 <prinsen> dwcook: I believe atleast. Lets say I need a value (M a). I want to write that value as several (M a):s like with <|>, and then using the alternative instance of a to return the correct value
11:58:37 <prooftechnique> They all do Java for work now because they're better than average OO programmers by accident
11:58:53 <Peaker> Twey, well, the argument was that no matter how good your technical filter is, you're going to hire 40-50% of your candidates at best (even with a perfect tech filter)
11:59:47 <speckle> how easy/reasonable would it be for a Haskell startup to hire experienced Common Lispers?
11:59:52 <dwcook> prinsen, okay, seems straightforward. Do you already have the Alternative instance?
11:59:53 <speckle> just an idea
12:00:07 <aristid> Peaker: israel has only 20 haskellers? oO
12:00:07 <prinsen> dwcook: yes for a, not for M
12:00:24 <dwcook> prinsen, what do you mean? a is of kind *, which can't be Alternative.
12:00:39 <prinsen> dwcook: I will write an example, 1 sec
12:00:44 <Peaker> aristid, I am somewhat guessing. It isn't popular in Israel. I know about ~10 Haskellers, and I am guestimating there are about 10 more
12:01:08 <skypers> some friends of mine just try to argue that “It’s stupid to restrict side-effects because you spend so many times on it for nothing; if your user does shit with your lib, it’s on him”
12:01:12 <Peaker> speckle, FP isn't that strong in Israel. I think there are more Scala devs though
12:01:14 <skypers> I’m desperate.
12:01:21 <Twey> Peaker: Records are important in Lamdu so I'm tempted to make them first-class objects, but OTOH it feels like if you're going to have records and sums then they should merge nicely.  But on the first hand records are technically a *subset* of sums, since the snd always has to be another sum or unit, so maybe it would be nicer to keep them separate in the abstract syntax rather than worry about whether
12:01:23 <Twey> you've got a record or not for any given sum.
12:01:44 <Peaker> Twey, great to have you thinking about it, btw :)
12:01:47 <aristid> Peaker: you think you know half of the haskellers in the country?
12:02:09 <prinsen> dwcook: rightValue :: Maybe2 (Maybe Int); rightValue = (Just2 (Maybe 1)) <||> (Just2 (Nothing))
12:02:26 <Twey> Peaker: I am prone to over-designing :þ
12:02:28 <Peaker> Twey, yairchu really wants to do a Scott/Church encoding of records/sums and then have "comacros" that translate it to a sugared notation that does support records/sums.. that way the type system is really simple
12:02:29 <prinsen> dwcook: where <||> is the corresponding <|> operator
12:02:31 <ezyang> Twey: Why aren't sums a subset of records (a sum is a record with two conventionally named field)
12:02:38 <Peaker> aristid, yes. It's a small country
12:02:42 <yitz> Peaker: we have a solid team of 4 (one is me, the others you probably don't know), and several more who do occasional haskell work. one more is hired and coming on board in a few weeks.
12:02:46 <prinsen> dwcook: and Maybe2 isn't an instance of Alternative, but Maybe is
12:02:52 <Twey> Peaker: Yeah, that's what I was considering too
12:02:55 <aristid> Peaker: hmm a bit smaller than half of the netherlands (pop-wise)
12:03:03 <Twey> Peaker: So that records essentially become just sugar for sums
12:03:09 <dwcook> prinsen, what is this Maybe2 type? And what's this Maybe data constructor?
12:03:11 <aristid> Peaker: so lamdu is currently on ice or does it only look like that?
12:03:12 <Twey> ezyang: They are :þ
12:03:48 <Peaker> aristid, it's semi-iced. yairchu is still working on it reasonably. I am bootstrapping in a startup so I'm on a break from it for a few months. When the startup is rolling I'll do 50% (that's what I'm contract-signed for)
12:03:51 <Twey> Oh, you mean as a design, Agda-style
12:03:51 <prinsen> dwcook: sry thee Maybe constructor should be Just, and the Maybe2 is a fictional monad
12:03:54 <Peaker> aristid, so I'll have 50% lamdu time long term
12:04:11 <Twey> ezyang: Yeah, that's a pretty nice idea
12:04:18 <aristid> Peaker: is the startup using haskell too?
12:04:19 <Peaker> Twey, I'm not sure I see why records or sums are more fundamental than one another..
12:04:27 <dwcook> prinsen, okay, but you want an Alternative instance for Maybe2, right? To write that it's necessary to know what it looks like.
12:04:28 <Peaker> aristid, if I manage to convince anyone ... :P
12:04:32 <aristid> heh
12:04:54 <Twey> ezyang, Peaker: Though I feel that sums are less ‘heavy’ than records and therefore nicer to reason about
12:05:10 <prinsen> dwcook: Its FormInput http://hackage.haskell.org/package/yesod-form-1.3.5.1/docs/Yesod-Form-Input.html#t:FormInput
12:05:27 <aristid> Peaker: i find it a bit sad that scala appears to be easier to introduce than haskell despite being a far inferior language</biased>
12:05:58 <ezyang> Twey: I mean, they might be easier to reason about for metatheoretical purposes, but there's a reason why we don't do flat lambda calculus for surface language
12:06:02 <Twey> Peaker: It's not that one is necessarily more fundamental, but the fact that you can write one in terms of the other makes them feel like they want to be the same thing
12:06:14 <dwcook> prinsen, okay, so your question is how you would write an Alternative instance for FormInput?
12:06:24 --- mode: ChanServ set +o milfjord
12:06:24 --- mode: milfjord set -b emma!*@*
12:06:33 <prinsen> dwcook: Well, mostly if its the right approach to the prblem
12:06:42 <dwcook> prinsen, what's the actual problem?
12:07:07 <dwcook> Even if it requires specific knowledge of Yesod and I don't have it, someone else might
12:07:20 <Peaker> aristid, the core product will be in C, as most companies in this space (justified IMO)
12:07:29 <Peaker> aristid, the question is about all the peripheral tools
12:07:39 <prinsen> dwcook: I have several alternative actions, and I want to express their priority like in Alternative :)
12:07:46 <Twey> ezyang: This is the abstract syntax — so the surface language will have records either way
12:07:49 <Peaker> Twey, yeah, that's what's so appealing about the church encoding
12:08:00 <aristid> Peaker: embedded stuff?
12:08:16 <dwcook> prinsen, so basically, when one comes up Left, you want to try the next one and so on till you get a Right?
12:08:24 --- mode: milfjord set -o milfjord
12:08:36 <prinsen> dwcook: I think so
12:08:39 <Peaker> aristid, storage controllers, programmed kinda like embedded, to get predictable/reliable resource use
12:08:53 <prooftechnique> :t withTempFile
12:08:55 <lambdabot> Not in scope: `withTempFile'
12:08:56 <Twey> ezyang: And Lamdu makes heavy use of records (for named function arguments).  The question is just whether to put them directly into the type theory or to treat them as sugar
12:09:41 <cariveri> Hi. what is the best way to update/replace an element in a list? It can be found by patternmatching.
12:09:41 <Twey> Peaker: Not ATS?  ;)
12:09:42 <Peaker> ezyang, there's a (possibly novel?) idea of "co-macros" that capture low-level code patterns (e.g: church-encoded sums/products) and sugaring them into a special sum/product notation
12:10:08 <cwraith> aristid: what? I ask basic questions about scala like "where can I find a short summary of the semantics of all the language constructs" and get a bunch of shrugs in response.  It's *not* a simple language to introduce.
12:10:11 <Twey> > [1, 2, 3, 4] & _ix .~ 5 -- cariveri
12:10:13 <lambdabot>  Not in scope: `_ix'
12:10:13 <lambdabot>  Perhaps you meant one of these:
12:10:13 <lambdabot>    `ix' (imported from Control.Lens),
12:10:13 <lambdabot>    `fix' (imported from Data.Function)
12:10:16 <Twey> Oops
12:10:19 <Twey> > [1, 2, 3, 4] & ix .~ 5 -- cariveri
12:10:21 <lambdabot>  Couldn't match type `p0 (Control.Lens.At.IxValue m0)' with `[]'
12:10:21 <lambdabot>  Expected type: Control.Lens.Setter.ASetter
12:10:21 <lambdabot>                   [f0 (Control.Lens.At.IxValue m0)] b0 a0 b1
12:10:21 <lambdabot>    Actual type: Control.Lens.Each.Index m0
12:10:21 <lambdabot>                 -> p0 (Control.Lens.At.IxValue m0) (f0 (Control.Lens.At.IxValue
12:10:28 <Twey> x.x
12:10:36 <Twey> > [1, 2, 3, 4] 3 & ix .~ 5
12:10:37 <lambdabot>  Couldn't match type `m0 -> f0 m0'
12:10:37 <lambdabot>                with `Control.Lens.Internal.Setter.Mutator b0'
12:10:38 <lambdabot>  Expected type: Control.Lens.Setter.ASetter
12:10:38 <lambdabot>                   (p0 (Control.Lens.At.IxValue m0) (f0 (Control.Lens.At.IxVal...
12:10:38 <lambdabot>                   b0
12:10:50 <Peaker> ezyang, maybe with "co-macros", using a flat LC in the low-level type-theory becomes manageable (I'm not sure)
12:11:00 <Twey> Okay, I'm going to leave lambdabot out of this.
12:11:06 <c_wraith> Twey: you're applying a list to a value there.
12:11:08 * hackagebot antisplice 0.7.0.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.7.0.0 (implementation)
12:11:14 <Algebr> Does the x in (x:xs) always mean the first element on a list?
12:11:21 <Algebr> in*
12:11:32 <c_wraith> Algebr: if it's a pattern match, yes
12:11:41 <Twey> c_wraith: I know, I'm just being an idiot
12:11:54 <Twey> c_wraith: (consistently)
12:12:03 <Algebr> c_wraith, so there isn't something like (x:xs:lst) where lst is the last element of the list?
12:12:10 <Twey> cariveri: You can use Lens like: [1 .. 6] & ix 3 .~ 7
12:12:23 <dwcook> prinsen, one thing you can do is is use (>>=) (or a do block) to determine, based on whether the result of the last action was a Left or a Right, whether to run the next.
12:12:35 <c_wraith> Algebr: not exactly.  pattern matching isn't magical - it just matches constructors.
12:12:46 <Twey> Algebr: Yes.  If you want the last element you can use a view pattern or pattern guard, (last → lst)
12:13:04 <c_wraith> Algebr: You can write something like (x:y:z), but there's nothing magical about it.  It's parsed as (x:(y:z))
12:13:26 <rgr> a totally dork Q here but.... why when applying pattern matching to lists do we use () notation and not []? e.g map f (x:xs) = f x : map f xs  and not 'map f [x:xs] = f x : map f xs' .  The square bracket definition appears at first glance to make more sense to me since its explicitly stating its a list.
12:13:27 <k00mi> Twey: that's not exactly helpful advice for understanding pattern matching
12:13:34 <c_wraith> Algebr: that is, x is the first element of the list, y is the first element of the rest of the list, z is everything after that
12:13:42 <milfjord> rgr: (:) also indicates list
12:13:48 <milfjord> rgr: thus [x:xs] is a list of lists
12:14:04 <yitz> rgr: [] notation is just syntactic sugar for : notation
12:14:10 <milfjord> @src []
12:14:10 <lambdabot> data [] a = [] | a : [a]
12:14:13 <rgr> oh right.
12:14:18 <dwcook> prinsen, I haven't tested this, but something like this should do: instance Alternative (FormInput m) where { x <|> y = FormInput $ \h ts e fe -> do { x' <- x ; either y (return x') x' }
12:14:24 <dwcook> Woops
12:14:30 <milfjord> ^ this isn't valid syntax, but if it was, it would define two constructors: [] and :
12:14:32 <dwcook> prinsen, sorry, I don't know what I was thinking >_<
12:14:34 <yitz> rgr: [a,b,c] is desugared by the compiler to a:b:c:[]
12:14:45 <Twey> k00mi: It was intended as an answer to the first question
12:14:45 <foobarbaz> Hi Guys, I was just wondering if anyone had heard of VDM? I thought this might be the best place to ask about it :P
12:15:02 <Twey> I think everyone else has the basic stuff covered
12:15:04 <dwcook> prinsen, instance Alternative (FormInput m) where { x <|> y = do { x' <- x ; either y (return x') x' }
12:15:14 <yitz> @google vdm
12:15:15 <lambdabot> http://www.viedemerde.fr/
12:15:16 <lambdabot> Title: Vie de merde : Vos histoires de la vie quotidienne
12:15:19 <cariveri> Twey: what does it do? I dont understand that line. besides ix and .~ is not in scope   in  "[1 .. 6] & ix 3 .~ 7"
12:15:30 <rgr> ugh. think I've confused myself between tuples and lists now.
12:15:34 <prinsen> dwcook: thanks, I will try it
12:15:43 <rgr> rewind time.
12:16:10 <foobarbaz> yitz more specifically this http://en.wikipedia.org/wiki/Vienna_Development_Method
12:16:18 <foobarbaz> it seems to have some really similiar constructs to haskell
12:16:33 <foobarbaz> But there seems to be a difference between VDM and VDM-SL
12:16:39 <aristid> c_wraith: i didn't mean introduce in the sense of learn or anything, but introduce in the sense of getting corporate approval.
12:16:48 <foobarbaz> For instance, VDM represents a sequence of zero of elements of type T to be T*
12:17:01 <foobarbaz> and a sequence of one or more elements to be type T+
12:17:01 <supki> cariveri: it's lens,  ix 3 .~ 7  means "change list element at position 3 to 7"
12:17:07 <supki> cariveri: and & is flipped $
12:17:08 <foobarbaz> I've never seen a type system like that before o.O
12:17:17 <Twey> cariveri: You'll need the Control.Lens module imported (from the package ‘lens’)
12:17:20 <foobarbaz> I was wondering if anyone has been that before maybe
12:17:37 <roconnor_> foobarbaz: the * thing?
12:17:47 <cariveri> supki: position 3 or element 3 ?
12:17:54 <dwcook> prinsen, that last thing I did was off too; you'd need to actually use unFormInput at some point. Sorry, I can't brain today
12:18:06 <foobarbaz> roconnor_ Yeah :)
12:18:13 <aristid> Peaker: oh, storage controllers... sounds like interesting stuff:) more silicon-y than silicon valley today
12:18:15 <supki> cariveri: 3 is the index of the element being changed
12:18:17 <foobarbaz> For instance, given a function f: T* -> T
12:18:23 <roconnor_> foobarbaz: it is a Kleene star; same one that appears in regular expressions.
12:18:28 <foobarbaz> I'm not sure how that would work if you had a sequence s of type T+
12:18:39 <foobarbaz> Whether or not that would invalidate the type system or not
12:18:46 <dwcook> prinsen, see if you can make sense of the general idea though and, if not, I can go in further depth
12:18:52 <supki> > [10..20] & ix 3 .~ 7
12:18:53 <Peaker> aristid, yeah, I like high availability high performance stuff.. interesting challenge in any language
12:18:53 <lambdabot>  [10,11,12,7,14,15,16,17,18,19,20]
12:18:57 <prinsen> dwcook: ok :)
12:19:02 <foobarbaz> Or, if there was a function tail: T* -> T*
12:19:08 <cariveri> supki: hmm but it means that I would have to lookup the elements position, in spite of being able to find it right away by pattern amtching
12:19:11 <foobarbaz> how that would ever handle a sequence s of type T+
12:19:38 <roconnor_> foobarbaz: you would need a (possibly implicit) coercion from T+ to T*
12:19:52 <foobarbaz> Yeah, that's what i was thinking
12:19:57 <prooftechnique> foobarbaz: Would that definition of tail be coherent?
12:20:00 <foobarbaz> but i can't find anything more on VDM
12:20:25 <foobarbaz> prooftechnique tail [T] yields []
12:20:32 <foobarbaz> But tail [] yields undefined
12:20:41 <prooftechnique> It seems like the natural definition would be from T+ -> T*
12:20:54 <nooodl> T+ -> T* for tail, T+ -> T for head
12:20:56 <foobarbaz> Agreed, but it works with [] too
12:21:01 <foobarbaz> to yield undefined
12:21:04 <prooftechnique> Weird
12:21:09 <supki> cariveri: oh, I was just explaining what that line means. What's the actual problem?
12:21:12 <Twey> There's an undefined in your proof language?
12:21:18 <foobarbaz> the type system seems flawed, but i think it might just be a pen and paper language?
12:21:24 <foobarbaz> Yes!
12:21:40 <foobarbaz> You can also say .. f: N* -> N U {undefined}
12:21:43 <dwcook> Undefined is a nuisance for proving things
12:21:59 <prooftechnique> dwcook: Undefined is a cheat code for proving things
12:22:03 <foobarbaz> You can union the return type of natural numbers, to also contain an undefined
12:22:25 <dwcook> prooftechnique, in that you can prove anything with it :P
12:22:26 <foobarbaz> for instance when getting the max value in a sequence that can be used
12:22:38 <foobarbaz> I guess no one has heard of VDM before? :(
12:22:44 <cariveri> supki: iamgine it more like this: [1,2,3,Status new,4,5] -> [1,2,3,Status old,4,5] . I could walkthrough and build the list replacing the one elem. but I supoose there is a more elegant way.
12:23:19 <dwcook> Let's say I have a type of proofs that a implies not a. Undefined, since it inhabits every type, inhabits it. Therefore, we have a implies not a, and thus a contradiction.
12:23:44 <foobarbaz> lol
12:23:58 <prooftechnique> dwcook: And now your program is proven and you can tell the managers to cut a check
12:24:02 <foobarbaz> that's clever
12:26:14 <dwcook> Some people try to argue Haskell is inconsistent because "IO isn't actually pure!", but all they need to do is point out bottom
12:26:38 <foobarbaz> I'm not sure how to handle this now; I wonder if there are any 'real' languages which support such a construct
12:26:44 <foobarbaz> Saying a sequence is at least one element
12:26:52 <foobarbaz> with functions applied to that
12:27:05 <dwcook> (The IO type is, of course, pure)
12:27:49 <jmcarthur> Twey: it is indeed that latter point which i was talking about.
12:27:56 <cdk> foobarbaz: data NonEmpty a = Last a | NonEmpty a (NonEmpty a) ?
12:27:57 <dwcook> foobarbaz, Agda, Idris
12:28:14 <dwcook> You can do the same in Haskell but you need type-level nats or something to do it right
12:28:28 <dwcook> and even then I think you might run into trouble
12:29:24 <supki> cariveri: I don't think there's a function to do directly this in base. I suppose you can use map, though
12:31:06 <supki> cariveri: oh, there's also break/span, which can be useful
12:32:51 <cariveri> supki: ok. I now do:   map (\e -> aSwitchFct NewVal  e) list
12:33:23 <Twey> dwcook: Eh?  Haskell can do non-empty lists just fine.  You need type-level nats to make Vec, which is more specific
12:33:37 <Twey> (up to ⊥)
12:33:44 <dwcook> Twey, yeah, I was accidentally conflating "at least one element" with "a fixed number of elements"
12:33:48 <Twey> Ah
12:34:25 <Twey> NonEmptyList = ∃ n. Vec (suc n)
12:37:21 <jmcarthur> or   data NonEmptyList a = One a | Cons a (NonEmptyList a)
12:37:52 <dwcook> data NonEmptyList a = Cons a [a]
12:38:13 <jmcarthur> yup, having the benefit that the tail is a standard list
12:40:53 <monochrom> "this formal system is inconsistent" makes great catchy sales-increasing headlines, it's a trick played by dishonest irresponsible news reporters whose only goal is sales. the real inconsistency is in "let's interpret this non-logic system as logic", i.e., in the dishonest irresponsible author.
12:41:51 <aristid> monochrom: which news reporters whose goal is sales do not instinctively avoid headlines that include "formal system" like the plague?
12:41:58 <dwcook> monochrom, are news reporters actually concerned with formal systems? o_0
12:42:58 <Twey> Hahaha
12:42:59 <monochrom> no. I am saying that people who say "haskell's type system is an inconsistent logic" are of the low calibre as dishonest irresponsible greedy news reporters
12:44:06 <quchen_> Could you elaborate on the (not?) inconsistent part of Haskell?
12:44:34 <quchen_> monochrom: ^
12:44:38 <monochrom> no.
12:44:52 <dwcook> quchen_, if a formal proof system contained bottom, much as Haskell does, it could be used to prove anything, including contradictions. See my comment above.
12:45:07 <dwcook> Or here: "Let's say I have a type of proofs that a implies not a. Undefined, since it inhabits every type, inhabits it. Therefore, we have a implies not a, and thus a contradiction."
12:45:10 <monochrom> the same way I could not elaborate on either "my car is so happy" or "my car is so not happy". type error.
12:45:23 <Twey> Haskell is consistent if you take the propositions x ∷ Y to be ‘if x evaluates to anything, it evaluates to a value of type Y’
12:45:28 <quchen> dwcook: Ah, so "Void is inhabited" is the problem
12:45:31 <dwcook> quchen, yes.
12:45:36 <aristid> if i had a car it would definitely be happy
12:45:46 <pharaun> haskell is in the news?
12:45:53 <rgr> ok, who has the patience? Probably some repetition too .... In 'match3 (a:b:c:xs) = [a,b,c]' is the () brackets specifically saying "pattern matching"? I cant get my head around why we're using these bracket types. Why not [a:b:c:xs] which would be "syntactic sugar" for a:b:c:therest:[] or?
12:46:16 <quchen> monochrom: So what would be a correct statement in this context? Haskell is not a formal system?
12:46:22 <Iceland_jack> rgr: Parentheses are just for *grouping*
12:46:23 <dwcook> pharaun, sometimes, and even xkcd has caught wind of (and ridiculed) it!
12:46:28 <monochrom> Haskell's type system is not a logic.
12:46:32 <Iceland_jack> Just like in (4 + 9) * 4
12:46:39 <geekosaur> rgr, [a:b:c:xs] alreadt has a meaning. specifically it is list with a single element, which is a list of at least 3 elements
12:46:42 <dwcook> https://xkcd.com/1312/
12:46:46 <pharaun> dwcook: :D yeah i've seen a couple of xkcd's comics
12:47:02 <dwcook> There was also one ridiculing functional programming, lemme find it
12:47:13 <dwcook> https://xkcd.com/1270/
12:47:18 <pharaun> hah that was a good one
12:47:28 <rgr> Iceland_jack: Oh jeeps. I was thinking it was an alternative tuple like syntax in this case. ok I think..
12:47:41 <quchen> monochrom: Makes me wonder what a logic is. I have a hunch that the Wikipedia article will be disappointing though.
12:47:44 <Eduard_Munteanu> Given -XDataKinds, data Foo = Bar | Baz, class IsFoo (f :: Foo), instance IsFoo Bar, instance IsFoo Baz, it seems GHC can't deduce 'IsFoo t' for an unspecified 't'. Any plans on fixing that?
12:47:47 <Iceland_jack> rgr: When you write
12:47:47 <Iceland_jack>     [a,b,c,d]
12:47:47 <Iceland_jack> it desugars to
12:47:47 <Iceland_jack>     a:b:c:d:[]
12:47:47 <Iceland_jack> which is the same as
12:47:47 <monochrom> rgr, the () brackets specifically say how to parse
12:47:47 <Iceland_jack>     a:(b:(c:(d:[])))
12:48:03 <Iceland_jack> rgr: so (a:b:c:xs) matches a list of length 3, length 4, length 5+
12:48:36 <Iceland_jack> > let (a:b:c:xs) = "ABC" in (c:b:a:xs)
12:48:37 <lambdabot>  "CBA"
12:48:38 <monochrom> quchen, perhaps there is some subjective judgment
12:48:45 <Iceland_jack> > let (a:b:c:xs) = "ABCD" in (c:b:a:xs)
12:48:46 <lambdabot>  "CBAD"
12:48:51 <Twey> quchen: A logic is a formal system used to prove propositions, surely
12:49:04 <Iceland_jack> > let (a:b:c:xs) = "ABCDE" in (c:b:a:xs)
12:49:05 <lambdabot>  "CBADE"
12:49:15 <companion_cube> what's interesting is that there is a dual view of logic
12:49:20 <Aetherspawn> the bit that took me a while to understand that it's not sugar is (x:xs)
12:49:24 <companion_cube> a syntactic view (proofs) and a semantic view (models)
12:49:27 <Iceland_jack> rgr: So (a:b:c:xs) successfully matches strings (lists) of length 3+
12:49:32 <Aetherspawn> since (:) is actually a constructor, it also works if you define your own constructors
12:49:34 <quchen> Twey: So formal systems don't necessarily prove anything? Now I don't know what a formal system is
12:49:35 <Iceland_jack> but watch how it fails to match "AB"
12:49:39 <Iceland_jack> > let (a:b:c:xs) = "AB" in (c:b:a:xs)
12:49:41 <lambdabot>  "*Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern (a...
12:49:45 <Aetherspawn> and also, xs can represent
12:49:54 <rgr> Iceland_jack: thank you. I'll run through that now. Your answers are always cool and dont make me feel too stupid for asking ;)
12:49:58 <shiona> what is an actual choice for m in (Applicative m, MonadRandom m) => m Int
12:50:01 <Aetherspawn> "the rest of the list", since the next reference is inside the actual object
12:50:11 <Twey> quchen: No, you can easily have a formal system with no model, where valid manipulations of the formal system have no further meaning than being valid manipulations of that system
12:50:12 <monochrom> but I am not going to use Haskell's type system to state any proposition, or Haskell's terms as proofs of any proposition. this is not a logic to me.
12:50:45 <Eduard_Munteanu> shiona: what MonadRandom is that?
12:50:47 <Iceland_jack> rgr: I'm glad to hear that, asking is a good thing :) please continue!
12:50:51 <Twey> monochrom: So you don't use the type system to state that ‘if id returns a value, it returns a function from an a to an a’?
12:51:02 <shiona> I have absolutely no idea
12:51:13 <quchen> Twey: Like a formal system with one axiom ∀P. P would not be a logic?
12:51:31 <Iceland_jack> rgr: The most fundamental thing to understand is that there are only *two* possible cases for lists: empty and non-empty
12:51:33 <Twey> quchen: It certainly wouldn't be a very useful logic
12:52:04 <Eduard_Munteanu> shiona: any idea what package or library it's from?
12:52:09 <Twey> quchen: (though it depends on the valid constructions of P, I suppose)
12:52:22 <Iceland_jack> If you match those you've covered all cases, where
12:52:22 <Iceland_jack>     foo []     = ...
12:52:22 <Iceland_jack> matches the empty list and
12:52:22 <Iceland_jack>     foo (x:xs) = ...
12:52:25 <Iceland_jack> matches the non-empty list (where ‘xs’ is another list)
12:52:26 <shiona> control.monad.random
12:52:29 <Eduard_Munteanu> @hoogle MonadRandom
12:52:29 <lambdabot> package MonadRandom
12:52:30 <lambdabot> package MonadRandomLazy
12:52:43 <monochrom> Twey, that statement belongs outside Haskell, at the meta level, not inside Haskell.
12:52:50 <shiona> which is the first one
12:52:52 <Eduard_Munteanu> shiona: looks like this one:  MonadRandomLazy
12:52:52 <Eduard_Munteanu> 22:47 < monochrom> Twey,  MonadRandomLazy
12:52:59 <Eduard_Munteanu> Er.
12:53:07 <Eduard_Munteanu> shiona: http://hackage.haskell.org/package/MonadRandom
12:53:07 <Twey> Heh
12:53:11 <Eduard_Munteanu> Paste fail.
12:53:14 <geekosaur> any instance of MonadRandom should be an instance of Applicative, although this won't be formalized until the next ghc release I think
12:53:21 <shiona> Eduard_Munteanu: that's the page I've been looking at for the last 2 hours
12:53:38 <quchen> monochrom: Do you mean that because Haskell is not used as a theorem prover (and probably not very useful at it anyway), it's not a logic?
12:53:45 <Twey> quchen: You could have a logic that only contains the proposition Unit and the proof (), where Unit is the proposition that if I have one apple and if I put another apple next to it then I will have a group of two apples (or perhaps a pear :-D)
12:53:49 <monochrom> yes quchen
12:53:53 <quchen> monochrom: Aaah.
12:53:56 <Eduard_Munteanu> shiona: then look at the MonadRandom instances in the Class module
12:54:04 <geekosaur> more the "not useful at it" part, I think
12:54:13 <Eduard_Munteanu> MonadRandom IO
12:54:25 <geekosaur> the problem with formal systems is they tend to be better at formal systems then real world applications
12:54:39 <geekosaur> *than they are at
12:54:53 <Twey> quchen: The correspondence means it has a model, and it's sound with respect to the model (for any proposition in the system, if it has a proof then its associated proposition in the model is true) but it's a very boring model
12:56:38 <Eduard_Munteanu> I wonder if an analogue to closed type families would make sense for typeclasses.
12:57:14 <Twey> Eduard_Munteanu: Surely that's just ‘data’
12:57:51 <Eduard_Munteanu> Twey: that doesn't quite retain the automatic resolution of typeclasses
12:58:17 <Twey> Eduard_Munteanu: Does it not?  You don't have to specify which constructor you're using
12:59:08 <dwcook> Does some package have an (almost) uninhabited type :: * -> *?
12:59:20 <Eduard_Munteanu> Twey: earlier I was asking about ... "Given -XDataKinds, data Foo = Bar | Baz, class IsFoo (f :: Foo), instance IsFoo Bar, instance IsFoo Baz, it seems GHC can't deduce 'IsFoo t' for an unspecified 't'."
12:59:49 <shiona> I'm getting nowhere
12:59:51 <Eduard_Munteanu> dwcook: all * -> * are uninhabited :)
13:00:23 <monochrom> geekosaur: I am not sure what to make of your statement. if it is true, then since every programming language is a formal system (every machine-readable language plus its machine processing is), you obtain "programming languages tend to be better at formal systems than real world applications"
13:00:31 <sipa> Eduard_Munteanu: huh?
13:00:38 <c_wraith> Eduard_Munteanu: doesn't surprise me at all that GHC assumes that unspecified type variables have kind * during inference
13:00:51 <dwcook> Eduard_Munteanu, okay yeah, I phrased that poorly. :P
13:01:01 <Eduard_Munteanu> sipa: what is the huh about? :)
13:01:04 <Twey> Eduard_Munteanu: *nod* It won't.  It's not a closed class.
13:01:07 <dwcook> A type :: * -> * that, given a *, results in an uninhabited *.
13:01:24 <c_wraith> Twey: functionally, it is closed.  It's just that GHC doesn't know it.
13:01:25 <Twey> dwcook: Const Void ?
13:01:34 <Twey> c_wraith: Hrm, yes
13:02:00 <Twey> It would be nice if GHC could reason about kinds, I suppose
13:02:01 <skypers> does C++ support closures?
13:02:03 <Eduard_Munteanu> c_wraith: er, haven't I specified the kind there? f :: Foo
13:02:10 <dwcook> Twey, hmm, that works. Thanks.
13:02:10 <skypers> if so, it doesn’t require a GC, why do we?
13:02:22 <sipa> Eduard_Munteanu: how about for example Maybe ?
13:02:31 <sipa> does that not inhabit * -> * ?
13:02:34 <c_wraith> Eduard_Munteanu: sure, in the *class* definition.  I'm talking about what it infers at the use site.
13:02:43 <Twey> skypers: It does, sort of.  It's also not memory-safe, though.
13:02:46 <sipa> or you mean there is no value of type Maybe>
13:02:56 <Eduard_Munteanu> sipa: I was saying all members of * -> * are uninhabited, not * -> * itself
13:03:01 <sipa> got it
13:03:16 <dwcook> Yeah, all values have a type of kind *
13:03:25 <skypers> Twey: hm
13:03:31 <Twey> skypers: In C++ you can a) copy the value into the closure, and throw away sharing or b) refer to the value via a pointer or reference, and throw away memory-safety
13:03:33 <skypers> to me it’s not closure
13:03:42 <shiona> Eduard_Munteanu: http://lpaste.net/6821265934225768448
13:03:44 <skypers> yes Twey
13:03:49 <pranz> Twey, skypers: I was in a hurry and thought of something like this: https://gist.github.com/Pranz/9040556
13:03:54 <sipa> Twey: or use shared_ptr as closure argument :)
13:03:57 <pranz> Twey, skypers: I have no idea if it works
13:04:05 <monochrom> I may be willing to accept "programming languages tend not to be good at real world applications" too. or, it may be more reasonable to say "it's toy formal systems that are not good at real world applications", but then the cause is the "toy" part rather than the "formal" part.
13:04:05 <Twey> skypers: a) is problematic in combination with laziness, because laziness is implemented by holding pointers to the data, and the structure isn't guaranteed to be finite
13:04:16 <sipa> Twey: or unique_ptr in combination with move semantics
13:04:27 <monochrom> "toys are not very good at real world applications" is a boring tautology
13:04:33 <Twey> sipa: That's a neat idea; does it get invalidated in the containing scope?
13:04:42 <skypers> Twey: I mean, where is the closure allocated in C++?
13:04:46 <skypers> on the stack?
13:04:57 <Eduard_Munteanu> shiona: you can instantiate that to IO (Integer, Integer)
13:05:03 <Twey> skypers: In the dynamic storage area
13:05:11 <skypers> how is it deleted?
13:05:16 <Twey> Dynamically :þ
13:05:16 <milfjord> >implying C++ has a stack
13:05:21 <sipa> Twey: a unique_ptr going out of scope deletes the value it points to
13:05:23 <skypers> Twey: so there’s a little GC?
13:05:48 <Twey> skypers: Er, I meant ‘automatic’ above
13:05:57 <skypers> yes, how?
13:05:58 <Twey> Sorry, I don't talk about C++ much :þ
13:06:01 <sipa> Twey: assigning a unique_ptr<T>&& to another just moves ownership
13:06:06 <sipa> ow, this is #haskell!
13:06:10 <skypers> it’s interesting though
13:06:18 <shiona> Eduard_Munteanu: damn, I hoped I could keep away from IO
13:06:20 <Twey> skypers: The automatic storage area for a scope is cleared when execution leaves that scope
13:06:34 <sipa> skypers: C++ has as much automatic GC, as Haskell has IO
13:06:42 <monochrom> sorry for bringing up curry-howard in #haskell!
13:06:53 <Eduard_Munteanu> shiona: http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random-Class.html
13:06:54 <sipa> skypers: it can be made pretty transparent, but it is still explicit
13:06:56 <skypers> Twey: yeah, it’s stack.
13:06:58 <Twey> sipa: I know; does referring to one in a lambda transfer ownership away from the variable in the enclosing scope?
13:07:04 <Twey> skypers: Not necessarily
13:07:31 <sipa> Twey: you'd create the lambda using new Closure(..., std::move(some_unique_ptr), ...)
13:07:49 <Twey> skypers: It's a chunk of memory that's erased when you go out of the scope :þ
13:07:52 <Twey> sipa: Ah, right
13:08:00 <Twey> sipa: So you can't do it with the lambda syntax?
13:08:12 <sipa> Twey: which transfers ownership, and in practice means the original unique_ptr now gets to point to null
13:08:14 <shiona> Eduard_Munteanu: I'm not sure if I've spoken to you personally before, but I usually have to tell people I cannot understand a thing about haskell documentation. It's more cryptic than the language itself
13:08:16 <skypers> Twey: which scope?
13:08:30 <skypers> I mean, passing a lambda to a function to store it
13:08:34 <prinsen> dwcook: http://lpaste.net/100039
13:08:36 <sipa> Twey: the argument of Closure needs to be rvalue reference
13:08:43 <Twey> skypers: The defining scope
13:08:49 <Twey> sipa: Right, but that wasn't what I asked
13:08:51 <sipa> Twey: however you end up with that, but a normal reference isn't automatically converted
13:09:03 <skypers> Twey: what?
13:09:13 <skypers> no, it’s not that way
13:09:33 <skypers> you can embed a lambda into a function that escapes the defining scope
13:09:37 <skypers> it’ll be still valid
13:09:46 <Twey> sipa: If I have a std::shared_ptr<A> foo and I create a lambda [foo] { … }, is the original foo invalidated?
13:09:57 <sipa> i don't think so
13:10:00 <Twey> skypers: You can return it out of the defining scope, in which case it's copied
13:10:04 <sipa> shared_ptr's do reference counting
13:10:09 <skypers> oh
13:10:11 <Twey> sipa: Er, unique_ptr, sorry
13:10:30 <Twey> skypers: The one in the defining scope is destroyed normally
13:10:35 <sipa> Twey: my guess is that that will just fail to compile, as you can't just assigned unique_ptr to another
13:10:38 <dwcook> prinsen, does that do what you wanted?
13:10:41 <Twey> sipa: Aha
13:10:44 <sipa> but i have never used the lambda syntax
13:10:52 <Eduard_Munteanu> shiona: you can use 'evalRandIO :: Rand StdGen a -> IO a', and your computation will be kept out of IO until you run it.
13:11:06 <sipa> </c++>
13:11:08 <SaBer> sipa, Twey: http://en.wikipedia.org/wiki/C%2B%2B14#Lambda_captures_expressions
13:11:11 <prinsen> dwcook: havent tested yet
13:11:20 <skypers> yeah well
13:11:24 <skypers> just state that C++ sucks
13:11:26 <skypers> thank you :)
13:11:34 <shiona> Eduard_Munteanu: an to get Rand StdGen a as my type I will have to do what?
13:11:35 <foobarbaz> <dwcook> https://xkcd.com/1270/
13:11:38 <Eduard_Munteanu> shiona: there's an instance RandomGen g => MonadRandom (Rand g), so you can instantiate your function to a Rand StdGen
13:11:39 <foobarbaz> I never got that one
13:11:40 <foobarbaz> D:
13:11:51 <rgr> Iceland_jack: going back to my Q just FYI the one quote from you totally cleared it all up : the specific expansion of the parsing of the lhs for the matching - m3 (a:(b:(c:rest))) = [a,b,c]
13:11:54 <shiona> ok
13:11:57 <dwcook> prinsen, I'd say you could have written empty more clearly
13:12:19 <Eduard_Munteanu> shiona: just evalRandIO your getRandomPair
13:12:22 <dwcook> foobarbaz, "got" how?
13:12:35 <c_wraith> shiona: haskell documentation tends to include a *lot* of information in dense formats, in places like instances lists.  Don't ignore type signatures, don't ignore instance lists.  They have about 80% of the information you need.
13:12:46 <Iceland_jack> rgr: Glad to hear that, it's actually rather rare to see any other list pattern matching than [] and (x:xs) in real code
13:13:13 <prinsen> dwcook: agreed :)
13:13:18 <c_wraith> Iceland_jack: matches on [x] aren't that uncommon, either, but anything bigger is pretty unusual.
13:13:33 <shiona> c_wraith: I don't ignore. I cannot make any sense of them. I think I can write instances (at least I have done so), but I feel like the instances list have totally different syntax which puts me off
13:13:53 <Iceland_jack> c_wraith: Yes [x], (x:y:ys) and sometimes [x,y], but [] and (x:xs) are by far the most common
13:13:59 <foobarbaz> The joke, I don't really get it :(
13:14:09 <Iceland_jack> rgr: Do definitions like
13:14:10 <Iceland_jack>     length :: [a] -> Integer
13:14:10 <Iceland_jack>     length []     = 1
13:14:10 <Iceland_jack>     length (_:xs) = 1 + length xs
13:14:13 <Iceland_jack> make sense to you?
13:14:20 <Iceland_jack> oops, length [] = 0 of course
13:14:20 <shiona> Eduard_Munteanu: thank you, I added the :: Rand StdGen (Integer, Integer) and now it seems to work
13:14:21 <Iceland_jack> :)
13:14:52 <Eduard_Munteanu> shiona: you don't need to, I think
13:15:10 <Twey> c_wraith, Iceland_jack: I sometimes write code like getArgs >>= run, where run matches on n arguments
13:15:21 <Eduard_Munteanu> shiona: evalRandIO already asks for a rather specific type
13:15:42 <Twey> sipa: Yep, seems to not compile
13:15:58 <dwcook> foobarbaz, I found the joke in the title text to be funnier
13:16:02 <rgr> yes
13:16:03 <shiona> Eduard_Munteanu: but as I wrote in the lpaste, I want to be able to define values in repl
13:16:08 <Iceland_jack> Twey: To make it clear, I wasn't saying things like
13:16:08 <Iceland_jack>     case args of
13:16:08 <Iceland_jack>       [x, y] -> ...
13:16:08 <Iceland_jack> aren't used :)
13:16:13 <shiona> and that let a = getRandomPair would throw a fit
13:16:28 <Eduard_Munteanu> c_wraith: I have a function 'f :: forall (t :: Foo). (IsFoo t) => ...', it seems I can't call that either
13:16:48 <Eduard_Munteanu> shiona: what REPL, ghci?
13:16:50 <sipa> Twey: you'll need the explicit: lambda [std::move(foo)] { ... }
13:16:55 <shiona> ghci yes
13:17:06 <c_wraith> Eduard_Munteanu: ok, now you're getting into the realm of "that really sounds like a bug"
13:17:09 <Iceland_jack> rgr: Incidentally, if you want to make a ‘quick and dirty’ program that takes two command-line arguments, you can write
13:17:09 <Iceland_jack>     main = do
13:17:09 <Iceland_jack>         [x, y] <- getArgs
13:17:09 <Iceland_jack> 	...
13:17:12 <Iceland_jack> which will fail with a run-time error if you pass it the wrong number of arguments
13:17:26 <shiona> I guess I should use that name, but for me haskell repl is ghci, i don't know any other
13:17:33 <Iceland_jack> rgr: which is the same as writing
13:17:33 <Iceland_jack>     main = do
13:17:33 <Iceland_jack>         x:y:[] <- getArgs
13:17:45 <Twey> sipa: That doesn't seem to work
13:17:47 <Eduard_Munteanu> c_wraith: hm, you think it's a bug? I'm not sure if closed kinds are supposed to be handled that way for typeclasses, maybe they haven't bothered about it.
13:18:07 <sipa> Twey: or [foo = std::move(foo)]
13:18:19 <SaBer> Twey: that's c++14
13:18:28 <c_wraith> Eduard_Munteanu: either it's a bug that it allowed the declarations, or a bug that it doesn't allow you to abstract over them.
13:18:48 <Eduard_Munteanu> Lemme come up with a minimal example then.
13:19:07 <Eduard_Munteanu> shiona: you can do that in the IO monad in ghci
13:19:11 <Twey> Ah, I see
13:19:29 <Eduard_Munteanu> shiona: just do  (x, y) <- getRandomPair
13:20:10 <Eduard_Munteanu> ls
13:20:16 <Eduard_Munteanu> Meh.
13:20:24 <mm_freak_> "let go = … in go"
13:21:02 <flebron> Cale: ping. How does Hask change when one has Rank2Types? is "forall a. a -> a" a type now in Hask?
13:21:04 <mm_freak_> let go, ingo!
13:21:24 <flebron> let haskell = ... in haskell ;)
13:21:36 <dwcook> flebron, forall a. a -> a was already in Hask
13:21:38 <Eduard_Munteanu> flebron: not quite, you need impredicative types for that
13:21:45 <dwcook> Or am I confused?
13:21:51 <rgr> Iceland_jack: so you could invoke main from ghci how? "main 1 2" ?
13:22:00 <quchen> rgr: :main args
13:22:00 <flebron> dwcook: You mean that for all a. "a -> a was already in Hask", correct?
13:22:01 <Iceland_jack> rgr: or :main
13:22:05 <Eduard_Munteanu> (->) is special
13:22:16 <pranz> \o/ success
13:22:38 <dwcook> flebron, okay, that's one way to say it
13:22:38 <pranz> skypers, Twey: heterogenous lists without wrappers
13:22:46 <rgr> why does "main 1 2" not work? its called main. Why the specific ":main 1 2"?
13:22:50 <Iceland_jack> rgr: If you type ‘:?’ ghci will list all possible commands, one of which is
13:22:50 <Iceland_jack>     :main [<arguments> ...]     run the main function with the given arguments
13:23:02 <skypers> pranz: hm
13:23:13 <skypers> I came up with droping a typeclass
13:23:23 <skypers> data + high order functions are just neat and sweet :)
13:23:25 <flebron> Eduard_Munteanu: So if I have f :: (forall a. a -> a) -> a -> a, and f is a morphism in Hask, what is its source object, and what is its target object?
13:23:37 <Iceland_jack> rgr: Because ‘main’ doesn't take arguments
13:23:52 <dwcook> flebron, it's not a morphism in Hask
13:23:55 <Iceland_jack> ‘main’ is not a function an has type ‘main :: IO ()’
13:24:15 <flebron> Ah, that's sad. Is it salvageable, like id :: a -> a isn't technically a morphism in Hask but a natural transformation?
13:24:18 <dwcook> flebron, remember what someone, I believe Cale, said before about indexed families of morphisms?
13:24:22 <Iceland_jack> so you cannot run ‘main’ with
13:24:22 <Iceland_jack>     ghci> main 1 2
13:24:27 <Eduard_Munteanu> flebron: you can interpret that as a natural transformation
13:24:40 <flebron> Right, I understand what happens to the usual polymorphic types like id, but not how it plays with Rank2Types
13:24:42 <rgr> Iceland_jack: I'm yet to read anything about what "main" actually is and what IO is yet so I'll stay frosty on that one.
13:24:48 <Iceland_jack> rgr: No problem
13:25:01 <Iceland_jack> rgr: If ‘main’ has no arguments, you can run
13:25:01 <Iceland_jack>     ghci> main
13:25:01 <Iceland_jack> just fine
13:25:06 <Iceland_jack> or :main
13:25:19 <rgr> well main 1 2 wont.
13:25:19 <Eduard_Munteanu> flebron: think of a naturality square going A -> A -> B and A -> B -> B the other
13:25:22 <Iceland_jack> If you want to pass arguments to main you can either do
13:25:22 <Iceland_jack>     ghci> :main 1 2 3
13:25:28 <rgr> yes
13:25:31 <Twey> pranz: How'd you do that?
13:25:31 <Iceland_jack> or you can write ‘import System.Environment’
13:25:35 <rgr> I did
13:25:39 <rgr> or get args isnt defined
13:25:42 <rgr> getargs
13:25:49 <Iceland_jack> and then do
13:25:49 <Iceland_jack>     ghci> withArgs ["1", "2"] main
13:25:53 <Eduard_Munteanu> flebron: A and B are instantiations of the 'a' variable
13:25:55 <rgr> aha ok
13:25:59 <dwcook> Twey, unsafeCoerce everywhere</facetious>
13:26:05 <Iceland_jack> rgr: getArgs, ‘Args’ is capitalized
13:26:24 <Twey> Heh
13:26:33 <Iceland_jack> You can see the functions defined in a module using ‘:browse System.Environment’ (or ‘:bro System.Environment’)
13:27:01 <Iceland_jack> There you should see
13:27:01 <Iceland_jack>     ghci> :bro System.Environment
13:27:01 <Iceland_jack>     getArgs :: IO [String]
13:27:01 <Iceland_jack>     getEnv :: String -> IO String
13:27:04 <Iceland_jack>     ...
13:27:21 <Iceland_jack> rgr: Which you can try out with
13:27:21 <Iceland_jack>     ghci> getEnv "USER"
13:27:21 <Iceland_jack>  
13:27:24 <flebron> Eduard_Munteanu: I can look at that square (I think haha, though it's more a rectangle), but what do I glean from that?
13:28:02 <pranz> Twey, skypers: updated gist https://gist.github.com/Pranz/9040556
13:28:29 <Eduard_Munteanu> flebron: a natural transformation is a bunch of arrows, that square shows the relationship between two instantiations of that variable
13:29:33 <Iceland_jack> rgr: If you want to see it in action, try defining
13:29:33 <Iceland_jack>     ghci> import System.Environment
13:29:33 <Iceland_jack>     ghci> let main = do arguments <- getArgs; print arguments
13:29:33 <Iceland_jack>     ghci> :main 1 2 3
13:29:36 <Iceland_jack>     ["1","2","3]
13:29:41 <Iceland_jack>     ghci> withArgs ["1", "2", "3"] main
13:29:42 <Eduard_Munteanu> flebron: this covers forall a. a -> a, which is a natural transformation Id -> Id (Id is the identity functor).
13:29:44 <Iceland_jack>     ["1","2","3]
13:29:48 <Iceland_jack>  
13:29:48 <Iceland_jack> Does that answer your question?
13:30:03 <pranz> Twey: ConstraintKinds really are magic :)
13:30:13 <sipa> :t getArgs
13:30:14 <lambdabot> Not in scope: `getArgs'
13:30:25 <Iceland_jack>     getArgs :: IO [String]
13:31:51 <Eduard_Munteanu> flebron: for things like ($) it's different functors and natural transformation.
13:32:31 <flebron> So my f :: (forall a. a -> a) -> a -> a would still be a natural transformation?
13:32:51 <shachaf> "f :: (forall a. a -> a) -> a -> a" is a very misleading way of writing that type.
13:33:01 <shachaf> Write f :: (forall a. a -> a) -> b -> b or something instead.
13:33:56 <rgr> thanks a lot.
13:33:57 <pranz> Twey: accidentally missed out critical part, now revisioned again
13:34:11 <Iceland_jack> You're welcome
13:34:48 <flebron> shachaf: Heh, ok :)
13:35:13 <Eduard_Munteanu> flebron: hmm...
13:35:52 <YOLO> OMFG!! Haskell is an advanced purely functional language! ADVANCED!
13:36:09 <YOLO> I did not know that I deal with advanced
13:36:18 <dwcook> Eduard_Munteanu, what is the categorical structure that corresponds to any given type in Haskell? e.g., the type could be an object Foo, a morphism Foo -> Foo, a natural transformation… What unifies these?
13:36:30 <Twey> pranz: https://gist.github.com/Pranz/9040556/#comment-1172529
13:36:30 <Eduard_Munteanu> flebron: that's more of a Nat(Nat(Id)) -> Nat(Id), I think
13:37:39 <pranz> Twey: yeah I know, but skypers asked if it could be done without a wrapper
13:37:56 <Eduard_Munteanu> dwcook: functors and natural transformations aren't in Hask per se
13:38:04 <Twey> Well, it's without a *specific* wrapper :þ
13:38:10 <dwcook> Eduard_Munteanu, notice I said "Haskell" rather than "Hask"
13:38:22 <flebron> What's Nat(Nat(Id)? I suppose Nat(Id) is a functor but... how? (I get that Nat(X) is the class of natural transformations between the functor X and itself)
13:38:32 <monochrom> dwcook: for Foo->Foo, we use a category that has "exponentiation", i.e., there is a bijection between Homset(X,Y) and an object for that function type (written Y^X)
13:38:40 <monochrom> the rest, I don't know
13:38:53 <Twey> Though the lack of type lambdas makes multiple constraints a pain
13:39:09 <Eduard_Munteanu> dwcook: yeah, there's the exponential when you want to talk about functions as objects
13:40:07 <dwcook> monochrom, do you mean that a category with exponentiation has its arrows as its objects as well?
13:40:34 <dwcook> or Eduard_Munteanu, I should say
13:40:36 <flebron> He means it's cartesian closed
13:41:19 <monochrom> not quite. intuitively yes. but more accurately, use two representations for each function type, a Homset is one, an object is another, and have conversion between them, so you can use whichever one that fits the context
13:42:23 <monochrom> yeah, look for "cartesian closed category" for the full story. the conversion requires a product, so "cartesian closed category" requires that as well
13:42:24 <rgr> if I load a hs file int ghci  and confirm an import (import System.Environment) worked  with 'getEnv "USER"' at the ghci command lines and it correctly returns "rgr". Why then does ':show imports' not show it as imported? it just shows GOA and Prelude.
13:42:39 <monochrom> it is also the source of the name "cartesian closed comics"! :)
13:43:03 <Eduard_Munteanu> flebron: generally, Nat(F, G) is the category of natural transformations between F and G
13:43:11 <jowens> anyone willing to explain memoization in Haskell?
13:43:18 <jowens> wrt to the wiki article
13:43:37 <Iceland_jack> rgr: It shows it imported here
13:43:50 <monochrom> the notation Y^X comes from the cardinality analogy: X*Y has |X|*|Y| elements, Y^X has |Y|^|X| functions
13:44:21 <rgr> http://dpaste.com/1626931/
13:44:54 <Cale> flebron: It would have to be, though I don't know exactly what the best way to represent its categorical properties would be.
13:45:26 <Iceland_jack> rgr: How did you import System.Environment? Can you paste the entire session (running ghci with the ‘-ignore-dot-ghci’ option)
13:45:51 <rgr> I did an import in my main hs file which I load into ghci in emacs.
13:46:10 <Iceland_jack> ah, :show imports only shows the imports made in the ghci session
13:46:13 <rgr> (inferior-haskell-load-file if thats of any interest)
13:46:26 <rgr> okily dokily.
13:46:50 <shachaf> monochrom: I don't think that meaning of "exponentiation" works for anything other than Set.
13:46:55 <Iceland_jack> you can do
13:46:55 <Iceland_jack>     ghci> import System.Environment
13:46:55 <Iceland_jack> or
13:46:58 <Iceland_jack>     ghci> :module +System.Environment
13:47:02 <Iceland_jack> to import it in ghci
13:47:09 <monochrom> well yeah every analogy breaks. I am not a fan of analogies.
13:47:15 <monochrom> analogies are like drugs.
13:47:29 <Iceland_jack> Analogies are like fine china, tend to crack under pressure..
13:47:53 <Eduard_Munteanu> shachaf: isn't it easier for Hask which is in many ways stricter?
13:48:04 <shachaf> I don't mean the cardinality analogy, I mean the bijection between Homset(X,Y) you mentioned before.
13:48:11 <shachaf> Anyway, not very important.
13:48:17 <monochrom> but I don't really have a better notation for the exponentiation object. even if I had one, nobody would understand it.
13:48:25 <XniX23> Hi guys, i'm having problems with EclipseFP, i installed eclipse for c++ and then installed eclipseFP, i'm not sure everything installed because if i go to options, it says to set path for buildWrapper (i dont know what this is) and if i choose to install it from hackage, it will throw an error that it (buildwrapper.exe) can't be found in one of my maps. Also it doesnt highlight the code, any suggestions?
13:49:25 <monochrom> um, I'm sure I have nothing wrong in that part. including the very word "bijection".
13:50:01 <monochrom> ok I'll re-read Pierce etc
13:50:05 <shachaf> Well, it only works if objects are sets.
13:50:10 <shachaf> Unless I misread.
13:50:37 <monochrom> yeah, I now remember
13:51:17 <monochrom> oh haha, I wrote it very poorly
13:52:10 <monochrom> bijection between { Homset(X,Y) | objects X, Y } and {Y^X | objects X, Y}
13:52:11 <shachaf> You can represent elements of Y^X as arrows : 1 -> Y^X, and then say there's a bijection between Hom(1, Y^X) and Hom(X, Y)
13:52:36 <shachaf> Which is almost the usual definition of an exponential.
13:54:21 <shachaf> Hmm, I'm not sure I understand that notation.
13:56:27 <monochrom> set builder notation. except don't throw stones at me for "but there are too many objects to make a set" :)
13:56:53 <Eduard_Munteanu> flebron: I think an  f' :: forall a. (a -> a) -> (a -> a)  gives you a transformation F -> F, where F A = A^A. Also your f is actually an f :: (forall a. a -> a) -> (forall a. a -> a), which seems to be a higher level thing.
13:57:49 <d3lxa> what's the easiest way to pass from a ResumableSource with HTTP Conduit to a url-decoded [(Text,Text)]? I'm at: res <- http req manager
13:59:05 <Twey> shachaf: http://en.wikipedia.org/wiki/Exponential_object ?
13:59:54 <shachaf> I know what an exponential object is.
14:00:32 <shachaf> I'm not quite sure what monochrom means and whether his thing is indeed an exponential in general.
14:01:17 * hackagebot cereal-vector 0.2.0.1 - Serialize instances for Data.Vector types.  http://hackage.haskell.org/package/cereal-vector-0.2.0.1 (AdamFoltzer)
14:03:34 <Eduard_Munteanu> flebron: I don't think it's anything in Hask anyway, just like 'id' isn't quite in Hask either (but the sum of its instantiations are)
14:03:46 <flebron> Right
14:04:06 <flebron> So for a sort of "discussion space" on Haskell, you'd recommend I leave out trying to formalize this when introducing RankNTypes?
14:04:24 <flebron> Well, obviously the theory of higher order from propositional calculus comes in, just not the type theory with it
14:05:45 <Eduard_Munteanu> flebron: you can still talk about natural transformations and polymorphic functions, just don't try to express all of it in CT language. Hask itself isn't particularly well-defined.
14:06:48 <flebron> Does it become well defined it we carefully ignore bottom?
14:06:58 <Eduard_Munteanu> That is, I'm not sure there's a fully formal treatment of categories defined in terms of type theory.
14:07:36 <Eduard_Munteanu> flebron: that's not the issue here, AFAICT.
14:08:53 <Eduard_Munteanu> flebron: I'm saying that while normal categories are defined with respect to Set as the underlying foundation, Haskell has Hask instead. E.g. homsets are objects of Hask.
14:10:25 <kini> does ghc produce "portable" binaries or does it detect the available instruction set on the local machine?
14:10:54 <monochrom> not portable in that sense
14:15:06 <merijn> kini: It's as portable as gcc binaries are
14:15:42 <merijn> kini: Which is to say, not all that portable if you're thinking of multiple hardware platforms
14:15:49 <d3lxa> What should I use to url-decode a query string (ByteString) in [(a,a)] form? a=Text if possible?
14:16:02 <kini> oh, right
14:16:32 <kini> I wasn't thinking of multiple hardware platforms like x86 vs arm or anything like that
14:17:03 <merijn> kini: It should be as portable as say, compiling something for x86 linux and copying the binary to another linux machine
14:17:09 <kini> actually I'm trying to virtualize a system installed natively on a system
14:17:11 <merijn> kini: Assuming the relevant C libraries are installed
14:17:33 <kini> *installed natively on a computer
14:18:05 <kini> in other words I'm expecting that my CPU is going to suddenly lose the ability to perform various instructions that it previously could :) but it should remain able to do the standard lowest common denominator
14:18:46 <kini> unfortunately I have installed a lot of packages with CFLAGS="-march=native" which I now have to recompile with CFLAGS="-mtune=generic" and I was wondering if haskell programs would also need a recompile - I guess they would, because of the backend
14:19:17 <monochrom> GHC binaries use lowest common denominator
14:19:48 <kini> even with CFLAGS set?
14:20:15 <monochrom> GHC has its own asm code generator. what CFLAGS?
14:20:46 <kini> oh. Then I guess I misunderstood what merijn was saying in referring to gcc
14:21:13 <geekosaur> merijn didn't say gcc
14:21:14 <merijn> kini: It was an anlogy, not meant to imply GHC actually uses gcc
14:21:26 <merijn> geekosaur: I did, I said "as portable as gcc binaries"
14:21:28 <geekosaur> oh, did up abpove
14:21:29 <kini> merijn: now I get it :)
14:21:33 <monochrom> analogies are like leaky abstractions
14:21:41 <kini> yeah, I didn't think ghc used gcc, I was getting confused...
14:21:47 <merijn> kini: A lot of people show up not even properly understanding the difference between, say, a machine code compiler and bytecode
14:21:59 <kini> sure
14:22:18 <merijn> kini: Or dynamic vs static linking, etc. so I was just going for a lowest common denominator analogy ;)
14:22:26 <kini> fair enough, haha
14:22:37 <nomeata> Hi. Is there a library like gloss or diagrams, but for compositing bitmap data?
14:22:41 <kini> I wouldn't say I'm an expert on those things either, so I appreciate the effort
14:23:03 <aristid> merijn: how could anybody possibly not know the difference between static and dynamic linking... i assume they are not even familiar with how relocatable code is implemented?!
14:23:05 <merijn> I'm not entirely sure what kind of ASM GHC generates though
14:23:08 <nomeata> I.e. something that lets me put them next to each other, or trip and crop them, etc.
14:23:29 <merijn> aristid: They don't understand compiled code at all because they've only used python/php/node?
14:23:49 <aristid> merijn: craziness
14:23:52 <merijn> kini: This sounds like the kind of question better suited to mailing lists, though :)
14:23:59 <geekosaur> merijn: I think it's completely generic right now but there is some work on adding sse2 instructions
14:24:40 <merijn> kini: Either the glasgow-haskell-users@haskell.org or haskell-cafe lists, I guess
14:24:51 <merijn> kini: There's also #ghc for compiler implementation questions
14:25:03 <kini> merijn: it's not that important. I'm thinking I'm probably just going to recompile all 1500 packages on my system, lol
14:25:32 <aristid> merijn: you're not a real developer if you don't realize that binary search is too slow because it is too likely to thrash the power-of-2-aligned associative cache, y'know
14:25:36 <merijn> aristid: Man, so many people don't understand *any* form of linking
14:26:32 <geekosaur> also, no promises if you used the llvm backend
14:26:32 <monochrom> there is no end in mourning other people's ignorance :)
14:26:43 <geekosaur> since I don't think we set any constraints on what that generates
14:27:22 <aristid> merijn: tbh i wouldn't expect most developers to even know that there's a difference between static and dynamic linking
14:27:41 <aristid> merijn: it's not something that comes up much when writing web apps with php or business apps with c#
14:28:25 <Forgetaboutit> aristid, merijn, I guess there are many shades of understanding (which can also be really unhelpful)
14:30:07 <merijn> Forgetaboutit: Sure, but a rudimentary knowledge of this stuff is critical if you want to be good at what you do :)
14:31:21 <Forgetaboutit> merijn: I absolutely agree!  I mean I'm pretty inexperienced myself, but I know that I *have* to learn to become good at what I do, actually.
14:32:03 <monochrom> ordinary humans will not comprehend more than some 2 layers of abstraction above and below what their daily job is at.
14:32:46 <Forgetaboutit> The problem is that you can get away quite often without knowing; also, many choose not to learn and and therefore not to know.
14:33:00 <merijn> monochrom: Sure
14:33:03 <Jeanne-Kamikaze> ignorance is bliss
14:33:13 <monochrom> even I, I give out the illusion of knowing many layers, by a sliding window trick
14:33:20 <Jeanne-Kamikaze> the less you know, the less questions you have
14:33:39 <merijn> monochrom: It's a good trick, especially as you manage to subtly slide during conversations :)
14:39:17 <esebelle> is there a way to load ghci with the environment of my cabal library?
14:39:56 <hakujin> esebelle: cabal repl if you're on cabal 1.18
14:39:58 <monochrom> "cabal repl" may help
14:40:41 <esebelle> ok. cool. somehow I am on an old version of cabal but I will fix that
14:41:26 <esebelle> I've found something unfortunate
14:41:46 <esebelle> if I want to test my hidden modules
14:42:43 <esebelle> I have to have my test-suite use my library code directory as a source
14:43:13 <esebelle> but then, I have to include all the build-depends even for my exposed library modules
14:43:18 <esebelle> in my test-suite
14:43:21 <esebelle> I think the solution
14:43:35 <esebelle> is to make a separate directory for extensions
14:44:20 <esebelle> err
14:44:22 <esebelle> unexposed modules
14:44:24 <esebelle> etc.
14:44:27 <pjdelport> silly question
14:44:29 <esebelle> but it's an annoyance
14:46:16 <pjdelport> what's an efficient way to enumerate all possible bytestrings of some range of characters / bytes?
14:47:14 <pjdelport> in other words, for e.g. 'a' to 'z', getting "a", "b", "c", ... "z", "aa", "ba", "ca", ... "zz"
14:47:19 <pjdelport> and so forth
14:48:19 <pjdelport> I began trying to create a bijection from the integers to string, using B.unfoldr and divMod / quotRem, but that doesn't quite get there
14:52:07 <pjdelport> here's what I have so far: http://lpaste.net/100042
14:52:46 <pavonia> > take 20 $ (\cs -> concatMap (sequence . flip replicate cs) [1..]) ['a'..'c']
14:52:50 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
14:53:31 <pavonia> Ah, you want to go from an integer
14:54:12 <pjdelport> pavonia: not necessarily; that's just seemed like an obvious strategy
14:54:38 <pjdelport> hmm, how efficient will that be for bytestrings?
14:55:11 <Twey> pjdelport: The bijection idea wasn't bad.  You can express any integer in base-n positional notation using your n characters.
14:55:20 <pjdelport> Twey: right
14:55:56 <pjdelport> the thing is, i don't only want a bijection from the integers, but full coverage of the strings
14:56:07 <khyperia> Is it possible to define dynamic precedence in happy, or is that required to be a postprocessing step?
14:56:21 <pjdelport> the base-n bijection ends up dropping the leading "zeroes"
14:56:27 <Twey> @let toBase base digit sep = intercalate sep . reverse . map (digit . (`mod` base)) . takeWhile (> 0) . iterate (`div` base)
14:56:31 <lambdabot>  Defined.
14:57:25 <Twey> @let toBaseWidth base digit sep = intercalate sep . reverse . map (digit . (`mod` base)) . take width . iterate (`div` base)
14:57:25 <lambdabot>  .L.hs:155:43: Not in scope: `width'
14:57:34 <Twey> @let toBaseWidth width base digit sep = intercalate sep . reverse . map (digit . (`mod` base)) . take width . iterate (`div` base)
14:57:35 <lambdabot>  Defined.
14:58:41 <Twey> > toBaseWidth 5 10 (return . (!!) "0123456789") "" 653
14:58:44 <lambdabot>  "00653"
15:00:37 <stolaruk> Do ppl use HUnit along with QuickCheck, or is QuickCheck typically enough?
15:03:17 <geekosaur> they do different things
15:03:58 <geekosaur> QuickCheck is good for when you can auto-gneerate inputs to a function and want to make sure it handles all of them
15:04:13 <stolaruk> Right
15:04:25 <geekosaur> HUnit is good for regression tests: "this case used to fail, I fixed it, test to make sure the case doesn't get broken again"
15:04:48 <stolaruk> ok so when you have a particular case in mind as opposed to a "property"
15:04:50 <geekosaur> which is good for more logical errors where you can't sensibly pregenerate inputs to test
15:05:17 <geekosaur> (think for example a parser, where randomly generating valid parser inputs is generally not viable)
15:05:28 <stolaruk> oh I see
15:06:15 <stolaruk> As you can probably tell, I'm just starting to get into this stuff. Haven't done much testing in Haskell or other langs
15:06:36 <stolaruk> QuickCheck has been surprisingly fun thus far
15:07:00 <stolaruk> The little HUnit I've done in Java was not really much fun
15:09:09 <syllogismos> is there a function that is opposite of pure? like pure' :: f a -> a
15:09:39 <syllogismos> can we implement it just from <*> <$> pure
15:09:44 <Iceland_jack> no
15:09:54 <stolaruk> You can't take a value out of an applicative functor
15:09:58 <stolaruk> not like that
15:10:14 <khyperia> syllogismos, consider the IO applicative functor
15:10:25 <milfjord> consider []
15:10:42 <Iceland_jack> milfjord: (!! 42) obviously :)
15:10:58 <milfjord> consider Reader
15:10:59 <syllogismos> nice..
15:12:57 <syllogismos> > sequence [[1,2,3],[2,3],[1]]
15:12:59 <lambdabot>  [[1,2,1],[1,3,1],[2,2,1],[2,3,1],[3,2,1],[3,3,1]]
15:13:16 <syllogismos> wat
15:13:36 <Iceland_jack> syllogismos: Do you know how the list monad works?
15:13:42 <djahandarie> syllogismos, it's called 'copoint' or 'extract', but no, you can't get it from Applicative (or Monad).
15:13:43 <milfjord> all paths from left to right
15:13:43 <Iceland_jack> @src sequence
15:13:43 <lambdabot> sequence []     = return []
15:13:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:13:43 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:13:46 <syllogismos> im expecting sequence to be like join I dont knowwhy
15:14:03 <Iceland_jack> @ty sequence
15:14:04 <lambdabot> Monad m => [m a] -> m [a]
15:14:05 <Iceland_jack> @ty join
15:14:06 <lambdabot> Monad m => m (m a) -> m a
15:15:26 <quchen> sequence and join are entirely different things.
15:16:08 <quchen> join flattens monadic structures, sequence performs a list of monadic actions one after another (and gathers the results).
15:16:26 <Twey> What's a coapplicative?
15:16:42 <stolaruk> join is the concat of monads
15:16:42 <Twey> :t (<*>)
15:16:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:16:49 <shachaf> No such thing.
15:17:02 <shachaf> Using bizarro-lenses you can invent Unapplicative, but it's bizarre.
15:17:10 <Twey> f b → f a → f (a → b) ?
15:18:31 <Twey> Hm, I guess f (b → a) → f a → f b
15:18:46 <Twey> Bizarre, indeed
15:18:59 <shachaf> unliftA2 :: (a -> b -> c) -> (p a -> p r) -> (p b -> p r) -> p c -> p r
15:19:27 <shachaf> I don't think the type you wrote makes much sense.
15:19:50 <TravisD> Is there a #not-haskell channel for discussing off topic questions?
15:19:57 <TravisD> (That one obviously doesn't exist, but maybe there is another)
15:19:58 <shachaf> That's for Contravariant p.
15:20:06 <milfjord> TravisD: #haskell-blah
15:20:06 <Twey> shachaf: Why not?  contramap ∷ (b → a) → f a → f b
15:20:27 <Twey> Surely the Applicative makes sense by analogy
15:20:31 <TravisD> milfjord: Thanks
15:21:50 <Twey> :t contramap
15:21:51 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
15:22:47 <Twey> :t flip (flip contramap `asAppliedTo` Comparison undefined)
15:22:48 <lambdabot> Not in scope: data constructor `Comparison'
15:24:32 <shachaf> I'm not sure that the analogy makes sense.
15:27:41 <quchen> shachaf: How does ComonadApply fit into the question?
15:27:46 <quchen> (And Twey)
15:28:33 <quchen> It looks like a Comonad-based Applicative, but not quite so because it's a subclass of Comonad
15:29:11 <edwardk> quchen: ComonadApply is sayng that there is some semigroup-like structure for putting together some comonads. It is like Apply with an extra set of laws relating it to extract.
15:29:33 <edwardk> quchen: it is based on ComonadZip from the 'essence of dataflow programming' paper.
15:30:16 <quchen> Thanks, I'll have a look at that.
15:30:45 <edwardk> quchen: applicative has (<*>) well behaved with regards to pure, ComonadApply has it well behaved w.r.t extract, which is a rather different thing
15:31:05 <edwardk> there isn't a proper 'coapplicative' notion
15:31:18 <edwardk> this is because there isn't a proper 'coexponential' in Hask.
15:31:23 <edwardk> there really _can't_ be.
15:31:24 * hackagebot sbv 3.0 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.0 (LeventErkok)
15:32:25 <edwardk> if you view applicative as mappings between monoidal categories that preserve the monoid (,), then the 'co-applicative' notion would preserve some comonoid.. but all comonoids in Hask/Set are trivial.
15:33:04 <edwardk> if you go to something else like a category of vector spaces you can find all sorts of interesting comonoids, but not in something Set-like
15:34:33 <companion_cube> http://leventerkok.github.io/sbv/ looks cool indeed
15:34:49 <quchen> edwardk: Could you explain what a coexponential is (and what it could be in some handwavy Haskell-y universe)?
15:35:10 <Eduard_Munteanu> There may still be coapplicatives from/to Hask to/from some other category.
15:35:32 <quchen> Make the Haskell-y Set or Vect maybe. Something I might be familiar with. :-)
15:35:44 <edwardk> quchen: see 'Coexp' http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Category-Cartesian-Closed.html
15:36:45 <edwardk> quchen: it doesn't work in Set. but lets look at a thin category like a poset. there it plays the role of subtraction.
15:36:46 <edwardk> coapply :: b `k` Sum k (Coexp k a b) a
15:37:12 <edwardk>  you can read that as    coapply ::  b <= (a - b) + a
15:38:02 <edwardk> er
15:38:07 <edwardk> the minus s backwards sorry
15:38:13 <edwardk>  you can read that as    coapply ::  b <= (b - a) + a
15:38:18 <djahandarie> edwardk, Set-like being CCC?
15:38:43 <quchen> edwardk: Sum k is the sum type (sum object) constructor in the CCC k?
15:38:49 <Eduard_Munteanu> eval :: B^A x A -> B  vs  coeval :: B^A x B -> A   right?
15:38:56 <edwardk> cocurry :: (c `k` Sum k a b) -> Coexp k b c `k` a    gives      c <= a + b     entails    c - b <= a
15:39:16 <edwardk> uncocurry :: (Coexp k b c `k` a) -> c `k` Sum k a b     gives      c - b <= a    ->    c <= a + b
15:39:47 <quchen> So apply for k = (->) is  ((a -> b), a) -> b?
15:40:04 <edwardk> djahandarie: yes. basically what happens if you have arbitrary exponentials and coexponentials is you collapse to a poset.
15:40:15 <Eduard_Munteanu> lift eval :: f (a -> b) -> f a -> f b   vs  lift coeval :: f (a -> b) -> f b -> f a
15:40:25 <edwardk> the laws are enough that there is only at most one arrow between any two objects
15:42:11 <edwardk> Eduard_Munteanu: coeval or coapply is     b -> (b_a) + a  where b_a is the coexponential
15:42:26 <edwardk> Eduard_Munteanu: gotta flip the whole arrow around
15:42:28 <Eduard_Munteanu> Er, right, it's not an exponential.
15:42:55 <edwardk> hence my - analogy  b <=  (b - a) + a
15:43:00 <Eduard_Munteanu> edwardk: and the coexponential is the same exponential but in the opposite category, right?
15:43:05 <edwardk> yes
15:45:15 <djahandarie> edwardk, hmm, so actually any closed monoidal category at all?
15:46:21 <edwardk> djahandarie: my recollection was that when you had both exponentials and coexponentials ( CCC + co-CCC?) is when things collapsed to a poset.
15:47:55 <Eduard_Munteanu> (<*>) :: f (a -> b) -> (f a -> f b), so a co-<*> for f :: Hask -> Hask^op would go like... f (a -> b) <- (f a <- f b), I suppose.
15:48:40 <Peaker> Hackage 2 is one of the most responsive websites on the whole web :)
15:49:11 <Eduard_Munteanu> And f (a -> b) maps b^a to b_a.
15:53:47 <rgr> any other haskell-mode users here with ingerior-haskell mode gchi? Wonder if you might have a fix for it freezing after inferior-haskell-send-decl as it doesnt send an explicit new line causing the next evaluation to freeze.
15:55:09 <Eduard_Munteanu> rgr: have you changed the ghci prompt? That causes issues.
15:57:42 <NemesisD> anyone know if its possible to have an executable in a cabal file that is only for test? they aren't actually tests but my tests must execute them
15:59:15 <rgr> Eduard_Munteanu: ah yes. Didnt think of that. I'll set it back,
15:59:34 <rgr> was looking at a comint "flush". Could possibly force another CR in the send hook later.
16:00:26 <rgr> and really irritating problem solved. ta.
16:01:08 <oakwhiz_> Anybody have any good articles on criticism of the actor model? I can find a lot of articles about why the actor model is great. But not much criticism.
16:04:39 <cads> don't actors get ENOUGH criticism?!
16:05:07 <cads> models too, for that matter :D
16:05:35 <cads> oakwhiz_: I'd be interested to see something that focuses on the real world difficulties of the model
16:06:00 <oakwhiz_> I found this: http://pchiusano.blogspot.ca/2013/09/actors-are-overly-nondeterminstic.html
16:06:16 <cads> that was the one criticism I could think of too
16:06:27 <cads> it's too hard to understand how a group of actors will behave
16:07:12 <cads> well, a less valid one is that "actors are probably hard to program / hard to find programmers for" which I don't know
16:07:14 <oakwhiz_> I wonder if some kind of hybrid between Unix pipes and Actors could solve that.
16:07:38 <oakwhiz_> It's easy to reason about a system using a pipes model.
16:08:12 <oakwhiz_> But since actors can get references to each other through message passing, the dataflow of an actor system changes as the system runs
16:08:22 <oakwhiz_> it could get pretty complicated.
16:08:54 <cads> sure, when actors aren't free to connect and disconnect the channels we can treat it as a dataflow network
16:09:56 <cads> oakwhiz_: actors and agents are synonymous, right?
16:10:11 <cads> they're just mobile processes
16:10:34 <oakwhiz_> cads: I'm not really sure. I thought that agents were a monad.
16:10:37 <cads> with some self preservation to make them robust across locations
16:10:47 <Twey> You can prove nice things about actors via π-calculus; they're pretty manageable given a type system.  The only thing I can think of is the unpredictable memory usage argument (which Haskell also has)
16:11:21 <cads> I was going to point out that we do have process calculi dealing with mobile processes
16:11:23 <Twey> But you can manage that with a synchronous calculus and listen-only replication too, I think
16:11:40 <cads> but good luck hiring a kid that can do that
16:12:07 <Twey> Well, they could use it given appropriate language design
16:12:40 <Twey> Probably not with any of the currently-popular implementations, but that's hardly a flaw of the model
16:13:02 <cads> true, automate away a lot of the behavior proofs and give the users highly robust templates for agent societies.
16:13:43 <cads> that's really the cake - we need coders to give us societal level proofs of properties
16:13:51 <cads> or the compiler.
16:14:57 <samwise__> hello folks, I was wondering if someone could clear out this piece of code for me http://lpaste.net/100043
16:14:58 <cads> I wonder for example if we can make a useful primitive out of solution to tricky agent problems
16:15:21 <ski> cads : which models ?
16:15:34 <ski> how close does Erlang correspond to the actor model ?
16:16:18 <Twey> ski: It's a perfect actor model, but it has all kinds of other behaviour as well
16:16:36 <Eduard_Munteanu> It seems GHC can't resolve instances for classes parametrized by a closed kind, any idea if this problem is being worked on? http://lpaste.net/100044
16:16:43 <Twey> (including local state and IO)
16:16:50 <Eduard_Munteanu> c_wraith: I posted an example of the closed typeclasses issue ^^
16:16:59 <Twey> (and the ability to inspect other actors &c.)
16:17:04 <cads> oakwhiz_ initially asked the question - to be honest I've read some theoretical work mobile agents
16:17:34 <cads> milner has a very graph theoretical, very categorical account called Bigraphical Reactive Systems
16:18:04 <cads> in his Space and Motion of Communicating Agents
16:18:26 <cads> a criticism of that is that the monoidal category thus derived is very ugly
16:18:45 <cads> lacking traces or something else plush that makes /other/ agent calculi more tractable
16:19:21 <cads> I'm not sure about erlang or its criticisms besides HR concerns
16:19:48 <identity> I'm trying to explain some Haskell to a heathen and IIRC GADts could be used to facilitate(reducing boilerplate basically) writing instances for stuff like, say, adding (theoretical) a Vector and a Matrix or some such. Do I remember correctly?
16:20:32 <identity> samwise__: clear out?
16:21:19 <identity> it looks incorrect at a glance if that's what you mean
16:21:36 <Eduard_Munteanu> identity: GADTs are sort of a manual-resolution flavor of typeclases
16:22:18 <identity> Eduard_Munteanu: I think I understand what you mean - I have only had reason to use them once, however, and I'm not sure I quite grasp the extent of their.. capabilities properly
16:23:48 <identity> samwise__: my bad, the code is fine, though the type signature is perhaps a little general. What are you trying to do?
16:25:12 <hpc> identity: the short version is that pattern matching on a GADT also matches on the type
16:25:14 <Eduard_Munteanu> identity: in the context of what you're saying, they're probably more appropriate if you want to write a DSL
16:25:59 <hpc> so, data Foo where IntFoo :: Foo Int, StringFoo :: Foo String
16:26:10 <hpc> f :: Foo a -> a
16:26:15 <hpc> f IntFoo = 5
16:26:22 <hpc> f StringFoo = "string"
16:27:38 <hpc> this can produce an effect that looks a lot like pattern matching on type variables, which lets you do some things similarly to type classes
16:27:38 <Eduard_Munteanu> data Matrix :: Nat -> Nat -> * where Mul :: Matrix m n -> Matrix n p -> Matrix m p
16:28:21 <samwise___> damn , xmonad random froze ..this is the second time omn a differnet laptop onthe same day!
16:28:52 <Eduard_Munteanu> But you can do that with typeclasses too,
16:28:58 <Eduard_Munteanu> s/,/./
16:29:04 <oakwhiz_> samwise___: could it be your graphics drivers
16:29:23 <oakwhiz_> those probably aren't written in haskell :-)
16:29:30 <identity> hpc: I see -- I believe I understand
16:29:37 <samwise___> oakwhiz: not sure ...it's a bit weird the same thinghappened on two different computerson the same day
16:29:53 <identity> Eduard_Munteanu: Oh, I see. I guess that is what I was thinking about, yeah
16:29:57 <enthropy> samwise___: we have an #xmonad channel on this network too
16:30:00 <hpc> identity: GADTs are pretty powerful, so it's hard to nail down one thing they're good for
16:30:34 <enthropy> might be that you have the same mistake in the configuration (haskell program) on both systems
16:30:35 <samwise___> enthropy: thanks, but I put that out there cause I got disconnected when someonereplied to my query on here ...before..getting..disconnected
16:30:39 <mm_freak_> samwise___: xmonad froze a few times for me, until i figured out that it was my own fault…  i had a concurrency problem in my configuration =)
16:30:45 <hpc> if the friend you are explaining to knows java, a (quite flawed) metaphor might be java generics and the instanceof keyword
16:30:59 <samwise___> mm_freak: do tell me more
16:31:03 <hpc> except with checking by the compiler
16:31:19 <mm_freak_> samwise___: written to an MVar that was never read
16:32:29 <samwise___> mm_freak: do not know enough tounderstand what youtyped down...would one (knowledgeable enough) happen to know such a problem by just looking at the config file?
16:32:48 <mm_freak_> samwise___: then it's very unlikely that you're running into the same problem =)
16:33:00 <identity> hpc: Aah, okay. It's a clojure dude, so I think he knows java as well
16:33:00 <mm_freak_> samwise___: in any case #xmonad is definitely a better channel for this
16:33:12 <samwise___> mm_freak: understood
16:39:15 <jowens> anyone able to explain memoization wrt the Haskell wiki page (specifically, the examples there and why one memoizes and the other doesn't)?
16:39:40 <c_wraith> Eduard_Munteanu: I don't see anything on GHC trac that appears to be that bug.  You should report it.
16:40:54 <Eduard_Munteanu> Ok, thanks.
16:46:33 <hpc> jowens: it's a particular application of sharing
16:46:55 <jowens> http://www.haskell.org/haskellwiki/Memoization
16:46:56 <hpc> sharing is the word for x = foo(); y(x, x); instead of y(foo(), foo())
16:47:32 <jowens> i'm asking about slow_fib vs. memoized_fib
16:48:15 <jowens> anyway, tell me about sharing. what is the benefit of sharing vs. not?
16:48:21 <hpc> sharing in ghc works by giving something a name
16:48:35 <Eduard_Munteanu> jowens: not recomputing expensive stuff
16:48:36 <jowens> ah. that makes sense.
16:48:44 <jowens> if it has a name, it is memoized?
16:48:48 <jowens> e.g. not recomputed?
16:48:51 <hpc> no, we're building up to that
16:48:56 <jowens> oh, ok, listening.
16:49:07 <hpc> so to memoize things, you have to somehow hold onto that thing you just computed
16:49:13 <jowens> nod.
16:49:23 <hpc> which is where haskell starts to look quite un-haskell ;)
16:49:49 <jowens> yeah, i didn't want to have to write a mutable data structure to store memoized results.
16:49:52 <hpc> in the slow_fib example, we have lots of recomputation
16:50:18 <hpc> in the memoized version, we define a list of fibs
16:50:21 <hpc> and then index into it
16:50:29 <jowens> and that list is "shared"?
16:50:36 <hpc> the list is shared between calls, indeed
16:50:46 <jowens> ok. and every individual index within it, also shared?
16:51:05 <jowens> e.g. fib[12]
16:51:24 <hpc> yeah
16:51:31 <hpc> there's a neat thing in ghci, called :sprint
16:51:38 <hpc> which shows you how evaluated a thing is
16:51:44 <jowens> ooh
16:51:59 <hpc> so, i'm going to make a slight transformation to memoized_fib so we can see the list of fibs
16:52:04 <hpc> bear with me a sec
16:52:11 <jowens> thx. haven't used ghci yet.
16:54:14 <hpc> http://lpaste.net/6227749832430190592
16:54:29 <jowens> ok
16:54:31 <hpc> write that into tmp.hs, then run "ghci tmp.hs"
16:55:01 <hpc> then type ":sprint fast_fibs"
16:55:03 <jowens> the diff appears to be that fast_fibs is a list as opposed to a-list-with-the-index-operator?
16:55:22 <hpc> fast_fib is the function, i've moved the other parts to the top level
16:55:32 <qrada> im using the vector library for 'multi dimensional arrays', it's somewhat hard to work with.. im using it to implement an adjacency matrix.. anyone know off top of an alternative I could use?
16:55:44 <qrada> i basically have used data.map, data.vector, and data.marray
16:55:47 <hpc> so the output of that sprint thing is "_" because nothing has been evaluated yet
16:55:50 <jowens> right
16:55:57 <jowens> lazy
16:56:02 <Eduard_Munteanu> qrada: repa
16:56:15 <hpc> if you do fast_fib 0, you get 1
16:56:20 <hpc> then :sprintf fast_fibs
16:56:27 <hpc> output will be "1 : _"
16:56:30 <jowens> yes. now it's, i guess, memoized
16:56:33 <Eduard_Munteanu> qrada: what exactly is hard?
16:56:42 <qrada> ooh nice, thanks Eduard_Munteanu
16:56:43 <qrada> will check that
16:56:44 <jowens> output is 0 : _, since you defined it wrong :)
16:56:57 <hpc> well, close enough ;)
16:57:01 <jowens> np
16:57:12 <qrada> i dont know, it's not 'hard', it's just messy.. but im a haskell beginner.. modifying the vector of vector's just seems a bit messy
16:57:23 <hpc> continue for larger n, and you see a pattern emerge
16:57:41 <jowens> well, i should skip to a larger n
16:57:42 <Eduard_Munteanu> qrada: that's not how you do things with arrays and stuff
16:57:43 <hpc> the list fast_fibs gets more and more evaluated
16:57:43 <jowens> and then see
16:57:58 <Eduard_Munteanu> qrada: they accept tuples as indexes too
16:57:59 <jowens> and that evals everything smaller
16:58:00 <jowens> as it should
16:58:16 <Eduard_Munteanu> :t listArray
16:58:17 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
16:58:23 <jowens> the tough part for me is not the memoization / why memoization works
16:58:29 <jowens> it's when it chooses to memoize and when it doesn't
16:58:37 <hpc> indeed
16:58:42 <Eduard_Munteanu> > listArray ((0, 0), (1, 1)) [1,2,3,4]
16:58:44 <lambdabot>  array ((0,0),(1,1)) [((0,0),1),((0,1),2),((1,0),3),((1,1),4)]
16:58:44 <jowens> and you're saying sharing
16:59:04 <jowens> and, afaict, that is tied closely to naming
16:59:10 <jowens> that in your code, fast_fib is named
16:59:13 <hpc> sharing is the underlying mechanism that makes memoization work
16:59:22 <hpc> in my code, fast_fibs is named
16:59:45 <Eduard_Munteanu> qrada: ^ you should do that instead of using nested lists or arrays
16:59:53 <jowens> and by "named", you mean "it's in an explicit data structure that has a name"
16:59:55 <jowens> is that accurate?
17:00:01 <hpc> yeah
17:00:08 <jowens> that's very clear.
17:00:09 <hpc> just bound to an identifier
17:00:17 <jowens> and, i might add, much much clearer than th ewiki
17:00:24 <hpc> the wiki's example does not have the list bound, which is confusing
17:00:24 <jowens> where that distinction is not called out at all
17:00:29 <qrada> cool thanks.. my multi dem arra is say, 20 x 20, .. so what im doing right now is horrible
17:00:35 <hpc> so let's look at how that works
17:01:04 <jowens> i'm *presuming* that the list then !! has the same sharing properties as the list?
17:01:25 <hpc> yes
17:01:38 <jowens> why?
17:01:56 <hpc> gimme a sec, it's weird to me too and i haven't thought about this in a while ;)
17:01:57 <jowens> is it internally "it's a list, and it happens to have this operator tacked on to it, but basically, think of it like a list"?
17:02:04 <qrada> ok cool i have some better stuff to work with now, thanks. off to mess with it
17:03:38 <hpc> damn, there's a lot happening with that function
17:04:04 <jowens> hpc: i presume that last sentence is actually the motto of Haskell
17:04:12 <hpc> haha
17:04:38 <speckle> jowens, which one - "weird to me too" or "a lot happening"? "_
17:04:50 <jowens> the latter :)
17:04:54 <syllogismos> ca we write bind in terms of <*> and <$>?
17:05:16 <hpc> oh, i remember now
17:05:28 <cdk> ST and IO are implemented identically in GHC, IO is a State function with a RealWorld state param, whereas ST has an existentially quantified state. So why is it said that ST can sometimes be more efficient than IO?
17:05:49 <hpc> so, the expression (map fib [0..]) is in a sense, "outside" the lambda
17:06:04 <hpc> jowens: so, functions are lambda expressions, ultimately
17:06:12 <Algebr> How is Prelude defined itself? In Haskell as well?
17:06:26 <geekosaur> some of ity
17:06:30 <Eduard_Munteanu> Algebr: yes, but it imports GHC-specific stuff
17:06:34 <hpc> jowens: let's step away from that memoized_fib because it's a damn mess
17:06:45 <jowens> ok
17:06:58 <hpc> jowens: we'll look at (\x -> f expensive x)
17:07:07 <Eduard_Munteanu> Algebr: ultimately it boils down to either FFI calls or primops (very basic functions the compiler provides)
17:07:17 <hpc> or to make this less confusing, we'll call it
17:07:25 <Algebr> Sorry, what does FFI/primops mean?
17:07:30 <hpc> \x -> <f> <expensive> x
17:07:48 <hpc> jowens: where <foo> is "here's a name for a block of code" and not a real identifier
17:07:51 <Eduard_Munteanu> Algebr: FFI means calls to external libraries, like C code
17:07:52 <hpc> which will be important
17:07:52 <jowens> ah ok
17:08:03 <Algebr> oh, foreign function interface right?
17:08:07 <Eduard_Munteanu> Algebr: yes
17:08:12 <Algebr> and primops?
17:08:18 <hpc> most functions you write are going to be something like
17:08:19 <geekosaur> FFI = foreign function interface (calling C from Haskell). "primops" are primitive operations implemented within the compiler or the C runtime and invoked as special Haskell functions
17:08:30 <Eduard_Munteanu> Algebr: I said above... "(very basic functions the compiler provides)"
17:08:35 <hpc> "foo x = blahblah where y = blub"
17:08:40 <jowens> ok
17:08:46 <hpc> this ends up being the same as
17:08:56 <hpc> "foo = \x -> let y = blub in blahblah"
17:09:02 <Algebr> But why does ghc need to rely on C at all? Is there no way to not have to deal with C at all? No way to make the entire haskell toolchain be just Haskell?
17:09:06 <jowens> fair enough
17:09:27 <hpc> when you apply an x to foo, it evaluates the inside anew, every time
17:09:47 <jowens> "apply an x" == "call foo with x as an arg"?
17:09:52 <hpc> y is computed to be blub (might be expensive), stuff is done with it, and then it gets thrown away
17:09:55 <hpc> jowens: yes
17:09:57 <jowens> ok
17:09:59 <jowens> totally get it.
17:10:00 <triliyn> Algebr: I think that would be theoretically possible, but there are a huge number of low-level tools developed for working with C and it would be a lot of work to reimplement those
17:10:06 <jowens> (so far)
17:10:09 <hpc> now we do something quite strange
17:10:15 <hpc> foo = let y = blug in \x -> blahblah
17:10:25 <Algebr> ah, thanks all.
17:10:33 <jowens> blug is outside the lambda
17:10:37 <hpc> yep
17:10:38 <jowens> and perhaps not reevaluated?
17:10:42 <hpc> and it can never be thrown away
17:10:51 <jowens> ah. it's tied to foo, inextrictably?
17:10:55 <hpc> indeed
17:11:00 <jowens> hmmmm interesting
17:11:14 <jowens> so when we want to memoize, we want to move anything we want to memoize outside the lambda, so to speak
17:11:23 <hpc> essentially
17:11:34 <jowens> things inside the lambda, re-evaled.
17:11:36 <jowens> outside, not.
17:12:03 <jowens> so can you translate memoized_fib = (map fib [0 ..] !!) into lambda for me?
17:12:07 <Algebr> So for example, doing ":i error", I get -- Defined in 'GHC.Err', is there a way for me to see that definition, or would that be a primop?
17:13:40 <hpc> jowens: memoized_fib = let fib = <definition> in \i -> (map fib [0..]) !! i
17:13:59 <hpc> hmm
17:14:11 <hpc> yeah, i am not sure how that memoizes either now
17:14:13 <jowens> not clear
17:14:14 <jowens> yeah
17:14:46 <jowens> (also, separate question: why can't we cache something inside the lambda? is that a possible optimization in haskell or instead something inherent in the way haskell is designed?)
17:15:10 <jowens> (who knew project euler question 14 would be this involved.)
17:15:20 <triliyn> jowens: I think the problem is just that it's hard to tell when it's a good idea to save things
17:15:27 <hpc> ^
17:15:42 <hpc> in specific instances you can sometimes guess what is wanted
17:15:48 <triliyn> Storing too many calculations means you're using way more memory than you need to be
17:16:08 <hpc> which leads to such things as java's string cache (iirc?)
17:16:20 <jowens> triliyn: makes sense. but then i'd think it might be a little easier to give a hint to the compiler, so to speak, that is a little less involved than what seems to be a fairly complex transformation
17:16:46 <jowens> to pass it a "memoize me" tag on the data structure
17:16:55 <triliyn> jowens: that seems like it would be doable, but no one's done the work yet
17:16:57 <jowens> which is surely not a haskelly way to say it, but you get it.
17:17:06 <triliyn> Also, these things can often be harder than they seem
17:17:18 <jowens> there is a data.function.memoize library, but it's not real clear how it ought to be used (at least for me)
17:17:58 <jowens> hpc: you figure out how your lambda translation memoizes?
17:18:06 <hpc> no :P
17:18:20 <hpc> i think just chalk it up to a ridiculous example
17:18:56 <hpc> anyhoo, to summarize, sharing is the underlying mechanism for memoization
17:19:00 <jowens> well, i feel a lot smarter than i did 20 minutes ago, so thank you.
17:19:23 <jowens> docs elsewhere seemed to imply this had something to do with "CAF"
17:19:25 <hpc> sharing is where something is bound to a name so the same thing can be used in multiple places (shared)
17:19:34 <jowens> sensible.
17:19:42 <hpc> ooh, good term to know!
17:19:52 <hpc> CAF is short for constant applicative term
17:19:58 <hpc> which is a nerdy way of saying constant
17:20:08 <hpc> (there's more to it than that ;))
17:20:12 <jowens> "something that can be constantized at compile time"?
17:20:19 <hpc> sort of
17:20:21 <triliyn> Isn't there always?
17:20:27 <hpc> in the hpaste i wrote, http://lpaste.net/6227749832430190592
17:20:32 <hpc> fast_fibs is a CAF
17:21:22 <jowens> i'm presuming it's different than immutable
17:21:50 <hpc> CAFs are immutable
17:22:06 <hpc> oddly, dictionary.com has a definition for it: http://dictionary.reference.com/browse/constant+applicative+form
17:22:10 <hpc> and a pretty good one too
17:22:29 <jowens> lifted straight from http://www.haskell.org/haskellwiki/Constant_applicative_form
17:22:50 <jowens> lifted straight from Peyton-Jones. :)
17:22:51 <hpc> it's a value that's not a lambda abstraction (not a function)
17:23:06 <hpc> and contains no free variables
17:23:17 <jowens> ok. i pretty much grok that.
17:23:20 <jowens> it's more than just a constant.
17:23:29 <hpc> (meaning, variables coming from function parameters)
17:23:36 <jowens> got it
17:23:38 <hpc> so it's a thing you can put at the top level
17:23:57 <hpc> it starts as a thunk and gradually becomes evaluated over time
17:24:07 <hpc> which is a kind of mutation, in the sense that we care about the effect it has
17:24:38 <jowens> and if a CAF is named, it is also memoized ?
17:24:58 <hpc> yeah
17:25:05 <hpc> within the scope it is defined in
17:25:18 <jowens> ok. i can live with that.
17:25:43 <hpc> so if you don't want that huge list of fibs sticking around forever, but you want to get the next five starting at index 1-billion
17:25:55 <hpc> define that infinite fibs list somewhere in a function :D
17:26:48 <jowens> hpc: you're a good person. thanks for this thoughtful tutorial.
17:26:50 <jowens> very much appreciated.
17:27:01 <hpc> np
17:27:11 <zRecursive> @wn memoize
17:27:12 <lambdabot> No match for "memoize".
17:28:36 <hpc> jowens: well, it keeps my brain in shape ;)
17:29:10 <syllogismos> > filterM (\x -> if x ==1 then Nothing else Just True) [1,2,3]
17:29:12 <lambdabot>  Nothing
17:29:32 <jowens> good. well, i'll be back.
17:29:41 <jowens> there's a ton of interesting stuff for me to learn.
17:29:47 <hpc> btw, the mess you just learned your way through is why we're so careful about side effects
17:30:10 <jowens> it seems powerful that you either can or can't memoize and the right result comes out in either case
17:30:13 <jowens> gives the compiler a lot of freedom
17:33:28 <syllogismos> filterM          :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:33:29 <syllogismos> filterM _ []     =  return []
17:33:29 <syllogismos> filterM p (x:xs) =  do
17:33:29 <syllogismos>    flg <- p x
17:33:29 <syllogismos>    ys  <- filterM p xs
17:33:29 <syllogismos>    return (if flg then x:ys else ys)
17:33:41 <syllogismos> > filterM (\x -> if x ==1 then Nothing else Just True) [1]
17:33:43 <lambdabot>  Nothing
17:33:48 <syllogismos> > filterM (\x -> if x ==1 then Nothing else Just True) [2,1]
17:33:50 <lambdabot>  Nothing
17:34:50 <syllogismos> when we do ys <- Nothing what happens?
17:34:59 <syllogismos> the whole result is nothing?
17:35:44 <ion> @src Monad Maybe
17:35:44 <lambdabot> Source not found. Sorry.
17:35:48 <ion> @src Maybe >>=
17:35:49 <lambdabot> Source not found. Are you on drugs?
17:35:54 <ion> @src Maybe (>>=)
17:35:54 <lambdabot> (Just x) >>= k      = k x
17:35:54 <lambdabot> Nothing  >>= _      = Nothing
17:35:55 <syllogismos> lol
17:36:35 * hackagebot dns 1.1.1 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.1.1 (KazuYamamoto)
17:38:13 <enthropy> > do x <- Nothing; return 2
17:38:14 <lambdabot>  Nothing
17:38:50 <syllogismos> @undo do x <- Nothing; return 2
17:38:51 <lambdabot> Nothing >>= \ x -> return 2
17:39:48 <identity> syllogismos: That is essentially the reasoning behind Maybe. If you have a computation that can fail or produce a result, and it cannot be complete without its parts, then any Nothing 'in the pipeline' will result in Nothing.
17:41:05 <nolrai66> So is there a reason "unRunMaybeKT :: m (Maybe a) -> MaybeKT m a" doesn't exist? Its absense makes writing MonadReader ect. instances really hard.
17:41:42 <identity> nolrai66: GeneralizedNewtypeDeriving?
17:42:06 <enthropy> is MaybeKT the same as MaybeT?
17:42:20 <nolrai66> Its a optimization of MaybeT.
17:42:37 <nolrai66> http://hackage.haskell.org/package/unification-fd-0.8.0/docs/Control-Monad-MaybeK.html
17:44:33 <syllogismos> haskell is turning out to be very hard to me.. I can program in it now.. but I still lack major intuitions that must be a second nature to me..
17:45:15 <geekosaur> keep working with it. it was helping out with xmonad that got me out of that pit
17:45:33 <nolrai66> syllogismos: like how?
17:46:39 <syllogismos> even list and maybe monads gives me results that I wasnt really expecting..
17:47:25 <syllogismos> > sequence [[1,2,3],[2,3],[1]]
17:47:27 <lambdabot>  [[1,2,1],[1,3,1],[2,2,1],[2,3,1],[3,2,1],[3,3,1]]
17:47:34 <syllogismos> for example ^
17:49:09 <ion> > sequence [["hi"], ["world", "syllogismos"], [".", "!"]]
17:49:11 <lambdabot>  [["hi","world","."],["hi","world","!"],["hi","syllogismos","."],["hi","syllo...
17:50:19 <ion> > do greeting <- ["hi"]; whom <- ["world", "syllogismos"]; punctuation <- [".", "!"]; return [greeting, whom, punctuation]
17:50:21 <lambdabot>  [["hi","world","."],["hi","world","!"],["hi","syllogismos","."],["hi","syllo...
17:51:04 <syllogismos> > sequence [[1,2,3],[2,3],[]]
17:51:06 <lambdabot>  []
17:52:13 <syllogismos> well now it makes sense..
17:52:59 <identity> Drink a couple(as in 2) of beers. That's where scientists say you get more creative
17:53:10 <hpc> the balmer peak :D
17:53:34 <identity> Haha, indeed
17:53:37 <monochrom> I disbelieve in that
17:54:10 <identity> I was slightly intoxicated when monads 'clicked' for me
17:54:32 <monochrom> or, I should believe in that. for all humans except the smartest ones, creativity = production of errors
17:54:33 <dwcook> Have there been real studies done on that sort of thing?
17:54:49 <identity> dwcook: Yep, IIRC
17:54:57 <identity> Even one 'going around' media just recently
17:55:25 <monochrom> dailywtf is a catalog of creativity
17:55:33 <hpc> monochrom: some neat things can come out of mistakes
17:55:51 <monochrom> yes. 1:10000000 things
17:56:01 <hpc> a few hours ago, someone in #haskell-game got a constant wrong in a GLSL shader and the effect was kinda cool
17:56:10 <monochrom> some people get rich from lottery, too
17:57:03 <syllogismos> so you people remember when monads click? lool
17:57:15 <identity> syllogismos: It was a momentous occasion
17:57:29 <jxv> I was writing in C
17:57:34 <monochrom> I learned monads from Wadler's tutorial and the monadic parser paper
17:57:41 * dwcook contemplates how to write a monad transformer that embodies creativity
17:57:47 <dwcook> unsafePerformIO and random?
17:57:57 <monochrom> that's just MonadRandom
17:57:59 <kristof> I learned monads from adit.io
17:58:01 <kristof> :)
17:58:05 <hpc> http://hackage.haskell.org/package/monadacme
17:58:08 <kristof> The pictures were awesome
17:58:09 <dwcook> monochrom, ah, true.
17:58:36 <dwcook> hpc, no documentation?
17:58:55 <identity> dwcook: Reader Beer?
17:58:55 <monochrom> MonadRandom suffices for creativity. but you can always throw in unsafePerformIO for more creativity.
17:59:00 <identity> You can only consume Beer.
17:59:18 <hpc> documentation is limiting
17:59:43 * dwcook notices the unsafeCoerce in the source code
18:00:40 <dwcook> Is that the only thing notable about this? That fail uses unsafeCoerce? I can't imagine what that would be good for.
18:00:44 <dwcook> Or bad for, as the case may be.
18:01:10 <dwcook> … Oh.
18:01:10 <shachaf> I don't think "monads" is a thing that "clicks".
18:01:28 <dwcook> Well, that's silly. :P
18:01:32 <shachaf> The "click" is a red herring, if anything.
18:01:59 <nolrai66> Yeah...not really. I mean its more like understanding a notation then a proof.
18:02:07 <monochrom> it was a more gradual process for me, yes
18:03:13 <identity> I agree, but nevertheless there was a moment when some .. importance piece just 'made sense' in my head that let me continue etc.
18:03:37 <shachaf> Every time I remember that I've seen someone say "monads have just clicked for me! a monad is really just X!", it was wrong or only correct in some special case.
18:03:39 <monochrom> expect many micro clicks, not one single final click
18:03:58 <identity> In reality, it was just about getting to terms with the abstract nature of what a monad is and not trying to 'understand it more than necessary'
18:04:23 <monochrom> one day, Maybe clicked. another day, State clicked. later, a parser monad clicked. a year later, Cont clicked. etc etc etc
18:04:47 <identity> monochrom: Ah yes, that was also a whole another thing for me. Especially state. I had a hard time with that.
18:04:55 <kristof> shachaf: "a comonad is just a coburrito!" is my favorite comment related to what you're talking about. Abstract algebra is abstract by definition (otherwise it wouldn't be useful), so trying to express it in concrete examples is counterproductive
18:04:57 <Algebr> ugh....people talking years....I'm just working in Haskell for about a week and was expecting to be productive in a months time.
18:05:06 <dwcook> I'm not sure when I started to understand how to use monad transformers, for example, but one day I just realized they weren't that hard.
18:05:23 <hpc> Algebr: productive, certainly
18:05:25 <dwcook> Lots of little details build up a big picture over time.
18:05:27 <hpc> Algebr: but you keep learning forever
18:05:28 <bitemyapp> kristof: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
18:05:37 <monochrom> people look too hard for shortcuts to learning and practicing
18:05:39 <bitemyapp> kristof: http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html
18:06:04 <levi> Algebr: You can be playing chess and having fun the day you learn the rules. Might take a while to master it, though. :)
18:06:20 <identity> dwcook: Yeah, pretty much the same thing here. Same with State(I tackled monad transformers mainly through StateT). All of a sudden, I could just.. use it and it made sense.
18:06:22 <bitemyapp> kristof: re: Codata and Comonads in Haskell - "This paper suggests that a useful interpretation of comonads in programming is that they account for effects originating in the context of a program fragment, effects to which the program fragment may react and which it may further propagate.
18:06:24 <monochrom> a month of honest learning can be saved by a year of looking for a blog post that makes you click
18:06:37 <identity> Basically banging my head agains the wall until it had stirred things up enough for stuff to make sense.
18:06:44 <bitemyapp> monochrom: I find papers are often more substance dense than blog posts.
18:07:12 <monochrom> yeah, Wadler's monad tutorial (a paper) is still the best one
18:07:30 <Algebr> monochrom, Its not that I'm looking for shortcuts, just thinking that a months time in any c-like language yields more understanding than Haskell.
18:07:34 <shachaf> monochrom: There are genuine insights about monads-the-abstraction, rather than about any concrete monad.
18:07:42 <shachaf> But I don't think they come as a click.
18:08:18 <identity> Algebr: Well, if you've done no functional programming before and you come from an imperative background, then the paradigm shift can be rough, yes.
18:08:46 <Algebr> identity, do you think the same would have been true in the inverse?
18:08:55 <levi> I'm trying to figure out the significance of how monads arise from adjunction. I have some vague ideas, but it will take a bit more reading for it to gel, I think.
18:09:09 <monochrom> Algebr, you need to consider this:
18:09:18 <monochrom> @quote monochrom haskell book
18:09:19 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the entire human race would have to be rewritten!
18:09:25 <monochrom> um, not that one
18:09:25 <identity> Algebr: I'm not sure, really. I've never met anyone that started out programming in something like Haskell.
18:09:33 <monochrom> @quote monochrom haskell.book.or
18:09:34 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
18:09:45 <monochrom> that one
18:10:02 <bitemyapp> monochrom: I hadn't heard of this book, I'll look into it. Thanks!
18:10:04 <levi> Algebr: I see all the time where people without an object-oriented background take a long time to really get object-oriented programming. The terms are a bit more familiar, but their technical meanings and the effects they have on program structure often aren't.
18:10:58 <identity> levi: Yeah, I agree on this. I just started studying computer science and many of my class mates have no experience with programming. Object oriented programming is *really* hard for some of them.
18:11:47 <levi> I don't think monads are particularly more difficult than objects, as program-structuring tools. It's hard to judge properly, though.
18:12:11 <identity> I've wondered how it's like for a complete 'newbie' to programming to start out with something like Haskell.
18:12:19 <identity> but as I said, I've never met anyone that has.
18:12:31 <spaceships> objects are pretty intimidating at first, just like monads ..
18:12:35 <dwcook> I'd like to try that. Get one of my presently non-programmer friends to learn Haskell.
18:12:42 <bitemyapp> identity: I've met and taught people like that.
18:12:47 <bitemyapp> identity: it's often easier in some respects.
18:12:56 <dwcook> I don't think it would be more painful than trying OO first.
18:12:57 <bitemyapp> than teaching somebody walking in with blub knowledge.
18:13:11 <levi> Well, the Racket people have made a lot of effort into getting their particular Scheme-based language taught to non-programmers and have had a lot of success.
18:13:17 <bitemyapp> that having been said, there are aspects of "procedural" languages that come more naturally to people absent some mathematical training.
18:13:17 <Algebr> levi, my problem is more about how to actually structure a haskell program. I'm thinking, well, if a function is not a series of statements, that its just returning a value, then heck, a haskell program must have like tons of tiny functions
18:13:37 <bitemyapp> Algebr: sometimes, yeah.
18:13:47 <bitemyapp> Algebr: you'd be surprised how much is already out there though.
18:13:47 <identity> bitemyapp: Yes, naturally. Imperative 'programming' is a how peoples' minds work in many areas
18:13:54 <identity> Following instructions, planning their day, etc.
18:13:59 <tautologico> many small functions is much more composable than large monolithic functions
18:14:05 <bitemyapp> identity: sometimes. again, mathematical training defenstrates this home-team advantage.
18:14:11 <bitemyapp> identity: basic algebra goes a long way.
18:14:17 <dwcook> There's still some form of sequencing there, but it's in function composition.
18:14:24 <levi> Algebr: Haskell programs *do* have tons of tiny functions. They're just not always given standalone definitions.
18:14:30 <Algebr> I'm coming from a decent math background and its still not exactly coming easy.
18:15:41 <spaceships> if you hit a wall, come back to it in a few months instead of banging head repeatedly
18:15:42 <bitemyapp> Algebr: the pedagogy surrounding Haskell is still very far from optimal.
18:15:49 <bitemyapp> Algebr: https://gist.github.com/bitemyapp/8739525
18:16:29 <djahandarie> edwardk, have anything for Tango Trees in Haskell?
18:16:34 <Algebr> bitemyapp, Thanks!! I'll use that as a guide
18:16:44 <edwardk> nope. they kinda suck to do functionally
18:17:02 <djahandarie> Darn.
18:17:37 <bitemyapp> edwardk: somewhere a grad student donned their armor and mounted Rocinante
18:17:49 <bitemyapp> djahandarie: just use a binary search tree and see what pans out.
18:18:40 <Algebr> although some stuff, because I'm coming from Python, has come easier, zip, functions first -class, etc.
18:19:24 <identity> I went from Haskell to python(for mandatory school stuff) and it made me a sad, sad panda.
18:19:36 <bitemyapp> identity: Algebr I do python for a living. gag.
18:19:49 <bitemyapp> I write relatively functional Python and it still makes me grumpy.
18:19:59 <identity> bitemyapp: I don't mean I hate it as such, but it was so weird not to have static typing and such
18:20:01 <dwcook> Among dynamically typed languages, I find Python among the most palatable.
18:20:03 <Algebr> heh, I do Python for a living and wish I could do Haskell for a day job.
18:20:21 <levi> I think trying to write Python in a functional style is a sure recipe for grumpiness. :)
18:20:22 <dwcook> That said, ever since I grokked Haskell I haven't wanted to do anything more than I want to do Haskell.
18:20:31 <identity> I don't mind python at all, really, but its dynamic nature just makes.. little sense to me
18:20:35 <no-n> I like and dislike Python
18:20:48 <Algebr> What is all the hate about the dynamic side?
18:20:48 <identity> (coming from Haskell)
18:21:03 <dwcook> One thing I had success with in Python that would be harder in Haskell was changing a piece of code out from under a running server.
18:21:26 <identity> dwcook: Probably. But doesn't xmonad do essentially that? I have never really understood how though.
18:21:31 <levi> Algebr: Haskell trains you to take advantage of the fancy type system, and going back to not using it feels weird.
18:21:34 <dwcook> I'm not familiar with xmonad.
18:21:57 <identity> dwcook: ah. window manager written in Haskell.
18:22:02 <monochrom> I hate errors. that's what I hate. dynamic typing is just a way to hide away more errors. but it's errors, not dynamic typing, that I hate.
18:22:04 <levi> xmonad does do something like that, and the bit that does it is in a re-usable library (yi uses it as well).
18:22:20 <dwcook> That's about all I know about it, actually. I've been meaning to try it but keep not bothering. :P
18:22:25 <dwcook> I'm mostly satisfied with awesome.
18:22:26 <identity> dwcook: You should.
18:22:33 <monochrom> you could say, dynamic typing is just an accomplice, not the real boss
18:22:38 <identity> dwcook: It's like going from *insert language here* to Haskell. There's just no going back.
18:22:45 <identity> monochrom: Heh, I guess, yeah.
18:22:51 <bitemyapp> dwcook: plugins and Hint.
18:23:13 <levi> dwcook: I tried awesome after getting used to xmonad (I like lua a lot) but found that it seemed terribly slow for some reason. Might have been the default config or something, though.
18:23:20 <identity> I just remember writing my first bits of code in python and have it actually run *parts* of my code, till a part where I had typo'd a method or some such, at which point it decides to crash on me.
18:23:37 <identity> I just sat and stared.. "did it just run *parts* of my code and die?"
18:23:42 <bitemyapp> levi: been fine for me, for a very long time
18:23:51 <Algebr> identity: umm, unit tests?
18:23:52 <enthropy> ghc has a -fdefer-type-errors anyways
18:23:58 <bitemyapp> identity: hahahahaha. i kno rite?
18:23:59 <dwcook> levi, this probably doesn't say much, but awesome is faster than any desktop environment I tried – Cinnamon, MATE, KDE, or even xfce
18:24:11 <identity> Algebr: Heh, of course. This was just in the very beginning of my python learning experience.
18:24:28 <Algebr> I will say that Haskell is making my Python and in general understanding of programming in general better.
18:24:29 <levi> dwcook: Well, don't try xmonad then. It may make you dissatisfied. ;)
18:24:37 <Algebr> err, just one general.
18:24:40 <hakujin> Algebr: if all your unit tests pass you aren't testing the right things; if you are you just replicated all of the work of a type system anyway
18:24:51 <dwcook> Oh I know I'll try it eventually. But it will have to be a time I feel like sitting around playing with a config file, probably. :P
18:25:09 <identity> bitemyapp: It's not that it's essentially wrong or anything, but it felt so very strange to go from Haskell which does not let you run anything but a completely type-checked module that is guaranteed to function in some way unless you're doing something bad, to something that doesn't know which objects have which methods until it tries to call those methods.
18:25:36 <levi> dwcook: Yeah, it does take some time to figure out the tweaking of it.
18:26:19 <dwcook> levi, well, besides that, I'm addicted to configuring things :P
18:26:32 <identity> Taking a peek at someone else's xmonad.hs will help.
18:27:23 <identity> dwcook: gah.. We share the same sickness, then. I can just go through my dotfiles and configure shit, tweaking stuff here and there for an entire evening.
18:27:33 <identity> it seems I can keep doing this rather frequently
18:27:44 <levi> I found the default config pretty reasonable, I just added an xmobar and tweaked a few of the bindings.
18:28:35 <levi> It was my first tiled window manager, though, and I am used to making myself comfortable with defaults.
18:29:39 <Algebr> One thing I'm having trouble understanding is how Haskell could be used for say GUI programming. I mean, you have a widget, I click on it and I need a callback to go off and change the state of something underlying the widget.
18:29:59 <identity> levi: Essentially, I have the same, but there are a good deal of keybindings, some code to talk to dbus to talk to spotify for media keys, configuration for xmobar, top level definitions for colors of various things etc.
18:30:05 <dwcook> That reminds me, I've been meaning to figure out what FRP's all about
18:30:15 <monochrom> one way to do GUI in Haskell is IO. the same way you get console I/O anyway.
18:30:21 <spaceships> Algebr: that's what the IO monad is for :)
18:30:54 <monochrom> when doing IO you do have a series of statements. it is not different there.
18:32:01 <monochrom> otoh, logically, I don't see why "add 1, times 2, take square root" must be a series of statements rather than an expression sqrt((x+1)*2)
18:32:47 <dwcook> You can view it as sqrt . (*2) . (+1), which in a way looks like a series of steps
18:33:02 <monochrom> http://www.vex.net/~trebla/haskell/gtk-interact.xhtml is my gtk example
18:33:47 <kusut> considering to buy "beginning haskell". it is good, right?
18:34:38 <monochrom> yes dwcook, but some people may be thinking "tmp1 = x+1; tmp2 = tmp1*2; answer = sqrt tmp2"
18:35:04 <dwcook> monochrom, what's so wrong about that? It gives you the same answer
18:35:10 <monochrom> do you know what's wrong with that? it undoes the progress made by fortran 50 years ago
18:35:38 <dwcook> What progress was that?
18:35:42 <ski> expressions
18:35:55 <ski> *nestable* expressions
18:35:56 <tautologico> FORmula TRANslator...
18:36:05 <ski> (one might even say "composable")
18:36:07 <monochrom> it's a regress. the whole point of fortran is so that you can screw all those tmp1 tmp2 and just write sqrt((x+1)*2) directly. and today people want to go back 50 years, they want their 3-address instructions back.
18:36:39 * hackagebot hoauth2 0.3.6 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.6 (HaishengWu)
18:36:54 <dwcook> I've never thought of nestable expressions as something that I couldn't use. Well, except in Assembly. What an odd concept.
18:37:13 <hakujin> monochrom: do people want to do that inherantly? I doubt. I think people who were taught that is the way you solve problems tend to solve problems that way
18:37:55 <ski> monochrom : aye, and with that, too much focus on the low-level, operational semantics details, and too little focus on the high-level, denotational, or even axiomatic (such as equational), semantics
18:39:33 <monochrom> hakujin, it seems to be part of OOP mindset. one o.m(param) per line.
18:39:59 <CaptainK> why are `div` and /  part of different type classes?
18:40:10 <ski> CaptainK : different concepts
18:40:16 <c_wraith> because they do different things
18:40:27 <ski> CaptainK : integral (approximate) division, vs. real division
18:40:38 <hakujin> monochrom: agreed; the real problem is initial education then yeah?
18:40:39 <dwcook> > (3 `div` 2, 3 / 2)
18:40:41 <lambdabot>  (1,1.5)
18:40:52 <CaptainK> :t `elem`
18:40:54 <lambdabot> parse error on input ``'
18:40:59 <c_wraith> what div does doesn't make sense for floating-point numbers.  What / does doesn't make sense for integral numbers
18:41:02 <CaptainK> :t (elem)
18:41:03 <lambdabot> Eq a => a -> [a] -> Bool
18:41:25 <CaptainK> ok, gtk
18:41:28 <CaptainK> thx
18:41:40 * hackagebot hoauth2 0.3.6.1 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.3.6.1 (HaishengWu)
18:49:29 <ski> @type (`elem`)
18:49:31 <lambdabot> parse error on input `)'
18:49:36 <ski> @type elem
18:49:37 <lambdabot> Eq a => a -> [a] -> Bool
18:53:55 <dwcook> ski, it's too bad you can't infinitely nest those :D
18:54:03 <dwcook> (`(f . g)`)
18:54:31 <Taneb> That'd be a neat language extension
18:55:31 <dwcook> Somehow I've never wanted to infix an arbitrary expression, but I'm sure someone would find a use for it
18:58:44 <shachaf> (`elem`) should be allowed. `(f)` shouldn't be allowed, because `` syntax is for identifiers, not expressions.
18:59:48 <Ralith> is there a particular reason it's not for expressions?
19:00:27 <shachaf> It would be complicated.
19:00:29 <ski>   infix 4 `elem`
19:00:46 <shachaf> Nesting ``s is not obvious.
19:00:54 <ski> @type (2 `elem`)
19:00:55 <lambdabot> (Eq a, Num a) => [a] -> Bool
19:01:12 <ski> since those sections work, arguably the "section" above should also work
19:01:13 <shachaf> But (OP) should just be a two-way section of OP
19:01:17 <shachaf> Right, what ski said.
19:02:48 <PhineasRex> I'm trying to make Maybe an instace of the PathPiece type class but I get "Expecting on more argument to `Maybe`"
19:02:57 <PhineasRex> s/instace/instance/
19:04:52 <Algebr> Why doesn't ":t main" give anything in ghci?
19:04:58 <weyard> hello I was wondering if someone could tell me what sort of type constructoris being described here  'type LockerMapp = Map.Map  Int (LockerState,code) '
19:05:35 <jxv> Algebr, it needs to be defined first
19:06:14 <geekosaur> did you tell ghci to load a source file that includes main?
19:06:16 <Algebr> jxv, so main isn't a keyword, its just convention?
19:06:29 <Algebr> geek, no, I was just fiddling in ghci
19:06:29 <jxv> correct
19:06:56 <geekosaur> it's the name of a function that the system's runtime support looks for as the entry point for an executable program
19:07:27 <PhineasRex> instance (PathPiece a) => PathPiece (Maybe a) where seems to be what I wanted.
19:08:20 <Algebr> geek, ah, so the runtime is expecting it. So If I don't include a main, my haskell exectuable will do nothing?
19:08:59 <geekosaur> (by ancient convention a crt0.o in the system library directory has code to translate raw parameter and environment information passed to a newly created executable memory image into something that can be accessed from a high level language, does various C runtime setup, and invokes main() with the converted parameter list and often environment)
19:09:17 <geekosaur> well, you can't link it into an executable since it's demanded by the C runtime stub (crt0)
19:10:13 <syllogismos> > (>) [1,2,3] [1]
19:10:16 <lambdabot>  True
19:10:22 <geekosaur> the GHC runtime is written in C so we need the stub (it's somewhere between insane and impossible to make standard operating system calls without using the standard C library, which is initialized by the standard C runtime)
19:10:22 <syllogismos> > (>) [1,2,3] [0,1]
19:10:23 <lambdabot>  True
19:10:28 <syllogismos> > (>) [1,2,3] [0,1,2]
19:10:29 <lambdabot>  True
19:10:44 <dwcook> syllogismos, lexical ordering
19:10:59 <syllogismos> oh like dictionary?
19:11:07 <dwcook> Yes
19:11:41 <dwcook> Compare the first elements, if the same compare the second…
19:11:42 <syllogismos> > (>) [1,2,3] [1,1,9]
19:11:43 <lambdabot>  True
19:12:13 <syllogismos> ok
19:12:38 <ezrios> hm I didn't know list was an instance of ord
19:12:54 <dwcook> As long as the element type is also
19:13:00 <dwcook> I think
19:13:02 <colDrMcBeardman> if I have a string with escaped unicode, e.g., "\u00e9" is there a function I can use to change the escapes to literal unicode glyphs?
19:13:03 <syllogismos> @info []
19:13:03 <lambdabot> []
19:13:04 <geekosaur> yes
19:13:16 <geekosaur> lambdabot haas no @info
19:13:17 <dwcook> Oh yeah, that is right
19:13:25 <geekosaur> (it's edit-correcting to @undo)
19:13:36 <dwcook> For some reason I was thinking of classes taking (* -> *)-kinded types that wouldn't be able to distinguish
19:13:41 <dwcook> But no, Ord takes *
19:14:15 <dwcook> @type (>) `asAppliedTo` []
19:14:16 <lambdabot> Ord a => [a] -> [a] -> Bool
19:16:09 <syllogismos> https://github.com/NICTA/course/blob/master/src/Course/Applicative.hs#L139 I am stuck here.. how do i implement filterM for an applicative?
19:17:16 <syllogismos> i saw the source code of filterM but it was implemented using do notation.. so..
19:17:46 <dwcook> syllogismos, hint: map and fmap may be handy
19:18:02 <dwcook> Wait no
19:18:13 <dwcook> map and (<*>)
19:18:18 <weyard> Iceland_jack: are you free to help me out?
19:18:58 <weyard> Iceland_jack: too busy catchinganohter flight?
19:19:50 <dwcook> syllogismos, by the way, there's a relatively straightforward way to transform filterM's definition to use Applicative
19:19:57 <dwcook> It still uses (<*>) though
19:20:36 <dwcook> If you'd like stronger hints I can provide them
19:22:32 <syllogismos> give me a hint.. im trying to figure it out for a long time..
19:23:07 <dwcook> Okay. When you see: do { a' <- a ; b' <- b ; return (f a' b') }, you can transform it to f <$> a <*> b
19:24:35 <Rotaerk_> do you guys avoid using error/assert?  and if so, do you 1) use some other mechanism to report breach of contract, 2) eliminate the contract by redefining your interface to be very forgiving, 3) usually find a way to express the contract via types, 4) ???
19:25:10 <Rotaerk_> 3 seems like a replacement for a very limited number of contracts
19:25:54 <dwcook> Rotaerk_, preferably, I encode the contract in the type system. Otherwise, I do whatever is necessary to avoid the error case. I hate _|_. :P
19:26:32 <c_wraith> I use error only when it means the programmer did something wrong.
19:26:45 <hakujin> I think the idea of contracts you have in mind is synonymous with types in Haskell
19:26:48 <Rotaerk_> breach of contract *means* the programmer did something wrong
19:27:07 <dmj`> error is defined in terms of undefined
19:27:14 <dmj`> @src error
19:27:14 <lambdabot> error s = throw (ErrorCall s)
19:27:32 <Rotaerk_> hakujin: except the type system can't express all things, as far as I can tell
19:27:36 <dwcook> @type throw
19:27:37 <lambdabot> Exception e => e -> a
19:28:12 <abstract-alf> hi, anyone here a user of Elm?
19:28:13 <dmj`> oops had that backwards
19:28:22 <dmj`> @src undefined
19:28:22 <lambdabot> undefined =  error "Prelude.undefined"
19:28:31 <hakujin> Rotaerk_: what is an example of a contract you want to enforce?
19:28:50 <Rotaerk_> I've got a "cell grid", and you can place an entity, remove an occupant, or move an occupant to another cell.
19:29:02 <dmj`> abstract-alf: there is an #elm IRC
19:29:06 <Rotaerk_> placing requires 1) the entity isn't already an occupant, and 2) the cell index is within the bounds of the grid
19:29:17 <Rotaerk_> removing requires the entity is an occupant
19:29:24 <dwcook> Rotaerk_, exposing a limited interface seems like a good bet.
19:29:37 <levi> abstract-alf: elm is pretty fun.
19:30:01 <dwcook> For example, I have a module that exports a type that's a transformer over IO. I don't want users embedding arbitrary IO, so I only export a few particular ones.
19:30:05 <abstract-alf> levi: built any games with it?
19:30:08 <Rotaerk_> moving requires target cell to be in bounds and not the same as currently occupied cell... and for the entity to be an occupant
19:30:25 <Rotaerk_> I see no way to enforce the cell index be within bounds, using the type system alone
19:30:35 <abstract-alf> dmj`: is Elm not considered to be haskell?
19:30:36 <levi> abstract-alf: Nope, but I started implementing a 'draggable box' :)
19:30:53 <bitemyapp> abstract-alf: that would be because it's not Haskell.
19:31:06 <abstract-alf> levi: haha, nice.  I've been reading and studuing Elm for a few months now.  finally my interest has hit critical mass
19:31:12 <levi> It isn't meant to be Haskell, just "inspired by" haskell.
19:31:22 <Rotaerk_> dwcook: not sure how that translates to this problem exactly
19:31:33 <abstract-alf> bitemyapp: is it perhaps considered to be 'a haskell', like clojure is 'a lisp'?
19:32:16 <bitemyapp> abstract-alf: there is no family of Haskell, Haskell is a singular thing.
19:32:21 <abstract-alf> ok
19:32:23 <bitemyapp> abstract-alf: Elm is not Haskell, there are no "Haskells"
19:32:26 <abstract-alf> my mistake
19:32:28 <Rotaerk_> this is effectively just a 2D array... except arrays get around the need to have this contract *not* by building it into the type system
19:32:28 <dwcook> Rotaerk_, you export functions that you've written to ensure that your requirements are met and, e.g., none of the type's constructors.
19:32:31 <bitemyapp> abstract-alf: it is, however, a typed functional language of some sort
19:32:34 <abstract-alf> it is certainly Haskelly
19:32:44 <bitemyapp> abstract-alf: syntactically, sure.
19:32:44 <Rotaerk_> but by making the interface forgiving:  i.e. it's okay to pass an out of bounds index... it just doesn't DO anything
19:32:46 <dmj`> abstract-alf: Elm was written in Haskell yes, but Elm itself is not Haskell, although it looks very familiar to haskell
19:32:48 <bitemyapp> abstract-alf: why do you care about syntax?
19:33:00 <no-n> how do I sort a [String] case-insensitively?
19:33:01 <abstract-alf> bitemyapp: when did I say I did?
19:33:10 <enthropy> bitemyapp: all the -X flags supported by ghc probably define "haskells"
19:33:11 <dwcook> If a user gets ahold of your constructor, then all bets are off except for what's ensured by the type system. So you don't give them that.
19:33:12 <levi> Haskell belongs to the family of functional languages descended syntactically from ISWIM, which includes the MLs as well.
19:33:27 <bitemyapp> enthropy: clojure isn't a common lisp pragma.
19:33:51 <esebelle> Has a problem.
19:34:05 <esebelle> When I run "cabal check"
19:34:12 <esebelle> it gets upset that I have "ghc-options: -Werror"
19:34:17 <Rotaerk_> dwcook: oh, well a call to "place" would look like:  place someEntity (1,2)
19:34:19 <esebelle> but I only enable that if a flag is on
19:34:23 <esebelle> which is off by default
19:34:33 <esebelle> I just want it on when I run tests
19:34:48 <dwcook> Rotaerk_, and does place ensure it's not already placed, for example?
19:35:04 <Rotaerk_> dwcook: it requires that it's not already placed; that's a precondition of the function
19:35:13 <Rotaerk_> i.e. part of its contract, and thus an assertion
19:35:30 <Algebr> The wiki page for ISWIM says that it was never actually implemented...what? So people just talked about the specs of the language?
19:36:33 <dwcook> Rotaerk_, don't give users of your module the opportunity to violate preconditions. Preconditions are for within the module, and types and tight control of exports are for controlling things across module boundaries.
19:37:17 <Rotaerk_> I think the type system can be used to guarantee predicates about an individual value but... relationships *between* values is also part of the contract, and I don't think the type system can very well handle that
19:37:48 <levi> Algebr: In the academic community, programs written in papers are not always meant to be complete programs that can be directly run. And many languages were implemented based on the ideas in ISWIM; it was sort of a language proposal.
19:38:04 <Rotaerk_> dwcook: only way i can think of to do that is to remove the preconditions and give it some "reasonable" behavior for that condition
19:38:33 <dwcook> Rotaerk_, or you only export functions that are only allowed to do things consistent with your conditions.
19:38:50 <esebelle> usually if a function can do something wrong if given certian input (i.e. the function is not total)
19:38:59 <dwcook> If you export a place, and it's possible to place things in an invalid manner, you can have it return a Maybe, for instance
19:39:00 <esebelle> you put the word "unsafe" in its name
19:39:25 <esebelle> if "unsafePlace" is much more efficient than "place", then implement both
19:39:26 <enthropy> Rotaerk_: https://github.com/pseudonom/phantheck might be of interest, but I don't think it's practical
19:39:35 <dwcook> You could also choose to make it a no-op, but that makes it hard to introspect
19:39:38 <esebelle> and allow users of your module to decide which tradeoff they want to make on a case-by-case basis
19:40:06 <esebelle> if "place" can be implemented about as efficiently as "unsafePlace"
19:40:08 <esebelle> then just do that
19:40:44 <Rotaerk_> dwcook: hmm "only export functions that are only allowed to do things consistent with your conditions" only seems possible by making these a no-op
19:40:46 <Rotaerk_> in this case
19:40:57 <dwcook> Did you see my previous suggestion? That one is saner. :)
19:41:03 <dwcook> Return a Maybe
19:41:06 <dwcook> or an Either
19:41:33 <Rotaerk_> ah, so basically your suggestion is don't use *errors* across module boundaries, use *failures*
19:41:43 <dwcook> Yeah, basically
19:42:00 <dwcook> Unless you're going with an unsafe approach like esebelle suggested
19:42:05 <dwcook> for the sake of efficiency
19:42:13 <dwcook> Just make it really obvious that it has an error case
19:42:41 <Rotaerk_> in this case, I have a CellGrid module, and a CellGrid.Internal module... the latter is technically a separate module, but intended only to be used by the former
19:43:03 <Rotaerk_> so my CellGrid module is reporting failures, but I have errors/assertions in the "internal" module
19:43:20 <dwcook> That seems fine
19:43:30 <dwcook> As long as the internal module isn't exposed by the package
19:43:38 <dwcook> Or if it is but marked unsafe
19:43:49 <esebelle> ooh also
19:44:03 <esebelle> pure code shouldn't throw exceptions unless marked unsafe
19:44:13 <Rotaerk_> hmm k, I'll look into marking unsafe
19:44:17 <esebelle> really it would be best if
19:44:21 <esebelle> no code threw exceptions
19:44:27 <esebelle> buut sometimes it's necessary in IO stuff
19:45:03 <Rotaerk_> it seems like pure code *should* throw exceptions if you don't want to encode everything as a failure
19:45:19 <dwcook> Why *not* encode things as failures? You can match on failures
19:46:03 <dwcook> If I somehow failed to place something, it'd be really nice to know why, say, by getting a Left AlreadyPlaced or somesuch
19:46:42 <Rotaerk_> the only reason that place function would fail is if the calling context didn't do what it was supposed to
19:46:54 <Rotaerk_> usually, it would already know that that entity was already placed
19:47:00 <Rotaerk_> and thus it wouldn't call it in the first place
19:47:19 <esebelle> your heart is impure young adept
19:47:23 <no-n> what's the idiom for a do nothing do statement? return ()?
19:47:30 <Rotaerk_> esebelle: lol
19:47:35 <dwcook> no-n, you don't need the "do" then, but sure
19:48:12 <dwcook> no-n, oh I misunderstood. But yeah, that's still a reasonable "do nothing".
19:48:30 <no-n> oh yeah
19:48:35 <no-n> ty
19:48:59 <Rotaerk_> basically, a failure is when preconditions hold but postconditions fail.  if the calling code meets the preconditions, and the postconditions are failable, it needs to check for them
19:49:21 <dwcook> Or if you already have a monadic value and all you want to do is make its result (), you can use
19:49:24 <dwcook> @type void
19:49:25 <lambdabot> Functor f => f a -> f ()
19:49:36 <no-n> but main = return () is fine?
19:49:41 <Rotaerk_> a calling context shouldn't check if it met the preconditions of the thing it's calling... that wouldn't make sense..  instead it should simply meet the preconditions
19:49:42 <dwcook> Yes, that's perfectly fine.
19:50:06 <no-n> kewl
19:50:43 <esebelle> main = main
19:51:01 <hakujin> Rotaerk_: are you passing a
19:51:02 <dwcook> Good luck running *that*, IO system!
19:51:14 <hakujin> Rotaerk_: are you passing around the state of your grid somewhere?
19:51:15 <hakujin> *
19:51:33 <Rotaerk_> so I do think error should be used for enforcing preconditions, *but* perhaps design to avoid having preconditions, at least at module boundaries.  postcondition failures should *never* be reported via exception though
19:51:39 <no-n> wouldn't that be an infinite loop?
19:51:45 <Rotaerk_> hakujin: yea
19:51:53 <hakujin> Rotaerk_: how?
19:52:11 <dwcook> no-n, yes, it evaluates to _|_
19:52:27 <no-n> I don't know what that is
19:52:52 <Rotaerk_> hakujin: the signature for place is occupant -> CellIndex -> CellGrid occupant -> CellGrid occupant
19:53:01 <dmj`> no-n: http://www.haskell.org/haskellwiki/Bottom
19:53:04 <dwcook> no-n, pronounced "bottom". It's what undefined gives you.
19:53:19 <esebelle> type Ass = Bottom
19:53:23 <no-n> ahh
19:53:29 <esebelle> some people use the above type synonym ^^
19:53:49 <dwcook> I mentioned _|_ because there are ways besides that that something can loop infinitely; e.g., in the IO system. But this one loops at evaluation.
19:53:53 <Rotaerk_> hakujin: well, not clear on the question..
19:54:03 <no-n> is that a CPU hog or is it clever enough to "give up" after a while?
19:54:51 <esebelle> umm can someone help me with my cabal issue?
19:55:06 <dwcook> no-n, there are certain situations where the compiler figures out something just loops infinitely. But if you ran that in, say, ghci, it would loop forever.
19:55:18 <esebelle> cabal is upset that I have "ghc-options: -Werror" but It's only turned on with a flag
19:56:09 <Rotaerk_> hakujin: there is a data Model = Model { _cellGrid :: Maybe (CellGrid Entity) }.  there are operations on Model which correspond to the place, remove, move operations on CellGrid.  *these* do report failures rather than errors.
19:56:38 <enthropy> esebelle: I don't think that warning gets in the way of cabal upload (at least it didn't a year ago or so)
19:57:17 <esebelle> enthropy: it doesn't, but I want to incorporate "cabal check" into my test script, and it makes the exit code non-zero
19:57:26 <Rotaerk_> brb
19:57:39 <geekosaur> because cabal will attempt to set flags to make something compile, and -Werror breaks builds (notably, clang is much more stringent than gcc so something that is gcc -Wall -Werror clean may well not build on OS X or other clang-based platforms)
19:58:08 <geekosaur> (if freebsd's not clang yet, it will be soon; they're working hard on it)
19:58:57 <esebelle> geekosaur: ok. then why does it still throw an error if I change the flag to manual?
19:59:41 <geekosaur> for that you'd have to ask one of the cabal folks. I suspect the -Werror check is just textual, as opposed to checking what flags are involved
20:00:16 <enthropy> esebelle: maybe you can move that -Werror flag into your call to cabal test / cabal configure?
20:00:40 <enthropy> I mean at some point you can run a cabal configure --ghc-option=-Werror
20:01:24 <hakujin> FreeBSD 10 is clang based yeah
20:01:28 <esebelle> umm
20:01:41 <esebelle> cabal configure doesn't seem to have a ghc-option according to --help?
20:02:43 <Rotaerk_> hmm actually, maybe it would be better for me to use failures in this case
20:02:58 <esebelle> oh is it "--PROG-options="?
20:03:07 <geekosaur> yes
20:03:15 <enthropy> works for me regardless of what the documentation says
20:03:19 <Rotaerk_> because with the assertions, I do the same checks in two places... once inside the functions (for ensuring preconditions are met), and once outside the functions (for ensuring they will be met)
20:03:30 <geekosaur> because there's some 12 or so different programs that cabal can handle options for
20:04:07 <geekosaur> so there's one list of the programs it knows about and then they just show one set of options with PROG instead of listing them all for all the programs it knows about
20:04:32 <hakujin> Rotaerk_: encoding failure in the type system is what you want yep
20:05:24 <Rotaerk_> k
20:05:24 <hakujin> Rotaerk_: using the monad isntances of Maybe or Either will keep you sane when dealing with a lot of possible failure
20:05:52 <Rotaerk_> I ran across this Failure monad, which seems nice
20:06:09 <Rotaerk_> lets you not get tied down to Maybe or Either... calling context can decide which is preferred
20:06:42 <Rotaerk_> Failure typeclass*
20:08:53 <copumpkin> how do I get cabal/ghc to pass -g to my C compiler?
20:10:20 <esebelle> is there a Haskell compiler targetting XSLT?
20:14:58 <esebelle> so...
20:15:02 <esebelle> can anyone push a package to hackage?
20:15:26 <geekosaur> cabal: --gcc-option=<option>   ghc: -optc<option>
20:15:43 <esebelle> ah you need a hackage username and password
20:15:57 <geekosaur> esebelle, anyone can create a new package and push it although you need to set up a hackage account. only a package maintainer can push updates to that package
20:15:58 <esebelle> eww eww eww You can store your Hackage login in the ~/.cabal/config file
20:16:09 <esebelle> why doesn't it use ssh with my private key?
20:16:53 <esebelle> look at the way the heroku client does it
20:17:01 <esebelle> first time you connect it asks for username and password
20:17:10 <esebelle> then uploads your default public key
20:18:56 <enthropy> probably those suggestions will get lost if this is the only place you make them
20:22:34 <jmcarthur> esebelle: it doesn't because nobody has written the code for it yet :)
20:23:07 <esebelle> :P
20:23:42 <nolrai66> Hmm. I clearly don't understand irc as well as I thought..
20:24:14 <levi> nolrai66: What did you misunderstand?
20:24:43 <geekosaur> hackage has a bug tracker...
20:24:53 <nolrai66> I thought /msg was how to query someone. Namely lambdabot.
20:25:04 <geekosaur> it is; what went wrong?
20:25:21 <geekosaur> (also there is /query in many clients, which should get you a dedicated window/tab)
20:25:32 <levi> That's the low-level messaging command that can send a message to a user or a channel.
20:25:42 <nolrai66> Ahh.
20:26:01 <levi> Turns into a PRIVMSG command in the protocol.
20:26:48 * hackagebot purescript 0.4.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.1 (PhilFreeman)
20:26:49 <nolrai66> I see, lambda bot said hi back to me, and I thought it was the system doing something with my /msg comand.
20:32:06 <pdxleif> Is there Lens stuff for WAI requests?
20:37:45 <qrada> with the repa library, can you 'change' data in the array? im not seeing it in the hackage docs
20:46:54 <enthropy> qrada: you end up defining a new array
20:54:30 <no-n> is there an off-topic channel?
20:55:02 <Cale> #haskell-blah
20:55:29 <no-n> ty
20:58:25 <no-n> hmm
21:09:02 <johnw> pdxleif: what would you like that to do?
21:13:46 <qrada> enthropy: ah thanks
21:29:13 <pdxleif> johnw: I guess just modify the pathInfo of a request (based on the old pathInfo).
21:38:38 <dmj`> pdxleif: there is System.FilePath.Lens
21:41:18 <pdxleif> Should I use that "makeLenses" TH thing?  I really only need a Lens' Request pathInfo
21:48:00 <dmj`> pdxleif: no, not for editing filepaths, that functionality is caked in. If you want to use your own ADT's then yes you would have to "makeLenses"
21:48:23 <dmj`> and prefix with an underscore
21:48:48 <shachaf> You can write your own lens instead of using TH, of course.
21:49:46 <chrisdotcode> hi everyone :)
21:50:03 <chrisdotcode> is there any such function like: Bool -> IO a, where if the bool is true, the action runs, and if not, then nothing happens?
21:50:23 <chrisdotcode> like a IO/monadic version of if/else
21:50:26 <joelteon> :t when
21:50:27 <lambdabot> Monad m => Bool -> m () -> m ()
21:50:50 <pdxleif> dmj`: I'm interested in the path of HTTP requests - http://hackage.haskell.org/package/wai-2.0.0/docs/Network-Wai.html#v:pathInfo
21:51:01 <Platz> Twey: after about a week of the ctrl + alt swap, I'm finally getting it; wishing I'd done this sooner
21:51:07 <chrisdotcode> joelteon: perfect. I think that's what I'm looking for :)
21:51:38 <pdxleif> shachaf: You happen to have a pointer to where I might find docs for writing my own lens?
21:51:44 <ReinH> pdxleif: HTTP requests go in, HTTP responses go out. Can't explain that.
21:51:53 <chrisdotcode> joelteon: but I am confused as to why there are three arguments. doesn't an action with side-effects have no return value?
21:52:09 <chrisdotcode> like why isn't "Bool -> m ()" enough for the declaration?
21:52:10 <pdxleif> The "lens" examples that I've found seem to just have tuples, or auto-deriving w/ TH
21:52:33 <joelteon> chrisdotcode: you provide a Bool argument and you get an action with no return value?
21:52:36 <joelteon> don't you need to provide an action to run?
21:52:37 <ReinH> chrisdotcode: when takes a bool and a monadic action and gives a monadic action
21:52:46 <shachaf> pdxleif: Probably in the documentation for lens?
21:52:53 <shachaf> Don't use the function "lens".
21:53:06 <shachaf> What's wrong with tuples?
21:53:08 <ReinH> chrisdotcode: can you give me a value of type IO () that doesn't do any IO?
21:53:08 <trillioneyes> chrisdotcode: it only has two arguments. The last m () is the return value
21:53:23 <chrisdotcode> right, I'm confused as to why it has a return value at all?
21:53:34 <chrisdotcode> if we're only caring about the side-effect, why does it haave a return value?
21:53:37 <ReinH> chrisdotcode: it can't *not* have a return value.
21:53:42 <trillioneyes> chrisdotcode: because IO actions don't have side effects
21:53:46 <trillioneyes> They represent side effects
21:53:49 <chrisdotcode> ReinH: oh, right
21:53:57 <ReinH> chrisdotcode: and it doesn't "have side effects".
21:54:05 <chrisdotcode> okay, so what happens ,then?
21:54:06 <trillioneyes> So "when" takes a bool and a side effect and either returns that side effect or no side effect
21:54:16 <ReinH> well
21:54:16 <chrisdotcode> ^ right, that makes sense
21:54:27 <ReinH> it takes a bool and an action and returns either that action or `return ()'
21:54:29 <chrisdotcode> don't IO actions "contain" side-effects?
21:54:38 <ReinH> chrisdotcode: IO actions don't contain anything
21:55:26 <ReinH> where's that handy ls quote
21:55:36 <pdxleif> What's wrong with the "lens" function?
21:55:44 <ChongLi> ReinH: well, saying they don't contain anything is a bit strong
21:55:53 <ChongLi> they don't contain the values you want
21:55:58 <ReinH> ChongLi: saying they contain anything is a bit wrong, so...
21:56:00 <ChongLi> they do contain other information, though
21:56:06 <chrisdotcode> I heard at one point that IO a contains a IO action that runs when you use it
21:56:06 <ReinH> in what sense?
21:56:09 <chrisdotcode> is that incorrect?
21:56:12 <ChongLi> such as what IO action they are
21:56:18 <chrisdotcode> "use it" in quotes
21:56:31 <ReinH> ChongLi: then I guess `1' contains "which integer is it"?
21:56:35 <ChongLi> if they contained no information, you could represent them all as ()
21:56:35 <ReinH> *it is
21:56:58 <ReinH> ChongLi: I think you're using two different definitions of "contain"
21:57:05 <trillioneyes> A value of type IO a is a structure that represents various forms of I/O and side effects and that kind of thing
21:57:18 <ChongLi> ReinH: well, when we program Haskell we're really operating on two different levels
21:57:27 <ChongLi> there's the level of the Haskell expressions themselves
21:57:31 <trillioneyes> I think "represents" is clearer than "contains" here, even if their meanings kind of overlap
21:57:37 <shachaf> pdxleif: It's more complicated and less efficient than defining a lens directly.
21:57:46 <chrisdotcode> so what's the clarifying solution, guys? >_>
21:57:50 <shachaf> I was about to give an example with a tuple, but you said you don't like tuples, so I'm stuck.
21:57:55 <ChongLi> and then the machine level (runtime) that does the work of evaluating Haskell and performing the effects
21:58:05 <chrisdotcode> ChongLi: that's the model that I had as well
21:58:25 <ChongLi> one way I like to think of the IO monad as being like the C preprocessor
21:58:28 <ChongLi> except lazy
21:58:30 * ReinH sighs
21:58:37 <ChongLi> so that preprocessing and program runtime become interleaved
21:58:51 <ReinH> Oh good not-very-good-io-monad-analogies time :D
21:58:57 <ChongLi> well, you could look at all of Haskell like that
21:59:21 <ChongLi> Haskell just being a purely functional alternative to the C preprocessor
21:59:30 <dmj`> pdxleif: In your case, if you want to modify a Request path, you'll first need to get at the underlying path "rawPathInfo" then unpack the ByteString as a String. FilePath is a type synonym for String. let req = Request { rawPathInfo = "www.google.com?q=dogs" :: ByteString }, str = BL8.unpack . rawPathInfo $ req, now you can use your lenses
21:59:31 <ChongLi> which happens to be lazy
21:59:37 <ReinH> chrisdotcode: do you know what happens when you execute a Haskell program?
22:00:10 <trillioneyes> ChongLi: the C preprocessor seems like a distractingly bad analogy here
22:00:11 <chrisdotcode> ReinH: I *think* that what can be purely reduced is reduced, and then something something side effects through main.
22:00:20 <ReinH> chrisdotcode: no, something much simpler happens.
22:00:34 <chrisdotcode> oh, sorry, thought you asked about compilation
22:00:35 <ChongLi> trillioneyes: yeah, it is too concrete/specific and includes a bunch of irrelevant/wrong ideas
22:00:36 <ReinH> well, conceptually at least
22:00:45 <chrisdotcode> so then what happens?
22:00:57 <ReinH> chrisdotcode: there's an IO action called `main'. This IO action is performed and, as it's an IO (), nothing is returned.
22:01:00 <pdxleif> The WAI docs explicitly say to modify pathInfo, not rawPathInfo
22:01:04 <ReinH> Then the program terminates (or not).
22:01:20 <ReinH> chrisdotcode: this is the only time that IO is performed when running a Haskell program.
22:01:30 <ReinH> everything else is a clever way to create a value of type IO ()
22:01:41 <shachaf> That's sort of technically true but not in a useful way.
22:01:47 <chrisdotcode> right, I knew that much
22:01:55 <shachaf> When you run a C program, the runtime system calls the function main().
22:01:57 <ChongLi> just think of your program as one giant expression
22:01:57 <pdxleif> Tuple example is fine I guess; I just assumed the tuple stuff like _2 had been pre-made - was just looking for an example with a newly defined data structure from scratch
22:02:01 <ReinH> shachaf: well, I'm glad we agree on "sort of technically true" :)
22:02:07 <chrisdotcode> I read somewhere that IO interactions only be run by connection through main
22:02:07 <shachaf> "this is the only time that a function is called in a C program"
22:02:14 <chrisdotcode> *connecting
22:02:15 <pdxleif> e.g. data Person = Person { name :: String, age :: Int }; Lens` Person String ...
22:02:18 <ChongLi> with parts of that expression tagged with "get this value at runtime"
22:02:31 <ReinH> shachaf: well, I don't think that's the same thing
22:02:33 <shachaf> ReinH: It's technically true for particular meanings of words like "only" which aren't the usual meanings.
22:02:41 <ChongLi> running your program then consists of simplifying this graph down to a value
22:03:16 <ChongLi> the effects performed occur when needed in order to fill in the aforementioned holes
22:03:16 <ReinH> shachaf: you're right, it isn't the usual meaning
22:03:31 <shachaf> main = do { print "hi"; print "bye" }
22:03:57 <ChongLi> do notation obscures what's really going on
22:04:06 <shachaf> To execute the IO action main, the runtime system executes the actions (print "hi") and then (print "bye"). That's what executing main is.
22:04:29 <ReinH> shachaf: the point being: if you want to understand how IO works, you should look at how the IO () value at `main' is composed.
22:04:29 <dmj`> pdxleif: then modify pathInfo instead. In that case call T.unpack . T.concat . pathInfo $ req. Now you have a filepath type
22:04:50 <ReinH> everything else, like talk of "adding side effects", is missing the point imo
22:04:52 <chrisdotcode> I was one told that "main" cheats, because the proper return value can be IO () or IO a?
22:05:04 <shachaf> "if you want to understand how C code works, you should look at how main() works"
22:05:21 <trillioneyes> chrisdotcode: well, IO () unifies with IO a
22:05:22 <ChongLi> the type IO a encompasses IO ()
22:05:27 <ReinH> shachaf: well, C doesn't have a strict separation of IO from non-IO, so I think the analogy is tenuous
22:05:27 <ChongLi> yeah, that
22:05:31 <shachaf> main isn't special, in either Haskell or C, except that it's the entry point.
22:05:33 <chrisdotcode> right, that makes sense
22:05:56 <ReinH> shachaf: when is IO performed when running a Haskell program?
22:06:07 <chrisdotcode> so initially I was curious as to why when has a return value, but I think you guys help me figure that out.
22:06:08 <ChongLi> when it's needed :)
22:06:27 <ChongLi> hence the term "call-by-need"
22:06:30 <chrisdotcode> at least, I think.
22:06:35 <ReinH> ChongLi: er.
22:06:36 <shachaf> What does that mean?
22:06:45 <ReinH> ChongLi: how is IO performed "when it's needed"?
22:06:58 <ReinH> and how is that different from saying "IO is performed when it is performed"?
22:07:21 <ChongLi> you can have a value of IO a that never gets forced
22:07:32 <ChongLi> and thus the effects never happen
22:07:59 <ReinH> and I write a function that I never call, what does that have to do with my question?
22:08:04 <ReinH> *and I can
22:08:48 <ReinH> Which, you'll note, was not "when is IO not performed when running a Haskell program?" ;)
22:09:14 <chrisdotcode> so if I have a sendMail function that has type "Email -> IO ()", and only want to send an email if the production boolean is true, I would write: when production $ sendEmail "chris@example.com". I would think that the type would be: Bool -> Email -> IO (), but I'm curious as to why sendMail only has one return value, when when has two.
22:09:14 <shachaf> IO and forcing/call-by-need/etc. have very little to do with each other.
22:09:31 <ChongLi> shachaf: sure they do
22:09:33 <chrisdotcode> (sendMail as in the actual function in haddock somewhere, just simplified for my question above)
22:09:35 <liyang> If you perform IO in the woods, and no one is there to observe it, is it still performed?
22:09:44 <ReinH> chrisdotcode: a function can only produce one value
22:09:45 <shachaf> Anyway, I'll be in #-overflow.
22:09:52 <haasn> > putStrLn "hello, world" `seq` () -- I forced an IO ()
22:09:54 <lambdabot>  ()
22:09:56 <haasn> nothing happened.
22:09:56 <ReinH> chrisdotcode: also a funcion must produce exactly one value
22:10:14 <dmj`> haskell eval is outside-in, so maybe when the outermost context demands evaluation? Aren't I/O thunks evaluated the same way thunks that do not contain I/O are?
22:10:23 <chrisdotcode> ReinH: okay, so why doesn't what I posted produce one value?
22:10:29 <ReinH> chrisdotcode: it does.
22:10:31 <haasn> dmj`: haskell doesn't specify rules about evaluation order
22:10:45 <ReinH> chrisdotcode: what value does it produce?
22:10:57 <chrisdotcode> ReinH: an IO ()?
22:10:59 <joelteon> shachaf gets annoyed a lot
22:10:59 <chrisdotcode> it sends the email
22:11:05 <ReinH> it does not send the email
22:11:10 <dmj`> haasn: yes, but what drives any evaluation at all?
22:11:16 <ReinH> it produces an IO action that, when run, might send the email
22:11:21 <ChongLi> and "one value" can be anything; an Int, a Char, a list, a vector, whatever
22:11:23 <chrisdotcode> ReinH: right
22:11:24 <haasn> dmj`: the RTS/implementation
22:11:31 <ReinH> ChongLi: (another function ;)
22:11:38 <haasn> dmj`: it's the interpreter's job to interpret the effects of ‘main :: IO ()’
22:11:40 <chrisdotcode> ReinH: so why isn't that just IO ()?
22:11:49 <haasn> dmj`: nothing more, nothing less
22:11:51 <ReinH> :t when
22:11:52 <lambdabot> Monad m => Bool -> m () -> m ()
22:12:17 <ReinH> chrisdotcode: strictly speaking, when takes a bool and produces a function that takes an IO () and produces an IO ()
22:12:50 <ChongLi> chrisdotcode: have you learned about free monads?
22:12:55 <chrisdotcode> ChongLi: no, not yet
22:13:03 <chrisdotcode> I'm just after monads, but before monad transformers
22:13:09 <ChongLi> they may aid your understanding of IO
22:13:28 <ReinH> chrisdotcode: look at this for a moment
22:13:29 <ReinH> :t when True
22:13:30 <lambdabot> Monad m => m () -> m ()
22:13:36 <dmj`> haasn: so then I/O always drives evaluation
22:13:39 <ChongLi> free monads let you do all kinds of interesting stuff, such as building an IO simulator
22:13:40 <ReinH> chrisdotcode: what do I have there?
22:13:57 <chrisdotcode> ReinH: a function that takes a monad and returns another one?
22:14:08 <ReinH> chrisdotcode: a function that takes a m () and returns an m (), yes
22:14:11 <ReinH> now what do I have here?
22:14:14 <ReinH> :t when False
22:14:15 <lambdabot> Monad m => m () -> m ()
22:14:20 <chrisdotcode> same thing
22:14:32 <ChongLi> chrisdotcode: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
22:14:33 <ReinH> chrisdotcode: now, in the first case what do I want to do?
22:14:37 <ChongLi> bookmark that one
22:14:44 <chrisdotcode> ChongLi: got it thanks :)
22:14:50 <ChongLi> if you don't understand it right away, that's okay
22:14:50 <chrisdotcode> ReinH: whatever the action is
22:14:58 <ReinH> chrisdotcode: so define it for me
22:15:00 <ReinH> when True = ???
22:15:01 <ChongLi> just keep coming back to it as you get further along
22:15:02 <haasn> dmj`: as far as Haskell is concerned, “readLine” for example doesn't need to evaluate any haskell expressions
22:15:11 <ReinH> or when True m = ???
22:15:15 <ReinH> if you don't want to do it point free
22:15:21 <newsham> question: whats a good starting point for someone who used to do a bit of haskell 5yrs ago but doesnt do much these days?  are there any good sources for "catching up" with modern haskell?
22:15:29 <haasn> (of course, you could count that “main = readLine” implies the evaluation of ‘main’ (as ‘readLine’))
22:15:33 <haasn> s/count/argue/
22:15:43 <chrisdotcode> ReinH: it performs the monadic action?
22:15:48 <ReinH> chrisdotcode: it doesn't perform anything
22:15:52 <ReinH> it takes a monadic action and gives it right back
22:15:55 <ChongLi> chrisdotcode: and if you have questions about it, ask Tekmo
22:15:57 <ReinH> chrisdotcode: let's try something else
22:15:58 <ChongLi> he's the author of that blog
22:16:04 <ReinH> chrisdotcode: give me a function that takes an a and provides an a
22:16:06 <chrisdotcode> ChongLi: okay, cool :)
22:16:08 <chrisdotcode> ReinH: id
22:16:11 <newsham> main' = performIO main
22:16:21 <ReinH> chrisdotcode: ok, so what happens if I say when True = id?
22:16:35 <ReinH> I just get back the monadic action I provided
22:16:37 <Platz> newsham: the new apress haskell book features some newer libraries in a project based format, not on the experts' views on the book
22:16:39 <ReinH> that's all that when True does
22:16:46 <ReinH> chrisdotcode: now think about when False
22:16:51 <ReinH> chrisdotcode: I need to provide some m ()
22:16:53 <chrisdotcode> you get back the fail?
22:16:56 <ReinH> chrisdotcode: and I want it to not do anything else
22:16:57 <dmj`> haasn: readLine in isolation yes, but getLine >>= return . (++"ok") will
22:17:12 <dmj`> main :: IO () has to start somewhre
22:17:13 <ReinH> chrisdotcode: how do you create a monadic value of type Monad m => m ()?
22:17:19 <chrisdotcode> return ()
22:17:21 <ReinH> yep
22:17:24 <newsham> platz: but surely there's more than just new libraries.. like the MIO paper talking about a new IO subsystem
22:17:26 <ReinH> so when False = return ()
22:17:33 <ReinH> chrisdotcode: and that's all that when does
22:17:34 <trillioneyes> @src when
22:17:34 <lambdabot> when p s = if p then s else return ()
22:17:39 <ReinH> @src when
22:17:39 <lambdabot> when p s = if p then s else return ()
22:17:41 <ReinH> yep
22:17:50 <Platz> newsham: ahh, then you're above me ;)
22:18:25 <newsham> platz: unless your in the southern hemisphere i'm probably below you
22:18:39 <chrisdotcode> ReinH: oh, okay.
22:18:41 <chrisdotcode> ReinH: I get it
22:18:42 <pdxleif> I guess you can use Control.Lens.TH.makeLensesFor to specify names for specific field names.
22:18:42 <chrisdotcode> !
22:18:52 <chrisdotcode> ReinH: I was really confused, and I was mixing up different things
22:18:55 <ReinH> chrisdotcode: to the extend that monads contain values and side effects, return x is a monad containing an x without any side effects
22:19:00 <ReinH> *extent
22:19:12 <ReinH> chrisdotcode: (note that this is a really bad way to think about monads)
22:19:21 <ReinH> since it leads to this sort of confusion
22:19:38 <ReinH> chrisdotcode: so when doesn't decide whether or not to *execute* IO
22:19:46 <ReinH> only running main does that
22:20:25 <ReinH> when decides whether to provide the monadic action or an "empty" one.
22:20:32 <ReinH> i.e. whatever return () means for that monad
22:20:40 <Platz> newsham: http://www.flourish.org/upsidedownmap/diversophy-large.jpg
22:20:53 <ReinH> chrisdotcode: does that make more sense?
22:21:02 <chrisdotcode> ReinH: my main question was why sendMail looks like "Email -> IO ()" instead of "Email -> IO () -> IO ()" if when looks the way it does?
22:21:07 <chrisdotcode> s/was/is/
22:21:15 <newsham> thats one valid viewpoint, platz.  but then again, why not make east "up"?
22:21:23 <trillioneyes> > (when True [(),(),()], when False [(),()])
22:21:24 <lambdabot>  ([(),(),()],[()])
22:21:39 <ReinH> chrisdotcode: but when you partially apply it with some Email value you just get an IO ()
22:21:46 <ReinH> so when bool (sendMail email)
22:22:03 <ReinH> er not partially apply
22:22:07 <ReinH> when you apply it
22:22:26 <chrisdotcode> hrm, I know that works because of lazy eval, but I haven't grokked it that far yet.
22:22:33 <ReinH> chrisdotcode: it has nothing to do with laziness
22:22:46 <ReinH> sendMail email is a monadic action
22:22:49 <chrisdotcode> well, sendMail email isn't evaluted until when is true, correct?
22:23:01 <chrisdotcode> *when was passed a true value
22:23:05 <ReinH> chrisdotcode: sendMail email isn't evaluated until and if it is performed as a result of running `main'
22:23:26 <ReinH> what `when' does is decide whether `main' gets the IO action for sending email or an empty one that does nothing
22:23:41 <chrisdotcode> hrm, okay
22:24:07 <chrisdotcode> I don't quite get it yet, but I'll revisit it when I grok a bit more
22:24:14 <ReinH> when doesn't decide *if* IO is performed. It decides *what* IO is performed: your IO action or a noop, i.e. return ()
22:24:37 <ReinH> main = when False (putStrLn "Hello World.")
22:24:55 <Platz> newsham: I'm actually hoping this gets traction, because to my nubian ears it sounds awesome http://plv.mpi-sws.org/backpack/
22:24:58 <ReinH> main still performs the IO action provided by the when expression
22:25:06 <chrisdotcode> ReinH: okay, so now I get it
22:25:11 <ReinH> it just so happens that this IO action is a noop because it is just `return ()'
22:25:43 <ReinH> chrisdotcode: IO actions are values like any other
22:25:55 <ReinH> chrisdotcode: they don't "perform IO" until they are evaluated as a result of running `main'
22:26:07 <ReinH> so you can pass them around, write functions that provide them, etc
22:26:16 <MedDev> I'm looking for a name for a concept I'm trying to explain (see paste: http://lpaste.net/100054) anyone know if this has a common name to avoid confusion when talking about it?
22:26:18 <chrisdotcode> okay, so that makes sense
22:27:05 <pdxleif> Maybe I'd be better off defining a Functor instance for Request or something. :/
22:27:40 <ReinH> chrisdotcode: yay :)
22:27:48 <milfjord> MedDev: base value sounds good to me (and as lpaste tells you, all of these are foldr)
22:28:13 <chrisdotcode> ReinH: your explanation makes perfect sense, but still something's not clicking, even though I get it.
22:28:17 <dmj`> MedDev: you mean a fold?
22:28:23 <chrisdotcode> I think I might need to actually write some code on my own to get a more firm grasp of it
22:28:24 <ReinH> chrisdotcode: welcome to Haskell :)
22:28:24 <MedDev> milfjord, i know they're folds. i'm just trying to show someone the logic behind the fold abstraction
22:28:33 <chrisdotcode> ReinH: *whshew* that's a relief :)
22:29:39 <ReinH> chrisdotcode: the thing to remember is that putStrLn, for example, doesn't actually print a line. It produces an IO value that, when executed by running `main', prints a line.
22:30:05 <ReinH> chrisdotcode: I can take that value and do other stuff with it if I want, like any other value. It isn't at all magical.
22:30:18 <ReinH> The magic happens once main gets ahold of it
22:30:33 <ReinH> (and then it's quite magical indeed)
22:30:44 <chrisdotcode> haha
22:30:55 <chrisdotcode> okay, that makes sense when I think of IO like any other monad, like Maybe
22:31:12 <milfjord> it's a bit like a syntax tree
22:31:38 <no-n> any general rule of thumb for when to write a type declaration for function whatever and when to not bother?
22:31:51 <newsham> if you look at a monad like State, its kind of like IO (but much more limiting), you can put together imperative programs with it, you can pass around actions, but none of the "magic" happens until you use evalState or runState or execState
22:31:54 <ReinH> I guess I should say "once the RTS gets ahold of it"
22:31:57 <milfjord> (Mul (Lit 2) (Add (Lit 3) (Lit 4))) doesn't actually do anything but you can write an eval function for it
22:32:14 <newsham> IO is kind of like that with a magical hidden runIO
22:32:25 <milfjord> no-n: I generally write type declarations for top-level things
22:32:50 <ReinH> chrisdotcode: and of course main is just another IO () value. The magic happens once RTS does whatever magic it does.
22:32:52 <milfjord> runIO is magic because it isn't written in Haskell
22:32:57 <no-n> milfjord: what do you mean by top-level?
22:33:32 <newsham> haskell would be much easier if it werent for that runIO
22:33:40 <milfjord> no-n: at module scope
22:33:52 <ReinH> chrisdotcode: you can fixIO main :D
22:34:03 <ReinH> or call main from main
22:36:03 <enthropy> no-n: write them at the same time you feel that you need a comment explaining the function
22:36:46 <no-n> so humans need them much more than the compiler?
22:37:03 <milfjord> in general, yes
22:37:32 <no-n> okay
22:37:38 <chrisdotcode> ReinH: right. thanks a lot :D
22:37:56 <ReinH> chrisdotcode: :)
22:37:57 <ReinH> np
22:38:03 <ReinH> chrisdotcode: I hope it helps
22:38:11 <chrisdotcode> ReinH: it did! thanks :)
22:38:59 <enthropy> no-n: well there are cases you can't avoid writing out types
22:39:18 <enthropy> when you define classes, functions that need Rank2Types
22:39:49 <milfjord> polymorphic recursion
22:40:07 <milfjord> avoiding the monomorphism restriction
22:40:29 <no-n> *nod*
22:40:30 <haasn> functions whose type signatures are nicer with type synonyms than when inferred
22:40:38 <no-n> I usually like to write them anyway
22:43:50 <ReinH> haasn: like anything you do with lenses? :p
22:43:58 <haasn> ReinH: exactly :)
22:44:14 <ReinH> haasn: lol ask ghc what it thinks the type of your _x = _1 is
22:44:15 <haasn> ReinH: although lens type signatures are nicest when you apply 10 different type synonyms that subtly aren't actually the same thing
22:44:36 <haasn> ReinH: hmm, coulda been worse
22:44:42 <ReinH> eh
22:44:43 <ReinH> heh
22:45:11 <Fuuzetsu> could have*
22:45:17 <ReinH> haasn: new plan: newtyped tuples with lens aliases rather than records
22:45:30 <ReinH> tell me why I shouldn't
22:45:31 <ReinH> :p
22:46:59 * hackagebot word24 1.0.7 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.7 (JohnLato)
22:49:08 <pdxleif> Is there something (lens-y) for modifying the 2nd / last element of a list?
22:52:18 <supki> pdxleif: ix, _last
22:52:48 <supki> > [1..10] & ix 1 .~ 14 & _last .~ 17
22:52:50 <lambdabot>  [1,14,3,4,5,6,7,8,9,17]
22:52:51 <ReinH> pdxleif: generally speaking if you need to modify the last elements of a list you should question your design and life choices
22:52:58 <supki> that too
22:57:30 <carter> o/ ReinH
22:57:56 <carter> hello everyone!
22:57:57 <ReinH> carter: \o
22:58:53 <carter> ReinH: have i walked yah through openblas yet?
22:58:55 <carter> *hopenblas
22:58:59 <carter> i can do it later this week if you want
22:59:01 <carter> should be usable then!
22:59:11 <carter> (welll its kinda usable now, just not very)
22:59:40 <nolrai66> I wish to apply a monadic function through a lense. I.e. "l :: lens a b" "f :: b -> m b" and I want something of type "a -> m a". Does this make sense?
22:59:59 <carter> i have no clue :)
23:00:05 <carter> have you tried doingit?
23:00:47 <nolrai66> I was hoping it was some operator or some-such..
23:01:03 <carter> mebe
23:01:06 <carter> i don't know anything :)
23:01:25 <carter> (about lenses)
23:01:26 <shachaf> There's an operator, but you don't actually need one.
23:02:11 <shachaf> carter: Then it's pretty strange to answer a lens question...
23:02:30 <shachaf> Anyway, see "traverseOf" or "mapMOf"
23:02:31 <carter> indeed, i've been travelling for 8 hours earlier today
23:02:32 <carter> :)
23:02:35 <ReinH> carter: not yet
23:02:36 <shachaf> But you can just apply the lens directly.
23:02:38 <ReinH> carter: seems good
23:02:53 <shachaf> type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s
23:02:54 <carter> i aimed for "vectory"
23:03:02 <carter> oh i made an accidental pun
23:03:40 <pdxleif> > over _last (+1) [5,10]
23:03:42 <lambdabot>  [5,11]
23:03:48 <shachaf> I guess the operator version is (%%~) or something.
23:04:20 <nolrai66> no thats for lensing the state of a state monad IIRC.
23:04:48 <shachaf> It looks like you don't?
23:05:15 <nolrai66> Oh wait, no your right.
23:05:27 <nolrai66> I was thinking of %%=
23:26:31 <nolrai66> :t _2 (toMaybeT . (\x -> Just (1 + x) )
23:26:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
23:26:41 <nolrai66> :t _2 (toMaybeT . (\x -> Just (1 + x) ))
23:26:42 <lambdabot> Not in scope: `toMaybeT'
23:26:53 <nolrai66> :t _2 (MaybeT . (\x -> Just (1 + x) ))
23:26:54 <lambdabot> Not in scope: data constructor `MaybeT'
23:31:27 <jle`> has anyone here ever had trouble installing haste?
23:32:23 <carter> using or installing?
23:32:33 <carter> i've heard about TH being a pain with haste
23:32:39 <jle`> oh it looks like
23:32:42 <jle`> it requires base < 4
23:32:55 <jle`> and i have 4.6.0.1 ?
23:32:57 <jle`> that sounds weird
23:33:19 <carter> WAT
23:33:25 <carter> that sounds wrong...
23:33:28 <jle`> oh haste-compiler
23:33:39 <jle`> haha
23:33:47 <jle`> well i had trouble installing it earlier (haste-compiler)
23:33:58 <jle`> and was trying a sandboxed version just now to pin down the problem
23:34:10 <pavonia> What kind of trouble?
23:34:33 <jle`> with haste-boot
23:34:54 <jle`> integer-gmp would not configure
23:35:14 <jle`> also it complains a lot about cabal-install 1.16 stuff being missing
23:37:32 <carter> jle`: file a ticket with the rpoject?
23:37:47 <jle`> and i'm pretty confident that cabal 1.18 was installed when i installed haste-compiler
23:37:49 <jle`> hm
23:37:55 <jle`> was just wondeting if anyone has heard about this
23:37:58 <jle`> or has worked through this
23:38:04 <carter> file a ticket
23:38:06 <carter> its faster :)
23:38:11 <jle`> mk :)
23:57:05 * hackagebot egison 3.2.19 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.19 (SatoshiEgi)
23:57:22 <nolrai66> man it sure feels like you should be able to write "(fst myPair,)" nicely with lenses, but it ends up being "(flip (_2 .~) myPair)" which is not that great.
