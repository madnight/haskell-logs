00:01:10 <bitemyapp> I need to make a "workon" zsh function so I can more quickly create my cabal sandbox'd experimentation directories.
00:01:17 <Ralith> bitemyapp: idris is meant to be more about writing programs than proving things
00:01:23 <Ralith> though of course the whole idea is for them to be the same thing
00:01:39 <mr-_> Twey: How would open source mathematics differ from current mathematics?
00:01:41 <ReinH> Twey: what do/did you use to learn CT btw?
00:01:48 <ReinH> Twey: working through various things right now including Awodey
00:02:02 <bitemyapp> Ralith: right but if the idea is to get more people doing stuff with CT, DT, and proven-correct software then isn't something like Idris the ticket?
00:02:03 <ReinH> I don't have enough math to really get through MacLane but I hope to go back to it
00:02:18 <bitemyapp> Ralith: you can ask Idris to prove termination for total functions too.
00:02:19 <Ralith> bitemyapp: hopefully!
00:02:20 <bitemyapp> IIRC
00:02:36 <Ralith> bitemyapp: you can ask idris to *check* termination for a *small subset* of total functions
00:02:42 <Twey> ReinH: I'm not currently learning category theory and I'm not a category theorist; I've just picked bits up.  But I'm strongly recommended ‘Category Theory for Computing Science’ by an avid professional category theorist.
00:02:44 <Ralith> of course, you can also use a partiality monad or something like that
00:03:23 <bitemyapp> Twey: wait what, there are professional category theorists?
00:03:43 <ReinH> Twey: ah I've come across that
00:03:54 <ReinH> Twey: so far Awodey is pretty great and he has some youtube lectures
00:04:07 <Twey> mr-_: Current mathematics is not modular: re-using a ‘library’ of proofs involves either reading the entire proof and convincing yourself of its correctness or trusting the author
00:04:11 <ReinH> Also using Lang for algebra but it's kinda rough going
00:04:51 <Tekmo> Twey: Also, a more rigorous proof trail makes it easier for an outsider to teach themselves rather than relying on a mentor
00:04:56 <Twey> mr-_: Having verified proofs means that (if you trust the verifier) you can just drop in someone else's library of proofs and use them in your own work without fear that there's a subtle error lurking in there somewhere
00:04:59 <Tekmo> Oops
00:05:03 <Tekmo> That should have been for mr-
00:05:08 <isyn_asaz> Every time I actively read this channel I want to go back and do a Maths degree to go with CS
00:05:23 <Twey> Tekmo: It's nice for interaction, too
00:05:27 <bitemyapp> isyn_asaz: I didn't even go to uni.
00:05:29 <Tekmo> Twey: Yeah
00:05:33 <Hafydd> Do it.
00:05:37 <Twey> You know you haven't screwed up too badly :þ
00:05:38 <bitemyapp> isyn_asaz: just code for a living. Find this stuff stimulating.
00:05:49 <Tekmo> I have neither a CS nor math degree
00:05:53 <Twey> isyn_asaz: I'd like to do that, too, but I'm too far into my course to switch now
00:06:22 <Ralith> Twey: easier to switch now than next year
00:06:49 <Tekmo> Holy crap, `cabal-debian` is pretty awesome
00:07:04 <Twey> Ralith: But still not easy enough :þ  At this point I might as well just take a second bachelor's
00:07:18 <Twey> (give or take a year)
00:07:26 <ReinH> bitemyapp: heh you and me both
00:07:56 <bitemyapp> ReinH: mostly I just got tired of tracking down errors originating from mistyped code with extensive source->sink distances.
00:07:57 <mr-_> Twey: I don't know why you chose the term Open-Source, but I agree. People don't care enough about the "interface" and trust is a real issue
00:08:13 <isyn_asaz> yeh, a second bachelors is seems like the way forward for me... maybe after I have the house paid off...
00:08:29 <bitemyapp> ReinH: even in a relatively nice language with decent'ish code you can have a 500-1000 line Clojure repo with a reproducible error that takes an experienced Clojure dev over an hour to resolve. Ick.
00:08:39 <Tekmo> isyn_asaz: Just find a Haskell job.  Then you are basically paid well to do computer science ;)
00:08:52 <isyn_asaz> This is a very tempting option.
00:08:58 <Ralith> bitemyapp: that's terrible; in haskell, you can do that in only ten lines!
00:09:09 <ReinH> heh
00:09:21 <Tekmo> I wish more people would use static languages in general
00:09:23 <mr-_> Tekmo: That's not true for me. It is not usually the case that I am lost because there are not enough details. Often it's the contrary :-)
00:09:23 <ReinH> bitemyapp: meaning, actually, that I don't have any college/uni either
00:09:39 <Tekmo> *statically typed languages
00:09:53 <Twey> mr-_: Because informal mathematics isn't open-source.  Not only is it often locked away behind a paywall, even if you can read a proof you don't get the ability to use it — you have to do most of the work of implementing it again yourself.  Reading a paper vs. having a formal proof available is like reading about MP3 vs. having an MP3-playing library.
00:10:07 <Tekmo> mr-: For me, having things in code is a big step up
00:10:14 <Tekmo> mr-: Three is something more "real" about code
00:10:15 <bitemyapp> Ralith: as long as I know the referents I don't find Haskell code takes any more time to debug. Usually less. The same prerequisite applies in something like Clojure anyway, except you don't have the benefit of types metadata.
00:10:17 <Tekmo> *There
00:10:34 <Tekmo> mr-: That was one of the big appeals to me about Haskell.  I could "run" everything I learned
00:10:36 <bitemyapp> ReinH: cool. I figured I wasn't alone.
00:10:54 <bitemyapp> Tekmo: well kinda. My attempts to use Tardis in "real" code have been abortive.
00:10:55 <Hafydd> Twey: saying you have to do "most of" the work is inaccurate for hard proofs.
00:11:04 <isyn_asaz> Tekmo: where did you learn it from?
00:11:06 <bitemyapp> I learned something, but I wouldn't say I really got to "run" Control.Monad.Tardis either.
00:11:07 <Twey> Hafydd: Of implementing, not of rediscovering
00:11:12 <isyn_asaz> the theory, that is
00:11:15 <Hafydd> "implementing"?
00:11:15 <Twey> Hafydd: I phrased that quite carefully :þ
00:11:28 <mr-> Tekmo: being able to run/play with the proofs would be nice. Let's wait and see if that's going to be feasible :-)
00:11:28 <Tekmo> isyn_asaz: I was a graduate student doing bioinformatics.  My professor didn't care what language I used, so I used Haskell
00:11:33 <bitemyapp> but Control.Monad.Tardis might be my favorite smart-ass way to solve a puzzle problem.
00:11:44 <Tekmo> isyn_asaz: That's how I built up most of my experience
00:11:48 <bitemyapp> Tekmo: I work at a genetics/bioinformatics company incidentally.
00:11:56 <Tekmo> bitemyapp: Oh yeah, I think I remember that
00:12:05 <Tekmo> bitemyapp: Are you in the bay area?
00:12:08 <bitemyapp> we have some areas where Haskell would serve better than the incumbent Python.
00:12:12 <bitemyapp> Tekmo: SF
00:12:16 <Tekmo> Same here
00:12:22 <bitemyapp> well, not presently, but soon!
00:12:29 <Twey> Hafydd: I'm making an analogy between understanding an informally-described proof sufficiently to be able to use it and be convinced of its correctness and implementing an informally-described algorithm
00:13:04 <Hafydd> Twey: you only have to understand theorem to "use" a proof, unless we're talking about different things.
00:13:13 <bitemyapp> Twey: I think part of what makes people averse to FP, types, proofs, etc is that it's typically a relatively "chunky" rather than smooth experience WRT making progress towards the solution.
00:13:19 <Hafydd> *the theorem
00:13:29 <Tekmo> Well, I think it's a lot to do with marketing
00:13:46 <Tekmo> If you don't tell people that Haskell is mathematical or academic then it sometimes helps
00:13:46 <Twey> Hafydd: Right, but you won't use it unless you trust it, which requires understanding the proof as well (unless you already trust the author)
00:13:53 <mr-> Twey: Depends on what you mean by "use". Disregarding Trust, you can just use the theorem
00:13:55 <bitemyapp> Twey: learning how to work from the REPL to query not only the results of applying functions, but also the types of program fragments is a step towards making it "smoother" but newbies won't know any better and just smash their heads against up (arrow + return -> compiler error) feedback loops.
00:14:22 <Hafydd> Twey: I suppose I can see your analogy, then.
00:14:23 <bitemyapp> once they realize they're playing tetris with type signatures, it usually falls together more neatly.
00:14:23 <Tekmo> Hopefully typed holes will help improve that
00:14:31 <bitemyapp> Tekmo: speed-tetris :)
00:14:33 <Tekmo> :)
00:15:16 <bitemyapp> I really hope somebody makes a nice Emacs interface for holes in haskell-mode.
00:15:23 <bitemyapp> (so I don't have to write elisp :( )
00:15:24 <Twey> bitemyapp: That's true.  I think the next step in interface design for typed languages is making what fits where more visually obvious — perhaps some kind of geometric metaphor.
00:16:04 <Tekmo> There are some things that permit a geometric metaphor
00:16:13 <bitemyapp> Twey: I don't think you need to necessarily show them overwrought geometric metaphors as long as they see how things fit together on a high level view and also when you zoom in.
00:16:26 <bitemyapp> when I'm teaching I try to stay as close to the code as possible.
00:16:29 <Tekmo> Categories/Monoids are the simplest ones: you're just placing morphisms side by side in a line
00:16:45 <Tekmo> Functors then work along a second dimension, getting them to agree on a common category
00:17:06 <Twey> bitemyapp: Well, the hypothesis is that the geometric metaphor becomes the code, in some kind of visual-programming style
00:17:13 <Tekmo> Capital-A `Arrow`s work can be represented using graphs
00:17:46 <bitemyapp> Twey: I could see that. I wonder if that's what Peaker has in mind if they're working on something else entirely?
00:17:50 <bitemyapp> or if*
00:18:16 <Twey> I don't think that's in the Lamdu plan; I'm not even sure how (or if) it would work
00:18:40 <jrmithdobbs> fwiw geometric metaphors and visual aids in general do nothing but make me stop listening
00:18:56 <jrmithdobbs> and always have
00:19:20 <Twey> jrmithdobbs: It would probably be rather different in an interactive tool, no?
00:19:20 <Tekmo> Note that you can actually get a decent geometric metaphor without ever leaving code
00:19:28 <bitemyapp> jrmithdobbs: I don't favor them at all, myself.
00:19:33 <jrmithdobbs> Twey: it's not
00:19:38 <bitemyapp> jrmithdobbs: I prefer to stick to the code, including the textual representation.
00:19:41 <Tekmo> What you do is place each morphism on a separate line, and then place all unifying functors to the left-hand side
00:19:50 <Tekmo> It acts like a simple 2-D representation of what's going on
00:20:19 <Tekmo> Here's a simple example from `pipes`
00:20:25 <Tekmo> Let's say I have three pipes of type:
00:20:31 <Tekmo> p1 :: Producer A IO ()
00:20:36 <jrmithdobbs> Twey: code and well written/spoken descriptions are just how I learn
00:20:41 <Tekmo> p2 :: Pipe A B (StateT S IO) ()
00:20:45 <jrmithdobbs> Twey: the more visual the less i retain
00:20:46 <Tekmo> p3 :: Consumer B IO ()
00:20:57 <Tekmo> Those are three morphisms and each gets one line
00:21:03 <Tekmo> So it looks something like this:
00:21:06 <Tekmo> hoist p1
00:21:09 <Tekmo> Oops
00:21:12 <Tekmo> hoist lift p1
00:21:14 <Tekmo> >-> p2
00:21:20 <Tekmo> >-> hoist lift p3
00:21:31 <Tekmo> p1, p2 and p3 are the morphisms (one morphism per line)
00:21:49 <Tekmo> The `hoist lift` are the unifying functors mapping the morphisms to agree on a common category
00:22:10 <Tekmo> So the vertical dimension corresponds to the category and the horizontal dimension corresponds to functors
00:22:12 <Twey> jrmithdobbs: Say, just for the sake of argument, that you had a pentagon-shaped hole in your proof, and you had a square proof term — wouldn't it be more immediately obvious that the latter wouldn't fit in the former than comparing two types like Σa:A. Πb:B. f a b and Σb:A. Πa:B. f a b to see how they differ?
00:23:15 <mr-> That sound like the cubical set stuff :-)
00:23:33 <Twey> Or if you had a hexagon and six different triangle-shaped things that could go into it.
00:23:52 <Twey> I'm not necessarily talking about anything so abstract as diagrams
00:24:13 <Twey> Just appealing to spatial intuition instead of comparing text
00:24:30 <Twey> mr-: I don't really understand that yet :-\
00:24:46 <Tekmo> Twey: So you mean something like a visual hash, except one that preserves certain important properties (so we can use visual intuition to solve things)?
00:24:57 <jrmithdobbs> i see the different a/b there immediately but have to think whether 6 triangles fit in a hexagon
00:25:00 <jrmithdobbs> i wish that was a joke ;p
00:25:37 <jrmithdobbs> Twey: so i guess that answers that, heh
00:25:38 <Twey> jrmithdobbs: When presented with the triangles and the hexagon visually, you mean, or just when converting from my textual explanation?
00:25:48 <Twey> Tekmo: I suppose I do, yes
00:25:48 <jrmithdobbs> Twey: both
00:26:12 <Twey> jrmithdobbs: But also you could play with the triangles and try to arrange them yourself into a hexagon shape interactively
00:26:47 <jrmithdobbs> why
00:27:01 <Tekmo> jrmithdobbs: Keep in mind that some people are visual thinkers
00:27:06 <Tekmo> jrmithdobbs: Something like this might help them
00:27:23 <bitemyapp> and that some people like working with abstract representations of their problem for inspiration or simply faculty.
00:27:37 <Tekmo> jrmithdobbs: Also, just because most programmers don't think visually isn't an argument against this sort of thing.  It just means that the visual thinkers got frustrated with programming and tried a different professoin
00:27:40 <jrmithdobbs> Tekmo: i just like adding the counterpoint to this because nobody ever seems to think about us that aren't when presenting this way =/
00:27:54 <Tekmo> jrmithdobbs: Oh, I see.  Ok
00:28:14 <Twey> Tekmo: It would also be nice if the properties were compositional, so that e.g.  Σa:A. A  is obviously related to A in some way that should make it relatively obvious that the former can be built out of the latter
00:29:28 <Twey> jrmithdobbs: I'm trying to make it concrete — not using the faculties you apply when visualizing abstract spaces in mathematics, which obviously some people have trouble with (myself included), but using the faculties you apply when walking through a door
00:30:15 <Twey> I think most people are good with those, perhaps barring some forms of dyspraxia or so
00:31:08 <Tekmo> So, for types that have a small number of concrete inhabitants, you could represent them as volumes of N size that occupy space (perhaps N boxes)
00:31:17 <Tekmo> ... where N is the number of inhabitants
00:31:28 <Tekmo> So like, Bool would be something 2 boxes big
00:31:46 <Tekmo> Then if you can line up the boxes in one concrete type with another concrete type you establish one possible isomorphism between them
00:32:25 <Tekmo> Polymorphic values could be like spheres (they don't fit inside boxes or, vice versa, boxes don't fit in side them)
00:32:40 <Tekmo> Or perhaps it could be a different shape for each polymorphic type parameter
00:32:52 <Twey> jrmithdobbs: The interaction is also a big point: I have trouble visualizing 3D interactions because I have to hold the space in my head, but the idea of having the space *in the computer* is that you don't have to remember anything or perform the transformations mentally: it's all right there to play with, like trying to fit a block in a hole
00:33:34 <jrmithdobbs> Twey: tbqh, the hole analogy overuse in haskell confuses me constantly
00:33:37 <Twey> Tekmo: I think I was thinking of differentiating them by colour
00:35:15 <jrmithdobbs> Twey: "types with holes" "you can think of this as a function with a hole" etc ... no .. that makes no sense, it's an unassigned type param and probabl some kind of cps, not a damned hole =/
00:35:26 <bitemyapp> jrmithdobbs: really? it's been pretty apt when I have some type I need to satisfy with my code and I need to find a function to fit into the slot.
00:35:28 <Twey> Tekmo: If you have some uniform way of representing types, like W-types, it seems like you should be able to derive some kind of useful shape from the ‘shape’ parameterization
00:35:59 <Tekmo> Twey: Also note that if you run out of colors you can start adding patterns, too
00:36:07 <Twey> Aye
00:36:53 <jrmithdobbs> bitemyapp: ya, it's a weird metaphor to me
00:37:13 <bitemyapp> jrmithdobbs: the trivial example is something like, "oh I need to use flip here"
00:37:19 <bitemyapp> boom, tetris.
00:37:19 <Twey> jrmithdobbs: Well, ultimately the whole concept of a function is ‘an expression with a hole’ :þ
00:37:40 <bitemyapp> Twey: talking to you is more fun when I pretend that smiley face means "QED"
00:37:45 <Twey> Haha
00:37:50 <jrmithdobbs> Twey: but it's not really a hole, it's an unapplied expression
00:38:04 <Twey> bitemyapp: Unfortunately it rather means the opposite!
00:38:11 <Tekmo> Maybe a puzzle piece with a loose end might be a better visual metaphor
00:38:50 <Twey> jrmithdobbs: The function isn't a hole, it's an expression with a hole *in* it.  Then applying the function becomes ‘putting the argument in the hole’ and evaluating the resulting closed expression.
00:39:36 <jrmithdobbs> Twey: but it's not! the expression contains references to bound names! there are no holes!
00:40:43 <Twey> jrmithdobbs: The closure isn't a hole, since it's already been filled
00:41:26 <bitemyapp> ahh it's one of those `--max-backjumps 3000` days.
00:43:05 <Twey> When you have a function like λx. x + 2 it's an expression with something missing — you can't evaluate it on a bound variable, so it's not ‘complete’ yet.  When you apply it to a term like (3 + 5), you ‘put the term (3 + 5) into the x hole’ so that where there was an empty x there's now a full (3 + 5) so you get (3 + 5) + 2, which is closed and can be evaluated
00:43:15 <Twey> Seems like a fairly solid metaphor to me :þ
00:43:29 <jrmithdobbs> it's an expression without context
00:43:32 <jrmithdobbs> nothing more or less
00:44:37 <Twey> I accept your general rejection of metaphor, but that doesn't make any particular metaphor you reject a bad one :þ
00:52:05 <jrmithdobbs> Twey: I do dislike metaphor as explanation is general, but the hole metaphor irks me inparticular. it's a named parameter you are explicitly referencing. The only thing in haskell that reminds me of a "hole" is _ in a pattern match
00:52:46 <jrmithdobbs> and weird uses of undefined
00:52:52 <jrmithdobbs> those are "holes"
00:54:51 <Twey> Those are deep pits into which things fall and are never found again… heck, undefined might even be described as a black hole that sucks the rest of your program down into it if you get too close :þ  But bound variables are just little dents that can be filled in by similarly-shaped bits of code to get a complete, evaluable expression
00:55:23 <Twey> Kind of like a jigsaw puzzle, I suppose
00:55:29 <jrmithdobbs> haha, clever
00:57:51 <jrmithdobbs> Twey: maybe i derive (too much?) intuition for that kind of thing from simple algebra. x = y + 1; What's x? If dealing with integers it's any integer == succ y, that's an awful large set to be considered a hole ...
00:57:52 <Twey> And really, there's no good reason why the ‘textual expression with named variable’ metaphor should be any more privileged than the ‘shape with hole’ metaphor — the former just happens to have been more convenient to display on old computers.  Ultimately they're both just aspects of something much more abstract, like the wave/particle duality in physics.
00:58:59 <Twey> jrmithdobbs: The hole is just ‘integer-shaped’: you just know you can put *any* integer into it, you don't have to try to put *every* integer into it
00:59:39 <jrmithdobbs> Twey: but you gave the example of using interactive shapes to interact with, that's exactly why the textual representations make more sense to me, you throw them in a text file or a repl and you can play with them.
01:00:59 <Twey> jrmithdobbs: And you'd still be able to; I'm just fooling around with ideas of *other* ways to play with them, ones that maybe reflect a little less textiness (parse errors? eek) and a little more functionness
01:02:30 <Twey> (or rather, typedness)
01:03:12 <bitemyapp> playing with the shape of text when you really care about the shape of your types and functions is slow, fiddly, and error-prone.
01:03:24 <bitemyapp> if I could make a co-* by just flipping the arrows around that would be positively divine :)
01:04:01 <bitemyapp> nothing wrong with text. I quite like it. I just don't think it's the only level of abstraction or medium we can be working with.
01:04:27 <mr-> A lot of annoying stuff (like flip) would just mean rearranging the sides. It's a very complicated puzzle, though
01:04:57 <Twey> Aye
01:05:11 <Twey> But you should only have to look at a bit of it at a time
01:05:36 <bitemyapp> and being able to direct textual manipulation in terms of the higher level abstractions would be nice.
01:05:49 <bitemyapp> flipping an arrow would change underlying text, and I'd see as much in a console.log in a side-terminal when I did so.
01:06:00 * bitemyapp rubs hands together and grins
01:06:12 <bitemyapp> Twey: we live in da future.
01:06:48 <jrmithdobbs> heh, i have a hard enough time not sounding crazy talking about haskell with coworkers and you want to add spinning arrow ides? ;p
01:07:39 <bitemyapp> jrmithdobbs: well, filter according to your audience.
01:07:52 <bitemyapp> jrmithdobbs: I didn't talk about Haskell at my company until I'd already sold them on using Clojure for a few projects.
01:07:58 <bitemyapp> thin end of the wedge and all that.
01:08:11 <jrmithdobbs> i'm trying to save myself from go
01:08:19 <bitemyapp> now I'm a Haskell trap-spider, shanghai'ing passing coworkers into haskell tutorials.
01:08:57 <mr-> bitemyapp: how many haskell projects have you done in that company?
01:09:37 <jrmithdobbs> bitemyapp: i did the spj lens video driveby earlier today myself! ;p
01:11:30 <bitemyapp> mr-: none yet because I'm not yet working in the dept that needs Haskell the most, but there are active Clojure projects I am working on. All things being equal these people would just keep using Python and Yavascript.
01:13:30 <bitemyapp> mr-: I've got ongoing fairly serious but relatively young Haskell and Fay projects at home. Been using HS off and on since '08, same year I started w/ Clojure.
01:19:08 <jrmithdobbs> Twey: as an example, i honestly find things like this (ignoring the pictures) the most helpful. walls of english explanation followd by code, preferably starting with an example that explains why reading the rest is at all interesting https://www.fpcomplete.com/user/bartosz/understanding-yoneda
01:20:36 <bitemyapp> jrmithdobbs: the pigs are hilarious
01:21:37 <Twey> jrmithdobbs: How do you feel about things like http://worrydream.com/#!2/LadderOfAbstraction ?
01:21:58 <Twey> (diagrams further down, with explanations)
01:23:25 <jrmithdobbs> Twey: that's straight up hard to read =/
01:24:19 <jrmithdobbs> Twey: my eyes can't stay focused on the text enough to answer honestly, that's like obnoxiously distracting
01:24:44 <Twey> Interesting
01:25:40 <bitemyapp> jrmithdobbs: I feel you on wanting to stay the hell way from Go
01:25:49 <bitemyapp> one of the biggest backwards steps this industry has made since...C.
01:25:58 <bitemyapp> hey wait a second, same people.
01:27:06 <Twey> C was a Google conspiracy‽
01:28:02 <jrmithdobbs> bitemyapp: i don't mind C, really, at least it's honest about what it is, go is just, i don't get what it's trying to solve, ha
01:28:38 <jrmithdobbs> and ya, not sure i get the reference there either
01:28:59 <bitemyapp> actually I think Go is much worse in this respect.
01:29:15 <bitemyapp> C's advantage was portability, but there were better languages in existence at the time
01:29:26 <bitemyapp> but they weren't really available or implementable for the hardware they had to work with
01:29:46 <bitemyapp> now hardware is fairly homogenous, so a language being relatively easy to write a compile for isn't that important.
01:30:05 <bitemyapp> Go is a big leap backwards, but not for any particularly good reason.
01:30:15 <numbersgame> http://i.imgur.com/uyWJPHC.png
01:30:17 <bitemyapp> other than a very crude abuse of "familiarity"
01:30:47 <Maior> fwiw, being able to trivially cross compile and have binaries with virtually no dependencies has been _wonderful_ ime
01:30:55 <numbersgame> my main function is inside the red box and it gives the following output as shown by the arrow.. why arent they executing in order
01:31:04 <jrmithdobbs> I keep thinking i'm missing something but I don't think I am
01:31:28 <jrmithdobbs> re: go, i mean
01:31:30 <bitemyapp> numbersgame: that's pretty cool :)
01:31:38 <numbersgame> its not my code..
01:31:51 <bitemyapp> oh, pity.
01:31:59 <numbersgame> its not my code though.. its from a tutorial.. :D
01:32:14 <Twey> Maior: In Go?
01:32:24 <bitemyapp> Haskell has statically linked libraries too.
01:32:46 <numbersgame> bitemyapp: http://www.cs.nott.ac.uk/~gmh/countdown.hs
01:34:02 <numbersgame> bitemyapp: can you tell me why its not following the order? do you understand my question?
01:34:14 <numbersgame> http://i.imgur.com/uyWJPHC.png
01:34:16 <bitemyapp> I have to hit the sack, I'm not the person to answer your question. Pacific time :)
01:34:26 <numbersgame> okay
01:34:49 <ij> bitemyapp, Go was made as a replacement for C++. Is it a leap backwards from it?
01:34:51 <supki> numbersgame: stdout is line-buffered by default
01:34:51 <Twey> numbersgame: Looks like buffering.  You see where you have the ‘hSetBuffering stdout NoBuffering’ commented out?
01:35:16 <numbersgame> what does those functions do?
01:35:46 <bitemyapp> ij: it doesn't suffice and it's terrible anyway.
01:35:55 <isyn_asaz> ij: Go only works as a replacement for C++ the same way Java does,
01:35:56 <bitemyapp> ij: you can't replace C++ with a garbage-collected language, for pete's sake.
01:36:08 <bitemyapp> ij: Go is roughly like Java, as isyn_asaz said.
01:36:15 <bitemyapp> in terms of applicable problem space.
01:36:36 <bitemyapp> that Google was using C++ in places Java would've been better suited is their mistake, not many other companies are that silly.
01:36:40 <DawidLoubser> Agreed, I don't think Go can possibly replace C++
01:36:45 <SaBer> I know very little about Go, but the fact that it doesn't have generics turns me off...
01:36:55 <Twey> It has row-typing
01:37:02 <bitemyapp> SaBer: right, going back to my "step backwards" bit.
01:38:10 <numbersgame> when I uncomment those I'm getting a parse error supki twey
01:38:17 <isyn_asaz> it's just a slight step up on Java, I don't think it's a step backwards from C++ anymore than Java was, but the fact something like Java existed makes me question the utility of it
01:38:34 <supki> numbersgame: well, you'll need to indent them properly
01:38:42 <supki> like the rest of the do block
01:38:53 <Twey> numbersgame: By default, stdout is generally line-buffered: it will only print what you've written to it after you send a newline.  By using the hSetBuffering function, you can change that to NoBuffering (write everything as soon as you get it, probably what you want), LineBuffering (as it currently is), or BlockBuffering (write every n characters).
01:39:06 <FireFly> I think I'd prefer both Java and Go for application development
01:40:10 <FireFly> over C++ I mean
01:40:13 <numbersgame> ohh..
01:40:18 <isyn_asaz> I do prefer Go's concurrency model, but it's not enough to make up for the deficits everywhere else in the language
01:40:26 <bitemyapp> Twey: could just make an auto-flushing function, no?
01:40:30 <ij> I still see no reason to ditch go as useless. It's got some concurrency, it's simple and is safe. And these backwards/forwards comparsions I think are just stupid flames.
01:40:42 <isyn_asaz> ij: it's not safe
01:40:43 <bitemyapp> isyn_asaz: don't be so content, they're considering getting rid of M:N green threads.
01:41:05 <bitemyapp> ij: Go is less safe than Java by a huge amount.
01:41:10 <jrmithdobbs> bitemyapp: lol what
01:41:14 <bitemyapp> ij: have you not seen the ridiculous interface{} crap.
01:41:25 <ij> And what do you mean by unsafe?
01:41:27 <FireFly> What is ridiculous about that?
01:41:38 <bitemyapp> am I in #haskell?
01:41:43 <FireFly> Lol
01:41:43 <bitemyapp> right, I am.
01:42:06 <ij> right, everyone must have the same opinion as yours in #haskell.
01:42:22 <jrmithdobbs> i think i'd honestly take c++11 over java or go
01:42:25 <bitemyapp> "Golang is ridiculous" is one of those self-evident truths up there with pursuit of happiness.
01:42:30 <shachaf> Yes. So this sort of language bashing is pretty off-topic at this point.
01:42:56 <bitemyapp> anyway
01:43:10 <numbersgame> oh i simply put a new line in the end of each putStr and removed hSetBuffering stdout NoBuffering line supki twey
01:43:11 <sipa> i still like to know in what way it is unsafe
01:43:17 <ij> ^
01:43:33 <bitemyapp> Twey: couldn't they use https://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#v%3AhFlush if they wanted?
01:43:43 <mr-> numbersgame: note, that there's also putStrLn
01:44:18 <mornfall> oh dear :-)
01:45:32 <numbersgame> why is that a default behaviour though?
01:46:10 <Twey> bitemyapp: Sure
01:46:19 <Twey> It's a bit clumsy, though
01:46:44 <Twey> numbersgame: You only needed to do one of those things :þ
01:48:40 <bitemyapp> Twey: just coming up with options :)
01:49:07 <thelordofthfrogs> hey guys, newbie here, can someone tell me what maximum' (x:xs)  this means
01:49:31 <supki> numbersgame: printing characters one-by-one is slow, so you generally want buffering
01:49:46 <supki> numbersgame: that's why it's the default behavior
01:50:00 <BoR0> thelordofthfrogs, it's a list comprehension. (x:xs) means that from a given list, x will be the head and xs the rest of the list
01:50:30 <thelordofthfrogs> boro, thanks a lot man
01:50:40 <BoR0> sorry, list pattern matching. not list comprehension
01:51:46 <numbersgame> thelordofthfrogs: you probably saw that line in a function that is trying to get the maximum number in a given list
01:52:55 <thelordofthfrogs> numbersgame: yup
01:53:28 <thelordofthfrogs> numbersgame: saw it in this tutorial http://learnyouahaskell.com/recursion
01:53:33 <numbersgame> maximum (x:xs) = if x > maximum' xs then x else (maximum' xs)
01:53:48 <thelordofthfrogs> numbersgame: that's it :D
01:54:04 <numbersgame> I'm a newb too.. pattern matching is the most obvious thing that you get to appreciate when you first come to haskell
01:58:17 <BoR0> @pl max
01:58:18 <lambdabot> max
01:58:29 <jeronimo> hello
01:58:33 <BoR0> @pl \x y ->  if x <= y then y else x
01:58:33 <lambdabot> flip =<< join . (if' .) . (<=)
01:58:38 <jeronimo> what is wrong with this?
01:58:47 <jeronimo> > let path = "/dir/file.txt" in liftA2 combine (takeDirectory path) (takeBaseName path)
01:58:48 <lambdabot>  Not in scope: `combine'Not in scope: `takeDirectory'Not in scope: `takeBaseN...
01:59:34 <shachaf> Those names aren't in scope, like lambdabot says.
01:59:38 <jeronimo> I am getting this error: Expected type: [FilePath]  Actual type: FilePath
02:00:14 <lieven_> cabal is compiling regex-tdfa. Is this supposed to take this long?
02:00:28 <jeronimo> they are not in scope because lambdabot did not include needed modules
02:00:45 <shachaf> Yes, but you didn't say what the error was back then.
02:00:55 <Maior> jeronimo: Paste code/errors: http://lpaste.net/new/haskel
02:00:56 <shachaf> Why are you writing liftA2 combine ...? What result are you expecting?
02:00:57 <jeronimo> *yawns*
02:00:59 <Maior> +l
02:01:04 <Maior> as per topic
02:02:25 <danny> are haskell gtk bindings better than qt?
02:02:37 <Jookia> Is there a way to bind the result of an either monad, but if it fails and returns a Left, 'return' that?
02:02:51 <Maior> Jookia: ...eh?
02:02:58 <Jookia> Maior: http://sprunge.us/UTfV
02:03:31 <Jookia> Maior: I'm returning the left values, but using >>= fails because I assume its failure condition doesn't return
02:03:36 <shachaf> Are you hoping for something of type :: Either a a -> Either e a
02:03:39 <Jookia> (using lots of lingo because I don't understand monads
02:03:40 <shachaf> Or maybe Either a a -> a?
02:03:48 <Jookia> Let me think
02:03:58 <shachaf> Oh, well, in that case.
02:04:23 <Maior> Jookia: drop the lingo ;P
02:04:24 <shachaf> If you don't understand something, you should use *less* lingo. Lingo is shorthand for things both parties understand.
02:04:28 <Maior> indeed
02:04:29 <danny> I would prefer to use qt if bindings are usable. anyone has experience with qt in haskell?
02:04:34 <Jookia> :v Sorry, I don't know what the terms are
02:04:37 <Maior> shachaf phrases it much better
02:04:46 <Jookia> I'll post what I *want* to write and why I can't write it
02:05:11 <Maior> Jookia: then definitely don't risk using the wrong ones - showing what you want and why that doesn't work is a good plan
02:06:39 <peteretep> I have: returnMy x = MyMonad (x, "")
02:06:41 <peteretep> Which is fine
02:06:47 <Jookia> http://sprunge.us/JZCG  I have a feeling I need to lift something
02:06:50 <peteretep> But my type signature for it gives complaints that I don't understand
02:06:54 <peteretep> returnMy :: a -> MyMonad (a, String)
02:07:03 <peteretep> Any clues?
02:07:08 <jeronimo> for some reason I thought takeDirectory and takeBaseName return IO String instead of String. anyway, thanks for being jerks instead of helping
02:07:35 <Maior> gosh he was lovely
02:07:47 <Maior> peteretep: pastebin the code and complaints please?
02:08:27 <Maior> Jookia: what's the type of lastPostDate?
02:08:28 <peteretep> http://pastebin.com/phdkVeZk
02:08:48 <Jookia> Maior: lastPostDate :: [JSON.Object] -> Either String UTCTime
02:09:41 <Maior> Jookia: ahh right
02:09:56 <Maior> Jookia: what do you want to happen when you get a Left String back?
02:10:17 <ij> Is it possible to run haskell in the browser? Emscripten is said to compile to llvm and ghc can compile to llvm, correct?
02:10:39 <Jookia> Maior I want to return it in to the Coroutine's monad
02:10:52 <Maior> Jookia: there are clever things I'm sure that can be done here, but basically, you can't take an "Either a b" and just go "hey here's a function that takes a b" (even ignoring the monadic stuff)
02:11:33 <Maior> Jookia: so fundamentally you're going to need _something_ a bit like "if it's Left, do this, if it's Right, do this"
02:11:49 <Maior> Jookia: (also I don't see where Coroutine's coming from?)
02:12:01 <Jookia> Maior: From the monad-coroutine library :P
02:13:29 <Jookia> I just realized I need to be in the Coroutine monad with my list of stuff any way >_< Woops. I'm still not happy about my chain of eithers though. Hmm, I think I need to be using Either String Coroutine ...
02:14:03 <Maior> Jookia: yeah that's what I mean
02:14:20 <Maior> sorry, didn't really express it hugely well
02:14:28 <Jookia> Hmm. So how would I lift my dumb either in to a coroutine is the question. :s
02:15:24 * Maior reads m-c docs
02:16:10 <Maior> (it feels like there's code you're not showing)
02:16:23 <Jookia> Oh I'll paste my entire function (it's messy)
02:16:39 <Jookia> http://sprunge.us/RHga
02:16:57 <Jookia> There's other util stuff but it's organized in to multiple files
02:17:02 <Jookia> That's all the coroutine stuff there
02:17:13 <Maior> so
02:17:18 <Maior> small functions ftw ;)
02:17:30 <Jookia> Yeah, this is my first step to cleaning it up
02:18:07 <Maior> "also I don't see where Coroutine's coming from?" -> "type JSONGet m = Coroutine JSONReq m JSONRet" :P
02:18:24 <Jookia> Maior: Oops
02:18:29 <Twey> ij: Yes, but more directly there's Fay and now GHCJS
02:18:30 <Maior> help me help you ;)
02:18:52 <Twey> :t either
02:18:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:19:00 <Jookia> I think what I'm doing with my either chains is returning a coroutine and so maybe I need to somehow make my various things along the way turn in to coroutine eithers
02:19:26 <Jookia> Which is kind of what return does. But is there a way to return an entire function? I've tried 'lift' blindly but that doesn't seem to work
02:20:23 <Jookia> Lifting the function crashes GHC actually
02:21:23 <Maior> ...does this actually compile as-is?
02:21:43 <Maior> I can't easily verify that myself because it's incomplete
02:21:56 <Jookia> Uh, no. I'd have to provide a bunch of other files to toy around with it. It's really all a mess. :\
02:22:10 <Jookia> Maybe I'll think about what type of type signature I need
02:22:15 <Maior> so
02:22:16 <Jookia> For this magic function
02:22:25 <Maior> I don't think I can easily help you, beyond general advice like
02:22:40 <Maior> check out either (as Twey showed above)
02:22:55 <Jookia> Thanks :3
02:22:56 <Maior> and the point at which you've indented more than 3-4 times, consider a new function
02:23:22 <Maior> small easily-readable easily-testable clearly-typed functions make everything easier
02:23:42 <Jookia> Maior: I'm using coroutines to make this supposedly testable, it's an IO-reliant task... without the IO
02:24:26 <Jookia> It's a recursive task, it'd be great if I made the function recursive
02:26:36 <Jookia> I think the reason it's the current way it is, is the case of the first iteration being empty. But thinking about it, maybe the design is flawed there
02:26:40 <Jookia> ¯\_(ツ)_/¯
02:26:56 <Jookia> Do you think coroutines are clean when splitting up IO from logic?
02:27:50 <Maior> Jookia: I don't really understand why you're using them, I'm afraid
02:28:30 <Jookia> Maior: I'm using a web API, and I have logic cycle that goes 'get URL, download page, do logic, possibly repeat'
02:28:39 <Jookia> The IO is the download page part
02:29:24 <Maior> Jookia: so how do coroutines help you "split" that?
02:29:32 <Maior> or do you mean computationally rather than organisationally?
02:30:32 <Jookia> Maior: I'm splitting it so I wrap the coroutine in an IO method that does the downloading and passing information back. Maybe it'd be a better idea to just take a function that downloads the page, with a generic type m for monad so it doesn't have to be IO
02:30:48 <Jookia> Maior: But that makes it a little hard to test
02:32:55 <Maior> Jookia: so you have a function that downloads the page, which is something like URL -> IO String
02:34:13 <Maior> Jookia: a function a bit like String -> YourDataFormat, your "logic" of type YourDataFormat -> Something
02:34:40 <Jookia> Maior: Yes, but write now it's in a coroutine with the looping.
02:35:02 <Maior> that shouldn't affect much more than the request loop
02:35:15 <Maior> the other stuff doesn't care
02:35:23 <Maior> or are you trying to multitask this?
02:35:26 <Jookia> Maior: The function runs the coroutine, gets the URL, sends the downloaded page back, then waits for the output or another request for the URL
02:35:50 <Maior> what's your actual spec?
02:35:57 <Jookia> Maior: Spec?
02:36:31 <Maior> Jookia: well fundamentally I'd suggest writing it without coroutines
02:37:01 <Maior> then once you've got something that works and is neat, add coroutines to parallelise better
02:37:23 <Jookia> So would I. But I can't think of (many) ways to test it without coroutines as I'd need to inspect the data on each step.
02:37:37 <Maior> Jookia: er, the stages I outlined above
02:38:05 <Jookia> Hmm?
02:38:32 <Maior> URL -> IO String, String -> YDF, YDF->Something, then some sort of coordination wrapping that
02:38:58 <Jookia> I was thinking along of the lines of
02:39:29 <Jookia> Params -> (URL -> IO String) -> Data
02:39:51 <Maior> which would wrap up your smaller functions, yes
02:40:10 <Jookia> I suppose that's testable
02:41:26 <Jookia> I learned with coroutines that there's an identity monad
02:41:33 <Jookia> while using coroutines*
02:41:56 <Jookia> I didn't know that before so that's why I kind of avoided the idea as I'd have to make the function impure for the function it took to download URLs
02:42:14 <Maior> I think I'm going to have to leave you to it I'm afraid
02:42:24 <Jookia> I'm just babbling at this point. :P
02:43:14 <Maior> but like
02:43:18 <Maior> stop using coroutines
02:43:20 <Maior> 'til much later
02:43:24 <Maior> start writing small functions
02:43:49 <Jookia> Yes. I felt the spaghetti but didn't know a better way :P
02:43:55 <Jookia> Spaghetti falling out of my code pockets
02:45:06 <ij> Twey, Cool, thanks!
02:49:16 <t7> @hoogle (<*>)
02:49:17 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
02:49:36 <t7> @hoogle (<+>)
02:49:36 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
02:49:36 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
02:49:36 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
02:50:16 <Jookia> Dang arrows
02:50:18 <t7> @hoogle (a -> b -> c) -> m a -> m b -> m c
02:50:19 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:50:19 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:50:19 <lambdabot> Data.IntMap.Strict intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
02:50:38 <t7> can i do liftM2 with infix?
02:51:07 <Feuerbach> yes, liftM2 (+)
02:51:07 <ij> I'm not sure, but isn't that a combo of <$> and <*>?
02:51:15 <ij> oh, that you mean..
02:51:31 <quicksilver> (+) <$> x <*> y
02:51:45 <t7> liftM2 a b c = a <$> b <*> c
03:00:18 <the_berserker> @pl \f x -> let xs = x : map f xs in xs
03:00:18 <lambdabot> (fix .) . flip ((.) . (:)) . map
03:01:17 <the_berserker> @pl let iterate f x = x : iterate f (f x) in iterate
03:01:17 <lambdabot> fix ((ap (:) .) . ((.) =<<))
03:02:31 <the_berserker> > (fix ((ap (:) .) . ((.) =<<))) (*2) 1
03:02:32 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
03:03:27 <the_berserker> How to get rid of the bind operator in the pointfree definition?
03:08:29 <GOOD_JOB_OPERS> http://box.ra.pe:8080/
03:12:34 <identity> ocharles: It seems the last couple of links on your 24 days of hackage for 2013 are broken. The problem seems to be that it's looking for the last posts in ./blog/guests-posts/ instead of posts(the correct link can be found in ./blog/)
03:13:00 <identity> how was it you could tell someone something using lambdabot in order to make sure they saw it?
03:14:42 <Hafydd> @help tell -- identity
03:14:42 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
03:18:02 <identity> thanks
03:18:15 <identity> @tell ocharles It seems the last couple of links on your 24 days of hackage for 2013 are broken. The problem seems to be that it's looking for the last posts in ./blog/guests-posts/ instead of posts(the correct link can be found in ./blog/)
03:18:15 <lambdabot> Consider it noted.
03:18:19 <identity> thanks babe.
03:20:06 <ocharles> identity: thanks, I'll sort that out now
03:20:39 <identity> ocharles: thanks yourself -- 24 days of hackage is more fun than christmas
03:26:03 <ocharles> :D
03:26:09 <ocharles> Glad you liked it
03:28:45 <hc> yay - i finally found my memory leak: i had   fun x y = catch ioerr $ do ... fun x y
03:29:00 <hc> changed that to catch ioerr $ (call fun repeatedly)
03:29:03 <teneen> what's the complexity of "minimum = head . sort" for quicksort, mergesort or any other efficient algorithm?
03:30:34 <Feuerbach> that obviously depends on the algorithm itself
03:31:02 <Feuerbach> for many it'll be O(n) or close, but for some it could be O(n log n)
03:31:22 <Feuerbach> and by O I mean theta
03:31:38 <teneen> Feuerbach: for quicksort and mergesort?
03:31:46 <johnw> hc: right, it wasn't tail recursive
03:33:34 <Feuerbach> teneen: I think it's O(n) (excluding "bad" cases for quicksort)
03:47:45 <numbersgame> so I have a listFunction that results in a list.. a lazy list? I only ever going to use the head of that list in further computations.. the list from my listFunction will sometimes be an empty list [], How do i write a control statement, that does one thing if the result is an empty list and another thing if the list is not empty..
03:48:17 <numbersgame> if I use (length xs == 0) in my if statement its evaluating the entire list and its taking a lot of time..
03:48:21 <numbersgame> I dont want that
03:48:55 <supki> case xs of [] -> ...; (x : _) -> ... x ...
03:49:29 <numbersgame> does case statements work in a do block?
03:49:40 <sopvop> :t null
03:49:41 <lambdabot> [a] -> Bool
03:49:54 <Saizan> numbersgame: yep
03:50:04 <numbersgame> or i can use null?
03:50:07 <sopvop> >t: guard (null []) $ do return ()
03:51:03 <Yaniel> > take 1 []
03:51:05 <lambdabot>  []
03:53:04 <byorgey> you can use null, if you don't want to do anything with the first element of the list when it is not empty
03:53:13 <numbersgame> how do i get to haddock of a function from ghci
03:53:15 <byorgey> otherwise I would use case like supki suggested
03:53:17 <numbersgame> yeah null is nice
03:54:31 <numbersgame> i have some vim extension that takes me to haddock if i type _? on the function in normal mode.. it opens in a browser.. how do i do that from ghci?
03:54:49 <byorgey> it's not easy
03:55:20 <byorgey> I don't know any way to get it to open in a browser.  You can install hoogle locally and set up a ghci command to call it
03:55:42 <byorgey> :def doc    \q -> return $ ":! hoogle --color=true --info      \"" ++ q ++ "\""
03:57:07 <ghorn> has anyone tried to install lens using 7.8 RC1?
03:57:29 <ghorn> I'm getting a linking error
04:08:11 <identity> numbersgame: what plugin is that?
04:09:00 <identity> numbersgame: but you can do what byorgey just showed you, but instead call the browser on the appropriate search url or some such
04:15:22 <byorgey> ghorn: apparently it's a known issue, and you can work around it by just calling 'cabal build'/'cabal install' repeatedly until it works =P
04:16:35 <ghorn> byorgey: thank you
04:17:52 <ghorn> byorgey: is it an issues with lens or ghc or cabal?
04:17:56 <ghorn> out of curiousity
04:19:44 <byorgey> ghorn: GHC, I think.  I don't actually know much about it.
04:34:18 <belikolei> Hallo Hasketeers
04:34:33 <Hafydd> Haskelliers
04:35:07 <danilo2> Hello! Is there any library in Haskell providing just "Stack" functionality? I iknow I can implement it in 15 lines of code, but I strongly belive in code reusability and if such functionality exist I will just use it. I think it should be somewhere in standard lib
04:35:35 <Hafydd> danilo2: do you mean like [a]?
04:37:37 <Axman6> a list is definitely a stack
04:37:51 <ghorn> the only thing a list can't do is O[1] size
04:38:24 <Axman6> push being (:) and pop st [] = Nothing; pop (x:xs) = Just (x,xs)
04:38:34 <Axman6> don't even need 15 lines, just one :P
04:39:31 <dredozubov> it seems more like 4 lines to me, but anyways - lists are great stacks
04:39:51 <mm_bureau> danilo2: type Stack = []
04:40:00 <mm_bureau> push = (:)
04:40:18 <mm_bureau> pop  = foldr (\x _ -> Just x) Nothing
04:40:33 <danilo2> Hafydd: yes, like a with push and pop operations. Axman6: I know :P I just was wanderingif these one liners are somewhere implemented
04:40:53 <belikolei> I'm trying to understand more about lazy evalutation. I have a function textXY :: Int -> Bool, and will map it onto a Int-list and compare with my desired result: (map (textXY) [14,83,15]) == [True, False, False]. What if textXY requires a lot of computational work? Is it faster to use && because if one is wrong the compiler wont bother checking th
04:40:53 <belikolei> e other cases? Or doesn't it matter because of lazy evaluation - which would also require that (==) compares the first elements of 2 lists, then the second and so on?
04:40:55 <mm_bureau> danilo2: no, because you would usually use cons and pattern-matching
04:41:14 <mm_bureau> danilo2: there is no reason to have an actual function named "pop"
04:41:39 <Axman6> belikolei: the == on lists terminates as soon as it finds two differing values
04:41:47 <Axman6> @src [] (==)
04:41:47 <lambdabot> []     == []     = True
04:41:47 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
04:41:47 <lambdabot> _      == _        = False
04:42:31 <Axman6> belikolei: and as such, the only values computed are the ones which are equal and the first one that isn't
04:43:09 <danilo2> mm_bureau: hmm, it makes sense. Ok, the quesition was too simple. I was thinking about a use case with lenses and monad transformers - there such function sometimes makes sense, but it should be different question
04:43:50 <belikolei> now i understand, thank you. i couldn't find the source of (==) at http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html because it links to 404...
04:43:50 <mm_bureau> danilo2: so you want an imperative stack language…  for that you can just use a state monad over a list
04:44:03 <mm_bureau> and in that case you would have to write push and pop
04:44:34 <mm_bureau> push x = state (x :)
04:45:00 <mm_bureau> and i'll leave writing pop as an exercise to you…  hint:  write the type signature first, and if it doesn't include a Maybe, it's wrong =)
04:45:28 <belikolei> which also gives me a much more elegant way to check since my Int-list is of length 12 and using 12 times && is ugly ;)
04:45:42 <belikolei> thanks again, have a good day everyone
04:45:58 <ghorn> same to you
04:50:40 <danilo2> mm_bureau: Ok, this question did nto have any sense :P nvm :)
04:51:42 <danilo2> mm_bureau: I realized I was just looking for stack monad
04:52:02 <danilo2> mm_bureau: something like stack monad - I just wanted to make it more general than just state with lsit
04:52:16 <mm_bureau> danilo2: well, you can write a type class
04:52:57 <mm_bureau> class MonadStack s m | m -> s where push :: s -> m (); pop :: m (Maybe s)
04:53:19 <mm_bureau> instance (Monad m) => MonadStack a (StateT [a] m)
04:53:49 <mm_bureau> the only advantage is that you can implement auto-lifting
04:54:52 <ownclo> MonadStack is probably a bad name though
04:55:22 <mm_bureau> indeed =)
04:57:23 <danilo2> mm_bureau, ownclo: :)
04:58:01 <mm_bureau> i think you can prove that any other instance of this MonadStack is basically StateT over [a] in disguise
04:58:27 <mm_bureau> it's a simple isomorphism proof
04:58:58 <mm_bureau> so you could just as well implement push and pop by MonadState =)
04:59:32 <mm_bureau> push :: (MonadState [a] m) => a -> m ()
05:04:31 * hackagebot tasty-program 1.0.0 - Use tasty framework to test whether a program executes correctly  http://hackage.haskell.org/package/tasty-program-1.0.0 (JanStolarek)
05:04:31 * hackagebot diagrams-svg 1.0.1.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.1.2 (BrentYorgey)
05:12:16 <ownclo> @quote morphism
05:12:16 <lambdabot> monochrom says: knows how to combat monomorphisms!
05:19:27 * hackagebot murmur-hash 0.1.0.7 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.7 (ThomasSchilling)
05:23:47 <bernalex> does anyone have a neat codegolf version of fizzbuzz euler 1? just curious
05:24:28 * hackagebot egison 3.2.13 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.13 (SatoshiEgi)
05:24:35 <bernalex> http://lpaste.net/5894587909314445312 would be one of the dull ways to do it, in case you're not familiar with the challenge
05:27:39 <quicksilver> bernalex: http://dmytrish.wordpress.com/2013/10/10/haskell-fizzbuzz/
05:27:49 <bernalex> quicksilver: thanks
05:28:17 <bernalex> FTR: I've been doing C++ all day. I need some cheering up.
05:31:29 <int-e> > sum(filter((>1).gcd 15)[1..1000])
05:31:31 <lambdabot>  234168
05:31:45 <identity> Wasn't there a flag for ghc that sacrificed some floating point accuracy in favor of speed?
05:31:49 <int-e> > let n = 1000; a c = c*(c+1) `div` 2; s d = d * a (n `div` d) in s 3 + s 5 - s 15
05:31:51 <lambdabot>  234168
05:32:56 <identity> nevermind -- -fexcess-precision
05:34:25 <identity> oh, and -optc-ffast-math
05:36:01 <quicksilver> identity: if you GHC is 10 years old, yes
05:36:25 <identity> quicksilver: hmm?
05:36:41 <identity> quicksilver: care to elaborate?
05:40:53 <quicksilver> identity: those options, as far as I know, relate to the via-C backend
05:41:02 <quicksilver> identity: which was the backend before the native codegen
05:41:09 <quicksilver> which itself was the backend before the 'new' codegen
05:41:12 <quicksilver> which we're using now.
05:41:13 <identity> oh, I see.
05:41:37 <identity> I didn't notice any performance improvements at any rate, but I guess that means the wiki pages need an update (Performance/GHC)
05:41:41 <quicksilver> also most people are on 64-bit
05:41:52 <quicksilver> which doesn't have the old-style x87 FPU registers in any case
05:42:58 <pranz> @pl \(x,y) -> x:y:ls
05:42:59 <lambdabot> uncurry ((. (: ls)) . (:))
05:49:31 * hackagebot egison-tutorial 3.2.4 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.4 (SatoshiEgi)
06:31:24 <zomg> by the way, I just found an Irssi script to mimic the weechat "ignore joins/parts for people who haven't spoken recently" feature someone mentioned yesterday, in case anyone is interested http://crshd.anapnea.net/2012/10/03/Smartfilter-for-Irssi/
06:53:18 <dennda> lukexi: Ping
06:57:39 <dennda> lukexi: Trying to follow your instructions at https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS -- Getting the following: https://gist.github.com/dennda/4b915fb1a33a9b0c66ad
07:01:14 <vamega> Hi.
07:01:29 <vamega> I downloaded the new GHC Release Candidate.
07:01:48 <vamega> But after installing I'm not finding a bundled cabal.
07:02:01 <vamega> Isn't cabal usually bundled with ghc?
07:02:16 <alpounet> no
07:02:41 <alpounet> ghc uses the Cabal library, but the handy 'cabal' tool isn't bundled with ghc. only in the haskell platform
07:03:03 <alpounet> you can however use your good old cabal
07:03:17 <the_berserker> @pl let x = not x in x
07:03:17 <lambdabot> fix not
07:03:26 <the_berserker> > fix not
07:03:27 <alpounet> using the —with-ghc and —with-hc-pkg options of cabal for example
07:03:30 <lambdabot>  mueval-core: Time limit exceeded
07:04:02 <the_berserker> @unpl (=<<)
07:04:02 <lambdabot> (\ b c -> c >>= b)
07:04:10 <vamega> @alpounet - Thanks.
07:04:11 <lambdabot> Unknown command, try @list
07:04:38 <the_berserker> @pl let iterate f x = x : iterate f (f x) in iterate
07:04:38 <lambdabot> fix ((ap (:) .) . ((.) =<<))
07:05:15 <the_berserker> Why is there (=<<) in my expression?
07:06:12 <the_berserker> @pl \f x -> let xs = x : map f xs in xs
07:06:12 <lambdabot> (fix .) . flip ((.) . (:)) . map
07:06:25 <zomg> Probably because @pl is mostly useful for code golfing? =)
07:06:44 <the_berserker> > ((fix .) . flip ((.) . (:)) . map) (+1) 0
07:06:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:08:04 <the_berserker> > (fix ((ap (:) .) . ((.) =<<)))(+1) 0
07:08:05 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:14:16 <maxiepoo> ugh I'm getting linking errors
07:14:32 <maxiepoo> dist/dist-sandbox-cab5876e/build/elm/elm-tmp/SourceSyntax/Pattern.o: In function `schU_info':
07:14:32 <maxiepoo> (.text+0x18cc): undefined reference to `xsszmsanitizzezm0zi3zi4zi2_TextziHTMLziSanitizzeXSS_zdsinsertzuzdsgo5_info'
07:14:47 <maxiepoo> no idea what to do :/
07:15:44 <int-e> oh. no preflex.
07:17:09 <akegalj_> is there function that will do zip 0 [1] [1,2,3] => [(1,1), (0,2), (0,3)]    or something like it in standard lib?
07:17:40 <the_berserker> @pl \f -> let x = f x in x
07:17:40 <lambdabot> fix
07:18:10 <the_berserker> @pl let y f = f (y f) in y
07:18:10 <lambdabot> fix (ap id)
07:18:17 <Tekmo> akegalj_: No, but you can define your own pretty easily
07:18:31 <akegalj_> Tekmo: yes, will do so now :)
07:18:32 <Tekmo> akegalj_: zip' n xs ys = zip (xs ++ repeat n) ys
07:18:50 <td123> akegalj_: zip (1:[0,0..]) [1,2,3]
07:19:05 <akegalj_> Tekmo, td123 : thnx :)
07:19:06 <benzrf> hey
07:19:10 <Tekmo> akegalj_: You're welcome
07:19:17 <benzrf> is there a way to use the applicative style with lenses?
07:19:29 <Tekmo> benzrf: What do you mean?
07:19:33 <the_berserker> > let y f = f (y f) in y (1:)
07:19:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:19:37 <int-e> akegalj_: should it also work if the second list is shorter than the first one?
07:19:38 <benzrf> i.e.
07:19:46 * hackagebot HTF 0.11.1.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.1.1 (StefanWehr)
07:19:52 <benzrf> hmm wait a sec let me think p:
07:20:19 <benzrf>  (+) <$> _1 <*> _2 -- lens that focuses on the sum of the first and second parts of a tuple
07:20:30 <benzrf> style of thing
07:20:42 <akegalj_> int-e: yes.. but will do it with guards
07:20:47 <benzrf> basically if over is fmap, is there a <*>
07:20:52 <int-e> akegalj_: if yes I think the best way is the obvious 4 line definition.
07:21:34 <akegalj_> int-e: yes
07:22:33 <benzrf> or uh
07:22:34 <benzrf> actually that's wrong
07:22:47 <benzrf> hmm
07:23:05 <benzrf> are there applicative transformers?
07:23:06 <benzrf> :D
07:23:33 <Tekmo> benzrf: Have you tried it out to see what happens?
07:23:40 <benzrf> yeah, i get a type error
07:23:49 <benzrf> because lenses are functions not in a newtype
07:23:50 <benzrf> :I
07:24:04 <Tekmo> Just because it's not in a newtype doesn't mean it's not an Applicative
07:24:16 <benzrf> yes but functions already have an applicative instance
07:24:18 <benzrf> I guess I could use (view _1) instead of _1
07:24:23 <int-e> :t (fix .) . (. (:)) . (.) . map
07:24:24 <lambdabot> (a -> a) -> a -> [a]
07:24:24 <edwardk> benzrf: you can runFold $ (,) <$> Fold _1 <*> Fold _2
07:24:32 <Tekmo> benzrf: Are you sure the function applicative instance is the wrong one?
07:24:36 <benzrf> huh
07:24:38 <benzrf> maybe??
07:24:39 <edwardk> benzrf: but it isn't sound to compose _lenses_ like that
07:24:45 <benzrf> hmm
07:25:05 <benzrf> is there a way to combine applicatives tho
07:25:11 <edwardk> benzrf: what happens when you use _1 twce? now write back and read? what happens with the laws
07:25:19 <Tekmo> benzrf: Data.Functor.Compose
07:25:22 <benzrf> thanks
07:26:04 <benzrf> hmmm
07:26:46 <benzrf> ok, this works :)
07:26:53 <benzrf> thanks
07:27:12 <Tekmo> You're welcome
07:28:29 <Clint> Tekmo: what's the pipes-conduit story?
07:29:39 <vamega> Hi, I'm unable to install the cabal-install tool with ghc 7.8 RC1
07:29:43 <Tekmo> Clint: I haven't worked on it since then
07:29:48 <dennda> lukexi: Nevermind, I think that was due to me interrupting (^C) a previous ARM build and then trying to do an i386 build. A make clean seems to have solved the issue and make && make install ran through.
07:30:05 <vamega> I'm getting errors saying that the base package is missing?
07:30:16 <Tekmo> Clint: Right now I am debianizing `pipes` while waiting for Renzo to upgrade his packages in response to `pipes-parse`
07:30:28 <vamega> Should I be running cabal-install HEAD?
07:31:33 <magicman> Ye gods, cabal update takes forever and a half >_<
07:32:38 <magicman> ... I'm also apprently running a horribly outdated version.
07:42:05 <Clint> Tekmo: yeah, we can't go to pipes 4.1.0 yet because of pipes-zlib i think
07:44:49 * hackagebot hatex-guide 1.3.0.1 - HaTeX User's Guide.  http://hackage.haskell.org/package/hatex-guide-1.3.0.1 (DanielDiaz)
07:47:58 <dennda> Should I just ignore that? https://gist.github.com/dennda/f636b39432b849043e8b
07:48:42 <Clint> Tekmo: er, i just saw your ITP.. pipes is already in debian
07:49:49 * hackagebot processing 1.2.0.1 - Web graphic applications with processing.js.  http://hackage.haskell.org/package/processing-1.2.0.1 (DanielDiaz)
07:51:16 <dennda> Aaaaand it does break the build.
07:57:42 <maxiepoo> can somebody help with these linker errors: http://lpaste.net/99442 ?
07:59:00 <dennda> lukexi: Got my haskell code running in the iOS simulator. Hooray. I think those instructions are way too involved though and am hoping it'll be possible to conflate them.
08:01:15 <supki> maxiepoo: can you paste the .cabal file too?
08:01:32 <dennda> http://the-space-station.com/~dennda/screenshots/screenshot_6294D1D4-DF4A-4A51-8C88-F683292C9E04.png
08:01:36 <dennda> :)
08:02:13 <maxiepoo> supki, updated
08:04:16 <supki> maxiepoo: I think it's a missing xss-sanitize dependency
08:05:04 <supki> the source apparently calls some function from that package, but .cabal file does not list it as a dependency
08:05:36 <maxiepoo> supki, the thing is that none of the dependencies depend on xss-sanitize
08:06:33 <maxiepoo> the only dependency that would make sense is `markdown` which I tried out a while ago on a different branch but not this one
08:07:21 <benzrf> ok...
08:07:33 <benzrf> why the hell aren't the monoid newtypes for Maybe functor/applicative instances!?
08:07:50 <dennda> lukexi: Let me know when you're around, por favor. :-)
08:08:31 <Sculptor> g'day
08:08:40 <benzrf> hmm
08:09:12 <benzrf> would it be appropriate to do 'fappend = dimap getFirst First mappend'
08:09:52 * hackagebot stunclient 0.1.0.1 - RFC 5389: Session Traversal Utilities for NAT (STUN) client  http://hackage.haskell.org/package/stunclient-0.1.0.1 (PhilippBalzarek)
08:11:01 <troydm> benzrf: you called a function fappend? rly?
08:11:05 <benzrf> oh shit
08:11:09 <benzrf> so not on purpose -.-
08:11:15 <troydm> lol
08:11:17 <benzrf> also i messed up that dimap
08:17:05 <Tekmo> :t (<>~)
08:17:06 <lambdabot> Monoid a => ASetter s t a a -> a -> s -> t
08:17:25 <Tekmo> I think you can use `(<>~)` to replace fappend
08:17:30 <benzrf> o_o
08:17:40 <benzrf> that operator looks like a virus
08:17:43 <Tekmo> You ca pass it an `Iso` for `First/getFirst` and then it probably does the right thing
08:17:55 <Tekmo> You hurt that operator's feelings
08:17:58 <benzrf> :-D
08:18:08 <benzrf> what is staa exactly again?
08:18:15 <benzrf> it takes an s and replaces an a with an a?
08:18:26 <Tekmo> :t iso
08:18:27 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
08:18:34 <Tekmo> :t iso First getFirst
08:18:34 <lambdabot> (Functor f, Profunctor p) => p (First a) (f (First a1)) -> p (Maybe a) (f (Maybe a1))
08:18:42 <Tekmo> :t iso getFirst First
08:18:43 <lambdabot> (Functor f, Profunctor p) => p (Maybe a) (f (Maybe a1)) -> p (First a) (f (First a1))
08:18:51 <benzrf> @hoogle Iso' Maybe First
08:18:51 <lambdabot> Did you mean: :: Iso' (Maybe a) (First a)
08:18:51 <lambdabot> No results found
08:18:52 <Tekmo> :t (iso getFirst First <>~)
08:18:53 <lambdabot> Monoid a => Maybe a -> First a -> First a
08:18:58 <Tekmo> There you go
08:19:04 <Tekmo> That's the function you want, I think
08:19:16 <benzrf> im just gonna do
08:19:16 <benzrf> fmappend = getFirst . (mappend <$> First <*> First)
08:19:33 <benzrf> wait
08:19:39 <benzrf> :t mappend <$> First <*> First
08:19:40 <lambdabot> Maybe a -> First a
08:19:50 <benzrf> hmmm
08:19:53 * hackagebot idris 0.9.11 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.11 (EdwinBrady)
08:19:54 <Tekmo> That's the function applicative
08:19:57 <benzrf> yeah
08:19:58 <benzrf> my intent
08:20:11 <benzrf> oh wait
08:20:18 <quicksilver> @pl x y -> mappend <$> getFirst x <*> getFirst y
08:20:18 <lambdabot> (line 1, column 7):
08:20:18 <lambdabot> unexpected '>'
08:20:18 <lambdabot> expecting operator
08:20:21 <benzrf> argh
08:20:26 <quicksilver> @pl \x y -> mappend <$> getFirst x <*> getFirst y
08:20:26 <lambdabot> ((mappend <$>) .) . (. getFirst) . (<*>) . getFirst
08:20:31 <quicksilver> that's what you wanted I think benzrf
08:20:36 <quicksilver> but it is neater Tekmo's way :)
08:20:46 <benzrf> wait hm
08:21:11 <benzrf> :t (<*>) `asAppliedTo` (undefined :: a -> b)
08:21:12 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
08:21:18 <benzrf> hmm
08:21:24 <benzrf> ohhh right
08:21:31 <benzrf> derp, I was thinking wrong
08:21:32 <benzrf> <_>
08:22:12 <benzrf> I want to mappend maybes as though they are firsts basically
08:22:15 <benzrf> not the other way around :u
08:22:43 <benzrf> @pl \a b -> getFirst $ mappend (First a) (First b)
08:22:43 <lambdabot> (getFirst .) . (. First) . mappend . First
08:22:48 <benzrf> ick
08:23:02 <benzrf> i feel like there is a more elegant way than that o-O
08:23:10 <quicksilver> there is
08:23:12 <quicksilver> tekmo's way :)
08:23:18 <benzrf> but i dont understand it T_T
08:23:22 <benzrf> and right now i cba
08:23:26 <benzrf> maybe i will come back to it
08:23:30 <benzrf> w/e points wont kill me
08:23:35 <quicksilver> you need the machinery of lens and iso to really nicely abstrat over two parameters
08:26:30 <johnw> if we had ala2 First mappend, that would do it
08:27:42 <benzrf> what is ala2?
08:28:13 <johnw> ala over two parameters; it doesn't exist
08:29:28 <andresrtm> hi everyone, there a lib to generate pure XML as Blaze ?
08:29:40 <mm_bureau> is there a good pure-haskell library for matrix transformations?
08:29:54 * hackagebot fixed-vector 0.6.1.1 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.1.1 (AlexeyKhudyakov)
08:29:56 * hackagebot scyther-proof 0.8.0.0 - Automatic generation of Isabelle/HOL correctness proofs  for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.8.0.0 (lochbihl)
08:29:58 * hackagebot histogram-fill 0.8.2.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.2.0 (AlexeyKhudyakov)
08:30:00 * hackagebot mwc-random 0.13.1.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.1.1 (AlexeyKhudyakov)
08:30:10 <mm_bureau> mainly interested in 4x4 matrices with 3D translation, rotation and (perspective) projection
08:31:07 <ocharles> mm_bureau: linear has rotation and translation covered, but not perspective matrix construction
08:31:34 <ocharles> ed might be open to including perspective and orthographic matrix construction
08:32:46 <Redz> hello, how do i get this running:
08:32:47 <Redz> mapt2 f (x,y) (x2,y2) = (f x x2, f y y2)
08:32:47 <Redz> instance (Num a, Num b) => Num (a,b) where (+) = mapt2 (+)
08:32:47 <Redz> i guess that i need forall or something or maybe that it doesn't work at all.
08:33:38 <benzrf> > fmap (+1) (1, 2)
08:33:40 <lambdabot>  (1,3)
08:33:45 <benzrf> ^just use that
08:34:34 <benzrf> (<+>) = liftA2 (+)
08:34:40 <benzrf> @let (<+>) = liftA2 (+)
08:34:40 <ion> > let f :: (Num b, Num c) => (forall a. Num a => a -> a -> a) -> (b, c) -> (b, c) -> (b, c); f op (a,b) = (op a, op b) in f (+) (1,2) (3,4)
08:34:41 <lambdabot>  .L.hs:144:9:
08:34:41 <lambdabot>      No instance for (Applicative f0) arising from a use of `liftA2'
08:34:41 <lambdabot>      The type variable `f0' is ambiguous
08:34:41 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
08:34:41 <lambdabot>        L.<+> :: f0 Integer -> f0 Integer -> f0 Integer
08:34:43 <lambdabot>  Couldn't match expected type `(b, c) -> (b, c)'
08:34:45 <benzrf> woah
08:34:45 <lambdabot>              with actual type `(b -> b, c -> c)'
08:34:47 <benzrf> oh dang it
08:35:03 <benzrf> > let (<+>) = liftA2 (+) in (1, 2) <+> (3, 4)
08:35:04 <lambdabot>  No instance for (Data.Monoid.Monoid t0)
08:35:04 <lambdabot>    arising from a use of `e_121234'
08:35:04 <lambdabot>  The type variable `t0' is ambiguous
08:35:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:35:04 <lambdabot>  Note: there are several potential instances:
08:35:09 <benzrf> wat
08:35:17 <bergey> mm_bureau: There are some additional functions in GLUtil that construct projection matrices with the types from linear: http://hackage.haskell.org/package/GLUtil-0.7.4/docs/Graphics-GLUtil-Camera3D.html
08:35:41 <pranz> > (+) <$> (1,2) <*> (3,4)
08:35:42 <lambdabot>  No instance for (Data.Monoid.Monoid t0)
08:35:42 <lambdabot>    arising from a use of `e_11234'
08:35:42 <lambdabot>  The type variable `t0' is ambiguous
08:35:42 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:35:42 <lambdabot>  Note: there are several potential instances:
08:35:49 <benzrf> where the hell are monoids coming from
08:35:52 <ion>  let f :: (Num b, Num c) => (forall a. Num a => a -> a -> a) -> (b, c) -> (b, c) -> (b, c); f op (a,b) (a',b') = (op a a', op b b') in f (+) (1,2) (3,4)
08:35:56 <ion> > let f :: (Num b, Num c) => (forall a. Num a => a -> a -> a) -> (b, c) -> (b, c) -> (b, c); f op (a,b) (a',b') = (op a a', op b b') in f (+) (1,2) (3,4)
08:35:57 <lambdabot>  (4,6)
08:36:06 <ocharles> benzrf: isn't (a,b) a writer monad/applicative, which needs applicative?
08:36:20 <benzrf> ocharles: no, writer is a newtype iirc
08:36:25 <benzrf> oh wait
08:36:27 <ocharles> I don't think so...
08:36:28 <benzrf> i think you may be right o:
08:36:37 <andresrtm> is there a lib to generate pure XML as Blaze ?
08:38:32 <mm_bureau> ocharles: yeah, i'm using linear already
08:38:35 <mm_bureau> bergey: thanks
08:39:25 <benzrf> thanks all
08:39:27 <benzrf> :)
08:39:52 <exicer_> Using Aeson, is there a way of adding two objects together ?
08:40:38 <mm_bureau> andresrtm: you can use blaze-markup
08:40:39 <ocharles> exicer_: you mean a union of them?
08:40:56 <ocharles> exicer_: {"a":1} + {"b":2} + {"a":1, "b":2} ?
08:41:39 <supki> maxiepoo: did you solve the problem?
08:41:42 <ocharles> exicer_: if so, Data.HashMap.union is exactly what you're looking for
08:41:49 <ocharles> (probably exactly)
08:41:49 <supki> maxiepoo: if not, do you have a link to sources you're trying to build?
08:42:00 <andresrtm> mm_bureau: i'm going to check
08:42:41 <mm_bureau> Declaration for velocityByKey_$dApplicative: Iface type variable out of scope:  a
08:42:45 <mm_bureau> what's this error?
08:43:56 <mm_bureau> deleting the dist directory and rebuilding fixed it
08:43:59 <mm_bureau> is this a GHC bug?
08:44:51 <ocharles> the #ghc guys may be able to shed more light on that
08:48:11 <epta> does anyone use travis multi-ghc? do you need 7.8-rc1?
08:48:31 <exicer_> oco
08:48:41 <hub2> Hi, Have you ever made some server API for web or mobile apps in Haskell?
08:48:52 <exicer_> ocharles: Yes, that is exactly what I want. Thanks :)
08:54:13 <mm_bureau> math question: say i have a rotation matrix, but it's the product of many individual rotations, is there a way to normalize away rounding errors?
08:55:19 <maxiepoo> supki, I fixed it by recloning the git repo, not sure what the problem was
09:02:16 <kazagistar> I am trying to figure out how to implement something like (count :: [a] -> (a -> a -> Bool) -> Map a Int) but I am wondering if I am approaching the problem wrong
09:03:42 <DMcGill> Can Criterion do memory profile comparisons?
09:04:42 <S11001001> kazagistar: what are the laws of your second argument?
09:04:58 * hackagebot numbers 3000.2.0.1 - Various number types  http://hackage.haskell.org/package/numbers-3000.2.0.1 (JohnWiegley)
09:06:01 <merijn> johnw: version 3000? o.O
09:06:11 <kazagistar> S11001001, its something like an equality comparison, like groupBy
09:06:13 <johnw> haha, I inherited the versioning scheme :)
09:06:58 <S11001001> kazagistar: it can't be an equality comparison
09:09:00 <kazagistar> S11001001, why not? (==) :: (a -> a -> Bool), right?
09:09:33 <quchen> :t (==)
09:09:33 <lambdabot> Eq a => a -> a -> Bool
09:09:59 * hackagebot bindings-DSL 1.0.21 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.21 (JohnWiegley)
09:10:00 <maxiepoo> kazagistar, what is the second argument for?
09:10:07 <S11001001> kazagistar: that's true.  But it doesn't give you enough information to form a coherent Map.
09:10:48 <mm_bureau> kazagistar: how about:  count :: (Ord a) => [a] -> Map a Int
09:11:00 <quchen> count = countBy (==)
09:11:48 <kazagistar> Oh, I see, because it would only keep one of the items, and which one would be arbitrary
09:12:44 <mm_bureau> kazagistar: depends on whether you want equality or just equivalence
09:12:52 <kazagistar> hmm, I guess I am being dumb about what I am getting out
09:12:57 <mm_bureau> equality is the kind of thing 'deriving (Eq)' gives you
09:13:08 <S11001001> kazagistar: Looking up a key in a map relies on the fact that the keys are ordered in the tree.  So for that 'Map a Int' to be useful, the 'a's must be ordered.  You can't derive an ordering from equality.
09:13:25 <mm_bureau> but it could be horribly confusing of your count's argument disagrees with Ord's equivalence relation
09:13:29 <exicer_> ocharles: I don't suppose you know of an easy way of getting the union of two Aeson Values  ?
09:13:37 <mm_bureau> s/of/if/
09:14:41 <bartavelle> exicer_, it will only make sense for a sub-part of the possible 'Value's
09:15:44 <exicer_> bartavelle: Ah true. So I guess I have to decode them in some roundabout fashion?
09:16:21 <kazagistar> I think I understand what I am doing wrong. what I actually want out is going to be something like [a] -> Int -> HashMap a (HashMap a (HashMap a.. <Int number of times> HashMap a Int)))), cause I am doing ngrams
09:16:33 <bartavelle> exicer_, I would write a "case (valuea, valueb) of" and enumerate the cases that make sense I suppose
09:16:54 <bartavelle> (you might want to treat Null as mempty or something)
09:17:31 <exicer_> bartavelle: For some reason I did not think that I could do this with aeson values.. doh. Sounds good!
09:18:38 <kazagistar> er, make that [[a]] -> Int -> HashMap...
09:19:28 <Hulk{-_-}> Is there a way to add haskell executables in one's gitignore?
09:19:59 <merijn> Hulk{-_-}: Same way you add any executable to gitignore?
09:20:00 <Hulk{-_-}> or how should one best separate code from whetever we get after compiling.
09:20:26 <merijn> Hulk{-_-}: cabal (by default) puts everything into a "dist" subdirectory of your working directory
09:21:01 <merijn> Hulk{-_-}: I just have "dist" in my .hgignore
09:21:15 <merijn> Hulk{-_-}: And if you're not using cabal yet, now sounds about the time ;)
09:21:40 <Hulk{-_-}> merijn: Yeah I am not using cabal yet
09:23:45 <merijn> Hulk{-_-}: "cabal init" will produce an interactive basic config, from there you should be able to use it with minimal use of the manual
09:24:01 <winobes> is anyone here good at xmonad?
09:24:18 <Hulk{-_-}> I was thinking of ignoring everything but my .hs files
09:24:20 <hakujin> first cabal command for a new project: cabal sandbox init
09:24:37 <S11001001> Hulk{-_-}: that doesn't sound good
09:24:41 <benzrf> @hoogle (a -> a) -> (a -> Bool) -> a -> a
09:24:42 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:24:42 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
09:24:42 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
09:24:48 <benzrf> neat
09:24:51 <benzrf> how convenient :>
09:24:56 <Hulk{-_-}> merijn: Uh cabal seems like it's for people doing lots of stuff. All I am doing are questions from learn you a haskell and 99 problems in haskell.
09:25:13 <Hulk{-_-}> merijn: Would it be appropriate for that too?
09:25:30 <Hulk{-_-}> S11001001: Why do you think so?
09:26:04 <merijn> Hulk{-_-}: cabal does things like track dependencies and control compilation flags, etc. if you don't need any of that you can just leave all the defaults for cabal. Or you could just put all of your exercises in a single file, that might be even easier
09:26:42 <Hulk{-_-}> merijn: No I want them across different files so I guess I will use cabal
09:27:06 <Hulk{-_-}> merijn: It will be good for experience too I guess
09:27:30 <benzrf> :t fix
09:27:31 <lambdabot> (a -> a) -> a
09:27:33 <benzrf> cool
09:28:09 <benzrf> @hoogle (a -> a) -> a -> a
09:28:10 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
09:28:10 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
09:28:10 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:28:13 <benzrf> hmm
09:28:24 <benzrf> is there something like until that stops when there is no more modification
09:30:34 <dgpratt> attempting to build a project in a cabal sandbox and I get: * Missing C library: png (this is on Windows, btw)
09:30:46 <benzrf> i.e. `hypothetical abs (-3)' => 3
09:30:51 <benzrf> bad example >_>
09:30:56 <benzrf> w/e ill implement it myself
09:31:02 <dgpratt> now I believe I can get the relevant lib for Windows (in fact it's already installed)
09:31:03 <merijn> dgpratt: Did you specify the location of libpng when you ran "cabal configure"?
09:31:18 <dgpratt> merijn, I did not
09:31:30 <dgpratt> in fact, I didn't run cabal configure :)
09:31:33 <merijn> dgpratt: There is a library/include path flag for cabal configure
09:31:46 <merijn> It's list in "cabal configure --help"
09:31:52 <dgpratt> ok, I'll give that a go, thanks merijn
09:32:28 <quchen> benzrf: I don't think there's a default function for that
09:32:46 <quchen> benzrf: http://lpaste.net/99444
09:32:55 <benzrf> already wrote it
09:33:07 <benzrf> @pl w f v = if f v == v then v else w (f v)
09:33:07 <lambdabot> w = fix (ap (ap . join . (if' .) . ((==) =<<)) . (.))
09:33:10 <benzrf> ew
09:34:02 <dgpratt> that worked, thanks merijn :)
09:35:29 <dgpratt> well, I should qualify: it built :)
09:35:49 <merijn> :p
09:36:08 <Rylee> @src if'
09:36:08 <lambdabot> Source not found. :(
09:36:12 <mangaba_leitosa> x
09:36:40 <Walther> Hmm. Is there anything php/ror/django/etc ish in Haskell? I know of Hakyll, but that's a different type of a hammer
09:37:19 <Walther> But ypuknow, writing a "webapp" in Haskell
09:38:17 <benzrf> Walther: happstack, snap, yesod
09:38:18 <felixsch> Walther: http://www.haskell.org/haskellwiki/Web/Frameworks
09:38:34 <Walther> Ooooh. Thanks!
09:39:00 <maxiepoo> is there a way to configure yum so when it installs, say xmonad it doesn't pollute my global package db?
09:40:02 <hakujin> Walther: on the other side of that coin, Scotty is a Sinatra inspired fairly unopinionated framework
09:42:06 <Hulk{-_-}> Though at which point should one start using cabal? As one learns or after one feels comfortable with haskell?
09:42:38 <hakujin> Hulk{-_-}: are you writing small functions only using the prelude or haskell platform included libraries?
09:42:48 <merijn> Hulk{-_-}: Once your "ghc Foo.hs Bar.hs Baz.hs" command line becomes so annoying that you'd rather config cabal once and type "cabal build" to compile instead
09:43:01 <maxiepoo> Hulk{-_-}, as soon as you start using a lot of packages that aren't in haskell-platform
09:43:30 <hakujin> aka, have you ever typed "cabal install x"
09:43:33 <Hulk{-_-}> hakujin: Well I am writing small .hs files that are not dependent on each other.
09:43:42 <hakujin> if so -> use cabal if only for the sandboxes
09:43:56 <merijn> Is there some way to get *all* extension parts of a filepath?
09:44:19 <merijn> i.e. 'System.FilePath.takeExtension "foo.tar.gz"' returns '.gz', not '.tar.gz'
09:44:39 <Hulk{-_-}> merijn: lol so when I am angry enough to use cabal.
09:44:59 <Hulk{-_-}> maxiepoo: Currently everything I am using is in haskell platform.
09:45:25 <merijn> Hulk{-_-}: tbh, it's not that hard to config cabal, so nowadays I just use it immediately when I have more than 1 file :)
09:46:06 <Hulk{-_-}> merijn: and cabal will work perfectly in parallel with git?
09:46:31 <Hulk{-_-}> merijn: Your talk of a dist directory was kinda confusing.
09:46:34 <merijn> Hulk{-_-}: cabal is just a build tool (think of make/autotools, but less sucky)
09:46:58 <Hulk{-_-}> merijn: AH! I thought it was some form of version control.
09:47:07 <merijn> Hulk{-_-}: When it compiles things for you, it stores the .o/.hi/etc files in the "dist" directory so your working directory doesn't get polluted
09:47:21 <Hulk{-_-}> merijn: Since you talked about it when I asked a question involving git
09:47:29 <merijn> Hulk{-_-}: Nope, just building, you can use it with whatever version control you like
09:47:45 <Hulk{-_-}> merijn: Ah cabal sounds awesome!
09:47:58 <merijn> Hulk{-_-}: There is a haskell version control system (darcs), but no point in learning that if you are already comfortable with git
09:48:00 <bitemyapp> I don't think I could compare Cabal with Make.
09:48:06 <bitemyapp> I use Makefiles in my Haskell projects.
09:48:33 <merijn> Hulk{-_-}: (Well, maybe there's a little reason to learn darcs, but I wouldn't worry about that :p)
09:48:33 <merijn> bitemyapp: For what?
09:48:35 <Hulk{-_-}> bitemyapp: Make is foss right?
09:48:49 <Hulk{-_-}> LYAH uses makefiles
09:48:49 <bitemyapp> Cabal is more like npm, sbt, Leiningen, pip+requirements.txt, setup.py, RVM + Gemfiles than Make.
09:48:55 <vyorkin> :t map
09:48:56 <lambdabot> (a -> b) -> [a] -> [b]
09:48:58 <bitemyapp> Hulk{-_-}: is that a serious question?
09:49:27 <Hulk{-_-}> Makefiles are good because you apply them over different languages.
09:49:31 <merijn> bitemyapp: Not really, those things are package managers that can uninstall
09:50:09 <rola> whoa
09:50:09 <supki> > "foo.tar.gz" ^. backwards (takingWhile (not . null) (iterated (view System.FilePath.Lens.basename) . extension))
09:50:10 <bitemyapp> merijn: setup.py + easy_install can't uninstall.
09:50:10 <lambdabot>  ".tar.gz"
09:50:18 <supki> hey
09:50:22 <bitemyapp> merijn: Leiningen can't/doesn't/doesn't need to either.
09:50:28 <merijn> bitemyapp: cabal is really just a build tool, albeit a one that is fairly elaborate and well integrated with ghc
09:50:28 <merijn> supki: Found it, apparently there is also "takeExtensions" (note extra 's' compared with takeExtension) :p
09:50:37 <supki> merijn: how boring
09:50:37 <bitemyapp> merijn: Cabal is primarily for package/dependency resolution and building. Same as Leiningen. Same as SBT. Same as pip + setup.py
09:50:49 <bitemyapp> merijn: it's decidedly not a "build tool" in the mold of Make.
09:51:06 <merijn> supki: But impressive work :p
09:51:18 <bitemyapp> supki: yeah that's really cool :)
09:51:25 <supki> :)
09:51:38 <merijn> > System.FilePath.takeExtensions "foo.tar.gz"
09:51:39 <lambdabot>  Not in scope: `System.FilePath.takeExtensions'
09:51:39 <lambdabot>  Perhaps you meant `System.FilePath.Lens.extension' (imported from System.Fil...
09:51:42 <merijn> aww
09:52:09 <bitemyapp> anyway like I was saying, I use Make with my Haskell projects, mostly for automation.
09:52:24 <bitemyapp> I like writing Make better than straight-up bash and it's equally universal.
09:52:25 <Hulk{-_-}> Thinking of a haskell project for GSoC but everything I try feels too advanced. :(
09:52:31 <DMcGill> `boundedMax = foldMap (maybe negInfty negFinite) :: (Foldable f, Ord a) => f (Maybe a) -> NegInf a'
09:52:40 <DMcGill> is that the correct use? It seems to work
09:52:41 <bitemyapp> Hulk{-_-}: I'm pretty sure going for it is how you learn more Haskell.
09:53:16 <DMcGill> ekmett's Data.Semigroup doesn't have BoundedMax - you're supposed to use Option (Max a) instead but that doesn't work when you have Maybes that you want to treat as neg inf :(
09:53:22 <Hulk{-_-}> bitemyapp: The being universal of make is what will most probably have me using makefiles instead.
09:53:26 <DMcGill> because there is no Bounded instance for Option a
09:54:19 <triliyn> DMcGill: you can write your own instances
09:54:45 <defanor> where could i read about idiomatic ways of composing messages (network packets, files of specified format, etc) in haskell?
09:55:19 <bitemyapp> Hulk{-_-}: instead of what?
09:55:20 <edwardk> DMcGill: you can make new semigroups you know ;)
09:55:20 <defanor> and is there some nice way to describe format once, for both parsing and composition?
09:56:04 <edwardk> the problem with Bounded (Option a) is is Nothing minimal or maximal?
09:56:33 <DMcGill> edwardk, triliyn: but think of the orphans! Nah I'll do that. It's about the same as making some 'fromFinite' function that's essentially the same as 'fromMaybe'
09:56:39 <edwardk> conal's old reactive used to have separate types for adding a Inf, NegInf or both
09:56:56 <merijn> bitemyapp: That doesn't really answer my question of what you use make for, though?
09:57:47 <edwardk> DMcGill: in http://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Ord.html i had MaxPriority and MinPriority, but it predates semigroups
09:58:00 <bitemyapp> merijn: I'm really lazy and don't like typing.
09:58:13 <bitemyapp> merijn: make deps will generally cabal install --only-dependencies - that sort of thing.
09:59:13 <DMcGill> huh, using `foldMap (maybe negInfty negFinite) ' turned out to be much much slower than `foldl' max emptySoln $ catMaybes $ V.toList'
09:59:24 <DMcGill> time to add some strictness!
10:02:00 <studmuf> I'm struggling to see how the function for this type declaration would look.
10:02:10 <studmuf> size :: BST k v -> Int
10:02:22 <studmuf> Any help is appreciated
10:03:41 <merijn> studmuf: "size _ = 1", in all seriousness, though, we don't know what "BST k v" is or what it's supposed to do
10:04:02 <fryguybob> DMcGill: There is also monoid-extras, don't know if that helps you: https://hackage.haskell.org/package/monoid-extras-0.3.2.4/docs/Data-Monoid-Inf.html
10:04:17 <studmuf> merijn: Sorry it returns the size of a Binary Search Tree
10:04:24 <merijn> studmuf: I'm guessing it's a binary search tree of some kind?
10:04:25 <ReinH> pretty easy to write your own tropical/arctic monoid
10:04:25 <studmuf> where k is the key
10:04:29 <studmuf> and v the value
10:04:33 <ReinH> data Min a =
10:04:35 <ReinH> er
10:04:36 <ReinH> er
10:04:41 <ReinH> wtf irc :(
10:05:05 <DMcGill> fryguybob: that's what I'm using in lieu of making my own instance for Max (Option a) but it's 3 times as slow as using `max . catMaybes Data.Vector.toList'!
10:05:21 <fryguybob> DMcGill: :(
10:05:44 <Adson102> hi i'm trying now to run haskellbot (from haskell wiki) i've downloaded Hugs and i have file 1.hs as in tutorial with source code of bot, how to run it ? :P
10:05:51 <merijn> studmuf: Right, since this is probably homework, I'll give you a clue using a different type, suppose we have a list datatype like "data List a = Nil | Cons a (List a)", we would write "size :: List a -> Int; size Nil = 0; size (Cons _ tail) = {- do something recursive -}"
10:06:06 <DMcGill> happily by just making my own `maxMaybe :: Ord a => a -> Maybe a -> a', V.foldl' maxMaybe is much faster!
10:06:30 <ReinH> data Min a = Min !a | NoMin; instance Ord a => Monoid Min a where mempty = NoMin; ...
10:06:30 <DMcGill> I might make my own strict boundedMax monoid but I suspect just defining maxMaybe will be much shorter overall
10:06:36 <merijn> studmuf: Similarly, for a BST you will want to have one case for every possible constructor and do something recursive based on those constructors
10:06:41 <DMcGill> ReinH: :)
10:07:16 <ownclo> @quote lambda
10:07:16 <lambdabot> dons says: not sure that the irc culture outside happy lambda land is always so warm and tropical
10:07:27 <merijn> studmuf: If you're stuck, try solving the list version first, and once you have that, try to generalise it too a tree
10:09:05 <ReinH> DMcGill: in lots of real world scenarios you can just use bounds: foldl' max minBound is arctic, foldl' min maxBound is tropical
10:09:51 <DMcGill> ReinH: I don't understand what you mean by "arctic" or "tropical". Are they math terms?
10:09:59 <ReinH> DMcGill: yes :)
10:10:18 <ReinH> DMcGill: http://en.wikipedia.org/wiki/Tropical_geometry
10:10:34 <bitemyapp> DMcGill: you think that's good, I was reading about magma last night.
10:11:23 <ReinH> DMcGill: also check out http://r6.ca/blog/20110808T035622Z.html
10:12:49 <merijn> @hoogle Bool -> (a -> a) -> a -> a
10:12:49 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:12:49 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:12:49 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
10:13:21 <merijn> Any functions like that that I can conveniently use?
10:14:06 <DMcGill> what behaviour do you want? ifF True f a = f a; ifF False _ a = a?
10:15:08 * hackagebot idris 0.9.11.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.11.1 (EdwinBrady)
10:15:38 <merijn> DMcGill: Yeah
10:17:10 <DMcGill> You could try for something clever (read: needlessly complicated) with Endo perhaps
10:17:31 <DMcGill> (if b then Endo f else mempty) a
10:17:46 <DMcGill> but you might as well just do (if b then f a else a)
10:18:18 <DMcGill> or `(if b then f else id) a'
10:19:00 <merijn> DMcGill: Yeah, but I was writing "item <- if conditionHere then f a else a" which looks a bit ugly
10:20:05 <ReinH> :t bool
10:20:05 <lambdabot> Not in scope: `bool'
10:25:11 * hackagebot free 4.5 - Monads for free  http://hackage.haskell.org/package/free-4.5 (EdwardKmett)
10:26:16 <Walther> Hmm. Is there some logic behind why the Happstack (lite) tutorial seems to use literate haskell (there's > at start every line)?
10:26:49 <stepkut> Walther: because it was written using markdown+lhs
10:27:20 <stepkut> Walther: I have better build technology now and could 'fix' that
10:27:52 <Walther> Hmm, <3 markdown though.
10:28:19 <stepkut> the whole crash course is written in markdown+lhs
10:28:32 <stepkut> but using pandoc and some other magic to export to html, pdf, epub, etc
10:28:42 <stepkut> and to extract the code examples
10:36:55 <Walther> Hmm. Happstack lite intro also seems to hardcode the example page in a bit of an unwieldly way; does Happstack support markdown compilation (e.g. pandoc) similar to Hakyll?
10:37:32 <Walther> I find it hard to believe this would actually require typing stuff like "H.p $ a ! href "/query?foo=bar" $ "query parameters"" all the time :P
10:37:35 <Javran> is that possible to define a `data Foo a = Foo [a]` that requires the list of exactly size 5? I don't want to use tuples.
10:37:44 <DMcGill> @pl maxMaybe2 s sM = (maybe id max sM) s
10:37:44 <lambdabot> maxMaybe2 = flip (maybe id max)
10:38:20 <merijn> Javran: Not really, the usual approach would be as follows
10:39:22 <merijn> Javran: "newtype FiveList a = FiveList [a]; makeFiveList :: [a] -> Maybe (FiveList a); makeFiveList xs = if length xs == 5 then Just (FiveList xs) else Nothing"
10:39:47 <merijn> Javran: Then, if you don't export the FiveList constructor, people are forced to use makeFiveList, thus enforcing correctness
10:40:05 <Javran> merijn: got it, now I can hide FiveList from outside
10:40:29 <merijn> Javran: Right
10:40:50 <Javran> merijn: thank you!
10:41:09 <supki> Walther: you can use whatever templating package you want; blaze-html is a common one, though
10:41:42 <supki> (I prefer heist, but it's a bit hardcore comparing to blaze-html)
10:42:07 <lukexi> dennda: hi! that's excellent to hear, I very much agree : )) (re instructions) congrats on getting it going!!
10:42:35 <Walther> supki: nod, but even with "ok $ template "home page" $ do" it looks way more verbose to have to type stuff like my previous line compared to e.g. markdown (which is bliss)
10:42:51 <Walther> http://happstack.com/page/view-page-slug/9/happstack-lite#templates
10:48:00 <Benzi-Junior> what is ghc-pkg exactly ?
10:48:04 <xintron> If I create a function in a "where" in my do-block and call it multiple times, will the same calculation be made each time for the same value (or is the value cached somehow)?
10:49:02 <dennda> lukexi: Hey! I was wondering if you could shed some light as to how you're integrating this. My inclination is that you'd use the haskell lib to do the heavy lifting/business logic and to do that call its functions from objc; is that how you do it?
10:49:20 <merijn> Benzi-Junior: ghc-pkg is the interface to interact with the database of installed packages that GHC maintains
10:49:37 <dennda> lukexi: The approach that is shown in the article (making haskell's main run first and then calling c_main) doesn't seem to lend itself to that very much.
10:49:41 <merijn> xintron: The answer is "it depends"
10:49:48 <Benzi-Junior> merijn: thanks
10:49:48 <xintron> :)
10:50:05 <lukexi> dennda: right! using this https://github.com/jspahrsummers/ObjectiveHaskell
10:50:08 <merijn> xintron: if you have "where f x = blahblah" and call "f 5" multiple times in a function body, it *may* be optimised to computing just once
10:50:11 <lukexi> dennda: haha, no, it doesn't
10:50:35 <xintron> merijn, ah, so the compiler may optimize it or may not, there's no way of knowing?
10:50:38 <merijn> xintron: If you want to be sure, GHC guarantees that a value bound to a name (using where/let) will only be evaluated once
10:50:53 <xintron> ok
10:51:04 <merijn> xintron: So if you have "where f x = blahblah; foo = f 5" and you use foo 5 times, "f 5" will only be computed once
10:51:22 <ifthenelse> So if I want to loop through a parameter, evaluate a function with that parameter, and write the result of that paof the s result to a file, then go to the next iteration, is that just a forM_ loop (in a do block)
10:51:32 <lukexi> dennda: but a customized version of that that removes the template haskell, which I haven't had time to clean up and release : / — I'd really like to get the binary of ghc-ios out before moving on to the next level of abstraction : )
10:51:53 <Walther> Gah, these tutorials that are "a literate haskell file" make it insanely hard to copypaste example code from - if you don't want your version to be literate haskell and only copy the code sections. Nothing that I couldn't get over with a good editor, but...
10:52:01 <ParahSailin> merijn: does it ever actually optimize callihng "f 5" multiple times?
10:52:15 <merijn> ParahSailin: I was told that recent GHCs sometimes do
10:52:24 <ifthenelse> forM_ parameters % \p -> do writeFile (show p) . f $ p
10:52:26 <ifthenelse> for instance
10:52:32 <ifthenelse> is that right?
10:52:32 <merijn> ParahSailin: But I didn't investigate further, but afaik the optimisation does exist in GHC
10:52:34 <joelteon> why isn't Functor a superclass of Monad
10:52:44 <merijn> joelteon: Hysterical raisins
10:52:52 <dennda> lukexi: What will you be ultimately shipping? Compiled binaries for the i386/arm version of the cross-compiler?
10:52:55 <merijn> joelteon: Will be fixed in 7.10, see 7.8 release notes and
10:52:58 <merijn> @where amp
10:52:58 <lambdabot> I know nothing about amp.
10:53:00 <merijn> hmm
10:53:04 <bitemyapp> joelteon: just...don't.
10:53:07 <lukexi> dennda: but in essence, it handles converting between objc primitives and haskell types. e.g. NSDictionary->Map, NSString->Text etc.
10:53:14 <merijn> joelteon: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
10:53:42 <lukexi> dennda: yeah, that's the plan. make binary-dist has some problems bundling up the cross compiler sadly or they'd be out right now alongside RC1
10:54:11 <ifthenelse> and then if I want to loop through two parameters, can I chain forM_'s?
10:54:28 <joelteon> Wait does this mean Functor will be a superclass too
10:54:35 <merijn> joelteon: Yes
10:54:38 <joelteon> ok cool
10:54:50 <dennda> lukexi: I suppose your changes to ObjectiveHaskell make it iOS-friendly? The README states that it's OS X only at the moment.
10:54:55 <joelteon> Will Prelude export (<$>)?
10:54:56 <merijn> joelteon: Functor is a superclass of Applicative, so once Applicative is a superclass of Monad, that'll be automatic
10:54:59 <lukexi> dennda: there is also ZeroTH which I've played with as a preprocessor for ObjectiveHaskell to flatten the template haskell bits. it looks like it would work with a bit of tweaking!
10:55:40 <lukexi> dennda: right
10:56:29 <Walther> Hm. Can I have a blaze-html template but still take content from e.g. markdown files? I can't seem to find an example - all the tutorials seem to just have hardcoded contents within the template :F
10:57:39 <dennda> lukexi: Pure curiosity: Do you have a snippet of code that shows the objc/hs interfacing using that?
10:58:04 <merijn> Walther: Why not use pandoc to generate html from markdown and combine that with blaze-html templates?
10:58:08 <lukexi> dennda: I also cabal-ized it. If I have some time later today I think I've got a copy that's clean enough to send along for testing : )
10:58:51 <merijn> Walther: Hakyll just uses pandoc as a library for doing that type of conversion, I don't see why you couldn't use it like that with blaze-html templates either?
10:58:54 <Walther> merijn: that sounds entirely possible, I'm just coming from Hakyll and things are a bit ...different
10:59:09 <dennda> lukexi: Cool! I can give you my email address if that's more convenient for you.
11:00:00 <lukexi> dennda: sure! i'm this name at me.com
11:00:54 <OneEyedWill> Run into this error
11:01:03 <OneEyedWill> Poop> let lst = [(9,"ipsum"),(12,"sit"),(7,"Lorem"),(13,"amet"),(10,"dolor")]
11:01:03 <OneEyedWill> Poop> foldl (\acc (x,y) -> ins x y acc) Empty lst
11:01:03 <OneEyedWill> *** Exception: hw3.hs:(66,1)-(70,38): Non-exhaustive patterns in function ins
11:01:12 <dennda> Let's see.
11:01:26 <DMcGill> what's the definition of 'ins'?
11:01:41 <OneEyedWill>  65 ins :: (Ord k) => k -> v -> BST k v -> BST k v
11:01:41 <OneEyedWill>  66 ins k v Empty = Node k v Empty Empty
11:01:41 <OneEyedWill>  67 ins x y (Node k v l r)
11:01:43 <Walther> merijn: I mean, Hakyll is pretty much *made* for blog-esque sites, and is *really* good at that. I'm just wondering if the content-first goodness from there could be used also within these "webapp" frameworks, instead of having to type those dreary " H.p $ a ! href "/query?foo=bar" $ "query parameters" " every time you want a simple link somewhere
11:01:43 <OneEyedWill>  68     | x == k = (Node x y l r)
11:01:45 <OneEyedWill>  69     | x > k = (Node x y (ins x y l) r)
11:01:47 <OneEyedWill>  70     | x > k = (Node x y l (ins x y r))
11:02:09 <lukexi> dennda: https://github.com/jspahrsummers/ObjectiveHaskell/blob/master/ObjectiveHaskellTests/BridgedObjectTest.hs has some examples
11:02:11 <DMcGill> look carefully at those two guards
11:02:37 <dennda> lukexi: I've sent you an email in the hope that it will find its way into your inbox.
11:02:41 <OneEyedWill> DMcGill: Which two of three are you referring too?
11:02:45 <zett_zelett> Both.
11:02:47 <zett_zelett> Look at both.
11:02:49 <zett_zelett> And compare.
11:02:49 <merijn> OneEyedWill: Please use lpaste for pasting more than 1 line of code
11:03:02 <OneEyedWill> merijn: Will do
11:03:03 <zett_zelett> Oh, both last.
11:03:06 <DMcGill> OneEyedWill: both 69 and 70 have "x > k". One should be "x < k"
11:03:11 <lukexi> dennda: got it : )
11:03:17 <OneEyedWill> haha thanks all
11:03:39 <DMcGill> OneEyesWill: Can you see how the "inexhaustive patterns" caused that error?
11:03:48 <Walther> it's easy to become blind to your own code and not notice even the simplest of mistakes :)
11:03:49 <OneEyedWill> yea
11:04:03 <DMcGill> OneEyedWill: also, compiling with -Wall would have warned of that happening ahead of time
11:04:04 <lukexi> dennda: there's also https://github.com/mchakravarty/language-c-inline which looks insanely cool (and a huge improvement over ObjectiveHaskell) but I haven't had a chance to see if I can get it working on iOS yet (likely via ZeroTH)
11:04:19 <merijn> DMcGill: The "fixed" one will still produce a warning
11:04:30 <OneEyedWill> DMcGill: how do I give the -Wall flag in ghci?
11:04:33 <merijn> DMcGill: The warning only goes away if you use "otherwise" as last clause
11:04:37 <DMcGill> merijn: oh yeah, I bet you could fix that in Agda!
11:04:44 <DMcGill> prove coverage or something
11:04:52 <DMcGill> OneEyedWill: ":set -Wall"
11:05:06 <OneEyedWill> DMcGill: Thanks
11:05:58 <OneEyedWill> merijn: how do you perform the paste command you said to use?
11:06:09 <OneEyedWill> merijn: example would be great
11:06:25 <DMcGill> OneEyedWill: go to lpaste.net
11:06:38 <OneEyedWill> DMcGill: ok
11:06:43 <DMcGill> paste your code and then sekect "#haskell" from the dropdown menu on the right
11:07:10 <DMcGill> that will automatically paste a link to that code in here
11:07:34 <OneEyedWill> DMcGill: Much better system. Thanks
11:08:52 <dennda> lukexi: I'll check it out.
11:09:52 <geekosaur> DMcGill, actually the pastebot has not been announcing for a while
11:09:56 <OneEyedWill> DMcGill: I don't see the link in here?
11:10:04 <geekosaur> (several weeks at least)
11:10:17 <DMcGill> whoops, I guess you'll have to paste it then OneEyedWill
11:10:28 <OneEyedWill> DMcGill: Haha Ok
11:10:55 <OneEyedWill> I'll try to find a work around to pasting code into channel
11:11:43 <OneEyedWill> *the
11:11:48 <DMcGill> OneEyedWill: I meant to paste the link in here
11:11:59 <DMcGill> that way people who want to see your code can, and people that don't don't
11:16:03 <Walther> Hmm. On http://www.haskell.org/haskellwiki/Web/Frameworks none seem as "simple" as e.g. Hakyll as in able to nom markdown files from one folder and spit out html at a domain.tld/dir with templates applied
11:16:15 <xintron> Is this valid: fromIntegral (read a :: Int)?
11:16:45 <Walther> Am I completely wrong, or do those framework "templating engines" such as blaze look ...way more verbose to type than markdown
11:17:14 <Feuerbach> xintron: I think "read a" will probably be enough
11:17:40 <Feuerbach> xintron: fromIntegral in combination with read creates an ambiguity
11:18:20 <ReinH> > fromIntegral (read "1" :: Int) :: Double -- xintron
11:18:21 <lambdabot>  1.0
11:22:01 <dxtr> I'm not sure if this is the correct place to post this; but I'm trying to build a program under openbsd and when it tries to link gnuidn it complains about about double symbols (http://lpaste.net/99449). I've tried googling it, found two links on StackOverflow but they didn't help me that much even though I tried what they said
11:22:29 <dxtr> I'm at a loss here
11:23:29 <samwise__> Hello I was wondering if someone could explain 'return ' inany context?
11:23:46 <OneEyedWill> Positive I don't understand how to use instance's. This is my attempt at Show for a BST http://lpaste.net/99450
11:23:49 <byorgey> samwise__: what do you mean, "in any context"?
11:24:00 <byorgey> @type return
11:24:01 <lambdabot> Monad m => a -> m a
11:24:16 <samwise__> byorgey: in any way it can be used ..any situation ,etc etc
11:24:19 <OneEyedWill> Could someone take a look and put me on the right path please
11:24:34 <byorgey> there's not much to explain beyond the type.  return takes a value of type 'a' and wraps it up into a monadic action of type  'm a'.
11:24:54 <geekosaur> samwise__, if you are starting from the theory that it behaves like the keyword in c / java / python / perl / etc., stop now
11:24:58 <geekosaur> it's an ordinary function
11:25:05 <geekosaur> it has nothing whatsoever to do with flow of control
11:25:11 <samwise__> byorgey: in LYAH , return comes before monads
11:25:24 <samwise__> geekosaur: yep, knew that
11:25:29 <byorgey> samwise__: it does?
11:26:17 <samwise__> byorgey: chapter 9 :I/o chaper 11:monads
11:26:34 <byorgey> samwise__: oh, so that's just the special case   return :: a -> IO a
11:26:50 <byorgey> which is an instance of   return :: Monad m => a -> m a,  where  m = IO
11:27:09 <Benzi-Junior> can I add a repository to Cabal-Install ?
11:27:20 <pranz> > [x*2 | x <- [1,2,3]]
11:27:22 <lambdabot>  [2,4,6]
11:28:01 <byorgey> OneEyedWill: what is the type of 'v' ?
11:28:26 <dhrosa> < return 2 :: [Int]
11:28:33 <dhrosa> > return 2 :: [Int]
11:28:34 <lambdabot>  [2]
11:28:43 <dhrosa> > return 2 :: Maybe Int
11:28:44 <lambdabot>  Just 2
11:29:04 <dhrosa> samwise__: it takes a value, and returns it in a monadic context, which means different things depending on the Monad
11:29:14 <dhrosa> > return 2 :: Either String Int
11:29:15 <lambdabot>  Right 2
11:29:44 <dhrosa> return 2 :: State Int ()
11:29:47 <dhrosa> > return 2 :: State Int ()
11:29:48 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal `2'
11:29:48 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num ())
11:29:51 <dhrosa> :(
11:30:11 <OneEyedWill> byorgey: It can be any. Which is why I was think I need to convert whatever the value is at v to a String
11:30:26 <byorgey> OneEyedWill: indeed.
11:30:46 <ReinH> :t return 2 :: State () Int
11:30:47 <lambdabot> State () Int
11:30:59 <ReinH> dhrosa: you got the type params backwards
11:31:03 <dhrosa> oops
11:31:27 <OneEyedWill> byorgey: i'd just use show v right?
11:31:35 <byorgey> OneEyedWill: yes
11:31:43 <OneEyedWill> byorgey: Sweet thanks
11:32:48 <byorgey> OneEyedWill: (by the way, did you know that GHC can generate Show instances for you? --- though if you're just doing this as a learning exercise that's fine)
11:33:34 <OneEyedWill> byorgey: I did know that (using derived) it's purely for learning
11:33:40 <byorgey> ok, cool
11:34:10 <OneEyedWill> byorgey: Receiving this error now     parse error (possibly incorrect indentation or mismatched brackets)
11:35:03 * byorgey uses his magical telepathy powers to figure out the syntax error in OneEyedWill's code
11:35:12 <OneEyedWill> updated code http://lpaste.net/99452
11:35:22 * OneEyedWill haha
11:35:23 * hackagebot monad-unify 0.2.0.0 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.2.0.0 (PhilFreeman)
11:35:25 * hackagebot purescript 0.3.8.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.8.1 (PhilFreeman)
11:36:06 <byorgey> OneEyedWill: that looks OK to me
11:36:18 <byorgey> maybe the error is in a different part of the file?
11:36:24 <OneEyedWill> unfortunately no the compiler
11:36:28 <OneEyedWill> hmm
11:36:33 <OneEyedWill> let me look around
11:37:55 <byorgey> s/maybe //
11:38:32 <OneEyedWill> byorgey: found it. it was in a another function below
11:38:36 <byorgey> ok
11:38:47 <klrr_> is there any good tutorial on free monads?
11:38:55 <OneEyedWill> byorgey: thanks again
11:38:59 <byorgey> sure
11:39:20 <johnw> klrr_: here's one: http://newartisans.com/2012/08/meta-programming-with-the-free-monad/
11:39:31 <klrr_> thanks will check it
11:41:07 <peddie> klrr_: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html and some other posts on the same blog
11:41:33 <klrr_> thanks
11:41:37 <shepheb> Feuerbach: the GHCJS folks would love a haskell-src-exts release to Hackage.
11:41:46 <DMcGill> My haskell code is currently ~7 times slower than my C code for the same problem. While I install LLVM to see if that helps does anybody want to take a look at both? I'll credit you in my thesis
11:43:05 <DMcGill> It's the knapsack problem, the haskell is only ~50 lines
11:43:21 <peddie> DMcGill: can you post the code?
11:43:52 <DMcGill> http://lpaste.net/99453
11:45:38 <klrr_> johnw: thanks a lot, that tutorial was really good!
11:46:07 <johnw> it tries to give a sense of one thing free monads can *do*, but it doesn't cover what they're really about, or why they are "free"
11:46:20 <johnw> for that there are many articles, of varying degrees of difficulty
11:47:00 <klrr_> yeah, but it gives sufficient introduction to see what they are useful for, "good for DSLs" was quite abstract till i read this
11:47:25 <johnw> they are great for DSLs; and there are libraries, like "operational", which make them much easier to use for that purpose
11:48:39 <Feuerbach> shepheb: I think the best way to achieve that is to open a github issue and explain why they want a release
11:49:05 <luite> Feuerbach: current hackage version doesn't build with ghc 7.8
11:49:39 <Feuerbach> oh
11:50:22 <Feuerbach> do you know which commits fix it? so that I can make a point release
11:51:32 <peddie> DMcGill: I don't see anything obviously wrong so far, but I don't know much about performance; might have to wait for someone with a clue :)
11:52:48 <peddie> DMcGill: have you tried profiling it?
11:54:37 <DMcGill> peddie: yep, http://lpaste.net/99454
11:56:12 <Feuerbach> luite, shepheb: actually, I've just compiled haskell-src-exts-1.14.0 with 7.8
11:56:57 <luite> Feuerbach: don't you get a type error on InternalParser?
11:57:12 <Feuerbach> oh
11:57:17 <Feuerbach> there's no error
11:57:37 <Feuerbach> search the github issues
11:57:46 <luite> hmm, what happy version do you have?
11:57:49 <Feuerbach> it's been already discussed
11:57:52 <shepheb> maybe it's just busted happy/alex
11:58:49 <Eduard_Munteanu> Is there a Bytestring equivalent to System.Process' createProcess, as far as arguments are concerned?
11:59:18 <Eduard_Munteanu> It's rather awful core libs stick to String.
11:59:21 <luite> Feuerbach: hmm, i tried to build it with happy 1.19.3 installed, latest from hackage
11:59:30 <Feuerbach> luite: did you find the issue?
12:00:19 <Feuerbach> https://github.com/haskell-suite/haskell-src-exts/issues/60
12:00:26 * hackagebot pipes-zlib 0.3.1 - Zlib compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.3.1 (RenzoCarbonara)
12:00:30 <Eduard_Munteanu> And unix's System.Posix.Process.Bytestring doesn't seem to provide a way to get at handles.
12:01:59 <luite> Feuerbach: yeah, i'll try again, perhaps i had some lingering files generated by the old happy
12:02:19 <Feuerbach> luite: basically, unpack & clean & install
12:03:09 <luite> Feuerbach: yeah running now, takes a while, big package :)
12:03:10 <Feuerbach> hm, now that I think of it, a point release could actually help avoid this problem. Because it would include a freshly generated parser
12:03:23 <Feuerbach> although it's a cabal problem, not HSE's
12:03:43 <Feuerbach> yup, will do
12:05:47 <supki> is it just me or does hackage actually support https now?
12:05:54 <Eduard_Munteanu> supki: it does
12:05:56 <supki> that's so cool
12:06:12 <Eduard_Munteanu> That's so normal. :)
12:06:37 <Eduard_Munteanu> supki: I don't think cabal does https or some form of crypto for validating downloads.
12:06:42 <luite> Feuerbach: clean unpack still fails here, does cabal cache the generated parser somewhere or something?
12:07:01 <Eduard_Munteanu> Not yet, last time I checked, I mean.
12:07:02 <Feuerbach> luite: yes. clean after unpack
12:07:04 <luite> or do i have a borked package in my local cache?
12:07:35 <Feuerbach> the released tarball contains dist/ with the generated parser inside
12:08:24 <luite> Feuerbach: i unpacked in a new dir
12:08:24 <luite> and it failed
12:08:24 <luite> cabal build && cabal configure in fresh unpack
12:08:25 <luite> err other way around
12:08:25 <luite> Feuerbach: ah!
12:08:29 <luite> tnx
12:08:49 <luite> yeah then a point release would be most welcome :)
12:09:49 <flebron> Haha, "reallyUnsafePtrEquality" :)
12:18:08 <Feuerbach> luite: uploaded 1.14.0.1
12:18:15 <luite> Feuerbach: cool, tnx!
12:18:33 <Feuerbach> luite: just curious, how do you use HSE in GHCJS?
12:18:40 <ReinH> flebron: you forgot the # :)
12:18:52 <luite> Feuerbach: jmacro uses HSE/HSM for antiquotes
12:20:29 * hackagebot haskell-src-exts 1.14.0.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.14.0.1 (RomanCheplyaka)
12:20:37 <quchen> Is Renzo Carbonara on #haskell?
12:20:51 <quchen> (Maintainer of multiple pipes* libraries)
12:21:18 <Aetherspawn> quchen: he's k0001
12:21:28 <Aetherspawn> usually on here, but not right now.
12:21:36 <quchen> Good to know, thanks
12:26:32 <xintron> Which would be more efficient: Data.Text.head "input" == ':' OR Data.Text.isPrefixOf ":" "input"?
12:26:41 <xintron> (my guess would be head but what do I know :) )
12:26:58 <stepkut> Walther: they are more verbose -- things like blaze html are designed to be able to programmatically generate HTML -- if you just want to type in some markdown -- perhaps you really want a CMS like clckwrks
12:26:59 <Aetherspawn> why isn't -O2 defaulted on cabal packages
12:27:04 <Aetherspawn> during cabal install?
12:27:35 <dcoutts> Aetherspawn: because -O1 is the appropriate default
12:27:37 <Eduard_Munteanu> xintron: the former I think too
12:28:08 <Walther> stepkut: Mmh. At #snapframework I was told (and shown an example) that Snap can actually use markdown, might go with that one
12:28:10 <xintron> Eduard_Munteanu, Since it should be less overhead creating Text to match against (and instead using char)?
12:28:19 <Walther> And obviously, use it in conjunction with Heist
12:28:26 <Aetherspawn> -O2 doesn't really cause any regressions like the manual suggests its dangerous and whatnot
12:28:49 <dcoutts> Aetherspawn: you can always override the default by doing a cabal install -O2, or for specific packages in the ghc-options
12:29:10 <Aetherspawn> that's what I've done, but now I'm contemplating whether my gracious use of INLINABLE counters that
12:29:12 <dcoutts> Aetherspawn: it is slower to compile, typically generates more code, and it's not always faster
12:29:19 <Eduard_Munteanu> xintron: not only, the explicit check might be faster as well, see how attoparsec warns against using inClass if you can avoid it
12:29:38 <xintron> ok
12:29:40 <dcoutts> Aetherspawn: if you know it makes your package faster you're most welcome to specify it in the ghc-options field in the .cabal file
12:29:42 <jfischoff_> dcoutts: yeah but its a higher number ;)
12:30:01 <dcoutts> jfischoff_: -O11!
12:30:05 <jfischoff_> haha
12:30:14 <dcoutts> :-)
12:30:38 <Eduard_Munteanu> xintron: e.g. takeWhile (\c -> c == '1' || c == '2')   vs   takeWhile inClass "12"
12:31:15 <Eduard_Munteanu> Er,  takeWhile (inClass "12")
12:31:31 <xintron> Can I cast a string to a type (data Foo = Bar | Biz) where the string would be either "Bar" or "Biz"?
12:32:06 <Eduard_Munteanu> xintron: read
12:32:18 <Eduard_Munteanu> > read "False" :: Bool
12:32:19 <lambdabot>  False
12:33:28 <Eduard_Munteanu> However, "cast" isn't quite appropriate.
12:33:41 <FreeFull> You could alternatively make your own function for it
12:34:02 <flebron> Is there an IntMap for Integers?
12:34:16 <Eduard_Munteanu> flebron: I don't think so
12:34:48 <xintron> FreeFull, Yeah, maybe that's the better way
12:34:55 <FreeFull> readFoo :: String -> Foo; readFoo "Bar" = Bar; readFoo "Biz" = Biz; readFoo _ = error "no parse"
12:35:11 <flebron> What would be the recommended structure if I wanted to store ~1M Ints, keyed by Integers? (each Integer is about 130 digits long)
12:35:33 <flebron> I'm currently using Data.Map, just wondering if I could improve on that. Batch insert, then batch read.
12:35:40 <xintron> FreeFull, And then I could wrap it in a Maybe as well for easier handling I guess
12:36:21 <FreeFull> xintron: Yeah, rather than use error
12:36:44 <Feuerbach> flebron: you could try HashMap instead. I'd be curious to see how they compare in your case
12:36:49 <Feuerbach> from unordered-containers
12:36:50 <FreeFull> Nothing wrong with defining or deriving a Read instance though
12:36:59 <xintron> FreeFull, thanks, great advice
12:37:11 <CaptainLexin> So, haskell-chappies, what's the appropriate way for an implicitly or dynamically typed language to handle dispatch? Is it not happening? Are there other solutions to the problem? Are they different for each type system?
12:37:25 <tv> hi; i'm just learning haskell using LYAH... and now i'm reading about Data.Map and the book talks about Data.Map.map as Map (which also seems to exist according to to ghc docs) but when i try to use Map.map, then ghci says "Failed to load interface for `Map'"... where do i fail?
12:37:55 <roboguy_> ChanServ: you mean dynamic dispatch on types?
12:37:59 <roboguy_> CaptainLexin
12:38:16 <FreeFull> tv: Did you import Data.Map as indicated?
12:38:32 <Eduard_Munteanu> tv: you probably want  import qualified Data.Map as Map   if you want to refer to that as "Map.map"
12:38:33 <tv> FreeFull: i did import qualified Data.Map as Map in ghci
12:38:34 <FreeFull> write    import Data.Map as Map    in ghci and it should work
12:38:46 <FreeFull> Or even qualified
12:38:50 <FreeFull> tv: Then it should work
12:38:55 <FreeFull> What does the prompt look like?
12:38:56 <tv> when i do :m + Data.Map, then i can access Data.Map.map
12:39:09 <Eduard_Munteanu> tv: what GHC version?
12:39:20 <tv> FreeFull: it says: Prelude Map>
12:39:35 <tv> Eduard_Munteanu: 7.6.3
12:39:45 <FreeFull> tv: :t Map.map   should work then
12:39:56 <CaptainLexin> roboguy_: Exactly so. For an equivalent of overloading, &c &c
12:40:24 <tv> uh, i just restarted ghci to see the version and now it works...-.-
12:40:24 <Eduard_Munteanu> tv: it works here on 7.6.3
12:40:39 <tv> dunno what i did wrong, though...
12:40:41 <roboguy_> CaptainLexin: well, haskell is sort of implicitly typed but that's probably not what you mean. Common Lisp has the CLOS which has dynamic dispatch
12:40:44 <tv> sorry for bothering^_^
12:41:53 <Wizek> good morning
12:42:38 <tv> ok, found the problem... i imported the module as Map, then i let map = Map.fromList ... and then the failure happened...
12:42:45 <tv> i shouldn't pollute the namespace
12:42:57 <tv> but i wasn't aware of the fact that i would declare it in Map
12:43:11 <FreeFull> No, Map.map should still work even if you let map = something
12:43:21 <tv> but it doesn't for me
12:43:33 <Wizek> How can I get the response body out from the withManager block while using http-conduit?
12:43:41 <Feuerbach> that could happen if you let map = Map.fromList before you importer Data.Map as Map
12:43:41 <Wizek> And not through a fileSink
12:43:49 <Feuerbach> *imported
12:43:54 <FreeFull> tv: Ah, I just tried it, and same thing happens to me
12:43:58 <roboguy_> tv: the error says "Failed to load interface"?
12:44:07 <FreeFull> roboguy_: Try it out yourself
12:44:11 <Feuerbach> hm
12:44:12 <tv> roboguy_: yes
12:44:15 <hakujin> Wizek: look at httpLbs
12:44:18 <roboguy_> FreeFull: I just did. no error...
12:44:25 <FreeFull> I did and I got the same error
12:44:51 <Feuerbach> no error for me either
12:44:53 <FreeFull> import qualified Data.Map as Map; let map = 3; :t Map.map
12:44:56 <tv> i started ghci, loaded Data.Map as Map and let map = something, then :t Map.map errors with "failed to load interface"
12:45:10 <roboguy_> FreeFull: oh, I didn't try Map.map
12:45:22 <Feuerbach> ah yes. I can reproduce it now, too
12:45:26 <FreeFull> http://lpaste.net/99455
12:45:42 <roboguy_> it looks like a bug. GHC HEAD doesn't give an error
12:46:02 <FreeFull> If it's a bug, there should be a commit that fixes it
12:46:44 <roboguy_> yeah. I'm sure that's why head works
12:47:47 <roboguy_> what version of containers are you using?
12:48:27 <xintron> Is there any printf for Data.Text one should use (instead of Text.Printf)?
12:48:58 <geekosaur> printf is not particularly loved, so I doubt it
12:49:03 <Forgetaboutit> Hey guys, newbie here. I' currently trying out Yesod and I want to build a JSON-delivering REST-API. Unfortunately, Yesod delivers my entity in a weird way ({id: 2, value: {name: ... } }). I want it to look like {id: 2, name: ... }. Apparently, there is a function for that (entityIdToJSON). It's documented here: ( http://hackage.haskell.org/package/persistent-1.3.0.2/docs/Database-Persist-Class.html ). Unfortunately, I can't i
12:49:09 <roboguy_> xintron: I think text-format has that
12:49:37 <Cale> Forgetaboutit: Your message was cut off at "Unfortunately I can't"
12:49:52 <xintron> geekosaur, ok. Maybe I should go about and just solve it with append instead then (since there is no special formatting done more than appending lines together)
12:50:37 <Forgetaboutit> I'm really puzzled if I or how I can use this function. Database.Persist is bundled with Yesod. But when I try to import it, it says "    Module `Database.Persist.Class' does not export `entityIdToJSON'"
12:50:39 <klrr_> does k usually repreasent a variable of type a -> m b?
12:50:55 <Forgetaboutit> Cale: I can't import it somehow
12:50:58 <roboguy_> klrr_: k?
12:51:16 <Cale> Forgetaboutit: uh, perhaps it's a version thing?
12:51:30 <Forgetaboutit> Cale: Uh, I'll check quickly
12:51:33 <Cale> Forgetaboutit: Do a  ghc-pkg list persistent
12:51:37 <klrr_> roboguy_: i mean k as in argument
12:51:39 <klrr_> variable
12:52:01 <byorgey> klrr_: I wouldn't say "usually".  Sometimes it might, especially since  (a -> m b) are the arrows of the "Kleisli category" for m
12:52:16 <roboguy_> klrr_: it could. it probably more frequently represents other types though. I don't think there is a convention for that particular name
12:52:17 <byorgey> k is also often used for continuations, for scaling factors, ...
12:52:28 <klrr_> okey
12:52:40 <Forgetaboutit> Cale: it says "persistent-1.2.3.0".
12:52:40 <klrr_> may i ask what arrows mean in that particular case?
12:52:56 <byorgey> klrr_: do you know any category theory?
12:52:58 <Forgetaboutit> Cale: Indeed, it seems like I have an old version
12:53:03 <roboguy_> klrr_: I think the morphisms of the Kleisli category
12:53:15 <Forgetaboutit> Cale: But how do I fix this?
12:53:38 <Feuerbach> xintron: take a look at text-format
12:53:50 <klrr_> byorgey: unfurtally not, it's on my "do when you know more math" todo list though
12:53:58 <xintron> Feuerbach, Will do
12:54:04 <Cale> Forgetaboutit: Well, I don't know a whole lot about Yesod, but it seems a little bit strange that you couldn't just define something to construct appropriate JSON values directly.
12:54:45 <Cale> Forgetaboutit: You're using aeson, right?
12:54:54 <byorgey> klrr_: OK, well, every category has a collection of "objects" and a collection of "arrows" or "morphisms" between the objects.  Functions of type (a -> m b) form the collection of arrows for a particular kind of category called a Kleisli category.
12:55:00 <xintron> Feuerbach, Just seem so "cumbersome" to do; append "foo" $ append name $ append "bar" host
12:55:01 <Forgetaboutit> Cale: I could probably do it the same way the new persistent package is doing it.
12:55:06 <Forgetaboutit> Cale: Yes
12:55:21 <xintron> Feuerbach, On the other hand I would guess it's more efficient than some printf solution
12:55:56 <Forgetaboutit> Cale: Looking at my cabal file tells me I probably have to change a lot just to get persistent to 1.3
12:55:57 <Cale> Forgetaboutit: Yeah, pretty much: http://hackage.haskell.org/package/persistent-1.3.0.2/docs/src/Database-Persist-Class-PersistEntity.html#entityIdToJSON
12:56:25 <klrr_> byorgey: ok, this might be a stupid assumption but does arrow mean the (->) and collection of objects the `a` and `m b`?
12:57:01 <byorgey> klrr_: no, it doesn't
12:57:13 <Forgetaboutit> Cale: I'd rather update the whole thing. I don't like developing on an 'old' version.
12:57:15 <Feuerbach> xintron: printf or analogues are not necessarily (noticably) less efficient
12:57:32 <klrr_> okey
12:57:35 <Forgetaboutit> Cale: But thank you for the help!
12:57:43 <roboguy_> klrr_: I believe (->) is an arrow but not the category we're considering right now
12:57:54 <Cale> klrr_: Given a monad M on a category C, the objects of the Kleisli category for M are the same as the objects of C, but the arrows A ~> B in the Kleisli category are arrows A -> M B in C.
12:58:19 <Cale> Forgetaboutit: no problem :)
12:59:15 <Cale> klrr_: The identity arrow A ~> A in the Kleisli category is then given by eta_A : A -> M A in C (a.k.a. return)
12:59:46 <Forgetaboutit> A more general question: I have read about cabal-dev, which can install libraries in a project-contained way. Should I be using it?
12:59:56 <Aetherspawn> cabal can too
12:59:57 <Aetherspawn> ;)
13:00:16 <Aetherspawn> cabal sandbox init
13:00:17 <S11001001> Forgetaboutit: cabal 1.18 has sandboxes for that sort of thing
13:00:18 <Cale> Forgetaboutit: For Yesod or the other web frameworks especially, yeah, that would be a great idea.
13:00:33 <Cale> Forgetaboutit: (or use cabal's new builtin sandboxing)
13:00:34 * hackagebot approximate 0.2.1 - Approximate discrete values and numbers  http://hackage.haskell.org/package/approximate-0.2.1 (EdwardKmett)
13:00:43 <Aetherspawn> allthough tbh
13:00:47 <Aetherspawn> on windows cabal sandboxing leaks
13:00:54 <klrr_> i appriciate the explaination but i honestly does not understnad it, i believe i have to get comfortable with the termology here first
13:00:54 <Aetherspawn> Im not sure if cabal-dev is any better
13:01:07 <Forgetaboutit> Aetherspawn: fortunately, I'm not stuck with Windows :)
13:01:36 <Forgetaboutit> I'll give cabal sandboxes a try :)
13:01:43 <sm> Forgetaboutit: there's no harm in not using sandboxes, I would say use them if you need them
13:01:52 <Cale> Forgetaboutit: The web frameworks all have insanely complicated dependencies, and it's easy to get things messed up if you start installing packages for other projects, so sandboxing tends to be a good plan.
13:01:57 <sm> periodically resetting your package db is an alternative
13:02:36 <Cale> klrr_: Okay, well, I could have made that description a little more Haskell-centric :)
13:02:59 <Cale> klrr_: So, if you look at return and (<=<), these are kind of analogous to id and (.)
13:03:03 <Cale> :t return
13:03:04 <lambdabot> Monad m => a -> m a
13:03:10 <Cale> :t (<=<)
13:03:11 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:03:16 <Cale> :t id
13:03:18 <lambdabot> a -> a
13:03:21 <Cale> :t (.)
13:03:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:03:44 <Forgetaboutit> Cale: I know the same issue from other languages and it has always bothered me if I couldn't keep the dependencies clean
13:04:27 <Forgetaboutit> Cale: I'm already wondering if Yesod is kinda overkill for building only an API on top of it, without using all the HTML/CSS/JS helper stuff
13:04:55 <klrr_> yeah, they look like their "monadic equaliant"
13:05:08 <Cale> klrr_: and indeed, the monad laws imply (and are implied by) the things which make return and (<=<) into definitions of the identity arrows and composition respectively for a category:
13:05:12 <Cale> return <=< f = f
13:05:16 <Cale> f <=< return = f
13:05:26 <Cale> f <=< (g <=< h) = (f <=< g) <=< h
13:05:33 <sm> Forgetaboutit: why not start with scotty, you can port it as soon as you need more framework
13:05:34 * hackagebot Win32 2.3.0.0 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.3.0.0 (BryanOSullivan)
13:06:29 <klrr_> okey, so *an* arrow is kind of a function, like identity?
13:07:05 <Feuerbach> klrr_: "kind of". It's more abstract than a function. What an arrow is, exactly, depends on the category
13:07:06 <Cale> klrr_: Arrows in a category in general are like an abstract generalisation of functions.
13:07:08 <Forgetaboutit> sm: what's the difference between scotty and Yesod?
13:07:21 <sm> scotty is the simplest of the haskell web frameworks
13:07:29 <klrr_> okey
13:07:48 <roboguy_> klrr_: in a monoid category, the arrows are the elements of the monoid and arrow composition is the binary operation of the monoid
13:07:55 <Cale> klrr_: What is probably the first category that serves as a central example for most people is the category whose objects are sets and whose arrows are functions between those sets.
13:07:59 <FreeFull> I think  (return,a -> m a,<=<) is a monoid
13:08:07 <Forgetaboutit> sm: Basically, I need a database connection, JSON handling and that's it
13:08:15 <Cale> FreeFull: only if you restrict yourself to a single object
13:08:32 <Forgetaboutit> sm: Maybe you're right and I should start with something simple
13:08:33 <sm> Forgetaboutit: just a db connection for doing raw sql, or something more like an ORM ?
13:08:39 <Cale> i.e. you restrict the type of (<=<) to be (a -> m a) -> (a -> m a) -> (a -> m a)
13:08:43 <klrr_> so the arrow can be thought of the operators of a class in haskell?
13:08:51 <klrr_> s/the/an
13:08:56 <Cale> klrr_: er
13:09:03 <FreeFull> :t (<=<)
13:09:04 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:09:06 <Forgetaboutit> sm: I prefer not having to write raw SQL. An ORM would be nice
13:09:12 <Cale> klrr_: Join ##categorytheory so that I can write out the definition of a category for you :)
13:09:20 <klrr_> okey
13:09:26 <FreeFull> Cale: Yeah, you're right, but the type I provided does restrict that
13:09:36 <sm> ok, if you want that, persistent is one excellent option
13:09:50 <sm> it comes with yesod, or you can just use it with scotty
13:10:37 * hackagebot hyperloglog 0.2 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.2 (EdwardKmett)
13:10:58 <Forgetaboutit> sm: Ok, cool. Are you aware of any downsides of Scotty?
13:14:39 <sm> Forgetaboutit: people seem to love it. You'll just probably soon want more features of a bigger framework like yesod, snap or happstack. It depends how eager you are for added complexity
13:15:04 <benmachine> added complexity is my favourite thing
13:15:27 <sm> but scotty does use the same wai/warp back end as yesod, so I imagine it does its job pretty darn well
13:15:35 <Forgetaboutit> added complexity sounds great, as long as it also comes with a bunch of features ;)
13:15:48 <bitemyapp> Scotty is nice but you need to think about how you're designing the app.
13:15:56 <sm> ok, straight to yesod then :)
13:16:00 <bitemyapp> If you can stick to a pure REST interface on the backend, Scotty or straight WAI will work fine
13:16:17 <bitemyapp> if you want traditional web app style with form processing and all that, you're going to be better off with Snap or Yesod.
13:16:53 <Forgetaboutit> bitemyapp: I prefer having a REST interface only, no rendered HTML and stuff
13:17:06 <bitemyapp> Forgetaboutit: then Scotty or straight WAI are going to be fine.
13:17:34 <Forgetaboutit> bitemyapp: what's WAI?
13:17:44 <bitemyapp> Forgetaboutit: Rack/WSGI/Ring for Haskell, kinda.
13:17:47 <bitemyapp> except not everybody uses it yet.
13:18:31 <Forgetaboutit> bitemyapp: Sounds nice, thanks
13:28:06 <rawtass> Is it possible to review/fseek back in the file when using Data.Binary.Get?
13:28:18 <rawtass> *rewind
13:31:29 <AlainODea> has anyone ever seen "setup: /usr/bin/ld: permission denied" when trying to cabal install Cabal itself from source?
13:31:41 <ownclo> rawtass: as far as I can tell, no. You must pass previously parsed data of interest explicitly.
13:32:33 <benmachine> AlainODea: that's weird. have you ever compiled a binary before?
13:32:42 <benmachine> (in this development environment)
13:33:26 <geekosaur> AlainODea, what platform?
13:33:44 <AlainODea> benmachine: I've built the whole of GHC and haskell-platform on it.  It's SmartOS.  Is there a way to see what parameters it is sending to ld?
13:34:29 <geekosaur> parameters would not matter
13:34:35 <syllogismos> t
13:34:36 <geekosaur> hrm, my smartos machine is not currently online
13:35:08 <mmat_> Can you get a regular c source to compile and link?
13:35:26 <benmachine> AlainODea: okay, my only idea is therefore false and I can be of no further use :P
13:37:22 <AlainODea> geekosaur: no problem. I've had some advice around DTracing it to see where it fails.  Permissions is a really strange place to fail especially seeing as I am running this as root
13:37:50 <geekosaur> well, permissions can mean you have a file that is not executable. I don't know where smartos puts its ld
13:37:53 <roboguy_> AlainODea: does /usr/bin/ld work at all?
13:37:58 <geekosaur> alternately this is some rsbac thing
13:38:08 <KatZilla> hi there. I have own hackage server
13:38:13 <geekosaur> (older solaris put it in /usr/ccs/bin)
13:38:44 <KatZilla> How to tell cabal to install packages from own/custom hackage server
13:38:45 <KatZilla> ??
13:39:17 <hakujin> thoughts on using regex libraries vs just attoparsec? I know regex is a little faster, but what do I gain from attoparsec if I only need a certain part of the whole text?
13:39:20 <AlainODea> roboguy_: I'm pretty sure, but I'll check.  I have the GCC toolchain as well.  It may be a problem with using the non-GCC stuff that is built-in
13:39:37 <geekosaur> KatZilla, report-repo: line in ~/.cabal/config
13:39:42 <geekosaur> er, remote-repo: line
13:39:58 <geekosaur> default entry is: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
13:40:14 <geekosaur> edit to point to your own (change the label as well as the href)
13:40:51 <AlainODea> roboguy_: I'm very rusty with building native code. Is there a good hello-world example of using ld?
13:41:20 <geekosaur> you don;t normally run ld directly
13:41:34 <KatZilla> geekosaur: where is this line located L
13:41:35 <KatZilla> ?
13:41:36 <roboguy_> AlainODea: int main() { return 0; }
13:41:42 <KatZilla> o thx )
13:41:45 <KatZilla> I see )
13:41:52 <roboguy_> gcc -c test.c && /usr/bin/ld -o test test.o
13:41:56 <KatZilla> geekosaur: thx man a lot !!)) Love Haskell ))
13:42:20 <roboguy_> AlainODea: also, when you do ls -l /usr/bin/ld does it say it's executable?
13:44:13 <shergill> has anyone looked into the haskell equivalent of pymacs? i.e., invoke haskell code from emacs
13:44:15 <AlainODea> roboguy_: /usr/bin/ld is 755
13:46:58 <geekosaur> it will be a bit before I can bring up my smartos box. my OI VM has /usr/bin/ld, it is executable and seems to work
13:47:49 <mmat_> On debian /usr/bin/ld is rwxrwxrwx root:root, I don't know how to translate that to the numeric code.
13:47:52 <roboguy_> AlainODea: does it give any other errors? do you have verbose output turned on?
13:48:25 <geekosaur> mmat_: actually it's lrwxrwxrwx and not relevant because it's part of the alternatives system
13:48:28 <roboguy_> mmat_: I think that's 777. 755 should be executable for everyone
13:48:35 <roboguy_> also
13:48:53 <geekosaur> (that is, it's a symlink so its actual permissions are not entirely relevant)
13:48:59 <Wizek> Can I ask GHC which imports are unnecessary?
13:49:01 <AlainODea> robogy_: no other errors beyond the permission denied
13:49:08 <Wizek> in my file
13:49:25 <AlainODea> roboguy_: apparently I've forgotten how to use keyboards :)
13:49:26 <roboguy_> Wizek: run ghc with -Wall
13:50:40 <roboguy_> AlainODea: hmm, do you have verbose output turned on?
13:50:41 * hackagebot parsers 0.10.3 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10.3 (EdwardKmett)
13:53:54 <AlainODea> roboguy_: cabal install --verbose Cabal/ shows some additional logging about dependencies and then logs the "setup: /usr/bin/ld: permission denied".  DTrace does not corroborate cabal's attempt to run /usb/bin/ld because there is neither an exec-success or exec-failure for it.  There are lots of execs of stuff like happy, hpc, hsc2hs, etc., but not
13:53:54 <AlainODea> /usr/bin/ld
13:54:37 <geekosaur> did you include -f when you ran dtruss?
13:55:48 <AlainODea> geekosaur: I'm running dtrace -n 'proc:::exec-* { trace(curpsinfo->pr_psargs); }' separately
13:56:24 <Kaidelong> why did the those library decide on "Those a b = This a | That b | Those a b" rather than "Those a b = OneOf(Either a b) | Those(a,b)"
13:56:47 <AlainODea> geekosaur: it essentially shows exec-success or exec-failure of any commands run AFAIK
13:57:08 <geekosaur> yes, that dtrace probe shouldn't care about forks
13:57:16 <geekosaur> which makes me wonder if it's doing something else
13:57:23 <Kaidelong> needs one less constructor and allows the use of existing functions that work with Either and ,
13:57:32 <geekosaur> perhaps it's trying to stat() it to see if it's executable
13:57:51 <geekosaur> in which case i  think you might have rsbac problems, or else it's a dangling symlink
13:57:58 <benmachine> Kaidelong: one constructor instead of two at use sites, arguably clearer intention
13:58:11 <benmachine> Kaidelong: you might as well ask why Maybe exists when you can just use Either ()
13:58:32 <geekosaur> (aiee not that thread again :p )
13:58:34 <mmat_> OneOf(Either) seems a bit confused to me.
13:58:40 <Wizek> -fwarn-unused-imports :)
13:58:46 <Kaidelong> benmachine: To me the latter more clearly evokes "product or sum"
13:58:53 <geekosaur> not so much confused as convoluted
13:58:56 <Kaidelong> which is how I mentally think about Those
13:59:46 <benmachine> Kaidelong: there's often a tension between re-using existing constructs and making new ones
13:59:49 <Kaidelong> benmachine: I dunno if Maybe t = Either () t really helps with anything
13:59:50 <benmachine> Kaidelong: it can go either way
14:00:03 <Kaidelong> I guess it doesn't really hurt either
14:00:18 <syllogismos> newtype School = [(Int, [String])]
14:00:26 <syllogismos> why is this giving me a parse error?
14:00:28 <benmachine> syllogismos: you need a constructor
14:00:51 <syllogismos> ohh
14:00:51 <geekosaur> are you sure you didn't want type instead of newtype?
14:00:52 <syllogismos> oops
14:00:54 <benmachine> newtype School = TooCool [(Int, [String])]
14:01:02 <syllogismos> how is string defined?
14:01:08 <heatsink> nice constructor name
14:01:08 <benmachine> type String = [Char]
14:01:13 <syllogismos> type String = [Char]
14:01:20 <syllogismos> i want type
14:01:23 <syllogismos> not newtype
14:01:26 <benmachine> suit yourself
14:01:33 <geekosaur> newtype wraps a type to "hide" it, so needs a constructor. type creates a type synonym and doesn't need a constructor
14:01:58 <Kaidelong> you use newtype when you want to define different typeclass definitions over the defaults
14:02:24 <Kaidelong> or if you just want to hide functionality about the actual type
14:02:53 <lispy> If you need a newtype to create different typeclass instances, that's an indicator that a typeclass is probably not the right design
14:03:35 <lispy> At that point you're basically using the newtype as an instance selector
14:03:35 <AlainODea> geekosaur: roboguy_: thank you very much for your help.  I've got to run, I'll figure this out now I think. You've pointed me in the right direction :)
14:03:41 <geekosaur> only if you're trying to replace them. consider the case of using newtype deriving so that you can treat your newtype as both StateT and ReaderT
14:05:30 <benmachine> Kaidelong: I frequently use newtype when I don't want different instances or any hiding
14:05:40 <benmachine> I just want one usage to not typecheck where the other is intended
14:07:05 <`^_^v> i have a type (m Expr) that i want to convert to (m (Maybe Expr)) by wrapping it in Just, is there an easy way to do so?
14:07:20 <Eduard_Munteanu> :t fmap Just
14:07:21 <lambdabot> Functor f => f a -> f (Maybe a)
14:07:41 <Eduard_Munteanu> `^_^v: ^^
14:07:59 <ReinH> `^_^v: is m a Functor?
14:08:14 <funfunctor> jesus, 5min in #c++ and I had to switch back to this window :p
14:08:20 <maxiepoo> what's the best way to figure out which of my dependencies is restricting another dependency? I.e., I have a dependency on blaze-html that would allow for the newest version but an older version gets installed and I want to know which of my other dependencies is being restrictive
14:08:44 <maxiepoo> :o, I meant e.g., not i.e.
14:08:49 <levi> lispy: There are plenty of things that have multiple sensible Monoid instances, etc.
14:09:25 <geekosaur> maxiepoo, I think if you run cabal with -v3 it should show all the dependencies it's examining
14:09:32 <syllogismos> what does uncurry function do
14:09:37 <syllogismos> :t uncurry
14:09:37 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:09:38 <ReinH> lispy: Uh. Sum, Product, Endo, etc.
14:09:39 <dwcook> @type uncurry
14:09:40 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:09:55 <mmat_> Ohh that's a cool function of an IRC bot.. :)
14:09:59 <ReinH> lispy: using newtypes to create different instances is common
14:10:01 <dwcook> Exactly what it suggests – It turns a function taking two curried parameters into one taking a tuple of them instead
14:10:07 <dhrosa> I have the following expression tree data types: I've  figured out how to parse expressions that yield an Expr Word8, is there a way to handle parsing expressions that can convert from Expr Word16 -> Expr Word8 and vice-versa while still using Parsec's buildExpressionParser?
14:10:11 <roboguy_> mmat_: it can even run some haskell code
14:10:13 <benmachine> ReinH: "common" doesn't mean "a good idea" :P
14:10:16 <dhrosa> oops, here's the link: http://lpaste.net/99457
14:10:24 <ReinH> Ok. It's both common and a good idea.
14:10:26 <dhrosa> the function in question is expr8
14:10:48 <dhrosa> if I make my parser return a generic Expr a, I get rigid type errors
14:11:14 <Dashkal> once upon a time I ran across a haskell snippet that defined an SKI calculus EDSL.  (It used the applicative for -> a).  Anybody remember where to find that?  My google-fu fails me.
14:11:59 <mmat_> Dashkal, I know "the evolution of a haskell programmer" has an SK EDSL on it.
14:12:00 <dwcook> syllogismos, does something confuse you about uncurry?
14:12:02 <roboguy_> Dashkal: I think k = const; s = (<*>); i = id
14:12:08 <levi> I would be surprised if making separate instances wasn't one of the primary reasons for introducing newtype in the first place.
14:12:57 <Dashkal> roboguy_: Sounds about right.  Danke
14:13:06 <syllogismos> no it makes sense now.. but i came across foldl' (flip $ uncurry myFunc) mySecondFunc
14:13:16 <syllogismos> so im trying to figure out whats happening..
14:13:56 <stolaruk> I have a function that recursively calls itself midway when a certain condition is true. Could this possibly overflow stack if the function calls itself over and over without ever officially "finishing"?
14:14:05 <ReinH> syllogismos: work it out piece by piece
14:14:15 <levi> That, and for making efficient Monad instances.
14:14:44 <roboguy_> stolaruk: does it build up a thunk with a size proportional to the number of recursive calls?
14:14:57 <Eduard_Munteanu> stolaruk: it could be productive... e.g.  repeat 1
14:15:39 <stolaruk> It reads user input, if input is blank, it calls itself; that's all
14:15:40 <levi> syllogismos: uncurry is very common in point-free code like that.
14:16:00 <roboguy_> stolaruk: so it is a tail call and there is no thunk being built up?
14:16:01 <Axman6> stolaruk: it's unlikely to be a problem then
14:16:29 <Kaidelong> @unpl foldl' (flip $ uncurry myFunc) mySecondFunc
14:16:29 <lambdabot> foldl' (\ b c -> uncurry myFunc c b) mySecondFunc
14:16:34 <stolaruk> roboguy_: I'm not exactly sure what would qualify as tail call, but I don't believe a thunk is being built uyp
14:16:37 <dwcook> syllogismos, that's someone being possibly too clever
14:16:37 <dwcook> @unpl flip $ uncurry myFunc
14:16:37 <lambdabot> (\ b c -> uncurry myFunc c b)
14:17:03 <dwcook_> @unpl flip $ uncurry myFunc
14:17:03 <lambdabot> (\ b c -> uncurry myFunc c b)
14:17:08 <syllogismos> its from one of the exercises in exercim.io
14:17:39 <hakujin> thoughts on using regex libraries vs just attoparsec? I know regex is a little faster, but what do I gain from attoparsec if I only need a certain part of the whole text?
14:17:43 <roboguy_> stolaruk: a tail call is when a function call is the outermost call. for example in "f x = g (h (x + 1))" there is a tail call to g
14:17:43 <ReinH> I'm not sure tail call recursion is relevant here
14:17:51 <syllogismos> thanks for @unpl
14:18:01 <roboguy_> true
14:18:16 <Eduard_Munteanu> hakujin: readability
14:18:29 <hakujin> Eduard_Munteanu: in what sense?
14:18:39 <stolaruk> @roboguy_ I pasted the function here: http://lpaste.net/99458
14:18:39 <lambdabot> Unknown command, try @list
14:18:40 <ReinH> but the GC should be able to reclaim the stack
14:18:42 <syllogismos> i forgot the irc command for private messaging lambdaot.. what is it?
14:18:49 <stolaruk> sorry
14:18:53 <stolaruk> roboguy_ I pasted the function here: http://lpaste.net/99458
14:18:54 <levi> hakujin: When you build parsers in Attoparsec, you get compile-time checking of their well-constructedness and they are typically easier to read.
14:18:58 <Eduard_Munteanu> hakujin: you can also use both, like Happy + (Atto)parsec, where the former tokenizes using regexps.
14:19:14 <levi> syllogismos: /query
14:19:14 <johnw> I really like writing parsers in Attoparsec
14:19:18 <Eduard_Munteanu> hakujin: a big regex might be somewhat unmaintainable or frightening.
14:19:19 <hakujin> levi: compile time checking of the regex I hadn't thought of! thanks
14:19:27 <stolaruk> roboguy_: The recursive call is not the outermost
14:19:46 <ReinH> stolaruk: tail recursion isn't very relevant here anyway
14:19:54 <roboguy_> I think that those things will get GC'd regardless of tail recursion
14:19:56 <levi> hakujin: Attoparsec combinators are also composable, while regex engines tend to require you write the whole thing into a big string.
14:19:56 <roboguy_> actually
14:20:06 <Eduard_Munteanu> hakujin: er, s/Happy/Alex
14:20:15 <ReinH> stolaruk: what's important is that GC can reclaim previous stack frames
14:20:33 <ReinH> the question is whether it can do so fast enough, and the answer here is yes.
14:20:42 <ReinH> unless your human input is faster than GC
14:20:45 <hakujin> Eduard_Munteanu, levi: thanks
14:20:46 <stolaruk> ok
14:20:47 <stolaruk> cool
14:20:52 <stolaruk> thanks
14:22:26 <ReinH> stolaruk: also note that Haskell doesn't have a call stack, so it doesn't stack overflow in quite the same way as other langauges
14:22:42 <stolaruk> ReinH: Yeah I was just reading about that
14:22:51 <stolaruk> ReinH: I like that.
14:22:59 <ReinH> you would need to create thousands of new entries on the pattern matching stack faster than they can be reclaimed by GC
14:23:04 <ReinH> and that seems pretty unlikely for a mud
14:23:39 <stolaruk> ReinH: Yeah primary concern would be building up too many thunks
14:24:02 <mm_freak> graphical games are actually surprisingly memory-stable
14:24:17 <mm_freak> because rendering evaluates at least the scene
14:24:21 <ReinH> but assuming you're going to be printing things based on state you're going to need to evaluate thunks pretty regularly
14:24:30 <ReinH> mm_freak: right, same concept here
14:24:38 <mmat_> stolaruk: What type of project are you working on: a text based game?
14:24:46 <stolaruk> mmat_: Yes
14:24:53 <ReinH> heh everyone is writing one now it seems
14:25:03 <benmachine> I wrote half of one and then ran out of steam
14:25:05 <stolaruk> really?
14:25:14 <mm_freak> ReinH: no, i'm writing a graphical one =)
14:25:16 <ReinH> well I'm writing one
14:25:17 <ReinH> mm_freak: :p
14:25:28 <mm_freak> using OpenGL and of course FRP =)
14:25:36 <ReinH> mm_freak: what opengl bindings?
14:25:37 <stolaruk> Right now it's a one-player game but I'm making a MUD so will be multiplayer.
14:25:42 <levi> ReinH: Were you a mudder back in the day?
14:25:43 <mm_freak> ReinH: OpenGL
14:25:45 <ReinH> mm_freak: and what frp lib?
14:25:50 <ReinH> levi: a bit, not too much
14:25:53 <ReinH> not like edwardk
14:26:01 <johnw> levi: I was, but also not like edwardk
14:26:12 <mm_freak> ReinH: this is an experiment to simplify netwire, so it uses a custom abstraction based on netwire
14:26:20 <ReinH> not of the "I write a Z-Machine to learn new architectures" variety
14:26:27 <ReinH> mm_freak: cool
14:26:31 <levi> I had no idea edwardk was a mudder.
14:26:35 <mm_freak> ReinH: in practical development i noticed that most of the features of netwire aren't really needed
14:26:37 <ReinH> levi: holy crap yes o_O
14:26:42 <levi> But it does not surprise me. :)
14:26:57 <ReinH> meanwhile I'm writing a Z-Machine in Haskell now as well
14:27:01 <ReinH> what a strange architecture
14:27:06 <johnw> levi: his wife is a huge mudder too :)
14:27:07 <stolaruk> that's awesome. MUDs are still alive and well
14:27:21 <levi> I got into the internet largely because of MUDs, back before the WWW.
14:27:57 <bitemyapp> I know a lot of people that started programming because they wanted bots for their MUDs.
14:28:07 <bitemyapp> I started programming because I wanted to write text adventures.
14:28:13 <levi> I mostly played the Tiny-derived variants due to being able to build and script in them as players.
14:28:15 <stolaruk> bitemyapp: nice
14:28:20 <merijn> Oh, sounds like my time to drop in
14:28:38 <stolaruk> On the topic of MUDs, does anyone have recommendations for how I might save world state?
14:28:40 <merijn> I've been wondering, are there any MUDs that allow/encourage botting so you can have AI/bot competitions?
14:28:45 <ReinH> bitemyapp: heh meanwhile I'm writing a text adventure in Haskell atm
14:28:54 <merijn> stolaruk: Sounds like the type of thing acid-state would be good for
14:29:14 <johnw> I hear acid-state can have some pretty large memory requirements
14:29:18 <levi> I learned to write C and do event-driven network servers while fooling around with MUD code. And now that's how I earn my living. :)
14:29:25 <quchen> Grrr pipes-binary-0.3 broke my build. What's the standard way of applying an isomorphisn (Iso')? With some abbreviations, I have a value of type `Iso' (Producer BS m r) (Producer a m (Either (Error, Producer BS m r) r))`, and a `Producer BS m r`. I need the "RHS" of the Iso'.
14:29:26 <Twey>  /b 11
14:29:27 <merijn> johnw: "large memory requirements" == entire state must be in memory
14:29:42 <merijn> johnw: Which, if you have a world state for a game it has to be anyway
14:29:54 <ReinH> levi: :)
14:29:55 <johnw> true enough
14:29:57 <stolaruk> interesting
14:30:08 <quchen> And iso (seems to be standard-ish) is    type Iso' a b = forall f p. (Functor f, Profunctor p) => p b (f b) -> p a (f a)
14:30:24 <mmat_> levi: I started programming on tintin.
14:30:35 <levi> That reminds me, I keep meaning to go back to the "Cult of the Bound Variable" ICFP programming task.
14:30:36 <merijn> stolaruk: I would argue that this is exactly the type of stuff acid-state is for
14:31:00 <merijn> stolaruk: i.e. persistent mutable state for your program
14:31:03 <bitemyapp> ReinH: I ran out of games on DOS, started writing little hybrid text adventure / roguelike games in GW-BASIC
14:31:05 <mm_freak> i second acid-state for saving game state
14:31:13 <ReinH> bitemyapp: nice :)
14:31:19 <bitemyapp> ReinH: they became increasingly roguelike because that's the only kind of game you can write that is still fun for the creator when you're 8 years old.
14:31:25 <bitemyapp> anything with less randomness is too boring.
14:31:26 <ReinH> Or you could use binary/cereal
14:31:32 <ReinH> bitemyapp: heh
14:32:00 <bitemyapp> ReinH: it gave me a good intuition for why roguelikes are designed the way they are.
14:32:18 <bitemyapp> the creators had limited resources and wanted something that would be challenging/fun/interesting on multiple playthroughs despite relatively perfect knowledge.
14:32:23 <bitemyapp> Zork is really only good for one run.
14:32:32 <bitemyapp> but nethack and rogue? that stuff is forever.
14:32:44 <merijn> bitemyapp: See also Dwarf Fortress :)
14:32:59 <levi> I am scared to try Dwarf Fortress.
14:33:13 <merijn> But the MUD/rogue discussion may be more for -blah :)
14:34:12 <levi> BTW, for someone who's looking for a fun programming task with which to increase haskell skill: http://www.boundvariable.org/task.shtml
14:36:01 <stolaruk> merijn: Thanks for pointing out acid-state, I'll check it out
14:36:45 <kristof> ok
14:36:48 <kristof> Question
14:36:51 <kristof> No, no question
14:37:13 <kristof> Well I guess I was going to ask if there were a good reason to not include subtyping in Haskell
14:37:21 <bitemyapp> kristof: yeah, lots.
14:37:26 <kristof> bitemyapp: Shhhh, not you
14:37:32 <bitemyapp> what. :(
14:37:41 <bitemyapp> but I know the answer :(
14:37:44 <kristof> bitemyapp: we've already talked about this before, I wanted to hear other people's opinions
14:37:56 <kristof> bitemyapp: Fine, go for it
14:37:58 <Cale> kristof: Yes, there are very good reasons
14:37:58 <mm_freak> kristof: yeah, lots
14:38:09 <Cale> It screws with type inference badly, in a practical way.
14:38:15 <kristof> wow, what a consensus
14:38:17 <merijn> It depends on what you mean by subtyping
14:38:27 <merijn> Clearly structural subtyping can be done and is really cool
14:38:30 <mangaba_leitosa> kristof: are you a fan of scala?
14:38:39 <kristof> mangaba_leitosa: not in the slightest
14:38:40 <merijn> I'm not sure why haskell doesn't have structural subtyping, tbh
14:38:52 <kristof> merijn: Like object-oriented inheritance kind of subtyping
14:38:58 <mm_freak> i'm pretty sure that it's the kind of subtyping, where unequal types unify
14:39:10 <merijn> kristof: Note that structural subtyping is very different from OO like "subclassing"
14:39:17 <kristof> Cale: Can you give me an example?
14:39:27 <bitemyapp> kristof: typeclass constraints are composable, you don't need sub-typing anyway.
14:39:30 <hpc> merijn: structural subtyping could get weird with newtypes and class instances
14:39:34 <benmachine> https://twitter.com/pigworker/status/396035730629488640
14:39:46 <hpc> (from my very limited understanding, at least)
14:39:56 <mm_freak> merijn: what is that?
14:39:57 <merijn> kristof: Structural subtyping is "If I have a function foo that works on a record with field A and B and a record that has fields A, B and C, then foo works on this record too"
14:40:04 <merijn> mm_freak: ^
14:40:12 <kristof> bitemyapp: I've just always found it problematic that I have to re-implement functions defined on a typeclass for every instance
14:40:13 <merijn> mm_freak: OCaml has structural subtyping, it's neat :)
14:40:13 <mm_freak> ah
14:40:27 <mm_freak> merijn: well, we have lenses
14:40:31 <benmachine> OCaml does have structural subtyping, it's neat but kind of weird sometimes
14:40:36 <Cale> Well, a proper record system *would* be nice.
14:40:45 <bitemyapp> Cale: proper?
14:40:46 <benmachine> I'm not sad that Haskell doesn't have it
14:40:50 <merijn> mm_freak: I like to call it/think of it as "statically checked ducktyping" :)
14:41:05 <Cale> bitemyapp: i.e. something with row polymorphism
14:41:07 <benmachine> a proper record system that was actually a proper module system, now that I'd like
14:41:09 <hpc> isn't duck typing just tagged data?
14:41:10 <mm_freak> merijn: i think there is too much potential for abuse here
14:41:19 <hpc> aka, what every dynamic typed language has anyway
14:41:21 <merijn> mm_freak: I like abusing things :)
14:41:28 <levi> ML signatures are structure-based, too, IIRC.
14:41:37 <mm_freak> merijn: if i expect vector3 for cross product, then passing a vector4 is simply wrong and should be reported as an error
14:41:41 <kristof> Oh my god, I stirred the beast
14:41:51 <Cale> kristof: Anyway, you might have noticed that in Scala or Java for instance, you end up having to specify the type of everything, including locally defined things
14:41:53 <merijn> Cale: I know, right! I've looked at Ur/Web and row polymorphism looks so cool :(
14:41:53 <bitemyapp> Cale: oh, I just use sum types and prisms.
14:41:55 <hpc> kristof: it's a fun beast
14:42:03 <mm_freak> merijn: and whether it is an error should not depend on whether i have written field names or not
14:42:17 <kristof> Cale: I thought that was simply because the JVM just doesn't have type inference, not because it couldn't *possibly* have type inference
14:42:27 <mm_freak> so this is something i definitely don't want to have in haskell
14:42:33 <Cale> kristof: Type inference has nothing to do with the JVM
14:42:42 <kristof> Cale: The compiler, then
14:42:43 <Cale> kristof: It's something about the language
14:42:46 <kristof> ok
14:42:46 <levi> Elm's records are pretty nice too, though the type errors get a little weird.
14:42:57 <bitemyapp> type inference is semantics, not plumbing.
14:43:07 <bitemyapp> and the ability to do it soundly depends on the semantics.
14:43:15 <kristof> got it
14:43:17 <Cale> kristof: and subtyping is what makes the inference problems hard: you're trying to locate solutions to systems of inequalities of types
14:43:23 <Cale> kristof: rather than equations of types
14:43:27 <bitemyapp> kristof: http://brianmckenna.org/blog/row_polymorphism_isnt_subtyping
14:43:41 <kristof> Cale: Well, what about just inferring the most general type?
14:43:52 <Cale> kristof: and the problem of finding those solutions becomes really hard in practical cases, i.e. exponential time
14:43:57 <kristof> oh, I se
14:43:58 <kristof> *see
14:43:59 <bitemyapp> kristof: variance also makes it insanely hard to get your type hierarchy right. Composable typeclass constraints are saner.
14:44:17 <kristof> :(
14:44:17 <bitemyapp> you can easily write unsound code that type-checks because of variance and subtyping.
14:44:20 <Eduard_Munteanu> kristof: the most general type would be computed anyway
14:44:21 <levi> kristof: You know the mess with Scala generics and variance annotations? That's what subtyping brings you.
14:44:33 <Cale> (type checking is already theoretically exponential time, but for the most part, the bad cases don't appear in real code -- with subtyping, they do)
14:44:47 <bitemyapp> kristof: look at the mckenna post, it's good.
14:45:01 <benmachine> Cale: I thought it was doubly exponential :P
14:45:07 <mmat_> Memories of C++ template metaprogramming.
14:45:12 <Cale> benmachine: well, okay, I was giving a lower bound ;)
14:45:23 <Cale> (on the worst case)
14:45:47 <mm_freak> Cale: what is such a bad case?
14:45:47 <Cale> kristof: However, there's another realisation
14:46:21 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
14:46:22 <lambdabot> t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((
14:46:22 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (
14:46:22 <lambdabot> t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), (((
14:46:22 <lambdabot> (t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
14:46:31 <Eduard_Munteanu> Hah, that still works?
14:46:50 <Cale> (it's actually exponential space, not just time ;)
14:47:14 <mm_freak> ah
14:47:51 <gratimax> Call me a freak, but after working with Scala for a while, variance and generics aren't that bad once you get used to them
14:48:07 <Cale> kristof: But there's another thing:
14:48:41 <Cale> The whole reason that subtyping is popular at all in typed OO languages, is that those languages tend to make the mistake of tying method implementations to the types of the objects.
14:48:53 <kristof> Jesus christ
14:48:55 <mm_freak> gratimax: remembering to call htmlspecialchars() in every potentially dangerous location and never to accidentally forget it is something you get used to as well =)
14:48:59 <pdxleif> What do "generics" have to do w/ subtyping?
14:49:04 <Cale> So, you *need* to make a subtype in order to adjust the method implementation.
14:49:06 <ReinH> > let finnish str = intersperse 'f' str in finnish "Hello world"
14:49:06 <mm_freak> just like you can get used to calling free() in C
14:49:07 <lambdabot>  "Hfeflflfof fwfofrflfd"
14:49:12 <heatsink> Cale, do you have an example of why subtyping is prone to exponential-time type inference?
14:49:22 <quchen> ReinH: Swedish. That's Swedish.
14:49:26 <ReinH> oh right my bad
14:49:29 <bitemyapp> gratimax: you're a freak.
14:49:31 <heatsink> Or the bad cases yo're talking about
14:49:48 <bitemyapp> ReinH: hahahaha
14:50:10 <ReinH> > let swedish = intersperse 'f' in (swedish.swedish) "Hello world"
14:50:11 <Cale> heatsink: Um, I really ought to, but the point at which I investigated this for myself was several years ago. There's a canonical example, but I don't remember it :S
14:50:11 <lambdabot>  "Hfffeffflffflfffofff fffwfffofffrffflfffd"
14:50:12 <pdxleif> not welsh?
14:50:31 <mmat_> Transfering from the OO way of thinking about inheritance and typing to haskell type classes was really hard for me.
14:50:32 <heatsink> haha pdxleif
14:50:39 <Axman6> that'd be l not f no?
14:50:48 * hackagebot pipes-zlib 0.4.0 - Zlib compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.0 (RenzoCarbonara)
14:50:53 <kristof> Cale: Ok, I understand now.
14:50:55 <gratimax> The reason Scala has variance is because it had to be somewhat similar to Java(which has a mess of a type system, we can agree) with inheritance and so forth
14:51:14 <Cale> heatsink: I think the tricky cases all involve things where you have a type constructor applied to a bunch of variables with different bounds on them which might be interrelated.
14:51:25 <kristof> Cale: It's going to take me a while to accept the "The whole reason that subtyping is popular at all . . ." statement but I suspect it's true
14:51:43 <Cale> kristof: Well, yes, that's a bit of a personal opinion of mine.
14:52:00 <Cale> kristof: I'm willing to agree that there are cases where subtyping really does buy you more than that.
14:52:03 <heatsink> Cale, well I'll keep an eye out for it
14:52:21 <Twey> > let { vowels = [('a', 'ä'), ('o', 'ö'), ('e', 'y')]; finnish = map (\x → maybe x id $ lookup x vowels) } in finnish "Hello world"
14:52:22 <lambdabot>  "Hyll\246 w\246rld"
14:52:26 <Twey> Boo
14:52:26 <kristof> Cale: Aren't most useful functions going to be tied to some kind of type, though?
14:52:30 <Twey> > let { vowels = [('a', 'ä'), ('o', 'ö'), ('e', 'y')]; finnish = map (\x → maybe x id $ lookup x vowels) } in text $ finnish "Hello world"
14:52:31 <lambdabot>  Hyllö wörld
14:52:32 <ReinH> Twey: noooo
14:52:33 <kristof> At the very least, a typeclass constraint?
14:52:36 <Cale> kristof: But I find it's quite rare, and also that good OO practice is converging on avoiding such cases anyway.
14:52:48 <bitemyapp> kristof: typeclass constraints yes, specific types, not as much.
14:52:49 <heatsink> kristof, but OO attaches the overloaded function to the _value_
14:52:50 <ReinH> Twey: not bad :)
14:53:00 <Twey> Pretty close
14:53:06 <Twey> Could do with a final -i :þ
14:53:10 <Cale> kristof: Well, imagine an OO language where the types of objects only specified the names and types of their methods.
14:53:15 <kristof> heatsink: That's only an illusion.
14:53:16 <syllogismos> can i have if then else in a where block?
14:53:24 <companion_cube> Cale: like ocaml?
14:53:28 <Eduard_Munteanu> syllogismos: yes
14:53:32 <johnw> you mean, conditional definitions?
14:53:36 <bitemyapp> kristof: it definitely happens but you lose almost all ability for reasoning about your code in a safe way when you stop defining your terms in terms of typeclass constraints.
14:53:38 <Cale> kristof: and when you construct objects of a given type, you just provide the implementations of the methods
14:53:39 <kristof> Cale: I don't follow.
14:53:48 <mmat_> The Google Go language is a bit like that
14:54:02 * bitemyapp grimaces
14:54:02 <Eduard_Munteanu> syllogismos: if-then-else is just an expression, mind
14:54:04 <platz> odersky is experimenting with ways to reduce the combinations of type features in scala... he recently talked about this DOT language which "projects" things like existentials and higher kinded types in terms of OO constructs
14:54:04 <syllogismos> where
14:54:16 <Cale> kristof: The whole point of objects is that they're values whose meaning is determined by the manner in which they respond to messages or methods.
14:54:21 <Cale> right?
14:54:23 <kristof> yes!
14:54:34 * bitemyapp drum rolls
14:54:47 <syllogismos> if (null list) then something = some else something = somethingelse
14:54:54 <syllogismos> I'm getting a parse error
14:55:05 <companion_cube> Cale: such type systems are complicated, sadly
14:55:07 <Cale> kristof: So, what if the type of an object just specified which methods/messages it could respond to and what the types of the parameters and responses would be
14:55:15 <Cale> kristof: and not *how* it would respond to them
14:55:18 <geekosaur> syllogismos, a definition can't be conditional
14:55:28 <amalloy> syllogismos: = isn't an assignment operator
14:55:35 <kristof> Cale: You mean typeclasses. :P
14:55:38 <geekosaur> not a top level one like that, and `let` would be syntactically acceptable but its scope would make it useless
14:55:41 * bitemyapp grins at kristof 
14:55:43 <Cale> kristof: No, I actually mean less than that!
14:55:52 <Cale> kristof: I mean record datatypes :D
14:55:55 <kristof> Interfaces
14:55:56 <kristof> oh
14:56:04 <Cale> (records of functions)
14:56:25 <mmat_> Cale: What you're talking about seems like the type system in Google's Go language.
14:56:43 <companion_cube> or ocaml
14:56:44 <companion_cube> :>
14:56:45 <Cale> mmat_: Maybe, but the type system in Go sucks for other reasons.
14:56:56 <syllogismos> ohh i have to do something = if (null list) then somethingding else somethingelse
14:57:03 <kristof> Cale: I'll be back in an hour or so. Thank you and everyone else for responding to my question
14:57:06 <kristof> :)
14:57:09 <syllogismos> go tit
14:57:10 <Cale> kristof: cool
14:57:11 <kristof> bitemyapp: I'll read that thing you sent me
14:57:16 <bitemyapp> kristof: gut.
14:57:17 <amalloy> yes
14:57:23 <haasn> why is there so much talk about golang in #haskell lately? This channel is about Haskell, not Go
14:57:35 <Eduard_Munteanu> syllogismos: guards may be better
14:57:36 <Cale> mmat_: You can't even write an analogue of  map :: (a -> b) -> [a] -> [b]  in Go.
14:57:58 <Cale> The first thing I do when faces with any new programming language is try to write map for lists.
14:58:20 <bitemyapp> Cale: sounds like NICTA/course :)
14:58:21 <Eduard_Munteanu> syllogismos: something | null list = foo      | otherwise = bar
14:58:26 <Cale> faced*
14:58:32 <Eduard_Munteanu> syllogismos: or just pattern match directly if you can
14:58:37 <platz> records of functions sounds like abstract data type's (or codata) , but then I think it makes pattern matching harder?
14:58:49 <syllogismos> I yeah guards are loking better..
14:59:00 <bitemyapp> platz: I wouldn't call that codata.
14:59:04 <Cale> platz: You can do the style of OO I'm suggesting in Haskell just fine.
14:59:38 <Cale> and yeah, you probably want it to be codata if you're going to make that distinction.
14:59:43 <bitemyapp> records of functions is how you have to do typeclass'ish interfaces in Fay right now.
14:59:52 <bitemyapp> it's...not great?
14:59:56 <Cale> One of the common things to do is to have an object respond to a message with a new/updated version of itself.
15:00:08 <platz> bitemyapp: I only bring that term up from reading this, but I didn't really understand it at all http://www.cs.ox.ac.uk/jeremy.gibbons/publications/adt.pdf
15:00:11 <Cale> and that's sort of fundamentally a corecursive thing to do
15:00:33 <bitemyapp> platz: oh hell, that's a really generic way to use the erm.
15:00:53 <Cale> (i.e. you'll be applying the record constructor, so the guarded corecursion condition will always hold there)
15:00:54 <bitemyapp> platz: I'd only seen codata used for total functional programming against sources of signals/events in Agda et al
15:01:07 <Cale> (but you generally won't be recursing on a subterm)
15:01:42 <`^_^v> does anyone have any suggestions on how to simplify this code? it just doesn't look right to me http://lpaste.net/6074025535497830400
15:01:58 <bitemyapp> Cale: I get how guarded corecursion is related to codata, but how do you connect that to a record constructor?
15:02:19 <Cale> `^_^v: first of all, learn to lay out if/then/else sensibly so that people can read your code ;)
15:02:21 <Cale> if foo
15:02:24 <Cale>    then bar
15:02:26 <Cale>    else quux
15:02:35 <bitemyapp> yeah that's just painful.
15:02:46 <`^_^v> i pretty much just copied the syntax that hlint gave me..sorry
15:02:54 <Cale> That's okay :)
15:03:27 <roboguy_> `^_^v: I don't think it really gives whitespace suggestions
15:03:33 <Cale> You might also consider using a little do-notation rather than bind? I know that some people like to write everything in terms of bind when starting out, but do notation does exist for a reason :)
15:03:45 <bitemyapp> `^_^v: you should try breaking it up a bit.
15:04:06 <bitemyapp> make constituent functions, then try laying out the top-level in do-notation.
15:04:17 <mmat_> I suggest do notation as opposed to bind too, but not a big deal.
15:05:51 <Cale> http://lpaste.net/6074025535497830400
15:06:17 <heatsink> I suggest avoid nesting conditionals and do-notation.  This has more than two levels of nested do and if
15:06:40 <heatsink> As bitemyapp said, you can split it by defining local functions
15:06:42 <stolaruk> `^_^v: Consider using hanging lambdas when you want to bind to a lambda
15:07:21 <stolaruk> for readability
15:07:26 <Cale> Note that the way I laid the code out in my annotation, it's easier to see how the branches of code are related.
15:07:41 <heatsink> stolaruk, is that a linebreak after -> ?
15:08:01 <Cale> I don't think it's *terrible* to have the nested branching and do-notation here, but it might be nice to split this up a little bit.
15:11:16 <stolaruk> heatsink: yep
15:11:29 <`^_^v> thanks guys
15:13:31 <briennetheblue> i wish there was a findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
15:14:04 <subleq> that type signature looks kind of like a monad transformer
15:14:50 <briennetheblue> oh
15:14:53 <briennetheblue> like MaybeT?
15:15:09 <haasn> briennetheblue: http://hackage.haskell.org/package/monad-loops-0.4.2/docs/Control-Monad-Loops.html#v:firstM
15:15:40 <briennetheblue> haasn: thanks, couldn't find it on hoogle
15:21:07 <syllogismos> what funciton takes two numbers and gives me an Ordering?
15:21:25 <Eduard_Munteanu> :t compare
15:21:26 <lambdabot> Ord a => a -> a -> Ordering
15:21:46 <syllogismos> compare
15:22:02 <syllogismos> thanks just searched it in hoogle
15:22:04 <dhrosa> @hoogle Ord a => a -> a -> Ordering
15:22:05 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
15:22:05 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
15:22:05 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:31:36 <Cale> bitemyapp: Oh, well, you might have something like  ball pos vel acc = MyObject { drawObject = ... ; timeStep = \dt -> ... ball ... ; ... }
15:32:10 <Cale> bitemyapp: i.e. defining how the object gets updated over time or in response to events through recursively applying the function which constructs it
15:32:24 <Cale> (sorry I missed your question earlier somehow)
15:32:58 <Cale> bitemyapp: and the reason that's okay, is because you're inside the record constructor
15:33:41 <Cale> (MyObject, in my example there)
15:33:59 <bitemyapp> well I don't quite get it, but I'll meditate on it later.
15:34:21 <Cale> bitemyapp: In other words, you don't expect the recursion here to terminate
15:34:36 <Cale> You just expect it to continue producing new objects from old over time
15:34:40 <mmachenry> Could someone tell me how to get randNums to type properly without that silly line I added to my program? http://lpaste.net/99463
15:34:46 <Cale> and that's the general use case for corecursion
15:35:12 <mmachenry> The other ways I tried gave me errors. I could tell you them but it's probably useless information.
15:35:16 <Cale> things which behave more like operating systems or servers of some sort, where you don't want the program to end
15:35:30 <Cale> (but you certainly want it to make progress)
15:36:32 <hakujin> Cale: does it discard older values over time?
15:36:35 <mmat_> Is there any package in haskell that uses the language of categories (allegories, categories on relations, arrows) to implement a relational database?
15:36:48 <Cale> hakujin: They'll be garbage collected if unneeded...
15:37:13 <Cale> mmachenry: You could stick the type annotation directly on the usage of randNums
15:37:21 <Cale> like  zip (randNums :: [Int]) l
15:37:53 <Cale> mmat_: No, but David Spivak is thinking about such things.
15:38:09 <Cale> mmat_: and has written a bunch of papers
15:38:23 <mmat_> Cale: Thanks for the heads up, i'll check out his literature
15:38:30 <mmachenry> Ah the first one would be good. Thanks.
15:40:03 <Cale> mmat_: there's a talk by him here: http://vimeo.com/12428370
15:40:18 <Cale> iirc, the sound is a bit awful, but the talk is good
15:40:53 * hackagebot hsbencher 1.5.1 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.5.1 (RyanNewton)
15:41:00 <orzo> hello
15:41:13 <orzo> I am trying to make a macro that generates cost centers
15:41:29 <orzo> http://lpaste.net/99464
15:41:53 <orzo> the idea is to be able to use the profiler to gaurontee my test suite has good coverage
15:42:07 <DMcGill> I have a newtype Value, over Int. I'd like unboxed vectors of Values to be (at runtime) identical to be the same as if they were Ints. I can derive Unbox just fine but "derive instance (G.Vector Vector Value)" gives just "parse error on input `instance'". Any suggestions?
15:42:20 <orzo> i wanted to be able to run the tests with profiling and then make sure all the test:number cost centers were hit
15:42:38 <Eduard_Munteanu> DMcGill: they are already Ints at runtime
15:42:39 <orzo> but ghc doesnt seem to like it
15:42:54 <orzo> is there a way to do what i want that satisfies ghc?
15:43:26 <Eduard_Munteanu> DMcGill: also that should be 'deriving', not 'derive'
15:43:38 <lpvn> hey guys, recommend me the best haskell tutorial I can find in the interwebs
15:43:52 <Eduard_Munteanu> lpvn: possibly LYAH if you're starting
15:43:57 <Eduard_Munteanu> @where lyah
15:43:57 <lambdabot> http://www.learnyouahaskell.com/
15:44:01 <Eduard_Munteanu> lpvn: ^^
15:44:03 <orzo> it seems to generate correct haskell and if i run ghc after cpp, then it works, but with the {-# LANGUAGE CPP #-} extension, it seems to balk at expanding the cost center pragma
15:44:15 <DMcGill> Eduard_Munteanu: ah that's it thanks. I know they're the same at runtime, that's why I'm using newtype deriving to convince the type system of that too :)
15:44:29 <Cale> orzo: Are you aware of hpc?
15:44:34 <orzo> no
15:45:26 <Cale> orzo: It's a tool for visualising the extent to which the code in your program was used
15:45:39 <Cale> https://www.haskell.org/ghc/docs/latest/html/users_guide/hpc.html
15:45:48 <lpvn> Eduard_Munteanu: thanks
15:46:50 <orzo> does hpc make my testme: macros unneccessary?
15:46:56 <orzo> cost centers
15:47:04 <Cale> orzo: It produces stuff like this: http://www.haskell.org/wikiupload/6/64/Hpcexample.gif
15:47:43 <orzo> hm
15:47:46 <Cale> yellow means "never evaluated", green means the conditional was always true, and red means always false
15:48:05 <Cale> It also generates tables showing the proportion of your code which was tested
15:48:24 <Hafydd> For some value of "always" and "never".
15:48:25 <orzo> sounds good
15:48:28 <acowley> Why can't the OS X binary of 7.8 be compiled with GCC to avoid the big slowdown? Why would this require the user having GCC later?
15:48:32 <orzo> thanks
15:48:42 <orzo> still think ghc should let me expand cost centers though
15:48:48 <oakwhiz_> Cale: Is Haskell the only programming language to have a tool like hpc?
15:49:14 <Cale> orzo: GHC has a flag you can set to automatically put cost centres everywhere
15:49:55 <levi> oakwhiz_: Most mature languages have code coverage tools.
15:51:11 <Cale> Though really, the usefulness of such things is a bit limited by the fact that it's a very rough notion of whether you're testing everything.
15:52:34 <Cale> If you're writing tests just to obtain coverage, it's very easy to write stupid tests that get you coverage without actually doing much to exercise the range of situations in which a piece of code will be needed.
15:53:14 <c_wraith> specifically, you can cover each edge case individually without covering combinations of them.
15:53:15 <ivanm> Cale: did you see the test-related post on dailywtf.com recently?
15:53:23 <Cale> no
15:53:26 <Cale> I'll have a look :)
15:53:58 <levi> The one with the code under test replaced with a mock? :P
15:54:04 <ivanm> levi: yup
15:54:17 <orzo> im sure you can screw up your tests and have coverage, but i think coverage is a very good indicator
15:54:18 <Cale> http://thedailywtf.com/Articles/But-the-Tests-Prove-it-Works-Correctly!.aspx -- is this it?
15:54:34 <ivanm> yup
15:54:39 <levi> That's the one I was thinking of.
15:55:23 <Cale> lol
15:56:02 <AshyIsMe> so im working on a bot for vindinium and it's working ok, but the code is looking pretty ugly
15:56:05 <AshyIsMe> https://github.com/AshyIsMe/vindinium-starter-haskell/blob/master/src/Bot.hs#L41-L61
15:56:14 <AshyIsMe> is there a better way to do the chaining of the case statements there?
15:57:13 <startling> AshyIsMe: you can do "case (heroes, neutralMine) of ..."
15:57:30 <heatsink> AshyIsMe, you can use pattern guards
15:58:15 <AshyIsMe> ooh the case tuples sounds like it would fit fairly well here
15:58:42 <Eduard_Munteanu> AshyIsMe: Data.Foldable.forM can be applied to 'm (Maybe a)' too, it do away with some case expressions
15:59:17 <startling> AshyIsMe: you can make the whole thing a case actually
15:59:44 <startling> AshyIsMe: case (runt == me || heroLife me <= 20, neutralMine, heroes) of
16:00:06 <startling> that's on the extreme side (and there's probably a nicer way to do it), but it's a good way to "flatten" it.
16:00:20 <AshyIsMe> yeah i like the sound of that
16:00:28 <AshyIsMe> i'll do that and be back later for further tips, cheers
16:01:51 <heatsink> AshyIsMe: http://lpaste.net/7843424195978461184
16:04:42 <DMcGill> Another Vector question: map has type `(Unbox a, Unbox b) => (a -> b) -> Unboxed.Vector a -> Unboxed.Vector b'. Is there a function of type `Unbox a => (a -> b) -> Unboxed.Vector a -> Boxed.Vector b'?
16:05:16 <acowley> DMcGill: I'd use Boxed.Vector.generate for that
16:05:41 <acowley> DMcGill: You could convert the Unboxed to Boxed, then do a Boxed.map
16:05:59 <acowley> DMcGill: But I think I'd go with the generate approach even though it means faffing about with indices
16:06:02 <heatsink> You should be able to convert Unboxed to Stream to Boxed
16:06:14 <DMcGill> generate shouldn't be too hart
16:06:17 <DMcGill> hard*
16:07:05 <heatsink> DMcGill, use 'convert'
16:07:43 <DMcGill> that was surprisingly easy, thanks. I'll get fused away right?
16:07:46 <DMcGill> it'll
16:08:42 <syllogismos> @pl concatMap (\(xs, i) -> zip xs (repeat i)) $ map swap inp
16:08:42 <lambdabot> uncurry ((. repeat) . zip) =<< map swap inp
16:08:56 <syllogismos> whoa.. it existsss
16:09:15 <syllogismos> do people understand pointfree style?
16:09:23 <DMcGill> don't let pl lead you astray
16:09:35 <syllogismos> i came up with the lambda function..
16:09:40 <heatsink> Not sure.  It depends on whether there's a rewrite rule for stream (unstream x)
16:09:57 <DMcGill> a little point-free can be nice - take "compare = comparing getValue <> comparing (Down . getWeight)"
16:10:13 <DMcGill> heatsink: surely that rewrite rule is the whole essence of vector fusion? :)
16:10:19 <acowley> How could you fuse away stream . unstream if they're at different types?
16:10:24 <triliyn> syllogismos: in some cases it's very understandable
16:10:30 <triliyn> In this case, not so much
16:10:31 <startling> syllogismos, concatMap f . map g = concatMap (f . g)
16:10:57 * hackagebot haste-compiler 0.2.11 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.11 (AntonEkblad)
16:10:59 <DMcGill> acowley, heatsink: well I'll benchmark it compared to generate anyway
16:12:38 <AshyIsMe> heatsink: oh wow, that's even nicer. I didn't realise you could use guards for declarations like that
16:13:32 <levi> syllogismos: There's a whole 'school' of functional program design centered on point-free programming and algebraically manipulating programs.
16:13:47 <DMcGill> at some point, point-free programming turns into stack programming
16:14:02 <DMcGill> if you find yourself writing dup and flip lots, consider using forth rather than haskell
16:14:11 <mmat_> DMCGill, exactly
16:14:14 <DMcGill> (dup being join for functions)
16:14:42 <shiona> it's kind of reverse stack programming
16:15:02 <DMcGill> @pl maxMaybe s sM = (maybe id max sM) s
16:15:02 <lambdabot> maxMaybe = flip (maybe id max)
16:15:09 <DMcGill> now that's a pl I put into my program
16:15:15 <DMcGill> it's nice, simple and easy enough to understand
16:15:25 <Rembane> What's a pl?
16:16:23 <mangaba_leitosa> levi: "In the early weeks, complex tacit definitions are torturous to write and next-to-impossible to read; blurred vision and sleepless nights are the occupational hazard of the programmer who dives into tacit J"
16:17:05 <roboguy_> Rembane: a pointless form
16:17:06 <heatsink> Rembane, pointless
16:17:35 <triliyn> mangaba_leitosa: tacit J is awesome
16:17:51 <mmat_> Try to use points free style as much as possible, but stop short of obfuscation and stack manipulation.  Ya I know, that's terrible advice.
16:18:00 <Rembane> roboguy_, heatsink: Sweet.
16:18:32 <triliyn> Better advice: use point-free only when naming your arguments is distracting and not informative
16:19:10 <mangaba_leitosa> triliyn: I read 200 out of 600 pages of "Programming in J" and concluded that my memory is too bad to memorize 200 function names consisting of 2 punctuation marks :-)
16:19:34 <triliyn> mangaba_leitosa: don't memorize them! That's what the dictionary is for!
16:19:42 <levi> Well, I think the Haskell point-free community is more due to Squiggol than J.
16:20:06 <triliyn> But yeah, it is nicer to give things intelligible names
16:20:57 <mangaba_leitosa> triliyn: being unable to write in your language of choice without dictionary causes frustration
16:20:58 <levi> The point-free idea is that you end up building re-usable components and you give *those* names before plugging them together.
16:21:31 <Twey> mangaba_leitosa: But Java programmers manage it :þh
16:21:36 <heatsink> J derives from APL.  I see what you mean about operator names
16:21:40 * geekosaur remembers poking at J a couple times, APL at least had the advantage of most operators being mnemonic for various matrix operations...
16:21:51 <heatsink> Does APL have its own Unicode block?
16:21:56 <geekosaur> yes
16:22:08 <geekosaur> well, no, it's scattered through the various math blocks IIRC
16:22:34 <geekosaur> (see "mnemonic for various matrix operations")
16:23:08 <mangaba_leitosa> heatsink: I have recently discovered that APL has a dedicated section in /usr/share/X11/locale/en_US.UTF-8/Compose
16:24:35 <roboguy_> I always wanted to try APL but I don't think I'd be motivated enough to get past the operator names
16:25:46 * geekosaur does not recall if the quote-quad escape has a character...
16:25:55 <kristof> Cale: ...corecursive?
16:25:59 <geekosaur> (quote-quad does, of course)
16:26:06 <Twey> I think the operator names are relatively sane in APL (as opposed to J)
16:26:24 <levi> kristof: Corecursion is how you operate on codata.
16:26:34 * kristof falls down
16:26:37 <syllogismos> transform :: M.Map Int [String] -> M.Map String Int
16:26:40 <syllogismos> transform inp = M.fromList $ concatMap (\(xs, i) -> zip (map (map toLower) xs) (repeat i)) $ map swap $ M.assocs inp
16:26:49 <kristof> levi: Reading the wikipedia article on it. Reminds me of unfold
16:26:53 <syllogismos> i came up with a function like this, is this good practice?
16:26:54 <Cale> kristof: This isn't a distinction we have in Haskell
16:26:58 <levi> kristof: It's precisely unfold
16:27:39 <levi> Or fold, or something. :P  I get confused which way the arrows point sometimes. :P
16:27:50 <Cale> (Haskell has general recursion, which lets us write programs that don't terminate, so it's not very meaningful to distinguish data and codata)
16:28:23 <Cale> (that don't terminate and also make no progress)
16:28:29 <levi> Stream is the co-data counterpart to List. But they are the same in Haskell.
16:28:33 <heatsink> :t swap
16:28:34 <lambdabot> (a, b) -> (b, a)
16:28:42 <roboguy_> syllogismos: you might want to separate out the toLower part
16:28:59 <Eduard_Munteanu> levi: Streams are expressly infinite
16:29:01 <roboguy_> and have one function that just does the basic M.Map Int [String] -> M.Map String Int conversion
16:29:08 <levi> Eduard_Munteanu: Yes.
16:29:34 <levi> Well, List and Stream are not *precisely* the same in Haskell, I guess.
16:29:35 <heatsink> syllogismos: 'swap' is redundant.  You can write (i, xs) instead of (xs, i)
16:29:56 <Eduard_Munteanu> levi: colists are the same as lists in Haskell, but a costreams isn't a list
16:30:40 <identity> How would I define a newtype wrapper for my monad stack so that I can easily define general computations that would work in both MyMonad and MyMonadT?
16:30:40 <heatsink> syllogismos: Also, zip (map f xs) (repeat i) can be written [(f x, i) | x <- xs]
16:30:50 <levi> We generally use lists as streams, when not writing mathematically precise programs.
16:30:51 <identity> It's wrapping State, essentially
16:31:16 <Eduard_Munteanu> identity: for stacks it's better to deal in terms of Monad* classes
16:31:21 <heatsink> ^
16:31:50 <Eduard_Munteanu> identity: unless the inner bits shouldn't be visible
16:31:53 <Cale> kristof: In Agda and Coq, for instance, when you write a recursive function, the language insists that there is some argument to your function where all the recursive uses of the function in the body are "decreasing" in that argument, in the sense that you're applying the function to some piece of the structure that you matched.
16:32:24 <DMcGill> alternatively: type MyMonad = MyMonadT Identity
16:32:36 <DMcGill> unless I'm missing something
16:32:37 <heatsink> class Monad m => FooMonad m where {- operations available in both MyMonad and MyMonadT -}
16:32:41 <bitemyapp> oh so we're still talking about codata?
16:32:41 <syllogismos> swap (i, xs) is a nice one.. it took me a while :D
16:32:42 <Cale> e.g.  plus (S n) m = S (plus n m)  is okay, because plus is decreasing in the first argument
16:33:00 <Cale> bitemyapp: kristof just brought it up again
16:33:09 <kristof> Saw it in the feed
16:33:15 <identity> oooh, like that. So.. I don't want a newtype wrapper?
16:33:22 <Eduard_Munteanu> identity: also   type MonadMy r w m = (MonadReader r m, MonadWriter w m)
16:33:38 <Cale> kristof: However, if you only allow "structural recursion" like that, you end up being able to prove that all your programs terminate.
16:33:46 <kristof> Cale: sweet!
16:33:46 <Eduard_Munteanu> Which requires ConstraintKinds.
16:33:47 <merijn> identity: That's how State/Reader/Writer/etc are implemented in Haskell
16:33:50 <Twey> Eduard_Munteanu: What's a costream?
16:33:58 <Cale> kristof: This is mostly a good thing, but what about programs that aren't supposed to terminate?
16:34:07 <kristof> Cale: Like lifesupport systems!
16:34:09 <Cale> kristof: Things like servers or operating systems :)
16:34:10 <Cale> right
16:34:36 <levi> Twey: I believe it would be a non-empty list-like type.
16:34:44 <Eduard_Munteanu> Twey: I mean the usual Stream is co- already, there's no inhabited co-less variant in a total language.
16:34:45 <bitemyapp> kristof: quicksort is an example of sub-structural recursion.
16:34:47 <kristof> Cale: Wait, so what did generalized recursion have to do with codata, again?
16:34:49 <merijn> identity: "type State s = StateT s Identity", and then you do "runState x s = runIdentity (runStateT x s)" (the runIdentity gets rid of the "Identity" returned by runStateT)
16:34:53 <Twey> Eduard_Munteanu: Oh, right.
16:35:06 <identity> merijn: Oh, yeah, I remember seeing that, yes.
16:35:07 <bitemyapp> kristof: codata is how you have totality with never-ending stream processing.
16:35:13 <kristof> bitemyapp: I'm just surprised that there are actually totally different kinds of recursion
16:35:19 <Cale> kristof: I'm doing this to set the stage for why we're interested in codata and corecursion
16:35:23 <bitemyapp> kristof: isn't this fun?!
16:35:24 <kristof> Cale: cool
16:35:25 <identity> @hoogle Identity
16:35:26 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
16:35:26 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
16:35:26 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
16:35:26 <kristof> bitemyapp: no
16:35:29 <bitemyapp> kristof: :(
16:35:39 <bitemyapp> well *I'm* enjoying myself.
16:35:41 <kristof> bitemyapp: it secretly is. Anyway Cale, continue
16:35:42 <bitemyapp> Cale: please do continue.
16:35:52 <merijn> identity: "newtype Identity a = Identity { runIdentity :: a }"
16:36:09 <kristof> Cale: Also, I appreciate how you and bitemyapp and loads of other people can sit in here and have the patience to explain such fascinating ideas to laymen
16:36:24 <merijn> identity: i.e. it's the "trivial" monad with "Identity x >>= f = f x" and "fmap f (Identity x) = Identity (f x)"
16:36:33 <Cale> kristof: So, structural recursion is something we do when mapping out of data types -- it's a condition saying how we're allowed to take apart values of that type recursively.
16:36:36 <DMcGill> acowley, heatsink: I've checked and generate is about 20% faster than convert on a vector of length 20k (at least in my code)
16:36:46 <heatsink> Interesting
16:37:13 <heatsink> Are you using unchecked indexing with generate?
16:37:16 <identity> Yeah, I can see that. So I can go ahead and define my own monad stack using a newtype wrapper and generalized newtype deriving, and then define a type synonym for the non transformer, basically?
16:37:20 <Cale> kristof: Codata and corecursion is similar, only the condition is placed on how you map *in* to a codata type -- i.e. how you're allowed to build values of that type, rather than how you're allowed to take them apart
16:37:32 <merijn> identity: Yeah
16:37:34 <DMcGill> heatsink: I wasn't, but I should. That's probably swing it even more in generate's favour
16:37:46 <identity> alright, sweet, I'll give it a spin. Thanks @ merijn & Eduard_Munteanu
16:38:15 <Cale> kristof: and that condition is simply that all the recursive applications the function you're defining have to occur inside of an argument to a codata constructor.
16:38:17 <Eduard_Munteanu> identity: if it's just a monad stack as opposed to something that hides its constituents, you should just use typeclasses
16:38:31 <DMcGill> for an example of a bad pl:
16:38:42 <DMcGill> @pl f j = eachPair j (vws U.! j)
16:38:42 <lambdabot> f = ap eachPair (vws U. !)
16:38:53 <Cale> this ensures that you always keep getting another constructor as you continue evaluating the piece of codata
16:39:03 <DMcGill> that looks fine until you realise that it actually takes ages to work out what it does
16:39:09 <Cale> and never get stuck waiting for the next one to come along
16:39:16 <heatsink> DMcGill: The difference is large enough that it could be due to a redundant vector copy
16:39:39 <kristof> Cale: So it's a guarantee of infinitude
16:39:54 <DMcGill> heatsink: could be. There's absolutely no way I'm going into the core to check though.
16:40:01 <Eduard_Munteanu> kristof: codata is not necessarily infinite
16:40:04 <Cale> Well, you might have some constructor which doesn't have any parameters, and just stops things there
16:40:36 <Cale> But yeah, if you have a codata type like (fake Haskell-ish syntax)  codata Stream a = S a (Stream a)
16:40:44 <Cale> then it guarantees that your streams are really infinite
16:40:50 <kristof> Cale: So I'm picturing a pyramid right now, where you build from the bottom up and you're always guaranteed to end up with a single point if you follow particular rules
16:41:00 * hackagebot Win32 2.3.0.1 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.3.0.1 (BryanOSullivan)
16:41:16 <Cale> Whereas in Haskell, we could write something like
16:41:16 <Eduard_Munteanu> kristof: in a total language, constructing data must provably terminate, while codata might not terminate but it must provably provide a piece of output in finite time
16:41:31 <Cale> x :: Stream Integer
16:41:32 <Cale> x = x
16:42:06 <Cale> A definition like that wouldn't be allowed, because the recursive application of x did not occur under a codata constructor (in this case, the only one is S)
16:42:18 <mmat_> I was always fascinated with the type data Mu a = Mu (Mu a -> a) being used to define a non-recursive type combinator using a recursive data type.  I'm still not quite sure how it works.
16:42:23 <Cale> But you would still be allowed to write:
16:42:31 <mmat_> y-combinator that is
16:42:31 <Cale> ones :: Stream Integer
16:42:37 <Cale> ones = S 1 ones
16:42:54 <Cale> because then your recursive usage occurs inside the application of S
16:43:14 <kristof> ok
16:43:26 <kristof> Starting to understand but it's all a little abstract for me.
16:44:00 <Cale> (I suppose I should say corecursive usage ;)
16:44:24 <Cale> Even though there's no argument to ones which is descending here (It's not even a function)
16:44:44 <Cale> So this isn't structural recursion
16:45:43 <syllogismos> @pl transform inp =  M.fromList $ concatMap (\(i, xs) -> [(map toLower x, i) | x <- xs]) $ M.assocs inp
16:45:43 <lambdabot> transform = M.fromList . (uncurry (flip flip [] . ((:) .) . (<-) . (| x) . (,) (map toLower x)) =<<) . M.assocs
16:45:55 <Eduard_Munteanu> If you write it as   fix $ \ones -> S 1 ones   then you can argue it's structurally *increasing*.
16:46:00 <syllogismos> sorry guys for spamming i'm having soo much fun looking at my creations..
16:46:03 <Cale> So, this gives you extremely powerful not-Turing-complete languages where you're ensured that the evaluation of any piece of data will terminate, and that the evaluation of any piece of codata will result in at least a constructor to match on.
16:46:11 <kristof> Cale: Hrmmmmmmm. Ok.
16:46:42 <kristof> Cale: And these languages are useful for general programming?
16:46:49 <Cale> yes, pretty useful
16:47:25 <spidrd> is there a way to write generic function that takes and/or returns a string-like Type? so just one function that would work with all theee string types (String, ByteString, Text)
16:47:37 <Cale> There are some things which can become awkward to express, but generally every algorithm that you can prove will work will also be admissible.
16:47:51 <levi> syllogismos: You can always /query lambdabot if you want to do something that might get too spammy.
16:48:00 <Eduard_Munteanu> spidrd: see IsString and the OverloadedStrings extension
16:48:11 <bitemyapp> kristof: it's those power / weight tradeoff things.
16:48:37 <Eduard_Munteanu> spidrd: but it won't let you convert among them if you already have one and need the other
16:48:41 <Cale> At the very least, if you can give a constructive termination proof, you can extract the number of steps from that proof and you have yourself an argument to descend on.
16:48:43 <bitemyapp> kristof: right now Haskell is a bit looser with a less expressive type system, but comparatively less oppressive, but as time goes on, we'll find increasingly "nicer" ways to express these proofs which will make it increasingly worthwhile to use languages like this.
16:49:26 <roboguy_> is there a connection here to demonic and angelic bind?
16:49:27 <Eduard_Munteanu> spidrd: generally there's no way to automate that conversion since it involves encoding
16:49:27 <mmat_> Does epigram fall into languages of this category bitemyapp?
16:49:32 <Cale> (But sometimes it sucks to have to actually write out the proof of termination in your language)
16:49:32 <merijn> mmat_: Yes
16:49:42 <bitemyapp> kristof: stuff like CompCert would be a pain in the arse compared to the same project in Idris or Agda - so progress has already been made.
16:49:50 <merijn> mmat_: Although Epigram takes a philosophically different approach
16:50:03 <spidrd> Eduard_Munteanu: I know about both. But where are all the useful string functions that accept IsString? do I have to define them myself?
16:50:22 <Cale> bitemyapp: Er, CompCert is in Coq. Are you saying you consider Coq more practical than Agda? :)
16:50:23 <merijn> mmat_: Epigram is pushed forward by the desire to have type-derived program derivation
16:50:30 <bitemyapp> Cale: you misread me mate.
16:50:40 <merijn> mmat_: i.e. if I write down a type, the compiler should help me write a program that matches it
16:50:42 <Eduard_Munteanu> spidrd: most base libs only accept String, depends on what you need.
16:50:45 <bitemyapp> Cale: `compared to`
16:50:57 <Cale> oh, less
16:50:58 <Cale> hah
16:51:01 <Eduard_Munteanu> spidrd: anything in particular you're using?
16:51:02 <mmat_> merijn: I found that aspect really compelling, that you're working with the compiler to write the program.
16:51:04 <spidrd> Eduard_Munteanu: does any function accept IsString?
16:51:11 <heatsink> merijn, is that the same as proof search?
16:51:13 <Cale> Well, I dunno. I find Coq to be *around* the same as Agda.
16:51:55 <Cale> Agda has nicer modules, but Coq has rudimentary type classes.
16:51:57 <Eduard_Munteanu> spidrd: not many, but if you have a function that accepts Bytestring and you give it a literal "foo", then OverloadedStrings handles the conversion for you through IsString
16:52:08 <merijn> mmat_: FYI, if you're interested in this stuff and know rudimentary type theory (i.e. dependent types and related theory make some sort of sense), I found that Conor's thesis was a really good intro to the ideas
16:52:15 <Eduard_Munteanu> Cale: Agda has rudimentary typeclasses too :)
16:52:22 <Cale> Eduard_Munteanu: Oh, it does now too?
16:52:23 <spidrd> Eduard_Munteanu: nothing in particular. but I wont get far without basic string functions that accept IsString, like words, lines, split, find, head, !!, etc
16:52:24 <Cale> cool
16:52:49 <heatsink> spidrd, the simplest solution is to convert to/from a common format
16:53:22 <Eduard_Munteanu> Cale: the implicits from scope... basically implicits whose inhabitants are searched in the global scope and it only picks one if it's unique.
16:53:41 <roboguy_> actually, is there a canonical library for demonic/angelic bind yet?
16:53:51 <Cale> Ah, it actually tests for uniqueness?
16:53:58 <Cale> That's better than Coq and Idris then :)
16:54:32 <Eduard_Munteanu> Cale: yes, up to some implicits
16:55:01 <bitemyapp> Cale: what you just said reinforces that Agda is nicer :)
16:55:09 <Cale> Well, okay :)
16:55:17 <Cale> I didn't know that it had support for type classes at all
16:56:04 <Cale> Last I tried, Coq and Idris would just pick an instance. iirc, Coq would always pick the last one you defined which matched, and Idris would always pick the first.
16:56:15 <Eduard_Munteanu> Cale: e.g. maybeMonad : Monad Maybe would be a record and you have someMonadicFunction :: {{ M : Monad m }} ...
16:56:31 <Cale> Eduard_Munteanu: yeah, that kind of implicit is certainly good enough
16:57:23 <Eduard_Munteanu> It can also fill in some implicits when searching for the instance, which is handy if your monad is universe-polymorphic.
16:57:42 <Cale> Eduard_Munteanu: The tricky bit is just that you don't really want it to work like other implicits, in that finding something that works isn't good enough, it also really ought to be the unique one in scope.
16:58:05 <Cale> But if they do that too, that's cool.
16:59:01 <ndsuacm_00> :,
16:59:08 <ndsuacm_00> :t (:,)
16:59:09 <lambdabot> parse error on input `,'
16:59:47 <Eduard_Munteanu> Cale: unfortunately it doesn't resolve instance recursively, that's what it doesn't do :(
16:59:54 <Eduard_Munteanu> *instances
17:00:19 <heatsink> Cale: Some of Coq's tactics seem to have arbitrary design choices baked in.  For instance, tactics generate subgoals in a particular order, which Coq programs rely on.
17:00:42 <heatsink> Cale: I've been wondering if this causes tactics to become fixed to an arbitrary design by the need for compatibility with old code
17:00:47 <Eduard_Munteanu> I guess instance search could be a tactic at some point too.
17:00:48 <Cale> Eduard_Munteanu: oh!
17:00:48 <heatsink> Do you have thoughts on the matter
17:01:41 <Cale> heatsink: Yeah, it worries me that dependently typed programs in general, and tactic based constructions in particular seem to be very fragile from a software engineering sort of perspective.
17:02:42 <Cale> They're like Faberge eggs which have been delicately constructed: you know that they'll work once they compile and that they have all the beautiful properties that you want, but alterations might be difficult, and details which seem like they ought not to matter can matter a lot.
17:02:49 <Eduard_Munteanu> Tactics are basically Template Agda, though last I checked you couldn't inspect data declarations.
17:04:03 <Cale> Though I have seen people get some mileage out of the idea that if your tactics are sufficiently general in what they attempt to do, then the proofs become more stable with respect to changes.
17:04:21 <heatsink> That kind of makes sense
17:04:23 <Cale> However, that also seems to fly in the face of proof relevance somewhat.
17:04:38 <Cale> We shouldn't just care that we have a proof, but which one we ended up with.
17:04:39 <spidrd> is agda a general purpose programming language?
17:04:46 <Cale> spidrd: Kind of
17:05:20 <Cale> spidrd: It's much more geared to being a proof assistant than a programming language, but the lines between these are very blurry.
17:05:48 <mgsloan> I've heard that called Chilpala style.  I think he might have popularized using a "crush" tactic to take care of most of the proof, and then just working in LTac.  Effective, but yeah, a bit ugly
17:06:06 <shergill> if a package has been uploaded to hackage, is that a guarantee that at some point in the past it did build as per 'cabal build'?
17:06:14 <Eduard_Munteanu> spidrd: it's pretty much inspired by Haskell as far as syntax goes, and you can FFI to Haskell, C or JS, but there are very few libraries for programming.
17:06:40 <heatsink> Cale: What is the concern there?  Robustness across tactic implementations?  Comprehensibility?
17:06:45 <shergill> (i.e., at the time of uploading)
17:06:48 <Cale> heatsink: yes :)
17:07:22 <heatsink> okay
17:07:29 <Eduard_Munteanu> Regarding the syntax bit you could say Agda is to Haskell what Coq is to ML.
17:07:39 <dcoutts_> shergill: no
17:07:42 <Cale> heatsink: From a HoTT sort of perspective, tactic-based proofs are absolutely fine when you're giving something which is a mere proposition.
17:08:01 <dcoutts_> shergill: authors can upload without ever testing if they really hate their users :-)
17:08:23 <dcoutts_> shergill: but it does mean it's highly likely it did build
17:08:28 <spidrd> Eduard_Munteanu: lack of libraries ignored, just as a language is agda meant to be used for general purpose programming?
17:08:29 <Cale> heatsink: But in general, proofs are algorithms, and which algorithm the tactics gives you can matter for things like performance, or even correctness (if not everything about correctness is encoded in your types)
17:08:45 <heatsink> Hmm, right
17:08:56 <hpc> spidrd: it's "meant to be used" for both proofs and real programs
17:09:03 <hpc> in practice the latter is ignored completely
17:09:19 <Cale> Well, I wouldn't say *completely*
17:09:29 <Eduard_Munteanu> spidrd: I'd rather say Agda is an experiment aimed to bring dependent types to programming, as well as being a theorem prover.
17:09:29 <Cale> There have been some fancy attempts at I/O in Agda :)
17:09:51 <Cale> But yeah, they're experimental :)
17:10:33 <Eduard_Munteanu> IO is sort of fine, the syntax and boilerplate tends to be annoying.
17:11:08 <Eduard_Munteanu> The stdlib doesn't use "typeclasses" for one thing.
17:11:49 <Eduard_Munteanu> You can define stuff like do-notation inside the language but it's rather non-trivial to make it work like Haskell's.
17:12:10 <Cale> It's entirely reasonable that we could translate everything that Haskell does as far as I/O into Agda, but 1) some of that might be considered deficient from the perspective that Agda lets your types express a whole lot more about what's going on, and 2) it's a lot of work that hasn't been done
17:12:17 <mmat_> You can declare const static primitives in C++ and if your compiler supports partial specialization it's possible to get a kind of dependent type.
17:13:29 <spidrd> Eduard_Munteanu: thanks
17:13:36 <spidrd> appreciate all the info
17:13:37 <shergill> dcoutts_: ok. i've taken over maintainership of liboleg and have been trying to get it to build. it's complaining about <http://okmij.org/ftp/gengo/Symantics1.hs>. specifically, in the definition of 'Abstract' class. but i don't see how it ever could've worked
17:13:49 <Cale> heatsink: Oh, and another thing that can really sneak up on you: the precise terms which are given for definitions can also matter very much, even amongst functions which are extensionally equal.
17:14:12 <heatsink> You mean like variable names?
17:14:34 <Cale> heatsink: What I'm referring to is that because you have types which can depend on terms
17:14:43 <Cale> checking that types match can involve evaluation
17:14:56 <enthropy> shergill: because ghc changes
17:15:13 <Cale> and then the precise way in which functions have been defined can affect the ability to do the partial evaluation which is necessary
17:15:13 <heatsink> Hmm
17:15:52 <Cale> You need to do evaluation of functions which are applied to variables whose values won't be known until runtime.
17:16:15 <Eduard_Munteanu> For plain data a total language can use strict and non-strict semantics interchangeably
17:16:17 <shergill> enthropy: sure. that's always one of the variables, but not being as intimate with ghc changes, i'm somewhat baffled. will make a paste, highlighting issue
17:16:30 <enthropy> where is import CC_Frame?
17:16:34 <Cale> So, that's one sense in which dependent typing is scary from a software engineering perspective -- functions often aren't as black-box as you'd like that way.
17:17:14 <Cale> Whether your addition on natural numbers recurses on the left or right argument can somewhat stupidly actually matter.
17:17:16 <heatsink> Cale: I thought type systems made it unambiguous what terms are "automatically" judged equal versus which require a proof of equality
17:17:44 <Cale> heatsink: They do, the equality which matters while typechecking is judgmental equality
17:17:59 <Cale> and which judgmental equalities you get depend on the precise definitions you give
17:19:21 <Cale> Evaluating whether two things are judgmentally equal is meant to be "easy", in that it doesn't involve any recursion -- it more or less just unfolds all the definitions and sees if things match.
17:19:49 <Cale> But that also makes it brittle to changes in the definitions which don't otherwise affect program behaviour
17:20:55 <shergill> enthropy: it's provided by cc-delcont. http://hackage.haskell.org/package/liboleg-2010.1.10.0/docs/src/Language-Symantics1.html is the actual file i'm trying to compile
17:21:33 <Cale> Maybe there will be some additional notions which can be added to make intensional type theory "more extensional" without forcing people to give complete proof trees.
17:22:28 <hpc> but not completely extensional :(
17:22:35 <enthropy> shergill: there's no problem getting the Abstract class to work here
17:22:40 <Cale> (ETT "solves" this problem by making type checking undecidable)
17:23:08 <enthropy> it's the instance that's the problem
17:23:17 <kazagistar> I have a somewhat complex 80 line program which is taking forever to run, and I have no idea why... how can I find out why?
17:23:45 <Cale> kazagistar: You could turn on profiling and see where it's spending all its time
17:24:20 <darthdeus> this is probably dumb question ... but is / on integers considered a binary operation in linear algebra, since it almost never returns an integer?
17:24:21 <apples`> i'm reading through https://www.fpcomplete.com/user/bartosz/understanding-yoneda , but i've run into a bit of a block right above figure 7. are we defining r = f?
17:24:21 <Cale> kazagistar: and/or run the program with +RTS -xc and then the exception generated when you Ctrl-C out will result in a cost-centre trace
17:24:41 <Cale> darthdeus: You mean div?
17:24:52 <darthdeus> no i mean / as in normal math /
17:24:55 <Cale> darthdeus: Or you mean the map Integer -> Integer -> Rational
17:25:07 <darthdeus> yeah sometihng like that
17:25:09 <Eduard_Munteanu> darthdeus: it is a binary operator, but not an algebra
17:25:19 <Cale> It's not a binary operator
17:25:26 <Cale> by some definitions of operator :)
17:25:29 <mmat_> darthdeus: in linear algebra multiply and division are scalar operators on vectors
17:25:29 <shergill> enthropy: you don't get the "Expecting one more argument to `c'" error at line 36?
17:25:36 <greedo> I am having a type problem
17:25:42 <Cale> Usually an n-ary operator on a set A is a function A^n -> A
17:25:43 <dcoutts_> shergill: my guess would be that Oleg was relying on some detail of the impl of TypeFamilies from the early days
17:25:47 <enthropy> shergill: just add a kind signature
17:25:48 <mmat_> {1,2,3} * 2 = {2,4,6}
17:25:52 <dcoutts_> shergill: but I've not looked at the error
17:25:53 <enthropy> type family I (lab :: k -> k) (btyp :: BTyp) :: k
17:25:53 <spidrd> cnxy yb.
17:26:05 <darthdeus> hmm
17:26:09 <enthropy> dunno why you want to take over that package
17:26:18 <greedo> http://lpaste.net/5544860980237828096
17:26:28 <heatsink> Cale: I'm trying to understand how the problem can happen.  You could use (1+x) interchangeably with (x+1).  If this is done in non-dependent situations, or in situations where x reduces to a constant, it works as expected.  If the code is reused in dependent types, you will encounter silly proof obligations.
17:26:28 <Cale> darthdeus: It also is missing (a,0) from its domain
17:26:30 <Eduard_Munteanu> Cale: isn't that called an universal algebra of type n, IIRC?
17:27:10 <dcoutts_> shergill: what is the kind of I?
17:27:17 <shergill> enthropy: gives me an excuse to get to know some of the techniques there on a more first-hand basis
17:27:29 <heatsink> And so the way you write your code depends on the order of operands to + in other definitions, which shouldn't matter
17:27:31 <enthropy> http://lpaste.net/99472 compiles and seems to do the right thing
17:27:34 <enthropy> shergill: ^^
17:28:09 <Cale> Eduard_Munteanu: Maybe... usually the words "universal algebra" are used to denote a whole branch of mathematics dealing with what you can prove about structures that consist of a set together with a bunch of k-ary operations (for various k) on that set, and a bunch of universally quantified equational laws
17:28:38 <enthropy> lots of oleg stuff was done can be rearranged to take advantage of newer extensions
17:29:17 <enthropy> err, it was done before those extensions existed
17:30:42 <Eduard_Munteanu> Is there a file copying function in 'unix' or System.*?
17:30:44 <shergill> enthropy: gotcha
17:31:03 <Cale> Eduard_Munteanu: For example, you might formulate a group as a set G together with a nullary operator e: 1 -> G, a unary operator i: G -> G, and a binary operator m: G^2 -> G such that ...
17:31:49 <greedo> the issue is with (splitOn "," "test,cool,yes,bod") !! r
17:32:00 <Cale> (and each of the laws has the form "for all x_1, ..., x_n in G, <some equation involving only the x_i and the operators>"
17:32:03 <Cale> )
17:32:39 <greedo> r is a randomly generated number
17:32:40 <shergill> dcoutts_: i would think (* -> *) -> * -> * ? stating that gives me another error, so i'm not sure if that's completely correct, but it's at least progress
17:32:56 <heatsink> Cale: Thanks for describing what you've observed.  Since I've only done small exercises with dependent types, I didn't know how DT affected large programming projects.
17:33:08 <dcoutts_> shergill: good luck!
17:33:10 <shergill> it wasn't clear to me that adding a kind signature was the thing to do
17:33:14 <Cale> heatsink: I don't want to come off as overly negative though
17:33:16 <shergill> so thanks enthropy
17:33:39 <Cale> heatsink: For the most part, the stuff that dependent types give you is *very* good from a software reliability standpoint.
17:33:50 <greedo> I feel I just have the type wrong
17:33:59 <Cale> heatsink: But the maintainability aspects are perhaps less hammered out.
17:34:09 <Eduard_Munteanu> Hm, there's System.Directory.copyFile. The standard FilePath stinks though. :(
17:34:21 <levi> heatsink: Have you watched any of the recent Idris talks? They're entertaining, and at least border on practical matters.
17:34:40 <Eduard_Munteanu> Are Strings like that fused away somehow?
17:35:21 <Cale> heatsink: Of course, in a real setting, you might work in a dependently typed language and yet choose not to attempt to express absolutely everything in your types, and manage to avoid a lot of the pitfalls I've mentioned.
17:35:22 <Eduard_Munteanu> e.g. converting Text to String to pass it to a stdlib function
17:35:40 <Cale> (i.e. you could just use the language like Haskell with some fancier types when you really want them)
17:35:48 <heatsink> levi, I saw one where the speaker used editor features to interactively generate a bunch of list functions from their types
17:36:02 <Cale> That was probably Conor McBride
17:36:07 <Cale> (but maybe not?)
17:36:12 <shergill> enthropy: thanks for the lpaste. had missed your message earlier
17:36:15 <levi> Yeah, most likely.
17:36:16 <Cale> Or Idris, hmm
17:36:26 <Cale> I dunno :)
17:36:28 <heatsink> He started out with a type system example
17:36:28 <levi> Oh wait, no.
17:36:35 <heatsink> involving a child's toy with blocks and holes
17:36:42 <greedo> but is there a diffence between Int and Integer?
17:36:48 <Cale> Okay, probably not what I was thinking of
17:36:57 <Cale> greedo: Int is machine ints
17:37:06 <levi> I'm thinking of the ones Edwin Brady has been doing.
17:37:11 <Cale> greedo: Integer is integers which are arbitrarily large
17:37:11 <Eduard_Munteanu> @src Integer
17:37:11 <lambdabot> data Integer = S# Int#
17:37:11 <lambdabot>              | J# Int# ByteArray#
17:37:32 <mmat_> Is it the video with Edwin Brady that comes up first on youtube?
17:37:35 <Cale> greedo: (and which reduce to being machine ints when they remain small)
17:37:40 <heatsink> Cale: Right, part of using the type system effectively is figuring out what's worth proving
17:37:50 <kazagistar> oh... it was "freezing" because I wasnt flushing the prompt...?
17:38:04 <Eduard_Munteanu> Where the S# wraps the usual unboxed Int and J# is used for larger numbers that require going through libgmp
17:38:14 <levi> He's done several recently. I watched one in the last couple of days where he was speaking to a haskell users's group.
17:38:18 <gelisam> hi! I know this sounds like a dumb idea, but is it possible to use unsafeCoerce to remove a typeclass constraint?
17:38:22 <greedo> Cale: thank you I used randomR but I think it could be Int or Integer
17:38:31 <Cale> gelisam: Only if you want to crash!
17:38:45 <heatsink> levi, I probably haven't seen it
17:38:48 <Cale> gelisam: That typeclass constraint is really a function parameter
17:38:52 <gelisam> it didn't crash, but it gave the wrong answer
17:38:55 <Cale> hah!
17:39:05 <mmat_> lol, that's even worse
17:39:18 <gelisam> so I could coerce SomeNullaryConstraint => a to () -> a ?
17:39:21 <Cale> gelisam: Well, that's probably interpreting a function value as an Integer or some weird stuff like that
17:39:25 <levi> Thus the "unsafe" bit in the name. :)
17:39:29 <Cale> gelisam: no
17:39:46 <roboguy_> gelisam: nullary constraint?
17:39:52 <Eduard_Munteanu> gelisam: you're better off making a stub instance for the missing thing
17:39:53 <heatsink> gelisam: Some values can accidentally look like other, unrelated values at run time.  Only unsafe coercions will reveal that.
17:39:56 <Cale> also, yeah, wtf is a nullary constraint?
17:40:09 <Eduard_Munteanu> ()  :)
17:40:21 <gelisam> I'm trying to find a use for the new NullaryTypeClasses in ghc 7.8
17:40:29 <Eduard_Munteanu> () => ...
17:40:35 <Cale> gelisam: You can't coerce away constraints because whenever you have a value of type  Foo a => ..., it's really a function FooDict a -> ...
17:41:03 <Cale> gelisam: where FooDict a is some record type containing the method implementations given by an instance of the class (or constructed out of many instances)
17:41:10 <heatsink> gelisam: Try this in GHCi:   (unsafeCoerce () :: Bool) == False
17:41:14 <Eduard_Munteanu> A nullary typeclass isn't quite the same thing as a nullary constraint.
17:41:40 <greedo> Cale: no, I need Int
17:41:41 <gelisam> okay, Nullary typeclass then.
17:42:19 <gelisam> but if the typeclass is really a function at runtime, can I use unsafeCoerce to obtain the function? if I don't plan to use the argument, then maybe it won't crash?
17:42:37 <Cale> gelisam: Oh, possibly there's some way
17:42:47 <greedo> Cale: like so -> http://lpaste.net/5544860980237828096
17:42:48 <Cale> I didn't realise that extension was actually being implemented
17:43:03 <Cale> greedo: sorry, what?
17:43:13 <Eduard_Munteanu> gelisam: you could just make a wrapper function that used a newtype with a fake instance for whatever typeclass your data is missing
17:43:24 <enthropy> there's a difference between `class (X ~ Y) => A' and  type A = (X ~ Y)?
17:43:25 <Cale> greedo: I was answering your question about the difference between Int and Integer, I didn't see your original question, I guess.
17:43:36 <greedo> Cale: using the random Int to select from a list
17:43:49 <greedo> Cale: yes, I got that working
17:43:57 <enthropy> besides the latter working in a released ghc
17:44:03 <Cale> greedo: yeah, unfortunately !! takes an Int
17:44:08 <roboguy_> hmm, what would a nullary type class be used for?
17:44:14 <greedo> Cale: yes
17:44:27 <greedo> Cale: not an IO Int
17:44:32 <Cale> gelisam: It would be smarter just to write the instance of that class.
17:44:55 <Cale> greedo: oh, er, that's not the unfortunate bit :)
17:45:07 <gelisam> in the ticket which introduced nullary typeclasses, simonpj said Nullary type classes did not look super useful, but that he agreed to add them because they removed an artificial limitation
17:45:10 <Cale> greedo: It's just unfortunate that they didn't go with Integer for that
17:45:26 <greedo> Cale: so I did r <- rollDice, where r is IO Int
17:45:27 <Eduard_Munteanu> enthropy: things for which X ~ Y applies aren't automatically As.
17:45:28 <Cale> greedo: since one can easily define lists which are much longer than 2^32 elements
17:45:33 <Cale> greedo: yep, that's right
17:45:54 <Cale> greedo: You'll have to execute rollDice to get the Int result like that.
17:46:09 <Eduard_Munteanu> enthropy: also, the 'type' one is a type (constraint) synonym so the usual restrictions apply
17:46:19 <Cale> gelisam: Yeah, they're really not all that useful
17:46:49 <gelisam> so far, I agree!
17:46:50 <greedo> Cale: ok and then (splitOn "," "test,cool,yes,bod") !! r should work I think
17:46:55 <enthropy> Eduard_Munteanu: the usual restrictions are just "type synonyms must be fully applied", no?
17:47:13 <shachaf> Wait, NullaryTypeClasses is in GHC 7.8?
17:47:20 <Cale> gelisam: But you could use them in a library to add some red tape to certain definitions, where the user would have to write an (empty) instance of some nullary class just to say that they were aware of certain caveats regarding that stuff, or something.
17:47:21 <roboguy_> you couldn't use nullary type classes to imitate some kind of more advanced module system could you?
17:47:23 <thoughtpolice> shachaf: correct
17:47:26 <shachaf> And, uh, I wrote the extension?
17:47:27 <shachaf> Hm.
17:47:28 <Eduard_Munteanu> enthropy: yeah, also they can't be instances unless TypeSynonymInstances
17:47:29 <shachaf> I forgot about that.
17:47:42 <thoughtpolice> i wonder in retrospect if it should have just been part of MPTCs
17:47:42 <Cale> greedo: yes
17:47:47 <greedo> Cale but I get Expected type: [Int]
17:47:53 <Cale> greedo: Oh, you left out some parens
17:47:56 <shachaf> thoughtpolice: I think so.
17:48:07 <shachaf> i,i RelevantTypeClasses, AffineTypeClasses, LinearTypeClasses
17:48:23 <Cale> greedo: return is just an ordinary function, not a keyword, and functions bind more tightly to their arguments than any infix operator
17:48:28 <heatsink> class EnableUnsafeCoerce where unsafeCoerce :: a -> b
17:48:29 <studmuf> Hi guys I working on this problem and I'm looking for some pointers as to how to implement it http://lpaste.net/99474
17:48:29 <gelisam> shachaf: yup, it's in! congratulations!
17:48:31 <mmat_> LinerTypes?
17:48:33 <Cale> greedo: So what you wrote was (return ...) !! r
17:48:37 <Eduard_Munteanu> enthropy: (classes can be parametrized by constraints as well)
17:48:38 <shachaf> Oh, I guess monoidal wrote it.
17:48:42 <mmat_> Haskell has Linear type extension?
17:48:43 <greedo> Cale: correct
17:48:56 <Cale> greedo: when what you want is  return (... !! r)
17:49:16 <heatsink> Hmm.  class EnableUnsafeCoerce; unsafeCoerce :: EnableUnsafeCoerce => a -> b
17:49:18 <Cale> greedo: just moving the !! r inside the parens should do
17:49:58 <greedo> Cale: so return (splitOn "," "test,cool,yes,bod" !! r)
17:50:02 <Cale> yep
17:50:09 <enthropy>  type family EnableUnsafeCoerce :: Constraint; unsafeCoerce :: EnableUnsafeCoerce => a -> b
17:50:13 <Eduard_Munteanu> enthropy: another one could be you can't recurse in type synonyms, so for more complex tricks you might need a typeclass to compute constraints for you instead of a type synonym or type family
17:50:29 <Cale> greedo: You might want that (1,3) in rollDice to be (0,3)
17:50:47 <Cale> greedo: your list will have 4 elements, and they'll be numbered 0 through 3
17:50:59 <ColdSauce> why is the Haskell Platform 1gb big?
17:51:15 <Cale> ColdSauce: Because wow, many software, much library
17:51:28 <ColdSauce> ohhh
17:51:29 <Cale> and 1gb isn't all that much these days
17:51:31 <ColdSauce> that's the library
17:51:31 <enthropy> profiling libraries double the size probably
17:51:39 <ColdSauce> haha I thought I was downloading the compiler
17:51:42 <ColdSauce> I was about to say..
17:51:42 <greedo> Cale: indeed, I still did something wrong, r <- rollDice, Expected type: [Int] Actual type: IO Int
17:51:52 <Cale> It also includes GHC, whose installed size is around 500MB or so
17:52:09 <Cale> (but it also includes a fair number of libraries)
17:52:11 <Eduard_Munteanu> That's a bit awful, why is it that large?
17:53:42 <Cale> cale@ender:/usr/local/lib/ghc-7.6.3$ du -sh
17:53:43 <Cale> 765M	.
17:54:00 <Cale> It's probably because everything is statically linked
17:54:15 <Cale> -rwxr-xr-x  1 root root 51378722 Sep  2 21:48 ghc
17:54:23 <greedo> Cale: any ideas?
17:54:23 <Eduard_Munteanu> Wow, is that still the case? Even for GHC itself?
17:54:26 <ColdSauce> should I install the GLUT library?
17:54:37 <Cale> Eduard_Munteanu: well, why not?
17:54:45 <ColdSauce> oh man I can't wait to learn haskell!
17:55:03 <Cale> greedo: Can I see what you have now?
17:55:20 <kazagistar> I have a data structure called NGram that is read out of a file via a function (readSongs :: String -> IO (NGram String)). However, it seems to be rereading the structure each time I try to access it. How do I make it not do that?
17:55:21 <Eduard_Munteanu> Cale: I thought the static linking was meant to make it easier to move executables built by GHC to other machines, but GHC itself...
17:55:26 <Cale> greedo: oh, your type signature for balls is incorrect
17:55:51 <Cale> greedo: If you're running an IO action, the thing you're writing is certainly an IO action (or something fancy built in terms of IO actions)
17:56:11 <Cale> Eduard_Munteanu: Well, ghc is built by ghc :)
17:56:22 <startling> kazagistar, what problems are you seeing?
17:56:24 <greedo> Cale: http://lpaste.net/5544860980237828096
17:56:41 <Cale> greedo: Yeah, balls :: IO String
17:57:23 <greedo> Cale: yes, that was it, thank you so much
17:58:00 <Eduard_Munteanu> Cale: still, it should be reasonable to set a proper RPATH and use only dynamic libs
17:58:16 <Cale> Eduard_Munteanu: possible, but I'm not sure it'd buy you all that much
17:58:48 <Cale> I don't really see the point of dynamically linking Haskell stuff in general. At least, until we've taken over the world to the extent that C has.
17:58:53 <Eduard_Munteanu> Cale: how many executables are there? ghc, ghci... perhaps others may creep in and increase the size?
17:59:20 <Cale> haddock is about as large as ghc
17:59:30 <Cale> then there's a whole bunch of smaller ones
18:09:30 <greedo> Cale: almost there
18:11:29 <greedo> Cale: Expected type: ReaderT Bot IO String, Actual type: IO String
18:11:58 <greedo> ah, but type Net = ReaderT Bot IO
18:12:04 <startling> greedo, liftIO it
18:12:07 <startling> :t liftIO
18:12:08 <lambdabot> MonadIO m => IO a -> m a
18:13:11 <greedo> startling: ?
18:13:31 <startling> :t liftIO :: IO String -> ReaderT () IO String
18:13:31 <lambdabot> IO String -> ReaderT () IO String
18:13:41 <greedo> oh
18:14:33 <startling> lift would work also.
18:14:43 <startling> :t lift :: IO String -> ReaderT () IO String
18:14:44 <lambdabot> IO String -> ReaderT () IO String
18:14:54 <mmat_> :info MonadIO
18:15:46 <startlebot> mmat_: class MonadIO m where liftIO :: IO a -> m a
18:16:11 * hackagebot iteratee 0.8.4.4 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.4 (JohnLato)
18:16:55 <gelisam> turns you can cast (SomeNullaryConstraint => a) to (() -> a) after all
18:17:43 <greedo> startlebot: how would it work in my example?
18:18:03 <greedo> startling: how would it work in my example?
18:18:14 <greedo> startling: http://lpaste.net/edit/5544860980237828096
18:18:17 <startling> greedo: that error you pasted says that an expression has type IO String when it should have type ReaderT Bot IO String.
18:18:31 <greedo> correct
18:18:58 <startling> greedo: hm, there's a couple things going on here.
18:19:34 <startling> greedo: `balls' has an incorrect type annotation, first of all
18:19:40 <greedo> startling: http://lpaste.net/5544860980237828096
18:19:50 <greedo> that's what I think you are saying
18:20:01 <startling> greedo, nope.
18:20:07 <greedo> oh
18:20:15 <startling> let me paste a correction.
18:20:43 <gelisam> I found a use for NullableTypeClasses: https://gist.github.com/gelisam/8816360
18:21:01 <startling> greedo, I think this is correct: http://lpaste.net/5544860980237828096
18:21:23 <greedo> oh
18:22:00 <startling> "lift" turns an IO x into an m IO x for any m that implements the MonadTrans typeclass.
18:22:04 <greedo> startling: yes, that was correct
18:22:11 <startling> ReaderT Bot is one of these m.
18:22:47 <greedo> thank you so much startling
18:22:53 <startling> greedo: no problem!
18:23:06 <greedo> I need to read up on Transformers
18:23:36 <gelisam> shachaf: do you approve of my abuse of your new ghc feature? :)
18:24:21 <greedo> I am working on an irc bot
18:24:34 <greedo> it will do stock quotes too
18:24:42 <greedo> that will be a fun task
18:25:30 <the_berserker> @pl \x -> let x = f (f (f x))) in x
18:25:30 <lambdabot> (line 1, column 26):
18:25:30 <lambdabot> unexpected ")"
18:25:30 <lambdabot> expecting variable, "(", operator, ";" or "in"
18:26:15 <the_berserker> @pl \f -> let x = f (f (f (f x))) in x
18:26:16 <lambdabot> fix . ap (.) (ap (.) (join (.)))
18:26:46 <the_berserker> @pl let fix f = f (fix f) in fix
18:26:46 <lambdabot> fix (ap id)
18:27:25 <the_berserker> > (fix (ap id)) (1:)
18:27:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:29:01 <sccrstud92> johnw: ping
18:29:14 <mmat_> greedo: Where are you getting the stock quotes from?  I think Yahoo has a nice HttpRequest based api for grabbing that information.
18:29:42 <greedo> mmat_: oh, great
18:30:07 <greedo> mmat_: I was going to try investing.com
18:30:27 <the_berserker> @pl fix fix
18:30:27 <lambdabot> fix fix
18:30:50 <greedo> wow, liftIO is pretty cool
18:32:44 <mmat_> greedo: http://www.gummy-stuff.org/Yahoo-data.htm
18:33:33 <the_berserker> @pl \x -> x x
18:33:33 <lambdabot> join id
18:34:56 <the_berserker> @pl \h f w -> f (h w) w
18:34:56 <lambdabot> flip flip id . (ap .) . flip (.)
18:35:33 <the_berserker> @pl \x _ -> x
18:35:33 <lambdabot> const
18:39:20 <mmat_> @pl \a b x -> (b a) x
18:39:20 <lambdabot> flip id
18:44:47 <the_berserker> @pl \x y z -> x y (y z) (x z)
18:44:47 <lambdabot> flip =<< (ap .) . ((.) =<<)
18:47:18 <mmat_> @pl \x y z -> (x z) (y z)
18:47:18 <lambdabot> ap
18:48:14 <mmat_> @pl \x y -> x
18:48:14 <lambdabot> const
18:54:00 <mmat_> @pl (\x y z -> (x z) (y z)) . (\x y -> x)
18:54:00 <lambdabot> (.)
18:55:07 <frx> > flip id 10 show
18:55:08 <lambdabot>  "10"
19:00:00 <dhrosa> @pl flip id 10 show
19:00:01 <lambdabot> show 10
19:00:07 <augur> ahahahaha
19:00:09 <augur> https://raw.github.com/maxpow4h/flip-plus/master/Control/FlipPlus.hs
19:01:44 <Cale> augur: Edward should include this in the next Lens!
19:01:56 <kristof> Oh that's right, Yahoo does have a nice stock API
19:02:15 <augur> Cale: :x
19:02:19 <kristof> I keep forgetting that Yahoo is pretty awesome as a company but no one cares because Google dominates every market Yahoo has its toes in
19:02:28 <mmat_> kristof: http://www.gummy-stuff.org/Yahoo-data.htm is really easy to use for prototype purposes.
19:02:56 <geekosaur> not sure I'd call them "awesome" but then I mostly see them buy and kill stuff
19:04:30 <kristof> geekosaur: I suppose what I mean is that they're unjustfiably ignored as much as they are
19:08:27 <byorgey> augur: wat
19:09:24 <kristof> one day, categorical duals will all be bestowed more colorful names than simply prefixing with co-
19:09:31 <kristof> Cofree comonad, you shall have your revenge...
19:10:25 <augur> byorgey: :)
19:15:25 <pavonia> Unfortunately, that naming scheme doesn't work well for Europeans
19:16:20 <dwcook> pavonia, why's that?
19:17:09 <dwcook> augur, can that code be simplified with TH?
19:17:10 <pavonia> Because it would be !"§$%& which doesn't work as an operator name
19:17:34 <dwcook> pavonia, oh, I thought you were referring to co-.
19:17:54 <augur> dwcook: lol
19:18:15 <augur> thats a silly question :)
19:18:26 <dwcook> augur, how so? :P
19:18:47 <augur> its a joke file that isnt supposed to be anything serious
19:18:54 <augur> so the answer doesnt matter
19:18:57 <dwcook> Oh I figured as much
19:19:02 <augur> tho it can be simplified with dependent types
19:19:04 <augur> i dont know about TH
19:19:43 <augur> in fact, the DTP version can be generalized to arbitrary arity functions
19:19:57 <dwcook> I mostly thought TH because I can't think of a better way to do variable binding names.
19:20:10 <dwcook> Though I'm not familiar enough with TH to know if it permits that.
19:20:49 <dwcook> Though if we were in PHP, we could use variable variables!
19:20:51 <augur> im sure it could do that
19:22:58 <byorgey> yes, you could easily generate that file with TH
19:23:34 <mmat_> I've thought about similar type of thing and came up with a naming scheme like |0,1,2,3| is unchanged |0,1,3,2| flips the last two arguments, etc.
19:23:38 <augur> byorgey: i think its more a question of whether you could generate the programs on the fly, or at least at compile time, with TH
19:23:41 <augur> but im sure you could
19:24:38 <byorgey> oh, you mean generate only the ones you actually use?
19:24:49 <augur> what the file is doing, interestingly, is something quite lovely
19:24:53 <augur> but not explicitly
19:25:30 <augur> see, if you curry this to hell, it turns out that this is just defining what it means to apply a function to some arguments in a variable context
19:26:02 <augur> thats what its really doing. these maps are just pair formers in variable environments
19:27:19 <augur> there's a very nice general way to build up precisely the translations necessary to capture exactly the permutatins-and-so-forth that these functions represent
19:28:26 <augur> namely, they're just tuplings of lookups. its quite a beautiful concept, lurking beneath it
19:28:33 <augur> categorical semantics, thats whats lurking
19:30:18 <kristof> what the hell is a variable variable
19:31:06 <geekosaur> sounds like varvarnames
19:31:24 * hackagebot abstract-deque 0.3 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.3 (RyanNewton)
19:31:50 <mmat_> Is it some kind of dynamically typed monstrosity?
19:31:54 <augur> kristof: its like a pointer pointer!
19:31:59 <dwcook> kristof, I was being facetious. But here: http://php.net/manual/en/language.variables.variable.php
19:32:02 <augur> a variable who's value is the name of another variable!
19:32:22 <kristof> dwcook: I just started reading it
19:32:23 <dwcook> augur, almost. It's the other variable
19:32:26 <kristof> this is utterly uselss
19:32:31 <kristof> *useless. Terribad
19:32:34 <dwcook> A variable whose name has been determined by the value of another variable
19:33:05 <kristof> PHP makes me want to regurgitate the contents of my stomach
19:33:06 <augur> dwcook: that too
19:33:17 <dwcook> It's really no better than a Map lookup where the key varies
19:33:33 <dwcook> which might sound trivial because it is
19:34:09 <kristof> all these non orthogonal features everywhere
19:34:16 <kristof> hopefully everyone here has read "PHP: A Fractal of Bad Design"
19:34:40 <greedo> Heh
19:34:41 <dwcook> kristof, I was actually pleasantly surprised that variable variables can be nested and that they don't just go one-deep
19:35:00 <kristof> dwcook: the spaghetti intensifies!
19:35:01 <greedo> I have to write PHP at work :(
19:35:22 <augur> gproj : Vec A m -> Vec (Fin m) n -> Vec A n  ;  gproj xs ixs = map (flip lookup xs) ixs
19:35:25 <dwcook> Well, pleasant not because it's something I'd want to use, but because it implies it's not a dumb special case
19:35:32 <dwcook> unlike much of the rest of PHP
19:36:07 <greedo> writing PHP makes we want to cry though
19:36:19 <dwcook> PHP is a hell of a drug.
19:37:00 <augur> gflip : Vec (Fin m) n -> (Vec A n -> B) -> Vec A m -> B   ;   gflip ixs f xs = f (gproj xs ixs)
19:37:34 <bmuk> I'm having trouble understanding traverse. Why doesn't traverse (map (+1)) [[1,2],[3,4]] just raise all of them by 1? It gives me a list of four lists and I can't figure out why
19:37:42 <augur> curry that in the Vec A args and you've got a (monotyped) definition of that fix for arbitrary arities both in f and the generalized flipped f
19:37:45 <augur> dwcook: ^
19:38:47 <dwcook> augur, I'm thinking it might be too close to my bedtime to grasp that just now
19:39:03 <augur> :)
19:39:32 <scott> bmuk: map (map (+1)) would do that
19:39:42 <scott> > traverse id [[1,2],[3,4]]
19:39:44 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
19:41:25 * hackagebot lockfree-queue 0.2.3 - Michael and Scott lock-free queues.  http://hackage.haskell.org/package/lockfree-queue-0.2.3 (RyanNewton)
19:41:50 <bmuk> scott: I'm not sure why id would give anything back but what I put in, isn't traverse used to keep the internal structure?
19:41:50 <startling> :t traverse
19:41:51 <startling> :t traverse id
19:41:51 <bmuk> > traverse map (map id) [[1,2],[3,4]]
19:41:52 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
19:41:53 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:41:53 <lambdabot>  Couldn't match type `[b1]' with `[t0] -> b0'
19:41:53 <lambdabot>  Expected type: [b1] -> [t0] -> b0
19:41:53 <lambdabot>    Actual type: [b1] -> [b1]
19:42:27 <roboguy_> > sequenceA [[1,2],[3,4]]
19:42:28 <lambdabot>  Not in scope: `sequenceA'
19:42:28 <lambdabot>  Perhaps you meant one of these:
19:42:28 <lambdabot>    `T.sequenceA' (imported from Data.Traversable),
19:42:28 <lambdabot>    `sequence' (imported from Control.Monad.Writer),
19:42:28 <lambdabot>    `T.sequence' (imported from Data.Traversable)
19:42:32 <roboguy_> > T.sequenceA [[1,2],[3,4]]
19:42:34 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
19:43:26 <bmuk> It's the first list paired with all combinations of the second list
19:44:59 <roboguy_> > traverse (map (+1)) [[1,2],[3,4]]
19:45:01 <lambdabot>  [[2,4],[2,5],[3,4],[3,5]]
19:46:26 * hackagebot chaselev-deque 0.5.0.3 - Chase & Lev work-stealing lock-free double-ended queues (deques).  http://hackage.haskell.org/package/chaselev-deque-0.5.0.3 (RyanNewton)
19:48:07 <roboguy_> bmuk: see how the the t and f are flipped in the type signature?
19:48:58 <roboguy_> I always thought of that intuitively as meaning that it has a "transpose-like" behavior
19:49:07 <roboguy_> (but more general of course)
19:50:27 <mmat_> > traverse pure [[1,2],[3,4]]
19:50:29 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
19:50:29 <lambdabot>    arising from a use of `e_11234'
19:50:29 <lambdabot>  The type variable `f0' is ambiguous
19:50:29 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:50:29 <lambdabot>  Note: there are several potential instances:
19:50:55 <jrmithdobbs> Control.Monad.Fix is not what i thought i think =/
19:51:18 <jrmithdobbs> is Fix not actually defined anywhere standard?
19:51:52 <startling> there's one in recursion-schemes
19:52:25 <roboguy_> jrmithdobbs: as in newtype Fix f = Fix (f (Fix f))?
19:52:52 <jrmithdobbs> roboguy_: si
19:53:11 <roboguy_> I don't think it's in base anywhere
19:53:12 <startling> jrmithdobbs: http://hackage.haskell.org/package/recursion-schemes
19:53:21 <asimov> anyone know why scotty 0.7.0 isn't being released to hackage? it was tagged more than a week ago on github https://github.com/scotty-web/scotty/commit/cb2187b50aa6a5247b00a7c361cf556022c0cdd4
19:53:32 <jrmithdobbs> startling: ya looking at it
19:54:03 <roboguy_> > traverse (fmap (+1)) [Just 1, Just 2, Just 3]
19:54:05 <lambdabot>  Just [2,3,4]
19:54:12 <roboguy_> > traverse (fmap (+1)) [Just 1, Just 2, Nothing, Just 3]
19:54:13 <lambdabot>  Nothing
19:54:19 <roboguy_> bmuk: ^ maybe this helps some
19:54:20 <jrmithdobbs> i wonder why lens doesn't depend on that
19:54:29 <startling> > _2 id (1, Just 2) -- this is similar-ish
19:54:31 <lambdabot>  Just (1,2)
19:55:06 <roboguy_> > sequenceAOf _2 (1, Just 2)
19:55:08 <lambdabot>  Just (1,2)
19:55:43 <roboguy_> the connection is a little more explicit in that form, I feel
19:55:46 <startling> roboguy_: oh, nice.
19:57:12 <bmuk> roboguy_: so it wraps the traversable in the functor instance
19:57:29 <roboguy_> startling: I read about that in an article about "functor strength" (I think that's the term)
19:57:29 <jrmithdobbs> heh, man i wrote a lot of code i didn't need to now that this free monad/cofree comonad stuff is starting to click ;p
19:58:21 <lovewithacaveat> if f is some function with type A->B, where A and B are unknown things
19:58:27 <edwardk> jrmithdobbs: reason lens doesn't depend on recursion schemes is they never arise in the course of writing lens. also i tend not to believe that recursion schemes other than the basic ones are very useful
19:59:16 <roboguy_> bmuk: yeah, given a function a -> f b and t a it gives you f (t b)
19:59:57 <jrmithdobbs> edwardk: makes sense, and ya after looking at the rest of the haddocks i have no use for the rest of the module so i'll just define Fix ;p
20:00:11 <mmat_> :t sequenceA
20:00:12 <lambdabot>     Not in scope: `sequenceA'
20:00:12 <lambdabot>     Perhaps you meant one of these:
20:00:12 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
20:00:18 <roboguy_> bmuk: also, sequenceA (which is effectively traverse id) sort of turns it inside out
20:00:21 <roboguy_> :t sequenceA
20:00:22 <lambdabot>     Not in scope: `sequenceA'
20:00:22 <lambdabot>     Perhaps you meant one of these:
20:00:22 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
20:00:28 <roboguy_> :t T.sequenceA
20:00:29 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
20:00:29 <mmat_> :t T.SequenceA
20:00:30 <lambdabot> Couldn't find qualified module.
20:00:59 <Platz> ever since I saw this I wondered if the proper way to write a dir size program is to use a hylomorphism http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo
20:01:08 <lovewithacaveat> how can i test to see if a given object "zog", has some type "A->B", where A and B could be anything (including other functions)
20:01:26 <Platz> not quite there yet though
20:01:27 * hackagebot pipes-text 0.0.0.0 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.0 (MichaelThompson)
20:01:30 <geekosaur> wanting to do that is generally a very bad sign in haskell
20:01:32 <ReinH> lovewithacaveat: "a given object"?
20:01:49 <lovewithacaveat> ReinH: something, an input to a program
20:01:59 <jrmithdobbs> that really is an odd thing not to be in base (Fix, i mean)
20:02:00 <lovewithacaveat> ReinH: myMagicFunction zog
20:02:25 <roboguy_> lovewithacaveat: :t in ghci?
20:03:00 <roboguy_> or do you mean some sort of metaprogramming thing?
20:03:02 <bmuk> roboguy_++
20:03:46 <mmat_> lovewithcaveat: type :t id into this chat window
20:03:57 <lovewithacaveat> no, that's not what i want
20:04:07 <lovewithacaveat> i want to try to write a function that calculates how many inputs another functions needs
20:04:24 <geekosaur> oy
20:04:30 <geekosaur> jump straight in the deep end, why not
20:04:39 <lovewithacaveat> calculates, as in, tries to count how many inputs another function needs
20:04:46 <ReinH> const 1
20:04:48 <ReinH> done
20:05:27 <jrmithdobbs> heh
20:05:42 <jrmithdobbs> ReinH: smartass
20:05:45 <ReinH> jrmithdobbs: :)
20:05:52 <ReinH> I am the best kind of correct
20:06:36 <geekosaur> lovewithacaveat, do you understand the concept of strict typing?
20:07:10 <fragamus> @pl (\x-> zip (repeat x) (chopper x))
20:07:10 <lambdabot> liftM2 zip repeat chopper
20:07:12 <lovewithacaveat> ReinH: in order to circumvent your solution, let me rephrase my specification: i want to try to write a function that counts how many "things" another "thing" can take until that "thing" is a "constant"
20:07:23 <geekosaur> lovewithacaveat, do you understand the concept of strict typing?
20:07:32 <jrmithdobbs> so you want
20:07:34 <lovewithacaveat> geekosaur: probably not
20:07:34 <jrmithdobbs> :t fix
20:07:35 <jrmithdobbs> ?
20:07:35 <lambdabot> (a -> a) -> a
20:07:46 <geekosaur> because what you are asking for is not strictly typed at all, it's dynamically typed
20:08:00 <lovewithacaveat> geekosaur: maybe you could give me a brief explanation of the two then?
20:08:02 <geekosaur> iof it were strictly typed then you would know the answer without needing to ask
20:08:10 <geekosaur> because you would know its exact type
20:08:24 <geekosaur> there *is* a mechanism for dynamic typing in haskell, but it is not trivial
20:08:30 <geekosaur> because haskell is strictly typed
20:08:45 <lovewithacaveat> geekosaur: doesn't *something* need to count though? something in the deep innards of haskell?
20:08:50 <geekosaur> you cannot, without a lot of work, *have* something like you describe
20:08:56 <geekosaur> no
20:09:06 <geekosaur> what "counts" is the compiler, at compile time
20:09:14 <lovewithacaveat> geekosaur: let's say that i want to use haskell to write a compiler for another strictly typed language
20:09:15 <jrmithdobbs> and it counts like ReinH said
20:09:23 <jrmithdobbs> > const 1
20:09:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
20:09:24 <lambdabot>    arising from a use of `M247360287326744953322540.show_M2473602873267449533...
20:09:24 <lambdabot>  The type variable `b0' is ambiguous
20:09:24 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:09:24 <lambdabot>  Note: there are several potential instances:
20:09:24 <ReinH> lovewithacaveat: functions take one argument
20:09:51 <lovewithacaveat> ReinH: right, while consts take no arguments
20:10:01 <lovewithacaveat> ReinH: how do i write a haskell program that can differentiate between functions and consts
20:10:03 <jrmithdobbs> no, those aren't functions
20:10:14 <lovewithacaveat> sure they are, they are just 0-ary functions
20:10:20 <ReinH> lovewithacaveat: no, they aren't.
20:10:24 <lovewithacaveat> yes they are
20:10:24 <jrmithdobbs> no, they are not
20:10:29 <lovewithacaveat> yes they are
20:10:30 <ReinH> No. They are not.
20:10:31 <jrmithdobbs> and this is the situation where the distinction matters
20:10:36 <jrmithdobbs> basically the only one
20:10:36 <lovewithacaveat> mathematically, that's what they are.
20:10:42 <ReinH> lovewithacaveat: No. they are not.
20:10:45 <geekosaur> lovewithacaveat, if you say that then you are not working in haskell
20:10:45 <lovewithacaveat> now somwhere, haskell has to be able to figure that out.
20:10:57 <lovewithacaveat> thanks everyone, you're right
20:10:59 <lovewithacaveat> i just realized it
20:11:05 <lovewithacaveat> problem solved
20:11:21 <dwcook> a ~ () -> a
20:11:24 <geekosaur> you have a model for how things work. that model happens to be incorrect for haskell
20:11:30 <ReinH> lovewithacaveat: http://conal.net/blog/posts/everything-is-a-function-in-haskell
20:11:35 <geekosaur> haskell's model does take a bit of getting used to
20:11:46 <dwcook> (~, not =)
20:11:53 <geekosaur> it is consistent, it is just different from what you expect
20:12:46 <dwcook> It actually didn't strike me before now that ~ is used for both "is isomorphic with" and "unifies with"
20:13:07 <AlainODea> how would I stat() a file from Haskell?
20:13:48 <m3ga> AlainODea: what part of the stat() return are you after?
20:14:16 <AlainODea> m3ga: file permissions. I'd like to determine if a file is executable
20:14:27 <joe_k> AlainODea: i would lmgtfy, but http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-Files.html#5
20:14:30 <jrmithdobbs> AlainODea: why not just try and run it?
20:14:36 <jrmithdobbs> AlainODea: why do you need to check?
20:14:40 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/directory-1.2.0.1/System-Directory.html#v:getPermissions portably, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Files.html#v:getFileStatus or http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Files-ByteString.html#v:getFileStatus on POSIX
20:15:02 <jrmithdobbs> (checking permissions instead of attempting to access is bad voodoo asking for race conditions, haskell or not)
20:15:09 <mmat_> System.Posix.Files
20:17:05 <AlainODea> jrmithdobbs: I'm trying to find out what Cabal is using, because there's a bug in the Cabal build on SmartOS. It checks to see if /usr/bin/ld is writable which is illogical.
20:17:21 <AlainODea> joe_k: thank you :)
20:18:08 <jrmithdobbs> AlainODea: well then it sounds like you don't need a race condition lecture, my bad ;p
20:19:18 <AlainODea> jrmithdobbs: LOL. Thank you for your help. I'm not generally keen on mucking around with the OS from Haskell if I can avoid it ;)
20:20:24 <AlainODea> geekosaur: thank you. And we have a winner. It checks write access and returns an error since /usr is a read-only file system on SmartOS
20:21:01 <geekosaur> why does it want write access
20:21:04 <geekosaur> oy
20:21:07 <mmat_> Ya, that's strange
20:23:36 <dwcook> What's a fun Hask isomorphism to prove?
20:24:01 <AlainODea> geekosaur: it doesn't.  The act of checking it causes the underlying access() syscall to return EROFS. Error, read-only file system. I suspect that triggers getPermissions to throw an exception, but I'm guessing
20:24:37 <AlainODea> geekosaur: the implementation of getPermissions is the problem. http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/directory-1.2.0.1/src/System-Directory.html#getPermissions
20:26:11 <AlainODea> geekosaur: Definitely. Prelude System.Directory> getPermissions "/usr/bin/ld". *** Exception: /usr/bin/ld: fileAccess: permission denied (Read-only file system)
20:26:39 <geekosaur> this sounds like something to open a bug about
20:26:52 <triliyn> The source of getPermissions has a comment noting that it's basically a flawed API, I think
20:27:26 <AlainODea> triliyn: awesome :)
20:27:36 <triliyn>   -- I tried for a while to do this properly, using the Windows security API,
20:27:37 <triliyn>   -- and eventually gave up.  getPermissions is a flawed API anyway. -- SimonM
20:27:42 <mmat_> Prelude System.Directory> getPermissions "/usr/bin/ld" Permissions {readable = True, writable = False, executable = True, searchable = False}
20:27:46 <AlainODea> geekosaur: I will. What is the appropriate forum for such a bug?
20:27:46 <triliyn> hmm, that is Windows though
20:27:56 <triliyn> Maybe it's an acceptable API on linux? Not sure
20:28:10 <triliyn> *unix
20:28:20 <geekosaur> I think this is demonstrating that it is not
20:28:25 <AlainODea> mmat_: it's going to work on most systems. If you remount /usr read-only, it will fail on Linux as well
20:28:40 <geekosaur> AlainODea, I think you'd be using the ghc trac for this, with the component "libraries"
20:29:04 <geekosaur> you might ask on libraries@haskell.org though
20:29:07 <AlainODea> triliyn: I don't think it's reasonable to crash on EROFS.  It's the UNIX standard return for checking W_OK on an access() syscall ;)
20:29:21 <AlainODea> geekosaur: will do.
20:29:33 <triliyn> AlainODea: yeah, there's obviously something going wrong in your case
20:30:10 <triliyn> I'm just not sure I can conclude from the getPermissions comment that getPermissions is a fundamentally broken API on anything but Windows
20:30:32 <triliyn> So I don't know if my original remark was relevant to your problem
20:30:59 <geekosaur> I think it is, just because it's not clear that the permissions it reports actually mean the same thing in a platform independent manner
20:32:04 <geekosaur> additionally, if at some point ghc adds support for platforms that are neither POSIX-compliant nor Windows, it may become even more meaningless
20:32:30 <geekosaur> for example, OS/400 containers can have the same name as files, so isDirectory is ... difficult
20:32:40 <triliyn> hmmm, there is that
20:33:19 <triliyn> Abstracting over the differences between OSs is annoying
20:33:50 <Qett> anyone use nixos?
20:34:45 <geekosaur> (it's actually more complex than that, but let that stand for now. I don't think getPermissions can even begin to describe OS/400's filesystem organization)
20:36:02 <mmat_> Well, you could always write the whole OS in UEFI boot mode. :)
20:37:23 <Twey> Qett: Some people use NixOS
20:37:31 <ReinH> aren't we all just deploying Haskell directly onto Xen now?
20:37:49 <jrmithdobbs> mmat_: and cry silently in the corner wishing it was openfirmware?
20:37:50 <Qett> Twey: i was thinking of switching, so i had some questions
20:37:50 <jrmithdobbs> ;p
20:38:43 <Qett> i currently use funtoo but nixos seems like a nice alternative
20:38:48 <jrmithdobbs> geekosaur: it'd be fun to implement on vms too, i'd bet
20:38:55 <Vbitz> how do I select the first n values of a list
20:39:05 <startling> :t take -- Vbitz
20:39:06 <AlainODea> triliyn: it's very annoying trying to provide access to OS capabilities in a cross-platform way. It's been very difficult and problematic for Java as well.
20:39:06 <lambdabot> Int -> [a] -> [a]
20:39:19 <Vbitz> thanks
20:39:30 <Twey> Qett: Ask away?  Though if your questions aren't Haskell-related (or maybe even if they are) you might get better responses in #nixos
20:39:31 <AlainODea> triliyn: I like to keep my code as far away from that as possible :)
20:39:54 <Qett> Twey: yeah ok ill ask in #nixos
20:40:52 <mmat_> I think the use of OpenGL in handhelds helps in paving the way for cross-platform graphics.
20:41:22 <mmat_> Looking forward to the future of OpenGL devel...
20:41:32 * hackagebot beamable 0.1.0.1 - Generic serializer/deserializer with compact representation  http://hackage.haskell.org/package/beamable-0.1.0.1 (JohnLato)
20:41:43 <AlainODea> geekosaur: I sent a message to libraries@haskell.org explaining the situation.  I think it may actuall be better for this to be fixed in Cabal. Cabal probably shouldn't be checking permissions, I think it should just try to run ld blindly.  This probably came from trying to provide better error messages in Cabal.
20:41:45 <jrmithdobbs> except that we heard that with opengl 2.0, 1.0, etc and it never standardized on bigger computers why start now?!
20:43:35 <mmat_> jrmithdobbs: I guess I could blame Bill Gates, but it's much more than that.
20:45:30 <Qett> what
20:45:44 <Qett> opengl is supported on pretty much all new nvidia and ati cards
20:45:45 <Qett> ...
20:45:51 <greedo> mmat_: Finance.Quote.Yahoo
20:45:56 <greedo> haha
20:46:10 <Twey> I'm looking forward to the future of OpenGL's replacement
20:46:19 <mmat_> greedo: Ya I saw that after I sent you the other link, thanks though.
20:46:32 <Qett> what we need is some open hardware
20:47:01 <mmat_> Twey: The newest versions of OGL with fully programmable pipeline are pretty solid.
20:47:05 <greedo> mmat_: I wonder if I can get index futures an currencies
20:47:12 <Twey> Qett: http://www.extremetech.com/extreme/147195-koreans-create-magnetic-transistor-that-could-turn-every-cpu-into-an-fpga
20:47:14 <Ralith> mmat_: API's still ugly as hell, though...
20:47:19 <Twey> mmat_: There's still implicit state floating around everywhere
20:47:20 <mmat_> A lot of the old ugliness is shuffled away and unused.
20:47:28 <Ralith> it's really not
20:47:41 <Ralith> it's right there in your face in unused function parameters and huge amounts of data passed through state
20:47:45 <Qett> well all of the 'old ugliness' is deprecated so it doesnt matter
20:47:47 <Twey> And the less said about GLSL the better :þ
20:47:51 <Ralith> no, that's unrelated
20:48:04 <greedo> I also need Outstanding Shares and Float, mmm
20:48:08 <Qett> fixed pipeline is completelly deprecated
20:48:08 <Ralith> the new performant stuff is still terribly stateful
20:48:10 <Twey> (which is really a shame, because GLSL shaders are basically pure functions)
20:48:23 <Ralith> nobody's talking about the fixed pipeline
20:48:34 <Ralith> maybe opengl 5 will make EXT_direct_state_access core; that would be nice
20:53:03 <fragamus> let chopper::String -> [String];chopper = nub . (tails <=< inits) in chopper "pig"
20:53:27 <fragamus> > let chopper::String -> [String];chopper = nub . (tails <=< inits) in chopper "pig"
20:53:29 <lambdabot>  ["","p","pi","i","pig","ig","g"]
20:55:18 <fragamus> > let chopper::String -> [String];chopper = nub . (tails <=< inits);makePairs = (\x-> zip (repeat x) (chopper x)) in makePairs "pig"
20:55:19 <lambdabot>  [("pig",""),("pig","p"),("pig","pi"),("pig","i"),("pig","pig"),("pig","ig"),...
20:55:56 <ReinH> fragamus: usually we put spaces around the ::
20:56:21 <fragamus> I usually wear underpants
20:56:27 <fragamus> but not always
20:56:47 <apples`> i'm having a little trouble with equational reasoning here. could anyone give me a hint? http://lpaste.net/809118692641079296
20:57:41 <fragamus> @pl (\x-> zip (repeat x) (chopper x))
20:57:41 <lambdabot> liftM2 zip repeat chopper
20:58:17 <fragamus> > let chopper::String -> [String];chopper = nub . (tails <=< inits);makePairs = liftM2 zip repeat chopper in makePairs "pig"
20:58:18 <lambdabot>  [("pig",""),("pig","p"),("pig","pi"),("pig","i"),("pig","pig"),("pig","ig"),...
20:58:48 <fragamus> what on earth does it mean
20:59:37 <mmat_> greedo: If you really want to get clever, http://www.sec.gov/edgar.shtml has directions on how to access the government FTP servers to get financial information.
21:01:12 <fragamus> when I run this pig thing with liftM2 it fails in ghci
21:01:17 <fragamus> but it works here
21:01:22 <ReinH> fragamus: what does "fails" mean?
21:01:31 <fragamus> No instance for (Monad ((->) String))
21:01:36 <carter> :t fails
21:01:37 <lambdabot>     Not in scope: `fails'
21:01:37 <lambdabot>     Perhaps you meant one of these:
21:01:37 <lambdabot>       `fail' (imported from Control.Monad.Writer),
21:01:38 <carter> :t fail
21:01:39 <lambdabot> Monad m => String -> m a
21:01:42 <geekosaur> makePairs might be hiotting the DMR
21:02:15 <fragamus> the what
21:02:30 <geekosaur> @where dmr
21:02:30 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:02:34 <geekosaur> "dreaded"
21:02:50 <fragamus> man I never grokked that
21:02:59 <roboguy_> fragamus: hmm it works for me
21:03:07 <geekosaur> ghci has an annoying tendency to infer ()s because of monomorphism and extended defaulting
21:03:15 <Twey> Hm
21:03:17 <Twey> Works in my GHCi
21:03:21 <fragamus> gotcha
21:03:30 <Twey> Even with the DMR on
21:03:47 <fragamus> well I'll try it on my other machine
21:03:56 <Twey> What error do you get?
21:05:38 <roboguy_> apples`: g can't really do anything with that r type value can it?
21:06:36 * hackagebot pipes-binary 0.3.0.1 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.3.0.1 (RenzoCarbonara)
21:07:11 <fragamus> http://lpaste.net/99487
21:07:57 <apples`> roboguy_, hrm, you're right
21:09:12 <roboguy_> fragamus: what does :i Monad give you?
21:10:06 <fragamus> http://lpaste.net/99488
21:10:26 <roboguy_> apples`: I think you can replace forall a. a types with Void. that might help some
21:10:32 <roboguy_> (conceptually, at least)
21:10:55 <enthropy> is there something weaker than Ord that allows max/min but not compare?
21:11:05 <roboguy_> fragamus: what version of ghc do you have?
21:11:16 <roboguy_> because I definitely see a ((->) r) instance
21:11:23 <roboguy_> on mine
21:11:26 <fragamus> The Glorious Glasgow Haskell Compilation System, version 6.12.3
21:11:32 <enthropy> hmm, actually hose are part of that class
21:11:38 <Twey> In some old versions you might need to import Control.Monad.Instances
21:11:40 <apples`> roboguy_, i'll give that a try, thanks
21:11:56 <td123> hey all, I have built ghc 7.8.1 rc1 and when I ran the tests, I get a bunch of warnings like the following: http://lpaste.net/2369120650716512256 , i found a ticket which seems sort of related, but it's for ios and not 64bit linux: https://ghc.haskell.org/trac/ghc/ticket/8208
21:12:03 <Ralith> fragamus: wow, that's ancient
21:12:04 <Twey> You should also upgrade your GHC :þ  We're on 7.8 now.
21:12:28 <roboguy_> 7.8 is officially released?
21:12:36 <Twey> Release Candidate 1
21:12:37 <roboguy_> I'm still on one of the 7.7 ghcs
21:12:58 <td123> does anyone have any hints on how to disable that warning?
21:13:39 <enthropy> fragamus: I don't think anything has changed at the introductory level
21:13:45 <Twey> td123: Are you on Mac OS?
21:14:04 <Twey> (or otherwise using clang as your CC?)
21:14:10 <fragamus> The Glorious Glasgow Haskell Compilation System, version 6.12.3
21:14:13 <fragamus> import Control.Monad.Instances
21:14:16 <fragamus> that worked
21:14:30 <Twey> fragamus: You should still upgrade.  :þ
21:14:33 <roboguy_> fragamus: you should definitely, definitely upgrade
21:14:46 <td123> Twey: no, 64bit linux, and I'm using gcc
21:14:49 <Twey> GHC 7 has lots of nice features over 6.
21:14:50 <fragamus> are you guys SURE I should upgrade?
21:15:02 <Twey> ¬.¬
21:15:24 <Ralith> fragamus: no, don't do it! think of the children!
21:15:29 <adnam> i'm surprised when i see packages supporting 6.12 :-)
21:15:35 <Twey> td123: Hm.  Maybe #ghc can help?
21:15:37 <fragamus> yes and the tiny tiny animals
21:15:51 <td123> Twey: ok, thank you
21:16:05 <fragamus> upgrading...
21:16:38 * hackagebot warp 1.3.10.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.10.2 (MichaelSnoyman)
21:16:40 * hackagebot warp 2.0.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.3.1 (MichaelSnoyman)
21:17:14 <NemesisD> carter: hey!
21:17:21 <carter> NemesisD: who dat?
21:17:32 <NemesisD> carter: i'm the guy that was winging about groundhog on twitter
21:17:40 <carter> ah
21:17:47 <carter> NemesisD: use postgres-simple
21:18:07 <NemesisD> i've made significant progress by peppering my code with undefineds, removing lots of handwritten types and letting ghmod tell me the types
21:18:38 <startling> undefineds always help. 8)
21:18:53 <NemesisD> its basically an interrogation at this point, ghc knows how to make my program work, i just have to trick it into writing it for me
21:20:41 <roboguy_> NemesisD: haha, that's always an interesting moment
21:21:09 <mmat_> I often feel like the one who the trick is being played on.
21:21:14 <NemesisD> typeholes may make this nicer?
21:21:18 <Twey> NemesisD: TypedHoles soon \o/
21:21:23 <NemesisD> im stoked man
21:21:26 <roboguy_> NemesisD: I think they do anyway
21:21:30 <Aetherspawn> PSA stop publishing your papers in book format they're annoying to print
21:21:30 <roboguy_> they're pretty awesome
21:21:35 <Aetherspawn> use the double column format, thanks.
21:21:39 * hackagebot atomic-primops-foreign 0.6 - An atomic counter implemented using the FFI.  http://hackage.haskell.org/package/atomic-primops-foreign-0.6 (RyanNewton)
21:21:41 * hackagebot abstract-deque-tests 0.3 - A test-suite for any queue or double-ended queue satisfying an interface  http://hackage.haskell.org/package/abstract-deque-tests-0.3 (RyanNewton)
21:22:00 <NemesisD> i really hope i can get a good setup going with vim and ghc 7.8
21:22:11 <Twey> Aetherspawn: But the double-column format is a pain on e-readers ☹
21:22:21 <Aetherspawn> :(
21:22:26 <Aetherspawn> the book format is a pain on printers
21:22:30 <Aetherspawn> too much paper
21:22:33 <NemesisD> every day it starts to set in that I have chosen an old rickety editor to become hopelessly dependent on
21:22:37 <Twey> This is 2014 — stop printing things :þ
21:22:50 <Aetherspawn> just bought an industrial printer :P
21:22:52 <Aetherspawn> printing papers like nuts
21:23:01 <startling> haha
21:23:30 <Twey> NemesisD: I was fighting the urge to take a shot at vim — thank you for saving me from temptation :þ
21:23:57 <fragamus> new Haskell platform did the trick thanks guys I dont regret the upgrade; children and animals be damned
21:24:46 <Twey> NemesisD: I hear Yi is getting nicer, and it has a vim mode (and Haskell support, obviously)
21:25:02 <Aetherspawn> why isnt there a haskell text editor written in haskell
21:25:07 <Twey> There is
21:25:11 <roboguy_> is it worth upgrading right now from ghc 7.7 (from probably about 3 or 4 weeks ago) to the ghc 7.8 RC (taking into account the package reinstalls, etc)?
21:25:15 <Aetherspawn> that isnt lecksah
21:25:21 <Twey> There's Yi
21:25:31 <Aetherspawn> :o Yi is written in haskell
21:25:31 <NemesisD> Twey: i'm curious how bad id be hurting if i eventually switched to emacs in vim mode
21:25:53 <Twey> NemesisD: I wouldn't do it
21:26:13 <startling> NemesisD, emacs is a better vim than vim is sadly
21:26:16 <Twey> If you're going to switch to emacs you might as well go all the way; the vi emulation doesn't support everything, as I understand it
21:26:21 <mmat_> NemesisD: Why go from the 6th layer to the 7th layer?
21:26:28 <NemesisD> i don't think i can give up the movement/editing language that vim has, its just a shame that its such a rickty jallopy of an editor. from my side of the grass it seems like people write way better extensions for it
21:26:47 <NemesisD> for emacs*
21:26:55 <startling> but yeah, you'll probably end up writing more emacs lisp to make your keybindings work and then all the sudden you'll be using C-k everywhere.
21:27:26 <NemesisD> theoretically if i were to jump ship, where should i statr
21:27:50 <NemesisD> i learned vim via almost a year of blood and tears
21:28:09 <Twey> NemesisD: emacs requires significantly less jumping in at the deep end
21:28:43 <Twey> You can just learn keys as you need them
21:29:01 <startling> NemesisD: open emacs, ctrl-h t
21:29:31 <Platz> I'd switch to emacs if I could figure out how to avoid the RSI
21:30:08 <Platz> might have to pick up a kinesis
21:30:14 <Twey> Platz: Switch Ctrl and Alt, or get a keyboard that has Ctrl in a better place
21:30:39 <Twey> The Advantage loves emacs
21:30:46 <NemesisD> yeah i was about to ask about that. right now my ctrl is my caps lock
21:31:06 <startling> god-mode (by our own chrisdone) is nice
21:31:16 <Twey> NemesisD: That's not a good place for Ctrl — it's still on the weakest finger *and* you can't use the heel of your hand any more
21:31:39 <Twey> Oh yeah, emacs + god-mode might be nice for vi-rehabilitation
21:32:01 <Twey> NemesisD: It's a much better idea to put it on a thumb, e.g. where the Alt key usually is
21:32:27 <ReinH> eh, caps lock works fine for me
21:32:30 <Platz> Twey: I might have to try that
21:32:32 <startling> me too.
21:32:38 <startling> I have big hands + a small keyboard though
21:32:43 <NemesisD> Twey: don't you need alt for emacsy stuff to?
21:32:46 <Twey> startling: All the better
21:33:14 <startling> yeah, I definitely don't lift the heel of my hand for ctrl
21:33:31 <Twey> NemesisD: Yes, but not nearly as much as Ctrl (and you can put it on the other Alt if you want: you don't have to worry about using opposite hands when your modifier is on a thumb, because pressing something with a thumb doesn't really restrict the movement of your other fingers)
21:34:54 <roboguy_> NemesisD: that's why you get foot pedals!
21:35:27 <Twey> I hope we get to working BCIs before I need a foot pedal
21:35:28 <blackdog> edwardk: i did manage get at least one lens reference into @evilhaskelltips...
21:35:50 <AndChat231636> Hello,i want to know if there are specific names we call these two different tree definition: data T=L Int | B T T; data T=L Into | B Int T T
21:36:23 <startling> AndChat231636: I wish I knew.
21:36:34 <startling> I call them all 'Tree'.
21:36:40 * hackagebot atomic-primops-foreign 0.6.1 - An atomic counter implemented using the FFI.  http://hackage.haskell.org/package/atomic-primops-foreign-0.6.1 (RyanNewton)
21:37:14 <AndChat231636> Basically one stores data in the leaves only, and other both inner and leaf nodes
21:37:16 <startling> the first is Free V2. I don't think there's a nice simple definition of the second.
21:37:42 <startling> data Row f a = Row a (f a) (f a); then it's Free Row.
21:38:02 <Twey> Free?
21:38:06 <Cale> AndChat231636: That second one is actually a bit less common (though nearly equivalent) to  data Tree a = Tip | Branch a (Tree a) (Tree a)
21:38:34 <startling> Twey, data Free f a = Pure a | Free (f (Free f a))
21:38:48 <startling> if f is a Functor, Free f is a monad.
21:39:28 <AndChat231636> Is there a way we could use a single definition to use both
21:39:44 <startling> hm
21:40:19 <fragamus> let chopper = nub . (tails <=< inits);makePairs = liftM2 zip repeat chopper in makePairs "pig"
21:40:30 <fragamus> can you guys explain liftM2
21:40:34 <fragamus> in this context
21:40:37 <Twey> @src liftM2
21:40:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:40:48 <roboguy_> fragamus: are you familiar with Applicative?
21:40:54 <fragamus> kinda
21:41:06 <fragamus> I understand
21:41:07 <startling> I wish there were a data Join f a = Join (f a a). Then we have Free (Join (,)) and Free (Join (Join (,)))
21:41:10 <Twey> fragamus: For functions, liftM2 f g h x = f (g x) (h x)
21:41:12 <fragamus> the source is clear
21:41:25 <roboguy_> fragamus: liftM2 zip repeat chopper  ==  zip <$> repeat <*> chopper
21:41:30 <startling> wait, that's not right.
21:42:28 <fragamus> so all monadic actions are functors right
21:43:00 <startling> no.
21:43:07 <startling> all monads are functors.
21:43:17 <fragamus> mkay
21:43:18 <mmat_> :t liftM2 (+) (return 1) (return 1)
21:43:19 <lambdabot> (Monad m, Num r) => m r
21:43:20 <startling> I guess all monadic actions are functors too but not in the way you mean.
21:43:46 <startling> (i.e. that's Reader(T))
21:43:52 <Twey> All monadic actions are ‘functoric actions’ :þ
21:44:04 <startling> heh
21:46:04 <roboguy_> fragamus: liftM = fmap; pure = return; (<*>) = ap
21:46:21 <roboguy_> I should say: fmap = liftM; pure = return; (<*>) = ap
21:46:41 * hackagebot fixedprec 0.2.1.1 - A fixed-precision real number type  http://hackage.haskell.org/package/fixedprec-0.2.1.1 (PeterSelinger)
21:46:52 <fragamus> Yes I used applicatives a bunch about a year back
21:46:57 <mmat_> > liftM2 (+) (return 1) (return 1) undefined
21:46:58 <lambdabot>  2
21:47:35 <fragamus> :t (return 1)
21:47:36 <lambdabot> (Monad m, Num a) => m a
21:47:50 <startling> that's the ((->) r) instance.
21:47:51 <fragamus> some nameless monad
21:47:55 <startling> a.k.a. Reader.
21:48:03 <fragamus> freaky
21:48:15 <roboguy_> fragamus: in this context, it is specifically (->) r
21:48:22 <startling> > ((+ 1) >>= (+)) 2
21:48:24 <lambdabot>  5
21:48:25 <roboguy_> fragamus: in general, return 1 can use any Monad instance
21:56:43 * hackagebot newsynth 0.1.1.0 - Exact and approximate synthesis of quantum circuits  http://hackage.haskell.org/package/newsynth-0.1.1.0 (PeterSelinger)
21:58:46 <NemesisD> what is this i don't even http://hackage.haskell.org/packages/archive/bifunctors/3.2.0.1/doc/html/Data-Bifunctor-Clown.html
22:00:43 <Cale> NemesisD: Conor likes puns
22:01:12 <Cale> http://strictlypositive.org/Dissect.pdf
22:02:14 <liyang> NemesisD: if you recall the ear-dissection scene from Reservoir Dogs.
22:07:16 <roboguy_> NemesisD: it's named after Stuck in the Middle With You
22:07:35 <mmat_> Bob Dylan
22:07:59 <roboguy_> hmm, I don't think it's Bob Dylan
22:09:12 <m3ga> roboguy_: not bob, 'stealers wheel'
22:09:16 <roboguy_> m3ga: maybe you're thinking of All Along the Watchtower
22:09:19 <roboguy_> ^ mmat_
22:09:41 <mmat_> Ohh that's funny, reading the wikipedia page, it says the song was a parody of dylan
22:09:42 <roboguy_> Cale: didn't he also write Kleisli Arrows of Outrageous Fortune?
22:10:08 <m3ga> oops, i think it came in late on this one
22:10:09 <Cale> roboguy_: yes
22:10:35 <roboguy_> mmat_: huh, I never knew that. I could see that
22:11:03 <Cale> http://strictlypositive.org/
22:11:47 <roboguy_> Cale: I still need to figure that paper out one of these days. parts of it make sense but I don't full grasp it
22:11:55 <roboguy_> *fully
22:11:57 <greedo> Cale: http://www.hardlystrictlybluegrass.com/
22:12:17 <greedo> hardlystrictly
22:22:39 <NemesisD> looking for a bit of advice on an algorithm, i'm trying to basically match up records in one collection to another, i can express it easily this way:
22:23:54 <NemesisD> [(sv, s) | sv <- svs, s <- ss | storeId sv == id' s]
22:24:53 <NemesisD> but that will do all permutation of both lists wont it? when really what i'm trying to do should iterate through one list and scan the other, preferably removing a match when it is found
22:25:19 <NemesisD> is my intuition here correct, and should i hand-roll a recursive function or is there a better way
22:25:35 <pavonia> Is that supposed to be a parallel list comprehension?
22:25:43 <jrmithdobbs> NemesisD: convert the second list to a hashmap and i think your problem because clearer
22:26:11 <NemesisD> pavonia: i don't think there's anything necessarily parallel, do list comprehensions desugar to parallel?
22:26:37 <sopvop> parallel is like zip
22:26:46 <sopvop> (it is zip)
22:26:54 <pavonia> NemesisD: No, but the second '|' is confusing
22:27:15 <NemesisD> pavonia: oh, thats just because i forget  the list comprehension syntax
22:27:26 <pavonia> Ah okay
22:28:12 <pavonia> As jrmithdobbs  said, convertind to a Map id --> value is probably the easiest
22:28:41 <jrmithdobbs> yes you want some kind of map or set probably, you're basically asking how to make a list not a list ;p
22:29:06 <NemesisD> yeah i think you're right, and i think i could still use a comprehension to process it, since you can use pattern match failures to move on to the next element
22:29:12 <tomjack> For Oleg's CFoldLeft applied to lists, would the monad just be the identity monad? I was thinking it would be an arbitrary monad (like traverse gets an arbitrary applicative), but I don't see how to use it for lists.
22:30:46 <tomjack> I guess the point is not to expose the monad to the folding user, but just to have a monad for resources handled by the fold implementor?
22:31:27 <tomjack> the one example seems to confirm that pretty well, thanks rubber ducks :(
22:46:18 <AaronFriel> What is the current best maintained/best practice for command line handling?
22:46:23 <AaronFriel> library, rather
22:47:03 <jle`> if `Maybe` is a functor
22:47:07 <jle`> what is `Maybe Int` ?
22:47:22 <kazagistar> I have tried to simplify to only the impure parts of my code, because that is where I think I am doing something wrong: http://lpaste.net/99492 … I am trying to read a file, store it into a data structure, and then do queries based on the file, but it seems to be rereading the file every time I querry?
22:47:26 <apples`> AaronFriel, you mean like command line arguments, or reading in lines of user input?
22:47:39 <AaronFriel> The former - arguments, options, displaying usage information and such.
22:47:51 <apples`> check out optparse-applicative
22:47:55 <adnam> AaronFriel: i'm using optparse-applicative
22:48:14 <notadog> I am coding my 3rd application using gtk, and am having trouble making a simple text combobox. I have used many variations on my own code, and code from many places on the web but I can't make it work. I can see the combobox but it doesn't have any of the strings in it.
22:48:15 <adnam> not too fond of the "applicative" part ;) but it's a pretty nice library
22:48:24 <notadog> I also get this when running Gtk-WARNING **: Refusing to add the same cell renderer to a GtkCellArea twice
22:48:49 <AaronFriel> I will check that out - thank you!
22:48:50 <notadog> though that could be a bug, this is gtk3 and GtkCellArea is marked as unstable.
22:50:42 <adnam> AaronFriel: we also have a package that uses GetOpt from base together with ConfigFile so we can specify options as command line args or in a config file
22:51:37 <AaronFriel> adnam: I think the optparse-applicative package will do what I need based on the github readme, but I will look into ConfigFile if I need to read settings from a file :)
22:54:57 <kazagistar> any ideas? on how to reuse computations from a lazy data structure without recreating the whole structure, which it appears to be doing now?
22:56:10 <notadog> ive tried everything i can think of :(
22:56:51 <adnam> kazagistar: afaict you're reading it twice
22:57:05 <adnam> oh wait the first one was commented out :-)
22:57:55 <kazagistar> adnam: yeah, sorry about that, I switched the filename to an argument
22:58:23 <adnam> kazagistar: did you try printing something in loadSongs to make sure it reads it several times? it looks like it should only read it once
23:00:09 <kazagistar> adnam: I mean, the rest of my code, in the forever do, should prompt for items and print… its really just a Map lookup in the background?
23:00:49 <sccrstud92> johnw: hey i finished that counting sort program
23:06:10 <adnam> kazagistar: since readFile is lazy it might delay the reading until mostCommonAfter is evaluated, i suppose
23:07:12 <kazagistar> adnam: which is what I am expecting, but then I was hoping that the second time I call mostCommonAfter, it would evaluate right away
23:07:23 <kazagistar> on the same data
23:07:35 <ReinH> Cale: ping
23:07:44 <Cale> hi
23:08:01 <adnam> kazagistar: yeah that should be the case, how do you know it's not?
23:08:04 <ReinH> Cale: random math question for you
23:08:57 <ReinH> Cale: is there a shorthand to define, given a set S and an element a in s, a set S' such that a is replaced with some b?
23:09:11 <ReinH> (b not in S)
23:09:49 <Cale> (S \ {a}) union {b}?
23:10:00 <ReinH> yeah, I suppose that's the best you can do
23:10:11 <Cale> Well, you can define whatever notation you like for that operation
23:10:17 <ReinH> heh
23:10:37 <Cale> like [b/a] S or something.
23:10:37 <ReinH> but there's nothing commonly used for it
23:11:07 <kazagistar> adnam: because both take like 20 seconds to complete, and the file for testing has a million lines
23:11:08 <Cale> Nothing too standard as far as I know
23:11:15 <ReinH> Cale: thanks
23:12:16 <mm_freak> kazagistar: if you're using String for processing that much data, don't be surprised =)
23:12:30 <mm_freak> use Text instead
23:12:38 <mm_freak> i.e. Data.Text or Data.Text.Lazy
23:13:25 <kazagistar> I am processing data, but it is all 5-10 char strings at a times, word by word?
23:13:55 <mm_freak> kazagistar: the format doesn't really matter…  String is a linked list of Char values!
23:14:48 <ReinH> Cale: I guess I need to read http://www.amazon.com/Handbook-Typography-Mathematical-Sciences-Steven/dp/1584881496 ;)
23:15:18 <kazagistar> right, and linked lists are terrible for everything performance, I guess that makes sense, but still, the lookup should be O(1)…?
23:15:35 <mm_freak> kazagistar: just to give you a reference:  i have processed gigabytes of text in seconds using Text =)
23:15:50 <ReinH> Text is quite fast
23:16:24 <mm_freak> kazagistar: what lookup?  (i haven't seen your code)
23:17:26 <kazagistar> oh god…
23:17:56 <kazagistar> well, now I have to show it, even though I know what I did wrong
23:18:14 <mm_freak> kazagistar: you can tell me in words what you're looking up
23:18:24 <kazagistar> "last" over a few million words…
23:18:34 <mm_freak> kazagistar: how is that supposed to be O(1)?
23:18:59 <mm_freak> String = [Char]  -- not just conceptually, but actually
23:19:05 <kazagistar> it should be first, and the list reversed in the data structure
23:19:16 <mm_freak> and reversing takes …?
23:19:32 <kazagistar> irrelevant, it only runs the first time?
23:19:40 <mm_freak> and takes …?
23:19:46 <kazagistar> O(N)
23:19:58 <mm_freak> so your program does do it after opening the file?
23:20:22 <mm_freak> and then spits out the first word?
23:20:50 <startling> reversing kills laziness though.
23:21:06 <startling> you could seek to the end, get that, and the do your processing.
23:21:07 <mm_freak> it does, but that's not really the problem
23:21:11 <startling> sure.
23:21:25 <kazagistar> here is my old code http://lpaste.net/99496 so we can be on the same page?
23:21:28 <mm_freak> and you can't seek unless make assumptions about the length of the last word
23:21:56 <startling> sure you can.
23:23:24 <kazagistar> my problem is line 37 and 59
23:23:31 <mm_freak> startling: so you seeked beyond the last word's beginning…  what do you do?
23:23:57 <startling> mm_freak: go back.
23:24:06 <mm_freak> kazagistar: first step:  replace foldl by foldl'
23:24:13 <mm_freak> startling: and read everything again
23:24:26 <mm_freak> up to the last seeking point
23:25:12 <mm_freak> startling: if the last word happens to be very long, this scheme can take orders of magnitude longer on a magnetic drive
23:25:54 <mm_freak> startling: also finding the last word in 1 GiB of text takes a fraction of a second
23:26:27 <mm_freak> the disk is your main bottleneck
23:27:41 <mm_freak> kazagistar: you can get a major speedup just by switching to M.fromListWith
23:27:48 <mm_freak> instead of folding manually
23:28:56 <mm_freak> kazagistar: you may get another speedup by removing the type signature on line 39
23:29:12 <mm_freak> alternatively, since type signatures are great, you can switch on ScopedTypeVariables
23:29:51 <kazagistar> mm_freak: wait, how does removing a type signature speed things up?
23:29:55 <mm_freak> then line 36 becomes:  grammify :: forall a. (Ord a) => [[a]] -> NGramNext a
23:30:10 <mm_freak> on line 39 you remove the Ord constraint
23:30:39 <mm_freak> kazagistar: the problem is that you have a local function with type constraints
23:31:16 <mm_freak> the best GHC knows this is a new constraint, so it needs to pass type class dictionaries instead of just reusing the one 'grammify' received
23:32:18 <mm_freak> if you remove the type signature, then GHC will infer a type that refers to the type variable in the top-level type signature
23:32:28 <mm_freak> it does automatically what i have done manually with ScopedTypeVariables above
23:32:40 <kazagistar> ok, I see
23:33:34 <mm_freak> f :: (Monad m) => m String
23:33:46 <mm_freak> f = go 0  where go :: (Monad m) => Int -> m String
23:33:58 <mm_freak> bad for performance, because the inner 'm' is unrelated to the outer
23:34:14 <mm_freak> f :: forall m. (Monad m) => m String
23:34:21 <mm_freak> f = go 0  where go :: Int -> m String
23:34:23 <mm_freak> much better
23:36:51 <kazagistar> … and you lost me, I am still shaky on monads, lemme think about that for a second
23:36:55 * hackagebot ansi-terminal 0.6.1.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6.1.1 (RomanCheplyaka)
23:43:27 <Aetherspawn> Rank2Types dont seem very dangerous
23:43:28 <piezoid> hi
23:43:31 <Aetherspawn> why aren't they a haskell2010 thing?
23:44:12 <c_wraith> Aetherspawn: they aren't inferrable, and they can be tricky to implement
23:44:14 <piezoid> since -fglasgow-exts is deprecated, what do you put in your .ghci to have a modern repl ?
23:44:31 <Aetherspawn> ah okay
23:44:35 <shachaf> Turn on the extensions you want.
23:45:02 <shachaf> I have 39.
23:45:24 <piezoid> shachaf: wow :)
23:49:05 <c_wraith> Aetherspawn: more fundamentally (and related to the fact that they can't be inferred), they destroy principle typing.
23:49:13 <startling> mm_freak: fair enough.
23:49:31 <c_wraith> Aetherspawn: that is, the haskell 2010 type system says that every expression has a single maximally general type
23:49:53 <c_wraith> Aetherspawn: that is the expression's principle type.
23:50:03 <Aetherspawn> gotcha
23:50:36 <shachaf> Haskell 2010 types can't always be inferred.
23:50:45 <c_wraith> true.
23:50:53 <c_wraith> Type classes are annoying in that way
23:51:13 <shachaf> Even without type classes (hmm, how do type classes cause that?).
23:51:46 <shachaf> (Do you mean things like show . read?)
23:51:49 <c_wraith> yeah
23:51:57 * hackagebot mime-mail 0.4.4 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.4 (MichaelSnoyman)
23:52:13 <shachaf> I don't think that's quite the same.
23:52:18 <shachaf> Anyway I meant polymorphic recursion.
23:52:31 <c_wraith> Ah, yes.  There is that case, too.
23:53:22 <shachaf> That's the tricky one.
23:53:30 <c_wraith> But polymorphic recursion doesn't cause ambiguous typing, does it? I mean, you have to tell the compiler you mean it, but there's still only one correct type for the expression, right?
23:53:48 <shachaf> People sometimes say that rank-2 types can be inferred but I'm not sure what they mean.
23:54:02 <c_wraith> err.  One correct maximally-general type
23:54:12 <Kaidelong> they mean that the Damas-Millner algorithm or whatever it is always terminates, I think
23:54:31 <Kaidelong> which was kind of an important discovery because rank2 is enough for rankN
23:54:42 <Kaidelong> so rankNtypes don't make the type system turing complete
23:55:00 <shachaf> People say that rank-2 can be inferred and rank-n can't in general.
23:55:06 <shachaf> And which algorithm do you mean?
23:55:12 <shachaf> c_wraith: Hmm, I'm not sure. Polymorphic recursion is tricky.
23:55:19 <eakuefner> hi jroesch_ :)
23:55:24 <Kaidelong> Haskell was based on some variation of Hindley-Miller
23:55:37 <eakuefner> *Milner
23:55:56 <Kaidelong> and shachaf that wasn't how I understood it, I though the important discovery made was that rankN and rank2 are equivalent
23:56:10 <Kaidelong> all rankN types can be rewritten into rank2 types
23:56:21 <shachaf> How?
23:57:36 <c_wraith> But Rank2Types do introduce ambiguous typing.  That is, there are times when you can't tell if something should have a rank 1 type, or a higher-rank type.  This gives two different types for those expressions, where each is maximally general, but they mean different things.
23:57:53 <c_wraith> err, two or more different types
23:58:00 <shachaf> Yes.
23:58:08 <shachaf> That is why I'm not sure what they mean.
23:58:50 <Kaidelong> yeah, my understanding was that Rank2 types prevents some types from being inferred at all, but it doesn't totally break the type inference engine by allowing you to write types that put it into infinite loops
23:58:58 <shachaf> You can encode existentials with rank-2 types, so the situation is even worse.
23:59:07 <shachaf> I don't know how type inference for existentials ought to work.
23:59:41 <shachaf> I'm also not sure that rank-2 types *should* be inferred in general, even if it's possible.
