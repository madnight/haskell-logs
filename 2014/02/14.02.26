00:01:15 <shachaf> I agree.
00:05:14 <metanat> geekosaur: I really figured out that problem with (^2) i had before
00:05:41 <stevejb> monochrom: that seemed to work! thank you
00:06:06 <metanat> geekosaur: I was because I am using -Wall, so I need to use (^(2::Int)) if I wan't to avoid the warning. ugh
00:06:28 <metanat> s/I was/It was
00:08:06 <metanat> (^(2::Int)) is rather ugly
00:08:11 <metanat> Do other people run into this?
00:08:40 <shachaf> I think turning that warning off isn't unreasonable.
00:09:40 <johnw> metanat: I do, but it's rare enough I don't care that much
00:10:04 <ion> (^) :: Num a => a -> Integer -> a wouldn‚Äôt be unreasonable either.
00:10:05 <metanat> right
00:10:36 <ion> (Or Natural, but we don‚Äôt have that in Prelude. :-P)
00:11:15 <Cale> I just don't use -Wall ;)
00:11:30 <Cale> (or ignore the warning)
00:12:26 <kamatsu> hm, what does it mean for something to "respect" a relation?
00:12:44 <kamatsu> is there a precise definition?
00:14:42 <shachaf> What is the context?
00:14:50 <Feuerbach> it usually means that when arguments are related, then e.g. function results are related, too. Depends on what "something" is
00:15:36 <Feuerbach> (where relation on function results may be a different one)
00:19:15 <MrRacoon> Hey, have any of you guys used the HsOpenSSL or tls pacakge to make an SSL client?
00:19:33 <MrRacoon> Specifically, i need to make an IRC bot, and I'd like to use SSL
00:19:39 <MrRacoon> thoughts?
00:32:49 <czro_> I have a silly example with vectors where things dont seem to work as I expect. Can anyone explain http://lpaste.net/100406
00:32:51 <czro_> ?
00:40:28 <b0bbi10> hello, I've read many good things about Haskell in the past months and decided to give it a try (just to understand the concepts). I know it's the response will be quite biased in here but is Haskell really that good and worth learning or is it just being hyped?
00:40:43 <b0bbi10> -it's
00:41:21 <verement> after taking the time to learn the language I quite enjoy it
00:41:57 <verement> it definitely challenges you to think about problems and programming differently
00:43:19 <quicksilver> czro_: lots of things about that code look odd to me
00:43:37 <czro_> quicksilver: I can imagine that :)
00:43:53 <czro_> quicksilver: Give me a hint.
00:43:54 <b0bbi10> verement: that's what I want to find out myself ;)
00:43:58 <quicksilver> czro_: what did you want "M.replicate n [n]" to do?
00:45:11 <verement> b0bbi10: find a good project to work on, or do something like the Project Euler problems in Haskell to hone your skills
00:45:35 <czro_> quicksilver: Its just a silly example. The code where it's from is a bit more involved. I have a vector of [Int] that i do some transformations on and want to freeze it to a vector of unboxed int vectors.
00:46:13 <czro_> quicksilver: The replicate stuff is just to get a vector of type Vector [Int]
00:46:46 <c_wraith> that's a really weird Vector type.
00:47:05 <c_wraith> Not impossible for it to be right, but unusual
00:47:31 <czro_> c_wraith: An immutable vector where each element is a list of integers?
00:48:04 <johtso> Hey, I'm trying to get to grips with the basics of types, and have a question. I'm trying to define something that is almost a hierarchy of types, but I'm clearly doing something wrong, as I can't use them in the way I was hoping to. http://lpaste.net/6310832169430286336
00:48:30 <c_wraith> czro_: you understand it properly, I was just saying it's unusual to want a vector of linked lists.  Not impossible, but not the most common thing.
00:48:35 <johtso> Am I close? Do I need to be looking at "instance"?
00:49:18 <c_wraith> johtso: hierarchies of types are very uncommon in haskell.
00:49:27 <johtso> oh
00:49:37 <czro_> c_wraith: It's an adjacency list for a graph algorithm.
00:49:56 <c_wraith> johtso: primarily because the typo system doesn't allow subtyping.
00:50:01 <c_wraith> .. *type system
00:50:07 <johtso> :)
00:50:21 <c_wraith> man, I typo'd in the word typo.  How about that?
00:50:29 <johtso> freudian slip
00:50:47 <c_wraith> czro_: That's a reasonable representation, I suppose.
00:50:56 <johtso> right, so the more idiomatic thing to do would be to flatten it out?
00:51:35 <quicksilver> czro_: I doubt there is much benefit to using a vector there
00:51:52 <quicksilver> over just using an IntMap of Lists
00:52:17 <c_wraith> johtso: Usually you come at things from an entirely orthogonal direction.  "What does this data type contain?" instead of "How is this data type related to other data types?"
00:52:44 <czro_> c_wraith: It's used in a very critical loop and constant time access to each list (vector) is dersirable.
00:52:55 <quicksilver> czro_: but, on to your actual problem then, I think it's that you're using V.map on a Mutable
00:53:18 <verement> johtso: you're using Player as both a type and a data constructor
00:53:39 <quicksilver> czro_: you need to convert from MVector to Vector if I follow your idea correctly
00:54:36 <johtso> I'm wondering if i could do something to enable me to see if a Square is a Player, and unpack the specific player type
00:54:44 <verement> johtso: you could keep it hierarchical if you wanted: data Square = P Player | T | Empty
00:54:59 <johtso> aha
00:55:01 <verement> johtso: then refer (and pattern match) on P X and P Y
00:55:09 <johtso> that's exactly what I was going for
00:55:34 <quicksilver> czro_: you do that by running the whole ST action inside 'create' which exists for this purpose
00:55:53 <quicksilver> czro_: create :: (forall s. ST s (MVector s a)) -> Vector a -- Execute the monadic action and freeze the resulting vector
00:56:00 <czro_> quicksilver: Checking out create.
00:58:41 <johtso> Oh, and about the function that converts Chars to Squares, is that idiomatic? Coming from Python I would first think of defining a hash map from one to the other, but is it typical to use a series of guards in Haskell?
01:02:42 <osa1> is it possible for someone other than the uploader to edit package information?
01:03:02 <osa1> or can I somehow provide someone else permission to edit the package information?
01:05:45 <czro_> quicksilver: I believe create solved it. Thanks!
01:06:04 <quicksilver> czro_: \o/
01:06:28 <quicksilver> czro_: As I say, I suspect you're getting no benefit from vector and will find the code simpler and the performance comparable with IntMap.
01:06:40 <quicksilver> czro_: but I wouldn't be sure without trying it.
01:06:43 <mikeplus64> johtso: it's perfectly fine to just have a long case statement for something Char -> Square, i don't think a hashmap would be of any benefit (rather it'd probably make it slower) for a map of Char
01:07:48 <johtso> that's what I was thinking, I suppose it's just the repeated equality check that seemed syntactically unnecessary
01:09:42 <czro_> quicksilver: Only one way to find out. I'm porting some old code just to learn some. Most of it has been rewritten in a much more functional style, but this particular code I could,'t figure out how to do it with.
01:13:53 <quicksilver> johtso: the repeated equality check is unnecessary.
01:14:26 <quicksilver> johtso: annotation added - http://lpaste.net/6310832169430286336
01:14:48 <johtso> quicksilver, oh right, patterns, of course!
01:15:09 <quicksilver> but then instead of repeating == you have to repeat the word 'square'
01:15:12 <quicksilver> not much saving of typing
01:15:15 <quicksilver> but it looks nicer
01:15:49 <johtso> Yeah, I agree
01:16:27 <johtso> interesting that there's no syntax for defining multiple patterns for the same function name
01:17:12 <quicksilver> well there is a the 'case' variant
01:17:59 <quicksilver> johtso: case variant annotated http://lpaste.net/6310832169430286336
01:18:38 <johtso> aha
01:18:44 <quicksilver> but the middle one is definitely the most idiomatic despite the extra typing.
01:19:21 <johtso> Would they compile down to the same native code?
01:20:12 <merijn> johtso: Yes
01:20:24 <johtso> ah, lovely
01:20:31 <quicksilver> johtso: the case one and the multiple equations one make the same code
01:20:37 <merijn> johtso: Well, the pattern match and case one
01:20:43 <quicksilver> johtso: the == version not so obviously, but it might well do if everything inlines nicely
01:20:57 <johtso> oh right
01:21:40 <merijn> johtso: FYI
01:21:46 <merijn> johtso: Your code sample is broken
01:22:10 <merijn> johtso: "square" returns a value of type Square, but X and Y are values of type Plaer
01:22:14 <johtso> yeah, was asking about the types here a minute ago :)
01:22:25 <merijn> johtso: I suspect line 2 isn't doing what you thin it is
01:24:04 <johtso> merijn, I now have something like this http://lpaste.net/960783844812783616
01:25:20 <bezirg> hello, in the current module I define a top-level function foo, but also I am importing another module that exports a function `foo`. GHC complains for disambiguate occurences. Is there a trick to disambiguate with import-qualifying the imported module? In other words, I want to disambiguate by always giving precedence to the top-level defs of the current module
01:25:42 <bezirg> I mean *without import-qualifying*
01:26:01 <quicksilver> selective import bezirg ?
01:26:38 <bezirg> quicksilver: y I thought of that too, but the thing is that this is generated Haskell code. I don't want to deal with name resolution
01:27:01 <bezirg> quicksilver: I googled a lot but nothing good came up
01:27:04 <merijn> bezirg: If it's generated the simple solution is to always use fully qualified names in the generated code, problem solves
01:27:07 <merijn> *solved
01:27:17 <merijn> johtso: Ah, right :)
01:27:21 <quicksilver> surely generated code knows why it's importing a module?
01:27:27 <quicksilver> so it can import just the functions it needs
01:27:34 <quicksilver> and then it should be an error if there is a name clash
01:27:44 <quicksilver> (or use qualification indeed)
01:29:03 <bezirg> hmmm I am not sure yet about it
01:29:44 <johtso> thanks for the help everyone
01:30:30 <bezirg> I have to think about it then.. thank you very much!
01:46:21 <NobbZ> Can someone help me with a small problem in emacs' haskell mode with a project that uses cabals Paths_*-Module?
01:46:59 <NobbZ> Haskell-Mode can't find that module and marks this as an error and does not show up any other errors or warnings in that file
01:47:20 <NobbZ> How can I make haskell-mode find that module?
01:51:58 <bergmark> NobbZ: you need to make sure dist/build/autogen is in the include path
01:53:49 <NobbZ> bergmark: But how? The project has severall subdirectories and emacs doesn't know about a project root‚Ä¶
01:54:40 <NobbZ> And I don't want to add every single project buildpath manually into my .emacs.el
01:55:26 <NobbZ> Since especially Paths_*.version is a very interesting function that I want to use more often
01:58:04 <jle`> why do i have to define both (<>) for Semigroup and mappend for Monoid if I already have a Semigroup?
01:58:05 <jmtorrespalma> Hi guys!! I have seen a GSoC project in which Im interested in. I don't know if this is the right place to ask that, but who can I contact to discuss my ideas? Thank you for your time, and sorry if its not the right place ask that.
01:58:22 <jle`> is it impossible to have a new Monoid typeclass that only has mempty?
01:58:29 <jle`> and have it work well with everyhting else
02:00:11 <shachaf> #haskell-gsoc
02:00:38 <Aetherspawn> Does anyone know a way to prove that 2 recursive calls are equal
02:00:40 <shachaf> Probably pretty quiet right now, though.
02:00:57 <bergmark> NobbZ: i have never bothered to get several projects working in emacs, i just use ghci separately
02:01:17 <Aetherspawn> following with an example, moment..
02:02:10 <bergmark> jle`: because semigroup isn't a superclass of monoid, it could be but semigroup isn't in base. (<>) isn't in the monoid type class, just import <> from semigroup instead
02:02:31 <NobbZ> It is not a problem with GHCi
02:03:02 <Aetherspawn> bah, forget it. Figured it's not a worthwhile thing to prove.
02:03:08 <mmmm> Where did you see this project jmtorrespalma ?
02:05:34 <mmmm> Aetherspawn: You can do an proof by induction
02:05:43 <mmmm> If that's what you mean
02:05:52 <Aetherspawn> it might be, let me read about it.
02:06:00 <Aetherspawn> I have this particular example here
02:06:07 <Aetherspawn> https://github.com/kvanberendonck/hseuler/blob/master/15.hs#L10
02:06:37 <Aetherspawn> the x==y part is me introducing dynamic programming to drastically reduce the runtime. I was wondering if there's a general way to apply dynamic programming in ie a compiler
02:06:42 * hackagebot Spock 0.4.0.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.0.0 (AlexanderThiemann)
02:09:34 <bergmark> NobbZ: this depends heavily on your setup, which package db are you using? Which packages do you want to load from source and which do you want to use compiled versions of? It sounds hard for haskell-mode to figure this out, but it's very easy to hard code yourself
02:10:05 <jle`> why is Eq a superclass of Ord?
02:10:19 <jle`> i guess so we can use (==) for both?
02:10:26 <jle`> i should probably think before i ask heh
02:10:48 <jle`> actually idk
02:10:59 <jle`> if something is just an Ord we can expect to not be able to use (==)
02:11:05 <mmmm> I don't seen any memoisation in this Aetherspawn, that would make things much faster and be truer to what dynamic programming means
02:11:07 <jle`> and (>=) would behave like (>)
02:11:40 <Aetherspawn> the memoisation is in the first diagonal slice of the grid
02:12:02 <Aetherspawn> since we know it's equal to the second half, when we meet the mid diagonal line we just double it
02:12:02 <quicksilver> jle`: then you could define x == y as not (x < y) && not (y < x)
02:12:05 <NobbZ> bergmark: Every single project is running in a cabal sandbox (cabal-install 1.18). The only thing I want is that haskell mode does recognize this import as valid. It doesn't have to work with it
02:12:10 <Aetherspawn> which I think qualifies for the dynamic programming title.
02:12:27 <Aetherspawn> I think it can be optimized even more to remove the x == y part
02:12:45 <Aetherspawn> I'm reading papers to see if anyone has written one on automatically doing this
02:14:15 <Aetherspawn> I'm aware the entire problem can be solved mathematically in O(1).
02:16:43 * hackagebot FontyFruity 0.1.0.2 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.1.0.2 (VincentBerthoux)
02:21:45 * hackagebot Spock 0.4.0.1 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.0.1 (AlexanderThiemann)
02:28:54 <Aleksejs> Hi, an interesting question: can one say that NaN is a set?
02:31:44 <Cale> Aleksejs: in what sense?
02:31:53 <Cale> NaN is a floating point value.
02:32:04 <quicksilver> I'm sure I could define a model of FP in which NaN was a set
02:32:25 <quicksilver> I'm not sure IEEE FP is a very good system mathematically, its models are probably pretty odd.
02:32:28 <Cale> Well, if you formalised IEEE floats in set theory, they'd all be sets.
02:32:32 <quicksilver> quite
02:32:52 <Aleksejs> Cale, I'd say "values", not "value"
02:33:20 <Cale> Aleksejs: It's a single value of any given floating point type
02:33:39 <merijn> Cale: There isn't one single NaN, though
02:33:45 <merijn> Pretty sure there's multiple NaNs
02:34:00 <Cale> oh, are there multiple encodings for it?
02:34:01 <Cale> hm
02:34:01 <merijn> But my IEEE754 knowledge is a bit flaky
02:34:10 <quicksilver> Aleksejs: your intuition is reasonable. There would be reasonable ways to make what you said accurrate.
02:34:38 <quicksilver> it would nice to model FP where 'well-behaved' numbers are mapped onto the set of real numbers within a confidence interval
02:34:54 <quicksilver> then NaN would be a uselessly large set, possibly all of R
02:35:10 <quicksilver> that model isn't the way FPU arithmetic works though, sadly.
02:35:25 <quicksilver> so it wouldn't be a good model of how FPU arithmetic behaves.
02:35:38 <Aleksejs> My point is: if IEEE states that you can't compare NaN with anything, then NaN should be a "set" that has no comparing behavior
02:36:09 <quicksilver> Aleksejs: don't be fooled into thinking your question has a yes or no answer
02:36:09 <Cale> Aleksejs: It lets you compare NaN with other things, it just says that the result of the comparison is always False.
02:36:27 <quicksilver> just because your intuition is reasonable doesn't mean it's right
02:36:33 <quicksilver> in some absolute sense
02:36:46 <quicksilver> the only model of IEEE we actually have is the model which encodes them into bits
02:38:50 <Cale> As it happens, there are multiple NaN values, they have the exponent filled with ones, and a non-zero number in the significand (zero there would indicate infinity)
02:39:16 <Aleksejs> yes, it is
02:41:17 <Benzi-Junior> waaa my package database is broken
02:41:45 <Benzi-Junior> is there a command that tells cabal to reinstall the packages registered in the database ?
02:49:03 <zipper> Could someone help with the following small applicative issue. https://gist.github.com/urbanslug/9227414
02:51:08 <zipper> The channel is unusually quiet.
02:52:40 <supki> the type signature claims fmapp' makes sense for any choice of f
02:53:05 <supki> while it actually uses Maybe
02:53:58 <zipper> supki: but isn't Maybe a same as f a at least as far as the type signature is concerned?
02:54:05 <zipper> f a makes it more general
02:55:07 <supki> it's the use of the function who chooses f not the author
02:55:22 <supki> let's assume fmapp' compiles and the user wants [] as f
02:57:14 <supki> zipper: the fact that Maybe a unifies with f a does not mean they are the same
02:57:43 <supki> many things unify with f a that are not Maybe a
02:58:27 <zipper> How would I write it for it to work with [] ?
02:59:37 <quicksilver> zipper: well you couldn't use 'Just' and 'Nothing' in the code for starters...
02:59:52 <quicksilver> you can't write it for a totally generic f
03:00:13 <quicksilver> the most generic f you can write it for is an Applicative f -- and that's already been written.
03:00:32 <zipper> Thinking (f ( x y)) (f n) = f ((x y) n)
03:00:56 <zipper> [*3] [3] --> [9]
03:01:17 <quicksilver> > [(*3)] <*> [3]
03:01:18 <lambdabot>  [9]
03:01:31 <quicksilver> it's as if someone read your mind, zipper :)
03:01:42 <zipper> quicksilver: I want to achieve that before reading about applicative functors
03:01:44 <quicksilver> fmapp' is called <*>
03:02:02 <quicksilver> then you need to make your own typeclass
03:02:10 <zipper> I am just about to read about them but I want to achieve it on my own before seeeing how the makers of haskell decided to solve it
03:02:23 <quicksilver> class Fmappable where fmapp :: f (b -> c) -> f b -> f c
03:02:52 <quicksilver> or maybe you can devise some more basic primitives you'd rather require
03:02:57 <quicksilver> and implement fmapp in terms of those
03:05:26 <zipper> quicksilver: I think I have understood what you mean. I should make fmappable a typeclass with just the type signature but when making instances of that typeclass is when I can implement it for [] Maybe etc. but I can't write a single general function to do so.
03:06:03 <quicksilver> correct
03:06:14 <quicksilver> unless you can think of some more basic operations you could use
03:06:26 <quicksilver> can you abstract the notion of 'Nothing' and 'Just' in some way?
03:06:49 <zipper> quicksilver: Can't think of any. You tell me.
03:10:18 <quicksilver> zipper: no, I can't :) Well 'Nothing' looks a bit like 'mempty' from Monoid.
03:11:13 <quicksilver> zipper: but 'Just' is difficult, because to generalise your equation "fmapp' (Just x) (Just y) = Just (x y)" you would need a way to unwrap the Just on the left and repackage it on the right
03:11:31 <quicksilver> zipper: this leads me to think that just having fmapp in the typeclass is the right way
03:11:52 <mark__> hello guys, I have the following question: If i have a record ``data Person = Person { first :: String, last :: String}``how can I access the update function for ``first``? Is there a better way than typing ``\ person firstname -> person { first = firstname }``?
03:12:31 <quicksilver> mark__: short answer, "No"
03:13:07 <quicksilver> mark__: Long answer: this is quite well agreed to be a gap in the language and various libraries exist to help, most of them using the word 'Lens' in their title.
03:14:02 <mark__> quicksilver: thanks for the quick answer! ;-)
03:14:13 <quicksilver> mark__: a more detailed answer is found in this stackoverflow question - http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
03:14:59 <zipper> quicksilver: I don't know monoids and monads.
03:16:37 <Benzi-Junior> zipper: well then it's time you learn something new
03:20:07 <zipper> quicksilver:lulz it worked https://gist.github.com/urbanslug/9227765 many thanks.
03:20:17 <zipper> supki: Thank you.
03:25:20 <zipper> "@jessitron: OH: um, this might be a personal question. What is a monad? #CPL14" <-- This tweet.
03:25:30 <zipper> Benzi-Junior: ^
03:34:45 <Benzi-Junior> @wikipedia Monad (functional programming)
03:34:45 <lambdabot> Unknown command, try @list
03:40:37 <Benzi-Junior> @wiki monad
03:40:37 <lambdabot> http://www.haskell.org/haskellwiki/monad
03:40:44 <Benzi-Junior> zipper: ^
03:41:58 <merijn> zipper: I'm willing to bet you know at least 3 monoids already, you just realise that you know them
03:42:13 <merijn> s/realise/don't realise
03:54:04 <Benzi-Junior> merijn: monoids and monads are not the same thing
03:54:42 <merijn> Benzi-Junior: His initial remark was "I don't now monoids and monads"
03:55:24 <t7> Benzi-Junior: monads are just monoids in the category of endo-functors
03:55:31 <Benzi-Junior> merijn: ahh yes, you are correct
03:56:10 <t7> do you guys say moan-ad  or mon-ad ?
03:56:37 <Kinnison> I say moh-nad
03:56:53 <Yuu-chan_> I say ÏÓÌ‡-‰‡.
03:57:04 <Kinnison> Yuu-chan_: But only when someone stands on your toes?
03:57:36 <Yuu-chan_> Kinnison: er, what?
03:58:00 <t7> i should learn the phonetic alphabet
03:58:18 <haskell_newb> edwardk: ping
03:58:33 <Kinnison> Yuu-chan_: I see a number of i's with various accents and a number of a's with various accents
03:59:14 <Yuu-chan_> Kinnison: oh, that must be encoding problems.
03:59:47 * Kinnison is running utf-8
04:01:35 <Yuu-chan_> —Ç–µ—Å—Ç
04:02:28 <Yuu-chan_> Yay, that helped.
04:02:33 <Kinnison> cyrillic TE IE ES TE
04:02:39 <Kinnison> in that order
04:03:10 <Yuu-chan_> Yeah, I checked in the archived chat log.
04:25:10 <mark__> Is there a way to wright `\ x y -> square $ x + y` with `.`? `square . (+)` does not work for me...
04:25:13 <Peaker> One defense I feel might be missing from explicitly concurrent (forkIO/async) Haskell programs -- is that the types of all threads are simply "IO", and it is easy to mess up by having an exception thrown in the wrong context (e.g: not forwarded to the right thread).  "async" itself helps, but sometimes one thread will do work on behalf of another, because messaging that other thread will over-serialize things
04:25:32 <Peaker> I'm wondering if it would make sense to annotate the IO type with some sort of "which thread this is supposed to execute in"
04:25:58 <Maior> @pl \x y -> square $ x + y
04:25:58 <lambdabot> (square .) . (+)
04:26:13 <Peaker> mark__: (+) is a curried function, e.g:  Int -> Int -> Int      so    square . (+)     is applying "square" to the Int -> ((Int -> Int))   component (marked with (()) )
04:26:23 <tychoreg> hi, does anyone know anything about cross compiling GHC? I'm inplace/bin/deriveConstants uses the wrong gcc but the correct nm , so the .o files are not compatible; ./configure reports the correct (cross platform) gcc but apparently not all the chain is copying that. how can I everything use the correct one which i pass with configure?
04:31:19 <mark__> Peaker: thanks
04:31:41 <Peaker> mark__: so basically you want to apply a function to:  Int -> Int -> ((Int))
04:32:53 <Peaker> mark__:    f . (+)   gets to the (Int -> Int),  so you can try to build a function that applies "square" to   Int -> ((Int))        and that is (square .)       that's why:   (square .) . (+)   applies square to the result-of-the-result-of-(+)
04:33:42 <merijn> Peaker: Actually, I wrote a paper about a similar idea, but haven't gotten around to prototyping
04:34:12 <merijn> Peaker: Instead of exceptions I was thinking about per thread GC and ensuring values from one GC don't leak into another (thus avoiding need for a global GC stop)
04:34:21 <Peaker> merijn: cool!
04:34:41 <merijn> Peaker: ETA for a prototype is indefinite atm, though
04:34:52 <Peaker> merijn: read-write sharing in Haskell is supposed to be rare, but due to hidden mutability in thunks, it's actually quite common, isn't it?
04:35:14 <Peaker> (making guarantees about not leaking stuff between threads and not requiring global GC hard?)
04:35:23 <merijn> Peaker: Actually, my idea was more general than this, considering your lamdu stuff I'm interested what you think
04:35:31 <quicksilver> that doesn't matter, Peaker, because thunk-update doesn't change things
04:35:43 <Peaker> quicksilver: GC-wise, you mean?
04:35:45 <quicksilver> thunk-update only refines values so it doesn't matter if it changes under your nose
04:36:01 <quicksilver> occasionally two threads may duplicate work
04:36:07 <quicksilver> but you never get a deadlock or a wrong answer
04:36:10 <Peaker> quicksilver: you mean it can only reach what was reachable from the thunk, less than that, and newly allocated stuff?
04:36:11 <merijn> Peaker: The problem is that to GC a value in thread 1 you need to be sure none of the other threads hold a reference to that value
04:36:17 <quicksilver> Peaker: yes, that too.
04:36:26 <merijn> Peaker: *that's* the costly bit about global GC stop
04:36:39 <merijn> Stopping every thread and syncing their GCs together
04:36:50 <Peaker> yeah
04:36:53 <quicksilver> merijn: you know GHC already has thread-local GC?
04:37:04 <Peaker> quicksilver: I must admit I've not thoroughly thought about mutithreaded GC :)
04:42:11 <merijn> quicksilver: There's still a global stop
04:42:28 <merijn> quicksilver: My basic idea would eliminate global stops entirely
04:42:50 <quicksilver> merijn: well I'm actually not sure what happened to JaffaCake's work in progress
04:43:13 <quicksilver> I have some vague memory that it sounded brilliant but ended up not improving performance. Have you at least read his paper?
04:43:25 <merijn> quicksilver: Or maybe it's in there and I'm out of date, at least in 7.6 there was a terrible scaling above 8 cores due to global GC stop
04:43:58 <merijn> quicksilver: No, because eliminating the GC was actually the idea I was writing about, it was just a convenient application I had for it
04:44:04 <quicksilver> merijn: https://ghc.haskell.org/trac/ghc/blog/new-gc-preview
04:44:27 <quicksilver> merijn: note that blog post is 2.5 years old, and I can't find information about what happened after that
04:45:39 <merijn> Peaker: If you're interested: https://dl.dropboxusercontent.com/u/1841232/oopsle.pdf
04:46:00 <merijn> More of a position paper then anything concretely technical
04:46:12 <merijn> I'd be curious what haskellers think of the basic premise, though
04:47:20 <merijn> dcoutts: ping?
04:47:41 <merijn> tychoreg: For cross-compilation of GHC you may want #ghc
04:47:51 <NobbZ> Does anyone know about ressources about haskell in the german language? Or any german communities/local user groups?
04:47:57 <Peaker> merijn: reading ... this sounds like general static-typing advocacy so far :)
04:48:44 <merijn> Peaker: Well, it was submitted to a software engineering workshop, not a FP/type system one :p
04:48:48 <Maior> NobbZ: I don't, but I'm about to talk to a bunch about monads...
04:48:55 <tychoreg> merijn: ah , i couldn't find that one before; sorry.. .
04:49:37 <merijn> tychoreg: No worries, you can ask GHC questions here too, but they tend to get drowned in noise/discussion, #ghc is *much* lower traffic, so bigger chance the right people see it
04:50:54 <Peaker> merijn: yay, got to a mention of GC :)
04:52:04 * hackagebot cabal-bounds 0.1.13 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.13 (DanielTrstenjak)
04:52:06 <NobbZ> Maior: So you are german? Your whois tells me you are connected from the Kingdom‚Ä¶
04:53:17 <Peaker> merijn: the part about lazy/strict data structures - isn't that kinda what "data" vs "codata" does in Agda?
04:53:42 <Maior> NobbZ: a quarter, though I don't think it's relevant; my whois should tell you the last hop in my connection is from a box with .co.uk rdns but the IP should locate somewhere in the US
04:54:02 <merijn> Does anyone knowledgable about cabal know if there's another way to set the build directory other than "--builddir=foo"? (i.e. can I safely assume the builddir is Distribution.Simple.Setup.defaultDistPref unless overwritten by --builddir?"
04:54:13 <merijn> Peaker: Yes, or at least similar
04:54:16 <Peaker> merijn: btw, do you know about universe polymorphism in Coq?
04:54:28 <merijn> Peaker: No
04:54:30 <Maior> NobbZ: but right now I'm in .de
04:54:34 <Maior> MUC to be precise
04:54:51 <Peaker> merijn: do you know about the (Set : Set) paradox (e.g: Russell's paradox)?
04:54:57 <merijn> Yeah
04:55:04 <Peaker> merijn: and the universe levels used to solve it?
04:55:13 <Peaker> Set0 : Set1 : Set2 : ...
04:55:27 <merijn> I read about of Luo's Extended CoC, which goes into it a bit, so I'm a bit familiar with it
04:55:38 <zomg> I think functional programming just became irrelevant https://github.com/lhartikk/ArnoldC
04:55:43 <zomg> That is so good. :D
04:55:59 <Peaker> merijn: Agda/Coq/etc let you write universe-polymorphic code like:  forall u. Set u -> Set (1+u) -> ...
04:56:13 <merijn> Peaker: Right
04:56:17 <Peaker> merijn: but it gets annoying to worry about universe levels everywhere, when that's entirely not the point of your code
04:56:29 <Peaker> merijn: even when you want to be universe polymorphic, you have to specify all these annoying universe type variables
04:56:44 <NobbZ> Maior: MUC means Munich? Thats at the other end‚Ä¶ Only people here I can talk with about haskell are my fellow students and our professor, and since we have about 7 weeks without lectures I won't see anyone of them
04:57:12 <Peaker> merijn: so Coq and NuPRL (IIRC) both have implicit universe polymorphism -- that basically infer all the universe level polymorphism crap automatically -- and make your code universe polymorphic without any syntactic noise
04:57:31 <Peaker> merijn: I'm mentioning all this because it sounds like this kind of implicit/unspecified universe polymorphism is what you want to apply to other stuff
04:58:11 <Peaker> you can program in Coq as if (Set:Set) and ignore Russell's paradox -- but if you actually encounter paradoxical code, it'll error out because the inferred universes won't work out
04:58:45 <merijn> Peaker: Right, I want to be implicit/inferred in most cases, but the ability to add in primitives which are not polymorphic
04:59:06 <merijn> Peaker: Thus ensuring said primitives are not used incorrectly/unsafely
04:59:11 <Peaker> merijn: yeah.. and you probably don't want the ST-like phantom type to pollute every single type everywhere just so you can be polymorphic
04:59:18 <merijn> Peaker: Right
04:59:38 <Peaker> I wonder if there's a way to do this that doesn't require ad-hoc extensions to the type system for every such idea
04:59:59 <merijn> Peaker: Right, that's my question too :)
05:00:02 <Peaker> e.g: Can Haskell be extended such that ST can be encoded in a way that the "phantom" type is never mentioned?
05:00:05 <merijn> Peaker: The main issue I saw was the following
05:00:09 <Peaker> (but still checked as if it was there)
05:00:41 <merijn> Peaker: If you treat (->) and * as the fundamental kinds that you want to assign different types to, you can do a bit more than know, but the question is how much
05:01:37 <merijn> Peaker: If you want to be more flexible you could want your typing to "go into" ADTs, but doing so would require the ability to "post-hoc" define typing rules for existing ADTs
05:01:40 <merijn> Which seems hard
05:01:52 <Peaker> merijn: this paper sounds like a great thing to actually figure out how to do -- but probably extremely difficult to figure out well, too :)
05:01:58 <merijn> Yeah
05:02:17 <merijn> I'd need significant prototyping time and this isn't (yet) related to my phd research :)
05:02:37 <Peaker> merijn: this sounds like its own very big thing, not a little side-project, to me :)
05:02:46 <merijn> Epic seems a good starting point to target (it's the backend for Epigram/Idriss)
05:03:12 <merijn> I'd try to implement the parallel GC typing for a minimal language using that, that seems a decent starting point
05:03:22 <merijn> That or I sucker some master students into doing it for me...
05:04:05 <merijn> I'm probably not qualified to supervise master students directly, but maybe I can sucker some professor into signing it off for me
05:04:42 <Peaker> merijn: in the separate GC domains -- how do you share references to the same data?
05:05:13 <Peaker> brb
05:06:12 <merijn> Peaker: You need an explicit hand-off, which can be implemented as runtime primitive, you could then expose a Chann/communication primitve that allows both domain polymorphic writes and reads, using this primitive
05:06:44 <merijn> Peaker: This way you can still hand-over values, but the typing guarantees that they all go through the appropriate primitve
05:07:56 <merijn> Unrelatedly: Where can I best get clarification of what Cabal is doing? dcoutts appears to be busy and I'm not confident enough I've identified all the relevant bits of source...
05:26:30 <fragamus> :t fmod
05:26:31 <lambdabot>     Not in scope: `fmod'
05:26:32 <lambdabot>     Perhaps you meant `mod' (imported from Prelude)
05:27:37 <quicksilver> fragamus: looking for a floating point version of mod?
05:27:47 <fragamus> yeah
05:27:56 <fragamus> one that does not suck
05:28:06 <quicksilver> @type Data.Fixed.mod'
05:28:07 <lambdabot> Real a => a -> a -> a
05:28:12 <quicksilver> there it is.
05:28:19 <fragamus> yay
05:28:23 <quicksilver> As for not sucking, I don't know
05:28:50 <fragamus> i'll let you know. It needs to behave itself with negative numbers
05:34:04 <fragamus> it does not suck
05:37:18 <quicksilver> fragamus: \o/
05:37:32 <fragamus> thank you
05:45:55 <bigOmega> zzz
05:47:10 * hackagebot bumper 0.6 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.6 (AdamBergmark)
05:47:12 * hackagebot bumper 0.6.0.1 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.6.0.1 (AdamBergmark)
06:03:30 <Peaker> merijn: a hand-off hands off exclusivity, doesn't it?
06:03:49 <Peaker> merijn: or do you mean for the shared-read case too?
06:06:01 <bernalex> when I have multiple ghc installs, how do I tell cabal configure/build wihch one to rely on?
06:06:31 <bernalex> oh, I guess -w will work
06:06:49 <bernalex> yep.
06:11:55 <merijn> Peaker: Well, there's two options, having a separate "global" store for shared things OR duplicating the value so both threads have unique copies
06:12:27 <merijn> Peaker: The latter has the downside of wasting space (and in haskell computation, due to elimination of sharing)
06:12:47 <Peaker> merijn: you could force it first, to only waste space
06:13:09 <merijn> Peaker: That's a haskell specific issue anyway, and this idea was not necessarily tied to haskell itself
06:13:29 <Peaker> merijn: if you duplicate the value, it sounds a lot like simple processes&IPC rather than threads
06:13:48 <merijn> Peaker: Well, yes, because that's what you want to be scalable ;)
06:14:13 <merijn> Peaker: Albeit it processes & IPC that allow typesafe communication and that can be accommodated in the runtime
06:14:32 <merijn> bernalex: Even simpler
06:14:43 <merijn> bernalex: cabal will simply use whichever ghc is first in your PATH
06:14:57 <bernalex> merijn: I don't want to use that one ;-)
06:15:00 <merijn> bernalex: I switch between 7.6 and 7.8 by just prefixing my path with the appropriate bin directory
06:15:16 <bernalex> I see. -w is nice enough when I just want to build that one library.
06:18:44 <kadoban> is there a cute way to rewrite the lambda in foldr (\x xs -> x:"\n":xs) []  using like (:) and (.) or something? seems like there should be, but i can't figure it out
06:19:01 <Peaker> merijn: well, then this solution already exists (e.g: CloudHaskell)
06:20:32 <merijn> Peaker: I know, which is why I don't think the GC is the best usecase, it's just a convenient example of why you might want to sneak a phantom type param (like ST's) into the type system
06:20:50 <merijn> kadoban: There is, but it won't be pretty, most likely
06:21:04 <merijn> @pl \x xs -> x:"\n":xs
06:21:04 <lambdabot> (. ("\n" :)) . (:)
06:21:27 <kadoban> merijn: ah, thanks. yeah, kinda figured it'd be gross, but i'm really bad at point-free, so i figure practice can't hurt
06:23:12 <Sonderblade> kadoban: make a list of 2-tuples and then concat
06:24:57 <awestroke> https://gist.github.com/anonymous/7af2028f41ce71942cb7 how do I cast the foreign C type to double?
06:25:27 <awestroke>  or convert
06:25:35 <merijn> awestroke: fromIntegral
06:25:43 <merijn> :t fromIntegral :: CInt -> Double
06:25:44 <lambdabot>     Not in scope: type constructor or class `CInt'
06:25:44 <lambdabot>     Perhaps you meant one of these:
06:25:44 <lambdabot>       `Int' (imported from Data.Int),
06:25:49 <merijn> awww
06:25:56 <merijn> You get the idea
06:25:59 <merijn> :t fromIntegral
06:26:00 <lambdabot> (Integral a, Num b) => a -> b
06:26:20 <kadoban> Sonderblade: sorry, you mean like... zipWith (,"\n") or something, and then go from there?
06:26:20 <merijn> @quote you.want.double
06:26:20 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:27:21 <t7> 'who do you call?'
06:27:26 <t7> so close
06:28:07 <merijn> t7: I know
06:28:10 <awestroke> merijn: thanks. any idea how I would convert Double to Foreign.C.Types.CFloat?
06:28:52 <t7> @dijnn (b -> a) -> (c -> b) -> c -> a
06:28:52 <lambdabot> f a b c = a (b c)
06:29:07 <merijn> :t realToFrac
06:29:07 <lambdabot> (Fractional b, Real a) => a -> b
06:29:55 <merijn> awestroke: Be careful with loss of precision, though
06:30:08 <t7> @dijnn Either a b -> Either b c -> Either (a, c) b
06:30:08 <lambdabot> f a b =
06:30:09 <lambdabot>     case a of
06:30:09 <lambdabot>     Left c -> case b of
06:30:09 <lambdabot>               Left d -> Right d
06:30:09 <lambdabot>               Right e -> Left (c, e)
06:30:10 <lambdabot>     Right f -> Right f
06:30:22 <t7> super spam time
06:30:46 <Sonderblade> kadoban: i think so, perhaps you just need the intercalate or intersperse function?
06:31:15 <kadoban> Sonderblade: intersperse would work, but i want one at the end too, heh...
06:31:23 <merijn> awestroke: The GHC runtime had a nice bug with an overflow in the conversion crashing on OSX due to a conversion without bounds checking, for example
06:31:47 <kadoban> Sonderblade: oh wait....i think i just re-invented unlines
06:32:42 <Sonderblade> great, foldr averted :)
06:32:54 <kadoban> haha, indeed :)
06:39:24 <merijn> argh
06:39:48 <merijn> I need to ammend my GHC patch for the 3rd time with a "really, really fixed bug this time"
06:40:34 <merijn> How can three people have reviewed and committed this without noticing it's wrong >.<
06:41:19 <awestroke> my program runs really slow... I'd love some feedback: https://gist.github.com/anonymous/06ed691574acb9346336
06:43:05 <merijn> @hoogle Monad m => (a -> m b) -> m a -> m a
06:43:06 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
06:43:07 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
06:43:07 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
06:43:41 <merijn> Are there any versions of =<< and >>= the resemble Applicative's <* and *> ?
06:44:57 <prophile> :t (*>)
06:44:58 <lambdabot> Applicative f => f a -> f b -> f b
06:45:05 <prophile> (>>)?
06:45:35 <t7> pro 'phile
06:45:38 <t7> hehe
06:45:53 <merijn> No, like above "(a -> m b) -> m a -> m a"
06:46:10 <merijn> prophile: I just want to do >>= but return the initial input, rather than the resulting b
06:46:32 <prophile> ah, I see
06:47:11 <quicksilver> merijn: I don't think so.
06:47:18 <merijn> Bleh
06:47:50 <prophile> @pl \f x -> x >>= (\y -> f y >> return y)
06:47:50 <lambdabot> (=<<) . (`ap` return) . ((>>) .)
06:48:07 <quicksilver> (\x -> x $> f x) =<< a
06:48:14 <quicksilver> something like that
06:48:21 <merijn> I would like to go on record and say that silent over/underflows suck and are terrible mistakes in language
06:48:24 <Rylee> @src ($>)
06:48:24 <lambdabot> Source not found. I feel much better now.
06:48:27 <Rylee> :-/
06:48:39 <quicksilver> but @pl always make it ugly if you duplicat an argument
06:48:41 <quicksilver> IYSWIM
06:49:00 <Rylee> > (+) 2 3
06:49:01 <lambdabot>  5
06:52:26 <h007> hello, is it possible to use unpack pragma on type definition with type variable e.g. data T = T {-# UNPACK #-} !Float --> data T a = T {-# UNPACK #-} !a
06:52:33 <bartavelle> I get a "Constraint is no smaller than the instance head" for "instance MonadIO m => MonadStack m where", is there some thing I could do to fix it without UndecidableInstances ?
06:52:53 <mbuf> can any one walk me through this code? http://lpaste.net/100413  when does t_max, t_min get assigned for a given list of [2, 3, 1, 4, 5]?
06:53:24 <merijn> h007: No, because GHC won't know the size of the unpacked value
06:54:22 <Iceland_jack> mbuf: That code is far from idiomatic, would you rather like to see how the idiomatic version would be?
06:54:28 <merijn> mbuf: The layout of that code makes it really confusing
06:54:28 <h007> maybe i need an extension. the above doesn't work
06:54:40 <merijn> h007: It can't work
06:54:43 <h007> merijn: what if i constraint a?
06:54:49 <merijn> h007: To what?
06:54:57 <mbuf> Iceland_jack, sure
06:55:03 <mbuf> merijn, yes
06:55:19 <merijn> h007: As long as 'a' is unknown, how can GHC know 1) how big 'a' is and thus 2) how much space to reserve for it
06:55:33 <h007> e.g. data (Integral a) T a = T {-# UNPACK #-} !a
06:55:39 <Iceland_jack> mbuf: So almost always when you see ‚Äòhead‚Äô and ‚Äòtail‚Äô and ‚Äònull‚Äô, pattern matching should be used instead
06:56:03 <h007> merijn: ok
06:56:38 <Iceland_jack>     maxmin [h] = (h, h)
06:56:38 <Iceland_jack> is pretty much what is intended by this part
06:56:38 <Iceland_jack>     maxmin list = let h = head list
06:56:38 <Iceland_jack>                   in if null (tail list)
06:56:41 <Iceland_jack>                      then (h, h) ...
06:56:48 <Iceland_jack> mbuf: Do you see how much clearer one is?
06:57:00 <h007> merijn: can i do something like: type MyT = T {-#UNPACK#-} !Int
06:57:19 <Iceland_jack> ‚Äúif null (tail list)‚Äù is really asking ‚Äúis list a singleton list‚Äù
06:57:36 <h007> merijn: it doesn't work, but thought it might need an extension
06:57:54 <mbuf> Iceland_jack, okay
06:57:56 <supki> bartavelle: no
06:58:06 <supki> bartavelle: and that kind of instances is bad in general
06:58:15 <supki> bartavelle: because it overlaps with everything
06:58:23 <Iceland_jack> mbuf: now the other case is when the rest of the list is non-empty
06:58:28 <bartavelle> supki: yeah I just figured it out :/ thanks for the answer
06:58:49 <h007> merijn: i get this error ghc: panic! (the 'impossible' happened)
06:58:50 <Iceland_jack> and that is when you pattern match on (x:xs) (following a match on [h])
06:59:35 <Iceland_jack> mbuf: Do you know what matching with (x:xs) does?
06:59:35 <mbuf> Iceland_jack, okay
06:59:40 <mbuf> Iceland_jack, yes
07:00:07 <Iceland_jack> right, so then we can compare the head to the first result of the recursive call (maxmin (tail list))
07:00:35 <Iceland_jack>     maxmin (x:xs) = let (max, min) = maxmin xs in ...
07:01:26 <Iceland_jack> mbuf: then we have the ‚Äòmax‚Äô and ‚Äòmin‚Äô values (t_max and t_min in your code) of the rest of the input, so you have to compare it against the current element ‚Äòx‚Äô
07:01:28 <merijn> h007: type aliases can't have constructors, so your current "type MyT = T Int" makes no sense
07:01:30 <awestroke> How do I enable profiling of my program? -prof requires that I have dynamic versions of all packages
07:01:57 <merijn> h007: Unless you're thinking of newtype, but then it still makes no sense as newtypes don't exist at runtime
07:02:07 <Iceland_jack> mbuf: Can you take it from here?
07:02:07 <Iceland_jack>     maxmin []     = error "..."
07:02:07 <Iceland_jack>     maxmin [x]    = (x, x)
07:02:07 <Iceland_jack>     maxmin (x:xs) = let (max, min) = maxmin xs in ... -- TODO mbuf
07:02:17 <awestroke> I get "Could not find module `Data.Complex'" when compiling with -prof
07:02:22 <merijn> awestroke: You can only profile binaries if you have profiled versions of all libraries, unfortunately
07:04:08 <mbuf> Iceland_jack, I worked it out, makes sense
07:04:47 <Iceland_jack> mbuf: I hope you'll find the resulting code far clearer
07:04:59 <Iceland_jack> also it helps GHC perform exhaustiveness checking when you pattern match on lists like that
07:07:51 <Iceland_jack> mbuf: Instead of using ‚Äúa = fst ab; b = snd ab‚Äù you should pattern match on a tuple ‚Äúlet (a, b) = ab‚Äù, instead of using ‚Äúx = head list; xs = tail list‚Äù you should use ‚Äúlet (x:xs) = list‚Äù, ...
07:08:15 <Iceland_jack> It's almost always preferrable
07:08:15 <Iceland_jack> preferable
07:11:41 <mbuf> Iceland_jack, I see
07:13:22 <Iceland_jack> mbuf: Do you want someone to walk through the new version or possibly the old version still?
07:14:30 <mbuf> Iceland_jack, that should be fine; thanks!
07:14:37 <Iceland_jack> You're welcome
07:22:59 <zipper> @src Control.Applicative.pure
07:22:59 <lambdabot> Source not found. :(
07:23:27 <zipper> :t Control.Applicative.pure
07:23:28 <lambdabot> Applicative f => a -> f a
07:34:00 <ski> mbuf,Iceland_jack : actually, instead of `let (x:xs) = list', it's simpler (and it think it looks nicer) to say `let x:xs = list'
07:34:42 <Iceland_jack> yes that's right
07:39:52 <quicksilver> ski: I dunno. That version seems to me like a corner case in the syntax
07:40:19 <quicksilver> ski: let x+y = 4 binds the operatior (+)...
07:40:41 <quicksilver> hmm maybe it's not really a corner case.
07:40:44 <quicksilver> ignore me :)
07:52:54 <taktoa> So I am working on a haskell log analyzer for teamspeak 3
07:53:10 <taktoa> and I am having trouble coming up with an algorithm
07:53:36 <taktoa> basically, I have a [(IP, UserID)]
07:54:06 <taktoa> A person can have multiple IPs, but an IP (for all intents and purposes) never refers to more than one user
07:54:30 <taktoa> Likewise, a user can have multiple UserIDs, but an ID never refers to multiple people
07:54:57 <kadoban> taktoa: in general, an IP can refer to more than one user. you sure your problem prevents this somehow?
07:55:06 <taktoa> The userbase is small
07:55:18 <taktoa> IPs are very very unlikely to cover more than one user
07:55:44 <kadoban> taktoa: no two people behind a NAT router?
07:55:49 <taktoa> Nope
07:56:06 <taktoa> Plus, there will be a step in which the Person to UserID mapping can be inspected
07:56:12 <taktoa> and modified if necessary
07:56:28 <quicksilver> so what's the problem taktoa ?
07:57:00 <taktoa> I am having trouble thinking of a way to infer the UserID to Person mapping based on the information given
07:57:20 <taktoa> I thought maybe you could run intersect between all the lists
07:57:26 <taktoa> in a complete graph
07:57:40 <taktoa> but firstly that's O(n^2)
07:57:49 <taktoa> and secondly it gets really really messy
07:58:14 <taktoa> I'm wondering if there is already an extant algorithm for this kind of thing
07:58:29 <taktoa> or at least an idiomatic way to express it
07:59:50 <taktoa> I am thinking that it might work better if I use Sets instead of lists
08:00:47 <quicksilver> taktoa: the information you've given so far is simply [(IP, UserID)]
08:00:57 <quicksilver> taktoa: how can I infer anything about persons from that?
08:01:11 <monochrom> in fact, what does "Person" mean?
08:01:12 <taktoa> You can say
08:01:17 <kadoban> taktoa: i'm not sure i understand your current algorithm...you mean you find matching IPs, and assume all of those corresponding UserIDs are the same person?
08:01:22 <monochrom> you are witholding information
08:01:23 <taktoa> Yes
08:01:49 <taktoa> Like, merge all of the IPs with the same UserID
08:02:04 <taktoa> Then look for IP sets that intersect and merge those UserIDs
08:02:17 <ski> quicksilver :)
08:02:32 <taktoa> you can eventually find a set of lists of UserIDs
08:02:35 <ski> (obviously i say `case .. of [] -> ...; x:xs -> ..x..xs..' as well)
08:02:49 <taktoa> where each list refers to a unique user
08:03:40 <zipper> @src Data.List.map
08:03:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:03:50 <zipper> No I'm silly
08:03:57 <quicksilver> sounds like a one-liner taktoa
08:04:03 <kadoban> taktoa: ah okay. well if nothing else, you can sortBy (comparing fst), then groupBy (comparing fst) and work from there, right?
08:04:35 <taktoa> Hmm..
08:04:35 <kadoban> each group will be a person, if i understood your definition correctly
08:04:42 <taktoa> Yes
08:04:58 <taktoa> Okay, how about this
08:05:03 <taktoa> here's a subproblem
08:05:05 <quicksilver> go from [(IP,UserId)] to Map IP (Set UserId)
08:05:11 <quicksilver> using fromListWith Set.union
08:05:31 <kadoban> ah, yeah that'd be cuter probably
08:05:47 <kadoban> fromListWith is pretty magical stuff
08:06:05 <taktoa> let me look into this
08:06:29 <taktoa> I have to leave in about seven minutes as I am at school but I will probably come back at 4 PM EST
08:08:17 <quicksilver> t (\xs -> Data.Map.fromListWith Data.Set.union (map (\(k,v) -> (k,Data.Set.singleton v)) xs))
08:08:24 <quicksilver> :t (\xs -> Data.Map.fromListWith Data.Set.union (map (\(k,v) -> (k,Data.Set.singleton v)) xs))
08:08:25 <lambdabot> (Ord k, Ord a) => [(k, a)] -> M.Map k (S.Set a)
08:09:36 <taktoa> so will that handle merging the UserIDs, or just the IPs?
08:09:54 <quicksilver> that's just merging the UserIDs found at the same IP
08:10:10 <taktoa> okay
08:10:25 <quicksilver> next step is to merge all those UserId sets which have a common element
08:10:57 <quicksilver> I'd explode it to a Map UserId (Set UserId)
08:11:08 <quicksilver> and the work through those in an abitrary order, merging the RHSes
08:11:42 <taktoa> hmm... let me think through that
08:13:17 <Rembane> > fromRational (sin 7) :: Double
08:13:17 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
08:13:18 <lambdabot>    arising from a use of `GHC.Float.sin'
08:13:18 <lambdabot>  Possible fix:
08:13:18 <lambdabot>    add an instance declaration for
08:13:18 <lambdabot>    (GHC.Float.Floating GHC.Real.Rational)
08:13:39 <Rembane> How do I get a Double from that statement?
08:13:59 <taktoa> okay, I'll be back later
08:14:35 <quicksilver> Rembane: just (sin 7 :: Double)
08:14:43 <quicksilver> > sin 7 :: Double
08:14:44 <lambdabot>  0.6569865987187891
08:15:36 <Rembane> quicksilver: Thanks!
08:25:40 <mzarella> data <- readFile "data.json" returns this error: <interactive>:6:6: parse error on input `<-'
08:26:01 <mzarella> In GHCi
08:26:54 <Iceland_jack> mzarella: You can't use data
08:27:07 <quicksilver> data is a keyword
08:27:09 <Iceland_jack> it's a keyword, pick something else and it will work
08:30:29 <mzarella> I also just tried `Data.Aeson.parseJSON $ read (readFile "data.json")`, but I get this error:  Couldn't match type `IO String' with `[Char]'
08:30:50 <mzarella> Iceland_jack: Thanks!
08:30:55 <mzarella> d <- ... worked
08:31:00 <Iceland_jack> mzarella: If you have a value of type 'IO a' and you want to apply a function of type 'a -> b' to it, use fmap
08:31:21 <Iceland_jack> @ty getLine
08:31:22 <lambdabot> IO String
08:31:23 <Iceland_jack> @ty fmap length getLine
08:31:24 <lambdabot> IO Int
08:32:48 <Iceland_jack> @ty readFile ""
08:32:49 <lambdabot> IO String
08:32:51 <mzarella> Data.Aeson.decode d -- Couldn't match type `[Char]'
08:32:52 <Iceland_jack> @ty fmap read (readFile "")
08:32:53 <lambdabot> Read b => IO b
08:33:32 <Iceland_jack> Have you looked at http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson.html ?
08:34:22 <magneticduck> how do I counter hGetContent's IO forking?
08:34:42 <magneticduck> I want to wait until the handle closes, and then proceed
08:35:37 <geekosaur> don't use hGetContents
08:36:27 <magneticduck> what do I use?
08:36:27 <geekosaur> hGetChar, hGetLine, etc. don't use unsafeInterleaveIO
08:37:12 <quicksilver> maybe Data.Text.getContents
08:37:17 <magneticduck> isn't there just a nice little function to collect the stuff coming through a handle until it closes, and then return the output?
08:37:23 <quicksilver> or Data.Bytestring.Strict.getContents
08:37:31 <quicksilver> depending if it's text or bytes you really have
08:37:34 <magneticduck> texyt
08:37:36 <magneticduck> text*
08:37:51 <quicksilver> then Data.Text.hGetContents is the one to use
08:37:57 <quicksilver> http://hackage.haskell.org/package/text-0.7/docs/Data-Text-IO.html
08:38:21 <magneticduck> conflicting names eh
08:38:23 <magneticduck> alright
08:38:24 <quicksilver> 0.7 is an arbitrary version that google happened to give me
08:38:31 <quicksilver> just use the version in your haskell platform though
08:38:47 <quicksilver> "These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.
08:38:50 <quicksilver> import qualified Data.Text as T"
08:38:53 <quicksilver> :)
08:39:15 <magneticduck> yes
08:40:33 <mzarella> import qualified Data.ByteString.Lazy as B; jsonFile = "data.json"; getJSON = B.readFile jsonFile; {-- successful so far --} print fmap Data.Aeson.decode getJSON -- Couldn't match expected type `(ByteString -> Maybe a1) -> IO ByteString -> t0'
08:41:09 <geekosaur> magneticduck, collecting all the output all at once is not a very common use case, normally you want to stream your processing (which hGetContents lends itself to). what happens if your file ends up being 5GB?
08:41:36 <mzarella> Iceland_jack: I have looked at that page, but it assumes I know how to get the data into the proper format
08:41:49 <geekosaur> mzarella, did you drop some parens there?
08:42:42 <geekosaur> ```print fmap Data.Aeson.decode getJSON``` looks very wrong to me, possibly you meant ```print $ fmap Data.Aeson.decode getJSON```?
08:42:43 <magneticduck> geekosaur: it won't.
08:42:50 <magneticduck> I'm dealing with little programs
08:42:55 <magneticduck> just reading their output and parsing it
08:43:01 <magneticduck> very small outputs usually
08:43:06 <magneticduck> but sometimes they take a while to finish
08:43:50 <mzarella> geekosaur: I did, my bad. print $ fmap Data.Aeson.decode getJSON -- No instance for (FromJSON a0) arising from a use of `decode'
08:43:55 <levi> magneticduck: Maybe try the io-streams library? It's got a pretty simple API.
08:44:50 <geekosaur> so it can't figure out what the type of getJSON is. (which seems weird)
08:45:00 <eyem> Hi could someone guide me to a solution, i have a list and can only use fold, i have to sort elements < 3 then add 0 else add x+3 to the sum, this is what i've come up with foldr (+) (foldr (\f x -> if x < 3 then 0 else x+3) 0 [1..10]) [1..10]
08:45:10 <quicksilver> geekosaur: isn't it that Aeson.decode need to know what type to decode into?
08:45:32 <geekosaur> mm, yes, that seems even more likely
08:45:38 <mzarella> It's getJson, my bad, but it's still the same error.
08:45:49 <geekosaur> your only constraints there are Show and FromJSON, and there's a bunch of possibilities
08:46:04 <geekosaur> you have to pick one at compile time, it won't figure it out at runtime based on the data for you
08:46:05 <Maior> NobbZ: http://twitter.com/solirc_/status/438715766624747520
08:46:16 <Maior> NobbZ: though you never did tell me where you were
08:47:29 <quicksilver> mzarella: Aeson is a typed decoder. It will decode into the type you request
08:47:39 <quicksilver> (and complain at runtime if the JSON it receives doesn't match that type)
08:47:48 <quicksilver> I think there is a generic supervalue you can use
08:47:52 <quicksilver> "Value"
08:48:38 <quicksilver> so you could try print =<< ((fmap Data.Aeson.decode getJson) :: IO Value)
08:49:46 <AncientPC> What does Bool do in something like this: foo x = y where Bool y = bar
08:50:19 <quicksilver> AncientPC: well in that case it's a constructor
08:50:22 <AncientPC> or foo x = if test then 1 else 0 where Bool test = stuff
08:50:28 <mzarella> quicksilver: your suggestion errors with `Couldn't match type `Maybe a0' with `Value'`
08:50:58 <mzarella> Here's what I'm trying to do...
08:51:04 <quicksilver> mzarella: oh yes, I forgot the Maybe
08:51:16 <NobbZ> Maior: I'm at Hamburg, so Berlin is somewhat too far away right now :(
08:51:18 <quicksilver> so you could try print =<< ((fmap Data.Aeson.decode getJson) :: IO (Maybe Value))
08:51:33 <quicksilver> AncientPC: it's unpacking the Bool constructor off stuff
08:51:48 <AncientPC> quicksilver: ahh ok, so data constructors of same type can be coerced into one another?
08:52:04 <quicksilver> AncientPC: no.
08:52:38 <mzarella> I have a json structure which look like this: arr = [ {"id": 1, "hits": [1,2,3]}, {"id": 2, "hits": [1,3,4]} ], and what I want is to reduce each hits array down to just unique elements between all the hits arrays. I am trying to parse some JSON, so I can get the data in a format so that I can ask how you would typically do something like this in Haskell.
08:52:38 <quicksilver> AncientPC: stuff is presumed to have Bool constructor. That code 'unwraps it' so that test takes the value of whatever was inside the Bool constructor
08:52:57 <mzarella> "arr": [...
08:53:03 <AncientPC> quicksilver: ahh ok, I was misunderstanding how the code works. Thanks.
08:53:49 <quicksilver> AncientPC: if 'stuff' turns out not to have a Bool constructor that will give a runtime error
08:53:55 <quicksilver> AncientPC: something like this:
08:54:01 <quicksilver> > let Just x = Nothing in x
08:54:02 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
08:54:33 <quicksilver> mzarella: yes. What you really want to do is understand Aeson well enouhg to pick the native haskell type which matches what you're doing.
08:54:46 <quicksilver> mzarella: however 'Maybe Value' is a starting point to prove your JSON decoding is working
08:55:30 <BMeph_> Why isn't reverse of a Sequence O(log n)?
08:56:18 <quicksilver> BMeph_: because you have to rebuild the whole finger tree the other way around?
08:57:17 <mzarella> quicksilver: the IO (Maybe Value) worked
08:57:51 <mzarella> Just (Object fromList [("results",Array (fromList [Object fromList [("hits",Array (fromList [Number 1.0,Number 2.0,Number 3.0])),("id",Number 1.0)],Object fromList [("hits",Array (fromList [Number 1.0,Number 2.0,Number 4.0])),("id",Number 2.0)],Object fromList [("hits",Array (fromList [Number 1.0,Number 2.0,Number 5.0])),("id",Number 3.0)]]))])
08:58:33 <quicksilver> mzarella: good :) you have JSON parsing working.
08:58:36 <BMeph_> quicksilver: As opposed to sorting, which does something different? :)
08:58:52 <mzarella> So now, let c = ((fmap Data.Aeson.decode getJson) :: IO (Maybe Value))
08:59:01 <mzarella> I have the JSON in a format that I can manipulate
08:59:16 <quicksilver> BMeph_: did you mean to ask why isn't it O( n log n)
08:59:22 <quicksilver> BMeph_: because that's not what you said :)
08:59:54 <mzarella> The original question is: how do you reduce each hits list down to just unique elements between all the hits lists?
09:00:39 <mzarella> Maybe I should make this simplar
09:01:15 <mzarella> Actually, I don't know how to make this question simpler
09:01:35 <BMeph_> quicksilver: Actually, I think it can arguably be O(log n). I'd like to have someone convince me differently.
09:01:40 <Reite> mzarella: I think people understand the question, they are just hesitating to write it for you :)
09:01:52 <mzarella> :(
09:01:58 <Reite> If you want to learn haskell you should try what you can and ask something more specific
09:02:39 <quicksilver> mzarella: I do understand your question, and I'm not going to write the program for you.
09:02:56 <quicksilver> mzarella: you can write a better data type and write a fromJSON instance for it and use Aeson to decode to that
09:03:19 <quicksilver> or you can try a generic data type like Map String [Map String Value]
09:03:31 <quicksilver> or Map String [Map String (Either Int [Int])]
09:03:38 <quicksilver> which somewhat covers the cases you have
09:03:44 <quicksilver> http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson.html
09:03:47 <quicksilver> read the docs. try stuff :)
09:03:54 <quicksilver> post source code here when you get stuck
09:05:06 <mzarella> quicksilver: Ok, thank you.
09:07:49 <quicksilver> BMeph_: well, it's "clever" that it's O(n) rather than O(n log n) which is because the monoid is basically symettrical so the fingertree structure will be the same but reversed
09:09:32 <quicksilver> BMeph_: as to whether you could be cleverer and somehow do it in O(log n)? I don't know, I'm not a fingertree expert. You'd have to share most of the structure somehow.
09:09:58 <BMeph_> quicksilver: I guess the main issue is: "What 'n' are we talking about?" - I assumed that the "n" is for the number of entries in the sequence.
09:10:03 <quicksilver> BMeph_: you could do it in O(1) by putting a special case in the code for reversed sequences of course.
09:10:11 <quicksilver> BMeph_: yes, that is right.
09:10:53 <theorbtwo> quicksilver: Then you'd have to check if the sequence is reversed, which I'm pretty sure you an't do in better then O(n), right?
09:12:17 <Feuerbach> quicksilver: there's nothing clever in it being O(n). fromList . reverse . toList is O(n), too.
09:13:18 <BMeph_> quicksilver: I have mentioned that as well, but then you have to add that check for reversed sequences to every function with a (Seq a) argument, which ought to be automatable, but sounds like a pain, and a kludge.
09:13:35 <quicksilver> theorbtwo: no, I mean literally just a boolean flag at the top level of the structure meaning "reverse the senses of indices for this sequence"
09:13:57 <quicksilver> BMeph_: right. Such hacks are always possible, and of course get out of control if you apply many of them, and make the common case slower.
09:14:12 <quicksilver> BMeph_: they can still be worth it as a micro optimisation for a special case though.
09:14:55 <quicksilver> Feuerbach: Duh. Quite right. I had forgotten fromList was O(n)
09:15:39 <quicksilver> BMeph_: (Sequence is itself a micro-optimisation for a special case - of Data.FingerTree)
09:16:44 <BMeph_> quicksilver: It'd be much easier to justify, if only rhetorically, if Lists weren't used Everywhere.... :/
09:18:11 <BMeph_> quicksilver: Similar to how Int is used as the standard index type, when we have a non-negative type (Word) that is "obviously" more correct.
09:18:49 * quicksilver nods
09:18:51 <BMeph_> (pity that it has such a "non-intuitive" name. though.)
09:18:55 <quicksilver> word
09:19:03 * BMeph_ laughs
09:30:47 <NobbZ> Is there a way to create an own datatype that behaves like Int but restricts it values to be inbetween for example 1 to 100?
09:31:21 <geekosaur> there are ways but they're not particularly convenient
09:31:50 <geekosaur> haskell can't really do that since it involves runtime checks
09:32:34 <tromp_> you can go the Data.Ratio route
09:32:37 <NobbZ> I hoped it would be possible and simple since theres already the class `Bounded` (or at least something very similar)
09:32:44 <tromp_> > 2 % 3
09:32:45 <lambdabot>  2 % 3
09:32:49 <bitemyapp> NobbZ: so, you want dependent types?
09:32:55 <tromp_> the constructor for ratios is hiddne
09:33:16 <bitemyapp> NobbZ: there are ways to kinda sorta fake your way into dependent types, but how you make it type-safe without disallowing the use of Num?
09:33:31 <bitemyapp> NobbZ: you'd have to write your own "checked arithmetic" Num typeclass that disallowed leaving the bounds.
09:33:45 <bitemyapp> NobbZ: but if that's acceptable to you, then yeah, it's possible to make a type-safe 1-100 type.
09:33:53 <geekosaur> Bounded doesn't impose restrictions, it describes existing ones (either hardware-enforced like Int, or something like an enumerated type where you list all the possible constructors)
09:34:07 <geekosaur> you could probably define your own that way but it would be a major pain
09:34:25 <geekosaur> data MyInt = X0 | X1 | X2 | ... list all of them ... | X99
09:34:30 <bitemyapp> I don't think it would be that difficult, just annoying.
09:34:37 <Iceland_jack> geekosaur: Template Haskell! :)
09:34:39 <bitemyapp> geekosaur: I think my "checked arithmetic" is nicer and equally safe.
09:34:51 <geekosaur> nicer in some ways, not in others
09:34:51 <quicksilver> either way you have to write the Num instance
09:34:58 <bitemyapp> Right.
09:35:06 <quicksilver> and writing the Num instance is your chance to be more precise about what you actually mean
09:35:09 <bitemyapp> and that's going to be the real deal-breaker, generally.
09:35:19 <quicksilver> runtime error on overflow? modulo arithmetic on overflow?
09:35:25 <NobbZ> It's not that I need it right now, but since I had PASCAL-lectures in parallel with the haskell ones (and in PASCAL its quite common to define Index types for arrays like this: type: TIndex = 1..100;)
09:35:28 <quicksilver> clamping to boundary on overflow?
09:35:43 <NobbZ> So it is more a question out of curiosity than out of a need
09:35:52 <bitemyapp> NobbZ: the answer is yes, but don't do that.
09:36:11 <Iceland_jack> NobbZ: Indexing is not nearly as important in Haskell as it is in imperative languages
09:36:15 <bitemyapp> quicksilver: probably wants clamp rather than overflow.
09:36:36 <NobbZ> OK, then my question is answered :)
09:36:53 <NobbZ> So I'll join my family for TV evening.
09:37:08 <bitemyapp> NobbZ: if you want a more serious way of doing this, look into Idris. Have a good evening.
09:58:47 <gaze__> Hey folks. I think I've sorta begun to wrap my head around the yoneda lemma. I'd like to understand how Coyoneda from kan-extensions can be useful
10:00:11 <gaze__> If (b->a) f b ~ f a, why ever deal with b->a f b?
10:02:42 * hackagebot packed-dawg 0.2.0.3 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.3 (AndrasKovacs)
10:05:47 <ski> gaze__ : `CoYoneda IORef' ?
10:07:43 * hackagebot penny 0.32.0.2 - Extensible double-entry accounting system  http://hackage.haskell.org/package/penny-0.32.0.2 (OmariNorman)
10:08:54 <monochrom> hmm, does "extensible double-entry" mean extensible to triple-entry, 0-entry, and pi-entry? :)
10:10:27 <gaze__> ski: What does this let you do?
10:16:51 <madjestic> hello.  I would like to be able to evaluate x*x and get x^2 in return.  That is preserving the symbolic shape of the expression, but applying valid mathematical operations otherwise.  I would like to use haskell as a mathematical aid, when dealing with simbolic expressions.  Is that doable with haskell?
10:18:00 <monochrom> no
10:18:31 <monochrom> or yes, but not unlike how much work Mathematica has to go through
10:18:59 <monochrom> no, I word it wrong
10:19:33 <monochrom> not unlike how much work is done to implement Mathematica
10:19:57 <madjestic> can I not define a custom datatype, representing symbols, and somehow define mathematical operations for, say: (+) :: Symbol -> Float -> Something?
10:20:00 <monochrom> "haskell syntax looks like math syntax" does not imply "magically, haskell is a computer algebra system"
10:20:06 <monochrom> yes
10:20:36 <milfjord> > a + b
10:20:37 <lambdabot>  a + b
10:20:41 <madjestic> monochrom: I am not arguing for that.  I just want to know if that's achiavable.  I am not normally use haskell as a theorem prover
10:20:47 <levi> You can certainly write a computer algebra system in Haskell, but it doesn't have the functionality built-in.
10:20:50 <joelteon> > foldl1 (+) [a,b,c,d,e]
10:20:51 <lambdabot>  a + b + c + d + e
10:21:05 <milfjord> proving things in haskell is super easy with fix
10:21:16 <madjestic> milfjord: more data on how to achieve that?
10:21:20 <madjestic> fix is a library?
10:21:27 <levi> fix is a function
10:22:49 <levi> :t fix
10:22:50 <lambdabot> (a -> a) -> a
10:22:58 <levi> @src fix
10:22:58 <lambdabot> fix f = let x = f x in x
10:24:07 <madjestic> thanks, guys, I'll try that
10:25:08 <levi> I'm not sure fix is going to be helpful to you if you want a computer algebra system, though.
10:26:00 <gaze__> match x*y -> if prove(x == y): x**2
10:26:21 <Iceland_jack> > fix (1:)
10:26:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:28:16 <jle`> is there a way to move a Maybe into a tuple?
10:28:23 <Iceland_jack> jle`: What do you mean?
10:28:25 <jle`> Maybe (a, b) -> (Maybe a, b)
10:28:33 <jle`> or Maybe (a, b) -> (a, Maybe b)
10:28:37 <jle`> hm
10:28:40 <joelteon> where would the a come from?
10:28:41 <Iceland_jack> What happens if the input is Nothing?
10:28:42 <jle`> but where would the other one ceom from
10:28:44 <jle`> of it was Nothing
10:28:49 <Iceland_jack> Wouldn't work
10:28:49 <jle`> yes
10:29:02 <jle`> hm
10:29:38 <Iceland_jack> You can move it to
10:29:38 <Iceland_jack>     Maybe (a, b) -> (Maybe a, Maybe b)
10:29:38 <Iceland_jack> but it would be rather uninteresting
10:29:52 <jle`> well i am using a list as a state
10:29:58 <jle`> and listToMaybe
10:30:00 <levi> The examples milfjord and joelteon showed with Lambdabot, e.g. where foldl got unfolded and printed as an expression, are done via SimpleReflect.  here's an explanation of how it works: http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
10:30:04 <jle`> to grab the "head"
10:30:21 <jle`> i guess i want to leave the state unchanged if it is empty
10:30:32 <jle`> and result as Just a if it isn't, Nothing if it is
10:30:51 <jle`> but i guess there is no better way than just doing it the non-clever way
10:31:24 <whatdoicare> hey, i have some loadable library and it works perfectly fine from runhaskell and ghci
10:31:27 <ski> gaze__ : `CoYoneda IORef' is `IOReadRef' (no write possible)
10:31:29 <whatdoicare> but i cant build a working exe
10:31:39 <ski> (or i suppose you could write `undefined' and similar)
10:32:06 <whatdoicare> i basically run runhaskell and ghc w/ the same flags
10:32:23 <Iceland_jack> okay, and where does the tuple come from?
10:33:46 <whatdoicare> tried -static, -shared but always getting the error when run the exe: "error while loading shared libraries: libbla.so.1: cannot open shared object file: No such file or directory"
10:34:17 <awestroke> how do I get profiled versions of all my libraries if I've installed the haskell-platform ubuntu meta-package?
10:35:12 <awestroke> oh nvm I see there's a haskell-platform-prof
10:37:04 <prinsen>  My brain just exploded
10:37:05 <prinsen>     I can't handle pattern bindings for existential or GADT data constructors.
10:37:05 <prinsen>     Instead, use a case-expression, or do-notation, to unpack the constructor.
10:37:20 <milfjord_> yep
10:37:22 <prinsen> I try to unpack the existential type  My brain just exploded
10:37:22 <prinsen>     I can't handle pattern bindings for existential or GADT data constructors.
10:37:35 <prinsen> Sry..
10:37:52 <prinsen> I try to unpack the value by JSONConsumer consumer = apiConsumer api
10:37:54 <Iceland_jack> prinsen: use a case of :)
10:38:00 <prinsen> Well how?? :)
10:38:07 <milfjord_> case EXPR of CASES
10:38:50 <Iceland_jack> If you don't know case expressions you might not have a good time mucking with existentials or GADTs
10:50:29 <dword> lambdabot: @help
10:50:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:52:20 <monochrom> you may be disappointed
10:52:56 <Iceland_jack> dword: Are you having any Haskell issues? :)
11:12:11 <prinsen> Iceland_jack: http://pastebin.com/WBm7s8NA
11:12:26 <prinsen> I don't understand why im getting these errors
11:16:31 <prinsen> Im getting errors like Could not deduce (r1 ~ r) while using existential types and I don't know how to fix them
11:17:28 <Cale> prinsen: Where's your code?
11:18:02 <Cale> prinsen: Note that the whole point of an existential type is to *forget* which type something had (in part)
11:18:23 <prinsen> Cale: Do you accept a github link?
11:18:27 <Cale> sure
11:18:39 <Cale> prinsen: So, if you later try to unify that forgotten type with anything else, you'll have problems.
11:20:24 <prinsen> Cale: https://github.com/fabianbergmark/API/blob/master/Handler/API/Effect.hs
11:20:59 <prinsen> Cale: The errors I get are these http://pastebin.com/WBm7s8NA
11:21:38 * milfjord blindly blames consumer/feeder
11:22:15 <Cale> prinsen: Well, first of all, this type you've given to runEffect looks really really unlikely
11:23:45 <Cale> It says that for any type r that *I* choose, so long as there's an instance of ToJSON r (which, note, gives no way to construct new values of type r), runEffect will take a bunch of stuff not involving r in any way, and hand me an IO action for producing values of type IO (Maybe r)
11:24:26 <milfjord> return Nothing
11:25:00 <Cale> I can conclude just from looking at this type that such an IO action will do one of three things when executed: 1) Not terminate. 2) Produce Nothing as its result. 3) Produce Just _|_ as its result (where _|_ represents any sort of nonterminating value)
11:25:44 <Cale> prinsen: Do you see why that has to be the case?
11:25:49 <prinsen> Cale: But the pipe knows how to produce a value of type r
11:26:00 <Cale> prinsen: Whatever runEffect does, it has no way of knowing which type r is.
11:26:13 <shachaf> (1) conflates two different cases.
11:26:27 <shachaf> Not that it's very relevant, I guess.
11:26:38 <Cale> prinsen: So it has to produce something which will work for *any* type r
11:27:10 <prinsen> Cale: Do you see what Im trying to achieve?
11:27:12 <Cale> and the only sort of expression which belongs to any type whatsoever is a nonterminating one
11:27:18 <Cale> Not quite
11:27:44 <Cale> Perhaps you mean to say that there exists some type r for which it will produce an IO (Maybe r), but that's not what the type says.
11:28:01 <Cale> It says *for all types r*, that the code will work
11:29:18 <shapr> Is there an irc channel for lambdabot discussion?
11:29:59 <shiona_> shapr: do you mean for discussing with or about lambdabot?
11:30:24 <shapr> shiona_: about lambdabot
11:30:37 <shiona_> ok, then no idea
11:30:43 <shapr> I was wondering if lambdabot had some features such as notification of github repo changes
11:30:54 <shapr> shiona_: Have you done any coding for lambdabot?
11:31:22 <shachaf> lambdabot does not have those features
11:31:25 <shiona_> no I haven't. I have a slight interest, but I doubt I have the skillset yet
11:31:25 * shapr tries to cabal install lambdabot
11:31:25 <Cale> prinsen: I think you'll have a much better time if you give up on these existentials and just work with values of type Value
11:31:28 <shachaf> But github has bots for that.
11:31:37 <milfjord> does github have rss for that?
11:31:55 <Cale> prinsen: If all you know about something is that it can be converted to or from JSON, then it might as well be a Value.
11:31:58 <prinsen> Basically, I have my pipes which deals only with Dynamic. To feed the first pipe, i have the producer which is a Pipe InputType (Dynamic) IO (..). Now as I compose this chain of pipes dynamically I have no idea what InputType is. So i figured if I require it to have a FromJSON instance, haskell would, during runtime, figure out which decode to run
11:32:18 <Cale> because that's all you're allowed to do with it anyway
11:32:32 <shachaf> It has atom for that.
11:33:05 <shapr> shachaf: So I only need to write a lambdabot plugin that reads atom and dumps that into a channel?
11:33:07 <prinsen> Cale: Then the producer could be Pipe Value Dynamic IO (Maybe Value) and it would know (during compile-time) which decode to use
11:33:14 <milfjord> can hackagebot read that?
11:33:30 <absence> when would one use attoparsec vs Data.Binary?
11:33:53 <sm> hackagebot (rss2irc) can read rss/atom feeds, yes
11:33:55 <Cale> If you can't work out which parser to run statically, nothing that the type class machinery will do for you will help dynamically, because it all happens at compile time. Which instance is to be applied in any given case is statically determined.
11:34:12 <shapr> sm: Ah, that may be a better choice
11:34:14 <shachaf> shapr: If you really want lambdabot to do it for some reason.
11:34:23 <shapr> shachaf: Well, might be fun
11:34:41 <shapr> I've written some lambdabot code before.
11:34:49 <prinsen> Cale: I guess that's not how it works?
11:36:07 <Cale> prinsen: Well, if *you* don't know which parser is appropriate, the compiler is going to be even less likely to know :)
11:36:36 <Cale> You typically need to determine that from some initial part of the input or some bit of context.
11:37:53 <Cale> prinsen: But in this case, I think maybe just replacing all of these type variables with Value will be okay?
11:39:49 <prinsen> Cale: Yes I will do that and save me some headache
11:40:05 <prinsen> Cale: Thanks!
11:45:31 <bennofs> Is there any known confusing behaviour when using asnyc's in child processes created using unix's forkProcess?
11:46:21 <klrr__> if i got Producer of bytestring using fromConnect (in pipes-network), would it be okey to just await and break the string into two pieces at "\r\n" and simply waiting to yield down to the parser till this process is finished, or is there a stream-ing way of doing it?
11:48:49 <klrr__> using pipes-parse and pipes-attoparsec seems like a better solution but im not really sure how that would work (if need to use a little hack'ish thing to make attoparsec finish properly)
11:49:09 <skypers> hi
11:49:18 <skypers> I need some idea about a problem I have
11:50:43 <skypers> I have a map, Map String Foo, and another, Map String Bar. I‚Äôd like to create another map which type is Map Bar (Map String Foo). i.e. for each same key, group elements in a new map for each Bar
11:50:52 <skypers> I see two options
11:51:09 <skypers> first, pretreat the second map, in order to make it Map Bar String
11:51:32 <skypers> then fold it, lookup with the String value the first map
11:51:45 <skypers> and insert in a new map the read element
11:51:47 <skypers> any better idea?
11:52:56 * hackagebot text-stream-decode 0.1.0.4 - Streaming decoding functions for UTF encodings.  http://hackage.haskell.org/package/text-stream-decode-0.1.0.4 (MichaelSnoyman)
11:53:40 <skypers> I see something like intersectionWith, but it‚Äôs not really what I want
11:53:54 <skypers> because the map will be reversed
11:54:26 <Guest76887> I'm trying to reverse proxy some requests in a Yesod app to some other web service. I've figured out how to do the proxying, but I'm not sure how to make it work with Yesod's monads. At the moment I have Handler Response
11:54:45 <Guest76887> Which doesn't seem right to me
11:56:05 <Guest76887> basically all response headers should be set by the client
11:56:48 <levi> Guest76887: There's actually a package based on Warp that is designed for just reverse proxy use.
11:57:11 <levi> http://hackage.haskell.org/package/http-reverse-proxy
11:57:19 <Guest76887> levi: is this http-reverse-proxy?
11:57:33 <skypers> maybe I can reverse the problem, and use something else for the other map‚Ä¶
11:57:56 * hackagebot conduit 1.0.15.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.15.1 (MichaelSnoyman)
11:58:31 <skypers> @hoogle Map k a -> Map a k
11:58:32 <lambdabot> Data.Map.Lazy mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
11:58:32 <lambdabot> Data.Map.Strict mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
11:58:32 <lambdabot> Data.Map.Lazy mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
11:58:37 <Guest76887> levi: that is what I've found so far. The tricky bit is passing the response from this back to the client
11:59:22 <Guest76887> levi: sounds like the sort of thing there might be a function for. Hence my asking on here
12:00:27 <levi> Well, usually a reverse proxy is a layer above a Yesod app rather than below.
12:01:16 <Eduard_Munteanu> Ha... I can't invent indexed monoids because edwardk already did. :P
12:01:31 <Eduard_Munteanu> Although I had a somewhat different construction in mind.
12:01:35 <Guest76887> levi: I think that is the problem
12:02:15 <levi> Guest76887: The #yesod folks might have more guidance, if anyone's awake there.
12:03:00 <levi> There's also the keter package for a fancier deployment manager with reverse-proxy capability.
12:04:05 <levi> I haven't used it, but it looks pretty slick.
12:04:28 <Guest76887> levi: found sendWaiResponse in Yesod.Core.Handler which is exactly what I want I think
12:04:36 <Guest76887> levi: thanks for the help :-)
12:04:58 <levi> No problem, good luck with the rest of your app. :)
12:05:18 <Eduard_Munteanu> edwardk (or somebody else): does this look sane to you... class IMonoid (m :: k -> *) (plus :: k -> k -> k) (zero :: k) where (><) :: m i -> m j -> m (plus i j); imempty :: m zero    ?
12:07:12 <Eduard_Munteanu> An example would be Vec (length-indexed lists).
12:12:22 <bennofs1> http://lpaste.net/100422 -- Anyone any ideas?
12:12:55 <Eduard_Munteanu> bennofs1: did you compile with -threaded?
12:12:56 <milfjord> "canclel"
12:13:12 <bennofs1> milfjord: yeah, typo. lpaste doesn't seem to accept title edits
12:13:39 <bennofs1> Eduard_Munteanu: doesn't make a difference
12:15:29 <levi> Did you run it with the correct RTS options to use multiple threads?
12:15:51 <bennofs1> levi: what are those?
12:16:07 <levi> I.e. +RTS -<N> where <N> is the number of 'capabilities' you want the runtime to use.
12:16:20 <bennofs> Btw, both threads do run. I get output from both
12:16:25 <bennofs> it's just that cancel blocks
12:16:43 <Eduard_Munteanu> bennofs: what OS?
12:16:46 <bennofs> Eduard_Munteanu: linux
12:16:56 <madjestic> joelteon: previously you demonstrated the example of foldl (+) [a,b,c,d] with the output: a + b + c + d.  It was mentioned that it could be achieved with fix function.  I would like to achieve that in ghci (or as a program output), is that possible?
12:17:04 <levi> There are some limitations to context switching points within a thread, though I can't recall exactly what they are.
12:17:24 <milfjord> madjestic: that example has nothing to do with fix
12:17:35 <bennofs> levi: cancel gets executed. GC runs the whole time. This is not a problem with missing context switches I think
12:17:53 <bennofs> levi: also, if I leave out the forkProcess, everything works fine
12:17:59 <madjestic> milfjord: I must have confused the message then
12:18:12 <bennofs> @index a
12:18:13 <lambdabot> Data.Graph.Inductive.Example
12:18:22 <bennofs> :t a
12:18:23 <lambdabot> Expr
12:19:18 <Eduard_Munteanu> > let s = fix $ \f xss -> case xss of [] -> 0; (x:xs) -> x + f xs in s [a,b,c,d]
12:19:19 <lambdabot>  a + (b + (c + (d + 0)))
12:19:28 <milfjord> foldr
12:19:42 <Eduard_Munteanu> Oh, well...
12:20:11 <Eduard_Munteanu> > let s = fix $ \f n xss -> case xss of [] -> 0; (x:xs) -> f (x + n) xs in s [a,b,c,d]
12:20:12 <lambdabot>  Could not deduce (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
12:20:12 <lambdabot>    arising from a use of `s'
12:20:12 <lambdabot>  from the context (GHC.Num.Num a)
12:20:12 <lambdabot>    bound by the inferred type of
12:20:12 <lambdabot>             it :: GHC.Num.Num a => [[Debug.SimpleReflect.Expr.Expr]] -> a
12:21:00 <Eduard_Munteanu> > let s = fix $ \f n xss -> case xss of [] -> n; (x:xs) -> f (x + n) xs in s [a,b,c,d]
12:21:01 <lambdabot>  No instance for (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
12:21:01 <lambdabot>    arising from a use of `s'
12:21:01 <lambdabot>  Possible fix:
12:21:01 <lambdabot>    add an instance declaration for
12:21:01 <lambdabot>    (GHC.Num.Num [Debug.SimpleReflect.Expr.Expr])
12:21:37 <Eduard_Munteanu> > let s = fix $ \f n xss -> case xss of [] -> n; (x:xs) -> f (x + n) xs in s 0 [a,b,c,d]
12:21:38 <lambdabot>  d + (c + (b + (a + 0)))
12:21:58 <Eduard_Munteanu> > let s = fix $ \f n xss -> case xss of [] -> n; (x:xs) -> f (n + x) xs in s 0 [a,b,c,d]
12:21:59 <lambdabot>  0 + a + b + c + d
12:22:41 <Eduard_Munteanu> Ok, next hole.
12:33:23 <Richie> Hi guys ! i'm newbie in haskell, i try to do a function when 3 int ( day, month, year) tells me if future or past ( bool ) but i have problems with IO monad http://lpaste.net/100424
12:34:06 <Rembane> Richie: Where's the IO part?
12:34:08 <milfjord> IO Bool, not Bool
12:34:11 <geekosaur> toGregorian is pure
12:34:15 <geekosaur> use let instead of <-
12:34:19 <geekosaur> <- is for stuff in IO
12:34:19 <skypers> ok, I finally found a way with may two maps: https://github.com/skypers/skyoralis/blob/unstable/Graphics/Rendering/Sky/Core/Geometry.hs#L185
12:34:23 <skypers> it‚Äôs quite ugly though
12:34:26 <geekosaur> do you see an IO in the type of toGregorian?
12:34:47 <Clint> Richie: if you don't want it to be IO Bool you need to do getCurrentTime outside of the function
12:34:51 <skypers> (the initial problem was to merge two maps into another: Map String A -> Map String B -> Map B (Map String a)
12:34:54 <skypers> )
12:35:17 <shiona> has anyone here gotten any actual education on haskell?
12:35:24 <skypers> no shiona
12:35:43 <Eduard_Munteanu> I know people in here who studied Haskell in an educational setting.
12:35:50 <Richie> geekosaur ohh got it, i'll try
12:36:02 <shiona> I mean I've taken now two courses from different universities and there seems to be some talk about bringing it to ours
12:36:25 <ski> shiona : yes, a "Functional Programming" and an "Advanced Functional Programming" course
12:36:45 <Richie> Clint: so i have to do two functions ?
12:37:08 <shiona> and I would like to assist in bringing it in. This would likely be in the form of being a course assistant, but I'm also interested in trying to create some tools
12:37:36 <Clint> Richie: depends what you want
12:37:51 <shiona> but if there is some open material (or tools!) on other courses, I would love to see them.
12:38:57 <Richie> Clint: i like something with signature diffNow :: Integer -> Int -> Int -> Bool , not IO Bool,
12:39:30 <milfjord> <Clint> Richie: if you don't want it to be IO Bool you need to do getCurrentTime outside of the function
12:39:56 <shiona> The first course I took was quite theoretical. I took it completely online and quite a bit of it was just manually finding out types or trying to do 'hard' things with a single fold.
12:40:19 <Richie> milfjord Clint why ?
12:40:39 <milfjord> Richie: because getCurrentTime is in IO
12:40:42 <milfjord> has to be, really
12:42:05 <shiona> Another has been the lecturer reading the LYAH out loud fox six weeks and extremely badly given exercises whose difficulty ramp would seem enormous for someone who has no previous experience with the language
12:42:05 <Eduard_Munteanu> LOL
12:42:08 <milfjord> getCurrentTime :: IO UTCTime
12:42:08 <Richie> and the other functions onlys call to getCurrentTime and "unpack" to return a  UTCTime instead IO UTCTime ?
12:42:08 <milfjord> if the IO wasn't there, it would be a constant
12:42:08 <Eduard_Munteanu> I get a 1700s feeling looking at academic teaching.
12:45:08 <shiona> I would like to see how others have done this, so if I happen to get a say about our course design I can make the best possible decision
12:45:08 <bennofs> So I have posted my previous question on stackoverflow: http://stackoverflow.com/questions/22052575/interaction-of-forkio-killthread-with-forkprocess
12:45:08 <Eduard_Munteanu> "I am the teacher, I pass information to thee orally because poor students can't afford books."
12:45:08 <milfjord> oh, you're using fork in haskell?
12:45:08 <milfjord> I'm surprised the code works at all
12:45:08 <bennofs> why surprised?
12:45:08 <shiona> Eduard_Munteanu: more like "the book is freely available online, I'm just reading from the book since I have to lecture the course and I know nothing of the subject"
12:45:09 <Cale> Eduard_Munteanu: not even books which are freely available online, apparently ;)
12:45:09 <milfjord> I remember hearing about issues, like the I/O manager thread not being copied across the fork
12:45:09 <Richie> Clint : and the other function only calls to getCurrentTime and "unpack" to return a  UTCTime instead IO UTCTime ?
12:45:09 <Eduard_Munteanu> It is a bit sad because it practically works the same today... or they use the same excuses.
12:45:15 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
12:45:15 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:31:09 2014]
12:46:30 <shiona> I have no idea. Most of my lecturers have been good and known their subject
12:46:41 <Cale> shiona: Well, I'd say don't teach a programming language as a course, unless your plan is to have a really technical course intended for people who want to e.g. implement that language specifically. Instead, teach something which is more general, and perhaps introduce Haskell through that.
12:46:43 <Clint> Richie: you would need to change your diffNow type to also take UTCTime or whatever else you want to pass the current time as
12:47:11 <Eduard_Munteanu> Clearly a future good researcher must absorb every word his teacher utters. Because hey, he's being *taught*.
12:47:18 <shiona> most courses do not require any book, most just have some booklet the course management has done and is free to print
12:47:30 <Clint> Richie: but i imagine it's saner for you to have IO Bool than to do all that
12:47:39 <shiona> even those courses that "require" a book I've managed to finish without buying one
12:47:43 <bennofs> milfjord: Ok, but I read that that is only if I use the threaded runtime?
12:48:09 <shiona> Cale: that is a good point
12:49:51 <Richie> Clint : so, if i change the type to IO Bool works ? i'm updated http://lpaste.net/100424
12:50:14 <haasn> Cale: that sounds like what my university does; we have a course on programming paradigms including FP and logical programming and example languages are haskell and prolog
12:50:17 <Clint> Richie: you might want to explain what you're actually trying to do
12:50:18 <Cale> shiona: For an example of the really dry course on Haskell, there's a lecture series online somewhere (in English) from some German university iirc, let me see if I can dig it up
12:50:32 <haasn> with another module that goes more indepth on functional languages, again with Haskell as the example
12:50:38 <Eduard_Munteanu> shiona: what sort of students do you expect to have? Do they have prior programming experience usually, are they studying computers and programming or more theoretical stuff?
12:51:04 <shiona> Cale: the first course I took was http://functional-programming.it.jyu.fi/TIES343/Credits.html (you can click on the table headers to get to the exercises)
12:51:26 <Richie> Clint: only  a function when 3 int ( day, month, year) tells me if future or past ( bool ) to learning
12:52:07 <shiona> Eduard_Munteanu: they would most likely have or be about to have their bachelors in CS and have medium to strong background in C++
12:52:24 <Cale> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
12:52:27 <Clint> Richie: then yes except you need to return an IO Bool on the last line and doing toGregorian and fromGregorian on now is silly
12:53:03 <milfjord> "videoaufzeichnung" :-|
12:53:04 <shiona> Cale: thanks, I'll take a look
12:53:50 <shiona> was zeichnung something like newspaper?
12:54:05 <shiona> damn my German is rusty
12:54:06 <milfjord> aufzeichnung = recording
12:54:10 <milfjord> zeichnung = drawing
12:54:14 <shiona> ah
12:54:18 <milfjord> zeitung = newspaper
12:54:26 <Eduard_Munteanu> @google translate aufzeichnung
12:54:28 <lambdabot> http://translation.babylon.com/german/to-english/aufzeichnung/
12:54:28 <lambdabot> Title: Aufzeichnung - German to English Translation
12:54:38 <Eduard_Munteanu> Meh, I expected more of an inline answer.
12:54:49 <shiona> that would make sense yes
12:55:08 <shiona> but thanks milfjord, that explains why I made the mistake
12:55:38 <LadyAurora> bad lambdabot
12:56:06 <Richie> Clint: how can return an IO Bool on the last line ? i chnge the type to IO Bool, but i got  Couldn't match expected type `IO Bool' with actual type `Bool'
12:56:20 * Eduard_Munteanu wonders why lambdabot doesn't provide its commands as Haskell actions...
12:56:32 <Eduard_Munteanu> Weird, it's the first time I thought about it.
12:57:10 <Cale> Richie: Perhaps you're missing a 'return'?
12:57:35 <Cale> Richie: Or maybe you wanted the thing to define a Bool after all, and you're not actually doing IO?
12:57:56 <Cale> Richie: (I didn't see your code)
12:58:16 <Richie> Cale: http://lpaste.net/100424
12:58:29 <Twey> diffNow y m d = (> 0) . diffDays (fromGregorian y m d) <$> getCurrentTime
12:58:34 <Cale> Richie: ah, you want  return (diffDays b a > 0)
12:59:07 <Cale> You're comparing the IO action with 0
12:59:36 <Cale> (i.e. the no-op IO action which always returns diffDays b a as its result)
13:00:11 <Cale> Richie: It's good to remember that function application always binds more tightly than any infix operator
13:01:01 <edwardk> Eduard_Munteanu: Dominic Orchard uses something like that for his flavor of indexed (co)monads
13:01:05 <Cale> (and that return is a function and not a keyword)
13:01:52 <Richie> Cale, hmm that's true
13:02:04 <LadyAurora> return is pure
13:02:24 <Eduard_Munteanu> edwardk: oh, hm, so it generalizes to monads... I guess you get an indexed (Co)MonadPlus?
13:02:35 <LadyAurora> Seriously, pure would be a much better name.
13:02:52 <Cale> return isn't a bad name
13:02:54 <Eduard_Munteanu> I'll look it up, thanks for the tip.
13:03:03 <Cale> After all, return x is the IO action which does nothing except to return x
13:03:24 <Eduard_Munteanu> pure is nicer, though.
13:03:33 <Cale> I think I prefer return
13:03:36 <ownclo_> 'return' makes newcomers able to read IO code
13:03:55 <Eduard_Munteanu> ownclo_: also causes some confusion, OTOH
13:04:03 <LadyAurora> Yeah, but people coming from imperative langs are sometimes confused by return.
13:04:07 <Cale> There's bound to be confusion regardless
13:04:16 <ownclo_> Eduard_Munteanu: yes, I agree; that is a source of confusion.
13:04:35 <Cale> If you want to be abstract, we could call it eta
13:04:55 <Cale> ;)
13:05:00 <Richie> Twey: ohh thanks, great,  Expected type: IO Day  Actual type: IO UTCTime, how i can works with getCurrentTime ?
13:05:28 <ownclo_> Cale: that's for math guys to be able to read IO code ;)
13:05:46 <Eduard_Munteanu> Yikes, I suspect you can index the monad independently of Plus monoidal structure, which could also be indexed.
13:06:01 <LadyAurora> Cale: that name's so uninformative for most people, it may be a good idea actually.
13:06:12 <Cale> Or actually just use the Greek letter Œ∑
13:06:20 <Cale> just to be a little more unhelpful
13:06:46 <LadyAurora> Use a snowman.
13:06:55 <milfjord> cohelpful
13:07:11 <LadyAurora> No, wait, Haskell is not Perl.
13:07:24 <milfjord> by that measure Perl isn't Perl either
13:07:24 <haasn> > generalCategory '‚òÉ'
13:07:25 <lambdabot>  OtherSymbol
13:07:55 <levi> bennofs: Figured it out; you've changed the code a bit on StackOverflow, but hopefully the fix I wrote there works as well.
13:08:15 <LadyAurora> milfjord: they're working on it
13:09:21 <milfjord> FUD
13:09:25 <milfjord> levi++
13:09:45 <bennofs> levi: doesn't seem to work for the changed version at least
13:10:21 <bennofs> levi: also, why would it change anything? putStrLn $ "..." ++ show x already forces x
13:10:41 <milfjord> no, putStrLn isn't strict
13:10:58 <bennofs> what?
13:11:16 <milfjord> oops, probably unrelated
13:12:03 <Cale> hmm...
13:12:07 <bennofs> putStrLn is *not* strict? How could that be? How can I write something to stdout without forcing it?
13:12:13 <Cale> > putStrLn undefined `seq` ()
13:12:14 <lambdabot>  ()
13:12:25 <bennofs> > putStrLn undefined
13:12:26 <milfjord> bennofs: putStrLn doesn't write to stdout
13:12:26 <lambdabot>  <IO ()>
13:12:30 <Cale> Executing putStrLn forces the string argument
13:12:35 <Eduard_Munteanu> It is strict as in strict IO.
13:12:37 <Cale> But evaluating it doesn't
13:13:07 <bennofs> Ok, that's right. But I'm in the IO monad there, so it should be evaluated
13:13:10 <Twey> Richie: (> 0) . diffDays (fromGregorian y m d) . utctDay <$> getCurrentTime -- you need to get the ‚ÄòDay‚Äô component from the UTCTime before you can compare it with another Day
13:13:17 <Cale> bennofs: Well, it'll be both :)
13:13:19 <Eduard_Munteanu> Although blocking strict IO can be confusing. :)
13:13:21 <LadyAurora> > (+ 2) undefined
13:13:22 <levi> bennofs: Well, port it back to the Async version and it will work there. :) I'll try to fix the one you posted.
13:13:22 <lambdabot>  *Exception: Prelude.undefined
13:13:23 <bennofs> executed*
13:13:25 <Cale> bennofs: (and the execution is what matters)
13:13:29 <LadyAurora> Damn.
13:13:39 <LadyAurora> > (+) undefined
13:13:40 <lambdabot>  <Integer -> Integer>
13:13:54 <Cale> > (+) undefined `seq` ()
13:13:55 <lambdabot>  ()
13:14:13 <Cale> ^^ it's best to use seq to check, because I'm not sure how strict the Show instance for functions is
13:14:29 <Cale> > undefined :: Integer -> Integer
13:14:30 <lambdabot>  <Integer -> Integer>
13:14:41 <Cale> > (undefined :: Integer -> Integer) `seq` ()
13:14:42 <lambdabot>  *Exception: Prelude.undefined
13:14:49 <bennofs> levi: That it doesn't work in the forkIO version is probably a good sign that i shouldn't be doing this anyway :p
13:15:35 <bennofs> levi: btw, I tried it on my machine, and it doesn't work in the async version either :|
13:24:21 <levi> Hah. Well, it *was* working for me.
13:26:29 <jle`> bennofs: the evaluation of putStrLn is not necessarily strict, but the execution of it forces its argument
13:26:49 <bennofs> jle`: I see.
13:26:59 <jle`> i can evaluate as big an IO computation as i want
13:27:20 <c_wraith> > putStrLn undefined `seq` ()
13:27:21 <lambdabot>  ()
13:27:30 <c_wraith> no crash!
13:27:33 <jle`> i can define *and* evaluate an IO computation taht does not terminate
13:27:53 <bennofs> > fix (\r -> r >> r) :: IO ()
13:27:54 <lambdabot>  <IO ()>
13:28:15 <jle`> an IO object can be thought of as just a graph of some sort
13:28:35 <jle`> we have no problems evaluating and representing cyclic graphs
13:29:11 <jle`> (in memory)
13:29:43 <jle`> trying to "DFS" a cyclic graph causes problems.
13:30:03 <jle`> but i am playing a bit too loose with analogies here
13:38:08 <jle`> what are the reasons to use an existential hetereogenous list over one with manually making an ADT?
13:38:33 <jle`> or i guess...what are legitimate reasons for it
13:38:52 <jle`> i want to avoid all that expression problem headache with having to change all my case swithces every time i add something
13:38:52 <benmachine> jle`: few and far between :P
13:39:10 <jle`> but that is mostly a reason of laziness
13:39:21 <jle`> but if i wanted to i could justify it as maintanability
13:39:22 <c_wraith> I don't think I've ever run into a case where the existential pattern was really what I wanted.
13:39:27 <benmachine> I actually can't off the top of my head think of a problem to which I would go "I know! I'll use existentials!"
13:39:48 <benmachine> apart from possibly typed ASTs, I guess they count, but they're not what you're talking about
13:39:58 <c_wraith> At least for a heterogenous list.
13:40:19 <jle`> in my simulation i would like a list of all things that can be collided with
13:40:27 <c_wraith> I did just (apparently infamously) use Coyoneda, which uses an existential so as to turn a value into a Functor when it wouldn't otherwise be.
13:40:32 <jle`> my firt shtought would be just to use an ADT
13:40:39 <jle`> but
13:40:50 <jle`> every time i add a new type that I want to be collidable
13:41:07 <jle`> i'd have to go and change every case statement that uses it?
13:41:07 <jle`> i mean it's not that bad
13:41:28 <jle`> because GHC tells me exactly where they are
13:41:28 <jle`> but still :|
13:41:29 <jle`> i could never even have them if i used existentials
13:41:40 <benmachine> jle`: well, isn't it the case that you'd have to write that code anyway?
13:41:50 <benmachine> you've got N new pairs of things that might collide
13:41:55 <benmachine> you have to do /something/
13:42:14 <jle`> if i knew i only needed to ask for the position
13:42:25 <jle`> i could have it be a typeclass that yields the position
13:42:35 <jle`> hm
13:42:38 <jle`> i guess i could just write a function
13:42:41 <jle`> that pulls a position
13:42:47 <jle`> out of the sum type
13:43:19 <jle`> so instead of writing an Instance for every type, i'd write a new switch case in one function
13:43:25 <jle`> i guess that's not so bad.
13:43:38 <jle`> but also manually defining every one feels kinda clumsy
13:43:56 <jle`> as in manually defining the ADT constructors
13:44:09 <jle`> if i had an ADT that had no purpose other than to be twelve dumb constructors
13:49:37 * monochrom is a static type. read this like "he's a science type", "he's a management type". so, it means: he prefers all sorts of static verification, ranging from static type checking to full correctness proving
13:52:04 <monochrom> logically, "he is a static type" is equivalently to "he is a find-errors-early type". corollary: "dynamic" is equivalent to "deliberately find errors later", which is deliberately fraudulent and scamful
13:52:52 <simpson> Was there a context to that, or is it just polemic?
13:53:00 <monochrom> no context
13:53:12 <monochrom> now I have to look up "polemic"
13:53:50 <monochrom> heh, "aggressive", that is a right assessment :)
13:54:41 <monochrom> on this topic and a few others, I am beyond polemic. I am acidic.
13:56:18 <BMeph__> monochrom: You say that as if forcing the user of your program to deal with your programming errors, were a bad thing.... ;√æ
13:57:12 <monochrom> well, you can say, it should depend on how much the user has paid. I would agree.
13:57:34 <simpson> Yes, I am aware. It's part of what makes this channel unenjoyable.
13:57:36 <monochrom> if I pay you to use my program, you should deal with my errors, yes
13:59:09 <BMeph__> simpson: Do you think it's possible, that it is merely just part of why you don't enjoy this channel, or even one of the things about the channel that you don't like?
13:59:38 <BMeph__> simpson: Not necessarily something that "makes this channel unenjoyable"? :)
14:00:34 <simpson> BMeph__: I think that static typing does not relieve anybody of the duty of finding errors. This is one of several Unpopular Opinions that I hold. That's all.
14:01:15 <Iceland_jack> simpson: Is that an unpopular opinion?
14:01:26 <monochrom> if you think you are in disagreement with what I stated, you should read again.
14:01:29 <simpson> Iceland_jack: In here, yes.
14:02:14 <monochrom> on people who do not carefully read what I write, I am beyond acidic.
14:02:19 <Saizan> simpson: we do have testing frameworks
14:02:23 <simpson> Saizan: I know.
14:02:25 <Earnestly> Don't worry, I can read \o/
14:02:25 <Iceland_jack> simpson: Some people take things said tongue in cheek seriously (‚Äúif it compiles, it works‚Äù) but in general not at all
14:03:02 <BMeph__> simpson: If anything, I read monochrom's comment as more like: "Some people assert that dynamic typing relieves programmers of the duty of finding errors." If I am wrong, monochrom, please tell me - and simpson.
14:03:02 <monochrom> I, too, have reasons to say "this channel is unenjoyable to me". and that is, people who misread and go on to put words into my mouth.
14:03:21 <simpson> monochrom: You're right, and I'll get out of your way.
14:03:44 <Earnestly> monochrom: Don't worry, I can read. :p
14:04:12 <BMeph__> monochrom: I can read...so I think you should woory more. ;)
14:04:36 * BMeph__ doesn't think he's a good speller, when he types, though.
14:04:53 <Earnestly> Or grammar? hehe
14:13:24 <ownclo_> what does 'import Foo as F' (with no 'qualified' keyword) do?
14:13:39 <haasn> ownclo_: lets you write F.foo instead of Foo.foo if you do want to qualify something
14:13:42 <haasn> eg. if you have ambiguities
14:13:52 <monochrom> I sometimes do
14:14:05 <haasn> note: you can always qualified something using the full module name even if you just use the plain ‚Äúimport Foo.Bar‚Äù syntax
14:14:09 <haasn> qualify*
14:14:19 <kadoban> my haskell install doesn't seem to know anything about Data.Map.Strict ...i guess the only solution would be to upgrade everything or something?
14:14:36 <monochrom> I understand that it is pretty low utility, but it is not absolute zero, so I still use it sparingly
14:14:43 <haasn> And you can even fully qualify names when importing using ‚Äúas‚Äù
14:14:48 <ownclo_> haasn: but is it the case where 'qualified' keyword is needed?
14:15:12 <haasn> ownclo_: I'm not sure what you're asking; qualified means that you *have* to qualify - ie. names are not imported into the ‚Äúdefault‚Äù namespace
14:15:35 <haasn> you can use ‚Äúqualified‚Äù with or without ‚Äúas <alias>‚Äù, they are tangential
14:15:53 <haasn> orthogonal, I should say
14:16:48 <ownclo_> haasn: if I omit 'qualified' and simply write 'import Foo as F' that still works, but I fail to spot the pattern. Seems like I can mix qualified and non-qualified names
14:18:32 <monochrom> ok. "import System.IO as X", this means you have both names "X.stdin" and "stdin"
14:18:53 <monochrom> "import qualified System.IO as X", this means you have "X.stdin" but no "stdin".
14:19:11 <joelteon> I feel like it would be more helpful to have an "unqualified" keyword instead of a "qualified" one
14:19:18 <joelteon> and "as" means it's qualified by default
14:19:30 <joelteon> at what point would I want to do an unqualified but aliased import?
14:19:38 <ownclo_> monochrom: aha. thank you. So it's like _introducing_ additional ambiguity
14:19:41 <monochrom> my http://www.vex.net/~trebla/haskell/module.xhtml has more stories
14:20:08 <jfischoff> what is the recommend way to use bindings to fftw and vector?
14:20:18 <haasn> joelteon: it can happen when you want to import two mostly distinct but slightly overlapping modules but you still want to distinguish between two versions of a colliding name
14:20:26 <jfischoff> should I use 'fft' and use a storable vector?
14:20:29 <levi> ownclo_: Note that having conflicting names *in scope* doesn't cause any problem, but *usage* of an ambiguous name does cause a problem. So if you use 'as', then you can use the unqualified version in non-conflicting cases and only qualify them when there's a conflict.
14:20:29 <joelteon> that's not the common case though
14:20:33 <haasn> indeed it isn't
14:20:54 <haasn> on the subject of import syntax, I really want a shorter way to say ‚Äúimport Data.ByteString (ByteString); import qualified Data.ByteString as BS‚Äù
14:21:03 <joelteon> yep
14:21:09 <joelteon> the import syntax is pretty awful
14:21:17 <haasn> that could be ‚Äúimport Data.ByteString as BS unqualified (ByteString)‚Äù or something maybe :P
14:21:33 <ownclo_> levi: got it. thank you
14:22:06 <levi> ownclo_: As these guys are saying, that's not done very often, but that's the effect you get with 'as' without 'qualified'.
14:22:13 <haasn> maybe it would be nice to have ‚Äúimport‚Äù be a block; eg. import Data.ByteString { qualified as BS; (ByteString) }
14:22:20 <haasn> (so you could just write them in two lines + indentation as well)
14:22:47 <jfischoff> haasn: interesting
14:22:49 <monochrom> I would like that feature too
14:23:49 <levi> Maybe when they get Backpack figured out, other little changes can be made to the syntax. But it seems unlikely to happen on its own for such a small thing.
14:25:15 <levi> Especially since you'd have to muck around with all the parsing tools.
14:25:30 <kadoban> is there some way to trick cabal into upgrading all of my packages, or do i really just have to re-install a new version? trying to get Data.Map.Strict to exist on my machine
14:25:41 <IceDanelol> Why does ghci sometimes stall like it's in an infinite loop when I'm using the debugging functionality to step through evaluation, saying it's "stopped" somewhere?
14:25:52 <IceDanelol> When I ^C it actually displays the output like it does normally
14:26:05 <IceDanelol> oh, maybe it was just slow. It seemed to go through
14:26:08 <IceDanelol> never mind me
14:26:18 <levi> ghci can be pretty slow.
14:26:55 <identity> Aye, I just quite didn't expect the debugger to incur such an overhead
14:27:06 <identity> (it's "instantaneous" without breakpoints/stepping)
14:33:14 * hackagebot linux-file-extents 0.2.0.0 - Retrieve file fragmentation information under Linux  http://hackage.haskell.org/package/linux-file-extents-0.2.0.0 (MariosTitas)
14:33:30 <identity> I'm loading a Data.Set.Set from disk, and debugging in ghci seems to be reevaluating it again and again. Could this be happening?
14:34:33 <Iceland_jack> identity: ‚Äúdebugging in ghci‚Äù is fairly vague, what are you doing exactly?
14:34:57 <dsrx> is this the right way to write a lambda in Cohaskell? (\x <- x + 1)
14:35:02 <identity> Running main in ghci without breakpoints consumes very little ram and finishes practically instantaneously. Using breakpoints and stepping through sometimes consumes all my ram and starts using swap.
14:35:14 <identity> Iceland_jack: Using :break and :step in ghci, that is.
14:35:16 <dsrx> and is this the right way to use 'do' notation? do { x -> Just 45; return x - 3 }
14:35:19 <identity> Debuggin as in using ghci's debugger
14:35:35 <Iceland_jack> ah, I wouldn't know
14:36:03 <Iceland_jack> dsrx: Cohaskell? Is that a dual of Haskell where you reverse every arrow?
14:36:21 <dsrx> Iceland_jack: yeah :P
14:36:37 <Iceland_jack> dsrx: Well it's not a real thing so I don't know what you mean by ‚Äúright way‚Äù
14:36:45 <dsrx> and ffeescript is that compile to JS language where the lambdas look like (x) <- x + 1
14:37:03 <bitemyapp> dsrx: that makes my eyes hurt.
14:37:17 <Iceland_jack> dsrx: When you reverse the arrows in dual categories, it is completely different from the ‚Äúarrows‚Äù in lambdas
14:37:26 <dsrx> Iceland_jack: i know.... it was a bad joke :(
14:37:49 <Iceland_jack> The topic doesn't say anything about bad jokes so I'll let it slide :)
14:38:03 <ownclo_> ffeescript is nice
14:39:25 <identity> dsrx: But as for an answer: you had a syntax error.
14:39:36 <identity> or not really syntax error. Semantic?
14:39:39 <identity> return $ x - 3
14:39:44 <identity> return (x - 3)
14:39:57 <dsrx> identity: oh whoops, yeah
14:39:58 <identity> > let x = 3 in return x - 3 :: Maybe Int
14:39:59 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
14:40:00 <lambdabot>    arising from a use of `GHC.Num.-'
14:40:00 <lambdabot>  Possible fix:
14:40:00 <lambdabot>    add an instance declaration for
14:40:00 <lambdabot>    (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
14:40:20 <identity> i don't get the joke though
14:40:23 <identity> *whoosh*
14:40:43 <identity> if it has the prefix 'co' and is somewhat related to mathematics I don't get it.
14:40:47 <stolaruk_> When there is a "stack overflow" due to the creation of two many thunks, specifically what "stack" overflows? Is it actually the heap?
14:41:27 <Iceland_jack> identity: It didn't really make a whole lot of sense :) adding co- basically means reversing the arrows, but the only arrows that were reversed were syntactic arrows that had nothing to do with the categorical ones
14:41:49 <identity> stolaruk_: I *think* so. There is only one rts setting for configuring the 'size of the runtime memory' and that seems to be the heap
14:42:12 <identity> Which I think is 8 megabytes by default, though that is being increased if I'm not mistaken, in 7.8 or something
14:42:39 <identity> (I could be completely mistaken)
14:42:51 <stolaruk_> It might be the heap
14:43:44 <identity> Iceland_jack: I see.
14:43:46 <identity> I think.
14:44:46 <ownclo_> from STG point of view, there are several stacks: argument stack, return stack and update stack. I guess that thunk overflow is about update stack
14:45:49 <ownclo_> but in a real implementation there are two stacks: one for values and one for pointers. From that point of view, the pointer stack overflows.
14:46:02 <stolaruk_> not the heap?
14:46:34 <stolaruk_> I'm doing a presentation on Haskell and I just want to make sure that I get this point right
14:49:01 <ownclo_> I guess that it depends. If I've got the paper right (STG: implementing non-strict lazy functional languages on a stock hardware), these two stacks are allocated separately from the heap. Both heap and stack can run out of memory.
14:50:35 <ownclo_> let me check that, I am likely to misunderstand something.
14:50:59 <stolaruk_> Yeah I will take a look at RWH, I think they say the heap overflows.
14:51:03 <monochrom> stolaruk_: (A) if you're doing an introductory presentation, you should not be talking about this at all. (B) if you want to talk about this, my http://www.vex.net/~trebla/haskell/lazy.xhtml is more useful
14:52:08 <ownclo_> monochrom: thunks are allocated on the heap; but is it possible that stack runs out of space earlier?
14:53:16 * hackagebot bustle 0.4.5 - Draw pretty sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.5 (WillThompson)
14:53:46 <monochrom> you can arbitrary fill the heap earlier, or fill the stack earlier, by adjusting their sizes
14:54:57 <stolaruk_> monochrom: ok thanks
14:56:25 <monochrom> in fact, most people set the heap to unlimited, and artificially set the stack to "at most 8MB". therefore, they fill up the stack artificially earlier.
14:56:33 <ownclo_> monochrom: does the runtime throws different messages in these cases? Which case is more probable?
14:56:35 <AncientPC> I'm trying to debug a non-exhaustive patterns in a function. Is there a way to print out what the function was called with?
14:56:48 <ownclo_> monochrom: you've already answered, thanks :)
14:57:38 <monochrom> (remark: GHC's stack is growable. there is no technical requirement of a fixed stack, unlike most C implementations.)
14:58:06 <artyomkazak> AncientPC: add a catch-all pattern to your function and use ‚Äúerror‚Äù to print it
14:58:14 <AncientPC> artyomkazak: thx
14:58:23 <ownclo_> monochrom: why do we have to set the stack size explicitly then?
14:58:53 <monochrom> oh, GHC's default is still 8MB stack. people do not set it explicitly.
14:59:02 <ownclo_> I thought that it's because the stack lives in a static memory
14:59:26 <ownclo_> yeah but anyway, it is fixed
14:59:26 <monochrom> it defaults to a limit because many years ago, GHC's stack was not growable, it needed a default
14:59:30 <bitemyapp> ownclo_: stacks in Haskell are dynamically sized.
14:59:43 <bitemyapp> ownclo_: http://www.reddit.com/r/haskell/comments/1wm9n4/question_about_stacks_in_haskell_and_rust/
15:00:05 <monochrom> but after it became growable, people cited a cheesy reason to rationalize keeping the default finite limit
15:00:51 <monochrom> "we still cap it at 8MB by default to guard against loopy programs that eat stack"
15:01:06 <bitemyapp> monochrom: eyeroll
15:01:09 <identity> it's fixed in 7.8, no?
15:01:27 <monochrom> great, and we put no cap on the heap to unleash loopy programs that eat heap
15:01:59 <monochrom> I haven't checked. but SPJ was persuaded to waive the stack limit after my acidic comment :)
15:02:18 <identity> So it grows unchecked now?
15:02:26 <monochrom> I hope so!
15:02:40 <identity> So do I
15:02:41 <ownclo_> aha. thanks
15:08:40 <haasn> @ask roconnor Any plans on adding color spaces / transfer functions other than sRGB to ‚Äòcolour‚Äô? I'd particularly be interested in a BT.709 space and an Adobe RGB 1998 space. Any plans on adding Y'CbCr support, according to either BT.709 or BT.601?
15:08:40 <lambdabot> Consider it noted.
15:11:52 <prinsen> I have a problem with Hint. I have a library that exposes a TH function generateTypes. I use this library in both my main project and in a separate library just created to declare the types for use with Hint (basically an empty file with $(generateTypes) at the top). Now, the TH library generates FromJSON instances for the types, and im able to encode/decode these types in the main app. But when i run code in Hint (with the export-library as
15:13:35 <geekosaur> you got chipped off at "the export-library as"
15:13:54 <geekosaur> irc has a fairly short line length limit, many of us have clients that autosplit what we send
15:14:43 <prinsen>  as an include) I get No
15:14:43 <prinsen>                  instance for (Data.Aeson.Types.Class.FromJSON
15:14:44 <prinsen>                  TH.API.Types.InputGoogleSearch
15:14:49 <prinsen> geekosaur: ty
15:15:40 <geekosaur> in any case I'm not sure hint can do TN
15:15:43 <geekosaur> er TH
15:15:59 <c_wraith> it should be able to, in theory
15:16:02 <prinsen> geekosaur: It's not doing th, just importing a library
15:16:11 <c_wraith> But there might be weirdness
15:16:21 <c_wraith> I mean, ghci can load modules with TH in them
15:16:30 <c_wraith> and hint and ghci share a lot of code
15:16:37 <prinsen> or it might do, hm
15:17:01 <geekosaur> there's a lot of weirdness in how they interact
15:17:09 <prinsen> The file Hint imports contains $(loadAPIs "../yql-tables/google")
15:17:11 <geekosaur> annoying
15:17:28 <prinsen> so i think thats asking for problems
15:18:05 <bitemyapp> SegFaultAX: AHA, WE GOTCH YOU
15:19:17 <prinsen> geekosaur: I basically want that file to contain the splice of the TH, not the TH
15:20:10 <prinsen> Is there any way to do that?
15:21:13 <geekosaur> if it's not getting spliced for some reason (which would be odd, since you should get a syntax error at the splice instead of a type error) there is zeroth on hackage
15:21:27 <geekosaur> but that's kind of a bad solution, I suspect
15:22:21 <prinsen> geekosaur: well it could be that the folders relative path is wrong. But the whole ide of this expose-library is to be a static splice of $(generate...)
15:22:24 <bitemyapp> SegFaultAX: :|
15:22:41 <geekosaur> again I would expect that to throw something other than a type error
15:23:01 <prinsen> well no
15:23:21 <prinsen> generateTypes generates types from files
15:23:36 <prinsen> if there is no files, nothing is generated, and no instances are generated
15:23:39 <prinsen> leading to the error
15:24:14 <kadoban> @pl \xs ys -> length $ filter id $ zipWith (==) xs ys
15:24:15 <lambdabot> ((length . filter id) .) . zipWith (==)
15:24:38 <new-user> I have a basic question:
15:24:54 <new-user> let a x = True == $ x
15:25:00 <new-user> gives a parse error on $
15:25:05 <Cale> that's correct
15:25:22 <new-user> but not if i surround the (True ==) with parens
15:25:26 <Cale> right
15:25:37 <jle`> :t (True ==)
15:25:38 <lambdabot> Bool -> Bool
15:25:39 <new-user> i thought that the $ operator would do that
15:25:43 <Cale> $ is just an infix operator defined like any other
15:25:43 <geekosaur> no
15:25:47 <Cale> f $ x = f x
15:25:48 <jle`> it's a part of the sections syntax
15:25:56 <jle`> sections are only valid with parentheses
15:26:07 <Cale> It doesn't literally put parens around the things to the left and right of it
15:26:17 <new-user> 'sections' is the name of a syntax construct or something?
15:26:18 <Cale> It just has low precedence
15:26:31 <geekosaur> [26 23:23] <jle`> :t (True ==)
15:26:33 <Cale> Yeah, and (True ==) is an operator section
15:26:34 <geekosaur> that is a section
15:26:42 <pranz> well you can never have operators beside each other
15:26:43 <geekosaur> it's a partially applied infix operator
15:26:51 <jle`> new-user: ah yeah.  if you have an infix operator/function
15:26:55 <jle`> you can "leave off" one of the sides
15:26:58 <geekosaur> the parentheses here are syntactic, not a specification of precedence
15:27:04 <jle`> and it will represent a function 'waiting' for the rest
15:27:07 <geekosaur> $ plays precedence games
15:27:16 <pranz> (2 + . + 2) isn't valid, for example
15:27:16 <jle`> for example, (< 3) is a function waiting for the number to the left of the (<)
15:27:20 <jle`> :t (< 3)
15:27:20 <lambdabot> (Num a, Ord a) => a -> Bool
15:27:27 <geekosaur> it can't supply syntactic parentheses to an operator section
15:27:40 <ownclo_> > :t (==) True $ True
15:27:42 <lambdabot>  <hint>:1:1: parse error on input `:'
15:27:42 <jle`> (True ==) is a function 'waiting' for the boolean to the right of the equals sign
15:27:58 <new-user> thank you, i will investigate 'operator sections'
15:28:00 <jle`> > let f = (True ==) in f True
15:28:01 <lambdabot>  True
15:28:03 <jle`> > let f = (True ==) in f False
15:28:04 <lambdabot>  False
15:28:14 <cmears> new-user, check out http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
15:28:49 <new-user> cmears: thank you for the link
15:28:51 <jle`> its most common usage is for higher order functions.  for example, say you wanted to add one to every element of a list.  map (\x -> 1 + x) xs is kinda clunky, and compare it to map (1 +) xs
15:29:06 <Iceland_jack> > map (\x -> x * 2) [1..10]
15:29:07 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
15:29:09 <Iceland_jack> > map (* 2) [1..10]
15:29:11 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
15:29:50 <jle`> for all the hype that anonymous functions have, they are actually kind of generally considered bad style in Haskell
15:29:53 <new-user> i think i understand partial application of operators, i guess i was just expecting the syntax to not require the parens or something
15:30:22 <jle`> ah yeah (+1) is more interesting that (1+)
15:30:27 <jle`> (*2), (/2)
15:30:35 <jle`> you can't do it with normal partial application
15:30:43 <jle`> without using flip
15:30:52 <Iceland_jack> jle`: Well (* 2) is also an anonymous function, it's just not an abstraction
15:31:04 <jle`> Iceland_jack: ah, yeah
15:31:18 <new-user> thank  you all for your help, this has saved me a lot of time
15:31:26 <Iceland_jack> Haskell has a lot of ways of constructing functions!
15:31:35 <geekosaur> new-user: it's an expansion of treating an infix operator as a function, which is done by wrapping it in parentheses
15:31:46 <geekosaur> so, to use * as a function, you say (*)
15:32:00 <geekosaur> if you then insert one of the parameters it expects, it becomes a section
15:32:26 <jle`> this is commonly also used as a free flip for non-operators
15:32:30 <new-user> sure, but let a x = (==) True $ x works just fine
15:32:32 <jle`> but i'm not sure if it's a good idea
15:32:50 <geekosaur> yes, because (==) is a function now
15:32:59 <ownclo_> Iceland_jack: what is the difference between anonymous function and abstraction (lambda-abstraction)?
15:33:02 <geekosaur> it's the same as map something $ whatever
15:33:07 <new-user> yes, i guess i expected operators to not be treated differently on something
15:33:20 <jle`> ownclo_: (*2) is still a function without a "name"
15:33:25 <jle`> so it's technically anonymous
15:33:40 <geekosaur> operators have to be treated differently like that, otherwise you can't tell whether it's being an operator or a function
15:33:50 <geekosaur> you can't use the type to determine it because of partial application
15:33:53 <Iceland_jack> ownclo_: "\x -> ..." is a lambda abstraction
15:34:33 <jle`> it is anonymous in the sense that we don't have to define a function f x = x * 2 to be able to use it once
15:34:34 <Iceland_jack> but strictly speaking an anonymous function is creating a new function without giving it a name even though it's generally used to refer to lambda abstractions
15:34:58 <new-user> geekosaur: can't the parser tell that it is an operator because it is a symbol?
15:34:58 <Iceland_jack> You could call (drop 3) an anonymous function which does the same as
15:34:58 <Iceland_jack>     drop3 xs = drop 3 xs
15:35:06 <ownclo_> does the same thing happens behind the scenes?
15:35:24 <geekosaur> yes, but then it treats it as an operator
15:35:24 <Iceland_jack> ownclo_: Behind the scenes of what?
15:35:29 <ownclo_> is (*2) equivalent to (\x -> x * 2)?
15:35:32 <Iceland_jack> yes
15:35:42 <geekosaur> `map 1 +` and `map (1 +)` are two different things
15:35:53 <jle`> :t (*2)
15:35:54 <lambdabot> Num a => a -> a
15:35:58 <jle`> :t (\x -> x * 2)
15:35:59 <lambdabot> Num a => a -> a
15:36:01 <Iceland_jack> and (2 *) is the same as ((*) 2)
15:36:02 <geekosaur> or, to make that clearer:  `map + 1` and `map (+ 1)` are two different things
15:36:17 <geekosaur> the former tries to add 1 to the function map, which doesn't work too well
15:36:34 <geekosaur> since it's a function, not a number
15:36:50 <jle`> but i write a Num instance for functions so it's cool.
15:37:07 <ski> (strictly speaking an anonymous function is just a function value, whether it is known under a name somewhere or not)
15:37:51 <Iceland_jack> Let's also talk about anonymous numbers like '5 + 10'
15:37:54 <new-user> geekosaur: so in let a x = True == $ x, so the == binding $ as its right hand argument?
15:38:06 <Iceland_jack> new-user: that doesn't work
15:38:10 <jle`> it's not doing anything because it's not valid syntax
15:38:11 <ski> new-user : that's a parse error
15:38:17 <jle`> it's a lexical error
15:38:22 <jle`> not even a type error
15:38:28 <new-user> what would happen if we made it not be
15:38:35 <new-user> or why wouldn;t that work
15:38:42 <geekosaur> what would it mean?
15:38:49 <Iceland_jack> new-user: Because (==) and ($) are operators
15:38:51 <jle`> well...you are free to define it however you want
15:38:51 <ski> new-user : you can't write `2 * / 3', and you can't write `True == $ x' either
15:38:53 <jle`> in your new language :)
15:38:54 <Iceland_jack> It's like writing
15:38:54 <Iceland_jack>     5 + * 2
15:39:16 <Iceland_jack> new-user: What is the value of '5 + * 2'? :)
15:39:32 <new-user> it seems like it should be a type error then
15:39:34 <geekosaur> remember, $ is not magic syntax. it's just an operator, one with the lowest possible precedence
15:39:46 <geekosaur> this means it *acts* like parentheses. but it is not parentheses
15:39:54 <new-user> with the == expecting something to compare with True
15:40:02 <ski> new-user : if it would be a type error, then what would be the AST tree resulting from the parse ?
15:40:03 <geekosaur> it's doing the same thing as when 5 + 3 * 2 acts like 5 + (3 * 2)
15:40:35 <kadoban> new-user: but it doesn't actually parse...for it to be a type-error, you have to be able to parse it into something that would otherwise make sense, except types don't match how they should
15:40:39 <geekosaur> except in reverse, since * is higher precedence than + but $ is lower precedence than everything else
15:41:03 <ownclo_> I wonder whether (*2) and '\x -> x * 2' are operationally identical. The first one will probably allocate a closure with code pointing to '*' and second argument pointing to '2'. Or will it be explicitly converted to lambda at any stage?
15:41:20 <jle`> ownclo_: that sounds a lot like an implementation detail
15:41:29 <ownclo_> Is there any difference, anyway?
15:41:36 <geekosaur> there shouldn't be
15:41:44 <Earnestly> ownclo_: Why not check ghc's core?
15:42:06 <AncientPC> I'm having trouble debugging my code. I have a "Parse error at []" but I'm not sure what's being called.
15:42:14 <AncientPC> Is there a way to get stack traces?
15:42:25 <jle`> AncientPC: stack traces for parsing?
15:42:31 <kadoban> AncientPC: parse error means it's not actually running, your code is malformed
15:42:34 <geekosaur> my guess is they're writing a parser?
15:42:39 <jle`> ah
15:42:48 <Iceland_jack> ownclo_: http://www.haskell.org/onlinereport/exps.html#sections
15:42:51 <kadoban> AncientPC: look at the part it tells you, it should give you a line and column number where it's confused
15:43:02 <ski> jle` : "for all the hype that anonymous functions have, they are actually kind of generally considered bad style in Haskell" ?
15:43:13 <AncientPC> I should probably clarify. All my code compiles, but I'm working with a parse.hs generated from a Happy file.
15:43:21 <Iceland_jack>     The following identities hold:
15:43:21 <Iceland_jack>         (op e) = \x -> x op e
15:43:21 <Iceland_jack>         (e op) = \x -> e op x
15:43:22 <jle`> ski: i meant explicit lambdas
15:43:31 <AncientPC> So there's a parse error with the generated parser.hs
15:43:31 <new-user> thank you again for your help
15:43:35 <jle`> and you should use partial application and sections whenever possible
15:43:44 <jle`> unless the explicit version is more clear
15:43:47 <ski> jle` : not always
15:44:01 <jle`> if it's more clear
15:44:04 <jle`> then it's generally better to name it
15:44:06 <Iceland_jack> If a compiler is standards compliant then there should be no difference, it doesn't specify particular implementation details
15:44:07 <ski> jle` : consider `forM_'
15:44:08 <jle`> right?
15:44:26 <jle`> ski: ah, i see
15:44:33 <jle`> and flip runState and the like?
15:44:36 <AncientPC> Actually I can compile the parser generated by Happy and all other *.hs files so I'm not sure where the Parser error is coming from.
15:44:56 <AncientPC> The parse error doesn't give me a file or line number.
15:45:12 <geekosaur> probably it's the Happy parser complaining that something it's been asked to parse is invalid?
15:45:25 <geekosaur> I haven't worked with Happy, I have no idea what tools it has
15:45:36 <ski> jle` : in my ears, saying you should name every function (defining it separately) is a bit like claiming you should name (and define separately) your `for' and `while' loops in C)
15:45:47 <AncientPC> geekosaur: Probably. I have some experience with yacc as well.
15:45:51 <geekosaur> but in yacc if you want location information you need to write it yourself, yyerror() is pretty dumb. (note, I'm talking about real yacc)
15:45:54 <Aster> Hi, I¬¥m having issues with ghc 7.4.2 and cabal 1.18.0.2; I¬¥m getting a bunch of /usr/bin/ld: cannot find -lHS... when trying to install a cabal package.
15:45:59 <AncientPC> the generated errors are pretty opaque. :(
15:46:57 <identity> Aster: Could you be more specific? Perhaps paste the errors?
15:47:21 <identity> http://lpaste.net
15:47:29 <Peaker> When showing Haskell, it bums me to show that a nice Python for loop:   for i in items:      becomes:   forM_ items $ \i -> do
15:47:39 <Aster> identity: http://sprunge.us/MSjS
15:47:48 <Aster> Sorry, it¬¥s easier for me to use sprunge :p
15:48:15 <ski> Peaker : otoh it's a library ..
15:48:17 <identity> Aster: That does look pretty bad.
15:48:30 <identity> Aster: Distro?
15:48:31 <Earnestly> Aster: Add ?hs if you want pygments to highlight it, fwiw
15:48:37 <Peaker> maybe if forM_ was "for", and $ should not have been necessary here, so something like:   for items \i -> do  ...  would have been much nicer
15:48:43 <Earnestly> Sprunge is amazingly simple and easy
15:48:43 <identity> Or is this on windows perhaps?
15:48:46 <dmj`> is there a standard function (like in prelude or data.list) that if given a [[a]] it will return the longest list? maximum doesn't do what I thought it did
15:48:47 <Aster> Earnestly: it¬¥s a cabal build log, no highlighting to make
15:48:53 <Earnestly> Aster: Fair enough
15:48:55 <dmj`> my current solution
15:48:55 <dmj`> max' = maximumBy (\x y -> if length x > length y then GT else LT)
15:49:02 <Iceland_jack> dmj`: comparing length
15:49:07 <identity> dmj`: maximumBy (comparing length)
15:49:09 <Peaker> ski: the emotional response to superficial ugliness is strong.. emotional response to deep beauty is also strong, but delayed -- often forever due to the former
15:49:12 <Iceland_jack> @ty maximumBy (comparing length)
15:49:13 <lambdabot> [[a]] -> [a]
15:49:14 <Earnestly> Aster: Don't worry, sprunge (and ix) are probably the best available for quick pastes
15:49:19 <Aster> identity: Archlinux, I installed the unofficial ghc 7.4 because a program I really want to get working requires it.
15:49:26 <identity> > maximumBy (comparing length) [[1,2,3], [1,2]]
15:49:27 <lambdabot>  [1,2,3]
15:49:29 <dmj`> :i comparing
15:49:33 <dmj`> where is comparing?
15:49:35 <Peaker> ski: also, there is often a strong correlation between superficial beauty and deep beauty.  i.e: superficially ugly code will often be deeply ugly too
15:49:36 <identity> It's in Data.Ord
15:49:36 <Iceland_jack> Data.Ord
15:49:39 <identity> There's also on
15:49:43 <identity> :t on
15:49:44 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:49:54 <Iceland_jack> dmj`: You can use Hoogle to find where functions are
15:49:57 <Iceland_jack> @hoogle comparing
15:49:57 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:50:06 <identity> Aster: How did you install the 'unofficial' ghc?
15:50:06 <Peaker> ski: I think Haskell should have optimized these cases that have nicer syntax in other languages if it didn't want to avoid success :)
15:50:07 <Earnestly> Aster: Btw, tried using cabal-dev for that purpose?
15:50:18 <identity> And by unofficial, did you build it yourself, you mean?
15:50:40 <dmj`> Iceland_Jack: thanks!
15:50:44 <Peaker> I guess new Haskell users don't see "forM_" for quite a bit
15:50:45 <Aster> identity: AUR (Archlinux User Repo), it¬¥s a user package that builds GHC itself, yes.
15:50:51 <identity> Ah, I see.
15:50:53 <Peaker> by which time they know things are beautiful :)
15:50:57 <Aster> Earnestly: nope! How does that work?
15:51:13 <identity> I've never seen those errors, but that doesn't mean too much since I'm not the most experienced. But have you considered simply building the haskell platform from www.haskell.org?
15:51:20 <Iceland_jack> Peaker: I agree that Python's version is nicer :) have you looked at Idris?
15:51:24 <identity> I'm not sure how up-to-date arch's repos are, but it shouldn't really be a problem
15:51:32 <Earnestly> Aster: The ghc maintainer on Arch mostly recommends just using cabal anyway.  As for cabal-dev, see https://github.com/creswick/cabal-dev/blob/master/README.md
15:51:33 <identity> It's pretty simple on ubuntu, even 12.04.
15:51:34 <Iceland_jack> They allow you to change the syntax
15:51:43 <Iceland_jack> dmj`: You're welcome, happy Haskelling!
15:51:47 <Aster> Arch is probably the most up-to-date.
15:51:52 <Earnestly> identity: Arch is on ghc 7.6.3
15:52:02 <Aster> As in, GHC is too up-to-date to run the program I want.
15:52:14 <identity> Aster: Oh. What is that program?
15:52:34 <Aster> identity: geordi, and IRC bot that `runs` C++.
15:52:39 <Aster> an IRC bot*
15:52:39 <identity> Oooh, yes.
15:52:43 <identity> I see.
15:52:44 <Peaker> Iceland_jack: not enough, I'm sure :)
15:53:01 <Iceland_jack> Peaker: Just check it out :) they have pretty much this example
15:53:02 <identity> Aster: At any rate, you can still grab an older haskell-platform. The errors you're having definitely look like arch-specific errors
15:53:03 <johtso> what the best practice way to deal with pattern match failures? would be nice to make it easier to debug as you don't get told what failed to match. http://lpaste.net/8236437373127229440
15:53:18 <identity> johtso: Do you have -Wall enabled?
15:53:28 <identity> It will warn you if you have unmatched patterns.
15:53:28 <Aster> identity: what do you mean by haskell-platform?
15:53:29 <johtso> I can't return an error as it expects a certain type
15:53:34 <Peaker> Iceland_jack: it's on my TODO list for ages :)
15:53:42 <identity> Aster: Oh, maybe that's the issue. Did you *just* build ghc?
15:53:45 <identity> That is, only ghc?
15:53:53 <Aster> identity: yes
15:54:01 <identity> Aster: That's the problem, then. YOu ahve a compile but no libraries.
15:54:10 <Aster> identity: ah?
15:54:16 <identity> cabal is trying to build the libraries you want to fetch without anything to build it against.
15:54:28 <johtso> identity, ah yes, I just read about and started using -fwarn-incomplete-patterns
15:54:29 <identity> When you install ghc, you normally do it alongside a bunch of libraries.
15:54:43 <identity> (The haskell platform)
15:54:46 <johtso> identity, but the thing is, I don't know what I should be doing in my fall through pattern
15:55:24 <Aster> identity: I see. I¬¥ll try out cabal-dev, then I¬¥ll look into that some mroe.
15:55:26 <Aster> more*
15:55:30 <Iceland_jack> Peaker: Example Idris code
15:55:30 <Iceland_jack>     main : IO ()
15:55:30 <Iceland_jack>     main = do for x in [1..10]:
15:55:31 <Iceland_jack>                   putStrLn ("Number " ++ show x)
15:55:35 <Iceland_jack>               putStrLn "Done!"
15:55:42 <Iceland_jack> http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf, section 11.1 :)
15:55:45 <ski> Peaker : "the emotional response to superficial ugliness is strong.. emotional response to deep beauty is also strong, but delayed -- often forever due to the former"
15:55:50 <ski> Peaker : "there is often a strong correlation between superficial beauty and deep beauty" -- yes, but often because we make it so, because of the above quote
15:55:54 <Peaker> Iceland_jack: what do "in" and ":" do?
15:56:04 <Iceland_jack> Just sugar
15:56:04 <identity> Aster: otherwise I recommend going to www.haskell.org, downloading the haskell platform that contains ghc 7.4.2 and building that
15:56:16 <Iceland_jack> Defined using
15:56:16 <Iceland_jack>     syntax "for" {x} "in" [xs] ":" [body] = forLoop xs (\x => body)
15:56:17 <Earnestly> identity: The "official" package does install most of them, base, unix, time, binary, etc.  But this "AUR" package (pretty much all AUR packages are bad) doesn't.
15:56:18 <ownclo_> johtso: either use 'error' or 'maybe'
15:56:22 <ski> Peaker : cf. adding syntactic salt for "bad" constructs, which you should think twice before using
15:56:33 <Aster> identity: alright, thanks. I¬¥ll keep you posted on my progress.
15:56:40 <Peaker> ski: I think it's usually because when someone cares about the code they're writing, they'll try to make it pretty in both deep and superficial senses.  So superficially ugly code was usually written by a coder who doesn't care
15:56:44 <identity> Earnestly: I see. I have very little experience with arch linux.
15:57:36 <bennofs> resourcet question: should I layer ResourceT over EitherT or EitherT over ResourceT? I.e ResourceT (EitherT ...) or EitherT ... (ResourceT ...)
15:57:39 <Peaker> ski: ah, if forM_ and lambda parameters are ugly/noisy because we want to discourage them, that's a different matter.. I understand "forM_" (noisy name)  but $ \..  is silly.. why discourage that?
15:57:41 <Iceland_jack> Peaker: Is that enough change for you? :)
15:57:54 <Earnestly> identity: http://sprunge.us/WeCW?sh is an example, taster if you want
15:58:12 <ski> Peaker : one of the problems with C++ is that when code is superficially simple, it's commonly deeply complex or wrong. the good safe way should be the default thing that people reach for at first, more semantically ugly things should also be more syntactically ugly
15:58:17 <Peaker> Iceland_jack: you can define new sugar freely like that? That sounds a bit crazy :)
15:58:30 <identity> johtso: I see. Well, in that case, you'd probably want to just use error.
15:58:33 <Iceland_jack> Peaker: A big part of Idris is writing DSLs
15:58:35 <identity> E.g. 'error'
15:58:39 <identity> @hoogle error
15:58:39 <lambdabot> Prelude error :: [Char] -> a
15:58:39 <lambdabot> Control.OldException errorCalls :: Exception -> Maybe String
15:58:39 <lambdabot> package error-loc
15:58:40 <Peaker> Iceland_jack: Haskell too
15:58:52 <ski> Peaker : also, i don't think "forM_ and lambda parameters are ugly/noisy because we want to discourage them" holds -- the above were general remarks about what would be good to strive for
15:58:53 <Iceland_jack> I don't believe that was a part of the original design of Haskell?
15:59:02 <Peaker> Iceland_jack: By having light-weight function application syntax, you can do DSLs pretty well (e.g: augustuss's BASIC/C DSL's)
15:59:09 <identity> johtso: The alternative is to use Maybe, but that means dealing with that all over your code unless all of it is in the maybe monad.
15:59:14 <Iceland_jack> Yes of course but Idris has that as well
15:59:44 <Peaker> ski: I agree with semantically ugly -> syntactically ugly.  I just think a for loop is ugly in Haskell without being semantically ugly
15:59:56 <ski> Peaker : somewhat, yes
16:00:08 <ski> Peaker : it would be better if the `$' wasn't needed :)
16:00:12 <Iceland_jack> ski: Agreed
16:00:14 <Peaker> Iceland_jack: I understand -- and it makes the for loop somewhat nicer -- but it also makes the reader's life more difficult in many cases, I am guessing
16:00:19 <identity> johtso: But depending on what you're doing and how that function will be used, square c = error $ c : " is not a valid square." -- might suit your needs.
16:00:21 <johtso> identity, ah, I can return error! sorry, I had a syntax issue that was causing me to think I had a type error
16:00:21 <Iceland_jack> Peaker: Absolutely!
16:00:48 <Peaker> Iceland_jack: I think the best trade-off is something like:   for items \item -> do
16:01:05 <Peaker> Iceland_jack: not as sugary as custom sugar -- but easy to explain
16:01:18 <ski> Iceland_jack : i'm not sure whether that Idris `for' loop is really any better .. unless it does give you a whole "loop clause" language you can use in between that `for' and that `:'
16:01:21 <Peaker> whereas when I show beginners Haskell code, I need to pollute my explanations with what "$ do" means
16:01:47 <johtso> identity, ah, don't know that syntax, I was doing error $ "Unknown board character: " ++ [a]
16:01:55 <johtso> identity, what does -- do?
16:02:05 <Iceland_jack> johtso: comment?
16:02:16 <identity> johtso: Oh, that was just a delimter in my explanation, heh
16:02:23 <johtso> oh of course ><
16:02:25 <identity> to denote where the code stopped.
16:02:33 <Earnestly> johtso: -- is ‚Äî
16:02:45 <Iceland_jack> ski: What do you mean ‚Äúwhole loop clause‚Äù language? it expands to just about the same as the identifier or pattern in a lambda function
16:02:54 <Earnestly> Except in ascii because someone can't compose ‚ò∫
16:02:56 <ski> Peaker : in general, i think `foo \...',`foo do ...',`foo case ...',`foo if ...' should all be allowed. probably also allowing `foo let ...' for consistency
16:02:56 <Peaker> Iceland_jack: I think he means Lisp's LOOP macro
16:03:19 <Iceland_jack> Peaker: LOOP is terrible..
16:03:24 <Peaker> ski: I'd remove "let" from the language, and just allow "where" in lambdas
16:03:24 * hackagebot rollbar 0.2.1 - error tracking through rollbar.com  http://hackage.haskell.org/package/rollbar-0.2.1 (GregWeber)
16:03:29 <Peaker> Iceland_jack: I dislike it too
16:03:51 <Aster> identity: alright, compiling GHC 7.4.2, then I¬¥ll build the Haskell Platform.
16:03:53 <Peaker> ski: and implicit "let" in "do" notation
16:04:24 <johtso> hah, that's embarrassing, and there's me wondering why it's not in hoogle :)
16:04:25 <Peaker> do { line <- readLine ; dup = line ++ line ; print (dup, dup) }
16:04:25 <ski> Peaker : how to do mutually recursive bindings inside a `do', then ?
16:04:27 <Iceland_jack> Then again too much power is bad because people collectively can't handle it
16:04:33 <ski> using `rec' ?
16:04:59 <Peaker> ski: I think all the mutually recursive bindings I ever wrote in "do" were accidental infinite loops :)
16:05:23 <ski> Peaker : you never define function bindings inside a `do' ?
16:05:24 <Iceland_jack> I've mostly used mutually recursive bindings in do to show off mutually recursive bindings :)
16:05:44 <Iceland_jack> ski: You could mandate a ‚Äúlet‚Äù there
16:05:45 <Peaker> ski: well, I exaggerated, but probably not many corecursive ones
16:05:51 <Iceland_jack> and elide it otherwise
16:06:05 <Iceland_jack> then again I've had this conversation here before :)
16:06:05 <Peaker> I think Haskell should have required "rec" for recursive bindings everywhere
16:06:15 <Aster> When compiling GHC 7.4.2, I get ghc-cabal: At least the following dependencies are missing: containers >=0.2 && <0.5, directory >=1 && <1.2
16:06:19 <Aster> How do I fix /that/?
16:06:21 <dmj`> Peaker: like F#?
16:06:24 <Peaker> General recursion is a dangerous potential side-effect, so I don't want to summon it accidentally
16:06:30 <Peaker> dmj`: probably
16:06:47 <Peaker> I was bitten by accidental general recursions many times
16:07:10 <lavorno> dmj: btw of f#, not a big fan of it but i really like their "type providers" - is there anything in haskell like that ?
16:07:10 <Iceland_jack> I like the idea of ‚Äúsummoning‚Äù recursion :)
16:07:10 <Peaker> I used to hate the idea of "rec" when I saw it in OCaml/etc. but then I realized it was probably a good idea :)
16:07:12 <dmj`> Peaker: ah yes
16:07:28 <Iceland_jack> lavorno: not that I'm aware, Idris does have something like that though
16:08:02 <lavorno> iceland_jack: yes, i heard of iris  - was v interested bat a haskell equivalent though.. do you think is possible to have that in haskell ?
16:08:14 <lavorno> bat=about
16:08:24 <Iceland_jack> Not sure bat that
16:08:27 <Peaker> ski: allowing "let" only in "do" is also an alternative.  But having two almost identical name binders "let" and "where" everywhere is unnecessary/confusing freedom
16:09:05 <lavorno> imo the type providers concept would fit haskell a lot better than f#
16:09:14 <Peaker> aren't type providers TH macros?
16:09:16 <roconnor> haasn: yt?
16:09:24 <Peaker> (basically?)
16:09:24 <dmj`> lavorno: I don't believe so, I think type providers is piggy-backing on a lot of existing functionality that .net already had
16:09:27 <lavorno> and open the door for haskell integration with lots of apis/etc - minimal effot
16:09:45 <Peaker> what's the difference between type providers and TH?
16:10:05 <dmj`> specifically w/ entity framework
16:10:08 <lavorno> dmj: agree, i believe they leverage some components for integration, but how about "pure" providers ? (like web based)
16:10:53 <lavorno> dmj: think jason, xml, etc - fairly structured things
16:10:58 <dmj`> lavorno: what's wrong w/ open protocols :) json is nice and easy, but no you won't get intellisense integration. You *will* get better compile time checking though and fewer bugs
16:11:11 <dmj`> using haskell
16:11:27 <haasn> roconnor: pong
16:11:36 <lavorno> dmj: that's exactly what i was saying - use json, and the likes for integration
16:11:41 <Peaker> I guess "type providers are TH macros that tend to do IO" would be relatively accurate?
16:12:01 <Peaker> (and are executed/expanded by the IDEs/tooling by convention)
16:12:05 <lavorno> Peaker: let me find a definition
16:12:15 <Peaker> lavorno: I'm trying to define what Type Providers are in Haskell terms
16:12:17 <dmj`> Peaker: it's more of a .net construct, specific to F#
16:12:32 <roconnor> haasn: the darcs sources of the colour library has support for Rec.709 in Data.Colour.HDTV
16:12:32 <dmj`> I can't think of a correlation
16:12:36 <prinsen> Cale: Hi, are you there?
16:12:36 <dmj`> http://www.developerfusion.com/article/145919/an-introduction-to-f-type-providers/
16:12:43 <Peaker> dmj`: but it doesn't seem to be different to TH macros, conceptually?
16:12:54 <roconnor> haasn: you should try it and let me know if it is useful and I will add it to the module export list.
16:13:17 <roconnor> (assuming it still compiles)
16:13:25 <dmj`> Peaker: Oh, in that sense yes. Entity framework does compile time code-gen
16:13:48 <haasn> roconnor: will do so tomorrow, thanks
16:13:57 <Peaker> dmj`: TH=Template Haskell, not sure what entity framework is
16:14:00 <tautologico> so who's going to make a Haskell plugin for atom? :)
16:14:04 <roconnor> haasn: I haven't looked at that in years though.
16:14:24 <haasn> roconnor: for context: I'm mainly interested in a colour pocket calculator that I know works correctly; so I can eg. easily verify whether my rendering pipelines produce correct results
16:14:29 <gka_hn> dir
16:14:37 <haasn> And I know the rest of ‚Äòcolour‚Äô is certainly implemented sanely
16:15:15 <roconnor> haasn: I used to work for a sofware video rendering company.
16:15:34 <lavorno> Peaker: the idea is to represent data sources as types - which i think it fits perfectly on haskell. was wandering if there is something similar already avail in haskell.
16:15:49 <roconnor> haasn: you will appreciate ...
16:15:56 <roconnor>   tf x | x < 0.0018 = 4.5 * x
16:15:57 <roconnor>        | otherwise = 1.099 * x**(0.45) - 0.099
16:16:11 <haasn> yeah that's exactly what I was looking for
16:16:12 <dmj`> Peaker: it's the .net version I suppose, except it's more integrated w/ the .net ecosystem. You write classes (they call it the 'code first' approach) and hit a button and it magically creates data transfer objects and SQL stored procedures. F# type providers have expanded that concept to external data sources. Template haskell could be used for that sort of thing
16:16:46 <lavorno> dmj: that would be awesome if we could do it in haskell
16:17:05 <haasn> roconnor: unrelated: I have reason to believe that apple's CMS implementation uses a pure power curve with Œ≥=1.95 for the function you just pasted; and it's affecting the way Apple DVD players, QuickTime Player X, Final Cut Pro X etc. encode to/from H.264/BT.709
16:17:10 <haasn> roconnor: do you know how widespread this is?
16:17:47 <roconnor> haasn: ouch.  No I don't.
16:17:48 <haasn> because I checked a handful of blu-ray movies and they all seem subjectively more ‚Äúcorrect‚Äù with 1.95 than with the actual BT.709 gamma function
16:18:06 <haasn> it's bad enough to the point where I'm advising users use this approximation instead of the actual gamma function in video renderers...
16:18:09 <roconnor> haasn: someone told me once that Nintendo used a piecewise linear function for some device.
16:18:17 <Peaker> lavorno: not sure what you're missing from TH here?
16:18:18 <mgsloan> lavorno / dmj`: We could definitely do that in Haskell.  The question is, is it honest to treat external APIs as static?  Are they usually versioned?
16:18:27 <lavorno> dmj: imagine a global set of APIs (like http://www.programmableweb.com/ for example) picking whatever api you need from there and start working right away..
16:18:32 <mgsloan> Yeah, you'd just need to write the library
16:18:37 <Peaker> lavorno: you could write a TH macro to read an SQL schema and generate types from that?
16:19:16 <lavorno> mgsloan: whether is honest or not, is the user decision the point is "ease of integration"
16:19:21 <roconnor> haasn: looks like the darcs sources are not located anywhere obvious
16:19:29 <roconnor> haasn: let me find a link for you to take down.
16:19:46 <dmj`> mgsloan: that's a good question, having that problem w/ hs-stripe. We're using an older version of the API, still supported though
16:19:49 <ownclo_> haasn: do you use haskell at production? I am from multimedia compression and it seems that there is no chance of seriously doing that in haskell.
16:19:55 <lavorno> Peaker: that would be great too, if you could point me to some examples ;)
16:19:57 <haasn> ownclo_: no, C
16:20:00 <haasn> (and GLSL)
16:20:15 <mgsloan> lavorno: Right, it's an engineering matter, that can be done with code generation.  It seems wierd to stick it in the language!
16:20:45 <mgsloan> lavorno: Well, persistent does it the other direction - generates the sql schema and datatypes from one schema - but that's a good proof of concept
16:20:51 <lavorno> mgsloan: maybe i was not expressing myself well. i didn't suggest to stick it in the language. just asking for some libs to do that
16:21:06 <mgsloan> upgrading to full "online" type providers would just be a matter of downloading it from the internet
16:21:35 <mgsloan> lavorno: Oh, nothing wrong with what you're saying, I'm just lambasting F#'s decisions (which I admittedly know little about)
16:21:47 <roconnor> haasn: and it looks like I haven't actually published the darcs repo
16:21:52 <roconnor> haasn: so let me do that now.
16:22:20 <mgsloan> I suppose I can see it being valuable to integrate it into the language if it aids in integration with the development environment
16:22:23 <lavorno> mgsloan: i don't care much bat f# and their decisions, more about how we can easily use haskell to build cool mashup like apps
16:22:25 <ownclo_> there will be no actual type available to a programmer; one will need to hold the types in memory, right?
16:22:51 <mm_freak> ownclo_: multimedia compression?  as in codecs?
16:23:12 <mgsloan> ownclo_: I think the idea is that at compile time you take a snapshot of the external source of types
16:23:16 <lavorno> mgsloan: true - integration with ice is another great benfit - you can get "intellisense" on your external types without having to do anything - just point to the url
16:23:24 <lavorno> ice=ide
16:23:40 <ownclo_> mm_freak: yeah. I've mostly worked at lossless image compression systems
16:24:14 <mgsloan> lavorno: Right, that is pretty cool.  Should still be possible with TH, but I don't think we quite have an intellisense parallel for haskell
16:24:19 <dmj`> mgsloan, lavorno: what you could do is call every api function on a new version of the api, parse the json format into TH splices, then generate it
16:24:20 <mgsloan> (yet!)
16:24:30 <dmj`> if that makes sense
16:24:41 <ownclo_> mgsloan: I see. the compiler will know the types, but you won't be able to look at them
16:24:44 <mm_freak> ownclo_: that seems perfectly doable in haskell‚Ä¶  we have data-parallel arrays and vectorized compilation through LLVM
16:25:03 <mm_freak> ownclo_: furthermore we have a DSL for offloading these computations to CUDA (and hopefully some day OpenCL)
16:25:15 <ownclo_> mm_freak: and I really loved REPA
16:25:52 <mm_freak> ownclo_: we actually have more than one solution now =)
16:25:54 <dmj`> like w/ acid-state migrations are manual, it would be cool if migration instances could be made automatically via TH when an ADT is detected to have changed. Not sure how it'd be possible
16:26:40 <lavorno> ownclo_: if you take a snapshot even at design time of the external source - would be a good starting point
16:28:29 * hackagebot BiobaseXNA 0.8.1.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.8.1.1 (ChristianHoener)
16:28:36 <lavorno> later on you can easily built something on top of it to keep track of snapshots and compare the previous version of the type with the current discovered one. similar to the mechanism cabal uses for packages
16:28:53 <mgsloan> dmj`: Well, persistent does do "safe migrations" automatically.  But sometimes if it's a more complicated transformation, there's no way it could be automatic
16:28:54 <ski> Peaker : actually, i think it's nice to (often) be able to choose between bindings-first and bindings-last
16:29:02 <ski> Peaker : "I think Haskell should have required \"rec\" for recursive bindings everywhere" -- meaning you otherwise have to define things in order ? or meaning that otherwise you can't form cycles (but you can still define stuff in the order you like) ?
16:29:08 <ski> lavorno : can you describe what "type providers" do ?
16:29:18 <roconnor> screw you unix permission bits.
16:29:35 <ski> Iceland_jack : for "loop clause" i have things like CL `loop' in mind yes, but better structured
16:29:37 <roconnor> stupid executable directories
16:29:44 <ski> Iceland_jack : see "The anatomy of a loop: a story of scope and control" by Olin Shivers in 2005-09 at <http://www.ccs.neu.edu/home/shivers/citations.html#loop>
16:29:57 <ski> Iceland_jack : "foof-loop" by Riastradh at <http://mumble.net/~campbell/scheme/foof-loop.txt>,its twin "loopy-loop" by foof at <http://synthcode.com/scheme/>,<http://wiki.call-cc.org/eggref/4/loopy-loop>,"Yow! LOOP macros are LOOPY!" by foof in 2006-09-06 at <http://groups.google.com/group/comp.lang.scheme/msg/60dcac5ea812398>
16:30:06 <ski> Iceland_jack : and also (do)/2 in ECL^{i}PS^{e} at <http://eclipseclp.org/docs/Dev/current/tutorial/tutorial025.html>,<http://eclipseclp.org/docs/Dev/current/userman/umsroot023.html>,<http://eclipseclp.org/docs/Dev/current/bips/kernel/control/do-2.html>
16:30:08 <roconnor> haasn: darcs get http://r6.ca/colour/ # this should work now.  Make note of it.
16:30:18 <dmj`> mgsloan: when you safe are you referring to the db's ability to rollback data def lang (DDL) changes?
16:30:27 <dmj`> ddl transactions
16:30:32 <lavorno> ski: i just seen a demo, so the description will be from my understanding of it, other guys may pitch in
16:30:49 <Iceland_jack> LOOP is realtively nice to work with only because many of the list processing functions in CL were quite unplesant to work with imo
16:31:00 <haasn> roconnor: thanks, got it
16:31:25 <ski> Iceland_jack : the point is that writing loops with tail-recursion is comparable (though perhaps somewhat nicer) to writing loops with `goto'
16:31:25 <Iceland_jack> But LOOP had such a massive design that it was ligitimately frightening :)
16:31:26 <ownclo_> mm_freak: I think that Haskell is ready for that indeed (though I have some doubts about GC). The most striking challenge is that C/C++ is most often part of requirement list. And very few multimedia pro's actually know haskell.
16:31:27 <haasn> roconnor: builds fine, unsurprisingly (for such a simple package)
16:31:44 <Iceland_jack> Sure
16:31:47 <ski> Iceland_jack : and it's sometimes hard to combine looping combinators in the way you want to
16:31:47 <johtso> Is it possible to do a pattern match like this? (any two pieces of the same sort should be equal) `(==) (Piece a) (Piece a) = True`
16:31:48 <lavorno> ski: you have an external source (could be json, wsdl, db, etc), using the "type provider" the language "discovers" the external source at design time (when the code is written) and using IDE intellisense navigates the source to find the parameters and components required to build a call to it
16:32:23 <randomclown> how much program slowdown does enabling profiling cause
16:32:28 <ski> Iceland_jack : so loop clauses is an attempt to build a pointful way of specifying the kind of looping, that tries to compose better
16:33:09 <lavorno> ski: i missed the key part - the provider converts the source into some types that are further explored and used
16:33:09 <Iceland_jack> ski: That's quite unlike what the Idris example does
16:33:35 <mm_freak> ownclo_: yeah, that's plausible, although i found selling haskell rather easy so far
16:36:08 <haasn> roconnor: what is the ‚Äúgamma approximation‚Äù for transfer functions actually used for?
16:36:08 <enthropy> johtso: (==) (Piece a) (Piece b) | a == b = True
16:36:25 <johtso> enthropy, aha
16:36:27 <enthropy> johtso: (==) (Piece a) (Piece b) = a == b  -- probably just as good for your case
16:36:46 <enthropy> assuming you will have a case that is False when the two don't match
16:36:48 <haasn> I see you use 0.5 for HDTV, dual to 2.0; but I think 1.95 is a closer approximation (and one that seems to be used rather than 2.0)
16:37:05 <ownclo_> mm_freak: unfortunately, I failed to sell haskell to them. They always said something like 'you know, son, we can do all of that in C. Can you _prove_ that your language is more modular?' and 'we have a special optimisation team to work on our C prototype, go and tell them that you'll use haskell'
16:37:09 <haasn> although its inverse, 0.5128 is deceptively close to 0.5
16:37:20 <enthropy> Piece a == Piece b = a == b -- probably the shortest it'll go
16:37:35 <geekosaur> enjoy those off by 1 core dumps
16:37:36 <enthropy> unless you can use deriving(Eq)
16:38:39 <ski> Iceland_jack : ok ?
16:38:45 <ski> Iceland_jack : instead of stuff like CL `(loop repeat 10 collect (asin 42))' you in foof-loop write like `(loop ((for x (in-list x-list)) (for y (in-vector y-vector)) i (up-from 0) (for z-list (listing (foo x y i)))) => z-list)' e.g.
16:38:52 <roconnor> haasn: I intended it as informational only.
16:39:14 <haasn> roconnor: I'm not sure who it's supposed to be informing, though - if it exists, isn't the danger that people will end up using it? (like Apple seems to have done)
16:39:25 <ownclo_> mm_freak: the amount of frustration I got from that caused me to quit the team. That is my failure story about 'selling haskell' :)
16:39:55 <ski> Iceland_jack : s/i (up-from 0)/(for i (up-from 0))/
16:40:09 <ski> Iceland_jack : the latter composes better, and you can define your own looping constructs like `in-list',`in-vector',`listing' without having to change the basic `loop' macro
16:40:09 <roconnor> haasn: the idea is that you may compose to different curves that are supposed to represent the same gamma but are formally different (think working with Nintendo's piecewise function on one hand and adobe on the other hand).
16:40:40 <roconnor> haasn: so you would like to know if you have put the functions together sanely by checking that the composate gamma is (approximately) 1.0.
16:40:51 <roconnor> haasn: even though the composite is some screwy function.
16:41:14 <Iceland_jack> Doesn't sound that dissimilar from fusion
16:41:27 <haasn> roconnor: fair enough
16:41:47 <roconnor> haasn: it could be a design mistake on my part.  I supose time will tell.
16:42:02 <roconnor> maybe I should add more documentation and a blink tag.
16:42:41 <ski> Iceland_jack : i suppose it has some similarities with fusion (the `loop' macro generates efficient code)
16:43:25 <monochrom> onoes, blink tag. add blink tags to every word :)
16:43:35 <haasn> roconnor: worst comes to worse you can make the field private and provide a function for checking whether gamma - 1.0 is below some epsilon
16:43:49 <roconnor> haasn: that's not a bad idea.
16:43:56 <ski> Iceland_jack : by "That's quite unlike what the Idris example does" did you mean anything more/else than it being just a simple syntactic sugar transform ?
16:44:07 <haasn> roconnor: I'm a bit unsure about what y'CbCr represents. Are these full-range values?
16:44:10 <haasn> Or TV-range?
16:45:01 <haasn> looks like TV-range
16:45:06 <johtso> argh, is there something wrong with my type declaration? http://lpaste.net/5203804744023277568
16:45:20 <Iceland_jack> ski: Yes I meant that the Idris example didn't perform any complicated transformations, it just transforms something like
16:45:20 <Iceland_jack>     for (x, y) in xs:
16:45:20 <Iceland_jack>         foo x; bar y
16:45:20 <Iceland_jack> into
16:45:23 <Iceland_jack>     forM_ xs (\(x, y) -> do foo x; bar y)
16:45:54 <monochrom> deep (getText >>> arr words >>> mkElem "blink" >>> mkText)
16:46:06 <mm_freak> ownclo_: well, sure, you can't sell it to everyone‚Ä¶  sometimes haskell doesn't make sense, but in other cases you will sometimes find that people are so hopelessly stuck in their ways that there is no way to fix it
16:46:07 <haasn> roconnor: what happens with out-of-range values?
16:46:36 <mm_freak> ownclo_: in particular beware of full-bearded C programmers =)
16:46:43 <monochrom> err, I guess I mis-ordered mkText and mkElem :)
16:47:14 <lavorno> ski: did you look at the requirements? what do you think ? imo if is done in f# should be much easier doable in haskell
16:47:32 <cmears> johtso, maybe you just want "map" instead of "concatMap"?
16:47:47 <cmears> (if the declared type is the one you actually want)
16:47:54 <lavorno> and it will be a great showcase of the huge advantages of programming with types..
16:48:09 <roconnor> haasn: out of range values for decoding?
16:49:14 <haasn> out-of-gamut values eg. y'CbCr 235 16 16
16:49:14 <Peaker> ski: no affect on ordering -- just disallow cycles
16:49:21 <ownclo_> mm_freak: I was constantly surrounded by them :) and yes, I think that haskell makes a lot of sense in multimedia processing algorithms (at least at the prototype stage)
16:49:27 <haasn> which gives you some extreme like 54.21/338.57/18.41
16:50:16 <roconnor> *Data.Colour.HDTV> y'CbCr 235 16 16
16:50:18 <roconnor> Data.Colour.SRGB.Linear.rgb 0.12816524164376417 1.8073834846482608 0.10164334318883872
16:51:12 <roconnor> so green
16:51:39 <roconnor> haasn: as a general rule, out of gammut colours and imaginary colours are allowed in the colour library.
16:51:42 <monochrom> "so green, very precise"? :)
16:52:02 <haasn> ah, right
16:52:10 <hpc> much cone, so linear
16:52:27 <roconnor> dogreen
16:52:54 <randomclown> how much performance penalty is there when profiling is enabled>?
16:53:24 <hpc> so penalty, very slow, much output
16:53:41 <monochrom> I don't think anyone has data on that
16:53:50 <Peaker> bah, http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-ByteString.html   uses ByteString.Char8 without documenting it clearly
16:53:56 <hpc> (it's not so bad, qualitatively, compared to other language debugging)
16:53:59 <randomclown> I can't reproduce this annoying space leak on my test machines
16:54:02 <ownclo_> mm_freak: I think that when it's time to go parallel (it will be a must pretty soon, I believe), even full-bearded C programmers will shift towards FP. Just look at Java8's parallel streams - it's so FP
16:54:03 <hpc> (but still noticable)
16:54:05 <joelteon> isn't the purpose of building twice with profiling to not have a performance hit?
16:54:10 <randomclown> only on production machines
16:54:11 <joelteon> with/without profiling
16:54:12 <randomclown> fml
16:54:26 <Peaker> there should probably be distinct Word8 and Char8 parsers
16:54:55 <johtso> cmears, ah oops! this is what I wanted http://lpaste.net/5203804744023277568
16:55:43 <Peaker> ownclo_: I don't think Haskell will replace C for high-performance stuff.  Manual memory management and not depending on smart black box optimizers is important in that domain
16:56:25 <Peaker> ownclo_: I am selling Haskell as a Python replacement at my company, not as a C replacement
16:56:46 <Peaker> (And even that is quite difficult!)
16:56:57 <roconnor> I'm a real fan of assembling "recipies" using a modular purely functional lazy lanugage, and then executing those receipes (possibly with haste).
16:57:23 <roconnor> This is both how Nix and Haskell more or less work.
16:57:26 <lavorno> Peaker: imo memory management in c comes after the algorithms work. and haskell should be much faster to build algorithms with
16:57:31 <roconnor> and it seems really effective in both domains.
16:57:39 <Peaker> lavorno: we design them hand-in-hand
16:57:54 <lavorno> Peaker: still ok
16:58:11 <Peaker> lavorno: for example, we might choose one algorithm over another because its data structure is more easily manageable intrusively
16:59:16 <lavorno> Peaker: true, it depends on the situation. if you need a lot of inlace replace..c would still do it
16:59:27 <Peaker> lavorno: also, in long-running, super-stable systems, part of the correctness spec is not leaking anything, having clearly confined memory use in all cases, etc.  That is moderately easy to guarantee in C (at least without many dynamic allocations, which you should avoid anyway in C).  Very very difficulty in Haskell
16:59:55 <lavorno> Peaker: agree with that too
17:00:10 <Peaker> lavorno: Yeah, mutable doubly linked lists are super-commonly useful in my domain, and in Haskell you'd have to do something completely different with probably muuuch worse constants
17:00:14 <lavorno> Peaker: i was talking about the design stage
17:00:44 <Peaker> lavorno: the design of a Haskell program and a C program are so different that I'm not sure such a prototype in Haskell would help much
17:01:47 <lavorno> Peaker: imo if you start with the interfaces and the algorithms you should be able to prototype and port much easier
17:02:07 <lavorno> that's why i was talking about type providers
17:03:00 <lavorno> they can allow to hook into various api-s / services/ etc at design time, try them out, use them, get an intuition.. once you have a more clear picture build the final approach (haskell/c/etc)
17:03:30 <Peaker> lavorno: but prototyping a super-mutability-based algorithm in an immutable-by-default language is going to be cumbersome
17:03:50 <lavorno> Peaker: sure, i didn't say u do that
17:03:55 <Peaker> lavorno: Well, when you have a lot of external uncertainties, sure
17:04:14 <Peaker> lavorno: in the storage controller world, all the external interfaces are relatively simple and certain
17:04:22 <Peaker> (which is the high performance world I'm familiar with)
17:04:40 <dmj`> lavorno: using http-conduit and aeson you can model and communicate w/ most json apis pretty well.
17:04:51 <lavorno> Peaker: if that's what you are talking about, i don't see haskell there, as the SLAs should be fairly tight
17:05:12 <ownclo_> Peaker: well C is not very good at going parallel from maintenance point of view. I think that benefits of easily going parallel can sometimes outweigh  C performance.
17:05:57 <lavorno> dmj`: sounds good, will check them out. is there something equivalent for wsdl/xml ?
17:06:10 <Peaker> ownclo_: in some domains, parallelism is relatively easy
17:06:13 <Peaker> ownclo_: even in C
17:06:41 <ownclo_> but anyway, C is sometimes irreplaceable
17:06:49 <Peaker> ownclo_: there might be some problems that Haskell outachieves C in practice -- until some C guru manages to carefully write a working parallel version in C
17:07:08 <johnw> and then a Haskell guru carefully writes that to something even better
17:07:13 <Peaker> I think Haskell should aim to replace Python, Ruby, Java, not C and C++
17:07:15 <haasn> roconnor: hmm, I'm seeing some unexpected deviation when comparing against http://home.roadrunner.com/%7Eres18h39/color.htm eg. for y'CbCr 170 80 106 I get linear 0.3385839252030959 0.6368552839868272 0.16427848444736176
17:07:17 <johnw> there is no end when try to imagine a "perfect implementor"
17:07:26 <haasn> but on the website I get 0.3086 0.6231 0.1085
17:07:36 <haasn> the deviation on blue is quite significant
17:07:47 <Peaker> johnw: A good C implementor will beat a good Haskell implementor in performance, it's quite an unfair advantage
17:07:57 <johnw> i don't buy that
17:08:00 <Peaker> (may require more time to reach the optimum, though)
17:08:06 <johnw> i think a lot of people say it, but I don't buy it
17:08:18 <lavorno> Peaker: back in the days i used to play with disk drive controllers parking heads, etc - you could break a disk by just making it bang it's head in a tight loop :)
17:08:22 <geekosaur> it's true, but you have to find that good implementor
17:08:38 <geekosaur> for some problems, a sufficiently good implementor will be quite hard to find
17:08:38 <Peaker> johnw: GC is a big handicap right out the bat. Pointer chasing everywhere is very expensive.  Immutability-based algorithms have a huge constant compared to mutability-based ones
17:08:41 <haasn> roconnor: the values from the website match what I expect and what I get in other applications I've tested (QTX when accounting for the bug, mpv, solving the matrix with wolframalpha)
17:09:01 <johnw> Peaker: I think you're assuming way too much
17:09:14 <lavorno> Peaker: i think what you say is that "for a certain class of problems c is better" - everybody agrees with that
17:09:24 <johnw> yes, for that I would agree
17:09:28 <dmj`> lavorno: unsure about wsdl, I'd try tagsoup,haxml,hxt for the latter
17:09:30 <Peaker> johnw: A Haskell program that uses all the C-style techniques (e.g: mutable array and not IntMap) is going to be a very ugly Haskell program (and lose many of Haskell's advantages along the way too)
17:09:47 <johnw> Peaker: you never said prettiness was also a constraint
17:10:03 <lavorno> dmi`: i played with tagsoup/hxt and it works but they don't do type conversion, just parsing and navigation
17:10:13 <geekosaur> "lose many of Haskell's advantages along the way"
17:10:19 <johnw> so don't restrict the Haskell implementor's freedom and then claim that C wins because it's a better language at doing X
17:10:21 <Peaker> johnw: I think the ugly Haskell program is going to require as much effort as the C program, and will still be beaten by the C program
17:10:37 <johnw> yeah, I still don't buy ti
17:10:38 <Peaker> johnw: whereas the pretty Haskell program will be easier to write but significantly slower
17:11:11 <lavorno> Peaker: be honest here - are u frustrated from writing too much c code and came over to slap some haskell dudes? ;)
17:11:13 <roconnor> haasn: hmm
17:11:16 <johnw> i'm glad you seem to already know all of this apriori
17:11:22 <Peaker> johnw: One high performance technique in C is intrusive mutable doubly linked lists.  I don't see Haskell programs implementing that - and if they do, it's going to be much more difficult than in C
17:11:31 <geekosaur> johnw, people have been doing this for years
17:11:39 <haasn> roconnor: I think your invtf is all wrong; you can't invert the transfer by simply swapping * with / and + with -, can you?
17:11:48 <haasn> roconnor: you need to actually account for the difference in order of operations
17:11:51 <johnw> geekosaur: yeah, I've noticed; they also say Haskell can't be used for practical code
17:11:59 <Peaker> lavorno: I love Haskell -- I just think people who believe it can/should replace C are misdirecting their efforts. Haskell should replace Java, Python, Ruby, Javascript, etc.
17:12:04 <dmj`> lavorno: what do you mean by type conversion
17:12:06 <johnw> funny how Haskell keeps achieving things people know it can't do
17:12:39 <kadoban> ...how do i remove a package in cabal? apparently i already had parsec, installed parsec3 and now i get errors because i have two versions or something
17:12:44 <ownclo_> Peaker: will the C program be written by an expert in that case? Because if not, I have a nice example of haskell's array sort beating C++ array sort in performance.
17:13:13 <haasn> roconnor: I changed it to    | otherwise = ((x + 0.099)/1.099)**recip 0.45  and it works fine now
17:13:25 <Peaker> ownclo_: Reasonable expertise assumed of both Haskeller/C programmer
17:13:39 <haasn> roconnor: where do I submit patches to this thing? :)
17:13:44 <cmears> kadoban, please see http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
17:13:51 <dmj`> Peaker: we need someone to make a new browser w/ haskell as the language to manipulate the dom, and w/ enough capital to make it a standard
17:13:55 <roconnor> haasn: did I make a typo?
17:14:07 <roconnor> haasn: oh I see
17:14:27 <Peaker> The vast majority of the code in the world is very loosely constrained, performance-wise.  That's where Haskell excels.  For nearing the performance optimum, lack of GC, ease of avoiding pointer chasing, etc are going to be very helpful
17:14:37 <roconnor> haasn: mailto:roconnor@theorem.ca
17:14:42 <kadoban> cmears: thanks much
17:14:45 <Peaker> dmj`: why not GHCJS? :)
17:14:50 <mm_freak> ownclo_: i'm not so optimistic about that‚Ä¶  old school C programmers tend to do it in C anyway, because they don't want to lose control over their resources
17:15:20 <roconnor> haasn: heh, maybe that is why the tests are commented out.
17:15:37 <lavorno> dmj`: i've described that before but here it comes once again :imagine at design time, when you write code, you want to use an external api / system/ etc . they are exposed using json, wsdl, or in a database, etc. a "type provider" would allow you to run a tool and convert that source into a data type that you can easily use in your system, together with the transport used to reach it. so you can access the external code seamlessly,
17:15:37 <lavorno> without much heavy lifting. also, the external system is presented as a static type, so you are getting full advantage of strong typing. makes some sense ? (it is implemented in f# and was hoping we can have something similar in haskell..)
17:15:45 <haasn> roconnor: sent, theoretically
17:15:52 <ownclo_> Peaker: well, I generally agree with you. C _can_ be a better choice. But then one just wraps some bits of C code into an FFI and hop!
17:15:57 <monochrom> C does not let me read or write the carry flag. that ends the "C gives you more optimal control" fairy tale for me.
17:16:04 <haasn> roconnor: I wonder if my mail setup actually works with darcs right now. Would appreciate feedback :)
17:16:16 <johnw> monochrom: lol
17:16:34 <ownclo_> I did that with arithmetic codec. It played perfectly
17:16:34 <Peaker> ownclo_: To near the performance of C in Haskell in many cases, you have to carefully avoid allocations and GC in your loops, remove most polymorphism from your code, strictify your data structures manually, use ugly mutability. The result takes longer to achieve than the C program, is unidiomatic, lacks the advantages Haskell is supposed to bring, etc.
17:16:41 <monochrom> without the carry flag, I can't even implement bloody big-integer addition for real
17:16:58 <Peaker> monochrom: C gives you "more" optimal control, not ultimate/most control
17:17:16 <mm_freak> i would go as far as to say that C is never a good choice‚Ä¶  in the domains where many people believe that C is the right choice there are plenty of a lot more sensible languages, even if it's just C++ for the template/exception support
17:17:17 <johnw> Peaker: you've clearly made up your mind; what are you trying to achieve here?
17:17:33 <Iceland_jack> monochrom: http://stackoverflow.com/a/6399855? :)
17:17:38 <Peaker> johnw: redirect advocacy efforts to a more fruitful direction
17:17:39 <lavorno> dmi`: in f# they use it tightly integrated with the ice, so the boilerplate is generated behind the scene. here we can have a bunch of tools to run before you try to use the external source - and get something like a IDL or similar, then just fill the stub and are done
17:17:46 <lavorno> ice==IDE
17:17:51 <ownclo_> Peaker: I hacked a bit of Juicy.Pixels library; It is pure haskell and it performs well. It was a bit of a pleasure to work with
17:18:05 <mm_freak> lavorno: use haskell syntax please
17:18:07 <mm_freak> where ice = IDE
17:18:08 <mm_freak> =)
17:18:10 <dmj`> Peaker: that's putting a band-aid on it, we need a new browser that's a global standard
17:18:21 <lavorno> mm_freak: ?
17:18:25 <johnw> I use only Haskell at my job.  Performance has never been an issue for us, though debugging space leaks comes up from time to time.  In our 1.5 years in production, I think we've experienced two segfaults.  I'll stick with Haskell.
17:18:28 <haasn> roconnor: test suite passes fine for HDTV now (I haven't checked SDTV)
17:18:28 <Iceland_jack> lavorno: It's a joke :)
17:18:31 <mm_freak> lavorno: just joking
17:18:33 <Peaker> ownclo_: how does its performance compare to libpng/etc?
17:18:33 <l8star__> Œª
17:18:42 <lavorno> mm_freak : you freaked me out
17:18:47 <mm_freak> ;)
17:18:54 <geekosaur> haskell works for the same reason perl does: sometimes fast enough is fast enough, fastest is not necessary
17:18:59 <haasn> he mm_freaked you out
17:19:02 <Peaker> johnw: As you should!  Haskell gives great performance for the vast majority of projects. Even Python gives good enough performance for most projects, and Haskell is much better than that
17:19:27 <roconnor> haasn: so I don't have the adobe 1998 whatever thingy. But you should have the tools needed to make your own.
17:19:30 <johnw> if you're telling me just to not write kernel device drivers in Haskell, I wouldn't have tried anyway
17:19:36 <haasn> roconnor: yes it's a very trivial color space
17:19:42 <ownclo_> Peaker: a lot of ST and INLINE, that's true, but it reads perfectly after some time of hacking
17:20:04 <haasn> roconnor: it just might be useful to add a tested set of default spaces to avoid forcing users to dig out spec sheets and prevent typos
17:20:13 <monochrom> since I don't do any advocacy (in fact against advocacy), I am fine with redirecting advocacy at anywhere.
17:20:17 <Eduard_Munteanu> Hm... am I wrong or does MonadPlus subsume Monoid? Monoid w   -->   MonadPlus (Const w)
17:20:17 <johnw> Peaker: you should talk with carter, who is working on high-performance numerical computing in Haskell
17:20:22 <roconnor> haasn: there are some commented out HDTV tests in Tests.hs
17:20:31 <roconnor> haasn: you might want to uncomment them out.
17:20:32 <ownclo_> I saw some benchmarks, it's about half as fast as C implementation (I'll check in a moment)
17:20:37 <johnw> Eduard_Munteanu: would you really want to Const-wrap everything to use <>?
17:21:02 <Eduard_Munteanu> johnw: no, but I"m thinking indexed additive monads may subsume indexed monoids
17:21:07 <haasn> roconnor: as I mentioned, I uncommented the HDTV test and it works fine. I haven't tested SDTV. I also haven't touched the module export list so you'll need to do that or tell me what I should be careful to export and/or not export
17:21:16 <johnw> perhaps so
17:21:31 <dmj`> lavorno: yea, that's the thing about .net, it's all about the "ide" and closed source
17:21:39 <johnw> i mean, if 'm a' is a monoid, and 'm' is Identity, then 'a' must be a monoid
17:21:42 <Peaker> does parsec not have takeWhile1?
17:22:07 <roconnor> haasn: oh, well it is your special build of data colour so you can do whetever you want on your own computer of course.  I recommend *not* exporting Data.Colour.Luma.  That is meant to be internal.
17:22:15 <haasn> roconnor: AdobeRGB 1998's transfer function is literally just 256/563, nothing crazy or segmented going on
17:22:15 <Eduard_Munteanu> johnw: yeah... it definitely wasn't a "we can remove Monoid" question :)
17:22:32 <Peaker> which parser combinator library is recommended these days, assuming I want nice error messages and don't care much about performance (and ideally, want to do IO during parsing)
17:22:41 <johnw> trifecta
17:22:48 <lavorno> dmj`: no need to do it "closed source" just use it for open ones
17:23:00 <Peaker> johnw: can it do IO during parsing?
17:23:09 <johnw> i'm pretty sure it has a transformer
17:23:09 <Peaker> johnw: e.g: implement "include"?
17:23:12 <Peaker> ah, cool
17:23:18 <monochrom> parsec can do IO during parsing. see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
17:23:32 <Peaker> how similar is trifecta to parsec/attoparsec?
17:23:35 <monochrom> in fact you can do IO and Cont during parsing, too
17:23:45 <johnw> _very_ similar
17:23:57 <Peaker> monochrom: yeah, I know it can -- but parsec got a lot of hate, and now porting attoparsec to parsec is proving slightly annoying (can't find some combinators)
17:24:13 <Peaker> johnw: thanks, cool, hopefully it doesn't depend on half of hackage, edwardk style :)
17:24:27 <johnw> it may pull in more than you'd like...
17:24:33 <johnw> but the error messages are great
17:24:40 <Peaker> cool
17:24:48 <ownclo_> Peaker: here is the benchmark http://soundofapixel.wordpress.com/2013/02/17/juicy-pixels-performances-update/. I find the results to be amazingly fast for pure haskell.
17:24:49 <haasn> roconnor: you have two SDTV modules lying around, what's up with those? I literally know nothing about SDTV since I just concern myself with Blu-ray content
17:25:20 <roconnor> haasn: I received your email
17:25:40 <haasn> ah, looks like they have slightly different primaries
17:25:44 <roconnor> haasn: ugh
17:25:49 <Peaker> ownclo_: they're great.  within 2x of C is great, much much better than Ruby and Python
17:25:56 <Eduard_Munteanu> johnw: I was considering indexed monoids defined as 'class IMonoid (f :: k -> *) (p :: k -> k -> k) (z :: k) where imappend :: f i -> f j -> f (p i j); imempty :: f z'
17:25:57 <roconnor> haasn: 525 line north america SDTV
17:26:05 <haasn> which one conforms to ITU-R Rec BT.601?
17:26:08 <roconnor> haasn: 625 line "PAL" european TV
17:26:14 <haasn> ah okay
17:26:14 <roconnor> both IIRC
17:26:23 <Eduard_Munteanu> johnw: and it seemed to me indexed monads could share the indexing for the additive structure
17:26:26 <roconnor> the nightmares are coming back
17:27:38 <Eduard_Munteanu> Basically ireturn :: a -> m i a, ibind :: m i a -> (a -> m j b) -> m (p i j) b
17:27:47 <haasn> roconnor: mind if I host my fork on hub.darcs.net? I'll push some development there which you could pull if you're ever interested in making another release
17:27:55 <roconnor> haasn: SGTM
17:28:31 <roconnor> haasn: I vaguely recall getting this TV stuff ready for my previous release, but it was taking too long to get right so I just dropped it from that release.
17:28:45 <johnw> Peaker: one other difference to consider with C and Haskell is that the C optimizer is constrained to a certain extent because the user has explicitly stated in their code the order of operations.  It takes a very sophisticated analyzer to figure out what can be safely interleaved.  By contrast, an optimizer like GHC has *far* more latitude in pure code.  And I would venture to guess that Haskell optimization technology is still in its
17:28:46 <johnw> infancy, compared to the age of the C compiler market, and how many research dollars have been poured into it, compared to Haskell.
17:29:45 <johnw> I would bet that the amount of money spent just an "auto-parallelizing" C probably exceeds anything that has ever been spent on Haskell compiler research by at least 1000x
17:30:13 <Peaker> johnw: for speed of development, that's indeed great for Haskell. But when writing high-performance software, a big black box optimizer is more a disadvantage than an advantage.. it isn't clear when it'll break and why
17:30:16 <johnw> I've worked for companies whose entire funding came from gov't grants to auto-parallelize C.  And they all pretty much failed.
17:30:30 <Peaker> johnw: auto-parallelizing C sounds like a pipe dream indeed
17:30:39 <ownclo_> Peaker: pretty acceptable even for high-perf. I would argue that Haskell is not there *yet*, but it's not far around
17:30:43 <roconnor> haasn: is darcs.net free for open source projects such as data.colour?
17:31:04 <johnw> so, if Haskell is a baby compared to the C world's mature old man, it makes me wonder what our argument will look like 20 years from now
17:31:07 <Peaker> johnw: the thing that bothers me the most about Haskell performance-wise, is data structure layout.  Polymorphic fields always cost an indirection :(   I want C++ template like behavior
17:31:09 <haasn> roconnor: yes
17:31:16 <roconnor> haasn: interesting...
17:31:30 <haasn> roconnor: more info over at http://hub.darcs.net/
17:31:33 <Ralith> Peaker: help us bring that to idris! :D
17:31:53 <Peaker> johnw: C might be replaced by Rust-like successors, but I don't think Haskell's (or its successors) will replace the former.  They might embed the former as DSLs though
17:32:15 <roconnor> haasn: this TV stuff as
17:32:22 <Ralith> that's basically what I'm aiming for
17:32:38 <Peaker> (s/replace/be on par, performance-wise)
17:32:50 <Ralith> there's no obvious way a remotely haskell-like language can avoid doing GC in its central expression language
17:32:50 <haasn> roconnor: if you upload your repository to hub.darcs.net I can ‚Äúfork‚Äù it on the website and they'll be linked that way, which gives you an easier interface to monitor differences and auto-merge them etc.
17:32:51 <roconnor> haasn: this TV stuff has gone through a couple iterations.  The various standards are kinda intertwined in strange ways regarding the technical details of how the formulas are derived.
17:32:51 <ownclo_> Peaker: some sort of strictly-typed non-GCd subset of Haskell will go well, I think
17:33:04 <Ralith> but a partial evaluator and a good EDSL can work around that completely
17:33:21 <Ralith> and be much more suited to a particular application than any general purpose imperative language
17:33:23 <Peaker> Ralith: are you working on template-like behavior for Idris?
17:33:35 <Peaker> or super-compilation in general?
17:33:37 <haasn> roconnor: ah yes, I see the spec now; it lists different primaries for 625 and 525
17:33:40 <haasn> that is quite a headache
17:33:43 <Eduard_Munteanu> Or region inference alternatively.
17:33:51 <Ralith> Peaker: well, I've been thinking about it for a year or so. edwinb himself is working on the partial evaluator (I think you've read that paper)
17:34:15 <monochrom> johnw: you may like my http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
17:34:19 <roconnor> haasn: don't even get me started on SMPTE-C
17:34:24 <Ralith> it's definitely something I hope to implement
17:34:36 <johnw> monochrom: neat, will read
17:34:46 <Ralith> might be a while unless someone hires me to, though
17:35:05 <roconnor> haasn: the TV stuff is probably important enough to include in a future release, especially the HDTV stuff.
17:35:27 <roconnor> I should probably make sure the HDTV stuff gets out.
17:36:00 <haasn> roconnor: HDTV absolutely. I don't care about SDTV *personally* but I can see a use-case for them
17:36:26 <bjz> Peaker: The interesting thing that it seems like Rust and Ralith are taking differing approaches - bottom up vs top down. Interested to see how the latter turns out.
17:36:48 * Ralith is flattered to be credited with the approach
17:37:01 <bjz> Oh wel, you are not the first
17:37:07 <mgsloan> Peaker: The non-template behavior of datatypes is an implementation decision though, right?  There's no reason that polymorphic datatypes couldn't cause some functions to autospecialize.  This'd need implicit conversion functions to the polymorphic representation, but it seems feasible
17:37:07 <Ralith> really it's the general direction of practical DTP research, I think
17:37:15 <bjz> but it is your goal, no?
17:37:16 <haasn> roconnor: if I feel particularly generous I may add lenses to the library which would be really cool; maybe some isomorphisms although that would probably incur a ‚Äòprofunctors‚Äô dependency
17:37:19 <Ralith> insofar as idris is not the full extent of practical full-spectrum DTP research anyway
17:37:32 <Ralith> bjz: right
17:37:35 <haasn> roconnor: but imagine just being able to eg. desaturate your colors by using & saturation /~ 2
17:37:57 <Ralith> I just need to get a bit further before I really deserve to be personally associated with the principle of the thing
17:38:01 <ownclo_> well, hardcore optimisation in C is a sort of an art anyway. Or just compile with icc and have a black-box optimising compiler ;)
17:38:26 <Peaker> mgsloan: I agree -- it can definitely be solved. It's just the most annoying thing in Haskell (for me), performance-wise
17:38:37 * hackagebot cab 0.2.9 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.9 (KazuYamamoto)
17:38:47 <mgsloan> Agreed!  I suppose this is the root cause of the inefficiency of transformers as well
17:38:48 <Peaker> mgsloan: when it is solved, many difficult problems still remain (if aiming for on-par-withC)
17:38:54 <mgsloan> right
17:39:32 <Peaker> so is trifecta about enhancing *parsec with layout stuff?
17:39:43 <johnw> it does more than that
17:39:45 <johnw> you'd have to ask edwardk
17:39:52 <johnw> trifecta is a wrapper around the 'parsers' library
17:40:30 <bjz> Ralith: I'm beginning to realise that for Rust the core semantics are: RAII with destructors, linear types, regions, and unsafe blocks. From those you can build nice, safe abstractions, including concurrent ones. Parametric polymorphism allows you to generalise it. Bear in mind I'm speaking rather informally here.
17:40:36 <monochrom> sometimes, I opine "don't aim at C, just keep improving". some other times, I opine, "on par with C? don't kid me, be an adult, aim at fortran"
17:40:37 <mgsloan> I think the original mission statement of trifecta included "better diagnostics"
17:40:55 <haasn> roconnor: I am going to look at the rest of this and maybe confirm HDTV works correctly on some larger sample sizes (I'm also unsure about your cross-over point for the inverse transform function) tomorrow; as for now I desperately need sleep. Thanks for uploading it, this will definitely come in handy
17:40:56 <mgsloan> And maybe also incremental parsing?
17:40:59 <Ralith> bjz: speaking as a non-rust-expert, those seem like reasonable things to say
17:41:17 <roconnor> haasn: good luck
17:41:24 <hpc> my understanding is that trifecta was "take every complaint about parsec and fix them all at once"
17:41:31 <bjz> Ralith: people say it is a very complex language, but they are definitely honing in on a tight core
17:41:39 <haasn> hpc: that's edwardk's working model in general
17:41:55 <Peaker> trifecta needs more examples!
17:41:56 <tautologico> rust is not complex, it just uses some unusual concepts as core ones
17:42:06 <Ralith> bjz: rust? complex? O.o
17:42:12 <bjz> yeah, rather odd
17:42:27 <Ralith> those probably are probably confusing relative novelty for complexity
17:42:28 <Ralith> as is common
17:42:43 <bjz> it was definitely a complex mismash of different ideas way back at 0.23
17:42:46 <bjz> woops
17:42:48 <bjz> 0.3
17:42:49 <kadoban> how do i get parsec to consume a fixed number of things, i.e. 3, instead of many?
17:43:02 <johnw> is it 'count'?  i forget
17:43:08 <hpc> :t repeat
17:43:09 <lambdabot> a -> [a]
17:43:09 <bjz> Ralith: how would your proposed approach look
17:43:11 <hpc> er
17:43:20 <hpc> @hoogle m () -> Int -> m ()
17:43:21 <lambdabot> Graphics.UI.GLUT.Callbacks.Global addTimerCallback :: Timeout -> TimerCallback -> IO ()
17:43:21 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
17:43:21 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
17:43:34 <monochrom> are you looking for replicateM? :)
17:43:40 <hpc> ... yes
17:43:44 <pingu> Hi, I'm new to pipes and am trying to tie them together with Snap (which wants an Enumerator).
17:43:47 <johnw> no, it's called count
17:43:50 <Peaker> http://hackage.haskell.org/package/parsers-0.10.3/docs/Text-Parser-Expression.html <-- seems cool
17:43:59 <johnw> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html
17:44:01 <johnw> second function
17:44:01 <Ralith> bjz: you've asked me this question before, the principle is the same as applied in rust
17:44:07 <monochrom> parsec also has "count", yes
17:44:07 <johnw> count :: Stream s m t => Int -> ParsecT s u m a -> ParsecT s u m [a]
17:44:18 <kadoban> johnw: ohhh, thanks
17:44:20 <pingu> Is anyone here familiar enough with Enumerators to comment on how you might build an 'adapter' for a pipe Consumer to an Enumerator
17:44:25 <bjz> Ralith: sorry, still trying to understand. I have a thick skull :)
17:44:36 <Ralith> bjz: I'd normally be happy to explain in detail but I gtg for a bit
17:44:43 <pingu> Or a pipe Effect to Enumerator I guess
17:44:43 <bjz> Ralith: I sort of mean, working down from a GCed language
17:45:04 <bjz> Ralith: Rust starts off without GC, and allows you to build it
17:45:28 <Ralith> bjz: http://eb.host.cs.st-andrews.ac.uk/writings/icfp10.pdf may give you a sense of things
17:45:35 <bjz> Ralith: not sure how you could build custom allocation stuff in idris
17:45:37 <Ralith> the tl;dr is supercompilation
17:45:39 <bjz> cool, will look
17:45:44 <bjz> o/
17:45:48 <Ralith> \o
17:47:27 <levi> Finally got the real answer to bennofs' killThread issue. GHC 7.6.3 quietly masks asynchronous exceptions in a child process when forkProcess is called.
17:47:46 <bennofs> oh :)
17:48:12 <monochrom> hmm, I think maybe it's documented somewhere... but ok I can agree it's hard to note
17:48:13 <Eduard_Munteanu> Interesting.
17:48:25 <levi> monochrom: In a ghc bug report. :)
17:48:35 <monochrom> I guess so
17:49:21 <joeyh> levi: it's fixed in newer ghc
17:49:24 <johnw> levi: for how long?
17:49:33 <joeyh> (having lost several hours to that myself and filed a bug)
17:49:38 <johnw> through the entire child process?
17:49:42 <levi> https://ghc.haskell.org/trac/ghc/ticket/8433
17:49:47 <joeyh> yep
17:49:51 <johnw> wow
17:49:53 <johnw> that's horrible
17:50:38 <joeyh> I assume it means not many people have managed to use forkProcess ..
17:50:46 <Peaker> what's trifecta/parser's equivalent of "takeWhile"?
17:51:08 <bennofs> levi: so threadDelay unmasks async exceptions?
17:51:11 <geekosaur> well, little things like the old I/O manager bug kinda made it useless anyway
17:51:36 <bennofs> but that I/O manager bug isn't there anymore, right?
17:52:21 <levi> bennofs: I'm not really sure why the threadDelay allowed things to work. It still didn't seem to work immediately, though.
17:53:07 <johnw> Peaker: good question
17:54:57 <Peaker> I guess it's   many (someConditionalParser) ?
17:55:22 <johnw> i was thinking maybe use "guard", but edwardk would know
17:55:49 <johnw> edwardk: lens, trifecta, tables, endomorphized byprofunctors!
17:55:54 <levi> bennofs: What were you using forkProcess for, anyway?
17:56:15 <Peaker> does trifecta have eof? Like attoparsec's "endOfInput"?
17:56:46 <Peaker> oh, "eof" :)
17:57:58 <Peaker> hmm.. is there a "many" which generates a ByteString, rather than going through []?
17:58:35 <Peaker> I'll use String everywhere :(
18:00:57 <johnw> use a doubly-linked mutable String
18:01:07 <johnw> I know you like those :)
18:02:03 <Peaker> awesome, trifecta is giving me great error messages :)
18:02:05 <Peaker> johnw: heh
18:03:22 <Peaker> trifecta's "Parser" type doesn't seem to be a transformer, though?
18:03:40 * hackagebot concurrent-dns-cache 0.0.1 - Concurrent DNS cache  http://hackage.haskell.org/package/concurrent-dns-cache-0.0.1 (KazuYamamoto)
18:05:04 * Clint squints.
18:08:42 <Peaker> I guess only Parsec does the transformer version
18:08:53 <Peaker> trifecta was a nice experiment though, very nice error msgs :)
18:09:09 <enthropy> have you tried uu-parsinglib?
18:11:30 <Peaker> enthropy: not yet
18:12:32 <randomclown> hey is there a way to wake up all threads waiting on a mvar?
18:12:44 <randomclown> or do I have to use channels and dup them
18:13:41 * hackagebot validation 0.3.0 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.3.0 (TonyMorris)
18:14:04 <geekosaur> most people try to avoid thundering herds...
18:14:21 <randomclown> yeah that's not possible to avoid
18:15:01 <Peaker> enthropy: it seems like it also doesn't have a transformer?
18:15:10 <Peaker> Only Parsec was thoughtful enough to have a transformer?
18:15:30 <enthropy> you want to do IO while you parse?
18:15:54 <c_wraith> Maybe he's parsing perl, and needs to execute it to know to parse it.
18:16:03 <Peaker> enthropy: yes
18:16:11 <Peaker> I am parsing Makefiles, and I want to implement "include"
18:16:31 <c_wraith> does include actually affect parsing, though?
18:16:54 <triliyn> It can, I think
18:16:57 <triliyn> It's like C include
18:16:58 <Peaker> c_wraith: not sure about Makefiles, actually, but I want to be able to write a parser that can handle include in any position in the grammar
18:16:59 <geekosaur> it's inserted into the current parse tree
18:16:59 <enthropy> maybe it adds new definitions that affect whether stuff downstream is valid
18:16:59 <c_wraith> is there some reason it needs to be part of parsing, rather than part of execution?
18:17:02 <triliyn> It just expands to the text of the file
18:17:06 <geekosaur> textual include, not module import
18:17:20 <Peaker> c_wraith: apparently even for Makefile, it is necessary for parsing
18:17:41 <Peaker> so at least my choice is easy: Parsec is the only parser that can do it
18:21:43 <ski> Peaker : ok
18:25:46 <lispy> Is that true? I don't think you can change the grammar of makefiles. So while you might need to be able to open/load files on the fly I don't see why happy couldn't do this.
18:26:04 <lispy> You'd just layer your parsing monad on IO
18:27:22 <niotepx> Hello all. Have any of you worked with AJHC, namely an Android app, and be willing to help with some opengl calls?
18:33:44 * hackagebot iproute 1.2.12 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.12 (KazuYamamoto)
18:35:01 <Platz> will there be an RC2 for ghc 7.8 or will it go RC1 -> Final
18:35:47 <Platz> some libraries don't like to be compiled with dyn linking since ghci wants dyn libs now
18:36:28 <randomclown> what I need is a condition variable
18:37:10 <randomclown> and there's going to be high contentsion
18:37:14 <randomclown> so I'm not going use STM
18:43:11 <new-user> i have a question about how "print . show $ True" is parsed
18:43:42 <new-user> the documentation says that function application has a higher precedence than infix operators
18:43:53 <new-user> so is (.) being passed to print?
18:43:59 <jroesch_> it is equivalent to
18:44:01 <roconnor> . is an infix operator
18:44:01 <new-user> as its argument?
18:44:04 <cmears> no, (.) is an operator
18:44:04 <jroesch_> (print . show) $ True
18:44:11 <ion> ($) has the lowest precedence so it‚Äôs (print . show) $ (True)
18:44:23 <new-user> yes, so in the (print . show)
18:44:28 <ion> f $ x = f x, so it‚Äôs (print . show) (True)
18:44:30 <roconnor> new-user: there is no function application in that bit of code.
18:44:34 <new-user> if functions bind befofre operators
18:44:37 <roconnor> everything is infix operators
18:44:41 <ion> (f . g) x = f (g x), so it‚Äôs print (show True)
18:44:44 <new-user> what about print
18:44:57 <cmears> there's no function *application*
18:45:26 <cmears> (syntactically)
18:45:39 <new-user> so print does not get . as its argument?
18:45:58 <roconnor> new-user: correct.  the . is an infix operator, like + and $
18:45:59 <cmears> No, in the same way that in "1 + 2" you're not passing (+) to the function 1
18:46:31 <new-user> operators are blowing my mind
18:46:42 <ion> ‚Äúprint . show‚Äù is the same as ‚Äú(.) print show‚Äù
18:47:00 <ion> > (+) 3 4
18:47:01 <lambdabot>  7
18:47:03 <ion> > 3 + 4
18:47:04 <lambdabot>  7
18:47:05 <new-user> ion: so that syntax change is done before parsing or something?
18:47:41 <ion> There is no ‚Äúsyntax change‚Äù, but ‚Äúprint . show‚Äù will parse as an application of (.) to the values print and show.
18:48:54 <roconnor> new-user: you know that . is an operator because it is a string made out of the characters !#$%&*+./<=>?@\^|-~
18:48:58 <roconnor> (more or less)
18:49:12 <new-user> i am interpreting that to mean that the (.) operator has a higher precendence, even though i know that is wrong
18:49:52 <ion> The precedence of (.) is 9. The precedence of function application can be thought of as being 10.
18:49:53 <new-user> if . were a function, it would not get to apply before print
18:50:18 <new-user> it seems like the . gets to rearrange the words before print takes its first argument
18:50:36 <cmears> Yes, operators are parsed differently from non-operators
18:50:36 <ion> This means ‚Äúa b . c d‚Äù parses as ‚Äú(a b) . (c d)‚Äù, not ‚Äúa (b . c) d‚Äù
18:51:24 <new-user> ion: that makes sense
18:52:09 <new-user> my mental model had the "rearranging" done by the operator as having to do with its precedence, which is wrong
18:53:03 <new-user> thank you for your help
18:53:15 <roconnor> np
19:46:09 <dario> so.. lists are monads, does that mean i can construct (:) from (>>=) and return?
19:47:07 <Aetherspawn> > return 3 :: [Int]
19:47:08 <lambdabot>  [3]
19:48:43 <trolling> dario: no
20:07:02 <t4nk356> quicksilver: ping
20:10:48 <t4nk356> quicksilver: so continuing from yesterday, is it true that just like how all Applicative computations can be transformed to a form in which a single pure function is applied to effectful parts, that all Monadic computations can be transformed to something similar to the Applicative  canonical form followed by a bunch of 'join's?
20:11:34 <ski> t4nk356 : i think so, yes
20:13:49 <randomclown> why is this valid syntax: mapM_ (sem -> putMVar sem ()) sems
20:13:55 <randomclown> doesn't lambda need \
20:14:01 <randomclown> or is that implicit do or something
20:14:39 <ski> it's not valid
20:14:57 <randomclown> it compiles
20:15:23 <randomclown> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-MVar.html
20:15:26 <randomclown> it's on this page
20:16:25 <ski> @type \sems -> mapM_ (sem -> Control.Concurrent.MVar.putMVar sem ()) sems
20:16:26 <lambdabot>     Pattern syntax in expression context:
20:16:26 <lambdabot>         sem -> Control.Concurrent.MVar.putMVar sem ()
20:16:28 <cmears> randomclown, haddock just mucked up the formatting
20:16:28 <ski> @type \sems -> mapM_ (\sem -> Control.Concurrent.MVar.putMVar sem ()) sems
20:16:29 <lambdabot> [GHC.MVar.MVar ()] -> IO ()
20:16:39 <cmears> there's a \ before the sem in the source
20:16:52 <randomclown> that's pretty messed up
20:16:58 <t4nk356> ski: hmm so monadic computations too have a fixed structure (since i don't see what's dynamic about the 'n' joins at the end)?
20:17:03 <randomclown> I remember that code compiling before
20:17:10 <randomclown> so a recent haddock must have messed it
20:17:18 <randomclown> cmears:
20:18:42 <ski> t4nk356 : the dynamicism is that in `M (M a)' the actual structure of the "inner" `M a' may depend on how you reach it (by execution) from the outer `M a'
20:19:14 <ski> er, outer `M (...)'
20:19:21 <randomclown> can dupchan cause memory leaks?
20:20:07 <c_wraith> randomclown: no more than Chan itself causes.
20:20:36 <c_wraith> randomclown: it just makes multiple readers working their way down the linked list.  Links are kept around so long as they still are unconsumed by the slowest reader.
20:20:58 <randomclown> say my slowest reader is a thread and it died
20:21:33 <t4nk356> ski: sure, i think i believe that. but there's no real reason for monadic computations to proceed sequentially as it were
20:21:34 <randomclown> what removes it from the list of readers?
20:22:20 <ski> t4nk356 : right, e.g. expression monads don't
20:23:04 <t4nk356> ski: expression monads? link?
20:23:07 <ski> t4nk356 : still, there's a kind of "abstract sequencing order" involved (which in some cases may actually amount to no real ordering. and in other cases amount to things one usually wouldn't consider "ordering")
20:23:16 <c_wraith> randomclown: I think the garbage collector should handle it automatically, so long as there are no reachable references to that particular dup'd chan
20:24:20 <ski> t4nk356 : expression monads are really a kind of trees
20:24:26 <ski> t4nk356 : start by
20:24:47 <ski>   data Tree a = Leaf a
20:24:48 <ski>               | Branch (Tree a) (Tree a)
20:24:54 <ski> t4nk356 : do you see how this is a monad ?
20:24:55 <randomclown> c_wraith: I need something akin to pthread_condition_variable
20:24:59 <randomclown> c_wraith: any recommendations?
20:25:20 <c_wraith> randomclown: isn't that more or less what MVars give you?
20:25:28 <randomclown> c_wraith: I need to wake up all threads
20:25:31 <randomclown> not just one
20:25:35 <t4nk356> ski: well i can see how this can be interpreted as a monad, i think. in that it seems similar to free monad
20:25:54 <c_wraith> randomclown: oh.  Not sure GHC has anything like that.
20:26:18 <ski> t4nk356 : note how `join' here just walks the outer tree down to the `Leaf's, removing them, in effect splicing the element trees in-place
20:26:22 <randomclown> c_wraith: I'm currently just using a chan but that's not optimal
20:26:27 <randomclown> and I suspect it's leaking a lot
20:26:53 <randomclown> c_wraith: something like a list of mvars? but how do I ensure dead threads get removed
20:26:54 <ski> t4nk356 : ok ?
20:27:03 <t4nk356> ski: yep
20:27:07 <ski> now, consider
20:27:10 <ski>   data Expr var = Var var
20:27:16 <ski>                 | Lit Integer
20:27:24 <ski>                 | Add (Expr var) (Expr var)
20:27:52 <ski> this is also a monad, `join' splices away `Var' nodes, just as for `Leaf' above
20:27:59 <t4nk356> yep
20:29:26 <ski> `(>>=) :: Expr var0 -> (var0 -> Expr var1) -> Expr var1' takes an expression with variables represented by type `var0', and a substitution/environment mapping all such variables into expressions with variables represented by type `var0', and performs the substitution once
20:29:33 <ski> it is also easy to define
20:29:56 <ski>   subst :: Expr var0 -> (var0 -> Expr var0) -> Expr var1
20:30:20 <ski>   subst expr env = do
20:30:26 <ski>     var0 <- expr
20:30:36 <ski>     subst (env var0) env
20:30:52 <ski> this looks like infinite recursion, but it will work just fine on expressions
20:31:19 <t4nk356> ski: won't the second arfument to subst be (var0 -> Expr var1)?
20:31:26 <t4nk356> *argument even
20:31:34 <ski> this type of expressions is like some kind of nondeterminism monad, with grouping (unlike lists), and also with some extra stuff thrown in to annotate the nodes (unlike `Tree' above)
20:31:49 <ski> no
20:32:06 <ski> the point is to perform the substitution repeatedly, until there are no variables left in the expression
20:32:50 <ski> therefore there is no constraint on the type `var1', so it could be replaced by anything, including the type `Void' with no values
20:33:15 <ski> all this amounts to the fact that there will simply be no nodes `Var v' with `v' of type `var1' in the result
20:34:00 <t4nk356> ski: right, sorry my bad. the type for all args is same it's Expr
20:34:19 <scshunt> hey, with template haskell, if I have a Q Exp, can I stick it into a quasiquote?
20:34:21 <ski> now, consider `do var <- expr; ..var..', what this actually does is : given `expr', find each way to walk down it, to a variable, call it `var', then use `..var..' to determine what expression to replace that variable by in the original expression `expr'
20:34:32 <ski> and this is done for *every* variable in the original expresion `expr'
20:34:48 <scshunt> e.g. if foo is a Q Exp, can I do [| bar $(foo) |] to get "bar x" where "x" is what I get from substituting in foo?
20:35:05 <t4nk356> ski: that makes sense
20:35:07 <ski> t4nk356 : no, the type of the arguments of `subst' are `Expr var0' and `var0 -> Expr var0', and the type of the result is `Expr var1'
20:35:46 <ski> t4nk356 : so, here there's no particular ordering imposed on the way in which the different variables in `expr' are visited
20:36:47 <t4nk356> ski: ok so sanity check. var1 may be Expr* var0? is that the idea? where by Expr* i mean 0 or more occurrences of Expr
20:37:17 <ski> t4nk356 : similarly, for the list monad, where `do element <- list; ..element..', which is the same as `[result | element <- list, result <- ..element..]', every `element' of `list' is visited, and in fact you can decide to skip looking at some elements in the output list, and then some elements in the input `list' won't be forced either
20:37:34 <ski> t4nk356 : i don't understand the question
20:37:37 <dagano> without using Data.List, how can i split "abc def zyx" into ["abc","def zyx"]?
20:37:57 <ski> > break isSpace "abc def zyx"
20:37:58 <lambdabot>  ("abc"," def zyx")
20:38:04 <ski> > break isSpace "abc"
20:38:05 <lambdabot>  ("abc","")
20:38:19 <ski> hm
20:38:27 <ski> "without", ok
20:38:28 <t4nk356> ski: the type of result is `Expr var1'. now var1 has to relate to var0 in some way, otherwise how do you get at it. i was trying to characterize the way in which var1 might relate to var0
20:38:29 <dagano> k that was my idea .. but i didn't want that first space in the tail of the result
20:38:54 <ski> t4nk356 : no, `var1' does *not* have to relate to `var0' in some way
20:39:10 <dagano> and yeah .. trying not to use break
20:39:10 <ski> because you don't get any value of that type in the result
20:39:30 <ski> t4nk356 : it's similar to how the empty list `[]' of type `[a]' doesn't add any constraint on the type `a'
20:40:05 <ski> dagano : it can be done with `foldr', but a paramorphism is probably nicer
20:40:10 <pavonia> > second (\x -> if null x then x else tail x) . break isSpace $ "abc def zyx"
20:40:11 <lambdabot>  ("abc","def zyx")
20:41:13 <ski> @type drop 1
20:41:14 <lambdabot> [a] -> [a]
20:41:15 <t4nk356> ski: could you show me what signature for subst would be for lists? would it be [a0] -> (a0 -> [a0]) -> [a1]?
20:41:31 <dagano> paramorphism ... aaaand you lost me
20:41:31 <ski> t4nk356 : yes .. but for lists, it's useless
20:41:50 <dagano> pavonia: helpful, thanks..still using break though
20:42:28 <pavonia> dagano: What's wrong with break?
20:42:36 <t4nk356> ski: ok at least we're in agreement there. since in lists a1 has to be related to a0
20:42:55 <ski> dagano : <http://comonad.com/reader/2009/recursion-schemes/>
20:43:40 <ski> t4nk356 : no, "in lists a1 has to be related to a0" isn't right
20:44:09 <dagano> there was a nice talk on folds today that i neglected to go to..perhaps i would have learned that . thanks
20:44:14 <ski> t4nk356 : the problem with lists is that they have too little extra structure apart from the elements, for the result of `subst' to be of any interest
20:44:27 <ski> dagano : consider
20:44:30 <ski> @src foldr
20:44:31 <lambdabot> foldr f z []     = z
20:44:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:44:33 <ski> vs.
20:44:38 <ski> well
20:44:41 <ski> @type foldr
20:44:42 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:44:44 <ski> vs.
20:44:53 <t4nk356> ski: well if it's not related then it has to be fixed constant. is there a third option (for lists)?
20:45:01 <ski>   para :: (a -> [a] -> b -> b) -> b -> [a] -> b
20:45:12 <ski>   para f z [    ] = z
20:45:26 <ski>   para f z (x:xs) = f x xs (para f z xs)
20:46:08 <ski> dagano : the difference is that with `para', `f' also gets to see `xs' directly, while with `foldr', it only gets to see the "recursive result on `xs'"
20:47:17 <ski> dagano : to simulate `para' with `foldr', you must "traverse all to the end" (though not actually, because laziness), and copy the `xs' in the result, so you can pass it to `f' (you really have to do this)
20:47:28 <ski> dagano : needless to say, while this works, it is inefficient
20:48:00 <ski> dagano : in your `break' example, you wanted to get a hold of the tail `"def zyx"' -- preferably *without* having to copy it
20:48:10 <dagano> right
20:48:11 <ski> hence `para' rather than `foldr' (which still would work)
20:48:38 <ski> of course .. you could just implement `break' yourself with recursion, as well
20:49:10 <dagano> ski: amazing little tutorial, thank you. i have a few things to look into
20:50:03 <ski> dagano : btw, the corresponding thing to paramorphisms for `unfoldr' is apomorphisms
20:50:13 <td123> hey all, this is more of a general programming question, but, I have a bunch of events in a database and I would like to run a function whenever the current time matches the time in one of the rows
20:50:17 <ski> with `unfoldr', you generate one more level of the list at a time
20:50:30 <td123> how would you recommend I approach this problem?
20:50:43 <t4nk356> ski: so i have to go. i'll look over what you said and think about it. is there any resource that would prove helpful for me?
20:50:52 <td123> I've thought about using cron for every event, but that doesn't seem scalable
20:50:52 <ski> with `apo', you get the option of providing the whole rest of the list at one go, without having to step through it, copying it
20:51:03 <ski> t4nk356 : the link above
20:51:59 <t4nk356> ski: on recursion schemes?
20:52:05 <ski> yes
20:52:19 <t4nk356> gotcha thanks
20:57:51 <ddere> is something wrong with hackage? site doesnt seem responsive?
20:58:04 <johnw> works fine here
20:58:25 <ddere> hmm ok thanks
21:05:36 <alang> ddere: i'm having problems with it as well
21:05:54 <ddere> alang: yeah its coming and going for me
21:13:26 <jle`> mm_freak: so how bad and un-frp/un-haskell/un-functional programming is unique identifiers, anyway?
21:13:43 <jle`> having an underlying state monad that pulls out a unique id for all of my things
21:13:56 <jle`> i have been using various forms of zipping for this past month
21:14:10 <jle`> and i have felt much excitement and exhilaration getting it to work
21:15:29 <jle`> but when people ask me, i can't say exactly why other than 'it feels un-functional', and i can't explain it
21:15:47 <jle`> and sometimes things get really tricky with the wire-zipping style and i have moment when i think about hwo much easier it would be to just have everything have a unique ID
21:15:57 <jle`> and i question everything i hav ever done
21:16:06 <jle`> :(
21:17:39 <johnw> i really don't know how to evaluate that, jle`, without more context
21:19:55 <jle`> johnw: oh, sorry. perhaps rambled to much.
21:20:04 <jle`> um this is regarding netwire and other afrp
21:20:27 <jle`> there are a couple of ways to manage dynamic collections of wires that can receive events
21:21:14 <jle`> one way is to basically maintain a list of wires as a collection and take in a list of events
21:21:23 <jle`> and pair each event in the list with the corresponding wire
21:21:34 <jle`> so the first event stream in the incoming list goes to the first wire
21:21:36 <jle`> etc.
21:21:54 <Ralith> bjz: I've got time to resume our earlier conversation now, if you like
21:22:07 <jle`> another way that i saw with yampa etc. is assigning each wire a unique id
21:22:18 <jle`> and having a single incoming event stream to the container
21:22:32 <jle`> and the container routes the incoming events to the wire with the corresponding id
21:22:40 <jle`> each event being tagged with a destination id
21:22:56 <jle`> in both of these cases wires are removed from the dynamic list when they inhibit
21:24:24 <jle`> and i've heard from a several people and feel some weird intuition that the latter method is sort of un-frp/un-functional
21:25:00 <jle`> i guess in a way it's a lot like pointer equality in imperative progrmaming
21:25:38 <jle`> and it feels slightly less composable
21:25:54 <jle`> and there is the issue of not involving a globally incrementing id if you don't need to involve state
21:25:57 <johnw> I don't see why using UUIDs is "unfunctional", unless you're using them along with some kind of mutation
21:26:09 <jle`> yeah...
21:26:10 <johnw> but then, I'm not the best determinant of what is "functional"
21:26:16 <jle`> when asked to justify how i feel
21:26:19 <jle`> i don't have any answers
21:26:23 <jle`> i can only say 'people have said so'
21:26:29 <enthropy> you can make "feels less composable" a bit more concrete, if you have examples where A+B works but A'+B' doesn't
21:26:59 <jle`> the zipping method has a large drawback where you can not ever have anything deal with a subset of the container
21:27:11 <jle`> so if i wanted something to only deal with, say, every third item
21:27:39 <jle`> i'd still have to pass the *entire* container output (a list of all of the wire outputs), filter it myself, and then pop out the list of event streams
21:27:42 <jle`> for the entire container
21:27:48 <enthropy> then do the equivalent of zipWith3 f (cycle [True, False,False])?
21:28:05 <jle`> enthropy: well i want to be able to pass an arbitrary subset to another wire
21:28:18 <jle`> which will only care about...maybe only wires that satisfy a certain predicate
21:28:33 <jle`> well for a more concrete example
21:28:48 <jle`> say the wires are a list of units in an rts
21:28:57 <jle`> which can accept 'hit' events
21:29:07 * hackagebot time-exts 2.0.0 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-2.0.0 (EnzoHaussecker)
21:29:20 <jle`> so if i have a unit that wants to send a hit event to another unit
21:29:29 <jle`> i'd have to pass into it a list of all enemy units
21:30:01 <jle`> and so then it can output a list of event streams...and have a 'hit' on say the nth event stream, if it wants to hit the nth unit
21:30:24 <jle`> but i can't ever pass to it, say, an arbitrary subset of the list of enemy units
21:31:07 <jle`> because then the list of event streams that it outputs won't 'line up' with the container zipping up 'hit' events to their corresponding rts units
21:31:51 <jle`> i could possibly circumvent it by having some sort of routing mechanism, between the thing that determines the subset of the units to pass to the unit...that is aware of what it passed in, and interprets the stream received from the unit int aht context and re-expand it
21:32:00 <jle`> but at this point...why not just use unique identifiers?
21:32:19 <johnw> i say do it
21:32:22 <jle`> yet everywhere i read seems to say that this is something to avoid if i could
21:32:26 <johnw> ah
21:32:31 <jle`> well
21:32:36 <jle`> by everywhere i mean a couple of places
21:32:38 <jle`> haha
21:32:46 <jle`> because admittedly there isn't much literature about this
21:32:58 <jle`> but the only place i have seen it done thsi way is in the yampa paper from a decade or so back
21:35:59 <jle`> the state actaully wouldn't even have to be global and i wouldn't have to transform a state monad
21:36:07 <jle`> it could be managed by the wire container itself actually
21:39:37 <jle`> i am hesitant to switch also becuase i have already invested so much time into making it work, heh
21:40:51 <startling> jle`, sunk cost
21:42:00 <jle`> startling: ah. true
21:42:35 <startling> might as well make a git branch and see if you can make it mostly work. :)
21:43:13 <jle`> startling: i'll try it out :) actually i think i can maybe even use both of them
21:43:21 <jle`> for different situations
21:43:28 <startling> heh
21:43:31 <jle`> but i just wanted to hear from someone who has been doing a lot of frp
21:43:36 <jle`> what people have done in the past
21:43:57 <jle`> or if what i am doing might be an anti-pattern
21:45:19 <startling> sure, makes sense.
21:46:22 <jle`> ah, starting to implement it now i see a problem
21:46:38 <jle`> it works well for events but it doesn't necessarily work well for continuous streams
21:46:44 <jle`> and i still need parallel behavior streams in any case.
21:47:15 <jle`> but i could fuse the two and have them side by side.  but this is a problem i did not have in the zip variant
22:10:36 <ghostwalker> when I compile the program at http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/docs/Database-HDBC-MySQL.html it gives me an error main.hs:13:22: parse error on input `->'. What should I do to resolve this?
22:11:56 <lispy> ghostwalker: looks like a valid complaint from the compiler.
22:12:09 <ghostwalker> lispy: why so?
22:12:35 <lispy> ghostwalker: I don't know what they meant with that last line, but it's definitely wrong
22:12:56 <lispy> oh
22:13:01 <ghostwalker> lispy: hmmm.. any work around for it?
22:13:06 <lispy> forM_ rows $ \row -> putStrLn $ show row
22:13:45 <lispy> http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/docs/src/Database-HDBC-MySQL.html
22:13:57 <lispy> the source version of it has the \ for the lamda
22:14:00 <lispy> lambda*
22:14:21 <pavonia> haddock seems to eat backslashes in code blocks lately, someone complained about that here before
22:14:44 <lispy> ghostwalker: I hope that helps
22:15:20 <ghostwalker> lispy: it does!
22:15:39 <ghostwalker> lispy: it might be a silly question, but how did you get to that source? ;\
22:15:57 <lispy> ghostwalker: I followed a link in the top right corner of the page
22:16:24 <ghostwalker> lispy: found it! Thanks!
22:19:03 <ghostwalker> main: user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking)) what is this error supposed to mean?
22:19:28 <ghostwalker> the program works when I pass ghc main.hs -threaded
22:19:53 <shachaf> It means what it says.
22:20:17 <shachaf> And you've figured out how to solve it, too, it looks like.
22:20:19 <shachaf> What's the question?
22:20:31 <lispy> the run-time system has a single threaded version and a multithreaded version.
22:20:48 <lispy> when you specify -threaded you get the multithreaded version
22:20:49 <ghostwalker> I was using this code http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/docs/Database-HDBC-MySQL.html#v:defaultMySQLConnectInfo and I wanted to know where I am spawning multiple threads
22:20:50 <johnw> i can't even remember the last time I use the single threaded version... I keep forgetting it exists
22:21:46 <lispy> ghostwalker: presumably HDBC-mysql is using threading on your behalf.
22:22:43 <ghostwalker> lispy: ah! thanks!
22:22:45 <shachaf> Spawning multiple threads isn't an issue. Only multiple OS threads is an issue.
22:23:47 <lispy> shachaf: I guess the single threaded rts doesn't have the same preemption?
22:24:03 <shachaf> ?
22:24:38 <lispy> When you use haskell threads in the single threaded RTS, IIRC they only get swapped out of execution at certain events like allocations
22:25:06 <lispy> I never do any threading in Haskell, so I don't really know how it works.
22:25:08 <shachaf> Also true in the threaded RTS.
22:25:19 <shachaf> Maybe this error is related to bound threads. I don't know.
22:25:37 <lispy> Maybe they use the wrong type of ffi?
22:25:52 <lispy> unsafe is related to threading in some way, IIRC
22:26:41 <johnw> unsafe just means that the ffi code should not call back into Haskell
22:27:30 <johnw> "An unsafe call blocks the capability in addition to blocking the OS and Haskell threads."
22:27:32 <johnw> from http://blog.melding-monads.com/2011/10/24/concurrency-and-foreign-functions-in-the-glasgow-haskell-compiler/
22:27:42 <lispy> johnw: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
22:27:54 <johnw> thanks, will read
22:28:29 <shachaf> "unsafe" means multiple things and you should be careful when you use it.
22:28:56 <shachaf> In particular it's commonf or people to say "unsafe just means X, and I don't care about X, so I can use unsafe", and then it turns out it also means Y and their code is broken.
22:29:11 <shachaf> Default to safe, switch to unsafe only if you know what you're doing.
22:33:29 <lispy> ah, forkOS == create bound thread
22:33:35 <johnw> yes
22:33:49 <johnw> shachaf: is there a Y beyond "unsafe blocks the capability"?
22:33:55 <lispy> I never knew what OS meant there after learning it's not an OS thread
22:34:12 <johnw> lispy: also, the main thread is always a bound thread
22:34:17 <shachaf> johnw: I don't remember.
22:34:59 <shachaf> I used to know all about this. Now I don't remember except that it's more complicated than people usually think.
22:35:02 <enthropy> where is the normal place to get instance (Num a, Num b) => Num (a,b)?
22:35:17 <johnw> shachaf: I agree it's reasonable to be very cautious in these matters
22:35:26 <shachaf> Blocking the capability is surely a bigger deal than not being able to call back into Haskell.
22:35:53 <johnw> in fact, every time I've ever used anything in Haskell where the word "unsafe" was involved, I've ended up spending hours hunting bugs a month later that had very subtle behaviors I wasn't expecting
22:36:49 <johnw> I still use ByteString's unsafeUseAsCString from time to time, but I have to be extremely careful with it
22:36:52 <lispy> and it's unsafe city in that source: http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/src/Database/HDBC/MySQL/RTS.hsc
22:37:13 <lispy> here too: http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/src/Database/HDBC/MySQL/Connection.hsc
22:37:29 <lispy> Someone should send them some patches
22:38:31 <lispy> Oh
22:38:32 <lispy> The @mysqlclient@ C library does not correctly restart
22:38:32 <lispy> -- system calls if they are interrupted by signals, so many MySQL API
22:38:32 <lispy> -- calls can unexpectedly fail when called from a Haskell application.
22:38:42 <lispy> Charming
22:38:43 <startling> enthropy, I wish I knew.
22:39:07 <enthropy> turns out gloss provides one
22:39:14 <startling> ugh.
22:42:49 <riceandbeans> can someone explain to me why functional coding exists
22:43:06 <riceandbeans> I swear I'm not trying to be a troll, I just look at functional code and it makes absolutely no sense to me
22:43:18 <riceandbeans> even hello world on wikipedia makes me scratch my head
22:43:31 <riceandbeans> I want to get it
22:43:53 <startling> riceandbeans, programming is harder than it should be
22:44:15 <shachaf> I don't know what functional coding is so I can't tell you much about it.
22:44:16 <startling> riceandbeans: a lot of people think functional programming has the capacity to make it easier.
22:44:26 <shachaf> But I know things about Haskell.
22:44:49 <startling> riceandbeans: I'm sort of wondering what code you're seeing that makes you scratch your head, though.
22:45:05 <shachaf> For example, hello world.
22:45:05 <riceandbeans> startling: anything I've looked at
22:45:08 <startling> often people try to use "functional style" in languages that weren't built for it with, uh, mixed results
22:45:23 <riceandbeans> the worst I've seen has been like...project euler in functional code
22:45:25 <startling> riceandbeans: what confuses you about 'putStrLn "hello world"'
22:45:44 <startling> well, 'main = putStrLn "hello world"'
22:46:26 <riceandbeans> module Main where
22:46:26 <riceandbeans> main :: IO ()
22:46:27 <riceandbeans> main = putStrLn "Hello, World!"
22:46:52 <startling> riceandbeans: ok! what part confuses you?
22:47:28 <riceandbeans> what's up with where? main :: IO? setting main = to what seems like a simple function
22:48:07 <johnw> note that none of these has anything to do with "functional programming"
22:48:13 <startling> riceandbeans, "main :: IO ()" says "main is an action that does IO and doesn't return anything we care about".
22:48:14 <johnw> it's just Haskell's syntax
22:48:49 <startling> riceandbeans, yeah, 'main = putStrLn "..."' is just a simple declaration.
22:48:49 <lispy> shachaf, johnw: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#v:forkOS
22:49:04 <shachaf> Yes, I know what a bound thread is.
22:49:18 * hackagebot tiempo 0.0.0.0 - Specify time intervals in different units (secs, mins, hours, etc.)  http://hackage.haskell.org/package/tiempo-0.0.0.0 (RomanGonzalez)
22:49:24 <shachaf> That's why I brought it up. :-)
22:49:24 <lispy> shachaf: I never said otherwise
22:49:30 <lispy> "To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the -threaded option when linking your program, and to make sure the foreign import is not marked unsafe.To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the -threaded option when linking your program, and to make sure the foreign import is not marked unsafe."
22:49:37 <lispy> gah, double paste
22:49:53 <riceandbeans> startling: any when I think, hey I should learn functional code, I get caught up in, what do I look at?
22:49:56 <riceandbeans> I mean
22:50:08 <lispy> So did the blocking behavior of unsafe change since ezyang's article?
22:50:21 <startling> riceandbeans, Haskell does a lot of things outside of "functional", so I can't really answer your question.
22:50:21 <riceandbeans> scala, haskell, ML, OCAML, LISP, Erlang, god knows what else
22:50:28 <johnw> riceandbeans: I would start with a text like Learn You a Haskell
22:50:31 <startling> riceandbeans: but if you want to learn Haskell, LYAH is ok.
22:50:32 <riceandbeans> I don't know where to begin
22:50:33 <startling> @where lyah
22:50:33 <lambdabot> http://www.learnyouahaskell.com/
22:50:36 <startling> ^
22:50:47 <johnw> thank goodness that book exists
22:51:03 <riceandbeans> and then with haskell there's different interpreters or something?
22:51:12 <johnw> just use GHC
22:51:12 <riceandbeans> with glasgow being the most common
22:51:16 <startling> riceandbeans, the only one anyone uses is GHC
22:51:41 <johnw> startling: I know companies that rely on their own in-house Haskell compiler
22:51:43 <shachaf> Did it? Why?
22:51:44 <levi> Well, it's definitely by far the most-used.
22:51:54 <levi> But not the only one.
22:52:02 <startling> johnw, wow, that's odd.
22:52:09 <riceandbeans> and it generates machine code
22:52:12 <riceandbeans> right?
22:52:15 <startling> anyway, rephrased: you should use GHC for learning.
22:52:16 <riceandbeans> not bytecode
22:52:23 <startling> riceandbeans, sure.
22:52:29 <riceandbeans> not interpreted anything
22:52:32 <shachaf> GHC can generate lots of things
22:52:43 <lispy> ghostwalker: I figured out why that program needs the threaded flag
22:52:45 <startling> riceandbeans: (it can also interpret things, but it's typical to compile things)
22:52:49 <shachaf> Including byte code which is interpreted and native machine code.
22:52:50 <levi> startling: Not all that odd, really.
22:52:54 <lispy> ghostwalker: it calls runInBoundThread
22:53:04 <lispy> ghostwalker: and that function fails on the non-threaded rts
22:53:40 <startling> levi, it surprises me. Maybe I don't know enough about haskell in industry
22:53:53 <riceandbeans> not that I want to start a flame war or anything but objectively, how is haskell different from some of the others
22:53:53 <lispy> ghostwalker: if you wanted to use the example with the non-threaded rts you would remove the call to withRTSSignalsBlocked
22:53:59 <riceandbeans> like say, erlang or lisp
22:54:16 <startling> riceandbeans: haskell has a very rich static type system and is pure.
22:54:24 <riceandbeans> what is pure?
22:54:35 <ghostwalker> lispy: I don't think there is an advantage to having in non-threaded is there?
22:54:39 <lispy> ghostwalker: it's not clear to me whether that would then cause you to have problems with rts signals (the comments make me think rts signals are only a problem when you're using the threaded rts)
22:55:05 <lispy> ghostwalker: Oh uh. Probably not. I was still wondering about your question of "why threaded?"
22:55:14 <startling> riceandbeans, evaluation may not have any side-effects (e.g. mutating a global variable) unless the type of the value is specifically marked.
22:55:34 <johnw> startling: even then evaluation does not :)
22:55:53 <levi> riceandbeans: Haskell is different in several ways from Erlang and Lisp.  First would be that Haskell has a static type system. Second would be that it does not allow side-effects; functions are more closely related to the mathematical ideal of a function than in most languages. And finally, it has a very different approach to evaluating expressions in the language than any other commonly used language.
22:55:59 <johnw> I think instead of saying "pure", we should say "effects are explicitly indicated by the type system"
22:56:03 <startling> johnw: what would you call the other thing?
22:56:14 <carter> lispy: another difference is i'm here :)
22:56:27 <johnw> startling: execution
22:56:34 <startling> johnw: ah, that makes sense.
22:56:36 <lispy> carter: huh?
22:56:45 <carter> i mean levi
22:56:47 <carter> sorry
22:56:50 <lispy> ah
22:56:54 <startling> riceandbeans, execution may not have any side-effects (e.g. mutating a global variable) unless the type of the value being executed is specifically marked.
22:57:10 <levi> carter: huh?
22:57:33 <carter> levi: i'm involved in helping haskell, not lisp or erlang :
22:57:34 <carter> :)
22:57:39 <carter> (thoug those are nice tools too)
22:57:39 <riceandbeans> startling: no offense, but I didn't really understand that
22:57:53 <riceandbeans> maybe that's a sign haskell isn't for me, hah
22:58:15 <startling> riceandbeans, I'm not sure that's true.
22:58:16 <levi> riceandbeans: Not necessarily; it just means there's lots of interesting things to learn about it.
22:58:28 <riceandbeans> how about this, of the functional languages, is haskell the most common? haskell?
22:58:30 <lispy> johnw: I don't think your comment about pure vs. effects is right. The language is pure and but we don't have effects built into the type system.
22:58:39 <startling> riceandbeans: probably not.
22:58:39 <carter> riceandbeans: i get paid to do cool stuff in haskell
22:58:46 <lispy> johnw: It's true that we can encode some effects into types, but that seems different.
22:58:58 <johnw> lispy: true
22:58:59 <riceandbeans> I get paid to be a sysadmin
22:59:05 <carter> cool!
22:59:13 <riceandbeans> but I want to move to the dev side
22:59:16 <carter> well
22:59:20 <johnw> lispy: maybe then all I mean is that effects are impossible unless IO is explicitly involved?
22:59:33 <lispy> that's not true either :)
22:59:34 <carter> theres a nice opportunity for haskell ops tools that are nice
22:59:35 <levi> riceandbeans: I think Haskell takes the idea of functional programming more seriously than most functional languages.  If you want to understand the essence of functional programming, Haskell is a good language to learn.
22:59:44 <lispy> johnw: You can have other notions of effect
23:00:09 <lispy> johnw: eg., IO is sufficient but not necessary
23:00:10 <carter> riceandbeans: haskell is one of only two major compiled languages which have Static binary build as  default
23:00:12 <johnw> startling: evaluation yields an action that is executed; execution always has some side-effect, otherwise there is no reason to do it
23:00:14 <levi> carter: I ran across a github repository of a guy doing a bunch of cloud service deployment/management tools in haskell as a startup.
23:00:21 <riceandbeans> levi: not that I'm GOING to do this, but is it POSSIBLE, to write an OS in Haskell?
23:00:34 <milfjord> in theory, yes
23:00:35 <johnw> lispy: that is true too; I think I'm too tired to offer the precision needed for this discussion
23:00:41 <lispy> johnw: we have a pure language with controlled effects?
23:00:47 <johnw> I like that
23:00:49 <riceandbeans> why would you want static linking by default?
23:00:55 <carter> riceandbeans: well,
23:00:58 <riceandbeans> your binaries would be huge
23:01:03 <levi> riceandbeans: There have been a couple of research projects to that effect, and a Japanese group has been experimenting with device drivers in Haskell.
23:01:11 <johnw> riceandbeans: yeah, but an executable which works would probably continue working :)
23:01:12 <carter> riceandbeans: because you want to deploy to many servers
23:01:13 <lispy> johnw: oh, it's my bed time I just realized.
23:01:23 * lispy waves and runs to bed
23:02:45 <carter> riceandbeans: in modern systems. is a 10mb binary or whatever really your bottle neck?
23:02:55 <carter> or 100mb evn
23:02:56 <carter> heck
23:03:18 <riceandbeans> carter: passing around a 2MB binary vs 100MB binary is a big difference to me
23:03:24 <carter> for servers?
23:03:40 <riceandbeans> but I guess glibc is more common than whatever haskell has
23:03:50 <riceandbeans> glibhaskell or something
23:03:52 <carter> riceandbeans: you can do dylinking too
23:03:53 <carter> nah
23:03:54 <riceandbeans> for those that are dynamic
23:04:03 <carter> all the core haskell stuff is BSD licensed
23:04:12 <riceandbeans> all the better
23:04:14 <carter> riceandbeans: do you like network stuff/
23:04:18 <levi> There are ways to trim down the binary size of Haskell programs, but I don't think most people do.
23:04:22 <carter> yeah
23:04:24 <riceandbeans> I do but I'm not so awesome with it
23:04:28 <milfjord> I've got a couple of haskell executables lying around here. they're between 900K and 3.5M
23:04:36 <carter> riceandbeans: well, lemme show you a cool paper
23:05:19 <riceandbeans> what about memory and performance in comparison to something in C or Go or Java?
23:05:24 <riceandbeans> out of curiousity
23:05:28 <carter> riceandbeans: lemme answer your question indirrectly
23:05:38 <milfjord> riceandbeans: it all depends
23:05:58 <carter> riceandbeans: i am writing haskell tools for numerical computing
23:06:03 <carter> ok
23:06:09 <milfjord> it's possible to optimize some code to run faster than C stuff
23:06:19 <johnw> the haskell program I use most is 9.9M
23:06:25 <milfjord> xmonad?
23:06:35 <riceandbeans> I never could get xmonad to work
23:06:38 <johnw> if I "strip" it, it goes down to 5.7M
23:06:44 <johnw> milfjord: no, it's a private binary
23:06:50 <riceandbeans> I like openbox a lot
23:07:45 <milfjord> ghc itself is 17M here
23:08:56 <riceandbeans> hah
23:09:09 <riceandbeans> learn you a haskell looks reminiscent of why's poignant guide to ruby
23:09:22 <carter> fact
23:09:27 <carter> i think its so
23:09:35 <carter> riceandbeans: soo
23:09:41 <carter> a key thing with *good* haskell libraries
23:09:52 <carter> is you should *actually* be able to write code in a pretty direct style
23:09:57 <carter> thats *high level*
23:10:07 <carter> and with a bit of practice
23:10:08 <milfjord> why are
23:10:11 <milfjord> you hitting
23:10:13 <milfjord> enter so much
23:10:16 <carter> milfjord :P
23:10:49 <johnw> that's just carter's style
23:10:50 <carter>  you should be able to get pleasantlly high level and pleasantly fast code
23:11:40 <carter> riceandbeans: i'm writing libs where the end goal is to defeat /match fortran libs that have hundreds of man years of work in them
23:11:47 <carter> wrt performance
23:11:51 <carter> but being much more high level
23:12:26 <carter> where the goal is i want the end users to just feel like they're writing math
23:12:28 <riceandbeans> wait wait wait
23:12:33 <carter> instead of tattooing themselvs with a pen
23:12:35 <johnw> i wonder if there's any library or application in the world with 1,000 man years of work in it
23:12:35 <riceandbeans> I can only set a variable once?
23:12:39 <carter> sure
23:12:42 <carter> lets
23:12:44 <carter> well
23:12:48 <riceandbeans> what kind of crap is that?
23:12:49 <carter> "set" meaning?
23:12:50 <carter> ohh
23:12:53 <johnw> riceandbeans: you don't "set a variable"
23:13:12 <milfjord> riceandbeans: math crap
23:13:21 <carter> milfjord: :p
23:13:21 <riceandbeans> variables are variables because they're not constants, if I want a constants I make constants
23:13:21 <milfjord> x = x + 1 isn't a sane equation in math
23:13:22 <johnw> riceandbeans: variables in Haskell are like mathematical variables: they are names for things, not symbols representing memory storage locations
23:13:24 <levi> johnw: Sure, lots of them.
23:13:34 <carter> riceandbeans: i can show you some very imperative haskell code i fyou want
23:13:40 <milfjord> riceandbeans: no, variables are things like function arguments: f(x) = 2*x
23:13:43 <carter> yeah
23:13:45 <milfjord> x isn't a constant there
23:13:49 <milfjord> but you can't modify it either
23:14:07 <carter> riceandbeans: we understand we're throwing a lot of ideas at you at once,
23:14:11 <riceandbeans> all variables are immutable...
23:14:23 <milfjord> that's what it means to be pure
23:14:24 <carter> riceandbeans: BUT, a varaible can refer to a mutable thing
23:14:31 <carter> like a reference or pointer
23:15:03 <levi> riceandbeans: Variables being mutable is really the odd thing. Most languages use the term variable for something that's very much not like a variable.
23:15:04 <jle`> yeah, 'variables' in haskell are not like constants or variables in other languages
23:15:14 <jle`> they are like neither
23:15:40 <jle`> so trying to understand them in the same mold will get you in trouble
23:15:42 <riceandbeans> when I read 'variable' I think, the data can 'vary' you initialize it, but give what goes in in the code, it changes
23:15:55 <milfjord> your intuition doesn't apply here
23:15:56 <levi> riceandbeans: Pretend, for a moment, that you'd never seen a programming language before, and you just walked out of your high school algebra class.
23:16:01 <milfjord> you'll have to unlearn a thing or two
23:16:05 <carter> f(x)=sin(x)
23:16:12 <johnw> riceandbeans: yeah, I used to understand "variable" to mean "data that can vary" too
23:16:15 <jle`> "let x = 4 in sin(x)"
23:16:20 <jle`> no sense of immutable or mutable there
23:16:24 <jle`> x is just 'defined' as 4
23:16:25 <mstefanko> are you guys talking about the wolfram programming language
23:16:27 <shachaf> When I read "variable", I think of a type of star.
23:16:30 <carter> mstefanko: nah
23:16:33 <shachaf> But that doesn't help me learn Haskell.
23:16:39 <milfjord> > let x = 4 in sin(x)
23:16:40 <lambdabot>  -0.7568024953079282
23:16:43 <carter> shachaf: you're a kind star
23:16:53 <mstefanko> it's a nice logic layer http://www.youtube.com/watch?v=_P9HqHVPeik
23:17:09 <carter> mstefanko:  ehhhh, i'm writing numerical haskell so people don't have to use mathematica :)
23:17:21 <mstefanko> i like the part where it will try to guess your meaning and create a formula from 'show all flags for south american countries'
23:17:34 <jle`> if i went to a math class and said 'let x = 5 in sin(x), x = x + 1, sin(x)', they'd tell you you were crazy
23:17:51 <mstefanko> and that you can leave variables like x intact
23:17:51 <jle`> actually you can think of haskell evaluation in a lot of sense as straight up lexical substitution
23:18:03 <mstefanko> i wonder what they use as underlying layer
23:18:09 <jle`> when i say let x = 5 in sin (x), i literally mean 'replace every occurence of x with 5'
23:18:37 <jle`> when i say 'let f x = x + 1 in f 6', i mean "replace every occurence of f x with x + 1"
23:18:45 <jle`> which turns f 6 into 6 + 1
23:18:59 <jle`> almost like a fancy find-and-replace
23:19:04 <milfjord> > let x = error "zomg" in length [x, x, x]
23:19:05 <lambdabot>  3
23:19:33 <jle`> so x, and f here aren't variables in the traidtional imperative sense
23:20:13 <riceandbeans> jle`: so haskell == sed
23:20:20 <jle`> not quite
23:20:23 <jle`> heh
23:20:28 <jle`> but it does illustrate what we mean by 'defining' a variable
23:20:35 <carter> riceandbeans:  https://www.dropbox.com/s/epzpbrozg99dcn4/Mio-%20A%20High-Performance%20Multicore%20IO%20Manager%20for%20GHC%20hask035-voellmy.pdf
23:20:37 <jle`> if i say x = 4
23:20:42 <jle`> i mean, everywhere you see x, replace it with 4
23:20:55 <carter> riceandbeans: haskell has thread scalling thats more epic than erlangs in some ways
23:20:56 <jle`> (everywhere where that definition is in scope)
23:21:03 <carter> though the distributed comput tooling isn't as  mature yet
23:21:12 <riceandbeans> right, sed -ie 's/x/4/g'
23:21:14 <carter> though i'm hopeing to help push it far enough to kill hadopop
23:21:26 <carter> or at least make hadoop run for its money
23:21:47 <jle`> riceandbeans: yeah, and there are things with scoping and where that deifnition applies
23:21:55 <carter> riceandbeans: also the compilers nice
23:21:56 <mstefanko> jle` it sounds like you're making the distinction between variables and functions?
23:21:59 <carter> i know, i hope work on it
23:22:06 <jle`> also, type system
23:22:06 <riceandbeans> so you guys are more BSD guys on average?
23:22:13 <carter> BSD license?
23:22:14 <johnw> why would you think that?
23:22:16 <carter> i'm on  mac
23:22:18 <riceandbeans> because BSD license
23:22:27 <carter> nah, most folks use linux
23:22:34 <riceandbeans> meh
23:22:34 <carter> though i hear nice things abou bsd
23:22:55 <riceandbeans> I'm moving away from linux because of the way things are going with it's future right now, moving my stuff to BSD
23:23:01 <carter> cool
23:23:02 <milfjord> mstefanko: category error
23:23:06 <riceandbeans> but anyway
23:23:06 <johnw> FreeBSD?
23:23:15 <riceandbeans> johnw: DragonFlyBSD
23:23:19 <carter> ooo
23:23:27 <mstefanko> milfjord sorry what?
23:23:27 <carter> did they ever finish Hammer2FS?
23:23:46 <riceandbeans> not yet, they're making a lot of progress but hammer2 isn't ready for prime time yet
23:23:56 <riceandbeans> it's still beta
23:23:57 <milfjord> mstefanko: that's like comparing variables and strings
23:24:05 <milfjord> or variables and ints
23:24:12 <carter> hammer2 seems like the next zfs
23:24:14 <carter> or am i wrong
23:24:19 <carter> been 2 years since i last read up on it
23:24:30 <mstefanko> milfjord well using x=5 to replace all x with 5, that's a variable, and using x=x+1 that's a function
23:24:55 <riceandbeans> well, I'm using hammer right now and I like it, I wouldn't mind using it instead of zfs but there are some things they do differently
23:25:15 <ion> mstefanko: Are we talking about Haskell?
23:25:27 <riceandbeans> but they have a good strong community and really interesting concepts, and those two things can really make or break an open source group
23:25:38 <riceandbeans> guess that could be good for haskell too
23:25:40 <ion> Not that ‚Äúx = x + 1‚Äù is a function in most other languages either.
23:25:54 <mstefanko> i'm just commenting on jle`'s comments above
23:25:58 <mstefanko> how would you call it ion?
23:26:04 <milfjord> mstefanko: I don't see x=x+1 there
23:26:16 <carter> riceandbeans: it'd be great to have more people use hakell on *BSD
23:26:21 <ion> Assignment in some languages, definition in Haskell.
23:26:34 <mstefanko> <jle`> when i say 'let f x = x + 1 in f 6', i mean "replace every occurence of f x with x + 1"
23:26:35 <mstefanko> <jle`> which turns f 6 into 6 + 1
23:26:38 <mstefanko> ah, f
23:26:51 <mstefanko> f(x){return x+1}
23:26:59 <mstefanko> ok i see the syntax, i'm not familiar with haskell syntax yet
23:27:10 <milfjord> f x = x + 1 is just syntactic sugar for f = \x -> x + 1
23:27:16 <milfjord> i.e. f is the variable being defined here
23:27:18 <riceandbeans> holy crap
23:27:31 <carter> ?
23:27:40 <riceandbeans> dfly# pkg install ghc
23:27:40 <riceandbeans> Updating repository catalogue
23:27:40 <riceandbeans> The following 1 packages will be installed:
23:27:40 <riceandbeans> Installing ghc: 7.6.3_2 [Avalon]
23:27:40 <riceandbeans> The installation will require 867 MB more space
23:27:43 <riceandbeans> 75 MB to be downloaded
23:27:45 <riceandbeans> Proceed with installing packages [y/N]: n
23:27:53 <mstefanko> so f is still a variable? isn't it a function?
23:27:55 <milfjord> yeah, tons of libraries and stuff
23:28:04 <riceandbeans> almost 1GB to install A package
23:28:09 <riceandbeans> I've never seen that before
23:28:11 <milfjord> mstefanko: "i = 42 - so i is still a variable? isn't it an int?"
23:28:31 <milfjord> functions are *values*
23:28:46 <carter> riceandbeans: nah, thats a few different tools
23:28:48 <milfjord> > (\x -> x + 1) 41
23:28:49 <carter> its the compiler
23:28:49 <lambdabot>  42
23:29:02 <carter> + several cli apps that ghc uses / you'll use
23:29:04 <milfjord> > (\y -> y 41) (\x -> x + 1)
23:29:05 <lambdabot>  42
23:29:16 <carter> and a bunch of basic libdraries
23:29:23 <carter> riceandbeans: how big a machine are you on?
23:29:33 <mstefanko> what does the slash in the syntax mean?
23:29:42 <milfjord> it's a backslash
23:29:48 <milfjord> it means "this is a function"
23:29:54 <milfjord> \ PARAMETER -> BODY
23:29:57 <mstefanko> ah, gotcha
23:30:08 <carter> like the python  lambda x : fooo x
23:30:14 <carter> but much better
23:30:14 <carter> :)
23:30:16 <mstefanko> anonymous function, ok nice
23:30:28 <milfjord> yeah, just like 1 is an anonymous number
23:30:33 <johnw> riceandbeans: if you are learning Haskell to learn something new, why is it surprising that some things seem unfamiliar?  It seems like you're expecting Haskell to behave more like what you already know, and in that case, why learn it?
23:30:49 <carter> riceandbeans: if you wanna ask someone who has done lots of systemsy hacking and ops work about haskell, ask computionist on #nothaskell
23:31:07 <carter> (he's still learning it too, but he may have a perspective you can relate to)
23:33:00 <carter> ( #nothaskell is less official, though still haskelly)
23:36:54 <riceandbeans> carter: a thinkpad with an i7 and 16GB RAM
23:37:08 <riceandbeans> running with openbox
23:37:19 <carter> okk
23:37:20 <carter> nice :)
23:37:23 <carter> i'm envious
23:37:35 <riceandbeans> it's my work laptop
23:37:40 <riceandbeans> company owns it
23:38:10 <carter> k
23:38:19 <riceandbeans> my home system has a failing drive, 4GB RAM, and two slow processors
23:38:21 <riceandbeans> :)
23:38:27 <carter> empathies
23:38:34 <carter> so, you deal a lot with infrastructure issues right?
23:39:00 <riceandbeans> honestly, my main focus at the moment is automation
23:39:16 <carter> fair
23:39:17 <riceandbeans> building out their configuration management, patch management, and vm lifecycle
23:39:31 <carter> and to have that work well
23:39:36 <carter> you need to make sure all the parts fit
23:39:41 <carter> and can coord correctly
23:39:43 <carter> etc right?
23:39:47 <riceandbeans> mixture of spacewalk, puppet, foreman, some other kludges I did
23:39:51 <carter> sure
23:40:14 <riceandbeans> some DB app I wrote in perl for cleaning up and tracking attacks on the perimeter
23:40:28 <carter> point being, its composing a system where the better you can be sure that the tools are work correctly, the happier you ar right?
23:40:30 <riceandbeans> owning the MX server...
23:40:37 <riceandbeans> yeah
23:40:56 <carter> and usually you're happier with the end result if you've been able to plan out that
23:41:06 <riceandbeans> yeah
23:41:15 <carter> and have ways of sanity checking that things fit together and "do what they claim"
23:41:25 <carter> without having to "run a second copy of production"
23:41:27 <riceandbeans> I usually chart out what I'm doing in stuff like Dia before I code
23:41:51 <carter> ok
23:41:52 <carter> well
23:42:51 <carter> haskell has rich enough (though not too rich) type system, such that you can use it to do a good strawman spec
23:43:11 <carter> for all the operations in a piece of software you're writing
23:43:13 <carter> (if you want to)
23:43:19 <johnw> and let's not forget that Haskell is just plain fun
23:43:28 <carter> thats only on saturdays, sshhhhh
23:43:55 <milfjord> putting the unction in functional programming
23:44:14 <carter> there exist (as neat resarch vehicles) some languages which have even more powerful type systems
23:44:23 <carter> BUT, they don't have as much type inference
23:44:33 <carter> GHC / Haskell have recurrently been about
23:44:37 <carter> how can you build a language
23:44:51 <carter> which has very very flexible powerful simple abstraction tools
23:45:21 <carter> that has GOOOOD type inference (we still write down the types because documenting things is good practice and catches unexpected changes in code)
23:45:33 <carter> and a really nice compiler and runtime system
23:45:50 <carter> its not perfect
23:45:58 <carter> but it strikes a really nice set of tradeoffs
23:47:03 <carter> that give you a suprisngly nice tool
23:47:07 <carter> where even if you're an expert
23:47:23 <carter> you wind up learning amazingly simple yet novel ideas
23:47:28 <carter> from other folks in the ocmmunity
23:47:34 <carter> plus we have really polite flamewars
23:47:42 <carter> riceandbeans: am i making any sense/
23:47:51 <carter> btw, you might have fun skiming that pdf li linked to ealier
23:48:04 <riceandbeans> yeah
23:48:18 <riceandbeans> this is working well
23:48:33 <riceandbeans> keeping my brain too busy to think
23:48:41 <riceandbeans> that was half the goal of the niht
23:48:43 <riceandbeans> night
23:48:45 <carter> :)
23:48:46 <carter> ok
23:49:10 <carter> heck, theres too much good stuff going on in haskel land even if you just try to read up on it all full time
23:49:13 <carter> i'm serious
23:49:28 <carter> i'm working on trying to improve the numerical computing / data analsysi tooling
23:49:40 <carter> and i help out a wee bit on the compiler (yes, you can too if you try)
23:50:02 <riceandbeans> carter: I have some software ideas I'm trying to do with friends but we've been mostly doing ruby
23:50:06 <levi> <- victim of the tendency to read too much about Haskell
23:50:06 <riceandbeans> some C
23:50:23 <carter> riceandbeans: well, the haskell / ghc C FFI is really nice
23:50:32 <riceandbeans> does haskell have QT and/or GTK+ bindings?
23:50:32 <carter> heck, you can also call haskell code from c
23:50:40 <carter> it has GTK ones
23:50:52 <carter> and whats that new QT markup thingy?
23:51:19 <riceandbeans> does it play nicely with postgresql?
23:51:22 <carter> ohh
23:51:27 <carter> we do
23:51:33 <carter> we have several different bindings
23:52:05 <carter> i like postgres-simple (it does a you write  sql string, but it guarantees proper escaping)
23:52:21 <carter> riceandbeans: in fact lpsmith is the author of postgres-simple
23:52:23 <carter> and a super nice guy
23:53:20 <carter> mind you, theres def room for better gui tools
23:54:17 <carter> but for *nix systems, gtk bindings apparently work out well
23:54:21 <carter> hav eyou heard of hoodle?
23:55:00 <carter> http://ianwookim.org/hoodle/
23:55:21 <levi> QML/QT Quick is the new Qt markup-based gui thing, I think.
23:55:40 <carter> levi: yeah... looks like hsqml hasn't been updated since 2012
23:55:42 <carter> but might still be good
23:55:43 <carter> idk
23:55:57 <carter> its late
23:56:00 <carter> i should head off
23:56:11 <riceandbeans> I've never (since VB) used a GUI to make a gui program
23:56:33 <carter> i know nuttin
23:56:43 <carter> a cute gui tool thats really portable
23:56:44 <carter> is
23:56:52 <carter> @hackage three-penny-gui
23:56:53 <lambdabot> http://hackage.haskell.org/package/three-penny-gui
23:57:03 <carter> here http://hackage.haskell.org/package/threepenny-gui
23:57:07 <carter> threepenny-gui
23:57:42 <carter> you write a haskell program that sends instructions back and forth to a local browser window that manipulates the dom
23:58:10 <carter> ok
23:58:11 <carter> i'm off
23:58:12 <carter> ttyl
