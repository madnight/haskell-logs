00:00:04 <jle`> you can do forM_ using the Data.Maybe stuff, but it's nice to use the same language for both lists and maybes
00:00:24 <jle`> and it's awkward to do with when
00:00:37 <jle`> when (isJust something) $ m (fromJust something)
00:01:14 <dmj> when (isJust x) $ do { let Just y = x; something y }
00:01:17 <dmj> probably more verbose
00:01:33 <shachaf> Ew. :-(
00:01:33 <dmj> jle: like a list of maybes?
00:01:37 <shachaf> @where boolean-blindness
00:01:37 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
00:01:39 <simpson> :t maybe
00:01:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:01:56 <shachaf> Do you "get" Functor?
00:01:58 <pavonia> Why doesn't regex-compat support character classes?
00:01:59 <jle`> compare to forM_ x something
00:01:59 <shachaf> Do you "get" mapM?
00:02:12 <simpson> :t \x something -> maybe (return ()) something x
00:02:13 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
00:02:29 <jle`> it's just neat cause you can reason with maybe and lists in the same way
00:02:33 <shachaf> Do you "get" Applicative?
00:02:34 <jle`> using the same functions
00:02:47 <dmj> shachaf: I feel good about using functor, applicative, monad, transformers and some arrows
00:02:49 <shachaf> If the answer to any of these is no, you should worry about them before Traversable.
00:02:49 <jle`> because maybes are just lists with 0 or 1 element
00:03:19 <dmj> shachaf: was 'ew' in reference to "<dmj> when (isJust x) $ do { let Just y = x; something y }"
00:03:33 <shachaf> Yes.
00:03:42 <shachaf> And so was the next thing I said.
00:04:16 * hackagebot stripe 0.5.0.0 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.5.0.0 (MichaelSchade)
00:04:54 <dmj> praise god it made it to hackage
00:05:06 <jle`> people usually use Trees and stuff like that as examples of traversable/foldable but i find myself using them for simpler things day to day.  also Data.Map, Data.Set are useful
00:05:39 <jle`> i'm always like "why can't i just treat this thing the same way i treat a list"
00:06:03 <jle`> so you can forM a Map
00:06:05 <jle`> forM_ a Set
00:06:08 <jle`> etc.
00:06:13 <jle`> sequence
00:06:15 <jle`> all that fun stuff
00:06:36 <dmj> jle`: so forM on Maybe, it will only be on one element right?
00:06:41 <jle`> dmj: one or zero
00:07:01 <dmj> jle`: I'm confused what it gives you that functor, appl., monad don't
00:07:09 <jle`> i use forM_ a lot for blaze when i want to render an html element only if some thing is Just x, or skip it if it's Nothing
00:07:15 <jle`> dmj: i wouldn't think of it as adding more power
00:07:27 <jle`> it's mostly so that you can reason with it the same way that you can reason with lists
00:07:34 <jle`> and use all with the same language
00:07:48 <jle`> sort of like the utility of the Monoid typeclass
00:07:55 <dmj> ah I see
00:08:28 <jle`> i mean i could make a different operator for every monoid
00:08:33 <jle`> or i can just use (<>) for all of them
00:09:16 * hackagebot JuicyPixels-util 0.1 - Convert JuicyPixel images into RGBA format, flip, trim and so on  http://hackage.haskell.org/package/JuicyPixels-util-0.1 (FumiakiKinoshita)
00:10:29 <jle`> similar to the Arrow typeclass...i'm not totally convinced that it's even something too much more powerful than Category + Applicative...but it's nice to be able to use first, &&&, etc. on all Arrows
00:13:31 <jle`> of course i might be missing something fundamental to foldable/traversable >.>
00:24:17 <pavonia> Using regex-compat, how do you add a '0' after a matched sub-expression? The following fails with "Index (10) out of range ((0,1))": subRegex (mkRegex "([0-9]+\\.)") "1." "\\10"
00:24:40 <pavonia> This looks like a bug to me
00:34:39 <shachaf> Hmm. http://hackage.haskell.org/package/regex-compat-0.95.1/docs/src/Text-Regex.html#subRegex uses a regex to search for backreferences in the replacement string.
00:35:45 <shachaf> And, yep, it doesn't look like it'll let you write a digit afterwards.
00:37:15 <pavonia> that's annoying :S
00:42:23 <Twey> jle`: What order does forM run the actions in for a Set/Map?
00:42:32 <glguy> Poking around about POSIX regular expressions, it doesn't seem that more than a single digit was intended to be supported when numbering backreferences
00:44:31 <bartavelle> I would also claim that only \10 should not be a valid backreference
00:44:34 * bartavelle corrects his library
00:44:57 <jle`> Twey: i would assume the ascending order of the key for map...looking for it in the source
00:45:24 <jle`> and also ascending order of the items in Set
00:45:30 <Twey> Hrm
00:46:09 <Twey> But you don't know there's an Ord constraint on Set — this is why we've never been able to make it Monad
00:46:41 <jle`> not sure i understand
00:46:51 <jle`> the ord constraint on Set is the reaosn why you can define a traversing/folding order
00:47:39 <jle`> hm
00:47:43 <jle`> it likes like for both
00:47:51 <Twey> jle`: http://stackoverflow.com/questions/12183656/constructing-efficient-monad-instances-on-set-and-other-containers-with-const
00:47:52 <jle`> it does a traversal of the binary tree
00:48:16 <Twey> Aha
00:48:17 <jle`> looks like in order
00:48:29 <jle`> http://hackage.haskell.org/package/containers-0.5.4.0/docs/src/Data-Set-Base.html#Set
00:48:31 <jle`> in-order
00:48:37 <jle`> ctrl+f "foldable"
00:48:58 <Twey> So the Traversable will traverse it in whatever order it appears in the Set, but that order is guaranteed to be in order because of insert (which has an Ord constraint).
00:49:14 <jle`> ah
00:49:17 <jle`> yeah that's neat actually
00:49:20 <jle`> the set isn't Ord'd
00:49:21 * hackagebot persistent-redis 0.2.2 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.2.2 (PavelRyzhov)
00:49:23 <jle`> but it's already ordered
00:49:25 <jle`> from insert
00:49:35 <jle`> because of the BST ordering
00:50:06 <jle`> and...i think it doesn't instance Traversable explicitly because foldable is a generalized traversable
00:50:22 <jle`> because you can turn anything foldable into a traversable by folding it up into a list and traversing the list
00:50:28 <dmj> shachaf: so then how is when (isJust x) $ do { let Just y = x; stuff y } boolean blindness?
00:50:46 <Twey> jle`: Right
00:50:55 <jle`> dmj: well, it's a little redundant to both isJust and pattern match out Just
00:51:04 <jle`> when you could ahve done it all in one step
00:51:22 <jle`> the Bool is kinda...lame, in a way
00:51:33 <jle`> it dioesn't "carry any information" onto the next step
00:51:40 <jle`> you have to re-extract the information that you already received
00:51:46 <jle`> but lost when turning into a Bool
00:52:53 <dmj> I see
00:54:21 * hackagebot pcre-utils 0.1.1 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.1 (SimonMarechal)
00:54:27 <dmj> so use case or if then else
00:54:40 <bartavelle> pavonia, not sure how useful this is to you, but I just updated pcre-utils, and it should only accept multi digit backreferences
00:54:47 <dmj> I liked the idea of when for some reason
00:55:01 <bartavelle> this is based on another re library though
00:55:49 <pavonia> bartavelle: Okay, thanks for the info, I'll look into that package
00:56:05 <Twey> bartavelle: *Only* accept multi-digit backreferences?
00:56:12 <bartavelle> erm I meant, it should only accept *single* digit backreferences
00:56:17 <Twey> Aha
00:56:28 <bartavelle> yeah, that would have been evil
00:56:31 <Twey> Hehe
00:57:02 <Twey> I thought maybe you meant that now you only accepted backreferences with exactly two digits, so you can append a zero by writing \010
00:57:42 <bartavelle> ah that would have been a solution, but that would also have been very surprising to most RE users
00:57:53 <Twey> I would certainly have been surprised
00:58:12 <bartavelle> especially because of the "pc" in "pcre"
00:58:17 <Twey> But on the pragmatism front I doubt anybody will be using more than 99 backreferences
00:58:23 <Twey> Indeed :þ
00:59:09 <jle`> dmj: if then else is actually where you see boolean blindness most often in the wild
00:59:36 <Twey> dmj: Booleans only tell you that something is true or false; they ignore what that ‘something’ is.  It's better to be ‘constructive’ about your assertions: whenever you have some data that says ‘this is true’ you should also have data that says ‘… and here it is’
01:00:39 <Twey> For example, rather than having a function isStringWellFormed ∷ String → Bool, you might have parseString ∷ String → Maybe ParsedValue
01:01:11 <Twey> That is, the moment you pattern-match on the value to find out whether the string is well-formed, you immediately have access to the proof
01:01:45 <Twey> (you should also have a proof that it isn't well-formed in the converse case, but that's a little convoluted to express in Haskell)
01:01:57 <shachaf> dmj: What will you do if "let Just y = x" fails and crashes your program?
01:02:01 <Twey> (and perhaps more difficult to prove in the general case)
01:02:27 <dmj> shachaf: how can it if "isJust" was called on it already
01:03:42 <pavonia> Twey: How should a function "doesFileExists :: FilePath -> IO Bool" look like to avoid boolean blindness?
01:03:46 <dmj> > do { let x = Just 3; when (isJust x) $ do { let Just y = x; print (y+1); } }
01:03:47 <lambdabot>  <hint>:1:72: parse error on input `;'
01:04:04 <shachaf> Well, it's not enough that «"isJust" was called».
01:04:06 <Twey> pavonia: Perhaps FilePath → IO (Maybe Handle) ?
01:04:16 <dmj> > do { let x = Just 3; when (isJust x) $ do { let Just y = x; print (y+1) } }
01:04:16 <dmj>  
01:04:17 <lambdabot>  <hint>:1:73: parse error on input `}'
01:04:18 <shachaf> What if it returned False?
01:04:32 <shachaf> I know how isJust works, you don't need to demonstrate it.
01:04:46 <dmj> shachaf: if it returned false the when block wouldn't get executed
01:04:59 <Cale> Heh, if an open filehandle is a proof of a file's existence, what's a refutation? :)
01:05:11 <bartavelle> Cale: obviously a closed filehandle !
01:05:33 <Twey> pavonia: In the general case you need to prove things about your code in order to avoid *all* forms of Boolean-blindness (and Maybe-blindness, which is a level up :þ), and it's not always possible or easy to prove, but it's worthwhile trying to include as much information as you reasonably can
01:06:06 <shachaf> dmj: Right, you know that.
01:06:15 <shachaf> But now you have to keep track of that.
01:06:32 <shachaf> Cale: (Any reason for +o?)
01:06:38 <jle`> also nonexhaustive pattern matches scare me :|
01:06:49 <jle`> Twey: first time i have heard about maybe-blindness ;)
01:06:51 <Twey> Cale: Perhaps an OS error?
01:06:57 <bartavelle> (issues of boolean blindness aside, it's better to just open a file and catch errors than testing for existence and then opening it)
01:07:05 <shachaf> In particular, the compiler doesn't know that, and can't give you an error message if you move that block around somewhere outsie of isJust.
01:07:40 <shachaf> And when you're reading or writing the code, you have a proof that that pattern match can never fail. But you have to keep track of that proof.
01:08:01 <Twey> jle`: Maybe only lets you say ‘this thing exists’, which doesn't admit refutations and can in itself be a form of blindness if the type isn't informative enough
01:08:24 <pavonia> bartavelle: Opening and catching errors seems like too much overhead to me if you're really only interested in the existence of a file
01:08:26 <Cale> shachaf: We've had a few people in here tonight spewing offensive stuff and insulting people. Figured I'd leave myself opped just in case they find a way back in.
01:08:27 <Twey> Cale: The OS isn't well-designed for this, unfortunately.  ☹
01:08:53 <jle`> in other words, we are on high alert level
01:09:06 <bartavelle> pavonia, yes obviously, but having "FilePath -> IO (Maybe Handle)" seems quite useful
01:09:09 <Twey> jle`: In the pathological case, of course, using Maybe () is isomorphic to Boolean-blindness :þ
01:09:33 <jle`> really?  .... crap, i've been doing it all wrong
01:09:47 <Twey> Hehe
01:09:53 <Twey> ‘They told me Booleans were bad!’
01:10:11 <Cale> Nearly isomorphic, but it lets you have Just _|_ as well ;)
01:10:25 <Twey> Cale: That's for the FILE_NOT_FOUND Boolean
01:10:49 <Cale> Error: The operation completed successfully.
01:11:07 <Twey> Heh
01:12:21 <dmj> here's an example where I'm indulging in boolean blindness
01:12:25 <dmj> http://lpaste.net/99559
01:13:07 <Cale> dmj: y u no case?
01:13:12 <dmj> If a user is referred to the website by way of a query string parameter I want to save that fact to a hash table then log the user in. Either way the user still gets logged in, w/ or w/o a referral
01:13:29 <Cale> I guess it'd be about the saem
01:13:31 <Cale> same*
01:13:42 <bartavelle> it also would be 3 lines long
01:13:56 <Twey> pavonia: An easy (computationally and conceptually) but still significantly better way is a wrapper: newtype FileExists = FileExists FilePath; type ErrorMessage = String; newtype FileDoesn'tExist = FileDoesn'tExist ErrorMessage; doesFileExist ∷ FilePath → IO (Either FileDoesn'tExist FileExists);
01:15:04 <Cale> case param of Just ref | not (null ref) -> update $ AddReferredBy ref user; _ -> return ()
01:15:27 <jle`> forM_ param $ \ref -> unless (null ref) (update AddReferredBy ref user)
01:15:34 <dmj> Cale: I guess I was averse to the  Nothing -> return () case
01:15:38 <Twey> pavonia: You can hide the constructors for FileExists and FileDoesn'tExist, so the module system guarantees that if you have a FileExists "foo" then you got it by calling doesFileExist, which, if your function works right, is a guarantee that the file "foo" exists (or at least used to exist)
01:15:50 <Cale> oh yeah, unless
01:16:01 <Cale> and I *guess* you could use forM_ :)
01:16:06 <tonnato> testing files for existence is an antipattern
01:16:13 <companion_cube> Twey: you have race conditions then
01:16:14 <Twey> Agreed
01:16:14 <Cale> I always find that a bit odd with Maybe
01:16:16 <mr-> If null is fine, isJust is too :-P
01:16:20 <Twey> companion_cube: As tonnato says
01:16:23 <jle`> forM_ param $ unless <$> null <*> (flip (update addReferredBy) user)
01:16:33 <jle`> Cale: that's my most common usage of forM_ actually heh
01:16:38 <Twey> companion_cube: But you already had race conditions with the Bool, so I don't feel we've lost anything :þ
01:17:25 <companion_cube> in the program itself, booleans aren't as dangerous :)
01:17:38 <companion_cube> I'm not a huge fan of this "boolean blindness" idea
01:17:46 <dmj> jle: so forM_ turns Maybe into a function that takes a list as its first param
01:17:51 <Twey> companion_cube: Aren't as dangerous how?
01:17:57 <jle`> dmj: no, it takes what is in the Maybe
01:18:07 <jle`> it's the same as forM_-ing over a list with only one or zero elements
01:18:08 <companion_cube> well, the problem with files is concurrent access/mutation with *other* programs
01:18:18 <dmj> @typ maybeToList
01:18:19 <lambdabot> Maybe a -> [a]
01:18:24 <Twey> Right
01:18:25 <dmj> diff?
01:18:26 <companion_cube> of course, don't carry a boolean far from where it was created, but they are still useful
01:18:31 <iross> Twey: Do you have a reference for the classical mechanics + types paper you mentioned earlier?  (Sorry, a bit behind the curve here...)
01:18:46 <jle`> dmj: it's sort of like implicitly maybetolisting, yeah
01:18:56 <Twey> companion_cube: They're exactly as useful as the Either, but less informative :þ
01:19:00 <jle`> Prelude.forM_ . maybeToList
01:19:09 <companion_cube> Twey: a == b is pretty informative
01:19:14 <dmj> @typ Prelude.forM_ . maybeToList
01:19:15 <dmj>  
01:19:15 <lambdabot>     Not in scope: `Prelude.forM_'
01:19:16 <lambdabot>     Perhaps you meant one of these:
01:19:16 <lambdabot>       `Prelude.mapM_' (imported from Prelude),
01:19:18 <companion_cube> if a == b then ... else ...
01:19:23 <companion_cube> can't see a problem with this
01:19:26 <jle`> oh it's not in prelude i guess heh
01:19:31 <tonnato> (a == b) ... ...
01:19:33 <dmj> @typ forM_ . maybeToList
01:19:34 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m ()
01:19:36 <jle`> I think it's in Control.Monad
01:19:58 <dmj> jle`: thought this was the foldable one
01:19:59 <jle`> or just already imported :)
01:20:08 <companion_cube> tonnato: that's pretty isomorphic
01:20:08 <jle`> the foldable one is F.forM_
01:20:15 <jle`> :t F.forM_
01:20:15 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
01:20:22 <companion_cube> I just prefer to use if/then/else rather than Church encodings of it
01:20:28 <jle`> so... t = Maybe
01:20:54 <jle`> ~
01:20:56 <Twey> iross: http://bentnib.org/conservation-laws.html
01:21:39 <Twey> companion_cube: But not as informative as it would be if it returned Either (a ≢ b) (a ≡ b)
01:21:53 <companion_cube> what's a "a = b" ?
01:22:13 <companion_cube> what can you use it for, apart from testing its truth value?
01:23:32 <iross> Twey: Oh, that looks mighty fine.  Thank you!
01:23:33 <Twey> companion_cube: a ≡ b is the type of proofs that a is the same thing as b; you can use it wherever a proof that a ≡ b is required (mind you, that's far outside what I'd bother doing in Haskell)
01:23:57 <companion_cube> indeed,  I see the point in a proof system, but not in a programming language
01:24:11 <companion_cube> in a proof system, bool is useless, Prop rules anyway
01:24:35 <Twey> iross: No problem!  It's pretty cool.  I wonder if we'll have a full type-theoretic account of physics some day.
01:24:52 <Twey> companion_cube: Well, proof systems are programming languages :þ
01:25:01 <companion_cube> but the converse isn't true
01:25:12 <Twey> Good enough programming languages are :þ
01:25:19 <companion_cube> I mean, if you write code in Coq, then sure, don't use bool (but for reflection purposes)
01:25:40 <Cale> companion_cube: Well, in HoTT, if A and B are types, then proofs of A = B are (to a first approximation) like isomorphisms between A and B
01:25:46 <companion_cube> if you write haskell or ML, then you don't have powerful enough a proof system to have more in a==b than just a bool
01:25:58 <companion_cube> Cale: I've yet to see a proof assistant that uses HoTT :)
01:26:10 <Cale> companion_cube: There are implementations of HoTT in Coq and Agda
01:26:10 <Twey> companion_cube: Something a bit more Haskell-friendly would be to return an Either Isn'tEqual IsEqual, where Isn'tEqual and IsEqual are opaque types.
01:26:17 <companion_cube> that's much much more elaborate than any programming language anyway
01:26:50 <Twey> companion_cube: Which would be significantly less useful, but still at least as informative as the Boolean (you've gone from ‘something is true’ to ‘some things are equal’)
01:26:56 <companion_cube> Cale: between you and me, I'm an heretic, I use classical logic anyway ^^
01:26:58 <Cale> companion_cube: I don't know whether it ought to be. I can think of a lot of good uses for higher inductive types in software engineering :)
01:28:02 <Twey> companion_cube: There's an interpreter for an experimental programming language that computes univalence using the cubical-set model on Hackage, called ‘cubical’
01:28:15 <Twey> (… / proof assistant)
01:28:36 <companion_cube> people of my lab are also thinking about HoTT in their dependently typed type checker
01:28:56 <Twey> We live in exciting times
01:29:12 <Cale> companion_cube: btw, I use classical logic too, but I also use constructive logic :)
01:29:21 <companion_cube> heh
01:29:31 <Twey> You can use classical logic under HoTT
01:29:48 <companion_cube> I like automated theorem proving, and doing constructivist proofs automatically is insanely hard
01:29:57 <Twey> It just doesn't generalize past the first two levels
01:30:58 <mr-> Cale: how would you use HITs? ;-)
01:32:52 <Cale> mr-: A simple one would be ensuring that the interpreters for a domain specific language respect equations between terms of the language.
01:33:58 <Cale> mr-: More fancy uses would be things like just being able to conveniently make use of groups. There was a nice example that Dan Licata gave of "darcs as a higher inductive type"
01:34:52 <Cale> Where you have a type with a single value constructor to serve as a basepoint, and you represent patches as paths from that basepoint to itself.
01:34:54 <Twey> Heh, the ‘darcs as a higher inductive type’ slides are contained in a file called git.pdf
01:35:48 <Cale> and then you throw in some 2-paths for commuting patches which touch different things
01:36:15 <mr-> indeed, maybe the computer algebraists should switch from C to Agda :-)
01:36:41 <Cale> (which are important when you want to invert a patch that isn't the last one you applied)
01:40:40 <Twey> Cale: I think it's a bit confusing to call a patch an ‘equality’
01:41:30 <morpheus07> Hi guys, I am a python developer. I would like to contribute to a project based on python. Can someone tell me where I can find the mentors ?
01:41:45 <Cale> morpheus07: You're in #haskell
01:41:46 <mornfall> morpheus07: not in #haskell, obviously
01:41:56 <xintron> Is there an easy way to parse Char -> HexaDecimal?
01:42:29 <Twey> xintron: Data.Char.ord?  That doesn't sound much like parsing to me, though
01:42:36 <Twey> > ord 'a'
01:42:37 <lambdabot>  97
01:43:20 <Cale> Twey: The point is that the things you can accomplish by patches form a group, and any group can be encoded using the loops at a point.
01:43:33 <xintron> Twey, I want the base16 value ('a' -> 61)
01:43:40 <Cale> (if you set up the type correctly)
01:43:51 <jle`> xintron: there was just a question about this a few hours ago
01:43:55 <jle`> let me see if i can dig it up
01:45:28 <jle`> > readHex "deadbeef"
01:45:29 <lambdabot>  [(3735928559,"")]
01:45:48 <jle`> it returns a list of possible parses with their residuals
01:45:53 <sccrstud92> > showHex 14
01:45:54 <lambdabot>  <[Char] -> [Char]>
01:46:11 <sccrstud92> > showHex "134"
01:46:12 <lambdabot>  No instance for (GHC.Real.Integral [GHC.Types.Char])
01:46:12 <lambdabot>    arising from a use of `Numeric.showHex'
01:46:12 <lambdabot>  Possible fix:
01:46:12 <lambdabot>    add an instance declaration for
01:46:12 <lambdabot>    (GHC.Real.Integral [GHC.Types.Char])
01:46:21 <Twey> xintron: It's a number: it doesn't have an intrinsic base.
01:46:32 <jle`> > snd <$> maybeToList (readHex "deadbeef")
01:46:33 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe (a0, b0)'
01:46:33 <lambdabot>              with actual type `[(a1, GHC.Base.String)]'
01:46:33 <Twey> > showHex (ord 'a') "" -- xintron
01:46:34 <lambdabot>  "61"
01:46:45 <xintron> Twey, ah, simple as that. Ty! :)
01:46:51 <tonnato> > digitToInt 'a'
01:46:51 <Twey> xintron: You need to import Numeric
01:46:52 <lambdabot>  10
01:47:09 <Cale> Twey: The story of intensional type theory is that maybe the ways in which you can prove something is equal to itself aren't just the trivial way by reflexivity, and the univalence axiom actually insists on it. :)
01:47:16 <jle`> oh i didn't realize digitToInt did hexes too. that's useful
01:47:27 <Twey> > digitToInt 'g'
01:47:28 <lambdabot>  *Exception: Char.digitToInt: not a digit 'g'
01:47:29 <tonnato> > Text.Printf.Mauke.printf
01:47:30 <lambdabot>  Not in scope: `Text.Printf.Mauke.printf'
01:47:30 <lambdabot>  Perhaps you meant `Text.Printf.printf' (imported from Text.Printf)
01:47:30 <Twey> Aw
01:47:55 <Twey> Hm, I haven't seen mauke around for a while.
01:48:09 <jle`> > fst <$> listToMaybe (readHex "deadbeef")
01:48:10 <lambdabot>  Just 3735928559
01:48:30 <jle`> > fst . head $ readHex "deadbeef"
01:48:31 <lambdabot>  3735928559
01:48:31 <tonnato> I wanted to try printf "%x" 'a'
01:48:34 <Twey> Cale: More ‘equivalent’ than ‘equal’, no?
01:49:12 <Cale> Twey: Well, sort of, yeah, but HoTT can prove a lot of things given an equality.
01:49:30 <Twey> It makes sense to say that the before and after of a patch are equivalent (under the patch) but to say they're ‘equal’ seems wrong to me
01:50:11 <Twey> So I usually try to taboo ‘equal’ when talking about HoTT :þ
01:50:23 <Cale> Twey: All you're saying is that the basepoint of this type is equal to itself -- all the data is encoded by the proofs of equality
01:50:51 <Twey> Aye
01:50:56 <Cale> As for why this is like equality, there's transport: for any type constructor C, there's a map (a = b) -> (C(a) -> C(b))
01:51:14 <Cale> and in fact, using univalence, we can prove:  (a = b) -> (C(a) = C(b))
01:51:36 <Cale> If you think of C as being a 'property' which might be had by a and b, then this says equal things have all the same properties
01:52:48 <Cale> and if you think of C as being some sort of construction which can be done in terms of a and b, this says that doing that no matter what it is, doing that construction will produce equal results.
01:52:58 <Cale> edit fail
01:53:05 <Cale> but you get the idea, I hope :)
01:54:28 * hackagebot knots 0.1.0.0 - Khovanov homology computations  http://hackage.haskell.org/package/knots-0.1.0.0 (maltem)
01:55:21 <Twey> Cale: I do, but I still don't like the use of the term ‘equal’, which has all kinds of stricter connotations for me :þ
01:55:41 <Cale> Well, it certainly takes some getting used to
01:55:50 <Twey> Hm
01:56:06 <Cale> When you restrict yourself to what HoTT calls sets, then it behaves just like equality of points in sets you're familiar with
01:57:07 <Cale> But HoTT vastly expands the universe of things which can be discussed at a formal level, so the notion of equality gets generalised.
01:57:08 <Twey> Hrm, yes, I suppose that's true
02:03:23 <bitemyapp> jle`: <$> instead of fmap?
02:05:51 <bitemyapp> > fromJust $ fmap fst $ listToMaybe $ readHex "deadbeef"
02:05:53 <lambdabot>  3735928559
02:06:34 <supki> > "deadbeef" ^? base 16
02:06:36 <lambdabot>  Just 3735928559
02:08:14 <Twey> Dammit lens
02:08:22 <Axman6> :t base
02:08:22 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
02:08:43 <Axman6> Choice?
02:08:54 <Axman6> @info Choice
02:08:55 <lambdabot> Choice
02:09:03 <Axman6> @hoolge Choice
02:09:03 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
02:09:04 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
02:09:04 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
02:09:16 <supki> :: Integral a => Int -> Prism' String a
02:09:48 <supki> Axman6: Choice is from profunctors
02:10:05 <supki> it's like ArrowChoice but without the awful part
02:10:20 * bitemyapp snorts
02:10:43 <tonnato> AwfulChoice
02:10:47 <Twey> Hm, has anyone written ‘Haskell: The Good Parts’ yet?  :þ
02:11:23 <bitemyapp> Twey: I was actually calling the way I teach Haskell that recently.
02:11:45 <Twey> bitemyapp: What does that involve?
02:12:02 <bernalex> bitemyapp: woah. I saw your name on twitter and on here at the same time. my brain is confused now. is this twitter? is twitter #haskell? woah.
02:12:11 <Axman6> supki: well, I have no idea what any of those are =)
02:12:35 <bitemyapp> Twey: Basics of the type system and signatures, then Typeclasses -> Functors -> (Applicatives && Monoids) -> Monads
02:12:54 <bitemyapp> Twey: I relate things like common-case list functions to the stuff going up with the typeclasses.
02:13:08 <bitemyapp> Twey: I go more in depth into the earlier parts if they're very new to programming or FP.
02:13:14 <Cale> b... but default declarations
02:13:24 <bitemyapp> but if they understand things like map filter, it's best to just get to the interesting stuff ASAP.
02:13:28 <bitemyapp> map and filter, that is.
02:13:33 <bitemyapp> bernalex: hi!
02:13:39 <Cale> and the monomorphism restriction :D
02:13:56 <bitemyapp> Cale: I actually cheat
02:14:15 <bitemyapp> Cale: I have monomorphism restriction turned off in my ghci config and teach things like addition in terms of Num.
02:14:28 <bitemyapp> I do mention that I'm cheating a bit, but again, it's just to introduce typeclasses.
02:14:38 <Cale> Yeah, I'm kidding :)
02:14:57 <bitemyapp> Cale: I think Num is the simplest/most obvious way to introduce typeclasses.
02:16:00 <bitemyapp> I try to save lists for fmap/join/>>=/return/<*>
02:16:46 <bitemyapp> Twey: I think if I managed to clear Monad/MonadPlus/Foldable/Traversable with a student I'd move onto edwardk's ouerve.
02:17:00 <Twey> bitemyapp: Interesting
02:17:07 <bitemyapp> mostly I just keep teaching the same material over and over because nobody knows a goddamn thing about Haskell. :)
02:17:36 <bitemyapp> anyway, to otherwise savvy programmers, the typeclassopedia is the real point.
02:17:42 <Twey> bitemyapp: Surely Monoid should come up before Functor?  It's much less intimidating.
02:17:46 <bitemyapp> they want to see the power + abstraction + safety
02:18:00 <bitemyapp> I disagree.
02:18:30 <bitemyapp> or at least
02:18:33 <Twey> Well, everyone's done string concatenation before.  fmap is a little more abstract, and requires that they already be familiar with things like first-class functions.
02:18:38 <bitemyapp> I don't find it any more difficult to explain functors than monoids.
02:18:53 <bitemyapp> hum, you missed the part I said about working with programmers who at least know what map and filter are.
02:18:58 <Twey> So Monoid seems like it would be a nice way to introduce them to the concept of generalizing-through-typeclasses.
02:19:01 <Twey> Ah, okay.
02:19:02 <bitemyapp> I'm relating it back to lists as I go through the basic typeclasses.
02:19:10 <bitemyapp> so I explain how fmap is a generalized map.
02:19:13 * Twey nods.
02:19:15 <bitemyapp> I explain how map is "
02:19:27 <bitemyapp> is lifting a function to operate in the context of a list
02:19:37 <bitemyapp> concordantly, fmap does the same thing, but for anything that's a valid functor.
02:19:53 <bitemyapp> pretty simple if you know how to explain it in clear terms and reinforce with examples like Maybe.
02:20:07 <bernalex> typeclasses are so badass. and the nice thing is that you can almost immediately get a feel for how they work. it's quite simple, like most elegant things.
02:20:21 <bitemyapp> I also try to relate Maybe <---> [] back and forth, point out the non-determinism implicit in both.
02:20:46 <bitemyapp> point out how the abstractions (inversion of control) are helping you set aside the non-determinism and just "say what you want to do"
02:21:00 <bitemyapp> bernalex: they're absolutely wondrous and a huge part of why I love the language.
02:21:11 <benj_> thinking of map in that way is really important IMO. It helps break away from the assumption that all functors are collections.
02:21:16 <bitemyapp> but that's why how I teach Haskell focuses so much on them.
02:21:42 <bitemyapp> benj_: right, and I do emphasize that they shouldn't necessarily think functors are expressly about reified containers.
02:21:51 <mangaba_leitosa> bitemyapp: where do you teach it?
02:22:01 <bitemyapp> benj_: the essence is only the "lifting" part.
02:22:55 <bitemyapp> mangaba_leitosa: I'm a Haskell trap-spider. I kidnap coworkers for one-on-one tutorials in and out of work. I teach people I know from IRC and Twitter over the internet/skype. Last Tuesday I gave a 101 tutorial over a brownbag lunch in a meeting room at my office.
02:23:22 <mangaba_leitosa> bitemyapp: cool :-)
02:23:50 <bitemyapp> another reason I have lists threaded throughout the typeclass explanations is that most Python users are already familiar with itertools and list comprehensions.
02:24:01 <bitemyapp> so things like applicative make a ton of sense in that context.
02:25:23 <bitemyapp> Twey: I guess Monoids are simpler if you want to focus on collections. I'm actively trying to "alienate" them from a collections-focused viewpoint.
02:25:49 <bitemyapp> Twey: and try instead to get them to think about collections as non-deterministic cardinalities etc etc
02:29:11 <bernalex> might as well try here as well: my laptop has died, and I'm w/o one until the 14th and so. further: our work server doesn't have the haskell platform, and since it's getting replaced in a couple of weeks, I doubt anyone will bother installing it.
02:29:26 <bernalex> tl;dr anyone have a server with haskell platform I can ssh into and work on? :-)
02:29:42 <bernalex> ooops sorry thought this was #-blah =/
02:36:56 <funky_lambda> .
02:39:03 <Axman6> ?
02:40:47 <bscarlet> Axman6: .
02:50:10 <tomejaguar> Do GHC.Generics and Data.Data do the same job?
02:51:24 <Feuerbach1> tomejaguar: broadly speaking, yes. but they are quite different
02:51:39 <dcoutts_> tomejaguar: if you look at them from 10,000 ft up, yes
02:52:42 <tomejaguar> How would I know which to choose for a particular job?
02:53:14 <tomejaguar> The specific job in mind is helping to provid instances for a class that's a lot like Applicative.
02:53:35 <tomejaguar> I would prefer to hand off as much as possible to another library.
02:53:47 <Feuerbach1> then go with GHC.Generics, I'd say
02:54:25 <tomejaguar> From the API it looks like Generics is lower level.  Is that right?
02:54:52 <Feuerbach> ideally you'd understand how each of them works and make your own choice in every case
02:55:00 <Feuerbach> I wouldn't say so. Just different
02:56:08 <tomejaguar> I see.  It seemed to me that one must subsume the other.  But I guess you're saying that's not right.
02:56:08 <Feuerbach> besides, if it's like Applicative, then type parameters are involved, which makes SYB a bad fit
02:56:32 <Feuerbach> there was a nice paper by Andres (I think) comparing and unifying them on a theoretical level
02:56:43 <tomejaguar> Yes at least two type parameters.
02:57:12 <tomejaguar> Generic Generic Programming?
02:57:38 <Feuerbach> http://www.andres-loeh.de/FormalComparisonGP/
02:58:02 <tomejaguar> Ah right.
02:58:46 <tomejaguar> OK thanks, I'll look into  them both.
03:08:23 <Feuerbach> tomejaguar: actually, I meant this one: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.6601 It is much simpler and easier to understand.
03:09:53 <tomejaguar> Very nice, thank you.
03:10:30 <sinclair|work> one thing i don't get about TCP, is that, does it have to accept every single segment it receives, or just the last segment it had received in order
03:13:25 <Aetherspawn> sinclair|work: tcp doesn't recieve in any defined segments.
03:13:29 <Aetherspawn> it's a stream
03:13:49 <sinclair|work> Aetherspawn: it needs to acknowledge
03:14:09 <sinclair|work> sender -> syn -> receiver -> ack
03:14:27 <Aetherspawn> sounds like you know more about it than me, so I concede.
03:14:40 <sinclair|work> in TCP, the sender sends a syn + sequence number, the receiver sends sequence number + 1 on the ack
03:25:12 <remdezx> Hello! How can I enable "-threaded" flag in GHC API? I keep getting error "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))" on runtime
03:25:20 <remdezx> I tried GHC.parseStaticFlags [GHC.noLoc "threaded"] but it didn't work
03:25:36 <hhhhhhhh> when i pipe my haskell program to something, it seems to stop printing anything. eg: `./program | grep .` prints nothing and on the same system `( while true; do echo a; sleep 1s; done ) | grep .` will print a's correctly
03:26:03 <awestroke> hhhhhhhh: show code
03:26:09 <awestroke> (gist)
03:26:25 <tomejaguar> Am I out of luck if I want to use GHC.Generics for a type constructor of two arguments?
03:27:06 <hhhhhhhh> awestroke it's a big program but i'm using print: https://github.com/mikejsavage/rssd/blob/master/src/main.hs#L293
03:27:33 <hhhhhhhh> i'm also using scotty and its "set phasers to stun" message doesn't appear to be piped either
03:28:35 <tomejaguar> hhhhhhhh: But it does print if you don't use a pipe?  Are you sure it's not just buffered?
03:30:43 <jedai> tomejaguar: Why would you be ?
03:30:45 <Feuerbach> tomejaguar: why? what is the specific problem?
03:31:33 <jedai> The logic of GHC.Generic seems not to care about the number of argument to your type constructor (your representation will just have as many arguments)
03:31:49 <exicer> Is there an easy way to do join's with persistent ?
03:31:56 <hhhhhhhh> tomejaguar: it looks like it's buffering. thanks
03:33:37 <bitemyapp> exicer: you've exceeded what Persistent was designed for. Look at Esqueleto.
03:33:51 <bitemyapp> exicer: IIRC, Esqueleto was designed to be used `with` Persistent.
03:34:24 <exicer> bitemyapp: Hm, okay. Will take a look, cheers.
03:34:41 * hackagebot creatur 5.0.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.0.1 (AmyDeBuitleir)
03:35:04 <JuanDaugherty> why does haskell need "generics"?
03:35:22 <JuanDaugherty> isn't it already sufficiently?
03:36:11 <JuanDaugherty> (srs question)
03:36:13 <bitemyapp> JuanDaugherty: http://www.haskell.org/haskellwiki/GHC.Generics
03:36:28 <bitemyapp> JuanDaugherty: IMHO, GHC.Generics is inside-baseball shit 99% of the community won't have to care about.
03:36:35 * bitemyapp shrugs
03:37:56 <JuanDaugherty> yeah, If you have ADTs I don't understand the need. I thought that was a standard element of the academic and thus the haskell culture
03:38:24 <Feuerbach> those are not the same generics as in other languages (there, they by "generics" they often understand "parametric polymorphism")
03:38:26 <tomejaguar> Feuerbach: Say I wanted to derive instances of 'Profunctor' using Generics.  Is that possible?
03:38:37 <JuanDaugherty> maybe just an unfortunate name choice though
03:38:43 <Feuerbach> by generics we understand datatype-generic programming
03:39:30 <Feuerbach> e.g. attempt to derive a functor instance for any user-defined datatype
03:39:35 <mr-> JuanDaugherty: When you write "deriving Show", or "deriving Functor", that's an instance of generic programming
03:39:45 <mr-> (in the sense that is meant here)
03:40:21 <kosmikus> tomejaguar: if you want to do class instances for an Applicative-like class generically, I'd indeed go with GHC.Generics (or even better with generic-deriving which wraps it). The generic-deriving package also contains all sorts of example generic functions that should help you to figure out what you need to do.
03:40:37 <JuanDaugherty> yeah and that's already in basic haskell/ghc right?
03:40:59 <Feuerbach> JuanDaugherty: for such basic things, yes. But say you want to make your own class derivable
03:41:21 <tomejaguar> kosmikus: But does it work with more than one type parameter?  I guessed it didn't since there's only Generic and Generic1.
03:41:23 <JuanDaugherty> i c
03:41:34 <kosmikus> tomejaguar: sorry, reading the log from way back, only coming to the more recent stuff now ;)
03:41:45 <bitemyapp> ahhh my old nemesis, swappiness.
03:41:47 <Feuerbach> JuanDaugherty: as a specific example, the Serial class of SmallCheck. that allows your type to be enumerated for testing, is derivable using GHC Generics
03:42:14 <kosmikus> tomejaguar: so the class you want to derive is of kind (* -> * -> *) -> Constraint?
03:42:59 <Feuerbach> JuanDaugherty: http://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html#g:1
03:43:37 <tomejaguar> kosmikus: I'm not sure what Constraint is there.  But let's start with the example of 'Profunctor'
03:43:47 <tomejaguar> http://hackage.haskell.org/package/profunctors-3.3.0.1/docs/Data-Profunctor.html
03:43:49 <tonnato> :k Show
03:43:50 <lambdabot> * -> Constraint
03:43:50 <tomejaguar> That's close enough.
03:44:15 <tomejaguar> OK I guess '(* -> * -> *) -> Constraint' is right then.
03:44:17 <kosmikus> tomejaguar: yes, Profunctor would be difficult to do
03:45:25 <Feuerbach> kosmikus: but it's because you have to track positivity of the position, not because of multiple type params, right?
03:46:16 <kosmikus> Feuerbach: no, it's because of multiple type params in this case
03:46:20 <Feuerbach> oh
03:46:29 <Feuerbach> tell us more :)
03:47:02 <kosmikus> Feuerbach: like what? :)
03:47:41 <kosmikus> you need a representation identifying both argument positions as parameters then
03:48:21 <kosmikus> Feuerbach: there's a fundamental different between using * -> * -> * types in a * -> Constraint class, and deriving a (* -> * -> *) -> Constraint class
03:49:19 <Feuerbach> yes, that makes sense...
03:49:53 <Feuerbach> but the class being derived itself doesn't appear anywhere in the Generics API, right?
03:50:14 <kosmikus> no
03:50:34 <Feuerbach> ah, I understand now
03:51:03 <Feuerbach> the derived representation isn't a data type that takes two parameters
03:51:05 <tomejaguar> I fear it may be Template Haskell then.
03:52:01 <kosmikus> tomejaguar: you could try the "derive" package (which still can use TH internally). then you don't have to start from 0.
03:52:27 <kosmikus> Feuerbach: the "Generic Haskell" approach easily allows to do typeclasses of arbitrary kinds
03:52:47 <kosmikus> Feuerbach: I should try to port that to a usable library once again, now that we have all the great kind system features
03:54:08 <tomejaguar> kosmikus: What's the relationship between generic-deriving and derive, if any?
03:56:22 <kosmikus> tomejaguar: just that they're for a similar purpose. but "derive" is a purely syntactic meta-programming approach
03:56:40 <kosmikus> tomejaguar: so no theoretical limitations, but also hardly any safety
03:57:06 <tomejaguar> So if I can get it to work with generic-deriving that sounds beter?
03:57:13 <tomejaguar> *better
03:57:41 <jedai> kosmikus: Why is generic limited to 1 type parameter though ? Shouldn't Generic2 be possible to write ?
03:58:25 <kosmikus> jedai: yes, of course, and Generic3 and Generic4 and ... :) and for each of them, you need to add auto-derivation to GHC
03:58:51 <tomejaguar> So we need a Generic Generic?
03:59:06 <kosmikus> jedai: possible, just not done, and hasn't been seen as necessary so far. I've personally more been interested in finding an approach that's equally usable and doesn't require all the different representations.
03:59:21 <kosmikus> tomejaguar: yes
03:59:45 <jedai> kosmikus: That would be ideal I guess...
04:00:34 <tomejaguar> kosmikus: Did you work on derive-generic?
04:00:41 <tomejaguar> I mean generic-deriving
04:00:51 <Feuerbach_> tomejaguar: re Generic Generic, ironically, Andres has a paper for that, too :)
04:00:53 <kosmikus> jedai: and even the GenericN scheme breaks as soon as someone wants to derive a class of kind ((* -> *) -> *) -> Constraint ;)
04:01:11 <kosmikus> tomejaguar: I'm Andres Löh
04:01:12 <tomejaguar> OK so you need generic binary tree
04:01:49 <kosmikus> tomejaguar: so yes, I did work on (the theory of) generic-deriving and GHC.Generics
04:01:53 <tomejaguar> kosmikus: Ah the secrets that hide behind IRC handles :)
04:01:55 <kosmikus> tomejaguar: I didn't actually implement it
04:02:00 <kosmikus> dreixel did
04:03:00 <tomejaguar> This Generics seems like a very interesting aspect of language design
04:03:48 <tomejaguar> kosmikus: Do you work full time for Well Typed now, or still do research?
04:04:23 <kosmikus> tomejaguar: I'm a partner at Well-Typed, so I don't have a formal employment contract specifying how many hours I work
04:04:39 <kosmikus> tomejaguar: I do some research, but I'm not paid for it
04:05:25 <kosmikus> tomejaguar: dreixel actually has some new work on generic-deriving with several parameters, but AFAIK, it's not implemented
04:05:53 <kosmikus> tomejaguar: see http://dreixel.net/index.php?content=research
04:06:01 <kosmikus> tomejaguar: (the draft)
04:06:41 <tomejaguar> Thanks
04:06:55 <tomejaguar> Generic stuff seems like one of the big important frontiers for language design
04:33:42 <dreixel> tomejaguar: why would you need a Generic2? out of curiosity
04:34:41 <tomejaguar> Hi dreixel
04:34:49 * hackagebot http-client 0.2.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.2 (MichaelSnoyman)
04:34:51 * hackagebot http-client-tls 0.2.1 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.1 (MichaelSnoyman)
04:35:07 <tomejaguar> I want to derive instances for 'Profunctor' (actually subclass of Profunctor, but Profunctor itself would be a good start)
04:35:19 <bernalex> so what do I do when I can't install ghc-mod because it can't install haskell-src-exts because happy >=1.17 is not installed, but it is?
04:35:40 <tomejaguar> Since Profunctor has two type arguments it seems like GHC.Generic doesn't support that.
04:35:48 <tomejaguar> Though I don't yet really understand these things ...
04:36:12 <dreixel> tomejaguar: right, cool. I should use that specific example in http://dreixel.net/research/pdf/gpmp_colour_draft.pdf :)
04:36:30 <tomejaguar> Yeah just been reading that ...
04:37:05 <tomejaguar> I can tell you about my actuall real-world example if that's relevant to you, though it's basically just a combination of Profunctor and Applicative.
04:37:10 <bernalex> and why is happy installed from scratch each time I do cabal install happy? does cabal have no way of knowing that things are already installed?
04:37:24 <tomejaguar> dreixel: Is this paper stuff that could be added to Haskell in the future?
04:37:48 <dreixel> tomejaguar: sure, do let me know of the application. and yes, it could be added to GHC, if there's enough people wanting it
04:38:32 <supki> bernalex: right, cabal does not track executables
04:38:33 <adnam> bernalex: it doesn't track binaries, if the .cabal file had specified a library as well it wouldn't reinstall it
04:39:33 <tomejaguar> dreixel: OK so the class is 'Profunctor p => ProductProfuctor p where { empty :: p () (); (***!) :: p a a' -> p b b' -> p (a, b) (a', b') }
04:39:49 * hackagebot http-client 0.2.2.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.2.1 (MichaelSnoyman)
04:40:01 <bernalex> right so what can you do when it insists you don't have a package that you have?
04:40:04 <tomejaguar> It's very easy to derive these in theory, but it requires the right generics library ...
04:41:33 <dreixel> tomejaguar: yes, indeed
04:42:13 <tomejaguar> dreixel: Do these generics libraries (and your draft) require lots of changes to GHC, or is it mostly in libraries?
04:43:06 <supki> bernalex: ?
04:43:09 <supki> bernalex: oh, happy
04:43:12 <adnam> bernalex: why do you insist on reinstalling it?
04:43:18 <bernalex> adnam: wat?
04:43:19 <supki> bernalex: that's probably a PATH issue
04:43:30 <dreixel> tomejaguar: the stuff described in my paper would require changes to GHC
04:44:43 <bernalex> supki: right. that might be true. I'm on someone else's server, so I didn't consider that.
04:44:49 <bernalex> supki: OK, nope.
04:44:50 * hackagebot range-set-list 0.0.1 - Memory efficient sets with continuous ranges of elements. List based implementation.  http://hackage.haskell.org/package/range-set-list-0.0.1 (phadej)
04:45:05 <supki> bernalex: what does  type happy  say?
04:45:20 <bernalex> -bash: type: happy: not found
04:45:33 <adnam> it's not a path issue, if you call cabal install on an executable it will always reinstall it
04:45:35 <bernalex> oh wait, I got it
04:45:41 <bernalex> adnam: ... wat?
04:46:22 <bernalex> supki: fixed it. forgot that this guy set me up with a different username than what I usually have, so I goofed the path in the EXPORT. :-) works now. thanks!
04:47:05 <AlainODea> adnam: put $HOME/.cabal/bin in your path, probabky at the front so you can ipdate cabal itself
04:47:35 <AlainODea> I will learn to type properly one of these days.  That was a mess :)
04:48:18 <bernalex> oh right. now haskell-src-exts just fails for no apparent reason
04:48:34 <bernalex> ExitFailure 9. uh-huh. OK. sure.
04:48:53 <supki> now that sounds like OOM ;)
04:49:25 <bernalex> supki: omg.
04:49:40 <bernalex> supki: thanks for letting me know at least. I'll have to wait until my gracious host wakes up then.
04:50:06 <bernalex> supki: yep. it's oom.
04:50:19 <Tekmo> bernalex: Can you compile an older version?
04:50:27 <bernalex> MemTotal:         503248 kB
04:50:29 <bernalex> ouch.
04:50:50 <bernalex> Tekmo: IDK, I'm trying to compile ghc-mod. looks like it needs hlint which needs haskell-src-exts.
04:50:57 <haasn> bernalex: get more swap :P
04:51:28 <AlainODea> bernalex: that sounds more like a Java process. We hae a simple background agent that uses 200MB. It's flat out ridiculous
04:51:33 <Tekmo> bernalex: I had a similar problem with another library on a computer with 1GB of memory.  Just randomly trying older versions worked for me
04:51:35 <bernalex> haasn: it's not my server
04:52:22 <bernalex> lol there are 70 versions available
04:52:49 <Tekmo> bernalex: That's why you have to pick randomly! :)
04:58:18 <haasn> that's why you pick the newest, no matter what. Even if it's unstable. Run a cron job to git pull and rebuild every 5 minutes, regardless of what operations you're currently running
05:03:37 <edsko> can I from (Lens' a b) to (Lens' (f a) (f b)) ?
05:03:42 <satc> Can deriving(Enum) start the count from 1 instead of 0. I have like 20 constructors and I dont want to define fromEnum and toEnum just because it has to start from 1 instead of 0.
05:03:47 <edsko> (for some restriction on f)
05:04:19 <merijn> satc: Why does it have to start from 1?
05:05:14 <Twey> satc: fromEnum is supposed to be a mapping onto the natural numbers; you'll probably just have to succ it up
05:05:27 <Twey> (when you use it, that is)
05:05:31 <quchen_> ba-dum tsh
05:05:35 <Twey> :-D
05:05:37 <quchen_> :-)
05:06:10 <quchen_> To answer the question, no, you cannot influence what `deriving` does.
05:06:22 <tomejaguar> edsko: Best to ask on #haskell-lens
05:06:34 <edsko> ah, didn't know that existed. thanks tomejaguar
05:06:35 <satc> merijn: Lets say I am defining some constants from a protocol. (similar to #defines in C)
05:06:50 <identity> Weren't there some lenses to directly manipulate state inside MonadState?
05:07:03 <notdan> yeah
05:07:09 <Twey> It would be nice if you could override bits of the ‘deriving’ function.  Too often I've had to write a Show instance manually for a huge datatype because I wanted to change how one constructor printed.
05:07:10 <quchen_> :t (%=)
05:07:11 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
05:07:11 <notdan> .= .+ .%
05:07:38 <Twey> satc: You don't have to use fromEnum; you can always define yourFancyEnumToInt = succ . fromEnum
05:07:44 <quchen_> Hmm. Well, that :t was useless. Anyway, look for stuff with "=" in it, or alternatively the state submodule of Lens.
05:07:46 <identity> notdan: thanks!
05:08:20 <notdan> oh wait those are acutally %=, +=, -=
05:08:30 <identity> @info (%=)
05:08:30 <lambdabot> (%=)
05:08:31 <notdan> and .= too
05:08:35 <identity> ah, okay.
05:08:42 <notdan> :t (%=)
05:08:43 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
05:08:44 <notdan> :t (.=)
05:08:45 <identity> notdan: do you know which submodule of lens they're contained in by chance?
05:08:45 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
05:08:59 <notdan> identity: Control.Lens.Setter I believe
05:09:17 <notdan> and Control.Lens.Operators (but that module has all the operators)
05:09:19 <quchen_> Click on index, click on all, look for %=.
05:09:56 <identity> notdan: thanks again!
05:10:32 <notdan> also quchen_ advice is very helpful not just for lens but in general
05:10:38 <identity> quchen_: Oh, hadn't used the index before. Definitely useful for a massive library like lens
05:10:47 <ownclo> quchen_: wow, thank you, it's very useful, never knew about it
05:11:20 <quchen_> Poor man's Hoogle (if you know the package) :-)
05:12:22 <quchen_> It's also nice to find the definition location of something in packages with lots of reexports.
05:13:00 <exicer> I'm having some trouble with cabal sandbox. I have my cabal file listing the build dependencies, and can do cabal install. However if I try to runhaskell on my file, it says it cannot find the most recently added dependency.
05:13:16 <exicer> This is after doing a cabal install --dependencies-only
05:13:32 <dcoutts> exicer: there's usually no need to use runhaskell setup, just use cabal
05:13:36 <quchen_> I don't think GHC knows about your sandbox.
05:14:02 <dcoutts> exicer: if you must, you have to realise that cabal is using a lot of extra flags, and you'd have to pass those manually
05:14:22 <exicer> dcoutts: So I should just use the binary cabal produces from install ?
05:14:54 <dcoutts> exicer: erm. I mean you don't need to say: runhaskell Setup.hs configure, instead you say: cabal configure
05:14:56 <exicer> I'm pretty new to cabal, so it is fair to say I don't really know what I'm doing
05:15:04 <dcoutts> similarly build, etc
05:15:27 <dcoutts> exicer: these days you can consider the Setup.hs command line interface to be a lower level machine interface, not a end-user interface
05:16:56 <exicer> dcoutts: Ahh, okay I see.
05:16:58 <exicer> Thanks
05:17:28 <exicer> Do you know of any way that flycheck in emacs can be linked in to cabal?
05:17:44 <johnw> exicer: to show what?
05:20:01 <exicer> Well at the moment my flycheck gets hung up on imports not being there, but they are present in the sandbox
05:21:11 <ownclo> I had similar problems with syntastic (vim) and hdevtools. You need to specify a path to sandbox packages somewhere
05:21:12 <johnw> oh, I see what you mean now
05:21:36 <johnw> I use hdevtolos with hsenv, and I have to set several env vars inside Emacs
05:21:49 <johnw> but for cabal, you'll probably need to create a new flycheck checker
05:21:53 <johnw> (which is fortunately very easy to do)
05:22:13 <dcoutts> exicer: sorry, never used flycheck
05:22:19 <exicer> No worries :)
05:22:42 <dcoutts> exicer: but it's "just" a matter of passing the right flags to ghc, you can see how cabal invokes ghc if you pass -v to cabal
05:22:42 <exicer> johnw: I will have a look. Thanks.
05:42:29 <johnw> lispy: ping
05:47:18 <DMcGill_work> I'm looking for a function of type (Int -> a -> (a,b)) -> b -> Vector a ->
05:47:41 <DMcGill_work> whoops. :: (Int -> b -> (a,b)) -> b -> Vector b I mean
05:48:00 <DMcGill_work> essentially an indexed unfold that I can use to construct a vector
05:48:32 <DMcGill_work> (Int -> b -> (a,b)) -> b -> Vector a
05:48:56 <DMcGill_work> Data.Traversable.mapAccumL words but is implemented in terms in toList and fromList
05:49:40 <DMcGill_work> unFoldRN works but I have to 1) keep track of the index myself and 2) use 'Just' everywhere
05:55:01 * hackagebot http-client 0.2.2.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.2.2 (MichaelSnoyman)
05:55:03 * hackagebot http-client-tls 0.2.1.1 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.1.1 (MichaelSnoyman)
05:55:05 * hackagebot http-conduit 2.0.0.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.5 (MichaelSnoyman)
05:59:39 <JuanDaugherty> Feuerbach, got it (if you read the log).
06:00:22 <predator117> exicer: did you see the flycheck-haskell package?  Essentially it does the thing mentioned here, setting the correct paths for ghc to find sandbox packages
06:00:29 <predator117> it's on elpa
06:20:04 * hackagebot fquery 0.2.1.5 - Installed package query tool for Gentoo Linux  http://hackage.haskell.org/package/fquery-0.2.1.5 (SergeiTrofimovich)
06:22:48 <identity> How do I the equivalent of ((+a) *** (+b)) (3, 3) in MonadState with lens?
06:24:04 <edwardk> lenses tend to be bad at 'zipping things'.
06:24:05 <laura_> If I define a constant  sn = truncate .sqrt  $ fromIntegral number
06:24:32 <laura_> this works, but when I want to have the sqrt only for the half of the number, i.e. number/2
06:24:50 <laura_> this doesn't work: sn = truncate .sqrt  $ fromIntegral number/2
06:25:04 <edwardk> fromIntegral (number / 2)
06:25:08 <laura_> can somebody give me a hint, why this doesn't work?
06:25:11 <edwardk> space binds tighter than /
06:25:14 <tonnato> laura_: it works fine
06:25:28 <identity> edwardk: I see. so I should use _1 and _2 with my state lens then?
06:25:38 <edwardk> >  truncate .sqrt  $ fromIntegral 400/2
06:25:39 <lambdabot>  14
06:25:44 <cognominal> I am reading elm source (they are in haskell) and I would like  to use ^C ⌥.           inferior-haskell-find-definition but the inferior haskell complains it has not the info, how do I make it available?  could it know about .cabal to find the relevant files?
06:26:05 <edwardk> of course you actually want the / outside the fromIntegral, so what you had was correct and should work
06:26:33 <laura_> nope, doesn't work in my environment. I get the message: No instance for (Fractional Integer) arising from a use of `/'
06:26:54 <edwardk> laura_: note the / 2 is _outside_ the fromIntegral number
06:26:59 <DMcGill_work> `solns `V.unsafeIndex` (i - w)'. It's at times like this where dependant types seem like a good idea. I'm /pretty/ sure that i >= w at all times but it'd be nice to be certain.
06:27:00 <edwardk> >  truncate .sqrt  $ (fromIntegral 400)/2
06:27:01 <lambdabot>  14
06:27:09 <edwardk> >  truncate .sqrt  $ fromIntegral (400/2)
06:27:10 <lambdabot>  Could not deduce (GHC.Num.Num a0) arising from the literal `400'
06:27:10 <lambdabot>  from the context (GHC.Real.Integral c)
06:27:10 <lambdabot>    bound by the inferred type of it :: GHC.Real.Integral c => c
06:27:10 <lambdabot>    at Top level
06:27:10 <lambdabot>  The type variable `a0' is ambiguous
06:27:27 <edwardk> the latter is probably what you are doing
06:27:28 <tonnato> laura_: "doesn't work" is not a problem description
06:27:54 <laura_> sorry, 'doesn't work' ==> I get an error
06:28:03 <laura_> as mentioned by lamdabot
06:28:07 <tonnato> "I get an error" is a super vague problem description
06:28:23 <tonnato> the lambdabot error was for the wrong code, not what you had originally
06:28:39 <laura_> ? I already have posted the error-text ???
06:29:14 <laura_> @edwardk, why does the different parenthis work?
06:29:14 <lambdabot> Unknown command, try @list
06:29:26 <tonnato> laura_: where?
06:30:22 <laura_> why does  truncate .sqrt  $ (fromIntegral 400)/2 work while  truncate .sqrt  $ (fromIntegral 400/2) fails?
06:30:48 <tonnato> you don't need parentheses in the first one
06:30:56 <tonnato> your original code was fine
06:32:17 <laura_> sorry, but now I am confused by myself :(
06:32:51 <quchen_> Both versions are fine.
06:32:53 <quchen_> > truncate .sqrt  $ (fromIntegral 400)/2 work while  truncate .sqrt  $ (fromIntegral 400/2
06:32:54 <lambdabot>  <hint>:1:89:
06:32:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:33:02 <quchen_> > truncate .sqrt  $ (fromIntegral 400)/2 work while  truncate .sqrt  $ (fromIntegral 400/2))
06:33:03 <lambdabot>  <hint>:1:90: parse error on input `)'
06:33:09 <quchen_> Goddammit.
06:33:31 <quchen_> More careful copy+pasting …
06:33:31 <quchen_> > (truncate .sqrt  $ (fromIntegral 400)/2, truncate .sqrt  $ (fromIntegral 400/2))
06:33:32 <lambdabot>  (14,14)
06:33:57 <laura_> but let a=truncate . sqrt $ fromIntegral (400/2) fails
06:34:27 <tonnato> > fromIntegral (1/2)
06:34:28 <lambdabot>  Could not deduce (GHC.Num.Num a0) arising from the literal `1'
06:34:28 <lambdabot>  from the context (GHC.Num.Num b)
06:34:28 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num b => b at Top level
06:34:28 <lambdabot>  The type variable `a0' is ambiguous
06:34:30 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
06:34:38 <tonnato> :t (/)
06:34:42 <lambdabot> Fractional a => a -> a -> a
06:34:43 <tonnato> :t fromIntegral
06:34:44 <lambdabot> (Integral a, Num b) => a -> b
06:35:05 <tonnato> (/) works on fractional numbers while fromIntegral demands an integer
06:35:24 <tonnato> hence the type error
06:35:30 <suOya> > replicateM 5 randomRIO (0,100)
06:35:32 <lambdabot>  [<IO Integer>,<IO Integer>,<IO Integer>,<IO Integer>,<IO Integer>]
06:36:00 <laura_> @tonnato: uhu, thx for the clarification
06:36:00 <lambdabot> Unknown command, try @list
06:36:54 <frx> > sequence $ replicateM 5 randomRIO (0,100)
06:36:55 <lambdabot>  <IO [Integer]>
06:37:11 <laura_> is there an *easy* (?) overview available, which types could be converted into which?
06:37:30 <laura_> e.g. I wasn't aware that Fractional is not an instance of Integer
06:37:42 <identity> https://gist.github.com/saevarb/8845272 I'm running into some errors trying to run StateT over Rand, that kind of look like some lens type errors(i'm using lens)
06:37:50 <identity> Could someone take a look?
06:37:57 <Tekmo> laura_: That's because Haskell distinguishes between integral division and floating point division
06:38:03 <Tekmo> laura_: You use `div` for integral division
06:38:13 <Tekmo> laura_: `Fractional` is for types that support floating point division
06:38:19 <Tekmo> laura_: Well, sort of
06:38:22 <Kaini> laura_, http://www.haskell.org/onlinereport/haskell2010/haskell2x.png this maybe?
06:38:27 <identity> laura_: Just logically, Fractional *shouldn't* be an instance of Integer. A fraction is per mathematical definition not an integer.
06:39:03 <identity> (or rather, numbers that are an instance of fractional shouldn't be an instance of integer and vice versa)
06:39:46 <laura_> that's the lesson I've now learned ;)
06:40:28 <laura_> thx
06:40:32 <haasn> laura_: your terms are the wrong way round - Integer is not an instance of Fractional
06:41:35 <laura_> About the pic from @Kaini:
06:41:59 <edwardk> laura_: we have quot and div for the two sensible versions of division for Integer. but they obey different laws than you'd expect for (/)
06:42:16 <johnw> morning, edwardk!
06:42:22 <edwardk> heya johnw
06:42:42 <laura_> Where is Integer included?
06:42:49 <laura_> Or how to understand the pic?
06:43:04 <haasn> “lenses tend to be bad at 'zipping things'.” we need zippable zippers
06:43:21 <edwardk> identity: that looks like somewhere you are using a lens as a value rather than the result of using the lens
06:44:33 <haasn> laura_: there is a hierarchy of type classes (Num, Integral, Fractional, Floating, RealFrac, RealFloat are the ones I can remember off the top of my head) - of which the various types (Integer, Double, Float etc.) are instances of (or not, depending on the type and typeclass)
06:44:54 <supki> identity: in getRandomR (-delta, delta) delta is a lens
06:45:10 <edwardk> laura_: you might want to just spend a little bit browsing the "Classes" section, which talks about what classes there are from the Prelude on http://zvon.org/other/haskell/Outputglobal/index.html it escribes what is in them, and names the standard instances below.
06:45:17 <edwardk> supki: aha
06:45:49 <edwardk> d <- use delta;   dX <- lift $ getRandomR (-d, d); ...
06:45:53 <identity> oh, god, of course. Silly my. I was passing delta to the stateFunction before
06:45:58 <haasn> laura_: roughly speaking: Num is stuff with (+), (*), negate/abs/signum and fromInteger;  Rational is still with rational (proper) division. Integral is stuff with integer (rounded) division and toInteger. Floating is stuff with irrational functions like sqrt, sin, cos etc.
06:46:00 <identity> eh, the markov function before
06:46:09 <merijn> laura_: The arrows indicate superclasses, i.e. anything that is an instance of Real *must* be an instance of Num too
06:46:23 <identity> thanks!
06:46:45 <haasn> RealFrac is stuff with toRational; and RealFloat is stuff with IEEE semantics (Infinity, NaN, denormalized numbers, mantissa/radix etc.)
06:47:07 <haasn> Integral and Fractional are disjoint
06:47:32 <haasn> And Floating stuff tends to be less precise than Fractional stuff
06:47:52 <haasn> Oh, I mixed my classes up
06:47:55 <haasn> Real is the one with toRational
06:47:58 <merijn> laura_: So you can see that Integer is an instance of "Integral" (it's listed in the Integral bubble), and every instance of Integral must be an instance of Real which must be an instance of Num, etc.
06:50:10 <haasn> I'm a bit confused as to the purpose of RealFrac actually; it seems like you could convert it to a Rational via Real's toRational and just get the properFraction out of that
06:50:20 <haasn> Is it just an optimization?
06:50:54 <k_bx> Hi everyone! I am doing something really wrong with aeson. Please take a look: https://gist.github.com/k-bx/3e5721644a9c27c4c0a1
06:51:04 <k_bx> I just want to encode/decode strict data instead of lazy
06:51:25 <laura_> thx for the details about the numerical stuff
06:52:05 <haasn> Kaini: are those all the Prelude typeclasses (+instances)?
06:52:41 <bennofs> Is this use of quickcheck ok, or is there a better way/library to do this: http://lpaste.net/99527 ?
06:53:16 <tdammers> k_bx: why would you do that?
06:53:30 <laura_> from what I understand now, is that the basic types (e.g. Integer, Int) have some general types (e..g Integral) and that a Double has superclass Floating...
06:53:36 <k_bx> tdammers: to store it in redis, for example
06:53:59 <tonnato> laura_: types aren't classes
06:54:06 <tonnato> there are no subtypes
06:54:23 <Feuerbach_> bennofs: that's a lot of code! :) maybe you can explain what's going on there?
06:54:25 <tonnato> there is no implicit type conversion
06:54:43 <bennofs> Feuerbach_: oh, ok
06:54:52 <laura_> What is the benefit to sum them up? Like to have an additional super (type?) for Integer and Int resp. for Float and Double?
06:54:55 <haasn> laura_: haskell types and type classes are not to be confused with OOP
06:55:16 <laura_> yeah, sorry, no classes - types...
06:55:23 <haasn> Integer, Int, Float and Double are all completely distinct and unrelated types not connected by any sort of relation
06:55:24 <laura_> thx for the explicit hint
06:55:28 <bennofs> Feuerbach_: I'll write a small example that is easier
06:55:39 <haasn> Each type can have any number of type class instances
06:56:09 <haasn> type classes exist for abstraction; eg. sum :: Num a => [a] -> a -- works on any type ‘a’, so long as that type has a Num a instance
06:56:22 <tdammers> k_bx: you're serializing a type that can only ever have one value. why?
06:56:26 <gspr> haasn: Well, some might say that "Int naturally includes in Integer" is a "relation" :)
06:56:37 <k_bx> tdammers: I simplified example
06:56:52 <tdammers> k_bx: a bit too much, it seems :D
06:56:55 <k_bx> tdammers: I want to understand why it can't encode -> decode itself
06:57:02 <haasn> gspr: fair enough, what I meant is some sort of explicit relation denoted in Haskell itself :)
06:57:04 <k_bx> tdammers: well it shows the problem :)
06:57:11 <haasn> not sure how to better phrase it but you probably know what I mean
06:57:13 <gspr> haasn: agreed :)
06:57:41 <haasn> (unlike classes, which *do* have relationships like   class Foo a => Bar a)
06:57:49 <laura_> so, the main benefit for the summary for e.g. Integral would be to write easier signatures?
06:57:58 <tdammers> k_bx: does the problem persist if you add some actual fields?
06:58:09 <k_bx> tdammers: sure, that's where it started at first
06:58:22 <k_bx> tdammers: and I think it shouldn't matter actually
06:58:24 <tdammers> k_bx: have you tried dumping the JSON representation to see what it contains?
06:58:53 <tdammers> k_bx: it shouldn't, but a value-less data type could just be one of those edge cases that people forget to test for
06:59:02 <tonnato> laura_: the advantage is being able to reuse code to work on both Ints and Integers
06:59:03 <k_bx> tdammers: yes, nothing unexpected
06:59:19 <tdammers> hmm
06:59:19 <haasn> laura_: it's not “easier”, since there's no way to write that function without type classes. You would have to write a sumInt :: [Int] -> Int; and a sumDouble :: [Double] -> Double; and a sumInteger :: [Integer] -> Integer etc., for every possible type
06:59:39 <k_bx> tdammers: actually you're right, for encoding empty one it's "[]", I'll re-work example. Sorry.
06:59:44 <haasn> or maybe something like a genericSum :: (a -> a -> a) -> a -> [a] -> a -- where you pass your own addition and 0 values
07:00:03 <haasn> but it's not possible to have the sort of automatically-instantiated ad-hoc polymorphism that type classes provide
07:00:36 <tdammers> k_bx: just "[]" isn't valid JSON IIRC... it'd have to be "{}"
07:00:42 <gspr> Since you guys are talking about this anyway now… something I've wondered ever since I started with Haskell is, why aren't functions such as length of type (Integral b) => [a] -> b?
07:00:56 <tonnato> data HasZero a = HasZero { zero :: a }; data HasPlus a = HasPlus { plus :: a -> a -> a }; sumGeneric :: (HasZero a, HasPlus a) -> [a] -> a
07:01:24 <tonnato> gspr: probably for efficiency reasons
07:01:56 <tdammers> "Int is a performance hack"
07:01:57 <gspr> tonnato: Couldn't that be worked around by SPECIALIZE pragmas for b = Int?
07:01:58 <tdammers> :D
07:02:20 <haasn> gspr: except that it would default to Integer not Int
07:02:31 <haasn> I'm sure there's a more involved reason, though
07:02:36 <k_bx> @tdammers http://lpaste.net/99563
07:02:36 <lambdabot> Unknown command, try @list
07:02:37 <gspr> haasn: Sure, the user would have to demand Int specifically
07:02:41 <k_bx> tdammers: http://lpaste.net/99563
07:02:44 <n0b> afaik length uses a genericLength
07:04:02 <tdammers> k_bx: that looks like it should work
07:04:11 <tdammers> or maybe I'm missing something
07:04:16 <k_bx> tdammers: exactly :D
07:04:33 <k_bx> tdammers: how do I convert strict byte string to lazy to check?
07:04:55 <identity> god damn, lens is friggin' magic
07:05:18 <n0b> !h
07:05:21 <edwardk> identity hah
07:05:24 <n0b> woops
07:05:55 <Feuerbach_> k_bx: there are toStrict and fromStrict functions
07:06:02 <Feuerbach_> in D.B.L
07:06:11 <tdammers> I doubt that's the problem though
07:06:28 <tdammers> if there is a bug, I think it's more likely to be in aeson than in bytestring
07:06:40 <Feuerbach_> no, I just answered the question
07:06:49 <Feuerbach_> I haven't looked at the issue yet
07:06:50 <k_bx> Feuerbach_: sorry, I was looking at old docs so couldn't find them before I think
07:06:51 <haasn> gspr: http://programmers.stackexchange.com/questions/211053/why-isnt-length-generic-by-default
07:07:05 <tdammers> Feuerbach_: sure, I didn't mean it that way
07:08:10 <tdammers> k_bx: there's eitherDecode variants of the decode functions
07:08:18 <tdammers> have you tried those to get an error description?
07:09:46 <k_bx> tdammers: will try now, thanks
07:11:21 <k_bx> http://lpaste.net/99564
07:11:27 <k_bx> "incomplete input"
07:11:51 <tdammers> yeah, saw it
07:11:55 <tdammers> strange
07:12:10 <tdammers> this almost smells like an off-by-one
07:12:24 <tdammers> for giggles, try appending a space before calling decodeStrict :D
07:14:17 <laura_> may I ask one additonal side-note to the type-basic?
07:14:19 <Eduard_Munteanu> Is there a generic templating engine, similar to what hamlet is for HTML but generic?
07:14:34 <bernalex> what's a way to figure out the path of a link using haskell?
07:14:39 <bernalex> i.e. readlink
07:14:44 <laura_> why do I have to convert length into an Integral to use it for (/)?
07:14:47 <Eduard_Munteanu> laura_: you can ask any question without asking to ask
07:15:10 * hackagebot git-gpush 3.0.0 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-3.0.0 (JohnWiegley)
07:15:12 <laura_> I thought it is already an Int
07:15:12 * hackagebot git-monitor 3.0.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.0.0 (JohnWiegley)
07:15:14 * hackagebot gitlib 3.0.0 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.0.0 (JohnWiegley)
07:15:16 <dcoutts> Eduard_Munteanu: there are untyped just string ones, like HStringTemplate
07:15:16 * hackagebot gitlib-cmdline 3.0.0 - Gitlib repository backend that uses the git command-line tool.  http://hackage.haskell.org/package/gitlib-cmdline-3.0.0 (JohnWiegley)
07:15:18 * hackagebot gitlib-cross 3.0.0 - Run tests between repositories  http://hackage.haskell.org/package/gitlib-cross-3.0.0 (JohnWiegley)
07:15:27 <ski> > replicateM 5 (randomRIO (0,100))  -- suOya ?
07:15:29 <lambdabot>  <IO [Integer]>
07:15:37 <Saizan> laura_: you have to convert it from Int to a Fractional type to use (/)
07:15:38 <laura_> I thought it is already an int
07:15:43 <Eduard_Munteanu> bernalex: unix's System.Posix.Files.readSymbolicLink
07:15:55 <bernalex> Eduard_Munteanu: a-hah! thanks.
07:15:57 <Saizan> laura_: or you could use div instead, which is integer division
07:16:12 <tdammers> k_bx: apparently decodeStrict uses attoparsec's parseOnly function, whereas decode uses parse
07:16:30 <ski> > length "caterpillar" `div` 4
07:16:31 <lambdabot>  2
07:16:38 <Saizan> > fromIntegral (10 :: Int) :: Double
07:16:39 <lambdabot>  10.0
07:16:47 <tdammers> k_bx: I'm not familiar enough with attoparsec to tell what the implications are, but I guess filing a bug for Aeson would be appropriate
07:16:59 <ski> > fromIntegral (length "caterpillar") / 4
07:17:00 <lambdabot>  2.75
07:17:01 <k_bx> tdammers: yep, will do something like that, thanks!
07:17:08 <tdammers> np
07:17:15 <Eduard_Munteanu> dcoutts: thanks, looks useful
07:17:19 <laura_> thx for the type-clarifications
07:17:24 <bennofs> Feuerbach_: http://lpaste.net/99565 -- Here is a more self contained version of my previous paste
07:17:24 <laura_> very helpful (for me)
07:17:55 <bennofs> Feuerbach_: what I'm trying to do is to use quickcheck to verify that whatever operation I apply on a model, the model still satisfies some invariants
07:18:39 <hsnoob> I have a design question : http://lpaste.net/99566
07:18:46 <bennofs> Feuerbach_: I cannot write an Arbitrary instance for the Model, because that would have to use the operations, and if they have bugs, I only get the test failure very late and it is hard to debug
07:19:26 <merijn> hsnoob: Oh, if you wanna use phantom types like this, you probably wanna read up on GADTs
07:19:31 <bennofs> Feuerbach_: With the approach taken in that paste, the error will be printed right after the operation has been performed. It is also possible to include a log of operations performed before by using a WriterT, for example.
07:19:42 <dcoutts> Eduard_Munteanu: fyi, it's what we use in the hackage server for both html and email templates
07:19:47 <merijn> hsnoob: The wikibook chapter on GADTs is pretty good: https://en.wikibooks.org/wiki/Haskell/GADT
07:20:19 <Eduard_Munteanu> Nice.
07:20:21 * hackagebot gitlib-libgit2 3.0.0 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.0.0 (JohnWiegley)
07:20:23 * hackagebot gitlib-s3 3.0.0 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-3.0.0 (JohnWiegley)
07:20:25 * hackagebot gitlib-sample 3.0.0 - Sample backend for gitlib showing the basic structure for any backend.  http://hackage.haskell.org/package/gitlib-sample-3.0.0 (JohnWiegley)
07:20:27 * hackagebot gitlib-test 3.0.0 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.0.0 (JohnWiegley)
07:21:16 <hsnoob> merijn: I'm not sure what you mean, that code compiles without GADT extension.
07:22:08 <Eduard_Munteanu> hsnoob: why are you using those ids in the first place?
07:22:12 <merijn> hsnoob: I know, I'm saying that if you want to enforce properties on phantom types, then GADTs are usually the best approach. Although I just realised this probably still doesn't solve your problem
07:22:28 <merijn> hsnoob: i.e. even that way I could still write "badIdea :: Id Person -> Id Land"
07:22:56 <hsnoob> Eduard_Munteanu: That's kinda the point of the question, I'm trying to move away from that design.
07:23:16 <merijn> Eduard_Munteanu: Well, what else would he do?
07:23:26 <merijn> hsnoob: I don't think there's anything inherently bad about this design
07:23:36 <Eduard_Munteanu> merijn: use the actual data structures as keys and values?
07:23:47 <merijn> Eduard_Munteanu: That's *really* inconvenient in a game
07:23:51 <Eduard_Munteanu> Or some unique field in it.
07:23:51 <Feuerbach_> bennofs: I see now. Well, I like your approach, and don't see anything wrong with it
07:24:00 <hsnoob> It feels very imperative to me.
07:24:27 <merijn> Eduard_Munteanu: Because if you update the owner of a Land, then you have to update Market as well, because what if the land whose owner changed was in Market's Set of land?
07:24:28 <Rc43> Why in Martin-Lof TT products are sigmas and functions are pi (products)?
07:24:50 <merijn> hsnoob: Well, that would be because a game state is really a rather imperative thing
07:24:55 <ski> Rc43 : because iterated sum is product, and iterated product is power
07:25:11 <Rc43> ski, wow
07:25:35 * ski blinks
07:25:36 <Eduard_Munteanu> Rc43: look at them as if they're sums of products, and products of sums
07:26:14 <hsnoob> merijn: What about something like FRP(pros/cons)?
07:26:29 <hsnoob> Or maybe I'm not understanding what FRP does
07:26:37 <Eduard_Munteanu> Rc43: an ordinary product A x B can be written as Sigma A (const B)
07:26:39 <Rc43> ski, Eduard_Munteanu, Ok, that makes sense; but where we get iterated sums and products?
07:27:04 <merijn> hsnoob: I personally think FRP is really cool, but it can be really confusing/intimidating when just starting. I would say the current approach would work better as a beginner project
07:27:21 <k_bx> tdammers: argh! It works with latest aeson (mine was 0.6.2.1, I think it was from latest platform)
07:27:21 <ski> Rc43 : not sure what you're asking now
07:27:58 <hsnoob> merijn: I've heard some of the FRP have problems because they build up records of past states, or something like this.
07:27:59 <merijn> hsnoob: I don't think the fact that it feels very imperative is a bad thing, sometimes that's just the easiest way to go. Forcefully trying to make it more functional will probably just make things more complicated
07:28:03 <Eduard_Munteanu> Rc43: sigma and pi are indexed... e.g. Sigma Bool F ~ F False + F True
07:28:15 <tdammers> k_bx: oy
07:28:24 <merijn> hsnoob: Yeah, there are "time" leaks in some FRP approaches, and in general no one has really decided on what the right way to do FRP is
07:28:25 <hsnoob> merijn: This seems like good advice.. :)
07:28:26 <tdammers> k_bx: no need to file a bug then :D
07:29:02 <k_bx> tdammers: ideally, platform shouldn't have these bugs, but.. :D
07:29:03 <merijn> hsnoob: You could even take it further and use ST for this instead of making your own "references" using Int
07:29:09 <Rc43> ski, Eduard_Munteanu, aa, got it; thanks.
07:29:10 <exicer> I'm using the persistent library, and trying to select a list of all users (so just mimicing select * from users). I can see I can use selectList [] [], but then don't really understand the type signature I should use.
07:29:16 <k_bx> tdammers: anyway, thanks for help
07:29:36 <hsnoob> merijn: In the real version I use MonadState and Lens so reads/writes/modify are less boilerplate
07:29:49 <merijn> hsnoob: See this paper: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.3299&rep=rep1&type=pdf
07:30:07 <merijn> hsnoob: (If that turns out to complex, you can just keep doing what you are doing now)
07:30:20 <merijn> hsnoob: But if you're comfortable with MonadState, it shouldn't be hard to follow
07:30:35 <hsnoob> Ohh I see, ST monad, ya I've thought about that, thanks for the link.
07:30:46 <Eduard_Munteanu> Rc43: also Pi... Pi (a : A) (F a) = (F a_0) x (F a_1) x ...   for some finite A.
07:31:13 <Eduard_Munteanu> Er , isomorphic, not equal.
07:32:27 <Rc43> Eduard_Munteanu, i.e. pointwise definition of function; clear now
07:32:32 <Eduard_Munteanu> Yep.
07:32:50 <ski> one man's isomorphism is another's equality
07:33:06 <jophish_> Yo yo yo
07:33:51 <Eduard_Munteanu> Rc43: note Pi and Sigma let you define dependent types, 'F a' there is type-level
07:34:09 <jophish_> Monad m => (a->b) -> Maybe a -> m Maybe b
07:34:27 <jophish_> I'm sure that this should be simple to do
07:34:53 <Eduard_Munteanu> arr for 'Kleisli m' basically.
07:34:54 <jophish_> Monad m => (a->m b) -> Maybe a -> m Maybe b -- I mean this
07:34:56 <Rc43> Eduard_Munteanu, ye, I asked it because looked at dependent types
07:35:05 <tdammers> k_bx: haskell is moving fast. bugs like this exist and get fixed all the time
07:35:08 <supki> :t traverse
07:35:09 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:35:13 <johnw> jophish_: return . fmap f
07:35:19 <tdammers> k_bx: the downside is that they sometimes slip through
07:35:26 <tdammers> k_bx: but the upside is that they get fixed
07:35:32 <ski> @type Data.Traversable.mapM :: Monad m => (a -> m b) -> (Maybe a -> m (Maybe b))
07:35:33 <lambdabot> Monad m => (a -> m b) -> Maybe a -> m (Maybe b)
07:35:47 <k_bx> tdammers: absolutely, I can live with that
07:35:52 <johnw> ski: ah, nice
07:36:08 <ski> johnw : also supki's suggestion
07:36:12 <Eduard_Munteanu> :t Data.Foldable.mapM
07:36:13 <bernalex> uhm so how do I return an IO FilePath? I thought return "" would do that
07:36:13 <lambdabot>     Not in scope: `Data.Foldable.mapM'
07:36:13 <lambdabot>     Perhaps you meant `Data.Foldable.fold' (imported from Data.Foldable)
07:36:21 <johnw> but traverse doesn't want an a -> b
07:36:21 <Eduard_Munteanu> :t Data.Foldable.mapM_
07:36:22 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
07:36:25 <merijn> bernalex: It should
07:36:37 <bernalex> according to ghc-mod, though, return "" is a [Char]. I guess the error is elsewhere.
07:36:51 <ski> johnw : neither does `mapM'
07:36:55 <bennofs> bernalex: [Char] = String = FilePath
07:36:55 <merijn> bernalex: But without code and an error there's not much we can say
07:37:00 <johnw> fair enough :(
07:37:03 <johnw> too early for me
07:37:05 <identity> does gloss not do anti-aliasing?
07:37:06 <bernalex> bennofs: exactly
07:37:15 <Eduard_Munteanu> bernalex: FilePath can refer to different things
07:37:16 <ski> (also note jophish_ corrected their query)
07:37:39 <Eduard_Munteanu> bernalex: are you using BasicPrelude by chance?
07:38:04 <bernalex> merijn: Couldn't match type `[Char]' with `IO FilePath'|| Expected type: IOError -> IO FilePath ||   Actual type: IOError -> [Char]
07:38:11 <bernalex> Eduard_Munteanu: IDK what that means
07:38:20 <bernalex> merijn: and the code as posted abvoe
07:38:40 <Eduard_Munteanu> BTW, do FilePath strings somehow fuse away? I'm slightly annoyed core libraries use String instead of Bytestrings.
07:39:01 <geekosaur> there are .ByteString variant modules for much of it
07:39:06 <johnw> :t return . fmap f
07:39:07 <lambdabot> (Monad m, Functor f, Show a, FromExpr b) => f a -> m (f b)
07:39:22 <merijn> Eduard_Munteanu: See Sytem.Posix.ByteString.FilePath
07:39:29 <bernalex> I guess the error might be in "readSymbolicLink l `catch` noLink" too.
07:39:31 <Eduard_Munteanu> geekosaur: for most things in System. there aren't really
07:39:37 <ski> @type (return .) . fmap
07:39:38 <lambdabot> (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
07:39:56 <bernalex> oh right
07:39:58 <bernalex> hurrr
07:40:00 <merijn> Eduard_Munteanu: On Windows ByteString would be incorrect, so doing it properly portable is annoying
07:40:04 <ski> @type Data.Traversable.mapM . (return .)
07:40:05 <lambdabot> (Monad m, Traversable t) => (a -> b) -> t a -> m (t b)
07:40:15 <Eduard_Munteanu> merijn: ah, I know 'unix' has them but they're far from being a complete System hierarchy
07:40:17 <bernalex> noLink _ = return "" -- not noLink = return ""
07:40:25 <Eduard_Munteanu> merijn: why would it be incorrect?
07:40:43 <merijn> Eduard_Munteanu: Because Windows file paths aren't byte strings?
07:40:48 <merijn> Eduard_Munteanu: They're unicode
07:41:12 <Eduard_Munteanu> merijn: er, are they really strings of unicode codepoints?
07:41:17 <geekosaur> yes
07:41:22 <Eduard_Munteanu> As opposed to some particular encoding? Hm.
07:41:24 <geekosaur> win32 api is utf18
07:41:25 <merijn> Eduard_Munteanu: They're enforced to be UTF-16 encoded unicode
07:41:32 <Eduard_Munteanu> Oh.
07:41:37 <merijn> geekosaur: No, they're not really unicode codepoints
07:41:39 <geekosaur> er utf16
07:41:40 <Eduard_Munteanu> Then Bytestring is exactly what you need.
07:41:41 <geekosaur> typing
07:41:56 <merijn> Eduard_Munteanu: No, because decoding UTF-16 to String is unambiguous
07:41:57 <tdammers> I thought they were restricted to the 16-bit fixed-width subset of UTF-16
07:42:18 <merijn> Eduard_Munteanu: Passing ByteString would allow users to specify invalid ByteStrings (i.e. non-UTF-16 bytestrings) which is an error
07:42:36 <merijn> String implicitly enforces all paths to be valid, as any String can be a valid UTF-16 ByteString
07:42:40 <jophish_> I'm not so sure that using Data.Traversable.mapM makes the code much cleaner than a case over Nothing or Just
07:43:04 <Sculptor> hi!
07:43:08 <Eduard_Munteanu> merijn: sure, but not all paths are valid anyway, are they? And if you read paths from the filesystem then you don't need to decode/encode at all.
07:43:51 <ski> jophish_ : `forM' probably looks nicer
07:43:58 * johnw hugs forM
07:43:59 <merijn> Eduard_Munteanu: All paths are valid in the sense that you can try to open/create them, the path you try to open may not exist, but that's an orthogonal issue
07:44:04 <Dodek> unix doesnt really care about what goes into pathname
07:44:06 <jophish_> form
07:44:16 <Eduard_Munteanu> Linux can use non-UTF8/ASCII encodings just fine with Bytestrings.
07:44:16 <merijn> Dodek: We were talking about Windows
07:44:19 <ski> jophish_ : for every element in the `Maybe'-container (there's at most one), do ...
07:44:25 <johnw> i tend to use forM instead of for, even when using Traversable, dunno why
07:44:29 <jophish_> yeah, I suppose so
07:44:34 <Dodek> ah, didn't scroll up high enough
07:44:44 <merijn> Also, the fact that *nix doesn't enforce encoding of file system entries is the hugest mistake since the invention of the null pointer
07:44:51 <ski> i suppose it's somewhat comparable to using `when'
07:45:14 * hackagebot conduit 1.0.13.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.13.1 (MichaelSnoyman)
07:45:16 * hackagebot conduit-extra 0.1.3 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.3 (MichaelSnoyman)
07:45:25 <Eduard_Munteanu> merijn: I'm not very sure, is "FOO:\ohai/" a valid path?
07:45:26 <merijn> Eduard_Munteanu: Now I give you a directory that has 1 file with UTF-8, 1 file with UTF-16 and one with UTF-32 encoding, how do you display the directory?
07:45:41 <bernalex> there should be a function that runs a functions and if there's an exception, gives a different expression
07:45:53 <jophish_> super, thanks all
07:45:58 <merijn> bernalex: You mean like everything in Control.Exception?
07:46:01 <tdammers> merijn: easy - use the current system locale :P
07:46:09 <bernalex> merijn: I mean so that you could do readSymbolicLink `lolol` "" -- instead of catching it to a function that needs a type signature and so on.
07:46:13 <bernalex> merijn: is there such a function?
07:46:15 <Eduard_Munteanu> merijn: if I don't know the encoding I can't display them ever, but if I use bytetrings I can pass them around without decoding
07:46:25 <ski> @type Control.Exception.mapException
07:46:26 <lambdabot> (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
07:47:10 <Eduard_Munteanu> bernalex: you can use getSymbolicLinkStatus first to check if it's really a symlink
07:47:22 <tdammers> Eduard_Munteanu: race condition...
07:47:38 <bernalex> Eduard_Munteanu: that throws an exception all the same if it's not a link at all
07:47:58 <xintron> I'm trying to get the hang of attoparsec. The problem I have is that if my `parseLine` fails I don't know how to skip that line, try the next etc and parse the whole file. Code: https://gist.github.com/xintron/b4040af8cb8c30455f36
07:47:58 <tdammers> Eduard_Munteanu: kind of theoretical, but if another process changes the symlink to an actual file between your check and the actual symlink resolving, it'll still fail
07:47:58 <Eduard_Munteanu> Reading the path pointed to by a symlink, without opening it through the symlink is racy too, no? :)
07:47:58 <bernalex> and IDC if it's not a link or if it's not a file at all. I just want to get what it links to, or "".
07:48:05 <Eduard_Munteanu> bernalex: no, it works on ordinary files too
07:48:11 <bernalex> Eduard_Munteanu: reread what I said
07:48:20 <bernalex> > getSymbolicLinkStatus "lolololololol"
07:48:21 <lambdabot>  Not in scope: `getSymbolicLinkStatus'
07:48:28 <bernalex> that will crash if there is no file lololololol
07:48:40 <jophish_> I'd like to use Data.Map as the output of a writer monad. Is it appropriate to add an instance of MonadPlus for Data.Map.Map in my code?
07:48:42 <Eduard_Munteanu> bernalex: oh, you can do doesFileExist first then
07:48:55 <bernalex> Eduard_Munteanu: and now we have more LOCs than catching the exception in the first place
07:49:13 <Eduard_Munteanu> Er, fileExist in 'unix'
07:49:23 <Eduard_Munteanu> Heh, fair.
07:49:41 <supki> jophish_: you can't, Map is not a Monad
07:49:45 <Eduard_Munteanu> jophish_: do you mean Monoid?
07:50:15 <jophish_> Eduard_Munteanu: yes
07:50:18 <hsnoob> :t mappend
07:50:19 <lambdabot> Monoid a => a -> a -> a
07:50:25 <Eduard_Munteanu> jophish_: then it already is AFAIK
07:50:45 <hsnoob> :t mplus
07:50:46 <lambdabot> MonadPlus m => m a -> m a -> m a
07:51:21 <Eduard_Munteanu> > mappend M.empty (M.fromList [(1, 'a')])
07:51:22 <lambdabot>  fromList [(1,'a')]
07:51:39 <Eduard_Munteanu> :t tell
07:51:39 <lambdabot> MonadWriter w m => w -> m ()
07:51:48 <jophish_> ah
07:52:09 <eacameron> when is Data.Sequence typically used?
07:52:39 <Eduard_Munteanu> eacameron: queues, random access pseudo-arrays...
07:52:52 <dgpratt> can someone tell me what is meant by "the non-deterministic choice for regexes" (from http://winterkoninkje.dreamwidth.org/90905.html) ?
07:52:57 <jophish_> ah, I didn't use fromList or singleton and got a whole bunch of misleading errors
07:53:17 <Eduard_Munteanu> eacameron: it performs best when you want to access both ends of it preferentially
07:53:21 <tdammers> > runWriter $ tell $ M.fromList [(1, "asdf")]
07:53:22 <lambdabot>  ((),fromList [(1,"asdf")])
07:53:34 <eacameron> Eduard_Munteanu: is it like a doubly linked list then?
07:53:42 <hsnoob> It's a three-finger tree right?
07:53:43 <Eduard_Munteanu> eacameron: no, it's a tree
07:54:17 <eacameron> Eduard_Munteanu: oh...interesting; why use it instead of "Tree"?
07:54:23 <Eduard_Munteanu> eacameron: I mean on the inside... on the inside the API leaves the impression of some sort of fast indexable list.
07:54:24 <ski> dgpratt : the union operation on the corresponding regular languages ?
07:54:39 <eacameron> Eduard_Munteanu: oh...got it
07:54:52 <dgpratt> ski, hmm...ok
07:54:56 <Eduard_Munteanu> eacameron: Tree isn't a fair comparison
07:55:10 <Eduard_Munteanu> eacameron: you can compare to Map/Set though
07:55:24 <eacameron> Eduard_Munteanu: Would one ever use it for a String with efficient appending
07:55:51 <ski> dgpratt : given regexen `R' and `S', a word `w' is accepted by `R + S' iff it is accepted by at least one of `R' and `S'
07:55:53 <Eduard_Munteanu> eacameron: not really, often you can eliminate appending
07:56:07 <Eduard_Munteanu> eacameron: how and why are you appending?
07:56:09 <eacameron> Eduard_Munteanu: Maybe *thats* what I need...how?
07:56:30 <dgpratt> ski, ok I think I kinda get it, thanks
07:56:48 <eacameron> Eduard_Munteanu: Well I'm not...I'm prepending an then reversing; it would be nice to just append though
07:56:53 <hsnoob> eacameron: An exercise that helped for me was to build a string using only function composition and the  cons (:) operator.
07:57:04 <Eduard_Munteanu> eacameron: depends on the usecase, what is the code doing?
07:58:47 <Eduard_Munteanu> eacameron: conceptually if you wrote something that's a left fold, what you want to do is rewrite it as a right fold; hence accumulating vs producing output as you go.
07:58:56 <eacameron> Eduard_Munteanu: It's a foldl over a "matrix" of rows/columns but it keeps track of a "stack trace"
07:59:13 <eacameron> Eduard_Munteanu: Wow...you predicted it!
07:59:33 <bernalex> hm. I just wrote my function. wonder if it exists somewhere.
07:59:40 <bernalex> fromJust . fromException . toException
07:59:48 <bernalex> oops, wrong chan
07:59:58 <ion> Hopefully not, fromJust is always bad.
08:00:03 <Eduard_Munteanu> eacameron: you can use Writer(T)
08:00:12 <bernalex> ion: uhm that's from ghc src
08:00:17 <hsnoob> < fromJust Nothing
08:00:26 <hsnoob> > fromJust Nothing
08:00:27 <lambdabot>  *Exception: Maybe.fromJust: Nothing
08:00:28 <Eduard_Munteanu> fromJust throws exceptions too :)
08:00:34 <eacameron> Eduard_Munteanu: never used that before
08:00:37 <ion> bernalex: GHC sources do contain bad things. :-P
08:00:48 <bernalex> catch io h = H'98.catch  io  (h . fromJust . fromException . toException)
08:00:51 <bernalex> is where that paste was from
08:01:02 <ski> bernalex> :t catch
08:01:03 <bernalex> my function is just orr _ = return
08:01:13 <bernalex> ski: ?
08:01:19 <eacameron> what's wrong with fromJust (filter isJust)?
08:01:20 <Eduard_Munteanu> eacameron: are you using mutable state, perhaps IO or ST?
08:01:32 <ski> bernalex : what is the type of (that) `catch' ?
08:01:34 <Eduard_Munteanu> :t catMaybes
08:01:35 <lambdabot> [Maybe a] -> [a]
08:01:58 <eacameron> Eduard_Munteanu: No, no; keeping track of state in each step of the fold
08:02:13 <eacameron> @src catMaybes
08:02:13 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:02:15 <ski> > [a | Just a <- [Just 0,Nothing,Just 1]]
08:02:16 <bernalex> ski: what do you mean? I just pasted the src of ghc catch, because ion said they hoped I didn't use fromJust in my paste, which they probably thought was from my own src.
08:02:16 <lambdabot>  [0,1]
08:02:27 <scshunt> is there an idiom for "optional" IO?
08:02:36 <prophile> "optional" IO?
08:02:44 <Eduard_Munteanu> eacameron: well if it's anything like a stack trace perhaps it's already in the right order, most stack traces show the innermost context first
08:02:45 <scshunt> that is, (Foo, IO ()) where the first element is some state you're processing on, and the second element is a log of what's happening?
08:03:09 <scshunt> so as you calculate on Foo, you can but don't have to thread IO actions along that cause side effects
08:03:26 <ski> (hm, `Writer (IO ())' ?)
08:03:42 <eacameron> Eduard_Munteanu: I'll toy with foldr and maybe Writer and see what I come up with
08:03:42 <prophile> ski: that needs a monoid instance for IO (), no?
08:03:43 <Eduard_Munteanu> You can use the free monad of IO.
08:03:43 <bernalex> hm. is there no such function in base? (f _ = return)
08:03:54 <ski> bernalex : you didn't give the type signature
08:03:57 <scshunt> I know this type will do what I want, but is there an idiomatic way to approach it?
08:04:08 <Eduard_Munteanu> bernalex: const return :)
08:04:08 <bernalex> ski: IO a -> a -> IO a
08:04:29 <eacameron> Eduard_Munteanu: Thanks, btw
08:04:45 <bernalex> Eduard_Munteanu: how do I put that in a ``? :-P
08:04:45 <scshunt> for instance, to compose functions of signature Foo -> (Foo, IO ())
08:04:47 <hsnoob> scshunt: Is it something monad transformer library can solve? https://hackage.haskell.org/package/mtl-2.1.2
08:05:10 <scshunt> I guess (a, IO ()) could be a monad here
08:05:12 <Eduard_Munteanu> bernalex: hm, I found myself wishing for an extended `` too
08:05:13 <ski> bernalex : surely the second argument has to be a function ?
08:05:20 <bernalex> ski: ? why
08:05:37 <bernalex> ski: orr ::  IO a -> a -> IO a; orr _ = return
08:05:45 <ski> @type ?h . fromJust . fromException . toException
08:05:46 <lambdabot> (?h::b -> c, Exception b, Exception a) => a -> c
08:05:51 <scshunt> bernalex: const
08:05:58 <Eduard_Munteanu> :t (&&&)
08:05:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:06:00 <ski> bernalex : i was talking about the `catch' you gave, not `orr'
08:06:12 <bernalex> ski: the catch doesn't have anything to do with my function
08:06:14 <Eduard_Munteanu> Meh.
08:06:16 <bernalex> catch was from ghc.
08:06:28 <ski> bernalex : still i was asking about `catch', not about `orr' :)
08:06:36 <identity> > do {x <- return 3; print x; x <- return 4; print x}
08:06:37 <lambdabot>  <IO ()>
08:06:40 <identity> eh
08:06:48 <bernalex> ski: what are you asking about? it's the default catch in ghc
08:07:00 <bernalex> you can look it up in the ghc src if you are curious about it
08:07:06 <Eduard_Munteanu> scshunt: why would you mix IO and pure functions anyway?
08:07:33 <ski> bernalex : it wasn't clear which `catch' you were talking about
08:07:42 <Taneb> :( overlapping instance for MonadIO Game
08:07:48 <ski> (e.g. it might have been some locally defined one)
08:07:50 <Taneb> (free-game)
08:07:50 <scshunt> Eduard_Munteanu: logging code
08:08:15 <scshunt> oh shit, I've got to go. will follow up later
08:08:15 <Eduard_Munteanu> scshunt: use Writer then.
08:08:27 <jophish_> Here is the problem: I'm renaming terms in some scoped source code (Haskell like) using some function rename :: String -> Rename (String, Int). I'd like to have the current environment sent in as a Reader input, so I can use local when entering a sub scope. Each term in a scope will look up its name in the reader environment and if it's already there then we know to what it's referring, otherwise it will have to create a
08:08:27 <jophish_> new unique for itself.
08:09:02 <jophish_> I thought it would be super cool to write the uniques out to a writer, and tie the knot, feeding the output of a scope into itself as a reader
08:09:16 <scshunt> Eduard_Munteanu: but how do I use Writer when the log is an IO stack, not necessarily a list?
08:09:27 <jophish_> the problem is I'm getting loops, because the terms try to look themselves up in the map before creating a new name for themselves
08:09:40 <Eduard_Munteanu> scshunt: what do you mean "IO stack"?
08:09:59 <jophish_> I'm sure that there is a really elegant solution for this, I'm just not sure how to go about it
08:10:10 <scshunt> Eduard_Munteanu: A series of IO actions. My log in this case might be more complex than just developing a list of things to output
08:10:16 <johnw> scshunt: have a list of IO actions
08:10:20 <scshunt> eventually it might even be interactive
08:10:34 <scshunt> but I haven't really thought about tha tyet
08:10:35 <scshunt> *that
08:10:46 <jophish_> A very similar problem would be labelling nodes in a graph
08:10:47 <scshunt> I'm definitely sure that the computation side of things should be pure, though
08:10:57 <ski> scshunt : you could define `newtype Log = L (IO ())', making it an instance of `Monoid'
08:11:30 <johnw> [IO ()] is already a Monoid
08:11:31 <Eduard_Munteanu> Also 'IO a' is (almost) a Monoid already for fixed 'a', but probably not what you want.
08:11:54 <Eduard_Munteanu> (I mean in the MonadPlus sense)
08:12:43 <scshunt> all right, thanks
08:12:54 <Eduard_Munteanu> ski is probably suggesting the Monoid for which mappend = (>>)
08:14:51 <merijn> What would mempty be for that Monoid?
08:15:03 <Eduard_Munteanu> merijn: return ()
08:15:36 <Eduard_Munteanu> It's the same idea as [IO ()].
08:15:40 <merijn> Eduard_Munteanu: That only works for IO ()
08:15:58 <ski> merijn : yes
08:15:58 <merijn> You mentioned for for any fixed 'a'
08:16:11 <Eduard_Munteanu> merijn:  < ski> scshunt : you could define `newtype Log = L (IO ())'
08:16:12 <ski> the `IO a' thing is another one
08:16:12 <johnw> isn't there an Endo for Kleisli arrows?
08:16:24 <johnw> but I doubt that's what he would want here
08:16:25 <ion> Another alternative: return mempty
08:16:29 <Eduard_Munteanu> merijn: that was about the MonadPlus monoid.
08:16:49 <ski> @type liftM2 mappend
08:16:50 <lambdabot> (Monad m, Monoid r) => m r -> m r -> m r
08:16:52 <Eduard_Munteanu> merijn: which is completely different, hence "probably not what you want)
08:17:16 <hsnoob> :t mplus
08:17:17 <lambdabot> MonadPlus m => m a -> m a -> m a
08:18:27 <Eduard_Munteanu> (instance Monoid (IO a) where mempty = mzero; mappend = mplus)
08:18:40 <hsnoob> :t return mempty
08:18:41 <lambdabot> (Monad m, Monoid a) => m a
08:19:31 <hamid> :t return (mempty :: Maybe)
08:19:32 <lambdabot>     Expecting one more argument to `Maybe'
08:19:32 <lambdabot>     In an expression type signature: Maybe
08:19:32 <lambdabot>     In the first argument of `return', namely `(mempty :: Maybe)'
08:19:47 <hamid> :t return mempty :: Maybe
08:19:48 <lambdabot>     Expecting one more argument to `Maybe'
08:19:48 <lambdabot>     In an expression type signature: Maybe
08:19:48 <lambdabot>     In the expression: return mempty :: Maybe
08:20:17 <ski> @type return (mempty :: Maybe a)
08:20:18 <lambdabot>     Could not deduce (Monoid a1) arising from a use of `mempty'
08:20:18 <lambdabot>     from the context (Monad m)
08:20:18 <lambdabot>       bound by the inferred type of it :: Monad m => m (Maybe a)
08:20:32 <johnw> @type return (mempty :: Monoid a => Maybe a)
08:20:33 <lambdabot> (Monad m, Monoid a) => m (Maybe a)
08:20:34 <ski> @type return (mempty `asTypeOf` Nothing)
08:20:35 <lambdabot> (Monad m, Monoid a) => m (Maybe a)
08:20:39 <hsnoob> :t return (mempty :: Maybe [])
08:20:40 <lambdabot>     Expecting one more argument to `[]'
08:20:40 <lambdabot>     In an expression type signature: Maybe []
08:20:40 <lambdabot>     In the first argument of `return', namely `(mempty :: Maybe [])'
08:20:48 <hsnoob> :t return (mempty :: Maybe [a])
08:20:49 <lambdabot> Monad m => m (Maybe [a])
08:21:03 <impredicative> Hello. As it's my first time here, I thought I'd just check whether asking random questions in case anybody knows the answer is appropriate?
08:21:30 <ski> impredicative : more or less, as long as it's tangentially related to Haskell
08:21:33 <int-e> impredicative: We really prefer questions about Haskell.
08:21:45 <impredicative> Oh, certainly, it's a Haskell question!
08:21:47 <johnw> i.e., random over a fix domain is OK
08:22:08 <hamid> why this doesn't work?  "return (mempty :: Maybe a)" by what i get this should be ok
08:22:18 <tdammers> hsnoob: you know you can /msg lambdabot, right?
08:22:32 <hsnoob> No I didn't
08:22:40 <tdammers> you do now :D
08:22:48 <impredicative> So, Vinyl uses type-level lists, but infers, say `type Foo = ["hello" ::: String] as being of kind * rather than of kind [*]
08:23:07 <impredicative> I'm wondering if there's a way to construct the list of just a single element
08:23:22 <mr-> hamid: Maybe a is not a monoid
08:23:25 <merijn> impredicative: A type level list you mean?
08:23:37 <impredicative> Maybe? What's the difference?
08:23:38 <hamid> mr-, not? hmm oh then alright thought it is.
08:23:39 <merijn> impredicative: i.e. [*] ?
08:23:42 <impredicative> Yes
08:23:45 <impredicative> Indeed
08:23:52 <merijn> impredicative: You can with the DataKinds extension
08:24:08 <ski> @hackage vinyl
08:24:08 <lambdabot> http://hackage.haskell.org/package/vinyl
08:24:09 <mr-> hamid: a needs to be at least a Semigroup, I think
08:24:17 <jophish_> This is the function I'm using to get and set the names of terms: http://lpaste.net/99568
08:24:24 <merijn> impredicative: See this example using that: https://gist.github.com/merijn/6130082
08:24:43 <jophish_> This just <<loop>>s trying to ask the reader state
08:25:12 <merijn> impredicative: It defines a type family that takes a * and [*] (actually, that's a lie, it takes kinds other than * too!) and checks that the type isn't in the list
08:25:22 <jophish_> Is what I'm trying to do possible even?
08:26:03 <impredicative> merijn: Ah, thanks. I'm not sure I understood the whole example (though I'll try to), but it gave me enough to solve the problem!
08:26:39 <impredicative> merijn: Which was just knowing that one can denote the empty type level list as `'[]`
08:26:59 <hamid> mr-, I have no idea what a semigroup type is :)
08:27:06 <merijn> impredicative: It's not very hard, it defines a TypeFamily (i.e. type level function) that takes a * and [*] and returns a Constraint (another example of a constraint would be "Eq a" or "Monad m")
08:27:35 <mr-> hamid: the point is that you need a way to "add" (Just "foo") and (Just "bar"), which boils down to having a way to add "foo" and "bar"
08:27:38 <merijn> impredicative: If the first type is *not* in the list, it just returns an empty (always valid) constraint
08:27:42 <hamid> mr-, maybe you can give me a link?
08:28:04 <merijn> impredicative: If the first type *is* in the list, it returns the constraint "("Error!" ~ "Tried to apply a restricted type!")", here ~ is type level equality
08:28:23 <merijn> impredicative: Now, obviously those two types are *not* equality, so the constraint never holds (i.e. it's a type error)
08:28:30 <hsnoob> (Just ("foo",(Just "bar",Nothing))
08:28:31 <int-e> jophish_: are you passing the map returned from the writer back to the RWS as reader's "state"? If so, no, that won't work.
08:28:42 <merijn> impredicative: The main reason to define it like that is so that those two strings get printed when the type error occurs, so it can help debugging
08:28:48 <impredicative> merijn: Okay, that makes sense, I think!
08:28:49 <hamid> mr-, right I get that :) thank you.
08:28:52 <jophish_> int-e: that's right. What other idioms are there for doing something like this
08:29:15 <merijn> impredicative: So basically "foo 'a'" returns 'a' (it's just id, after all) but "foo ()" returns a type error
08:29:30 <merijn> impredicative: Since () is in [(), Int]
08:29:43 <jophish_> int-e: I suppose that I could use the state for things in the current scope and the reader for things in parent scopes
08:29:45 <impredicative> That makes sense
08:29:45 <int-e> jophish_: informally, you have a time traveller's paradox in that code: you add something to the map if it's not in the map, but once added it will always have been in the map. in practice, such paradoxes make the value undefined.
08:29:52 <merijn> impredicative: Or rather, not "returns a type error" but "it IS a type error"
08:30:08 <impredicative> merijn: Yeah
08:30:19 <int-e> jophish_: you really need a state monad for such things, I believe.
08:30:20 * hackagebot hruby 0.2.4 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.4 (SimonMarechal)
08:30:28 <jophish_> int-e: yeah, I was hoping that there would be some magic behind the scenes sorting all that out
08:30:40 <mr-> hamid: and a semigroup is a Monoid that does not have a 0. It only knows how to add
08:31:08 <mr-> hamid: So there's also an instance Monoid a => Monoid (Maybe a) defined in Data.Monoid
08:31:25 <hamid> mr-, ow! yeah i see that
08:32:13 <impredicative> merijn: I think in my case I was just struggling with the syntax for type level lists - namely, that `type Foo = [Int, ()]` is treated as being kind [*], but `type Foo = [Int]` is treated as being kind *
08:32:36 <impredicative> So instead I've declared `type Foo = Int ': '[]` and that works
08:33:34 <int-e> jophish_: it's not completely impossible. you can use 'tell' to accumulate the used name into a set; pass that into the getTopLevelName, and create unique names for all elements of the set before starting the actual computation. If the monads are sufficiently lazy, that should work.
08:33:53 * ski thinks the attempt at punning tuple and list values with respective types (and constraints) was a mistake
08:34:07 <int-e> jophish_: Note that the uniqueness is ensured by the intermediate 'Set' result, rather than on the fly.
08:34:17 <int-e> jophish_: I'd prefer the State monad solution.
08:34:34 <jophish_> int-e: that's a good idea. There needs to be some knot tying involved I think though
08:34:38 <jophish_> int-e: consider something like: let a = b; b = a; in ...;
08:35:04 <int-e> jophish_: the knot is tied the same way as before - take the writer output, pass it into the monad action.
08:37:10 <jophish_> int-e: I'll let you know how I get on. Thanks for the help
08:37:21 <int-e> jophish_: The key difference with computing a Set, and then annotating it with unique names, is that the writer output can be computed (in principle, at least) without touching the input value that it generates.
08:38:21 <ski> int-e : sounds vaguely `repMin'-related
08:38:27 <int-e> jophish_: (I say "in principle" because there are still quite a few possible ways for this to fail in the end.)
08:39:23 <int-e> ski: is that the single pass "repeat (length l) (minumum l)" exercise? If so, yes, that's similar.
08:39:59 <ski> int-e : yes, except usually stated for a tree
08:40:53 <ski>   repMin :: Ord a => Tree a -> (a,a -> Tree a)
08:40:59 <ski> being one way to stage it
08:42:59 <int-e> repMin :: Ord a => Tree a -> a -> (a, Tree a) -- hey this looks like a state monad.
08:43:04 <merijn> impredicative: Just writing '[Int] should work too
08:43:20 <merijn> impredicative: The ' disambiguates between a type of kind * and a type of kind [*]
08:43:29 <impredicative> @merijn Oh, really? Cool
08:43:29 <lambdabot> Unknown command, try @list
08:43:38 <impredicative> merijn: Oh, really. Cool!
08:43:46 <impredicative> merijn: Thanks
08:44:14 <int-e> @hoogle Min
08:44:15 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Min :: BlendEquation
08:44:15 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax module Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax
08:44:15 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters type MinificationFilter = (TextureFilter, Maybe TextureFilter)
08:44:21 <ski> int-e : heh. my variant looks more like a state-in-context comonad :)
08:45:29 <int-e> ski: I was going to suggest a WriterT (Min a) (ReaderT a), but then I discovered that Data.Monoid has no 'Min'.
08:46:06 <bennofs> @hoogle Min +semigroup
08:46:07 <lambdabot> Could not find some databases: semigroup
08:46:07 <lambdabot> Searching in:
08:46:07 <lambdabot>   .
08:46:20 <ski> @type uncurry (flip ($))
08:46:20 <lambdabot> (a, a -> c) -> c
08:46:22 <ski> @type snd . fix . (. fst)
08:46:23 <lambdabot> (b -> (b, c)) -> c
08:46:27 <bennofs> @hoogle Min +semigroups
08:46:28 <lambdabot> Could not find some databases: semigroups
08:46:28 <lambdabot> Searching in:
08:46:28 <lambdabot>   .
08:46:40 <bennofs> Hmm, semigroups does have Min though
08:50:16 <mr-> Min?
08:50:43 <mr-> indeed
08:50:58 <int-e> mr-: it should come with an  instance (Bounded a, Ord a) => Monoid (Min a)
08:51:47 <int-e> mr-: the monoid would have  maxBound  as its neutral element and  min  as binary operation. (All wrapped in a newtype to keep the Haskell type system happy.)
08:52:23 <mr-> Yeah, I see. It does have Min, though
08:52:29 <mr-> http://hackage.haskell.org/package/semigroups-0.8/docs/Data-Semigroup.html
08:52:39 <mr-> Or used to have?
08:52:40 <int-e> mr-: Data.Monoid doesn't.
08:52:51 <mr-> Oh, right sorry
08:53:16 <johnw> I prefer using Semigroup these days until I find that I actually need mempty
08:54:15 <int-e> Is there a Semigroup version of Writer?
08:54:33 <johnw> not that I know of
08:54:47 <prophile> how would that work?
08:54:50 <johnw> it would need a different type for runWriter too
08:54:58 <int-e> prophile: you just need to give an initial value
08:55:02 <johnw> runWriter :: Writer w a -> w -> (a, w)
08:55:09 <int-e> johnw: right.
08:55:18 <jophish_> int-e: Sadly I don't think that this works, not with Set anyway. I think that this may be because the Set that the writer outputs is strict in the monad's evaluation
08:55:39 <prophile> you'd have to do it with the state monad
08:55:43 <jophish_> when I tie the knot I convert the Set into a Map
08:55:58 <johnw> creating SemiWriter would be fairly trivial
08:58:10 <int-e> @hoogle Arctic
08:58:10 <lambdabot> No results found
08:58:32 <hsnoob> This has confused me a bit.  Could someone provide an example of when you would use maybe monoid First
08:58:46 <johnw> "maybe monoid First"?
08:58:52 <hsnoob> :t getFirst
08:58:53 <lambdabot> First a -> Maybe a
09:00:23 * hackagebot diagrams-svg 1.0.1.3 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.1.3 (BrentYorgey)
09:00:25 <johnw> i still don't understand your question
09:01:00 <int-e> > getFirst . msum . map First $ [1..10]
09:01:01 <lambdabot>  Could not deduce (Control.Monad.MonadPlus Data.Monoid.First)
09:01:01 <lambdabot>    arising from a use of `Control.Monad.msum'
09:01:01 <lambdabot>  from the context (GHC.Enum.Enum (Data.Maybe.Maybe a),
09:01:01 <lambdabot>                    GHC.Num.Num (Data.Maybe.Maybe a))
09:01:01 <lambdabot>    bound by the inferred type of
09:01:20 <quchen_> mconcat, not msum :-)
09:01:54 <quchen_> hsnoob: You have a bunch of things (possibly infinitely many) that might fail, but you only need one of the solutions. Using First, you can evaluate the entire thing, and automatically abort when a solution was found.
09:02:10 <int-e> > getFirst . mconcat . map (First . Just) $ [1..10]
09:02:11 <lambdabot>  Just 1
09:02:16 <int-e> > getFirst . mconcat . map (Last . Just) $ [1..10]
09:02:17 <lambdabot>  Couldn't match type `Data.Monoid.Last a1'
09:02:17 <lambdabot>                with `Data.Monoid.First a0'
09:02:17 <lambdabot>  Expected type: Data.Maybe.Maybe a1 -> Data.Monoid.First a0
09:02:17 <lambdabot>    Actual type: Data.Maybe.Maybe a1 -> Data.Monoid.Last a1
09:02:24 <int-e> > getLast . mconcat . map (Last . Just) $ [1..10]
09:02:25 <lambdabot>  Just 10
09:03:25 <hsnoob> quchen_: Ohh, I think I get it now.
09:03:27 <quchen_> First is very of similar to the "try this(, if it doesn't work try this)*" pattern.
09:04:39 <int-e> `First` is the monoid underlying the `mplus` from the `MonadPlus` instance of `Maybe`.
09:04:41 <quchen_> More often you're using the Alternative/MonadPlus version of it, which acts similarly.
09:05:20 <quchen_> So for example when you're using a parser, you're often doing something like  `asum [dot, colon, letter]`, which tries to parse a dot, and if there is no dot it tries colon, and if there is no colon it tries a letter.
09:06:14 <darthdeus> so i've been reading a bunch about category theory, and i'm still struggling a bit to get the intuition for what a category actually is
09:06:28 <quchen_> It's so simple it's complicated ;-)
09:06:48 <laura_> in the wikibook one of the exercises it to generate a fact-list. This version works
09:06:49 <laura_> factList n =  foldr1 (*) ( takeWhile (<=n) [1..]): factList (n-1)
09:06:55 <laura_> but this fails
09:06:59 <darthdeus> my understanding is that if i have a "set" of objects, which is any abstract thing, and a set of morphisms, which are like functions on those objects (i know people say they're not functions, but pls bear with me), then i can call that group of groups a category, right?
09:07:04 <laura_> factList n =  factList (n-1): foldr1 (*) ( takeWhile (<=n) [1..])
09:07:18 <darthdeus> so it's kinda like a group, but instead of numbers and operations i have objects and morphisms?
09:07:20 <laura_> which is just to get the last element to first
09:07:42 <quchen_> A category is literally a "bunch" of objects and a "bunch" arrows between those objects, subject to the arrow laws (namely there is an identity and composition is associative).
09:07:42 <laura_> hint?
09:07:52 <hsnoob> The base of Category theory is morphisms (function), composition (.), and the identity morphism
09:07:55 <quchen_> "this fails" is not an error description.
09:08:10 <darthdeus> ok good
09:08:34 <JagaJaga> hi guys, how to add additional folder for ghc-pkg to watch?
09:08:42 <laura_> sorry, error says : Occurs check: cannot construct the infinite type: a0 = [a0]
09:08:54 <int-e> laura_: (:) takes a list element as its first argument and a list as its second.
09:09:02 <darthdeus> i still don't understand how a morphism/arrow is different from a function
09:09:06 <darthdeus> as in pure function
09:09:10 <int-e> laura_: to "reverse" x : xs, you need to write  xs ++ [x].
09:09:12 <darthdeus> they're both a mapping from X -> Y no?
09:09:38 <byorgey> darthdeus: no, 'morphism' is very abstract.  It need not correspond to any sort of "mapping".
09:09:51 <darthdeus> i've read something about different morphisms, but for example monomorphism is just like a function with an inverse function?
09:10:01 <byorgey> a morphism is just a "thing" with a "source" object and a "target" object.
09:10:05 <darthdeus> byorgey: really? "morphism refers to a structure-preserving mapping" :o
09:10:25 * hackagebot smallcaps 0.3.0.0 - A library and a program for pre-processing LaTeX files  http://hackage.haskell.org/package/smallcaps-0.3.0.0 (StefanBerthold)
09:10:29 <darthdeus> but how's that different from a function?
09:10:33 <hsnoob> Or Domain -> Codomain
09:10:37 <byorgey> darthdeus: unfortunately, that is a somewhat different (though related) use of the word morphism.
09:10:45 <johnw> darthdeus: a monomorphism is an injective homomorphism :)  wasn't that easy?
09:10:48 <darthdeus> domain -> codomain == X -> Y?
09:10:54 <int-e> laura_: (I'd like to add that this is probably a bad idea because building an n-element list by appending singleton lists has quadratic complexity.)
09:10:59 <jophish_> int-e: I've got it working
09:11:22 <johnw> but to put it more simply, f is a monomorphism if it "cancels on the left": f . g = f . h => g = h
09:11:42 <laura_> @int-e: Why quadratic?
09:11:42 <lambdabot> Unknown command, try @list
09:11:50 <darthdeus> johnw: so if i take any injective function i can think of it as a monomorphism?
09:11:52 <byorgey> darthdeus: morphisms/arrows in a category are not necessarily structure-preserving mappings.
09:11:53 <laura_> @int-e the solutions worx
09:11:53 <lambdabot> Unknown command, try @list
09:12:01 <darthdeus> like if i have (+1) and compose with (-1) it has a left inverse, right?
09:12:13 <darthdeus> uhm
09:12:21 <johnw> darthdeus: prove that it cancels on the left
09:13:03 <laura_> I thought its lazy evaluating the things, therefore I don't get the quadratic issue here
09:13:04 <darthdeus> well i have +, and if i compose (+1) and (-1) i get "id" for +
09:13:06 <ReinH> darthdeus: well, you'd have to compose with (subtract 1) ;)
09:13:13 <int-e> jophish_: congrats
09:13:15 <darthdeus> yeah that
09:13:23 <byorgey> darthdeus: if I were you I would not try so hard to get an "intuition" for what a category "is".
09:13:30 <byorgey> darthdeus: just understand the definition and look at lots of examples.
09:13:37 <ski> laura_ : the IRC convention to direct a message to a specific person is to start the message with their nickname (no initial `@'), possibly followed by a comma or a colon
09:13:49 <johnw> darthdeus: yes, (+1) is monomorphic, but it's more interesting to talk about monomorphisms of polymorphic functions
09:13:57 <darthdeus> byorgey: i'm trying :D but i still don't see an example that'd show me how functions are not arrows
09:14:22 * ski . o O ( "polymorphisms" )
09:14:25 <int-e> laura_: xs ++ ys takes linear time in the length of xs; (([1]++[2])++[3])++[4])++... appends to elements of length 1,2,3,etc, for a total of 1+2+3+...+n = n*(n+1)/2.
09:14:26 <johnw> darthdeus: the opposite, btw (cancels on the right) is an epimorphism
09:14:41 <johnw> if you have mono and epi, you have an iso (at least in some categories)
09:14:46 <ReinH> darthdeus: functions are arrows in certain categories
09:14:58 <ski> johnw : it's called "bimorphism", iirc
09:14:59 <hsnoob> darthdeus it helps to think of two sets {John, Susie, Barry} and what band they like {Beatles, AC/DC, Rolling Stones}.  Then answer questions like: how many morphisms from set A to B, what if you end up with a codomain with few objects than the domain (can you get back to the domain), etc...
09:15:09 <byorgey> darthdeus: consider the category with a single object, and an arrow from that object to itself for each natural number
09:15:09 <ReinH> darthdeus: but not all arrows are functions
09:15:17 <johnw> darthdeus: the book "Introduction to Conceptual Mathematics" has several chapters devoted to monos and epis
09:15:20 <byorgey> darthdeus: to compose two arrows, you add the numbers
09:15:38 <darthdeus> hsnoob: so if i have that i have isomorphism?
09:15:46 * johnw thinks it's call that Google can make it look like you know stuff
09:15:52 <johnw> s/call/cool
09:15:53 <byorgey> darthdeus: I leave it as an exercise for you to prove that this is really a category.
09:16:14 <byorgey> and, of course, natural numbers are not functions.
09:16:16 <ReinH> darthdeus: consider a category where objects are integers, arrows are matrices (an arrow f : 2 -> 3 is a 2x3 matrix), and composition is matrix multiplication
09:16:31 <jophish_> int-e: there are a couple of things I don't understand about it though, primarily this: http://lpaste.net/99570
09:16:33 <ReinH> sorry, objects are natural numbers
09:16:46 <ReinH> darthdeus: those arrows are not functions
09:16:52 <laura_> ski: thx for the hint
09:16:57 <jophish_> When things are replaces with the commented out code, it loops
09:17:03 <jophish_> replaced*
09:17:03 <darthdeus> hmm
09:17:09 <jophish_> the code that's there works fine
09:17:16 <darthdeus> johnw: i think i need to read that book
09:17:27 <johnw> it's an enjoyable book, if you like this sort of thing
09:17:35 <ReinH> johnw: which book?
09:17:44 <johnw> intro to conceptual math by Lawvere
09:17:46 <hsnoob> That's the book by lawvre right?
09:17:47 <ReinH> ah
09:17:53 <johnw> with nice pictures, we could call it LYACT
09:17:58 <ReinH> hahaha
09:18:00 <darthdeus> lol
09:18:08 <ReinH> someone should actually write that
09:18:09 <darthdeus> LYACT is exactly what i need
09:18:20 <johnw> some people call it the "baby book", but it's perfect if you are a CT baby like me
09:18:22 <laura_> int-e: I understand the argument, BUT
09:18:24 <ReinH> darthdeus: there are also some nice lectures on youtube by Awodey and TheCatsters
09:18:46 <jophish_> I can't really explain what's going on there, As fas as I can tell, returning a Maybe b from find makes it strict in the list
09:18:54 <laura_> isn't that true for the oposite append as well (I mean, reverse is reverse...)
09:18:56 <darthdeus> ReinH: yeah i watched the first one by Awodey but i don't understand much from it
09:19:12 <johnw> I found Awodey a bit advanced if you don't already have a strong math background
09:19:16 <byorgey> darthdeus: if you want some intuition, think of a category as "a collection of things that compose" (i.e. the arrows)
09:19:24 <johnw> but after Lawvere Awodey can be a revelation, he really nails some things nicely
09:19:26 <byorgey> the objects are just there to tell you which arrows you are allowed to compose.
09:19:36 <hsnoob> Ya, the Awodey book is a bit more difficult
09:19:57 <darthdeus> byorgey: hmm, that sort of makes sense
09:19:58 <ReinH> the objects are boring and can be recovered by the identity arrows anyway
09:20:03 <johnw> Awodey likens category theory to the "algebra of functions"
09:20:09 <darthdeus> so the objects are sort of constraints on the arrows?
09:20:20 <rola> Awodey has a older version (draft?) of his book online here http://www.andrew.cmu.edu/course/80-413-713/notes/
09:20:37 <johnw> yeah, objects are only there to pin the arrows, of themselves they are meaningless
09:20:51 <ReinH> darthdeus: would you say that f :: Int -> Int is a constraint on f?
09:21:01 <darthdeus> ReinH: yes
09:21:28 <darthdeus> it restricts what f can haz
09:21:48 <ReinH> darthdeus: f is an arrow in the category Hask of haskell types and functions
09:22:05 <darthdeus> that i read in the typeclassopedia yesterday
09:22:09 <int-e> jophish_: all I see is that the reformulation (after correcting a type error) delays the 'lookup' call. It's akin to omitting the
09:22:09 <darthdeus> and i was like "wtf is Hask category"
09:22:21 <int-e> jophish_: to omitting the 'case' statement altogether.
09:22:26 <ReinH> darthdeus: it's just a category where objects are haskell types and arrows are haskell functions
09:22:28 <johnw> darthdeus: and the more you read, the more you'll be asking that :)
09:22:36 <ReinH> f is an arrow from the object Int to the object Int
09:22:42 <ReinH> i.e. it's an automorphism
09:22:58 <jophish_> int-e: what do you mean by reformulation?
09:23:17 <int-e> jophish_: I really don't want to look any deeper into this. It'll probably end up with reasoning about the internals of the RWS monad.
09:23:27 <dmj> jle`: ping
09:23:43 <jophish_> ok, no worries. It was fun figuring this out. Thanks a bundle for your help, int-e
09:23:44 <int-e> jophish_: replacing  asks $ find s  by  Just $ asks $ find s  and changing 'lookup' accordingly.
09:23:49 <Eduard_Munteanu> ReinH: maybe endomorphism? auto implies iso
09:25:26 * hackagebot diagrams-cairo 1.0.1.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.0.1.2 (BrentYorgey)
09:25:28 * hackagebot diagrams-postscript 1.0.1.2 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.1.2 (BrentYorgey)
09:26:16 <ReinH> Eduard_Munteanu: right, f might not have an inverse
09:26:23 <lispy> johnw: hi
09:26:54 <johnw> lispy: hey!  I have a question for you in #haskell-infrastructure
09:28:46 <hsnoob> I think of an automorphism as a set where all the elements are scrambled up, but no information is lost.
09:28:56 <hsnoob> For my small brain
09:29:27 <quicksilver> hsnoob: that sounds right except for the bit where you called it a set :)
09:29:59 <quicksilver> it's a transformation, or a function or a morphism, depending how concrete the context is.
09:30:07 <hsnoob> quicksilver: oops, ya. :)
09:30:11 <Eduard_Munteanu> A bit more intuition and we can totally claim "you could have invented Cayley's theorem yourself". :)
09:30:22 <quicksilver> you totally could.
09:30:26 <quicksilver> after all, cayley did.
09:30:42 <joelteon> > "\x0000000000000000000000000000000000006f"
09:30:43 <lambdabot>  "o"
09:31:15 <joelteon> that's interesting
09:31:18 <tonnato> > "\                                                        \o"
09:31:19 <lambdabot>  "o"
09:31:30 <ReinH> byorgey: heh how aobut a TikZ backend for diagrams? ;)
09:31:50 <tonnato> joelteon: C should work the same way
09:32:50 <hsnoob> Eduard_Munteanu: I don't think I'm smart enough to do abstract math without a foundation of flawed intuitions and models.
09:33:25 <quicksilver> intuition isn't flawed just because it's too concrete
09:33:35 <quicksilver> lots of people find it useful to remember special cases as intuition
09:33:49 <quicksilver> just remember that your special case might have its own quirks which don't apply in generality.
09:33:55 <quicksilver> (like objects having elements....)
09:34:31 <ReinH> hsnoob: an automorphism of a set is indeed called a permutation :)
09:34:47 <ReinH> but not all automorphisms are on sets
09:35:18 <hsnoob> Is a permutation always an endomorphism?
09:35:27 * hackagebot BlogLiterately-diagrams 0.1.4.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.4.1 (BrentYorgey)
09:35:53 <ReinH> hsnoob: well, what is the domain and codomain of a permutation?
09:35:56 <Eduard_Munteanu> By definition I'd say so.
09:36:59 <ReinH> hsnoob: also, since a permutation of a set is an automorphism, and automorphisms are endomorphisms, yes :)
09:38:03 <hsnoob> Ohh, so a permutation of a set preserves its size?  Then in this case it's another word for automorphism right?
09:38:07 <flebron> If one is to be really pedantic, then length by itself isn't in Hask, right? length_t is in Hask for every t in Hask.
09:39:02 <flebron> (To be even more pedantic, for every object t in Ob(Hask), there's a length_t in Mor(Hask), Ob the objects, Mor the morphisms)
09:39:15 <Eduard_Munteanu> flebron: it sort of is due to the impredicative nature of Hask.
09:39:29 <johnw> length is a natural transformation over endofunctors from Hask -> Hask
09:40:25 <flebron> johnw: I didn't get that. How is it so?
09:40:27 <johnw> since natural transformations are akin to polymorphic functions
09:40:50 <johnw> i.e., you can transform length :: [a] to length :: [t] for any t
09:41:19 <flebron> Right, but over a specific endofunctor, [].
09:41:20 <johnw> flebron: http://lukepalmer.wordpress.com/2008/04/28/whats-a-natural-transformation/
09:41:26 <Eduard_Munteanu> You have a naturality square but the natural transformation itself is trivial.
09:42:03 <johnw> and also http://comments.gmane.org/gmane.comp.lang.haskell.beginners/12806
09:42:15 <johnw> where he does not that only *some* polymorphic functions are natural transformations
09:42:19 <johnw> s/not/note
09:42:40 <flebron> Ah, the other functor is the identity functor.
09:42:58 <johnw> yeah, Identity has a strange way of "hiding" in normal CT, where it is always explicit in Haskell
09:43:23 <johnw> any "a" is the same as an implied "{Identity} a"
09:43:40 <byorgey> ReinH: http://git.hcoop.net/?p=notd/diagrams-tikz.git
09:46:29 <Eduard_Munteanu> I think things get more clear once you remove impredicativity by pretending types are parametrised by other types instead of being polymorphic.
09:46:49 <flebron> johnw: So if I have f :: x -> x, it's a natural transformation between two identity functors?
09:48:09 <flebron> Eduard_Munteanu: I'm not entirely sure what you mean by impredicativity, never heard that word
09:48:11 <hsnoob> The relationship between haskell Functor and CT functor are still a bit of a mystery to me.  CT is A^C -> B^C I think, I don't know where f (a -> b) -> f b came from
09:48:42 <Eduard_Munteanu> hsnoob: er, where did you get the A^C -> B^C thing?
09:48:51 <flebron> C^T is that for every arrow (a -> b), you have an arrow F a -> F b
09:49:01 <flebron> *CT haha, no idea  why I copied one of your ^.
09:51:20 <Eduard_Munteanu> flebron: call Hask '*' instead. Inhabited types like Bool or Char -> Int are in '*', so in a type like f :: forall x. x -> x, 'x -> x' is in *. But 'forall x. x -> x' is in * too.
09:51:48 <johnw> flebron: I'm not clear enough yet to answer that question properly
09:52:06 <ski> s/Inhabited/Inhabitable/
09:52:08 <flebron> Eduard_Munteanu: Oh, you mean arbitrarily ranked functions?
09:52:13 <Eduard_Munteanu> flebron: that's sort of an abomination if you're pedantic
09:52:33 <ski> hsnoob : a type in `Functor' is a CT endo-functor on the category `Hask'/`*'
09:53:07 <platz> hsnoob: my incomplete understanding is that a functor maps types to types, and also has the additional property that it maps morphisms to morphisms.. i think the latter is where fmap plays its role
09:53:09 <ski> hsnoob : it can be useful, even in Haskell, to consider other categories as well, as well as allowing the source and the target category to differ
09:53:29 <ski> platz : sounds right
09:54:38 <flebron> I hadn't actually thought of how polymorphic functions interact with the underlying type theory :)
09:54:38 <Eduard_Munteanu> flebron: not really... are you familiar with the hierarchy of universes in Agda or Coq? 'Set l' stuff.
09:55:02 <flebron> Eduard_Munteanu: 6 is an upper bound on the number of Agda lines I've written.
09:55:08 <flebron> And I'm fond of whitespace.
09:55:49 <ski> hsnoob : let's say you define `newtype List ref a = L (ref (Cell ref a)); data Cell ref a = Nil | Cons a (List ref a)', then `List' is a functor, but not a functor from `*' to `*', but a functor from `* -> *' to `* -> *'
09:57:27 <shachaf> Well, (* -> *) isn't a category on its own. Or there are many categories where objects are things of that kind.
09:58:09 <flebron> The way I understood Hask is I grabbed all types and I cartesian-closed it.
09:58:21 <ski> shachaf : yes
09:58:47 <flebron> And by "all types" I mean "all basic types", like data definitions and built ins.
09:59:16 <rola> Hask is cartesian closed?
09:59:33 <shachaf> A common functor from the category of Functors and natural transformations to the category of types and functions is Fix :: (* -> *) -> *
09:59:53 <shachaf> Hmm, unless I'm wrong and it's not a functor. But I think it is.
10:00:07 <Eduard_Munteanu> flebron: the basic idea is Haskell lets you claim 'forall a. a' :: *, which pretty much leads to * :: * if you think about it.
10:00:17 <johnw> flebron: to answer your previous question to me: yes, according to http://www.ioc.ee/~tarmo/tday-voore/vene-slides.pdf (see the slides on "Logical Relations and Parametricity")
10:00:20 <flebron> I think if you remove bottom Hask is cartesian closed?
10:00:37 <Eduard_Munteanu> Which is akin to Russell's paradox.
10:01:08 <phischu> shachaf: is "Fix" like "Free" only without "Return"?
10:01:34 <johnw> phischu: type Free f a = Fix (Compose (Either a) f)
10:01:36 <Eduard_Munteanu> Just locally cartesian closed, and it already is without removing bottoms, AFAICT.
10:01:49 <johnw> phischu: so, yes
10:02:01 <Peaker> Eduard_Munteanu: if you also add other stuff, I think (e.g: set comprehensions, or sigma types) I'm not quite sure what Russell's paradox would be in the Haskell type system (In Agda, it's an instantiation of bottom, but in Haskell that's trivial anyway)
10:02:56 <hsnoob> I think the topic in #math needs to read "For category theory questions go to #haskell"
10:03:21 <nicoo> xD
10:04:34 <tac> There _is_ a ##categorytheory
10:05:07 <notdan> Eduard_Munteanu: well, if you have bottom than you have more than one arrow going into the terminal object
10:05:13 <Eduard_Munteanu> Peaker: you don't really need sigmas, it's just "most" (tm) Haskell functions are rather ill-typed :)
10:05:20 <notdan> making it not really terminal/
10:05:21 <notdan> ?
10:06:13 <Eduard_Munteanu> I guess so.
10:06:52 <Peaker> Eduard_Munteanu: http://www.cs.nott.ac.uk/~txa/g53cfr/l20.html/l20.html <-- this is what it takes to get Russell's paradox in Agda with Set:Set
10:06:53 <Eduard_Munteanu> Peaker: e.g. id's type 'forall a. a -> a' is in *
10:08:30 <Eduard_Munteanu> Peaker: isn't set in set issue a general result? It holds for Coq too, hence they need a hierarchy for Set too. Prop avoids it due to proof irrelevance.
10:09:01 <Peaker> Eduard_Munteanu: as I understand it -- Coq/Agda really want comprehensions (sigma types) and getting rid of them would rip out the core of the language
10:09:28 <Peaker> Eduard_Munteanu: but if you had no sigma/comprehensions, then Set:Set would not necessarily lead to Russell's paradox, but I haven't done the proofs/etc:)
10:11:51 <Eduard_Munteanu> Peaker: no comprehensions or do you mean restricted comprehensions?
10:12:49 * Eduard_Munteanu is thinking of small/large classes too
10:14:18 <Eduard_Munteanu> IIRC the original resolution of Russell's paradox was to claim comprehensions can range over strictly "smaller" sets.
10:14:45 <ReinH> byorgey: heh of course, awesome
10:17:12 <Rc43> Am I right that first-order logic differs from higher-order logic only in that we can't quantify over _all_ propositions?
10:18:23 <Eduard_Munteanu> Rc43: higher order is usually finite, e.g. second order can quantify over first-order propositions.
10:20:35 <Rc43> Eduard_Munteanu, I just heard the proposition that Coq models higher-order logic unlike Agda which models first-order logic. And this difference is in that we can write "forall P : Prop" in Coq and must write "forall l : level, forall P : Set l" in Agda.
10:21:02 <Rc43> Eduard_Munteanu, and I don't know what it means for programmer on Coq and Agda. Seems that only difference is "forall l : level".
10:22:00 <Eduard_Munteanu> Rc43: I don't think that's really true. It only makes a difference on proof irrelevance AFAIK.
10:23:47 <Eduard_Munteanu> Rc43: in Coq, Prop is impredicative, you get irrelevance for free and without caring about universe levels. But Coq still requires a universe hierarchy for Set.
10:24:31 <Eduard_Munteanu> Rc43: in contrast Agda doesn't distinguish between data types and propositions, they're all in Set.
10:25:34 <Eduard_Munteanu> I've heard people claiming Coq's explicit universe polymorphism is rather horrific to use.
10:26:16 <Rc43> Eduard_Munteanu, ye, Prop impredicativity is that why the guy with whom I talked said that Coq is higher order logic.
10:27:25 <Rc43> I didn't found yet what is proof irrelevance =/
10:27:31 <Eduard_Munteanu> Rc43: the way you usually pick universe levels in Agda doesn't really limit you in any way wrt to what things you can express.
10:28:48 <Eduard_Munteanu> Rc43: that's why it's called universe polymorphic, so you don't need to define a proposition for each "order".
10:30:31 <Rc43> Eduard_Munteanu, proof irrelevance is just "forall P : Prop, p1 p2 : P, p1 = p2"?
10:30:49 <Rc43> Eduard_Munteanu, how can it be true?
10:31:26 <tac> Rc43: How can proof irrelevance be true?
10:32:14 <Rc43> tac, thats what I asked :)
10:32:20 <Eduard_Munteanu> Rc43: it might help to note the word "irrelevant": users of the proof don't care which proof they get as long as the type is inhabited.
10:32:33 <Rc43> tac, I googled coq file wheere it is an axiom
10:32:48 <tac> Rc43: Say you and I have a proof that 1 + 1 = 2. Does it really matter HOW we proved that?
10:32:53 <ski> (mere) propositions being where we don't care about differing proofs/elements ?
10:33:05 <Rc43> Eduard_Munteanu, ye, but why we need proof irrelevance?
10:33:05 <tac> Answer: Not really. So we might as well assume that our two proofs are the same.
10:33:21 <tac> Proof irrelevance is important for compiling dependently-typed languages.
10:33:29 <johnw> proof irrelevance = as long as it compiles, we're good :)
10:33:31 <Eduard_Munteanu> Rc43: because it lets erasure work in a DT language, for example
10:33:32 <tac> If something is proof irrelevant, it doesn't affect the runtime execution of a program.
10:33:43 <ski> tac : i like to think that the proof of that is `Refl 2'
10:33:57 <Rc43> tac, but we decline Prop values at compiling stage, aren't?
10:33:59 <johnw> tac: is that true?  aren't there differing inhabitants to functions?
10:34:03 <magneticduck> guys guys guys... I have a question: why is Gloss SO SLOW?
10:34:16 <magneticduck> (compared to using openGL / GLUT directly)
10:34:21 <tac> Also, if a function takes a Prop as an argument, if it can be figured out by the computer, we need not care how the computer got the answer.
10:34:40 <tac> (Haskell type classes are very much like Props, because you can only have one instance per type)
10:34:41 <Rc43> tac, or it is necessary for transformations of proofs which preserve type?
10:34:42 <magneticduck> I'm making a openGL / GLUT wrapper myself, I'm wondering why gloss got to be so slow so I can avoid it in my own binding (which I will use for a game)
10:34:42 <Eduard_Munteanu> Irrelevance means you also can't really deconstruct a proof.
10:34:58 <magneticduck> I mean, take trying to draw like 200 little blocks to the screen
10:35:17 <ski> Eduard_Munteanu : but you can still do cases on `P \/ Q' in Coq, iirc
10:35:22 <johnw> Eduard_Munteanu: doesn't it also means that all proofs of the same propsition are equivalent?  i.e., that _how_ you proved it doesn't matter, only _that_ you proved it
10:35:23 <Eduard_Munteanu> Agda has it too, but it's a per-argument thing.
10:35:35 <tac> johnw: A function type might have multiple inhabitants, of course. But when you "propositionally truncate" it, they are all considered equivalent
10:35:36 <magneticduck> doing it hard in openGL is a breeze, using a list to contain them and drawing them to the screen is also really fast, but doing it in gloss is omgslow
10:35:38 <magneticduck> why?
10:35:57 <tac> (But you aren't allowed to case match or apply arguments to a proposition)
10:36:01 <epta> Could some please explain what is the point of bitarray package? http://hackage.haskell.org/package/bitarray-0.0.1/docs/Data-BitArray.html
10:36:05 <Eduard_Munteanu> johnw: yeah you can still construct different proofs I think, though it matters less in Coq where you use tactics rather than explicit lambda terms.
10:36:15 <epta> Why bitarray is bettern than just array of bits?
10:36:20 <Rc43> Wait, guys. Why we need proof irrelevance if we erase all Props? (Lets not look at examples where we have functions decomposing Prop value.)
10:36:37 <hsnoob> Bitarrays typically take less space in memory
10:37:04 <Eduard_Munteanu> Rc43: you can't erase Prop if it's not irrelevant, because something else might inspect such a proof and have different behavior depending on the input.
10:37:57 <Eduard_Munteanu> Rc43: "decomposing Prop" is sort of the point here, Prop is altogether different from Set.
10:39:02 <Eduard_Munteanu> ski: I think P \/ Q means two different things depending on whether you write it in Prop or Set
10:39:43 <hsnoob> epta: because it requires the use of bitshifts and logic operations.  The hardware doesn't see an array of bits, things have to be bunched up into machine words.
10:39:48 <ski> possibly. i intended `Prop' anyway
10:40:29 <dxtr> epta: What exactly is the difference between "bitarray" and "an array of bits"?
10:40:40 * hackagebot cpsa 2.3.3 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.3.3 (JohnRamsdell)
10:40:44 <hsnoob> I think he meant something like [Bit]
10:40:47 <Eduard_Munteanu> ski: or you might be able to match it, but only if the result of the match is itself irrelevant.
10:40:54 <ski> yes
10:41:13 <bergey> magneticduck: have you run your gloss version with profiling on?
10:41:36 <Eduard_Munteanu> I think Agda irrelevance works in a similar fashion, it's just a per-argument thing.
10:41:49 <magneticduck> bergey: I haven't used gloss in a while
10:42:21 <ski> Eduard_Munteanu : it would of course be different if you could also case on the input, given that the result doesn't depend on what actual input you get
10:43:23 <ski> (that's like another kind of quotient)
10:44:13 <epta> dxtr: BitArray is a strange data type from bitarray package with 15 downloads, 1 version which was created almost 4 years ago. By arrays of bits I mean Array Int Bit or similar
10:46:12 <hsnoob> epta: http://en.wikipedia.org/wiki/Bit_field http://en.wikipedia.org/wiki/Bit_array
10:46:21 <Rc43> Eduard_Munteanu, so how do we solve problem if we just declare all proofs of same type to be equal? Functions still behave differently.
10:47:07 <tac> Rc43: Which problem?
10:47:08 <Eduard_Munteanu> Rc43: no, there are restrictions on what they can do to irrelevant arguments
10:47:18 <epta> hsnoob: I have that strange feeling that all people use something instead that bitarray package
10:47:32 <tac> The issue is simple: Sometimes you want to distinguish between things. Othertimes you want to ignore any differences.
10:48:13 <tac> If all you case about is that the proposition is true, use a Prop. If you ever want to pattern-match on things or call a function, use a Set instead.
10:48:22 <tac> If in doubt, use a Set :)
10:50:13 <hsnoob> epta: Ya, I don't know.  [Bool] works fine unless you really have memory issues.
10:51:28 <epta> hsnoob: also there is Data.Array.Unboxed if point of bitarray package is about it
10:53:29 <merijn> Anyone know if there is an IRC channel for pandoc? The one on freenode seems mostly empty
10:53:38 <supki> > (2371263718127381723172313 :: Integer) & bitAt 127 %~ not
10:53:40 <lambdabot>  170141183460471602995405431097607278041
10:53:44 <supki> epta: I'd use lens
10:54:55 <merijn> You can just use Data.Bits
10:55:17 <edwardk> epta: for bits i tend to use random stuff i've written myself usually. in structures i have a bit array i use locally. i also have one in my succinct test package, but neither of those are ready for prime time
10:55:19 <hsnoob> epta: Unless you're designing a network protocol or driver programming, you'll probably not need to bit pack.
10:55:26 <merijn> It seems lens users forget you can do things without lens :p
10:55:37 * magneticduck doesn't know what a lens is
10:55:42 <magneticduck> today I will learn.
10:55:52 <epta> merijn: what is the point of not using them?
10:56:01 <merijn> edwardk: Time for your elevator pitch ;)
10:56:21 <merijn> epta: If you aren't already using lens/don't know lens, why add an extra dependency/learning curve?
10:56:43 <edwardk> merijn: It is important to the lens cult's identity to ensure that they always first think of the proper way to do it within the mindset of lens, before exploring radical outside perspectives.
10:57:20 <epta> merijn: it sounds like aggressive ignorance :)
10:57:25 <guesting> If I have a list of 200000 strings, each string is 20 characters long, how much memory would that be taking up?
10:57:27 <hsnoob> Is this a leaderless cult?
10:57:34 <merijn> epta: How so?
10:57:40 <edwardk> my pitch is to use whatever the right tool is for the job. ;) then my goal is to make lens the right choice as much as is practical ;)
10:58:04 <edwardk> hsnoob: well, by adopting the disinterested outsider perspective it is easier for me to sway you to the lens way of thinking ;)
10:58:43 <merijn> epta: I don't see how using a simple API to toggle bits which happens to be the exact same thing lens wraps constitues "aggressive ignorance"?
10:58:46 <epta> edwardk: what is locally?
10:58:58 <edwardk> epta: 'in my own work'
10:59:04 <epta> :[
10:59:07 <edwardk> anyways, re the lens thing
10:59:25 <edwardk> > 0 & partsOf bits .~ [True, False, True] :: Int
10:59:27 <lambdabot>  5
10:59:46 <epta> btw, where `bitAt` comes from?
10:59:49 <edwardk> (32 :: Int)^..bits
10:59:53 <edwardk> Data.Bits.Lns
10:59:54 <hsnoob> Data.Bits
10:59:55 <edwardk> > (32 :: Int)^..bits
10:59:56 <lambdabot>  [False,False,False,False,False,True,False,False,False,False,False,False,Fals...
11:00:08 <edwardk> > (32 :: Int) & bits %~ not
11:00:10 <lambdabot>  -33
11:00:17 <tac> oh neat
11:00:22 <edwardk> > (32 :: Int) & bitAt 5 %~ not
11:00:24 <lambdabot>  0
11:00:48 <hsnoob> That's actually pretty cool. :)
11:01:00 <quchen> edwardk = fix (\tool -> if isLensy tool then const tool else lensify)
11:01:09 <edwardk> the API for twiddling bits is made up of a lens and traversal an a bunch of combinators the lenserati already know how to use ;)
11:01:20 <Eduard_Munteanu> What's a nice way to serialize a record to a bunch of pairs of strings?
11:01:58 <edwardk> Eduard_Munteanu: by cheating and going through its fromJson and toJson? =)
11:02:28 <Eduard_Munteanu> Ah, no... I want to end up with a Map Text Text really.
11:02:32 <dxtr> epta: To answer your question: A bitarray is an array of bits
11:02:33 <edwardk> Eduard_Munteanu: if you want to do it in an advanced style you can use GHC.Generics to get all the field names out
11:02:45 <dxtr> Or, well, an array of something that represent bits
11:02:56 <edwardk> and even check that they are all Text, or what have you
11:03:00 <hsnoob> There's a trick like that with stringstream in C++
11:03:26 <Eduard_Munteanu> edwardk: ah... so I should be using GHC.Generic directly? I was wondering if there's something already cooked up.
11:03:45 <epta> actually bitarray questions appears because it seems to be that array of bits could be optimal way to construct sieve of Eratosthenes. maybe there is another data structure that could fit it?
11:03:47 <edwardk> Eduard_Munteanu: well, it is likely what i'd use if i had to do it.
11:03:58 <merijn> Speaking of Map, is there a datatype for total maps? i.e. "lookup :: Map k v -> k -> v" (no Maybe) since all keys are inhabited?
11:04:12 <Eduard_Munteanu> merijn: a function? :)
11:04:17 <edwardk> epta: just use a Vector Word64 and twiddle the bits yourself as you go in each Word
11:04:30 <merijn> Eduard_Munteanu: You can't update the value in a function easily
11:04:51 <merijn> Eduard_Munteanu: At least, I don't know how to use functions for this effectively
11:04:55 <edwardk> epta: https://github.com/ekmett/structures/blob/master/src/Data/Vector/Bit.hs is a custom Vector type compatible with Data.Vector.Generic that works bit packed.
11:05:03 <edwardk> copy and paste and go nuts ;)
11:05:07 <shachaf> merijn: Yes, conal has one.
11:05:19 <dcoutts> epta: the ordinary UArray Int Bool is implemented as a bitarray, if that helps
11:05:20 <epta> edwardk: and why Vector is more efficient than i.e. Array?
11:05:25 <shachaf> merijn: https://hackage.haskell.org/package/total-map
11:05:32 <johnw> isn't Vector the "newer" of the two?
11:05:39 <edwardk> epta: stream fusion
11:06:00 <edwardk> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401
11:06:26 <dcoutts> epta: depends what you're doing. vector has more operations. On the other hand (U)Array can do multi-dimensional arrays
11:06:27 <epta> great, thanks!
11:06:30 <Eduard_Munteanu> merijn: what sort of keys do you have?
11:06:44 <merijn> shachaf: That doesn't seem to have an "update :: Map k v -> k -> v -> Map k v", though?
11:06:44 <tac> What package is bits in?
11:06:45 <dcoutts> epta: if all you're doing is building & indexing then there's not much in it
11:06:49 <tac> @info bits
11:06:49 <lambdabot> bits
11:06:53 <tac> @type bits
11:06:54 <lambdabot> (Num b, Applicative f, Indexable Int p, Bits b) => p Bool (f Bool) -> b -> f b
11:07:15 <merijn> Eduard_Munteanu: Nothing in particular right now, I just needed one in the past (where I basically had a enum of constructors as key)
11:07:27 <merijn> Eduard_Munteanu: And I was motivated to figure out something now :p
11:07:38 <tac> Also, why is @info completely worthless on lambdabot? :<
11:07:48 <geekosaur> because it doesn't exist
11:07:51 <ski> there is no `info' command in lambdabot
11:07:52 <merijn> tac: It's not a command
11:07:54 <triliyn> tac: there is no @info; it gets autocorrected to @undo
11:08:10 <Eduard_Munteanu> merijn: you could use / generate a record, so you get some guarantees of totality
11:08:10 <tac> oh
11:08:18 <hsnoob> epta: I'm not sure how a bitarray optimizes the sieve of eratosthenes?
11:08:21 <tac> @hoogle bits
11:08:22 <lambdabot> package bits
11:08:22 <lambdabot> package bits-atomic
11:08:22 <lambdabot> package bits-conduit
11:08:29 <merijn> Eduard_Munteanu: Sure, I was wondering whether someone had already done this :p
11:08:34 <johnw> there's a bits-conduit?
11:08:45 <johnw> heh
11:08:51 <johnw> turns integers into Bool streams
11:09:08 <merijn> TotalMap seems the obvious candidate, but I'm a bit confused why it doesn't seem to have any functions other than lookup and creation
11:09:29 <Eduard_Munteanu> merijn: I was working on getting record initializers based on lenses, but I haven't cleaned it up and submitted it yet
11:09:59 <Eduard_Munteanu> The generation part you'd have to handle yourself anyway I suppose.
11:11:18 <epta> hsnoob: well, you need to have a Map Int Bool in memory to full it with non primes number and then lookup for a candidate. Maybe IntMap will be enough
11:11:32 <Eduard_Munteanu> As a nice side-effect you can build an initializer step by step and only check totality when you apply it.
11:12:19 <epta> hsnoob: bitarray was just an example of possible data structure for that
11:13:18 <merijn> Eduard_Munteanu: One example use case where I've wanted one in the past is having a game board with a fixed number of players (I just had a "data Player = UK | Germany | France | etc." setup, where all keys must always be present
11:14:27 <edwardk> merijn: i tend to use a representable functor with that key as its representation.
11:16:04 <edwardk> or go further and use linear's E type to make the accessor provide the lens directly
11:17:16 <edwardk> newtype E t = E { el :: forall a. Lens' (t a) a };       then if you have data Players a = Players { _uk, _us, _canada :: a }; makeLenses ''a   -- you can talk about 'E us'   as the key into the Players data structure
11:17:47 <edwardk> and you can make instance Representable Players where type Rep Players = E Players;   -- very easily using a couple of boilerplate lines.
11:18:17 <enthropy> hi, http://lpaste.net/99574 doesn't seem to go away when I actually call Foreign.Concurrent.newForeignPtr
11:18:27 <edwardk> type Player = E Players  gives you a player type you can index with, and you can convert to a Player number with a little bit of trickery that probably isn't worth it ;)
11:18:52 <enthropy> I am trying to add a finalizer that is foreign import ccall safe "& nlopt_destroy" nloptDestroyFP :: FunPtr (Ptr () -> IO ())
11:19:09 <edwardk> being representable gives Players easy access to Applicative, Monad, Distributive, etc. definitions
11:19:19 <edwardk> along with default definitions
11:19:30 <Eduard_Munteanu> edwardk: hm, I think I want Data.Data instead of Generics
11:19:36 <edwardk> so in exchange for just wrting out the instances and linking them to the default definitin you get an entire player map
11:20:04 <merijn> edwardk: Unrelatedly: One of your School of Haskell posts recommended implementing comonad instances for Pretext and Bazaar, but I couldn't find any implementations to compare mine too to verify I got them right
11:20:11 <edwardk> Eduard_Munteanu: you can do it with either, the Generics version as the benefit of giving you the ability to complain if te type isn't a record at compile tme
11:20:24 <edwardk> merijn: Control.Lens.Internal.Pretext
11:20:32 <Eduard_Munteanu> Hm.
11:20:42 <merijn> edwardk: Did someone bother to write something explaning what Representable is?
11:21:00 <shachaf> Which Representable?
11:21:16 <edwardk> merijn: a Functor f is Representable if it is isomorphic to (->) x for some x
11:21:39 <merijn> edwardk: There is no Control.Lens.Internal.Pretext?
11:21:48 <edwardk> might be Context
11:22:04 <edwardk> but it should have a Pretext type in it
11:22:14 <shachaf> Isn't Pretext crazy these days?
11:22:19 <edwardk> well, yes
11:22:24 <shachaf> Parameterized over two profunctors or something like that.
11:22:26 <edwardk> but the code for the instance is the same as what he wants
11:22:32 <shachaf> Sure.
11:22:36 <merijn> I think I looked at lens already, but the Bazaar/Pretext in it are more complicated than the ones described in the article
11:22:42 <merijn> I'll try again :)
11:22:50 <edwardk> yeah, but they are just an extra couple of type parameters
11:22:58 <shachaf> (By the way, #-lens is a good place for these things)
11:23:03 <Cale> enthropy: That's interesting, maybe a GHC bug?
11:23:11 <edwardk> alternately tel did a write up and i replied on reddit with the right instances
11:23:53 <Cale> enthropy: Are you certain that this is the only finalizer you have to worry about?
11:23:58 <enthropy> Cale: dunno. Have you had such things work? My file is kind of big 400 lines chs / 1000 lines hs
11:24:01 <hsnoob> you say isomorphic to (->) x for some x, as opposed to any x
11:24:10 <Cale> I've never run into that issue before
11:24:13 <hsnoob> I'm not quite sure i get that statement
11:24:22 <johnw> hsnoob: "any x" carries no information
11:25:03 <johnw> hsnoob: in order for it to be representable, you have to know the scope of the some x
11:25:08 <triliyn> hsnoob: IntMap is a representable functor because it's isomorphic to (->) Int, even though it's not isomorphic to (->) ()
11:25:52 <edwardk> hsnoob: you can define class Functor f => Representable f where type Rep f :: *; tabulate :: (Rep f -> a) -> f a; index :: f a -> (Rep f -> a)  -- there 'x' is 'Rep f'
11:25:59 <edwardk> alternately i could have defined
11:26:24 <edwardk> class Functor f => Representable x f | f -> x where tabulate :: (x -> a) -> f a; index :: f a -> (x -> a)
11:26:32 <Cale> Wait, surely IntMap isn't actually isomorphic to (->) Int
11:26:37 <edwardk> tabulate and index together represent the isomorphism
11:26:48 <edwardk> Cale: never said IntMap was representable
11:26:51 <triliyn> Cale: well, a total int map, I mean
11:26:56 <Cale> triliyn did :)
11:26:59 <triliyn> I was perhaps being a bit careless
11:27:04 <edwardk> ah
11:27:06 <enthropy> Cale: false alarm (ghc was compiling a .hs file and ignoring changes to my .chs file)
11:27:07 <edwardk> yeah IntMap fails
11:27:27 <triliyn> The discussion about total maps must have confused me
11:27:27 <Cale> enthropy: Ah, good to hear that things aren't just broken :)
11:27:46 <enthropy> originally I had a foreign import ccall "wrapper" mkNloptFinalizer :: (Ptr () -> IO ()) -> IO (FunPtr (Ptr () -> IO ()))
11:28:09 <enthropy> to make the FunPtr, but that's worse than importing the "&nlopt_destroy" directly
11:28:36 <`^_^v> i have a function :: (Maybe String) -> (String -> m Expr) -> m (Maybe Expr), is there any short way to write it (currently im just pattern matching on the maybe string)?
11:29:14 <Blkt> what's the idiomatic way to parse a file using parsec a single try at a time?
11:29:15 <triliyn> Is there a word for things that are isomorphic to (->) x `O` Maybe?
11:29:42 <triliyn> Or does that turn out to be not particularly interesting?
11:29:45 <Blkt> collecting both failures and successes
11:29:55 <enthropy> `^_^v: Data.Traversable.for
11:30:48 <enthropy> ortherwise it's a flip fmap, if you're happy with    Maybe (m Expr)
11:31:17 <enthropy> which might be your only option if you can't attach any constraints to 'm'
11:31:18 <Cale> triliyn: Well, it's probably interesting for us, but there also likely isn't a word from CT for it.
11:31:24 <Eduard_Munteanu> Bleh, is there a nice way to get a DataType by name, without 'dataTypeOf (undefined :: Foo)'?
11:31:39 <enthropy> that is nice, Eduard_Munteanu
11:32:00 <shachaf> proxy is nicer than undefined
11:32:27 <Eduard_Munteanu> I suppose I can use Proxy for arguments to the caller of dataTypeOf.
11:33:05 <rawtass> How would I go about parsing and outputting in a streaming sense when prasing a file with the data.binary.get monad? I cannot do IO in the Get monad and I do not want to return the entire dataset from the file in a list..
11:33:12 <rawtass> *parsing
11:33:20 <shachaf> i,i pataTypeOf :: Data a => proxy a -> DataType; pataTypeOf ([] :: [Foo])
11:33:36 <`^_^v> thanks, enthropy
11:37:44 <Cale> rawtass: There's runGetIncremental, I'm not sure if that's an answer to your question at all
11:38:45 <adelbertc> i want to parse a line that looks like (without brackets): [112 534 6982 20]. i want to parse the first number, and then parse the rest of the line, but ensure none of the subsequent numbers are the same as the first number - i'm having a bit of trouble figuring out how to maintain that invariant as i parse (i'm using attoparsec)
11:38:49 <Clint> rawtass: conduits or pipes?
11:39:06 <rawtass> Cale: that might be one way to go.. yes
11:39:19 <rawtass> Clint: ah, I am not familiar with that..
11:39:35 <Peaker> adelbertc: why not verify the invariant after-wards?
11:40:00 <sccrstud92> does conduits integrate with attoparsec like pipes does?
11:40:05 <Peaker> adelbertc: you could pass the Set of parsed numbers to the next parsers
11:40:16 <Clint> sccrstud92: there is attoparsec-conduit
11:40:17 <adelbertc> Peaker - yeah that's an option, was wondering if atto had some sort of way of doing it
11:40:29 <sccrstud92> makes sense
11:40:34 <adelbertc> not sure what you mean with pass the Set of parsed numbers to the next?
11:40:58 <Cale> rawtass: The more important question here is what type of data you're parsing? Why do you think a list is a bad data structure?
11:41:19 <Cale> (lists can be rather good for streaming things :)
11:41:37 <sccrstud92> this operation seems like a fold, right?
11:41:49 <rawtass> Cale: I am creating a list of a datastructure, but my files are so big that I fill the memory with that list.
11:42:03 <Peaker> adelbertc:   something like: loop alreadyParsed = do { num <- parseNumber ; when (num `member` alreadyParsed) (handle error here...) ; rest <- loop (insert num alreadyParsed) ; return (num:rest) }
11:42:10 <Peaker> adelbertc: with EOF handling, of course
11:42:33 <merijn> rawtass: You probably wanna look at pipes/conduits if you wanna do streaming parsing
11:42:34 <adelbertc> Peaker - hm interesting
11:42:44 <adelbertc> will take a look, thanks!
11:42:52 <merijn> rawtass: They're designed for constant space processing for large files
11:42:52 <Peaker> adelbertc: but it'd be more elegant to make a simple parse of all the numbers -- and then do the verification after-wards on the resulting list
11:43:03 <sccrstud92> rawtass: are the lines in the files big too? or are there just a bunch of lines?
11:43:53 <adelbertc> Peaker - so the verification need only look at a single line at a time - currently i've got a Parser (Maybe Foo) going on but if that Maybe is a Nothing.. the Parser should just fail at that point
11:44:32 <merijn> adelbertc: Why are you returning "Maybe Foo" if the parser is supposed to fail on Nothing anyway?
11:45:06 <rawtass> sccrstud92: It's a binary format that I am parsing into my own datastructure, and it repeats ALOT of times .. could be hundreds of GB of total file size.
11:45:08 <adelbertc> merijn - i question the existence of my Parser (Maybe Foo) as well, 99% sure i'm doing something wrong so looking for alternatives
11:45:28 <rawtass> marijn: ok, I need to read up on that I think
11:45:30 <merijn> adelbertc: You probably want to change it to "Parser Foo" and use "empty" internally
11:45:45 <adelbertc> empty?
11:45:54 <merijn> adelbertc: empty is from the Alternative typeclass (implemented by all parser libraries I know)
11:45:57 <sccrstud92> rawtass: but does it have really long lines?
11:46:15 <merijn> adelbertc: empty is a failing parser (so kinda similar to Nothing), hence why the Maybe is redundant
11:46:16 <rawtass> sccrstud92: what do you mean by long lines?
11:46:23 <merijn> :t Control.Applicative.empty
11:46:23 <lambdabot> Alternative f => f a
11:46:46 <sccrstud92> rawtass: do you have single lines that are GB long or do you have line that are shorter and just millions of lines?
11:47:08 <shi> hi
11:47:08 <adelbertc> merijn - aha, this is my first run-in with Alternative, but looks like what i want
11:47:09 <merijn> adelbertc: You'd write something like "myParser = do { cond <- parseStuff; if cond then parseFoo else empty }"
11:47:13 <steven807> (For anyone reading logs of this in the future, the problem was that I had "executable-profiling: True" in my .cabal/config.  After changing that to false, I needed to do was "cabal install ghc-mod hdevtools", and my problems went away.)
11:47:30 <merijn> adelbertc: This is basically "fail if you can't parse a Foo"
11:47:38 <merijn> adelbertc: There's also <|>
11:47:42 <merijn> :t (<|>)
11:47:43 <lambdabot> Alternative f => f a -> f a -> f a
11:47:48 <codygman>  Does anyone know of a haskell equivalent for pyrad (RADIUS client implementation as per RFC2865): https://github.com/wichert/pyrad
11:48:03 <merijn> adelbertc: "p1 <|> p2
11:48:10 <hsnoob> adelbertc: did you say you needed to check the parse midstream if you parsed the same number twice?
11:48:27 <merijn> adelbertc: "p1 <|> p2" returns p1 IF p1 /= empty, if p1 == empty, then it returns p2
11:48:35 <adelbertc> hsnoob - i parse the very first number in a line, and then parse other numbersin the same line - if any of those numbers are the same as the fist number, it fails
11:48:44 <merijn> adelbertc: Obviously, if p2 is empty to, then entire expresion returns empty
11:48:52 <hsnoob> So just the first number can't match the other numbers?
11:48:56 <adelbertc> merijn - aha, very nice, thanks
11:49:08 <adelbertc> hsnoob - yes, "1 2 3 4" is fine but "1 4 1 5" is not
11:49:30 <adelbertc> hsnoob - you just made me realize that's not correct either, all numbers must be unique in the line.. heh
11:49:38 <adelbertc> merijn - ah cool, cheers
11:50:29 <Cale> sccrstud92: that ought not to matter...
11:51:00 <Cale> rawtass: Of course, a list might be an okay thing to produce if you can find a way to construct it lazily.
11:51:20 <sccrstud92> Cale: it matters because you need to hold in memory all the numbers you have encountered on that line so far, but once you reach the end of the line you dont need em anymore. unless im misunderstanding the problem
11:51:44 <Cale> sccrstud92: Didn't rawtass say it was a binary format?
11:52:02 <sccrstud92> Cale: he also said it was all "one line"
11:52:04 <Cale> Whether or not there were newline characters shouldn't matter :)
11:52:23 <Cale> Maybe there are two threads getting mixed up here
11:52:31 <klrr_> what is "... :: Foo => ..." `Foo` called to be in verbal terms?
11:52:40 <apples`> constraint
11:52:41 <Cale> klrr_: A class constraint
11:52:44 <klrr_> okey thanks
11:53:43 <rawtass> Cale: right.. But can you parse a binary file and store the values lazily in a list?
11:53:46 <merijn> klrr_, Cale: I would argue just a constraint
11:54:07 <merijn> klrr_, Cale: It's possible to have non-class constraints
11:54:30 <klrr_> ill use just contraint sounds most logical for my context
11:54:30 <Cale> merijn: of course, but equality constraints look different
11:54:31 <rawtass> Cale: I originally coded this thing with no concern of performance and I'm working on trying to optimize it now..
11:54:32 <merijn> Most obviously type equality constraints such as "(a ~ Int)" but with TypeFamilies one can add arbitrary type level constraints
11:54:45 <Cale> I suppose that's true :)
11:54:56 <Cale> rawtass: Yes, though it might involve a little trickery to make it be lazy enough for you.
11:55:23 <Cale> rawtass: You might need some sort of loop which uses runGetIncremental
11:55:29 <sccrstud92_> rawtass: i thought you were parsing lines because i read something someone else said. my bad
11:55:46 <rawtass> sccrstud92_: ok :)
11:56:01 <merijn> rawtass: I actually have a setup where I use pipes + runGetIncremental to do streaming parsing of a networking protocol
11:56:19 <rawtass> merijn: cool, is it available on a repo?
11:56:25 <merijn> The code isn't ready to be public yet, but I can pastebin the parsing bit
11:56:40 <rawtass> merijn: I would appreciate that..
11:58:08 <Cale> rawtass: If you look at the examples at the very top of http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary-Get.html
11:58:52 <rawtass> Cale: this is how I parse yes.. with runGet at the moment
11:58:53 <Cale> rawtass: You can see where they use Get to parse out one chunk at a time and produce a lazy list of Trade values.
11:59:10 <Cale> vs. producing the whole list at once inside Get
11:59:46 <Cale> That last blue code section is probably the sort of thing you want to do.
11:59:49 <rawtass> Cale: hmm.. ok.. Maybe I need to take a closer look at those
12:01:37 <Cale> You could go off and use pipes like merijn is suggesting. I just have a really hard time recommending anything like pipes to beginners. Some people are less reserved about it than I am though.
12:02:08 <merijn> rawtass: http://lpaste.net/99575
12:02:16 <Cale> It certainly can work, and will avoid some of this mess, but internally, it's very heavy machinery.
12:02:33 <merijn> rawtass: See also the pipes tutorial: http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html
12:03:09 <merijn> rawtass: I think this uses cereal instead of binary, but should be fairly obvious how to change this to use runGetIncremental from binary
12:03:12 <Cale> (and a lot of that complexity still shows through in the types)
12:03:40 <sccrstud92_> merijin: 4.1.0 is relatively new right? didnt it just come out like a week ago?
12:04:00 <merijn> sccrstud92_: It's mostly the same as 4 though, which is somewhat older by now
12:04:10 <rawtass> cool, thanks for the tips. I think this has me on the right track..
12:04:22 <merijn> rawtass: Pipes can be a bit intimidating to new comers, but can't hard to have a quick look
12:04:26 <sccrstud92_> merijn: so not many changes? thats what i was wondering
12:04:28 <merijn> rawtass: The tutorial is pretty good
12:04:39 <merijn> sccrstud92_: I'm guessing not, but I'm not sure :)
12:04:46 <merijn> eh
12:04:50 <merijn> s/can't hard/can't hurt
12:05:07 <Eduard_Munteanu> Can't hurd.
12:05:31 <merijn> Any vim users that have a working haskell tags solution they can recommend?
12:06:18 <shepheb> merijn: YouCompleteMe's basic skimming of your open buffers goes a surprisingly long way
12:06:34 <shepheb> but it's not really tags, doesn't know about files that aren't open, and doesn't understand different types.
12:06:35 <DMcGill> Is there a way to lens into two subcomponents at once? Something like (Lens' a b -> Lens' a c -> Lens' a (b,c)) i.e. (&&&) for lenses?
12:06:58 <shepheb> I'd be interested to know there is a good Haskell tags solution.
12:08:15 <sm> hasktags is the most haskell-aware one I believe
12:08:19 <merijn> shepheb: I'm not looking for autocompletion (I barely use it anyway), I want tags for code navigation (i.e. I'm looking at the pandoc source and it's really painful to navigate between definitions)
12:08:21 <edwardk> DMcGill: it isn't sound in general.
12:08:27 <edwardk> DMcGill: consider foo _1 _1
12:08:32 <merijn> sm: There's three on the wiki, but I'm unsure which works best
12:08:50 <DMcGill> edwardk: fair enough, guess I lose my point free style then :(
12:08:50 <sm> you could also consider using one of the IDES with haskell support, at least while learning a code base
12:09:04 <sm> eclipsefp, intellij+ideah, or haskell center
12:09:19 <edwardk> DMcGill: you can 'runFold $ (,) <$> Fold _1 <*> Fold _2'   or what have you for _reading_ though
12:09:38 <edwardk> DMcGill: it is a perfectly cromulent fold, just not guaranteed to be a good lens
12:09:41 <dennda> sm: There's haskell support for intellij? I didn't know that. Is it any good?
12:10:58 <sm> dennda: I tried it yesterday, and seems to work great at least for opening and browsing a haskell project
12:11:42 <sm> the plugin is out of date, but claims to support symbol navigation/building/running/ghci as well
12:12:09 <merijn> correction, apparently there's at least 4 tag generators
12:12:15 <merijn> I guess I'll just try all of them >.>
12:15:01 <merijn> sm: I'm not in favour of that approach as it involves installing an IDE, having to leave my terminal, etc. :\
12:16:11 <steven807> merijn: I've been using vim-hdevtools, with the additional mapping: "au FileType haskell nnoremap <buffer> <F3> :HdevtoolsInfo<CR>".  It's not perfect (it doesn't work if the code doesn't currently compile), but it's better than nothing.
12:18:23 <DMcGill> edwardk: where are runFold and Fold from? I' can't see them in Data.Lens.Fold
12:18:34 <merijn> steven807: FYI, if you set g:hdevtools_options to use -g-fdefer-type-errors it will run on non-compiling files too
12:18:35 <edwardk> Control.Lens.Reified IIRC
12:18:37 <cheeve> hi i'm comparing algorithm run-times and would like to count how many times an algorithm recurs. is there a simple way to do this in haskell?
12:18:55 <edwardk> DMcGill: Lens doesn't use Data.Lens for anything ;)
12:19:04 <DMcGill> Control.Lens even :)
12:19:12 <edwardk> heh
12:19:28 <merijn> steven807: Can HdevtoolsInfo jump to tags?
12:19:33 <edwardk> anyways newtype ReifiedFold s a = Fold { runFold :: Fold s a } is in there
12:19:35 <scshunt> ugh
12:19:39 <scshunt> I'm so bad at haskell
12:19:43 <Rembane> cheeve: Wrap it in a function with a counter?
12:19:57 <DMcGill> can I just use functions from Control.Lens.Fold without needing to reify it?
12:20:03 <cheeve> a counter?
12:20:07 <edwardk> it has all the instances you'd expect from someting isomorphic to s -> [a] or ReaderT s [] a
12:20:28 <edwardk> reify is t put multiples together like you were in ReaderT s []
12:20:30 <steven807> merjin: It doesn't use tags, but it does effectively the same thing, just by querying for the identifier under the cursor, then giving you the ability to jump to its definition by hitting <RET>
12:20:38 <edwardk> if you don't need that then just use the combinators
12:20:46 <merijn> steven807: That's annoyingly more work, though :\
12:20:49 <DMcGill> I'll take a good look thanks :)
12:21:11 <scshunt> when I come in here trying to decide if something is a typeclass or a datatype, why do people never remind me about how typeclasses pollute your type space? I can't make a datatype containing just "a list" without also encoding what that list contains
12:21:14 <merijn> steven807: I'll check if I can automate the jump directly
12:21:16 <steven807> merijn: Well, it's one extra keystroke, but I guess you have a lower tolerance than I do... :-)
12:21:24 <edwardk> similarly ReifiedGetter is isomorphic to (->) and has similar instances
12:21:37 <merijn> steven807: Not just one extra keystroke, unless it also provides a "back" key
12:21:55 <merijn> steven807: With vim tags you can jump can go forwards and backwards through a stack of tags
12:23:31 <steven807> merijn: Just use ^O and ^I -- it works just as well.
12:25:52 <merijn> ugh
12:26:04 <merijn> Hdevtools is choking on CPP phase :\
12:28:15 <bennofs> merijn: you need to pass -optP-include -optPdist/build/autogen/cabal_macros.h
12:30:47 <merijn> bennofs: That just gets me "error: dist/build/autogen/cabal_macros.h: No such file or directory"
12:31:21 <bennofs> merijn: ah, does it work if you run hdevtools from the cabal project root?
12:31:41 <bennofs> [ You do use cabal, right? ]
12:32:33 <merijn> bennofs: That gets me "Could not find module `Text.Pandoc.Walk'"
12:32:49 <bennofs> merijn: hmm, maybe also add -isrc ?
12:33:00 <merijn> Already have that
12:33:15 <bennofs> merijn: do you use cabal sandboxes?
12:33:15 <merijn> There appears to not be a "src/Text/Pandoc/Walk.hs" file
12:34:09 <bennofs> merijn: where is Text/Pandoc/Walk.hs then?
12:34:13 <merijn> bennofs: No
12:34:46 <merijn> Only tests/Test/Walk.hs which doesn't have the right path anyway
12:36:08 <colDrMcBeardman> if i show a Double that's large, it prints something like 1.34e8, how do I get it to print 134000000?
12:36:42 <cheeve> anyone?
12:37:04 <shachaf> What's "it"?
12:37:32 <geekosaur> colDrMcBeardman, you'll need to use something with formatted output. Text.Printf if you must, or look in the Numeric module
12:37:47 <shachaf> Numeric has a function for that, if you're OK with using a function.
12:38:03 <shachaf> > showFFloat Nothing 1.34e8 ""
12:38:04 <lambdabot>  "134000000.0"
12:38:07 <geekosaur> show isn't configurable (and isn't really intended or suitable for anything but debug output)
12:38:50 <merijn> bennofs: Line 83 import Text.Pandoc.Walk https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Shared.hs but it's not in that repository
12:39:10 <colDrMcBeardman> hmm/
12:39:42 <scshunt> fuck apparently I want dependent types. again.
12:40:09 <colDrMcBeardman> no problem with using a function, but i will want to wrap showFFloat as that is slightly ugly. thanks, shachaf
12:40:25 <merijn> scshunt: Story of my life :p
12:40:38 <colDrMcBeardman> geekosaur, always amazed at how printf lives on.
12:40:53 <merijn> bennofs: tbh, I can't find a single clue on where Text.Pandoc.Walk is supposed to come from
12:40:58 <scshunt> ok so I have a class Foo a
12:41:00 <geekosaur> I'm not fond of it, but it often is the easiest solution for formatting numbers
12:41:02 <joelteon> it's such a concise way to format data
12:41:31 <scshunt> Foo a has a function Foo a -> Maybe (Foo b). The type b may depend on a. So I want to use an associated instance
12:41:41 <bennofs> merijn: http://hackage.haskell.org/package/pandoc-types
12:41:43 <scshunt> but for some choices of a, the function always returns Nothing
12:41:44 <merijn> bennofs: Oh, right, it's from the pandoc-types package
12:42:00 <quchen> joelteon: If only it was typesafe
12:42:07 <bennofs> merijn: do you have that package installed?
12:42:09 <scshunt> is it terrible to make Void an instance of Foo so that if that is the case, it can set b = Void so that the only valid value is Nothing?
12:42:11 <joelteon> There are some ways to do that
12:42:12 <cheeve> does anyone know an simple way to count the number of recursions in an algorithm? i'm trying to compare merge sort to insertion sort.
12:42:14 <quchen> > printf "%d" "hello" :: String -- :-(
12:42:15 <lambdabot>  "*Exception: Printf.printf: bad argument
12:42:19 <merijn> bennofs: So why is hdevtools failing in the pandoc repository?
12:42:21 <joelteon> We could special-case the compiler
12:42:23 <joelteon> :/
12:42:44 <bennofs> merijn: what file are you checking?
12:42:58 <merijn> bennofs: Text.Pandoc.Readers.RST
12:43:13 <geekosaur> I would like to see something that uses printf %-escapes, but doesn't need the type hackery. single parameter, record update syntax to specify things like variable precision, etc.
12:43:53 <merijn> bennofs: If I run "HdevtoolsType" in that file I get this error that it can't find the module
12:44:11 <bennofs> merijn: does hdevtools check work?
12:44:22 <geekosaur> output is always type String, or maybe something so it plays with IsString (so still String internally but easier to fit into Text/ByteString)
12:44:44 <quchen> Speaking of printf annoyances, is there a way to prinf Text?
12:45:54 <quchen> Since printf-mauke does not have it I suspect there is some law of nature that doesn't allow it ;-)
12:46:30 <merijn> bennofs: If I run it from the command line I get: http://lpaste.net/99576
12:47:02 <colDrMcBeardman> quchen, odd, you would think OverloadedStrings would do it?
12:47:15 <bennofs> merijn: what hdevtools do you use? The one from hackage?
12:47:27 <quchen> colDrMcBeardman: OverloadedStrings just changes how string literals are treated
12:47:33 <colDrMcBeardman> oh
12:47:38 <merijn> bennofs: Yeah
12:47:50 <quchen> colDrMcBeardman: What you would need to do is add an instance PrintfArg Text, but the class isn't exported by Text.Printf
12:47:53 <colDrMcBeardman> so you can't get stuff out of Text or ByteString with it.
12:48:10 <colDrMcBeardman> quchen, i wonder why it's not exported.
12:48:21 <bennofs> merijn: hmm, then that's weird. Have you checked ghc-pkg if it's actually hidden?
12:48:41 <quchen> Probably so people don't start printf-ing `Vector Int -> Void` data or something.
12:48:42 <merijn> bennofs: Yup, it's not
12:49:31 <bennofs> merijn: Can ghci load it? i.e. does ghci src/Text/Pandoc/Readers/RST.hs work?
12:49:31 <scshunt> edwardk: any opinion on my Void idea above? you seem like someone who'd endorse it. :P
12:50:01 <bennofs> merijn: you might also want to try passing -v3 to GHC for more information (not sure if you have to start the daemon with --noDaemon to get the output)
12:50:26 <edwardk> ?
12:50:29 <bennofs> merijn: note that iirc, you have to restart the daemon when you change the verbosity flag
12:51:56 <merijn> bennofs: ghci fails too
12:52:09 <bennofs> merijn: ah, what does -v3 to GHCi give?
12:52:59 <mcstar> whats the term for the thing, when you have an array with a type which encodes its length?
12:53:12 <scshunt> edwardk: < scshunt> Foo a has a function Foo a -> Maybe (Foo b). The type b may depend on a. So I want to use an associated instance < scshunt> but for some choices of a, the function always returns Nothing < scshunt> is it terrible to make Void an instance of Foo so that if that is the case, it can set b = Void so that the only valid value is Nothing?
12:53:49 <merijn> First it couldn't find Text/Pandoc/Parsing.hs, but after adding -isrc to ghci it now fails on Could not find module `Paths_pandoc'
12:55:10 <merijn> bennofs: If I also add "-idist/build/autogen" like I have in vim, it now fails on Could not find module `Text.Pandoc.Walk'
12:56:01 <bennofs> merijn: please paste the output of ghci -v3 <options you added> <src> somewhere
12:56:30 <merijn> ugh
12:56:33 <mcstar> i just need the proper term for some googling, pls
12:56:36 <merijn> I suspect pandoc-types is out of date
12:57:01 <ystael> mcstar: You're thinking of dependent types, specifically the standard dependent vector type
12:57:23 <merijn> This is another argument against using Hdevtools for tags, I can't browse source without having all dependencies installed
12:57:42 <mcstar> ystael: dependent types is a solution, for implementing the thing im thinking of
12:58:29 <mcstar> this kind of array, or its type has a name... im quite sure ive heard it before, just cant remember it
12:58:58 <Cale> mcstar: Usually these are called vectors
12:59:27 <scshunt> also, when working with type families, is there a way to specify classes that the type family must satisfy?
12:59:33 <scshunt> e.g. to say that an associated type must have an instance of Show
13:04:28 <Eduard_Munteanu> scshunt: I think not, use a class for that.
13:04:45 <scshunt> Eduard_Munteanu: huh
13:04:50 <scshunt> I'm trying to write a class
13:04:55 <mcstar> well, it seems there is no commonly used term for this thing, at least i cant find it, thanks guys
13:05:51 <Eduard_Munteanu> scshunt: type family Foo a    can be written as    class Foo a r | a -> r
13:05:58 * hackagebot Wheb 0.0.1.1 - The Batteries-Included Haskell WAI Framework  http://hackage.haskell.org/package/Wheb-0.0.1.1 (hansonkd)
13:06:10 <scshunt> Eduard_Munteanu: But I'm already in a typeclass. I'm trying to say that an associated type must also be an instance of the same class
13:06:43 <scshunt> I guess I can just use FlexibleContexts
13:06:48 <Eduard_Munteanu> scshunt: associated type families are type synonyms really, so it's a can of worms
13:07:14 <Eduard_Munteanu> scshunt: you could put a context on methods, or you can rewrite it using fundeps.
13:07:30 <mcstar> ill pose a c++ question on #haskell-blah
13:07:31 <greedo> is it possbile for Maybe to return 2 values?
13:07:43 <jle`> greedo: Maybe (1,2)
13:07:47 <jle`> er
13:07:50 <mcstar> return (1,2) :: Maybe (Int,Int)
13:07:52 <jle`> Maybe (a,b)
13:08:02 <Eduard_Munteanu> scshunt: class Foo a where type Bar a   ~    class Foo a bar | a -> bar where
13:08:07 <jle`> hooray for ad-hoc product types
13:08:10 <Cale> Just (1,2)
13:08:13 <greedo> jle`: mmm, ok thanks, I'll try it
13:08:56 <jle`> greedo: if you want to optionally return zero, one, or two items
13:09:16 <jle`> then you can't do it with Maybe too cleanly
13:09:32 <jle`> with a list you can optionally return zero, one, two ... up to infinity
13:09:46 <jle`> there's a hackage package that has zero/one/two i think
13:11:01 <greedo> jle`: http://hackage.haskell.org/package/Finance-Quote-Yahoo-0.7.0/docs/Finance-Quote-Yahoo.html
13:11:11 <greedo> so I have this Maybe m
13:11:23 <greedo> but I want to do 2 lookups
13:11:41 <greedo> Just (a,b)
13:12:24 <jonkri> What could be the reason that trace does not show any input? (The expression is evaluated.)
13:12:32 <jonkri> Well, output. :)
13:12:52 <quchen> What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?
13:12:53 <jle`> greedo: if one fails, should the whole thing be Nothing?
13:13:24 <jle`> do the lookups depend on eachother?
13:13:46 <greedo> jle`: they do
13:14:16 <greedo> so I guess do the lookups seperately
13:14:29 <greedo> and then combine and return
13:14:33 <quchen> Applicative instance! liftA2 (,) lookup1 lookup2 :: Maybe (a,b)
13:14:41 <scshunt> *ugh*
13:14:44 <scshunt> I give up
13:14:52 <scshunt> Eduard_Munteanu: thanks for the help, I screwed up for other reasons
13:14:57 <FreeFull> quchen: That's only if they don't depend
13:15:11 <scshunt> I think I have to turn this typeclass into a concrete type, otherwise there's no way to do what I want without dependent types
13:15:31 <quchen> Oh, right. Good thing there's also a Monad.  do { a <- lookup1; b <- lookup2 a; return (a,b) }
13:15:44 <FreeFull> Yeah, you need monads for that
13:15:54 <greedo> monads are ok
13:17:40 <pavonia> @pl f >>= \a -> g a >>= \b -> return (a, b)
13:17:40 <lambdabot> liftM2 (>>=) g ((return .) . (,)) =<< f
13:19:06 <quchen> Can we have a new @faq entry for "is @pl useful here"? It would be the negative counterpart for the current @faq.
13:19:26 <greg`> anyone know a good library for connecting to gmail, ive tried using Network.POP3 but im getting "getAddrInfo: does not exist (Name or Service not known)
13:20:00 <shachaf> Can we get rid of @faq?
13:20:13 <shachaf> Or make it link to the FAQ.
13:22:22 <jle`> greg`: (,) <$> op1 <*> op2
13:22:36 <pavonia> I like the current @faq but it should be more clever about the kind of question that's asked
13:22:38 <jle`> will do the operations inrelated to eachother, and return it in a Maybe (a,b)
13:22:43 <jle`> sorry, greedo
13:22:46 <jle`> ^^
13:22:53 <jle`> if either fails, the whpole thing fails
13:23:33 <greedo> jle`: yeah, I think they are tied together, I don't want half a quote
13:23:59 <jle`> > (,) <$> Just 4 <*> Just 5
13:24:01 <lambdabot>  Just (4,5)
13:24:11 <jle`> > (,) <$> Nothing <*> Just 5
13:24:12 <lambdabot>  Nothing
13:24:32 <jle`> it's equivalent to do { x <- Just 5; y <- Just 6; return (x,y) }
13:24:46 <jle`> except i think the compiler likes applicative style better in some situations
13:25:40 <quchen> It was mentioned before (by me), and it's wrong.
13:26:03 <jle`> ( quchen: addressed to me? )
13:26:05 <quchen> Yes.
13:26:14 <quchen> The lookups are dependent on each other.
13:26:59 <jle`> ah, didn't read that
13:27:09 <greedo> quchen: they are, half quotes are no good
13:28:09 * quchen isn't sure why quotes would be stored in halfs, but that's besides the Haskell part of the question.
13:28:16 <quchen> halves*
13:28:31 <greedo> quchen: well, they are part of a Map
13:32:50 <hakujin> hi, I'm writing an Attoparsec.Text parser that will consume input until it finds "|c2". the full input will be "|c0asdfasdfasdf|c1asdfasdf|c2asdasdf|c3asdasdf". is there a more efficient way than manyTill anyChar (string "|c2")?
13:35:09 <pavonia> hakujin: Do you get a space leak with that?
13:35:26 <quchen> hakujin: I think your parser has a problem when there is "|" without "c(2)" after it. It will consume the "|" and then fail because it doesn't backtrack (is that the right word?) properly.
13:35:41 <quchen> In other words, wrap the parenthesis in a "try".
13:35:53 <quchen> Also see manyTill's description, http://hackage.haskell.org/package/attoparsec-0.11.1.0/docs/Data-Attoparsec-Combinator.html#v:manyTill
13:36:19 <quchen> As for efficiency, no idea. Profile it and then decide whether to worry about it.
13:36:39 <hakujin> quchen: attoparsec parsers always backtrack on failure
13:36:57 <hakujin> parsec does not
13:37:13 <quchen> Do they? The docs seem to suggest otherwise in the link I gave you.
13:37:41 <Cale> quchen was correct, you need try here
13:39:30 <Cale> hakujin: Ordinarily, if an attoparsec parser accepts any part of its input, the rest of the parser is discarded, i.e. you can't backtrack and failure at that point will result in the whole parser failing.
13:39:32 <hakujin> oh? I specifically see "This combinator is provided for compatibility with Parsec. Attoparsec parsers always backtrack on failure. " listed under try on http://hackage.haskell.org/package/attoparsec-0.11.1.0/docs/Data-Attoparsec-Text.html
13:39:56 <Cale> hmm!
13:40:09 <Cale> okay, maybe that's new :)
13:40:17 <hakujin> :)
13:40:30 <quchen> Haha, `try p = p`
13:40:38 <Peaker> attoparsec has "try = id" for parsec compatibility
13:40:39 <quchen> Okay, apologies. And thanks for the laughs ;-)
13:40:46 <geekosaur> I thoguht we'd determined attoparsec did not actually backtrack?
13:41:24 <quchen> What does "compatibility with Parsec" mean? Is Attoparsec supposed to be a drop-in-ish replacement for Parsec-based parsers?
13:41:46 <merijn> quchen: Most of the combinators exist in both, so you can mostly drop it in, yeah
13:41:46 <Cale> quchen: yeah
13:42:01 <Cale> But if there's no backtracking, then wtf does the Alternative instance do?
13:42:22 <Cale> plus :: (Monoid t) => Parser t a -> Parser t a -> Parser t a
13:42:22 <Cale> plus a b = Parser $ \i0 a0 m0 kf ks ->
13:42:22 <Cale>            let kf' i1 a1 m1 _ _ = addS i0 a0 m0 i1 a1 m1 $
13:42:22 <Cale>                                   \ i2 a2 m2 -> runParser b i2 a2 m2 kf ks
13:42:22 <Cale>                ks' i1 a1 m1 = ks i1 (a0 <> a1) m1
13:42:23 <Cale>            in  noAdds i0 a0 m0 $ \i2 a2 m2 -> runParser a i2 a2 m2 kf' ks'
13:42:36 <quchen> Glad we cleared that up.
13:42:39 <Cale> looks like backtracking to me
13:43:15 <Cale> (at least insofar as I can read that at all)
13:43:25 <quchen> I'm amazed how you can decipher that.
13:43:48 <Cale> It's setting the failure continuation to use the other parser
13:44:20 <hakujin> as far as efficiency do you guys see a better way to implement that parser? the Attoparsec.Text docs specifically note manyTill anyChar being slower compared to things like takeWhile1, etc, but I need to compare against a string and not just a char
13:44:49 <quchen> Interesting. I've heard numerous times that "try" is one thing that slows Parsec down considerably, and now the speedy Attoparsec has it built in by design.
13:45:22 <hakujin> bos: this question is right up your alley :)
13:46:02 <Cale> hakujin: If I determined that the whole thing was too slow, I'd probably attempt something like just splitting the string into chunks on each |
13:46:13 <quchen> Maybe I should open a ticket about the many* functions mentioning "try". That's pretty misleading in its current state.
13:46:31 <hakujin> Cale: good thought
13:47:49 <Cale> I wonder if this actually makes Attoparsec worse than Parsec for some languages
13:48:49 <greg`> how can we tell the good libraries from the bad in hackage?
13:49:04 <quchen> Hearsay, number of downloads. In other words, no.
13:49:12 <Cale> OH!
13:49:20 <Cale> Right, it doesn't.
13:49:28 <Cale> Well, it sort of does at the same time
13:49:32 <Cale> heh
13:49:42 <Cale> The main efficiency concern is a space concern
13:49:55 <Cale> But Attoparsec only works on strict ByteString and Text
13:50:17 <Cale> and can't efficiently deallocate the initial part of the string *anyway*
13:51:18 <hakujin> I believe Attoparsec now can consume lazy ByteString and Text
13:51:19 <Cale> and the whole string will need to be in memory from the outset (though attoparsec does have some stuff to try to deal with partial input)
13:51:31 <hakujin> maybe with a perf hit?
13:51:50 <Cale> iirc, the way that it deals with lazy bytestrings is rather poor
13:51:59 <Cale> (I could be wrong)
13:54:22 <Cale> iirc, in many cases, it'll end up allocating bigger and bigger strict bytestrings and the parser won't actually make progress until the whole lazy bytestring ends up converted to a strict one
13:54:39 <adelbertc> having issues installing attoparsec and bytestring for my cabal project (sandboxed), any suggestions? http://lpaste.net/3185435625486548992
13:54:39 <Cale> I remember someone else in #haskell having this problem
13:55:20 <user__> does "last" run in linear time?
13:55:22 <bitemyapp> Cale: seems like a streaming parser would be better if that's what you want.
13:55:54 <user__> i need a queue with constant time tail and append
13:56:00 <bitemyapp> user__: don't use a list.
13:56:06 <dcoutts_> adelbertc: hmm, weird, no error message. Can try with -v and see if we get any more info
13:56:11 <bitemyapp> user__: you probably want channels or vector
13:56:16 <user__> bitemyapp: no i should use two lists
13:56:23 <adelbertc> dcoutts_ - oh there's a lot of error messages, i trimmed those out, let me add 'em in
13:56:23 <user__> bitemyapp: what's a channel?
13:56:31 <bitemyapp> well fuck it then, I clearly don't know what the fuck I'm talking about
13:56:34 <bitemyapp> go for it, use two lists
13:56:34 <dcoutts_> adelbertc: heh, ok
13:56:45 <bitemyapp> user__: if you weren't going to listen, why ask?
13:56:51 <Cale> bitemyapp: Yeah, the solution just involved breaking the thing into chunks outside of attoparsec, and then mapping the parser over that lazy list.
13:57:06 * bitemyapp squints at Cale
13:57:08 <bitemyapp> Cale: ow.
13:57:14 <user__> bitemyapp: it was a joke referring to a hacky technique that runs in amortized constant that i don't wnat to use
13:57:21 <user__> bitemyapp: what's a channel?
13:57:30 <bitemyapp> @google haskell channel\
13:57:31 <lambdabot> http://hackage.haskell.org/package/base/docs/Control-Concurrent-Chan.html
13:57:31 <lambdabot> Title: Control.Concurrent.Chan
13:57:36 <bitemyapp> @google haskell vector
13:57:36 <lambdabot> http://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector.html
13:57:36 <lambdabot> Title: Data.Vector
13:57:39 <Cale> bitemyapp: In many cases that's a really easy thing to do
13:57:55 <Cale> (especially when you would have thought that it's possible to be lazy about things)
13:58:07 * bitemyapp pats lambdabot on the head
13:58:08 <quchen> Data.Sequence might also work.
13:58:10 <adelbertc> dcoutts - a closer look at my error messages leads me to beleive it's becuase of Mac OS Mavericks and GHC not playing nice: Data/ByteString.hs:388:3: error: invalid preprocessing directive #-}
13:58:27 <user__> quchen: was that for me?
13:58:30 <quchen> Yes.
13:58:31 <dcoutts_> adelbertc: ah yes, you're using the bad ghc / clang combo
13:58:38 <Cale> user__: Yeah, Data.Sequence makes a good queue structure
13:58:51 <Cale> user__: Or there are many other queues of various sorts on Hackage
13:59:04 <adelbertc> dcoutts - had no issues with base and containers so i assumed my setup was all good... needless to say i was wrong :-P
13:59:18 <user__> hm i always thought that vector's tail was o(n)
13:59:42 <bitemyapp> user__: if you want "queues" you probably want chan.
13:59:48 <quchen> Data.Sequence is probably the better choice (compared to Concurrent.Chan). It has a much more container-y API.
14:00:01 <DMcGill> hmm, cabal installing lens-4.0.0 is failing because of "ghc.exe: could not execute: cpphs"
14:00:02 <bitemyapp> quchen: CSP uber alles.
14:00:13 <Cale> Appending on vectors is really slow
14:00:28 <Cale> bitemyapp: But Chan is concurrent...
14:00:33 <Cale> and in IO
14:00:38 * quchen looks up CSP
14:00:53 <user__> Cale: yeah that was it; snoc is linear
14:01:04 <Cale> user__: What are you using the queue for?
14:01:09 <bitemyapp> Cale: ¯\_(ツ)_/¯
14:01:50 <user__> Cale: a stable marriage
14:01:54 <Cale> bitemyapp: If I was trying to write a pure function and happened to need a queue as part of my algorithm, then Chan would kind of be a terrible choice :)
14:02:18 <quchen> Cale: Right, TQueue has much better performance :-þ
14:02:21 <Cale> But I agree that probably most of the time you need something like a queue, it's for IO
14:02:58 <dcoutts_> edwardk: why is build-tools: cpphs commented out in the lens.cabal file? looks like it's needed
14:03:26 <edwardk> dcoutts_: because where i had put it wasn't legal cabal syntax and hackage wouldn't let me upload it with it there ;)
14:03:45 <dcoutts_> edwardk: ok ok apart from the fact that it's in the wrong place...
14:03:48 <edwardk> dcoutts_: i think it was supposed to be in a library or executable stanza
14:04:01 <DMcGill> so can I install lens-4 by unpacking and uncommenting that bit before installing?
14:04:04 <edwardk> dcoutts_: let me push a version that doesn't require cpphs. we mae the change
14:04:11 <dcoutts_> edwardk: yes, it's just like other dependencies
14:04:35 <edwardk> dcoutts_: i was floundering aroun trying to find an example and eventually punted
14:04:43 <edwardk> DMcGill: one sec
14:05:01 <DMcGill> thanks
14:05:17 <Cale> http://hackage.haskell.org/package/queuelike-1.0.9/docs/src/Data-Queue-Queue.html#Queue -- this is funny :D
14:05:40 <dcoutts_> edwardk: for future reference, Cabal user guide. http://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
14:06:05 * hackagebot lens 4.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.1 (EdwardKmett)
14:06:08 <quchen> Cale: Not sure in what way this is funny.
14:06:15 <edwardk> dcoutts_: yeah found that, but missed the "The following fields may be optionally present in a library or executable section" sentence at the start of the section at the time
14:06:16 <user__> so i'm guessing that drop 1 is data.seq's version of tail
14:06:23 <Cale> quchen: It prepares to use Data.Sequence, and then doesn't
14:06:33 <edwardk> DMcGill: released and tagged
14:06:36 <Cale> quchen: and the comments even indicate that it's going to, but it's all lists
14:06:37 <dcoutts_> edwardk: a 'k
14:06:38 <DMcGill> :)
14:06:50 <bitemyapp> Cale: that is perverse.
14:06:51 <Cale> user__: yeah
14:06:55 <quchen> Cale: -W to the rescue!
14:06:58 <bitemyapp> Cale: how do you hit version 1.0.9 like that?
14:07:25 <Cale> I think it's quite possible the author discovered that lists were faster
14:07:31 <quchen> Cale: On the other hand, I prefer the module this way. It's clear that it's trash by looking at the comment density so I won't try to use it and find out that the code is weird as well.
14:07:44 <edwardk> anyways cpphs found its way in as part of a fix for OSX's replacement of gcc with clang. the preprocessor became more anal retentive and  all previous ways to concatenate identifers now fail
14:08:15 <edwardk> i just changed out an X-Macro for a less sophisticated one with more boilerplate and we dropped the requirement the other day
14:08:24 <Cale> (but it still doesn't excuse not fixing the comments)
14:09:45 <edwardk> quchen: if you are already using lens i think there is a deque in there in an Internal module you can use ;)
14:10:10 <edwardk> http://hackage.haskell.org/package/lens-4.0/docs/Control-Lens-Internal-Deque.html
14:10:36 <quchen> edwardk: Why not Sequence?
14:10:38 <edwardk> that is a classic okasaki banker's deque
14:10:54 <edwardk> because Sequence was actually a lot slower for its usecase
14:11:19 <quchen> At a glance it looks similar to how TQueues are implemented
14:12:11 <quchen> edwardk: Why is it internal though? To avoid API clutter? It would probably make a nice (tiny) module on its own.
14:12:12 <Cale> http://hackage.haskell.org/package/dequeue-0.1.5/docs/Data-Dequeue.html -- there's also this
14:12:24 <edwardk> needs more lens
14:12:35 <edwardk> =)
14:13:29 <quchen> Cale: Giant class, one instance. Hmmmm
14:13:33 <edwardk> i was amused that almost the entire dequeue api was able to dissolve into typeclasses that were already around
14:14:10 <quchen> edwardk: Your dequeue is a close second to () in the race of being an instance of the most things.
14:15:16 <dennda> So if you try to install something that has a list of dependencies that rely on specific versions of packages, that themselves rely on specific versions (other versions) of the same packages, are you just screwed?
14:15:49 <merijn> dennda: Well, you can try manually changing some dependencies to make them more flexible (and submit a patch if it works)
14:16:09 <dennda> merijn: Right, that's basically what I meant with being screwed :)
14:16:15 <ReinH> edwardk: sad that there isn't a typeclass for fromList :(
14:16:16 <merijn> dennda: Then yes
14:16:22 <merijn> dennda: Blame the maintainers!
14:16:27 <edwardk> ReinH: that is changing
14:16:36 <ReinH> heh why am I not surprised
14:16:41 <dennda> merijn: Yeah, it's kind of a pain
14:16:46 <merijn> ReinH: 7.8 has OverloadedLists \o/
14:16:53 <edwardk> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
14:16:54 <ReinH> edwardk: and what deep theoretical underpinnings are you using for fromList?
14:16:55 <merijn> Or was it 7.10? I forget
14:17:06 <ReinH> o_O cool
14:17:13 <edwardk> the deep theoretical underpinning that someone just bolted it onto ghc
14:17:35 <merijn> ReinH: The theoretical underpinnings appear to be "Hey! You know what'd be cool?"
14:17:42 <Fuuzetsu> I'm looking for an image library which will let me load a static (non-animated) image and then access the individual pixels (with their colour values), any suggestions?
14:17:53 <edwardk> Fuuzetsu: try JuicyPixels
14:17:56 <andyroid> 5/2
14:17:58 <ReinH> edwardk: hah fair enough
14:18:05 <ReinH> I thought it was going to be cosomething
14:18:17 <Fuuzetsu> edwardk: Alright, I thought that might come up. I'll do that.
14:19:04 <andyroid> How to eval an expr in chat?
14:19:14 <codygman> > putStrLn "Like this"
14:19:15 <lambdabot>  <IO ()>
14:19:21 <edwardk> I also have some unreleased bindings to OpenImageIO, but i' have to bring them up to date, and installing the dependencies is hellish
14:19:28 <merijn> codygman: Except that lambdabot doesn't do IO :p
14:19:36 <codygman> merijn: As I saw
14:19:37 <geekosaur> if you're going to do a lot of it, open a /query to lambdabot
14:19:37 <merijn> codygman: For obvious security reasons
14:19:40 <ReinH> Hmm does OverloadedLists obsolete OverloadedStrings?
14:19:56 <andyroid> > 5/2
14:19:58 <lambdabot>  2.5
14:19:58 <edwardk> ReinH: no, for different syntaxes
14:20:04 <ReinH> ah right
14:20:13 <bitemyapp> ReinH: have you defined a string using ['a', 'b', 'c'] lately?
14:20:17 <ReinH> bitemyapp: heh
14:20:21 <ReinH> actually yes :)
14:20:25 <codygman> > 5.00000343425234/-2
14:20:26 <lambdabot>  Not in scope: `/-'
14:20:26 <lambdabot>  Perhaps you meant one of these:
14:20:26 <lambdabot>    `-' (imported from Prelude), `/' (imported from Prelude),
14:20:26 <lambdabot>    `/=' (imported from Data.Eq)
14:20:27 <bitemyapp> ReinH: pervert.
14:20:27 <shachaf> It's vaguely sad that OverloadedLists doesn't let you overload (:) and [] separately rather than just using fromList.
14:20:31 <codygman> err
14:20:32 <ReinH> bitemyapp: :D
14:20:33 <edwardk> hah
14:20:47 <andyroid> It is amazing how much better i got at coding embedded c after coding a lot of haskell
14:21:15 <edwardk> shachaf: clearly that should be part of the pattern synonym proposal. adding class associated bidirection patterns for (:)  and []
14:21:19 <shachaf> Just about every case I can think of where I'd actually want OverloadedLists doesn't work with that.
14:21:22 <edwardk> er bidirectiona
14:21:24 <edwardk> er l
14:21:27 <edwardk> blah
14:21:38 <shachaf> I don't know how much I care about matching.
14:22:05 <edwardk> i don't know how much i care about having the sugar at all, but someone will ;)
14:22:27 <edwardk> also matching is way cheaper on, say Text than consing
14:23:21 <shachaf> I just want to be able to express "heterogeneous" lists of some sort.
14:27:13 <quchen> Don't ViewPatterns do pretty much what you were asking for?
14:29:16 <shachaf> Who?
14:31:03 <zwarn> hallo dear people
14:31:35 <zwarn> i am doing research about extendable interpreters in haskell
14:32:26 <zwarn> i have found some papers from 1996 describing technics involving monad stacks
14:32:46 <ReinH> zwarn: what does "extendable" mean?
14:34:00 <zwarn> it should be as easy as possible to extend the language
14:34:25 <merijn> I'm guessing zwarn is referring to the "Moduler and Extensible Interpreters" paper?
14:34:33 <merijn> *Modular
14:34:34 <zwarn> in the papers i found they stacked modular monads
14:34:39 <zwarn> yes correct
14:35:49 <zwarn> is this still the way to go?
14:36:09 <merijn> Well, it depends on what you want to do with your interpreter
14:39:20 <zwarn> well it is not as much need because of the language i want to use it with but because of the research part
14:40:47 <merijn> zwarn: Basically, the techniques used in there are interesting and useful, but I probably wouldn't use it to build in an interpreter that way
14:41:11 <zwarn> what would you do?
14:44:02 <xintron> Data.Attoparsec.ByteString.parse allows me to use Lazy ByteString but parseOnly doesn't accept that. Should it really matter?
14:46:18 <platz> I was thinking of doing the 'Write Yourself a Scheme in 48 Hours' .  Is that a totally novice way to do an interpreter or is that somthing you can build on for more advanced work
14:46:51 <dibblego> with RebindableSyntax, are there any constraints to the types of e.g. fail? Why wouldn't I just make it (fail :: Void) or something nutty?
14:47:25 <merijn> dibblego: THe desugared code should typecheck
14:47:27 <platz> i noticed it uses some IORefs internally, but apparently this is needed for a decent interpreter?
14:47:37 <dibblego> (or, where is the documentation proper for RebindableSyntax — GHC user's guide 7.3.11? doesn't even mention it)
14:47:47 <merijn> platz: There's nothing bad about IORefs?
14:48:02 <dibblego> merijn: oh ok I think I see, thanks
14:48:34 <dibblego> maybe making fail :: Void so that type error is not such a bad idea :)
14:48:52 <merijn> dibblego: Agreed
14:48:53 <platz> merijn: I guess there's nothing intrinsically bad, no
14:56:26 <user__> wow
14:56:38 <user__> o(1) appends really makes it fly :>
15:01:21 <piezoid> hi
15:01:25 <piezoid> it is possible to make a zipWith for Church list (forall r. (a->r->r)->r->r) ?
15:03:09 <piezoid> or more general, if i have two traversal (Traversal' (f a) a, Traversal' (f b) b), i want to make Traversal' (f a, f b) (a, b)
15:05:17 <codygman> LOL... Haskell is second on the "Language voting leaderboard" for codewars.com now... it was 8th... then I posted it to /r/haskell
15:09:58 <Fuuzetsu> Oh cool, with LambdaCase we can use (.) like foo >=> return . \case …!
15:17:34 <platz> codygman: The hard part will be ensuring that someone who knows what their doing (and how to teach) creates the challenges
15:22:11 <codygman> platz: Agreed. Hopefully they allow the respective communities to help out with those things.
15:30:30 <JuanDaugherty> they're doing
15:42:48 <DMcGill> I have a function unCoord :: (Float, Float) -> (Float -> Float) that is symmetrical over the x and y axis. How I make a function that, if x and/or y is negative, negates it to give to unCoord and then negates that half of the result
15:43:05 <DMcGill> I can do it in 4 cases easily enough
15:43:13 <DMcGill> is there a way to do it in 1 or 2 lines?
15:43:15 <shachaf> What is a half of the result?
15:44:08 <DMcGill> 4 cases being: posCoord x y | x >= 0 && y < 0 = let (x',y') = coord (x,-y) in (x',-y')
15:44:55 <DMcGill> shachaf: I can't think of the word for it. The corresponding dimension? Coordinate? Point?
15:45:02 <nooodl> upload your code. i don't know what posCoord or coord are
15:45:09 <nooodl> or how unCoord relates to them
15:45:37 <DMcGill> posCoord is what  I'm trying to define, coord/unCoord :: (Float, Float) -> (Float, Float) and their actual defns are meaningless
15:45:44 <DMcGill> sorry I mixed the latter two up
15:45:56 <nooodl> oh it returns a tuple
15:46:10 <DMcGill> I just want to be able to only define my coord function over a quarter of ZxZ and take advantage of the symmetry
15:46:47 <nooodl> let (x', y') = coord (abs x, abs y) in (signum x * x', signum y * y')
15:46:58 <DMcGill> perfect thanks
15:47:52 <DMcGill> Component! That was the word I was looking for!
15:48:09 <shachaf> OK, so unCoord return (Float, Float)
15:48:32 <shachaf> Now the word "half" makes more sense.
15:48:47 <DMcGill> oh man I messed up that explanation too
15:48:57 <DMcGill> maybe I should just call it a night
15:48:58 <shachaf> (I wonder whether it should be called a "square root" instead.)
15:49:09 <nooodl> shachaf: :D
15:49:23 <DMcGill> sorry about all the typos, we got there in the end
16:05:13 <adelbertc> for MaybeT should i be using this? http://hackage.haskell.org/package/transformers
16:09:11 <Taneb> adelbertc, yes yes and thrice yes
16:09:35 <adelbertc> Taneb - just making sure :-) saw it wasn't updated in a while, then again i suppose there's not much to update for such a library
16:09:50 <adelbertc> thanks
16:17:41 <johnw>  I didn't even know there was another MaybeT!
16:18:20 <bitemyapp> johnw: wait wut
16:18:53 <johnw> transformers is my world
16:18:58 <johnw> and mtl my interface to it :)
16:21:14 <kristof> Ok, so, I asked in here a few days about about subtyping and why one wouldn't want to have it in a functional programming language
16:21:25 <johnw> I remember
16:21:38 <kristof> And I got some good answers but most of them had to do with how difficult it made type inference
16:21:51 <kristof> Also, there are some really bad problems with variance
16:22:27 <kristof> The former just sounds like "it's too hard / makes compilation take too long"
16:22:47 <geekosaur> it's not
16:22:50 <kristof> Besides the variance example, are there any clear semantic disadvantages to subtyping
16:24:56 <peddie> kristof: with subtyping, don't you actually lose information during type inference?  I don't think it's just a question of "this makes the compiler take longer to compile my program"
16:25:19 <geekosaur> type inference is not simply a matter of "that's too much like work", unless the work you are talking aout is having to be explicit about types everywhere in your program
16:25:28 <geekosaur> (that is, much more work for the programer)
16:25:30 <Eduard_Munteanu> kristof: subtyping is sort of redundant
16:25:42 <kristof> ...The same people popped up again
16:25:46 <kristof> I feel like a nuisance
16:25:58 <johnw> kristof: what is it that you want to solve with subtyping?
16:26:38 <kristof> johnw: A combination of sharing function definitions and enforcing some kind of general static typing.
16:27:00 <johnw> well, it depends on what you want the typing to mean
16:27:13 <kristof> johnw: Different bank account types.
16:27:18 <johnw> you can solve sharing via higher order functions, ADTs containing functions, type classes, etc.
16:27:37 <ReinH> johnw: speaking of which, mind if I ask you a question about mtl?
16:27:39 <johnw> there are many tools for abstracting common code available to you
16:27:44 <johnw> ReinH: go for it
16:28:15 <ReinH> if I have newtype Game a = Game (EitherT Quit (StateT GameState IO) a)
16:28:27 <ReinH> how do I evaluate that transformer stack in main?
16:28:31 <Eduard_Munteanu> I think OOP and subtyping are somewhat orthogonal.
16:28:41 <ReinH> s/EitherT/ErrorT if you want
16:28:45 <johnw> ReinH: you'll need to add a runGame accessor
16:29:02 <johnw> flip runStateT () $ runEitherT (runGame f)
16:29:04 <ReinH> ok pretend I did
16:29:14 <Eduard_Munteanu> ReinH: I would advise avoiding concrete transformers if you can
16:29:17 <johnw> you just keep "unwrapping" down to IO
16:29:25 <ReinH> Eduard_Munteanu: what would you prefer?
16:29:43 <johnw> I would recommend a type synonym too
16:30:02 <ReinH> ok, what's the suggestion then?
16:30:13 <johnw> there are a whole bunch of instances like MFunctor and MonadBaseControl that you don't want to have to derive/write yourself with a newtype wrapper
16:30:13 <Eduard_Munteanu> ReinH: (MonadState GameState io, MonadError Quit io, MonadIO io) => ... -> io Something
16:30:31 <ReinH> johnw: well I can derive those for my newtype
16:30:33 <johnw> ah, he means use the mtl
16:30:54 <johnw> you can, but there are about 30 lines of code you'll need to write in the end.  I've done it, many times...
16:31:26 <Eduard_Munteanu> ReinH: of course, your main function will still use runStateT and runErrorT.
16:31:35 <johnw> Eduard_Munteanu: that helps him with writing his functions, but not for creating his transformer stack
16:31:42 <johnw> right
16:32:41 <Eduard_Munteanu> Ah, well, that's the easy bit, each run* function basically unwraps the transformer into the wrapped monad
16:32:50 <Eduard_Munteanu> :t runMaybeT
16:32:51 <lambdabot> Not in scope: `runMaybeT'
16:32:55 <Eduard_Munteanu> :t runErrorT
16:32:56 <lambdabot> ErrorT e m a -> m (Either e a)
16:33:54 <johnw> ReinH: example: https://gist.github.com/8855330
16:33:55 <Eduard_Munteanu> :t runWriterT . runErrorT
16:33:56 <lambdabot> ErrorT e (WriterT w m) a -> m (Either e a, w)
16:34:04 <johnw> although I think some of that can be done away with if you use generalized newtype deriving
16:34:25 <ReinH> johnw: pretty much all of it in fact
16:34:42 <johnw> I don't think you can do MonadBaseControl that way
16:35:05 <johnw> I'm almost certain MonadUnsafeIO and MonadThrow can be
16:35:07 <johnw> this is older code
16:35:21 <bitemyapp> Eduard_Munteanu: they're not
16:35:38 <bitemyapp> Eduard_Munteanu: not as originally designed in Smalltalk. Subtyping and inheritance were part and parcel.
16:35:54 <johnw> sometimes I feel like subtyping is a hammer in search of a nail
16:36:07 <johnw> I've hardly missed it
16:36:18 <johnw> it depends on how you're used to thinking about solutions, I Guess
16:36:19 <bitemyapp> johnw: I think it's a pretty obvious way to do "code reuse" if you're not thinking very hard.
16:36:27 <johnw> if you're from an OO backgroundi t is
16:36:32 <bitemyapp> but obvious != good
16:36:44 <bitemyapp> johnw: most programmers without a background in maths don't really understand composition.
16:38:45 <johnw> I like how the functional paradigm inverts the primacy of relationship between objects and their methods; in OO "everything is an object" and methods are like these things that you talk about after sustaining that revelation.  Whereas in FP, it's the functions that matter and objects are mainly arguments and return values.  So composition is used to "build", rather than building more complex relationships between objects in isolation
16:39:33 <kristof> It's not an inversion of the relationship
16:39:36 <kristof> It's a generalization
16:39:55 <johnw> i mean, in OO you talk about objects, and tack on methods; in FP you do the opposite
16:39:55 <kristof> Obj.message(args) is syntactic sugar for (message-function obj arg arg)
16:40:44 <johnw> the same way that Set theory talk about sets and elements primarily; and then CT came along and starting talking about morphisms primarily
16:40:47 <kristof> johnw: Sure, but I think that's a syntactic illusion that puts blinders on the programmers eyes, and nothing more
16:42:01 <johnw> anyway, I no longer feel that the OO way of structuring solutions is any more "natural"; it's merely so if you've learned to think about problems in that manner
16:43:01 <johnw> I think a lot of people would like an extensible records solution that would get you very close to the kind of subtyping you want, though, kristof
16:43:06 <johnw> have you looked at "vinyl"?
16:44:15 <kristof> no
16:44:20 <johnw> @hackage vinyl
16:44:20 <lambdabot> http://hackage.haskell.org/package/vinyl
16:44:36 <kristof> johnw: I didn't say I wanted subtyping. I'm just trying to think of solutions to a lot of problems I abused inheritance for in Common Lisp.
16:44:55 <johnw> yeah, dynamic dispatch across multiple arguments was pretty fun
16:46:24 <tac> Subtyping has always felt really unnatural to me
16:46:33 <johnw> anyway, gotta run now, ttyl
16:46:35 <platz> F# is kind of interesting in that it's inference works better than scala's because OO isn't forced on you, and then you only have to provide type annotations in certain situations
16:46:37 <tac> Interfaces, sure, but subclasses? Yuck
16:46:51 <platz> they kind of live side-by-side instead of all mixed up
16:47:03 <tac> also, subtyping means variance and variance is more painful than death
16:47:12 <kristof> tac: elaborate
16:47:23 <tac> kristof: on which part?
16:47:36 <kristof> tac: Variance is death.
16:47:40 <tac> oh
16:47:52 <tac> It's just obnoxious to worry about variance when dealing with subtypes
16:48:33 <tac> I had an analogy once involving "bags of things"... and we all know that candy is a thing and also that razorblades are things
16:48:51 <tac> So on Halloween, if you mess up your variance, you may end up eating a bag of razorblades instead of a bag of candy.
16:49:19 <ReinH> Well that was stupidly easy once I figured out how they compose
16:49:40 <ReinH> runStateT . runEitherT . runGame
16:49:56 <mgsloan> I wouldn't mind being able to treat constructors as subtypes
16:50:01 <ReinH> johnw: ^
16:50:10 <kristof> tac: That wasn't very descriptive
16:51:00 <mgoszcz2> Hi. In Text.XML.HXT.Parser.HtmlParsec what's parseHtmlDocument for and how is it different from parseHtmlContent?
16:51:23 * hackagebot ghc-mod 3.1.6 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.6 (KazuYamamoto)
16:51:34 <tac> kristof: If you have a bag of candy, only candy can go inside, so it's safe to eat. You open your bag for your neighbor, who treats it as a bag of things. This is fair, since a bag of candy is a bag of things.
16:52:13 <tac> But since it's now a bag of things, he puts a razor blade in your bag, and he hasn't done anything wrong, as far as the type system is concerned
16:52:25 <kristof> tac: Immutability, next!
16:52:26 <tac> You take your bag of candy (because it was always a bag of candy to you), and you eat all the candy inside!
16:52:52 <monochrom> that is so collateral damage :)
16:53:10 <tac> kristof: The same thing happens if you can do subtyping with IORefs
16:53:46 <kristof> tac: References to volatile memory are mutable, so same problem
16:53:54 <tac> You have to answer the question, if a <: b, how are IORef a and IORef b related by subtyping?
16:53:55 <kristof> and same solution :^)
16:54:26 <platz> here's some lectures notes that explains some of the relationships with subtyping and variance https://www.dropbox.com/s/ag6hk3zzyb0af61/lecture_slides-section8-section8sum.pdf
16:54:31 <tac> If you have subtyping and any kind of reference (in a monad or otherwise), you have to deal with the issue of variance
16:54:34 <tac> It becomes a PITA
16:54:45 <tac> And your silly smiley face doesn't change that fact :)
16:54:48 <kristof> tac: I know exactly the problem you're talking about, I just don't think it's really prominent when you simply work with immutable data structures
16:55:08 <kristof> tac: Solution, don't subtype IORefs
16:55:18 <monochrom> I think you two are in violent agreement
16:55:32 <tac> kristof: Well, then you also can't do subtyping with lists, can you?
16:55:33 <kristof> monochrom: It's even worse than that, I'm furious! :P
16:55:39 <kristof> tac: Immutable lists, sure
16:55:45 <tac> IORefs are immutable!
16:55:52 <kristof> tac: They're references to mutable memory
16:56:23 <tac> So is a List.
16:56:35 <tac> Once you garbage collect a list, that memory might change
16:57:11 <kristof> People don't reference mutable memory when they reference a list, though.
16:57:17 <kristof> They reference the values in the list
16:57:25 <tac> The point is, subtyping is a PITA, and if you can weasle out of all the hoops you normally have to jump through, you should write a research paper on it
16:57:30 <kristof> Is this a hair splitting discussion? :/
16:57:38 <kristof> tac: I'll trust you on that.
16:58:03 <kristof> tac: Like I said before, I'm just trying to think of ways to translate some Common Lisp inheritance abusing code.
16:58:16 <kristof> I'm settling toward composition and higher order functions
16:58:59 <tac> anyway, I'm off
16:59:07 <tac> SUBTYPING IS EVIL DON'T FORGET
16:59:09 <tac> bye!
16:59:18 <Axman6> o.O
16:59:25 <Axman6> what is subtyping anyway?
16:59:53 <[swift]> evil
16:59:59 <[swift]> pay attention!
17:00:13 <Axman6> I got that bit, but how do I avoid it?
17:00:24 <Axman6> how do I know if I'm subtyping by accident?
17:00:38 <Axman6> does it happen when I have a tiny keyboard on my keyboard?
17:00:59 <kristof> check your keyboard for keyboards
17:01:05 <kristof> if you find a keyboard, check it for keyboard
17:01:10 <mgsloan> Or maybe if you're in an undersea vessel?
17:01:11 <DigitalKiwi> yo dawg i heard you like keyboards...
17:01:31 <[swift]> i'd also avoid quizno's
17:04:11 <WraithM>  
17:05:10 <pingu> Axman6: I'm wondering how your lz4 project went? That was you was it not?
17:16:28 <Axman6> pingu: it'd gone ok, though I've been working on something else for a while. I wasn't completely happy with my solution, but it does seem to work. you can peruse it at https://github.com/axman6/HLZ4 (very alpha so far, and I've got several changes I need to make)
17:24:41 <silasm> Axman6: yay compression in Haskell. I have an awful no-longer-functioning lz78 algorithm I wrote a while back. It was fun.
17:31:28 * hackagebot text-normal 0.1.0.0 - Unicode-normalized text  http://hackage.haskell.org/package/text-normal-0.1.0.0 (JoelTaylor)
17:34:26 <spidrd> how do you guys feel about idris?
17:39:33 <Cale> spidrd: pretty good
17:39:41 <silasm> spidrd: you know there's an IRC channel for it, right? :)
17:39:53 <Cale> spidrd: I'm a little bit sad that idris isn't lazy by default
17:40:04 <colDrMcBeardman> so. all monads are functors, right?
17:40:14 <Cale> colDrMcBeardman: yes
17:40:31 <colDrMcBeardman> but haskell doesn't know that, right?
17:40:34 <Cale> spidrd: But it's exciting to see people exploring dependent types for practical programming
17:40:40 <spidrd> silasm: sure, but I will probably get different opinions in here and there
17:41:14 <Cale> colDrMcBeardman: I think at the moment just for historical reasons (specifically, just that it was that way in Haskell 98), Monad isn't a subclass of Functor, but that will be changing soon.
17:41:37 <silasm> spidrd: I like it a lot but can't force myself to getting around to learn it. I'll like it more when there are better learning materials, but I know people are working on that.
17:41:46 <colDrMcBeardman> Cale, lulz, I assumed that would have been fixed in the three years since I last used haskell, but ok.
17:42:07 <colDrMcBeardman> is there something i can do in the meantime to get fmap to jive without being able to add someone's monad to functor?
17:42:18 <silasm> Cale: isn't it in 7.8?
17:42:27 <Cale> silasm: I believe so, yeah
17:42:31 <colDrMcBeardman> or actually.... can i instance it myself even if it's someone else's monad?
17:42:32 <silasm> awesome :D
17:42:38 <Cale> colDrMcBeardman: You can
17:42:38 <colDrMcBeardman> yes, good to hear!
17:42:43 <triliyn> colDrMcBeardman: I would be surprised if there were any extant monad instances that don't have functor instances
17:42:46 <colDrMcBeardman> Cale, ok cool, thanks.
17:42:50 <triliyn> But yes, you can write your own instance if you need to
17:42:53 <Cale> instance Functor Foo where fmap = liftM
17:42:59 <Cale> Or you can just use liftM
17:43:03 <Cale> Which monad is this?
17:43:11 <colDrMcBeardman> Delicious.
17:43:20 <Cale> You should complain if someone doesn't write a Functor instance for their monad.
17:43:36 <colDrMcBeardman> i didn't think of liftM, oops. still haven't internalized all the cat theory stuff :\
17:43:45 <colDrMcBeardman> i was trying to mapM, durrrh
17:45:53 <shachaf> liftM vs. fmap has nothing to do with cats and not much to do with category theory.
17:46:16 <shachaf> Functor can be seen as a particular special case of the category theory thing called a "functor", but you don't need to think about that and you probably shouldn't.
17:46:25 <shachaf> (If your goal is learning Haskell.)
17:46:30 <deontologician> Does anyone feel like helping me with a type-level proof?
17:46:35 <colDrMcBeardman> shachaf, oh, it's ok, i like maths.
17:46:47 <FreeFull> You probably shouldn't think about Haskell functors when learning category theory either
17:47:10 <ReinH> well, you can, but they aren't particularly interesting functors
17:47:37 <colDrMcBeardman> i also forgot everything i read in the "cat theory for cs majors" book by pierce.
17:47:44 <colDrMcBeardman> but i remember it being pretty neato.
17:47:59 <djahandarie> It's okay, he forgot everything in it too.
17:49:05 <colDrMcBeardman> djahandarie, is that a bad book? my goal in life is to have a huge library, so i bought that one because i am on a crappy budget and it was within my means.
17:49:28 <colDrMcBeardman> but if i should put something else on my acquisitions list, please make a suggestion.
17:49:41 <djahandarie> I haven't read it, but others have said it's not the best.
17:50:01 <djahandarie> My recommendation is a book that hasn't come out yet: http://www.maths.ed.ac.uk/~tl/bct/
17:50:26 <colDrMcBeardman> it's a lot like one of those "DEFINITION. THEOREM. PROOF." LaTeX math books with some PSFIG diagrams. woohoo. not bedtime reading material.
17:52:49 <deontologician> If anyone's interested: https://gist.github.com/deontologician/8856123
17:53:06 <deontologician> Having some trouble getting the type-checker to unify some types
17:54:21 <L8D> deontologician: camelCase is Haskell's standard
17:54:54 <L8D> deontologician: you also might want to try to implement an instance for compare instead of doing all of that...
17:55:10 <deontologician> L8D: ha, been doing too much python recently
17:55:12 <L8D> but I don't completely understand what you're doing or what the problem is
17:56:00 <deontologician> L8D: I'm abusing the type-checker to do some proof verification
17:56:06 <Cale> He's trying to prove the trichotomy law for the ordering on natural numbers
17:56:11 <benzrf> hey, how can i zipWith but use a default for if one of the lists is shorter?
17:56:40 <hpc> pick the list that's shorter and do list ++ repeat default
17:56:40 <L8D> benzrf: zipWith (+) foo (bar ++ repeat x)
17:56:54 <benzrf> bbbut i do not know which is shorter
17:57:19 <L8D> benzrf: write your own zipWith
17:57:24 <L8D> zipWithD
17:58:27 <benzrf> bah
17:58:52 <Cale> deontologician: I think the problem is that your recursive call doesn't actually have the same type...
18:00:25 <Eduard_Munteanu> :t \xs ys -> zipWith (liftA2 ?f) (fmap Just xs ++ repeat Nothing) (fmap Just ys ++ repeat Nothing)
18:00:26 <lambdabot> (?f::a -> b -> c) => [a] -> [b] -> [Maybe c]
18:00:38 <deontologician> Cale: The type seems similar, I thought it just couldn't determine that the parameters were the same
18:00:43 <benzrf> what is ?f
18:00:57 <FreeFull> A hole
18:01:04 <Eduard_Munteanu> benzrf: just a trick to get lambdabot to show some stuff
18:01:25 <Eduard_Munteanu> Now, liftA2 isn't quite appropriate there.
18:01:31 <Cale> deontologician: It should be telling that you haven't used EQS, LT2 or GT2 anywhere
18:01:36 <benzrf> O:
18:01:54 <Cale> I got it to build :)
18:02:12 <deontologician> Cale: yeah, that was bothering me, but I'm not sure how they fit in
18:02:13 <Cale> http://lpaste.net/99582
18:02:17 <Cale> ^^ like that
18:02:40 <Cale> You need to transform the proof to complete the inductive step
18:03:52 <deontologician> Cale: transform?
18:04:03 <Cale> deontologician: Look at my lpaste
18:04:18 <ReinH> Tekmo: ping
18:05:06 <Cale> deontologician: So, in the first case, for instance, we have Inr applied to a proof that Nat n :=: Nat m and we need to turn it into a proof that Nat (S n) :=: Nat (S m)
18:06:06 <deontologician> Cale: Oh I saw what you did, I thought maybe "transform" was some proof technique that led you to the solution you found
18:06:30 <Cale> deontologician: Well, I just mean that the proof we get back from the recursive call isn't complete
18:07:03 <deontologician> Cale: OK, that makes sense. It also alleviates my dirty feeling about not using the other rules
18:08:47 <Cale> You might have a bit nicer of a time doing this kind of thing in Coq or Agda
18:08:54 <deontologician> Cale: Ok, so what I was trying to do was return a proof that the property holds for one number less than was passed in. You need to re-successor it at the end to get the right output types, and you use the inductive rules for that
18:09:02 <Cale> (or even Idris!)
18:09:09 <Cale> yeah
18:10:19 <deontologician> Oh yeah, I know this is crazy verbose and haskell doesn't help you out or anything. I'll probably need to pick up Agda one of these days.
18:10:54 <deontologician> Trying to do some constructions from Bob Harper's HoTT lectures and I already know Haskell so I just whipped it up
18:11:31 <deontologician> Cale: Thanks again! Much appreciated
18:11:33 <Cale> Yeah, if you can write this, then you can probably already write Coq or Agda code by hammering on your keyboard until the checker accepts it :)
18:11:42 <deontologician> lol
18:12:15 <Cale> (Agda is a little more fiddly because of the fancy unicode symbols, but apart from the RSI you get trying to type them all, they're not so bad)
18:13:14 <deontologician> Would you recommend something else? I tried Coq once, and didn't really like the syntax
18:13:48 <Cale> If you're looking for something which is aimed at being a programming language more than a proof assistant, you could try Idris.
18:14:00 <Cale> Coq's syntax is a little dated, I agree, but it's not *that* bad.
18:14:47 <adelbertc> design question - from some sort of text file i want to read in a graph. i can read in the graph as { undirected, directed } x { unweighted, weighted } - i've done the horrible thing where i've accounted for all 4 scenarios in separate functions. should i instead factor it into 1 function that takes an additional param that's data GraphProp = Directed | Undirected | DirectedWeighted | UndirectedWeighted ?
18:14:56 <deontologician> ok cool, I'll check it out
18:15:18 <Cale> deontologician: (but you should probably look at all of them to at least some extent)
18:16:02 <adelbertc> i've tried both Coq and Idris, I found Coq to be very helpful in familiarizing myself with theorem proving (with tactics) and how it works (perhaps because CPDT exists for Coq), but Idris's syntax was much easier to wrap my head around
18:16:09 <Eduard_Munteanu> adelbertc: if you use Parsec it's quite straightforward
18:16:22 <Cale> adelbertc: If you can see something that's easy enough to factor out, then factor it out :)
18:17:02 <adelbertc> Cale - time to factor then!
18:17:34 <adelbertc> Eduard_Munteanu - yeah but i still have to decide how i want to try to parse it, if i want to be directed or undirected, etc.
18:20:11 <Eduard_Munteanu> adelbertc: GraphType <$> (Undirected <$ "undirected" <|> Directed <$ "directed") <*> (Weighted .....)    ?
18:20:37 <benzrf> wtf
18:20:47 <Eduard_Munteanu> If you use something like   data GraphType = GraphType Directedness Weightedness
18:21:26 <Eduard_Munteanu> Well, some tokenizing would be good in there.
18:21:57 <benzrf> :t replicate
18:21:58 <lambdabot> Int -> a -> [a]
18:22:39 <benzrf> >even 2
18:22:42 <benzrf> > even 2
18:22:43 <lambdabot>  True
18:22:44 <benzrf> mm
18:24:30 <Eduard_Munteanu> How do you apply something like 'show' using Data.Data.gmapQ?
18:25:03 <Eduard_Munteanu> :t gmapQ
18:25:04 <lambdabot> Data a => (forall d. Data d => d -> u) -> a -> [u]
18:25:31 <enthropy> Data gives you a type-case thing
18:25:58 <Eduard_Munteanu> enthropy: hm, which is it?
18:26:12 <enthropy>  \x -> case () of _ | Just y <- cast x -> show (y :: Double)
18:26:12 <Eduard_Munteanu> Perhaps Typeable stuff?
18:26:16 <Eduard_Munteanu> Hm.
18:26:29 <enthropy> and more cases for more types you feel like numerating
18:26:34 <enthropy> enumerating too
18:26:42 <enthropy> @hackage syb-with-class
18:26:42 <lambdabot> http://hackage.haskell.org/package/syb-with-class
18:27:19 <Eduard_Munteanu> enthropy: ah, it seems part of Data.Typeable
18:27:22 <Eduard_Munteanu> :t cast
18:27:23 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
18:27:32 <Eduard_Munteanu> Thanks.
18:27:36 <enthropy> that one can let you express "apply Show to any piece"
18:27:53 <enthropy> you can also build it up with mkQ and extQ
18:27:58 <enthropy> @type extQ
18:27:59 <lambdabot> Not in scope: `extQ'
18:29:08 <benzrf> @hoogle a -> Maybe a -> a
18:29:09 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:29:09 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:29:09 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
18:29:10 <enthropy> something like   mkQ "forgot this case!" (\x -> show (x::Int)) `extQ` (\x -> show (x::Double))
18:29:19 <benzrf> > asTypeOf 3 4
18:29:20 <lambdabot>  3
18:29:24 <benzrf> > asTypeOf "foo" 4
18:29:25 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
18:29:25 <lambdabot>    arising from the literal `4'
18:29:25 <lambdabot>  Possible fix:
18:29:25 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
18:29:28 <benzrf> wait wat
18:29:32 <benzrf> @src asTypeOf
18:29:32 <lambdabot> asTypeOf = const
18:29:35 <benzrf> o-o
18:29:54 <Eduard_Munteanu> benzrf: it differs only in the type
18:29:56 <Eduard_Munteanu> :t const
18:29:57 <lambdabot> a -> b -> a
18:30:05 <benzrf> what use is it o-o
18:30:31 <Eduard_Munteanu> benzrf: disambiguating types while avoiding ScopedTypeVariables
18:31:22 <enthropy>  x `asTypeOf` (undefined :: a -> Maybe a)
18:31:56 <enthropy> that's a hint that x is a function kind of like Just
18:32:04 <enthropy> but the `a' could be something more
18:32:41 <Eduard_Munteanu> > let f = show . asTypeOf 1 . read in f "001"
18:32:43 <lambdabot>  "1"
18:32:51 <enthropy>  x :: a -> Maybe a -- isn't nice to write even with ScopedTypeVariables, since then you need to write a type signature up top that will bind the 'a' variable
18:33:27 <benzrf> ah
18:33:46 <Eduard_Munteanu> :t let f = show . asTypeOf 1 . read in f
18:33:47 <lambdabot> String -> String
18:34:02 <kristof> mmmmm
18:34:20 <Eduard_Munteanu> > let f' = show . read in f' "001"
18:34:21 <lambdabot>  "*Exception: Prelude.read: no parse
18:34:24 <Finde> anyone mind lending a hand? I'm having trouble with cabal on OSX 10.9 - it keeps saying an update is available but even though it appears to successfully install, it gives me the same message after the install
18:34:55 <Eduard_Munteanu> Well, the "no parse" is sort of a lambdabot-specific behavior due to extended defaulting rules.
18:35:06 <Eduard_Munteanu> > let f' = show . read in f' "()"
18:35:08 <lambdabot>  "()"
18:35:41 <geekosaur> Finde: check your $PATH
18:35:48 <Eduard_Munteanu> In plain GHC it's going to complain the types are ambiguous.
18:36:05 <Finde> I just added the dir to the path and re-ran bash but no luck
18:36:17 <geekosaur> to the beginning or the end?
18:36:22 <Eduard_Munteanu> Finde: how did you add it to path?
18:36:29 <geekosaur> the first one found will be used so you want to stick it on the front of the path
18:36:30 <Finde> ah I added it to the end
18:36:33 <Finde> gotcha
18:36:34 <Finde> thanks
18:40:10 <adelbertc> Eduard_Munteanu - hm currently i have data Graph AdjList = DGraph AdjList | UGraph AdjList (D = directed, U =undirected). i played around with incorporated weightedness in there but decided against it.. i forget why though, i should probably revisit that to make sure
18:45:51 <Eduard_Munteanu> :t maybe "" show . cast
18:45:52 <lambdabot> Typeable a => a -> [Char]
18:46:05 <Eduard_Munteanu> :t gmapQ (maybe "" show . cast)
18:46:05 <lambdabot> Data a => a -> [[Char]]
18:49:16 <Eduard_Munteanu> > gmapQ (maybe "" show . cast) (Just True)  -- grr, defaulting
18:49:17 <lambdabot>  [""]
18:50:23 <enthropy> > gmapQ (maybe "" show . cast) (Just ())
18:50:23 <Eduard_Munteanu> Oh, hm, wait.
18:50:24 <lambdabot>  ["()"]
18:50:31 <enthropy> yes it is defaulting
18:50:34 <benzrf> what is gmapQ
18:50:34 <benzrf> o-o
18:50:45 <Eduard_Munteanu> benzrf: see Data.Data
18:51:11 <benzrf> :t gmapQ
18:51:12 <lambdabot> Data a => (forall d. Data d => d -> u) -> a -> [u]
18:51:13 <Eduard_Munteanu> enthropy: yeah, I was rather wondering why GHC doesn't like my show cast thing
18:51:13 <benzrf> wat
18:51:45 <Eduard_Munteanu> > gmapQ (maybe "" show . (cast :: a -> Maybe a)) (Just True)
18:51:45 <enthropy> because it has to know what type to try
18:51:46 <lambdabot>  Could not deduce (GHC.Show.Show d)
18:51:46 <lambdabot>    arising from a use of `GHC.Show.show'
18:51:46 <lambdabot>  from the context (Data.Data.Data d)
18:51:46 <lambdabot>    bound by a type expected by the context:
18:51:46 <lambdabot>               Data.Data.Data d => d -> [GHC.Types.Char]
18:52:14 <enthropy> > gmapQ (maybe "" (show::Bool -> String) . cast) (Just True)
18:52:15 <lambdabot>  ["True"]
18:52:35 <benzrf> :t fromMaybe
18:52:36 <lambdabot> a -> Maybe a -> a
18:52:43 <Eduard_Munteanu> enthropy: but I don't want to restrict it to Bool
18:53:01 <enthropy> then use syb-with-class, or template haskell
18:53:08 <Eduard_Munteanu> Ouch.
18:53:26 <enthropy> or list enough monomorphic types to satisfy yourself
18:53:27 <Aetherspawn> I feel sorry for Tekmo
18:53:31 <Aetherspawn> getitng bashed so hard on reddit
18:53:37 <Aetherspawn> for saying pipes is better than conduits
18:53:48 <Eduard_Munteanu> > gmapQ (maybe "" show . (cast :: a -> Maybe (forall a. Show a => a))) (Just True)
18:53:49 <lambdabot>  Illegal polymorphic or qualified type:
18:53:49 <lambdabot>    forall a. GHC.Show.Show a => a
18:53:49 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
18:53:54 <Eduard_Munteanu> Bleh. :)
18:54:09 <Taneb> Aetherspawn, pipes vs conduit has been going on for a while now and I don't think either side is particularly better than the other
18:54:25 <Aetherspawn> conduits are safer
18:54:28 <Aetherspawn> pipes are faster.
18:54:38 <mm_freak_> Aetherspawn: how?
18:54:47 <Aetherspawn> conduits have proper resource cleanup
18:54:47 <Taneb> Aetherspawn, I mean both sides have done their fair bit of bashing the other
18:54:53 <mm_freak_> Aetherspawn: pipes have that as well
18:55:08 <Aetherspawn> it's not as good, I talked with Tekmo about it once
18:55:16 <Aetherspawn> it requires a garbage collection versus being immediate
18:55:29 <Aetherspawn> which apparently has some merit in a server where resources are tightly strung
18:55:29 <mm_freak_> Aetherspawn: then you talked to him before pipes 4
18:55:36 <Aetherspawn> oh, yeah that was before.
18:55:39 <Aetherspawn> has it been fixed since?
18:55:43 <mm_freak_> yes
18:55:58 <Aetherspawn> well, in that case, I can't argue a merit for conduits anymore
18:55:58 <Aetherspawn> >.>
18:56:08 <Aetherspawn> does conduits have shortcut fusion?
18:56:43 <mm_freak_> Aetherspawn: both conduits and pipes are fused-by-construction
18:57:11 <kristof> Ugh, Template Haskell
18:57:18 <kristof> beautiful results, but such an ugly thing to work with
18:57:27 <Aetherspawn> pipes fuses things like
18:57:42 <Aetherspawn> recieve >-> map (+1) >-> process >-> map (+1) >-> send
18:58:08 <Aetherspawn> into recieve >-> map ((+1) . process_inner . (+1)) >-> send
18:58:29 <kristof> Aetherspawn: So is that like F#'s |>
18:58:30 <mm_freak_> Aetherspawn: that's by design, not by optimization, although it does some minor optimization to get even better performance
18:58:49 <mm_freak_> kristof: no, F#'s |> is for functions, not for stream processors
18:58:55 <Aetherspawn> yeah I just finished implementing shortcut fusion RULES for my pipes-courier library :)
18:59:05 <mm_freak_> kristof: it corresponds to a left-associative ($)
18:59:34 <kristof> mm_freak_: why is a stream processor not a function?
18:59:53 <mm_freak_> kristof: it is (sort of) a function, but (>->) is not function composition
19:00:45 <kristof> mm_freak_: a >-> b >-> c >-> d == d (c (b a)) ?
19:00:58 <mm_freak_> kristof: no, that's a type error
19:01:08 <kristof> mm_freak_: I'll google this then
19:01:25 <mm_freak_> kristof: define:  newtype Auto a b = Auto (a -> (b, Auto a b))
19:01:29 <mm_freak_> then write a Category instance
19:01:38 * hackagebot yaml 0.8.6.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.6.2 (MichaelSnoyman)
19:01:38 <mm_freak_> you will notice the difference between function composition and Auto composition
19:01:44 <kristof> mm_freak_: Codata?
19:01:50 <mm_freak_> a pipe is a generalization of Auto
19:02:15 <mm_freak_> this isn't related to data vs. codata
19:02:27 <kristof> mm_freak_: then comonad
19:02:33 <mm_freak_> no, category
19:02:37 <kristof> ffff
19:02:37 <kristof> ok
19:02:49 * kristof meanders off wondering what he just read
19:03:17 <jle`> another day in #haskell
19:03:41 <mm_freak_> the basic Auto abstraction is a family of comonads, but pipes' Proxy type is not
19:04:05 <kristof> mm_freak_: http://www.youtube.com/watch?v=2jdJGdA7AYs I'll watch this and get back to you
19:04:14 <mm_freak_> this is the basic idea of Proxy:  data SP a b = Get (a -> SP a b) | Put b (SP a b)
19:04:17 <mm_freak_> this is not a comonad
19:04:44 <mm_freak_> well, it's actually the more traditional Pipe…  proxies are bidirectional
19:05:15 <kristof> mm_freak_: SP == StreamProcessing?
19:05:35 <mm_freak_> pretty much
19:05:44 <mm_freak_> i read it as "stream processor"
19:07:09 <mm_freak_> add an underlying monad:  newtype SP m a b = SP (m (Either (a -> SP m a b) (b, SP m a b)))
19:07:21 <mm_freak_> change the type argument order and allow it to return
19:07:31 <mm_freak_> then you already have SP a b m r
19:07:43 <mm_freak_> this is pretty much Pipe
19:07:58 <mm_freak_> finally make it bidirectional…  then you have the full Proxy type
19:09:18 <Aetherspawn> mm_freak_: are you a pipes or a conduit fan
19:10:01 <mm_freak_> Aetherspawn: i'm not a "fan" of pipes, but i use it
19:10:25 <mm_freak_> in the sense of getting stuff done =)
19:10:40 <heatsink> mm_freak_: I wrote a Category instance for Auto.  Do you mean that |> is literally (\g f -> \x -> g (f x)) ?
19:10:48 <jrmithdobbs> mm_freak_: do you prefer it to conduit for any particular reason?
19:11:18 <mm_freak_> heatsink: F#'s (|>) is just flip ($)
19:11:24 <mm_freak_> and left-associative
19:11:36 <heatsink> I see
19:11:44 <mm_freak_> jrmithdobbs: it's fast, safe and easy to work with
19:12:15 <mm_freak_> jrmithdobbs: in particular when it comes to breaking streams down into chunks and processing them individually
19:12:35 <mm_freak_> this is something conduit is terrible at (in comparison)
19:13:31 <jrmithdobbs> mm_freak_: how so? that sounds like exactly what i use conduit for
19:14:10 <mm_freak_> jrmithdobbs: transFreeT processLine (lines stdin)
19:15:32 <jrmithdobbs> mm_freak_: CB.sourceFile stdin =$= processLine $$ CB.sinkFile stdout ...
19:15:45 <mm_freak_> jrmithdobbs: and if your lines are 1 GiB in length?
19:16:46 <jrmithdobbs> set buffering on stdin to 64k? that's what leftover is for?
19:17:26 <mm_freak_> jrmithdobbs: that's not the same thing…  processLine is not aware of the splitting…  to it the individual line is the whole stream
19:17:31 <jrmithdobbs> mm_freak_: i'm actually not sure how it behaves if you leave it at line buffering and have a huge line
19:17:54 <mm_freak_> jrmithdobbs: the leftovers problem simply doesn't come up here in the pipes version
19:18:37 <jrmithdobbs> mm_freak_: well, there's always sourceFile =$= sinkparser someattoparsecparser $$ sinkFile
19:19:04 <mm_freak_> jrmithdobbs: that's the point…  you need to hack your way around this limitation and you lose the separation of concerns
19:19:25 <mm_freak_> 'lines' deals only with splitting into lines, and processLine deals only with processing a line
19:19:29 <jrmithdobbs> using an incremental parser in a pipeline of incremental chunks is a hack?
19:19:36 <jrmithdobbs> i mean i agree it's not as elegant but that's a bit far ;p
19:19:48 <mm_freak_> jrmithdobbs: you're missing the point
19:20:32 <mm_freak_> think of a ready-made stream processor 'process'…  you don't write it, but it comes as a library function
19:20:53 <mm_freak_> by transFreeT-mapping it over chunks of a stream you can easily use it on individual lines or words or requests or whatever
19:21:42 <mm_freak_> similarly 'lines' is a library function…  by transFreeT-mapping you can write your individual stream processors without having to deal with line splitting or chunks or leftovers
19:23:54 <jrmithdobbs> mm_freak_: what's pipes' answer to resourceT?
19:24:19 <mm_freak_> jrmithdobbs: i just use ResourceT =)
19:24:29 <mm_freak_> pipes-safe has its own version, called SafeIO
19:24:42 <mm_freak_> but it's basically ResourceT in disguise and lacks a few features
19:26:52 <mm_freak_> the only advantage of SafeIO is that it uses 'exceptions' instead of 'monad-control', so your type signatures get a lot shorter and simpler
19:27:44 <sccrstud92__> if i have two ints a and b is there a better way to do this other than [min a b .. max a b]
19:27:54 <jrmithdobbs> mm_freak_: so what if you have a scenario where you desire leftover/await type behavior with pipes? eg, i notice pipes-aeson doesn't have a mode to stream object tuples or list/array elems
19:28:27 <jrmithdobbs> (object tuples meaning key/value pairs inside a json object)
19:28:38 <mm_freak_> jrmithdobbs: either you recurse with leftover or you feed the leftover back in
19:28:58 <mm_freak_> if p is the remaining stream and x is the leftover, just continue with (yield x >> p)
19:29:03 <sccrstud92__> is there a better way to do this ----- [min a b .. max a b]?
19:29:34 <sccrstud92__> @pl f a b = [min a b .. max a b]
19:29:34 <lambdabot> f = ap (ap . (enumFromTo .) . min) max
19:29:42 <sccrstud92__> :t ap
19:29:43 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:30:00 <mm_freak_> sccrstud92__: if a < b then [a .. b] else [b .. a]
19:30:18 <sccrstud92__> mm_freak_: why do you like that better?
19:30:51 <mm_freak_> sccrstud92__: i'm not sure that i do =)
19:31:04 <sccrstud92__> mm_freak_: i agree
19:31:14 <sccrstud92__> is there a version that can be generalize to enums?
19:31:34 <sccrstud92__> looking at the Enum class it doesnt seem so
19:31:41 * hackagebot persistent-postgresql 1.3.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.0.1 (MichaelSnoyman)
19:31:43 * hackagebot persistent-sqlite 1.3.0.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0.2 (MichaelSnoyman)
19:31:45 * hackagebot persistent-template 1.3.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.1.1 (MichaelSnoyman)
19:31:54 <mm_freak_> sccrstud92__: any Enum-only version would be a hack…  you need Ord for sensible min/max
19:32:27 <sccrstud92__> mm_freak_: im using min/max but I don't see why they are "necessary"
19:32:51 <mm_freak_> sccrstud92__: because that's the semantics of Enum, at least for most predefined types
19:33:08 <mm_freak_> sccrstud92__: if [5..4] were nonempty, this would break many applications
19:33:12 <sccrstud92__> mm_freak_: where is a good place to read about the semantics of enum?
19:33:23 <sccrstud92__> Enum*
19:33:26 <mm_freak_> sccrstud92__: the base source code =)
19:33:51 <sccrstud92__> i was looking for something more like design decisions
19:34:09 <sccrstud92__> i know what the functions do, i meant i wanted to read about why they chose them to work in that way
19:34:41 <sccrstud92__> i misunderstood what you meant when you said "semantics of enum"
19:37:05 <mm_freak_> sccrstud92__: well, special cases or conditional behavior is always a bad idea, at least from the viewpoint of many haskell programmers
19:37:41 <mm_freak_> [x..y] would be a different thing depending on the ordering of x and y
19:38:00 <flebron> Is there a sequence data structure that supports efficient splicing inside a sequence? That is, calls to "Insert the subsequence X at index i"?
19:38:21 <mm_freak_> flebron: what other operations do you need?
19:38:26 <sccrstud92__> flebron: Data.Sequence does that in O(log n)
19:38:57 <flebron> I don't think I need any others, I'll just have a bunch of pairs <index, subsequence>. Note that "index" will need to refer to the _current_ state of the sequence.
19:39:17 <ski> i suppose one could expect `forall a,b,x. elem x [a .. b] = True => (a =< x && x =< b) = True'
19:39:19 <flebron> So inserting <0, [1,2]> then <1, [3]> should yield [1, 3, 2].
19:39:43 <mm_freak_> flebron: you can get O(log n) with Data.Sequence or in some cases O(1) with a zipper
19:40:02 <sccrstud92__> mm_freak_: you might have the wrong idea. i like the way the [..] syntax works, and im not saying it should be any other way. I just figured that someone had run into the same situation as me and a better solution than [min a b..max a b] had been found
19:40:56 <mm_freak_> sccrstud92__: i think that solution is pretty good
19:40:56 <sccrstud92__> :t Data.Sequence.splitAt
19:40:57 <lambdabot> Int -> Seq.Seq a -> (Seq.Seq a, Seq.Seq a)
19:41:08 <sccrstud92__> :i Data.Sequence.(><)
19:41:16 <sccrstud92__> :t Data.Sequence.(><)
19:41:17 <lambdabot> Couldn't find qualified module.
19:41:19 <flebron> Yeah, I'm checking those two out :)
19:41:45 <sccrstud92__> those are the only one u need i think
19:41:50 <mm_freak_> sccrstud92__: if you're doing computation-heavy stuff you could in some cases benefit from the if-variant, because it does only one comparison
19:41:57 <sccrstud92__> mm_freak_: thanks for ur advice
19:42:02 <mm_freak_> but in general i would write [min a b .. max a b] as well
19:42:18 <sccrstud92__> mm_freak_: noted, but in this case it wont matter
19:42:53 <mm_freak_> also for base types GHC might actually optimize the second comparison away =)
19:44:34 <ski> should there be a `minMax' ?
19:45:25 <mm_freak_> uncurry enumFromTo (minMax x y)
19:45:44 <sccrstud92__> @hoogle minMax
19:45:44 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax module Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax
19:45:44 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax minmax :: StateVar (Maybe (PixelInternalFormat, Sink))
19:45:44 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax getMinmax :: Reset -> PixelData a -> IO ()
19:45:53 <sccrstud92__> :t minMAx
19:45:54 <lambdabot> Not in scope: `minMAx'
19:45:57 <sccrstud92__> :t minMax
19:45:58 <lambdabot>     Not in scope: `minMax'
19:45:58 <lambdabot>     Perhaps you meant one of these:
19:45:58 <lambdabot>       `IM.findMax' (imported from Data.IntMap),
19:46:00 <mm_freak_> sccrstud92__: hypothetical
19:46:04 <sccrstud92__> ah
19:46:10 <sccrstud92__> that would be nice
19:46:16 <mm_freak_> @let minMax a b | a < b = (a, b) | otherwise = (b, a)
19:46:18 <lambdabot>  Defined.
19:46:20 <mm_freak_> :t minMax
19:46:21 <lambdabot> Ord t => t -> t -> (t, t)
19:46:51 <mm_freak_> :t (\x y -> uncurry enumFromTo (minMax x y))
19:46:52 <lambdabot> (Enum b, Ord b) => b -> b -> [b]
19:47:26 <sccrstud92__> @let incRange x y = uncurry enumFromTo (minMax x y)
19:47:28 <lambdabot>  Defined.
19:47:36 <mm_freak_> not sure if this is really an improvement =)
19:47:39 <sccrstud92__> > incRange 1 10
19:47:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:47:48 <sccrstud92__> > incRange 10 1
19:47:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:48:15 <sccrstud92__> its less typing at the very least
19:54:18 <dhrosa> @pl \h -> step (head h) : h
19:54:19 <lambdabot> (:) =<< step . head
19:55:23 <dhrosa> that actually makes sense, probably not going to use that though
20:03:19 <Finde> are there any other known issues with loading packages on mavericks? I can't get GLFW to load into ghci
20:05:45 <Finde> looks like I hit a similar issue to this person https://ghc.haskell.org/trac/ghc/ticket/8490
20:21:47 * hackagebot conf 0.1.0.0 - Parser for Haskell-based configuration files.  http://hackage.haskell.org/package/conf-0.1.0.0 (carymrobbins)
20:26:48 * hackagebot free-game 1.0.3 - Create games for free  http://hackage.haskell.org/package/free-game-1.0.3 (FumiakiKinoshita)
20:27:47 <dhrosa> @pl f h = p (pc (head h)) (fd (head h))
20:27:47 <lambdabot> f = ap (p . pc . head) (fd . head)
20:27:56 <dhrosa> :t a `ap` b
20:27:57 <lambdabot>     Couldn't match expected type `m0 (a0 -> b0)'
20:27:57 <lambdabot>                 with actual type `Expr'
20:27:57 <lambdabot>     In the first argument of `ap', namely `a'
20:28:06 <dhrosa> :t ap
20:28:07 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:31:48 * hackagebot amazon-emailer 0.3.0.0 - A queue daemon for working with Amazon's Simple Email Service with a  PostgreSQL table as a queue.  http://hackage.haskell.org/package/amazon-emailer-0.3.0.0 (DanielPatterson)
20:31:50 * hackagebot amazon-emailer 0.3.0.1 - A queue daemon for Amazon's SES with a PostgreSQL table as a queue.  http://hackage.haskell.org/package/amazon-emailer-0.3.0.1 (DanielPatterson)
20:41:49 * hackagebot hamlet 1.1.7.7 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.7.7 (MichaelSnoyman)
20:41:51 * hackagebot shakespeare-js 1.2.0.3 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.2.0.3 (MichaelSnoyman)
20:41:53 * hackagebot shakespeare-text 1.0.1 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.1 (MichaelSnoyman)
20:42:21 <cheriez> Hi, I'm having trouble installing lens-4.0.1 (and 4.0) with ghc 7.4.1: http://lpaste.net/99587
20:44:15 <m3ga> cheriez: are you on OSX?
20:44:26 <cheriez> no, ubuntu
20:44:44 <m3ga> ubuntu LTS?
20:45:00 <cheriez> 12.04.4, yes
20:46:46 <m3ga> can't offer much. if it was osx, i think there was a known bug. that compiler is pretty old now. if you know about schroot you could set up a chroot for one of the later dev versions of ubuntu which should have ghc-7.6.3.
20:49:14 <cheriez> hm, okay. thanks
20:52:34 <peddie> cheriez: I think there's a #haskell-lens channel too
21:13:03 <Twey> cheriez: You can always install GHC outside your package manager, too
21:13:37 <Twey> Oh
21:13:51 <Twey> cheriez: But this looks like you might have run out of resources when compiling
21:15:06 <Twey> cheriez: Try giving GHC more memory: cabal install lens --ghc-options '+RTS -M600m'
21:15:51 <Aetherspawn> does anyone else experience a problem using Control.Concurrent.Async
21:16:18 <Aetherspawn> where if you make a heap of threads that spam stdout, it eventually locks up the terminal
21:16:23 <Aetherspawn> and nothing gets through
21:17:58 <Ralith> Aetherspawn: don't write to stdout from multiple OS threads at once
21:18:50 <Aetherspawn> Ralith: is it known to lock up?
21:41:57 * hackagebot llvm-general-pure 3.3.10.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.10.0 (BenjaminScarlet)
21:41:59 * hackagebot llvm-general-pure 3.4.1.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.1.0 (BenjaminScarlet)
21:42:02 * hackagebot llvm-general 3.3.10.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.10.0 (BenjaminScarlet)
21:42:04 * hackagebot llvm-general 3.4.1.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.1.0 (BenjaminScarlet)
21:47:42 <cheriez> Twey: oh sorry, i went to the haskell-lens channel. it turns out dmesg was giving me errors like "[2977352.321772] traps: ghc[17582] general protection ip:109ea2f sp:7fff79d86bf8 error:0 in ghc[400000+20ea000]" on compiling Control/Lens/At.hs. I'm just going to upgrade ghc
21:50:35 <Twey> cheriez: That just means you've segfaulted, which happens when you run out of memory (malloc() returns a null pointer, which applications usually don't check for, so you get a segfault)
21:52:52 <cheriez> Twey: i tried it, but it made no difference
21:53:29 <cheriez> but wouldn't ghc which is a haskell program spit out some sort of memory error instead of derefing a null ptr?
21:54:45 <c_wraith> cheriez: were you using the ghc 7.8 rc?  It has known issues compiling lens
21:54:48 <Twey> cheriez: You might need to actually increase the amount of memory available (e.g. by adding swap to your system)
21:55:05 <c_wraith> cheriez: (and other things of course)
21:55:09 <Twey> I mean, by all means upgrade GHC too — nobody should be stuck on 7.4 :þ
21:55:39 <cheriez> c_wraith: no, ghc 7.4.1
21:56:29 <Twey> cheriez: GHC isn't (entirely) a Haskell program, and the GHC runtime AFAIK doesn't do anything sensible when it runs out of memory anyway
22:05:37 <Aetherspawn> iugh
22:05:56 <Aetherspawn> I hate it when people use a stupid module name without dots
22:06:07 <Aetherspawn> like MyLibraryAndThisSubmodule
22:06:26 <Aetherspawn> but then they take a really popular and easily searchable name on hackage, so theres no room for someone to make a better one
22:12:18 <lispy> Aetherspawn: IMO we should call this the shakespear problem ("Would a rose by any other name...")
22:12:43 <Aetherspawn> not hating towards the person who made pipes-cereal-plus or anything
22:13:07 <Aetherspawn> but its most unidiomatic pipes package in the entire ecosystem and it binds cereal-plus so it doesn't leave many places to go
22:13:12 <lispy> don't hate the contributor, hate the name
22:13:47 <Aetherspawn> absolutely, I'm only hating on the name :P in fact, pipes-cereal is missing and i have no idea why. As soon as I upload pipes-courier I'm going to do something about it
22:14:08 <lispy> hackage squatting :(
22:17:57 <Aetherspawn> java solves the issue very lightly
22:18:02 <ivanm> don't you love it when you're comparing your code to someone elses, so you copy-paste their code into yours... and their library is _still_ faster? :s
22:18:18 <Aetherspawn> by requiring people put the name of their domain before the package namespace thing
22:18:42 <shachaf> do you turn on optimizations
22:19:24 <lispy> ivanm: heh
22:19:43 <ivanm> shachaf: neither cabal file has any listed that I can see, so I'm assuming it's using cabal's default of -O
22:19:51 <lispy> Aetherspawn: I feel like that side steps the problem instead of addressing it.
22:20:01 <lispy> Aetherspawn: We still want short names for things when we discuss them
22:20:16 <ivanm> OK, I somehow missed the glaringly obvious -O2 in the other library :s
22:20:35 <lispy> ivanm: You should try -O while you're there
22:20:51 <Aetherspawn> the only real solution might be a quality controlled hackage :P
22:20:52 <lispy> ivanm: -O2 is supposed to only be a win in specific cases...
22:21:03 <Aetherspawn> but then theres a bit of argument over what that means
22:21:03 <fragamus_> @pl (\x-> topLeft' + (stepDown' * (fromIntegral (x `div` horizontalResolution))) + (stepRight' * (fromIntegral (x `mod` horizontalResolution)))   )
22:21:04 <lambdabot> ap ((+) . (topLeft' +) . (stepDown' *) . fromIntegral . (`div` horizontalResolution)) ((stepRight' *) . fromIntegral . (`mod` horizontalResolution))
22:21:06 <lispy> ivanm: obviously, YMMV
22:21:07 <ivanm> yeah, that's what I thought, and that cabal applied -0 automatically
22:21:21 <lispy> ivanm: You mean -O0 ?
22:21:25 <ivanm> lispy: I'm not doing math or parallel stuff, so I don't think -O2 will make a difference
22:21:31 <lispy> ivanm: -O == -O1, IIRC
22:21:33 <ivanm> no, just -O (which is equal to -O1)
22:21:53 <lispy> ivanm: I'm pretty sure cabal doesn't optimize at all, but I'd be happy to be wrong.
22:22:02 * hackagebot range-set-list 0.0.2 - Memory efficient sets with continuous ranges of elements.  http://hackage.haskell.org/package/range-set-list-0.0.2 (phadej)
22:22:05 <ivanm> @google cabal install optimisations
22:22:06 <lambdabot> http://www.haskell.org/ghc/docs/7.0.2/html/Cabal/builders.html
22:22:06 <lambdabot> Title: 4.�Building and installing a package
22:22:09 <ivanm> bah
22:22:50 <lispy> ivanm: oh cool
22:22:56 <lispy> ivanm: you are right:  level 1 is the default if no n parameter is given
22:23:02 <lispy> ah
22:23:05 <lispy> actually
22:23:09 <ivanm> nope, adding -O2 doesn't do anything
22:23:14 <lispy> I bet they mean, if you say --enable-optimizations then 1 is the default
22:23:36 <lispy> (default) Build with optimization flags (if available). This is appropriate for production use, taking more time to build faster libraries and programs.
22:23:39 <lispy> The optional n value is the optimisation level. Some compilers support multiple optimisation levels. The range is 0 to 2. Level 0 is equivalent to --disable-optimization, level 1 is the default if no n parameter is given. Level 2 is higher optimisation if the compiler supports it. Level 2 is likely to lead to longer compile times and bigger generated code.
22:23:46 <ivanm> well, the optimisation field defaults to True in ~/.cabal/config
22:23:50 <fragamus_> :t ap
22:23:51 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:29:32 <jle`> :t (<*>)
22:29:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:32:17 <jle`> hm. you can build Windows 8 apps using HTML5 and Javascript
22:32:33 <jle`> does anyone know if anyone has built a full app using Fay/ghcjs/haste/etc. ?
22:32:44 <jle`> or even Elm for that matter
22:32:51 <ivanm> jle`: chrisdone has with Fay, strangely enough... :p
22:32:56 <ivanm> I believe lpaste uses Fay
22:33:25 <jle`> ivanm: oh i was referring to Windows 8 apps
22:33:27 <jle`> on the app store
22:33:40 <ivanm> that I haven't heard of
22:33:58 <jle`> because technically you can build an entire windows 8 app on haskell
22:34:08 <jle`> or maybe there are some approval hoops you must jump through
22:34:33 <jle`> i think i'd give it a shot if i had any app ideas
22:36:26 <jle`> (who needs ghc ios anyway?)
22:36:28 <jle`> :P
22:39:10 <fragamus_> haskell is great for multicore; how does scala measure up on that score
22:39:42 <fragamus_> (my company has one haskeller, and lots of scala folks
22:39:43 <fragamus_> )
22:41:02 <ivanm> fragamus_: why ask here?
22:41:10 <fragamus_> sorry
22:41:28 <ivanm> we wouldn't know as well as #scala would
22:41:40 <fragamus_> i guess I am already decided on haskell i just want the scala guys to have a puzzle
22:52:05 * hackagebot yesod 1.2.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.5 (MichaelSnoyman)
22:52:07 * hackagebot yesod-bin 1.2.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.6 (MichaelSnoyman)
22:52:09 * hackagebot yesod-core 1.2.6.7 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.7 (MichaelSnoyman)
22:53:23 <Twey> Heh, GHC produces some wacky error messages
22:53:36 <dmj> is there a better way to write this
22:53:37 <dmj> showTxt :: Show a => a -> [Text]
22:53:38 <dmj> showTxt str = [ T.pack $ show str ]
22:53:38 <dmj>  
22:53:59 <Twey> You get used to them after a while, then suddenly it hits you that ‘The first argument of ($) takes one argument, but its type has only one’ is not a reasonable error description
22:54:19 <dmj> showTxt = return . T.pack . show
22:54:56 <Aetherspawn> mm_freak_: do you know how to use the new Pipes.Binary interface in a chain of >->'s
22:55:07 <Aetherspawn> I really dislike the direction it's gone with the do-notation and lenses stuff
23:19:29 <ReinH> Twey: yeah I've been enjoying the "x takes two arguments but you provided two" errors
23:19:32 <ReinH> wait what
23:22:51 <Twey> Honestly, I don't even read the error messages most of the time — I just go to the term it's complaining about and look around for where I've done something stupid
23:23:01 <bitemyapp> ReinH: I've started getting wary of mixing infix and $.
23:23:12 <Twey> Probably a C++ habit :þ
23:23:17 <bitemyapp> Twey: it depends for me on what kind of error it is.
23:23:25 <bitemyapp> Twey: if it's a relatively trivial and local error, yeah I just look at the terms.
23:23:41 <bitemyapp> Twey: but if it's something I'm doing in the process of learning a new API, I generally read the errors carefully first, then the terms.
23:23:44 <Twey> Right, I'll read the error after I've stared at it for a while and can't figure it out
23:24:03 <bitemyapp> I'm saying I'll read the type errors first if I already know it's a non-local/non-trivial thing.
23:24:10 <bitemyapp> because it'll teach me what I need to know about the API
23:24:13 <bitemyapp> usually followed by a :t
23:24:37 <bitemyapp> because it's usually highlighting some disagreement in my mental model with reality and is more informative than staring at my misconceived code.
23:24:58 * Twey nods.
23:25:27 <bitemyapp> whereas if it's a "mere mistake", yeah, straight to the terms
23:25:39 <bitemyapp> because if my mental model is essentially correct then I'm capable of evaluating and debugging terms myself.
23:37:11 * hackagebot hsimport 0.2.8 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.8 (DanielTrstenjak)
23:45:46 <xintron> I have an attoparsec parser which fetches a ByteString of hexadecimal values. If I want to allow user input to add hexadecimal filtering on matched rows, how could I do that efficiently?
23:46:04 <xintron> By taking the full bytestring and run `inFixOf`?
23:53:14 <mm_freak_> Aetherspawn: which ones?
23:53:37 <Aetherspawn> pipes-binary uses to have a decodeGetMany which was a straightforward Producer(?)
23:53:56 <Aetherspawn> now all this new lens stuff in pipes-binary is really confusing ... I just want to stream ByteStrings in one side and get things out the other
23:54:14 <Aetherspawn> /s/uses/used/
23:56:21 <Heather> may someone explain in nutshell what is wrong in  getExecutablePath >>= </> "sync.yml"
23:56:44 <Heather> should I just add return to getExecutablePath and don't use >>= ?
23:56:45 <jle`> Heather: you need parentheses around sections
23:56:58 <jle`> otherwise it's kinda ambiguous
23:57:01 <jle`> it's just a syntax rule
23:57:02 <Heather> alike?
23:57:10 <Heather> getExecutablePath >>= (</>) "sync.yml" ?
23:57:23 <jle`> are you trying to do (</> "sync.yml") ?
23:57:34 <jle`> :t (</> "sync.yml")
23:57:34 <lambdabot>     Not in scope: `</>'
23:57:35 <lambdabot>     Perhaps you meant one of these:
23:57:35 <lambdabot>       `<>' (imported from Data.Monoid),
23:57:39 <jle`> drat
23:57:50 <Heather> seems like not...
23:57:53 <jle`> but it won't work either, you're right
23:57:57 <Heather>  Expected type: FilePath -> IO Char
23:58:02 <jle`> becuase the left hand side of the bind has to be an IO action
23:58:10 <jle`> in this case...you're just applying a pure function to the result
23:58:13 <jle`> you can just use fmap for that
23:58:23 <jle`> (</> "sync.yml") <$> getExecutablePath
23:58:27 <Heather> left type is IO
23:59:20 <Heather> jle` I don't need IO in out
