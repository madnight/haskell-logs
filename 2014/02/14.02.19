00:00:20 <treehouse> hc: I've done that, but I keep getting messages from the server that "orzo has sent you a message.. type blah blah to read it"
00:00:33 <hc> he doesn't seem to be identified, so +R should stop that
00:00:59 <treehouse> and now he's sending me PMs from other user names, to circumvent my /ignore .. (same IP.. identified user)
00:01:27 <treehouse> wow, he's really raging now.... he starts to send me obscenities.. Please orzo, just stop it!
00:01:34 <hc> then you might want to talk to freenode staff in #freenode
00:01:37 <orzo> can we ban him?
00:01:55 <orzo> he's just trying to annoy me
00:01:56 <treehouse> hc: they'll just tell me to ignore him
00:02:07 <treehouse> orzo: don't try to make this look bad on me
00:06:09 * uiop places imaginary bitbet that orzo and treehouse are same person
00:07:11 <davean> well one of them is connected via tor ...
00:07:35 <orzo> might be a friend messing with me
00:07:38 <orzo> but i've no idea
00:08:21 <uiop> heh, i did't realize what channel this was, but imaginary bitbet still stands :)
00:08:32 <uiop> *didn't
00:09:02 <orzo> if i took the bet, how could i prove he's not me?
00:09:37 <treehouse> just stop PMing me from different hosts orzo, and I'll be glad  to say that I'm not you.
00:10:07 * hackagebot xml-lens 0.1.5 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.5 (FumiakiKinoshita)
00:10:07 * hackagebot fields-json 0.2.2.3 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2.2.3 (GracjanPolak)
00:10:10 <uiop> orzo: you would take an imaginary oath which and we would both swear by richard simmons
00:10:11 <simpson> treehouse: Set +g, seriously.
00:10:51 <simpson> If it persists, go to #freenode.
00:10:57 <treehouse> k, thnx
00:17:24 <orzo> i suppose this is relevent: http://www.youtube.com/watch?v=njoFI6fuo7I
00:17:35 <orzo> :P
00:35:44 <exicer_> If I wanted to create a new datatype, Email, is there any way to place the constraint on it that it should be Text of a certain pattern ?
00:36:50 <Cale> exicer_: Not really. You could define it to be the pieces which go into that pattern, and then write a function which turns it into Text
00:37:08 <exicer_> Cale: That is what I thought
00:37:21 <exicer_> I was asking because I have just started reading about quickcheck
00:37:29 <exicer_> and it seems very good for testing numeric things
00:37:34 <exicer_> but not so good for text based things
00:38:00 <Cale> exicer_: In a dependently typed language, you could do more. Theoretically, you could probably do more by exploiting Haskell's type system, but something like that would be extremely hairy and not worth the trouble.
00:38:29 <Cale> Oh, you can certainly test QuickCheck properties of Text
00:38:46 <exicer_> Well, say I had a function that I don't know.. extracts the domain from an email address.
00:39:00 <exicer_> How do I test such a function ?
00:39:23 <laura_h> beginners question: In the Prelude I see the definition of reverse as: reverse          =  foldl (flip (:)) []    and the call with reverse "abc" worx well. But how do I make the same on command-line?
00:39:24 <mgsloan> One good approach is to have a newtype that wraps Text, and only export a function to create it, which checks for the pattern
00:39:25 <jle`> exicer_: perhaps you could have a list of domains, and generate a bunch of random email addresses based on those domains? and now you know what corresponds to what
00:39:29 <laura_h> foldl (\x y -> flip (:) x y) "abcde" doesn't work
00:39:31 <laura_h> ?
00:39:35 <jle`> and make an Arbitrary for that newtype
00:39:54 <jle`> laura_h: do you mean how to define reverse on ghci?
00:40:06 <jle`> let reverse = foldl (flip (:)) []
00:40:21 <exicer_> jle`: Hmm, I think I will have to read a bit more about quickcheck.
00:40:37 <laura_h> jle`: no more how to exectue it on command line, cause the lambda stuff is little bit too short to understand (for the very moment)
00:41:12 <laura_h> i.e how to write a one-liner on command line without using the reverse-function....
00:41:25 <jle`> er
00:41:38 <jle`> > (foldl (flip (:)) []) "hello"
00:41:40 <jle`> ?
00:41:40 <lambdabot>  "olleh"
00:41:44 <laura_h> more or less some kind of 'wanna look behind the curtain' resp. 'understanding the ..'
00:42:23 <jle`> do you mean ghci, or from the unix shell?
00:42:30 <laura_h> ghci
00:42:59 <jle`> do you want to trace the evaluation?
00:43:04 <jle`> i'm not totally sure what you are asking
00:43:15 <osa1> I hate RecordWildCards, makes code harder to read because of name overloading
00:43:19 <laura_h> jle`would be beneficial
00:43:38 <jle`> @src foldl
00:43:38 <lambdabot> foldl f z []     = z
00:43:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:43:45 <jle`> easiest way is just to do it by hand, which isn't that hard
00:43:50 <apples> if i have data X = A a | B a, is there a way i can have data Y = Y (B a) b? a, b are concrete types
00:43:56 <jle`> all evaluation in haskell is just substitution
00:43:57 <startling> laura_h, there's Debug.Trace
00:44:10 <apples> i tried DataKinds to no avail
00:44:14 <jle`> so just replace foldl (flip (:)) [] "hello" with the definition of foldl
00:44:19 <startling> laura_h: in general execution is difficult-to-follow because of laziness
00:44:24 <startling> jle`: (not strictly true)
00:44:59 <jle`> (conceded)
00:45:22 <jle`> but if laura_h just wants to see what happens when they call reverse
00:45:37 <jle`> then substitution would be a good way to see what is 'going on'
00:46:14 <startling> fair enough.
00:46:26 <startling> I don't know anything about most of these tools, but there's http://www.haskell.org/haskellwiki/Debugging
00:46:32 <startling> hood and hat look useful
00:46:44 <laura_h> jle` would be good to see, cause I have little bit troubles to understand why (flip (:)) worx and (++) doesn't
00:47:14 <laura_h> foldl (++) [] "hello"
00:47:25 <jle`> foldl (flip (:)) [] 'h':"ello"   --->  foldl (flip (:)) ((flip (:)) [] 'h') 'e':"llo"
00:47:34 <jle`> @src flip
00:47:34 <lambdabot> flip f x y = f y x
00:47:55 <startling> > foldl f a [b, c, d] :: Expr
00:47:58 <lambdabot>  f (f (f a b) c) d
00:48:12 <jle`> so (flip (:) [] 'h') is 'h':[], which is "h"
00:48:39 <jle`> the next step you'll do (flip (:) 'e' "h"), which is 'e':"h", which is "eh"
00:49:01 <jle`> sorry
00:49:02 <supki> apples: B a  has no inhabitants, so I'm unsure why would you want that
00:49:05 <laura_h> jle`: Uhu, thx for the details... Another question
00:49:06 <jle`> flip (:) "h" 'e'
00:49:18 <jle`> the next step will be (flip (:) "eh" 'l')
00:49:23 <jle`> which is "leh"
00:49:39 <jle`> next is (flip (:) "leh" 'l'), which is "lleh"...etc.
00:49:48 <jle`> > flip (:) "leh" 'l'
00:49:50 <lambdabot>  "lleh"
00:49:58 <laura_h> doesn't it grow by quadratic time, cause you have to skip first to the end of the list before putting everything together?
00:50:00 <apples> supki, i meant for it to be like B String or something. anyways, i think i'm just going to use String instead of trying to be clever
00:50:14 <jle`> a lot of this stuff kinda solves itself with a pencil and paper
00:50:33 <jle`> laura_h: you don't skip to the end of the list ever
00:50:39 <laura_h> jle`: Yeah, even nowadays ;)
00:50:45 <supki> apples: well, ok, but there's no values of type  B String  anyway
00:50:51 <jle`> to combine "leh" and 'l', you only need to do 'l':"leh"
00:50:57 <supki> apples: data promotion is mostly useful for phantom types
00:51:02 <jle`> which is O(1)
00:51:18 <apples> supki, but B is a data constructor, not a type
00:51:46 <jle`> remember that these are singly (forward) linked lists, and it is constant time to append a single node to the front of a singly linked list.
00:52:01 <laura_h> so, concat is done immediately and not memorized to concat afterwards, right?
00:52:02 <jle`> even for persistent/immutable data structures
00:52:10 <jle`> there is no concatenation happening, only consing
00:52:25 <laura_h> yeah, sorry consing instead of concat
00:52:54 <jle`> well...it actually builds up a giant thunk chain of conses
00:53:02 <jle`> that is done at the end
00:53:20 <jle`> but the collapsing of the thunk is O(n) i believe
00:53:24 <laura_h> jle`: what is the difference between the two words 'consing' and 'concat' (the first is :  and the second?)
00:53:26 <supki> apples: in  data Y = Y (B a) b  "B a" is a type
00:53:33 <jle`> laura_h: concat would be (++)
00:53:34 <supki> apples: Y :: B a -> b -> Y
00:53:34 <startling> :t concat -- laura_h
00:53:35 <lambdabot> [[a]] -> [a]
00:53:46 <jle`> ah yes and the concat function
00:53:53 <jle`> concat works between two lists
00:53:59 <apples> supki, sorry, that part of my statement was imprecise (because i didn't know how else to state it)
00:54:00 <jle`> consing appends a single item to a list
00:54:03 <laura_h> jle`: Uh, ok, that function...
00:54:40 <supki> apples: you can promote X to be a kind for B to be a type constructor, but then B a has no values
00:55:00 <supki> apples: so I don't understand what you're trying to do :)
00:55:12 <jle`> actually in a strict language, concat inevitably requires the duplication of the entire first list, so evne concatenating something like [1] ++ [2,3,4] requires creating a 1:[] list and then duplicating it to a 1:2:3:4:[] list.  save smart compiler optimizations of course
00:55:20 <apples> supki, like i said, just trying to be too clever for my own good :) problem solved
00:55:36 <jle`> because these lists are immutable, remember
00:56:00 <jle`> so concat and cons are fundamentally different things
00:56:47 <apples> (still trying to get used to the idea of DataKinds in general)
00:57:58 <laura_h> jle`: thx for the details. I didn't really thought about up till now bout the immutability of lists - but thinking of it makes sense.... thx
00:58:25 <jle`> laura_h: immutability of lists is kinda cray.  imagine doing something like [1,2,3] ++ [4,5]
00:58:35 <jle`> what nodes must be destroyed?  what nodes can be saved/shared?
00:58:52 <jle`> the 4 node points to the 5, so it can be saved
00:58:58 <jle`> the 5 node points to nil, so it can be saved
00:59:16 <jle`> but the 3 node that used to point to nil must now point to the 4 node, so it must be duplicated
00:59:33 <jle`> and now that 2 node that pointed to the 3:[] node now must point to the 3:4:5:[] node, so it must also be duplicated
00:59:53 <jle`> and now that 1 node that used to point to a 2:3:[] node must now point to the new 2:3:4:5:[] node, so that must also be duplicated
01:00:05 * hackagebot egison 3.2.22 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.22 (SatoshiEgi)
01:00:13 <jle`> this is for a strict language like ocaml and variants
01:00:31 <jle`> in haskell usually because of laziness we actually end up saving a lot of these duplications
01:01:37 <laura_h> jle`: is this about memory or more in sense of performance?
01:01:47 <jle`> both, in a way
01:02:43 <jle`> anyways the best way to get down and see what is actually happening/evaluated i think is to just sit down with paper and pencil and do the evaluation-by-substitution by hand and see what exactly needs to be evaluated or duplicated etc.
01:02:51 <Cale> exicer_: Sorry, got distracted there. Yeah, the best way to test parsers is to also write a prettyprinter, and then test that prettyprinting something and then parsing the result gets you back what you started with.
01:03:05 <jle`> remember to save the collapsing of the giant cons thunk to the end
01:03:31 <startling> you should definitely have some unit tests, though.
01:04:04 <jle`> you'll end up at the end with something like foldl (flip (:)) (flip (:) ('o':'l':'l':'e':'h':[])) ""
01:04:36 <jle`> which in the end is 'o':'l':'l':'e':'h':[], which is "olleh", so it only needs to do n conses in the end
01:05:00 <jle`> the allocation of the thunks onto the heap is another story but not too much more complicated i think
01:05:34 <laura_h> jle`: well the allocation is currently out of the scope when I am still stuck with basics ;)
01:06:17 <jle`> :)
01:06:37 <jle`> honestly reasoning about haskell performance is always going to be tricky
01:06:54 <jle`> just by the nature of laziness
01:07:59 <c_wraith> I really don't find reasoning about haskell performance to be hard.
01:10:29 <jle`> the main trickiness i think is that most of the conclusions you make in a vacuum don't normally translate into what actaully happens i think :|  you can always do worst-case analysis and assume eventual full evaluation, and that's not too hard.  but also not always going to be what actaully happens. at least that's what trips it up for me
01:15:55 <czro_> What's the best way to represent a point in time or a time window somewhere in the future?
01:17:40 <c_wraith> czro_: in what context?
01:18:00 <laura_h> jle`: your last statement about evalution: Isn't it about complexity? I mean most of the time you are interested in the limits resp. borders of an evaluation... or not?
01:18:09 <mm_freak_> jle`: any composition of valid FRP functions is valid, and yes, there is 'hold' =)
01:18:11 <czro_> a delivery window. Looking at utctime from Data.Time.
01:18:20 <czro_> c_wraith: a delivery window. Looking at utctime from Data.Time.
01:18:23 <mm_freak_> czro_: UTCTime and NominalDiffTime
01:18:34 <czro_> thanks. Found it.
01:18:40 <jle`> mm_freak_: hold only works for events?
01:18:58 <jle`> i have a continuous stream of (Maybe a) values
01:19:04 <jle`> Wire (Maybe a) a
01:19:04 <laura_h> jle`: take as an example to sort a list. If the list is already sorted...
01:19:23 <c_wraith> laura_h: laziness means that sometimes you get complexity from elsewhere added in to the middle of your evaluation.
01:20:29 <c_wraith> laura_h: for instance, sorting a list that's the result of heavy-duty computation may end up doing all that computation while just figuring out what the first element of the sorted list is.
01:20:32 <mm_freak_> jle`: that sounds impossible to me
01:21:42 <laura_h> c_wraith: But therefore you have some kind of upper-bound, which is estimated - worst case scenario
01:21:58 <laura_h> c_wraith: and best-case is e.g. already sorted
01:22:00 <jle`> mm_freak_: was it for the reasons ezrios mentioned earlier?
01:22:19 <laura_h> c_wraith: so somewhere inbetween you'll have the result ;)
01:22:24 <jle`> because there is no well-defined "maximal time" Just
01:22:45 <c_wraith> laura_h: sometimes it's a global concern, rather than a local one.  If you're profiling, the sort code might be credited with doing lots of work, if it was passed a list that had lots of unevaluated values in it.
01:22:50 <jle`> it's Just for [0,t) and Nothing for [t,inf)
01:23:04 <jle`> so there is no maximal t for which to pick what value to 'hold'
01:23:13 <jle`> ?
01:24:01 <mm_freak_> jle`: without searching my backlog, let me just explain:  try writing Behavior (Maybe a) -> Behavior a
01:24:10 <mm_freak_> when in doubt that's always a good idea
01:25:06 <mm_freak_> jle`: and yes, that's exactly the problem
01:25:16 <jle`> drat
01:26:28 <jle`> my problem is that my little soldiers have an orientation that is based on the target they are facing...but when they don't have a target anymore, i'd want to them o maintain the same orientation they had before
01:27:07 <jle`> my naive solution was to fire off a 'turn' event, that tells them to change their orientation, whenever their direction changes
01:27:29 <jle`> but moving targets mean that this will fire almost continuously
01:27:51 <Ralith> so?
01:28:13 <jle`> ezrios sugested  using a discrete staircaser/stepper to fire off events at steps independent of the system timestep
01:28:30 <jle`> so basically it'll update its orientation every so and so
01:28:33 <mm_freak_> yes, you could do that
01:28:45 <mm_freak_> however, why does the orientation even need updating?
01:29:01 <mm_freak_> why is it not a function of the current target?
01:29:11 <jle`> you might have no target
01:29:32 <jle`> your target might die and there are no other suitable targets
01:29:38 <jle`> so you just sit there
01:29:40 <mm_freak_> and how do you know that you've lost your target?
01:30:29 <jle`> when ther eare no more available targets in the target list
01:30:38 <jle`> i'm a bit lazy right now and it just picks the closest enemy as its target >.>
01:30:43 <jle`> as a continous function
01:31:12 <jle`> er, continous behavior
01:31:17 <jle`> continuous
01:32:59 <Fuco> I'm trying "cabal install category-extras" and it gives me couple dependency errors, like: rejecting: representable-functors-3.2.0.2 (conflict: semigroupoids==4.0,representable-functors => semigroupoids>=3 && <4)
01:33:06 <Fuco> is the package broken or what? :O
01:33:24 <Fuco> or can cabal not resovle dependencies?
01:33:46 <mm_freak_> Fuco: it's obsolete
01:33:51 <Fuco> aha
01:33:54 <mm_freak_> install the individual packages you need
01:33:57 <Fuco> where can I get comonads from
01:33:58 <Fuco> very well
01:34:03 <mm_freak_> comonad =)
01:34:18 <mm_freak_> or comonads
01:34:20 <Fuco> right, thanks
01:34:27 <mm_freak_> and comonads-fd, if you need some extra comonads
01:34:32 <shachaf> I usually get them from the opposite category.
01:35:14 <supki> mm_freak_: comonads-fd is obsolete too; it's merged into comonad
01:35:26 <mm_freak_> ah, ok
01:38:50 <jle`> mm_freak_: i think i'm going to pretend i did the explicit discretizer/turn event and secretly do a hacky performant wire holdJust i = mkPureN $ \x -> case x of (Just x') -> (Right x, holdJust x'); Nothing -> (Right i, holdJust i)
01:39:10 <jle`> but will i be able to live with myself
01:39:24 <jle`> that is the question.
01:39:41 <mm_freak_> jle`: remember that events are cheap in AFRP =)
01:40:01 <chrisg_> if you knew all code atrocities committed by the hand of man you would be willing to live with yourself :-)
01:40:02 <mm_freak_> also remember that in the new abstraction it won't be so easy to cheat ;)
01:40:28 <cinimod> merijn: did my non-functor example make sense?
01:40:45 <mm_freak_> jle`: btw, the first version is online
01:40:51 <jle`> mm_freak_: really? :)
01:40:59 <osa1> I'm loading a file in ghci but still can't use :info on some names used in same file and imported from some other module, why is that?
01:41:48 <mm_freak_> jle`: apart from the basic haddocks it's completely undocumented right now, and a lot of stuff is missing, because i'm still figuring out how to represent it
01:41:52 <mm_freak_> jle`: http://hub.darcs.net/ertes/wires
01:42:01 <jle`> mm_freak_: events are cheap, but the idea of manually discretizing everything just to do something i can hack so simply makes me uneasy in a different way
01:42:07 <jle`> mm_freak_: thanks :)
01:42:10 <mm_freak_> jle`: if you understand netwire, you should be able to understand wires quickly
01:42:18 <jle`> looks like i have my bus reading for tomorrow
01:42:37 <jle`> i should probably install darcs
01:42:45 <mm_freak_> jle`: you should =)
01:43:12 <mm_freak_> if you have a contribution or want to latest updates quickly, registering on hub.darcs.net is also a good idea ;)
01:43:20 <jle`> :)
01:43:23 <jle`> i just want to clone it for now
01:43:31 <jle`> er....'get'?
01:43:32 <mm_freak_> darcs get URL
01:44:38 <jle`> where can i learn about this syntax? http://hub.darcs.net/ertes/wires/browse/Control/Wire/Core.hs#88
01:44:48 <jle`> is this what data kinds is?
01:44:54 <jle`> :|
01:45:21 <mm_freak_> jle`: that's GADT syntax
01:45:42 <mm_freak_> commonly written "data Wire m a b where"
01:45:47 <merijn> cinimod: I think I missed it?
01:45:59 <mm_freak_> but i prefer to write the kind signature:  "data Wire :: (* -> *) -> * -> * -> * where"
01:46:35 <startling> mm_freak_: oh, neat, I didn't know you could do that.
01:46:55 <startling> I've been doing data X (a :: ...) (b :: ...) which is the worst of both worlds.
01:47:38 <merijn> startling: It requires -XKindSignatures, but yes you can
01:47:43 <mm_freak_> startling: well, you can't without KindSignatures, but yeah, you have that one already =)
01:47:58 <merijn> TypeFamilies still require the sucky syntax you mentioned, though :(
01:48:37 <jle`> ah so the m is replaced by (* -> *), a and b by (*)?
01:49:03 <jle`> so nothing really game-changing going on here
01:49:57 <merijn> jle`: Well, it's more typesafe then a and b
01:50:01 <jle`> hm. i thought you mentioned taking out the underlying monad?
01:50:09 <merijn> jle`: Or at least, the type safety is clearer
01:50:09 <jle`> but i guess it's still there
01:50:13 * hackagebot gang-of-threads 0.0.1 - Non-deterministic parallelism with bags  http://hackage.haskell.org/package/gang-of-threads-0.0.1 (bholst)
01:50:20 <jle`> merijn: yeah, that makes sense
01:50:22 <merijn> Not sure it's actually safer unless you use it for DataKinds abuse
01:50:25 <cinimod> merijn: Consider a group as a single object category
01:50:39 <cinimod> merijn: And take Z_2 and Z_3
01:51:29 <cinimod> merijn: The only group homomorphism (functor) is the one which maps both elements of Z_2 to the identity
01:52:09 <mm_freak_> jle`: i brought it back, because OpenGL performance is delicate
01:52:10 <cinimod> merijn: so take f(0) = 0 and f(1) = 1
01:52:38 <mm_freak_> jle`: the monad is to be used only for stuff like environmental events and updating vertex buffers
01:52:45 <cinimod> merijn: then f(1 + 1) = f(0) = 0 but f(1) + f(1) = 1 + 1 = 2
01:53:22 <merijn> cinimod: I need to meditate on this for a day to understand it :)
01:53:29 <cinimod> :)
01:53:43 <mm_freak_> jle`: see also tests/Test.hs for a demo blank screen =P
01:54:04 <mm_freak_> jle`: should eventually become a small particle effect
01:54:17 <jle`> mm_freak_: is this supposed to be integrated all with openGL?
01:54:36 <mm_freak_> jle`: no, but OpenGL is my personal main target…  that's why the test uses OpenGL
01:54:36 <jle`> SDL
01:54:39 <jle`> ah
01:54:44 <mm_freak_> jle`: no, but SDL is my personal main target…  that's why the test uses SDL
01:54:45 <mm_freak_> =)
01:55:08 <mm_freak_> well, small…  i won't be happy until it renders 1M particles at 60 FPS =)
01:55:09 <jle`> i see
01:55:18 <mm_freak_> at least on my card
01:55:29 <jle`> :t (>->)
01:55:31 <lambdabot>     Not in scope: `>->'
01:55:31 <lambdabot>     Perhaps you meant one of these:
01:55:31 <lambdabot>       `>>' (imported from Control.Monad.Writer),
01:55:38 <mm_freak_> it's a pipes operator
01:55:42 <jle`> ah
01:55:50 <jle`> thought it looked familiar
01:55:57 <mm_freak_> pipes will eventually become the main interface between wires and the real world
01:56:17 <merijn> mm_freak_: \o/
01:56:42 <orzo> okay, i'm missing something.  This code works the way i want:    k = maybe Nothing (\(n,k) -> let _ = n :: Int in k) decoded
01:56:44 <mm_freak_> jle`: notice a major change:  builtin inhibition is gone =)
01:56:58 <orzo> replacing it with simpler code fails:      k = fmap (\(n,k) -> let _ = n :: Int in k) decoded
01:56:58 <mm_freak_> intervals are now Maybe behaviors
01:57:07 <orzo> what happened?
01:58:42 <jle`> mm_freak_: oh interesting
01:59:09 <jle`> i always sold built-in inhibition as a major benefit of netwire/associated frp's
01:59:16 <jle`> any reason why you took it out?
01:59:27 <jle`> (sold to my friends)
02:15:11 <Fuco> I have a data A x = A x... can I provide different Show instances for different types of X?
02:15:42 <merijn> Fuco: Yes, but then you can't have a generic show instance
02:15:42 <Fuco> it tells me I have overlapping instances when I try instance Show (A Bool/Integer)  etc
02:15:49 <Fuco> ah
02:15:59 <Fuco> I can live with that, I really only need it for Bool
02:16:04 <Fuco> (and Int)
02:16:45 <startling> Fuco, it may be simpler to use a GADT
02:16:58 <Fuco> what's that
02:17:30 <startling> Fuco, data A :: * -> * where ABool :: Bool -> A Bool; AInt :: Int -> A Int;
02:18:26 <startling> (if you don't intend to use the parameter for more than those types)
02:18:30 <Fuco> ah
02:18:47 <Fuco> this is something new :)
02:18:52 <startling> then you just have an instance Show (A x) where ...
02:20:16 * hackagebot cabal2nix 1.60 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.60 (PeterSimons)
02:24:19 <mm_freak> jle`: because builtin inhibition caused some major trouble, and i realized that i can get inhibition behavior without building it into the wire itself
02:24:30 <jle`> ah
02:24:30 <mm_freak> inhibition should be a behavior feature, not a wire feature
02:24:32 <jle`> but
02:24:33 <jle`> no more magic
02:24:36 <jle`> :/
02:24:49 <mm_freak> the code will look just the same, only the types will be different =)
02:25:04 <suOya_> .
02:25:08 <jle`> i did things like when (> 0) -< health; returnA -< x
02:25:09 <mm_freak> (-->) :: (Monad m) => Wire m a (Maybe b) -> Wire m a b -> Wire m a b
02:25:12 <jle`> will that still work?
02:25:20 <mm_freak> note that this has a well-defined result =)
02:33:06 <mm_freak> jle`: it won't work that way
02:34:22 <mm_freak> this will be the raw version of that code:  ok <- when (> 0) -< health; id; id -< ok *> pure x
02:34:32 <mm_freak> but there will be combinators to make this nicer
02:35:03 <mm_freak> the builtin inhibition has caused so much trouble that i chose to make it explicit
02:36:22 <mm_freak> oops
02:36:43 <mm_freak> ok <- when (> 0) -< health; id -< ok *> pure x
02:37:32 <jle`> ah so just explicit now.
02:37:39 <jle`> i guess it wasn't really that big of a benefit
02:37:44 <hc> :t <-
02:37:44 <jle`> and i did actually have a lot of headaches with it
02:37:45 <lambdabot> parse error on input `<-'
02:37:47 <jle`> at first
02:37:48 <hc> :t -<
02:37:50 <lambdabot> parse error on input `-<'
02:37:54 <hc> :t (-<)
02:37:55 <lambdabot>     Not in scope: `-<'
02:37:55 <lambdabot>     Perhaps you meant one of these:
02:37:56 <lambdabot>       `-' (imported from Prelude), `<' (imported from Data.Ord),
02:37:59 <jle`> hc: -< is syntax
02:38:00 <mm_freak> jle`: it is a benefit over yampa-style switching
02:38:06 <mm_freak> hc: it's arrow notation
02:38:09 <hc> oh
02:38:12 <jle`> mm_freak: looking forward to it :)
02:38:21 <bernalex> how do you copy files? a stackoverflow suggests System.Directory (copyFile), but that doesn't exist according to the docs.
02:38:34 <mm_freak> bernalex: look again =)
02:38:51 <bernalex> mm_freak: lolwtf
02:39:16 <bernalex> my Web browser dun goofd on loading the page maybe? I even tried refreshing it previously, and no copyFile.
02:39:24 <bernalex> oh well. works now, heh.
02:39:54 <mm_freak> see?  all you needed was my positive vibes =)
03:02:47 <bernalex> what's the best way to check if a directory exists?
03:03:04 <bennofs> bernalex: doesDirectoryExist?
03:03:09 <bennofs> @hoogle doesDirectoryExist
03:03:12 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
03:03:15 <bernalex> right, thanks
03:04:43 <osa1> cabal repl does not show informatino about imported names, why is that? I remember doing that with ghci before using sandboxes
03:05:58 <dcoutts_> osa1: you'll have to be more specific
03:06:09 <dcoutts_> about what you mean
03:06:52 <osa1> dcoutts_: when I load a module inside cabal repl,
03:07:14 <osa1> I can't run :info on imported names, I can run :info on only names defined in the same module I loaded to repl.
03:07:29 <osa1> e.g. if my module imports Data.String I can't run :info on functions defined in Data.String
03:07:41 <osa1> same for :t
03:08:01 <bernalex> so how do I use an IO bool? like "if doesDirectory Exists (last fs) then putStrLn "yes!" else putStrLn "no!"
03:08:18 <bernalex> uhm "doesDirectoryExists (last fs)". but.
03:08:36 <dcoutts_> osa1: try with cabal repl --ghc-options=-fbyte-code
03:08:48 <prophile> do thingExists <- doesDirectoryExist (last fs); putStrLn (if thingExists then "yes!" else "no!")
03:08:48 <dcoutts_> or maybe it's -fbytecode
03:09:25 <bernalex> prophile: right. that's sort of what I thought. then my mistake has to be elsewhere in my code.
03:09:31 <dcoutts_> osa1: I don't think it's special to repl, but ghci does have different behaviour when working with pre-compiled modules
03:09:59 <osa1> dcoutts_: --ghc-options=-fbyte-code did not work
03:10:10 <osa1> ah let me try -fbytecode
03:10:22 <osa1> unrecognised flag
03:10:43 <ivanm> dcoutts_: something I've noticed with sandbox behaviour: if a build of an add-source fails, it keeps going on; shouldn't it stop if a source it depends on can't be built?
03:11:16 <osa1> this thing is driving me crazy. I was using this all the time. I can't memorize where every single function is defined ...
03:11:50 <bernalex> prophile: http://lpaste.net/4871527962127630336
03:12:08 <dcoutts_> osa1: perhaps you just need to load the module you're interested in. By default repl loads all the modules
03:12:11 <ivanm> osa1: touch the file, then reload it
03:12:16 <bernalex> so in ^, I have my attempt at doing test <- testFunction; if test then ... else ..., but it fails miserably because I'm probably doing something very wrong.
03:12:26 <bernalex> please excuse all the LOLOMGWTF stuff in there, I will refactor it away afterwards.
03:12:28 <dcoutts_> osa1: repl is just calling ghci and passing it all the modules, you can see how it's calling it
03:12:28 <prophile> bennofs: the alternate case in your if needs a "do"
03:12:40 <bernalex> prophile: aha
03:12:44 <prophile> uh, bernalex*
03:12:51 <dcoutts_> ivanm: yeah that's not great
03:13:18 <bernalex> prophile: then I get cp.hs|44 col 20 error| parse error on input `forM_'
03:13:21 <bergmark> osa1: you can try calling ghci and passing the sandbox's package db etc
03:13:40 <ivanm> dcoutts_: oh, good, it's not just me then :p
03:13:43 <bernalex> prophile: oh right, I needed do\n
03:13:48 <dcoutts_> ivanm: hmm, actually, what? You mean things that depend on the one that failed are built?
03:13:55 <ivanm> yup
03:14:01 <bernalex> prophile: however, the catch still fails. I'll paste the update.
03:14:05 <dcoutts_> ivanm: against what?
03:14:16 <ivanm> dcoutts_: specifically, the actual package is built against the previously installed version of the one that failed
03:14:22 <bernalex> prophile: http://lpaste.net/5108467130160906240
03:14:44 <dcoutts_> ivanm: I've no idea how it'd be doing that, it's not the normal install plan behaviour
03:14:48 <bernalex> prophile: bork is bork ::  String -> IOError -> IO (), and works fine without the if.
03:14:53 <bergmark> osa1: i'm still using cabal-dev... but i do: ghci -package-conf $SANDBOX/packages-*.conf -no-user-package-db $@
03:14:53 <ivanm> huh
03:14:58 <ivanm> so maybe it _is_ just me :p
03:15:02 <prophile> bernalex: the second argument to catch expects an argument
03:15:26 <prophile> bork (last fs) doesn't take an argument
03:15:28 <bernalex> prophile: oh right, the way it is structured now I need to specify f myself
03:15:41 <bernalex>                 forM_ fs $ \f -> when (f /= last fs) $ (copyFile f ((last fs) ++ "/" ++ f) `catch` bork f)
03:15:45 <bernalex> works, thanks a lot prophile !
03:15:48 <osa1> bergmark: what does that do?
03:15:53 <prophile> no worries
03:15:53 <dmj`> @pl guids x = fmap showGuid $ lookup x $ zip [0..] $ liftM4 (,,,) nums nums nums nums
03:15:53 <lambdabot> guids = fmap showGuid . flip lookup (zip [0..] (liftM4 (,,,) nums nums nums nums))
03:16:11 <osa1> I'm wasting %50 of my time looking for functions in hackage.
03:16:25 <dcoutts_> osa1: so the thing to compare is what you're loading with :load adding with :m or importing with import in the two cases. The main difference with repl is that it's calling ghci with all the source files, where as you probably call it initially with only one, but you can change that after using :load
03:16:37 <bergmark> osa1: tell ghci to only use the package db of the sandbox
03:16:48 <dcoutts_> bergmark: that's what cabal repl already does
03:17:42 <dcoutts_> osa1: and then the bytecode vs object code thing, as ivanm said, you can force it to use bytecode by touching a file or cabal clean -s
03:17:59 <dcoutts_> osa1: the -fbytecode may not have done anything because we didn't force a recompile
03:19:16 <osa1> dcoutts_: cabal clean -s worked. thanks.
03:19:16 <lllllllllllll> mm_freak, any chance you have your arrow tutorial somewhere backed up?
03:19:23 <osa1> you just saved my hours.
03:19:56 <dcoutts_> osa1: ok, so this was all about the object code vs bytecode, ghci can only get "inside" a module when using bytecode, otherwise it's like you can only import the external api of a module
03:19:59 <mm_freak> lllllllllllll: it's still there, but not online right now
03:20:15 <mm_freak> lllllllllllll: oh, wait…
03:20:21 <dcoutts_> osa1: or you can find a better & more detailed explanation in the ghc user guide
03:20:32 <mm_freak> lllllllllllll: http://lpaste.net/94914
03:20:39 <mm_freak> pasted it =)
03:20:50 <osa1> got it. thanks.
03:20:52 <mm_freak> lllllllllllll: you may want to run that through pandoc first
03:21:41 <lllllllllllll> mm_freak, thank you very much!
03:21:51 <mm_freak> my pleasure
03:21:54 <zebr> does anyone know if there's an ISWIM (ML/Haskell) language with object-level variables that can be unified, so you can say 's = t' and it does prolog-style unification on the two terms?
03:22:16 <zebr> that might be too half-baked an idea
03:22:20 <mm_freak> zebr: something like mercury?
03:22:31 <lllllllllllll> haasn, ^ -- iirc you wanted it too
03:23:12 <zebr> mm_freak: hmm, i've heard of mercury. it could be what i'm looking for; i'll have a look. :)
03:25:21 * hackagebot hsbencher 1.5.3 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.5.3 (RyanNewton)
03:26:02 <akegalj> helo. i'm confused with conduit library. How to Monad m => Source m a -> m a  ?
03:26:45 <osa1> but now cabal repl takes forever to start :-)
03:26:57 <bennofs> akegalj: you cannot do that. A source might produce mutliple results or none at all, so maybe you're looking for Monad m => Source m a -> m [a]?
03:27:18 <dcoutts_> osa1: that's the tradeoff, you can have some modules compiled and some via bytecode
03:27:46 <akegalj> bennofs: maybe... i really dont understand conduit... how to do  Monad m => Source m a -> m [a]?
03:27:54 <bennofs> akegalj: but that defeats the whole purpose of conduit. Conduit wants to do streaming, so it doesn't have to pull all results into memory
03:28:07 <bennofs> akegalj: why do you need this function, what do you want to do?
03:30:21 * hackagebot posix-realtime 0.0.0.2 - POSIX Realtime functionality  http://hackage.haskell.org/package/posix-realtime-0.0.0.2 (MichalGajda)
03:30:51 <akegalj> bennofs: so i'm using yesod and uploading file. Using handler i want to calculate md5 from that file. Yesod.Core.Handler.fileSource gives me Source m ByteString, so i somehow what to calculate md5 from that bytestring.
03:47:31 <akegalj> bennofs: i found it. sinkLbs from Data.Conduit.Binary does the job
03:47:51 <bennofs> akegalj: how do you calculate the md5 hash?
03:48:59 <haasn> lllllllllllll, mm_freak: thanks!
04:00:28 * hackagebot HGamer3D-Ogre-Binding 0.3.1 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.3.1 (PeterAlthainz)
04:00:30 * hackagebot HGamer3D-Graphics3D 0.3.1 - 3D Graphics Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Graphics3D-0.3.1 (PeterAlthainz)
04:01:13 <akegalj> bennofs: i do Data.Digest.Pure.MD5.md5
04:02:14 <bennofs> ah, ok.
04:25:37 <Rc43> Hello.
04:26:28 <Fuco> hm, is it possible to redefine an instance?????
04:26:43 <Fuco> ggggod I hatttte this keyboard
04:26:53 <supki> Fuco: no
04:27:01 <Rc43> Is there way to beutifully combine lenses and maybe?
04:27:01 <Fuco> my earlier problem would be nicely solved by redefining Show Bool
04:27:11 <supki> instances are global and unique
04:27:34 <haasn> Rc43: what are you trying to achieve?
04:27:35 <Rc43> E.g. modifying of list inside of something (list can be empty and I want to return Nothing in that case).
04:28:09 <Fuco> hm. Can I then create a type Bool'    that would be exactly   the    same except for the Show? other then defining all of it.
04:28:29 <pjdelport> Fuco: newtype
04:28:34 <hpc> just write your own function :: Bool -> String
04:28:43 <pjdelport> or that, yes
04:28:58 <Fuco> hpc: that doesn't work innnn compound      types
04:29:10 <bennofs> > _1 (\l -> if length l == 4 then Nothing else Just l) ([1,2,3,4], 4) -- Rc43: Like this?
04:29:11 <lambdabot>  Nothing
04:29:16 <bennofs> > _1 (\l -> if length l == 4 then Nothing else Just l) ([1,2,3,4,5], 4)
04:29:17 <lambdabot>  Just ([1,2,3,4,5],4)
04:29:39 <Rc43> bennofs, ye, seems like what I want
04:30:21 <hpc> :t _1
04:30:22 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
04:30:38 <Rc43> bennofs, how to combine such lenses? I have list deeply inside object; e.g. (X,(Y,List A),Z).
04:31:17 <bennofs> > (_1._2) (\l -> if length l == 4 then Nothing else Just l) ((5,[1,2,3,4]), 4)
04:31:19 <lambdabot>  Nothing
04:31:33 <bennofs> Rc43: Just like usual, but remember to use parentheses
04:31:46 <bennofs> ((_1._2) is the lens)
04:31:57 <Rc43> bennofs, hmm, ok; seems that I just don't understand lenses, will read more about them
04:32:37 <Rc43> Also there is different stuff like Iso, etc. What is it in two words?
04:33:03 <Rc43> Mapping between different structures?
04:33:07 <bennofs> Rc43: yes
04:33:46 <bennofs> Rc43: If you have a function f :: a -> b and g :: b -> a, and f . g = id and g . f = id, then you can make an Iso' a b
04:34:39 <Rc43> bennofs, ah, ok
04:47:01 <Rc43> :t _1
04:47:02 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
04:47:17 <Rc43> :t _1._2
04:47:18 <lambdabot> (Functor f, Field2 s1 t1 a b, Field1 s t s1 t1, Indexable Int p) => p a (f b) -> s -> f t
04:47:36 <Rc43> :t _1._1
04:47:37 <lambdabot> (Functor f, Field1 s t s1 t1, Field1 s1 t1 a b, Indexable Int p) => p a (f b) -> s -> f t
04:47:56 <Rc43> :i Field1
04:48:57 <bennofs> Rc43: It might help to a) ignore Indexable Int p b) replace p with (->) c) use something that's not as overloaded as _1
04:49:56 <bennofs> @let _fst :: Functor f => (a -> f b) -> (a,c) -> f (b,c); _fst f (a,c) = f a <&> \b -> (b,c)
04:49:57 <lambdabot>  Defined.
04:50:13 <bennofs> @let _snd :: Functor f => (a -> f b) -> (c,a) -> f (c,b); _fst f (c) = f a <&> \b -> (b,c)
04:50:14 <lambdabot>  .L.hs:143:1:
04:50:14 <lambdabot>      The type signature for `_snd' lacks an accompanying binding
04:50:49 <bennofs> @let _snd :: Functor f => (a -> f b) -> (c,a) -> f (c,b); _fst f (c,a) = f a <&> \b -> (c,b)
04:50:50 <lambdabot>  .L.hs:143:1:
04:50:50 <lambdabot>      The type signature for `_snd' lacks an accompanying binding
04:50:56 <bennofs> @let _snd :: Functor f => (a -> f b) -> (c,a) -> f (c,b); _snd f (c,a) = f a <&> \b -> (c,b)
04:50:58 <lambdabot>  Defined.
04:51:02 <bennofs> :t _fst . _snd
04:51:03 <lambdabot>     Not in scope: `_fst'
04:51:04 <lambdabot>     Perhaps you meant `fst' (imported from Data.Tuple)
04:51:13 <bennofs> @let _fst :: Functor f => (a -> f b) -> (a,c) -> f (b,c); _fst f (a,c) = f a <&> \b -> (b,c)
04:51:14 <lambdabot>  Defined.
04:51:15 <bennofs> :t _fst . _snd
04:51:16 <lambdabot> Functor f => (a -> f b) -> ((c1, a), c) -> f ((c1, b), c)
04:54:55 <osa1> best types ever http://hackage.haskell.org/package/groundhog-0.4.1/docs/Database-Groundhog-Generic-PersistBackendHelpers.html
04:56:16 <markuss> hello! im having trouble finding the test-suite 'detailed-1.0' (cabal v1.18.x). any tips to what i can do?
04:56:49 <startling> markuss: I'm not sure it exists.
04:57:52 <bennofs> osa1: You don't need documentation. Just look at the types! :D
04:58:02 <markuss> startling: im reading about in the user-guide here, though: http://www.haskell.org/cabal/users-guide/developing-packages.html#example-package-using-detailed-1.0-interface
04:58:40 <startling> markuss, scroll up a bit
04:59:03 <startling> well, maybe I'm wrong.
04:59:21 <startling> I remember a while ago that doc described some nice things that nobody had bothered to implement.
05:00:18 <markuss> startling: ah, i see what you're talking about. ("it is preferred that new test suites be written for the detailed-1.0 interface")
05:00:26 <bennofs> markuss: I don't think many people use the detailed test suite interface. Most people just use exitcode-stdio with a test framework like tasty
05:01:14 <startling> I wish I could find real documentation about this.
05:01:16 <markuss> bennofs: ok! thanks for that, ill look into tasty then :)
05:01:33 <bennofs> startling: I think documentation for that is mostly "look at the source" :D
05:01:42 <startling> bennofs: I guess so.
05:01:43 <markuss> im having some insane linker errors with detailed-0.9, so would love to get rid of it
05:04:07 <bennofs> markuss: there seems to be no detailed-1.0. detailed-0.9 is the only available other test interface, telling from the source (https://github.com/haskell/cabal/blob/master/Cabal/Distribution/PackageDescription.hs#L490)
05:07:52 <markuss> bennofs: hehe, good to know. going over to exitcode-stdio. thanks!!
05:10:36 <startling> I wonder if someone will ever fix the blatant lies in the docs.
05:10:42 <startling> They've been there for a few years now.
05:11:48 <startling> (Or make it more clear that it's describing a specification etc etc)
05:30:11 <mm_freak> is 'lift a >> lift b' commonly optimized to 'lift (a >> b)'?
05:30:45 <mm_freak> or in my particular case:  lift a >>= lift b = lift (a >>= b)
05:32:28 <merijn> mm_freak: What do you mean by commonly optimised? You mean by GHC?
05:33:44 <mm_freak> yeah
05:33:50 <mm_freak> in this case it's 'pipes'
05:34:24 <merijn> mm_freak: No, that optimisation requires knowing the monad laws/lift laws and AFAIK GHC doesn't currently do law bsed optimisations
05:34:24 <mm_freak> 'lift a >>= lift b' is nice and cozy in the code, but 'lift (a >>= b)' would be ugly and verbose
05:34:44 <mm_freak> well, not GHC itself, but i thought maybe transformers has such a rule
05:35:53 <mm_freak> Tekmo should visit more often =)
05:36:44 <mm_freak> @seen mm_freak
05:37:04 <merijn> mm_freak: lambdabot doesn't have an @seen command
05:37:22 <mm_freak> but it just responded to that particular command in another channel
05:37:39 <mm_freak> <zipper> @seen mm_freak <lambdabot> /\/\M_phReAx
05:37:43 <merijn> And preflex is gone because, iirc, it's host died
05:37:43 <merijn> mm_freak: @seen autocorrect to @leet
05:37:43 <merijn> @leet merijn
05:37:54 <mm_freak> is that a bug or a feature?
05:38:17 <merijn> mm_freak: Feature, it autocorrect using levensteihn distance and leet is only two letters away from seen
05:38:27 <mm_freak> oh
05:38:29 <pjdelport> it's a confusing feature
05:38:38 <pjdelport> if it needs to be explained every time :)
05:38:39 <mm_freak> indeed
05:38:53 <mm_freak> i disabled auto-correct in zsh because it was driving me nuts =)
05:39:08 <mm_freak> @seen blah
05:39:53 <_d0t> hi. Whats the best way to insert a value into haskell code during compilation? I need to print the program version and build number after the start.
05:40:14 <merijn> _d0t: I think you can do that using the CPP and cabal_macros.h
05:40:16 <Axman6> you can use CPP
05:40:21 <mm_freak> _d0t: if you use cabal you can get some of that information by including Paths_yourprogram
05:40:27 <mm_freak> "include" as in "import"
05:40:34 <Axman6> add {-# LANGUAGE CPP #-} at the top of the file
05:40:35 <mm_freak> for everything else, yeah, CPP
05:40:39 <_d0t> ok. Thanks.
05:41:55 <mm_freak> cabal_macros.h doesn't seem to include anything like that…  it just includes the versions of the dependencies
05:42:17 <merijn> mm_freak: I was just guessing on that one >.>
05:42:57 <mm_freak> well, "build number" isn't something that cabal manages anyway…  you have to do that yourself
05:43:04 <bennofs> However, you can make Paths_*.hs include build number when you're using a custom Setup.hs
05:43:15 <utkarsh> if I have multiple versions of a package installed using cabal, can I make a file use a specific version of some package when running from `runghc`, or compiling with `ghc --make`?
05:43:35 <mm_freak> utkarsh: on file level you need the PackageImports extension
05:43:48 <mm_freak> on package level you can do that by hiding the versions you don't want
05:43:59 <merijn> utkarsh: No, but you can if you compile with cabal
05:44:04 <bennofs> utkarsh: If you want to do it for all files compiled by ghc --make, you can use -package "package-name-{version}"
05:44:14 <merijn> utkarsh: Also, the "--make" flag is redundant in modern GHC's
05:44:16 <mm_freak> merijn: it's possible with PackageImports or hiding
05:44:28 <merijn> oh, right
05:44:33 <mm_freak> import "mtl >= 2.0 && < 3" Control.Monad.Reader
05:44:39 * dcoutts does not recommend PackageImports
05:44:43 <bennofs> utkarsh: oh sorry, that was probably confusing. Use -package "package-name-version"
05:44:47 <mm_freak> me neither
05:44:52 <merijn> mm_freak: The fact that it's possible doesn't make it the right solution
05:44:56 <dcoutts> mm_freak: it doesn't support versions like that does it?
05:44:58 <merijn> The right solution is still "use cabal"
05:45:05 <mm_freak> dcoutts: i believe it does
05:45:18 <mm_freak> and yeah, use cabal
05:45:48 <dcoutts> utkarsh: right, the recommended solution is use cabal, or for quick things just use the -package flag, e.g. -package foo or -package foo-1.0
05:46:03 <utkarsh> these are just simple scripts I wanted to run against specific versions, I'm using cabal for bigger projects
05:46:04 <mm_freak> sorry, i was wrong
05:46:23 <mm_freak> PackageImports doesn't support versions
05:48:42 <mada> so, say I want to install 'aura' on arch. I download the .tar.gz from the tarball and attempt to build it, but it has several dependencies of libraries that I actually have installed with cabal. But they have to be installed with pacman in order to be able to install aura
05:49:02 <mada> is there a compromise between both? Not use either and build directly from source?
05:49:40 <mm_freak> @hype Left [()] <|> Right (1 :: Integer)
05:49:42 <lambdabot>     No instance for (Control.Monad.Trans.Error.ErrorList ())
05:49:42 <lambdabot>       arising from a use of `<|>'
05:49:42 <lambdabot>     Possible fix:
05:49:47 <mm_freak> uuhhh
05:49:56 <merijn> mada: The only way to install haskell packages that doesn't fuck up your environment (on most linuxes) is to only install via cabal
05:50:00 <mm_freak> it didn't support the nat-by-list hype =/
05:50:03 <bennofs> oh, what's @hype? autocorrect?
05:50:11 <mm_freak> bennofs: yeah =)
05:50:15 <utkarsh> dcoutts, that seems to work fine, thanks!
05:50:21 <merijn> mada: Or even more precisely: http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
05:50:23 <mm_freak> @hype (<$>)
05:50:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:50:43 <bennofs> Lambdabot should also autocorrect my haskell code when doing > :|
05:50:56 <mada> merijn: I see, that's what I was afraid of
05:50:59 <benj_> @skype (<$>)
05:50:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:51:17 <mm_freak> @ass merijn who enabled this?!
05:51:17 <lambdabot> Consider it noted.
05:51:19 <merijn> mada: The only safe is to never install distro packaged packages after installing with "--global" and never install using "--global" after installing user-local
05:51:28 <merijn> mm_freak: It's alway been on
05:51:41 <mm_freak> just a joke =P
05:51:56 <merijn> mada: The problem is many distro's like to mess around with the global haskell package db and they screw things up
05:52:45 <Rc43> What does double prime before Meetup mean here? https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#wait-a-second--ghci-is-telling-me-the-types-of-these-things-are-absurd-
05:53:07 <Rc43> In "makeLenses ''Meetup".
05:53:18 <merijn> Rc43: TemplateHaskell quoting
05:53:28 <merijn> Forgot the exact meaning, but google TH syntax
05:53:37 <merijn> makeLenses is a TH function
05:54:13 <Rc43> merijn, ok, thanks
05:59:02 <Rc43> merijn, should that example work from-the-box? I used TH pragma, but ghc says that makeLenses not in scope.
05:59:46 <mada> merijn: should cabal be installed from source?
06:00:38 <merijn> Rc43: makeLenses should be import from the lens library and you need to have -XTemplateHaskell enabled
06:01:05 <merijn> mada: I always install the binary distribution on OSX, so I've never had to bother with that
06:01:20 <Rc43> merijn, ye, it works; I forgot to import lens
06:02:18 <Rc43> Why lenses are restricted to Functor type of modification?
06:02:34 <mada> merijn: the thing is, I have cabal, xmonad and dependencies installed from arch's package manager, so I'm thinking it's best to only leave ghc and reinstall everything using cabal
06:02:38 <Rc43> (I mean (x -> Functor x).) Why not arbitrary (x -> y)?
06:03:08 <bennofs> Rc43: you can "recover" that arbitrary modification by using the Identity functor
06:03:52 <Rc43> bennofs, ow, clear :)
06:04:01 <bennofs> Rc43: So, lenses are not "restricted", but rather extended to also support functorial modifications
06:04:45 <merijn> Rc43: "newtype Identity a = Identity { runIdentity :: a }" <- this is a functor, so you can trivially wrap + unwrap with Identity to get "x -> y" which is what happens in some operators
06:05:13 <merijn> i.e. just use the lens with "Identity . myFunc" and "runIdentity" the result :)
06:07:17 <Rc43> _1 show (1,1)
06:07:24 <Rc43> > _1 show (1,1)
06:07:27 <lambdabot>  [('1',1)]
06:07:36 <Rc43> Why does it work?
06:07:42 <Rc43> Where is Functor here?
06:07:50 <merijn> :t _1
06:07:52 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
06:08:01 <sfsdas> Is there a library on Hackage that provides a Parsec combinator for parsing Haskell Doubles?  There's 'parsec3-numbers', but I have difficulties understanding its API.
06:08:06 <bennofs> Rc43: remember: show :: Show a -> [Char]
06:08:10 <merijn> Rc43: list functor
06:08:19 <sfsdas> In particular, why does 'floating2' require a Bool argument?
06:09:08 <Rc43> bennofs, merijn, haven't it to be Functor String?
06:09:18 <bennofs> Rc43: type String = [Char]
06:09:39 <bennofs> Rc43: so String everywhere where you can write String, you could have also written [Char]
06:09:40 <Rc43> bennofs, merijn, ah, I did mistake
06:09:52 <Rc43> > _1 show ("123",1)
06:09:53 <lambdabot>  [('"',1),('1',1),('2',1),('3',1),('"',1)]
06:09:56 <merijn> Rc43: Note that "_1 show (1,1)" returns [(Char, Int)]
06:10:08 <merijn> :t (.~)
06:10:08 <lambdabot> ASetter s t a b -> b -> s -> t
06:10:14 <Rc43> merijn, ye, it's clear; I wanted to test other
06:14:22 <sfsdas> Ah, got it: parse (floating2 False) "" "1." => Right 1.0; parse (floating2 True) ":(" "1." => error: expecting fraction
06:14:25 * khyperia is completely confused what "_1 show" does...
06:14:39 <khyperia> I would have guessed "over _1 show"
06:15:51 <supki> > traverse show (1, 2)
06:15:52 <lambdabot>  [(1,'2')]
06:16:03 <supki> _1 is just a particular kind of traversal
06:16:21 <sfsdas> Argh, it doesn't work for negative numbers...
06:18:22 <khyperia> I haven't learned traversals yet, supki, that'd probably be why I don't understand them :P
06:19:02 <supki> oh, right, you certainly want to start with Foldable/Traversable before diving into lens
06:21:01 <Rc43> Is `head' a lens? Or is there analogue?
06:21:02 <Rc43> > set _1 "223" ("123",2)
06:21:05 <lambdabot>  ("223",2)
06:21:10 <Rc43> > set (_1.head) '2' ("123",2)
06:21:11 <lambdabot>  Couldn't match type `[p0 [GHC.Types.Char] (Control.Lens.Internal.Setter.Mutator
06:21:12 <lambdabot>                                               b0)]'
06:21:12 <lambdabot>                with `a0 -> Control.Lens.Internal.Setter.Mutator GHC.Types.Char'
06:21:12 <lambdabot>  Expected type: (a0
06:21:12 <lambdabot>                  -> Control.Lens.Internal.Setter.Mutator GHC.Types.Char)
06:21:23 <Rc43> > set (_1._head) '2' ("123",2)
06:21:25 <edwardk> rc43: there is _head and ix 0, which both work
06:21:26 <lambdabot>  ("223",2)
06:21:40 <Rc43> > set (_1.(ix 3)) '2' ("123",2)
06:21:42 <lambdabot>  ("123",2)
06:21:45 <Rc43> edwardk, nice
06:21:50 <edwardk> Rc43: they are traversals though, not lenses
06:22:21 <Rc43> Looks pretty clever thing due (.) is usual functions composition.
06:24:33 <khyperia> Looks like a Foldable is pretty simple, heh. Traversable looks a bit more complicated...
06:25:02 <khyperia> is "traverse" like a multi-element (>>=)?
06:25:37 <khyperia> no, fmap
06:25:55 <merijn> khyperia: traverse is polymorphic mapM
06:25:58 <merijn> :t mapM
06:26:00 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:26:04 <khyperia> ahh
06:26:04 <merijn> :t traverse
06:26:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:26:21 <merijn> :t Data.Traversable.mapM
06:26:22 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:26:49 * khyperia waits for the AMP to go through...
06:27:00 <merijn> khyperia: I was about to say that, yeah :)
06:27:14 <carlosgaldino> how can I make this work? `all (elem ['A'..'Z']) "MY UPPERCASE PHRASE"`
06:27:20 <merijn> :t all
06:27:21 <lambdabot> (a -> Bool) -> [a] -> Bool
06:27:31 <merijn> carlosgaldino: flip elem
06:27:47 <Iceland_jack> (`elem` ['A'..'Z']) or (flip elem ['A'..'Z'])
06:27:49 <merijn> :t all (flip elem ['A'..'Z']) "MY UPPERCASE PHRASE"
06:27:50 <lambdabot> Bool
06:28:09 <merijn> carlosgaldino: Although, having said that (and Iceland_jack's working version) NEVER WRITE THIS
06:28:15 <merijn> carlosgaldino: EVER
06:28:15 <carlosgaldino> merijn:thanks
06:28:31 <merijn> > all isUpper "MY UPPERCASE PHRASE"
06:28:33 <lambdabot>  False
06:28:42 <Iceland_jack> > all (`elem` ['A'..'Z']) "NEVER WRITE THIS" -- ;)
06:28:43 <lambdabot>  False
06:28:43 <merijn> oh, space isn't uppercase, I guess :)
06:28:56 <merijn> Then again, the same holds for the elem one
06:28:59 <Iceland_jack> > all (`elem` ['A'..'Z'] ++ " ") "NEVER WRITE THIS" -- ;)
06:29:00 <lambdabot>  True
06:29:20 <merijn> carlosgaldino: "elem ['A'..'Z']" only considers uppercase ASCII
06:29:31 <merijn> carlosgaldino: Your code will fail horribly for non ascci
06:29:59 <merijn> > elem 'Λ' ['A'..'Z']
06:30:01 <lambdabot>  False
06:30:01 <Iceland_jack> For completeness sake there is also
06:30:01 <Iceland_jack> :t isAsciiUpper
06:30:02 <lambdabot> Char -> Bool
06:30:09 <merijn> > isUpper 'Λ'
06:30:10 <lambdabot>  True
06:30:11 <Iceland_jack> if that's really what you want
06:30:35 <merijn> carlosgaldino: isUpper is a proper unicode aware function for determining case
06:30:51 <carlosgaldino> but it doesn't not consider spaces right?
06:31:05 <merijn> carlosgaldino: No, but neither does "elem ['A'..'Z']" :P
06:31:15 <carlosgaldino> haha, yeah
06:31:18 <benj_> > all isUpper $ concat $ words "MY UPPERCASE PHRASE"
06:31:19 <lambdabot>  True
06:31:22 <carlosgaldino> how could I check that?
06:31:27 <carlosgaldino> ah
06:31:28 <carlosgaldino> right
06:31:37 <merijn> Or, better
06:31:39 <Iceland_jack> :t all (\x -> isUpper x || isSpace)
06:31:40 <lambdabot>     Couldn't match expected type `Bool' with actual type `Char -> Bool'
06:31:40 <lambdabot>     In the second argument of `(||)', namely `isSpace'
06:31:40 <lambdabot>     In the expression: isUpper x || isSpace
06:31:42 <Iceland_jack> :t all (\x -> isUpper x || isSpace x)
06:31:43 <lambdabot> [Char] -> Bool
06:32:01 <Iceland_jack> > all (\x -> isUpper x || isSpace x) "THIS SHOULD WORK"
06:32:02 <lambdabot>  True
06:32:12 <merijn> That doesn't consider punctuation though
06:32:19 <merijn> > all (\x -> isUpper x || isSpace x) "THIS SHOULD WORK!"
06:32:21 <lambdabot>  False
06:32:26 <khyperia> Oh, speaking of non-ascii, my co-worker ran into issues in C# when the culture specified that toUpper 'i' == 'İ' and vice versa. Huge issues with `map toUpper string == "CONSTANT WITH I"`. Lesson: Don't disregard unicode in production code.
06:32:46 <Iceland_jack> The specification didn't mention punctuation :)
06:33:00 <merijn> > all (\c -> if isLetter c then isUpper c else True) "THIS SHOULD WORK!"
06:33:01 <lambdabot>  True
06:33:02 <Iceland_jack> with my solution at least it's easy enough to add more cases (if you didn't know how to before)
06:33:10 <Rc43> > view _Left (Left ())
06:33:11 <syllogismos> instance Applicative (State s) where
06:33:11 <syllogismos> --(<*>) :: (State s (a -> b)) -> (State s a) -> (State s b)
06:33:11 <syllogismos>   (<*>) (State g) (State h) = State $ \s -> let (f, _) = g s
06:33:11 <syllogismos>                                                 (a, _) = h s
06:33:11 <syllogismos>                                             in (f a, s)
06:33:12 <lambdabot>  ()
06:33:19 <Rc43> > view _Left (Right ())
06:33:20 <lambdabot>  ()
06:33:21 <syllogismos> is this the right?
06:33:25 <merijn> khyperia: Use Text with locale aware uppercase function
06:33:32 <Rc43> > view _Left (Right ())
06:33:33 <Iceland_jack> syllogismos: Don't paste code here
06:33:34 <lambdabot>  ()
06:33:36 <syllogismos> applicative instance of the state monad
06:33:42 <Iceland_jack> @where lpaste
06:33:42 <lambdabot> http://lpaste.net/new/haskell
06:33:43 <syllogismos> its just 3 lines..
06:33:44 <tdammers> khyperia: good old Turkish, ruining it for naive programmers since... well, whenever it was they adopted the latin alphabet
06:33:45 <syllogismos> okay
06:33:51 <Iceland_jack> 5 lines
06:34:02 <khyperia> heh, tdammers, yep. Forgot what language it was :)
06:34:17 <Rc43> Eeem, why so? (`view _Left (Right ())' give ())
06:34:18 <merijn> khyperia: text-icu has "toUpper :: LocaleName -> Text -> Text"
06:34:26 <khyperia> neato, merijn
06:34:30 <Rc43> On my machine it is static erro, btw.
06:34:47 <bennofs> Rc43: ghci-style aggresive defaulting
06:35:00 <merijn> khyperia: Normal text already has neat "toUpper" i.e. it expands lowercase ffi ligature (one character) to three uppercase characters
06:35:09 <christiaanb> hi, what are heap objects between  '<'  and '>' when profiling with "+RTS -hd"? Class dictionaries? if so…. how do I get rid of them, that is, solve the space leak?
06:35:10 <bennofs> :t view _Left (Right 3)
06:35:11 <lambdabot> Monoid a => a
06:35:11 <Rc43> bennofs, here on in my ghci?
06:35:24 <bennofs> Rc43: it defaults a to (), which has a monoid instance
06:35:28 <merijn> Rc43: ghci and lambdabot both have extended defaulting
06:35:39 <khyperia> which that's pretty nice, in C# it just silently treats "toUpper" as a culture-specific conversion (I think), grabbing the culture behind the scenes.
06:35:58 <Rc43> merijn, in my ghci this line gives static error; can it be cause different versions?
06:36:02 <khyperia> silly side effects, who needs 'em
06:36:03 <Rc43> Is lambdabot 7.8?
06:36:07 <Rc43> :version
06:36:19 <merijn> Rc43: "import Data.Monoid"
06:36:35 <merijn> Rc43: Else you won't have the monoid instance of () in scope
06:36:47 <Rc43> merijn, still error
06:36:54 <Rc43> merijn, for Left () it is ok.
06:36:56 <bennofs> merijn: can't be. Lens uses the monoid constraint, so it has to import Data.Monoid
06:37:04 <merijn> ah
06:37:13 <merijn> dunno then
06:37:45 <Rc43> I am wondring also how ghci can give static errors in runtime.
06:38:00 <Rc43> For Left () it is ok and for Right () there is error about types.
06:38:37 <khyperia> I think it invokes ghc behind the scenes, doing a standard compile reporting any errors
06:38:58 <predator217> > preview _Left (Right 3)
06:39:00 <lambdabot>  Nothing
06:39:03 <khyperia> well, maybe not "standard", but going through all the steps of ghc
06:40:41 * hackagebot handa-gdata 0.6.9.1 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.6.9.1 (RyanNewton)
06:44:54 <Fuco> is there something like mapM, but respecting a functor structure? e.g. fmapM
06:45:28 <Fuco> hmm, I guess I need Traversable
06:45:44 * hackagebot hsbencher 1.5.3.1 - Flexible benchmark runner for Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.5.3.1 (RyanNewton)
06:45:49 <merijn> Fuco: Traversable, OR if you don't care about the result, Foldable
06:45:55 <christiaanb> maybe somebody here knows: What are heap objects between  '<'  and '>' when profiling with "+RTS -hd"? Class dictionaries?
06:46:02 <merijn> Fuco: (i.e. Foldable is like mapM_)
06:46:58 <Fuco> yes, Foldable will be better
06:47:01 <Fuco> thanks
06:56:48 <Rc43> Prisms and Lens are particle cases of Traversals. But the way they are specializations of Trav~ is pretty non-obvious. Firstly (when I didn't start read about Trav~ yet) I thought that Traversal will be just "composition" of Prism and Lens. But in the tutorial it is new generalized type.
06:57:04 <prophile> @hoogle StateArrow s a b c -> s -> Automaton a b c
06:57:04 <lambdabot> Warning: Unknown type StateArrow
06:57:04 <lambdabot> No results found
06:57:17 <Rc43> I though they are just induction principles which reconstruct type back or something.
07:05:19 <supki> Rc43: lenses are traversals that have precisely 1 target, prisms are traversals that have 0 or 1 targets and you can turn them around; the composition of a lens and a prism is 0-1 target traversal
07:06:16 <Rc43> supki, ye, but why it isn't enough to use 0-1 target traversal for traversing lists?
07:06:58 <Rc43> supki, or we need n-target traversal for handling dynamic length of list?
07:07:27 <bennofs> Rc43: how do you traverse a list with 2 elements with a 0 or 1 target traversal?
07:07:47 <supki> you can have 0-1 target traversal for any particular element of the list, but not for the whole list
07:08:46 <Rc43> bennofs, supki, ah, it's clear now
07:10:45 <utkarsh> I'm unable to get this trifecta/parsers parser to compile: https://gist.github.com/46379dbbd9471d4425db
07:10:46 * hackagebot yesod-paginator 0.9.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.9.1 (PatrickBrisbin)
07:10:53 <utkarsh> Getting "No instance for (Text.Parser.Combinators.Parsing Parser) ..."; full message is in the gist above.
07:10:56 <utkarsh> any ideas?
07:11:26 <edwardk> utkarsh: you probably have two versions of parsers installed or two versions of trifecta if you look through your ghc-pkg list
07:11:52 <edwardk> utkarsh: what happened is trifecta built aganst one parsers but the one you are getting in ghci or whatever is the other.
07:12:23 <edwardk> utkarsh: at least 9 times out of 10 that kind of error stems from that sort of thing
07:13:46 <utkarsh> edwardk, I do have many versions installed. let me see.
07:15:51 <Guest3466> hi!
07:16:03 <Guest3466> someone can help me with a doubt?
07:21:52 <Guest3466> can someone help me? http://lpaste.net/100124
07:23:14 <_d0t> Guest3466: so whats the problem?
07:23:41 <_d0t> Guest3466: you've got a syntax error in the second line
07:24:08 <Guest3466> wich?
07:24:21 <Guest3466> (sorry by my english...)
07:24:38 <Guest3466> this is the result of call minimo' [1..3]
07:24:48 <Guest3466> in ghci
07:24:49 <quicksilver> it's not a syntax error
07:24:56 <`^_^v> what are the type of [1..3]?
07:24:57 * heath waves gm
07:25:00 <`^_^v> is*
07:25:01 <predator217> Guest3466: try minimo' [1::Int..3]
07:25:11 <quicksilver> you need to remove the type signature
07:25:13 <_d0t> hmm
07:25:19 <heath> > :t [1..3] --curious if this works
07:25:21 <lambdabot>  <hint>:1:1: parse error on input `:'
07:25:23 <predator217> er [(1::Int)..3]
07:25:23 <quicksilver> in line 2
07:25:28 <Iceland_jack> :t [1..3] -- this works
07:25:28 <heath> [1..3] :: (Enum t, Num t) => [t]
07:25:29 <lambdabot> (Enum t, Num t) => [t]
07:25:42 <heath> cool
07:26:37 <Guest3466> wow!! minimo' [(1::Int)..3] works!!
07:26:40 <Guest3466> why??
07:26:52 <`^_^v> what is the type of 1?
07:27:14 <merijn> `^_^v: Num a => a
07:27:18 <Guest3466> 1 :: (Num a) => a
07:27:20 <Iceland_jack> `^_^v: You can ask lambdabot or ghci
07:27:23 <Iceland_jack> :t 1 -- `^_^v
07:27:25 <lambdabot> Num a => a
07:27:27 <`^_^v> jesus
07:27:30 <merijn> `^_^v: So by extension, [1..3] :: Num a => [a]
07:27:34 <`^_^v> im trying to help Gue
07:27:34 <`^_^v> im trying to help guest3466
07:27:38 <`^_^v> i know what the type of 1 is
07:28:08 <Iceland_jack> `^_^v: Honest mistake, no harm done
07:28:50 <Guest3466> but, Num is not a include in Ord or Bounded?
07:29:17 <Guest3466> my type declaration is
07:29:18 <Guest3466> minimo' :: (Bounded a, Ord a) => [a] -> a
07:29:37 <Guest3466> i'm think that this support a (Num a)
07:29:46 <geekosaur> Num does not imply Ord, no. (you can't define Ord according to its current meaning for Complex Double)
07:30:15 <Guest3466> oooh!! thanks, i'm not know that
07:30:15 <geekosaur> Num does not imply Bounded (what are the bounds on Integer?)
07:30:25 <Guest3466> i'm newby in haskell
07:31:16 <Guest3466> i'm very dummy... it's obvious that Num not imply Bounded... sorry
07:31:22 <christiaanb> geekosaur: Integer is arbitrary precision, so there are not bounds :)
07:31:24 <Guest3466> thanks by the help
07:31:24 <`^_^v> Guest3466, minimo' does not perform any operation that requires a Num. but, haskell doesn't know how to instantiate [1..3] because like we know, it's not a specific type
07:31:25 <geekosaur> this isn't so much Haskell as math; you cannot define a consistent ordering between complex numbers
07:31:32 <geekosaur> christiaanb, yes, that was my point
07:31:42 <`^_^v> instantiate a type for
07:31:53 <geekosaur> they asked why Num did not imply Ord or Bounded, I pointed out specific cases to think about
07:32:14 <`^_^v> that is why it is ambiguous, because it could be Int, Integer, etc
07:32:19 <Guest3466> i know that i don't define consistent ordering between complex numbers
07:32:30 <Guest3466> i don't now that complex numbers exist in haskell
07:32:45 <quicksilver> furthermore, haskell has a way to resolve ambiguity
07:32:49 <quicksilver> it tries a default type
07:32:51 <quicksilver> but that didn't work here.
07:33:04 <quicksilver> so it gave up and complained about the ambiguity.
07:33:12 <geekosaur> also I have not described the situation with complex numbers precisely, you might want to study them a bit to see what the truth is.
07:33:20 <prophile> Guest3466: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Complex.html
07:33:34 <mm_freak> Guest3466: you get complex numbers (Data.Complex), and extra packages give you even quaternions, which is handy for 3D rotations
07:34:00 <Guest3466> thanks
07:34:26 <utkarsh> edwardk, worked! thanks :)
07:37:34 <japesinator> so, I'm working on writing a scheme in haskell from the wikibook
07:37:49 <japesinator> and I'm trying to define numeric binary operators
07:38:32 <japesinator> but the problem is I'm trying to have things like addition defined across not just integers, but also complex numbers, ratios, and floats
07:38:49 <japesinator> is there a good way to make this work in haskell's type system?
07:39:03 <japesinator> right now I'm using the example code from https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1#Presentation
07:39:27 <japesinator> the problem is I'm not sure how to define unpackNum over anything except integers
07:39:29 <`^_^v> yes, by using a type class like Num
07:41:00 <`^_^v> numericBinop, instead of taking a (Integer -> Integer -> Integer), will take a function Num a => (a -> a -> a)
07:41:42 <`^_^v> i never read the tutorial but that's the general idea of what you want to do
07:42:20 <Iceland_jack> japesinator: You can also define a type family if you want to be able to add (say) Ints and Integers
07:43:35 <bergey> What do folks like for writing text (ascii, not xml) file formats?  I'm finding Text.PrettyPrint excessively slow.
07:43:36 <japesinator> `^_^v:  my code now looks like this:
07:43:58 <japesinator> unpackNum:: (Num a) => LispVal -> a
07:44:32 <japesinator> oh, OK
07:45:16 <eternauta> there is any way of implement the sieve of eratostenes in functional style? any link?
07:45:34 <`^_^v> https://web.archive.org/web/20130514030554/http://www.cs.tufts.edu/~nr/comp150fp/archive/melissa-oneill/Sieve-JFP.pdf
07:45:48 * hackagebot yesod-markdown 0.8.3 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.3 (PatrickBrisbin)
07:45:51 <eternauta> thanks
07:46:09 <japesinator> Now it says it can't match expected type Complex Double with actual type Ratio Integer
07:46:29 <japesinator> or wait no,
07:46:46 <Fuco> hmmm... I have 'class Shiftable m where center :: m a -> a'. Now, when I do 'instance Shiftable (G U) where ...' , data U x, data G m x, the 'm' in Shiftable is 'G U'. Is there some way to make it just 'G'? (i.e. the 'a' in `center' should be 'U x')
07:47:07 <japesinator> "Can't match type 'Complex Double' with type 'Ratio Integer'"
07:47:21 <japesinator> Expected type: a
07:47:27 <japesinator> Actual type: Rational
07:48:07 <Peaker> Hey, I'm designing a multi-threaded build system, and wondering if there's a nice way (design-wise) to have a failure propagate from worker threads so it can fail the entire build process
07:48:17 <enthropy> japesinator: I would just go for the Number constructor being Integer (or Rational or whatever they recommend)
07:48:47 <Peaker> I could make all blocking operations (e.g: waiting for some worker thread to complete) also wait on some possible globally visible error channel, but that sounds ugly
07:49:22 <Peaker> hmm.. maybe keep a list of all ThreadId's I spawned, and kill them all...
07:49:35 <merijn> Peaker: Doesn't async let you spawn processtrees and call them recursively?
07:49:48 <merijn> s/call/kill
07:50:01 <merijn> i.e. throwing a recursion will propagate and kill the entire tree
07:50:27 <Peaker> merijn, perhaps.. so if my Unix socket server thread which spawns accept'd threads used "async" instead of "forkIO", I could just kill the server
07:50:50 <merijn> Peaker: Couldn't you just kill the server anyway?
07:51:01 <Peaker> then the connection handling threads would still persist
07:51:02 <merijn> oh, wait server thread
07:51:16 <merijn> For a second I thought you were talking about an entire process
07:52:05 <Peaker> I meant "process" there not in the unix term
07:52:20 <Peaker> but as the thing that progresses via threads to form the building
07:53:01 <Peaker> btw: I already have a proof-of-concept running, where a bunch of (currently hard-coded) build commands run in a random order, and when they try to access files that other build cmds generate, I block them, and get the other build cmds to run first
07:53:35 <Peaker> merijn, I did go for LD_PRELOAD after fuse was less than optimal -- but discovered that LD_PRELOAD kinda sucks for this.. will eventually switch back to fuse
07:53:43 <japesinator> so now I'm trying to make a lisp type that takes any numerical value
07:53:47 <Peaker> (but the POC works with LD_PRELOAD)
07:53:52 <japesinator> so I have:
07:54:11 <japesinator> data LispVal = Atom ... | Number (Num a) | ...
07:54:24 <merijn> Peaker: Anyway, async is probably easiest
07:54:37 <eternauta> <`^_^v> wow! it's a great paper!! (https://web.archive.org/web/20130514030554/http://www.cs.tufts.edu/~nr/comp150fp/archive/melissa-oneill/Sieve-JFP.pdf) thanks!!
07:54:37 <Peaker> yeah, "async" seems like a nice drop-in replacement for almost any "forkIO"
07:54:40 <merijn> Peaker: That or wrap forkIO with a custom one that keeps state in a TVar
07:54:40 <japesinator> but I get "Not in scope: type variable a"
07:54:47 <jophish> I'd like to assert that a function can only be passed a particular constructor for a datatype. Ideally this would be solved at the type level, but in the absence of that possibility, is it better to use an irrefutable pattern, or 'error "..."' on any other patterns?
07:54:56 <Peaker> merijn, Am already using "async" for some purposes
07:55:15 <jophish> irrefutable patterns seem nice for this job, but I'm not sure that's their intended purpose
07:55:47 <Peaker> jophish, I'd use "error" because I prefer custom tailored error messages
07:55:50 * hackagebot http-conduit 2.0.0.7 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.7 (MichaelSnoyman)
07:55:54 <Peaker> jophish, but usually this kind of thing is possible with GADTs
07:56:05 <Peaker> (at the type-level)
07:56:11 <jophish> ah, I'd not thought of that
07:56:36 <Peaker> jophish, GADTs let you assert at the type-level almost arbitrary constraints on what data constructors are possible
07:56:50 <jophish> I'll implement it with ~ to get things working, and then take a look at GADTs
07:56:59 <geekosaur> japesinator, you don't have a declared in there and you're trying to use Num as a type
07:57:08 <jophish> Thanks, Peaker
07:57:23 <japesinator> geekosaur: how can I do that?
07:57:43 <geekosaur> data LispVal a = ...
07:57:53 <geekosaur> and you cannot, with a normal ADT, include a Num constraint
07:58:34 <geekosaur> (you can with a GADT but I have not scanned back to see what exactly you're trying to do. and I can't really at present. but what you showed there makes no Haskell sense)
07:59:14 <Peaker> japesinator, you can use an existential type constrained with "Num" for the "Number" case
08:01:03 <r444> I'm trying to implement infinite prime numbers sequence via sieve of erathosthenes. https://gist.github.com/dredozubov/9094929 currently it's getting stuck in infinite loop.
08:01:15 <r444> i guess something is strict-evaluating
08:01:25 <r444> can anyone give a look?
08:01:39 <monochrom> I don't think the sieve is meant for infinite sequence to begin with
08:02:27 <r444> monochrom: why not?
08:02:39 <Peaker> Is there a way to catch only Asynchronous exceptions?
08:02:47 <jophish> What is a nice shorthand for map . map?
08:03:02 <Peaker> I want to have an Async action that executes a process, and if asynchronously killed/stopped/whatever, kills the process it executed to avoid leaking it
08:03:13 <eternauta> this is a algorithm for sieve https://web.archive.org/web/20130514030554/http://www.cs.tufts.edu/~nr/comp150fp/archive/melissa-oneill/Sieve-JFP.pdf
08:03:43 <monochrom> the sieve says: throw away all multiples of the first prime in your interval. then throw away all multiples of the second prime in your interval.
08:03:54 <SwashBuckla> what is "ExitFailure 247" in a cabal install?
08:04:06 <monochrom> well if your interval is infinite, you will not finish throwing away multiples of the first prime.
08:04:49 <jfischoff> Peaker: the short answer is no, if you mean exceptions thrown with throwTo
08:05:25 <prophile> is there any syntax for doing existential types in a simple type signature?
08:05:28 <SwashBuckla> I am trying to cabal install 'cabal-install --ghc-options=-rtsopts' (I am using rtsopts because this machine only has 1GB and compiling pandoc uses up more than 1GB of memory without rtsopts)
08:05:54 <prophile> in this case for something like Automaton a b c -> exists s. (StateArrow s a b c, s)
08:06:23 <r444> eternauta: thanks, i'll give it a look. I'm really interested in finding error in my solution attempt though, i think it'll be pretty educational.
08:06:25 <Peaker> jfischoff, well, I could just try to terminate the process anyway, and if it's already terminated, no harm done
08:06:25 <jfischoff> prophile: no lightweight syntax, you need to wrap it in a type
08:06:33 <Peaker> jfischoff, `onException` terminateProcess ...
08:06:37 <prophile> jfischoff: okay, thanks
08:07:07 <r444> monochrom: you can construct filter function and filter it lazily
08:07:20 <dcoutts> SwashBuckla: -rtsopts on it's own doesn't do much, it just means the program you make will support the +RTS runtime flags
08:07:21 <jfischoff> Peaker: sure I hadn't thought about the larger problem your solving ;)
08:08:08 <monochrom> 247 means you should post the complete output, not just 247.
08:08:21 <monochrom> generally, all cabal-install exit codes mean that.
08:08:30 <SwashBuckla> dcoutts: ok. Is it enough to pass -rtsopts to the new cabal-install, though? And then when that new cabal-install is install, I can use the enabled +RTS flags in building pandoc
08:09:22 <dcoutts> SwashBuckla: yes, if you're trying to pass +RTS flags to cabal itself
08:09:32 <SwashBuckla> monochrom: ok I will paste the whole output
08:09:59 <Peaker> hmm.. so if an async action is killed, does it kill the async actions it has spawned?
08:10:10 <jfischoff> yes
08:10:12 <dcoutts> SwashBuckla: and if you always want to do that, then bake them in when you build cabal, e.g. cabal install cabal-install --ghc-options=-with-rtsopts=-M500m
08:10:28 <jfischoff> its a tree of threads
08:10:30 <SwashBuckla> dcoutts: oh, I see
08:10:33 <Peaker> jfischoff, that would be weird in the general case, as an async action could pass handles to its children to others
08:10:37 <SwashBuckla> monochrom: what pastebin do you suggest?
08:10:43 <monochrom> lpaste.net
08:10:50 * hackagebot amqp 0.8.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.8.0 (HolgerReinhardt)
08:10:57 * SwashBuckla reads topic...
08:11:01 <Peaker> jfischoff, oh, found it in the doc, to form a "tree of threads", need to use "withAsync"
08:11:22 <jfischoff> ah
08:11:24 <jfischoff> my bad
08:11:30 <SwashBuckla> monochrom: http://lpaste.net/100127
08:12:29 <monochrom> perhaps it is out of memory as you was worrying.
08:12:30 <BMeph_> jophish: Isn't "map . map" short enough for you? ;)
08:12:57 <jophish> BMeph_: I have the code. mapM_ (mapM_ f) xss
08:12:58 <monochrom> cabal +RTS -M500m -RTS install xxx
08:13:06 <SwashBuckla> so I can't build cabal-install enabling less memory because I don't have... enough memory D:
08:13:09 <jophish> I'm wondering if it's possible to do something clever
08:14:05 <BMeph> jophish: To paraphrase, "Welcome to Haskell, where it's Always Possible to Do Something Clever!" ;)
08:14:23 <SwashBuckla> monochrom: cabal +RTS -M500m -RTS install gives output "cabal: Most RTS options are disabled. Link with -rtsopts to enable them."
08:14:35 <monochrom> I see
08:15:11 <SwashBuckla> I will need to cabal install cabal-install with --ghc-options=rtsopts, but that is what is giving me the ExitFailure 247
08:15:11 <monochrom> but we need not use cabal-install, do we?
08:15:21 <SwashBuckla> I don't know
08:15:51 * hackagebot mono-traversable 0.3.0.2 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.3.0.2 (MichaelSnoyman)
08:16:19 <monochrom> nevermind, ghc is the one using too much memory, cabal-install is irrelevant
08:18:04 <Peaker> Async.race/concurrently/etc seem like a problem!  If the caller thread to these dies/is cancelled, this won't propagate inside, or would it?
08:18:42 <Peaker> oh, they do use withAsync internally
08:18:52 <jle`> @src mconcat
08:18:52 <lambdabot> Source not found. That's something I cannot allow to happen.
08:19:10 <monochrom> set environment variable GHCRTS='-M500m'
08:19:54 <monochrom> limiting cabal does nothing
08:20:02 <joneshf-laptop> with transformers how do you get around all this explicit lifting?
08:20:33 <quicksilver> by using classes
08:20:45 <Peaker> or functions
08:20:56 <Peaker> well, *some* of the explicit lifting
08:21:05 <quicksilver> so 'put' is actually (some number of lifts) $ put
08:21:16 <quicksilver> but you don't need to know how many, the typeclass instance encodes it
08:21:30 <Peaker> joneshf-laptop, I like to name each of my layers, and then I don't use "lift . lift $ put 5", I use:  "accountState $ put 5" which I think adds to, rather than subtracts from, the readability of the code
08:21:49 <joneshf-laptop> ah
08:22:05 <Peaker> so there's a bit of boilerplate where you define the monad stack -- giving a name to each layer like:  fooReader = lift ; accountState = lift . lift
08:22:54 <quicksilver> I don't like to think of my code as having layers at all
08:23:00 <quicksilver> just primitives in a DSL
08:23:08 <quicksilver> which might (for all the user cares) affect multiple layers
08:23:15 <quicksilver> makeItSo 5
08:23:31 <joneshf-laptop> maybe i didn't set up the stack right?
08:23:33 <quicksilver> but the implementation of those "primitives" would use the typeclasses.
08:23:46 <joneshf-laptop> it's `StateT Foo (InputT IO) ()`
08:23:53 <monochrom> there is little difference between "makeIt (put 5)" and "makeitput 5"
08:24:26 <hodapp> I think I had a Haskell dream.
08:24:33 <SwashBuckla> monochrom: I still get 'cabal: Most RTS options are disabled. Link with -rtsopts to enable them.'
08:24:36 <hodapp> but it involved explaining monads with a soda can analogy.
08:24:40 <hodapp> so I should probably ignore it.
08:25:08 <monochrom> oh, I see
08:25:11 <SwashBuckla> monochrom: this is now running    export GHCRTS='-M500m' as usual
08:25:16 <quicksilver> monochrom: there is and then there isn't.
08:25:30 <quicksilver> monochrom: makeIt (put 5) exposes the fact that it factors through a State monad
08:25:33 <quicksilver> so it's less abstract
08:25:40 <quicksilver> but potentially more polymoprhic or reusable.
08:25:58 <quicksilver> less abstract and more abstract are both valid choices...
08:26:24 <monochrom> SwashBuckla, do you mean you now have success?
08:26:49 <SwashBuckla> monochrom: no
08:26:58 <SwashBuckla> it just doesn't run
08:27:06 <SwashBuckla> 'cabal: Most RTS options are disabled. Link with -rtsopts to enable them.'
08:27:47 <Saizan> GHCRTS='-M500m' applies to cabal too
08:27:48 <monochrom> cabal install cabal-install --ghc-options='+RTS -M500m -RTS'
08:28:40 <monochrom> the moral is I have to surgically give something to ghc without giving it to cabal-install
08:29:11 <monochrom> this is like "bomb the basement but don't harm the 2nd floor"
08:29:41 <monochrom> and I am not exactly sure that --ghc-options='+RTS -M500m -RTS' is the right syntax
08:29:47 <SwashBuckla> we shall see
08:30:28 <pjdelport> hodapp: monadically consuming the contents of a soda can and putting it back in does not sound wise, yes
08:30:40 <oio_> where is .GHCI?
08:30:50 <oio_> On mac OS X
08:31:32 <Peaker> I have potentially multiple threads who race to add a key to a map. The winner puts the key and spawns a thread associated with that key. The loser should get a handle to the same thread.  I am currently using atomicModifyIORef and a Map to MVars to do this. But this is racy -- what if I'm killed before the MVar is written?  Is there perhaps a nicer way to do this?
08:32:18 <monochrom> oio_: it's .ghci, lower case. and see GHC user's guide section 2.9, it's somewhere on your hard disk
08:32:40 <Peaker> so both winner and loser make an empty MVar, both try to add it to the map,  and the winner puts his mvar, and returns the action to fill that mvar from the atomic action.  The loser does nothing to the map, and just returns an action to read that mvar
08:32:58 <oio_> monochrom: couldn't find / -name ".ghci*"
08:33:01 <Peaker> but maybe I'm reinventing the wheel poorly here?
08:33:56 <prophile> of potential interest, conversions between StateArrow and Automaton: https://gist.github.com/prophile/9095693
08:33:57 <monochrom> then you do not have one. most people won't. it's user customization, and most users don't customize
08:34:15 <prophile> this seems to work, although it sounds like it shouldn't
08:35:04 <monochrom> and I thought your question was "I want to write one, where should I write it?" apparently, you mean something else unknown
08:35:46 <pvt_petey> how exactly is a type class like a java interface
08:35:57 <monochrom> I should know that a terse question cannot possibly mean anything at all
08:35:58 <pvt_petey> I don't quite get it from the learn you a haskell tutorial
08:36:28 <Maior> pvt_petey: how is it not?
08:36:36 <monochrom> @quote twitter
08:36:36 <lambdabot> kmc says: ghc -XTwitter -ddump-tweets
08:36:40 <monochrom> @quote twitter
08:36:40 <lambdabot> alephomega says: Wait, there's blackboard bold in unicode? My life has just been changed. My poor twitter followers...
08:36:47 <oio_> monochrom: where should i put it?
08:37:07 <monochrom> see section 2.9. but one option is "the current directory"
08:37:33 <pvt_petey> well a java interface is for methods only, and constants or enum
08:37:38 <pvt_petey> it's the behavior
08:37:41 <SwashBuckla> monochrom: cabal transplant successful, basement bombed :)
08:37:42 <Maior> pvt_petey: I don't really mean that flippantly - your question implies you know what a java interface is; do you think that typeclasses aren't like them?
08:38:25 <Maior> I'd forgotten about being able to put constants in interfaces; been a while since I wrote Java - ignore that bit
08:39:20 <pvt_petey> well I don't really know
08:39:52 <monochrom> pvt_petey, see my http://www.vex.net/~trebla/humour/tautologies.html #0, then laugh and move on. all analogies are wrong.
08:40:28 <Maior> lol
08:41:33 <pvt_petey> ^^ i guess the syntax is weird
08:41:57 <pvt_petey> (==) :: (Eq a) => a -> a -> Bool   how does this even compare to public class implements ......
08:42:28 <monochrom> I agree with you. not supposed to compare.
08:43:08 <pvt_petey> (Eq a) is it right to say that it's just a contract that says you have to return something (Eq a) rather than it has to implement this function with this name..
08:43:09 <n3hima> public interface Eq { public boolean equals(Eq a, Eq b); }
08:43:11 <n3hima> I guess
08:43:27 <pvt_petey> ok
08:43:49 <pvt_petey> so anything with (Eq) for example has a constraint on it's format ?
08:43:55 <monochrom> it is not right. Eq a does not say what you have to return
08:43:59 <n3hima> it has to implement (==)
08:44:09 <S11001001> n3hima: you need a type parameter there
08:44:25 <n3hima> in Java?
08:44:31 <S11001001> n3hima: yes.
08:44:32 <monochrom> ok, I can't correct the whole world. but you are all wrong.
08:44:36 <n3hima> I haven't written any for a while, but that's the gist
08:46:08 <Maior> pvt_petey: you appear to confuse implementation with other type signatures
08:47:08 <pvt_petey> Like Enum or Elem ?
08:47:12 <Maior> to translate Eq to protojava: interface Eq<T> { public Bool inlineEqualsMagic(T a, T b); }
08:47:35 <Maior> (ish)
08:47:46 <Maior> (terrible analogy that isn't quite equivalent)
08:49:46 <pvt_petey> ok
08:49:50 <pvt_petey> think I've kinda got it
08:50:02 <pvt_petey> Enum or Elem is the type interface
08:50:15 <bennofs> Is there a function to compare lists, where order is not important?
08:50:25 <pvt_petey> something like (Eq a) => a -> a -> Bool  is the implementation
08:50:29 <Iceland_jack> bennofs: You can always just use sets?
08:50:31 <bennofs> Hmm, I could just sort each list and compare :|
08:50:34 <Maior> pvt_petey: no
08:50:38 <pvt_petey> and (Eq a) is specifying what the parameters are in effect
08:50:40 <bennofs> Iceland_jack: my lists can contain duplicate elements
08:50:41 <Maior> pvt_petey: that's a type signature
08:50:49 <Maior> pvt_petey: the type signature for (==) in fact
08:50:52 <Iceland_jack> bags then :)
08:50:59 <Maior> (and also for (/=))
08:51:12 <Maior> (which I forgot about in my protojava)
08:51:20 <Iceland_jack> http://hackage.haskell.org/package/multiset
08:51:44 <joelteon> why did (==#) change from returning Bool to returning Int#?
08:51:45 <Iceland_jack> or http://hackage.haskell.org/package/data-ordlist-0.4.6/docs/Data-List-Ordered.html
08:51:47 <Maior> pvt_petey: an implementation would use `instance`
08:51:53 <Iceland_jack> sorting the lists is also an option
08:52:05 <Iceland_jack> possibly more expensive
08:53:23 <pvt_petey> perhaps that's more accurate ?
08:53:40 <Maior> pvt_petey: see, f/ex, http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html - search for "instance" and observe where Maybe "implements" Functor
08:53:44 <Peaker> I wonder how terrible, memory-wise, it would be to do:   serverLoop = do { conn <- accept ; withAsync (handle conn) $ const serverLoop }
08:54:01 <Peaker> As a (terrible) way to maintain the server as the parent-async to the children connection threads
08:54:24 <Peaker> though this would not free the memory when these children disconnect/die, so probably best to maintain a list of connections manually and kill them when the server dies
08:55:45 <monochrom> pvt_petey: "Eq a" means: the callee may use (==) and (/=) on values of type a. therefore, the caller must ensure that his choice of type a has that much. at this point, you should be asking, "caller of what? callee of what?"
08:56:35 <monochrom> so here is an example. "fff :: Eq a => a -> Int". then I am referring to the callee of fff and the caller of fff
08:57:09 <monochrom> I am the callee of fff. I am its author. I am entitled to write: "fff x y = if x==x then y else y+1"
08:58:20 <monochrom> you are the caller of fff. you are its user. you are entitled to write "fff 'c' 10" (Char is an instance of Eq). you are not entitled to write "fff not 10" (Bool->Bool is not an instance of Eq. at least, not yet.)
08:59:14 <monochrom> that is it. end of story. it is simpler than every analogy under the sun with other languages
08:59:38 <klrr> i cant use a attoparsec parser inside a pipes parser, right?
09:00:54 * hackagebot hOpenPGP 1.0.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.0.2 (ClintAdams)
09:00:56 <klrr> if not as i presume, is there any function to convert a Char to Word8 and back? (so i can check specific bytes)
09:01:20 <monochrom> the nice thing about analogies is that you can get the warm fuzzy Dunning-Kruger self-assurance of "I understand it" without facing the cold hard reality of making actual code work
09:02:29 <mkscrg> :t fromIntegral . ord
09:02:30 <lambdabot> Num c => Char -> c
09:02:41 <mm_freak> bound question:  let M be my expression type, then i can assume M Void to be a closed term, right?
09:02:52 <supki> klrr: convert how?
09:03:20 <supki> klrr: Char is bigger than Word8
09:03:40 <mm_freak> or even better:  type ClosedM = forall a. M a
09:04:45 <monochrom> I have not seen your expression type. I did not even know that it is of kind *->*, much less what that type parameter does
09:06:45 <mm_freak> monochrom: very simple example:  data Expr a = Let (Expr a) (Scope () Expr a) | Var a
09:07:22 <mm_freak> seems like a safe assumption to me that when 'a' is empty or fully polymorphic, then the expression must be closed
09:07:23 <monochrom> then likely yes
09:07:24 <mm_freak> (modulo bottoms)
09:07:38 <mm_freak> are there cases when it's not?
09:08:23 <monochrom> when "data Expr a = Atom | Var a"
09:08:41 <monochrom> well, I guess Atom is a closed term, too
09:08:59 <mm_freak> Var is the only way to refer to variables in my case
09:09:05 <monochrom> ok, when "data Expr a = Atom | Var a | ThisIsNotVar a"
09:09:10 <mm_freak> there are builtin functions, but they are considered closed
09:09:23 <mm_freak> and they don't need the type argument
09:09:43 <monochrom> err, nevermind. there is no counterexample
09:10:02 <mm_freak> thanks =)
09:11:40 <klrr> supki: hmm, but how do i check for a specific byte in a bytestring using pipes-parse then? attoparsec got char8 but that produces a attoparsec-specific parser
09:14:22 <fragamus> I have an off topic question: I wrote a ray tracer in haskell and I use cosine shading. DO I NEED to do gamma correction on the cosine value to produce the correct luminance?
09:17:57 <jowens> fragamus: typically you don't do any gamma correction until the very end of the pipeline when you choose a display
09:18:30 <jowens> store your images linear in intensity, do all your calculations in that space
09:18:39 <fragamus> ok so mplayer is doing the display, and I feed it YUV and so it should be handled right
09:18:59 <jowens> i don't know mplayer
09:19:37 <jowens> usually on a monitor it's a system-wide setting
09:20:07 <jowens> i would say don't worry about it at all until you're completely done and find your images look too dark or too light
09:35:10 <SwashBuckla> Hi there. I am experiencing the following panic! 'impossible' error: http://lpaste.net/100131
09:36:51 <ion> swashbuckla: I’d try upgrading GHC first. You have a rather old version.
09:37:42 <ion> swashbuckla: I install the newest version this way: https://gist.github.com/ion1/2815423
09:40:04 <monochrom> I don't exactly like setting PATH in .<shell>rc
09:40:09 <benj_> aloiscochard, going to this? http://www.meetup.com/London-Haskell/events/167064162/
09:40:51 <ij> monochrom, First that comes to mind is user shell set to a script that sets env and then calls shell, is that how you're going about it?
09:41:28 <monochrom> no, I put it in .profile
09:42:10 <SwashBuckla> yes .profile is the appropriate place
09:42:22 <SwashBuckla> seeing as some people use multiple shells
09:43:05 <monochrom> I can see where both sides come from
09:43:29 <applicative> SwashBuckla: try cabal install happstack-server --flags="-template_haskell"
09:44:09 <mm_freak> a good alternative is to use the default PATH
09:44:16 <mm_freak> and not to change it at all
09:45:33 <monochrom> putting GHC in .ghc is likely funny when combined with the suggestion "erase .ghc to get rid of user packages"
09:48:06 <Peaker> is it safe to pass mask's argument "restore" to a forkIO thread and use it there to locally unmask only in that thread?
09:51:27 <applicative> klrr: Pipes.Attoparsec.parse (do a <- Attoparsec.char8 'a'; b <- Attoparsec.char8 'b'; return (a,b)) is a Pipes.Parse bytestring parser
09:52:26 <Peaker> hmm.. using an async as a "forkIO" breaks when you want to start sending specific async exceptions into it
09:53:05 <Peaker> oh, cancelWith!
09:53:42 <klrr> applicative: oh, thanks!
09:54:13 <Peaker> awesome, my multithreaded setup now works as intended, including error propagation, at least for the simple case :)
10:06:21 <Peaker> what Exception type should I catch to examine Network.Socket errors?
10:07:48 <mm_freak> SomeException =)
10:08:47 <Peaker> I want to check which error it is...
10:09:07 <Peaker> I want to recv from a socket, and catch connection reset errors specifically
10:10:48 <oio_> any equation solver for ghci?
10:11:43 <mm_freak> that was…  patient…
10:12:08 <shachaf> An IOException created from an errno, it looks like?
10:12:23 <mm_freak> yeah, it's likely an IOException
10:12:52 <oio_> any equation solver for GHCI?
10:12:53 <Peaker> ah, thanks
10:13:01 <mm_freak> oio_: if your equations happen to be linear, there are matrix functions on hackage
10:13:09 <mm_freak> oio_: otherwise look into maxima
10:13:20 <Peaker> I wonder how I figure out whether an IOException/IOError is an ECONNRESET
10:14:05 <mm_freak> Peaker: not that i can answer your question, but why do you need to catch connection reset specifically?
10:14:52 <Peaker> mm_freak, I have a unix socket open in SEQPACKET mode to a child process. When that child process dies and cleans up its socket, it seems on my side I get an ECONNRESET error, rather than a normal EOF
10:14:57 <Peaker> mm_freak, so I want to treat it as a normal EOF
10:15:31 <mm_freak> ah, i see
10:15:37 <monochrom> I think IOException suffices
10:16:10 <mm_freak> Peaker: is the peer program under your control?
10:16:17 <Peaker> but IOException has a bunch of specific "isFoo" "isBar" functions, none of which can check for "isResetByPeer"
10:16:28 <shachaf> IOException has an errno.
10:16:29 <Peaker> mm_freak, only partially (I hook it with LD_PRELOAD)
10:16:45 <mm_freak> Peaker: because a properly written socket program would use 'shutdown' on the socket
10:16:45 <Peaker> shachaf, how do you get to it?
10:17:00 <mm_freak> at which point you should get something like EOF
10:17:27 <shachaf> GHC.IO.Exception exports a selector. I don't know if any standard module does.
10:17:40 <Peaker> shachaf, ah, thanks, I didn't think of looking under the hood there
10:17:47 <mm_freak> the problem you're facing is common:  connection reset /is/ an error and should in principle be treated as such
10:18:09 <mm_freak> but then many programmers abuse it as EOF
10:18:16 <Peaker> mm_freak, well, it represents the death of the process -- and since I'm using SEQPACKET, I don't have any send-atomicity issues.. Why is it necessarily an error?
10:18:54 <mm_freak> Peaker: it's a non-graceful shutdown of the socket…  in particular you can't tell close() from SIGKILL
10:19:50 <Peaker> mm_freak, but in my case, it doesn't really matter at all
10:20:35 <Peaker> All I need is a stream of FS operations the process is doing -- a different mechanism is used to monitor its successful exit, if needed
10:20:52 <jxv> general design question ( http://lpaste.net/100133 ) when is the top or bottom more appropriate?
10:22:25 <mm_freak> Peaker: then i would go the SomeException route while reading
10:23:12 <Peaker> but if there's a different error, it may not represent an end of all potential input.. I'd rather vet every error
10:23:27 <Peaker> (e.g: Some sort of EAGAIN error would better cause a retry)
10:30:06 <AlexRussia> Hello!How to get execute file with ghc in linux?
10:30:26 <kazagistar> I am trying to understand modules… the module names have to line up with the folder hierarchy?
10:30:49 <jxv> kazagistar, yes
10:31:01 * hackagebot streams 3.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.2 (EdwardKmett)
10:31:02 <dfmr> AlexRussia: ghc yoursourcefile1.hs yoursourcefile2.hs yoursourcefileN.hs -o theexecutablenameyouwant
10:32:24 <AlexRussia> dfmr: ty
10:33:41 <troydm> how do i write new line character in haskell
10:33:43 <troydm> ?
10:33:51 <troydm> "\n" is String expression
10:33:58 <troydm> but i want an character expression
10:34:01 <jxv> '\n'
10:34:41 <troydm> jxv: it doesn't works with '\r' so
10:34:43 <troydm> :(
10:35:41 <supki> > ord '\r'
10:35:42 <lambdabot>  13
10:35:47 <supki> > ord '\n'
10:35:48 <lambdabot>  10
10:36:41 <troydm> hmm... it seems i have an error which isn't related to this
10:36:44 <troydm> thx anyways
10:36:46 <AlainODea> troydm: lpaste a small example with context
10:37:15 <AlainODea> troydm: it should be easier to see what is going wrong
10:38:23 <mm_freak> troydm: '\r' is wrong anyway =)
10:38:34 <troydm> AlainODea: http://lpaste.net/1964443068241281024
10:38:38 <mm_freak> troydm: and keep in mind that by default stdout is line-buffered
10:39:08 <mm_freak> troydm: what are you trying to do there?
10:39:14 <mm_freak> you're replacing the letter n by a line feed
10:39:28 <troydm> ahh never mind
10:39:34 <troydm> i know my error
10:39:41 <troydm> | symbol is ML only
10:39:52 <mm_freak> what?  no…
10:39:57 <troydm> i forgot about it
10:40:11 <mm_freak> it just means something different…  i didn't even notice the | =)
10:40:24 <AlainODea> troydm: excellent.  Best way to find an error :)
10:42:29 <troydm> but it still refuses to compile
10:42:44 <troydm> now x -> x line is at fault
10:43:03 <troydm> can't i just match character to any variable
10:43:07 <troydm> ?
10:44:39 <troydm> hmm i need to use otherwise
10:46:13 <joneshf-laptop> @pl \(Foo a b) c -> Bar a b c
10:46:14 <lambdabot> (line 1, column 7):
10:46:14 <lambdabot> unexpected "a"
10:46:14 <lambdabot> expecting operator or ")"
10:47:43 <joneshf-laptop> erm, what?
10:47:52 <joneshf-laptop> does it not work with constructors?
10:48:04 <troydm> how do i '\' ?
10:48:10 <troydm> '\\' ?
10:48:11 <Iceland_jack> '\\'?
10:48:28 <Iceland_jack> joneshf-laptop: No, pl can't do that much with your own constructs anyway
10:48:40 <Iceland_jack> since it has no way of eliminating them other than pattern matching
10:48:56 <ion> joneshf: You should be able to eta-reduce that to \(Foo a b) -> Bar a b
10:48:57 <Iceland_jack> @pl \(a, b) c -> Bar a b c
10:48:57 <lambdabot> uncurry Bar
10:49:45 <ion> or unFoo Bar if you have the equivalent of uncurry. :-P
10:49:57 <Iceland_jack> yes :)
10:50:11 <predator117> hi, can somebody tell me why this: http://lpaste.net/100134 does not work for infinite lists?
10:50:54 <joneshf-laptop> hmm, so basically no improvement for random things
10:50:56 <joneshf-laptop> that's fine
10:51:25 <joneshf-laptop> though i would've thought there's be some combinator for that
10:52:00 <ion> @pl usually deteriorates code, don’t expect improvements in general.
10:52:01 <lambdabot> (line 1, column 26):
10:52:01 <lambdabot> unexpected ','
10:52:01 <lambdabot> expecting variable, "(", operator or end of input
10:52:07 <Athas> predator117: it seems like <:> is strict in its right operand.
10:52:18 <jedai42> predator117: To apply <:> you need to know that the result of half zs will be a pair, but to know that, you need to evaluate it so you'll need to compute w:W ...
10:52:19 <shachaf> predator117: Try (n,m) <:> ~(ns,ms) = ...
10:52:28 <joneshf-laptop> hmm
10:52:36 <Iceland_jack> predator117: what shachaf said
10:52:54 <AlainODea> troydm: case c of ... | otherwise -> c
10:53:07 <jedai> predator117: Right, lazy pattern as shachaf said is the standard cure (you can also try writing it as a fold too)
10:53:16 <predator117> shachaf: thanks that works, but why exactly is that so?
10:53:17 <AlainODea> troydm: in lieu of | x -> x (which doesn't compile)
10:53:22 <joneshf-laptop> i think i asked the wrong question
10:53:25 <joneshf-laptop> as usual
10:53:26 <predator117> i know the lazy pattern match ~
10:53:44 <predator117> but i would not have thought that matching on the tuple forces the whole list
10:54:00 <Iceland_jack> well matching on a tuple forces the *tuple*
10:54:02 <ion> It doesn’t force the whole list, but it does force the tuple.
10:54:24 <Iceland_jack> which in turn forces the recursive ‘half zs’
10:54:25 <jedai> predator117: It does because you need to evaluate half zs to be sure it _is_ a tuple (and not undefined)
10:54:41 <predator117> okay thx that makes more sense
10:55:54 <AlainODea> troydm: my bad on that case c of { ... ; _ -> c }
10:56:16 <AlainODea> troydm: without the braces or semicolons if you're in a file. I'm hacking this in ghci
10:56:26 <troydm> AlainODea: yeah, i've got it, what's wrong with otherwise?
10:56:39 <troydm> did they changed the standard for this case operator ?
10:57:02 <ion> > case 42 of otherwise -> otherwise
10:57:03 <troydm> like i remember somehow reading about it few years ago in LYAH used otherwise
10:57:04 <lambdabot>  42
10:57:07 <ion> > case 42 of x -> x
10:57:08 <lambdabot>  42
10:57:16 <troydm> hmm
10:57:16 <ion> This is just shadowing the value “otherwise”.
10:57:36 <Iceland_jack> troydm: otherwise is just 'True'
10:57:43 <Iceland_jack> it's not a pattern
10:57:59 <d3lxa> how can you use the ? operator? do I need to import something?
10:58:06 <Iceland_jack> You can use it for
10:58:06 <Iceland_jack>     foo x | x == 4    = ...
10:58:06 <Iceland_jack>           | otherwise = ...
10:58:08 <troydm> Iceland_jack: ahh, ic
10:58:22 <geekosaur> d3lxa: afaik ? is a lens-ism?
10:58:24 <ion> > let (?) = (+) in 3 ? 4
10:58:25 <lambdabot>  7
10:58:28 <Iceland_jack> But that's functionally equivalent to
10:58:28 <Iceland_jack>     foo x | x == 4 = ...
10:58:28 <Iceland_jack>           | True   = ...
10:58:50 <Iceland_jack> (?) is addition!
10:58:53 <d3lxa> oh it's in derive, okay
10:59:28 <geekosaur> yeh, nonstandard operator, depends on which one you're expecting from where (hereabouts lens seems most popular but like <+> there are many different ones)
10:59:40 <ion> I think i would have preferred “| = blah” syntax instead of the “otherwise” value.
11:00:48 <adas> it seems like there are only two haskell package managers. cabal and cabal-dev. Which one is recommended and which one does the community use?
11:01:08 <joneshf-laptop> the question i should've been asking, is why was I even making `Foo`'s in the first place
11:01:31 <Iceland_jack> Why /were/ you making Foo's in the first place joneshf-laptop? :)
11:02:00 <ion> Cabal-dev is just a wrapper over cabal. Cabal itself has gained sandbox support, so you might be fine without cabal-dev.
11:02:19 <joneshf-laptop> Iceland_jack, holdover from old code
11:02:21 <jfischoff> is there a way to tell if a thread is still alive, if I have it's thread id?
11:02:42 <dcoutts> adas: and cabal-dev development has stopped and the authors now recommend using cabal
11:02:45 <Iceland_jack> @hoogle threadStatus
11:02:45 <lambdabot> GHC.Conc.Sync threadStatus :: ThreadId -> IO ThreadStatus
11:02:45 <lambdabot> GHC.Conc threadStatus :: ThreadId -> IO ThreadStatus
11:02:45 <lambdabot> GHC.Conc.Sync data ThreadStatus
11:02:51 <Iceland_jack> jfischoff
11:02:55 <jfischoff> thanks
11:03:04 <AlainODea> troydm: the '|' is for guards and is an alternative if you are writing this conversion as a function without using a case expression. let f c | c == 'n' = '\n' | c == 'r' = '\r' | otherwise = c
11:03:20 <AlainODea> troydm: vs let f c = case c of {'n' -> '\n' ; 'r' -> '\r' ; _ -> c}
11:03:28 <adas> getting back after a long time
11:03:52 <dcoutts> Iceland_jack, jfischoff: hmm, nice I didn't know that existed, ghc internal of course
11:04:37 <troydm> AlainODea: ic, thx for clarifyign
11:04:39 <dcoutts> jfischoff: so of course that hints that you're not supposed to do things that way. Ok for debugging/monitoring of course.
11:05:24 <AlainODea> troydm: my pleasure :)
11:05:44 <bennofs> Is criterion only suited for micro benchmarks or is it also good for larger computations?
11:05:44 <jfischoff> dcoutts: its just for logging :)
11:09:06 <joneshf-laptop> hmm, is there a general "fail late" monad, in contrast to the "fail early" of Maybe/Either?
11:09:21 <joneshf-laptop> oh wait, that's Alternative right?
11:09:46 <mizu_no_oto> Can you mix lens's mkLenses with Persistant's template haskell?  I'm getting a fairly unhelpful error -  http://lpaste.net/100138
11:12:02 <bennofs> When I have a top-level definition of some constant (let's call it c), and then do print (someFunction c) >> print (someFunction c), and c is a lazy data structure, it will stay evaluated between the calls, right?
11:14:50 <lispy> bennofs: in this case c is "shared"
11:15:03 <bennofs> lispy: can I somehow break the sharing?
11:15:03 <lispy> bennofs: And that means it's the same c in both calls
11:15:23 <lispy> bennofs: Yes
11:15:38 <bennofs> lispy: how? Give it an extra () argument?
11:16:09 <lispy> bennofs: That would work if you added the parameter to c
11:17:15 <lispy> if you had c' = const c, I'm not sure if the optimizer would just inline things and recover the sharing.
11:17:17 <treehouse> question: how many here are absolutely sure that they aren't a psychopath?
11:18:46 <bennofs> lispy: even if it doesn't inline things, c would be shared, wouldn't it? When evaluating c' (), c will be needed, and c has a name, so it's shared
11:18:58 <BMeph> treehouse: While we are glad that you enjoy the openness and friendliness of #haskell, if you're playing around, may I suggest #haskell-blah, please?
11:19:26 <lispy> bennofs: Oh right. That sounds correct.
11:19:29 <treehouse> k
11:20:17 <lispy> bennofs: Would that still be true if we hid c under a lambda? c' = \() -> c
11:20:25 <bennofs> lispy: I guess so
11:20:35 <bennofs> lispy: as soon as you give c a name, it will be shared
11:20:38 <matheus23> I have a hard time figuring out types and writing a little type class... :( http://lpaste.net/100140
11:20:44 <lispy> I think so too. You'd have to reevaluate c' but the c part would be given.
11:20:49 <bennofs> lispy: you need to inline c under the lambda to break the sharing
11:20:54 <lispy> bennofs: right
11:21:05 * hackagebot ghc-events-parallel 0.4.2.0 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.4.2.0 (JostBerthold)
11:21:11 <lispy> bennofs: Could you do that with a where-clause?
11:21:28 <lispy> bennofs: c = \() -> oldC where oldC = ....
11:21:39 <bennofs> lispy: Not sure. Might be that ghc detects that the where doesn't depend on the argument, and lifts it up.
11:22:05 <lispy> bennofs: I think it's worth a try, I know ghc tries to be careful about adding too much sharing.
11:22:21 <lispy> for example, they avoid CSE
11:22:35 <bennofs> lispy: But I think it will only work if you write c () = ... where, and not if you write c = \() -> ... where
11:24:26 <klrr> is there any Producer ByteString IO () -> Parser ByteString IO () -> Producer ParsedFormat IO ()?
11:24:46 <lispy> bennofs: I'm not sure. I get tripped up by the run-time performance differences of those two and I could have picked the wrong one.
11:25:16 <lispy> bennofs: I guess the former is a function whereas the other one has a closure on the outside of the function?
11:25:25 <lispy> bennofs: I'm wondering, how would you reason about the difference.
11:25:32 <bennofs> lispy: yes, I guess
11:25:48 <bennofs> lispy: I'm writing a small test program using trace trying several of the different versions
11:26:06 * hackagebot shellmate 0.1.2 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.2 (AntonEkblad)
11:26:07 <lispy> bennofs: cool, let me know what you figure out
11:31:06 * hackagebot primitive 0.5.2.1 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.2.1 (BryanOSullivan)
11:34:10 <bennofs> lispy: wow, with -O2, I wasn't able to break the sharing with ANY of the variants
11:34:27 <matheus23> for anyone wondering, that's how I fixed my problems: http://lpaste.net/100143
11:35:12 <bennofs> lispy: here is what I tried: http://lpaste.net/100144
11:36:43 <bennofs> lispy: any ideas on how to break sharing with -O1 ?
11:40:47 <lispy> bennofs: Play with the NOINLINE pragma
11:41:03 <lispy> bennofs: I can't remember if that's a hint or always respected...
11:41:07 * hackagebot shellmate 0.1.3 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.3 (AntonEkblad)
11:41:18 <applicative> klrr: you mean something like this http://lpaste.net/7444591441222828032
11:41:48 <Wizek> Good morning!
11:42:26 <bennofs> lispy: putting NOINLINE on everything but f doesn't change the result
11:42:27 <applicative> klrr: bah, the type should be apply :: Monad m => Parser a m b -> Producer a m y -> Producer b m z
11:43:00 <Wizek> Can I share variables in different do blocks (IO Monad)?
11:43:12 <notdan> Wizek: yes
11:43:18 <Wizek> notdan, how?
11:43:19 <notdan> Wizek: you can share IORefs
11:44:15 <notdan> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-IORef.html
11:44:15 <Achylles> I have hdevtools in my "./cabal/bin", but vim complains that it is not executable. How can I fix this in my .vimrc or wherever?
11:44:27 <milfjord> Achylles: what's the error message?
11:44:38 <ReinH> Wizek: but what you might actually want to do is wrap your IO with StateT
11:45:00 <Wizek> ReinH How?
11:45:46 <klrr> applicative: thanks, exactly what i wanted, may i ask what RankNTypes does here?
11:45:48 <lispy> bennofs: two things: a) Can we really trust trace for this? b) I'm out of ideas :)
11:45:58 <bennofs> lispy: going to ask on SO
11:46:04 <bennofs> lispy: why not trust trace?
11:46:17 <ReinH> Wizek: StateT will give you access to "mutable" state with your IO actions.
11:46:21 <lispy> bennofs: I guess this overlaps with observing sharing, and you're not supposed to be able to do that under normal circumstances
11:46:25 <Achylles> milfjord, "hdevtools is not executable! ghcmod is not executable!"
11:46:34 <ReinH> Wizek: for example http://www.haskell.org/haskellwiki/Simple_StateT_use
11:46:36 <lispy> bennofs: So you might have some luck with some of the ways to observe sharing
11:47:09 <milfjord> Achylles: is .cabal/bin in your PATH?
11:47:14 <lispy> bennofs: trace can change strictness
11:47:33 <Achylles> milfjord, do you mean in my .vimrc?
11:48:01 <milfjord> no, in your environment
11:48:09 <jle`> i was...legitimately going to start writing out a complex function composition of normal functions using proc/do notation
11:48:17 <Achylles> milfjord, no. I think not
11:48:21 <jle`> until i realized that i can just use 'where' and stuff like that >.>
11:48:31 <mm_freak> am i the only one who is bothered by the fact that most people consider state and mutable variables to be the same thing?
11:49:07 <jle`> mm_freak: i actually never even noticed that that was mixed up in common conception
11:49:14 <jle`> that...explains a lot
11:49:17 <jle`> now
11:49:58 <mm_freak> here is a stateful haskell program:  main = print [1..]
11:50:06 <Wizek> To avoid an XY issue: Which approach would you use in HSpec to share variables? I am trying to replicate a Given..When..Then pattern for BDD testing.
11:50:14 <mm_freak> and no, i'm not referring to the 'print', but to the [1..]
11:50:33 <Wizek> So whatever is set up in Given I should have access to later.
11:50:47 <Rc43> Anybody can get how to define in agda any lens with such definition? https://github.com/aristidb/lens-agda/blob/master/Lens.agda
11:50:54 <Rc43> E.g. _1.
11:50:57 <johnw> Wizek: I'm pretty sure you can just use let
11:51:29 <johnw> i.e., https://gist.github.com/9100130
11:51:36 <mm_freak> Wizek: what are you trying to do?
11:51:38 <johnw> because after all it's just a monad
11:51:39 <bennofs> lispy: The trick is to use {-# INLINE #-} pragmas
11:51:56 <mm_freak> Wizek: whatever it is, i'm really sure that mutable variables are not the answer
11:52:03 <lispy> bennofs: inline the thing you don't want to share?
11:52:06 <mm_freak> so neither IORef nor StateT
11:52:08 <bennofs> lispy: yes
11:52:19 <Wizek> mm_bureau could very well be, let me make an example
11:52:19 <lispy> bennofs: Yeah, that makes sense. Not sure why I was thinking NOINLINE >.>
11:52:41 <mm_freak> Wizek: try to explain the problem, not the solution =)
11:52:48 <lispy> bennofs: and it works with trace?
11:52:53 <bennofs> lispy: yes
11:52:56 <lispy> cool
11:53:22 <bennofs> lispy: I wonder if you can force ghc to inline big computations too? How much force does {-# INLINE #-} have?
11:53:52 <bennofs> lispy: btw, you can even put {-# INLINE #-} on the constant and it doesn't share :)
11:54:07 <applicative> klrr: it's just so I can use the fancy "Parser" type synonym. It's not really relevant otherwise. Obviously if the parser is returning Maybe x, you should exit and so on
11:54:45 <klrr> applicative: okey, thanks! :)
11:54:46 <Wizek> https://gist.github.com/Wizek/9100198
11:55:00 <Wizek> Not in scope: `out'
11:55:06 <Wizek> This is the basic problem :)
11:55:18 <Iceland_jack> > scope
11:55:19 <lambdabot>  Not in scope: `scope'
11:55:33 <Wizek> E2E.hs:19:19: Not in scope: `out'
11:55:41 <Wizek> This is the actual error runghc gives me
11:55:43 <mm_freak> Wizek: you have two actions, and one depends on something from the other
11:55:49 <Wizek> yep
11:55:53 <mm_freak> Wizek: what is something that depends on something?
11:56:09 <Achylles> milfjord, thx, I have fixed that message, Now I need to fix ghcmod
11:56:22 <Wizek> mm_bureau I feel like you want me to say something obvious
11:56:28 <mm_freak> Wizek: indeed =)
11:56:54 <mm_freak> if value x depends on value y, x is a … of y
11:57:07 <Wizek> mm_bureau function of y?
11:57:13 <mm_freak> Wizek: there you go =)
11:57:29 <mm_freak> then_the_game_should_present_itself out = do …
11:57:55 <Wizek> hmm
11:58:06 <Wizek> that would indeed work
11:58:16 <mm_freak> and in order for then_the_game_should_present_itself to receive that 'out' value, given_the_application_starts first should stop keeping it to itself =)
11:58:17 <Wizek> but wouldn't be the prettiest to write
11:58:43 <applicative> klrr: here's something closer to the 'correct' approach, http://lpaste.net/100147 for one case
11:59:18 <mm_freak> Wizek: why would that not be pretty?  it's the most straightforward encoding of data dependencies
11:59:58 <mm_freak> Wizek: it feels like more to write right now, but don't worry, in the end it will actually be less to write =)
12:00:00 <Wizek> mm_freak I mean somethimes I might have a lot of `given`s, should I pass all of them explicitly furhter? Can't I just have that kind of state automatically passed furhter for all the next call;s?
12:00:17 <mm_freak> Wizek: this is a lie:  you can't
12:00:22 <mm_freak> go with the lie for now
12:00:41 <Wizek> Okay, you'll see me soon.
12:01:04 <klrr> applicative: oh, thanks!
12:01:07 <mm_freak> don't worry, there are ways to hide this stuff under a think layer of monadic magic =)
12:01:12 <mm_freak> just don't do that right now
12:01:20 <mm_freak> s/think/thick/
12:01:43 <matheus23> hey, does anybody know what '[Data] of kind [kind] is not promotable' means? code: http://lpaste.net/100148
12:03:08 <mm_freak> matheus23: out of curiosity:  does it work, if you replace newtype by data?
12:03:13 <Saizan> matheus23: that you can't use [Data] as a kind, i don't know the details of which are allowed though
12:03:27 <matheus23> mm_freak: nope :(
12:03:37 <mm_freak> Saizan: it's not an exact error quote
12:03:43 <mm_freak> the truth is in the paste =)
12:04:08 <mightybyte> Is there anything existing that is like Show but generating Text instead of String?
12:04:12 <Saizan> mm_freak: you, was just reusing the same meta variables there :)
12:04:20 <Saizan> *yup, not you
12:06:13 * hackagebot directed-cubical 0.1.0.0 - Finite Directed Cubical Complexes and associated algorithms  http://hackage.haskell.org/package/directed-cubical-0.1.0.0 (mmisamore)
12:06:32 <mm_freak> matheus23: is it perhaps because of the Nat?  my brain is broken right now, but you might actually lift beyond kinds there
12:07:46 <matheus23> mm_freak: yeah. My brain is almost dead as well... that could be. I was also wondering why I couldn't replace "(Add d N1)" with "(Succ d)"
12:07:54 <noisemaker> ciao
12:07:57 <noisemaker> !list
12:07:58 <monochrom> noisemaker: http://hackage.haskell.org/packages/archive/pkg-list.html
12:16:16 <Rc43> Can we defined usual lenses with Profunctor or Profunctor is necessary only for Iso lenses?
12:17:24 <johnw> Rc43: you should ask in #haskell-lens
12:17:40 <johnw> I remember seeing a reformulation of the core lens types around isos and profunctors that was extremely elegant
12:17:44 <Rc43> johnw, oh, didn't know about that channel
12:18:03 <Rc43> johnw, I found agda definition with profunctor and can't get how to use it
12:18:12 <bennofs> Rc43: You can have profunctor only lenses, but the price is that you can no longer use "traverse" and similar as a lens
12:19:20 <Rc43> bennofs, it is ok in my case; I want only to find way for removing some boilerplate from my Coq development =/
12:20:32 <bennofs> Rc43: ah, no, lens doesn't currently implement pure profunctor lenses because of that trade off, so you'd have to write your own 'lens' package to use profunctor only lenses
12:26:15 * hackagebot etcd 0.1.0.1 - Client for etcd, a highly-available key value store  http://hackage.haskell.org/package/etcd-0.1.0.1 (wereHamster)
12:27:01 <dmead> ?yow
12:27:01 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
12:35:05 <mm_freak> what?
12:35:27 <mm_freak> reminds me how, when you typed "amish", google used to auto-suggest "amish online dating"
12:41:34 <matheus23> mkey
12:41:41 <matheus23> sorry, wrong chat
12:55:10 <Elision> @pl f (g x) (g y)
12:55:10 <lambdabot> f (g x) (g y)
12:55:15 <Elision> lol
12:55:23 <geekosaur> you need to specify which points to remove
12:55:32 <Elision> yeah
12:55:38 <Elision> gonna just do it in pm
12:56:13 <johnw> @pl \× y -> f (g x) (g y)
12:56:13 <lambdabot> (line 1, column 3):
12:56:13 <lambdabot> unexpected "\151"
12:56:13 <lambdabot> expecting letter or digit, operator, pattern or "->"
12:56:18 <kazagistar> why is there Enum Double?
12:56:19 <johnw> @pl \x y -> f (g x) (g y)
12:56:19 <lambdabot> (. g) . f . g
12:56:26 <Elision> *wow*
12:56:58 <raichoo> such composition!
12:57:10 <Elision> I was expecting some kind of clever applicative nonsense that only required one instance of 'g'
12:57:17 <merijn> Elision: In general @pl tends to make things worse :p
12:57:26 <Elision> haha yeah
12:57:34 <merijn> Elision: Are x and y the same type?
12:57:43 <Elision> yes
12:57:44 <Iceland_jack> :T ON
12:57:46 <Iceland_jack> :t on
12:57:46 <merijn> :t on
12:57:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:57:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:57:53 <Elision> ah there we go
12:58:01 <merijn> Elision: i.e. "f `on` g"
12:58:35 <geekosaur> note tht @pl is not real smart, and has not been updated to know about e.g. "on" (and can't use it anyway since it doesnt know if x and y have the same type)
12:59:23 <Elision> where is 'on'?
12:59:28 <geekosaur> Data.Function
12:59:31 <Iceland_jack> @hoogle on
12:59:32 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:59:32 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
12:59:32 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
12:59:41 <Elision> ah
13:00:19 <kazagistar> ghc cannot infer the type of `succ` and `pred` in my code because for some mysterious reason, Doubles are Enums too, which means I have to do some horrible (+(1::Int)) and (+(-1::Int)) stuff
13:01:43 <geekosaur> the reason they're Enum is because people tend to expect [1.0 .. 5.0] to work
13:02:14 <kazagistar> ah, I see…
13:02:33 <Elision> danke
13:02:57 <Elision> geekosaur: ... and give them what, [1.0, 2.0, 3.0, 4.0, 5.0]?
13:02:59 <enthropy> kazagistar: ghc doesn't pick an instance just because there is only one that fits
13:03:07 <geekosaur> also ^ that
13:03:20 <geekosaur> Elision, that is what it gives, yes. (although it can get rather weird, actually)
13:03:26 <Elision> hmph
13:03:33 <geekosaur> it's actually a bad fit but we're stuck with it
13:03:38 <kadoban> any ideas for improving the memory usage of this? i'm trying to find really big fibonacci numbers by using a matrix definition and then using matrix squaring to bring it down to O(lg n), but that unfortunately involves really really big matrices...
13:03:40 <Elision> I mean, you *can* enumerate double-precision IEEE fp
13:03:43 <prophile> Int is smaller than Double generally I believe
13:03:46 <Elision> it's just.... not fun
13:03:51 <prophile> so you can't make it an actual Enum
13:03:58 <kadoban> http://lpaste.net/100154
13:04:01 <prophile> because Enum entails isomorphism with Int
13:04:09 <khyperia> wait, I thought Int was native integer? Or is it 32 bit on 64 bit systems?
13:04:27 <prophile> I seem to recall it's required to be at least -2^29..2^29
13:04:30 <geekosaur> khyperia, depends on how ghc was built, I believe
13:04:42 <prophile> so from a spec point of view it isn't big enough to represent an IEEE double
13:05:35 <kazagistar> > [1.1 .. 1.5] — surprise!
13:05:37 <lambdabot>  <hint>:1:25:
13:05:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:05:46 * Iceland_jack is surprised
13:05:51 <kadoban> haha
13:05:52 <johnw> khyperia: on a 64-bit system Int should be 64-bits and double should be 80 bits
13:06:14 <Eduard_Munteanu> Are there FRP web frameworks or generally steps towards that?
13:06:26 <kazagistar> I am rather surprised by that… it works in ghci…
13:06:39 <kazagistar> or rather, does not work as expected :D
13:06:44 <khyperia> ah, johnw
13:06:51 <Eduard_Munteanu> > enumFromTo 1.1 1.5
13:06:53 <lambdabot>  [1.1]
13:07:08 <Earnestly> kazagistar: It looks like your `-- comment` was converted into an mdash, —
13:07:11 <joelteon> > [1.1 ..]
13:07:12 <lambdabot>  [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,17.1...
13:07:20 <khyperia> although I must have installed the 32 bit haskell platform or something, since "logBase 2 (fromIntegral (maxBound :: Int))" spits out 31
13:07:25 <shepheb> Eduard_Munteanu: AngularJS? :P
13:07:29 <Earnestly> kazagistar: Which is why it confused lambdabot
13:07:37 <merijn> Eduard_Munteanu: Did you mean front end or backend?
13:08:19 <Eduard_Munteanu> shepheb: my knowledge about that sort of stuff is rather, er, ... I don't even know. :)
13:08:26 <Eduard_Munteanu> merijn: frontend
13:08:40 <matheus23> Eduard_Munteanu: Have you had a look at Elm?
13:08:45 <merijn> Eduard_Munteanu: Elm
13:08:50 <matheus23> Eduard_Munteanu: http://elm-lang.org/
13:09:07 <Eduard_Munteanu> Interesting.
13:10:01 <merijn> Eduard_Munteanu: And with ghcjs you can of course use your favorite FRP library for the frontend :p
13:10:05 <Eduard_Munteanu> The reason for asking is I don't want to write HTML, I figured maybe I could take a detour through a more functional approach.
13:10:37 <merijn> Eduard_Munteanu: Do you want pragmatic and practical or I wanna learn cool stuff and semi-practical?
13:11:11 <Eduard_Munteanu> merijn: somewhere in-between :)
13:11:30 <Eduard_Munteanu> What's semi-practical? :)
13:11:33 <Elision> joelteon: also fun is let x = 10^308 in [x..x+1] :: [Double]
13:11:40 <Elision> :p
13:11:58 <joelteon> oh neat
13:12:00 <merijn> Eduard_Munteanu: Ur/Web, dependently typed language for web-programming with statically checked HTML, JS and SQL :)
13:12:22 <Eduard_Munteanu> Now *that* sounds interesting. :)
13:12:56 <merijn> Eduard_Munteanu: The haskell reddit had a post by a guy implementing his startup RSS reader in it and the guy working on it claims to do consulting work for it, so it must be somewhat usable
13:13:16 <merijn> Eduard_Munteanu: http://www.impredicative.com/ur/
13:13:31 <joelteon> do people use ur/web
13:13:41 <giskardreventlov> merhaba. haskell öğrenmeye çalışıyorum. acaba türkçe bilen birileri var mı?
13:13:44 <merijn> joelteon: See 2 lines up :p
13:13:55 <Eduard_Munteanu> Hm.
13:13:57 <joelteon> asked too quickly
13:14:23 <merijn> Eduard_Munteanu, joelteon: See also: http://www.impredicative.com/pipermail/ur/2014-January/001608.html
13:14:33 <Eduard_Munteanu> Maybe, I should state my goal / annoyance.
13:14:44 <merijn> He claims to have several thousand paying customers using his Ur/Web app, so
13:14:45 <bennofs> Is there something like the Coroutine monad, but where the suspension functors alternate between two functors for each suspension?
13:15:11 <Eduard_Munteanu> I'm primarily annoyed that I have to write a bunch of HTML/CSS/JS when I just want a darn form suitable for a datatype.
13:15:40 <mm_freak> bennofs: what would the type of that be?
13:15:40 <joelteon> wow, ur's type system is pretty crazy
13:16:18 <joelteon> i don't know how I feel about xml *in source code*
13:16:56 <mm_freak> is there a fast Float/Double to ASCII ByteString converter?
13:16:58 <Eduard_Munteanu> On a related note, I'd much prefer writing an XML schema than a form.
13:17:03 <merijn> joelteon: The type system is haskell/ocaml fusion with a side of proper dependent types :p
13:17:13 <bennofs> mm_freak: newtype Coroutine s1 s2 r = Coroutine { resume :: Either (s1 (Coroutine' s1 s2 r)) r }; type Coroutine' s1 s2 r = Coroutine s2 s1 r
13:17:26 <merijn> joelteon: Well, the advantage is that the type checker actually verifies your XML is well-formed
13:17:38 <erisco> Eduard_Munteanu, there is not enough information in the data definition to derive a form
13:17:40 <merijn> joelteon: It does the same for SQL and JS
13:17:41 <mm_freak> bennofs: i'm afraid not, but note that Coroutine ≃ FreeT
13:17:45 <erisco> Eduard_Munteanu, but people certainly try
13:18:49 <Eduard_Munteanu> erisco: interesting... has this thing been researched? Are there ways to make data definitions specific enough?
13:19:37 <joelteon> oh, that's cool
13:20:16 <erisco> Eduard_Munteanu, academically researched? I do not know. However, this is something oodles of web frameworks have tried to accomplish, so in an applied sense it has been well researched
13:20:39 <Eduard_Munteanu> Not necessarily academic, no.
13:22:25 <Eduard_Munteanu> erisco: what exactly is the issue? AFAICT, certain schema languages let you define rather specific documents.
13:22:38 <Eduard_Munteanu> erisco: I should note I care less about layout.
13:23:00 <jfeltz> OT: is programming with C++ basically translating recursive solutions into appropriate loop structures?
13:23:33 <jfeltz> that's what going back to that language from Haskell feels like
13:24:25 <jfeltz> mentally i'm arriving to solutions via recursion, and encoding them as loops, it's ffing weird
13:24:30 <erisco> Eduard_Munteanu, as far as selecting the correct input widget, that can be done reasonably well but with some inconvenience. For example, how would you distiguish a password (therefore need a password field) from a normal string (a text field)
13:25:26 <erisco> Eduard_Munteanu, and how do you tell whether you need a text field (one line) or a textarea (multiline)? What if you want three separate input boxes for each portion of a telephone number, but you would prefer to store it just as a string?
13:25:53 <Eduard_Munteanu> I see.
13:26:01 <erisco> there are many possible mismatches between how the data is interpreted internally and how the data is interpreted for a user interface, even without considering layout
13:27:27 <Eduard_Munteanu> I suppose my case isn't the general case, I just want a quick way to whip up an editable tree-like structure, without dealing with presentation at all if possible.
13:28:10 <Eduard_Munteanu> I even considered going through an external XML editor, but they sort of suck.
13:29:22 <erisco> some frameworks have quick fix solutions like you are looking for (and related is scaffolding). however, they have to make numerous assumptions so it only serves practically as a meat and potatoes developer tool
13:30:01 <kazagistar> the constraints on the database really should match the constraints encoded in javascript in the UI, but I am not sure if I have seen a perfect solution yet
13:30:27 <Eduard_Munteanu> Heh, it's not even a database.
13:30:30 <kazagistar> mostly because the sets of constraints on databases tends to be limited and disjoint
13:30:47 <Eduard_Munteanu> I'm trying to provide a minimal usable interface to my code, for non-technical users.
13:30:54 <erisco> kazagistar, the database is not necessarily capable of all the constraints one wants
13:31:13 <Eduard_Munteanu> By interface I mean some way to manipulate configuration.
13:32:32 <Eduard_Munteanu> erisco: thanks, googling for scaffolding seems to provide interesting results
13:36:20 <kazagistar> idea: web-based json editor that uses a json schema to generate a nice UI, allowing automatic generation of hierarchical configuration UIs
13:37:23 <erisco> kazagistar, good luck :)
13:39:05 <Eduard_Munteanu> kazagistar: yes, that's exactly what I was thinking of
13:40:00 <Eduard_Munteanu> kazagistar: however it seems there aren't many free web-based XML/JSON editors that take a schema and don't suck
13:40:21 <aleksejs_> so, you trying to make a system that generates UI from JSON?
13:40:50 <kazagistar> Eduard_Munteanu: I can't find ANY that take a schema
13:41:33 <Eduard_Munteanu> Actually I'm not sure I found any either. :)
13:42:30 <Eduard_Munteanu> aleksejs_: that makes it sound like more than it actually is... I just want a quick way to generate a minimal interface for data entry.
13:43:42 <aleksejs_> I have my own JS FW, that is pretty simple and not very nice, but it generates web UI from JSON, thus I don;t need to write HTML
13:44:10 <erisco> having the schema is useful, but I warn that if you have any intention of controlling the layout, a one-fits-all generator will let you down
13:44:11 <kazagistar> Eduard_Munteanu: well, I have been thinking about it for a while, but… it not going to poof into existence in the very near future
13:45:14 <kazagistar> erisco: something like this ( http://marianoguerra.github.io/json.human.js/ ) , but editable in a way restricted by a schema, seems reasonable though
13:46:42 <erisco> indeed something like that. having a well-defined schema format is useful, but if you care about the layout you'll want to tweak the schema -> HTML generation
13:46:56 <erisco> ie you'll want to define your own
13:47:20 <aleksejs_> here's an example https://github.com/ivanovsaleksejs/haskell-blog/blob/master/static/templates/post.js , and the advantage is that this object will become DOM node and you will be able to refer to it if you need
13:51:53 <Guest11940> This seems like a simple question, but I can't find the answer....  Does cabal have a Haskell API to compile packages?  I want to compile and get results (ie- success or list of errors) all in Haskell data structures.
13:54:30 <pavonia> Guest11940: Like that http://hackage.haskell.org/package/Cabal ?
13:54:55 <Guest11940> pavonia- I shall look, one sec
13:55:34 <kazagistar> erisco: I mean, I would write it under a free licence, so the layout tweaking can always be done the hard way? And if it just returns HTML, you can do a lot with stylesheets…
13:57:52 <Guest11940> pavonia- It looks like Distribution.Simple.Build.build might do what I am looking for....
13:58:02 <erisco> yes you can do a lot with stylesheets. however, you cannot do everything (imagine trying to struggle with floats and positioning) and usually you do not want to have to do a lot (ie instead of absurd hacks it would be preferable to have more conducive markup)
13:58:06 <Guest11940> pavonia- thanks
13:58:19 <pavonia> no problem
13:59:49 <erisco> kazagistar, you could also do document transforms
14:03:54 <bennofs> Is there a free monad without the pure case?
14:04:07 <bennofs> That would be a free apply, right?
14:05:40 <johnw> that's just Fix, isn't it?
14:05:58 <johnw> which is a functor, but I don't think it's applicative
14:06:16 <jrmithdobbs> bennofs: http://hackage.haskell.org/package/free-4.5/docs/Control-Applicative-Free.html ?
14:06:47 <bennofs> johnw: Yeah, but is Fix maybe an instance of `Bind` ?
14:08:14 <bennofs> johnw: btw, is there a package providing the Fix type?
14:08:55 <`^_^v> <erisco> yes you can do a lot with stylesheets. however, you cannot do everything
14:09:03 <`^_^v> well, css is turing complete i think ;p
14:10:32 <johnw> bennofs: nothing lightweight
14:10:43 <bennofs> johnw: what's a non-lightweight package?
14:11:18 <jrmithdobbs> what does this actually mean? https://github.com/fpco/gitlib/issues/25
14:11:32 <bennofs> I'm already using a couple of non-lightweight packages, maybe it's in one of them?
14:11:39 <johnw> I was thinking about compdata
14:11:48 <johnw> but I can't find it in there, since it uses Free, not Fix
14:12:05 <johnw> (aka Mu)
14:12:16 <johnw> jrmithdobbs: good question
14:12:26 <jrmithdobbs> johnw: full of 'em ;p
14:12:36 <johnw> try enabling that extension in the .cabal file?
14:13:10 <johnw> bennofs: http://hackage.haskell.org/package/category-extras-0.53.5/docs/Control-Functor-Fix.html
14:13:12 <johnw> there it is
14:13:24 <johnw> that package is deprecated, so I don't know where edwardk has moved it to
14:13:27 <bennofs> I also found data-fix
14:13:35 <jrmithdobbs> it's in khan-extensions now iirc
14:13:46 <johnw> data-fix is nice and leightweight
14:14:00 <johnw> doesn't provide a functor instance though...
14:14:19 <johnw> oh, I see, it mentions it in the docs
14:14:25 <johnw> nice
14:14:57 <hpc> jrmithdobbs: KAAAAAAAN!
14:17:25 <jrmithdobbs> johnw: after i double checked there weren't 20 other things ihad to change to do so, it does *build* with that extension enabled, not sure if it's working though
14:18:07 <johnw> try the tests?
14:18:26 <johnw> you'll need to build gitlib-test, and then a backend, like gitlib-cmdline, and then run the tests in gitlib-cmdline
14:18:45 <jrmithdobbs> johnw: ya libgit2 backend is still building atm
14:20:40 <burbul> I've just written some breadth first search code, and although it works I feel like it could be cleaner and/or much more idiomatic.  It's at http://lpaste.net/100156 -- I'd be very grateful for any comments. (NB. I'm not asking about things like camelCase -- more about architectural issues.)
14:23:55 <Eduard_Munteanu> burbul: what is a layer?
14:24:21 <cmears> nodes with the same distance from the source are in the same "layer"
14:25:13 <cmears> so the direct neighbours of the source are in layer 1, their neighbours are in layer 2 (unless they were already in layer 1), etc.
14:25:48 <Eduard_Munteanu> Oh same distance as degrees of separation, not some weights.
14:26:25 <jrmithdobbs> johnw: tests at least on libgit-gitlib2 backend appear to pass ... still don't know what that extension is or why it's needed there though
14:26:41 <johnw> yeah, I guess when i start using 7.8 I'll have to figure it out
14:26:47 <dagle> In gtk, is there some event like linkActivated, that I can hook when a link is clicked.
14:26:59 <burbul> as cmears says
14:27:00 <johnw> until then, I guess we need a guarded inclusion of that extension
14:27:48 <burbul> I think of BFS in a very procedural fashion, so expressing it directly in Haskell took a lot of thinking
14:28:01 <burbul> And I'm just not very happy with the result
14:28:07 <jrmithdobbs> johnw: haha, i didn't even realize that was your code until just now. updated the issue for you however you want to handle it, just enabling the extension does *seem* to work though. :)
14:28:22 <johnw> ok, thanks for letting me know!
14:28:48 <Eduard_Munteanu> burbul: generally you get BFS from DFS by swapping the stack (list) with a queue, basically
14:29:13 <cmears> burbul, you might like to compare yours with the BFS in the fgl library
14:29:28 <cmears> (which basically just keeps a queue of nodes, like Eduard_Munteanu says)
14:29:37 <burbul> I think -- but am not sure -- the layering makes it a bit more complex than the DFS case.
14:29:53 <Eduard_Munteanu> Seq is a reasonable queue, btw.
14:30:09 <cmears> The fgl one doesn't explicitly do the layering, but it is easy to reconstruct after the fact because you get a list of nodes ordered by distance
14:30:30 <cmears> So you can just record the distance as you go along, then call groupBy to get the layers
14:30:37 <Eduard_Munteanu> And DFS is easiest, you just recurse naturally.
14:31:02 <cmears> Oh, and fgl does have a version on bfs that does the layers (:
14:31:12 <burbul> I did look up 'bfs' before embarking on this, but there were so many fns defined in terms of other fns that I couldn't easily tell what the actual core of the algorithm was
14:31:33 <jrmithdobbs> burbul: academic papers/definitions are fun =/
14:31:51 <mm_freak> newer OpenGL versions should not export the GLU module by default
14:32:10 <Eduard_Munteanu> burbul: lower level languages tend to avoid straightforward recursion, which may complicate things.
14:32:16 <cmears> burbul, the key to understanding the fgl algorithms is that they deconstruct the graph as they go along
14:32:38 <cmears> So when it takes the node from the start of the queue it actually removes it from the graph as well
14:33:01 <burbul> Also I wasn't keen on using Ints to store distance and then reconstructing layers -- that seemed inaesthetic.
14:34:08 <burbul> Also Data.Graph.Inductive.Graph requires your nodes to be pre-labeled with Ints,
14:34:12 <exicer_> How can I specifically not import something from prelude ?
14:34:25 <burbul> exicer: import Prelud ehiding (???), I think
14:34:37 <burbul> I.e. make the import explicit
14:34:43 <burbul> Data.Graph.Inductive.Graph requires your nodes to be pre-labeled with Ints,
14:35:03 <burbul> whereas I'm dealing with an infinite graph that is generated on-the-fly during the BFS
14:35:26 <burbul> "lower level languages tend to avoid straightforward recursion" -- didn't understand this
14:35:39 <burbul> Are you referring to C, python, etc. ?
14:36:03 <kgadek> my google-fu failed me, but this should be trivial — is there any package for using notification center in OS X ?
14:36:15 <Eduard_Munteanu> burbul: more like C
14:37:15 <no-n> isn't recursion kinda dangerous in C
14:37:28 <Eduard_Munteanu> burbul: you could make your BFS function accept a list of continuations to feed nodes of each level to
14:37:37 <burbul> I think that what's bothering me here is that a procedural C++ implementation of this algorithm feels more perspicuous than the Haskell one. Normally I find the complete opposite. So I feel like I'm not using Haskell properly.
14:37:46 <geekosaur> kgadek: I don't know of one offhand. you'd probably need an interface to objective c and apple events
14:38:14 <burbul> Eduard_Munteanu: how would that help? (not being sarcastic, genuine q.)
14:38:36 <burbul> What I was trying to get at with the original q. was things like
14:38:58 <burbul> -- should I be using monads to wrap up the (index, nID) state
14:39:50 <burbul> -- should I have a sister fn to visit that doesn't have a 'n' argument, to be called when starting on a layer
14:40:07 <burbul> (that would get rid of the ugly '(d@(n',_):ds') = reverse ds')
14:40:29 <burbul> (at the cost of adding two mutually reursive fns, making comprehension harder)
14:40:31 <burbul> etc.
14:40:42 <kgadek> geekosaur: …or use createProcess + https://github.com/alloy/terminal-notifier although I'll suffer using ruby.
14:40:43 <kgadek> thanks
14:40:48 <Eduard_Munteanu> burbul: er, do you want to track the level number after all?
14:40:52 <burbul> no
14:41:09 <burbul> sorry, did I say somehtign that implied that?
14:41:25 <burbul> the level number is implicit in the type of the output, namely [Layer]
14:41:30 <Eduard_Munteanu> burbul: BFS would normally provide a list of nodes as output, no levels
14:41:40 <burbul> right, here I explicitly want the levels
14:42:00 <Eduard_Munteanu> burbul: but you want the bfs to be generic?
14:42:03 <burbul> that's why I called the fn stratify rather than bfs
14:42:20 <burbul> no, I don't need it to be more generic than it is
14:42:31 <burbul> the specification is right; it's the implementation that feels ugly
14:42:42 <Eduard_Munteanu> burbul: then I don't understand why you worry about tracking the level :)
14:43:11 <burbul> what did I say that implies I worry about tracking the level?
14:43:42 <Eduard_Munteanu> burbul: the thing about Int
14:44:23 <burbul> "I wasn't keen on using Ints to store distance and then reconstructing layers -- that seemed inaesthetic."?
14:44:31 <Eduard_Munteanu> burbul: yeah
14:44:46 <burbul> storing a bunch of ints which you then throw away felt v. ugly, that's all.
14:46:30 <Eduard_Munteanu> burbul: oh... so you want the layers, but not numbered; instead, you just want a list of lists?
14:46:45 <burbul> if you can compute [[a,b,c],[d,e,f]] directly, why compute it via [(a,0),(b,0),(c,0),(d,1),(e,1),(f,1)] ?
14:47:03 <burbul> yes, that's what the fn is doing
14:47:22 <burbul> a Layer is basically a list like [a,b,c] in the ex. just given
14:47:43 <burbul> although importantly it stores edges out from nodes in that layer as well as the nodes themselves
14:48:49 <burbul> [The numbering of nodes is done by the stratify code, so edges need to be explicitly output as (Int, Int) pairs]
14:51:50 <Eduard_Munteanu> burbul: you could use Writer for that
14:52:42 <burbul> yes, I was also wondering whether I should use Writer for the output -- although then the fn would return something like Writer w (), which feels a bit odd
14:53:16 <Eduard_Munteanu> burbul: it's common to wrap Writer in an execWriter and not expose it at all
14:53:20 <burbul> One major underlying q. I'm finding it hard to get a grip on is: when _should_ one use monads?
14:53:26 <burbul> I know how to use it both ways, but
14:53:47 <burbul> I don't know which is stylistically preferable.
14:53:57 <johnw> Monads let you operate on values within a context, while leaving the bookkeeping for that context up to that particular monad
14:54:18 <burbul> It's also much harder to find an answer to that q. than to learn about what constructs actually do.
14:54:22 <burbul> johnw: i know.
14:54:45 <burbul> I can rewire that code to use State, Writer, or both.
14:55:05 <burbul> What I can't gauge is what's _cleanest_.
14:55:10 <Eduard_Munteanu> State is probably too much.
14:55:14 <johnw> if you only have the one function, Writer is probably too much
14:55:23 <johnw> Writer is great when you have multiple function that all need to share the same Writer context
14:55:38 <johnw> you can always haev your functino be: foo = runWriter $ ...
14:55:48 <johnw> then you get to use Writer, but not expose the type to the caller
14:55:57 <Eduard_Munteanu> burbul: cleanest is probably writing a breadth-first fold/traversal, then using that to get your function
14:56:12 <edwardk> johnw: recursion-schemes
14:56:14 <burbul> Hmmm... that sounds interesting. Thank you -- I will think about that.
14:56:22 <johnw> edwardk: thanks!
14:56:34 <johnw> yep, there it is
14:56:37 <Eduard_Munteanu> burbul: which is somewhat like the earlier continuation I was proposing.
14:57:07 <burbul> Could you by any chance jot down a rough type signature, so I have something to work form when I come back to this?
14:57:28 <vvvroom> is there a commonly used operator for `flip fmap`?
14:57:39 <burbul> Oh, one last q:
14:57:40 <lispy> :t flip fmap
14:57:41 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:57:47 <lispy> :t (>>=)
14:57:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:57:50 <lispy> :t join
14:57:51 <lambdabot> Monad m => m (m a) -> m a
14:57:54 <burbul> in the clause labelled     -- if there are unconsidered neighbours, index and add to 'unvisited descendants' the fresh ones
14:58:03 <Eduard_Munteanu> @hoogle (<$$>)
14:58:05 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
14:58:05 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
14:58:09 <burbul> I use recursion to iterate through all the neighbours of a node
14:58:25 <vvvroom> i.e. so you write: getLine --> words --> map read
14:59:10 <bennofs> vvvroom: lens has <&>
14:59:49 <burbul> The fact that I'm recursing on visit, rather than recursing on an inner fn, feels wrong to me -- but I don't know whether this is because I'm from a procedural background?
15:00:52 <jmob> What's the twitter length purpose of the lens library?
15:01:13 <vvvroom> ok - that looks like it -- thanks!
15:02:07 <edwardk> jmob: to et you get more done in twitter length code
15:02:12 <edwardk> jmob: er let
15:02:35 <edwardk> jmob: 'jquery for haskell data types' is another pithy way to say it
15:02:48 <jmob> edwardk, reading about lenses, it looks like OO-ish syntax for Haskell
15:03:04 <djahandarie> To let you get more done in Twitter length code, unlike every other library.
15:03:07 <edwardk> jmob: that is sort of the entry point, but they go a LOT deeper
15:03:16 <jmob> edwardk, ah, interesting way to put it
15:03:28 <djahandarie> It's lenses all the way down!
15:04:08 <edwardk> > [(1,2),(3,4)] & traverse.both +~ 1
15:04:11 <lambdabot>  [(2,3),(4,5)]
15:04:30 <edwardk> notice that that actually 'hit' multiple targets in the object
15:04:42 <edwardk> as an example of something where it extends what you are used to
15:05:08 <edwardk> > [(1,2),(3,4)] & traverse._1 +~ 1
15:05:10 <lambdabot>  [(2,2),(4,4)]
15:05:18 <edwardk> and there how it is more selective
15:05:25 <milfjord> awful examples, though
15:05:35 <milfjord> they don't show what's going on unless you already know
15:05:37 <erisco> > [(1,2),(3,4)] & traverse._3 +~ 1
15:05:37 <edwardk> milfjord: pick something nicer. i'm constrained for time
15:05:38 <lambdabot>  No instance for (Control.Lens.Tuple.Field3 (t0, t1) b0 b1 b1)
15:05:38 <lambdabot>    arising from a use of `e_1123431'
15:05:38 <lambdabot>  Possible fix:
15:05:38 <lambdabot>    add an instance declaration for
15:05:38 <lambdabot>    (Control.Lens.Tuple.Field3 (t0, t1) b0 b1 b1)No instance for (GHC.Show.Sho...
15:05:46 <edwardk> gotta run
15:05:57 <jmob> edwardk, thanks
15:06:01 <milfjord> > [(1,2),(3,4)] & traverse.both *~ 2
15:06:02 <lambdabot>  [(2,4),(6,8)]
15:06:08 <luite> yeah jquery is a good analogy, that's why i hope a jquery thing for ghcjs will just be plain ahskell data that can be manipulated with lens, and some mapping to actual nodes :)
15:06:17 <luite> dom nodes that is
15:06:19 <burbul> :t (+~)
15:06:21 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
15:06:52 <exicer_> is ghcijs looking like it will actually be useable ?
15:06:57 <jmob> milfjord, I didn't understand the explanation of how lenses work anyway
15:07:29 <kadoban> is there some way to get ghc to use more memory/swap? i have a huge swap available, if nothing else, but i'm getting 'out of memory' when i run this program, it seems to only be using 3 gigs or so
15:07:48 <milfjord> kadoban: maybe you're running out of address space
15:07:54 <jmob> kadoban, could be from memory fragmentation
15:08:11 <geekosaur> 3 gigs, are you using a 32-bit ghc?
15:08:14 <erisco> kadoban, ghc --help look at the -H flag
15:08:17 <luite> exicer_: yes, in a few weeks when ghc 7.8 is out
15:08:20 <kadoban> oh...shit, yeah this is on 32 bit :/ bah
15:08:27 <luite> exicer_: it can compile most packages from hackage correctly
15:08:33 <edwardk> jmob: basically they use a fancy way to get a sort of implicit subtyping relationship between the different lens-like constructions. this lets you use every isomorphism _as_ a lens, every lens _as_ a traversal, and when you compose them you get the least upper bound of functionality. the nice thing about this is you aren't constantly mucking around with conversion operators.
15:08:50 <luite> exicer_: generated code is a bi big, but modern browsers can handle it decently (and more improvments on that front on the way too)
15:09:06 <edwardk> jmob: the combinators are designed to work with rater excessively general types, which makes it so you can learn how to use something on one of them, and transfer the knowledge to others
15:09:11 <luite> exicer_: main focus is getting most haskell work correctly in the first release :)
15:09:25 <monochrom> haha, 3GB for GHC. normally I only hear "how to tell GHC to use less", not "more" :)
15:09:33 <edwardk> jmob: it is mostly about taking what you already know how to write in haskell and making it more compositional. separating vocabularies for 'what to do' from 'what to do it to'
15:09:50 <luite> exicer_: where most = almost everything, unless you do system-specific things, or fancy stuff with pointers
15:10:16 <monochrom> are you, like, asking GHC to type-check 1000-tuples and 2000-ary functions? :)
15:10:28 <luite> exicer_: Int, Word, 32 and 64 bit, Integer etc, are all supported, running haskell examples with ghcjs should almost always give the same result as with ghc
15:10:30 <exicer_> luite: How does it work regarding interfacing with the dom ?
15:10:33 <edwardk> jmob: 'traverse._1' in the code above is saying you want to go through every element of the list, and into the first half of each as a pair.    +~ 1   is saying you want to add 1 to whatever the targets of the lens-like thing are
15:10:35 <bennofs> monochrom: Doesn't ghc only have tuples up to 64?
15:10:39 <kadoban> ugh, i wonder if i can just run a livecd to run this prog or something...seems to hard to get the memory consumption down
15:11:08 <monochrom> I'm just joking! please don't correct my jokes
15:11:41 <edwardk> the 'object oriented field accessor' use of lens is just more or less two of those 'what to do' combinators, there are a few hundred others
15:11:43 <luite> exicer_: there are multiple options, a low level ghcjs-jquery binding, the ghcjs-dom package that replicates the whole DOM API in haskell, with types (generated from the webkit idl api specification), and you can use the "foreign import javascript" ffi where you can just insert snippets of js code in your haskell
15:11:52 <erisco> edwardk, what is the more general function for applying an operation? ie +~ is to add something... what is the "do something" operator?
15:11:53 <Eduard_Munteanu> burbul: I think you probably want to make a 1-layer BFS... you take a bunch of nodes in the same layer and produce the next layer.
15:12:01 <edwardk> erisco: %~
15:12:14 <edwardk> erisco: if you need help remembering, % in c is for 'mod' so thats mod-equals.
15:12:16 <luite> exicer_: but since it's quite new, there is not really a fully fleshed otu lib, or best practices of any kind :)
15:12:20 <exicer_> luite: If I no longer had to write js I would be so happy
15:12:26 <erisco> :t (%~)
15:12:27 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:12:46 <edwardk> erisco: if you want to apply an action with actual side-effects in a monad or applicative you can just pass it to the lens!
15:13:06 <Eduard_Munteanu> burbul: with that, you start with the root, then get the first layer, then the second etc, each with a single invocation of that function.
15:13:21 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t   -- pass it your a -> f b  action, and the container
15:13:26 <Eduard_Munteanu> And you collect the results in a list.
15:13:47 <jmob> edwardk, that makes sense
15:13:48 <AlainODea> exicer_: you need to talk to doge_js about how very dynamic, such callbacks, wow JS is though ;)
15:13:50 <edwardk> > _1 (\x -> Just x) ("hello","erisco")
15:13:51 <lambdabot>  Just ("hello","erisco")
15:14:00 <edwardk> > _1 (\x -> Nothing) ("hello","erisco")
15:14:01 <lambdabot>  Nothing
15:14:09 <Eduard_Munteanu> burbul: does it make sense?
15:14:15 <edwardk> > _1 id ("hello","erisco")
15:14:15 <luite> exicer_: oh it also works on the terminal, programs run with node.js. for example someone wrote a z-machine interpreter (for zork), and i compiled it with ghcjs last week. terminal IO just works if you run the js file with node.js, and of course it works on every platform with node. easiest cross-compiler ever!
15:14:16 <lambdabot>  [('h',"erisco"),('e',"erisco"),('l',"erisco"),('l',"erisco"),('o',"erisco")]
15:14:56 <edwardk> the latter is taking String -> [Char] -- so its replacing the string with each char in it, and giving you back the list of results after you glued the context back on
15:15:16 <erisco> confusing
15:15:24 <edwardk> erisco: not the easiest example to follow
15:15:39 <edwardk> but you' get the same thing if you used 'sequence' on a container
15:16:59 <carter> luite: so we can boostrap cabal install with a node cabal.js now?
15:17:33 <no-n> @src (++)
15:17:33 <lambdabot> []     ++ ys = ys
15:17:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:17:33 <lambdabot> -- OR
15:17:33 <lambdabot> xs ++ ys = foldr (:) ys xs
15:18:22 <Scorchin> Hello! I'm fairly new to Haskell so I'd appreciate anything you have to say about how I can improve this very small implementation
15:18:25 <Scorchin> https://www.irccloud.com/pastebin/slXSvWey
15:19:14 <jmob> edwardk, I'm not well versed enough in Haskell to understand what it improves though, why aren't other haskell facilities enough?  E.g. "how to do it" would just be a type generalized function, typeclasses would specify "what to do it to".
15:19:31 <monochrom> Scorchin: it looks pretty nice to me
15:19:40 <erisco> edwardk, I have not met a single person who has first looked at lens and said "ah, just what I need! how intuitive", but I do see the general idea of what it is after. What work is being done to improve the simplicity?
15:19:44 <Rembane> Scorchin: Add Ord to Rank.
15:19:44 <carter> luite: or does someone  still need to write a process / shell binding?
15:19:53 <Scorchin> monochrom: Thanks :-)
15:20:22 <monochrom> I have met some persons who said that
15:20:42 <bennofs> erisco: lens-family(-core) is a package that uses the same underlying abstraction as lens, but without so much typeclasses so it's simpler if you're just starting. You can still switch to lens later
15:22:01 <Scorchin> Rembane: I get why you're saying that, but I want to build on this to create orderings based on different card games. Will that still apply?
15:24:02 <Rembane> Scorchin: Ah, no. Not generally. :)
15:24:11 <Eduard_Munteanu> Bounded might be nice, so you could just say [minBound..maxBound].
15:24:29 <bennofs> Also, why is Ace the lowest card?
15:24:30 <mgsloan> erisco: When I first saw it, it was pretty intuitive and clearly addressed itches I'd had.  Then again, that was in the early days of lens, and I'd used fc-labels a fair amount and had felt the pain of klunky composition with isos / lack of handling failure
15:24:48 <Eduard_Munteanu> bennofs: it's the case for quite a few card games
15:25:03 <bennofs> Eduard_Munteanu: ah, not the card games I play :D
15:25:05 <Eduard_Munteanu> Also 11 sometimes.
15:25:21 <erisco> mgsloan, oh, well hello then :)
15:25:54 <Eduard_Munteanu> For Blackjack it's both 1 and 11, also Solitaire has it as 1.
15:26:40 <erisco> or 14
15:27:28 <erisco> and what about games with jokers?
15:27:47 <erisco> or wildcards? tricky stuff :)
15:30:32 <burbul> Eduard_Munteanu: yes, I considered that (specifically I considered unfoldr), but this is exactly the kind of thing where I wasn't sure whether it was idiomatic or not. . Anyway, thank you very much for the extensive advice -- it was very kind of you!
15:33:19 <burbul> (FWIW, the reason that it was a bit tricky was that one had to number the nodes in layer n+1 in order to describe the edges associated with layer n. And once you had done that, needed to store the nodes in layer n+1 somewhere so the next iteration didn't have to recompute them.)
15:36:45 <Eduard_Munteanu> burbul: why not do that separately?
15:37:46 <Eduard_Munteanu> burbul: the outward edges of a layer should be the union of outward edges sets of its nodes.
15:41:57 <Eduard_Munteanu> What library should I use as a https client?
15:44:32 <mm_freak> Eduard_Munteanu: http-conduit, or you could get more experimental and try pipes-http
15:45:27 <Eduard_Munteanu> Thanks.
15:46:22 <mm_freak> Eduard_Munteanu: if you need session support, there is also http-conduit-browser
15:46:38 <mm_freak> it handles stuff like cookies
15:53:15 <burbul> Eduard_Munteanu: it had to do with how I defined Layers.  The natural stratified structure of a graph is as
15:53:28 <burbul> [N], [E], [N], [E], [N], [E], [N], ...
15:53:33 <burbul> And I chose to bracket as
15:53:51 <burbul> ([N], [E]), ([N], [E]), ([N], [E]), ...
15:53:59 <burbul> So that I didn't have a strange layer at the start
15:54:08 <burbul> If instead I had bracketed as
15:54:22 <burbul>  [N], ([E], [N],) ([E], [N],) ([E], [N],) ...
15:54:43 <burbul> I could have done what you suggest, but the 'edge' information  in the first layer would have been rather ugly
16:01:33 <japesinator> so, I'm trying to write a type system for the scheme I'm writing in Haskell
16:01:50 <jophish> What column limit is most prevalent in haskell? From what I've seen it's 80
16:02:14 <japesinator> there's a LispNumber type that can be either a Complex Double, Double, Ratio Integer, or Integer
16:02:39 <hpc> jophish: i just go by whatever my current terminal resolution is
16:02:42 <hpc> if it fits, i commits
16:02:47 <japesinator> and I'm trying to define a function that takes a function that takes two numbers and returns a third and two numbers and returns a third
16:03:22 <jophish> hpc: My screen is 139 columns wide, 3 short of having 80|80|80 splits
16:03:32 <japesinator> essentially :t lispMath == (Num a) => (a -> a -> a) -> LispNum -> LispNum -> LispNum
16:03:40 <monochrom> the average column limit is 82.19385
16:03:57 <monochrom> the average indentation is 3.1416
16:03:57 <japesinator> but the problem is I can only have it defined for one type of LispNum before it starts throwing errors
16:04:36 <japesinator> Is the best option here to just write a whole instance of Num for LispNum?
16:05:29 <jophish> monochrom: cool, any more stats?
16:05:37 <monochrom> no
16:05:56 <thebnq> indentation is suspiciously close to pi
16:06:00 <Eduard_Munteanu> japesinator: how would you apply a Float -> Float -> Float to that? Or some other type.
16:07:19 <japesinator> Edward_Munt:  I have LispMath func (Float a) (Float b) = Float (func a b)
16:07:24 <monochrom> yes, the average haskell project is maintained by 1.941 persons
16:07:51 <kristof> quality
16:08:16 <kristof> That was slightly derisive. I just think it's disappointing that the majority of FOSS projects are maintained by one or two people.
16:08:26 <Eduard_Munteanu> japesinator: it looks like your FloatNum doesn't have a constructor wrapping floats
16:08:33 <kristof> I've always been surprised by how well GNOME is organized compared to FOSS in general
16:09:40 <japesinator> Eduard_Munteanu: Can you clarify that?
16:10:19 <Eduard_Munteanu> japesinator: I mean you don't seem to be able to handle types that are arbitrary Num instances
16:10:57 <japesinator> how can I do that?
16:12:30 <Eduard_Munteanu> japesinator: well, do you have to?
16:13:18 <Twey> 225058 <monochrom> the average column limit is 82.19385  —  IOW we're all carefully adhering to the 80-columns standard, apart from one rebel who's written a package with 500-character lines
16:14:06 <Eduard_Munteanu> I adhere to 80-columns on principle as well.
16:14:06 <monochrom> the average type class has 3.89 methods and 2.44 laws. the average GHC version implements 22.43 extensions
16:14:16 <hpc> or it means everyone almost-adheres to the standard
16:14:22 <Twey> monochrom: How do you recognize a law?
16:14:26 <japesinator> https://gist.github.com/japesinator/9104335
16:14:31 <monochrom> I myself have bumped to 90 columns
16:14:34 <japesinator> ^^ That's the problem code
16:14:45 <monochrom> fractional number of laws is part of the joke :)
16:14:55 <Eduard_Munteanu> If going above is too complex for low-level languages, it probably is for Haskell too.
16:15:00 * monochrom loves fractions. they are so fractional.
16:15:07 <Twey> japesinator: This doesn't look much like a type system :þ
16:15:51 <japesinator> Twey:  That's only part of what I have, but you're right that it might be something else
16:16:06 <japesinator> my categroy theory is lacking, and by lacking I mean nonexistent
16:16:17 <japesinator> s/categroy/category
16:16:40 <Twey> Type theory is not category theory
16:16:43 <Eduard_Munteanu> japesinator: you can't really expect to handle Bar -> Bar -> Bar if the target language only talks about Foo
16:17:15 <Eduard_Munteanu> japesinator: what do you do for other instances of Num?
16:17:23 <japesinator> Twey:  I'm pretty bad at both.  For future reference, is there a better name for that?
16:17:44 <japesinator> 'that' being the code
16:17:45 <mm_freak> s/s\/categroy\/category/s\/categroy\/category\//
16:17:50 <mm_freak> SCNR =)
16:18:28 * Eduard_Munteanu kicks type theory in the categroyn
16:18:43 <Iceland_jack> Such a violent channel.. :)
16:18:47 <japesinator> Eduard_Munteanu: I'm still not quite understanding what you're saying.  What kind of other instances are referring to?
16:18:56 <Eduard_Munteanu> @instances Num
16:18:57 <lambdabot> Double, Float, Int, Integer
16:19:22 <Eduard_Munteanu> japesinator: well, it's a typeclass, anyone can add an instance at any point even if you handle them all
16:19:39 <Eduard_Munteanu> japesinator: another example... Word8
16:19:45 <Twey> japesinator: So, func has type a → a → a, for some a chosen by the caller.  But, you've used it in a way that means the a can only ever be Double (for example).
16:19:54 <japesinator> As of right now, I had just been using Doubles to handle Floats and Integers to handle Int
16:20:04 <Eduard_Munteanu> :t (+) :: Word8 -> Word8 -> Word8
16:20:05 <lambdabot> Word8 -> Word8 -> Word8
16:20:18 <Eduard_Munteanu> @instances-importing Num
16:20:18 <lambdabot> Double, Float, Int, Integer
16:20:35 <japesinator> Twey:  That makes a lot of sense in context of the error messages I had been getting
16:20:36 <Twey> japesinator: The errors you're seeing are GHC trying to find a single instantiation of ‘a’ that's consistent with all the ways you've used it — as a Double, as a Complex Double, as an Integer, and as a Ratio Integer
16:20:45 <japesinator> Oh, OK
16:20:59 <Eduard_Munteanu> japesinator: you can't really handle arbitrary conversions from/to Double using Num alone
16:21:04 <Twey> If it succeeded, it would then instead complain about not being able to match that with *any arbitrary* a, which is what you promise in the type signature
16:21:36 <Eduard_Munteanu> :t fromInteger -- is all Num gives you
16:21:36 <lambdabot> Num a => Integer -> a
16:21:59 <Eduard_Munteanu> :t fromRational
16:22:00 <lambdabot> Fractional a => Rational -> a
16:22:05 <Twey> Now, what you *meant* to write is (∀ a. Num a ⇒ a → a → a), i.e. ‘a function a → a → a that will work for any Num a that I choose’
16:22:24 <japesinator> Twey: Yeah, that's what I was trying for
16:22:37 <japesinator> Is there a way of implementing that?
16:23:03 <Twey> japesinator: Yes, you can enable Rank2Types
16:23:06 <Eduard_Munteanu> japesinator: forall a. Num a => a -> a -> a   :)
16:25:36 <Twey> japesinator: FYI the type ‘Ratio Integer’ has a synonym ‘Rational’ that's in the Prelude
16:25:45 <japesinator> Eduard_Munteanu: Now it's telling me "Illegal constraint: forall a (Num a)"
16:25:57 <Twey> japesinator: You wrote it wrong
16:26:50 <Twey> japesinator: http://ideone.com/9cmc5E
16:27:22 <Twey> japesinator: Sounds like you forgot the dot
16:27:32 <Eduard_Munteanu> japesinator: alternatively you can make a 'LispNum a' newtype and make an instance (Num a) => LispNum a. Depends on your goals though.
16:27:43 <Eduard_Munteanu> Er.
16:27:47 <subleq> Go
16:27:54 <Eduard_Munteanu> instance (Num a) => Num (LispNum a)
16:28:25 <Twey> If you're going that way you should use a GADT
16:28:51 <erisco> jle`, any luck?
16:28:59 <Eduard_Munteanu> I wonder why LispNum needs to handle different types in the first place.
16:28:59 <japesinator> what is a GADT?
16:29:40 <Eduard_Munteanu> I can only think of floating point vs integral numbers.
16:29:59 <Eduard_Munteanu> But not sure how they do it in Lisp.
16:30:06 <japesinator> I was trying to be R5RS compliant, and they specify a 'tower' of numbers
16:30:29 <Twey> japesinator: A GADT is a Generalized Algebraic Data Type, a variant on the usual data … syntax that lets you specify a parameter to the type according to which constructor was used
16:31:15 <japesinator> that sounds pretty cool
16:31:40 <Twey> japesinator: For example, data LispNum a where Complex ∷ Complex Double → LispNum (Complex Double); Rational ∷ Rational → LispNum Rational; Float ∷ Float → LispNum Float; Integer ∷ Integer → LispNum Integer
16:32:12 <Eduard_Munteanu> Does Scheme/Lisp even distinguish those?
16:32:18 <Twey> Then Integer 3 ∷ LispNum Integer, Integer 5 ∷ LispNum Integer, Rational (3 % 4) ∷ LispNum Rational
16:32:24 <Twey> Eduard_Munteanu: Scheme does
16:33:00 <Eduard_Munteanu> And does it infer types? Or how does it choose doubles over integers?
16:33:08 <Twey> Eduard_Munteanu: http://www.schemers.org/Documents/Standards/R5RS/HTML/
16:33:12 <Peaker> Does anyone know of any semaphore implementation that also allows specifying a priority/precedence for the "wait"s
16:33:18 <Twey> Eduard_Munteanu: The ‘types’ are just runtime tags
16:33:35 <Peaker> I have a bunch of threads, some much more important than others, that all want a piece of the semaphore
16:34:03 <Eduard_Munteanu> Twey: er, I meant to ask how it promotes / converts stuff.
16:34:32 <Eduard_Munteanu> Ah, explicit predicates according to the spec.
16:34:35 <Twey> Eduard_Munteanu: It has conversion functions and the subtype relation you see there
16:35:31 <kristof> I can't remember how R5RS standard numbers compare to the common lisp specification
16:35:31 <japesinator> It works now!  Thanks very much for all the help
16:35:34 <Eduard_Munteanu> I'd define   data LispNum = Complex | Real | Rational | Integer
16:35:40 <kristof> which is why I hesitate with "LispNum"
16:36:10 <kazagistar> Eduard_Munteanu: http://marianoguerra.github.io/json-edit/ check this out, also this thread: http://stackoverflow.com/questions/998832/gui-based-or-web-based-json-editor-that-works-like-property-explorer
16:36:19 <Eduard_Munteanu> Er, let's call that LispNumType.
16:36:33 <Eduard_Munteanu> kazagistar: thanks, I'll have a look
16:36:35 <japesinator> before I had LispNum I had seperate types for Ints, Floats, Complexes, and Rationals, but doing math with those got really ugly
16:39:33 <Eduard_Munteanu> Then you can make  data LispNum :: * -> * -> LispNumType -> * where IsRational :: Ratio i -> LispNum i f 'Rational   or something along those lines.
16:39:34 <Twey> japesinator: When you say you want a type system, do you actually want a type system?  :þ
16:40:05 <Twey> Eduard_Munteanu: That looks a lot like the GADT with extra boilerplate :þ
16:40:28 <Eduard_Munteanu> Because I don't see much reason for lifting arbitrary types into those if you don't need to be flexible in your representation.
16:40:45 <Eduard_Munteanu> Twey: yeah, with a few differences
16:41:35 <Twey> japesinator: If you really want a type system, i.e. tracking types before runtime, you should go with the GADT approach, or Eduard_Munteanu's DataKinds.  If you don't, and only want to check ‘types’ at runtime, you should stick with the forall version.
16:42:15 <Eduard_Munteanu> You still check types at runtime either way, since the subtyping and conversions can't easily be baked into Haskell stuff.
16:42:30 <Eduard_Munteanu> It just affords some type-safety to the interpreter code itself.
16:42:47 <japesinator> I don't have the background in PLT to be able to judge well what to do here
16:42:49 <Eduard_Munteanu> e.g. not conflating the Haskell Integer and Scheme's
16:43:20 <Twey> japesinator: Scheme doesn't have types, so if you want strict R5RS compliance then you need to not track types
16:43:51 <Twey> japesinator: If you're trying to create some sort of typed Scheme, on the other hand, these are ways to do it
16:43:55 <japesinator> I think for now I'm going to stick with the forall because that works and I understand it, but perhaps once I know a bit more I'll come back and change it
16:44:01 <Twey> (by embedding into Haskell)
16:44:08 <japesinator> Twey:  I'm actually just working along with the wikibook right now
16:44:09 <Fuuzetsu> (by not creating a second Typed Racket)
16:44:39 <Eduard_Munteanu> japesinator: you should probably just drop the forall and lift into each constructor separately
16:46:16 <Eduard_Munteanu> japesinator: intBinop :: (Integral a) => (a -> a -> a) -> LispNum -> LispNum -> LispNum
16:46:37 <Eduard_Munteanu> @src Integral
16:46:37 <lambdabot> class  (Real a, Enum a) => Integral a  where
16:46:37 <lambdabot>     quot, rem, div, mod :: a -> a -> a
16:46:37 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
16:46:37 <lambdabot>     toInteger           :: a -> Integer
16:47:56 <japesinator> the forall looks cleaner to me, but that might just be my lack of experience
16:47:58 <Eduard_Munteanu> And another one for Double, which is FP-specific.
16:48:29 <Eduard_Munteanu> japesinator: I think it allows things you wouldn't consider correct
16:48:53 <Eduard_Munteanu> japesinator: besides, it completely makes Double useless
16:49:09 <Eduard_Munteanu> You can't do a proper floating point division.
16:49:21 <Eduard_Munteanu> :t (/)
16:49:22 <lambdabot> Fractional a => a -> a -> a
16:50:15 <japesinator> I was probably going to declare a special instance for lispMath (/) (Double a) (Double b)
16:50:46 <Eduard_Munteanu> japesinator: an instance of what class?
16:51:03 <japesinator> instance is the wrong word
16:51:29 <japesinator> just define lispMath (/) (Double a) (Double b) before lispMath func (Double a) (Double b)
16:51:44 <Twey> japesinator: You can't pattern-match on functions
16:51:45 <Eduard_Munteanu> japesinator: you can't match on functions
16:51:51 <Twey> Haskell has no notion of function equality
16:54:54 <Eduard_Munteanu> japesinator: if you want to define basic number operations, you might want to focus on function rather than the number. More specifically, make it part of your AST (not necessarily syntax-related).
16:57:07 <Eduard_Munteanu> Expression types might be a better word than AST.
16:57:31 <Twey> Except that makes it sound like there are types :þ
16:57:57 <monochrom> expression representation
16:58:17 <Twey> Something like data Operation = Add | Subtract | Multiply | Divide; lispMath ∷ Operation → LispNum → LispNum → LispNum
16:59:09 <Twey> (and enjoy the 64 cases :þ)
17:00:40 <Eduard_Munteanu> Twey, japesinator: more like  data Operation = AddReals Expr Expt | AddIntegers Expr Expr ...
17:01:24 <Eduard_Munteanu> And keep the type casting hidden away.
17:01:40 <Twey> Eduard_Munteanu: You'd need an actual type system to do thhat
17:01:42 <Twey> that**
17:02:13 <Twey> Oh, well, I suppose not, just error when interpreting Operation
17:02:24 <Twey> Still, it doesn't seem like a great idea to bake that into the language
17:02:29 <Eduard_Munteanu> Twey: no, I mean it would compile generic Add operations to AddReals/AddIntegers
17:02:41 <Eduard_Munteanu> Doing the check at runtime, that is.
17:03:21 <Eduard_Munteanu> This way you keep the actual operations monomorphic, and handle conversions somewhere else.
17:04:43 <Twey> Ah, I see
17:06:24 <jle`> erisco: I think there is a pretty strong case that the behavior as I had expected it is not possible without breaking FRP, but your discrete sampling idea was good. I am going to however keep the bad idea for performance sake for now :)
17:24:50 <kadoban> unboxed arrays are magical...took my memory usage from gigs to pretty much negligible
17:26:11 <colDrMcBeardman> speaking of such low-level hackery, i wonder if there is some kind of heuristics by which the compiler could choose to do such things.
17:28:52 <kadoban> is there some trick i could use to peek at the progress in a running program? like i have explicit recusion going on, could i see what the currently-being-evaluated argument is? it's just an int
17:29:42 <joelteon> no
17:29:52 <kadoban> damn
17:31:45 <Twey> kadoban: Maybe, with the GHC API
17:31:57 <colDrMcBeardman> kadoban, maybe ghc-vis would help you?
17:32:39 <joelteon> oh
17:32:40 <joelteon> well, then maybe
17:32:55 <kadoban> sounds pretty cool from the description, i'll check it out
17:33:51 <colDrMcBeardman> it's super amazing.
17:34:21 <kadoban> huh, there's a lot of cool sounding stuff in GHC api too
17:34:26 <kadoban> thanks both
17:34:58 <colDrMcBeardman> ghc-vis scares me when i see what spaghetti the heap is... but then again, i used to live in C-land, so...
17:43:34 <colDrMcBeardman> kadoban, ghc-vis has some magic for debugging in the .ghci script it provides. i think you could use :su to get the stepwise visualization you want
17:44:43 <kadoban> this thing is cool as hell, haha. i forgot what i was actually going to do with it, just watching it work XD. now to actually try...
17:56:43 * hackagebot separated 0.0.7 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.7 (TonyMorris)
18:01:12 --- mode: ChanServ set +o copumpkin
18:01:14 --- mode: copumpkin set -q dbelange!*@*
18:01:17 --- mode: copumpkin set -o copumpkin
18:02:42 <no-n> how do I make ghci run with some given flags every time?
18:02:49 <no-n> ghc too
18:03:58 <verement> set the flags with a command in .ghci?
18:04:15 <no-n> how though
18:04:25 <shergill> is there something similar to yesod devel for recompiling a cabal project on source code change?
18:04:41 <verement> no-n :set <options>
18:04:47 <no-n> ahhh
18:04:48 <no-n> ty
18:06:27 <gridaphobe> hey, i'm trying to install ghci-ng with ghc7.6.3 and cabal-install1.18, and i'm getting a parse error.. it seems that a CPP macro is not being properly expanded. has anyone run into this?
18:06:36 <kazagistar> just to double check, this ( http://lpaste.net/100158 ) will always fully evaluate the Int before storing in in the array, right?
18:07:35 <gridaphobe> i'm on osx so it may well be related to the gcc/clang issues, but i have the ghc-clang-wrapper installed :-/
18:08:33 <no-n> verement: how do I do that for just ghc?
18:08:51 <verement> no-n: what sort of flag is it?
18:09:09 <no-n> I want --make -odir trash -hidir trash -XscopedTypeVariables
18:09:39 <verement> the -X you can do in your source code with {-# LANGUAGE ScopedTypeVariables #-}
18:09:43 <verement> not sure about the others
18:10:05 <no-n> okay
18:10:07 <verement> maybe a Makefile or cabal file would help
18:10:13 <no-n> would that go before "Module Main were"
18:10:23 <jk4930> Are people here interested in Haskell-related GSoC projects?
18:10:24 <verement> yes
18:10:43 <no-n> hmm. would that be GHCFLAGS?
18:11:14 <Twey> no-n: It depends on the flags.  Language extensions have {-# LANGUAGE — #-}; for other options you need to use {-# OPTIONS_GHC — #-}
18:11:20 <Twey> (which is non-portable, obviously)
18:12:51 <no-n> okay
18:26:03 <astropirate> How is it that Go has only 9XX users in channel and haskell has 12XX users and there are a shit ton more Go devs/projects than in Haskell
18:26:10 <astropirate> not to mention adoption
18:26:16 <astropirate> not trying to start flam war, just intersted
18:26:29 <astropirate> as I am interested in both languges and actually use Go in production now
18:26:31 <joelteon> where are you getting that third number?
18:27:01 <astropirate> joelteon, is that to me?
18:27:04 <joelteon> yep
18:27:14 <astropirate> joelteon, buzz
18:27:21 <Fuuzetsu> buzz?
18:27:33 <astropirate> yes tech buzz, people talking about it
18:27:41 <joelteon> i see
18:27:51 <Yaniel> different kinds of people?
18:27:54 <astropirate> i don't have nayhard numbers to back up what i'm saying
18:27:59 <astropirate> just things I hear
18:28:14 <astropirate> Yaniel, yes, some are short, some are tall
18:28:15 <joelteon> does sound like trying to start a flame war, to be honest
18:28:23 <Fuuzetsu> oh, so you just made it up; astropirate, by that logic, Haskell is the most popular language of choice and I'm sure it's not correlated with the fact that I mostly associate myself with Haskellers ;P
18:28:26 <astropirate> joelteon, sorry don't mean that
18:28:40 <joelteon> how many folks are in #java
18:28:46 <Fuuzetsu> after all, all the buzz I hear is about Haskell
18:28:56 <Fuuzetsu> well most
18:29:21 <astropirate> Fuuzetsu, I'm not talking ab nout buzz in #go-nuts, i'm just saying the buzz in the tech news/blogs etc
18:29:34 <joelteon> go is fairly new
18:29:38 <astropirate> joelteon, but common.. eveyrbody and their grandma uses java
18:29:48 <astropirate> or avoids it
18:29:53 <mgsloan> Maybe it's that it's more interesting to talk about Haskell than Go, since Haskell is more interesting?  Not saying that go isn't good stuff, just that it's another go at a common theme
18:29:53 <joelteon> haskell was created in 1990
18:29:53 <Fuuzetsu> astropirate: I don't follow such sites (and IMHO anyone giving Go the time of their day is wasting their time but whatever)
18:30:08 <joelteon> anyway, i don't think it's a good idea to get into this
18:30:12 <joelteon> i'm out
18:30:13 <astropirate> alright
18:30:17 <Fuuzetsu> ;P
18:30:20 <astropirate> me too
18:31:37 <astropirate> So, Idris huu
18:31:39 <astropirate> sound interesting
18:32:32 <Fuuzetsu> Shame about the weak reasons for denying unicode operators &c
18:33:51 <Twey> astropirate: I spent a while trying to figure out what a ‘Nayhard number’ is
18:34:38 <Twey> Idris is pretty cool
18:34:48 <Twey> I still want Epigram 2, though
18:34:56 * astropirate looks it up
18:35:28 <perebor> what is a nayhard number? do i need to add another dimension to by bacon/erdos coordinate?
18:36:12 <astropirate> perebor, haha i meant "no hard numbers"
18:36:19 <Twey> perebor: I thought it was more like a Bernoulli number
18:38:14 <kadoban> hah...was wracking my brain to figure out why my algorithm was taking sooo much longer with bigger N...forgot it's O(N^3), not O(N^2)....
18:56:01 <c_wraith> I think I understand data families now!  This is exciting, but to verify I still need to write some code.
19:05:06 <ion> no-n: hFlush
19:05:29 <Twey> c_wraith: Data families are type families that compute to a new data type.  What's the problem?  :þ
19:05:56 <c_wraith> Twey: they're really entirely unlike type families.  They're more like open data types.
19:06:18 <c_wraith> Twey: (except that to add a new set of constructors, it needs to be a new type)
19:06:58 <no-n> ion: thanks
19:07:05 <c_wraith> So somewhere between GADTs (the type limits the set of possible constructors) and open data types.
19:09:49 <vozz> Say I've added a ^{footer} to my default-layout, what do I need to put in my defaultLayout to make it work? I tried footer <- $(widgetFile "partials/footer") but no dice
19:11:24 <Twey> c_wraith: http://lpaste.net/100159
19:11:58 <Twey> c_wraith: It's mostly a combination of a type family and a new data type — *except* that the restriction to a new, otherwise unnamed data type means that data families are injective
19:11:59 <no-n> is this easily translatable to haskell? (from python) try: f() except KeyboardInterrupt: pass
19:12:39 <c_wraith> no-n: assuming you're in a context where "do nothing" means something.
19:13:10 <no-n> yeah
19:13:15 <Twey> no-n: You need to install a signal handler
19:13:24 <no-n> o
19:13:48 <c_wraith> Oh.  Is KeyboardInterrupt ctrl-c?
19:13:53 <no-n> yeah
19:14:13 <c_wraith> Then yeah, you need a signal handler - which is unfortunately not portable between unixes and windows
19:14:18 <m3ga> no-n: was looking at this just recently. https://stackoverflow.com/questions/2349233/catching-control-c-exception-in-ghc-haskell
19:14:20 <no-n> okay
19:15:43 <Twey> no-n: installHandler keyboardSignal (Catch (return ())) Nothing; f; installHandler keyboardSignal Default Nothing
19:15:56 <Twey> A more robust solution might be to define some sort of wrapper function
19:16:57 <Twey> c_wraith: So type families are also ‘open’ in that sense; the injectivity is the only interesting difference
19:17:25 <Twey> (only as open as the parameter allows, of course)
19:17:37 <no-n> ty
19:18:14 <Twey> no-n: Oh, you can replace (Catch (return ())) with Ignore
19:19:45 <Twey> vozz: What's a defaultLayout?  Sounds like you might be better off asking in the channel for whatever software you're using (#yesod? #hakyll? #xmonad?)
19:20:53 <vozz> Twey: yeah sorry, I thought I was in #yesod
19:21:10 <Twey> Ah, right
19:21:16 <ion> Someone should name a web framework “nood”.
19:21:30 <ion> called
19:21:30 <Twey> Why?
19:21:37 <ion> because “yesod”
19:21:43 <no-n> hmm. are signals the same on mac os x?
19:21:44 <Twey> Oh, right.
19:21:45 <Fuuzetsu> I don't get it
19:21:49 <Twey> no-n: Yes
19:21:53 <c_wraith> many people don't realize yesod is actually a word.
19:21:56 <Twey> no-n: But not Windows
19:21:59 <no-n> all right
19:22:15 <Twey> no-n: It'll work on anything POSIX-compliant
19:22:30 <no-n> System.Posix.Signals?
19:22:36 <Twey> (well, some subset of signals will; I think various systems define various extra ones)
19:22:39 <Twey> no-n: Yes
19:22:46 <no-n> cool, thanks, Twey
19:23:08 <Twey> No problem
19:28:25 <Twey> c_wraith: The injectivity comes from the fact that data families have no normal-form name.  If you have the expression TypeQuux True, the compiler normalizes it to TypeFoo, and from then on you have a TypeFoo — there's no way to know that it was generated by ‘TypeQuux True’ (since it's valid to refer to the same type as TypeFoo directly), so there's no way to get the ‘True’ back out.  Whereas with
19:28:25 <Twey> data families there's no way to refer to DataQuux True other than as ‘DataQuux True’: DataQuux True refers to a unique type that can't be accessed any other way, so wherever you see that type you know it must have been generated by the expression ‘DataQuux True’, so you can get the True back out.
19:29:06 <c_wraith> Twey: yes, yes, I understand all this.  The important part is that I understand what they're *for*, now.
19:29:21 <c_wraith> Assuming the code I write actually works, anyway. :)
19:30:01 <Twey> Injective type functions.  :þ
19:31:00 <c_wraith> Indexed data types. :P
19:32:24 <Twey> They're much more useful than that
19:33:17 <c_wraith> But I couldn't even find any other solution for indexed data types, and I'd been wanting them for a while.
19:34:43 <Twey> c_wraith: You mean *open* indexed data-types?  I think closed data families are just GADTs
19:34:55 <c_wraith> Ah, yes.  I do mean *open* indexed data types.
19:34:58 <kazagistar> ugh, I am getting a "Pattern match(es) are overlapped" in my "else" case, where I am just matching _ for everything else… is this expected?
19:35:05 <Twey> Aha
19:35:16 <c_wraith> kazagistar: well, yes, it does overlap.  That's expected.
19:35:29 <cmears> kazagistar, I think you can get that if you already matched all possible cases
19:36:32 <kazagistar> it is in a "where" clause, but I am matching Exception types for catchJust, so it should not be exhaustive yet
19:36:42 <kazagistar> and getting them all is not reasonable
19:39:16 <pavonia> kazagistar: Could you paste that case-expression?
19:42:48 <kazagistar> pavonia: http://lpaste.net/100162
19:44:02 <pavonia> Where is DatumTypeError from?
19:44:40 <kazagistar> pavonia: I defined it, it is an instance of Exception
19:45:06 <pavonia> Is that the only constructor?
19:46:02 <kazagistar> pavonia: yep,  "data DatumTypeError = DatumTypeError String"
19:46:30 <pavonia> Well yeah, so the second branch in never reached
19:48:04 <kazagistar> pavonia: hmm, maybe I am doing this wrong. How do I filter for a specific exception in my catchJust?
19:48:29 <johnw> just make the type match it
19:48:44 <johnw> f `catch` \(e :: DatumTypeError) -> ...
19:49:54 <kazagistar> johnw: will that rethrow the original error on a mismatch, or replace it with a new pattern match error?
19:50:18 <johnw> it doesn't catch mismatches at all, they continue propagating
19:52:04 <no-n> hmm, i must be doing something wrong here http://lpaste.net/6338365293504495616
19:52:14 <u_> in parsec
19:52:26 <Twey> kazagistar: The pattern is ‘e’ — it can't fail
19:52:32 <u_> i want to use chainl1 to parse "a b c" as App (App (Var "a") (Var "b")) (Var "c")
19:52:48 <u_> but the parser for variables jumps the gun and parses "a b c" as just Var "a" instead
19:52:50 <u_> how can i stop this?
19:52:52 <Twey> kazagistar: catch dispatches on the type of the lambda to know what to catch
19:54:08 <pavonia> u_: What does you variable parser look like?
19:54:15 <pavonia> *your
19:54:23 <u_> pavonia: fmap Var (many1 letter)
19:55:05 <jxv> no-n, "void exitSuccess" rather than "exitSuccess >> return ()"
19:55:15 <pavonia> u_: And the complete parser?
19:55:50 <no-n> jxv: is that Control.Monad.void?
19:56:04 <u_> pavonia: http://pastebin.com/BAqAiwMp
19:56:32 <jxv> no-n, yes
19:57:43 <u_> i have to try parsing it as a variable first, so it doesn't go into an infinite loop, but parsing it as a variable always succeeds even if there's more
19:58:20 <aji> #haskell
19:58:24 <no-n> jxv: doesn't fix the problem though :(
19:58:40 <no-n> but better form at least :3
20:04:08 <u_> it seems like everywhere i look i.e. http://stackoverflow.com/questions/18555390/lambda-calculus-grammar-llr
20:04:21 <u_> they get around the problem of telling a single variable "a" from an application "a b" somehow
20:04:45 <Axman6> u_: have you considered lexing first, then parsing?
20:04:47 <u_> but.. oh wait, does that still work?
20:05:05 <u_> Axman6: i guess i could but it seems like overkill in this case
20:05:10 <u_> i know there's a simple way to fix this
20:05:17 <u_> i just forgot what it was
20:06:25 <u_> oh yeah, i can do a modified version of the stackoverflow link
20:06:40 <u_> i've written something like this before where it worked fine
20:06:53 <u_> and looked almost the same as the pasted code
20:21:57 <guesting> Using the Data.Text library, how can I "show" a type? That is, I have an algebraic type with one of the constructors being "Cheese". How can I convert "Cheese" to a Text "Cheese"?
20:22:46 <jfischoff> T.pack . tyConName . fst . splitTyConApp . typeOf
20:23:10 <jfischoff> but there is more learning to be had there
20:23:14 <johnw> or use ppShow from Text.Pretty.Show
20:23:16 <guesting> jfischoff: Isn't T.pack really slow?
20:23:28 <copumpkin> why are you doing that?
20:24:24 <jfischoff> guesting: yes the deeper question is what are you actually trying to do?
20:24:25 <guesting> copumpkin: Because I need to write a bunch of results to a file, where the results are types.
20:24:33 <copumpkin> Cheese is not a type
20:25:01 <copumpkin> isn't a Show instance enough?
20:25:14 <guesting> copumpkin: Maybe a better example would be showing "Maybe a" or "Nothing"
20:25:19 <copumpkin> Just a?
20:25:27 <copumpkin> > show Nothing
20:25:28 <guesting> copumpkin: Whoops, yeah
20:25:29 <lambdabot>  "Nothing"
20:25:33 <copumpkin> > show (Just 5)
20:25:34 <lambdabot>  "Just 5"
20:25:47 <guesting> but I don't want any strings at all, I just want Text as it's much faster
20:25:59 <guesting> I read files as Text and write them as Text
20:26:16 <copumpkin> not sure there's much you can do in an automated manner that isn't a huge hack
20:27:24 <guesting> weird. Then why use Text?
20:27:43 <guesting> If you need to convert it (most of the time) to strings?
20:28:06 <guesting> I guess that's a silly question
20:28:07 <guesting> but still
20:28:21 <guesting> I wish I could just convert a type to a Text :/
20:28:25 <guesting> quickly
20:28:43 <johnw> pack . show?
20:28:44 <jfischoff> that code I posted isn't even right :p
20:28:47 <jfischoff> what else is new
20:28:48 <johnw> what do you mean by "convert a type"?
20:28:51 <u_> right so
20:28:55 <guesting> johnw: I tried that, but it's INCREDIBLY slow
20:28:57 <u_> instead of recursing directly in chainl1
20:29:15 <u_> i can go to a different version of expr that prioritizes variables, then recurse
20:29:18 <u_> obvious in retrospect
20:29:27 <c_wraith> Woo.  I'm back into getting type errors I don't know how to fix.  It's like being a beginner again!
20:29:36 <copumpkin> guesting: well, what you have is some automatic code generation in GHC to make you strings for data constructor names. If you want the same thing for text, you'll need to write it. Or just write the Text values for your particular type
20:30:02 <guesting> johnw: Like if I have Data TrafficLight = Red | Yellow | Green, I would like to write out "Red" if that's the result.
20:31:34 <guesting> copumpkin: But I like using the algebraic data types instead of strings as it makes the code much more logical and neat
20:31:38 <guesting> and easier to debug
20:31:46 <copumpkin> guesting: I'm not saying you shouldn't
20:32:02 <copumpkin> I'm saying showText :: MyType -> Text
20:32:15 <copumpkin> showText Red = T.pack "Red"
20:32:17 <guesting> copumpkin: Oh. Duh. And pattern match it?
20:32:19 <copumpkin> and that one will be efficient
20:32:27 <copumpkin> (because I say so)
20:32:27 <guesting> yes, got it
20:32:31 <guesting> brilliant!
20:32:42 <copumpkin> or OverloadedStrings :)
20:32:45 <guesting> I'm using overloaded strings, so it should be fasta
20:32:46 <guesting> yes
20:32:57 <guesting> yaaay! why didn't I think of that--thank you!
20:32:57 <copumpkin> just make sure you're careful with building compound strings
20:33:14 <guesting> copumpkin: What do you mean?
20:33:42 <copumpkin> well, you don't just want to concatenate Text values willy-nilly
20:33:56 <copumpkin> it has a builder
20:34:00 <guesting> copumpkin: Why not?
20:34:15 <copumpkin> well, it'll be inefficient
20:34:21 <copumpkin> if you're concatenating lots of them
20:34:31 <guesting> there is one part where I concatenate
20:34:32 <guesting> hm
20:34:36 <guesting> a lot of them
20:35:08 <copumpkin> if you use Text's own concat
20:35:10 <copumpkin> that should be fine
20:35:36 <guesting> copumpkin: Yes, I'm using Text's version
20:35:41 <copumpkin> yeah, that's fine
20:35:45 <copumpkin> just don't call append in a loop
20:35:48 <guesting> I don't think the types agree with any other version...
20:40:18 <nkpart> Is there a Monoid for `ZipList a` (given a Monoid for a)?
20:40:42 <startling> nkpart: alas, no
20:40:53 <startling> nkpart: you can use liftA2 mappend though
20:40:59 <startling> :t liftA2 mappend
20:41:00 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
20:41:14 <startling> :t liftA2 mappend `asAppliedTo` ZipList []
20:41:16 <lambdabot> Monoid c => ZipList c -> ZipList c -> ZipList c
20:41:24 <nkpart> oh yeah, cool
20:41:36 <nkpart> so not in the libraries, but could exist
20:41:39 <startling> yeah.
20:41:43 <startling> I'm not sure why it doesn't.
20:42:14 <startling> oh: what would 'mempty' be?
20:42:33 <nkpart> Yeah.... I'm wondering if the laws would hold
20:42:34 <startling> it'd be replicate n mempty for some n we can't get.
20:42:35 <nkpart> I don't think they would
20:43:56 <startling> nkpart, it would, there's just not enough information in the type for 'mempty' to be specific enough
20:44:17 <startling> since the length of the ziplist isn't encoded in the type
20:46:15 <nkpart> Right, yeah. I was thinking you'd have to use [] or `repeat mempty`, but neither would work
20:46:16 <c_wraith> Hmm.  I'm suffering from muddy thinking.  I'm sure that conceptually my program is well-typed.  However, I'm not sure how to tell GHC that.
20:46:20 <Rotaerk_> http://lpaste.net/6332849365790490624
20:46:51 <Rotaerk_> I don't understand why it doesn't let m remain abstract... why does it need me to disambiguate the type arguments
20:47:02 * c_wraith considers unsafeCoerce.  unsafely.
20:47:12 <Rotaerk_> I just want m to be (ModelOf EntityEvent m) => m
20:47:25 <copumpkin> c_wraith: what are you doing?
20:48:17 <Rotaerk_> I think there's something fundamental about typeclasses that I'm missing...
20:48:40 <c_wraith> Rotaerk_: actually, you might just be running into MonoLocalBinds.  Try putting a polymorphic type signature on m
20:49:08 <Rotaerk_> I tried this:  let m = (c ^. model :: forall m. (ModelOf EntityEvent m) => m) in Success c
20:49:53 <c_wraith> copumpkin: I'm trying to model ST with ST.  This is mostly just an exercise in learning to use GHC features I haven't before.
20:49:55 <Rotaerk_> hmm it does clear up the "ambiguous type variables" error, though gives me another
20:50:03 <copumpkin> c_wraith: without ST?
20:50:12 <c_wraith> copumpkin: no, with.  :)
20:50:17 <copumpkin> hmm :)
20:51:10 <Rotaerk_> c_wraith: is that what you meant?
20:52:22 <c_wraith> Rotaerk_: Yeah, I have no clue what the underlying situation might be.  I was just pointing out a reason why you sometimes get things that try to be monomorphic even though they could be polymorphic.
20:52:34 <Rotaerk_> ah
20:56:32 <c_wraith> copumpkin: http://lpaste.net/100167  I don't yet understand enough to solve this.
20:59:36 <johnw> c_wraith: I don't think you can unify your forall s. with ST's forall s
20:59:53 <c_wraith> johnw: Yes, that's the conclusion I reached.
21:00:07 <c_wraith> johnw: But I'm not sure if there's a workaround possible or not.
21:00:36 <c_wraith> johnw: I mean, my forall s. provides the exact same sort of safety.  unsafeCoerce *should* be safe.  But it feels wrong.
21:00:50 <c_wraith> Like I should be able to solve it without that horrible hack.
21:01:02 <c_wraith> If I'm doing that, I might as well just unsafePerformIO the IO version.
21:01:08 <c_wraith> It's slightly less unsafe.
21:02:23 <copumpkin> you probably just need to write a new interpretWithMonad
21:02:28 <kazagistar> hmm, I am having a hard time finding a good way to test if something is a valid IArray index… is "isValidIndex index array = (\(a, b) -> a <= index && index <= b) . bounds array" the best way?
21:02:53 <c_wraith> copumpkin: ...  That's a terrifying thought.  That's the Control.Monad.Operational function that does all the work. :)
21:02:55 <Rotaerk_> hmm I guess the issue is that updateContextWith signature just uses the m type variable as an intermediate step to saying "c is the context of some model(s) of e" and then m is forgotten about
21:03:00 <copumpkin> c_wraith: it's like three lines :P
21:03:11 <c_wraith> copumpkin: ...  I didn't say all the work was lots of work.
21:03:20 <Axman6> @hoogle Ix a => a -> (a,a) -> Bool
21:03:21 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
21:03:21 <lambdabot> Text.Regex.Base.RegexLike extract :: Extract source => (Int, Int) -> source -> source
21:03:21 <lambdabot> Data.Graph.Inductive.Graph gelem :: Graph gr => Node -> gr a b -> Bool
21:03:34 <Axman6> kazagistar: is inRange what you're after?
21:03:52 <c_wraith> copumpkin: is it just that it would need a different type signature, with the same implementation?
21:04:09 <kazagistar> Axman6: thanks, I couldnt find it on google without the Ix qualification
21:04:10 <dagle> Is there a lib lets you insert a unix filepath with enviroment path variables and such and it expands it?
21:04:42 <dagle> Not hard to write but it sounds like something that should exist.
21:05:06 <copumpkin> c_wraith: probably
21:06:11 <c_wraith> I feel like this problem is related to impredicative instantiation.
21:06:37 <c_wraith> Like if I could instantiate a type variable as polymorphic somewhere, and keep it that way, it would work.
21:07:31 * hackagebot hamlet 1.1.8.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.8.1 (MichaelSnoyman)
21:12:17 <c_wraith> The fact that it feels impredicative implies to me that maybe I can make this work with a polymorphic newtype wrapper.
21:20:26 <c_wraith> An unsafeCoerce sure made it compile!  (no, this is not my real solution)
21:20:43 <c_wraith> unsafeCoerce makes most things compile.
21:21:50 <c_wraith> Glad I got those two sentences in *before* edwardk joined.
21:23:09 <edwardk> hah
21:23:15 <edwardk> unsafeCoerce does make most things compile ;)
21:23:23 <c_wraith> darn the logs!
21:24:02 <c_wraith> I'm working on a problem where I'm not smart enough to tell GHC that something is well-typed.  Possibly because I'm not smart enough to actually prove it is well-typed.
21:24:44 <c_wraith> edwardk: Do you have any suggestions for making interpreter #2 work?  http://lpaste.net/100167
21:25:55 <c_wraith> I feel like there's something I'm missing.
21:29:39 <edwardk> c_wraith: what doesn't work?
21:29:51 <edwardk> oh the variable escape
21:30:07 <c_wraith> the error message is at the bottom, yeah
21:30:17 <c_wraith> I can't see how to communicate the quantification through
21:33:48 <edwardk> c_wraith: lift 'f' to the top level?
21:34:00 <c_wraith> Huh.  Does that work?
21:34:43 <edwardk> oh derp
21:34:45 <edwardk> nevermin
21:34:47 <edwardk> easier fix
21:35:10 <edwardk> runEnvST ep = runST (interpretWithMonad f (runEnv p))
21:35:19 <edwardk> move the opening of the Env _into_ the runST
21:35:32 <edwardk> the skolem is being picked outside the quantifier
21:35:33 <Victor1> Hey there !
21:36:25 <c_wraith> edwardk: hmm.  That makes some sense.  Let me poke at it a bit.  I probably will ask some more questions about it.  This is an area where I'm not near smart enough.
21:36:26 <Victor1> Hey there !
21:36:37 <c_wraith> (yet)
21:36:38 <Victor1> Hey there !
21:36:48 --- mode: ChanServ set +o edwardk
21:36:53 --- mode: edwardk set +b *!~nodebot@117.220.247.56
21:36:54 --- kick: Victor1 was kicked by edwardk (Your behavior is not conducive to the desired environment.)
21:37:38 * hackagebot hamlet 1.1.9 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.9 (MichaelSnoyman)
21:38:06 <monochrom> hmm, skolem
21:38:28 <zcd> i'm trying to implement my own show for a custom data class, but that data class has a type parameter
21:38:37 <zcd> how do i make sure the type parameter has a show?
21:38:55 <edwardk> instance Show a => Show (MyFoo a)
21:39:54 <Hafydd> What is a data class?
21:40:14 <zcd> ty
21:40:19 <zcd> my mistake custom data
21:40:35 <zcd> w/e it's supposed to be called
21:40:42 <Hafydd> A data type, usually.
21:41:09 <zcd> duly noted
21:42:04 <c_wraith> edwardk: Well, yep.  That works.  But..  Why?
21:42:08 <roboguy_> classes are something different
21:42:57 <BotCoin> what is Monad?
21:42:58 <c_wraith> edwardk: this must have something to do with how RankN types are implemented.
21:43:16 <c_wraith> BotCoin: an abstraction.  You probably don't need to worry about the details.
21:43:19 <edwardk> c_wraith: when you open Env p you pick the choice of 's'
21:43:31 <edwardk> before you go into runST's argument where you have to work for all s.
21:44:03 <c_wraith> Huh.  Is that just how pattern-matching on a polymorphic value is defined to work?
21:44:39 <edwardk> c_wraith: yes
21:44:59 <johnw> otherwise, what would you match?
21:45:16 <roboguy_> BotCoin: do you know about Functor?
21:45:19 <c_wraith> That's actually really handy to know.  I suppose that's related to GHC's head exploding if you try to match a GADT in a let/where?
21:45:27 <edwardk> c_wraith: otherwise what type does 'p' have? if you had two arguments what type would they each have?
21:45:30 <BotCoin> no
21:48:48 <c_wraith> edwardk: When I was struggling with this earlier, I said it felt like the problem had to do with the lack of impredicative instantiation.  If the type of p could be instantiated impredicately (and psychically, such that GHC picked the right polymorphic type for p), would that also have worked?
21:51:18 <edwardk> c_wraith: perhaps for this particular simple example, not for harder ones
21:51:56 <c_wraith> Can you give me an example of a harder example?  Or is that a ton of work? :)
21:52:54 <edwardk> foo (Env p q) = ... where p and q have related types.
21:53:34 <c_wraith> Oh, I see.  Impredicative instantiation wouldn't carry the fact that they're related
21:53:41 <edwardk> the fact that you might ave somehow judo flipped the check by deferring it until you were under the nested runST context is a hack that only works because that thing is only used _after_ you opened it
21:53:48 <edwardk> but only locally
21:54:25 <edwardk> if you had foo (Env p) = runST (bar p) + runST (baz p)  -- that also doesn't make sense
21:58:04 <c_wraith> edwardk: ok, I think I've learned as much about this as I can digest right now.  Maybe another day, I'll run into further bits I don't understand, but.. That's not now.  Thanks for the help.
22:01:33 <YellowOnion> I'm looking for a library that allows me to generate 3d models, i've tried ImplicitCAD but it seems to be broken.
22:03:55 <carter> does anyone know if using constraint clients would interact badly with specialization?
22:04:44 <carter> *constraint kinds
22:04:47 <carter> WOAH i can't spell
22:06:12 <c_wraith> Depends on how you're using them.  If you're using a constraint-kinded variable to actually specify a constraint, then I can see it being problematic
22:06:46 <c_wraith> But if you're just using it as a phantom type variable in a non-constraint type, I don't think it should interfere.
22:27:32 <Axman6> @hoogle Monoid a => a -> a -> a
22:27:33 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
22:27:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:27:34 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
22:27:48 <Axman6> bah, what's the shortened version of mappend?
22:28:21 <Axman6> <+>?
22:28:23 <pavonia> <>?
22:28:28 <Axman6> ah that's it
22:28:28 <pavonia> :t (<>)
22:28:29 <lambdabot> Monoid m => m -> m -> m
22:31:52 <dword>  /msg NickServ identify 159666
22:32:31 <Axman6> oops :\
22:48:45 <ion> Congrats, that’s a great password.
22:50:50 <shachaf> http://www.inutile.ens.fr/estatis/password-security-checker/ doesn't rate it very highly
22:51:20 <simpson> Looks like the combination to somebody's luggage.
22:52:09 <c_wraith> my luggage only allows 5 digits.
22:52:58 <kfish> the devil's luggage allows 6
22:54:30 <rola> NicholasServ?
22:56:47 <startling> kfish, I thought it was three.
22:57:17 <_leroy_> If there a difference between guardians and case expressions?
22:57:59 * hackagebot bustle 0.4.4 - Draw pretty sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.4 (WillThompson)
23:00:42 <pavonia> _leroy_: If you mean guards, yes, they are different concepts. Guards are an additional condition for a pattern match and case introduces a pattern match on an expression
23:06:37 <kingofthehill> Hey Guys, can someone point me to good tutorials on haskell and databases?
23:15:05 <AshyIsMe> kingofthehill: there's a couple 24 days of hackage on acid-state and persistent
23:15:06 <AshyIsMe> http://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html
23:15:11 <AshyIsMe> http://ocharles.org.uk/blog/posts/2013-12-06-24-days-of-hackage-persistent-esqueleto.html
23:18:36 <kingofthehill> AshyIsMe: cook thanks :-)
23:19:06 <kingofthehill> AshyIsMe: Is there anything for Database.HDBC.Mysql?
23:19:30 <AshyIsMe> im not sure, haven't used that yet myself
23:19:47 <kingofthehill> AshyIsMe: Ah ok. Thanks anyway
23:22:49 <c_wraith> I just wrote (unsafeCoerce . g . unsafeCoerce).  Type-safety?  hah!  Though it occurs to me I could just rewrite it as (unsafeCoerce g)
23:23:05 <kingofthehill> AshyIsMe:
23:23:17 <kingofthehill> AshyIsMe: Any idea if there is good support for other databases?
23:23:48 <kingofthehill> Or CSV? I just want to import a table into haskell and run set operations on it
23:23:50 <shachaf> c_wraith: It'll be more efficient, too!
23:24:31 <_leroy_> pavonia: thanks! I'll try to find out the difference :)
23:25:20 <shachaf> (Because it won't eta-expand. This is a sort of lens joke.)
23:25:46 <c_wraith> Oh.  I just figured it was because it only did one unsafeCoerce. :P
23:26:24 <c_wraith> unsafeCoerce doesn't actually generate code, though, does it?
23:26:33 <shachaf> It compiles to the same code as id.
23:27:01 <c_wraith> Ah, right.  And if the simplifier can remove it, it does.  Otherwise, it does result in code
23:27:09 <shachaf> In lens we have a lot of newtypes. We write something like (Constructor . foo). That gets compiled to (id . foo). That gets inlined to (\x -> id (g x)), and then to (\x -> g x)
23:27:24 <shachaf> But you can't in general eta-reduce that to g, because g might be _|_.
23:27:30 <tomjack> I had `join f x = f x x`, lambdabot helpfully suggested `join`
23:27:48 <c_wraith> tomjack: yeah..  join does that. :)
23:27:56 <shachaf> A new GHC optimization makes it so that you can when g is known to be non-_|_.
23:28:11 <c_wraith> Oh, that's actually a nice optimization
23:28:28 <shachaf> So g `seq` (\x -> g x) compiles to g.
23:28:35 <tomjack> c_wraith: yes, this is why I defined it that way :). but I was looking for a pointfree definition not relying on an existing implementation of the monad
23:28:37 <shachaf> Except I hear there are still issues.
23:28:55 <c_wraith> Is that why the RC segfaults when trying to compile lens?
23:29:04 <shachaf> I doubt it.
23:29:08 <shachaf> tomjack: Well, you need *some* primitives.
23:29:28 <shachaf> Pick a set of primitives and you can write (\f x -> f x x) in terms of it.
23:29:52 <tomjack> Agda stdlib? :)
23:30:13 <no-n> what are the Data.Map equivalents to (map fst) and (map snd)?
23:30:43 <shachaf> For example, with SKI it's S S (K I)
23:30:46 <shachaf> :t ap ap (const id)
23:30:47 <lambdabot> (a -> a -> b) -> a -> b
23:31:07 <tomjack> aha
23:31:09 <tomjack> thank you
23:31:18 <joneshf-laptop> I'm trying to set up folders for xdg base directory when a package `foo` is installed with cabal. If I use the `postInstall` hook in Setup.hs, will it set up these directories only when someone explicitly installs `foo`, or will it still set up these directories if some other package `bar` has `foo` as a dependency?
23:31:29 <tomjack> I like to plug pointful definitions into ?pl in the hopes that I'll someday understand the typical output..
23:32:44 <c_wraith> no-n: keys and elems, respectively.
23:33:05 <c_wraith> no-n: I found them by searching the haddock page for [k] and [a]
23:33:09 <no-n> c_wraith: ahh, ty
23:33:23 <no-n> [k] and [a]?
23:33:46 <shachaf> What does it mean to understand?
23:33:57 <c_wraith> no-n: the types of those functions would be Map k a -> [a]  and Map k a -> [k]
23:34:16 <no-n> oh
23:34:34 <c_wraith> no-n: given that k and a were the names used universally in the documentation, I was sure that they'd show up in the haddocks, and they did
23:34:38 <carter> ok
23:34:41 <carter> hey all
23:34:46 <carter> i've a fancy data kinds data type
23:34:49 <no-n> ok
23:34:51 <carter> and i'm getting a funny syntax error
23:34:56 <no-n> i'm used to k and v from python :3
23:35:27 <c_wraith> no-n: ah.  Well, just reading the first few type signatures would have suggested k and a, in this case
23:35:43 <carter> Cale: thanks
23:35:45 <carter> i'm a bit tired
23:35:53 <carter> data Elem ls el  where
23:35:53 <carter>     Point :: Elem '[] el
23:35:53 <carter>     (:#) :: a -> Elem ls el -> Elem (a ': ls) el
23:35:55 <carter> does the trick
23:35:58 <AshyIsMe> kingofthehill: not sure sorry, i'd be interested to see what you find though!
23:36:34 <kingofthehill> AshyIsMe: Well I did figure out how to work the mysql demon, interested to know?
23:37:42 <AshyIsMe> yeah sure, can you stick up a gist?
23:38:37 <tomjack> (flip ap) id ?
23:38:43 <carter> shachaf: because i'm tired and i had an off by one error
23:38:44 <tomjack> hmm
23:39:37 <kingofthehill> AshyIsMe: Here you go http://lpaste.net/100171
23:40:10 <AshyIsMe> ah cheers
23:40:57 <AshyIsMe> there's also the Text.CSV module by the looks, that could be useful for you too
23:48:17 * hackagebot dvi-processing 0.3.1 - Read/write DVI and TFM file  http://hackage.haskell.org/package/dvi-processing-0.3.1 (JeanPhilippeBernardy)
