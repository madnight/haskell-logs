00:04:06 * hackagebot ipopt-hs 0.4.0.0 - haskell binding to ipopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.4.0.0 (AdamVogt)
00:07:32 <xintron> when playing around in ghci, is there any good way of lifting the result from an IO action (for let foo = ...; assignment)?
00:08:37 <tomejaguar> Do you mean 'var <- action'?
00:09:22 <xintron> yes
00:09:51 <kazagistar> I never quite got that‚Ä¶ var <- action uses >>= to shove var into the rest of the program, right?
00:10:00 <xintron> Sure I can do let c = readFile "file" but it would be sweet to have the data lifted (when playing around in ghci)
00:10:58 <xintron> do { c <- readFile "foo"; putStrLn c } == readFile "foo" >>= putStrLn?
00:11:19 <startling> xintron: yeah.
00:11:22 <xintron> without the use of "c <-" it would be as if one used >> instead
00:11:40 <startling> kazagistar, it desugars to a lambda
00:12:13 <startling> kazagistar: do { c <- readFile f; putStrLn c} === readFile f >>= (\c -> putStrLn c)
00:12:27 <startling> (parens are unnecessary, added for clarity)
00:14:11 <xintron> startling, ah, so it will make a lambda expression (and not the way I wrote it)?
00:14:15 <kazagistar> startling: thanks, that makes sense‚Ä¶ does ghci actually end up with a bajillion lambdas in each other like that, or does it only do that conceptually?
00:15:08 <startling> xintron: yeah, but what you said is equivalent-ish
00:15:14 <xintron> :)
00:15:16 <startling> kazagistar: I'm not sure your question makes sense.
00:15:38 <xintron> startling, But is there any way to lift IO a -> a in ghci?
00:15:47 <startling> xintron: it's a process called eta-reduction (\a -> f a to f) that's usually allowed in haskell but not always.
00:15:58 <startling> xintron: I don't understand that question.
00:16:18 <xintron> startling, let c = readFile "foo"; and have c :: a
00:16:22 <xintron> instead of c :: IO a
00:16:42 <startling> xintron, only in IO.
00:16:51 <startling> (that's c <- readFile "foo")
00:16:52 <kazagistar> if I keep a ghci session open for a while, then is my current code executing inside of like 100 lambdas or something, from any <- operations I have done?
00:17:22 <startling> kazagistar: I suspect ghci cheats, but in any case it doesn't matter.
00:17:40 <xintron> startling, oh, that worked. Thought I needed to always use let in ghci
00:17:43 <xintron> thanks!
00:17:52 <startling> xintron: oh, nope, <- works in ghci
00:19:07 * hackagebot markdown2svg 0.0.1.13 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.13 (YoshikuniJujo)
00:31:47 <jle`> xintron: if you're familiar with do blocks, it's similkar
00:39:10 * hackagebot markdown2svg 0.0.1.14 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.14 (YoshikuniJujo)
00:47:30 <Heather> how to rewrite foo (a x) (b x) ? where x is data structure object
00:49:22 <opqdonut> Heather: (apply foo ((juxt a b) x))
00:49:29 <opqdonut> ,(apply prn ((juxt :a :b) {:a 1 :b 2 :c 3}))
00:49:40 <opqdonut> aarg
00:49:43 <opqdonut> wrong channel once again
00:49:53 <opqdonut> thought I was in #clojure for some reason
00:49:53 <simpson> Heather: Why does it have to be rewritten?
00:49:59 <Heather> xD
00:50:09 <Heather> simpson: to write x once
00:50:26 <opqdonut> @pl \x -> foo (a x) (b x)
00:50:26 <lambdabot> liftM2 foo a b
00:50:41 <opqdonut> liftA2 will work as well
00:50:53 <opqdonut> this is the ((->)r) Monad/Applicative
00:51:07 <simpson> Heather: let x = theActualComplicatedDefinitionOfX in ...
00:51:18 <opqdonut> but yeah, a let is nicer
00:51:19 <simpson> Heather: let x = theActualComplicatedDefinitionOfX in foo (a x) (b x)
00:54:54 <kazagistar> dunno, maybe its just me, but I am ok with writing x a couple times‚Ä¶?
00:55:02 <startling> > foo <$> f <*> g $ a :: Expr
00:55:03 <lambdabot>  Not in scope: `foo'
00:55:03 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversable)
00:55:10 <startling> > f <$> f <*> f $ a :: Expr
00:55:11 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
00:55:11 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
00:55:11 <lambdabot>  The type variable `a0' is ambiguous
00:55:11 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:55:11 <lambdabot>  Note: there are several potential instances:
00:55:36 <startling> > (f <$> f <*> f $ a) :: Expr
00:55:37 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
00:55:38 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
00:55:38 <lambdabot>  The type variable `a0' is ambiguous
00:55:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:55:38 <lambdabot>  Note: there are several potential instances:
00:55:42 <startling> :/
00:56:54 <startling> > (*) <$> (+ 1) <*> subtract 1 $ 0
00:56:55 <lambdabot>  -1
00:59:12 * hackagebot markdown2svg 0.0.1.15 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.15 (YoshikuniJujo)
01:14:23 * hackagebot markdown2svg 0.0.1.16 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.16 (YoshikuniJujo)
01:14:25 * hackagebot generic-maybe 0.1.1.0 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.1.1.0 (JonathanFischoff)
01:22:48 <xintron> Is there some way of checking if there is a stdin stream available (in an easy fashion)?
01:24:52 <Feuerbach> what do you mean?
01:25:03 <Feuerbach> is there any data to read?
01:25:21 <xintron> Feuerbach, yes, exactly
01:25:56 <xintron> My first idea was to just check `c <- getContents; if null c` but that didn't seem to work
01:26:23 <Feuerbach> you can use blocking read functions in a separate thread
01:27:46 <Feuerbach> actually, there's hReady and hWaitForInput
01:27:51 <Feuerbach> in System.IO
01:29:25 * hackagebot yesod-form 1.3.5.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.5.1 (MichaelSnoyman)
01:30:08 <xintron> Feuerbach, oh, nice. Will take a look at  that :)
01:41:24 <jophish_> Whats a good channel to chat about untyped lambda calculus?
01:45:19 <Heather> okay I discovered liftA2 and now I need liftA2skip1
01:45:22 <Heather> liftA2skip1 print "%s <> %s" location branch repo
01:45:39 <Feuerbach> jophish_: dunno, #scheme? :)
01:46:51 <Feuerbach> (ironically, I think an average Haskeller is more interested in ULC than an average Schemer)
01:47:09 <makalu> can I have instance declarations with multiple definitions on one line? Like "instance Foo Int where { foo = id, bar = id }"
01:47:19 <Feuerbach> sure, why not
01:47:26 <osfameron> ULC?
01:47:33 <Feuerbach> untyped lambda calculus
01:47:36 <opqdonut> Heather: liftA2 (print "%s <> %s) location branch repo
01:47:49 <Heather> opqdonut: oh
01:47:51 <Heather> right
01:47:51 <osfameron> Feuerbach: ah, ta
01:47:54 <Feuerbach> makalu: just use semicolon instead of comma
01:48:13 <makalu> Feuerbach: thank you
01:52:21 <Heather> opqdonut: doesn't help
01:54:02 <opqdonut> Heather: error message? btw, did you mean printf instead of print?
01:54:37 * hackagebot iCalendar 0.4 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.4 (ChristianRoedliAmble)
01:55:03 <Athas> Has it been considered adding a progress bar to 'cabal update'?
01:55:30 <Heather> opqdonut: I mistaken ) should use printf instead of print
02:00:56 <simon`> does anyone know how I can make emacs aware of hs-source-dirs defined in a .cabal file?
02:08:22 <makalu> can I have a cabal executable that is only built when explicitly asked?
02:10:28 <jfischoff> you could do that with cabal flags
02:16:07 <makalu> jfischoff how do I run cabal with the flag?
02:16:28 <jfischoff> I think it is -fthe-flag or something similar
02:18:26 <makalu> it says unrecognised command
02:18:50 <makalu> --flags=foobar doesn't work either
02:19:08 <supki> makalu: what command do you type in?
02:19:17 <supki> makalu: -f is for cabal configure/install
02:19:24 <makalu> oh
02:19:28 <makalu> I tried it with build
02:20:01 <makalu> thank you jfischoff and supki, it works now
02:27:58 <merijn> Feuerbach: FYI, untyped LC is more commonly abbreviated as UTLC (for similarity with STLC, i.e. simply typed LC)
02:29:42 * hackagebot hweblib 0.6 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.6 (AycanIrican)
02:30:27 <Feuerbach> good to know
02:34:42 * hackagebot idris 0.9.11.2 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.11.2 (EdwinBrady)
02:52:01 <aspidites> what is the most idiomatic way to have types with similar fields? Type classes seem to be more about having types with shared behavior, rather data.
02:52:58 <merijn> aspidites: You mean you have types A and B that share a common subset of fields?
02:52:59 <aspidites> more concretely, I have a type card with multiple constructors. while diffirent constructors all have a name field, not all of them have an attack value
02:53:06 <aspidites> merijn: exactly
02:53:44 <aspidites> or i guess my example would be a type A with constructors B and C which share a common subset of fields
02:54:04 <merijn> aspidites: Oh, if you have multiple constructors of the same type you can even define fields for each constructors, however if you use a field selector on a constructor that doesn't have that field your program will crash
02:54:41 <merijn> aspidites: i.e. "data Foo = Foo { name :: String, attack :: Int } | Bar { name :: String, defense :: Int }" <- this works
02:55:08 <merijn> But "attack (Bar _)" <- this crashes and so does this -> "defense (Foo _)"
02:55:32 <merijn> aspidites: "name (Bar _)" and "name (Foo _)" will both work, though
02:55:36 <aspidites> ah. is there a safer, perhaps more idiomatic way to approach this then?
02:56:13 <supki> lens has a solution for this
02:56:14 <merijn> aspidites: The other common approach is to split the common fields of in a separate type and then have "data Foo = Foo CommonFields Rest | Bar CommonFields SomethingElse"
02:56:34 <aspidites> ah. i thought of that, but didn't know if it was too hacky
02:56:37 <merijn> aspidites: That means you have to do annoying nested updates to change CommonFields values in Foo, but that's what we have lens for
02:56:49 <aspidites> then have custom functions that hide away the nesting, so to speak?
02:57:11 <merijn> aspidites: You could do that, but the various lens libraries already have those custom functions for you :)
02:58:27 <aspidites> merijn: ah. haven't gotten that far in my haskell-fu. just recently conqueored monads ... well, won a spar with them, I guess
02:59:03 <merijn> aspidites: data-lens is a fairly simple library to get started with. lens is the new favorite and comes with all bells and whistles
02:59:19 <merijn> aspidites: However the lens API and types can be...intimidating to say the least
02:59:50 <aspidites> because you know, haskelle wasn't already intimidating to begin with? ;-)
03:00:07 <supki> merijn: I think you meant lens-family/lens-family-core or something as an example of simple lens library
03:00:15 <supki> data-lens is obsolete and stuff
03:00:23 <aspidites> for the record, i keep wanting to pronounce your name as merlin, because you're like a wizard
03:01:14 <aspidites> record -- no pun intended there
03:01:26 <merijn> supki: data-lens is what I used, it was fairly easy to grok so that's what I recommend
03:01:34 <supki> interesting
03:01:42 <lieven_> funny since merijn was the translation used in the dutch version of LotR for Merry, so rather a hobbit than a wizard :)
03:01:57 <supki> the approach data-lens takes is very different from lens, so I'm unsure how useful it is to start with it
03:02:17 <lieven_> I'm using fclabels which is also lenslike I think
03:03:42 <merijn> lieven_: I went by Merry in the UK because people kept butchering the pronounciation of Merijn >.>
03:04:26 * aspidites googles how to pronounce Merijn
03:04:41 <merijn> Google Translate set to Dutch does an okay job
03:04:44 <Feuerbach> I, too, favor data-lens
03:04:45 <lieven_> merijn: tell me about it. anglophones aren't kind to a name like lieven either :)
03:05:01 <aspidites> http://www.pronouncenames.com/pronounce/merijn is that right?
03:05:13 <merijn> I can always tell anglophones on IRC by the fact that they keep typing "merjin" >.>
03:05:15 <aspidites> muh-rhine?
03:05:35 <merijn> aspidites: That's about as close as most English speakers get :)
03:06:05 <Feuerbach> it's the same sound as in Dijkstra, isn't it?
03:06:37 <merijn> Yeah
03:07:16 <aspidites> oh well. so much for NOT butchering it. sorry
03:15:00 <Twey> Hm, it occurs to me that Lens (and maybe some automatic derivation with TH) could be used to get something very much like subclassing
03:15:44 <Twey> You just specify a field to ‚Äòinherit‚Äô and derive lenses that transparently access that field on the ‚Äòchild‚Äô type
03:16:08 <supki> Twey: that's what makeClassy does, I think?
03:16:19 <Twey> Oh, of course it exists :√æ
03:16:46 <Twey> Ah, no, I don't think that's quite the same
03:17:33 <Twey> I mean that if you had Bar { baz ‚à∑ Baz } and Foo { bar ‚à∑ Bar }, you can also derive a HasBaz for Foo
03:18:38 <Twey> (i.e. bar . baz)
03:19:12 <supki> well, isn't that makeClassy?
03:20:01 <Twey> supki: No, makeClassy only makes HasBar Foo and HasBaz Bar, not HasBaz Foo
03:20:01 <supki> you have e.g. instance HasBaz Baz, instance HasBaz Bar, and instance HasBaz Foo and can use baz on Foo
03:20:27 <supki> oh, right, you'd need to right HasBaz Foo yourself
03:23:26 <supki> I tend to write all this machinery without the TH though, but otherwise it's very useful, yes
03:24:05 <Twey> Sorry, makeClassy gives you HasFoo Foo and HasBar Bar, and lenses fooBar and barBaz, but not fooBaz = fooBar . barBaz
03:24:38 <Twey> Wait, you actually do this?
03:25:26 <supki> yes, it's very convenient for nested records (app's configuration, etc)
03:26:36 <vu3rdd> slightly OT: I have a custom ghci prompt which displays a greek letter lambda. But in the emacs run-haskell repl, I get this: √é¬ª>
03:26:53 <vu3rdd> ghci displays the prompt fine on urxvt though..
03:27:28 <tdammers> *mumble*localesomething*mumble*
03:27:52 <asqwexz> question. In LYAH there's a part that talks about why to "never add typeclass constraints in data declarations" because you end up having to specify them again in function declarations. This is followed by the example "data (Ord k) => Map k v = ..."  and how now "toList would have to be toList :: (Ord k) => Map k a -> [(k, a)], even though the function doesn't do any comparing of keys by order"
03:28:02 <Feuerbach> Twey: I did this in time-lens
03:28:23 <Feuerbach> http://hackage.haskell.org/package/time-lens-0.3/docs/Data-Time-Lens.html
03:28:28 <asqwexz> Why is this bad considering there's no way to construct a map from a list without the Order constriants, and the fact that you have to repeat that constraint multiple times?
03:31:52 <Twey> vu3rdd: Looks like your emacs isn't using UTF-8.  Do you have LANG=your_locale.UTF-8 set?
03:32:17 <Feuerbach> asqwexz: not sure what your point it. toList destructs a map, not constructs it
03:32:47 <Twey> asqwexz: It's just extra noise to no gain
03:33:13 <Twey> Feuerbach: Ah, right!
03:39:00 <AfC> I need a data structure that is both a key/value map AND a queue, ie, that I can take one or so elements from the structure at a time. Any suggestions?
03:39:28 <Twey> AfC: Map
03:40:11 <Twey> It's a tree inside, so you can findMin or findMax in O(log n)
03:40:58 <Twey> Just have your elements be pairs of (priority, value)
03:41:39 <Twey> Oh, sorry, you didn't say priority queue
03:41:41 <Twey> Hrm
03:42:24 <AfC> Twey: so ordering doesn't matter [to me], though I note that Data.Map{.Strict} has the split and min/max operations whereas of course Data.HashMap doesn't of course
03:43:24 <Twey> I'm not sure it's possible (other than by using two separate data structures).  Basically you're interested in two different orders: the order of insertion and the order of the keys
03:43:32 <Twey> Which should be orthogonal
03:43:35 <AfC> yeah
03:44:12 <Twey> If your items are big and you don't want to duplicate them you could have the queue point to elements in the map, or vice versa
03:44:32 <AfC> if findMin is O(logN) I suppose that will just involve going down the [say] left side of the tree, tada
03:44:40 <Twey> Right
03:45:22 <AfC> [which would be a reason to use containers' rather than unordered-containers']
03:45:31 <Twey> ‚Ä¶ heh, actually, we're in Haskell, so you get that benefit for free so long as you insert the same element into each container
03:45:56 <AfC> I shudder to think how much garbage I'm going to be creating using a tree as a queue that way.
03:46:03 <Twey> Yeah, a hash map is going to give you O(n) find-min unless you carefully construct your hash function to preserve ordering
03:46:44 <AfC> I was sorta hoping there'd be a "strip one off of it" type op
03:46:58 <Twey> Off of what?
03:47:06 <AfC> the [hashtree]
03:47:13 <Twey> Ah
03:48:05 <Twey> The order isn't going to be the order you put the elements in, anyway
03:48:15 <mm_freak> it could give you O(log n) find-some-element
03:48:23 <mm_freak> but it doesn't
03:48:32 <Twey> mm_freak: How so?
03:48:38 <Twey> Isn't it up to the hash function?
03:48:48 <mm_freak> Twey: find the element with the least hash value
03:49:05 <Twey> Oh, find *any* element
03:49:12 <mm_freak> yeah
03:49:19 <mm_freak> although that operation may be problematic
03:49:45 <mm_freak> hashable uses a per-process secret to prevent hash collision DoS attacks
03:50:19 <Twey> That's smart, but inconvenient
03:51:04 <mm_freak> it's a necessary evil
03:51:49 <Twey> Yes
03:55:12 <bernalex> anyone have any experience with curses bindings and care to recommend some? the only one I know about is ncurses, the "modern binding to GNU ncurses". it looks OK, but I thought I'd ask if anyone had experience with something else before I got cracking. :-)
03:56:42 <mm_freak> bernalex: if you can live without windows support (i think), vte is simple to work with
03:56:55 <mm_freak> it's not curses, it's a pure haskell library
03:57:05 <mm_freak> uhm
03:57:08 <mm_freak> vty, not vte =)
03:57:38 <mm_freak> and there is also vty-ui, which gives you widget-based UIs based on vty
03:57:48 <bernalex> mm_freak: IDC about Windows at all. I just want to make an RSS reader like Raggle in Haskell. :-)
03:58:04 <mm_freak> then you probably want vty-ui =)
03:58:13 <bernalex> mm_freak: cool, thanks!
03:58:31 <mm_freak> it has an awkward event-handler-driven interface‚Ä¶  i suggest you use reactive-banana together with it
03:58:43 <mm_freak> if you don't mind a learning curve =)
03:58:45 <bernalex> here's raggle in all its advanced gloy: http://raggle.org/files/shots/11.png so that's basically what I want
03:59:30 <bernalex> so what I need is uhm RSS, text output with three widgets/windows/whatever (feeds, posts, post text), and input to navigate between them. that's it.
04:00:47 <vu3rdd> Twey: yes, that was the problem! Thanks
04:01:56 <Twey> vu3rdd: No problem
04:03:19 <Twey> bernalex: Wrap it up in reactive-banana, and post the library so the rest of us don't have to suffer the IORefs ;)
04:09:53 * hackagebot language-puppet 0.12.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.12.1 (SimonMarechal)
04:11:18 <ski> dmwit : well, at least i think `foo' can be forced to WHNF after `bar'
04:12:17 <ski> dmwit : and i suspect `foo' can possibly be forced even later, as long as the termination behaviour, and the observable output of the program is the same
04:13:23 <ski> dmwit : iiuc otoh with `pseq' `foo' is forced before `bar' is started to be forced
04:21:30 <kuribas> Is there a function "Bool -> a -> Maybe a" ?
04:21:42 <kuribas> returning Just a if Bool is True.
04:22:43 <kuribas> @hoogle Bool -> a -> Maybe a
04:22:44 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
04:22:45 <lambdabot> Control.Exception assert :: Bool -> a -> a
04:22:45 <lambdabot> Control.OldException assert :: Bool -> a -> a
04:26:42 <supki> :t \y x -> x <$ guard y
04:26:42 <lambdabot> (Functor f, MonadPlus f) => Bool -> a -> f a
04:27:44 <timbod> If I ask cabal what it will install (with cabal install --dry-run), it tells me an earlier version than the latest. How can I see why it is choosing the older version?
04:27:53 <supki> :t \y x -> y ^? only True . to (const x)
04:27:54 <lambdabot> Bool -> a -> Maybe a
04:28:14 <kuribas> :t (<$)
04:28:15 <lambdabot> Functor f => a -> f b -> f a
04:28:25 <adnam> timbod: you can either give it the new version as a constraint and see why it fails, or check what it's actually doing with -v3
04:28:38 <adnam> timbod: it might also be because it prefers installed versions, so you can try --upgrade-dependencies
04:29:56 * hackagebot websockets 0.8.1.3 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.1.3 (JasperVanDerJeugt)
04:30:04 <timbod> adnam: Thanks. -v3 tells me what I need.
04:33:34 <kuribas> :i (Functor f, MonadPlus f) => Bool -> a -> f a
04:33:45 <kuribas> @hoogle (Functor f, MonadPlus f) => Bool -> a -> f a
04:33:46 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
04:33:46 <lambdabot> Control.Exception assert :: Bool -> a -> a
04:33:46 <lambdabot> Control.OldException assert :: Bool -> a -> a
04:34:36 <kuribas> @hoogle Functor f => f b -> a -> f a
04:34:37 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
04:34:37 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
04:34:38 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
04:38:31 <supki> :t (Control.Comonad.$>)
04:38:31 <lambdabot> Functor f => f a -> b -> f b
04:39:24 <kuribas> I'll just use "guard test >> Just result", as it is a bit clearer to read.
04:45:28 <kazagistar> if I fmap over a lazy Map, will each value have the fmap applied individually?
04:47:04 <lieven_> :t guard
04:47:05 <lambdabot> MonadPlus m => Bool -> m ()
04:49:20 <kazagistar> as in, I have a key value map where each value is then fmap-ed through some non-trivial computation, but I only ever access a small subset of the values
04:49:43 <ivanm> kazagistar: there will be a thunk, so if you don't actually use a value the fmap won't be calculated for it
04:49:56 <ivanm> with strict Maps, it will be evaluated to WHNF
04:50:06 <ivanm> (i.e. the outermost constructor of the result)
04:52:04 <kazagistar> right, so (fmap (sortBy (flip compare) . count)) will only run the sort (and generate the list to be sorted at all) if I access it
04:54:15 <kazagistar> I think I found where I have my Shlemiel the Painter‚Ä¶ i'm doing a Map.fromListWith (++)‚Ä¶ (++) is not  O(1), right?
04:56:23 <merijn> kazagistar: It is if it can be fused
04:56:58 <merijn> i.e. "map f (xs ++ ys)" here the ++ is O(1) as it is fused with the traversal of map (yay, laziness!)
05:00:19 <kazagistar> hmm, I am having trouble reasoning about the complexity in this case‚Ä¶ http://lpaste.net/99727
05:00:43 <kazagistar> I am pretty sure that is where my leakage is coming from?
05:02:49 <xintron> When looking at concurrency, should I start out with MVar or jump at TMVar instead (and what is the big difference)?
05:04:42 <merijn> xintron: MVar and Chan are more efficient in the presence of lots of blocking readers
05:04:53 <merijn> (more efficient than their STM counter parts, that is)
05:06:00 <xintron> merijn, Maybe I should give the use case as well: an IRC-bot with multiple server connections where writing to the handle might happen in multiple threads
05:07:22 <merijn> xintron: Right, so you probably want 1 thread reading from a Chan and writing to the Handle and multiple threads writing to that Chan to write to the handle
05:07:55 <xintron> merijn, yeah, seems like a better way than letting the writer threads write directly to the handle.
05:12:12 <xintron> merijn, But what is the difference against STM then?
05:21:17 <satc> I was defining the traversable instance of Foo a b c. I wrote something like traverse f (Foo a b c) = Foo <$> f a <*> f b <*> f c. But the order in which I want to traverse is b a c. I am not sure how to write that.
05:22:29 <merijn> satc: "flip Foo <$> f b <*> f a <*> f c"?
05:23:44 <satc> merijn: Ohh.. But is there a better way of doing that. I mean for a general case. I dont want to insert too many flips. If it was a monad I could have just used do notation.
05:26:02 <merijn> satc: write a lambda/small function using let/where with argument in the proper order
05:47:07 <Peaker> I wonder which of using linux-ptrace, https://github.com/maurer/ptrace or just System.Process+"strace"  will get me to see all open/stat calls most easily
06:02:52 <Peaker> WordPtr is not a valid FFI type?
06:02:58 <Peaker> that's a bit weird...
06:03:56 <merijn> Peaker: Why would you expect it to be?
06:04:32 <merijn> Or rather, why WordPtr rather than "Ptr WordX"?
06:04:47 <Peaker> merijn, well, the ptrace package on github assumes it is :) It's defined by its compatibility with "Ptr", and is mostly useful for FFI, where C programs take a uintptr_t or a ptr-sometimes-casted-to-int cases
06:05:09 <Peaker> http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html <-- WordPtr is its own type, not a "Ptr WordX"
06:05:09 <Peaker> mostly equivalent to uintptr_t from C
06:06:00 <merijn> Ah, right
06:10:08 * hackagebot smallcaps 0.4.1 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4.1 (StefanBerthold)
06:14:17 <osa1> can anyone help me running this groundhog example: http://lpaste.net/99728 ? this is directly taken from FPcomplete groundhog tutorial but it doesn't work ...
06:17:22 <Kaidelong> is there an equivalent of Right for Either?
06:17:27 <Kaidelong> err
06:17:28 <Kaidelong> not right
06:17:35 <Kaidelong> Last?
06:17:59 <Kaidelong> the Maybe newtype for which Just a <> Just b == Just b
06:18:15 <quicksilver> a monoid instance for the last 'Right' ?
06:18:33 <Kaidelong> such that Left a <> Right b == Left a but Right a <> Right b == Right b
06:18:41 <quicksilver> >>
06:18:49 <quicksilver> if you're happy using the monad instance
06:19:27 <Kaidelong> well I guess I could do that, the reason I was thinking a monoid was because I wanted to use a reader monoid, but I could just implement something like ><>>
06:20:01 <Kaidelong> (><>>) f g x = f x >> g x
06:20:12 <Kaidelong> but actually come to think of it, that's not the behavior I want anyway
06:20:39 <Kaidelong> what I really want is Either SpecialExclusiveEvent (Right NormalStuff)
06:20:49 <Kaidelong> which IIRC is a monoid
06:21:05 <Kaidelong> so now it's a non-problem
06:21:21 <Kaidelong> err
06:21:26 <Kaidelong> Last NormalStuff
06:21:46 <Kaidelong> @instances Monoid
06:21:47 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:22:20 <Kaidelong> > Left "aa" <> Right (Last "bb")
06:22:21 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a0'
06:22:21 <lambdabot>              with actual type `[GHC.Types.Char]'
06:22:35 <Kaidelong> > Left "aa" <> Right (Last (Just "bb"))
06:22:36 <lambdabot>  No instance for (Data.Monoid.Monoid
06:22:36 <lambdabot>                     (Data.Either.Either
06:22:36 <lambdabot>                        [GHC.Types.Char] (Data.Monoid.Last [GHC.Types.Char])))
06:22:36 <lambdabot>    arising from a use of `Data.Monoid.<>'
06:22:36 <lambdabot>  Possible fix:
06:22:39 <Kaidelong> oh
06:22:44 <Kaidelong> well that sucks
06:23:02 <Kaidelong> why is there no (Monoid t) => Monoid (Either u t)?
06:24:59 <supki> because it's not canonical?
06:25:18 <supki> I'm actually surprised there's Semigroup (Either a b)
06:25:39 <Kaidelong> why not just say
06:25:47 <Kaidelong> mzero = Right mzero
06:25:47 <quicksilver> it's not really less canonical than other uses of Either
06:26:08 <quicksilver> Either is generally understand to have a conventional asymmetry
06:26:13 <Kaidelong> (Right x) `mappend` (Right y) = Right (x `mappend` y)
06:26:25 <Kaidelong> and Left annihilates
06:29:23 <Kaidelong> I guess I'll just wrap Either a (Right b) in a newtype and make my own Monoid instance
06:29:55 <Kaidelong> or mm
06:30:10 <tdammers> I tend to think of Either as Maybe with a more specific Nothing
06:30:15 <Kaidelong> (Last a, Last b) would perhaps work just as well for my purposes
06:30:41 <Kaidelong> tdammers: that's funny, I think of Maybe as an Either with a more specific Left
06:31:20 <tdammers> Kaidelong: same difference right?
06:31:22 <supki> even with asymmetry I'm not convinced the proposed instance is somehow more interesting than  Monoid m => Monoid (Either m a), i.e. validation
06:31:51 <Kaidelong> supki: it rhymes with the functor instance
06:32:16 <Kaidelong> you could always give an alternative monoid with a newtype for the validation
06:32:29 <rgr> hi folks, I'm ploughing through learnyouashaskell - would you recommend the leksah haskell IDE or should I stick with emacs? In fact any recommendations that helps me get associated online type/API help from the editor directly would nice.
06:32:48 <Kaidelong> stick with emacs
06:33:08 <tdammers> stick with whatever editor you're already comfortable with
06:33:10 <Kaidelong> the main thing leksah does for you right now is generating cabal files and running GHC in the background
06:33:23 <Kaidelong> the latter it does clumsily, the former I'm sure there's some emacs extension for
06:33:23 <tdammers> Haskell is not one of those languages that require an IDE to be bearable
06:33:49 <Kaidelong> tdammers: that maxim seems to break down as haskell projects get bigger and bigger
06:34:17 <tdammers> Kaidelong: that goes for every language, really, but IMO, the effect is much weaker in Haskell than most others
06:34:54 <rgr> actually from what Ive seen and being familiar with many languages I would say haskell is a language that definitely does but all to their own. thanks for the advice.
06:36:15 <bernalex> I have yet to use a language that doesn't work with vim+bash, or emacs.
06:36:16 <Kaidelong> I think if you think so you more think of the IDE as a way to get discovery, but emacs can do that, I think tdammers was more talking about RAD IDEs that generate repetitive code
06:36:28 <bernalex> well... Java is a PITA, but then again I don't have to use that any longer, lol.
06:36:38 <Kaidelong> NetBeans is a nice IDE
06:36:42 <Kaidelong> free, too
06:36:43 <bernalex> I hate it
06:36:52 <bernalex> then again I hate everything that isn't vim or emacs. :-D
06:36:58 <tdammers> what I mean is that most languages can *benefit* from a good IDE, if you're into that kind of thing
06:37:12 <tdammers> but some really *require* one, unless you're really masochistic
06:37:13 <bernalex> yes that's why you use vim or emacs plugins :-P
06:37:33 <Kaidelong> tdammers: ...and would those be languages that require lots of repetitive code?
06:37:44 <tdammers> Kaidelong: mostly, yes
06:37:44 <kuribas> emacs with ecb will work with large projects too.
06:37:51 <bernalex> java is so awful
06:38:01 <tdammers> Kaidelong: I consider a "snippets repository" a sign of admitting defeat
06:38:08 <Kaidelong> Java was nice for its time
06:38:13 <bernalex> eclipse has crap like autoimport and uh "autowrite getters and setters", which you kind of should have if you work with java all day
06:38:17 <kuribas> I don't see why emacs couldn't be used for large projects...
06:38:19 <tdammers> if you need "snippets", your language is obviously inadequate for the kind of abstractions you need
06:38:40 <Kaidelong> kuribas: I think of emacs and vim + extensions as being an IDE
06:38:49 <bernalex> it can be.
06:38:49 <kuribas> right
06:38:52 <bernalex> s/it/they
06:38:53 <Kaidelong> there are probably degrees to it
06:39:11 <Kaidelong> I don't generally extend my vim far enough for it to really be considered an IDE
06:39:14 <Kaidelong> maybe I should
06:39:22 <kuribas> The difference is that emacs doesn't work "out of the box".
06:39:29 <bernalex> you can make vim a full-blown IDE like Eclipse and NetBeans if you relly want to. personally I like to use BASH for most things not pertaining to editing code.
06:39:52 <bernalex> so I have a window with BASH for running GHC or whatever, and just edit code in a vim window.
06:40:25 <bernalex> kuribas: yes, but that's the good thing for us powerusers. we want to be in control. instead of learning how to use a program, we teach the program how we want to use it. :-)
06:40:49 <kuribas> true
06:43:31 <Kaidelong> what cross-compilation support does GHC have at this point?
06:43:34 <mbrock> Emacs is very much an IDE for Emacs Lisp, in much the same way that, say, Squeak is a Smalltalk IDE.  That kind of dynamic, live IDE is much more worthy of the name than most IDEs!
06:43:41 <Kaidelong> C libraries on windows is just really awkward
06:44:00 <Kaidelong> so it seems like it might be better to develop on linux, cross compile to windows, test on Wine
06:44:18 <bernalex> mbrock: especially with slime
06:45:03 <Kaidelong> mbrock: now I'm thinking about developing haskell using Squeak
06:45:17 <Kaidelong> it would be a huge project to get that working but it might be fun
06:45:26 <Kaidelong> smalltalk is one of the nicest languages I've used
06:46:04 <Kaidelong> and squeak is an awesome environment
06:46:04 <osa1> is there a way to see TH generated code?
06:46:21 <bernalex> osa1: yes.
06:46:27 <osa1> bernalex: how?
06:46:34 <bernalex> I don't remember.
06:46:57 <bernalex> osa1: Language.Haskell.TH.Ppr seems to be one
06:47:11 <bernalex> osa1: oh, I was thinking about --dump-splices
06:47:24 <zq> do any of the *parsecs provide a built-in way to match a fixed number of repetitions of "m `sepBy` sep"?
06:47:32 <bernalex> osa1: Dump TH spliced expressions, and what they evaluate to
06:47:38 <bernalex> man ghc. :-)
06:47:52 <zq> in particular attoparsec since efficiency is a concern
06:49:06 <osa1> bernalex: yeah that worked. though generating whole page with splices replaced would be more preferable
06:59:08 <piezo> zq: no, you have to roll your own
06:59:43 <piezo> zq: (:) <$> m <*> replicateM (n-1) (sep *> m)
06:59:52 <zq> oh come on
07:00:01 <zq> i was just in the middle of thinking it out myself :p
07:00:26 <piezo> zq: sorry :p
07:00:48 <zq> piezo: i had a stupid recursive answer in my head, anyway. thanks.
07:00:54 <piezo> zq: you can do better, not mixing monadic with applicative
07:01:47 <zq> piezo: why is that significant?
07:02:38 <piezo> zq: not really, just a matter of style :)
07:04:30 <zq> piezo: well applicative is a generalization of monad, right? so monad ops could in theory exclude a few special cases
07:04:57 <zq> just wondering what those cases could look like
07:05:14 * hackagebot himpy 0.5.0 - multithreaded snmp poller for riemann  http://hackage.haskell.org/package/himpy-0.5.0 (pyr)
07:05:42 <piezo> no, monads generalize applicatives
07:12:38 <exicer> Has anyone got any experience using haskell for numerical computing ?
07:35:16 <kuribas> exicer: try #diagrams, someone there was writing a book about it
07:36:51 <byorgey> exicer: talk to cinimod
07:37:05 <byorgey> doesn't look like he's logged in right now
07:37:28 <byorgey> exicer: http://idontgetoutmuch.wordpress.com/
07:38:56 <byorgey> oh, looks like he just wrote a new post *today* =)
07:40:18 * hackagebot wai-route 0.1.0 - Minimalistic, efficient routing for WAI  http://hackage.haskell.org/package/wai-route-0.1.0 (romanb)
07:53:20 <Kron> oh god this blog post is huge
07:54:17 <Kron> it even has a bibliography
08:06:02 <epredator> hello :)
08:06:16 <klrr_> hi
08:07:31 <epredator> i've got a problem. I must create haskell based server HTTP with cgi scripts
08:08:03 <epredator> but my scripts must use post HTML methods and JavaScripts code
08:08:28 <epredator> do you know how to create somthing like this in haskell?
08:10:21 <nect> you could try an established framework and follow some of the tutorials, http://snapframework.com/docs/tutorials/snap-api
08:12:58 <epredator> i read about YESOD but i dont found any JavaScript/AJAX implementations in code
08:13:31 <klrr_> julius it's called
08:13:39 <klrr_> it's part of shakespear, its templating system
08:14:01 <klrr_> also, there is #yesod for yesod specific qusetions
08:28:32 <exicer> byorgey, kuribas: Thanks.
08:28:38 <rgr> noob alert. going through learnyouahaskell the example "length' xs=[sum 1|_<- xs]" triggers the following when I run it with a "parameter". I'm assuming its something really silly on my part but I cant see it. http://dpaste.com/1601496/
08:29:28 <zrho_> it's length' xs = sum [1 | _ <- xs]
08:29:51 <zrho_> sum :: Num a => [a] -> a sums up all the elements of a list
08:30:11 <zrho_> the idea of length' is then to produce a list with a 1 in it for each element of xs and then sum up all the ones
08:30:34 <merijn> rgr: Your calling "sum 1" inside the list comprehension
08:30:43 <merijn> rgr: '1' is not a list and sum wants a list, so it complains
08:31:53 <rgr> oh jesus... code blind! So sorry.
08:32:40 <zrho_> No need to apologize; that
08:32:48 <zrho_> 's part of what this channel is for
08:33:55 <merijn> rgr: The error is a bit confusing due to the way numeric literals work in Haskell
08:34:54 <merijn> rgr: (i.e. numeric literals are treated as having type "Num a => a", so any numeric type. This allows others to implement new numeric types in libraries, but unfortunately cause this to error with "there is no Num instance for lists" instead of noting that you're passing a number to something expecting a list)
08:34:58 <kuribas> omg wtf noob!  Actually most errors are like that when you finally see them...
08:35:14 <rgr> yeah. thanks.
08:39:17 <rgr> in "removeLowerCase st= [c|c<-st,c `elem` ['A'..'Z']]" what is the correct term for `elem` ?
08:39:34 <rgr> infix function?
08:39:54 <zrho_> yes
08:40:54 <rgr> and its done like that specifically why? (ie as opposed to "elem a b")
08:41:26 <simukis_> rgr: in some cases it produces more beautiful/easier to read code.
08:41:34 <enthropy> because people say "a is an elem of b"
08:41:34 <rgr> thats fair enough.
08:41:40 <rgr> fine.
08:43:03 <rgr> Now last bit of noob hysteria I hope. When you're in your ide/editor of choice (Im currently using emacs and haskell-mode) when I see a function like "elem" or "mybigfunctioname" I can see its type definition immediately. But how do I know where its from and, as a result, where to find the correct API documentation for it?
08:43:27 <merijn> rgr: Usually hoogle is a good start
08:43:30 <kuribas> Also it looks a bit like the mathematical symbol.
08:43:39 <amalloy> rgr: for the same reason that "mod a b" is usually written as "a `mod` b" - it's the kind of function where, prefix-style, it's not obvious which arg is which, but putting it infix makes it easier to remember because it looks like stuff you're used to seeing
08:43:48 <merijn> rgr: If you set up your cabal to always install local documentation, you can also locally browse API docs
08:43:57 <zrho_> ghci is also immensely helpful, c.f. :i
08:44:07 <rgr> merijn: cabal install?
08:44:10 <merijn> rgr: ghc-mod/hdevtools let you inspect where a value/type is from in vim, so I presume there's something similar for emacs
08:44:33 <merijn> rgr: cabal is the dependency resolver used to build & install haskell libraries
08:44:50 <merijn> rgr: If you installed Haskell Platform, you should have it already
08:44:52 <rgr> yes- I have it- How can I query it for what docs is may install?
08:44:57 <rgr> it may install
08:45:26 <rgr> I have xmonad and xmobar from cabal. I assume haskell is from the debian repos.
08:45:41 <rgr> yes it is
08:45:54 <merijn> rgr: You probably want to add the following two 2 lines to ~/.cabal/config (before you regret doing so 3 months from now :): "library-profiling: True"
08:46:00 <merijn> and "documentation: True"
08:46:10 <rgr> and then cabal update?
08:46:17 <FreeFull> Documentation is really nice to have
08:46:22 <merijn> rgr: No, you can just leave it at adding those
08:46:53 <merijn> rgr: When you install new things in the future it will also build a profiling version (else 3 months from now you want to debug something and you need to recompile *everything* to get profiling versions)
08:47:12 <merijn> rgr: "Documentation: True" tells cabal to also build and install documentation for every library you install
08:47:33 <merijn> I dunno where it's put under linux, someone else here can probably tell you
08:47:42 <rgr> but for stuff like enum thats a base haskell library documention element that should be already installed I guess.
08:48:07 <merijn> rgr: Probably, you can never be sure, linux distros love splitting up haskell package into separate bits and breaking things
08:48:53 <merijn> rgr: Anyway, to find things you usually either use hoogle (which indexes a part of hackage) or use ghc-mod/hdevtools (via whatever emacs plugins exist) or ghci to find out where something is from and then you can open the local docs
08:49:28 <rgr> so many components. It's quite confusing to know whats what. hoogle and hayoo indeed... ;)
08:50:23 <maurer> Hm, looks like Peaker alread left, just saw that he noticed my lib
08:50:53 <maurer> In any case, the thing he wants to do I have code for, but it runs on top of that lib, it's not in the lib directly
08:51:09 <rgr> ok I was missing hdevtools
08:51:55 <merijn> If you load a file you can also just do ":i symbol" to get the type, origin, etc.
08:52:05 <merijn> s/load a file/load a file in ghci
08:52:17 <rgr> :i length'
08:54:03 <rgr> ok thanks. I also just found this which addresses lots of other little niceties. many thanks. https://www.fpcomplete.com/blog/2013/12/api-emacs
08:55:07 <merijn> lambdabot only implements :t, not the other ghci commands :)
08:56:32 <identity> merijn: What does cabal do with documentation for libraries when sandboxed?
09:02:11 <absence> i've been looking at reactive-banana and all the sample code i've found seem to be all about IO actions and implicit time. if i instead have an audio buffer and want to process the samples using an frp network, how would i set that up? i guess the timestamps would get all screwed up if i used newAddHandler and and mapM the handler over the sample buffer
09:04:07 <supki> identity: it stores docs in .cabal-sandbox/share/doc
09:04:17 <identity> supki: Ah, I see.
09:04:55 <exicer> I've been messing around with persistent. It seems to me (I am probably wrong) that it gets very clunky to use with multiple tables/joining. I know you can use esqueleto, but the results are ugly tuples. Is there any way around this problem ?
09:04:58 <supki> the only difference, AFAIU, is cabal does not generate the index file when sandboxed
09:05:09 <supki> which is a blessing
09:07:27 <zebr> hi all. in quickcheck, i want to say that (prop1 ==> prop2), such that either prop1 fails or both prop1 and prop2 hold. but the (==>) i can find needs a Bool as its first argument. anyone know what i ought to do?
09:09:20 <quchen> zebr: I'm not sure this exists on its own, but you should be able to easily build it using (.||.) and (.&&.).
09:09:28 <quchen> See http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Property.html
09:10:17 <rgr> groan. loads of cabal version errors. I guess I need to cabal install cabal.
09:12:35 <rgr> could not find module Prelude.
09:13:25 <Peaker> does anyone have any general recommendations regarding Haskell and database packages/APIs?  Regarding network-accessed DBs with support for transactions like "exclusively create/get a key/row" that let me enforce just one entity gets to create a particular row
09:17:53 <rgr> installing ghc-dynamic hasnt helped either. Debian. Any suggestions?
09:18:46 <identity> rgr: Did you install haskell platform from the debian repos?
09:18:50 <identity> which ghc version do you have?
09:19:13 <klrr_> parse errors in haskell are scaaary =o
09:19:30 <rgr> from the repos yes.
09:19:47 <rgr> 7.6.3
09:19:59 <identity> hmm. What are you trying to accomplish exactly?
09:20:09 <quchen> klrr_: "Parse error: no" ‚Üê that kind?
09:20:13 <rgr> cabal installing things. it says missing prelude.
09:20:41 <rgr> It was working. But when I changing the profile and documention flags in the config and then tried cabal installing xmonad again it fell over.
09:20:51 <identity> rgr: yeah, that sounds really bad if it's missing prelude
09:20:59 <identity> did you by chance install haskell packages from the repos as well?
09:22:22 <rgr> I have no idea to be honest. Not explicitly. ghc yes.
09:22:50 <rgr> prelude is installed as part of ghc?
09:22:53 <identity> rgr: Hmm? You should've gotten cabal and ghc with the haskell-platform
09:23:16 <Twey> Prelude is part of the base package, which comes with GHC
09:23:39 <Twey> Perhaps your Cabal and GHC versions are mismatched?
09:24:14 <rgr> Iyouve just solved it. I had ghc but for some reason "haskell-platform" wasnt -- maybe it got cleaned out inadvertently earlier as I was unplumbing gnome.
09:24:21 <identity> When shit really hits the fan with cabal and friends, the best course of action is often just to reinstall the whole shebang.
09:24:37 <identity> rgr: Did you just install haskell-platform on top of ghc?
09:24:44 <rgr> oh god...
09:24:50 <rgr> sob. I'm confused now.
09:25:08 <rgr> you mean haskell-platform and ghc are not friends?
09:25:33 <identity> rgr: They are, kind of. But you are basically installing packages on your system that may not work well together or even mess with each other
09:26:00 <rgr> ok. please advise me what to do. Do I need haskell-platform for prelude or not?
09:27:04 <identity> rgr: Try doing something like: sudo apt-get remove --purge haskell-platform && sudo apt-get remove --purge ghc cabal && sudo apt-get install haskell-platform && cabal update && cabal install cabal-install
09:27:07 <rgr> is ghc a different version of "ghc" (which I thought was the haskell compiler) than what would be in haskell-platform?
09:27:10 <identity> The last step may not even be necessary
09:27:14 <rgr> ok identity will do
09:27:48 <identity> rgr: They haskell platform is ghc and cabal and a few packages that are considered useful, or something like that. GHC itself just comes with base(which is a package) and probably some other stuff -- I don't know much about it
09:28:13 <identity> but in general, you want to install the haskell platform wich gives you the compiler and cabal, and then use cabal to install packages from hackage that you may want to use
09:28:45 <k00mi> haskell platform is a set of important libraries with fixed versions
09:29:15 <identity> ^
09:30:11 <rgr> ok
09:30:22 <dawik> i wish there was something like cabal for erlang
09:30:41 <rgr> should I cabal install cabal ?
09:30:42 <dawik> ..that is just as functional and adopted..
09:31:27 <klrr_> quchen: not that scary :p
09:31:39 <rgr> o cabal-install.
09:31:41 <identity> rgr: no, cabal comes with the haskell platform. however, it is sometimes updated, in which case you update cabal-install with cabal
09:35:30 <benj_> you'll want to make sure your cabal bin directory is on your PATH, to use the new cabal binary that you install with cabal
09:37:06 <rgr> that all appears to be progressing smoothly. Wow what a mess it was though. thanks identity !
09:37:31 <xDie> @slap all
09:37:31 * lambdabot slaps all
09:37:57 <rgr> yeah it was cabal was working fine.
09:38:08 <rgr> just libs were all over the shop for some reason.
09:38:28 <identity> rgr: Is the installation done?
09:38:31 <identity> apt-get, that is.
09:38:59 <rgr> yeah Im rebuilding xmonad etc now
09:39:21 <identity> rgr: I see. What do you get if you type "which cabal" in your terminal?
09:39:37 <rgr> my local .cabal one
09:39:43 <identity> excellent. then you're set.
09:39:51 <rgr> but that was the case before too.
09:39:57 <identity> ah.
09:40:18 <identity> well, all that matters is that you're using the right one.
09:40:46 <rgr> I suspect but dont know that while i was deleting loads of gnome fluff I inadvertently fd something up earlier today.
09:41:05 <rgr> well,thanks to your claming influence its up and running again now ;)
09:41:05 <rgr> calming even...
09:41:59 <xDie> haskell is the best language of world
09:42:28 <xDie> i need that any fuckme my ass
09:43:30 <joelteon> pardon?
09:43:30 <identity> GUARDS!
09:43:42 <xDie> jajaja
09:43:42 <xDie> hahah
09:43:45 <xDie> perdon?
09:43:52 <xDie> alguien habla espaÒol
09:44:30 <Cale> xDie: Please stay polite and on topic if you could.
09:45:00 <rgr> who would have thought a nym like xDie would be so contrary ;) lol...
09:46:17 <xDie> ok Cale
09:46:17 <xDie> rgr, Xd
09:46:17 <xDie> im gae
09:46:17 <xDie> and programming in haskell
09:46:17 <identity> The joy of being 13 years old.
09:46:17 * hackagebot smallcaps 0.4.1.1 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4.1.1 (StefanBerthold)
09:46:17 <rgr> jolly good.
09:46:17 <xDie> lambdabot, is my friend
09:48:04 <hakujin> how can I get more helpful error messages from attoparsec? I'm using <?> to name the parser and I don't see my name in the error message.
09:48:42 <Cale> Perhaps it wasn't expecting to use that parser somehow?
09:49:25 <hakujin> this isn't one of those attoparsec/parsec quirks, right? assuming I use <?> correctly it will appear in attoparsec's error string?
09:53:50 <johnw> yes, it should work hakujin
09:54:11 <hakujin> johnw: thanks. I will keep prodding.
09:54:36 <johnw> I think the parser will have to consume at least one token before <?> will name that parser, though; but that's really just a guess
10:00:23 <zq> how much does an electron go for these days
10:00:56 <johnw> I usually buy them in bulk
10:15:31 <byorgey> given the average price of electricity around here, assuming a 120V supply (based on http://ca.answers.yahoo.com/question/index?qid=20100819193139AAOd1nZ), it looks like I pay about 8.9e-25 USD per electron
10:15:41 * hackagebot git-annex 5.20140210 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140210 (JoeyHess)
10:16:27 <byorgey> of course given that it's alternating current I guess it's really the same electrons going back and forth?  what a ripoff.
10:16:53 * shachaf wonders whether joeyh is around.
10:17:29 <joeyh> yes, I'm here
10:17:33 <johnw> hey joeh
10:17:35 <johnw> joeyh
10:17:37 <joeyh> also on #nixos
10:21:18 <shachaf> joeyh: You should think twice about using that encryption thing whose name I've forgotten.
10:22:10 <joeyh> telehash?
10:22:50 <shachaf> That one.
10:23:30 <shachaf> Or maybe you have thought twice. But some parts of the protocol seemed very suspicious to me.
10:24:55 <joeyh> well, I have not reviewed the encryption in detail. I'd be interested to hear your take
10:26:10 <shachaf> I don't remember many details now.
10:27:10 <shachaf> But for instance it does all this fancy key-exchange business and then uses no authentication on the actual line packets at all.
10:27:19 <joeyh> I'd probably try to get Daniel Khan Gilmor or someone else I trust to review the encryption before I use it, but there's not even a usable implementation yet (aside from node.js)
10:27:49 <shachaf> (In CTR mode, so you can xor whatever you want against it.)
10:29:09 <shachaf> Things like "SHA-256 hash the public elliptic key to form the encryption key for the inner packet" also seem pretty odd.
10:29:12 <joeyh> hmm, I thought that the packets didn't have any crypto in them because they're in turn wrapped in other packets that do the authentication
10:29:38 <shachaf> Are they? Where?
10:31:06 <joeyh> line packet
10:31:18 <jfischoff> who goes by roche in reddit?
10:31:59 <shachaf> Feuerbach_
10:32:45 <jfischoff> ah
10:32:50 <shachaf> joeyh: What do you mean?
10:33:07 <joeyh> https://github.com/telehash/telehash.org/blob/master/protocol.md#line---packet-encryption
10:35:25 <shachaf> Which part do you mean for the authentication?
10:35:42 <skypers_> hi
10:35:51 <skypers_> I need some help to get into monad-control
10:36:08 <skypers_> I write the typical use case with StateT and lift
10:36:19 <skypers_> now I‚Äôd like to get the same for monad-control
10:36:28 <skypers> I read about RunInBase
10:36:34 <skypers> what‚Äôs that actually?
10:36:41 <skypers> the base monad is‚Ä¶ which one again?
10:37:00 <joeyh> shachaf: well, the line is first opened, and the open uses the RSA public key for auth
10:37:47 <magneticduck> say I have a random haskell function <2DPosition> -> <Color>, and I want to use it to draw an array of pixels to an openGL framebuffer. Granted the function runs fast enough, what's the fastest way of doing that?
10:38:01 <magneticduck> I tried rendering primitive polygon after primitive polygon, but for some reason it's *really slow*
10:38:23 <magneticduck> like, for fairly large arrays (pixel = 10 by 10 pixel block)
10:39:01 <magneticduck> I'm reading a bunch of openGL literature and stuff, but I haven't found anything that directly answers this question
10:39:13 <shachaf> joeyh: What prevents someone from tampering with the line packets?
10:39:26 <magneticduck> I've figured out how to pixelate any already-drawn framebuffer (or something)
10:40:00 <Feuerbach_> what's up shachaf
10:40:07 <shachaf> Feuerbach_: 10:27 <jfischoff> who goes by roche in reddit?
10:40:15 <Feuerbach_> ah
10:40:30 <magneticduck> anyway, anybody have any ideas?
10:40:32 <magneticduck> I'm stumped
10:40:37 <magneticduck> I'm not sure if it's possible
10:40:46 <magneticduck> maybe multithreaded things are the answer? maybe that's simply a bad idea?
10:41:08 <magneticduck> I mean, come on, it *has* to be possible
10:41:13 <magneticduck> it's a pretty simple problem
10:41:31 <magneticduck> render an array of pixels defined by a fast function to the screen in less than a 60th of a second
10:41:36 <magneticduck> is it *that hard*?
10:41:46 <magneticduck> (I mean, big pixels)
10:42:48 <joeyh> shachaf: "The BODY is a binary encoded encrypted packet using AES-256-CTR with the encryption key that was generated for the line"
10:43:07 <pjdelport> magneticduck: maybe this is a good question for SO or reddit?
10:43:23 <magneticduck> :|
10:43:25 <pjdelport> (with your code so far)
10:43:31 <magneticduck> I'll reddit it
10:43:34 <shachaf> joeyh: Right. Which means that it's the plaintext xored with the CTR keystream.
10:43:58 <shachaf> So if I know anything about the plaintext I can xor my own thing with it and change it to say whatever I want.
10:44:07 <joeyh> ok, block ciphers are where my crypto stops
10:44:15 <joeyh> all I know is they're easy to get wrong :)
10:45:38 <shachaf> Everything is easy to get wrong.
10:45:39 <joeyh> doesn't the IV guard against that?
10:47:36 <schell> magneticduck: i'd try looking at JuicyPixels
10:48:12 <shachaf> The way CTR mode works, roughly, is: You encrypt the IV (128 bits) to get a 128 bit "keystream" block. Then you encrypt IV+1 to get another 128 bit block. And so on.
10:48:16 <schell> create an image, iterate over the position to produce the pixels and then buffer the data into a texture
10:48:28 <shachaf> Then you xor the keystream blocks with the plaintext to get the ciphertext.
10:48:42 <c_wraith> oh.  Yeah.  if you use CTR mode, you absolutely *must* authenticate the data.
10:48:46 <shachaf> Then to decrypt you do the same thing.
10:49:05 <joeyh> ok, I'll certianly buy you have a hole there
10:49:06 <shachaf> The IV is public knowledge. It only exists so that you don't get the same keystream each time (you must never reuse it).
10:49:09 <c_wraith> Though to be fair, there are attacks on CBC when you don't authenticate the data as well
10:49:09 <shachaf> Maybe this conversation would be better ##crypto.
10:49:15 <schell> magneticduck: you may not even need juicy pixels
10:49:20 <shachaf> There are attacks on just about anything if you don't authenticate the data.
10:49:21 <c_wraith> so really, you *always* need to authenticate data
10:49:33 <c_wraith> And this is where newer modes like GCM come into play
10:49:37 <shachaf> Authentication isn't really optional in a protocol like this.
10:49:41 <c_wraith> They authenticate for you.
10:50:00 <c_wraith> Authentication isn't optional in any secure use of encryption.
10:50:46 <shachaf> c_wraith: http://cr.yp.to/snuffle/design.pdf made some reasonable arguments for keeping authentication separate.
10:51:15 <c_wraith> Yeah, I have nothing against keeping it separate, so long as you do it.
10:51:21 <schell> just create an array of pixels as [CInt] or whatever seems best to you and then user `withArray` to send that data with `texImage2D`
10:51:40 <c_wraith> But authentication of the data is never optional, and should always be done *before* the decrypted data is processed.
10:52:10 <c_wraith> If you attempt to stream process decrypted data and then check it at the end, you open yourself up to timing attacks
10:52:20 <shachaf> In a case like this it should probably be done as part of a library that does all this for you and gets it right.
10:52:57 <shachaf> I'm saying that it didn't really look like telehash is this library, when I looked at it.
10:52:59 <c_wraith> I couldn't convince the author of the AES-GCM package on hackage that his design is broken because it allows naive users to use the decrypted data without verifying it.
10:53:10 <c_wraith> I really tried.
10:53:47 <c_wraith> oh, I thought we were in -blah.  I didn't realize how off-topic I was.  Sorry.
10:54:07 <shachaf> thoughtpolice: How's that NaCl binding going?
10:55:04 <johnw> c_wraith: it happens
10:55:47 <kazagistar> how lazy is haskell's sort? is (head . sort) seems like it could have an average case linear time if you use quicksort‚Ä¶
10:55:58 <S11001001> kazagistar: it's heapsort
10:56:16 <c_wraith> errr.  Last I checked, it was a merge sort.
10:56:21 <monochrom> I haven't proved it, I think it is linear time
10:56:50 <S11001001> c_wraith: Could be.  Was heap when I looked, like 3-4 years ago at this point.
10:57:22 <c_wraith> Looks like a merge sort to me..
10:57:23 <kazagistar> wouldn't the heap have to add all the items to get the smallest one, resulting in O(N*log(N))?
10:57:26 <c_wraith> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#sort
10:57:52 <geekosaur> were you looking at ghc's implementation or the report prelude?
10:58:09 <c_wraith> GHC's
10:58:18 <geekosaur> I meant S11001001
10:58:23 * shachaf wonders how heapsort would work in Haskell.
10:58:38 <joeyh> shachaf: https://github.com/telehash/telehash.org/issues/23
10:58:45 <S11001001> geekosaur: would have been the former
10:59:40 <S11001001> Eh, never mind.  Clearly I cannot have seen heapsort, because I remember that email message that's quoted in that source from when I looked.
11:00:17 <kazagistar> c_wraith: i'm trying to think‚Ä¶ wouldn't a mergesort also have a O(N*log(N)) complexity for (head . sort)
11:00:50 <c_wraith> kazagistar: That's a tougher one, but not so long as merges are properly incremental
11:01:39 <c_wraith> kazagistar: it's a bottom-up merge sort.  Getting the head of the sorted list requires getting the head of each sublist, recursively.
11:01:58 <kazagistar> I'm just in a case where most of the time, I just want to know one or two of the highest items in a list, but sometimes I need more, and I access each list many times
11:01:59 <c_wraith> kazagistar: at the bottom level, that's n/2 comparisons.  At the next level, it's n/4, etc
11:02:12 <c_wraith> kazagistar: the limit of that computation is O(n)
11:02:55 <kazagistar> c_wraith: right cool, I guess I am just tired right now‚Ä¶ thanks :D
11:03:00 <shachaf> joeyh: OK, that's one issue out of n.
11:03:38 <joeyh> yeah
11:03:41 <shachaf> I agree that it needs an expert to look at it carefully before it's reasonable to use it. I'm not an expert.
11:03:57 <shachaf> Is there a particular reason to use this library in the first place?
11:04:09 <joeyh> I don't know of anything else solving the same set of problems
11:05:02 <rgr> more dumbness but I not quite seeing the partitioning/relatinship between hoogle and hayoo. is hayoo simply a web interface to hoogle generated data?
11:05:58 <geekosaur> hoogle does type directed searches better, hayoo does name directed searches better, more or less
11:06:13 <Fristi> Hello
11:06:15 <johnw> geekosaur: recently hoogle is much better at name directed searches
11:06:23 <geekosaur> also the default hoogle is rather limited whereas hayoo indexes all of hackage (but fpcomplete has a whole-hackage hoogle)
11:06:28 <johnw> geekosaur: I'm not sure if the default server instance is using the latest version, but fpcomplete.com/hoogle does
11:06:37 <johnw> (and fpcomplete.com's hoogle indexes all of stackage)
11:06:39 <rgr> so they are not the same thing in different dresses?
11:07:00 <c_wraith> hayoo is sort of a tech demo for their map/reduce system, iirc
11:07:02 <Fristi> i am trying to install eclipseFP on macosx maverciks
11:07:34 <Fristi> however buildwrapper fails to install , due regex-tdfa failure
11:08:04 <rgr> but hayoo isnt something I can cabal install like hoogle and related data?
11:08:10 <johnw> yeah
11:08:13 <johnw> (sorry)
11:08:47 <c_wraith> Fristi: and why does regex-tdfa fail to install?
11:09:11 <Fristi> No instance for (Extract (Seq Char))
11:09:19 <Fristi> Text/Regex/TDFA/Sequence.hs:46:10
11:09:26 <Fristi> version 1.2.0
11:09:31 <c_wraith> Sounds like a semigroupiods version issue.
11:09:55 <Fristi> let me see
11:09:57 <c_wraith> err, no it's not.  got confused between extract and extend
11:10:22 <rgr> yes I can? Im just trying to get soething going where I can read the documentation for a base function like "sum" for instance locally in an emacs buffer. a local hoogle command lists all the defintions containing "sum" but thats about it.
11:10:35 <c_wraith> Fristi: it does sound like a version issue with dependencies, though
11:11:02 <Fristi> myea , tried install version regex-tdfa 1.1.8
11:11:04 <Fristi> that worked
11:11:45 <johnw> rgr: Hoogle has a command-line option to show the docs for the first hit: --info
11:11:52 <Fristi> i dont know if it is possible to make buildwrapper work with that version.. seems cabal install buildwrapper reinstalls all dependencies up to the newest versions
11:11:58 <Fristi> is there anyway to work around that?
11:14:19 <DrAwesomeClaws> hey folks.  Making progress on my little irc bot, but running into some resistance trying to figure out how to implement functions that are time dependent in various ways.  One example: I want to rate-limit the bot's ability to send messages to the network in some situations.  Like I want to implement a Queue of messages and dispatch a message from the queue every t timesteps.  Should I use Control.Monad.St
11:14:20 <DrAwesomeClaws> ate to somehow implement a "globally" available queue?  I think my brain is still stuck in imperative land.
11:16:01 <c_wraith> Fristi: Yes, but it's probably painful.  You'll probably have to wipe your package database, and experiment with constraining package versions until you finally find a combination that works.
11:16:36 <Fristi> ai ai , is there anything else i could do?
11:17:25 <c_wraith> Fristi: not that I know of.  When things don't have accurate bounds, the situation is really ugly.
11:18:08 <rgr> johnw: thanks. had to wrap it in its own script and change haskell-hoogle-command but now works. cool. thanks.
11:18:17 <Fristi> c_wraith: i'll see how things work out on my ubuntu install :) thanks for the help
11:19:02 <schell> DrAwesomeClaws: you might want to try creating a list of things to send, storing that list in an MVar and then using forkIO to spawn a process that reads the head off the list, prints it to irc then does threadDelay - rinse and repeat?
11:19:03 <jkarni> have there been any changes in the landscape that have made getting around identical instance head (with, however, different constraints) any easier than this: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap ?
11:19:07 <c_wraith> DrAwesomeClaws: Control.Monad.State is basically useless there.  You want concurrent access to mutable state.  Control.Monad.State doesn't give concurrent access or mutable state.
11:20:09 <jkarni> in particular, not having to have a dummy class that matches up (instances are all the same) as the constraints you're trying to use?
11:20:09 <DrAwesomeClaws> thanks schell and c_wraith.  I'll probably do that then, I was reading about MVars earlier.
11:20:19 <schell> :)
11:20:33 <c_wraith> DrAwesomeClaws: you might look at Chan, too.  It corresponds to queues nicely.
11:20:40 <schell> DrAwesomeClaws: let me know if that works, and if not, how you solved it
11:22:03 <DrAwesomeClaws> my plan before asking was somehow implementing Control.Monad.State in such a way where each state is an Int timestamp and the next state was the previous state  + delayInterval  ... using that basic idea to kind of make things "tick", haha
11:22:21 <DrAwesomeClaws> but that wouldn't help with the queue at all
11:28:56 <dwcook> Who needs mutable state? Just have the threads throw exceptions at each other. Problem solved.</facetious>
11:29:52 <sm> which is the proper cabal section for adding changelog files so they show up on hackage, again ?
11:30:04 <sm> extra-source files ? other-files ?
11:30:11 <c_wraith> dwcook: as if the async exception mechanism isn't mutable state in the RTS. :P
11:30:23 <c_wraith> sm: It should be other-files
11:30:30 <c_wraith> sm: it just needs to be included in the package
11:30:31 <dwcook> c_wraith, one of the reasons I was being facetious :D
11:30:46 <dwcook> s/reasons/explanations for why/
11:30:48 <dwcook> Wait no
11:30:50 * hackagebot HTF 0.11.2.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.2.1 (StefanWehr)
11:31:04 <dwcook> ways in which, there we go
11:31:12 * dwcook forgot how to English
11:31:22 <sm> c_wraith: thank you
11:39:39 <joeyh> shachaf: their followup to the bug seems reasonable (ish)
11:50:52 * hackagebot ipopt-hs 0.4.0.1 - haskell binding to ipopt and nlopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.4.0.1 (AdamVogt)
11:53:11 <sm> c_wraith: actually, other-files seems to have been deprecated in favour of extra-source-files
11:53:32 <solrize> @hoogle MonadPlus m => Bool -> a -> m a
11:53:33 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
11:53:33 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:53:33 <lambdabot> Control.OldException assert :: Bool -> a -> a
11:58:03 <exicer> I posted a question about persistent/esqueleto on SO: https://stackoverflow.com/questions/21686579/haskell-persistent-joins-with-esqueleto
11:58:10 <exicer> Would appreciate it if anyone could help me!
12:00:43 <johnw> exicer: I believe you can just return the constructed aggregate type from your select
12:00:49 <johnw> instead of returning a tuple and then converting it
12:01:05 <johnw> i mean, it's just a monad after all, it doesn't care what value you return from it
12:01:23 <exicer> johnw: That is true
12:01:25 <exicer> :p
12:01:51 <exicer> It just seems a bit redundant to have to define these things effectively twice
12:02:37 <johnw> well, you have two different data models here
12:02:48 <johnw> one is in normal form, the other is a set of linked structures
12:03:29 <exicer> True, true. Other orm type things (in python for instance) provide this kind of functionality
12:03:45 <johnw> btw, it is usually the job of more "high-level" ORM systems to translate between these two automatically (by generating the conversions for you), but they come with annoying amounts of metadata you need to specify to describe the relations
12:04:09 <johnw> what about using something like acid-state, instead of SQL?
12:04:17 <johnw> then you don't need to deal with normal form
12:04:20 <exicer> I've never actually used acid-state
12:04:30 <exicer> To be honest I'm pretty much a haskell beginner
12:04:47 <johnw> acid-state is for when you want all of the data to be in memory, you simply need to persist it between runs
12:04:52 <exicer> I had a quick look, but couldn't find a good tutorial or anything for acid-state
12:05:37 <exicer> johnw: How would that work if you had large, production scale databases ?
12:05:43 <johnw> it wouldn't
12:05:48 <exicer> Ah :)
12:10:36 <l8star___> hi
12:11:25 <magneticduck> lol reading through a large package's source to scavenge some code is... well, fun isn't the word
12:17:52 <magneticduck> oh wow I had no idea "data families" exists
12:17:54 <magneticduck> existed*
12:18:06 <magneticduck> well. I just learned a new thing about haskell.
12:18:47 <tac> There's a lot of Haskell
12:18:55 <tac> You don't need all of it, and it isn't all equally important.
12:18:58 <haasn> data families don't exist in Haskell(tm)
12:19:03 <magneticduck> I mean, I know there is a lot of imporant stuff written in haskell
12:19:17 <magneticduck> but, "atomic" aspects of the haskell *language*...
12:19:22 <magneticduck> every once and a while I find a new one
12:19:27 <magneticduck> and I'm taken aback a bit
12:19:29 <johnw> i'm always finding new ones
12:19:57 <magneticduck> s/imporant/interesting and powerful
12:20:54 <magneticduck> haasn: I don't understand language extensions :D
12:21:00 <magneticduck> I mean, I get what they are
12:21:05 <magneticduck> but I appreciate simplicity
12:21:16 <magneticduck> having all these strange language extensions running around... ick
12:21:25 <kazagistar> I can't seem to find a !!-like list function that returns Maybe instead of crashing on out of bounds‚Ä¶
12:21:34 <johnw> see the 'safe' package
12:21:58 <johnw> it's called atMay
12:23:03 <johnw> :t find
12:23:04 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:24:20 <ParahSailin> :t lookup
12:24:22 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:25:04 <ParahSailin> @src (!!)
12:25:04 <lambdabot> xs     !! n | n < 0 = undefined
12:25:04 <lambdabot> []     !! _         = undefined
12:25:04 <lambdabot> (x:_)  !! 0         = x
12:25:04 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:25:32 <skypers> still no one to explain me monad-control, especially what is a the base monad?
12:25:37 <skypers> woah ParahSailin
12:25:49 <skypers> I thought literals weren‚Äôt ctors
12:25:54 <skypers> they seem to be
12:25:58 <geekosaur> huh?
12:26:15 <skypers> I‚Äôd have expected something with guards
12:26:23 <Twey> skypers: (:) is not a literal
12:26:36 <skypers> ?
12:26:44 <Twey> It's just the name of an infix constructor
12:26:54 <skypers> you can see that there‚Äôs a pattern matching on the Int parameter
12:26:59 <skypers> I do know what !! is.
12:27:48 <Twey> Oh, right.  Yes, integer literals aren't constructors, but you can pattern-match on them and they use the relevant (==) instance
12:27:59 <skypers> sooooo
12:28:03 <skypers> something like
12:28:07 <frx> only integer literals?
12:28:16 <johnw> string literals work too
12:28:24 <johnw> and Text and ByteString, if you are using OverloadedStrings
12:28:31 <skypers> foo a = case a of 0 -> tic; _ -> toe
12:28:32 <skypers> is like
12:28:42 <skypers> foo a | 0 = tic | otherwise = toe
12:28:43 <tac> skypers: thank you for sparing me
12:28:43 <skypers> ?
12:28:50 <skypers> oh :D
12:28:53 <skypers> sorry ahah
12:28:57 <Twey> Haha
12:29:13 <frx> I would expect it to work for all types that implement Eq and that have a literal syntax
12:29:15 <Twey> johnw: How does that work?
12:29:20 <frx> are there any exceptions?
12:29:26 <skypers> frx: I wouldn‚Äôt
12:29:32 <johnw> Twey: case foo of "Hello" -> ...
12:29:33 <skypers> pattern matching is about ctors to me
12:29:35 <Twey> johnw: An IsString doesn't necessarily have an Eq, nor is it even injective
12:29:39 <skypers> not Eq
12:29:52 <skypers> 21:25 < johnw> Twey: case foo of "Hello" -> ...
12:29:53 <frx> skypers if it works for Int and String why not for everything else
12:29:54 <skypers> this is a ctor
12:29:55 <Twey> skypers: It's just sugar
12:30:03 <Twey> skypers: It's not a constructor.
12:30:05 <skypers> frx: for String it‚Äôs because it‚Äôs a ctor
12:30:22 <frx> "string literal" is not a constructor
12:30:29 <skypers> frx: sure it is
12:30:33 <Twey> frx: It is when it's a String
12:30:34 <skypers> it‚Äôs (:)
12:30:54 <skypers> "foo" == 'f' : 'o' : 'o' : []
12:30:58 <frx> (:) is constructor, string literal is a String
12:31:16 <skypers> it‚Äôs correct pattern matching to me, except the 'f' litterals
12:31:28 <frx> but yeah, "foo" is syntax sugar for 'f':.. I get your point
12:32:11 <frx> then change my statement to "if it works for Int why not for every other type that has Eq and a literal syntax"
12:34:44 <raspz> is there a haskell IDE/editor that supports identifier completion and function argument hints?
12:34:48 <skypers> frx: yeah, now I‚Äôm with you
12:35:11 <Twey> Oh, I guess it just imposes an Eq constraint on the type
12:35:12 <skypers> I guess primary type has syntactic sugar in GHC?
12:35:44 <mirpa> raspz: Emacs has some basic (general) completion and it shows type signatures of some (standard) functions
12:37:07 <raspz> mirpa: Nothing better than that? it does not have to be emaca
12:37:18 <raspz> emacs
12:37:51 <Twey> I believe ghc-mod can show you the types of any expression
12:38:22 <Twey> The usual tools (hippie-expand &c.) will give you identifier completion, though it's not type-aware
12:38:41 <mirpa> raspz: better like what?
12:38:55 <pjdelport> raspz: have you looked at http://www.haskell.org/haskellwiki/IDEs ?
12:39:03 <Twey> The type of a function *should* be enough of a hint.  If not, please submit a patch introducing some type synonyms.  :√æ
12:39:54 <raspz> mirpa: showing type signature for all functions rather than standard ones, and identifier completion that is aware of haskell modules
12:41:10 <levi> raspz: As Twey said, ghc-mod (when integrated with your editor) will give you the type signatures.
12:41:35 <bitemyapp> I need to better integrate ghc-mod with cabal sandbox.
12:41:42 <levi> I believe hdevtools will do it as well. They are both designed for editor integration.
12:41:43 <mirpa> raspz: maybe it is my buggy settings, advanced completion might be possible with something like etags for emacs/haskell (hasktags?) ... I don't think it is worth the troubles with settings. You can do a lot with ghci.
12:42:00 <raspz> levi: mirpa said it works only for (some) standard functions
12:42:14 <levi> raspz: No, that's what haskell-mode gives you without ghc-mod
12:42:52 <mirpa> note: I have quite basic haskell mode configuration
12:43:27 <mirpa> 'cabal repl' with cabal sandbox does all the hard work
12:43:56 <levi> bitemyapp: When did you last update ghc-mod? I filed a bug with them shortly after cabal 1.18 was released, and I believe it now correctly understands the relevant sandbox config files.
12:44:16 <mirpa> I often start in ghci and then just write working, generalized code into editor
12:44:22 <mirpa> *offten
12:44:54 <raspz> just to see if we are talking about the same thing, ghc-mode gives you function signature when you type its name in the editor or repl, and it works with all functions, including your own?
12:45:57 <raspz> because I tried ghc-mode a couple of months ago and I had no such thing. maybe it was my config
12:46:03 <bitemyapp> levi: I guess I'll reinstall it, but I don't remember it "seeing" my sandboxed packages.
12:46:04 <mirpa> raspz: you can get type signature in ghci with ':t name', in emacs you just move cursor over identifier and type is echoed in small buffer ("status bar")
12:46:05 <levi> There are two components to this system; a haskell program called 'ghc-mod' that uses the GHC API to analyze your code via a command-line interface, and an emacs mode 'ghc-mode' that interfaces with the program 'ghc-mod'.
12:46:58 <raspz> mirpa I see. so it should be trivial to write elisp code that does what I want
12:47:17 <levi> bitemyapp: It's been a while since I've messed with it; I don't recall if there were other steps beyond just rebuilding ghc-mod.
12:47:37 <mirpa> raspz: look at haskell mode for emacs...
12:47:59 <levi> I know I was able to convince hdevtools to deal with cabal sandboxes despite it not understanding the configuration files itself, though. I need to remember what I had to do...
12:48:26 <mirpa> but sandboxes in cabal are rather new
12:48:41 <levi> raspz: Install haskell-mode into emacs. Install ghc-mod with cabal-install. Install ghc-mode into emacs.
12:49:11 <levi> Make sure your emacs exec path includes your .cabal/bin path as well.
12:49:57 <mirpa> http://www.haskell.org/haskellwiki/Emacs
12:50:58 <raspz> I just checked and I already have them installed since my last attempt to play with haskell, they are nearly a year old. is it worth upgrading?
12:51:21 <mirpa> check if there is new version
12:52:41 <levi> raspz: There are most definitely upgrades to haskell-mode
12:52:55 <mirpa> isn't there some comercial IDE? FP Complete or something like that...
12:53:17 <levi> Yes. It's also free for hobby use.
12:53:39 <mirpa> https://www.fpcomplete.com/business/haskell-center/overview/
12:53:48 <Clint> rgrinberg: no, you don't
12:53:54 <Clint> er
12:53:56 <Clint> how'd that happen
12:58:54 <levi> bitemyapp: It looks like flycheck-haskell is what makes hdevtools play nicely with cabal sandboxes in my configuration.
13:00:01 <bitemyapp> levi: I'm still poking at it.
13:00:04 <xintron> Should one go for Concurrent.STM or normal MVar instead?
13:00:09 <bitemyapp> xintron: KISS
13:00:14 <johnw> STM
13:00:19 <bitemyapp> xintron: why do you need an MVar?
13:00:29 <bitemyapp> johnw: rationale?
13:00:55 <bitemyapp> we don't even know their problem, AFAICT
13:01:03 * hackagebot hledger-web 0.22.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.2 (SimonMichael)
13:01:16 <xintron> bitemyapp, actually, I might not need it. Since only one thread should be able to access the handle. But other threads will be available using a Chan instead
13:01:36 <xintron> bitemyapp, but then, TChan or Chan...
13:03:09 <skypers> liftWith is similar to lift in that it lifts a computation from the argument monad to the constructed monad.
13:03:15 <skypers> I don‚Äôt understand that sentence
13:03:18 <skypers> help please! :)
13:04:37 <mornfall> skypers: which bit of that sentence? :)
13:04:45 <levi> skypers: Where'd you get the sentence from?
13:04:59 <skypers> levi: http://hackage.haskell.org/package/monad-control-0.3.2.2/docs/Control-Monad-Trans-Control.html
13:05:00 <raspz> is there a haskell sizeof equivalent? how to check how many bytes a character or a string occupies?
13:05:02 <skypers> mornfall: well
13:05:09 <mornfall> skypers: it just says lift(With) go from one monad to another
13:05:11 <skypers> :t sizeOf
13:05:12 <lambdabot>     Not in scope: `sizeOf'
13:05:12 <lambdabot>     Perhaps you meant one of these:
13:05:12 <lambdabot>       `IM.size' (imported from Data.IntMap),
13:05:21 <skypers> raspz: Foreign.Storable.sizeOf
13:05:32 <skypers> mornfall: hm
13:05:51 <skypers> I don‚Äôt understand the ‚Äúmonad argument‚Äù to the ‚Äúconstructed‚Äú monad
13:05:53 <skypers> to me
13:05:55 <mornfall> skypers: ... a x -> c x (a for argument, c for constructed)
13:06:08 <skypers> well
13:06:12 <skypers> lift already does that
13:06:15 <jle`> l
13:06:21 <mornfall> skypers: yes, just as the sentence says :)
13:06:26 <skypers> it lifts an argument monad to a constructed one
13:06:35 <skypers> ok
13:06:46 <skypers> so I don‚Äôt get the idea of that function :D
13:07:13 <levi> skypers: Are you familiar with monad transformers and the mtl typeclasses?
13:07:17 <skypers> yes
13:07:19 <skypers> I am
13:07:22 <mornfall> :t lift
13:07:23 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:07:27 <mornfall> :t liftWith
13:07:28 <lambdabot> Not in scope: `liftWith'
13:07:28 <skypers> I use them a lot
13:07:42 <skypers> @let import Control.Monad.Trans.Control
13:07:43 <lambdabot>  .L.hs:53:1:
13:07:43 <lambdabot>      Control.Monad.Trans.Control: Can't be safely imported!
13:07:43 <lambdabot>      The package (monad-control-0.3.2.2) the module resides in isn't trusted.
13:07:46 <skypers> ‚Ä¶
13:08:02 <skypers> ok, liftWith is just lift with a context?
13:08:05 <mornfall> skypers: liftWith takes a function
13:08:21 <raspz> haskell has 32 bit characters?  I thought it didnt last time I checked. o_0
13:09:13 <verement> > maxBound :: Char
13:09:15 <lambdabot>  '\1114111'
13:09:21 <dagle> "returns array{obj} a list" So, does it return a list or an array?
13:09:50 <mornfall> skypers: I guess the idea is that liftWith lets you weave control through the transformer
13:09:52 <skypers> mornfall: yes, and that function is‚Ä¶ what?
13:10:26 <levi> skypers: That sentence just describes what 'lift' and 'liftWith' both do. The difference is described later.
13:10:26 <skypers> yeah I don‚Äôt understand the idea of that function
13:10:43 <skypers> I wrote my idea of the concept
13:10:49 <skypers> with a ‚Äúpause‚Äù step
13:10:52 <skypers> an ‚Äúinner‚Äù step
13:10:57 <skypers> an a ‚Äúresume‚Äù step
13:11:04 * hackagebot generic-maybe 0.2.0.0 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.2.0.0 (JonathanFischoff)
13:11:25 <skypers> liftWith takes a function that takes a function and outputs something in a monad
13:11:49 <levi> skypers: My point is that the sentence you quoted doesn't say anything about what makes liftWith different from lift, so trying to analyze the quoted sentence probably isn't going to yield much insight.
13:12:00 <skypers> ok, thank you levi
13:12:53 <raspz> I could swear about reading a discussion how isUpper :: Char will not work for all the characters. am I mixing up languages?
13:13:16 <bitemyapp> levi: tried to use ghc-mod manually for testing, got this: "It is a member of the hidden package `course-0.1.0'. Perhaps you need to add `course' to the build-depends in your .cabal file."
13:14:05 <bitemyapp> levi: lint worked, it found an unnecessarily point-ful function :)
13:15:05 <skypers> liftBaseWith :: (RunInBase m b -> b a) -> m a
13:15:14 <skypers> I don‚Äôt actually understand ‚Äúbase‚Äù monad
13:15:26 <skypers> it might refer to the inner monad or the outer monad
13:15:28 <Twey> raspz: Char is a Unicode codepoint.  So there are ‚Äòcharacters‚Äô that are formed of more than one Char.  Other than that, no, isUpper should be fine.
13:15:35 <bitemyapp> check worked too. Huh.
13:15:43 <bitemyapp> I wonder why it's choking on something that uses modules?
13:15:48 <levi> skypers: It's the one that's not a transformer.
13:16:03 <Twey> raspz: You might be thinking of the ‚Äòmap toUpper‚Äô function, which won't always do the correct thing depending on the language of the text.
13:16:05 * hackagebot sqlite-simple 0.4.5.1 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.5.1 (JanneHellsten)
13:16:07 * hackagebot QuickCheck-GenT 0.1.1 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/QuickCheck-GenT-0.1.1 (NikitaVolkov)
13:16:22 <raspz> Twey i thought all unicode characters can fit into 32 bits?
13:16:25 <LadyAurora> > toUpper '√ü'
13:16:25 <bitemyapp> ghc-mod type and info don't work, other things do.
13:16:26 <lambdabot>  '\223'
13:16:29 <bitemyapp> raspz: you can't count on that.
13:16:39 <bitemyapp> raspz: unicode could expand again.
13:16:41 <levi> bitemyapp: Weird. :/
13:16:48 <bitemyapp> raspz: you're better off accepting that unicode means variable length
13:16:52 <bitemyapp> and just using UTF-8
13:17:14 <bitemyapp> packs better anyway.
13:17:41 <levi> At least for English and similar text.
13:18:12 <LadyAurora> raspz: the uppercase of '√ü' is "SS", toUpper :: Char -> Char can't deal with that
13:18:16 <Twey> raspz: The word ‚Äòcharacter‚Äô is ambiguous.  All current Unicode codepoints fit into 32 bits (into 21 bits, even), but a codepoint does not always directly correspond to a glyph (a symbol drawn on the screen), and the number of possible *glyphs* is, theoretically, infinite.
13:18:17 <raspz> bitemyapp: doesnt it have enough empty room in 32bit that can cover all realiistic expansions?
13:18:57 <Twey> raspz: So a Char represents a codepoint, which is often but not always enough to encode a glyph.
13:19:00 <raspz> ok my unicode knowledge is obviously lacking
13:19:59 <levi> raspz: At least you're in good company there.
13:20:14 <raspz> What is the point in using 32 bit characters then, when we still have to worry about codepoints?
13:21:05 * hackagebot hledger-web 0.22.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.3 (SimonMichael)
13:21:34 <Twey> raspz: It mostly stems from confusion about Unicode and holdovers from ASCII, I think.
13:23:28 <Twey> In ASCII or other encodings where one glyph = one codepoint = one ‚Äòcharacter‚Äô, you can count the number of glyphs in a string in O(1) by dividing the size of the string by the size of a character, which is sometimes useful
13:24:19 <Twey> It doesn't really make sense when you have things like combining and zero-width codepoints, though.
13:26:11 <ski> > (isUpper &&& ((id &&& (== '√ü')) . toLower)) '·∫û'
13:26:12 <lambdabot>  (True,('\223',True))
13:26:50 <pavonia> :(
13:27:20 <Cale> Data.Text can handle it though.
13:27:35 <Cale> ghci> import qualified Data.Text as T
13:27:36 <Cale> ghci> T.toUpper (T.pack "√ü")
13:27:39 <Cale> "SS"
13:28:04 <shachaf> Cale: Any reason for +o?
13:28:18 <ski> earlier troll, istr
13:28:34 <LadyAurora> Cale: that's because Data.Text.toUpper has the correct type, so it can do that
13:28:41 <Cale> LadyAurora: right
13:29:33 <Cale> Though I sort of wonder why Char.toUpper doesn't at least produce ·∫û
13:29:52 <Cale> Seems like that would at least be better than giving back √ü
13:30:24 <raspz> Twey: if we could start fresh again what do would the size of a haskell Char be?
13:30:44 <raspz> s/do//
13:30:50 <Twey> raspz: Probably the same as it is now?
13:30:54 <LadyAurora> raspz: Char is okay, it's just misnamed
13:31:01 <Twey> Just remember that a Char is a codepoint, not a glyph
13:31:03 <LadyAurora> It's CodePoint really
13:31:08 <Cale> Maybe Char *should* be a glyph.
13:31:13 <shachaf> There's always ·∫û.
13:31:16 <Twey> Cale: That's hard.  ‚òπ
13:31:19 <Cale> Why?
13:31:26 <xintron> Is there a way to do a non-blocking read on a Chan?
13:31:27 <raspz> Twey why not 8 bit, using UTF8?
13:32:00 <dwcook> xintron, you can check isEmptyChan
13:32:03 <LadyAurora> raspz: that's a code unit, not a code point
13:32:12 <Twey> raspz: Because that doesn't represent *anything* useful.  :√æ
13:32:17 <Cale> xintron: Do a blocking read from another thread.
13:32:31 <xintron> dwcook, It's deprecated though :/
13:32:36 <dwcook> Ah, so it is
13:32:46 <Twey> At least a codepoint represents some kind of semantic unit.  A byte of UTF-8 is just a byte of opaque binary data ‚Äî it's not even a codepoint, out of context.
13:33:01 <dwcook> TChan supports tryReadTChan, if you feel like going that route
13:33:06 <Cale> isEmptyChan is dumb, because the Chan might not be empty by the time you go to use the information it just gave you
13:33:28 <Cale> So, if you rely on that answer in any way, your program probably has a bug.
13:33:35 <xintron> Bah, I'll make two threads then (reader + writer) with MVar and then one chan for the writer
13:33:47 <Cale> xintron: That sounds sensible
13:34:01 <Cale> Don't forget that threads are pretty damn cheap
13:34:01 <grady_player> simple beginner question: how do I evaluate a number of consecutive elements of a list?  I am trying http://cl.ly/code/1L1s0T3s1z2t , but it goes in 5's it looks like
13:34:21 <grady_player> the line of interest is f n (n1:n2:n3:n4:n5:xs) = if (n1*n2*n3*n4*n5 > n) then f (n1*n2*n3*n4*n5) xs else f n xs
13:34:22 <xintron> Cale, yeah, so I've understood :)
13:34:30 <Twey> Cale: Because Unicode is big, and has non-normal forms, and many ways of combining codepoints to get glyphs
13:34:51 <Cale> grady_player: What are you trying to do? That code looks like it does something sensible, even if it's not what you want it to do.
13:35:16 <raspz> what about 16 bit chars?
13:35:25 <grady_player> trying to go through that string 1 item at a time and find the product of that element plus the next 4
13:35:28 <Cale> Twey: Sure... but isn't there an easy specification of which combinations of codepoints produce a glyph somewhere?
13:35:33 <Twey> raspz: What about them?  There's no difference
13:35:44 <dwcook> grady_player, you don't have a pattern that matches on a list whose length is between 1 and 4
13:35:48 <skypers> ok so liftBase is used to cross-lift between monads, right?
13:36:10 <Twey> Cale: There is; the problem is enforcing it
13:36:16 <raspz> Twey: they cant hold all unicode codepoints either?
13:36:21 <Twey> raspz: Nope
13:36:25 <grady_player> my dataCount % 5 == 0 shouldn't matter for this example right?
13:36:31 <Twey> raspz: You need 21 bits to encode all of Unicode (as of today)
13:36:33 <LadyAurora> raspz: Unicode code points are 20 and a fraction bits
13:36:51 <Twey> > logBase 2 0x10ffff
13:36:53 <lambdabot>  20.087461546321563
13:37:18 <dwcook> grady_player, try using Data.List.splitAt or similar
13:37:28 <Twey> raspz: Specifying the size of a Char in memory isn't all that useful.  It's best to just say it's a Unicode codepoint, and leave it at that.
13:37:36 <Rotaerk> I have a component C that generates an event containing C-specific details in it, and this gets broadcast to other components.  if those components depend on C and care about C-events, they can ask the C component for the details about it.
13:37:36 <Cale> grady_player: You might try something like: [a*b*c*d*e | [a,b,c,d,e] <- map (take 5) (tails xs)]
13:37:43 <raspz> yeah I see
13:37:54 <Twey> raspz: That way you're also covered if Unicode grows again.
13:38:01 <Rotaerk> one way I can do this is to pack an ID into the event, which the A component then looks up, in order to provide those details...
13:38:16 <Rotaerk> but I was wondering about whether I could just pack the A-specific details in the event somehow
13:38:24 <Cale> (of course, you can do a little better than that, but this way avoids the cases near the end of the list where you don't have a full 5 elements)
13:38:28 <Rotaerk> this would require some kind of down-casting mechanism... does haskell support such a thing?
13:38:52 <grady_player> ok thanks dwcook / Cale, will try each then be confused for a while whether or not it works :)
13:39:01 <Cale> grady_player: Or you might just recurse on (n2:n3:n4:n5:xs) instead of recursing on xs
13:39:16 <levi> skypers: It's kind of like liftIO, but for when your base monad might not be IO.
13:39:18 <grady_player> Cale... I didn't know I could do that
13:39:29 <grady_player> that is more straight forward what I am trying
13:39:46 <johnw> bitemyapp: I always choose STM first, until the problem demands MVar
13:40:26 * grady_player speaks english natively... (though you wouldn't know it from that last sentence)
13:40:53 <levi> skypers: You might want to be able to choose either IO or ST as your base monad, for example.
13:41:37 <Cale> Twey: Perhaps I don't understand what's difficult about saying that a Char is some sequence of codepoints representing a single complete glyph.
13:41:54 <Cale> Perhaps up to equivalence
13:42:19 <Cale> (I assume that Unicode also defines an equivalence relation on such sequences)
13:43:03 <LadyAurora> Cale: define "single complete glyph"
13:43:08 <Cale> So you wouldn't be allowed to have a Char that's just some combining thing.
13:43:10 <mornfall> Cale: it defines normal forms
13:43:15 <Clint> four of them
13:43:28 <skypers> 22:35 < levi> skypers: It's kind of like liftIO, but for when your base monad  might not be IO.
13:43:31 <skypers> yeah
13:43:31 <skypers> :)
13:43:34 <skypers> got it!
13:43:54 <Cale> LadyAurora: Well, "glyph" :)
13:44:13 <LadyAurora> For example, is Dutch "IJ" a single glyph?
13:44:33 <Cale> I dunno, does Unicode say it is?
13:45:03 <Cale> It provides some definition of glyph which would presumably resolve that question, wouldn't it?
13:45:09 <pjdelport> there are lots of Unicode codepoints that don't map neatly to glyphs or characters in any way
13:45:27 <LadyAurora> Cale: Unicode says nothing about it IIRC, and they hate ligatures anyway
13:45:33 <pjdelport> LTR stuff, zero-width control codes and annotations, combining hints
13:45:49 <FireFly> ƒ≤ is one codepoint, anyway
13:46:02 <pjdelport> probably more things I can't think of right now
13:46:02 <Cale> pjdelport: Yeah, so we'd lose the ability to represent those as Char values.
13:46:08 <LadyAurora> pjdelport: good point
13:46:54 <Clint> unicode defines characters, not glyphs
13:47:13 <LadyAurora> FireFly: AFAIR Unicode ligatures are for compatibility, they're not really recommended
13:48:12 <pjdelport> full support for Unicode and all its associated algorithms will always be a complex task, suited for an entire library
13:48:39 <pjdelport> representing the codepoints is just the starting point, not the end
13:49:05 <pjdelport> (but most things also don't need to care about that full complexity)
13:49:15 <mornfall> that's because human scripts are complex
13:49:19 <Clint> and those that do handle it poorly
13:49:25 <mornfall> and largely incompatible with each other :)
13:49:47 <FireFly> LadyAurora: I see. I suppose they want the font to take care of that
13:50:04 <FireFly> (well, the thing doing the text rendering)
13:50:08 <LadyAurora> FireFly: yeah
13:51:14 * hackagebot hledger-web 0.22.4 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.4 (SimonMichael)
13:52:51 <skypers> oooook
13:53:00 <skypers> I got how to use liftBaseWith
13:53:04 <skypers> it‚Äôs powerful!
13:53:56 <hamid> how much
13:53:57 <hamid> :t liftBaseWith
13:53:58 <lambdabot> Not in scope: `liftBaseWith'
13:54:12 <jrmithdobbs> :t iter
13:54:13 <lambdabot> Not in scope: `iter'
13:54:16 <jrmithdobbs> erm, wrong window
13:54:25 <frerich> Hi, I'm trying to devise a little thread pool library. The gist of it is visible at http://lpaste.net/99743 - the client can call something like 'create 3 myProc' and a pool of three threads running myProc will be launched. I'm facing some hen-and-egg problem here: the 'myProc' function should receive a handle to the pool so that it can do things like feeding new input to it or draining it (i.e. signalling that there's no further input available).
13:54:35 <skypers> it lets you run a base monad inside a monad capturing its state, and resume it later
13:55:04 <frerich> Unfortunately (see the 'mapM' line in 'create') the Pool is only actually available *after* creating the threads. Does anybody have some idea how to resolve this nicely? I feel I'm missing something painfully straightforward...
13:55:08 <hamid> skypers, thanks
13:55:36 <skypers> I‚Äôm still trying to get some stuffs
13:56:03 <jrmithdobbs> frerich: not sure such a library makes much sense with how the threads work?
13:56:03 <skypers> like, from IO, runMaybeT then liftBaseWith goes in IO back, but I don‚Äôt know how to go into MaybeT again
13:56:25 <cdk_> frerich: look into recursive do syntax, or equivalently MonadFix
13:57:23 <skypers> ok
13:57:30 <skypers> it‚Äôs from the run function
13:57:34 <skypers> tricky
13:58:00 <frerich> cdk_: Thanks for the idea, I'll read up on that.
13:58:30 <jrmithdobbs> cdk_: oh nifty, i'd seen that paper looking for something at some point but didn't realise it was actually implemented
13:58:41 <skypers> runMaybeT $ do { liftBaseWith $ \run -> putStrLn "hi" >> run ((guard False) :: MaybeT IO ()); }
13:58:52 <skypers> this is really great
13:58:56 <skypers> but quite hard to follow :D
13:59:07 <johnw> skypers: it gets a lot easier with time
13:59:13 <johnw> <-- heavy user of liftBaseWith and company
13:59:19 <skypers> really?
13:59:22 <johnw> yeah
13:59:27 <skypers> use case is not very common isn‚Äôt it?
13:59:30 <johnw> also, control is more typical
13:59:32 <johnw> it's quite common
13:59:52 <skypers> johnw: if I don‚Äôt want to restore the state
13:59:54 <jrmithdobbs> frerich: have you looked at pipes/conduit? because i'm pretty sure both can build a thread pool like thing fairly straightforwardly
13:59:58 <johnw> then use liftBaseDiscard
14:00:35 <skypers> ok
14:01:05 <skypers> I think this package is going to be great with Foreign!
14:01:20 <skypers> I often want to use my monads inside the with* functions
14:01:23 <johnw> except when your monad doesn't allow MonadBaseControl to be derived :(
14:01:29 <johnw> when you run into that scenario, ping me :)
14:01:29 <skypers> ?
14:01:53 <skypers> how would it ‚Äúforbid‚Äù instancing?
14:01:59 <frerich> jrmithdobbs: I hoogled for 'thread pool' and found a couple of things, but most were either deprecated or didn't seem to do what I wanted (and/or seemed overly complex). So I decided to do the usual exercise of thinking that I can do it better myself and eventually realize that the complexity in other solution is for a reason. :)
14:02:02 <johnw> you'll know what I mean when you get there; unitl then, don't worry about it
14:02:18 <skypers> johnw: I‚Äôm curious
14:02:29 <johnw> conduits, mainly
14:02:40 <johnw> and Cont
14:02:43 <skypers> you mean, monads which state can‚Äôt be extracted?
14:02:47 <johnw> yes
14:02:55 <skypers> I don‚Äôt know either
14:03:02 <skypers> I just know what Cont is for
14:03:04 <skypers> but never used it
14:03:17 <johnw> it's great to blog about
14:03:17 <jrmithdobbs> frerich: well, eg, with conduit, you wrap your whole conduit pipeline in resourceT usually so you can easily have a conduit that takes input and feeds it to a thread pool and waits for the result and spits it back out the other end
14:03:29 <skypers> johnw: what is it useful for?
14:03:47 <johnw> mostly for code that needs to "abort" with a value, and you don't want to both with EitherT
14:03:48 <jrmithdobbs> frerich: the model exists, it's just hidden behind a layer of abstraction (as usual with haskell) ;p
14:04:03 <skypers> johnw: I don‚Äôt really get it
14:04:10 <skypers> I thought Cont was for reintrant functions
14:04:27 <johnw> flip runContT return $ \exit -> .....; exit (); ....
14:05:42 <johnw> you can model reentrant functions by returning a Cont action, since it knows where to resume to
14:06:48 <skypers> Abuse of the Continuation monad can produce code that is impossible to understand and maintain.
14:06:51 <skypers> :D
14:06:54 <skypers> sounds pretty odd
14:07:26 <jrmithdobbs> well it's a monad that can potentially emulate any other monad (think about why), so things get confusing pretty quick
14:08:05 <jrmithdobbs> Cont is fun.
14:08:36 <bitemyapp> there should be contests where people race to emulate other existing monads with Cont and see who can pass the tests first.
14:08:48 <bitemyapp> bonus points for obfuscation.
14:08:50 <johnw> jrmithdobbs: except that it can't truly emulate them because other monads can have MonadBaseControl instances, for example, whereas it cannot :)
14:09:05 <LadyAurora> Cont monad is terrible, it ought to replace Haskell syntax with Scheme's but doesn't
14:09:07 <jrmithdobbs> bitemyapp: bonus points for removing Cont and replacing it with Free and appropriate algebra
14:09:18 <bitemyapp> jrmithdobbs: (+1)
14:10:18 <johnw> skypers: anyway, another good tool for your monad transfomer toolbox is mmorph
14:10:29 <johnw> between monad-control and mmorph, you can slice and dice pretty much any transformer stack
14:11:16 <skypers> mmorph? hm
14:11:27 <johnw> primarily the function "hoist"
14:11:36 <bitemyapp> johnw: I need to see how this changes kristof's feelings on monad transformers.
14:11:43 <bitemyapp> johnw: doest thou hoist? :)
14:11:43 <johnw> which can turn any "t m a" into a "t n a", given a function m a -> n a
14:12:03 <skypers> I know hoistEither :)
14:12:07 <johnw> i rather like monad transformers, but it does take a while to get really fluid with them
14:12:19 <skypers> sure :D
14:12:58 <johnw> it wasn't until I wrote all of monad-control for myself that it truly sank in.   The next version should have the docs I wrote for Baas
14:14:32 <johnw> skypers: https://gist.github.com/jwiegley/8925274
14:15:28 <codygman> what is the easiest way to get information from a form field and turn it into a pdf? Use snap, heist, and pandoc? Can't I just generate the html then convert it to pdf with pandoc?
14:15:29 <jrmithdobbs> so, GND is "safe" now with 7.8 or is there something still not safe about it?
14:15:50 <ocharles> I think it's safe now that we have roles
14:15:55 <ocharles> that was my understanding
14:16:04 <jrmithdobbs> ocharles: mine too, i'm just double checking ;p
14:16:09 <bitemyapp> codygman: I'd go with the latter approach if possible.
14:16:17 <guymann> ye
14:16:26 <johnw> skypers: better version: https://www.fpcomplete.com/user/jwiegley/monad-control
14:19:25 <skypers> thank you for the link, johnw
14:20:49 <jrmithdobbs> johnw: so why can't cont have a controlbase instance? i'm missing that part
14:21:47 <skypers> jrmithdobbs: maybe because you can‚Äôt force evaluation to extract temporaries?
14:21:49 <jrmithdobbs> err basecontrol
14:22:26 <skypers> :t morph
14:22:27 <lambdabot> Not in scope: `morph'
14:22:33 <skypers> this function sounds‚Ä¶ woah.
14:22:36 <jrmithdobbs> doesn't runCont do that?
14:23:37 <johnw> jrmithdobbs: I did spend like 6 hours trying to write one; ultimately, you'll be missing a b -> a when all you have is an a -> b
14:23:51 <johnw> if that function is invertible, it's actually possible
14:23:57 <johnw> see the 'layers' library for a solution which goes that route
14:24:33 <bizarrefish> Hi, all
14:25:08 <jrmithdobbs> johnw: oh, ya, I see the issue .. you could have an instance for a specific Cont instance but not generically for Cont
14:25:18 <kazagistar> I am working on my first nontrivial program in haskell. It is supposed to parse and clean a million song titles into "ngrams", and then use that information to come up with "frequent song titles". Unfortunately, it explodes in time and memory usage. I would be really grateful if someone could point me in the direction of my mistakes, or even just style tips: http://lpaste.net/99744
14:25:31 <skypers> :t embed
14:25:31 <lambdabot> Not in scope: `embed'
14:25:35 <skypers> embed is sick!
14:25:40 <johnw> skypers: embed is in monad-extras
14:25:54 <johnw> http://hackage.haskell.org/package/monad-extras-0.5.6/docs/Control-Monad-Extra.html
14:25:56 <henk> Hi, I have a conceptual question about handling input data: my program reads files where each line consists of a timestamp and a string. For each timestamp I want to calculate the timedelta to the previous timestamp. I‚Äôm not sure whether I should create a special data type for that, or even more than one, or with multiple constructors. Should I make a datatype for just one line and store them in a list or
14:25:58 <henk> a map, or one for a set of lines? How would you handle that? Any recommendation or pointers to relevant docs are welcome.
14:26:31 <skypers> :DD
14:26:32 <skypers> :t om
14:26:34 <lambdabot>     Not in scope: `om'
14:26:34 <lambdabot>     Perhaps you meant one of these:
14:26:34 <lambdabot>       `or' (imported from Data.List),
14:26:40 <skypers> om nom nom
14:26:41 <skypers> :D
14:26:52 <johnw> :)
14:27:01 <johnw> chrisdone is the genius behind those names :)
14:27:48 <johnw> skypers: where did you find embed?
14:28:00 <bizarrefish> henk: Sounds like what you want is a foldl lifted into an IO (I'm newish to haskell, so that might be balls).
14:28:26 <skypers> johnw: mmorph
14:28:35 <johnw> ah, does it have its own version of embed?
14:28:47 <johnw> ah, I see
14:28:57 <johnw> different meaning
14:29:21 <skypers> Embed a transformer (Kleisli) arrow as an arrow in the base monad returning a mutated transformer state. If you do not want the transformation and your base monad is IO, use embedIO.
14:29:22 <johnw> mine is for packing up a function in a transformer in an action of its base monad so you can use it as a callback for, say, FFI functions
14:29:26 <skypers> I got nothing.
14:29:27 <skypers> :D
14:29:45 <tommd> henk: zipWith (diffTime) theList (drop 1 theList)
14:29:45 <ski> henk : probably depends on what you want to do with the data afterwards
14:30:18 <Cale> skypers: Documentation like that is probably less informative than just reading the type signature.
14:30:18 <ski> henk : if this list of timedeltas is just to be used once, then i probably wouldn't bother with making a new type for it
14:30:45 <Cale> (but by the sounds of it, if you read the type signature of that thing, it should tell you exactly what it does)
14:31:01 <kazagistar> at least, what is the best way to debug a memory problem in haskell?
14:31:05 <frerich> henk: I think I'd go with a type for timestamps, and a separate one for delates. The function which reads a file is something like 'readFile :: String -> [(TimeStamp, String)]' and calculating the delates is a separate function 'deltas :: [(TimeStamp, String)] -> [(Delta, String)]' or so. Might be a bit annoying though, but that's usually how I start (whipping up types and signatures and then playing Lego with that).
14:31:16 <johnw> kazagistar: what kind of memory problem?
14:31:35 <henk> bizarrefish: I don‚Äôt want to accumulate a value, so I don‚Äôt think folds are what I need ‚Ä¶
14:31:50 <skypers> Cale: yeah the type signature is black magic to me
14:31:53 <skypers> embedIO :: (MonadBaseControl IO m, MonadIO m) => (a -> m b) -> m (a -> IO b)
14:32:00 <skypers> embed :: MonadBaseControl base m => (a -> m b) -> m (a -> base (StM m b))
14:32:03 <frerich> henk: I think I would lose a lot of time on deciding whether I would spell it 'TimeStamp' or 'Timestamp'. ;-)
14:32:03 <skypers> ^ that one
14:32:30 <henk> tommd: What about the string associated with the timestamp, how do I pass that on?
14:32:46 <johnw> I use embedIO pretty frequently when I want to mix MonadLogger-constrainted functions with FFI calls in IO
14:32:51 <ski> frerich : with some `IO's sprinkled on top
14:32:56 <pjdelport> kazagistar: what level of grammity are you testing with?
14:33:16 <skypers> I don‚Äôt even undertand its type
14:33:26 <skypers> it takes a function that takes a value and output m b
14:33:29 <skypers> likes >>=
14:33:31 <skypers> -s
14:33:39 <Cale> kazagistar: If I look at this, the first thing I'd be suspicious of is the fact that the (+1) you're applying to the values in your Map is probably not going to be evaluated until much later, and if you do it a lot, you'll end up with expressions in memory which look like (+1) ((+1) ((+1) (...)))
14:33:49 <frerich> ski: I suppose you could get away without IO by just calling it 'parse' instead of 'readFile' :-)
14:33:51 <johnw> fooIO <- embedIO foo ; callSomeFFIFunction fooIO
14:34:03 <ski> (: frerich
14:34:05 <johnw> where callSomeFFIFunction wants a callback function a -> IO b
14:34:43 <skypers> can‚Äôt you do that with control?
14:34:45 <henk> ski: Well, I can‚Äôt say for sure yet (; I‚Äôd like to keep my options open. It‚Äôs also a "I‚Äôm learning me a haskell for Great Good" kind of project, so I wouldn‚Äôt mind doing it, as long as it doesn‚Äôt hurt.
14:34:53 <johnw> skypers: sure, look at how embedIO is implemented :)
14:34:57 <Cale> kazagistar: The next thing I'd be suspicious of is the fact that you're using foldl, which is almost never the fold that you want. Either foldl' (if you're being strict) or foldr (if you're being lazy)
14:35:03 <ski> henk : you can change your mind later
14:35:10 <frerich> cdk_: Your recursive-do hint worked out quite well! I don't really grok the black magic behind it yet, but it allowed me to write exactly the code I had in mind, and it even seems to work as intended. :-)
14:35:12 <skypers> with liftBaseWith
14:35:20 <frerich> cdk_: So thanks for that!
14:35:30 <ski> frerich : in `IO' ?
14:35:32 <johnw> skypers: because control implies a call to restoreM
14:35:39 <skypers> yes
14:35:40 <johnw> and the point of embedIO is that it does not back-propagate state changes
14:35:51 <skypers> and ou don‚Äôt want that, so why not liftBaseDiscard?
14:35:51 * ski wonders whether frerich was using `IORef' or `MVar' or such ?
14:35:56 <johnw> embed uses control
14:36:09 <johnw> embed f = control $ \run -> run $ return (run . f)
14:36:17 <skypers> yeah just read that
14:36:24 <skypers> I think I might need it
14:36:28 <Cale> kazagistar: The reason for that is that if you apply foldl to a really long list, it will do nothing apart from apply itself to new arguments until it reaches the end of the list, and since the accumulating parameter isn't being evaluated, it's going to balloon into a large expression in memory.
14:37:03 <skypers> this is just sick
14:37:10 <henk> frerich: Yeah, well, it looked a little like that a while ago ‚Ä¶ Then I started "optimizing" ‚Ä¶
14:37:19 <skypers> when complexity stops? :D
14:37:20 <Cale> kazagistar: e.g.  foldl f z [1,2,3,...] -> foldl f (f z 1) [2,3,...] -> foldl f (f (f z 1) 2) [3,...] -> foldl f (f (f (f z 1) 2) 3) [...] -> ...
14:37:34 <skypers> I thought monad transformers were one of the hardest things about Haskell
14:37:46 <henk> ski: oh, believe me: I know and I do (:
14:37:46 <skypers> a few weeks ago I discovered control
14:37:48 <skypers> now that‚Ä¶
14:37:53 <frerich> ski: My original question was about how I could adjust my sketch of a thread pool library (code is at http://lpaste.net/99743 ) such that the pool itself is passed to the worker procedures. My idea was to pass the pool to the workers so that they could do things like feeding new data into the pool or draining it (i.e. signalling that no further data is to be processed).
14:38:06 <johnw> well, they can be overused and misused somewhat easily, which is usually what makes them hard to work with
14:38:12 <levi> skypers: All the fun of monad transformer PLUS the fun of continuations!
14:38:33 <skypers> levi: I‚Äôll learn continuations
14:38:34 <Cale> kazagistar: and if your list is millions of elements long, you'll build up an expression graph in memory with millions of nodes in it.
14:38:36 <skypers> it sounds important
14:38:39 <frerich> ski: So in that code paste, I had a hen-and-egg issue in the 'mapM' line: I wanted to pass the pool to the 'worker' function which is used for forking the threads - but the pool itself only starts to exist after the threads were forked.
14:39:27 <pjdelport> kazagistar: for accumulating the data, have you considered an approach based on fromListWith?
14:39:34 <ski> frerich : i see. sounds like typical `mfix' stuff
14:39:46 <Cale> and yeah, fromListWith might do better here
14:40:13 <mm_freak> i wonder how far the term "continuatoin" reaches in haskell‚Ä¶  i even consider the tail of a non-empty list to be a continuation in the lists-as-control interpretation
14:40:19 <mm_freak> wow
14:40:22 <mm_freak> continuation
14:40:36 <frerich> ski: Yes, cdk_ mentioned that as well. I never heard about MonadFix et al before. I now have http://lpaste.net/99743 (the annotation) and it seems to work alright!
14:40:40 <pjdelport> kazagistar: for accumulating the data, have you considered an approach based on fromListWith?
14:40:56 <Cale> pjdelport: you already said that :)
14:41:05 <frerich> ski: The 'mdo' keyword is supposedly deprecated according to the documentation, but my ghc doesn't warn, so who am I to argue...
14:41:12 <pjdelport> Cale: sorry, I think IRCCloud is being weird :P
14:41:19 <henk> ok, let me rephrase my question a little: I get a line with a timestamp. I‚Äôm parsing that timestamp using a given format to ZonedTime, then take it apart to get UTCTime and TimeZone. ALL of that needs to be remembered somewhere while calculating the deltas, because all of it is used in the output. Would creating my own datatype(s) help with any of that?
14:41:23 <skypers> hm
14:41:30 <skypers> type families seem to be important as well
14:41:38 <skypers> I‚Äôll dig in it tomorrow
14:41:56 <monochrom> you can use the "rec" keyword instead. it's newer.
14:41:56 <johnw> type families is a whole lot easier than monad-control :)
14:42:00 <epta> http://lpaste.net/99747 what is wrong with this?
14:42:23 <frerich> monochrom: My ghc (7.6.3) barfed on that. Or is that a separate language extension?
14:42:37 <nomeata> monochrom: rec is for when you need more control, mdo when you want it to look more like do, right?
14:42:38 <monochrom> it is a different extension, yes
14:43:08 <skypers> johnw: yeah I guessed that :D
14:43:08 <monochrom> yes rec is finer-grain. and easier for both reader and compiler.
14:43:21 <skypers> I just hope it‚Äôs not a try to introduce OO into Haskell
14:43:23 <skypers> I hate OO.
14:43:42 <ski> frerich : also `do ...; rec {...; ...}; ...'
14:44:37 <ski> skypers : proper records would be nice
14:45:01 <monochrom> but rec still looks like do
14:45:01 <kazagistar> pjdelport: I did consider fromListWith, but I couldn't figure out how to make it work with the Map in a Map
14:45:05 <frerich> ski: I saw such snippets as well, but to be honest - it's almost midnight, my wife fell asleep next to me and I couldn't be bothered to find out *why* it works, I'm just happy that I can move along. I just added a '-- magical recursive-do suggestion courtesy of _cdk of #haskell fame' comment. ;-)
14:45:31 <kazagistar> Cale: I will try to use the strict fold then?
14:45:42 <johnw> skypers: but everything is an object!
14:46:16 <monochrom> in GHC, everything is a heap object
14:46:17 * ski submits everything is a subject !
14:46:20 * hackagebot deka 0.4.0.0 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.4.0.0 (OmariNorman)
14:46:51 <monochrom> every British is a Queen's subject
14:46:58 <Cale> kazagistar: Or do what pjdelport suggested and use Data.Map.Strict.fromListWith to accumulate your map.
14:47:12 <Earnestly> monochrom: (not since the 70s)
14:47:44 <mirpa> I've just tried flycheck+hdevtools in emacs and it looks pretty awesome - I must give it a upvote on github :-)
14:47:48 <kazagistar> :t Data.Map.Strict.fromListWith
14:47:49 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
14:47:58 <pjdelport> kazagistar: why exactly do you have two levels of Map?
14:48:02 <mirpa> realtime error checking
14:48:08 <codygman> Sometimes I feel like a trick is being played on me with Haskell: http://lpaste.net/99748
14:48:11 <mirpa> with hlint
14:48:15 <kazagistar> it has symetric parameters to the accumulator, that does not seem right‚Ä¶
14:48:41 <skypers> oooh
14:48:45 <skypers> I already use them
14:48:49 <skypers> as associated types
14:48:55 <skypers> in typeclasses
14:48:56 <frerich> codygman: Note that the error message talks about the third argument in some cases and the first argument in others.
14:49:02 <skypers> I didn‚Äôt know it was called that way
14:49:05 <kazagistar> pjdelport: because given a n-1 length list of words, I am trying to find the most common word that follows them in my data set
14:49:28 <johnw> skypers: yeah, "family" here just means "indexed" where you index by a type
14:49:59 <augur> is there a nice little haskell library for doing DB-like tasks, but not via some DB system?
14:50:12 <johnw> augur: do you want all the data to live in memory?
14:50:14 <codygman> frerich: Thanks
14:50:16 <augur> by that i mean, processing CSVs into tables, doing joins on tables, etc.
14:50:20 <johnw> there's 'tables' and 'acid-state'
14:50:27 <skypers> ok exhausted
14:50:27 <augur> johnw: yeah, its just a scripting task so
14:50:29 <skypers> see you guys
14:50:32 <johnw> I'd use tables then
14:50:40 <augur> tables is familiar. ill check it out
14:51:07 <johnw> and maybe pipes to feed the data into the table, to be extra cool
14:51:16 <augur> lol
14:51:21 * hackagebot crypto-random-effect 0.2.0 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0 (ibotty)
14:51:23 <johnw> since pipes-parse and tables both intersect at the lens library
14:51:32 <levi> Don't for get to use Traversals from lens to do queries.
14:52:44 <pjdelport> kazagistar: regarding the accumulator, the idea is to feed it something like fromListWith (+) [(k, 1) | k <- keys]
14:53:19 <augur> johnw: yeah, tables uses lens.. im gonna just roll my own
14:53:30 <johnw> tables is actually pretty easy to use
14:54:03 <pjdelport> kazagistar: to get the most common following word, you could use a single-level map and examine the range that shares the prefix of n-1 words
14:54:11 <augur> johnw: for some definition of "easy"
14:54:18 <pjdelport> but yeah, Map isn't ideally suited for this
14:54:23 <pjdelport> kazagistar: this problem really calls for a Trie
14:54:43 <pjdelport> kazagistar: have you looked at Data.Trie or such?
14:59:48 <kazagistar> pjdelport: that seems like it would be better indeed, but‚Ä¶ I got it working in Perl really smoothly using a double hash, so it would be kinda a pity if I couldn't do the same in haskell‚Ä¶?
15:00:29 <pjdelport> kazagistar: oh, well you can try a hash in Haskell too
15:01:16 <pjdelport> Map isn't quite the same, especially with this kind of depth of structure
15:01:25 <kazagistar> pjdelport: I think I was under the mistaken impression that maps acted like hashes
15:03:32 <codygman> I have been trying to make an htmlToPDF function using pandoc, but I keep getting an error generating PDF: http://lpaste.net/99750
15:07:19 <bizarrefish> I've been playing with haskell and am currently trying to realise a "Coroutine" monad. I've read about similar ones, where the yieldables and responses are represented as a sum type, but why couldn't you make a more type-safe one like this: http://lpaste.net/99745
15:07:30 <pjdelport> kazagistar: Map is a balanced binary tree internally, and it's not mutated in-place
15:07:47 <bizarrefish> Any pointers as to where my thinking is going screwy here?
15:08:53 <mm_freak> bizarrefish: how is that Coroutine supposed to actually continue?
15:09:15 <c_wraith> bizarrefish: Yield c (r -> Coroutine c r a)
15:09:26 <johnw> I think you want Yield a (r -> Coroutine c r a), or something
15:09:28 <johnw> haha
15:09:33 <Earnestly> Uncanny
15:09:39 <c_wraith> I think you want to yeild a c, not an r
15:09:43 <c_wraith> otherwise the c type is useless
15:09:44 <mm_freak> i'd have preferred to allow bizarrefish to figure that out =)
15:09:47 <c_wraith> *yield
15:09:55 <c_wraith> err, a c, not an a
15:10:15 <levi> codygman: Do you have latex stuff installed?
15:11:15 <codygman> levi: Yes
15:11:26 <bizarrefish> mm_freak: The Yield returns a result and a function which takes a value, returning another Yield or Done
15:11:45 <c_wraith> bizarrefish: why do you have 3 type variables?  What does each one represent?
15:11:47 <bizarrefish> c in this case needs to be of Coroutine type, for it to work correctly
15:12:48 <mm_freak> bizarrefish: i see‚Ä¶  usually Coroutine is really just a free monad transformer with direct recursion
15:13:07 <levi> codygman: Does the pandoc executable work at creating pdfs?
15:13:12 <johnw> mm_freak: I love how you said that like it was a normal thing :)
15:13:17 <mm_freak> newtype FreeT f m a = FreeT (m (Either a (f (FreeT f m a)))))
15:13:19 <bizarrefish> c is the coroutine type that the yield's function produces. r is the value which the function using the coroutine passes back to the Yield function, and a is the result of the whole thing.
15:13:27 <johnw> "oh, it's just ..."
15:13:32 <bizarrefish> Hehe
15:13:32 <johnw> what's the problem?
15:13:37 <c_wraith> johnw: well, that *is* what it is.  Even if you don't know it. :)
15:13:38 <mm_freak> johnw: sorry‚Ä¶  i guess i've been using haskell for too long =)
15:13:48 <johnw> no, it was a great answer
15:13:49 <bizarrefish> Gotta love this channel
15:13:51 <bizarrefish> :D
15:14:10 <mm_freak> bizarrefish: for coroutines you need to have /some/ recursion
15:14:11 <bizarrefish> (I actually do; so much friendlier than I remember #C++ was in my teenage years)
15:14:11 <johnw> I just remember what it was like once, to see Haskell people talk and think it was a puzzle instead of a language
15:14:26 <codygman> Well I somewhat improved my situation with pandoc/latex/pdfs: http://lpaste.net/99750
15:14:45 <mm_freak> bizarrefish: you can establish the recursion from outside of Coroutine, but i doubt that you want to use one of the various fixed point types =)
15:14:55 <bizarrefish> *googles*
15:15:06 <c_wraith> bizarrefish: the problem with that definition is that if you want a coroutine to yeild 4 times, you get an *incredibly* ugly type.
15:15:14 <c_wraith> bizarrefish: that's why they're usually recursive types
15:15:21 <codygman> The log file generated by pandoc is deleted or never created :(
15:15:43 <shachaf> What if I want it to yield forever?
15:15:47 <bizarrefish> c_wraith: Isn't that the compiler's job to worry about? :P
15:15:48 <c_wraith> bizarrefish: if you want something that can yeild an arbitrary number of times, you need an infinite type.  Might as well just make it directly recursive
15:16:03 <c_wraith> bizarrefish: it's your problem if you want to document your types
15:16:10 <bizarrefish> Hmm
15:16:41 <bizarrefish> Okay, so how would I go about actually declaring such a majestic type?
15:17:04 <mm_freak> data Producer a r = Done r | Yield a (Producer a r)
15:17:24 <johnw> at which point you need to ask: why not just use pipes?
15:17:30 <bizarrefish> *squints*...I'm sure that made the compiler barf. 1mo, will check
15:17:32 <levi> codygman: Have you tried having it just output the tex code and seeing if that's sensible?
15:17:39 <mm_freak> data Consumer a r = Done r | Await (a -> Consumer a r)
15:17:48 <codygman> levi: I should do that. No I haven't thought about that.
15:18:25 <mm_freak> connect :: Producer a r -> Consumer a r -> r
15:18:32 <bizarrefish> johnw: "Pipes" is a haskell thing?
15:18:36 <levi> If a composition of pieces fails, the first thing to do is un-compose it. :)
15:18:38 <johnw> it's a Haskell library
15:18:39 <mm_freak> bizarrefish: pipes is a library
15:18:41 <bizarrefish> Ah
15:18:43 <johnw> which codifies what we're starting to talk about
15:18:51 <mm_freak> bizarrefish: it does what you're doing‚Ä¶  on steroids‚Ä¶ =)
15:18:57 <johnw> i.e., connecting producers and consumers
15:19:03 <jrmithdobbs> which is a version of pipes/conduit's model
15:19:04 <jrmithdobbs> haha
15:19:36 <johnw> I use conduits, some use pipes, but it's pretty much all in the same neighborhood of using coroutines to model inversion of control
15:20:36 <mm_freak> bizarrefish: don't read about pipes/conduit for now‚Ä¶  do it yourself, it's a fun and useful exercise =)
15:20:42 <johnw> that's true
15:20:46 <johnw> very very true
15:20:47 <bizarrefish> mm_freak: I didn't like having the same sum type representing all of my possible yieldables. Seemed like a bit like I was castrating the type system. I'm not trying to build something specific here, so maybe that's my problem. Need to do something real.
15:21:08 <jrmithdobbs> mm_freak: pfft, use pipes/conduit and move on to a more fun problem without nice solutions already ;p
15:21:25 * hackagebot pretty-show 1.6.6 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.6 (IavorDiatchki)
15:21:30 <bizarrefish> Heh, I see the Haskell community isn't so different after all :D
15:21:32 <mm_freak> jrmithdobbs: like what?
15:21:53 <jrmithdobbs> mm_freak: whatever he originally needed a coroutine for would be a good start ;p
15:22:00 <mm_freak> bizarrefish: oh, btw, pipes uses a bizarrefish operator
15:22:04 <mm_freak> (>->)
15:22:04 <mm_freak> =)
15:22:13 <bizarrefish> :D
15:22:29 <codygman> levi: I tried and everything looks sensible to me: http://lpaste.net/99750
15:25:45 <levi> codygman: That is not a very sensible TeX document, actually.
15:26:09 <levi> codygman: You probably need to change the options to the TeX generator to tell it to generate a standalone document rather than a fragment.
15:26:53 <codygman> levi: Thanks. I guess that shows I don't know much about TeX then :S
15:28:04 <fooozbizzle> is it okay to install a cabal executable which was compiled in a sandbox?
15:29:05 <c_wraith> fooozbizzle: what do you mean by "install"?
15:29:07 <Cale> fooozbizzle: Should be fine, so long as it's statically linked.
15:29:22 <levi> fooozbizzle: There are a couple of exceptions, like xmonad and yi, though.
15:29:35 * Fuuzetsu runs Yi in a sandbox
15:29:46 <c_wraith> Also, if it hardcodes paths to resources, those will point to the sandbox, which may or may not be what you want
15:29:49 <Fuuzetsu> I do cheat and point it to the packages inside the sandbox though
15:29:56 <levi> It's fine as long as it knows where to find all its stuff.
15:30:14 <fooozbizzle> Cale c_wraith  levi - i compiled lushtags in a sandbox, and i'm wondering if it's okay to "cabal install" in the sandbox to put the binaries in ~/.cabal/bin
15:30:30 <levi> cabal install in the sandbox won't do that, though.
15:30:39 <c_wraith> it'll put the binaries in the sandbox
15:30:41 <levi> It will make a bin directory in your sandbox.
15:31:26 * hackagebot cprng-aes-effect 0.1.0 - Run random effect using cprng-aes, a crypto pseudo number generator.  http://hackage.haskell.org/package/cprng-aes-effect-0.1.0 (ibotty)
15:31:41 <fooozbizzle> levi: c_wraith: okay.. that's fine i guess.. i'll just use a symlink or something to the built executable
15:33:59 <levi> fooozbizzle: It will most likely work just fine.
15:35:25 <dmwit> ski: Right, that's why I phrased my promise as I did. Instead of saying "when evaluating 'foo `seq` bar', by the time 'bar' is in WHNF, 'foo' is too" (which indeed has the error you're saying), I said "when evaluating 'foo `seq` bar', by the time 'foo `seq` bar' is in WHNF, 'foo' is, too".
15:35:38 <fooozbizzle> another question: if i have two packages, A depending on B, which both have many shared dependencies, C, D, and F, when I compile B in a sandbox, can I tell A to use the same compiled files?
15:35:43 <dmwit> ski: I agree it's a subtle difference, and I thank you for pointing it out. It's important to be careful about that stuff.
15:36:05 <raspz> :t sizeOf
15:36:06 <lambdabot>     Not in scope: `sizeOf'
15:36:07 <lambdabot>     Perhaps you meant one of these:
15:36:07 <lambdabot>       `IM.size' (imported from Data.IntMap),
15:36:26 * hackagebot crypto-random-effect 0.2.0.1 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0.1 (ibotty)
15:37:36 <k1tt3n> Hi!
15:37:38 <raspz> sizeOf "hi there" gives me "No instance for (Storable [Char])". how could I find out the total memory that string (or any other haskell object) uses?
15:37:59 <k1tt3n> I've got a quick question: if you define a recursive function, is it better for perfomance if you put the base case at the end?
15:38:08 <k1tt3n> looking at the code it seems like it
15:38:19 <k1tt3n> but it 's a question of whether the compiler makes any optimization
15:39:06 <mm_freak> raspz: it's impossible in general
15:39:27 <mm_freak> raspz: you can use profiling though
15:39:40 <fooozbizzle> levi: c_wraith: if i am working on two packages, A depending on B, both of which have many shared dependencies, C, D, and F, when I compile B in a sandbox, can I tell A to use the same compiled files?
15:39:50 <mm_freak> k1tt3n: depends on your pattern-matching
15:40:15 <shachaf> k1tt3n: In most cases it's not relevant.
15:40:24 <k1tt3n> so if I first match the more common case, it does matter?
15:40:24 <mm_freak> k1tt3n: if you're determining the case through pattern-matching, then it usually doesn't matter‚Ä¶  in the case of guards the order does matter
15:40:52 <shachaf> If you really care, you should benchmark and find out.
15:40:55 <k1tt3n> why is there a difference with guards?
15:41:17 <fooozbizzle> levi: c_wraith: i'm working on a group of packages (the As) which depend on http://hackage.haskell.org/package/GPipe .. and it has a ton of dependencies, some of which are shared by my As
15:41:18 <mm_freak> k1tt3n: because to determine whether a guard is true you need to evaluate it
15:41:26 <shachaf> I think your mental model of how Haskell code is evaluated is unlikely to match reality unless you've actually looked at generated code or read some papers or something.
15:41:30 <k1tt3n> well, for the kind of recursive calls I do it seems kind of irrelevant. It was more of a 'philosophical' question.
15:41:41 <k1tt3n> ok, thanks!
15:41:47 <shachaf> However: The order of constructors *can* matter.
15:41:59 <k1tt3n> is it better to use guards or pattern matching?
15:42:02 <mm_freak> k1tt3n: benchmarking is your best option
15:42:09 <mm_freak> k1tt3n: pattern matching is better in general
15:42:16 <c_wraith> fooozbizzle: you can do it a couple different ways.  You can do it with either cabal sandbox add-source or cabal sandbox init --sandbox
15:42:33 <raspz> for a String, is it (4+sizeOf(pointer)) * length
15:42:38 <shachaf> See e.g. [Note: Order of constructors] in http://hackage.haskell.org/package/containers-0.5.4.0/docs/src/Data-Map-Base.html#Map
15:42:51 <shachaf> k1tt3n: It's better to use pattern matching.
15:43:25 <shachaf> (It's better not to worry about micro-optimizations like this at all.)
15:44:00 <fooozbizzle> c_wraith: i thought add-source would help .. if i "add-source" inside one of my As pointing to GPipe, will my A have access to GPipe's already-compiled deps?
15:44:07 <k1tt3n> I was just curious. I do remember the recommendation of putting the base case at the end from some other functional language
15:44:18 <k1tt3n> anyway, it was just a more or less random thought I had
15:44:36 <shachaf> If you really care then the answer is, as always, "benchmark" and "look at generated code".
15:44:38 <fooozbizzle> c_wraith: assuming that GPipe was compiled in a sandbox..
15:45:00 <c_wraith> fooozbizzle: if you use the add-source method, you should only build from the sandbox
15:45:22 <c_wraith> fooozbizzle: it will pick up changes to source dependencies and recompile them
15:45:45 <ski> dmwit : yes
15:45:57 <monochrom> k1tt3n: from my reading of generated code, your order of cases does not matter, GHC always imposes its own order.
15:46:04 <ski> dmwit : however, i'm not sure whether the latter will necessarily hold always
15:47:16 <fooozbizzle> c_wraith: "only build from the sandbox"? ...
15:47:18 <monochrom> the moral of the story is: do not theorize. do not opine. look at generated code.
15:47:25 <greg`> just finished 20 problems for intermediate haskell programmers
15:47:37 <monochrom> well, I forgot "do not extrapolate"
15:47:39 <greg`> levelled up to intermediate!
15:47:46 <shachaf> monochrom: But <shachaf> See e.g. [Note: Order of constructors] in http://hackage.haskell.org/package/containers-0.5.4.0/docs/src/Data-Map-Base.html#Map
15:47:49 <monochrom> and "do not think".
15:47:55 <johnw> greg`: congrats!
15:48:01 <fooozbizzle> c_wraith: i'm assuming i'd have a GPipe sandbox with the deps compiled, and a sandbox in my package referencing the GPipe sandbox using add-source ...
15:48:13 <fooozbizzle> c_wraith: or is that crazy-talk
15:48:58 <c_wraith> fooozbizzle: you can do that, but it results in double-compiling GPipe and its dependencies.
15:49:24 <fooozbizzle> c_wraith: okay, i guess i'm not understanding how to avoid the double compiling then..
15:49:31 <fooozbizzle> c_wraith: and that's the whole point .. ;)
15:49:58 <c_wraith> fooozbizzle: only compile your project that uses GPipe.  It will pick up changes to GPipe and recompile it as needed.
15:50:16 <mm_freak> k1tt3n: when you use guards and have more than two guards, then the order usually matters, so you would want to put the most common case first and the least common last
15:50:29 <mm_freak> so that common cases are matched earlier
15:50:33 <c_wraith> fooozbizzle: if you *really* want to compile GPipe by itself, use the shared sandbox approach.  cabal sandbox init --sandbox
15:50:39 <k1tt3n> greg`: which problems were those? Could you possibly provide me with a link?
15:50:40 <monochrom> ok, I suppose order in a data declaration matters. but I was only speaking of pattern matching order
15:51:15 <c_wraith> fooozbizzle: You have to do more bookkeeping then, though.  It won't automatically detect changes to GPipe when you recompile things that depend on it
15:52:38 <k1tt3n> greg`: is it this one: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
15:53:11 <monochrom> overall, I am, of course, more a proponent of meta-optimization: optimize how much time you spend on optimizing code
15:54:28 <monochrom> sadly, programmers who can be easily nerd-sniped must fail to meta-optimize.
15:55:01 <fooozbizzle> c_wraith: i don't expect GPipe or its deps to change often -- and if they do, i'm not really interested in updating my code (because gpipe has version maximums)
15:55:29 <c_wraith> fooozbizzle: that's why there are multiple options available.  *shrug*
15:55:36 <fooozbizzle> c_wraith: so if the shared sandbox is the only way to prevent double-comiling of my GPipe & deps all the time, then that's what i need to do
15:55:59 <fooozbizzle> c_wraith: i'm not understanding what the other options are..
15:56:05 <fooozbizzle> c_wraith: sorry..
15:56:17 <c_wraith> fooozbizzle: well, add-source won't double-compile GPipe and its deps unless you *also* compile GPipe on its own.
15:56:28 * hackagebot markdown-pap 0.0.1.9 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.9 (YoshikuniJujo)
15:57:02 <fooozbizzle> c_wraith: but i'm going to need to add-source (pointing to GPipe) inside of many of my own packages ..
15:57:22 <fooozbizzle> c_wraith: which means i'll end up many-compiling gpipe & deps
15:57:26 <fooozbizzle> c_wraith: is this wrong?
16:01:00 <c_wraith> fooozbizzle: cabal sandbox doesn't have any answer to "I want to build this package with these dependencies and reuse it everywhere that's compatible with those dependencies".
16:01:14 <c_wraith> fooozbizzle: if that's what you're after, sorry, it won't do it.
16:01:15 <mm_freak> sadly GPipe is terribly outdated
16:01:31 <mm_freak> it's still on OpenGL 2.5, but the current platform is on OpenGL 2.8
16:01:52 <mm_freak> and i can't wait for it to switch to OpenGL 2.9 =)
16:02:11 <c_wraith> Isn't OpenGL on 4.something now?
16:02:37 <mm_freak> c_wraith: haskell's OpenGL binding
16:02:41 <c_wraith> oh, ok
16:02:45 <mm_freak> haskell OpenGL 2.8 corresponds to OpenGL 4.4
16:02:47 <mm_freak> uhm
16:02:48 <c_wraith> too many version numbers!
16:02:52 <mm_freak> haskell OpenGL 2.9 corresponds to OpenGL 4.4
16:02:58 <mm_freak> and 2.8 corresponds to 3.2
16:03:11 <c_wraith> that's a big jump
16:03:16 <mm_freak> which is mostly fine, but the new fancy shaders are only available in 4.x =)
16:03:29 <mm_freak> most notably the compute shader and the geometry shader =)
16:03:34 <fooozbizzle> mm_freak: i've modded gpipe to use up-to-date versions and it works just fine.. the only problem is restrictive version numbers
16:03:53 <mm_freak> fooozbizzle: are you planning to release your version?
16:03:56 <fooozbizzle> i could submit a pull request to tobias i guess
16:05:05 <mm_freak> if he's still active that might work
16:05:44 <mm_freak> fooozbizzle: does GPipe have a functional shader language or do you still write shaders by hand?
16:06:13 <DrAwesomeClaws> my new preferred debugging method:  Delete lines until it compiles.  Realize you didn't actually need all those lines anyway
16:07:34 <Noldorin> can anyone recommend a Haskell web framework? I'm looking for one that will make my life easy writing a sizeable business website, and one that doesn't require too much configuration. encountered HappStack, Yesod, Scotty, but though I'd ask here before learning too much about any one in particular...
16:08:08 <mm_freak> Noldorin: the three big ones are happstack, snap and yesod
16:08:18 <hakujin> Noldorin: add Snap to that list and you have the majority
16:08:22 <dhrosa> @pl  \(c, m) x y -> train x y c
16:08:22 <lambdabot> flip (flip . train) . fst
16:08:35 <dhrosa> meh
16:08:40 <Noldorin> mm_freak, hakujin, not heard as good things about Snap from others... but okay
16:08:51 <Noldorin> your personal recommendations?
16:09:23 <mm_freak> Noldorin: they all work well‚Ä¶  yesod focusses on speed and safety, snap on modularity, happstack on modularity and safety
16:09:36 <tac> How do you get parsec to fail to parse something without using the f-word?
16:09:39 <mm_freak> Noldorin: if you can't decide, pick on randomly and see if it works for you
16:09:43 <Noldorin> mm_freak, heh fair enough
16:09:49 <mm_freak> Noldorin: if not, do the next project with one of the other two =)
16:10:07 <mm_freak> tac: empty
16:10:23 <tac> mm_freak: monoid empty?
16:10:27 <tac> no, that's not right
16:10:30 <mm_freak> tac: Alterantive empty
16:10:31 <tac> @type empty
16:10:32 <lambdabot> Alternative f => f a
16:10:32 <mm_freak> Alternative
16:10:35 <Noldorin> mm_freak, do any of them (including Scotty if you're familiar with it) support sort of Haskell-like syntax over HTML? that is, mixing in haskell with the HTML...
16:10:57 <joelteon> hamlet does that
16:10:59 <mm_freak> Noldorin: all of them do
16:11:05 <Noldorin> ah jolly good.
16:11:12 <mm_freak> Noldorin: blaze-html gets closest to HTML in haskell
16:11:31 <Noldorin> mm_freak, blaze-html is usable within all 3 of those conveniently?
16:11:49 <Noldorin> 3 or 4.... if you include scotty
16:12:11 <bitemyapp> some people will just use WAI directly.
16:12:17 <tac>     Could not find module `Control.Applicative.Alternative'
16:12:20 <mm_freak> Noldorin: with happstack (and i believe snap) you can use it directly‚Ä¶  with yesod you need to write a small wrapper around it
16:12:24 <tac> Does Alternative not come with base?
16:12:29 <Noldorin> aha
16:12:30 <mm_freak> tac: import Control.Applicative
16:12:47 <Noldorin> mm_freak, heard something about quasi-quotations, which makes it unique (?). i suppose that's an alternative to blaze-html even
16:13:11 <mm_freak> Noldorin: QQ is used to allow custom non-haskell syntax within haskell code
16:13:18 <mm_freak> Noldorin: yesod's hamlet uses that heavily
16:13:18 <Noldorin> oh
16:13:20 <Noldorin> right
16:14:42 <Noldorin> mm_freak, eh, not sure I'm a fan of embedding yet another language and having it in the mix... blaze-html sounds nicer
16:14:43 <mm_freak> Noldorin: there are four approaches to templating in haskell
16:14:47 <Noldorin> ah yes?
16:15:07 <mm_freak> 1. blaze-html, direct haskell code with regular functions and a combinator library
16:15:19 <mm_freak> 1. HSP, preprocessing XML code mixed with haskell code
16:15:26 <mm_freak> uhm
16:15:27 <mm_freak> that's 2. =)
16:15:48 <mm_freak> 3. heist, separate files with XML-based templating
16:15:53 <jrmithdobbs> hrm, so with the Church encoding of Free you can't match off of the next element inside of the algebra, so if I need to do that I need to build it in F representation and then walk it back to Free before performing the actual operation?
16:15:58 <mm_freak> 4. hamlet, a QQ-based DSL
16:16:10 <jrmithdobbs> or am I missing something?
16:16:24 <mm_freak> heist is snap's default, hamlet is yesod's default, and HSP and blaze-html are happstack's default
16:16:31 * hackagebot pretty-show 1.6.7 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.7 (IavorDiatchki)
16:16:33 * hackagebot yjsvg 0.1.18 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.18 (YoshikuniJujo)
16:16:48 <mm_freak> (that is in happstack you choose between HSP and blaze-html)
16:17:09 <Noldorin> mm_freak, ah, very good. blaze-html gives me a best first impression (not a big XML fan), so might go with that and happstack. :)
16:17:24 <mm_freak> =)
16:17:39 <mm_freak> Noldorin: it's difficult to get around some TH though
16:18:06 <mm_freak> in happstack you would typically use web-routes-boomerang, for which you would use some convenience TH
16:18:13 <mm_freak> it gives you safe URLs
16:18:20 <Noldorin> mm_freak, I haven't encountered TH yet unfortunately... I know I should at some point... any good tutorials out there?
16:18:23 <Noldorin> ah right
16:18:24 <Noldorin> very good
16:18:30 <Noldorin> what
16:18:35 <mm_freak> TH is pretty much a necessary evil
16:18:37 <Noldorin> what's "web-routes-boomerang" though?
16:18:39 <Noldorin> I see.
16:18:45 <dmwit> ski: err, huh
16:18:51 <mm_freak> web-routes gives you a type-safe routing abstraction
16:18:57 <mm_freak> and web-routes-boomerang is a concrete realization
16:19:20 <dmwit> ski: why?
16:19:21 <mm_freak> yesod does something similar, but has its own library for typesafe routing
16:19:34 <mm_freak> in snap routes are stringly-typed
16:20:36 <mm_freak> it's possible to add web-routes support to snap, but it makes working with its main feature, snaplets, a little awkward
16:21:30 <Noldorin> mm_freak, are web-routes and web-routes-boomerang alternatives?
16:21:42 <Noldorin> right
16:21:43 <mm_freak> no, you use them together
16:21:58 <Noldorin> well i'll probably go with happstack to start, but it's good to know the others have alternatives
16:22:03 <Noldorin> okay
16:22:05 <mm_freak> for happstack you would use web-routes, web-routes-boomerang and web-routes-happstack
16:22:12 <Noldorin> got it
16:22:23 <Noldorin> mm_freak, how's happstack's own server incidentally?
16:23:17 <fooozbazlll> mm_freak: you write your shaders in haskell
16:23:18 <mm_freak> Noldorin: it's reasonably fast and focusses mainly on simplicity
16:23:28 <mm_freak> fooozbazlll: nice
16:24:11 <Noldorin> mm_freak, great. any server that's fast and stable enough to be used in 'real-world' environments does the job. after that, my main criterion would be simplicity (I hate having excess configuration)
16:24:37 <fooozbazlll> mm_freak: https://github.com/plredmond/gltut_haskell-gpipe/blob/master/Tut_06_Objects_in_Motion/hs/Tutorials/Rotations.hs#L64 that's a shader to do  basic projection .. i haven't gotten to the tuts where you do lighting yet
16:26:33 * hackagebot xturtle 0.1.25 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.25 (YoshikuniJujo)
16:26:35 <mm_freak> Noldorin: hackage is a happstack application =)
16:27:16 <Noldorin> mm_freak, super
16:27:19 <Noldorin> that's cool
16:28:34 <Noldorin> mm_freak, sorry for the endless question... now my queries are a) any decent Haskell to Javascript compiler (translator) out there? b) can I eschew (X)HTML completely and write my pages in Haskell? c) can I eschew CSS completely and write stylesheets in Haskell?
16:28:40 <Noldorin> I know, Haskell for everything!
16:28:44 <ski> dmwit : say `f (seq foo bar)' with `f' strict. couldn't this possibly denotationally be the same as `seq foo (f bar)' ?
16:29:00 <merijn> Noldorin: With the release of 7.8 pending ghcjs should have it's first real release soon
16:29:27 <merijn> Noldorin: That compiles haskell (with support for all GHC extensions, software transactional memory and threading) to JS
16:29:54 <Noldorin> ah, jolly good
16:30:11 <mm_freak> Noldorin: you can write CSS in haskell
16:30:16 <mm_freak> there is clay, for example
16:30:31 <mm_freak> alternatively you can use a custom Writer-based solution
16:30:45 <dmwit> ski: Wow, that's sneaky.
16:30:48 <merijn> Noldorin: There's several other approaches, UHC (Utrecht Haskell Compiler) can compile to JS and Fay is a subset of haskell that can be compiled to JS
16:31:05 <merijn> Noldorin: The downside of Fay is that while all valid Fay is valid haskell, not all valid haskell is valid Fay
16:31:11 <mm_freak> fooozbazlll: interesting, although the DSL could use some polishing‚Ä¶  i find GLSL easier to read compared to that
16:31:33 <ski> dmwit : so it seems to me one could operationally delay the forcing of `foo' further, while keeping the same denotational semantics of it
16:31:56 <dmwit> right
16:32:14 <ski> you can imagine that the compiler determines `f' is strict by strictness analysis, and for some reason decides to reorder the forcing of `foo' using this
16:32:17 <merijn> Noldorin: If the goal is to write *actual* haskell, then ghcjs will be the way to go. But the official first release is waiting for 7.8 which has some important bits (7.8 RC1 was recently released)
16:32:22 <Noldorin> merijn, oh so only a subset eh. I've also heard of using Haskell -> LLVM -> Javascript via GHC & emscripten
16:32:34 <dmwit> That is really subtle.
16:32:36 <mm_freak> Noldorin: http://www.haskell.org/haskellwiki/The_JavaScript_Problem
16:32:37 <Noldorin> merijn, that's cool. I can wait a month or so, at least
16:32:45 <dmwit> And now I'm really, really glad you called me out.
16:32:59 <mm_freak> that page summarizes your options for going from haskell/haskell-like to javascript
16:33:00 <dmwit> ski++
16:33:02 <merijn> Noldorin: I haven't used Haskell's LLVM backend, but that approach will probably be a lot less efficient than ghcjs which just generates JS directly :)
16:33:06 <fooozbazlll> c_wraith: if i just have them all use the same shared-sandbox, doesn't this solve my problem?
16:33:12 <tac> fucking Haskell number tower.... How do you cast from Int to Integer?
16:33:21 <dmwit> :t fromIntegral
16:33:22 <lambdabot> (Integral a, Num b) => a -> b
16:33:25 <tac> ty
16:33:26 <dmwit> :t toEnum
16:33:27 <lambdabot> Enum a => Int -> a
16:33:27 <Taneb> :t toInteger
16:33:29 <lambdabot> Integral a => a -> Integer
16:33:31 <ski> dmwit : it's more or less "as-if" semantics -- but this can matter if you're attempting to reason about the actual ordering (for performance, or because you're doing dirty `unsafePerformIO' tricks, say)
16:33:39 <mm_freak> merijn: depends‚Ä¶  compiling LLVM bytecode via emscripten may actually yield some decent javascript
16:33:50 <Noldorin> mm_freak, I like the intro to that article. it would seem most Haskellers are in agreement that Javascript is a horrid invention :)
16:34:01 <mm_freak> Noldorin: indeed =)
16:34:16 <Noldorin> merijn, yeah ghcjs seems to have good all-round support, and is actively maintained. sounds good, thanks for the advice.
16:34:22 <merijn> Noldorin: That's why we program haskell instead of Node.js :)
16:34:26 <ski> dmwit : i didn't know the example about before i just formulated it. i just had a vague feeling that some such delaying ought to be possible
16:34:32 <ski> s/about/above/
16:34:34 <Noldorin> merijn, yes, and thank goodness you do!
16:34:34 <merijn> Noldorin: luite and some others working on it are frequently here
16:34:42 <Noldorin> ah, very good.
16:34:53 <dmwit> ski: So is seq's actual promise in terms of denotational semantics?
16:34:55 <merijn> But I should go sleep :)
16:35:00 <dmwit> well
16:35:10 <ski> dmwit : afaiui, yes
16:35:17 <ski> (unlike `pseq')
16:36:12 <Noldorin> mm_freak, merijn, to be clear, blaze-html and clay fulfil pretty similar roles for (X)HTML and CSS respectively?
16:36:34 * hackagebot markdown2svg 0.0.1.17 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.17 (YoshikuniJujo)
16:38:33 <kristof> Why are there so many implementations of Haskell that compile to JS?
16:38:47 <kristof> You'd think there would be very little wiggle room for design choices
16:39:31 <dmwit> yap, the promise is "seq _|_ b = _|_; seq a b = b when a /= _|_"
16:39:40 <dmwit> very tricky
16:40:21 <mm_freak> Noldorin: yes
16:41:31 <mm_freak> kristof: there are easily a dozen ways to compile a lazy functional language to javascript, each with unique advantages and disadvantages
16:41:41 <mm_freak> the most common problem is code explosion
16:41:51 <kristof> code explosion?
16:42:04 <bitemyapp> kristof: hey
16:42:04 <mm_freak> huge target code
16:42:19 <kristof> bitemyapp: Hi, maybe you can offer some knowledge
16:42:24 <kristof> mm_freak: Gotcha
16:42:27 <mm_freak> to support full haskell you need at least concurrency
16:42:30 <bitemyapp> kristof: http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html
16:42:40 <kristof> mm_freak: Logical threads only since it's JS, right?
16:42:46 <bitemyapp> kristof: I've been doing a lot of tinkering with JS and Haskell-esque languages lately.
16:42:58 <bitemyapp> kristof: mainly with Fay and PureScript.
16:43:04 <mm_freak> kristof: or web workers when available
16:43:20 <Noldorin> mm_freak, marvellous. I think that covers up everything I'd need to develop and host a website purely in Haskell. anything else (other libraries?) I should be aware of?
16:43:23 <kristof> bitemyapp: I'm aware, which is why I thought you'd have some ideas about this subject
16:43:32 <bitemyapp> it's kind of a long story.
16:43:35 <mm_freak> Noldorin: reform
16:43:39 <kristof> bitemyapp: Also, I just read Gonzalez's post about comonads being object oriented programming
16:43:45 <bitemyapp> I also need to finish following up on Haste before I can give any real pronouncements.
16:44:01 <bitemyapp> kristof: mmorph is directly relevant to your complaining about monad transformers.
16:44:06 <mm_freak> Noldorin: for typesafe forms with automatic validation and security
16:44:06 <kristof> bitemyapp: well when you do, let me know. It'd be cool to write some haskell code and have it actually execute in a web browser
16:44:29 <bitemyapp> kristof: the short of it is that purescript seems the most broadly applicable for frontend web apps, but it's really young.
16:44:40 <ski> dmwit : i believe <http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2> sepecifies `seq' denotationally
16:44:53 <bitemyapp> kristof: I don't think Haste/GHCJS are a good idea (yet) and Fay doesn't have typeclasses which is crippling.
16:44:58 <Noldorin> mm_freak, right. better than formlets/digestive-functors?
16:45:08 <bitemyapp> kristof: purescript is strict, if that wasn't obvious.
16:45:12 <ski> right, you also found it
16:45:25 <kristof> bitemyapp: Because of 1) how big clojurescript is getting and 2) how cool Haskell is, I think it would be pretty cool if the Haskell community sort of gravitated to one de facto implementation of Haskell-to-JS
16:45:38 <bitemyapp> kristof: part of the problem is that you don't really want to use setTimeout to encode yield
16:45:47 <bitemyapp> kristof: you want your frontend code to have control over callbacks and yielding.
16:45:47 <kristof> ok
16:45:50 <asimov> Can I run mapM over a Data.Vector without importing the Data.Vector module?
16:46:17 <roboguy_> asimov: you could import just the instances
16:46:22 <kristof> bitemyapp: Which implementations encode yield in terms of timeouts?
16:46:25 <roboguy_> I think with import Data.Vector ()
16:46:30 <bitemyapp> kristof: we need two things to be competitive with ClojureScript, 1. a mature Haskell'ish dialect (doesn't have to be 100%, Fay with typeclasses would be fine) 2. HAMTs 3. core.async
16:46:43 <bitemyapp> kristof: Haste at a minimum, GHCJS is closer to a full blown interpreter encoding.
16:46:48 <Noldorin> mm_freak, never mind, just saw the Hackage page for it. seems to build on those two
16:46:53 <bitemyapp> GHCJS interleaves. Scary.
16:47:28 <kristof> bitemyapp: Hash Array Mapped Tries?
16:47:39 <kristof> bitemyapp: Or those like bit partitioned hash tries?
16:47:46 <asimov> roboguy_, can i do it without using the "vector" package at all?
16:47:58 <asimov> roboguy_, i don't want to add it to my cabal file
16:48:25 <roboguy_> asimov: probably not, but I haven't tried
16:48:32 <asimov> ok thanks
16:49:03 <kristof> bitemyapp: I don't think channels are very haskelly. But anyway, there's a working implementation of communicating sequential processes (from 2012, I think?) which does not do the cool deepwalking macro stuff that go does but at least it gives you channels
16:49:44 <ski> kristof : deepwalking ?
16:50:22 <kristof> ski: nontrivial code transformation, see Timothy Baldridge's videos on his go macro
16:50:38 <ski> kristof : what does it achieve ?
16:51:23 <kristof> ski: Takes synchronous looking code and turns it into a finite state machine
16:52:23 <ski> "Clojure : Deep Walking Macros" by Timothy Baldridge in 2013-09-26 at <http://www.youtube.com/watch?v=HXfDK1OYpco> presumably being relevant
16:52:40 <kristof> ski: The next video after that is the one that talks specifically about how the macro works
16:52:50 <kristof> ski: Take your pick, they're all good videos
16:53:02 <kristof> ski: If you don't know clojure or are comfortable with macrology, watch the one you just linked
16:53:20 <Noldorin> mm_freak, eh, one more thing... is there a Haskell mail/IMAP server? that's asking too much right? ;)
16:53:55 <mm_freak> Noldorin: you can answer most "is there" questions by visiting hackage =)
16:54:05 <mm_freak> Noldorin: http://hackage.haskell.org/packages/
16:54:13 <Noldorin> mm_freak: already searched hackage, but just wondering if I missed something
16:54:16 <kristof> ooph, that reminds me
16:54:25 <kristof> someone should go write a Haskell frontend for mailgun
16:55:05 <Noldorin> oh
16:55:06 <Noldorin> by category
16:55:09 <Noldorin> that's handy
16:55:10 <mm_freak> i usually ignore the categories
17:00:28 <mm_freak> it was meant as a good feature, but turned out to be a mess to allow package authors to choose the categories freely =)
17:00:29 <Noldorin> heh yeah, fair point
17:00:29 <mm_freak> to such an extent that hackage's categories are almost useless
17:00:30 <Rembane> I wonder if there's a better way to automatically set the categories.
17:00:31 <mm_freak> not automatically‚Ä¶  just provide a sensible set of predefined categories
17:00:32 <Noldorin> mm_freak, I know it's not really haskell-related, but since you sound like you've hosted your own sites before, any decent recommendation for a simple robust *nix mail server?
17:00:32 <mm_freak> Noldorin: i mostly use postfix+dovecot
17:00:32 <ski> kristof : pretty simple macrology, so far
17:00:35 <bitemyapp> kristof: Not Haskell-y? Really? I like Control.Concurrent.Chan :(
17:00:35 <bitemyapp> kristof: like unordered-containers or Clojure collections.
17:00:36 <bitemyapp> kristof: well, I'll put it this way, a way to encode concurrency that is nicer than callbacks, but doesn't involve encoding an interpreter you can't control.
17:00:36 <mm_freak> bitemyapp: Chan is deprecated in pretty much every case you would want to use it =)
17:00:36 <mm_freak> see TChan
17:00:36 <bitemyapp> mm_freak: understood.
17:00:37 <bitemyapp> mm_freak: regardless, I like CSP.
17:00:38 <bitemyapp> and it mates well to browser use-cases.
17:00:38 <mm_freak> "CSP"?
17:00:39 <Noldorin> mm_freak, would you judge between them? i've noticed OS X includes postfix this days and just a sendmail compatibility layer, so I'm presuming postfix is rather superior... but dovecot?
17:00:39 <bitemyapp> mm_freak: communicating sequential processes
17:01:13 <mm_freak> Noldorin: postfix for sending and receiving mails (SMTP), dovecot for accessing mails (IMAP)
17:01:33 <Noldorin> mm_freak, oh right. i'm an idiot; i thought postfix did both
17:01:36 <Noldorin> never mind, very well
17:01:53 <mm_freak> bitemyapp: sounds like that could be another super java-buzzword for "monoid" =)
17:03:05 <bitemyapp> mm_freak: ...
17:03:17 <bitemyapp> mm_freak: http://en.wikipedia.org/wiki/Communicating_sequential_processes
17:03:21 <hae> Is there a JVM implementation of Haskell?
17:03:25 <mm_freak> bitemyapp: is this about threads passing data along?
17:03:36 <bitemyapp> hae: frege sorta, but it's not mature at all.
17:03:52 <bitemyapp> mm_freak: ish
17:04:17 <mm_freak> sounds like something i would do with pipes-concurrency or monad-par or ‚Ä¶
17:04:24 <hae> Interesting.
17:04:32 <Noldorin> mm_freak, i'm off now, but many thanks for all your advice!
17:04:55 <mm_freak> Noldorin: my pleasure, and if you write a pure haskell SMTP server, i'll be happy to give it a shot =)
17:04:59 <bitemyapp> mm_freak: we don't have a viable green-threading model in JS, CSP plays nicely because it can be translated to callbacks.
17:05:09 <bitemyapp> mm_freak: I'd kinda like a Lamson for Haskell.
17:05:27 <mm_freak> bitemyapp: a haskell implementation can choose to implement cooperative threading
17:05:44 <mm_freak> which translates to coroutines, which translates to callbacks
17:06:09 <bitemyapp> I really like the idea of my data flow being actual data structures (channels)
17:06:18 <Noldorin> mm_freak, hah. good to hear. maybe one day when i'm rather more proficient in the language.
17:06:19 <bitemyapp> even if I'm forking off handlers
17:06:21 <kristof> bitemyapp: Ok, I can agree with you on that (avoiding callbacks)
17:06:25 <Noldorin> anyway, cheerio...
17:06:31 <mm_freak> bitemyapp: me, too‚Ä¶  i just don't think that Chan is a very good abstraction
17:06:49 <bitemyapp> mm_freak: you're getting a little too focused on Chan specifically.
17:07:56 <mizu_no_oto> Do cabal sahdboxes have to be used in conjunction with cabal files?  Or can you create a new directory, cabal sandbox init, cabal install a dependency, and use ghci?
17:08:51 <dcoutts_> mizu_no_oto: currently have to use a cabal file
17:09:18 <dcoutts_> mizu_no_oto: what you're asking for is a fairly common feature request and is likely to appear at some point
17:10:52 <greg`> k1tt3n yes it is that one
17:11:00 <greg`> very late response i know :
17:13:15 <ski> kristof : sounds like "deepwalking macro" is the same as a "code walker"
17:14:01 <kristof> ski: Do you use lisp? Code walking in lisp is done within the language, like an ouroboros.
17:14:25 <greg`> a snake eating its tail?
17:14:41 <BMeph> Like a giant navel? :)
17:15:03 <greg`> i think clojure will be the next language i learn
17:15:04 <BMeph> Walt, sorry, that's am omphallos. My bad!
17:16:55 <schell> what are the differences between common lisp and clojure?
17:17:59 <hae> One of them features in Greenspun's Tenth Law.
17:19:39 <greg`> schell well i think in lisp everything is a list , and clojure has moved away from that a little, i may be wrong
17:19:58 <greg`> probably best to ask at #clojure :-\
17:20:12 <schell> yeah, that's what i would guess :)
17:20:34 <dwcook> Everything is a list? Is this like "everything is a function"?
17:20:40 <schell> though - moving away from "every is a list" would be a movement away from lisp itself, i would guess
17:24:13 <ski> kristof : i'm more familar with Scheme than with Common Lisp or Clojure
17:24:52 <ski> schell : Clojure is much more recent
17:25:08 <kristof> ski: To be honest, I'm not entirely sure how much of this could be done with Scheme's define-syntax
17:25:34 <ski> kristof : be sure to not confuse `syntax-rules' with `define-syntax'
17:26:04 <kristof> schell: What are you talking about? Common Lisp has been around since the very late 70s and had support for real multidimensional arrays, hash tables, sets...
17:26:15 <ski> (`define-syntax' is merely the binding mechanism of a macro implementation to an identifier. there are different macro systems, mechanisms for implementing macros)
17:28:00 <ski> perhaps schell was thinking of that traditionally the forms passed to macros have consisted out of lists, and symbols, and various other atoms, only occasionally being constructed out of other things, like vectors
17:28:33 <ski> whereas, iiuc, Clojure uses vectors more liberally in the syntax of various forms
17:31:52 <DrAwesomeClaws> yay.  I have successfully forked my first thread
17:36:06 <randomclown> DrAwesomeClaws: use the async library
17:36:10 <randomclown> forkIO sucks
17:36:31 <haasn> FSVO ‚Äòsucks‚Äô
17:37:40 <Cale> async isn't intended to be a replacement for forkIO
17:37:40 <DrAwesomeClaws> randomclown: forkio is working fine for my needs atm.  I can refactor when it becomes a problem
17:38:26 <c_wraith> forkIO does exactly what it says it does.  Sometimes, that's all you need.
17:41:31 <randomclown> With respect to exception handling
17:43:57 <TravisD> e
17:44:02 <codygman> I have been trying to write an htmlToPDF function using latex with pandoc for a while, but still can't find the source of the error generating one: http://lpaste.net/99757
17:44:54 <c_wraith> codygman: you do know that latex documents need to start with the \begin{document} stuff, right?
17:45:43 <codygman> c_wraith: I just saw that after posting. I think the standalone option needs to be checked as I was advised earlier with pandoc.
17:47:02 <codygman> c_wraith: That fixed my problem. Everything finally came together levi, thanks.
18:11:50 <asimov> Can someone please tell me which packages these functions are from:
18:12:04 <asimov> > fmap fromByteString . sourceFile
18:12:05 <lambdabot>  Not in scope: `fromByteString'Not in scope: `sourceFile'
18:12:17 <asimov> from: https://groups.google.com/forum/#!topic/yesodweb/fMfkzZkoUFM
18:12:24 <asimov> I can't seem to get it to typecheck
18:14:57 <bsqrd> hello folks
18:15:02 <roboguy_> asimov: looks like there's a few possibilities https://www.fpcomplete.com/hoogle?q=frombytestring&env=ghc-7.4.2-stable-13.09 https://www.fpcomplete.com/hoogle?q=sourceFile&env=ghc-7.4.2-stable-13.09
18:18:09 <bsqrd> i'm a bit confused on how to use/what i'm doing wrong with Data.Stream.  To create a Stream, I use S.Cons 'a', which has type 'S.Stream Char -> S.Stream Char'. i want to convert to a list using S.toList, but the types don't match
18:18:30 <bsqrd> S.toList :: S.Stream a -> []
18:18:37 <bsqrd> correction: S.toList :: S.Stream a -> [a]
18:21:04 <schell> kristoff, ski: i'm not sure what you thought i meant but i was saying that lisp is all about lists - isn't that the basis of lisp? list processing? everything evaluates up to s-expressions or lists of them, right?
18:21:16 <dwcook> bsqrd, what do you mean they don't match? Maybe show how you're using toList.
18:21:31 <bsqrd> S.toList $ S.Cons 'a'
18:21:54 <dwcook> bsqrd, ah, yeah, you need an actual Stream, not simply a function that results in one.
18:21:57 <schell> kristoff: it seems like if you move away from list processing it ceases to be a lisp
18:22:29 <dwcook> bsqrd, think of a Stream as a necessarily infinite list. You need to provide the rest of the Stream.
18:22:31 <codygman> For some reason using the writerStandAlone option of the pandoc latex parser gives me no output: http://lpaste.net/99758
18:23:39 <Cale> schell: I'm not sure I'd agree with that idea, based on the fact that most lisps seem to have somewhat impoverished list libraries. (Though maybe I'm just spoiled because Haskell's is pretty good.)
18:23:47 --- mode: Cale set -o Cale
18:24:48 <bsqrd> dwcook: ok, that makes sense. i knew that a Stream is a necessarily infinite list, just didn't realize i needed to provide the rest of the Stream
18:27:50 <stolaruk> Do Arch users still recommend using the [haskell-core] mirror?
18:29:38 <cdk_> stolaruk: you'd probably be better off using cabal
18:29:50 <stolaruk> yeah, ok
18:45:04 <jophish> Yo yo yo
18:45:58 <jophish> I have a class: class C a where f :: X -> a Y -> a Z
18:46:33 <jophish> I'm having trouble making an instance C a => C [a], because (obviously) a has the wrong kind
18:49:40 <watermind> jophish: and...
18:49:58 <jophish> watermind: I'm not entirely sure about how to write this instance
18:50:50 <dwcook> jophish, write [] instead of [a]
18:50:58 <jmcarthur> jophish: i don't think i'm entirely sure what you actually intend the instance to mean
18:51:15 <jophish> jmcarthur: probably not
18:51:21 <watermind> yeah I'm not sure what the intent is either
18:51:29 <watermind> jophish: can you give an example of what you want?
18:51:33 <jophish> the intent is that X is a mapping from Y to Z
18:51:42 <jophish> and a is some kind of container
18:51:52 <dwcook> My suggestion assumed you wanted f :: X -> [Y] -> [Z]
18:51:55 <jophish> (I'm sure that this exists already)
18:52:26 <jophish> dwcook: ah, then no. I want f :: X -> [a Y] -> [a Z]
18:52:31 <jmcarthur> jophish: it sounds like Functor, but doesn't look like it
18:53:19 <jophish> yes, that does sound about right actually
18:54:18 <watermind> if X is a mapping from Y to Z... then if a is a functor you just need to do  fmap (apply_mapping x)
18:54:32 <jophish> watermind: writing it now
18:54:35 <jophish> thanks all
18:57:02 <jophish> is DeriveFunctor a extension which isn't frowned upon
18:57:14 <jophish> the definitions for these types are all vanilla
18:58:33 <jmcarthur> DeriveFunctor is a fine extension
18:59:34 <jophish> super
19:03:24 <roboguy_> as far as I know, DeriveFunctor does only good thins
19:03:26 <roboguy_> *things
19:04:33 <startling> there's some performance issues in older GHCs I think
19:05:01 <startling> oh, no, just Foldable and Traversable
19:05:04 <startling> i5-4288U
19:05:06 <startling> er
19:05:08 <startling> https://ghc.haskell.org/trac/ghc/ticket/7436
19:06:40 <startling> "I just noticed that DeriveFunctor has the same issue, in a slightly less severe form (you have to look at all the elements to do quadratic work)." <- apparently Functor has the issue too
19:07:27 <startling> yeah, and it's not merged into 7.6. boo.
19:09:35 <roboguy_> it's fixed in 7.8 though isn't it?
19:10:13 <tertl3> the GHC is great good
19:10:24 <dolio> Think so. If you're talking about what I think you are.
19:15:39 <CaptainK> now I have full protection from DICE and the NSA! http://photos1.blogger.com/blogger/6406/1644/1600/Cage%20Faraday%20-%20ferm%3F%3F.jpg
19:16:31 <CaptainK> lol, meant for another thread
19:18:38 <jfischoff> I thought that was weird bot ;)
19:19:17 <CaptainK> oh ya, that would look like that too :P
19:25:21 <xrz> Does anyone have any idea what is the meaning of  "Iface type variable out of scope:  k"? GHC 7.6.3; code looks like: data (a ~ Bucket, b ~ Bucket) => Doc a b = Doc a b
19:27:39 <roboguy_> xrz: what is that supposed to do?
19:31:14 <jfischoff> I don't think that is valid Haskell2010
19:31:37 <xrz> roboguy_: it is supposed to provide parameters to the Doc type, so I can hopefully use that to typecheck various kinds of Doc later. There are two modules (I was trying to isolate the error). They compile just fine first time; when I am trying to recompile module which imports this declaration, I am getting the error from my first message
19:31:51 <jfischoff> you could write data Doc a b = forall a b. (a ~ Bucket, b ~ Bucket) => Doc a b I think
19:32:02 * jfischoff fires up ghci
19:32:39 <roboguy_> xrz: why do you need the type restrictions?
19:33:09 <codygman> For some reason using the writerStandAlone option of the pandoc latex parser gives me no output: http://lpaste.net/99758
19:33:15 * hackagebot markdown2svg 0.0.1.18 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.18 (YoshikuniJujo)
19:33:26 <jfischoff> yes, you can write what I wrote, not sure why you would want to though
19:34:08 <Sgeo> "The optional expr argument is the erroneous source syntax object or S-expression (but the expression #f cannot be represented by itself; it must be wrapped as a syntax object). "
19:34:19 <Sgeo> Is this why Racket was called unprincipled the other day? This sort of thing?
19:35:35 <xrz> jfischoff: Doc a b = forall a b. (a ~ Bucket, b ~ Bucket) => Doc a b  works fine, I cannot reproduce the error. I am in doubt whether I should report a bug - do not have enough expertise to make a decision.
19:35:55 <jfischoff> what error?
19:36:10 <jfischoff> it's a bad error message
19:36:15 <jfischoff> the one you had
19:36:35 <jfischoff> its should say something like data contexts are not Haskell2010
19:37:07 <roboguy_> xrz: I think data contexts are considered bad in general
19:37:08 <c_wraith> It should also say "and if you think you want them, please reconsider"
19:37:17 <roboguy_> xrz: why do you need the context?
19:37:23 <xrz> roboguy_: Primarily, I would like to make sure that nobody can make a typo in sources and mix Docs with different buckets together. Very important to me really.
19:37:50 <roboguy_> xrz: couldn't you achieve this by putting the context into the function types?
19:38:11 <L8D> @hoogle Read a => String -> [a]
19:38:12 <lambdabot> Prelude read :: Read a => String -> a
19:38:12 <lambdabot> Text.Read read :: Read a => String -> a
19:38:12 <lambdabot> Control.Monad.Trans.Error listMsg :: ErrorList a => String -> [a]
19:38:16 <c_wraith> That's the better approach anyway
19:38:21 <roboguy_> actually, I'm still not all that clear what you're doing...
19:39:28 <jfischoff> I'm pretty sure that you could just write Doc = Doc Bucket Bucket
19:39:33 <jfischoff> which is equivalent
19:40:09 <jfischoff> because of the type equality you can only use them for buckets anyway
19:40:28 <xrz> jfischoff: I see similar messages in relatively recent bug reports, but I do not understand, what exactly is wrong in my case: https://ghc.haskell.org/trac/ghc/ticket/7958
19:41:56 <syllogismos_> what is the best way to parse csv files in haskell?
19:42:54 <peddie> @hackage cassava
19:42:54 <lambdabot> http://hackage.haskell.org/package/cassava
19:43:13 <peddie> syllogismos_ ^
19:43:15 <xrz> roboguy_: I would also like to make functions more concise - to force them to accept only certain Doc instances. It seems, that there actually are ways to do that without context, but my current question is more like "Is that really a bug of GHC? Should I create a ticket that?""
19:48:37 <roboguy_> xrz: wait, I'm not sure I understand the error message. does it really say something abut a type variable named "k" when you only have type variables named "a" and "b"? maybe you should post the code+error message
19:49:05 <roboguy_> also, I think that sort of thing only works if you enable the DataContexts extension (which you shouldn't)
19:49:28 <xrz> 1 sec, I'll create a gist
19:50:31 <xrz> DataContexts extension is not enabled and yes, it says k when there is no k in my code
19:52:25 <qrada> hey, i have this function which balloons up extreme in memory.. i've compiled it with -O2 etc.. the function is intense, it's traversing some graph structure using millions of combinations, using recursion.. is there any tricks someone might know of to aid this thing along.. obviously most of this has to do with how i am programming this function, im trying to address that.. but are there any other tricks? perhaps compile tricks?
19:52:31 <qrada> in general
19:53:06 <hiptobecubic> qrada, compile tricks are not going to save you unless you accidentally trick the compiler into making something strict
19:53:17 * hackagebot yesod-eventsource 1.1.0.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.1.0.1 (MichaelSnoyman)
19:53:23 <hiptobecubic> assuming you algorithm is written in a way to make such a thing possible
19:54:07 <qrada> hm, do you think i should try making some of this strict? basically, i have a 'graph structure', and i'm recursively traversing the tree in every direction possible etc.. i would have imagined that strict eval would allocate SOOO much memory initially
19:54:12 <qrada> im haskell nub so
19:55:05 <qrada> this current graph structure has ~4 million possible traversals for example.. so im recursing and at the same time making my traversal set smaller.. but it's blowing up in memory
19:56:29 <xrz> roboguy_: https://github.com/AlexanderAA/GHC_Iface_error
19:57:52 <roboguy_> xrz: for me it just says "Illegal data type context ..."
19:57:58 <roboguy_> what version of ghc are you using?
19:58:24 <roboguy_> also, it's weird that you don't have main in the Main module...
20:00:02 <pingu> Has anyone seen a busy loop like this? http://lpaste.net/68036
20:00:26 <pingu> Obviously someone has, because I just googled for that one. I've managed to reproduce it though.
20:00:32 <pingu> unfortunately.
20:00:57 <xrz> roboguy_: 7.6.3
20:01:30 <roboguy_> xrz: that's what I'm using too. when you try to compile Main.hs with exactly the code you posted, it gives you that error?
20:03:42 <levi> qrada: How are you traversing?  You're going to need a strict, tail-recursive evaluator over a lazy data structure to avoid accumulating too much data, too many unevaluated expressions, or too big of a return stack.
20:04:35 <qrada> ya that's what's happening
20:04:50 <mcjohnalds> What's one of haskell's best functional gui packages?
20:05:05 <qrada> im recursing but it's not true tail recursive 'yet'
20:05:34 <qrada> i need to make it truly tail recursive but , not sure yet
20:05:35 <qrada> thank
20:05:35 <pavonia> mcjohnalds: Functional as in FRP?
20:05:42 <levi> qrada: But are you doing the evaluations strictly?
20:05:58 <levi> qrada: Lazy evaluation will bite you even with tail recursion.
20:06:11 <mcjohnalds> pavonia: I'm not sure there's any other functional way of doing GUIs, but if there is that'd be great to
20:06:25 <roboguy_> levi: I thought tail recursion wasn't really a big deal in haskell
20:06:36 <qrada> nah ive hardly ever used strict eval.. pretty new to haskell.. so ya i guess i need to make a strict version of my 'algorithm' first
20:06:45 <roboguy_> because of how the pattern stack works
20:06:55 <qrada> i also need to use vector for O(1) lookups.. right now im getting O(logn) using a Data.Map
20:08:05 <pavonia> mcjohnalds: I fear most (all?) of them are limited in the functionality the imperative back-ends provide
20:08:13 <levi> roboguy_: It really depends on how your program is structured.
20:08:19 * hackagebot ewe 0.1.0.38 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.38 (JuanFranciscoCardonaMcCormick)
20:09:05 <roboguy_> levi: how do you mean?
20:09:30 <xrz> roboguy_: I've updated the repository. I believe, that you should be able to clone it and compile with something like "cabal install"
20:11:55 <mcjohnalds> pavonia: That seems to be a common theme in haskell, any idea which one looks the best, or at least which one looks useable for small GUI applications?
20:11:55 <xrz> I also removed the unnecessary module, so there are just two .hs files. To reproduce the error, you need to compile everything. After that, make any minor change to Main.hs and recompile - you are likely to get that error.
20:12:08 <roboguy_> xrz: that's actually giving me no errors
20:12:13 <roboguy_> oh
20:12:38 <xrz> yes, add some space now to Main.hs and compile again
20:12:46 <levi> roboguy_: If your problem lends itself to tail recursion with a strictly evaluated accumulator, it can be far more efficient to do it that way.
20:13:18 <xrz> it seems, that cabal compiles only changed files by default, and that is exactly what is needed
20:13:19 * hackagebot markdown2svg 0.0.1.19 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.19 (YoshikuniJujo)
20:13:31 <roboguy_> xrz: actually, that does look like a bug
20:13:32 <levi> mcjohnalds: Are you looking for GUI widgets and whatnot, or something like a game?
20:13:36 <fozworth> i'm trying to learn the basics of making a haskell package and would love some feedback on what i've got so far -> https://github.com/tfausak/hop
20:13:36 <roboguy_> it works in ghc 7.8
20:13:39 <roboguy_> though
20:14:19 <roboguy_> levi: doesn't it have to do more with strictness than tail recursion though (in haskell)?
20:14:22 <mcjohnalds> levi: Something like GTK or QT
20:15:25 <levi> mcjohnalds: Not sure what people are using for FRP GUIs like that. I think most just stick with imperative APIs and GTK. FRP is much more widely used in game-type GUIs.
20:16:21 <levi> roboguy_: Lazy tail recursion is not very helpful, but strict non-tail recursion still accumulates space proportional to the recursion depth.  How could it not?
20:17:21 <mcjohnalds> levi: alrighty then that'll have to to, thanks for the advice
20:17:51 <levi> mcjohnalds: There might be some, though, I'm just not familiar with them.
20:19:01 <roboguy_> levi: it just seems like dividing it into tail recursion vs non-tail recursion might obscure the real issue of what should and what shouldn't be strict
20:19:20 <mcjohnalds> levi: Unless there's a really good one I'm just going to stick with writing imperative code, it's not a huge deal
20:20:02 <levi> mcjohnalds: Well, you can always write a bit of glue code between the widgets you need and a FRP library like reactive-banana or netwire.
20:21:29 <mcjohnalds> levi: reminds about that xkcd comic about how standards proliferate
20:21:54 <xrz> roboguy_: Thanks a lot for reproducing, I'll try to report that.
20:22:10 <roboguy_> xrz: it looks like it's already fixed in ghc 7.8
20:22:20 <levi> roboguy_: Both things ought to be considered if the problem is non-trivial enough to cause crashing. Ultimately you need to understand how your program is evaluating and how that compares to the best way of evaluating for your problem.
20:23:04 <levi> Sprinkling bangs and $!s randomly through your program is unlikely to help much.
20:23:37 <roboguy_> levi: tail recursion can be less efficient than non-tail recursive equivalents though
20:23:41 <xrz> roboguy_: Ah, right
20:23:46 <roboguy_> (in Haskell)
20:24:51 <levi> roboguy_: Not for problems that are amenable to strict tail recursion.
20:28:17 <levi> roboguy_: http://www.slideshare.net/tibbe/highperformance-haskell
20:31:04 <levi> There are situations where nicer-looking programs will be just as efficient, but strict tail recursive functions are more or less the "assembly language" of functional programming.
20:31:04 <roboguy_> levi: http://www.vex.net/~trebla/haskell/lazy.xhtml
20:33:16 <levi> roboguy_: That says nothing about strict tail recursion, though.
20:33:32 <roboguy_> levi: I think the point is that this issue has to do with strictness, not tail calls
20:33:41 <roboguy_> levi: also, there's a relevant discussion http://ircbrowse.net/browse/haskell?id=17278298&timestamp=1390006057#t1390006057
20:34:42 <roboguy_> > foldl (+) 0 [1..1000000]
20:34:44 <lambdabot>  *Exception: stack overflow
20:34:46 <roboguy_> > foldl' (+) 0 [1..1000000]
20:34:48 <lambdabot>  500000500000
20:35:21 <levi> roboguy_: I didn't start programming in Haskell yesterday.
20:35:33 <roboguy_> well, neither did I
20:36:35 <roboguy_> I'm just saying that tail recursion doesn't really seem to be the issue and strictness does
20:36:53 <roboguy_> it seems to me that tail recursion is more important in strict functional languages
20:36:56 <levi> I never said that strictness wasn't an issue.
20:38:04 <levi> But your foldr is *still* going to accumulate space unnecessarily vs foldl', and it can cause problems if you accumulate enough of it.
20:38:24 * hackagebot purescript 0.3.13 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.13 (PhilFreeman)
20:39:25 <levi> A foldr in Haskell is wonderful for lazy memoizing recursive algorithms, but wasteful versus foldl' when summing a list of numbers.
20:40:45 <oakwhiz> > data Test1 = String | Int ; test2 :: Test1 ; test2 = "Hi"
20:40:47 <lambdabot>  <hint>:1:1: parse error on input `data'
20:43:25 * hackagebot markdown2svg 0.0.1.20 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.20 (YoshikuniJujo)
20:43:55 <oakwhiz> When I run that snippet in ghci, I get: Couldn't match expected type `Test1' with actual type `[Char]'
20:44:08 <oakwhiz> why does this happen?
20:44:54 <roboguy_> oakwhiz: you are defining a new type, separate from String
20:44:58 <levi> > foldr (+) 0 [1..1000000]
20:45:00 <lambdabot>  *Exception: stack overflow
20:45:57 <roboguy_> levi: I guess my point is that, in my opinion, the strictness is more fundamental to the issue. foldl doesn't sum numbers any better than foldr even though it's tail recursive. foldl' does because it is strict
20:46:35 <levi> roboguy_: Ahem. Note that *only* foldl' works in this situation.
20:46:39 <roboguy_> oakwhiz: if you want a type *synonym* use "type" not "data"
20:47:09 <roboguy_> levi: I'm aware, but it is the strictness that sets it apart. the tail recursion is a consequence of this
20:47:10 <levi> roboguy_: Understanding evaluation in general is essential, not just one factor or the other.
20:49:32 <levi> I don't understand why you are insisting that one is more important than the other, when clearly a misunderstanding of *either* can cause stack exhaustion.
20:50:42 <L8D> what's the unix command to locate all matching files in $PATH?
20:50:49 <L8D> or is it an option for `which`?
20:50:52 <levi> And, if you look back at the advice I gave, I emphatically cautioned that being tail recursive would not be helpful without also being strict.
20:51:06 <L8D> found it, which -a
20:51:11 <roboguy_> man which
20:51:15 <roboguy_> hm
20:51:35 <L8D> sorry.
20:51:38 <L8D> wrong channel
20:54:31 <roboguy_> levi: I guess it is a good thing to know, but it does seem important to point out the fact that it works differently than a strict language which you did mention
20:55:45 <roboguy_> if the results of something like foldr are consumed and GC'd almost immediately, it is not really less efficient than tail recursion for instance
20:57:12 <levi> But for a function like sum, it *can't* be consumed.  The rest of the function (because it's not tail recursive, there's remaining work to be done on each element) holds references to each list element!
20:57:35 <levi> This is what I meant by understanding the structure of your problem.
20:58:20 <roboguy_> well, it can be consumed if you use lazy numbers but that's neither here nor there. that's true
20:59:26 <levi> I'm not sure how you can foldr over a list of integers, summing them, and not hold references to each element.
21:00:30 <codygman> levi: I tried adding the writerStandAlone option on pandoc and it gives me an empty string: http://lpaste.net/99758
21:00:43 <levi> You don't even start applying the function until you've got to the end of the list.
21:01:13 <roboguy_> levi: the main thing that makes me think that strictness is a bit more fundamental is that ghc doesn't really have a call stack
21:01:21 <roboguy_> as I understand it, anyway
21:01:51 <lispy> more fundamental?
21:02:09 <roboguy_> maybe that's not the right word
21:02:33 <levi> roboguy_: It does, but it's not the same as the C call stack. It does still limit the stack, clearly, or you wouldn't get stack exhaustion notices on right folds.
21:03:06 <lispy> It has a stack but not a call stack
21:03:17 <lispy> ghc's stack is more like an evaluation stack
21:03:37 <lispy> whereas a cal stack is about where you've been
21:04:05 <levi> No, call stacks are records of the work left to be done in previous activation records.
21:04:08 <roboguy_> lispy: what do you say tail recursion: very relevant in haskell or not as relevant as strict functional languages?
21:04:25 <lispy> roboguy_: not usually relevant
21:04:47 <kusut> hows the verdict on the new "beginning haskell" book? it is good, right?
21:04:49 <roboguy_> that's the discussion, currently
21:05:38 <lispy> Typically (and I gather levi already pointed this out) tail recursive definitions in haskell need to be strict in the accumulator.
21:05:56 <lispy> on the other hand, you can think of every function call as a tail call
21:06:26 <levi> Sure, as long as you pass the continuation with the rest of your parameters.
21:06:32 <lispy> So I guess it's that tail recursion is rarely a worthwhile transformation to apply by hand, but tail call itself is relevant because it's going on all the time
21:08:17 <lispy> roboguy_: For anyone who wants to better understand how GHC evaluates your programs, I can't recommend SPJ's book enough. It has exercises and everything.
21:08:39 <lispy> roboguy_: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
21:09:27 <lispy> There are even sections on how the compiler infers strictness. At least for simple cases.
21:09:51 <roboguy_> lispy: that's sort of what I was getting at, but I couldn't think of a good way to explain it
21:10:05 <levi> codygman: You might try playing with the pandoc binary and see what options you need to get the effect you're after. Then just set those in your program.
21:10:05 <roboguy_> I'll definitely look into the book though, I've heard a lot of good things
21:10:18 <levi> It is a good book.
21:12:15 <lispy> roboguy_: If you want a hardcopy, I think you can find it on cafepress. I just sat down with the PDF, rewrote the example code, and worked through the exercises.
21:12:19 <roboguy_> especially since language implementation is pretty interesting to me in general
21:12:48 <lispy> You should know that the code in the book is techincally miranda, but as a Haskell programmer it should be clear what the code means.
21:13:00 <roboguy_> I wrote a really simple forth compiler a few weeks ago, but I'd like to learn a little more about those things
21:13:17 <lispy> Neat. I've never looked at forth
21:13:23 <levi> But again, my point was not that tail recursion is paramount, but that understanding your problem and how haskell will evaluate any given solution is what you need to know. There are many different ways to run out of resources on big problems!
21:13:35 <roboguy_> lispy: it's *sort of* like if lisp was postfix instead of prefix
21:14:12 <roboguy_> levi: that's true
21:14:32 <roboguy_> sorry if I came across as too argumentative. I'm still learning about this stuff
21:14:35 <lispy> levi: That's very true. I think the thing people struggle with is how to go from, "Okay I need to understand how haskell will evaluate this" to an actual understanding.
21:15:13 <lispy> That's where SPJ's book is brilliant. Also, talking to people here is valuable.
21:15:16 <levi> lispy: I agree. I have been working on it for a while, but I still sometimes get stuck in wrong patterns of thinking.
21:15:41 <roboguy_> I'm curious of how they implement thunks. I used a very simple implementation in my forth compiler which probably isn't very practical
21:15:46 <levi> roboguy_: No problem, I do the same thing sometimes.
21:17:02 <levi> I don't think thunks are a typical Forth implementation strategy. IIRC, typical early implementations were threaded-code interpreters, and modern ones are either threaded-code interpreters or traditional compilers.
21:17:29 <levi> (not to say that your strategy was *wrong*, just atypical)
21:17:32 <roboguy_> yeah I wasn't sure about that too actually
21:17:49 <roboguy_> I have quoting as a basic operation, though
21:18:05 <roboguy_> by quoting, I basically mean explicit lazy evaluation
21:19:01 <roboguy_> like you could implement if like ": if rot coll;     : true swap call ;    : false call ;"
21:19:07 <roboguy_> *call
21:19:25 <roboguy_> then have something like "true [1] [2] if"
21:20:19 <roboguy_> I wonder how much mileage I can get out of definitions like that...
21:26:21 <levi> Sounds a bit like Factor
21:26:56 <levi> And a bit like Joy, which was one of Factor's inspirations.
21:31:06 <levi> Smalltalk worked that way, too. So you can clearly get a lot of mileage out of it, although efficiency is another matter.
21:33:21 <mzero> er? did someone say Smalltalk?
21:33:32 * mzero was on the Smalltalk team at Apple
21:33:41 <Madarc> did they, i auto replace smalltalk in my mind with poo
21:34:01 <mzero> !
21:35:35 <shachaf> Come on. There's no need to be rude.
21:35:36 <roboguy_> mzero: I never really figured out how you run smalltalk code. do you always need some sort of virtual machine type thing?
21:36:59 <codygman> levi: Thing is, the default pandoc command converts to pdf just fine. I guess I need to look up the source to it and follow exactly what it does.
21:37:04 <mzero> Yes. It was a relatively exotic wild idea: If you'd imlement the virtual machine (~100 opcodes, ~100 primitives) .... then you could take this whole image file and run it - giving you a full GUI environment, with development environment embedded
21:37:25 <mzero> But furthermore, as concieved, Smalltalk programs only ran within that environment
21:37:46 <mzero> though later comercial systems found ways to "seal" the enviornment up, and package it, so you could delvier it as an applciation
21:37:49 <Madarc> yeah, that was my huge problem with it
21:38:06 <mzero> remember that dynamic compliation was pioneered on Smalltalk (the Deutch-Schiffman compiler)
21:38:57 <mzero> Many programming environments shared this stance: logo and basic for example
21:39:23 <Madarc> yeah, but logo was specifically designed as a beginner's language
21:39:28 <mzero> notice that all of these (basic, logo, smalltalk, and even early pascal) were products of people thinking about teaching
21:39:31 <simpson> mzero: Oh hey, that's awesome. Did you happen to work with any of the guys that worked on E?
21:39:43 * simpson is working on a modern E environment
21:39:56 <mzero> Later, when I first worked at Google, I worked with Mark Miller
21:40:03 <mzero> though not on E
21:40:25 * Madarc giggles
21:40:35 <mzero> Madarc - Smalltalk WAS designed as a learning teaching and exploring system
21:40:39 <simpson> Yeah, he's working on that Caja thing.
21:40:48 <mzero> it came out of Xerox's Learning Research Group
21:41:08 <mzero> Actually, he's moved on - there is a whole team for Caja!
21:41:08 <Madarc> mzero, rephrase, logo was designed for teaching 10 year olds
21:41:13 <simpson> Out of the original gang, it seems only Allen's still un-Googled.
21:41:21 <mzero> Madarc - as was Smalltalk
21:41:42 <mzero> It just happened to have (for the time) many incredible system and language ideas
21:41:59 <mzero> Alan Kay's primary interest was, and has always been, teaching children to think
21:42:15 <mzero> everything else is just a means to that end
21:45:13 <levi> The thing that reminded me of Smalltalk was that even conditionals were implemented as message sends to a boolean object, and both branches were passed as blocks.
21:46:03 <mzero> yes, the message is   ifTrue:ifFalse:   (actually ifFalse:ifTrue:, ifTrue:, and ifFalse: all exist too)
21:46:07 <levi> (at least they were implemented that way conceptually, I understand some implementations were more clever about how they actually implemented them.)
21:46:09 <Ymesio> Good night
21:46:14 <Ymesio> What's wrong here:
21:46:15 <Ymesio> calc :: (Num a) => String -> a
21:46:15 <Ymesio> calc symbols = length( symbols )
21:46:18 <Ymesio> ?
21:46:32 <mzero> no parens
21:46:42 <mzero> and length returns Int
21:46:47 <mzero> not arbitrary Num a
21:46:59 <Ymesio> melter: Should I say Int instead of Num a?
21:47:01 <mzero> so     clac :: String -> a
21:47:10 <mzero> calc symbols = length symbols
21:47:16 <mzero> er
21:47:22 <mzero> calc :: String -> Int
21:47:30 <mzero> do you really need it to be Num a?
21:47:48 <levi> mzero: I got to meet Alan Kay a few years back. He was one of my main inspirations for getting back into computer science, and I was a huge Smalltalk fan for years.
21:47:53 <Ymesio> mzero: hm, I think you're right, I want it to be an Int
21:48:00 <Ymesio> And compiler is right
21:48:15 <Ymesio> mzero: Thanks, it's my first haskell function :)
21:48:56 <mzero> levi: Indeed, the standard implementation did a bit of a hack: the four messages I mentioned were actually tranlasted into calls to   asBoolean and then jumps (if the blocks were of the right forms)
21:49:28 <mzero> so you could still override conditionals for your own classes, but you had to overried asBoolean, not ifTrue:ifFalse
21:49:58 <mzero> Ymesio: remember, parenthesis don't surround arguments to a function in Haskell
21:50:03 <mzero> (or in Smalltalk for that matter!)
21:50:37 <Ymesio> mzero: Got it,
21:52:47 <levi> I really like Smalltalk's message selector syntax. I think it's too bad that not many other languages followed its syntax.
21:53:27 <mzero> heh, you'd like my successor language (to Smalltalk): Glyphic Script -- it followed Smalltalk's lead, but got rid of colons... it used bold instead!
21:53:33 * hackagebot webdriver 0.5.3.2 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.3.2 (AdamCurtis)
21:53:33 <mzero> source code looked great!
21:53:56 <mzero> http://www.ozonehouse.com/mark/codeworks.html
21:54:37 <levi> mzero: I followed the Slate language and a couple of others that borrowed Smalltalk syntax for a while, but I eventually got too distracted by other things.
21:55:09 <levi> Everyone's either in the Algol, C, or ISWIM syntax traditions these days.
21:55:26 <levi> Except for Erlang, which borrows from Prolog of all things.
21:56:04 <levi> Well, I guess we do have Obj-C carring the Smalltalk message selector torch.
22:04:30 <Platz> Lots of ruby folks pay homage to smalltalk, though matz seems to deny it
22:07:17 <levi> That's not the impression I got from matz. It's clear smalltalk was one of his inspirations, though surely not the only one.
22:08:21 <Platz> ah, that makes more sense
22:13:35 * hackagebot conduit-extra 0.1.5 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.5 (MichaelSnoyman)
22:25:30 <fread2282> what package has the "as" function?
22:26:30 <shachaf> You might be more qualified than anyone here to answer that, if you have any sort of idea what the context is.
22:29:31 <fread2282> shachaf: it was for type resolution
22:29:44 <fread2282> can lambdabot do searches?
22:29:57 <Iceland_jack> @hoogle [a] -> a
22:29:58 <lambdabot> Prelude head :: [a] -> a
22:29:58 <lambdabot> Data.List head :: [a] -> a
22:29:58 <lambdabot> Prelude last :: [a] -> a
22:30:22 <fread2282> @hoogle (as :: a)
22:30:22 <lambdabot> Parse error:
22:30:22 <lambdabot>   (as :: a)
22:30:22 <lambdabot>         ^
22:30:27 <fread2282> @hoogle as
22:30:28 <lambdabot> Prelude asin :: Floating a => a -> a
22:30:28 <lambdabot> Prelude asinh :: Floating a => a -> a
22:30:28 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:30:42 <fread2282> yeah, but hoogle is limited to the core libraries
22:30:47 <Iceland_jack> fread2282: is it possible that ‚Äòas‚Äô is a variable?
22:30:56 <fread2282> Iceland_jack: no, it's a function
22:31:02 <Iceland_jack> just making sure
22:31:16 <fread2282> maybe a typeclass though
22:31:34 <Iceland_jack> A method of a type class or an actual type class?
22:31:42 <Iceland_jack> In which case it would be upper case: As
22:32:10 <startling> fread2282, I doubt anyone can help you without more context.
22:32:17 <fread2282> wait, I think I remember what it was
22:32:23 <fread2282> thanks
22:32:37 <roboguy_> fread2282: is it this? https://www.fpcomplete.com/hoogle?q=as&env=ghc-7.4.2-stable-13.09
22:32:45 <roboguy_> (the first one)
22:32:58 <fread2282> roboguy_: yep, thanks
22:51:10 <jfischoff> hmm, I just switch from 7.6.3 to 7.4.2 and my doctests are working
22:51:17 <carter> Q: who's  currently in charge of lambda bot?
22:51:32 <jfischoff> I think elliot
22:51:44 <jfischoff> or three lll ellliot
22:51:54 <jfischoff> or maybe not
22:52:03 <jfischoff> Cale might be able to help
22:52:39 <carter> ok
22:53:06 <Cale> It's int-e
22:54:18 <carter> int-e: could you add #numerical-haskell to lambdabot's list of channels?
22:54:19 <carter> :)
22:54:31 <carter> its getting enough people now that its kinda becoming a real channel! :_
23:02:13 <DrAwesomeClaws> I just used a Maybe monad without a tutorial directing me to do so and it worked.
23:02:16 * DrAwesomeClaws celebrates
23:02:44 <Iceland_jack> congratulations :)
23:02:57 <DrAwesomeClaws> ty
23:03:05 <Iceland_jack> Now try doing it with the (Either a) monad!
23:03:06 <startling> carter, is that like "ironical"?
23:03:20 <carter> startling:?
23:03:24 <carter> what typo did i do?
23:03:31 <carter> i've had a lont few days?
23:03:36 <carter> *long
23:03:40 <startling> haha
23:03:47 <startling> carter, I'm just curious why it's "numerical" rather than "numeric"
23:04:00 <carter> numerical computing
23:04:09 <DrAwesomeClaws> I remember doing something with a type Either String String at some point
23:04:11 <startling> is that the standard phrasing? hm.
23:04:28 <carter> no one says "* numerics"
23:04:29 <DrAwesomeClaws> it appears it's not in the codebase anymore, but I remember that being pretty intuitive.
23:04:34 <carter> they say "numerical *"
23:04:47 <DrAwesomeClaws> but that was tutorial directed or retyped code
23:04:51 <startling> carter, I meant "numeric haskell".
23:04:55 <carter> yea
23:05:06 <dmj`> anyone using continuous integration software w/ haskell?
23:05:07 * startling shrugs
23:05:26 <carter> startling: both are probably right
23:05:27 <carter> idk
23:05:33 <startling> dmj`, the ekmett ecosystem makes heavy use of travis
23:05:54 <carter> travis ci is why 7.8 upgrades will be easier than in the past
23:06:14 <carter> startling: also henning's got numeric-prelude
23:06:24 <carter> sooooo, name space
23:06:28 <startling> carter: haha
23:06:52 <carter> he did bsdify it after i did the leg work to get the ok from all his contributors
23:06:53 <carter> BUT
23:07:11 <carter> yeah
23:07:13 <carter> btw http://www.thefreedictionary.com/numeric
23:07:24 <carter> says its a variant of numerical when used as an adjective
23:08:12 <startling> yeah, just like "ironical". :)
23:08:31 <carter> or mathematical
23:08:32 <carter> :p
23:08:55 <carter> but numerical computing is a phrase people hear
23:08:59 <carter> not numeric computing
23:09:08 <carter> sounds like a counting spice
23:09:14 <carter> needs more numeric
23:09:15 <carter> :P
23:09:24 <startling> tumerical.
23:09:29 <carter> yes
23:09:48 <startling> I think it's tumerical enough already, tyvm.
23:09:55 <carter> hehe
23:10:01 <carter> huh, theres a numeric java script
23:10:02 <carter> http://numericjs.com/
23:11:09 <ethercrow> what's correct, americ or americal?
23:11:24 <carter> aetherical
23:11:25 <carter> :P
23:11:30 <carter> rather than aetherial
23:12:51 <startling> but ethereal?
23:13:00 <ion> √¶thern√¶t
23:13:21 <dmj`> startling, carter: travis sounds nice, but I'm using bitbucket since I don't want to pay for repos :-/
23:13:28 <carter> dmj`: ahhh
23:13:31 <carter> drone.io
23:13:32 <carter> :)
23:13:52 <carter> dmj`: public or private?
23:13:52 <startling> drone.io supports bitbucket? huh.
23:13:55 <carter> yah
23:14:03 * startling needs to learn the ci ecosystem better
23:14:03 <carter> they also opensourced their statck recently
23:14:18 * startling is probably starting work at a ci company pretty soon.
23:14:31 <carter> oh?
23:14:32 <carter> which one?
23:14:35 <startling> carter, circle
23:14:38 <carter> ohhhh
23:14:43 <carter> where are you based?
23:14:55 <startling> carter, they're in SF. I'm moving there soon.
23:15:02 <carter> wait, where are you based now?
23:15:09 <startling> carter: outside of chicago.
23:15:09 <carter> i'm visitning sf this week
23:15:29 <dmj`> startling: what suburb?
23:15:35 <startling> carter: you'll probably beat me there.
23:15:42 <startling> dmj`, lombard
23:15:51 <dmj`> startling: ha, I grew up in wheaton :/
23:15:56 <dmj`> :) *
23:16:20 <startling> dmj`: oh neat, I grew up in winfield.
23:16:21 <dmj`> startling: have you come to the chicago meetups?
23:16:32 <dmj`> startling: ha, crazy
23:16:34 <startling> dmj`: no, they've all been timed pretty badly for my schedule.
23:18:03 <dmj`> startling: had enough of this weather huh? off to SF you go. I see
23:18:08 <dmj`> ;)
23:18:21 <startling> dmj`: yeah, thank god.
23:19:13 <dmj`> startling: don't blame ya
23:24:49 <Student93> hey
23:25:16 <ocfx> hi
23:25:54 <Student93> i could use some help wrapping my mind around patterns and recursion in haskell
23:26:15 <Student93> looked around on line, and got pretty sick of the factorial example
23:26:25 <dmj`> In order to understand recursion one must first understand recursion
23:26:30 <Student93> ha
23:26:32 <verement> patterns, recursion, and Haskell, oh my
23:26:41 <ocfx> lol
23:26:46 <Student93> it's throwing me for a bit of a loop
23:26:52 <startling> Student93: yeah, the factorial example is a bad example.
23:26:53 <ocfx> lo lloop get it
23:27:02 <Student93> I'm hilarious, I know
23:27:03 <startling> Student93, mapping over lists is a better one.
23:27:33 <Student93> if only it were that easy. Taking a class right now, they're not letting us use any mapping functions
23:27:37 <Student93> simple recursion
23:27:55 <dmj`> Student93: it's all about the base case my friend
23:28:00 <startling> Student93, sure. we can write the mapping function right now to give you a better handle on recursion, though.
23:28:00 <Student93> I get the arithmetic recursion just fine, it's manipulating lists that is throwing me off
23:28:15 <dareTake> Try converting simple for loops into recursive functions
23:28:18 <threeifbywhiskey> It's cons cells all the way down.
23:28:20 <Student93> Let me give it a shot, see if I can get it
23:28:46 <Student93> map _ [] = []
23:28:53 <startling> Student93: sure. the important thing to realize is that we know "a list is the empty list ([]) or an element prepended to another list (with :)"
23:29:08 <dareTake> try @hoogle repeat
23:29:18 <Iceland_jack> @src []
23:29:18 <lambdabot> data [] a = [] | a : [a]
23:29:53 <dareTake> @src repeat
23:29:53 <lambdabot> repeat x = xs where xs = x : xs
23:29:53 <Student93> yeah I've looked and looked. How about I give you guys the problem I'm currently looking at. I'd prefer not to get an outright answer, since it's for class and such, but you know
23:29:56 <codygman> I've been debugging this for a while and I'm still not sure why pandoc is throwing out the header of latex files: http://lpaste.net/99762
23:29:56 <Student93> perils of irc and all
23:30:18 <startling> Student93, ok, so obviously we need to apply the function to the head of the list somehow
23:30:37 <startling> Student93, that gives us map f (a : as) = f a ...
23:31:15 <startling> Student93, but that's not right since it doesn't affect the rest of the list
23:31:16 <Student93> still on map? map (x:xs) (y:ys) = [(x,y)]: map xs ys
23:31:19 <Student93> ?
23:31:35 <startling> Student93, that's not what map does.
23:31:37 <startling> :t map
23:31:38 <lambdabot> (a -> b) -> [a] -> [b]
23:32:41 <threeifbywhiskey> http://lpaste.net/99763
23:32:45 <Iceland_jack> Student93: I suggest trying to implement ‚Äúlength‚Äù first
23:32:59 <threeifbywhiskey> I understand why it's not type-checking, but how do I get it to?
23:33:18 <dareTake> Student93 : try repeat yourself, just keep on adding numbers indefinitly to a list
23:33:19 <threeifbywhiskey> (floor . sqrt) doesn't do the trick, and I'm not quite sure what an instance declaration is.
23:33:37 <threeifbywhiskey> (thing :: type) is an instance declaration, presumably?
23:33:45 <Cale> threeifbywhiskey: Perhaps use (takeWhile (\k -> k*k <= n) [3,5..])
23:34:11 <threeifbywhiskey> Yes, that's certainly a solution, and thank you for it.
23:34:18 <verement> :t sqrt
23:34:19 <dareTake> then try to limit it to a number like take 5 (repeat 5). So you understand base cases.
23:34:19 <lambdabot> Floating a => a -> a
23:34:25 <dareTake> :t length
23:34:26 <lambdabot> [a] -> Int
23:34:27 <Cale> threeifbywhiskey: floor (sqrt (fromIntegral n)) would work for a while
23:34:36 <dareTake> yep length is good too
23:34:36 <threeifbywhiskey> For a while?
23:34:53 <Cale> Floating point numbers are limited in precision
23:35:10 <Student93> so if I set the condition map f [] = [] as my base case, can I use map f (x:xs) = f x : map f xs?
23:35:16 <Iceland_jack> yes you can Student93
23:35:20 <Cale> adding 1 to that would keep it going a bit longer, but eventually it'll fail
23:35:24 <Student93> awesome
23:35:40 <startling> Student93: exactly.
23:35:45 <dareTake> yep
23:35:50 <Cale> (or using round instead of floor would similarly help a bit)
23:36:23 <threeifbywhiskey> Makes sense. Thanks again, Cale.
23:36:30 <Iceland_jack> Student93: The most important thing to take away from that is that lists only have two possible cases: empty (represented as []) or non-empty (represented as (x:xs))
23:36:41 <dmj`> carter: I just want free hosted CI w/ free private repos :(
23:36:45 <Iceland_jack> It's a pattern you'll see over and over again
23:36:47 <dareTake> It helps to think about just one step in the recursion, then set a limit with a base case.
23:36:54 <Student93> but that's almost easier to comprehend, it uses two variables and the recursion is self explanatory in that case. what if I wanted to take in a list of elements and generate a list of tuples of every possible combination of those elements
23:36:58 <threeifbywhiskey> dmj`: Travis has a free plan, don't they?
23:37:00 <Student93> sorry, two arguments
23:37:22 <dmj`> threeifbywhiskey: Maybe, but I'm using bitbucket, which doesn't work w/ travis apparently
23:37:29 <threeifbywhiskey> That's a shame.
23:37:55 <Student93> so the list [1,2,3,4] would return [([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])]
23:38:32 <Iceland_jack> Student93: no ([], [1,2,3,4]) and ([1,2,3,4], [])? :)
23:38:32 <Iceland_jack>     
23:38:34 <dmj`> threeifbywhiskey: maybe I'll just move to github...
23:38:55 <Student93> exactly, so the base case would be f [x] = [x]...
23:38:56 <Student93> I think
23:39:02 <dmj`> sometimes github go down tho
23:39:40 <Iceland_jack> Student93: You may want to try simpler cases, but that could be neatly solved using a local function
23:39:41 <Student93> I don't even know that that's the right approach. I thought about using helper functions and replacing the (h:t) patter with (header,ender) where header= something something but I don't know where to gofrom there
23:40:00 <Iceland_jack> You're on the right track with the helper function
23:40:04 <Student93> okay cool
23:40:36 <threeifbywhiskey> Just make sure your helper functions' names end with apostrophes, multiple ones if necessary.
23:40:44 <Student93> is that convention?
23:40:50 <threeifbywhiskey> I believe so.
23:40:53 <Iceland_jack> Student93: Not multiple ones..
23:40:55 <threeifbywhiskey> The apostrophe is pronounced "prime".
23:41:03 <Student93> alright, just checking
23:41:06 <Iceland_jack> But using a single one, sure: it's a matter of taste
23:41:32 <Student93> thank you all for the help, I appreciate it!
23:41:37 <Student93> I'll probably check back in later
