00:17:12 <zRecursive> How can i just see the "git diff" of remote repo ?
00:17:27 <johnw> what would that be a diff against?
00:17:52 <zRecursive> the diff between the local and remote
00:18:04 <johnw> add the remote, and then diff against one of its refs
00:18:09 <johnw> git remote add -f remote URL
00:18:16 <johnw> git diff HEAD remote/SOMEREF
00:18:33 <johnw> you cannot get around having to download its commits
00:18:34 <zRecursive> the local is `git clone` before
00:19:01 <Maxdamantus> you can just fetch a particular branch though, without adding it as a remote.
00:19:07 <johnw> ah, then just git diff master origin/master, if that's the branch you're on
00:19:07 <zRecursive> i just want to see the changed code since cloned
00:19:11 <Maxdamantus> and you'll refer to it as FETCH_HEAD
00:19:12 <johnw> ah
00:19:17 <johnw> git log -p ..origin/master
00:20:58 <zRecursive> `git log -p ..origin/master` no ooutput, but `git log -p` does !
00:21:16 <johnw> are you on master?
00:21:44 <zRecursive> i am not sure
00:21:48 <johnw> if you are, and there is no output, it means nothing has changed; try doing "git fetch" before you do that command
00:22:05 <johnw> also, we can talk more in #git
00:22:30 <zRecursive> johnw: ok, thanks
00:22:56 <johnw> hi
00:23:00 <johnw> oh, n/m
00:27:36 <supki_> Twey: I didn't mean to imply there's anything wrong with it
00:27:42 <supki_> I just haven't used it (yet)
00:28:31 <Twey> Ah, okay
00:28:51 <Twey> I get the impression pipes is the library to go for these days
00:39:56 <satc_> Is it possible to not export instances from a module?
00:40:43 <supki_> no
00:41:13 <supki_> they're also always imported
00:41:25 <supki_> it's called the open world assumption
00:44:34 <kadoban> okay...how is member O(min(n, W)) and notMember O(lg n)? http://hackage.haskell.org/package/containers-0.4.2.1/docs/Data-IntMap.html#v:member
00:44:58 <satc_> supki_: So what happens when two modules defining instances for the same type are imported in a third module?
00:45:25 <Feuerbach> kadoban: just a mistake, obviously
00:45:38 <kadoban> okay, just making sure
00:45:58 <Feuerbach> kadoban: probably was copypasted from Data.Map
00:46:36 <Twey> kadoban: They're both O(min(n, W))
00:47:10 <kadoban> thanks :)
00:47:13 <Feuerbach> kadoban: it's fixed in the latest version, btw http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Lazy.html
00:47:37 <kadoban> oh, hmm. i wonder how i always end up on old docs every time i look
00:47:58 <Twey> That's a silly notation.  W is only going to be about 64; might as well not include it in the complexity
00:48:35 <Twey> In fact, it's strictly redundant, since O implies a lower bound to the validity of the complexity anyway
00:48:53 <kadoban> yeah, it does seem a little odd.  i guess it's just to give more detail than just everything being O(1)?
00:49:07 <Twey> kadoban: It's O(n)
00:49:40 <kadoban> Twey: err, it is?
00:49:49 <Twey> Oh, wait
00:49:55 <Twey> That's an *upper* bound
00:49:58 <kadoban> yeah
00:49:58 <Twey> Okay.
00:51:48 <kadoban> i should test these things out...sure seems like they should be my default data structures, unless the constants are just completely ridiculous
01:05:17 <quicksilver> Twey: basically the thing is that asymptotic complexity doesn't make any sense.
01:05:32 <quicksilver> Twey: if you take the view that "W is about 64, you might as well ignore it"
01:05:45 <quicksilver> Twey: then you also have to say "log n is under 64, you might as well ignore that"
01:06:00 <quicksilver> Twey: and then all your log-complexity operations become O(1)
01:06:09 <quicksilver> which maybe they should be, since O(1) doesn't exist either.
01:06:13 <quicksilver> it's all smoke and mirrors...
01:06:37 <kadoban> it's pretty useful smoke and mirrors though
01:06:57 <quicksilver> yup
01:10:08 <Twey> quicksilver: For this, yeah
01:10:57 <Twey> Oh, well, no
01:11:27 <Twey> The tree structure gives you honest O(log n) operations
01:11:48 <quicksilver> they might be honest O(log n), but log n is still bounded by W - a constant.
01:11:49 <Twey> Or, well, it gives you O(log n) operations until you collide, anyway
01:12:01 <quicksilver> you can't store more than 2^W elements in any container
01:12:04 <Twey> quicksilver: But after that it'll become O(n) or something, not O(1)
01:12:11 <Twey> Really?
01:12:27 <quicksilver> not on any machine with W-based addressing
01:12:34 <Twey> Oh, right
01:12:42 <quicksilver> you can't store more anythings than your machine can address
01:12:49 <Twey> Yes
01:13:01 <quicksilver> it's a kind of silly argument
01:13:15 <quicksilver> but the log n/W stuff in fingertree forces you to confront it
01:13:17 <merijn> If we're being theoretical, are you including a filesystem?
01:13:35 <merijn> (This question arose during a conversation whether C was Turing complete or not)
01:14:30 <quicksilver> merijn: I don't know really. Nobody knows what model we're using or what the argumetn is supposed to be.
01:14:50 <Twey> So I guess everything in IntMap is O(1)
01:14:53 <quicksilver> I'm not actually *that* interested in making it precise, just in pointing out the absurdity of other people's obviously wrong models :)
01:15:16 <Twey> merijn: Filesystems are finite too
01:15:32 <merijn> Twey: Oh? Why?
01:15:56 <Twey> merijn: Because we live in a universe with (as far as we currently know) a finite capacity for data storage
01:16:00 <merijn> *implementations* of file systems are necessarily finite, obviously
01:16:07 <quicksilver> You can obviously define a theoretical machine with unbounded integers addressing
01:16:20 <quicksilver> and define that it has O(1) pointer dereference even for those unbounded integers
01:16:27 <merijn> Twey: Well, the fact that an implementation is bounded by the universe is irrelevant for the discussion we had
01:16:32 <quicksilver> but that's quite a surprising system
01:16:34 <simon> in Arch Linux, should I really install cabal and ghc from pacman just so I can recompile them from cabal?
01:16:47 <merijn> Twey: For example, Haskell (the language) is Turing complete, as there is no size bound in the language
01:16:53 <quicksilver> or maybe surprising is the wrong word
01:16:56 <simon> I had hoped that cabal could bootstrap ghc itself.
01:16:58 <Twey> simon: You can't install GHC via cabal
01:17:15 <quicksilver> it doesn't seem close enough to real machines to be the write model
01:17:15 <Twey> merijn: *nod*
01:17:20 <simon> Twey, I thought I saw ghc as a package. but okay.
01:17:21 <merijn> Twey: C (the language) is not Turing-complete, as the spec mandates a fixed, finite pointer size that can address any value
01:17:41 <Twey> merijn: Huh.
01:17:46 <merijn> Twey: No, if we extend C with a filesystem interface that is not bounded, then C would be Turing complete
01:17:53 <merijn> s/No/Now
01:17:54 <quicksilver> simon: yes, there is a package called that but it's a confusing name.
01:18:01 <merijn> Twey: Where did I lose you?
01:18:04 <quicksilver> simon: the 'ghc' package contains 'some ghc private libraries'
01:18:16 <Twey> merijn: Oh, nowhere, I was just expressing my surprise.
01:18:20 <quicksilver> simon: but reinstalling it won't actually reinstall ghc.
01:18:27 <simon> quicksilver, ah, fine. :)
01:18:55 <merijn> Twey: Now, *obviousl* any implementation of such an unbounded file system interface will *in practice* be bounded, if we go of the assumption the universe is finite
01:19:05 <Twey> simon: Usually you would install GHC and cabal (and maybe the haskell-platform, if you're not planning on upgrading any of those packages) via your package manager, then install other things and possibly upgrade cabal via cabal
01:19:17 <merijn> However, since the *interface* isn't bounded, the theoretical C+filesystem language *would* be Turing complete
01:20:32 <quicksilver> merijn: which is a intuitive enough concept, since the turing machine itself was a "finite machine" and the only infinte part was the tape.
01:20:45 <Bfabio> ciao
01:20:49 <merijn> Completely unrelatedly, while we're on the subject of theory
01:21:27 <merijn> 1) Am I right in understanding that the arrows in the Banana, Lenses, Envelopes & Barbed Wire paper are profunctors? 2) Is there a more gentle explanation of that paper somewhere?
01:21:42 <edwardk> merijn: i don't see how they are
01:22:02 <quicksilver> that was a remarkably quick answer :)
01:22:10 <quicksilver> edwardk++ # ninja fact-checker
01:22:27 <merijn> edwardk: Well, "(f -> g) h = g . h . f"
01:22:28 <quicksilver> I actually hadn't read the question in that time.
01:22:39 <merijn> That *looks* like a profunctor to me?
01:23:24 <merijn> Furthermore "(f -> g) . (h -> j) = (h . f) -> (g . j)", which looks even more like that?
01:23:46 <edwardk> what is the -> you are using there?
01:23:49 <merijn> Alternatively, I'm grossly misundertanding the (very odd) notation used in this paper
01:24:07 <merijn> edwardk: The arrow operation defined in the paper
01:24:16 <merijn> I have no clue what it is, hence my question
01:24:22 <edwardk> bah, going back to a paper i havn't read in a few years one sec
01:24:34 <merijn> edwardk: Page 7 and 8
01:26:04 <merijn> To be honest, this entire paper reads like I'm rereading my haskell knowledge on acid
01:26:08 <edwardk> er that arrow is just (->) in hask, its breaking down the set of bifunctors canonically to get sums, products, exponentials
01:26:22 <merijn> It uses weird notation everywhere to confuse me :(
01:26:27 <edwardk> the exponential there is (->) s we know it, which is a profunctor of course
01:26:31 <edwardk> all the others are bifunctors
01:26:39 <edwardk> but none of the (| |), etc. things are
01:26:43 <merijn> edwardk: I have no clue what you just said :(
01:28:06 <edwardk> merijn: '(->)' isn't terribly relevant to the paper as a whole other than he uses it to show ADTs can all be defined canonically by breaking them down into sums, products, functions, etc.
01:28:23 <edwardk> as some ADTs contain functions
01:28:34 <edwardk> you'll occasionally see an (->)
01:28:45 <merijn> edwardk: Yeah, which is this whole ADTs are an algebra shtick where this 'derivative of a type" thing comes from, no?
01:29:14 <merijn> edwardk: tbh, the rest of the start of the paper isn't much clearer because the notation is so much different from the type theory stuff I'm used to
01:30:04 <edwardk> well that follows from realizing that the algebra in question forms a valid differential semiring
01:30:41 <edwardk> merijn: its rather different from the type theory almost everyone who wasn't raised on the Bird-style squiggol formalism is used to ;)
01:30:53 <merijn> Which is unfortunate, because as far as I can tell the stuff they're describing would be useful to me, but I dunno how to actually grok the thing
01:30:54 <edwardk> merijn: so its not just you ;)
01:31:25 <merijn> edwardk: Right, but did anyone ever write a translation for mere plebs like me? :p
01:31:27 <edwardk> merijn: my personal experience in this area is that it isn't as deep as the opaque notation makes it look
01:31:42 <edwardk> merijn: i wrote a blurb on catamorphisms, and wrote a field guide once
01:31:54 <edwardk> just kind of describing the different foo-morphisms
01:32:18 <merijn> edwardk: Can I find that anywhere?
01:32:31 <edwardk> merijn: comonad.com has both.
01:32:45 <merijn> ok, thanks
01:32:51 <edwardk> http://comonad.com/haskell/catamorphisms.html
01:33:09 <edwardk> http://comonad.com/reader/2009/recursion-schemes/
01:33:43 <edwardk> also i have a recursion schemes package, and if you go back to old versions of category-extras there are a bunch of separate modules full of them
01:33:52 <edwardk> not many examples though
01:33:59 <edwardk> i wasn't into those back then
01:38:52 <merijn> edwardk: Couldn't get others to write them for you back then? :p
01:41:00 <merijn> Not planning to use this for haskell anyway, planning to rip it off and sell it as groundbreaking in a different field :p
01:46:16 <jle`> when would i want something to not inline?
01:46:25 <jle`> why don't i throw inline pragmas everywherE?
01:46:33 <jle`> for non-recursive functions
01:46:35 <jle`> and helper functions
01:46:35 <predator117> merijn: I don't know if it helps, but I found this: http://blog.ezyang.com/2010/05/bananas-lenses-envelopes-and-barbed-wire-a-translation-guide/, though I did not yet read the paper
01:47:00 * hackagebot disk-free-space 0.1.0.0 - Retrieve information about disk space usage  http://hackage.haskell.org/package/disk-free-space-0.1.0.0 (MariosTitas)
01:49:05 <merijn> jle`: GHC already tries to figure out when it should inline stuff and inlining too much will explode the code size
01:49:49 <merijn> jle`: Unlike C, where figuring out whether something can be inlined is hard, knowing what *can* be inlined is trivial in Haskell and as a result GHC already aggressively inlines things
01:49:57 <jle`> ah. okay
01:50:08 <jle`> but why do i see inline pragmas sprinkled everywhere in source code i read?
01:50:14 <merijn> jle`: Adding random inlines everywhere is likelier to make things worse than better, unless you know what you're doing
01:51:08 <merijn> jle`: high performance packages like bytestring/text will compile their functions to core, study the core to see how it can be made more efficient and then add the appropriate inline pragma's to make sure GHC inlines them correctly
01:51:10 <jle`> i guess those people know what they are doing, then?
01:51:19 <jle`> ah okay
01:51:21 <jle`> i see
01:51:23 <jle`> so they test it against core
01:51:44 <merijn> jle`: Yeah, you should probably not add pragmas until you have profiled, found a hotspot, analysed the core and *know* that adding inline will make the problem go away
01:53:06 <merijn> edwardk: Any tips on further background reading? I see you use the term F-algebra too, but I've never seen it outside of the context of "papers I don't understand/gloss over", so I feel like I'm missing some crucial fundamentals, but I dunno which
01:57:19 <quicksilver> merijn: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
01:57:26 <quicksilver> merijn: (not wadler's most accessible paper I'm afraid)
01:57:34 <jle`> there are just small things that really i only have as a little function alias.  like for example if i made my own mconcat = foldr mappend mempty...that's just something that i would type in myself every time i used it, if it wasn't inconvenient
01:57:41 <jle`> but maybe that's not the point of inlining
01:58:22 <merijn> jle`: The smaller the function the more likely GHC is to inline it
01:58:32 <jle`> so i should trust ghc
01:58:41 <merijn> jle`: Well, trust but verify
01:59:14 <merijn> jle`: More importantly, don't prematurely optimise. Don't worry too much about performance until you profile and see it's a problem
01:59:31 <quicksilver> jle`: some of the packages you see with INLINE scattered everywhere are done so in ignorance :)
01:59:31 <merijn> jle`: Suppose GHC doesn't inline it, but your code is still fast enough, do you care?
01:59:45 <quicksilver> people like to do stuff they believe will help.
02:00:01 <quicksilver> otheres are indeed done by experts who studied the core before/after.
02:00:14 <quicksilver> you will also see code with over-liberal seq/!/deepseq
02:01:10 <kadoban> i seem to be using seq and friends way too much recently...bad habit to break
02:01:15 <merijn> jle`: Here's a good example of how to decide what to do: http://neilmitchell.blogspot.nl/2014/01/optimising-haskell-for-tight-inner-loop.html
02:01:17 <jle`> thanks all for the help
02:01:28 <jle`> merijn: ah yes i have read that
02:01:39 <jle`> i guess when it comes time to actually profile i should think about this then
02:02:12 <merijn> jle`: Keep in mind that for many programs a few cycles here and there just don't matter that much
02:02:21 <jle`> it is hard for me to consider inlines as premature optimizations becuase they are so unobtrusive in the source code
02:02:34 <jle`> but i can see that they might cause more toruble than good
02:02:54 <Maior> what's the simplest typeclass, for demonstration purposes? is there an "Identity"?
02:03:14 <Maior> ah Eq will do, sorry
02:03:46 <merijn> Identity typeclass would be silly, as you can implement identity with just polymorphism :)
02:03:56 <jle`> Show is a pretty simple one too
02:04:06 <jle`> it only has one function :)
02:04:08 <b_jonas_> merijn: the Identity monad typeclass isn't silly
02:04:12 <b_jonas_> oh wait
02:04:15 <b_jonas_> typeclass
02:04:15 <b_jonas_> um
02:04:17 <b_jonas_> ignore that then
02:04:20 <jle`> haha
02:04:23 <merijn> Simplest typeclass would be "class Foo" <- no functions and no parameters :)
02:04:49 <merijn> Probably not a very good example, though. And would also require a GHC extension :p
02:04:52 <b_jonas_> merijn: how many member definitions?
02:05:05 <b_jonas> I mean instance
02:05:06 <jle`> you can use it to restrict what types can be used in your functions?
02:05:07 <b_jonas> um
02:05:11 <jle`> but then you wouldn't be able to ever do anything with it
02:05:14 <merijn> b_jonas_: Logically it could only have one, I haven't tried, though
02:05:15 <jle`> because you wouldn't know anything about it
02:05:22 <merijn> jle`: correct
02:05:36 <merijn> jle`: Well, it can't even restrict what types are used, it has no arguments
02:05:42 <b_jonas> wouldn't you have to write it as class Foo where {} though?
02:05:45 <jle`> well
02:05:48 <jle`> you can, right?
02:05:53 <b_jonas> wait...
02:05:58 <b_jonas> it's a nullary typeclass?
02:05:59 <b_jonas> wtf
02:06:00 <jle`> only types with a defined instance can be used
02:06:06 <merijn> b_jonas: Yes, GHC supports those :)
02:06:11 <b_jonas> nice
02:06:12 <jle`> so you'd have to write out an instance for every type allowed
02:06:40 <merijn> jle`: If you wanna restrict which types are allowed for a function, check out this neat example I came up with: https://gist.github.com/merijn/6130082
02:06:43 <b_jonas> @define class Foo where {}
02:06:44 <lambdabot>  .L.hs:147:1:
02:06:44 <jle`> if only you could not export "instancing"
02:06:44 <lambdabot>      No parameters for class `Foo'
02:06:44 <lambdabot>      In the class declaration for `Foo'
02:06:56 <merijn> b_jonas: It requires an extension
02:07:07 <jle`> merijn: that's neat :)
02:07:16 <b_jonas> merijn: but doesn't lambdabot has most of the crazy extensions turned on by default?
02:07:28 <kadoban> looking through the typeclasses i can find...Bounded is super simple, haha. that's the simplest i can find so far
02:07:28 <supki_> an extension and GHC 7.8
02:07:33 <merijn> b_jonas: Most, but not all
02:07:38 <jle`> i think Show might be the simplest typeclass
02:07:46 <b_jonas> @define class (Foo x y) where { f :: x -> y -> Bool;  }
02:07:47 <lambdabot>  Defined.
02:07:48 <merijn> Show, Bounded and Eq are all about equally simple, IMO
02:07:54 <b_jonas> jle`: I don't think show is
02:08:01 <jle`> yes but show only has one method
02:08:02 <b_jonas> it should be, but it has some crazy magic for strings doesn't it?
02:08:06 <b_jonas> no
02:08:07 <b_jonas> um
02:08:19 <b_jonas> @source Show
02:08:19 <lambdabot> Unknown command, try @list
02:08:25 <b_jonas> @src Show
02:08:25 <tikhon> yeah, it has special handling for lists
02:08:25 <lambdabot> class  Show a  where
02:08:25 <lambdabot>     showsPrec :: Int -> a -> ShowS
02:08:25 <lambdabot>     show      :: a   -> String
02:08:25 <lambdabot>     showList  :: [a] -> ShowS
02:08:28 <jle`> it does kind of 'break' parametricity in a way that Eq and Bounded do not
02:08:30 <jle`> oh darn
02:08:32 <jle`> that sucks
02:08:47 <b_jonas> @src Bounded
02:08:47 <lambdabot> class  Bounded a  where
02:08:47 <lambdabot>     minBound, maxBound :: a
02:08:53 <b_jonas> how about Ord?
02:08:57 <merijn> jle`: The only real downside of that example is that it breaks in the presence of overloaded literals, i.e. "foo 1" since "1 :: Num a => a" it can't decide whether 'a' is () or Int and thus complains
02:08:57 <b_jonas> @src Ord
02:08:57 <lambdabot> class  (Eq a) => Ord a  where
02:08:57 <lambdabot>     compare      :: a -> a -> Ordering
02:08:57 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
02:08:57 <lambdabot>     max, min         :: a -> a -> a
02:08:58 <jle`> i used to think that the strings stuff was magically handled by the compiler
02:09:03 <tikhon> Eq is probably easy to understand
02:09:05 <b_jonas> hmm no, not Ord
02:09:16 <jle`> Eq is probably the mbest demonstration typeclass
02:09:20 <jle`> Num is nice too
02:09:23 <jle`> if they have ever used Ocaml
02:09:26 <b_jonas> @src Eq
02:09:26 <lambdabot> class  Eq a  where
02:09:26 <lambdabot>     (==), (/=)   :: a -> a -> Bool
02:09:30 <jle`> they can appreciate not having to use .+
02:09:31 <tikhon> except maybe for the way it has both (==) and (/=)
02:09:31 <kadoban> yeah, Eq is a nice demo, it actually does something without having any magic going on
02:09:33 <b_jonas> @src Num
02:09:33 <lambdabot> class  (Eq a, Show a) => Num a  where
02:09:33 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:09:33 <lambdabot>     negate, abs, signum     :: a -> a
02:09:33 <lambdabot>     fromInteger             :: Integer -> a
02:09:33 <jle`> and having an overloaded (+)
02:09:52 <jle`> the only thing is fromInteger breaks the cleanness of it slightly
02:09:55 <tikhon> except Num is fat and pretty ugly
02:09:58 <b_jonas> does this actually show the full source? or are there some members omitted below these?
02:10:04 <nicoo> jle`: It is (+.) :þ (But yes, typeclasses is the thing I miss while using OCaml)
02:10:05 <merijn> b_jonas: No
02:10:12 <jle`> nicoo: haha thanks
02:10:14 <merijn> b_jonas: @src is filled with lies and misinformation
02:10:27 <merijn> b_jonas: It just looks up strings in a table on lambdabot's machine
02:10:34 <b_jonas> jle`: what? no way, fromInteger SHOULD be there because it's a real operation in a unitary ring. if anything, it's signum that makes it ugly
02:10:38 <tikhon> @src is just a hand-compiled database, isn't it?
02:10:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:10:42 <merijn> b_jonas: If you want to see the source click the relevant source links on hackage
02:11:09 <nicoo> tikhon: I don't believe so
02:11:14 <nicoo> @src Typeable
02:11:14 <lambdabot> Source not found. Whoa.
02:11:20 <nicoo> @src length
02:11:20 <lambdabot> Source not found.
02:11:22 <merijn> b_jonas: for example, while the Haskell report defines Eq and Show is superclass for Num GHC doesn't
02:11:31 <b_jonas> and abs too
02:11:37 <merijn> nicoo: It is just a hand-compiled database
02:11:41 <tikhon> @src foldr
02:11:41 <lambdabot> foldr f z []     = z
02:11:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:11:49 <nicoo> merijn: Ah, damn
02:11:51 <tikhon> which isnt' the actual implementation used in GHC, I believe
02:12:07 <merijn> That's not the source of foldr, for example
02:12:13 <merijn> Compare: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#foldr
02:12:16 <tikhon> exactly
02:12:34 <tikhon> foldr k z = go
02:12:34 <tikhon>           where
02:12:35 <tikhon>             go []     = z
02:12:38 <tikhon>             go (y:ys) = y `k` go ys
02:13:04 <tikhon> so yeah: @src is dubious at best
02:14:03 <b_jonas> @src Foldable
02:14:03 <lambdabot> Source not found.
02:14:24 <b_jonas> no wait, that has too many methods
02:14:45 <tikhon> I think using Eq and then Ord as examples for typeclasses is good
02:14:58 <tikhon> they show off a bunch of the features like default definitions
02:15:08 <tikhon> and having one class require another
02:15:13 <merijn> It depends on the goal
02:15:14 <tikhon> but are still pretty simple
02:15:27 <tikhon> well, yes
02:15:46 <tikhon> honestly, I'm not a big fan of Foldable in general
02:19:49 <b_jonas> let's use Typeable as the example! it only has one method I think
02:19:55 <b_jonas> :)
02:23:10 <quicksilver> there are three stages of Foldable elightenment.
02:23:56 <b_jonas> quicksilver: is one stage where you realize that Traversable describes types that can be converted to a list, only it is defined in a more complicated way to hide that?
02:24:14 <b_jonas> hmm, let me check the typeclassopedia
02:24:18 <quicksilver> (1) hey this is a really cool type class, it abstracts maps into monoids (2) oh no, it's a really dull typeclass, it's really just toList, it's things you can turn into lists (3) hey, lists are the free monoid over a set of generators, that's why it works, so actually that's really quite interesting.
02:24:44 <tikhon> eh, my path was a bit different
02:24:50 <b_jonas> quicksilver: "maps"?
02:24:54 <quicksilver> b_jonas: well yes, but that's Foldable not Traversable you are describing.
02:24:58 <quicksilver> @type foldMap
02:24:59 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:25:04 <quicksilver> b_jonas: ^^ that
02:25:08 <tikhon> I learned about catamorphisms before I learned about Foldable
02:25:41 <b_jonas> ah, I see
02:25:42 <tikhon> so I came to Foldable with pretty high expectations
02:57:14 <aegis__> hello :) quick question: why doesn't "f x = (f 3, f True)" typecheck in Haskell?
02:57:27 <aegis__> "f x = (x 3, x True)" sorry
02:58:04 <kosmikus> aegis__: a lambda-bound variable can only be monomorphic, unless it has an explicit type signature
02:58:43 <kosmikus> aegis__: if you enable the RankNTypes language extension and give f an explicit type signature, such as "f :: (forall a. a -> a) -> (Int, Bool)", then it checks
02:59:13 <aegis__> kosmikus: so the type inference mechanism will complain except if I provide an explicit signature for f: "f :: (t -> u) -> (u, u)" ?
02:59:25 <aegis__> kosmikus: makes sense; thanks!
02:59:32 <kosmikus> aegis__: your type signature won't work
03:00:10 <kosmikus> aegis__: you need a rank-2 type. the argument itself has to be a polymorphic function.
03:00:20 <tikhon> aegis__: the best way to think about it is that the *caller* chooses what u is
03:00:23 <kosmikus> aegis__: type inference in Haskell won't ever infer a rank-2 type.
03:00:33 <tikhon> and
03:00:34 <tikhon> 5
03:00:35 <tikhon> t
03:00:50 <tikhon> what type for t will let your tuple work properly?
03:01:13 <tikhon> (t -> u) would somehow have to be both Integer -> u and Bool -> u
03:01:35 <aegis__> tikhon: yep so any type for t since only u matters for the tuple type
03:01:51 <tikhon> the trick is that t is determined when f is used
03:02:01 <aegis__> kosmikus: is the hindley-milner algorithm capable of inferring such types?
03:02:04 <tikhon> and there's no consistent type to replace for t to make your function used
03:02:12 <kosmikus> aegis__: no.
03:02:13 <tikhon> aegis__: Hindley-Milner isn't
03:02:23 <kosmikus> aegis__: there are other inference algorithms that are, to a certain extent.
03:02:28 <tikhon> I believe inference for Rank-2 types is decidable
03:02:28 <kosmikus> aegis__: but GHC doesn't use them.
03:02:52 <merijn> tikhon: Pretty sure Rank2 and up is undecidable, hence why GHC inference breaks
03:02:58 <merijn> tikhon: Not 100% sure, though
03:03:00 <tikhon> no, I think RankN is undecidable
03:03:03 <tikhon> but Rank2 isn't
03:03:06 <kosmikus> rank 2 is decidable
03:03:08 <kosmikus> but complicated
03:03:15 <kosmikus> I completely understand why GHC doesn't implement it
03:03:21 <aegis__> tikhon: ok I think I am a bit confused with the difference between and Rank 1 and Rank 2 types; I'll read up the documentation on haskell.org
03:03:46 <tikhon> hmm
03:04:02 <tikhon> you might actually be better off reading about the theory instead: find some slides about System F
03:04:25 <tikhon> at the very least, I found that learning about polymorphism in System F made RankN types much easier to understand
03:04:27 <kosmikus> aegis__: a polymorphic function can be used at different types. that's rank-1 polymorphism.
03:04:44 <kosmikus> aegis__: you want more. you want to use the *argument* of a function at different types. that's rank-2 polymorphism.
03:05:19 <aegis__> kosmikus: yep. so my signature is equivalent to forall t, u. (t -> u) -> (u, u) (rank 1)
03:05:43 <kosmikus> aegis__: that's the signature you continue to give, but your function simply doesn't have that type.
03:06:26 <aegis__> and what you are suggesting with rankN types enabled is forall u. (forall t. (t -> u)) -> (u, u)
03:06:26 <kosmikus> given your type, I'd be allowed to call the function with (+1) as an argument and expect a pair of two integers back.
03:06:26 <aegis__> ?
03:06:52 <kosmikus> yes
03:07:02 <tikhon> try it in GHCi
03:07:18 <tikhon> you can turn an extension on with :set -XRankNTypes
03:07:26 <tikhon> which took me a while to figure out :/
03:07:33 <kosmikus> :)
03:07:54 <kosmikus> hitting TAB after typing :set -X is quite impressive
03:07:57 <tikhon> oh yeah, you can also use ; in lets to add a type signature to a function
03:08:03 <tikhon> let f :: forall u. (forall t. t -> u) -> (u, u); f x = (x 3, x True)
03:08:08 <tikhon> that also took me a while to learn
03:08:32 <tikhon> I probably should have read :help or the documentation more closely, in hindsight
03:10:16 <kosmikus> the type "f :: forall u. (forall t. t -> u) -> (u, u)" is valid, but not very useful. all you can apply the function to is a constant function.
03:10:37 <aegis__> kosmikus: sorry if I am a bit slow on this but to make sure: without rankN types, if I pass a polymorphic function as argument, the lambda-bound variable is forced to be monomorphic, so the hindley-milner alg will attempt to find a monomorphic form of it but will wail since I have x 3 and x True
03:10:48 <tikhon> yes
03:13:44 <aegis__> that was enlightening, thanks!
03:15:50 <quicksilver> kosmikus: isn't that just (t->u) -> (u,u) ?
03:16:15 <quicksilver> on the left of two -> means that forall is in a positive position
03:16:48 <tikhon> quicksilver: do you mean forall u. (forall t. t -> u) -> (u, u)?
03:17:05 <quicksilver> tikhon: that is that type I was referring to, yes.
03:17:20 <kosmikus> quicksilver: even if it's in a positive position, it doesn't mean you can move it out
03:17:42 <quicksilver> forall u. (forall t. t -> u) -> (u, u) is the same as forall t u. (t -> u) -> (u, u) is normally written (t -> u) -> (u,u)
03:17:46 <quicksilver> kosmikus: yes it does.
03:17:51 <quicksilver> kosmikus: normal form for quantifiers.
03:17:52 <aegis__> tikhon: do you have a good article / paper about why rank 2 types are undecidable / complicated to decide?
03:18:01 <quicksilver> "prenex normal form"
03:18:31 <quicksilver> @djinn (t->u) -> (u,u)
03:18:31 <lambdabot> -- f cannot be realized.
03:18:34 <tikhon> aegis__: hmm, not really, I just remember covering it in a class or maybe reading it somewhere random
03:19:07 <kosmikus> > let f :: forall u t. (t -> u) -> (u, u); f x = undefined in f id
03:19:08 <lambdabot>  *Exception: Prelude.undefined
03:19:20 <kosmikus> > let f :: forall u. (forall t. t -> u) -> (u, u); f x = undefined in f id
03:19:21 <lambdabot>  Couldn't match type `u' with `t'
03:19:22 <lambdabot>    `u' is a rigid type variable bound by
03:19:22 <lambdabot>        the inferred type of it :: (u, u) at Top level
03:19:22 <lambdabot>    `t' is a rigid type variable bound by
03:19:22 <lambdabot>        a type expected by the context: t -> u at <interactive>:1:69
03:19:39 <kosmikus> quicksilver: I'd like to see a reference for that equivalence.
03:20:11 <tikhon> Yeah, I'm pretty sure they're different
03:20:50 <spookyfo_> j /#sublimetext
03:22:33 <quicksilver> kosmikus: you can justify it with the game theory interpretation. Either the caller or the callee choose the type of 't'. There are only two options. foralls in negative positions quantify types chosen by the callee, types quantified by foralls in positive positions are chosen by the caller
03:23:16 <aegis__> quicksilver: silly question but what's positive and negative position?
03:23:35 <tikhon> I think maybe you didn't calculuate the positive/negative position properly
03:23:41 <kosmikus> quicksilver: aren't you assuming a classic setting here?
03:24:24 <quicksilver> kosmikus: I don't think so. I must admit I'm feeling slightly uncertain.
03:24:32 <tikhon> because under your interpretation, forall u t. (t -> u) -> (u, u) lets the caller choose t whereas forall u. (forall t. t -> u) -> (u, u) forces the caller to pass in a function polymorphic over t
03:24:54 <tikhon> you can demonstrate they're not the same type signature because a function typechecks with the latter but not the former
03:25:10 <tikhon> compare
03:25:12 <tikhon> let f :: forall u. (forall t. t -> u) -> (u, u); f x = (x 3, x True)
03:25:15 <tikhon> let f :: forall u t. (t -> u) -> (u, u); f x = (x 3, x True)
03:25:20 <tikhon> hmm
03:25:23 <tikhon> > let f :: forall u. (forall t. t -> u) -> (u, u); f x = (x 3, x True)
03:25:24 <lambdabot>  not an expression: `let f :: forall u. (forall t. t -> u) -> (u, u); f x = (...
03:25:28 <kosmikus> quicksilver: I think that in intuitionistic logic, it's simply not true that you always have prenex normal form.
03:25:29 <quicksilver> kosmikus: I know that prenex normal form is not valid for intuitionistic logic but I think the notion of alernating quantifiers like this is.
03:25:37 <quicksilver> but tikhon is right :)
03:25:49 <quicksilver> I did calculate the positions wrong.
03:26:00 <quicksilver> it would have to be ((forall t. t) -> u) -> (u,u)
03:26:04 <quicksilver> to be in a positive position.
03:26:27 <quicksilver> it's the positivity of the forall, not the positivity of the t, that matters.
03:27:34 <kosmikus> ok, yes. I see that. I'm still not convinced that your other proposition holds, though.
03:27:57 <tikhon> kosmikus: which proposition?
03:28:00 <kosmikus> so you're now claiming that ((forall t. t) -> u) -> (u,u) in Haskell is the same as (t -> u) -> (u,u) ?
03:28:03 <tikhon> I've officially become confused about antecedents
03:28:21 <quicksilver> kosmikus: yes, that is my revised claim
03:28:27 <kosmikus> that doesn't seem true either
03:28:59 <quicksilver> well they have the same denotation :)
03:29:07 <quicksilver> I agree that doesn't make for a useful general principle.
03:29:14 <kosmikus> denotation in what?
03:29:17 <quicksilver> (they're both uninhabited types)
03:29:41 <kosmikus> ok, yes, sorry
03:29:45 <kosmikus> I was confused
03:30:17 <kosmikus> ok, perhaps you're right and quantifier-lifting works even in an intuitionistic setting
03:30:22 <kosmikus> I have to think about this
03:31:07 <kosmikus> I would have assumed that lifting a quantifier by two levels gives you a double negation somewhere
03:32:11 <kosmikus> aegis__: sorry for all this. it has little to do with your original question. please don't be scared :)
03:32:23 <tikhon> even though it is at least a little bit scary :P
03:32:39 <aegis__> kosmikus: I get scared every time I spend more than 10min on this channel ^_^
03:32:43 <tikhon> this comes up very rarely in normal programming
03:32:59 <kosmikus> aegis__: heh. yes, #haskell can be like that.
03:33:08 <kosmikus> I'm not usually the worst offender though.
03:33:10 <kosmikus> :)
03:33:22 <tikhon> hmm
03:34:22 <aegis__> kosmikus: I feel most of the people here have extensive background in type theory etc so sometimes it's a bit hard to follow form a freshman like me
03:34:33 <aegis__> for*
03:34:34 <tikhon> things get a bit clearer if we just ditch the u variable which is confusing things
03:35:00 <tikhon> to me, things go a bit clearer when I compared forall t. t -> Int vs (forall t. t) -> Int
03:35:01 <aegis__> tikhon: yeah if you had (forall. t) -> Int -> (Int, Int)
03:35:34 <kosmikus> aegis__: a few people do, but certainly not all. and while there's certainly a correlation between people interested in Haskell and people interested in type theory, it doesn't mean that you have to know type theory in order to enjoy Haskell :)
03:35:46 <tikhon> if you're a freshman, you still have plenty of chances to take a fun type theory course ;)
03:36:26 <tikhon> at my school, it was partly fun because relatively few people ever bother taking it so it was a relatively small class
03:36:33 <aegis__> kosmikus: fair enough but it seems to be where the fun lies :p
03:36:42 <tikhon> oh yeah, lots of fun
03:36:54 <kosmikus> aegis__: ah well, if you think that, then just learn it, and don't be scared :)
03:37:54 <aegis__> kosmikus: that's actually how I stumbled upon my question. I'm trying to implement hindley-milner for a toy language and it couldn't infer the type of f x = (x 3, x True) so I tried it in ghc to check if I messed up
03:38:03 <tikhon> ah
03:38:51 <tikhon> that's a fun exercise
03:38:52 <kosmikus> aegis__: I see. ok, good news for you then: you didn't :)
03:38:55 <aegis__> tikhon: and yep I'll definitely do that next year. Speaking about type theory, would you advice Agda or Idris for an introduction to dependent types?
03:38:57 <aegis__> or else?
03:39:06 <kosmikus> aegis__: both are fine
03:39:13 <tikhon> you could just extend your toy language with dependent types
03:39:14 <tikhon> it's simply easy
03:39:18 <kosmikus> :)
03:39:24 <tikhon> http://strictlypositive.org/Easy.pdf
03:39:33 <tikhon> see, it even has "Easy" in the URL!
03:39:42 <aegis__> tikhon: "easy" like most of the discussions happening here or easy at a "normal" level?
03:39:46 <tikhon> umm
03:39:59 <tikhon> "Simply Easy!" is the title of the paper
03:40:06 <tikhon> I actually found it really confusing at first
03:40:12 <tikhon> then, later, it all made sense
03:40:22 <aegis__> oh actually Conor McBride was giving a serie of lectures here last month
03:40:25 <aegis__> fun guy
03:40:35 <kosmikus> tikhon: it's actually an older version of http://www.kosmikus.org/LambdaPi/
03:40:37 <aegis__> but yeah, I don't trust Nordic people saying "easy"
03:40:39 <tikhon> part of the problem is that the notation people use for dependently typed λ-calculis is horrible
03:41:04 <tikhon> I tried teaching a bunch of people about dependent types a little while back
03:41:10 <kosmikus> and I think the more recent version is to be somewhat preferred, even though it doesn't have the funny title
03:41:13 <tikhon> and they all got really confused by the notation for dependent function spaces
03:41:16 <kosmikus> I think the journal didn't like it
03:41:24 <tikhon> euh
03:41:29 <aegis__> tikhon: yep I tried some agda before and I feel you quickly run into a theory wall if you don't understand lambda calculus and category theory
03:41:41 <aegis__> I'll take a look at that paper though
03:42:13 * hackagebot idempotent 0.1.1 - Idempotent monoids  http://hackage.haskell.org/package/idempotent-0.1.1 (alynn)
03:42:20 <tikhon> yeah, the review process in general seems a bit hit or miss
03:42:41 <tikhon> I don't have much first-hand experience, but I've heard people talking about how they reviewed submissions
03:42:54 <kosmikus> tikhon: or perhaps it was the conference reviewers who didn't like it. but I know that we relucatantly changed the title at some point.
03:43:18 <tikhon> I like the title
03:43:21 <tikhon> memorable
03:43:39 <tikhon> I'm not a big fan of the normal descriptive but overly-long titles papers have
03:43:46 <tikhon> although it's not as bad as laws!
03:43:54 <kosmikus> right. some people like everything to be boring.
03:44:09 <prophile> laws usually have short catchy names
03:44:13 <tikhon> no
03:44:14 <tikhon> not officially
03:44:15 <prophile> "associativity"
03:44:16 <prophile> that sort of thing
03:44:19 <kosmikus> fortunately, if you're working with Conor, that's not ever going to happen.
03:44:28 <tikhon> hah, I meant legal laws :P
03:45:34 <tikhon> normal style titles are pretty bad for conversation too
03:45:55 <kosmikus> aegis__: so both Idris and Agda are good intro languages for dependent types if you're coming from Haskell. Agda is a bit older, has more libraries written for it. Idris, OTOH, is more focused on actual compilation.
03:46:14 <tikhon> Coq seems like a pretty good place to start too
03:46:17 <kosmikus> aegis__: so if you just want a type checker to play with, Agda is great. if you also want to execute your programs, Idris is, in my experience, better.
03:46:39 <kosmikus> tikhon: yes, but the syntax is a bit more alien if your main language background is Haskell, not OCaml.
03:46:47 <tikhon> oh, I guess so
03:47:06 <tikhon> I've used a fair bit of OCaml, so it didn't affect me
03:47:43 <tikhon> I haven't actually used Agda, but it does seem prettier
03:47:52 <tikhon> I am also a big fan of Unicode
03:49:35 <tikhon> aegis__: coincidentally, it's good to see freshman interested in functional programming
03:49:42 <tikhon> I had only started reading about Haskell then
03:49:55 <aegis__> kosmikus: thanks for the tip
03:51:07 <aegis__> tikhon: well to be honest I didn't start haskell very long ago but I find the whole business of programming language theory very exciting :-)
03:51:19 <aegis__> tikhon: just out of curiosity, are you a postgrad or..?
03:51:23 <tikhon> nah
03:51:32 <tikhon> undergrad
03:51:42 <tikhon> well, sort of: I'm taking a break from school right now
03:51:44 <aegis__> oh ok
03:53:25 <CaptainK> isn't the whole school thing pointless in todays technology, learn it yourself, save tons of money...profit!
03:53:30 <tikhon> eh
03:53:34 <tikhon> it's fun
03:53:41 <tikhon> and you get access to pretty cool research
03:53:44 <tikhon> which is trickier normally
03:53:51 <CaptainK> ah good point
03:54:21 <tikhon> for me, doing some undergraduate research has probably been the most valuable thing from school
03:54:39 <aegis__> tikhon: what kind of research?
03:54:48 <CaptainK> seen and what value?
03:54:57 <tikhon> some stuff with program synthesis and superoptimization
03:55:09 <tikhon> basically optimizing low-level code by searching through all possible programs
03:55:14 <tikhon> not very heavy on theory :)
03:55:24 <tikhon> my school really doesn't do much PL theory stuff, unfortunately
03:55:48 <aegis__> it seems very interesting though
03:56:07 <tikhon> in practice, it's much less elegant
03:56:26 <tikhon> still fun though
03:56:33 <aegis__> the name is fancy :p
03:57:07 <tikhon> funny, my first reaction to hearing "superoptimization" was that it was too markety
03:57:15 * hackagebot wai-routes 0.4.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.4.1 (AnupamJain)
03:58:05 <tikhon> and it has exposed me to some programming language designs I would never have seen otherwise
03:58:20 <tikhon> my project involves working with a version of Forth where *color* is part of the syntax
03:58:29 <tikhon> color!
03:58:32 <aegis__> wut
03:58:35 <tikhon> exactly
03:58:53 <tikhon> they also don't store programs as text files
03:58:55 <aegis__> why not font family and size?
03:59:00 <aegis__> so people can edit code in Word
03:59:14 <tikhon> instead they have their own custom encoding that's compressed by default
03:59:32 <tikhon> it's a version of http://www.colorforth.com/cf.htm
04:00:05 <tikhon> then again, there was a POPL paper recently that used color too
04:00:42 <cizra> Hi. I'm sort of confused about cabal install, it tends to print rather weird messages to me -- why, for example, is installing a package likely to break GHC? http://lpaste.net/100501
04:01:20 <aegis__> tikhon: I had no idea such things existed
04:02:12 <tikhon> ah, never mind, it was ICFP: http://www.cse.chalmers.se/~bernardy/CCCC.pdf
04:02:32 <supki_> cizra: it's ghc api package, not ghc itself
04:02:41 <supki_> it kinda confusingly named
04:02:42 <cizra> supki_: OK, what do I need to do to install the package?
04:02:49 <cizra> (filesystem)
04:03:49 <supki_> your log still looks bad, you shouldn't reinstall bytestring, unix, and directory
04:04:43 <supki_> cizra: where did you find that package?
04:06:14 <supki_> oh, wait
04:07:47 <kosmikus> cizra: the FileSystem package depends on both bytestring-0.9 and binary-0.5, which is an unfortunately combination for ghc-7.6.3
04:07:53 <kosmikus> *unfortunate
04:09:08 <kosmikus> cizra: I'd try to install it into a sandbox. You can make the solution found by Cabal slightly better by adding --constraint="unix installed"
04:09:13 <cizra> OK, let's approach this problem from the other side. I want basic FS operations like moveFile, also readFile :: FileName -> IO ByteString. What do I need to install?
04:11:07 <kosmikus> cizra: if you have the Haskell Platform, then you already have the necessary packages to do basic file system operations
04:11:17 <kosmikus> cizra: System.Directory.renameFile, for example
04:11:55 <cizra> Ah, cool. Thanks for the pointer.
04:12:17 * hackagebot type-natural 0.2.0.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.0.0 (HiromiIshii)
04:12:21 <kosmikus> cizra: and Data.ByteString.readFile
04:12:36 <kosmikus> cizra: (if reading it as a ByteString is what you want)
04:12:44 <cizra> yessir
04:13:32 <cizra> Thanks a lot!
04:17:27 <tikhon> aegis__: oh hey, you've proably already seen this, but if you haven't it might be interesting: http://web.cecs.pdx.edu/~mpj/thih/
04:17:55 <quicksilver> kosmikus: well, I asked it on SO, lets see if the type-theory mafia pick it up :)
04:18:03 <quicksilver> my first ever SO question actually.
04:19:47 <aegis__> tikhon: actually I didn't. Thanks!
04:20:40 <Saizan_> quicksilver: link?:O
04:20:56 <tikhon> http://stackoverflow.com/questions/22094962/is-it-valid-to-lift-positive-positive-forall-quantifiers-to-the-outside
04:21:11 <quicksilver> Saizan_: tikhon has it :)
04:21:39 <kosmikus> quicksilver: ok :)
04:22:08 <aegis__> quicksilver: I asked it earlier but I am not sure if you answered: what's "positive" when talking about a forall?
04:23:12 <quicksilver> aegis__: positive means "to the left of an even number of arrows"
04:23:23 <quicksilver> including 0.
04:23:56 <quicksilver> N -> N -> N -> P
04:24:11 <aegis__> quicksilver: ok I should go back do some reading on category theory then ;P didn't get into arrows yet
04:24:13 <quicksilver> (((N->P)->N)->P)
04:24:23 <quicksilver> aegis__: I just mean the literal symbol '->' in a haskell type
04:24:28 <aegis__> oh ok
04:25:03 <quicksilver> all the positive positions are covariant, all the negative positions are contravariant
04:25:16 <quicksilver> I bet there is a less jargony way to explain :(
04:25:21 <quicksilver> but I can't think of it.
04:25:57 <aegis__> I get covariant/contravariant so that makes sense :p
04:26:10 <aegis__> negative position is on the right of an arrow then?
04:27:55 <quicksilver> aegis__: negative position is to the left of an odd number of arrows
04:27:59 <quicksilver> aegis__: (including one)
04:28:14 <quicksilver> aegis__: so, (a -> b) is covariant in b and contravariant in a
04:28:22 <quicksilver> aegis__: so, a is in the negative position.
04:30:45 <aegis__> quicksilver: ok
04:31:10 <merijn> quicksilver: I like the mental image of a type theory mafia :)
04:31:31 <merijn> "Nice free theorem you have there...would be a shame if something happened to it..."
04:32:04 <quicksilver> merijn++
04:42:21 * hackagebot sized-vector 1.3.1.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.3.1.0 (HiromiIshii)
04:47:21 * hackagebot sized-vector 1.3.1.1 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.3.1.1 (HiromiIshii)
04:47:23 * hackagebot largeword 1.1.1 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.1.1 (DominicSteinitz)
05:02:29 <Eduard_Munteanu> Is Safe Haskell considered safe for running random pure code these days? Also, is there any integration with Cabal?
05:03:10 <Eduard_Munteanu> I'm unsure how I'd go about installing a safe-inferred package safely.
05:34:26 <EcoGiko> Hello!
05:34:52 <Axman6> 'lo
05:51:30 <greg`> is takusen haskells answer to clojures datomic?
05:57:30 * hackagebot hscrtmpl 1.2 - Haskell shell script template  http://hackage.haskell.org/package/hscrtmpl-1.2 (DinoMorelli)
06:13:39 <pxqr>  integerDec in bytestring-0.10.2.0:Data.ByteString.Builder exists: <http://hackage.haskell.org/package/bytestring-0.10.2.0/docs/Data-ByteString-Builder.html#v:integerDec>, hoverwer ghc is complaining it is not in scope
06:13:46 <pxqr> why this can happen?
06:14:17 <pxqr> i have bytestring == 0.10.2.0 set in cabal and have Data.ByteString.Builder imported
06:15:13 <pxqr> problem disappear with 0.10.0.2 version of bytestring
06:17:35 <fragamus> @pl (\x->(foo x,bar x))
06:17:35 <lambdabot> liftM2 (,) foo bar
06:19:06 * benj_ slaps lambdabot for using an unnecessary monad constraint when applicative would do
06:20:10 <Maerten> Hi, anyone here using Persistent? I come from using PHP with the Doctrine2 ORM. After retrieving an entity from the DB, i can update a field and then call a persist and flush method on an 'entityManager'. How does this work in Persist? I have a list of entities, want to update a field in all of them, and want to write the updates back ot the DB in one big transaction (that might contain some other INSERT or UPDATE's too). Is this possi
06:20:10 <Maerten> As I'm new to haskell it takes me hours to even understand the docs.. :|
06:22:22 <zomg> Maerten: I have a similar background so I know exactly what you're talking about :)
06:22:41 <zomg> basically you just give persistent a new "record" to update into the DB
06:23:28 <zomg> Maerten: have you looked at the docs here? http://www.yesodweb.com/book/persistent#persistent_update
06:23:48 <simon> Maerten, your message got chopped at "Is this possi"
06:24:36 <adas> is there a way to search for function only in a certain package with hoogle inside ghci?
06:24:40 <Maerten> Is this possible? As I'm new to haskell it takes me hours to even understand the docs.. :|
06:25:04 <adas> i tried :hoogle +Prelude map , but that gives me irrelevant results
06:25:09 <Maerten> zomg: yes i saw these docs, and the part about "When we say update, we’re not talking about modifications to the values in Haskell. " got me to ask a question here
06:25:43 <zomg> yeah 'cause haskell values are immutable
06:26:13 <zomg> so basically if you query a Person from the DB similar to in the examples, you create a new Person record let person2 = myPerson { name = "new name" }
06:26:30 <zomg> then you could for example do `replace myPersonId person2` to replace the old row with the new row
06:26:47 <adas> restricting output of hoogle ?
06:26:55 <zomg> (assuming myPerson and myPersonId were the results you got from querying the DB)
06:28:23 <Maerten> zomg: ah that sounds good. so i could do the same, but with a big list of entities? so i have to keep track of the old and the new records myself and call 'replace entityId newEntityValue' on all of them?
06:29:04 <zomg> Yeah or you could use the update function to modify the rows instead of having to create new records for using replace
06:31:17 <Maerten> zomg: hm. well what i'm trying to do is, i have a lot of rows with events (lets say clicks on a button), and i want to summarize them by date for a daily report. then i want to write the reports to the DB in a single transaction, together with all the original rows with events, but updating a few fields like: update_date = now(), reportId = [id of the generated report]
06:32:17 <zomg> it sounds like it might be simplest to map through the list of records to generate a list of (rowId, reportId)
06:32:59 <zomg> then you could use forM to go through the list and run `update` with the parameters needed
06:34:26 <Maerten> zomg: alright i will try something along those lines, thanks a lot!
06:35:38 <Maerten> zomg: how long have you been using php / haskell? is there any kind of project for which you'd still use php?
06:37:15 <zomg> did php for like I dunno 10+ years :P Started using haskell on and off for random hobby projects a few years back
06:37:35 * hackagebot linux-cgroup 0.1.1.1 - Very basic interface to the Linux CGroup Virtual Filesystem  http://hackage.haskell.org/package/linux-cgroup-0.1.1.1 (clord)
06:37:37 * hackagebot bytestring-from 0.2 - A type-class to convert values from ByteString.  http://hackage.haskell.org/package/bytestring-from-0.2 (ToralfWittner)
06:37:37 <zomg> php certainly does the job for web dev I think, but haskell is more interesting =)
06:37:55 <zomg> for the record I get paid to do node.js web dev stuff currently
06:38:06 <Hafydd> For some value of "does the job".
06:38:28 <zomg> well love it or hate it it's pretty easy to do most web-things with it
06:38:46 <Hafydd> It's not easy to use PHP if you hate it.
06:39:07 <zomg> yeah I guess it might be hard if your eyes get bloodshot from rage or something
06:40:39 <quicksilver> Hafydd: paradoxically, if you do use PHP it's not easy not to hate it.
06:40:39 <greg`> because haskell rocks
06:41:32 <utkarsh> I've got `data Expr = Eq Expr Expr | Not Expr | B Bool`. How can I make this lambda shorter? `\x y -> Not (Eq x y)`
06:42:05 <Hafydd> @pl \x y -> Not (Eq x y)
06:42:05 <lambdabot> (Not .) . Eq
06:42:43 <greg`> you know i really really like adit.io great great blog posts for all levels
06:42:43 <greg`> not many of them , waiting for a talk on arrows
06:43:25 <Maerten> yes php has been working fine for me, it was easy to pick up because of how many examples there were online. currently doing web things with php and some javascript/node too. but i am learning haskell because it seems like i can do more with less code. but the learning curve seems pretty steep :D
06:44:32 <zomg> yeah there certainly is an initial curve if coming from non-fp langs
06:44:33 <Hafydd> But once you taste static analysis, I think, it's hard to go back to debugging everything at runtime.
06:44:36 <Maerten> zomg: anyway, thanks again for the help!
06:44:50 <zomg> but I would say it's worth it 'cause after you learn haskell, you'll even write better php code =)
06:45:01 <zomg> (though you probably wouldn't want to because haskell just is better, but...)
06:45:02 <zomg> haha
06:49:50 <jlouis> Hafydd: I went back to debugging everything at runtime.
06:50:03 <jlouis> luckily that transition is as easy as the other way
06:52:33 <Kaidevappy> does haskell-platform have any way to work with sound?
06:57:37 * hackagebot linux-cgroup 0.1.1.2 - Very basic interface to the Linux CGroup Virtual Filesystem  http://hackage.haskell.org/package/linux-cgroup-0.1.1.2 (clord)
07:07:14 <Alexey> Hi! Anyone know how to send EOF character to WinGHCi ?
07:07:39 <Alexey> CTRL-Z not helping
07:08:48 <shiona> Have you tried Ctrl-Z Enter, I have gotten the impression that you need the trailing enter to make it a EOF
07:09:52 <shiona> no idea if it works, but that's my best bet. I don't think I've ever sent eof successfully in windows
07:10:12 <Alexey> No it doesnt work
07:19:11 <haasn> aleator_: Ctrl-D?
07:19:27 <haasn> Err, Alexey already left
07:23:47 <Actreka> According to my mathformula this "floor $ logBase 10 1000 + 1" will show me how many digits there are in 1000, but the output I get from GHCi is 3, how come?
07:24:17 <merijn> > logBase 10 1000
07:24:18 <lambdabot>  2.9999999999999996
07:24:27 <Iceland_jack> Actreka: Wrong grouping
07:24:35 <haasn> > floor (logBase 10 1000) + 1
07:24:36 <lambdabot>  3
07:24:37 <Iceland_jack> > floor (logBase 10 1000) + 1
07:24:38 <lambdabot>  3
07:24:42 <haasn> > floor (logBase 10 1000 :: CReal) + 1
07:24:43 <lambdabot>  4
07:24:45 <Yaniel> > logBase 10 1001
07:24:46 <lambdabot>  3.0004340774793183
07:25:02 <haasn> > floor $ logBase 10 1000 + (1 :: CReal)
07:25:03 <lambdabot>  4
07:25:05 <Iceland_jack> huh
07:25:07 <Actreka> haasn: What is this CReal?
07:25:19 <haasn> Actreka: arbitrary precision computable Real
07:25:28 <haasn> it's slow, but it's more exact than Double
07:25:30 <Actreka> Superb, just what I need
07:25:34 <haasn> as merijn showed, Double gives you 2.9999999999996
07:25:40 <haasn> which gets floor'd to 2
07:25:43 <haasn> instead of the correct value 3
07:25:54 <mm_freak> > sin pi == 0
07:25:55 <lambdabot>  False
07:25:59 <mm_freak> > sin pi == (0 :: CReal)
07:26:00 <lambdabot>  True
07:26:03 <quicksilver> surely the solution to that one is to use round, not floor
07:26:06 <quicksilver> rather than you CReal
07:26:16 <Actreka> quicksilver: What about 101 then
07:26:25 <haasn> It was not my intention to propose CReal as a solution
07:26:32 <haasn> Just to illustrate why it breaks
07:26:36 <quicksilver> actually round won't work
07:26:49 <quicksilver> it will flip up to the next number above 300 or so
07:26:50 <Actreka> haasn: I learnt something so thanks :)
07:27:06 <quicksilver> it will consider 400 to be a 4 digit number
07:27:06 <Actreka> quicksilver: Yea, I tried using round
07:27:12 <quicksilver> since it's over 100*sqrt(10)
07:27:22 <quicksilver> this is just a really bad way to count digits.
07:27:23 <mm_freak> Actreka: to figure out the number of digits you should use an exact integer logarithm, which will be a lot faster than CReal
07:27:28 <mm_freak> Actreka: see the arithmoi package
07:27:32 <quicksilver> > length . show $ "101"
07:27:33 <lambdabot>  5
07:27:38 <quicksilver> doh
07:27:40 <quicksilver> > length . show $ 101
07:27:41 <lambdabot>  3
07:27:42 <quicksilver> :)
07:27:43 <haasn> mm_freak++ nice, did not know that
07:27:53 <haasn> length . show is the cheesiest way to do it ;)
07:27:57 <Actreka> quicksilver: Does that turn it into a list, then count elements?
07:28:00 <haasn> But beware:
07:28:02 <quicksilver> yes.
07:28:07 <mm_freak> haasn: integerLogBase 10
07:28:07 <haasn> > length $ show (-100)
07:28:08 <lambdabot>  4
07:28:14 <mm_freak> besser than length . show
07:28:20 <quicksilver> show for integers incorporates integerLogBase 10 into its algorithm
07:28:20 <mm_freak> particularly because of edge cases
07:28:21 <quicksilver> implicitly.
07:29:05 <mm_freak> http://hackage.haskell.org/package/arithmoi-0.4.0.3/docs/Math-NumberTheory-Logarithms.html
07:29:30 <Actreka> mm_freak: Thanks :)
07:30:03 <mm_freak> Actreka: keep in mind that logarithm is not exactly number of digits
07:30:30 <Actreka> mm_freak: Are you thinking about numbers like 00123?
07:30:38 <mm_freak> no, numbers like 123
07:30:45 <mm_freak> as opposed to numbers like 100
07:31:03 <Actreka> mm_freak: I don't understand what you mean by that
07:31:15 <mm_freak> Actreka: integerLogBase 10 100 = 2
07:31:17 <haasn> λ map (integerLogBase 10) [99,100,123,999,1000]
07:31:18 <mm_freak> Actreka: integerLogBase 10 123 = 2
07:31:19 <haasn> [1,2,2,2,3]
07:31:45 <mm_freak> Actreka: the integer logarithm is the truncated logarithm
07:31:54 <Actreka> mm_freak: Oh! Now I see
07:31:58 <haasn> Are you saying you need to add one?
07:32:06 <mm_freak> haasn: no, that would be wrong
07:32:19 <mm_freak> oh would it?
07:32:20 <Actreka> mm_freak: That would be like flooring the number right? Hence we can just add one
07:32:29 <haasn> mm_freak: how so? Look at the examples
07:32:37 <mm_freak> yeah, + 1 should work
07:32:49 <haasn> note that integerLogBase isn't defined for 0 and negative numbers
07:32:58 <haasn> you might want to special-case 0
07:33:11 <haasn> and perhaps negative numbers (as numDigits (-x))
07:33:47 <mm_freak> well, if speed is not important, you can save a package dependency and the 0 special case by using length . show
07:33:59 <mm_freak> but if speed is important, i would definitely go the integerLogBase route
07:34:31 <mm_freak> if you choose to do the former, just for safety write a separate function that has a rather strict type signature
07:34:38 <mm_freak> numDigits :: Integer -> Int
07:34:50 <haasn> Maybe you could hand-implement it by seeing how often you can `quotRem` it with a non-zero quotient
07:34:51 <Actreka> It seems to work well, do you know if haskell supports complex logarithms?
07:35:01 <mm_freak> Actreka: it does
07:35:04 <haasn> (plus one)
07:35:12 <mm_freak> > log (1 :+ 2)
07:35:13 <lambdabot>  0.8047189562170503 :+ 1.1071487177940904
07:35:28 <mm_freak> Actreka: import Data.Complex and read "a :+ b" as "a + b*i"
07:35:41 <Actreka> Amazing thanks!
07:36:07 <Iceland_jack> or as "a + bj" if you like living in sin :)
07:36:10 <mm_freak> haasn: that's basically integerLogBase, just slower =)
07:36:21 <haasn> > length . takeWhile (>0) . iterate (`quot` 10) $ 123
07:36:22 <lambdabot>  3
07:36:30 <haasn> > length . takeWhile (>0) . iterate (`quot` 10) $ 0
07:36:31 <lambdabot>  0
07:36:33 <haasn> :(
07:36:49 <haasn> > length . takeWhile (/=0) . iterate (`quot` 10) $ (-123)
07:36:50 <lambdabot>  3
07:36:51 <haasn> :)
07:37:06 <zrho> Is there a game project out there that combines FRP with networked multiplayer?
07:37:11 <Iceland_jack> > (+1) . length . takeWhile (>9) . iterate (`quot` 10) $ 0
07:37:12 <lambdabot>  1
07:37:13 <Iceland_jack> :)
07:37:29 <Actreka> haasn: Nice, but is it slower than the integerLogBase approach?
07:37:30 <mm_freak> zrho: i'm working on one, but it's behind closed doors right now
07:37:42 * hackagebot shelly 1.4.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.4.1 (GregWeber)
07:37:55 <haasn> Actreka: probably, but you drop the arithmoi dependency :)
07:38:07 <deech> Can lazy evaluation be explained as a simple form of prolog-style unification?
07:38:23 <haasn> Iceland_jack: breaks for negative numbers again :(
07:38:36 <haasn> takeWhile ((>9).abs) -- ugh
07:38:38 <zrho> A lot of game state in FRP games currently is kept in closures with arrow loop, which is quite unfortunate if you want to synchronize state over the network...
07:38:39 <Iceland_jack> hah
07:38:41 <haasn> let's go with integerLogBase.
07:38:44 <haasn> Shorter code.
07:39:04 <mm_freak> zrho: i have actually solved that problem already =)
07:39:13 <mm_freak> zrho: wires support serialization now
07:39:44 <randomclown> mm_freak: can you have a look at my code and see if where the space leak is?
07:39:47 <mm_freak> haasn: i often pull in entire package trees just for a single function ;)
07:39:58 <mm_freak> randomclown: uh, me specifically?
07:40:04 <randomclown> yeah you specificially
07:40:09 <mm_freak> uhm, ok =)
07:40:12 <randomclown> take it to pms?
07:40:13 <mm_freak> i guess
07:40:15 <haasn> mm_freak: I pull in lens for combinators like (&) and (??)
07:40:29 <mm_freak> randomclown: go ahead
07:41:05 <zrho> mm_freak: I understand you do not want to share the project at this moment, but could you elaborate on how you did that?
07:41:39 <zrho> or - in a related matter - what kind of wires you are using that allow serialization.
07:42:03 <haasn> mm_freak: do I have to provide serialization methods when writing my own wires, then?
07:42:09 <mm_freak> zrho: the basic wire is this:  newtype Wire a b = Wire (a -> (b, Wire a b))
07:42:16 <mm_freak> zrho: (notice that inhibition is no longer builtin)
07:42:39 <haasn> Mealy!
07:42:50 <mm_freak> zrho: that one is isomorphic to:  data Wire a b = forall s. Wire s ((a, s) -> (b, s))
07:43:20 <mm_freak> zrho: so i realized that i can add serialization simply by requiring a Serialize instance for 's'
07:43:29 <mm_freak> however, /deserialization/ is more complicated
07:43:49 <mm_freak> so i went back to the initial version and added explicit serialization functions
07:44:29 <mm_freak> the basic idea is:  deserializing a wire takes not only the string as input, but also the initial wire
07:44:38 <mm_freak> it then uses the existing structure for deserialization
07:45:15 <mm_freak> haasn: if you use the smart constructors, yes…  but usually you would just use existing ones and combine them
07:46:22 <haasn> mm_freak: okay
07:46:48 <haasn> mm_freak: right, I was assuming if I wanted to write my own wire primitive
07:46:55 <zrho> mm_freak: it takes the initial wire and then fast forwards it?
07:58:04 <mm_freak> zrho: no, that would be horrible
07:58:31 <mm_freak> zrho: the problem is:  when you serialize an Int state you won't know what wire it represents
07:59:00 <mm_freak> one way is to write a special loader function that is aware of all the existing wires, but that would be a bad solution
07:59:24 <mm_freak> instead i realized that you have the wire anyway, so just use it as a template for loading
07:59:35 <mm_freak> myWire = time
07:59:47 <mm_freak> a Time value would be saved, say with value 13.7
08:00:05 <mm_freak> load myWire "blah.wire"
08:00:20 <mm_freak> understands that the 13.7 belongs to the 'time' wire
08:00:28 <mm_freak> because it can look into the template
08:01:22 <zrho> so each wire carries a serizalization and deserialization function (= the template)?
08:02:39 <mm_freak> zrho: yeah
08:05:58 <zrho> mm_freak: okay, this basically prevents using arrow loop for state then... But you could use a function like state :: Serializable s => Wire (a, s) (b, s) -> s -> Wire a b
08:09:10 <mm_freak> zrho: i don't see a reason why that would disallow ArrowLoop
08:09:53 <zrho> mm_freak: I guess you could forward information with it that can not be serialized, but that's just an intuition right now.
08:10:32 <bernalex> any wxhaskell gods who want to help me build a program? heh
08:10:51 <enthropy> why did you pick that toolkit?
08:11:30 <bernalex> enthropy: seems easier than gtk2hs
08:14:35 <bernalex> then again considering I'm unable to do anything and having trouble with the docs since they are only of the type "foo is a pointer to bar", and that the wx docs themselves are uhm yeah, not great... maybe have another look at gtk2hs.
08:20:18 <mljsimone> Hello
08:20:42 <mljsimone> There is a tool like valgrind that help me find a memory leak on a Haskell program?
08:20:46 <cariveri> hi :) How can I to move an element that I can select by id backwards or forwards ?  like in: Tree node [..,pred,mover,succ,..]  ->  Tree node [..,mover,pred,succ,..]
08:21:07 <geekosaur> careveri: zipper?
08:21:15 <bgamari> mljsimone, you mean GHC's heap profiler?
08:21:28 <bgamari> mljsimone, http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/prof-heap.html
08:21:33 <geekosaur> http://www.haskell.org/haskellwiki/Zipper
08:22:40 <mljsimone> bgamari: maybe. let me take a look
08:23:15 <shiona> I have extremely hard time starting any web dev attempts in haskell. There seems to be a few frameworks all of which have some tutorials of differing quality. Then there seems to be other relevant libraries (wai, warp, hamlet etc.)
08:23:29 <shiona> is there any one source I could go to to get going
08:24:09 <klrr_> shiona: here's some links http://www.haskell.org/haskellwiki/Web
08:24:10 <shiona> at the moment my grand plan would be to have user be able to run some limited haskell in their browser
08:24:40 <klrr_> like try haskell?
08:24:58 <klrr_> https://github.com/chrisdone/tryhaskell
08:25:21 <cariveri> geekosaur: perhasp I should have implement with zipper right away. but for now I only need to adjust the possition in a list.
08:25:50 <shiona> not sure. I had a vision of being able do to stuff with diagrams and then render them as svg to user
08:26:30 <klrr_> http://paste.hskll.org/get/1109 like that?
08:26:44 <cariveri> geekosaur: [..,pred,mover,succ,..] -> [..,mover,pred,succ,..]
08:26:57 <klrr_> https://github.com/co-dan/interactive-diagrams
08:27:24 <klrr_> (not posting for "haskell already have this", just they might have some information about it)
08:27:54 <shiona> seems like what I was thinking about, yes
08:30:06 <shiona> klrr_: since it's been done I guess I'll stick with that. or possibly fork and make some minor edits
08:35:12 <cizra> https://hackage.haskell.org/package/cryptohash-0.11.2/docs/Crypto-Hash.html - how do I get an ASCII printable SHA256 out of this?
08:35:51 <Iceland_jack> cizra: What do you mean ASCII printable? base64?
08:35:56 <cizra> hexdigest
08:36:15 <Yaniel> isn't SHA256 usually printed as base64
08:36:35 <cizra> Iceland_jack: I need to be compatible with http://docs.python.org/2/library/hashlib.html, search for hexdigest()
08:36:47 <Yaniel> or base16
08:37:29 <cizra> Python's hashlib's hexdigest() incidentally happens to output the same stuff that Linux's sha256 program.
08:39:29 <hjulle> Why does these not give the same result?
08:39:29 <hjulle> @run let n = 1 in -1 `div` 2
08:39:30 <lambdabot>  0
08:39:41 <hjulle> @run let n = -1 in n `div` 2
08:39:42 <lambdabot>  -1
08:39:51 <hjulle> @run -1 `div` 2
08:39:52 <lambdabot>  0
08:39:59 <hjulle> :S
08:40:46 <geekosaur> my guess is the usual weird precedence stuff around unary -
08:40:54 <geekosaur> it's a hack
08:40:56 <cizra> Yaniel: I think base16 might be what I want, and conveniently there's a lib for encoding binary stuff into base16. Testing...
08:40:57 <hjulle> @run (-1) `div` 2
08:40:59 <lambdabot>  -1
08:41:06 <klrr_> @run let n = 1 in (-1) `div` 2
08:41:07 <lambdabot>  -1
08:41:10 <Yaniel> :t base16
08:41:10 <lambdabot>     Not in scope: `base16'
08:41:10 <lambdabot>     Perhaps you meant `base' (imported from Numeric.Lens)
08:41:13 <klrr_> yeah
08:41:46 <cizra> Yaniel: Iceland_jack: Thanks! base16 works!
08:41:50 <hjulle> geekosaur: Thanks
09:00:59 <bernalex> I have a text field that I need to update every Nth second. any ideas for a good way to do this?
09:01:57 <bernalex> to be a bit more specific: I am using GTK and I have a label, and I want to update this label every Nth second. when I start the program, a file is read. I then do words file. I want to traverse this list word by word at a set word per minute rate.
09:02:13 <Twey> bernalex: FRP!
09:02:39 <bernalex> Twey: yes, it sounds exquisitly fit for FRP. any halp would be nice.
09:03:05 <bernalex> Twey: super bonus points if you know of a demo that does something like this with gtk2hs.
09:03:26 <Twey> bernalex: With reactive-banana you create an (event, handler) pair with addEventHandler, then have a main loop that fires the event every n seconds using the clock from GTK
09:03:49 <bernalex> Twey: interesting.
09:03:50 <Cale> That's... quite a sledgehammer to apply
09:04:12 <Twey> Cale: But then you can start infecting… ahem… improving the rest of the code with it!
09:05:05 <Twey> bernalex: In fact, given your problem description, you could make an event that accepts a String, and feed a word in every <time period>
09:05:33 <bernalex> Twey: I probably *could*. I need to find out how to do it first. :-P
09:06:14 <klrr_> what does (~) mean in the context of a type signature?
09:07:05 <quicksilver> it's an equality constraint, klrr_
09:07:13 <quicksilver> says that two types must be the same, or must unify together
09:07:36 <bernalex> Twey: I don't see any addEventHandler even, looking at http://hackage.haskell.org/package/reactive-banana-0.8.0.0/docs/doc-index.html
09:07:38 <Twey> bernalex: http://lpaste.net/7481116654856830976 — here's me doing it with GLFW; I don't know how the GTK clock works, but I assume it's similar
09:07:56 <Twey> bernalex: Sorry, it's called ‘newAddHandler’
09:09:34 <Twey> bernalex: It produces a pair of a → IO () and AddHandler a; you call the a → IO () from outside the network, then you can reify the AddHandler a inside the Moment monad to get an Event a that occurs whenever the a → IO () is executed
09:09:42 <klrr_> quicksilver: equal in what sense?
09:10:05 <quicksilver> klrr_: in the sense that Int is equal to Int
09:10:30 <klrr_> hmm, what is it useful for, and in what cases can two different types be the same?
09:10:50 <Cale> klrr_: When you pattern match on a GADT, type equality constraints are generated
09:10:59 <Cale> klrr_: For example, if you have something like
09:11:02 <klrr_> to give some context, i ran across this when using pipes-safe and seeing this type signature: "(MonadSafe m, Base m ~ IO) => ..."
09:11:50 <Cale> Okay, well, in that case, it says that the type Base m is equal to IO. Presumably Base is an associated type or a type family
09:12:19 <klrr_> how can two different types be equal?
09:12:25 <Iceland_jack> :kind (~)
09:12:31 <bennofs> klrr_: Base m is a type family
09:12:42 <Cale> klrr_: Look at the definition of MonadSafe
09:12:46 <klrr_> oh, so i need to understand type familys for this
09:12:48 <Cale> http://hackage.haskell.org/package/pipes-safe-2.0.2/docs/src/Pipes-Safe.html#MonadSafe
09:12:59 <k_89> hello
09:13:01 <k_89> http://lpaste.net/100514
09:13:07 <Cale> Instances of MonadSafe will say which type Base m is
09:13:14 <k_89> this code is giving me way too many errors than i'd like
09:13:39 <Cale> and so that constraint is saying that whichever instance it is that you choose has got to be one for which Base m is IO
09:13:42 <k_89> can someone tell me why ?
09:13:43 <klrr_> aa , so  ~ is more of a decleration saying this is IO?
09:14:01 <Cale> klrr_: It's a restriction on which instances of MonadSafe you're allowed to use
09:14:20 <Iceland_jack> @kind (~)
09:14:21 <lambdabot> * -> * -> Constraint
09:14:25 <Iceland_jack> @kind (~) Int Bool
09:14:25 <lambdabot> Constraint
09:14:45 <klrr_> does "*" mean anything special or is it just a type variable?
09:14:46 <bernalex> Twey: ty
09:14:48 <Cale> k_89: Your type signature says that nth takes two parameters
09:14:58 <Iceland_jack> klrr_: It's a kind
09:15:05 <Cale> k_89: But your definition assumes it has one parameter, which is a pair
09:15:08 <Twey> bernalex: No problem
09:15:16 <Iceland_jack> @kind Int
09:15:17 <lambdabot> *
09:15:21 <Iceland_jack> @kind Maybe
09:15:22 <lambdabot> * -> *
09:15:23 <Iceland_jack> @kind Either
09:15:23 <k_89> oh
09:15:24 <lambdabot> * -> * -> *
09:15:39 <k_89> spaces
09:15:42 <k_89> no commas
09:15:43 <k_89> thanks
09:15:45 <bennofs> @kind 1
09:15:46 <lambdabot>     Illegal literal in type (use -XDataKinds to enable): 1
09:15:49 <klrr_> so any monad that is instance of IO and are of kind * -> * are allowed to be used ?
09:15:57 <klrr_> MonadIO*
09:16:19 <Cale> klrr_: Not literally...
09:16:32 <Cale> klrr_: It means what it says, that Base m had better be IO
09:16:58 <klrr_> im not sure what that means
09:17:14 <Twey> klrr_: Base can be a type family, for example
09:17:18 <Cale> klrr_: Note that in the instance  (MonadIO m, MonadCatch m) => MonadSafe (SafeT m), you have the definition  type Base (SafeT m) = m
09:17:31 <Twey> type instance Base m = IO
09:17:42 <Cale> klrr_: So, e.g. Base (SafeT IO) ~ IO
09:18:24 <Cale> However, if m were not IO, but some other instance of MonadIO and MonadCatch, then that equation wouldn't hold there
09:19:18 <klrr_> is there any were i could learn about the necessary to understand this?
09:19:46 <Achylles> which is the command/function to turn a string into a list of char?  "hello" ->  ['h','e','l','l','o']
09:19:50 <Cale> http://www.haskell.org/haskellwiki/GHC/Type_families
09:19:55 <Iceland_jack> Achylles: id :)
09:19:57 <`^_^v> a string is a list of chars
09:20:02 <Iceland_jack> It's the same Achylles
09:20:12 <Iceland_jack> > ['h', 'e', 'l', 'l', 'o'] == "hello"
09:20:13 <lambdabot>  True
09:20:17 <Achylles> Iceland_jack, I know that
09:20:26 <geekosaur> then why are you asking?
09:20:28 <klrr_> Cale: thanks
09:20:33 <Kaidevappy> ^
09:20:33 <Iceland_jack> Well then you should also know that there is no need for a function Achylles
09:20:53 <Iceland_jack> Maybe you mean turning a string into a list of singleton strings
09:21:07 <Iceland_jack> > map return "hello" :: [String]
09:21:08 <lambdabot>  ["h","e","l","l","o"]
09:21:09 <Cale> > map (:[]) "hello"
09:21:10 <lambdabot>  ["h","e","l","l","o"]
09:21:14 <Achylles> Iceland_jack, I want only to turn a representation into another
09:21:17 <geekosaur> or they are confused that show makes it a string instead of a list
09:21:21 <Kaidevappy> you aren't
09:21:22 <Iceland_jack> Achylles: that doesn't make sense
09:21:26 <FreeFull> (:[]) is the robot monkey
09:21:30 <Cale> Achylles: They're not different representations
09:21:32 <Twey> klrr_: They're just functions that take and return types
09:21:33 <Iceland_jack> It's just sugar
09:21:39 <Kaidevappy> when they say those two are the same, they mean it
09:21:47 <Kaidevappy> "f" is exactly the same thing as ['f']
09:21:54 <geekosaur> Achylles, there is no difference. but show will always show a list of characters as a string because that's what it usually represents
09:22:00 <Kaidevappy> it's two different syntaxes for the same thing
09:22:01 <Cale> Achylles: "hello" and ['h','e','l','l','o'] literally are the same thing
09:22:24 <klrr_> Twey: i bet there is more to know, otherwise the type family document wouldnt be so long ;)
09:22:24 <Achylles> Iceland_jack, lets say that I want to split  "hello" into a list
09:22:25 <Kaidevappy> and 'h':'e':'l':'l':'o':[]
09:22:27 <Cale> They're the same String value, so there's no way to tell them apart
09:22:27 <Iceland_jack> It's possible that Achylles only wants "hello" do *display* as ['h','e','l','l','o'] in GHCi or soemthing similar
09:22:36 <Cale> Achylles: It already is a list
09:22:37 <Iceland_jack> which is possible
09:22:55 <Cale> Achylles: and you can apply any list function to it
09:23:01 <Cale> :t reverse
09:23:01 <lambdabot> [a] -> [a]
09:23:05 <Cale> > reverse [1,2,3,4,5]
09:23:06 <bennofs> > drop 4 "hello"
09:23:06 <lambdabot>  [5,4,3,2,1]
09:23:07 <lambdabot>  "o"
09:23:11 <Cale> > reverse "hello"
09:23:12 <lambdabot>  "olleh"
09:23:26 <Twey> klrr_: Well, there are some other things, but that's all you need to understand ~
09:24:00 <Kaidevappy> > mapM (fromEnumTo minBound) "hello"
09:24:01 <lambdabot>  Not in scope: `fromEnumTo'
09:24:01 <lambdabot>  Perhaps you meant `fromEnum' (imported from Prelude)
09:24:05 <Twey> klrr_: There are also associated types (types that are determined by a type class) and data families (type families whose result is a new type, rather than a reference to an existing type)
09:24:06 <Cale> klrr_: The type families document mostly consists of examples of how you can use the things. The idea of them is pretty natural
09:24:22 <Kaidevappy> > mapM (fromEnumTo minBound) "hello"
09:24:23 <lambdabot>  Not in scope: `fromEnumTo'
09:24:23 <lambdabot>  Perhaps you meant `fromEnum' (imported from Prelude)
09:24:32 <FreeFull> How do you make "hi" display as ['h','i'] then?
09:24:35 <Kaidevappy> > mapM (enumFromTo minBound) "hello"
09:24:36 <lambdabot>  ["\NUL\NUL\NUL\NUL\NUL","\NUL\NUL\NUL\NUL\SOH","\NUL\NUL\NUL\NUL\STX","\NUL\...
09:24:54 <Cale> FreeFull: You'd have to write some custom display function.
09:24:57 <bennofs> you can get close
09:25:03 <Iceland_jack> FreeFull: Do you mean in GHCi when you enter
09:25:03 <Iceland_jack>     > "hi"
09:25:03 <Iceland_jack> or do you want to function String -> String?
09:25:05 <Twey> FreeFull: You can newtype-wrap Char
09:25:07 <klrr_> well, i just read the document and see if ~ make sense then
09:25:08 <bennofs> > map (:[]) "hello"
09:25:09 <lambdabot>  ["h","e","l","l","o"]
09:25:19 <FreeFull> Twey: That would work
09:25:24 <Twey> @define newtype NotChar = NotChar a
09:25:24 <lambdabot>  .L.hs:151:27: Not in scope: type variable `a'
09:25:26 <FreeFull> bennofs: Not the same
09:25:28 <Twey> Er
09:25:30 <Twey> @define newtype NotChar = NotChar Char
09:25:31 <lambdabot>  Defined.
09:25:34 <bennofs> FreeFull: I said close :)
09:25:44 <Kaidevappy> FreeFull: for display purposes, that works well, though
09:25:48 <Twey> @define instance Show NotChar where show (NotChar a) = show a
09:25:49 <lambdabot>  Defined.
09:26:00 <FreeFull> > map NotChar "hello"
09:26:03 <lambdabot>  ['h','e','l','l','o']
09:26:24 <bennofs> @let asCharList = map NotChar
09:26:25 <lambdabot>  Defined.
09:26:38 <Twey> bennofs: I think you should include show in there
09:26:50 <bennofs> > asCharList "hello"
09:26:52 <lambdabot>  ['h','e','l','l','o']
09:27:02 <Twey> So as to hide the ‘NotChar’ altogether
09:27:06 <Achylles> bennofs, lambdabot    thx
09:27:07 <Cale> :t asCharList "hello"
09:27:08 <lambdabot> [NotChar]
09:27:10 <Cale> :D
09:27:16 <Cale> Kind of misleading
09:27:24 <Iceland_jack> This is all syntactic niceties, but probably doesn't help Achylles
09:27:34 <Twey> @define showAsCharList = show . map NotChar
09:27:35 <lambdabot>  Defined.
09:27:41 <Twey> > showAsCharList "hello"
09:27:42 <lambdabot>  "['h','e','l','l','o']"
09:27:48 <k_89> > nth :: [a] -> Int -> Maybe[a]
09:27:49 <lambdabot>  Not in scope: `nth'
09:27:53 <k_89> > let nth :: [a] -> Int -> Maybe[a]
09:27:54 <lambdabot>  not an expression: `let nth :: [a] -> Int -> Maybe[a]'
09:28:01 <k_89> ..
09:28:07 <Iceland_jack> If you want to differentiate between syntactic sugar then you're possibly doing something wrong
09:28:26 <FreeFull> :t showAsCharList
09:28:27 <lambdabot> [Char] -> String
09:28:37 <Twey> Haha
09:28:54 <FreeFull> k_89: What are you trying to do?
09:29:10 <k_89> FreeFull, http://lpaste.net/100515
09:29:26 <k_89> trying to write a function to get the nth element out of a list using pattern matching
09:29:44 <FreeFull> k_89: Well, lambdabot doesn't have nth defined, so doing that wouldn't work
09:29:59 <Twey> k_89: That's not going to type-check
09:29:59 <k_89> okay, basically, i am getting an error
09:30:04 <k_89> yeah
09:30:04 <Twey> k_89: I think you mean ‘Maybe a’
09:30:09 <k_89> oh
09:30:11 <FreeFull> k_89: What Twey said
09:30:20 <k_89> scala stuff is carrying over :p
09:30:39 <Twey> Maybe [a] is maybe a list of a's, and you've put an a in it, so the only way that can work is if a = [a], which gives an infinite type
09:31:27 <k_89> i am still getting an error
09:31:28 <k_89> No instance for (Num (Maybe a)) arising from a use of `-'
09:31:28 <k_89>     Possible fix: add an instance declaration for (Num (Maybe a))
09:31:28 <k_89>     In the expression: nth xs n - 1
09:31:28 <k_89>     In an equation for `nth': nth (x : xs) n = nth xs n - 1
09:31:44 <k_89> i have no clue how to do anything about it
09:31:57 <Twey> k_89: Your precedence preconceptions are wrong
09:31:58 <Iceland_jack> k_89: You're treating a 'Maybe a' value as a number
09:32:11 <Twey> nth x n - 1 = (nth x n) - 1
09:32:11 <Iceland_jack> since 'nth xs n' return either Nothing or 'Just something'
09:32:31 <Twey> You probably want  nth x (n - 1)  or  nth x $ n - 1
09:32:34 <k_89> adding brackets
09:32:44 <k_89> phew, thanks
09:35:59 <cizra> How can I convert between lazy and strict ByteStrings? It seems to me that Data.ByteString.Base16 uses strict ones, and Codec.Archive.Tar uses lazy ones.
09:36:27 <k_89> okay, so function definitions work only with types and not concrete values
09:36:29 <k_89> ?
09:36:44 <Clint> cizra: there are functions for that in Data.ByteString.Lazy
09:36:56 <Iceland_jack> k_89: What do you mean?
09:37:03 <cizra> Clint: Thanks!
09:37:57 <k_89> Iceland_jack, http://lpaste.net/100515
09:38:16 <k_89> i called it like nth([1,2,3,4,5], 3)
09:38:19 <Twey> cizra: pack . unpack
09:38:39 <Iceland_jack> k_89: Skip the tuple
09:38:43 <Twey> cizra: But perhaps you should just be using lazy ones from the start?  Data.ByteString.Lazy.Base16 ?
09:38:49 <Iceland_jack> You should call it like it's defined
09:38:49 <Iceland_jack>     nth [1,2,3,4,5] 3
09:38:56 <k_89> OH
09:38:59 <k_89> ohhh
09:38:59 <Iceland_jack> :)
09:39:03 <k_89> why do i keep doing that
09:39:15 <Iceland_jack> Old habits are hard to break
09:39:18 <k_89> yeah
09:39:38 <Iceland_jack> Does it work now?
09:39:53 <k_89> it works, but not corerctly
09:39:56 <Iceland_jack> haha
09:40:00 <k_89> :P
09:40:14 <cizra> Twey:     Could not find module `Data.ByteString.Lazy.Base16'
09:40:23 <k_89> i am expecting a Just(4), and its giving me a Nothing, figuring out why
09:40:50 <Iceland_jack> k_89: it's because of (x:[])
09:40:53 <k_89> yeah
09:40:56 <Iceland_jack> that will only match the singleton list
09:40:58 <k_89> figured, removing them
09:41:13 <Twey> cizra: Sorry, it's .Base16.Lazy
09:41:17 <Iceland_jack> If you do:
09:41:17 <Iceland_jack>     nth (x:_)  0 = Just x
09:41:35 <Iceland_jack> then it works for
09:41:35 <Iceland_jack>     ghci> nth [1,2,3,4,5] 3
09:41:35 <Iceland_jack>     Just 4
09:41:40 <k_89> yeah
09:41:53 <k_89> i don't know why i changed it from _ to [], i had _ before
09:42:00 <k_89> it works now though, thanks !
09:42:03 <Iceland_jack> The old version would only work for getting the last element of a list :)
09:42:13 <Iceland_jack>     ghci> [1..5] 4
09:42:13 <Iceland_jack>     Just 5
09:42:13 <k_89> yeah
09:42:25 <Iceland_jack> Hope that cleared things up :)
09:42:29 <k_89> yup !
09:42:49 <Iceland_jack> Just fyi, if you do want to match the singleton list you can use
09:42:49 <Iceland_jack>     someFunction [x] = ...
09:42:57 <Iceland_jack> It means the same as
09:42:57 <Iceland_jack>     someFunction (x:[]) = ...
09:43:03 <k_89> hmm, yeah
09:43:05 <k_89> cool
09:43:28 <Iceland_jack> But looks nicer :)
09:44:34 <Iceland_jack> You can also match on lists of length 2, length 3, ...
09:44:34 <Iceland_jack>     myFunction [a,b]     = ...   -- same as myFunction (a:b:[])
09:44:34 <Iceland_jack>     myFunction [a,b,c]   = ...   -- same as myFunction (a:b:c:[])
09:44:34 <Iceland_jack>     myFunction [a,b,c,d] = ...   -- same as myFunction (a:b:c:d:[])
09:44:41 <Iceland_jack>  
09:45:02 <klrr_> okey, so in Pipes.Network.TCP.Safe Base m ~ IO simply means Base m have kind * -> * and IO does aswell?
09:47:38 <Cale> klrr_: No
09:47:42 <Cale> klrr_: It means they're equal
09:47:53 <Cale> Base is a type-level function
09:48:26 <Cale> Base :: (* -> *) -> (* -> *)
09:48:55 <Cale> and Base m :: * -> * might or might not be equal to IO
09:48:57 <klrr_> then IO is a type-level function as well?
09:49:08 <Cale> sure, but IO :: * -> *
09:49:16 <klrr_> ok
09:49:21 <Cale> So, IO is potentially the result of applying Base to m
09:49:27 <Cale> but it might not be
09:49:28 <klrr_> but what does it mean that they are equal then?
09:49:54 <Cale> The instances of MonadSafe define what Base does when applied to various m
09:50:12 <Cale> and this type equality constraint says that Base m has to be IO
09:50:33 <Cale> in order for whatever follows to be used
09:51:00 <klrr_> hmm
09:51:15 <klrr_> i dont quite understand why it needs it
09:52:00 <Cale> Well, given the operations in MonadSafe, probably because it applies register to an IO action
09:52:07 <Cale> register :: Base m () -> m ReleaseKey
09:52:41 <klrr_> is it to make those signatures shorter? or is there actually a purpose to "wrap" types into Base?
09:52:41 <Cale> or perhaps it uses liftBase, applying that to an IO action
09:52:41 <Cale> liftBase :: Base m r -> m r
09:52:51 <Cale> It's not wrapping anything
09:52:57 <Twey> It's weird how we have equality for functions at the type level but not at the value level
09:53:02 <Cale> Base is computing some other type, given m
09:53:14 <Cale> in the same way that  sqrt  computes a Float given another Float
09:53:21 <klrr_> if ~ is a type-level function, what type does it return?
09:53:33 <Cale> It's not
09:53:38 <klrr_> okey
09:53:41 <klrr_> what does it do then
09:53:52 <Cale> t ~ s says that t and s are equal
09:54:02 <klrr_> okey, but why explicitly state that?
09:54:03 <triliyn> It's a Constraint like typeclass constraints
09:54:09 <Twey> Cale: Is it not an operator ★ → ★ → Constraint?
09:54:22 <Twey> Er, no
09:54:26 <Twey> I guess it isn't
09:54:28 <Cale> Well, it would at least have to be polykinded
09:54:32 <Twey> k → k → Constraint
09:54:37 <Cale> forall k. k -> k -> Constraint, yeah
09:54:41 <klrr_> so it saying basically i only allowed Monad m if Base is equal to IO?
09:54:50 <klrr_> Base m*
09:54:59 <Cale> Where are you seeing this constraint?
09:55:23 <klrr_> http://hackage.haskell.org/package/pipes-network-0.6.2/docs/Pipes-Network-TCP-Safe.html#fromConnect
09:56:01 <Cale> It says you're only allowed to use fromConnect for m which are instances of MonadSafe and for which Base m is equal to IO
09:56:34 <Cale> In that case, you supply an Int, a HostName, a ServiceName, and you receive a Producer' ByteString m ()
09:56:34 <klrr_> okey
09:56:51 <klrr_> then i think ive understood it, thanks!
09:58:50 <Cale> klrr_: If you'll look at http://hackage.haskell.org/package/pipes-safe-2.0.2/docs/src/Pipes-Safe.html#MonadSafe and the various instances defined in this module
09:59:09 <Cale> klrr_: You'll see that  Base (SafeT m) = m
09:59:28 <enthropy> do other people write  let xy = (x,y) in f `uncurry` xy ?
09:59:33 <Cale> and for various sorts of monad transformers other than SafeT, we have  Base (SomethingT m) = Base m
09:59:44 <Cale> enthropy: wat
09:59:45 <enthropy> when the (x,y) is provided by some other function
10:00:12 <Cale> oh, I haven't done that, usually I'll write uncurry prefix
10:00:14 <enthropy> err, the xy is a pair provided by some other function
10:00:32 <klrr_> Cale: okey, so Base m ~ IO is in fact Base (SafeT m) ~ IO?
10:00:49 <Cale> Or I will write  let (x,y) = foo ... in f x y
10:01:09 <Cale> klrr_: possibly
10:01:14 <klrr_> in the context of fromConnect
10:01:16 <Cale> klrr_: It depends on what m is
10:01:36 <Cale> In the context of fromConnect, m is just m, we don't know more about it
10:01:47 <Cale> You need to look at where fromConnect is being used to tell which m is being selected
10:01:51 <klrr_> it feels like im missing something then
10:02:16 <Cale> But maybe we choose m = SafeT IO
10:02:31 <triliyn> klrr_: it looks like it just means "There's an IO at the bottom of this monad stack"
10:02:35 <Cale> and then we know that  Base (SafeT m) = m, so in particular Base (SafeT IO) = IO
10:02:41 <Cale> which satisfies the constraint
10:02:47 <Cale> triliyn: not quite!
10:02:57 <Cale> triliyn: But almost
10:03:27 <Cale> It means that there are possibly a bunch of transformers applied to SafeT which is then immediately applied to IO
10:03:55 <Cale> Er, that's misstated, a bunch of transformers applied to SafeT IO
10:04:19 <Cale> The SafeT can't occur farther up
10:04:29 <Cale> (though in general, perhaps it could)
10:04:37 <klrr_> so if m is virtually any MonadIO?
10:04:50 <klrr_> or rather, can only be any Monad of MonadIO
10:05:04 <klrr_> who is instance of MonadIO is what i mean
10:05:26 <Cale> It has to specifically look like  FooT (BarT (BazT (SafeT IO)))
10:06:14 <klrr_> okey, so the "last" monad in a monad transformer need to be SafeT IO and that is implied by giving the contraint Base m ~ IO ?
10:06:18 <Cale> In particular,  FooT (BarT (SafeT (BazT IO))) wouldn't work with fromConnect
10:06:27 <Cale> yeah
10:06:50 <klrr_> Cale: okey, thanks a lot for the explaination(s)!
10:07:17 <mm_freak> i tend to use ResourceT over SafeT
10:07:28 <mm_freak> it can occur anywhere and has some other benefits
10:07:34 <Cale> I tend to use neither. I don't really understand what any of this is for.
10:08:03 <klrr_> mm_freak: what is the ResourceT's package called?
10:08:06 <mm_freak> Cale: (key, h) <- allocate (openFile "blah" ReadMode) hClose
10:08:28 <mm_freak> Cale: either you free early by releasing via 'key', or the resource is freed automatically when ResourceT is left
10:08:29 <bennofs> Sometimes, ResourceT is useful when you have some stateful code in a forever $ block that dynamically needs to allocate / release resources
10:08:40 <mm_freak> SafeT does pretty much the same thing, except that it's missing some important functionality
10:08:44 <mm_freak> klrr_: resourcet
10:08:49 <klrr_> thanks
10:08:55 <cizra> Is it possible to convince the Codec.Archive.Tar module to suppress somehow errors on unpacking? It's failing to unpack some archives with broken symlinks and stuff.
10:09:08 <klrr_> mm_freak: what functionality?
10:09:15 <mm_freak> klrr_: 'allocate' for example =)
10:09:31 <mm_freak> also recently Tekmo stated that he might actually move to ResourceT
10:10:01 <klrr_> hmm, not sure if i need that in my program though so ill stick with pipes-safe for now
10:10:08 <mm_freak> klrr_: you need it
10:10:31 <mm_freak> the problem with SafeT is that resource allocation and assigning a release-key are decoupled in SafeT, unless you do blocking yourself
10:10:43 <Clint> where has Tekmo been?
10:10:51 <mm_freak> so it has some unsafe spots which ResourceT does not have
10:11:07 <mm_freak> Clint: he's here from time to time
10:13:54 <klrr_> Cale: well, i dont really want to decide when to release the resources, i simply want to do that when program is finished
10:14:14 <Twey> Is there a name for an ‘anti-distributive’ property, like for string reverse or matrix transpose, such that for some operator * you have f(x * y) = f(y) * f(x) ?
10:14:26 <mm_freak> another useful feature of ResourceT:  it has a system for scarce resources…  you create a resource, but it is not allocated until you actually use it, and is immediately freed afterwards
10:14:34 <klrr_> or it's just me who have missunderstood something (as usual)
10:15:17 <mm_freak> klrr_: well, 'bracket' is often enough
10:15:48 <klrr_> yeah, i think ill just overcomplicate think with pipes-safe
10:16:07 <mm_freak> ResourceT is useful when you allocate a lot of resources in the middle of a loop that you need to keep to some fixed point
10:16:34 <mm_freak> klrr_: what are you doing?  perhaps i can help you with the decision =)
10:17:58 <klrr_> an IRC bot, maybe SafeT or ResourceT can be useful for handler functions (whenever my bot recieve a proper command it spawns a thread that apply its arguments to the function)
10:18:35 <mm_freak> that seems like a weird design
10:18:42 <mm_freak> how about using reactive-banana?
10:19:41 <Grant__> Cabal is yelling at me when I try to use "data-dir" or "extra-source-files" in the .cabal file. Have these been deprecated or something?
10:19:43 <klrr_> could you explain? (i dont see how FRP could be useful when writing a IRC bot)
10:20:28 <mm_freak> klrr_: IRC is a system of events (messages, joins, parts, etc.) and behaviors (nicknames, channel memberships, etc.)
10:20:35 <mm_freak> klrr_: FRP models that very elegantly
10:20:58 <mm_freak> your current nickname is a behavior, and you use it like it were a regular string…  if your nickname changes, your program will behave properly
10:21:45 <klrr_> ive played around with FRP a bit, but how i thought to design my irc bot was like this: server :: Producer Message >-> eventHandler :: Pipe Message Messsage >-> writeToServer :: Consumer Message
10:22:01 <mm_freak> klrr_: there is your problem: "eventHandler"
10:22:11 <mm_freak> every callback-based system eventually hits the complexity wall
10:22:13 <bennofs> is using StateT with a custom state data type a bad idea for algorithms that could be written using a fold? I find that when I use stateT, I can more easily factor out the updating of different parts of the "state".
10:22:30 <klrr_> mm_freak: ill have to google callback
10:22:32 <mm_freak> bennofs: depends on the algorithm
10:22:43 <mm_freak> klrr_: an event handler is called a "callback"
10:22:53 <mm_freak> klrr_: you specify an action to be invoked when an event happens
10:23:22 <mm_freak> klrr_: if i ever get around to actually finishing fastirc, you will see this in action =)
10:23:40 <klrr_> fastirc?
10:23:46 <Clint> @hackage fastirc
10:23:46 <lambdabot> http://hackage.haskell.org/package/fastirc
10:23:52 <mm_freak> don't look into the hackage package
10:24:04 <klrr_>  i already have a parser
10:24:04 <Clint> look at the secret github repo
10:24:06 <mm_freak> it's a horribly outdated version that has nothing in common with the one i'm slowly working on
10:24:22 <mm_freak> Clint: that one is also outdated
10:24:25 <klrr_> secret github repo?
10:24:25 <Clint> haha
10:24:43 <klrr_> your idea with FRP is actually quite nice though
10:25:13 <klrr_> although, i want my irc bot to be easily extendible, and i think it would be easier to define a type of handler functions and then put them in a map
10:25:20 <mm_freak> ircLines :: (Monad m) => Producer ByteString m r -> FreeT (Producer ByteString m) m r
10:25:36 <mm_freak> then comes the parser, and everything after that is FRP =)
10:25:55 <mm_freak> klrr_: you're wrong
10:26:06 <mm_freak> klrr_: FRP is specifically to address maintainance hell and extensibility
10:26:23 <klrr_> okey, how would you define a command for example?
10:26:43 <klrr_> do you have abstract the Message producer as a behaviour isntead?
10:26:43 <mm_freak> the most general form would be:  Event Message -> Event Message
10:26:57 <klrr_> aaa
10:27:05 <klrr_> good idea
10:27:13 <mm_freak> it takes the input event and produces an output event
10:27:20 <bennofs> mm_freak: well, I have a board game where you lay a series of stones onto a board. In my function to get the available moves starting at some position on the board, I need to get the possible stones for the current position, then update the game state and the position and recurse until I cannot lay another stone. I'm using the list monad. Currently, my function takes 6 parameters and the body of the function
10:27:21 <bennofs> is just a big let binding assigning param' values. If I write this using the State monad, I can split it into "update position", "update game state", etc. Just wondering if that is me thinking too imperatively
10:27:24 <mm_freak> (note the difference between "event" and "occurrence")
10:28:24 <klrr_> but what do i do if i want to run the command in another thread so it doesnt block?
10:28:28 <mm_freak> bennofs: ask yourself whether you /want/ to split this up
10:28:40 <mm_freak> bennofs: there are always ways to make this nicer, and State is probably not one of them =)
10:29:07 <mm_freak> klrr_: FRP is concurrent by design
10:29:43 <mm_freak> klrr_: http://www.youtube.com/watch?v=gaG3tIb3Lbk
10:29:51 <mm_freak> i recommend watching this
10:30:12 <mm_freak> it's about sodium though, not reactive-banana
10:30:23 <klrr_> thanks, will need to refresh my memory on FRP it seems
10:30:24 <mm_freak> they are pretty similar
10:30:33 <klrr_> both are applicative so
10:30:47 <klrr_> or classical its called ?
10:30:52 <mm_freak> FRP =)
10:31:00 <klrr_> yeah classical frp
10:31:14 <mm_freak> it's "traditional" in the sense that it has 'Behavior a' and 'Event a'
10:31:19 <mm_freak> AFRP has 'a' and 'Event a'
10:31:25 <mm_freak> but it's not really suitable for this kind of application
10:33:33 <mm_freak> FRP has another important benefit:  if you ever decide to give your bot a UI, integration will be very easy =)
10:33:49 <triliyn> mm_freak: speaking of FRP, do you think the inability to convert a Behavior into an Event of changes is a useful property? I can't visualize any particular situations where it's important
10:34:37 <mm_freak> triliyn: well, it's a property of the model…  if you don't follow the model, your basic assumptions about your system may be in danger
10:35:07 <triliyn> mm_freak: right, I guess I was just wondering what the motivation behind that particular property of the model was
10:35:31 <mm_freak> triliyn: the motivation is this:  a true FRP system can have continuous behaviors, for which changes would in fact not make sense
10:35:37 <mm_freak> this is particularly true for AFRP
10:35:48 <mm_freak> not so much for reactive-banana, because it's less general
10:36:03 <mm_freak> in reactive-banana behaviors are technically discrete
10:36:11 <mm_freak> because they are always constructed out of events
10:36:55 <mm_freak> triliyn: i'm doing research on a topological FRP model that may actually be able to make sense of 'changes' =)
10:37:09 <triliyn> hmmm, interesting!
10:37:32 <conal> mm_freak: no temporally continuous primitives in reactive-banana? not even time?
10:37:40 <mm_freak> conal: nope
10:37:49 <conal> :/
10:38:21 <mm_freak> conal: reactive-banana and sodium start with events and construct behaviors out of them…  it's in fact the only way to get behaviors there
10:38:49 <conal> mm_freak: too bad. i wonder why.
10:39:05 <mm_freak> conal: it makes sense for certain applications…  it allows an efficient concurrency-based internal design
10:39:20 <mm_freak> conal: in fact i found that STM is entirely enough to implement this subset of FRP
10:39:25 <dmwit> Why bother with behaviors if they're just disguised events?
10:39:40 <mm_freak> dmwit: because behaviors are applicative and always have a value
10:40:24 <dmwit> Why can't we make events be applicative with the same intuition?
10:40:30 <conal> mm_freak: maybe it'd be easy to put a continuous layer on top. by having discretely updating values each of which is a continuous non-reactive behavior, as in the TBAG and reactive implementations.
10:41:08 <mm_freak> dmwit: you can make an Applicative instance that handles only simultaneous events…  it's just not very useful =)
10:41:13 <mm_freak> dmwit: wait, you can't
10:41:19 <mm_freak> 'pure' doesn't make sense
10:41:27 <dmwit> But why not make an Applicative event that handles non-simultaneous events?
10:41:29 <mm_freak> dmwit: the 'merge' pattern is more useful for events
10:41:37 <mm_freak> merge :: (a -> a -> a) -> Event a -> Event a -> Event a
10:41:56 <mm_freak> conal: sure, you can do that
10:42:05 <mm_freak> conal: but it's still discrete =)
10:42:11 <mm_freak> you could pretend that it's continuous
10:42:22 <mm_freak> dmwit: because it's impossible
10:42:23 <dmwit> i.e. f <*> v would have "timesteps" at the union of the set of timesteps "f" and "v" have
10:42:32 <mm_freak> (<*>) :: Event (a -> b) -> Event a -> Event b
10:42:43 <mm_freak> what's your result, if the first event does happen, but the second doesn't?
10:42:56 <conal> mm_freak: then put an API layer on top of that implementation to make it genuinely continuous, as in tbag & reactive.
10:43:02 <hcaulfield57> Any Gentoo users here?
10:43:07 <dmwit> mm_freak: Same semantics as the second value, then.
10:43:18 <conal> mm_freak: rather than exposing the layered implementation.
10:43:20 <dmwit> mm_freak: If your argument is allowed not to happen, surely your result is allowed not to happen =)
10:43:35 <mm_freak> conal: that would work, but if you need that, i believe AFRP handles that better
10:43:56 <mm_freak> dmwit: and what's 'pure'?
10:44:02 <mm_freak> dmwit: the event that happens all the time? ;)
10:44:08 <dmwit> An event at -\infty, I would suppose.
10:44:14 <dmwit> Just a single such.
10:44:24 <conal> mm_freak: i'm meaning to point out that frp and afrp can both handle continuity easily. which one chooses is another matter.
10:44:54 <mm_freak> conal: sure, but AFRP only does an addition per frame to get that
10:46:48 <mm_freak> conal: in a system like reactive-banana and sodium this would be very expensive, and i couldn't figure out how to get the same efficiency for actual time out of non-arrowized FRP
10:47:03 <mm_freak> conal: if i could abandon the A i would do it immediately =)
10:47:10 <t4nk306> people actually talking here?
10:47:13 <t4nk306> wow
10:47:20 <triliyn> mm_freak: do you find arrows cumbersome?
10:47:28 <mm_freak> triliyn: yes
10:47:59 <triliyn> hmm o.o
10:48:08 <mm_freak> triliyn: surprised? =P
10:48:16 <conal> mm_freak: i don't know why you think it'd be very expensive. have you tried, via a simple type of non-reactive continuous behaviors as the values being discretely updated?
10:48:20 <triliyn> A bit!
10:48:35 <luova> Has anybody had experience overloading showList in an instance of Show for a custom data type?
10:48:40 <conal> mm_freak: adding one optimization for dynamic constant propagation.
10:48:52 <conal> mm_freak: which is very simple
10:48:58 <mm_freak> conal: yes, my benchmark resulted in ~50k FPS with reactive-banana and ~200M FPS with netwire
10:49:16 <mm_freak> conal: and my new abstraction beats even netwire
10:49:19 <t4nk306> so i am a beginner, where do i start?
10:49:36 <mm_freak> t4nk306: LYAH is popular
10:49:39 <mm_freak> @where lyah
10:49:39 <lambdabot> http://www.learnyouahaskell.com/
10:50:03 <luova> t4nk306: I found the tutorials on fpcomplete.com to be very useful, more so than LYAH. but that's just me.
10:50:16 <conal> mm_freak: with continuous time and faithful to a precise & simple denotation?
10:50:16 <nschoe> t4nk306, Real World Haskell is great too
10:50:21 <Peaker> Writing a parser that supports textual #include with Parsec proves much more challenging than I thought!
10:50:26 <mm_freak> conal: yes
10:50:38 <t4nk306> Real World Haskell?
10:50:40 <mm_freak> conal: your original denotation in fact
10:50:40 <t4nk306> how come?
10:50:57 <conal> mm_freak: :)
10:51:13 <mm_freak> conal: http://hub.darcs.net/ertes/wires
10:51:20 <nschoe> t4nk306, it's a book. Very well written. Learnt from here.
10:51:26 <mm_freak> conal: it's not a new version of netwire, because builtin inhibition is gone
10:51:57 <nschoe> t4nk306, there's an online version here : http://book.realworldhaskell.org/read/ if you're interested.
10:52:38 <t4nk306> yeah i was checking out LYAH
10:52:43 <t4nk306> which do you think is better?
10:52:49 <t4nk306> RW or LYAH?
10:53:03 <dmwit> RWH and LYAH serve different purposes.
10:53:22 <t4nk306> i need to get familiar to grammar
10:53:27 <dmwit> LYAH is an introduction; RWH is a book about application and best practices.
10:53:29 <dmwit> ...I think.
10:53:35 <dmwit> I've never read either of them. =P
10:53:53 <nschoe> I agree with dmwit here.
10:54:08 <geekosaur> RWH is "now that you've learned Haskell from somewhere else, here's how you do useful things with it"
10:54:19 <mm_freak> i skimmed through both of them, and my impression was that both introduce haskell, but RWH is a little faster-paced and touches some advanced concepts
10:54:20 <t4nk306> what would you do if you had no idea about Haskell yet you have to start from somewhere
10:54:33 <nschoe> t4nk306, RWH will give you "deep" notions, while LYAH is somehow "easier" to follow at hte beginning.
10:54:40 <Peaker> Because monadic parsers make back-tracking somewhat expensive -- they encourage you to factor out common prefix-parsers outside. But those prefix-parsers are implementation details of these parsers, so this breaks modularity :(
10:54:41 <dmwit> t4nk306: I can tell you what I *did* do. =)
10:54:42 <mm_freak> t4nk306: try LYAH, and if it's too slow, move to RWH =)
10:54:55 <dmwit> t4nk306: And that was to read the Gentle Introduction. And I turned out fine, despite what everybody else here will tell you.
10:55:15 <t4nk306> woah thanks guys
10:55:21 <t4nk306> how do you even answer in red ?
10:55:23 <mm_freak> t4nk306: i would learn the basics and then write stuff =)
10:55:33 <mm_freak> in red?
10:55:43 <Peaker> t4nk306: that's your IRC client highlighting messages with your nick in them?
10:55:46 <t4nk306> you know your name is in red when you answer to me
10:55:58 <Yaniel> t4nk306: nick highlighting
10:56:09 <mm_freak> t4nk306: that's because of the "t4nk306: " =)
10:56:09 <t4nk306> how do you reply ?
10:56:14 <Yaniel> when someone mentions you the message is highlighted
10:56:16 <t4nk306> you write that?
10:56:16 <Twey> bernalex: http://lpaste.net/100524
10:56:20 <geekosaur> just mention the nick, clients highlight it
10:56:25 <geekosaur> it's built into most clients
10:56:26 <mm_freak> t4nk306: type "mm", then hit the tab key
10:56:44 <t4nk306> wow i am enlightened
10:56:50 <mm_freak> =)
10:56:58 <t4nk306> it's like *click* :P
10:57:03 <mm_freak> it's nothing magic, just saves you a few keystrokes =)
10:57:20 <t4nk306> i see people helping people
10:57:23 <nschoe> t4nk306, now go learn Haskell and write yourself an IRC client and implement nick highlighting :-)
10:57:24 <t4nk306> that's amazing
10:57:30 <t4nk306> nope
10:57:35 <t4nk306> i won't do that :)
10:57:38 <t4nk306> but i'll learn haskell
10:57:39 <nschoe> Why now ?
10:57:41 <nschoe> not*
10:57:49 <makalu> if I try to send a buffer (C-c C-l) in emacs' ghc mode to ghci I get a progress cursor and nothing happens. Any idea on how to debug?
10:57:54 <t4nk306> i have my own priorities :)
10:58:00 <makalu> really inconvenient
10:58:11 <t4nk306> am i interrupting anything herE?
10:58:20 <t4nk306> i have no idea what i am doing
10:58:20 <queBrew_> Hi, I am trying to finalize my first haskell project. I can build it using cabal, but it won´t link the executable. Do I have to specify something for that?
10:58:24 <mm_freak> t4nk306: no =)
10:58:36 <t4nk306> mm_freak: thank's dude
10:58:43 <t4nk306> mm_freak:  i get the hang of it :P
10:58:46 <Twey> makalu: I've noticed that sometimes that happens and I just need to kill the *haskell* buffer and try again (C-g to cancel the current attempt if you still have a progress cursor)
10:58:48 <luova> \quit
10:58:49 <dmwit> queBrew_: Perhaps you haven't put an "executable" block in your cabal file.
10:58:50 <t4nk306> mm_freak: way to go irc :p
10:58:53 <mm_freak> queBrew_: is it a library?
10:59:12 <mm_freak> t4nk306: good =)
10:59:18 <conal> mm_freak: if you write about wires (e.g., a blog post), please let me know.
10:59:26 <makalu> Twey: doesn't help unfortunately
10:59:29 <Kron> if you make a series of pattern matches that completely covers all possible values of a data type, will GHC replace the final one with no check?
10:59:39 <Kron> foo True = ...
10:59:42 <Kron> foo False = ...
10:59:52 <queBrew_> dmwit: No I have. looks like: executable pw  \n main-is: Main.hs
10:59:53 <Kron> that's slower than foo _ = ... in the second clause, right?
11:00:05 <queBrew_> mm_freak: no, executable.
11:00:13 <dmwit> Kron: No, it's not slower; it's the same.
11:00:25 <mm_freak> conal: i will
11:00:28 <dmwit> Kron: (in GHC)
11:00:29 <Kron> alright, so it knows when the final pattern match has to match so it won't make a comparison right?
11:00:39 <mm_freak> queBrew_: could you paste your cabal file?
11:00:40 <Twey> Kron: It has to check the constructor to determine that it's not True already
11:00:43 <Kron> just want to make sure, because replacing the final case with _ everywhere makes it so unreadable
11:00:45 <dmwit> queBrew_: And there's nothing in dist/build/pw after you "cabal build"?
11:00:46 <conal> mm_freak: :)
11:00:53 <mm_freak> queBrew_: http://lpaste.net/
11:00:59 <Kron> I assumed it would check the constructor for every pattern match
11:01:04 <Kron> so it would check again if it was False
11:01:07 <queBrew_> dmwit: yes there is.
11:01:15 <queBrew_> dmwit: all there
11:01:22 <dmwit> queBrew_: So what does "it won't link the executable" mean?
11:01:29 <Twey> Kron: Probably not; that would be daft, and GHC is quite smart
11:01:40 <Kron> gotcha
11:01:47 <queBrew_> dmwit: I was under the impression that it would link it to my bin.
11:01:53 <mm_freak> conal: i'm going to write a paper actually about this topological FRP…  the benefit is that it makes sense of 'changes' and of integration/derivatives in FRP
11:02:03 <makalu> what the heck. The fact that I hade a ~/.ghci file was at fault :S
11:02:05 <conal> mm_freak: wonderful
11:02:06 <dmwit> queBrew_: "cabal install" will put a copy of the executable in ~/.cabal/bin (by default).
11:02:22 <Twey> I'm just guessing, but it's probably a jump table indexed by the bit value of the constructor tag
11:02:28 <mm_freak> conal: because it always bothered me that integrals are so useful, but they don't make sense denotationally
11:02:41 <conal> mm_freak: me too!
11:02:53 <Twey> I'm not sure anybody knows for sure, after it's gone through all the different layers of GHC and LLVM optimization :þ
11:03:25 <mm_freak> conal: one minor goal is to get rid of "junk"
11:03:40 <conal> mm_freak: amen
11:04:14 <Kron> yeah and -Wall informs me of incomplete patterns too
11:04:18 <queBrew_> dmwit: so it won´t link anything to usr/bin?
11:04:20 <Kron> so it's clearly aware of pattern completeness
11:04:21 <Kron> as a concept
11:04:30 <dmwit> Twey, Kron: GHC has a cutoff (9 patterns, I think?) after which it switches from a linear lookup to a lookup table indexed by constructor.
11:04:45 <Twey> Yes, it is (though it's not very smart, there)
11:04:51 <dmwit> Twey, Kron: The cutoff was chosen by measuring how big the linear search had to be before it was slower than an indirect jump. =P
11:04:54 <Twey> dmwit: Ah, someone does know!  Thanks ☺
11:04:58 <mm_freak> conal: the basic idea is the same as heinrich's time argument to Behavior and Event
11:04:59 <Kron> faascinating!
11:05:00 <Twey> Heheh
11:05:04 <mm_freak> Behavior t a, Event t a
11:05:06 <Kron> so in large patterned functions
11:05:16 <Kron> it doesn't necessarily scan up->down and it just branches
11:05:19 <Kron> that's kinda interesting
11:05:20 <dmwit> queBrew_: link is the wrong word. And you can ask it to by modifying your ~/.cabal/config.
11:05:52 <dmwit> queBrew_: But I don't really recommend it. Instead add ~/.cabal/bin to your $PATH.
11:06:36 <t4nk306> hey guys me again
11:06:47 <t4nk306> i've been told by LYAH that i need text editor?
11:06:50 <queBrew_> dmwit: Thats what I want to do but on my *nix machine.
11:07:04 <t4nk306> what's that :)
11:07:21 <geekosaur> how do you normally create and edit files?
11:07:22 <mm_freak> t4nk306: a program that allows you to write text files
11:07:35 <t4nk306> mm_freak: what do you suggest?
11:07:42 <cizra> t4nk306: Windows? Notepad++ or Emacs
11:07:46 <mm_freak> t4nk306: my suggestion would be biased =)
11:07:47 <t4nk306> mm_freak: windoes
11:07:55 <t4nk306> cizra: windows
11:07:59 <geekosaur> windows comes with notepad (but I'd suggest at least notepad++), most unixlikes (e.g. linux) come with vim and often emacs
11:08:00 <t4nk306> mm_freak: biased?
11:08:12 <geekosaur> or there's stuff like sublime text
11:08:21 <cizra> t4nk306: Emacs works very well on Windwoes, has excellent support for Haskell, but might be a bit complex for newbies. Also, you'll need to remap Caps Lock to Ctrl to avoid breaking bones.
11:08:26 <mm_freak> t4nk306: editors are like religions…  your best bet is to try a few of them
11:08:45 <t4nk306> cizra: so for a beginner notepad++ is god?
11:08:48 <mm_freak> t4nk306: i use emacs myself, but it has a learning curve
11:08:50 <t4nk306> cizra: good*?
11:08:58 <t4nk306> mm_freak: oh no
11:09:00 <aleksejs_> speaking of editors: has anyone tried atom+haskell?
11:09:04 <t4nk306> mm_freak: that i can't do
11:09:10 <geekosaur> it's pretty good, yes
11:09:11 <mm_freak> t4nk306: so if you use emacs to learn haskell, you will be climbing two learning curves at the same time ;)
11:09:12 <t4nk306> mm_freak: i'm over my head with haskell already
11:09:20 <Yaniel> Notepad++ is quite good
11:09:20 <geekosaur> easy to use, does most of what you need
11:09:28 <cizra> t4nk306: It can create text files all right... Not sure if it's got any support, like syntax highlight, for Haskell.
11:09:34 <queBrew_> dmwit: Ok, thanks for clearing it up!
11:09:44 <nschoe> Aleksejs_ there was a discussion in reddit that went pretty hot about Atom. Seems like it's another Sublime-like.
11:09:44 <t4nk306> cizra: syntax highlighting is cool
11:09:45 <geekosaur> by the time you want something more capable you'll be in a better position to say what you want form it and therefore what to try next
11:09:51 <t4nk306> cizra: that i want :)
11:09:51 <nschoe> But I'd like to try, though.
11:10:00 <mm_freak> t4nk306: to be honest, you can just use notepad for your first steps…  editors come with some complexity and sometimes hide some useful details from you
11:10:16 <t4nk306> mm_freak: what is biased?
11:10:23 <t4nk306> mm_freak: you mentioned earlie
11:10:25 <t4nk306> mm_freak: r
11:10:33 <cizra> t4nk306: mm_freak's opinion on editors
11:10:38 <geekosaur> well, except notepad has a certain tendency to drop noise in the file (like a byte order mark)
11:10:43 <mm_freak> t4nk306: my opinion is biased, because i like emacs
11:10:52 <mm_freak> and i don't like vim…  others do the opposite
11:10:52 <makalu> what was the pragma to enable gadts?
11:11:01 <mm_freak> makalu: LANGUAGE GADTs
11:11:19 <makalu> thank you
11:11:38 * treehouse urinates on cizra's dick
11:12:04 <mm_freak> copumpkin: …
11:12:06 <t4nk306> woha
11:12:10 <t4nk306> what the hell
11:12:32 <k_89> can someone explain this : http://lpaste.net/100525
11:12:33 <t4nk306> mm_freak: i'll go for notepad++
11:12:40 <t4nk306> mm_freak: thanks again
11:12:46 <treehouse> t4nk306: mind your language please, there are rat babies in my room who can watch the screen.
11:12:54 <mm_freak> @where ops
11:12:54 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
11:12:56 <k_89> same function works if its type signature is defined in certain ways and doesn't when defined otherwise
11:12:59 --- mode: ChanServ set +o dcoutts
11:13:01 <t4nk306> treehouse: rat babies huh
11:13:05 --- mode: ChanServ set +o edwardk
11:13:07 <treehouse> dcoutts: count
11:13:11 <t4nk306> treehouse: that's deep
11:13:15 <treehouse> dcoutts, edwardk: cunt
11:13:19 --- mode: edwardk set +b *!~schmeidth@gateway/tor-sasl/schmeidth
11:13:19 <shapr> ban treehouse please?
11:13:21 --- kick: treehouse was kicked by edwardk (Your behavior is not conducive to the desired environment.)
11:13:23 <shapr> thank you
11:13:29 <mm_freak> thanks =)
11:13:36 <t4nk306> way to go
11:13:36 <geekosaur> wtf
11:13:46 <dcoutts> weird
11:13:47 --- mode: ChanServ set -o dcoutts
11:13:54 <shapr> he got banned from #haskell-blah yesterday
11:14:01 <edwardk> shapr: heh took me a moment for my targeting to come online, fortunately the target highlighted himself by talking to me ;)
11:14:06 <shapr> heh :-)
11:14:12 <nschoe> Weird guys...
11:14:13 <mm_freak> k_89: 'let' and 'in', if on different lines, have to line up
11:14:14 <zalzane> #haskell-drama
11:14:19 <geekosaur> k_89: either you specify the entire type signature incliuding constraints, or let the whole thing be inferred
11:14:45 <BMeph> shapr: Any reason why you didn't do so yourself? :)
11:14:51 <geekosaur> using (<) without an Ord constraint in scope is a type error
11:14:58 <k_89> okay
11:15:03 <shapr> BMeph: my targeting computer is slow
11:15:03 <geekosaur> the constraint is not optional
11:15:13 <k_89> thanks
11:15:14 <geekosaur> (in fact, it looks like a parameter for a reason: it is one)
11:15:28 <edwardk> BMeph: he'd have to remember how to IRC ;)
11:15:37 <BMeph> shapr: Aah...carry on, Son of Eris. ;)
11:15:38 <geekosaur> "you must also pass this function a dictionary telling it which instance of (<) to use"
11:15:51 <xintron> Is there any way of removing a cabal installed package and all it's dependencies?
11:16:07 <mm_freak> k_89: oh, ignore me
11:16:14 <mm_freak> i was wrong =)
11:16:18 <k_89> hehe
11:17:06 <geekosaur> also, Num is a typeclass, that is to say, a constraint. you can't use it as a type
11:17:10 <shapr> BMeph: :-)
11:17:25 <geekosaur> it's not a type, it's a collection of functions that can be used on various types
11:19:26 <joelteon> is there a library that provides a data structure that's like a probability-weighted map?
11:19:50 <mm_freak> joelteon: you mean like Map k (Double, a)?
11:19:57 <joelteon> well, kind of
11:20:11 <joelteon> like, you insert 1, 2, 2, 2, 3, 3
11:20:23 <joelteon> then lookups will find 1 1/6 of the time, 2 half the time, etc.
11:20:29 <joelteon> obviously provide a RandomGen
11:20:38 <joelteon> or you can get a summary of the probabilities of all the elements
11:20:46 <joelteon> maybe I should just do it myself
11:20:47 <haasn> edwardk: is there something like a comonad that gives you extent but not extract? Specifically, I want comonad-like extract for [a] but there obviously can't be an extract :: [a] -> a
11:20:58 <mm_freak> joelteon: ah…  i've used Seq (a, Double) for that
11:21:08 <mm_freak> joelteon: but i constructed it from Map a Int
11:21:08 <edwardk> Data.Functor.Extend
11:21:21 <joelteon> ok I think i'll do that
11:21:28 <mm_freak> joelteon: there is also IntervalMap
11:21:29 <edwardk> that provides a notion of a 'semicomonad' as the Extend class
11:21:35 <mm_freak> joelteon: on hackage
11:21:49 <haasn> edwardk: thanks
11:21:51 <haasn> edwardk: that's perfect
11:21:53 <zomg> edwardk: how many words have you guys made up to make programming more interesting?
11:21:56 <zomg> every time I look here
11:21:57 <Grant__> If you change data-dir and whatnot in cabal, does it go back and cleanup old directories it made?
11:21:59 <zomg> now semicomonad
11:21:59 <zomg> :D
11:22:15 <edwardk> zomg: not my name. i just appropriated it =)
11:22:27 <edwardk> Extend is my name. wish i'd just used Semicomonad instead ;)
11:22:32 <zomg> heh
11:23:24 <edwardk> anyways it is borrowed from a rather obscure branch of category theory where you care about things that aren't quite categories
11:24:24 <k_89> question : when does (..) behave like a tuple, and when does it not
11:24:24 <k_89> ?
11:24:31 <haasn> edwardk: is that a strong lax semi-comonoidal endofunctor? :)
11:24:34 <edwardk> a 'category' without identity arrows can be called a semicategory, or in som circles the small ones can be called semigroupoids, as it is the 'oidification' of a semigroup when everything is small enough to be made out of sets.
11:24:46 <darthdeus> what's the easiest way to make a string by repeating certain character N times?
11:24:55 <geekosaur> :t replicate
11:24:56 <lambdabot> Int -> a -> [a]
11:25:00 <darthdeus> thanks :X
11:25:18 <k_89> oh
11:25:20 <geekosaur> k_89: a tuple has comma-separated expressions.
11:25:26 <edwardk> the functors between them don't have identities to deal with, so they are just 'semifunctors', but without identities, the Yoneda lemma doesn't make sense, adjoints aren't unique, all sorts of things break down
11:25:28 <k_89> a tuple with just one value is the value itself
11:25:33 <geekosaur> there is no 1-tuple so (expr) is just grouping
11:25:39 <k_89> okay
11:25:41 <geekosaur> (for precedence)
11:25:45 <edwardk> on the other hand, there are a lot more of them to play with
11:26:09 <edwardk> a semimonad has a kleisli category that is just a semicategory, (no return)
11:26:48 <edwardk> and is given rise to by a semiadjunction, but since semiadjunctions aren't unique there are possibly many such semimonads.
11:27:19 <edwardk> zomg: i'll be quiet now as i think i just made your case for you ')
11:27:25 <zomg> haha
11:27:47 <zomg> I'm sure someone has a use for it
11:28:00 <zomg> I just don't do that much haskell yet so it just sounds scary
11:28:00 <zomg> hehe
11:28:12 <haasn> I think that sounds scary to nearly every haskell programmer
11:28:34 <haasn> and this has little to do with haskell, also
11:28:46 <haasn> haskell isn't formally based on category theory let alone semicategory theory
11:28:59 <haasn> rather, you can use category theory to model some aspects of haskell
11:29:05 <haasn> but you can use category theory to model a lot of things.
11:29:09 <haasn> including some aspects of C#
11:29:30 <mm_freak> zomg: you found functors scary before you started with haskell, and likely you have used them in other languages before =)
11:29:30 <zipper> I'm having an issue importing the Writer w a type from Control.Monad.Writer. I code copied and pasted from LYAH that still fails with Control.Monad.Writer at https://gist.github.com/urbanslug/9277883
11:29:45 <shergill> there has to be an easier naming convention than what we've got going on
11:29:47 <zomg> mm_freak: yeah dem fancy words =)
11:30:18 <geekosaur> hemidemisemicohypermonadoid
11:30:18 <haasn> zipper: that is because Writer doesn't exist as a constructor in ‘transformers’
11:30:20 <mm_freak> zomg: the thing is, the words are necessary =)
11:30:31 <haasn> zipper: use ‘writer’ (lower case)
11:30:33 <zomg> mm_freak: yeah
11:30:37 <shergill> well easier for those unfamiliar with what kleisli this or yoneda that is
11:31:01 <haasn> zomg: (or use monad abstractions eg. logNumber x = x <$ tell ["Got number: " ++ show x])
11:31:09 <haasn> s/zomg/zipper/
11:32:35 <zipper> I hope the writer of the book could fix that. :(
11:33:02 <BMeph> That reminds me of some computer-related subjects blogger that was going on about how naming things after the persons related to their discovery or use, is bad, and that we should just call such things by a description of the phenomenon directly.
11:33:31 <geekosaur> if this is lyah, we've been trying to get in contact with the author for a while :(
11:34:16 <mm_freak> BMeph: the funny thing is that category theory doesn't make as much use of that naming convention as other models
11:34:26 <mm_freak> yet i can't think of a better word than "monad"
11:34:32 <zipper> haasn: Transformers?
11:34:43 <mm_freak> perhaps because the descriptive name would probably have to cite the laws
11:35:11 <BMeph> All I remember about him, was that 1) He was not impressed with the name "currying"; 2) he is a "he"; 3) he is Chinese; 4) he isn't nearly as persuasive, entertaining, informative or non-pretentious, as monochrom is.
11:35:34 <klrr_> i dont think name is actually something that makes stuff harder to undertsand, but since haskell got scary-soundy names then automatically you think that's the cause of not understanding
11:35:54 <monochrom> \∩/
11:36:06 <klrr_> i can do that sometimes at least , even though i know names itself are not the cause of me not understanding
11:36:25 <haasn> zipper: oh, Writer is imported from Control.Monad.Writer, which is a module in the package mtl; it re-exports Writer from Control.Monad.Trans.Writer, which is a module in the package transformers
11:36:26 <zomg> the names just make things sound weird to the unfamiliar I think =)
11:36:26 <zipper> Ok maybe I have short memory but the error I got involved data contructors yet all I know of are value and type constructors.
11:36:40 <haasn> zipper: http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-Writer-Lazy.html#g:1
11:36:41 <zomg> at least whenever I mention some haskell-buzzword to someone who hasn't done any haskell that's kinda the reaction I get..
11:36:44 <zomg> :D
11:36:52 <klrr_> zomg: that's my point, since they sound weird you blame the words instead of yourself, i do that sometimes
11:36:52 <haasn> zipper: “data constructor” here means “value constructor”
11:36:56 <haasn> zipper: the former is the correct term for them
11:37:13 <hellwolf> hi, is there a reason behind haskell not allowing "let a = length . take"?
11:37:14 <astropirate> zomg, you stalking me accross freenode?
11:37:35 <zomg> wait, who? me?
11:37:37 <geekosaur> hellwolf: "not allowing" how or where?
11:37:46 <astropirate> yes
11:37:51 <zomg> noo.. that's not possible
11:37:52 <geekosaur> (either you're trying to use it in a file at top level, or you ran into the DMR)
11:37:57 <haasn> hellwolf: the syntax for let/in is “let name = <expr> in <expr>” where <expr> is some expression
11:37:58 <hellwolf> geal, ghc shows me no
11:37:59 <zomg> *calls for backup*
11:38:12 * hackagebot hblas 0.1.0.0 - BLAS and Lapack bindings for OpenBLAS  http://hackage.haskell.org/package/hblas-0.1.0.0 (CarterSchonwald)
11:38:21 <haasn> Oh, that said; length . take is a type error
11:38:23 <haasn> :t length . take
11:38:24 <lambdabot>     Couldn't match type `[a1] -> [a1]' with `[a0]'
11:38:24 <lambdabot>     Expected type: Int -> [a0]
11:38:24 <lambdabot>       Actual type: Int -> [a1] -> [a1]
11:38:32 <hellwolf> haasn, I use let just because I was using ghci.
11:38:39 <haasn> take :: Int -> ([a] -> [a]) returns a function from lists to lists
11:38:46 <haasn> and length :: [a] -> Int  expects a list
11:38:47 <geekosaur> that's a special syntax for ghci and for inside "do"
11:38:55 <geekosaur> at a top level you just say "a = whatever"
11:38:55 <geal> hellwolf: ghc is always true. Praise ghc
11:39:01 <geal> now what was the question again?
11:39:02 <haasn> GHC tries to match the [a] that “length” expects with the “Int -> [a]” that “take” returns
11:39:21 <haasn> hellwolf: you may have meant something like \n -> length . take n
11:39:25 <haasn> :t \n -> length . take n
11:39:26 <lambdabot> Int -> [a] -> Int
11:39:38 <geekosaur> because with ghci, if you don't specify otherwise with some keyword then it evaluates an expression
11:39:52 <haasn> (equivalent to “max 0”, I think)
11:40:52 <hellwolf> haasn, ah, good one, but why would ghc would not figure out that? Am I missing something, I mean when I look (length . take) myself,  I was thinkin gof  a shorthand to length(take ...)
11:41:18 <BMeph> haasn: more like "min n" isn't it? :)
11:41:46 <haasn> hellwolf: they are not the same thing; the definition of (.) is:  (f . g) x = f (g x);  so if you have something like  (length . take) n xs you get length (take n) xs
11:41:48 <haasn> not length (take n xs)
11:41:53 <haasn> and ‘take n’ returns a function, not a list
11:42:00 <haasn> on the other hand
11:42:13 <haasn> (\n -> length . take n) n xs is (length . take n) xs is length (take n xs)
11:42:37 <hellwolf> :t take
11:42:38 <lambdabot> Int -> [a] -> [a]
11:42:51 <Grant__> Which should be preferred: (flip f) y, or `f` y
11:42:52 <BMeph> hellwolf: GHC is not a social worker. It does not construct an expression to make what you say make sense. It only works with what you actually type in. (for Some Values Of "actually", to be more honest.)
11:43:08 <haasn> Grant__: f ?? y   ;)
11:43:18 <shachaf> Grant__: I prefer (`f` y) whenever it makes sense to use f infix.
11:43:22 <Grant__> Didn't know about ?? thanks
11:43:27 <Grant__> :t ??
11:43:27 <lambdabot> parse error on input `??'
11:43:32 <shachaf> I prefer (\x -> f x y) to (flip f y)
11:43:33 <Grant__> :t (??)
11:43:34 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:43:35 <haasn> (that was not entirely serious, for ?? you need to import ‘lens’ which is probably not what you want)
11:43:41 <Grant__> Oh ok
11:43:42 <bennofs> (??) is from lens though
11:43:46 <haasn> Just use (`f` y)
11:43:48 <haasn> I don't like flip either
11:44:08 <mm_freak_> i prefer flip
11:44:12 <Grant__> ?? Is a neat operator, though
11:44:13 <lambdabot>  Is a neat operator, though
11:44:18 <mm_freak_> and i don't like "just do" suggestions ;)
11:44:20 <haasn> What just happened there?
11:44:33 <haasn> ?? is this like @@?
11:44:33 <lambdabot> Plugin `compose' failed with: Unknown command: "@?"
11:44:40 <haasn> Indeed it seems to be
11:44:58 <haasn> Oh right, ? is a valid control character in addition to @
11:45:41 <Grant__> The reason I ask is because I have generally been coding haskell in a vacuum so I didn't know if there was a community preferred idiom
11:46:51 <zett_zelett> Something unrelated for native speakers: Does the term "mother language" for mother tongue seem right to you?
11:47:13 <Grant__> No
11:47:15 <johnw> not quite
11:47:19 <Grant__> "First language" or "mother tongue"
11:47:21 <Grant__> not a combo
11:47:24 <monochrom> «flip (if b then f else g) y» cannot be written as «`if b then f else g` y»
11:48:13 * hackagebot utility-ht 0.0.10 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.10 (HenningThielemann)
11:50:51 <Shockk> hello, I was wondering if there's any exposed interface in the Network.Socket module (part of network package) to manually pack and set a socket options, if I want to set an option which isn't one of the defined SocketOption constructors? -- such as TCP_DEFER_ACCEPT which would be packed as Just ((6), (9))
11:52:45 <cariveri> hey: whats wrong with this?:instance (Eq b) => Eq (Tree (a,b)) where \    (Node (_,nid1) _) == (Node (_,nid2) _) = (nid1 == nid2)
11:53:14 * hackagebot check-pvp 0.0 - Check whether module and package imports conform to the PVP  http://hackage.haskell.org/package/check-pvp-0.0 (HenningThielemann)
11:53:36 <Cale> cariveri: Apart from the fact that it doesn't define a total ordering?
11:54:48 <cariveri> Cale: waht do you mean? Ord b isnt necessary I think
11:55:08 <Cale> oh, sorry, lol
11:55:14 <monochrom> it is a very coarse equivalence relation
11:55:34 <Cale> Yeah, I somehow thought of a similar thing for Ord in my head :)
11:55:42 <monochrom> it is wrong or right depending on what is externally observable about your trees
11:56:14 <monochrom> in fact, every question about "what is equality?" depends on it.
11:56:20 <cariveri> monochrom: ghc gives me: Illegal instance declaration for `Eq (Tree (a, b))'
11:56:35 <joelteon> Is there a data structure that's a map both from keys to values and the values to their keys?
11:56:39 <darthdeus> how do i append to a list? something like [a] -> a -> [a], but I can't find it via hoogle
11:56:46 <joelteon> like a bijective map!
11:56:46 <monochrom> ok then you have a more shallow error
11:56:47 <Cale> cariveri: Oh, well, instances like that require FlexibleInstances
11:57:08 <Cale> cariveri: The error message should have told you this :)
11:57:20 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #9 :)
11:57:35 <Cale> darthdeus: to the end?
11:57:59 <cariveri> Cale: yes it did, but ... this doesnt seem right to do.
11:58:11 <Cale> darthdeus: Usually that's written like (++ [x]), but this is a terrible operation if you're going to be doing it repeatedly
11:58:30 <cariveri> Cale:  I jsut want to make two trees compareable, which have a comparable value.
11:58:44 <Cale> cariveri: Haskell 98 (and hence 2010 since it didn't change much) is very restrictive about which instances it allows.
11:59:05 <Cale> cariveri: In particular, instances can only be defined for a type constructor T applied to a sequence of distinct type variables
11:59:18 <Cale> like T a1 a2 .. an
11:59:50 <Cale> So, one type at a time.
12:00:16 <Cale> cariveri: However, I wouldn't define an instance of Eq for a comparison like that
12:00:16 <cariveri> Cale: wait. I dont understand. where did I violate that form?
12:00:26 <Cale> Your instance is for Tree (a,b)
12:00:31 <Cale> not  Tree a
12:00:45 <Cale> i.e. it involves two type constructors, Tree and (,)
12:00:50 <monochrom> written in prefix notation, Tree ((,) a b). the form is T1 (T2 a b)
12:01:09 <cariveri> ok that makes sens
12:01:16 <joe9> any emacs flycheck users here? Would you mind sharing your configuration? I cannot get it to work.
12:01:26 <cariveri> so I need to make an instance for (,) ?
12:01:36 <cariveri> Eq (a,b)
12:01:42 <monochrom> you can't. it is already written.
12:01:46 <Cale> cariveri: This is a ridiculous restriction which I think even at the time that Haskell 98 was specified the compilers could already do more.
12:02:11 <Cale> But type classes were relatively new at the time, and so they were specified in a very conservative fashion
12:02:59 <monochrom> I don't agree that it is ridiculous. then again, you will catch me saying things like "C does not allow nested function definitions, that's ridiculous"
12:03:12 <Cale> The answer is just to turn on FlexibleInstances (which actually wasn't a named extension at all for a long time, until someone pointed out that GHC wasn't following the standard to the letter here)
12:03:17 <cariveri> ok. guess I need to work aroudn that. I actually wanted to use t `elem` ts which relies on Eq t1.
12:04:15 <Cale> monochrom: Well, okay, it *does* make implementation of instance resolution dead simple.
12:04:39 <Cale> cariveri: What are you actually trying to do?
12:04:49 <Cale> cariveri: Maybe you really want 'any'?
12:05:03 <Cale> :t any
12:05:04 <lambdabot> (a -> Bool) -> [a] -> Bool
12:05:39 <darthdeus> Cale: thanks, I'm only doing the append on a small case and just once
12:05:43 <Cale> :t any ((== 5) . rootLabel)
12:05:44 <lambdabot> (Eq b, Num b) => [Tree b] -> Bool
12:06:04 <Cale> cariveri: ^^ something like that maybe?
12:06:29 <cariveri> Cale: I want to check whether a Tree is in a lsit of Trees.
12:06:47 <Cale> cariveri: Yeah, but your instance of Eq only tested (part of) the root label of the tree
12:06:49 <cariveri> where Trees are equivalent by an id stored in the node
12:06:52 <Cale> which isn't enough at all!
12:06:55 <mm_freak> i wonder why FlexibleContexts and FlexibleInstances aren't standard
12:07:01 <cariveri> Cale: yes it is! :)
12:07:06 <mm_freak> they are very useful and don't seem to have any negative effect
12:07:06 <bakibour> Greetings
12:07:17 <mm_freak> hi there bakibour
12:07:17 <dmwit> It sounds like carivari wants a fast-path equality check by ID.
12:07:17 <Cale> mm_freak: For exactly the reason I stated
12:07:33 <dmwit> It's a common request, and pretty reasonable. Just don't name that fast-path check (==).
12:07:42 <Cale> cariveri: It's an abuse of Eq to do that kind of testing
12:08:03 <Cale> You should define an operation which compares the IDs in the root, and then use any :)
12:08:07 <geekosaur> the standards folks are afraid if they add that they're scare away even more implementers. not that there are many implementers to scare away
12:08:38 <mm_freak> Cale: we had the opportunity to standardize them for h2010…  i wonder why that didn't happen
12:08:59 <dmwit> H2010 was a pretty conservative step from H98.
12:09:03 * dmwit shrugs
12:09:20 <dmwit> Push for a H2015; maybe you can convince people to make it less conservative this time. =)
12:09:27 <geekosaur> hah
12:09:40 <bakibour> In Haskell you can not have one type class bound to the same type because you have local ... but if you had first class modules you could because you then have global ... , i can not remember what that ... is called again i have something like confluence on the tip of my tongue with apperently is totally false.
12:09:57 <Cale> mm_freak: Well, have you looked at what changes H2010 actually includes? It's like... they just folded the official addenda to the Haskell Report in (FFI and Hierarchical modules), and then threw in a handful of questionable things like DoAndIfThenElse
12:10:12 <mm_freak> it's still weird that PatternGuards made it, but ViewPatterns did not…  EmptyDataDecls made it, but Flexible* did not
12:10:14 <Cale> Oh, and I guess PatternGuards?
12:10:24 <Cale> PatternGuards are cool
12:10:49 <mm_freak> Cale: of course, but every time i use a pattern guard, i say to myself: "this would be so much nicer with a view pattern"
12:10:57 <geekosaur> bakibour, I am not sure what you're trying to say there
12:11:01 <mm_freak> and sometimes i can't resist and turn them on
12:11:13 <TankDude27> mm_freak: hey
12:11:18 <geekosaur> instances are global so you can have only one implementation of a given typeclass for a given type
12:11:21 <Cale> mm_freak: I don't!
12:11:24 <mm_freak> hi TankDude27
12:11:27 <TankDude27> mm_freak: i was tank306 :)
12:11:27 <bakibour> geekosaur: The type system can either just have one instance of something or several instances in different scopes.
12:11:32 <mm_freak> TankDude27: i know =)
12:11:36 <TankDude27> mm_freak: how come?
12:11:42 <Cale> mm_freak: For the most part, I use PatternGuards in the presence of GADTs and fancy type hackery though
12:12:08 <Cale> mm_freak: They're nice if you have a lot of constraints that get unpacked by matching on certain constructors
12:12:17 <Cale> and you have nested matching going on to do it
12:12:17 <mm_freak> Cale: what bothers me about pattern guards is that they usually introduce unnecessary intermediate names
12:12:23 <mm_freak> Cale: and they are a lot more noisy in general
12:12:38 <mm_freak> TankDude27: your hostname did not change, so i just assumed =)
12:12:47 <Actreka> Does anyone know why this "map (^2) [1,3..]" faster than this "[n^2 | n<-[1,3..]]"?
12:12:48 <Cale> I always break the line before starting a chain of pattern guards
12:12:57 <Cale> and usually line them up vertically
12:12:57 <bakibour_> Meh got dced.
12:13:09 <TankDude27> mm_freak: so i was working this notepad++ and once i write functions i have to save it and load it from ghci to manipulate that func right?
12:13:13 <enthropy> mm_freak: I think the only reason is because ViewPatterns is far newer?
12:13:18 <mm_freak> Actreka: it shouldn't be
12:13:22 <Cale> Actreka: That's surprising. I'd expect them to compile to the same thing.
12:13:38 <Cale> Actreka: Do you have optimisations turned on?
12:13:46 <bennofs> @karma notepad
12:13:46 <lambdabot> notepad has a karma of 63
12:13:47 <enthropy> also that extension might be a bit less clear about how many times the function gets evaluated
12:13:53 <Actreka> Cale: I tried it in the ghci
12:13:57 <geekosaur> ghci doesn't do optimization
12:14:18 <Actreka> So if I compiled it, it should be equally fast?
12:14:20 <Cale> yes
12:14:30 <enthropy> > case 1 of (odd -> True) | False -> 0; (odd -> True) | True -> 1
12:14:31 <Actreka> Oh ok, my bad
12:14:32 <lambdabot>  1
12:14:35 <cariveri> Cale: okay. replaced  `elem` and the instance of Eq with any and myEqualMethodForTreesWhichShouldBeTrivial
12:14:36 <Twey> enthropy: Aren't ViewPatterns older?
12:14:37 <Cale> I would be pretty surprised if the code generated was different at all.
12:14:40 <mm_freak> Actreka: i suppose the latter is translated to something like this:  concatMap (\n -> [n^2]) [1, 3..]
12:14:43 <enthropy> how many times does odd get evaluated?
12:14:49 <mm_freak> Actreka: with optimizations turned off this might actually be slower
12:14:53 <Cale> cariveri: :D
12:14:55 <Twey> I heard about them before PatternGuards, I think
12:14:59 <enthropy> Twey: not at all
12:15:11 <dmwit> Actreka: I do not observe the first being faster than the second.
12:15:36 <TankDude27> mm_freak: hear my cry for help :p
12:15:40 <dmwit> Actreka: I observe 3.30s vs 3.33s for the first 1.5e8 terms -- probably just measurement error.
12:15:51 <Actreka> dmwit: I tried this in ghci: "sum $ takeWhile (<100000000000000) (map (^2) [1,3..])" compared to "sum $ takeWhile (<100000000000000) [n^2 | n<-[1,3..]]"
12:16:01 <mm_freak> TankDude27: sorry =)
12:16:10 <Actreka> dmwit: got about 2 seconds difference
12:16:11 <dmwit> Actreka: ghci is not a reliable measure of speed.
12:16:11 <TankDude27> mm_freak:  no worries
12:16:13 <mm_freak> TankDude27: you load it into GHCi, but manipulation you still do in the text editor
12:16:22 <mm_freak> TankDude27: although GHCi can fire up your text editor for you
12:16:23 <TankDude27> mm_freak: i have to save it right?
12:16:27 <mm_freak> TankDude27: yes
12:16:35 <Actreka> What should I use to measure the speed?
12:16:44 <dmwit> Actreka: ghci is built to go from text to execution fast; it is not built to make the execution itself fast.
12:16:47 <mm_freak> Actreka: a compiled program at the very least
12:16:49 <TankDude27> mm_freak: thanks ^^
12:16:49 <dmwit> Actreka: Use ghc -O2.
12:17:07 <enthropy> http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/release-6-10-1.html
12:17:17 <mm_freak> Actreka: for precise measurement you can use criterion…  for just a rough comparison using 'time' on your shell is sufficient
12:17:17 <monochrom> 6.10 is very old!
12:17:34 <zipper> @src Control.Monad.Writer.runWriter
12:17:34 <lambdabot> Source not found.
12:17:45 <Actreka> mm_freak: How rough do you recon using time is?
12:17:45 <enthropy> "The new ViewPatterns language extension"
12:17:46 <ReinH> mm_freak: When I learned of :e in GHCi I was very happy :)
12:18:08 <monochrom> sorry, what is :e again?
12:18:14 <ReinH> open in $EDITOR
12:18:14 <enthropy> open in editor
12:18:18 <zipper> ReinH: What does it do?
12:18:20 <monochrom> ah, that one
12:18:22 <mm_freak> Actreka: usually just a few milliseconds
12:18:28 <ReinH> zipper: it opens your module in your editor
12:18:33 <mm_freak> Actreka: but you have to run your benchmark multiple times manually
12:19:36 --- mode: ChanServ set +o milfjord
12:19:36 --- mode: milfjord set -b+b *!~schmeidth@gateway/tor-sasl/schmeidth $a:Schmeidth
12:19:56 <mm_freak> ReinH: now that you said that i come to the conclusion that emacs and vim are dual
12:20:11 <ReinH> mm_freak: in some deep categorical sense?
12:20:14 <mm_freak> emacs → ghci → vim
12:20:18 <ReinH> ha
12:20:32 <ReinH> I still can't run IRC in vim though
12:20:37 <ReinH> well, maybe I could. But I don't.
12:21:03 <mm_freak> i'm one of the very few who use emacs as an actual text editor =)
12:21:11 <Twey> http://www.vim.org/scripts/script.php?script_id=931
12:21:13 <ReinH> Heh
12:21:14 <mm_freak> so i have irssi for IRC ;)
12:21:19 * Twey too
12:21:22 <Actreka> I use irssi too :)
12:21:23 <ReinH> mm_freak: so my "math for rubyists" talk is now almost entirely about monoids.
12:21:24 <Twey> WeeChat though.
12:21:30 <ReinH> Actreka: me three
12:21:37 --- mode: milfjord set -o milfjord
12:21:40 <mm_freak> ReinH: nice
12:21:48 <zipper> ReinH: This failed ":e Control.Monad.Writer"
12:22:06 <mm_freak> ReinH: from monoids to categories isn't a very huge step…  just draw monoids the right way =)
12:22:07 <ReinH> zipper: :e opens your current module
12:22:14 <mm_freak> a circle with arrows pointing back to it
12:22:18 <ReinH> mm_freak: and a bit of equational reasoning, but I have to wave my hands *really* fast to get through that part.
12:22:31 <ReinH> mm_freak: right, the one-object category
12:22:35 <ReinH> might could do
12:22:39 <hellwolf> what does this mean: No instance for (Fractional Integer) arising from a use of `/'. I was typing "a / 2" in ghci, and I let a = 2
12:22:51 <milfjord> hellwolf: you can't use / with integers
12:23:16 <ReinH> mm_freak: and interestingly that looks enough like the state diagram for the kleene star (say, [ab]*), that I might be able to make some connection there
12:23:17 <monochrom> consider "div a 2"
12:23:24 <hellwolf> let a = 2 in a / 2 would work though?
12:23:32 <milfjord> yes, a is a Double there
12:23:39 <mm_freak> ReinH: when i introduce monoids in my workshops, some people already know them, and they are very confused by my visualization…  i just say, "don't worry, the reason for that will become clear soon" =)
12:23:46 <geekosaur> it can work if haskell can infer you meant a Double
12:23:48 <mm_freak> and then i introduce categories
12:23:50 <ReinH> mm_freak: oh you do workshops? What kind of workshops?
12:23:54 <geekosaur> this means numeric literals in particular places
12:24:00 <ReinH> mm_freak: I think I like this idea
12:24:01 <mm_freak> ReinH: mostly cryptography, sometimes haskell
12:24:05 <ReinH> mm_freak: nice :)
12:24:11 <ReinH> mm_freak: so monoids for crypto?
12:24:17 <mm_freak> yes
12:24:17 <ReinH> mm_freak: like running hashes or?
12:24:26 <hellwolf> thanks for the help guys, it's really helpful here even I am sure it's really newbie question
12:24:32 <mm_freak> ReinH: groups are important for crypto
12:24:37 <ReinH> hellwolf: newbie questions are great :)
12:24:49 <ReinH> mm_freak: right, but what can you do with monoids aside from make groups? ;)
12:25:04 <mm_freak> ReinH: build an abstraction step by step
12:25:06 <BMeph> Newbiw answers are the Best answers! ;)
12:25:11 <mm_freak> ReinH: don't start with complexity =)
12:25:18 <ReinH> mm_freak: :)
12:25:20 * BMeph sighs
12:27:00 <mm_freak> ReinH: the funny thing is that i never build up to monads…  i introduce them as a side effect =)
12:27:18 <mm_freak> usually after explaining folds, maps and concat-maps
12:27:19 <monochrom> hahaha
12:27:54 <Actreka> When I'm using GHCi and do :l haskellfile.hs, does it compile the file, any optimizations?
12:28:04 <milfjord> no
12:28:27 <monochrom> not optimized, and largely interpreted
12:28:29 <ReinH> mm_freak: awesome, sounds a lot like what I'm doing.
12:28:36 <ReinH> mm_freak: I'm not sure I'm going to get to monoids though
12:28:42 <ReinH> er monads
12:28:56 <Actreka> Is it possible to import a haskell binary into GHCi to test?
12:29:19 <monochrom> yes. the GHC user's guide chapter 2 says it all. I'm too lazy to copy-paste it here.
12:29:33 <Actreka> monochrom: Thank you, I'll look there
12:29:36 <monochrom> the GHC user's guide is very likely somewhere on your hard disk already
12:29:36 <mm_freak> ReinH: i didn't really find it useful to introduce them outside of the context of haskell
12:29:54 <ReinH> mm_freak: yeah...
12:30:20 <ReinH> mm_freak: why do you talk about concat-maps?
12:31:14 <mm_freak> ReinH: because the concept of concat-maps is very useful
12:31:27 <ReinH> mm_freak: what particularly motivates them for your workshops?
12:31:32 <darthdeus> is there a function that for positive numbers returns the number, and for <= 0 returns 0?
12:31:40 <mm_freak> ReinH: "if you want to continue …"
12:31:49 <mm_freak> ReinH: i usually introduce them in the context of Maybe, then []
12:33:06 <mm_freak> darthdeus: max 0
12:33:28 <mm_freak> > map (max 0) [-3..3]
12:33:30 <lambdabot>  [0,0,0,0,1,2,3]
12:33:46 <nadirs> mm_freak: nice
12:33:46 <monochrom> concat-map is useful whenever you sequentially compose functions that give multiple answers. you have to interleave application and flattening
12:33:49 <hellwolf> how can I keep taking 2 elements from a [()] and form a new [((), ())]?
12:34:11 <johnw> map (join (,))
12:34:13 <milfjord> chunksOf 2
12:34:17 <johnw> ah, or that
12:34:26 <nadirs> hellwolf: is that a list of bottoms?
12:34:40 <darthdeus> mm_freak: nice
12:34:42 <darthdeus> mm_freak: thanks
12:34:45 <nadirs> hellwolf: how does it work?
12:34:49 <monochrom> chunksOf is in Data.List.Split, package name "split". it is in the Haskell Platform
12:35:09 <mm_freak> > let chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunksOf 3 ['a'..'z']
12:35:10 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
12:35:31 <mm_freak> but yeah, Data.List.Split defines it
12:35:39 <hellwolf> nadirs, not sure I understand what you mean. I would like to take [1, 2, 3, 4...] -> [(1, 2), (3, 4)]
12:36:04 <hellwolf> or [1, 2, 3, 4..] -> [(1,2),(2,3)..] roo
12:36:18 <hellwolf> chunksOf 2 can solve the first one I think
12:36:18 <mm_freak> hellwolf: if you want tuples, you'll have to write the function yourself
12:36:43 <mm_freak> hellwolf: rethink whether you want that restriction, particularly because it isn't well-defined at the end
12:36:51 <monochrom> begin with chunksOf to get [ [1,2], [3,4] ] first anyway. post-process it to make tuples
12:36:54 <ReinH> monochrom: Right, I'm familiar with [] as a "choice" monad.
12:37:07 <mm_freak> monochrom: boolean blindness alarm!
12:37:17 <mm_freak> i'd write that function myself just to avoid that =)
12:37:32 <hellwolf> oh, sorry for my loose typing, a list would be fine, I didn't want to mean tuple. But maybe tuple is good to be used here too?
12:37:57 <mm_freak> hellwolf: if you want a guarantee that there are always two elements, then tuples are the right way to go
12:37:58 <monochrom> I don't know because I don't know what you use it for
12:38:04 <ReinH> hellwolf: it depends on what you're doing
12:38:16 <mm_freak> hellwolf: if you can deal with arbitrarily long sublists, then chunksOf is fine
12:38:18 <nadirs> hellwolf: I'm quite a beginner but I saw the () and immediately thought of _|_ (bottom) so I interpreted [()] as a list of _|_ values, while instead you probably meant something like [a]. Does it make sense?
12:38:28 <hellwolf> ok, I'm learning haskell, so I'm writing a funciton generate a list of twin primes
12:38:41 <haasn> nadirs: () has no more to do with _|_ than Int has to do with _|_
12:38:43 <hellwolf> i got a primes function working,w hich returns a infi list of primes
12:38:51 <mm_freak> hellwolf: that's a job for tuples
12:39:05 <bernalex> Twey: oh. you posted something. I came in here looking for your glfw paste, heh. thanks! I'll have a look now.
12:39:08 <nadirs> haasn: I definitely need to learn more about the subject :)
12:39:18 <haasn> () has a value, namely ()
12:39:22 <haasn> that is distinct from _|_
12:39:23 <mm_freak> hellwolf: ZipList would solve that elegantly, but personally i'd just write a recursive function for that
12:39:34 <mm_freak> hellwolf: construct a list of primes, then recurse to find the twins
12:39:36 <nadirs> haasn: so, () is not bottom?
12:39:39 <haasn> nadirs: _|_ is said to be a member of every type, eg. “undefined :: a”
12:39:41 <haasn> nadirs: no, () is unit
12:39:43 <hellwolf> nadirs, I have weak understanding of bottom, but I couldn't understand it using you context
12:39:43 <Cale> nadirs: right
12:39:50 <milfjord> > ()
12:39:51 <lambdabot>  ()
12:39:53 <haasn> nadirs: are you thinking of Void? Void has no constructors so the only possible value of type Void must be _|_
12:39:56 <Cale> The type () has two values, _|_ and ()
12:40:12 * hellwolf think "bottom" sometimes sounds funny looking twice
12:40:33 <monochrom> zip (myprimes) (tail myprimse) = [(2,3), (3,5), (5,7), (7,11), (11,13), ...}. post-process that to find twin prime tuples.
12:40:33 <nadirs> haasn: I didn't heard about Void yet
12:40:41 <mm_freak> a proper zipper is a hole without bottom
12:40:56 <haasn> > [(), (), (), ()] :: [()] -- nadirs
12:40:57 <lambdabot>  [(),(),(),()]
12:41:08 <hellwolf> monochrom, thanks, let me try to understand what you typed...
12:41:12 <nadirs> Cale, haasn: so _|_ is like (forgive the blasphemy) like null/None/nil of other imperative languages?
12:41:23 <haasn> nadirs: there's a distinct difference
12:41:26 <milfjord> nadirs: not really
12:41:35 <haasn> nadirs: in other languages you can do something like “if (x == null) { ... }”
12:41:40 <haasn> nadirs: in haskell, there's no way to tell something is _|_ outside of IO
12:41:48 <fizbin> nadirs: _|_ is like the type Nothing in scala.
12:41:48 <milfjord> even inside IO
12:41:50 <mm_freak> haasn: that's because null is not bottom
12:41:59 <milfjord> infinite loops are _|_ too
12:42:04 <haasn> oh yes
12:42:05 <ReinH> monochrom: for some reason I keep thinking about paramorphisms but that's not quiet what we want here is it?
12:42:17 <haasn> milfjord is right, you can detect some kinds of _|_ in IO but not all
12:42:18 <monochrom> I don't know paramorphism
12:42:27 <fizbin> (In scala, a function that returns the type "Nothing" can only exit by throwing an exception)
12:42:44 <mm_freak> haasn: in those languages null corresponds to the implicit Nothing that you get for every implicitly-Maybed type
12:42:49 <ReinH> monochrom: para  c n = snd . foldr (\ x (xs, t) -> (x : xs, c x xs t)) ([], n)
12:42:50 <nadirs> any type contains a "_|_"?
12:42:52 <Twey> nadirs: ⊥ is like the return value of a non-terminating function, or the return type of killing the program you're in
12:42:53 <johtso> Is there a foldlWhile function? Something like (a -> b -> a) -> (a -> Bool) -> [b] -> a
12:42:58 <ReinH> monochrom: from the bananas paper iirc
12:43:17 <mm_freak> johtso: foldM over Writer i guess =)
12:43:23 <nadirs> Twey: can I say _|_ is non-value?
12:43:35 <nadirs> Like, since the function didn't terminate, then
12:43:45 <nadirs> it resulted in a "non-value"
12:43:48 <ReinH> johtso: unfold?
12:43:51 <johtso> oops, and got the last two the wrong way round (a -> b -> a) -> (a -> Bool) -> a -> [b]
12:44:07 <mm_freak> johtso: that's not a fold
12:44:17 <hellwolf> nadirs, depends on how you define "non-value" I guess..
12:44:35 <mm_freak> johtso: (a -> b -> Maybe a) -> a -> [b] -> a
12:44:54 <johtso> mm_freak: oh? I'm just starting out with Haskell so I'm probably doing/asking something stupid :)
12:45:04 <mm_freak> johtso: try to explain your application instead =)
12:45:06 <ReinH> johtso: doing/asking stupid things is how we learn :)
12:45:09 <hellwolf> if _|_ is already well defined, come up with an alternative definition to prove they are equivalent would be a more daunting task
12:45:20 <mm_freak> johtso: in other words, explain the problem, not the solution =)
12:45:33 <Twey> nadirs: Yes, basically
12:45:38 <nadirs> hellwolf: I guess, since it's called bottom, it  is a value on the boundary of the set of possible values of a type so it's almost a non-value, at least from the point of view of that set. I don't know if any of this makes sense :P
12:45:46 <Twey> ⊥ is the lack of a value, the failure to produce a value
12:46:10 <mm_freak> ⊥ is the value that is never computed
12:46:16 <bernalex> Twey: your example doesn't typecheck btw
12:46:23 <johtso> mm_freak: Just liked the idea of explaining what I wanted using a type signature :)  .. what I'm trying to do is something like a fold, iterate over a list with an accumulator, but I want to break out early if the accumulator gets to a certain state
12:46:35 <nadirs> Twey: This. This I can understand
12:46:47 <ReinH> nadirs: do you know how to write foldl?
12:46:47 <geekosaur> nadirs: in strict languages you don't talk about bottom because it's always a program failure of some kind. in non-strict languages, it is possible to reason about bottom to some extent
12:46:54 <mm_freak> johtso: the idea was good, but understanding the application is most important before attempting to help =)
12:46:55 <ReinH> er sorry
12:46:57 <ReinH> nadirs: not you
12:47:02 <geekosaur> which is another way of saying we can represent infinite datastructures
12:47:04 <mm_freak> johtso: you explained the solution again ;)
12:47:10 <ReinH> johtso: do you know how to write foldl?
12:47:16 <mm_freak> johtso: explain the problem you want to solve with such a function
12:47:25 * ReinH shuts up
12:47:51 <nadirs> geekosaur: ok, I think I get it. Like "head []"? Until you evaluate it, everything is fine?
12:47:52 <Twey> bernalex: What example?
12:48:00 <bernalex> Twey: http://lpaste.net/raw/100524
12:48:01 <haasn> nadirs: yes
12:48:07 <haasn> nadirs: or length [1..]
12:48:09 <Cale> nadirs: or like x = x :)
12:48:09 <bernalex> or er http://lpaste.net/100524 but yeah
12:48:10 <monochrom> johtso: you may like to know that foldr already exits early, if you use it right. consider foldr (&&) True [False, True, True ...]
12:48:28 <Cale> (or I should say, let x = x in x)
12:48:31 <Twey> bernalex: Typechecks and compiles for me
12:48:33 <geekosaur> yes. which is not so useful, but consider that `[1..]` is infinite but `take 2 [1..]` is not and is entirely well defined in haskell
12:48:35 <nadirs> I understood haasn's examples, but not Cale's :/
12:48:41 <Twey> bernalex: Perhaps you have a different version of some package?  What's the error?
12:48:47 <geekosaur> in a strict language it would not be evaluable
12:48:49 <haasn> nadirs: let x = x in ...
12:48:56 <bernalex> Twey: odd. I get Couldn't match expected type `Future (String, [String])' with actual type `(String, t0)'
12:48:56 <nadirs> Isn't something like that in "Tying the knot"?
12:49:04 <mm_freak> nadirs: "what is x?  oh, it's x, and what is x?  ah, it's x…  so what is x?  it's x…"
12:49:05 <Cale> nadirs: let x = x in x will be a tight infinite loop
12:49:09 <bernalex> Twey: on the line changes bWords >>= reactimate . fmap (\ (word, _) -> set label [ labelText := word ])
12:49:20 <Twey> bernalex: What version of reactive-banana do you have?
12:49:27 <mm_freak> nadirs: asking for x will not conclude =)
12:49:32 <bernalex>  In the pattern: (word, _) In the first argument of `fmap', namely `(\ (word, _) -> set label [labelText := word])' -- to be specific
12:49:40 <bernalex> Twey: 0.8.0.0
12:49:41 <haasn> Cale: (depending on what operational semantics you assign to it, no? it could just be a black hole error)
12:49:49 <Cale> haasn: right
12:49:54 <Twey> bernalex: Ah, I guess it changed a bit — I'm still on 0.7.*
12:49:59 <Twey> bernalex: But you get the idea
12:50:06 <bernalex> Twey: yes, it's a great help, thanks
12:50:18 <Cale> It *will* be a black hole error if you're doing blackholing at all
12:50:27 <monochrom> perhaps I should write a tutorial on denotational semantics and tell you how to reason with bottom
12:50:36 <mm_freak> lol
12:50:40 <haasn> I wonder what the haskell report actually specifies about _|_ and exceptions
12:50:49 <johtso> monochrom: foldr exists early? but doesn't it only return when the list is consumed?
12:50:54 <nadirs> (nevermind my reference to Tying the knot, x and y have at least a value in cyclic :P)
12:50:59 <Cale> The Haskell report definitely ought to say more than it does, I feel.
12:51:07 <johnw> johtso: it all depends on the function you pass to it
12:51:08 <haasn> would it be valid for GHC to compile “x = x” as it would “x = error "black hole: x"”?
12:51:20 <monochrom> the haskell report doesn't even have exceptions. well, except for IOError. but IOError does not include bottom
12:51:25 <Cale> In the really old versions of Haskell, there was a denotational semantics to go along with the Report
12:51:25 <mm_freak> johtso: foldr f z (x:xs) = f z (foldr f x xs)
12:51:25 <johnw> johtso: if that function is not strict in its second argument, foldr can return after the first element
12:51:33 <Cale> But people didn't bother keeping them up to date.
12:51:34 <mm_freak> johtso: now let f = (&&) and z = True
12:52:07 <monochrom> also x=False. in fact z doesn't matter
12:52:08 <haasn> mm_freak: I think you meant f x (foldr f z xs)
12:52:12 <mm_freak> uh
12:52:13 <mm_freak> sorry
12:52:15 <nadirs> haasn: I wonder, does the compiler detect it by comparing the "pointer" of the two symbols? Or after a certain amount of recursion?
12:52:15 <monochrom> hehe
12:52:37 <nadirs> (I mean, the black hole error)
12:53:03 <monochrom> foldr (&&) whatever (False : xs) = False && (foldr ...) = False. full stop. does not matter that "what if xs is infinite?"
12:53:03 <johtso> mm_freak: oh!
12:53:09 <johtso> aha moment :)
12:53:18 <mm_freak> johtso: what haasn said =)
12:53:22 <mm_freak> my equation was wrong
12:53:33 <johtso> I don't have to consume the second argument
12:53:40 <mm_freak> foldr f z (x:xs) = f x (foldr f z xs)
12:53:41 <Cale> nadirs: When beginning the evaluation of each variable bound to an unevaluated expression, the compiler replaces the pointer to that expression's code with a pointer to something which throws an exception
12:53:42 <haasn> nadirs: basically when the thunk ‘x’ gets entered it's temporarily overwritten by a “black hole”. Normally you'd keep evaluating until you reach the outer constructor and then rewrite the thunk for x by that constructor
12:53:53 <Cale> er, well, the code for the expression does that, rather
12:54:09 <mm_freak> foldr (&&) True (False:xs) = False && foldr (&&) True xs
12:54:13 <haasn> nadirs: when x depends on itself like that, though, the compiler will enter “x” again during the evaluation of x, so it finds the black hole
12:54:18 <haasn> telling us that something's wrong
12:54:20 <mm_freak> and False && _ = False, by the definition of (&&)
12:54:27 <monochrom> this totally debunks the lies about "foldl starts from left, foldr starts from right"
12:54:33 <monochrom> blantant lies
12:54:36 <mm_freak> johtso: that's equational reasoning =)
12:54:38 <monochrom> blantant lies die die die
12:54:42 <Cale> and yeah, when it's finished evaluating that expression, it'll rewrite that code pointer with one that returns the computed result immediately (to avoid duplicating work next time)
12:55:09 <johnw> monochrom: I too had that confusion for months, because people call it a "right fold", rather than a "right-associative fold"
12:55:19 <monochrom> well, mm_freak, it comes down to (&&) being conditionally non-strict in the 2nd operand
12:55:34 <Cale> But if in the process of evaluating that bound variable, it finds out that it needs to evaluate the same variable again and follows the appropriate code pointer, it's sent to the code which throws the exception.
12:56:22 <haasn> of course
12:56:32 <haasn> the correct answer is that both folds start neither left nor right
12:56:33 <nadirs> Cale, haasn: clear. Thanks for the great answers and for the very interesting discussion about bottom. This channel is beautiful
12:56:41 <haasn> because the order of evaluation isn't clear
12:57:02 <haasn> (or is it?)
12:57:20 <Cale> Well, it's usually kind of safe to assume that you're using lazy evaluation
12:57:25 <Cale> which is a specific evaluation order
12:57:25 <johtso> would you usually use foldr rather than foldl if the direction doesn't matter?
12:57:30 <Cale> But GHC won't actually always use that order.
12:57:41 <haasn> johtso: the associativity matters
12:57:46 <johnw> johtso: I would suggest using foldl' until you know you want foldr
12:57:47 <Cale> johtso: yes, usually you either use foldr or foldl'
12:57:49 <haasn> johtso: for non-associative functions
12:58:11 <haasn> for associative functions that are strict in both arguments I would use foldl'
12:58:11 <Cale> foldl itself is pretty rarely what you really want, with a few notable exceptions
12:58:16 <haasn> like (+) or (*)
12:58:17 <monochrom> johnw: I have a perfect explanation of why it's taught wrong. travel back to school. "2*(3+5)", "PEDMAS" or whatever it's called. compute the (3+5) part first because it's in parentheses, right?
12:58:32 <monochrom> except "0*(392834+290384)" you shouldn't even bother. it's 0.
12:58:43 <Cale> Though, GHC is actually pretty good at turning foldl into foldl' when you compile with optimisations and it's an appropriate thing to do
12:58:45 <haasn> (for Integer or Double or other types for which (+) and (*) are strict; before somebody tells me that (*) isn't necessarily strict in both arguments ;))
12:59:23 <haasn> Cale: doesn't help in GHCi does it? :)
12:59:25 <nadirs> monochrom: I thought you were going to say "the margin is too narrow" :P
12:59:28 <Cale> haasn: Right
12:59:35 <monochrom> PEDMAS is really about parsing, building the parse tree. evaluation order may or may not coincide with that. but that's too much information for highschool. they are unified.
12:59:50 <Cale> haasn: (unless you've compiled your code and ghci has loaded the .o for it)
13:00:07 <monochrom> and then when you come to haskell, you have to separate them again.
13:00:41 <haasn> monochrom: in eager languages evaluation is from the inside out, right?
13:00:47 <hexagoxel> previously (iirc), i was able to interrupt a computation on the repl with ctrl-c; now, it seems to quit (crash?) on ctrl-c
13:00:51 <haasn> in eager evaluation, that is
13:00:54 <hexagoxel> is that supposed to work?
13:00:59 <johtso> haasn: ahh, I'm missing so much terminology, what does strict in both arguments mean?
13:01:23 <johtso> does it mean the order of the two arguments matters?
13:01:26 <johnw> a function is strict in its argument if f ⊥ = ⊥
13:01:29 <monochrom> yes. highschool is essentially all eager evaluation because you only get to see strict operators anyway. eager doesn't hurt. it's alright to tell the shortest story possible.
13:01:29 <haasn> johtso: a function ‘f’ being strict in its first argument means that f _|_ = _|_
13:01:32 <Cale> monochrom: Well, evaluation isn't even something that's formally described in school, even though it's implicitly something demanded of students through exercises. All that's actually described is equality.
13:01:53 <Cale> But you fail if you respond to 1 + 1 = ? with 1 + 1
13:01:54 <haasn> johtso: in practice this means that to evaluate “f x” you need to evaluate x, no matter what
13:01:57 <johtso> haasn: ah, from terminology to symbols :D
13:02:03 <Actreka> I keep seeing "_|_", what is this?
13:02:25 <Cale> Actreka: It's ascii art for an upside down T sort of symbol used to denote a nonterminating computation.
13:02:27 <johtso> haasn: aha okay
13:02:27 <haasn> johtso: for an operator, say × to be strict in both arguments means that (⊥ × a) = (a × ⊥) = ⊥
13:02:39 <monochrom> except that I would really love highschool to teach the if-then-else operator too. http://groups.google.com/group/alt.algebra.help/msg/1c8cbcc4195b4012
13:02:40 <hexagoxel> it is called "bottom"
13:02:45 <haasn> johtso: in practice, this again means that evaluating (a × b) forces you to evaluate both ‘a’ and ‘b’, no matter what
13:02:45 <hexagoxel> _|_ that is
13:03:00 <monochrom> but then the if-then-else operator is pretty non-strict.
13:03:32 <haasn> johtso: an example of an operator that is strict in both arguments: (+) on Int, you need to evaluate both x and y to put an exact value on x + y; an example of an operator that is *not* strict in its right argument (but strict in its left) is right-biased (&&), because False && x = False; even if x is ⊥
13:03:43 <haasn> johtso: (or left-biased, whatever)
13:03:47 <Actreka> Is a non-terminating computation like an infinite loop in OOPL?
13:03:54 <Cale> It's called bottom because it's the bottom of a definedness partial ordering on values of a data type. (i.e. it's the least-defined possible value)
13:04:02 <haasn> johtso: so even though (&&) is associative, foldr (&&) and foldl' (&&) can have different semantics
13:04:26 <Cale> Actreka: yes, an infinite loop or an error which kills the program
13:04:28 <haasn> > foldl' (&&) True $ repeat False
13:04:33 <lambdabot>  mueval: ExitFailure 1
13:04:33 <lambdabot>  mueval: Prelude.undefined
13:04:34 <haasn> > foldr (&&) True $ repeat False
13:04:35 <lambdabot>  False
13:04:38 <haasn> johtso: ^
13:04:45 <johtso> haasn: aha, so if my function is only strict in its first argument, then I want to use foldr?
13:04:54 <haasn> johtso: perhaps. I don't know
13:04:58 <johnw> only if you need it
13:05:07 <Cale> johtso: Probably.
13:05:22 <haasn> johtso: a good rule of thumb is that you want to use foldr if your function can short-circuit
13:05:25 <haasn> like (&&) and (||)
13:05:35 <johnw> also, using foldr with (:) is usually a good idea
13:05:49 <haasn> johnw: (:) is not associative ;)
13:06:03 <haasn> so it has completely different semantics between foldr and foldl here anyway
13:06:12 <Cale> You have to flip (:) to use it with foldl
13:06:19 <Cale> and that's a good definition of reverse ;)
13:06:31 <haasn> id and reverse, yes :)
13:06:42 <haasn> hence “completely different semantics”
13:06:51 <Cale> map f = foldr ((:) . f) []
13:07:14 <Cale> You can think of that as being "replace each (:) in the list with (:) . f and replace the [] at the end (if any) with []
13:07:20 <haasn> I wonder if it would make sense to actually define map that way, for fusion
13:07:27 <Cale> yes
13:07:40 <Cale> It effectively is defined that way
13:08:12 <haasn> "map"       [~1] forall f xs.   map f xs                = build (\c n -> foldr (mapFB c f) n xs)
13:08:13 <haasn> interesting
13:08:45 <Cale> another good rule of thumb is that if you want to have any hope of your function operating on infinite lists, you'll want to avoid left folds
13:08:48 <haasn> mapFB ≅ (.)
13:09:24 <haasn> something I'm not actually quite sure about: is there any reason you'd ever want foldl instead of foldl'?
13:10:17 <monochrom> I still haven't needed to choose foldl over foldl'
13:10:40 <haasn> Hmm
13:10:50 <haasn> maybe if you have a function that is not strict in its left parameter
13:11:07 <haasn> which lets you short-circuit some big calcualtion (that is more expensive than allocating all those tuples)
13:11:09 <monochrom> but see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ :)
13:11:42 <hamster007_> I am trying to install this and use it     http://dinkla.net/en/programming/haskell-cglib.html
13:12:05 <hamster007_> I downloaded it and unzipped it and cd into it and cabal install
13:12:47 <hamster007_> now I want to mess with it in ghci but no workie whenI import
13:13:52 <Actreka> Using this doesn't work is there a better way to do this? "filter (>2000 && <4000)"
13:14:01 <ifthenelse> Is there a way to read a string as a function? Like, (read "take 2" :: (a -> [b] -> [b])) [1, 5, 3] would return [1, 5]?
13:14:17 <haasn> Actreka: filter (\x -> x > 2000 && x < 4000)
13:14:26 <monochrom> if you want my tutorial on denotational semantics and bottom, you will have to make do with this for now: http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231/
13:14:45 <shiona> :t (>2000) <> (<4000)
13:14:46 <lambdabot>     Could not deduce (Monoid Bool) arising from a use of `<>'
13:14:46 <lambdabot>     from the context (Num a, Ord a)
13:14:46 <lambdabot>       bound by the inferred type of it :: (Num a, Ord a) => a -> Bool
13:14:46 <haasn> Actreka: the point-free way could be something like filter (liftA2 (&&) (>2000) (<4000)) but that's not very pretty
13:15:12 <supki_> :t inRange
13:15:13 <lambdabot> Ix a => (a, a) -> a -> Bool
13:15:15 <Actreka> haasn: I'm a bit uneasy with these lambda things, is there a good resource where I can learn about them?
13:15:18 <haasn> There is also https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
13:15:19 <shiona> meh, would need all with that
13:15:48 <haasn> Actreka: supki_'s idea is actually quite good; but as for what you asked, have you read about them in LYAH? I don't remember how well it describes them
13:16:04 <hamster007_> I get this error
13:16:05 <hamster007_> Could not find module `GeomAlg.Delaunay.Voronoi'
13:16:14 <monochrom> actually http://article.gmane.org/gmane.comp.lang.haskell.cafe/20686/ is better
13:16:15 <hamster007_> I tried to import that^^^
13:16:43 <hamster007_> I am a noob ok I'm not a genius like you guys
13:16:46 <haasn> hamster007_: what does ghc-pkg describe GeomAlg say?
13:16:46 <Actreka> haasn: I've tried to understand the LYAH, didn't get it :/.
13:17:16 <Actreka> supki_: Do I have to implement inRange myself or is it already somewhere?
13:17:30 <haasn> Actreka: it's in Data.Ix
13:17:58 <haasn> > inRange (2000,4000) 2000
13:17:59 <lambdabot>  True
13:18:07 <haasn> not quite the same thing, you have to use (2001,3999) for the same semantics
13:18:19 <haasn> that is, assuming you're using something like Int
13:18:28 <haasn> inRange doesn't work for something else like double
13:18:29 <Actreka> Yep all are ints
13:18:38 <Actreka> Thanks for the heads up though
13:19:10 <hamster007_> SO... I downoaded the package and compiled it with cabal install    what more do I need to do?
13:19:17 <haasn> Actreka: you can think of (\x -> y) as an anonymous function; say “let anonymous x = y in anonymous”
13:19:29 <haasn> in fact I'm reasonably convinced those should have the exact same semantics
13:19:37 <hamster007_> have mercy on the hamster ok
13:19:52 <haasn> (maybe somebody more knowledgeable on the monomorphism restriction could answer that)
13:20:28 <Twey> Actreka: filter ((&&) <$> (> 2000) <*> (< 4000)) -- much prettier!
13:20:39 <haasn> Actreka: so using (\x -> x > 2000 && x < 4000) is like defining your own function inMyRange x = x > 2000 && x < 4000; and then using filter inMyRange
13:20:44 <Actreka> Twey: Wow thanks!
13:21:05 <thebnq> that would be even prettier with idiom brackets!
13:21:10 <monochrom> lambda is just anonymous function. (\x -> x && True) is just a way to say "define f x = x && True, but without the f"
13:21:23 <haasn> that might actually be pretty with idiom brackets ;)
13:21:41 <Actreka> What would these anonymous functions do, that normal functions can't?
13:21:50 <haasn> Actreka: nothing, but they don't have a name :)
13:21:54 <haasn> and you don't have to give them one
13:21:55 <Actreka> Do they self-destruct after use?
13:22:07 <monochrom> even named functions self-destruct
13:22:34 <haasn> Actreka: a typical compiler would probably lift out an anonymous function to a top-level one by giving it some unique name
13:22:43 <monochrom> there is no difference, other than writing style.
13:22:44 <haasn> it's just a convenience for the programmer, at least in Haskell
13:22:50 <hamster007_> : |
13:23:18 <Actreka> haasn: I see, I'm sensing that I should try to understand and use it I guess
13:23:44 <monochrom> you should understand it. you should trust your judgement in when to use and when not to use.
13:25:34 <mm_freak> for infix operators i prefer liftA2
13:25:34 <haasn> monochrom: whatever “self-destruct” means, of course :)
13:25:34 <monochrom> damn, it's hard to spell judgment properly. why do they make it so hard?! :)
13:25:34 <mm_freak> filter (liftA2 (&&) (> 2000) (< 4000))
13:25:35 <mm_freak> or even:  let (<&&>) = liftA2 (&&) in filter ((> 2000) <&&> (< 4000))
13:25:35 <monochrom> (\x -> x+x) in Haskell becomes "function (x) { return x+x; }" in javascript
13:25:44 <monochrom> there is also a version in recent C++
13:25:50 <haasn> Actreka: you will undoubtedly come across quite a number of lambdas so it would be a good idea to understand what they are
13:25:55 <monochrom> there is also a version in future Java
13:26:12 <monochrom> I forgot what C# says on this
13:26:17 <mm_freak> there is also a version in elite-haskell
13:26:24 <mm_freak> in elite-haskell it becomes join (+)
13:26:45 <haasn> Twey: filter (schön inRange 2000 4000) -- so much schöner
13:26:47 <monochrom> in python it's "lambda (x): return x+x" I think
13:26:58 <mm_freak> monochrom: lambda x
13:27:03 <mm_freak> haasn: schön!
13:27:13 <haasn> mm_freak: I finally found a use case! I am so happy
13:27:16 <Actreka> schön, germans everywhere?
13:27:17 <monochrom> you can no longer avoid lambda, even if you avoid haskell
13:27:39 <Actreka> I can't avoid lambda when doing linear algebra...
13:27:41 <mm_freak> Actreka: no, i just wrote a joke library for schönfinkelization =)
13:27:49 <monochrom> hahaha. different lambda, but ok!
13:27:49 <mm_freak> but yeah, i'm actually from germany =)
13:28:08 <mm_freak> Actreka: http://hackage.haskell.org/package/acme-schoenfinkel-0.1.1/docs/Control-Category-Schoenfinkel.html
13:28:46 <haasn> mm_freak: why is this in acme- :(
13:28:51 <monochrom> just yesterday I just wrote javascript "Stepper.prototype.step = function () { ... }" that's a lambda right there for OOP methods in javascript
13:28:53 <Actreka> mm_freak: Seems to advanced for me, don't understand what it does
13:28:55 <hamster007_> mm_freak: save me man... I am trying to do something simple but I'm a noob
13:29:00 <haasn> do we have any other library that provides a class for categories with currying?
13:29:44 <hamster007_> http://www.dinkla.net/fp/GeomAlg/index.html
13:29:49 <mm_freak> haasn: because it started as a joke, but i suppose you could probably use it seriously, in which case i'd avoid the unicode variants =)
13:29:54 <haasn> Actreka: I was just making a lame pun off “schön” meaning “pretty”; you could have just used ‘curry’ which is in the Prelude I think
13:29:58 <mm_freak> Actreka: just look at the bottom of that page =)
13:30:00 <hamster007_> I built this using cabal install
13:30:11 <mm_freak> hamster007_: just ask =)
13:30:23 <hamster007_> now I want to load it into GHCI
13:30:24 <haasn> mm_freak: he did a while ago, if you scroll up ;)
13:30:33 <Actreka> Apropos this Prelude, is that always imported when compiling?
13:30:41 <hamster007_> I don't know what to load
13:30:44 <quchen> mm_freak: That library only exists to have a "hässlich" function, doesn't it
13:30:46 <mm_freak> oh, i'm not reading continuously =)
13:30:58 <mm_freak> quchen: no, that function was actually suggested by someone else =)
13:31:26 <Actreka> schrecklich...
13:31:27 <hamster007_> need some hamster love
13:31:59 <mm_freak> awww
13:32:02 * mm_freak hugs hamster007_ 
13:32:25 <quchen> mm_freak: How about an synonym, "häßlich", for backwards orthography compatibility?
13:32:36 <Actreka> Are there some standard cases where lambda functions are better?
13:33:01 * haasn whistles innocently at mm_freak
13:33:13 <quchen> Actreka: Prelude is imported unless you tell the compiler not to
13:33:16 <Actreka> Ich bin ein Deutsch Student hehehe
13:33:25 <mm_freak> quchen: it's on darcshub…  feel free to send me a patch =P
13:33:33 <Cement> I'm trying to solve Problem 11 on Project Euler, and I'm having trouble getting the diagonals from the matrix
13:33:38 <Actreka> quchen: Without the Prelude, does it have any functions defined at all then?
13:33:39 <Cement> http://lpaste.net/100534
13:34:02 <quchen> Actreka: Some primitives might still exist, I'm not sure. `seq` might be available, for example.
13:34:19 <quchen> But really basic stuff like (.) is missing if you don't import Prelude.
13:34:35 <haasn> Actreka: I think that's a no
13:34:42 <haasn> other than ones you import, of course
13:35:03 <mm_freak> there are two ways not to import the Prelude
13:35:04 <Actreka> I hate the . I always mess up with it
13:35:07 <c_wraith> quchen: seq maps to a primop, but you still have to import it
13:35:13 <mm_freak> NoImplicitPrelude and 'import Prelude ()'
13:35:21 <pjdelport> Cement: take a look at http://stackoverflow.com/q/3998891/444705 perhaps
13:35:23 <haasn> seq is in the Prelude
13:35:36 <mm_freak> the former is the real "not importing the Prelude"
13:36:08 <haasn> could import Prelude () give you some instances you don't want?
13:36:29 <mm_freak> haasn: yes
13:36:30 <geekosaur> you still get instances, yes
13:36:30 <haasn> I'm guessing not because the only instances it re-exports are ones you'd get either way if you import those classes, no?
13:36:40 <monochrom> all instances you don't want, in fact :)
13:36:43 <mm_freak> haasn: when you write '0' it may end up being an Integer
13:36:57 <pjdelport> Cement: You may want to consider an Array-based representation, rather than nested lists.
13:36:59 <hexagoxel> does "cabal list --installed" not include executables (like happy)?
13:37:02 <mm_freak> haasn: and you don't have Integer imported, so you have a well-defined value that you can't actually use in any way =)
13:37:12 <hamster007_> http://lpaste.net/100542
13:37:19 <geekosaur> hexagoxel, yes, it uses ghc-pkg which only knows about libraries
13:37:55 <haasn> mm_freak: what happens if you write 0 with NoImplicitPrelude, actually? Does it come out as (0 :: Prelude.Num a => a) ?
13:38:05 <hexagoxel> so the description in "cabal list --help" is wrong, or am i missing something?
13:38:27 <hexagoxel> geekosaur: ok, ty
13:38:30 <geekosaur> when it says packages, it's talking about ghc packages (as listed by ghc-pkg)
13:38:38 <geekosaur> it's kinda confusing
13:39:00 <pjdelport> haasn: in ghci, it comes out as (0 :: GHC.Num.Num a => a)
13:39:05 <hexagoxel> but for "cabal install" command, a package suddenly can be an executable?
13:39:11 <hexagoxel> seems very consistent..
13:39:22 <geekosaur> there is a difference between cabal packages and ghc packages
13:39:52 <haasn> pjdelport: thanks, that's what I'd expect
13:39:53 <geekosaur> a cabal package that installs only executables does not have a corresponding ghc package, so it can't be tracked
13:40:36 <geekosaur> this leads to a number of weirdnesses, like it can install an executable-only package as a dependency and then not be able to find it later becuse the executable(s) aren't in your $PATH
13:40:40 <hamster007_> AHA!!!
13:40:43 <hexagoxel> well if different cabal --help texts refer to different stuff, they should say so
13:40:48 <mm_freak> haasn: i don't know actually…  you might have to define Num and set defaulting
13:40:51 <hamster007_> import Voronoi
13:40:54 <mm_freak> haasn: but i've never done that myself
13:41:03 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml tells most of the story
13:41:24 <c_wraith> My favorite cabal package for weirdness is bindings-dsl.  It does install a library, that consists of one empty module.  It also installs no executables!
13:41:36 <hexagoxel> geekosaur: hmm that might a useful read, thanks
13:41:51 <haasn> mm_freak: I'd also be curious to see what happens to [x,y,z] and (x,y,z) with NoImplicitPrelude
13:42:00 <Twey> c_wraith: o.@
13:42:00 <hpc> c_wraith: it doesn't look that empty to me
13:42:07 <hexagoxel> (and i still consider the help wrong :D)
13:42:07 <geekosaur> there's also RebindableSyntax...
13:42:14 <hpc> http://hackage.haskell.org/package/bindings-DSL-1.0.21/docs/src/Bindings-Utilities.html#storableCast -- it's an entire 50-ish lines long!
13:42:16 <Sonarpulse> is there any webpage with GSoC 2014 ideas yet?
13:42:46 <c_wraith> hpc: oh, hey.  That's new.  It used to just be an empty module
13:43:14 <Twey> c_wraith: What did it do when it was an empty module?
13:43:31 <c_wraith> Twey: same thing it does now.  It's a collection of macros for hsc2hs
13:44:00 <Twey> c_wraith: Where are the macros stored?  There don't seem to be any in the source of Bindings.Utilities
13:44:09 <c_wraith> Twey: when it's part of the build-dependencies section of a cabal file, its header file is visible to hsc2hs
13:44:14 <Twey> Aha
13:44:24 <mm_freak> haasn: i've just tried it
13:44:35 <mm_freak> [x,y,z] works,
13:44:41 <mm_freak> but i have no idea what it becomes
13:44:56 <kylcarte> are there any potential downsides to adding an instance of MonadCatch for EitherT?
13:46:11 <mm_freak> haasn: i believe it becomes a value of the builtin list type
13:46:24 <haasn> mm_freak: most likely, yes
13:46:27 <mm_freak> i expected trying to define [] to succeed, but it failed
13:46:35 <mm_freak> data [] a = …
13:46:45 <c_wraith> it's still not syntactically valid
13:46:51 <c_wraith> even if GHC's definition wasn't in scope
13:46:53 <haasn> mm_freak: NoImplicitPrelude is also distinct from OverloadedSyntax; the former still makes “if x then y else z” use the built-in Bools
13:47:07 <haasn> the latter lets you define your own non-Bool alternative interpretation for that syntax
13:47:16 <mm_freak> c_wraith: it doesn't complain about syntax though, but about illegal binding of builtin syntax
13:47:17 <haasn> OverloadedSyntax, however, does not cover list and tuple literals
13:47:27 <mm_freak> test.hs:6:6: Illegal binding of built-in syntax: []
13:47:33 <Actreka> Any way I can make vim the default editor in ghci?
13:47:46 <mm_freak> Actreka: define the EDITOR variable in your shell profile
13:47:56 <mm_freak> export EDITOR=vim
13:48:06 <mm_freak> a couple of other programs use that, too
13:48:08 <Actreka> "echo $EDITOR" outputs vim
13:48:15 <mm_freak> oh
13:48:18 <mm_freak> try VISUAL then
13:48:20 <c_wraith> mm_freak: I bet that's just an artifact of how the parser is written.
13:48:32 <mm_freak> c_wraith: might be, yeah
13:48:42 <Twey> So, upgrading reactive-banana causes my video player to be reïnstalled… truly, the ways of Gentoo are mysterious
13:48:57 <Actreka> mm_freak: VISUAL didn't work either :/
13:49:01 <mm_freak> Twey: http://nixos.org/ =P
13:49:07 <Twey> mm_freak: Soon
13:49:19 <mm_freak> Actreka: oh, found it
13:49:22 <haasn> Twey: what video player? :)
13:49:34 <mm_freak> Actreka: put this in your ~/.ghci: :set editor vim
13:49:46 <Actreka> Ah, thank you :)
13:49:51 <mm_freak> i would have expected it to default to $EDITOR
13:49:53 <Twey> haasn: mpv
13:50:03 <Actreka> I thought so too
13:50:08 <geekosaur> docs say it does
13:50:14 <geekosaur> apparently it's broken
13:50:20 <haasn> Twey: okay, that is weird. mpv doesn't have a dependency on reactive-banana here
13:50:24 <Twey> Tree output: reactive-banana 0.8.0.0 requires pqueue.  Also, I'm reinstalling mpv.
13:50:24 <Actreka> mm_freak: feature request for ghci then
13:52:35 <haasn> Twey: wait a minute, wait a minute; I remember something like this
13:54:21 <haasn> Twey: https://bugs.gentoo.org/show_bug.cgi?id=486910
13:55:02 <haasn> Twey: https://bugs.gentoo.org/show_bug.cgi?id=486580 here is the issue I had
13:56:25 <haasn> I'm quite sure mpv was in the list of rebuilt packages :)
13:56:46 <Twey> haasn: That was fixed ages ago; I'm sure I've upgraded Portage since then
13:56:56 <haasn> Oh okay, good point
13:56:59 <haasn> It might be something similar though
13:57:17 <Twey> Perhaps
14:02:32 <joelteon> what does ".\" after an identifier mean in prof output?
14:11:55 <mm_freak> freenode under attack again?
14:12:10 <prophile> not an unreasonable assumption
14:12:16 <Sculptor> when did it end, mm_freak
14:17:20 <enthropy> is there a version of http://home.telfort.nl/sp969709/gtk2hs/app1.html which works with gtk3?
14:17:53 <enthropy> things have been rearranged such that I have to use something like renderWithDrawWindow instead of renderWithDrawable I think
14:21:56 <pavonia> enthropy: I don't think all the examples have been updated so far, the Haskell bindings to Gtk3 are pretty new
14:22:22 <EcoGiko> Hello, I am trying to install haskell on linux mint for 7 hours. Can anyone offer some advice?
14:22:58 <c_wraith> EcoGiko: install generic linux binaries to your user directory as step 1
14:23:27 <EcoGiko> c_wraith: generic linux binaries? what do you mean by that
14:23:30 <bitraten> Can I parse hashtags "#foo" from a file with ReadP?
14:24:04 <Athas> bitraten: I would not recommend it.
14:24:07 <foobazbar> Hi guys, i'm trying to get to grips with comrepehensions and I'm wondering if there's a way of performing maps with them?
14:24:12 <foobazbar> IE if i have say a scala map like Map(1 -> Map(1 -> -200, 2 -> 0), 2 -> Map(2 -> 400))
14:24:14 <c_wraith> EcoGiko: the ones from this page:  http://www.haskell.org/ghc/download_ghc_7_6_3  ignore everything it says that you want something else.  You don't want something else.
14:24:17 <foobazbar> I'd like a sequence of [-200, 0, 400]
14:24:17 <bitraten> Athas: How would you do it then?
14:24:27 <foobazbar> or would i need intermediate data structures for that
14:24:46 <Athas> bitraten: well, you can.  ReadP is just a parser combinator library, and you can define a parser just fine, but in practice there are better combinator libraries (like Parsec).
14:25:29 <EcoGiko> c_wraith: I have been building it from source, not from linux x86 platform, is that why it's not working?
14:26:08 <c_wraith> EcoGiko: you can't build ghc without having ghc.  Building it from source is not a first choice.
14:26:34 <pavonia> foobazbar: What do you want to do with that list exactly?
14:28:01 <foobazbar> pavonia I'm trying to learn some bits of discrete maths, and i can't get my head around it. So i wanted to play about with it in haskell instead
14:28:29 <EcoGiko> c_wraith: I got it. I have ghc from official repositories, I am downloading the linux x84 version and I will try it out
14:28:31 <foobazbar> Maybe that's not the smartest thing to do though...
14:28:52 <zomg> hmm tempted to write a small api we need at work in haskell as it needs to be pretty reliable.. but on the other hand I'm worried that because I'm not that experienced in haskell I'll just make an unreliable haskell program =)
14:29:12 <mm_freak> foobazbar: seems fine to me
14:29:21 <Twey> bernalex: This works with 0.8: http://lpaste.net/100524
14:29:46 <mm_freak> zomg: the most common problem is the memory leak in haskell, and those can be tracked down and fixed =)
14:29:59 <zomg> yeah
14:30:11 <zomg> though none of the web apis I've ever written in haskell have ever misbehaved in any way
14:30:14 <zomg> so maybe I'm worrying about it for no reason
14:30:15 <zomg> heh
14:30:53 <bernalex> Twey: oh. I already figured it out, but thanks for your time!
14:31:09 <mm_freak> zomg: perhaps you may want to start with a personal project first, so you don't get into trouble for delay
14:31:33 <k_89> http://lpaste.net/100547
14:31:33 <mm_freak> zomg: climbing a learning curve while doing production work always takes a lot more time
14:31:41 <zomg> Aye, I have written a few already so I'm pretty sure I could deliver it in time easily
14:31:51 <mm_freak> then just do it =)
14:32:02 <zomg> Yeah I'm leaning towards that option as well =)
14:32:12 <k_89> http://lpaste.net/100548
14:32:17 <k_89> can someone help me with that
14:32:28 <k_89> pasted the error inside the paste too
14:32:30 <Twey> bernalex: Ah, okay; glad you got it solved
14:32:41 <mm_freak> zomg: just remember that right now freenode tends to be down exactly when you need it most ;)
14:32:52 <zomg> heh
14:33:42 <bernalex> Twey: I think next step is fixing font stuff, and then adding "open file" support. I'd like to have alpha-1 by the end of Sunday. I think the *idea* is great at least.
14:33:44 <enthropy> pavonia: things seem to be better with gtk3
14:37:45 <zerokarmaleft> hello...taking my first steps with Sodium (pretty new to Haskell as well), and I'm not sure how to get putChar for this simple example on the right thread: http://lpaste.net/100549
14:45:40 <darthdeu> let's say i have a function which expects a positive integer as an argument, and it doesn't make sense to call it with a negative one, how should I handle this? From what I've read I should either raise an exception, or return Maybe something, with Nothing for negative numbers
14:45:45 <darthdeu> but both seem derpy
14:46:09 <darthdeu> but I guess there's no way to enforce it any other way :\
14:46:48 <pavonia> darthdeu: You could use a natural number type to ensure it gets an positive integer
14:47:21 <Iceland_jack> is it possible to get the kind of the promoted data constructor '(:) in GHCi?
14:47:51 <Iceland_jack> I know what it should be but I just can't get it to work, while :kind '[] works
14:48:06 <Iceland_jack> GHC 7.9.20140211
14:48:14 <Cale> zerokarmaleft: I believe you're not supposed to have multiple calls to sync ordinarily
14:52:38 <Cale> Well, okay, you need to for the new events
14:53:00 <Twey> Iceland_jack: Isn't it (':)?
14:53:06 <Cale> But the bit connecting the input and output would normally be inside a single call to sync, I believe.
14:53:23 <Iceland_jack> Twey: I get “parse error on input ‘:’”
14:53:58 <EcoGiko> c_wraith: I get an error saying I have a missing libgmp.so.3
14:54:19 <geekosaur> urgh not that one again
14:54:19 <c_wraith> EcoGiko: yeah... That happens.
14:54:23 <Iceland_jack> And in the Giving Haskell a Promotion paper they refer to it as '(:), not (':)
14:54:23 <Iceland_jack>     '(:) :: ∀χ. χ → [χ] → [x]
14:54:32 <Twey> Hm
14:54:35 <Iceland_jack> (which doesn't work either incidentally)
14:55:01 <Twey> I'm pretty sure it should be (':).  Infix you write it (x ': xs).
14:55:16 <Twey> It seems to be just the section that causes the parse error
14:55:20 <Iceland_jack> Yes but ' is not a part of the operator identifier
14:55:31 <EcoGiko> c_wraith: This http://askubuntu.com/questions/286764/how-to-install-haskell-platform-for-ubuntu-13-04 tells me not to symlink it. Do you have any other ideas how to make it work?
14:55:46 <Twey> But it always goes next to the identifier it's lifting
14:55:47 <c_wraith> EcoGiko: I'm trying to remember how I made it work.
14:57:15 <mm_freak> i'm mad at vincent
14:57:31 <Cale> zerokarmaleft: actually, I'm silly, your program seems to work?
14:57:32 <mm_freak> cprng-aes used to be such a great library, before it got all those impurities =(
14:57:48 <Iceland_jack> Twey: That's the syntax used in the paper, I'm unable to write any example code where type operators are written as type functions with the apostrophe
14:57:59 <mm_freak> it exposes a pure interface, so you expect it to be deterministic, but your code randomly breaks, because vincent thought that impure reseeding would be a good idea
14:58:10 <Twey> Yeah, I can't find a way to do it either
14:58:21 <Twey> Maybe GHC doesn't support it?
14:58:36 <zerokarmaleft> Cale: it does, but stdout doesn't "update" until the bottom falls out
14:58:42 <Iceland_jack> That's possible
14:58:44 <zerokarmaleft> oh derp, maybe I need to turn off buffering for stdout also
14:58:47 <Cale> zerokarmaleft: It doesn't?
14:58:58 <Cale> zerokarmaleft: Maybe you have output buffering somehow?
14:59:12 <Iceland_jack> Twey: Hm, odd :)
14:59:19 <Twey> Indeed
14:59:50 <Grant_> With cabal, can the main file also be a module?
15:00:38 <Iceland_jack> I tried changing something like
15:00:38 <Iceland_jack>     ... :: a -> H as -> H (a ': as)
15:00:38 <Iceland_jack> to
15:00:38 <Iceland_jack>     ... :: a -> H as -> H ((:) a as)
15:00:40 <zerokarmaleft> Cale: that was it heh
15:00:41 <Iceland_jack>     ... :: a -> H as -> H ('(:) a as)
15:00:46 <Iceland_jack>     ... :: a -> H as -> H ((':) a as)
15:00:49 <Iceland_jack>  
15:00:49 <Iceland_jack> but they all failed
15:03:00 <c_wraith> EcoGiko: It seems I symlinked libgmp.so.3 to libgmp.so.10.0.5
15:03:07 <c_wraith> EcoGiko: and it's working just fine for me
15:03:24 <EcoGiko> c_wraith: That seems to be the solution the internet is providing me with as well
15:03:52 <c_wraith> EcoGiko: sorry it took me so long to answer that. I totally forget the name of ldd. :)
15:04:08 <EcoGiko> c_wraith: no problem, thanks for the help!
15:10:12 <EcoGiko> c_wraith: Hmm I don't have /usr/lib/x86_64-linux-gnu/libgmp.so.10 directory
15:10:48 <c_wraith> EcoGiko: well..  install it?  That one should be available via apt
15:12:03 <EcoGiko> c_wraith: I already have
15:12:08 <EcoGiko> c_wraith: libgmp3-dev
15:12:35 <mm_freak> is there a trend in observable sharing?
15:12:37 <c_wraith> then figure out where it put its so file, I guess
15:12:57 <mm_freak> i need a graph data structure with observable sharing
15:13:28 <roshan> Hi everyone! Does anybody remember a website from a while ago that had a one-page summary of the worker/wrapper transformation? I think it was called worker-wrapper.org or something like that, but I can't find it now
15:13:51 <lpsmith> hmm,  a concurrent hashtable would actually be pretty useful for me
15:14:13 <lpsmith> or an stm hashtable
15:14:38 <mm_freak> lpsmith: does it have to be a table?  there is HashMap, which you can wrap in a TVar
15:17:07 <c_wraith> mm_freak: that's not a concurrent data structure, though.  It's serial access to a persistent data structure
15:18:11 <Grant_> Best QuickCheck tutorial recommendations?
15:19:06 <Iceland_jack> Grant_: I would watch the Chalmers intro to FP recordings
15:19:11 <Iceland_jack> they cover QuickCheck quite indepth
15:19:58 <lpsmith> mm_freak, yeah what c_wraith said.   I suppose it doesn't necessarily have to be a hashtable,  a tree might be ok too.
15:20:22 <lpsmith> A tree might be a bit more difficult to make reasonably efficient,  IDK
15:20:27 <EcoGiko> c_wraith: I had to install libgmp3c2 and now its working, no symlink no nothing
15:20:36 <c_wraith> EcoGiko: ah, nice
15:21:53 <artyomkazak> roshan: it's workerwrapper.com , but it's unavailable right now
15:21:56 <artyomkazak> roshan: http://web.archive.org/web/20130214061623/http://www.workerwrapper.com/
15:22:49 <lpsmith> So there's some LGPL stuff on hackage that looks possibly in the right ballpark-ish
15:23:22 <lpsmith> And edwardk's thash,  which appears to be almost totally unused.
15:23:37 <roshan> artyomkazak: Thanks! I couldn't even remember what the domain name was, and google failed me
15:23:40 <Grant_> Is there a good or standard way to test parsec parsers with quickcheck?
15:23:44 <EcoGiko> I still can't build alex 3.0.5 :/
15:24:14 <lpsmith> and a GSOC project that unfortunately didn't work out.
15:24:46 <artyomkazak> roshan: I googled “worker wrapper transformation site:*.com” out of random
15:25:10 <artyomkazak> no idea why it couldn't be found without that
15:27:59 <lpsmith> It'd be nice if the concurrent hash table would be resurrected.
15:28:07 <lpsmith> as another GSOC project
15:29:33 <mm_freak> c_wraith, lpsmith:  you can always do this:  TVar (HashMap K (TVar A))
15:30:00 <c_wraith> mm_freak: that'll still cause all in-flight transactions to retry when you insert an element
15:30:27 <mm_freak> sure…  i don't think there is a ready-made solution
15:32:01 <enthropy> @hackage LVish
15:32:01 <lambdabot> http://hackage.haskell.org/package/LVish
15:32:16 <enthropy> http://hackage.haskell.org/package/lvish
15:32:31 <ReinH> enthropy: lvish,  while pretty damn cool, isn't really production-ready imo
15:32:46 <ReinH> well, I haven't looked at it in a couple months, so I would love to be wrong
15:32:47 <enthropy> they don't have a hashmap, but the rest of it might apply?
15:32:58 <ReinH> enthropy: the issue with LVars is observability
15:33:53 <bitemyapp> ReinH: probably more production ready than what I see most node.js users up to.
15:34:44 <ReinH> bitemyapp: that's neither true nor helpful :p
15:35:08 <bitemyapp> :)
15:35:19 <ReinH> It's not that it's broken, it's that it is difficult to use practically, or was the last time I talked to Lindsey about it
15:37:12 <ReinH> But anyway it's a very cool model for concurrent data structures and you should check it out anyway :p
15:41:40 <bitemyapp> ReinH: lots to learn from it.
15:43:33 <Peaker> Writing non-trivial Parsec parsers is much more subtle and less obvious than I thought
15:44:08 <Peaker> especially when handling "include" files via parser state push/pop was involved
15:52:46 <Peaker> having a precise whitespace policy, who eats what kind of whitespace, handling newlines, include-directive-anywhere, eof->stack-pop, lines that end with or without eof, tons of subtleties to get correct
15:53:13 <Peaker> mostly the stuff that you would expect a tokenizer to handle, heh
15:53:18 <c_wraith> Peaker: a pattern that people often use to simplify stuff is using parsec twice
15:53:24 <c_wraith> the first pass only lexes
15:53:30 <dagnachew> is there a place to see web apps made with haskell ?
15:53:41 <Peaker> yeah, I was tempted to do that, but I worried about how cumbersome it would be, to preserve file locations, etc.
15:53:42 <c_wraith> the second pass operates on a stream of tokens, rather than the raw character stream
15:53:55 <Peaker> c_wraith: I couldn't find examples of this, either
15:56:05 <ReinH> c_wraith: huh hadn't thought of using parsec for both stages, interesting
15:56:21 <ReinH> c_wraith: I too would be intersted in examples :)
15:56:32 <c_wraith> I forgot who said they did it commonly
15:56:50 <ReinH> c_wraith: well fat lot of good you are :p
15:56:55 <c_wraith> I know
15:57:00 <ReinH> jokes
16:00:41 <beaky> hello
16:00:56 <beaky> how do i program the stm32 with haskell
16:02:04 <sm> Peaker: Hledger.Read.JournalReader does those things, probably the hard way
16:02:32 <sm> (no tokenising step)
16:02:46 <monochrom> oh hi beaky again
16:02:47 <Peaker> sm: I too parse that way, but it was hard to get it right!
16:03:59 <monochrom> you design your token data structure to have fields for original filename, line number, and column number. the first pass fills in those fields. (do you know this already?)
16:05:04 <sm> yes
16:05:09 <sm> (Peaker)
16:05:24 <mm_freak> Peaker: i think that's supposed to be the advantage of trifecta
16:05:35 <mm_freak> Peaker: layout is an extension
16:05:47 <mm_freak> but i don't really understand trifecta myself =)
16:05:50 <sm> I have a parsec-specific trace function I wish I'd made sooner
16:05:51 <beaky> how do i understand monads better
16:06:04 <erisco> beaky, use them
16:06:30 <Peaker> mm_freak: but trifecta, uu-parsinglib, attoparsec, all do not support a monad transformer, only parsec does.  So to do textual include support properly, I need parsec, or a first stage to handle includes
16:06:32 <beaky> so far i only use the list monad
16:06:38 <erisco> beaky, or read about them, or write your own
16:06:57 <Peaker> beaky: you could avoid "do" notation in your IO part of the program to understand monadic binds better
16:07:06 <Peaker> beaky: (and everywhere else)
16:07:14 <mm_freak> Peaker: that's surprising
16:07:42 <beaky> chaining >>= is pretty ugly :D
16:07:48 --- mode: copumpkin set -o copumpkin
16:08:05 <Peaker> mm_freak: yeah, it was quite annoying to discover :(  btw, for include support, I need both IO-during-parsing and something that lets me set the parse position/string and then at eof set it back.  Which is a bit hacky, but what I do with parsec
16:08:07 <beaky> and  =<<  has lots of abuse potential :D
16:08:41 <erisco> beaky, it is not ugly if you can eta-reduce the argument
16:08:57 <Peaker> mm_freak: for restrictive "include", I could put a token "include here", but in Makefiles which I parse, "include" is allowed to change the parser state :(
16:09:20 <mm_freak> beaky: this is my XML code:  element "blah" >=> child >=> element "blubb" >=> attribute "zabb"
16:09:35 <Iceland_jack> Aesthetics also don't matter when you're learning about monads, you can switch back to do-notation afterwards
16:09:40 <mm_freak> if that's not beautiful, i should rethink my notion of beauty =)
16:10:03 <beaky> mm_freak: wow
16:10:12 <beaky> that reminds me of this haskell web framework templating thing
16:10:23 <mm_freak> beaky: blaze-html?
16:10:29 <beaky> yeah that one!
16:10:49 <beaky> or was it some other one...
16:10:55 <mm_freak> sure…  if a template depends on data, then it is a function of that data =)
16:11:02 <mm_freak> s/template/document/
16:11:14 <beaky> so templates are functors?
16:11:19 <mm_freak> functions
16:11:19 <beaky> oh wait
16:11:22 <beaky> right
16:11:24 <Iceland_jack> mm_freak: If only (>=>) didn't stick out quite so much :) I have no idea why the fishes aren't more pervasive though
16:11:47 <mm_freak> Iceland_jack: i'm used to the three-letter combinators for functors
16:11:55 <mm_freak> <*>, <$>, >>=, >=>, …
16:12:13 <mm_freak> occasionally you get nice two letters though =)
16:12:14 <Iceland_jack> Sure, it would just be very nice to be able to use (.) for Kleisli composition :)
16:12:24 <beaky> i wish i knew the names for <*> and >=>
16:12:24 <mm_freak> "open" *> thisHere <* "close"
16:12:25 <mm_freak> =)
16:12:47 <mm_freak> beaky: you could call them "apply" and "compose" respectively =)
16:12:48 <Iceland_jack> beaky: If only there were some way of finding out on a #haskell channel :)
16:13:06 <mm_freak> beaky: functors are all about fancy function application =)
16:13:15 * bennofs sometimes wishes there was an operator for Applicative f => (a -> f b) -> f () -> f b
16:13:36 <bennofs> I meant Applicative f => (a -> f b) -> f () -> a -> f b
16:13:45 <mm_freak> bennofs: what does it do?
16:13:49 <Iceland_jack> beaky: http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators and http://www.haskell.org/haskellwiki/Pronunciation
16:14:07 <mm_freak> bennofs: it's (>>=) with an extra argument as far as i can tell
16:14:18 <mm_freak> bennofs: so it doesn't quite fit Applicative
16:14:27 <mm_freak> oh wait
16:14:33 <mm_freak> sorry =)
16:14:47 <bennofs> It's \f x a -> f a <* x
16:14:49 * mgsloan calls >=> "fish"
16:15:08 <Iceland_jack> (>=>) and (<=<) are schools of fish (operators) and don't let anyone tell you otherwise :)
16:15:13 <bennofs> Or an operator for f >=> const g
16:15:14 <mm_freak> you could call most of them "fish"
16:15:21 <mgsloan> hahaha
16:15:31 <mm_freak> >>=, >=>
16:15:33 <Peaker> >=> <=< are fish, (:[]) is monkey
16:15:43 <Iceland_jack> mm_freak: What kind of fish is >>=?!
16:15:46 <mm_freak> and weird backwards fish for comonads:  =>>, =>=, …
16:15:54 <Peaker> cofish
16:15:56 <mm_freak> Iceland_jack: use your imagination =P
16:15:58 <bennofs> =>> is the rocket operator
16:16:12 <Iceland_jack> mm_freak: It's more of a fish you've cut in two alraedy
16:16:19 <mm_freak> bennofs: that fits actually…  =>> can make your pictures explode =)
16:16:25 <djahandarie> Comonads, for when you want to safely launch missiles.
16:16:26 <mm_freak> (=>> explode)
16:16:29 <hpc> >=====>
16:16:31 <hpc> the Arapaima operator
16:16:34 * Iceland_jack goes cofishing
16:16:45 <mm_freak> Iceland_jack: no, cofishing goes you
16:16:54 <Iceland_jack> :)
16:16:58 <bennofs> cofishing in semilakes?
16:17:25 <Fuuzetsu> why does this channel always eventually end up at co-jokes?
16:17:41 <Iceland_jack> Fuuzetsu: What do category theorists drink on a cold winter night?
16:17:44 <mm_freak> Fuuzetsu: because we turn cotheorems into ffee
16:17:47 <Iceland_jack>     A: Hot a.
16:17:50 <hpc> Fuuzetsu: it's the logical course of co-nversation
16:18:05 <bennofs> because we all love CO-mputer science :)
16:18:13 <Fuuzetsu> I immediately regret by decision to say anything.
16:18:16 <Fuuzetsu> my*
16:18:24 <mm_freak> stop mputing already!
16:19:36 <mm_freak> the latest type theory is so HoTT!  mputation is obsolete =)
16:20:54 <mgsloan> a.k.a. counivalent homputation
16:21:34 <djahandarie> @remember #haskell < Fuuzetsu> why does this channel always eventually end up at co-jokes? < Iceland_jack> Fuuzetsu: What do category theorists drink on a cold winter night? < mm_freak> Fuuzetsu: because we turn cotheorems into ffee < Iceland_jack>     A: Hot a. < hpc> Fuuzetsu: it's the logical course of co-nversation < bennofs> because we all love CO-mputer science :) < Fuuzetsu> I immediately regret my decision to say anything.
16:21:34 <lambdabot> I will remember.
16:23:46 * hackagebot shelly 1.4.4.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.4.2 (GregWeber)
16:42:23 <haasn> hpc: co-urse
16:42:40 * geekosaur runs for co-ver
16:42:47 <Iceland_jack> oh dear
16:46:37 <monochrom> hahaha
16:46:56 <monochrom> eh? lw is at U of Toronto?
16:58:29 <mrmonday> Is there some way to get signalling NaN's in haskell? aka make my program die the second a NaN exists so I can track it down?
17:00:59 <haasn> mrmonday: I don't think Haskell lets you install any handlers or semantics for when computations result in NaN, but it should be possible to at least use isNaN to check for NaNs
17:01:16 <mrmonday> hmm, ok
17:01:42 <mrmonday> that doesn't help too much unless I litter my code with isNaN unfortunately
17:01:45 <haasn> worst case scenario I guess you could wrap everything in some “traceNaN :: RealFloat a => a -> a; traceNaN x | isNaN x = error "NaN!" | otherwise = x
17:02:17 <mrmonday> haasn: I may do that, thanks
17:02:21 <haasn> mrmonday: I think a better idea would be to wrap functions that can result in NaN, like sqrt/division/log etc.
17:02:33 <haasn> and make them throw errors instead of returning NaN
17:02:46 <mrmonday> ooh, that'd probably work
17:04:57 <mrmonday> it'd be cool if there was a way to do that automatically without wrapping everything manually
17:06:11 <pavonia> mrmonday: You could create a newtype with a Num instance that throws an exception whenever a NaN occurs
17:14:20 <mrmonday> pavonia: not a bad idea either, thank you :)
17:14:34 <tikhon> hey, has anyone here used HaRe?
17:33:14 <ReinH> djahandarie: nice one
17:39:28 <Eduard_Munteanu> Is there some way to leverage Safe Haskell when installing random packages with cabal install / using installed packages?
17:40:10 <Eduard_Munteanu> More specifically, I'm interested if Safe Haskell can be enabled by default somehow.
17:41:02 <simlay> Is there something like virtualenv/rbenv for haskell?
17:41:11 <geekosaur> hsenv
17:41:29 <simlay> geekosaur: Logically named.
17:41:38 <bitemyapp> simlay: you don't want hsenv
17:41:47 <bitemyapp> simlay: you want cabal sandbox, which comes with 1.18 automatically.
17:42:00 <simlay> Interesting.
17:42:08 <bitemyapp> if you don't have cabal and cabal-install 1.18, then `cabal update && cabal install cabal-install`
17:42:11 <geekosaur> also if your cabal-install is up to date it has sandboxes, although that virtualizes only user packages; hsenv virtualizes an entire installation
17:42:19 <bitemyapp> there is that.
17:42:35 <geekosaur> which you may want if you're playing with multiple versions of the platform or the bleeding edge version of yesod or etc
17:42:53 <bitemyapp> right.
17:45:17 <simlay> Oh. So, if I have 1.18, using cabal install has it already sandboxed?
17:46:17 <simlay> Yes. That's what your words mean.
17:46:19 <simlay> That's cool.
17:49:11 <bitemyapp> simlay: not already sandboxed
17:49:12 <simlay> `cabal install text` is broken for me on osx.
17:49:14 <simlay> http://pastebin.com/K64p2uKz
17:49:21 <bitemyapp> simlay: you have to use cabal sandbox init to use a sandbox.
17:49:24 <simlay> Ah.
17:49:31 <geekosaur> simlay: see /topic, that's xcode 5
17:49:51 <geekosaur> apple uses a preprocessor that doesn't appreciate being run on haskell source, there's a patch
17:49:52 <simlay> Ah.
17:50:08 <simlay> Cool.
17:50:14 <simlay> Thanks.
17:50:16 <geekosaur> (also we should really not be using a C preprocessor on haskell, but that ship sailed...)
17:51:28 <Eduard_Munteanu> Well, can't TH do what CPP does?
17:52:00 <geekosaur> it can't easily get at the version information cabal pulled for the dependencies it chose
17:52:16 <geekosaur> which cabal exports as cpp macros
17:52:51 <geekosaur> also cpp works on more platforms than TH does
17:53:10 <Eduard_Munteanu> geekosaur: hm, didn't know TH was platform-dependent
17:53:44 <geekosaur> that is changing in 7.8, I think, but for example there's no working TH on ARM except in some private builds
17:53:48 <geekosaur> which have their own problems
17:54:02 <tapuu> I have a question about monadfix
17:54:54 <ReinH> tapuu: perhaps you should ask it then :)
17:55:12 <tapuu> Is it possible to make a dyadic monadfix? I have two IO actions that need each other's arguments
17:55:23 <tapuu> Each other's results, I mean
17:55:37 <geekosaur> (basically in 7.6 and earlier ghci and TH rely on a custom loader built into the bytecode backend to load modules at runtime, not all platforms have code for that loader)
17:56:15 <Eduard_Munteanu> tapuu: what do you mean dyadic?
17:56:48 <tapuu> Eduard_Munteanu: Like a polyvariadic fix-point combinator but for just two functions
17:56:51 <DarkLinkXXXX> I can't build parsec as root for some reason.
17:57:14 <sipa> tapuu: fix \(f,g) -> f . g
17:57:48 <tapuu> sipa: I need one that uses mfix
17:57:51 <sipa> hmm, for monadic actions, unsure
17:58:22 <Eduard_Munteanu> FWIW, I think 'fix' is nicer even for monadic stuff.
17:58:29 <tapuu> Is there a different way to solve the problem of two IO actions that need each other's results
18:03:15 <tapuu> I've tried using this but it doesnt seem to work http://lpaste.net/100553
18:04:32 <pavonia> tapuu: What is your use case?
18:04:47 <jle`> Twey: hi
18:05:10 <jle`> Twey: i'm trying to write a huffman compressor as a toy/demonstration project
18:05:11 <dhrosa> @src msum :: [Maybe a] -> Maybe a
18:05:11 <lambdabot> Source not found. I am sorry.
18:05:23 <tapuu> pavonia: I'm using async, I need to create 2 async actions that are able to cancel each other
18:05:24 <dhrosa> hmm, how do I look up the source of a certain implementation?
18:05:29 <jle`> Twey: and part of it involves bit-level consumption and production
18:05:34 <haasn> dhrosa: using hackage is your best bet
18:05:37 <dhrosa> @src mconcat :: [Maybe a] -> Maybe a
18:05:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:05:48 <haasn> msum = foldr mplus mzero
18:05:52 <haasn> dhrosa: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#msum
18:06:16 <jle`> Twey: I saw that Data.Binary does 'lazy io' in that sense but it's not too reliable, isn't it?  can i use pipes to work with bit-order IO (production and consumption)
18:06:20 <Guest22743> \pl fmap (lst !!) $ randomRIO (0, length lst - 1)
18:06:22 <dhrosa> I searched for the wrong thing, I know how msum works, but I wanted to see the source for the Monoid instance of Maybe
18:06:42 <haasn> @src Monoid Maybe
18:06:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:07:01 <Guest22743> pl \lst-> fmap (lst !!) $ randomRIO (0, length lst - 1)
18:07:02 <dhrosa> actually now that I think about it I think there's multilple monoids for maybe
18:07:06 <haasn> dhrosa: it's at http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Monoid.html#Monoid
18:07:10 <jle`> dhrosa: there's only one non-wrapped one
18:07:17 <jle`> but there are several newtype monoid instances
18:07:20 <haasn> dhrosa: search for Monoid (Maybe a)
18:07:29 <jle`> the default one basically mappends what is inside the maybes
18:07:39 <jle`> and ignores Nothings
18:08:26 <lpsmith> tapuu,  you probably need to either use a irrefutable pattern,  or change it to use fst and snd
18:09:07 <lpsmith> tapuu:  http://lpaste.net/100553
18:09:10 <silasm> the monoid instance for maybe should really require that its argument be a Semigroup...
18:09:49 <silasm> as opposed to requiring an identity for that argument.
18:09:55 <tapuu> lpsmith: I'll try that, thanks
18:11:00 <lpsmith> tapuu, I edited again, to show the three variants.    The latter two should work.
18:11:18 <tapuu> lpsmith: Holy shit, it works
18:11:23 <tapuu> lpsmith: thank you
18:11:26 <jle`> silasm: yeah, that makes more sense.
18:11:37 <jle`> there are people that believe that First should be the default monoid instance too
18:11:48 <lpsmith> tapuu, np :)
18:11:54 <prophile> speaking of monoid instances
18:11:58 <jle`> but we already have that with the other monoid operator (<|>)
18:12:01 <jle`> monoidal
18:12:02 <prophile> where would be the place to report a bug in Data.Monoid
18:12:15 <prophile> (or in base more generally I guess)
18:12:44 <silasm> @src (<|>)
18:12:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:13:31 <mm_freak> is that funny or just stupid?
18:14:34 <DarkLinkXXXX> As root, I try to build cabal-install as root, but I'm getting /usr/bin/ld: cannot find -lHSmtl-2.1.2-ghc7.9.20140217
18:23:02 <hcaulfield57> Could someone explain to me why in the following program http://lpaste.net/100551 'modify' updates the current state of the monad on each sucessive call to loop (line 7) I assumed that the monads scope would be 'reset' on each call to the function
18:26:12 <jle`> haasn: the state persists within the same runState
18:26:20 <jle`> sorry, hcaulfield57
18:26:53 <jle`> that's the whole point of runState
18:27:01 <jle`> if you look in the definition of (>>=) for State
18:27:16 <jle`> the whole point is that you can compose different State functions to work on the same State
18:27:39 <jle`> the second State should be lowercase
18:29:42 <hcaulfield57> Let me look up the definition of bind, one second
18:32:20 <mm_freak> not sure if State really has a point =)
18:32:52 <mm_freak> step 26 to becoming a haskeller:  you stop using State =)
18:33:19 <tapuu> I need to catch an IO error and do different things depending on its type, does anyone have a good example of this?
18:33:36 <mm_freak> tapuu: you can do that with 'catch'
18:33:48 <mm_freak> a `catch` f1 `catch` f2 `catch` f3
18:34:04 <mm_freak> f1 :: IOException -> IO X
18:34:11 <mm_freak> f2 :: ArithException -> IO X
18:34:15 <tapuu> mm_freak: What would
18:34:29 <tapuu> mm_freak: that make sense, thank you
18:34:47 <mm_freak> let me verify that `catch` is actually left-associative
18:34:58 <mm_freak> well, it has to be
18:35:02 <mm_freak> otherwise it's a type error =)
18:35:23 <hcaulfield57> mm_freak: I'm not at that point yet :)
18:35:29 <tapuu> mm_freak: Arent backtick functions always left-associative?
18:36:02 <mm_freak> hcaulfield57: i'm just joking =)
18:36:14 <hindleymilner> :t asTypeOf
18:36:15 <lambdabot> a -> a -> a
18:36:18 <mm_freak> tapuu: no, you can set their infix properties just like for every other infix operator
18:36:19 <hindleymilner> @src asTypeOf
18:36:19 <lambdabot> asTypeOf = const
18:36:21 <hindleymilner> :t const
18:36:22 <lambdabot> a -> b -> a
18:36:26 <hindleymilner> wat.
18:36:31 <mm_freak> infixl 1 `catch`
18:36:34 <geekosaur> I think they're infix 5 (nonassociative) by default
18:36:42 <tapuu> mm_freak: I had no idea you could do that
18:36:48 <hcaulfield57> I'm not sure I understand it, so the state remains the same with >>= so it keeps passing around the state between function calls?
18:36:50 <jle`> hcaulfield57: so the idea is that
18:36:52 <geekosaur> but you can have an infix declaration for backticked functions
18:36:59 <mm_freak> ok, in that case you have to write ((a `catch` f1) `catch` f2) `catch` f3
18:37:03 <jle`> State is just a function  s -> (a, s)
18:37:07 <mm_freak> remember that SomeException is catch-all
18:37:16 <jle`> the newtype wrapper is only there because of implementation
18:37:20 <mm_freak> so f3 has to be the SomeException catcher, if you want that
18:37:27 <jle`> so i have two functions s -> (a, s) and s -> (a, s)
18:37:34 <jle`> and i want to combine them in a meaningful way
18:37:42 <jle`> that is, i want to use the state result of the first one as the state of the second one
18:37:48 <jle`> that is what >> is for
18:37:52 <jle`> well
18:37:55 <jle`> you can do it by hand, as well
18:37:57 <jle`> using pattern matching
18:38:10 <jle`> so you can imagine a "doFirstThenSecond"
18:38:24 <jle`> doFirstThenNext :: (s -> (a,s)) -> (s -> (a,s)) -> (s -> (a,s))
18:38:30 <jle`> which takes two s -> (a, s)
18:38:36 <jle`> and returns a new big fat s -> (a, s)
18:38:44 <jle`> that is the composition of the first two
18:38:50 <jle`> with semantic meaning
18:39:04 <jle`> that you run the given state on the first, take the resulting state, and use that for the second, and return the result of the second
18:39:05 <lpsmith> tapuu, mm_freak,  you might be better off using catches
18:39:18 <jle`> so if you understnad doFirstThenNext
18:39:22 <jle`> you should be able to implement it yourself
18:39:31 <jle`> try it :)
18:39:37 <lpsmith> I don't like the syntax, admittedly  (then again I'm not a big fan of the plain catch syntax either),   but there are some real advantages to using it.
18:39:37 <jle`> doFirstThenNext f1 f2 = ...
18:39:47 <jle`> do it using normal functions s -> (a, s), without worrying about State
18:40:07 <jle`> if you do, you will be implementing (>>) for State
18:40:23 <jle`> the reason we have State is that you can't define (>>=) and (>>) etc. for naked functions like (s -> (a, s))
18:40:27 <lpsmith> tapuu, mm_freak oops forgot the link file:///usr/local/hs/ghc-7.6.3/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Exception.html#v:catches
18:40:33 <lpsmith> haha
18:40:33 <hcaulfield57> jle`: I think I understand what you said so far, but I guess I imagine that the whole state would reset itself on each function call, like automatic vairables in C
18:40:47 <geekosaur> lpsmith, errrr...
18:41:08 <jle`> okay, so imagine you have implemeneted doFirstTHenNext, and called it (>>)
18:41:26 <jle`> then f1 >> f2 would basically thread the resulting state of f1 into the input of f2
18:41:33 <jle`> and then you could say, f12 = f1 >> f2
18:41:39 <lpsmith> geekosaur, yeah my bad =)
18:41:40 <jle`> now, you also have an f3
18:41:45 <jle`> and you could do f1 >> f2 >> f3
18:41:46 <jle`> OR
18:41:50 <jle`> you can do f12 >> f3
18:41:52 <jle`> right?
18:41:56 <mm_freak> hcaulfield57: you might do yourself a favor by ignoring that State is a monad…  instead do this:  type State s a = s -> (a, s)
18:42:09 <mm_freak> hcaulfield57: then write functions that compose State-like functions =)
18:42:23 <mm_freak> andThen :: State s a -> State s b -> State s b
18:42:26 <jle`> what would f1 >> f2 >> f3 would take the resulting state of f1, give it to f2; f2 to f3 and give it. etc.
18:42:30 <lpsmith> correct link:   http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Control-Exception.html#v:catches
18:42:36 <jle`> listen to mm_freak too :)
18:42:43 <jle`> the monadness of State really hindered my understanding of it
18:42:47 <mm_freak> which is then really just this:  andThen :: (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
18:42:49 <jle`> i just use (>>) because it's easy to type :)
18:43:07 <hcaulfield57> But where does that happen in the code, in modify? runState?
18:43:22 <mm_freak> hcaulfield57: if you implement it yourself, it will become clear =)
18:43:25 <jle`> runState is an implementation detail
18:43:44 <hcaulfield57> Okay, I'll give it a shot
18:43:50 <mm_freak> runState isn't even an implementation detail…  if it weren't for the State constructor, 'runState' would be 'id'
18:43:50 <tapuu> mm_freak: I'm trying to use catch like you said but I'm getting this error: Illegal type signature: `AsyncException`
18:44:03 <jle`> it's because we need a newtype
18:44:18 <jle`> to instance it as anything
18:44:25 <mm_freak> tapuu: what lpsmith said
18:44:32 <jle`> ideally we wouldn't even need the newtype and we'd juse use things like andThen :: (s -> (a, s) -> ...
18:44:36 <jle`> and you don't need runState
18:44:44 <jle`> you can just use (f1 `andThen` f2) s0
18:45:19 <jle`> remember that when you use >>, andThen, etc.
18:45:28 <jle`> you are composing s -> (a, s)'s
18:45:36 <jle`> into one *big*/giant s -> (a, s)
18:45:39 <mm_freak> jle`: allow hcaulfield57 to figure it out =)
18:45:56 <mm_freak> implementing State usually makes it click
18:46:04 <jle`> mm_freak: ah. yeah that is probably the best way here
18:46:16 <jle`> this is usually your method of dealing with me :P
18:46:20 <mm_freak> ;)
18:46:23 <jle`> ;D
18:46:25 <jle`> have to go anyway
18:46:33 <jle`> good luck hcaulfield57
18:46:33 <no-n> #haskeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeell
18:46:47 <ij> I'm checking out happstack-lite. If you were to make a fairly sizable web app, would the ton of includes and pragmas would typically end up in a lot of files? How much of a problem does it ever become?
18:47:22 <jle`> oh, i'll leave one thing here
18:47:27 <jle`> remember referential transparency
18:47:37 <jle`> if you define f12 = f1 `andThen` f2
18:47:42 <jle`> then f12 `andThen` f12
18:47:44 <jle`> has to be equivalent
18:47:54 <jle`> to f1 `andThen` f2 `andThen` f1 `andThen` f2
18:47:59 <jle`> they have to be indistinguishable
18:48:02 <mm_freak> don't worry, purity will slap hcaulfield57 in the face when their assumptions are wrong =)
18:48:17 <stepkut> ij: why would imports and pragmas be a problem?
18:48:38 <haasn> jle`: assuming associativity of `andThen`?
18:49:07 <hcaulfield57> I'm stumped with where to even begin
18:49:08 <ij> stepkut, well, they're a lot of stuff, that doesn't matter for me. I'm wondering whether it's possible for it to not be there.
18:49:22 <mm_freak> hcaulfield57: begin with this:  newtype State s a = State (s -> (a, s))
18:49:30 <mm_freak> hcaulfield57: then write a Functor instance for that one
18:49:31 <stepkut> ij: if you don't need it -- why would you put it there in the first place?
18:49:38 <hcaulfield57> Okay, lemme try
18:49:41 <ij> The compiler needs it.
18:51:29 <stepkut> ij: if the compiler needs it... then I am not sure what you mean by "doesn't matter to me".. it sounds like it does matter..
18:52:16 <haasn> you could probably set pragmas globally in your .cabal, but I'm not sure that's the best of ideas
18:52:36 <haasn> you could also define your own module that re-exports the imports you often need
18:52:41 <haasn> and import that throughout your code
18:53:29 <haasn> ij: are you worried about code size only? or confusion factor when opening a file?
18:53:41 <tapuu> Does GHC 7.8 RC2 have the new IO manager?
18:53:58 <stepkut> haasn: one downside of putting the pragmas only in the .cabal is that it is then difficult to load the modules into ghci (though easier these days than it used to be due to cabal aware ghci something or other)
18:54:15 <haasn> stepkut: cabal repl yeah
18:54:17 <stepkut> tapuu: yes
18:54:26 <hcaulfield57> I'm stumped haha
18:54:34 <hcaulfield57> fmap f s = State (\x -> (f x, s))
18:54:34 <mm_freak> hcaulfield57: what have you got so far?
18:54:36 <hcaulfield57> Does not work
18:54:39 <ij> haasn, No, I just liked to know whether I can hide it somehow, so i'm reading about that reimporting now.
18:54:44 <tapuu> stepkut: thanks
18:54:49 <mm_freak> hcaulfield57: http://lpaste.net/
18:55:00 <haasn> hcaulfield57: paste it along with the error you get on the site mm_freak linked :)
18:55:01 <mm_freak> paste your code and lets see how to fix it =)
18:55:07 <haasn> (the full error)
18:55:42 <haasn> ij: you could hide it in an editor that supports collapsing by collapsing the pragmas and imports sections
18:55:48 <haasn> this seems like an editor thing, at any rate
18:56:05 <hcaulfield57> http://lpaste.net/100557
18:56:22 <haasn> hcaulfield57: and the error?
18:56:34 <mm_freak> hcaulfield57: what's the argument of your transition function?
18:57:05 <hcaulfield57> http://lpaste.net/100557
18:57:06 <mm_freak> i.e. what you called "x"…  what's your interpretation of this x variable?
18:57:19 <mm_freak> haasn: it's ok, the error is obvious =)
18:57:30 <hcaulfield57> I'm not sure,
18:57:47 <haasn> mm_freak: is it? :)
18:57:56 <mm_freak> hcaulfield57: ok, what is the second argument to fmap?  in words
18:58:25 <hcaulfield57> A newtype State
18:58:40 <mm_freak> sorry, i don't understand "newtype"…  use english =)
18:58:51 <haasn> mm_freak: (the first time I looked at it I thought the error was something else! :( to be fair I am extremely tired)
18:59:11 <mm_freak> haasn: i've seen that error many times in my haskell workshops =)
18:59:23 <hcaulfield57> The function (s -> (a,s)) right?
18:59:41 <mm_freak> hcaulfield57: almost, yeah, but use words
18:59:42 <hcaulfield57> wrapped in State I guess
18:59:45 <mm_freak> it's a …?
18:59:54 <mm_freak> what's your interpretation of a State value?
19:00:14 <hcaulfield57> A function that takes a value, and returns a tuple.
19:00:52 <mm_freak> hcaulfield57: and what is the semantics?  obviously you want to model stateful computations, so what's the semantics of such a function?
19:01:10 <hcaulfield57> You pass the initial state?
19:01:30 <mm_freak> and you get the final state and a result…  it's a state transition function
19:02:02 <mm_freak> so from now on call State values transition functions =)
19:02:25 <mm_freak> now try again:  the second argument is a …?
19:02:38 <hcaulfield57> a transition function?
19:02:42 <mm_freak> yeah
19:02:46 <mm_freak> and what is fmap's result?
19:03:19 <hcaulfield57> I'm not sure, would you want fmap to modify the initial state passed?
19:03:31 <mm_freak> think simple
19:03:33 <mm_freak> it's …?
19:03:54 <hcaulfield57> It's another transition function, or State ...
19:04:04 <mm_freak> those are exactly the words i wanted to read =)
19:04:19 <mm_freak> what is the relationship between the argument TF and the resulting TF?
19:04:28 <haasn> “TF” :(
19:04:43 <mm_freak> haasn: was that an unintentional pun?
19:04:51 <mm_freak> oh, of course
19:04:53 <mm_freak> d'oh =)
19:05:19 <hcaulfield57> The state can be different?
19:05:24 <mm_freak> hcaulfield57: can it?
19:05:45 <mm_freak> hcaulfield57: if you're not sure how to answer this, look at fmap's type
19:05:46 <mm_freak> what's its type?
19:06:05 <hcaulfield57> (a -> b) -> f a -> f b
19:06:11 <mm_freak> and what is f?
19:06:25 <hcaulfield57> The transition function
19:06:30 <mm_freak> f is a type
19:06:34 <mm_freak> not a value =)
19:06:40 <mm_freak> f = ?
19:06:46 <hcaulfield57> State s
19:07:00 <mm_freak> yeah, so give a more precise type siganture for fmap
19:07:04 <mm_freak> signature
19:07:14 <hcaulfield57> So the state can't change ? (a -> b) -> State s a -> State s b
19:07:41 <mm_freak> the type is correct, and the state can change, but ignore state for now…  what's the relationship between the argument State value and the result?
19:07:53 <mm_freak> look at the type =)
19:08:21 <hcaulfield57> The can change?
19:08:41 <mm_freak> the resulting transition function is the argument transition with …?
19:09:09 <hcaulfield57> im not sure
19:09:21 <mm_freak> why are you taking a function of type a -> b as first argument?
19:09:36 <hcaulfield57> To apply it to the a in State s a
19:09:57 <mm_freak> and the 'a' is what feature of the transition function?
19:10:18 <hcaulfield57> the result?
19:10:22 <mm_freak> exactly
19:10:27 <mm_freak> now complete the sentence =)
19:10:30 <mm_freak> the resulting transition function is the argument transition with …?
19:11:30 <hcaulfield57> (a -> b )
19:11:40 <mm_freak> that's not a sentence =)
19:11:51 <hcaulfield57>  …?
19:11:56 <hcaulfield57> Ooops
19:12:25 <hcaulfield57> The resulting transition function is the argument transition with (a -> b) ?
19:12:54 <mm_freak> i don't understand what you're saying there…  i'm almost a layman, but i do understand transition functions
19:13:06 <mm_freak> tell me what i can use fmap for
19:13:22 <hcaulfield57> To modify the result of a transition function?
19:13:27 <mm_freak> great
19:13:39 <mm_freak> so the resulting transition function is the original transition function, but with …
19:14:38 <hcaulfield57> the results passed through the function that fmap took
19:14:41 <haasn> :)
19:14:45 <mm_freak> there you go =)
19:15:00 <mm_freak> so the argument is a transition function
19:15:04 <mm_freak> fmap f (State g) = …
19:15:09 <mm_freak> the result is also a transition function
19:15:15 <mm_freak> fmap f (State g) = State $ \s -> …
19:15:38 <hcaulfield57> (f s, g) ?
19:15:51 <mm_freak> it's the same as g, but it applies f to the /result/ (not the state!)
19:16:05 <mm_freak> fmap f (State g) = State $ \s0 -> let (x, s1) = g s0 in (f x, s1)
19:16:28 <mm_freak> does that make sense?
19:16:30 <haasn> (if only we defined State as s -> (s,a) instead of s -> (a,s), grrrr)
19:17:12 <haasn> (then we could use fmap f (State g) = State (fmap f . g))
19:17:25 <haasn> fmap (fmap f) g ;)
19:17:35 <mm_freak> haasn: if only the haskell platform would support that very well
19:17:41 <mm_freak> random, unfoldr, …
19:17:48 <shachaf> haasn: fmap fmap fmap f g
19:17:50 <mm_freak> they are all state-right-biased
19:18:15 <shachaf> unfoldr's type is reasonable.
19:18:36 <haasn> shachaf: perfect
19:18:38 <shachaf> Since [a] = Fix (Maybe . (a,))
19:18:48 <hcaulfield57> Yea I think it makes sense
19:18:49 <mm_freak> shachaf: unfoldr pretty much models StateT over Maybe
19:18:51 <haasn> shachaf: now we just drop the State and fmap = fmap fmap fmap
19:19:00 <mm_freak> shachaf: so by that logic State is reasonable, too =)
19:19:13 <mm_freak> hcaulfield57: great…  your next task is to switch to Reader
19:19:21 <mm_freak> hcaulfield57: and for that one you will implement a Monad instance =)
19:19:34 <mm_freak> hcaulfield57: here is how you start:  newtype Reader e a = Reader (e -> a)
19:19:42 <shachaf> State s = (s ->) . (s,)
19:19:42 <mm_freak> begin with Functor again
19:20:04 <mm_freak> and once you have Functor working, try Monad =)
19:27:58 <hcaulfield57> I think this works, http://lpaste.net/100559
19:28:05 <LamdaFan> I recall seeing a monad that modeled the ability to have two actions, and executing the second only if the first succeeded. What's the name of this Monad?
19:28:09 <hcaulfield57> We apply the function, then apply the function to the result
19:28:32 <mm_freak> hcaulfield57: yeah, that's correct
19:28:37 <mm_freak> hcaulfield57: can you do it without the 'let'?
19:28:40 <ephess> I'm going through LYAH at the moment, but could use some exercises. I don't suppose anyone is able to recommend some good haskell exercises with solutions?
19:29:05 <mm_freak> LamdaFan: can you give an example?
19:29:32 <hcaulfield57> fmap f (Reader e) = Reader $ \x -> f $ e x
19:29:49 <mm_freak> hcaulfield57: great…  can you write it even shorter?
19:30:40 <enthropy> > (do Nothing; Just 1, do Just 1)
19:30:41 <lambdabot>  (Nothing,Just 1)
19:30:42 <hcaulfield57>  fmap f (Reader e) = Reader $ f . e
19:30:48 <mm_freak> hcaulfield57: perfect
19:30:52 <mm_freak> well, almost
19:30:59 <hcaulfield57> In this case the e in Reader is a function, yes?
19:31:04 <mm_freak> i would rename 'e' to 'g' =)
19:31:05 <mm_freak> yeah
19:31:07 <LamdaFan> mm_freak: well I don't know the notation. Now that I think about it, the Either Monad is what I may be thinking of. Basically I want to chain two actions together, and if the first fails, the second only propogates the fail value, instead of doing it's action
19:31:17 <mm_freak> 'e' i would call the argument, the "environment"
19:31:31 <hcaulfield57> I can't believe I wrote that, although I did have help :)
19:31:43 <mm_freak> LamdaFan: oh, many monads model that
19:31:50 <mm_freak> LamdaFan: Maybe, Either, [], …
19:31:57 <LamdaFan> maybe Alternate
19:32:05 <LamdaFan> I will look it up
19:32:11 <ion> I would humbly suggest that f (e x) and Reader (f . e) may be nicer to read than f $ e x and Reader $ f . e :-)
19:32:21 <mm_freak> hcaulfield57: also consider that there was no mutability going on there, and no global variables…  it's all just functions =)
19:32:28 <LamdaFan> Alternative I mean
19:32:33 <mm_freak> ion: i agree
19:32:44 <mm_freak> LamdaFan: Alternative is a class
19:32:51 <mm_freak> x <|> y = x, if x results, otherwise y
19:33:07 <hcaulfield57> Yea, I feel like my head is going to explode
19:33:12 <hcaulfield57> Working on Monad
19:33:18 <mm_freak> hcaulfield57: start with 'return' =)
19:33:45 <mm_freak> hcaulfield57: always keep in mind that nothing "does", everything just "is"
19:33:48 <hcaulfield57> return x = Reader $ (\y -> x)
19:33:56 <mm_freak> hcaulfield57: try using ($) less =)
19:33:57 <LamdaFan> mm_freak: yeah not what I wanted, I'll keep looking
19:34:05 <LamdaFan> talking it out gets the brain going
19:34:32 <mm_freak> LamdaFan: monads like that often have a 'catch' equivalent
19:34:45 <beaky> is there a monad explanation that even a bonehead like me can understand?
19:34:49 <mm_freak> > Just 3 <|> Just 5
19:34:50 <lambdabot>  Just 3
19:34:54 <mm_freak> > Nothing <|> Just 5
19:34:55 <lambdabot>  Just 5
19:34:57 <hcaulfield57> mm_freak: Is the answer wrong?
19:35:03 <mm_freak> hcaulfield57: no, it's right
19:35:18 <mm_freak> hcaulfield57: but you can improve it =)
19:35:39 <mm_freak> hcaulfield57: rename 'y' to something that reflects the fact that it isn't used
19:35:49 <mm_freak> there is a certain variable pseudo-name in haskell for that =)
19:36:07 <mm_freak> beaky: explanations don't help…  /use/ monads
19:36:59 <LamdaFan> beaky: I hav the thing for you
19:37:09 <erisco> beaky, here I'll give you an assignment: write the Maybe monad without peaking
19:37:18 <beaky> ok
19:37:41 <LamdaFan> beaky: http://www.youtube.com/watch?v=ZhuHCtR3xq8
19:37:46 <hcaulfield57> return x = Reader $ (\_ -> x)
19:37:58 <ion> Yeah, Maybe is not the monad to peak at.
19:38:09 <LamdaFan> that's a good assignment
19:38:30 <beaky> data Maybe a = Nothing | Just a; instance Monad Maybe where...
19:38:31 <mm_freak> hcaulfield57: great, now get rid of the lambda altogether
19:38:35 <beaky> im stuck
19:38:45 <LamdaFan> beaky, watch the video
19:39:28 <beaky> but its an hour long i will probably fall asleep halfway and be bound to a monadic dream
19:39:45 <c_wraith> beaky: that's a type error unless you're a monadic value
19:39:56 <mm_freak> beaky: the video is great, it's very enlightening…  unfortunately i don't believe that it introduces monads themselves very well to a beginner
19:40:01 <mm_freak> it's more for understanding the theory behind them
19:40:06 <beaky> ah
19:40:07 <mm_freak> but it does explain monoids very well =)
19:40:13 <mm_freak> and that's valuable
19:40:16 <beaky> but monoids are easy
19:40:18 <mm_freak> so you should probably at least watch the first 15-20 mins =)
19:41:07 <hcaulfield57> I'm getting close
19:41:19 <hcaulfield57> I skipped to >>=
19:41:22 <LamdaFan> mm_freak: realy? he starts from functions, works up to functors, monoids then monads.
19:41:23 <mm_freak> hcaulfield57: what is a function that ignores its argument?
19:41:29 <beaky> monoids are things that have an identity thing and a thing that takes two things and returns a thing
19:41:31 <mm_freak> hcaulfield57: does it vary?
19:41:41 <hcaulfield57> Does what vary?
19:42:04 <mm_freak> LamdaFan: i know, i've watched it…  it's interesting to someone, who already understands monads, to get a deeper insight, but it will make question marks appear over the head of a beginner =)
19:42:40 <mm_freak> hcaulfield57: if a function ignores its argument, it has the same value everywhere
19:42:45 <mm_freak> hcaulfield57: in other words it is …?
19:43:20 <haasn> (in mathematics, what do you call functions like f(x) = 3?)
19:44:18 <hcaulfield57> immutable?
19:44:25 <mm_freak> hcaulfield57: all functions are immutable
19:44:36 <mm_freak> hcaulfield57: if it does not vary, it is not variable, and what is the opposite of "variable"?
19:44:40 <haasn> all values are immutable
19:45:05 <beaky> ok ive made the maybe monad: instance Monad Maybe where return x = Just x; Nothing >>= _ = Nothing; Just x >>= f = f x
19:45:16 <beaky> now i have mastered monads
19:45:23 <mm_freak> beaky: now do State =)
19:45:34 <beaky> what does state do
19:45:36 <hcaulfield57> mm_freak: This is as close as I've gotten (Reader e) >>= f = Reader $ \x -> let r = e x in f r
19:45:54 <hcaulfield57> Am I on the right track, it doesn't work obvoiusly
19:46:04 <haasn> hcaulfield57: it looks very close to the correct function
19:46:42 <haasn> hcaulfield57: GHC's type error might be enough to figure out what's missing
19:46:43 <mm_freak> hcaulfield57: (>>=) for Reader is slightly confusing, if you do it for the first time…  you really need to work with the types
19:47:08 <mm_freak> hcaulfield57: Reader f >>= g = Reader $ \e -> …
19:47:12 <mm_freak> what's the type of "…"?
19:48:09 <mm_freak> beaky: it models state transition functions
19:48:17 <mm_freak> sorry, missed your question =)
19:48:21 <hindleymilner> what are the rules of rigid type vars?
19:48:53 <beaky> wow the state monad sounds awesome im going to reinvent it
19:48:59 <mm_freak> beaky: do it =)
19:49:28 <mm_freak> beaky: you may peak for the type definition, but then write the Functor instance by yourself
19:49:39 <mm_freak> don't worry about Monad for now, Functor is tricky enough =)
19:50:07 <haasn> hindleymilner: maybe this posts helps? http://stackoverflow.com/questions/12719435/what-are-skolems/12719617#12719617
19:50:37 <beaky> state is a functor?
19:50:51 <mm_freak> State is a family of functors
19:50:58 <mm_freak> for every 's', 'State s' is a functor
19:51:09 <beaky> oh
19:51:17 <hcaulfield57> I'm stuck
19:51:33 <mm_freak> hcaulfield57: what's the type of (>>=)?  (with the correct m filled in)
19:52:46 <hcaulfield57> Reader e a -> (a -> Reader e b) -> Reader e b
19:52:50 * haasn wonders if an interactive tool that lets you “fill in holes” by showing you their expected types along with what the types of what you have lying around could be useful for gaining intuition for this kind of stuff
19:52:59 <haasn> in particular, it could work nicely with indexed monads ;)
19:54:06 <mm_freak> hcaulfield57: great, so let's work this out
19:54:07 <haasn> maybe that's a motivating reason for me to finally learn one of those fancy interactive JS frameworks like elm, ur or ghcjs
19:54:11 <mm_freak> Reader f >>= g = …
19:54:15 <mm_freak> hcaulfield57: what's the type of "…"?
19:54:37 <ion> hcaulfield57: GHC 7.8 will let you write _ there and it’ll tell you the type, but with earlier versions you can abuse -XImplicitParams and use ?foo. Trying to compile “Reader e >>= f = ?foo e f” will tell you the type of ?foo and replacing ?foo with a function of that type will work. You can do that iteratively.
19:55:27 <haasn> ion: oh, of course; that seems like exactly what I just described as well
19:55:48 <haasn> seems like my “interactive tool” would just be iteratively calling out to GHC 7.8 with _ in the place of what you need to fill in :)
19:55:52 <hcaulfield57> Reader e b
19:56:04 <mm_freak> hcaulfield57: correct, so how do you start?  add only one word to the current code
19:56:13 <hcaulfield57> Reader
19:56:19 <mm_freak> good
19:56:21 <mm_freak> Reader f >>= g = Reader …
19:56:24 <mm_freak> what's the type of … now?
19:56:35 <hcaulfield57> (e -> b)
19:56:43 <mm_freak> ok, expand the code further
19:56:57 <mm_freak> but only fill in your new knowledge and keep the … =)
19:57:16 <hcaulfield57> Reader f >>= g = Reader $ \e
19:57:24 <mm_freak> good
19:57:31 <mm_freak> Reader f >>= g = Reader (\e -> …)
19:57:34 <mm_freak> what's the type of …?
19:57:39 <hcaulfield57> b
19:57:44 <mm_freak> now comes the tricky part
19:57:51 <haasn> (what are the types of ‘f’, ‘g’ and ‘e’?)
19:58:01 <mm_freak> we need to figure out how to arrive at a value of type b
19:58:05 <mm_freak> what's the type of g?
19:58:11 <hcaulfield57> (a -> Reader a b)
19:58:21 <mm_freak> ok, it's a function that wants an 'a'
19:58:25 <mm_freak> do you have such a value right now?
19:58:38 <hcaulfield57> The result of f?
19:58:43 <mm_freak> exactly =)
19:58:51 <mm_freak> but f is a function…  is there anything you can apply to it?
19:59:02 <hcaulfield57> \e ?
19:59:05 <haasn> s/to it/it to/ ;)
19:59:09 <mm_freak> well, 'e'
19:59:11 <mm_freak> uh, yeah, sorry =)
19:59:33 <mm_freak> hcaulfield57: ok, so:  f e :: a
19:59:42 <mm_freak> what can you do with 'f e'?
20:00:09 <hcaulfield57> Assign it to a temporary variable
20:00:28 <mm_freak> you could do that, sure, but can you do something useful?  remember your goal
20:00:47 <mm_freak> there is an 'a -> Reader e b' that you want to reduce to a 'Reader e b' to eventually get the 'b' =)
20:01:12 <hcaulfield57> Apply it to g?
20:01:19 <haasn> Apply g to it*
20:01:19 <mm_freak> apply g to it =)
20:01:34 <mm_freak> ok, we have this right now:  g (f e)
20:01:37 <mm_freak> what's the type of that?
20:02:07 <hcaulfield57> Reader e b
20:02:10 <mm_freak> great
20:02:15 <mm_freak> and now comes the tricky part
20:02:20 <mm_freak> you have a Reader e b, but you want a 'b'
20:02:26 <mm_freak> any idea how you might get there?
20:03:52 <hcaulfield57> Why do I want a b?
20:04:07 <mm_freak> because that's what you need to replace the "…" by
20:04:18 <mm_freak> this is your current code:
20:04:28 <mm_freak> Reader f >>= g = Reader (\e -> …)
20:04:36 <mm_freak> and you figured out that "…" must be of type 'b'
20:04:44 <mm_freak> so you need a 'b' to put there =)
20:05:19 <mm_freak> you've got very far:  g (f e) :: Reader e b
20:05:38 <mm_freak> but there is this "Reader e" in the way =)
20:06:03 <mm_freak> hcaulfield57: any idea?  just use your intuition
20:06:08 <hcaulfield57> We need to apply that Reader e to something
20:06:15 <mm_freak> exactly
20:06:24 <mm_freak> and in order to apply it, …?
20:06:47 <hcaulfield57> I'm not sure,
20:06:59 <mm_freak> ok, take a break from (>>=)
20:07:17 <mm_freak> implement this function now:  extractReaderFunction :: Reader e a -> (e -> a)
20:07:26 <mm_freak> it's really trivial =)
20:08:35 <hcaulfield57> Is it just extractReaderFunction (Reader e) = e
20:08:41 <mm_freak> correct
20:09:00 <mm_freak> except that you like to mix up the environment with the function of environment
20:09:02 <mm_freak> =)
20:09:19 <mm_freak> hcaulfield57: now return to (>>=)
20:09:27 <hcaulfield57> (Reader e) >>= f = Reader $ \x -> let (Reader r) = f (e x) in r x
20:09:37 <mm_freak> perfect
20:09:38 <hcaulfield57> Not sure about the last part
20:09:41 <hcaulfield57> Oh great!
20:09:47 <khyperia> woo! I was following along, I got that too :D
20:10:10 <mm_freak> hcaulfield57: any idea why i let you write that extractReaderFunction function?
20:10:27 <hcaulfield57> mm_freak: Nope
20:10:31 <hcaulfield57> To make me think?
20:10:48 <mm_freak> Reader f >>= g = Reader (\e -> extractReaderFunction (g (f e)) e)
20:10:59 <mm_freak> that function is usually called runReader =)
20:11:13 <mm_freak> and you usually get it for free:  newtype Reader e a = Reader { runReader :: e -> a }
20:11:18 <hcaulfield57> Ah, I see, yes that makes sense!
20:11:24 <mm_freak> Reader f >>= g = Reader (\e -> runReader (g (f e)) e)
20:11:28 <hcaulfield57> mm_freak: Thank you so much, this has been incredibly helpful
20:11:43 <khyperia> Ohhh, *that's* why people put names on newtypes! So you don't have to patternmatch!
20:11:53 <mm_freak> my pleasure…  now i suggest you take a break to let it sink in
20:12:02 <mm_freak> and later you try the Monad instance for State
20:12:17 <mm_freak> it's slightly more involved, but the basic rules to figure this out are the same =)
20:12:17 <hcaulfield57> Yes, this is the most I've used my brain in months, far better than playing Nethack in Java class
20:13:05 <mm_freak> this is very often the correct approach to write programs in haskell
20:13:17 <mm_freak> what do i have?  what do i need?  how can i combine what i have to arrive at what i need?
20:13:24 <khyperia> now, just because I'm curious, this is probably going to blow up...
20:13:26 <khyperia> @pl \e -> runReader (g (f e)) e
20:13:26 <lambdabot> runReader =<< g . f
20:13:43 <mm_freak> khyperia: you want your mind blown?
20:13:45 <khyperia> ... ok, that's probably using function monad instance or something wack like that
20:13:48 <mm_freak> instance Monad ((->) e)
20:13:55 <mm_freak> type Reader e a = e -> a
20:13:56 <mm_freak> =)
20:14:04 <mm_freak> get :: Reader e e
20:14:06 <mm_freak> get = id
20:14:13 <khyperia> augh
20:14:13 <mm_freak> s/get/ask/
20:14:43 <hcaulfield57> mm_freak: Thanks again, I've saved the Reader example, we'll see if it still makes sense in the morning :)
20:14:57 <hcaulfield57> Really, though I do appreciate the time :)
20:14:59 <mm_freak> > let runReader = ($); ask = id; in (do x <- ask; return (x + 1)) 5
20:15:00 <lambdabot>  6
20:15:22 <mm_freak> hcaulfield57: it's weekend and i'm at home…  it's my pleasure =)
20:15:45 <mm_freak> uh
20:15:54 <mm_freak> > let runReader = ($); ask = id; in runReader (do x <- ask; return (x + 1)) 5
20:15:55 <lambdabot>  6
20:16:11 <mm_freak> there, Reader in its most direct form =)
20:16:24 * khyperia 's brain is now mush
20:16:58 <mm_freak> khyperia: just add the Reader constructor at appropriate places and you've got the newtyped Reader
20:17:04 <mm_freak> but they are really exactly the same type
20:17:13 <mm_freak> newtype Reader e a = Reader (e -> a)
20:17:17 <mm_freak> type Reader e a = e -> a
20:21:23 <khyperia> I'm curious, where actually is Reader defined? I can't seem to find it in the mtl git
20:22:52 <mm_freak> khyperia: mtl is an interface to the 'transformers' library, where ReaderT is defined
20:22:59 <mm_freak> and Reader is defined in terms of ReaderT
20:23:07 <mm_freak> Control.Monad.Trans.Reader
20:23:22 <khyperia> ah, thanks
20:24:57 <khyperia> I'm going to have to learn how transformers work someday
20:25:30 <mm_freak> khyperia: just look at the definitions
20:25:52 <Iceland_jack> Sometimes you need more of a bird's eye view :)
20:26:05 <mm_freak> Reader gives you environment monads for functions of the 'e -> a' pattern
20:26:14 <mm_freak> ReaderT gives you environment monads for functions of the 'e -> m a' pattern, where m is a monad
20:26:21 <julianb> Hey!. I'm trying to split lines of text from a file, through this code: let text = lines =<< hGetContents handle. However, I'm getting an eror (expected [String] with actual type IO String), I can't understand why, though, lines is String -> [String], so it shouldn't be expecing a [String]
20:26:26 <khyperia> is it basically just instead of, say, in the case of Reader r a, it's Reader r (m a)... (not sure if that's correct) but basically returning a monadic value instead of the value itself?
20:26:39 <mm_freak> so if you keep passing your database connection around, you probably have lots of functions of the form 'DB -> IO ()'
20:26:40 <khyperia> looks like the same for StateT
20:26:46 <Iceland_jack> julianb: Check the type of hGetContents :)
20:27:05 <mm_freak> you can then use ReaderT DB IO ()
20:27:10 <Iceland_jack> khyperia: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf check this one out
20:27:11 <mm_freak> and that's about it =)
20:27:23 <Kaidevappy> okay so the problems with haskell on windows seems to be: some haskell packages need shell or perl to build, there is no GUI library for haskell that actually works on windows, and too many things depend on things being built by GCC
20:27:29 <mm_freak> khyperia: and yes, that's correct
20:27:30 <khyperia> yeah, I know how to use them, I just don't know how to implement them... but I think I just figured 'em out
20:27:32 <julianb> Iceland_jack, its Handle -> IO String, but isn't =<< supposed to "unpack" the String from IO temporarily?
20:27:33 <mm_freak> khyperia: but only for Reader
20:27:39 <Kaidevappy> the last one seems like the hardest to attack
20:27:51 <Kaidevappy> I'm wondering if I might be able to make a dent in the first two, though
20:28:08 <mm_freak> Kaidevappy: GTK+ and wx were reported to work
20:28:21 <Kaidevappy> mm_freak: if you sacrifice a chicken and stand on one leg
20:28:46 <Iceland_jack> @ty fmap lines (System.IO.hGetContents undefined)
20:28:46 <Kaidevappy> maybe it's easier if you don't try to use cabal
20:28:47 <lambdabot> IO [String]
20:28:50 <Iceland_jack> julianb: ↑
20:29:08 <Iceland_jack> If you work out the type signature of (=<<) I think you'll find that the types don't quite match up :)
20:29:13 <mm_freak> Kaidevappy: look into the gtk2hs homepage…  i believe they have some convenience stuff to make getting this to work easier
20:29:19 <khyperia> mm_freak, I think I got the pattern, though - the result of the function (whatever data type, reader, state, writer (even though writer isn't a function)) is monadic instead of pure (also is "monadic" the right term?)
20:29:33 <mm_freak> khyperia: there is a catch
20:29:35 <ion> “Abusing ImplicitParams as a substitute for type holes” https://gist.github.com/ion1/9285144
20:29:46 <mm_freak> khyperia: State s (m a) = s -> (m a, s)
20:29:55 <mm_freak> khyperia: StateT s m a = s -> m (a, s)
20:30:00 <khyperia> ah, yeah
20:30:40 <julianb> Iceland_jack, true that!. Tyvm!
20:30:58 <Iceland_jack> You're welcome julianb, would you like a quick overview why the original version didn't work?
20:31:44 <mm_freak> khyperia: and here is a use case:  have you ever been bothered by layers and layers of 'if'/'when'/'unless' to check every 'IO (Maybe X)' for Nothing?
20:31:48 <mm_freak> khyperia: enter MaybeT =)
20:31:56 <julianb> Iceland_jack, lines does not return an IO value?
20:32:06 <mm_freak> newtype MaybeT m a = MaybeT (m (Maybe a))
20:32:11 <carter> o/ khyperia  hows things
20:32:24 <khyperia> heh, nice mm_freak
20:32:31 <Iceland_jack> julianb: well, lines would have to have type 'String → IO a'
20:32:32 <khyperia> heya carter, touching up on basics of haskell
20:32:43 <carter> khyperia: after getting compiler patches in too :)
20:32:47 <khyperia> haha, yeah
20:32:52 <Iceland_jack> @ty (=<<)
20:32:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:33:00 <julianb> Iceland_jack, yeah, exactly. A return lines should fix that, right?
20:33:01 <carter> doesn't it help make everything else seem like it must be tractable
20:33:02 <carter> ?
20:33:13 <carter> "i understand some teeny fragment of the compiler, how bad could the rest be"
20:33:14 <carter> :)
20:33:27 <Iceland_jack> julianb: You could do it like that, but fmap is the say to go
20:33:33 <carter> pretty cool how quickly your last patch got merged in too
20:33:39 <khyperia> yeah, that was awesome
20:34:28 <carter> so its a good thing i redirected yah to that one?
20:34:45 <carter> 2 day turn around right?
20:34:56 <carter> in exchange for 6 hrs of debuggin :)
20:35:05 <Kaidevappy> mm_freak: do you know how well GTK+ deploys these days?
20:35:19 <Kaidevappy> I remember the pidgin installer had to install GTK first before installing pidgin
20:35:19 <khyperia> Heh, yep, thanks for that! Unrelated, I kind of want to concurrently (while doing ghc work) work on my own compiler, just to figure things out for myself (I learn by doing)... which would be great *if* my silly prof decided to let me use Haskell to write my compiler project instead of a OO language.
20:35:37 <Iceland_jack> julianb: So you can see that 'hGetContents handle' fits as a second argument to (=<<)
20:35:37 <Iceland_jack>     hGetContents handle :: IO String
20:35:37 <Iceland_jack>     lines :: String -> [String]
20:35:37 <Iceland_jack>     (=<<) :: (String -> IO b) -> IO String -> IO b
20:35:42 <Fuuzetsu> I'm trying to use vinyl and it doesn't let me have a PlainRec with a single field due to kind mismatch; I don't understand why something like ‘["foo" ::: Integer]’ has the kind ‘*’ but ‘["foo" ::: Integer, "bar" ::: Integer]’ has a kind ‘[*]’
20:35:45 <carter> khyperia: you can write haskell in any languae :)
20:35:51 <carter> wich oop ?
20:35:58 <Fuuzetsu> fyi I need kind [*]
20:36:14 <julianb> Iceland_jack, oh. That makes sense. It didn't work using return though (hGetContents handle >>= return.lines)
20:36:28 <Iceland_jack> julianb: and as you suggested correctly, ‘return’ would solve it
20:36:39 <khyperia> Doesn't matter which language, all it matters is that it's OO (it's for a OO class, prof said "you're beyond it, just do your own thing that shows you know your stuff"), but I'm thinking C# since I'm very familiar with it
20:36:39 <Iceland_jack>     return.lines :: String -> IO [String]
20:36:42 <Kaidevappy> (mostly unrelated note; how to handle persistant data and how to handle deployment should perhaps both become real concerns of programming language implementation design itself)
20:37:19 <julianb> Iceland_jack, isn't that exactly what I needed?
20:37:21 <BMeph> bbiab - Weendoze needs a burping...
20:37:25 <mm_freak> Kaidevappy: no, sorry
20:37:30 <Iceland_jack> julianb: Well like I mentioned before, fmap is what you should use :)
20:37:39 <Iceland_jack> @ty fmap lines (System.IO.hGetContents undefined)
20:37:40 <lambdabot> IO [String]
20:38:03 <Iceland_jack> Which you can also write as
20:38:03 <Iceland_jack> @ty lines <$> System.IO.hGetContents undefined
20:38:04 <lambdabot> IO [String]
20:38:31 <julianb> Iceland_jack, I know, but I'm interested in understanding how to use the return way
20:38:44 <Iceland_jack> julianb: Understand in what way?
20:38:49 <mm_freak> Kaidevappy: if i had to write windows GUIs i'd probably use the bridge framework…  it has only one IO action defined
20:38:58 <mm_freak> jumpOff :: IO ()
20:39:14 <Kaidevappy> mm_freak: I don't get it
20:39:21 <Kaidevappy> oh
20:39:23 <julianb> Iceland_jack, well, hGetContents handle >>= return . lines is not working
20:39:23 <Kaidevappy> now I do
20:39:23 <Iceland_jack> You could also use do-notation
20:39:24 <Iceland_jack> @ty do content <- System.IO.hGetContents undefined; return (lines content)
20:39:24 <lambdabot> IO [String]
20:39:43 <mm_freak> Kaidevappy: nevermind, i was just recalling my year of visual studio slavery
20:39:43 <mm_freak> =)
20:39:43 <Fuuzetsu> oh, nevermind, I had to use ‘'["foo" ::: String]’
20:39:44 <Kaidevappy> mm_freak: that seems to be why it is so bad, and that's why I'm thinking maybe I need to put in some elbow grease myself
20:40:11 <julianb> and it does have the expected type: return . lines :: Monad m => String -> m [String]
20:40:14 <Kaidevappy> it seems nobody wants to make haskell work nicely on windows because haskell on windows sucks enough that the people who use haskell don't use windows and don't care to make it not suck
20:40:40 <mm_freak> Kaidevappy: in any case, GTK+ and wx are easy to get up and running, if you know how, and that's the tricky part
20:40:44 <Iceland_jack> julianb: do you mean it's not working or not type checking?
20:40:50 <mm_freak> there is no step-by-step windows guide
20:40:56 <julianb> not type checking
20:41:13 <mm_freak> Kaidevappy: haskell actually works very well on windows, until you approach widget-based GUIs
20:41:20 <Iceland_jack> Are you quite sure?
20:41:27 <Iceland_jack> @ty System.IO.hGetContents undefined >>= return . lines
20:41:28 <lambdabot> IO [String]
20:41:35 <Kaidevappy> mm_freak: binding to C libraries in general is a bit of a nightmare on windows
20:41:42 <mm_freak> Kaidevappy: indeed
20:42:02 <Kaidevappy> mm_freak: which in haskell is something you do really often, not just with widget toolkits, unfortunately
20:42:14 <julianb> yeah, it's giving me a Expected type: IO String Actual type: IO [String]
20:42:21 <mm_freak> Kaidevappy: that's probably because every windows developer just bundles the required DLLs with their program instead of pushing microsoft into making a package management solution
20:42:25 <Kaidevappy> IE you want to use CUDA, or MPI, or COM
20:42:50 <Iceland_jack> julianb: it does type check here, make sure that you're not mixing together (>>=) and (=<<) and then lpaste the code
20:42:52 <Iceland_jack> @lpaste
20:42:52 <lambdabot> Haskell pastebin: http://lpaste.net/
20:43:04 <Kaidevappy> mm_freak: that approach is superior to dependency hell IMO, but the nix approach of a database of versioned packages is even better
20:43:07 <mm_freak> Kaidevappy: usually with OS libraries it's easy, because all you need to do is the usual FFI magic
20:43:15 <mm_freak> the trouble starts when you need to compile C libraries
20:43:26 <julianb> Iceland_jack, ouch, sorry. It was another line, and I didn't notice!
20:43:38 <Kaidevappy> mm_freak: the most successful packing approach on linux was also in my opinion RPM, which like windows usually means "copy all your DLLs"
20:43:58 <mm_freak> Kaidevappy: nix works well without having to do that =)
20:44:00 <Iceland_jack> julianb: Great, I hope it's working :) now you have 5 different ways of writing that
20:44:02 <Kaidevappy> yes
20:44:11 <Kaidevappy> nix is the real solution IMO
20:44:16 <ion> @tell hcaulfield57 You may or may not find this useful: https://gist.github.com/ion1/9285144
20:44:16 <lambdabot> Consider it noted.
20:44:17 <mm_freak> i love how with nix every deployment is a single command
20:44:20 <Kaidevappy> but I'd take MSI over apt
20:44:21 <Iceland_jack> do-notation, fmap, <$>, (=<<) and (>>=) with return
20:44:24 <mm_freak> regardless of how big it is
20:44:29 <Kaidevappy> (or RPM)
20:44:53 <mm_freak> RPM still has the usual FHS problem
20:44:59 <mm_freak> other packages can get in your way
20:45:07 <julianb> Iceland_jack, thank yo uvery much, that was very useful
20:45:30 <Iceland_jack> Glad to hear that julianb, good luck with Haskelling
20:46:12 <Kaidevappy> mm_freak: yeah I think what ended up happening is that rpm had dependencies but developers realized it was usually bad to actually use them
20:46:29 <Kaidevappy> slackware's package system doesn't even support the feature
20:46:48 <Kaidevappy> but I think their approach is to farm dependency management to the user, not to make things self contained
20:47:00 <Kaidevappy> which has its advantages; things only break if you break them
20:47:00 <mm_freak> yeah
20:47:07 <Kaidevappy> and then you generally know how to fix it
20:47:34 <taktoa> I would say that pacman does a lot better than rpm
20:47:35 <mm_freak> IMO RPM is not a good solution…  it's like fixing a bug by turning it into a feature =)
20:47:49 <mm_freak> taktoa: pacman is fundamentally the same
20:48:11 <taktoa> at least at the user level, the experience is quite different
20:48:21 <chirpsalot> mm_freak: it's the most efficient means of fixing bugs, though :).
20:48:25 <Kaidevappy> nix actually reminds me a bit of WinFS
20:48:31 <mm_freak> chirpsalot: true ;)
20:48:58 <mm_freak> Kaidevappy: one very important feature of nix is profiles
20:49:15 <Kaidevappy> maybe if the longhorn people didn't get kicked out windows would have gotten a package manager based on a database-style filesystem so that you don't end up with the ridiculous path names nix generates
20:49:17 <mm_freak> they're probably its killer feature
20:49:19 <chirpsalot> For instance languages that don't have a standard, and only have a "standard implementation" can never have bugs :).
20:50:02 <Kaidevappy> it's really sad that WinFS got the axe =(
20:50:17 <mm_freak> chirpsalot: not quite…  PHP has actual bugs that the test suites (yes, they have them) report to fail
20:50:25 <mm_freak> why don't they fix them?  because failure is expected
20:50:44 <chirpsalot> mm_freak: failure is the specification!
20:50:57 <mm_freak> at some point the bugs got so widely used that the community made them features =)
20:51:07 <chirpsalot> Speaking of package managers... Why do I always have issues with cabal? Is there like a cabal tutorial? Whenever I try to install a library it ends up exploding :(.
20:51:22 <Kaidevappy> ^
20:51:23 <mm_freak> chirpsalot: the reason is that cabal is not a package manager
20:51:26 <nisstyre> chirpsalot: well you can remove your entire thing when that happens
20:51:31 <nisstyre> and reinstall all of your packages
20:51:33 <Kaidevappy> it's even worse on windows, I was just griping about that
20:51:36 <mm_freak> chirpsalot: i tend to reinstall everything when i change my cabal packages =)
20:51:47 <chirpsalot> mm_freak: what is cabal then?
20:51:55 <Kaidevappy> on linux I just avoid using cabal directly and use nix instead
20:52:02 <mm_freak> chirpsalot: an installation system with dependency tracking
20:52:05 <Kaidevappy> chirpsalot: a build system
20:52:09 <Kaidevappy> kind of like make
20:52:16 <mm_freak> yeah, "build system" is probably the better word
20:52:20 <mm_freak> a haskell-specific fancy build system
20:52:29 <nisstyre> also use sandboxes
20:52:35 <nisstyre> then you avoid having to wipe everything
20:52:40 <chirpsalot> Okay. But it's vaguely related!
20:52:41 <Kaidevappy> it includes some package manager like features and in practice people use it like a package manager
20:52:53 <Kaidevappy> this is horrible, but it's what people ended up doing
20:53:07 <mm_freak> i use nix with cabal…  it works beautifully
20:53:09 <pharaun> how come the winfs got axed
20:53:13 <Kaidevappy> ^
20:53:25 <chirpsalot> How are you supposed to install Haskell libraries then? I thought cabal was the preferred way?
20:53:38 <mm_freak> chirpsalot: it is
20:53:40 <nisstyre> chirpsalot: put everything in a sandbox
20:53:40 <mm_freak> chirpsalot: just don't uninstall or update them =)
20:53:45 <Kaidevappy> also pharaun in short because longhorn took too long and infighting in the windows team led to throwing out the work of the longhorn people with a vengeance
20:53:51 <mm_freak> and yeah, use a sandbox for each project
20:53:53 <nisstyre> then when you start something new you can use newer versions of stuff
20:53:56 <pharaun> Kaidevappy: ah so politics?
20:54:02 <Kaidevappy> even though a lot of it was good useful work in good states of completion
20:54:03 <Kaidevappy> partially
20:54:04 <chirpsalot> mm_freak: okay, so I'm not the only one who has problems?
20:54:09 <mm_freak> chirpsalot: no
20:54:15 <chirpsalot> That's a relief!
20:54:29 <dolio> I'm the only one who doesn't have problems.
20:54:32 <mm_freak> chirpsalot: it's a mistake to see cabal as package management
20:54:34 <chirpsalot> I don't know if I have ever successfully installed a library.
20:54:40 <dolio> Everyone else has problems, for some reason.
20:54:42 <pharaun> <- uses gentoo with haskell, it works decently
20:54:43 <Kaidevappy> anyway chirpsalot, if you're on a UNIXy system, just use nix
20:54:57 <pharaun> but i've been migrating mostly to sandboxes with cabal for initial dev work
20:55:01 <mm_freak> dolio: me neither, but we do understand how to use cabal properly =)
20:55:15 <taktoa> cabal sandboxing works pretty great
20:55:20 * relrod hasn't had issues since cabal got sandboxing
20:55:21 <Kaidevappy> if you're on windows, you're kind of screwed. Use slackware for a while and get some experience with having to manage the stuff cabal doesn't do correctly yourself
20:55:21 <dolio> I do things that people say cause problems, too.
20:55:22 <relrod> yeah
20:55:26 <dolio> And don't have problems. :)
20:55:29 <chirpsalot> Kaidevappy: lice treatment? Harsh :P. Looking at it now... Thanks!
20:55:41 <nisstyre> taktoa: well yeah because it lets you use newer versions of stuff without f-king up old stuff
20:55:41 <taktoa> and arch finally pushed out cabal 1.18
20:55:49 <pharaun> it has problems but *shrugs* i usually just nuke and reinstall the sandbox, that's the nice thing bout having *.cabal
20:55:56 <mm_freak> dolio: the problems start when you pull in large stuff like web frameworks =)
20:56:08 <dolio> Yeah. That's something I don't do.
20:56:09 <mm_freak> most other things work quite smoothly
20:56:12 <pharaun> yesod
20:56:16 <pharaun> that was *rough*
20:56:30 <pharaun> tried to use yesod via portage :p didn't end well
20:56:35 <taktoa> yesod worked fine on cabal-dev last time I checked
20:56:36 <mm_freak> dolio: yesod even hat to release a compatibility package that has nothing but dependencies with strict version bounds
20:56:48 <dolio> Heh.
20:56:52 <pharaun> i would use it in a sandbox now *shrugs*
20:56:54 <mm_freak> it's called yesod-platform i think
20:56:57 <taktoa> except I seem to recall a problem with the text version change
20:57:02 <mm_freak> but yeah, today you would just use a sandbox
20:57:08 <mm_freak> and in the old days you would use cabal-dev =)
20:57:20 <pharaun> cabal-dev had some rough edge but it worked well enough for me
20:57:21 <taktoa> IIRC text went from like 0.11.x.x to 1.0.x.x
20:57:26 <Fuuzetsu> I second the sandbox, I just went through this bullshit yesterday and sandbox was really the only way I could get it to even install
20:57:31 <mm_freak> taktoa: 1.1
20:57:37 <taktoa> yea
20:57:47 <nisstyre> I suppose the problem with sandboxes is that there's so much duplication
20:57:48 <pharaun> oh the ol' let's skip and do a whole major version hop
20:57:48 <Kaidelong> nix and nixos are so nice there is no reason not to use them anyway
20:58:02 <mm_freak> anyway, i don't have any of those problems today…  nix solves dependency hell =)
20:58:07 <nisstyre> although your FS should do COW to optimize that right?
20:58:12 <mm_freak> including when deploying your stuff elsewhere
20:58:14 <nisstyre> well, any decent one should
20:58:28 <pharaun> name one? :p
20:58:38 <nisstyre> btrfs? :P
20:58:43 <Kaidelong> mm_freak: and with nixos you can deploy your entire system you use!
20:58:44 <enthropy> mm_freak: you don't end up with half of your dependencies wanting lens < 4 and the other half lens > 4 or similar issues with text?
20:58:49 <nisstyre> I can't recall if ext4  does it
20:58:54 <pharaun> nisstyre: i guess i just don't regard it as stable yet
20:59:01 <mm_freak> enthropy: context?
20:59:04 <pharaun> still on ext3 and xfs here but recently got a box with zfs up
20:59:06 <nisstyre> pharaun: I am using it on an external drive, works well
20:59:16 <pharaun> nisstyre: good to know that its getting there tho :)
20:59:27 <nisstyre> it can do compression too which is nice
20:59:36 <pharaun> always nice
20:59:36 <mm_freak> enthropy: you mean with nix?
20:59:48 <enthropy> yes
20:59:52 <chirpsalot> nisstyre: disk space is cheap, though!
20:59:54 <pharaun> nisstyre: i am just not all that trusting of new fs *shrugs* i shall have to try it sooner or later
21:00:02 <nisstyre> pharaun: and it will check if the compression ratio is decent before doing it
21:00:02 <mm_freak> enthropy: if your package doesn't use both, it's usually no problem
21:00:05 <pharaun> chirpsalot: well compression can sometime improve performance
21:00:06 <Kaidelong> enthropy: that's the problem nix was built to solve
21:00:16 <pharaun> because its the i/o that is usually the limitor
21:00:22 <nisstyre> compression means less latency
21:00:30 <nisstyre> more cpu cycles, but who cares
21:00:35 <pharaun> so if you're being io bottle-necked and have some cpu to spare, compression can help speed things up overall
21:00:35 <Kaidelong> half of your dependencies depend on lens < 4 and the other half depend on lens > 4 but that is not a problem
21:00:44 <nisstyre> exactly
21:00:44 <pharaun> (not always, not for all cases) but generally
21:00:51 <mm_freak> enthropy: if one package uses text 0.* and the other one uses 1.*, and they are unrelated, then there is no problem, and that's guaranteed
21:00:51 <chirpsalot> Well, point is duplication of libraries isn't a super big concern?
21:01:01 <nisstyre> if it's all files that are already compress though, then it won't help obviously
21:01:20 <pharaun> indeed
21:01:24 <Kaidelong> chirpsalot: no not at all, this happens on windows all the time in fact, and also on android
21:01:49 <Kaidelong> although with android the libraries generally get statically linked
21:01:53 <chirpsalot> Kaidelong: honestly half the time I just wish everything was statically linked.
21:02:09 <mm_freak> chirpsalot: that would be a huge waste of memory
21:02:13 <Ralith> huge?
21:02:16 <Kaidelong> chirpsalot: static linking is more trouble than its worth
21:02:29 <Ralith> executable code doesn't seem to be a very big portion of memory use...
21:02:44 <chirpsalot> mm_freak: I doubt it's that huge... I mean disk is super cheap anyway.
21:02:53 <Kaidelong> with tiny libraries it's awesome but in practice most of the libraries you use are going to be things like Qt and SDL
21:03:03 <nisstyre> chirpsalot: well, SSDs haven't gotten that big yet
21:03:09 <nisstyre> mine is "only" 500 gb
21:03:13 <chirpsalot> nisstyre: ah, that's true I suppose.
21:03:15 <nisstyre> and it was $350
21:03:19 <Kaidelong> although there are some tools to analyze libraries before statically linking them and trim out the parts you don't want
21:03:29 <mm_freak> Ralith: libc is 4.7M here, and that's only the archieve…  the actual image in memory likely ends up being larger
21:03:37 <mm_freak> Ralith: that times 100 processes
21:03:38 <geekosaur> keep your eyes open, there was a $100 1TB offer recently
21:03:41 <mm_freak> 400M
21:03:47 <mm_freak> optimistically
21:03:50 <geekosaur> (yes, SSD)
21:03:53 <Ralith> hm, fair enough
21:03:56 <nisstyre> geekosaur: company?
21:03:59 <luite> is it possible to have  a flag with an optional number with optparse-applicative, for example nothing for verbosity level 1, -v for level 3, and -vN for verbosity N?
21:04:02 <taktoa> geekosaur: where?
21:04:07 <Ralith> geekosaur: damn
21:04:11 <chirpsalot> geekosaur: oh, I was going to say $100 for 1TB HDD isn't that great :P.
21:04:24 <mm_freak> Ralith: memory is cheap, but it's not free yet =)
21:04:28 <Kaidelong> nisstyre: the irony here is that one of the areas where static linking gets used a lot is in android development where small memory capacities of phones make it particularly ill suited to the domain
21:04:46 <joelteon> is there no strict foldr because it's not needed?
21:04:50 <Kaidelong> but the convenience wins out
21:04:51 <nisstyre> Kaidelong: interesting, I didn't know that
21:05:04 <geekosaur> lemme find the latest one in my logs (may have expired by now, it was a few days ago --- at least it is out of my backscroll for the channel which suggests 2-3 days minimum)
21:05:11 <taktoa> doesn't that imply that static linking is a no brainer on desktops
21:05:23 <taktoa> since it seems to work okay on resource-constrained platforms
21:05:32 <chirpsalot> Kaidelong: Android feels like it's full of ill suited things.
21:05:34 <Kaidelong> taktoa: it really doesn't
21:05:40 <Kaidelong> android development is a nightmare
21:05:46 <chirpsalot> Yeah :(
21:05:52 <geekosaur> looks like it's Samsung 1TB
21:05:54 <taktoa> I don't mean development-wise, I mean performance-wise
21:06:03 <nisstyre> geekosaur: cool, probably decent quality then
21:06:08 <nisstyre> mine is a samsung drive
21:06:09 <geekosaur> as of 20 Feb
21:06:14 <Kaidelong> taktoa: well, I guess you could use the same techniques they use to make it workable on phones
21:06:15 <geekosaur> may have gone up since
21:06:31 <Kaidelong> but why not just dynamically link to begin with?
21:06:38 <Kaidelong> and avoid the issues entirely
21:06:46 <enthropy> Kaidelong: I don't get it then, haven't you had type errors from using multiple copies of the same package but of different versions?
21:06:59 <pharaun> is there an upgraded version of network-simple-tls to work with tls 1.2.2 ? if not i'm working on a patch for that
21:07:05 <geekosaur> there we go Feb 20 21:43:27 <Q_Continuum>   1TB 840 Evo for $499 on Amazon.
21:07:11 <mm_freak> Ralith: but apart from memory usage dynamic linking is just a lot faster on a unix-like system where processes start and die all the time…  if you had to load a statically linked image each time you type 'ls', well, just let me remind you that ELF is turing-complete =)
21:07:12 <geekosaur> oh, not the $100 one
21:07:14 <geekosaur> oh well
21:07:25 <taktoa> $500 is a lot more than $100 lol
21:07:31 <pharaun> lol
21:07:32 <geekosaur> that was an earlier one (I think a newegg special and nobody quite trusted it IIRC)
21:07:43 <pharaun> but it still "exists"
21:07:46 <pharaun> so that's a start
21:08:01 <nisstyre> does Intel make one?
21:08:15 <Kaidelong> enthropy: I don't actually write the nix language so I don't know how it's type system works, I just use it to avoid headaches. I've not run into such problems though, it seems to work as advertised when two versions of the same thing is needed (copies both versions to the store, only the correct version is exposed to the dependents)
21:08:20 <mm_freak> i actually had a fully statically linked system for a short amount of time when i used gentoo
21:08:28 <geekosaur> yeh found that mention right after and it was 850GB for like $150
21:08:37 <geekosaur> but an off brand
21:08:37 <Kaidelong> I guess I technically write nix expressions when I work with say, configuration.nix
21:08:37 <taktoa> there's this: http://www.newegg.com/Product/Product.aspx?Item=N82E16820721108
21:08:43 <mm_freak> it was way slower, and especially booting took a number of times longer
21:08:48 <Kaidelong> but that's not how I think of it
21:09:57 <geekosaur> in any case they're out there and the prices are dropping fairly quickly
21:10:31 <taktoa> why is it that mercury has like ten different backends, but haskell has few reliable backends
21:10:40 <taktoa> like, obviously people are working on this problem
21:10:55 <geekosaur> that said I am surprised static takes that much longer, shared object binding takes a fair amount of time
21:11:04 <taktoa> and it seems to me that mercury would be harder to compile
21:11:06 <nisstyre> taktoa: probably because mercury is easier to generate code from
21:11:08 <geekosaur> unless you do something like COFF/Mach-O prelinking, which has its own problems
21:11:18 <geekosaur> although come to think of it I think RH does its own prelinking thing
21:11:40 <enthropy> taktoa: if you count up all the haskell compilers out there I think you'll get close to 10 backends
21:11:53 <Kaidelong> well I think he more meant like
21:12:12 <Kaidelong> C, LLVM, native code, MSIL, Java Bytecode, etc
21:12:14 <taktoa> well yeah, but most are experimental and are fairly difficult to use, especially if you want to use hackage
21:12:18 <taktoa> yeah
21:12:20 <Kaidelong> when he said backend
21:12:30 <Fuuzetsu> is there a function that lifts into Arrow?
21:12:35 <enthropy> @type arr
21:12:36 <lambdabot> Arrow a => (b -> c) -> a b c
21:12:38 <Kaidelong> IE, what the targets for compilation are
21:12:45 <Fuuzetsu> @hoogle arr2
21:12:46 <lambdabot> No results found
21:12:58 <geekosaur> admittedly you generally only need to load a commonly used library from disk once instead of once per executable, but during system boot I think the only library you should be seeing that with is glibc itself... which is not large
21:13:01 <chirpsalot> Kaidelong: there's a JVM backend?
21:13:16 <nisstyre> there's Frege
21:13:17 <geekosaur> especially compared to, say, the various gtk+/gnome or qt/kde libs
21:13:25 <taktoa> frege, jaskell
21:13:26 <nisstyre> which is supposed to be a subset of Haskell for the JVM
21:13:31 <geekosaur> LambdaVM is kinda bitrotted
21:13:42 <Kaidelong> chirpsalot: I don't think so
21:13:51 <Kaidelong> I think mercury has one, though
21:13:54 <chirpsalot> Kaidelong: oh, I thought you said there was.
21:13:58 <Kaidelong> and I think that's what taktoa was getting at
21:14:17 <taktoa> idk, if you could make something like Clojure for Haskell
21:14:32 <taktoa> like, a tightly coupled language that runs on a few popular vms
21:14:39 <chirpsalot> taktoa: why not?
21:14:53 <taktoa> that would do a lot to help haskell's portability
21:15:20 <geekosaur> I think a JVM backend is more viable now than it was since ghcjs had to solve the main issues (getting haskell to play nicely in a less well typed ecosystem)
21:15:40 <geekosaur> but, someone still has to do the work
21:15:47 <taktoa> yeah
21:15:57 <jfischoff> I wonder if there is anything worth learning from frege and ermine
21:16:11 <geekosaur> win32/x86_64 didn't happen until someone paid for it to be done
21:16:20 <jfischoff> for targeting the jvm with a haskell like language
21:16:33 <geekosaur> and one would think that would be a high profile/high priority target...
21:16:48 <no-n> @hoogle assert
21:16:49 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
21:16:49 <lambdabot> Control.Exception assert :: Bool -> a -> a
21:16:49 <lambdabot> Control.OldException assert :: Bool -> a -> a
21:17:28 <mm_freak> Fuuzetsu: that lifts /what/ into Arrow?
21:18:52 <Kaidelong> mm_freak: anyway I think I've realized what I could do, I could maybe write up some documentation on how to install wx and gtk bindings on windows
21:19:01 <Kaidelong> although I'd need to figure it out myself first
21:19:17 <Kaidelong> I think I did get gtk2hs to install once, I could start with that
21:19:28 <Fuuzetsu> mm_freak: basically I was wondering if there's a way to rewrite this http://lpaste.net/100561 into something shorter; I don't know how to translate it as we could with monadic do notation (AFAIK it's convoluted for arrows)
21:19:31 <mm_freak> have fun =)
21:20:02 <mm_freak> Fuuzetsu: if your arrow is Applicative…
21:20:08 <mm_freak> Fuuzetsu: liftA2 (<+>)
21:20:29 <Fuuzetsu> I kind of didn't want to restrict it to Applicative but I'll consider it
21:20:43 <mm_freak> Fuuzetsu: it's not a restriction
21:21:09 <mm_freak> instance Applicative (MyArrow a)
21:21:48 <mm_freak> in fact i believe that Applicative is more general
21:21:56 <Fuuzetsu> these are HXT arrows
21:22:03 <mm_freak> those are monads anyway
21:22:13 <mm_freak> i never understood why they expose this awkward arrow interface
21:22:28 <Fuuzetsu> *shrug*
21:22:29 <taktoa> functor applicative monad problem?
21:22:45 <mm_freak> taktoa: my feeling is that arrows were just cooler =)
21:22:46 <enthropy> Fuuzetsu: use the proc notation then
21:22:51 <Fuuzetsu> enthropy: I did
21:23:00 <mm_freak> Fuuzetsu: well, there is (&&&)
21:23:03 <Fuuzetsu> I was wondering if there's a function defined already which is shorter
21:23:13 <mm_freak> arr (<+>) . x &&& y
21:23:20 <mm_freak> arr (uncurry (<+>)) . x &&& y
21:23:27 <Fuuzetsu> :t arr (uncurry (<+>)) . x &&& y
21:23:27 <lambdabot>     Ambiguous occurrence `<+>'
21:23:27 <lambdabot>     It could refer to either `Control.Arrow.<+>',
21:23:27 <lambdabot>                              imported from `Control.Arrow' at /home/lambda/.lambdabot/State/L.hs:37:1-20
21:23:39 <mm_freak> :t arr (uncurry (<|>)) . x &&& y
21:23:40 <lambdabot>     Couldn't match expected type `a0 -> (f0 a1, f0 a1)'
21:23:40 <lambdabot>                 with actual type `Expr'
21:23:40 <lambdabot>     In the second argument of `(.)', namely `x'
21:23:44 <mm_freak> :t \x y -> arr (uncurry (<|>)) . x &&& y
21:23:44 <lambdabot> Alternative f => (a -> (f a1, f a1)) -> (a -> c') -> a -> (f a1, c')
21:23:55 <mm_freak> oh
21:23:59 <mm_freak> :t \x y -> arr (uncurry (<|>)) <<< (x &&& y)
21:24:00 <lambdabot> (Arrow cat, Alternative f) => cat a (f a1) -> cat a (f a1) -> cat a (f a1)
21:24:58 <Fuuzetsu> that works
21:26:19 <mm_freak> to be honest i prefer xml-conduit's cursor approach
21:30:08 <pharaun> mm_freak: can it parse html?
21:30:25 <pharaun> the shitty formatted html parsing problem is what lead me to hxt :)
21:30:54 <mm_freak> pharaun: unlikely
21:31:00 <mm_freak> it pretty much requires well-formed XML
21:31:04 <pharaun> ouch
21:31:16 <mm_freak> that's fine for XML applications =)
21:31:34 <mm_freak> for malformed stuff i'd probably try tagsoup before trying anything else
21:31:45 <mm_freak> IIRC it's made for this
21:31:50 <pharaun> i'm actually using tagsoup in hxt
21:32:08 <pharaun> haven't tried raw tagsoup parsing so i'm not sure if i would like it
21:32:28 <randomclown> mm_freak: i.imgur.com/XEXY62Z.png
21:32:38 <randomclown> mm_freak: how do I probe what's causing this
21:33:37 <mm_freak> randomclown: no clue
21:33:44 <mm_freak> i've actually never used profiling
21:33:54 <randomclown> top lel
21:34:11 <randomclown> anybody that actually uses profiling?
21:35:19 <mm_freak> randomclown: i don't understand why you always ask me specifically anyway =)
21:35:58 <hindleymilner> :t (\x y -> (x, y)) :: a -> b -> c
21:35:59 <lambdabot>     Couldn't match expected type `c1' with actual type `(a1, b1)'
21:35:59 <lambdabot>       `c1' is a rigid type variable bound by
21:35:59 <lambdabot>            an expression type signature: a1 -> b1 -> c1 at <interactive>:1:1
21:36:02 <randomclown> you generally know what you are doing
21:36:14 <randomclown> going to call out carter
21:36:20 <randomclown> and Cale
21:37:02 <hindleymilner> aren't :k (x, y) and c both *? why can't i arbitrarily represent the former with the latter?
21:37:30 <mm_freak> hindleymilner: your function claims that it works "for all c"
21:37:36 <mm_freak> hindleymilner: but then it assumes that c is a tuple type
21:37:48 <mm_freak> "a -> b -> c" is the same as "forall a b c. a -> b -> c"
21:38:13 <mm_freak> so it breaks its promise:  it doesn't work for all c =)
21:38:59 <shachaf> ":: a -> b -> c" is the same as ":: forall a b c. a -> b -> c", if a,b,c are free.
21:42:47 <randomclown> shachaf: i.imgur.com/XEXY62Z.png
21:42:50 <Kaidelong> shachaf: is that condition ever not true in given that context of ()? You need a typeclass to introduce a functional dependency at least
21:42:54 <randomclown> any ideas on how to fix?
21:43:08 <randomclown> ghc doesn't tell me anything about where it's coming from
21:43:17 <shachaf> ?
21:43:33 <mm_freak> Kaidelong: if a variable is unknown (i.e. neither free nor bound), it is implicitly quantified at the outermost level of the type signature
21:43:34 <shachaf> How did functional dependency get involved?
21:43:54 <shachaf> mm_freak: How is unknown different from free?
21:44:22 <mm_freak> shachaf: ScopedTypeVariables has some weird rules
21:44:40 <Kaidelong> shachaf: was trying to think of ways to make something with a type "a -> b -> c" where a, b, and c are not free
21:44:57 <shachaf> Kaidelong: id :: (a -> b -> c) -> (a -> b -> c)
21:44:58 <Kaidelong> one way would be if one of them was determined by another
21:45:19 <shachaf> Neither of those "(a -> b -> c)" subexpressions have a,b,c free.
21:45:58 <Kaidelong> shachaf: but (a -> b -> c) -> (a -> b -> c) itself does and is a different type from a -> b -> c, and that should be sufficient because the implicit forall happens at the outermost level
21:46:28 <mm_freak> i think you can't actually have free variables in haskell…  they always get quantified implicitly
21:46:50 <shachaf> mm_freak: In "(a -> b -> c)", a,b,c are free.
21:47:04 <mm_freak> true
21:47:10 <shachaf> In "(forall a b. a -> b -> c)", c is free and a,b aren't.
21:47:33 <shachaf> When you write ":: ...", every type variable which is free in "..." gets a forall.
21:47:41 <shachaf> This is part of the ::, not part of the type.
21:47:50 <mm_freak> shachaf: only in standard haskell
21:47:59 <mm_freak> ScopedTypeVariables makes this rule more complicated
21:48:21 <shachaf> OK, I suppose it does, the way I phrased it.
21:48:36 <mm_freak> every variable that is not bound within the type signature and any parent type signature gets implicitly quantified
21:48:45 <mm_freak> other variables stay free
21:49:09 <shachaf> :: is still the thing that provides the forall, though. I think that's what I was trying to get at.
21:49:46 <mm_freak> sure, it's just not always the "::" you might expect
21:49:50 <shachaf> "a -> b -> c" isn't the same as "forall a b c. a -> b -> c", it's just a type expression, hard to give it meaning without context.
21:50:15 <mm_freak> yeah, i was really implying the context, so sorry for the confusion =)
21:50:18 <shachaf> "foo :: a -> b -> c" is the same as "foo :: forall a b c. a -> b -> c" in Haskell 2010, if Haskell 2010 had forall.
21:50:40 <mm_freak> it's the same in haskell 2010 + ExplicitForalls
21:50:40 <shachaf> I think this is important because "type expressions" can stand on their own, just like "value expressions".
21:51:03 <mm_freak> yeah, usually i'm very pedantic about that distinction
21:51:16 <mm_freak> i even tend to write A -> B where others write a -> b
21:51:31 <shachaf> The funny thing is that A and B in your "A -> B" are also quantified.
21:51:36 <Kaidelong> shachaf: I interpreted your use of ":: a" rather than "a" as saying you specifically meant a full type rather than a subexpression
21:51:40 <shachaf> They're just quantified completely outside the program.
21:52:18 <Kaidelong> in subexpressions I can agree that sometimes the variables are not free
21:52:30 <shachaf> Kaidelong: Right.
21:52:38 <Kaidelong> like (a -> b -> c) in :: (a -> b -> c) -> (a -> b -> c)
21:52:50 <Kaidelong> but I don't think in the latter context they're ever not free
21:53:12 <Kaidelong> (even with extensions? less sure about that)
21:53:23 <shachaf> ?
21:53:26 <shachaf> In which context?
21:54:04 <Kaidelong> shachaf: when you're talking about the entire type of a value where the implicit "forall" rule applies
21:55:22 <shachaf> I don't quite know what you mean, but the answer is probably either ScopedTypeVariables or RankNTypes.
21:56:59 <Kaidelong> shachaf: I think in both cases the use of those extensions shows up in the type signatures themselves
21:57:15 <Kaidelong> but don't those do the opposite anyway?
21:57:22 <Kaidelong> allow types to be free where they normally can't
21:57:47 <shachaf> I still don't know what you mean.
21:59:02 <ZNW> If I have a function
21:59:03 <ZNW>     pretty :: String -> IO String
21:59:04 <ZNW> How can I pass it to
21:59:05 <ZNW>     interact :: String -> String -> IO ()
21:59:06 <ZNW> ?
21:59:46 <enthropy> @type interact
21:59:46 <lambdabot> (String -> String) -> IO ()
21:59:58 <Kaidelong> shachaf: a way to have something of type "f :: a -> b -> c" where a, b, and c can't simply be anything, but the type is still written down by the programmer as "f :: a -> b -> c"
22:00:04 <Axman6> String -> String -> IO () != (String -> String) -> IO ()
22:00:11 <Axman6> they're very different
22:00:17 <Kaidelong> I think this is impossible even with extensions
22:00:19 <enthropy> ZNW: whichever signature it has, you aren't supposed to be able to accomplish it
22:00:21 <Kaidelong> but I'm not sure
22:00:52 <c_wraith> You can't annotate a the type of a value that was existentially quantified.
22:01:06 <enthropy> well maybe you can have:    main = do a <- pretty "hi"; b <- pretty "there"; ZNW.interact a b
22:01:13 <ZNW> yeah, I know I can't just pass it, but is there any way to transform it and still use the pretty :: String -> IO String ?
22:02:30 <enthropy> @hackage universe
22:02:30 <lambdabot> http://hackage.haskell.org/package/universe
22:02:43 <shachaf> Kaidelong: Let's simplify to "f :: a". foo :: forall a. a -> a; foo x = let { f :: a; f = x } in f
22:02:54 <enthropy> you can enumerate all the Strings up to a certain length you're likely to see
22:03:10 <enthropy> store the results of pretty applied to each of them
22:03:43 <enthropy> that's inefficient, and maybe the side effects of pretty should happen later
22:04:47 <roboguy_> ZNW: why is it String -> IO String?
22:05:09 <cschneid> I'm getting an error trying to build ghc from source - libgmp.so.3 not being there, my system installs 10.1.3 instead. Is there a way around this? (I'm on a locked down system w/ no access to package manager, gotta build from src)
22:05:21 <ZNW> it's a pretty function, read a FilePath and pretty print it
22:05:46 <roboguy_> ZNW: I'd break that into two parts: reading the file and pretty printing it. that would probably make this easier
22:06:13 <enthropy> that won't make using interact easier
22:06:20 <enthropy> @src interact
22:06:20 <lambdabot> interact f = do s <- getContents; putStr (f s)
22:06:34 <roboguy_> oh right
22:06:46 <Kaidelong> shachaf: "the type of f unifies with the right side of the type of foo"
22:06:47 <enthropy> but you can use getLine and putStr
22:07:06 <Kaidelong> do you really have to say that the type of f is restrained by the type of foo?
22:09:43 <Kaidelong> but I must leave, sadly
22:09:50 <Kaidelong> =(
22:10:05 <Kaidelong> goodbye everyone, and thanks for the coversation
22:38:06 <LamdaFan> haskellers rulez!
22:43:21 <no-n> > 1
22:43:22 <lambdabot>  1
22:43:32 <Fuuzetsu> I just ended up using ‘fmap fmap fmap’ again… There really needs to be a better name for this somewhere!
22:44:08 <no-n> filter (/='m') it
22:45:28 <enthropy> > (1,(2,(3,'4'))) & _2._2._2 %= fromEnum
22:45:29 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState
22:45:30 <lambdabot>                     s0 ((->) (t0, (t1, (t2, GHC.Types.Char)))))
22:45:30 <lambdabot>    arising from a use of `Control.Lens.Setter.%='
22:45:30 <lambdabot>  Possible fix:
22:45:30 <lambdabot>    add an instance declaration for
22:45:36 <enthropy> > (1,(2,(3,'4'))) & _2._2._2 %~ fromEnum
22:45:38 <lambdabot>  (1,(2,(3,52)))
22:50:12 <__jim__> Guys, new to cabal here. After installing a package with cabal install how do you run it? I tried the command from terminal but this didn't seem to do anything/
22:50:29 <Fuuzetsu> __jim__: what package was it?
22:50:39 <pavonia> Fuuzetsu: for functions that's usually named (.:)
22:50:49 <aalevy> __jim__ you need to make sure $HOME/.cabal/bin is in your PATH
22:50:52 <Fuuzetsu> you might have to add the cabal binaries path to ATH
22:51:15 <Fuuzetsu> pavonia: Yeah, I know, I just don't like defining it for one-time-use or having to define it in every package
22:51:18 <__jim__> wow, I didn't even think about that
22:51:23 <__jim__> seems pretty obvious
22:51:25 <__jim__> thanks guys
23:28:03 <irssi> anyone use ghcjs here? whenever i try to install a package that includes an executable on cabal, i get ghcjs: unrecognised flag: -to
23:28:33 <irssi> is there some way to exclude the executables, since js executables don't really make sense
23:28:38 <irssi> and those packages are needed just for the libraries
23:29:59 <Fuuzetsu> iirc there's a way to only install the library
23:31:31 <Fuuzetsu> huh, maybe not, can't find anything…
23:32:50 <Fuuzetsu> irssi: maybe something like ‘cabal configure && cabal build library’
23:34:13 <covi> What's the *real* difference between dependent types and refinement types? Which one do you find more interesting / useful?
23:36:04 <irssi> Fuuzetsu: thanks. that seems to skip the executable. if only there was a way to do that while cabal's automatically resolving dependencies
23:39:35 <luite> irssi: oh that's a recent problem
23:39:54 <luite> irssi: i replaced the frontend to make the command line parser better, which it is
23:40:07 <luite> irssi: but that was the one option that i didn't quite know how to do
23:40:28 <luite> irssi: hamishmack is currently working on a fix, should be done soon if he doesn't fall asleep
