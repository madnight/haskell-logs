00:02:34 <tlevine> Enigmagic are the evaluateHTMLXpath results just separated by newlines, or am i missing something?
00:10:05 * hackagebot mighttpd2 3.0.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.3 (KazuYamamoto)
00:10:05 * hackagebot protobuf 0.1.3 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.1.3 (NathanHowell)
00:24:30 <Enigmagic> tlevine: sounds about right.. i only wrote the initial version and not this stuff. if you need/want something changed feel free to send pull requests
00:24:39 <Enigmagic> tlevine: here's the newline logic https://github.com/alphaHeavy/xpathparser/blob/master/cbits/eval.c#L287
00:25:21 <prooftechnique> Anyone know the video where one of the big Scala contributors more or less swears off Scala at some Scala conference?
00:25:36 <prooftechnique> I swear I had it in my reddit saved links, but I can't find it now.
00:27:04 <prooftechnique> It had an interesting perspective that I'd like to revisit, but I can't for the life of me remember it.
00:27:34 <Platz> https://www.youtube.com/watch?v=TS1lpKBMkgg
00:28:18 <prooftechnique> Platz: That's the one! Thank you!
00:28:36 <Platz> sure, np
00:30:39 <AshyIsMe> hmm, im getting an error from !! index too large
00:30:46 <AshyIsMe> can i get a stacktrace somehow from that?
00:31:46 <simpson> AshyIsMe: Not really. You could look at places where you're calling (!!) and fix them.
00:32:58 <Cale> If you compile with profiling, and run with +RTS -xc you'll get a cost centre trace. Usually though, it's probably better just to do what simpson is suggesting.
00:34:08 <Cale> There are a lot of reasons to avoid using !! altogether in general.
00:34:43 <Cale> (There are some cases where it's really just the only thing which makes much sense, but in a lot of cases, you can avoid it somehow)
00:35:02 <jrmithdobbs> it usually means you picked the wrong container
00:35:03 * hackagebot free-game 1.0 - Create games for free  http://hackage.haskell.org/package/free-game-1.0 (FumiakiKinoshita)
00:35:06 <jrmithdobbs> if it makes sense
00:35:40 <AshyIsMe> hmm
00:35:46 <Cale> Yeah, xs !! n takes O(n) time to evaluate, and on top of that, it can fail.
00:36:08 <AshyIsMe> in this case im getting a Path back which is [Node] which is [startingpoint,n1,n2,...destination]
00:36:13 <AshyIsMe> and i want n1
00:36:27 <AshyIsMe> but yeah, im using !! in a few places so i'll bisect to find which one is causing it
00:36:43 <Cale> What happens for the path where the starting point and destination are the same?
00:37:59 <Cale> You might want to completely pattern match your list, and handle the cases of [], [s], and (s:n1:_)
00:38:10 <Cale> Rather than using !!
00:38:42 <Cale> Of course, *maybe* the list really can't have fewer than 2 elements.
00:39:16 <Cale> But even if you implement the other two cases with explicit calls to error, you'll know something about what's happening
00:44:22 <AshyIsMe> ah cool, thanks
00:44:36 <AshyIsMe> pattern matching still isnt ingrained enough yet
00:59:51 <AshyIsMe> Cale: ah cool thanks, error "no paths at all!" was displayed :)
01:00:42 <cark> hello, i have a quick question ... >>= is bind, what is the name of the >> operator ?
01:03:17 <prooftechnique> cark: I usually call it "then"
01:03:33 <cark> ah good enough =) thanks !
01:05:35 <AshyIsMe> cark: there's some more here: http://www.haskell.org/haskellwiki/Pronunciation
01:06:03 <cark> ah sequence is nice, buit that namespace is quite crowded already !
01:10:00 <Wizek> good morning!
01:10:09 <dmj`> good night
01:11:24 <jrmithdobbs> um, is it just me or does aeson kind of suck at large files?
01:11:57 <Wizek> How can I convert Data.Text.Lazy.Internal.Text to String?
01:12:00 <dmj`> how large and what version of aeson
01:12:28 <dmj`> Wized: use Data.Text.Encoding
01:12:32 <dmj`> Wizek: ^
01:12:50 <dmj`> there is a function decodeUtf8
01:12:56 <dmj`> oh wait, just to string?
01:12:59 <dmj`> call show
01:13:00 <ion> wizek: Data.Text.Lazy.unpack
01:13:05 <prooftechnique> Wizek: Does unpack not work?
01:13:39 <dmj`> wouldn't show do the same thing?
01:13:45 <ion> Hopefully not.
01:14:06 <dmj`> why hopefully?
01:14:07 <prooftechnique> :t Data.Text.unpack
01:14:08 <lambdabot> Data.Text.Internal.Text -> String
01:14:19 <prooftechnique> :t Data.Text.Lazy.unpack
01:14:20 <lambdabot> Data.Text.Lazy.Internal.Text -> String
01:14:38 <Wizek> Data.Text.Lazy.unpack did it, thanks! The next time I want to convert A to B, where can I figure it out myself? (without having to ask here)
01:14:56 <prooftechnique> Wizek: Hoogle's good
01:14:56 <ion> @hoogle Text -> String
01:14:57 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
01:14:57 <lambdabot> Data.Text.Internal showText :: Text -> String
01:14:57 <lambdabot> Data.Text.Lazy unpack :: Text -> String
01:15:06 <ion> @where hoogle
01:15:06 <lambdabot> http://haskell.org/hoogle ‚Äì See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
01:15:32 <ion> Also, reading the documentation for Data.Text.Lazy is a good idea. http://hackage.haskell.org/package/text
01:16:01 <ion> dmj: For the same reason show for String is not id.
01:36:25 <dmj`> ion: what is the definition of show for String
01:38:42 <ion> dmj: ‚Äúinstance  Show Char‚Äù, showList http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Show.html#Show
01:41:45 <dmj`> ion: interesting. do strings have an associated encoding? like how text is utf8, bytestring.char8 treats binary data as ascii, etc.
01:42:19 <ion> dmj: String is [Char] and Char represents a Unicode codepoint.
01:42:33 <dmj`> ion: every Char is 32-bits no?
01:42:45 <ion> > ord maxBound
01:42:47 <lambdabot>  1114111
01:43:35 <haasn> dmj`: not necessarily
01:43:50 <haasn> dmj`: Char is just a unicode codepoint. Haskell is opaque about the internal encoding
01:44:42 <ion> Any language that is not opaque about the internal encoding of text is doing it horribly wrong.
01:45:30 <dmj`> I see, unicode is 17 planes, w/ 2^16 code points.
01:45:33 <dmj`> > 17 * 2 ** 16
01:45:34 <lambdabot>  1114112.0
01:45:57 <haasn> > maxBound :: Char
01:45:58 <lambdabot>  '\1114111'
01:46:15 <haasn> from \0 to \1114111
01:48:45 <prooftechnique> > chr 127752
01:48:46 <lambdabot>  '\127752'
01:49:15 <dmj`> haasn: so when goes ghc decide how many bytes a Char will consume?
01:49:15 <dmj`>  
01:49:16 <prooftechnique> Someone should write an emoji library üåà
01:49:22 <dmj`> does*
01:49:33 <ion> dmj: The implementation of Char dictates that.
01:49:54 <haasn> dmj`: might be worth digging through the GHC source for that, hang on
01:50:36 <dmj`> ion: but if Char is a unicode code point, it will need to be translated to UTF no?
01:50:43 <ion> dmj: Why?
01:52:01 <ion> > map ord "hello"
01:52:02 <lambdabot>  [104,101,108,108,111]
01:52:25 <ion> dmj: [104,101,108,108,111] is another way to represent ‚Äúhello‚Äù. No UTF-xx involved.
01:52:53 <dmj`> ion: how large are those ints tho?
01:53:11 <prooftechnique> :t map ord "hello"
01:53:12 <ion> That‚Äôs not relevant to what i was trying to say.
01:53:12 <lambdabot> [Int]
01:54:27 <almostobsolete> Hello, what does it mean when I get "programname: <<loop>>" from GHC when I try to run my program
01:54:53 <almostobsolete> (forgive me if that's a hopelessly vague question, hoping that's an actual thing with an actual answer :p )
01:54:54 <dmj`> ion: I see how we can express everything in code points. But is this efficient
01:55:15 <ion> almostobsolete: It ends up in infinite recursion producing nothing. Please paste your code.
01:55:46 <ion> dmj: In general no, but in some cases the list data structure may be optimized away by fusion.
01:55:47 <almostobsolete> Ah, that makes sense. How does GHC detect infinite recursion?
01:56:17 <almostobsolete> Will see if I can solve it myself now that I know what it means, otherwise will paste some code and ask again. Thanks for your help!
01:56:18 <ion> almostobsolete: AFAIU it marks thunks it‚Äôs in the middle evaluating and detects when the evaluation leads to a thunk that was already marked.
01:56:30 <exicer> If I'm using a cabal sandbox, how can I remove all installed packages and start from scratch ?
01:56:37 <almostobsolete> Ok, that makes sense, let me see if I can puzzle this out :p
01:56:57 <ion> exicer: Try deleting the sandbox directory.
01:57:09 <prooftechnique> exicer: rm -rf .cabal-sandbox
01:57:20 <exicer> Thanks
01:59:21 <dmj`> ion: for example map ord "hello" produces integers that could be expressed in less than 8 bits, but will they be. So every platform will do it different? Based on processor architecture?
01:59:31 <randomclown> has anyone used hedis before?
02:00:08 <ion> dmj: In GHC, Int has a constant size. Char probably has a constant size, too.
02:00:12 * hackagebot arb-fft 0.2.0.2 - Pure Haskell arbitrary length FFT library  http://hackage.haskell.org/package/arb-fft-0.2.0.2 (IanRoss)
02:00:48 <haasn> ion: constant per platform, but not constant across platforms
02:01:12 <ion> dmj: Haskell promises Int to be at least 30 bits IIRC. And it promises Char to represent a Unicode codepoint.
02:01:21 <ion> > maxBound :: Int
02:01:22 <lambdabot>  9223372036854775807
02:01:33 <dmj`> that's 64-bit
02:01:56 <ion> > logBase 2 (fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int))
02:01:57 <lambdabot>  64.0
02:02:17 <haasn> ‚ÄúThe finite-precision integer type Int covers at least the range [  ‚àí2^29, 2^29‚àí1]‚Äù
02:02:37 <haasn> This is the promise made by Haskell
02:02:54 <vlatkoB> I'm going through Persistent tutorial and trying to get count of all rows, no Filter.
02:02:54 <vlatkoB> How to let 'count' know to count on Person? Something of a kind:
02:02:54 <vlatkoB>   i <- (count [] :: Person)
02:02:54 <haasn> GHC chooses a machine integer on 32+ bit platforms. I don't know if GHC actually compiles to any platforms with 16 bit machine integers
02:03:38 <dmj`> so is it safe to say a code point assumes the max size of an Int on the given platform?
02:05:26 <tharper> dmj`: yes
02:05:33 <tharper> dmj`: that is exactly how it works
02:05:46 <tharper> if you mean [Char]
02:06:09 <tharper> Each char is an (unencoded) unicode code point represented by a 32+-bit integer
02:07:56 <dmj`> tharper: what is the difference between Word and Int then
02:08:58 <tharper> there are different Word sizes, iirc
02:09:12 <tharper> Word is the same as int
02:09:17 <tharper> but then there is word8, word16, etc
02:09:20 <Kaidelong> is ByteStream misnamed?
02:09:31 <Kaidelong> or does it use Word8 internally no matter what?
02:09:36 <tharper> I beleive it uses word8
02:09:37 <Kaidelong> ByteString*
02:10:17 <tharper> it's not misnamed, as in
02:10:21 <dmj`> so Word8 is just an 8-bit integer
02:10:24 <tharper> yes
02:10:26 <tharper> well
02:10:26 <tharper> unsigned
02:10:31 <tharper> but yes
02:10:37 <Kaidelong> mmm, is that just because most modern machines can efficiently work with bytes still even if their machine words are larger than a byte?
02:10:51 <tharper> it is because people wnated to do byte-level io
02:10:57 <tharper> in particular it is good for ASCII text processing
02:11:01 <tharper> or something analogous
02:11:16 <tharper> where the logical unit one is dealing with fits into a byte
02:11:28 <tharper> since char/int take up far too much space
02:12:02 <tharper> at the io-level I believe it reads in blocks that larger than bytes but the data is always represented as byte blocks
02:12:07 <tharper> that are larger*
02:13:37 <varr> !seen joshcough
02:14:11 <Wizek> @hoogle [a] -> Int -> Maybe a
02:14:12 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:14:12 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:14:12 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
02:14:52 <dmj`> :t listToMaybe
02:14:53 <lambdabot> [a] -> Maybe a
02:15:57 <Wizek> dmj`: But that only takes first, no?
02:16:08 <tharper> it must do
02:16:35 <tharper> Maybe is the non-recursive base functor of list
02:16:50 <tharper> well, Maybe (a,b) is
02:17:02 <tharper> I guess Maybe a just takes the head in that case
02:17:05 <henk> Where is syntax such as '<-' documented?
02:17:21 <Wizek> henk: good question
02:17:38 <Wizek> Is there a `[a] -> Int -> Maybe a` implementation of (!!)?
02:17:50 <dmj`> henk: it's just sugar I believe
02:17:53 <dmj`> :t \x -> listToMaybe . (x!!)
02:17:53 <lambdabot> [[a]] -> Int -> Maybe a
02:18:50 <Wizek> Why the double list?
02:18:58 <dmj`> Wizek: (!!) can throw exceptions
02:19:03 <Wizek> I know
02:19:09 <Axman6> @hoogle [a] -> Int -> Maybe a
02:19:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:19:10 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:19:10 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
02:19:13 <Wizek> let me try
02:19:22 <Axman6> you're crap lambdabot
02:20:07 <henk> dmj`: sugar for?
02:20:26 <dmj`> henk: for dealing w/ monads
02:20:41 <simpson> :t \xs i -> do { guard $ length xs < i; return $ xs !! i } -- I shouldn't be allowed to Haskell after midnight
02:20:41 <dmj`> > [1..10] >>= \x -> [x,x]
02:20:41 <lambdabot> MonadPlus m => [b] -> Int -> m b
02:20:42 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
02:20:58 <dmj`> > do { x <- [1..10]; return [x,x] }
02:20:59 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]
02:21:04 <tharper> dmj`: hat do you want to know about it? there are of course many monad tutorials
02:21:27 <tharper> there is a way to express how it desugars
02:21:31 <simpson> > let f xs i = do { guard $ length xs < i; Just $ xs !! i } in f [1..10] 4
02:21:32 <lambdabot>  Nothing
02:21:51 <simpson> > let f xs i = do { guard $ length xs > i; Just $ xs !! i } in f [1..10] 4 -- wow, so derpy
02:21:53 <lambdabot>  Just 5
02:21:56 <tharper> it can be desugared into binds
02:22:12 <dmj`> > do { x <- [1..10]; [x,x] }
02:22:13 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
02:22:16 <dmj`> there we go
02:22:22 <tharper> hehe
02:22:35 <tharper> trickery!
02:22:46 <Wizek> > (\x -> listToMaybe . (x!!)) [[7,8,9]] 1
02:22:48 <lambdabot>  *Exception: Prelude.(!!): index too large
02:23:10 <Wizek> dmj`: I don't think this works the way you or I want it to work ;)
02:23:48 <tharper> well Maybe doesnt' catch exceptions
02:23:52 <tharper> it's a way to model them
02:23:59 <Wizek> I know
02:24:23 <Wizek> Is there an implementation of (!!) that returns Maybe instad of throwing exceptions?
02:24:32 <CindyLinz> use unsafePerformIO and then catch them.. (flee)
02:24:45 <Wizek> (I know I could implement it myself, but come on guys)
02:24:59 <simpson> Wizek: Well, I just put in a guarded implementation ^^
02:25:14 <henk> Is there a reference for this kind of sugar?
02:25:14 <Wizek> checking
02:25:29 <tharper> Wizek: I don't think so
02:25:55 <tharper> ah
02:25:55 <tharper> http://hackage.haskell.org/package/safe-0.3.4/docs/Safe.html
02:25:58 <tharper> there you go
02:26:13 <tharper> (there might be a newer version, but I knew there was a Safe package somewhere)
02:26:22 <Wizek> There we go!
02:26:25 <simpson> > let f [] _ = Nothing; f (x:_) 0 = Just x; f (x:xs) i = f xs (i - 1) in f [1..10] 4
02:26:26 <lambdabot>  Just 5
02:26:28 <dmj`> Wizek: http://lpaste.net/99325
02:26:49 <CindyLinz> :t atMay
02:26:50 <lambdabot> Not in scope: `atMay'
02:26:58 <dmj`> Wizek: prob want to check its > 0 too
02:27:08 <dmj`> if its*
02:27:38 <dmj`> henk: yea I bet if you read the haskell report it'll be in there
02:28:37 <ion> > "foo" ^? ix 2
02:28:38 <lambdabot>  Just 'o'
02:28:40 <ion> > "foo" ^? ix 3
02:28:42 <lambdabot>  Nothing
02:29:18 <dmj`> night all
02:29:20 <Philonous> Is there a chart that explains how the operators are formed?
02:29:38 <Philonous> the lens operators, I mean
02:32:05 <Wizek> Btw, how come the default implementation of (!!) uses exceptions? Isn't using Maybe a preferred alternative?
02:32:38 <ion> wizek: Historical mistakes and backwards-compatibility.
02:32:53 <Axman6> yeah, but the Prelude was designed for simplicity and teaching. people are likely to encounter (!!) beofre learning pattern matching when learning (they certainly do in our haskell course at the ANU)
02:33:27 <Philonous> That sounds horrible, Why wouldn't pattern matching be one of the first things you learn
02:33:48 <Wizek> ion: How about incrementing the major version and introducing desirable breaking changes?
02:33:50 <Axman6> because the course is not a Haskell course, it's a programming course
02:33:58 <Philonous> OK.
02:34:26 <Philonous> I'm tempted to say "Even so"
02:34:29 <Axman6> Wizek: the Prelude isn't just any ordinary library. literally everything relies on it
02:35:00 <Philonous> Wizek, There are alternative Preludes
02:35:21 <Wizek> Philonous: Really? Where do I find them?
02:35:36 <Philonous> Just enter "prelude" in the hackage search box.
02:35:41 <Philonous> http://hackage.haskell.org/packages/search?terms=prelude
02:35:45 <mirpa> There is usually some Maybe alternative like !? or lookup
02:36:00 <henk> dmilith: ok, thanks
02:36:14 <ion> wizek: FWIW, [a] is usually not appropriate in the first place when you‚Äôd want Int -> [a] -> Maybe a. For the rare cases (!!) is appropriate for, it‚Äôs the current form you want.
02:36:49 <ion> > iterate (\xs -> xs ++ " " ++ xs) "hello" !! 3
02:36:50 <lambdabot>  "hello hello hello hello hello hello hello hello"
02:37:26 <ion> Of course, [a] wouldn‚Äôt be appropriate for that either if we had an infinite list type in Prelude.
02:37:28 <Wizek> ion: What do you mean by "not appropriate"?
02:37:50 <ion> wizek: A list isn‚Äôt the appropriate data structure when your use case is random access.
02:38:22 <Wizek> In my case, it is an intermediary
02:38:55 <Wizek> The lib I use returns it, I want the one item out of it
02:39:10 <Wizek> Sometimes it isn't there
02:39:29 <Wizek> Maybe seems an appropreate structure to convert said list to
02:39:34 <Wizek> isn't it?
02:42:27 <Wizek> ion: But I think I do understand your point, I just can't really look for another lib or ask the maintiner to change it, that is outside my scope.
02:45:59 <jle`> yeah, his point is that if you can choose what data structure you want for indexed storage and access, list is not really designed for it
02:46:34 <jle`> but if it's not your control then you just live it with heh.
02:46:40 <jle`> also there are a lot of partial functions in Prelude
02:46:46 <dmilith> henk: my pleasure! ;]
02:47:06 <jle`> head is one
02:47:18 <jle`> there is the non-partial alternative, listToMaybe
02:47:32 <jle`> but there are good reasons why head is partial
02:47:45 <kqr> if i have a type data D = D { _x :: String, _y :: Maybe Int  }, how can i create a Prism' D Int?
02:48:04 <urs-of-the-backw> has anyone experience with new version of netwire, I'm hopelessly lost in constructing a stateful wire as with 4.x versions?
02:48:05 <kqr> i tried the obvious yval = y . _Just :: Prism' D Int
02:48:18 <kqr> but it complains about not deducing (p ~ (->))
02:48:45 <jle`> urs-of-the-backw: well...i've only used 5.0+
02:48:50 <jle`> so i might be able to help you
02:48:52 <jle`> or maybe not heh
02:49:06 <jle`> what are you trying to do?
02:49:31 <urs-of-the-backw> would be great, simple question, how to take a state a pure function with new state as output and construct a simple wire from that?
02:50:18 <jle`> hm
02:50:38 <jle`> it might be late but i feel like there is a comma or two missing from that sentence that is tripping me up
02:50:44 <kqr> worth noting is that D "hello" (Just 57) & y . _Just .~ 53 works fine, so it's something about ambiguous type variables I guess
02:50:49 <urs-of-the-backw> I'm basically missing the old: mkState signature
02:51:09 <jle`> can you say it in types?
02:51:13 <urs-of-the-backw> with: mkState ::      s ->      (Time -> (a, s) -> (Either e b, s)) ->      Wire e m a b
02:51:32 <jle`> and s is the initial state?
02:51:37 <jle`> (the first parameter)
02:51:40 <urs-of-the-backw> yes
02:52:51 <jle`> okay
02:52:52 <randomclown> hmm, if I accidentally install cabal install a library without --profiling enable
02:53:01 <randomclown> I'll have to nuke my entire .cabal-sandbox
02:53:03 <randomclown> lame
02:53:15 <jle`> i would do that using mkPure
02:53:22 <jle`> but i'm not sure if that's the idiomatic way to do it
02:53:36 <jle`> but at least that's how integral/accum/scan etc. are implemented
02:54:15 <jle`> do you know your way around Auto?
02:54:30 <urs-of-the-backw> mkPure sounds good but how to get the out-wire then done in the signal function?
02:54:43 <jle`> http://hackage.haskell.org/package/netwire-5.0.0/docs/src/FRP-Netwire-Move.html#integral
02:54:45 <jle`> might help you
02:55:17 <jle`> i'm sorry, i'm not totally sure what you are asking
02:55:20 <urs-of-the-backw> and why is state parameter s (or isn't this the state parameter) the same as in the Wire signature for the time variable, this is where I'm actually lost
02:55:28 <jle`> oh
02:55:32 <jle`> the s in Wire s e m a b
02:55:37 <jle`> actually parameterizes the time
02:55:41 <jle`> time type
02:55:43 <jle`> time step type, etc.
02:55:55 <urs-of-the-backw> yes, I know, but where is the state parameter then?
02:56:02 <jle`> there is no state parameter
02:56:13 <jle`> there is a, the input, b, the output
02:56:43 <urs-of-the-backw> integral is a good example, let me understand
02:56:50 <urs-of-the-backw> I need 5 min
02:56:50 <jle`> if you want an underlying state monad then it'd be in the type of your monad but that's probably not what you are talking about
02:56:55 <jle`> no problem.
02:57:29 <jle`> the key is in the recursive call to integral
02:57:34 <jle`> that's the 'new wire'
02:57:40 <jle`> it's integral with a new initial state
02:58:23 <jle`> so the wire basically looks like f :: state -> (b, f newState)
02:58:26 <jle`> in simple-ish terms
02:58:59 <jle`> you carry your state in the function call, and modify it in the recursive call
02:59:25 <urs-of-the-backw> the state is in the recursion variable, wow
02:59:46 <jle`> yeah it's kinda neat
02:59:49 <jle`> not sure how it was done before
03:00:02 <jle`> actaully in this way it's impossible to extract the state from the wire
03:00:06 <jle`> because if you think about it
03:00:11 <jle`> the "state" can actually vary dynamically
03:00:17 <jle`> the type of the state, that is
03:00:41 <jle`> so you can have a wire whose state turns from a Double to a String to a Bool etc, but with still the same type signaturel Wire s e m a b
03:01:26 <jle`> which is why it doesn't make sense to have a state parameter in the type of the wire
03:08:12 <urs-of-the-backw> jle': yes the state should not be in the type of the wire agree, but it is also not any more in the type of the construction functions, ... but you point with the integral is a good example. Thanks !
03:09:45 <jle`> urs-of-the-backw: yeah i feel like it would not be too hard to write a convenience function that does exactly what you want
03:09:56 <jle`> and make the recursive plumbing stuff for you
03:10:08 <jle`> it would not be as powerful as a general mkPure
03:10:12 <jle`> but it might be handy to have
03:10:31 <jle`> i wonder if it's there somewhere that i can't find, or if there was an intentional reason why it was left out
03:10:59 <mm_freak> urs-of-the-backw: mkState is gone, because it was not supposed to be used by application developers and framework developers should prefer the recursive mkGen/mkPure (and the many new functions in netwire 5)
03:11:08 <mm_freak> urs-of-the-backw: mkState was really just translated to those
03:11:49 <jle`> oh hi mm_freak
03:11:59 <mm_freak> if you want an FRP-compliant mkState you can use accumE or iterateE
03:12:09 <mm_freak> hi there jle`
03:12:22 <jle`> hope you don't mind me trying to fumble around with an explanation :)
03:12:47 <mm_freak> no worries‚Ä¶  i'm actually glad =)
03:13:12 <mm_freak> at this very moment i'm experimenting with the wire abstraction in the context of a small opengl game
03:13:12 <jle`> i understand the reasoning now
03:13:20 <mm_freak> i'll upload the code, as soon as something is visible =)
03:13:27 <jle`> mm_freak: that would be wonderful :)
03:13:32 <jle`> i
03:13:41 <jle`> have hooked up my frp n-body to GLUT
03:14:07 <mm_freak> jle`: if it looks pretty, you should make a video and post it on vimeo/youtube =)
03:14:30 <jle`> mm_freak: hopefully :)  it's supposed to be a solar system simulation
03:14:38 <jle`> i got the real numbers of the actual positions and velocities
03:14:44 <jle`> of the bodies in the solar system
03:14:47 <jle`> and so they move around
03:15:12 <jle`> but i'm trying to make the frontend as generic and reusable as possible
03:15:16 <jle`> for my other eventual stuff
03:16:32 <jle`> anyways, i'm off to bed. submitted an assignment due at 4 am. look forward to the result of your work :)
03:16:57 <Yuu-chan_> What for are irrefutable patterns (those with ~) used?
03:17:29 <bennofs> Yuu-chan_: they increase laziness
03:17:48 <bennofs> > let ~(Just x) = Nothing in 3
03:17:49 <lambdabot>  3
03:17:52 <bennofs> > let (Just x) = Nothing in 3
03:17:53 <lambdabot>  3
03:17:54 <mm_freak> jle`: good night
03:17:58 <bennofs> oops
03:18:15 <bennofs> > let f ~(Just x) = 3 in f Nothing
03:18:16 <lambdabot>  3
03:18:19 <bennofs> > let f (Just x) = 3 in f Nothing
03:18:20 <lambdabot>  *Exception: <interactive>:3:5-18: Non-exhaustive patterns in function f
03:18:52 <Yuu-chan_> > let f ~(Just x) = x in f Nothing
03:18:53 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern (Da...
03:19:09 <bennofs> The pattern is only evaluated when x is actually used
03:19:49 <Yuu-chan_> bennofs: I knew, but I couldn't imagine a use case
03:20:42 <bennofs> Yuu-chan_: ah ok. I didn't need to use irrefutable patterns myself yet
03:24:12 <haasn> Yuu-chan_: the first use case that comes to mind for me is using it for recursive functions that would be _|_ without them
03:24:24 <haasn> if you match on a tuple that's returned from the future, without using the fields yet
03:24:36 <haasn> you can sometimes end up blackholing yourself
03:24:48 <bennofs> haasn: is that how the state monad uses irrefutable patterns?
03:26:00 <haasn> bennofs: Not entirely sure about that; maybe to avoid even invoking ‚Äòf‚Äô if you never end up using the state *or* the return value
03:26:05 <haasn> evaluating*
03:26:48 <randomclown> is there a way to install a handler when a thread dies?
03:27:05 <mm_freak> randomclown: forkIO (myThread `finally` myHandler)
03:27:15 <mm_freak> note:  this does not work when the main thread exits
03:27:54 <bennofs> @hoogle forkFinally
03:27:55 <lambdabot> No results found
03:28:38 <fernando-alonso> :i finally
03:28:49 <quchen> bennofs, randomclown: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#v:forkFinally
03:29:00 <quchen> Exists, but Hoogle is out of date
03:29:02 <fernando-alonso> :t finally
03:29:02 <lambdabot> IO a -> IO b -> IO a
03:30:11 <bennofs> fernando-alonso: you should probably use forkFinally
03:30:55 <randomclown> is there a way to ensure the main thread dies when a child thread dies?
03:31:17 <randomclown> I suppose mainthread has to wait on a mvar or something
03:31:18 <mm_freak> randomclown: put into an MVar () in the child, take the MVar in the main thread
03:31:25 <randomclown> that's the only way?
03:31:45 <mm_freak> randomclown: all ways boil down to that‚Ä¶  of course there are some abstraction libraries that make this easier
03:31:48 <mm_freak> for example the async library
03:31:49 <quchen> randomclown: Async is useful to back-propagate exceptions. Make the main thread wait for the async, if something happens in the child the exception is re-thrown by wait.
03:32:34 <bennofs> randomclown: with async, I think you can write `link $ async $ yourHandler`
03:32:43 <bennofs> s/yourHandler/myThread
03:33:51 <mirpa> Is there some howto for cursored arrays in Repa (without stencils)?
03:37:53 <randomclown> I see
03:41:47 <henk> dmilith: oops sorry
03:41:54 <dmilith> no problem :}
04:00:25 * hackagebot free-game 1.0.1 - Create games for free  http://hackage.haskell.org/package/free-game-1.0.1 (FumiakiKinoshita)
04:10:27 * hackagebot Monaris 0.1.7 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.7 (FumiakiKinoshita)
04:17:08 <arbus> Is http://learnyouahaskell.com/ a good place to start haskell or do you guys have a better recommendation?
04:17:35 <bennofs> arbus: it's definitely good
04:17:56 <arbus> cool, thanks! Digging in now
04:29:16 <AlainODea> arbus: LHAH is solid and accessible. I really enjoyed it and it gave me a good base to use Haskell. RWH is a good follow-up since it has some good challenges that get you thinking functionally but it has a few annoying bugs
04:30:57 <quchen> Just keep in mind that the explanation of foldr in LYAH is wrong and should be skipped.
04:35:46 <arbus> Thanks Alain! What is RWH?
04:36:19 <mirpa> Real World Haskell book
04:36:23 <arbus> Thanks for the heads up quchen, I am still in chapter 2 but will keep an eye out for it
04:36:33 <arbus> Thanks
04:41:12 <orion> hmm
04:43:30 <orion> Is there a solutions manual to the NICTA course?
05:04:08 <sauravtom> Hi guys, are there any big projects scheduled for GSCO14, related to haskell which an interested student might start looking into starting now ?
05:16:03 <deevus> Hello!
05:17:52 <deevus> I come from HN.
05:18:12 <randomclown> deevus: best IRC channels?
05:18:12 <sauravtom> oh that new thread about the best irc channel
05:18:37 <deevus> randomclown, sauravtom: correct
05:19:17 <deevus> I can pause making internet points for a moment to ponder Haskell
05:20:12 <sauravtom> what are internet point ?
05:20:19 <randomclown> upvotes
05:20:29 <sauravtom> okay
05:20:30 <deevus> sauravtom: HN karma
05:21:09 <jfeltz> are all Parsec "primitives" consume input on failure? this seems unclear
05:21:27 <jfeltz> do* all
05:22:05 <deevus> I've tried learning Haskell, Clojure, F#. It's definitely a different way of thinking than I'm used to when programming.
05:25:23 <notdan> jfeltz: not all of them
05:26:08 <notdan> there is 'try'
05:26:50 <notdan> manyTill
05:26:52 <notdan> and others
05:28:23 <deevus> exit
05:28:27 <deevus> !!
05:30:24 <jfeltz> notdan: gah, ok, i'm raged then, I noticed that many1 (char '\SP') doesn't consume input when the next parser in the monad is successful, or whatever, but when I do many1 customParser it will, I don't know how to distinguish them
05:31:34 <jfeltz> notdan: ya, I've worked around this with try, but there should be some intuition of some sort here
05:43:34 <Redz> should i use (<$>) or fmap?
05:44:17 <mmmm> liftA
05:45:07 <simukis_> Redz: Either is fine. Pick depending on how they would look in your code. E.g. (<$>) often looks better when you're doing pointless things.
05:45:58 <Redz> thanks simukis_
05:47:48 <iyerland> what is an invariant?
05:48:17 <notdan> jfeltz: hm, strange
05:48:23 <notdan> can you give a small example?
05:49:43 <mgoszcz2> :q
05:49:53 <mgoszcz2> Damn it! Sorry
05:50:04 <randomclown> is Aeson's TH able to generate parser for objects with keys?
05:50:23 <randomclown> from the docs it looks it'd make arrays of values which is not ideal for configuration files
05:53:25 <mm_freak_> > seq undefined `seq` ()
05:53:26 <lambdabot>  ()
05:55:44 <jfeltz> iyerland: depending on who you ask, it can mean different things, generally, it's an assertion on some property, or a predicate of the output that must hold True, given pre-conditions of an input on a function
05:56:11 <randomclown> @hoogle getArgs
05:56:12 <lambdabot> System.Environment getArgs :: IO [String]
05:56:12 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
05:56:12 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
05:56:32 <iyerland> jfeltz: thanks! that helps.
05:56:41 <sdfsxzxds> @hoogle mapM
05:56:41 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:56:41 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:56:41 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:02:00 <shouya1> hello guys,
06:02:29 <shouya1> i just encountered a problem when installing cabal on my gentoo laptop.
06:03:23 <shouya1> it prompted that it cannot find the package Control.DeepSeq
06:03:29 <shouya1> „ÄåCould not find module `Control.DeepSeq'„Äç
06:04:06 <shouya1> while it is actually installed since I could see it in the output of 'ghc-pkg list'.
06:09:11 <AshyIsMe> wow gentoo, i didnt realise people still used it
06:10:21 <mornfall> AshyIsMe: what do people actually use these days?
06:10:40 * hackagebot enummapmap 0.7.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.7.0 (MatthewWest)
06:11:00 <AshyIsMe> osx on the laptop, ubuntu or fedora core or the server :P
06:11:11 <AshyIsMe> i have no idea what the actual usage stats are, that's just me
06:11:45 <Sosacek> archlinux
06:12:02 <Sosacek> but OS X is good choice for the lazy
06:12:36 <AshyIsMe> the mac laptops are nice products and osx is unixy enough i've found
06:12:40 <shouya1> gentoo's fine yet.
06:13:16 <shouya1> so anyone has ideas about that?
06:13:35 <shouya1> I'm now compiling all packages manually.
06:15:30 <AshyIsMe> shouya1: did you manually type those nice quotes around the error message above?
06:15:43 <AshyIsMe> or was that just copy pasted?
06:16:05 <shouya1> that line was just copied directly from the output.
06:16:43 <shouya1> I am now typing commands like: „Äåfor i in zlib-0.5.4.1 stm-2.4.2 random-1.0.1.1 transformers-0.3.0.0 text-0.11.3.1 parsec-3.1.4 network-2.4.2.1 HTTP-4000.2.8; do cd $i; ghc --make Setup && ./Setup configure && ./Setup build && sudo ./Setup install; done„Äç
06:17:18 <bezirg> hey ppl, question: is there a performance benefit to use the ST monad instead of IO?
06:17:19 <shouya1> missed a 'cd ..'
06:17:55 <bennofs> bezirg: ST uses IO under the hood, so there shouldn't be
06:19:47 <bezirg> bennofs: thx
06:23:14 <wereHamster> how do I convert a NominalDiffTime to Double?
06:24:48 <quchen> wereHamster: realToFrac
06:31:48 <skypers> @hoogle Map k a -> [a]
06:31:49 <lambdabot> Data.Map.Lazy elems :: Map k a -> [a]
06:31:49 <lambdabot> Data.Map.Strict elems :: Map k a -> [a]
06:31:49 <lambdabot> Data.Map.Lazy keys :: Map k a -> [k]
06:33:54 <klrr_> hmm, i got hard time grapsing how to use Data.Machine.Wye, anyone know any example? (google search didnt help, only found one example which was for 0.3)
06:33:58 <exicer> How can I lift Maybe into MaybeT IO ?
06:34:00 <klrr_> i use the one on hackage
06:35:14 <supki> :t Control.Monad.Trans.Maybe.MaybeT . return
06:35:15 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
06:35:25 <wereHamster> quchen: thanks, that worked
06:36:56 <skypers> @pl MaybeT . return
06:36:57 <lambdabot> MaybeT . return
06:37:17 <skypers> I thought there was a more convenient way to do that
06:40:19 <skypers> or maybe
06:40:25 <skypers> :t maybe mzero return
06:40:26 <lambdabot> MonadPlus m => Maybe a -> m a
06:41:33 <bennofs> @let import Control.Monad.Trans.Maybe
06:41:35 <lambdabot>  Defined.
06:41:53 <bennofs> @ty F.foldMap return :: Monad m => Maybe a -> MaybeT m a
06:41:54 <lambdabot>     Could not deduce (Monoid (MaybeT m1 a1))
06:41:54 <lambdabot>       arising from a use of `foldMap'
06:41:54 <lambdabot>     from the context (Monad m)
06:42:00 <bennofs> :|
06:46:10 <skypers> @hoogle (MonadTrans m, MonadTrans m1) => m a -> m1 a
06:46:11 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
06:46:11 <lambdabot> Language.Haskell.TH.Syntax unQ :: Q a -> forall m. Quasi m => m a
06:46:11 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
06:46:18 <ge0rJey> #go-nuts
06:56:41 <skypers> @let import Control.Comonad
06:56:41 <lambdabot>  .L.hs:38:1:
06:56:42 <lambdabot>      Control.Comonad: Can't be safely imported!
06:56:42 <lambdabot>      The package (comonad-4.0) the module resides in isn't trusted.
06:56:49 <skypers> what
06:56:54 <skypers> :t duplicate
06:56:54 <lambdabot>     Not in scope: `duplicate'
06:56:55 <lambdabot>     Perhaps you meant one of these:
06:56:55 <lambdabot>       `replicate' (imported from Data.List),
06:56:59 <skypers> dammit!
06:57:10 <skypers> I just came up with a funny function
06:57:27 <skypers> cross :: (Comonad m, Monad t) => m a -> t a; cross = return . extract
07:00:06 <skypers> ahah it‚Äôs nice
07:00:07 <skypers> maybe "dammit!" show $ cross (1,6)
07:00:07 <skypers> "6"
07:00:21 <skypers> :)
07:02:25 <skypers> either (const "dammit") show $ cross (1,6)
07:02:26 <skypers> "6"
07:02:29 <skypers> that‚Äôs sweet
07:03:20 <rootlocus> I was reading about lambdabot, can it really evaluate haskell expressions through irc?
07:03:42 <dv-> > 1 + 1
07:03:43 <lambdabot>  2
07:03:46 <skypers> > concat ["yes","I","can"]
07:03:47 <lambdabot>  "yesIcan"
07:03:59 <rootlocus> awesome :D
07:04:02 <Moogles> nice
07:04:11 <fredcy> #lesswrong
07:04:12 <skypers> > intercalate " " ["yes","I","can"]
07:04:12 <lambdabot>  "yes I can"
07:04:25 <dv-> > unwords ["yes", "I", "can"]
07:04:26 <lambdabot>  "yes I can"
07:05:22 <klrr_> anyone know any example code or explanation about how you use Wye in machines 2.*?
07:08:04 <skypers> @let cross :: (Comonad w, Monad m) => w a -> m a; cross = return . extract
07:08:04 <lambdabot>  .L.hs:162:11: Not in scope: type constructor or class `Comonad'
07:08:05 <lambdabot>  
07:08:05 <lambdabot>  .L.hs:163:18: Not in scope: `extract'
07:08:13 <skypers> dammit, please update lambdabot!
07:08:25 <bennofs> @let import Control.Comonad
07:08:26 <lambdabot>  .L.hs:38:1:
07:08:26 <lambdabot>      Control.Comonad: Can't be safely imported!
07:08:26 <lambdabot>      The package (comonad-4.0) the module resides in isn't trusted.
07:08:34 <skypers> already tried, bennofs
07:08:51 <Datsundere> lambdabot, help
07:09:08 <Datsundere> help
07:09:42 <Datsundere> @let 2+2 = 5
07:09:44 <lambdabot>  Defined.
07:09:45 <skypers> @let class Comonad w where { extract :: w a -> a; duplicate w a -> w (w a) }
07:09:45 <lambdabot>  Parse failed: Parse error: ->
07:09:54 <skypers> @let class Comonad w where { extract :: w a -> a; duplicate :: w a -> w (w a) }
07:09:54 <lambdabot>  Defined.
07:10:05 <Datsundere> @ cycle "te"
07:10:09 <skypers> how do we define instances in lambdabot ?
07:10:16 <Datsundere> @cycle "te"
07:10:16 <lambdabot> Unknown command, try @list
07:10:41 <bennofs> @let import Control.Monad.Identity
07:10:42 <lambdabot>  Defined.
07:11:20 <bennofs> @let instance Comonad Identity where { extract = runIdentity; duplicate = Identity }
07:11:21 <lambdabot>  Defined.
07:11:26 <bennofs> skypers: ^^ like this?
07:11:49 <skypers> @instance Comonad ((,) b) where { extract = snd ; duplicate p@(a,b) = (p,b) }
07:11:49 <lambdabot> Maybe you meant: instances instances-importing
07:11:57 <skypers> @let instance Comonad ((,) b) where { extract = snd ; duplicate p@(a,b) = (p,b) }
07:11:58 <lambdabot>  .L.hs:175:31:
07:11:58 <lambdabot>      Couldn't match expected type `b' with actual type `(b, a)'
07:11:58 <lambdabot>        `b' is a rigid type variable bound by
07:11:58 <lambdabot>            the instance declaration at .L.hs:173:10
07:11:58 <lambdabot>      In the expression: p
07:12:02 <skypers> oops
07:12:38 <bennofs> > extract (Identity 'h')
07:12:40 <lambdabot>  'h'
07:12:56 <skypers> @let instance Comonad ((,) b) where { extract = snd ; duplicate (a,b) = (a,(a,b)) }
07:12:58 <lambdabot>  Defined.
07:13:05 <bennofs> @hoogle (=>>) +comonad
07:13:05 <lambdabot> Could not find some databases: comonad
07:13:05 <lambdabot> Searching in:
07:13:05 <lambdabot>   .
07:13:18 <skypers> @let cross :: (Comonad w, Monad m) => w a -> m a; cross = return . extract
07:13:20 <lambdabot>  Defined.
07:13:33 <skypers> > cross (1,4) :: Maybe Int
07:13:36 <lambdabot>  Just 4
07:13:44 <skypers> > cross (1,4) :: Either String Int
07:13:46 <lambdabot>  Right 4
07:13:48 <skypers> \m
07:14:05 <skypers> > cross (1,4) :: MaybeT Int
07:14:06 <lambdabot>  Kind mis-match
07:14:07 <lambdabot>  The first argument of `Control.Monad.Trans.Maybe.MaybeT' should have kind `*
07:14:07 <lambdabot>                                                                             -...
07:14:07 <lambdabot>  but `GHC.Types.Int' has kind `*'
07:14:13 <skypers> > cross (1,Just 4) :: MaybeT Int
07:14:14 <lambdabot>  Kind mis-match
07:14:14 <lambdabot>  The first argument of `Control.Monad.Trans.Maybe.MaybeT' should have kind `*
07:14:14 <lambdabot>                                                                             -...
07:14:14 <lambdabot>  but `GHC.Types.Int' has kind `*'
07:14:20 <skypers> yeah, well. :D
07:14:42 <bennofs> @let a =>> f = fmap f (duplicate a)
07:14:44 <lambdabot>  Defined.
07:14:47 <bennofs> @ty (=>>)
07:14:47 <lambdabot> (Functor f, Comonad f) => f a -> (f a -> b) -> f b
07:15:01 <bennofs> @let (<<=) = flip (=>>)
07:15:02 <lambdabot>  .L.hs:179:14:
07:15:02 <lambdabot>      No instance for (Comonad f0) arising from a use of `=>>'
07:15:02 <lambdabot>      The type variable `f0' is ambiguous
07:15:02 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
07:15:02 <lambdabot>      Note: there are several potential instances:
07:15:13 <bennofs> @let (<<=) a b = flip (=>>) a b
07:15:15 <lambdabot>  Defined.
07:15:15 <maxiepoo> have people seen all the love this channel is getting on hacker news right now?
07:15:20 <skypers> join $ cross (undefined,Just a)
07:15:25 <skypers> > join $ cross (undefined,Just a)
07:15:27 <lambdabot>  Just a
07:15:35 <skypers> yeah, I‚Äôm going to stop now
07:16:20 <skypers> btw my class is not the real Comonad, it lacks extend
07:17:08 <bennofs> skypers: and the Functor superclass
07:17:32 <skypers> yep
07:17:41 <skypers> it was just to test cross in there
07:18:43 <skypers> comonads are really cool
07:20:22 <skypers> ok
07:20:48 <skypers> I think withArray has a type that implies issues
07:20:54 <skypers> (and all with* functions actually)
07:21:09 <bennofs> Still, I haven't yet found an use for comonads apart from using it for calculating a new "cell" by looking at the "neighbours" of some datastructure
07:21:38 <skypers> withArray is something like newArray, calling f with it, then freeing
07:21:52 <skypers> but it forces the monad to be IO
07:22:19 <magneticduck> o/ hey guys
07:22:26 <magneticduck> wondering about how to name something...
07:22:28 <skypers> it‚Äôs a pain
07:23:02 <magneticduck> ..is 'lift' the proper word for something that "lifts" a function on some smaller type onto a data structure that holds that type?
07:23:13 <magneticduck> like fmap for functors, but the data type in question doesn't take a type parameter
07:23:39 <magneticduck> like let's say I have a list type that, for various justified reasons, only holds integers; what could I call the function (Int -> Int) -> (Data -> Data)?
07:23:39 <skypers> we can‚Äôt do that with withArray: do { a <- liftIO (newArray n); f a; liftIO (free a) }
07:23:47 <skypers> s/that/this
07:24:17 <skypers> magneticduck: lift collides with MonadTrans.lift
07:24:26 <skypers> listLift, maybe?
07:24:29 <bennofs> skypers: what happens if that is in the MaybeT IO monad?
07:24:31 <magneticduck> skypers: yeah, I'd call it something like listLift
07:24:41 <magneticduck> skypers: but it has to be a kind of common problem; is there any standard?
07:24:44 <skypers> bennofs: what do you mean?
07:24:59 <skypers> magneticduck: well, yes: lift
07:25:03 <skypers> lists are monad too
07:25:21 <skypers> and the proper name for your function is liftM
07:25:32 <bennofs> skypers: if f returns a result of type MaybeT IO (), then the array will never be freed if it returns MaybeT (return Nothing)
07:25:48 <bennofs> @hackage mono-traversable
07:25:48 <lambdabot> http://hackage.haskell.org/package/mono-traversable
07:25:50 <skypers> bennofs: solid point indeed
07:25:52 <bennofs> magneticduck: you could use that ^^
07:25:57 <skypers> dammit‚Ä¶
07:26:03 <bennofs> @hackage monad-control
07:26:03 <lambdabot> http://hackage.haskell.org/package/monad-control
07:26:05 <bennofs> skypers: ^^
07:27:26 <skypers> magneticduck:
07:28:57 <maxiepoo> or write a `Traversal' Data Int` as defined in lens
07:29:15 <frogo> hey , I was wondering if someone could explain what does 'space' has the highest precedence?
07:29:21 <bennofs> skypers: I think `control (\run -> withArray n (run $ f a)` (control is from the package I linked) does the trick
07:29:37 <skypers> how could it work?
07:29:45 <maxiepoo> frogo what do you mean? did you read that somewhere?
07:29:57 <bennofs> I meant `control (\run -> withArray n $ run . f)`
07:30:29 <frogo> maxiepoo: yeah my bad for not putting things ontext...into context "Putting a space between two things is simply function application. The space is sort of like an operator and it has the highest precedence. " -LYAH
07:30:49 <skypers> bennofs: it enables me to pass a MonadIO function into an IO one?
07:30:50 * hackagebot scrz 0.0.0.1 - Process management and supervision daemon  http://hackage.haskell.org/package/scrz-0.0.0.1 (wereHamster)
07:30:54 <bennofs> skypers: For MaybeT, run will "unwrap" the MaybeT and return something like IO (Maybe a).
07:31:01 <bennofs> skypers: you need MonadBaseControl IO
07:31:14 <monoidal> frogo: in sin 5 + cos 2, the priority is (sin 5) + (cos 2) not sin (5 + cos 2) or similar
07:31:21 <skypers> bennofs: does it break my higher monad?
07:31:26 <bennofs> skypers: then, control will "rewrap" the IO (Maybe a) and put it back into MaybeT IO
07:31:36 <bennofs> skypers: what do you mean by "break"?
07:31:37 <maxiepoo> and what monoidal says works for any operator
07:32:04 <skypers> well, I have hidden parameters in my monad
07:32:19 <skypers> I need them to travel in the IO monad as well
07:32:26 <skypers> like State
07:32:30 <skypers> (or StateT IO)
07:33:25 <frogo> monoidal : eh should it be (((((sin) 5)+)cos)2)?
07:34:17 <monoidal> frogo: no. (sin 5) + (cos 2). if I use % to denote function application, it is (sin % 5) + (cos % 2)
07:35:02 <frogo> monoidal : ....please explain more
07:35:07 <monoidal> frogo: in more complex expression: "f a b + g x y z * h u > t" is parsed as "(f a b) + (g x y z) * (h u) > t"
07:35:43 <bennofs> skypers: I don't know, you'll have to try it out
07:36:08 <skypers> I think the type system forbids that
07:36:13 <skypers> and that‚Äôs quite logic
07:36:17 <skypers> if I run in IO
07:36:23 <skypers> I run in IO, not MonadIO
07:36:29 <frogo> monoidal : is it known apriori that f,g,h are functions?
07:36:34 <skypers> the monad I run the IO action from can‚Äôt be accessed
07:36:41 <frogo> monoidal: or does that not matter?\
07:36:45 <skypers> I then need to alter manually the monad
07:36:51 <maxiepoo> frogo, it doesn't matter for parsing
07:37:02 <maxiepoo> but it will matter for type checking :)
07:37:02 <monoidal> frogo: they must be functions in order for that to type-check
07:37:11 <bennofs> skypers: but note that control (\run -> withArray $ run . f) can be of type StateT IO ()
07:37:44 <bennofs> skypers: the state from the monad can be passed via the `run` function, which will feed the state to unwrap the StateT IO () returned from f
07:37:48 <maxiepoo> but operators can also mix in different ways, but function application is always tightest
07:38:05 <skypers> I need to inquire about that control then
07:38:30 <maxiepoo> "f a b . g x y z . h u $ t" is parsed as ((f a b) . (g x y z) . (h u)) $ t
07:38:40 <skypers> I don‚Äôt even know MonadBase
07:39:03 <henk> What is the point of doing 'flip id'? (context: 3rd line from the bottom of the code at http://hackage.haskell.org/package/base-4.6.0.1/docs/System-Console-GetOpt.html#g:4)
07:39:14 <monoidal> frogo: 2 + 3 * 4 is 2 + (3 * 4). 2 + sin 4 is 2 + (sin 4). meaning, you can imagine that between "sin" and "4" there's space which means "apply that function"
07:39:22 <skypers> ok
07:39:23 <skypers> it‚Äôs great
07:39:27 <skypers> liftBase
07:39:29 <bennofs> skypers: http://www.yesodweb.com/blog/2011/08/monad-control (Limitation: http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/)
07:40:52 <frogo> monoidal : what about the space between two parameters?
07:41:31 <monoidal> frogo: f a b is the same as (f a) b - meaning, f not only must be a function, but "f a" must also be a function
07:41:38 <monoidal> frogo: for example,
07:41:42 <monoidal> > elem 3 [1,2,3]
07:41:43 <lambdabot>  True
07:41:51 <FireFly> @ty elem 3
07:41:52 <lambdabot> (Eq a, Num a) => [a] -> Bool
07:41:56 <monoidal> > let hasTree = elem 3 in hasTree [1,2,3]
07:41:57 <lambdabot>  True
07:42:12 <monoidal> that should be hasThree of course
07:42:12 <FireFly> Three* :p
07:42:45 <randomclown> is there any difference between !Double and Double# ?
07:42:50 <FireFly> Maybe it's also worth mentioning that (+) could be used to "turn" an operator into an identifier, and `foo` the other direction
07:43:24 <FireFly> elem 3 [1,2,3]   is equivalent to  3 `elem` [1,2,3]   is equivalent to   (3 `elem`) [1,2,3]
07:43:39 <monoidal> frogo: in haskell, we don't really have multi-parameter functions; instead, we have a function that takes first parameter and returns a function that takes the second parameter etc
07:43:55 <frogo> monoidal : that makes sense
07:45:08 <monoidal> frogo: you can, but don't have to, supply all such parameters at once - above first I called "elem 3 [1,2,3]", but then just "elem 3" (and got a function in response)
07:46:04 <frogo> monidal I understand like in LYAH let a = max 10   ---- a 5 evaluates to 10 ..yep yep I get that
07:46:15 <monoidal> yes
07:46:50 <dhrosa> a function a->b->c associates as a -> (b->>c), a function that takes an a and returns a function from b to c
07:47:50 <frogo> monoidal : dude/dudette thanks
07:49:51 <monoidal> randomclown: in principle, !Double works the same as Double, but has a strict constructor
07:50:08 <monoidal> randomclown: however, you can write {-# UNPACK #-} !Double, and then it becomes Double#
07:50:43 <monoidal> randomclown: there's a flag that makes unpacking the default, and in 7.10 for small fields will be on by default
07:50:47 <monoidal> randomclown: *7.8
07:50:57 <skypers> @let import Control.Monad.Base
07:50:57 <lambdabot>  .L.hs:43:1:
07:50:58 <lambdabot>      Control.Monad.Base: Can't be safely imported!
07:50:58 <lambdabot>      The module itself isn't safe.
07:51:03 <skypers> seriously lambdabot
07:51:55 <randomclown> monoidal: as a matter of style, should I perfer unpack + ! vs #?
07:52:34 <ownclo> Good day! Is there somebody who is interested in invertible marshalling? It seems like I've managed to implement invertible _monadic_ marshalling, but I cannot tell whether I'm reinventing the wheel
07:52:50 <monoidal> randomclown: not sure, I use those things rarely. probably unpack + ! to avoid dealing with Double#
07:56:12 <the_berserker> @pl (>>= id)
07:56:12 <lambdabot> join
07:56:29 <the_berserker> @pl (>>= ($))
07:56:29 <lambdabot> join
07:56:37 <the_berserker> @pl ($)
07:56:37 <lambdabot> id
07:57:34 <dhrosa> wat
07:57:43 <dhrosa> > $ 2
07:57:44 <lambdabot>  <hint>:1:1: parse error on input `$'
07:58:10 <dhrosa> how are $ and id equal?
07:58:34 <monoidal> ($) f is f, in the same way id f is f
07:58:41 <dhrosa> ah
07:58:47 <monoidal> (there's a minor strictness issue that can be disregarded.)
07:59:01 <monoidal> ($) is type-restricted id
07:59:14 <dhrosa> :t id
07:59:15 <lambdabot> a -> a
07:59:22 <dhrosa> :t ($)
07:59:23 <lambdabot> (a -> b) -> a -> b
07:59:30 <dhrosa> I see
08:03:51 <sophie_> an someone help me figure out why my newtonian iteration  for n-th roots only ever computes the square root, never  the cube/quintic/etc root? http://bpaste.net/show/174528/  run it in ghci with -XNoImplicitPrelude and try  "Clifford.root 3.0 $ scalar 27.0" =[
08:08:37 <dom96> codehotter: #nimrod
08:09:17 <Redz> @hoogle (a -> Maybe a) -> a -> a
08:09:17 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
08:09:17 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
08:09:17 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
08:11:23 <spacekitteh> http://lpaste.net/99332 lpaste version of it :T
08:11:39 <madjestic> (Haskell, OpenGL) I am trying to make vertex colors work.  At the moment my color buffer is ovewriting the position buffer.  I must be initializing it wrong. Any clues how to fix that?: https://github.com/madjestic/Haskell-OpenGL-Tutorial/blob/master/tutorial04/NGL/Rendering.hs
08:13:56 <t7> madjestic: u have negative colours?
08:14:04 <t7> why
08:19:04 <identity> Redz: You want something that would basically do something like 0 -> Nothing and n > 0 -> Just n?
08:19:46 <Redz> i was just checking if something like this is already written:
08:19:46 <Redz> untilMaybe f x = maybe x (untilMaybe f) (f x)
08:19:52 <madjestic> t7: it should not matter, in regards to the issue.
08:20:42 <t7> couldnt see the issue, are the number of vertex colours and v positions the same? not sure that would matter either
08:20:56 * hackagebot himg 0.1.0.0 - Simple gtk2hs image viewer. Point it at an image and fire away.  http://hackage.haskell.org/package/himg-0.1.0.0 (MateuszKowalczyk)
08:20:58 <identity> Redz: yeah. Not quite the same, but I've run into a similar pattern(and some other guy in here as well, atl east) so many times. But it's not in the library
08:22:35 <madjestic> t7: yes, the example is set up so that the number of vertexes and colors match.  Then 2 buffers get initialized.  The 2nd buffer is somehow ovewriting the first.  I wonder why.
08:22:38 <Redz> what a shame. ^^
08:26:25 <t7> madjestic: i cant see the issue :O
08:26:34 <t7> buffers are bound correctly etc
08:27:00 <t7> might be your shader :P
08:28:08 <bergey> madjestic: Does it make a difference if you have the vertex buffer bound when setting the vertexAttribPointer for vPosition?
08:29:01 <Yaniel> yes it doees
08:29:15 <Yaniel> vertexAttribPointer points to the currently bound buffer
08:29:48 <madjestic> bergey: I am going to try it right now.
08:31:34 <Yaniel> I can imagine the statefulness of opengl causing quite a bit of confusion in haskell
08:31:58 <madjestic> Yaniel: or the lack of modern working examples :(
08:32:06 <t7> yeah i would do opengl bits in c :3
08:32:07 <bergey> It's not very pleasant, for sure.
08:32:42 <bergey> madjestic: I'm glad to see your set of examples.  I'm also working on some:  https://github.com/bergey/haskell-OpenGL-examples/tree/master/wikibook
08:36:25 <skypers> bennofs: ok, I read about liftBase
08:36:29 <madjestic> bergey: thanks.  It's a 'sombody got to do it' thing.  I would rather much prefer it done by somebody else already.
08:36:32 <skypers> I barely understand it
08:36:42 <skypers> it‚Äôs used to run a monad from its base
08:36:43 <skypers> like hm
08:37:01 <skypers> running StateT s IO in IO
08:37:23 <skypers> this is not really what I want, because it would break the state I guess
08:38:16 <skypers> I want to be able to 1. pause a monad ; 2. resume by lifting it into another one ; 3. unpause the first monad by passing the lifted one back
08:38:39 <monochrom> lifting does not pause
08:38:42 <identity> doesn't gloss use opengl?
08:38:53 <monochrom> err, I misread
08:39:09 <skypers> like StateT s IO, then IO, then StateS s IO with s passed from the higher StateT, then StateT again, altered from the nested IO
08:39:15 <skypers> I have a sample, wait
08:39:45 <bergey> madjestic: Ditto.  I'll take a look at your repo; maybe it's worth merging some of them, or at least linking to eachother.  I do like acowley's libraries, but it's good to have examples without, too.
08:39:59 <madjestic> bergey: hey, I am familiar with your code.  You use GLRAW and it shows your knowledge of OGL, which, in my case, I lack.  However I find your style hard to follow.  I mean it with respect.
08:40:12 <gspr> Does one need pipes-safe to do cleanups etc if a pipe terminates, or am I just confused? Say I have p :: Producer a IO () and that I need to run a certain cleanup :: IO () when the pipe p that feeds terminates. How do I do that?
08:41:00 <madjestic> identity: yes it does.
08:41:17 <skypers> http://lpaste.net/99336
08:41:20 <skypers> that ^
08:42:32 <skypers> do you get it?
08:43:05 <sebastian_> skypers: do you know Control.Monad.Trans.Control ?
08:43:21 <skypers> bennofs talked me about that
08:43:34 <skypers> but I haven‚Äôt digged in it yet
08:44:15 <madjestic> bergey: on the second thought... I must be confused.  https://github.com/bergey/haskell-OpenGL-examples/blob/master/wikibook/tutorial-03-attributes/Interleaved.hs  It looks clean and very much in line of what I consider good style.  Please forgive my mistake.
08:45:17 <dwcook> Are there any proposals to get parameterized modules into the language?
08:45:19 <bergey> madjestic: I've been learning OpenGL for the first time over this past year.  It's slowly starting to make sense.  I'd like to hear which parts of my code are hard to follow, so I can make it better.
08:45:45 <AshyIsMe> well making a simple vindinium bot has been fun
08:45:49 <sebastian_> skypers: https://www.fpcomplete.com/user/jwiegley/monad-control
08:46:00 <AshyIsMe> i feel a bit more comfortable with haskell now
08:46:50 <skypers> sebastian_: may you explain me MonadBase first?
08:47:32 <madjestic> bergey: I am glad to see that you can take criticism well.  Looking through your examples now.
08:49:04 <skypers> oh
08:49:11 <skypers> control is exactly what I‚Äôm looking for then!
08:49:14 <skypers> thank you guys!
08:49:21 <sebastian_> skypers: sorry. I'm not familiar with them. I just had an unsolvable requirement for MonadBaseControl and found that article
09:06:31 <Vicfred> hi, can someone explain me this code? http://lpaste.net/99339 it does the pattern matching but I dont understand the "p 1" part in the first line, it shouldn't have 2 arguments and not only the "1"?
09:07:20 <Vicfred> oh i think i got it, it fixed the function p(x,y) with x=1 right?
09:07:41 <davean> yes
09:07:50 <geekosaur> yes, that's partial application
09:09:34 <carter> bergey: i last learned opengl a decade ago, happily its now a completely different thing i gather
09:12:07 <bergey> carter: That's what I hear.  Sadly, most of the tutorials describe the old version.
09:12:14 <carter> hrmm
09:16:00 <skypers> woh I don‚Äôt know the keyword family
09:16:00 <chosoone> woh I don‚Äôt know the keyword family
09:16:08 <skypers> uh.
09:16:09 <chosoone> uh.
09:16:19 <skypers> may someone kick this idiot?
09:16:19 <chosoone> may someone kick this idiot?
09:16:32 <hpc> @ops
09:16:32 <lambdabot> Maybe you meant: pl oeis docs
09:16:32 <chosoone> @ops
09:16:32 <lambdabot> Maybe you meant: pl oeis docs
09:16:32 <chosoone> Maybe you meant: pl oeis docs
09:16:33 <chosoone> Maybe you meant: pl oeis docs
09:16:37 <Fuuzetsu> @mods
09:16:37 <lambdabot> Maybe you meant: todo more docs
09:16:41 <Fuuzetsu> guess not!
09:16:42 <hpc> jeez
09:17:00 <haasn> it's @where ops
09:17:07 <Fuuzetsu> of course it is
09:17:09 --- mode: ChanServ set +o Saizan
09:17:22 <Yaniel> good ol' idoru
09:17:34 <Saizan> oh, late
09:17:39 <int-e> thanks idoru
09:17:43 --- mode: Saizan set -o Saizan
09:22:50 <carter> skypers: keywords are annoying like that sometimes :)
09:23:52 <hpc> my favorite keyword is java's goto
09:24:01 <hpc> it exists solely to prevent you using it as an identifier
09:24:36 <carter> i was so confused that in can't be used as a type variable that i opened a ghc ticket
09:24:47 <carter> "spj: nope, keyword"
09:24:52 <carter> me "ohhhhhh"
09:24:56 <carter> "fine"
09:25:15 <hpc> does haskell 2010 specify you can't have level-specific keywords?
09:25:20 <carter> level?
09:25:24 <carter> i have no idea
09:25:29 <hpc> like, would it be still valid haskell for you to be able to put "in" in a type
09:25:30 <carter> level as in type vs term level?
09:25:31 <c_wraith> hpc: not entirely..  they have always reserved the right to implement goto in a future version of java
09:25:43 <hpc> carter: yes
09:25:50 <carter> hpc: wellll, if we ever get dependen types, that would be aproblem
09:25:53 <carter> g2g for a bit
09:26:04 <hpc> that it would
09:33:27 <enthropy> > let qualified = "hpc" in qualified
09:33:28 <lambdabot>  "hpc"
09:33:57 <hpc> TIL i am qualified
09:34:15 <enthropy> there's lots of that "using keywords as variables in situations where they aren't keywords" in fortran
09:34:23 <enthropy> I think people avoid that
09:34:43 <enthropy> just like you never see people using qualified as a variable in haskell
09:34:58 <c_wraith> hpc: no one said *what* you were qualified for, though
09:36:34 <quchen> c_wraith: hpc is universally qualified (as String)
09:42:13 <klrr_> edwardk: sry to highlight you but i think you are the best pesron to ask; i try to understand how to use the Wye api, and the only doc/example i found was this https://github.com/alanz/machines-play/blob/master/Main.hs#L204 which is written with 0.3, im using 2.* as you recommended some day(s) ago. could you please point me to an explaination or give a hint on how these work? (ive tried to google ;))
09:44:13 <edwardk> to write a plan that expects 2 inputs and wants to be able to block non-deterministically between them you set it up so its input type is `Y firstChannel secondChannel`.
09:45:05 <edwardk> when wrting the plan to block on either input you await X or await Y, if you only use those options you remain dterministic
09:45:12 <klrr_> non-deterministically is that it doesnt expect a certain order?
09:45:37 <edwardk> on the other hand you can choose to await Z in which case you'll take input from X _or_ Y and it'll just give you the Either to indicate which you got
09:45:38 <edwardk> yes
09:45:46 <c_wraith> it just combines the two streams into one
09:46:04 <klrr_> thanks! that explains it
09:46:13 <edwardk> c_wraith: well, it gives you the option, as you can still block on either stream deterministically
09:46:30 <c_wraith> ah, hence your specific wording.  ok.
09:46:41 <c_wraith> what's the current state of machines, anyway?
09:47:12 <c_wraith> edwardk: Last I heard, you still considered it somewhat experimental.  Has that changed?
09:47:14 <edwardk> a common usecase is to deal with accepting say buffering, by taking sources and sinks, and accepting both unless you've run out of one or the other and maintaining a fixed sized window
09:47:31 <edwardk> it is still experimental, i still advocate conduits and pipes over it for most usecass
09:48:13 <edwardk> I personally pick it up and revisit it when i have a programming problem in this space trying to jump the ball into a better state, but it isn't getting a lot of love right now ;)
09:49:56 <klrr_> edwardk: would it make sense to create a tutorial for it? (i am willing to if so, when ive gotten comfortable with it;) )
09:50:17 <edwardk> klrr_: i wouldn't given the large changes likely to happen to it, but YMMV ;)
09:51:36 <klrr_> excuse my english, but im not sure if i can intepret that
09:52:10 <edwardk>  'i wouldn't bother' 'i'm going to make very big changes to it eventually' ;)
09:52:16 <klrr_> aa okey
09:52:38 <klrr_> then i need to find another library with undocumented api :p
09:53:09 <c_wraith> GHC api.  that totally needs docs
09:53:11 <alanz> Looks like I will have to update my machines example
09:54:03 <edwardk> the main thing machines offers is Wye. if you don't need that it is just a crippled pipes/conduit clone that doesn't leak time in a case they do by not allowing you to write that case ;)
09:54:07 <klrr_> alanz: they're not out of date, i just use 2.*
09:54:32 <edwardk> alanz: machines 0.3 basically turned out to be a dud. i wanted the simplification, but it didn't come together
09:55:17 <klrr_> machine got simpler types too
09:55:35 <klrr_> at least compared to pipes, never touched conduit
09:55:53 <alanz> ok, so the hackage version is 0.2.3.1, I should either update to use that or state that it is no longer relevant
09:56:10 <edwardk> well the 0.3 type is simpler still, it just turned out to be too simple to write many useful programs
09:56:19 <edwardk> hence why machines stalled
09:56:40 <alanz> So it might make sense to update my repo to say that
09:57:49 <alanz> because there have been a number of references to it here recently
09:58:23 <c_wraith> most of them have been to Mealy, that I've seen
09:58:53 <klrr_> i might write a little small tutorial just for the sake of having sth on my blog ;)
09:59:08 <heatsink> What's the difference between a parameterized thing and an indexed family of things?
09:59:08 <c_wraith> Which is really handy to have in a library containing instances for it, independent of everything else machines does
10:00:57 <hpc> heatsink: a very rough and don't-trust-this-in-the-slightest explanation would be that in an indexed family you can "pattern match" on the type, of sorts
10:01:26 <hpc> unless i am totally misunderstanding the question
10:02:41 <monochrom> yes
10:02:59 <heatsink> Both terminologies describe function-like objects, which specify another object when given a parameter or index
10:03:04 <heatsink> But they're not used interchangeably
10:03:15 <heatsink> so I guess there's a difference
10:03:48 <jedai> heatsink: A "parameterized" thing (function, type constructor) can accept any type and behave similarly for every type
10:04:27 <heatsink> So it's that it behaves in a uniform way over all parameters
10:04:36 <jedai> heatsink: An indexed family only accept the type for which the image is specified and can have very different image for different types
10:04:36 <heatsink> instead of being defined by case analysis
10:04:42 <jedai> Right
10:04:44 <jedai> :)
10:05:03 <heatsink> ok
10:05:13 <heatsink> thanks hpc, jedai
10:06:22 <tommd> dmwit: how goes the phd?
10:07:38 <companion_cube> never ask this question :p
10:15:53 <dhrosa> hah, I'm looking at the haskell irc channel stats
10:16:15 <dhrosa> Cale is the most active nick, 6889 lines, about 100 more lines than lambdabot
10:17:19 <klrr_> what would be the appropriate type of `a' here: "foo :: PlanT (Is (Y Int String a)) (Maybe Int) IO ()"?
10:17:47 <hpc> about what i expected
10:17:56 <hpc> didn't think lambdabot would be so close though
10:20:49 <dhrosa> carter: to answer your question like 24 hours later, electrical engineering and computer science
10:20:58 <carter> dhrosa: so course 6
10:21:01 <dhrosa> yes
10:21:01 <carter> whats yer focus?
10:21:07 <dhrosa> 6-2, I do both
10:21:22 <carter> hopefully sleep and friends and hobbies to
10:21:25 <carter> on rotation
10:21:50 <dhrosa> i'm probably going into embedded systems
10:22:01 <carter> oo cool
10:22:07 <carter> i never had the chance to dig into that in undergrad
10:22:16 <carter> and i'm starting to learn taht stuff now
10:22:27 <carter> in my very very very finite freetime
10:22:34 <carter> g2g, bbiab
10:22:46 <carter> dhrosa: if you like hasklel + using it for mathy things, lurk on #numerical-haskell
10:22:49 <carter> :)
10:22:56 <dhrosa> I just took a caffeinated 6.828 course (operating systems), frmo there I've learned lots of hilarious things, like the fact that on windows font rendering is done in kernal space
10:22:59 <dhrosa> kernel*
10:23:03 <carter> hehe
10:23:25 <carter> dhrosa: i bet you its because thats an easier way to support all their compatibility hacks
10:23:50 <carter> dhrosa: like, A LOT of windows engineering is from the perspective of "how do we support that random buggy program working correctly now that we've fixed teh windows bug it dependend upon"
10:24:07 <dhrosa> it's because the rest of the display stack is in kernel space for effiency reasons, so they just put everything graphics-related thing in kernel space to minimize context switches
10:24:08 <jmcarthur> I seem to recall that at some point in time there was a program that would help you find just the right combination of strictness annotations to best optimize your program. I definitely recall something similar for finding compilation flags, but I'm more interested in the strictness annotations in this case. Does anybody know whether I'm just making this up in my head?
10:24:31 <carter> dhrosa: are you sure its just that reason? :)
10:24:42 <carter> did the course touch on any of the compat hacks windows has/
10:24:52 <c_wraith> jmcarthur: if it happened, it either predated me, or I missed it.  (It's not that hard for haskell software to have predated me)
10:25:14 <klrr_> one last machines Wye question: what would be the appropriate type of `a' here: "foo :: PlanT (Is (Y Int String a)) (Maybe Int) IO ()"?
10:25:29 <alpounet> jmcarthur: I remember Don playing with genetic algorithms to find the best parameters for maximum efficiency, but not anything else‚Ä¶?
10:25:47 <dhrosa> carter: it was a one-month version of a course normally offered during the semester, they didn't touch too much on that unfortunately
10:26:30 <jmcarthur> alpounet: yeah, that was the optimizations flags bit i referred to
10:26:32 <alpounet> jmcarthur: related is the strict ghc plugin by (IIRC) Austin
10:26:40 <carter> alpounet: nope, tibbe
10:26:41 <carter> i think
10:26:42 <alpounet> but i haven't heard about a mix of both
10:26:49 <alpounet> carter: no, i mean an older thing
10:27:02 <alpounet> carter: http://hackage.haskell.org/package/strict-ghc-plugin
10:28:40 <jmcarthur> i definitely don't want to strict all the things here
10:30:47 <klrr_> edwardk: a little qusetion, since you can use Wye for determistic purposes, why have Tee too?
10:32:32 <c_wraith> klrr_: Tee goes the other direction.  It allows multiple consumers to read the *same* things from a producer
10:33:37 <c_wraith> klrr_: that is, if a something produces a stream of all integers, and you want multiple consumers to read from it, and you want them all to get *all* the integers, you use Tee
10:33:48 <c_wraith> klrr_: without Tee, they would each get a non-overlapping subset
10:35:27 <klrr_> okey, kinda get it
10:36:43 <unsung_anarchist> >
10:37:58 <klrr_> another question, why is the monad m parameter placed on different location on the different types? e.g. "PlanT k o m a" "Wye m a b c"
10:38:50 <hpc> klrr_: putting it second to last is the usual thing to do with transformers because it curries better and is what MonadTrans expects
10:38:54 <hpc> not sure what Wye is
10:39:19 <zett_zelett> With list comprehensions, how can I achieve something like [ (x,y) | x <- [1..3]] without writing [1..3] twice?
10:39:23 <c_wraith> yeah, making it second-to-last is what you have to do to make something MonadTrans
10:39:25 <klrr_> WyeT*
10:39:56 <c_wraith> I would guess that in the case of WyeT it's not second-to-last to indicate it has no sensible way to be an instance of MonadTrans
10:39:56 <hpc> let m = [1..3] in (,) <$> m <*> m
10:40:03 <hpc> > let m = [1..3] in (,) <$> m <*> m -- er
10:40:04 <geekosaur> zett_zelett: clarify please?
10:40:04 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:40:33 <zett_zelett> I meany [ (x,y) | x, y <- [1..3]] and what hpc achieved.
10:40:35 <zett_zelett> meant*
10:40:46 <zett_zelett> Yeah, there was the 'y' suddenly.
10:40:46 <c_wraith> zett_zelett: you can use a let inside a comprehension
10:41:03 <zett_zelett> c_wraith: So how would you have written it?
10:41:10 <c_wraith> > [(x, y) | let l = [1..3], x <- l, y <- l]
10:41:11 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:41:19 <zett_zelett> Okay, the thing is.
10:41:25 <zett_zelett> In the exam today, I needed 9 variables.
10:41:46 <hpc> as in, a 9-tuple?
10:41:52 <zett_zelett> So I wrote [ f a b c d | a, b, c, d, e, f, g, h <- [1..3] ]
10:41:59 <zett_zelett> Or something like that.
10:42:06 <hpc> or do you need [[Int]]?
10:42:08 <zett_zelett> So that won‚Äôt work as I just discovered.
10:42:08 <c_wraith> That probably shouldn't be a list comprehension
10:42:22 <zett_zelett> How would you have done that?
10:42:44 <zett_zelett> also, f is not taken from <- [1..3] in this example, obviously.
10:42:46 <quchen> :t \f -> map f (replicateM 10 [1..3])
10:42:46 <lambdabot> (Enum a, Num a) => ([a] -> b) -> [b]
10:43:43 <zett_zelett> quchen: What would that achieve?
10:44:07 <zett_zelett> quchen: I mean, I see what it does, but how could I have used it?
10:44:55 <quchen> > replicateM 2 [1,2,3] -- These are all combinations of [1,2,3] of length 2. Map f over it and you have what your list comprehension did.
10:44:56 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
10:45:53 <quchen> So if you define f (a:b:c:d:_) = something, then  `\f -> map f (replicateM 10 [1..3])` is precisely your list comprehension from above.
10:46:45 <zett_zelett> I need to digest that, but many thanks!
10:47:32 <quchen> Just remember that `replicateM n = sequence . replicate n`. The mapping part is pretty easy to understand once you have a feeling for what replicateM does for List.
10:48:18 <quchen> And if you don't understand `sequence`, https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
10:48:36 <Scorchin> Are there any good examples of people open sourcing web apps (micro services) and putting them on GitHub? I think I know just enough Haskell to be dangerous, but I'm not sure how it would apply to web development.
10:49:14 <quchen> Scorchin: The pretty #haskell logs are Haskell-based: http://ircbrowse.net/
10:49:38 <quchen> Tryhaskell is Haskell as well
10:49:46 <quchen> And probably everything else Chrisdone has created
10:50:19 <copumpkin> either haskell or elisp
10:51:16 <spacekitteh> can someone help me figure out why my newtonian iteration for n-th roots only ever computes the square root, never  the cube/quintic/etc root? http://lpaste.net/99332 run it in ghci with -XNoImplicitPrelude and try  "Clifford.root 3.0 $ scalar 27.0"
10:51:28 <spacekitteh> (root the very bottom)
10:51:39 <spacekitteh> root is right at the very bottom*
11:00:56 <zett_zelett> Cale is more active than lambdabot.
11:01:49 <fragamus> I am having some strand difficulty constructing a V4
11:02:29 <fragamus> I have a V3 in hand and I want to append a constant as the fourth element of a V4
11:02:43 <ion> Calebot
11:02:52 <fragamus> I used lens to get the x y z components
11:03:16 <quchen> Cale runs Lambdabot even I think
11:03:19 <Platz> "append (V3 a b c) d = V4 a b c d " didn't work ?
11:03:19 <quchen> So technically ‚Ä¶ :-)
11:03:25 <fragamus> V4 raycos^._x raycos^._y raycos^._z 0.0)
11:03:49 <quchen> "Doesn't work" is not an error description
11:03:51 <fragamus> I get strange complaints from the compiler
11:04:55 <dhrosa> fragamus: what specifically?
11:05:07 <fragamus> momento...
11:06:14 <fragamus> let a = V3 1 2 3
11:06:24 <fragamus> let b = V4 a^._x a^._y a^._z 1
11:06:43 <fragamus> Couldn't match expected type `Accessor
11:06:44 <fragamus>                                     s0 (V3 Integer -> V3 Integer -> V3 Integer -> V4 (V3 Integer))'
11:06:44 <fragamus>                 with actual type `s0 -> Accessor s0 s0'
11:06:47 <ion> fragamus: That parses as ((V4 raycos) ^. (_x raycos) ^. (_y raycos) ^. (_z 0)) . 0
11:06:50 <bennofs> fragamus: you need to write V4 (a^._x) (a^._y) (a^._x) 0.0
11:06:57 <bennofs> fragamus: note the parentheses
11:07:09 <ion> Actually, scratch the last part.
11:07:25 <ion> (V4 raycos) ^. (_x raycos) ^. (_y raycos) ^. (_z 0.0)
11:07:43 <fragamus> mkay
11:08:14 <fragamus> thanks dudes
11:08:26 <ion> Also see what Platz said.
11:11:15 <zett_zelett> Wait, how do you use let in list comprehensions?
11:11:57 <geekosaur> [01 18:38] <c_wraith> > [(x, y) | let l = [1..3], x <- l, y <- l]
11:12:27 <dhrosa> like that!
11:13:29 <zett_zelett> Okay.
11:19:05 <zett_zelett> We had to solve (send + more == money) where each letter stands for a different decimal digit and there are no leading zeros. I correctly implemented a function solvesRiddle which checks if a given list of integer solves the equation, and then I tried out every combination in a list comprehension.
11:19:09 <zett_zelett> But it‚Äôs sooooooooooo slow.
11:19:27 <zett_zelett> I‚Äôm interested whether there is a fast way of solving the problem.
11:20:28 <simpson> zett_zelett: Constraint propagation is usually pretty fast on these. How'd you do it?
11:21:44 <zett_zelett> let solvesRiddle :: [Int] -> Bool; solvesRiddle [s,e,n,d,m,o,r,y] = (send + more) == money where send = dec [s,e,n,d]; more = dec [m,o,r,e]; money = dec [m,o,n,e,y]; dec = fst . foldr f (0,0); f a (x,k) = (x+a*10^k,k+1);
11:21:49 <zett_zelett> Wait, I‚Äôll paste this.
11:22:27 <alpounet> zett_zelett: maybe use the z3 binding
11:22:43 <simpson> No, this can be done without anything fancy.
11:22:55 <zett_zelett> z3-binding?
11:24:06 <simpson> http://stackoverflow.com/a/15867565/264985
11:24:10 <simpson> Nothing fancy here.
11:24:33 <simpson> Since you're still starting out, you could write this without StateT and just using lists.
11:24:53 <monochrom> monad on list? if you can write list comprehension, I know how to convert to do-notation
11:25:03 <simpson> Yeah.
11:25:07 <zett_zelett> http://lpaste.net/99341
11:26:38 <simpson> Yeah, you'll want some guards in there to cut down on the search space.
11:26:57 <zett_zelett> How do you mean?
11:27:02 <simpson> For example, you want (d + e) % 10 == y, right?
11:27:33 <simpson> So you want to pick a possible d, e, y, and then check that condition. And if it fails, then you know that the rest of the solution *must* be bad.
11:27:47 <simpson> So you'd want to move on to the next one as soon as possible.
11:27:49 <zett_zelett> Yeah, but we weren‚Äôt allowed to use preliminary considerations.
11:28:04 <simpson> Really? Why not?
11:28:21 <kristof> What's everyone talking about?
11:28:44 <zett_zelett> I dunno, probably because you could just solve it yourself, if you‚Äôre clever and then write: solution = [9,5,3‚Ä¶]
11:29:05 <simpson> zett_zelett: Oh. No, I'm talking about dynamic constraints, not pre-solving.
11:29:06 <zett_zelett> But, still, how would I go about doing that?
11:29:21 <kristof> oh, logic programming...
11:30:02 <zett_zelett> Still, this was disallowed. But nevermind, I‚Äôm interested nonetheless.
11:30:14 <zett_zelett> Can you write down a comprehension which would work a bit faster?
11:30:40 <joelteon> Is there a built-in conditional for .cabal files regarding whether tests are enabled or not?
11:30:46 <simpson> zett_zelett: http://lpaste.net/99341
11:30:58 <simpson> Here's an example of the constraints I'm talking about.
11:31:20 <skypers> joelteon: yes
11:31:29 <zett_zelett> Okay, so I take it the order of conditions matters a lot?
11:31:34 <simpson> The SO link above gets even more precise; it uses State to track which digits have been used, and so it narrows down the possibilities very quickly.
11:31:40 <simpson> Yes; order in a list comprehension matters.
11:32:19 <joelteon> skypers: what is it?
11:32:20 <skypers> joelteon: if arch(x86) ‚Ä¶ else _
11:32:32 <joelteon> how is that tests related?
11:32:58 <simpson> > [ (x, y, z) | x <- [1..5], y <- [x..5], z <- [y..5] ]
11:32:59 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,2,2),(1,2,3),(1,2,4),(1,2,5),(1,...
11:33:08 <skypers> well it was an example, you might have to dig in the documentation and look for the tests flag I guess
11:33:28 <zett_zelett> Okay, thanks, simpson. It still takes a while. I haven‚Äôt calculated the solution with what I wrote.
11:33:35 <joelteon> yeah, that's why I'm asking, I can't find the bit in the documentation where predefined flags are
11:34:00 <zett_zelett> My cpu gets too hot and then I chicken out and cancel.
11:34:03 <bennofs> joelteon: I think there isn't. You can only do it the other way, only enabling tests when a flag is set
11:34:05 <mjrosenb> sort uses mergesort, yes?
11:34:30 <skypers> joelteon: have you tried to look in Base?
11:34:44 <skypers> the arch flag uses the System.Info.arch function
11:34:50 <exicer> I'm messing around with the persistent library, and many of the functions return (generated) keys. However I can't seem to work out how to query using those returned keys.
11:34:55 <bennofs> joelteon: you can probably also do this with a custom Setup.hs
11:34:55 <skypers> maybe there‚Äôs something about compilation info
11:35:06 <simpson> zett_zelett: Consider: How does your program guard against solutions like 9000 + 1000 = 10000 ?
11:35:45 <simpson> zett_zelett: It checks that condition at the very end!
11:36:07 <simpson> zett_zelett: So you're generating a *massive* number of possibilities and checking each of them. Very expensive.
11:36:22 <simpson> > 10^8
11:36:23 <lambdabot>  100000000
11:36:46 <zett_zelett> I should probably do [9..1] then.
11:36:59 <simpson> But if you were crossing numbers off of the list as you traversed, then your possibility range would be much better.
11:37:07 <simpson> > product [2..9]
11:37:09 <lambdabot>  362880
11:37:21 <kristof> zett_zelett: Did you mean [9,8..1]?
11:37:29 <bennofs> > [9..1] -- zett_zelett
11:37:30 <lambdabot>  []
11:37:31 <kristof> Or maybe my Haskell is rusty and I forgot how list generating works
11:37:31 <zett_zelett> Yes.
11:38:15 <kristof> > take 2 [9..1]
11:38:16 <lambdabot>  []
11:38:50 <monochrom> > [9, 8 .. 1]
11:38:52 <lambdabot>  [9,8,7,6,5,4,3,2,1]
11:38:53 <mzarella> https://en.wikipedia.org/wiki/Concurrent_computing I'm not sure why Haskell isn't on this list
11:39:12 <monochrom> I know why, it's because I'm too lazy to add it there
11:39:53 <kristof> lazy, haskell, I get it
11:40:05 <monochrom> zett_zelett: you may like to see my http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html . it has source code, find the link.
11:40:08 * joelteon `seq`s monochrom
11:40:30 <monochrom> please deposit one bitcoin
11:40:36 <bennofs> Maybe because it's not so much "language constructs" but more "library constructs" that make haskell a parallel programming language?
11:40:43 <monochrom> my "too lazy" means I am not paid enough
11:40:58 <zett_zelett> Okay, thanks, monochrom
11:41:39 <kristof> I wonder if someone has translated Sussman's "The Art of the Propagator" into Haskell yet
11:42:08 <nisstyre> kristof: I don't think it would be as easy as you think
11:42:19 <nisstyre> but it is CC licensed and you can remix it
11:42:33 <kristof> nisstyre: Strict vs. lazy semantics?
11:42:47 <kristof> nisstyre: Oh, right, because propagation is pretty strict
11:43:05 <nisstyre> kristof: well you would have to rewrite all of the "this is how evaluation works!" stuff yeah
11:43:25 <kristof> Haskell supports explicitly strict evaluation, though
11:44:05 <kristof> That might be a good weekend project :P
11:44:13 <nisstyre> kristof: it would take way more than a weekend
11:44:18 <nisstyre> at least to do a good job
11:44:22 <kristof> was being slightly facetious, haha
11:44:42 <nisstyre> also there's stuff that would just make no sense
11:44:54 <kristof> also, I can't recall if his code uses mutable cells or not
11:44:55 <nisstyre> like the part where it introduces delay and force
11:45:08 <nisstyre> kristof: I don't think it uses set-car! or set-cdr!
11:45:14 <nisstyre> maybe in the implementation parts
11:45:19 <kristof> nisstyre: hmm
11:45:23 <Datsundere> anyone logging this channel? link pls
11:45:35 <ion> topic
11:45:39 <simpson> Datsundere: /topic
11:45:45 <Datsundere> ty
11:45:55 <levi> I had not heard of "The Art of the Propagator" before. Thanks!
11:45:59 <kristof> levi: welcome
11:46:12 <kristof> Papers written in Scheme are not read anymore :'(
11:46:45 <nisstyre> kristof: that's not true at all
11:47:16 <nisstyre> but people in the "typed functional programming" community don't seem to look at the "schemers" community that much
11:47:32 <nisstyre> I know there is some crosstalk
11:47:38 <kristof> maybe that's what I meant
11:47:39 <levi> The schemers are a bit less active on IRC these days.
11:47:51 <nisstyre> levi: #racket
11:48:19 <levi> Ahh, is that the secret? I didn't know there was a #racket.
11:48:20 <johannesbodannes> i've been told that scheme isn't as pure as most functional languages
11:48:20 <nisstyre> but yeah, obviously way fewer people in there
11:48:24 <Datsundere> everyone joined the #racket bandwagon
11:48:37 <Datsundere> no secret
11:48:40 <nisstyre> johannesbodannes: it's about as pure as OCaml or SML
11:48:42 <simpson> johannesbodannes: What does that mean?
11:49:02 <levi> And the "industry" people have jumped on Clojure.
11:49:17 <johannesbodannes> meaning that it uses a lot of mutable state i'm guessing!
11:49:21 <ReinH> levi: clojure is a pretty nice way to not write Java on the JVM
11:49:21 <kristof> Clojure has hype going for it
11:49:30 <kristof> and it's not undeserved (entirely)
11:49:33 <Datsundere> ReinH++
11:49:58 <kristof> The community's really vibrant and a lot of exciting stuff happens there
11:50:04 <levi> I certainly don't mean to disparage it.
11:50:24 <simpson> johannesbodannes: What if I told you that Haskell has mutable state? >:3
11:50:38 <levi> It was the impetus behind the formation of a local functional programming meetup.
11:50:41 <kristof> ST
11:51:12 <johannesbodannes> mutable state, or the illusion thereof? we aren't talking about syntactic candy in monads, are we? <_<
11:51:24 <levi> Some local Racket researchers came to the last meeting to give presentations on Racket, too.
11:51:26 <simpson> Well, I was talking about ST, STM, and IO. I don't know what you were thinking of.
11:51:48 <kristof> levi: The only really popular "pure" functional programming language I can think of is Haskell. The other very popular functional languages are probably Clojure, F#, Scala, Ocaml, and then there's Common Lisp and Scheme
11:52:20 <kristof> levi: I think I meant that for johannesbodannes
11:52:24 <levi> Yeah, I'm pretty familiar with what's out there. Just not the relative activity of IRC channels. :)
11:56:54 <levi> I have only read through the beginning of the Propagator paper, but I wonder already how it relates to "The Essence of Dataflow Programming". I guess I will find out...
11:58:04 <kristof> levi: zomg, I have that open in another tab (because comonads are cool)!!!
11:59:18 <levi> Yeah, I also have been pondering constraints lately due to my at-work projects.
11:59:28 <zomg> I'm cooler than comonads though
11:59:38 <kristof> levi: The difference between propagators and "dataflow programming", I think, is that dataflow programming will lend itself quite nicely to lazy computation in a way that propagators won't
11:59:56 <edwardk> EoDFP uses comonads to represent the semantics of dataflow programs, propagators can be constructed as operad algebras for the operad for synchronous dataflow. rather different approaches to model the same kind of thing
11:59:58 <kristof> zomg: Hahahahah, sorry for the accidental pin but your nick is unfortunate
11:59:59 <prophile> zomg: is that the dual of being oler?
12:00:08 <kristof> *ping
12:00:21 <zomg> kristof: np, I just take them as opportunities to come up with dumb comments
12:00:22 <zomg> lol
12:00:29 <kristof> :)
12:00:38 <levi> edwardk: Thanks for the insightful answer out of the blue. :)
12:00:47 <edwardk> the nice thing about the propagator approach is you can accept a little non-determinism into your heart and just run them to completion asynchronously if you ave some lattice-like properties for your propagators
12:01:19 <kristof> Sounds beautiful
12:01:21 <levi> I have not entirely figured out what an "operad algebra" is yet, though at least I've got something of a grasp on what algebras in general are.
12:01:21 <edwardk> levi: i spent a lot of time talk to alexey radul about propagators ;)
12:01:38 <kristof> The nondeterminism is one of the things I liked most about the propagators paper
12:02:25 <kristof> Ah, this conversation reminds me that I preordered that Dataflow Programming book which should be coming out in... April?
12:02:30 <kristof> I dunno if I should have done that XD
12:02:46 <levi> Too many interesting things to learn.
12:02:53 <kristof> ^^^^^
12:02:57 <kristof> levi: get reading
12:03:10 <kristof> if you find yourself not reading, start reading again
12:03:18 <kristof> you can stop reading when you're dead.
12:03:21 <prophile> kristof: the kickstarted one?
12:04:01 <edwardk> levi: basically you can make an operad out of directed wire diagrams. its kinda boring though, as it is just an Arrow in disguise, then you can construct an algebra of propagators over it.
12:04:04 <kristof> prophile: That one
12:04:10 <levi> My iPad is filled with PDFs of books and papers. Reading is not the problem; understanding, finishing things, and retaining information is.
12:04:54 <kristof> levi: This is probably preaching to the choir, but: Read until you don't understand. When you don't understand, ask until you do. Then start reading again. Repeat!
12:05:05 <kristof> Oh, an iPad? Are you satisfied with that product?
12:05:27 <kristof> I was hesitant on liking any tablet until I tried one myself
12:05:31 <edwardk> kristof: my usual approach is to read until i don't have context for something, then go chase down source references until i'm in a completely different field of study ;)
12:05:57 <Qett> does anybody know where i can find some good indentation settings for haskell for vim?
12:06:00 <kristof> edwardk: Have you found a good way to get the yak hair out of your shirt?
12:06:06 <edwardk> as i tend to only have a finite stack depth i learn a lot, just rarely what i set out to learn
12:06:20 <levi> kristof: It was the first one to have a hi-res display of sufficient size to render PDFs quickly and beautifully. I am very satisfied, although I now wish I'd got one with more storage.
12:06:22 <kristof> I suffer from the same problem :P
12:06:53 <edwardk> kristof: no, i just learned to like the feel of yak hair, it's like cashmere.
12:07:34 <levi> I am trying to discipline myself to take notes and work more things out rather than just reading straight through.
12:07:36 <ownclo> Qett: does vim-haskell satisfy your needs?
12:08:04 <levi> And to go back to fundamental things that I didn't learn well enough before.
12:08:15 <ownclo> Qett: https://github.com/zenzike/vim-haskell
12:08:50 <Platz> ownclo: bitc/vim-hdevtools isn't half bad either
12:09:41 <klrr_> is there any function that removes each a element in a list? something like "a -> [a] -> [a]"
12:10:22 <ownclo> Platz: vim-hdevtools is a great thing indeed! But I use it for type highlighting. I didn't know that vim-hdevtools provides syntax highlighting as well.
12:10:38 <levi> klrr_: You can type that signature right into Hoogle and get a list of functions that match it.
12:10:42 <c_wraith> has anyone used free-operational? I can't get it to do anything other than an infinite loop
12:11:01 <klrr_> levi: i know
12:11:08 <Platz> ownclo: You're right, I don't think it does syntax highlighting
12:11:08 <klrr_> still cant see any which do what i want :s
12:11:45 <byorgey> klrr_: filter (/= a)
12:12:04 <byorgey> @type filter . (/=)
12:12:05 <lambdabot> Eq a => a -> [a] -> [a]
12:12:14 <klrr_> thanks!
12:14:35 <ownclo> c_wraith: I'm using an operational package for building invertible parsers. Is free-operational very different in some way? As far as I can see, it's just a reimplementation of operational (https://github.com/HeinrichApfelmus/operational) package
12:14:58 <c_wraith> ownclo: that was what I figured..  Maybe I'm doing something terribly wrong, I'm trying something simpler.
12:15:00 <kristof> I don't understand the fascination with type signature googling
12:16:36 <subleq_> kristof: why not?
12:16:46 <levi> It's handy when you don't know the libraries very well.
12:16:49 <kristof> klrr_: What's the context, out of curiousity? I'm not seeing how this is useful considering that Haskell uses homogeneous lists
12:17:21 <klrr_> kristof: removing spaces from a parsed string
12:17:22 <c_wraith> gah.  It's free-operational itself.  The simplest possible example I could think of went into an infinite loop
12:17:33 <kristof> klrr_: Oh I got you. Yeah, filter is pretty important :P
12:17:38 <klrr_> it's just a hacky script im making nothing serious
12:17:51 <klrr_> i know about filter
12:17:54 <kristof> klrr_: Sometimes I tantalize my C# friend. "You really don't need for loops in a language." "WHAT, HOW DO YOU GET ANYTHING DONE?"
12:17:56 <klrr_> i just couldnt remember it xD
12:18:04 <klrr_> i just know haskell :p
12:18:25 <klrr_> problem is my bad memory ;)
12:18:29 <ReinH> ownclo: my understanding is that operational is just a slightly inefficient free monad
12:18:36 <augur_> State s a = Reader s (Writer s a)
12:18:40 <augur_> which i find interesting
12:18:41 <earthy> kristof: then that C# friend doesn't really know much C#
12:18:50 <kristof> klrr_: Sometimes I forget if filter removes items or preserves them; I'm used to common lisp, where you've got both "REMOVE-IF-NOT" and "REMOVE-IF"
12:18:52 <c_wraith> ReinH: the interface is *very* different
12:19:02 <ReinH> c_wraith: Well that's true.
12:19:02 <augur_> it seems almost natural, given that statefulness is being able to read and write to a variable
12:19:03 <klrr_> kristof: haha, ive done that too xD
12:19:11 <augur_> i wonder if the monad operations are related as well
12:19:12 <kristof> earthy: I showed him delegates the other day, he had no idea how he would use them
12:19:45 <klrr_> any opinion if filter and split operations should be typeclasses? Filterable and Splitable?
12:20:01 <earthy> kristof: show him LINQ, break his mind. :)
12:20:07 <ReinH> klrr_: what would that give us?
12:20:09 <kristof> klrr_: No, they shouldn't be.
12:20:15 <klrr_> well, anything that derive both functor and monoid is filterable
12:20:22 <kristof> klrr_: Oh, I see what you mean.
12:20:37 <ReinH> klrr_: functors are not filterable.
12:20:39 <klrr_> so you dont need to re implement filter for Text bytestrings etc.
12:20:51 <ReinH> foldables are filterable if you don't need to preserve type
12:21:22 <klrr_> i just dont see why re-implementing split and filter for each new type is better than having a type class
12:21:24 <ReinH> i.e. filter :: Foldable f => (a -> Bool) -> f a -> [a]
12:21:31 <c_wraith> oh, I see.  apparently the issue is interpret is broken.  interpretWithMonad probably works
12:21:31 <zipper> Learn you a haskell might not be the best for a person who hasn't written functional.
12:21:52 <kristof> Sure it is
12:22:03 <kristof> Learn You a Haskell is targetted at people who can program, but not necessarily functionally
12:22:19 <zipper> Taking me forever to read and after I am done I am not sure I'll be a confident with haskell.
12:22:30 <hpc> it takes forever to read
12:22:31 <ReinH> but any foldable already has a toList, so filter is just filter p . toList
12:22:31 <kristof> It tries very hard to get people to think of computation as the transformation of data.
12:22:43 <kristof> zipper: Oh! Were you in here yesterday?
12:22:50 <zipper> kristof: People who have programmed and know their algos
12:22:56 <zipper> kristof: lol yes I was
12:23:01 <kristof> ahhhhh I remember you
12:23:12 <ReinH> :t \p -> filter p . F.toList
12:23:13 <lambdabot> Foldable t => (a -> Bool) -> t a -> [a]
12:23:14 <zipper> kristof: I remember you too
12:23:19 <ReinH> is probably the filte ryou want
12:23:30 <kristof> zipper: Like I said yesterday, work through the stuff in LYAH, and then read Real World Haskell. The combination of those two well get you very comfortable with Haskell.
12:24:18 <zipper> kristof: Ok man. Thanks.
12:24:38 <Platz> earthy: first-class functions and closures in c# don't get a lot of love in beginning c# tutorials.  Before LINQ it was usually encountering events for the first time you'd learn about them.
12:25:01 <zipper> I want to read that then http://composingprograms.com/ and then start actually implementing stuff.
12:25:04 <ReinH> Platz: well LINQ is an attempt to make imperative langauges more functional, right? :)
12:25:13 <kristof> bleh, LINQ
12:25:26 <levi> zipper: People who have been in #haskell a while have helped a lot of people. Although no one path to learning Haskell works for everyone, there are some that seem to work better for most than others. If that way doesn't work for you, just keep at it and we'll find one that does.
12:25:42 <Platz> ReinH: yes LINQ changed a lot in the C# world, hard to understate that
12:25:50 <kristof> something something supportive channel helpful community etc.
12:26:00 <Platz> still some people don't embrace it
12:26:03 <kristof> Platz: I'm not particularly enamored with closures, to be honest.
12:26:13 <zipper> lol thanks
12:26:28 <lispy> levi: on that note, sometimes it's the meta strategies to learning that actually work :)
12:26:43 <lispy> levi: eg., trying lots of things to learn the material
12:26:49 <levi> Yeah.
12:27:28 <kristof> someone with the name "lispy" talking about "meta-strategies". I lawled
12:27:35 <kristof> it made me laugh in a good way, though
12:27:39 <Platz> kristof: I agree when passing closures outside of functions, it can get messy, threading etc..
12:27:58 <lispy> kristof: :)
12:28:08 <zipper> meta-strategies?
12:28:18 <kristof> strategies about strategies
12:28:20 <zipper> strategies about stategies?
12:28:39 <earthy> Platz: beginning C# tutorials tend to be written for beginning programmers
12:28:53 <lispy> zipper: a strategy would be "follow this book and do the exercises". So then, wouldn't a strategy for picking how to study be a meta-strategy?
12:28:53 <kristof> Platz: Passing closures outside of functions? C# sure as hell doesn't have first class environments, I'm not sure what you mean
12:29:38 <zipper> lispy: Oh I see :)
12:30:02 <klrr_> what about split then? should it be a typeclass Splitable?
12:31:09 <earthy> kristof: methinks he means capturing variables from the environment in which an anonymous function is declared, and then returning that function out of the scope in which the variable was declared.
12:31:11 <Platz> kristof: I may not be saying it clearly, but i though you could  return a lambda which refers to a variable not defined in the lambda
12:31:11 <kristof> klrr_: name a scenario where you wish there was a typeclass Splittable
12:31:31 <Platz> and could modify it
12:31:36 <earthy> Platz: you can.
12:31:46 <kristof> Platz: ...so you mean an object.
12:32:00 <akemerofako> haskell newbie here trying to install happstack but no luck: src/Happstack/Server/Internal/Socket.hs:61:7:ghc: panic! (the 'impossible' happened)
12:32:02 <akemerofako>   (GHC version 7.4.1 for x86_64-unknown-linux):
12:32:03 <lispy> > let x = 1; y = \z -> x; in y 2
12:32:04 <lambdabot>  1
12:32:04 <akemerofako> 	Can't happen: pprExp (CompExp [])
12:32:41 <levi> klrr_: What you're asking for sounds a bit like 'Classy Prelude'
12:32:43 <lispy> Platz: Is y = \z -> x an example of a lambda like you mean? The x is non defined in \z -> x, but it can still reference it
12:32:51 <klrr_> kristof: so you dont need to define a new split for each string type for example
12:32:57 <klrr_> levi: does it got a splitable class?
12:33:02 <monoidal> akemerofako: could you paste the whole error message to lpaste.net?
12:33:03 <Platz> kristof: I'm probably not using the terms correctly, i tend to do that
12:33:18 <klrr_> but there is also other stuff, like sets and maps
12:33:40 <Platz> lispy: yes that's what I mean
12:33:44 <monoidal> akemerofako: does it say "Can't happen: pprExp (CompExp [])"?
12:33:52 <lispy> akemerofako: If I had to guess, it looks like a template haskell crash. Normally, it won't crash like that. It's possible you have a disagreement between the version of ghc and template haskell. Or something of that nature.
12:34:09 <levi> klrr_: I don't really know
12:34:10 <monoidal> akemerofako: if so, I recommend upgrading to ghc 7.6
12:34:15 <lispy> Platz: in that lambda, x is a free variable, but it is bound in a larger scope.
12:35:16 <kristof> Platz: You're using them perfectly fine
12:35:44 <kristof> Platz: Yes, you're right, that gets messy. But I don't see much of the point of that in a language like C# which already has objects, you know? :P
12:36:06 <akemerofako> http://lpaste.net/99343
12:36:27 <akemerofako> monoidal: okay, I will try.
12:37:05 <Platz> kristof: yep, totally valid point.  And in many cases those lambdas will desugar into an such an object via the compiler
12:37:14 <lispy> akemerofako: what does ghc-pkg list template-haskell say?
12:37:22 <Platz> "loosely speaking"
12:37:40 <kristof> Platz: Slightly unrelated, but this is about environments: ever heard of delimited dynamic variables?
12:38:34 <akemerofako> lispy: /var/lib/ghc/package.conf.d
12:38:36 <akemerofako>    template-haskell-2.7.0.0
12:38:38 <akemerofako> /home/anon/.ghc/x86_64-linux-7.4.1/package.conf.d
12:38:40 <akemerofako>    template-haskell-2.8.0.0
12:39:13 <Platz> kristof: no, google didn't turn up a whole lot either.  Looks like something to do with continuations, which is still a weak spot of mine.
12:39:14 <lispy> akemerofako: that looks fishy. Notice how they have different version numbers
12:39:30 <byorgey> having two verrsions of template haskell installed is a Bad Idea
12:39:47 <byorgey> you should unregister 2.8:  ghc-pkg unregister template-haskell-2.8.0.0
12:39:48 <Platz> there's something on 'this plt life' which insinuiates deliminted continuations are exceedingly difficult to understand
12:40:03 <byorgey> it may tell you some other things would break, you'll have to unregister those too
12:40:05 <Platz> but not sure if thats related at all
12:40:17 <akemerofako> lispy: okay, I see. You know I am new to haskell and I believe I installed one with apt-get and the other manually but I am not sure
12:40:42 <lispy> akemerofako: byorgey mentions the command you should run
12:41:31 <akemerofako> ghc-pkg: unregistering template-haskell-2.8.0.0 would break the following packages: stylish-haskell-0.5.9.1 Elm-0.11 pandoc-1.12.3.1 yaml-0.8.5.4 texmath-0.6.6 language-ecmascript-0.15.4 pandoc-types-1.12.3.1 aeson-pretty-0.7.1 aeson-0.7.0.0 indents-0.3.3 cmdargs-0.10.7 concatenative-1.0.1 QuickCheck-2.6 (use --force to override)
12:41:45 <akemerofako> byorgey, should I do it
12:41:57 <akemerofako> I need Elm
12:42:06 <byorgey> ouchies
12:42:13 <lispy> akemerofako: Are you using 7.4.x because it comes with your distro?
12:42:33 <lispy> akemerofako: one solution would be to use a newer ghc, but I don't want to suggest that if it's going to be a pain for you.
12:42:35 <akemerofako> lispy: yes I apt-get it.
12:42:58 <monoidal> looks like the crash was fixed in https://github.com/ghc/packages-template-haskell/commit/d7b864b7ddb0e8c2f58d08dfd50e843eb8966b90
12:43:06 <levi> There may be an alternate apt source that has more recent versions.
12:43:23 <byorgey> akemerofako: you will have to ask the Elm folks what the status is on support for ghc 7.4.x
12:43:39 <kristof> Platz: http://www.cs.rutgers.edu/~ccshan/dynscope/DDBinding.pdf
12:43:44 <kristof> Platz: More oleg-ware, of course
12:44:06 <byorgey> from personal experience maintaining a large project myself, 7.4 is getting old enough that maintaining support for it takes active and intentional effort
12:44:17 <akemerofako> byorgey: Alright, I am upgrading my ghc
12:44:22 <akemerofako> Thanks guys
12:44:42 <lispy> akemerofako: Good luck, you're welcome!
12:46:21 <earthy> wow. I've been out of touch... last I used haskell in anger 7.0 was the new kid on the block
12:47:29 * heatsink wishes the Cabal API would stabilize so that a custom Setup would work with different GHC versions
12:48:12 <Rembane> earthy: Have you been rage-Haskelling?
12:52:07 <bennofs> heatsink: and the worst about that is that there is no way to query the cabal version in a setup.hs file, is there?
12:52:30 <earthy> Rembane: nah. got hired in a C# shop about 2 1/2 years ago, haven't done much haskell since
12:52:57 <Rembane> earthy: Ah. Why did you use it in anger?
12:53:43 <earthy> ah, maybe you're not aware of the idiom? http://www.englishforums.com/English/SourceExpressionAnger/jkkzb/post.htm
12:54:02 <heatsink> Right, bennofs.  So the build system needs its own build system to manage that.
12:54:53 <bennofs> heatsink: check against cabal, and use ghc to compile a custom setup.hs? :|
12:55:58 <Rembane> earthy: Nope, and swedish doesn't help in that regard.
12:56:03 <Rembane> earthy: Cool idiom!
12:56:07 <heatsink> What's a portable way to query what version of a package is installed, without using Cabal?
12:56:51 <bennofs> heatsink: why do you need that?
12:58:20 <heatsink> Some parts of the Cabal API have changed between Cabal versions
12:58:52 <heatsink> So, before compiling code that uses the Cabal API, it's necessary to query which version of the Cabal API is available
12:58:58 <bennofs> heatsink: cabal --version?
12:59:10 <heatsink> That's cabal-install, not the Cabal library
12:59:27 <bennofs> for me it gives:
12:59:29 <bennofs> cabal-install version 1.18.0.2
12:59:32 <bennofs> using version 1.18.1.2 of the Cabal library
12:59:33 <geekosaur> doesn't it show both?
12:59:37 <geekosaur> yeh, that
12:59:41 <bennofs> but you could also use ghc-pkg
12:59:59 <geekosaur> although it can still lie because it mighthave been built against a different cabal library
13:00:12 <heatsink> The output of ghc-pkg doesn't appear to be designed for automatic parsing
13:00:17 <bennofs> like this: ghc-pkg field Cabal version
13:00:24 <bennofs> which gives:
13:00:26 <bennofs> version: 1.16.0
13:00:29 <bennofs> version: 1.18.1.2
13:00:31 <bennofs> for me
13:02:33 <heatsink> Hmm.  So I can write a Setup.hs that inspects the Cabal version, selects CPP flags, rebuilds Setup2.hs if out of date, then passes its command line arguments to Setup2
13:03:06 <heatsink> That is manageable
13:03:14 <heatsink> I still feel like I shouldn't have to write a build system for my build system
13:03:22 <bennofs> heatsink: if you call ghc, it won't rebuilt except if it's out of date
13:03:32 <bennofs> heatsink: so you don't need to check that
13:04:14 <amalloy> i can't find any function analogous to `list` in lisps: take an argument x, and return [x]. i guess there's (replicate 1), but that seems just silly. i don't recall why at the moment, but i wanted to map list xs. is there any particular reason this function doesn't exist?
13:04:18 <heatsink> ok
13:04:28 <gelisam> return
13:04:47 <heatsink> Thanks for pointing out ghc-pkg field.  I didn't know there was an easy way to read that information.
13:05:06 <bennofs> heatsink: but note that one may have multiple versions of a package installed
13:05:24 <gelisam> amalloy: when return is instantiated on lists, it wraps its argument as a singleton
13:05:25 <bennofs> heatsink: maybe ghc-pkg --simple-output latest Cabal is what ghc uses?
13:05:39 <amalloy> huh, return. i guess so, and it's more generic in case some other monad makes sense as well
13:05:54 <amalloy> thanks for that reminder
13:05:59 <bennofs> heatsink: or you might just pass `-package Cabal-${detected-version}` to GHC to be sure
13:05:59 <BMeph> amalloy: Lists aren't as central to Haskell, although you may not feel that way from looking at it. :)
13:06:51 <heatsink> There's also (:[]), which is one character less than return
13:07:01 <amalloy> pfft
13:07:27 <bennofs> or pure, if you have applicative imported
13:08:05 <ReinH> heatsink: monkey operator
13:08:44 <amalloy> right, i was too focused on the concrete case of lists
13:08:49 <ReinH> but usually one just writes [x] and moves on ;)
13:09:24 <ReinH> constructing lists is easier in languages with list construction literals ;)
13:16:11 <magneticduck> can I use an if expression inside a definition of a value in a let expression?
13:16:13 <magneticduck> I can, right?
13:16:19 <magneticduck> but I'm getting a parsing error or something
13:16:34 <nisstyre> > let a = 12 in if a == 12 then "something" else "nothing"
13:16:35 <lambdabot>  "something"
13:16:41 <magneticduck> yep
13:16:44 <nisstyre> oh you meant in the first part
13:16:45 <monoidal> > let a = if True then 4 else 5 in a
13:16:46 <lambdabot>  4
13:16:53 <magneticduck> yeah
13:16:55 <monoidal> perhaps your indentation is incorrect?
13:16:59 <magneticduck> perhaps
13:17:03 <magneticduck> I'm using it inside a do block
13:17:28 <magneticduck> but I don't think that's a problem
13:17:34 <nisstyre> magneticduck: that should work, just make sure it's indented far over enough
13:17:56 <nisstyre> try putting it all on one line first to make sure it's not another issue
13:18:37 <monoidal> magneticduck: if nisstyre's suggestion does not work, paste your code.
13:19:11 <magneticduck> http://ix.io/afY
13:19:19 <magneticduck> I'm usually a perfectly smart haskell programmer
13:19:24 <magneticduck> but right now I'm tired or something
13:19:31 <magneticduck> there's probably something blindingly obvious going on
13:19:33 <magneticduck> but can't find it
13:20:09 <magneticduck> btw I know the math is wrong in that code =P
13:20:19 <magneticduck> fails right at the line where the if is introduced
13:20:59 <shachaf> It's an if-then-else indentation issue.
13:21:21 <magneticduck> what's the problem?
13:21:26 <shachaf> By the way, you should paste your code and error message when you ask this sort of question.
13:21:34 <magneticduck> btw I know that code doesn't make sense at all
13:21:39 <shachaf> Otherwise people have to resort to guessing.
13:21:44 <magneticduck> yeah
13:21:50 <magneticduck> I said the error message though
13:21:55 <magneticduck> common parsing error
13:22:00 <magneticduck> triggered at the line where the if is introduced
13:22:04 <monoidal> magneticduck: it's indentation, if you merge the 4 lines it parses
13:22:23 <magneticduck> huh.
13:22:41 <magneticduck> no, actually
13:22:45 <magneticduck> merging the lines still gets the error
13:22:57 <magneticduck> triggered at the same line
13:22:58 <nisstyre> magneticduck: you should probably scrap the if expression anyway and put that in its own function
13:23:11 <magneticduck> ick
13:23:14 <magneticduck> why?
13:23:24 <nisstyre> magneticduck: easier to test
13:23:33 <monoidal> magneticduck: oh, just indent 4 lines containing the if statement with more spaces
13:23:47 <monoidal> magneticduck: they have to be more indented than "let"
13:23:59 <magneticduck> they are.
13:24:12 <magneticduck> intending the lines more didn't help, just tried it
13:24:14 * Axman6 suspects TABS!
13:24:18 <nisstyre> magneticduck: also you can use guards there
13:24:19 <magneticduck> no tabs
13:24:23 <magneticduck> Axman6: I like my spaces.
13:24:57 <nisstyre> > let a | 5 > 1 = "foo" | otherwise = "bar" in a
13:24:58 <monoidal> magneticduck: um, I mean more indented than "[" in "let [(targetH :: Double), targetW] ="
13:24:59 <lambdabot>  "foo"
13:25:07 <Axman6> yeh that whole if block definitely needs to be indented more
13:25:20 <magneticduck> monoidal: ahk
13:25:39 <magneticduck> huh.
13:25:42 <magneticduck> strange.
13:27:39 <monoidal> if you write
13:27:42 <monoidal> let x =
13:27:44 <monoidal> 1
13:28:05 <copumpkin> @src (^)
13:28:06 <lambdabot> x ^ 0            =  1
13:28:06 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:28:06 <lambdabot>   where f _ 0 y = y
13:28:06 <lambdabot>         f x n y = g x n
13:28:06 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:28:07 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:28:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:28:18 <monoidal> then 1 must be indented more than "x", otherwise it is considered to be next declaration in the let block
13:33:37 <td123> does anyone know why test libraries implement asserts without printing expected and actual?
13:34:08 <bennofs> td123: which test library are you using? Pretty sure that HUnit prints expected and actually
13:34:14 <bennofs> s/actually/actual
13:34:27 <bennofs> @quickcheck \x -> x == 4
13:34:27 <lambdabot> Unknown command, try @list
13:34:32 <bennofs> @check \x -> x == 4
13:34:34 <lambdabot>  *** Failed! Falsifiable (after 1 test):
13:34:34 <lambdabot>  0
13:34:50 <bennofs> ah, quickcheck only prints the inputs for which the test failed
13:35:07 <td123> bennofs: for example: http://hackage.haskell.org/package/yesod-test-1.2.1/docs/src/Yesod-Test.html#bodyEquals
13:35:32 <bennofs> td123: oh, that library uses assertBool.
13:36:21 <td123> right, but it should still provide expected and actual imo
13:36:24 <bennofs> td123: it should probably use assertEqual there
13:37:25 <td123> ah, I will have to get familiar with hunits assertEqual then
13:37:56 <td123> it's strange that this library uses assertBool for its assertEqual no?
13:38:44 <bennofs> td123: It also seems that that package won't work if the body contains unicode characters outside the Word8 range, because BSL8.pack will truncate them?
13:39:03 <bennofs> td123: not sure if bodies of responses are allowed to contain unicode characters
13:39:11 <zett_zelett> Has anyone good references for testing/debugging? I want to learn it, but at my level it seems unnecessary and I wouldn‚Äôt know how to start.
13:39:58 <bennofs> zett_zelett: you want to check out HUnit and QuickCheck.
13:40:29 <bennofs> zett_zelett: and also a test framework, for running multiple tests, like `tasty`
13:41:55 <bennofs> zett_zelett: some links: http://ocharles.org.uk/blog/posts/2012-12-08-24-days-of-hackage.html (Quickcheck) http://ocharles.org.uk/blog/posts/2013-12-03-24-days-of-hackage-tasty.html (Tasty)
13:43:54 <zett_zelett> Great, thank you very much, bennofs!
13:45:37 <BBShortcut> Which packages should I apt-get install to be able to cabal install darcs on Debian Sid?
13:45:57 <Clint> BBShortcut: apt-get build-dep darcs
13:46:13 <hpc> to give a slightly more specific answer, don't
13:46:22 <hpc> apt-get install everything, or use cabal entirely
13:47:01 <fragamus> howdy
13:47:20 <BBShortcut> thanks
13:48:11 <fragamus> I want to understand
13:48:14 <fragamus> http://lpaste.net/99345
13:48:56 <hpc> i am no expert, but i think that's a type error ;)
13:49:01 <hpc> can you paste code?
13:50:32 <fragamus> pasted an update
13:50:44 <fragamus> i am no expert either
13:51:18 <hpc> bah, just got pulled into something else
13:51:29 <hpc> uh
13:51:48 <hpc> yeah, i don't know enough lens to offhandedly help :(
13:51:51 * hpc away
13:51:52 <fragamus> no worries I have been getting kicked around for years
13:52:06 <Clint> fragamus: what's a V3 and what's _x?
13:52:23 <fragamus> See the Linear package
13:52:33 <fragamus> V3 is a vector
13:52:38 <fragamus> with three elements
13:52:53 <fragamus> _x is the first one
13:53:10 <bennofs> @hoogle _x +linear
13:53:10 <lambdabot> Could not find some databases: linear
13:53:10 <lambdabot> Searching in:
13:53:10 <lambdabot>   .
13:53:18 <bennofs> aw
13:54:03 <fragamus> http://hackage.haskell.org/package/linear
13:55:36 <enthropy> fragamus: !*! doesn't do  vector * matrix
13:55:51 <fragamus> oh!
13:55:59 <enthropy> I think you need to turn the V4 into a matrix, say with V1 (V4 ... )
13:56:33 <lars2> is there a portable way of getting file size without reading the entire file?
13:59:45 <Fuuzetsu> lars2: http://hackage.haskell.org/package/system-fileio-0.3.12/docs/Filesystem.html#v:getSize perhaps?
14:00:54 <bennofs> enthropy: ah, I understand the error now. Pretty weird :P
14:01:31 <enthropy> makes sense if you look at the type of !*!
14:01:48 <lars2> Fuuzetsu: thanks, I will try. I found System.Posix, which doesnt work on windows (except perhaps cygwin is installed)
14:01:56 <enthropy> !*! :: m (t a) -> t (n a) -> m (n a)
14:01:58 <lars2> +if
14:06:35 <skypers> is there a function like bracket but for EitherT?
14:06:38 <binroot> @pl (\(x,y) -> [x,y])
14:06:38 <lambdabot> uncurry ((. return) . (:))
14:06:47 <skypers> I guess it‚Äôs either
14:11:28 <joe9> any comments on this code, please? https://github.com/joe9/xmonad-task/blob/master/XMonad/Actions/Task.hs
14:12:26 <Fuuzetsu> joe9: not code per-se but perhaps put the Haddock named block at the bottom
14:16:52 <lars2> when I do getFile path I get this error: Couldn't match expected type `system-filepath-0.4.8:Filesystem.Path.Internal.FilePath' with actual type `[Char]'
14:17:22 <fragamus> enthropy: you nailed it man
14:17:30 <fragamus> I needed to use !*
14:17:34 <fragamus> not !*!
14:18:02 <td123> bennofs: I just ended up writing my own assert functions that do display expected vs actual
14:21:15 <BBShortcut>  #haskell
14:21:33 <BBShortcut>  /join #haskell
14:21:58 <hc> already there ;)
14:24:20 <Link-> is this really the un-trollable channel?
14:24:50 <BBShortcut> hc: apt-get build-dep gave me a list of packages and I use it to 1) cabal install all x for libghc-x-dev packages and apt-get install all liby-dev but this is not enough and cabal install darcs exits with an exitfailure 139
14:25:03 <prophile> Link-: not quite, one just has to know how to troll
14:25:24 <johannesbodannes> hmmmmmmm!
14:25:24 <prophile> starting discussions about other languages and what constitutes functional programming can trigger off some interesting reactions i've witnessed
14:25:28 <gelisam> hi! I'm having trouble compile ghc-7.8, should I ask here or over at #ghc?
14:25:41 <shachaf> Link-: Please don't troll.
14:25:47 <shachaf> prophile: Please don't troll or encourage trolling.
14:26:14 <prophile> shachaf: I was doing neither, just making an observation - please pardon my not making that more clear :)
14:26:29 <Link-> shachaf: I won't, but this brought me here :) https://gist.github.com/quchen/5280339
14:26:36 <BBShortcut> hpc: sorry, see message for hc ;-)
14:26:45 <shachaf> sigh
14:27:37 <BBShortcut> hpc: do you know what exitfailure 139 means?
14:27:42 <johannesbodannes> i do appreciate that people are very mild-mannered here
14:27:45 <Axman6> Link-: we're pretty good at dealing with trolls by making them want to learn haskell. Obviously this is a waste of time and will make them unproductive and unemployable for the rest of their life
14:28:09 <johannesbodannes> i just don't think anyone really tries to troll. i don't think that haskell attracts that kind of audience
14:28:41 <johannesbodannes> that sounded so conceited
14:28:48 <Link-> Axman6: which part is the waste of time? them trolling or you making them interested in haskell?
14:29:08 <Axman6> the latter =P
14:29:10 <prophile> BBShortcut: SIGSEGV
14:29:33 <Link-> Axman6: I think both are lol
14:30:19 <Link-> johannesbodannes: it depends.. on the people actually
14:30:37 <ownclo> that reminds me very much the MLP community
14:30:40 <lars2> why did system.filepath have to create a data called FilePath :/
14:31:18 <ownclo> Haskell is magic
14:31:19 <monoidal> gelisam: try here
14:31:20 <johannesbodannes> i have these friends who are huge trolls. i don't think any of them would have the patience. but they're perfectly happy to mash away at PHP or whatever
14:32:23 <Link-> johannesbodannes: troll or not, bashing PHP is another story lol
14:32:29 <gelisam> monoidal: I get a segfault during stage2 http://lpaste.net/99344
14:32:47 <oakwhiz_> Link-: http://www.codinghorror.com/.a/6a0120a85dcdae970b017742d249d5970d-800wi
14:33:33 <oakwhiz_> I have to && a lot of boolean expressions together. Is there a nice way of doing this in Haskell?
14:33:37 <gelisam> and the suggestion at http://www.haskell.org/pipermail/ghc-devs/2013-August/002086.html led to a different error
14:33:40 <Link-> oakwhiz_: :D Yep
14:34:05 <monoidal> gelisam: this seems extremely bad. I would open a ticket with those reproduction instructions + details about your system.
14:34:27 <monoidal> gelisam: or, ask at #ghc
14:34:48 <gelisam> monoidal: thanks, I will
14:35:24 <FireFly> oakwhiz_: what kind of expressions?  There's `and`, which asserts that all booleans in an array are true
14:35:50 <triliyn> > and [1 < 2, 2 < 3, 3 < 4]
14:35:52 <lambdabot>  True
14:36:14 <oakwhiz_> oh that's very cool
14:36:22 <L8D> :t choose
14:36:23 <lambdabot> Random a => (a, a) -> Gen a
14:37:08 <L8D> @hoogle Bool -> a -> a -> a
14:37:08 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:37:09 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
14:37:09 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
14:37:38 <L8D> :t \b x y -> if b then x else y
14:37:39 <lambdabot> Bool -> t -> t -> t
14:37:48 <joe9> Fuuzetsu: good idea, thanks.
14:39:21 <L8D> :hoogle (a -> Bool) -> b -> b -> a -> b
14:40:24 <monoidal> @hoogle (a -> Bool) -> b -> b -> a -> b
14:40:24 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
14:40:24 <lambdabot> System.Posix.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
14:40:24 <lambdabot> System.Posix.Error throwErrnoPathIfRetry :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
14:40:46 <L8D> I want an easy way to check for null
14:41:03 <monoidal> L8D: for Nothing? isNothing in Data.Maybe
14:41:30 <L8D> @pl \xs y -> if null xs then [y] else xs
14:41:30 <lambdabot> flip =<< (. return) . if' . null
14:41:33 <ocharles> L8D: bool :: a -> a -> Bool -> a -- will be in the next GHC, but not this GHC
14:41:35 <L8D> :t if'
14:41:36 <lambdabot>     Not in scope: if'
14:41:36 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
14:41:39 <ocharles> not the current*
14:42:07 <L8D> ocharles: cool then...
14:42:14 <L8D> I hate use lambdas
14:42:17 <L8D> using*
14:42:27 <k00mi> ocharles: next as in 7.8?
14:42:30 <ocharles> yea
14:42:37 <monoidal> @pl \y xs -> if null xs then [y] else xs
14:42:37 <lambdabot> join . flip (if' . null) . return
14:42:38 <k00mi> nice
14:42:44 <ocharles> my one commit to help GHC 7.8 ;)
14:43:05 <k00mi> it keeps getting better
14:43:13 <k00mi> 7.8 will be like christmas
14:43:20 <monoidal> L8D: this one is rather irregular, I would leave it as 'if', or even make a case on empty list
14:43:41 <ocharles> L8D: guard (not $ null xs) *> [y] <|> xs -- is one way to do that specifically in the list monad
14:43:58 <ocharles> :t \xs y -> guard (not $ null xs) *> [y] <|> xs
14:43:59 <lambdabot> [a] -> a -> [a]
14:44:38 <ocharles> in fact, i think you can drop the alternative
14:44:52 <L8D> @pl \xs -> if null xs then [0] else xs
14:44:52 <lambdabot> flip if' [0] =<< null
14:45:06 <ocharles> let f xs y = guard (not $ null xs) *> [y] in (f [42] 99, f [] 99)
14:45:12 <ocharles> > let f xs y = guard (not $ null xs) *> [y] in (f [42] 99, f [] 99)
14:45:14 <lambdabot>  ([99],[])
14:45:25 <x77686d> I see 'init' in both the Prelude and Data.List and I  see 'words' in both the Prelude and Data.String.  Is the Prelude in fact a collection of selected functions from various modules?
14:45:50 <monoidal> x77686d: yes: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Prelude.html
14:45:55 <gratimax> Yes, you can even see the api docs: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
14:46:03 <gratimax> oh, you beat me
14:47:30 <x77686d> That's just what I was looking for!  Thanks to both!
14:51:32 <hvr> k00m, L8D: http://hackage.haskell.org/package/base-4.7.0.0/candidate/docs/Data-Bool.html#v:bool
14:58:34 <johannesbodannes> augh ffs, endless dependency build errors
15:01:06 <johannesbodannes> does anyone here happen to have built yesod on ubuntu recently? <_<
15:01:38 <skypers> nope
15:02:32 <johannesbodannes> what about using the ubuntu haskell-platform in general? i'm sort of tempted to just
15:03:04 <johannesbodannes> get the most recent haskell-platform from somewhere else and try that
15:03:39 <johannesbodannes> everything just installs so much more smoothly on my own computer ._.
15:05:02 <Saizan> i tend to avoid haskell stuff from distros, it's often behind or splitted into too many packages
15:05:31 <johannesbodannes> pain in the arse
15:05:40 <aleksejs_> johannesbodannes, don't know about yesod, but there were some dependency problems installing happstack+mysql-simple+json in my case
15:06:02 <johannesbodannes> yeah iirc there are a lot of common dependencies
15:06:23 <skypers> :t eitherT
15:06:24 <lambdabot>     Not in scope: `eitherT'
15:06:24 <lambdabot>     Perhaps you meant `either' (imported from Data.Either)
15:06:41 <aleksejs_> can lambdabot show me a declaration of a function?
15:06:47 <skypers> :t map
15:06:47 <lambdabot> (a -> b) -> [a] -> [b]
15:06:51 <skypers> aleksejs_: ^
15:06:55 <skypers> @src map
15:06:55 <lambdabot> map _ []     = []
15:06:55 <lambdabot> map f (x:xs) = f x : map f xs
15:07:02 <aleksejs_> tnx
15:07:08 <skypers> you‚Äôre welcome
15:07:13 <johannesbodannes> wow that's awesome, didn't know lambdabot did that
15:07:18 <FireFly> Doesn't work for everything though
15:07:22 <aleksejs_> @src scanl
15:07:22 <lambdabot> scanl f q ls = q : case ls of
15:07:22 <lambdabot>     []   -> []
15:07:22 <lambdabot>     x:xs -> scanl f (f q x) xs
15:07:24 <fragamus> woo hoo haskell rocks
15:07:30 <skypers> it even works for instance
15:07:48 <skypers> does anyone know a way to use eitherT?
15:08:01 <skypers> I want being able to ‚Äúcatch‚Äù errors in EitherT
15:08:08 <fragamus> I just tried my torus ray tracer and it worked the first time
15:08:10 <skypers> and not breaking it on Left
15:08:28 <skypers> fragamus: I‚Äôm interested
15:08:41 <skypers> I‚Äôm a demomaker, and migrating my 3D engine from C++ to Haskell
15:08:46 <fragamus> well I only did one ray
15:08:53 <skypers> software?
15:08:56 <skypers> or gl?
15:09:04 <fragamus> but it hit the torus, exited, entered again and exited again
15:09:16 <fragamus> [960.0,940.0,1060.0,1040.0]
15:09:37 <fragamus> software
15:09:40 <skypers> ok
15:10:00 <fragamus> with one call to a cube root function in C
15:11:38 <skypers> ok
15:11:59 <skypers> I guess the best equivalent of bracket for EitherT is eitherT
15:12:11 <skypers> or EitherT . eitherT
15:12:14 <simpson> skypers: You want to be able to "recover" from a Left and return a Right?
15:12:20 <skypers> yep simpson
15:12:24 <skypers> like bracket does for exceptions
15:12:36 <skypers> either does that
15:12:37 <skypers> :t either
15:12:38 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:12:55 <skypers> I think eihterT is perfect for that
15:13:30 <skypers> I‚Äôm just surprised there‚Äôs not the EitherT version return in errors
15:13:41 <structuralist> I'm confused about why I'm getting this error: http://lpaste.net/99348
15:13:48 <simpson> skypers: Well, you want to detect the Left first.
15:14:09 <structuralist> given the types of A and B it looks like I should be able to apply B to A but no luck
15:14:32 <simpson> skypers: It's not hard, but you'll have to remember to runEitherT first.
15:14:43 <skypers> simpson: ?
15:15:25 <skypers> I don‚Äôt get your point simpson
15:15:43 <skypers> eitherT does that for me
15:15:47 <simpson> skypers: What kind of type signature do you want to see?
15:15:51 <simpson> :t bracket
15:15:52 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:16:08 <simpson> Do you want something like that, but with EitherT?
15:16:25 <skypers> something like (e -> EitherT e m b) -> (a -> EitherT e m b) -> EitherT e m a -> EitherT e m b
15:16:35 <skypers> something transactional
15:16:50 <skypers> @let import Control.Monad.Trans.Either
15:16:50 <lambdabot>  .L.hs:55:1:
15:16:50 <lambdabot>      Failed to load interface for `Control.Monad.Trans.Either'
15:16:50 <lambdabot>      Perhaps you meant
15:16:50 <lambdabot>        Control.Monad.Trans.Writer (from transformers-0.3.0.0)
15:16:50 <lambdabot>        Control.Monad.Trans.Error (from transformers-0.3.0.0)
15:17:01 <skypers> lambdabot: you‚Äôre so stupid my gosh
15:18:09 <djahandarie> @let import Unsafe.Coerce
15:18:09 <lambdabot>  .L.hs:122:1:
15:18:09 <lambdabot>      Unsafe.Coerce: Can't be safely imported!
15:18:09 <lambdabot>      The module itself isn't safe.
15:18:45 <skypers> mapEitherT sounds great to
15:19:03 <skypers> but I don‚Äôt like the fact it‚Äôs too powerful
15:19:11 <skypers> it can change monad on-the-fly
15:19:52 <Earnestly> "Unsafe coerce cannot be safely imported", heh
15:21:33 <skypers> ahah!
15:21:37 <skypers> it‚Äôs bimapEitherT
15:21:54 <skypers> or bimap with Bifunctors I guess
15:22:56 <skypers> oh
15:23:00 <skypers> no, it‚Äôs not bimap
15:23:02 <skypers> dammit
15:23:27 <bennofs> skypers: hmm, really?
15:23:33 <bennofs> @let import Data.Bifunctors
15:23:34 <lambdabot>  .L.hs:59:1:
15:23:34 <lambdabot>      Failed to load interface for `Data.Bifunctors'
15:23:34 <lambdabot>      Perhaps you meant
15:23:34 <lambdabot>        Data.Bifunctor (from bifunctors-4.1.1)
15:23:34 <lambdabot>        Data.Profunctor (from profunctors-4.0.1)
15:23:35 <skypers> hm, well I guess it‚Äôs ok
15:23:37 <bennofs> @let import Data.Bifunctor
15:23:37 <lambdabot>  <no location info>:
15:23:38 <lambdabot>      The package (tagged-0.7) is required to be trusted but it isn't!
15:23:55 <skypers> lambdabot is such a douche
15:24:05 <skypers> I guess I can do something like
15:24:22 <skypers> bimap cleanUp doSmtgh $ Left "fail"
15:24:26 <skypers> it will clean up
15:24:35 <skypers> and stay in EitherT :)
15:24:43 <simpson> :t \fail succeed ma -> do { eea <- runEitherT ma; case eea of { Left e -> fail e; Right a -> succeed a } }
15:24:44 <lambdabot>     Not in scope: `runEitherT'
15:24:44 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
15:24:48 <simpson> skypers: ^^?
15:24:49 <bennofs> ah no, that won't work. bimap is like fmap, but for functors with 2 "values"
15:25:01 <skypers> yes bennofs
15:25:10 <skypers> and EitherT has two values as well
15:25:23 <skypers> so I think it‚Äôll make it through
15:29:40 <Platz> I keep getting hung up when I hear that bifunctors must be covariant, but my current understanding of variance only applies to subtyping, so there's something else in the algebra i haven't grokked yet there
15:31:08 <shachaf> "covariant" in a Haskell context means something slightly different from what it means in a subtyping context.
15:31:19 <shachaf> ("slightly" because they're both instances of a more general idea.)
15:32:13 <shachaf> Really, it means the same as "functor".
15:32:55 <shachaf> "F is covariant in its argument" means you can write a function fmap :: (a -> b) -> F a -> F b that satisfies the functor laws.
15:33:40 <shachaf> "F is contravariant in its argument" means you can write a function contramap :: (a -> b) -> F b -> F a that satisfies (a version of) the functor laws.
15:34:17 <shachaf> So "F is (co/contra)variant in its (first/second) argument" means the same thing but restricted to just one argument.
15:34:41 <shachaf> E.g. secondmap :: (a -> b) -> F x a -> F x b
15:35:42 <Platz> thanks, that's pretty clear
15:36:29 <Platz> There seem to be a lot of fmap examples in the tutorials, not so much exposure to contramap
15:37:17 <shachaf> To see the relation to subtyping: "F is covariant" means "if A <: B, then F A <: F B"
15:37:29 <shachaf> And "contravariant" means "(A <: B) -> (F B <: F A)"
15:37:55 <shachaf> Yes, Contravariant is less common.
15:38:31 <shachaf> There's more or less just one way to get it in Haskell, which is to use something as the argument of a function.
15:39:00 <shachaf> I.e. (A -> B) is contravariant in A.
15:39:22 <shachaf> (OK, you can also get it with a phantom type.)
15:39:43 <ParahSailin> what stream/pipe/iteratee pattern would i use if i had n between 20-100 files, and i wanted to zip them into a stream of n-size arrays, taking byte 0 of all files, byte 1 of all files.. etc
15:40:43 <athan> Has anyone here read Category Theory by Steve Awodey?
15:40:45 <Axman6> that's an interesting question...
15:41:11 <Axman6> (ParahSailin not athan)
15:42:25 <zrho> athan: I once read some chapters, but that's quite some time ago
15:43:18 <athan> I'm trying to figure out what he means by a group in his definitions
15:43:37 <athan> I've never studied group theory, but I think that's something different than how he uses the term "group"
15:43:54 <ParahSailin> i will probably end up doing this with low-level bytestring operations
15:44:02 <zrho> Does he use it for a one object category with only isomorphisms?
15:44:09 <athan> for instance
15:44:37 <athan> "For any set X, we have the _group_ Aut(X) of automorphisms of X"
15:44:45 <athan> Yes@
15:44:47 <athan> !*
15:44:52 <Axman6> ParahSailin: you could use an array of Builders (or even perhaps an IntMap of builders) and accumulate over all files zipped with the character/byte indices
15:45:20 <zrho> Well, you have the composition as the group operation
15:45:37 <athan> huh...
15:45:42 <athan> what does group do?
15:45:55 <athan> so say the category is just one object A
15:46:04 <athan> and the different isomorphisms are f, g, h, ...
15:46:13 <athan> what would it mean to have a group of them?
15:46:27 <zrho> In a classical definition a group is a set  together with an associative binary operation on that set with an identity element and an inverse for each element
15:46:46 <zrho> Now take the automorphisms of A as the set of the group
15:47:01 <athan> OH
15:47:01 <zrho> The operation is composition, the neutral element is id
15:47:03 <athan> okay
15:47:17 <zrho> And they have to be isomorphisms in order to be invertible.
15:47:35 <silasm> zrho: aren't all automorphisms isomorphisms?
15:47:51 <zrho> automorphisms are isomorphisms which are endomorphisms
15:48:07 <zrho> so isomorphisms A -> A for some object A
15:48:22 <athan> so the binary operation is invertable, as well?
15:48:47 <zrho> In a sense: for each f in Aut(G) there is a g in Aut(G) such that f * g = id = g * f
15:49:03 <zrho> with * being composition
15:49:25 <athan> that being it's inverse??
15:49:33 <athan> g being f's inverse?
15:49:37 <zrho> yes
15:49:45 <athan> ahh okay I had this totally wrong
15:52:12 <zrho> Note that End(A) for some object A builds a monoid under composition; then you additionally require the elements to be invertible so you get Aut(A), which then forms a group (monoid in which every element has an inverse).
15:54:50 <skypers> ooooh
15:55:11 <skypers> it seems already the bracket equivalent for EitherT already exists
15:55:46 <skypers> it‚Äôs catchT
15:55:52 <skypers> or handleT
15:57:30 <athan> so an automorphism creates a group, which can be manipulated via Groups?
15:58:46 <nisstyre> athan: an automorphism is just permutations of stuff afaik
16:00:29 <zrho> nisstyre: in Sets, yes. In a general category an automorphism is an endomorphism (a morphism from an object to itself), which is also an isomorphism (there exists a morphism such that both morphisms composed are the identity)
16:00:47 <nisstyre> zrho: I'm sorry I have no idea what that means
16:01:06 <nisstyre> what's the use of an automorphism in category theory?
16:01:48 * hackagebot hsqml 0.2.0.3 - Haskell binding for Qt Quick  http://hackage.haskell.org/package/hsqml-0.2.0.3 (RobinKay)
16:02:41 <Rarrikins> How can I have a global MVar?
16:02:47 <Rarrikins> Or something similar
16:03:17 <zrho> It's just terminology basically. In the category of sets it coincides with permutations (bijective self-maps).
16:03:47 <nisstyre> zrho: okay cool
16:03:48 <skypers> night
16:04:31 <Axman6> Rarrikins: it's possible but generally to be avoided. you can use myGlobal :: MVar Foo; myGlobal = unsafePerformIO emptyMVar {-# NOINLINE myGlobal #-}
16:04:37 <zrho> Or e.g. in the category of finite vector spaces over a field K an automorphism is a square matrix over K.
16:05:05 <athan> where can I learn more about vector spaces / bijective self-maps stuff?
16:05:07 <Rarrikins> Axman6: Is that guaranteed to be a 'singleton'?
16:05:30 <Axman6> Rarrikins: I don't know about guaranteed, but afaik it will be
16:05:33 <nisstyre> zrho: permuting only works as a group operation on finite sets yes?
16:05:42 <Rarrikins> Axman6: OK, thanks :)
16:05:43 <nisstyre> or is there some other way of defining that
16:06:01 <athan> I feel like I'm missing out on it all
16:06:37 <Axman6> Rarrikins: but what is almost guaranteed is that you probably don't eant to do that ;)
16:07:02 <zrho> nisstyre: if you interpret permuting as bijective maps of a set into itself, then it also works for infinite sets: composition is associative, has a neutral element (id) and and inverse (because it's bijective)
16:07:41 <johannesbodannes> can anyone recommend a good linux distribution that has a very current version of the haskell platform?
16:07:43 <nisstyre> zrho: okay, so that would be a more abstract version of permutation
16:07:49 <athan> gentoo
16:07:51 <skypers> johannesbodannes: archlinux
16:07:55 <skypers> or debian with sid
16:07:58 <athan> warning: compile your kernel
16:07:59 <nisstyre> and if you collect all of the possible elements of that group you get the permutations
16:08:05 <johannesbodannes> ok thanks
16:08:05 <skypers> I use wheezy right now
16:08:09 <nisstyre> and that number can be infinite I guess
16:08:10 <skypers> and it‚Äôs quite okay
16:08:17 <skypers> but I don‚Äôt use haskell platform
16:08:18 <shachaf> zrho: An invertible matrix, not just any square matrix.
16:08:26 <skypers> I just have ghc, and cabal-install
16:08:37 <zrho> shachaf: Yep
16:08:46 <Axman6> what the hell happened to Arch? I tried it the other day, and I swear it used to have an installer, now it's some backwards junk of making a file system, then using pacman to install everything. it was horrific
16:08:49 <zrho> missed that one.
16:08:58 <nisstyre> Axman6: they got rid of the AIF I think
16:09:08 <Axman6> whyyyyy
16:09:09 <skypers> Axman6: you‚Äôre late :)
16:09:10 <Axman6> D:
16:09:19 <nisstyre> Axman6: it's not that hard, the hardest part is figuring out your partitions
16:09:22 <Axman6> what the hell is the point of that
16:09:33 <skypers> arch moved from the install to ‚Äúinto the core‚Äù a few years ago
16:09:35 <nisstyre> Axman6: well I think the AIF was hard to maintain
16:09:37 <nisstyre> or something
16:09:37 <Chousuke> Axman6: because doing stuff like that teaches you, or something.
16:09:39 <Axman6> nisstyre: I shouldn't have to.
16:09:46 <skypers> Axman6: what Chousuke said
16:09:50 <shachaf> But these are way too many complicated words for a few simple concepts.
16:09:52 <zrho> athan: I would recommend reading a book on linear algebra for some basic algebraic stuff (sets, monoids, groups, rings, vector spaces), then switch to a nice category theory book.
16:10:02 <skypers> I learned A¬†LOT about initramfs while installing arch
16:10:07 <skypers> and hooks
16:10:12 <athan> zrho: Thanks man
16:10:24 <skypers> after dozens of arch installs
16:10:30 <skypers> you can do anything you want.
16:10:31 <Earnestly> Axman6: Except that AIF was horrifically buggy, didn't actually work at all since systemd and no one wanted to maintain or fix it.
16:10:31 <skypers> :D
16:10:39 <Chousuke> arch is not really a distro for you  if you just want something that works.
16:10:41 <nisstyre> zrho: usually that stuff is called abstract algebra, linear algebra is more about computational methods of solving systems of equations
16:10:44 <nisstyre> at least here in Canada it is
16:10:50 <Yaniel> the arch install procedure is not that difficult after you do it once or twice
16:10:51 <zrho> nisstyre: it is
16:10:54 <skypers> Chousuke: that‚Äôs why I moved from arch to debian wheezy
16:10:56 <Axman6> I just wanted a simple distro to run in a VM. ended up after trying 3 (arch, nix, ubuntu) and figuring out what my problem on OS X actually was
16:11:01 <Earnestly> So now you have to make partitions yourself, this shouldn't be hard.  Most of us have to make partitions ourselves anyway because the AIF only covered the most extreme of basic cases, it didn't even do GPT.
16:11:04 <silasm> Chousuke: I've actually found arch surpisingly easy to maintain most of the time.
16:11:10 <Earnestly> Axman6: Arch is not for you, pick something else
16:11:13 <skypers> always fixing things back after each updates is painful
16:11:14 <zrho> nisstyre: but introductions to linear algebra seem to be written quite well and cover the basics
16:11:17 <silasm> gentoo's a little hairier
16:11:19 <Axman6> Yaniel: even OpenBSD is easier to install
16:11:24 <nisstyre> zrho: yeah true
16:11:26 <Chousuke> silasm: I tried it once but then gave up when I had to touch AUR and it was just painful.
16:11:27 <Axman6> Earnestly: I did, twice
16:11:32 <skypers> especially because I have optimus GPUs
16:11:33 <Rarrikins> Axman6: What's a good way to maintain state for an external web application so that two threads that don't know about each other accessing one account have a consistent cache of that account's data (I want to store a small amount of metadata for each account and storing it separately for each independent thread will degrade performance)?
16:11:45 <Earnestly> Axman6: Then use OpenBSD, Arch does not care about its users
16:11:53 <silasm> Chousuke: ah, I meant pacman stuff. AUR is a crapshoot basically.
16:11:54 <skypers> use debian.
16:12:15 <skypers> wheezy is really nice to me
16:12:21 <Earnestly> silasm: Literally over 50% (57% iirc) of the AUR will not work when pacman 4.2 is released ;p
16:12:22 <skypers> maybe one of the best distro ever
16:12:23 <Chousuke> I run debian unstable :P
16:12:27 <Earnestly> And they've had plenty of time to fix it
16:12:28 <skypers> sid?
16:12:30 <skypers> or jessy?
16:12:31 <nisstyre> Axman6: if you do decide to use Arch, then please do not use the haskell packages in the AUR
16:12:31 <Rarrikins> Axman6: In another language, I'd just use a sort of global hashmap or something, but I'm not sure what to do in Haskell.
16:12:36 <Chousuke> well actually
16:12:38 <Earnestly> (the AUR packagers, e.g. anyone)
16:12:45 <Chousuke> I run jessie with manually pinned unstable packages mixed in
16:12:55 <skypers> :)
16:12:58 <Fuuzetsu> are you girls playing with your toy distros again?
16:13:02 <Earnestly> nisstyre: +1, they're all horrible lol
16:13:08 <Axman6> Rarrikins: why would there be no way for the threads to be spawned with reference to an MVar you made in main?
16:13:08 <skypers> Fuuzetsu: I do have boobs
16:13:10 <nisstyre> Earnestly: there are a few necessary packages in the AUR, like there's a kernel patch to get my touchpad working properly
16:13:16 <Earnestly> nisstyre: Even td123 doesn't bother packaging haskell stuff because cabal is just so much better at it
16:13:21 <silasm> Earnestly: yeah, ime most AUR package managers don't do very good maintanence. I've had some that did good work though.
16:13:25 <skypers> yeah I‚Äôm just kiding
16:13:28 <skypers> night folks
16:13:30 <Chousuke> and re partitioning, just use LVM
16:13:33 <Fuuzetsu> skypers: you also have NO BREAK SPACE which disqualifies you from any discussion
16:13:34 <Chousuke> 0 trouble
16:13:51 <Earnestly> nisstyre: Yeah, I maintain my own PKGBUILDs though, good ones.  I posted them in the AUR comments after fixing them as and when, sometimes the maintainer picks it up *shrug*
16:14:20 <nisstyre> Earnestly: well I never redownload it, it just gets redone every time I get a new kernel
16:14:51 <Earnestly> nisstyre: Exactly, I just keep the PKGBUILDs and other source files around for reuse, while fixing the pkgbuild at the same time
16:14:58 <Rarrikins> Axman6: There's a possibility that a library user might do it wrong. I'd like to avoid that.
16:15:45 <Earnestly> nisstyre: But yeah, the AUR is pretty miserable.  We had someone write an aurlinter that basically pulled the entire AUR and did some checks on the PKGBUILD, if it conformed to the manual, looked for tar bombs, etc.  It wasn't great
16:16:14 <nisstyre> Earnestly: are you a TU or dev?
16:16:17 <Earnestly> Some people even redefine DL_AGENT in the pkgbuild for almost no reason‚Ä¶
16:16:20 <Earnestly> nisstyre: Neither
16:16:26 <nisstyre> ah ok
16:16:29 <Earnestly> Just someone who writes better pkgbuilds than most TUs
16:16:48 <nisstyre> Earnestly: after falconindy stopped being a TU
16:16:52 <Earnestly> He's a dev
16:16:57 <nisstyre> yeah that's what I meant
16:16:59 <Earnestly> Thankfully core stuff is done properly
16:17:01 <Axman6> Rarrikins: it really sounds like you're trying to do something most haskell users wouldn't want to use. global state is widely frouned upon and leads to many issues
16:17:13 <Earnestly> But [community] (TU) is pretty meh to say the least.
16:17:24 <nisstyre> Earnestly: I should start contributing to things more
16:17:28 <nisstyre> I occasionally edit the wiki
16:17:40 <nisstyre> and sometimes answer questions in the programming subforum
16:17:42 <nisstyre> lol
16:17:44 <Earnestly> nisstyre: It's a battle of attrition
16:18:14 <nisstyre> Earnestly: I'm getting a new laptop soon (system76) and I'm debating keeping ubuntu on it
16:18:19 <Earnestly> There are a few wiki members who constantly going around adding pretty bad content, entire scripts written in bad shell, etc.
16:18:35 <nisstyre> Earnestly: yeah, there are some bad articles
16:18:37 <Axman6> I used to really love Arch, now it seems like a completel ghetto
16:18:38 <nisstyre> e.g. the mpd one is bad
16:18:51 <Axman6> complete*
16:19:07 <Axman6> it felt like the most BSD like distro, and I loved that
16:19:08 <nisstyre> Axman6: it's not that bad, I haven't had any problems in ages
16:19:17 <nisstyre> systemd is better than expected
16:19:27 <Axman6> not having an installer is a very very big problem
16:19:33 <silasm> yeah I actually like systemd as well.
16:19:43 <silasm> Axman6: heh, and I was about to recommmend gentoo XD
16:19:48 <nisstyre> I might install arch just for systemd actually
16:19:55 <nisstyre> then I can get ridiculous boot times with my SSD
16:20:03 <silasm> but I really can't as I've only been actually *using* it for ~2 weeks.
16:20:05 <Earnestly> nisstyre: Anyway, it suits me.  I do appreciate that Arch as a rule doesn't care about the userbase, or if it has any users (unless you submit patches and bug reports) and that it doesn't split packages into `-dev` nonsense combined with pure upstream (or almost without alteration)
16:20:22 * silasm thinks if this goes on much longer we should probably move to haskell-blah
16:20:24 <Earnestly> nisstyre: systemd also isn't broken by design ;p
16:21:04 <nisstyre> Earnestly: I need to figure out how to add needless graphical sugar to xmonad
16:21:05 <Earnestly> Anyway, yeah.  A lot of offtopic, will stop o/
16:21:14 <Earnestly> nisstyre: taffybar?
16:21:15 <nisstyre> so that I can properly make use of the GPU on this new laptop
16:21:22 <nisstyre> Earnestly: never heard of that
16:21:29 <athan> nice!
16:21:30 <nisstyre> I was thinking more of hacking compiz on
16:21:34 <athan> Have you ever used wayland?
16:21:37 <nisstyre> no
16:21:44 <athan> I want to
16:21:49 <Earnestly> athan: I've only used weston and a few other bits
16:22:01 <nisstyre> I saw that CCC talk about X though
16:22:02 <athan> I think the nvidia/ati xorg drivers are compatible
16:22:09 <nisstyre> and it makes me really want to drop X for something else
16:22:10 <zrho> Haskell blah: I am currently trying to find a nice topic for a haskell related bachelors thesis. Any ideas?
16:22:11 <Yaniel> does anyone know of an xmonad successor for wayland? :D
16:22:31 <nisstyre> athan: what about Intel?
16:22:42 <athan> Most likely
16:22:46 <Yaniel> athan: the proprietary drivers don't support KMS which was a showstopper last time I checked
16:22:48 <athan> Google it up!
16:22:58 <nisstyre> I'm guessing Intel has the best support for anything tbh
16:23:02 <athan> ooooooooh crap, I think you're right...
16:23:11 <Yaniel> nisstyre: except opengl
16:23:13 <Earnestly> Yaniel: None yet, but there is this: (sort of like a `libdwm` for wayland compositors) http://lists.freedesktop.org/archives/wayland-devel/2014-January/012899.html
16:23:33 <Yaniel> because mesa only supports 3.3 so far :(
16:23:49 <athan> What we need
16:23:51 <Earnestly> Yaniel: Which is more than enough for almost everything (plus extensions)
16:23:57 <athan> are some good open source gpus
16:24:02 <Yaniel> but I want to use 4.4 :(
16:24:06 <Earnestly> Why?
16:24:14 <Yaniel> well, I guess 4.3 has all I really will use
16:24:18 <Earnestly> What extensions do you need from 4.3/4?
16:24:23 <Axman6> athan: there was a kickstarter project for one... it was trying to reproduce a very old GPU
16:24:31 <Earnestly> (There is tesselation, that's one)
16:24:32 <Yaniel> debug contexts as the first thing
16:24:44 <Yaniel> tessellation is 4.0 iirc?
16:24:50 <athan> I heard ccc's can be compiled down to ASICs, is this true?
16:24:58 <athan> I feel like that would be a step in the same direction
16:25:07 <Axman6> ccc's?
16:25:08 <Earnestly> Yaniel: https://www.opengl.org/registry/specs/ARB/debug_output.txt ?
16:25:16 <athan> closed cartesian categories
16:25:23 <athan> erm
16:25:27 <Yaniel> Earnestly: yeah
16:25:28 <athan> you know hwat I mean haha
16:25:40 <Yaniel> I know there are two or three extensions for it
16:25:49 <Yaniel> but it is always nice when you can use core functionality
16:25:54 <Earnestly> Yaniel: http://cgit.freedesktop.org/mesa/mesa/tree/docs/GL3.txt
16:26:10 <zrho> Categories with a terminal object, all products and all exponentials.
16:26:15 <Yaniel> ooh, nice
16:26:24 <shachaf> finite products
16:26:29 <zrho> Right
16:26:31 <Earnestly> Yaniel: Mesa will only support Core Profiles though after 3.1 though
16:26:44 <Yaniel> fine for me
16:26:55 <Earnestly> Because it will never implement GL_ARB_compatability
16:27:01 <Yaniel> I barely have interest for compat profile
16:27:10 <Earnestly> Fair enough
16:27:18 <Yaniel> since learning to do things the modern way at least
16:27:36 <Earnestly> \o/
16:28:02 <Earnestly> GLSL 4.0 is going to be interesting, I wonder how they're going to do that, and when, heh.
16:28:10 <Yaniel> GLSL4.0 ?
16:28:26 <Yaniel> you mean 4.00? or GL 4.0
16:28:29 <Earnestly> Atm, they have GLSL 3.3
16:28:58 <Earnestly> (OpenGL Shader Language)
16:29:10 <Yaniel> yeah
16:29:28 <Earnestly> https://www.opengl.org/registry/doc/glspec41.core.20100725.pdf
16:29:41 <Yaniel> (glsl versions are numbered x.yy and gl versions x.y)
16:29:58 <Yaniel> btu what makes you think 4.00 will get interesting?=
16:30:30 <Earnestly> Iirc it almost requires a rewrite
16:31:02 <Yaniel> let's take it to -blah
16:32:29 <Yaniel> I don't know about mesa internals, care to explain there?
16:33:07 <Earnestly> Ah, sorry, I don't either.  Just read bits and pieces here and there
16:54:25 <omefire> Hi guyz
16:54:30 <kalloc> hi
16:54:57 <omefire> can anyone point to a good tutorial for Applicatives ?
16:55:42 <Fuuzetsu> maybe http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
16:56:45 <hpc> LYAH has what you need
16:57:16 <hpc> there's some problems with that adit.io post
16:58:18 <omefire> @hpc,  thanks
16:58:19 <lambdabot> Unknown command, try @list
16:58:32 <omefire> hpc: thanks for the link
16:58:34 <pavonia> @where typoclassopedia
16:58:34 <lambdabot> I know nothing about typoclassopedia.
16:58:41 <pavonia> @where typeclassopedia
16:58:41 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:58:50 <pavonia> omefire: ^ also that
17:03:50 <josiah14> Is there a way to alias a type in Haskell?  For example, what if I want True == Yes and False == No
17:04:04 <josiah14> just as a simple example for sh**s and giggles
17:05:00 <simpson> josiah14: Not really. What did you want to build?
17:05:21 <simpson> (Note that you're talking about aliasing the *constructors* for the type. You can alias types.)
17:06:47 <josiah14> I'm still at the stage of F***ing around with the language to test it's capabilities
17:07:13 <josiah14> constructor, got it, I wasn't sure what to call it since Bool is the type, right
17:07:20 <amalloy> josiah14: i mean, you can let (Yes,No) = (True,False), defining those values in whatever scope you want
17:07:40 <simpson> Can you do that with the type space?
17:07:49 <simpson> > let Derp = True in Derp
17:07:50 <lambdabot>  Not in scope: data constructor `Derp'Not in scope: data constructor `Derp'
17:07:51 <amalloy> or, i guess you can't because Yes is upper-case? still not sure about haskell naming rules
17:07:53 <bergmark> yes and no would have to be lowercase
17:07:55 <simpson> YEah, that's what I thought.
17:08:20 <josiah14> Yah, unless I could somehow declare Yes and No as constructors?
17:08:41 <simpson> Not of type Bool. You can't amend types after-the-fact.
17:08:59 <simpson> Also you wouldn't be able to alias the constructors to make Yes and True the same constructor.
17:10:33 <enthropy> josiah14: -XPatternSynonyms will do it
17:10:47 <josiah14> I'll google that
17:11:55 <simpson> You should focus on learning the language right now instead of trying to write code from other languages in Haskell.
17:11:56 * hackagebot pipes-aeson 0.2.1 - Encode and decode JSON streams using Aeson and Pipes.  http://hackage.haskell.org/package/pipes-aeson-0.2.1 (RenzoCarbonara)
17:13:50 <josiah14> enthropy: that's kickass.  Glad you knew about that new feature in GHC
17:13:57 <josiah14> Haskell get's better every release
17:14:31 <enthropy> well aliasing True as Yes isn't a good example of where that extension is useful
17:14:56 <enthropy> if that was all it could do, I don't think they would have accepted it in ghc
17:15:30 <josiah14> enthropy: agreed, but I was really just seeing if I 'could' alias constructors
17:16:03 <jrmithdobbs> that pipes-aeson looks nice
17:16:24 <josiah14> simpson: I disagree, the most important part of learning a language is using it.  At first, you use it poorly, with work, eventually you use it elegantly
17:16:48 <jrmithdobbs> i was trying to do something similar with conduit and was having horridly slow results on large files with lots of strings, lets see if it's my approach or aeson! ;p
17:17:28 <simpson> josiah14: Walk before you run; crawl before you walk.
17:17:56 <josiah14> simpson: accepting the fact that my code right now will be bad is crawling
17:18:01 <josiah14> :p
17:18:19 <josiah14> I'm going through the 99 haskell problems right now, having read learn you a haskell
17:19:06 <josiah14> as I was programming the problems, I got to wondering, 'self, I wonder if I could make Yes == True and No == False'
17:19:22 <josiah14> finding nothing on google, I asked here.  Turns out you can
17:21:46 <dmj`> I added a query in acid state, now I'm getting, "This method is required but not available: ..." etc. The error docs say this occurs only when an event has been removed, not added. Also, I didn't think queries were serialized. Any ideas what I'm doing wrong?
17:25:07 <Tehnix> Has anyone tried Angel to run processes? I don't quite know how to start Angel as a daemon, thought someone in here might have toyed with it.. -- http://hackage.haskell.org/package/angel
17:26:48 <dmj`> Tehnix: yea, just create a conf file that executes your script or binary and run angel against it
17:27:03 <dmj`> Tehnix: so ./angel test.conf
17:27:43 <Tehnix> yeah, but it's more to daemonize angel itself, atm that approach means I can't really just leave it (it uses the shell output etc)
17:27:56 <Tehnix> s/to/about how to
17:28:12 <dmj`> Tehnix: yes, if you are using linux I'd recommend looking at upstart
17:28:27 <dmj`> http://upstart.ubuntu.com/cookbook/upstart_cookbook.pdf
17:28:40 <dmj`> it's a daemon to run your daemon :)
17:29:09 <Tehnix> doesn't upstart conflict with other service managers like systemd sysv etc?
17:29:10 <bennofs> or systemd if you don't use ubuntu :p
17:29:46 <Tehnix> hmm, will look into it then, thanks though :)
17:41:59 * hackagebot treeviz 0.0.5 - Visualization of computation decomposition trees.  http://hackage.haskell.org/package/treeviz-0.0.5 (DavidBanas)
17:51:48 <c_wraith> ack, I can never remember this...  arguments are negative position, result is positive position?
17:52:08 <c_wraith> and yes, I'm leaving out the case of passing functions around, I just want the simplest version
17:54:40 <johny`> is concatenating a large number of strings and with ++ inefficient? if I understand lazyiness right it really isn't? we are not iterating through all the elements on each ++, we simply have a thunk that says "continue with this string once you reached here". is this right?
17:55:01 <shachaf> It doesn't have much to do with laziness, really.
17:55:15 <johny`> what then?
17:55:19 <c_wraith> any number of concatenations is really efficient if you don't look at the result
17:55:25 <johny`> is my idea how it works wrong?
17:55:31 <c_wraith> But once you do, laziness no longer matters
17:55:38 <shachaf> Well. If you just look at the first character of (a ++ (b ++ (c ++ d))), none of the b++c++d thing will be evaluated.
17:55:59 <c_wraith> which is why concat is implemented as foldr
17:56:19 <shachaf> If you look at the last character, the whole thing will be evaluated no matter what, of course.
17:56:42 <ParahSailin> Tekmo: what pipes pattern would i use if i had n between 20-100 files, and i wanted to zip them into a stream of n-size arrays, taking byte 0 of all files, byte 1 of all files.. etc
17:57:01 * hackagebot pipes 4.1.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.1.0 (GabrielGonzalez)
17:57:07 <shachaf> And (((a ++ b) ++ c) ++ d) gives you roughly the same sorts of problems that it would in a strict language.
17:57:09 <c_wraith> johny`: here's the model to use, by the way. "when I look for the first constructor in the list, how much work does it need to do?"
17:57:16 <Tekmo> ParahSailin: How large are the individual files?
17:57:45 <johny`> in `"foo" ++ "bar"', if we look at the first three characters it looks like this, no? f : o : o <thunk>, and then if we look at the fourth character, thunk is replaced with 'b', and the rest of "bar" is used as a new thunk.
17:57:46 <c_wraith> johny`: in the case of right-associative concatenations, there's only a single copy needed for each list constructor
17:57:57 <ParahSailin> Tekmo: 200-500kb id say
17:58:07 <c_wraith> johny`: in the case of left-associative concatenations, there's a copy done for each input for the first constructor
17:58:07 <maxiepoo> does anyone here know about modal logic? I'm reading this paper "A Modal Calculus for Effect Handling"(Nanevski) and he keeps referring to box as a comonad, but I don't see how it's a functor
17:58:34 <Tekmo> ParahSailin: You'll want to use `Pipes.ByteString.nextByte`
17:58:48 <shachaf> maxiepoo: I don't know about modal logic, but I think you might have to be careful with what you mean by things here.
17:58:48 <Tekmo> ParahSailin: Its type is:
17:58:57 <maxiepoo> I.e., in modal logic, (A -> B) -> Box A -> Box B is not generally provable since
17:58:59 <c_wraith> johny`: and yes, all those copies are done lazily, but it means it's still doing O(total number of inputs) work to get the first several characters, instead of O(1)
17:59:11 <Tekmo> ParahSailin: nextByte :: Producer ByteString m r -> m (Either r (Word8, Producer ByteString m r))
17:59:13 <shachaf> maxiepoo: By "functor" you mean that you don't have (A -> B) -> (‚ñ°A -> ‚ñ°B), I guess?
17:59:15 <maxiepoo> you need the non-necessary assumption (A -> B)
17:59:22 <Tekmo> ParahSailin: It basically lets you pop off a byte from a `Producer`
17:59:23 <maxiepoo> shachaf, right
17:59:31 <shachaf> Right.
17:59:41 <Tekmo> ParahSailin: Note that you would need to have 20-100 handles open for this
18:00:00 <Tekmo> ParahSailin: You'd have to open all 20-100 handles to those files, and then go down the list of files, popping off a byte from each one at a time
18:00:04 <johny`> c_wraith not sure I quite got your last statement. is it not O(n) in both cases, where n is the number of characters you are takin?
18:00:23 <shachaf> Is this (->) actually the right thing to look at, though?
18:00:41 <c_wraith> johny`: nope.  "foo" ++ "bar" requires O(1) work to get the first character - it creates a single new constructor.
18:01:00 <maxiepoo> shachaf, idk the paper doesn't actually talk about in what sense it is a comonad as far as I can tell
18:01:26 <c_wraith> johny`: same with "foo" ++ ("bar" ++ "baz")..  it only requires copying 1 constructor to get the first character.
18:01:27 <johny`> c_wraith and if we call rest a couple of times, and try to get 'b' in "bar"? what is the complexity then?
18:01:40 <johny`> b in "foo" ++"bar", that is
18:01:58 <shachaf> I think you have to be careful about what the arrows of your category are, or something like that.
18:02:27 <c_wraith> johny`: to get just the 'b'?  still O(1), assuming you've traversed enough of the list for 'b' to be the head of the list.
18:02:28 <johny`> s/rest/tail
18:02:55 <c_wraith> johny`: ah.  Here you have to be careful.  Calling tail doesn't do anything until you evaluate it.
18:03:33 <johny`> if we call ++ a thousand of times, and then after that traversed the list from start till the end, will we only iterate through the combined list once?
18:04:00 <c_wraith> johny`: it depends on how you arrange them.
18:04:07 <johny`> in a strict language we would have to iterate from the beginning on each ++
18:04:18 <c_wraith> no it wouldn't
18:04:23 <c_wraith> not if they were right-associated
18:04:45 <johny`> c_wraith how so? it's a singly linked list, we don't know where to append unless we iterate to the end first
18:04:56 <c_wraith> johny`: it's pure.  You don't append, you copy
18:05:27 <johny`> oh right, forgot about that
18:05:52 <c_wraith> johny`: You make a new list.  You copy all the constructors in the left argument, and the last one points to the right argument, instead of to the empty list
18:06:05 <johny`> yeah, I completely forgot that we are not mutating the list
18:06:48 <johny`> lets say that we have a mutable list, though, am I right that calling ++ would be more efficient in haskell because of lazyness?
18:06:59 <johannesbodannes> arch linux : )
18:07:01 <c_wraith> laziness and mutability really don't mix.
18:07:02 * hackagebot pipes-safe 2.0.2 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.0.2 (GabrielGonzalez)
18:07:04 * hackagebot pipes-parse 3.0.0 - Parsing infrastructure for the pipes ecosystem  http://hackage.haskell.org/package/pipes-parse-3.0.0 (GabrielGonzalez)
18:07:06 * hackagebot pipes-group 1.0.0 - Group streams into substreams  http://hackage.haskell.org/package/pipes-group-1.0.0 (GabrielGonzalez)
18:07:08 * hackagebot pipes-bytestring 2.0.0 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-2.0.0 (GabrielGonzalez)
18:07:15 <johannesbodannes> accommodates my ghc eccentricity
18:07:16 <johny`> c_wraith then how can we have mutable arrays?
18:07:16 <johannesbodannes> finally
18:07:17 <johannesbodannes> i am zen
18:07:37 <x77686d> >ord 5
18:07:40 <maxiepoo> shachaf, the thing is the "comonad operations" (Box A -> A) and (Box A -> (Box (Box A))) are provable
18:07:54 <c_wraith> johny`: by embedding them in IO, which has the effect of removing laziness
18:08:05 <maxiepoo> so I'm wondering if it's just loose terminology
18:08:07 <johny`> hmm
18:08:12 <johannesbodannes> we don't really need mutable arrays though
18:08:24 <c_wraith> occasionally, they're more efficient
18:08:43 <johannesbodannes> sure but, is that really a concern most of the time?
18:08:47 <shachaf> maxiepoo: I think someone mentioned that it wasn't just that, but let me see the paper.
18:08:57 <shachaf> (Maybe #-blah would be better for this -- kind of busy in here.)
18:09:01 <c_wraith> most of the time, no.  Occasionally, it's a huge deal.  So they exist for those few times it's a big deal.
18:10:15 <johny`> o the same thing applies in haskell i guess, when appending characters at the end using : and then reversing the list is more efficient than using ++
18:11:21 <x77686d> ord 5 produces "No instance for (Num Char)..."  It seems to be saying that if Char were in the Num type class the expression would be valid, but that's not so.  What's the reasoning?
18:11:23 <c_wraith> yeah, if you need multiple appends to the end of a list, [a] isn't a good type.
18:11:41 <jmcarthur> it's also worth pointing out that there are a lot of mutation patterns which can be expressed purely functionally anyway, e.g. Data.Vector.accumulate
18:11:42 <johny`> won't it be O(n) if we use : and then reverse?
18:12:23 <c_wraith> johny`: yes.  But it won't be lazy at all.  And it's often worth trying to figure out how to preserve laziness
18:12:30 <jmcarthur> and when you look for them in imperative code it very often ends up that you can express the same algorithm more functionally
18:14:15 <c_wraith> johny`: and there are tricks for repeated appending to the end of a list in a lazy way, which is where the [a] -> [a] encoding comes in
18:15:19 <johny`> I am curious how would that trick work
18:15:57 <jmcarthur> johny`: take a look at the source code for the dlist package
18:16:06 <Tekmo> There are two tricks for this
18:16:35 <Tekmo> Wait, sorry, only one of them is lazy, I think
18:16:57 <jmcarthur> still curious what the tricks were
18:17:03 * hackagebot pipes-http 1.0.0 - HTTP client with pipes interface  http://hackage.haskell.org/package/pipes-http-1.0.0 (GabrielGonzalez)
18:17:24 <Tekmo> Like c_wraith mentioned, you start off with a function of type [a] -> [a]
18:17:24 <joelteon> Is there a library that provides a typeclass like Show, but the output is more human-friendly (indented etc.)?
18:17:26 <Tekmo> Typically `id`
18:17:35 <Tekmo> Then to append to the end you do something like:
18:17:49 <Tekmo> diffAs . (a:)  -- ... where diffAs is your current difference list
18:18:02 <Tekmo> Then to materialize the list at the very end, you just apply the difference list to []
18:18:21 <jmcarthur> what's the strict trick?
18:18:30 <Tekmo> The second trick, which is less efficient (and maybe less lazy?) is to build up the list in reverse and just call `reverse` when you are done
18:18:47 <jmcarthur> yeah, that is indeed strict
18:18:55 <Tekmo> I've benchmarked both tricks and the first one is more efficient
18:19:02 <Tekmo> So I never use the `reverse` trick
18:19:22 <jmcarthur> yeah, it's especially more efficient with all of ghc's inlining and simplifying optimizations
18:20:19 <heatsink> joelteon, Text.PrettyPrint.HughesPJ is a nice pretty-printing library
18:20:40 <heatsink> joelteon, I've seen some packages use a type class Ppr a where ppr :: a -> Doc
18:22:51 <joelteon> that's template haskell?
18:22:52 <c_wraith> Most of the time, I don't actually use the DList package.  If I need laziness and appending to the end, I just use the [a] -> [a] encoding directly in my functions.  It's really not a hassle.
18:23:20 <heatsink> It's not Template Haskell
18:23:48 <Tekmo> I remember shachaf mentioned that church encoding the list gave all the nice properties of DLists
18:24:12 <c_wraith> and all the bad properties of DLists, too
18:24:32 <shachaf> Not all of them.
18:24:35 <Tekmo> But anyway, I use the same approach as c_wraith.  I just manually encode the difference list by hand in my functions
18:24:39 <shachaf> (That's to both Tekmo and c_wraith.)
18:26:02 <jmcarthur> newtype ThingWithDListLikeProperties a = ListThing (forall f. Foldable f => f a)
18:26:27 <shachaf> http://hackage.haskell.org/package/fmlist
18:26:39 <shachaf> That has all sorts of nice properties.
18:26:44 <jmcarthur> yeah, fmlist is basically the slimmed down version of that
18:26:44 <shachaf> roconnor says it doesn't actually exist, though.
18:27:08 <jmcarthur> wait. says what doesn't actually exist?
18:27:23 <shachaf> Hmm, no, roconnor says it doesn't exist when it's infinite.
18:27:32 <shachaf> But those are the nice properties I was thinking about.
18:27:34 <tertl3> functored up
18:27:49 <jmcarthur> shachaf: what doesn't exist when what's infinite?
18:28:47 <shachaf> OK, he says infinite traversals don't exist.
18:28:56 <jmcarthur> ah
18:28:57 <shachaf> Never mind, it wasn't meant very seriously.
18:31:25 <Tekmo> shachaf: This is why I don't like traversals in general
18:31:48 <shachaf> Because roconnor proves things about them in Coq?
18:32:03 <Tekmo> Because they don't stream and won't work on infinite containers
18:32:17 <shachaf> ?
18:32:42 <shachaf> > (repeat ('a','b')) ^.. folded . both
18:32:44 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
18:33:46 <Tekmo> traverse pure [1..]
18:33:49 <Tekmo> > traverse pure [1..]
18:33:50 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
18:33:50 <lambdabot>    arising from a use of `e_11'
18:33:50 <lambdabot>  The type variable `f0' is ambiguous
18:33:50 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:33:50 <lambdabot>  Note: there are several potential instances:
18:33:59 <Tekmo> > traverse pure [(1::Int)..]
18:34:00 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
18:34:01 <lambdabot>    arising from a use of `e_11'
18:34:01 <lambdabot>  The type variable `f0' is ambiguous
18:34:01 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:34:01 <lambdabot>  Note: there are several potential instances:
18:34:07 <shachaf> > runIdentity $ traverse pure [1..]
18:34:07 <Tekmo> > traverse pure [(1::Int)..] :: IO [Int]
18:34:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:34:10 <lambdabot>  <IO [Int]>
18:34:20 <Tekmo> Use `IO` and you'll see what I mean
18:34:47 <shachaf> That's an IO thing, not a Traversal thing.
18:35:00 <Tekmo> No
18:35:07 <Tekmo> You can trigger this with several other monads
18:35:13 <shachaf> Yes.
18:35:20 <shachaf> That's an IO-and-also-other-things thing.
18:35:21 <Tekmo> > traverse Right [(1::Int)..] :: Either String [Int]
18:35:22 <lambdabot>  *Exception: stack overflow
18:35:25 <Tekmo> There you go
18:35:40 <shachaf> Yes. That's exactly the behavior I'd expect here.
18:35:45 <shachaf> This is like costrength.
18:35:57 <Tekmo> Yes, and that's exactly why `traverse` is inadequate for most problems that require working on infinite streams
18:36:03 <jmcarthur> it's because you're using a strict monad
18:36:06 <Tekmo> Or even very long streams
18:36:17 <Tekmo> jmcarthur: You can't just say not to use strict monads.  I use `IO` all the time
18:36:22 <Tekmo> jmcarthur: And `Either`
18:36:30 <Tekmo> jmcarthur: Is there a non-strict `Either` monad?
18:36:37 <jmcarthur> it's not traverse's fault, is all i mean
18:36:44 <shachaf> You're saying "map this function over this list, and tell me whether it returns (Left ...) for any element in the list"
18:36:55 <Tekmo> shachaf: No, I'm not saying that
18:37:08 <Tekmo> shachaf: Here's a simple example
18:37:13 <jmcarthur> you are quite literally saying that, actually
18:37:54 <Tekmo> jmcarthur: Sorry, let me clarify
18:38:01 <carter> Tekmo: oh wait, you're in SF area now right?
18:38:02 <jmcarthur> if you really want more incremental behavior you will have to do something more along the lines of ListT, of course
18:38:03 <Tekmo> jmcarthur: I'm saying that the type ignature I gave is not the ideal one
18:38:21 <Tekmo> jmcarthur: If you approach the problem from the standpoint of "I want an `Either` as my final result" then you are doomed
18:38:24 <Tekmo> carter: Yes
18:38:35 <carter> i'll be in the sf / bay area feb 5-16
18:38:35 <Tekmo> jmcarthur: Right, that's what I'm aiming to say
18:38:42 <Tekmo> jmcarthur: I think `ListT` is the better alternative to `traverse`
18:38:45 <jmcarthur> but i don't think this is a reason to just not like traverse, because it's not traverse's fault. you're just not expressing what you actually want in this case
18:38:52 <Tekmo> jmcarthur: Most problems that `traverse` solves are better solved by `ListT`
18:38:58 <Tekmo> jmcarthur: That's all that I was trying to say
18:39:00 <jmcarthur> woah, no, i very much disagree
18:39:07 <carter> Tekmo: and i *may* have have an actually use of Free monads for HPC :)
18:39:11 <carter> mebe
18:39:18 <Tekmo> carter: How?
18:39:28 <jmcarthur> i don't see how ListT is even reasonable for most of the things i use traverse for
18:39:36 <Tekmo> jmcarthur: Let me clarify
18:39:37 <jmcarthur> they are totally different things
18:39:41 <Tekmo> jmcarthur: Traverse when specialized to lists
18:39:47 <Tekmo> jmcarthur: I should have specified that
18:39:52 <jmcarthur> it still depends on the monad
18:40:00 <jmcarthur> s/monad/applicative/
18:40:01 <carter> Tekmo: still figuring out the details, but has to do with enumeration orders for locality aware code
18:40:15 <Tekmo> jmcarthur: Okay, traverse, specialized to lists and on monads other than `Identity` and the lazy `State` monad
18:41:14 <Tekmo> Note that I'm fine with `traversed` applied to things like `Maybe` and `Either`
18:41:20 <carter> and abusing the list monad to get DPH style math
18:41:24 <carter> not sure if it'll work
18:41:24 <Tekmo> I think that's a legitimate use of the type
18:42:14 <shachaf> "give me a summary of this entire thing" is a reasonable thing to be asking.
18:42:18 <Tekmo> carter: This reminds me (a tiny bit) of an example somebody told me here on IRC where he used a free monad to build up a decision tree
18:42:25 <carter> close
18:42:43 <carter> basically its a list of computations that you can either break up more, or work directly on
18:42:51 <carter> and doing that in a nested way in a particular order
18:43:23 <carter> which also lets you queue the work in a work stealing userland schedule
18:43:57 <carter> also fits nicely with my goal of wanting to support het compute
18:45:08 <Tekmo> What is het compute?
18:45:18 <carter> heterogenuous
18:45:33 <carter> I want to be able to split work across cpu and gpu, and split across a cluster too
18:45:37 <carter> and make it zero pain
18:45:44 <Tekmo> So you basically build up a description of the task and some sort of "scheduler" then decides how to split up the computation and to what granularity level?
18:45:59 <carter> not quite
18:46:06 <carter> though it may turn into that
18:46:11 <carter> but forcing myself to punt on that for now
18:46:13 <Tekmo> This reminds me a bit of accelerate
18:46:24 <carter> eh
18:46:26 <carter> yes / no
18:46:45 <carter> accelerate is strictly less expressive than repa
18:46:46 <Tekmo> Well, at least in the way that they build up a computation representation and then manipulate that before actually converting it to GPU code
18:46:51 <carter> erm
18:46:54 <carter> thats actually a different thing
18:47:04 <carter> i'm talking about nested parallelism recursion
18:47:15 <carter> nested computation is a no no there
18:47:21 <carter> i
18:47:28 <carter> i'm not talking about an AST of computation
18:47:41 <carter> i'm talking about recurring on the datatums into nested sub problems
18:48:02 <carter> which is inexpressible with sane perf in the land of acclerate / repa
18:48:08 <carter> like, the anti pattern there
18:48:10 <mvc`> hey, I was just wondering if anyone had any ideas for a graphics tool chain in haskell
18:48:35 <carter> mvc`: opengl or diagrams or gloss
18:48:37 <carter> whats the use case?
18:49:06 <Tekmo> carter: Maybe it would help if you just linked me to a rough sketch of the data type
18:49:09 <mvc`> carter: its for a graphics class. Ideally it'd do 3-d (which I think rules out diagrams and gloss)
18:49:15 <carter> opengl!
18:49:22 <carter> Tekmo: this is a really really new idea of ime
18:49:24 <carter> *mine
18:49:31 <carter> i may do a strawman hack in the next few days though
18:49:35 <carter> like, only had it on friday
18:49:53 <Tekmo> It's okay
18:49:55 <carter> "HPC performance via list comprehensions"
18:49:58 <Tekmo> I won't judge you :)
18:50:01 <carter> soke
18:50:06 <mvc`> carter: what would you recommend for manipulating coordinates in a functional way
18:50:06 <carter> i also don't have teh code yet
18:50:13 <carter> mvc`: linear
18:50:26 <mvc`> carter: ok, I'll check that out
18:50:33 <Tekmo> carter: Is it specialized to matrix computations or is it more general?
18:50:34 <carter> mvc`: also ask on #haskell-game
18:50:42 <mvc`> good call
18:51:05 <bergey> mvc`: 3D Diagrams are coming, but probably not soon enough for your class. :/
18:51:07 <carter> mvc`: also ask jmcarthur (on #haskell-games)
18:51:25 <carter> Tekmo: it could work for rank N arrays too i guess
18:51:33 <mvc`> bergey: does Diagrams do animations?
18:52:37 <bergey> Diagrams does do animations.  There are a bunch of animated GIF examples kicking around.  I haven't made any myself.
18:53:11 <bergey> Actually, the animated GIF code may only be in HEAD so far.
18:53:25 <carter> which is exciting!
18:53:31 <carter> Tekmo: DPH has to do backflips to get decent locality
18:53:44 <shachaf> Someone named "bergey" talking about diagrams? This is too confusing.
18:53:56 <Tekmo> carter: So do you divide up the computation into groups that preserve locality?
18:54:01 <mvc`> bergey: neat, I was actually thinking about looking into diagram for a dot/inkscape replacment
18:54:02 <carter> yes
18:54:13 <carter> Tekmo: thats kinda all i've been talking about for eons
18:54:28 <carter> :)
18:54:31 <bergey> shachaf: Yes, I know.  But it's been my name for years. :)
18:54:32 <Tekmo> carter: So is this representation just a first-class way of manipulating locality?
18:54:35 <monochrom> hahaha shachaf
18:55:05 <carter> Tekmo: more like a first class way of writing array computations that should have decent perf but look like math
18:55:21 <carter> i've some more nuts and bolts stuff i'm focusing on first before i dig into this idea
18:55:25 * monochrom creates the extra persona byargey, byirgey, byurgey...
18:56:39 <johny`> given a path how do I get directory name?
18:57:06 <carter> johny`: which docs have you looked at yet?
18:57:23 <johny`> import System.FilePath
18:57:27 <Tekmo> johny`: Is it a full path?
18:57:29 <johny`> without import :)
18:57:44 <carter> what abou the unix package?
18:57:50 <carter> or the System.Directory
18:57:54 <johny`> yes. basically I am trying to find a function that will return "directory" given both "/directory" and "/directory/"
18:57:57 <Tekmo> johny`: You can split it into '/' delimited groups and drop the last one
18:59:39 <carter> Tekmo: i've a more nitty gritty locality approach that may turn into the internals for this more high level idea
18:59:48 <johny`> using a string function? :/
19:00:22 <Tekmo> carter: But does it have to be a free monad?
19:00:33 <Tekmo> carter: What I mean is that this sounds like it should be a different kind of free object
19:00:40 <carter> yeah, you're right
19:00:42 <carter> monads suck
19:00:47 <carter> its probablynot a monad
19:00:48 <carter> well
19:00:50 <carter> hrmm
19:00:58 <Tekmo> carter: Maybe a free semiring
19:00:59 <carter> Tekmo: the overall thing isn't
19:01:20 <carter> but the scheduler hack is a free something something
19:01:29 <johny`> should read better, I found it. splitFileName
19:01:30 <Tekmo> carter: Yeah
19:01:57 <carter> any "deep embedding" should be an "enrichment" of the "free embeddding"
19:02:08 <carter> that is, certain backends may have their own specific funcctionality
19:02:32 <carter> and the free embedding should be a subset of every deep embedding
19:02:45 <johny`> > last $ splitPath "/tmp/foo/"
19:02:45 <lambdabot>  Not in scope: `splitPath'
19:02:46 <lambdabot>  Perhaps you meant one of these:
19:02:46 <lambdabot>    `BS.splitWith' (imported from Data.ByteString),
19:02:46 <lambdabot>    `BSL.splitWith' (imported from Data.ByteString.Lazy),
19:02:46 <lambdabot>    `BSLC.splitWith' (imported from Data.ByteString.Lazy.Char8)
19:03:04 <carter> Tekmo: bascally thers a lot of structure
19:03:15 <carter> but i may lie and ignore it for usability until i pin the theory down
19:03:32 <johny`> that gives me "foo/", and I want "foo". is it time to resort to string functions?
19:04:16 <johny`> I would rather not, but it looks like I will have to
19:04:34 <carter> johny`: theres many libs
19:04:35 <carter> manyyyy
19:04:42 <carter> i'm sure one has a function just for you :)
19:05:34 <enthropy> > dropTrailingPathSeparator "foo/"
19:05:35 <lambdabot>  Not in scope: `dropTrailingPathSeparator'
19:05:47 <enthropy> > System.FilePath.dropTrailingPathSeparator "foo/"
19:05:48 <lambdabot>  Not in scope: `System.FilePath.dropTrailingPathSeparator'
19:05:52 <johny`> nice
19:06:48 <johny`> carter when you have to resort to generic string functions to manipulate file paths it's usually an indication that the file path library is lacking.. I am glad this isn't the case
19:07:26 <carter> johny`: generally when the standard tools are wrong, haskell folks are happy to have a 1-2 deprecation breaking change cycle to have nice things
19:08:47 <enthropy> I think the only alternative to filepath/directory is this one http://hackage.haskell.org/package/system-filepath
19:09:09 <enthropy> which makes it harder to use list functions
19:09:11 <carter> enthropy: theres also the stuff in neil mitchell's shake
19:09:12 <carter> right?
19:10:32 <enthropy> hmm, the bits in shake pretty much re-export System.FilePath
19:10:48 <carter> oh ok
19:10:50 <carter> i know nothing
19:12:05 <monochrom> "when you realize that you know nothing, you can get a Master degree" :)
19:12:28 <carter> monochrom: i didn't stay for the masters, was too shitty a place, copumpkin  would agree
19:12:34 <monochrom> the one before that is "when you think you know everything, you can get a Bachelor degree"
19:12:48 <carter> i'm at the "i wonder if i'm wrong, i hope i'm wrong"
19:12:48 <carter> phase
19:13:02 <monochrom> and the one after: "when you also realize that your supervisor knows nothing, you can get a PhD"
19:13:20 <monochrom> all 3 sentences have been true for me :)
19:14:06 <heatsink> Why do you want to recursively decompose work, carter?  The C way is to tile loops for each level of the memory hierarchy.  That gives you a fixed-depth block decomposition of data, which doesn't require recursion.
19:14:11 <nicoo> a/wg #k	
19:14:19 <carter> heatsink: exactly!
19:14:37 <carter> i just wanna do a 3 level thing using list comprehnsions to troll people :)
19:15:02 <carter> just written in a way that people dont expect
19:15:07 <carter> to hammer home "LOCALITY"
19:15:08 <carter> :)
19:15:25 <heatsink> hmmmmm
19:15:27 <heatsink> okay
19:16:08 <carter> also makes it easier to emphasize how the tiling thing is kinda an atternating innner / outer product
19:17:13 <heatsink> I don't understand
19:17:17 <carter> ok
19:17:22 <carter> lemme get a piture
19:17:24 <carter> *picture
19:18:41 <johny`> if String is only for toy programs why do all the functions in System.FilePath and System.Directory work with Strings?
19:18:49 <johny`> and none with Text
19:19:17 <carter> heatsink: http://imgur.com/uqrUhEY
19:19:47 <carter> heatsink: a blocked outter product over a blocked inner product
19:20:23 <triliyn> johny`: because those modules are very old and updating very old standards is hard
19:20:31 <carter> thats the BLIS alg structure
19:20:34 <heatsink> Is it a picture of matrix multiplication?
19:20:37 <carter> yes
19:20:58 <carter> well GEMM to be precise
19:20:59 <carter> but yeah
19:21:32 <heatsink> The microkernel has the structure of (map inner_product) . outer_product
19:22:20 <johny`> trilyn they are from year 2007. is that so old?
19:22:39 <carter> yes, you break it down into out producty bits, and within them you compute inner products style
19:23:14 <johny`> Data.Text seems to be from year 2008, though.. I thought it was much older
19:23:36 <enthropy> maybe you're thinking it's as old as bytestring?
19:23:44 <enthropy> or maybe packed string
19:23:51 <carter> woah thats retro
19:24:02 <heatsink> Okay.  Then it's the same traversal pattern over blocks at the outer level of the algorithm?
19:24:10 <carter> which is?
19:24:24 <johny`> I have no idea what a packed string is, and bytestring sucks for strings
19:24:52 <carter> well
19:24:59 <carter> the products over the blocks are a matrix mult
19:25:02 <carter> so i'm saying
19:25:14 <carter> organize the work in blocked outer prdocuts on the top level
19:25:28 <carter> then for your block product, on the inside,  do a blocked inner product
19:26:06 <carter> heatsink: so... yes?
19:27:14 <heatsink> I don't follow, but it seems close enough to loop tiling that I can believe there's a way to write it.
19:27:45 <carter> it is a tiling
19:27:47 <carter> with loops
19:27:48 <carter> i agree
19:28:00 <carter> and its ~ 2 levels of tiles in that picture
19:28:12 <carter> *loop tiling
19:28:12 <heatsink> okay
19:28:18 <carter> what i'm saying is
19:28:19 <flebron> Haskell's typesystem (without extensions) is sound, right? What's an example of it being incomplete?
19:28:27 <carter> flebron: define terms please ;)
19:28:30 <carter> its very very unsound
19:28:32 <johny`> is Data.Text only 6 years old? everyone just used String before that if they wanted unicode?
19:28:32 <carter> and thus complete!
19:28:41 <carter> johny`: they just cried :)
19:28:46 <carter> heatsink: so what i was saying before
19:29:02 <carter> is that i see a path to generating that tiling in a cheap way
19:29:06 <BMeph_> Is "Sequence Char" an instance of IsString? More importantly, should it be (FSVO "should")?
19:29:15 <carter> "semi implicitily"
19:29:25 <carter> BMeph_: scary questions
19:29:26 <carter> :)
19:29:30 <flebron> carter: Why is it unsound? Because of bottom?
19:29:38 <carter> unsafeCoerce :)
19:30:03 <carter> unsafeCoerce is actually very very handy if you're very very very careful
19:30:45 <flebron> Say we removed that, and we removed all unsafe things, is it now sound?
19:31:06 <carter> by definition
19:31:09 <flebron> (i.e. we nuke the Unsafe namespace and unsafePerformIO and all its ilk.)
19:31:10 <carter> if only safe ops are allowed
19:31:15 <carter> :)
19:31:28 <carter> flebron: lets zoom out
19:31:37 <carter> and consider whats provable in sound idris/agda/coq
19:31:43 <johny`> he did say "without extensions", though, unsafeCoerce is part of ghc, but not part of haskell standard, no?
19:31:45 <flebron> I think what I should first define what it means to be "sound".
19:31:59 <heatsink> carter: on vectors or multidimensional arrays?
19:32:08 <carter> both?
19:32:11 <carter> rank n arrays
19:32:12 <flebron> In terms of formal logic, that means if \Gamma |- P, then \Gamma |= P.
19:32:21 <carter> 2d and 1dim being the normative case
19:32:33 <flebron> I suppose \Gamma here would be the system F Haskell uses in its Core?
19:32:39 <carter> but tooling to support the fools who want 30dim to add support
19:32:50 <flebron> And P would be all types. |- would be "compiles". I'm not sure what |= would be.
19:33:00 <flebron> P would be *any type.
19:33:09 <carter> flebron: coq / agda/ idris are probably sound AND complete
19:33:23 <carter> being able to define inductive famlies is like having an open axiom set
19:33:55 <flebron> But if they are sound and complete as formal systems, and they can model arithmetic, doesn't that fall afoul of G√∂del?
19:34:00 <carter> nope
19:34:17 <carter> theres a good book on G√∂del fallacies
19:34:18 <carter> somewhere
19:34:20 <carter> on amazone
19:34:49 <heatsink> carter: I would like to see how you do it, sometime.  Depending on how expressive the interface is, there are some difficult cases to deal with.
19:34:57 <carter> yesss
19:35:02 <carter> which tricky bits are you thinking of?
19:35:17 <carter> heatsink: as i have free time i'm whacking on it
19:36:39 <heatsink> You've got logical restructuring of data, such as slicing and transposition, which makes it difficult to figure out what loop nesting to use
19:37:12 * hackagebot pipes-concurrency 2.0.2 - Concurrency for the pipes ecosystem  http://hackage.haskell.org/package/pipes-concurrency-2.0.2 (GabrielGonzalez)
19:37:23 <carter> ohhhh
19:37:24 <carter> :)
19:37:47 <carter> heatsink: depends on the sort of slicing you do
19:39:17 <carter> heatsink: sooo, that has to do, in part with
19:39:26 <carter> "how do slices impact contiguity of data"
19:40:18 <carter> and how do tranposes change which operations preserve array contiguity
19:40:40 <nstdloop> I'm trying to make a binary tree that I made a Functor instance, but I'm hitting a slight roadblock. I've defined a treeMap function that has a signature of: treeMap :: (Ord a, Ord b) => (a -> b) -> Tree a -> Tree b, but fmap has a signature of: fmap :: (Functor f) => (a -> b) -> f a -> fb. The problem is that when I try to say in the instance declaration that fmap = treeMap I have type problems! I'd rather not
19:40:40 <nstdloop> make the type signature of treeMap more lenient because then you can accidentally move a Tree into a non-Ord type using fmap. Thoughts?
19:40:46 <carter> and then i think it becomes "how much should i try to recover contiguity internally with a paneled copy, OR should i choose a better format to gbeing with"
19:42:47 <amalloy> nstdloop: i don't think it can be a functor if you need to impose additional constraints on a or b
19:43:00 <heatsink> There's reordering the data, reordering the loops, and loop fusion/fission choices involved
19:43:20 <carter> yup
19:43:26 <carter> i'm not claiming to solve that
19:43:34 <carter> at least for now
19:43:44 <carter> just trying to figure out tools and vocab to make it more explicit
19:44:00 <heatsink> Okay
19:45:13 <carter> because half the challenge with understanding the code thats GOOD right now
19:45:20 <carter> is reverse engineering their vocabl and approach
19:45:22 <nstdloop> amalloy: Do you think I should just make treeMap not have the Ord constraints? Is it worth the possible lack of safety?
19:45:35 <heatsink> That's true
19:46:11 <heatsink> I don't know of a way to write highly optimized loops that also makes the optimization choices clear
19:46:32 <amalloy> i would expect the right answer to be: don't define a Functor instance for your Tree, because it can't act like a functor
19:46:39 <carter> well, the cost model will always be semi implicity
19:46:44 <carter> but you can make teh manipualtions clear
19:50:10 <carter> heatsink: but yeah
19:50:13 <heatsink> I've read a bit of Fortran code.  A lot of the code-reading time was figuring out how to map loop counters and array index expressions on to the algorithm.
19:50:13 <carter> theres no one true thing
19:50:21 <carter> yes
19:51:00 <carter> and i think part of how to do that nicely, is to make it easier to write block oriented / tile oriented code
19:51:04 <carter> i may be wrong
19:51:07 <carter> idk anymore :)
19:52:21 <heatsink> From what you're saying, I'm envisioning a collection of components for building loops, with simple loop fusion
19:52:35 <carter> thats something that could definitely happen
19:52:42 <carter> i'm thinking of it more as block / tile recursion
19:52:56 <carter> with good vocab to support it in both mutable and functional styles
19:53:29 <carter> basically "what happens if i have a multi dimensional version of Vector, with multiple formats/layouts supported"
19:53:43 <carter> 'cause fusion alone wont save the day
19:53:45 <carter> you have locality too
19:54:01 <carter> also just making the connectionb etween the different algorithm styles clearer I hope helps
19:54:10 <carter> heatsink: lets switch to #numerical-haskell? :)
19:54:23 <heatsink> that channel exists?
19:54:36 <carter> yup :)
19:54:40 <carter> blame me :)
19:54:44 <heatsink> ok
19:57:55 <japesinator> Anyone here use haskell-mode for vim?
19:58:17 <eflister> is there a named algebraic structure for the type a that has an f: a -> b -> a that always eventually leads to some fixed point a'  ?
19:58:32 <AshyIsMe> japesinator: i might be
19:58:43 <quintus> japesinator: I didn't even know such a thing existed. I'm installing it now.
19:58:49 <japesinator> I'm getting a weird error
19:58:53 <japesinator> http://pastebin.com/hFzy2DU2
19:59:25 <AshyIsMe> nope, looks like ive got it turned off:
19:59:33 <AshyIsMe> Bundle 'Superior-Haskell-Interaction-Mode-SHIM' 1 "Bundle 'laurilehmijoki/haskellmode-vim' 2 Bundle 'dag/vim2hs' 3 Bundle 'Conque-Shell' 4 Bundle 'jtratner/vim-flavored-markdown' 5 Bundle 'airblade/vim-gitgutter' 6 "Bundle 'itchyny/calendar.vim' 7 Bundle 'eagletmt/ghcmod-vim'
20:01:10 <quintus> japesinator: have you set g:haddock_browser to your web browser?
20:01:37 <quintus> japesinator: if you're on a mac, "open" will suffice according to http://projects.haskell.org/haskellmode-vim/
20:01:57 <japesinator> Oh, alright
20:03:27 <shachaf> eflister: What's b? And what do you mean?
20:03:30 <quintus> japesinator: if you're on a mac, try the instructions here: http://ur1.ca/gjom8
20:04:24 <shachaf> quintus: Is the URL shortener necessary?
20:04:35 <shachaf> It makes it hard to see where the link will go.
20:04:44 <quintus> My apologies. http://splonderzoek.blogspot.com/2009/04/haskell-mode-for-vim-on-mac.html
20:04:54 <benzrf> @hoogle Prism' s a -> s -> Bool
20:04:54 <lambdabot> Warning: Unknown type Prism'
20:04:55 <lambdabot> Data.Graph.Inductive.Graph gelem :: Graph gr => Node -> gr a b -> Bool
20:04:55 <lambdabot> Data.Graph.Inductive.Graph ufold :: Graph gr => ((Context a b) -> c -> c) -> c -> gr a b -> c
20:05:00 <quintus> shachaf: I forgot I had a script in my irssi
20:05:06 <benzrf> @hoogle Prism s t a b -> s -> Bool
20:05:06 <lambdabot> Warning: Unknown type Prism
20:05:06 <lambdabot> No results found
20:05:11 <benzrf> fie
20:05:35 <shachaf> It's has.
20:05:57 <levi> Grr. I really want to like structured-haskell-mode, but the paren-handling keeps biting me.
20:07:27 <japesinator> Now I'm getting "hdevtools is not executable" and "ghc-mod is not executable"
20:07:37 <jfischoff>  levi: what does it do?
20:07:44 <eflister> shachaf: the idea is "repeatedly do the same kind of thing until there's nothing more to do."  my example is hangman: keep guessing characters until the puzzle is solved.  so game -> char -> game eventually leads to game==Solved.  it's almost dual to MonadPlus i was thinking...
20:08:36 <shachaf> So what has a fixed point here?
20:08:57 <eflister> shachaf the game type (Solved is fixed under f)
20:09:00 <japesinator> oh, I just needed to cabal install those
20:09:21 <jrmithdobbs> Tekmo: pipes-aeson is yours isnt it? you have some actual example uses somewhere
20:09:28 <shachaf> Maybe I don't understand what you mean by fixed point.
20:10:14 <shachaf> The meaning I'm thinking of: "x is a fixed point of f" means "f x = x"
20:10:28 <eflister> shachaf: isn't that just what holds here?
20:10:31 <shachaf> What's f?
20:10:48 <benzrf> :t either
20:10:49 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
20:10:59 <eflister> shachaf: f is the action of making a char guess
20:11:28 <shachaf> OK, can we flip your function? guess :: Char -> Game -> Game
20:11:38 <eflister> shachaf: sure of course
20:11:52 <shachaf> (What's a game? I'm not quite sure.)
20:12:08 <shachaf> Are you saying that (guess 'q') has a fixed point?
20:12:15 <joelteon> Oh
20:12:16 * hackagebot tasty-integrate 0.0.1 - automated integration of QuickCheck properties into tasty suites  http://hackage.haskell.org/package/tasty-integrate-0.0.1 (jfeltz)
20:12:20 <jfeltz> there we go
20:12:50 <levi> jfischoff: Well, it tries to keep matching pairs of parens at all times. So hitting open-paren gives you a pair of them. And there's a command for wrapping things in parens, but it's not working with my manually-selected region, only the shm-region-thing that doesn't want to exactly match the code I want to wrap with parens.
20:12:55 <eflister> shachaf: no, the type game has a fixed point, the value Solved
20:13:12 <shachaf> What does it mean for a type to have a fixed point? What is Solved?
20:13:20 <levi> jfischoff: Some of this behavior may be fixed since my last upgrade... I'm going to try upgrading again.
20:13:21 * jfischoff nods
20:13:34 <benzrf> hey
20:14:01 <benzrf> Lens' s a means a lens that focuses on type s and points to a part of type a
20:14:06 <benzrf> what does Lens s t a b mea?
20:14:07 <benzrf> *mean
20:14:31 <eflister> shachaf: Solved is a value in Game, i guess i mean a type has a fixed point x (under some f) when forall f (f x = x)
20:14:42 <shachaf> > set _2 "hi" (False,True)
20:14:44 <lambdabot>  (False,"hi")
20:14:47 <edwardk> Lens s t a b says that you can look inside 's' and get an 'a', that if you replace with a 'b', you'll get a 't'
20:14:59 <shachaf> Think of the type of set _2 there.
20:15:05 <edwardk> if you dn't change the types of anything when a ~ b,    s ~ t.
20:15:08 <Axman6> so Lens [a] [b] a b
20:15:13 <Axman6> for example
20:15:15 <jfischoff> edwardk: lens tip!
20:15:28 <edwardk> jfischoff: i think you have a new account to make
20:15:36 <benzrf> edwardk: ah
20:15:44 <jfischoff> actually it already exists
20:15:59 <benzrf> edwardk: oh you are ekmett?
20:16:03 <edwardk> yeah
20:16:07 <benzrf> O:
20:16:15 <benzrf> lenses are cool
20:16:20 <jfischoff> not sure is running it though
20:16:21 <benzrf> thx for making lens
20:16:33 <jfischoff> s/is/who is
20:16:38 <edwardk> it may be ocharles
20:16:48 <edwardk> benzrf: i'm rather fond of them ;)
20:16:58 <jfischoff> ah
20:17:30 <jfischoff> have you seen @evilhaskelltips?
20:17:47 <edwardk> ahahahaha
20:17:48 <edwardk> nope
20:18:13 <jfischoff> :)
20:18:33 <edwardk> waiting for evillenstips
20:18:42 <jfischoff> ha
20:18:56 <edwardk> advising the use of singular, unsafePartsOf, upon...
20:19:18 <jfischoff> first tip: always use lens, its like jquery
20:19:40 <benzrf> jquery is like the js stdlib that should be
20:19:49 <eflister> shachaf: i see i'm kind of abusing terms, i don't really know what i'm doing. but it seemed like a common pattern to me: do the same kind of action repeatedly until there's nothing more to do.  i was hoping there would be a pre-existing class to use that had a function (something like untilM) to do the recursion...
20:19:53 <Axman6> "Remember, lens is just functions so there's no overhead"
20:19:54 <jfischoff> better: whatever your problem is the answer is lens
20:20:01 <benzrf> Axman6: huehuehue
20:20:16 <edwardk> @EvilLensTip: Always use lens, even when you don't have to, to better demonstrate your superiority over others.
20:20:16 <lambdabot> Unknown command, try @list
20:20:29 <jfischoff> :)
20:20:56 <benzrf> so edwardk
20:21:02 <benzrf> is there something like isn't but the other way around
20:21:09 <edwardk> has
20:21:12 <edwardk> there is has and hasn't
20:21:22 <edwardk> is is also in Control.Lens.Extras
20:21:25 <benzrf> oh
20:21:28 <edwardk> but i wasn't willing to take that name by default
20:21:43 <edwardk> > M.fromList [(1,"hello")] & has (ix 1)
20:21:45 <lambdabot>  True
20:21:52 <benzrf> > _Left `has` (Right 3)
20:21:54 <lambdabot>  False
20:21:57 <benzrf> > _Left `has` (Left 3)
20:21:58 <lambdabot>  True
20:22:01 <benzrf> oh good
20:22:01 <edwardk> > has (ix 20) "hello"
20:22:03 <lambdabot>  False
20:22:05 <shachaf> eflister: I don't really know what you're getting at, though.
20:22:08 <benzrf> isn't == hasn't?
20:22:12 <edwardk> yeah
20:22:14 <benzrf> ok
20:22:17 <edwardk> isn't is type restricted hasn't
20:22:22 <edwardk> because it reads better for prisms
20:22:27 <shachaf> eflister: Presumably you have to try every character before you're done.
20:22:33 <edwardk> Either a b  either is _Left or it isn't
20:22:34 <benzrf> mm
20:22:45 <edwardk> but a Map either _has_ ix 2 or it hasn't
20:22:55 <benzrf> im redoing my cruddy lisp impl with lenses and mt's
20:22:56 <benzrf> :-D
20:23:09 <benzrf> maybe mt's anyway
20:23:16 <benzrf> we'll see o-o
20:23:19 <eflister> shachaf: unless you're done already :)
20:23:43 <shachaf> eflister: And if I remember how the game works correctly, guessing a character twice doesn't do you any good (guessing is "idempotent").
20:24:04 <shachaf> So here you have to know lots of things about the type Char in order to do this.
20:24:06 <eflister> shachaf: aren't there a lot of processes with that structure?  "do the same kind of thing over and over until you are at some magic value"?  this is trying to model idempotency of a kind...
20:24:10 <shachaf> In particular you have to be able to enumerate it.
20:24:35 <eflister> shachaf: but if there were some value like mzero that you can test to see if you are at, you know you're done, otherwise try another action.
20:24:47 <shachaf> I'm not really sure what you're getting at.
20:25:43 <randomclown> is there a specalised `all` that checks if the whole list is true?
20:25:55 <randomclown> whole list only has [True, True, ...]
20:25:56 <eflister> shachaf: it's kind of dual to MonadPlus -- a magic value and a kind of operation.  the importantness of the magic value is that it is a fixed point.
20:26:19 <thirsteh> any switch to get criterion to output one benchmark result per line (human-readable)?
20:26:20 <shachaf> What does it mean for a value to have a fixed point?
20:26:31 <shachaf> Er, sorry. You said it "is" a fixed point.
20:26:40 <shachaf> Every value is a fixed point of id.
20:27:35 <benzrf> :t all
20:27:36 <lambdabot> (a -> Bool) -> [a] -> Bool
20:27:43 <benzrf> randomclown: all id?
20:27:53 <shachaf> @src all
20:27:53 <lambdabot> all p =  and . map p
20:27:54 <benzrf> :t and
20:27:55 <lambdabot> [Bool] -> Bool
20:28:36 <eflister> shachaf: "apply f :: m a -> m a until a == Fixed"
20:29:38 <randomclown> and it is
20:29:49 <eflister> shachaf: like "work through items in this collection until it's empty"
20:34:30 <structuralist> what are some cool things you can do with constraint kinds?
20:37:34 <enthropy> @hackage exists
20:37:34 <lambdabot> http://hackage.haskell.org/package/exists
20:45:23 <randomclown> is there a way to make ghci ignore scope?
20:52:03 <benzrf> hmm
20:52:13 <benzrf> given a StateT around an Either
20:52:25 <benzrf> will it continue running the State if I return a Left?
20:52:41 <benzrf> it wouldnt would it
20:53:14 <simpson> @unmtl StateT s (Either e) a
20:53:14 <lambdabot> s -> (Either e) (a, s)
20:53:30 <benzrf> oh
20:53:32 <benzrf> derp
20:54:33 <simpson> unmtl doesn't know about EitherT, but that would look like...
20:54:44 <benzrf> i was accidentally generalizing the way Reader works to State
20:54:47 <benzrf> blugh
20:55:06 <simpson> s -> (Either e a, s)
21:07:25 <thirsteh> what kind of synchronization is necessary if two threads share an MVector?
21:07:48 <thirsteh> I assume it's not thread-safe?
21:08:00 <Axman6> no
21:08:07 <Axman6> I'd probably wrap it in an MVar
21:08:29 <thirsteh> thanks
21:12:16 <jfischoff> what is the difference between ReadPrec and ReadP
21:13:03 <Axman6> Hmmm, I seem to remember the former having something to do with either precedence or parentheses
21:13:38 <jfischoff> them seem to fairly equivalent
21:13:43 <jfischoff> on first blush
21:13:56 <benzrf> @src undefined
21:13:57 <lambdabot> undefined =  error "Prelude.undefined"
21:14:00 <benzrf> righ
21:14:02 <benzrf> t
21:14:09 <benzrf> @src error
21:14:09 <lambdabot> error s = throw (ErrorCall s)
21:14:15 <benzrf> @src throw
21:14:15 <lambdabot> throw exception = raise# exception
21:14:38 <in_the_mist> Someone should translate GLM (OpenGL Mathematics) into Haskell. There's really no easy way to use matrices with OpenGL at the moment.
21:15:22 <Axman6> go for it!
21:16:22 <in_the_mist> I think I might have to...
21:17:17 <in_the_mist> It would be cool if glm was actually open source...
21:17:27 <BMeph> The Danger of Haskell: Any time you declare that "someone" should do something, you may wind up wishing you had said "someone ELSE"... ;)
21:18:24 <thirsteh> I just want to make sure I understand the memory model correctly. If I have an MVar Foo, and the Foo data type has some MVector record fields, then, as long as I make take the MVar then mutate the MVectors, and put back the value, there is no chance of a data race? What happens if I use modifyMVar and my code throws an exception?
21:19:32 <Axman6> perhaps you want STM
21:19:35 <thirsteh> (it feels like I should probably just keep using immutable vectors.. although I really have to modify the vector repeatedly.)
21:20:42 <thirsteh> Axman6: you can't use an MVector in the STM monad, right?
21:20:50 <thirsteh> because of that very issue
21:21:05 <thirsteh> there is no guarantee it can safely rollback the transaction if I'm messing with a mutable vector
21:21:14 <Axman6> no, but there should be STM vectors of some type... I hope
21:21:33 <thirsteh> oh, looks like there's a TArray
21:21:33 <Axman6> I mean, you could use Array of (STRef a)
21:23:48 <thirsteh> Axman6: thanks, I'll think about it
21:23:56 <CaptainLex> This may be a long shot, but does anyone know why Arch ARM's repos dropped GHC for ARM6?
21:23:58 <jfischoff> there is a lot of overhead there
21:24:45 <thirsteh> jfischoff, Axman6: Yeah, it kinda defeats the purpose of using the MVector in the first place. If it wasn't for the fact that my whole use case is updating and reading some index, I'd just use a Sequence or Vector
21:25:34 <Axman6> there's definityely ways to do it. how much are you modifying each time you work on the MVector?
21:25:50 <jfischoff> thirsteh: use bracket to deal with exceptions
21:26:23 <jfischoff> thirsteh: have you read this book? http://chimera.labs.oreilly.com/books/1230000000929
21:26:23 <Axman6> you could always have data Foo = Foo (MVar ()) (MVector Bar) and just make sure that your functions always take the MVar
21:26:36 <benzrf> @unmtl StateT Env (Either String) LispVal
21:26:36 <lambdabot> Env -> (Either String) (LispVal, Env)
21:26:43 <benzrf> huh
21:26:55 <benzrf> ah i see the prob
21:26:57 <thirsteh> Axman6: Almost every time. Although that's because I'm updating the Bar value that it's storing. I could make it a Vector IORef Bar, then it'd be rarer...
21:27:13 <Axman6> oryou could have withFoo :: Foo -> (MVector Bar -> IO a) -> IO (Maybe a) and catch exceptions, and ensure you're going to take and put the MVar even when exceptions are thrown
21:28:04 <thirsteh> jfischoff: Yes, actually. My question is what happens if I use modifyMVar (which of course puts back the contents) and the MVar protects an MVector
21:28:08 <thirsteh> I'm guessing the behavior is undefined
21:28:13 <Axman6> (perhaps IO (), because you don't want to let that MVector escape)
21:29:44 <thirsteh> Axman6: Interesting
21:30:03 <jfischoff> thirsteh: I see, I had not read the doc of modifyMVar
21:30:11 <jfischoff> it is exception safe
21:30:18 <thirsteh> I guess my actual question is if there is any mutating operation for MVectors that might throw an exception and leave the array in an unusable state
21:30:20 <jfischoff> I understand your question better
21:30:24 <Axman6> thirsteh: withFoo would best be implemented using bracket btw
21:30:29 <Axman6> @t bracket
21:30:29 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
21:30:34 <Axman6> :t bracket
21:30:35 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:31:01 <jfischoff> thirsteh: that is a good question
21:31:28 <jfischoff> probably is my guess, I'll look at the source
21:32:20 <jfischoff> which variant are you using? Data.Vector.Unboxed.Mutable?
21:32:26 <thirsteh> cool, no need to look too hard if not for your personal edification
21:32:26 <Axman6> bracket alloc free process (so withFoo (Foo v mvec) f  = bracket (takeMVar v) (const (f mvec)) (putMVar v))
21:32:34 <Axman6> uh, swap the last two
21:32:34 <thirsteh> jfischoff: Boxed
21:32:41 <jfischoff> oh
21:33:02 <thirsteh> I'm guessing that if I want to stay pure, my next best option is Data.Sequence
21:33:12 <thirsteh> although I'd really love for index and set to be O(1)
21:33:41 <thirsteh> Axman6: I might use that. Thank you
21:34:24 <jfischoff> Guess I'm thinking if is already boxed just make, I don't know a Vector of MVar's or something safer basically
21:34:51 <jfischoff> I assumed you had unboxed packed data, if you don't there is less value in Vector anyway
21:34:58 <Axman6> thirsteh: are you only modifying a single element at a time?
21:35:08 <Axman6> like, do you need atomicity of the whole array?
21:35:34 <jfischoff> yeah I'm guessing now you have an easier problem
21:35:53 <Axman6> if so, Array (IORef Bar) would work well and perform well
21:36:06 <Axman6> using atomicModifyIORef
21:36:11 <bmuk> I'm reading typeclassopedia, and I'm having a hard time trying to figure out foldMap . foldMap
21:36:18 <Axman6> but it won't if there's any dependency between the values in the vector
21:36:36 <Axman6> :t foldMap . foldMap
21:36:37 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t (t1 a) -> m
21:37:00 <jfischoff> Axman6: that sounds good
21:37:11 <bmuk> It takes a container of containers and maps a function over them?
21:37:23 <bmuk> leaving a single value?
21:37:33 <thirsteh> Axman6: the Foo type that contains the MVector that I was talking about earlier is in an MVar, so there will only ever be one user. I usually only modify one index, and I don't really need atomicity
21:38:03 <Axman6> bmuk: yeah, it turns all the a's nested two levels deep into m's and then joins them all together using their Monoid instance
21:38:11 <AshyIsMe> so on ec2 linux sudo yum install ghc doesnt find the ghc package
21:38:14 <thirsteh> jfischoff: Vector of MVar could work.
21:38:27 <jfischoff> what Axman6 said is better
21:38:34 <Axman6> thirsteh: in that case look into an array of IORef's then
21:39:02 <AshyIsMe> im guessing i need to enable a repo somewhere for yum
21:39:14 <thirsteh> What's the difference between a Vector and an Array for boxed values?
21:39:36 <jfischoff> your probably better off with vector, I don't know
21:39:42 <jfischoff> it has a fusion frameword
21:39:46 <jfischoff> framework
21:39:51 <Axman6> Vector is prefered if you're using 0 based Int indexing
21:39:54 <jfischoff> but IORef is the important part
21:40:11 <Axman6> yeah Vector (IORef Bar) is more likely what you want
21:40:15 <jfischoff> with atomicModifyIORef
21:41:09 <thirsteh> jfischoff, Axman6: I think I'll do that. Thank you!
21:41:29 <jfischoff> thank us when it works :p
21:41:41 <jfischoff> anyway np :)
21:42:09 <thirsteh> well, I'll be back after a few months of troubleshooting odd behavior to report the results
21:42:47 * jfischoff nods
21:43:48 <AshyIsMe> ah i needed the epel repo enabled
21:48:13 <benzrf> :t lift
21:48:14 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:49:45 <fragamus> hey guys is there a graphics rendering system that uses Linear
21:52:45 <haasn> fragamus: http://packdeps.haskellers.com/reverse/linear
21:53:06 <fragamus> oh i like that
21:57:36 <zipper> Is the one known as @computionist on twitter here?
22:01:01 <codygman> Using snap, how do I go from ("test", writeBS "test page") to using a template that simply has the content "test page"? From what I can tell you need to add your template to ./snaplets/heist/templates/test (you can add configure it to use other template locations I'm guessing?). I'm just starting to use snap and haven't found any examples of using routes/templates together in the docs.
22:04:42 <mm_freak_> codygman: you should learn how snaplets work
22:05:10 <codygman> mm_freak_: Alright, I went through the tutorial on them once but I'll do it again.
22:09:15 <fragamus> OK i wrote a ray tracing primitive for a funny shape.  I need a ray tracing environment with which to use it. I use linear for my matrices and I hope some package exists
22:17:16 <edwardk> fragamus: maybe https://github.com/TomHammersley/HaskellRenderer can b adapted
22:20:44 <fragamus> nifty!
22:22:31 * hackagebot llvm-general-pure 3.3.9.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.9.0 (BenjaminScarlet)
22:22:33 * hackagebot llvm-general 3.3.9.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.9.0 (BenjaminScarlet)
22:22:35 * hackagebot llvm-general-pure 3.4.0.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.0.0 (BenjaminScarlet)
22:22:37 * hackagebot llvm-general 3.4.0.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.0.0 (BenjaminScarlet)
22:24:24 <benzrf> :t guard
22:24:25 <lambdabot> MonadPlus m => Bool -> m ()
22:26:05 <benzrf> @djinn [a -> Bool] -> [a] -> Bool
22:26:05 <lambdabot> Error: Undefined type []
22:26:10 <benzrf> pfft
22:26:42 <dhrosa> :t undefined
22:26:43 <lambdabot> a
22:34:26 <tac> Is there a well-maintained library for doing interprocess communication?
22:34:47 <zRecursive> @hoogle ipc
22:34:47 <lambdabot> package ipc
22:34:47 <lambdabot> package bindings-sipc
22:34:47 <lambdabot> package FileManipCompat
22:40:52 <tac> @hoogle zmq
22:40:52 <lambdabot> package zmqat
22:40:52 <lambdabot> package binary-protocol-zmq
22:41:03 <haasn> @hoogler zeromq
22:41:03 <lambdabot> Maybe you meant: hoogle+ hoogle
22:41:07 <haasn> @hoogle zeromq
22:41:07 <lambdabot> package zeromq-haskell
22:41:07 <lambdabot> package zeromq3-conduit
22:41:07 <lambdabot> package zeromq3-haskell
22:41:45 <tac> It looks like the answer to my question is a big fat 'no' :<
22:42:05 <haasn> @hoogle distributed-process
22:42:05 <lambdabot> package distributed-process
22:42:05 <lambdabot> package distributed-process-azure
22:42:05 <lambdabot> package distributed-process-p2p
22:42:07 <haasn> That count? :)
22:42:52 <tac> I don't think a library capable of distributed processing would count as IPC.
22:43:04 <tac> so no :P
22:44:01 <Ralith> tac: what's wrong with zeromq?
22:44:25 <tac> There are 4 versions on Hackage (for each version of 0MQ) and I am unsure as to how well supported any is
22:44:52 <tac> @hoogle zmq
22:44:52 <lambdabot> package zmqat
22:44:52 <lambdabot> package binary-protocol-zmq
22:44:55 <tac> @hoogle zeromq
22:44:55 <lambdabot> package zeromq-haskell
22:44:55 <lambdabot> package zeromq3-conduit
22:44:55 <lambdabot> package zeromq3-haskell
22:45:00 <haasn> distributed-process lets you set up channels between processes and serialize messages though them, though
22:48:33 <tac> zeromq would be ideal if the package maintainer would include documentation on Hackage
22:48:46 <Ralith> tac: so when you said "there are no libraries" you actually meant "there are too many libraries". I see.
22:49:36 <tac> Ralith: If you filter out the libraries which aren't viable in production, you're left with (maybe) distributed-process
22:51:24 <wyager> Hi everyone. New Haskell user here. Is everyone else not blown away that Haskell isn't used *way* more?
22:51:55 <wyager> It's by far the best language I've ever come across
22:52:32 <wyager> Is the barrier to adoption that people just don't understand FP?
22:53:06 <shelf> not really, because most programmers prefer a long hack-observe-debug loop more than compiler feedback
22:53:44 <shelf> if compiler errors make you feel dumb, haskell is going to be an unpleasant experience
22:54:18 <bitemyapp> shelf: I prefer being productive, so I'd rather get confronted with my fuck-ups ASAP
22:54:22 <wyager> I compile my C code with maximum pedanticity, all warnings enabled, and Werror, so I guess I'm a little nonstandard in that regard :p
22:54:31 <haasn> what about type errors so complex that they make you feel dumb because you can't understand them
22:54:32 <erisco> there is a popularity problem and a stigma problem... former could be helped if it was taught in more schools
22:54:35 <bitemyapp> I find the compiler easier to understand than the massive error source-sink distances I get in dynamically typed langs.
22:54:46 <erisco> latter will change over time
22:54:49 <shelf> bitemyapp: me too, which is why i'm hear
22:54:51 <shelf> here** jeez
22:54:51 <bitemyapp> wyager: I think that's standard for professional C developers.
22:55:24 <shelf> but it doesn't surprise me that a lot of devs find haskell confrontational and it doesn't grow as rapidly as the latest procedural language
22:55:45 <jle`> bitemyapp: that might be you, but maybe not the majority of people :)
22:55:48 <shelf> i learned it in school and was well evangelised :>
22:56:01 <wyager> bitemyapp: Not in my experience. Most people wish they could just ignore everything :/
22:56:53 <tac> wyager: there's lots of reasons. Probably the #1 reason is that Haskell (and functional programming languages) grew up in academia
22:57:19 <erisco> popular opinion of Haskell is "it is not productive" and "I can only think in objects"
22:57:22 <wyager> tac: And yet, most universities go for Java :/
22:57:34 <tac> But no one does research on Java.
22:57:45 <wyager> My university used to teach Haskell to freshmen, but now it's all Java :(
22:57:53 <tac> Java is taught because programming is a trade skill.
22:58:12 <wyager> tac: Then they should teach a language that's used in industry, but also isn't soul-crushing
22:58:17 <tac> and most CS degrees are a mix of theoretical and vocational classes.
22:58:26 <wyager> I agree with Djikstra on the subject of teaching Java
22:58:29 <erisco> what, like C++? I'd rather take Java
22:58:40 <wyager> C, C++, Python, Ruby
22:58:46 <wyager> OK, maybe not C++
22:58:59 <wyager> But I think the rest are a lot better than Java
22:59:15 <bitemyapp> jle`: I know a fair number of systems and embedded programmers. professional C developers live and die by their Wall & Werror
22:59:21 <erisco> as tac said, it is partly about industry demand
22:59:28 <levi> wyager: Telling your C compiler to be pedantic and whatnot is certainly standard for professional C programmers who are worth anything as C programmers. :P
22:59:48 <wyager> bitemyapp: levi: Depends where you work, and what they do
22:59:52 <erisco> if people are not hiring for it then then there is little job value in learning the language
23:00:02 <wyager> erisco: It makes you a better programmer
23:00:09 <wyager> And life isn't all about work
23:00:09 <bitemyapp> jle`: it's absolutely not the case for non-C, non-systems/embedded programmers, but it is for that subset.
23:00:37 <levi> Well, I am a systems/embedded C programmer, so I guess my experience is biased that way.
23:00:45 <erisco> wyager, well try explaining that to someone trying to hire a Java programmer
23:01:11 <wyager> erisco: If more programmers know things besides Java, Java will die
23:01:26 <erisco> no it will not, because your predicate is already true
23:01:26 <wyager> There's no reason learning haskell excludes you from learning Java
23:01:37 <wyager> Right, and it's happening already
23:01:49 <levi> Java is not going to die.
23:01:52 <wyager> Java is extremely unpopular among new programmers. They almost never choose to use it
23:01:54 <levi> Cobol didn't die.
23:01:57 <wyager> Not immediately, but soon
23:02:01 <wyager> Yeah, let's be real there
23:02:07 <erisco> like, in the next 20 years
23:02:10 <wyager> cobol represents a vanishingly small fraction of code
23:02:11 <erisco> "soon"
23:02:17 <wyager> Cobol is dead for all intents and purpsoes
23:02:32 <rs0_> the sqlite people have a pretty interesting perspective on compiler warnings http://www.sqlite.org/testing.html
23:02:40 <wyager> When a language is limited to strictly legacy code, it's basically dead
23:02:41 <rs0_> "Static analysis has not proven to be especially helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis."
23:03:03 <levi> Java is not likely to be limited to strictly legacy code anytime soon.
23:03:14 <joelteon> sqlite has 91 million lines of test code
23:03:37 <rs0_> joelteon: yeah... ~~dreamy smile~~
23:03:58 <wyager> levi: We'll see about that. I give it ten years before java is no longer the favorite language of clueless enterprise people
23:04:15 <rs0_> levi: eh, java's kind of dead from the neck up. new stuff is being written in java, but it no longer seems to have any kind of culture
23:04:25 <bitemyapp> Scala has already grown quite a bit, despite the flaws.
23:04:42 <levi> You guys have a weird sense of language liveness.
23:04:48 <bitemyapp> carter: hai
23:04:54 <erisco> wyager, their ball game is far different. What language you do or do not like is not of much concern
23:05:01 <dhrosa> Java is still THE language taught by default in schools
23:05:05 <dhrosa> or one of them
23:05:10 <wyager> erisco: Their ball game is based on buzzwords and cluelessness
23:05:34 <levi> wyager: I think you are being irrationally biased against Java.
23:05:50 <wyager> levi: Maybe. But I have an entirely rational dislike of Java
23:06:00 <levi> I certainly don't love it, but it's not all bad.
23:06:16 <levi> And it's got solid control of a market right now.
23:06:23 <tac> wyager: everyone who knows anything about language design hates Java.
23:06:30 <tac> But it is what it is
23:06:45 <wyager> levi: Just because something is popular does not make it good. And I think we all know Java isn't good
23:06:49 <jrmithdobbs> could be worse
23:06:51 <erisco> wyager, your view is very narrow
23:06:53 <jrmithdobbs> it could be node :(
23:07:13 <wyager> erisco: How so?
23:07:52 <erisco> you cannot seriously believe that all business people operate on "buzzwords and cluelessness"
23:08:23 <levi> wyager: There's really no need to hate so much on Java. Haskell can be awesome without Java being terrible.
23:08:27 <tac> How do you import a typeclass instance from a qualified package?
23:08:31 <rs0_> yeah, that's pretty much the stereotype of ivory tower elitism
23:08:34 <zRecursive> However we have to admit many applcations are developed using Java
23:08:44 <wyager> levi: But Java *is* terrible. It has nothing to do with how I feel about Haskell
23:09:07 <tac> In particular, if I qualify-import Data.ByteString, I apparently don't get the desired IsString instance
23:09:44 <tac> @hoogle String -> ByteString
23:09:44 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
23:09:44 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
23:09:44 <lambdabot> Prelude error :: [Char] -> a
23:09:48 <levi> wyager: Your opinion of Java is irrelevant, especially in #haskell.
23:10:03 <wyager> levi: That's funny, because it's exactly what we're talking about
23:10:27 <levi> Conversations occasionally go off-topic. Temporarily.
23:10:28 <tac> wyager: Java is off-topic here. Please take it to ##programming if you want to fight about languages.
23:10:41 <tac> Or #haskell-blah
23:10:43 <tac> also acceptable
23:10:50 <rs0_> there's more than one legitimate, relevant definition of 'good', cf. http://www.youtube.com/watch?v=NftT6HWFgq0
23:11:35 <tac> Do Haskell threads operate as daemons by default?
23:11:59 <levi> tac: What do you mean by 'operate as daemons'?
23:12:24 <tac> If there are running threads from forkIO, and the main thread finishes execution, do the rest get killed?
23:13:10 <levi> I think so.
23:19:36 <levi> tac: If you haven't seen it before, this is a great reference for Haskell multithreading stuff: http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:23:29 <josiah14> how should i interpret this as a type [[a] -> [a]]
23:24:37 <wyager> A list of functions of type [a]->[a]?
23:24:39 <levi> A list of functions from lists-of-a to lists-of-a
23:24:39 <josiah14> I got that type from putting ':t (replicate 2 tail) in ghci
23:24:43 <dhrosa> josiah14: a list of functions, each function takes a list and returns a list of the same type
23:25:02 <josiah14> wow, that's crazy
23:25:04 <dhrosa> what were you trying to do?
23:25:41 <josiah14>  i was studying a solution to the third problem of the 99 haskell problems.  link coming up
23:26:01 <josiah14> http://www.haskell.org/haskellwiki/99_questions/Solutions/3
23:26:10 <levi> josiah14: You probably meant to apply tail to a list before passing to replicate.
23:26:40 <josiah14> it's the second solution under 'a few more solutions using prelude functions'
23:27:36 <amalloy> right. that solution creates a list of N copies of the tail function, and then folds over them, resulting in calling tail N times
23:27:50 <levi> Oh, nope, it really does replicate the function.
23:28:51 <levi> I've done something like that before to apply a bunch of a -> a functions.
23:29:18 <josiah14> that solution is fucking with my mind right now
23:29:27 <josiah14> it's hard to picture in my head
23:29:58 <josiah14> so I get that replicate 2 tail == [tail, tail] now
23:30:29 <josiah14> so then i end up with foldr ($) xs [tail, tail]
23:30:52 <josiah14> which is just weird as all frack
23:31:07 <levi> There's no existing combinator to compose a list of functions, so you have to use something like that if you don't have a fixed composition chain to write out with (.)
23:33:02 <dhrosa> alternatively, (foldl (.) [tail, tail]) xs ?
23:33:14 <dhrosa> well, almost
23:33:19 <dhrosa> alternatively, (foldl (.) id [tail, tail]) xs ?
23:34:02 <josiah14> I'm still confused, haha
23:34:22 <dhrosa> you're trying to implement !! using tail, right?
23:34:29 <josiah14> the second argument needs to be a list, no?
23:34:43 <josiah14> sort of, it's almost !!
23:34:58 <dhrosa> :t foldl (.) id
23:34:59 <lambdabot> [c -> c] -> c -> c
23:35:13 <josiah14> except xs!!0 == elementAt xs 1
23:35:31 <dhrosa> foldl (.) id takes a list of functions, and combines them all together into one function via composition
23:35:59 <dhrosa> so foldl (.) id [tail, tail] x becomes equivalent to (tail . tail) x
23:36:03 <josiah14> oooh, damn
23:36:09 <josiah14> I'm beginning to see this
23:36:14 <josiah14> wow, thats really clever
23:36:43 <levi> That's just the beginning of the cleverness that some Haskellers get up to.
23:36:47 <dhrosa> I personally would prefer this to $, because you're combining functions into asingle function, which you call on xs
23:36:59 <dhrosa> to the foldr ($) solution*
23:37:00 <jle`> in an fp class i took at uni, one of the first assignments required students to do this
23:37:09 <jle`> many were tripped up
23:37:29 <josiah14> yah, it's not a way I'm used to thinking, but  I get it, now
23:37:32 <jle`> but actually it might help you see Endo (a -> a functions) as a monoid
23:37:33 <dhrosa> jle`: did your fp class assume previous programming skills?
23:37:35 <jle`> (you know about monoids right?)
23:37:48 <dhrosa> I wonder what it would be like to learn fp first
23:37:50 <levi> It does get you thinking about functions-as-data.
23:37:51 <jle`> dhrosa: it was a typical 3rd year class, so it's after students took two years of java i assume. i was not a cs major
23:38:03 <josiah14> I never had an fp class -> computer engineering major
23:38:07 <dhrosa> a lot of learning fp seems to be unlearning imperatice
23:38:15 <josiah14> I learned assembly code and logic design, hahahaha
23:38:19 <dhrosa> imperative*
23:38:37 <josiah14> fp is more fun, though, if you ask me
23:38:56 <jle`> dijkstra seems to have a strong opinion on which are better for your personal development as a programmer
23:38:58 <levi> Definitely. :)
23:39:01 <josiah14> I agree, fp is basically learning to program all over again
23:39:05 <jle`> :)
23:39:08 <jle`> people get frustrated
23:39:19 <jle`> because they say they have been learning haskell for a couple of weeks/a month
23:39:28 <jle`> and simple things still seem "harder than other languages" to understand
23:39:31 <jle`> but then i ask them...
23:39:33 <dhrosa> how would you describe fp to someone who doesn't know fp and is wondering "why not just python?"
23:39:35 <jle`> do you remember your first month of programming?
23:39:41 <tac> jle`: to be fair, that is true for many things
23:39:45 <josiah14> yah, i see Haskell as a journey
23:39:49 <jle`> if you started programming ten years ago...
23:39:53 <jle`> you can't compare learning haskell after one month
23:39:59 <josiah14> it took me a good 6 months to wrap my head around c++
23:39:59 <jle`> to knowing how to imperative for ten years
23:40:04 <tac> Some things in Haskell are obnoxious to learn
23:40:12 <jle`> maybe imagine how you will look at the problem after ten year sof haskell
23:40:17 <tac> But that's half the fault of the community
23:40:19 <jle`> and that would be a fair comparison
23:40:32 <erisco> tac, which parts?
23:40:33 <tac> and the fact the language is so old and when it was younger, it was novel.
23:40:48 <jle`> josiah14: do you know about monoids?
23:40:57 <josiah14> not really
23:40:59 <tac> erisco: I spent nearly 2 hours trying to figure out how to cobble a 1-line piece of lens code today
23:41:12 <josiah14> I vaguely know about what a monad is
23:41:19 <tac> monoids are much simpler things
23:41:22 <jle`> you might find that a lot of things/types have some sort of a -> a -> a operation
23:41:28 <jle`> like, integers and (+)
23:41:29 <tac> > [1,2,3] <> [3,4,5]
23:41:30 <lambdabot>  [1,2,3,3,4,5]
23:41:33 <jle`> integers and (*)
23:41:35 <jle`> lists and (++)
23:41:37 <tac> > Sum 3 <> Sum 6
23:41:38 <lambdabot>  Sum {getSum = 9}
23:41:47 <jle`> basically an operator that "combines" (kinda) two types into one
23:41:50 <dhrosa> :t (<>)
23:41:51 <lambdabot> Monoid m => m -> m -> m
23:41:56 <jle`> > [1,2,3] ++ [4,5,6]
23:41:56 <dhrosa> is <> just mappend?
23:41:57 <lambdabot>  [1,2,3,4,5,6]
23:41:58 <tac> > Product 4 <> Product 7
23:41:59 <lambdabot>  Product {getProduct = 28}
23:42:00 <dhrosa> :t mappend
23:42:01 <lambdabot> Monoid a => a -> a -> a
23:42:04 <tac> dhrosa: Yes.
23:42:13 <tac> > [1,2,3] <> mempty
23:42:14 <lambdabot>  [1,2,3]
23:42:32 <tac> Just 4 <> Just 6
23:42:34 <jle`> also, there is a specific value in this type that leaves the thing unchanged when you use the operator
23:42:37 <tac> > Just 4 <> Just 6
23:42:38 <erisco> tac, ah well thankfully I've dodged that bullet thus far
23:42:38 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
23:42:38 <lambdabot>    arising from a use of `e_146'
23:42:38 <lambdabot>  The type variable `a0' is ambiguous
23:42:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:42:38 <lambdabot>  Note: there are several potential instances:
23:42:43 <jle`> for example, if you have Ints and (+), your "identity" is 0
23:42:49 <jle`> if you have Ints and (*), your "identity" is 1
23:42:51 <tac> > Just (Sum 4) <> Just (Sum 6)
23:42:52 <lambdabot>  Just (Sum {getSum = 10})
23:43:03 <jle`> if you have Bools and (&&), your "identity" is True
23:43:15 <jle`> if you have lists and (++), your "identity" is the empty list, []
23:43:16 <tac> erisco: It's not hard once you "see" how they work, but the problem is that the error messages are less than useless.
23:43:26 <jle`> > [1,2,3] ++ []
23:43:27 <lambdabot>  [1,2,3]
23:43:31 <josiah14> I might have to say one person at a time, lol
23:43:35 <jle`> heh.
23:43:40 <tac> Lens seem pretty interesting, but the biggest issue with them is that the type signatures bleed all over the place
23:43:46 <josiah14> I'm reading lambdabot's stuff right now
23:43:52 <tac> And haskell has no way of saving you from experiencing the bloodshed
23:43:56 <enthropy> no "instance for blah" isn't useless
23:44:14 <tac> enthropy: I wasn't talking about monoids
23:45:40 <jle`> josiah14: basically, for a lot of types, you can find an operator between two values in that type.  *and* that operator has an idenity.  For lists, the operator is (++), and the identity is [] (anything ++ [] is itself).  For ints, you can have an operator (+) with an identity 0 (anything + 0 is itself), or the operator (*) with the identity 1.  or for Bools, you can have the operator (&&) with the identity
23:45:43 <jle`> True.  Or also the operator (||) with the identity False
23:45:59 <josiah14> gotcha
23:46:23 <josiah14> this brought the monoid into the light for me http://en.wikipedia.org/wiki/Monoid
23:46:29 <jle`> mhm
23:46:29 <josiah14> good old wikipedia
23:46:35 <jle`> in Haskell we have a Monoid typeclass
23:46:45 <jle`> just like we have an Eq typeclass
23:46:47 <josiah14> yah, saw that in Google search just now
23:46:49 <jle`> where Eq defines (==)
23:46:55 <jle`> Monoid defines (<>) and mempty
23:47:02 <tac> josiah14: If you have any math background, maybe you've also heard of a group (in the sense of algebra). All groups are monoids.
23:47:04 <jle`> anyways, the Monoid typeclass isn't really the point right now
23:47:04 <josiah14> I really like how fp is much closer to real math
23:47:08 <jle`> anyways
23:47:12 <jle`> functions of type (a -> a)
23:47:13 <jle`> are monoids
23:47:16 <jle`> do you see?
23:47:26 <tac> > (+1) <> id
23:47:27 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
23:47:27 <lambdabot>    arising from a use of `e_11'
23:47:27 <lambdabot>  The type variable `a0' is ambiguous
23:47:27 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:47:27 <lambdabot>  Note: there are several potential instances:
23:47:27 <jle`> you can combine any function (a -> a) with another function (a -> a)
23:47:34 <jle`> using (.)
23:47:40 <tac> > (+1) <> id $ 2
23:47:41 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
23:47:41 <lambdabot>    arising from a use of `e_112'
23:47:41 <lambdabot>  The type variable `a0' is ambiguous
23:47:41 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:47:41 <lambdabot>  Note: there are several potential instances:
23:47:45 <josiah14> yah, I started college as a chemistry major - went up through calculus 3 with partial derivatives and all
23:47:50 <tac> hmm. That's kind of gross.
23:47:50 <levi> :t tail
23:47:51 <lambdabot> [a] -> [a]
23:47:54 <jle`> if f is Int -> Int, and g is Int -> Int, then f . g is also Int -> Int
23:47:55 <levi> :t tail <> tail
23:47:56 <lambdabot> [a] -> [a]
23:48:04 <jle`> so we have a binary operator
23:48:07 <jle`> but what about the identity?
23:48:19 <jle`> the identity is the `id` function :)
23:48:24 <jle`> f . id = f
23:48:27 <jle`> id . g = g
23:48:30 <josiah14> right, yah, i see lambdabot
23:48:47 <jle`> so functions (a -> a) are monoids  under (.) with the identity id :)
23:48:50 <jle`> that's why you can fold them up
23:48:57 <jle`> with the operator (.)
23:49:00 <jle`> and the "initial value" id
23:49:05 <jle`> foldr (.) id
23:49:05 <dhrosa> > (+1) <> id $ 2 :: Int
23:49:06 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
23:49:06 <lambdabot>    arising from a use of `Data.Monoid.<>'
23:49:06 <lambdabot>  Possible fix:
23:49:06 <lambdabot>    add an instance declaration for (Data.Monoid.Monoid GHC.Types.Int)
23:49:07 <josiah14> because of auto-currying, you can just apply funcs to funcs and choose when to treat them as vars or funcs
23:49:16 <dhrosa> :(
23:49:19 <levi> :t mconcat (replicate 5 tail)
23:49:19 <lambdabot> [a] -> [a]
23:49:46 <dhrosa> aw man, it didn't occur to me that functions form a monoid like that
23:49:50 <jle`> not all functions
23:49:53 <dhrosa> I have to compose lists of functions all the time
23:50:00 <dhrosa> functions from a->a at least?
23:50:07 <tac> dhrosa: Functions from a to a are in a sense the "original" monoid
23:50:09 <jle`> yeah, we call them Endo
23:50:32 <tac> dhrosa: When you allow for functions going from a to b, then you get a sort of "monoidoid"... or a category, as they are usually called
23:50:46 <jle`> yeah
23:50:54 <jle`> you get a Category, which is like a generalized monoid of sorts
23:51:01 <jle`> the difference is that monoids have to have one unique id
23:51:06 <jle`> identity
23:51:15 <tac> Category's id's are unique, too
23:51:33 <jle`> if you consider id_a and id_b to be identical?
23:51:45 <tac> well, unique per object
23:51:46 <tac> so yeah
23:51:59 <jle`> not unique for the entire category
23:52:24 <jle`> unless your category has only one object
23:52:32 <jle`> and...it's a monoid :)
23:55:01 <levi> > ((++"a") <> (++"b") <> id) "c"
23:55:02 <lambdabot>  "cacbc"
23:55:15 <tac> @kind Endo
23:55:15 <lambdabot> * -> *
23:55:45 <tac> @type Endo
23:55:45 <lambdabot> (a -> a) -> Endo a
23:56:13 <tac> wait, why did levi's example work there but not this one?
23:56:16 <tac> (+1) <> id $ 2
23:56:49 <shachaf> it depends on what you man by "work"
23:57:05 <tac> shachaf: what do you think I mean?
23:58:02 <tac> actually, wtf is levi's example even doing? It seems to apply the append on both sides somehow
23:58:25 <levi> > ((++"a") <> (++"b")) "c"
23:58:26 <lambdabot>  "cacb"
23:58:26 <shachaf> I don't know what you mean, but it's probably not what happened.
23:58:38 <levi> The extra c at the end was due to the id
23:58:43 <haasn> > ("c"++"a") <> ("c"++"b") <> "c"
23:58:44 <lambdabot>  "cacbc"
23:58:46 <tac> > (++" world") $ "Hello"
23:58:47 <lambdabot>  "Hello world"
23:58:49 <tac> > (++" world") <> id $ "Hello"
23:58:50 <lambdabot>  "Hello worldHello"
23:58:59 <jle`> the default monoid instance for functions
23:59:08 <jle`> is not Endo
23:59:30 <shachaf> OK, what I think you mean is a Monoid instance such that f <> g is f . g
23:59:34 <haasn> :t (<.)
23:59:35 <lambdabot> Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
23:59:36 <haasn> :t (<>)
23:59:37 <lambdabot> Monoid m => m -> m -> m
23:59:51 <jle`> this is similar to how there are many monoid instances of Maybe
23:59:53 <shachaf> There is no such Monoid instance for (a -> b).
23:59:59 <jle`> but there is only one default one
