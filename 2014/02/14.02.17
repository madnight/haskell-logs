00:11:34 * hackagebot word24 1.0.7 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.7 (JohnLato)
00:11:34 * hackagebot egison 3.2.19 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.19 (SatoshiEgi)
00:18:07 <grohne> hi. I am working on this piece of code that does tons of "lift . lift . lift" stuff, and I thought I should add some LiftX classes with liftX methods (like liftIO), but it uses "type" rather than "newtype" to plug its monads together. what are my options now?
00:18:28 <grohne> a) replace type with newtype and fix tons of code b) FlexibleInstances c) ?
00:22:33 <supki> grohne: I tend to use  (MonadFoo m, MonadBar m, ... MonadWhatever m) => m a  types, instead of concrete implementations, so I don't need lifts at all. Then, I can plug in a raw monad stack or a newtype-wrapped one without any work
00:22:44 <supki> I guess that's what you meant by b) ?
00:24:14 <grohne> supki: I don't quite get that yet. with be I meant like "class LiftFoo m where liftFoo :: Foo a -> m a" and then I'd have to use FlexibleInstances to do "instance LiftFoo (StateT ...) where .."
00:24:38 <grohne> where Foo is a type alias
00:25:34 <supki> uhm, no, there's already MonadState class that can lift stateful computations
00:25:42 <jle`> well
00:25:57 <jle`> you instance all of your Monad transformers in your entire stack as MonadFoo
00:26:28 <cinimod> @seen merijn
00:26:28 <lambdabot> M3rijn
00:26:30 * hackagebot irc 0.6.0.0 - A small library for parsing IRC messages.  http://hackage.haskell.org/package/irc-0.6.0.0 (TrevorElliott)
00:26:30 <supki> e.g. instead of  StateT S IO a  you use  (MonadIO m, MonadState S m) => m a  and then you can plug in whatever implementations of MonadIO and MonadState S you want
00:26:47 <jle`> and you'd do something like instance MonadFoo m => MonadFoo t m where foo = lift foo
00:26:56 <jle`> and then in the actual concrete FooT
00:27:01 <jle`> you'd do the actual implementation
00:27:30 <grohne> supki: but how do I select the target monad in that setting?
00:27:31 <jle`> t being StateT, ReaderT, etc.
00:27:34 <jle`> um i flew a bit loose with the syntax
00:27:56 <cinimod> merijn: consider a group as a single object category
00:28:46 <supki> grohne: you select it then you actually run the computation with  runState  or something
00:28:49 <grohne> I seem to be missing more bits (background) here. Is there introductory documentation on monad transformers?
00:29:24 <cinimod> carter: your instructions worked fine thanks
00:29:46 <jle`> grohne: a MonadState is anything that implements get, put, etc., right?
00:30:07 <grohne> jle`: yes, but I have two StateTs on the stack
00:30:07 <jle`> so would not a FooT (StateT s) m be a MonadState?
00:30:10 <cinimod> carter: the ghc-lang-cwrapper script did not
00:30:15 <jle`> where get = lift . get
00:30:16 <jle`> ah
00:30:18 <jle`> well
00:30:25 <jle`> then the typeclass hackery fails you here
00:30:31 <jle`> i think.
00:30:51 <grohne> so there is:
00:30:53 <grohne> type IM a = StateT Igor LM a
00:31:10 <grohne> type LM = ELT (C IO)
00:31:21 <grohne> type ELT m = (StateT LogState (ErrorT String (WriterT Log m)))
00:31:30 <grohne> there we have two StateTs
00:31:36 <jle`> (you probably would typically do type IM = StateT Igor LM)
00:32:08 <grohne> well I try to understand and make work existing code. ;-)
00:32:23 <grohne> actually it does work... on ghc6
00:32:44 <supki> oh, two StateT transformers is a pain
00:33:03 <supki> I usually merge them into one and use lenses to access parts of the state
00:33:13 <supki> ..but that may be a bit too advanced
00:33:25 <jle`> yeah the way mtl/transformers is organized does not play well at all with two of the same monad transformer in a stack
00:33:40 <jle`> unfortunately
00:33:44 <jle`> iirc
00:33:51 <supki> right
00:33:54 <grohne> hmm. so I won't get rid of the "lift . lift . lift" hackery
00:34:02 <jle`> well
00:34:05 <jle`> it's not that bad
00:34:09 <jle`> if you abstract it away
00:34:21 <jle`> liftState1
00:34:23 <jle`> liftState2
00:34:31 <jle`> = lift . lift . lift etc.
00:34:33 <jle`> but it's kinda fragile
00:34:35 <grohne> well my aim was to have liftLM
00:36:30 <supki> grohne: liftLM is a composition of lifts, you don't need a typeclass
00:36:41 <grohne> depends on where you come from
00:36:42 <supki> the definition will change when you remove or add more layers
00:45:26 <jle`> i think typically you don't want to be jumping back and forth between layers too much intermediately
00:45:45 <jle`> the whole point is that you basically have one super-monad with all of your effects
00:45:50 <jle`> and you abstract the layers away completely
00:46:35 <jle`> the layers aren't even supposed to 'exist', except when you unwrap at the end
00:47:12 <jle`> they are an implementation detail, ideally
00:48:09 <tdammers> isn't that pretty much what monad transformers are supposed to do for you?
00:48:52 <tdammers> like how StateT WriterT a IO automatically gives you MonadState, MonadWriter and MonadIO?
00:49:14 <jle`> tdammers: yeah, so i'm trying to say that he shouldn't have to worry too much about jumping back and forth between different levels
00:49:29 <tdammers> well, stacking two states is a bit trickier
00:50:18 <tdammers> but then, I'd think that you could either merge them into one, or the "lower" one can be abstracted some further, and you could do the same trick for it that other transformers already have
00:50:43 <tdammers> ie., expose it through more specialized methods in a typeclass, and write instances to do the lifting automatically
01:02:19 <supki> tdammers: you'll also need to reimplement all MonadState machinery you use
01:02:34 <supki> which may or may not be very painful
01:03:16 <ReinH> the joys of GeneralizedNewtypeDeriving
01:03:29 <tdammers> supki: not if you encapsulate the actual State
01:13:04 <davesq> i'd like top pull out some blocks of text from a loosely structured text doc. e.g. given https://gist.github.com/dtchepak/e97f81f64fa49cb1601d, I'd like to parse ["abc","123"]. Is it something I should throw Parsec-style lib at? Or just fold over lines?
01:14:37 <Hail_Spacecake> there's an unsafe function that will extract a value out of a maybe
01:14:44 <Hail_Spacecake> and fail if the value of the maybe is Nothing, right?
01:14:51 <Hail_Spacecake> along the lines of unsafePerformIO?
01:15:08 <Hafydd> It's called fromJust, but it's not comparable to unsafePerformIO.
01:15:18 <Hafydd> It will quite safely terminate the program if it fails.
01:15:25 <Hafydd> (Or terminate the thread, anyway)
01:21:07 <pavonia> unsafeFromJust mb = case mb of { Just a -> a; _ -> unsafePerformIO (launchTheMissiles >> return undefined) }
01:21:45 <Ralith> that's a misnomer
01:22:18 <pavonia> *unsafeFromMaybe
01:28:21 <tdammers> there are several degrees of unsafe
01:32:10 <grohne> tdammers: exposing via more specialized methods is likely what I would need.
01:32:41 <grohne> tdammers: given that I don't fully understand the code at hand, it is difficult to come up with that interface though
01:33:32 <grohne> I guess most of the problems would vanish, if I were to abstract this "ELT" type above in some way (as that would also remove the need for two StateTs)
01:37:42 <spacekitteh> do lenses destroy fusion with vectors?
01:38:52 <Taneb> spacekitteh, which lenses in particular?
01:40:50 <spacekitteh> um, i'm not sure. i'm only just now learning lenses and have noticed that there is an instance for vectors. so um, i guess data.vector.generic.lens.sliced?
01:42:39 <mm_freak_> spacekitteh: you can make GHC tell you when rewrite rules fire (see the GHC manual on rewrite rules)
01:42:50 <mm_freak_> so just check yourself whether the fusion rules fire
01:43:42 <spacekitteh> hmm.
01:46:42 <carter> cinimod: i know
01:46:43 <carter> thats why i recommended it
01:46:44 <carter> :)
01:46:46 <carter> cinimod: how're you doing?
01:46:55 <spacekitteh> ok, i guess a question i should have asked prior to that one is, does the lens paradigm use its own version of fold/scan/map? *shrugs*
01:47:29 <carter> cinimod: btw, #numerical-haskell is a channel now :)
01:47:32 <spacekitteh> i'm still in the early stages of wrapping my head aroudn them
01:50:34 <mm_freak_> spacekitteh: you can express many of those things using lenses
01:50:56 <mm_freak_> (whether it's a good idea is a different question)
01:51:26 * spacekitteh nodnods
01:54:42 <carter> the only time i've used lens thus far is to sanely mess with the cabal lib config stuff in custom setup.hs stuff
02:03:29 <jle`> Hail_Spacecake: the two usages of unsafe do not really mean the same thing in this context
02:05:45 <passiveobserver> is there a way to see type inheritance? e.g. that Floating -> Float, Double and that Num->Integral->Int, Integer (e.g. know whom a type inherits from?
02:06:31 <Iceland_jack> passiveobserver: :info should do what you want
02:06:41 <spacekitteh> Iceland_jack: >:(
02:07:05 <Iceland_jack> spacekitteh: oops! :x
02:07:15 <Iceland_jack> sorry for bailing on you!
02:08:09 <spacekitteh> a security guard was following me
02:08:19 <spacekitteh> i looked rather suspicious
02:08:24 <Iceland_jack> how so?
02:08:53 <spacekitteh> i was wearing a cat beanie and a shemagh and a tshirt. i looked like some sort of furry terrorist
02:09:12 <Iceland_jack> You probably are
02:09:44 <merijn> passiveobserver: There is no inheritance
02:10:10 <Benzi-Junior> hey anyone here used Alex or know where I should direct questions about problems using it ?
02:10:35 <merijn> passiveobserver: Integral doesn't inherit from Num, the existence of a Num instance is a prerequisite for an Integral instance, but there's no inheritance there
02:10:47 <merijn> Benzi-Junior: What are you using Alex for?
02:11:21 <Benzi-Junior> merijn: creating a lexer, schoolwork
02:12:17 <merijn> Benzi-Junior: Ah :\ I was gonna say that you probably want to use parsec if you're doing lexing/parsing, but I guess schoolwork requires Alex?
02:13:10 <Benzi-Junior> merijn: no actually any lexing tool will do
02:14:41 <mm_freak> the cartesian closed comic is offline
02:15:20 <Benzi-Junior> merijn: the project is creating my own programming language (i.e. create a compiler for a programming language)
02:16:39 <merijn> Benzi-Junior: Right, if you have no restrictions I would recommend not using alex and using parsec instead
02:17:16 <Benzi-Junior> merijn: why ? (I looked into it but alex seemed simpler)
02:17:41 <merijn> Benzi-Junior: It's much simpler to build a parser (not just lexer) with Parsec. There's a chapter in Real World Haskell that explains parsec (it's for parsec 2 instead of 3, so the examples are a bit out of date, but the rough line should be easy to follow)
02:17:45 <merijn> @where rwh
02:17:45 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:23:59 <Benzi-Junior> what would be the correct way to force a type on getContents ?
02:24:36 <merijn> What do you mean by "force a type on getContents"?
02:27:03 <Yuu-chan_> getContents :: IO String?
02:27:12 <Iceland_jack> Benzi-Junior probably wants something like
02:27:12 <Iceland_jack> @ty do cont <- getContents; return (map read (lines cont) :: [Int])
02:27:13 <lambdabot> IO [Int]
02:27:58 <Iceland_jack> Of course that will fail if ‘read’ cannot parse one number per line
02:28:06 <Benzi-Junior> merijn:  "IO String" or "IO ByteString" or "IO Text"  are all documented as types for getContents
02:28:10 <Benzi-Junior> Iceland_jack: Nailed it
02:28:19 <Iceland_jack> Benzi-Junior: They're not types for the same function
02:28:21 <no-n> > let r n f = if(n==0) then(id) else(r (pred n) f . f) in r 2 (r 3 (++".")) "hello"
02:28:22 <lambdabot>  "hello......"
02:28:31 <Iceland_jack> @hoogle getContents
02:28:32 <lambdabot> Prelude getContents :: IO String
02:28:32 <lambdabot> System.IO getContents :: IO String
02:28:32 <lambdabot> Data.ByteString.Lazy getContents :: IO ByteString
02:28:47 <merijn> Benzi-Junior: Those are different getContents
02:29:00 <Iceland_jack> You'll see that ‘getContents :: IO String’ is in System.IO, ‘getContents :: ByteString’ is in Data.ByteString.Lazy, etc.
02:29:07 <merijn> Benzi-Junior: Prelude is a different module then Data.ByteString which is different from Data.Text, etc.
02:29:27 <Iceland_jack> Then there is one from Data.Text, Data.Text.Lazy, etc.
02:29:27 <Iceland_jack> @hoogle getContents :: IO Text
02:29:27 <lambdabot> Data.Text.Lazy.IO getContents :: IO Text
02:29:27 <lambdabot> Data.Text.IO getContents :: IO Text
02:29:28 <lambdabot> Data.Text.Lazy.IO hGetContents :: Handle -> IO Text
02:29:41 <Iceland_jack> Benzi-Junior: Different actions :)
02:30:06 <Benzi-Junior> guess I should have checked my imports
02:30:49 <Yuu-chan_> Benzi-Junior: you need to specify the module, e.g. Data.ByteString.Lazy.getContents or something like B.getContents if use a qualified import
02:31:11 <Benzi-Junior> Yuu-chan_: noted
02:32:02 <killy9999> I have a ByteString that stores a multiline string. When I use "show" to convert ByteString to String I see thatnewline characters are escaped and they get printed as "\n", not as newline characters
02:32:08 <killy9999> how can I print them as newlines?
02:33:01 <Yuu-chan_> killy9999: use putStr from the corresponding ByteString module
02:33:03 <Iceland_jack> killy9999: Have you searched for something like ‘print bytestrings Haskell’?
02:33:24 <Iceland_jack> ‘show’ is not the way to turn a ByteString into a String
02:34:06 <Yuu-chan_> Or, if you need only to convert, not to output, use unpack.
02:34:08 <killy9999> Iceland_jack: I looked at haddock for ByteStrings
02:34:20 <Iceland_jack> You mean Hackage?
02:34:24 <killy9999> yes
02:34:32 <killy9999> haddock on hackage
02:35:00 <killy9999> Yuu-chan: putStr returns IO ()
02:35:01 <Iceland_jack> Haddock is just the documentation tool, but enough on that
02:35:03 <killy9999> that's no good
02:35:25 <Iceland_jack> killy9999: So you don't want to print it, you want to convert it to a String
02:35:25 <killy9999> Hackage is just a hosting server, but enough on that
02:35:32 <killy9999> yes
02:35:39 <merijn> killy9999: You need to decode
02:35:53 <Iceland_jack> @hoogle ByteString -> String
02:35:54 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
02:35:54 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
02:35:54 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
02:35:58 <killy9999> ah, decode looks better
02:36:01 <merijn> killy9999: The correct way from ByteString to String is "ByteString -decode-> Text -decode-> String"
02:36:15 <merijn> killy9999: No, if you use any of those functions I will find you and murder you
02:36:26 <merijn> And the same goes for Iceland_jack for mentioning them >.<
02:36:32 <killy9999> merijn: thanks, I'm trying with decode ATM
02:36:50 <Iceland_jack> merijn: Chances are killy9999 doesn't want ByteString in the first place
02:36:58 <merijn> killy9999: decodeUtf8With :: OnDecodeError -> ByteString -> Text
02:37:05 <Yuu-chan_> merijn: kill me as well, I proposed unpack earlier
02:37:08 <merijn> killy9999: Data.Text.Encoding
02:37:41 <merijn> killy9999: And Data.Text has "unpack :: Text -> String"
02:39:05 <merijn> killy9999: ByteString are just plain bytes, you can't print them or convert them to String as String is proper unicode, so you need to decode ByteString first (and handle decoding errors), Text is the efficient version of String (i.e. densely packed unicode text, instead of a linked list of Char)
02:39:33 <merijn> (obviously the "decodeUtf8With" assumes you do, in fact, have UTF-8
02:41:29 <killy9999> well, I'm storing the output of GHC in a bytestring
02:41:37 <killy9999> if GHC has proper UTF 8 then so do I
02:41:55 <Iceland_jack> Why did you decide to use ByteString rather than Text?
02:42:43 <killy9999> Iceland_jack: beacuse library I am using uses ByteSring
02:42:49 <killy9999> so I just went with that
02:43:01 <Iceland_jack> What library is that?
02:43:11 <killy9999> tasty-golden
02:43:12 <SLi> Is there a less ugly way to express (,) <$> x <*> y?
02:43:26 <merijn> SLi: liftA2 (,) x y
02:43:27 <Iceland_jack> SLi: liftA2 (,) if you can partially apply it
02:44:23 <killy9999> Iceland_jack: but it's not like ByteString are set in stone. I can use Text, will just have to apply some conversions (which it looks I need anyway)
02:44:45 <SLi> Yeah, I know I can use liftA2 (,), not sure I consider it less ugly :) (I cannot partially apply)
02:45:20 <SLi> Maybe it is more esthetically pleasing than the operator mess I have.
02:45:26 <Iceland_jack> SLi: You can always define an auxiliary function as
02:45:26 <Iceland_jack>     liftTuple :: Applicative f => f a -> f b -> f (a, b)
02:45:26 <Iceland_jack>     liftTuple = liftA2 (,)
02:45:34 <SLi> True.
02:46:17 <Iceland_jack> or you can define it as
02:46:17 <Iceland_jack>     (!.!) :: Applicative f => f a -> f b -> f (a, b)
02:46:17 <Iceland_jack>     (!.!) = liftA2 (,)
02:46:17 <Iceland_jack> and then you get this nice effect
02:46:20 <Iceland_jack>     (Just 5 !.! Just True)
02:46:24 <Iceland_jack>     ⇒ Just (5, True)
02:46:40 <bennofs> Is <,> a valid operator? I guess not :(
02:46:57 <Iceland_jack> it isn't
02:47:04 <Iceland_jack> but only because of the comma
02:47:29 <Iceland_jack> @let comma = liftA2 (,) :: Applicative f => f a -> f b -> f (a, b)
02:47:30 <lambdabot>  .L.hs:142:9:
02:47:30 <lambdabot>      No instance for (Applicative f0)
02:47:30 <lambdabot>        arising from an expression type signature
02:47:30 <lambdabot>      The type variable `f0' is ambiguous
02:47:30 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
02:47:39 <Iceland_jack> hm
02:47:55 <bennofs> @hayoo (<->)
02:47:55 <lambdabot> Unknown command, try @list
02:47:58 <bennofs> :|
02:48:15 <merijn> @let comma :: Applicative f => f a -> f b -> f (a, b); comma = liftA2 (,)
02:48:16 <lambdabot>  Defined.
02:48:26 <Iceland_jack> > Just 5
02:48:28 <lambdabot>  Just 5
02:48:28 <merijn> Iceland_jack: What you wrote is different from what I wrote :p
02:48:31 <Iceland_jack> > Just 5 `comma` Just Bool
02:48:32 <lambdabot>  Not in scope: data constructor `Bool'Ambiguous occurrence `comma'
02:48:32 <lambdabot>  It could refer to either `L.comma', defined at L.hs:144:1
02:48:34 <lambdabot>                        or `Text.PrettyPrint.HughesPJ.comma',
02:48:36 <lambdabot>                           imported from `Text.PrettyPrint.HughesPJ' at L.hs:1...
02:48:37 <Iceland_jack> sigh
02:48:58 <merijn> > Just 5 `L.comma` Just True
02:49:01 <lambdabot>  Just (5,True)
02:51:17 <benj_> you could always use another unicode comma symbol in your operator <evil grin>
02:51:57 <killy9999> merijn: http://lpaste.net/100059
02:52:14 <killy9999> that's what I get when I try to decodeUtf8 my bytestring
02:52:37 <killy9999> where did I went wrong?
02:54:04 <merijn> killy9999: Mixing lazy and strict ByteString,
02:54:26 <merijn> killy9999: Data.Text.Encoding is strict, your ByteString appears to be lazy, so you want Data.Text.Lazy.Encoding
02:54:44 <killy9999> well, I have no control over that
02:54:54 <killy9999> ByteString comes from a libvrary interface
02:55:02 <killy9999> which I suppose can be casted somehow
02:56:41 <merijn> killy9999: You do have control, just use the decode from Data.Text.Lazy.Encoding like I just said
02:56:41 <killy9999> nope, I can't cast that
02:56:49 <killy9999> oh, OK
03:00:37 <killy9999> oh, that works
03:00:48 <killy9999> I'm saved :D
03:00:50 <killy9999> thanks
03:07:15 <killy9999> oh dear, and now a bug in GHC :-/
03:07:28 <killy9999> gotta fix it
03:08:09 <skypers_> hi
03:08:46 <skypers_> I’d like to have your opinion about this: how do you choose whether your need a data with a high order function or a typeclass to solve a polymorphic problem?
03:08:55 <skypers_> you*
03:09:06 <skypers_> I have my own reflexion about that, but I’d like hear from you
03:10:08 <mikeplus64> skypers_: sometimes you need constraints on the types used, or it's more efficient to have monomorphic types, so i those cases typeclasses are needed
03:10:27 <skypers_> can you be more precise?
03:11:16 <skypers_> I wonder this: if the polymorphic feature is “related” to the type, then it should be a data to me, but if it’s a feature not really related to any time, it should be a typeclass
03:11:21 <skypers_> what do you think of that?
03:11:38 <mikeplus64> you could have data V3 a = V3 !a !a !a, or data V3D = V3 {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double. operations on the latter will usually be faster than on the former because the doubles are unpackked
03:11:55 <skypers_> for instance, in my 3D engine, I have a Uniformable typeclass used to express OpenGL’s uniforms because Int, Float, (Float,Float) are instances and it’s to me the best thing to do
03:12:42 <mikeplus64> well, you can't make a polymorphic function without a typeclass for that case, so yeah, typeclasses are the best thing to do
03:12:45 <skypers_> whereas I could simply have written a data Uniformable and used combinators to pass from Int, Float, (Float,Float) -> Uniformable
03:12:52 <skypers_> ok
03:12:58 <skypers_> so my thinking is correct?
03:13:02 <skypers_> meaning:
03:13:15 <mikeplus64> well you're right, you could use a combinator instead, maybe
03:13:26 <mikeplus64> (maybe, depending on the particular case)
03:13:46 <skypers_> “if the polymorphic feature is significant to a type, it should be implemented as a data and combinators; if it’s not really significant nor relevant for that type, it should be a typeclass”
03:13:57 <skypers_> for Uniformable I use a typeclass
03:14:02 <skypers_> but for Shader for instance
03:14:10 <skypers_> I use a data + combinators
03:14:28 <skypers_> because the “Shader” feature is really strongly connected to what a Shader is
03:14:29 <mikeplus64> i'm not sure what you mean by that
03:14:50 <skypers_> whereas a Uniformable feature is not really connected to what a Int, or Float is
03:15:01 <skypers_> I mean
03:15:06 <skypers_> if Shader was a typeclass
03:15:10 <skypers_> I’d have a few instances
03:15:12 <skypers_> VertexShader
03:15:14 <skypers_> GeometryShader
03:15:15 <skypers_> and so on
03:15:21 <skypers_> and they’re ONLY shaders
03:15:22 <skypers_> nothing else
03:15:23 <mikeplus64> i'm not sure when "the polymorphic feature is significant to a type"
03:15:31 <skypers_> so a typeclass is not that good to me in that case
03:15:36 <skypers_> yeah hm
03:15:41 <skypers_> I’d rather say hm
03:15:53 <skypers_> the polymorphic feature caracterizes the type
03:16:01 <skypers_> here, a VertexShader is a Shader
03:16:10 <skypers_> so making Shader a typeclass might be wrong
03:16:19 <skypers_> this is how I think about that
03:16:19 <mm_freak> skypers_: in my current engine i keep the scene description polymorphic in the element type
03:16:34 <mm_freak> skypers_: only the renderer chooses the appropriate types
03:16:43 <mm_freak> data Scene a = …
03:16:47 <skypers_> yeah
03:16:50 <skypers_> so you use a data
03:16:59 <mm_freak> render :: (MonadIO m) => Consumer (Scene GLfloat) m r
03:17:00 <skypers_> my question is really about data+combinators vs. typeclass
03:17:23 <skypers_> I read something about that in a Widget lecture
03:17:40 <skypers_> saying that in OOP languages we’d implement that through class hierarchy and inheritance
03:17:50 <skypers_> whereas in Haskell it’s done through data and high order function
03:18:03 <skypers_> I think I got why a typeclass is boring in that case
03:18:19 <skypers_> I just want to be sure to correctly think about that, hence your opinion :)
03:19:05 <skypers_> well
03:19:10 <skypers_> got to go
03:19:13 <skypers_> thank you for your instance
03:19:29 <skypers_> skypers stays here, it’s my idleing me :)
03:19:40 <skypers_> so if you have anything else to add, just hl skypers :)
03:19:46 <skypers_> thank you again and have a nice day!
03:20:32 <mm_freak> skypers: i'm not entirely sure what you're asking
03:21:12 <mm_freak> skypers: in principle you can model shaders as an EDSL, similar to 'accelerate', but it's a lot of hard work
03:21:45 <Axman6> isn';t there something that does that already? gpipe or something?
03:21:54 <mm_freak> GPipe does, but it's horribly outdated
03:23:26 <no-n> how do you write multilines strings?
03:23:32 <no-n> multilined*
03:23:46 <Iceland_jack> > unlines ["hello", "world"]
03:23:47 <lambdabot>  "hello\nworld\n"
03:23:50 <mikeplus64> my shaders for my game (video at https://www.youtube.com/watch?v=L2kdblzK1do) were GLuints + a static list of uniforms (GLints) tagged with the type that they expect
03:23:53 <Iceland_jack> that's one way
03:24:08 <bennofs> no-n: http://www.haskell.org/haskellwiki/Cookbook/Lists_and_strings#Multiline_strings ?
03:24:20 <Iceland_jack> > concat ["hello\n", "world"]
03:24:21 <lambdabot>  "hello\nworld"
03:24:31 <mikeplus64> ie data Uniforms s where UCons :: !GLint -> !(Uniforms s) -> Uniforms (t -> s); UNil :: Uniforms (IO ())
03:24:40 <mikeplus64> then the function to upload them just became Uniforms s -> s
03:24:58 <no-n> meant multiline in the source-file, sorry. what bennofs posted works.
03:25:12 <mikeplus64> since it was implemented in a typeclass every iteration of it would be inlined, so there was no loop, which was nice
03:31:32 <mm_freak> wow, looks like a difficult game =)
03:31:54 <mm_freak> > unlines ["Hello", "world"]
03:31:55 <lambdabot>  "Hello\nworld\n"
03:36:45 * hackagebot casadi-bindings 1.8.0.0 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.8.0.0 (GregHorn)
03:41:29 <Benzi-Junior> anyone know about a good parsec 3 code example
03:48:14 <FreeFull> "My hamster chewed through a CAT cable last week; it took me three days to notice, so complete was my Zen immersion in creating a period-accurate replica of the first Galilean telescope, using only Haskell lenses."
03:51:41 <Iceland_jack> Is it possible to define an IsList instance for (length-indexed) Vectors?
03:52:12 <Peaker> Why does System.Process use "String" for everything? :(
03:52:37 <Benzi-Junior> parseCSV ....
03:52:47 <Iceland_jack> Peaker: process-extras
03:53:02 <merijn> Peaker: Because using ByteString is inconvenient on platforms that don't use ByteString for filesystem interaction (i.e. Windows)?
03:53:11 <merijn> Peaker: See System.Posix.Process
03:53:42 <merijn> At least, i thought that used ByteString
03:54:29 <Iceland_jack> there's also System.Posix.Process.ByteString
03:56:16 <Peaker> merijn, the problem with System.Posix.Process.ByteString is that it's lower-level than System.Process
03:59:40 <Peaker> Iceland_jack, thanks
04:08:08 <jaspervdj> Hmm is there a way to easily covert from Data.HashMap.Strict to Data.HashMap.Lazy and back again?
04:10:23 <mm_freak> jaspervdj: "convert"?
04:17:25 <Peaker> Iceland_jack, doh, I want to pass an environment to my process, but process-extras only has the stdin/stdout/stderr hooking, not the env hooking
04:17:32 <lieven_> jaspervdj: toList/fromList. This may be fairly inefficient.
04:17:40 <Peaker> something ought to provide the System.Process low-level API but with ByteString
04:17:52 <Iceland_jack> Peaker: oh painful
04:17:59 <Peaker> I'll just use System.Process with Handles
04:17:59 <john___> quit
04:18:24 <john___> exit
04:18:31 <mm_freak> lieven_: there is an easier function to convert between the two
04:18:32 <mm_freak> id
04:18:32 <Maior> john___: /quit
04:18:42 <Iceland_jack> String/ByteString/ByteString.Lazy/Text/Text.Lazy can be quite the PITA
04:18:47 <lieven_> mm_freak: lol
04:18:56 <john___> oh thank you, let me try
04:18:58 <mm_freak> hence my question:  "convert"?
04:19:16 <mm_freak> they are different APIs to the same thing
04:19:17 <Peaker> Iceland_jack, We need a type-class abstraction for commonalities
04:21:25 <no-n> are there timers in haskell out of the box?
04:21:59 <Maior> timer?
04:22:08 <no-n> you know, countdown
04:22:25 <no-n> something happens after 2 minutes or something
04:22:42 <Iceland_jack> @hoogle threadDelay
04:22:43 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
04:22:44 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
04:22:44 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
04:23:04 <no-n> thanks
04:23:09 <jaspervdj> mm_freak: What's convert? Which module is it in?
04:23:11 <Iceland_jack>     threadDelay (2 * 10^6) >> putStrLn "2 seconds have passed"
04:23:11 <Iceland_jack>  
04:23:21 <Kaidelong> what an unsatisfying type
04:23:21 <Peaker> what's the difference between spawning a process in the same group or in a new process group?
04:23:24 <quchen> threadDelay (2 * 10^6) >> putStrLn "at least 2 seconds have passed"
04:23:29 <jaspervdj> lieven_: Thanks but I'd need something more efficient -- it should be able to preserve the structure after all
04:23:37 <Kaidelong> @hoogle Int -> IO a -> IO ()
04:23:38 <lambdabot> Graphics.UI.GLUT.Callbacks.Global addTimerCallback :: Timeout -> TimerCallback -> IO ()
04:23:38 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
04:23:38 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
04:23:48 <Maior> :t TimerCallback
04:23:50 <lambdabot> Not in scope: data constructor `TimerCallback'
04:23:52 <Maior> er
04:23:54 <Iceland_jack> quchen: heh
04:23:57 <Maior> I don't mean that do I
04:24:30 <mm_freak> jaspervdj: it wasn't a function name, but a question ;)
04:24:43 <mm_freak> jaspervdj: how do you convert Int to Int? ;)
04:25:44 <jophish> Yo yo yo
04:26:14 <jaspervdj> mm_freak: id ;-)
04:26:36 <mm_freak> jaspervdj: now observe that id is fully polymorphic
04:26:44 <mm_freak> so you can use it to convert HashMap to HashMap
04:27:17 <mm_freak> in fact it can convert every type to itself =)
04:27:30 <notdan> I tihnk it should be easy to convert from lazy to strict and back and forth if you can access the internals of HashMap
04:27:52 <notdan> mm_freak: well tbh, the question was about converting a Lazy HashMap to a Strict one
04:27:55 <jaspervdj> mm_freak: Oh I get it now
04:28:06 <mm_freak> notdan: i know
04:28:09 <notdan> I don't :(
04:28:16 <mm_freak> notdan: they're the same type
04:28:45 <jaspervdj> I dove in the code of unordered-containers to search for it only to discover that mm_freak
04:28:51 <mm_freak> btw, id is such a flexible function…  you can use it to go from Data.Map.Lazy to Data.Map.Strict as well =)
04:28:58 <notdan> Oh
04:29:00 <notdan> they are!
04:29:01 <jaspervdj> Haha, thanks
04:29:21 <Peaker> "GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded"  Yuck!
04:30:05 <merijn_> Peaker: That makes sense, though
04:30:16 <Peaker> merijn_, it could spawn a posix thread if the epoll engine can't do it
04:30:30 <Peaker> (just to wrap the waitpid call)
04:30:50 <merijn_> Peaker: Isn't that what the point of -threaded is? Using multiple threads in the runtime...
04:30:57 <hpc> maybe you are waiting for thousands of processes to exit?
04:31:20 <merijn_> hpc: That's fine, wait can wait on multiple process at once
04:31:22 <Peaker> merijn_, no no, -threaded means multiple threads of Haskell execution
04:31:38 <Peaker> here it could just be a thin thread wrapper to wait
04:32:13 <Peaker> so only one thread of Haskell execution, can still avoid thread synchronization overhead for Haskell code
04:32:15 <user____1> 1GB of diskspace?!!
04:32:23 <Peaker> GHC is a fat-ass :(
04:32:34 <hpc> user____1: you need to download more ram
04:32:35 <user____1> why?
04:32:47 <user____1> but why?
04:33:04 <merijn_> user____1: Platform?
04:33:14 <mm_freak> Peaker: i always compile with -threaded
04:33:27 <merijn_> user____1: Because it ships, dynamic, static and profiled binaries of GHC and 52 or so packages?
04:33:30 <user____1> Platrom?
04:33:36 <mm_freak> Peaker: -threaded means to use the threaded RTS
04:34:04 <mm_freak> and i'm not sure why anyone would choose to use the non-threaded RTS
04:34:05 <merijn_> user____1: Are you talking about Haskell Platform, I meant
04:34:07 <user____1> o darn. Well, I'll give it a try
04:34:21 <user____1> merijn_: yes that what the site told to download
04:34:46 <merijn_> user____1: Right, well like I just said that has all I mentioned in it
04:35:04 <mm_freak> Peaker: note that it doesn't mean that your program is going to use multiple threads, but the run-time can use certain OS features to allow some operations not to block other haskell threads
04:35:39 <mm_freak> IMO the threaded RTS should become the default
04:36:01 <Peaker> mm_freak, the problem is that GHC's default is not -threaded, so I easily forget -threaded now and then, and then I'm going to get silly blocking bugs
04:36:23 <mm_freak> Peaker: i have -threaded in my skeleton =)
04:36:38 <Peaker> mm_freak, I can put OPTIONS -Wall, but not OPTIONS -threaded
04:36:57 <mm_freak> you can put 'ghc-options: -threaded -Wall' in your cabal file
04:37:17 <mm_freak> -threaded is a linker option, so it makes sense that you can't put it in OPTIONS
04:38:05 <Peaker> I always thought it could be nice to propagate demands to the linker from the compilation units..
04:38:47 <mm_freak> blame the booleanness of the usual command line interface
04:40:35 <user____1>  doubleMe x = x + x
04:40:35 <user____1> <interactive>:16:12: parse error on input `='
04:40:40 <user____1> ???
04:40:47 <user____1> this is from the book ^ ?
04:40:49 <mm_freak> user____1: put a "let" in front of that
04:40:58 <Iceland_jack> user____1: let doubleMe x = x + x
04:41:25 <mm_freak> user____1: this isn't a module in a file, but expressions on the command line, so what you wrote is a syntax error =)
04:41:39 <bennofs> user____1: Or put that in a file and load the file with GHCi (then you don't need the let), like so: :l <filename>.hs
04:42:05 <user____1> ah
04:42:09 <user____1> why the difference?
04:42:15 <Iceland_jack> user____1: When you define a function in a .hs file, you write
04:42:15 <Iceland_jack>     doubleMe x = x + x
04:42:15 <Iceland_jack> When in GHCi however you need to prefix it with ‘let’
04:42:15 <Iceland_jack>     ghci> let doubleMe x = x + x
04:42:18 <Iceland_jack>     ghci> doubleMe 5
04:42:21 <Iceland_jack>     10
04:42:24 <Iceland_jack>     
04:42:38 <mm_freak> user____1: in principle there is no difference
04:42:52 <user____1> pfff
04:42:52 <mm_freak> your file begins with:  module MyModule where …
04:43:02 <Iceland_jack> user____1: Such is life :)
04:43:04 <mm_freak> the 'where' allows the kind of syntax you were using
04:43:19 <user____1> ah
04:43:58 <bennofs> hmm, I never thought about it from that standpoint, it now suddenly makes sense :)
04:44:09 <mm_freak> it's just that in GHCi you don't define a module, so there is no 'where' scope to allow the syntax
04:44:30 <makalu> what is cabal's separator for "include-dirs"
04:44:48 <Iceland_jack> user____1: If you want to define a multi-line function in GHCi you need braces
04:44:48 <Iceland_jack>     ghci> let { myDouble :: Int -> Int; myDouble x = x + x }
04:44:48 <Iceland_jack>     ghci> myDouble 5
04:44:48 <Iceland_jack>     10
04:44:58 <mm_freak> makalu: just a guess, but the usual separator is whitespace
04:44:58 <Iceland_jack> For future reference
04:45:42 <makalu> mm_freak: doesn't work
04:46:01 <mm_freak> makalu: then it's probably commas
04:46:12 <mm_freak> look into the user guide for the exact syntax
04:49:19 <user____1> is there haskell mode for emacs?
04:49:27 <Iceland_jack> yes, haskell-mode :)
04:49:38 <Iceland_jack> It's quite simple but very nice to use
04:50:40 <kazagistar> has anyone managed to solve "unknown symbol `__objc_empty_vtable'" errors when compiling GLFW-b on OSX? google isn't turning up anything, and it is a dep of lamdu
04:50:42 <user____1> my emacs don't have it
04:51:00 <Iceland_jack> user____1: You may be able to install it using your system's package manager
04:51:17 <user____1> windows
04:51:45 <Iceland_jack> You can try to do M-x (require 'haskell-mode) and see what that gives you
04:51:52 <Iceland_jack> no sorry, M-:
04:52:26 <Iceland_jack> Otherwise you're going to have to install it either through your Emacs package manager (possibly ELPA if you're on version 24)
04:52:35 <Iceland_jack> or just download and load it manually
04:52:48 <user____1> I got 24
04:53:34 <Iceland_jack> user____1: you should be able to search for “ELPA tutorial” and find a way of installing haskell-mode through that
04:55:11 <mirpa> kazagistar: have you seen this: https://github.com/bsl/bindings-GLFW/issues/8 ?
04:55:58 <Peaker> user_1, in ghci, you can also use   :{   and :}  to start/end a multiline input
04:57:18 <Iceland_jack> Peaker: that's rather painful to use because unless you use braces it needs to be correctly indented (also prompt2 is annoying if you have many imports and don't customize it)
04:58:40 <kazagistar> mirpa: yeah, unfortunately, the conclusion looks like "wait for 7.8", which sucks :(
05:00:16 <user____1> Iceland_jack : it worked
05:00:45 <Iceland_jack> okay :)
05:09:03 <user____1> tab don't work in haskel-mode
05:09:28 <aloiscochard> hey hackers, I'm completely lost, I'm trying to install a package I wrote at home on my job machine... but I'm cabal hell
05:09:35 <aloiscochard> anyone could help me solving this: http://lpaste.net/100062
05:09:56 <aloiscochard> I tried to take criterion 0.9 (from source), it got better, but than representable-functor don't compile :-(
05:10:04 <aloiscochard> I really don't know how to fix this
05:10:11 <mirpa> user____1: to indent?
05:10:39 <user____1> mirpa: yes
05:11:50 <mirpa> user____1: this is what I have in ~/.emacs http://lpaste.net/100063
05:13:22 <mirpa> aloiscochard: are you using sandbox?
05:14:33 <user____1> thanks mirpa
05:14:53 <user____1> is indentation meaningful to the compiler?
05:15:05 <Iceland_jack> yes
05:15:19 <user____1> does it suck?
05:15:23 <Iceland_jack> nope
05:15:33 <user____1> hmm
05:16:02 <Iceland_jack> Don't worry about the syntax for now :)
05:19:43 <haasn> no, it's wonderful :)
05:20:11 <supki> aloiscochard: it looks like you have too tight bounds on something
05:22:04 <user____1> ok, now I compiled soemthign and got many errors
05:22:24 <Iceland_jack> Great! That's a good way to learn :)
05:22:37 <Iceland_jack> put your code and errors on lpaste
05:22:37 <Iceland_jack> @lpaste
05:22:37 <Iceland_jack>  
05:22:38 <lambdabot> Haskell pastebin: http://lpaste.net/
05:22:43 <user____1> oh now it compiled
05:22:59 <user____1> just a spelling error in function name
05:23:16 <user____1> o wow, that was easy
05:23:38 <user____1> why text books make such a big deal out of IOs and monads and stuff
05:23:46 <user____1> I just wrote it like I would in C
05:23:49 <user____1> and it work
05:24:14 <Iceland_jack> IO isn't that difficult in Haskell, the main difficulty is that you need some extra code to combine pure functions and impure functions
05:24:43 <Iceland_jack> But things like
05:24:43 <Iceland_jack>     main = do
05:24:43 <Iceland_jack>       putStrLn "What is your name?"
05:24:43 <Iceland_jack>       line <- getLine
05:24:46 <Iceland_jack>       putStrLn ("Your name is " ++ line)
05:24:49 <Iceland_jack> isn't that hard
05:24:56 <tdammers> user____1: if "it works" is enough for you, then Haskell doesn't have a lot to offer for you
05:25:58 <mm_freak> user____1: note that a single error can span pages with GHC =)
05:26:20 <tdammers> mm_freak: the same goes for C++. I prefer Haskell errors though.
05:26:24 <mm_freak> it takes a while to get used to GHC's error messages, but once you're used to them they are amazing
05:26:35 <mirpa> mm_freak: C++ teplate errors are worse
05:26:54 <bennofs> That's the difference between C++ template errors and GHC errors: You can get used to C++ template errors, but they still suck :)
05:26:59 <mm_freak> "worse"?  it was a positive statement
05:27:17 <mm_freak> GHC's error messages are long and useful, as soon as you know how to read them
05:27:35 <tdammers> well, GHC's error messages can be slightly confusing at times
05:27:50 <tdammers> takes some experience to write code that produces more useful ones
05:27:57 <mm_freak> the good thing is:  you start by reading the first line…  in most cases that's enough to fix the error
05:28:04 <mirpa> not always... sometimes ghc suppreses warnings in favour of type error
05:28:05 <mm_freak> if not, you consume more and more lines of the error message
05:28:17 <mm_freak> mirpa: it doesn't do that for me
05:29:04 <bennofs> Is there a way to tell cabal to generate as much errors as possible, i.e not stop on the first error (especially when compiling with -Wall -Werror)
05:29:20 <mirpa> mm_freak: for example when you accidentally shadow name (I've reported that on ghc issue tracker)
05:29:52 <mm_freak> oh, i don't even have that warning enabled, i think
05:30:25 <mirpa> problem was that warning is suppressed even when enabled because there is type error
05:31:00 <mm_freak> well, that sounds like a bug to me, not a feature
05:31:13 <mirpa> but after some practice haskell errors are quite good
05:31:22 <mm_freak> GHC errors are
05:31:32 <k00mi> some GHC errors have misguiding suggestions in them, like the "add an instance declaration for ..."
05:31:37 <Kaidelong> I've been thinking of ways to improve type errors
05:31:38 <k00mi> that's almost never the fix
05:31:45 <merijn> k00mi: True
05:32:02 <mm_freak> k00mi: that's why i said, you need to get used to them =)
05:32:09 <merijn> k00mi: The only suggestion that's actually good are FlexibleContexts (and maybe FlexibleInstances)
05:33:01 <bergmark> missing pragmas are almost always correct from my experience
05:33:07 <bennofs> -fno-helpful-errors should disable suggestions :) Maybe we should suggest that flag to beginners
05:33:27 <bennofs> Also, if you mispell a name, suggesting the correct name/module/package is often correct too
05:33:31 <bergmark> but when it says IncoherentInstances you should probably think twice :-)
05:33:38 <Kaidelong> essentially providing a mechanism with "if my parameter is being used as if though it has this type, or if I am being used as if I'm this type, print this programmer-written error instead, and put the actual error in parenthesis" seems like it would solve a lot of issues
05:33:50 <mm_freak> btw, -fconcise-errors would be helpful to non-beginners as well
05:34:07 <mm_freak> Type error:  Expected T, got U
05:34:17 <mm_freak> No instance: C T
05:34:18 <Kaidelong> like (.) could be made aware of the common error f . g . h x
05:34:35 <bennofs> mm_freak: does that flag exist?
05:34:38 <mm_freak> no
05:34:43 <Kaidelong> and say "right side was a value instead of a function, perhaps you forgot to add $"
05:34:55 <bennofs> :| -fno-helpful-errors exists though
05:34:57 <DarkCthulhu> <newbie question> When doing a list comprehension involving 2 lists x and y, how would I do it such that the first elements of x and y are combined, then the second elements of x and y, and so on...?
05:35:18 <lieven_> DarkCthulhu: zip
05:35:19 <mirpa> hugs has some pretty good error messages
05:35:26 <mm_freak> but i would use it, if it existed…  don't disable suggestions, just make GHC less noisy
05:35:39 <Iceland_jack> DarkCthulhu:
05:35:39 <Iceland_jack> > zip [1..] "test"
05:35:41 <lambdabot>  [(1,'t'),(2,'e'),(3,'s'),(4,'t')]
05:36:14 <DarkCthulhu> I want to combine tham in a particular way though, the way the comprehension would.
05:36:21 <bennofs> > [ x + y | (x,y) <- zip [1..10] [4..13] ]
05:36:22 <lambdabot>  [5,7,9,11,13,15,17,19,21,23]
05:36:39 <bennofs> > zipWith (+) [1..10] [4..13]
05:36:41 <lambdabot>  [5,7,9,11,13,15,17,19,21,23]
05:36:47 <DarkCthulhu> ahhhh
05:36:52 <merijn> That or parallel list comprehensions
05:36:53 <Iceland_jack> You can also enable an extension called ParallelListComp which allows you to write
05:36:53 <Iceland_jack>     [ x + y | x <- [1..10] | y <- [4..13] ]
05:36:53 <Iceland_jack> rather than
05:36:53 <Iceland_jack>     [ x + y | (x, y) <- zip [1..10] [4..14] ]
05:37:02 <Rc43_> Hello.
05:37:12 <DarkCthulhu> If I want to do a string concatenation between the lements?
05:37:14 <DarkCthulhu> *elements
05:37:28 <bennofs> DarkCthulhu: use another operator instead of (+) ?
05:37:33 <Iceland_jack> DarkCthulhu: Do you mean if you have two lists of strings?
05:37:38 <DarkCthulhu> yes
05:37:39 <Iceland_jack> then you just do what bennofs said
05:37:51 <Rc43_> Suppose, I want to define very simple lens library. What is the simplest definition of "view"?
05:38:00 <DarkCthulhu> okay, I use the ++ operator, but I also have another string in between that I need to concat
05:38:11 <Iceland_jack> DarkCthulhu: Then you just do that
05:38:15 <Iceland_jack>     str1 ++ " " ++ str2
05:38:42 <Iceland_jack> > [ str1 ++ " " ++ str2 | (str1, str2) <- zip ["hello", "good bye"] ["world", "universe"] ]
05:38:43 <lambdabot>  ["hello world","good bye universe"]
05:39:07 <DarkCthulhu> got it! thank you all!
05:39:22 <Iceland_jack> This is how you'd do that using parallel-list comprehensions
05:39:22 <Iceland_jack> > [ str1 ++ " " ++ str2 | str1 <- ["hello", "good bye"] | str2 <- ["world", "universe"] ]
05:39:23 <lambdabot>  ["hello world","good bye universe"]
05:39:35 <tdammers> > let (+-+) a b = a ++ " " ++ b in "Hello," +-+ "world"
05:39:36 <lambdabot>  "Hello, world"
05:39:51 <Iceland_jack> And this is how you'd do it without list comprehensions
05:39:52 <Iceland_jack> > zipWith (\str1 str2 -> str1 ++ " " ++ str2) ["hello", "good bye"] ["world", "universe"]
05:39:53 <lambdabot>  ["hello world","good bye universe"]
05:40:35 <DarkCthulhu> zipWith.. cool!
05:41:08 <Iceland_jack> Or using tdammers's definition :)
05:41:08 <Iceland_jack> > let a +-+ b = a ++ " " ++ b in zipWith (+-+)  ["hello", "good bye"] ["world", "universe"]
05:41:09 <lambdabot>  ["hello world","good bye universe"]
05:41:33 <Iceland_jack> @ty zipWith
05:41:34 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
05:41:41 <Iceland_jack> Does the type of ‘zipWith’ make sense DarkCthulhu?
05:42:38 <DarkCthulhu> Iceland_jack: Trying to understand. \str1?
05:42:50 <DarkCthulhu> typo?
05:43:29 <DarkCthulhu> > zipWith (str1 str2 -> str1 ++ " " ++ str2) ["hello", "good bye"] ["world", "universe"]
05:43:30 <lambdabot>  Pattern syntax in expression context:
05:43:30 <lambdabot>      str1 str2 -> str1 ++ " " ++ str2
05:44:16 <DarkCthulhu> hmm.. that \ prevents immediate evaluation or something? I'm still at the beginning of LYAH, haven't seen that before
05:44:21 <mm_freak> in haskell \ is a lambda with a broken leg =)
05:44:30 <DarkCthulhu> ah
05:44:31 <lieven_> it introduces a function without giving it a name
05:44:32 <mm_freak> see:  \ vs. λ
05:44:37 <Cale> \x -> y is the function which given x produces the result y
05:44:41 <Iceland_jack> DarkCthulhu: \ is a function
05:44:46 <Iceland_jack> or the start of one
05:44:52 <Iceland_jack> > (\x -> x + x) 15
05:44:53 <lambdabot>  30
05:45:30 <Iceland_jack> > (\str1 str2 -> str1 ++ " " ++ str2 ++ "!") "hello" "again" -- DarkCthulhu
05:45:31 <lambdabot>  "hello again!"
05:46:16 <aloiscochard> mirpa: yes I'm using sandbox
05:46:20 <mm_freak> does GHC allow actual lambdas?
05:46:26 <mm_freak> > (λx -> x) 5
05:46:27 <lambdabot>  Pattern syntax in expression context: λx -> x
05:46:28 <aloiscochard> supki: mmm... maybe base, that's the only bound I have
05:46:30 <Iceland_jack> no
05:46:30 <idontgetoutmuch> merijn: Consider a group as category with a single object and consider the groups Z_2 and Z_3
05:46:31 <DarkCthulhu> so the anonymous function here takes 2 params.
05:46:36 <Iceland_jack> DarkCthulhu: yes
05:46:53 <DarkCthulhu> can there be a space between \ and the parameter name?
05:46:54 <aloiscochard> supki: here is my conf: base >=4.6 && <4.7, async, bytestring, containers, criterion, HTTP, monad-loops, monoid-statistics, monoids, mwc-random, primitive, stm, transformers
05:46:56 <user____1> No instance for (Num (IO t0))
05:46:58 <Iceland_jack> DarkCthulhu: yes
05:46:58 <Iceland_jack>  
05:47:01 <aloiscochard> supki: something obvious?
05:47:03 <Iceland_jack> You can make an anonymous function with a single paramter
05:47:03 <Iceland_jack> > (\x -> 5 * x) 10
05:47:04 <lambdabot>  50
05:47:19 <Cale> > (\ x -> 5 * x) 10
05:47:21 <lambdabot>  50
05:47:21 <idontgetoutmuch> merijn: then the only group homomorphism is the one which maps all elements to the identity element
05:47:22 <Iceland_jack> Or one with two parameters
05:47:22 <Iceland_jack> > (\x y -> 2*x + 2*y) 10 4
05:47:23 <lambdabot>  28
05:47:41 <Iceland_jack> user____1: You're probably trying to add two IO operations
05:47:41 <mm_freak> DarkCthulhu: spacing is generally allowed between tokens, but it's rather uncommon to use a space after the introducing lambda
05:47:46 <Iceland_jack> user____1: You'll have to show us the code
05:47:47 <supki> aloiscochard: I'd try  cabal install --constraint='containers installed'  to understand what causes a downgrade
05:47:50 <CaptainK> Iceland_jack: didn't know you could do that with more than one element
05:48:12 <aloiscochard> supki: awesome, I'll give that a try, ty!
05:48:12 <Iceland_jack> CaptainK: Do you mean create a anonymous function with two arguments?
05:48:14 <bennofs> mm_freak: I think you need UnicodeSyntax for that, no?
05:48:16 <Cale> You can also pattern match (against one particular constructor)
05:48:25 <Cale> > (\(x,y) -> x) (3,4)
05:48:26 <DarkCthulhu> Understood. I thought the one with the space would be preferred, as it indicates "lambda, param1, param2" better imo.
05:48:27 <lambdabot>  3
05:48:27 <Iceland_jack> bennofs: Even with UnicodeSyntax it doesn't work I think
05:48:40 <bennofs> hmm, right
05:48:49 <user____1> ok
05:48:54 <pjdelport> re. Unicode lambda, https://ghc.haskell.org/trac/ghc/ticket/1102
05:49:03 <mm_freak> :t liftM2 (+)
05:49:04 <lambdabot> (Monad m, Num r) => m r -> m r -> m r
05:49:07 <Cale> DarkCthulhu: Well, it's delimiting punctuation like parens and commas and stuff
05:49:13 <idontgetoutmuch> merijn: Taking 0 as the identity and defining f(1) = 1 then 0 = f(0) = f(1 + 1) /= f(1) + f(1) = 2
05:49:19 <Cale> DarkCthulhu: so the space usage around it is arbitrary
05:49:23 <aloiscochard> supki: indeed, now it looks like 'monoids' is posing problems: (conflict: monoids => containers>=0.2 && <0.5)
05:49:43 <CaptainK> Iceland_jack: yes
05:49:45 <aloiscochard> supki: maybe I should try to get last version of monoids from source?
05:49:57 <DarkCthulhu> Cale: a matter of getting used to it I guess. :) I'll stick to the no-spaces definition.
05:50:07 <Iceland_jack> CaptainK: Writing
05:50:07 <Iceland_jack>     \x y -> ...
05:50:07 <Iceland_jack> is the same as doing
05:50:07 <Iceland_jack>     \x -> \y -> ...
05:50:07 <CaptainK> Cale: cool, you can map it too...Haskell rocks!
05:50:10 <Iceland_jack> :)
05:50:40 <supki> aloiscochard: hackage page for monoids says it's deprecated in favor of reducers
05:51:00 <CaptainK> and point-free style kicks ass too
05:51:00 <mm_freak> DarkCthulhu: not a definition, just a convention =)
05:51:02 <user____1> http://lpaste.net/100064
05:51:25 <CaptainK> where you can use it anyway
05:51:26 <Iceland_jack> user____1: main is an IO function
05:51:31 <Iceland_jack> You'll want to use print
05:51:34 <aloiscochard> supki: you are me hero! a shame I missed that in first place...
05:51:37 <Iceland_jack>     main = print (func1 1 2 3)
05:51:39 <mm_freak> user____1: try main = print (func1 1 2 3)
05:51:42 <aloiscochard> supki: thank you, I'm moving forward now :-)
05:52:07 <CaptainK> can you use placeholders in those temp functions like /x,_ ?
05:52:09 <pjdelport> CaptainK: also, generally speaking, "f x y ... = [...]" is equivalent to "f = \x y ... -> [...]"
05:52:19 <Sonderblade> CaptainK: try factor :) point-free all the way
05:52:22 <Iceland_jack> CaptainK: You wouldn't use a comma, but sure
05:52:24 <DarkCthulhu> How exactly does one use ideone with haskell code? I tried assigning to main, but it errors out saying it expects an "IO t0"
05:52:32 <pjdelport> it's syntax sugar all the way down
05:52:33 <mm_freak> user____1: (simplified):  func1 1 2 3 :: Integer, print :: Integer -> IO (), print (func1 1 2 3) :: IO (), main :: IO ()
05:52:41 <Iceland_jack> DarkCthulhu: You need an action, a value by itself it not an action
05:53:01 <Iceland_jack> so if you have a number ‘num = 5’ you can bind it to main by
05:53:01 <Iceland_jack>     main = print num
05:53:13 <Iceland_jack> s/bind it to main/print it/
05:53:56 <CaptainK> very nice
05:54:02 <mm_freak> Iceland_jack: depends on your viewpoint, i guess…  to me "main" is totally a value =)
05:54:06 <Iceland_jack> heh :)
05:54:11 <CaptainK> all kinds of way to make the code tight
05:54:18 <CaptainK> like with $
05:54:22 <Iceland_jack> CaptainK: If you want to print more than one thing (or perform more than one action) you can do
05:54:22 <Iceland_jack>     main = do
05:54:22 <Iceland_jack>       print 4
05:54:22 <Iceland_jack>       print 'a'
05:54:34 <ciaranm> eww
05:54:40 <DarkCthulhu> Where does the do end?
05:54:54 <mm_freak> DarkCthulhu: when its indented block ends
05:55:00 <Iceland_jack> DarkCthulhu: When the indented block ends
05:55:17 <mm_freak> just read it like a poem…  it's in most cases the right way to read haskell code
05:55:36 <DarkCthulhu> ah, okay. That print statement worked. I haven't gotten to the IO chapters in LYAH. I thought there was some "monad" complication though.
05:56:00 <Iceland_jack> DarkCthulhu: Clear your mind of monads :) what I wrote it doesn't look tricky does it?
05:56:21 <Iceland_jack> Lists are monads too, yet lists aren't tricky
05:56:25 <DarkCthulhu> Looks imperative-y ;)
05:56:30 <Iceland_jack> Exactly :)
05:56:37 <mm_freak> DarkCthulhu: IO is imperative
05:56:40 <Cale> A block starts at the first non-whitespace character following one of the layout keywords: "do", "where", "let", "of", which sets the column that the rest of the block must start in, and the block ends as soon as a line begins in a column shallower than that
05:57:27 <mm_freak> Cale: that's the problem with technical (as opposed to intuitive) explanations…  it's easy to get it wrong =)
05:57:34 <mm_freak> do print (
05:57:35 <mm_freak> 3)
05:57:57 <mm_freak> in fact even this works:
05:58:01 <mm_freak>      do print (
05:58:02 <mm_freak> 3)
05:58:05 <user____1> mm_freak: that worked, but I tried to do soomething do{ func1 1 2 3; putStrLn "hi"} and that doesn't work
05:58:18 <mm_freak> user____1: because it's a type error =)
05:58:22 <Cale> mm_freak: Yeah, the actual rule is more complicated to describe
05:58:22 <Iceland_jack> user____1: ‘func1 1 2 3’ is not an action
05:58:30 <Cale> mm_freak: (but it probably shouldn't be)
05:58:36 <mm_freak> Iceland_jack: how do you know?
05:58:45 <user____1> why is it a type error?
05:58:46 <Iceland_jack> mm_freak: Because user____1 pasted the code
05:58:52 <mm_freak> Iceland_jack: you still don't know
05:59:07 <Iceland_jack> mm_freak: Come on, this sort of thing is not helpful
05:59:33 <mm_freak> user____1: when you write 'do x; y', both x and y must be IO actions
06:00:37 <user____1> but I heard that the last action is the value of the expression
06:00:55 <Clint> what are you expecting that do block to do?
06:00:59 <mm_freak> user____1: 'do x; y' is an action, and its result value is defined by y
06:01:15 <user____1> so why x should be IO?
06:01:20 <mm_freak> given two actions x and y, 'do x; y' is the action that performs x, then y and results in y's result
06:01:25 <mm_freak> x /must/ be IO
06:01:27 <Iceland_jack> user____1: One way to create an ‘IO action’ is by applying ‘print’ to things like numbers or string
06:01:39 <Iceland_jack> user____1: That's the point of do(-notation)
06:01:53 <benj_> you should work out why it doesn't type-check by expanding the do-notation sugar, not by hand-wavy arguments about what is an "action"
06:02:16 <mm_freak> user____1: i believe it would be most helpful to desugar the do-notation here:  'do x; y' is exactly the same thing as 'x >> y'
06:02:21 <mm_freak> user____1: now look at the type of (>>):
06:02:26 <mm_freak> (>>) :: IO a -> IO b -> IO b
06:02:34 <Iceland_jack> benj_: Then you have to get into what a monad is, user____1 is on their first chapter of LYAH
06:02:38 <Cale> user____1: The value of the do-expression is an action constructed by composing of all the IO actions in it. The *result of executing* that action is the same as the result of executing the last action in the block (after executing the others of course)
06:02:42 <user____1> I don't know (>>)
06:02:42 <Iceland_jack> or just specialize the types :)
06:02:50 <mm_freak> user____1: you do now =)
06:02:57 <mm_freak> user____1: you have chosen y = putStrLn "hi"
06:03:05 <mm_freak> x >> putStrLn "hi"
06:03:12 <mm_freak> putStrLn "hi" :: IO ()
06:03:23 <Iceland_jack> Keep in mind that user____1 also doesn't know about the difference between (>>) and >>
06:03:45 <FreeFull> user____1: Do you know >>= and lambdas?
06:03:56 <user____1> i know lambda
06:04:09 <mm_freak> i strongly believe that "overhelping" is a thing…  allow user____1 to figure things out =)
06:04:17 <user____1> don't know haskel specific functions
06:04:24 <FreeFull> user____1: Have you read LYAH?
06:04:31 <mm_freak> for now (>>) is a predefined operator to chain IO actions
06:04:43 <user____1> reading it now FreeFull
06:04:44 <Iceland_jack> mm_freak: What would overhelping be in this case? :)
06:05:21 <benj_> Iceland_jack, you really don't have to get into what a monad is, just the signature of >> (as mm_freak just wrote) should suffice
06:05:23 <FreeFull> user____1: You should probably just keep reading it, I found the explanations for things in it very clear myself when I was learning Haskell
06:05:27 <mm_freak> Iceland_jack: assuming that beginners have no knowledge and are completely unable to figure things out without help =)
06:05:31 <user____1> so basically what I understand is that do is an operation of type  IO a -> IO b -> IO b
06:05:55 <mm_freak> user____1: when you write "do x; y", it gets rewritten to "x >> y"
06:06:16 <mm_freak> try it out:  main = putStrLn "hello" >> putStrLn "world"
06:06:53 <user____1> can there by type IO a -> b -> IO a ?
06:07:04 <mm_freak> user____1: what would that do?
06:07:05 <FreeFull> user____1: What would happen to the b?
06:07:09 <Iceland_jack> user____1: sure but it wouldn't be very useful
06:08:04 <mm_freak> user____1: whenever you have a question like this, just try to write such a function =)
06:08:16 <mm_freak> begin with:  f :: IO a -> b -> IO a
06:08:24 <mm_freak> f someAction something = ?
06:09:03 <SLi> :t const :: (IO a -> b -> IO a)
06:09:04 <lambdabot> IO a -> b -> IO a
06:09:13 <user____1> name <- getLine; 1; print "name"
06:09:29 <Iceland_jack> user____1: You cannot put ‘1’ there
06:09:30 <mm_freak> user____1: i'll assume a "do" in front of that
06:09:34 <mm_freak> and then it's a type error
06:09:37 <Iceland_jack> Just as before
06:09:39 <Iceland_jack> mm_freak: There is also such a thing as information overloading :) I'm not sure desugaring do-notation is the most effective strategy (for the purposes of the first chapters of LYAH knowing print/putStrLn/getLine and the do-notation should suffice). Of course opinions can differ
06:09:50 <Iceland_jack> *overflow!
06:10:07 <mm_freak> Iceland_jack: i'm not desugaring do-notation, i'm desugaring a specific instance to introduce the types
06:10:33 <mm_freak> and i've done that in actual haskell workshops
06:10:34 <user____1> its ok, Iceland_jack , it help
06:10:43 <Iceland_jack> Okay :) that's all that matters
06:11:25 <user____1> IO a -> b is something that take IO and output type b
06:11:27 <mm_freak> Iceland_jack: don't worry…  people learn much better when given mental challenges =)
06:11:37 <mm_freak> user____1: yes
06:11:55 <mm_freak> user____1: but 'IO a -> b -> IO a' is something that takes an 'IO a' and a 'b' and gives an 'IO a'
06:11:56 <user____1> b -> IO a is something that take type b and output IO of type a?
06:12:08 <mm_freak> yes
06:12:33 <mm_freak> also remember the currying rule:  a -> b -> c = a -> (b -> c)
06:13:11 <mm_freak> but typically it's enough to read it as "takes a and b and gives c" =)
06:13:35 <user____1> so if I would write it in function order, like z=((f x) y) it is: IO a=((f IOa) b)
06:13:56 <mm_freak> user____1: what's the type of x?
06:14:15 <user____1> IOa
06:14:31 <mm_freak> (add a space)
06:14:38 <user____1> IO a
06:14:44 <Iceland_jack> Does user____1 understand what the ‘a’ is?
06:14:51 <user____1> generic type
06:14:52 <mm_freak> Iceland_jack: probably not yet
06:15:03 <mm_freak> but it's ok =)
06:15:22 <mm_freak> user____1: have you written 'f'?
06:15:49 <user____1> f?
06:15:57 <mm_freak> f :: IO a -> b -> IO a
06:16:04 <mm_freak> f someAction something = ?
06:16:20 <user____1> ah
06:16:26 <mm_freak> it takes 'someAction :: IO a' and 'something :: b'…  what's its result?
06:16:43 <user____1> ah
06:16:55 <user____1> f x y = putStrLn "hi"
06:17:04 <user____1> f x y = putStrLn x
06:17:16 <mm_freak> putStrLn :: String -> IO ()
06:17:19 <mm_freak> x :: IO a
06:17:22 <mm_freak> IO a ≠ String
06:17:24 <mm_freak> so type error =)
06:17:41 <mm_freak> try again =)
06:19:01 <user____1> isn't IO always IO () ?
06:19:09 <user____1> can there be IO a?
06:19:37 <Cale> user____1: There can
06:19:42 <Cale> :t getLine
06:19:43 <lambdabot> IO String
06:20:06 <user____1> that input
06:20:25 <Cale> user____1: You can write things like  mapIO :: (a -> b) -> IO a -> IO b;  mapIO f x = do v <- x; return (f v)
06:20:42 <mm_freak> user____1: if you pass 'getLine' to f, then the 'a' becomes String for that particular case
06:20:51 <mm_freak> f :: IO a -> b -> IO a
06:20:56 <mm_freak> f getLine :: b -> IO String
06:21:01 <zipper> Could someone explain to me why in this case the program takes input before running main or something https://gist.github.com/urbanslug/9051333
06:21:27 <Cale> zipper: line buffering
06:22:11 <Cale> zipper: you can either hFlush stdout after each putStr' or just hSetBuffering stdout NoBuffering
06:22:36 <Iceland_jack> zipper:
06:22:36 <Iceland_jack>     import System.IO
06:22:36 <Iceland_jack>     ...
06:22:36 <Iceland_jack>     main = do
06:22:39 <Iceland_jack>         putStr "Hello? "
06:22:42 <Iceland_jack> 	hFlush stdout
06:23:00 <zipper> Cale: I read about buffering while scheming through that section
06:23:21 <zipper> skimming
06:23:32 <mm_freak> scheming =)
06:24:00 <zipper> mm_freak: Natural languages are weird
06:24:08 <mm_freak> hehe
06:24:18 <murgaan> What's the best way to show you guys about 2 or three lines of code for reference?
06:24:29 <zipper> Cale: So instead of return() I should flush buffers?
06:24:46 <Iceland_jack> murgaan: lpaste
06:24:48 <Iceland_jack> @where lpaste
06:24:48 <lambdabot> http://lpaste.net/new/haskell
06:25:38 <Iceland_jack> zipper: ‘return ()’ has nothing to do with flushing
06:25:56 <mm_freak> zipper: btw, your putStrLn' function is wrong
06:26:23 <zipper> mm_freak: yeah fails to give me a new line, why?
06:26:34 <user____1> why main = do... name <- getLine (which evalute to String) , is ok and "String" isn't?
06:26:34 <zipper> Iceland_jack: So I should flush in main?
06:26:37 <mm_freak> zipper: because it only does that for empty lines
06:26:38 <Iceland_jack> zipper: Because you call ‘putStr’ in the ‘recursive’ case
06:26:48 <mm_freak> zipper: otherwise it acts just like putStr'
06:27:07 <mm_freak> s/empty lines/empty strings/
06:27:10 <zipper> mm_freak: Ah I see
06:27:24 <zipper> mm_freak: Error in typing
06:27:32 <mm_freak> zipper: you don't need putStrLn' to have two cases anyway
06:27:46 <mm_freak> putStrLn' xs = …
06:27:54 <zipper> I should've used it to call putStr' (x:xs)
06:28:30 <zipper> mm_freak: What if it gets to the end of the string?
06:28:57 <mm_freak> zipper: think more semantically:  putStrLn' is composed of two actions…  what are those?
06:29:26 <zipper> It should be a new line and a recursive call to itself
06:29:34 <Iceland_jack> zipper: It shouldn't be recursive
06:29:46 <mm_freak> zipper: actions as in IO actions
06:29:55 <Iceland_jack> *shouldn't have to be, anyway
06:30:17 <zipper> Ok I updated it
06:30:50 <Iceland_jack> zipper: If you do
06:30:50 <Iceland_jack>     putStrLn' "hello"
06:30:50 <Iceland_jack> it's the same as
06:30:50 <Iceland_jack>     putStr' "hello"
06:31:06 <zipper> mm_freak: putChar and putStr'
06:31:17 <mm_freak> zipper: exactly
06:31:30 <Iceland_jack> zipper: What you want is to ‘output the string’ and then ‘output a newline’
06:31:40 <Iceland_jack> Now put that into code :)
06:31:41 <zipper> Iceland_jack: Yes
06:31:51 <mm_freak> zipper: what Iceland_jack is explaining in other words is:  it's safe to read "=" as "is identical to" in haskell =)
06:32:02 <zipper> but putStr' is not same as putStrLn'
06:32:10 <orzo> i have an io action im already using in my code, but i'd like to change its behavior so that its side-effects only happen the first time it is called.  Unfortunately it is not passed any state paramaters where it can keep record.  Intuitively, i don't think this shoudl be a problem for an IO action... but i dont see a nice way to do what i want
06:32:18 <mm_freak> in your earlier version you had:  putStrLn' ('h' : "ello") = putStr' ('h' : "ello")
06:32:38 <Iceland_jack> zipper: That's right, but this definition
06:32:38 <Iceland_jack>     putStrLn' (x:xs) = putStr' (x:xs)
06:32:38 <Iceland_jack> means that
06:32:38 <Iceland_jack>     putStrLn' "hi" == putStr' "hi"
06:33:03 <Iceland_jack> (that is not Haskell's (==) before people get on my case) :)
06:33:50 <dawik> > "hi"
06:33:51 <lambdabot>  "hi"
06:34:18 <dawik> > "hi" == "hi"
06:34:19 <lambdabot>  True
06:34:52 <dawik> i love you lambdabot
06:35:10 <zipper> I want a call to putStrLn' be a call to putStr' but I see an issue when putStr' returns a IO ()
06:35:13 <zipper> Iceland_jack: ^
06:35:32 <CaptainK> how do I get my floating point down to just 1 digit?
06:35:37 <mm_freak> zipper: this operator might help you:  (>>) :: IO a -> IO b -> IO b
06:35:42 <mm_freak> zipper: read it as "and then" =)
06:36:02 <Iceland_jack> zipper: Use what mm_freak just posted to execute one thing after another :)
06:36:47 <zipper> mm_freak: I'm lost
06:36:58 <mm_freak> putStrLn' xs = … >> …
06:37:05 <mm_freak> where both … are IO actions
06:37:06 <Iceland_jack> zipper: If you want to print something twice you can do
06:37:06 <Iceland_jack>     putStrLn "one" >> putStrLn "two"
06:37:13 <pjdelport> CaptainK: what do you mean?
06:37:23 <Iceland_jack> or equivalently
06:37:23 <Iceland_jack>     do putStrLn "one"
06:37:23 <Iceland_jack>        putStrLn "two"
06:37:25 <zipper> putStrLn' (x:xs) = putStr' (x:xs) >> '\n'
06:37:26 <murgaan> OK, I'm trying to understand function currying. I understand that max 4 5 is the same as (max 4) 5
06:37:30 <Iceland_jack> zipper: exactly
06:37:33 <Iceland_jack> only
06:37:42 <Iceland_jack> you need a function to print '\n' :)
06:37:48 <murgaan> So, I'm trying to to curry manually with this: http://lpaste.net/100065
06:37:59 <Iceland_jack> so
06:37:59 <Iceland_jack>     putStrLn' str = putStr' str >> ??? '\n'
06:38:06 <zipper> Iceland_jack: putStrLn' (x:xs) = putStr' (x:xs) >> putChar '\n'
06:38:12 <Iceland_jack> that's right
06:38:18 <Iceland_jack> and you can replace (x:xs) with str
06:38:18 <zipper> Iceland_jack: What is ???
06:38:29 <Iceland_jack> zipper: In your case, ‘putChar’ :)
06:38:37 <Iceland_jack> I used ??? as a placeholder for an unknown function
06:38:42 <user____1> why this don't work : let tfunc2 x y z = putStrLn $ "(" ++ x ++ "," ++ y ++ "," ++ z ++ ")"
06:39:03 <Peaker> is there a way to get the FD number underlying a "Socket" or a "Handle"? I want to hand it over to a child C process
06:39:06 <murgaan> What I don't quite understand is how to give it a proper type.
06:39:07 <CaptainK> how can i set my float to globally be 1 digit, like 5.3 not 5.3423423532
06:39:13 <mm_freak> user____1: as far as i see it does work
06:39:34 <geekosaur> Peaker: handeToFd?
06:39:34 <mm_freak> Peaker: Network.Socket should give you that
06:39:36 <Peaker> oh, I see: System.Posix.IO.handleToFd
06:39:41 <mm_freak> handleToFd is unsafe
06:39:44 <murgaan> In ghci I did a :t compareWithFour
06:39:44 <zipper> Iceland_jack: I had used (x:xs) in thinking that it would catch it when it got to the end of the line. I hadn't realised that it wouldn't call putStrLn' again
06:39:45 <pjdelport> murgaan: Did you look at the inferred type?
06:39:55 <Peaker> mm_freak, Can't find any fd or such in Network.Socket..
06:40:12 <user____1> No instance for (Num [Char]) arising from the literal `1'
06:40:13 <murgaan> and it told me compareWithFour :: (Num a, Ord a) => a -> a
06:40:15 <geekosaur> note that a socket only has a backing fd on posix
06:40:15 <merijn_> mm_freak: In what way is it unsafe?
06:40:17 <Peaker> oh, now I can
06:40:41 <Peaker> I guess "fdSocket" is it
06:40:44 <geekosaur> CaptainK, you don't unless you mean Data.Fixed
06:40:48 <zipper> Iceland_jack: Now about that buffering.
06:40:51 <Peaker> thanks
06:40:56 <pjdelport> murgaan: How familiar are you with type classes (the Num and Ord in that signature)?
06:41:01 <zipper> Iceland_jack: How can I understand it?
06:41:08 <CaptainK> so import Data.Fixed?
06:41:09 <geekosaur> if you are talking about Show instances, you're abusing Show.
06:41:10 <mm_freak> merijn_: buffering
06:41:19 <murgaan> :pjdelport I'm *just* learning about them.
06:41:25 <user____1> mm_freak: it tell me : No instance for (Num [Char]) arising from the literal `1'
06:41:26 <merijn_> mm_freak: Oh, if you interleave them, you mean?
06:41:27 <mm_freak> Handle is buffered, Socket is not
06:41:40 <murgaan> I understand that Num is a number and Ord is something that can be ordered.
06:41:43 <mm_freak> merijn_: it's unspecified when the RTS starts buffering
06:41:54 <mm_freak> generally it's best to avoid Handle and go from Socket to Fd directly
06:41:56 <user____1> mm_freak: when I do: tfunc2 1 2 3
06:41:56 <merijn_> mm_freak: Doesn't make handleToFd unsafe, thouh
06:42:02 <Iceland_jack> zipper: Normally dstdout is line-buffered, meaning that things get printed when the newline is encountered
06:42:06 <Iceland_jack> *stdout
06:42:06 <zipper> Iceland_jack: line 14 and 13 are working in a weird way
06:42:07 <merijn_> mm_freak: handleToFd closes and flushes the Handle
06:42:17 <mm_freak> merijn_: depends on your notion of safety, i guess =)
06:42:18 <murgaan> pjdelport: is it saying that a is both types?
06:42:26 <Iceland_jack> This is not Haskell-specific
06:42:34 <mm_freak> not unsafe as in impure, but as in unpredictable
06:42:41 <merijn_> mm_freak: Well, it's safe in the sense that "after you do it, using the Handle for anything throws an exception"
06:42:54 <geekosaur> user____1, haskell does not do implicit coercions, your wrote a function that operates on String, you cannot pass it a number
06:42:56 <merijn_> So, you don't get weird effects, just weird exceptions :p
06:42:57 <pjdelport> murgaan: briefly, you can read that as "compareWithFour :: a -> a, where a is any type that's an instance of Num and Ord (in other words, any numeric, orderable type)"
06:43:24 <zipper> Iceland_jack: By when a new line is encountered we mean when I press enter
06:43:29 <Iceland_jack> zipper: If you want to print out something without a newline so that the user can type their response
06:43:29 <Iceland_jack>     putStr "What's your name? "
06:43:29 <Iceland_jack> you can follow it by ‘hFlush stdout’
06:43:33 <Iceland_jack> zipper: yes
06:43:36 <mm_freak> user____1: the error is probably elsewhere
06:43:47 <user____1> ah
06:44:05 <murgaan> pjdelport: ok, so that means that the "a" is both types.
06:44:35 <user____1> geekosaur: isn't it part of the polymorphism? for the ++ operator?
06:44:40 <geekosaur> if you want a number there, generate a String from it and pass that. `show` is the easy way, there are others that give you control over formatting (Text.Printf, various routines in Numeric)
06:44:44 <geekosaur> no
06:44:47 <geekosaur> :t (++)
06:44:48 <lambdabot> [a] -> [a] -> [a]
06:44:55 <geekosaur> all the "a"s are the same
06:44:58 <zipper> Iceland_jack: The flushing the buffer forces it to be printed?
06:45:00 <murgaan> pjdelport: and the reason that it has to be both in my function is because it gets compared and assigned to a number?
06:45:02 <pjdelport> murgaan: Well, Num and Ord aren't the same as types. You can think of them as interfaces, perhaps: they just describe a set of operations that an actual type must implement.
06:45:06 <geekosaur> you start with "(" ++
06:45:11 <geekosaur> so it's operating on String
06:45:12 <user____1> aha
06:45:13 <mm_freak> zipper: yes
06:45:24 <merijn_> murgaan: It means that 'a' is an instance of both typeclasses
06:45:43 <mm_freak> zipper: if stdout is a terminal, the default is line-buffering, so it prints only when it encounters an LF or when the buffer fills up
06:45:55 <pjdelport> murgaan: So you can *specialize *your function to (for example) compareWithFour :: Integer -> Integer
06:45:55 <mm_freak> zipper: if you want to print earlier than that, you must use hFlush
06:46:29 <mm_freak> zipper: alternatively you can disable the line buffering
06:46:32 <mm_freak> :t hSetBuffering
06:46:33 <lambdabot> Not in scope: `hSetBuffering'
06:46:38 <Iceland_jack> zipper: yes, it transmits all accumulated characters to the file (stdout)
06:46:39 <mm_freak> :t System.IO.hSetBuffering
06:46:40 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
06:46:53 <mm_freak> stdout :: Handle, NoBuffering :: BufferMode
06:46:55 <pjdelport> murgaan: or compareWithFour :: Double -> Double, or so on
06:47:16 <zipper> mm_freak: Iceland_jack: Like in Line 3 https://gist.github.com/urbanslug/9051333
06:47:16 <geekosaur> (more precisely `a` there is Char)
06:47:35 <pjdelport> Integer, Double, and a number of other types all implement the common set of operations that Num and Ord require
06:47:36 <mm_freak> zipper: yeah, that should work
06:47:48 <murgaan> pjdelport: OK, thanks. That all makes sense.
06:47:57 <mm_freak> zipper: however, it's unconventional for output functions to flush the buffer…  you should do it in 'main' instead
06:48:11 <mm_freak> putStr "Gimme stuff: " >> hFlush stdout
06:48:40 <zipper> mm_freak: That feals like I will be giving my user a lot of work.
06:48:49 <mm_freak> zipper: your user?
06:48:53 <pjdelport> murgaan: So type classes are a way to make the function polymorphic across different, while remaining safe: you're declaring that the types must belong to a common class (or classes).
06:49:00 <pjdelport> across different types, i meant
06:49:02 <zipper> I assume everyone wants it on their terminal as a default
06:49:14 <zipper> mm_freak: Well I have no user
06:49:23 <mm_freak> zipper: you only use it for prompts, because prompts usually don't include an '\n'
06:49:45 <mm_freak> the default buffering mode is a tradeoff between speed and convenience
06:49:46 <pjdelport> murgaan: Note that once the function is specialized to Integer or Double or any other concrete type, the type class constraint no longer appears in the type signature.
06:50:22 <pjdelport> Haskell just infers the more general type for you, where possible.
06:50:23 <zipper> mm_freak: So when the user flushes buffer it is faster?
06:50:51 <mm_freak> zipper: who is the user?  the person interacting with your program?
06:51:23 <zipper> mm_freak: The person using putStr'
06:51:53 <mm_freak> zipper: it's not common to use putStr/getLine for user interaction…  you do that only for learning =)
06:51:59 * hackagebot nc-indicators 0.1 - CPU load and memory usage indicators for i3bar  http://hackage.haskell.org/package/nc-indicators-0.1 (MihalyBarasz)
06:52:03 <mm_freak> zipper: for user interaction you would rather use something like haskeline
06:52:05 <murgaan> pjdelport: why is that?
06:52:31 <zipper> mm_freak: Why did I learn something I will never use? :C I feel cheated
06:53:09 <mm_freak> zipper: because real user interaction is a complicated topic…  you're learning functions and types right now, not UIs =)
06:53:52 <mm_freak> when you look at command line programs like 'sort', this is a task you could solve by using 'getLine' and 'putStrLn'
06:55:30 <mm_freak> but to be honest in practical haskell programs putStr* and getLine are seldom to be found…  if at all, putStr* is used to print some diagnostics or debug messages
06:55:47 <mm_freak> and even then you would probably prefer 'print' or a real logging solution
06:58:15 <zipper> Because putStrLn is for strings only
06:58:28 <pjdelport> murgaan: You mean, why does Haskell infer the general type instead of more specific types?
06:58:50 <murgaan> pjdelport: This seems legal compareWithFour :: (Integral a) => a -> a
06:59:51 <pjdelport> murgaan: Right, that's legal, but it's a more restrictive type class than just Num and Ord, on their own.
07:00:31 <pjdelport> murgaan: It's perfectly acceptable to declare that signature in your code if you actually want the additional constraint.
07:00:51 <pjdelport> In other words, if you don't want compareWithFour to be used with non-integral numbers.
07:01:03 <murgaan> pjdelport: That makes sense. I don't know what you mean by "the class constraint no longer appears in the type signature"
07:01:27 <merijn> murgaan: He means that you don't get "Num Int => Int -> Int"
07:01:33 <Maior> :t uncurry
07:01:34 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:01:46 <merijn> murgaan: "Num a => a -> a" just becomes "Int -> Int" when the compiler can see it only needs Int
07:01:59 <mm_freak> zipper: putStrLn is slow, String is slow, and getLine is an engineering nightmare =)
07:02:00 <pjdelport> murgaan: I mean that that's effectively what happens when you "instantiate" a with a concrete type, like Int, Double, etc.
07:02:21 <merijn> murgaan: i.e. once 'a' can only be Int, there's no point to keep the constraint as "Int" already is guaranteed to be a "Num" instance
07:02:35 <murgaan> Ah, ok. Thanks.
07:02:59 <pjdelport> murgaan: In other words, you won's see something like compareWithFour :: (Integral Int) => Int -> Int
07:03:08 <mm_freak> zipper: if you're on linux, just start your program and type ctrl-d
07:03:20 <mm_freak> instead of typing something in =)
07:05:04 <zipper> mm_freak: I feel cheated
07:05:16 <zipper> I just might skip this section
07:05:58 <pjdelport> murgaan: So, the type class constraints only apply to type *variables*, like a. Once you provide an instance of a that fullfils the type class constraints, they're no longer relevant.
07:06:10 <mm_freak> zipper: no, don't!
07:06:37 <mm_freak> zipper: again, this is not about user interaction, it's about learning the language…  and getLine/putStr* is a simple API to learn how IO works
07:07:15 <mm_freak> i totally use them in toy programs, just not in real applications =)
07:09:08 <benj_> I use putStrLn all the time, in simple apps that just compute something, print it to the terminal and then quit
07:09:11 <zipper> mm_freak: lol ok I won't skip it
07:09:43 <zipper> Are you people trying to make me feel better? lol
07:09:58 <mm_freak> benj_: you really go through the trouble of writing "putStrLn (show …)"? ;)
07:10:15 <zipper> Santa isn't real but we still dress up as him so even if santa is not real he is real-ish
07:10:24 <mm_freak> zipper: we try to make you not skip important information ;)
07:10:45 <mm_freak> santa is totally real…  he even has a type
07:10:56 <zipper> mm_freak: lol
07:11:08 <benj_> mm_freak, how is print defined? :)
07:11:18 <Iceland_jack>     print = putStrLn . show
07:11:22 <mm_freak> benj_: that's irrelevant to my question ;)
07:11:30 <benj_> your question missed the point
07:11:46 <mm_freak> benj_: and your response missed the point of my question =P
07:12:07 <Iceland_jack> There are a lot of irrelevancies :)
07:12:35 <benj_> what was the point of your question?
07:12:35 <jmcarthur> santa is real like real numbers are real
07:13:05 <Iceland_jack> Santa is real like IEEE 754 represents the real numbers
07:13:21 <mm_freak> benj_: the points are to the right of "show"
07:13:22 <jmcarthur> there are, in fact, an infinite number of santas between every real person
07:13:33 <Iceland_jack> jmcarthur: That's terrifying
07:14:05 <mm_freak> oh, did i fail to mention?  you need a UTF-8-capable client to get my points ;)
07:14:18 * benj_ makes some weak joke about point-free
07:14:56 <benj_> it turns out the actual definition of print is pointful
07:15:09 <jmcarthur> @src print
07:15:09 <lambdabot> print x = putStrLn (show x)
07:15:11 <jmcarthur> :(
07:15:30 <c_wraith> eh.  ghc should generate identical code for those
07:15:32 <mm_freak> print probably is older than (.)
07:15:54 <mm_freak> just like Monad is older than Functor =)
07:16:05 <jmcarthur> it is my understanding that ghc is more likely to inline point free definitions than pointful ones, such as when they are partially applied
07:16:24 <geekosaur> also remember that @src lies a lot
07:16:36 <Iceland_jack> ‘@src’ is full of lies
07:16:40 <benj_> I know that, I meant the real source
07:16:48 <mm_freak> in some unfortunate cases @src tells the truth
07:16:50 <benj_> (assuming hackage doesn't lie)
07:16:53 <mm_freak> @src sum
07:16:53 <lambdabot> sum = foldl (+) 0
07:16:57 <jmcarthur> :D
07:16:59 <c_wraith> I've never understood GHC's restriction that it only inlines fully saturated function applications.
07:16:59 <geekosaur> (in particular it likes to quote the Report, which seems more oriented toward didaction than performance; ghc's implementation often differs)
07:16:59 <jmcarthur> err
07:17:01 <jmcarthur> :( i mean
07:17:43 <c_wraith> where "fully saturated" depends on how many points were in the function declaration, rather than being a property of its type
07:17:52 <jmcarthur> c_wraith: it's probably just easier, or perhaps it's to give you, the programmer, more control over it.
07:18:05 <mm_freak> my source code usually follows the standard defined in the GHC report =)
07:18:43 <c_wraith> jmcarthur: actually, my best guess is that it's to avoid generating multiple versions of each function with multiple arguments.
07:18:52 <mm_freak> and ∀ you. if you're honest, yours probably does the same =)
07:19:15 <jowens> n00b question: i'm trying to write a (memoized) version of a Project Euler problem. It doesn't terminate on even the simplest case (calling with argument 1). Help me understand why? http://lpaste.net/100066
07:19:47 <jmcarthur> c_wraith: i am strongly leaning toward it just being easier, though. "the trick" (eta expansion) is not always easy to get right.
07:20:03 <jmcarthur> c_wraith: i doubt it's due to duplication. inlining is, after all, duplication *by definition*
07:21:04 <mm_freak> in a perfect world inlining is obsoleted by sharing
07:21:09 <jmcarthur> c_wraith: in fact, i think i may have just come up with the real reason. eta expansion can cause you to allocate more closures and lose more sharing.
07:21:24 <c_wraith> jowens: there's absolutely no memoization there.
07:21:34 <jmcarthur> mm_freak: indeed
07:21:44 <jowens> c_wraith: happy to accept the reason why.
07:21:58 <c_wraith> jowens: but more to the point, you want n `div` 2, not n * 2
07:22:09 <c_wraith> jowens: also, !! is 0-indexed
07:22:14 <jowens> yeahhhhh that would tend to grow awfully quickly
07:22:16 <jmcarthur> mm_freak: evaluation under lambdas with sharing and a nice JIT would be cool :)
07:22:38 <jowens> why does collatzCount(1) not terminate though?
07:22:54 <c_wraith> jowens: because !! is 0-indexed.  collatzCount 0 will terminate
07:22:57 <mm_freak> jmcarthur: why JIT?
07:22:58 <jowens> ah
07:23:09 <jowens> ok. that was a lot of errors in a small piece of code! thanks mucho.
07:24:18 <c_wraith> jowens: as for why it's not memoized - in order to memoize, it would need to refer to the data structure holding its other values (the list) at some point.
07:24:55 <c_wraith> jowens: that definition just makes direct recursive calls.  There's no place to depend on previously-calculated results
07:25:13 <jowens> compare to memoized_fib though?
07:25:16 <jowens> how is that one different?
07:25:28 <jowens> (pasting in a sec)
07:25:38 <c_wraith> memoized_fib is terrible.  It's both confusing and not nearly as memoized as simpler implementations
07:25:43 <jowens> http://lpaste.net/100067
07:25:45 <jowens> ah
07:25:56 <jowens> the memoization wiki page really needs some help
07:26:05 <jmcarthur> mm_freak: all that "runtime inlining" would result in a lot of closures all pointing to each other. once any sort of supercombinator has been produced and found to run a lot it would be nice to just make that native code instead
07:26:41 <ij> I don't get why it ends up being [[b]] and what does that even mean?: http://sprunge.us/RTQI
07:26:54 <mm_freak> jmcarthur: don't we have native code in the first place?
07:26:58 <jmcarthur> err, maybe not supercombinators, but anything that is basically just a bunch of low level instructions with tons of unnecessary boxing and environments and such
07:27:08 <mm_freak> ah
07:27:29 <mm_freak> you mean removing boxes at runtime?
07:27:33 <jmcarthur> mm_freak: once you have evaluation under lambdas you will end up constructing tons of extra closures as you manipulate free variables
07:28:31 <jowens> c_wraith: suggestion for a better memoized  example?
07:28:34 <mm_freak> jmcarthur: by applying a free variable multiple times to the same function in different scopes?
07:28:41 <mm_freak> uh
07:28:43 <jmcarthur> mm_freak: since there tend to be a lot of "partial applications" under lambdas (function applied to, say, one known argument and one free variable)
07:28:47 <mm_freak> the same function to the same variable
07:28:57 <mm_freak> ah
07:29:07 <mm_freak> like in fmap (map f)
07:29:21 <jmcarthur> that's a good enough example
07:29:46 <mm_freak> it's the simplest nontrivial example i could think of =)
07:30:23 <mm_freak> but GHC seems to handle this very well
07:30:29 <jmcarthur> yes, statically
07:30:32 <jmcarthur> via inlining
07:30:50 <c_wraith> jowens: Most memoization in haskell comes from replacing recursive function calls with recursive data definitions.
07:30:54 <mm_freak> jmcarthur: you can help GHC there
07:31:12 <mm_freak> jmcarthur: f x = let !z = … in \y -> …
07:31:21 <jowens> do you like this formulation?
07:31:24 <jowens> http://stackoverflow.com/questions/15544164/how-does-this-memoized-fibonacci-function-work
07:31:25 <mm_freak> let !f' = f x in fmap f'
07:31:26 <jmcarthur> my point is that if the inlining actually occurs at runtime, you will probably also want some of that compilation pipeline at runtime, too
07:31:51 <mm_freak> when does inlining occur at runtime?
07:32:32 <jmcarthur> evaluation under lambdas has the effect of inlining the definitions that are known already
07:32:42 <zipper> Eat >> Sleep
07:32:46 <mm_freak> even in STG?
07:32:57 <jmcarthur> e.g.   \x -> (f . g) x   ==>   \x -> f (g x)
07:32:59 <mm_freak> i thought that STG uses supercombinators and closures
07:33:04 <jmcarthur> STG doesn't evaluate under lambdas
07:33:13 <c_wraith> jowens: I don't really like the definition in the question..  It's actually memoized, but..  really badly.  any time you memoize in terms of !!, you're probably not gaining much.
07:33:40 <jowens> really happy to see a smart impl
07:33:46 <mm_freak> jmcarthur: such an optimization might be useful, if you use an SKI compiler
07:33:51 <c_wraith> jowens: even if you neglect the cost of addition, that definition is O(n^2), where O(n) is possible.  (if you count the cost of addition, add an extra factor of n to each)
07:34:02 <jmcarthur> mm_freak: you said ideally sharing obsoletes inlining. with evaluation under lambdas and a JIT, sharing *can* obsolete inlining.
07:34:04 <jowens> i get the naming issue (that we have to name things)
07:34:15 <mm_freak> jmcarthur: ah, now i get your point =)
07:34:37 <mm_freak> jmcarthur: however, i'm not convinced that this can't be done statically
07:35:22 <mm_freak> even though sharing is a run-time effect, it is built into the code at compilation time
07:35:39 <jmcarthur> mm_freak: nope, it can't always. for example, consider an interpreter that runs a program fed to it dynamically. with eval under lambda, you actually specialize the interpreter to that program, dynamically.
07:36:11 <jmcarthur> mm_freak: in fact, it is as though the interpreter never existed, when taken to its extreme. this is just partial evaluation, essentially.
07:36:32 <mm_freak> the interpreter becomes a compiler
07:36:34 <jmcarthur> yup
07:36:37 <jmcarthur> at runtime!
07:36:42 <mm_freak> interesting
07:37:18 <mm_freak> this would probably be a nightmare to implement for haskell =)
07:37:34 <jmcarthur> well, it would certainly be hard to do for ghc
07:37:57 <c_wraith> jowens: I'm putting together something to demonstrate what I mean
07:37:59 <jmcarthur> i believe somebody was once looking into doing this (maybe without the JIT) in uhc, but i never heard about it again, so it probably didn't work out.
07:38:04 <jowens> thx!
07:38:21 <mm_freak> it's probably too much work for a single programmer
07:39:05 <jmcarthur> i think a big problem with doing it in an existing compiler is that so much code has already been written that assumes a totally different execution model
07:39:27 <jmcarthur> e.g. GHC's implementation of IO actually *does* use evaluation order, under the hood, to control the ordering of effects
07:39:40 <mm_freak> yeah, and writing a haskell compiler from scratch is difficult alone
07:40:10 <jmcarthur> maybe writing a Core compiler would be more doable
07:40:21 <mm_freak> indeed
07:40:37 <mm_freak> would be interesting to see how haskell code performs under SKI compilation
07:41:10 <jmcarthur> you'd probably want more than just SKI
07:41:15 <mm_freak> sure
07:41:25 <pranz> is unsafecoerce slow?
07:41:29 <jmcarthur> e.g. to prevent the well known exponential blowup
07:41:31 <mm_freak> read "SKI" as abstraction elimination, no matter what your combinators are
07:41:43 <jmcarthur> isn't that just supercombinators?
07:41:50 <mm_freak> yeah
07:42:14 <mm_freak> you can prevent the exponential blowup by using a number of additional supercombinators
07:42:31 <geekosaur> pranz: tempted to say even asking that question is evidence you should not be thinking about it...
07:42:33 <jmcarthur> but ghc basically already does this, so i must be misunderstanding something
07:42:50 <mm_freak> GHC doesn't do SKI compilation
07:42:51 <jmcarthur> oh, you still mean a static set of combinators, not generating new combinators from the code
07:42:52 <mm_freak> it does STG
07:43:04 <tromp__> you dont need more than SK to avoid certain blowups
07:43:09 <tromp__> you need better abstraction rules
07:43:43 <jmcarthur> tromp__: oh?
07:43:47 <mm_freak> tromp__: there is a certain case that blows up with SK alone, documented in SPJ's compiler book
07:43:51 <tromp__> see my paper at http://homepages.cwi.nl/~tromp/cl/cl.html
07:44:22 <tromp__> wld be interesting to try that case with my abstraction rules
07:44:27 <mm_freak> but anyway, even if SK alone is sufficient, you still want the single-path variations of S
07:44:41 <bergmark> Feuerbach: oh noes 502'd http://ro-che.info/
07:44:44 <mm_freak> also i found adding a flipping combinator to be useful
07:45:07 <Feuerbach> bergmark: oops
07:45:22 <geekosaur> it hit the ro-che limit? :p
07:46:02 <jmcarthur> flip = C
07:46:39 <tromp__> my rules are also implemented in http://stratigery.com/acl.html
07:46:48 <mm_freak> jmcarthur: i always defined B and C to be single-path versions of S, following SPJ's convention
07:46:51 <jmcarthur> STG and supercombinators are not mutually exclusive
07:46:55 <Feuerbach> bergmark: should be back now
07:47:03 <geekosaur> pranz: if you insist on foot shooting, unsafeCoerce has no runtime cost in ghc
07:47:16 <jmcarthur> supercombinators still need some sort of machine to reduce them, and STG does a fine job
07:47:20 <pranz> geekosaur: only for experimental stuff :p
07:47:25 <mm_freak> pranz: unsafeCoerce is highly expensive
07:47:29 <jmcarthur> mm_freak: i see
07:47:32 <bergmark> Feuerbach: thanks!
07:47:48 <geekosaur> (and if you have any idea what you are doing, then what I just told you should give you some idea of how dangerous it actually is)
07:48:07 <Feuerbach> bergmark: thanks to you :-)
07:48:13 <mm_freak> pranz: it makes your code orders of magnitude slower, gives your pet cancer and launches the missiles
07:48:34 <mm_freak> unsafeCoerce makes your code so sloooooooow that you should probably not use it
07:48:43 <mm_freak> unsafePerformIO has the same problem
07:49:15 <jmcarthur> also, unsafeInterleaveIO still gives your pet cancer, and launches missiles, just later
07:49:52 <jmcarthur> unsafeInterleaveST is as bad as unsafeCoerce and unsafePerformIO though
07:50:00 <jmcarthur> as is unsafeIOToST
07:51:18 <c_wraith> jowens: http://lpaste.net/100070  I may have muddied the waters a bit with the calls to trace, but they illustrate just how much more work is done by the non-memoized version
07:52:16 <c_wraith> jowens: the Catalan numbers are a decent example because the algorithm is even more self-referential than the fibonacci sequence
07:52:36 <mm_freak> it's much easier to sell performance, kittens and peace than safety =)
07:53:05 <jowens> ok. so rather than using !!, you are just defining it as a list
07:53:42 <jowens> and that list is explicitly named ("catalans")
07:53:45 <c_wraith> jowens: yes.  Extracting a specific element will still end up using !!, but at least the person using it knows the cost.  It's O(n), after all
07:54:19 <jowens> ok. that meshes well with intuitive memoization
07:54:25 <jowens> that there's a list
07:54:32 <jowens> and the important bit (at a high level) is that list needs to be named
07:54:35 <jowens> is that all accurate?
07:54:54 <c_wraith> jowens: it doesn't necessarily need to be named, but it needs to be shared.  The easiest way to share it is to name it.
07:55:27 <c_wraith> There *are* other ways, but..  They involve weird knot-tying stuff.
07:55:32 <jowens> ok. thx for distinction.
07:57:30 <jowens> c_wraith: really, that is above and beyond, much appreciated.
07:58:15 <matheus23> is anybody here using Sublime-Haskell? It tells me to re-run 'cabal configure' because the version of cabal has been changed. I tried running it via command line, but that doesn't help apparently
07:58:23 <c_wraith> jowens: I had some of that code sitting around already, as I'd been working on related ideas.  Glad it could help.
07:58:41 <jowens> you would do well to update wiki entry :) - it needs some help.
08:09:52 <bernalex> how does FileMode work with createDirectory?
08:10:52 <geekosaur> roughly the same way it does for files? it gets modified by the umask
08:11:19 <geekosaur> (it reflects the syscall, not the shell command which always passes 0666 to the syscall and lets umask sort it out)
08:11:21 <bernalex> uhm so how does it work for files? I thought 0755 meant what I thought it meant but it didn't :-P
08:12:15 <geekosaur> oh, I see, your question  is how does octal work in haskell
08:12:26 <geekosaur> > 0755
08:12:29 <lambdabot>  755
08:12:45 <bernalex> no I wanted to set it to 755 w/o sticky bits
08:12:56 <geekosaur> ok, that went straight overhead
08:13:14 <bernalex> but but createDirectory "lol" 0755 gives
08:13:15 <bernalex> d-wxr----t 2 alexander alexander 4.0K Feb 17 17:08 lol
08:13:18 <geekosaur> bernalex: your problem is that the conventional "755" is an OCTAL number
08:13:24 <bernalex> oh right
08:13:30 <geekosaur> haskell reads it as a DECIMAL number
08:13:32 <bernalex> ah
08:14:28 <geekosaur> (493 decimal, and I do not recall how you get octal aside from various things in the Numeric module)
08:14:45 <bernalex> yes, I used decimal and it worked, thanks
08:15:06 <geekosaur> oh right, 0o
08:15:14 <geekosaur> so 0o755 would have worked
08:15:46 <bernalex> geekosaur: indeed it does! thanks.
08:15:50 * no-n wonders if he should read LYAH again
08:16:04 <no-n> didn't get all the way through
08:17:34 <bennofs> no-n: where did you stop?
08:17:46 <no-n> not sure
08:18:01 <no-n> have forgotten a lot
08:18:28 <geekosaur> so just go through the whole thing
08:18:48 <geekosaur> if you don't use stuff it starts to bitrot; regular review is a good idea
08:21:15 <bennofs> is there an alternative to timeout that is more accurate? (timeout uses threadDelay)
08:22:01 <geekosaur> unlikely
08:22:12 <geekosaur> most of the hysteresis there is from the OS
08:22:48 <geekosaur> (i.e. if you want realtime accuracy, run ghc on a realtime OS / in a realtime scheduling milieu)
08:23:21 <bennofs> I get about 0.07s difference
08:28:53 <eacameron> what is the best OS for Haskell support? Windows is not it
08:31:08 <randomclown> linux obviously
08:31:19 <eacameron> any particular flavor?
08:31:34 <randomclown> ones with a decent package manager
08:31:36 <bernalex> looks like gentoo is miles beyond the other ones
08:31:40 <bernalex> nixos is probably very good too
08:31:58 <tdammers> debian and arch seem popular too
08:32:00 <randomclown> I think compiling ghc will be an experience in ultimate suffering
08:32:03 <Earnestly> eacameron: They're all the same, pick whatever you want
08:32:07 <randomclown> gentooboy
08:32:10 <Earnestly> The only difference is library versions
08:32:16 <c_wraith> Eh.  Any linux works fine, so long as you don't use the system package manager to install/manage GHC and libraries
08:32:21 <bernalex> compiling ghc involves "emerge ghc" and that's it
08:32:31 <randomclown> yeah that takes like 2 hours
08:32:45 <randomclown> or more
08:32:45 <bernalex> using gentoo means you get a huge set of packages that play nicely and work with your regular package manager.
08:32:46 <bartavelle> c_wraith, some have up to date versions, and are actually nice to use
08:32:56 <bernalex> that takes about 40 mins on modern CPUs, and you hardly do it often.
08:33:10 <bernalex> actually, looking at my logs, it takes about 20 mins.
08:33:13 <randomclown> I like binaries better
08:33:43 <c_wraith> It's not like you can build GHC without a GHC install anyway.
08:34:15 <bernalex> then pick one of the others at random, but expect a few headaches every now and again. if the distro has active haskell devs, you can probably get nice support.
08:34:23 <bernalex> nixos is probably your best bet there.
08:34:53 <eacameron> bernalex: interesting, I've never used nixos
08:34:58 <no-n> when I use "ghc --make" - how can I get all the .hi and .o files to go to a different dir? (or simply delete themselves)
08:35:26 <bernalex> eacameron: me neither, but it uses haskell a lot and most devs (maybe all) are haskellers, so there's probably nice haskell support.
08:35:34 <no-n> I once did rm *.hs instead of rm *.hi so I don't like to do it manually :P
08:35:42 <eacameron> bernalex: wow, crazy!
08:35:54 <bartavelle> eacameron, bernalex you can use the "nix" package manager without installing nixos
08:35:56 <geekosaur> no-n: -odir?
08:36:13 <no-n> ty
08:36:17 <bernalex> bartavelle: there are some problems with nix packages/repos which cause me to avoid them.
08:36:50 <bartavelle> indeed, it's not entirely painless, as I have found
08:37:58 <c_wraith> no-n: in most cases, using cabal solves the problem in a better way.
08:38:18 <c_wraith> no-n: of course, sometimes you don't want a cabal file for 30-line binaries.
08:38:18 <no-n> *nod*
08:39:19 <bernalex> mostly you want cabal though
08:39:29 <bernalex> cabal is so many orders of magnitude more comfortable to work with than autotools :-P
08:51:16 <zipper> :t hFlush
08:51:17 <lambdabot> Not in scope: `hFlush'
08:51:26 <mm_freak> :t System.IO.hFlush
08:51:27 <lambdabot> GHC.IO.Handle.Types.Handle -> IO ()
08:51:49 <zipper> :t System.IO.hSetBuffering
08:51:50 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
08:52:46 <zipper> mm_freak: when we used hFlush stdout we didn't pass a handle to hFlush did we?
08:55:40 <quicksilver> zipper: stdout is the handle
08:56:05 <zipper> :t Systme.IO.stdout
08:56:06 <lambdabot> Couldn't find qualified module.
08:56:12 <zipper> :t System.IO.stdout
08:56:13 <lambdabot> GHC.IO.Handle.Types.Handle
08:58:24 <hopf> For singleton list construction, is it better to use (:[]) or return?
08:58:59 <zipper> Honky Tonk Badonkadonk by Trace Adkins http://www.youtube.com/watch?v=MNuenYfSNaU
09:02:27 <CindyLinz> I like return more than (:[])..
09:03:18 <CindyLinz> Because I think (:[]) looks a little hairy....
09:04:24 <haasn> > pure 3 :: [Int]
09:04:27 <lambdabot>  [3]
09:06:43 <hopf> Okay, so we have pure, return, and (:[]). I agree that (:[]) looks hairy.
09:09:09 <geekosaur> @quote monkey
09:09:10 <lambdabot> Botje says: replacing "monad" with "monkey" makes haskell much more easy to understand
09:09:20 <geekosaur> @quote robot
09:09:21 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
09:09:23 <geekosaur> bah
09:09:28 <geekosaur> @quote robot.*monkey
09:09:28 <lambdabot> byorgey says: now we have the pig operator <^(++)^> as well as the robot monkey operator (:[])
09:09:52 <haasn> lens adds plenty more
09:10:05 <haasn> snail ^@..
09:10:10 <haasn> I like to call this one rat: <<>~
09:10:11 <bartavelle> never thought it looked like a robot, looks like a plain gorilla to me
09:10:49 <geekosaur> sadly =^..^= is not valid :p
09:12:03 <jmcarthur> not valid what?
09:12:24 <jmcarthur> let a =^..^= b = a + b in 5 =^..^= 6
09:12:26 <jmcarthur> > let a =^..^= b = a + b in 5 =^..^= 6
09:12:27 <geekosaur> you can't have a module named =^ as far as I can tell
09:12:28 <lambdabot>  11
09:12:31 <geekosaur> huh
09:12:46 <geekosaur> every time I think I understand how .-s get parsed...
09:13:07 <jmcarthur> it starts with an operator character, therefore . is part of the operator
09:16:09 <ReinH> jmcarthur: too bad you can't define the Kirby operator (>^_^)>
09:16:39 <ReinH> geekosaur: oh quote takes a regexp?
09:16:55 <prophile> is there some kind of yoneda/coyoneda equivalent for either arrows or profunctors?
09:17:00 <geekosaur> yes
09:17:03 <ReinH> hopf: if you have an identifier, I like wrapping it with [] :)
09:17:14 <prophile> and where might I find such a device
09:17:16 <ReinH> geekosaur: cool
09:18:19 <jmcarthur> prophile: i'm not sure how to interpret your question, actually. what would fill in the blank normally? "yoneda/coyoneda are for <blank>"
09:18:42 <hopf> yoneda is for when you-need-a lemma
09:19:51 <prophile> jmcarthur: apologies; "removing fmap applications" and either "removing lmap/rmap applications" or "removing >>^ and ^>> applications"
09:21:00 <jmcarthur> ah!
09:24:30 <jmcarthur> prophile: perhaps something like this terribly named construction?   data ProYoneda f a b = forall i j. ProYoneda (a -> i) (f i j) (j -> b)
09:25:35 <jfischoff> What is the blessed way to convert a Int into Text?
09:25:38 <prophile> jmcarthur: interesting, thanks, I'd have guessed that one needed existential types there
09:25:51 <jfischoff> I realized I could use Show, but that seems inefficent
09:25:52 <prophile> jmcarthur: do you happen to know if anyone's librarified it?
09:26:04 <jmcarthur> prophile: not a clue. i had to piece it together on the fly just now
09:26:30 <user____1> are there regullar arrays in haskell?
09:26:39 <Algebr> Doing :t in ghci yields the type, but how can I find out if say 'a' if an instance of Ord?
09:26:39 <prophile> k, I shall continue to search; thanks
09:26:41 <jfischoff> user___1: yes, repa
09:26:46 <jmcarthur> user____1: see repa
09:27:04 <jfischoff> Agebr: :i
09:27:13 <jmcarthur> user____1: also, Data.Array can be used to represent regular arrays, although repa is more trendy
09:28:26 <c_wraith> well, repa has the whole pa part, in addition to the re part
09:28:39 <jmcarthur> right
09:28:41 <Algebr> jfischoff: I get a parse error for that in ghci.
09:28:51 <jfischoff> what did you type?
09:28:56 <Algebr> :t 'a'
09:28:57 <lambdabot> Char
09:29:03 <jfischoff> :i Char
09:29:20 <Algebr> ah, that works.
09:30:34 <Algebr> is [Char] always the same thing as String?
09:30:48 <johnw> yes
09:30:53 <haasn> Algebr: yes, per definition of String
09:31:13 <Algebr> okay, cool, was just wondering if any crazy corner cases existed.
09:31:42 <joelteon> what library should I be using for communicating with an XML-based API?
09:33:21 <no-n> is there a library function that takes a list and gives you its head and tail in a tuple?
09:33:35 <johnw> (,) <$> head <*> tail
09:33:42 <shachaf> :-(
09:33:45 <shachaf> What if the list is empty?
09:33:52 <haasn> :t uncons
09:33:53 <lambdabot> Cons (->) (Accessor (First (a, s))) s s a a => s -> Maybe (a, s)
09:33:55 <johnw> same caveat applies to just using head and tail
09:33:56 <no-n> then spankings
09:34:10 <no-n> what does <*> mean
09:34:23 <shachaf> The thing johnw wrote is a complicated way to write (\x -> (head x, tail x))
09:34:41 <haasn> why not just do case xs of (h:t) -> ...
09:35:07 <johnw> oh, sorry,  I misunderstand him to mean head and last
09:35:12 <johnw> > splitAt 1 [1,2,3,4,5]
09:35:13 <lambdabot>  ([1],[2,3,4,5])
09:35:15 <no-n> yeah, i'll write it myself it's not complicated
09:35:17 <johnw> > splitAt 0 [1,2,3,4,5]
09:35:18 <lambdabot>  ([],[1,2,3,4,5])
09:35:23 <no-n> i just thought there was some named function that does it already
09:35:23 <johnw> > splitAt 1 []
09:35:25 <lambdabot>  ([],[])
09:35:34 <johnw> that's going to be safer, then just take the head of the first element
09:35:35 <no-n> ahhh
09:35:44 <johnw> (after you check that it's not empty)
09:36:09 <shachaf> That also isn't appropriate for the occasion. The problem becomes no simpler than before.
09:36:18 <johnw> how is that?
09:36:21 <khyperia> no-n: <*> is related to applicative functors, read up on them if you want to know what it is
09:36:31 <haasn> instead of  case splitAt 1 xs of ([h],t) -> ...   why not just use  case xs of (h:t) -> ...
09:36:37 <joelteon> is there a DSL for building xml docs?
09:36:37 <shachaf> haasn's advice is the best. Pattern-match on the list.
09:36:50 <shachaf> If you want a function to do it, it needs to have this type: [a] -> Maybe (a, [a])
09:36:52 <no-n> all right
09:36:57 <shachaf> No such function exists in base.
09:37:06 <johnw> that function is typically called "uncons"
09:37:14 <shachaf> But things that require you do "check that it's not empty" are unsafe.
09:37:17 <no-n> unicorns? :P
09:37:24 <haasn> but instead of “case uncons xs of Just (h,t) -> ...” etc. etc.
09:38:43 <no-n> splitAt 1 is perfect thanks johnw
09:38:51 <johnw> :)
09:40:25 <jfischoff> Has anyone use this http://hackage.haskell.org/package/text-xml-qq-0.1 or another xml quasiquoter?
09:40:53 <jfischoff> Or is there an easier way to make XML pretty printer?
09:44:27 <rgr> which ident mode to you emacs using guys use? Tab key alignment is all over the place for multi line let declarations for example.
09:46:19 <levi> I use either hi2 mode or structured haskell mode for haskell programming in emacs.
09:46:22 <johnw> i use haskell-indentation and then just fix it by hand
09:49:31 <rgr> I hadnt seen hi2 mode I'll check it out. thanks.
09:50:10 <levi> It's not included with haskell-mode, so you'll have to install it separately.
09:50:20 <johnw> how do you find shm, levi?
09:50:43 <levi> Grab it from hackage
09:50:52 <johnw> i meant, how do you like it?
09:51:01 <levi> Oh. I have mixed feelings.
09:51:17 <levi> It's very opinionated, and we don't always agree.
09:51:30 <johnw> chrisdone has sold me on it many times, but I can't seem to groove with it yet
09:53:03 <levi> I get the feeling that the bits that fall outside his normal workflow aren't terribly solid. Which is understandable; it's fairly new and the problem is not exactly trivial.
09:54:22 <levi> I tend to need to go back and add parentheses to things after the fact, and often I can't talk it into parethesizing exactly what I want.
09:54:50 <levi> So I end up putting *pairs* of parens on each end of the subexpression, and then deleting one on each end. :/
09:55:14 <johnw> have you brought this up in #haskell-emacs?
09:55:44 <rgr> its in melpa so thats good.
09:56:28 <levi> Nope; I wasn't aware of that channel.
09:57:14 * hackagebot modulo 1.9.0 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.9.0 (HansHoglund)
09:57:34 <monochrom> a "list" is already a tuple of head and tail. unless it's empty. { Just (x, xs}, Nothing } is just a more indirect, inefficient way to say { x:xs, [] }. if you plan to first convert to the inefficient former and then pattern-match anyway, you may as well pattern-match on the efficient original latter to begin with, and save yourself an XY problem.
09:59:58 <johnw> monochrom: great point, monochrom
10:17:15 * hackagebot ersatz 0.2.4 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.2.4 (EdwardKmett)
10:27:16 * hackagebot libjenkins 0.4.2.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.4.2.0 (MatveyAksenov)
10:49:04 <amalloy> is there a way to define a type using record syntax but not define the accessor functions that come with that? i want to do: data Foo = Foo {context :: String}, but not define a function named cnotext - giving it a name is just a convenient way to remember what that String is for
10:49:25 <amalloy> should i instead be defining a new type like `type Context = String`, and then data Foo = Foo Context, or something?
10:50:50 <Twey> amalloy: I like that approach, yes
10:53:15 <Twey> amalloy: You should be able to see what a function or datatype does or is by its name and type signature.  If you can't, you need a better name or a better type signature.  Where possible, a function's behaviour should be the only reasonable behaviour given that type signature; where that's not practical or plausible, type synonyms are a good way to document which of the possible behaviours it is
11:00:10 <jowens> c_wraith: you got a sec to look at what I wrote? It does not seem to be memoized (but AFAIK it's correct)
11:11:08 <jmcarthur> amalloy: if you are just trying to avoid unused variable warnings, you can just prefix the name of the field with an underscore
11:11:23 <jmcarthur> amalloy: e.g.  data Foo = Foo { _context :: String }
11:12:03 <amalloy> jmcarthur: i'm actually looking at shadowing warnings from -Wall, where i pattern-match (Foo context), and it warns me i'm shadowing the global context
11:12:45 <amalloy> but i figured, if i can avoid this problem *and* make my types better, why not
11:12:48 <levi> amalloy: I will often use type aliases for product type members instead of "Int" or "ByteString", both for documentation purposes and for the ability to easily change the concrete type in all of them at once.
11:14:56 <zipper> Could someone tell me why folds and I can't seem to get along here https://gist.github.com/urbanslug/9056891
11:16:26 <johnw> your first atIndex doesn't even use x
11:16:36 <johnw> but the other one does
11:16:49 <zipper> johnw: Good point
11:17:05 <johnw> also, name "acc" index in the first one
11:17:10 <zipper> I couldn't find a way to pass x as the new acc
11:17:14 <johnw> these functions are completely different
11:17:38 <dwcook> zipper, not a problem per se but evidence of a misunderstanding: You don't need the do block in the second one
11:17:47 <johnw> atIndex = foldr1 (\x index -> if index == 0 then x else (index-1) )
11:17:55 <johnw> something like that is more like what the second function is doing
11:18:01 <Twey> zipper: Your function is constant: either the index is 0 and you return the first list item, or index isn't 0 and you return index - 1
11:18:14 <Twey> Neither x nor acc is ever actually updated :
11:18:15 <Twey> :þ
11:18:26 <zipper> johnw: but foldr1 lamda takes first element as acc and second element as ...
11:18:41 <Twey> zipper: Also, making partial functions is usually a bad idea.  It would be better style to return a Maybe.
11:18:42 <johnw> are you sure?
11:19:03 <zipper> johnw: Of course not. :)
11:19:47 <Twey> zipper: Does that even typecheck?  You return an a if index == 0 and an Int otherwise
11:19:58 <zipper> Twey: Then what is higher oderism for
11:20:14 <Twey> I don't understand your question
11:20:16 <zipper> The praise partial application of functions all over the book
11:20:36 <Twey> zipper: I didn't say partial application, I said partial functions, i.e. functions that are undefined for some inputs
11:20:36 <ezrios> Twey: it does not typecheck
11:20:37 <zipper> Twey: No it did not compile
11:20:58 <janitrix> hi everyone
11:21:01 <levi> zipper: Just because you *can* implement almost anything as a foldr doesn't mean it's always the right higher-order function to use.
11:21:07 <zipper> or whatever its called when the emacs interpreter is checking for correctness
11:21:07 <Twey> > head [] -- this is a partial function: if given the input [] it will error out
11:21:09 <lambdabot>  *Exception: Prelude.head: empty list
11:21:18 <amalloy> atIndex is supposed to be a reimplementation of (flip (!!)), right? the comment describes it as if you were implementing indexOf :: [a] -> a -> Int
11:22:06 <zipper> levi: Really because folds are cool and encouraged in my understanding
11:22:48 <janitrix> one quick question: I compiled ghc then installed haskell-platform from source to a folder in my home. I then did "cabal update && cabal install cabal-install" which updated my version of the "cabal" binary, but instead of replacing the previous binary from haskell-platform, I got a new one in ~/.cabal/bin
11:23:03 <levi> zipper: Folds are encouraged where they make sense. This doesn't make sense as a foldr.
11:23:03 <geekosaur> that is expected, yes
11:23:06 <janitrix> I found this default behaviour rather weird
11:23:12 <geekosaur> oh?
11:23:28 <zipper> levi: What should it be? I am really lost
11:23:35 <geekosaur> you are running cabal as yourself, not as root (and you should NOT run it as root unless you know what you are doing)
11:23:38 <janitrix> I mean, that means that binary from packages installed by haskell platform are destined to be outdated
11:23:44 <janitrix> and replaced by ones from .cabal/bim
11:23:46 <janitrix> and replaced by ones from .cabal/bin
11:23:51 <geekosaur> also, NEVER EVER replace a system-installed binary
11:23:52 <amalloy> geekosaur: he said he installed haskell-platform as a user too, not root
11:24:06 <amalloy> so it's plausible to expect cabal update to replace the version he installed
11:24:07 <janitrix> I compiled everything, nothing installed as root
11:24:08 <levi> zipper: Well, I think you ought to try hand-evaluating a foldr, a foldl, and your explicitly recursive function.
11:24:15 <geekosaur> it still expects to behave as system installed, it does not rewire all of itself to be a cbaal user install
11:24:44 <ezrios> zipper: folds are normally used to "reduce" a list of values to a single value
11:24:52 <geekosaur> you migth be able to get away with cabal install --global in that case
11:24:56 <janitrix> I have nothing against putting .cabal/bin in my PATH, but it bothers me to keep the previous one too
11:25:13 <monochrom> you can erase the old one
11:25:15 <johnw> well, you can generalize that to say that a fold process the values of some structure into some other value -- whether that value has structure itself or not does not matter
11:25:15 <geekosaur> beware of anything that might overwrite or update bootlibs because your recovery is wiping all of it and starting over
11:25:17 <ezrios> using some function that takes a value from the list, the "result accumulated" so far, and gives you another value of the same type as the ones you took in as arguments
11:25:19 <janitrix> that means you can't update packages installed by haskell-platform,
11:25:26 <geekosaur> you cant anyway
11:25:36 <geekosaur> seriously
11:25:38 <geekosaur> don't
11:25:38 <janitrix> that's...weird
11:25:46 <geekosaur> ghc is weird about this, yes
11:25:48 <ezrios> (at least, for foldr1)
11:26:08 <geekosaur> you WILL Break your install if you upgrade them without doing a full upgrade of the whole platform
11:26:23 <janitrix> that means I should not update cabal?
11:26:38 <geekosaur> cabal the executable (cabal-install) is safe
11:26:43 <geekosaur> Cabal the library is not
11:26:47 <janitrix> it's just very confusing
11:26:52 <janitrix> why would you name both of those the same
11:27:02 <janitrix> :D
11:27:05 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml
11:27:19 <geekosaur> if it had been me they would not be named that way
11:27:24 <monochrom> yes, you need to read that.
11:27:30 <dcoutts_> janitrix: history, one arrived before the other
11:27:33 <monochrom> but I agree about duplicate naming
11:27:35 <janitrix> thanks for the read
11:27:55 <janitrix> so, I just need to let it go and accept that I have a out-of-date cabal-install binary in my path?
11:27:57 <zipper> johnw: Well https://gist.github.com/urbanslug/9056891 didn't typecheck either
11:28:02 <dcoutts_> janitrix: and just to confuse things we'll eventually rename them to be what everyone thinks they ought to be called (ie cabal package containing the cabal executable)
11:28:11 <ssaa> The Android back button does not really make sense to me always. I mean it does not need to traverse the whole application history right? i just want it to mean "go back to previous screen, whatever that was". it really messes things up if it can traverse the whole app history.
11:28:23 <monochrom> what I did for a newer cabal-install: I built it in a sandbox, then copied it out
11:28:58 <janitrix> I updated cabal to get sandboxes
11:29:00 <amalloy> is it even possible to write (!!) using foldr? it's hard for me to see how you would know when to stop
11:29:07 <monochrom> I still keep the old one because it is still useful. you can easily erase it or rename it. I don't understand your problem.
11:29:32 <monochrom> yes, but I did my own sandbox by hand
11:29:46 <levi> amalloy: It's possible to write foldl with foldr, but it's not exactly straightforward or worthwhile, outside of showing that it can be done.
11:29:52 <janitrix> my "problem" is that I find this default behavior weird and confusing. It makes me wonder what's the point of the haskell-platform
11:29:54 <monochrom> I still do. it is still simpler and superior to all industrial solutions out there
11:30:20 <janitrix> if you have to recompiled the whole thing to update a single package...
11:30:57 <geekosaur> janitrix: you have decided it's solving a different problem than the one it solves
11:31:13 <monochrom> I want to be rude and say "what update?"
11:31:42 <monochrom> but the explanation is that haskell platform is intended for those who do not incrementally update (not until the next version of haskell platform)
11:31:50 <dcoutts_> amalloy: easy: foldr (\x r n -> if n == 0 then x else r (n-1)) (error "!!")
11:31:54 <janitrix> aaaaaaaaah
11:32:15 <janitrix> that means if you want to tune your haskell packages, you have to compile ghc then cabal
11:32:19 <janitrix> then use cabal
11:32:35 <levi> Or just install a binary ghc.
11:32:35 <monochrom> you are of course entitled to do whatever you want. but read my article on consequences.
11:32:37 <dcoutts_> amalloy: or more precisely you could define (!!) = foldr (\x r n -> if n == 0 then x else r (n-1)) (error "!!")
11:32:52 <geekosaur> "this is a stable set of libraries that developers can work against, and other people will have the same stable set available"
11:33:27 <janitrix> the fact that cabal cannot uninstall anything and that GHC nows about packages confused me a lot too
11:33:33 <dcoutts_> amalloy: and if you try that you'll notice that it does have the correct shortcut behaviour
11:34:01 <monochrom> as for PATH, when you built haskell platform, there was a way to tell it to use ~/.cabal/bin too, so that later you get automatic overwriting, if that is what you want
11:34:15 <monochrom> in fact, it is simply "./configure --user" IIRC
11:34:26 <janitrix> thanks, I missed it :(
11:34:48 <amalloy> dcoutts_: that makes my brain explode. but i think i see what you've done
11:35:16 <monochrom> read my article. you do not know that "--prefix" and "--global vs --user" are completely orthogonal. completely
11:35:26 <dcoutts_> amalloy: it's a fairly simple variation on the definition of foldl in terms of foldr
11:35:56 <dcoutts_> amalloy: so if you want to really grok it, look at how foldl can be defined in terms of foldr
11:37:13 <janitrix> so compiling HaskellPlatform with --user would solve my issue without giving up the platform
11:37:17 <janitrix> thanks
11:38:11 <dcoutts_> amalloy: try "A tutorial on the universality and expressiveness of fold", particularly sections 4 & 5
11:39:16 <janitrix> "Moreover, GHC only identifies packages containing libraries, since GHC needs the libraries only."
11:39:24 <janitrix> any idea why it was done this way?
11:39:31 <monochrom> the "universality" there probably does not mean "it solves all problems". it is more like "it solves one problem correctly".
11:39:47 <janitrix> this is really confusing. That means you cannot "uninstall" binary-only packages
11:39:56 <amalloy> dcoutts_: wow, the first google hit for that wants to charge me like $45 to read it. they must have some pretty good SEO to outscore the free pdfs
11:40:01 <monochrom> because least effort to get what it needs
11:40:27 <monochrom> GHC worries about libs for a reason. that reason does not exist for exes.
11:40:42 <dcoutts_> amalloy: it's certainly available free, ignore the ACM DL
11:40:49 <amalloy> yeah
11:40:55 <Igloo> janitrix: I don't think you can uninstall libraries, either
11:41:04 <Twey> amalloy: Welcome to the world of paywalled journals
11:41:21 <amalloy> oh, i'm familiar with that world from trynig to read about comonads and so on
11:41:22 <monochrom> as for "what about making user's life easier", I will put on my capitalist hat and ask "how much did you pay?"
11:41:39 <janitrix> Igloo: there is ghc-pkg unregister I think
11:41:50 <monochrom> I, at least, paid my time to write that article
11:41:58 <Igloo> janitrix: That doesn't remove the files from the disk
11:42:18 <janitrix> I know, but it removes it from GHC
11:42:20 <janitrix> which is super confusing
11:42:31 <janitrix> it seems package management leaks all over the place
11:42:36 <janitrix> there is a bit of it everywhere
11:43:10 <janitrix> then there is the fact that cabal is a build system and cabal-install a package management system
11:43:30 <monochrom> yes, my order of preference is: perfect abstraction, no abstraction, leaky abstraction
11:44:00 <janitrix> I still don't undestand why GHC would need to know about packages
11:44:14 <monochrom> read on, my article says why somewhere
11:44:14 <janitrix> why not give it dependencies when compiling?
11:44:29 <janitrix> and let something else care about packaing libraries
11:45:28 <dcoutts_> janitrix: ghc/ghc-pkg pretty much only care about "packages" to the extent that ghc needs it to know how to compile things, ghc's notion of a package is not like rpm/deb notion of a package
11:46:06 <dcoutts_> janitrix: ghc's notion of package is much closer to what pkg-config does for C libraries
11:46:29 <janitrix> dcoutts_: you are telling me ghc "packages" and cabal "packages" have almost nothing in common? :(
11:46:46 <Platz> I thought 2013 was the year of bitcoin
11:46:46 <dcoutts_> janitrix: no, just that they exist at different levels of the system
11:46:56 <Platz> whoops
11:47:02 <monochrom> I don't like the word "package" anyway. packages are computations.
11:47:20 <janitrix> dcoutts_: so it does leak indeed, because the user has to interact at different levels depending on the action needed
11:47:27 <dcoutts_> janitrix: just as you have both the pkg-config layer and the rpm/deb layer for C libs
11:47:47 <dcoutts_> janitrix: yes, the upper layers do not fully wrap the lower
11:48:06 <janitrix> dcoutts_: I don't know nearly enough to tell if it's fucked up or not, but as a beginner used to other systems, it's very confusing :D
11:48:22 <dcoutts_> janitrix: e.g. most users never interact with pkg-config, but some devs have to
11:48:59 <janitrix> dcoutts_: well then you have a dependency issue and you want to remove a couple of packages, and you read "recompiled everything, it's fucked"
11:49:30 <dcoutts_> janitrix: we know that it's not perfect
11:50:22 <janitrix> I'm wondering how people manage their production environment
11:50:42 <levi> janitrix: Haskell is a different sort of language than probably most of those you've used other packaging systems for. And GHC requires things that most languages don't in order to support both separate compilation and efficient binaries.
11:50:48 <dcoutts_> janitrix: and with arbitrary effort it could be better. You also have to realise that all this stuff has been developed incrementally over 10 years or so, and we don't have the same problems as we used to
11:50:50 <janitrix> thanks for the help anyway guys
11:51:43 <levi> janitrix: It's a difficult problem, and there's not a lot of motivation to do the R&D required for a solution that's significantly better.
11:51:43 <janitrix> dcoutts_: I do realize that. I'm not bitching about it (sorry if it looks that way). I'm just very confused and don't know if it's because it IS confusing or I just don't understand
11:52:03 <janitrix> levi: yep I know
11:54:53 <levi> Mostly people who do production Haskell stuff do a lot of sandbox management and recompiling of things. This is what happens in most modern language-specific package systems, but they're mostly designed for dynamic languages or languages with dynamic-recompilng runtimes.
11:55:56 <Nolrai66> Hey I have "((MArray a (Maybe Size) m), (MonadReader (Board a) m))" showing up in all the top level functions of one module, and have some vauge memory of a GHC extension that allows something like the type keyword for contexts?
11:55:58 <levi> I recently installed something via npm and it must have installed 4 or 5 versions of some of the packages.
11:58:42 <janitrix> levi: I understand having a statically typed language changes things for package management since you need everything at compile time. Still, I'm pretty sure it could be handled differently.
11:59:02 <k00mi> Nolrai66: ConstraintKinds
11:59:08 <monochrom> Nolrai66: ConstraintKinds allows you to "type W a = (Read a, Show a)"
11:59:21 <Nolrai66> Ah That was it!
11:59:32 <Nolrai66> Thanks! Would have taken me a while to find.
12:00:52 <levi> janitrix: It's not the static types, necessarily. It's the level of abstraction Haskell provdes. You can't do full separate compilation and get the kind of optimizations that you want.
12:01:09 <janitrix> levi: hmmm I see
12:02:23 <Twey> janitrix: Actually, static types in general help separate compilation
12:02:23 * hackagebot charset 0.3.7 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.7 (EdwardKmett)
12:02:38 <Twey> janitrix: The main problem, as I understand it, is with cross-module inlining
12:04:17 <levi> Yeah; modules can export inlinable versions of code, and other modules will take advantage of those, and now you depend on the binary interface of the module and all those it took advantage of inlining things from.
12:06:06 <levi> So the version number of a package doesn't fully determine the surface of the binary inteface; it also potentially depends on the transitive closure of dependencies it was built against.
12:06:42 <Twey> That said, GHC/Cabal could probably handle it better *cough*Nix*cough*
12:07:08 <Twey> But I don't know most of the issues involved, so I'm leery of making general statements
12:07:22 <levi> This gets you *some* of the benefits of separate compilation, and *some* of the benefits of whole-program optimization. It's a reasonable tradeoff, I think, but you could make different ones.
12:07:59 <dcoutts_> Twey: that's right of course, which is why we've been moving in that direction for the last 5 years
12:08:56 <levi> This sort of thing is available to some extent in the C world as well with modern linkers, as long as you're willing to have statically compiled binaries.
12:09:01 * geekosaur somewhat suspects that the move to dynamic by default is going to change the pain point here, because people are conditioned to believe that dynamic libraries can be swapped around
12:09:36 <dcoutts_> Twey: though we've found that nix has an easier problem than we do, because we also have to deal with in-progress packages not just complete tarballs
12:09:40 <geekosaur> (see how for example so many people on debianoids thought it was perfectly sensible to solve no libgmp.so.3 by symlinking it to libgmp.so.10)
12:10:03 <janitrix> levi: thanks for the info :)
12:10:07 <monochrom> I am one of those people
12:10:27 <monochrom> but I don't think. I empirically test. so far I detect no error.
12:10:57 <hpc> me too, but i don't think, i see that others have done the testing for me ;)
12:11:15 <monochrom> if you say, I extrapolate this tiny success to all libraries, you overestimate my imaginative power.
12:11:45 <geekosaur> I don't claim you do. I do claim that that is how 99% of DSOs work on linux and therefore what people expect
12:12:10 <monochrom> in fact, with 7.6.3, I already build GHC myself to link against gmp10 properly. and with 7.8, it's already linked against gmp10, I need do nothing
12:12:15 <geekosaur> although technically the one I pointed to *is* a violation of the versioning policies
12:12:22 <levi> HP (I think?) had a research project called 'Dynamo' a few years ago that did trace-based on-the-fly recompiling of standard C programs. It made many of them more efficient since it was able to optimze across library boundaries.
12:12:49 <Luke> anyone know AristidBreitkreuz?
12:13:50 <geekosaur> if what they "know" works with gnome does not work with ghc, guess which one will be declared broken?
12:13:51 <levi> http://www.hpl.hp.com/techreports/1999/HPL-1999-78.html
12:14:29 <geekosaur> (the C devs gave up on fixing this years ago, it's why they have versions baked into *both* sides of DSO names now...)
12:15:56 <monochrom> at this point I recommend my http://www.vex.net/~trebla/humour/tautologies.html #1 :)
12:16:09 <johnw> The first rule of tautology club is the first rule of tautology club.
12:16:16 <monochrom> :)
12:17:20 <etandel> http://xkcd.com/703/
12:18:53 <monochrom> I saw and forgot that one!
12:19:11 <ion> The title text :-)
12:20:10 <levi> If the 'Lambdachine' implementation of Haskell ever matured, it would probably be a lot easier to manage deployment with.
12:21:19 <tomejaguar> What is lambdachine?
12:22:10 <levi> http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2012/Schilling
12:22:18 <levi> https://github.com/nominolo/lambdachine
12:23:10 <tomejaguar> Oh that's interesting.  Last commit 11 months ago.  Did it stall?
12:23:44 <yyyyy> stupid question, but can someone help me understand why ambiguity arises here: http://lpaste.net/100073
12:24:17 <bennofs> tomejaguar: there is a commit from 14 days ago on another branch
12:24:25 <bennofs> tomejaguar: (feat-ghc-7.8)
12:26:08 <pavonia> yyyyy: I guess param yields any Parsable, toHtml takes any Parsable and you're making not clear which exact one you really want
12:26:10 <tomejaguar> And 11 days ago on feat-large-objects.  I'm glad people have clever ideas about compiler technology.
12:26:18 <levi> It borrows, from what I understand, from the LuaJIT 2 project, which is an amazing feat of engineering itself.
12:26:30 <Kaidelong> is there any documentation somewhere on in what ways exactly haskell breaks eta-equivalence?
12:26:41 <geekosaur> yep, it's the same problem as (read . show)
12:26:45 <supki> yyyyy: what's the type of group?
12:26:48 <Kaidelong> I'd like to be informed and see it coming rather than having it be a nasty surprise
12:27:03 <milfjord> Kaidelong: I have no context but \x -> f x is defined even if f isn't
12:27:04 <supki> (and how ghc is supposed to figure it out?)
12:27:32 <yyyyy> pavonia, but I was assuming that "group" was already inferred as Text, which does happen after an annotation is included - within the argument to H.toHtml.
12:27:57 <yyyyy> supki, Data.Text, through OverloadedStrings
12:27:57 <levi> Kaidelong: The Haskell Report talks about it a bit, but for a guide as to what's reasonable to do as far as equational reasoning in Haskell, you might check out the paper "Fast and Loose Reasoning is Morally Correct"
12:29:16 <levi> Kaidelong: There are some articless on the Haskell Wiki as well, and on various blogs, but I'm afraid I don't have links for you.
12:29:34 <supki> yyyyy: well, nothing in the code hints it, params outputs something Parsable, and toHtml takes something ToMarkup
12:29:42 <supki> yyyyy: no sign of Text anywhere ;)
12:31:05 <yyyyy> supki, I somehow thought that once imported, OverloadedStrings would default to it - but now that you've said it it would be undecidable. What if there is another 'Overloadable' string in scope. No way to choose.
12:31:41 <geekosaur> it even listed one as a possibility (ByteString)
12:33:12 <supki> yyyyy: OverloadedStrings is unrelated to the problem, the code is still ambiguous even if you disable the extension
12:34:06 <yyyyy> geekosaur, sure, but if I chose it a type error would ensue due to missing ToMarkup instances.
12:35:00 <yyyyy> supki, if toHtml had a concrete type as input, would the type checker simply use it to derive the correct type variable instantiation?
12:35:29 <supki> yes
12:35:30 <geekosaur> also I think you're focusing on the wrong thing still since the type error included a bunch of non-string instances
12:35:55 <geekosaur> the thing in the middle might be one of several string-like types, but the thing going *in*, according to that error, could be anything at all
12:36:01 <geekosaur> as long as it can be toHtml-ed
12:37:22 <yyyyy> geekosaur, yes I see it now. is it correct to reason that the issue was that a type variable never got a concrete type in the entire expression?
12:37:35 <geekosaur> yes
12:38:16 <geekosaur> you said "grab some attribute and toHtml it" --- never saying anything more, so there is a type variable that is only constrained by existence of whatever constraint toHtml has, which apparently covers a lot of different types :)
12:38:43 <geekosaur> as I said, this is the (read . show) problem
12:39:04 <yyyyy> read . show?
12:39:07 <geekosaur> you know what goes in the middle, you know what's coming out because you must to call it, but the type that goes *in* can't be inferred
12:39:25 <geekosaur> :t read . show
12:39:27 <lambdabot> (Read c, Show a) => a -> c
12:39:27 <bennofs> or show . read :) (Which can't even be easily fixed through a type annotation for the whole expression)
12:40:45 <yyyyy> still, if i had no OverloadedStrings, there would be no ambiguity. I would have to use something like Data.Text.pack, which would correctly give a concrete type to param (and toHtml). Is that correct?
12:41:55 <yyyyy> I never looked into it, but are OverloadedStrings simply a type class with compiler support during the parsing stage?
12:42:15 <levi> It makes string literals work like numeric literals.
12:42:48 <geekosaur> OverloadedStrings is not relevant here, I think, the only thing it applies to is the string literal "group" and I doubt that can fix the type of `param`
12:42:50 <levi> I.e., they get inserted into the code as a sort of 'fromLiteral <literal>' call instead of just a plain value.
12:43:04 <geekosaur> (that is, I doubnt that the result type of param depends on exactly what kind of string you passed it)
12:43:27 <yyyyy> geekosaur, it really does not
12:43:40 <geekosaur> right, then OverloadedStrings is not relevant
12:43:46 <yyyyy> oh, actually it does
12:43:50 <geekosaur> ...
12:43:52 <yyyyy> sorry
12:44:07 <yyyyy> here it got inferred as param :: Text -> ActionM Text
12:44:28 <geekosaur> I don't think so
12:45:02 <geekosaur> ActionM Text looks rather too concrete to be causing the compiler to search for a Parseable instance for amn ambiguous type
12:45:54 <c_wraith> jowens: well, I do *now*.  If you're still around.
12:46:09 <jowens> ok
12:46:14 <jowens> lemme upload
12:46:26 <yyyyy> param :: Parsable a => Text -> ActionM a
12:46:40 <jowens> http://lpaste.net/100075
12:46:46 <geekosaur> right
12:46:48 <geekosaur> see that a?
12:46:54 <geekosaur> a is not Text there
12:46:59 <geekosaur> or doesn't have to be
12:47:08 <jowens> "men" marks the one I was hoping to be memoized
12:47:34 <geekosaur> and telling it to treat the literal "group" as String would just complain that it is not Text. it does not set what `a` is at all
12:47:57 <jowens> er "mem" , not "men"
12:48:21 <geekosaur> the ONLY thing OverloadedStrings does ther is let you say "group" instead of calling Data.Text.pack on it
12:48:26 <c_wraith> jowens: It looks memoized, but..  the choice of data structure isn't useful.
12:48:31 <geekosaur> it does not in any way shape or form specify `a` there
12:48:33 <jowens> ok hit me
12:48:54 <c_wraith> jowens: [] is a linked list.  There's no way to get the 1000th element than traversing the 999 before it.
12:49:16 <c_wraith> jowens: that's way more work than just doing the calculation from scratch
12:50:02 <jowens> your catalans example did the same data structure, yeah?
12:50:25 <jowens> (brb)
12:53:11 <yyyyy> geekosaur, yes, i see it now. i'm looking at the implementation of param, and it does `ask` for something within the state (request) through a lookup then parses it. seems obvious, but this also means that a failure to parse will blow up at runtime, right.
12:53:25 <jowens> (back)
12:53:38 <jowens> it would seem bad if a !! b traversed a until it hit b via a linked list
12:54:06 <c_wraith> jowens: yes, but it was a structure where lists were ok.  Calculating each number required looking at every previous number.  Lists are ok for sequential access, it's random access where they are terrible.  And the collatz sequence uses very chaotic access, including potentially numbers *way* bigger than the starting point.
12:54:39 <jowens> understood. i mean, if i was writing this in C++, I'd use a vector
12:54:45 <jowens> which has O(1) random access
12:54:53 <c_wraith> jowens: and you'd write all over uninitialized memory. :P
12:55:02 <jowens> but you're saying a !! b has cost proportional to the magnitude of b?
12:55:05 <joneshf-laptop> how can i set file permissions?
12:55:14 <joneshf-laptop> to the extent of chmod
12:55:17 <c_wraith> jowens: yes, (!! n) is O(n)
12:55:27 <joneshf-laptop> System.Directory only seems to change use permissions
12:55:34 <jowens> ow
12:55:35 <joneshf-laptop> user
12:55:40 <c_wraith> jowens: but pay attention to my other point - the collatz sequence can get *much* larger than the number it starts at.
12:55:49 <jowens> i understand that.
12:56:12 <S11001001> jowens: choosing a data structure is about making the operations you want efficient.  And there's less cause for looking up a list element by index then there may seem.
12:56:15 <yyyyy> what i take from this is that whenever i have a polymorphic return value, i need to somewhere down the expression chain make it explicit, or be sure that any further type classes are implemented for the entire 'domain of types' in the type variable - if that even makes sense.
12:56:39 <c_wraith> jowens: if you were trying to do this with a vector in C++, at least half the numbers past the first third of the vector would look at entries past the end of the vector
12:56:41 <jowens> S11001001: I'd bet there's some sort of haskell structure that has O(1) access.
12:56:57 <S11001001> jowens: Yeah.  But this is less useful than you'd think.
12:57:12 <jowens> c_wraith: understood. I'd have to use C++ vector::reserve if i went off the end
12:57:32 <c_wraith> S11001001: actually, his use case is one of the few where it'd work out ok.
12:57:43 <S11001001> c_wraith: I see.
12:57:44 <c_wraith> S11001001: except for not knowing the necessary upper bound
12:57:52 <geekosaur> joneshf-laptop, I have no idea what you are asking there
12:58:00 <jowens> ok. so in terms of memoizing, this is a harder than usual task b/c of the large potential space needed to memoize
12:58:18 <c_wraith> and because of the chaotic access pattern you get from the function
12:58:57 <dcoutts_> joneshf-laptop: System.Directory is portable, for unix-specific use the unix package which has modules to do that (System.Posix.Directory iirc)
12:59:32 <jowens> so: how do we do better than what i've written?
12:59:55 <joneshf-laptop> geekosaur, i'm asking just what dcoutts_ answered :)
13:00:06 <geekosaur> yyyyy: it does mean that, but depending on the type it may indicate a problem with something else. still unclear is what type you intend `a` to be, which determines which parser matters --- and I have trouble believing a parser for a == () would have issues here :)
13:00:34 <joneshf-laptop> hmm, so there's no platform independent function for this?
13:00:41 <geekosaur> not really
13:00:49 <geekosaur> unix permissions and windows permissions are very different
13:01:16 <geekosaur> if you figure out a sensible way to make a coherent interface that works well for both, there are a whole bunch of NAS vendors who want a word with you :)
13:01:53 <dcoutts_> joneshf-laptop: cabal has this issue too, and we may extend the portable api a bit, so it can cover "this user" and "other users", but the "other" would cover unix's group + other, and on windows something different again
13:02:04 <hpc> geekosaur: apple will just break it again
13:02:12 <hpc> move file permissions into those weird dot-files
13:02:31 <c_wraith> jowens: you get clever.  There are a couple different ways to get clever.  You could use a lazy array with a function that only memoizes some of its results.  You could use an existing clever library, like MemoTrie, which memoizes functions efficiently as long as their argument can be used as a key in a trie lookup
13:02:36 <dcoutts_> joneshf-laptop: but it'd be just enough to be able to create files that are (for example) readable to the user but noone else, or readable to everyone
13:03:20 <jowens> this is not a haskell-specific difficulty. this is just a slightly hairier function than, say, catalans
13:03:27 <jowens> (IMHO)
13:03:41 <Luke> is there a new recommended way of using haskell-mode with cabal sandboxes? C-l doesn't correctly reload anymore
13:03:48 <geekosaur> hpc: nobody cares about Apple ACLs to speak of
13:03:52 <jowens> all that being said: is what I wrote memorizing *at all*?
13:03:58 <jowens> (spell check)
13:04:01 <geekosaur> the only thing I've ever seen use them is time machine
13:04:21 <jowens> I tried to make collatzCountMem a named object so that it would memoize
13:05:02 <c_wraith> jowens: it is memoizing, if I read it correctly, but at a cost exceeding that of just recalculating.  you could try throwing stuff like the Debug.Trace bit I did at it.
13:07:29 * hackagebot hweblib 0.6.1 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.6.1 (AycanIrican)
13:09:02 <conal> jowens: howdy. nice to see you on #haskell.
13:09:02 <jowens_> (sorry, network blip. thanks very much for all this kind commentary. I learned a lot!)
13:09:23 <jowens> conal: hi! lots of nice folks helping me with my self-study!
13:09:37 <conal> jowens: :D
13:09:57 <jowens> trying to be reasonably intelligent by mid-march
13:09:59 <c_wraith> jowens: by the way, conal is the author of the MemoTrie lib I just mentioned.
13:10:15 <jowens> c_wraith: yeah, he's all over the memoization literature like a bad rash.
13:10:41 <jowens> in a good way, of course.
13:11:02 <conal> i didn't find memoization very interesting when i started poking into it, but it just kept getting prettier.
13:11:44 <jowens> to do it automatically when appropriate without explicitly declaring data structures for it or explicitly asking for it to happen seems like a neat trick, and a problem worth attacking.
13:11:51 <conal> i originally learned about memoization in operational, imperative terms, which obscures the essence.
13:12:21 <yyyyy> geekosaur, but to reach a point where a == () comes out of the parse the function would necessarily not be total, right? or does this have to do with the 'bottom inhabits every type' issue?
13:12:25 <conal> now i think the essence of memoization is simply conversion of functions into data structures. laziness helps a good deal to make it practical.
13:13:02 <johnw> is conal the Elliott variety?
13:13:07 <jowens> i made note of one of c_wraith's prescient comments earlier: "Most memoization in haskell comes from replacing recursive function calls with recursive data definitions."
13:13:15 <conal> johnw: yes.
13:13:24 <johnw> then hello again!  we talked about Emacs at ICFP
13:13:25 <geekosaur> yyyyy: () was the fiirst type suggested in that error you got :)
13:13:37 <conal> johnw: hi. i remember.
13:15:01 <conal> jowens: agreed. deciding whether to memmoize is tricky & useful to automate. we have a single simplistic choice in typical haskell implementations, which is to memoize data structures but not lambdas, although they're conceptually similar.
13:15:21 <jowens> conal: sensible. and understood.
13:15:35 <jowens> and as i mentioned in my email, poorly explained on the wiki page. :)
13:15:47 <conal> jowens: sorry about that.
13:15:56 <jowens> conal: I don't blame you!
13:16:06 <conal> jowens: i knew you didn't
13:21:54 <c_wraith> jowens: are you interested in seeing an example of a half-clever colution to this, that partially memoizes?  (Trust me, it's not actually clever)
13:22:00 <jowens> natch
13:22:05 <jowens> hit me
13:22:12 <yyyyy> geekosaur, my point (i think) is that if you have a function e.g. p :: Text -> a; p t | T v1 <- f t = T t (...), and all possible Text cases for the guards are taken in account, shouldn't 'a' in this case be an 'anonymous sum type' of sorts? maybe i'm simply confused.
13:22:52 <yyyyy> (and in this case () would never appear in that sum type)
13:23:02 <geekosaur> anonymous sum type?
13:23:09 <geekosaur> you are rather confused, I think
13:23:23 <geekosaur> the point here is: a is a type with only one constraint, Parseable a
13:23:45 <c_wraith> jowens: http://lpaste.net/100076
13:23:46 <geekosaur> nowhere is it specified *what* a
13:24:16 <geekosaur> there must be some specific a for the program to compile, since it needs to know which parser to apply
13:24:43 <geekosaur> (this is not runtime information! all types go away at runtime. it must pick the type, and therefore the parser, at *compile* time)
13:24:47 <yyyyy> `Text -> a` would be `Text -> A1` where A1 is (conceptually) a data A1 = Return1 | Return2 | Return3 (...) of possible the function is capable of 'emitting' as output
13:25:07 <c_wraith> jowens: That is not pretty code.  It involves silly heuristics and bizarre helper functions.  But it does memoize some of the work, based on a guess on what size memo table it needs, then calculate the few overflowing bits without memoizing them
13:25:11 <yyyyy> possible types*
13:25:31 <geekosaur> also, if you are imagining something like Java where a value carries a type with it (perhaps implicitly by what messages it responds to)... it does not
13:25:46 <jowens> that's the size = 3x?
13:25:50 <jowens> "some of the work"
13:26:02 <jowens> i'm presuming listArray is a O(1) access?
13:26:21 <c_wraith> yeah.  Numbers in the collatz sequence can exceed 3x starting value
13:26:21 <jowens> and lookup is the accessor
13:26:22 <c_wraith> So it's just a guess
13:26:24 <jowens> ah
13:26:32 <jowens> well, yeah, that's not exactly lovely
13:26:32 <c_wraith> actually, listArray is O(n) list creation
13:26:42 <jowens> but O(1) access? the ! ?
13:26:43 <c_wraith> ! is the O(1) lookup function
13:26:43 <yyyyy> geekosaur, is type instantiation for that variable (i lack the terminology) always based on the expressions passed for function application?
13:26:45 <jowens> ok
13:26:46 <geekosaur> yyyyy: your formulation implies that something somewhere *at runtime* knows what type was chosen.
13:26:51 <jowens> what's the diff btwn ! and !!?
13:26:53 <geekosaur> there is no "chosen", there is no type at runtime
13:27:15 <c_wraith> jowens: !! is for [], ! is for Arrays, as in Data.Array.  They're just different library-defined infix operators
13:27:15 <geekosaur> jowens: (!) applies to Data.Array, (!!) to Data.List
13:27:26 <yyyyy> i see
13:27:35 <jowens> crazy kids
13:27:49 <jowens> with their variable number of bangs
13:28:10 <c_wraith> you don't mean "crazy languages with their library-defined infix operators"? :)
13:28:30 * geekosaur hands jowens the yak shears
13:28:44 <jowens> well, my previous fp experience was scala, so this is not altogether foreign to me
13:29:02 <yyyyy> thanks. i think that makes more sense now.
13:29:04 <c_wraith> ah, ok.  The rules are a little simpler than scala's, at least
13:29:27 * davidfetter_disq wonders what happens when you compose function programming with dysfunctional programming
13:29:58 <davidfetter_disq> functional*
13:30:00 <davidfetter_disq> ugh
13:30:05 <c_wraith> davidfetter_disq: remember, dysfunctional doesn't mean non-functional.  It just means functional in a suboptimal way. :)
13:30:09 <jowens> c_wraith: you're a champ. thanks mucho.
13:30:40 <davidfetter_disq> hrm
13:31:02 <c_wraith> jowens: you're welcome.  And remember, the MemoTrie library would result in *way* prettier code. :)
13:31:18 <jowens> i know conal will hook me up with good technical support
13:31:21 <davidfetter_disq> i always thought of dysfunctional programming as more an organizational matter, where "organizational" here refers to organizations of humans into groups
13:31:31 * mangaba_leitosa began the course about oz/mozart https://www.edx.org/course/louvainx/louvainx-louv1-01x-paradigms-computer-1203 (starting today)
13:31:40 <mangaba_leitosa> they made a nice easy to install emacs-based ide for mozart
13:31:57 <conal> jowens: a drawback of the array approach is that it forces you to choose a finite segment to memoize. lists don't, but you get linear lookup. binary tree is a good compromise, for unbounded size and efficient (log-time) lookup
13:32:19 <conal> jowens: ... which is what MemoTrie would give you.
13:32:41 <jowens> conal: i agree. and for the odd sequence i'm memoizing, it's clearly a better fit
13:32:47 <conal> jowens: and since you know hardware, you know that "constant-time" array access is really log-time anyway.
13:33:49 <jowens> low constants though on that log term
13:34:12 <jowens> that's a good prelims question though, i'll write it down
13:36:08 <Forgetaboutit> conal: I honestly never really though about it that way!  So obvious but thanks anyway :)
13:37:33 <conal> Forgetaboutit: me neither until i heard john o'donnell point it out.
13:38:05 <jowens> btw, general question: i do just about everything in emacs. i am trying eclipse. one thing i really like is the ability to type random stuff into the bottom pane and get it evaled right away; it appears to run ghc constantly and keep recompiling and makes good suggestions and has hoogle access. is there anything else i should look at, either in emacs or in another editor/environment?
13:38:08 <jmcarthur> arrays aren't constraining for small enough domains, of course.
13:38:40 <jowens> (os x btw)
13:38:58 <jmcarthur> and lists are a fine way to memoize peano numerals :)
13:39:07 <jmcarthur> *on the domain of
13:40:33 <conal> jmcarthur: and not only a fine way but the natural way, in that the general memoization scheme invents list from peano naturals
13:40:49 <AlainODea> jowens: the :complete feature in 7.8.1 looks promising and apparently works well with the right mix of emacs packages
13:40:54 <conal> oops -- didn't intend that double meaning of "natural" .
13:40:55 <Forgetaboutit> jowens: you can integrate hoogle into GHCi, saw that somewhere.
13:42:29 <AlainODea> jowens: dysinger is in the process of trying a new mix on Emacs now. https://twitter.com/dysinger/status/435478299964239872
13:42:55 <peddie> jowens: if you use ghc-mod for emacs, it will underline errors and suggestions from GHC and hlint in your buffer
13:42:59 <jowens> ok. i'll poke about the emacs repos. AlainODea: thanks for that link! timely for sure.
13:43:56 <conal> jowens: btw, i work almost exclusively inside emacs also. we can compare notes when i visit next month.
13:44:29 <conal> jowens: also in mac os
13:45:41 <tomejaguar> Actually since we live in three dimensions, data access is at least O(n^(1/3)) regardless of the storage format, but if you take it that far it becomes silly :)
13:47:03 <Forgetaboutit> jowens: are you already using structured Haskell mode in Emacs?
13:47:35 <jowens_> forgetaboutit: no, i just started fresh with eclipse
13:47:43 <Forgetaboutit> jowens: It obviously still needs some work, but it's pretty decent already.
13:47:57 <jowens> i'm certainly biased towards trying it.
13:48:39 <gfredericks> yo abstract algebra fans do you recall the name of an algebraic structure that has subtraction defined but not addition?
13:49:10 <Twey> gfredericks: Subtraction isn't an operation, it's just addition of an inverse
13:49:18 <jmcarthur> tomejaguar: where do you arrive at that figure?
13:49:20 <jmcarthur> *how
13:49:21 <gfredericks> Twey: yeah that's what's weird about it :)
13:49:40 <gfredericks> Twey: simplest example is points in space -- you can subtract them to get a distance, but you can't add them meaningfully
13:49:40 <bennofs> tensor?
13:49:55 <tomejaguar> torsor?
13:50:00 <gfredericks> torsor!
13:50:02 <gfredericks> that's it
13:50:04 <bennofs> ah, nearly right :p
13:50:09 <jmcarthur> tomejaguar: and i wonder if it's different when accounting for relativistic effects, since we're being extremely pedantic now.
13:50:15 <Twey> Huh, that's a thing?  Cool
13:50:22 <gfredericks> tomejaguar: cool, thanks :)
13:50:30 <tomejaguar> jmcarthur: You can only access t^3 units of storage in time t
13:50:36 <tomejaguar> O(t^3)
13:51:09 <jowens> forgetaboutit: only about half those packages in package-get-packages, alas.
13:51:29 <jmcarthur> tomejaguar: oh, i interpreted it differently, is all i was confused about
13:51:39 <jmcarthur> tomejaguar: i was still thinking about addressing
13:52:10 <Forgetaboutit> jowens: Yeah, you have to clone the repo manually yet
13:52:12 <jmcarthur> tomejaguar: but you are talking about the distances of information retrieval
13:52:18 <tomejaguar> jmcarthur: Exactly
13:52:24 <c_wraith> jowens: oh, by the way, I did want to point out one more thing about the array implementation.  It doesn't automatically evaluate cc at every point in the array.
13:52:40 <jowens> no, it should do it on demand, yah?
13:52:58 <c_wraith> jowens: yes, it does.  Which makes it memoization, even though it looks more like dynamic programming.
13:53:33 <c_wraith> jowens: note, however, that's the result of using the default Array type.  Other modules have different Array types that do force everything to be evaluated as it's inserted
13:53:41 <jowens> gotcha
13:54:05 <jmcarthur> i look forward to "distance oblivious" algorithms and data structures for actor models or something
13:54:38 <c_wraith> jowens: that's a minor technical point that I thought I should add.  But overall, I agree with Conal about trees being a nicer tradeoff. :)
13:55:03 <jowens> i am still in BFS mode not DFS mode for learning haskell. but i will get there soon enough.
13:58:12 <zipper> np Will.i.am ft Miley Cyrus - Feelin' Mysel
13:58:18 <zipper> np Will.i.am ft Miley Cyrus - Feelin' Myself
13:58:41 <johnw> zipper: not here
13:59:09 <zipper> johnw: That fold did not work btw
13:59:17 <johnw> i didn't try it here
14:01:41 <zipper> johnw: I am seriously groping in the dark https://gist.github.com/urbanslug/9056891
14:02:00 <johnw> what is "do" doing in there?
14:02:27 <johnw> you may want to go back to the drawing board here, and read up on folds some more
14:02:39 <zipper> johnw: Not again
14:03:01 <johnw> as many times as it takes; the pain is worthwhile
14:04:26 <enthropy> foldr1 isn't going to work there
14:04:32 <enthropy> @src (!!)
14:04:33 <lambdabot> xs     !! n | n < 0 = undefined
14:04:33 <lambdabot> []     !! _         = undefined
14:04:33 <lambdabot> (x:_)  !! 0         = x
14:04:33 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:04:59 <enthropy> you can try to translate that into a foldr
14:05:00 <zipper> enthropy: A fold cannot be used in such a case?
14:05:18 <enthropy> no you can write !! in terms of foldr
14:06:41 <zipper> I'm lost
14:06:47 <zipper> I'm going to bed.
14:08:52 <yesthisisuser> what's the cleanest way to make an (Maybe (IO a) into an IO a ?
14:09:49 <Fuuzetsu> yesthisisuser: maybe (return ()) id
14:09:51 <S11001001> yesthisisuser: depends on what a is
14:09:55 <pranz> yesthisisuser: you can't for any a
14:10:06 <Fuuzetsu> oh, for IO a
14:10:08 <enthropy> fromMaybe (error "something horrible happened")
14:10:10 <milfjord> const (fail "hi")
14:10:39 <Fuuzetsu> just case on the Maybe where you need to use it
14:10:57 <S11001001> @hoogle strength
14:10:58 <lambdabot> No results found
14:11:05 <pranz> @hoogle error
14:11:05 <lambdabot> Prelude error :: [Char] -> a
14:11:05 <lambdabot> Control.OldException errorCalls :: Exception -> Maybe String
14:11:05 <lambdabot> package error-loc
14:11:11 <yesthisisuser> ok.. wait IO () we could say
14:11:22 <S11001001> yesthisisuser: then what Fuuzetsu first said
14:11:30 <yesthisisuser> yes. thanks
14:11:45 <S11001001> yesthisisuser: it is also straightforward to flip the Maybe and IO there.
14:12:07 <S11001001> @ty traverse :: forall a. Maybe (IO a) -> IO (Maybe a)
14:12:09 <lambdabot>     Couldn't match type `a0 -> f0 b0' with `Maybe (IO a)'
14:12:09 <lambdabot>     Expected type: Maybe (IO a) -> IO (Maybe a)
14:12:09 <lambdabot>       Actual type: (a0 -> f0 b0) -> t0 a0 -> f0 (t0 b0)
14:12:12 <milfjord> :t ap maybe (>>) (return ())
14:12:13 <lambdabot> Monad m => Maybe (m ()) -> m ()
14:12:27 <S11001001> @ty sequence :: forall a. Maybe (IO a) -> IO (Maybe a)
14:12:28 <lambdabot>     Couldn't match type `[IO a0]' with `Maybe (IO a)'
14:12:28 <lambdabot>     Expected type: Maybe (IO a) -> IO (Maybe a)
14:12:29 <lambdabot>       Actual type: [IO a0] -> IO [a0]
14:12:36 <S11001001> @ty Data.Traversable.sequence :: forall a. Maybe (IO a) -> IO (Maybe a)
14:12:37 <lambdabot> Maybe (IO a) -> IO (Maybe a)
14:12:53 <yesthisisuser> one could also do maybeToList and then sequence
14:12:57 <yesthisisuser> but that's just .. hmm
14:13:00 <S11001001> blecch
14:15:17 <pranz> F.mapM_ (>> return ())
14:19:21 <enthropy> @type sequenceA_
14:19:23 <lambdabot>     Not in scope: `sequenceA_'
14:19:23 <lambdabot>     Perhaps you meant one of these:
14:19:23 <lambdabot>       `F.sequenceA_' (imported from Data.Foldable),
14:23:13 <pranz> :t F.sequenceA_
14:23:14 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f ()
14:29:17 <benbangert> I'm trying to write a FromJSON instance, but the example here doesn't work: http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson.html#g:11
14:29:32 <benbangert> I seem to be unable to import an Object value constructor
14:29:37 <benbangert> prolly cause Object is a type alias.....
14:31:54 <hpc> oh, looks like that "Object" is mis-linked
14:31:56 <hpc> http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson.html#t:Value
14:32:01 <hpc> it's a data constructor for Value
14:32:33 <Luke> guys i'm trying to get my haskell-mode working with cabal sandbox. apparently I have to use "cabal repl" instead of "ghci" but simply changing the command that's called fails at "finding the prompt"
14:32:38 <hpc> (Object :: HashMap Text Value -> Value)
14:32:45 <Luke> any hints as to how to use haskell-mode with cabal repl?
14:32:49 <hpc> that type alias is awful
14:32:49 <benbangert> hpc: ah, cool, yea importing it as Value(Object) grabbed it
14:33:24 <c_wraith> wait, you can declare a data family instance with newtype?  Huh.
14:33:47 <hpc> c_wraith: unsafeCoerce here we come?
14:34:28 <c_wraith> hpc: well, data families are, in fact, data types.  I assume it just removes the runtime overhead in cases where it doesn't matter
14:34:41 <bennofs> c_wraith: there is no such thing as a newtype families, is there?
14:34:50 <benbangert> kinda wonder why the generic instance wasn't as lenient as the FromJSON I defined
14:34:55 <c_wraith> bennofs: correct
14:35:04 <benbangert> maybe it was checking the wrong json key. hm
14:35:35 <Luke> how do I simply start haskell-interactive-mode in it's own buffer?
14:36:48 <c_wraith> I think I finally understand what data families *do*.
14:37:46 <cmears> Luke: maybe you want "M-x run-haskell"?
14:37:59 <Luke> i just found the docs - you may be right
14:38:01 <DarkLinkXXXX> I've been having some trouble trying to install the haskell platform with ghc from HEAD. Is that a bad idea?
14:38:03 <hpc> c_wraith: they're sort of GADT-ish, yes?
14:38:04 <Luke> http://haskell.github.io/haskell-mode/manual/latest/#haskell_002dinteractive_002dmode
14:38:14 <cmears> Luke, and "C-u M-x run-haskell" will let you choose the interpreter
14:39:06 <Luke> cmears: that's what C-c C-l already runs. same problem
14:39:08 <Luke> can't find the promp
14:40:00 <Luke> basically the docs are saying I need to replace all my standard key bindings to get access to interactive-mode
14:40:32 <Fuuzetsu> Luke: (setq haskell-program-name "cabal repl")
14:40:50 <Fuuzetsu> you might have to C-c C-l twice, first time it configures (can't find the prompt) and then it should work
14:40:50 <Luke> Fuuzetsu: no that's basically the same thing cmears suggested
14:41:03 <Luke> Fuuzetsu: doesn't seem to wokr
14:41:05 <Luke> same problem
14:41:12 <cmears> Luke, the way I use emacs+ghci+sandbox is to set GHC_PACKAGE_PATH and the PATH before I run emacs
14:41:21 <cmears> Then emacs just runs ghci as normal, but it uses the sandbox
14:41:22 <Fuuzetsu> Luke: what does it say when you run cabal repl from the command line? If it doesn't work there, it won't work in emacs.
14:41:38 <Luke> it works fine
14:42:07 <ij> I'm quite sure this is impossible, but can I somehow run haskell in a php host? I was given some free hosting for a site and I wouldn't mind using it properly.
14:42:09 <OODavo> I'm trying to cabal install web-encodings, but it's failing to install the directory package because lots of things aren't in scope, including Prelude.catch. What should I do about that? I've got GHC 7.6.3 as installed from the Ubuntu Saucy repositories.
14:42:11 <Luke> trying to use it as the command path does this: "inferior-haskell-wait-for-prompt: Can't find the prompt"
14:42:15 <Fuuzetsu> I don't know then, Works For Me™ and I don't see why it wouldn't for you
14:42:39 <Luke> Fuuzetsu: yeah I don't know either. What you suggested is the first thing I tried
14:42:49 <Luke> just doesn't seem to work because of the can't find prompt thing
14:43:16 <Luke> there's also other issues. ghc-mod seems to also not like compling my project anymore
14:43:38 <DarkLinkXXXX> If I build ghc from source, should I install haskell-platform, or just install things as I need them?
14:43:54 <Fuuzetsu> Luke: what does the *haskell* buffer say after you C-c C-l? It should tell you what's wrong.
14:44:38 <Fuuzetsu> Perhaps you're in the wrong directory.
14:44:40 <Luke> Fuuzetsu: http://lpaste.net/100077
14:44:54 <Fuuzetsu> yep
14:44:56 <Fuuzetsu> M-x cd
14:44:57 <Luke> looks like you're right: no file found
14:45:08 <Fuuzetsu> then choose the directory with your cabal file
14:45:15 <Fuuzetsu> the try C-c C-l again (twice)
14:45:23 <Luke> I'm adding ghc-ghc-options "-isrc"
14:45:25 <Luke> that should fix it
14:45:36 <Luke> is there a way to get it so I don't have to run it twice?
14:45:45 <Fuuzetsu> I don't think that will fix it
14:46:01 <Fuuzetsu> Luke: it will only need to be ran twice the first time around after making some changes
14:46:11 <Fuuzetsu> it's because it calls cabal configure for you and emacs gets confused
14:46:13 <joneshf-laptop> does cabal support post-install hooks?
14:46:36 <joneshf-laptop> like, after an executable is installed, run some script
14:46:46 <Fuuzetsu> making some changes to the cabal file that is, not your source files
14:47:11 <Luke> Fuuzetsu: yeah still not finding the dir by default
14:47:26 <Fuuzetsu> Luke: run M-x pwd
14:47:28 <Luke> its not going to the parent dir
14:47:41 <Luke> its pwd is the .hs file bascailly
14:47:41 <Fuuzetsu> well, does it matter? Just cd to the parent dir
14:47:50 <Luke> i don't want to do that every time
14:48:09 <Fuuzetsu> you'll only have to do that once; once your REPL is open, you can just C-c C-l and it will do the right thing
14:48:10 <Luke> normal inf-haskell finds the project root dir for me
14:48:32 <Luke> by ever time I mean every time I open a different project
14:49:10 <NemesisD> do you guys have any advice on how to develop an intuition for when its appropriate to create a DSL in haskell
14:49:14 <joneshf-laptop> let me ask this instead
14:49:33 <Fuuzetsu> you could use the function from the inferior haskell mode that finds the file and have a pre-run advice to cd there or something
14:49:36 <Fuuzetsu> but that's up to you to make
14:50:02 <joneshf-laptop> i want to set up xdg directories for an executable after it is `cabal install`-ed, what's the best way to go about this?
14:50:03 <Rembane> NemesisD: I suppose you're in a position where a DSL wasn't the right tool for the job, or it was?
14:51:11 <khyperia> what is this NixOS I just found on /r/haskell?
14:51:14 <Luke> Fuuzetsu: if I can get it to run the "find root" logic first then I don't have to rerun any command twice
14:51:21 <Luke> its all a problem with not finding the root
14:51:53 <ij> khyperia, OS built on the purely functional pkg manager nix.
14:51:59 <NemesisD> Rembane: i'm actually not currently working on anything. i've just been reading about free monads and GADTs and all the examples are contrived
14:52:04 <khyperia> ah
14:52:28 <NemesisD> Rembane: i recently was at a haskell meetup with someone who does it as their full time job and i didn't get a chance to ask in more detail. he said they create lots of EDSLs with GADTs
14:54:00 <Rembane> NemesisD: Ah. Maybe you need to reach a certain level of complexity for a problem to have a good fit for a DSL.
14:54:04 <Rembane> NemesisD: What's a EDSL?
14:54:23 <NemesisD> embedded domain specific language
14:55:43 <BeardedCoder> Luke: Are you still having Emacs Cabal issues? I found some code a while back that straightened it out for me.
14:55:53 <Luke> BeardedCoder: yeah
14:56:48 <BeardedCoder> Luke: it's for changing the working directory. https://gist.github.com/BJTerry/3693479
14:56:55 <Luke> thanks
14:57:04 <Luke> looks like what I need
14:57:17 <BeardedCoder> Luke: NP, I've been using that gist for several months.
14:57:30 <Luke> too bad this functionality isn't just build in
14:57:38 <Luke> looks like we need a change to haskell-mode
15:00:34 <jle`> if i ever make a Haskell FPS i will call it Call of Function
15:00:50 <jle`> first person shooter that is
15:02:42 <johnw> Lazy vs. Strict
15:04:20 <bitemyapp> jle`: make the damage lazy so it doesn't register until you've accumulated enough to die, then it derefs the thunks all at once
15:04:29 <bitemyapp> jle`: and you go from clear vision to red jam all over the screen all at once
15:07:18 <c_wraith> jle`: do you play fighting games at all?  Blazblue has a character with move names like p -> q and f o g
15:07:44 <roconnor_> jle`: have you seen Frag
15:07:52 <roconnor_> http://www.haskell.org/haskellwiki/Frag
15:09:26 <dwcook> bitemyapp, if the damage were truly lazy, how would you know when you've accumulated enough without evaluating it? :P
15:10:02 <bitemyapp> dwcook: strict side effect accum. it was a silly comment.
15:10:22 <dwcook> Yeah, figured it was
15:10:39 <Twey> dwcook: Lazy numbers!
15:11:09 <dwcook> Twey, explain?
15:11:49 <roconnor_> > 3 < (infinity :: Nat)
15:11:53 <lambdabot>  mueval-core: Time limit exceeded
15:11:56 <Twey> @let lazyLTE [] [] = True; lazyLTE (_ : _) [] = False; lazyLTE [] (_ : _) = True; lazyLTE (_ : xs) (_ : ys) = lazyLTE xs ys
15:11:59 <lambdabot>  Defined.
15:12:31 <Twey> > lazyLTE [(), (), ()] $ () : () : () : () : undefined
15:12:34 <lambdabot>  True
15:12:39 <dwcook> Neat.
15:12:52 <Twey> (you can make a Num instance but not in lambdabot)
15:13:13 <c_wraith> are you sure?  you can add data declarations in lambdabot now
15:13:22 <Twey> No, not sure
15:13:35 <dwcook> > type Nat = Fix Maybe
15:13:37 <lambdabot>  <hint>:1:1: parse error on input `type'
15:13:44 <c_wraith> dwcook: with @let
15:14:06 <dwcook> Is it personal or global or something else?
15:14:11 <c_wraith> global
15:14:21 <c_wraith> and anyone can erase them at any point, to go back to the pristine state
15:14:34 <dwcook> @kind Nat
15:14:34 <mm_freak> you can do pretty much anything
15:14:37 <lambdabot> Not in scope: type constructor or class `Nat'
15:14:46 <dwcook> @let Nat = Fix Maybe
15:14:47 <lambdabot>  .L.hs:145:1: Not in scope: data constructor `Nat'
15:14:47 <lambdabot>  
15:14:47 <lambdabot>  .L.hs:145:7: Not in scope: data constructor `Fix'
15:14:47 <lambdabot>  
15:14:47 <lambdabot>  .L.hs:145:11: Not in scope: data constructor `Maybe'
15:14:49 <dwcook> @let type Nat = Fix Maybe
15:14:50 <lambdabot>  .L.hs:146:12: Not in scope: type constructor or class `Fix'
15:14:52 <mm_freak> @let import qualified Data.Maybe as Blah
15:14:54 <lambdabot>  Defined.
15:15:00 <mm_freak> :t Blah.maybe
15:15:01 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:15:13 <dwcook> @let newtype Fix f = Fix (f (Fix f))
15:15:14 <lambdabot>  Defined.
15:15:16 <mm_freak> of course restricted by safe haskell
15:15:17 <dwcook> @let type Nat = Fix Maybe
15:15:18 <lambdabot>  Defined.
15:15:26 <c_wraith> what's the command to reset?  @undefine?
15:15:31 <no-n> @src concat
15:15:31 <lambdabot> concat = foldr (++) []
15:15:32 <mm_freak> yeah
15:15:45 <dwcook> > Just (Just (Just Nothing)) :: Nat
15:15:47 <lambdabot>  Couldn't match type `Data.Maybe.Maybe
15:15:47 <lambdabot>                         (Data.Maybe.Maybe (Data.Maybe.Maybe (Data.Maybe.Maybe...
15:15:47 <lambdabot>                with `L.Fix Data.Maybe.Maybe'
15:15:47 <lambdabot>  Expected type: L.Nat
15:15:47 <lambdabot>    Actual type: Data.Maybe.Maybe
15:15:55 <dwcook> Woops
15:16:00 <c_wraith> forgot your constructors. :P
15:16:03 <dwcook> Yeah
15:16:10 <dwcook> It's a silly definition anyway :P
15:16:18 <mm_freak> lambdabot is the most powerful IRC bot in existence…  it probably has its own nuclear reactor for @djinn and @pl =)
15:16:21 <dwcook> @undefine Nat
15:16:21 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
15:16:29 <dwcook> Welp.
15:16:42 <Twey> @let instance Num [a] where (+) = (++); xs * ys = sequence [xs, ys]; xs - ys = drop (length ys) xs; negate = error "Negation of naturals"; abs = id; signum [] = 0; signum _ = 1; fromInteger = flip replicate undefined
15:16:43 <lambdabot>  .L.hs:153:19:
15:16:43 <lambdabot>      Couldn't match type `a' with `[a]'
15:16:43 <lambdabot>        `a' is a rigid type variable bound by
15:16:43 <lambdabot>            the instance declaration at .L.hs:151:10
15:16:43 <lambdabot>      Expected type: [a]
15:17:14 <Twey> Oh, right
15:17:37 <Twey> @let instance Num [a] where (+) = (++); xs * ys = sequence [xs, ys]; xs - ys = drop (length ys) xs; negate = error "Negation of naturals"; abs = id; signum [] = []; signum _ = [undefined]; fromInteger = flip replicate undefined
15:17:38 <lambdabot>  .L.hs:153:19:
15:17:39 <lambdabot>      Couldn't match type `a' with `[a]'
15:17:39 <lambdabot>        `a' is a rigid type variable bound by
15:17:39 <lambdabot>            the instance declaration at .L.hs:151:10
15:17:39 <lambdabot>      Expected type: [a]
15:18:15 <ski> @type \xs ys -> sequence [xs,ys]
15:18:17 <lambdabot> Monad m => m a -> m a -> m [a]
15:18:46 <mm_freak> try (*) = liftA2 const
15:18:52 <Twey> @let instance Num [a] where (+) = (++); xs * ys = map (const undefined) $ sequence [xs, ys]; xs - ys = drop (length ys) xs; negate = error "Negation of naturals"; abs = id; signum [] = []; signum _ = [undefined]; fromInteger = flip replicate undefined . fromIntegral
15:18:54 <lambdabot>  Defined.
15:19:02 <Twey> Oh, that would have been nicer, yeah
15:19:16 <Twey> > 3 :: [()]
15:19:20 <lambdabot>  [*Exception: Prelude.undefined
15:19:25 <dwcook> Heh
15:19:27 <mm_freak> also an instance for [()] would be more sensible
15:19:27 <OODavo> Here's what's failing when I try to cabal-install web-encodings: http://sprunge.us/SPcS Not sure what I've got wrong here.
15:19:32 <c_wraith> that's what you get for that definition of fromInteger. :P
15:19:42 <mm_freak> because [a] ≃ ℕ only if a ≃ 1
15:19:43 <Twey> Just according to plan!
15:20:09 <Twey> mm_freak: True; it screws up the definition of (==), I suppose
15:20:47 <mm_freak> well, i'd define a completely different instance =)
15:21:17 <mm_freak> instance (Num a) => Num [a] where (+) = liftA2 (+); (-) = liftA2 (-); …
15:21:35 <mm_freak> i believe that there is a TH helper package on hackage to derive instances like that
15:21:44 <dwcook> > 1 :: ()
15:21:46 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal `1'
15:21:46 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num ())
15:21:49 <mm_freak> (but for some reason i write them by hand each time)
15:22:07 <mm_freak> dwcook: it's an instance unrelated to natural numbers
15:22:21 <dwcook> mm_freak, what?
15:22:24 <Twey> > 1 :: [()]
15:22:27 <lambdabot>  [*Exception: Prelude.undefined
15:22:34 <mm_freak> > length 1
15:22:36 <lambdabot>  1
15:22:45 <Twey> It's a valid instance, you just can't look inside the list
15:22:51 <mm_freak> > length (15 + 17)
15:22:53 <lambdabot>  32
15:23:11 <dhrosa> :t length
15:23:12 <lambdabot> [a] -> Int
15:23:20 <dwcook> Oh, the only reason I did that was because I was thinking there's a sane definition for (Num a) => Num [a] and another for Num [()], which would overlap. That led me to wonder whether someone was crazy enough to write Num ().
15:23:23 <Twey> Though actually I wanted to define Ord
15:23:35 <mm_freak> Twey: i don't consider anything that strictly relies on bottom to be anything close to valid
15:23:45 <Twey> Touché
15:23:49 <dhrosa> what?why does length (15 + 17) work?
15:23:56 <jmcarthur> mm_freak: I don't consider anything that strictly relies on bottom to terminate. :P
15:24:03 * Twey groans.
15:24:18 <mm_freak> dhrosa: because of the abuse instance that Twey defined above =)
15:24:21 <dwcook> @type length `asAppliedTo` (15 + 17)
15:24:22 <Rylee> > length 5
15:24:22 <lambdabot> [a] -> Int
15:24:23 <lambdabot>  5
15:24:36 <Rylee> > length [5]
15:24:38 <lambdabot>  1
15:24:43 <dhrosa> oh I didn't see that
15:25:05 <c_wraith> I'm really tempted to yell "party's over!" and then undefine. :P
15:25:12 <mm_freak> @undefine
15:25:12 <lambdabot> Undefined.
15:25:14 <mm_freak> =P
15:25:27 <c_wraith> ok, party's over!
15:25:46 <mm_freak> i missed my type errors
15:25:48 <mm_freak> > length 1
15:25:50 <lambdabot>  No instance for (GHC.Num.Num [a0]) arising from the literal `1'
15:25:50 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num [a0])
15:26:24 <Twey> Oh, there is actually already an Ord instance
15:26:49 <Twey> I'm not sure if I like this:
15:26:52 <Twey> > () > ()
15:26:53 <lambdabot>  False
15:27:10 <c_wraith> well, (>) shouldn't be reflexive!
15:27:15 <Twey> But anyway, dwcook,
15:27:32 <Twey> > [(), (), ()] < (() : () : () : () : undefined)
15:27:33 <lambdabot>  True
15:27:40 * hackagebot wai-routing 0.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.1 (ToralfWittner)
15:27:41 <no-n> How do I Use -XScopedTypeVariables?
15:27:44 <Twey> c_wraith: That's not the problem here :þ
15:27:48 <Eduard_Munteanu> What's a nice XML lib these days?
15:28:05 <geekosaur> no-n: any variable to be scoped has to be "declared" with a top-level forall
15:28:07 <Twey> no-n: Write a ∀ in the type signature to introduce the scoped variable, then use the same name inside your definition
15:28:45 <Eduard_Munteanu> Well, 'forall' unless -XUnicodeSyntax
15:28:46 <no-n> I want to do this: let (line::String) = printf "<%s> %s" botNick msg
15:29:02 <mm_freak> no-n: should be possible now
15:29:04 <Eduard_Munteanu> no-n: you don't need it for that
15:29:05 <Twey> Oh, yeah, some people don't have UnicodeSyntax on by default…
15:29:13 <dwcook> You can also do: let line :: String ; line = …
15:29:19 <geekosaur> no-n: er, no, you want <- not let, and you won't need the type that way
15:29:24 <Eduard_Munteanu> let line = ... :: String
15:29:25 <mm_freak> no-n: but if you just put the ":: String" elsewhere you don't need an extension =)
15:29:30 <geekosaur> oh wait I am confused
15:29:32 <geekosaur> never mind
15:29:38 <Twey> printf is polymorphic in its return type, no?
15:29:47 <mm_freak> bad: let (x :: T) = y
15:29:49 <geekosaur> yes, I just untangled it wrong
15:29:50 <Eduard_Munteanu> Yeah.
15:29:53 <mm_freak> good: let x = y :: T
15:29:56 <no-n> ;-;
15:30:02 <mm_freak> good: let x :: T; x = y
15:30:18 <Twey> > let line = printf "<%s> %s" "lambdabot" "Hello, world!" ∷ String in line
15:30:19 <lambdabot>  "<lambdabot> Hello, world!"
15:31:20 <pavonia> Why is "let (x :: T) = ..." bad?
15:31:34 <mm_freak> pavonia: because it wants you to enable an extension
15:31:34 <no-n> geekosaur: o
15:31:39 <no-n> thanks
15:32:05 <mm_freak> no-n: i suppose you want to send this down a connection Handle
15:32:09 <geekosaur> there is no need to use an odd extension there when there are two ways to do it without extensions
15:32:14 <mm_freak> in that case just use hPrintf instead of printf
15:32:24 <dwcook> Is it always true that words . unwords = unwords . words = id ?
15:32:28 <Twey> mm_freak: Which extension does that require?
15:32:32 <Twey> dwcook: It's not
15:32:33 <no-n> mm_freak: not yet. atm it's just a fake thing printing what would be.
15:32:35 <mm_freak> Twey: ScopedTypeVariables
15:32:42 <dwcook> Twey, what's a counterexample?
15:32:53 <Twey> dwcook: Anything with multiple blanks
15:33:02 <geekosaur> between words
15:33:05 <Twey> > unwords . words $ "foo   bar"
15:33:07 <lambdabot>  "foo bar"
15:33:11 <Twey> > unwords . words $ "foo \n bar"
15:33:12 <lambdabot>  "foo bar"
15:33:18 <dwcook> Well that's no fun. Thanks for pointing that out.
15:33:22 <mm_freak> dwcook: words . unwords :: [String] -> [String]
15:33:30 <mm_freak> dwcook: unwords . words :: String -> String
15:33:33 <dhrosa> words . unwords $ "foo   bar"
15:33:39 <dwcook> mm_freak, yeah woops, I phrased that wrong
15:33:49 <Twey> mm_freak: Isn't there a more fine-grained extension?  PatternTypeSignatures or something?
15:33:54 <dwcook> words . unwords = id and unwords . words = id
15:33:57 <mm_freak> Twey: none that i know of
15:33:58 <dwcook> But anyway that turns out to be false
15:34:14 <Twey> Huh.
15:34:31 <pavonia> -XPatternSignatures, no?
15:34:32 <FreeFull> unlines . map unwords . map words . lines  is closer to id, but still not quite there
15:34:38 <Twey> dwcook: Yeah, those are different ‘id’s
15:34:43 <dwcook> Yep, I'm aware
15:34:53 <Twey> pavonia: Deprecated, apparently
15:34:57 <mm_freak> they aren't 'id's
15:35:02 <Twey> I think that's what I was thinking of, though
15:35:08 <dwcook> I just tried to shortcut the notation too much
15:35:17 <dwcook> mm_freak, right, I was asking if they were
15:35:24 <no-n> do { msg <- printf "%s" "hello"; putStrLn msg }
15:35:28 <jmcarthur> @check \str -> (unlines . map unwords . map words . lines) str == str   -- not id
15:35:29 <lambdabot>  <hint>:1:103:
15:35:29 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
15:35:36 <jmcarthur> @check \str -> (unlines . map unwords . map words . lines) str == str
15:35:38 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
15:35:38 <lambdabot>  "a"
15:35:40 <no-n> > do { msg <- printf "%s" "hello"; putStrLn msg }
15:35:42 <lambdabot>  <IO ()>
15:35:50 <no-n> ,_,
15:35:59 <Twey> mm_freak: Well, it makes sense to form the proposition ‘words . unwords = id’ and ‘unwords . words = id’, for different ‘id’s.  You just can't prove it :þ
15:36:11 <FreeFull> no-n: That's the same as just   printf "%s\n" "hello", since printf can have IO () as its return type
15:36:32 <no-n> i know
15:36:35 <Axman6> 1huh, can printf produce IO String?
15:36:41 <mm_freak> Twey: which i would express in words as "they are not identities" =)
15:36:42 <jmcarthur> i actually didn't exact that kind of test case to fail
15:36:47 <mm_freak> Axman6: no
15:36:52 <jmcarthur> > (unlines . map unwords . map words . lines) "a"
15:36:53 <FreeFull> It is true that words . unwords . words == words
15:36:53 <lambdabot>  "a\n"
15:36:54 <no-n> but i want to do something else with the string in future
15:36:55 <jmcarthur> ah
15:37:12 <Twey> mm_freak: But mathematical notation is clearly more convenient!
15:37:26 <dwcook> In fact it looks like words isn't even an isomorphism
15:37:35 <dwcook> > [words "hello world", words "hello  world"]
15:37:36 <lambdabot>  [["hello","world"],["hello","world"]]
15:37:37 <Twey> dwcook: Bijection?
15:37:46 <no-n> will do for now though
15:37:54 <FreeFull> no-n: There is a different module for string formatting
15:38:05 <no-n> oh
15:38:08 <dwcook> I don't know which term would be more appropriate, if either
15:38:09 <FreeFull> Which you might find useful
15:38:10 <Axman6> @check \str -> (words . unwords . words) xs == words xs
15:38:11 <lambdabot>  Not in scope: `xs'
15:38:11 <lambdabot>  Perhaps you meant one of these: `x' (imported from Debug.SimpleReflect), `s'...
15:38:17 <Axman6> @check \str -> (words . unwords . words) str == words str
15:38:19 <lambdabot>  +++ OK, passed 100 tests.
15:38:33 <Twey> dwcook: I think ‘bijection’ is usual for functions
15:38:48 <mdmkolbe> I am working on a paper and need a unicode symbol for representing a flag that indicates whether a Parsec parse is a committed result (i.e. it consumed input and so <|> should try the other alternatives) or an uncommited result (i.e. it didn't consume input or was wrapped in a "try").  Any suggestions?
15:38:52 <mm_freak> Twey: what would be a convenient mathematical notation for "'f . g = id' can be disproved"?
15:38:52 <dwcook> Haskell functions aren't really functions in the usual sense though
15:38:53 * Twey waits for someone to disagree
15:38:56 <Axman6> @check \str -> ' ' `elem` str ==>  (words . unwords . words) str == words str
15:38:58 <lambdabot> Plugin `check' failed with: Ambiguous infix expression
15:39:09 <Axman6> @check \str -> (' ' `elem` str) ==>  (words . unwords . words) str == words str
15:39:11 <lambdabot>  *** Gave up! Passed only 46 tests.
15:39:12 <FreeFull> no-n: Not sure what it's called, though
15:39:20 <Twey> mm_freak: ‘f . g ≠ id’?  :þ
15:39:35 <mm_freak> dwcook: if by "the usual sense" you mean the mathematical functions, you're right
15:39:43 <mm_freak> dwcook: and if by "the usual sense" you mean the procedures, you're right
15:39:45 <mm_freak> =)
15:39:51 <dwcook> Yeah, so I win either way :D
15:40:08 <mm_freak> Twey: that's another proposition
15:40:11 <dwcook> I was referring to the former – I consider the use of "function" in most programming languages to be illegitimate
15:40:18 <mm_freak> Twey: you're missing the "has a proof" part ;)
15:40:21 <Twey> mdmkolbe: I'd probably go with ! vs. ?
15:40:37 <Twey> mm_freak: Sure.  It's the proposition that it has a proof.  :þ
15:41:13 <mdmkolbe> Twey: I like the thinking, but those overlap with the "?" and "!" lookahead operators.
15:41:16 <Twey> mm_freak: As a constructivist, my preferred notation for *assertions* that something has a proof is the proof itself!
15:41:20 <mm_freak> Twey: in that case here you go:  1 = 2
15:41:21 <mm_freak> =)
15:41:42 <no-n> :o
15:41:58 <dwcook> Twey, you mean the proposition itself? Or am I confused?
15:42:00 <Twey> mdmkolbe: Maybe a variant?  ¿ ¡  ?
15:42:10 <mm_freak> propositions are easy to state, but "has a proof" is not at all easy/convenient in general ;)
15:42:43 <Twey> dwcook: The proposition doesn't assert the existence of a proof, it merely proposes it
15:42:54 <Twey> dwcook: Giving a proof, however, asserts the existence of a proof :þ
15:43:01 <dwcook> Ah, right
15:43:23 <mm_freak> for the sake of human communication "is not an identity" is probably the easiest way to get it across =)
15:43:33 <dwcook> Like when you asserted the existence of a proof that words was not a bijection by providing a counterexample
15:44:19 <Twey> mm_freak: But you sidestep all the neat syntactic and epistemological discussion!
15:45:12 <mm_freak> Twey: it's a feature, not a bug =P
15:45:40 <Twey> mdmkolbe: Or perhaps ○ (uncommitted) vs. ● (committed)
15:45:40 <Fuuzetsu> @pl f d = foo <$> bar d
15:45:41 <lambdabot> f = (foo <$>) . bar
15:45:43 <Fuuzetsu> pfft
15:45:56 <Twey> Fuuzetsu: fmap foo . bar, please
15:46:21 <Fuuzetsu> but then I have parenthesis because foo is actually two words in my case
15:46:54 <Twey> Fuuzetsu: Still nicer
15:47:30 * Fuuzetsu sticks with f d … bar d
15:47:33 <mdmkolbe> Twey: That is another possibility.  (I've also though about up/down arrows.  (Top and bottom are already used for other things.))
15:47:39 <Twey> The worst thing about operator sections is when you want to use an operator of the same or lower precedence inside them and end up having to write ((foo <$> bar) <$>)
15:48:47 <Fuuzetsu> Yes; I have proposed an alternate way of processing this and someone even filed a GHC ticket but I forgot all about it until now
15:49:30 <dwcook> Fuuzetsu, link?
15:49:37 <Fuuzetsu> looking for it
15:49:40 <Fuuzetsu> it wasn't anything special
15:50:06 <Fuuzetsu> https://ghc.haskell.org/trac/ghc/ticket/8304
15:51:39 <Twey> Hmm, diadic operator sections, nice
15:52:25 <joneshf-laptop> i've oftenwanted that
15:52:31 <joneshf-laptop> but never understood why it didn't exist
15:53:09 <Fuuzetsu> I'm sure no-one would mind if you posted the necessary patch for the extension on GHC Trac ;)
15:57:25 <Fuuzetsu> is there IO Bool → IO Bool → IO Bool somewhere?
15:57:43 <prophile> Fuuzetsu: liftM2 (&&) or equivalent?
15:57:57 <Fuuzetsu> yeah, I'm wondering if it already exists somewhere
15:58:04 <prophile> yes, it's liftM2 (&&)
15:58:11 <Fuuzetsu> ...
15:58:15 <prophile> alternatively (>>) which fits that type signature too :)
15:58:38 <Axman6> prophile: do you want a short circuiting version?
15:58:38 <Fuuzetsu> Perhaps a nicer, infix form for liftM2 (&&) was already defined for me.
15:59:02 <prophile> Axman6: nah, that's how you start fires
15:59:11 <bennofs> Fuuzetsu: I wish for that too
16:00:43 <benbangert> how does the lazy behavior of haskell interact with the IO monad? I mean, if I have a recursive function that produces IO [a], and it fetchs 30 of [a] at a time over the network, if I lifted (take 70) into it, would it run the function just enough for the (take 70) to work?
16:01:32 <Axman6> depends on the IO [a] function. it sounds like it would fetch 90 elements
16:02:19 <Axman6> if it doesn't return a result until it's retrieved 30 results, you can run the take 70 on all of it until there's at least 70 elements
16:02:35 * Axman6 -> work
16:02:51 <enthropy> side effects don't usually happen because of evaluation
16:04:58 <enthropy> http://www.haskell.org/haskellwiki/Iteratee_I/O
16:30:26 <NemesisD> hey guys, i'm editing a haskell file and if i do anything to interact with haskell mode such as hitting tab or running flycheck, it pops a *Help* buffer on the right side for haskell-mode. what gives?
16:31:27 <NemesisD> specifically it pops up docs on haskell-mode-hook
16:31:47 <Twey> NemesisD: Nobody could decide which indentation mode to use by default, so they made it tell you how to choose one, instead
16:32:51 <NemesisD> Twey: i thought i was using one though. my .emacs has (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
16:40:40 <no-n> is lookup considered slow or fast?
16:41:08 <Rembane> no-n: Data.List.lookup?
16:41:35 <no-n> I don't know. it's just available when I enter ghci.
16:41:47 <Rembane> no-n: Type this: :i lookup
16:41:53 <jfischoff> I think it is linear
16:42:01 <no-n> GHC.List
16:42:10 <cmiller_> If it operates on lists it's O(n)
16:42:23 <Rembane> It is linear, so for small lists it's quite fast. For big lists, it's slow.
16:42:33 <cmiller_> So slow in the grand scheme of things.
16:42:38 <no-n> okay
16:42:47 <no-n> how big is big?
16:42:59 <jfischoff> There is also Data.Map.lookup and Data.HashMap.Strict.lookup, etc.
16:43:22 <monochrom> 2^20 is big
16:43:37 <Fuuzetsu> What's a nice way to go from ‘Map k (IO a)’ to ‘IO (Map k a)’?
16:43:39 <cmiller_> Depends mostly on how expensive your (==) is?
16:44:00 <Cale> :t traverse
16:44:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:44:01 <no-n> it might be something I do a lot, but on a small list
16:44:21 <no-n> but there's probably no reason it shouldn't be a Map
16:44:28 <cmiller_> If it's really small say <= 10. I wouldn't bat an eye at it.
16:44:30 <jfischoff> :t sequence
16:44:30 <lambdabot> Monad m => [m a] -> m [a]
16:44:33 <jfischoff> eh
16:44:33 <Cale> :t Data.Traversable.sequence
16:44:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:44:43 <jfischoff> yeah
16:44:53 <cmiller_> Cause the overhead of moving to a tree like struct will probably not be worth it.
16:44:55 <Fuuzetsu> sequenceA might work
16:44:58 <Fuuzetsu> ah, there's a Monadic one too
16:45:02 <Fuuzetsu> thanks, was just looking at that
16:45:03 <cmiller_> Beyond that I'd profile.
16:45:13 <monochrom> I agree, list of size 10 is small
16:45:39 <no-n> are Map lookups faster?
16:45:50 <cmiller_> O(log n)
16:45:57 <monochrom> yes. search a Map of size 2^20 takes only 20 steps
16:45:58 <cmiller_> So for large n, yes very.
16:46:15 <cmiller_> But premature optimization is the road to hell.
16:46:21 <no-n> yeah
16:46:27 <no-n> it's a small list but it will be happening a lot
16:46:42 <cmiller_> The happening a lot doesn't matter so much if it's small.
16:46:50 <no-n> ok
16:47:05 <cmiller_> What's the underlying data type?
16:48:14 <no-n> the list is of type [(String, String -> [String] -> Foo -> IO Foo)]
16:48:32 <no-n> where Foo is something defined with data
16:48:38 <cmiller_> and you're looking up the first string in the tuple?
16:48:48 <no-n> yes
16:48:53 <cmiller_> Are the strings long?
16:48:57 <no-n> no
16:50:18 <cmiller_> So your comparison operation shouldn't add to much. There's no right answer here. At a certain point you'll go "Damn that's slow," when that happens switch to Data.Map.
16:50:38 <no-n> heh, yeah. :)
16:50:54 <no-n> @src lookup
16:50:55 <lambdabot> lookup _key []          =  Nothing
16:50:55 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
16:50:55 <lambdabot>                         | otherwise = lookup key xys
16:56:12 <Fuuzetsu> I switched to Data.Map for something small the other day and I achieved about 0% extra performance ;_;
16:56:45 <dwcook> Fuuzetsu, over list you mean?
16:56:50 <Fuuzetsu> Yeah.
16:57:15 <dwcook> Could be you have a pathological case on your hands, or not enough elements for it to matter
16:57:15 <Fuuzetsu> Maybe GHC figured out a fast way for me or maybe my input samples were just small enough for it to not matter.
16:57:35 <dwcook> (Though of course those aren't the only possibilities)
16:58:27 <Twey> Fuuzetsu: It's sequenceA if you can define a Traversable instance for Map
16:58:34 <Twey> Or Map k rather
16:59:17 <Fuuzetsu> there's one defined already; I ended up using sequence from Traversable
16:59:32 <Fuuzetsu> It works fine. Well, the types line up.
16:59:56 <Twey> Yep, that's fine
17:00:04 <mm_freak> Fuuzetsu: one of your main bottlenecks is String keys
17:00:31 <mm_freak> switch from String to something else (like strict Text) and from lists to Map
17:00:32 <Twey> Fuuzetsu: Try a trie maybe?
17:00:45 <mm_freak> if your keys are sufficiently long you can probably benefit from HashMap
17:01:02 <Twey> Or a trie, if your map is dense
17:01:31 <Twey> Or both, I suppose
17:01:36 <mm_freak> in many cases HashMap provides additional speedup, simply because balancing will be cheaper on average
17:02:03 <mm_freak> in any case, get rid of String
17:02:06 <Twey> mm_freak: Over a trie?
17:02:15 <mm_freak> Twey: HashMap
17:02:19 <mm_freak> ah
17:02:22 <mm_freak> i'm not sure
17:02:55 <mm_freak> tries may work, if prefixes are good enough
17:02:56 <Twey> I would assume the trie would give you better performance, especially if you have a lot of data
17:03:02 <Twey> Right
17:03:18 <mm_freak> but for string keys HashMap is a good first choice
17:03:21 <Twey> Isn't the HashMap a trie?
17:03:38 <mm_freak> probably, but if it is, it's a trie on hash values, not the original strings
17:03:52 <Twey> « an Data.IntMap.IntMap indexed by hash values of keys »
17:03:57 <Twey> Yeah, that's what I meant
17:04:07 <mm_freak> and yes, indeed HashMap uses tries
17:04:35 <mm_freak> and hash tries are generally a better choice than string tries
17:04:56 <Fuuzetsu> mm_freak: You have two people mixed up, I didn't mention what I was using for keys ;) There are two people with Map here now.
17:05:08 <mm_freak> oh
17:05:12 <mm_freak> sorry then
17:05:34 <mm_freak> no-n: see above =)
17:06:05 <mm_freak> but anyway, this is probably useful knowledge for everyone =)
17:06:34 <Twey> Indeed
17:06:53 <mm_freak> String keys: bad
17:06:56 <Twey> I just like the word ‘trie’
17:07:00 <mm_freak> Text keys: better, but still bad
17:07:04 <mm_freak> Text hash tries: good
17:07:30 <mm_freak> the word "trie" is weird, if your first language is german =)
17:07:53 <Twey> Why?  At least it's pronounced how it's spelt in German
17:08:10 <mm_freak> it's like someone who is a bad english speller tried to write "tree" =)
17:08:30 <Twey> In English it looks like it should be pronounced ‘try’.  And then when you get it right it's pronounced the same as ‘tree’.
17:08:35 <Twey> I'm not sure which is worse.
17:09:08 <cmiller_> I always pronounced it tree but with a faux french accent.
17:09:10 <Twey> Especially given the high collision rate in context.
17:09:15 <Twey> cmiller_: Nice.
17:09:26 <mm_freak> i don't even know how to pronounce it…  i tend to just pronounce both the same way, but use the english 'r' for tree and the german 'r' for trie to tell them apart
17:09:46 <Twey> So the same as cmiller_, then
17:09:55 <Twey> I may have to adopt this convention; it's useful
17:10:03 <mm_freak> yeah, except that mine doesn't sound like a love song =)
17:10:11 <Twey> Heh.
17:11:15 <Fuuzetsu> any recommendations of a plotting library?
17:11:28 <mm_freak> Fuuzetsu: Chart?
17:11:29 <Twey> Fuuzetsu: I like Charts
17:11:29 <monochrom> missing the Forrest for the trie
17:11:32 <Twey> Er, Chart
17:11:37 <Fuuzetsu> k
17:11:56 <roconnor_> Chart
17:11:56 <Fuuzetsu> How about for 3D stuff?
17:12:03 <Twey> Not sure if it compiles with current GHC, though — you might have to patch it
17:12:07 <Fuuzetsu> bleh
17:12:08 <mm_freak> Fuuzetsu: OpenGL =)
17:12:25 <Twey> For 3D you're stuck with gnuplot or drawing it yourself AFAIK, yeah
17:12:43 <mm_freak> there was this 3D variant of gloss, but i can't remember its name
17:12:47 <Twey> not-gloss
17:12:52 <cmiller_> Someone needs to do matplotlib in haskell.
17:13:19 <mm_freak> but the gloss interface isn't terribly useful for plotting
17:13:46 <no-n> mm_freak it's for an IRC bot btw. for taking a line of IRC and seeing if the first word is a command, the functions in snd part of the tuples are what they do.
17:13:47 <Twey> It's not bad
17:14:13 <Twey> It takes some interesting abuses of ‘align’
17:14:42 <Fuuzetsu> Chart installed fine on 7.6.3 FYI
17:14:47 <mm_freak> no-n: i'm sorry to report that my IRC library still isn't finished =)
17:14:55 <no-n> hehe :)
17:15:18 <no-n> mm_freak, would your above advice still apply?
17:15:32 <mm_freak> no-n: it applies in general
17:15:36 <Twey> Fuuzetsu: Okay
17:15:38 <no-n> okay
17:15:43 <mm_freak> and even when it is finished, it isn't exactly beginner-friendly with its pipes/FreeT interface =)
17:15:57 <no-n> *nod*
17:16:44 <mm_freak> it does however parse gigabytes of traffic within seconds =P
17:16:48 <Twey> mm_freak: Pipes IRC?
17:16:50 <Twey> Oo.
17:16:55 <mm_freak> Twey: fastirc
17:17:04 <mm_freak> there is a version on hackage, but it's horribly outdated
17:17:20 <mm_freak> i think the hulk IRC server even uses it
17:17:27 <roconnor_> how can an IRC package become outdated?
17:17:28 <Twey> Oh, are you Söylemez?
17:17:34 <mm_freak> Twey: yeah
17:17:42 <Twey> Oh, okay
17:17:50 * hackagebot http2 0.2.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.2.0 (KazuYamamoto)
17:17:52 <Twey> There's another connection I never made
17:17:57 <Fuuzetsu> mm_freak: Oh, I wanted to use fastirc just a couple of weeks ago but IIRC it wouldn't compile or something.
17:18:14 <mm_freak> Fuuzetsu: that's not surprising
17:18:24 <mm_freak> i think it's based on an old attoparsec
17:18:28 <Twey> Haskell, where even IRC bindings are outdated a couple of years after they're written
17:18:39 <Fuuzetsu> I had to put that project on hold so here's your chance to give it a new life.
17:18:52 <mm_freak> Twey: well, haskell programmers don't make the mistake to reinvent everything all the time =)
17:19:00 <mm_freak> which comes at the cost of actually having to maintain your code =)
17:19:03 <Twey> True that :þ
17:19:22 <mm_freak> Fuuzetsu: right now i have two projects with much higher priority
17:19:38 <aleksejs_> Hi, I have 2 functions http://vpaste.net/rDuRc (both work) and I can't figure out how to move a part that repeats, to another function. Could you help me?
17:20:01 <mm_freak> one may become the next netwire, and the other one will eventually become an OpenGL game based on it =)
17:20:19 <Fuuzetsu> aleksejs_: someOtherFunction = fmap (toResponse . encodeJSON)
17:20:38 <djahandarie> mm_freak, my biggest issue with the fastirc package was actually that some IRC servers decide to not implement the spec exactly, and there's not easy way to tweak fastirc aside from just actually grabbing it all and changing it.
17:21:01 <mm_freak> djahandarie: that shouldn't apply to the parser though
17:21:10 <monochrom> Fuuzetsu: you may have to give it a type signature
17:21:19 <Fuuzetsu> aleksejs_: you could even do someOtherFunction f g = fmap (toResponse . encodeJSON) . g . f I guess
17:21:24 <Fuuzetsu> monochrom: probably
17:21:29 <mm_freak> djahandarie: the basic shape of the protocol should be common
17:21:35 <zRecursive> :t (.)
17:21:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:21:50 <mm_freak> [:PREFIX] CMD [ARG [ARG … [:A R G]]]
17:22:24 <aleksejs_> Fuuzetsu, thanks! My brain just doesn't work anymore :(
17:23:02 <jxv> Fuuzetsu, fastirc uses the old catchError
17:23:10 <jxv> it should be catchIOError
17:23:55 <benbangert> mm_freak: I ended up using SimpleIRC, it works ok
17:24:54 <mm_freak> simpleirc has an advantage over fastirc:  it's very easy to wrap it up in a reactive-banana layer
17:25:26 <benbangert> I tried fastirc first, and couldn't divine how to arrange it in such a way that anything useful happened
17:25:50 <mm_freak> and this is also the route i'll eventually go with fastirc:  a very fast pipes-based parser for the low level and a reactive-banana-based high level interface
17:26:22 <benbangert> more than a few haskell libs I've stumbled across eschow docs in favor of you reading the entirety of the doc strings, than somehow divining the best arrangement of the functions and types in such an order as what you want actually happens
17:27:02 <benbangert> mm_freak: if its a new lib, doc it! ;)
17:27:14 <mm_freak> benbangert: it's fastirc =)
17:27:39 <benbangert> mm_freak: doc it!
17:28:42 <silasm> while on the subject of documentation, has anyone worked with hscurses? I've started falling back to the ncurses documentation where the hscurses doc was lacking, but I'm wondering if I'm missing something in terms of tutorials or whatever. I do have some example code, but that only does so much.
17:28:53 <mm_freak> benbangert: do you have a particular complaint about the docs of the old version?
17:29:17 <mm_freak> silasm: i guess must haskell programmers use vty
17:29:27 <mm_freak> most
17:30:03 <benbangert> mm_freak: yes, I have no idea how to actually use it
17:30:09 <silasm> mm_freak: hmm, I'll think about making the switch I guess. I was still in the exploration phase.
17:30:42 <benbangert> mm_freak: there are a variety of types and functions spread across a half dozen packages, with no clear overview/example/tutorial on how to put it all together to actually do anything
17:30:59 <mm_freak> benbangert: ok, thanks for the feedback
17:30:59 <jmob> Anyone know why haskellforall.com is down?
17:31:22 <monochrom> perhaps I should grab haskellexists.com :)
17:31:22 <benbangert> pipes has a nice Tutorial package that tells you a little about what is in the other bits, and how to pull it together to get something going
17:31:47 <mm_freak> silasm: vty gives you a somewhat declarative interface, but it is slower…  you might notice the difference if you do a lot of full-width scrolling
17:32:30 <mm_freak> benbangert: nowadays i put separate tutorial-style documentation on the darcshub page
17:33:02 <benbangert> mm_freak: are there any links there from anything on hackage?
17:33:06 <Crowds> Hello fellow Haskellers, I recently started learning this language and I have a question: how do you convert DiffTime to a int?
17:33:25 <silasm> mm_freak: hmm, thanks for the info. I want to make an sc clone in Haskell to force myself to write an actual application.
17:33:27 <mm_freak> Crowds: round/ceil/floor/…
17:33:33 <Crowds> I want to use the system clock to generate random numbers
17:33:54 <mm_freak> Crowds: also most random number generators do the initialization for you
17:34:03 <mm_freak> in fact all of them i know
17:34:13 <benbangert> Crowds: uh, don't. use System.Random or Crypto.Random to generate random numbers
17:34:16 <silasm> I'd imagine it might also be slightly easier to read/output to xlsx files than it would be to add that functionality to sc too, so here's to hoping.
17:34:33 <mm_freak> benbangert: netwire is a good example of that…  there are links between darcshub and the wiki
17:34:55 <mm_freak> however, no links from hackage…  this time the haddocks are a bit lacking compared to older versions
17:35:02 <benbangert> mm_freak: yea, I'm not picky on where the docs are, as long as I can find them. :)
17:36:12 <monochrom> DiffTime is fractional
17:36:37 <Crowds> alright, thanks!
17:37:14 <mm_freak> it's RealFrac in particular
17:38:40 <benbangert> mm_freak: fastirc is yours?
17:39:32 <mm_freak> benbangert: yeah
17:40:12 <benbangert> mm_freak: it looked like, I just couldn't figure out how to arrange all the bits to get something working. I found an example bot written with simpleirc which was enough for me to figure that out (the docs alone weren't quite sufficient)
17:40:18 <benbangert> er, 'it looked nice'
17:41:56 <mm_freak> benbangert: well, they are pretty similar
17:42:15 <mm_freak> start a bot, assign event handlers
17:43:06 <mm_freak> and yeah, that idea sucks in general =)
17:43:21 <benbangert> lol
17:49:27 <hakujin> when I build hoogle in a cabal sandbox and move it to ~/.cabal/bin it creates the database in the sandboxed location instead of the relative location. how can I correct this?
18:02:51 <johnw> hakujin: I don't think you can
18:04:54 <hakujin> johnw: is the path compiled into the executable?
18:05:19 <Twey> sed?
18:05:22 <johnw> I believe so
18:05:43 <hakujin> well shit
18:05:53 <Twey> NixOS has some kind of tool for changing paths in executables.  It's pretty successful.
18:06:42 <roconnor_> patchelf
18:07:37 <Twey> That's the one
18:08:00 <geekosaur> afaik that changes rpath, not random strings that might contain paths
18:08:24 <Twey> Hm, or maybe not
18:08:26 <geekosaur> at a guess it has a path from a Paths_foo module, and that may have been inlined multiple places
18:08:46 <Twey> I thought there was something that actually went through the whole executable
18:09:42 <johnw> Twey: That would be quite tricky to do
18:10:23 <johnw> most string constant are kept in the data segment image within the executable.  You'd have to enlarge that segment, write the new string to the end (if it's larger), and rewrite the symbol table to point at the new location.  Not impossible, but tricky
18:11:37 <geekosaur> erm, if it's an actual String constant, it's worse than that
18:11:47 <geekosaur> since it's actually a linked list of Char
18:11:55 <johnw> ah, true!
18:12:18 * geekosaur ws originally thinking of gcc and clang putting string constants into the *text* segment, and then realized these are probably not ByteStrings
18:13:00 <geekosaur> (and even if they were, I think compile time bytestrings are not yet a solved problem)
18:27:01 <yellowfish> I DEMAND YOU HANDING OVER FAGGOTS NOW
18:28:12 <yellowfish> WHERE THEM NIGGAS AT
18:28:37 <simpson> @where ops
18:28:37 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:28:42 --- mode: ChanServ set +o geekosaur
18:28:48 --- mode: geekosaur set +b yellowfish!*@*
18:28:50 --- kick: yellowfish was kicked by geekosaur (yellowfish)
18:28:53 <simpson> > where them ops at
18:28:54 --- mode: geekosaur set -o geekosaur
18:28:56 <lambdabot>  <hint>:1:1: parse error on input `where'
18:28:59 --- mode: ChanServ set +o copumpkin
18:29:02 --- mode: copumpkin set -o copumpkin
18:29:11 * geekosaur is having notwork problems :/
18:29:20 <simpson> geekosaur, copumpkin: You guys rock, thanks.
18:33:36 <S11001001> hum.  the where ops thing should be added to chanserv.
18:35:52 --- mode: ChanServ set +o johnw
18:35:54 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops' by johnw
18:35:58 --- mode: johnw set -o johnw
19:00:36 <Dustin> I am trying to write a function creating a list of the inverses of the triangular numbers. (1, 1/3, 1/6, 1/10, ...)
19:00:38 <Dustin> printinvtris :: (Integral a) => a -> [a]
19:00:46 <Dustin> printinvtris 0 = [0]
19:00:54 <Dustin> printinvtris n = [1..(2/(n*n + n))]
19:01:29 <Dustin> That is what I have, I don't know why it's not working.
19:01:48 <enthropy> @type (/)
19:01:49 <lambdabot> Fractional a => a -> a -> a
19:02:19 <Cale> Dustin: well, a few reasons...
19:03:27 <khyperia> I would think it'd be something like printinvtris n = map (\x -> 1 / (x * x + x)) [1..n]
19:04:18 <khyperia> because the syntax [a..b] does a sequential, increment-by-1 range between a and b
19:04:21 <Cale> Dustin: If you give bounds for range notation which are in the wrong order, you might get a list with 1 or 0 elements
19:04:59 <Cale> > [1 .. 1/2] -- this is weird, but it's implied by the silly rules about how floating point numbers interact with this notation
19:05:00 <lambdabot>  [1.0]
19:05:13 <Cale> > [1 .. 1/6] -- more likely
19:05:14 <lambdabot>  []
19:05:44 <Cale> Dustin: But then your other problem is that the type signature that you gave is wrong.
19:05:57 <Cale> (/) can't be used with Integral numbers
19:06:17 <Cale> (generally speaking anyway, the instances of Integral and Fractional are pretty much disjoint)
19:06:27 <Dustin> Oh, what khyperia did was almost perfect
19:06:45 <khyperia> Argh, I shouldn't have just given the answer :P
19:07:09 <Cale> Note you can also use a list comprehension to nice effect
19:07:22 <Dustin> Except khyperia you needed n = map (\x -> 2 / (x * x + x)) [1..n]
19:07:23 <Cale> > [1/(n*n + n) | n <- [1..]]
19:07:24 <lambdabot>  [0.5,0.16666666666666666,8.333333333333333e-2,5.0e-2,3.333333333333333e-2,2....
19:07:31 <Cale> > [2/(n*n + n) | n <- [1..]]
19:07:33 <lambdabot>  [1.0,0.3333333333333333,0.16666666666666666,0.1,6.666666666666667e-2,4.76190...
19:08:01 <khyperia> also, Dustin, to make it more idiomatic you could make it generate an infinite list and then call take n on it
19:09:33 <hiptobecubic> if you know you always need n elements, i wouldn't say it's less idiomatic to just create n elements.
19:11:07 <startling> There's no real reason to limit it, though.
19:28:02 * hackagebot egison 3.2.20 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.20 (SatoshiEgi)
20:03:05 * hackagebot pipes-text 0.0.0.8 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.8 (MichaelThompson)
20:05:06 <pdxleif> What vim stuff do people use for "tell me the type of the thing I'm pointing at"?
20:05:35 <startling> Can I make a type argument partially polykinded?
20:05:51 <startling> e.g. I want to say "this thing has kind [x] for some kind x"
20:06:05 <hakujin> pdxleif: https://github.com/eagletmt/ghcmod-vim lets you use :GhcModType or :GhcModInfo
20:06:16 <hakujin> bind to <leader> as you see fit
20:06:27 <pdxleif> Ah, cool - I had that set up before, but then switched to syntastic
20:07:08 <hakujin> don't use the CheckAndLintAsync feature and they get along
20:07:52 <pdxleif> Was also looking at https://github.com/eagletmt/neco-ghc
20:08:09 <enthropy> startling:  data T (a :: [k]) (b :: k) -- doesn't do what you want?
20:09:00 <adelbertc> pdxleif - haskellmode-vim does this with _t
20:09:04 <adelbertc> thats what im using
20:09:18 <hakujin> pdxleif: I use neco-ghc to provide omnicompletion to YouCompleteMe
20:10:03 <adelbertc> i've ben using haskellmode-vim + neco-ghc + vim-hoogle thus far, been treating me wel
20:10:32 <hakujin> adelbertc: you switch from ghcmod-vim? or did you start with haskellmode-vim?
20:10:35 <startling> enthropy: oh, heh, it does
20:10:48 <startling> enthropy: thanks!
20:10:57 <adelbertc> hakujin - just started with haskellmode-vim
20:11:37 <pdxleif> Sounds like ghci 7.8 will have completion assistance built-in.  Also wanna take advantage of that for Idris's vim mode.
20:12:06 <adelbertc> type holessssss
20:12:57 <ivanm> anyone else here use flycheck in emacs with Haskell programming?
20:13:19 <hakujin> pdxleif: first I've heard of completion assistance; where did you see so I can read more?
20:14:06 <pdxleif> hakujin: The twitterwebs - https://twitter.com/dysinger/status/435477722861563904 I don't know more
20:14:56 <pdxleif> Idris has an ideslave mode that offers completion assistance
20:35:24 <sam___> hello folks , could someone tell me why the following is correct and incorrect http://lpaste.net/100086
20:36:48 <khyperia> sam___, the second one cons takes precedence over application, where the first one application over cons
20:37:10 <khyperia> $ is an ordinary operator just like anything else (I think infixr 0?)
20:37:54 <sam___> khyperia: isn't $ just another way of saying ()..right associative brackets?
20:38:08 <thebnq> @src ($)
20:38:08 <lambdabot> f $ x = f x
20:38:12 <khyperia> no, it's an ordinary operator defined as... like that
20:38:41 <sam___> khyperia: kindly enlighten me
20:39:21 <geekosaur> it acts like brackets because of its very low precedence, but otherwise it's just function application
20:39:50 <ezyang> f $ x y = f (x y)
20:39:56 <khyperia> it's the same as, say, "+". Let's change up the operators a bit... in your example, you have "x : siever $ filter...", which goes to "(x : siever) (filter...)"
20:40:19 <khyperia> and then I said "change up the operators a bit" and went on a tangent and didn't say what I intended to say :P
20:40:20 <sam___> kyperia: oh
20:40:32 <khyperia> anyway, : takes higher precedence than $
20:40:38 <nolrai66> > Nothing < Just 0
20:40:41 <lambdabot>  True
20:40:43 <khyperia> :info (:)
20:41:17 <khyperia> (:) is "infixr 5", ($) is "infixr 0"
20:42:20 <sam___> khyperia: Understood, is there a wayto encorprate  ($) into that example of mne correctly?
20:43:00 <johnw> x:(siever $ ...)
20:43:06 <khyperia> Perhaps x : (siever $ filter (\y -> rem y x /= 0 ) xs), but that's no better than the first version, actually has more characters
20:43:34 <sam___> khyperia:exactly , too many characters
20:43:45 <sam___> johnw: need another one mate
20:43:59 * ski doesn't see anything wrong with `siever (p:ns) = p : siever (filter (\d -> d `rem` p /= 0) ns)'
20:44:41 <johnw> need another one what?
20:45:14 <ski> sam___ : btw, if this is supposed to be primes, then you're missing one
20:45:34 <sam___> ski: one is a prime number?
20:45:43 <ski> you're missing one prime
20:45:48 <ski> `1' isn't a prime number, though
20:45:49 <Heather> :t ($)
20:45:51 <lambdabot> (a -> b) -> a -> b
20:45:51 <khyperia> ski, it's the second one that's "wrong", as in fails to compile.
20:46:03 <khyperia> at least I assume it fails to compile
20:46:20 <ski> khyperia : yes, i know
20:46:24 <khyperia> ah
20:46:45 <ski> i was merely expressing that imho, there is no need for any replacement
20:47:17 <sam___> ski : is there no way I can express that without brackets?
20:47:17 <thebnq> oh passed the 100000th lpaste recently!
20:47:32 <khyperia> Oh, "anything wrong with" as in syntax-wise... thought you meant behavior-wise, I'm dumb
20:52:32 <ski> sam___ : whay do you want to express it without brackets ?
20:52:46 <ski> s/whay/why/
20:53:09 * hackagebot digit 0.1.1 - A data-type representing digits 0-9 and other combinations  http://hackage.haskell.org/package/digit-0.1.1 (TonyMorris)
20:53:18 <Heather> :t (>>=)
20:53:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:53:47 <ski> @type flip concatMap
20:53:47 <lambdabot> [a] -> (a -> [b]) -> [b]
20:54:25 <sam___> ski : Me belongs to a class of dunderheads who have difficulty getting used to other's ideas and needto find some sort of validation by encorporating their ideas
20:55:20 <ski> i'm not sure what "encorporating their ideas" refers to here
20:55:41 <ski> (i assume "getting used to other's ideas" perhaps refers to using brackets ?)
20:57:02 <sam___> ski : nevermind .Thanks for the help. I am hungry. I'm off.
20:57:07 <ski> ok
20:59:47 <Heather> @src (>>=)
20:59:48 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:17:56 <nolrai66> is there a better way to write "writeArray <*> view boardProper <*> return size <*> return Nothing" the "<*> return"'s bother me.
21:17:59 <khyperia> Heather, >>= is part of Monad, there's no one defining source
21:20:36 <DarkLinkXXXX> Why does the newest cable-install depend on an older version of array? Like, a major release lower?
21:22:26 <ivanm> DarkLinkXXXX: because the newest version of array isn't officially out yet?
21:22:37 <ivanm> (as in, there's no official GHC release that uses it, just the beta)
21:23:12 <begriffs_> Hey speaking of cabal, does anyone know a reason *not* to use --reorder-goals when doing cabal install?
21:23:27 <ivanm> nolrai66: \ bp -> writeArray bp size Nothing <*> view boardProper ?
21:23:39 <DarkLinkXXXX> That might be it. Does that mean I need to get the cabal-install that isn't officially out?
21:23:43 <ivanm> begriffs_: never heard of it
21:24:05 <ivanm> DarkLinkXXXX: with the 7.8 beta? yeah, might need to get it from git
21:24:21 <ivanm> or else just unpack it, edit the cabal file and see if that works
21:24:25 <DarkLinkXXXX> And much of it's dependencies too maybe?
21:24:27 <ivanm> it might just be that they need to bump the bounds
21:24:29 <nolrai66> ivanm: Yeah, thats better.
21:48:13 * hackagebot stripe 0.7.0 - A Haskell implementation of the Stripe API.  http://hackage.haskell.org/package/stripe-0.7.0 (MichaelSchade)
21:50:06 <joneshf-laptop> Do any haskell programs actually follow xdg base directory?
21:50:47 <joneshf-laptop> it seems everyone just dumps all their stuff into ~/
21:54:47 <DarkLinkXXXX> Any advice on dealing with dependency hell?
21:55:49 <ChongLi> cabal sandbox
21:55:50 <ChongLi> !
22:01:09 <chirpsalot> DarkLinkXXXX: hah. I was just going to complain about how every time I try to install something, even on a fresh cabal it always breaks :P.
22:01:15 <chirpsalot> I don't know what I do wrong :(.
22:03:14 * hackagebot hamlet 1.1.8 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.8 (MichaelSnoyman)
22:03:17 * hackagebot shakespeare 1.2.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.1 (MichaelSnoyman)
22:03:18 * hackagebot shakespeare-css 1.0.7 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.7 (MichaelSnoyman)
22:03:20 * hackagebot shakespeare-js 1.2.0.4 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.2.0.4 (MichaelSnoyman)
22:03:22 * hackagebot fsharp 0.0.4 - some F# operators, high priority pipes  http://hackage.haskell.org/package/fsharp-0.0.4 (Heather)
22:16:00 <startling> I wonder if I can write a Category instance for filenames.
22:16:32 <startling> a.txt -- "a.txt"
22:18:06 <erisco> how do I get rid of the meta data in the XmlTree (HXT)?
22:18:13 <erisco> I just want the main document
22:21:06 <haskell-learner> Hey guys can you please tell me why I am getting this error     No instance for (Data.Convertible.Base.Convertible a0 SqlValue)       arising from a use of `toSql'
22:23:01 <ivanm> haskell-learner: some code to go with that error might help
22:23:13 <ivanm> otherwise, we can't really give you any more information than what's already there...
22:23:20 <haskell-learner> ivanm: the code was toSql 1
22:23:27 <ivanm> probably need a type sig
22:23:31 <haskell-learner> this threw that error
22:23:34 <ivanm> try "toSql (1 :: Int)"
22:23:39 <ivanm> @type 1
22:23:43 <lambdabot> Num a => a
22:24:13 <haskell-learner> ivanm: yup that works, can you tell me why it was not working in the first case?
22:24:22 <ivanm> haskell-learner: where you doing it in ghci?
22:24:24 <ivanm> *were
22:24:30 <haskell-learner> ivanm: yup
22:24:43 <ivanm> in ghci, integral literals like 1 default to type Integer
22:25:00 <ivanm> and it appears Integer can't be converted to an SqlValue
22:25:16 <haskell-learner> what is the difference between Int and Integer
22:25:26 <ivanm> either that, or else "toSql 1" was keeping the type of 1 generic and didn't know which Integral instance to use
22:25:27 <anta-pyon-ist> haskell-learner: Integer is a bigint.
22:25:39 <haskell-learner> also I was following the tutorial here http://book.realworldhaskell.org/read/using-databases.html
22:25:44 <ivanm> haskell-learner: Int are machine-level integers, Integer is infinite (modulo memory limits)
22:25:55 <anta-pyon-ist> haskell-learner: Int is a fixed-size integer, if I understand correctly, typically a machine integer.
22:26:24 <ivanm> haskell-learner: unfortunately RWH might be out-of-date with the current state of the libraries
22:26:42 <joelteon> anybody know of a library that lets you show time intervals in a human-readable way?
22:26:52 <haskell-learner> ok ok.. is learnyouahaskell.com any good?
22:27:07 <ivanm> haskell-learner: another alternative (as I'm not familiar with the Convertible class): it might be it didn't know which Sql type to convert it to
22:27:13 <haskell-learner> also toSql (1 :: Integer) seems to work too..
22:27:26 <haskell-learner> toSql 1 in ghci doesn't work though
22:27:30 <ivanm> yeah, then it must be because it didn't know what to convert it to
22:27:40 <anta-pyon-ist> haskell-learner: Have you imported all required modules?
22:27:42 <ivanm> LYAH is pretty good, but not sure if it covers databases
22:27:47 <anta-pyon-ist> ivanm: It does not.
22:28:30 <haskell-learner> anta-pyon-ist: yup
22:28:47 <haskell-learner> Database.HDBC, Database.HDBC.sqllite3
22:29:06 <dpwright> this is not really strictly a haskell-related question, but I am writing it in haskell and I figure some of you may be able to point me in the right direction: I am trying to write a basic type inference engine, based on this tutorial: https://raw.github.com/wh5a/Algorithm-W-Step-By-Step/master/AlgorithmW.lhs
22:29:44 <anta-pyon-ist> haskell-learner: What concrete error do you get when you use toSql in ghci?
22:30:13 <haskell-learner> this is the error that it throws
22:30:14 <haskell-learner> <interactive>:16:1:     No instance for (Data.Convertible.Base.Convertible a0 SqlValue)       arising from a use of `toSql'     Possible fix:       add an instance declaration for       (Data.Convertible.Base.Convertible a0 SqlValue)     In the expression: toSql 1     In an equation for `it': it = toSql 1
22:30:21 <dpwright> as well as the wikipedia page.  But, I think I'm not understanding things quite right
22:32:52 <dpwright> if I try and infer a type for "4.5 + 1", where "+" is a variable in my environment corresponding to "forall a. a -> a -> a" (imagining for the moment that the only two types in the world are int and float, which can be added together to form themselves but can't be added to each other), I get float
22:33:02 <dpwright> if I try to infer "1 + 4.5" I get int
22:34:07 <dpwright> looking at the "mgu" function in that tutorial, that makes sense -- if either of the types it's trying to unify (its two parameters, in this case) are a type variable ("a"), it will, as wikipedia says, pick one arbitrarily
22:34:53 <corp_drone> !
22:34:56 <corp_drone> !help
22:35:32 <dpwright> but I'm not sure if that's right, since I have "+" mapped to "forall a. a -> a -> a", so I'd expect unify to fail when trying to apply that to variables of two differing types
22:36:01 <dpwright> am I wrong?  Is that the job of a separate constraint solver?  if so, what's the point of the type environment?
22:36:08 <ibid> dpwright: what do you mean by "pick one arbitrarily".  what is the "one" you are referring to?
22:36:12 <haasn> joelteon: does ‘time’ help? It has DiffTime and stuff, you could use a DiffTime to represent your interval, and if you want to show it with days, add it to some UTCTime as well and print that
22:36:18 <haasn> or do you want an output like “9h50m3s”?
22:36:32 <joelteon> no, I want an output like "9 hours ago"; "about a year ago"; "about a minute ago"; etc.
22:37:18 <haasn> ah, I don't think time will help you with that :(
22:37:28 <haasn> you probably need to implement your own (and upload it to hackage)
22:37:35 <ibid> dpwright: also, which wikipedia page?
22:38:03 <haasn> (note: I would drop the ‘ago’ part from the equation and simply write a function for converting a length in seconds into some representation like “about a year”, “about a minute”)
22:39:12 <Hafydd> Why do you want to undo the progress afforded to humanity by the invention of digits?
22:39:37 <dpwright> ibid, the definition of mgu (which I believe is "unify") from that tutorial I linked does a pattern match.  If both types being passed to it are functions it runs mgu on the parameters followed by the expressions.  Failing that, if the first type is a type variable it will bind it.  Failing that, if the second type is a variable it will bind that.  If both types are type literals it returns a null substitution, otherwise it throws an error.
22:39:44 <dpwright> this wikipedia page: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
22:39:55 <dpwright> (sorry, should have been clearer there)
22:40:02 <Hafydd> Hindley%E2%80%93Milner_time_system
22:40:15 <haasn> Hafydd: “63072912 seconds ago” :)
22:40:25 <haasn> (okay, fair, you could just print a timestamp)
22:40:38 <ibid> dpwright: yes, that's how it ought to be
22:41:06 <ibid> dpwright: but i don't see how picking one arbitrarily follows from that
22:41:22 <ibid> dpwright: i'm just trying to make sense of your question, sorry :)
22:41:38 <haasn> is there actually a library function somewhere that will prettyprint a length of seconds into something like “3d 16h 23m 59s”?
22:41:43 <dpwright> sorry, there's a lot about this I don't understand so I am probably wording it badly :-)
22:42:17 <paul___> @pl \((a,b),(c,d)) -> ((a,d),(b,c))
22:42:18 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . (.) . flip . ((,) .) . (,)))
22:42:51 <ibid> dpwright: if i understand your type system correctly, both 1 + 4.5 and 4.5 + 1 ought to be type errors
22:42:56 <dpwright> perhaps arbitrary was the wrong word, though it does seem to be "arbitrarily" picking the first one
22:42:59 <dpwright> yes, that's what I want
22:43:07 <startling> joelteon, http://hackage.haskell.org/package/friendly-time
22:43:26 <dpwright> but when I run either of those through the checker, I'm just getting the type of the first one returned
22:43:35 <haasn> startling: cool :)
22:43:36 <dpwright> I think possibly I'm misusing the typeenv
22:43:39 <startling> haasn: formatTime: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Format.html
22:43:45 <ibid> dpwright: hard to say without seeing your code
22:43:49 <paul___> @pl \((a,b),(c,d)) -> ((a,d),(c, b))
22:43:50 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (,)) . (.) . flip . ((,) .) . (,)))
22:44:39 <ibid> dpwright: my initial question was premised on the possibility that maybe you were thinking that in the two-type-variables case one should pick a concrete type at random, but it does not seem to be your problem based on what you've written since
22:45:40 <startling> haasn: oh, I guess that won't do difftime, hrm
22:46:36 <dpwright> ibid: Ah right... no, in fact it's almost the opposite; I think it should be a type error, but I am being given a type -- not at random, just always the first type
22:47:24 <haasn> startling: I was thinking of one with a more flexdible format, too; eg. for shorter durations it would just print “9m 3s”
22:47:29 <haasn> rather than showing 0d 0h
22:47:32 <ibid> dpwright: trying to unify two different type variables should result in one of them vanishing, all of its occurrences being replaced with the other
22:47:52 <startling> haasn: good point.
22:48:03 <cbarrett> :t ($>)
22:48:04 <lambdabot>     Not in scope: `$>'
22:48:04 <lambdabot>     Perhaps you meant one of these:
22:48:04 <lambdabot>       `$' (imported from Data.Function),
22:48:11 <ibid> dpwright: forex a -> a and b -> b unify in two ways: in the first, a is replaced by b, and in the second, b is replaced by a
22:48:35 <joelteon> thanks startling
22:48:42 <joelteon> that uses time though, not thyme, so I'll use it for inspiration
22:48:46 <ibid> dpwright: the result is that they become either a -> a and a -> a or b -> b and b -> b
22:48:52 <joelteon> or I could use fromThyme
22:51:50 <ibid> dpwright: but i'm not sure how this would ever come to play in your example terms
22:52:31 <joelteon> oh wait, thyme DOES this
22:52:33 <joelteon> awesome
22:52:36 <ibid> dpwright: in the case of 1 + 4.5, in which (+) : a -> a -> a, and 1 : int and 4.5 : float, you would likely first unify int with a, binding a to int.  then you try to unify float with a, except that a is already int, so you're trying to unify float and int, which is a type error
22:52:49 <dpwright> ibid: Hmmm, I think I'm misunderstanding something somewhere along the line, just trying to put my finger on where...
22:53:18 <dpwright> ok
22:53:34 <dpwright> maybe that's where I'm going wrong
22:53:45 <ibid> dpwright: and the same thing happens with 4.5 + 1, except things are done in a different order
22:54:01 <ibid> dpwright: that, too, ends up trying to unify float and int
22:58:19 <dpwright> ibid: Sorry, got dragged away for a second
22:59:16 <dpwright> so, what I've tried to do, which is possibly where I'm going wrong, is to transform everything into the simple lambda expression language at the top of that tutorial first
22:59:26 <dpwright> EVar | ELit | EApp | EAbs | ELet
23:00:05 <dpwright> so in the case of 4.5 + 1, I'm transforming that into "EApp (EApp "+" 4.5) 1"
23:00:16 <ibid> are you using that code or writing your own?
23:00:55 <dpwright> I've pretty much got that code as-is, and then the code I've written myself is to take the
23:01:18 <dpwright> AST from the language I'm actually working in and put it in terms of Exp
23:02:09 <ibid> dpwright: what type environment are you using?
23:02:42 <dpwright> there are some small differences, so I've changed TFun from that tutorial into "TApp T.Text [Type]", and in the case of functions I'm then doing "TApp "->" [t1, t2]", but that's basically equivalent
23:04:23 <dpwright> and then for my type environment, I've made an initialEnv that takes my operators and maps them to Types, so "+" is mapped to 'TApp "->" [TVar "a", TApp "-> [TVar "a", TVar "a"]]'
23:04:46 <ibid> dpwright: how do you type constants?
23:08:02 <dpwright> ibid: Um... you mean constants in my source language?  I'm not sure I understand.  I had imagined dealing with constants and variables in much the same way, either using an EVar as the left parameter of an EApp statement or using ELet...
23:08:16 <dpwright> but I haven't got as far as that yet
23:09:02 <ibid> dpwright: well, your examples had two constants in them, one integer and one float.  how do you teach the algorithm their types?
23:09:11 <dpwright> oh, sorry!
23:09:34 <dpwright> in my code, and the tutorial I was following, they were referred to as "literals", so I got confused
23:10:29 <dpwright> in the expression language, I have an ELit, similar to the tutorial
23:11:13 <dpwright> unlike the tutorial, I don't have like a TInt and TBool constructor in my Type, instead I have TLit which takes the various types (int, float, etc) as a parameter
23:12:05 <dpwright> the actual instantiation of those TLit parameters is done by a function called "tiLit", which is basically the same as the so-named function in the tutorial, but adjusted for the types I'm working with (in this case, int and float)
23:12:10 <ibid> okay,  mgu needs to verify if two TLits are the same type.   are you doing that correctly?
23:12:27 <ibid> (one possible place it might be failing in your problems)
23:12:38 <dpwright> ibid: Aha! I am not!
23:12:53 <ibid> :)
23:13:20 * hackagebot iteratee 0.8.9.5 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.9.5 (JohnLato)
23:13:22 * hackagebot warp 2.0.3.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.3.2 (MichaelSnoyman)
23:13:27 <dpwright> You're right... in the original code, the TInt and TBool patterns were obviously separate patterns to mgu... in mine it all became TLit, and I stupidly dropped the parameter to TLit instead of checking they were equal
23:13:31 <dpwright> thank you!
23:14:13 <ibid> np :)
23:14:33 <ibid> good thing it was that simple.  it's time for me to go to work :)
23:15:06 <dpwright> ibid: Excellent!  That works perfectly.. thanks again, been scratching my head over that one for ages
23:26:31 <makalu> I have installed ghc in a prefix. How do I tell cabal to use that ghc's packages instead of what came with a package manager?
23:38:22 * hackagebot egison 3.2.21 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.21 (SatoshiEgi)
23:43:22 * hackagebot eternal 0.0.1 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.1 (Heather)
23:55:17 <startling> makalu: there's probably a flag for it. you can probably find it in 'man ghc'.
23:55:25 <startling> er, cabal --help
23:56:11 <startling> --with-ghc looks promising
