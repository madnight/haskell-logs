00:00:31 <mm_freak_> xintron: probably a bad idea…  you should just compile on your server
00:00:37 <syllogismos> > filterM (>) [2,5,6,5] 4
00:00:38 <lambdabot>  [5,6,5]
00:01:17 <xintron> mm_freak_, Just wanted to avoid draging in ghc and all the libraries just to compile it. Well, maybe I should compile it in a debian based docker container insteada
00:01:49 <mm_freak_> syllogismos: instantiate the type signature
00:02:15 <mm_freak_> filterM :: (a -> e -> Bool) -> [a] -> e -> [a]
00:06:48 <mm_freak_> xintron: well, disk space is cheap =)
00:11:11 * hackagebot soap 0.2.2.0 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.0 (AlexanderBondarenko)
00:26:12 * hackagebot soap-tls 0.1.0.0 - TLS-enabled SOAP transport (using tls package)  http://hackage.haskell.org/package/soap-tls-0.1.0.0 (AlexanderBondarenko)
00:37:26 <LambdaDusk> hello, I want to send/stream data over a UDP-connection. I found conduit-network with sourceSocket :: Socket -> Int -> Producer m Message, and I could not figure out what to do with this Producer. The conduit tutorials were not very helpful, does anyone have an example on this (or perhaps a better idea which library to use)?
00:41:14 * hackagebot plot 0.2.3 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.3 (VivianMcPhail)
00:49:45 <levi> LambdaDusk: I am not very familiar with conduit, but I think a Producer is what you'd get on the receiving end rather than the sending end.
00:50:07 <levi> Are you trying to be the sender or receiver of the streaming data?
00:50:19 <LambdaDusk> levi: The sender, of course
00:52:15 <levi> You want sinkSocket then, not sourceSocket
00:53:07 <LambdaDusk> hm
00:53:15 <LambdaDusk> but I am producing data, right?
00:54:41 <levi> They're named from the perspective of the code rather than the network.
00:55:19 <levi> A source brings data into your program, and it exits via a sink.
00:56:52 <levi> So you will need to create a Producer for your data, then use the Conduit operators to hook that producer to the Consumer returned by sinkSocket.
00:56:55 <LambdaDusk> hm now it's just a server error
00:57:57 <u-ou> @pl (\x a -> if null a || head a /= x then x : a else a)
00:57:57 <lambdabot> join . ap (ap . (if' .) . liftM2 (||) null . (. head) . (/=)) (:)
00:58:04 <u-ou> ;-;
00:59:12 <u-ou> :t ap
00:59:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:00:01 <levi> LambdaDusk: Where does the data you're streaming come from?
01:00:21 <LambdaDusk> levi: Right now, just a "yield abcd"
01:00:32 <LambdaDusk> it says "destination address required"
01:01:44 <levi> Have you looked at this yet?: https://haskell.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
01:10:56 <levi> It looks like there's an example of usage here: https://github.com/brendanhay/numbersd/blob/master/src/Numbers/Conduit.hs
01:12:19 <hunt> anyone on?
01:12:44 <hunt> i brew installed gcc48 and brew linked it but im not sure how to use it instead of gcc 4.2
01:13:41 <LambdaDusk> levi: I have seen those and they don't quite solve the problem - I think the problem lies with that there's no receiver for the stream. The package doesn't provide how to "listen" to packages
01:16:18 * hackagebot cpphs 1.18.2 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.2 (MalcolmWallace)
01:18:33 <levi> LambdaDusk: There's another example with a sink here: https://github.com/NicolasT/kontiki/blob/master/bin/udp.hs
01:20:11 <levi> UDP packets don't require a receiver. The network stack will happily send them off into the ether without any regard to whether anyone's listening. Your problem must be due to not setting the socket up so that the packets will be *addressed* to someone.
01:21:07 <levi> You may have used the function that binds a receiving socket rather than the one that sets up a sending socket.
01:21:54 <hunt> im installing ghc 7.8 over my ghc 7.6 because some libs are broken
01:22:08 <hunt> does anyone know how i specify which gcc version to use
01:22:11 <hunt> when building
01:23:27 <LambdaDusk> hunt: have you tried setting the CC local variable
01:24:25 <hunt> im not sure how i would do that
01:24:28 <levi> Installing one ghc over top of the other seems like a bad idea.
01:24:44 <LambdaDusk> hunt: https://ghc.haskell.org/trac/ghc/wiki/Building/Using#Runtheconfigurescript
01:24:45 <hunt> i have both installed now
01:24:53 <LambdaDusk> hunt: it says to use --with-gcc
01:25:00 <LambdaDusk> when doing configure
01:25:20 <hunt> ah --with-gcc=
01:25:20 <LambdaDusk> I recommend stting --with-ld and --prefix, too
01:26:09 <LambdaDusk> levi: Ghc is equired to build ghc, and as long as he uses --prefix and keeps $PATH clean, there's no problem
01:26:19 * hackagebot soap-tls 0.1.1.0 - TLS-enabled SOAP transport (using tls package)  http://hackage.haskell.org/package/soap-tls-0.1.1.0 (AlexanderBondarenko)
01:26:36 <hunt> im not sure where i would want to install it
01:26:48 <LambdaDusk> hunt: $HOME/bin
01:26:58 <hunt> haha ty
01:27:04 <LambdaDusk> or rather, $HOME/local
01:27:26 <syllogismos> How do i think about solving problems using state monad?
01:27:26 <hunt> for --with-gcc= do i need a specific path or could i just specify gcc-4.8 instead of regular old gcc
01:27:31 <LambdaDusk> then $HOME/bin is your ghc
01:27:46 <LambdaDusk> syllogismos: With your brain.
01:27:58 <syllogismos> like there is a problem asking me to implement nub using filterM and State how do i go about it.
01:28:05 <LambdaDusk> hunt: No, I think it has to be the full path
01:28:15 <hunt> alright i can do that
01:28:38 <syllogismos> LambdaDusk my brain is rusty..
01:28:42 <hunt> LambdaDusk, im on mac i dont think the home/local applies because i have no local directories anywhere
01:28:59 <hunt> ah /usr/local/
01:29:06 <hunt> and then /usr/local/bin is ghc
01:29:15 <LambdaDusk> hunt: Mac is a unix (kindof) and you can install anywhere
01:29:30 <LambdaDusk> syllogismos: State monad is a wrapper with a "put" and a "get"
01:30:06 <LambdaDusk> syllogismos: There's not much more to it
01:31:59 <LambdaDusk> syllogismos: So how about you use the state "put" to create your unique list by "putting" it there, and use "get" with filterM to check for uniqueness...
01:32:05 <LambdaDusk> lemme write it real quick
01:32:51 <bahamas> hi, guys. I'm reading the gentle introduction and I'm confused about something in the User-Defined Types section, specifically this: data Point a = Pt a a
01:33:01 <bahamas> data Bool = True | False makes sense
01:33:24 <bahamas> however, I don't understand. do Point or Pt exist before the definition?
01:33:32 <shachaf> No.
01:33:37 <hunt> LamdaDuck, is /usr/local is the root of my brew install (mac) will there be problems if prefix points there
01:33:46 <shachaf> "Point Int" is a type. "Pt 3 5" is a value of that type.
01:34:09 <LambdaDusk> hunt: Only if your ghc is installed right there
01:34:11 <shachaf> It's a bit confusing because "Pt" is a (value-level) constructor (that you're defining) but the things after Pt are types.
01:35:05 <hunt> LamdaDusk, if my original ghc is installed there (its at /usr/local/bin/ghc)? So does that mean i shouhuld install ghc 7.8 elsewhere?
01:35:32 <bahamas> shachaf: yes, it's confusing. I don't know what value-level constructor means, for example.
01:36:12 <merijn> hunt: Personally I just made a "~/ghc" directory and installed there on OSX
01:36:22 <shachaf> Let's start with something simpler.
01:36:24 <bahamas> shachaf: unfortunately, there is no usage example in the text.
01:36:27 <merijn> hunt: Other common names would be ~/opt or ~/local
01:36:43 <shachaf> data Foo = Blah Int Char
01:36:53 <shachaf> Foo is a type (as are Int and Char, but you knew that already)
01:36:57 <merijn> shachaf: This conversation sounds like another reason to make GADTSyntax default :>
01:37:08 <shachaf> The type of (Blah 5 'a') is Foo.
01:37:15 <shachaf> Does that much make sense?
01:37:58 <merijn> bahamas: There is an alternative syntax which would write "data Foo = Blah Int Char" as "data Foo where Blah :: Int -> Char -> Foo", which I personally find clarifies what's going on a bit more
01:38:08 <bahamas> shachaf: it kind of makes sense. it's like you're composing (I don't know if this is the best word) a type from other types.
01:38:45 <hunt> merijn, that would be a good idea, but im just going ham and installing it over itself or something
01:38:51 <shachaf> Do you know another language that has types to make an analogy to?
01:38:51 <hunt> im trying not to think about it too much
01:39:11 <bahamas> shachaf: statically typed language you mean?
01:39:20 <shachaf> Yes.
01:39:37 <bahamas> shachaf: sure, I'm familiar enough with C, let's say
01:40:06 <merijn> bahamas: Ah, good. Are you familiar with the notion "tagged union"?
01:40:16 <shachaf> merijn: Huh? Why bring that up?
01:40:25 <shachaf> We're still just talking about products.
01:40:28 <bahamas> merijn: er, no. I'll google it
01:40:39 <merijn> bahamas: Don't bother right now
01:40:46 <shachaf> The C equivalent to this type would be struct Foo { int a; char b; };
01:40:51 <merijn> shachaf: Right, I guess your example would be more of just a struct
01:41:03 <shachaf> Blah is unnamed (and in the Haskell example a and b are unnamed, though you could use an alternative syntax to name them).
01:41:20 <merijn> I'll just let shachaf finish his story :)
01:41:56 <shachaf> I think maybe I'll go to sleep.
01:42:32 <nschoe> bahamas: is your problem differenciating "Point" and "Pt" here ?
01:42:58 <hunt> fuuuck does anyone have experience installing glfw on mac os x
01:42:59 <bahamas> nschoe: my problem is that I don't see an example usage of Pt after I think
01:43:09 <hunt> in haskell (ofc)
01:43:13 <bahamas> after the definition, I mean
01:43:41 <merijn> bahamas: What was the definition of Pt? (I missed that)
01:43:43 <nschoe> bahamas: you don't see how you can use Data Point a = Pt a a ? I mean like in a real applicaiton ?
01:43:57 <startling> bahamas, Pt is a function of type a -> Point a
01:44:11 <shachaf> merijn can finish his story
01:44:14 <bahamas> merijn: it's here, section 2.2 http://www.haskell.org/tutorial/goodies.html
01:44:16 <startling> bahamas: so we could say e.g. Pt 12 :: Point Integer
01:44:17 <merijn> startling: You mean "a -> a -> Point a", I hope you meant
01:44:32 <startling> oh, yes, i think so.
01:44:33 <merijn> eh, I'm being redundantly redundant
01:45:29 <bahamas> startling: ok, and then what? and maybe you meant Pt 12 4 or something, no?
01:45:30 <merijn> bahamas: Right, so alternative syntax for that would be "data Point a where Pt :: a -> a -> Point a", in other words the "Pt" constructor behaves like a function that takes two a's and returns a "Point a"
01:45:35 <startling> bahamas: yeah.
01:46:06 <startling> bahamas: so, the right-hand-side of a "data" declaration is what gives us a way to make values of the new type.
01:46:15 <startling> the left-hand-side just defines the type.
01:46:19 <bahamas> merijn: ah, so you would use it like this, let's say let mypoint = Pt 2 5; then mypoint holds a Point
01:46:21 * hackagebot soap 0.2.2.1 - SOAP client tools  http://hackage.haskell.org/package/soap-0.2.2.1 (AlexanderBondarenko)
01:46:31 <startling> bahamas: yeah, exactly.
01:46:34 <merijn> bahamas: Constructors are essentially functions that take argument and return the datatype that defines them. The only difference is that you can pattrn match constructors, but can't pattern match functions
01:46:39 <startling> well, a Point SomeNumericType
01:46:41 <nschoe> bahamas: Well, you can think of "Point"  as the "name of the type" you define a ne type named "Point". "Pt" however is the keyword you use to *build* an instance of that new type (named "Point").
01:46:42 <merijn> bahamas:
01:46:49 <merijn> @let data Point a = Pt a a
01:46:50 <lambdabot>  Defined.
01:46:54 <merijn> :t Pt
01:46:55 <lambdabot> a -> a -> Point a
01:47:00 <startling> :t Pt 1 2
01:47:00 <lambdabot> Num a => Point a
01:47:04 <merijn> oh, whoops
01:47:10 <merijn> @unlet
01:47:10 <lambdabot>  Define what?
01:47:15 <startling> @undef
01:47:15 <lambdabot> Undefined.
01:47:27 <merijn> @let data Point a = Pt a a deriving (Show)
01:47:28 <lambdabot>  Defined.
01:47:32 <merijn> > Pt 2 4
01:47:35 <lambdabot>  Pt 2 4
01:47:36 <nschoe> bahamas: now, you type is constructed on top of another one : "a", which means you can build a Point on top of a Integer, an Int, a Bool, a Double....
01:47:58 <merijn> > let first (Pt x _) = x in first (Pt 3 5)
01:47:59 <lambdabot>  3
01:48:07 <merijn> :t Pt 3 5
01:48:07 <lambdabot> Num a => Point a
01:48:10 <bahamas> I think I'm starting to understand.
01:48:19 <dagle> :t any
01:48:19 <lambdabot> (a -> Bool) -> [a] -> Bool
01:48:28 <skuggi_> :kind Point
01:48:33 <merijn> bahamas: So the Pt constructors returns values of type "Point a" and you can pattern match to get values out
01:48:41 <bahamas> merijn: you're losing me a bit :) there is new syntax in what you're writing
01:48:42 <merijn> skuggi_: lambdabot doesn't support :kind
01:48:55 <skuggi_> merijn: yeah, just checking :)
01:48:55 <bahamas> merijn: I understand that part, I think
01:48:55 <merijn> bahamas: Ah, which line lost you?
01:48:56 <nschoe> bahamas: In order to build this type, you use the constructor "Pt" Fundamentally, Pt is a function that takes one argument of type "a" and returns another function that takes another "a" and returns a value of your new type "Point".
01:50:26 <bahamas>  merijn> > let first (Pt x _) = x in first (Pt 3 5)
01:50:36 <startling> bahamas: that's just a function defition
01:50:43 <bahamas> plus above with deviring and Show
01:51:02 <startling> bahamas, do you know what typeclasses are yet?
01:51:15 <merijn> startling: Don't go into that, it'll just be confusing
01:51:22 * hackagebot multirec 0.7.4 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7.4 (AndresLoeh)
01:51:25 <merijn> bahamas: Basically, by default values in haskell can't be printed
01:51:27 <startling> bahamas, ok. deriving (Show) is a magic line that tells interpreters how to print things of that type.
01:51:30 <bahamas> startling: well, I just started with the gentle introduction
01:51:36 <bahamas> I'm at section 2.2, so that's all I know
01:51:44 <startling> bahamas: got it. don't worry about it too much, you'll get there.
01:51:47 <merijn> bahamas: "deriving (Show)" just asks the compiler "automagically derive a display function for me"
01:52:03 <merijn> bahamas: You may also want to look at Learn You a Haskell, it's a bit simpler than the Gentle Intro
01:52:05 <merijn> @where lyah
01:52:06 <lambdabot> http://www.learnyouahaskell.com/
01:52:10 <merijn> @quote wrestling.bears
01:52:10 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
01:52:27 <bahamas> merijn: yup. I know about it. I felt like a tough guy and thought about trying the gentle intro :)
01:52:59 <merijn> bahamas: Anyway, "let X in Y" is a local definition, which basically says "use the definitions in X in the expression Y"
01:53:55 <merijn> bahamas: So I was defining a function with type "first :: Point a -> a" (which was inferred, so wasn't in the text) and body "first (Pt x _) = x", that is, it pattern matches the Pt constructor and returns the first value given to it
01:54:25 <merijn> bahamas: Then I used this function in the expression "first (Pt 3 5)", which returned '3'
01:54:43 <bahamas> merijn: ok, I got it
01:55:30 <bahamas> another way of putting it is that 'first' returns the first attribute of the instance created by Pt, no?
01:55:55 <startling> "instance" is the wrong word.
01:56:27 <merijn> bahamas: first attribute of the value, there is no instance here. Although it'd be more common to call them "fields", rather than attributes
01:57:17 <merijn> bahamas: "instance" sounds like object oriented terminology, in haskell "instance" would refer to typeclass instances (which you haven't got to yet)
01:57:43 <bahamas> merijn: yeah, I meant it the OOP way
01:59:26 <merijn> bahamas: If we use a C example like "struct Point { int x; int y; }" (note: this is not polymorphic, the haskell version is!) then first would be the same as "int first(struct Point value) { return value.x; }"
01:59:49 <merijn> bahamas: But the haskell version can store *any* type, not just int
02:00:14 <bahamas> merijn: yup. anyway, an important distinction seems to be that between type constructor and data constructor
02:00:22 <bahamas> merijn: yup. I got that
02:01:09 <shachaf> The type Bool has two constructors, False and True, both with no fields.
02:01:23 * hackagebot pbc4hs 0.1.1.3 - pbc for HsLua  http://hackage.haskell.org/package/pbc4hs-0.1.1.3 (DavidFeng)
02:02:04 <bahamas> shachaf: that's what nullary means? a constructor with no fields?
02:03:03 <hunt> what does fdynamic do in cabal install
02:03:12 <shachaf> That's what I'd take it to mean if I saw it written.
02:05:58 <bahamas> ok, thanks for the help, guys.
02:06:24 * hackagebot pbc4hs 0.1.1.4 - pbc for HsLua  http://hackage.haskell.org/package/pbc4hs-0.1.1.4 (DavidFeng)
02:09:58 <hunt> oh man
02:10:06 <hunt> has anyone ever successfully installed glfw on mac
02:10:07 <hunt> for haskell
02:10:14 <hunt> i cannot get it for my life
02:10:28 <mithsv> use homebrew
02:10:37 <hunt> i have homebrew
02:10:58 <hunt> but i still need the haskell glfw stuff
02:11:09 <merijn> Well, do you have the required C libraries installed?
02:11:09 <hunt> i think ive installed glfw through homebrew
02:11:19 <hunt> yea i can compile stuff from <GLFW/*>
02:11:44 <merijn> hunt: You probably need use the include/library dir options to cabal install so it can find glfw
02:12:08 <hunt> merijn, where can i learn about that/ how do i do that?
02:12:14 <merijn> hunt: "cabal install --help" should list those and then you just pass the include/library directories wheer you installed glfw
02:13:13 <merijn> hunt: I have installed it succesfully on OSX, but I always just use the binary distribution of the platform, and I'm not on the OSX bleeding edge (i.e. 10.7 atm)
02:13:39 <merijn> I'm postponing updating to 10.9 until the new 7.8 platform with 10.9 support is released :p
02:15:08 <hunt> merijn, i installed 7.8 on 10.9 just today
02:15:16 <hunt> merijn, RC 2
02:16:05 <merijn> I have 7.8 installed too, but the latest platform doesn't deal with 10.9's drop of gcc yet
02:16:21 <merijn> New platform should be real soon after the official 7.8 release
02:16:25 <hunt> merijn, idk where glfw is installed :| even though I can include it and probably installed it myself
02:16:52 <hunt> merijn, because its gcc 4.2?
02:17:07 <merijn> hunt: 10.9 doesn't have gcc at all
02:17:19 <hunt> ah but in dev tools it should
02:17:28 <merijn> hunt: No
02:17:32 <merijn> hunt: That's the problem
02:17:43 <hunt> merijn, what? how do i have it then, i thought i installed it from dev tools
02:17:48 <merijn> hunt: 10.9 stopped shipping gcc with Xcode, Xcode now only ships clang
02:18:06 <hunt> merijn, how is that useful
02:18:26 <merijn> hunt: Either you have an old gcc installed or you have clang pretending to be gcc or you installed gcc via ports/homebrew
02:19:10 <hunt> merijn, i recently installed with homebrew but i had 4.2 from before
02:19:20 <hunt> merijn, also how do i find where my GLFW is
02:19:33 <merijn> hunt: Ask homebrew where they install stuff?
02:20:21 <mithsv> brew info glfw3: /usr/local/Cellar/glfw3
02:20:29 <merijn> Anyhoo, I need to run and prepare my class for tomorrow
02:20:34 <hunt> ah cellar
02:21:02 <hunt> alright, thanks merijn
02:21:05 <hunt> and mithsc
02:21:06 <hunt> v
02:21:15 <mithsv> it's symlinked to /usr/local/include
02:23:28 <hunt> mithsv, to reference it in cabal install do i use --extra-include-dirs or should it be available automatically
02:23:30 <dyn> I'm having some trouble installing leksah with cabal (or cabal-dev, tried both)
02:23:42 <dyn> is there any trick I'd better be aware of?
02:25:52 <mithsv> hunt, it's been a while since i installed it
02:26:19 <dyn> or a plain cabal-dev install leksah should work on a relative clean system?
02:26:26 <mithsv> you need to install glfw with a GCC environment in homebrew
02:27:44 <hunt> sorry mitssv, but im not entirely sure what that means.. with a GCC environment
02:27:49 <hunt> mithsv*
02:27:55 <hunt> thanks btw
02:31:41 <dyn> trying to build leksah, what I get is an error about 'Cannot find gtk2hsC2hs' and trying to install gtk2hs-buildtools manually also fails
02:32:46 <hunt> god damn i have no idea what to do with this
02:35:24 <mithsv> hunt, i can't find it atm, and i'm in class
02:35:39 <mithsv> i always use my linux pc for OpenGL
02:39:00 <hunt> mithsv, fuck! someone had a solution last night but brew was installing stuff so i couldnt run it then and there, i shouldve saved it
02:39:08 <aspidites> i'm using clay for css and blaze for html, is there any particular reason that I shouldn't insert the generated css into a style tag instead of writing the css to disk first?
02:39:49 <mithsv> no need to swear, just look it up in the logs
02:40:38 <aspidites> hunt: http://ircbrowse.net/
02:40:46 <hunt> mithsv, i closed the window i had it in, is there anywhere else to get logs? yea sorry i live in a very swear filled world
02:41:55 <hunt> thanks aspidites
02:42:29 <aspidites> np
02:46:28 * hackagebot aws-sdk 0.12.1 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.12.1 (YusukeNomura)
02:47:39 <bahamas> how is [2,2..20] interpreted? I see that it builds a huge list of 2s
02:48:10 <randomclown> withMVar or readMVar
02:48:16 <ion> bahamas: enumFromThenTo 2 2 20
02:48:17 <randomclown> I don't get the difference
02:49:03 <bahamas> ion: can you translate that? I'm just starting out with haskell
02:49:07 <Axman6> @hoogle withMVar
02:49:08 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
02:49:08 <lambdabot> GHC.Conc.Sync withMVar :: MVar a -> (a -> IO b) -> IO b
02:49:08 <lambdabot> GHC.Conc withMVar :: MVar a -> (a -> IO b) -> IO b
02:49:09 <ion> bahamas: Start with two, keep incrementing by 2 - 2 = 0 until 20 is reached.
02:49:29 <aspidites> :t withMVar
02:49:30 <lambdabot> Not in scope: `withMVar'
02:49:30 <Axman6> > [a .. b]
02:49:32 <lambdabot>  *Exception: not a number
02:49:33 <bahamas> ion: ah, so forever
02:49:35 <Axman6> :(
02:49:50 <bahamas> ion: thanks
02:50:04 <aspidites> :t readMVar
02:50:04 <aspidites> whoops
02:50:05 <lambdabot> Not in scope: `readMVar'
02:50:09 <u-ou> for (i = 2; i <= 20; i += 0)
02:50:50 <bahamas> ion: also, why is 19 needed in [20,19..1]?
02:51:02 <Axman6> enumFrom(2)Then(to 2)To(until you reach 20)
02:51:08 <randomclown> because [20,17..1]
02:51:09 <ion> bahamas: The default increment value is 1.
02:51:14 <randomclown> > [20,17..1]
02:51:16 <lambdabot>  [20,17,14,11,8,5,2]
02:51:23 <ion> > [20..1]
02:51:25 <lambdabot>  []
02:51:28 <ion> > [20,21..1]
02:51:29 <lambdabot>  []
02:51:30 <randomclown> also default is positive and goes up
02:52:40 <bahamas> ion: ah, so specifying 19, changes the default increment to -1
02:53:21 <bahamas> thanks
03:00:42 <u-ou> @src span
03:00:43 <lambdabot> span _ xs@[]                     =  (xs, xs)
03:00:43 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
03:00:43 <lambdabot>                   | otherwise    =  ([],xs)
03:02:30 <hunt> so if i wrote a graphics app in haskell with glfw how impossible would it be to distribute on mac
03:06:30 * hackagebot http-test 0.1.2 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.1.2 (glutamate)
03:06:33 * hackagebot ace 0.4 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.4 (ChrisDone)
03:06:35 * hackagebot ace 0.5 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.5 (ChrisDone)
03:08:55 <srhb> hunt: Uh, why would that be impossible?
03:09:01 <srhb> Isn't glfw cross-platform?
03:33:56 <Aetherspawn> Does doing something like this introduce anything bad?
03:33:58 <Aetherspawn> https://gist.github.com/kvanberendonck/9186647
03:36:02 <merijn> Aetherspawn: Seems overly complicated? Why do you need two different classes for that?
03:36:19 <merijn> Aetherspawn: Or rather
03:36:23 <Aetherspawn> I'm not sure really
03:36:29 <Aetherspawn> I kind of based it off what mtl is doing
03:36:43 <Aetherspawn> but I want to be able to swap around the order of annotations and have it still work
03:37:24 <merijn> Aetherspawn: You'll have a combinatorial explosiion of implementations to write when you add more annotations
03:37:48 <Aetherspawn> I know, and I justified it because that's how mtl did it, but is there a better way?
03:39:00 <merijn> Aetherspawn: Hard to say without more info on what exactly you hope to accomplish
03:39:28 <quchen> Code style thing, I think you should use pattern matching whenever possible, e.g.  sourcePos (UsageAnn (x,_)) = sourcePos x instead of sourcePos (UsageAnn x) = sourcePos (fst x).
03:40:04 <Aetherspawn> well, I'll have some functions that add more annotations to a stack of annotations
03:40:23 <Aetherspawn> and I want my functions/passes which consume them to specify a stack of annotations using constraints
03:41:11 <Aetherspawn> but because I don't know which order the stack comes in, I want to just seperate the annotation from the AST
03:41:31 <Aetherspawn> and call the different getters/processors on the annotation directly, like shown in the example with sourcePos and usageInfo despite the type of foo
03:43:59 <Aetherspawn> and quchen, I didn't really like the brace density so I changed it to use fst/snd
03:44:24 <Aetherspawn> but coming to think of it, the structure is probably an important thing to convey I guess
03:46:43 <quchen> When you have all the patterns on the left, you have a nicer separation between structure and operations on data structures
03:55:20 <davd> what's an improper lens? I'm using parsing lenses in pipes-text.
03:56:24 <Cale> davd: Something which doesn't satisfy the lens laws.
03:56:30 <Cale> (but has the appropriate type)
03:57:27 <Cale> But I suppose that suggests the question of what the purpose of such a thing would be. I'm unfamiliar with that package. I see what you're referring to though.
03:57:57 <davd> hm, okay.
04:00:13 <Cale> Maybe it should actually be a Traversal
04:00:35 <davd> It would be nice if the practical implications were documented.
04:01:21 <davd> Perhaps it affects putting stuff back into the parser (unDraw)
04:01:37 * hackagebot hblock 0.1.0.0 - A mutable vector that provides indexation on the datatype fields it stores  http://hackage.haskell.org/package/hblock-0.1.0.0 (HugoGomes)
04:01:39 * hackagebot dirfiles 0.1.0.2 -   http://hackage.haskell.org/package/dirfiles-0.1.0.2 (HugoGomes)
04:01:50 <davd> Anyways, I'm a newbie on Lens.. should probably read up.
04:16:38 * hackagebot multiarg 0.24.0.4 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.24.0.4 (OmariNorman)
04:18:23 <randomclown> Cale: check out my baby - doge.st
04:21:53 <Aetherspawn> merijn: whats the alternative to n^2 instances
04:22:53 <merijn> Aetherspawn: Statically fix the order
04:23:02 <Aetherspawn> oh
04:26:40 * hackagebot cabal-bounds 0.1.3 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.3 (DanielTrstenjak)
04:29:42 <u-ou> @src head
04:29:42 <lambdabot> head (x:_) = x
04:29:42 <lambdabot> head []    = undefined
04:29:48 <u-ou>  
04:29:48 <bernalex> does cabal's "other-sources" not understand spaces in paths?
04:29:51 <u-ou> @src tail
04:29:51 <lambdabot> tail (_:xs) = xs
04:29:51 <lambdabot> tail []     = undefined
04:29:59 <bernalex> "src/foo\ bar" doesn't seem to be working.
04:31:40 * hackagebot ofx 0.4.0.2 - Parser for OFX data  http://hackage.haskell.org/package/ofx-0.4.0.2 (OmariNorman)
04:34:19 <u-ou> what are partially-applied infix-functions called?
04:34:28 <u-ou> i seem to remember there was a special name
04:35:02 <supki> sections
04:35:13 <u-ou> that's the one
04:35:38 <shiona> would it make sense for Endo to have an instance of Category? and is it possible to do one?
04:36:33 <merijn> shiona: No, because endo has only one type argument
04:36:47 <merijn> shiona: i.e. "newtype Endo a = Endo (a -> a)"
04:37:01 <shiona> merijn: is that an answer for the second question or the first?
04:37:02 <merijn> shiona: Category has two type arguments
04:37:16 <merijn> shiona: So, it's the answer to both
04:37:25 <merijn> i.e. no, it's not possible and doesn't make sense
04:37:34 <shiona> ok.
04:37:42 <merijn> shiona: The closest thing is the Category instance for (->)
04:37:47 <shiona> I came to the same conclusion that it's not possible
04:38:02 <shiona> but I could see the usefulness of being able to use (.) with Endo
04:38:15 <merijn> shiona: That's the monoid instance of Endo
04:38:45 <merijn> mempty = id, (Endo f) <> (Endo g) = Endo (f.g)
04:39:02 <merijn> shiona: That monoid is the entire reason for Endo existing :p
04:39:51 <shiona> yes, but it would be nice if one would not need to remember when to use (<>) and when (.), when they are on some level the same thing
04:40:01 <ivanm> wait, so Endo is the monoid on a -> a, instead of the monoid of (Monoid b) => a -> b ?
04:40:19 * ivanm could have used that then....
04:40:39 <merijn> ivanm: Yes
04:41:00 <ivanm> oh well, too late now... (though it only was the other day when I was wanting that)
04:41:01 <mr-> ivanm: Yes, Endo is a monoid regardless of a
04:41:45 <ivanm> all I found was the default function instance, which made my code do the wrong thing until I realised what it was doing :s
04:45:49 <dreuge> Hi, I want to create a list of records from data fed from stdin, but gracefully handle faulty input. I figured I need the Maybe monad, to signify failure and propagate it nicely, but I also want to pass the input stream nicely, along with my record-in-construction... any advice how to best do this?
04:47:11 <Aetherspawn> what have you tried?
04:47:36 <Yuu-chan_> dreuge: if you need to combine Maybe failure processing with feeding from IO, I think about monad transformers
04:47:55 <Aetherspawn> probably wouldn't go into monad transformers
04:47:59 <Aetherspawn> thats overcomplicating it imo.
04:48:49 <dreuge> Aetherspawn, I'm a bit of a newbie, doing this to learn haskell better. fiddled around with returning Maybe (record, rest_of_stream), but seemed a bit ugly...
04:49:18 <Aetherspawn> maybe you're looking for a parser like attoparsec
04:49:22 <Yuu-chan_> Hm, combinator parsers maybe?
04:49:41 <dreuge> attoparsec? hmm will take a look, thanks
04:50:17 <Yuu-chan_> Or regular Parsec if you don't want to deal with ByteStrings
04:53:07 <ski> @kind Category  -- only a single argument ..
04:53:08 <lambdabot> (* -> * -> *) -> Constraint
04:58:07 <haasn> > reads "Node { rootLabel = 3, subForest = [] } Node { rootLabel = 4, subForest = [] }" :: [(Tree Int, String)]
04:58:08 <lambdabot>  [(Node {rootLabel = 3, subForest = []}," Node { rootLabel = 4, subForest = [...
04:58:18 <haasn> you can also use this to read a list of records while propagating failures and multiple alternatives
04:58:33 <haasn> (using the list monad rather than Maybe)
04:58:36 <haasn> but the advantage is that “reads” is built-in
04:58:45 <haasn> and can be auto-derived from your record type using “deriving Read”
04:58:59 <haasn> oh, but you probably don't have the data in exactly that form. Never mind :P
04:59:00 <Yuu-chan_> @info Tree
04:59:01 <lambdabot> Tree
05:00:34 <Yuu-chan_> haasn: does it really propagate useful failures? When I tried to use read for loading a config, it was really cool and simple, but a single typo caused "no parse".
05:00:55 <haasn> not useful, no :)
05:01:10 <haasn> > reads "sjdfksjdf" :: [(Int, String)]
05:01:12 <lambdabot>  []
05:01:15 <haasn> zero information
05:01:28 <haasn> Anyway dreuge probably would benefit from learning to use a real parsing library here :)
05:01:41 <haasn> If you're streaming from IO I'd also heartily recommend using pipes together with pipes-attoparsec
05:01:51 <haasn> Err, pipes-parse
05:01:57 <haasn> @hackage pipes-parse
05:01:57 <lambdabot> http://hackage.haskell.org/package/pipes-parse
05:02:35 <haasn> @hackage pipes-attoparsec -- oh, this exists too; no wonder I got confused. I meant pipes-attoparsec
05:02:36 <lambdabot> http://hackage.haskell.org/package/pipes-attoparsec -- oh, this exists too; no wonder I got confused. I meant pipes-attoparsec
05:02:42 <dreuge> haasn, what's the advantage of using pipes?
05:02:52 <haasn> dreuge: you can read input incrementally without lazy IO hacks
05:03:09 <haasn> dreuge: that is, you can process records one at a time as you read through the file and if there's an error anywhere it will be handled safely and sanely
05:03:19 <haasn> without filling up your memory by reading the entire file or leaving file descriptors open
05:03:27 <dreuge> ahh
05:03:48 <haasn> pipes is a bit advanced though
05:03:51 <dreuge> It looks a bit more complicated than what I can handle right now though
05:03:55 <haasn> fair enough
05:04:12 <haasn> just keep it in the back of your head for some later date, then :)
05:04:21 <dreuge> cheers
05:11:40 <u-ou> @src foldl
05:11:40 <lambdabot> foldl f z []     = z
05:11:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:25:53 <Kneiva_> > foldl max 0 [1, 3, 2, 4, 6, 5]
05:25:54 <lambdabot>  6
05:27:28 <ski> > foldl max 0 [1, 3, 2, 4, 6, 5]             :: Expr
05:27:29 <lambdabot>  max (max (max (max (max (max 0 1) 3) 2) 4) 6) 5
05:30:56 <u-ou> what module is Expr from?
05:31:00 <alexbr> Hi all. Do you know of any standard method to generate fresh names in haskell?
06:04:41 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
06:04:41 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
06:26:53 * hackagebot tokenize 0.2.2 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.2.2 (GrzegorzChrupala)
06:30:43 <migimunz> Hello! If I have a function a -> a -> a, and apply uncurry on it, I get a function of type (a, a) -> a. I noticed that, in order to force the function to be uncurryable, it transformed it so that it now takes a tuple of a and returns an a. Is this really all that it has done, and why is this a useful thing to do? I hope it's not too broad a question.
06:31:09 <scshunt> migimunz: yes, uncurry f (a, b) = f a b
06:31:10 <migimunz> tuple of type (a, a), I meant
06:31:23 <scshunt> it's can be useful in a few circumstances
06:31:23 <migimunz> scshunt, thank you
06:31:45 <scshunt> if you have a list of tuples, then it can help you do a map over them, for instance
06:31:48 <bernalex> like if maybe you have a tuple of (Ball, Ball) and you want to collide $ uncurry bs
06:32:08 <migimunz> oh I understand. Thank you guys!
06:34:01 <t4nk694> migimunz: say you have a list of (Int, Int) tuples and want to sum them one by one: map (uncurry (+))
06:34:57 <merijn> A cabal file can only specify a single library?
06:35:49 <bernalex> I'm looking a demo of a library and it gives me a billion "Couldn't match type 'ByteString' with '[Char]'", ideas?
06:36:18 <bernalex> I assume they want me to use some pragma for this
06:36:35 <scshunt> bernalex: data.text
06:36:45 <scshunt> oh wait, that's bytestring
06:36:59 <scshunt> data.bytestring
06:37:01 <bernalex> the example looks very much like it should "just work", so I imagine they have forgotten a pragma
06:37:05 <merijn> bernalex: Sounds like you need OverloadedStrings
06:37:13 <bernalex> merijn: that's in there, actually
06:37:16 <bernalex> {-# LANGUAGE DeriveDataTypeable, FlexibleContexts, GeneralizedNewtypeDeriving, RankNTypes, RecordWildCards, OverloadedStrings #-}
06:39:22 <bernalex> uhm actually, the example does .pack all over the place as well
06:39:41 <bernalex> oh, right. the errors are all that the return type of 'pack' is String but expected ByteString
06:39:53 <bernalex> they're using C.pack, and they have import qualified Data.ByteString.Char8 as C.
06:41:55 * hackagebot matchers 0.14.0.2 - Text matchers  http://hackage.haskell.org/package/matchers-0.14.0.2 (OmariNorman)
06:57:17 <merijn> Any cabal experts around?
06:57:43 <merijn> I want to programmatically check whether a cabal package configuration is up-to-date and if not, configure it
06:58:00 <merijn> I've found Distribution.Simple.Configure.checkPersistBuildConfigOutdated :: FilePath -> FilePath -> IO Bool
06:58:04 <migimunz> t4nk694, thanks, the practical example makes it that much clearer
06:58:20 <merijn> But even after reading the source it is unclear to me what kind of FilePaths it expects?
06:58:46 <bernalex> I'm not sure if I'll ever remember this but: how do you specify in the source which module you want when there's ambiguous imports?
06:59:02 <merijn> The only use of it within cabal is in the context of getBuildConfig, but that doesn't tell me much on how to use it...
06:59:18 <merijn> bernalex: The correct answer is: Use cabal
06:59:41 <bernalex> merijn: thanks, but feel free to answer my question too.
06:59:53 <davean> bernalex: do you mean when two things export the same module?
07:00:01 <davean> (which cabal won't fix)
07:00:05 <bernalex> davean: I mean ambiguous module names
07:00:23 <bernalex> so if you use ghc  you just do hide module_you_dont_want
07:00:45 <davean> Hiding a package?
07:00:49 <merijn> bernalex: Solution 1) don't have ambiguous module names, Solution 2) if they're in different package, use cabal to determine which package you don't want, Solution 3) Read the GHC docs because you don't want to tackle the solution properly
07:00:55 <davean> bernalex: I think you're confused as to terms, which is the start of hte problem
07:00:57 <bernalex> davean: yes, so you can do this in source.
07:01:14 <davean> bernalex: To asker your question I have to be sure what you want
07:01:36 <bernalex> merijn: 1. it's transformers. 2. I don't use cabal for a tiny script which is meant to be run with runhaskell. 3. no thanks.
07:01:42 <davean> I tihnk you MIGHT mean package qualified imports
07:01:58 <davean> like import "network" Network.Socket
07:02:00 <bernalex> davean: I mean Ambiguous module name `Control.Monad.Reader': it was found in multiple packages
07:02:03 <davean> but I'm also pretty sure I can think of 3 things you MIGHT mean
07:02:19 <bernalex> the error message is specifically "Ambiguous module name" for this case.
07:02:39 <davean> Ok then the answer I gave is what you want, what you should do ...
07:03:15 <davean> See 7.3.18 http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
07:03:44 <davean> This also comes up when packages conflict about what namespace they're claiming
07:04:38 <bernalex> davean: ah, that was it. thanks.
07:06:49 <davean> as for why what you're doing is bad ... I'm sure experiance will teach you better then I ever could :)
07:07:48 <bernalex> hm. why can't I import Control.OldException? that's odd. I have base4.
07:08:06 <Cale> What?
07:08:17 <bernalex> "Could not find module Control.OldException"
07:08:28 <bernalex> and according to docs it's in base 4.5
07:08:57 <davean> Well, it isn't in 4.6 as far as I can tell
07:09:06 <bernalex> ah, so it's nuked?
07:09:14 <davean> it is "Old"
07:09:21 <bernalex> maybe I'll have to rewrite this example code then
07:09:54 <davean> In 4.5 "Deprecated: Future versions of base will not support the old exceptions style. Please switch to extensible exceptions."
07:10:00 <bernalex> err right they just catch all errors, how do I do that with the newer lib?
07:10:09 <davean> Exception
07:10:11 <bernalex> i.e. catch (runReaderT run st) (const $ return ())
07:10:27 <Cale> Usually you'll just want to write (\(SomeException e) -> ...) in place of (\e -> ...)
07:10:43 <davean> https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html
07:10:46 <davean> "Catching all exceptions"
07:11:03 <davean> bernalex: you might want to start reading the docs, these are questions directly answered in the docs
07:11:22 <bernalex> davean: I see, I'll just use SomeException. thanks.
07:12:09 <Cale> Yeah, the code displayed in the comment there is actually usually inconvenient, because a lot of code which matches against all exceptions won't actually use the exception value in the body of the lambda
07:12:23 <Cale> So, I'd recommend just pattern matching against the SomeException data constructor.
07:12:26 <bernalex> Cale: I see. the same is with the code I posted.
07:12:40 <bernalex> i.e. catch (runReaderT run st) (const $ return ())
07:12:57 <Cale> Yeah, you could make that (\(SomeException e) -> return ())
07:13:47 <bernalex> Cale: yes that's what I did. :-)
07:14:39 <bernalex> thanks, both of you. works now. well, not really, but the problem is elsewhere at least. :-)
07:15:15 <Maior> where do people stand on orphan instances?
07:15:20 <Cale> What code are you updating?
07:15:30 <bernalex> Cale: I'm trying to run the haskell wiki irc bot example
07:15:30 <Cale> Maior: Means of last resort
07:15:41 <u-ou> @src span
07:15:42 <lambdabot> span _ xs@[]                     =  (xs, xs)
07:15:42 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
07:15:42 <lambdabot>                   | otherwise    =  ([],xs)
07:15:51 <bernalex> Cale: everything type checks and is ok in the code, but it just does "connecting to irc.freenode.net" forever now.
07:15:57 <Maior> Cale: ah ok, cheers (https://github.com/doismellburning/lux/blob/feature/skeleton-graphite/src/Lux/Outputs/Graphite.hs)
07:16:21 <Cale> Maior: You generally would always like to avoid orphan instances, but there are cases where you don't actually have ownership over the code you'd need to in order to avoid them.
07:16:59 * hackagebot soap-openssl 0.1.0.0 - TLS-enabled SOAP transport (using openssl bindings)  http://hackage.haskell.org/package/soap-openssl-0.1.0.0 (AlexanderBondarenko)
07:17:28 <Maior> Cale: thanks, fortunately it's fairly trivial to remove the instance here
07:17:31 <bernalex> Cale: not even the simplest example works. it just does h <- connectTo server (PortNumber (fromIntegral port)); hSetBuffering h NoBuffering; t <- hGetContents h; print t -- that's the entire thing. =/
07:18:26 <Cale> What's going on with the PortNumber there?
07:18:43 <bernalex> I assume it's something from Network
07:18:44 <Cale> remove the PortNumber data constructor
07:19:05 <bernalex> uhm connectTo requires a Num PortID
07:19:10 <Cale> PortNumber is an instance of Num, and you shouldn't use its data constructor directly, unless you want to deal with endianness issues
07:19:17 <Cale> oh
07:19:22 <Cale> hm
07:19:56 <Cale> oh, yeah, right
07:19:57 <Cale> okay
07:20:00 <Cale> so that's not it :)
07:20:15 <bernalex> :->
07:20:15 <Cale> I guess they even hid the constructor I was thinking of to prevent this issue anyway :)
07:20:34 <bernalex> I'm taking a break to watch Chinese martial arts films; I'll look more into it tomorrow.
07:24:40 <u-ou> @src even
07:24:40 <lambdabot> even n = n `rem` 2 == 0
07:27:05 <Sculptor> hi
07:29:12 <GilTheMighty> hello
07:29:45 <GilTheMighty> I am new to Haskell and I wonder how to install a compiler to Haskell
07:29:56 <GilTheMighty> *for
07:30:27 <Cale> GilTheMighty: You'll want GHC
07:30:38 <merijn> GilTheMighty: On Windows/OSX you probably want to grab the binary distribution of Haskell Platform
07:30:49 <Cale> http://www.haskell.org/ghc/download_ghc_7_6_3
07:31:57 <Cale> Well, yeah, it somewhat depends on platform. On Linux, usually I'll just get the generic GHC binary, and then install cabal-install using the tarball from Hackage.
07:32:37 <merijn> Cale: That's why I let linux out and only mentioned windows/OSX :p
07:32:47 <Cale> (You could also get your distribution's package for GHC, but I have an inherent distrust for distribution packages when it comes to Haskell.)
07:34:13 <GilTheMighty> cale: I am downloading the GHC via your link
07:35:07 <Cale> GilTheMighty: You'll also want http://hackage.haskell.org/package/cabal-install-1.18.0.2/cabal-install-1.18.0.2.tar.gz
07:36:24 <Cale> GilTheMighty: Inside that package, you'll find a bootstrap.sh script that you can run to install it, if you're on Linux.
07:37:01 * hackagebot oauthenticated 0.1.2 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.2 (JosephAbrahamson)
07:37:06 <u-ou> @src flip
07:37:06 <lambdabot> flip f x y = f y x
07:37:43 <Sornaensis> @src foldl
07:37:43 <lambdabot> foldl f z []     = z
07:37:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:44:43 <GilTheMighty> Is it compiler?
07:45:15 <haasn> What's the technical term for comparing a list by first comparing the head, and only if that is equal, comparing the next elements, etc.?
07:45:55 <coltfred> haasn: short circuit equality maybe?
07:46:22 <coltfred> haasn: I would just call it equality with a reasonable method of evaluation, but there might be some technical term that better describes it.
07:46:33 <haasn> emphasis on the order in which elements are compared; I faintly remember there being a term for it - also “backwards foobar” for when you start with the last element, etc.
07:46:49 <dreuge> Does anyone know an example of useing Parsec 3 with Data.Text?
07:46:51 <haasn> lexicographic?
07:47:09 <haasn> yes, lexicographic order is what I was looking for
07:50:41 <jxv> dreuge, you can look at chrisdone's "ace" package
07:53:55 <klrr> is it possible to use a Char8 bytestring in pipes-bytesrting?
07:54:43 <Twey> klrr: Isn't a Char8 bytestring the same as a normal bytestring?  I think the encodings are just about input/output actions; the ByteString type itself is encoding-agnostic
07:55:54 <merijn> Twey: They are
07:56:11 <merijn> Twey: The only difference is that Char8 exports a different pack/unpack function and an IsString instance
07:58:54 <klrr> okey, thanks
08:02:04 * hackagebot threepenny-gui 0.4.1.0 - GUI framework that uses the web browser as a display.  http://hackage.haskell.org/package/threepenny-gui-0.4.1.0 (HeinrichApfelmus)
08:04:40 <Maior> reading through network-metrics; `open :: Host -> HostName -> PortNumber -> IO AnySink` - anyone have any clue what the dual Host/HostName might be? (I say this as I read the source, slowly)
08:08:07 <carter> hello everyone!
08:11:55 <alexbr> merijn: are you still there? I tried using it, but I didn't manage
08:12:18 <geekosaur> Maior: if I had to guess from the API, Host is a tag identifying the host the metrics came from and HostName is the host running the collection daemon
08:12:42 <alexbr> merijn: (the supply transform)
08:13:16 <Maior> geekosaur: cheer
08:13:19 <Maior> *cheers
08:13:26 <Maior> looks about right, thanks
08:14:16 <Twey> Crazy proposal: replace (or augment) the rôle of monads in Haskell with indexed monads.
08:16:30 <alexbr> anyone can give me a concrete example of how I should use a supply monad?
08:17:47 <haasn> runSupply 0 succ $ liftM2 (,) demand demand -- ?
08:18:00 <haasn> would result in (0,1)
08:18:21 <haasn> oh, other order on “runSupply”; ugh
08:18:46 <haasn> this is the single greatest issue with monad transformers - you never get the right parameter order on runX!
08:19:01 <dreuge> I'm thinking that parsec is still beyond my haskell ability -_- May try again after more practice
08:19:29 <haasn> dreuge: what are you struggling with?
08:19:35 <alexbr> so the first parameter is the initial value, the second is the state transformer?
08:19:51 <haasn> working with parsec pretty much requires knowing how to work with monads (and ideally applicatives), mind
08:20:28 <dreuge> basically all of it :p The tutorials on it I found work with parsec 2, whereas I'm using parsec 3. And even then I have no idea of how to make even a tiny parser work with Data.Text.Lazy
08:20:32 <haasn> alexbr: runSupply :: Supply s a -> (s -> s) -> s -> a
08:20:36 <ParahSailin> did i hear correctly that MonadPlus is getting rolled into Alternative?
08:20:46 <haasn> alexbr: looks like the actual parameter order is “runSupply x update initial”
08:20:49 <japesinator> is there a division operator that has type of Num a => a -> a -> a?
08:20:54 <japesinator> Hoogle turns up nothing
08:20:55 <haasn> eg. runSupply x succ 0
08:21:37 <alpounet> @type div
08:21:38 <lambdabot> Integral a => a -> a -> a
08:22:18 <japesinator> Ideally I'm looking for something that works for Integral, Complex, Real, and Float
08:22:30 <haasn> interesting, you could run it off runMonadSupply x (getRandomIO :: IO UUID) -- to generate uuids
08:22:35 <haasn> on the fly
08:22:46 <klrr> hmm, is it not possible to do partial evaluation on data constructors? e.g. data Foo = Foo String In Bar foo = Foo , yields errors complaining about too few applied args
08:23:05 <klrr> wait nvm
08:23:28 <haasn> klrr: I cannot parse that code example
08:23:54 <klrr> nvm it
08:24:09 <Twey> japesinator: No, integer division has different properties to floating-point division so it's a different function
08:24:32 <alexbr> haasn: I don't get what x is in the example
08:24:41 <haasn> alexbr: your computation of type “Supply s a”
08:28:05 <GilTheMighty> I have dowmloaded GHC from  http://hackage.haskell.org/package/cabal-install-1.18.0.2/cabal-install-1.18.0.2.tar.gz
08:28:10 <dagle> I had a problem understanding the haskell cairo bindings... then I understood why, I had no clue how cairo really worked.
08:28:26 <GilTheMighty> and I dont what to do that I could run Haskell programs
08:28:52 <haasn> dagle: haskell bindings do that for you ;)
08:29:28 <dagle> haasn: Yeah, I thought "Well, lets look at the types and function names and things will explain them selfs", I guess not.
08:29:49 <byorgey> dagle: what are you using the cairo bindings for?
08:29:51 <GilTheMighty> *know
08:29:53 <bennofs> How do I write to a Ptr from haskell? I'd like to write a ByteString to a Ptr Word8
08:30:12 <enthropy> @hoogle memcpy
08:30:13 <lambdabot> No results found
08:30:18 <dagle> byorgey: Rendering layers of images, text and figures.
08:30:31 <enthropy> bennofs: there are things in Foreign.Storable and Foreign.Marshal
08:32:50 <sssilver> Guys, when attempting to cabal install gloss-examples on the latest OSX, I'm getting a: Warning: Couldn't figure out LLVM version. I do have XCode installed. Anyone knows what's going on?
08:33:14 <joelteon> which version of llvm do you have?
08:33:48 <sssilver> 5.0
08:33:54 <sssilver> llvm-gcc --version that is
08:34:33 <monochrom> yikes, now #haddock exists?! :)
08:36:03 <Fuuzetsu> yes, you're now able to have all your complaints fall into obscurity there ;)
08:36:23 <monochrom> so many channels, very few pixels :)
08:38:55 <geekosaur> sssilver, if the llvm you have is just apple's, it includes only the parts apple uses
08:39:10 <geekosaur> you will need to install a full llvm from somewhere
08:39:16 <sssilver> geekosaur: I just have what comes with xcode
08:39:19 <sssilver> so that might be it
08:40:05 <Maior> has anyone here actually used network-metrics themselves?
08:40:14 <Maior> I'm currently debugging the tail end of http://hackage.haskell.org/package/network-metrics-0.3.2/docs/src/Network-Metric-Internal.html and a bit uninspired
08:44:28 <haasn> Is there interest in an instance (Applicative f, Num a) => Num (WrappedApplicative f a) -- ?
08:45:42 <bennofs> haasn: I for one would like that. WrappedApplicative could also be a monoid, for Monoid a
08:46:20 <haasn> many classes could be lifted over applicatives, indeed
08:52:18 <krgn> hey I have a question regarding instances defined for Key from Web.ClientSession
08:53:02 <krgn> on hackage, it claims there is an instance defined for Serialize, but when I check :info Key in ghci it doesn't show
08:53:23 <krgn> as in, only an instance for Show and Eq are defined
08:53:33 <krgn> I made sure that the versions are the same, as well
08:57:17 <bennofs> krgn: I've found :info to be pretty unreliable when looking up instances
08:57:17 <bennofs> krgn: also, do you have Data.Serialize imported? It could be that the class is just not in scope
08:57:44 <krgn> bennofs: ah I havn't, that might be the culprit!
09:12:29 <sssilver> OK so I did a separate install of brew install llvm
09:12:29 <sssilver> besides the one that came with XCode
09:12:38 <sssilver> but I'm still having the problem
09:12:51 <apt-get> hey
09:13:04 <apt-get> starting to learn haskell with learnyouahaskell
09:13:09 <apt-get> ghci> sum [5,2,1,6,3,2,5,7]
09:13:10 <apt-get> 31
09:13:17 <apt-get> shouldn't this be 12600?
09:13:34 <thebnq> its adding them up
09:13:36 <Fuuzetsu> > product [5,2,1,6,3,2,5,7]
09:13:37 <lambdabot>  12600
09:14:05 * carter sssilver: you don't need llvm 
09:16:19 <apt-get> oh um
09:16:19 <apt-get> oh
09:16:23 <apt-get> I misread sum and product
09:16:24 <apt-get> lol sorry
09:18:29 <dreuge> haasn, went for a walk, think I have a much better grasp of the idea of parsec after looking at it again. Two questions though: 1. When should I use runParser instead of parse? 2. It there a better way to output Data.Text as well as input, other than peppering my functions with T.pack/
09:18:35 <sssilver> carter: it's not me, it's gloss-examples -> gloss-raster :)
09:18:42 <carter> why does it need llvm?
09:18:47 <carter> sounds ike a bug.
09:20:33 <haasn> dreuge: looks like parsec has an additional ‘u’ user stat that you can freely mutate if you want to (similar to mixing in a StateT monad transformer); if you don't need this user state, you can use ‘parse’ instead of ‘runParser’ which automatically assumes your user state is () and passes that as the initial value
09:20:43 <haasn> apart from that, runParser takes an additional ‘u’ parameter that is used as the initial state for your parser
09:20:53 <sssilver> carter: I can't find one that's been filed, so I'm assuming it's normal
09:20:59 <carter> sssilver: but you don't need llvm
09:21:02 <carter> ever
09:21:06 <carter> unless you explicitly call it
09:21:09 <dreuge> haasn, thanks
09:21:10 <carter> warnings != errors
09:21:40 <sssilver> carter: http://bpaste.net/show/YTu43RKYtPpxv1hIANjL/
09:21:41 <grohne> I am confused. Will catchError ever catch an "error"? (i.e. is there any instance MonadError instance that would do this?)
09:22:14 * hackagebot uni-util 2.3.0.0 - Utilities for the uniform workbench  http://hackage.haskell.org/package/uni-util-2.3.0.0 (ChristianMaeder)
09:22:24 <carter> https://github.com/benl23x5/gloss/blob/master/gloss-raster/gloss-raster.cabal#L33
09:22:27 <carter> fuck you're right
09:22:43 <carter> thats shitty
09:22:52 <sssilver> I'm sorry
09:23:51 <carter> sssilver: you have nothing to apologize for
09:23:56 <carter> i'm gonna go yell at ben :)
09:24:28 <supki> grohne: I don't think there is
09:24:39 <supki> grohne: you can write one yourself with a newtype wrapper around IO
09:25:03 <Maior> so, http://hackage.haskell.org/package/network-2.2.1.7/docs/Network.html#10 is a little light on information about more useful error handling, like reconnecting
09:25:06 <Maior> any suggested reading?
09:25:12 <haasn> dreuge: oh, I didn't see your second question; not sure what you mean. You want a parser that returns some Text?
09:25:22 <carter> sssilver: i'm gonna go yell at ben
09:25:23 <supki> grohne: you'll need a wrapper because there's already a  MonadError IOException IO
09:25:30 <grohne> supki: good. I don't want one. I am debugging an endless loop. ;-)
09:26:03 <sssilver> carter: in my corporation they say that yelling is not an efficient tool for achieving desired results
09:26:05 <dreuge> haasn, exactly. Since it's consuming Text anyway, it seems like it's converting to String unnecessarily in the parser
09:26:22 <carter> sssilver: "yelling" is me being euphamsitics
09:26:23 <grohne> supki: and since I had some fun with "fail" being assumed to result in Left, I was guessing that maybe some error could be swallowed
09:26:37 <haasn> dreuge: the API is based on character streams either way so I'm not convinced there's necessarily a big advantage you can gain here; especially since most parsers are based on combining simpler primitive character parsers
09:26:45 <haasn> dreuge: T.pack seems like the best thing you can do
09:26:50 <carter> sssilver: if you've seen me doing bug reports, its more  stubborn, usually correct, and annoying :)
09:27:22 <haasn> dreuge: oh, it seems like parsec-alternatives support this though
09:27:25 <haasn> dreuge: eg. http://cpanel213.necdn.com/808C06/hockgiftshop.com/images/nalgene%20glow%20in%20the%20dark%20green.jpg
09:27:30 <haasn> Oops, wrong url: http://hackage.haskell.org/package/parsers-0.10.2/docs/Text-Parser-Char.html#t:CharParsing
09:27:56 <haasn> and indeed, that one works with parsec!
09:28:25 <haasn> dreuge: oh, but the definition for that one is simple:
09:28:29 <haasn> text t = t <$ string (unpack t)
09:28:31 <carter> ok
09:28:33 <carter> i'm gone
09:28:43 <supki> grohne: oh, right, Either's fail behavior did change
09:28:52 <dreuge> haasn, hah nice
09:29:47 <zebr> hi all. is every monoidal pointed functor a monad, or does it need something extra?
09:29:50 <dreuge> How would I implement a parser that consumes all tokens except those another parser does consume? Like ^ in regex character classes
09:30:01 <TravisD> Weird, my new IRC client automatically fetches images and displays them inline
09:30:07 <prinsen> AlainODea: Are you there?
09:30:25 <Maior> I guess I need to installHandler at The Magic Point
09:30:30 <dreuge> for example, parsing all non-whitespace characters using the space parser
09:30:46 <haasn> dreuge: usually you'd use something like satisfy; eg. satisfy (not . isSpace)
09:31:14 <dreuge> thanks again!
09:31:24 <sssilver> carter: so then I guess I'm putting my acquaintance with Gloss away for now, because I'm failing to make this work for the last two days :))
09:31:35 <haasn> dreuge: apart from that, you could maybe use something like notFollowedBy
09:31:45 <Maior> though I'm confused about going from SIGPIPE to "ok this TCP connection needs re-creating"
09:31:51 <haasn> notFollowedBy parserYouWantToFail *> char -- would parse a char not matched by parserYouWantToFail
09:31:56 <haasn> Disclaimer: i think.
09:41:31 <halvorg> Hey, is this somewhat in the right direction? I'm trying to do animations in haskell
09:41:34 <halvorg> http://lpaste.net/100356#line16
09:42:52 <halvorg> Like, I have a tail recursive function that draws some pictures with a thread delay
09:43:29 <halvorg> I think the delay happens, but I see no effect of the animation.
09:43:39 <halvorg> It is very possible that there is a bug somewhere else though.
09:45:36 <geekosaur> "msecs"
09:45:45 <geekosaur> you are aware that threadDelay operates in usecs?
09:46:18 <Twey> halvorg: Consider Gloss
09:47:05 <halvorg> Gloss is what? an SDL wrapper/alternative?
09:47:17 * hackagebot cabal-bounds 0.1.4 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.4 (DanielTrstenjak)
09:47:29 <Twey> halvorg: This is a very imperative approach.  It'll work, but it will probably be clumsy.  The idiomatic way to do it is to define a picture DSL, as Gloss does.
09:47:43 <haasn> have a look at fran and friends also :)
09:47:50 <haasn> frp mixes well with animated graphics
09:48:38 <halvorg> I tried some frp packages earlier, but couldnt get even the simplest examples to run. Like grapefruit or something.
09:48:54 <halvorg> Twey: DSL?
09:49:05 <Twey> halvorg: The modern FRP packages are things like reactive-banana and Sodium
09:49:11 <Twey> Domain-Specific Language
09:49:45 <Twey> Or Netwire maybe
09:50:28 <halvorg> geekosaur: oh, I didn't know. Still I use a large enough number that it shouldn't matter.
09:52:17 * hackagebot cabal-bounds 0.1.5 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.5 (DanielTrstenjak)
09:52:30 <Twey> Oh, and statements in a do-block are sequential.  That's what it's for.
09:52:51 <Twey> (for some definition of ‘sequential’ defined by the monad, but for IO that's what you probably expect)
09:53:24 <Clint> fsvo 'statement'
09:53:56 <Twey> Clint: The usual one :þ
09:54:06 <xintron> Any recommended sqlite library?
09:54:26 <PatLarsson> Is there anyway to enforce user-defined axioms about type families in GHC? For example, I want to state that the type family G is left-inverse of the the type family F, i.e. "G (F t) ~ t"
09:54:28 <Twey> xintron: persistent-sqlite probably
09:54:36 <halvorg> Yeah thanks Twey, I'll look into frp I guess..
09:54:41 --- mode: ChanServ set +o edwardk
09:54:41 <halvorg> again : (
09:55:56 <artyomkazak> Um, is there a place where I can download all of Hackage in an archive?
09:56:14 <Twey> PatLarsson: Not in general.  You can specify that as a constraint to functions that require it to be true, though.
09:56:48 <xintron> Twey, Been looking at sqlite-simple but persistent-sqlite looks good
09:57:00 <monochrom> hackage is huge. but you can use wget recursively
09:57:41 <Twey> PatLarsson: You can probably specify it for a closed family if you're using 7.8, but for an open family you can't guarantee any properties for the whole family because someone can come along and change the behaviour later by adding new instances
09:57:59 <PatLarsson> Twey: I tried something like  "f :: (G (F t)) ~ t => ..." but does not help
09:58:31 <Twey> artyomkazak: There's even a script, https://github.com/jamwt/mirror-hackage
09:58:39 <monochrom> how to know hackage is huge: so far, only two entities go out of their ways to store all of hackage, and one of them is hackage itself.
09:59:13 <Twey> « Note: expect to devote 10-15GB to your Hackage mirror as of 2012-08 »
09:59:19 <artyomkazak> Twey: I found an archive on old-hackage, it's a “300MB tar file”
09:59:21 <Twey> I don't think that counts as ‘huge’ any more
09:59:50 <Twey> artyomkazak: I tihnk it's a bit bigger now.  ;)
09:59:52 <Twey> think**
09:59:58 <monochrom> but 2012-08 does not count as "recent" either :)
10:00:02 <Twey> I'd estimate somewhere around 30 GiB, conservatively
10:00:41 <monochrom> if it's around 30GB, I admit that I have 1TB of disk personally and could store it.
10:01:16 <monochrom> ok! the time of "I sell hackage on a blu-ray rom" is ripe, I guess
10:02:05 <Twey> Heh
10:02:10 <Twey> The problem is keeping it synced
10:02:37 <monochrom> (do you remember the old days of periodically selling linux distros on CDs?)
10:02:49 <artyomkazak> I don't intend to set up a mirror, just want a snapshot to gather some statistics
10:03:02 <geekosaur> monochrom: wuarchive cdrom :p
10:03:08 <monochrom> yeah!
10:03:11 <geekosaur> (walnut creek, iirc?)
10:04:10 <monochrom> I think wuarchive and walnut creek are distinct, and they were both popular public ftp sites, and periodic CDs containing their collections were sold all the time
10:04:48 <sssilver> how many spaces is it widely accepted to use for indents in Haskell?
10:04:49 <monochrom> I downloaded from them at school circa 1995
10:05:00 <carter> sssilver:  if you remove the -fllvm line from the gloss-raster it should work
10:05:13 <monochrom> the average indentation is 2.773
10:05:34 * monochrom should phrase it more funnily
10:05:47 <monochrom> the average haskell file indents by 2.773 spaces
10:06:24 <monochrom> the average type class comes with 3.314 laws
10:07:15 <ReinH> monochrom: are... are those the actual stats?
10:07:22 <monochrom> no :)
10:07:25 <ReinH> :p
10:07:31 <carter> ReinH: nah, most type classes are a wild wild west
10:07:48 <ReinH> I like 2. I would also accept 4. Indentest thou not 3 excepting that thou then proceedeth to 4.
10:07:50 <carter> ReinH: speaking of power madness, hackage trustees have too much power now :)
10:09:04 <monochrom> they should generalize power to exponentiation and go cartesian-closed
10:09:24 <ReinH> monochrom: there it is
10:10:07 <carter> hahaah
10:11:41 <ReinH> monochrom: it's not the power, it's the application of power. Or something.
10:39:27 <tromp_> anyone1 here have access to a 32+ core machine?
10:51:57 <johanneslippmann> Hey, I have a problem with an instance declaration, could you give me a hint?
10:52:06 <johanneslippmann> Here is a minimal example: http://lpaste.net/100357
10:52:25 <davidfetter_disq> tromp_, they're available for rent on amazon if nothing else comes up handy
10:53:40 <tromp_> thx for tip. i might try that if i don't get offers in next week.
10:54:28 <monochrom> "instance <whatever> => Ord c" does not do what you think. (it is why I don't even care about the <whatever> part.) delete it. just delete it. write Creature instances for each type you want. no other way.
10:57:50 <johanneslippmann> I don't understand.
10:58:45 <Rarrikins> johanneslippmann: Ord c isn't a type.
10:59:00 <johanneslippmann> no, its a class
10:59:11 <Rarrikins> johanneslippmann: Right. c also isn't a type.
10:59:43 <Hafydd_> (It is, but not a very useful type_
10:59:44 <johanneslippmann> I thought it was a type of the class creature.
10:59:52 <Hafydd_> forall c. c
11:00:06 <johanneslippmann> (and Creatures are usefull sometimes)
11:00:11 <Fuuzetsu> how nice of amazon, they give you discounts after you spend $250000 and $2000000
11:00:30 <aspidites> is a type cass even necessary here?
11:01:07 <Rarrikins> johanneslippmann: It's not going to let you do that because of conflicts with two typeclasses.
11:01:10 <aspidites> that is, seems this would do just fine -> dat Creature = Creature { fitness :: Int }
11:01:22 <aspidites> then instance Ord Creature where
11:01:42 <Rarrikins> johanneslippmann: If you were to put an Ord instance for all types in class D, then if something is both in class Creature and D, which instance does it choose?
11:01:45 <monochrom> I don't see how one does not understand the instruction "delete it. just delete it. write Creature instances for each type you want. no other way". I agree that maybe you don't understand why you have to do this. but you have to do this.
11:02:25 <Rarrikins> johanneslippmann: That sort of thing cannot be resolved, and Haskell takes the route of if it can be messed up by a later definition, don't allow it.
11:03:11 <aspidites> or heck, even -> type Fitness = Int; data Creature  Creature Int deriving (Eq, Ord)
11:03:21 <shachaf> monochrom: Do you mean Ord instances?
11:03:47 <johanneslippmann> I don't even have some Data that is an instance of Creature yet.
11:03:50 <monochrom> yes
11:04:45 <johanneslippmann> So I can't make this Data (the Creature) an instance of Ord.
11:05:04 <aspidites> what i'm saying is that creature should be data, not a typeclass
11:06:08 <johanneslippmann> But I don't even know how the creature will be implemented. It is what a class is for: Declare functions for things you don't know.
11:06:30 <aspidites> granted, Im new to haskell, but I don't think that's what typeclasses are for
11:07:02 <johanneslippmann> What are they for then?
11:07:28 <aspidites> the closest OOP analogy to typeclasses might be instances. that is, they implement behavior that is common to *some* related data types that dont relate to all data types
11:07:34 <monochrom> they are for things you know
11:07:52 <aspidites> for instance, integers and floats are all numbers, but not all numbers are ints or floats
11:08:04 <aspidites> no pun intended btw
11:09:03 <spion> isn't the closest analogy interfaces?
11:09:25 <aspidites> spion: typo i meant to say interfaces where i put "might be instances"
11:09:39 <spion> ah ok
11:09:51 <aspidites> reading an article and typing at the same time :P thanks for pointing that out though. otherwise what I said made 0 sense :-)
11:10:10 <aspidites> johanneslippmann: what did you program in before haskell?
11:11:06 <monochrom> I know that I like to compare two integers. I know that I like to compare characters. etc etc. I want to be uniform about that. so I use the Ord class. it is based on knowing. nothing here is unknown.
11:11:27 <aspidites> monochrom: my data example will do that
11:11:53 <monochrom> every bloody line of code you write is because you know. if you don't know, don't write anything. "you do not know what you're writing" applies.
11:12:21 <johanneslippmann> I can write a sort function for every datatype a that is instance of Ord. I don't have to have a clue what a looks like, how it is implemented and what it stands for.
11:12:28 <noob> Hi everyone, hope it's OK to ask questions here...
11:12:39 <iteratee> noob: yes
11:12:41 <noob> Mine is a simple one
11:13:04 <aspidites> johanneslippmann: forgive me if this sounds condescending, but it sounds like what you're saying is "I know what I want to happen, but I'm not sure how I'm supposed to get there" is that close?
11:13:06 <Guest92609> I've only been working with Haskell for a few days so bare with me
11:13:13 <carter> prinsen: also don't just copy and paste the same qusetions sentence every few hours :)
11:13:29 <Rarrikins> Guest92609: This isn't a nudist colony.
11:13:34 <carter> prinsen: its more likel you're just using the API wrong
11:13:35 <carter> :)
11:13:48 <prinsen> carter: Some 13 swedish governments have arranged a hackaton where they open up their data and tells about how to access them
11:13:51 <Guest92609> My problem: function takes argument x. Inside the function, I can't use (floor x/2).
11:13:59 <prinsen> carter: It was an act of desperation, but point taken
11:14:03 <carter> prinsen: no
11:14:08 <carter> an act of laziness
11:14:15 <Rarrikins> Guest92609: Why can't you use it?
11:14:22 <artyomkazak> Guest92609: what type does your function have?
11:14:34 <johanneslippmann> aspidites: Well, I thought I knew how to get there. But ghci doesn't agree, and so are you it seems.
11:14:34 <carter> you should instead say "I'm having trouble getting plugins to work, i'm having trouble loading codes that aren't in Bas"
11:14:36 <carter> e
11:14:43 <Guest92609> I think my problem is types. Not sure how to work with them
11:14:43 <carter> "heres a self contained github repro"
11:14:53 <carter> "please help me understand what i'm doing right or wrong"
11:15:03 <carter> prinsen: Q: have you tried reading the source for plugins?
11:15:08 <Rarrikins> Guest92609: What is the error message?
11:15:09 <carter> i suspect that is what you should do
11:15:09 <geekosaur> I am under the impression plugins is broken currently?
11:15:18 <carter> geekosaur: it is?
11:15:20 <carter> i know nothing
11:15:24 <carter> just that prinsen  has trouble with it
11:15:27 <geekosaur> or at least not compatible with recent ghc, and nobody wants to fix it because the ghc api provides a better way
11:15:35 <carter> oh ok
11:15:36 <geekosaur> (but could use some convenience wrappers)
11:15:39 <carter> prinsen: there yah go
11:15:39 <prinsen> geekosaur: ahh good info
11:15:42 <carter> use Hint or GHC API
11:15:47 <Guest92609> Ok let my type up the error message. Assume I run (function 5).
11:15:51 <johanneslippmann> aspidites: Am I totaly wrong?
11:15:52 <aspidites> so ignoring haskell for a minute, what DO you know about this mysterious creature type? it seems you know you at least want a type that has a fitness, right?
11:16:08 <prinsen> I might dive directly at the GHC API then
11:16:16 <geekosaur> also I think ou need ghc 7.8 to be able to unload a plugin
11:16:21 <geekosaur> via the ghc api
11:16:29 <carter> prinsen: http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/DynamicLoading.html  :)
11:16:30 <Guest92609> No instance for (RealFrac a0)... and... No instance for (Num a0) arising from the literal '5'...
11:16:32 <carter> is an example
11:16:39 <carter> geekosaur: though hint is a bit more fully featured
11:16:46 <geekosaur> but plugins works by grotting around with ghc internals and breaks regularly as a result
11:17:20 <carter> jah
11:17:25 <peteretep> http://lpaste.net/2923149299934035968 -- how can I fix the type errors on this?
11:17:25 <carter> just use the ghci api
11:17:28 <johanneslippmann> aspidites: right. And I want to be able to compare Creatures by there fitness
11:17:28 <carter> you'll learn !
11:17:41 <prinsen> carter: yes :)
11:17:45 <Rarrikins> Guest92609: What's the definition of the function?
11:18:21 <afarmer_> anyone know the CPP to special case something for windows?
11:18:28 <Guest92609> Rarrikins: function s =
11:18:46 <Guest92609> otherFunction(floor x/2)
11:18:58 <Guest92609> Rarrikins: indented underneath
11:19:35 <Rarrikins> Guest92609: What is otherFunction?
11:19:49 <Rarrikins> Guest92609: Please use a pastebin like lpaste.
11:19:59 <Guest92609> Oh ok I will
11:20:26 <Sonder> aford: ifdef WIN32?
11:20:35 <Guest92609> Rarrikins: here's a pastebin: http://lpaste.net/3187543453701505024
11:20:53 <Guest92609> so in makeBinTree is where I call floor on the argument
11:21:01 <aspidites> johanneslippmann: you don't need typeclasses to do that
11:21:19 <aspidites> you need a creature data type that is an instance of Ord and Eq
11:21:55 <Rarrikins> @type (/)
11:21:56 <lambdabot> Fractional a => a -> a -> a
11:22:13 <benneh> aspidites: a typeclass seems like an entirely reasonable way to do that to me
11:22:16 <Rarrikins> Guest92609: (/) takes a Fractional type. You probably have an Integral type. You'll need to convert.
11:22:21 <artyomkazak> @type floor
11:22:22 <lambdabot> (Integral b, RealFrac a) => a -> b
11:22:32 <aspidites> benneh: but its overkill, especially if you don't understand them to begin with
11:22:33 <benneh> you might want lots of different creature types that have nothing in common except that they can have their fitness measured somehow
11:22:53 <aspidites> plus it makes later type signatures more complicated than they need to be
11:22:56 <artyomkazak> Guest92609: you need to convert floor's output to Fractional again before passing it to makeBinTree
11:23:01 <Guest92609> Rarrikins: So I need to convert x to fraction, do floor operation, convert back?
11:23:06 <Guest92609> Rarrikins: ah :)
11:23:13 <aspidites> benneh: especially if you say, through lens into the mix to make navigating them easier
11:23:17 <Rarrikins> Guest92609: Yes, though I think converting back might be unnecessary.
11:23:32 <Rarrikins> Guest92609: floor should return any Integral type you want.
11:24:10 <artyomkazak> ah, yes, I see the original intention was for makeBinTree to take an integral. Sorry for confusing.
11:24:14 <benneh> aspidites: I guess it just depends how different the individual creature types need to be; there might be no feasible way to combine them all into a single type, or there might be
11:24:26 <aspidites> benneh: records
11:24:32 <Guest92609> Rarrikins: Perfect. So I should use fromIntegral when I do floor
11:24:40 <Rarrikins> Guest92609: Yeah, that should work.
11:24:44 <Rarrikins> @type fromIntegral
11:24:44 <lambdabot> (Integral a, Num b) => a -> b
11:24:56 <benneh> johanneslippmann: do you know, in advance, what your creature types are going to look like?
11:25:11 <Guest92609> Rarrikins: Nice let me try that. Also lambdabot is cool didn't know about it
11:25:15 <benneh> if not, then there's really no way to do it without typeclasses, as far as I can see
11:25:33 <aspidites> and besides, given composability, until you know you need something, seems wasteful to start with it
11:25:43 <aspidites> as he stated, he doesn't even know what exactly a creature is
11:26:15 <benneh> there you go then, I don't see how he has any other choice
11:26:24 <johanneslippmann> Well, I hoped to be able to make Creatures very general, so I could try some evolution-stuff on them.
11:26:32 <Rarrikins> johanneslippmann: It's probably best to have a data type which contains the information for various kinds of creatures rather than a typeclass. Otherwise, you can't, say, compare one type of Creature to another, since compare takes two items of the exact same type.
11:27:18 <aspidites> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
11:28:18 <Rarrikins> johanneslippmann: You can do things like data Creature = FlyingCreature Int Int Int; WalkingCreature Int Int or whatever for the various kinds of creatures.
11:28:30 <Rarrikins> johanneslippmann: Sorry, that should be a | rather than ;
11:29:27 <johanneslippmann> I don't see why it is so complicated. Creature and fittness are not very different from Show and show after all. And knowbody knows what the data deriving Show looks like
11:29:29 <Guest92609> @type floor
11:29:29 <lambdabot> (Integral b, RealFrac a) => a -> b
11:29:46 <Guest92609> @type /
11:29:46 <lambdabot> parse error on input `/'
11:29:52 <Guest92609> @type (/)
11:29:53 <lambdabot> Fractional a => a -> a -> a
11:29:59 <johanneslippmann> äh, nobody, not knowbody :D
11:30:26 <benneh> johanneslippmann: I think this is just a difference of preferred style, more than anything else; I see nothing wrong with what you're trying to do
11:30:29 <benneh> others do
11:30:39 <aspidites> benneh: except that it's invalid syntax
11:31:04 <benneh> aspidites: I still don't think there's anything wrong with what he's _trying_ to do
11:32:03 <johanneslippmann> So the question is, is there a way to do it? I don't know what creatures will look like, so I cannot make them Data.
11:32:23 <johanneslippmann> But it would be nice if ghc would agree with my syntax.
11:32:32 <benneh> johanneslippmann: as previously stated, simply make each creature an instance of Ord when you make it an instance of Creature
11:33:54 <navaati> johanneslippmann: remember that code is data in haskell : a data structure can contain functions
11:34:13 <Guest92609> Hey Rarrikins here's  the updated function http://lpaste.net/7283797031120797696
11:34:18 <navaati> (but you can't store it on disk then)
11:34:25 <Guest92609> Rarrikins: http://lpaste.net/7283797031120797696 updated function
11:34:30 <johanneslippmann> thats comlicated. I wouldn't be able to implement a function like findFittest :: (Creature c) => [c] -> [c]
11:34:37 <Guest92609> Rarrikins: might need some more help
11:35:25 <Guest92609> Rarrikins: actually here's the whole thing http://lpaste.net/8593486345270198272
11:35:34 <johanneslippmann> I would have to functions for Data, not Data for functions.
11:36:46 <Guest92609> Rarrikins: Error is: "Could not deduce (Num BinTree) arising from a use of '+'"
11:36:52 <Panos2> Hi
11:36:54 <Guest92609> Am I adding in the wrong spot?
11:39:08 <johanneslippmann> navaati: Is there no Top-down way to do this? Please note that I would accept a "There is non".
11:40:09 <aspidites> johanneslippmann: for the first part of what you were trying to do http://lpaste.net/100359
11:42:14 <Heffalump> does anyone have GHC 7.8.1RC1 i386 (not x86_64) installed on Windows? If so could you try compiling http://lpaste.net/100358 and let me know if the compiler crashes?
11:42:38 <Heffalump> in fact I'd be interested in the same result from any other i386 platform too. It's fine on x86_64 AFAIK.
11:44:31 <johanneslippmann> aspidites: This is fine, but the comparison of monsters is by their name, not by there fittnes: http://lpaste.net/100360
11:44:37 <Earnestly> (Offpoint here, but I doubt you mean "i386", you probably mean ia32 (intel).  i386 is an extremely old cpu that Linux doesn't even support anymore (since 3.8))
11:45:16 <carter> 32bit intel
11:45:22 <Guest92609> Hi everyone I have a question about floor operation and types. Anyone able to help?
11:45:29 <alkabetz> Guest92609: Probably, ask away
11:45:55 <Guest92609> alkabetz: here's my code http://lpaste.net/3871279406588624896
11:47:01 <Guest92609> alkabetz: My error message is on 13:32... Couldn't match expected type "BinTree" with actual type 'BinTree -> BinTree"
11:47:45 <Guest92609> alkabetz: Please please ignore this
11:47:51 <Guest92609> What a dumb mistake!!!
11:47:58 <alkabetz> Guest92609: Haha, no worries
11:48:13 <skypers_> is there a way to group C buffers in a function like  withArrayLen?
11:48:14 <alkabetz> Rubber ducky debugging is a powerful tool :)
11:48:24 <skypers_> like I want two buffers for two lists
11:48:27 <skypers_> withArrays?
11:48:29 <skypers_> something like that?
11:48:51 <Guest92609> alkabetz: But here's my actual question: why can't I call (makeBinTree (s+1) (s-1)) ?
11:49:06 <Guest92609> alkabetz: aka I can't add/subtract one to an argument?
11:49:45 <Guest92609> alkabetz: I get "No instance for (Num BinTree) arising from use of '+' "
11:49:46 <alkabetz> You can definitely add one to / subtract one from an argument.
11:50:06 <alkabetz> So somewhere, the variable you think is a number is actually a BinTree.
11:50:13 <skypers> @hoogle (Storable a) => [[a]] -> ([Ptr a] -> IO b) -> IO b
11:50:14 <lambdabot> No results found
11:50:16 <alkabetz> I fixed the parenthesis problem and it worked for me.
11:50:18 <skypers> onoes :(
11:50:37 <alkabetz> Guest92609: (modulo producing an infinite data structure because your 'makeBinTree' has no base case)
11:50:39 <skypers> I think I’ll have to nest two function calls
11:50:52 <aspidites> johanneslippmann: http://lpaste.net/100361
11:51:12 <Guest92609> alkabetz: Oh... could you explain a bit further?
11:51:25 <alkabetz> Guest92609: About the infinite data structure business?
11:51:53 <Guest92609> alkabetz: specifically how my code isn't handling it properly
11:51:58 <geekosaur> alkabetz: there is no condition where makeBinTree ever produces a value, all possible cases call makeBinTree again
11:52:10 <alkabetz> Guest92609: what geekosaur said
11:52:31 * hackagebot pbc4hs 0.1.1.5 - pbc for HsLua  http://hackage.haskell.org/package/pbc4hs-0.1.1.5 (DavidFeng)
11:53:09 <monochrom> makeBinTree takes 1 parameter only. why are you giving it 2 parameters in "makeBinTree (s+1) (makeBinTree (s-1) )"?
11:53:51 <Guest92609> monochrom: That's a massive typo. Let me update with a new pastebin
11:53:56 <johanneslippmann> aspidites: Thats great. Thank you so much, you saved evolution ;)
11:53:57 <monochrom> ok, next you way, you mean 2 parameters to N. but then it should be N (makeBinTree (s+1)) (makeBinTree (s-1))
11:54:28 <Guest92609> monochrom: Here: http://lpaste.net/8542259978273030144
11:54:34 <Guest92609> alkabetz: see the updated code
11:54:42 <monochrom> it does create a tree of unfathomable depth.
11:54:44 <Guest92609> alkabetz: Same type issues arise
11:55:11 <monochrom> um, "makeBinTree (s+1) (s-1)" is worse
11:55:13 <Guest92609> monochrom: Really? Even with base cases?
11:55:24 <monochrom> ok, with base case it's a finite tree yes
11:56:37 <monochrom> just eat the bullet and write "N (makeBinTree (s+1)) (makeBinTree (s-1))" explicitly. there is no shortcut
11:57:05 <geekosaur> bite the bullet, one hopes. eating it is rather more destructive :p
11:57:16 <monochrom> also, helpMe (s `div` 2)
11:57:57 <monochrom> or helpMe (div s 2) if you don't want the ` notation yet
11:58:14 <Guest92609> monochrom: Nice. Thanks so much. I'll do some testing. :)
12:00:31 <monochrom> I should pick a suitable quotation mark for code and stick with it. and it cannot be " or ' because they are already reserved by code
12:00:47 <monochrom> many years ago kmc and I used « »
12:00:56 <monochrom> but a bit clumsy to type
12:00:59 <Kinnison> Use [[ and ]]
12:01:46 <monochrom> that will work wonderfully with [[f :: [[Int]]]]
12:02:15 <monochrom> perhaps I should be naughty and use “ ”
12:02:24 <Rarrikins> monochrom: Heretic!
12:02:39 <Kinnison> monochrom: oh boo :-(
12:03:13 <alkabetz> monochrom: « and » aren’t too clumsy if you have a Compose key
12:03:50 <monochrom> I am already using compose-<-< for that. I am already feeling clumsy
12:04:08 <monochrom> I bloody need a USB 3.0 port in my head for direct connection to the bloody computer!
12:04:12 <alkabetz> :(
12:04:34 <monochrom> granted, compose-<-< is already the best possible
12:04:48 <t4nk566> I don't know if this fits here but I didn't find any better place to ask it. I'm not sure if I understand all the formalisms around Lambda Calculus. Explained simply, can there be a difference in the result when reducing fully depending on if you reduce normal-order or the other order?
12:05:05 <geekosaur> I've been using ` when no conflict, otherwise ``` (mnemonic: common usage in markdown)
12:05:05 <t4nk566> This is, ignoring infinite loop terms
12:06:18 <t4nk566> Because I am trying to make some kind of lambda reducer in haskell at the moment
12:07:48 <Eduard_Munteanu> Is there a package that defines usual DataKinds-enabled data structures, like length-indexed lists?
12:08:25 <aspidites> benneh: http://lpaste.net/100362
12:08:48 <aspidites> personally  I find that easier to manage and clearer than the typeclasses version
12:09:01 <aspidites> using that, he'd have still had his evolution mechanism
12:09:14 <levi> t4nk566: Generally, yes, normal vs applicative order matters. But not if your terms are all strongly normalizing.
12:10:00 <t4nk566> levi: Is strongly normalizing different from "terminating"?
12:10:26 <monochrom> God, superscript parentheses exist!
12:10:35 <levi> t4nk566: But pure untyped lambda calculus terms are *not*, in general, strongly normalizing. Else they would not be able to represent all computable functions.
12:10:55 <aspidites> and type signatures go from "foo :: Creature Foo a => a -> a" to simply "foo :: Creature"
12:11:23 <levi> t4nk566: They're basically the same thing; "strongly normalizing" is just the native terminology and more precisely describes what's going on.
12:11:39 <aspidites> foo :: Creature -> Creature rather
12:12:58 <haasn> what is “normal form” in the lambda calculus, actually?
12:13:14 <haasn> something that isn't an application?
12:13:40 <prinsen> carter: Hint is working great!
12:13:58 <carter> prinsen: share the code!
12:14:00 <Eduard_Munteanu> haasn: whatever can't be reduced any further, so yeah :)
12:14:14 <prinsen> carter: Ill push to git in sec
12:14:30 <t4nk566> levi: I don't really care for non-terminating terms. So you are basically saying that all terminating terms yield the same result no matter what strategy you use?
12:14:33 <levi> It's basically any term that can't be reduced further through the system's rewrite rules.
12:14:46 <skypers> isn’t a Map a good bifunctor?
12:14:54 <levi> t4nk566: It doesn't matter if you care for them or not. If they are in the formal system, they are in the system.
12:14:54 <skypers> oh
12:14:57 <skypers> yeah, not all
12:15:03 <monochrom> I too disagree with how most OOP teachers teach "you don't know what to do yet, so do the most general thing". (note: I am carefully distinguishing OOP from most OOP teachers.)
12:15:10 <skypers> well I guess it’s indexable
12:15:15 <skypers> is there a typeclass for that?
12:15:19 <Eduard_Munteanu> skypers: Map is more like a profunctor
12:15:28 <skypers> Eduard_Munteanu: huhu :D
12:15:41 <aspidites> monochrom: was that a pun that you didn't generalize OOP teachers in your argument against their teaching of generalization?
12:15:45 <levi> There are variants of the lambda calulus that *are* strongly normalizing; but you haven't made it clear just which lambda calculus you're talking about.
12:15:47 <t4nk566> levi: Oh right, you have to use the right Y-combinator depending on strategy, for example. Right?
12:16:10 <skypers> Eduard_Munteanu: I just want a function like
12:16:13 <monochrom> need I tell you the joke about a math PhD student who did the most general thing without seeing one single concrete example, and therefore ruined his own thesis?
12:16:20 <Eduard_Munteanu> skypers: if you squint at it, Map k v is a bit like k -> Maybe v
12:16:20 <Sornaensis> λ Сalculus 1.0
12:16:24 <monochrom> haha, I didn't realize there is a pun there :)
12:16:25 <skypers> (k -> a -> m b) -> Map k a -> m b
12:16:31 <haasn> Eduard_Munteanu: I'm just confused because in Haskell something that isn't an application (and hence, a constructor or lambda abstraction) is said to be in weak head normal form, no?
12:16:32 <t4nk566> levi: Or is there terms that terminate in both strategies but still give different results?
12:16:52 <haasn> rather than full normal form
12:16:59 <aspidites> monochrom: i'd like to hear the joke. or is it worth it, considering you gave the punch line?
12:17:19 <skypers> Eduard_Munteanu: I’d like something like hm
12:17:21 <levi> t4nk566: If there is a way for a term to be reduced to normal form, the normal order will always reduce it to normal form.
12:17:21 <skypers> a bifold?
12:17:31 <Eduard_Munteanu> haasn: WHNF is basically anything for which the outermost constructor can't be reduced further
12:17:32 <skypers> a BiFoldable?
12:17:36 * hackagebot cabal-bounds 0.1.6 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.6 (DanielTrstenjak)
12:17:40 <skypers> I guess it’s indexable
12:17:53 <Eduard_Munteanu> skypers: what's 'm', is it supposed to be a monad?
12:17:58 <skypers> yes
12:18:05 <levi> t4nk566: The same is not true of applicative order; some terms that reduce to normal form if evaluated via normal order will diverge if evaluated via applicative order.
12:18:28 <monochrom> a PhD student worked on a kind of ring (or monoid, whatever) for his thesis. so, he stated his extra axioms and proved many nice properties. unfortunately, during the defense, an examiner asked, "you do know of a concrete example of your ring (or monoid)?" he had none.
12:18:29 <prinsen> carter: pushed!
12:18:35 <carter> prinsen: link?
12:18:59 <monochrom> the examiner went up to the blackboard and proved that the only ring satisfying his extra axioms is {0}
12:19:01 <prinsen> carter: https://github.com/fabianbergmark/plugins-bug
12:19:19 <skypers> the more I dig in complex types
12:19:24 <aspidites> ha. theory is good in theory, not practice
12:19:29 <skypers> the more I see the need to understand what a profunctor is really
12:19:40 <skypers> I know about the covariant / contravariant stuff
12:19:53 <skypers> but I barely have examples of contravariant functors
12:20:05 <skypers> profunctors are like quatum foam to me :D
12:20:07 <haasn> Eduard_Munteanu: ah, in the lambda calculus normal form refers to beta-reduction, ie. something is said to be in normal form indeed when it is not in the form (x y)
12:20:09 <monochrom> the project of "I don't know what concrete creatures I have yet, but I will write a lot of nice classes with nice properties anyway" will enjoy the same fate.
12:20:14 <t4nk566> levi: So if I'm implementing a reducer, normal order would be my best bet? Am I correct about how it works if I say it first does all the reductions it can on the outermost structures, and only when done with that starts doing reductions on the inner structures?
12:20:36 <haasn> Eduard_Munteanu: I guess the haskell “normal form” refers to a different rewriting rule; WHNF would be the equivalent concept to lambda calculus' normal form, no?
12:20:53 <Eduard_Munteanu> haasn: yeah, beta is rather trivial in plain LC.
12:21:08 <aspidites> i tend to do a lot of refactoring anyway so generally start with "ill implement what works"
12:21:13 <levi> t4nk566: It depends on what your goal is! Straight-up normal order evaluation is highly inefficient to implement.
12:21:22 <Eduard_Munteanu> haasn: normal form would mean something completely forced in Haskell, a-la deepseq.
12:21:29 <aspidites> once the api is stable i'll tag and release a version.
12:21:38 <ocharles> Anyone here got any experience with the `singletons` library? I have a function that requires `SNonEmptyList`, and I have a `NonEmptyList`. I thought I could get access to a singleton of that with `toSing myList` and then pattern matching on it, but I get a scary type error
12:21:39 <haasn> yeah
12:21:42 <t4nk566> levi: Performance means almost nothing to me :)
12:21:47 <aspidites> then the implementation can continue to evolve in the background. in theory anyway
12:22:04 <haasn> Eduard_Munteanu: would Just (\x -> thunk) where thunk is not in WHNF be considered normal form?
12:22:09 <Eduard_Munteanu> haasn: or in Agda, which is strongly normalizing, you can just ask it for the normal form of any term (since computations terminate anyway)
12:22:16 <monochrom> I support generalizations after you have at least two concrete examples.
12:22:29 <aspidites> ocharles: no, but can i have an autograph?
12:22:31 <Eduard_Munteanu> haasn: yes, Just is a constructor.
12:22:36 * hackagebot cabal-bounds 0.1.7 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.7 (DanielTrstenjak)
12:22:41 <levi> t4nk566: What exactly are you trying to implement, though?  Just a toy evaluator to learn about lambda calculus, or are you trying to create something practical?
12:22:49 <japesinator> Is there a good way to define division across Integers, Complex Doubles, Floats, and Rationals?
12:23:05 <Eduard_Munteanu> :t foldrM -- skypers, this?
12:23:06 <lambdabot>     Not in scope: `foldrM'
12:23:06 <lambdabot>     Perhaps you meant one of these:
12:23:06 <lambdabot>       `F.foldrM' (imported from Data.Foldable),
12:23:08 <aspidites> monochrom: right. generalizing when there is only one concrete example tends to create boilerplate, not elliminate it
12:23:11 <Eduard_Munteanu> :t F.foldrM -- skypers, this?
12:23:12 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
12:23:20 <haasn> could I recursively define “normal form” in Haskell as “a value which is in WHNF, and each of its constructor's fields are also in NF”?
12:23:23 <skypers> Eduard_Munteanu: no
12:23:27 <ocharles> https://gist.github.com/ocharles/74cd81df5edae09e7626 That's what I'm battling with at the moment
12:23:33 <Eduard_Munteanu> skypers: do you need the key too?
12:23:36 <skypers> yes
12:23:40 <t4nk566> Yeah, a toy evaluator. I want to do it firstly because I want to understand the LC itself better, and secondly because it's pretty damn cool to see LC programs actually working
12:23:48 <skypers> don’t tell me to use lens please…
12:23:54 <skypers> I know we can do it with _indexed
12:23:54 <Eduard_Munteanu> skypers: for Map in particular it's easy since you can toList it and fold over that
12:23:56 <skypers> or something like that
12:24:06 <skypers> hm
12:24:17 <skypers> I thought there was something simplier
12:24:20 <skypers> but ok
12:24:22 <skypers> it’ll do it
12:24:26 <Eduard_Munteanu> skypers: it is rather simple
12:24:35 <skypers> I mean in term of performances
12:24:57 <Eduard_Munteanu> skypers: the list might fuse away
12:25:02 <triliyn> skypers: as far as profunctors go, the way I think about it is that they're computations that have input(s) and output(s)
12:25:09 <haasn> iirc Map defines its own indexed fold functions
12:25:15 <skypers> triliyn: yeah
12:25:15 <japesinator> Or is there even a practical way of differentiating between Ints and non-Ints?
12:25:17 <levi> t4nk566: Well, normal order evaluation is a reasonable choice then; you might want to optimize via some form of laziness, or you might want to just textually re-write everything. Lambda Calculus is a purely syntactic formalism, so it doesn't really matter.
12:25:29 <Eduard_Munteanu> They're not monadic though.
12:25:36 <skypers> I see contravariant functions as computations with input adaptors
12:25:39 <skypers> functors*
12:25:46 <Eduard_Munteanu> But you could sequence the result.
12:26:06 <t4nk566> levi: I guess LC being a purely syntactic formalism is an evidence that a lot of stuff can be turing complete
12:26:06 <skypers> yeah
12:26:22 <t4nk566> levi: Also, laziness? Isn't normal order essentially laziness?
12:26:28 <skypers> Eduard_Munteanu: I might have already seen a typeclass for indexed stuff with arbitrary index type
12:26:33 <skypers> is it Indexed from lens?
12:26:36 <skypers> or is there anything else?
12:26:42 <Cale> t4nk566: almost
12:26:54 <Cale> t4nk566: Lazy evaluation is normal order + sharing
12:27:00 <Eduard_Munteanu> skypers: yeah, what for though?
12:27:08 <skypers> just curiosity
12:27:19 <skypers> I think it should be extracted from lens
12:27:21 <skypers> :)
12:27:33 <skypers> I’m for little libs
12:27:36 <Cale> t4nk566: i.e. any work done to evaluate a variable should be shared between its occurrences
12:27:43 <skypers> but I know a lot of folks here disagree with that
12:27:47 <t4nk566> Cale: Oh, right. Doesn't sharing require some sort of macro system? Or are you talking about automatically recognizing similar terms?
12:27:51 <Eduard_Munteanu> Lens already depends on a whole bunch of libs :)
12:28:01 <Cale> t4nk566: It's nothing so sophisticated
12:28:03 <skypers> yes I do know that :)
12:28:04 <Eduard_Munteanu> lens, even.
12:28:19 <ocharles> aspidites: an autograph?
12:28:27 <skypers> the thing is, I want to wrap a Map String SomeThing into a newtype
12:28:33 <skypers> and provide some convenient functions
12:28:37 <t4nk566> Cale and levi: I'm not sure what a "variable" in this case is. Are you talking about pure LC without any kind of macro/constant declaration at all?
12:28:41 <aspidites> nvm. celeb status ocharles :P
12:28:46 <ocharles> haha
12:28:46 <Cale> Sure, if you like
12:28:49 <ocharles> hardly :)
12:29:00 <skypers> like getting a list of elements (Map.elems), fmap it (Functor instance) and folding it down with indexed (?)
12:29:07 <Cale> Lazy evaluation makes sense in such a context. Variables are all bound by lambdas in that case
12:30:11 <ocharles> Does Richard Eisenberg ever come here?
12:30:53 <t4nk566> Well, when applying a lambda abstraction term to something else, I would just "find and replace" the variable with the term that is given as an argument. How else would that be done?
12:31:06 <Cale> t4nk566: Let's throw in integers as well, and suppose you have a program like (\x -> x + x) ((\x -> x + x) 5)
12:31:25 <Cale> Then under normal order evaluation, this would reduce like:
12:31:34 <Cale> (\x -> x + x) ((\x -> x + x) 5)
12:31:41 <Cale> -> ((\x -> x + x) 5) + ((\x -> x + x) 5)
12:31:48 <Cale> -> (5 + 5) + ((\x -> x + x) 5)
12:31:54 <Cale> -> 10 + ((\x -> x + x) 5)
12:32:00 <Cale> -> 10 + (5 + 5)
12:32:03 <Cale> -> 10 + 10
12:32:04 <Cale> -> 20
12:32:20 <Cale> But we obviously wasted a bunch of effort recomputing ((\x -> x + x) 5)
12:32:29 <skypers> ok
12:32:35 <skypers> Eduard_Munteanu: mapM f . M.toList
12:32:39 <skypers> it’s almost great
12:32:45 <skypers> oh
12:32:46 <t4nk566> Entirely true, but it feels like trying to "share" that would essentially make the reducer applicative order
12:32:47 <skypers> it’s foldM btw
12:32:49 <skypers> but hm
12:33:01 <skypers> foldM takes a -> b -> a
12:33:02 <Cale> nope, we're still going to evaluate outermost-first
12:33:06 <t4nk566> Or at least make it really hard to stick to normal order
12:33:23 <skypers> I want it to take a -> k -> b -> a
12:33:29 <Cale> But we're going to share any work which is done to evaluate any variable between the copies
12:33:29 <skypers> the first b is actually (k,b')
12:33:37 <skypers> so I might need something like… curry?
12:33:38 <t4nk566> Not entirely understanding this process. Could you do it on the same example
12:33:38 <skypers> uncurry?
12:33:40 <skypers> I never know
12:33:42 <Cale> okay
12:33:56 <t4nk566> And kind of tell me which algorithm you follow
12:33:57 <Cale> So, if you'll allow me to use let/in syntax to represent the sharing
12:34:03 <Cale> (\x -> x + x) ((\x -> x + x) 5)
12:34:16 <Eduard_Munteanu> skypers: you could have it behave as a traversable functor over (k, a), I think.
12:34:28 <skypers> hm
12:34:30 <Cale> -> let x = ((\y -> y + y) 5) in x + x -- still outermost-first (I alpha converted for clarity)
12:34:40 <skypers> yeah, it’s not very convenient to use
12:34:48 <Cale> -> let x = 5 + 5 in x + x
12:34:51 <skypers> I prefer k -> a over (k,a) ->
12:34:53 <Cale> -> let x = 10 in x + x
12:34:58 <Cale> -> 10 + 10
12:34:59 <Cale> -> 20
12:35:44 <Cale> The variables bound by let here may or may not ever be evaluated further
12:36:08 <Cale> In general we'll still just proceed with evaluating the 'in' part
12:36:24 <t4nk566> Cale: Ooh! So implementing this would be pretty easy in Haskell, since Haskell itself is lazy?
12:36:25 <Cale> and only if the things bound by 'let' are really needed will we do any further evaluation
12:36:28 <t4nk566> Because I can just use let itself
12:36:29 <Eduard_Munteanu> skypers: wouldn't be too different from some things in the Arrow interface
12:36:33 <Cale> yeah, sure
12:36:57 <skypers> Eduard_Munteanu: I don’t know Arrows
12:37:59 <t4nk566> Oh well, let me start with actually getting a completely correct normal order implementation without sharing, sharing can be implemented later
12:38:30 <skypers> Eduard_Munteanu: you know what
12:38:32 <levi> t4nk566: It's still not exactly *trivial* to implement. Renaming things can be especially tricky.
12:38:48 <skypers> I’ll just expose a function like fromMyStuff :: MyStuff -> [(String,Stuff)]
12:38:50 <skypers> is not that great
12:38:52 <t4nk566> Should simplify a lot
12:38:53 <t4nk566> So let's say I'm using De Bruijn indices (http://en.wikipedia.org/wiki/De_Bruijn_index)
12:38:53 <skypers> but it’ll do it
12:39:06 <Eduard_Munteanu> skypers: yeah, I was going to ask... why wrap Map?
12:39:09 <skypers> I’ll foldM that later with (String,Stuff)
12:39:22 <skypers> Eduard_Munteanu: because I don’t want to expose the implementation
12:39:53 <skypers> I don’t really the keyword type
12:39:57 <skypers> expect for some stuff
12:39:58 <skypers> like IDs
12:40:06 <skypers> type FooID = Word32
12:40:11 <skypers> it’s okay to me
12:40:12 <t4nk566> levi: Do you have experience with De Bruijn indices?
12:40:33 <levi> t4nk566: A little bit, from a long time ago.
12:40:59 <levi> It's one of those things that's simple in concept, but hard to wrap your head around.
12:41:02 <t4nk566> levi: Curious, is there any better alternative in your opinion?
12:41:55 <Eduard_Munteanu> skypers: might be nice to use an existential in this case and provide a function for lookups... but really, Map isn't a lot more of an implementation detail than a list.
12:41:57 <levi> I know there are alternatives, such as Higher Order Abstract Syntax, but I understand that they have pitfalls of their own. I don't know enough to give any recommendations.
12:41:59 <lemao_> Ola! Curiosity question: I often see discussions about function name collisions, qualified & unqualified imports. Assuming a module A imports two modules B and C and B and C export the same function name but highly likely have different parameter types, could Haskell be smart enough to auto select the right one?
12:42:38 <skypers> 21:40 < Eduard_Munteanu> skypers: might be nice to use an existential in this  case and provide a function for lookups... but really,  Map isn't a lot more of an implementation detail than  a list.
12:42:41 <Eduard_Munteanu> lemao_: no, there have been proposals to do that but so far nothing usable.
12:42:42 <lemao_> in the unlikely case where the names and the parameter types are the same, then qualify the imports
12:42:42 <skypers> yeah, well…
12:42:49 <levi> lemao_: Could be? Perhaps. Is it? No.
12:42:55 <benmachine> I don't think it should be
12:43:04 <levi> I don't think it should be either.
12:43:14 <Eduard_Munteanu> @google haskell type-directed name resolution
12:43:16 <lambdabot> http://www.haskell.org/haskellwiki/TypeDirectedNameResolution
12:43:17 <lambdabot> Title: TypeDirectedNameResolution - HaskellWiki
12:43:17 <t4nk566> levi: Anyway, indices do sound the simplest to me
12:43:19 <lemao_> I seems a bit anti-modular to have to consider the ecosystem before giving a name to a function in a package
12:43:23 <Eduard_Munteanu> lemao_: ^
12:43:29 <benmachine> lemao_: qualified imports, then
12:44:02 <lemao_> benmachine: yes, I know you can qualify it, but still it seems that these name discussion still go on forever
12:44:24 <levi> lemao_: That's the whole point of a module system. Granted, Haskell's module system could have a bit more power, but it suffices to provide disambiguation tools.
12:44:26 <lemao_> Eduard_Munteanu: looking ...
12:44:37 <isaacd> Can we improve the syntax for qualified imports?
12:44:40 <isaacd>   "import qualified Data.Bits as Bits; import Data.Bits ((.|.), (.&.))"
12:44:46 <Eduard_Munteanu> lemao_: a longer term fix might be getting a smarter, more first-class-like module system
12:45:10 <benmachine> yeah we need better modules
12:45:14 <johnw> import qualified Data.Bits as Bits except ((.|.), (.&.))
12:45:17 <johnw> that would be nice
12:45:29 <lemao_> Eduard_Munteanu: how would that be different than TypeDirectedNAmeResolution wrt to resolving names?
12:45:29 <johnw> well, that verb choice is bad
12:45:51 <levi> johnw: You should read the module import documentation. :)
12:45:56 <isaacd> "import Data.Bits qualified as Bits and ((.|.), (.&.))"
12:46:00 <t4nk566> So am I correct that a substitution in term T of variable N with term R would be calculated like this: If T is a variable, just check if the indices are the same, if so return R. Else return T. Substitution in an application would give a new application with both of its terms substituted in the same way. An abstraction would give a new abstraction with its body replaced in exactly the same way, but with N + 1 instead of N
12:46:02 <t4nk566> Does this make sense?
12:46:04 <johnw> oh?  does it allow something like that?
12:46:04 <isaacd> anything along those lines would be lovely
12:46:37 <benmachine> johnw: there is "hiding"
12:46:38 <Eduard_Munteanu> lemao_: you could parametrize modules by the type you operate on.
12:47:12 <levi> johnw: You can hide things, you can import a module multiple times (once with a qualified name, once to import some things un-qualified, etc.)
12:47:25 <benmachine> you can import multiple modules with the same qualified name
12:47:33 <benmachine> = good times
12:47:58 <levi> I see that fairly frequently in the top-level module of some libraries.
12:47:58 <lemao_> Eduard_Munteanu: yes, that would be quite nice. However, but seems like an independent addition to making name resolution a bit more automatic
12:48:29 <levi> You can do the same thing by just putting a bunch of module clauses in your exports, though, AFAICT.
12:48:37 <Eduard_Munteanu> lemao_: Agda has both type-directed name resolution for constructors only and parametrised modules, yeah.
12:48:46 <navaati> hi
12:48:47 <lemao_> I understand that it is possible to qualify, but without a good IDE support it is quite annoying to have to qualify names.
12:49:24 <navaati> i'm using the vector library and i'm having a perf problem, it seems that loop fusion doesn't occur
12:49:41 <navaati> code is here http://navaati.net/depot/Main.hs
12:49:53 <navaati> mem profile is here http://navaati.net/depot/Main.ps
12:50:08 <isaacd> benmachine: it's good that it's possible, but it's much more verbose than most of Haskell, *and* this repetition itself gets repeated at the beginning of many modules
12:50:22 <Eduard_Munteanu> lemao_: although qualification is probably better than making names unique by {pre,ap}pending the type's name :)
12:50:32 <levi> lemao_: Well, qualified module imports are not the most convenient thing in the world while typing in code, but they can make the code more readable in many cases.
12:50:40 <ocharles> carter: took your advice, emailed richard ;)
12:50:56 <navaati> i'd expect the program to only allocate n*8 bytes, at the point between postscanl' and postscanr'
12:50:59 <isaacd> in one codebase, I went with importing unqualified and then using explicit qualification where there's ambiguity
12:51:05 <navaati> but it does a lot more
12:51:09 <isaacd> "import Data.Map as Map"
12:51:15 <Eduard_Munteanu> lemao_: by the way, take a look at ClassyPrelude if you haven't.
12:51:18 <lemao_> Eduard_Munteanu, levi: yes, I see that. But I put this in the same level as why type inference is great
12:51:48 <Eduard_Munteanu> lemao_: it provides you with a bunch of typeclasses if you hate Prelude's monomorphic choices :)
12:51:56 <lemao_> Eduard_Munteanu, levi: I don't need to specify the types: it's inferred. If this is not an inconvenience then I don't see auto selecting the module automatically as an inconvenience
12:52:49 <Eduard_Munteanu> ClassyPrelude sort of does that except it's more trouble for its implementor. :)
12:54:13 <carter> ocharles: about singletons?
12:54:15 <carter> hehe
12:54:23 <carter> did you have a concrete example to share with him?
12:54:37 <lemao_> Eduard_Munteanu: "although qualification is probably better than making names unique by {pre,ap}pending the type's name :)". What about not having to qualify at all (or at least it is your choice)?
12:54:37 <n-dolio> The problem with type-directed name resolution proposals is that the stuff they do isn't part of the type system.
12:54:51 <n-dolio> Because the type system way to handle them is type classes.
12:56:04 <navaati> anyone got an idea of why this memory profile happens ?
12:56:05 <n-dolio> Agda can get away with it for constructors, because you're required to write a type down for all functions.
12:57:05 <n-dolio> In general, you get behavior that is not first-class.
12:57:41 <n-dolio> I have an expression that I can copy and paste to get working behavior, but I cannot give it a name and refer to it in two places and have it work.
12:58:59 <n-dolio> That's true in Agda, too, but people don't care that you can't write definitions that abstract over types with constructors of the same name.
12:59:20 <Eduard_Munteanu> Besides, parametrised modules would be a whole lot more useful. :)
12:59:41 <n-dolio> Yes.
13:00:06 <n-dolio> That's, I think, what isn't gotten in a lot of this discussion.
13:00:16 <n-dolio> ByteString/Text is written like we have parameterized modules.
13:00:25 <ocharles> carter: yea
13:00:34 <n-dolio> I parameterize on a string implementation, and instantiate it with Text.
13:00:49 <n-dolio> But, if we had parameterized modules, I _wouldn't_ use Text qualified, most likely.
13:00:50 <ocharles> carter: https://gist.github.com/ocharles/74cd81df5edae09e7626
13:01:06 <n-dolio> I'd parameterize over string implementation, and work with it unqualified.
13:01:08 <carter> n-dolio: yeah, i agree
13:01:17 <carter> it'd be nice to get module functors
13:01:43 <n-dolio> So designing for qualified imports is the opposite of what I want.
13:01:51 <Eduard_Munteanu> WARNING: no proper quoting around word "functors" :)
13:02:02 <eruk> classes?Hey folks, is lyah correct in stating typeclsses has nothing to do with oop
13:02:12 <n-dolio> Because we don't have the facilities to work with such implementations unqualified.
13:02:27 <Eduard_Munteanu> eruk: mostly, I wouldn't say nothing.
13:03:04 <Eduard_Munteanu> eruk: super/subclassing is similar to subtyping on some level.
13:03:14 <isaacd> typeclasses very loosely correspond to interfaces in OOP
13:03:26 <eruk> Eduard_Munteau : I came across this bit of code ( Asteroids clone that used a typeclass as a class!)
13:03:40 <eruk> tryingto refind it
13:04:29 <Eduard_Munteanu> eruk: perhaps as an abstract class, OOP classes are more like types
13:05:51 <Eduard_Munteanu> Though that's not quite meaningful either.
13:05:51 <Twey> OOP classes are unholy conglomerations of type + constructor + namespace
13:06:24 <Eduard_Munteanu> Yeah, the namespace bit is rather important.
13:07:17 <Eduard_Munteanu> I think there's more to attribute to namespacing than to polymorphism, at least more than the initial impression.
13:08:51 <Eduard_Munteanu> Since you're basically overloaded in the object type, all other overloading happens externally.
13:10:45 <eruk> Eduard_Munteau : http://www.cse.chalmers.se/~patrikj/poly/others/geneticalgorithmsinhaskellwithpolytypicprogramming.ps.gz
13:11:00 <Hafydd_> Why does the definition of plus10 result in a type error, while those of plus2 and plus6 do not? http://lpaste.net/100363
13:11:13 <jle`> is there an unsafe-family method to forcibly unwrap a newtype?
13:11:22 <eruk> Eduard_Munteau : wasn't a asteroid clone , more likegenetic algol
13:11:33 <Eduard_Munteanu> jle`: unsafeCoerce?
13:11:34 <jle`> unsafeCoerce?
13:11:39 <jle`> ah
13:11:45 <jle`> I suspected so
13:12:15 <jle`> darn annoyingly unexported constructors
13:13:37 <jle`> Eduard_Munteanu: thanks :)
13:16:50 <skypers> http://fr.wikipedia.org/wiki/RMI_(java)
13:16:53 * skypers throws up
13:17:40 <Eduard_Munteanu> Hafydd_: it picks '(Num a) => Plus5 a' and checks it sooner because of OverlappingInstances, I think
13:17:56 <lemao_> n-dolio: "problem with type-directed name resolution proposals is that the stuff they do isn't part of the type system" I don't fully follow you here.
13:18:44 <NumberMan> Hi everyone!
13:18:50 <NumberMan> Anyone able to help me?
13:18:58 <NumberMan> Very new to Haskell here
13:19:03 <Cale> Probably!
13:19:05 <levi> NumberMan: Don't ask to ask, just ask! :)
13:19:05 <NumberMan> How do I check if a number is odd or even?
13:19:10 <Cale> :t even
13:19:11 <lambdabot> Integral a => a -> Bool
13:19:15 <bernalex> :t odd
13:19:15 <Cale> > even 5
13:19:15 <lambdabot> Integral a => a -> Bool
13:19:16 <lambdabot>  False
13:19:20 <Eduard_Munteanu> Hafydd_: note plus6 would still give you an error when you actually use it
13:19:21 <bernalex> > odd 5
13:19:22 <lambdabot>  True
13:19:23 <bernalex> :-)
13:19:31 <Cale> There's also mod
13:19:35 <Cale> > mod 5 2
13:19:36 <lambdabot>  1
13:19:40 <Cale> > 5 `mod` 2
13:19:41 <lambdabot>  1
13:19:47 <Eduard_Munteanu> Hafydd_: unless you add a suitable instance, that is
13:19:51 <NumberMan> Oh cool! Exactly what I need!
13:19:56 <NumberMan> Mod is perfect
13:20:02 <nh2> does anybody know how I can turn a C constant to a CInt with c2hs?
13:20:03 <NumberMan> > 5 'mod' 2
13:20:05 <lambdabot>  Syntax error on 'mod'
13:20:05 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
13:20:05 <Hafydd_> Eduard_Munteanu: it works for Num instances.
13:20:12 <Cale> Those are backticks
13:20:16 <NumberMan> What are those symbols for 'mod'?
13:20:18 <bernalex> NumberMan: it's ` not '
13:20:22 <Eduard_Munteanu> Hafydd_: sure... but if you don't give it a Num, it fails like plus10
13:20:27 <NumberMan> Oooh
13:20:33 <NumberMan> > 5 `mod` 2
13:20:34 <lambdabot>  1
13:20:37 <bernalex> NumberMan: ` is not a symbol for mod explicitly, it's for calling functions infix in general.
13:20:38 <NumberMan> Perfect!
13:20:39 <nh2> I have it a #define ERR -1 and I want to get myErr :: CInt; myErr = ERR with ch2s
13:20:39 <bernalex> @lyah
13:20:40 <lambdabot> Unknown command, try @list
13:20:46 <Hafydd_> Eduard_Munteanu: it works for (undefined :: Void), too.
13:20:47 <bernalex> oh
13:20:49 <NumberMan> Thanks you guyf!!!!
13:20:52 <NumberMan> guys*
13:20:57 <bernalex> NumberMan: check out http://learnyouahaskell.com/
13:21:01 <Eduard_Munteanu> Hafydd_: sure, because your Void instance doesn't need Num
13:21:15 <Hafydd_> Eduard_Munteanu: in what circumstances would it not work, then?
13:21:16 <NumberMan> bernalex: Will do! Thank you.
13:21:49 <Eduard_Munteanu> Hafydd_: if you give it any type that's not a Num and not Void.
13:22:06 <Hafydd_> Eduard_Munteanu: that's hardly surprising, given that its type signature explicitly says that.
13:22:14 <Eduard_Munteanu> Hafydd_: it does?
13:22:55 <WraithM> Hi everyone, I'm working on a little prototype program with a free monad, and I'm not thinking correctly about what I'm trying to do. I have a type error, and I was wondering if I could get some help. http://lpaste.net/100365
13:22:57 <Eduard_Munteanu> Hafydd_: note instance resolution happens at the use site, not where you define the method.
13:23:10 <Hafydd_> Eduard_Munteanu: well, implicitly, I suppose. Anyway, that's intentional.
13:23:39 <Eduard_Munteanu> Hafydd_: whenever you supply e.g. a monomorphic type to plus6, that's when it looks for instances of Plus3.
13:27:38 <Hafydd_> Eduard_Munteanu: do you know what it is about the particular form used to define plus10 that causes that to happen, which is absent in plus2, and how might I fix it so I can define recursive function like that?
13:27:42 <Hafydd_> Sb e
13:28:06 <Eduard_Munteanu> WraithM: the 'g' in Get's type isn't properly quantified I think, you need an explicit forall in the first argument parens
13:29:23 <Eduard_Munteanu> Hafydd_: perhaps there are other instances of Plus1 that you haven't pasted?
13:29:29 <WraithM> you mean: Get :: (forall b. Gettable g => g -> b) -> (b -> a) -> ScriptF a
13:29:38 <Eduard_Munteanu> WraithM: yes
13:29:42 <Eduard_Munteanu> Er, no
13:29:50 <Eduard_Munteanu> WraithM: forall g
13:29:53 <WraithM> Ahh
13:30:02 <n-dolio> lemao_: I mean if you have two imports of 'foo', some expression involving 'foo' does not have a type that unifies the two if possible.
13:30:05 <Hafydd_> Eduard_Munteanu: there aren't. I'd like to be able to write code that type-checks properly when there's only the Num a => instance.
13:30:34 <Hafydd_> Or at least to know why I can't.
13:30:37 <WraithM> Eduard_Munteanu: That did it!
13:30:38 <Eduard_Munteanu> Hafydd_: move the constraint to the class declaration?
13:30:41 <WraithM> Thank you :)
13:30:52 <Hafydd_> Eduard_Munteanu: I want to be able to add more specific instances, later.
13:31:06 <n-dolio> It can at best have some ad-hoc choice between the two foos.
13:31:20 <WraithM> Yeah, I think I incorrectly assumed that the GADT would properly quantify that
13:31:28 <Hafydd_> Or to allow other users importing the module to do so.
13:31:42 <Eduard_Munteanu> WraithM: it quantifies it in the outer scope, like in function types
13:31:48 <WraithM> Right, exactly
13:32:03 <Eduard_Munteanu> Hafydd_: you should really use newtype wrappers then, not OverlappingInstances
13:32:40 <Hafydd_> Perhaps; but I seek the know the limitations of this approach.
13:32:50 <Hafydd_> *to
13:33:04 <Eduard_Munteanu> Hafydd_: newtype ByNum a = ByNum a    instance (Num a) => Plus5 (ByNum a) ...
13:33:25 <n-dolio> Because modules are not part of the type system.
13:33:52 <Eduard_Munteanu> Hafydd_: it makes it rather impossible to reason about your instances sanely... adding/removing instances can silently break code in unrelated parts of your code.
13:34:58 <Eduard_Munteanu> Hafydd_: it's pretty much a bad idea unless your typeclass is "closed", i.e. you make sure you define all instances in one place
13:35:55 <enthropy> removing instances which are not overlapping is still likely to break things
13:36:30 <enthropy> the aversion should be that "adding an import can change how code evaluates, which compiled just fine before"
13:36:57 <Eduard_Munteanu> Or worse, it could continue to compile fine but fail in really unexpected ways.
13:37:33 <Eduard_Munteanu> Pretty much as if you defined a function for which anyone could add clauses, anywhere, in any particular order with respect to the other ones. :)
13:38:04 <Hafydd_> No doubt.
13:38:15 <enthropy> the ordering is defined
13:38:28 <enthropy> it's not like overlapping instances means "pick an instance at random"
13:38:50 <Hafydd_> That still does not explain my error, though.
13:39:39 <Eduard_Munteanu> Hafydd_: said error would appear at the call site of your other functions
13:39:50 <syao> good day Haskellers! ^^
13:39:56 * Eduard_Munteanu has to go AFK a bit
13:39:58 <c_wraith> I still think haskell could allow local data types to be defined, so long those types didn't escape the context.
13:41:34 <Eduard_Munteanu> c_wraith: or you could turn them into CPS-ed existentials in outer scopes, maybe
13:47:11 <aavogt> Hafydd_: my guess is that ghc doesn't treat the instance as if it was overlapping when you compile with -XOverlappingInstances unnecessarily
13:47:37 <aavogt> so that Plus5 instance matches
13:47:42 <t4nk566> Can anyone spot the error in this code?
13:47:43 <aavogt> and then it can't satisfy the constraint
13:47:44 <t4nk566> http://lpaste.net/9148322839181393920
13:48:21 <t4nk566> When I "manually reduce stuff" applicative order, it works. But it doesn't quite work when doing it by itself in normal order
13:49:52 <milfjord> that's just some definitions
13:49:52 <nh2> anybody around who knows c2hs?
13:50:12 <milfjord> also you're using otherwise wrong
13:50:51 <t4nk566> Yeah I'm implying that by "running" the reducer, I run the function reduce on an expression. How am I using otherwise wrong?
13:51:10 <milfjord> @src otherwise
13:51:10 <lambdabot> otherwise = True
13:51:58 <t4nk566> Oh, right, I should use _ instead?
13:52:02 <milfjord> yeah
13:52:21 <t4nk566> Wait, how did that even run
13:52:32 <t4nk566> Wouldn't I get an undefined value from that code?
13:52:38 <milfjord> it created a local variable called 'otherwise'
13:52:46 <milfjord> > case 2 + 2 of otherwise -> otherwise
13:52:47 <lambdabot>  4
13:52:53 <t4nk566> ooh haha, so it accidentally still worked
13:53:46 <skypers> runStateT over foldM is so convenient <3
13:53:52 <t4nk566> Still not sure what's wrong with it
13:54:03 <milfjord> me neither
13:54:07 <milfjord> what's the problem?
13:55:37 <aavogt> nh2: sure
13:56:04 <nh2> aavogt: how do I get a damn single macro out? :)
13:56:19 <t4nk566> milfjord: With these definitions: http://lpaste.net/3066120557830340608
13:56:22 <aavogt> did you try enum define stuff?
13:56:33 <nh2> aavogt: my library does `#define FOO -1` and I want to get `foo :: Cint; foo = FOO`
13:56:34 <t4nk566> reduce $ App (App mult two) two evaluates to Abs (Abs (App (Var 1) (App (Var 1) (App (Var 1) (App (Var 1) (Var 0)))))) which is true
13:56:45 <parc> are there any reasonably well organized lists of mature haskell projects? right now i'm just looking for whats popular on github/other sites
13:57:06 <t4nk566> milfjord: Wait, haha, nevermind!
13:57:10 <nh2> aavogt: so basically I just want to assign that define to a toplevel Haskell constant
13:57:12 <t4nk566> milfjord: I fixed it!
13:57:48 * hackagebot mime 0.4.0.1 - Working with MIME types.  http://hackage.haskell.org/package/mime-0.4.0.1 (IavorDiatchki)
13:59:00 <nh2> aavogt: the paper hints at doing this with a "Wrapping" enum and then doing whatever complicated stuff, but I imagine there must be a simple solution
13:59:25 <milfjord> have you tried hsc2hs?
13:59:47 <nh2> milfjord: yes, but this is not my project, and it uses c2hs extensively
13:59:52 <Twey> Hafydd_: Rewriting plus10 = plus5 . plus5  seems to make it work.  I have no idea why.  :-D
14:01:19 <Twey> Hafydd_: plus10 x = (plus5 . plus5) x  is also fine; it seems to be just the let for some reason
14:01:35 <mietek> hm
14:01:44 <mietek> port <- (read <$> getEnv "PORT") `catch` const (return 8001)
14:01:50 <skypers> > maxBound (undefined :: Int)
14:01:51 <lambdabot>  No instance for (GHC.Show.Show a0)
14:01:51 <lambdabot>    arising from a use of `M438869377023711497727224.show_M4388693770237114977...
14:01:51 <lambdabot>  The type variable `a0' is ambiguous
14:01:51 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
14:01:51 <lambdabot>  Note: there are several potential instances:
14:02:09 <mietek> It seems my use of catch is ambiguous in the type of the exception
14:02:13 <skypers> > maxBound :: Int
14:02:14 <lambdabot>  9223372036854775807
14:02:18 <skypers> holy
14:02:27 <skypers> > maxBound CInt
14:02:27 <nh2> it's over 9000
14:02:28 <lambdabot>  Not in scope: data constructor `CInt'
14:02:30 <skypers> > maxBound :: CInt
14:02:31 <lambdabot>  Not in scope: type constructor or class `CInt'
14:02:31 <lambdabot>  Perhaps you meant one of these:
14:02:31 <lambdabot>    `Int' (imported from Data.Int),
14:02:31 <lambdabot>    `Cont' (imported from Control.Monad.Cont)
14:02:34 <dagle> > (maxBound :: Int) + 1
14:02:35 <lambdabot>  -9223372036854775808
14:02:38 <dagle> :)
14:02:51 <skypers> > maxBound :: Int8
14:02:52 <lambdabot>  127
14:02:53 <milfjord> > maxBound
14:02:54 <lambdabot>  ()
14:02:57 <skypers> > maxBound :: Int64
14:02:58 <lambdabot>  9223372036854775807
14:03:03 <skypers> > maxBound :: Int32
14:03:04 <lambdabot>  2147483647
14:03:18 <skypers> what isok
14:03:20 <geekosaur> > maxBound :: Foreign.C.Types.CInt
14:03:20 <skypers> ok*
14:03:21 <lambdabot>  Not in scope: type constructor or class `Foreign.C.Types.CInt'
14:03:24 <geekosaur> bah
14:03:24 <skypers> this is CInt
14:03:27 <skypers> Int32
14:03:34 <aavogt> nh2: there are {# enum define .. #} things implemented
14:03:34 <geekosaur> on some platforms
14:03:41 <skypers> yeah, most of them now
14:04:56 <mietek> Any idea how to catch all exceptions?
14:05:21 <nh2> aavogt: I don't really understand them and they look 10 times more complicated
14:05:28 <milfjord> mietek: why? the code is broken anyway
14:05:37 <mietek> milfjord: pardon?
14:05:51 <milfjord> mietek: if the environment variable is a non-numeric string, it'll blow up
14:06:05 <Twey> :t catch
14:06:05 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
14:06:58 <Twey> mietek: foo `catch` \_ -> bar -- should do it, I think
14:07:09 <Twey> But you shouldn't do that, for all the usual reasons
14:07:11 <mietek> Twey:
14:07:13 <mietek> port <- (read <$> getEnv "PORT") `catch` const (return 8001)
14:07:22 <skypers> 23:03 < mietek> Any idea how to catch all exceptions?
14:07:23 <mietek> No instance for (GHC.Exception.Exception e0) arising from a use of `catch'
14:07:31 <skypers> catch with SomeException
14:07:39 <skypers> it’s an existential type for all exceptions :)
14:07:57 <skypers> 23:05 < Twey> mietek: foo `catch` \_ -> bar -- should do it, I think
14:08:00 <skypers> it won’t work
14:08:01 <milfjord> export PORT=foo
14:08:06 <milfjord> bang
14:08:17 <skypers> it doesn’t know which extension to look for
14:08:24 <mietek> milfjord: I'm not trying to defend against user error
14:08:26 <skypers> exception*
14:09:07 <milfjord> mietek: so why exactly are you trying to catch all exceptions?
14:09:36 <mietek> Ideally, I'd take a getEnvOrDefault function
14:09:44 <dagle> Because sometimes the only thing to do is: success or fail. Nothing in between.
14:09:52 <milfjord> mietek: there is one in System.Posix.Env
14:10:23 <mietek> Oh indeed.  Thanks!
14:17:50 * hackagebot process-streaming 0.0.1.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.0.1.1 (DanielDiazCarrete)
14:19:39 <jroesch_c> edwardk: any reason why you avoid sandboxes?
14:20:03 <edwardk> because given the nature of what i write and how i write it, i just never feel the pain everyone sandboxes for
14:24:50 <monochrom> I don't have multiple projects with differing dependency requirements. so I don't sandbox them either.
14:26:08 <monochrom> so far, my most frequent use of sandboxing is when someone claims a cabal-hell problem and I try to reproduce it
14:26:48 <monochrom> the second most frequent use is one in a while I build a new cabal-install but don't want to pollute my existing libraries
14:30:24 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/109231/ is proof that multiple versions of Cabal is harmful. to upgrade cabal-install you must use a sandbox
14:32:17 <greg`> hmmm i would recommend sandboxes as good practise though
14:32:26 <johnw> i use them a lot too
14:32:35 <greg`> not that im anybody
14:32:51 <monochrom> oh yes, if I were more active, I would have to sandbox more
14:33:37 <jroesch_c> edwardk: fair enough the only things that have ever given me pain are building larger projects like yesod/agda/idris. I've just picked up the habit of sandboxing everything just to avoid future headaches.
14:34:10 <adelbertc> i tend to sandbox anything that's an executable (idris, hakyll, ghc-mod)
14:34:25 <adelbertc> though i learned happy and alex don't like being sandboxed
14:34:30 <adelbertc> at least not easily
14:34:39 <greg`> its like explained in the "expert beginner" article, if you dont follow best ptactise u can only get so far
14:34:50 <jrmithdobbs> sandboxes are less useful once dynamic linking is turned on tbqh
14:35:23 <jroesch_c> jrmithdobbs: true, but a lot of what I'm doing right now has to be statically linked anyways
14:35:40 <jrmithdobbs> jroesch_c: because you like lgpl3?
14:35:56 <jrmithdobbs> jroesch_c: assuming you're not building with simple-math, anyways
14:35:59 <Feuerbach> jrmithdobbs: what's the issue with dynamic linking?
14:36:19 <thoughtpolice> edwardk: honestly, i'm in the same boat I think. I rarely sandbox much anymore, and if I do, I tend to just use Nix instead now, since it's more of an Uber sandbox than just the Cabal one.
14:36:47 <edwardk> jroesch_c: i tend not to build those =)
14:37:03 <edwardk> jroesch: if i'm adventurous i'll install part of warp and some websockets ;)
14:37:08 <edwardk> thats pretty application-y for me ;)
14:38:43 <jroesch_c> jrmithdobbs: running code on a super computer and we have a build system that builds a single executable and then moves it to the target machine before we run, and they don't have GHC installed and there is no chance of us convincing them to do that
14:38:44 <greg`> i recently followed a blog post by tim dysinger for setting up emacs haskell
14:39:17 <jrmithdobbs> jroesch_c: well, if that group counts as distributing (depending on org layout) all your code is lgpl3 now, fun huh?
14:39:29 <greg`> v. good setup instructions
14:40:21 <jroesch_c> jrmithdobbs: yeah, luckily we are doing this as an academic exercise and I doubt anyone is going to hound us about licensing
14:40:48 <greg`> johnw: does haskell ide use HaRe at all?
14:42:11 <thoughtpolice> jrmithdobbs: the binary distribution of GHC dynamically links to GMP, today and tomorrow. the static/dynamic dichotomy is squarely about Haskell code - we have always linked to an external GMP (the binary distributions do this for example, and policies in package managers tend to dictate similarly)
14:43:01 <jroesch_c> edwardk: yeah I also avoid most application-y things, I was helping someone else build Yesod yesterday (part of trying to get other people to write more Haskell means I the one people come to with cabal build issues, and people who have globally installed many packages tend to have a hard time getting things like Yesod to build, esp. when they are new to the
14:43:01 <jroesch_c> Haskell ecosystem)
14:43:38 <jrmithdobbs> thoughtpolice: yes but if you distribute a static binary built without simple-math the gmp link becomes static not dynamic so you can't distribute non-simple-math haskell static binaries that are not lgpl3 right now, afaict
14:44:12 <jrmithdobbs> thoughtpolice: none of it matters unless you distribute, of course.
14:44:16 <thoughtpolice> er, no. if you build a static binary - which is the default in GHC - the resulting executable is still dynamically linked to GMP. a result of this that binary *does* need GMP on the system. it always links dynamically.
14:44:51 <joehillen> I thought you can statically link to lgpl3. Isn't that allowed by the license?
14:45:06 <Clint> joehillen: as long as you comply with the license terms
14:45:31 <joehillen> it's only if you modify lgpl3 code and then distribute that you need to distribute your modifications
14:45:54 <joehillen> Clint: I mean without licensing your own code under the l/gpl3
14:47:06 <Clint> joehillen: it is possible to do that as long as the license terms are followed
14:47:12 <edwardk> jroesch: if you want to work with yesod and anything else either get really comfortable using --force, or sandbox ;)
14:47:16 <thoughtpolice> jrmithdobbs: e.g. if you compile a 'hello world' application, it'll link to, for example, /usr/lib/x86_64-linux-gnu/libgmp.so.10 (on my system). -dynamic in GHC only affects Haskell code - it does not affect C code, to which we already tend to link to dynamically. 'dynamic Haskell binaries' means instead that there is a dynamic dependency on shared objects for haskell libraries, e.g. a dependency like 'libHSattoparsec-<VERSION>.so'
14:48:04 <jrmithdobbs> thoughtpolice: erm, i just did a cabal configure --disable-executable-dynamic --disable-shared --enable-executable-profiling and gmp is not one of the linked libs after building
14:48:44 <thoughtpolice> jrmithdobbs: what platform?
14:49:26 <jrmithdobbs> thoughtpolice: os x
14:49:50 <thoughtpolice> where's the binary dist from? like, homebrew?
14:50:13 <jrmithdobbs> not using a binary dist but a default build of 7.8 tip
14:50:24 <benbangert> anyone using SublimeHaskell know how to add a cabal sandbox to the module doc search for autocomplete?
14:50:49 <jrmithdobbs> it's linked against a homebrew installed libgmp in /usr/local though
14:51:04 <joehillen> the lgpl3 doesn't distinguish between static and dynamic linking. Here is the relevant part: Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version.
14:51:11 <joehillen> https://www.gnu.org/copyleft/lesser.html
14:52:21 <jrmithdobbs> joehillen: yes well, that description's semantics clearly contradicts itself since a) isn't ever actually done with static linking
14:52:30 <thoughtpolice> jrmithdobbs: OK, so what's the problem? the actual integer-gmp Haskell source code is BSD licensed. it's fine to link statically to that. and your application is dynamically linked to homebrew's libgmp, which is how it should work. am I missing something here? (or not understanding)?
14:52:48 <jrmithdobbs> thoughtpolice: it's not dynamically linked to libgmp.
14:52:56 <jrmithdobbs> thoughtpolice: otool -L shows no link
14:53:15 <thoughtpolice> i'm confused by this bit then: 16:49 < jrmithdobbs> it's linked against a homebrew installed libgmp in /usr/local though
14:53:25 <thoughtpolice> or do you mean GHC itself?
14:53:26 <jrmithdobbs> thoughtpolice: the ghc build
14:53:28 <jrmithdobbs> ya
14:55:57 <jrmithdobbs> thoughtpolice: eg, on the ghc binary this is shown with otool: @rpath/libHSinteger-gmp-0.5.1.0-ghc7.7.20140204.dylib (compatibility version 0.0.0, current version 0.0.0)
14:57:00 <thoughtpolice> hm, this sounds like a bug, but my new Mavericks machine doesn't actually have GMP installed.
14:57:04 * thoughtpolice installs gmp and tries a build
14:57:08 <Peaker> is there a nice way to debug where forkIO'd threads are stuck?
14:57:10 <jrmithdobbs> thoughtpolice: oh hmm, it looks like on os x my build script ignored my gmp install and built it's own?!
14:57:18 <jrmithdobbs> looking closer
14:57:57 <jrmithdobbs> so ya, that means it's building executables with gmp included and so you're distributing gmp with your code so what I said seems to hold ...
14:58:05 <bennofs> For storable instances, should sizeOf (undefined :: s) always be a multiple of alignment (undefined :: s) ?
14:59:03 <thoughtpolice> jrmithdobbs: then yes, that's a bug. it's possible the in-tree GMP build is slightly broke (there are a few bugs for it right now), although i can't remember one for not dynamically linking the .so
14:59:34 <jrmithdobbs> thoughtpolice: i'll futz with it more next time i update (don't have time this week to wait for all that to rebuild atm ;p)
15:00:13 <jrmithdobbs> tbqh, i'm more looking forward to the simple-math revamp i heard rumor of for 7.10 anyways ;p
15:01:54 <thoughtpolice> Linux, of course, works properly. but Linux has never really been the problem here. an OpenSSL based integer backend would be interesting
15:02:08 <thoughtpolice> or one just based on libtommath or whatever, which would make all of it go away.
15:02:37 <m3ga> hmm, i'm actually working on a pure haskell integer implementation.
15:02:40 <jrmithdobbs> well seeing as openssl is being deprecated in os x i don't know that switching to BN (which is fairly slow anyhow) is much use
15:03:45 <thoughtpolice> m3ga: i still think the actual Right Thing is just to make the integer implementation a link time option, like threaded vs non-threaded. but i don't know how to do that.
15:04:06 <m3ga> sure, that makes sense
15:04:07 <thoughtpolice> or at least, i haven't given it a huge amount of thought
15:04:30 <monochrom> will openssl-based integer backend send all your boring euler project attempts to NSA? :)
15:06:49 <johnw> likely
15:07:47 <thoughtpolice> monochrom: given the things inside OpenSSL, it's more likely to just not work or something.
15:08:22 <monochrom> haha
15:09:07 <monochrom> ok, so it's more like "hi, why does my code says that 3 is a composite number equal to 2*5?" :)
15:09:26 <sipa> mod 7, probably
15:09:44 <monochrom> good call! :)
15:13:20 <dleedev> hi, I've read that the powerful type system in Haskell precludes a wide category of bugs
15:13:38 <dleedev> what are some category of bugs that DO often show up in Haskell?
15:13:41 <sipa> @faq Can haskell prevent typos?
15:13:42 <lambdabot> The answer is: Yes! Haskell can do that.
15:14:28 <m3ga> dleedev: the haskell type system allows you to encode invariants so that potential bugs become compile time errors
15:14:56 <dleedev> I should have been clearer: *runtime bugs*
15:15:15 <joehillen> dleedev: also incomplete pattern matches and forgetting to handle all possible outputs
15:15:29 <joehillen> that's my favorite thing haskell catches
15:15:48 <m3ga> dleedev: non-total functions (like head of an empty list)
15:15:49 <milfjord> is everyone just ignoring the question?
15:16:12 <dleedev> non-total functions == incomplete pattern matches, right?
15:16:19 <hpc> dleedev: also the very large category of logic bugs, like incorrectly picking weaker encryption options when a good one is available
15:16:36 <monochrom> here is a possible requirement: "for all c, f 3 c should equal [c, c, c]". here is a possible bug: f 3 'x' equals ['x', 'x', 'x'], but f 3 True = [True]. if f's type is Int -> a -> [a], that bug does not happen.
15:16:36 <S11001001> dleedev: and infinite loops
15:16:38 <milfjord> space leaks
15:16:45 <joehillen> dleedev: yes, there is not type level protect for head of empty list. You need dependent-types for that
15:16:50 <hpc> or RNGs that have issues with their distribution making them not true random
15:17:31 <hpc> forgetting to close resources (subtly different from "space leaks", but relatively fixable with withFoo)
15:17:48 <dleedev> monochrom: how does that bug not happen?
15:18:08 <hpc> also concurrency issues; in a large concurrent system you can starve some threads of execution
15:18:14 <hpc> or lock them in transactions that fail repeatedly
15:18:16 <SrPx> Hello, quick question, is stream fusion implemented for the standard lists ?
15:18:31 <hpc> dleedev: in short, the type system prevents "obvious" bugs ;)
15:18:50 <milfjord> dleedev: how could it?
15:19:00 <milfjord> dleedev: I mean, try to write f
15:19:03 <hpc> dleedev: and the goal of people who do type system research is to expand the frontier of obviousness
15:19:22 <monochrom> the type "a -> [a]" forbids you from trying "if that's Char, do one thing; if that's Bool, do a different thing". you can only do uniform things.
15:19:38 <mietek> Does Scotty want a threaded runtime?
15:19:56 <dleedev> monochrom: Ah, I see
15:19:59 <monochrom> for very technical and mathy details, look for "parametricity" and "Wadler theorems for free"
15:20:52 <milfjord> @where theorems
15:20:52 <lambdabot> I know nothing about theorems.
15:21:14 <dleedev> I was looking for an answer more along the lines of "space leaks"
15:21:16 <davidfetter_disq> o/` millions of theorems // theorems for me o/`
15:21:37 <davidfetter_disq> o/` millions of theorems // theorems for free o/`
15:21:40 <skypers> night
15:21:44 <dleedev> something that's quite unique lazy languages
15:22:03 <hpc> dleedev: well, now you are asking about two different things
15:22:07 <hpc> type systems and laziness
15:22:18 <khyperia> accidentally using foldl instead of foldl' on a huge list? Stuff like that?
15:22:37 <hpc> dleedev: also space leaks are not unique to lazy languages
15:22:48 <dleedev> hpc: yeah, I shouldn't have prefaced my original question with the phrase about type saftey
15:22:58 * hackagebot clckwrks-plugin-ircbot 0.6.9 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.9 (JeremyShaw)
15:23:11 <dleedev> khyperia: yeah, something like that
15:23:39 <Twey> dleedev: Haskell's type system does *not* check for space usage, time usage, or termination.  So those show up sometimes.  Also protocol violations (we can encode session types, but they're currently awkward due to a lack of syntax for indexed monads).
15:23:47 <dleedev> basically, I haven't done large projects with Haskell, so I was hoping to hear about scars and bruises from real-world experiences
15:24:13 <dleedev> real-life experiences
15:25:07 <Twey> dleedev: Also all the usual bugs one expects from impure code can still happen in IO; many of them are preventable with sufficiently sophisticated types, but few libraries make full use of the type system, so some partial code can slip through
15:25:12 <dleedev> is it much more difficult to take "space usage, time usage, or termination" into consideration with Haskell? Or is it pretty much the same as any other language?
15:25:27 <Twey> dleedev: Opinions vary.
15:26:24 <Twey> Termination is no harder than usual, but because of laziness it can rear its head in places you don't expect (you can construct a non-terminating value, but the actual infinite loop doesn't happen until you try to evaluate it, which can be arbitrarily far away from the blame site).
15:26:31 <Twey> Which can be awkward for debugging.
15:26:35 <dleedev> I see... I have a hard time with exactly those things when reasoning about haskell code, but I was wondering if that's due to my novice experience
15:27:31 <dleedev> reasoning about performance and space/memory is easier in other languages for me. termination is about the same.
15:27:47 <Twey> OTOH I think equational reasoning probably makes non-termination a bit harder to cause accidentally than in other languages: it's usually relatively easy to see whether your arguments are smaller on each call, as opposed to imperative languages, where you can accidentally tweak a variable somewhere in the loop body such that the termination condition never succeeds
15:27:57 <monochrom> try my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:28:12 <monochrom> (I still have to find time to add more!)
15:28:45 <Twey> I personally believe that *time* performance is no harder in Haskell than in other languages: reasoning about it as if it were a strict language is as easy as reasoning about a strict language, and will give you a strict (ha) upper bound
15:29:01 <Twey> *Space* performance, on the other hand, I find unpleasant to reason about due to GC
15:29:43 <hpc> it's always thunks that get me
15:30:04 * hpc has no problem with space performance in perl, which has about the worst GC of a currently used language
15:30:05 <dleedev> monochrom: it seems like you claim lazy evaluation is not good for precise cycle/byte counts
15:30:15 <monochrom> I opine the opposite. on time, pretending eagerness (not strictness, strictness tells you nothing) is too loose. on space, no harder than every GCed environment.
15:31:08 <dleedev> monochrom: was that in response to me or Twey?
15:31:15 <monochrom> Twey
15:31:16 <Twey> To me, I imagine
15:32:20 <Twey> Agreed on ‘no harder than every GCed environment’.  I'm not sure what ‘too loose’ means in the time claim.
15:32:46 <Twey> hpc: One doesn't usually write Perl for its high efficiency :þ
15:33:09 <dleedev> Twey: I think *time* is not too hard, but *timing* is what's hard
15:33:15 <monochrom> «take n [1..]» takes infinite time under eagerness. that is a useless upper bound
15:33:16 <benmachine> at work I use OCaml
15:33:22 <Twey> dleedev: Yes
15:33:32 <benmachine> all my colleagues are like, "ha ha, that crazy haskell, it's so hard to debug space leaks"
15:33:43 <Twey> monochrom: Sometimes it is, yes, but often it isn't
15:33:48 <dleedev> Twey: is that because I'm a novice, or is that common to all Haskellers?
15:33:49 <benmachine> and then all our applications have space leaks in them
15:33:56 <benmachine> turns out writing correct code is really hard!
15:34:12 <benmachine> and actually I think Haskell's memory profiling tools are pretty damn good
15:34:13 <Twey> dleedev: Unpredictability is a core feature of GCs ;)
15:34:25 <monochrom> I guess what you really do is pretend eagerness but make a ton of exceptions for a ton of special idioms
15:34:42 <Twey> The memory-profiling tools are pretty good, yeah
15:34:43 <mietek> Is there a way to refer to other local cabal packages in a cabal package description?
15:34:45 <Nafai> aren't space leaks in Haskell due mostly to laziness?
15:34:49 <Twey> monochrom: That sounds about right
15:34:50 <Eduard_Munteanu> I wonder if you could make some analogy relating eagerness vs laziness in time with manual management (or regions) vs GC on space.
15:35:23 <monochrom> the problem with exceptions is exemplified by the Ptolemy model of astro bodies
15:35:45 <Twey> Eduard_Munteanu: I suppose something like ‘GC is lazy freeing’ :þ
15:35:47 <mietek> I'd like to be able to do something like "cabal sandbox add-source lib/foo", but from within the main cabal package description.
15:35:55 <monochrom> you can always add one more wheel to adjust for one more case, since you already have 10001 wheels.
15:36:30 <Twey> monochrom: Heh.  In this case it's always going to be an approximation anyway — you rarely reason down to the compiled opcodes these days.
15:38:16 <Eduard_Munteanu> Yeah... similarly, eagerness seems like computations being bracket-ed by construction / destruction of values, a bit like regions / malloc+free
15:38:45 <Eduard_Munteanu> (note not necessarily full eagerness)
15:43:02 <Eduard_Munteanu> By the way, does GHC's strictness analyzer attempt to allocate regions for clear cases / any plans to do that? It seems to me even in the presence of GC it might be nice to get at least some things inferred at compile-time.
15:43:54 <hpc> Eduard_Munteanu: ghc can transform some strictness into mutation, from my understanding
15:44:08 <hpc> which might supercede that sort of thing?
15:44:31 <Eduard_Munteanu> Mmm, yes, although they're different goals.
15:45:35 <Eduard_Munteanu> (Moving some GC computational effort to compile-time vs. avoiding reallocation)
15:45:57 <Eduard_Munteanu> Or maybe they're not all that different.
15:46:30 <mp> hi, type-eq 0.4.1 does not compile, 0.4 does, offeding line: Type/Eq.hs:28, if !(MIN_VERSION_base(4, 7, 0)), cpphs does not like it
15:47:24 <Eduard_Munteanu> If reallocation is light enough I guess you can say GC already turns them into mutation by recycling collected memory without moving things around.
15:54:57 <Twey> mp: Feel free to submit a pull request on GitHub
15:58:42 <adelbertc> nkpart: ping
15:58:55 <nkpart> Hi
15:59:15 <adelbertc> random question: noticed you used irccloud - wondering how you like/dislike it?
15:59:36 <benmachine> that question is pseudorandom at best
15:59:47 <adelbertc> benmachine: fair enough :-)
15:59:54 <benmachine> :P sorry I'll be quiet
15:59:56 <nkpart> It's good, I'll tell you more over back channels
16:06:36 <Eduard_Munteanu> Is there a word that describes datatypes "lifted" to typeclasses? E.g. class List f where nil :: f a; cons :: a -> f a -> f a; elim :: r -> (a -> f a -> r) -> f a -> r
16:07:30 <encanis> is currying compulsory in haskell? every function takes only 1 argument?
16:07:37 <roboguy_> Eduard_Munteanu: final maybe?
16:07:47 <hiptobecubic> encanis, you're welcome to not use it
16:07:47 <Eduard_Munteanu> encanis: no, you can make it take a tuple
16:07:50 <roboguy_> as in final encoding
16:07:54 <hpc> encanis: it's not compulsary, but not using it is miserable
16:08:04 <hpc> instead of (a -> b -> c), (a, b) -> c
16:08:10 <Eduard_Munteanu> roboguy_: hm, never heard of that, I'll look it up
16:08:34 <roboguy_> @where finally tagless
16:08:35 <lambdabot> I know nothing about finally.
16:08:41 <Eduard_Munteanu> encanis: the problem is you can't do partial application, for one thing
16:08:55 <Eduard_Munteanu> Not nicely.
16:09:41 <Eduard_Munteanu> encanis: well, my "no" is relative, that's still taking only one argument, but still :)
16:11:59 <roboguy_> Eduard_Munteanu: http://okmij.org/ftp/tagless-final/course/lecture.pdf
16:12:15 <roboguy_> I'm not sure if that's exactly what you had in mind though
16:12:22 <Eduard_Munteanu> Yeah, I googled that myself after you mentioned "finally tagless". :)
16:12:41 <roboguy_> that's the haskell version of the paper, which I can never find through google for some reason
16:12:53 <Eduard_Munteanu> Ah.
16:13:48 <Eduard_Munteanu> I wonder what difference it makes...
16:14:11 <roboguy_> funfunctor: indecision?
16:14:41 <Eduard_Munteanu> I suspect they're equivalent up to recursion, at which point you need equirecursive types to keep them equally expressive?
16:15:20 <roboguy_> Eduard_Munteanu: what does elim do?
16:15:40 <Eduard_Munteanu> roboguy_: destruct the list, i.e. the eliminator
16:15:50 <Hulk{-_-}> Should one spend much time reading about functors and applicative functors? Are they used often?
16:15:57 <Eduard_Munteanu> roboguy_: like 'maybe' for Maybe
16:16:01 <roboguy_> Hulk{-_-}: they are used often in my experience
16:16:05 <roboguy_> Eduard_Munteanu: ah, I see
16:16:19 <Iceland_jack> Hulk{-_-}: They are very useful
16:16:19 <Hulk{-_-}> roboguy_: Thanks.
16:16:23 <Eduard_Munteanu> Hulk{-_-}: yeah, but luckily they're rather simple
16:16:26 <hpc> Hulk{-_-}: in addition, they are a part of learning monads
16:16:31 <roboguy_> Hulk{-_-}: they can make things a lot nicer
16:16:39 <evincar> Hmm, could you make a class for partial application?
16:17:49 <Eduard_Munteanu> evincar: possibly, but not easily, it sounds like it might need PolyKinds
16:18:36 <Eduard_Munteanu> evincar: and of course you'd need an operator between the function and arguments
16:18:53 <greg`> ok im getting the error could not find module System.IO.Streams but when i cabal install Streams it says it is already installedd
16:19:05 <Eduard_Munteanu> evincar: (much like Applicative)
16:19:06 <evincar> Eduard_Munteanu: Of course. It also depends on which order you want to apply arguments in.
16:19:13 <roboguy_> greg`: that is not the module name
16:19:33 <greg`> roboguy_: how do i find the module name
16:19:33 <roboguy_> greg`: try Data.Stream
16:19:37 <roboguy_> greg`: http://hackage.haskell.org/package/Stream
16:19:48 <greg`> hmmm
16:20:11 <roboguy_> greg`: oh, unless you mean this one http://hackage.haskell.org/package/streams
16:20:22 <roboguy_> either way, it's a different module name
16:20:29 <evincar> Eduard_Munteanu: I.e., having "f(x, y, z)" and "class PApply ? where ($$) :: ?", do you expect to be able to say "f $$ (x, y) $$ z" or "f $$ x $$ (y, z)"?
16:20:32 <evincar> Or both?
16:21:42 <greg`> roboguy_: so how is one supposed to know?
16:21:57 <roboguy_> greg`: go to the hackage page and look. it lists the module names
16:22:11 <roboguy_> Data.Stream.Future, Data.Stream.Infinite, etc
16:24:20 <stephenmac7> I was wondering... is it okay to use a library without knowing how it works?
16:24:24 <TravisD> Is there a macro that provides an alternative to defn, but creates a memoized function that also looks for cached values whenever it recurs? As far as I know, you cannot use the memoize function to do this except for the special case of top-level functions held in vars
16:24:31 <TravisD> er, an alternative to fn, I suppose
16:24:32 <Eduard_Munteanu> evincar: maybe   class PApply (f :: * -> k) where type Fun f :: *; type Result f :: * -> * ($$) :: Fun f -> a -> Result f a
16:24:39 <TravisD> Ah - wrong channel. Sorry folks!
16:25:11 <johnw> greg`: you asked a question about the ide; no, we don't use HaRe at the moment
16:25:12 <roboguy_> stephenmac7: maybe
16:25:25 <stephenmac7> roboguy_: Like Yesod or Scotty
16:25:32 <roboguy_> stephenmac7: probably
16:25:49 <stephenmac7> I see the example code: like https://github.com/scotty-web/scotty
16:25:59 <stephenmac7> But I don't understand Monad Transformers
16:26:00 <greg`> johnw: just wondered , im thinking of taking it for a spin
16:26:12 <johnw> greg`: let me know how it goes!
16:26:17 <johnw> greg`: are you Greg Weber?
16:27:01 <greg`> no
16:27:17 <greg`> im really ordinary and rather mediocre
16:27:33 <rnons> Why there is no ToJSON ByteString in aeson-0.7?
16:27:56 <greg`> though i aspire to greatness!
16:27:58 <stephenmac7> roboguy_: Thanks
16:28:01 <roboguy_> stephenmac7: I don't have too much experience with them, but monad transformers never struck me as too difficult to understand well enough to use properly. they are a way to compose monads (although, not all monads can be composed)
16:28:37 <stephenmac7> roboguy_: I could never find something that explained them well
16:29:21 <jchee> rnons: I was under the impression it was because bytestrings had no encoding
16:29:27 <greg`> roboguy_: I have System.IO.Streams imported in this code fragment,is that haskell 98 only?
16:29:32 <no-n> @src concat
16:29:33 <lambdabot> concat = foldr (++) []
16:30:05 <roboguy_> greg`: it looks like that is from the io-streams package
16:30:15 <jchee> rnons: Text and String are unicode
16:30:31 <rnons> jchee: Thanks, I find this: https://github.com/bos/aeson/pull/148
16:30:52 <greg`> *very frustrated* why isnt it clear where modules come from , surely we should be able to search fully qualified names in hackage, hoogle , hayoo
16:31:12 <roboguy_> stephenmac7: I've just thought of them as a way to work in multiple monads at once, instead of just one
16:31:21 <rnons> jchee: So, my old code should be modified to String or Text?
16:31:37 <roboguy_> greg`: I just put "import System.IO.Streams" into google
16:31:52 <WraithM> rnons: If you really meant Unicode in your old code, yes
16:32:02 <WraithM> Unicode encoding
16:32:32 <roboguy_> usually that's how I find modules
16:32:40 <greg`> roboguy_: ok perhaps im being a pedant, but if i need to import Systems.IO.Streams why can i not cabal install it?
16:33:05 * hackagebot purescript 0.4.2.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.2.1 (PhilFreeman)
16:33:06 <greg`> presumably the x.x.packagename is a namespace to act as a unique identifier
16:33:30 <greg`> why is there this weird mapping, or why should i need to go to google?
16:33:43 <Eduard_Munteanu> evincar: hm, are you familiar with heterogenous lists? Might be easier to go through that.
16:34:18 <roboguy_> greg`: multiple packages can provide the same module
16:34:23 <roboguy_> and in fact do sometimes
16:34:36 <Cale> greg`: The thing you import is the module, the thing you download from hackage is a package (which can contain many modules)
16:35:13 <greg`> ah ok
16:35:47 <Cale> greg`: Packages are not part of the formal language specification (though perhaps they ought to be), while modules are.
16:37:11 <Eduard_Munteanu> Bleh, I'm tired and confusing things.
16:37:21 <greg`> ah so the world of packages is a bit like the wild west, but actually i appreciate the flexibility here
16:38:31 <haasn> I wonder if it would be possible to throw together a quick bash script using hoogle, grep and cabal-install to do what greg` wanted
16:38:32 <greg`> thanks, i'll find some drugs to suppress my autistic tendency to freak out when the world doesnt fit cleanly into my logical model, mean while i will google my module to find its package
16:38:46 <mirpa> Is ghci debugger good for finding source of exceptions like (head []) or (index out of bounds - from array)?
16:38:49 <Cale> greg`: Also, the thing about modules with dots in their names is completely artificial and just helps with mapping things into directories. You can have a module X.Y without having X
16:39:04 <Cale> (and you can have both without them being related to each other)
16:39:26 <greg`> thats fine isnt it
16:39:27 <hpc> usually you have both, and they are related
16:39:37 <greg`> i think its just namespacing as per the java world
16:39:39 <Cale> Yeah, it's fine, it's just something to watch out for
16:39:44 <hpc> but it's fine as long as you name things sensibly
16:39:55 <hpc> it's different from java, because you can't do
16:40:00 <hpc> import Foo.Bar.*
16:40:05 <hpc> which you can in java
16:40:35 <hpc> it is that way for boring, detailed, and possibly accidental reasons
16:41:30 <Cale> It was really as simple as "Okay, we're going to allow modules to have dots in their names now, and the compiler will use that as a way to know where to look for the source code"
16:41:36 <greg`> thats fine, i sometimes forget that haskell is so young, i have no doubt that the brightest minds are on the case
16:41:49 <hpc> it's older than you think
16:41:55 <Cale> (along with some little syntactical details regarding the fact that period is also used as an operator symbol)
16:42:09 <benmachine> I always get the impression that the people working on Haskell were like "laziness! type classes! this is really exciting! oh I guess we need modules too or whatever"
16:42:09 <hpc> but it's both very conservative and veyr experimental, which makes its development a bit strange to compare with other languages
16:42:10 <roboguy_> greg`: haskell's more than 20 years old
16:42:52 <Cale> benmachine: Well, fancy module systems had already been done, so you weren't likely to get many papers out of that :)
16:43:06 <greg`> indeed but it spent a lot of time in exile
16:43:10 <hpc> unfancy module systems!
16:43:17 <benmachine> FANCIER ones
16:43:33 * benmachine deserts to Agda
16:43:50 <sipa> then you're guatanteed to be terminated
16:44:13 <greg`> it is a bit broken if i have to google to find out which package my module is in and then kinda guess by looking at the best fit
16:44:21 <Cale> Haskell's module system is sitting at a really good point in terms of power/weight ratio. There is one little thing I'd have liked to see -- making type synonyms interact with the module system better would have given more purpose to them.
16:44:38 <roboguy_> how do you guys feel about backpack?
16:44:50 <greg`> whats that?
16:44:59 <Cale> roboguy_: I haven't really looked at it too closely yet
16:45:01 <roboguy_> it's a proposal for a fancy module system for haskell
16:45:11 <benmachine> Cale: so now that I've been working with OCaml for a while, Haskell's namespacing feels really clumsy
16:45:27 <benbangert> heh, fancy modules or not, I'd just prefer everyone to use qualified imports or explicitly name wtf they import from a module ;)
16:45:37 <benmachine> even leaving aside all the exotic stuff like parameterised modules and first-class modules, just having submodules would be a start
16:45:37 <roboguy_> Cale: I haven't look at it too much either, but I'm curious about it. I hear it's sort of like SML's system
16:45:46 <roboguy_> which only sort of means something to me
16:45:48 <BMeph> Isn't Haskell 25, this year? :)
16:45:56 <hpc> amateurs, i want @INC!
16:46:03 <benmachine> BMeph: iirc Haskell is 1990 or so
16:46:04 <Cale> benbangert: Weirdly I'm the other way, for reasons I have a hard time explaining :)
16:46:19 <greg`> anyway its not fancy modules, its just sensible
16:46:28 <benmachine> I think Haskell makes qualified imports far harder than they need to be
16:46:35 <Eduard_Munteanu> evincar: ok, it's easier than I thought, I was thinking of something else :)
16:46:37 <benmachine> well
16:46:39 <benmachine> Haskell doesn't
16:46:41 <benmachine> but e.g. Haddock does
16:46:45 <benbangert> Cale: I end up reading lots of code on the web, and the thought of having to install a package, its deps, just so my tooling can tell me where the hell the func/operator came from makes me cry
16:46:56 <sipa> hpc: #include is far superior
16:47:29 <benmachine> it makes me cry that people still use #include in actual things used by actual people
16:47:59 <hpc> benmachine: i bet the recent apple ssl bug just about killed you with sadness
16:48:03 <roboguy_> I just realized you could use #include in haskell with CPP, haha
16:48:12 <benmachine> roboguy_: :'''(
16:48:12 <hpc> roboguy_: yes, it's awful
16:48:21 <roboguy_> there's probably some really weird corner case where you *have* to
16:48:34 <hpc> (i use it in one project for really dumb import reasons)
16:48:40 <roboguy_> which makes me sad to think about
16:48:44 <Cale> I'd really like if modules took at least a little bit of care not to step on each other's names, and to use qualified module imports in the case where you accidentally have collisions. Maybe it's just out of nostalgia for the days where you could just write  import Set  and  import FiniteMap  and not have to worry about telling the compiler every single time that you'd like it imported qualified with the usual prefix
16:48:44 <benmachine> roboguy_: the corner case is when you are making a mystical potion that needs the tears of an internet stranger
16:48:52 <hpc> (there's a few specific modules that need a huge number of things imported qualified, and the hell with typing those out)
16:48:53 <roboguy_> benmachine: haha
16:49:59 <benbangert> Cale: yea, tooling could also make it easy to explicitly import just the names you use, so that you don't have to keep jumping to the import list everytime you need to use some other func from the package
16:50:47 <Cale> I also rather dislike when languages make decisions which result in *needing* fancy tools to get by.
16:50:57 <benbangert> my Go tooling lets me modify the import list while I'm writing code so my flow isn't interrupted just to import something, quick shortcut key popup
16:51:08 <Cale> The compiler should be the fancy tool
16:51:21 <hpc> the programmer should be the fancy tool
16:51:30 <Cale> heh
16:51:34 <benbangert> Cale: yea, thats exactly why I like seeing what names are imported from each module, then I don't need a fancy tool to devine it
16:51:51 <hpc> (but really, the language should be the fancy tool)
16:51:51 <greg`> no i want computers to do the mundane detail
16:52:07 <simpson> I've come to the conclusion that the Go team hates programmers.
16:52:20 <greg`> i want to do only the thinking thats absolutely necessary
16:52:23 <Cale> benbangert: That's somewhat true, but if it makes you type a bunch of stuff that ends up being awkward to maintain, then I think it also kind of outlives its welcome from another angle.
16:52:32 <simpson> My evidence is: import "fmt"
16:52:43 <benbangert> simpson: I came to that conclusion awhile ago, when their reasoning for not having proper generics was that it made their compiler sad, rather than the fact that not having them makes *programmers* sad
16:52:48 <greg`> and i want to spend the rest of my time with my wife and kids
16:53:19 <simpson> benbangert: Sadly, there's been a declaration from on high that my division's going to have to start learning Go and preparing to use it for stuff.
16:53:20 <greg`> hurt the computers and stroke the humans
16:53:22 <benmachine> greg`: I don't have a wife and kids, I need import statements to distract me from my loneliness :(
16:53:30 <Cale> It's great to import rare modules qualified, but for stuff like Control.Monad or Data.Map that you're using every day, it's kind of unjustified to need to qualify that kind of thing.
16:53:36 <greg`> lol
16:53:54 <benbangert> Cale: yea, for heavily used modules it doesn't bug me that much
16:54:01 <Cale> (and so the case of Data.Map being designed such that it *must* be imported qualified, it kind of annoys me)
16:54:05 <benmachine> Cale: but Map.empty and Set.empty does feel more uniform than emptyMap and emptySet
16:54:32 <greg`> qualify everything, it doesnt hurt and actually its the kinda mundane thing computers do well for you
16:54:56 <Cale> I'd rather have emptyMap and emptySet and just be able to write  import Map; import Set at the top of my modules  :)
16:55:19 <Cale> (but it's not something that's about to change now, really)
16:55:21 <hpc> i would rather have Map/Set in Prelude
16:55:30 <BMeph> Cale: My biggest peeve is when I import something from a module, which conflicts with something from the Prelude...which I never thought to hide, since I (almost) never use it...ooh, sometimes I really HATE auto-importing the Prelude, with a white-hot passion!
16:55:39 <roboguy_> I'd like to have Monad and Applicative in Prelude
16:55:43 <Cale> hpc: Yeah, there's a decent argument for including those
16:55:47 <benmachine> Monad is in Prelude
16:55:56 <hpc> Applicative is not
16:56:09 <hpc> and (<$>) is in Applicative, lol
16:56:16 <roboguy_> benmachine: by Monad I mean Control.Monad
16:56:17 <benmachine> it's also in Data.Functor, these days
16:56:33 <S11001001> BMeph: NoImplicitPrelude?
16:56:36 <sipa> Cale: if integer division and real division are sufficiently different to warrant a separate operator, surely checking whether a map or a set are empty should be different too :)
16:56:58 <Cale> sipa: (or referring to the empty map or set)
16:57:07 <sipa> yeah, same thing
16:57:07 <hpc> Cale is not shirley!
16:57:11 <BMeph> S11001001: You mean, the Ultimate in Baby-and-Bath-Water-Tossing technology? ;þ
16:57:26 <roboguy_> there are several things in Control.Monad that aren't in Prelude for some reason
16:57:43 <Cale> Bikeshedding should be an Olympic sport.
16:58:04 <johnw> it's the technical form of a filibuster
16:58:09 <benmachine> Cale: ok but it should be called bike-shedding
16:58:16 <benmachine> or possibly an endash instead of a hyphen
16:58:44 <Cale> :D
16:58:56 <BMeph> Cale: Oh, but it is...currently, the five-medal-award proposal is in the lead, but the three-medalers haven't given up yet! ;)
16:59:28 <BMeph> benmachine: I Like the way you think! :)
17:00:12 <benmachine> :)
17:01:24 <aavogt> Cale: can't you make a caletainers package?
17:03:13 <Cale> aavogt: I could, but it would be incompatible with everything, and I'd end up importing the usual containers anyway, which would defeat the purpose.
17:04:25 <Cale> aavogt: anything short of a revolution would be counterproductive, and that revolution would also be quite costly for something that's admittedly a pretty minor annoyance.
17:05:23 <aavogt> can't it be compatible? you have   emptyMap = M.empty
17:05:39 <Cale> Oh, I suppose I *could* do that :)
17:07:23 <Cale> Of course, then I've introduced two names for many of the same things which I'm not sure I'd be happy with doing, but it'd work.
17:07:45 <aavogt> well you can have your own world of Map and Set unqualified
17:08:13 <Aetherspawn> bikeshedding for an olympic sport
17:08:15 <hpc> i would create emptyMap, emptySet in containers
17:08:16 <Aetherspawn> all of my yes
17:08:17 <aavogt> anybody importing your modules can still use  import qualified Data.Map as M
17:08:18 <hpc> deprecate empty
17:08:21 <hpc> then wait about 8 years
17:19:29 <parc> Has anyone compared both the pipes and wire libraries?
17:23:06 <roboguy_> parc: don't those libraries serve somewhat different purposes?
17:24:19 <parc> Do they? I thought they both were sort of for stateful stream processing
17:25:11 <roboguy_> parc: I thought pipes was stream processing and wire was FRP
17:25:15 <Eduard_Munteanu> As much as FRP and iteratees intersect, I guess.
17:25:45 <roboguy_> Eduard_Munteanu: are pipes and conduit considered iteratee packages?
17:26:17 <Eduard_Munteanu> I'm unsure, I haven't used all of these much.
17:26:36 <Eduard_Munteanu> Perhaps I should have said non-lazy IO abstractions.
17:27:04 <parc> Essentially. I was making something with a type signature like: Automata a b = Automata { runAutomata :: a -> (b, Automata a b) }, and ended up finding that both pipes/wire have a similar structure
17:27:05 <johnw> roboguy_: yes
17:27:41 <freq> http://bit.ly/1chOEeN <- can anyone see the reflection in this picture?
17:28:02 <freq> oh no! 95
17:28:07 <Eduard_Munteanu> parc: that, as the name also implies, has more to do with stream comonads I think.
17:28:12 * hackagebot Win32-services 0.2.3 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.3 (MichaelSteele)
17:29:00 <Fuuzetsu> @pl f g x = g x x
17:29:00 <lambdabot> f = join
17:29:58 <Eduard_Munteanu> parc: if it's a celullar automata, are you familiar with their relationship to store(-like) comonads and zippers?
17:32:40 <parc> Not really. I'm working on a machine learning project to familiarize myself with haskell, and I found I needed to compose a lot of stream processing-like functions together, and came up with the automata example
17:33:12 * hackagebot Win32-services 0.2.3.1 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.3.1 (MichaelSteele)
17:33:21 <parc> and then I found out about wire/pipes, and wanted to try to look into them to see what a more mature project might look like
17:34:23 <roboguy_> parc: I think FRP packages like wire are more focused on time-varying things
17:37:46 <parc> ah. then I guess I'll focus more on pipes for now
17:39:06 <Eduard_Munteanu> parc: for streams as in data Stream a = Cons a (Stream a) you can make a comonad with extract being like 'head' and duplicate like 'tails'. You can think of '(=>>) :: Stream a -> (Stream a -> b) -> Stream b' as chaining computations that look ahead into the stream. Maybe that might be of some use to you.
17:42:25 <parc> Eduard_Muneanu: I think I need to familiarize myself more with monads in general at this point. more stuff to read up on
17:42:52 <roboguy_> parc: comonads are different than monads though
17:43:11 <Eduard_Munteanu> Ah, ok. I thought this was more of a researchy (personal or not) thing.
17:43:58 <parc> I did not know that :/ And it is researchy; that'll just be one more thing on my list to learn
17:44:18 <Twey> One could even say that comonads are the complete opposite of monads :þ
17:44:37 <Aetherspawn> pipes changed majorly like .. well, 4 times.
17:44:45 <Eduard_Munteanu> Not sure about "complete". :P
17:44:57 <Aetherspawn> and I sometimes wonder if it will change again
17:45:02 <roboguy_> they are sort of "an" opposite of monads
17:45:04 <Aetherspawn> maybe towards lenses :P
17:45:43 <Twey> They're definitely the complete opposite on one scale of measurement (… though I'm not sure what a *partial* opposite would look like there)
17:46:25 <Eduard_Munteanu> Meh, I was poking a pun at "complete" having specific meanings in math. :)
17:47:15 <Twey> Hm,  (a → m b, m b → a) → (m a → m b, m b → m a)… but I guess that's just a monad and a comonad
17:47:45 <Twey> Eduard_Munteanu: Oh, right!
17:48:31 <Twey> Heh, perhaps my ‘partial’ is your ‘complete’…
17:48:42 <Eduard_Munteanu> There's Bikleisli if you want to mix them.
17:48:49 <Twey> Oh, really?  Neat
17:49:15 <Eduard_Munteanu> newtype Bikleisli m w a b = Bikleisli (w a -> m b)
17:49:40 <Twey> Ah, with a distribution law
17:50:08 <Eduard_Munteanu> Although not a very good idea generally, if you want to combine the two, becuase of that distribution law.
17:50:18 <Twey> Aye
17:50:21 <haasn> Biklicycle
17:51:12 <Eduard_Munteanu> (a nicer one is comonad transformers over Kleisli or monad transformers over Cokleisli)
17:51:56 <mhmy> Hello?
17:52:57 <Eduard_Munteanu> Parse error at '?', expected type 'SalutationFormula', actual type 'Question'.
17:53:19 <Eduard_Munteanu> mhmy: hi :)
17:53:29 <mhmy> Hi there. Is anyone here a photographer?
17:53:49 <monochrom> no
17:53:58 <Eduard_Munteanu> mhmy: maybe, but this channel is about discussing Haskell the programming language.
17:54:07 <mhmy> oh... sorry!
17:54:23 <monochrom> "but Don Stewart sent me here"
17:56:12 * hpc really wants to dub wrath of khan with someone screaming "DOOOOONNNNNNNSSSS!"
17:56:38 <Eduard_Munteanu> That's not a very orthodons thing to do. :P
18:01:08 <buckmaster> has anybody tried using wai-handler-devel in a sandboxed project? I can't get it to find my libraries :(
18:04:38 <no-n> @src foldr
18:04:38 <lambdabot> foldr f z []     = z
18:04:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:19:43 <roboguy_> man, static typing has really spoiled me for dynamically typed languages like racket
18:20:09 <buckmaster> me too :P
18:20:43 <monochrom> I am a static type
18:22:12 <buckmaster> and type inference has spoiled me for languages that don't have it :P
18:22:25 <johnw> STM has done that to me too
18:22:48 <johnw> and super cheap threading
18:22:57 <roboguy_> how's STM? I still need to get around to trying it. which reminds me, I want to try Accelerate pretty soon
18:23:15 <buckmaster> I haven't found anything I really need STM for yet... makes me sad
18:23:32 <scshunt> STM is pretty good, the metro comes very frequently and the fare management is top class, but some of the infrastructure needs work
18:23:43 <johnw> the code I work on at work is very asynchronous, so we use STM all over the place
18:23:48 <monochrom> STM is like you can use shared mutable variables and not think about race conditions
18:24:41 <johnw> well, you don't have to think about them within the STM block
18:24:42 <buckmaster> does anyone use STM in for example a web server? I imagine that'd be the role the database/ORM plays in that setting
18:24:47 <johnw> but still have spent many hours debugging races
18:25:01 <monochrom> in fact, that is not the end of it. you can also say "dequeue from queue1 xor dequeue from queue2"
18:25:08 <johnw> in one relatively small module that combines STM with asynchronous processes, I ended up with 5 pretty serious races by the end
18:25:23 <buckmaster> where were the races coming from?
18:25:42 <johnw> lack of synchronization variables, or too many synchronization variables and getting them wrong
18:25:52 <johnw> the answer was to keep simplifying until as few variables as possible were involved
18:26:09 <johnw> and then just write test and review code until my eyes bled
18:26:17 <buckmaster> so synchronisation that fell outside the type boundary of the stm stuff?
18:26:17 <johnw> I'm still not convinced it's race-free
18:26:21 <johnw> yeah
18:26:28 <johnw> *within* an STM block, there can be no races
18:26:58 <buckmaster> yeah that was what I thought... so obviously anything outside it can have the usual traps :P
18:27:11 <johnw> yep
18:27:13 <johnw> and usually does
18:27:20 <johnw> and then you throw async exceptions into the mix
18:27:30 <johnw> and you end up having to be just as careful as in any language; but the STM definitely helps
18:28:00 <buckmaster> I guess it's only simple cases when you can have literally everything inside STM
18:28:20 * hackagebot aws-sdk 0.12.2 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.12.2 (YusukeNomura)
18:31:32 <johnw> i think my problem was that I had two different kinds of asynchronicity
18:31:48 <johnw> Haskell threads, and external processes
18:32:11 <johnw> if it's all Haskell, I tend to encounter races much less often
18:37:45 <buckmaster> hmm
18:42:22 <joelteon> can parsec be used to parse things that are left-associative?
18:42:32 <scshunt> yes
18:42:46 <scshunt> quite easily
18:47:40 <buckmaster> so again - sorry to repeat - nobody'
18:47:52 <buckmaster> 's tried using wai-handler-devel in a cabal sandbox?
18:48:22 * hackagebot hamlet 1.1.9.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.9.1 (GregWeber)
18:52:04 <funfunctor> howdy
18:53:55 <funfunctor> I'm having a little bit of a issue with finding modules https://gist.github.com/victoredwardocallaghan/9201725 ..
18:55:12 <funfunctor> I am using Clay to generate CSS but my source is in a number of files.. While trying to get Hakyll to build it I encounter the problem of some Haskell modules not finding others..
18:56:00 <funfunctor> I'm not exactly sure how that works compared with C includes where we pass -I/path the werid thing here is that if I run runghc on Main.hs it finds the modules fine
18:59:40 <funfunctor> oh nm, fixed it with -i./css
19:02:14 <buckmaster> good work ;P
19:24:09 <sellout-> So, what are the arguments for/against putting functions inside a typeclass? One benefit of including it is that an instance could define its own implementation. And the argument against is possible runtime overhead? Or is there more to it?
19:24:43 <sellout-> (EG, including `for` in Traversable)
19:31:44 <bergey> sellout-: The argument against is also that an instance could define its own implementation.
19:32:05 <sellout-> bergey: And break the laws?
19:33:15 <bergey> Potentially.  Even if it doesn't, it makes it harder to look at the class and understand what laws it promises, or at the types of functions using the class.
19:43:38 <NemesisD> hey guys. i'm trying to investigate an api compatibility, so i'm going to binary search versions on one of my dependencies. how can i do this with cabal sandbox w/o having to nuke *all* the deps each time
19:43:59 <NemesisD> since there's no "cabal uninstall", i want to make sure it uses the older version
19:46:01 <cmears> NemesisD, would it work to unregister the previous package version before you install the next one?
19:46:33 <NemesisD> cmears: can you do that with a sandbox?
19:47:07 <cmears> I haven't tried, but you might be able to by setting GHC_PACKAGE_PATH then using ghc-pkg as normal
19:49:33 <cmears> I'm trying it out now...
19:49:55 <NemesisD> it claims it would break a ton of packages
19:50:11 <cmears> I think that is inevitable
19:50:13 <NemesisD> whatever ill just script it and go do something else
19:50:29 <cmears> If you're removing a package and other packages were built against that, they will break
19:50:51 <cmears> But at least the packages that don't depend (transitively) on the one you remove will survive
19:57:23 <bergey> NemesisD: What about `cabal install --constraint=...`
20:04:08 <jroesch_c> is there a way to have cabal print the output of a tasty test suite w/ color?
20:06:31 <enthropy> dunno, but I think a file written somewhere in dist/.. has the color escapes in there
20:14:51 <mietek> Why does cabal configure tell me there are missing dependencies?
20:15:25 <geekosaur> mietek: most of the time they are C libraries
20:15:33 <mietek> I know they're missing, cabal!
20:15:33 <geekosaur> cabal is not apt-get or yum or pacman or etc,
20:15:44 <mietek> cabal pulls them in when I do a "cabal build"
20:15:50 <enthropy> or "cabal install" not "cabal configure"
20:15:54 <mietek> Yes
20:16:06 <mietek> So why is it complaining about them for "cabal configure"?
20:16:46 <enthropy> because somebody thought configure doesn't mean install dependencies from hackage
20:17:08 <geekosaur> if you're running individual steps, it does not follow deps automatically; that is intended for development/debugging, not for normal end user use
20:17:34 <mietek> I am actually doing development.
20:17:36 <mietek> "cabal configure --disable-library-profiling --disable-executable-profiling --disable-shared"
20:17:47 <mietek> As part of a Heroku buildpack.
20:18:02 <tristan__> how's that working out
20:18:13 <geekosaur> (specifically "cabal configure" is a wrapper for e.g. "runhaskell Setup.hs --configure" which doesn't follow deps
20:18:14 <geekosaur> )
20:18:16 <enthropy> cabal install probably accepts those flags too
20:18:31 <mietek> tristan__: https://github.com/begriffs/heroku-buildpack-ghc -- I think it's great
20:19:22 <tristan__> hm
20:19:26 <tristan__> not sure I've tried this one
20:19:46 <mietek> It's kept up-to-date
20:19:56 <mietek> enthropy: so it does.
20:19:57 <tristan__> last one I tried kept timing out
20:20:29 <mietek> I'm left wondering again, why is Cabal such a mess.
20:34:31 <external-reality> I need help with SYB. I undertand you must start with a type "specific" case but what about situations where your type specific case as a type vairalbe in it. For example (using the Company example) incS :: Float -> Salary a -> Salary a
20:34:42 <external-reality> Is something like that even possible?
20:35:06 <joelteon> how do I parse something left-associative in parsec
20:35:08 <joelteon> i.e. "a b c d" -> (((a b) c) d)
20:37:04 <pavonia> joelteon: There's chainl
20:40:32 <external-reality> ok I got it -- extQ and extT can help me cover multiple type sepecific cases.
20:40:53 <hiptobecubic> ?
20:53:37 * hackagebot egison 3.2.23 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.23 (SatoshiEgi)
20:53:39 * hackagebot egison-tutorial 3.2.5 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.5 (SatoshiEgi)
20:54:20 <anshul> haddock question: I have "cabalized" my package and while trying to run haddock I get the following error "File name does not match module name: Saw 'Main' Expected Data.Tiles" any ideas?
20:54:41 <geekosaur> you forgot the module declaration?
20:54:41 <anshul> Data.Tiles does not contain any mention of "Main"
20:54:50 <geekosaur> module Data.Tiles where
20:54:56 <geekosaur> if you omit it, it assumes Main
20:54:58 <anshul> @geekosaur ... nope
20:54:58 <lambdabot> Unknown command, try @list
20:55:54 <dwcook> anshul, change your file name to Tiles.hs?
20:55:57 <anshul> I do have Main.hs at the top-level in my source directory
20:56:15 <anshul> dwcook: Nope, module is named correctly
20:56:19 <geekosaur> you might also get that if there is something before the module declaration that it doesn't understand, but these days that would be somewhat strange as haddock should come with and be matched with ghc
20:56:27 <dwcook> According to the error it isn't
20:56:41 <geekosaur> (you used to get weird stuff when haddock didn't understand the ghc extensions in use)
20:56:42 <dwcook> anshul, what does your module declaration look like? What is its file name?
20:57:10 <cschneid> how do I nuke cabal, and start over. Got myself in a bad state and want to start over.
20:57:18 <anshul> path is src/Data/Tiles.hs
20:57:19 <dwcook> You also might need to create a directory Data to put Tiles.hs into
20:57:22 <dwcook> Oh, okay
20:57:24 <anshul> module is Data.Tiles
20:57:36 <dwcook> Then I haven't the faintest
20:57:45 <anshul> I do have language extensions turned on
20:57:51 <dwcook> Shouldn't matter
20:57:55 <anshul> {-# LANGUAGE BangPatterns -#}
20:58:37 * hackagebot egison-tutorial 3.2.6 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.6 (SatoshiEgi)
20:58:45 <geekosaur> cschneid, rm -rf ~/.ghc ~/.cabal/lib
20:58:50 <anshul> and the version of haddock I have is 2.13.2 (from May 2013)
20:59:11 <anshul> geekosaur: cschneid?
20:59:11 <geekosaur> (as always with rm -r, doublecheck you said what you meant before hitting enter)
20:59:27 <cschneid> geekosaur: thanks :) I figured the .cabal dir
20:59:27 <geekosaur> anshul, you are not the only person asking questions in the channel
20:59:42 <cschneid> geekosaur: thanks :)
20:59:55 <geekosaur> "cabal hell" is not cabal, it's ghc
20:59:57 <anshul> :| oops .. sorry
21:00:23 <geekosaur> cabal is the messenger, the mess is in ghc (and cleaning cabal/lib isn't strictly necessary)
21:01:20 <cschneid> geekosaur: interesting. I try to use sandboxes, except when I try not to, then --force-reinstall, then hate myself.
21:03:38 * hackagebot inflections 0.1.0.0 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.0 (jsl)
21:04:13 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml explains most of what's going on (minus some details about the ghc innards that cause the problem; it's cross-module inlining that causes it)
21:04:14 <anshul> tried an experiment: I had comments at the beginning of the Data/Tiles.hs file and when I removed them, the same error appeared in another file. sigh
21:04:41 <geekosaur> suddenly I wonder what version of haddock you have installed
21:05:01 <geekosaur> could you somehow have the ancient standalone one? this kind of thing is why we killed it in favor of the one integrated with ghc
21:05:50 <anshul> geekosaur: 2.13.2
21:06:13 <geekosaur> huh
21:06:48 <anshul> haddock --version Haddock version 2.13.2, (c) Simon Marlow 2006 Ported to use the GHC API by David Waern 2006-2008
21:08:39 * hackagebot inflections 0.1.0.1 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.1 (jsl)
21:11:17 <zzo38> What are some possible functors used in Haskell which can be applicable to any categories? I know what some of them would be, at least.
21:11:56 <apples> (->) r?
21:14:17 <zzo38> I can see:   data Identity x = Identity x;   is a functor, monad, and comonad, applicable to any category.    data Const x y = Const x;    is a endofunctor, applicable to any category.    data Finalize x = Finalize;    is a monad, applicable to a category with a final object.    data Initialize x;    is a comonad, applicable to a category with a initial object.
21:14:33 <zzo38> Do you know if these Initialize and Finalize have different names used commonly in mathematics?
21:15:27 <zzo38> And are there any others?
21:23:17 <anshul> asking my haddock question again: While trying to generate haddock documentation for my cabal package, I get the following error "File name does not match module name: Saw 'Main', Expected "Data.Tiles" haddock returned ExitFailure 1
21:23:55 <anshul> I have checked all the obvious things (directory structure matches the module name etc)
21:24:36 <roboguy__> zzo38: they have different names commonly used in haskell
21:25:01 <pavonia> anshul: Do you have a Main module or a module without name in Data.Tiles?
21:25:31 <anshul> pavonia. I do have src/Main.hs with a main function in it
21:25:41 <Fuuzetsu> didn't someone publish pure Haskell fast fourier transform lib the other week? I swear I saw something on the mailing lists but I can't find it on Hackage
21:25:54 <anshul> I also have Data/Tiles.hs which has module Data.Tiles in it
21:26:16 <Fuuzetsu> …oh, arb-fft might be it
21:26:54 <pavonia> anshul: the Data directory is in src?
21:27:37 <anshul> I have a directory called prj/prj.cabal, prj/Data and a file prj/Main.hs
21:28:01 <anshul> sorry file called prj/prj.cabal
21:28:25 <roboguy__> Finalize would be Proxy and Initialize would be Const Void
21:28:41 * hackagebot monoid-subclasses 0.3.6 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.6 (MarioBlazevic)
21:29:18 <Fuuzetsu> > fix Just
21:29:19 <lambdabot>  Occurs check: cannot construct the infinite type:
21:29:19 <lambdabot>    a0 = Data.Maybe.Maybe a0
21:29:19 <lambdabot>  Expected type: a0 -> a0
21:29:19 <lambdabot>    Actual type: a0 -> Data.Maybe.Maybe a0
21:29:42 <copumpkin> > fix (Mu.Just)
21:29:43 <lambdabot>  Not in scope: data constructor `Mu.Just'
21:29:43 <lambdabot>  Perhaps you meant `P.Just' (imported from Prelude)
21:29:47 <copumpkin> > fix (Mu . Just)
21:29:48 <lambdabot>  Not in scope: data constructor `Mu'
21:29:52 <copumpkin> > fix (In . Just)
21:29:54 <lambdabot>  In {out = Just (In {out = Just (In {out = Just (In {out = Just (In {out = Ju...
21:30:13 <roboguy__> copumpkin: where do the names In and out come from?
21:30:17 <roboguy__> I always wondered
21:30:23 <Fuuzetsu> :t Mu
21:30:24 <lambdabot> Not in scope: data constructor `Mu'
21:30:40 <copumpkin> roboguy__: I dunno, just needed some vaguely descriptive name to go in and out of the wrapper type?
21:30:52 <ethercrow> :t Fix
21:30:53 <lambdabot> Not in scope: data constructor `Fix'
21:30:55 <Fuuzetsu> :t In
21:30:56 <lambdabot> f (Mu f) -> Mu f
21:31:08 <Fuuzetsu> :t Out
21:31:09 <lambdabot> Not in scope: data constructor `Out'
21:31:14 <Fuuzetsu> :t out
21:31:15 <lambdabot> Mu f -> f (Mu f)
21:31:28 <Fuuzetsu> oh, I see
21:31:47 <Fuuzetsu> it's In { out … }
21:32:33 <Fuuzetsu> :t out
21:32:33 <lambdabot> Mu f -> f (Mu f)
21:32:55 <pavonia> anshul: That looks fine. Maybe there's something in your Data.Tiles module's header that is confusing haddock?
21:33:35 <Fuuzetsu> protip: there's now #haddock ;)
21:33:54 <anshul> I think the comments may be confusing it ... I removed the comments and the error now appears in another module
21:34:05 <anshul> the error message is terrible though
21:34:48 <pavonia> Could you paste the header that is failing?
21:35:40 <zzo38> roboguy__: Yes I know there are different names commonly used in Haskell, although some people seem to use different names than others, somehow.
21:36:37 <Fuuzetsu> anshul: it'd be the easiest if you put the whole project up somewhere so we could actually have a look
21:36:44 <zzo38> It still doesn't answer my original question though.
21:37:45 <joeyh> so, I just learned, the hard way that there are 2 different HttpException types, in conduit and http-client. And if you accidentially catchJust the wrong one, you'll fail to catch an exception, and the type checker can't tell you
21:38:25 <bitemyapp> joeyh: ouch :(
21:38:36 <Fuuzetsu> averagedayofexceptionusers.jpeg
21:38:44 <zzo38> You could try to write a function that would catch one and throw the other kind
21:38:46 <johnw> joeyh: have you mentioned that in a conduit issue?
21:38:57 <joeyh> I'm certianly going to
21:39:10 <joeyh> afaics, it's entirely a cut-n-paste from http-client, except with one constructor removed
21:39:26 <bitemyapp> johnw: I love that there's like, one obvious misdesign in library that could allow a run-time error that the compiler didn't catch and people want to immediately fix it.
21:39:31 <johnw> I'm sure snoyberg would be keen to know
21:39:40 <bitemyapp> in the Ruby and Python communities the names of the exceptions would've gotten bikeshedded for at least a week first.
21:39:46 <bitemyapp> then nothing would've been fixed.
21:39:59 <Fuuzetsu> bitemyapp: fixing things is unpythonic
21:39:59 <zzo38> And then you can just catch one kind and it is usable with both kind.
21:40:22 <bitemyapp> Fuuzetsu: deeply so. I think Odersky took a page from those people.
21:40:43 <bitemyapp> zzo38: it's a nifty idea but would make me feel deeply icky.
21:45:02 <zzo38> The IO monad is impure because it can catch errors in pure code. I do have the suggestion how to correct such things: Make up a "sandbox macro" which makes up the value in IO monad but makes it to avoid using lazy evaluation and makes it throw IO exceptions when it makes errors in pure code while evaluating it.
21:45:15 <zzo38> It would have to be a macro, not a function, to do this.
21:45:43 <Fuuzetsu> alternatively, don't throw exceptions from pure code
21:46:34 <zzo38> Fuuzetsu: Yes, but sometimes it will have an error message anyways, because of incomplete patterns or whatever.
21:46:52 <Fuuzetsu> I'm proposing that you avoid incomplete patterns or whatever ;)
21:47:01 <zzo38> Yes, that *will* work.
21:47:08 <zzo38> However, not all programs are like that~
21:47:29 <Fuuzetsu> you should strive to make your programs like that rather than trying to hack around the problem with macros
21:47:43 <zzo38> Yes, it would help.
21:47:57 <zzo38> However, macros would be a good thing to have too, for many different kind of purposes.
21:48:03 <Fuuzetsu> if your function can fail in pure code, make it explicit
21:48:19 <Fuuzetsu> zzo38: we have Template Haskell for the 5% of the stuff you'd need
21:48:41 <zzo38> Fuuzetsu: Yes I agree, "if your function can fail in pure code, make it explicit". But like I said not all program is like that.
21:49:15 <Fuuzetsu> zzo38: ‘it's not like that!’ is not too convincing; programs aren't inherently ‘not like that’
21:49:37 <zzo38> And macros are useful for a large number of things, and Template Haskell doesn't do a lot of them. I don't mean only this specifically example; I mean in general.
21:49:49 <mm_freak_> 225 063813 <bitemyapp> in the Ruby and Python communities the names of the exceptions would've gotten  bikeshedded for at least a week first.
21:49:59 * Fuuzetsu has a big problem with people trying to stick macros where they don't belong
21:49:59 <mm_freak_> reminds me of the endless "IO is pure/impure" debate
21:50:36 <zzo38> IO monad is mostly pure, but I described some situations where it isn't.
21:50:40 <Fuuzetsu> mm_freak_: this just seems to be the case of someone used to just throwing macros at everything thinking it's the best solution
21:50:58 <mm_freak_> zzo38: without justification
21:51:26 <zzo38> mm_freak_: What is without justification?
21:51:53 <mm_freak_> zzo38: the situations you described…  catching exceptions from pure code doesn't make IO impure
21:52:44 <zzo38> mm_freak_: I think it does make IO impure, especially due to lazy evaluation, but that isn't the only reason, but it is one of them.
21:52:54 <mm_freak_> zzo38: if you view IO as a GADT, here is the proof:  CatchPure :: a -> (SomeException -> IO a) -> IO a
21:53:16 <mm_freak_> and this idea is even implemented in Control.Exception
21:53:21 <mm_freak_> :t Control.Exception.evaluate
21:53:21 <lambdabot> a -> IO a
21:53:27 <zzo38> OK
21:54:12 <zzo38> But that isn't a real way; it makes pure code impure, then.
21:54:23 <mm_freak_> what?
21:54:36 <mm_freak_> does 'return' make pure code impure?
21:54:44 <zzo38> mm_freak_: No.
21:55:01 <mm_freak_> does 'return $!'?
21:55:08 <zzo38> No.
21:55:19 <mm_freak_> then why does 'evaluate'?  it's semantically equivalent to (return $!)
21:55:43 <zzo38> mm_freak_: Well, it doesn't. What *does* make it impure is the ability to catch those kind of exceptions.
21:56:01 <mm_freak_> why?  i just showed you a pure way to encode it
21:56:35 <zzo38> No, it doesn't encode it.
21:56:40 <mm_freak_> what's missing?
21:56:57 <Fuuzetsu> magical sandbox macros which make things strict
21:57:09 * Fuuzetsu is not helping
21:57:33 <the_berserker> @pl s >>= f  = cont $ \c -> runCont s $ \x -> runCont (f x) c
21:57:33 <lambdabot> (line 1, column 11):
21:57:33 <lambdabot> unexpected " "
21:57:33 <lambdabot> expecting operator
21:58:07 <the_berserker> @pl \s f -> cont $ \c -> runCont s $ \x -> runCont (f x) c
21:58:08 <lambdabot> (cont .) . (. (flip . (runCont .))) . (.) . runCont
21:58:10 <zzo38> What's missing is that, for example, (error "Hello") means something doesn't have a response value at all, so it is error, it isn't a real value; but, then it isn't supposed to be caught. It is mathematically impure and imprecise.
21:58:32 <mm_freak_> zzo38: no response value is generated
21:58:53 <zzo38> A value of type "a" doesn't contain a SomeException. You can't do anything with it other than just pass it.
21:59:10 <zzo38> It is a universal quanitified type.
21:59:14 <mm_freak_> alright then
21:59:44 <zzo38> Hopefully do you understand me now at least (whether or not you agree)?
22:00:08 <mm_freak_> i understand your argument, and i'm not willing to waste my time disproving it
22:00:57 <joelteon> wait, does Void make haskell impure then?
22:01:08 <zzo38> No, that isn't what I mean either.
22:01:13 <joelteon> foo :: Either Void (); foo = Right ()
22:02:10 <mm_freak_> note that the entirety of IO can be encoded as a GADT
22:02:12 <zzo38> That's OK, since Left is not a proper value in that case (although, it can be Left and then lazy; that depends whether you count lazy evaluations as impure)
22:03:00 <zzo38> mm_freak_: Yes, or as a Free CoYoneda, but if you do that, there isn't a way to catch pure codes using such a GADT, then.
22:03:13 <joeyh> aha.. HttpException has been fixed to import from http-client in a newer version of http-conduit
22:03:27 <zzo38> joeyh: That's good, it is fixed.
22:04:00 <mm_freak_> zzo38: the GADT does capture catching exceptions from pure code…  but without stretching this useless discussion further i'd like to point out that you should not throw exceptions from pure code in the first place
22:04:18 <zzo38> I agree with you, that you should not throw exceptions from pure code in the first place. That is not my point.
22:04:28 <joeyh> well, the instance of the problem is fixed. The class of problem remains
22:04:43 <zzo38> If it does capture catching exceptions from pure code, then show me what is the code to do so, without using any existing IO codes!
22:05:09 <joelteon> what's an IO code?
22:05:15 <mm_freak_> zzo38: data IO :: * -> * where CatchPure :: a -> (SomeException -> IO a) -> IO a; …
22:06:36 <zzo38> But that requires a use "outside of the system"; it allows IO tamper with pure code.
22:06:53 <mm_freak_> zzo38: yes, 'getLine' does require that, too
22:06:55 <ion> IO can tamper with anything, that’s what IO means. :-P
22:07:11 <mm_freak_> it's the point of IO to be a DSL that is interpreted by an outside system
22:07:25 <zzo38> Yes I know
22:08:06 <zzo38> But getLine is a proper code; if it is a GADT, GetLine you can put in your own input using your own function, without doing anything special.
22:08:22 <mm_freak_> GetLine :: IO String
22:08:29 <mm_freak_> getLine :: IO String
22:08:32 <mm_freak_> getLine = GetLine
22:08:33 <zzo38> Yes, that is OK
22:08:36 <zzo38> It isn't bad
22:09:16 <mm_freak_> so if catching exceptions is impure, then getLine is impure as well
22:09:33 <zzo38> Catching exceptions isn't impure in general.
22:09:42 <zzo38> Since they are I/O exceptions.
22:10:00 <zzo38> Perhaps it isn't the best representation of getLine (maybe it is better to repesent the individual input of each character), but that is irrelevant. Still, you can pattern match on GetLine, and to therefore run the program using your own system calls, in such a way.
22:12:39 <zzo38> I agree that it's the point of IO to be a DSL that is interpreted by an outside system (well, actually it is implemented a bit differently, but that is an implementation detail and is irrelevant). However, then it shouldn't try to read things inside of the system in an impure way.
22:12:45 <zzo38> Doing so causes a lot of problems.
22:13:14 <mm_freak_> it seems like with have conflicting notions of purity
22:13:58 <roboguy__> is there a way to tell cabal to not build profiling when building a certain library?
22:14:13 <zzo38> For example the code (getContents >> return ()) won't request any input, but (getContents >> print) does, so it is impure.
22:14:25 <zzo38> I mean, (getContents >>= print)
22:14:49 <mm_freak_> roboguy__: sure, just don't use -p for that library
22:14:50 <zzo38> It improperly pays attention to evaluation.
22:15:11 <roboguy__> mm_freak_: I already have library profiling enabled in my cabal config file
22:15:13 <zzo38> mm_freak_: Possibly...
22:15:27 <zzo38> Yes, I think possibly it is conflicting notions of purity
22:15:29 <joelteon> well, getContents >> print doesn't typecheck
22:15:38 <joelteon> i guess that's one definition of "impure"
22:15:42 <mm_freak_> hehe
22:15:42 <zzo38> joelteon: I know; I made a mistake and I corrected myself.
22:16:15 <zzo38> It is a typographical error.
22:16:21 <joelteon> getContents won't return any input in ghci because readline is confusing it.
22:16:28 <joelteon> try getLine >> return () vs getLine >>= print
22:16:34 <mm_freak_> roboguy__: i don't think there are per-package flags for bulk installs
22:16:49 <roboguy__> mm_freak_: I mean if I'm just building one package
22:16:49 <Nands> Basic Aeson beginners question. How can I parse JSON from an API call that sometimes returns an array of results or a single field representing one result. Aeson parses correctly based on my current FromJSON instances when it's an array but as soon as I get one result back in a regular field it throws a "when expecting a [a], encountered Object instead"
22:17:01 <mm_freak_> roboguy__: in that case you can use --disable-library-profiling
22:17:09 <zzo38> joelteon: That works as expected; what are you trying to make?
22:17:21 <zzo38> It request input even if not used.
22:17:34 <joelteon> I don't know what I'm trying to make
22:17:37 <roboguy__> mm_freak_: cabal doesn't recognize that option
22:17:45 <mm_freak_> roboguy__: cabal install should
22:17:46 <joelteon> you gave an example that's wrong, so I gave you an example that illustrates how it's wrong
22:17:49 <joelteon> and now you're saying it works as expected.
22:18:01 <roboguy__> mm_freak_: oh it does. thanks!
22:18:05 <zzo38> But getLine is different from getContents.
22:18:40 <zzo38> getContents uses lazy I/O, which is different from lazy evaluation, and allows pure code to affect how lazy the I/O is which causes the program to act differently.
22:19:06 <zzo38> Yes (getContents >> print) is clearly wrong, but that is just a typographical error I forgot an equal sign.
22:19:30 <joelteon> I still don't understand.
22:19:34 <joelteon> getContents >>= print will wait until EOF.
22:19:39 <zzo38> Yes it will.
22:19:49 <joelteon> oh ok
22:20:00 <zzo38> But, getContents >> return () will not request any input at all.
22:20:34 <zzo38> That's what I meant!
22:20:40 <zzo38> Now do you know?
22:23:20 <zzo38> But to return to my first question, do you know which other functor may have use in other categories too?
22:25:14 <zzo38> For example, the definition of a final object is, each object has exactly one morphism into the final object. So, a Finalize monad is a monad where return is that morphism, and fmap and join are identity morphisms.
22:25:32 <zzo38> Do you know of any other examples like this one?
22:26:08 <mm_freak_> i often use functors to/from pipes
22:26:20 <mm_freak_> those are not the usual Hask endofunctors aka Functor
22:27:28 <eazar001> Is there any reason why development in haskell seems to be particularly biased towards static builds, and tends to avoid use of shared objects?
22:28:06 <zzo38> mm_freak_: What are functors to/from pipes? I can see they may not be endofunctors, but it doesn't say what it is.
22:28:07 <mm_freak_> eazar001: historical reasons, and because i believe static linking against /haskell/ libraries is still the default
22:28:29 <mm_freak_> eazar001: other libraries in the system are dynamically linked as usual
22:28:33 <eazar001> it is still the default ... I don't understand that either
22:28:35 <supki> Nands: you can use Alternative instance of Parser like  xs <- (o .: "foo") <|> fmap (: []) (o .: "foo")
22:29:00 <mm_freak_> eazar001: well, there is no real reason to use the default…  just enable 'shared' in your configuration.nix
22:29:03 <mm_freak_> err
22:29:06 <mm_freak_> in ~/.cabal/config i mean
22:29:49 <mm_freak_> zzo38: newtype PipeC r m a b = PipeC (Pipe a b m r)
22:29:55 <zzo38> In the case of Haskell it is clearly the Functor class is only for endofunctors on (->), and that other functors can be used in Haskell (the Arrow class defines one; there are also functors to/from Kleisli categories, etc)
22:29:57 <mm_freak_> that's a Category in the Control.Category sense
22:30:10 <eazar001> mm_freak: i see, thx
22:30:22 <zzo38> mm_freak_: OK, but I don't know what "Pipe" is.
22:30:33 <mm_freak_> zzo38: it's a stream processing abstraction
22:30:47 <zzo38> Ah, OK.
22:31:29 <zzo38> It still isn't explaining exactly what the type means. But if it is a category then I suppose it is sensible to arrange them in that order.
22:32:20 <mm_freak_> zzo38: a haskell category is a type of kind * -> * -> * that obeys certain laws
22:32:22 <zzo38> What do "a", "b", "m", and "r" mean?
22:32:29 <zzo38> mm_freak_: Yes, I know that.
22:32:37 <mm_freak_> then a functor is a type of kind (* -> * -> *) -> (* -> * -> *) with yet other laws
22:32:46 <zzo38> Yes, I know that too.
22:32:48 <mm_freak_> a and b are objects
22:32:53 <zzo38> I know that, too.
22:32:55 <mm_freak_> m is the underlying monad of the abstraction
22:33:01 <mm_freak_> it's Pipe-specific
22:33:01 <zzo38> I am asking what it means in terms of Pipe
22:33:17 <mm_freak_> you should really just read the tutorial
22:33:31 <zzo38> What package does it belong to?
22:33:32 <mm_freak_> see the Pipes.Tutorial module in the haddocks
22:33:37 <mm_freak_> @hackage pipes
22:33:37 <lambdabot> http://hackage.haskell.org/package/pipes
22:33:48 <zzo38> OK, I will look at "pipes" package.
22:35:07 <mm_freak_> it's nothing special really…  it's just a very powerful, extremely fast and beautifully elegant stream processing abstraction
22:35:29 <zzo38> OK
22:36:18 <zzo38> Now I can see, it made up a module which exports nothing, to be used for this kind of documentation.
22:37:12 <lispy> is there a more efficient way to say let xs = S.toList someset in zip xs (tail xs) ?
22:37:30 <lispy> the result of zip will be immediately consumed
22:37:48 <lispy> (by mapM_ somemonadthing)
22:38:09 <mm_freak_> lispy: zip (S.toList someset) (tail (S.toList someset))
22:38:19 <mm_freak_> the sharing may make things worse here
22:38:59 <Heffalump> mm_freak_: really - won't the GC be able to free the heads of the list as they get used?
22:39:21 <mm_freak_> Heffalump: my intuition says it does
22:39:46 <mm_freak_> but with the non-shared version it's guaranteed
22:39:54 <mm_freak_> well, in GHC
22:40:06 <mm_freak_> S.toList is cheap anyway
22:41:16 <lispy> I wonder if I'm over thinking that line
22:43:35 <mm_freak_> lispy: well, if efficiency is important you should probably write the zip yourself
22:43:49 <mm_freak_> mapM_ f . pairs . S.toList
22:43:50 * hackagebot lio-fs 0.0.1.0 - Labeled File System interface for LIO  http://hackage.haskell.org/package/lio-fs-0.0.1.0 (DeianStefan)
22:44:37 <lispy> mm_freak_: I was going to replace it with zipWith and see what happens. Is zip/zipWith known to be suboptimal?
22:45:02 <mm_freak_> lispy: zip/zipWith traverse independently
22:45:13 <mm_freak_> this one does not:  pairs (x1:xs@(x2:_)) = (x1, x2) : pairs xs;  pairs [] = []
22:45:29 <mm_freak_> it should give you best sharing/GC behavior
22:47:49 <zzo38> That pipes library does looks like pretty good, and PipeC makes a lot of sense in that case too. I suppose then there is clearly the functor from (->) to PipeC.
22:48:48 <mm_freak_> zzo38: yes, it's in Pipes.Prelude
22:49:04 <mm_freak_> map :: (Monad m) => (a -> b) -> Pipe a b m r
22:52:24 <mm_freak_> there is also a functor from Kleisli m to PipeC r m
22:52:34 <mm_freak_> mapM :: (Monad m) => (a -> m b) -> Pipe a b m r
22:58:25 <codygman> Should I be getting a "use --force-reinstalls to reinstall" message when using cabal sandboxes?
22:58:40 <codygman> Does it use previously installed system packages?
22:58:51 * hackagebot cabal-bounds 0.1.8 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.8 (DanielTrstenjak)
22:58:53 * hackagebot cabal-bounds 0.1.9 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.9 (DanielTrstenjak)
23:00:54 <jle`> kept on looping a giant nondeterminstic simulation (basically a giant coin flip) and i kept on getting apparently huge strings of heads or tails
23:01:16 <jle`> but it was because the loop passed on the original seed unchanged
23:01:40 <jle`> so at every startup it'd be always the same
23:02:16 <jle`> i was thrown off because one of the simulations was THHHH. that's kinda weird.
23:11:51 <supki> codygman: sandboxes reuse system-wide package db
23:13:49 <codygman> supki: Thanks, I wasn't sure.
