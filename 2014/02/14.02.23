00:00:30 <shadewind> when using the FFI, what does the keyword "static" do?
00:01:17 <shachaf> Do you have an example?
00:01:29 <shachaf> Oh, never mind.
00:02:36 <shadewind> foreign import ccall "static foobar" foobar :: Foo -> IO Bar
00:03:00 <shachaf> static is the default
00:03:05 <shadewind> I see
00:03:06 <shachaf> See http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
00:03:06 * hackagebot xattr 0.6.2 - Haskell extended file attributes interface  http://hackage.haskell.org/package/xattr-0.6.2 (DeianStefan)
00:03:23 <shadewind> that's why it never explained this
00:08:31 * hackagebot x509 1.4.9 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.9 (VincentHanquez)
00:08:31 * hackagebot xattr 0.6.2 - Haskell extended file attributes interface  http://hackage.haskell.org/package/xattr-0.6.2 (DeianStefan)
00:09:14 <pharaun> @pl test a = print a
00:09:15 <lambdabot> test = print
00:09:34 <no-n> @src (&&)
00:09:34 <lambdabot> True  && x = x
00:09:34 <lambdabot> False && _ = False
00:09:41 <pharaun> @pl encode a = encode' a `append` "b"
00:09:41 <lambdabot> encode = (`append` "b") . encode'
00:09:56 <pharaun> durr me
00:12:09 <blueonyx> ping michaelt@github
00:18:32 <solrize_> It's only the polymorphic non-overloaded seq that is an abomination. Putting it in a type class makes it respectable again (obviously there would not be an instance of seq for the arrow type; since this instance cannot be written in Haskell).
00:18:35 <solrize_> what's that mean?
00:19:31 <shachaf> Is the first thing you wrote a quote?
00:22:50 <solrize_> yeah, http://www.reddit.com/r/haskell/comments/1yfc5f/laziness_make_haskell_not_beautiful/cfk7sj1
00:23:14 <solrize_> responding to neelk saying seq is an abomination
00:56:06 <anshul> Hello.
00:57:40 <anshul> I am trying to prove the following (from the Typeclassopedia exercise on Applicative Functors): pure f <*> x = pure (flip ($)) <*> x <*> pure f
00:57:52 <anshul> ...and this his how far I got:
00:58:23 <levi> solrize_: What part of it do you want the meaning of?
00:58:45 <anshul> pure (flip ($)) <*> x <*> pure f = pure flip <*> pure ($) <*> x <*> pure f
00:58:54 <anshul> = pure flip <*> pure ((.) id) <*> x <*> pure f
00:59:03 <anshul> = pure flip <*> pure (.) <*> pure id <*> x <*> pure f
01:00:43 <anshul> any hints?
01:01:15 <no-n> :t pure
01:01:20 <lambdabot> Applicative f => a -> f a
01:01:23 <no-n> @src pure
01:01:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:01:30 <shachaf> I think you might be making things more complicated than they started out.
01:01:37 * no-n strangles lambdabot 
01:02:13 <shachaf> no-n: Really? Please don't strangle people in here.
01:02:43 <shachaf> Anyway, I'd start by adding parentheses.
01:02:53 <shachaf> (pure (flip ($)) <*> x) <*> pure f
01:03:19 <anshul> @shachaf thanks
01:03:19 <lambdabot> Unknown command, try @list
01:03:20 <shachaf> let q = pure (flip ($)) <*> x and you have q <*> pure f
01:37:44 <skypers> hi
01:40:49 <no-n> how much does learning category theory improve one's haskell?
01:44:43 <startling> not very much.
01:44:50 <randomclown> not very much
01:46:53 <no-n> ahhh
02:00:50 <jle`> not very much
02:05:20 <fikusz_> can I use SDL-ttf with sdl2?
02:26:28 <randomclown> I think I've finally fixed that retarded space leak
02:26:35 <randomclown> will have to wait 6 hours to get my results though
02:27:19 <prinsen> i get api: /tmp/MXXXXX22565.o: unknown symbol `apizm0zi0zi0_DataziTest_zdfTypeableTest_closure' when trying to use the Plugins library with a user defined type, which derives Typeable
02:41:57 <no-n> I don't understand what fix is about
02:42:12 <Axman6> > fix (1:)
02:42:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:42:54 <Axman6> > fix (\f n -> if n > 2 then f (n-1) + f (n-2) else n) 30
02:42:58 <lambdabot>  mueval-core: Time limit exceeded
02:43:10 <Axman6> it's generalised recursion
02:43:13 <Axman6> > fix (\f n -> if n > 2 then f (n-1) + f (n-2) else n) 5
02:43:14 <lambdabot>  8
02:43:26 <no-n> I see
02:43:41 <Axman6> any recursive function cane be written like that using fix basically
02:45:14 <startling> it's not used very commonly.
02:45:26 <no-n> brb
02:45:39 <CindyLinz> lambdabot's @pl use it heavily..
02:45:54 <CindyLinz> Very useful to create unreadable codes... (flee)
02:45:57 <startling> I wouldn't say "heavily".
02:46:01 <Axman6> @pl let f n = if n > 2 = f (n-1) + f (n-2) else n in f
02:46:01 <lambdabot> (line 1, column 21):
02:46:01 <lambdabot> unexpected " "
02:46:01 <lambdabot> expecting operator
02:46:38 <Axman6> @pl fix (\f n -> if n > 2 then f (n-1) + f (n-2) else n)
02:46:38 <lambdabot> fix (join . liftM2 if' (> 2) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
02:46:44 <CindyLinz> @pl let f n = if n > 2 then f (n-1) + f (n-2) else n in f
02:46:44 <lambdabot> fix (join . liftM2 if' (> 2) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
02:47:15 <Axman6> oh roight, I always do that for some reason
02:47:50 <jacco> What would be the problem with changing the meaning of String to be the implementation of Text, and all code that uses the current String type would use [Char] instead?
02:48:09 <CindyLinz> I agree that if we use 'fix' precisely, it will still enhance the readability.
02:48:16 <Axman6> well, everything whose type said String would break...
02:48:18 <FreeFull> > let fibs = 0:1:zipWith (+) fibs (tail fibs)
02:48:20 <lambdabot>  not an expression: `let fibs = 0:1:zipWith (+) fibs (tail fibs)'
02:48:21 <FreeFull> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
02:48:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:48:33 <startling> jacco: 'text' isn't in 'base'.
02:49:16 <jacco> startling: it could be added, right?
02:49:34 <startling> jacco: I guess so.
02:49:51 <startling> jacco: You're not going to get an answer other than "it would break backwards-compatibility in a big way".
02:50:48 <jacco> startling: ok, but the only thing required to fix it, is substituting [Char] for every occurence of String
02:51:20 <pjdelport> jacco: there's http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#overloaded-strings
02:51:48 <CindyLinz> jacco: Not only the substitude the type, but also the way we use it.. @@"
02:52:20 <jacco> pjdelport: thanks, I am aware of that. But the more I learn about the difference of Text and String, it makes less sense that [Char] is the default implementation
02:52:59 <jacco> CindyLinz: what do you mean exactly? that all code working on [Char] should be converted to work on Text?
02:53:41 <pjdelport> jacco: Ah, okay. Well, there are also ByteStrings, and several other implementations. It might take some arguing to really establish that Text is truly ideal.
02:54:05 <CindyLinz> jacco: If my code uses [Char], I typically write code by pattern matching on list
02:54:14 <pjdelport> CindyLinz: I think jacco is only proposing removing the type synonym, not changing any existing code that works on [Char]
02:54:29 <CindyLinz> oh..
02:54:44 <jacco> pjdelport: that's right
02:56:56 <pjdelport> jacco: One problem with Text is that it's strongly UTF-16 based (as far as I understand), which isn't great for Unicode beyond the 16-bit range.
02:57:26 <earthy_> there's not *that* much unicode beyond 16 bits, is there, though?
02:58:16 <supki> jacco: which Text?
03:01:38 <Axman6> good point
03:01:40 <pjdelport> earthy_: It depends what you're doing; the most important thing outside of BMP is the unified CJK ideographs
03:02:14 <pjdelport> So if you're working with CJK text, it's an issue.
03:03:22 <jacco> supki: that's a good question, I don't know. I suppose the strict version could be more common in practical applications (for performance), but lazy would fit better with haskell's philosophy
03:05:06 * Maxdamantus hates the "there's not that much beyond the BMP" appreach.
03:06:28 <Maxdamantus> I think it might be illegal to sell software in China that only supports the BMP.
03:09:16 <Rembane> Maxdamantus: BMP?
03:10:01 <pjdelport> Rembane: Basic Multilingual Plane; the lower 16-bit codepoints of Unicode
03:10:45 <pjdelport> "21st Century ASCII" :)
03:10:45 <Rembane> pjdelport: That's a pretty kickass name for something mundane.
03:10:48 <Rembane> :D
03:10:58 <Maxdamantus> Rembane: basic multilingual plane.
03:11:12 <Maxdamantus> er, pjdelport answered.
03:11:30 <statusfailed> "Basic Multilingual Plane" sounds like something from dungeons and dragons
03:12:07 <Maxdamantus> what's funny is that in MySQL, "utf8" only supports the BMP.
03:12:21 <statusfailed> also, has anyone used that 'Aether' package (and why ain't it on cabal?) https://github.com/guoguo12/aether
03:12:40 <Maxdamantus> to use full unicode, you have to use "utf8mb4" or something.
03:13:02 <Guest21474> the planes that aren't the BMP are astral planes
03:13:09 <Rembane> MySQL is not very good anymore imo.
03:13:18 <Maxdamantus> (or just not let the database try to interpret your text)
03:13:38 <pjdelport> Rembane: Are you implying there was any point where it was actually good?
03:14:53 <Rembane> pjdelport: Yeah, about 2000. When you needed a fast and sloppy RMDB for an equally sloppy language, PHP.
03:16:25 <CindyLinz> XD
03:23:50 <no-n> @src last
03:23:51 <lambdabot> last [x]    = x
03:23:51 <lambdabot> last (_:xs) = last xs
03:23:51 <lambdabot> last []     = undefined
03:29:11 <syllogismos> :t filterM
03:29:11 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
03:29:17 <syllogismos> :t filterM (>)
03:29:18 <lambdabot> Ord a => [a] -> a -> [a]
03:29:26 <netogallo> Prelude GHC.Generics> :t t1'
03:29:34 <netogallo> t1' :: Rec0 (Maybe Int) t
03:29:40 <Placinta> Hi, I'm trying to build mtl, with ghc 7.8 and cabal install mtl, on windows. But I get ExitFailure -1073741819. Does anyone know what that might be?
03:30:17 <netogallo> Anyone know if there is some function that could do something like: typeName t1'  which would  produce something like "Maybe Int" ?
03:31:08 <syllogismos> data.typeable?
03:31:54 <ski> > -1073741819 + (fromIntegral (maxBound :: Int32) + 1) `div` 2
03:31:55 <lambdabot>  5
03:32:24 <netogallo> No, the Rec0 is not an instance of typeable
03:32:36 <ski> > -1073741819 + 2 ^ 31
03:32:37 <lambdabot>  1073741829
03:32:44 <ski> > -1073741819 + 2 ^ 30
03:32:45 <lambdabot>  5
03:32:57 <syllogismos> > typeOf (Just 1)
03:32:58 <lambdabot>  Maybe Integer
03:33:18 <CindyLinz> Typeable?
03:33:33 <netogallo> For maybe it works, but t1' is a type representation from GHC.Generics
03:34:19 <netogallo> ie t1 :: K1 i c p f
03:34:50 <syllogismos> you have to derive typeable or define it yourself
03:35:27 <syllogismos> Data.Typeable is what you are looking for.. i'm not sure though.. im new too..
03:36:08 <netogallo> I will try to derive typeable, but I don't know how will that go for TypeRepresentations
03:36:11 <netogallo> thanks
03:38:35 <syllogismos> :t filterM (>)
03:38:36 <lambdabot> Ord a => [a] -> a -> [a]
03:38:49 <syllogismos> how is this happening?
03:38:54 <syllogismos> :t filterM
03:38:54 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
03:40:42 <startling> syllogismos, it's the Monad ((->) r) instance
03:40:42 <dmj`> @src filterM
03:40:42 <lambdabot> Source not found. :(
03:41:07 <startling> > filterM (>) [1, 2, 3] $ 2
03:41:08 <lambdabot>  [3]
03:41:29 <startling> syllogismos: nice find. :)
03:41:47 <syllogismos> its always the reader monad.. every time a seemigly simple question is giving me a hard time..
03:41:50 <startling> haha
03:42:26 <startling> if you get weird stuff from by giving a monad function a function argument, it's probably that.
04:08:53 * hackagebot polysoup 0.4.0 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.4.0 (JakubWaszczuk)
04:26:08 <CaptainK> +
04:28:47 <ski>     -
04:29:33 <prinsen> i get api: /tmp/MXXXXX22565.o: unknown symbol `apizm0zi0zi0_DataziTest_zdfTypeableTest_closure' when trying to use the Plugins library with a user defined type, which derives Typeable
04:33:56 * hackagebot equational-reasoning 0.0.3.0 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.0.3.0 (HiromiIshii)
04:38:09 <notdan> Why there is not 'elem' function in Data.Text, like in ByteString or Prelude?
04:40:41 <startling> :t elemOf Data.Text.Lens.text
04:40:42 <lambdabot> Data.Text.Lens.IsText s => Char -> s -> Bool
04:40:55 <startling> :>
04:41:54 <startling> notdan: that is strange, though.
04:42:47 <startling> :t Data.Text.foldl (\b c -> b || c == 'a') False
04:42:48 <lambdabot> Data.Text.Internal.Text -> Bool
04:42:51 <notdan> Why there is not 'elem' function in Data.Text, like in ByteString or Prelude?
04:42:53 <notdan> erm
04:42:53 <notdan> sorry
04:43:17 <notdan> thanks startling , I can't afford a lens dependency though
04:43:30 <notdan> I wrote elem using isJust.find
04:43:48 <startling> that's probably the best way, yeah.
04:54:04 <d3lxa> I just installed a new debian, I need cabal sandboxes, what's the best way to get them? cabal-install in testing hasnt them :(
04:55:27 <IceDanelol> d3lxa: just install the haskell platform from www.haskell.org
04:55:41 <IceDanelol> building it is pretty simple
04:56:23 <bergey> cabal install cabal-install
04:56:44 <IceDanelol> or that, yes, if that gives you 1.18
04:56:46 <bergey> IceDanelol: platform has cabal 1.16 still
04:57:06 <IceDanelol> bergey: that's true, yeah
04:57:35 <d3lxa> okay, thank you :) will go with cabal install cabal-install
05:09:00 * hackagebot serialport 0.4.6 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.6 (JorisPutcuyps)
05:21:48 <jle`> is there a library function to clamp a value within bounds?  \x -> min (max x low) high
05:28:47 <prinsen> I posted a Haskell question to StackOverflow, I would appreciate if someone tries to answer it, http://stackoverflow.com/questions/21967194/haskell-plugins?noredirect=1#comment33285936_21967194
05:29:17 <prinsen> I posted a Haskell question to StackOverflow, I would appreciate if someone tries to answer it, http://stackoverflow.com/questions/21967194/haskell-plugins
05:34:05 <ski> > map (\x -> 2 `max` x `min` 7) [0 .. 9]
05:34:06 <lambdabot>  [2,2,2,3,4,5,6,7,7,7]
05:36:20 <Iceland_jack> @let { (...) :: Ord a => a -> a -> a; (...) = max }
05:36:21 <lambdabot>  Defined.
05:36:22 <Iceland_jack> @let { (....) :: Ord a => a -> a -> a; (....) = min }
05:36:22 <lambdabot>  Defined.
05:36:27 <Iceland_jack> > map (\x -> 2...x....7) [0..9]
05:36:29 <lambdabot>  [2,2,2,3,4,5,6,7,7,7]
05:36:31 <Iceland_jack> @undef
05:36:31 <lambdabot> Undefined.
05:38:53 <klrr_> hmm, is the "message" of a IRC message a special case or should it be treated the same as the parameters? if it's just treated as parameters how do i if a IRC message contain a "message"?
05:39:23 <hpc> message as in the part after the colon?
05:40:12 <klrr_> yes
05:40:32 <hpc> i wouldn't say "special case", but yes it is
05:40:36 <klrr_> well, if i make the colon part of it after parsing then it's easy to identify
05:40:47 <Iceland_jack> klrr_: The message is a parameter of PRIVMSG
05:40:48 <hpc> it is its own thing in parsing irc lines
05:41:04 <klrr_> okey, will treat it as a paramater
05:41:13 <Iceland_jack> klrr_: The final parameter is separated by a colon
05:41:23 <klrr_> okey
05:41:23 <Iceland_jack> the others are separated by space
05:41:27 <klrr_> yeah
05:41:34 <klrr_> well, a space and a colon seperate it
05:41:45 <klrr_> a space after : is part of the parameter
05:41:47 <hpc> Iceland_jack: that's wrong
05:42:14 <Iceland_jack> hpc: It is?
05:42:20 <Iceland_jack> It's been a while since I used the IRC protocol
05:42:39 <hpc> well, it seems i am wrong too
05:42:52 <hpc> (going by the BNF for irc lines)
05:43:40 <hpc> <params> ::= <SPACE> [ ':' <trailing> | <middle> <params> ]
05:43:54 <hpc> er, we're both right
05:44:01 <Iceland_jack> hah
05:44:04 <hpc> it's a part of the "params"
05:44:05 * hackagebot parcom-lib 0.8.0.1 - A simple parser-combinator library, a bit like Parsec but without the frills  http://hackage.haskell.org/package/parcom-lib-0.8.0.1 (TobiasDammers)
05:44:08 <hpc> but it is special
05:44:56 <hpc> in general, an IRC command consists of [:word] words :words\r\n
05:47:50 <hpc> with ugly details for what a word consists of at each point ;)
05:49:04 <prinsen> I posted a Haskell question to StackOverflow, I would appreciate if someone tries to answer it, http://stackoverflow.com/questions/21967194/haskell-plugins
05:52:11 <AlainODea> prinsen: two things: 1) IRC DDoS+netsplits are going to degrade your coverage here. 2) the StackOverflow Haskell tag is posted to twitter and should get some attention. Given the nature of the problem I would ask in #ghc, but YMMV due to 1)
05:57:38 <notdan> prinsen: hm, what if you get of the 'deriving instance' line and just put 'Typeable' next to 'Show'?
05:57:55 <notdan> prinsen: btw if I were you I would update the post with GHC version, plugins version etc
05:58:06 <notdan> it is really version-specific
06:00:29 <zebr> hi all. if i want a recursive type, is the only way of doing that with a datatype? e.g. data Thunk = Thunk Term [Thunk]
06:01:42 <zebr> it's just, i'd rather something like: mu thunk. (Term, [thunk])
06:01:42 <no-n> @src span
06:01:42 <lambdabot> span _ xs@[]                     =  (xs, xs)
06:01:42 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:01:42 <lambdabot>                   | otherwise    =  ([],xs)
06:01:53 <ski> zebr : `data' or `newtype', yes
06:02:15 <ski> zebr : no equi-recursive types in Haskell, only iso-recursive ones
06:02:29 <zebr> ski: i see. is there a technical reason for that?
06:02:48 <ski>   newtype Thunk = MkT (Term,[Thunk])  -- also works
06:03:21 <ski> zebr : not really. it's mostly that allowing equi-recursive bugs tend to hide and delay silly bugs more often than it being useful
06:03:54 <zebr> ah, ok. thanks. :)
06:03:59 <ski> zebr : OCaml has equi-recursive types (but only if the cycles goes through an object type, unless you use `ocaml -rectypes'), in case you want to play with it
06:05:56 <zebr> ski: ahh, i didn't know about -rectypes. thanks a lot
06:09:38 <mietek> Why do Haskell binaries built in a Cabal sandbox get symlinked into ~/Library/Haskell/bin?
06:10:08 <ski> @type let take _ [] = []; take n [a:as] = a : take (n-1) as in take
06:10:09 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
06:10:09 <lambdabot>     Expected type: [[a0]]
06:10:09 <lambdabot>       Actual type: [a0]
06:10:42 <ski> ^ that's one kind of problem that wouldn't be caught with equi-recursive types (unless you add an explicit type signature)
06:11:28 <ski> also, if you forget a function argument somewhere, you can easily get `a = String -> a' kind of stuff, which would hide the problem as well
06:12:18 <syllogismos> @type let take _ [] = []; take n (a:as) = a : take (n-1) as in take
06:12:19 <lambdabot> Num a1 => a1 -> [a] -> [a]
06:13:40 <syllogismos> whats the differnece between [a:as] and (a:as) during pattern matching?
06:13:53 <ski> zebr : you can e.g. define `let rec eater : ('a -> 'w) as 'w = fun _ -> eater', or `let fix f = (fun t -> t t) (fun g -> fun x -> f (g g) x)'
06:14:04 <notdan> [a:as] is a list containing one element (which is also a list)
06:14:08 * hackagebot largeword 1.1.0 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.1.0 (DominicSteinitz)
06:14:12 <notdan> (a:as) is a list containing at least one element
06:14:22 <no-n> is there a way to set maximum length of lists that ghci will build?
06:14:36 <ski> syllogismos : `a:as' is the non-empty list starting with the element `a' and continuing with all the (possibly zero) elements of `as'
06:14:40 <syllogismos> ohhh
06:15:07 <ski> syllogismos : `[a:as]' is a list having a single element : namely the list i just described above
06:15:31 <ski> syllogismos : `[a:as]' is the same as `(a:as):[]'
06:15:52 <Iceland_jack> > let [a:as] = [[1,2,3]] in (a, as)
06:15:54 <lambdabot>  (1,[2,3])
06:16:09 <prinsen> I posted a Haskell question to StackOverflow, I would appreciate if someone tries to answer it, http://stackoverflow.com/questions/21967194/haskell-plugins
06:16:10 <ski> writing `[a:as]' (or, often also `[as]') in patterns is a common error newbies often do
06:16:19 <ski> > let a:as = [[1,2,3]] in (a, as)
06:16:21 <lambdabot>  ([1,2,3],[])
06:16:43 <notdan> prinsen: < notdan> prinsen: hm, what if you get of the 'deriving instance' line and just put 'Typeable' next to 'Show'?
06:16:49 <notdan> prinsen: < notdan> prinsen: btw if I were you I would update the post with GHC version, plugins version etc
06:17:02 <ski> (of course, in some cases you really do want to write `[as]', and i suppose it's possible that you do want to write `[a:as]' sometimes as well)
06:17:52 <ski> syllogismos : so, me writing `[a:as]' instead of `a:as' (wrappedd in brackets, for precedence), was the perhaps-somewhat-subtly bug in the code snippet above
06:19:52 <Ivo> you guys seen this? http://pyos.github.io/dg/ :D
06:20:14 <int-e> syllogismos: did you have any exposure to the Clean programming language (it uses [x:xs] as notation for the list cons operator)
06:20:21 <int-e> ?
06:20:45 <zebr> ski: do you think allowing only explicit recursive types would be reasonable? for example, in ocaml i just defined type thunk = term * thunk list; only recursive types that have been named would then be permitted
06:20:56 <zebr> maybe that's a bit weird.
06:21:29 <ski> i would think it's a bit weird, yes
06:21:47 <ski> you can't refactor types as easily, then
06:21:59 <ski> since you can't just substitute equals for equals
06:22:29 <ski> (istr Pascal has something strange like that .. possibly Ada as well)
06:23:45 <zebr> ski: yeah, that's true. i just feel like it would be interesting to program in a language that has type sum, product, and recursion, and no ADTs per se. there doesn't seem to be such a thing though.
06:24:05 <Iceland_jack> > With Haskell's syntax but none of its type system, dg is the best way to make fans of static typing shut up already.
06:24:05 <Iceland_jack> :)
06:24:06 <lambdabot>  <hint>:1:32: parse error on input `of'
06:24:20 <ski> zebr : an alternative is to encode recursive types using universals
06:25:45 <ski>   type thunk = 'o. (term -> 'o list -> 'o) -> 'o;
06:26:38 <zebr> presumably that would be an overapproximation, though? i.e. it's not as strict as the recursive type.
06:26:40 <ski> `mu r. f r' corresponds to `forall r. (f r -> r) -> r', and `nu s. f s' corresponds to `exists s. s * (s -> f s)'
06:27:09 <ski> zebr : iiuc, it can express exactly the same values (at least if we ignore side effects)
06:27:30 <zebr> huh. okay, i'll have to sit down to try and understand that one.
06:28:13 <ski> zebr : for lists, `type List a = mu r. 1 + a * r', we get `type List a = forall r. r -> (a -> r -> r) -> r'
06:29:08 <ski> @type foldr
06:29:09 <lambdabot> (a -> b -> b) -> b -> [a] -> b
06:29:21 <syllogismos> int-e sorry i went away.. theres a programming language called Clean?
06:29:40 <ski> @let foldr_ :: [a] -> forall r. (a -> r -> r) -> r -> r; foldr_ = flip (flip . foldr)
06:29:40 <lambdabot>  Parse failed: TypeOperators is not enabled
06:29:46 <ski> syllogismos : yes, there is
06:30:00 <ski> @type GHC.Exts.build
06:30:01 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
06:31:27 <prinsen> notdan: sry I did not see yo answer
06:31:54 <prinsen> If i put it beside Show, it won't even compile
06:34:57 <AlainODea> prinsen: I retracted my comment. Thank you :)
06:35:52 <AlainODea> prinsen: the nature of the error is object code level.  Does it crash hard?  Is this on GHCi?
06:36:35 <prinsen> AlainODea: Its in an executable as a part of a Yesod project
06:37:04 <prinsen> AlainODea: Yesod seems to catch almost anything so the program doesn't crash
06:37:21 <prinsen> AlainODea: im upgrading the post with package version information
06:37:31 <AlainODea> prinsen: snoyberg may have some insight. I don't know if he's on another side of IRC right now though
06:37:52 <AlainODea> prinsen: is this happening with yesod-platform?
06:39:01 <prinsen> AlainODea: I will create a minimum working example without yesod
06:39:18 <AlainODea> prinsen: awesome. Thank you :)
06:39:57 <Eduard_Munteanu> Is there a reason I should prefer '1 + n = Succ n' over 'n + 1 = Succ n' for inductive naturals? Agda uses the former, but the latter seems nicer.
06:40:39 <Iceland_jack> The former feels more like a function
06:40:39 <Iceland_jack>     1+ ∶ ℕ → ℕ
06:40:39 <Iceland_jack>  
06:40:39 <klrr_> in attoparsec, is there a way of using 'try' on a parser and then make it return Bool so you can see if it failed or succeeded?
06:41:20 <Eduard_Munteanu> Hm, yeah. Although you can make it a suffix function too in Agda, or section (+) in Haskell.
06:41:30 <Eduard_Munteanu> _+1 : N -> N
06:41:37 <Eduard_Munteanu> s/function/operator/
06:41:58 <Eduard_Munteanu> klrr_: 'try' does nothing in Attoparsec, it always backtracks
06:42:58 <Eduard_Munteanu> klrr_: you could 'run' a parser inside a parser
06:43:26 <klrr_> Eduard_Munteanu: yeah but is there any function to check something? i mean i want to parse a few chars and depending what it encounters i wanna apply two different parsers
06:44:02 <klrr_> that is, it checks for two chars, depending on which it encounter first it does two different things
06:44:18 <Algebr> Say I define a type that only has one value constructor, then it is almost always the case that the value constructor should have the same name as the type?
06:44:19 <Eduard_Munteanu> klrr_: use <|>... parseA <$ char 'a' <|> parseB <$ char 'b'
06:44:35 <ski> Eduard_Munteanu : ⌜(1 + m) · n⌝ goes nicely with ⌜n + (m · n)⌝ and ⌜1 · n = n⌝, while ⌜(m + 1) · n⌝ goes better with ⌜(m · n) + n⌝ and ⌜n · 1 = n⌝
06:44:52 <Eduard_Munteanu> Algebr: not necessarily, but it does seem common for newtypes
06:45:11 <klrr_> Eduard_Munteanu: okey, thanks
06:45:25 <Algebr> Eduard_Munteanu: Thanks, also why can't get the type of a type?
06:45:41 <Eduard_Munteanu> Algebr: you mean the kind? You get it with :k in ghci
06:45:51 <Eduard_Munteanu> ski: interesting... I regard n + 1 and 1 * n as "natural".
06:45:53 <Algebr> Eduard_Munteanu: Ah, I didn't even know about that, thanks!
06:46:21 <ski> Algebr : i prefer the pattern `newtype Foo = MkFoo (...)' (or `MakeFoo'), or `newtype Foo = MkFoo {unFoo :: ...}' (or sometimes `runFoo' or `applyFoo' or something similar, instead of `unFoo')
06:47:10 <ski> Eduard_Munteanu : of course, if you define multiplication by induction on the right argument, the picture changes
06:47:31 <Algebr> Eduard_Munteanu: What's the equivalent way to do :t <something> inside of a function, like putStrLn :t <something>
06:48:04 <ski> Eduard_Munteanu : but if you start from the engligh "`m' times `n'" (being equal to "`n', `m' times"), then it might make more sense to induct on the left argument
06:48:17 <Algebr> Basically looking for the python equivalent of putting a print type([]) in a function body
06:48:27 <Eduard_Munteanu> ski: on the right arg? I find it more intuitive to recurse on the left one, like math notation prefers 'c * n = (c - 1) * n + n' for constant 'c'.
06:49:01 <ski> Algebr : it would be nice if you could "step" into a function definition, and query for types of local variables, but i don't think GHCi supports that
06:49:07 <Eduard_Munteanu> Algebr: you could just 'show' it, it should be unambiguous for most things
06:49:21 <Eduard_Munteanu> > show (Just ())
06:49:23 <lambdabot>  "Just ()"
06:49:32 <ski> Algebr : possibly it does in case you use breakpoints, and let those suspend evaluation inside the function
06:49:46 <Algebr> ski: But I mean in a regular Haskell program, not while playing with ghci
06:50:05 <ski> Algebr : so, not for debugging purposes ?
06:50:18 <ski> > typeOf (Just ())
06:50:20 <lambdabot>  Maybe ()
06:50:22 <Eduard_Munteanu> > show (typeOf (Just ())
06:50:23 <lambdabot>  <hint>:1:23:
06:50:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:50:30 <Eduard_Munteanu> Er, that.
06:50:30 <ski> > show (typeOf (Just ()))
06:50:31 <lambdabot>  "Maybe ()"
06:50:39 <Algebr> ski: Yea, not for debugging, I guess like logging?
06:51:04 <ski> Algebr : not quite sure why you want to print the type, but try `typeOf' ?
06:51:25 <AlainODea> Algebr: Debug.Trace.traceShow?
06:51:34 <haasn> traceShow is for debugging
06:51:35 <haasn> *not* production
06:51:38 <Eduard_Munteanu> Algebr: for a lot of usecases, types are pretty well defined at compile-time
06:51:44 <ski> AlainODea : also, doesn't show the type
06:51:54 <Algebr> Neat, thanks all!
06:52:02 <Eduard_Munteanu> They don't even exist at runtime, except typeclass dictionaries can represent them.
06:52:12 <ski> Algebr : typically, there will only be a single type that the thing has anyway, so it won't vary at run-time
06:52:36 <ski> Algebr : well, it *can* vary, if you use `Typeable' constraints or similar, but not otherwise
06:52:50 <AlainODea> ski: but the types are erased by design. Is it even possible to achieve?
06:54:13 <Eduard_Munteanu> AlainODea: consider existential wrappers... in such cases the types are still erased but you can "trace" them back from typeclass constraints
06:54:18 <haasn> Typeable doesn't get erased
06:54:31 <haasn> but it also relies on you shutting your eyes and relying on GHC implementing it correctly
06:54:44 <haasn> (is it actually possible to write Typeable instances manually yet? What happened to auto-typeable?)
06:54:52 <haasn> s/yet/right now/
06:55:11 <Eduard_Munteanu> haasn: deriving Typeable?
06:55:50 <Eduard_Munteanu> It should be even nicer now with PolyKinds.
06:56:56 <haasn> Eduard_Munteanu: auto-typeable as in “typeOf :: a -> TypeRep”
06:57:13 <AlainODea> Eduard_Munteanu: interesting. That sounds like a similar approach that manifests achieve for reifying generics as needed in Scala.
06:57:20 <haasn> or “instance Typeable a”; basically, making it work for every single type, by default, without even having to write “deriving Typeable”
06:57:34 <haasn> I remember some discussion about this but I'm not sure what ever happened
06:57:34 <ski> AlainODea : yes, the constraint can carry a representation of the type at run-time
06:57:37 <Eduard_Munteanu> haasn: ah, yeah, I think that should work with Generics
06:57:59 <Eduard_Munteanu> And the 'default' thing.
06:58:30 <AlainODea> ski: good to know. I'll keep that in mind.
06:58:34 <mietek> It appears "cabal repl" doesn't work with a sandbox created without a .cabal file
06:58:39 <mietek> Is this right?
06:58:39 <ski> haasn : `typeOf :: forall a. a -> TypeRep' would break parametricity
07:00:11 <haasn> ski: ah, right, I think that is the verdict that was reached
07:00:17 <Eduard_Munteanu> AlainODea: class IAmA t where whoami :: String; instance IAmA () where whoami = "()"  ... ; data Something = forall t. (IAmA t) => Something t; youCanCallWhoamiOnThese = [(), Just True]
07:00:32 <Eduard_Munteanu> Er.
07:00:38 <haasn> ski: the compromise would be typeOf :: Typeable a => a -> TypeRep -- but still have ‘Typeable a’ always resolve?
07:00:38 <ski> haasn : e.g., such an operation exists in Mercury
07:00:41 <Eduard_Munteanu> [Something (), Something (Just True)]
07:00:47 <ski> (Mercury has type classes)
07:00:53 <mietek> Does "cabal repl" even work?
07:01:00 <ski> haasn : maybe
07:01:09 <ski> haasn : i wonder whether it would work for skolems
07:01:33 <skypers> dammit
07:01:57 <skypers> using typeclasses everywhere leads to some issues
07:02:00 <skypers>     Could not deduce (monad-control-0.3.2.3:Control.Monad.Trans.Control.MonadBaseControl
07:02:03 <skypers>                         IO m)
07:02:06 <skypers> I don’t know how to solve that
07:02:21 <prinsen> AlainODea: I have a small working example now, however I have to leave home. How do I send you the code?
07:02:26 <mietek> Ah, "ghci -no-user-package-db -package-db .cabal-sandbox/*.conf.d"
07:02:43 <Eduard_Munteanu> skypers: sounds like you're missing a constraint on a function type
07:02:51 <skypers> hm
07:03:10 <skypers> well here, it should default m to IO
07:03:15 <bennofs> skypers: add a MonadBaseControl IO m constraint?
07:03:27 <skypers> bennofs: where?
07:03:31 <skypers> it’s in my code
07:03:32 <skypers> like
07:03:44 <skypers> like in runEitherT $ theFunction
07:03:45 <AlainODea> prinsen: http://lpaste.net/new/haskell or github repo are easiest ways I can think of
07:03:48 <Eduard_Munteanu> skypers: it can't default if it's a polymorphic 'm' that doesn't have that constraint
07:04:08 <skypers> hm
07:04:11 <skypers> dammit then
07:04:12 <skypers> :)
07:04:18 <bennofs> skypers: runEitherT $ theFunction is probably in a do-block. What is the type of the do-block?
07:04:27 <bennofs> skypers: or do you type it at ghci?
07:04:35 <skypers> it’s compiled
07:04:43 <AlainODea> prinsen: it's no rush, just ping me here once it's ready and I'll take a look :)
07:04:52 <Algebr> Is :kind supposed to print anything useful? I used it on my defined type and just got back Shape :: *, what is the * mean?
07:05:04 <skypers> well I think I got the issue
07:05:07 <skypers> gonna try something else
07:05:12 <Eduard_Munteanu> skypers: if f calls g and g needs MonadBaseControl IO m, then so does f
07:06:06 <Eduard_Munteanu> Algebr: it's the kind of concrete types (types which are inhabited), as opposed to e.g. Maybe :: * -> *
07:06:38 <skypers> I think it’s not that great using typeclasses everywhere
07:06:38 <Eduard_Munteanu> Note  Maybe Bool  is inhabited, but  Maybe  isn't.
07:06:45 <skypers> it defers the implementation to the user
07:06:52 <skypers> and then exposes a lot of stuff to do
07:07:28 <Eduard_Munteanu> skypers: not really, it also makes transformers less dependent on the actual application order.
07:07:43 <skypers> Eduard_Munteanu: this is a good thing, right?
07:07:55 <Eduard_Munteanu> skypers: yeah ... you might want a constraint synonym if you find it hard to type.
07:08:13 <skypers> I already have constraint synonym
07:08:17 <skypers> but for instance
07:08:22 <skypers> I have MonadFailure m
07:08:31 <skypers> that is a synonym of MonadError MyErrorType m
07:08:40 <skypers> when I want to launch a function with that constraint
07:08:46 <skypers> I wrap it in a runEitherT
07:08:49 <skypers> and it’s great!
07:08:55 <Eduard_Munteanu> Yeah, that's reasonable.
07:09:06 <skypers> now, how should I do with MonadBaseControl?
07:09:09 <skypers> wrap it… ?
07:09:52 <Eduard_Munteanu> skypers: no, you just call it, and it should get instantiated to IO, like liftIO
07:10:02 <Eduard_Munteanu> :t liftIO
07:10:03 <lambdabot> MonadIO m => IO a -> m a
07:10:13 <Eduard_Munteanu> :t liftIO (putStrLn "Hi")
07:10:14 <lambdabot> MonadIO m => m ()
07:10:17 <Eduard_Munteanu> :t liftIO (putStrLn "Hi") :: IO ()
07:10:18 <lambdabot> IO ()
07:10:21 <Eduard_Munteanu> skypers: ^
07:10:23 <skypers> I know that
07:10:26 <skypers> but hm
07:10:30 <skypers> wait
07:10:59 <Eduard_Munteanu> skypers: of course, you have to call the run* unwrappers for transformers first
07:11:05 <skypers> geometry :: (MonadIO m, MonadFailure m, MonadBaseControl IO m) => [Vertex] -> m Geometry
07:11:09 <skypers> how could I run that?
07:11:18 <skypers> MonadIO m is quite easy
07:11:23 <skypers> MonadFailure -> runEitherT
07:11:34 <skypers> then if I wrap that in a runEitherT
07:11:38 <skypers> it should run, right?
07:11:38 <Eduard_Munteanu> skypers: runEitherT (geometry ...)
07:11:41 <Eduard_Munteanu> Yes.
07:11:44 <skypers> yes
07:11:45 <skypers> well no.
07:11:47 <skypers> :(
07:12:04 <skypers> I get a nasty error
07:12:11 <Eduard_Munteanu> What is it?
07:12:26 <skypers>     Could not deduce (monad-control-0.3.2.3:Control.Monad.Trans.Control.MonadBaseControl
07:12:29 <skypers>                         IO m)
07:12:42 <skypers> maybe I should include MonadBaseControl IO m in the constraint of the calling function?
07:12:47 <skypers> but that’s quite ugly…
07:12:49 <Eduard_Munteanu> skypers: pastebin it, I need more context
07:12:50 <bennofs> skypers: try runEitherT (geometry) :: IO ()
07:12:59 <skypers> I can’t bennofs
07:13:06 <skypers> I run that in a more complex monad
07:13:08 <skypers> ok, wait
07:13:22 <Eduard_Munteanu> skypers: you "run" it how? Is the caller also polymorphic?
07:13:33 <skypers> Eduard_Munteanu: http://lpaste.net/1675701595276312576
07:13:37 <skypers> yes, Eduard_Munteanu
07:13:38 <skypers> it is
07:14:08 <Eduard_Munteanu> skypers: is app the caller?
07:14:20 <skypers> yes
07:14:25 <skypers>     triangle <- runEitherT $ geometry vertices
07:14:28 <skypers> it’s in app
07:14:52 <Eduard_Munteanu> skypers: you should be using MonadBase rather than mixing in MonadIO
07:14:54 <bennofs> skypers: then you need a MonadBaseControl IO m constraint on app
07:15:22 <Eduard_Munteanu> skypers: you could liftIO 'geometry' but that instantiates it to IO
07:16:02 <Eduard_Munteanu> Probably not an issue for you though.
07:16:17 <bennofs> right, liftIO $ runEitherT $ geometry ... should work too
07:17:30 <skypers> yes, it works
07:17:31 <skypers> thank you
07:17:43 <skypers> I don’t want to expose monad-control to the user
07:17:50 <skypers> it’s enough filfthy… :D
07:18:06 <Eduard_Munteanu> skypers: IMO it's nicer if you do
07:18:22 <skypers> Eduard_Munteanu: it doesn’t work anyway
07:18:34 <skypers> putting the MonadBaseControl IO m in the constraint
07:18:54 <Eduard_Munteanu> skypers: the user can call it as an ordinary IO function, instantiating 'm' to IO.
07:19:21 <Eduard_Munteanu> skypers: likely because other stuff in there needs lifting
07:19:31 <bennofs> skypers: probably because the JournalT monad transformer doesn't have a Monad m => MonadBaseControl m instance?
07:19:41 <skypers> Eduard_Munteanu: I’m wondering if it’s a good idea. In my lib I designed all around MonadIO and other typeclasses
07:19:44 <bennofs> Or some other monad transformer in your stack
07:19:46 <skypers> I’m not sure it’s that great
07:19:53 <skypers> 16:18 < bennofs> skypers: probably because the JournalT monad transformer  doesn't have a Monad m => MonadBaseControl m instance?
07:19:56 <skypers> indeed
07:20:01 <skypers> I should add it
07:20:32 <Eduard_Munteanu> skypers: it's annoying to write IO-polymorphic functions calling plain IO functions, but the other way around it's more manageable
07:20:59 <skypers> what do you mean?
07:21:18 <skypers> I should change my MonadIO code to IO?
07:21:30 <Eduard_Munteanu> skypers: no...
07:21:34 <skypers> the thing that is great with doing things that way is that I can “list features” as constraints
07:21:37 <skypers> I like that
07:21:39 <skypers> you read the constraint
07:21:47 <skypers> and you know that it’s going to do some IO and logging stuff
07:21:56 <skypers> for example for (MonadIO m, MonadLogger m)
07:22:09 <Eduard_Munteanu> skypers: I'm saying the caller has no trouble if it treats them as normal IO functions, it's only difficult for you to call normal IO functions because you need to lift them
07:22:20 <skypers> yeah
07:22:21 <Eduard_Munteanu> Yeah, that's nice.
07:22:42 <Eduard_Munteanu> skypers: however try not to abuse constraint synonyms
07:23:25 <Eduard_Munteanu> skypers: you might like the 'lifted-base' package, btw
07:23:52 <Eduard_Munteanu> @hackage lifted-base
07:23:53 <lambdabot> http://hackage.haskell.org/package/lifted-base
07:24:45 <skypers> :)
07:24:46 <skypers> ok so
07:24:49 <skypers> for my function
07:24:52 <skypers> I need an instance for
07:25:06 <skypers> instance (Monad m) => MonadBaseControl m (JournalT m) where
07:25:07 <skypers> right?
07:27:24 <Eduard_Munteanu> skypers: instance (MonadBaseControl b m) => MonadBaseControl b (JournalT m) where
07:27:46 <skypers> huhu
07:27:47 <skypers> ok :D
07:29:35 <Eduard_Munteanu> skypers: think about MonadIO...  instance (MonadIO m) => MonadIO (JournalT m) where
07:29:37 <hunt> hey haskell i need some help
07:29:42 <hunt> if you guys have the time
07:29:43 <Eduard_Munteanu> hunt: hi
07:29:51 <Eduard_Munteanu> If you ask a question. :)
07:29:57 <hunt> i have two functions
07:30:07 <hunt> one of them takes a bunch of integrals and makes a list of integrals
07:30:17 <hunt> and the other takes a string and parses out a list of Integers
07:30:20 <Iceland_jack> bunch of integrals = list of integrals?
07:30:21 <hunt> because it uses read
07:30:38 <hunt> oh no sorry just a few different integral arguments
07:30:42 <Iceland_jack> I see
07:30:47 <hunt> anyways
07:31:12 <hunt> i cant find a way to use the parse function in the other function
07:31:28 <hunt> and maintain everything as integrals
07:31:41 <Iceland_jack> Can you give us the type signatures of the functions?
07:31:51 <hunt> parseComs :: Integral a => (a,a,a) -> [String] -> [(a,a,(a,a,a))]
07:31:58 <hunt> readInts :: String -> [Integer]
07:32:30 <Iceland_jack> Seeing something like [(a, a, (a, a, a))] is a red flag
07:32:43 <Eduard_Munteanu> hunt: so you'd like an Integral type instead of Integer?
07:32:55 <hunt> yea! but read is tricky
07:33:04 <hunt> thats an x, y, color
07:33:21 <hunt> im relatively new to haskell so ill get to a better solution as i learn more i think
07:33:24 <Eduard_Munteanu> hunt: you'll have to put a Read constraint not only on readInts but on the others too
07:33:25 <Iceland_jack> You should later on create an actual datatype for that
07:33:44 <hunt> yea i havent gotten up to my own data types yet but i would
07:33:54 <hunt> does that eman that
07:34:03 <hunt> in other functions that are receiving the parsed data
07:34:10 <hunt> they also need to use the Read typeclass
07:34:23 <Iceland_jack> :t map read :: (Read a, Integral a) => [String] -> [a]
07:34:24 <lambdabot> (Integral a, Read a) => [String] -> [a]
07:34:24 <bennofs> hunt: you could define a data type Color a = Color { red :: a, green :: a, blue a } (Or other fields if you use a different format) and a data type Position and then you can write Color a -> [String] -> [(Position a, Color a)]
07:34:26 <Eduard_Munteanu> hunt: in functions polymorphic in that type that call readInts
07:34:48 <Eduard_Munteanu> Directly or indirectly.
07:35:19 <hunt> damn that seems sort of incompatible with my project
07:35:28 <Iceland_jack> What does?
07:35:29 <Eduard_Munteanu> hunt: why?
07:35:38 <hunt> adding the read type to all these functions
07:35:40 <hunt> for example
07:36:02 <hunt> i have a function drawLine that takes two (x,y) Integrals and creates a list of positions for the line
07:36:10 <Eduard_Munteanu> hunt: when you settle on a particular type, you don't need the constraint anymore
07:36:24 <Iceland_jack> Not to mention that patrameterizing Position and Colour with the same Integral feels odd
07:36:37 <hunt> it seems like bad practice to me
07:36:46 <hunt> but i hvent learnt custom data types yet
07:36:47 <Iceland_jack> So if you want to restrict your colours to Word8 the coordinates must also be Word8s?
07:36:51 <hunt> so i think its my best option
07:37:27 <hunt> well i think im certain that my colours are integrals
07:37:29 <Iceland_jack> How about you get it working with fixed types hunt?
07:37:37 <Eduard_Munteanu> Ok, that's a bit odd, usually data declarations are introduced before typeclasses.
07:37:47 <hunt> im not sure im following
07:37:53 <Iceland_jack> It seems like you're biting off a bit more than you can chew
07:38:05 <hunt> whys that?
07:38:06 <Iceland_jack> for example using
07:38:06 <Iceland_jack>     type Colour = (Int, Int, Int)
07:38:06 <Iceland_jack>  
07:38:14 <Iceland_jack> Because you're having trouble
07:38:20 <hunt> oh sure
07:38:25 <hunt> but ive been having trouble since the start
07:38:28 <Iceland_jack> :)
07:38:32 <hunt> this is meant to help me learn
07:38:39 <Eduard_Munteanu> hunt: anything in particular?
07:38:43 <hunt> haskell
07:38:46 <Eduard_Munteanu> :)
07:38:47 <hunt> lol
07:38:49 <Iceland_jack> hunt: Can you implement the desired functionality without polymorphism?
07:39:01 <hunt> yea but i feel icky doing that
07:39:17 <hunt> i feel like i SHOULD be able to use Integrals and not have to cope with this stuff
07:39:28 <Iceland_jack> Why? Why do you need coordinates to be polymorphic?
07:39:36 <Eduard_Munteanu> Yes, it would work.
07:39:54 <hunt> no but I don't think i should limit the accepted data types when i dont have to
07:40:01 <hunt> so what am i missing?
07:40:08 <hunt> is there a concept i need to learn
07:40:14 <hunt> in order to get this to work with Integrals
07:40:51 <Eduard_Munteanu> hunt: you could avoid tying the parsing and computational aspects together, so you don't need Read everywhere
07:41:26 <Eduard_Munteanu> hunt: that is, keep the 'read'-ing separate
07:42:08 <hunt> im not sure i understand how thats possible
07:42:17 <hunt> are you saying parse in one block and process in another?
07:42:30 <Iceland_jack> hunt: The functions that compute your data don't need to know that it's readable, just that it's an Integral
07:42:41 <Iceland_jack> *work on your
07:42:48 <Eduard_Munteanu> hunt: make your functions work on those Integrals, without expecting String input
07:42:56 <hunt> well
07:43:05 <hunt> the parser is pretty much decoding the string input
07:43:13 <hunt> and passing the integrals into other functions
07:43:16 <hunt> and my difficulty
07:43:19 <hunt> is that i cant get integrals
07:43:23 <hunt> from the decoded strings
07:43:57 <Eduard_Munteanu> hunt: you can't read polymorphic things
07:44:11 <hunt> so do i have to restrict the other functions to static types
07:44:11 <Eduard_Munteanu> Unless they're instances of REad.
07:44:16 <Iceland_jack> hunt: Let's say you have a parser that parses into an Int (which is an Integral)
07:44:16 <Iceland_jack>     parse   :: String -> Int
07:44:16 <Iceland_jack> then you can easily pass it to a function process
07:44:16 <Iceland_jack>     process :: Integral a => a -> ...
07:44:19 <AlainODea> hunt: that's quite difficult.  At some point your code needs to statically know the actual type of the Integral to read it in
07:44:22 <Iceland_jack> by
07:44:22 <Iceland_jack>     process (parse "4")
07:44:31 <Eduard_Munteanu> hunt: no, but you can expect the user to call the reading function himself, and settle on a particular Integral
07:44:47 <bennofs> yes, the processing functions can be polymorphic, but the parsers need to produce a concrete type
07:45:13 <hunt> alright
07:45:17 <hunt> let me see if i can work with that
07:45:19 <hunt> thanks guys
07:45:33 <AlainODea> hunt: good hunting :)
07:45:39 <hunt> :)
07:48:20 <f7o> hay there..
07:50:04 <AlainODea> f7o: hello
07:55:47 <int-e> Hmm, is there a viable update path away from MonadCatchIO towards something based on catch/mask?
07:57:36 <bennofs> int-e: lifted-base maybe?
07:59:20 * hackagebot sized-vector 1.3.0.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.3.0.0 (HiromiIshii)
07:59:22 * hackagebot type-natural 0.1.0.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.1.0.0 (HiromiIshii)
07:59:38 * carter ocharles: yo
08:00:14 <ocharles> hey carter
08:00:20 <ocharles> carter: shall we move to #haskell-overflow?
08:00:24 <carter> ocharles: you there?
08:00:28 * carter there was a net split in the past 12 hours?
08:00:30 <carter> ocharles: hey!
08:00:31 <carter> no, we shall move to #numerical-haskell
08:00:32 <carter> :)
08:00:34 <ocharles> ok :)
08:00:44 <carter> because my ffi singletons stuff is in my blas ffi :)
08:00:57 <onionboy> #haskell
08:01:25 <geekosaur> there were still occasional netsplits going on 10 hours ago
08:01:27 <shiona_> Umm.. "Ambiguous module name `Control.Monad.Writer.Lazy': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2", any help?
08:01:42 <geekosaur> ghc-pkg hide monads-tf
08:02:20 <shiona_> Could I remove it, or is there a reason for this situation?
08:03:18 <ocharles> shiona_: what are you running that causes that error?
08:03:28 <ocharles> I usually '-hide-package monads-tf-0.1.0.1' in that scenario
08:03:44 <geekosaur> we have no way of knowing why it's installed
08:03:47 <Cale> shiona_: Probably monads-tf got installed as a dependency of something else. Just hiding it won't hurt anything and will solve the problem.
08:04:02 <int-e> bennofs: thanks (though it won't help in my particular case; I'm wondering on how to adapt ghc-mtl, which currently maps ghc:Exception.ExceptionMonad to MonadCatchIO, but with ghc 7.8, ghc:ExceptionMonad will have methods gcatch, gmask.)
08:04:14 <shiona_> "import Control.Monad.Writer.Lazy" is what's causing this
08:04:18 <shiona_> and thanks
08:15:39 <skypers> gosh, too much code, blog writing and thinking for today :)
08:16:50 <hunt> i got it boys
08:17:21 <Eduard_Munteanu> There are girls in here too. :)
08:18:00 <adm_> indeed
08:18:14 <Eduard_Munteanu> You just can't see through the existential nicknames. :P
08:18:39 <hunt> i got it beings
08:19:45 <klrr_> i have some problems with sepBy in attoparsec, any idea how i would write this correctly? https://gist.github.com/klrr/c53d1f83aa9be4f2bbbd#file-decode-hs-L77 (code and error is in paste)
08:21:19 <Eduard_Munteanu> klrr_: you have the wrong kind of bytestring there
08:21:57 <klrr_> Eduard_Munteanu: so the logic in the params parser is correct?
08:22:52 <Eduard_Munteanu> klrr_: yeah, though instead of notInClass it should be faster to use isEndOfLine
08:23:16 <Eduard_Munteanu> klrr_: actually, you might want takeWhile1
08:23:38 <Eduard_Munteanu> Or sepBy1.
08:23:39 <klrr_> does all IRC messages have parameters though?
08:23:59 <klrr_> i want it to be [] in case there is none
08:24:07 <Eduard_Munteanu> Ah.
08:24:47 <Eduard_Munteanu> klrr_: mind takeWhile will try to take space and ':' too
08:25:14 <klrr_> oh so it should be (notInClass " :\r\n")?
08:26:12 <Eduard_Munteanu> klrr_: that or \c -> not (isEndOfLine c || c == ':' || c == ' ')
08:27:15 <Eduard_Munteanu> klrr_: regarding the bytestring, you're using the normal Word8 flavor but the parser operates on Char8
08:27:39 <klrr_> Eduard_Munteanu: is there two different strict ByteStrings?
08:27:51 <Eduard_Munteanu> klrr_: sure
08:27:57 <klrr_> o.o
08:28:06 <klrr_> soo many strings, lol :P thanks for the catch
08:29:06 <Eduard_Munteanu> klrr_: the usual one gives you Word8, the other operates on Char-s converted from Word8 (basically affords you a quick and dirty latin1)
08:31:31 <davison> Wondering what the best option is for getting up to speed with Haskell ?  Friend suggested LYAH, but looking for a larger sample size.  Have access to LYAH, Real World, Programming in Haskell, Haskell School of Expression...and as for web help, Hitchikers Guide and Learn the Hard Way
08:31:59 <davison> Have experience of several other languages, but no functional languages, if it makes a difference to the suggestion
08:32:36 <adm_> davison: LYAH + RWH did it for me
08:32:58 <Eduard_Munteanu> davison: probably LYAH to show you the way generally and other resources for specific topics... say wikibooks or the (not-so-) Gentle Introduction.
08:33:38 <klrr_> davison: start with LYAH and then perhaps read the yesod book if you into web dev
08:33:42 <Eduard_Munteanu> Or as references, I should say.
08:33:43 <Cubic_> davison: I learned with RWH, I can confirm that LYAH is pretty good though
08:34:00 <klrr_> also: Write Yourself a Scheme in 48 Hours
08:35:04 <Eduard_Munteanu> Also Googling around or looking at the Haskell Wiki can be quite helpful for specific topics once you're comfortable enough.
08:35:42 <Cubic_> Does the hs-plugins package work with GHC-7.6.*? I'm trying something that I'm almost sure should work, but it doesn't... I always get Prelude.undefined instead of a LoadError though
08:36:07 <klrr_> i would suggest just read LYAH and then start writing a program and use google
08:36:46 <geekosaur> my understanding is plugins is kinda on the way out, as the ghc api has everything needed now (although not yet convenient to use, apparently)
08:36:52 <klrr_> when you are comfortable, look into lenses, pipes, frp etc.
08:38:33 <davison> Right now it's mostly going to be for math based work;  Web dev isn't a big area of interest at the moment.  Thanks for the recommendations.
08:40:29 <klrr_> i wish cabal could uninstall packages :s
08:41:09 <klrr_> is there a way to specify what version of packages to use when you run ghci?
08:41:21 <klrr_> if you dont wanan createa a .cabal
08:41:45 <navaati> hi
08:41:48 <Eduard_Munteanu> klrr_: you can't really have multiple versions installed
08:42:09 <enthropy> klrr_: use some combination of -package -hide-package and -hide-all-packages
08:42:17 <enthropy> which is what cabal does
08:42:18 <navaati> what is the name of the lib enabling one to manipulate symbols for learning purpose, like that :
08:42:39 <navaati> > foldl (+) a [b, c, d]
08:42:41 <lambdabot>  a + b + c + d
08:42:54 <navaati> > scanl (+) a [b, c, d]
08:42:54 <lambdabot>  [a,a + b,a + b + c,a + b + c + d]
08:43:18 <navaati> :t a
08:43:19 <lambdabot> Expr
08:43:22 <klrr_> Eduard_Munteanu: i hate several versions of bytestring installed
08:43:36 <klrr_> enthropy: okey
08:43:43 <klrr_> s/hate/have
08:44:07 <Eduard_Munteanu> klrr_: consider using cabal-dev (or perhaps sandbox)
08:45:54 <klrr_> Eduard_Munteanu: i go with cabal-dev, my qusetion though was more if there was a way *wihtout* having to setup a complete project, e.g. if you just wanna test a file
08:46:29 <Eduard_Munteanu> klrr_: try keeping your user cabal prefix clean then
08:47:32 <sipa> > f
08:47:34 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
08:47:34 <lambdabot>    arising from a use of `e_1'
08:47:34 <lambdabot>  The type variable `a0' is ambiguous
08:47:34 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:47:34 <lambdabot>  Note: there are several potential instances:
08:47:49 <sipa> navaati: ^ that gives a hint, maybe
08:48:00 <klrr_> Eduard_Munteanu: how do i do that?
08:49:30 <klrr_> anyone know what can cause this runtime linker error? https://gist.github.com/klrr/5b486cac87c015a227f0
08:57:43 <dagle> So nice when people doesn't document their json syntax and what values are allowed to be null... a part of me wanna say Maybe on all types...
08:57:59 <dagle> s/syntax/format/
09:02:08 <navaati> sipa, ah, yup, thanks
09:02:20 <navaati> @hoogle Debug.SimpleReflect.Expr
09:02:21 <lambdabot> package expression-parser
09:02:22 <lambdabot> package attoparsec-expr
09:02:22 <lambdabot> package boolexpr
09:18:58 <onionboy> quit
09:26:11 <ReinH> ahhh recovered from the netsplit
09:28:32 <antithesis> Is there any book that teaches a newbie Haskell in the style of The Little Schemer?
09:32:16 <notdan> I am not sure. The Little Schemer is a very unique book by a great pedagogue of FP/Lisp.
09:32:24 <notdan> You can try Learn You a Haskell
09:32:26 <notdan> @where lyah
09:32:26 <lambdabot> http://www.learnyouahaskell.com/
09:32:45 <klrr_> can someone explain why i get these type errors http://paste.ubuntu.com/6982830/ ? here's the code http://paste.ubuntu.com/6982828/
09:32:46 <antithesis> I hear that that one is very different from The Little Schemer
09:33:39 <notdan> antithesis: well it is similar in that it takes a "fun" approach, with cute images and informal (but rigorous and deep) presentation
09:34:32 <f7o> just a dummy question.. are many of you using xmonad on your productiv dev system
09:34:56 <dv-> klrr_: you need parens around try
09:35:06 <Eduard_Munteanu> f7o: I am.
09:35:56 <dwcook> Parens around (serv bs0), I imagine
09:36:36 <dwcook> But since it looks like you're using Attoparsec's try, try is just id anyway
09:36:36 <dv-> try (serv bs0 <|> nick bs0) no?
09:36:57 <dwcook> In Parsec, try is often used like this: try firstParser <|> secondParser
09:37:05 <dv-> oh no you're right yeah
09:37:14 <dwcook> But here you don't even need the try
09:37:20 <dwcook> I think someone mentioned this earlier in fact
09:37:43 <Eduard_Munteanu> I remember mentioning it, yes. :)
09:39:01 <drjfreeze> Anyone know how to get around this error on mac: Could not find module `System.PosixCompat.Files'
09:39:19 <f7o> Eduard_Munteanu: kay.. i'm just started to switch.. cause i want to switch to haskell in some case..so xmonad could be a good practical start..
09:39:58 <Eduard_Munteanu> f7o: xmonad configuration isn't a great way to learn Haskell, if that's what you intend to do
09:40:37 <Eduard_Munteanu> klrr_: you're missing a 'map' in params
09:40:48 <Eduard_Munteanu> klrr_: you fmap only once
09:41:26 <Eduard_Munteanu> I'd write it like   params = map dec <$> p   though.
09:43:07 <f7o> Eduard_Munteanu: ok.. first i'll learning basics and so will see.. except scheme i never did fuctional things.. but c++ every day.. just sucks..and i never need such performance
09:43:32 <ReinH> Eduard_Munteanu: Hmm, I'm also ok with: fmap (fmap dec) p
09:44:32 * hackagebot cabal-bounds 0.1.2 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.2 (DanielTrstenjak)
09:55:01 <klrr_> Eduard_Munteanu: oh, thanks! :)
10:01:08 <Eduard_Munteanu> Huh...
10:01:33 <Eduard_Munteanu> Why is   data Foo s k = Foo k   not promotable but   data Foo s k = Foo (s -> k)   is?
10:02:02 <johnw> the fact that the first is using a phantom?
10:02:14 <Eduard_Munteanu> Well, yeah, but why is it a problem?
10:02:28 <johnw> did you paste the error?
10:04:52 <Eduard_Munteanu> data Foo s k = Foo k   class Test (x :: Foo s k)    instance ('Foo '() Bool)
10:04:55 <supki_> drjfreeze: you'd need to install the unix-compat package
10:05:26 <Eduard_Munteanu> johnw: `Foo' of kind `forall (k :: BOX). k -> * -> *' is not promotable
10:05:40 <drjfreeze> supki_: Thanks. Now I get Could not find module `Control.Exception.Extensible'
10:06:36 <supki_> @hoogle Control.Exception.Extensible
10:06:36 <lambdabot> Control.Exception.Extensible module Control.Exception.Extensible
10:06:36 <lambdabot> package extensible-data
10:06:36 <lambdabot> package extensible-exceptions
10:06:39 <supki_> ;)
10:07:15 <monochrom> then perhaps, in "Foo s k", the kind of s is not inferred to be *
10:07:30 <monochrom> therefore perhaps, "data Foo (s :: *) k = Foo k" works better
10:07:37 <Eduard_Munteanu> monochrom: why would it matter?
10:07:44 <monochrom> I do not know
10:08:57 <Eduard_Munteanu> This also triggers it: data Foo s = Foo
10:09:55 <Eduard_Munteanu> monochrom: what would the '*' be in the promoted kind? :/
10:10:30 <monochrom> I do not know
10:10:58 <drjfreeze> Anyone here know about github-backup?
10:10:58 <drjfreeze> https://gist.github.com/jfreeze/9174964
10:10:58 <Eduard_Munteanu> When one wants '*' in a lifted type usually it's accomplished by passing it into one of the parameters, like   data Foo hask = Foo (hask -> hask)   ... Foo * ...
10:12:12 <Eduard_Munteanu> monochrom: indeed, data Foo (s :: *)... works but I have no clue why.
10:12:55 <Eduard_Munteanu> :k 'Foo   gives   'Foo :: Foo *
10:12:56 <lambdabot> parse error on input `::'
10:15:17 <Eduard_Munteanu> "We do not promote datatypes whose constructors are kind polymorphic, involve constraints, or use existential quantification."
10:15:23 <Eduard_Munteanu> I could've sworn that worked :/
10:16:44 <Eduard_Munteanu> Oh, it can be a kind variable, if at the call site it's monomorphic, I think.
10:17:16 <mm_freak_> Eduard_Munteanu: we never had sort polymorphism, kind classes or kind existentials ;)
10:17:41 <Eduard_Munteanu> I know, yeah.
10:18:10 <Eduard_Munteanu> I thought variables all go into BOX
10:18:39 <Eduard_Munteanu> And you also can't apply stuff, no BOX -> ...
10:21:24 <Algebr> Having to do something like fst $ head [("a", "B"] or fst (head [("a", "b")] is really annoying. Am I not thinking the haskell way or is this just a silly part of the language
10:21:38 <Algebr> err, [("a", "B")]
10:21:39 <Eduard_Munteanu> mm_freak_: btw, mind this works:  data Foo = forall s. Foo s   , perhaps confusingly
10:21:49 <pranz> Algebr: fst.head $ ..
10:22:30 <Algebr> pranz: Whoa, what is that dot syntax called? Its not function composoition right
10:22:35 <Eduard_Munteanu> Algebr: 'head' and other partial functions are best avoided... why do you need it?
10:22:46 <Eduard_Munteanu> It is.
10:23:19 <Algebr> Eduard_Munteanu: Just playing on ghci, why should head be avoided?
10:23:22 <pranz> Algebr: yeah, some would say using no spaces with the dots is a big no-no
10:23:30 <Eduard_Munteanu> > head []
10:23:31 <lambdabot>  *Exception: Prelude.head: empty list
10:23:33 <pranz> Algebr: but I like the compactness of it
10:23:35 <Eduard_Munteanu> Algebr: ^
10:24:21 <Algebr> neat, thanks pranz and Eduard_Munteanu
10:24:50 <Eduard_Munteanu> Algebr: you might be used to letting that thing pass in other languages, but in Haskell it's best to avoid partial functions
10:25:35 <Algebr> I listened to the haskell pod cast where Don Stewart was guest and he also said they basically do everything in strict....so was lazyiness as the default a mistake in the language?
10:26:19 <Eduard_Munteanu> Algebr: can you provide a quote?
10:27:46 <Algebr> Eduard_Munteanu: Not at the moment, it was in this pod cast, http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/ I might be mistaken about what Don was saying though.
10:27:56 <pranz> Algebr: it depends on who you ask
10:28:20 <pranz> Algebr: the default laziness is one of the most controversial features I would think
10:28:46 <Algebr> Its controversial no doubt, but like it seems that "read world" code tries to avoid the laziness?
10:29:37 * hackagebot ty 0.1.5 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.5 (ConalElliott)
10:30:10 <pranz> Algebr: laziness sacrifices (possible) performance for (possible) modularity
10:30:37 <pranz> Algebr: a function is probably more modular if it's lazy, because then you don't need to compute everything that function describes
10:31:00 <pranz> Algebr: but at the same time, it might be slower
10:31:21 <Algebr> pranz: Why would it be slower? Its not doing computation.
10:32:04 <Eduard_Munteanu> Algebr: it involves a level of indirection, plus you have to deal with sharing
10:33:50 <Eduard_Munteanu> Algebr: for example, in a strict language you expect to control evaluation in such a way that you compute expensive stuff once. With laziness you don't rely on that any longer.
10:35:47 <Eduard_Munteanu> Instead you hope your computation's result will be shared and reused automatically.
10:36:14 <monochrom> you cannot possibly do everything strict. you cannot possibly literally mean everything.
10:36:37 <monochrom> if everything is strict, "loop = print 5 >> loop" will print nothing.
10:37:01 <Algebr> Eduard_Munteanu: What do you mean by hope? Like hoping that the runtime caches the result?
10:37:42 <mizu_no_oto> Where did the two names "Maybe" and "Option" come from for the same type?  ML uses Option, so was that the first usage?  Why then did Haskell change the name of the type to Maybe?
10:37:49 <Eduard_Munteanu> Algebr: same sort of hope as when you hope garbage collection will free up your memory, more or less :)
10:38:59 <monochrom> if you ask me, I prefer "data Option a = None | Just a" :)
10:39:01 <Eduard_Munteanu> Algebr: there are ways to reason about it, but it is a bit implementation-specific
10:39:43 <Eduard_Munteanu> monochrom: that tells me you prefer choice over hazard :P
10:39:44 <haskell352> so i'm trying to prove the equivalence between the monoidal formulation of applicatives (as mentioned http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation). i've proven one direction, , specifically Monoidal implies Applicative, but i'm having trouble going the other direction. any ideas?
10:41:04 <haskell352> specifically, i'm getting stuck trying to implement (<*>) in terms of fmap, unit and (**)
10:42:47 <Philonous> @djin (a -> b, a) -> b
10:42:47 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:42:51 <Philonous> @djinn (a -> b, a) -> b
10:42:51 <lambdabot> f (a, b) = a b
10:44:11 <monochrom> I think Philonous is giving a hint :)
10:44:37 <haskell352> Philonous: that is useful when implementing (**) in terms of (<*>) and fmap, but i'm trying to go the other direction. or am i just getting confused by something simple?
10:46:04 <Eduard_Munteanu> haskell352: also note  unit :: f ()  vs   pure :: a -> f a   which should tell you 'unit' might hide more structure inside.
10:46:05 <monochrom> you are confused. suppose x :: f (a->b), y :: a. what is the type of x ** y ?
10:46:44 <Philonous> monochrom, THanks, I wasn't sure how to help without giving away to much.
10:46:49 <monochrom> err sorry. x :: f (a -> b), y :: f a
10:46:49 <Philonous> too*
10:47:05 <haskell352> monochrom: f(a -> b, a)
10:47:20 <Philonous> @type (<*>)
10:47:21 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:47:42 <monochrom> from (a -> b, a), can you get b? from f (a->b, a), can you get f b?
10:48:15 <haskell352> monochrom: yes, to both
10:48:26 <monochrom> then you are done
10:48:28 <haskell352> oh.
10:49:31 <haskell352> well that's embarrassing. i are dumb.
10:49:35 <klrr_> if i do "do x <- readFile "foo"; return $ someFunc x;" does the file get read when the evaluation of someFunc happens?
10:49:36 <Eduard_Munteanu> :t liftA2 ($)
10:49:37 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
10:50:04 <Eduard_Munteanu> klrr_: no
10:50:14 <klrr_> okey
10:50:19 <Eduard_Munteanu> klrr_: readFile doesn't finish until it reads everything
10:50:26 <klrr_> is it strict?
10:50:40 <monochrom> it's pretty lazy
10:50:42 <Eduard_Munteanu> klrr_: yes, as opposed to hGetContents
10:50:49 <klrr_> okey
10:51:07 <klrr_> trying to undestand this thread http://www.reddit.com/r/haskell/comments/1yoysc/reasoning_about_stream_programming/
10:51:14 <Eduard_Munteanu> Er, I think I'm confusing things.
10:51:16 <Philonous> Eduard_Munteanu, readFile name   =  openFile name ReadMode >>= hGetContents
10:51:47 <Eduard_Munteanu> Yeah, I've been using non-String IO quite a bit. :)
10:51:54 <Philonous> klrr_, readFile will indeed only perform the reading when the content is forced
10:51:55 <d3lxa> how can I work elegantly in a forM of IO when my functions returns Maybes and if any fail it should return Nothing, each function need the result of the precendent, any idea?
10:52:32 <klrr_> Philonous: okey, and this is bad for some reason?
10:52:38 <Eduard_Munteanu> d3lxa: you can use MaybeT to automatically handle failure and bail out
10:53:23 <Philonous> klrr_, Depends. You have no control over when the handle will be closed. In simple programs that's usually not an issue.
10:54:06 <Eduard_Munteanu> d3lxa: given 'foo :: IO (Maybe Foo)', runMaybeT $ do { ... x <- MaybeT foo ... }. Or you can go for MonadError or exceptions.
10:54:53 <klrr_> okey, thanks!
10:55:05 <Eduard_Munteanu> (don't forget Monad provides 'fail' so you can do stuff like  Just x <- foo)
10:55:19 <d3lxa> Eduard_Munteanu: I'll give it a try (again) thx :)
10:55:56 <d3lxa> Eduard_Munteanu: the problem with fail is that it will break the forM in the middle, right?
10:55:58 <haskell352> monochrom: wait, i don't think i'm done (and i'm sorry if i'm being extra slow). i can get applicative from monoidal. but i'm trying to go the other direction. i.e. i'm given f a and f b and i want to get f(a,b). what you said allows me to implement <*> but i've already done that
10:56:18 <Eduard_Munteanu> d3lxa: any of those will, unless you catch it somehow
10:57:08 <d3lxa> Eduard_Munteanu: yeah, what I wanted is to consider each entry independently, I think I wasn't clear enough
10:57:22 <haskell352> or is it ok to consider a as () -> a. i might be able to make something work that way
10:57:41 <Eduard_Munteanu> d3lxa: er, then just mapM and look at the resulting list of maybes?
10:57:45 <Philonous> haskell352, Oh, ok. You realize (a,b) is just ((,) a b), right?
10:57:49 <d3lxa> Eduard_Munteanu: can I runMaybeT inside the forM then?
10:58:03 <haskell352> Philonous: oh, no i didn't
10:58:26 <Eduard_Munteanu> d3lxa: that only helps if you have a bunch of statements that are chained
10:58:29 <monochrom> you should use your scroll buffer to see you asked about implementing <*>. to implement **, get "fmap (,)" involved
10:58:29 <d3lxa> Eduard_Munteanu: yes actually I have already planned to use catMaybes outside to prun Nothing's
10:58:55 <d3lxa> Eduard_Munteanu: yes I do have chained statements and it's inside the do of my forM
10:59:15 <Eduard_Munteanu> d3lxa: then yes, wrap the whole do block in runMaybeT
10:59:28 <haskell352> monochrom: yes, my bad.
10:59:32 <haskell352> thanks Philonous monochrom
10:59:41 * hackagebot process-streaming 0.0.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.0.1 (DanielDiazCarrete)
11:11:27 <magneticduck> I've decided to relearn some stuff, redo some stuff, and get my setup going better
11:12:25 <johnw> your GHC setup?
11:13:59 <Eduard_Munteanu> Hm, seems to me DatatypeContexts isn't *that* bad if you're not mistaking it for something else. It seems nice for completeness in a few (theoretical) scenarios, AFAICT.
11:14:20 <magneticduck> in particular, my choice of vim plugins
11:14:20 <magneticduck> http://www.haskell.org/haskellwiki/IDEs#Vim <-- some cool ideas it seems
11:14:20 <magneticduck> I was having some fun with haskellFold and vim-hoogle
11:14:20 <magneticduck> at the moment though, I'm really just editing with one half of the screen in vim and running "cabal install" in a terminal on the other half of the screen
11:14:50 <magneticduck> ...there's a better way isn't there =P
11:14:50 <magneticduck> I'll start off with syntastic I guess
11:14:51 <Eduard_Munteanu> For instance they sort of stand for constraints on parameters like those in DT languages.
11:15:28 <magneticduck> (I mean, it's alright doing it like this, but *at least* I could have a cooler way of viewing ghc errors than scrolling up and down a bunch of text)
11:15:29 <magneticduck> I haven't set up GHC in any particular way
11:15:37 <magneticduck> just using very vanilla setup atm
11:16:13 <Eduard_Munteanu> E.g. data (a ~ b) => Foo ... a b ... = ...   behaves somewhat like parametrizing Foo by a lifted equality type.
11:16:44 <monochrom> a better way is to use 3/4 of the screen for the editor and 1/4 for the command line
11:16:49 <Eduard_Munteanu> And pattern-matching on it.
11:17:46 <Eduard_Munteanu> Except we can't lift GADTs. :)
11:19:14 <Eduard_Munteanu> It would be nice to get data declarations to track parameters and indices properly.
11:19:16 <mm_freak_> Eduard_Munteanu: maybe because that type isn't all that useful
11:19:52 <magneticduck> btw guys, does GHC have any type of style checking or stuff?
11:20:02 <magneticduck> or do you have to use hlint to do that kind of ting
11:20:07 <johnw> mostly hlint
11:20:22 <mm_freak_> magneticduck: i use my own eyes
11:20:41 <mm_freak_> the haskell coding style is:  "write whatever you will find readable in six months" =)
11:21:00 <magneticduck> mm_freak_: I know
11:21:04 <magneticduck> I'm just wondering
11:21:04 <Eduard_Munteanu> mm_freak_: it sort of boils down to parameters vs indices semantics, in that sense I think you can make it useful, e.g. you don't want to defer the constraint check until a constructor is pattern-matched.
11:21:09 <magneticduck> because syntastic is giving me little "style" warnings
11:21:11 <magneticduck> is it using hlint?
11:22:14 <magneticduck> wait a second
11:22:21 <magneticduck> ....
11:22:28 <magneticduck> oh, syntastic ONLY runs hlint
11:22:33 <magneticduck> it doesn't try to compile the code?
11:22:37 <magneticduck> doesn't check for errors?
11:22:39 <magneticduck> huh?
11:22:49 <monochrom> I have never heard of syntastic
11:23:00 <magneticduck> it looks cool
11:23:03 <Eduard_Munteanu> Cool name though.
11:23:12 <magneticduck> but I would like it to actually try to compile the code and tell me where the errors are!
11:23:12 <supki_> magneticduck: it runs whatever checkers you setup
11:23:21 <magneticduck> oh!
11:23:27 <magneticduck> okay, where do I set up checkers then
11:23:47 <magneticduck> yeah, it's only using hlint
11:23:55 <klrr_> what is the most popular test framework for haskell?
11:24:05 <johnw> tasty or hspec I'd think
11:24:26 <johnw> I prefer hpsec's use a monad rather than a "list of tests", so I use that
11:25:16 <mm_freak_> magneticduck: it is difficult to check haskell style, so hlint really only catches some common style errors, and i don't even agree with it from time to time
11:25:40 <magneticduck> mm_freak_: yeah
11:25:57 <mm_freak_> magneticduck: and for syntax/type errors you would, of course, use the compiler =)
11:26:05 <klrr_> you can always use structured-haskell-mode and you get good style by default
11:26:11 <klrr_> johnw: gonna check it out, thanks
11:26:16 <johnw> especially that one hlint warning: "Ask mm_freak what he would do here."
11:26:20 * u_ has been trying for 3 days to make sense of page 149 of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.7437&rep=rep1&type=pdf#page=137
11:26:26 <mm_freak_> hehe
11:27:27 <magneticduck> good hlint error: "what do you think this is, lisp?"
11:27:36 <magneticduck> "(use $ and . !)
11:27:50 <mm_freak_> johnw: first step:  search for "(. " and " .)"
11:27:53 <mm_freak_> if found, reject =)
11:28:20 <johnw> i almost use "(. f) . run" in one place today, because the lambda it replaced was so ugly; but then i resisted
11:28:43 <johnw> (f .) . g is the only one I ever use, and that quite rarely
11:29:06 <mm_freak_> i don't even use that one, simply because looking at it right now i would have to evaluate it in my head to understand it
11:29:16 <johnw> i just translate it to f .: g
11:29:31 <Twey> mm_freak_: If you use it you'll get used to it
11:29:37 <Twey> Like anything else :þ
11:29:38 <klrr_> hmm, anyone could explain what tasty is? is it some kind of easier-to-use wrapper?
11:29:39 <johnw> yep
11:29:40 <mm_freak_> it doesn't satisfy my "readable six months later" rule =)
11:29:54 <mm_freak_> klrr_: replacement for test-framework
11:30:05 <johnw> it's like using the lens operators; once you get used to the pattern, it remains readable for long as you are using that pattern
11:30:13 <Twey> mm_freak_: Well, the question is whether you've been using it in those six months or whether you've forgotten it
11:30:15 <klrr_> okey, so what is its purpose?
11:30:16 <Twey> Right
11:30:30 <Twey> You can completely forget Haskell syntax in six months, and then everything fails the test :þ
11:30:49 <magneticduck> what is ghc_mod?
11:31:07 <johnw> magneticduck: lets you do on-the-fly syntax checking in vim/emacs
11:31:23 <johnw> a faster version is of hdevtools, which keeps GHC resident in memory
11:31:23 <Twey> magneticduck: ghc-mod is a command-line interface to the GHC API meant for using in editors, and some editor bindings to it for vim and emacs
11:31:50 <magneticduck> johnw: ahah!
11:31:51 <mm_freak_> Twey: let me put it this way:  it isn't necessary and straightforward code is the most beautiful code you can have…  cleverness never pays off in programming =)
11:31:52 <magneticduck> yes I see
11:32:27 <mm_freak_> Twey: i'm receiving contributions to netwire, even though it is quite a nontrivial abstraction, because the code is really easy to get into =)
11:33:08 <Twey> mm_freak_: Ehh.  What's straightforward is purely a question of what you're used to.  There are plenty of people who would say that no Haskell code is straightforward :þ
11:33:48 <Twey> As for ‘necessary’… sure, but sugar like monads isn't necessary either.  The question is just whether you're willing to get used to a new abstraction to avoid some repetition.
11:34:01 <mm_freak_> Twey: well, the basic assumption is that you are a haskell programmer and understand the language and some very common coding patterns…  also i generally assume knowledge of basic abstract algebra
11:34:23 <johnw> I think a style rule like "don't use nested composition" is as useless as any other arbitrary rule
11:34:34 <johnw> and as useful
11:35:13 <Twey> Yeah; it depends on your audience.  If you want to write newbie-friendly code, you should probably avoid things like nested composition and SECs (and all of lens).
11:35:13 <mm_freak_> johnw: maybe it's just me, but my brain rejects memorizing that pattern
11:35:33 <johnw> mm_freak_: fair enough
11:35:46 <johnw> I'm starting to use it less and less, as a kindness to other readors
11:36:00 <johnw> i'm already forcing them to grok lens more
11:36:10 <Twey> And probably prefer e.g. map over fmap, concat over join, and so forth; the basic-prelude is also helpful here
11:36:38 <Twey> Er, I guess that's not the package I was looking for; what's the newbie-friendly one that generalizes as little as possible?
11:36:48 <johnw> lens-family?
11:37:10 <magneticduck> hahahahahahahhaha yesssss syntastic is working
11:37:14 <deech> Is there some way to set a (Ptr a) to NULL? I realize there's a nullPtr but that's not quite what I want.
11:37:18 <mm_freak_> i'm also not immune to making impositions…  to understand my code you generally need to have a good understanding of monads, pipes and often arrows =)
11:37:26 <magneticduck> now... there is one thing that I would love....
11:37:36 <magneticduck> which would be to be able to put a vim buffer in another window
11:37:40 <johnw> deech: how is it not what you want?
11:37:56 <mm_freak_> by "monads" i mean functors, applicative functors, monads and monad morphisms (both ad hoc morphisms and monad transformers) =)
11:37:56 <magneticduck> let i3 do the frame management, leave vim to the text editing
11:37:58 <d3lxa> Eduard_Munteanu: how would you "insert" a pure Maybe inside the MaybeT? tried: val <- MaybeT $ (lift return) $ mVal
11:38:33 <Twey> deech: A Ptr a is equivalent to (C syntax) a*.  You can't set it to null because what you're setting is the a, not the Ptr.  If you have a** (Ptr (Ptr a)) then you can poke a nullPtr in there.
11:38:35 <Eduard_Munteanu> d3lxa: val <- return foo
11:38:58 <d3lxa> tried that, but it fail somehow
11:39:21 <deech> Twey: So there's no equivalent of (*a = NULL) in the haskell FFI?
11:39:25 <supki_> d3lxa: MaybeT . return
11:39:29 <Eduard_Munteanu> d3lxa: what are the types you expect of 'foo' and 'val'?
11:39:46 <Twey> deech: Yes, there is, but that requires a to itself be a pointer, as I just said
11:39:59 <d3lxa> supki_: nice catch! thx
11:40:02 <milfjord> :t poke
11:40:03 <lambdabot> Not in scope: `poke'
11:40:09 <Twey> deech: It's not a question of the FFI: it only makes sense to set a *pointer* to null, not an arbitrary value
11:40:26 <milfjord> poke pp nullPtr
11:40:27 <deech> Twey: Right, got it. Thanks!
11:40:32 <Eduard_Munteanu> d3lxa: you don't really need that MaybeT
11:40:36 <Twey> Same in C or C++: if you say *a = NULL then a must have type foo**
11:40:49 <milfjord> Twey: wanna see a counterexample?
11:41:03 <d3lxa> Eduard_Munteanu: I don't? seems the types won't check otherwise
11:41:04 <Eduard_Munteanu> d3lxa: MaybeT is just 'lift' for the maybe transformer
11:41:30 <Eduard_Munteanu> > runMaybeT (return ())
11:41:31 <lambdabot>  Not in scope: `runMaybeT'
11:41:38 <Eduard_Munteanu> Bleh.
11:41:39 <mm_freak_> d3lxa: MaybeT :: m (Maybe a) -> MaybeT m a
11:41:53 <mm_freak_> return :: Maybe a -> m (Maybe a)
11:42:22 <mm_freak_> once you get the types right, your code usually works =)
11:42:59 <Eduard_Munteanu> Actually not quite 'lift', my mistake.
11:43:14 <mm_freak_> 'lift' lifts m, not Maybe
11:43:29 <Eduard_Munteanu> return :: a -> MaybeT m a
11:43:35 <d3lxa> that's like 'return' doesn't do the right "thing"?
11:43:54 <mm_freak_> d3lxa: MaybeT . return :: (Monad m) => Maybe a -> MaybeT m a
11:44:20 <d3lxa> mm_freak_: yup, thanks :)
11:44:22 <Eduard_Munteanu> Is that what d3lxa asked for?
11:44:26 <Eduard_Munteanu> Ok, I misread then.
11:44:46 <mm_freak_> Eduard_Munteanu: i believe so:  <d3lxa> Eduard_Munteanu: how would you "insert" a pure Maybe inside the MaybeT? tried: val <- MaybeT $ (lift return) $ mVal
11:45:07 <Eduard_Munteanu> Fair, I got thrown off a bit by "pure"
11:45:20 <monochrom> always look at the type before guessing at code
11:45:30 <d3lxa> I was confused because I thought return was for MaybeT, but it's for m instead, is this a convention for m transformers?
11:45:39 <mm_freak_> d3lxa: it's for every monad
11:45:56 <mm_freak_> d3lxa: if m is a monad, then MaybeT m is also a monad
11:45:56 <Eduard_Munteanu> d3lxa: return is polymorphic, and both 'm' and 'MaybeT m' are monads.
11:46:13 <d3lxa> mm_freak_: I mean: the fact the transformer doesn't define lift as for Maybe but for the inner monad m
11:46:14 <milfjord> it's like mr. dalliard
11:46:37 <Eduard_Munteanu> d3lxa: that's what 'lift' does
11:46:44 <Eduard_Munteanu> :t Control.Monad.Trans.lift
11:46:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:46:50 <mm_freak_> d3lxa: that's because 'lift' lifts the inner monad, not the "meaning" of the outer monad
11:46:57 <monochrom> lift is different from return
11:47:02 <d3lxa> oh right! okay :) that's how it is
11:47:17 <Eduard_Munteanu> :t MaybeT
11:47:17 <lambdabot> Not in scope: data constructor `MaybeT'
11:47:36 <d3lxa> << seems lambdabot doesn't like MaybeT :P
11:47:37 <Eduard_Munteanu> MaybeT :: m (Maybe a) -> MaybeT m a
11:47:47 <monochrom> always write out the bloody type
11:47:59 <mm_freak_> d3lxa: and again it's a question of types:  lift :: (Monad m) => m a -> MaybeT m a
11:48:27 <mm_freak_> :t Control.Monad.Trans.Maybe.MaybeT
11:48:28 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
11:48:29 <thebnq> '''''''''''''
11:48:43 <mm_freak_> lambdabot imports most stuff fully qualified =)
11:48:51 <thebnq> oops
11:50:09 <d3lxa> thanks for your help, guys :) haskell (community) is awesome
11:50:46 <Eduard_Munteanu> xmonad is haskell (community), not awesome :P
11:50:58 <mm_freak_> haskell community is xmonad =P
11:51:13 <d3lxa> I used to use awesome but now xmonad :) btw
11:51:26 <mm_freak_> yeah, i use the xmonad library, too =)
11:51:32 <greg`> not in scope  GHC.Docgroup imported from GHC when trying to compile hdevtools any idea why?
11:55:18 <magneticduck> mmm this is better
11:55:41 <magneticduck> greg`: that error means that the module GHC.Docgroup is not in scope
11:56:14 <magneticduck> .... no idea why
11:56:37 <magneticduck> I'll install it and see if I can recreate the error
11:56:48 <magneticduck> nope goes very smoothly here greg`
11:56:55 <magneticduck> could you paste the entire output?
11:57:11 <magneticduck> to www.hpaste.org I mean
11:58:34 <magneticduck> mmm it's really nice to have syntastic working
11:58:39 <magneticduck> highly reccomended!!
12:00:25 <intrados> How would I get a request header in Happstack-lite? (Particularly, the User-Agent?)
12:05:13 <mm_freak_> intrados: http://hackage.haskell.org/package/happstack-lite-7.3.3/docs/Happstack-Lite.html
12:05:18 <mm_freak_> see the section "HTTP headers"
12:06:54 <haskell_newb> hello
12:07:09 <haskell_newb> why i'm getting "No instance for (Integral Float) arising from a use of `floor'" ?
12:07:40 <joelteon> because floats are not integrals
12:07:47 <haskell_newb> > let a = 1.9 :: Float in ceiling a
12:07:48 <lambdabot>  2
12:07:57 <haskell_newb> why it works thne?
12:08:08 <magneticduck> @type ceiling
12:08:09 <lambdabot> (Integral b, RealFrac a) => a -> b
12:08:12 <magneticduck> taa daa
12:08:20 <magneticduck> lambdabot is a bit strange
12:08:23 <milfjord> haskell_newb: show your code
12:08:27 <magneticduck> but that is the true type signature
12:08:31 <milfjord> lambdabot is not strange
12:08:37 <magneticduck> yes it is
12:08:42 <magneticduck> it's not acting very strange here though =P
12:09:04 <magneticduck> > 1 2
12:09:05 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
12:09:05 <lambdabot>    arising from the ambiguity check for `e_112'
12:09:05 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
12:09:05 <lambdabot>    bound by the inferred type for `e_112':
12:09:05 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
12:09:10 <magneticduck> oops
12:09:20 <magneticduck> ...
12:09:23 <magneticduck> never mind
12:10:01 <heatsink> > pi + floor pi
12:10:03 <lambdabot>  No instance for (GHC.Show.Show a0)
12:10:03 <lambdabot>    arising from a use of `M522108701790089851223974.show_M5221087017900898512...
12:10:03 <lambdabot>  The type variable `a0' is ambiguous
12:10:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:10:03 <lambdabot>  Note: there are several potential instances:
12:10:19 <heatsink> > 3.1 + floor pi
12:10:20 <lambdabot>  No instance for (GHC.Show.Show a0)
12:10:21 <lambdabot>    arising from a use of `M878631455633130264423983.show_M8786314556331302644...
12:10:21 <lambdabot>  The type variable `a0' is ambiguous
12:10:21 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:10:21 <lambdabot>  Note: there are several potential instances:
12:10:29 <haasn> > 3 + floor pi
12:10:30 <lambdabot>  6
12:10:32 <mm_freak_> haskell_newb: remember that floor rounds /from/ a floating point type, and the result type must be integral
12:10:45 <haskell_newb> mm_freak_: http://lpaste.net/100318
12:10:57 <mm_freak_> haskell_newb: to round from float to float you need something like:  fromIntegral . round
12:10:59 <milfjord> haskell_newb: what's the error message?
12:11:13 <haskell_newb> It gives me error for     No instance for (Integral Float) arising from a use of `ceiling'
12:11:19 <haskell_newb> for line 38.
12:11:20 <milfjord> haskell_newb: what's the complete error message?
12:11:23 <intrados> mm_freak_: Thanks. I somehow managed to miss the get function each of the three times I looked
12:11:28 <mm_freak_> haskell_newb: you're rounding from float to float
12:11:37 <mm_freak_> that's a type error
12:12:20 <mm_freak_> > round (0.5 :: Float) :: Float
12:12:21 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Float)
12:12:21 <lambdabot>    arising from a use of `GHC.Real.round'
12:12:21 <lambdabot>  Possible fix:
12:12:21 <lambdabot>    add an instance declaration for (GHC.Real.Integral GHC.Types.Float)
12:12:26 <mm_freak_> but:
12:12:30 <haasn> > fromIntegral (round 0.5) :: Float
12:12:31 <lambdabot>  0.0
12:12:33 <mm_freak_> > fromIntegral (round (0.5 :: Float)) :: Float
12:12:34 <lambdabot>  0.0
12:12:43 <haskell_newb> fixed, thanks.
12:13:57 <haasn> what's the motivation we have on round etc.'s result being Integral and not Num, anyway?
12:16:02 <intrados> haasn: What would be the alternative for converting from Fractionals to Integrals?
12:16:50 <milfjord> fromEnum
12:16:53 <haasn> intrados: every ‘Integral a’ is also a ‘Num a’ so you can just use it with any type you can right now, either way; the only thing I can imagine you gaining from this is the ability to abstractly assume an “Integral a” constraint when leaving ‘a’ polymorphic, but you could just as well add the constraint manually I think
12:19:08 <mm_freak_> haasn: i guess sometimes we just don't need to go through Integer
12:19:20 <mm_freak_> rounding from Float to Int is very fast
12:19:25 <haasn> I'm not sure how RealFrac is even implemented internally for types like Float
12:19:48 <Clint> is there something that does (m a, b) -> m (a, b)?
12:19:57 <haasn> but for Ratio, the definition given infers to a type involving only Num, not Integral, for the output
12:19:58 <magneticduck> hey guys I need some help with vim-haskellfold
12:20:11 <magneticduck> let's say I want to define some type synonyms...
12:20:14 <haasn> Clint: for Functor m?
12:20:16 <Taneb> @djinn ([a], b) -> [(a, b)]
12:20:16 <lambdabot> Error: Undefined type []
12:20:25 <Taneb> @djinn (Maybe a, b) -> Maybe (a, b)
12:20:26 <lambdabot> f (a, b) =
12:20:26 <lambdabot>     case a of
12:20:26 <lambdabot>     Nothing -> Nothing
12:20:26 <lambdabot>     Just c -> Just (c, b)
12:20:26 <Clint> haasn: for Maybe, in specific
12:20:32 <magneticduck> I would like to put them inside of a section with a certain fast explination, and be able to fold them all up into it
12:20:38 <magneticduck> is there a way of doing that?
12:20:40 <mm_freak_> Clint: \(c, x) -> fmap (, x) c
12:20:44 <Taneb> :t \(a, b) -> fmap (, b) a
12:20:45 <lambdabot> Functor f => (f a, t) -> f (a, t)
12:21:00 <milfjord> that looks super lensy
12:21:03 <haasn> uncurry strength
12:21:12 <mm_freak_> Clint: and without TupleSections: flip (,) x
12:21:20 <jmcarthur> :t strength
12:21:21 <lambdabot> Not in scope: `strength'
12:21:25 <haasn> :(
12:21:37 <mm_freak_> :t Control.Lens.strength
12:21:37 <lambdabot>     Not in scope: `Control.Lens.strength'
12:21:38 <lambdabot>     Perhaps you meant one of these:
12:21:38 <lambdabot>       `Control.Lens.teeth' (imported from Control.Lens),
12:22:06 <mm_freak_> you can probably use acme-schoenfinkel with WrappedSchoenfinkel in some way =)
12:22:55 <Twey> > floor 2e19 :: Int -- I'm not sure I'd trust that
12:22:56 <lambdabot>  1553255926290448384
12:23:34 <mm_freak_> > 19*logBase 2 10
12:23:35 <magneticduck> okay this is kind of annoying....
12:23:35 <lambdabot>  63.11663380285989
12:23:43 <magneticduck> guys I need some help with vim-haskellFold
12:23:45 <magneticduck> anybody here use it?
12:23:46 <jmcarthur> :t uncurry . flip $ fmap . flip (,)
12:23:47 <lambdabot> Functor f => (f a, b) -> f (a, b)
12:23:58 <jmcarthur> this pointfree version is a bit much
12:24:05 <magneticduck> in short, it doesn't play well with type synonyms!
12:24:23 <magneticduck> wtf xD
12:24:58 <jmcarthur> :t (uncurry.liftA2) (,) . second pure
12:24:59 <lambdabot> Applicative f => (f a, b) -> f (a, b)
12:25:06 <jmcarthur> that one is a little more understandable at least
12:25:14 <jmcarthur> but uses applicative :\
12:25:31 <mm_freak_> :t liftA2 (liftA2 (,)) fst (pure . snd)
12:25:32 <lambdabot> Applicative f => (f a, b) -> f (a, b)
12:26:01 <mm_freak_> :t liftA2 (,) . (id &&& pure)
12:26:01 <lambdabot> (Applicative f, Monoid a) => a -> (a, b) -> (a, (f a, b))
12:26:04 <mm_freak_> uh
12:26:08 <haasn> mm_freak_: I'm not sure how
12:26:18 <mm_freak_> haasn: how what?
12:26:18 <haasn> re: WrappedSchoenfinkel
12:26:20 <mm_freak_> ah
12:26:23 <intrados> haasn: Integral is a subtype of a Num, right? So one ought to be able to define operations which work for Integral and not Num. Which necessitates the ability to narrow to Integral...
12:26:39 <mm_freak_> haasn: me neither =)
12:27:15 <milfjord> :t toIntegral
12:27:16 <lambdabot>     Not in scope: `toIntegral'
12:27:16 <lambdabot>     Perhaps you meant one of these:
12:27:16 <lambdabot>       `fromIntegral' (imported from Prelude),
12:27:22 <haasn> intrados: but the trade-off is more hassle when interoperating with something that provides only Num, not Integral
12:27:22 <milfjord> oh, right
12:28:06 <Clint> mm_freak_: thanks
12:28:49 <haasn> intrados: which, especially for beginners, seems to be the more common use case
12:29:08 <haasn> I'm wondering what kind of concrete code examples would break either mildly or horribly if the signature was changed
12:29:25 <haasn> (other than trivial examples that would be fixed by s/Integral/Num/)
12:31:14 <intrados> Yeah. I'm having trouble thinking of many common operations that couldn't be generalized from Integral to NUm.
12:31:40 <milfjord> (>)
12:31:47 <prinsen> AlainODea: Are you still here? :)
12:32:28 <Twey> mm_freak_, jmcarthur: fmap swap . sequenceA . swap
12:32:58 <Twey> intrados: Num has fromIntegral, so… there are none :þ
12:33:40 <magneticduck> hey guys, does anybody here use vim-haskellFold?
12:33:51 <Twey> Hm, that's a weird class structuer
12:33:53 <Twey> structure**
12:34:13 <haasn> intrados: div, mod etc.
12:34:35 <haasn> those are the only ones Integral really exists for - basically due to floor you can go from floor (x/y) to floor x `div` floor y
12:34:41 <haasn> not sure who profits from that but it's thinkable
12:34:43 <Twey> Num has fromIntegral, but all Integrals must be Num… so effectively Integral and Num are the same?
12:35:24 <haasn> Twey: fromIntegral allows you to change type; all Integrals being Num refers to the same type
12:35:29 <haasn> Num doesn't let you change type, for example
12:35:39 <Twey> Hrm, yes
12:38:20 <Twey> I guess Integral is just a strict subset of Num
12:38:59 <prinsen> I have created a small working example of a bug in the Plugins library: https://github.com/fabianbergmark/plugins-bug
12:39:35 <prinsen> If anyone can take a look at it, I would deeply appreciate it!
12:40:27 <magneticduck> hey guys... was thinking about a sort of module overview system where you could see a quick listing of defined types, data types, functions, etc. created and exported by a module file in question...
12:40:38 <magneticduck> uh
12:40:46 <magneticduck> just a simple static overview thing
12:40:54 <magneticduck> has anybody made something like that?
12:41:53 <magneticduck> ...
12:42:04 <heatsink> That sounds like what Haddock does
12:42:15 <magneticduck> I'm talking about something much simpler
12:42:21 <jxv> there's also ":browse" in ghci
12:42:33 <magneticduck> you just pass it a file path and it spits out a bunch of things defined in the module in question
12:42:50 <haskell_newb> http://www.haskell.org/haskellwiki/Library/PNG I'm truing to use monochrom png creatiion related code but for output image feh says "feh WARNING: /tmp/test.png - No Imlib2 loader for that file format"
12:42:57 <haskell_newb> Is there some ommisions?
12:43:00 <magneticduck> well, maybe something ncurses so you can scroll around or stuff
12:43:31 <jxv> magneticduck, in ghci try ":browse Data.Maybe" for example
12:45:37 <magneticduck> hum
12:45:37 <haskell_newb> are ther any librtaries which allow you to write imahe to file pixel by pixel?
12:45:39 <magneticduck> alright
12:45:48 <magneticduck> haskell_newb: JuicyPixels?!
12:45:53 <haskell_newb> without ton of boilerplate preferable
12:46:10 <magneticduck> yes
12:46:15 <magneticduck> haskell_newb: it uses repa for arrays
12:46:20 <magneticduck> hopefully that isn't too scary
12:46:21 <milfjord> System.IO
12:46:24 <magneticduck> hehe
12:46:25 <milfjord> if you use ppm
12:46:33 <magneticduck> yeah, you can also just  ... write the file
12:46:44 <magneticduck> but I suggest JuicyPixels
12:46:46 <milfjord> but seriously, ppm is like the easiest image format ever
12:47:30 <magneticduck> oh wait, I kind of though JuicyPixels used repa...
12:47:36 <magneticduck> not sure why
12:47:38 <magneticduck> I guess it doesn't
12:48:28 <haasn> magneticduck: there's a juicypixels-repa package, maybe that's why? :)
12:48:41 <magneticduck> anyway I gtg cya later
12:49:12 <haskell_newb> thanks, i'll try that
12:49:43 <haasn> juicypixels certainly has a reasonable accessible “generateImage :: Pixel a => (Int -> Int -> a) -> Int -> Int -> Image a”
12:50:08 <haasn> there's also Codec-Image-DevIL and its repa-devil frontend
12:50:24 <haasn> which I've found to be more accessible when using repa, iirc
12:51:21 <haasn> but ppm is indeed simple!
12:54:02 <johnw> dcoutts: ping
12:59:30 * lispy added generateImage so he's pleased to hear someone finds it reasonable :)
13:00:14 <lispy> It was just the right abstraction for my ray tracer to generate an image.
13:00:20 <haasn> reasonably accessible* but yes :)
13:00:48 <haasn> re: ppm https://en.wikipedia.org/wiki/Netpbm_format it's amazing just *how* simple it is ;)
13:01:09 <lispy> I wonder if that could be used to add streaming/fusion to juicypixels...
13:03:46 * monochrom has already been created :)
13:04:24 <lispy> monochrom: juicypixels already supports fusion?
13:04:45 <monochrom> I don't know
13:04:59 <lispy> Oh, I'm confused then as to what you were saying.
13:05:13 <monochrom> I'm doing a pun with my nick :)
13:05:35 <lispy> I see now :)
13:09:56 * hackagebot ecdsa 0.2 - Basic ECDSA signing implementation  http://hackage.haskell.org/package/ecdsa-0.2 (StephenWeber)
13:12:27 <haskell_newb> Trying to implement this in haskell http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html .
13:12:41 <haskell_newb> but stuck on "Now we find our y dimension weight, Sy, by evaluating the ease curve at y - y0, and finally we take a weighted sum of a and b to get our final output value z."
13:12:51 <haskell_newb> Could you please explain hot to do it?
13:13:00 * lispy takes a look
13:13:46 <haskell_newb> http://lpaste.net/100321 My current status
13:14:17 <haasn> “The problem with Perlin's implementation on its own was that that reading the descriptions of the math published on Perlin's website was a bit like reading Greek -- it took me about a week of reading his code and notes to figure out the actual geometric interpretations of the math.” reminds me of kmett writing
13:14:18 <lispy> haskell_newb: I think you use linear interpolation again like you did with Sx?
13:14:51 <edwardk> haasn: who wrote that one?
13:15:00 <haasn> edwardk: from haskell_newb's link
13:15:23 <haskell_newb> lispy: For Sx and Sy i do ease curve but i don't know how to "inally we take a weighted sum of a and b to get our final output value z".
13:15:26 <haasn> and I meant, the attributes he assigns to perlin, not the writing of the quote itself
13:16:40 <haskell_newb> lispy: Ah. got what you meant
13:16:53 <edwardk> haasn: that link needs to add variable lacunarity and change of axes so it can reduce axis alignment artifacts
13:17:09 <lispy> haskell_newb: I think I was too hastey
13:17:14 <lispy> haskell_newb: Sx and Sy are weights
13:17:33 <lispy> haskell_newb: a weighted some would be lie Weight1*x + Weight2*y
13:17:46 <lispy> and you might have a property like Weight1 + Weight2 = 1
13:17:51 <edwardk> i have a bunch of perlin noise code around here somewhere, not sure how much i have in haskell though
13:18:23 <lispy> I have some too, and it's in haskell
13:18:31 <haasn> read that as “i have a bunch of perlin noise around here somewhere” :)
13:18:31 <edwardk> i pretty much wind up reimplementing the whole perlin toolbox when i find myself doing animation though.
13:18:36 <lispy> But I think it's based on a slightly different model
13:18:47 <edwardk> bias/gain/noise are really easy tools for animating
13:19:30 <lispy> haskell_newb: it will proabbly just confuse you, but when I implemented perline noise this is what I ended up with: https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/SolidNoise.hs
13:19:38 <lispy> haskell_newb: that's based on a book I have about ray tracing.
13:19:59 <haskell_newb> lispy: He-he, yeah, it confuses me. :)
13:20:00 <edwardk> haskell_newb: anyways you may want to look into simplex noise
13:20:08 <haasn> lispy: got any recommended books about raytracing? :)
13:20:26 <edwardk> that fixes the isotropy problems perlin noise has and scales better.
13:20:54 <lispy> haasn: I have two that I like just fine, but a co-worker has one that is really bad ass. I wish I could remember the name of his book. I feel bad recommending the ones I have given that I know the other book is better.
13:20:58 <haskell_newb> edwardk: But before that i need to understand perlin noise first i think.
13:22:00 <haskell_newb> lispy: So the last step would be z  = a * sY + b * sY ?
13:22:24 <edwardk> haskell_newb: fair enough
13:22:36 <edwardk> haskell_newb: if you're still having trouble tonight, feel free to ping me for help
13:23:18 <haskell_newb> edwardk: Thank you.
13:23:18 <lispy> haskell_newb: More like z = a * sX + b * sY; but I can't figure out if it should instead be z = a * sY + b * sX
13:23:38 <lispy> (and it may not matter)
13:26:02 <lispy> haskell_newb: when I look at the pictures for Sx and the resulting equations and then apply that reasoning to the pictures for Sy, I get this: z = a + sY * (b - a)
13:26:41 <lispy> So I have to say, despite my previous suggestions I think that is what the author intended for z.
13:27:12 <haskell_newb> lispy: Thanks!
13:27:30 <lispy> yw
13:27:53 <lispy> haskell_newb: do you see how that equation is consistent with the rest of the articel?
13:29:28 <lispy> this paragraph: Ok, I've droned on long enough, it's calculation time: first, we take the value of the ease curve at x - x0 to get a weight Sx. Then we can find the weighted average of s and t by constructing a linear function that maps 0 to s and 1 to t, and evaluating it at our x dimension weight Sx. We'll call this average a. We'll do the same for u and v, and call the result b.
13:29:31 <haskell_newb> lispy: Yep, it's very similar to how a or b whas calculated
13:29:43 <lispy> Plus the figures below it, and the equations just below the figure are the key to understanding this bit.
13:29:58 * hackagebot api-tools 0.2 - DSL for generating API boilerplate and docs  http://hackage.haskell.org/package/api-tools-0.2 (ChrisDornan)
13:30:20 <haskell_newb> Okay, i have something working. http://lpaste.net/100322 -> http://i.imgur.com/RAPhMpv.gif
13:30:39 <haskell_newb> But it's not quite a perlin noise. :)
13:30:49 <haskell_newb> I guess i messed up rendering
13:31:18 <haskell_newb> Or gridPointGradient function, because of hairy "g".
13:31:21 <adm_> @hoogle String -> ByteString
13:31:23 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
13:31:23 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
13:31:23 <lambdabot> Prelude error :: [Char] -> a
13:31:33 <ion> adm: Which encoding?
13:31:57 <lispy> haskell_newb: You might try using Debug.Trace to see what the intermediate values in your computation are working out to be
13:32:01 <adm_> ion: pass; http://hackage.haskell.org/package/network-metrics-0.3.2/docs/Network-Metric-Internal.html#t:Host
13:32:02 <lispy> haskell_newb: make a 20x20 image
13:32:26 <td123> is it just me or does esqueleto feel very hacky to others as well?
13:33:15 <ion> adm: Ok, you’ll want either UTF-8 or IDN.
13:33:58 <haskell_newb> lispy: I'm not sure what these values are *should* be. So far property of "noise function becomes zero when x and y are both whole numbers" but what else can i check?
13:34:47 <lispy> haskell_newb: we can tell from your gif that the final output is always 0
13:34:58 <lispy> haskell_newb: We know that because the image is black
13:34:58 <haskell_newb> s/but whay/holds but what/
13:35:46 <lispy> > let x = 0.4 in ceiling x - floor x
13:35:47 <lambdabot>  1
13:35:50 <haskell_newb> lispy: It's not entirely black.
13:36:08 <tel> Is there a more elegant way to write this pipe combinator: (>>-) :: Monad m => Producer b m r -> (b -> Producer c m (Maybe r)) -> Producer c m r
13:36:18 <tel> i.e. `for` or `(//>)` with early termination
13:36:23 <haskell_newb> "noise2dGen x y = round . (*100) . abs $ noise2d ((fromIntegral x) * 0.01, (fromIntegral x) * 0.01)" => http://i.imgur.com/iQAXtGG.gif
13:36:29 <haskell_newb> lispy: ^
13:36:42 <lispy> haskell_newb: BTW,you shouldn't initialize your random gen more than once
13:36:43 <tel> I've currently defined it as: p >>- f = for (p >-> dieOnEcho) f where dieOnEcho = await >>= respond >>= maybe dieOnEcho return
13:36:54 <ed209`> test
13:37:02 <lispy> haskell_newb: mkStdGen should be lifted out to main.
13:37:41 <haskell_newb> lispy: I'm not sure. "important consideration that it always returns the same gradient for the same grid point, every time it's calculated".
13:37:55 <haskell_newb> Thats for g(xgrid, ygrid) = (gx, gy) funciton from article
13:37:56 <lispy> haskell_newb: ah, is the problem that you need to map colors from 0 to 1 to the range 0 to 255?
13:38:30 <haskell_newb> lispy: Not sure if that the only problem, but that's a definitely a problem for me. :)
13:39:11 <bennofs> Can I make GHC GC run less often, only when memory is actually needed?
13:39:23 <haskell_newb> noise2d (1.0,3.4) => -5.368644e-2 Yeah, noise2d doesn't calculate properly, prabably because of that gridPointGradient.
13:39:24 <lispy> haskell_newb: https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/RGB.hs#L23
13:39:25 <carter> ohh
13:39:32 <carter> bennofs: theres a no idle gc flag
13:39:33 <carter> hangon
13:39:38 <bennofs> +RTS -I0
13:39:42 <bennofs> I already do that
13:39:53 <carter> +RTS -I0 -RTS
13:39:54 <carter> yeah
13:39:57 <lispy> haskell_newb: that function takes a float in the 0 to 1 range and puts it in the 0 to 255 range
13:40:04 <carter> bennofs: so whats the issue?
13:40:08 <bennofs> I also use +RTS -H1000M
13:40:10 <carter> oh
13:40:15 <carter> how about -A50M
13:40:27 <carter> are you getting hit by minor or major collections
13:40:32 <bennofs> major
13:40:35 <carter> ok
13:40:36 <carter> umm
13:40:41 <carter> whats the application / worload?
13:40:59 <bennofs> Lots of spikes from 0MB to about 46MB
13:41:11 <carter> whats the program do
13:41:18 <NobbZ> Hi there! Could someone point me to a ressource that explains the WheelSieve algorythm for primenumber construction en detail? I don't get it from the haskell wiki and the source of the package primes
13:41:21 <lispy> haskell_newb: as for the issue with randomness, I think Perlin had a solution to this that was like, precalculate the random (or even pseudo random) values and use it as a look up table.
13:41:42 <carter> bennofs: have you tried making -A large?
13:41:43 <bennofs> allocate a game tree, and when enemy chooses a move, there is a lot of the game tree that will be garbage
13:41:50 <carter> ok
13:41:59 <carter> so they're all short lived right?
13:42:17 <bennofs> Not everything. The part of the game tree that is played will be kept
13:42:36 <carter> ok
13:42:52 <carter> how big is the part of the game tree you'll drop¿
13:42:58 <carter> and how big is the part you'll keep?
13:43:11 <carter> make sure you have -A$FOO
13:43:19 <carter> big enough to fit the short lived stuff
13:43:23 <carter> or it'll get promoted
13:43:32 <carter> try -A100M or something
13:43:51 <bennofs> If I do heap profiling, does that also show memory used by garbage not yet collected?
13:44:10 <carter> idk, i'm spacey and tired this weekend
13:44:23 <carter> how would it know whats live if you've not collected it?
13:44:35 <lispy> haskell_newb: Perlin noise is a hack in that it's a horribly simple model compare to the physical thing it mimics. What's so amazing and beautiful about it is the simplicity of the hack. For example, the random values you use don't need to be very random. Just disorganized.
13:44:41 <carter> with a GC, you only pay for whats live
13:44:43 <carter> not whats dead
13:44:49 <carter> allocation is cheap subject to that, right?
13:45:21 <lispy> haskell_newb: In other words, for testing purposes you could even hardcode some values you made up by hand to "look random"
13:45:38 <lispy> haskell_newb: I need to get going. Good luck!
13:45:53 <carter> bennofs: anyways, try -A$LARGENUMBER
13:46:02 <carter> like -A50m or A100m
13:46:07 <haskell_newb> lispy: Thank you for your help!
13:46:16 <bennofs> Yeah, trying. I guess I just keep too much of the tree in memory
13:46:33 <carter> yes
13:46:48 <carter> also if you can figure out how to better reuse parts your care about
13:46:53 <carter> or make recomputing stuff cheap
13:46:54 <carter> that works too
13:46:55 <dhrosa> @pl listDot x y = sum $ zipWith (*) x y
13:46:56 <lambdabot> listDot = (sum .) . zipWith (*)
13:47:22 <monochrom> carter: successively longer made-up variable names for successively larger numbers? :)
13:47:29 <carter> sure
13:48:10 <monochrom> -A$The_Number_That_Only_Ramajuan_Knew
13:48:36 <monochrom> (cf. the book titled "the man who knew infinity" :) )
13:48:39 <rusk101> hey guys. Im trying to use the zipWith3 function to get a list of products. i.e. zipWith3 (*) [1,2,3] [2,3,4] [3,4,5]
13:48:55 <rusk101> im no getting it to work
13:49:16 <geekosaur> :t zipWith3
13:49:17 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
13:49:21 <geekosaur> :t (*)
13:49:22 <lambdabot> Num a => a -> a -> a
13:49:38 <rusk101> :t product
13:49:39 <lambdabot> Num a => [a] -> a
13:50:04 <rusk101> zipWith3 (product) [1,2,3] [2,3,4] [3,4,5]
13:50:08 <dhrosa> rusk101: (*) is a binary operator, you want a ternary operator
13:50:24 <bennofs> What I wonder, though, is that heap profiling shows that I use about 48M max per move. It is strictly increasing, so I guess any GC's that happen while I calculate the move don't really do anything. Yet I don't get GHC to avoid these collections
13:50:30 <geekosaur> :t product . ([,,])
13:50:31 <lambdabot> parse error on input `,'
13:50:32 <rusk101> why doesnt product work then?
13:50:33 <geekosaur> bah
13:50:35 <dhrosa> zipWith3 (\a b c -> a * b * c) [1..3] [2..4] [3..5]
13:50:42 <dhrosa>  > zipWith3 (\a b c -> a * b * c) [1..3] [2..4] [3..5]
13:50:45 <carter> bennofs: did you try larger nursery yet?
13:50:46 <dhrosa> > zipWith3 (\a b c -> a * b * c) [1..3] [2..4] [3..5]
13:50:47 <geekosaur> because product wants a list, not multiple parameters
13:50:47 <lambdabot>  [6,24,60]
13:50:54 <rusk101> ok thanks
13:50:59 <monochrom> zipWith3 (\u s a -> product [u, s, a]) :)
13:51:05 <rusk101> lOL
13:51:05 <schurr> try (\x y z -> x*y*z)?
13:51:25 <dhrosa> @pl \a b c -> a * b * c
13:51:25 <lambdabot> ((*) .) . (*)
13:51:26 <bennofs> carter: I did, now I only get Gen 1 collections.
13:51:28 <dhrosa> well that's gross
13:51:34 <carter> bennofs: ok
13:51:35 <carter> cool
13:51:40 <carter> and those should be cheaper
13:51:46 <monochrom> the explicit lambda is clearer, yes
13:51:48 <bennofs> Gen 1 is the older generation
13:51:51 <bennofs> I thought
13:51:53 <carter> ummm
13:51:57 <carter> yes
13:52:03 <carter> i don't remember
13:52:10 <carter> wait
13:52:15 <bennofs> Gen 0 is collected far more often
13:52:17 <carter> yes
13:52:24 <carter> so the goal is to make gen 0 cheaper
13:52:37 <carter> bennofs: did perf get better with larger nursery or no?
13:52:42 <carter> bennofs: also: threaded or no?
13:52:51 <bennofs> carter: no threaded
13:53:43 <carter> how are you benchmarking?
13:53:46 <carter> also whats the code
13:53:54 <carter> its like i'm helping you weith a magic box
13:53:57 <carter> that i cant see
13:54:02 <bennofs> Hmm, it could actually be the tree nodes that are killing me, not the contents of the tree itself. I destroy sharing of the nodes, because my search function sorts the tree. Probably not a good idea
13:54:11 <carter> ok
13:54:17 <carter> bennofs: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
13:54:31 <carter> you might wanna try out parallel GC
13:54:35 <carter> also how are you benchmarking it?
13:54:50 <bennofs> carter: I'm running my program with +RTS -S
13:54:59 <shergill> who's in charge of the nix ghc package? i have ghc-7.6.3. when trying to install cabal-install-1.18.0.2 i get the following error: /nix/store/zlkc3mnixmkjccq841i5ir7cl4l780hi-binutils-2.23.1/bin/ld: cannot find -lz
13:55:09 <carter> bennofs: try building it threaded
13:55:14 <carter> + add -qg to RTS ops
13:55:42 <bennofs> Can I see
13:55:48 <carter> ??
13:55:50 <bennofs> how much garbage was collected?
13:55:54 <carter> umm
13:55:56 <carter> -S ?
13:55:57 <carter> idk
13:56:04 <carter> the manual tells you how
13:56:07 <carter> been a while :)
13:57:14 <bennofs> It shows live bytes, allocated bytes and copied bytes. What is the difference between live bytes and copied bytes? I thought all live objects where copied?
13:57:33 <adm_> @hoogle Float -> Double
13:57:34 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:57:35 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
13:57:35 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:57:57 <bennofs> Also, the allocated bytes it shows is less that the live bytes. How can that happen?
13:59:00 <carter> live == not dead
13:59:03 <carter> copied == promoted
13:59:05 <carter> i think
13:59:22 <carter> bennofs: what does the documentation say?
13:59:33 <bennofs> carter: where is this documented?
13:59:34 <monochrom> adm_: try realToFrac
13:59:38 <bennofs> carter: I cannot find it :(
13:59:45 <adm_> :t realToFrac
13:59:46 <lambdabot> (Fractional b, Real a) => a -> b
13:59:48 <adm_> monochrom: thanks
13:59:56 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
14:00:01 * hackagebot ripple 0.1 - Ripple payment system library  http://hackage.haskell.org/package/ripple-0.1 (StephenWeber)
14:00:06 <carter>  --machine-readable
14:00:16 <carter> -t and -s right?
14:00:31 <carter> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/GHC-Stats.html
14:00:34 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
14:00:36 <carter> bennofs: pause
14:00:40 <carter> and read these
14:00:45 <carter> also i'm away for most of the evneing
14:04:09 <shergill> i get the following error when running 'cabal install cabal cabal-install': /nix/store/zlkc3mnixmkjccq841i5ir7cl4l780hi-binutils-2.23.1/bin/ld: cannot find -lz. any ideas?
14:04:46 <geekosaur> missing zlib devel package?
14:05:01 <jmcarthur> install libz
14:05:02 * hackagebot hoogle 4.2.29 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.29 (NeilMitchell)
14:05:25 <jmcarthur> or zlib or something or other
14:05:33 <jmcarthur> google is your friend
14:07:33 <shergill> i already have zlib1g-dev installed, but that's via apt (ghc is via nix)
14:14:31 <prinsen> AlainODea: Are you there?
14:15:03 * hackagebot io-streams 1.1.4.2 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.2 (GregoryCollins)
14:21:03 <syao> hello Haskellers :)
14:21:09 <Rembane> Hello syao !
14:21:15 <ddere> hello
14:21:40 <hc> qapla'!
14:21:55 <syao> Cale: are you here?
14:23:53 <syao> Got a question, as we know haskell is lazy FP langauge, for that it should make it easier to make distributed stoftware
14:24:01 <syao> *software
14:24:19 <hpc> laziness doesn't help with distributed computing at all
14:24:27 <hpc> (purity does a bit, but the huge one is first-class IO)
14:25:27 <syao> (laziness does not solve problems but gives performance.)
14:26:22 <carter> distributed engineering just requires paranoia and respect for physics
14:26:26 <syao> is there a paper for distributed software in haskell?
14:26:55 <carter> syao: do you have any formal dist sys background?
14:26:59 <geekosaur> you might want to poke at cloud haskell?
14:27:15 <carter> geekosaur: i'm hoping to fix it up
14:27:24 <syao> carter, some, yes. but not so much
14:28:03 <carter> www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf syao  is what it ell everyone read
14:28:15 <carter> geekosaur: "cloud haskell" needs some improvment
14:28:56 <carter> i hope to try to do some over the next few weeks
14:28:59 <carter> to make it more haskelly
14:29:01 <geekosaur> yes, I know it's fairly young. I thought there was some vaguely Erlang-ish thing out there too but a quck scan of hackage didn't show it
14:29:12 <syao> carter, thanks
14:29:16 <carter> theres a few things
14:30:03 <carter> geekosaur: CH (aka distributed-process and friends) is a bit complicaed
14:30:06 <carter> (and on hackage)
14:30:14 <carter>  i have some ideas for simplifying it
14:30:21 <carter> theres also courier, which is a cute mini version
14:33:45 <syao> carter, but don't you think that software should be seamless in a perspective of distribution?
14:33:52 <carter> nope
14:33:54 <carter> thats a lie
14:34:03 <syao> why not?
14:34:17 <carter> syao: read that lectures notes i linked you and you'll understand
14:34:25 <syao> maybe that the performance will be a problem, but not in theory
14:34:25 <carter> basically, coordination is hard and fickle
14:34:28 <carter> umm
14:34:29 <carter> no
14:34:31 <carter> go read :)
14:34:42 <carter> sometimes it fundamentally is impossible
14:34:47 <carter> in practice you can get it working
14:34:56 <carter> but its pretty subtle when you get to anything complex
14:35:27 <carter> also even if the software has no bugs, the hardware might fail!
14:35:45 <syao> I think social life of people is one big distributed system, and yes we have some problems, but that does not stop us :)
14:36:03 <ed209`> eh?
14:36:16 <carter> metaphors don't prove nuttin
14:36:22 <carter> people are terrible at communicating / coordinating
14:36:38 <syao> some are, some are not.
14:36:57 <carter> some are though :P
14:37:20 <syao> yeah :)
14:37:20 <carter> and the point is
14:37:47 <carter> distributed engineering winds up being about making sure things happen in  sane way + cope with crazy bugs
14:39:16 <syao> You see I am not talking about practical implementations in today's software, just a theory. and the basic rules to cope with faults.
14:39:21 <syao> to get a result
14:39:32 <syao> *reading book*
14:39:34 <carter> syao: then read the theory lecture notes first :)
14:39:40 <carter> i linked to the best one i know of
14:39:55 <syao> good, thank you :) will read it
14:40:36 <syao> doing it now.
14:40:38 <shergill> well you can have robustness to certain degree of failure. is that what you're talking about syao?
14:41:57 <syao> shergill, yes, like in the real world, when the world dies, we are not talking on recovery..
14:42:10 <carter> ?
14:42:13 <shergill> i'm not sure i understand
14:42:35 <carter> i'm confused too
14:42:42 <carter> could you explain with different words please
14:43:01 <shergill> it might be better for you to get some background as carter suggested, but yes it's possible to design robust systems
14:43:09 <carter> both
14:46:03 <bernalex> does ghc basically make your code super omg such parallel if possible, or do you need to pass some flags to encourage this?
14:46:10 <syao> I am saying: you can't make  system to recover from all the faults possible. Some things will be lost, and will need repair
14:46:32 <bernalex> I've noticed that cabal sets -threaded as a default flag, so I assume it's not threaded per default for instance?
14:46:50 <bernalex> and there's all sorts of XParallel flags etc.
14:46:53 <benmachine> bernalex: GHC doesn't automatically parallelise, you have to annotate your programs
14:47:02 <benmachine> this is because getting parallelism right is actually pretty hard
14:47:05 <bernalex> benmachine: can you provide some info on this?
14:47:09 <bernalex> benmachine: yes, I know
14:47:16 <enthropy> bernalex: have a look at repa?
14:47:20 <bernalex> benmachine: if you have some links I could check out that would be good
14:47:23 <enthropy> /data parallel haskell
14:47:35 <benmachine> bernalex: http://hackage.haskell.org/package/parallel
14:47:39 <hpc> bernalex: the quickest way to parallelize is to sprinkle par and pseq in a few strategic places
14:47:44 <bernalex> thanks guys
14:47:58 <carter> bernalex: also share your code
14:48:03 <carter> or we cant actually help you effectively
14:48:05 <benmachine> bernalex: I don't know how much my link helps because I haven't done this stuff
14:48:07 <syao> and there can be times when you can not repair the state of the system.
14:48:13 <bernalex> carter: what code?
14:48:15 <benmachine> bernalex: I know the theory not the practice :)
14:48:19 <carter> the stuff you're trying to do
14:48:21 <hpc> the RTS will parallelize as the opportunity arises based on those two functions
14:48:23 <carter> "how do i make it parall"
14:48:30 <bernalex> carter: I didn't ask that question.
14:48:34 <carter> ok
14:48:35 <carter> ok
14:48:59 <carter> syao: yes, but that depends on how you design it
14:49:13 <hpc> how do i make my code run at exactly a 33.7 degree angle?
14:49:14 <shergill> ok so any tips on installing lambdabot locally?
14:49:26 <hpc> shergill: run screaming in the other direction ;)
14:49:43 <hpc> (it might be less bad nowadays)
14:49:57 <hpc> shergill: try doing a plain cabal install lambdabot
14:49:58 <shergill> hpc: for real? but lambdabot has such gems. it'd be nice to be able to use them locally
14:50:07 <enthropy> hpc so that's called magic angle spinning?
14:50:08 <benmachine> hpc: ssh into a box a few thousand miles north/south of wherever
14:50:10 <hpc> there might be some binary depends that cabal still derps on
14:50:21 <hpc> happy/alex, ect
14:50:31 <benmachine> shergill: a few of lambdabot's things are available separately
14:50:42 <benmachine> shergill: pointfree is a standalone program
14:50:48 <hpc> as is djinn
14:50:49 <benmachine> I can't remember if it works
14:50:51 <hpc> and hoogle
14:50:57 <benmachine> I fixed it but maybe I didn't release
14:51:08 <hpc> you'll have to test things step-by-step
14:51:09 <shergill> hpc: yeah it choked, but i think the issue i'm having is with the nix installed version of ghc not being able to find the right libraries
14:51:22 <syao> carter so you are saying that the system can recover from all faults in distributed system? I think its not possible
14:51:49 <benmachine> oh, I totally did fix it
14:51:53 <benmachine> well done, past-me
14:52:35 <shergill> benmachine: actually that may be sufficient, thanks
14:52:38 <shergill> and easier to do
14:52:42 <carter> no
14:52:50 <benmachine> shergill: if you have any issues with pointfree
14:52:53 <carter> syao: i said "depends on the definition of words and what exact problem you are talkinga bout"
14:52:55 <benmachine> then I will be in bed instead of fixing them
14:53:00 <benmachine> but will get to them tomorrow evening :)
14:53:01 <syao> by saying all = all possible faults that we can imagine in this world.
14:53:14 <carter> dist sys is so complex its pointless to talk in hypoetheticals
14:53:23 <carter> saying something is always true is always false :P
14:53:27 <shergill> benmachine: just finished installing. and a dummy query works. will let you know if something else comes up, but i doubt it
14:53:29 <carter> which is paradoxical
14:53:32 <carter> but is fact
14:54:01 <syao> carter, is there a proof for that?
14:54:13 <carter> proof of what?
14:54:16 <carter> go read those lecture notes
14:54:28 <carter> we're talking in such a vague way that anything we respectively say on this topic has no meaning :)
14:54:30 <syao> "saying something is always true is always false"
14:54:42 <tromp_> 0==0 is always true
14:54:54 <carter> :)
14:54:57 <tromp_> true is always true
14:55:06 <carter> the riemann hypoethsis is always true
14:55:09 <carter> is a false statement
14:55:33 <carter> dist systems are always fault tolerant is false statement
14:55:35 <carter> etc etc
14:55:37 <carter> i'm off to dinner
14:55:39 <carter> enjoy
14:55:57 <dwcook> @pl \x -> a x >-> b
14:55:57 <lambdabot> (>-> b) . a
14:56:12 <syao> carter,, no one said that they are fault tolerant, but it can be made like that
14:56:26 <dwcook> Hmm, that's probably worse.
15:00:08 * hackagebot hopenpgp-tools 0.7 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.7 (ClintAdams)
15:12:04 <waidmann> can someone please explain to me what "let (x:xs@(y:ys)) = [1,2,3,4,5]" actually does
15:12:16 <waidmann> I'm trying to get familiar with '@'
15:12:35 <MedDev> waidmann, why not try writing that in ghci?
15:12:48 <Peaker> waidmann: it just gives a name to some part matched by a pattern
15:12:51 <MedDev> ghci> let (x:xs@(y:ys)) = [1..5]
15:13:10 <MedDev> ghci>printStrLn $ show x
15:13:15 <dhrosa> waidmann: xs@(y:ys) gives a  name to the list (y:ys), so  you can refer to  xs in your code to refer to (y:ys)
15:13:22 <johnw> aka print x?
15:13:27 <dhrosa> while still pattern matching on y and ys
15:13:35 <waidmann> hmm I see
15:13:43 <MedDev> does having a pattern before the @ even work?
15:13:57 <waidmann> y shows up as 2, x shows up as 1
15:14:14 <geekosaur> if I recall the syntax right, it's name@pattern
15:14:15 <dhrosa> let (x:xs@(y:ys)) = [1,2,3, 4,5] in print x >> print xs >> print y >> print ys
15:14:18 <MedDev> ah yeah it does
15:14:20 <dhrosa> > let (x:xs@(y:ys)) = [1,2,3, 4,5] in print x >> print xs >> print y >> print ysa
15:14:21 <lambdabot>  Not in scope: `ysa'
15:14:21 <lambdabot>  Perhaps you meant `ys' (line 1)
15:14:23 <dhrosa> > let (x:xs@(y:ys)) = [1,2,3, 4,5] in print x >> print xs >> print y >> print ys
15:14:25 <lambdabot>  <IO ()>
15:14:30 <dhrosa> oof
15:14:41 <MedDev> geekosaur, there can be patterns before the @ apparently
15:14:45 <tautologico> x is the first element (x:xs) pattern and y is the second (y:ys pattern applied to xs)
15:14:49 <geekosaur> but I think that parses as x : (xs@(y:ys))
15:14:56 <waidmann> I initially thought '@' was to give a pattern or something a name to refer to
15:15:03 <MedDev> geekosaur, it does
15:15:06 <waidmann> but y == 2 and x == 1 threw me
15:15:21 <geekosaur> if you meant can you use it in mid-pattern, then yes
15:15:38 <geekosaur> but something like (x:xs)@(y:ys) I think does not work
15:16:12 <MedDev> geekosaur, nope it doesn't
15:16:28 <waidmann> oh wait no I've got it
15:17:07 <waidmann> (x:xs@(y:ys)) is creating another list (y:ys) from xs and ignoring the x part
15:17:16 <waidmann> I think
15:17:47 <tautologico> think of it as x : (xs @ (y:ys))
15:18:04 <dhrosa> (x:xs@(y:ys)) matches a list composed of a head, named  x, and the rest of the list xs. xs must be composed of a head, named y, and the rest of it, named ys
15:18:11 <waidmann> tautologico: yeah thet definition clicked with me just a second ago
15:18:25 <waidmann> I was thinking of it as (x:xs)@(y:ys)
15:18:42 <waidmann> Thank you all for helping me though
15:28:03 <hunt> hey guys
15:28:19 <hunt> is anyone on? I'm running into some trouble
15:28:27 <dhrosa> ask away
15:28:54 <hunt> I have this function: pixelsGridOM :: Integral a => (a,a) -> (a,a,a) -> [(a,a,(a,a,a))] -> [(a,a,a)]
15:29:10 <hunt> and for the third argument im passing in the results of this function
15:29:17 <hunt> loadPixs :: String -> IO [(Integer,Integer,(Integer,Integer,Integer))]
15:29:27 <hunt> and it wont accept the integers
15:29:37 <hunt> "Couldn't match type `Integer' with `Int'     Expected type: [(Int, Int, (Int, Int, Int))]       Actual type: [(Integer, Integer, (Integer, Integer, Integer))]     In the third argument of `pixelsGridOM', namely `newPixels'"
15:29:46 <hunt> I cant figure out why it would want Ints
15:30:09 <shergill> out of curiosity, does either agda or idris have something like template haskell?
15:30:45 <hunt> any ideas?
15:31:02 <cmears> hunt, sometimes you get a stray "Int" from functions like "take" and "!!" and friends
15:31:26 <hunt> does that explain why its expecting ints?
15:31:33 <pranz> hunt: if the previous arguments are Int's, it will only accept int
15:31:42 <pranz> the "a" must be the same type
15:31:50 <hunt> ahhh
15:32:03 <hunt> thats so stupid of me
15:32:10 <hunt> is there a way
15:32:16 <hunt> to use one variable
15:32:28 <hunt> or should i just use Integral bs for the list
15:32:30 <Twey> hunt: If you don't want that to be the case you can use separate variables, but you'll have to mess around converting them in the function body if you want to do anything with them together
15:33:46 <pranz> hunt: I'd recommend to just convert
15:34:03 <hunt> coool yea
15:34:11 <hunt> i was apparently passing in Ints
15:34:17 <hunt> so im just going to pass in the Integers in this case
15:35:00 <heatsink> Is there a way to see which ways a library was built in ghc-pkg?
15:35:09 <Maerten> Hi, i have a question about converting PHP script to Haskell as a project to learn haskell. In short: i have a DB table of 10.000+ rows of data (lets say they are pageviews on websites with each different domains and some simple URL's like /index.html /about.html and /contact.html). This data is summarized by the PHP script, in order to generate a daily pageview counter, and a monthly report of pageviews per domain, or pageviews per
15:35:09 <Maerten> specific webpage (so different kinds of grouping). The summarizing is done by constructing a multidimensional array, and incrementing some counters insode of this array: $['domain1']['2014-02-24'][/index.html']['pageviews']++;  The final result will be stored into a 'summary' DB table. My question: what would be the FP/Haskell aproach to summarizing this pageview data and storing it into the (already existing) database? I can try repla
15:35:10 <Maerten> the loop with a fold, and the array with Data.Tree but I'm not sure if that's the way, and as it'll take me a week to do, I hope someone here can point me in the right direction. Any help would be appreciated! TL;DR how can I convert my PHP script to Haskell?
15:37:26 <hunt> so
15:37:27 <heatsink> Maerten: There are Haskell database and array libraries.
15:37:33 <hunt> what does the final data look like
15:38:44 <thsutton> Maerten: Personally, I'd try to do it in the DB rather than the application.
15:39:05 <heatsink> Haskell libraries tend to have an interface that conforms closely to the library's semantics.  This can be frustrating for new users, but it's the main thing you will benefit from if you use Haskell.
15:39:28 <heatsink> Rather, the main thing you will benefit from if you take the time to learn the Haskell APIs
15:39:34 <hunt> is it possible in IO to write to a file in a similar way to C, ie progressively instead of in one call
15:39:52 <Maerten> heatsink: thanks, I have seen the db libs, I'm using Persist right now. i will check for array libraries.
15:40:10 <geekosaur> hPutStr / hPutStrLn (and openFile) instead of writeFile
15:40:32 <heatsink> Maerten: You probably want to use either Data.Array.STArray or Data.Vector.Unboxed.Mutable
15:40:42 <heatsink> Data.Array.STUarray
15:40:57 <Maerten> thsutton: unfortunately it's not really an option, the example was simplified..
15:41:03 <thsutton> Ah.
15:41:05 <Maerten> heatsink: thank you i will check
15:41:10 <heatsink> Oh, I see.  A PHP array is a hash table.
15:41:24 <heatsink> That's a bit different.
15:42:02 <Rembane> heatsink: And an array at the same time.
15:43:31 <Maerten> it makes it kind of difficult, in PHP i would use array's for almost anything. In haskell there are tuples, lists, trees, etc.
15:43:54 <thsutton> Maerten: Perhaps try nested Data.Map?
15:44:10 <heatsink> hunt: You can imperatively append to a file like in C, though there's an easier way to do it in many cases.
15:44:13 <Maerten> so is constructing a big blob of data like I currently do in PHP the way to go here?
15:44:24 <heatsink> It depends on how memory-constrained you are
15:44:30 <Maerten> thsutton: ok i will look into it
15:45:01 <heatsink> How much data is in the array?
15:45:13 * hackagebot sunlight 0.2.0.0 - Test Cabalized package against multiple dependency versions  http://hackage.haskell.org/package/sunlight-0.2.0.0 (OmariNorman)
15:45:47 <hunt> heatsink: easier as in what kind of way? if i want to write two separate strings is it best to append them then write or some other method?
15:47:54 <heatsink> If you only write two strings to the file, then the complexity doesn't matter much
15:48:33 <Maerten> heatsink: not so much, the structure of the array is like $['domain1']['2014-01-01']['/some_url.html']['pageviews'] = 12345;  and then there are some 20 domains. the greatest amount of data is processed when the total pageviews are calculated once a month, but it's not really much
15:48:34 <heatsink> It's generally better to separate the code that produces output from the code that does I/O
15:48:53 <heatsink> Maerten: Then nested Data.Map should work fine
15:49:22 <Maerten> heatsink: thanks i'll give it a try. is there any reason to prefer Data.Map over Data.Tree ?
15:49:57 <Maerten> for this specific purpose i mean.
15:50:11 <heatsink> Maerten: In my experience, the code is easier to manage if you make a newtype that wraps your nested maps, along with wrappers around the insert/delete/etc. functions
15:51:00 <Maerten> ok sounds good. plenty of things to look into =] thanks for your help!
15:51:11 <heatsink> Maerten: Tree is for when all keys are the same type and the nesting depth is variable
15:52:08 <Maerten> yes i noticed that about the keys. thanks heatsink!
15:52:52 <heatsink> Or in other words, if transplanting a subtree to a different depth turns your tree into nonsense, then it's not really a tree.
15:53:06 <heatsink> You're welcome Maerten
15:53:38 <heatsink> hunt: There are a few stream-like libraries for interleaving the steps of producing and writing I/O
15:54:11 <heatsink> Machines is one
15:54:25 <johnw> conduit and pipes are far more mature than machines, though
15:55:14 * hackagebot sunlight 0.4.0.0 - Test Cabalized package against multiple dependency versions  http://hackage.haskell.org/package/sunlight-0.4.0.0 (OmariNorman)
15:56:30 <hunt> another question
15:56:37 <hunt> ghci is only loading the main function
15:56:41 <hunt> but i want to test the other stuff
15:56:51 <hunt> is there a better way to load source than :l module
15:57:06 <heatsink> That loads all exported functions
15:57:22 <heatsink> If you type :browse then you should see the other exported functions in the module
15:59:52 <hunt> yea so it seems the only exported function is main :: IO ()
16:00:04 <roboguy_> hunt: what is your module declaration like?
16:00:27 <hunt> ah ok I have loaded everything
16:00:37 <hunt> im not really sure how to answer that
16:00:39 <hunt> very new
16:00:47 <roboguy_> oh, never mind
16:05:15 * hackagebot ace 0.2 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.2 (ChrisDone)
16:05:17 * hackagebot ace 0.3 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.3 (ChrisDone)
16:05:21 <pranz> hunt: :l loads everything defined in the top level
16:05:57 <jle`> are short ufnctions inlined by default?
16:08:53 <ski> hunt : nitpick, `main' isn't a function, it's an `IO'-action
16:08:56 <no-n> what's the best way to get to [a,b,a,b,a,b] from [a,a,a] and [b,b,b]?
16:09:09 <ski> interleaving ?
16:09:39 <no-n> if that's what people call it :P
16:10:19 <mmmm> Data.List has a method
16:10:23 <mmmm> I think
16:10:28 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =      ys; (x:xs) /\/ ys = x : (ys /\/ xs)
16:10:29 <lambdabot>  Defined.
16:11:00 <ski> > fix (\ns -> repeat 0 /\/ map succ ns)
16:11:03 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
16:12:21 <ski> > [fix (\go n -> if n == 1 then 0 else n `mod` 2 + go (n `div` 2)) n | n <- [1 ..]]
16:12:22 <lambdabot>  [0,0,1,0,1,1,2,0,1,1,2,1,2,2,3,0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,0,1,1,2,1,2,2...
16:13:47 <ski> > [fix (\go n -> if odd n then 0 else 1 + go (n `div` 2)) n | n <- [1 ..]]  -- rather
16:13:48 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
16:14:01 <no-n> nice :)
16:14:08 <no-n> thanks
16:14:24 <ski> > [fix (\go n -> if n == 0 then 0 else n `mod` 2 + go (n `div` 2)) n | n <- [0 ..]]  -- another one
16:14:25 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
16:14:52 <ski> > fix (\ns -> ((0 :) . tail) (ns /\/ map succ ns))
16:14:54 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
16:15:34 <ski> that one counts number of `1's in the binary representation
16:16:05 <ski> the former counts number of `0's starting from the LSB, until you reach the first `1'
16:16:46 <ski> the `(0 :) . tail' in the latter is a "fudge trick" to force the first element to be `0'
16:17:00 <hpc> ski: isn't the former also the number of bits changed between steps?
16:17:02 <ski> it would be neat if one could define it as
16:17:07 <ski>   ns = 0 : _
16:17:12 <ski>   ns = ns /\/ map succ ns
16:17:13 <hpc> (minus one)
16:17:22 <ski> but that doesn't work, of course
16:17:29 <ski> perhaps one can use `unamb'
16:18:14 <no-n> > concat . transpose [1,2,3] $ [4,5,6]
16:18:15 <lambdabot>  Couldn't match expected type `[t0] -> [[a0]]'
16:18:15 <lambdabot>              with actual type `[[a1]]'
16:18:17 <ski> hpc : no, at least one bit changes in every step
16:18:53 <ski> hpc : it seems like it could be number of changing bits, minus one, though
16:19:15 <no-n> > concat $ transpose [[1,2,3],[4,5,6]]
16:19:16 <lambdabot>  [1,4,2,5,3,6]
16:19:16 <hpc> ski: yeah, i caught myself, see the enxt line
16:19:22 <ski> oh
16:19:30 * ski missed it
16:19:41 <hpc> *next
16:19:49 * hpc takes that as his cue to leave ;)
16:20:07 <ski> > (concat . transpose) [[0,2 ..],[1,3 ..]]
16:20:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:21:03 <FreeFull> ski: Hmm, I smell a really inefficient way to generate the list [0..] in there
16:21:11 <ski> hehe
16:21:13 <FreeFull> Where each number takes exponentially longer to get
16:21:33 <ski> just checking whether it would work to interleave infinite lists that way
16:21:58 <artyomkazak> Why exponentially longer?
16:22:02 <Twey> Then you can zip it with another list and use bogobogosort to no-op the list based on their original positions…
16:22:04 <FreeFull> > transpose [[0,2..],[1,3..]]
16:22:05 <lambdabot>  [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,2...
16:22:45 <FreeFull> artyomkazak: I think my idea wouldn't work anyway
16:22:55 <hpc> [0..] = sort(keys(BB^-1(x))
16:22:59 <FreeFull> Hmm
16:24:25 <FreeFull> > scanl (():) [] $ []
16:24:25 <lambdabot>  Couldn't match type `[()]' with `b0 -> [()]'
16:24:26 <lambdabot>  Expected type: [()] -> b0 -> [()]
16:24:26 <lambdabot>    Actual type: [()] -> [()]
16:25:00 <FreeFull> I want an unfold
16:25:47 <ski> hm
16:26:09 <FreeFull> > unfoldr (\x -> Just (():x,():x)) []
16:26:10 <lambdabot>  [[()],[(),()],[(),(),()],[(),(),(),()],[(),(),(),(),()],[(),(),(),(),(),()],...
16:26:20 <FreeFull> > map length $ unfoldr (\x -> Just (():x,():x)) []
16:26:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:26:29 <FreeFull> > 0 : map length $ unfoldr (\x -> Just (():x,():x)) []
16:26:30 <lambdabot>  Couldn't match expected type `[a0]'
16:26:30 <lambdabot>              with actual type `[[a1]] -> [GHC.Types.Int]'Couldn't match expec...
16:26:34 <FreeFull> > 0 : (map length $ unfoldr (\x -> Just (():x,():x)) [])
16:26:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:26:48 <FreeFull> ski: How inefficient do you think that is?
16:27:05 <artyomkazak> still efficient :(
16:27:18 <FreeFull> > 0 : (map length $ unfoldr (\x -> Just (():x,():x)) []) !! 10000
16:27:19 <lambdabot>  Couldn't match type `GHC.Types.Int' with `[a0]'
16:27:19 <lambdabot>  Expected type: [[a0]]
16:27:19 <lambdabot>    Actual type: [GHC.Types.Int]
16:27:24 <FreeFull> > (0 : (map length $ unfoldr (\x -> Just (():x,():x)) [])) !! 10000
16:27:25 <lambdabot>  10000
16:27:27 <FreeFull> > (0 : (map length $ unfoldr (\x -> Just (():x,():x)) [])) !! 100000000
16:27:31 <lambdabot>  mueval-core: Time limit exceeded
16:27:40 <FreeFull> > [0..] !! 100000000
16:27:43 <lambdabot>  100000000
16:29:06 <ski> > (map length . (`unfoldr` [])) (\us -> Just (():us,us))
16:29:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:29:14 <artyomkazak> But linear nevertheless
16:29:23 <mm_freak_> wow, the ".Strict" and the haddock docs for Control.Monad.Trans.Writer.Strict is horribly misleading
16:29:24 <ski> > (map length . (`unfoldr` [])) (\us -> Just (us,():us))
16:29:25 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:29:33 <FreeFull> Perfect
16:29:37 <quchen> > let foo xs = xs ++ [last xs] in take 10 . map length $ iterate foo ([1] :: [Int]) -- not linear :-)
16:29:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:30:37 <ski> quchen : right, since `xs' is used twice :)
16:31:57 <quchen> I can't come up with a short exponential algorithm.
16:33:28 <FreeFull> > let f 0 = 0; f x = 1 + f (x-1); in iterate f 0
16:33:29 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:33:37 <FreeFull> > let f 0 = 1; f x = 1 + f (x-1); in iterate f 0
16:33:38 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:33:52 <FreeFull> That's definitely not exponential
16:34:32 <FreeFull> And I suspect f gets optimised out somehow
16:35:01 <quchen> Artificially exponential:
16:35:01 <quchen> > let f 0 = 1; f x = 1 + (f (x-1) + f (x-1)) `div` 2; in take 10 $ iterate f 0
16:35:02 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
16:35:03 <FreeFull> > let f 0 = 1; f x = 1 + f (x-1); in iterate f 0 !! 10000
16:35:06 <quchen> But that doesn't really count
16:35:06 <lambdabot>  mueval-core: Time limit exceeded
16:35:08 <FreeFull> > let f 0 = 1; f x = 1 + f (x-1); in iterate f 0 !! 1000
16:35:09 <lambdabot>  1000
16:35:28 <FreeFull> It does slow down for larger numbers
16:35:34 <FreeFull> You should try running it in ghci
16:35:42 <FreeFull> It's a linear slowdown though
16:35:55 <FreeFull> So polynomial time
16:37:19 <FreeFull> quchen: Not sure if yours is exponential or not
16:38:41 <quchen> You can trivially rewrite it to be polynomial again
16:38:45 <quchen> Not pretty.
16:39:29 <monochrom> "f x = 1 + f(x-1)" is exponential. in the number of bits. "f x = ... f(x-1) ... f(x-2) ..." is doubly exponential.
16:39:42 <no-n> from module import (x as a, y, z) # how do I do this in Haskell?
16:40:12 <monochrom> cannot
16:40:19 * hackagebot monad-extras 0.5.7 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.7 (JohnWiegley)
16:40:24 <monochrom> I too wish for rename-while-importing
16:41:11 <shachaf> Haskell 1.2 had it.
16:41:23 <roboguy_> that seems like it would be pretty confusing
16:41:27 <FreeFull> shachaf: Why was it gotten rid of?
16:41:40 <monochrom> not confusing at all
16:42:04 <roboguy_> it would make it harder to look things up
16:42:26 <roboguy_> and I'm not sure when you'd want that over a qualified import
16:42:30 <monochrom> no. it is easier to look up.
16:42:40 <roboguy_> ?
16:43:14 <sssilver> Hello gentlemen
16:43:23 <monochrom> step 1: find "a" in the import list. step 2: find that it renames Data.Map's fromList. step 3: look up Data.Map's fromList.
16:43:38 <sssilver> I've read most of Learn You a Haskell, and am now thinking about writing some simple project
16:43:50 <roboguy_> monochrom: that's longer than step 1: find fromList in import list. look up fromList in Data.Map
16:43:53 <sssilver> I usually write a textmode Tetris game when I'm learning a new programming language
16:44:00 <sssilver> but with Haskell, it seems like it'd be too difficult
16:44:03 <sssilver> what'd you recommend?
16:44:11 <mm_freak_> sssilver: would it?  should be easy enough using vty
16:44:18 <no-n> can it be done with just one thing?
16:44:26 <no-n> e.g. from module import foo as bar
16:44:30 <roboguy_> no-n: yes
16:44:40 <roboguy_> er no
16:44:45 <roboguy_> I thought you meant selective importing
16:44:48 <monochrom> it is only slightly longer, and without loss of clarity.
16:44:50 <no-n> ok
16:45:29 <roboguy_> what would be a good example of something being renamed in a way that is at least as clear as a qualified import?
16:45:34 <carter> anyone up for some singleton types? i have a wee use of them that i wanna get working
16:45:51 <heatsink> ok carter
16:45:54 <carter> https://gist.github.com/cartazio/9179670
16:45:56 <heatsink> sssilver: How about a calculator program?  It's mainly a test of your ability to use a parsers
16:46:08 <no-n> roboguy_: it's about avoid namespace clashes, rather than clarity. but using qualified is fine.
16:46:09 <carter> basicallly because Eff :: * -> * rather than *
16:46:12 <carter> its not promotable
16:46:32 <monochrom> "import Data.Map(fromList as mfromlist); import Data.Set(fromList as sfromlist)" is as clear as "import Data.Map as M(fromList); import Data.Set as S(fromList)"
16:46:37 <mm_freak_> i like the idea of writing a tetris clone more than an expression-based calculator
16:46:48 <carter> heatsink: if i get this working, i can actually express stuff like "i don't care if this input is mutable or not"
16:46:52 <carter> for algorithms!
16:46:57 <mm_freak_> writing a tetris clone teaches you a lot of useful concepts that you need in practical haskell stuff
16:46:57 <carter> without using type classes
16:47:05 <sssilver> heatsink: take something like "(1 + 3 / 2 * sqrt(6.5)) ^ 2" and write the answer?
16:47:09 <carter> like solving NP hard programs by hiring a person :)
16:47:15 <carter> o/ mm_freak_
16:47:23 <Rembane> For a Tetris clone: What about the graphics?
16:47:33 <Earnestly> Ascii
16:47:34 <carter> heatsink: its a pretty small piece of code
16:47:39 <carter> or GLOSS
16:47:41 <carter> or Diagrams
16:47:42 <mm_freak_> Rembane: for terminals vty, for real graphics gloss
16:47:44 <carter> or OpenGL
16:47:46 <zRecursive> > (1 + 3 / 2 * sqrt(6.5)) ^ 2
16:47:47 <lambdabot>  23.27352927038917
16:47:52 <mm_freak_> OpenGL is too much
16:47:55 <mm_freak_> just use gloss
16:48:03 <sssilver> I was thinking about Tetris in text mode
16:48:07 <sssilver> like the original Tetris was
16:48:08 <hpc> silly idea of the day: take a source game and change all the parallax maps to a tetris AI
16:48:15 <carter> ?
16:48:21 <carter> you mean teh backgrounds?
16:48:23 <sssilver> I'd just need some sort of terminal control bindings
16:48:25 <mm_freak_> sssilver: vty gives you a text canvas similar to ncurses =)
16:48:39 <Rembane> mm_freak_: Cool! Thanks.
16:48:52 <sssilver> mm_freak_: I see, that should help!
16:48:53 <carter> http://lpaste.net/5044951861002502144
16:49:02 * carter waves for attention
16:49:04 <sssilver> mm_freak_: would it also give me access to keyboard input?
16:49:10 <mm_freak_> sssilver: yeah
16:49:18 <hpc> carter: https://en.wikipedia.org/wiki/Parallax_occlusion_mapping
16:49:22 <zRecursive> Is ghc-7.8 released ?
16:49:25 <carter> zRecursive: its in RC
16:49:30 <monochrom> expression calculator is more useful to me than tetris
16:49:42 <zRecursive> carter: ok
16:49:43 <carter> and assumign you help me get this type thing done, i can help make it ready for release sooner by helping with CPP
16:49:48 <carter> zRecursive: so help me with this unrelated thing :)
16:50:01 <carter> so i can get back to work :P
16:50:06 <carter> pleaseeeee
16:50:06 <carter> :)
16:50:29 <carter> huh
16:50:31 <carter> i have a solution
16:51:39 <monochrom> I do not play with datakinds
16:52:01 <mm_freak_> monochrom: i'd like to encourage people to write stuff in haskell that includes a main loop and handling events from the real world =)
16:52:22 <heatsink> netjoin
16:52:27 <carter> data EVector  :: * -> * -> * where
16:52:28 <carter>     PureVector :: S.Vector el  -> EVector () el
16:52:28 <carter>     MutVector :: SM.MVector s el -> EVector s el
16:52:29 <carter> erm
16:52:29 <carter> not quite what I need
16:52:29 <carter> blah
16:52:54 * heatsink was netsplitted away
16:53:05 <no-n> hehe
16:53:11 <monochrom> that is in no conflict with writing an expression calculator
16:54:01 <heatsink> carter, I think promoted data types are first-order only
16:54:09 <carter> which ?
16:54:14 <monochrom> or my number-guessing game at http://lpaste.net/52480
16:54:14 <carter> heatsink: yeah
16:54:48 <no-n> ty heatsink
16:55:06 <sssilver> so you guys think writing a Tetris in Haskell is a bad idea?
16:55:25 <mm_freak_> monochrom: of course…  my point is that we all know that haskell is one of the strongest languages for DSL design, parsers and evaluation…  but i like when beginners write something that includes less mathy stuff
16:55:37 <mm_freak_> like drawing graphics, handling events, concurrency in general, etc.
16:55:45 <mm_freak_> sssilver: no, i think it's a great idea!
16:55:51 <mm_freak_> by all means, do it =)
16:55:54 <carter> heatsink: blah, I think this needs kind kinds
16:56:03 <heatsink> sorts
16:56:35 <sssilver> I don't know why writing interactive applications like games is so exciting for me
16:56:49 <mm_freak_> sssilver: don't worry…  it's exciting for me as well ;)
16:56:50 <sssilver> even if it's just tetris-
16:56:52 <heatsink> you get to see the result in action
16:57:26 <carter> heatsink: johnw got it working
16:57:27 <mm_freak_> sssilver: btw, rather than writing a text variant you can try gloss…  it's actually easier than vty and gives you pretty graphics =)
16:57:32 <carter> data Eff = Pure | Mut
16:57:32 <carter> data EVector  :: Eff -> * -> * -> * where
16:57:32 <carter>     PureVector :: S.Vector el  -> EVector Pure () el
16:57:32 <carter>     MutVector :: SM.MVector s el -> EVector Mut s  el
16:57:40 <sssilver> although with the idea of stateless programming, I guess it's a lot of so-called "side effects"
16:58:03 <mm_freak_> sssilver: "no side effects" doesn't mean "stateless"
16:58:11 <monochrom> mm_freak_, I do not care what haskell is purported to be good at. I am stating what programs are useful to me.
16:58:28 <carter> :)
16:58:28 <sssilver> mm_freak_: I just mean to say that games are inherently stateful, somehow
16:58:31 <mm_freak_> monochrom: and i wanted to state my point independent of what yours was =)
16:58:39 <mm_freak_> sssilver: of course
16:58:50 <heatsink> carter: Looks like manual unboxing to me?
16:58:58 <carter> unboxing of what?
16:59:08 <carter> a first orderification of what i really want? :)
16:59:19 <sssilver> wow gloss sounds promising
16:59:32 <heatsink> Turned PureVector (Pure ()) a into PureVector Pure () a
16:59:43 <carter> yeah
16:59:44 <dwcook> One of the things I like best about Haskell is the friendly community.
17:00:05 <carter> dwcook: i think you understate :)
17:00:23 <dwcook> carter, how would you state it? :)
17:00:23 <heatsink> Foo (1, 2) 3 ==> Foo 1 2 3 is an unboxing transformation, right?
17:01:09 <monochrom> "first-orderification" is a cool word
17:01:41 <monochrom> perhaps the act of adding -ification to words can be called ificationification.
17:01:43 <johnw> dwcook: we hide our dark underbelly inside IO
17:02:09 <mm_freak_> sssilver: drawing a circle:  main = display (InWindow "blah" (0, 0) (400, 400)) black (color white (circle 200))
17:02:18 <heatsink> y ification
17:02:19 <mm_freak_> vty is already more complicated than that =)
17:02:32 <sssilver> mm_freak_: haha, fair enough
17:02:52 <mm_freak_> sssilver: for animations you would use 'animate' and for games you would use 'simulate' or 'play' =)
17:03:33 <sssilver> an important question here.. do you guys think a person who's math background isn't too huge stands little chance with really utilizing Haskell?
17:03:43 <sssilver> the only math I'm reasonably good at is linear algebra... but abstract mathematics and stuff like that isn't something I've done at all
17:04:03 <mm_freak_> sssilver: don't worry…  the stuff you will need you can learn along the way
17:04:12 <cmears> sssilver, a serious maths background isn't necessary at all
17:04:15 <mm_freak_> in fact it's often easier to learn stuff in the context of haskell
17:04:29 <sssilver> thanks for the input guys
17:04:39 <sssilver> I don't know if you're just trying to be inspirational or you're actually objective :)
17:04:51 <sssilver> you guys are awesome
17:05:06 <mm_freak_> sssilver: let me help you with that choice:  i write OpenGL stuff in haskell ;)
17:05:08 <heatsink> sssilver, I picked up a working knowledge of the relevant math through Haskell
17:05:29 <monochrom> they are objective. they are using Haskell fine without even knowing Ramsey theory.
17:06:14 <hpc> sssilver: shit, you know linear algebra? way ahead of me!
17:06:33 <sssilver> hpc: lol, just been doing my share of 3D graphics engine programming
17:06:38 <mm_freak_> well, knowing linear algebra is pretty natural if you do 3D graphics
17:06:42 <sssilver> hpc: so it was really going from programming to math, not vice versa
17:07:07 <sssilver> and, linear algebra is not difficult
17:07:20 <sssilver> ramsey theory just blew my mind though :D
17:07:21 <carter> sssilver: #numerical-haskell has LOTS of in alg
17:07:25 <hpc> i get an itch to try graphics programming every so often, but it's so hard to set up an environment to test with
17:07:25 <carter> ramsey theory is neat
17:07:30 <carter> easy way to get big numbers
17:07:43 <mm_freak_> hpc: i might be able to help you with that
17:07:53 <sssilver> hpc: graphics programming is difficult (as in: math-heavy), and awesomely colorful and fun.
17:07:56 <mm_freak_> hpc: in the sense that i'm going to release an FRP OpenGL library soon
17:08:17 <monochrom> yes, carter's next made-up variable name after -A$LARGENUMBER was going to be -A$RAMSEY_4_4
17:08:37 <hpc> sssilver: it is; i have had much more luck with just making images (or mooching from nasa) and piping into imagemagick
17:08:51 <mm_freak_> hpc: you will need some linear algebra to use it…  most of what you need is in the 'linear' package, but some things are provided by my library instead, including the perspective matrix you need for fancy 3D scenes =)
17:08:57 <carter> monochrom: didn't erdös say "if the aliens threatend to invade if didnt' tellm them R_4,4, we may as welll give up" ?
17:09:16 <hpc> carter: 4,4 is fine, 5,5 and we're fucked
17:09:27 <sssilver> hpc: well if you sit down for a few evenings with some matrices and affine transformations and vectors and stuff like that, you'll be able to do neat 3D stuff on the screen
17:09:41 <sssilver> hpc: then you sit for a few weeks with optics and physics of lighting, and you're set
17:09:43 <hpc> sssilver: it's a few evenings with no results in the meantime
17:09:52 <mm_freak_> hpc: i found this article very helpful to understand 3D transforms:  https://unspecified.wordpress.com/2012/06/21/calculating-the-gluperspective-matrix-and-other-opengl-matrix-maths/
17:09:53 <hpc> any mistakes at all and you get a black screen
17:10:10 <hpc> (or purple if you make a few very specific mistakes)
17:10:13 <mm_freak_> hpc: ignore the OpenGL-specific parts…  it's mostly a math article
17:10:22 <Twey> mm_freak_: You have a library with a perspective matrix?  I ended up writing my own last time I did GL programming
17:10:26 <sssilver> hpc: that's true :) I remember having spent a week debugging a black screen, in the end it turned out my triangle was just too small to appear on the screen
17:10:38 <mm_freak_> Twey: yeah, but it's not released yet
17:10:52 <Twey> Oh.  :þ
17:11:10 <hpc> mm_freak_: reading... it's certainly easy to skip the opengl parts, opengl code lends itself nicely to being discarded as line noise ;)
17:11:12 <sssilver> hpc: if you do DirectX, Visual Studio has a pretty neat graphics debugger which will show you the state of your pipeline on each step, graphically. That makes things easier
17:11:30 <mm_freak_> Twey: http://lpaste.net/100331
17:11:35 <mm_freak_> that's my matrix
17:13:12 <shergill> so do dependently typed languages like agda or idris have the equivalent of template haskell?
17:13:13 <mm_freak_> hpc: indeed, OpenGL is really ugly…  i tend to abstract most of it away =)
17:13:19 <sssilver> I think a person who's successfully programming 3D graphics on Haskell is nearly divine
17:13:25 <sssilver> mm_freak_: ^
17:13:39 <sssilver> the only person I thought does that is Carmack
17:14:29 <mm_freak_> sssilver: not at all =)
17:14:38 <hpc> carmack was working on the existing research of a few people
17:14:40 <carter> shergill: even better, they don't need it
17:14:42 <monochrom> as time goes by, more mortals can do it
17:14:43 <schurr> is there a data constructor for infinity other than doing 1/0?
17:14:57 <hpc> schurr: 2/0
17:14:58 <monochrom> just like: OOP requires fewer and fewer PhDs to do
17:15:11 <monochrom> no data constructor for infinity
17:15:12 <darkpassenger> phd...you know..pretty huge..
17:15:22 <cmears> doctorate
17:15:23 <randomclown> never understand the human capacity for failure
17:15:25 <shergill> carter: how do you mean?
17:15:31 <hpc> monochrom: true OOP can only be written by someone with a BS in IT
17:15:32 <randomclown> underestimate*
17:15:33 <monochrom> pretty huge diskettes
17:15:39 <schurr> thanks
17:15:40 <darkpassenger> lol ;)
17:15:46 <carter> shergill: i'm sliglty exagerating
17:15:48 <darkpassenger> pretty huge diskette, brow
17:15:50 <shergill> carter: they may not need it for some of the type tricks, but that's not their only use
17:15:51 <randomclown> pretty huge dudes
17:15:54 <carter> yes
17:15:58 <carter> so *less so*
17:16:07 <shergill> sure, but that's not the question
17:16:20 * monochrom has 5.25-inch diskettes. not as huge as 8-inch, but pretty huge compared to SD cards
17:16:41 <heatsink> But do you have a device that can read them?
17:17:12 <monochrom> anyway, just want to remind: when OOP first came out, it required PhDs, too.
17:17:31 <hpc> i store all my data in the form of nazca lines
17:17:52 <mm_freak_> well, the original OOP isn't used very often
17:17:54 <monochrom> hell, it took such giants as Dijkstra to merely think up "please use a loop construct"
17:18:04 <heatsink> hpc: So your data farm could be an actual _farm_
17:18:30 <monochrom> I still have a 5.25-inch floppy drive
17:18:43 <hpc> monochrom: to be fair, dijkstra was hardly the first to complain
17:19:32 <monochrom> http://www.vex.net/~trebla/humour/book_for_sale.html
17:19:33 <hpc> his goto article was about on the level of "end every line of javascript with a semicolon"
17:19:45 <monochrom> haha
17:19:49 <mm_freak_> and today it takes us haskell programmers to say: "please use actual functions"
17:21:25 <hpc> it's a good thing we in this most modern year of 2014 don't do such things as goto-fail error handling in SSL cert validation!
17:21:34 <hpc> imagine the problems that could cause if there was a mistake in that code
17:21:53 * verement coughs.
17:21:56 <mm_freak_> your sarcasm makes me sad =(
17:22:15 <hpc> we have things like -Wall and linting tools, and code review, and unit tests
17:22:24 <hpc> all miraculous technologies that make such errors impossible
17:25:47 <mm_freak_> we have 'bracket'
17:25:50 <mietek> @hoogle Data.Text.Text -> Data.Text.Lazy.Text
17:25:51 <lambdabot> Parse error:
17:25:51 <lambdabot>   Data.Text.Text -> Data.Text.Lazy.Text
17:25:51 <lambdabot>        ^
17:26:09 <monochrom> Haskell Weekly News has not been released for quite a while.
17:26:10 <mm_freak_> bracket and bracketOnError are my favorite functions in the base library
17:27:06 <monochrom> in fact, approximately since I begun my TA job. coincidence? the editor is in my class and therefore just as busy? (it's a brutal course on computability and NP-completeness)
17:27:23 <hpc> monochrom: they use lazy IO
17:27:32 <hpc> they don't write an article until someone visits the site to read it
17:27:41 <monochrom> well, it was not lazy in the past
17:28:40 <hpc> HWN is the -cafe thing with the IRC quotes and such?
17:28:51 <monochrom> to be fair, I didn't notice its absence until I invented a great quote a few days ago and then thought "will it appear in HWN?"
17:28:56 <monochrom> yes
17:28:57 <hpc> haha
17:29:19 <monochrom> @quote monochrom river
17:29:19 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
17:29:19 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
17:29:40 <monochrom> next time someone wants heterogeneous lists or existential lists, try it :)
17:29:57 <joelteon> brilliant
17:30:02 <joelteon> show, then read on the other side
17:30:16 <hpc> hahaha
17:30:20 <mm_freak_> wow, that's clever!
17:30:51 <mm_freak_> monochrom: but i want my list to contain functions of different types
17:30:56 <hpc> quick, someone write a framework that abstracts out the process of manually showing everything that crosses rivers!
17:31:07 <heatsink> But generally, that question comes about because someone notices that they're typing 'show' N times and they want to abstract it out
17:31:41 <hpc> (related: i am bothered by the proliferation of frameworks that take program flow for themselves, instead of plain libraries)
17:31:58 <mm_freak_> [(a :: *, a)]
17:32:06 <heatsink> Like event-driven frameworks?
17:32:50 <hpc> yeah
17:33:15 <hpc> i am having a hard time naming examples, because the one thing that currently comes to mind is happstack, which is a good framework
17:33:26 <hpc> it abstracts away one absolute pisser of a control flow pattern
17:34:04 <mm_freak_> hpc: just recently i had a debate about why i think SDL is better than GLUT/GLFW
17:34:14 <mm_freak_> it gives me waitEvent and pollEvent instead of callbacks
17:34:40 <hpc> i actually have written down somewhere that i need to try sdl
17:34:40 <mm_freak_> happstack doesn't have that problem, because you could always use concurrency
17:35:21 <hpc> in my case happstack actually does have a bit of a problem
17:35:28 <hpc> i am making a game that is web-based
17:35:34 <hpc> and configured via a web page as well
17:35:48 <hpc> so i have happstack do its thing in one thread, and another thread opens the configure page in a browser
17:35:58 <mm_freak_> huh, why?
17:36:20 <hpc> because it's a nice UI thing and i wanted to see if i could
17:36:30 <mm_freak_> ah
17:36:34 <hpc> but there's no way to have the second thread wait until happstack is "spun up"
17:37:06 <hpc> so i just have it threadDelay for a fraction of a second to make sure
17:37:34 <hpc> (probably doesn't matter for happstack, but it might for another kind of framework)
17:37:46 <mm_freak_> i see, but why do you even need to wait for that?
17:37:58 <hpc> i probably don't
17:38:41 <hpc> but i don't want it to open a browser first, go "oops, cannot haz page", then finally start accepting connections
17:38:50 <hpc> even if very rarely
17:38:59 <stepcut> you are starting a happstack server and launching a browser window at the same time?
17:39:07 <hpc> yeah
17:39:08 <mm_freak_> oh, i see…  you're using the browser as the primary UI from the application itself
17:39:33 <hpc> i came up with this about a year ago, but then recently at work had need of a virtual windows server
17:39:38 <hpc> and apparently exchange does the same thing
17:39:49 <mm_freak_> is it threepenny-gui by any chance?
17:39:56 <stepcut> you could have your app start the happstack thing, then poll until it gets a successful request and then launch the browser page?
17:40:02 <hpc> it's not
17:40:31 <hpc> i actually ifdef to see if i should call windows's "start" to open the default browser, or "x-browser" or whatever
17:40:41 <hpc> it's super gross
17:40:52 <hpc> and i could easily do something better now
17:41:05 <hpc> but the game is for fun, and i don't feel like coding unfun things
17:41:15 <hpc> so i will probably never finish
17:41:49 <carter> hpc: haveyou looked at three-penny at all/
17:42:03 <hpc> i have not
17:42:10 <carter> you might like it ALOT
17:42:19 <hpc> whatis?
17:42:23 <hpc> native gui lib?
17:42:35 <carter> https://hackage.haskell.org/package/threepenny-gui
17:43:48 * hpc is debating doing everything over again as a native gui program
17:44:08 <hpc> it's currently the most ridiculous hodgepodge of technologies
17:44:19 <dmj`> hpc: could you just ajax or websocket poll the server to check if it's up, o/w display a loading message
17:44:26 <hpc> map generation via imagemagick, gui via happstack and blaze-html, backend is acid-state
17:45:07 <hpc> and i should really just use sdl or something
17:47:43 <mm_freak_> acid-state for a game…  i hope you create checkpoints regularly ;)
17:48:16 <hpc> i stage the actions that will step the game forward, and then run them all at the same time
17:48:20 <hpc> simultaneous turn-based
17:48:48 <hpc> or something like that, haven't decided
17:50:08 <mm_freak_> this is one of the rare cases when i'd probably prefer raw safecopy over acid-state
17:50:27 <hpc> like i said, ridiculous hodgepodge of technologies ;)
17:50:27 * hackagebot anonymous-sums 0.4.0.0 - Anonymous sum types  http://hackage.haskell.org/package/anonymous-sums-0.4.0.0 (OmariNorman)
17:50:39 <mm_freak_> that's also what my "savegames for free" experiment is based on
17:50:39 <dmj`> mm_freak_: will data be lost if checkpoints aren't created regularly?
17:50:53 <mm_freak_> dmj`: no, but your transaction log will explode
17:51:10 <roboguy__> hpc: sdl in haskell is pretty frustrating in my experience
17:51:21 <mm_freak_> dmj`: also startup times will get slower and slower
17:51:25 <mm_freak_> roboguy__: why?
17:51:45 <dmj`> mm_freak_: sure startup times will be slower, but how often will he shut it down?
17:52:25 <mm_freak_> dmj`: the main problem is that the transaction log gets bigger and bigger…  for a game usually a lot of state changes happen
17:52:38 <hpc> dmj`: startup times are just as important for continuous uptime stuff
17:52:59 <hpc> because when it inevitably has to be restarted, you want it to be like restarting gdm or something
17:53:06 <hpc> not like restarting exchange
17:53:24 <roboguy__> mm_freak_: if I remember right, the higher level sdl library doesn't even work on OS X so I had to use the low level functions that change their arguments in unsafe ways
17:53:38 <dmj`> mm_freak_: could you create an app that monitors the log size and creates a checkpoint automatically and manually removes old checkpoints
17:53:46 <hpc> roboguy__: blaming a haskell library for osx issues is unfair
17:53:55 <mm_freak_> roboguy__: i hope that the sdl2 library will become usable soon
17:54:10 <mm_freak_> the SDL library uses the deprecated sdl-1 anyway
17:54:19 <mm_freak_> dmj`: sure
17:54:26 <roboguy__> hpc: why? sdl itself seems to work fine...
17:55:00 <hpc> dmj`: acid-state automatically creates checkpoints at regular intervals, using safecopy internally
17:55:11 <dmj`> mm_freak_: this is why loading transaction logs from an S3 bucket would be awesome. Then you could just create a checkpoint every hour
17:55:11 <mm_freak_> hpc: really?
17:55:13 <dmj`> hpc: really?
17:55:20 <hpc> indeedily doodily
17:55:33 <roboguy__> mm_freak_: me too
17:56:02 <hpc> afaict, at least
17:56:56 <hpc> hmm, not finding anything in hackage's source to corroberate
17:57:33 <dmj`> hpc: My understanding is that safecopy is just used for versioning, I believe cereal uses it to save tags w/ your serialized functions so it knows how to repopulate it back into memory and perform migrations when it sees an incremented version #
17:57:48 <dmj`> correct me if I'm wrong tho
17:57:50 <mm_freak_> hmm…  it would be interesting to write the game using FRP server-side and render it client-side using WebGL =)
17:59:27 <hpc> dmj`: it is
18:00:14 <hpc> from what i can tell of acid-state's api, things are stored as (latest checkpoint, [changes])
18:00:56 <hpc> you use template haskell to convert (stuff -> ... -> Update ...) actions into data constructors that can be serialized
18:01:41 <hpc> so a state might be (0, [Succ, Succ, Succ]), where Succ is the automatically created constructor for the update action succ :: Update Int ()
18:01:56 <hpc> you make a checkpoint, and now the state is (3, [])
18:04:16 <dmj`> hpc: so the checkpoint clears the state?
18:04:32 <mm_freak_> dmj`: it clears the transaction log
18:04:32 <hpc> the checkpoint applies the staged changes and removes them
18:04:32 <dmj`> would (3,[Succ,Succ,Succ]) stay in there?
18:04:39 <hpc> no
18:04:53 <hpc> (3,[Succ,Succ,Succ]) => (6, [])
18:05:09 <mm_freak_> dmj`: the "current state" is the last checkpoint state with all later transactions replayed
18:05:19 <dmj`> ok so a checkpoint writes a new checkpoint file, clears the existing state, and then reloads it from the new file?
18:05:30 <hpc> no
18:05:38 <hpc> we're talking entirely on-disk behavior
18:06:04 <hpc> in-memory, the state is stored as current state only
18:06:27 <mm_freak_> dmj`: a checkpoint is just a file…  it contains the state of your data at any point in time…  it indeed encodes a value of your state data type
18:06:39 <mm_freak_> dmj`: then when you make a transaction, only a log entry is written
18:06:47 <hpc> and the update action is (begin transaction >> perform update in memory >> write to transaction log >> end transaction)
18:06:59 <hpc> so...
18:07:03 <hpc> memory: 3
18:07:13 <hpc> disk: (0, [Succ, Succ, Succ])
18:07:17 <dmj`> mm_freak_: ahhh ok I get it, on disk it's smaller since the state is update to (3, []), no more history.
18:07:31 <hpc> >update state Succ
18:07:34 <hpc> memory: 4
18:07:36 <mm_freak_> dmj`: when you load your state, acid-state finds the most recent checkpoint and replays all transactions that occurred after that
18:07:43 <hpc> disk: (0, [Succ, Succ, Succ, Succ])
18:07:48 <hpc> >checkpoint
18:07:50 <hpc> memory: 4
18:07:52 <dmj`> mm_freak_, hpc: do checkpoints create new empty log files as well?
18:07:54 <hpc> disk: (4, [])
18:08:01 <mm_freak_> dmj`: no, just the checkpoint file
18:08:19 <mm_freak_> dmj`: transaction logs are created on demand
18:08:29 <dmj`> mm_freak_: when do new event logs get added?
18:08:37 <mm_freak_> dmj`: when you Update
18:08:51 <mm_freak_> in other words when you change the state
18:09:11 <mm_freak_> (or rather when you /potentially/ change the state)
18:09:12 <dmj`> mm_freak_: I can see an event-0000x.log being appended to, but how does acid-state know to create an entirely new one?
18:09:23 <dmj`> a new event-0000x.log that is
18:09:48 <mm_freak_> dmj`: i'm not sure about the precise file format and how file names are selected
18:10:07 <mm_freak_> but you can make a basic assumption:  when you perform an Update operation, a new log entry is created
18:11:12 <mm_freak_> when your update action is finished, the log entry is guaranteed to be written, so now your application can decide to crash or your power cable can decide to break
18:11:51 <hpc> if your power cable craps out before the update action finishes, the log entry is guaranteed to not be written, also
18:12:11 <mm_freak_> indeed
18:12:24 <hpc> with the usual stipulations of STM-like stuff
18:12:27 <dmj`> mm_freak_: k, so if I have an acid-state being served by a remote server, if I add a query, to ensure the system keeps running all I need to do is rebuild the db server and swap out the binary right? Web server binaries don't need to be touched (unless they take advantage of the new query).
18:12:28 <hpc> no MonadIO, etc
18:13:05 <mm_freak_> dmj`: not sure what you mean…  acid-state is a haskell library, not a daemon
18:13:16 <mm_freak_> you use it as part of your server application
18:13:17 <hpc> mm_freak_: acid-state has a network interface too
18:13:28 <mm_freak_> sure, but i don't trust that one =)
18:13:33 <hpc> heh
18:13:35 <dmj`> mm_freak_: why? :)
18:13:57 <dmj`> mm_freak_: it uses STM to ensure threads make changes in sync
18:13:58 <mm_freak_> because i don't know its protocol, and it doesn't employ any kind of security
18:14:07 <hpc> there's an acid-state-tls
18:14:17 <mm_freak_> ah, nice
18:14:30 <oakwhiz> I was looking at the pwstore-fast package and I think I might have found a timing attack. https://github.com/PeterScott/pwstore/blob/master/pwstore-fast/Crypto/PasswordStore.hs#L325
18:14:34 <dmj`> mm_freak_: there is acid-state-tls, but I couldn't get it to connect from windows to unix using it, so I had to scrap it. Plus, your db shouldn't be exposed publicly anyway
18:14:40 <hpc> and the protocol is on top of tcp, which has edge conditions that mean you don't get end-to-end transaction niceness from server to client
18:15:14 <hpc> it's like rdbmses, where network could crap out mid-query and it still gets written but the client never sees it happen
18:15:17 <mm_freak_> oakwhiz: indeed!
18:15:24 <mm_freak_> oakwhiz: please report that to the author
18:15:28 <oakwhiz> will do.
18:15:32 <hpc> no data gets corrupted, but it is in some sense "written before the update finishes"
18:18:00 <hpc> in any event, if you need to operate acid-state remotely you have almost certainly evolved beyond "haskell data structure stored transactionally to disk" and should use a more proven db
18:18:41 <dmj`> hpc: what isn't proven about it? It's been around for a while
18:19:02 <dmj`> hpc: plus type-safe queries / updates are a big win
18:19:16 <hpc> dmj`: in terms of performance
18:19:27 <dmj`> hpc: is it not performant?
18:19:40 <mm_freak_> dmj`: acid-state is as fast as you want it to be for an in-memory haskell data structure
18:19:41 <hpc> i don't know that it's been measured to the degree of other dbs
18:19:52 <mm_freak_> dmj`: RDBMSes are very fast at stuff that is potentially not in memory yet =)
18:19:55 <hpc> it's no redis, for sure
18:20:14 <hpc> you would never store a terabyte of data in acid-state
18:20:14 <dmj`> mm_freak_: haha :) exactly
18:20:33 <dmj`> hpc: why not (devil's advocate)
18:20:50 <hpc> dmj`: because the data is always entirely in-memory
18:20:57 <hpc> got a tb of ram handy?
18:20:58 <mm_freak_> dmj`: RAM is cheap, but then you still need a board that allows you to stick 1 TiB of RAM into it ;)
18:22:27 <dmj`> mm_freak_: true, if stuff get's bad, in theory you could buy your own H/W, colocate it, and then have it VPN in to your amazon VPC, to get a hybrid type data center. Since AWS RAM prices aren't cheap.
18:22:54 <dmj`> mm_freak_: the issue comes in w/ the log sizes. S3 storage has no limit, so loading from that would be nice.
18:23:11 <metanat> probably gets said all the time, but thought I would share. I just started learning haskell, and it is so beautiful. I think I am in love
18:23:38 <hpc> metanat: haskell is my forever language, get your skanky brain away from it! ;)
18:24:24 <mm_freak_> metanat: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
18:24:36 <mm_freak_> i don't like the conclusion, but it's still a beautiful post =)
18:25:52 <mm_freak_> (and the premise is weird, too)
18:26:15 <metanat> hpc: haha
18:27:09 <dmj`> hpc: I'm not sure my remote acid state is actually performing checkpoints when it's called... think it might be a bug
18:27:27 <hpc> dmj`: yeah, i think i was mistaken
18:27:47 <hpc> i can't find anything in acid-state's source to support my idea that it performed regular checkpoints
18:28:16 <hpc> (probably to avoid situations where things block for a long time on colossal update actions)
18:28:20 <mm_freak_> hpc: it surprised me, too…  i've never observed it creating checkpoints by itself
18:28:42 <mm_freak_> hpc: i generally keep my program in a huge 'bracket' scope that creates a checkpoint at the end
18:28:59 <hpc> to be fair, it looks a lot like it does do regular checkpoints from the way the docs are written
18:29:06 <mm_freak_> bracket (open…) createCheckpointAndClose $ \db -> …
18:29:13 <hpc> it doesn't mention anywhere that it doesn't
18:29:26 <mm_freak_> and it doesn't mention anywhere that it does
18:29:44 <rusk101> Hello guys. Im creating a function for the Chinese Remainder Theorem and Im having some syntax issues. crt :: [Integer] -> [Integer] -> Maybe Integer crt as ms | crtHasSolution as ms == False = Nothing           | otherwise let prod = product ms                        es = zipWith (minv) (map (prod/) ms) ms                       xs = zipWith (mod) es ms                       in sum (zipWith3 (\a b c -> a*b*c) as xs es
18:29:46 <hpc> yeah
18:29:52 <dmj`> mm_freak_: when you send the Ctrl-C HUP (kill signal?) does it perform a checkpoint?
18:30:09 <dmj`> rusk101: use lpaste.net to paste your code hard to read
18:30:24 <jophish> Yo yo yo
18:30:25 <mm_freak_> rusk101: could you paste your code on lpaste.net?
18:30:25 <rusk101> http://lpaste.net/100333
18:30:28 <rusk101> sorry
18:30:30 <mm_freak_> thanks =)
18:30:34 <jophish> Is there a nicer way of doing this? http://lpaste.net/100332
18:30:47 <roboguy__> rusk101: the let bindings show line up
18:30:50 <roboguy__> *should
18:30:53 <mm_freak_> rusk101: otherwise = …
18:31:01 <dmj`> rusk101: I don't think you can use "as" it's a reserved keyword I believe
18:31:15 <mm_freak_> rusk101: also there is no reason to keep checking and calculating the solution separate
18:31:17 <dmj`> oops nevermind :)
18:31:18 <roboguy__> dmj`: you can use it. it's not reserved
18:31:22 <hpc> dmj`: it's only a keyword in imports
18:31:30 <hpc> in one particular spot
18:31:32 <mm_freak_> rusk101: if there is no solution you will have an impossible division
18:31:50 <roboguy__> also your result isn't a Maybe value in the otherwise branch
18:31:58 <hpc> (haskell parsing has a few weird points - another is in how "{-
18:32:02 <hpc> " is found)
18:32:16 <hpc> ((and "--")
18:32:18 <hpc> )
18:32:25 <mm_freak_> rusk101: so you should probably start by writing invertMod :: Integer -> Integer -> Maybe Integer
18:34:08 <rusk101> Oh, i should include Just
18:34:42 <mm_freak_> rusk101: on a more general style note:  your code suffers horribly from boolean blindness
18:34:45 <saml> hello you need help?
18:35:02 <saml> boolean blindness
18:35:13 <mm_freak_> try avoiding partial functions and use Maybe instead of Bool
18:35:19 <saml> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
18:35:36 <mm_freak_> saml: yeah, that one =)
18:35:52 <rusk101> so I should say == instad of =?
18:36:03 <mm_freak_> rusk101: no, it's a conceptual problem
18:36:11 <mm_freak_> rusk101: what's the type of your minv?
18:36:13 <saml> rusk101, can i see your code?
18:36:20 <randomclown> is it ok use Set in an IORef?
18:36:20 <enthropy> is there something like camlp4 for ghc?
18:36:25 <randomclown> if I need it mutable
18:36:28 <mm_freak_> randomclown: sure
18:36:38 <rusk101> one sec
18:36:48 <randomclown> is there a thread-safe synchronised set?
18:37:14 <rusk101> http://lpaste.net/100333
18:37:33 <enthropy> randomclown: you can put the set in an MVar or so to make sure only one thread reads/modifies it at once
18:37:55 <roboguy__> rusk101: you need "| otherwise = let ..."
18:38:39 <athan> Hey guys I got a quick question; is foldr structurally recursive and foldl corecursive?
18:38:49 <dmj`> randomclown: or you could put it in a TVar
18:38:52 <rusk101> parse error on input es
18:38:53 <mm_freak_> athan: rather the opposite
18:39:20 <athan> mm_freak_: Ahh, i thought foldr had to reach the final element in a list before executing...?
18:39:21 <randomclown> hmm ok
18:39:33 <randomclown> is Set T.Text perferable to Set String?
18:39:34 <mm_freak_> athan: but the question is really apples vs. bananas…  you should rather compare foldr and unfoldr
18:39:38 <mm_freak_> athan: foldl is something weird
18:39:39 <athan> mm_freak_: does it start from the right, or "move" right?
18:39:49 <mm_freak_> athan: both foldr and foldl move right
18:39:51 <athan> mm_freak_: ahh damn
18:40:02 <athan> mm_freak_: hmm, needs me some more learnings
18:40:14 <roboguy__> rusk101: the lines of a let have to line up also
18:40:32 <shachaf> I,I foldr :: (Maybe (a,b) -> b) -> [a] -> b
18:40:44 <mm_freak_> athan: foldr can be both recursive and corecursive in haskell…  in a total language it's only one of the two, depending on the list type
18:40:56 <mm_freak_> athan: if the list type is corecursive, then foldr is impossible
18:41:06 <rusk101> like so? http://lpaste.net/100333
18:41:53 <roboguy__> rusk101: usually they are aligned on the left. that might work, I'm not sure
18:42:15 <athan> mm_freak_: Where could I learn more??
18:42:18 <mm_freak_> rusk101: that won't work
18:42:21 <rusk101> ok. i made the allignment on the left. and it gave parse error possibly incorrect indentation or msmatched brackers
18:42:32 <mm_freak_> athan: good question…  i've learned most of this by trial and error =/
18:42:45 <mm_freak_> athan: but doing this stuff in agda helps a lot
18:42:59 <roboguy__> rusk101: this is what I mean http://lpaste.net/100337
18:42:59 <athan> mm_freak_: Hmm I'll check it out
18:43:01 <shachaf> You can learn about things by thinking about Mu and Nu (and Fix).
18:43:23 <athan> mm_freak_: Thanks again, I couldn't get anywhere without you guys here haha.
18:43:37 <athan> wouldn't*
18:43:46 <shachaf> newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }; data Nu f = forall x. Nu x (x -> f x)
18:43:53 <mm_freak_> it was quite surprising that foldr is impossible for colists
18:43:54 <rusk101> mm_freak: what won't work?
18:44:00 <mm_freak_> rusk101: right-aligning
18:44:18 <saml> rusk101, your code hard to read
18:44:29 <shachaf> Rather than lists, just think about Mu Maybe and Nu Maybe (both of them isomorphic to Nat, in Haskell).
18:44:37 <shachaf> (data Nat = Z | S Nat)
18:44:44 <saml> probably because i don't know what gcd, crt, co prime mean
18:45:03 <Twey> jophish: balanced = (== 0) . foldl (\ t x -> case x of _ | t < 0 -> t; Open → t + 1; Close → t - 1) 0
18:45:04 <mm_freak_> saml: number theory
18:45:14 <Twey> jophish: Or foldl', preferably
18:45:18 <roboguy__> saml: gcd is a semi-common acronym
18:45:22 <hpc> gcd = greatest common demoninator
18:45:37 <hpc> largest number that is a factor of every input
18:45:41 <jophish> Twey: that will accept on [Close,Open]
18:45:41 <mm_freak_> saml: greatest common divisor, chinese remainder theorem, and x and y are coprime, if gcd x y = 1
18:45:45 <hpc> crt i don't recognize
18:45:47 <saml> why not use builtin gcd?
18:45:52 <saml> > gcd 2 5
18:45:52 <jophish> it needs to fail if n ever drops below 0
18:45:53 <hpc> co-prime numbers have no common factors
18:45:53 <lambdabot>  1
18:45:53 <BMeph> Twey: -XLambdaCase? :)
18:46:01 <Twey> jophish: No it won't
18:46:08 <Twey> BMeph: Oh, how could I forget about LambdaCase!
18:46:19 <mm_freak_> hpc: chinese remainder theorem…  you can solve certain diophantine equations by using it
18:46:20 <jophish> oh
18:46:21 <rusk101> http://lpaste.net/100333 I cleaned it up a bit. Everything else works except. crt which is chenese remainder theorem. Im getting parse error: incorrect indentation or mismatched brackers
18:46:23 <jophish> sorry, Twey
18:46:29 <mm_freak_> hpc: also you can optimize modular arithmetic with the CRT
18:46:51 <mm_freak_> rusk101: the error is in the last line
18:46:55 <roboguy__> rusk101: you should put a comment that says where the error is
18:46:56 <mm_freak_> look closely
18:47:42 <Twey> BMeph: Hm, I think I'd want two arguments, though
18:48:00 <Twey> Which I believe LambdaCase doesn't do
18:48:11 <Twey> Could curry, but it doesn't seem worth it any more :þ
18:48:34 <khyperia> Oh cool, I didn't know about LambdaCase. That's nifty.
18:48:54 <mm_freak_> i was so excited about LambdaCase and MultiWayIf (IIRC), only to find that i've never actually used either =)
18:48:59 * BMeph tips his cyber-hat to khyperia and Twey.
18:50:07 <Twey> khyperia, mm_freak_: It's especially nice in monad expressions.  There's an annoying pattern that looks like: do foo ← someAction; case foo of … where you introduce the name ‘foo’ purely for passing to the case, because the ← syntax doesn't let you specify multiple patterns.  LambdaCase is a nice workaround: you can say someAction >>= \case … instead.
18:50:30 <rusk101> Am i having a syntax issue here or something more conceptual? http://lpaste.net/100333
18:50:39 <mm_freak_> Twey: i tend to just use the ugly variant in an inner do block
18:50:42 <khyperia> Aaand that's wonderful. Thank you for sharing.
18:50:50 <mm_freak_> do ok <- getOk; unless ok …
18:50:52 <roboguy__> rusk101: look at the last line
18:50:55 <rusk101> omg
18:50:57 <rusk101> im dumb
18:51:01 <Twey> mm_freak_: Blech.  :þ
18:51:33 <mm_freak_> Twey: maybe when we finally get MonadCase or MonadicIf in the standard, i might use a nicer style =)
18:51:36 <Twey> mm_freak_: I'd use ‘getOk >>= flip unless …’ there anyway.
18:52:05 <mm_freak_> Twey: which isn't much nicer
18:52:24 <mm_freak_> this is simply a case that is poorly covered by current sytnax
18:52:25 <mm_freak_> syntax
18:52:53 <Twey> It avoids making up an arbitrary name for something that ought to be a simple pipeline
18:53:03 <mm_freak_> Twey: sure
18:53:08 <freebsdhaskell> Hi there quick question: I it obvious from the API of a module/library if it uses impure things (IO) or do I have to dig through the source?
18:53:12 <Twey> True that, but LambdaCase patches it quite nicely, I think.
18:53:25 <Twey> freebsdhaskell: It has to be obvious
18:53:37 <mm_freak_> Twey: i think the real issue is producing the Bool in the first place here, which is unfortunately what OpenGL does a lot
18:53:39 <freebsdhaskell> Twey: awesome, thanks :)
18:53:47 <Twey> freebsdhaskell: Unless it's evil and uses unsafePerformIO, but in that case you shouldn't be able to tell, and if it is that's a bug you should file
18:53:47 <mm_freak_> Twey: there is simply no nice way of dealing with booleans
18:53:49 <shachaf> freebsdhaskell: Unless it uses unsafe functions, of course.
18:53:59 <Twey> mm_freak_: That's definitely true
18:54:10 <Twey> freebsdhaskell: and if you can**
18:54:19 <freebsdhaskell> ;)
18:54:40 <Twey> mm_freak_: The ‘bool’ eliminator works well for simple cases; for longer ones I reach for the LambdaCase again
18:55:41 <roboguy__> Twey: I think the sdl package has a lot of bugs in that case
18:56:14 <mm_freak_> sdl is fine actually…  it uses exceptions and Either
18:56:23 <mm_freak_> SDL that is
18:56:50 <mm_freak_> OpenGL (the standard) uses booleans a lot
18:57:03 <mm_freak_> OpenGL (the haskell library) abstracts away most of them
18:57:05 <roboguy__> I was thinking more about how it modifies arguments without too much indication that it's going to do that. I guess I can't expect too much from a C binding though
18:57:05 <Twey> roboguy__: It has a lot of observable unsafePerformIO?
18:57:27 <mm_freak_> roboguy__: oh, you mean that
18:57:40 <mm_freak_> yes, SDL sucks in that regard
18:57:40 <hpc> Twey: solution: obfuscate it until it cannot be observed
18:57:50 <roboguy__> Twey: I don't think so, but it changes arguments sometimes. Now that I look at it again, it looks like there are type synonyms for ForeignPtrs that hid that from me before
18:58:15 <Twey> roboguy__: That's different.  Maybe not good design, though.  ☺
18:58:34 <roboguy__> I'm not sure what the good choice would be in that case actually. I can understand type synonyms for those types, but at the same time they sort of hide potential mutability...
18:59:02 <mm_freak_> there are some functions on Surface values that aren't pure
18:59:59 <Twey> roboguy__: You probably shouldn't hide away IO.  Though you'd have to be in a MonadIO to use it anyway.
19:00:04 <roboguy__> mm_freak_: yeah that's what I mean. It's just a little weird to see a (conceptually) encapsulated type like Surface that doesn't have an annotation saying that it's impure being modified
19:00:10 <mm_freak_> for example the surface width/height can change over time in certain settings, but surfaceGetWidth has a non-IO type
19:00:21 <Twey> mm_freak_: Eek
19:00:40 <mm_freak_> i hope sdl2 works better
19:00:52 <roboguy__> doesn't that kind of thing interact in weird ways with ghc's optimizations sometimes?
19:01:01 <mm_freak_> right now it's a horrible OpenGLRaw-like API
19:01:17 <mm_freak_> roboguy__: yes, and i've actually been bitten by that already
19:01:31 <rusk101> ok. so now i get a new error. its included at the bottom. I know its because of my lack of understanding of Maybe Integer type and Just... http://lpaste.net/100333
19:01:38 <mietek> Does anyone know if scotty is able to handle multiple HTTP requests concurrently?
19:01:45 <roboguy__> mm_freak_: that's a pain
19:01:59 <hpc> mietek: it'd be a pretty fatal flaw if it couldn't
19:02:10 <mm_freak_> rusk101: you stripped off an important part of the error:  the source code location
19:02:38 <roboguy__> mm_freak_: to be fair, it does reprint the line
19:02:41 <rusk101> 23:29
19:02:45 <roboguy__> rusk101: you need parentheses
19:02:51 <roboguy__> Just only takes one argument
19:03:01 <mietek> hpc: yes. And?
19:03:41 <hpc> you can test it yourself by opening two telnet sessions and sending incomplete headers
19:04:01 <mm_freak_> mietek: i have yet to encounter a haskell web framework that doesn't
19:04:44 <mm_freak_> mietek: a framework that doesn't handle multiple connections concurrently is more difficult to write in haskell than one that does
19:04:58 <roboguy__> actually it says that in the error message
19:05:55 <mm_freak_> mietek: if you use GHC and have problems with concurrent connections, be sure to compile your program with -threaded
19:06:16 <mm_freak_> even if you don't intend to use multiple OS threads
19:06:23 <rusk101> it does. thanks. but now this shows up.... http://lpaste.net/100333
19:06:38 <roboguy__> rusk101: you want quot instead of /
19:06:42 <roboguy__> quot is integer division
19:06:55 <mm_freak_> you want div in this case
19:08:19 <roboguy__> oh, right. I always forget which is which
19:09:48 <mm_freak_> in general just use either divMod or quotRem
19:09:53 <mm_freak_> but not both
19:10:42 <mm_freak_> since there is no divRem and no quotMod, it's easy to figure out which one to use =)
19:10:46 <rusk101> ok. I got it to compile finally. but giving me a wrong answer. gives me 57 for when im passing [3,1,1] [5,7,4]
19:11:43 <rusk101> should be 113
19:12:40 <mm_freak_> rusk101: paste your latest code
19:13:24 <rusk101> http://lpaste.net/100333
19:14:18 <mm_freak_> rusk101: first step: change the type of minv
19:14:24 <mm_freak_> minv :: Integer -> Integer -> Maybe Integer
19:14:39 <mm_freak_> second step:  remove crtHasSolution
19:15:03 <mm_freak_> third step:  change the type of crt
19:15:16 <mm_freak_> crt :: (Integer, Integer) -> (Integer, Integer) -> Maybe Integer
19:15:35 <mm_freak_> in other words write CRT for two equations
19:15:45 <dncr> why does calling sleep(4) over FFI return right away for me: https://github.com/dancor/one-off/commit/82018c5808f9da5b0e80b710512c667abb4cae12
19:16:04 <mm_freak_> when you've done that, you can easily turn it into a CRT function for arbitrarily many equations
19:17:13 <geekosaur> dncr: because the runtime doesn't turn off the periodic alarm signal (itimer) during FFI calls for some reason, and sleep() is interrupted by signals
19:17:45 <geekosaur> if you check errno after sleep() you'll probably find it's EINTR
19:19:00 <dncr> geekosaur: ah.
19:19:01 <hunt> hey guys
19:19:06 <hunt> GLFW is failling to install on my mac
19:19:19 <hunt> anyone have any experience with this?
19:19:49 <dncr> i'm surprised that isn't seen as a Big compromise of FFI
19:20:15 <geekosaur> saying something like that without providing output/error message (in a pastebin, please) is like saying nothing but "it don't work"
19:20:41 <mm_freak_> hunt: i would love to say, "just use SDL", but just earlier today someone noted that it doesn't compile on macs either =)
19:20:59 <geekosaur> dncr: the not disabling signals thing has been noticed before, it is possible you need to specify a flag on the FFI declaration
19:21:26 <roboguy__> mm_freak_: :(
19:21:44 <hunt> here: http://pastebin.com/UTtu0EAB
19:21:59 <rusk101> mm_freak: I think the error is somewhere in my crt algorithm. I dont see a reason why making minv a Maybe Ineger
19:22:01 <hunt> oh god so its maybe just broken?
19:22:28 <mm_freak_> rusk101: because the whole crtHasSolution thing is redundant and introduces unnecessary boolean blindness
19:22:36 <mm_freak_> rusk101: it makes your code complicated and difficult to understand
19:22:55 <mm_freak_> rusk101: also minv has to be Maybe, because it can fail
19:23:09 <roboguy__> hmm, I wonder why glfw package compiles those source files to assembly
19:23:23 <mm_freak_> rusk101: and that's precisely why CRT sometimes doesn't have a solution…  you don't need to check that the moduli are coprime, because if they aren't, minv will fail
19:23:32 <geekosaur> last time I tried it, the only reason SDL "didnt build" was you had to get an SDL from somewhere, and it had to be compatible with your ghc (that is, from a compatible source: if you get SDL from homebrew then your ghc must also be from homebrew or you get weird link errors)
19:24:10 <rusk101> ok thx for the explanation
19:24:27 <hunt> so i should install glfw with brew and install bindings with cabal?
19:24:35 <hunt> geekosaur: ^
19:24:48 <mm_freak_> rusk101: given a proper minv, the entire CRT is a nice three-liner =)
19:24:49 <roboguy__> geekosaur: what's the sdl that's compatible with haskell platform/the ghc 7.8 rc?
19:24:49 <Guest46309> ohai
19:24:52 <geekosaur> the official GHC-HQ or HP packages will not work with an SDL from fink, homebrew, or macports. (apple has managed to make the library situation on macs rather annoying. google "mac iconv" sometime)
19:25:37 <roboguy__> geekosaur: what do those package managers do that's different?
19:25:42 <geekosaur> roboguy__, I don't know if anyone provides a package built against Apple standard libs, you might have to build it yourself
19:26:47 <geekosaur> Apple ships out of date (for example iconv) or incompatible (for example readline) versions of a lot of things, so all the package managers maintain their own versions. (Even Homebrew has figured out that this is necessary.)
19:26:47 <Guest31429> What would be the quickest way to trace a function in ghci?
19:26:50 <hunt> also, is anyone high up in the haskell community talking about how to get this language more popular?
19:27:17 <simpson> hunt: Why is popularity necessary or good?
19:27:43 <mm_freak_> simpson: because it makes my life easier
19:27:44 <carter> hunt: talking != doing
19:27:45 <carter> i'm doing :)
19:27:52 <Fuuzetsu> hunt: because libraries aren't gonna write themselves
19:27:57 <geekosaur> but everyone deals with the iconv incompatibility in a different way: macports does it in a way that causes compile time errors on mismatches, fink (and maybe homebrew? have not checked) do it in a way that causes runtime core dumps on mismatches
19:27:59 <mm_freak_> and yeah, i'm with carter there
19:28:08 <hunt> simpson: so the language has a stronger community and then libraries and then you can actually use it practically
19:28:09 <carter> mm_freak_: though i talk A LOT too :)
19:28:11 <roboguy__> hunt: the fpcomplete people
19:28:17 <mm_freak_> carter: me, too
19:28:19 <carter> roboguy__: eh :)
19:28:25 <roboguy__> sort of
19:28:25 <carter> they're helping
19:28:30 <carter> but they're not leading the charge
19:28:35 <geekosaur> because the static initialized data for appple's iconv is incompatible with the library code for the modern iconv versions everyone else uses
19:29:03 <geekosaur> likewise, apple's readline is actually bsd editline, but everyone else uses readline that is actually gnu readline
19:29:18 <carter> gplv3 made things complicated
19:29:27 <geekosaur> so, massive pains in the *** everywhere
19:29:37 <carter> geekosaur: ooth, clang is NICE :)
19:29:52 <geekosaur> seriously, I like OS X's environment, but if you want stuff to just compile, stay on linux
19:30:08 <carter> brew's a ghetto
19:30:13 <carter> but its an easy to patch active ghetto
19:30:48 <simpson> hunt: You can use Haskell practically already.
19:31:17 <simpson> hunt: There are nearly as many people in here as there are in #python. What part of the community is weak? What kind of popularity do you seek?
19:31:18 <mm_freak_> btw, i don't think popularizing haskell is a thing…  pick your favorite aspect of haskell and popularize that one instead
19:31:34 <mm_freak_> my personal thing is FRP =)
19:31:43 <orbital_> ok, myself again... To see what a function is doing in ghci, is there an easy way?
19:31:46 <hunt> simpson: graphical programming
19:31:59 <geekosaur> language popularity proves nothing. I mean, the most popular languages are php and javascript...
19:32:03 <mm_freak_> hunt: like what?
19:32:45 <hunt> mm_freak_: honestly, Im a begginer, but from what I understand the state of the haskell communnity makes it difficult to actually develop in haskell
19:32:59 <mm_freak_> you can do anything from simple shapes (gloss), diagrams (diagrams), plots (Chart) to full 3D games (OpenGL+OpenAL+SDL+network)
19:33:01 <hunt> mm_freak_: but honestly ive put no thought into this, its just the reputation ive picked up on
19:33:03 <geekosaur> ghc is developed on linux
19:33:08 <geekosaur> so it works most easily on linux.
19:33:14 <no-n> that's because the haskell community has no state ;p
19:33:30 <mm_freak_> no-n: depends on your notion of state
19:33:38 <startling> hunt: do you mean GUI-type programming?
19:33:38 <mm_freak_> haskell is particularly great at stateful applications
19:33:41 <dmj`> hunt: it's hard to use haskell w/o an understanding of the types, and that takes time, plain and simple. Your productivity in haskell is predicated on your knowledge of the types.
19:33:55 <geekosaur> windows and os x offer their own pains, partly because they're somewhat alien to many of the ghc devs, partly because os x is just difficult as far as building stuff that originated on linux is concerned
19:34:14 <hunt> startling: i guess, i dont really know, this is not founded on anything except small bits of info ive heard about what haskells not good at
19:34:24 <mm_freak_> one of my favorite state types is defined in the base library
19:34:27 <mm_freak_> and no, it's not IO =)
19:34:38 <johnw> ST?
19:34:39 <mm_freak_> it's this one:  data [a] = [] | (a : [a])
19:34:41 <geekosaur> (and windows is even more so since Microsoft's ecosystem is completely different, whereas OS X is at least a distant relative)
19:34:43 <startling> hunt, oh. I think you're wrong.
19:35:06 <hunt> startling: i wouldnt know
19:35:13 <startling> ok!
19:35:17 <hunt> haha
19:35:45 <roboguy__> I can only imagine how frustrating it is to do regular development on windows
19:35:48 <startling> hunt: the main thing about Haskell is there's sort of a steep learning curve.
19:35:55 <geekosaur> also, I think the state of gui is hampered on linux only because so many people want to invent a functional paradigm for gui programming
19:36:02 <dmj`> roboguy__: using visual studio? Or haskell dev on windows?
19:36:07 <roboguy__> dmj`: haskell dev
19:36:14 <geekosaur> if you ignore the silliness, gtk2hs works fine now
19:36:42 <hunt> startling, i think thats one of the attractive thinks, I'm only originally interested because imperative programming is feeling kind of stale
19:36:58 <hunt> things*
19:36:58 <geekosaur> (with the usual caveats, such as windows compatibility for what is a fundamentally unixy library...)
19:37:20 <geekosaur> er, gui on haskell, not on linux
19:37:22 <geekosaur> derp
19:37:28 <dmj`> roboduy__: I use cygwin and install emacs + haskell_mode. send-to-repl is broke, but I just load ghci in ansi-term. It's surprising how much installs on windows
19:37:35 <hunt> does anyone have any experience installing glfw on mac though? having no luck (http://pastebin.com/UTtu0EAB)
19:37:39 <mm_freak_> geekosaur: that's because it's impossible to get stuff done with existing GUI libraries
19:37:52 <mm_freak_> which is not haskell's fault of course, but it's a problem that deserves a solution
19:38:38 <roboguy__> hunt: do you have the glfw c library installed?
19:39:17 <geekosaur> I think you or someone has said that before, but I've certainly used gtk2hs successfully before
19:39:26 <geekosaur> it's not pretty, it's not idiomatic, but it works
19:39:39 <mm_freak_> geekosaur: it works until you hit the maintainability wall
19:39:49 <hunt> roboguy__, i actually dont know
19:39:50 <geekosaur> if you want idiomatic, well, join all those folks trying to invent some kind of usable frp...
19:39:56 <geekosaur> and wake me up when it's actually usable :p
19:40:10 <mm_freak_> geekosaur: the usable FRP is already there
19:40:15 <geekosaur> (it's kinda sad that the only one that actually is usable is threepenny-gui)
19:40:18 <mm_freak_> so wake up
19:40:22 <roboguy__> hunt: I'd start with installing that. it looks like cabal is trying to and failing
19:41:01 <mm_freak_> geekosaur: your problem may be that you're waiting for reactive-banana-gtk, which isn't necessary…  you can just use reactive-banana itself
19:41:09 <hunt> roboguy__ alright ill have another go at it once ive installed there, thanks man
19:41:24 <geekosaur> oh, I am? really
19:41:25 <geekosaur> ?
19:42:01 <mm_freak_> geekosaur: in the particular case of GTK+ the types even line up right away…  you can just use fromAddHandler with any callback registration function that you encounter
19:42:04 <geekosaur> are you reading too much into my mentioning gtk2hs? or just projecting? (I do not particularly care what underpinning the gui has)
19:42:44 <mm_freak_> geekosaur: well, replace gtk2hs by your favorite event-callback-registration-based GUI framework
19:43:01 <mm_freak_> reactive-banana is written with those frameworks in mind
19:43:18 <roboguy__> what is it about guis that make them so tricky to write in haskell? I've never tried
19:43:31 <mm_freak_> roboguy__: they aren't tricky to write in haskell…  they are tricky to write
19:47:44 <carter> yes
19:47:46 <carter> tricky period
19:48:10 <hunt> hm
19:48:16 <hunt> so i brew installed glfw2 and 3
19:48:27 <hunt> but its giving meno salvation as far as cabal installing glfw
19:50:12 <hunt> man this is frustrating
19:50:22 <hunt> i need sleep
19:50:25 <hunt> but first i need glfw
19:52:51 <carter> hunt: cabal install glfw-b
19:52:53 <carter> works
19:53:53 <hunt> carter, were there any dependencies? mines failing for b too
19:53:59 <carter> whats it say
19:54:05 <carter> "it fails"
19:54:06 <carter> could mean
19:54:10 <carter> "my house exploded"
19:54:15 <carter> which i'm sorry to hear about ;)
19:54:30 <johnw> carter: anything can happen with unsafePerformIO
19:54:46 <carter> johnw: nah, you're thinking inlinePerformIO
19:54:49 <carter> or unsafeCoerce
19:55:00 <ivanm> unsafeInlinePerformCoerceIO! :p
19:55:45 <hunt> carter, http://pastebin.com/kBbmqNwJ
19:56:21 <carter> hrm
19:56:35 <carter> what version of cabal?
19:56:43 <carter> also
19:56:46 <carter> what does ghc --info say
19:56:52 <carter> also what does gcc --version say?
19:57:34 <ivanm> OSX issue?
19:58:02 <xpika_> what's the easiest way of generating the times tables with a maximum multipliers of 10 in haskell as a [[Int]]?
19:58:16 <carter> xpika_: list comprehensions
19:58:18 <xpika_> actually i want the shortest
19:58:25 <carter> list comprehensions
19:58:42 <rusk101> finally got it to work! woohoo! thx mm_freak http://lpaste.net/100333
19:58:54 <orbital_> guards, 'where' clauses and laziness: is the 'where' clause evaluated invariably or only when needed?
19:59:05 <johnw> > (*) <$> [1..3] <*> [1..3]
19:59:06 <lambdabot>  [1,2,3,2,4,6,3,6,9]
19:59:22 <hunt> carter, cabal 1.16.0.2 || ghc --info (http://pastebin.com/Jxcp3Juj) || gcc --version (http://pastebin.com/r3sfMeAb)
19:59:41 <carter> hunt: yer on mavericks i see!
19:59:42 <carter> ok
19:59:51 <hunt> yessir
19:59:56 <johnw> > [1..3] >>= \x -> [1..3] >>= \y -> return (x * y)
19:59:57 <lambdabot>  [1,2,3,2,4,6,3,6,9]
19:59:59 <rusk101> mm_freak_: thanks
20:00:01 <carter> hunt: and using my settings file patch i see :)
20:00:12 <carter> hunt: ok
20:00:38 <carter> 1) cabal update ; cabal install cabal-install # because cabal-install 1.18 is magic and you should have nice things
20:00:41 <hunt> you wrote a settings file patch? thats actually really cool
20:00:56 <carter> hunt: well, whose directions for setting gcc-4.2 did you use?
20:01:09 <carter> afaik, mine is the only one :)
20:01:24 <xpika_> > [[y*x|y <-[1..10]]|x<-[1..10]]
20:01:26 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20],[3,6,9,12,15,18,21,24,27...
20:01:26 <hunt> i dont even remember
20:01:30 <hunt> i guess yours
20:01:33 <hunt> nice !
20:01:36 <xpika_> @pl [[y*x|y <-[1..10]]|x<-[1..10]]
20:01:36 <lambdabot> [[y * x | y <- [1..10]] | x <- [1..10]]
20:02:05 <roboguy__> @undo [[y*x|y <-[1..10]]|x<-[1..10]]
20:02:05 <lambdabot> concatMap (\ x -> [concatMap (\ y -> [y * x]) [1 .. 10]]) [1 .. 10]
20:02:07 <hunt> [x | x <- [1..]]
20:02:08 <carter> 2) cabal install glfw-bindings --ghc-options="-pgmc clang -pgma clang" ; cabal install glfw-b --ghc-options="-pgmc clang -pgma clang"
20:02:13 <hunt>  > [x | x <- [1..]]
20:02:24 <carter> hunt: focus :)
20:02:36 <hunt> haha sorry i wanted to try lambdabot
20:02:47 <Fuuzetsu> hunt: that's just [1..]
20:02:56 <carter> hunt: i mean whats gcc-4.2 --version
20:03:08 <carter> hunt: steps 1 and 2 should leave you in  ahppy place though
20:03:25 <orbital_> dear community, how does one earn the right to ask questions here?
20:03:47 <hunt> Fuuzetsu, i just wanted to see if lambdabot would print it
20:03:51 <Fuuzetsu> orbital_: you just did!
20:04:00 <Fuuzetsu> >[1..]
20:04:08 <hunt> carter, mission failure
20:04:09 <Fuuzetsu> > [1..]
20:04:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:04:18 <hunt>  > [1..]
20:04:26 <Fuuzetsu> no space in front and one space after >
20:04:26 <roboguy__> @pl concatMap (\ x -> [concatMap (\ y -> [y * x]) [1 .. 10]]) [1 .. 10]
20:04:27 <lambdabot> (([1..10] >>=) . flip flip [] . ((:) .) . (*)) `fmap` [1..10]
20:04:28 <hunt> > [1..]
20:04:28 <carter> hunt:?
20:04:29 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:04:35 <orbital_> Fuuzetsu: awesome :) i'll try again then
20:04:39 <orbital_> guards, 'where' clauses and laziness: is the 'where' clause evaluated invariably or only when needed?
20:04:43 <hunt> carter, yea incoming paste
20:04:50 <carter> ohhh
20:04:59 <roboguy__> orbital_: when needed
20:05:07 <orbital_> roboguy__: thanks
20:05:19 <hunt> carter, http://pastebin.com/UcQmDFTC
20:05:59 <roboguy__> > let x = 10 where y = error "This won't be evaluated" in x
20:06:00 <lambdabot>  10
20:06:18 <carter> hunt: https://github.com/bsl/bindings-GLFW/issues/8
20:06:18 <carter> ok
20:06:23 <carter> hunt: i have a solution
20:06:29 <carter> its a bit edgy
20:06:31 <carter> but it should work
20:06:55 <hunt> my middle name is edge
20:07:28 <carter> lemme test locally first
20:07:40 <carter> :)
20:07:53 <hunt> alright ! thanks btw for bein so helpful
20:08:14 <carter> ok
20:08:25 <carter> solution: you get to update to GHC 7.8 RC :)
20:08:54 <hunt> oh boy! (RC?)
20:08:55 <carter> https://github.com/bsl/bindings-GLFW/issues/8
20:08:56 <carter> yes
20:09:00 <carter> lemme linke you to my build
20:09:03 <carter> its a few days old
20:09:04 <carter> but mostly works
20:09:26 <hunt> woah thats .2 versions higher, is this a dev build or something?
20:09:37 <carter> its a release candidate build
20:09:40 <carter> lemme link you by copy
20:09:50 <carter> btw, you should have brew installed gmp
20:09:54 <carter> if you want mine to work
20:10:06 <hunt> installed
20:10:09 <carter> ok
20:10:19 <carter> also gcc-4.8
20:10:25 <carter> but you can edit the settings file to use 4.2
20:10:29 <carter> easy fix
20:10:49 <carter> hunt: basically in 7.8, GHCI / TH uses the system dylinker
20:10:55 <carter> so certain dynamic linker things work :)
20:11:01 <carter> including using LLVM as a library in ghci!
20:11:18 <carter> technically this linked one is pre RC2
20:11:19 <carter> https://github.com/cartazio/ghc/releases/tag/postRC2-7.8
20:11:25 <Platz> any guides out there on upgrading to ghc 7.8 with a haskell platform intall?
20:11:49 <carter> Platz: install the new stuff
20:11:56 <carter> remove the  old ghc
20:12:07 <carter> rm ~/.cabal/config
20:12:09 <carter> cabal update
20:12:13 <carter> know joy
20:12:16 <roboguy__> carter: is it important to remove the old ghc?
20:12:17 <roboguy__> I didn't
20:12:19 <Platz> carter: thanks, will do
20:12:22 <carter> roboguy__: idk
20:12:30 <carter> i just suck a managing my path :)
20:13:47 <enthropy> there is no standard   instance Monoid a => Monoid (IO a)?
20:13:55 <carter> huh
20:14:01 <hunt> carter, for brew linking libffi, is it ok to brew link --force /usr ... /Cellar/libffi/
20:14:06 <carter> sure
20:14:14 <hunt> alright cool !
20:14:19 <carter> you mean brew link --force libffi?
20:14:25 <carter> oh, you got mine DLed already?
20:15:16 <hunt> not yet but im doing the brew stuff ahead of it
20:15:36 <roboguy__> enthropy: there would be at least two possibilities for a Monoid instance for IO
20:15:48 <roboguy__> that could be part of the reason
20:16:44 <carter> yeah
20:16:54 <enthropy> well one possibility is covered by the MonadPlus instance
20:16:55 <carter> no instance is better than "not canonical"
20:17:12 <carter> ok
20:17:14 <carter> i'm tired
20:17:15 <carter> ttyll all
20:17:23 <enthropy> good night
20:17:53 <carter> hunt: also remeeber to wipe your ~/.cabal/config
20:17:59 <roboguy__> good night carter!
20:18:05 <carter> and then do cabal update
20:18:08 <carter> and paste the results
20:18:28 <carter> (i'tll be slightly wrong if you try to then use it for your current 7.6 install, but whatever)
20:19:03 <hunt> carter, so i do that after installing new ghc?
20:19:09 <carter> sure
20:19:13 <hunt> awesome
20:19:17 <hunt> thanks carter
20:19:27 <carter> cabal install glfw-bindings --ghc-options="-pgma clang -pgmc clang"
20:19:44 <carter> err
20:19:45 <carter> i mean
20:19:45 <carter> cabal install bindings-glfw --ghc-options="-pgma clang -pgmc clang"
20:19:53 <carter> then cabal install glfw-b
20:19:56 <carter> works fine for me
20:20:29 <hunt> sweet i should be able to give that a try in 5~ minutes
20:20:38 <carter> ok
20:20:44 * hackagebot rainbow 0.6.0.4 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.6.0.4 (OmariNorman)
20:20:45 <carter> haskelling for fun or profit?
20:20:50 <hunt> fun
20:21:05 <carter> cool
20:21:06 <hunt> i got board of everything
20:21:08 <hunt> bored
20:21:10 <carter> oh?
20:21:11 <carter> of what?
20:21:27 <hunt> i was doing a lot of c and js
20:21:36 <hunt> and just imperative in general
20:21:44 <hunt> was feeling kind of mundane and grunty
20:21:59 <carter> ah
20:22:12 <carter> joys of industrial employement where everyoe needs a website?
20:22:14 <carter> huh
20:22:16 <carter> C+ JS
20:22:19 <carter> i don't see that combo often
20:22:21 <carter> context/
20:22:21 <hunt> no no still in school
20:22:25 <hunt> separate courses
20:22:30 <hunt> but loads of shit to do for each
20:22:48 <simpson> JS in school? How sadistic.
20:23:01 <hunt> yea but the web man
20:23:09 <simpson> The Web is stupid; throw rocks at it.
20:23:16 <johnw> Node.js is all you ever need
20:23:24 <simpson> Also, The Web still works if you stick to non-JS stuff.
20:23:26 <dmj`> johnw: :)
20:23:42 <hunt> yea but somebody has to do the js stuff
20:23:51 <hunt> otherwise its not spiffy enough
20:24:03 <simpson> IYSS.
20:24:03 <carter> *responsiveeeeeee*
20:24:13 <carter> hunt: fyi dm'd yah a remark
20:24:18 <carter> hunt: focusing on CS ?
20:24:19 <dmj`> wordpress all you need. just use plugin
20:25:09 <carter> someone i know was saying "i'm studying w3schools to make a personal webpage"
20:25:16 <carter> was debating suggesting "just use wordpress"
20:25:28 <hunt> yea focusing cs is the plan
20:25:34 <carter> which areas?
20:25:43 <dmj`> http://www.w3fools.com/
20:25:47 <hunt> idk yet
20:25:56 <hunt> also embarrassing but idk what dm is
20:26:17 <carter> "irc messaged"
20:26:19 <startling> carter: oh man
20:26:22 <carter> look at your other tab
20:27:17 <roboguy__> hunt: I'm studying cs too and I'm not totally sure what I want to focus on either
20:27:41 <hunt> roboguy__ im pretty worried that ill get bored of anything
20:27:46 <roboguy__> compiler design is pretty interesting, but probably not a huge need for compiler developers
20:27:53 <hunt> i hate committing to stuff
20:27:56 <carter> solution: roboguy__  and hunt  should do haskell.org GSOCs :)
20:28:03 <carter> hunt: how about compilers and math?
20:28:05 <roboguy__> carter: I thought about that actually
20:28:07 <johnw> roboguy_: it's bit enough
20:28:08 <johnw> big
20:28:25 <shelf> hmm. any new GSOC ideas up?
20:28:39 <roboguy__> hunt: I can understand that
20:28:42 <carter> shelf: no, tell  us what you get excited by / think is cool
20:28:46 <carter> or care about
20:28:49 <hunt> carter,  compilers and math are cool, idk man i have put way too little thought into it
20:29:00 <carter> solution: you should try stuff out!
20:29:06 <shelf> i don't really have the chops for a haskell GSOC yet, judging by past entrants :>
20:29:08 <carter> trying is the cheapest way of measuring
20:29:09 <roboguy__> when it's GSOC time I might actually have some more time too
20:29:17 <carter> shelf: roboguy__  nah
20:29:24 <carter> just choose a tool you like / think is cool
20:29:31 <carter> read some teeny piece of the code
20:29:38 <carter> and give a "cleanup / simplify" patch
20:29:42 <carter> to get your feet wet
20:29:58 <roboguy__> carter: that's a good idea
20:30:04 <carter> roboguy__: its the only idea
20:30:12 <roboguy__> haha yeah that's true
20:30:14 <shelf> seems to be the way to go.
20:30:28 <carter> doing lots of simple dumb improvements looks impressive to 3rd parties who don't realize how simple and dumb the work was :)
20:30:35 <carter> the trick is choosing topics where you can care about doing that :)
20:30:43 <carter> everything gets boring once you dig deep enough
20:30:45 <carter> its about how much you care
20:30:54 <shelf> and then i can grow up to be steve klabnik~
20:31:05 <carter> ehhh
20:31:09 <carter> he has a ruby tattoo
20:31:14 <shelf> was joke
20:31:15 <carter> seems like a nice guy though
20:31:29 <hunt> lol
20:32:09 <carter> but really, a tattoo, even if its your favorite tool?
20:32:25 <shelf> even a tattoo of your wife can be a risky endeavour
20:32:37 <carter> no comment
20:32:46 <carter> even the tattoo of someones name
20:32:55 <hunt> the only good tattoo is of yourself
20:33:02 <carter> self portrait
20:33:08 <carter> of your pace on your belly button
20:33:11 <carter> face
20:33:17 <carter> hunt: install working?
20:33:27 <hunt> still installing ghc48
20:33:33 <startling> carter: I've considered a small lambda
20:33:43 <carter> hunt: you didn't need that
20:33:44 <hunt> or sorry gcc
20:33:48 <carter> you could just edd the settings file
20:33:49 <carter> :)
20:33:53 <carter> to point to 4.2
20:33:56 <hunt> yea but i feel behind the times
20:33:59 <carter> fair
20:34:02 <carter> 4.2 is OLD
20:34:19 <hunt> its whats in the mac dev tools
20:34:25 <carter> yeah
20:34:26 <hunt> wtf is going on with the mac dev tools
20:34:36 <carter> its all clang / llvm now
20:34:45 <carter> gcc 4.2 was the last gplv2
20:34:50 <carter> all the newer gcc was v3
20:35:33 <hunt> ah
20:37:07 <xpika_> how do i export a Show instance in a haskell module?
20:37:27 <startling> xpika_: instances can't be hidden
20:37:44 <roboguy__> you can't not export it
20:41:04 <Platz> hunt: is brew decent?  dpkg has been one of those things that's worked so well I don't think about it
20:41:27 <hunt> Platz, i dont really have anything to compare it to on mac but yea its done everything i need
20:41:31 <geekosaur> I find homebrew code (base and recipes) downright scary to look at
20:41:35 <hunt> Platz, i spend a lot more time on linux distros
20:42:07 <geekosaur> but then, I don't exactly invite people to look at tcl, *that* can cause permanent scarring even when it's well written
20:42:09 <tautologico> I use brew because it worked better than macports (ugh)
20:42:13 <Platz> hunt: it's encouraging that there aren't any bad stories though
20:42:19 <roboguy__> geekosaur: wait, it's in tcl?
20:42:28 <geekosaur> brew is ruby
20:42:36 <carter> brew is terrible, but its the least terrible option
20:42:44 <geekosaur> it's also some of the hackiest ruby I've ever seen
20:42:54 <geekosaur> macports is (sadly) tcl
20:43:04 <roboguy__> wasn't brew written because fink was worse?
20:43:14 <joelteon> it's becaus everything is bad
20:43:18 <geekosaur> brew likes ot think it's the working alternative to macports
20:43:52 <geekosaur> sadly the only reaosn brew still works is it steals as much code from macports as it can these days, having figured out that not using apple libraries is not a mistake
20:44:07 <johnw> i haven't even thought about macports in forever
20:44:17 <johnw> so brew surely is the working alternative
20:44:26 <geekosaur> yes, everyone hates macports and wishes it would die, apparently
20:44:33 <johnw> yep
20:44:37 <geekosaur> it's worked fine for me for years, it must be utterly horrib;e
20:44:42 <roboguy__> think someone will make a better os x package manager one of these days?
20:44:49 <geekosaur> also if it did go away homebrew would decay into a complete mess
20:45:20 <geekosaur> as for fink, it keeps lapsing into a coma and then waking up again
20:45:24 <tbelaire> What's actually wrong with brew?
20:45:40 <startling> can we all just agree we hate fink?
20:45:47 * hackagebot separated 0.0.8 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.8 (TonyMorris)
20:46:13 <geekosaur> brew works fine as long as (a) you dion't ever install anything else in /usr/local (b) you don't ever install anything anywhere else that a configure script might decide to look
20:47:12 <tbelaire> Ok.
20:47:13 <geekosaur> (c) you never do anything unexpected to your system because most brew recipes don't check the system for consistency and will blow up spectacularly if something isn't exactly the same as it was on the recipe author's systme
20:47:49 <johnw> is this really the place to rant about OS X package managers?
20:48:23 <geekosaur> (well, everything that recipe might look at. you can be lucky a lot and then get the recipe for the program from hell that does something nobody would expect and it explodes messily because you looked at it funny and the moon is full)
20:48:53 <geekosaur> actually I;m ranting more about configure scripts that overstep their bounds
20:49:16 <geekosaur> which is a problem that everyone not running a vanilla linux has to live with...
20:49:56 <dmj`> wasn't there some kind of gsoc project where if given data A = A { thing :: String } and data B = B { thing :: String }, that both "thing" functions could be defined w/o issues, and the usage would infer the type? Not sure how it'd work w/ record wild cards..
20:50:20 <dmj`> I'd like to use that if it exists, I swear I read about it
20:50:22 <geekosaur> dmj', if they're the same type, there's already a ghc extension for it
20:50:56 <dmj`> geekosaur: think they'd be different types in this case
20:50:59 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
20:51:11 <dmj`> hmm maybe not
20:51:39 <geekosaur> the different types version, there are a bunch of different proposals, none of which is clearly superior and none of which has enough backing relative to the others, so we remain stalemated :(
20:51:44 <geekosaur> unless you count the tricks lens does
20:53:57 <dmj`> geekosaur: what trick?
20:54:26 <geekosaur> lens is not so secretly a generics library, so it handles different types
20:55:00 <geekosaur> it may well be the most usable-for-ordinary-folks generics library
20:55:48 * hackagebot prednote 0.18.0.4 - Build and evaluate trees of predicates  http://hackage.haskell.org/package/prednote-0.18.0.4 (OmariNorman)
20:56:04 <roboguy__> is that the makeClassy thing?
20:57:48 <dmj`> geekosaur: even w/ disambiguate fields I still get the multiple definition issue, does this mean I need to define them in separate modules?
20:57:54 <dmj`> http://lpaste.net/7119595732700495872
20:58:48 <dmj`> oh I do, I see
20:58:56 <geekosaur> oh, that kinda surprises me, I thought that worked if they were the same type...
20:59:35 <dmj`> is there a multiple modules lang extension?
21:00:12 <geekosaur> haskell does have some limitations in that area but I thought it handled that case. (in the general case, a field name defines a projection function and that function is not special and therefore can't return multiple types and can't have the same name as another function in the same scope, etc.)
21:00:20 <geekosaur> no, one module per file
21:00:29 <geekosaur> ghc requires that to be able to find modules
21:03:26 <xpika_> @pl (\ f z1 z2 ->  z1 >>= \x -> return (z2  >>= \y -> return (f x y)))
21:03:26 <lambdabot> flip ((.) . (>>=)) . ((return .) .) . flip . (fmap .)
21:06:05 <copumpkin> xpika_: I wouldn't settle for that
21:06:25 <copumpkin> xpika_: but why the extra return?
21:07:31 <copumpkin> xpika_: if you take out the extra return it's just liftM2
21:09:03 <xexonixxexillion> Is it worth reporting GHC panics (i.e the impossible happened) if they came from undecidable instances?
21:10:02 <dolio> Yes.
21:10:08 <dolio> Always report panics.
21:12:16 <xexonixxexillion> Also, I wrote some pretty strange code and when I asked the type of the function I wrote, I got an error about not being able to find an interface file declaration
21:13:03 <xexonixxexillion> is that worth reporting?
21:13:58 <dolio> Not sure.
21:14:03 <dolio> Seems like it.
21:14:10 <xpika_> copumpkin: the extra return makes it type m (m a) which i want instead of m a
21:14:23 <copumpkin> xpika_: why do you want it, though?
21:14:56 <johnw> he's golfing his times-table puzzle
21:15:05 <xexonixxexillion> Messing around with recursion-schemes seems to be more mind bending for the compiler than it is for me...
21:15:21 <xpika_> copumpkin: trying to shorten my list compreheinsion
21:15:35 <copumpkin> ah
21:16:04 <xexonixxexillion> I accidentally wrote prod = ana (\x -> case x of {Nil -> 1; Cons x y -> x * y}) instead of prod = cata (\x -> …)
21:16:56 <xexonixxexillion> and instead of getting a useful error I get "can't find interface file declaration for prod"
21:17:48 <copumpkin> >  [[y*x|y <-[1..10]]|x<-[1..10]]
21:17:49 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20],[3,6,9,12,15,18,21,24,27...
21:18:08 <johnw> I think he had that before
21:18:13 <copumpkin> yeah
21:18:18 <copumpkin> just seeing the desired output
21:18:53 <xpika_> @pl (\ g h g2 h2  -> g z1 (\x -> h ( g2 z2  (\y -> h2 (f x y)) ))
21:18:53 <lambdabot> (line 1, column 62):
21:18:53 <lambdabot> unexpected end of input
21:18:53 <lambdabot> expecting variable, "(", operator or ")"
21:19:58 <xpika_> @pl (\f z1 z2 -> (\ g h g2 h2  -> g z1 (\x -> h ( g2 z2  (\y -> h2 (f x y)) )) ) (>>=) return (>>=) return)
21:19:59 <lambdabot> flip flip return . (flip .) . flip flip (>>=) . (flip .) . flip flip return . (flip .) . flip flip (>>=) . (flip .) . flip ((.) . flip . (((.) . (.) . (.)) .) . flip id) . (flip ((.) . (.) . (.)) .) . flip (flip . (((.) . (.)) .) . flip id) . flip ((.) . (.))
21:21:04 <xpika_> not sure if its any more readable
21:21:06 <copumpkin> > (<$>) =<< flip ((<$>) . (*)) $ [1..10]
21:21:07 <copumpkin> :P
21:21:07 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20],[3,6,9,12,15,18,21,24,27...
21:21:27 <johnw> copumpkin++
21:21:56 <xpika_> copumpkin: now why couldn't pl tell me that
21:22:12 <carter> hunt: got it working?
21:27:56 <ion> > (<$>) =<< flip ((<$>) (<$>) (*)) $ [1..10]
21:27:57 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20],[3,6,9,12,15,18,21,24,27...
22:01:58 <maybefbi> should i use newtype/type if i want performance?
22:02:28 <Hafydd> As opposed to what?
22:03:05 <startling> maybefbi, newtype is erased at runtime
22:03:35 <maybefbi> ah ok so newtype Flow = Flow { unFlow :: V.Vector Int8 } deriving (Eq, Show)
22:03:47 <maybefbi> is same as type Flow = V.Vector Int8
22:03:52 <maybefbi> at runtime
22:04:08 <startling> maybefbi: ish. instances are done a little differently iirc
22:04:16 <startling> but it shouldn't be a big thing.
22:04:36 <maybefbi> i really badly need every bit of performance i can get
22:04:57 <maybefbi> dont care much about Eq, and Show
22:05:02 <enthropy> which Vector do you use?
22:05:06 <maybefbi> Unboxed
22:05:18 <maybefbi> non-mutable
22:05:41 <startling> maybefbi: I don't think it will affect you. you can benchmark if you want to be sure
22:05:56 * hackagebot lio 0.11.4.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.11.4.0 (DeianStefan)
22:05:58 * hackagebot lio-fs 0.0.0.1 - Labeled File System interface for LIO  http://hackage.haskell.org/package/lio-fs-0.0.0.1 (DeianStefan)
22:06:02 <maybefbi> ok thanks
22:07:18 <enthropy> so haddock drops {-# NOLINE pragmas #-} in > blocks
22:07:45 <enthropy> must be some kind of conspiracy against global variables
22:09:56 <maybefbi> the globalists
22:10:06 <maybefbi> they are evil man
22:12:26 <kusut> worse than nihilists? http://www.youtube.com/watch?v=b_29yvYpf4w
22:12:34 <kusut> at least it's an ethos
22:15:22 <reactormonk> How do I lift e -> (e -> t) to ((e -> t) -> t) -> (e -> t) where e is something and t is bool?
22:15:46 <Aetherspawn> uh newtype is important
22:15:58 <Aetherspawn> @ maybefbi sometimes if you don't use newtype you don't get stream fusion
22:16:03 <Aetherspawn> and little quirks like that
22:16:20 <Platz> rI cabal installed 'split' and in ghci I get could not find Data.List.Split and it says something about "dyn" libraries for split"
22:16:59 <Platz> why can't I import Data.List.Split?
22:17:42 <Aetherspawn> dyn libraries sounds like a ght 7.8 qurik
22:17:42 <maybefbi> Aetherspawn, hmm ok. I hope Data.Unboxed.Vector doesn't using stream fusion
22:17:52 <Aetherspawn> all vectors need stream fusion
22:17:54 <Aetherspawn> or they can be slow
22:18:02 <startling> Aetherspawn: that's a good point
22:18:12 <Aetherspawn> operations on vectors using stream fusion are usually as fast as C
22:18:13 <maybefbi> Aetherspawn, they use stream fusion without our permission?
22:18:20 <startling> haha
22:18:22 <Aetherspawn> lol
22:18:24 <Aetherspawn> seriously
22:18:58 <startling> do most vectors ask permission first?
22:19:38 <Aetherspawn> is it possible to @quote that
22:19:39 <Aetherspawn> :P
22:19:42 <maybefbi> ok im using newtype
22:21:06 <Platz> ahh I needed --enable-shared
22:32:35 <zcd> does anyone have experience installing haskell collection on freebsd?
22:32:46 <zcd> i'm getting a requirement for opengl c library but i can't seem to find what it wants
22:34:22 <ivanm> zcd: if all else fails, you can look at the haskell opengl libraries .cabal files and see what the library they link to is called
22:34:35 <ivanm> but you probably want the header files for gl, glut, dri, etc.
22:34:54 <ivanm> note also it's the haskell platform, not haskell collection (unless someone's created a new bundling I haven't heard of...)
22:39:03 <zcd> ivanm: yes i mean platform :)
22:39:14 * startling collects haskell implementations
22:40:55 <ivanm> startling: which ones have you got so far?
22:41:09 <no-n> is GHC written in C?
22:41:48 <ivanm> nope
22:41:53 <ivanm> the RTS is written in C
22:42:00 <ivanm> part of the mangler at least used to be written in perl
22:42:07 <ivanm> but GHC itself is written in Haskell
22:42:10 <startling> ivanm: ghc
22:42:21 <no-n> RTS?
22:42:39 <ivanm> run time system
22:42:48 <no-n> ahh
22:42:49 <ivanm> startling: so not even hugs? what kind of collector are you? :o
22:43:13 <shachaf> The mangler is gone.
22:43:14 <startling> haha
22:43:56 <ivanm> shachaf: even on architectures were there isn't any native support?
22:44:01 <ivanm> is it just native and llvm now?
22:44:26 <shachaf> Wasn't the mangler specifically for the evil registerized variant?
22:45:00 <ivanm> not sure
22:45:01 <annulus> zcd, if you're using the nvidia driver you may be missing some symlinks or something
22:53:40 <zcd> i don't think it's an nvidia driver
22:53:40 <NemesisD> for library/utility code on lists, is non-strict foldl considered harmful
22:53:44 <zcd> being run from virtualbox
22:55:02 <ivanm> NemesisD: seeing as how IIRC GHC with the -O flag (enabled by default by cabal-install) turns foldl into foldl' ... I don't think it makes a difference unless you're using ghci :p
22:55:06 <Aetherspawn> heh
22:55:17 <Aetherspawn> theres an ((->) r) instance for MonadReader
22:55:25 <Aetherspawn> so you can run a reader over a partially applied function
23:09:38 <chowmeined__> so, the haskell platform and leksah dont get along?
23:11:04 * hackagebot unix-memory 0.1.0 - Unix memory syscalls  http://hackage.haskell.org/package/unix-memory-0.1.0 (VincentHanquez)
23:24:40 <chowmeined__> okay so, leksah doesnt work with the latest haskell platform, compiling it is a huge undertaking, all i want is to starting learning haskell, whats the deal here?
23:28:14 <startling> chowmeined: leksah is weird and old and you probably shouldn't use it
23:28:31 <chowmeined> startling, what should I use?
23:28:43 <hamid> chowmeined, you don't need an IDE.
23:28:54 <chowmeined> uhuh
23:29:04 <startling> chowmeined: what do you usually use?
23:29:07 <chowmeined> these are not the droids you're looking for
23:29:38 <chowmeined> IntelliJ or Visual Studio
23:29:59 <startling> chowmeined, lots of people here use emacs and vim. It may or may not be worth learning one of those.
23:30:04 <chowmeined> i know vim
23:30:04 <startling> I think there's an intellij thing
23:30:13 <chowmeined> the intellij thing looked broken and dead
23:30:51 <chowmeined> perhaps im spoiled, but i like the package navigation and refactoring tools
23:30:55 <startling> dang. sorry !
23:32:04 <Platz> theres that eclipseFP thing but I haven't used it
23:33:07 <chowmeined> okay ill give eclipseFP a shot
23:35:48 <randomclown> man, multiwayif is one of the greatest things ever invented
23:38:36 <chowmeined> maybe leksah shouldnt be the first result in google for "haskell ide" or "ghc ide"
23:39:33 <startling> heh
23:39:41 <startling> alas, we don't have much control over that.
23:42:10 <chowmeined> lol, the EclipseFP jar has a java exploit in it
23:46:57 <startling> chowmeined: both leksah and ideah seem to have more active development on github
23:47:23 <chowmeined> i give up, how dare i try to use haskell on windows
23:47:28 <chowmeined> back to my linux VM
23:47:45 <chowmeined> :)
23:47:53 <startling> yeah, it's definitely a less painful experience on a unix.
23:48:31 <syllogismos> i hate reader monad.
23:48:39 <simpson> What's up?
23:48:44 <syllogismos> hate is a strong word.. but i really really really dont like it.. :p
23:49:01 <_violet_> what's reader monad?
23:49:13 <syllogismos> (->) r
23:51:52 <apples> what do you dislike about it?
23:53:57 <mm_freak_> > let (<+>) = liftA2 (+) in (sin <+> cos) 3
23:53:58 <lambdabot>  -0.8488724885405782
23:54:35 <adelbertc> :t (<+>)
23:54:36 <lambdabot>     Ambiguous occurrence `<+>'
23:54:36 <lambdabot>     It could refer to either `Control.Arrow.<+>',
23:54:36 <lambdabot>                              imported from `Control.Arrow' at /home/lambda/.lambdabot/State/L.hs:35:1-20
23:54:47 <mm_freak_> (now wait for people to point out that you can write a Num instance for functions)
23:54:49 <adelbertc> :t Control.Arrow.(<+>)
23:54:49 <lambdabot> Couldn't find qualified module.
23:54:54 <adelbertc> :t Control.Arrow.<+>
23:54:55 <lambdabot> parse error on input `Control.Arrow.<+>'
23:55:06 <adelbertc> (╯°□°）╯︵ ┻━┻
23:55:10 <mm_freak_> :t (Control.Arrow.<+>)
23:55:11 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
23:55:20 <adelbertc> oh.
23:55:22 <adelbertc> mm_freak_ - cheers
23:55:40 <mm_freak_> note that ArrowPlus + ArrowZero ≈ Alternative
23:56:43 <adelbertc> if i have an IntMap and i have newtype Foo = Foo Int, is there a way around wrapping and unwrapping all the time?
23:57:20 <adelbertc> (the users of hte library should only ever get a Foo from the library, but under the covers itll be "unwrapped" (from the Foo ctor) to put in the IntMap
23:57:58 <Cale> adelbertc: nope, the point of a newtype is that you syntactically must use the constructor/pattern matching to go back and forth between it and the original type
23:58:10 <adelbertc> Cale - fair enough, cheers
23:58:29 <Cale> It is a little unfortunate that you can't use type synonyms as module-level newtypes
23:58:45 <Cale> i.e. do something to not export the type equality between the synonym and the original type
23:59:22 <Cale> That would solve your problem, I would bet, but it would also make type synonyms a lot less trivial.
23:59:36 <xintron> My computer is running another linux dist than the server I want to compile for (different glibc). Can I statically link glibc or is that a bad idea?
23:59:46 <adelbertc> :t sequence
23:59:47 <lambdabot> Monad m => [m a] -> m [a]
23:59:52 <syllogismos> apples it confuses me..
