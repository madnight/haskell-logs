00:00:34 <Twey> L8D: The latter is generally considered to be a better idea, and also simplifies your WordDict type (because there's no longer a need to pass in the dictionary: you have it from the closure when you defined the function in the first place)
00:01:18 <L8D> Twey: should we do this over pm?
00:01:35 <Twey> So you WordDict just becomes newtype WordDict = WordDict [(String, [Int] → IO [Int])]
00:01:44 <L8D> Twey: now I see
00:01:45 <shachaf> There is #haskell-overflow for long conversations that start to drown out #haskell conversation.
00:02:01 <L8D> Twey: should we go to haskell-overflow?
00:02:06 <Twey> L8D: It's a pretty on-topic discussion
00:02:09 <L8D> okay
00:02:28 <shachaf> #haskell-overflow is an on-topic discussion channel.
00:02:53 <bitemyapp> jfeltz: Euler problems are about math, not programming
00:03:02 <bitemyapp> jfeltz: I don't think they're a good way to learn a language at all but some people like them
00:03:10 <bitemyapp> I don't think they teach much Haskell
00:03:10 <Twey> your**
00:11:54 <L8D> I know it's incredibly unsafe, but is there any way for a ByteString -> Int and vice versa with pointers?
00:12:11 <shachaf> Which does what?
00:12:19 <L8D> Gets a pointer to a string
00:13:04 <shachaf> Int isn't a very good type for a pointer.
00:13:15 <shachaf> Better to use e.g. Ptr.
00:13:23 <L8D> Isn't it usually larger than Ptr though?
00:13:29 <shachaf> Or, for that matter, ForeignPtr. Which is how a ByteString is implemented.
00:13:31 <shachaf> ?
00:13:47 <L8D> I want to do arithmetic and such on it
00:14:03 <L8D> I want a pointer which is completely usable as an Int
00:14:08 <pharaun> why
00:14:11 <shachaf> You want a signed type?
00:14:30 <Ralith> L8D: what are you trying to accomplish
00:14:33 <L8D> pharaun: It's what the spec says
00:14:36 <L8D> Ralith: an interpreter
00:14:37 <enthropy> @hoogle plusPtr
00:14:37 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
00:14:42 <shachaf> Not e.g. CUIntPtr, corresponding to the C type uintptr_t?
00:15:01 <Ralith> L8D: that's good, then, because an interpreter does not need such functionality.
00:15:46 <L8D> Ralith: the spec says to store strings as some kind of pointers
00:16:03 <L8D> So that the user can do byte-offsets by simple incrementing the number
00:16:26 <shachaf> Haskell has plenty of things for working with pointers. You don't have to subvert the system for it.
00:16:35 <verement> what spec is that?
00:16:39 <shachaf> Are you prepared to deal with the ByteString being GCed or something?
00:16:51 <L8D> Well, I need some kind of pointer that can be stored in an Int
00:17:00 <Ralith> no, you don't
00:17:08 <jrmithdobbs> Int isn't what you think it is
00:17:09 <L8D> Ralith: why?
00:17:35 <L8D> jrmithdobbs: not a CInt
00:18:17 <jrmithdobbs> why would you ever convert a pointer to a known-smaller signed type?
00:18:27 <jrmithdobbs> (or at least, allowed smaller)
00:18:40 <frx> even CInt would be inappropriate. there are no guarantees that int in C can hold a pointer value
00:18:49 <dmwit> You can already do pointer arithmetic with Ptr.
00:19:15 <L8D> dmwit: yes, but then I'd have to do a ton of verbose union product typing stuff
00:19:18 <dmwit> What does the objection "Isn't it usually larger than Ptr though?" mean?
00:19:21 <L8D> to keep the compatibility with Int
00:19:33 <dmwit> L8D: Why do you need compatibility with Int?
00:19:44 <dmwit> Int doesn't even guarantee enough bits!
00:19:50 <jrmithdobbs> ^
00:19:55 <pharaun> this ^
00:20:02 <L8D> dmwit: Haskell 'Int' is larger than 'CInt' which is usually the comp's word size, which is usually the same or larger than the size used for pointers
00:20:06 <dmwit> no
00:20:16 <dmwit> Haskell Int is 29 bits guaranteed, implementation-dependent actual size
00:20:22 <L8D> wat
00:20:30 <L8D> why?
00:20:35 <dmwit> irrelevant
00:20:35 <jrmithdobbs> encoding
00:20:59 <verement> 30 bits
00:21:02 <verement> signed
00:21:10 <L8D> why 29? why not 30 or thiry-fucking-two
00:21:13 <dmwit> Oh, yes, it's probably 30 bits.
00:21:22 <L8D> why not 32?
00:21:25 <L8D> gawd
00:21:27 <verement> [-2^29 .. 2^29 - 1]
00:21:30 <L8D> everything has been foiled now.
00:21:30 <dmwit> To give implementations some wiggle room. =)
00:21:52 <L8D> all my hopes and dreams...
00:21:56 <L8D> down the drain
00:22:01 <pharaun> wat
00:22:06 <verement> your hopes and dreams were ill-founded
00:22:08 <jrmithdobbs> no your idea was wrong anyways
00:22:15 <enthropy> too bad haskell doesn't come with Integer
00:22:27 <jrmithdobbs> don't use that for storing pointers either damn it
00:22:29 <L8D> I guess I'll just not support strings in my implementation
00:22:34 <dmwit> I am honestly beyond confused about what it is L8D *actually* needs.
00:22:39 <verement> implementation of what?
00:22:41 <L8D> RL
00:22:52 <L8D> It's this stupid stack-based language
00:22:57 <L8D> think FORTH
00:23:12 <verement> why do you need actual pointers and not, say indices into an array?
00:23:45 <L8D> verement: indices into an array is okay, but I don't want to have to keep passing around an array of memory
00:23:45 <dmwit> But even if you need actual pointers, WE HAVE ACTUAL POINTERS.
00:23:56 * hackagebot markdown-pap 0.0.1.3 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.3 (YoshikuniJujo)
00:24:57 <L8D> Is there some form a reads that will read hex, octal, binary and decimal?
00:25:00 <verement> you will end up very likely passing a pointer around anyway, without even worrying about it
00:25:38 <enthropy> look at the Numeric module in base
00:25:42 <dmwit> reads will do hex, octal, and decimal, but not binary
00:25:47 <dmwit> unfortunately
00:25:54 <L8D> dmwit: that's fine. thanks
00:26:02 <dmwit> But you could readP to do all four without too much trouble, I would guess.
00:26:39 <enthropy> oh there's no readIntAtBase
00:26:52 <dmwit> I lost a word in that sentence somehow. That should say "could hack readP to do all four".
00:27:08 <dmwit> enthropy: There's readInt...
00:27:10 <L8D> I want to read in numbers like: 1, 0b1, 0x1, and 01
00:27:10 <dmwit> :t readInt
00:27:11 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
00:28:24 <L8D> well, all I really need is just hex and decimal
00:28:26 <L8D> for the spec
00:28:38 <L8D> so...1 and 0x1
00:29:16 <pharaun> whats the spec anyway?
00:29:28 <verement> > readDec "10"
00:29:29 <lambdabot>  [(10,"")]
00:29:39 <verement> > readHex "10"
00:29:40 <lambdabot>  [(16,"")]
00:30:00 <L8D> pharaun: a book
00:30:02 <dmwit> > map (reads :: ReadS Int) ["1", "0x1"]
00:30:04 <lambdabot>  [[(1,"")],[(1,"")]]
00:30:06 <L8D> well, it's in a book
00:30:30 <L8D> from like 10 years agi
00:30:32 <L8D> ago*
00:31:56 <L8D> it provides some sample code for writing an interpreter in C, but part of the point of it is for you to write your own interpreter to then practice all the problems in the rest of the book
00:31:59 <amalloy> i'm a bit confused about how to write a recursive function inside a do block. specifically, i'm in State and i have a function f. i want to call f with some args, and then possibly change the state based on f's return value, and then possibly keep going, with new args for f based on the new state. i'm sure this is possible but i can't quite fit it in my head
00:32:39 <L8D> amalloy: by state, do you mean the data you keep passing through recursively?
00:33:21 <dmwit> f = do { val <- f some args; put (munge val); f new args } -- ?
00:33:31 <amalloy> L8D: well, both. i need to pass different data through recursively, but those are derived from changes to the state held in the State monad
00:33:49 <L8D> amalloy: oh, I misread and didn't realize you were using State
00:34:11 <dmwit> Well. My proposal is clearly wrong. But it's intended to be just right enough to spark objections that will help clarify your question.
00:34:18 <amalloy> haha
00:34:28 <amalloy> well, are all those `f`s there the same f?
00:34:32 <dmwit> yes
00:35:25 <amalloy> the first one seems to take different arguments from the other two
00:35:34 <c_wraith> well, he did say it's clearly wrong. :)
00:35:45 <dmwit> Okay. f a b = do { ... }
00:36:07 <dmwit> Next objection, please!
00:36:33 <zRecursive> @undo do { val <- f some args; put (munge val); f new args }
00:36:33 <lambdabot> f some args >>= \ val -> put (munge val) >> f new args
00:38:03 <amalloy> okay, so i think that makes sense. and when i recursively call f (in the last clause), the changes applied by `put` will have taken effect, because we're binding
00:38:16 <dmwit> yup
00:38:31 <amalloy> i think the second f in your example wants to be g (the other function i'm calling), but that's fine
00:38:50 <dmwit> I suspect the first f also wants to be g for some suitable g.
00:39:05 <dmwit> Though perhaps you have something sneaky up your sleeve involving laziness.
00:40:04 <zRecursive> How many ways are there to make 'lazy' be 'strict' in haskell ?
00:40:43 <dmwit> http://stackoverflow.com/q/15627849/791604
00:42:12 <amalloy> so i think i want something like: f a b = do {val <- get; let result = g something val; put (munge result); if (keepGoing result) f newA newB else return ()}. does this sound crazy?
00:43:17 <dmwit> You might like iterateM from the monad-loops package.
00:43:21 <dmwit> Or one of the other loops in there.
00:45:55 <L8D> Twey: guess
00:45:56 <L8D> what
00:46:57 <L8D> nvm
00:48:06 <Twey> L8D: I'm confused
00:49:18 <L8D> Twey: I can implement word definitions in a different manner
00:49:41 <L8D> I wouldn't need to setup a wordDict type or anything
00:50:00 <zRecursive> :t ($!)
00:50:01 <lambdabot> (a -> b) -> a -> b
00:50:11 <zRecursive> :t ($)
00:50:12 <lambdabot> (a -> b) -> a -> b
00:50:20 <Twey> Oh, yeah, there are plenty of ways
00:50:30 <zRecursive> No differenc ?
00:50:30 <jle`> @src ($!)
00:50:31 <lambdabot> f $! x = x `seq` f x
00:50:55 <jle`> > const 1 $ undefined
00:50:56 <lambdabot>  1
00:50:58 <dmwit> zRecursive: The types are the same. The behaviors are not.
00:51:00 <zRecursive> ($!) uses `seq`, thx
00:51:01 <jle`> > const $! undefined
00:51:03 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:51:03 <lambdabot>    arising from a use of `M18166320024150808776283.show_M18166320024150808776...
00:51:03 <lambdabot>  The type variable `a0' is ambiguous
00:51:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:51:03 <lambdabot>  Note: there are several potential instances:
00:51:05 <jle`> er
00:51:07 <Twey> The dictionary just seemed the most straightforward for you :þ
00:51:12 <jle`> > const 1 $! undefined
00:51:13 <lambdabot>  *Exception: Prelude.undefined
00:51:14 <L8D> @src seq
00:51:14 <lambdabot> Source not found. Maybe you made a typo?
00:51:20 <jle`> seq is magic
00:52:47 <jle`> sometimes i feel like i just want to give up on frp but i always end up motivating myself to keep on going
00:52:50 <jle`> somehow
00:53:10 <jle`> in the hopes that i will one day change the world
00:53:27 <jle`> i've never felt this way in any other language
00:54:41 <L8D> jle`: me too
00:54:52 <L8D> besides the change the world part
00:55:02 <jle`> everywhere i look i find unsatisfactory answers to a problem that i know should have an answer
00:55:14 <zRecursive> jle`: Would you mind exposing the magic of `seq` ?
00:55:14 <jle`> and i feel like once i figure it out then i will make an impact on the world for the better
00:55:31 <jle`> sometimes i find out that it has been done but i didn't find it before :|
00:55:48 <jle`> also sometimes i wonder if this is all worth it, if my actions are of any consequence outside of this haskell bubble
00:56:01 <jle`> and maybe this haskell bubble will always be an obscure bubble and i am wasting my time on earth
00:56:15 <jle`> but i always find the resolve to continue somehow in the hopes that my actions will one day make a difference
00:56:22 <L8D> jle`: Haskell can look very good on a resumé, depending on who your employer is.
00:56:29 <jle`> in hopes, or perhaps in faith
00:56:47 <jle`> L8D: not being good at haskell; i mean...solving problems that i feel are unsolved
00:56:52 <zRecursive> :t seq
00:56:53 <jle`> or am not satisfied with present solutions or solutions i can find
00:56:53 <lambdabot> a -> b -> b
00:56:53 <Twey> zRecursive: When you evaluate ‘seq x y’ you evaluate both x and y (one step) at once
00:57:21 <jle`> zRecursive: x `seq` y says that when you evaluate y, evaluate x.
00:57:24 <Twey> zRecursive: So you evaluate y normally, but it attaches a ‘hook’ to y that causes x to also be evaluated
00:57:58 <jle`> > let x = undefined; y = 1 in snd (x,y)
00:58:00 <lambdabot>  1
00:58:19 <jle`> > let x = undefined; y = 1 in (x `seq` (snd (x,y))
00:58:21 <lambdabot>  <hint>:1:49:
00:58:21 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:58:24 <jle`> > let x = undefined; y = 1 in (x `seq` (snd (x,y)))
00:58:25 <lambdabot>  *Exception: Prelude.undefined
00:58:35 <jle`> so normally evaluating snd (undefined,y) doesn't result in an error
00:58:41 <jle`> because you don't need to evaluate the first field
00:59:00 * hackagebot markdown2svg 0.0.1.9 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.9 (YoshikuniJujo)
00:59:11 <jle`> but if you seq it, it says that when you try to evaluate snd (x,y), also evaluate/force the evaluation of the other thing
00:59:24 <jle`> in this case, giving an error
01:00:03 <zRecursive> How about not evaluating "snd (x,y)" now ?
01:00:15 <jle`> hm?
01:00:33 <jle`> well you don't have to evaluate snd (x,y) if you do'nt want to
01:00:35 <jle`> but
01:00:45 <jle`> here we are printing it out
01:00:54 <jle`> so we need to evaluate it before we print it
01:01:07 <jle`> but if we never use y in seq x y....we won't evaluate x either
01:01:26 <jle`> > let x = undefined; y = 1 in snd (x `seq` y, y)
01:01:27 <lambdabot>  1
01:01:27 <zRecursive> i see if in ghci, but if we dnot print it ?
01:01:55 <jle`> in that case we do x `seq` y...so it'll evaluate x when we ask for the first field.  but we never ask for it so we never evaluate the first field, so we never evaluate x
01:02:18 <jle`> zRecursive: you can bind it to a variable/name it...and it'll be of no consequence until you one day try to evaluate it
01:02:21 <zRecursive> i see now. thx
01:02:58 <jle`> in Haskell nothing is evaluated until it is required or explicitly requested
01:03:16 <jle`> http://blog.ezyang.com/2011/04/the-haskell-heap/
01:03:23 <zRecursive> sure
01:04:20 <jle`> like Twey said, it's more of a hook
01:04:26 <jle`> than a do this immediately
01:04:28 <dmwit> zRecursive: When I say, "seq is magic", I mean, "seq can't be implemented by the user, it must be provided by the compiler". This is different from most other things in the Prelude; Bool, True, False, even (:) and [] could be done by user code.
01:04:32 <dmwit> But not seq.
01:05:50 <zRecursive> i am curious what the compiler do in "let x = undefined; y = 1 in snd (x `seq` y, y)" ?
01:06:27 <jle`> zRecursive: ed yang's article might help you
01:06:28 <dmwit> There are two answers: 1) try it 2) understand the promise of seq. Which do you prefer?
01:06:56 <zRecursive> 2)
01:06:59 <dmwit> ok
01:07:11 <zRecursive> > let x = undefined; y = 1 in snd (x `seq` y, y)
01:07:13 <lambdabot>  1
01:07:22 <jle`> you can
01:07:27 <jle`> evaluate it yourself
01:07:29 <jle`> by hand
01:07:33 <jle`> using substitution
01:07:34 <dmwit> The promise of seq: when "foo `seq` bar" is in WHNF, we have definitely already put "foo" in WHNF.
01:07:35 <jle`> @src snd
01:07:36 <lambdabot> snd (_,y) =  y
01:08:04 <dmwit> The promise of seq, part two: the value of "foo `seq` bar", if it has any, is the same as the value of "bar".
01:08:34 <dmwit> So now we must ask about "snd (x `seq` y, y)": is "x `seq` y" ever put in WHNF?
01:08:37 <zRecursive> yeah
01:09:00 <zRecursive> not yet
01:09:04 <dmwit> right
01:11:35 <jle`> L8D: were you talking about FRP?  are you trying to figure it out too?
01:11:51 <zRecursive> thanks for all your help !  Haskell is really a neat language
01:12:34 <jle`> i think...compared to other ways of forcing evaluation...seq is considered the most dangerous way
01:12:41 <jle`> or anti-semantic
01:13:20 <Twey> Erm
01:13:47 <jle`> :|
01:13:47 <Twey> I don't think that's the case
01:14:01 <jle`> am i about to be educated
01:14:06 <Twey> It introduces the ‘side-effect’ of evaluation, but that's already not one we control in Haskell
01:14:25 <jle`> well
01:14:26 <Twey> The standard doesn't even define an evaluation order
01:14:41 <jle`> it does allow code to break some laws, right?
01:15:04 <jle`> and endangers equational reasoning
01:15:17 <Twey> Only due to non-termination
01:16:03 <Twey> As far as I can see, you don't lose any guarantees from seq that you haven't already lost by using a non-terminating lazy language
01:16:44 <Twey> Some laws only hold modulo bottom depending on their inputs, but that's something we've just come to expect from Haskell :þ
01:17:36 <Twey> And you can never break a law by passing in a seq that wouldn't be broken by passing in an undefined, or a let x = x in x
01:19:03 * hackagebot pipes-cereal-plus 0.2.1 - A streaming serialization library on top of "pipes" and "cereal-plus"  http://hackage.haskell.org/package/pipes-cereal-plus-0.2.1 (NikitaVolkov)
01:51:00 <ski> Twey : monad laws for `IO' ?
01:51:46 <Twey> ski: How so?
01:52:47 <ski> dmwit : hm, i thought it was more like, with `seq foo bar', `foo' will be evaluated eventually, if `bar' is evaluated ?
01:52:51 <ski> > (undefined :: IO ()) `seq` ()
01:52:52 <ski> > ((undefined :: IO ()) >>= return) `seq` ()
01:52:52 <lambdabot>  *Exception: Prelude.undefined
01:52:53 <lambdabot>  ()
01:52:56 <ski> Twey ^
01:52:59 <Twey> How do I load a file into GHCi that uses CPP?  I'd like to inspect the file Text/Pandoc/Writers/HTML.hs from Pandoc, but it has a CPP condition in it, and GHCi just says phase `C pre-processor' failed (exitcode = 1)
01:54:03 <Feuerbach> Twey: can you lpaste the whole session?
01:54:41 <Twey> Feuerbach: http://lpaste.net/405108131471818752
01:54:48 <ski> (also, iirc, in the absence of `seq', eta holds)
01:55:29 <ski> > (undefined :: Bool -> Bool) `seq` ()
01:55:30 <lambdabot>  *Exception: Prelude.undefined
01:55:39 <ski> > (\b -> (undefined :: Bool -> Bool) b) `seq` ()
01:55:41 <lambdabot>  ()
01:56:02 <Feuerbach> Twey: you have to include cabal macros
01:56:10 <Feuerbach> the simples way is to use cabal repl
01:56:31 <Twey> Aha
01:58:04 <Twey> ski: That's not because of seq per se, though: it's just that seq happens to be the only thing you can call that will inspect an IO
01:58:20 <dxtr> So I'm trying to compile git-annex under openbsd and I keep getting this error: http://lpaste.net/99630
01:58:25 <dxtr> And I can't understand what it is
01:58:46 <dxtr> At first I thought that libidn is messing with me, so I compiled it without the c_isascii symbols but it just kept complaining about more symbols
01:59:20 <Twey> Feuerbach: Ah, that works — thanks!
01:59:31 <Feuerbach> yw
01:59:38 <ski> Twey : what's the difference ?
02:00:21 <ski> the effect is that eta, and right-unit for `IO', is broken where before they couldn't be observed to be broken
02:01:21 <Twey> ski: You could hypothetically have a function on IO that inspected IO values
02:01:48 <Twey> Hm
02:01:55 <Twey> I see your point
02:02:36 <Twey> But they're already broken on monads whose values can be inspected, so it doesn't seem like that big a deal :þ
02:03:45 <fread2282> has there been any recent Numeric Prelude work?
02:04:28 <Twey> fread2282: Hackage says: not since August
02:05:43 <fread2282> Twey: not just Numeric Prelude, any of the other Numeric Hierarchies?
02:16:49 <Twey> fread2282: numeric-prelude is a specific package.  There are some other packages and modules with ‘numeric’ in their name, but they're not necessarily related.
02:17:39 <fread2282> Twey: yeah, I was meaning to ask about Numeric hierarchy packags in general
02:18:56 <Twey> fread2282: So your question is, have any packages that have modules that are called something like ‘Numeric’ been updated recently?
02:19:19 <fread2282> Twey: no, packages that define an altenative to Num
02:19:27 <Twey> Aha
02:20:39 <skypers> hello
02:22:18 <Twey> fread2282: Hm, I only know of NumericPrelude
03:04:14 * hackagebot cairo 0.12.5.1 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.5.1 (HamishMackenzie)
03:04:16 * hackagebot gtk3 0.12.5.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.1 (HamishMackenzie)
03:09:15 * hackagebot gtk 0.12.5.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.1 (HamishMackenzie)
03:25:35 <xintron> So, is it possible to use the same "namespace" (is this the correct term) when importing qualified as long as the exports doesn't clash?
03:25:47 <pyr> hello happy haskellers
03:26:12 <pyr> I wonder if there's a standard way for emacs to start the underlying interpreter using a cabal sandbox
03:26:54 <pyr> my only gripe with sandboxes right now is that it breaks in-editor tests
03:28:46 <pyr> hmm, ok, seems my google-fu finally paid off, setting haskell-program-name should do the trick
03:30:52 <pyr> it works ! for the record (setq haskell-program-name "cabal repl ") seems to be sufficient
03:37:25 <lpsmith> Hmm, it _really_ isn't a good idea to call Data.Attoparsec.ByteString.take on a very large integer
03:37:27 <f-a> I just installed a new debian system + cabal. The first thing I did was to edit config and set profiling to True. Now I can't cabal install nothing because it complains that I haven't installed profiling libraries for package base.
03:37:46 <f-a> I am unsure what to do: cabal install --reinstall base? apt-get something?
03:37:52 <lpsmith> It's quadratic, though with a very low constant factor (assuming of course that the strings you feed attoparsec are of reasonable size)
03:38:19 <startling> f-a, there might be a separate package. base comes with ghc.
03:38:32 <merijn> Yay, linux packaging!
03:38:35 <lpsmith> Still, it will be quadratic in the number of chunks it needs.
03:39:08 <merijn> lpsmith: How about using cereal/binary for something like that?
03:39:12 <startling> merijn: yay indeed.
03:39:15 <klrr_> (>>=) what that called verbally now again?
03:39:19 <merijn> klrr_: bind
03:39:22 <klrr_> ok thanks
03:39:44 <merijn> Or deformed fish :p
03:39:51 <merijn> (fish operator being >=>)
03:40:06 <lpsmith> merijn, I've decided that neither cereal nor binary are really all that suitable for my needs
03:40:25 <lpsmith> (that being a log-following processor)
03:40:25 <merijn> lpsmith: Out of curiosity, what are you doing that has such large numbers?
03:41:12 <merijn> lpsmith: oh? I'm having quite some success using pipes+cereal for streaming parsing from the network :)
03:41:15 <f-a> startling: thanks I will search for it
03:41:22 <lpsmith> well,  I have a raw response log;  each entry is a small bit of metadata followed by a length-prefixed response of ~150-200 kilobytes
03:41:41 <lpsmith> merijn, interesting
03:41:48 <merijn> lpsmith: I actually switched to cereal because fixed length parsing was a bitch in attoparsec
03:41:52 <klrr_> merijn: hahah
03:42:24 <klrr_> we need an operator like this (><>) and call it fish :3
03:42:34 <merijn> klrr_: I think lens has that
03:42:40 <merijn> klrr_: Or at least lens has <>~
03:42:52 <klrr_> looks kinda like a fish :d
03:43:07 <merijn> klrr_: I dubbed it the sperm operator :p
03:43:34 <lpsmith> merijn, well, actually I'd like to run a parser on the response,  streaming from a file on disk.
03:43:49 <lpsmith> specifically, an attoparsec parser
03:44:00 <merijn> lpsmith: I pasted a simple approach to how I did this yesterday
03:44:04 <merijn> lemme see if I can find the lpaste
03:45:16 <klrr_> haha
03:45:19 <merijn> lpsmith: I use something like this: http://lpaste.net/99575
03:46:10 <merijn> lpsmith: That does blocking reads from a Handle, passes the ByteString on, then I have a Pipe that receives bytestrings and incrementally parses an 'a' and then outputs the 'a'
03:47:18 <lpsmith> merijn, that looks like you are using attoparsec for the parsing,  not cereal
03:47:32 <merijn> I use 'Get a', because that allows me to just pass a do-block in the Get monad as input, rather than being stuck with the default Serialise typeclass
03:47:59 <merijn> lpsmith: How so?
03:48:43 <lpsmith> merijn, where's the Fail, Done, and Partial coming from?
03:48:57 <lpsmith> That's not cereal,  maybe pipes?
03:49:38 <merijn> It is cereal
03:49:46 <merijn> http://hackage.haskell.org/package/cereal-0.4.0.1/docs/Data-Serialize-Get.html
03:49:52 <lpsmith> hmm
03:49:57 <merijn> cereal has incremental parsing
03:50:00 <lpsmith> why did I miss that
03:50:03 <merijn> :)
03:50:14 <lpsmith> Once a while ago,  and now more recently
03:50:18 <lpsmith> like, just now
03:55:01 <lpsmith> still,  I need to run an attoparsec parser on the response itself;  on the other hand it should be acceptable for my purposes to just call cereal's  getLazyByteString
03:55:23 <lpsmith> then run attoparsec on the result
03:55:54 <merijn> lpsmith: Right, it depends on the complexity of the response
03:56:16 <merijn> lpsmith: In my case I just have fixed width fields and length prefixed values so I just parse everything using the Get monad
03:57:21 <lpsmith> merijn, well I discovered my original observation while I was studying attoparsec to see if I could write something like   "subparse :: Int -> Parser a -> Parser a"
03:58:11 <lpsmith> I think I have a reasonable (although not perfect) grasp on the internals now;  of course I've worked with continuation-passing code a fair bit.
03:58:35 <lpsmith> I don't think it's actually possible to write subparse at the moment
03:59:07 <merijn> lpsmith: It is, but it sucks, is ugly and prone to error >.>
03:59:24 <Tekmo> lpsmith: Why not?
03:59:28 <merijn> I wrote the same thing before switching to cereal :p
03:59:35 <Tekmo> lpsmith: You mean because the internals are not exposed?
04:00:00 <r44> https://gist.github.com/dredozubov/05fbe47cd914a52fc6f1 i'm trying to create simplest possible scenario with attoparsec + lazy bytestring and still it won' compile. Can anyone give me any pointers?
04:00:05 <lpsmith> Tekmo, no, I was looking at a patch to attoparsec
04:00:30 <lpsmith> I could be wrong,  but I don't see any way of preventing the inner parser from prompting for input on it's own
04:01:19 <lpsmith> Basically, there is no mapM because of the existential quantification on the result.
04:01:20 <Tekmo> lpsmith: I think this should be possible, for the same reason that it's possible for pipes-based parsing
04:02:20 <Tekmo> lpsmith: Can't you just feed it a subset of the input?
04:03:23 <merijn> r44: You're passing a lazy bytestring to something expecting a strict bytestring
04:03:32 <lpsmith> Well, you probably can if you turn Results back into parsers
04:03:44 <ilmig> @pl \x, y -> y+1
04:03:45 <lambdabot> (1 +) . snd
04:03:53 <Tekmo> lpsmith: I've been wanting this exact same feature myself
04:03:57 <merijn> r44: Also, every time you use ByteString.Char8 jesus murders a kitten
04:04:21 <Aetherspawn> Jesus doesn't murder anyone.
04:04:45 <lpsmith> But that's not how attoparsec normally works inside,  it's all an internal CPS most of the time
04:05:19 <Tekmo> lpsmith: I know that, but it's essentially isomorphic to `StateT <input> ErrorStuff r`
04:05:29 <merijn> r44: the "string" from Attoparsec.Char8 expects a strict ByteString, but B.pack is from ByteString.Lazy and returns a lazy bytestring
04:05:59 <r44> merijn: so i'm supposed to give strict bytestring to attoparsec's "lazy" parser? I'm kind of lost
04:06:10 <r44> seems like it
04:06:18 <merijn> r44: "string" is not a lazy parser, afaik?
04:06:21 <lpsmith> Tekmo, not really,  CPS enables non-local effects and exits.
04:06:41 <lpsmith> You could do it with a mapM analog,  but existential quantification inside Parser prevents that from happening
04:06:57 <lpsmith> err, not mapM,  mapCont, sorry.
04:07:10 <ilmig> @pl \x y -> y+1
04:07:11 <lambdabot> const (1 +)
04:07:25 <merijn> r44: It's unclear to me how to get a lazy Char8 Parser
04:07:26 <Tekmo> lpsmith: Not if it's universally quantified, which it is
04:07:44 <Tekmo> lpsmith: It's universally quantified, not existentially quantified
04:08:40 <lpsmith> Yeah,  you are correct, universally quantified
04:09:03 <Tekmo> lpsmith: The definition is a textbook church-encoding of `StateT s (Either e) r`
04:09:36 <r44> merijn: frankly i'm really confused with what i'm supposed to import (it's the first time i'm trying to write parser in haskell)
04:09:55 <merijn> r44: Why are you trying to use attoparsec?
04:10:09 <lpsmith> I'm going to walk back my claim a little bit,   subparse :: Int -> Parser a -> Parser a is doable if you implement Result -> Parser,  but it's not doable with the approach I had in mind
04:10:15 <merijn> r44: You seem to want to parse ASCII text?
04:10:22 <r44> i'm gonna parse pretty big files with ascci
04:10:23 <lpsmith> Tekmo, feel free to prove me wrong =)
04:10:25 <r44> ascii*
04:10:26 <r44> yep
04:10:32 <merijn> r44: If you want to just parse normal text, why not try Parsec?
04:11:01 <Tekmo> lpsmith: So I think there is one thing missing necessary to implement this correctly
04:11:30 <Tekmo> lpsmith: In order to limit the parser to a subset of the input, you need a place to stash the off-limits input while the parser is running
04:11:43 <obiwahn> [ERROR] Plugin.djinnPlugin: Djinn command failed: readProcess: djinn  (exit 127): failed
04:11:57 <Sagi> hello everyone. I how would I go about profiling using cabal-install? Every tutorial I find uses Ghc directly, but there's also some packages using Flag developer or similar. Can someone give me some hints?
04:12:24 <r44> merijn: maybe i'll try that later, now i just want to fix the code
04:12:28 <obiwahn> i get this when starting lambdabot
04:12:43 <Tekmo> lpsmith: Basically, for this to work, the type would have to essentially be `forall x . StateT (t, x) (Either e) r` instead of `StateT t (Either e) r`
04:12:54 <Tekmo> lpsmith: The `t` is the input you're allowed to parse and the `x` is the off-limits stash
04:12:56 <startling> Sagi, there's a ghc-options flag for cabal
04:13:01 <startling> Sagi: I'm not sure if that's what you mean
04:13:21 <obiwahn> Could not find module `SimpleReflect' when i type something
04:13:27 <ski> lpsmith : what should `subparse' do ?
04:13:43 <Tekmo> ski: It limits the parser to a subset of the input
04:13:57 <Tekmo> ski: i.e. `subparse 10 decimal` parses a decimal within at most 10 characters
04:14:05 <ski> oh
04:14:27 <lpsmith> ski,  basically an efficient   (subparse n p = do { t <- take n;  parseOnly (p t) }
04:14:33 <Sagi> startling: yeah, I found those. But it feels stupid to change those everytime I want to compile for production or for profiling.
04:14:50 <Sagi> startling: so I spotted the use of 'Flag's within .cabal files, but I have no idea how to use them.
04:14:56 <startling> Sagi: you could use a cabal flag
04:14:57 <startling> yeah
04:14:59 <startling> one sec
04:15:05 <lpsmith> well, my conception was that it'd also discard the leftover characters,  but either way....
04:15:17 <lpsmith> The difference isn't that important
04:16:03 <lpsmith> you can implement either variant from the other
04:16:11 <startling> Sagi: take a look at https://github.com/ekmett/lens/blob/master/lens.cabal , in particular lines 130 and 313
04:16:16 <Tekmo> lpsmith: If you understand `lens`, I can explain how to do this much more easily
04:16:35 <lpsmith> Tekmo, not yet
04:16:44 <Tekmo> lpsmith: Darn! :)
04:16:44 <startling> speak of the devil
04:16:53 <ski> Tekmo,lpsmith : so more or less like something like  replicateM 10 anyChar `andAlso_` decimal  ?
04:17:25 <lpsmith> well,  more like replicateM 10 anychar,  then run the decimal parser on the result.
04:17:29 <ski> er, well "at most 10", rather than "exactly 10" -- anyway, same idea
04:17:34 <lpsmith> Basically, here's a fixed-length field,  parse it with this parser.
04:17:35 <Tekmo> ski: What is this `andAlso_` function?
04:17:59 <ski> Tekmo : hypothetical combinator that runs two parses in lockstep, making sure then consume exactly the same input
04:18:07 <Sagi> startling: I think I get that part. But how to call cabal in order to actually signal their use?
04:18:10 <ski> s/then/they/
04:18:16 <Tekmo> ski: Yeah, then basically like that
04:18:19 <lpsmith> ski, well Tekmo seems to be talking about your former variant,  I'm talking about the latter,  but like I said,  they can both be used to implement the other pretty efficiently
04:18:26 <Aetherspawn> night Tekmo, and thanks :)
04:18:30 <Tekmo> Aetherspawn: You're welcome!
04:18:33 <Tekmo> Aetherspawn: Wait, one thing
04:18:40 <Tekmo> Aetherspawn: So do you want me to go ahead and write up those non-lens functoins?
04:18:55 <Aetherspawn> I reponded just a seconda go. That would be great!
04:18:59 <Tekmo> Ok, great! :)
04:19:19 <ski> lpsmith : i suppose in general composing parsers so that the output generated by one is passed as input to another is a different thing
04:19:19 <Sagi> startling: ah, I just found http://www.haskell.org/cabal/users-guide/installing-packages.html#controlling-flag-assignments , will try that.
04:19:29 <Aetherspawn> Also, sorry for sounding really naive. I wasn't aware conduit was dropping input
04:19:40 <Tekmo> Aetherspawn: It's alright
04:19:44 <Tekmo> Aetherspawn: You should also read this:
04:19:58 <Tekmo> Aetherspawn: http://www.haskellforall.com/2014/02/pipes-parse-30-lens-based-parsing.html
04:20:01 <Tekmo> Aetherspawn: Read that tomorrow
04:20:06 <Tekmo> Aetherspawn: It explains the issue in greater detail
04:20:14 <Aetherspawn> thanks!
04:20:15 <lpsmith> ski, the key difference is,  assuming the length-delimited field is long,  then you really want to have the inner parser operate incrementally,  instead of hoovering up a bunch of input until you have enough to run the whole thing.
04:20:18 <Tekmo> Aetherspawn: You're welcome!
04:20:35 <ski> Tekmo,lpsmith : basically, these `andAlso',`andAlso_' corresponds to the "with" (additive conjunction) connective in linear logic -- or more relevantly. ordered logic
04:20:49 <Aetherspawn> I also read your other lens tutorial and it was really great, but theres quite a large gap between the "feel" of the lenses used in the simple data accessing example and the lenses which apply logic like the ones in pipes
04:20:57 <Tekmo> ski: Linear logic is something I'm interested in generaly.  Do you have a good introductory paper or text for it?
04:21:00 <Tekmo> *generally
04:21:23 <Tekmo> Aetherspawn: Yeah, it's two separate idioms
04:21:31 <ski> lpsmith : yes, the idea is to have both run in lockstep, rather than first running one of them, and only after that running the second on exactly on input consumed by the first
04:21:42 <lpsmith> Like I said,  my use case is a log file,  with length-delimited responses of approximately 150-200 kilobytes.    Which really doesn't need to be run incrementally,  but at the same time attoparsec doesn't really have an efficient, out-of-box way of hoovering up that much input either.
04:21:50 <ski> Tekmo : hm, not sure
04:22:07 * ski can't recall quite where he learned most linear logic :/
04:22:14 <Tekmo> lpsmith: Wait, I have one question.  Is the length in question going to be quite large?
04:22:28 <Tekmo> lpsmith: i.e. will it be on the order of 10 characters or several kilobytes?
04:22:30 <lpsmith> In my case,  150-200 kilobytes :)
04:22:36 <Tekmo> lpsmith: Then you can already do this using `pipes`
04:22:49 <Tekmo> lpsmith: The only reason I didn't recommend `pipes` is that it wouldn't be efficient if the length was tiny
04:23:01 <Tekmo> lpsmith: The code basically looks like this
04:23:15 <Tekmo> lpsmith: zoom (splitAt numChars) (parse myParser)
04:23:25 <dreifuss> so i am trying to figure out how to parse a layout sensitive grammar in haskell, so far I have found Trifecta, that seemed to have layout parsing support until version 1.0
04:23:29 <Tekmo> lpsmith: That runs the parser within a fixed input size whlile preserving streaming
04:24:04 <Tekmo> lpsmith: Read this: http://www.haskellforall.com/2014/02/pipes-parse-30-lens-based-parsing.html
04:24:09 <ski> lpsmith : hm, just realized your "inner parser operate incrementally" applied to the "outer and inner parser" scenario, rather than the "combine two parsers into a single one that ensures both consume the same input" scenario
04:24:13 <Tekmo> lpsmith: The examples at the bottom of that post will interest you
04:24:41 <Tekmo> lpsmith: The relevant packages you want are `pipes-bytestring` (which provides the `splitAt` functionality) and `pipes-parse`/`pipes-attoparsec` (which provides the rest)
04:25:02 <Tekmo> lpsmith: I will write up a short example program to get you started
04:25:24 <Kaidelong> so if you have some typeclass T a b | b -> a
04:25:36 <lpsmith> Tekmo, that's ok,  I've pretty much decided on just doing it outside attoparsec,  with io-streams
04:25:37 <Kaidelong> and you have some other typeclass U a b
04:25:54 <Kaidelong> (T a b) => U a b
04:25:57 <Kaidelong> I meant
04:26:09 <Kaidelong> is GHC smart enough to know that U has the same fundep as T?
04:26:44 <lpsmith> Tekmo, after all I already have a log-following InputStream via linux-notify =)
04:26:56 <Kaidelong> or do you need to explicitly say (T a b) => U a b | b -> a
04:26:57 <Tekmo> lpsmith: Got it :)
04:27:08 <lpsmith> err, linux-inotify
04:27:36 <Kaidelong> also is T a b | a -> b, b -> a any less ambiguous than T a b | b -> a?
04:28:26 <lpsmith> Tekmo, it just seems that it might be a little nicer (and certainly useful elsewhere) if attoparsec had subparse
04:28:44 <ski> Kaidelong : iirc, you don't have to add the FD on the derived relation
04:28:50 <Tekmo> lpsmith: I agree
04:28:54 <lpsmith> which,  if you didn't care about long inputs,  I don't think you need to modify the internals at all for an efficient subparse
04:28:59 <Tekmo> lpsmith: For small sizes it's essential for performance
04:29:00 <lpsmith> I could be wrong.
04:29:05 <Kaidelong> ski: does anything bad happen if you do?
04:29:09 <Tekmo> lpsmith: Lots of input formats have things like `An integer within 8 columns`
04:29:18 <lpsmith> oh yeah
04:29:40 <ski> Kaidelong : i can't see why
04:29:44 <Kaidelong> yay
04:29:46 <Tekmo> lpsmith: Well, I do care about long inputs
04:29:48 <lpsmith> well,  I designed this log-file format myself,  it's length-prefixed to be able to handle arbitrary binary data without quoting.
04:29:48 <merijn> lpsmith: I added a feature request for subparse on github, but no reponse
04:30:02 <lpsmith> merijn, link?
04:30:08 <ski> Kaidelong : "is T a b | a -> b, b -> a any less ambiguous than T a b | b -> a?" -- yes, the former is stricter than the latter
04:30:23 <lpsmith> bos is busy enough that if you don't suggest a patch,  he's unlikely to respond.
04:30:24 <mm_freak> lpsmith: note that a length prefix makes a grammar context-sensitive
04:30:27 <Tekmo> lpsmith: I'm really anal about not loading more input into memory than is absolutely necessary
04:30:36 <merijn> lpsmith: https://github.com/bos/attoparsec/issues/48
04:30:41 <lpsmith> mm_freak, in a sense,  but who cares?
04:30:45 <Tekmo> lpsmith: Not true
04:30:51 <ski> Kaidelong : `T a b | a -> b' means `forall a. unique b. T a b' means `forall a b0 b0. (T a b0,T a b1) => b0 = b1'
04:30:52 <Tekmo> lpsmith: He's been responsive to my criterion issues
04:31:14 <lpsmith> Tekmo, bugs or feature requests?
04:31:15 <mm_freak> lpsmith: http://www.youtube.com/watch?v=3kEfedtQVOY
04:31:17 <Tekmo> lpsmith: bugs
04:31:32 <Tekmo> lpsmith: Maybe that's the difference
04:31:32 <ski> Kaidelong : in words, for each `a', there can be at most one `b' such that `T a b'. there can't be both instances `T a b0' and `T a b1', in case `b0' and `b1' are distinct
04:31:39 <mm_freak> lpsmith: "who cares" is exactly the attitude that is behind the flaws of our current protocols and file formats
04:32:10 <Kaidelong> ski: okay, thank you. Then I do want | a -> b, b -> a. restricting to a single instance is exactly what I want
04:32:13 <ski> Kaidelong : "If two instances for `T' have the same type for the `a' parameter, then they must also have the same type for the `b' parameter"
04:32:13 <lpsmith> mm_freak, I'm going to strongly disagree with you that length-prefixing is a bad thing.
04:32:18 <merijn> mm_freak: length prefixes are significantly easier/more efficient to parse, though
04:32:29 <lpsmith> mm_freak, and it's only context-sensitive at the lexical level
04:32:30 <Tekmo> merijn: Why?
04:32:43 <merijn> Tekmo: You can just bit-blit them
04:32:53 <Kaidelong> and I assume the result of that would be GHC not balking at a type like "T a b => b -> b -> b"?
04:32:58 <mm_freak> alright then
04:33:05 <obiwahn> simple-reflect-0.3.1 is installed
04:33:08 <Kaidelong> because it knows there is at most one instance for T a b
04:33:09 <Tekmo> merijn: How does that work?
04:33:10 <lpsmith> If you count the length-prefixed fields as a single token,  your file format can still be context-free
04:33:32 <ski> Kaidelong : when typechecking, if it knows `(T a b0,T a b1)' for some particular types `a',`b0',`b1', then given the FD, it can immediately unify `b0' and `b1' (and assuming that succeeds) (calling the common result `b') simplify those two constraints to a single `T a b' constraint
04:33:33 <Feuerbach> Does anyone recognize this arrow transformer? Is it defined anywhere? http://lpaste.net/99631
04:33:44 <merijn> Tekmo: In binary protocols where the payload is "just" arbitrary binary payloads, how else would you parse something?
04:33:56 <mm_freak> lpsmith: if you cound a turing-complete subgrammar as one token, then the overall grammer can still be contextfree?
04:33:57 <mm_freak> count
04:34:00 <Tekmo> merijn: I do this all the time
04:34:09 <merijn> Tekmo: How do you know when to stop?
04:34:20 <Tekmo> merijn: When parsing is done
04:34:22 <ski> Kaidelong : simply because it knows there can't be more that one such `b', so therefore if there is any such `b0' and `b1' (for any particular `a' there may or may not be), then `b0' and `b1' *must* be the same. this is what reduces the ambiguity
04:34:28 <merijn> Tekmo: How do you know when parsing is done?
04:34:52 <Tekmo> merijn: When it returns a value
04:35:01 <merijn> Tekmo: I'll give you an example
04:35:15 <lpsmith> mm_freak, yeah but typical examples of "this file format is context-free if you count length-prefixed fields as lexemes"  doesn't depend on such trivialities
04:35:17 <merijn> Tekmo: ZMTP sends variable size binary blobs over the network, prefixed by a header
04:35:31 <merijn> Tekmo: How do you figure out the blob size without having an explicit length?
04:35:35 <Tekmo> Oh, I see what you mean
04:35:46 <mm_freak> lpsmith: then you can define any grammar to be context-free and the word loses all its meaning
04:36:20 <lpsmith> I disagree,  trivial counterexamples aren't that interesting.
04:36:29 <lpsmith> exclude them :)
04:36:32 <mm_freak> lpsmith: but they are counterexamples
04:36:34 <merijn> Tekmo: I deal with blobs a lot, I'm surprised how anyone could propose a blanket ban on length prefixes and still be able to handle those
04:36:49 <merijn> mm_freak: I'm curious how you'd tackle this problem
04:36:55 <mm_freak> lpsmith: to disprove something, a single counterexample is sufficient, no matter how trivial it is
04:37:11 <mm_freak> merijn: a log format?
04:37:26 <merijn> mm_freak: No, parsing formats with blobs without length prefixes
04:37:31 <lpsmith> But if the counterexample is trivial,  you can just exclude it in a formal statement
04:37:47 <Tekmo> merijn: You're talking about raw payloads
04:37:47 <Tekmo> merijn: Yeah, if the payload has no distinguishing features then you need a length prefix
04:37:47 <Tekmo> mm_freak: When are you going to show me your high-performance bytestring stuff?
04:38:03 <lpsmith> And a certain amount of informality isn't a bad thing,  as long as everybody understands it.
04:38:25 <Tekmo> merijn: Yeah, I get it now
04:38:28 <mm_freak> merijn: binary blobs?
04:38:40 <lpsmith> I mean,  what's the estimated proof size that 2+2=4 using axiomatic ZF set theory?
04:38:41 <ski> Kaidelong : more generally, `T a b c d e | a c -> e b' means `forall a c. unique e b. exists d. T a b c d e' means `forall a b0 b1 c d0 d1 e0 e1. (T a b0 c d0 e0,T a b1 c d1 e1) => e0 = e1 /\ b0 = b1' (note no `d0 = d1' !), which could also be expressed as `forall a0 a1 b0 b1 c0 c1 d0 d1 e0 e1. (T a0 b0 c0 d0 e0,T a1 b1 c1 d1 e1) => (a0 = a1 /\ c0 = c1 => e0 = e1 /\ b0 = b1)'
04:38:53 <Tekmo> mm_freak: He basically means raw binary data that the transport protocol does not understand
04:38:58 <ski> Kaidelong : multiple FDs correspond to separate such conditions
04:39:01 <mm_freak> Tekmo: i think i've shown you bits and pieces of it…  there is no library right now, so individual functions is the best i can do right now =)
04:39:17 <merijn> Tekmo, mm_freak: I'd also be interested how a format like OTF should've been designed if context-sensitive parsing is so bad?
04:39:33 <lpsmith> A proof in mathematics is rarely truly formal,  but rather an repeatable experiment in convincing other knowledgeable mathematicians that they themselves could write a formal proof.
04:39:51 <mm_freak> merijn: i didn't say that context-sensitivity is bad…  i just didn't want it to go unnoticed
04:39:53 <Tekmo> mm_freak: Just show me one example where you got a really big performance improvement.  I can infer the rest
04:40:10 <mm_freak> anything more complicated than context-sensitive will be a problem
04:40:30 <ski> (though the FD `a c -> e b' is actually equivalent to the two FDs `a c -> e', `a c -> b')
04:41:24 <lpsmith> mm_freak, I agree that length-prefixing makes the resulting grammar context sensitive,  if you restrict yourself to looking only at bytes
04:41:38 <ski> Kaidelong : btw, if you know anything about relational databases, you'll note that the concept "functional dependency" here is basically the same as there, only applied in a different context
04:41:55 <lpsmith> I'm just saying that's not a bad thing :)
04:42:07 <lpsmith> In this case.
04:42:29 <Kaidelong> I do know some relational databases although the analogy is not immediately obvious, maybe if you're working straight with the relational calculus it is
04:42:35 <ski> lpsmith : ZF set theory is a bad thing, though :)
04:42:47 <mm_freak> Tekmo: http://lpaste.net/99632
04:43:02 <mm_freak> Tekmo: that's one example of an efficient line splitter
04:43:10 <mm_freak> in this case it splits into IRC protocol lines
04:43:38 <mm_freak> this particular one joins sequences of delimiters
04:43:44 <lpsmith> ski =)
04:43:47 <mm_freak> so \r\n\r\n\r\n is only one delimiter
04:44:07 <Tekmo> mm_freak: Thanks
04:44:20 * ski doesn't know where lpsmith would like to draw the line between "context-free" and "context-sensitive". how trivial is trivial enough ?
04:45:46 <lpsmith> well, certainly (some variant of) stating that file format can be context-free if you count length-prefixed fields as lexemes is a legitimate and useful statement.
04:46:08 <Feuerbach> exactly
04:46:12 <Feuerbach> it's trivial if it's not useful
04:46:17 <Kaidelong> ski: I was asking all this in the context of this little bit of conceptualizing I was doing, by the way: http://lpaste.net/99621
04:46:27 <Feuerbach> considering any language as context-free is not useful
04:46:27 <lpsmith> mm_freak is pointing out that every file format is context-free under that definition if you count the entire file as a single lexeme
04:46:29 <Kaidelong> wrt how to get rid of num
04:46:51 <lpsmith> which is totally legit,  but not all that useful,  and definitely relying on a trivial construction.
04:47:33 <lpsmith> how to formalize all this, I dunno
04:47:44 <lpsmith> Let's make fun of C's syntax instead :-P
04:47:57 <obiwahn> Cale: do you know what lambdabot's problem with simple-reflection could be?
04:48:00 <Tekmo> mm_freak: Also, have you seen the recent trick for limiting parser input while preserving leftovers?
04:48:14 * ski would simplify `(Semigroupoid t) => ' to `Semigroupoid t => ' :)
04:48:16 <Tekmo> mm_freak: It works better than just truncating the producer with `Pipes.ByteString.take`
04:48:49 <Tekmo> mm_freak: You can now do `zoom (splitAt maxBytes) yourParser` and the parser will run within `maxBytes` input and it will still return leftovers correctly
04:49:06 <lpsmith> Which is context-sensitive in a bad way,  and not in a useful way.
04:49:15 <lpsmith> C++ is even worse.
04:49:33 <mm_freak> Tekmo: yeah, but in this case it's not needed…  the leftover in this case is specifically to be discarded =)
04:49:38 <merijn> lpsmith: How is C's context-sensitive in a bad way?
04:49:52 <lpsmith> char * foo;
04:50:01 <mm_freak> lpsmith: the problem is that certain assumptions break down as soon as you have context-sensitivity
04:50:04 <Tekmo> mm_freak: Got it
04:50:16 <merijn> lpsmith: How is that context sensitive?
04:50:19 <lpsmith> Does that declare a pointer to a (char*),  or multiply two variables,  char and foo?
04:50:25 <Kaidelong> I always use parenthesis on the left side for some reason, I think it looks prettier
04:50:29 <lpsmith> char is probably a bad exaple.
04:50:32 <merijn> lpsmith: The former, char is not a valid identifier
04:50:34 <Kaidelong> but if it is not idiomatic then I guess I should stop
04:50:37 <lpsmith> foo * bar;
04:50:51 <mm_freak> lpsmith: most notably a context-sensitive grammar makes writing lazily producing parsers much more difficult
04:51:16 <lpsmith> In general, absolutely.
04:51:27 <ski> Kaidelong : `class Group t => AbelianGroup t' is certainly possible yes (and can be useful for the reason you give)
04:51:47 <lpsmith> In the specific case of length-prefixed fields,  it's usually not so bad.
04:52:05 <mm_freak> lpsmith: a Parser type is such a general setting…  you will have to include special cases for lazy production, and runParser won't give you any strictness guarantees anymore
04:52:30 * ski would really like a common subclass of `Show' and `Read' with no methods, expressing the law `read . show = id'
04:52:51 <mm_freak> ski: well, there is Serialize
04:53:03 <Kaidelong> ski: in that case wouldn't the right thing to do be to make a "class Semigroupoid t => AbelianSemigroupoid t" and then, if that instance is instantiated, work up through existing instances to AbelianMonoid and AbelianGroup?
04:53:09 <mm_freak> but yeah, it's binary
04:53:19 <ski> mm_freak : but it's not mentioned in the standard, now is it ?
04:53:24 <Kaidelong> I guess I could uncomment the cascades of instances I had for stuff like that already
04:53:42 <mm_freak> ski: which is almost a shame =)
04:54:10 <Kaidelong> also those cascades were the whole reason for Semiring being defined in terms of a monoid isomorphism rather than it just having its own (*) and one
04:55:22 <ski> Kaidelong : some people always wrap a "constraint list" in outer brackets, because they think it's prettier ior easier to add more constraints. some other (like me) finds the extra unnecessary brackets jarring and remove them when possible
04:55:30 <ski> (i do the same with `deriving')
04:55:41 <Kaidelong> the main thing I'm worried about is that it'll be ugly to write (Semiring whatthewhatgoeshere t) => type with t but no u, even if it is perfectly valid just to leave the u on the left side unbound
04:55:59 <ski> .. however, in some cases i do add in extra brackets, e.g. when i want to emphasize a particular structure/pattern in a type, like
04:56:18 <Kaidelong> err
04:56:23 <Kaidelong> not unbound, you have to bind it
04:56:30 <Kaidelong> but bound polymorphically and left unused
04:56:33 <ski>   fmap :: Functor f => (  a ->   b)
04:56:34 <ski>                     -> (f a -> f b)
04:56:53 <Tekmo> My rule of thumb is to do whatever hlint says, because if I don't then people will yell at me for ignoring hlint
04:56:54 <ski> (here the latter pair of brackets are strictly speaking unnecessary)
04:57:24 <Kaidelong> ski: with higher order functions though explicit right association makes sense
04:57:32 <lpsmith> ugh,  hlint.   I find the "redundant do" warning pretty obnoxious
04:57:47 <Kaidelong> because it expresses that you really do mean you're working on "function values"
04:57:49 <ski> Kaidelong : re, `AbelianSemigroupoid' -- perhaps
04:58:14 <lpsmith> I tend to throw in do in certain cases whether it's needed or not
04:58:25 <ski> Kaidelong : yes, or at least explicitly hinting to the reader that it can be useful to do that in some circumstances
04:58:38 <Tekmo> lpsmith: I like to throw it in if I think it will help a beginner's eye
04:58:49 <ski> lpsmith : yes, i sometimes do that as well
04:59:03 <lpsmith> I like to throw it in so I don't have to add it later,  and to reduce the size of future deltas.
04:59:04 <Tekmo> lpsmith: For example: `forM_ xs $ \x -> do ...`
04:59:14 <lpsmith> exactly,  I'd definitely use do in that case
04:59:28 <ski> (if some branches (bodies of defining equations, or `case' branches) use `do' outermost, i commonly add it for all of them)
04:59:53 <Tekmo> Yeah, I like that, too
05:00:10 <Tekmo> Visual consistency is a big plus
05:01:44 <ski> Kaidelong : re `class (AbelianGroup t, Monoid u) => Ring u t' -- are you sure you don't need a way to convert between `u' and `t' there ?
05:03:23 <Tekmo> I really wish there were a SemiRing class, if only so that I could implement a `Bool` instance
05:04:04 <ski> hm, i suppose one could possibly think about superclasses as reference constraints, in terms of the relational database model
05:04:36 <ski> (whereas FDs obviously are functional dependency constraints)
05:06:50 <ski> Kaidelong : `fromInteger :: Integer -> t' (note, not `Int') could exist for every ring (assuming you allow it to be non-injective)
05:07:25 <ski> > fromInteger 12345678901234567890123456789 :: Int  -- such as in this cse, e.g.
05:07:27 <lambdabot>  5097733592125636885
05:07:33 <ski> s/cse/case/
05:09:32 <ski> Kaidelong : given an `Integer' `n', you can add `one' to itself that many times (or taking `negate' on the negated number of times, if negative) -- of course there's often a more efficient way, hence this is a good candidate for a class method with default (which is interpreted as a law that must hold, regardless of actual implementation)
05:09:52 <ski> iow, according to this argument, `fromInteger' could reside in `Ring'
05:16:14 * ski idly wonders why `class (Monoid (Prod t),Monoid t) => Semiring t | Prod t -> t where {data Prod t; toProduct :: t -> Prod t; fromProduct :: Prod t -> t}' doesn't work :/
05:18:07 <ski> hm, well, i suppose one would probably have to say `(Prod t) -> t', to have it be interpreted correctly
05:18:37 <ski> and i suppose saying `data Prod t' actually enforces `Prod t -> t' anyway
05:19:00 <milfjord> ... where { data Prod t; instance Monoid (Prod t); ... }
05:19:26 <skypers> hey
05:19:28 <ski> (`t -> Prod t' is obvious, doesn't need to be stated)
05:19:28 <lpsmith> merijn, hah,  your suggestion for fixed is yet a third possibility...  require the sub-parser to consume the entire input
05:19:38 <ski> milfjord : is there a difference there ?
05:19:38 <skypers> I’m running a RWST (over IO) in IO a
05:19:38 <skypers> like
05:19:46 <milfjord> just making up syntax
05:19:47 <skypers> (a,_,_) <- runRWST …
05:19:48 <skypers> return a
05:19:53 <skypers> I get an error on the type:
05:20:02 <skypers>     Couldn't match expected type `IO t0'
05:20:02 <skypers>                 with actual type `(a0, s0, w0)'
05:20:05 <skypers> any idea?
05:20:08 <ski> Kaidelong : anyway, something like ^ might be nice to attempt
05:20:17 <milfjord> skypers: what's the code and the error message?
05:20:23 <lpsmith> So you could leave the unconsumed input there for the outer parser,  you could discard the unconsumed input,  or require the parser consumes everything
05:20:30 <skypers> milfjord: (a, _, _) <- runRWST s cinfo () M.empty
05:20:45 <skypers> it runs it a function IO a
05:20:45 <lpsmith> I guess actually the first option would be the most general,  as you can't really put back input
05:20:49 <ski> @type runRWST
05:20:50 <lambdabot> RWST r w s m a -> r -> s -> m (a, s, w)
05:21:05 <milfjord> ski: aah
05:21:13 <milfjord> good spot
05:21:15 <ski> skypers : you're passing four actual parameters ?
05:21:25 <skypers> s, cinfo, () and M.empty
05:21:26 <skypers> four.
05:21:30 <ski> milfjord ?
05:21:33 <lpsmith> at least, not with attoparsec
05:21:55 <milfjord> ski: well, runRWST only takes 3 so m = Reader
05:21:59 <milfjord> I mean (e ->)
05:22:05 <milfjord> hence the IO vs tuple conflict
05:22:06 <skypers> :t runRWST
05:22:07 <lambdabot> RWST r w s m a -> r -> s -> m (a, s, w)
05:22:15 <ski> milfjord : environment :)
05:22:17 <skypers> no
05:22:19 <lpsmith> Though,  reading the attoparsec source,  I suspect you could probably be a bit faster and more general,  with some work.
05:22:20 <skypers> it’s the Writter
05:22:31 <skypers> I don’t have to pass () for the Writer
05:22:34 <skypers> ahah
05:22:43 <skypers> I can drop the () I guess
05:22:45 <ski> the writer/output only outputs, no input
05:22:56 <skypers> yeah
05:23:00 <skypers> it works
05:23:06 <skypers> thank you anyway :)
05:23:21 * ski generally prefers using the terms "environment" and "output" to "reader" and "writer"
05:23:42 <ski> (like i think many of the original papers do)
05:23:51 <milfjord> ski: that's not how we unix!
05:24:00 <ski> milfjord ?
05:24:39 <milfjord> in a unix context "environment" would be the 3rd parameter to execve and "output" the stuff sent to file descriptor 1
05:26:35 <ski> yes
05:27:06 <ski> and the environment (`Reader r' and `(r ->)') serve a similar purpose
05:27:16 <ski> (also "variable environment")
05:27:46 <milfjord> but "naked environment" isn't as fun to say as "naked reader"
05:28:04 <ski> what's the naked part ?
05:28:31 <milfjord> no newtype Reader around it
05:28:42 <Twey> Athas: I think your site's MenuLevel is a list zipper
05:30:00 <ski> mhm
05:30:01 <Athas> Twey: correct, although I don't really move around in it.
05:32:01 <Twey> Hm, yes
05:36:44 <drbean> I have a function, parseAll :: :: PGF -> Type -> String -> [[Tree]]
05:36:59 <drbean> But I have only a IO PGF value.
05:37:06 <milfjord> >>=
05:37:19 <drbean> How do I lift the String to IO String?
05:37:52 <Athas> drbean: liftM3 parseAll
05:38:17 <Athas> Alternatively, use Applicative and: parseAll <$> ioPGFArg <*> pure arg2 <*> pure arg3
05:38:25 <ski>   liftM3 parseAll :: IO PGF -> IO Type -> IO String -> IO [[Tree]]
05:38:26 <Athas> In all cases, you'll get an IO [[Tree]] back, of course.
05:38:33 <milfjord> drbean: why do you need that?
05:38:40 <drbean> I am doing: liftM2 parseAll gr (liftM startCat gr)  "who laughs"
05:38:59 <milfjord> that seems unnecessarily complicated
05:39:05 <milfjord> and it runs gr twice
05:39:42 <milfjord> gr >>= \x -> return (parseAll x (startCat x) "who laughs")
05:44:27 <ZettaBlade> Hey, I'm trying to design a program that can launch other executable files, and keeps track of those executables and maybe even communicates with them. Any advice on how I can go about doing this, or relavant subjects I could research?
05:44:47 <Athas> ZettaBlade: in Haskell, or in general?
05:44:55 <Athas> In Unix, you're looking at fork(), exec() and wait(), really.
05:44:57 <ZettaBlade> In haskell
05:45:45 <Athas> Well, for Haskell on Unix, it's System.Posix.Process.ByteString.forkProcess, then use the PID you get back to keep tabs on it.
05:46:11 <Athas> I'd recommend creating a lightweight Haskell thread per process that is responsible for tracking that process.
05:46:21 <Athas> You can use MVars to communicate with these threads.
05:47:23 <merijn> forkProcess is a bad idea
05:47:52 <merijn> I recommend using System.Process.createProcess
05:48:00 <merijn> It's more portable (i.e. supports windows)
05:49:02 <merijn> I would spawn one thread per process and then use those to interact witht he spawned processes
05:50:13 <ZettaBlade> How exactly would interaction work? MVars?
05:50:32 <merijn> ZettaBlade: MVars, Chans or TVars depending on what you wanna do
05:51:27 <Athas> ZettaBlade: do you mean interaction with the processes or the Haskell threads?
05:51:39 <Athas> For the processes, there aren't many nice ways to do it.
05:51:52 <Athas> You can read their stdout/stderr, write to their stdin, send them signals, etc.
06:03:55 <xintron> Is it possible to specify the type value for a function? data Foo = Bar | Biz; foo :: Foo(Bar) or something like that?
06:04:14 <xintron> (on the other hand, wouldn't really make sense would it :/ )
06:04:50 <hpc> you should look at GADTs
06:04:55 <hpc> they aren't quite that, but close
06:05:26 <hpc> what you are asking for in general is called dependent types, which haskell doesn't have
06:07:48 <merijn> I like how everyone always says "dependent types are too hard!"
06:08:05 <merijn> Yet every newbie figuring out the Haskell type system seems to immediately find a use for them :p
06:08:15 <Twey> Heh
06:09:08 <hpc> they get a lot harder when you have to implement it ;)
06:09:29 <merijn> hpc: Sure, but I'm pretty sure most people would have a hard time implementing haskell too
06:09:39 <merijn> That doesn't seem to stop people from using haskell :p
06:09:49 <Twey> Haskell's a lot harder to implement :þ
06:10:42 <hpc> void interpret (Program p) { printf("Error: mutation is an illusion!"); exit(1); }
06:11:11 <Twey> Heh
06:11:19 <milfjord> errors should go to stderr, not stdout
06:11:20 <hpc> i wish i was a bad enough dude to write a language :(
06:11:21 <milfjord> missing \n
06:11:27 <milfjord> 1 is not a portable exit status
06:11:38 <hpc> thatsthejoke.jpg
06:11:56 <merijn> Speaking of implementing languages
06:12:18 <merijn> I've asked before, but does anyone know a minimal Hindley-Milner typed functional language?
06:12:50 <merijn> Doesn't have to be usable as long as it can run a program, has GC and covers at least STLC with like numbers and booleans
06:13:15 <merijn> I don't want to have to implement one from scratch to do some research >.>
06:13:54 <Twey> merijn: It's only a hundred lines or so to write one in Haskell
06:14:08 <hpc> yeah, i can't think of one
06:14:17 <hpc> but it's the quintessential GADT example
06:14:46 <Twey> I don't know of anyone who writes minimal HM languages any more, but I could link you to a dozen implementations of dependently-typed lambda calculus :þ
06:15:19 <Twey> In fact
06:15:21 <merijn> hpc: That doesn't have ASM generation and GC, though
06:15:35 <merijn> hpc: I don't mean "implement an AST in haskell and have an "interpret" function
06:15:38 <Twey> … actually, no, that's probably complicated enough to be less useful
06:15:39 <klrr_> attoparsec is freaking difficult to debug oO
06:15:44 <merijn> I want something that runs and has a GC
06:15:59 <merijn> klrr_: How so?
06:16:13 <Twey> merijn: You mean, you want a native-code compiler?
06:16:19 <merijn> Twey: Yes
06:16:25 <Twey> Hrm
06:16:28 <merijn> Twey: Well, if it compiles to JVM or whatever, that'd be fine too
06:16:34 <merijn> Twey: Actually, wait, no
06:16:43 <Twey> merijn: edwinb has a language called ‘Epic’ in Haskell with a native backend
06:16:51 <merijn> Pretty sure GC is built-in in JVM, no?
06:16:54 <Twey> Yes
06:17:01 <merijn> Right, then I want native code
06:17:10 <Twey> You could write the trivial HM language in Haskell and translate it to Epic
06:17:19 <Twey> … or you could just read the Epic source
06:17:31 <klrr_> merijn: writing a IRC bot and my attoparsec code fail to parse the messages BUT when i pass the messages in the repl it succeeds
06:17:34 <Twey> It's designed as a compiler target, so it's pretty minimal
06:17:41 <merijn> Twey: Oh! This might be what I need
06:17:46 <merijn> Twey: Thanks!
06:17:50 <Twey> No problem
06:18:03 <Twey> I don't think it does type inference, but that's the easy bit :þ
06:18:04 <klrr_> and then i tried start debugging it printing more info out and it basically says nothing (which i expected since it says so in docs that it dont return useful info)
06:18:17 <Twey> Oh, compiles to C, beg your pardon
06:18:29 <klrr_> but anyway, i need to get some energy to rewrite the parser in parsec instead, gonna eat
06:18:59 <merijn> Twey: Don't really care, tbh. I want to experiment with parallel GC that utilises typing to ensure you don't leak/proper handover between GC pools
06:19:10 * Twey nods.
06:19:18 <Twey> Epic is untyped, but it seems like good reference material
06:19:24 <merijn> Twey: So if I have something simple to generate and a basic GC implementation that means I don't have to reinvent the wheel
06:19:34 <merijn> The typing I need to do myself anyway
06:20:29 <merijn> klrr_: Did you try using Debug.Trace to print debug info?
06:26:51 <magicman> klrr_: What has tripped me up with writing a parser for IRC messages is that they end in \r\n. Even if you hGetLine from an IRC handle, there may still be a dangling \r which may not be there if you enter the message in the repl.
06:44:39 * hackagebot DAV 0.6.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.6.1 (ClintAdams)
06:48:26 <magicman> http://lpaste.net/99640 <- Weird stuff is happening when I combine the cgi and hint packages.
06:48:44 <magicman> Individually, they work fine. That code should be fairly minimal.
06:49:11 <magicman> Anyone have any idea what I should try (or if I'm trying something that's fundamentally flawed)?
06:49:36 <opqdonut> have you tried to run the cgi executable by hand?
06:52:04 <magicman> Works. Some Content-type headers followed by Right 5.
06:52:39 <opqdonut> could it be an issue with the current working directory or something like that?
06:52:42 <magicman> So. Hrm. The server software is mangling things :-/
06:52:55 <opqdonut> try invoking the cgi executable from another directory
06:53:16 <magicman> I don't know. Other Haskell-made cgi executables work just fine :-/
06:53:17 <opqdonut> (I'm assuming you ran ./cgi-executable and cgi-executable and Nmber.hs were in the same directory)
06:53:48 <magicman> Indeed. Pretty sure the executable and Number.hs need to be in the same directory for hint to find it, though.
06:54:42 <opqdonut> the webserver is probably not setting the working directory to anything, and hint probably searches for Number.hs in the working directory
06:55:18 <magicman> Ah, okay. Any clue why it's looking for M<random-numbers>, though?
06:55:21 <milfjord> >not setting the working directory to anything
06:55:24 <milfjord> ಠ_ಠ
06:55:35 <opqdonut> well I mean it's the working directory of the web server
06:55:43 <opqdonut> not explicitly setting it to anything just for the cgi
06:55:50 <milfjord> ah
06:56:00 <opqdonut> magicman: have a look at Language.Haskell.Interpreter.searchPath. it defaults to .
06:56:04 <magicman> Yeah, I'm ashamed to admit, but the server is MS IIS stuff -_-.
06:56:11 <opqdonut> I guess the error message is just bad
06:56:13 <magicman> Not my machine, is all I can say.
06:56:32 <opqdonut> should be easy enough to start your program with a cd to the right directory
06:56:39 <opqdonut> or you could wrap it in a shell script that does it
06:56:45 <opqdonut> or you could set the search path explicitly
06:58:09 <magicman> Using a (for the moment hardcoded) dir with System.Directory.setCurrentDirectory right at the start would work, you think?
06:58:54 <dxtr> Guys
06:59:15 <dxtr> 'setSocketOption sock ReuseAddr 1' give an invalid argument exception under openbsd
07:02:30 <magicman> Okay. setCurrentDirectory to where the executable and Number.hs are located doesn't do a thing. Let's try the searchPath thing.
07:04:41 * hackagebot deka 0.2.0.0 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.2.0.0 (OmariNorman)
07:07:21 <magicman> Neither does the searchPath :-/
07:15:59 <jophish_> Yo yo yo
07:16:23 <jophish_> Using GHC TypeLits, how can I get from a type level natural to an Integer
07:17:07 <jophish_> natVal seems to be the way to do it, but I'm getting hung up on not being able to deduce KnownNat
07:17:08 <magicman> I'll set up an Apache on my own machine, and see if I can get it to work. Thanks for thinking with me!
07:21:27 <merijn> jophish_: You can't
07:21:37 <merijn> jophish_: Well, you can use the singletons library which fakes it
07:21:47 <merijn> jophish_: But there's no way to create values from types in Haskell
07:22:01 <benmachine> merijn: I'm not sure that's
07:22:05 <benmachine> er
07:22:06 <benmachine> true :P
07:22:15 <benmachine> I mena, type classes pretty much allow types to determine values
07:22:22 <benmachine> *mean
07:22:32 <jophish_> merijn: I presume that this would require some magic in GHC
07:22:34 <benmachine> especially Typeable which will actually allow you to dispatch based on types
07:22:50 <merijn> benmachine: Sure, but only if you explicitly ship dictionaries with values
07:22:59 <jophish_> :t natVal
07:23:00 <lambdabot> Not in scope: `natVal'
07:23:02 <merijn> benmachine: You can go "here's a type you haven't seen, give me a value"
07:23:02 <benmachine> merijn: "sure, but only if you do a thing that GHC does"
07:23:09 <jophish_> :t GHC.TypeLits.natVal
07:23:10 <lambdabot> Not in scope: `GHC.TypeLits.natVal'
07:23:31 <merijn> benmachine: With TypeFamilies you can produce types in ways that the dictionary can't be shipped with the type
07:23:54 <benmachine> merijn: but "it can be impossible" is very different from "it is impossible"
07:24:10 <merijn> benmachine: Generally it's impossible in the interesting cases
07:25:02 <jophish_> The problem is this: I'm implementing a language with haskell's syntax, and In my language I have a type 'Array (n :: Nat) a'. I'm trying to implement in Haskell a set of libraries which will perform the same as the types in my language
07:25:20 <jophish_> in my language I have: size :: Array n a -> Int
07:25:44 <jophish_> in the haskell wrapper, arrays are implemented as: Array (n :: Nat) a = Array [a]
07:26:00 <jophish_> it would be nice to be able to implement size too
07:26:28 <benmachine> ...length?
07:27:15 <jophish_> benmachine: the definition for fromList wouldn't allow that
07:27:25 <benmachine> ah, I see
07:27:26 <jophish_> fromList :: [a] -> Array n a
07:30:08 <excarna> I have Yesod set up in a cabal sandbox. I'm trying to use `yesod init` to set up a new project, but whenever I cd into the newly created directory and use `yesod devel` it tells me a whole whack of dependencies are missing, including a number of yesod packages, conduit, warp, etc...
07:30:34 <excarna> what gives? I thought I already installed yesod, I'm not sure how I can use `yesod devel` if I didn't
07:31:34 <benmachine> jophish_: fromList seems like an odd function, what happens if the list is not the right length?
07:31:50 <merijn> excarna: Yesod init create a project which tries to use the yesod library, but since that's installed in a sandbox it doesn't see the library
07:32:07 <jophish_> benmachine: runtime error when using haskell. in my language the only lists are ones passed to fromList, and they have to have a size resolved at compile time
07:32:11 <jonasw> Can you pass -package-db to ghc through yesod devel?
07:32:20 <merijn> excarna: The solution is to setup a new sandbox for your "yesod init" directory and add the yesod sandbox to that
07:32:22 <jonasw> And point it to your sandbox
07:32:29 <merijn> excarna: However that works with sandboxes
07:32:49 <jophish_> so in my language I can have: myArray :: Array 5 Int; myArray = fromList [1,1,2,3,5]
07:33:00 <merijn> jophish_: Trying to make haskell code exactly reflect your source language is going to be a hard fight
07:33:12 <Sagi> if I perform (in a cabal sandbox) cabal install --reinstall -p <somepackage>, it tells me that it's already installed and that I can reinstall using --reinstall :?
07:33:25 <merijn> jophish_: Why not implement the array type in your language using normal haskell arrays?
07:33:29 <Sagi> sounds like a bug to me, or at least something I didn't expect at all.
07:33:54 <jophish_> merijn: my language is extremely restrictive, no recursion or recursive data types
07:34:02 <jophish_> I doubt that Array would be compatible with this
07:34:11 <merijn> jophish_: Why does that matter?
07:34:36 <jophish_> merijn: I may not have understood your first question
07:34:39 <merijn> jophish_: You sound like you're not so much writing a language as trying to implement a language as a haskell library
07:35:09 <merijn> jophish_: Why would the primitives used to implement your language have to mimic your actual language?
07:35:11 <jophish_> merijn: I'd like to use GHC to sanity check my compiler. I write some code in my language, and check if my compiler and GHC agree
07:35:31 <merijn> jophish_: That makes your life much harder, though
07:36:01 <merijn> Because it means you can't really implement things in your language that cannot be implemented in haskell
07:36:28 <jophish_> merijn: That's not really a problem. I'm fine with my language being a subset of Haskell
07:36:37 <jophish_> however compile time sized arrays are a requirement
07:36:46 <merijn> jophish_: Right, but those are really hard in haskell
07:37:01 <jophish_> I only need to emulate them with the same syntax
07:37:10 <jophish_> I don't really care how arcane they are behind the scenes
07:39:26 <jophish_> merijn: you mentioned faking it with singletons, could you elaborate a little?
07:41:05 <merijn> @hackage singletons
07:41:05 <lambdabot> http://hackage.haskell.org/package/singletons
07:41:54 <CaptainK> when GHCi loads, why do 5 Prelude prompts appear?
07:43:20 <geekosaur> not seeing that here, do you have a .ghci?
07:43:41 <Kaidelong> why do we have Monoid rather than LeftZeroSemigroupoid?
07:44:18 <Kaidelong> (with Monoid just being a typeclass with an empty instance that subclasses that)
07:44:55 <Kaidelong> LeftZeroSemigroupoid is enough for mconcat
07:47:11 <Sagi> how do I add cost centres to a third party library?
07:48:00 <Sagi> I compiled with --enable-library-profiling and added ghc-prof-options: -auto-all to its cabal file, but I still don't get any cost centres associated with the package.
07:48:42 <Sagi> strangely enough, I do get CAF cost centres, presumable from the -caf-all in my own .cabal.
07:52:43 <Sagi> oh, removing and re-creating the sandbox seems to have solved it. :-\
08:14:49 * hackagebot libsystemd-journal 1.1.0 - Haskell bindings to libsystemd-journal  http://hackage.haskell.org/package/libsystemd-journal-1.1.0 (OliverCharles)
08:15:43 <dhrosa> ni/join #xmonad
08:16:37 <dhrosa> oops
08:19:10 <rawtass> how do I define an infinite list of infinite lists? [[1..], ...] does not work..
08:20:03 <jophish_> I'm not entirely sure that Data.Singletons is what I want
08:20:06 <jophish_> http://lpaste.net/99642
08:20:29 <jophish_> This is where I've got to with GHC.TypeLits
08:21:13 <jophish_> the compile errors: http://lpaste.net/99644
08:21:47 <jophish_> putting: natVal (Proxy :: Proxy 5) works
08:22:01 <jophish_> using a literal there is ok, but n doesn't work
08:22:27 <enthropy> rawtass: what's the second list supposed to be?
08:22:52 <enthropy>  iterate tail [1 .. ] -- one option
08:22:59 <enthropy>  repeat [1 .. ] -- another
08:24:06 <enthropy> jophish_: fromList :: forall n. KnownNat n => [a] -> Array n a
08:24:47 <mirpa> How do I send patch to code.haskell.org repository using darcs?
08:24:48 <enthropy> you need to do that (and add -XScopedTypeVariables) otherwise there is no connection between the "n" on like 16 and the one on like 17
08:24:50 * hackagebot gtk3 0.12.5.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.12.5.2 (HamishMackenzie)
08:24:52 * hackagebot gtk 0.12.5.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.5.2 (HamishMackenzie)
08:25:05 <rawtass> enthropy: hm.. So [repeat [1 ..]] ?
08:25:19 <enthropy> mirpa: "darcs send" or maybe darcs send -O (and email the .dpatch)
08:25:36 <jophish_> enthropy: super, thanks very much!
08:25:42 <mirpa> enthropy: thanks ... so I need to setup sendmail
08:25:43 <rawtass> take 2 (take 2 [repeat [1..]]) ?
08:26:04 <enthropy> well I just attach patch bundles manually
08:26:17 <jophish_> enthropy: why did this need forall n, though?
08:26:37 <rawtass> should this not print the two first elements of the two first elements of these infinite nested lists?
08:27:06 <milfjord> no, take 2 is idempotent
08:27:31 <milfjord> take 2 . take 2 == take 2
08:28:06 <rawtass> ok
08:28:33 <dhrosa> take 2 returns the first two elements of the  list, then you're trying to t ake the first two elements of the  resulting list, which is going to be  the same exact  list
08:28:47 <milfjord> > take 2 "abcde"
08:28:48 <lambdabot>  "ab"
08:28:55 <milfjord> > take 2 (take 2 "abcde")
08:28:57 <lambdabot>  "ab"
08:29:22 <cognominal> is "beginning Haskell" worth the money? I had only terrible experiences with Apress
08:29:29 <milfjord> > take 2 (map (take 2) (repeat [1 ..]))
08:29:31 <lambdabot>  [[1,2],[1,2]]
08:29:52 <dhrosa> cognominal: I've been wondering the same thing about that book, looks interesting
08:29:59 <rawtass> milfjord: ok.. nice
08:30:25 <enthropy> jophish_: because in standard haskell type variables aren't scoped (except when you define classes I guess)
08:31:09 <jophish_> so one needs to use ScopedTypeVariables and forall t to pull it into scope manually
08:31:16 <enthropy> you might as well have called the "Proxy n" "Proxy notTheNabove"
08:31:33 <enthropy> that's just one option
08:32:08 <cognominal> dhrosa, It has one 5 star comment on amazon.   For non computer books, there is often enough comments to make up my mind.
08:32:24 <enthropy> you can write   withSelf :: (Proxy n -> Array n a) -> Array n a; withSelf f = f Proxy
08:32:29 <enthropy> without any scopedtypevariables
08:34:38 <cognominal> dhrosa, https://twitter.com/puffnfresh/status/430057677842944000
08:34:52 * hackagebot SafeSemaphore 0.10.0 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.10.0 (ChrisKuklewicz)
08:36:00 <dhrosa> oo
08:39:31 <obiwahn> +hbot │   Could not find module `SimpleReflect'
08:39:37 <obiwahn> what must i do to fix this?
08:40:17 <CyberPunkZ> hey is it possible i can use the tagging on xmobar for mcwm like how u can use it on xmonad, but instead i want to use the tag for mcwm
08:40:48 <CyberPunkZ> tag for the workspace .. also i notice mem, cpu, and other plugins with xmobar doesnt work at all on freebsd
08:42:44 <obiwahn> ghc-pkg list -> simple-reflect-0.3.1
08:45:20 <Kaidelong> ReaderT is just Kleisli!
08:46:32 <Kaidelong> why do we need both? limitations with the order of type arguments?
08:52:42 <Feuerbach> Kaidelong: nice observation :) but yeah, the argument order is different (for a good reason), and also they are used for different purposes
08:58:43 <obiwahn> is my state buggy?
09:00:26 <Feuerbach> obiwahn: what's the problem?
09:00:33 <obiwahn> +hbot │   Could not find module `SimpleReflect'
09:00:53 <Feuerbach> what's +hbot? I don't understand this
09:01:56 <obiwahn> hbot is a lambdabot
09:02:05 <obiwahn> now i am looking at the L.hs
09:02:25 <obiwahn>  --import SimpleReflect hiding (var)
09:02:41 <obiwahn> now it complains about something else
09:03:09 <merijn> cognominal: I can't say, but there's several haskell books well known to be worth money, so why buy some unknown one ;)
09:03:22 <Feuerbach> oh, I know nothing about lambdabot, unfortunately
09:03:27 <merijn> cognominal: Lean You a Haskell and Real World Haskell are both good (and available for free online)
09:03:32 <Eduard_Munteanu> What's a synchronous alternative to Chan, or is it already? I mean writes would block until someone reads from them.
09:03:50 <merijn> Eduard_Munteanu: Eh, MVar? :p
09:04:12 <Feuerbach> or a bounded chan
09:04:13 <Eduard_Munteanu> merijn: yeah, though it doesn't seem to have a getContents API
09:04:19 <obiwahn> > 1 +1
09:04:20 <merijn> cognominal: There's also Graham Hutton's Programming Haskell, which I don't know but have heard good things about?
09:04:20 <lambdabot>  2
09:04:52 <Feuerbach> getChanContents is evil
09:05:03 <merijn> Eduard_Munteanu: That's a feature :)
09:05:13 <Eduard_Munteanu> I suppose I could use an additional MVar for synchronizing the writers.
09:05:32 <Eduard_Munteanu> Or just use an MVar really. :)
09:06:16 <Eduard_Munteanu> Feuerbach: any more evil than getContents?
09:06:44 <merijn> Eduard_Munteanu: Not really, but getContents is pretty evil already
09:06:51 <Eduard_Munteanu> Heh, fair.
09:06:56 <Feuerbach> a bit, I'd say
09:12:42 <obiwahn> my bot thows errors like Control.Arrow.Transformer.All: Can't be safely imported!
09:13:00 <obiwahn> i wonder if the files have been partially renamed
09:13:14 <haasn> Kaidelong: Kleisli can't be an instance of MonadTrans, for example
09:19:48 <Eduard_Munteanu> What's a good way to multiplex reading from multiple Handles? I'm launching asyncs to read each Handle and putMVar to a shared MVar, but it seems I have to check if there's are any writers left so it doesn't block indefinitely.
09:20:27 <Eduard_Munteanu> I'm reading it from the main thread.
09:22:37 <Feuerbach> what's wrong with it blocking?
09:24:24 <Eduard_Munteanu> Feuerbach: basically I'm running a command and reading its stdout and stderr, sending lines to the main thread. So the issue is the main thread will block if it attempts to takeMVar when the logging threads are gone.
09:25:16 <Eduard_Munteanu> Feuerbach: I could check if the process is still running (since I want the exit code anyway) but I'm wondering if I'm missing something
09:25:39 <Feuerbach> so what do you want to do if the logging thread is gone?
09:26:46 <Eduard_Munteanu> Feuerbach: check the exit code and return, the main thread is waiting for the external command to finish
09:26:49 <RichyB> Eduard_Munteanu, there are two answers to this: either you want the logging threads to send a message saying "I've stopped now" which the main thread will count up, or…
09:26:56 <Feuerbach> you could set a flag (in forkFinally's handler) and check for it in the reading thread
09:27:15 <RichyB> …you can rely on the fact that threads that block indefinitely on an MVar in GHC become eligible for garbage collection.
09:27:32 <oddasat> Hi, I`m trying to get m
09:27:40 <Feuerbach> I wouldn't rely on the latter
09:27:41 <RichyB> The latter isn't a solution to your problem
09:27:48 <Eduard_Munteanu> Oh, so these sort of checks are fine? I could just check if the process is running.
09:28:07 <Eduard_Munteanu> RichyB: yeah, because I'm not running that on a separate thread
09:28:25 <Eduard_Munteanu> Actually that's racy too...
09:28:28 <RichyB> No, that won't do if the main thread runs the check in between the subprocess finishing and a line arriving from the stdout-reading process
09:28:34 <Eduard_Munteanu> Yeah.
09:28:53 <RichyB> What I'd do is use MVar Either (ExitCode String),
09:28:54 <dxtr> 'setSocketOption sock ReuseAddr 1' give an invalid argument exception under openbsd. I Googled around and found http://lpaste.net/77947 that suggests setSocketOption (in ghc?) might be broken under OpenBSD. Do anyone know more about this?
09:29:03 <oddasat> Hi, I`m trying to get my head a round something, two short functions I`d like to inline: http://lpaste.net/99649
09:29:07 <RichyB> er
09:29:14 <RichyB> MVar (Either ExitCode String)
09:30:53 <RichyB> Eduard_Munteanu, so if you were doing this with logging threads, you'd have to make sure that the logging threads always finish by putMVar (Left n).
09:31:32 <RichyB> I have felt that I'd really like a user-level select/poll library in HS before. :|
09:32:07 <Eduard_Munteanu> Indeed.
09:32:17 <RichyB> oddasat, what is your problem? What is your code doing that you would like it to not do?
09:32:35 <cognominal> merijn, about "beginning haskell", what interest me also it that it talks a bit about idris and dependant programming.
09:34:00 <cognominal> merijn, If I understand well, many recent haskell features are special cases of dependent progamming.
09:34:09 <zg> what's the difference between 'bottom type' and 'void'
09:34:11 <oddasat> re: http://lpaste.net/99649, I was thinking I could capture bits of `toGregorian ...`, pick one of the parameters and return it directly, without having to create a new function (like dayNumber)
09:34:37 <Eduard_Munteanu> RichyB: hmmm... I think I could spawn an additional async to collect results, and make the main thread wait for the first to finish
09:34:42 <milfjord> oddasat: did you have a question?
09:35:01 <oddasat> like (_,m,_) $ dayNumber $ toGregorian d
09:35:05 <Eduard_Munteanu> And another one to wait for the process to finish.
09:35:11 <cariveri> hi. how do I handle option paring with parsec ?  where one option is a prefix of the next? like (string "Initial" <|> "Invalid") http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-ParserCombinators-Parsec-Prim.html
09:35:24 <milfjord> oddasat: (\(_, m, _) -> m) (...)
09:35:31 <milfjord> if you're talking about literal inlining
09:35:52 <milfjord> you can also use destructuring binding with let or case
09:37:04 <oddasat> ok, I`ll give that a go, thanks!
09:37:30 <Eduard_Munteanu> cariveri: not sure what you mean by prefix given that example
09:37:57 <cariveri> Eduard_Munteanu: "In" is the prefix of Initial and of Invalid.
09:38:33 <Eduard_Munteanu> cariveri: ah, you probably want to use 'try' to make it backtrack
09:39:16 <Eduard_Munteanu> cariveri: try (string "Initial") <|> try (string "Invalid")
09:39:24 <cariveri> Eduard_Munteanu: hwo woudl I do that with several options? I did: try ( op1 <|> .. <|> opN) . but that dint work
09:39:39 <cariveri> Eduard_Munteanu: really? each one gets a try?
09:39:42 <Eduard_Munteanu> cariveri: you need 'try' on each one
09:39:47 <RichyB> Eduard_Munteanu, that approach makes most sense to me.
09:40:46 <Eduard_Munteanu> cariveri: try (op1 <|> ...) will backtrack once all ops parsers fail, and each of them could consume some input
09:41:23 <Eduard_Munteanu> @hoogle choice
09:41:24 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
09:41:24 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
09:41:24 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
09:42:24 <RichyB> cariveri, the other option, if you can, is to left-factor the grammar to get rid of the shared prefix. Instead of (try $ string "Initial") <|> (try $ string "Invalid"), write: string "In" >> (string "itial" <|> string "valid")
09:42:36 <RichyB> Yay, LL(1)!
09:42:38 <Eduard_Munteanu> cariveri: mapM try [op1, op2, ...]   might be nicer for many options
09:42:48 <Eduard_Munteanu> Er.
09:43:16 <Eduard_Munteanu> choice (map try [op1, op2, ...])
09:43:20 <cariveri> Eduard_Munteanu: for the time being I inserted "try" each time. and it wokrs. so msut thank you anyways!
09:43:38 <watermind> is there any extension to simplify the syntax of partial application? e.g.  \x->(x,a)  ==   (_,a)
09:43:51 <merijn> cognominal: If you want to dive more into type theory there are perhaps other books to consider
09:44:05 <benmachine> watermind: in the specific case of tuples there are TupleSections
09:44:07 <benmachine> :t (,4)
09:44:08 <lambdabot> Num t1 => t -> (t, t1)
09:44:09 <Eduard_Munteanu> watermind: in that case, TupleSections let you write (, a)
09:44:12 <merijn> cognominal: Specifically, Types and Programming Languages would be a good followup after learning Haskell
09:44:13 <cariveri> RichyB: lefting didnt work, because its too many options and too complicated. the names are jsut arbitrary.  thank you though.
09:44:33 <haasn> :t (4,) :: (, Int)
09:44:34 <lambdabot> parse error on input `Int'
09:44:35 <merijn> cognominal: It deals with implementing type systems
09:44:45 <Eduard_Munteanu> Heh.
09:45:06 <watermind> benmachine: Eduard_Munteanu: I see... why just for tuples though? Any reason why it wouldn't work with other functions, e.g.  (map _ xs)
09:45:25 <benmachine> watermind: the primary problem with the underscore syntax is ambiguity
09:45:25 <cariveri> Eduard_Munteanu: thank ill try that too. choice map
09:45:44 <haasn> watermind: I think the main concern is it being too unclear where the lambda gets introduced, syntactically
09:45:56 <benmachine> watermind: like, say I have map (f _) xs, does this mean \y -> map (f y) xs, or does it mean map (\y -> f y) xs?
09:46:04 <haasn> watermind: for that particular case you could write (map ?? xs) where (??) = flip  :)
09:46:18 <watermind> benmachine: haasn: good points
09:46:22 <benmachine> plus, lambdas themselves aren't exactly heavyweight
09:46:38 <watermind> haasn: yeah I know but that's not super readable
09:46:45 <haasn> benmachine: three symbols, an identifier not to mention *all that whitespace*!?
09:47:07 <benmachine> haasn: it's the parens that you usually need, those are the worst
09:47:33 <zg> should I focus on Haskell 98 or Haskell 2010
09:47:35 <benmachine> but you can cut the three symbols to two by enabling UnicodeSyntax and using → :P
09:47:42 <zg> I'm trying to choose which online report to read
09:47:44 <merijn> zg: The differences are minimal
09:47:44 <haasn> how about (\f x _ y _ z) as shorthand for (\a b -> f x a y b z)
09:47:45 <benmachine> zg: the difference isn't that great
09:47:49 <zg> ok
09:47:51 <benmachine> zg: might as well go with H2010
09:47:57 <merijn> zg: If you're going to read the report, just read Haskell2010
09:48:00 <watermind> zg: if you're leanring 98 gives you more than enough, if you're developing 2010, I would say
09:48:10 <zg> thats what I was reading originally, but then learned there are older versions of Haskell
09:48:19 <haasn> or perhaps (→f x _ y _ z) or (->f x _ y _ z) or (λf x _ y _ z)
09:48:31 <merijn> zg: Although I wouldn't really read the report while learning haskell (that may just be my bias)
09:48:56 <merijn> zg: I think reading the report mostly makes sense if you are implementing haskell or using it as a reference to answer a specific question
09:49:15 <zg> I'm just trying to learn the language, I figure the report is a good starting point
09:49:29 <merijn> (much like I wouldn't recommend the C standard for learning C, although the Haskell Report is *much* more accessible)
09:49:40 <merijn> zg: Have you tried Learn You a Haskell and/or Real World Haskell?
09:49:56 <Eduard_Munteanu> zg: if you feel like reading concise stuff, take a look at The Gentle Introduction (which isn't that gentle :D)
09:49:56 <zg> yeah, I didn't really enjoy reading Learn You a Haskell
09:49:58 <darthdeus> is there a good tutorial on cabal sandbox?
09:49:59 <Eduard_Munteanu> @where gentle
09:49:59 <lambdabot> http://www.haskell.org/tutorial/
09:50:12 <watermind> merijn: seems like one of the few people who still prefer Richard Birds book :/
09:50:16 <Eduard_Munteanu> zg: ^^
09:50:28 <obiwahn> http://paste.debian.net/80884/ after i have commented out quite a lot my lambdabot is working
09:50:38 <mirpa> dathttp://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
09:50:45 <mirpa> darthdeus: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
09:50:50 <merijn> watermind: Never heard of that book :)
09:50:52 <obiwahn> could somebody help me to fix the missing imports
09:50:54 <darthdeus> mirpa: thanks
09:51:40 <zg> Our purpose in writing this tutorial is not to teach programming, nor even to teach functional programming. Rather, it is intended to serve as a supplement to the Haskell Report [4], which is otherwise a rather dense technical exposition.
09:51:46 <zg> lol.
09:51:53 <watermind> merijn: http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460
09:51:55 <haasn> obiwahn: you mean, help you figure out which package provides those modules? You can use hayoo for that
09:52:08 <zg> that's a bit from the Gentle Introduction to Haskell, which is what I was reading originally...
09:52:13 <obiwahn> is that a program?
09:52:32 <merijn> where hayoo
09:52:34 <merijn> @where hayoo
09:52:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
09:52:38 <watermind> merijn: it's rather theoretical, and uses pre-98, but he focuses on reasoning about your programs from the very beginning
09:52:59 <watermind> merijn: and I find that gives you a pretty strong basis to understand all the rest
09:53:09 <watermind> merijn: just not a fan of how he introduces monads
09:53:17 <darthdeus> is there a way to do cabal install so that it automatically adds the package to my project's .cabal ?
09:53:20 <darthdeus> in the dependencies
09:53:24 <darthdeus> kinda like npm install --save
09:53:32 <haasn> “Integer (infinite-precision integers)” Isn't it better to call them “arbitrary-precision integers”?
09:53:59 <monochrom> yes. but people like to conflate "unbounded" with "infinite"
09:54:02 <Eduard_Munteanu> haasn: integers are easily infinite precision :)
09:54:11 <mirpa> darthdeus: it should report package name you are missing in dependencies
09:54:37 <Eduard_Munteanu> Which is stronger than just arbitrary precision.
09:54:53 <haasn> come to think of it, what does precision even mean? Something's either precise, or it's imprecise to some degree. You can't get more precise than precise
09:54:59 <mirpa> darthdeus: ...in case of compilation error using cabal build or cabal install
09:55:01 * hackagebot lens 4.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.2 (EdwardKmett)
09:55:19 <monochrom> even a very good statistics prof, I caught him saying, for an infinite series, "sum until i equals infinity"
09:55:36 <darthdeus> mirpa: uhm, i'm talking about this in reverse mode ... say that i do cabal init and then i want to add happstack, so what i would do is to run cabal install happstack, then edit the .cabal file and add happstack there
09:55:39 <Eduard_Munteanu> haasn: you could say arbitrary / infinitesimal error instead
09:55:49 <Eduard_Munteanu> Or null error even.
09:55:49 <haasn> monochrom: in other words, you never stop summing? :)
09:55:54 <darthdeus> what i was asking is if i can do someting like cabal install happstack --save and it'll get added to the .cabal file for me :)
09:56:15 <jrmithdobbs> darthdeus: add it to the cabal file and then cabal install --dependencies-only --reinstall
09:56:18 <haasn> I think (unbounded integers) is the correct label here
09:56:27 <jrmithdobbs> darthdeus: and basically every time you change the cabal file cabal clean and re-run that
09:56:37 <obiwahn> » cabal install --max-backjumps -1 hayoo
09:56:38 <darthdeus> hmm okay
09:56:39 <obiwahn> Resolving dependencies...
09:56:41 <obiwahn> cabal: out of memory (requested 2097152 bytes)
09:56:42 <monochrom> I don't know. "i equals infinity" is just wrong.
09:56:43 <obiwahn> :(
09:56:45 <darthdeus> jrmithdobbs: why do i need to clean?
09:56:53 <darthdeus> jrmithdobbs: shouldn't it figure out stuff automatically? :X
09:56:59 <jrmithdobbs> it should, but it does not
09:57:04 <Eduard_Munteanu> monochrom: maybe he was a non-standard analysis sort of guy :P
09:57:38 <jrmithdobbs> darthdeus: because the dep checking isn't as good as node/bundler/similar quite yet, sandboxes are brand new in 1.18
09:57:49 <haasn> monochrom: another big can of worms is all the various forms of limits involving infinity
09:57:50 <Eduard_Munteanu> One who does not stop at Archimedean fields.
09:57:53 <monochrom> cabal out of memory, that's fun :)
09:58:02 <darthdeus> jrmithdobbs: ok, makes sense :)
09:58:22 <jrmithdobbs> darthdeus: so it doesn't always rebuild the right things and occassionally you just need to cabal sandbox delete; cabal sandbox init; cabal install --dependencies-only --reinstall ;p
09:59:00 <monochrom> anyway, just saying, people are very confused about things like "there are infinitely many whole numbers, therefore infinity is one of them"
09:59:04 <jrmithdobbs> darthdeus: but that's better than having to do the equiv on the global package db!
09:59:14 <darthdeus> yeah true
09:59:25 <watermind> monochrom:   "I don't know. "i equals infinity" is just wrong."   it could fine, if e.g. he defines N +{\inf}  and  n<\inf forall n. in N
09:59:39 <watermind> monochrom:   then you have an until meaning he never stops summing
09:59:55 <watermind> monochrom: and then he can define sum and producing a sequence of partial sums :P
10:00:23 <watermind> s/and/as
10:00:38 <jrmithdobbs> darthdeus: i'm finding with 7.8.1rc once i got it bootstrapped right with dynamic libs that the sandbox is less useful (and broken at least on os x with dynamic libs)
10:00:51 * Eduard_Munteanu . o O (infinity = sup N   ?)
10:01:06 <monochrom> I don't know why you go out of your way to rationalize it. it is a statistics course. do you think any prof will bother? and if they do, do you think any student will bother?
10:01:55 <Eduard_Munteanu> For fun, not for the rationalization itself. :)
10:02:01 <watermind> monochrom: who knows... I've seen algebra teachers stuck teaching statistics courses before, so he might... the students no so much
10:02:30 <monochrom> I just feel like I have nerd-sniped a lot of people
10:02:44 <watermind> that wasn't meant to be taken too seriously
10:03:03 <darthdeus> jrmithdobbs: this is also probably a noob question, but why am i having to add things like blaze-html in the dependencies when happstack itself depends on them? i'm trying to follow this http://happstack.com/page/view-page-slug/9/happstack-lite-tutorial#starting
10:04:07 <Eduard_Munteanu> darthdeus: because cabal wants to know about your direct dependencies
10:04:24 <Eduard_Munteanu> E.g. to import packages and such.
10:04:42 <jmcarthur> darthdeus: if happstack is later upgraded to not depend on blaze-html, it would break your package if you weren't required to specify it for your own uses.
10:04:54 <jmcarthur> darthdeus: even if happstack's api doesn't change at all
10:05:01 <jrmithdobbs> darthdeus: if you import them in your modules you have to specify them
10:05:43 <cognominal> merijn, about "type and programming". I should read it. It scared me at the time, and I wanted to learn haskell, not ml. I have read enough of the haskell white paper that idris papers become to make sense to me even if I don't understand yet a lot of it probably because it assumes the knowledge of other dependantly typed languages like coq or epigram.
10:05:48 <monochrom> yes, if you did not have any import line relevant to blaze-html, you would not need to mention blaze-html
10:07:32 <cognominal> merijn, I still feel a beginner but looking back I have made a lot of progress. Otherwise, the more you learn, the more you feel ignorant.
10:08:28 <darthdeus> ok that makes sense
10:08:31 <darthdeus> thanks guys
10:16:01 <merijn> cognominal: tbh, it uses fairly simple ocaml, once you're fairly comfortable with haskell it should be easy enough to read the ocaml code
10:16:29 <cognominal> I agree.
10:16:32 <merijn> cognominal: Whether it's worht reading depends on what your goal is
10:16:46 <merijn> If you wanna learn this stuff to write your own language, then I'd recommend it
10:19:33 <cognominal> merijn, my knowledge is very spotty so it could certainly consolidate it, and his following book "advanced topics..." even more so
10:30:06 * hackagebot deka 0.2.0.2 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.2.0.2 (OmariNorman)
10:30:08 * hackagebot purescript 0.3.11 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.11 (PhilFreeman)
10:34:37 <adelbertc> so.. i'm in a freshly made cabal sandbox, and i run "cabal install happy" and i get: The program happy is required but it could not be found  during the install process....
10:34:41 <adelbertc> happy.. depends on happy? o_O
10:35:13 <morrrrrgan> secrets d'état & co ( révélations, etc ), faites tourner .. http://morganroulleau.wordpress.com ( on s'en branle que vous compreniez pas, au pire ça viendra plus tard ( .. )) ( La NSA approuve ce message. ) ( méway, sans doute, ils m'aiment. )
10:35:16 <morrrrrgan> GL HF
10:38:29 <adelbertc> more info her: http://lpaste.net/6626820880561340416
10:41:50 <zg> I'm really enjoying ghci, but I'm wondering if it's possible to send one-liners to ghci to get responses
10:41:57 <zg> without actually opening ghci, of course
10:42:33 <zg> ahk, gotta go
10:42:36 <zg> I'll come back later
10:43:56 <BMeph_> adelbertc: Just so you don't feel totally abandoned... :)
10:44:14 <adelbertc> ?
10:45:50 <BMeph_> adelbertc: ...but Happy is an executable, as well as a library - alex is the same way - so it needs the program to link to.
10:46:02 <adelbertc> so i need to install it manually?
10:46:09 <BMeph_> @where happy
10:46:10 <lambdabot> http://www.haskell.org/happy/
10:46:24 <BMeph_> Yes.
10:46:40 <adelbertc> "cabal install happy" <--- lieeessssssss
10:47:09 <BMeph_> adelbertc: Mainly, it's just "put the exec in your /bin directory," but it isn't (yet) done automatically.
10:48:11 <adelbertc> BMeph_ - got it - so if i want to sandbox the install, i would clone the source, initialize a sandbox, and then build the source?
10:49:59 <BMeph_> adelbertc: Sounds about right. We're still working out the "how to make programming in Haskell as dull as Java" kinks here. ;)
10:50:19 <adelbertc> heh
10:50:42 <adelbertc> to clarify, i don't need to change anything in the cabal file (https://github.com/simonmar/happy/blob/master/happy.cabal) right? cabal sandbox init with a cabal install --only-dependencies with cabal build will do it?
10:51:17 <adelbertc> commands like "runhaskell Setup.lhs configure/build/install" are superceded by "cabal configure/build/install" right
10:51:39 <adelbertc> (i'm new to haskell (from scala land) if you can't tell.. :-) )
10:51:54 <BMeph_> adelbertc: I guess most of the heavy-hitters are still out "having a life" around now, so you didn't get the typical four-point contrapuntal fugue of answers.
10:54:17 <BMeph_> adelbertc: Okay, well, welcome to Haskell! In a couple of months, expect to do a lot of "oh, so THAT's where that came from" and "now if only it did THIS..." in your programming sessions! ;)
10:54:38 <adelbertc> heh, thanks
10:54:52 <Xenasis> Without using the word burrito, can someone explain to me what a monad is in simpleish terms?
10:55:25 <BMeph_> Yep - and, yes, to the cabal thing; not so much superceded, as starting to get more automated.
10:55:26 <adelbertc> Xenasis - a type of kind (* -> *) that supports two operations (>>=) and (return), along with some laws
10:55:39 <haasn> Xenasis: I suggest the chapter on them in LYAH and also http://www.haskell.org/haskellwiki/Typeclassopedia#Monad
10:55:59 <adelbertc> BMeph_ - awesome possum
10:56:00 <haasn> but only once you have a firm understanding of type constructors and type classes
10:56:12 <Xenasis> I'm pretty sure I do o.o
10:56:17 <Xenasis> I've heard of some stuff it says
10:57:32 <Eduard_Munteanu> Xenasis: it's best to ask some questions if you've looked into this before, to get started
10:58:31 <Xenasis> I've not really looked into this before, but I recognise some of the words from Agda
10:58:44 <bennofs> Is there some kind of tree datastructure that allows one to easily update all the leaves (extending the tree, by replacing the leaves with new trees)? I also need top-down traversal
10:58:49 <Xenasis> I've been meaning to actually understand what a monad is for ages though
10:58:51 <adelbertc> bah, cabal configure gives "unrecognized option `--sysconfdir=$prefix/etc'" and "unrecognized option `--extra-prog-path=/Users/adelbertc/.cabal/bin'"
10:59:11 <Eduard_Munteanu> Xenasis: heh, cool... you came to Haskell from Agda. You don't hear that every day. :)
10:59:13 <haasn> Xenasis: ‘monad’ is a term from category theory. Are you interested in category theory, or are you interested in haskell's Monads?
10:59:35 <Xenasis> A mixture of the two, I think
10:59:42 <Xenasis> Eduard_Munteanu: I came to Agda from OCaml, too
10:59:45 <Xenasis> Coq looks vile
10:59:46 <Eduard_Munteanu> @quote haskell.*heroin
10:59:46 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
10:59:48 <Xenasis> :P
10:59:54 <dwcook> Xenasis, you might be interested in ##categorytheory for the former
10:59:55 <nsno> :')
10:59:55 <haasn> Xenasis: for Monad, you could probably jump directly to the latter link. It gives a good rundown of the operations, laws and some examples
11:00:09 <Xenasis> Everyone says they're some super hard complicated thing and doesn't explain it, but hell, I need to understand what a monad is for xmonad, for example
11:00:14 <Xenasis> bind is used for xmobar
11:00:27 <nsno> (i came to haskell after a whirlwind 1 hour walk-through of agda)
11:00:30 <Kaidelong> why do you need to understand what a monad is for xmonad
11:00:30 <Xenasis> (I know that it is called bind but I do not know what it is)
11:00:35 <haasn> Xenasis: as for category theory, you'd want to start with category theory's foundations. There are many books on this, the one I first used was Benjamin Pierce's “Basic Category Theory for Computer Scientists”
11:00:47 <dwcook> Xenasis, you don't need to know what monads are to use a particular structure that happens to be a monad
11:01:02 <adelbertc> Xenasis - i've had good recommendations for "Conceptual mathematics - a first introduction to categories"
11:01:02 <Xenasis> eh, that feels dirty :$
11:01:09 <Xenasis> I'd like to understand something before I use it
11:01:15 <Kaidelong> that's backwards
11:01:21 <Xenasis> Not really
11:01:29 <Xenasis> you know what a number is before you do addition
11:01:31 <Twey> Xenasis: Did you understand monoids before you concatenated strings?  :þ
11:01:39 <Xenasis> Anyway, I'll look at that book and page I guess
11:01:47 <jrmithdobbs> is there something like -ddump-splices for deriving extensions?
11:01:53 <Eduard_Munteanu> Xenasis: monads provide a bare minimal API that accomodate computations with side-effects, it's a least common denominator of sorts.
11:01:54 <Kaidelong> Xenasis: what is a number?
11:02:02 <haasn> Personally I find looking at the theory of something helps me understand how to use it in practice and vice versa. I can totally support wanting to learn the theory
11:02:23 <Xenasis> alright o.o
11:02:46 <Eduard_Munteanu> Well, "side-effects". I should rather say "computations with structured output", where side-effects are one example of extra structure.
11:03:11 <Eduard_Munteanu> :t (>>=)
11:03:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:03:16 <Twey> I'm all for learning theory, but thinking you *have* to learn the general theory before you can use an instance of it is just plain wrong
11:03:24 <darkPassenger> http://pastebin.com/sCkvpdLi
11:03:26 <milfjord> The paste sCkvpdLi has been copied to http://lpaste.net/3794965912277221376
11:03:34 <darkPassenger> I have a hard time understanding the error message
11:03:41 <merijn> Twey: No it isn't, I had to master quantum mechanics before I could even understand how to walk!
11:03:44 <Twey> (thankfully, or I'd have to study for twenty years before I could do addition)
11:03:49 <Twey> Hehe
11:03:53 <darkPassenger> is says a syntax error on last line
11:03:57 <Xenasis> You don't need to be an expert
11:04:01 <Xenasis> only to understand what it is
11:04:11 <Eduard_Munteanu> Xenasis: if you look at (>>=) type, it makes this pretty clear: you give it a computation yielding 'a' in a context, and a function that uses the result and produces another computation.
11:04:13 <Xenasis> at a base leveel
11:04:23 <Twey> Xenasis: Quantum mechanics for walking?  :þ
11:04:27 <Xenasis> No
11:04:38 <trillioneyes> darkPassenger: you don't want an = before "loop (x:xs) = ..."
11:04:41 <Xenasis> Quantum mechanics in terms of walking is very hard stuff!
11:04:52 <Twey> Heh
11:04:56 <Xenasis> You only really need to know the fundamental basics of how legs work to try
11:04:56 <trillioneyes> And I think it needs to be indented to line up with the upper loop
11:05:13 <BMeph> bennofs: That's not so much a property of the tree, as how you acces it.
11:05:26 <Eduard_Munteanu> Xenasis: it's probably best to start with a few simpler examples like the Maybe monad
11:05:39 <Eduard_Munteanu> @src Monad Maybe
11:05:39 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
11:05:45 <Eduard_Munteanu> @src Maybe Monad
11:05:45 <lambdabot> Source not found. Wrong!  You cheating scum!
11:05:48 <Eduard_Munteanu> Bleh.
11:05:54 <dwcook> @src instance Monad Maybe
11:05:54 <darkPassenger> trillioneyes: thx, i still have a syntax error on the last line
11:05:54 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:05:57 <dwcook> Welp
11:06:02 <Twey> Xenasis: Quantum mechanics is a general theory that can be applied to give you walking — you don't need to know anything about quantum mechanics in order to walk, only to generalize concepts from walking.
11:06:17 <Twey> Category theory is, uh, maybe around Newtonian mechanics in this analogy :þ
11:06:22 <trillioneyes> darkPassenger: http://lpaste.net/3794965912277221376 annotated
11:06:36 <Eduard_Munteanu> return x = Just x   Nothing >>= _ = Nothing    Just x >>= f = f x
11:06:46 <Xenasis> o.o
11:06:58 <trillioneyes> hmmm, actually... I think you also might need to have all the | at the same level
11:07:06 <trillioneyes> And have the "where" indented less
11:07:23 <BMeph> bennofs: Likewise, if you need top-down traversal, just traverse it top-down. :)
11:07:38 <kosmaks> hey guys. is there any good articles on session types?
11:07:59 <darkPassenger> trillioneyes: it says unexpected symbol "loop"
11:08:00 <haasn> kosmaks: I have this open in a tab but I've never looked at it: http://www.eecs.harvard.edu/~tov/pubs/haskell-session-types/
11:08:02 <haasn> maybe it'll help
11:08:03 <darkPassenger> on last line
11:08:15 <Eduard_Munteanu> Xenasis: so Maybe models computations that can fail. I might be going a bit fast but I figure if you came from Agda, you're ok with reading equational stuff. :)
11:08:30 <kosmaks> yea, i saw it
11:08:34 <haasn> @@ Eduard_Munteanu @src Maybe return
11:08:34 <lambdabot>  Eduard_Munteanu return              = Just
11:08:38 <kosmaks> but thanks anyway
11:08:42 <BMeph> bennofs: Sorry, I'd talk more, but if I don't get breakfast, my wife will Hurt me...
11:08:44 <haasn> Oops, unfortunate output from lambdabot there :)
11:08:57 <Xenasis> Eduard_Munteanu: I'll give it a look, thanks!
11:08:58 <trillioneyes> darkPassenger: can you repost what you have now?
11:09:03 <darkPassenger> yes
11:09:12 <darkPassenger> http://pastebin.com/4YMvJki2
11:09:14 <milfjord> The paste 4YMvJki2 has been copied to http://lpaste.net/6914572939090198528
11:09:31 <haasn> Who is milfjord and what did he do to mauke
11:09:55 <dwcook> A /whois will answer that
11:09:58 <Eduard_Munteanu> haasn: I remember lambdabot could output entire typeclass definitions
11:10:10 * hackagebot conduit-extra 0.1.4 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.4 (MichaelSnoyman)
11:10:17 <hpc> /whois milfjord
11:10:33 <hpc> milfjord [~i_ate_mauke@i/ate/mauke]
11:10:55 <Eduard_Munteanu> Heh.
11:11:06 <haasn> Eduard_Munteanu: not with @src at any rate, at least not in the copies of lambdabot's ‘@src’ file I've seen
11:11:14 <trillioneyes> darkPassenger: does this work? http://lpaste.net/6914572939090198528
11:11:23 <haasn> Eduard_Munteanu: it can, however, output entire typeclass definitions (I'm guessing you actually meant instances)
11:11:26 <trillioneyes> There's a description of the layout rules somewhere
11:11:29 <haasn> @src Monad
11:11:30 <lambdabot> class  Monad m  where
11:11:30 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:11:30 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:11:30 <lambdabot>     return      :: a -> m a
11:11:30 <lambdabot>     fail        :: String -> m a
11:11:42 <trillioneyes> darkPassenger
11:11:43 <trillioneyes> http://en.wikibooks.org/wiki/Haskell/Indentation
11:12:16 <Eduard_Munteanu> I meant instances, yes.
11:12:25 <Kaidelong> don't curse like that lambdabot, geez
11:12:57 <Kaidelong> don't read anything after "return" Xenasis
11:13:25 <L8D> darkPassenger: quit using tabs, use spaces
11:13:27 <trillioneyes> Yes, "fail" is widely considered to be a mistake that doesn't belong in the class
11:13:28 <Kaidelong> also >> is just a special case of >>=
11:13:41 <darkPassenger> L8D: thats the issue ?
11:13:46 <Kaidelong> aptly named in retrospect
11:13:51 <L8D> darkPassenger: nothing aligns
11:14:02 <trillioneyes> L8D: if you ARE using tabs, then yeah, you probably should not be
11:14:07 <trillioneyes> Tabs are like... 8 spaces I think?
11:14:12 <trillioneyes> As far as haskell is concerned
11:14:16 <trillioneyes> Or something outlandish like that
11:14:17 <haasn> tabstops are located every 8 spaces
11:14:20 <haasn> tab takes you to the next tabstop
11:14:33 <haasn> \t is not necessarily always exactly 8 spaces
11:14:37 <L8D> trillioneyes: also many editors have different number of spaces to represent things
11:14:55 <trillioneyes> L8D: yeah
11:14:56 <darkPassenger> L8D: allright !
11:14:57 <L8D> trillioneyes: So...Everything is mis-aligned
11:15:05 <L8D> miss*
11:15:42 <L8D> darkPassenger: also, try shortening down your variable names
11:15:51 <L8D> to single or double characters
11:16:11 <L8D> to make the distinction between other functions and the variables you're working with
11:16:19 <L8D> It's just a haskell convention
11:17:27 <L8D> darkPassenger: Also using global variables named like 'max' (unless you're in a module namespace) can be really confusing
11:17:39 <L8D> use something like maxScore or maxEnemyCount
11:17:55 <Xenasis> Eduard_Munteanu: that Benjamin C. Pierce guy was the same guy who wrote Software Foundations
11:17:57 <Xenasis> O.O
11:18:08 <Xenasis> (one of them, at least)
11:18:27 <Eduard_Munteanu> Also (AT)TAPL.
11:19:34 <L8D> darkPassenger: look at this: http://lpaste.net/99657
11:19:46 <Xenasis> Shame the Category book isn't free like Software Foundations...
11:19:51 <Xenasis> are there any decent free alternatives?
11:20:23 <Xenasis> (that you know of)
11:20:24 <Eduard_Munteanu> Xenasis: Awodey's is probably better for CT
11:20:45 <Eduard_Munteanu> @where awodey
11:20:45 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
11:20:53 <Xenasis> 404
11:21:02 <Xenasis> but I'll google, thanks
11:21:22 <Xenasis> http://carlossicoli.free.fr/A/Awodey_S.-Category_theory-Oxford_University_Press,_USA(2010).pdf
11:21:25 <Eduard_Munteanu> Xenasis: there might be a free version around, at least the first edition
11:21:26 <Xenasis> this seems right
11:22:38 <L8D> darkPassenger: Also, for readability, functions like elem are generally written as operators like x `elem` xs
11:22:41 <etrepum> If I'm developing with Cabal, is there a reasonable way to specify that I need some package from a git repository that isn't on hackage?
11:22:43 <Eduard_Munteanu> Xenasis: it's a bit of a long way to monads though, and not particularly enlightening wrt their use in programming languages. But knowing a bit about categories, functors and natural transformations might help.
11:23:05 <Xenasis> Thanks anyway - I think I'll give it a bit of a read and see how it goes
11:23:24 <etrepum> basically, I need to fork and fix a dependency, but I don't want to publicly fork it nor do I want to wait for the maintainer to release a new version
11:23:39 <merijn> etrepum: You can just install a fixed version locally?
11:23:57 <etrepum> merijn: I want it to be easily reproducible
11:24:09 <merijn> etrepum: Then no
11:24:10 <Eduard_Munteanu> Xenasis: you might want to get an overview first... https://en.wikipedia.org/wiki/Monad_(functional_programming)  (also the article on the CT notion of monads)
11:24:24 <AlainODea> etrepum: cabal sandbox.  Gimme a sec.  I'll get an example
11:24:34 <merijn> AlainODea: How does that help?
11:24:45 <Xenasis> alright, thanks
11:25:13 <merijn> AlainODea: He's saying he wants to depend on a non-existent version of the package, without releasing a fork himself
11:25:19 <etrepum> I'm using cabal sandbox, but I want "cabal sandbox init; cabal install" to do the right thing from a fresh checkout
11:25:22 <merijn> AlainODea: I don't see how sandboxes avoid that
11:25:41 <etrepum> I could use a Makefile or something to set up the sandbox and install the fork to it, but that's not ideal
11:25:58 <AlainODea> etrepum: I do this to build AMQP against unreleased connection. https://gist.github.com/AlainODea/7852276
11:26:20 <mirpa> etrepum: you might include source code of that package into sandbox and distribute it with your package - but I am not aware that you can specify git dep. as in golang for example
11:26:46 <Eduard_Munteanu> Makefiles are a bit annoying to use with whole directories.
11:26:52 <AlainODea> merjn: not possible directly with a Cabal file, but definitely with a script or makefile wrapper
11:26:58 <tdammers> Makefiles are a bit annoying, period.
11:27:09 <tdammers> but then, all build systems are.
11:27:12 <etrepum> AlainODea: thanks
11:27:23 <benmachine> all life is suffering
11:27:25 <mirpa> tdammers: have you heard about Redo?
11:27:47 <AlainODea> etrepum: my pleasure.  Caveat Emptor: it won't be releasable to Hackage :)
11:27:47 * benmachine composes angsty build-system poetry
11:28:06 <etrepum> AlainODea: I don't really care about that, it's really just a tool for me
11:28:33 <tdammers> mirpa: nope
11:28:35 <etrepum> AlainODea: but if I want to use it again in 6 months, I want to remember how to make it work :)
11:28:54 <AlainODea> etrepum: just as in my case :)
11:33:14 <Noldorin> why can't i do something like this in Haskell? 4 * (a + 1 where a = 9) + 2
11:33:49 <milfjord> because 'where' is for declarations, not expressions
11:33:50 <haasn> using “where” to introduce local names like that is only valid after declarations
11:34:01 <haasn> Noldorin: consider using 4 * (let a = 9 in a + 1) + 2
11:34:03 <hakujin> let is an expression
11:34:07 <hakujin> ^
11:34:13 <tdammers> > 4 * (let a = 9 in a + 1) + 2 -- this should work
11:34:15 <lambdabot>  42
11:34:15 <Eduard_Munteanu> Hah... I thought he meant something eval-like.
11:34:25 <tdammers> nm
11:34:54 <Noldorin> milfjord, haasn, hakujin, but I mean, why didn't the language designers allow for this? any good reason?
11:34:56 <milfjord> > 4 * (let b = a where a = 9 in b + 1) + 2
11:34:57 <lambdabot>  42
11:35:11 <L8D> @pl ("[" ++) . (++ "]"_
11:35:11 <lambdabot> (line 1, column 14):
11:35:12 <lambdabot> unexpected '+'
11:35:12 <lambdabot> expecting expression
11:35:13 <L8D> @pl ("[" ++) . (++ "]")
11:35:14 <lambdabot> ('[' :) . (++ "]")
11:35:24 <haasn> Noldorin: perhaps just that the scoping isn't entirely clear
11:35:32 <CaptainK> is there a good standarrd to follow for naming conventions that make the code more readable...point free
11:35:33 <hakujin> Noldorin: let and where serve different purposes, especially around things like guards. LYAH has a section on this exact question.
11:35:49 <Noldorin> hakujin, it has a section, but fails to explain why where can't be used in this situation
11:35:59 <Peaker> "where" is allowed after binding forms, not just after "declarations"
11:36:02 <Noldorin> haasn, hmm maybe. but it seems clear enough to me
11:36:09 <Peaker> for example, each alternative in a "case" can have its own "where"
11:36:10 <Eduard_Munteanu> Noldorin: 'where' is handy when you want a definition to apply to multiple clauses, e.g. pattern guards
11:36:30 <Noldorin> it just seems conceptually nicer to write it with a where clause
11:36:33 <Peaker> I always use "where" and only use "let" in do blocks when I depend on a <- bound name
11:36:47 <mirpa> CaptainK: look around Prelude and standard libraries
11:37:08 <Noldorin> hmm
11:37:23 <CaptainK> mirpa: how do you mean?
11:37:27 <haasn> Peaker: oh, good points
11:37:37 <CaptainK> to watch out for reserved words?
11:37:49 <Peaker> hmm.. I guess a lambda is a binding form and does not allow a "where", which breaks the universality which would allow always using "where". But I tend to name my lambdas usually
11:37:50 <Noldorin> Peaker, example...?
11:37:59 <Peaker> Noldorin: of "let" depending on <- ?
11:38:05 <Noldorin> Peaker, yeah
11:38:12 <Noldorin> ideally i'd like to use where everywhere too
11:38:12 <Eduard_Munteanu> I sometimes use   toplevelDef = let foo = ... in do { some-do-block-here }
11:38:13 <mirpa> CaptainK: look what is used in standard libraries - you should pick up thing or two
11:38:19 <CaptainK> can you have \where?
11:38:33 <Peaker> Noldorin: main = do { line <- getLine ; let foo = concat $ replicate 20 line ; putStrLn (foo ++ " : " ++ foo) }
11:38:44 <Noldorin> ah right
11:38:51 <Noldorin> got it
11:38:55 <Noldorin> thanks
11:39:01 <Peaker> Eduard_Munteanu: can move the "let" into the "do" and save the "in" and a nesting level
11:39:05 <milfjord> you've got the braces in the wrong spot :-(
11:39:52 <Eduard_Munteanu> Peaker: well, you can have something between 'in' and 'do', my example wasn't particularly enlightening
11:40:48 <Eduard_Munteanu> I think you can't do   foo = bar . baz where baz = do\n\t...
11:41:17 <haasn> would it be okay to define a strict language as a language in which f _|_ = _|_ for all f? The only corner case I can think of is in the case of f = \x y -> (); in which case since ‘f’ is not “fully-applied” it might be plausible for the result of this to be \y -> ⊥
11:41:58 <Eduard_Munteanu> haasn: you might want shortcut evaluation for things like &&
11:41:58 <Peaker> Eduard_Munteanu: a definition in a "let" in a "do" can have its own "where"
11:42:22 <dwcook> haasn, I'm not sure that's a reasonable exception. i.e., I think in a strict version of Haskell you'd get argument evaluation at the place of application
11:42:37 <Eduard_Munteanu> Yeah, but I prefer cramming it on the declaration line if it's small enough, instead of adding an indentation level.
11:43:01 <Peaker> you could have unlifted functions and products, so functions/products simply don't have _|_ and there's no "seq" to detect it
11:43:54 <Peaker> or a total language
11:44:12 <akurilin2> Quick question: should I expect a new .cabal file to be generated for me when I do cabal sandbox init on the latest mainline version?
11:44:21 <akurilin2> I'm sad, I didn't get one apparently.
11:44:41 <haasn> dwcook: yeah, hence me asking
11:44:47 <haasn> dwcook: I think I'm satisfied with the definition
11:45:23 <hakujin> akurilin2: nope. sandbox init generates the sandbox only. cabal init is what you want.
11:45:32 <hakujin> (after sandbox init)
11:45:40 <Eduard_Munteanu> haasn: also, const () _|_ should be () even in a strict language for some class of _|_
11:46:04 <haasn> Eduard_Munteanu: what do you mean?
11:46:12 <CaptainK> where are the libraries stored?
11:46:21 <CaptainK> on win32
11:46:38 <CaptainK> haskellplatform/lib ?
11:47:20 <Eduard_Munteanu> haasn: consider   const () (fromJust Nothing) where fromJust (Just x) = x   , should you error out as soon as you evaluate fromJust if the result is irrelevant?
11:47:35 <milfjord> Eduard_Munteanu: yes
11:47:59 <dwcook> Eduard_Munteanu, if we're just taking Haskell and making evaluation strict, absolutely.
11:48:03 <Eduard_Munteanu> Well, quite a few languages don't do that, at least in some cases.
11:48:09 <milfjord> I don't know any
11:48:12 <milfjord> except haskell
11:48:51 <Eduard_Munteanu> milfjord: this C snippet: 0 && abort()  :)
11:49:02 <mirpa> CaptainK: try searching for something like ghc/html/libraries/index.html (I am on Linux)
11:49:22 <milfjord> Eduard_Munteanu: doesn't use const
11:50:15 * hackagebot c-dsl 0.1.0.0 - A higher level DSL on top of language-c  http://hackage.haskell.org/package/c-dsl-0.1.0.0 (jozefg)
11:50:15 <Eduard_Munteanu> Well, true, an actual   f(..., abort(), ...)   would fail.
11:50:23 <Eduard_Munteanu> At least for normal functions.
11:52:09 <Eduard_Munteanu> But if you're thinking about pointers and other stuff in popular languages, I'm think you have to bend things into what it means to be undefined and defined.
11:52:19 <Eduard_Munteanu> s/I'm/I/
11:52:33 <CaptainK> ok, I think I get the drift...inside HaskellPlatform/doc/html/libraries you can see the different module names...follow that style and reserved words right?
11:53:42 <akurilin2> hakujin: aah ok thank you.
11:54:10 <mirpa> CaptainK: you should look for html doc generated by haddock from which you can browse libs documentation and possibly source code
11:54:50 <CaptainK> yeah found the index.htnl
11:54:58 <CaptainK> htm*l
11:55:11 <CaptainK> that one?
11:56:20 <haasn> Eduard_Munteanu: I'm pretty sure that's what I'd consider to be a strict language, yes
11:56:29 <jophish_> Out of curiosity: Why can I declare: foo = id :: a
11:56:46 <jophish_> why can't the type variable 'a' stand in for the type (b->b)
11:56:57 <dwcook> jophish_, you can't
11:57:02 <jophish_> (in this situation)
11:57:11 <jophish_> can't*
11:57:17 <dwcook> jophish_, did you mean "why can't you"? Because a is too general a type for id
11:57:19 <haasn> Eduard_Munteanu: for the record I consider && not to be an example of an ‘f’ in this context since it's more like a special syntactical construct for control flow (like if/else)
11:57:22 <Eduard_Munteanu> jophish_: b -> b is a specialization of a
11:57:59 <CaptainK> how do I import ClockTime ?
11:58:03 <Eduard_Munteanu> haasn: yeah, things like C have pretty awful semantics
11:58:05 <CaptainK> or Time
11:58:11 <dwcook> The most general type of id is a -> a. You can only specialize that type, you're not allowed to generalize it or the type system would be useless.
11:58:44 <dwcook> Imagine if you could convert id to be of any type a. Then every type would be inhabited by id, as well as anything else you'd converted.
11:59:03 <dwcook> Then you could use these values that wouldn't necessarily make sense as being of certain types.
11:59:28 <jophish_> I see
11:59:31 <jophish_> Super, thanks all
11:59:52 <CaptainK> This link is a great example of what I was looking for: http://urchin.earth.li/~ian/style/haskell.html
12:01:01 <dwcook> jophish_, however, if something expects a value of type a (a value of any type), you can supply id, since its type b -> b indeed can be substituted for a.
12:01:12 <dwcook> @type id id
12:01:14 <lambdabot> a -> a
12:01:23 <dwcook> @type id `asAppliedTo` id
12:01:24 <lambdabot> (a -> a) -> a -> a
12:03:57 <magicman> @type asAppliedTo
12:04:00 <lambdabot> (a -> b) -> a -> a -> b
12:04:48 <magicman> Ah. Type-restricted const. Of course.
12:04:58 <magicman> Cool trick.
12:20:38 <jophish_> What vocabulary can distinguish between 'a' in 'a -> a' and 'Int' in 'Int -> Int'. Am I correct in thinking that both 'a' and 'Int' are monotypes
12:21:11 <Eduard_Munteanu> jophish_: 'a' is a type variable, and the whole type is polymorphic
12:21:23 <Eduard_Munteanu> Polymorphic in 'a' if you like.
12:21:32 <dwcook> jophish_, a type signature lacking type variables is called monomorphic.
12:21:53 <jophish_> Eduard_Munteanu: as a little context. I'm trying to implement a Hindley-Milner type checke
12:21:57 <jophish_> oops
12:22:28 <skypers> hm
12:22:39 <skypers> hGetLine has a \r at the end of each line
12:22:40 <jophish_> *checker, and need to distinguish between 'a' and 'Int'. Is it the case that 'a' is a free type variable
12:22:43 <skypers> how could I remove that?
12:22:58 <dwcook> jophish_, it's not free but rather bound by an implicit forall
12:23:05 <dwcook> a -> a is in fact forall a. a -> a
12:23:10 <Eduard_Munteanu> skypers: you probably need to set the encoding on the Handle properly, or avoid opening it as a binary file on platforms like Windows
12:23:25 <jophish_> my Type data type looks like this at the moment: data Type = TyFun Type Type | TyVar String
12:23:39 <skypers> Eduard_Munteanu: it’s from a socket
12:23:48 <jophish_> I think that I should be distinguishing here between things like Float and a
12:24:11 <Eduard_Munteanu> skypers: shouldn't matter, decoding is an application thing
12:24:23 <jophish_> for example, when I get the free type variables in a type, I shouldn't be returning things like "Float" or "int"
12:24:44 <Eduard_Munteanu> skypers: you could also use 'decode' somewhere from Data.Text IIRC
12:24:50 <milfjord> jophish_: Int isn't a variable
12:24:55 <jophish_> milfjord: exactly
12:24:58 <jophish_> what is it?
12:25:04 <milfjord> a constant
12:25:08 <jophish_> as in, what would be a good name for that constructor
12:25:16 <Eduard_Munteanu> jophish_: a concrete type
12:25:30 <Eduard_Munteanu> Int is a (0-ary) type constructor.
12:25:41 <jophish_> this is going to be fun
12:25:59 <Eduard_Munteanu> Often you read that as 'nullary'.
12:26:10 <jophish_> Eduard_Munteanu: super, thanks again
12:26:14 <skypers> Eduard_Munteanu: I don’t really get it, but ok
12:26:33 <Eduard_Munteanu> skypers: how are you reading stuff from it?
12:26:47 <jophish_> Eduard_Munteanu: isn't it possible to have type constructers which are also type variables though?
12:26:48 <skypers> writing and reading to, yes
12:27:04 <jophish_> is Int a 0-ary concrete type constructor
12:27:21 <Eduard_Munteanu> skypers: hGetLine expects a Handle. You can use hSetEncoding on it.
12:27:34 <skypers> yes, and I set it to what?
12:28:06 <Cale> jophish_: Yeah, if you want to call it that, that's fine.
12:28:07 <skypers> I guess I just want UTF-8, it should already be UTF-8 I guess
12:28:32 <Eduard_Munteanu> jophish_: a type is generally one of: (1) a type variable, (2) a type constructor, (3) an application of a type constructor and another type
12:28:54 <Eduard_Munteanu> skypers: are you on Windows?
12:28:55 <L8D> > (\(x:) -> x + 1) (0:)
12:28:56 <skypers> linux
12:28:58 <lambdabot>  <hint>:1:4: Parse error in pattern: x :
12:29:01 <L8D> :(
12:29:11 <jophish_> Eduard_Munteanu: I should be handling -> as a 2-ary constant constructor then, and not as any special case
12:29:17 <Cale> jophish_: Things at the type level are classified by kinds. Int has kind * (as do all the types which have values at present (well, there's unboxed types, but let's ignore those))
12:29:27 <Eduard_Munteanu> jophish_: you could handle it separately
12:29:29 <Cale> jophish_: and then for instance Maybe has kind * -> *
12:29:43 <Cale> as does IO and any other Functor or Monad
12:30:16 <Cale> and then for instance Either has kind * -> * -> *
12:30:36 <skypers> ok, connectTo returns a Handle with no attached encoding
12:30:38 <Cale> Monad transformers tend to have kinds which look like (* -> *) -> * or some variant of that.
12:30:43 <Eduard_Munteanu> skypers: look at hSetNewlineMode
12:30:51 <Cale> (often with one or two additional type parameters)
12:30:52 <Eduard_Munteanu> Or that.
12:31:06 <jophish_> Cale: this all makes a lot of sense
12:31:06 <dwcook> @kind ReaderT
12:31:07 <lambdabot> * -> (* -> *) -> * -> *
12:31:22 <Cale> oh, sorry, yes
12:31:24 <dwcook> Cale, you mean (* -> *) -> * -> *?
12:31:30 <Cale> (* -> *) -> (* -> *), yes
12:31:37 <Eduard_Munteanu> @kind LensLike
12:31:38 <lambdabot>     Type synonym `LensLike' should have 5 arguments, but has been given none
12:31:39 <lambdabot>     In a type in a GHCi command: LensLike
12:31:44 <Eduard_Munteanu> Bleh. :)
12:31:44 <Cale> because you're taking a monad and producing another :)
12:31:50 <jophish_> exactly
12:32:50 <jophish_> as a bit of an esoteric question: Kinds look a lot like a type system for types themselves. Does this continue upwards forever, is there a type system for kinds?
12:33:07 <milfjord> yes, of sorts
12:33:16 <Twey> *groan*
12:33:27 <dwcook> >_<
12:33:30 <skypers> 21:26 < Eduard_Munteanu> skypers: look at hSetNewlineMode
12:33:31 <skypers> huh
12:33:32 <Cale> For something which *does* have kind (* -> *) -> *, you could look at something like  data GenTree f = Branch (f (GenTree f a))
12:33:39 <Cale> oops
12:33:45 <Cale> data GenTree f = Branch (f (GenTree f))
12:33:52 <Eduard_Munteanu> skypers: you might need http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text-Encoding.html because if it's a binary handle it will ignore encoding stuff altogether
12:33:53 <haasn> Fix!
12:34:20 <skypers> Eduard_Munteanu: it’s not a binary handle
12:34:25 <skypers> it’s plain text
12:34:44 <skypers> I guess I can just drop all \r\n in each line?
12:34:59 <Cale> jophish_: There is now, Haskell 98 didn't define sorts, because its kind system was so simple, but in recent GHCs, the kind system has started to become a bit more elaborate, warranting that there be "sorts" to classify the things at the kind level.
12:34:59 <Eduard_Munteanu> skypers: how do you know?
12:35:11 <Eduard_Munteanu> jophish_: yes, Agda and Coq have an infinite hierarchy of * equivalents
12:35:20 <Twey> New GHC has sorts?
12:35:23 * hackagebot monad-resumption 0.1.1.0 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.1.0 (IanGraves)
12:35:24 <Cale> jophish_: Some languages like Omega elaborate this into an infinite hierarchy.
12:35:43 <Eduard_Munteanu> Twey: formally... for polymorphic kinds and stuff
12:35:50 <Eduard_Munteanu> Basically only BOX, IIRC.
12:35:58 <jophish_> Cale: well, I'm implementing something like Haskell98, So I'll probably stick with Kinds
12:36:01 <Cale> jophish_: and dependently typed languages basically collapse it by allowing types to be classified by other types
12:36:11 <Twey> Eduard_Munteanu: Oh, right
12:36:25 <Cale> (typically)
12:37:16 <Eduard_Munteanu> skypers: whatever sockets library you're using sets the encoding, which is a property of the Handle, not of the data you transfer over it
12:38:10 <Cale> What most dependently typed languages do is they have an infinite hierarchy of universes, something like  Type 0  which is the type of all the ordinary basic types, and then  Type n :: Type (n+1)
12:38:22 <skypers> Eduard_Munteanu: ok
12:38:52 <dwcook> Cale, why not just Type :: Type? (I've briefly read mention of why not but don't know the specifics)
12:38:54 <skypers> I don’t understand
12:38:56 <skypers> if I do
12:38:59 <Eduard_Munteanu> skypers: likely it's a binary handle because that suits all purposes if you decode/encode manually
12:39:03 <skypers> getLine >>= print
12:39:08 <skypers> there’s no extra \r
12:39:16 <skypers> the server sends me extra \r at each end of line
12:39:18 <skypers> this is boring
12:39:24 <Cale> Type :: Type is okay if you're only interested in having a programming language, and you're going to admit general recursion (fix, etc)
12:39:40 <Cale> But it spoils the dependently typed language as a proof assistant
12:39:52 <Cale> (you can prove a contradiction using it)
12:40:00 <jophish_> Well, I understand this all a little better. Thank you Cale, Eduard_Munteanu, dwcook
12:41:04 <DMcGill> I'm looking for a lens operator that may or may not set something. I.e. like "maybeSet lens mX = maybe id (lens .~)" i.e. if there is a Just then it acts like a normal setter and if there is Nothing then it's just id
12:41:36 <DMcGill> "maybeSet lens mX = maybe id (lens .~) mX" even
12:41:37 <Eduard_Munteanu> skypers: sounds like the server is sending cr+lf terminated lines to you.
12:41:47 <edwardk> > _Just %~ (+1) $ Nothing
12:41:51 <lambdabot>  Nothing
12:41:56 <edwardk> > _Just %~ (+1) $ Just 12
12:41:58 <lambdabot>  Just 13
12:42:01 <skypers> Eduard_Munteanu: yeah, so I can just drop them?
12:42:04 <DMcGill> great thanks
12:42:33 <Cale> Wait... that's just fmap isn't it?
12:42:34 <edwardk> > Just 4 & _Just +~1  -- is probably more idiomatic
12:42:37 <lambdabot>  Just 5
12:42:44 <Cale> ugh
12:42:52 <Eduard_Munteanu> skypers: is the server under your control or written by you as well?
12:42:54 <edwardk> Cale: and yes ;)
12:43:06 <Cale> Why would you not just write fmap?
12:43:10 <edwardk> well it is (<$) anyways
12:43:16 <dwcook> skypers, do you know about http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#v:hSetNewlineMode ?
12:43:25 <Eduard_Munteanu> skypers: the right thing to do is figure out the protocol details... is it a home cooked protocol, or something known?
12:43:41 <edwardk> :t \l -> maybe id (l .~)
12:43:43 <lambdabot> ASetter a1 a1 a2 a -> Maybe a -> a1 -> a1
12:43:43 <skypers> dwcook: nope
12:43:49 <skypers> Eduard_Munteanu: no
12:43:53 <skypers> it’s actually freenode ;)
12:44:10 <skypers> the protocole is just IRC
12:44:15 <Cale> hmmm
12:44:20 <skypers> protocol*
12:44:30 <haasn> > Just (T.pack "Hello, Cale!") & _Just.text.from enum +~ 1
12:44:32 <lambdabot>  Not in scope: `T.pack'
12:44:32 <lambdabot>  Perhaps you meant `BS.pack' (imported from Data.ByteString)
12:44:47 <haasn> No T.pack ?!
12:45:02 <edwardk> :t maybe id (set both)
12:45:04 <lambdabot> Maybe a -> (a, a) -> (a, a)
12:45:08 <Eduard_Munteanu> skypers: "IRC messages are always lines of characters terminated with a CR-LF" from the RFC
12:45:27 <edwardk> > maybe id (set both) (Just 2) (3,4)
12:45:29 <lambdabot>  (2,2)
12:45:35 <edwardk> > maybe id (set both) Nothing (3,4)
12:45:36 <lambdabot>  (3,4)
12:45:49 <Cale> Right
12:46:04 <dwcook> skypers, sounds like you're after NewlineMode CRLF CRLF
12:46:08 <Eduard_Munteanu> skypers: if you're planning on using String or Text, use hSetNewlineMode to tell it to use CRLF
12:47:05 <Eduard_Munteanu> skypers: actually you probably should use ByteString for the protocol bits
12:47:21 <Eduard_Munteanu> And decode/encode it to Text to/from the user.
12:47:36 <frx> Eduard_Munteanu there are popular clients that do not care what IRC RFC says about message endings (like mirc)
12:48:02 <Eduard_Munteanu> Because you probably want to handle internal CRLF occurences.
12:48:52 <Eduard_Munteanu> frx: all the more reason to use ByteString and make the decoding explicit :)
12:50:21 <levi> The IRC RFCs are next to useless, unfortunately. And I would recommend using ByteString on the protocol bits as well.
12:51:09 <Eduard_Munteanu> Do popular FOSS clients obey them?
12:51:34 <Eduard_Munteanu> I'd say you can just drop malformed messages, who cares about mIRC anyway. :)
12:51:39 <levi> No client can obey them strictly, because no server obeys them strictly.
12:51:55 <milfjord> I found the IRC RFC perfectly fine for writing a client
12:51:57 <Eduard_Munteanu> Well, no, not strictly, just using it as a reference.
12:52:24 <Eduard_Munteanu> Sure, even Freenode extends it by stuff like SASL auth.
12:52:40 <levi> They make a reasonable starting point, sure.
13:00:24 <Earnestly> frx: Show me one IRC client that ignores the RFC
13:00:27 <levi> The RFCs are much more useful on the client side than the server side, I've found. (I'm writing an IRC server)
13:00:40 <levi> Earnestly: What do you mean by 'the RFC' for IRC?
13:00:50 <Earnestly> levi: The RFC, for IRC.
13:00:58 <levi> Earnestly: And which RFC is that?
13:01:22 <milfjord> 1459
13:01:36 <levi> That's one of them.
13:02:20 <benmachine> levi: it sounds like you are asking questions to which you know the answer, why are you doing that?
13:02:33 <Earnestly> levi: Obviously 1459 and the extensions
13:02:41 <monochrom> aw, RFCs are not next to useless, please don't exaggerate
13:02:44 <Earnestly> levi: Being 2810-2813
13:02:53 <Earnestly> Everything that matters is based on an RFC
13:02:58 <Earnestly> Basically everything
13:03:18 <levi> Earnestly: The relationship between 1459 and 2810-2813 is not quite that simple, though.
13:03:19 <Earnestly> From email, to tcp, to carrier pidgeons
13:03:21 <jophish_> Does Haskell98 allow variable type constructors in types?
13:03:41 <monochrom> there is a long distance between "not completely complied" and "next to useless"
13:03:41 <Earnestly> levi: So, are you chipping in for frx, can you find one client that doesn't comply to the RFC?
13:03:46 <benmachine> jophish_: do you mean, types like "f a"?
13:03:54 <benmachine> jophish_: you can't really have monads without those, so yes :)
13:03:59 <benmachine> well
13:04:03 <benmachine> no that's not fair
13:04:05 <benmachine> but yes anyway
13:04:10 <frx> I agree. your client/server should follow RFC, and also add support for crappy clients/servers that dont
13:04:18 <Earnestly> levi: Because 1459 is still *the* correct RFC
13:04:23 <jophish_> benmachine: of course, I don't know what I was thinking asking that
13:04:28 <Earnestly> There are no "alternative" rfcs for irc
13:04:41 <Earnestly> frx: servers should follow IRCv3
13:04:47 <jophish_> thanks
13:04:56 <levi> Earnestly: Have you read them all?
13:05:12 <Earnestly> It's what most do, like freenode's charybdis
13:05:26 * hackagebot regex-pcre-builtin 0.94.4.6.8.32 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.6.8.32 (AudreyTang)
13:05:34 <Earnestly> levi: Mostly?
13:05:51 <levi> IRC is, actually, an implementation-defined protocol. The RFCs attempted to capture and standardize the server behavior, but were not entirely successful.
13:06:12 <Earnestly> show me one
13:06:17 <Earnestly> That doesn't
13:06:33 <levi> Earnestly: No.
13:06:50 <FireFly> IRCv3 isn't an RFC, is it?
13:07:06 <levi> FireFly: No, it's an implementation.
13:07:11 <FireFly> but um, this should probably be in -blah
13:07:14 <Earnestly> FireFly: Nah, it's an atheme project
13:07:23 <FireFly> I thought it was an extension
13:07:28 <FireFly> but still, -blah
13:07:31 <monochrom> yeah, this "debate" is going nowhere
13:07:39 <Earnestly> levi: It's not an implementation ._. sigh
13:07:55 <levi> I'm finished talking about IRC.
13:08:27 <Earnestly> You are very confused, but as others have pointed out this is not going anywhere, take care.
13:08:30 <benmachine> good grief, there's a lot of snark in this room
13:08:45 <dfmr> benmachine: it has high variance
13:09:04 <benmachine> dfmr: well, mostly I'm just oversensitive because I'm used to it being so unsnarky
13:09:25 <dfmr> benmachine: yeah; it used to be less snarky, and sometimes still is
13:09:51 <benmachine> dfmr: that sometimes could totally be an often
13:10:04 <benmachine> things needn't always get worse over time :P
13:10:07 <dfmr> hopefully; I'm not here that regularly
13:10:34 <osfameron> it's also the weekend -- during the week there are more people just talking politely about haskell
13:10:42 <dfmr> ah
13:11:02 <osfameron> well, during US/EU office-hours at least, I guess
13:12:32 <levi> I apologize for any snarkiness on my part.
13:16:53 <burbul> :t \((l:ls):cs) -> (l:ls'):cs' where (ls':cs') = copyable_from (ls:cs)
13:16:54 <lambdabot> parse error on input `where'
13:17:22 <burbul> :t \((l:ls):cs) -> let (ls':cs') = copyable_from (ls:cs) in (l:ls'):cs'
13:17:23 <lambdabot> Not in scope: `copyable_from'
13:17:35 <burbul> :t \((l:ls):cs) -> let (ls':cs') = f (ls:cs) in (l:ls'):cs'
13:17:36 <lambdabot> (Show a, FromExpr [[a]]) => [[a]] -> [[a]]
13:17:48 <dwcook> burbul, where is part of binding syntax. e.g., f = x where x = 10
13:18:19 <milfjord> :t \((l:ls):cs) -> let (ls':cs') = ?copyable_from (ls:cs) in (l:ls'):cs'
13:18:20 <lambdabot> (?copyable_from::[[a]] -> [[a]]) => [[a]] -> [[a]]
13:18:25 <burbul> i see -- thanks
13:19:02 <burbul> I was trying to find a more pointfree way of writing the function I just set out
13:19:11 <burbul> @pl \((l:ls):cs) -> let (ls':cs') = f (ls:cs) in (l:ls'):cs'
13:19:11 <lambdabot> (line 1, column 21):
13:19:11 <lambdabot> unexpected "("
13:19:11 <lambdabot> expecting "()", natural, identifier or "in"
13:19:57 <jle`> burbul: /q lambdabot
13:20:08 <dwcook> The syntax of @pl doesn't match up perfectly with Haskell's, it seems
13:20:48 <syllogismos> oh we can put ? to get the type of that specifically?
13:21:02 <milfjord> :t ?f ?x
13:21:03 <lambdabot> (?f::t -> t1, ?x::t) => t1
13:21:03 <joeyh> huh. In System.FilePath.Windows, isRelative "/foo" == True, but "C:\\BAR" </> "/foo" == "/foo"
13:22:25 <burbul> Actually, more specifically, is there any higher-order way of writing this thing?
13:22:29 <burbul> :t \l -> \(ls':cs') -> (l:ls'):cs'
13:22:30 <lambdabot> a -> [[a]] -> [[a]]
13:23:05 <milfjord> this is not total :-|
13:23:30 <burbul> If I wanted to prefix l to the first element of a pair, I could use something like 'first (l:)'
13:23:52 <milfjord> ls':cs' is not a pair
13:23:53 <burbul> It seems that there should be something similar for a list -- but possibly the problem is the lack of totality?
13:23:57 <milfjord> ah
13:24:06 <burbul> It would be fine to just leave the empty list alone
13:24:23 <milfjord> :t \l -> uncurry (:) . first (l :) . splitAt 1
13:24:24 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
13:24:24 <lambdabot>     Expected type: [a0] -> a0
13:24:24 <lambdabot>       Actual type: [a0] -> [a0]
13:24:36 <milfjord> :t \l -> uncurry (++) . first (l :) . splitAt 1
13:24:37 <lambdabot> a -> [a] -> [a]
13:25:02 <milfjord> :t \l -> uncurry (++) . first (map (l :)) . splitAt 1
13:25:05 <lambdabot> a -> [[a]] -> [[a]]
13:25:13 <burbul> If there isn't a standard function in the libraries then that's fine -- I just felt like I must be missing some analogue of 'first'
13:25:20 <burbul> Thanks, though.
13:25:28 <milfjord> there's probably a lens for that
13:25:53 <edwardk> milfjord: t do what?
13:26:33 <milfjord> modify the first element of a list
13:26:35 <edwardk> oh prefix somethig onto the head of the list if its there?
13:26:37 <jle`> i wonder why the semigroups requires text or either requires monadrandom :|
13:26:42 <burbul> edwardk: to apply a function to the first element of the list
13:26:51 <burbul> (Leaving empty lists alone)
13:26:54 <jle`> i did not expect installing either to install so many packages
13:27:19 <monochrom> really? let me take a look on hackage
13:27:22 <burbul> In the same way that 'first' applies a function to the first element of a pair
13:27:24 <edwardk> > ["hello","world"] & _head %~ ('c')
13:27:26 <lambdabot>  Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
13:27:26 <lambdabot>              with actual type `GHC.Types.Char'
13:27:28 <edwardk> > ["hello","world"] & _head %~ ('c':)
13:27:31 <lambdabot>  ["chello","world"]
13:27:41 <edwardk> > [] & _head %~ ('c':)
13:27:42 <lambdabot>  []
13:28:09 <Sagi> can someone give a hint how I can loop getLine and read until I get an Int from the user?
13:28:25 <monochrom> I think it's because semigroups wants to give you an instance for Text, therefore it has to first load up text...
13:28:48 <edwardk> jle`: because orphans are a worse problem
13:28:49 <Sagi> I seem to remember some function which retries until it succeeds, but I cannot find it in either Control.Monad or Control.Exception. I must be going blind :-)
13:28:58 <milfjord> @pl \x l -> l & _head %~ (x :)
13:28:58 <lambdabot> (line 1, column 13):
13:28:59 <lambdabot> unexpected "_"
13:28:59 <lambdabot> expecting space or simple term
13:29:20 <L8D> :t uncurry
13:29:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:29:21 <monochrom> haskell platform gives you text already. it is not a burdening dependency
13:29:22 <jle`> Sagi: you might look in Control.Monad.Loops
13:29:40 <monochrom> monadrandom may be a bit unnecessary
13:29:51 <edwardk> jle`: i can live in a world in which all my packages wrk together and where i can get stuff done, or i can live in a world where i shed a few dependencies. The latter place is a less interesting place for me to live, and nobody is ever satisfied no matter how many dependencies i remove, so i moved here.
13:29:56 <Sagi> jle`: oh sorry, I have looked there too. But those require an explicit condition, right?
13:30:39 <Earnestly> edwardk: (Out of curiosity, I missed the beginning, but where is 'here' and where is 'there'?)
13:30:54 <jle`> edwardk: fair enough
13:31:08 <jle`> t'was just slightly surprising
13:31:10 <monochrom> anyway, when I typed in "hackage.haskell.org", chrome suggestion suggested "hackage.haskell.org down", hehe
13:31:52 <Sagi> oh, I can combine it with readMaybe I guess, thanks jle`
13:32:26 <jle`> Sagi: np. for something this simple though most people just use explicit recursion i think.
13:32:51 <burbul> <edwardk>: thanks! will look up those operators
13:33:03 <edwardk> Earnestly: this being the universe where i have a few more dependencies and avoid orphans, there being where i provide isolated packages that don't integrate well, but which satisfy a pedantic need for not depending on anything more than they require
13:33:39 <Earnestly> edwardk: Ah, I know what you mean.  Yeah
13:33:56 <jle`> Sagi: tryUntilInt = do { i <- readMaybe; case i of Just n -> return n; Nothing -> tryUntilInt }
13:34:17 <L8D> @pl \(x:xs) -> print x >> return xs
13:34:17 <lambdabot> ap ((. return) . (>>) . print . head) tail
13:34:24 <edwardk> Earnestly: i seriously tried to live in the minimalist separate package world. i couldn't use my code together, users couldn't find instances, the net effect was much worse than dealing with a few people complaining about the length of the dependencies ;)
13:34:46 <L8D> :t ap ((. return) . (>>) . print . head) tail
13:34:47 <lambdabot> Show b => [b] -> IO [b]
13:35:05 <Earnestly> edwardk: Yeah, besides, if I use something I would like it to be as comlete as possible so that it might deal with anything I throw at it.
13:35:15 <L8D> @pl \case (0:xs) -> -1:xs; (x:xs) -> 0:xs
13:35:16 <lambdabot> (line 1, column 17):
13:35:16 <lambdabot> unexpected "-"
13:35:16 <lambdabot> expecting lambda abstraction or expression
13:35:16 <Earnestly> complete*
13:35:25 <L8D> @pl \x -> case x of (0:xs) -> -1:xs; (x:xs) -> 0:xs
13:35:25 <lambdabot> (line 1, column 26):
13:35:25 <lambdabot> unexpected '>'
13:35:25 <lambdabot> expecting operator
13:35:48 <monochrom> perhaps @pl is very limited
13:36:20 <edwardk> Earnestly: that is pretty much what i've settled on doing. I expose internals at least off to one side so users don't wind up painted into a corner by unexpected demands, and i provide instances without orphans where possible
13:36:54 <jle`> i keep on forgetting that Earnestly is a nick and i read it as you are specifying that you are saying something in earnest :)
13:37:00 <milfjord> 'case' is unplable
13:37:07 <jle`> which is probably true nonetheless
13:37:08 <edwardk> jle`: =)
13:37:20 <Sagi> jle`: oh, of course. Thanks
13:37:21 <monochrom> I should call myself Obviously
13:37:22 * milfjord is now known as verily
13:37:40 <edwardk> verily it is true, Obviously.
13:38:24 <monochrom> damn, "obviously" is already taken
13:38:46 <milfjord> verily is available
13:38:47 <burbul> Prob. stupid question:  hoogling (%~) and (&) doesn't turn anything up...
13:39:15 <roboguy_> burbul: try this https://www.fpcomplete.com/hoogle
13:39:33 <FYI> yay, just got this nick
13:39:38 <edwardk> On the other hand, if we start talking about taking things in earnest, etc. this is going to get uncomfortable for him real quick.
13:39:42 <roboguy_> burbul: they're in lens by the way
13:39:49 <syllogismos> fpcomplete hoogle has bigger index?
13:39:53 <roboguy_> syllogismos: yep
13:40:09 <adelbertc> what does it include that http://www.haskell.org/hoogle/ msses?
13:40:19 <jle`> FYI: haha
13:40:22 <roboguy_> adelbertc: lens, for one thing
13:40:33 <DMcGill> burbul: also if you know what package it's from you can specify using "(&~) +lens"
13:40:34 <burbul> huh -- thanks. Why does that site index more than haskell.org? (Or equivalently, why does Haskell.org index less?) . I'm trying to figure out which one I should point my Chrome shortcut at...
13:40:40 <edwardk> Oh, it is just FYI
13:40:54 <identity> When running cabal install inside a sandboxes package, will it install it ~/.cabal/bin? Or does it sandbox the installation as well?
13:41:02 <adelbertc> identity - sandboxed
13:41:07 <adelbertc> ~/.cabal_sandbox/bin
13:41:10 <roboguy_> adelbertc: I think the haskell.org hoogle might only index base packages, actually
13:41:13 <edwardk> burbul: hoogle is maintained by a guy who doesn't use lens ;)
13:41:14 <adelbertc> well, not ~/.cabal_sandbox
13:41:20 <adelbertc> but, the .cabal_sandbox dir in the sandbox
13:41:23 <identity> I see.
13:41:24 <roboguy_> and I think the fpcomplete hoogle includes all the stuff that fpcomplete has
13:41:24 <edwardk> burbul: the fpcomplete site is by folks who do ;)
13:41:38 <burbul> thanks
13:42:01 <BMeph> Darn - registered. Should have seen that coming. :)
13:42:14 <syllogismos> when will importing packages in fpcomplete work, like the ones that are not default?
13:42:22 <roboguy_> edwardk: I would think that regardless of whether or not they use it, they would acknowledge that it's pretty important...
13:42:46 <edwardk> roboguy_: feel free to send him an email about it ;)
13:43:08 <roboguy_> edwardk: haha, I don't want to cause too much trouble and the fpcomplete hoogle works for me right now
13:43:14 <edwardk> it is a fairly common 'surprise' point here on channel
13:43:24 <roboguy_> well, that *is* true
13:43:26 <jle`> does neil hang out around here?
13:43:33 <edwardk> ndm used to
13:43:34 <roboguy_> it surprised me
13:44:09 <skypers> hi
13:44:18 <jle`> hi skypers
13:44:19 <skypers> I want to compile my program in static
13:44:26 <skypers> like, libffi.so in static as well
13:44:27 <skypers> and so on
13:44:30 <skypers> is it possible?
13:44:31 <roboguy_> edwardk: hey, one thing I've been wondering... will knowledge of category theory help at all with understanding how the more complex internals of lens work?
13:44:49 <skypers> I want to push my program on a machine that doesn’t anything about haskell
13:44:54 <skypers> +know
13:45:04 <edwardk> well, it'll give you more familiarity with the building blocks
13:45:19 <mzero> libffi isn't really part of Haskell... it is a standard lib on many OS distros
13:45:36 <skypers> really?
13:45:46 <edwardk> lens internaly tries to do the 'right' thing for each combinator to make them work in the most situations, but that makes the implementation pretty complex.
13:45:51 <skypers>  error while loading shared libraries: libffi.so.5: cannot open shared object file: No such file or directory
13:46:05 <roboguy_> edwardk: that's that what I've suspected. can't hurt to learn something new either way, right?
13:46:13 <edwardk> skypers: libffi is a 3rd party lib, we just use it
13:46:27 <skypers> it’s not haskell related?
13:46:29 <skypers> I thought so
13:46:46 <edwardk> roboguy_: Learning category theory was really a pivotal event in my life, so I can hardly argue against it!
13:47:05 <Earnestly> skypers: (Also yes, not related)
13:47:12 <skypers> ok, thank you
13:47:16 <skypers> I might have some issues then
13:47:49 <dfmr> edwardk: how was it pivotal?
13:48:06 <milfjord> have you accepted category theory as your lord and saviour?
13:48:07 <roboguy_> edwardk: it looks very interesting to me. I've made several attempts at learning it, without too much success (although I sort of understand the basics). I just got a book that seems to explain it in pretty basic terms, so I'm going to try starting with that
13:48:11 <mangaba_leitosa> skypers: libffi it's usually available as a separate package, just like glib, gtk or any other library
13:48:51 <edwardk> dfmr: It changed the way I program and approach problems a great deal.
13:49:08 <skypers> yeah, I just wonder why it’s not there
13:49:21 <skypers> it’s a debian
13:49:37 <roboguy_> and now that I know that ##categorytheory exists, maybe I can actually figure it out
13:50:37 <mildfate> I'm looking at an toy parser in a haskell tut and came across this: "symbol :: Parser Char" does this mean that I'm defining symbol to have both types Parser and Char?
13:50:39 <Earnestly> skypers: It's used in a bunch of things from ruby-ffi, to cpython to even dalvik.  If you're on debian I think you could just get `libffi` as the package name.
13:51:01 <geekosaur> mildfate, no
13:51:05 <dwcook> mildfate, no, Parser Char is a single concrete type.
13:51:13 <roboguy_> mildfate: no, it's applying the Parser type constructor to the Char type to make a concrete type
13:51:29 <joseph07> What is a data kind?
13:51:30 <geekosaur> Parser is what you might think of as a type function. you apply it to a type to produce a different type
13:51:34 <edwardk> dfmr: I used to work very much top-down - all architecture and design patterns. Learning enough category theory to be dangerous let me turn around and work bottom up more coherently, identify things by laws it satisfies, using naturality and the free theorems, it let me stop looking for many solutions by giving me the ability to borrow knowledge from other domains that can show me the solution can't exist... changed the way i code
13:51:36 <edwardk>  even simple things like linear algebra
13:51:57 <geekosaur> compare Maybe Char
13:51:58 <mildfate> dwcook: You can define a type as two separate words?
13:52:05 <dfmr> you mean borrowing from linear algebra?
13:52:15 <dwcook> mildfate, Parser is a type constructor. Think of it as a function that takes a type and results in a type.
13:52:17 <roboguy_> mildfate: [Int] is similar. it is the [] type constructor applied to the Int type
13:52:27 <milfjord> mildfate: that's like asking if 'x = sqrt 2' defines x to be both sqrt and 2
13:52:38 <roboguy_> mildfate: In fact, you can write "[Int]" as "[] Int"
13:52:50 <mildfate> oh whoah, ok, I guess I'm diving into this too quickly.  I don't know what a constructor type it
13:52:51 <mildfate> is*
13:53:02 <roboguy_> > [1,2,3] :: [] Int
13:53:03 <lambdabot>  [1,2,3]
13:53:24 <mildfate> > :t (Parser Int)
13:53:26 <lambdabot>  <hint>:1:1: parse error on input `:'
13:53:29 <milfjord> mildfate: [Int] (or [] Int) means "list of int"
13:53:36 <Earnestly> > :k Maybe
13:53:37 <lambdabot>  <hint>:1:1: parse error on input `:'
13:53:37 <edwardk> dfmr: no i really mean i use category theory to motivate the design of my 'linear' package. it exploits two 'coincidences' in the design. one is that representable functors are ones isomorphic to (->) x  for some x, the second is all vector spaces are free vector spaces and so are isomorphic to (x -> r) for some basis x.
13:53:41 <Earnestly> OH :<
13:53:41 <milfjord> Parser Char means "parser of char"
13:53:47 <roboguy_> :k Maybe
13:53:47 <lambdabot> * -> *
13:53:51 <Earnestly> Thank you
13:53:55 <geekosaur> mildfate: for a simpler example, Maybe is a type constructor which takes a type (such as Char) and produces a type which can have the value Nothing or the value Just x for some x which is a Char
13:53:59 <burbul> Also, is there a standard name for this operator?
13:53:59 <burbul> (-||-) = liftM2 (||)
13:54:15 <dwcook> mildfate, well, I basically gave you the gist of what it means. In practice, it means we can create types that are parameterized by other types, so, a list of strings, a list of integers, a list of booleans, etc. are all possible.
13:54:30 <Earnestly> mildfate: So Parser is a type that takes another type to create a concrete type
13:54:45 <Earnestly> :k Parser
13:54:46 <edwardk> dfmr: so in linear i choose to represent vector spaces as representable functors, then exploit this structure to make it so i can make lenses to the fields be the representation of the functor, giving a universal encoding that works for all vector spaces and all bases, avoids naming the members of the basis...
13:54:46 <lambdabot> Not in scope: type constructor or class `Parser'
13:54:51 <dwcook> mildfate, more specific to your example, a Parser Char is a parser that in some sense "results" in a Char when it reads something in.
13:54:56 <roboguy_> burbul: I doubt it, since it's just "liftM2 (||)"
13:54:56 <edwardk> dfmr: it kind of feeds on itself after a while ;)
13:54:58 <Earnestly> *shrug*, you can do it in GHCi
13:55:08 <dfmr> edwardk: I really wish I could understand that :-)
13:55:14 <mildfate> So you could have a chain of a bunch of type constructors, right?
13:55:15 <geekosaur> burbul: xmonad calls it <||> but there's no common name
13:55:35 <burbul> roboguy: writing e.g.
13:55:35 <dwcook> mildfate, you sure could. Take Either for example – It takes two types. e.g., Either String Int
13:55:52 <mildfate> Is string operating on Int
13:55:53 <burbul> all (liftM2 (--) is_shadow_var (==ref)) refs
13:55:57 <geekosaur> Either (Maybe [Int]) Char
13:55:59 <mildfate> or is Either taking both String and Int?
13:55:59 <Earnestly> mildfate: Except you can't combine two type constructors, afaik
13:55:59 <geekosaur> no
13:56:03 <joseph07> :k Either
13:56:04 <burbul> is much more inscrutable than
13:56:04 <lambdabot> * -> * -> *
13:56:07 <burbul> all (is_shadow_var -||- (==ref)) refs
13:56:13 <edwardk> V2 10 20  is a vecto space in linear you have lenses _x and _y that can access its parts. but it is isomorphic to Bool -> Double
13:56:24 <dwcook> mildfate, read it as (Either String) Int. You first apply Either to String, then the result of that to Int.
13:56:29 <milfjord> @src Either
13:56:29 <lambdabot> Source not found. :(
13:56:40 <geekosaur> mildfate: works the same as
13:56:45 <geekosaur> > mod 5 3
13:56:46 <lambdabot>  2
13:56:50 <dwcook> mildfate, if you know how function application works, this may seem familiar.
13:57:00 <FYI> edwardk: i see -fdicts-cheap in some of your packages. there isn't much documentation on it that i can find. what benefit does it provide?
13:57:05 <joseph07> :t (Just (Just 3))
13:57:06 <geekosaur> so is 5 operating on 3 there, or is mod operating on both of them? (the latter)
13:57:06 <lambdabot> Num a => Maybe (Maybe a)
13:57:09 <edwardk> it is also isomorphic to (forall x. Lens' (V2 x) x) -> a)
13:57:27 <mildfate> oh ok, of course.  I guess just the fact of a type constructor is sending me through a loop
13:57:30 <edwardk> FYI: its a holdover from the early bytestring era and can probably be removed
13:57:30 <geekosaur> (note that yu'd normally write that as 5 `mod` 3)
13:57:50 <milfjord> mildfate: do you know any other programming languages?
13:57:54 <mildfate> java
13:57:58 <roboguy_> burbul: I generally prefer applicative notation
13:58:05 <milfjord> mildfate: Parser<T>
13:58:11 <roboguy_> although that can look a bit strange if you're using an operator already. I still like it though
13:58:24 <mildfate> oh it's parametric!!!!
13:58:34 <joseph07> yep type parameter
13:58:36 <roboguy_> > (||) <$> Just True <*> Nothing
13:58:37 <lambdabot>  Nothing
13:58:39 <mildfate> ok, I totally get it now
13:58:51 <geekosaur> unlikely, but you will eventually :p
13:58:58 <syllogismos> lol
13:59:01 <dwcook> mildfate, missed my use of the word "parameterized" earlier? :) That's okay.
13:59:03 <mildfate> well, it's a little more clear in my head at least
13:59:05 <geekosaur> (java types don't work the same way, quite)
13:59:09 <monochrom> well, problem with likening to java is: you can say "Either X Y" is "Either<X,Y>", but now you can't translate "Either X"
13:59:26 <milfjord> doesn't matter at this stage
13:59:30 <mildfate> dwcook: I didn't miss it, just in one ear out the other with no side-effects :P
13:59:36 <dwcook> Fair enough.
13:59:39 <Earnestly> monochrom: Can type constructors be curried?
13:59:55 <milfjord> :t (Either Int) Char
13:59:56 <lambdabot>     Not in scope: data constructor `Either'
13:59:56 <lambdabot>     Perhaps you meant `Other' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
13:59:56 <lambdabot>     Not in scope: data constructor `Int'
13:59:59 <milfjord> :k (Either Int) Char
14:00:00 <monochrom> in which language?
14:00:00 <lambdabot> *
14:00:05 <burbul> Hm. Before you wrote it out I just looked at Control.Applicative and thought you were referring to this:
14:00:06 <FYI> edwardk: why? what purpose did it serve? did it just not pan out as hoped, or has it been superceded by some other optimization?
14:00:18 <burbul> class Applicative f => Alternative f where ... (<|>) :: f a -> f a -> f a
14:00:20 <edwardk> it is folded into -O2 IIRC
14:00:34 <haasn> I really dislike it when people ask questions about currying because I never know what “x is curried” is supposed to mean
14:00:47 <copumpkin> FYI: FYI, your nick is FYI
14:00:53 <monochrom> we say things like "instance Monad (Either String)" all the time, if that is what you're looking for
14:00:57 <edwardk> FYI: http://osdir.com/ml/lang.haskell.cvs.ghc/2006-07/msg00108.html
14:01:06 <FYI> haasn: best i can figure is that it returns a function
14:01:43 <monochrom> or perhaps "instance Functor (Either String)" is a better example
14:01:46 <roboguy_> burbul: nope, Alternative is a bit different
14:01:47 <burbul> haasn:
14:01:50 <FYI> copumpkin: ah! i was unaware. thank you.
14:01:50 <joseph07> haasn: I think they mean "partially applied"
14:02:02 <burbul> (a,b) -> c is uncurried
14:02:10 <haasn> applying a type constructor like ‘Either’ to a type like Int, does indeed return another type constructor
14:02:12 <burbul> a -> b -> c, meaning a -> (b -> c)
14:02:15 <burbul> is curried
14:03:03 <roboguy_> burbul: Applicative is a bit underrated in my opinion
14:03:05 <FYI> burbul: i think haasn understands what currying is but is making some complaint about sloppy use of vocabulary?
14:03:15 <burbul> o i see -- sorry
14:03:31 <FYI> well, i don't know for sure, see :)
14:03:33 <syb0rg> Is dons not here?
14:04:03 <FYI> syb0rg: dons has been locked in a basement, only occasionally allowed outside to take photos of clouds to post on twitter
14:04:21 <haasn> burbul: but what about when ‘c’ here is itself a function? is (a,b -> d) -> (b -> d) supposed to be curried or not?
14:05:10 <syb0rg> So has he not been seen recently?
14:05:15 <edwardk> dons disappeared into a building in Singapore and hasn't been seen in years, other than a brief hostage video taken by ReinH, and the occasional plaintive sunset tweets he uses to smuggle out information about his plight steganographically.
14:05:22 <dwcook> Currying is an action you can take on a function. "Curried" is a state with a questionable meaning.
14:05:34 <ReinH> heh
14:05:35 <dwcook> @type curry
14:05:36 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:05:39 <burbul> oh, i see
14:05:54 <burbul> sorry, I thought you meant somethign much more basic
14:05:55 <copumpkin> curried chicken
14:06:02 <haasn> edwardk: he's photographing the sky to give us hints as to his location, based on the timestamp
14:06:04 <edwardk> At least, we think the man in the video was dons.
14:06:06 <copumpkin> the scheme implementation with curried functions
14:06:07 <haasn> and the sun's position
14:06:17 <magicman> @type curry . curry
14:06:18 <lambdabot> (((a, b), b1) -> c) -> a -> b -> b1 -> c
14:06:28 <FYI> i don't even think there was mention of ransom in that video
14:06:34 <burbul> I Suppose there's a coherent notion of 'maximally curried', no?
14:06:37 <milfjord> MonadRansom
14:06:47 <copumpkin> Handsom Ransom?
14:06:51 <copumpkin> +e
14:06:57 <syllogismos> @type curry . uncurry
14:06:58 <lambdabot> (a -> b -> c) -> a -> b -> c
14:07:00 <edwardk> burbul: only if you fix the type variables
14:07:19 <edwardk> burbul: keep in mind 'id' can curry just fine
14:07:23 <edwardk> :t id
14:07:24 <lambdabot> a -> a
14:07:31 <edwardk> looks fully curried, but
14:07:33 <edwardk> :t curry id
14:07:34 <lambdabot> a -> b -> (a, b)
14:07:46 <FYI> :t (uncurry.curry) id
14:07:47 <lambdabot> (a, b) -> (a, b)
14:07:51 <frx> edwardk fix them in what way?
14:07:53 <milfjord> :t uncurry id
14:07:54 <lambdabot> (b -> c, b) -> c
14:08:21 <burbul> Yes, I suppose I meant that any given type signature had a maximally curried version, rather than that there was a limit to how many times you could curry a function.
14:08:27 <burbul> Although the distinction hadn't occurred to me.
14:08:31 <FYI> frx: make them monomorphic
14:08:45 <benmachine> :t curry (curry id)
14:08:46 <lambdabot> a -> b -> b1 -> ((a, b), b1)
14:08:54 <benmachine> :t curry curry id
14:08:55 <lambdabot>     Couldn't match type `(a0, b1) -> c0' with `(a1 -> a1, b0)'
14:08:55 <lambdabot>     Expected type: (a1 -> a1, b0) -> a0 -> b1 -> c0
14:08:55 <lambdabot>       Actual type: ((a0, b1) -> c0) -> a0 -> b1 -> c0
14:08:56 <benmachine> aw
14:09:02 <edwardk> frx: ust saying that uncurrying until you're out of ->'s isn't well defined if the result is polymorphic in a way that can unify with (another argument -> the real result)
14:09:10 <dwcook> burbul, well, I suppose you could come up with a mechanical source transformation that removes tuples as parameters and splits them into separate parameters
14:09:14 <FYI> :t fmap uncurry curry id
14:09:15 <lambdabot> (a, b) -> (a, b)
14:09:27 <milfjord> :t fmap curry uncurry id
14:09:28 <lambdabot> (b -> c) -> b -> c
14:09:53 <dwcook> @type curry (uncurry id)
14:09:54 <syllogismos> i never knew id could confuse me
14:09:54 <lambdabot> (b -> c) -> b -> c
14:10:05 <roboguy_> :t flip id
14:10:06 <lambdabot> b -> (b -> c) -> c
14:10:24 <roboguy_> aka
14:10:26 <dwcook> syllogismos, it might help if you think of it as the same as ($) when a happens to be a function
14:10:27 <roboguy_> :t flip ($)
14:10:28 <lambdabot> b -> (b -> c) -> c
14:11:30 <edwardk> :t curry id
14:11:31 <lambdabot> a -> b -> (a, b)
14:11:33 <edwardk> :t uncurry id
14:11:34 <lambdabot> (b -> c, b) -> c
14:14:21 <jophish_> let's say I have a State monad which will rename nodes in a tree with a unique number (the state being the next unique number for the next node). Should the monad be a verb or a noun? "Rename" or "Renamer"
14:14:33 <jophish_> neither seem to fit
14:14:37 <haasn> :t (curry.curry) id
14:14:38 <lambdabot> a -> b -> b1 -> ((a, b), b1)
14:14:39 <haasn> :t (curry.curry.curry) id
14:14:40 <lambdabot> a -> b -> b1 -> b2 -> (((a, b), b1), b2)
14:14:44 <haasn> ad infinitum
14:14:53 <haasn> (we need a Curry lenslike, now.)
14:15:00 <edwardk> its there
14:15:04 <edwardk> :t curried
14:15:04 <lambdabot> (Functor f1, Profunctor p) => p (a -> b -> c) (f1 (d -> e -> f)) -> p ((a, b) -> c) (f1 ((d, e) -> f))
14:15:10 <milfjord> oh, of course
14:15:11 <haasn> :)
14:15:16 <edwardk> t: uncurried
14:15:21 <roboguy_> jophish_: all it does is rename nodes? why not a function then?
14:15:21 <edwardk> :t from curried
14:15:22 <lambdabot> (Functor f, Profunctor p) => p ((d, e) -> f1) (f ((a, b) -> c)) -> p (d -> e -> f1) (f (a -> b -> c))
14:15:33 <jophish_> roboguy_: it was just an example
14:15:36 <haasn> :t id ^. curried.uncurried.curried.curried.uncurried.curried
14:15:36 <edwardk> :t id^.curried
14:15:37 <lambdabot> a -> b1 -> b -> ((a, b1), b)
14:15:37 <lambdabot> a -> b -> (a, b)
14:16:17 <joelteon> :t to curried
14:16:18 <lambdabot> (Functor f, Functor f2, Profunctor p1, Conjoined p, Contravariant f) => p (p1 ((a, b) -> c) (f2 ((d, e) -> f1))) (f (p1 ((a, b) -> c) (f2 ((d, e) -> f1)))) -> p (p1 (a -> b -> c) (f2 (d -> e -> f1))) (f (p1 (a -> b -> c) (f2 (d -> e -> f1))))
14:16:22 <joelteon> oh that is beautiful
14:16:24 <dwcook> Ow ow ow
14:16:32 <Feuerbach> lol
14:16:50 <dwcook> I might be able to understand that type if I could actually keep it in memory while parsing it
14:16:56 <dwcook> Time to draw a diagram…
14:17:01 <roboguy_> I wish lambdabot had :i...
14:17:12 <edwardk> :t to curry
14:17:13 <lambdabot> (Functor f, Conjoined p, Contravariant f) => p (a -> b -> c) (f (a -> b -> c)) -> p ((a, b) -> c) (f ((a, b) -> c))
14:17:24 <edwardk> that is the sane one
14:17:25 <roboguy_> dwcook: have you seen the constraint for Conjoined, haha?
14:17:31 <edwardk> :t id^.to curry
14:17:32 <lambdabot> a -> b -> (a, b)
14:18:08 <dwcook> roboguy_, nope. I haven't really dug into lens yet
14:18:20 <roboguy_> dwcook: it's probably the scariest constraint in lens
14:18:26 <haasn> dwcook: (Functor f, Profunctor p) => Getter (p (a -> b -> c) (f (d -> e -> f)) (p ((a, b) -> c) (f ((d,e) -> f))
14:18:38 <edwardk> Conjoined is there because it makes things fast, not because it is pretty ;)
14:18:41 <roboguy_> dwcook: class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where ...
14:18:48 <haasn> imagine splitting an Iso' ((a,b) -> c) (a -> b -> c) in half :)
14:19:25 <edwardk> it is everything you can say about a profunctor that is isomorphic to i -> a -> b  -- it is both representable by (i ->)  and corepresentable by (,) i
14:19:26 <roboguy_> edwardk: can you use the conjoined method when the type isn't (->)?
14:19:40 <edwardk> roboguy_ yes
14:19:42 <edwardk> :t over
14:19:43 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
14:19:54 <edwardk> :t over traversed
14:19:55 <lambdabot> (Traversable f, Indexable Int p) => p a b -> f a -> f b
14:19:59 <roboguy_> edwardk: how does that satisfy the p ~ (->) constraint though?
14:20:02 <edwardk> :t over traversed . Indexed
14:20:03 <haasn> edwardk: corepresentable?
14:20:03 <lambdabot> Traversable f => (Int -> a -> b) -> f a -> f b
14:20:16 <edwardk> :t over traversed (Indexed (,)
14:20:16 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:20:21 <edwardk> > over traversed (Indexed (,)) "hello"
14:20:22 <haasn> is this a profunctor thing or can regular functors be corepresentable as well?
14:20:23 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:20:36 <edwardk> roboguy_: it oesn't, so it can't use that argument
14:20:42 <sccrstud92_> :@src and
14:20:42 <edwardk> it uses the other
14:20:46 <sccrstud92_> @src and
14:20:46 <lambdabot> and   =  foldr (&&) True
14:20:46 <edwardk> read it in negative position
14:20:51 <syllogismos> my niece asked me what perimeter of a rectangle is, I spent 1 hour trying to explain her what it is.. She still didn't get it. and then I thought to myself, she needs time.. its the same with haskell and me
14:20:55 <edwardk> :t conjoine
14:20:55 <lambdabot>     Not in scope: `conjoine'
14:20:56 <lambdabot>     Perhaps you meant one of these:
14:20:56 <lambdabot>       `conjoined' (imported from Control.Lens),
14:20:56 <edwardk> :t conjoined
14:20:57 <lambdabot> Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
14:21:11 <haasn> roboguy_: implementations of conjoined are either conjoined f _ = f -- for unindexed versions  or conjoined _ f = f -- for indexed versions
14:21:35 <enthropy> syllogismos: did you use a piece of string?
14:21:46 <edwardk> that says given Conjoined p, and something that if p was (->) could give you q (a -> b) r     and something that works regardless for p, i can give you, well, one or the other.
14:22:02 <roboguy_> edwardk: speaking of category theory, I have a feeling that I'd understand the description of Conjoined a lot more if I knew some
14:22:42 <edwardk> roboguy_: conjoined is around because making, say a traversal use it lets me avoid payng to update indices if you don't use them
14:22:50 <haasn> edwardk: ah, never mind; I just looked at the definition of corepresentable in the lens doc
14:22:53 <edwardk> :t conjoined traverse traversed
14:22:55 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
14:23:10 <edwardk> that uses traverse if it can, traversed if it has to
14:23:32 <edwardk> the fact that they can give different answers is something you should guard against
14:23:46 <haasn> edwardk: (i -> a -> b) being representable is realized by ‘flipped’, and corepresentable is realized by ‘curried’?
14:23:53 <roboguy_> edwardk: hmm, that *sort of* makes sense to me
14:23:59 <edwardk> haasn: yep
14:24:22 <Platz> what does the tilde represent in the type of conjoined?  I assume it's not lazy pattern binding
14:24:30 <edwardk> haasn: if you look at the code for the instances for Representable/Corepresentable for Indexed i you'll see just that modulo newtype noise
14:24:39 <Platz> ahh equality constraint
14:24:58 <edwardk> Platz: yep
14:25:36 <syllogismos> enthropy: whoa.. thats a great idea.. we are trying to derive p = 2 (l + b) for a rectangle.. but she doesnt really get why I'm replacing CD with AB and BC with DA.. and I'm scared to even think about Area now
14:27:06 <enthropy> so with haskell you can also look at concrete examples first, then see the generality later on
14:28:21 <sccrstud92_> im working on a version of the n queens problem, but my function that determines whether two queens threaten each other is using too much memory. it seems like more laziness could fix it but im not sure. anyone want to take a look? its not a lot of code. http://lpaste.net/99667
14:28:34 <syllogismos> yeah, I'm much better than few months back now. and exercism.io is turning out to be very valuable.. i'm doing those exercises in haskell now
14:30:21 <haasn> edwardk: what is the constraint needed for, actually?
14:30:36 * hackagebot pipes-text 0.0.0.6 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.6 (MichaelThompson)
14:32:10 <haasn> ah, in the case that you are abstracting over ‘p’
14:32:21 <haasn> you can't just assume it's (->) unless it comes from outside
14:32:30 <haasn> Never mind :)
14:32:39 <jle`> any reason why the Report implementation is different from the ghc one here? http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#and
14:32:51 <jle`> shouldn't they both be equivalent from referential transparency?
14:33:21 <dwcook> Is Indexable a b like saying that b has access to an environment a?
14:33:26 <jle`> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#foldr
14:34:00 <edwardk> :t indexed
14:34:01 <lambdabot> Indexable i p => p a b -> i -> a -> b
14:34:13 <geekosaur> I think the point is the RULES pragmas afterward which let the rewritten versions participate in fusion?
14:34:22 <edwardk> Indexable i p    says you can call that function
14:34:23 <sccrstud92_> nevermind i was misreading the profiling information
14:34:36 <jle`> geekosaur: ah, it's all about the rules pragma?
14:34:59 <geekosaur> that's how I read it
14:35:07 <edwardk> :t let foo f (a,b,c) = (,,) <$> indexed f "index 1" a  <*> indexed f "index 2" b <*> indexed f "index 3" c in foo
14:35:09 <lambdabot> (Applicative f, Indexable [Char] p) => p a1 (f a) -> (a1, a1, a1) -> f (a, a, a)
14:35:29 <edwardk> > let foo f (a,b,c) = (,,) <$> indexed f "index 1" a  <*> indexed f "index 2" b <*> indexed f "index 3" c in (1,2,3)^..foo
14:35:31 <lambdabot>  [1,2,3]
14:35:36 <sccrstud92_> does anyone know of an algorithm for n queens where the board can have blocked sqaures?
14:35:45 <sccrstud92_> i was unable to find anything
14:35:48 <edwardk> that makes an indexed traversal, which can be used as a normal one like that
14:35:58 <edwardk> and you can also access the indices
14:36:00 <edwardk> > let foo f (a,b,c) = (,,) <$> indexed f "index 1" a  <*> indexed f "index 2" b <*> indexed f "index 3" c in (1,2,3)^@..foo
14:36:02 <lambdabot>  [("index 1",1),("index 2",2),("index 3",3)]
14:36:05 * dwcook should probably read a lens introduction
14:36:17 <roboguy_> sccrstud92_: couldn't you use normal backtracking, but just fail on blocked squares?
14:36:35 <sccrstud92_> roboguy_: takes too long and uses too much memory
14:36:52 <edwardk> conjoined lets you choose to stop fiddling with indices way at the top of the function, f you have lots of invocations of indexed or they are hard to construct it can be a big win
14:37:35 <haasn> dwcook: yes :)
14:37:37 <sccrstud92_> roboguy_: though it does work
14:38:24 <roboguy_> sccrstud92_: what if you "cross off" the places that the queens can't go and only check the places that the queens *can* go
14:38:37 <roboguy_> that's how I solved the knights problem
14:39:36 <edwardk> sccrstud92_: grab a sat solver, add the constraints, easy
14:39:48 <edwardk> sccrstud92_: sbt or ersatz can deal with it easily
14:40:03 <edwardk> er sbv
14:40:09 <sccrstud92_> roboguy: so u mean like, if i have a list of position where queens can go, when i add a new queen, remove all newly threaten positions from the list?
14:40:26 <sccrstud92_> edwardk: i havent used a sat solver before. which would you recommend?
14:40:41 <roboguy_> sccrstud92_: yeah. that dramatically improved the speed of my knight solver back when I did that
14:41:21 <edwardk> sccrstud92_: ersatz is mine, sbv is much richer and more supporte, ymmv.
14:42:04 <edwardk> sccrstud92_: if you wnt to do it all in haskell you can use an overton style constraint solver. they are pretty easy to write, but the probem is small enough you can solve it just using list monad hackery
14:42:04 <sccrstud92_> roboguy: i wonder if there is a better way to remove the threatened positions than sorting and merging
14:42:19 <merijn> Any clue why hdevtools trips over files with a shebang while GHC doesn't?
14:42:26 <roboguy_> sccrstud92_: why do you need to sort and merge?
14:42:34 <edwardk> sccrstud92_: http://overtond.blogspot.com/2008/07/pre.html
14:43:06 <sccrstud92_> roboguy: it would be O(n^2) to remove one list from another right? unless i sort before removing to reduce to O(nlogn)
14:43:24 <roboguy_> sccrstud92_: I essentially represented my board like "data Square = Empty | Queen | Unusable;type Board = [[Square]]"
14:43:27 <sccrstud92_> edwardk: thanks for the link ill read that soon
14:43:35 <edwardk> sccrstud92_: i highly recommen reading that article i just linked before going too much deeper
14:43:57 <sccrstud92_> edwardk: is constraint solving still appropriate if i need all solutions instead of just one?
14:43:59 <akurilin2> Quick question: I'm doing a ghc 7.6.3 install from source on ubuntu precise, at the ./configure --prefix=/opt/ghc-7.6.3 step I'm told "GHC is required unless bootstrapping from .hc files"
14:44:03 <akurilin2> Any suggestions?
14:44:06 <edwardk> sccrstud92_: it gives the 'right' way to solve this sort of thing if you aren't willing to resort to a heavier external solver.
14:44:18 <edwardk> sccrstud92_: yes, moreso than the sat version
14:45:08 <sccrstud92_> roboguy: edward: thanks ill look into both of these
14:47:43 <merijn> akurilin2: Well, do you have a GHC installed?
14:48:09 <jle`> was there ever a serious idea to unify the interfaces of all the containers containers with a typeclass? (class Container c k v where insert :: (Ord k) => k -> v -> c k v ... etc.)
14:48:16 <jle`> if that would even make sense
14:48:51 <Cale> jle`: yes
14:49:06 <jle`> so...what happened?
14:49:06 <Cale> There have been a bunch of attempts at it which haven't really taken off
14:49:12 <jle`> bad error messages?
14:49:34 <jle`> or just lack of interest
14:49:36 <Cale> Well, the differences between containers make it hard to really do correctly
14:49:47 <akurilin2> merijn: well, I'm trying to install it. Is the assumption that I have to start with whatever old version my distro provides me with and then just build my way up to the latest one with it?
14:50:11 <Cale> and if you do it that naive way you have there, you get terribly bad type inference
14:50:17 <akurilin2> I found a ppa for 7.6.3 from haskell cafe, probably going to get all my personal info stolen :P
14:50:26 <merijn> akurilin2: Well, you can't compile GHC without having a haskell compiler installed
14:50:30 <jle`> Cale: ah i see
14:50:36 <mzero> Also, I have to say, I don't think unified containers is all that useful in practice
14:50:39 <Cale> Functional dependencies and class associated types try to solve that problem though
14:51:01 <jle`> i was just using a bunch of differnet containers in a single module and i just wondered if it made sense to combine them all instead of doing everything qualified all the time
14:51:08 <merijn> akurilin2: The easiest solution would be to install whatever binary your distro has and compile 7.6 using that (assuming your distro doesn't have 7.6 as binary)
14:51:09 <Cale> Usually if I want to abstract over some sort of container, I just write a function which takes functions of the appropriate types
14:51:22 <benmachine> jle`: qualification ain't so bad
14:51:28 <Cale> i.e. explcitly the things I need in good ol' functional programming style
14:51:30 <akurilin2> merijn: ok perfect, thanks for confirming that for me.
14:51:42 <jle`> benmachine: not so bad, but wondered if there was a different way
14:52:06 <akurilin2> ll
14:52:40 <merijn> akurilin2: Unfortunately, not many OSes ship a haskell compiler by default ;)
14:52:48 <merijn> *yet
14:53:03 <akurilin2> merijn: well it's also a 400mb download from what I can tell
14:53:22 <akurilin2> at least on ubuntu that's what it tells you
14:54:00 <mzero> akurilin2: surely there is Haskell Platform w/7.6.3 for Ubuntu at this point
14:54:23 <akurilin2> mzero: for 13.10 yes, I'm on precise
14:54:25 <akurilin2> which is a few years back
14:54:55 <mzero> ah - humpf! is there a HP for percise (is that 12.04?)
14:55:30 * mzero is always driven crazy by having both relase numbers AND names for OS release... Ubunutu, Debian, and Mac OS X all do this
14:55:40 <akurilin2> mzero: I'm not sure, not the right person to ask tbh. Yes it's 12.04
14:56:22 <mzero> well, in theory, *I'm* the right person to ask... but I can never keep all the linux variants striaght
14:56:52 <akurilin2> mzero: are you a package maintainer? If you are, you're a hero among men :P
14:56:53 <mzero> There is HP for precise - it is HP 2012.1.0.0
14:57:07 <mzero> Uhm... I'm the Haskell Platform release (mis-)manager
14:57:42 <akurilin2> I need to read up on what a haskell platform is, still really new :)
14:58:17 <mzero> Ah - it is for people like you! It is the compiler + a bunch of very commonly used libs + all the doc    -- all packaged up for an easy install
14:59:14 <Clint> akurilin2: http://people.debian.org/~nomeata/platform.html might give you a partial picture
14:59:45 <sccrstud92__> mzero: i just saw ur google tech talk
15:00:17 <mzero> So - that package for percise should have GHC 7.4.1 in it --- which is certainly good enough to get you going - you'll be able to do a fair bit with that if you are new to Haskell
15:00:17 <merijn> Any vim-hdevtools users? How do I jump to file with definition with HdevtoolsInfo ?
15:00:25 <akurilin2> mzero: nice, seems like what I need :)
15:00:27 <mzero> oh, sccrstud92__, hope you liked it
15:00:28 <merijn> The comments imply that a link should be created in the info window
15:00:40 <mzero> http://packages.ubuntu.com/search?keywords=haskell-platform
15:00:45 <merijn> But I don't have a working link when I try it
15:00:53 <sccrstud92__> mzero: i did indeed. im still trying to get my friends into haskell, and maybe that talk will help
15:00:56 <akurilin2> mzero: well, I'm told that sandboxing makes your life 10x better, so I was looking for 7.6.3. The PPA I found worked just fine.
15:01:26 <mzero> sandboxing does - but that is just a function of cabal, not the whole shebang!
15:01:48 <akurilin2> mzero: isnt' 7.6.3 a prereq for cabal with the version that supports sandboxing?
15:01:57 <mzero> once you've installed that version of the platform ... you should be able to just build and install the latest cabal
15:02:00 <mzero> ah - possibly
15:03:03 <mzero> akurilin2: looking at the dependencies , I don't see that it would
15:04:38 <akurilin2> mzero: ok nevermind then, I was just basing that off of something I read
15:05:09 <mzero> (I might be wrong... but I think it will be fine)
15:05:12 <akurilin2> On a different note: is anybody aware of a simple to follow guide for creating a new sandboxed cabal project for an executable?
15:05:55 <mzero> here, I'll paste you a template
15:07:31 <akurilin2> I don't get how half of these tutorials work: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html . They skip the cabal init part, which seems to be necessary to generate the .cabal file, which is required by cabal build.
15:07:43 <akurilin2> So if you follow along it won't actually build, unless I'm doing something wrong here.'
15:10:19 <mzero> http://lpaste.net/99670\
15:12:58 <akurilin2> Let me try that
15:13:11 <syrioforel> Is there a "map" analog for arrows? I would like a b c -> a [b] [c] for something I'm doing with HXT. (So a can be an arrowlist even)
15:13:47 <Saizan> syrioforel: yeah, HXT has a combinator like that iirc
15:14:02 <syrioforel> ok i'll have to look around
15:14:11 <roboguy_> syrioforel: hmm, that seems like a profunctor thing
15:15:15 <roboguy_> actually, maybe not
15:15:53 <AncientPC> I'm compiling some files and there's an error message: ghc: panic! ('impossible' happened): Prelude.head: empty list
15:15:53 <syrioforel> I can see it not working in the obvious way for any functor, like I wouldn't expect a b c -> a (f b) (f c)
15:16:00 <AncientPC> is there a way to narrow down what's causing that panic?
15:16:21 <akurilin2> mzero: cool, that worked, thank yo!
15:16:22 <syrioforel> (thinking of arrowlists for a moment, b -> [c] doesn't induce f b -> [f c])
15:16:26 <mzero> welcome
15:16:41 <roboguy_> :t arr (fmap undefined)
15:16:42 <lambdabot> (Functor f, Arrow a) => a (f a1) (f b)
15:17:26 <gseitz> I'm trying to upload a file with http-conduit like `requestBody = requestBodySource size $ sourceFile path`, but it seems the content is never transmitted
15:17:48 <gseitz> when I read the file via ByteString and use RequestBodyBS directly, then the upload works as expected
15:17:57 <AncientPC> The same project compiles on 7.4.1 fails on 7.6.3 with a panic. :(
15:20:01 <gseitz> I don't know how else to set up the Source to get this to work
15:20:58 <gseitz> the files to be uploaded (videos) will usually be quite large, so the non-streaming solution won't work with non-test files
15:31:48 <f-a> hello. Naive question: a program I am compiling requires alex-3.1. I run debian stable and the binary from the distro is wholly outdated. So I ran cabal install alex-3.1 (and it worked), but still when I 'cabal install yi' the error is 'found at /usr/bin/alex is version 3.0.1'. How can I tell ghc/cabal 'hey, there is a new version, installed with cabal!'?
15:32:30 <akurilin2> mzero: well, managed to add scotty to that template you gave me, seems like it's working. Was amazed just by how must stuff was downloaded when cabal fetched the deps the first time.
15:32:36 <Eduard_Munteanu> f-a: you likely need to alter your PATH to make it pick the other one... what does "which alex" say?
15:32:55 <akurilin2> 13 meg executable, not bad I guess.
15:33:22 <f-a> /usr/bin/alex , Eduard_Munteanu
15:33:33 <gseitz> nevermind, I was being silly. sorry for the noise
15:33:39 <Eduard_Munteanu> f-a: fix your PATH then
15:35:34 <f-a> Eduard_Munteanu: currently /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games <-- I guess I should add ~/.cabal/bin to that, right?
15:35:43 * hackagebot neat 0.1.0 - A Fast Retargetable Template Engine  http://hackage.haskell.org/package/neat-0.1.0 (ajg)
15:35:56 <Eduard_Munteanu> f-a: yes
15:36:14 <geekosaur> to the *front*
15:37:15 <f-a> to the front, ok. Thank you both. I will export this on .bashrc, geekosaur Eduard_Munteanu
15:46:35 <mzero> akurilin2: cool!
17:01:17 <Eduard_Munteanu> Does async's "wait" provide output lazily?
17:01:56 <Eduard_Munteanu> E.g. you spawn an async that produces a list and wait on it
17:02:47 <Eduard_Munteanu> Actually I guess that would be too surprising for a function called "wait".
17:02:54 <copumpkin> that doesn't seem to have the desired semantics
17:02:56 <copumpkin> since it wouldn't wait
17:03:01 <roboguy_> getContents doesn't like to read binary data does it?
17:03:19 <Eduard_Munteanu> roboguy_: I don't think that's true
17:03:41 <Eduard_Munteanu> roboguy_: you probably need to set the handle mode to binary
17:03:50 <roboguy_> Eduard_Munteanu: ah that's probably it
17:04:11 <copumpkin> isn't the whole notion of "binary mode" a windows abomination
17:04:37 <rgr> Im trying to set up emacs haskell-mode to get online help. When I try I get the following error message related to uninstalled stuff. Could one of you kind folks decipher it for me and let me know if its something easy to fix using cabal? http://dpaste.com/1594127/
17:04:59 <roboguy_> copumpkin: I'm on OS X and it still doesn't like it at the moment
17:05:07 <Eduard_Munteanu> copumpkin: originally yes, I suppose. Probably an abomination of trying to make it easier on the programmers as well.
17:05:28 <copumpkin> The mode string can also include the letter ``b'' either as last character or as a character between the characters in any of the two-character strings described above.  This is strictly for compatibility with ISO/IEC 9899:1990 (``ISO C90'') and has no effect; the ``b'' is ignored.
17:06:11 <copumpkin> anyway, just use getContents in ByteString
17:06:14 <copumpkin> if you aren't already
17:06:31 <Eduard_Munteanu> copumpkin, roboguy_: but Haskell seems to have perpetuated this abomination by also adding an encoding mode to handles
17:06:49 <Eduard_Munteanu> So I don't think it's the same as fopen's 'b'.
17:07:04 <guymann> hi
17:07:09 <Eduard_Munteanu> guymann: hi
17:07:21 <Eduard_Munteanu> Likely because String.
17:08:01 <Eduard_Munteanu> It's sort of awful base libs still use that as the main (and usually only) API.
17:08:39 <Rarrikins> copumpkin: No, it comes from text files by necessity having a specific encoding and library designers assuming that text files are without an encoding.
17:10:12 <Eduard_Munteanu> Rarrikins: they should add a "z" flag then, to indicate the handle refers to a gz-compressed file and it should be transparently decompressed. :P
17:10:45 <Rarrikins> Eduard_Munteanu: I think that they should just do binary by default and have the programmer specify an encoding if they want text.
17:11:03 <SquareRoot> Hey chat
17:11:28 <Eduard_Munteanu> Rarrikins: yeah, like Data.Text.Encoding. There's really no place for stuff like that on Handle-s themselves.
17:11:36 <SquareRoot> How is everybody doing
17:12:47 <zq> is it possible to load the results of a 'cabal build' into ghci?
17:13:27 <SquareRoot> Does anybody here see me?
17:13:38 <Eduard_Munteanu> SquareRoot: yes
17:13:50 <SquareRoot> Nobody seems to want to talk to me
17:14:10 <Cale> SquareRoot: everyone can see you :)
17:14:16 <SquareRoot> that's what she said
17:14:35 <Cale> SquareRoot: This channel is for discussion of the programming language Haskell
17:14:44 <SquareRoot> Oh sorry
17:15:36 <Eduard_Munteanu> He might've thought this is #haskell like #iowa.
17:17:23 <startling> zq, cabal repl
17:17:38 <Eduard_Munteanu> Bleh, I wish there was a mvarGetContents. :(
17:17:45 <zq> startling: 0.14.0 here, no repl
17:17:51 <zq> 1.14.0, rather
17:18:12 <Eduard_Munteanu> I wonder if it's as straightforward as just doing unsafeInterleaveIO.
17:18:47 <startling> zq, cabal install cabal-install, then?
17:24:23 <zq> startling: what?
17:24:46 <zq> startling: it's already installed
17:24:58 <enthropy> is it actually redundant to drop the parentheses in http://hackage.haskell.org/package/optimization-0.1.3/docs/Optimization-Constrained-Penalty.html#v:lagrangian ?
17:25:10 <roboguy_> is there an easy way to turn a String into a list of Word32s?
17:25:11 <copumpkin> Rarrikins: yeah, file reading should not be dealing with encodings at all
17:25:35 <enthropy> ie. in the source people write  x -> y -> (forall z. C z => z -> z)
17:25:47 <enthropy> but ghc it without any parens
17:25:56 <enthropy> err, prints it
17:26:00 <Eduard_Munteanu> roboguy_: that's not very well-defined, String isn't comprised of bytes.
17:26:13 <roboguy_> Eduard_Munteanu: would ByteString be better?
17:26:32 <Eduard_Munteanu> roboguy_: yes, sure. String can contain arbitrary Unicode codepoints.
17:26:54 <enthropy> @type map (fromIntegral . fromEnum) :: String -> [Word32]
17:26:55 <lambdabot> String -> [Word32]
17:27:27 <roboguy_> enthropy: that effectively turns it into a list of bytes though, right?
17:28:01 <enthropy> word32 is something like 4 bytes, no?
17:28:10 <roboguy_> enthropy: yeah
17:28:18 <prophile> it's 4 octets
17:28:28 <Eduard_Munteanu> enthropy: fromIntegral there converts a Char to a Word32
17:28:40 <enthropy> no it converts Int to Word32
17:28:41 <Eduard_Munteanu> Not sure roboguy_ wants that.
17:28:45 <enthropy> @type  fromEnum
17:28:46 <lambdabot> Enum a => a -> Int
17:29:07 <ajg> Howdy. I need an Arbitrary instance for Rational that only produces values with finite decimal expressions--any idea how to do this or whether something like it already exists?
17:29:10 <Eduard_Munteanu> enthropy: well, fromEnum operates on individual chars anyway
17:29:22 <roboguy_> basically, all I want to do is read a "binary" file in and get a list of Word32s (actually, I want a Seq Word32)
17:29:36 <Eduard_Munteanu> > fromIntegral (fromEnum 'a') :: Word32
17:29:37 <lambdabot>  97
17:29:57 <prophile> ajg: you could generate an arbitrary list of digits
17:30:02 <verement> assuming what encoding? big endian? little endian?
17:30:04 <prophile> and an arbitrary integral part
17:30:39 <Rarrikins> You can get the integral part, the length of the fractional part, and the fractional part.
17:30:53 <roboguy_> verement: probably little
17:31:53 <byorgey> ajg: well, a rational has a finite decimal expansion if and only if the only prime factors in its denominator are 2 and 5.  So you could generate a triple of numbers: a numerator, an exponent of 2, and an exponent of 5
17:32:05 <Eduard_Munteanu> roboguy_: you could split a bytestring into chunks of 4 bytes and add them up using shifts
17:32:24 <Eduard_Munteanu> Or multiply.
17:32:41 <roboguy_> Eduard_Munteanu: that's what I'm doing now actually, I was just wondering if there's a built in way to do it (especially since I'm not *totally* sure I'm doing it right)
17:32:50 <enthropy> do you know the binary package?
17:32:59 <byorgey> if you want to get really fancy you can randomly generate a prime factorization for the numerator that avoids 2 and 5
17:33:04 <roboguy_> enthropy: nope
17:33:16 <Eduard_Munteanu> Actually you can just read them, I think, at least with binary like enthropy suggests.
17:33:38 <ajg> @prophile, @byorgey: thanks, let me try that
17:33:38 <lambdabot> Unknown command, try @list
17:41:51 <rgr> could someone advise me what the updated url to perform a doc lookup is now? emacs haskell mode produces a url such as www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Enum.html#v:succ -- and GHC-enum doesn't exist anymore.
17:44:41 <twfNoFPgf> Hey guys. I was on the wiki, and thought the Phooey library looked nice, no I decided to install it through cabal. It won't build with the latest platform, though. The culprit seems to be Control.Monad, the last error being "Control\Monad\Error.hs:73:21: Not in scope: `catch'" Any ideas?
17:46:47 <syllogismos> is there a function to know what the day of the week given the date?
17:47:47 <Eduard_Munteanu> syllogismos: Data.Time can do that IIRC
17:49:59 <byorgey> rgr: that URL looks fine.  It looks to me like GHC.Enum just isn't exported from the base package, so it doesn't show up in the docs
17:50:09 <Eduard_Munteanu> syllogismos: http://hackage.haskell.org/package/time-1.4.0.1/docs/Data-Time-Calendar-WeekDate.html
17:50:47 <byorgey> rgr: I guess haskell-mode is getting a bit confused and sending you to the module where 'succ' is defined (even though it isn't exported), instead of to Prelude where 'succ' is re-exported
17:51:06 <byorgey> rgr: if you change 'GHC-Enum' to 'Prelude' it should work
17:51:28 <levi> twfNoFPgf: That's a pretty old package, and it will probably need some love from someone to get it to build in a recent Haskell Platform.
17:51:45 <byorgey> rgr: haskell.org/hoogle  is also useful for looking up standard functions like this, and does a better job sending you to the right documentation page
17:53:42 <twfNoFPgf> levi: If that's the case, I'm going to start with Threepenny, since that just installed without issue. When I suck less I'll see if there's anything I con do for phooey. The examples were all really nice.
17:55:54 <levi> twfNoFPgf: Threepenny is definitely being actively maintained, and it should be one of the easier ones to use cross-platform if that is a concern for you.
17:57:29 <jophish_> In Example 1 here: https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system I don't quite understand why beta is being quantified twice
17:58:22 <jophish_> why isn't foo using the quantification by bar?
17:58:47 <jophish_> would this be equivalent if beta was renamed to gamma in foo?
17:59:10 <rgr> byorgey: changing that did indeed work. thanks. haskell-mode seems pretty abandoned. But then its all new to me. thanks again.
17:59:44 <Eduard_Munteanu> jophish_: beta is a type *variable*, likely the convention being used is equivalent to Haskell without ScopedTypeVariables
17:59:48 <twfNoFPgf> levi: cross platform is always good in my book! Threepenny looks awesome for the RPG tools I've been meaning to make, but Java/Swing make me despise making.
18:00:07 <Eduard_Munteanu> Er, I meant to highlight "type", not "variable".
18:00:30 <byorgey> rgr: haskell mode is most emphatically not abandoned!
18:00:47 <byorgey> rgr: where did you get it / how did you install it?
18:00:51 <byorgey> maybe you found some old version
18:01:14 <jophish_> Eduard_Munteanu: but foo is able to inherit alpha from the outer scope
18:02:09 <rgr> sorry, you're right. I'm just getting a tad frustrated trying to get the help functions to output something or anything. I'll stick with it.
18:02:34 <Eduard_Munteanu> jophish_: mm, not sure, I think alpha is free. I haven't read the article.
18:03:08 <Eduard_Munteanu> jophish_: in any case, one of them seems shadowed.
18:03:20 <jophish_> I'll keep thinking
18:03:21 <jophish_> thanks Eduard_Munteanu
18:03:39 <Eduard_Munteanu> jophish_: ah... "I.e. in context of the example, the same type variable \alpha appears both bound and free in different types. "
18:03:40 <byorgey> rgr: yeah, I understand the feeling.
18:05:03 <jophish_> yeah, I pretty much understand alpha's part in this, it's beta I'm not so convinced about
18:05:21 <levi> twfNoFPgf: Cool, good luck with your RPG tools. :)
18:05:36 <jophish_> I can't see how this would be different if beta was replaced with gamma in foo's scope
18:06:34 <Eduard_Munteanu> jophish_: it wouldn't be different... since it's explicitly quantified, it can't be something else in scope
18:06:54 <levi> rgr: haskell-mode does take a bit of tweaking... a bunch of people with different preferences hack on it, so it's more of a 'haskell-mode kit' when you first get it.
18:06:56 <jophish_> so beta is being shadowed in foo
18:07:04 <rgr> I mean if the main haddock lookup function online doesnt work and features hard coded url construction one has to wonder ;)
18:07:23 <Eduard_Munteanu> jophish_: no, you can't draw that conclusion from "Example 1" alone
18:07:36 <rgr> and I used package manager to install it so its pretty upto date afaik.
18:08:47 <Eduard_Munteanu> jophish_: I don't think the beta in bar's type has a scope wider than bar's type itself.
18:09:00 <jophish_> ah I see
18:09:07 <darthdeus> anyone here using emacs? I'm trying to figure out how to do C-c C-l when using cabal sandbox
18:09:11 <jophish_> the example was just being economical with their letters then :)
18:19:39 <startling> darthdeus, I wish I knew. I don't think it's possible.
18:24:01 <AlainODea> darthdeus: it's definitely possible, but may not be in ELPA, so you may have to hack some Emacs Lisp to do it
18:25:01 <NemesisD> where do you guys install your emacs haskell-mode? distro package manager or?
18:25:17 <startling> NemesisD: the built-in package manager
18:25:25 <startling> (to emacs)
18:25:38 <startling> You might need to add a repository, I forget.
18:25:59 <NemesisD> startling: this is literally my first day of using emacs so i know nothing
18:26:21 <NemesisD> aren't there multiple package managers for emacs
18:26:38 <startling> NemesisD, M-x package-install RET haskell-mode RET
18:26:56 <sm> NemesisD: o happy day!
18:26:56 <startling> NemesisD: there were but then one was blessed and included and no one uses the others
18:27:54 <NemesisD> we'll see if i stick with it. i'm determined to not pick up any vim emulators
18:28:50 <NemesisD> assuming that the emacs input mode will lead to best results in emacs
18:28:51 <Eduard_Munteanu> NemesisD: you should, Emacs is rather annoying as an editor
18:29:22 <NemesisD> Eduard_Munteanu: really? do most people do that? why not just use vim?
18:29:23 <LowPotential> Hello everyone. I'm using Data.Binary, and I'd like to write a function choice :: [Get (Maybe a)] -> Get (Maybe a), which returns the first "successful" decoding of multiple options. If 'options' are the list of options, then I'm running 'mapM lookAheadM options', but this doesn't "stop" once the first one succeeds, but instead continues to evaluate all the options. Any tips? Am I being very unclear?
18:29:24 <Eduard_Munteanu> NemesisD: I recently switched to Emacs, and using Evil is sort of okay. You're just going to use it for editing.
18:29:38 <Eduard_Munteanu> NemesisD: because Vim sort of sucks functionality-wise :)
18:29:55 <LowPotential> Basically, I want to short-circuit 'lookAheadM'.
18:30:55 <jfischoff> LowPotential: you probably want to (<|>) somehow, I'm just guessing, let me look at the doc
18:31:41 <jfischoff> LowPotential: I'm wrong
18:31:44 <Eduard_Munteanu> LowPotential: likely whileM from monad-loops (or rolling your own) might do
18:31:48 <NemesisD> Eduard_Munteanu: well i suppose you may be right. thats pretty much the reason why im' considering switching. i have absolutely 0 problems being productive coding-wise in vim
18:31:51 <jfischoff> there is no Alternative for Get
18:32:24 <jfischoff> oh wait there is
18:32:30 <jfischoff> I was looking at the wrong version :p
18:34:23 <Eduard_Munteanu> NemesisD: note there are some issues with evil not playing nice with haskell-mode by default, though it's fixable (mainly referring to messing up indentation).
18:35:08 <jfischoff> LowPotential: choice = foldr (<|>) (fail …) . map lookAhead
18:35:17 <jfischoff> I think you want something like that
18:35:30 <jfischoff> I don't know how you want to fail
18:35:31 <LowPotential> jfischoff: That looks good, actually. Thanks!
18:35:44 <jfischoff> let me know if it works :p
18:35:48 <NemesisD> Eduard_Munteanu: i may give emacs proper a try. im wondering if it can do a better job at navigating code by the structure
18:36:20 <Eduard_Munteanu> I haven't tried, it's not really a structural editor either.
18:37:11 <PhineasRex> Has anyone tried structured haskell mode?
18:37:15 <Eduard_Munteanu> NemesisD: I can supply an ~/.emacs if you want one, I customized mine to look like a vim terminal even though it's an X window.
18:37:26 <LowPotential> jfischoff: Could I have used (<>) from Data.Monoid?
18:37:36 <NemesisD> Eduard_Munteanu: i find myself in vim doing a whole lot of bashing chunks of code around in vim to get it in the right format
18:37:53 <jfischoff> yeah probably
18:38:10 <jfischoff> I think you are supposed to make them work the same
18:38:12 <LowPotential> jfischoff: Just trying to wrap my head around the solution.
18:38:27 <jfischoff> Assuming there is a Monoid instance of Get a
18:40:04 <DrAwesomeClaws_> hi folks.  I hesitate to post this because this code is probably horrid.  Playing with extending the irc bot example from the wiki.  Running into a strange situation.  I've set up 3 basic commands, !listfeeds, !say, and !quit.  !listfeeds and !quit work fine, but !say doesn't.  http://lpaste.net/7266645624685068288  relevant bit is around line 72, it seems cmdIs "!say" returns false for some reason, while
18:40:04 <DrAwesomeClaws_>  the other ones work.
18:40:49 <jfischoff> LowPotential: (<|>) is like <> for Applicatives
18:41:14 <DrAwesomeClaws_> it's not the implementation of sayCmd, because replacing that with something trivial doesn't get run.  Tried the ghci debugger, but it seems scoping is strange on breakpoints
18:42:02 <jfischoff> almost universally when writing parsers in Haskell you choose the between to options with (<|>)
18:42:08 <DrAwesomeClaws_> oh, and i've gotten rid of (toLower `fmap` t) .... changed to just t     with the same results.
18:43:14 <LowPotential> :t map lookAhead
18:43:14 <lambdabot> Not in scope: `lookAhead'
18:43:22 <LowPotential> Woops. Wrong buffer. :-p
18:43:52 <Rarrikins> LowPotential: Turn from the confusing way of evil. Embrace vim.
18:49:14 <LowPotential> Rarrikins: Never!
18:49:47 <roboguy_> is anyone here familiar with the Cult of the Bound Variable challenge? I'm having some trouble reading the encoding correctly
18:51:30 <syllogismos> > data Gamma = SRGB | Curve Double deriving (Functor, Show, Eq)
18:51:31 <lambdabot>  <hint>:1:1: parse error on input `data'
18:51:50 <Rarrikins> roboguy_: Was that the one with a virtual machine?
18:51:56 <roboguy_> Rarrikins: yeah
18:53:29 <LowPotential> jfischoff: Your solution type-checked, but I was still evaluating all the options even when one succeeded. This is a problem, because the 'Get' monad pulls from a byte stream. I ended up doing manual recursion to do the early termination, and it works.
18:53:34 <Rarrikins> roboguy_: If you want a spoiler, http://boundvariable.org/press/tr-06-163.pdf has a simple C implementation on page 3.
18:53:47 <jfischoff> thats odd
18:54:18 <jfischoff> I mean I haven't looked at the instance definition so I have no idea how <|> behaves there but I'm surprised
18:54:31 <jfischoff> I'll take a look in a sec, I'm curious now
18:55:24 <LowPotential> jfischoff: I'm using "choice = foldr (<|>) (return Nothing) . map lookAhead".
18:56:06 * hackagebot regex-pcre-builtin 0.94.4.6.8.34 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.6.8.34 (AudreyTang)
18:56:16 <LowPotential> Where "choice :: [Get (Maybe a)] -> Get (Maybe a)"
18:56:29 <LowPotential> and that doesn't work as I would expect, where manual recursion does.
18:56:39 <jfischoff> I have to look at the definition of <|> and relook at lookAhead, I don't know this library perfectly so I'm just going off my Haskell inituition
18:56:55 <LowPotential> jfischoff: That's okay. I appreciate your help.
19:04:58 <DrAwesomeClaws_> woohoo.  Fixed it.  Of course it was just a dumb mistake
19:06:24 <greymalkin> How should I decide which of many packages for a purpose to use? More specifically... which statistics package is best supported?
19:06:55 <greymalkin> I found hstats -- but it still has references to haskell98
19:07:14 <greymalkin> Then I did a hackage search and found a *lot* of statistics packages
19:08:43 <greymalkin> For the moment, all I want is a simple mean and standard deviation, but I'm going to be expanding quickly.
19:10:06 <Cale> Perhaps http://hackage.haskell.org/package/statistics
19:10:28 <Cale> Anything maintained by bos is likely to be high quality :)
19:11:57 <Cale> http://hackage.haskell.org/package/statistics-0.10.5.2/docs/Statistics-Sample.html#v:mean
19:13:42 <Cale> greymalkin: ^^
19:14:44 <greymalkin> Yeah, it's installed, but I'm having a bear of a time figuring out what to import (Statistics.Distribution, but not finding it)... it doesn't help that this is the 4th haskell anything I've done
19:19:42 <levi> greymalkin: What do you mean by "but not finding it"? How are you trying to do the import and run your code?
19:20:27 <greymalkin> I think I'm getting it... I wasn't importing deep enough (just Statistics.Distribution instead of Statistics.Distribution.Normal)
19:23:21 <AlainODea> greymalkin: packages usually include an examples folder in their code. I find them extremely helpful. https://github.com/bos/statistics/tree/master/examples
19:23:25 <levi> OK, glad you're getting it figured out.
19:24:37 <AlainODea> greymalkin: Hackage provides home pages and source links which get you there. http://hackage.haskell.org/package/statistics
19:27:09 <levi> roboguy_: What kind of trouble are you having?
19:27:36 <roboguy_> levi: I think it's mostly because I'm not used to reading in pieces of binary data
19:28:00 <levi> roboguy_: Could be. How are you doing it now?
19:29:14 <roboguy_> levi: well, for example, my current code to get the operator number is opNum = fromBits . take 4 . reverse $ toListOf bits word32 where fromBits bs = 0 & partsOf bits .~ reverse bs
19:30:27 <Rarrikins> (.&. 0xf)
19:31:05 <roboguy_> Rarrikins: that's actually what I had originally, but it didn't work for some reason.
19:31:14 <roboguy_> actually, it was probably another part of the code that wasn't working
19:31:52 <levi> Hmm, I don't recall whether there's an endianness issue or not.
19:32:19 <roboguy_> levi: I think there is. the most significant bit is the leftmost bit
19:35:53 <enthropy> has anybody here used http://hackage.haskell.org/package/optimization-0.1.3/docs/Optimization-Constrained-Penalty.html ?
19:36:13 * enthropy isn't getting things to converge for a demo problem
19:36:33 <levi> roboguy_: Yeah, if you're on an x86 platform you'll have to do byte order swapping then, or at least take that into account when picking out the right bits.
19:37:19 <roboguy_> levi: well, I am reading it in in big endian using the binary package. would that account for endianness issues?
19:37:20 <Cale> greymalkin: If all you want are mean and stdDev of a vector of samples, likely the ones you want are in Statistics.Sample
19:39:01 <levi> roboguy_: The binary package should take care of that for you, yeah. Assuming you're using it correctly, of course. :)
19:39:39 <roboguy_> levi: haha, I *think* I am. I recursively read Word32s into a Seq using getWord32be
19:45:49 <Polarina> Would ghc ever optimize a State monad into something that mutates when it knows that the old result is never used again?
19:46:29 <startling> Polarina: I don't know. It's definitely a legal optimization though.
19:47:05 <Cale> Perhaps if you're lucky enough with inlining and strictness analysis/unboxing
19:47:27 <Cale> Occasionally it's able to do everything in registers
19:47:35 <Cale> But I wouldn't count on it
19:47:43 <startling> I wonder if you could do something like compile-time reference counting.
19:48:01 <Cale> Usually getting everything to work out perfectly requires a little bit of tweaking and explicit unboxing
19:50:31 <startling> I guess that's linear types
19:51:04 <levi> roboguy_: Hmm, I just looked through the network protocol handler I wrote with Data.Binary, but it doesn't do any bit-level stuff, all the fields are multiples of full bytes. But 'getWord32be' should do the byte order swapping you need.
19:53:38 <Cale> startling: Yeah, linear or uniqueness types can help give hints to where that optimisation might be good to apply
19:54:33 <roboguy_> levi: do you think I would need things to be swapped on a bit level too?
19:54:45 <startling> Cale: yeah.
19:57:18 <karnal> First attempt at coding in Haskell... I am going through Real World Haskell and I ran into a cryptic error message. Any help would be greatly appreciated.  http://lpaste.net/99675
19:57:32 <karnal> (error message in the code comments)
19:57:50 <levi> roboguy_: Not if you've already taken the whole Word32 to native byte order.
19:58:13 <startling> karnal, "1 + myLength $ xs" is "(1 + myLength) xs"
19:58:23 <levi> I wrote a VM for this problem while the contest was going on, but it's almost certainly lost to the mists of time now.
19:58:27 <karnal> ah...
19:58:31 <startling> karnal: oh, but that's not the error you're seeing
19:58:33 <karnal> let me try it out
19:58:50 <startling> karnal: line 4 should be mylength (_:xs) = ...
19:59:02 <roboguy_> levi: if everything is in the right order, "word32 .&. 0xf" would get the four most significant bits wouldn't it?
19:59:38 <karnal> awesome
19:59:48 <karnal> thanks startling!
20:00:01 <startling> karnal: no problem!
20:02:20 <levi> roboguy_: Nope, that'll give you the four least significant bits if you've got the word32 in native byte order
20:07:33 <roboguy_> right, I need to shift it right first
20:08:40 <levi> Left. :)
20:09:17 <levi> You want 0xf0000000 for the most significant bits.
20:11:30 <levi> When values are loaded into memory correctly, the way the architecture stores them is transparent to the programmer. So you just have to think in terms of numbers instead of ordered bits.
20:15:08 <roboguy_> levi: wait, I'm not sure I understand why it would be a left shift. if I have something like the byte 0xa1, a would be most significant nibble and I would want to shift it right to get that value wouldn't I?
20:15:27 <roboguy_> > 0xa1 `shiftR` 4
20:15:28 <lambdabot>  10
20:16:19 <Platz> hah, hateoas considered as a horrible breakfast cereal
20:23:53 <levi> roboguy_: Oh, you mean you're shifting before you're masking. I meant you'd left-shift the 0xf to get it in the right place to mask the MSB.
20:24:18 <roboguy_> levi: ahh
20:24:36 <levi> roboguy_: You've got the right idea, I think.
20:24:44 <roboguy_> well, it's working a *little* more. it's printing things now, but it's a little out of order and there's some kind of error happening
20:25:02 <roboguy_> the words in the output aren't garbled though, which is interesting
20:30:13 <levi> That's encouraging, anyway. :)
20:31:08 <roboguy_> yeah. all it's printing is "Index in 0-array fail", which is a bit cryptic though...
20:31:59 <roboguy_> unless that's actually the text it's supposed to print if the first test fails. hmm
20:36:55 <levi> Probably that's what's happening.
21:25:40 <Rotaerk_> hmm, if I have a typeclass:  class ContextOf component context where componentId :: context -> ComponentId
21:26:21 <Rotaerk_> and then I have a function:  foo :: (ContextOf Bar context, ContextOf Baz context) => context -> context
21:26:51 <Rotaerk_> is there a way, in that function implementation, to specify which instance of componentId I want to use?
21:27:19 <apples`> use a type annotation
21:27:35 <apples`> oh wait
21:28:28 <Rotaerk_> basically, if I want the component ID of the Baz, or the component ID of the Bar
21:29:09 <jle`> mm_freak_: is there any reason why you chose not to make Wire a monad?
21:29:13 <enthropy> so it's not a typo that `component' isn't used in the method?
21:29:31 <jle`> mm_freak_: do you not wnat to let people turn a wire of a wire into a wire?
21:29:38 <Rotaerk_> correct; I have other methods that do use it, but they're irrelevant to the problem
21:30:06 <jmcarthur> Rotaerk_: i'm surprised ghc even lets you define that type class
21:30:12 <Rotaerk_> hmm maybe it doesn't
21:30:25 <Rotaerk_> didn't occur to me that it might not; checking
21:30:34 <jmcarthur> Rotaerk_: i think it doesn't. you will have to use some sort of proxy value, i think
21:31:01 <jmcarthur> Rotaerk_: i would define the method like this:   componentId :: proxy component -> context -> ComponentId
21:31:13 <enthropy> it does accept that instance though
21:31:40 <jmcarthur> Rotaerk_: then you can use something like http://hackage.haskell.org/package/tagged-0.7/docs/Data-Proxy.html with it (or your own proxy value if one is already available)
21:31:43 <Rotaerk_> hmm yea, it compiled
21:31:46 <jmcarthur> huh
21:32:10 <jmcarthur> amazing, it does accept that
21:32:11 <enthropy> it's still helps to have the proxy though
21:32:17 <Rotaerk_> the other method in the typeclass is :  component :: Lens' context (component context)
21:32:19 <copumpkin> it'll accept it, but you can never call it
21:32:27 <copumpkin> as far as I'd guess
21:32:27 <enthropy> because writing type annotations to fix the ambiguous type are annoying
21:32:30 <jmcarthur> i see no reason it should allow it
21:32:42 <Rotaerk_> and I just rely on whatever I'm doing with the result of that "component" method, to resolve which one I mean
21:32:46 <copumpkin> I think I filed a bug about this years ago
21:32:49 <Rotaerk_> not so trivial with the componentId one
21:32:56 <copumpkin> about it letting you create useless classes
21:33:13 <jmcarthur> Rotaerk_: i stand by my proxy suggestion, regardless of the fact that ghc accepts your type class
21:33:17 <Rotaerk_> k
21:33:49 <Platz> is this the 'overlapping instances' or is that something else
21:34:12 <jmcarthur> Rotaerk_: it's worth noting that i made proxy lowercase in the method signature on purpose, btw
21:34:27 <copumpkin> this is just "there's no way for you to tell Haskell which instance you want"
21:34:38 <Rotaerk_> I'm not familiar with proxy at all yet, but I did notice that and wondered
21:35:07 <Rotaerk_> are you suggesting that I make proxy one of the parameters to the typeclass?
21:35:11 <jmcarthur> Rotaerk_: it means you can use type constructors other than just some specific one. for example, if you already happen to have a Maybe component around, you can just use that
21:35:13 <Platz> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/type-class-extensions.html#instance-overlap ?
21:35:23 <jmcarthur> Rotaerk_: no, just leave it totally polymorphic and unrelated to the type class
21:35:26 <Rotaerk_> ah
21:35:38 <Rotaerk_> hmm, didn't realize you could do that, for some reason
21:36:28 <Rotaerk_> I may do the same thing for my "component" member, even though I have ways of resolving it otherwise
21:36:31 <Rotaerk_> simply for readability
21:36:32 <jmcarthur> Rotaerk_: anyway, in the total absense of any other suitable values in scope, you just use (Proxy :: Proxy MyComponent) as the argument
21:36:46 <Rotaerk_> hmm interesting
21:37:42 <Rotaerk_> thanks for the suggestion
21:41:27 <enthropy> copumpkin: http://lpaste.net/99679 I guess you're right about that being pretty useless
21:41:56 <enthropy> but stuff like that paste should be allowed (which probably complicates that check)
21:43:49 <Rotaerk_> hmm think I'll leave my component and componentId members without proxy parameters
21:44:04 <Rotaerk_> and then I'll add some functions outside the typeclass which do take proxies
21:44:29 <Rotaerk_> that way I don't have to supply one in contexts where it's not needed
21:45:58 <enthropy> you missed the point that you can't write those functions outside the typeclass
21:47:18 <enthropy> unless you have a fundep (or the equivalent ~) | componentId -> component
21:47:59 <Rotaerk_> componentId isn't a type; there's ComponentId
21:48:03 <enthropy> Platz: you need two instances to have overlap
21:48:28 <enthropy> sorry, I mean   | context -> component
21:48:50 <Rotaerk_> ah, nope; there are multiple components in the context, just one per type of component
21:51:43 <Platz> enthropy: Ah yes theres just one instance, but the two constraints are using different type varibles
21:54:24 <jle`> is there any function maybeToEither :: e -> Maybe a -> Either e a
21:54:49 <jle`> maybeToEither e = maybe (Left e) Right
21:55:09 <jle`> hoogle says no but i feel like it would be useful
21:55:11 <jle`> oh well
21:55:49 <startling> jle`: yeah, there is
21:55:51 <startling> one sec
21:55:56 <startling> I think it's called "note"
21:56:13 <startling> yeah: http://hackage.haskell.org/package/errors-1.4.5/docs/Control-Error-Util.html
21:56:19 <levi> jle`: There's a bunch of stuff like that in the 'errors' package
21:56:21 <startling> not in base, but.
21:56:25 <startling> levi, jinx.
21:56:35 <levi> Heh.
21:58:55 <jle`> levi, startling: thanks :)
22:03:48 <Rotaerk_> http://lpaste.net/99680  confused about how this can compile
22:04:03 <carter> Rotaerk_: how are you confused?
22:04:04 <Rotaerk_> oh wait... nevermind, it's proxy, not Proxy...
22:04:19 <carter> also you never do an instance
22:04:25 <Rotaerk_> I was confused because "component" is *->*, but it was accepting it as a parameter of proxy
22:04:27 <carter> and class instances are resolved at the use sites
22:04:51 <Rotaerk_> but nevermind
22:05:06 <enthropy> bgamari_: is http://hackage.haskell.org/package/optimization-0.1.3/docs/Optimization-Constrained-Penalty.html supposed to work decently?
22:05:17 <enthropy> with the bfgs I tend to get NaNs coming up
22:05:18 <Rotaerk_> though it'd be nice if there were something like Proxy that worked on *->*'s
22:05:28 <carter> enthropy: thats a #numerical-haskell topic! :)
22:05:44 <carter> enthropy: one issue with AD is it does boxing
22:05:45 <enthropy> oh bgamari_ is there too
22:05:50 <carter> yup :)
22:08:04 <Rotaerk_> is it possible to make a type that operates like Proxy, but its type-argument is *->*?
22:08:30 <jle`> it's called `note`
22:08:34 <jle`> how interesting
22:08:44 <Rotaerk_> as is, I'll need to do:  componentId (Proxy :: Proxy (MyComponent context))
22:09:33 <Rotaerk_> I'll just make custom proxies... that's what I'll do
22:09:56 <Rotaerk_> componentId MyComponentProxy
22:26:54 <jle`> with lens
22:27:04 <jle`> how do i append/insert an item into a list
22:27:09 <jle`> that is held in a spot in a vector
22:27:15 <jle`> that is an element in a Map
22:29:34 <jle`> i guess i would use %something (at key).(indexaccessor i) (++ [elem]) ?
22:29:43 <jle`> or something :|
22:39:28 <jle`> oh you can use at for both
22:40:31 <jle`> how can i lense inside a Maybe?
22:40:51 <edwardk> _Just is a prism for Maybe's contents, traverse works as a traversal of ts contents
22:40:56 <edwardk> what do you want to do?
22:41:06 <edwardk> work with at?
22:41:18 <edwardk> for that you typically want 'non' to supply a default value
22:41:28 <jle`> well i want to change the content of an item inside a vector
22:41:38 <edwardk> > M.fromList [(2,3)] & at 4 . non 0 +~ 1
22:41:40 <lambdabot>  fromList [(2,3),(4,1)]
22:41:42 <edwardk> > M.fromList [(2,3)] & at 2 . non 0 +~ 1
22:41:44 <lambdabot>  fromList [(2,4)]
22:41:51 <jle`> and using %~ wants me a Maybe
22:42:13 <jle`> ah thanks
22:42:21 <edwardk> > M.fromList [(2,"hello")] & at 2 . non "" %~ ('c':)
22:42:23 <lambdabot>  fromList [(2,"chello")]
22:42:29 <edwardk> > M.fromList [(2,"hello")] & at 4 . non "" %~ ('c':)
22:42:30 <lambdabot>  fromList [(2,"hello"),(4,"c")]
22:43:09 <ddellacosta> Are constants (nullary data constructors) values, same as 1, "some string", etc.?
22:44:09 <startling> ddellacosta: ish.
22:44:30 <jle`> you can think of Int as data Int = ... 0 | 1 | 2 | 3 ... i think
22:44:48 <startling> ddellacosta, the biggest difference I can think of is that only particular values (constructors + some special things) may be pattern-matched against.
22:45:32 <jle`> edwardk: i can't seem to do it against Vector
22:45:39 <jle`> should i still be using at ?
22:45:53 <edwardk> lets see f vector is on lambdbot
22:46:26 <edwardk> :t M.fromList [(2,Data.Vector.fromList "hello")] & at 2 . non mempty %~ Data.Vector.cons 'c'
22:46:27 <lambdabot> (Num k, Ord k) => M.Map k (Data.Vector.Vector Char)
22:46:31 <edwardk> there you go
22:46:55 <jle`> i mean, a Vector of lists
22:47:02 <ddellacosta> startling: right...so, you can pattern-match against some constants as types, but use them in other cases as though they were values, is this a correct statement?
22:47:03 <edwardk> at here is talking about the map.
22:47:03 <jle`> and consing the nth list in that vector
22:47:09 <jle`> so no more map
22:47:21 <edwardk> will you always be accessing in bounds?
22:47:38 <jle`> edwardk: hm. what would it look like both ways?
22:47:42 <edwardk> e.g. a position that is present in the vector?
22:47:58 <edwardk> well, one way its doable with lens, the other you're on your own ;)
22:47:58 <ddellacosta> startling: not "some constants," but "all constants," rather
22:48:19 <edwardk> myVector & ix n %~ ('c':)
22:48:31 <edwardk> will modify the entry at position n in the vector
22:48:39 <edwardk> if it is present that is
22:48:50 <startling> ddellacosta: I'm not sure "constant" is a term that makes sense for haskell values.
22:48:51 <edwardk> otherwse it'll just give you back the old vector
22:48:55 <jle`> ah
22:49:05 <jle`> hm. what kind of things does at access?
22:49:10 <jle`> the At typeclass i'm guessing
22:49:13 <jle`> but is it always Maybe?
22:49:14 <edwardk> vectors, maps, lists, etc.
22:49:22 <startling> jle`: yes.
22:49:23 <edwardk> Ixed has more instances than At
22:49:29 <ddellacosta> startling: sorry, I'm using the terminology from this doc: http://www.haskell.org/haskellwiki/Constructor  (better to say "nullary data constructor" probably)
22:49:41 <jle`> Ixed is always not-maybe?
22:49:42 <startling> jle`: it's a lens on a Maybe rather than a traversal.
22:49:46 <startling> jle`: yeah.
22:49:48 <jle`> oh
22:49:56 <jle`> class Ixed m => At m
22:49:59 <edwardk> because i can always try to get you the 100th element of a list or fail, but if i hav a 30 element list i can't fill in out to 100 without changing answers for things i shouldn't and violating laws
22:50:15 <edwardk> ixed is a traversal so it can fail, at is a lens to maybe
22:50:38 <startling> the big difference is changing a Nothing to a Just.
22:50:45 <startling> At lets you do that.
22:50:47 <edwardk> to get a Maybe result out of ix you use   ^? ix n     to get one out of at you use ^. at n
22:50:48 <startling> Ix doesn't.
22:50:56 <ddellacosta> startling: in any case, the following section states exactly the answer to my question so nevermind...whoops.  Thanks for your help.
22:51:04 <startling> ddellacosta: haha, no problem.
22:51:09 <jle`> the idea of traversals being inherently failable...is that a lens traversals thing or is something universal abut traversals?
22:51:20 <edwardk> if you have 'at', then you could implement    ix n = at n . traverse
22:51:21 <startling> jle`: it's a universal thing about traversals
22:51:37 <startling> jle`, Applicative has pure, so you have a way to not-apply the given function
22:51:46 <edwardk> jle`: a traversal can visit 0 or more targets
22:51:47 <startling> jle`: whereas Functor only has fmap, so you have no such way.
22:51:59 <edwardk> jle`: when it visits 0 'it failed' in this sense
22:52:05 <startling> a lens must visit exactly one target.
22:52:35 <startling> I've been thinking about teaching lenses a lot, by the way.
22:52:43 <startling> I think starting with parametricity is the right way.
22:52:56 <edwardk> good! teach more =)
22:53:00 <startling> :)
22:53:09 <jle`> so ix is technically a traversal over 0 or 1 items?
22:53:15 <edwardk> yes
22:53:27 <edwardk> ix would be an 'affine' traversal if we had the type for it
22:53:29 <jle`> so it's not fail as in a error way, it's fail as in a [] or [x] way
22:53:36 <edwardk> yep
22:53:51 <startling> jle`: do you know what traversals look like?
22:53:57 <startling> type-wise.
22:54:15 <jle`> startling: nope.  i don't know too much past http://lens.github.io/tutorial.html
22:54:19 <edwardk> in general about a year and a half ago i decided to rip out all the lenses we had that would error and replace them with traversals, forcing th user to use ^?!   or singular to get the older lies
22:54:49 <jle`> what are the newer lies?
22:54:57 <edwardk> =P
22:55:23 <edwardk> the newer lie is that we got them all, there are a few things like unsafePartsOf that can fail
22:55:28 <startling> jle`: type Traversal s t a b = Applicative f => (a -> f b) -> s -> f t
22:55:53 <startling> jle`, because that constraint says Applicative, a traversal can take a function but never apply it.
22:55:54 * zRecursive Without using Lens, we can still program very well using haskell :)
22:55:55 <jle`> stab
22:56:37 <startling> i.e. \_ -> pure :: Traversal s s a a
22:56:45 <edwardk> :t ignored
22:56:46 <lambdabot> Applicative f => pafb -> s -> f s
22:56:57 <jle`> and...how would i get a Traversal?
22:57:02 <jle`> :t (ix 1)
22:57:03 <lambdabot> (Num (Index m), Indexable (Index m) p, Ixed f m) => p (IxValue m) (f (IxValue m)) -> m -> f m
22:57:06 <edwardk> > ([],1,2,4)^?ignored
22:57:07 <startling> jle`, you write it (or derive it)
22:57:07 <lambdabot>  Nothing
22:57:10 <jle`> oh that's pretty
22:57:26 <jle`> startling: when would i work with a Traversal in real life?
22:57:29 <edwardk> M.fromList []^?ix 1
22:57:32 <startling> :t ix 1 :: Traversal [a] [a] a a
22:57:32 <edwardk> > M.fromList []^?ix 1
22:57:33 <lambdabot> Applicative f => (a -> f a) -> [a] -> f [a]
22:57:34 <lambdabot>  Nothing
22:57:34 <jle`> like, how do i get somethjing of the Traversal type
22:57:40 <startling> jle`, "ix 1" is one
22:57:40 <jle`> ah i see
22:57:49 <edwardk> > M.fromList [(1,2)]^?ix 1
22:57:51 <lambdabot>  Just 2
22:57:54 <startling> it's just written way more abstractly than it needs to be. :)
22:58:02 <edwardk> > M.fromList [(1,2)] & ix 1 .~ 100
22:58:03 <startling> this is a common pattern in lens.
22:58:04 <lambdabot>  fromList [(1,100)]
22:58:12 <jle`> super generalization?
22:58:15 <zRecursive> @hoogle traversal
22:58:16 <lambdabot> No results found
22:58:17 <startling> yeah.
22:58:26 <startling> jle`, so
22:58:31 <edwardk> "than it needs to be" is perhaps someting i might take issue with, but i'll roll with it ;)
22:58:34 <Platz> :t Data.Traversable.traverse
22:58:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:58:41 <startling> > ix 1 Just [1, 2, 3]
22:58:43 <lambdabot>  Just [1,2,3]
22:59:00 <startling> ^ jle`: do you see what's happening, sort of?
22:59:23 <edwardk> :t traverse Just [1,2,3]
22:59:24 <lambdabot> Num b => Maybe [b]
22:59:26 <edwardk> > traverse Just [1,2,3]
22:59:27 <lambdabot>  Just [1,2,3]
22:59:27 <jle`> Just is our a -> f b
22:59:32 <startling> jle`: right.
22:59:35 <jle`> s is our ...?
22:59:38 <nolrai66> So how should I decide between the packages "units", "unittyped", "dimensional" and "dimensional-tf'?
22:59:44 <jle`> [1,2,3] is our s, but what is s?
22:59:52 <jle`> the thing to be traversed over?
22:59:55 <startling> jle`, just the structure we're traversing
22:59:56 <startling> yeah
23:00:08 <edwardk> nolrai66: by trying them all and reporting back your findings before you expire to save the next person the pain
23:00:22 <nolrai66> Okay.
23:00:33 <jle`> what is ix then
23:00:43 <jle`> Int -> Traversal stab ?
23:00:49 <edwardk> nolrai66: yours will be a long, painful existence, but you may bring light back to others. godspeed.
23:01:02 <startling> jle`, so the thing ix 1 specifies is a way to apply any such function to a part of the structure and then lift the rest of the data structure into the same Applicative as the function's result.
23:01:06 <edwardk> Int -> Traversal [a] [b] a b
23:01:15 <edwardk> well, several other types are possible
23:01:16 <edwardk> er
23:01:18 <startling> edwardk: I don't think that's right
23:01:19 <startling> yeah
23:01:20 <edwardk> Int -> Traversal [a] [a] a a
23:01:30 <jle`> i'm not sure what the 1 in the ix 1 is referring to here then
23:01:31 <edwardk> it can't change types
23:01:36 <edwardk> te index in the container
23:01:36 <startling> jle`, oh
23:01:43 <jle`> but the Just goes over the entire container?
23:01:48 <startling> > preview (ix 1) [0, 3, 6]
23:01:49 <lambdabot>  Just 3
23:01:57 <startling> > preview (ix 2) [0, 3, 6]
23:01:58 <lambdabot>  Just 6
23:01:59 <edwardk> > "hello" & ix 0 .~ 'j'
23:02:02 <lambdabot>  "jello"
23:02:20 <startling> jle`: no. pure goes over the entire container.
23:02:20 <nolrai66> :t &
23:02:21 <lambdabot> parse error on input `&'
23:02:26 <nolrai66> :t (&)
23:02:27 <lambdabot> a -> (a -> b) -> b
23:02:27 <startling> jle`: it just so happens that pure in this case is Just
23:02:31 <edwardk> > ix 0 Left "hello"
23:02:34 <lambdabot>  Left 'h'
23:02:38 <edwardk> > ix 4 Left "hello"
23:02:40 <lambdabot>  Left 'o'
23:02:42 <startling> > ix 1 (\n -> Just (n + 2)) [0, 1, 2]
23:02:44 <edwardk> > ix 400 Left "hello"
23:02:44 <lambdabot>  Just [0,3,2]
23:02:45 <lambdabot>  Right "hello"
23:03:30 <edwardk> ix k    will apply the applicative action to the target of the traversal, and glue the rest of the structure back on around it
23:03:34 <jle`> ah
23:03:36 <jle`> i see
23:03:43 <jle`> that's...interesting
23:04:03 <jle`> i never even considered that kind of operation
23:04:04 <edwardk> with my Left examples above if it found it, it ran an action that 'failed' into the Left case of the Either Applicative
23:04:11 <startling> jle`: it's an interesting operation.
23:04:14 <edwardk> but if it didn't find it it used Right to glue it back together
23:04:17 <startling> jle`: n.b. this is not just a lens thing
23:04:30 <startling> jle`, Data.Traversable in base has a class a la Functor for it.
23:04:47 <jle`> nota bene
23:04:55 <startling> yeah. :)
23:05:00 <jle`> what would this look like using normal functions?
23:05:12 <startling> jle`: we could write traverse for lists.
23:05:16 <startling> :t traverse
23:05:17 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:05:19 <edwardk> 'over' takes a function and maps it over any lens, traversal, setter, etc.
23:05:40 <edwardk> > over (ix 3) succ "hello"
23:05:42 <lambdabot>  "helmo"
23:05:43 <startling> :t traverse :: Traversable s => Traversal (s a) (s b) a b
23:05:44 <lambdabot> (Applicative f, Traversable s) => (a -> f b) -> s a -> f (s b)
23:06:10 <edwardk> over l f = runIdentity . l (Identity . f) -- can be worked out
23:06:34 <jle`> thanks guys :) i got to go now but i appreciate the help
23:06:41 <startling> jle`: no problem!
23:06:42 <edwardk> > over both succ (3,4)
23:06:44 <lambdabot>  (4,5)
23:06:44 <jle`> never thought of even looking into the types
23:06:54 <jle`> past the utility of the operators/accepting the magic
23:07:06 <startling> jle`: yeah, it's definitely a trip when you do. :)
23:07:09 <edwardk> they are 'bad', but they aren't _too_ bad if you are persistent there is structure in there
23:07:26 <startling> honestly lens wasn't very usable for me until I looked at the types.
23:07:32 <edwardk> and it really does in the long term give you an understanding of how the whole thing hangs together
23:07:38 <startling> exactly.
23:08:18 <zRecursive> Does Lens slow down haskell program ?
23:08:32 <startling> zRecursive: it tries not to.
23:08:49 <startling> it probably does in some cases.
23:08:49 <zRecursive> tries?
23:08:54 <edwardk> zRecursive: for most cases involving concrete applications of known lenses to known operators it is as fast as the original or faster. for a few cases there can be some slowdowns
23:09:09 <startling> compile times, on the other hand ...
23:09:49 <edwardk> zRecursive: e.g. Data.Text.Lens offers a 'text' traversal. that one combinator plays the role of more or less the entire Data.Text API with hundreds of functions, it can be ~30% slower though.
23:09:51 <zRecursive> more code to be produced ?
23:10:09 <startling> zRecursive: lots of dependencies.
23:10:15 <startling> TH is not very good for compile times either.
23:10:51 <edwardk> zRecursive: now you can remember all the functions in text, or the one combinator and a bunch of things that work with everything. if you _really_ need the speed, you can go back and swap in a few others e.g. 'setting Text.map' or someting when you don't need the full traversal lens gives you, and eke back out most of that speed
23:11:18 <edwardk> but in general we've been working to make it so that we give you a surprising amount of speed while still remaining flexible.
23:11:44 <edwardk> and for most users we've probably done more work optimizing lens than anything else in their codebase, so its usually a net win ;)
23:12:35 <startling> it's definitely worth it for most things I've tried using it for.
23:14:24 <zRecursive> edwardk: 30% is big
23:15:05 <edwardk> zRecursive: and we win by 30%, 50% 80% in other cases.
23:15:19 <edwardk> zRecursive: i'm giving a sense of the range
23:15:40 <edwardk> zRecursive: it isn't always a win, but it isn't going to cost you an order of magnitude
23:15:53 <startling> zRecursive: so, write it using the lens combinators first, benchmark, and switch to the ugly stuff later if it's necessary. :)
23:15:55 <edwardk> but it may save you one
23:18:22 <codygman> Does -Wall warn about monads which don't follow the monad laws?
23:19:23 <adelbertc> i don't think the compiler can do that for you can it? you'll have to make do with quickcheck
23:19:30 <adelbertc> or proving via coq or something
23:19:44 <codygman> adelbertc: Ok, that's fine. I was just wondering.
23:31:37 * hackagebot pcre-utils 0.1.2 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.2 (SimonMarechal)
23:43:27 <gobo> hey guys I was wondering why ' map (-3) [1,3,3]' is wrong?
23:45:03 <Feuerbach> gobo: because -3 parses as a number
23:45:07 <Feuerbach> use subtract instead
23:45:14 <Feuerbach> map (subtract 3) ...
23:45:49 <gobo> Feuerback : thanks
23:51:39 * hackagebot reducers 3.10.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.2 (EdwardKmett)
23:54:56 <orzo> hi, could somebody comment on: http://jerkface.net/~joe/ConduitQueue.html
23:55:18 <Hafydd> or ((-) 3) or (- (3))
23:55:32 <Hafydd> Er... the first one is false.
23:55:38 <Hafydd> flip (-) 3
23:56:46 <Hafydd> or (-3 +)
23:59:12 <milfjord> :t (-3 +)
23:59:13 <lambdabot> Num a => a -> a
