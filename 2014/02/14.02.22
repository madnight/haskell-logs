00:00:05 <mm_freak> triliyn: yes
00:00:10 <mm_freak> x -> y = y^x
00:00:15 <zzo38> triliyn: Yes, it works quite like that
00:00:22 <triliyn> Is it at all significant that dependent function arrows are multiplication and dependent tuples are addition? Or am I seeing things similarities that are not really there?
00:00:42 <dmwit> Significant in what sense?
00:00:49 <zzo38> It applies to logic, to category theory, to natural numbers...
00:01:11 <triliyn> Moving from independent to dependent almost feels like taking a derivative of the type system
00:01:24 <triliyn> or wait, no
00:01:34 <triliyn> Derivative doesn't reduce exponentiation to multiplication...
00:01:34 <mm_freak> triliyn: you shouldn't confuse "multiplication" with "product" here…  it's an algebraic product
00:01:35 <triliyn> never mind
00:02:11 <triliyn> mm_freak: independent product types seem to have a lot of similarities to multiplication though
00:02:13 <Hafydd> What is the current time-derivative of Haskell's type system?
00:02:25 <mm_freak> view it this way:  a dependent sum takes the left side as an index that specifies the right side
00:02:29 <dmwit> Hafydd: 3
00:02:43 <mm_freak> given index 3 you get f 3 for the right side
00:02:47 <hagger> hey guys,I as wondering asto where is the accumulator term in the following : scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
00:02:58 <triliyn> Right
00:02:59 <mm_freak> altogether you get f 0 + f 1 + f 2 + f 3 + f 4
00:03:19 <mm_freak> if the dependent sum is not dependent, then you get:  f _ + f _ + f _ + f _ + f _ = 5 * f _
00:03:20 <zzo38> mm_freak: O, like the Sigma operator?
00:03:29 <mm_freak> that's how the dependent sum becomes the independent product
00:03:31 <triliyn> hmm
00:03:43 <mm_freak> zzo38: ?
00:04:18 <zzo38> mm_freak: Like the Sigma operator with x=0 on bottom, 4 on top, and f x on the right side, I mean.
00:04:19 <dmwit> hagger: What is an accumulator term, and what makes you think there should be one in there? =)
00:04:20 <mm_freak> triliyn: the same idea works for dependent product…  if it's an independent product, it's an exponentiation
00:04:21 <triliyn> This actually feels a lot like integration
00:04:34 <mm_freak> triliyn: very loosely =)
00:04:38 <triliyn> Which only tickles my previous calculus-y intuitions further
00:04:54 <triliyn> Algebra of types seems really cool
00:04:54 <mm_freak> zzo38: pretty much!
00:05:04 <hagger> dmwit : em isn't eh type definition (a->b->a) -> a ->[b] -> a
00:05:10 <mm_freak> triliyn: consider (x : 3) -> f x
00:05:16 <zzo38> Is that why they call them sigma-types then?
00:05:24 <mm_freak> where 3 is a type with constructors A, B and C
00:05:47 <dmwit> hagger: I don't think so. But suppose it were; where should we go from there?
00:05:49 <mm_freak> that's f A * f B * f C
00:06:05 <triliyn> Right
00:06:06 <mm_freak> if f is constant, then it's f A * f A * f A = (f _)^3
00:06:27 <mm_freak> that's how dependent product becomes independent power
00:06:33 <hagger> dmwit : well .. em isn't one parameter missing if nothing else ?
00:06:43 <mm_freak> zzo38: yes
00:06:51 <triliyn> hmmm
00:06:58 <zzo38> And I can see how is dependent product type working too due to such a case, which are called pi-types. Now it makes sense to me too!
00:06:58 <dmwit> hagger: Ah, you mean the type of the scan? Perhaps you didn't notice the "1" at the end. =)
00:07:01 <dmwit> hagger: Compare:
00:07:03 <dmwit> :t scanr
00:07:04 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
00:07:05 <dmwit> :t scanr1
00:07:06 <lambdabot> (a -> a -> a) -> [a] -> [a]
00:07:10 <triliyn> Dependent product doesn't seem to have a corresponding calculus thingy
00:07:16 <triliyn> Riemann products would be silly
00:07:17 <bahamas> hi, guys. what learning resource do you recommend for experienced programmers? I have limited experience with functional programming (a bit of erlang) and more with imperative
00:07:30 <mm_freak> and that's also why dependent products are sometimes written as the product sign =)
00:07:37 <triliyn> And indeed, in all the trivial places they'd diverge
00:07:41 <dmwit> bahamas: I recommend The Gentle Introduction.
00:07:42 <triliyn> Or go to zero
00:08:24 <dmwit> bahamas: It is Gentle iff you are already a programming languages expert (meaning an expert in the field called programming languages, not an expert in many programming languages).
00:08:35 <dmwit> bahamas: But it is precise, and concise, and I like both of those things.
00:08:40 <hagger> dmwit : omg you mean the '1' at the of 'scan1 ' ?
00:08:43 <mm_freak> bahamas: and just to have two opinions i recommend LYAH, if you had little exposure to functional programming =)
00:08:46 <triliyn> mm_freak: thanks for explaining that! It is nearly so beautiful an idea as to eclipse all the rest of my day, which was already going pretty well
00:09:07 <mm_freak> =)
00:09:26 <bahamas> dmwit: ok, I don't know if I can call myself a programming languages expert, but I'll try your suggestion
00:09:46 <zzo38> bahamas: Do you have experience with mathematics? You can learn Haskell whether or not you have experience with mathematics.
00:09:46 <bahamas> mm_freak: yes, I know about LYAH. I'll keep it in mind
00:09:51 <dmwit> LYAH, then RWH, seems to be a pretty popular route these days.
00:10:08 <bahamas> zzo38: I studied maths in highschool, but I don't remember much
00:10:12 <hagger> :t scan1
00:10:15 <lambdabot>     Not in scope: `scan1'
00:10:15 <lambdabot>     Perhaps you meant one of these:
00:10:15 <lambdabot>       `scanl' (imported from Data.List),
00:10:21 <hagger> :t scanl
00:10:22 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
00:10:46 <hagger> :t scanl1
00:10:47 <lambdabot> (a -> a -> a) -> [a] -> [a]
00:11:02 <dmwit> bahamas: I read the Gentle Intro before I had studied the field of programming languages at all. It's doable, and fun.
00:11:13 <dmwit> bahamas: I was just warning you that it wouldn't be Gentle, that's all. =)
00:11:22 <zzo38> bahamas: Then that probably doesn't count, but like I said it is OK either way.
00:11:25 <startling> bahamas: oh hey
00:11:41 <zzo38> So don't worry about it if you know much of mathematics or not.
00:12:03 <bahamas> startling: hey
00:12:24 <bahamas> I'm finally getting around to starting on the haskell path :)
00:12:39 <dmwit> ?where tutorials
00:12:39 <lambdabot> http://haskell.org/haskellwiki/Tutorials
00:12:42 <zzo38> But it can help a bit to know what everything means in Haskell, other than just in terms of how to write the program, to know some of mathematical things. It isn't necessary, though.
00:12:44 <startling> bahamas, yeah, the gentle introduction is nice but not very gentle. I think you're already familiar with LYAH? (I think you mentioned it to me in the first place? ;)
00:13:16 <startling> honestly for me this channel has been the best resource for learning Haskell.
00:14:07 <mm_freak> i've learned haskell on the haskell road to logic =)
00:14:09 <bahamas> startling: yeah, I did. I was curious if there was something more compact. I will take a look at the non-gentle gentle introduction
00:14:24 <mm_freak> it's even less gentle than the gentle intro, but it was fun =)
00:14:33 <bahamas> and freenode is great
00:15:50 <startling> bahamas, it's definitely compact. LYAH kind of drags on towards the middle in my experience (but it's useful sometimes to pick at).
00:16:33 <mm_freak> bahamas: haskell is sufficiently different that most people relearn programming in haskell…  in other words, a quickstart tutorial or reference manual won't be enough
00:16:44 <startling> ^ this is a good point
00:16:46 <zzo38> For example, if you look at https://en.wikipedia.org/wiki/Monad_(category_theory) you can see what a monad is, but you don't need to know any of that to program in Haskell (and I don't know if you get confused due to such things). Nevertheless, it is there in case you are interested.
00:16:59 <triliyn> LYAH is also adorable but of course that doesn't automatically make it the best way to learn
00:17:05 <hagger>  scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
00:17:20 <hagger> >  scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]
00:17:21 <startling> getting used to writing haskell has been way more of a journey than /learning/ it, if that makes sese.
00:17:22 <lambdabot>  [3,4,5,5,7,9,9,9]
00:17:42 <dmwit> The Ruby guide that LYAH is based on absolutely killed my interest in learning Ruby, and so I have purposely avoided reading LYAH at all.
00:18:02 <dmwit> The cutesy stuff and wacked out samples were just too much for me.
00:18:06 <startling> dmwit, is it based on the poignant guide?
00:18:12 <dmwit> That one, yes.
00:18:21 <zzo38> startling: That makes sense to me, at least.
00:18:31 <hagger> in  scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1] , acc is 1 right ?
00:18:41 <startling> me too. I've never been convinced that the poignant guide was a good way to learn ruby, yeah.
00:18:41 <mm_freak> dmwit: except for the dinkiness LYAH is a good resource as far as i can tell
00:18:52 <startling> I do like it a lot though.
00:19:09 <mm_freak> and yeah, what turned me off of ruby was ruby, not the way to learn it =)
00:19:23 <zzo38> Yes, but do you use similar ways to learn SQL?
00:19:23 <dmwit> Yes, I'm superficial.
00:19:42 <bahamas> I will use LAYH to setup my environment and then complement it with the gentle guide. the latter doesn't say a word about it apparently
00:19:53 <dmwit> hagger: Well, the function (\acc x -> ...) gets called many times, and the first argument is not 1 in all of those calls.
00:20:03 <startling> bahamas: what operating system are you on?
00:20:14 <hagger> dmwit : that is what I don'tget
00:20:15 <dmwit> hagger: (In fact, I don't think the first argument is 1 in any of those calls.)
00:20:17 <mm_freak> SQL was weird until i learned relational algebra, at which point i understood that SQL is just a broken instance of it =)
00:20:19 <bahamas> startling: ubuntu 12.04
00:20:34 <mm_freak> and then the sensible subset of SQL started making sense =)
00:20:54 <bahamas> I actually have haskell installed, but I did it some time ago. I want to see if there's anything I need to upgrade
00:21:04 <startling> bahamas: mainly you need to install ghc. typically people use cabal to install things from hackage but occasionally people prefer OS packages. reading a cabal sandbox introduction might be useful.
00:21:31 <mm_freak> bahamas: for learning it probably doesn't matter that much, but you may want to upgrade anyway:  just install the latest haskell platform
00:21:32 <bahamas> startling: cabal sandbox sounds like the equivalent of virtualenv
00:21:34 <dmwit> Don't learn cabal before Haskell. cabal is so much less beautiful than Haskell. =(
00:21:34 <zzo38> mm_freak: What do you call the sensible subset of SQL? Is it SQLite?
00:21:36 <startling> bahamas: it is.
00:21:52 <startling> dmwit: you usually need to, alas. :(
00:22:05 <mm_freak> zzo38: the subset modulo multisets that is covered by relational algebra
00:22:05 <bahamas> cool. I want to discover these equivalents
00:22:17 <mm_freak> relational algebra uses regular sets, and rightly so!
00:22:24 <mm_freak> SQL is multiset-based
00:22:52 <dmwit> hagger: Well, how can I help you get it?
00:23:02 <dmwit> hagger: We could look at the implementation of scanl1, if that would help.
00:23:31 <dmwit> And try to reduce your example code "by hand" so to speak.
00:25:00 <zzo38> mm_freak: Yes, it is multiset-based, I suppose. I find SQLite good enough; it is unusual compared to other programming languages but works very well for some things, much better than anything else I see.
00:25:19 <startling> I wouldn't call sqlite a subset of sql.
00:26:01 <mm_freak> zzo38: sqlite is worse than everything i have ever seen…  it is slow, locked, stringly typed (i thought you like type safety!)
00:26:04 <zzo38> startling: Yes you are correct it is actually one kind of SQL
00:26:13 <mm_freak> generally SQL gets relational algebra wrong, but then comes sqlite, which gets even SQL wrong…
00:26:21 <mm_freak> you can't get any worse than that, sorry
00:26:58 <zzo38> SQLite is efficient for small databases.
00:27:11 <mm_freak> have you benchmarked it?
00:27:17 <zzo38> Not for large ones, though.
00:27:27 <hagger> : dmwit : I kinda get the output just dealwith state of the acc term , and the lamda functon affects the state of acc.. but wht was the first acc? 1?
00:27:31 <mm_freak> i mean in comparison to, well, pretty much everything else ;)
00:27:33 <zzo38> mm_freak: I haven't, but the people who wrote it have.
00:28:07 <mm_freak> zzo38: everything is fast in a benchmark, if there is no competition
00:28:08 <zzo38> I don't really like the procedural SQL stuff though
00:28:50 <dmwit> ?src scanl1
00:28:50 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
00:28:50 <lambdabot> scanl1 _ []     =  []
00:28:59 <dmwit> ?src scanl
00:28:59 <lambdabot> scanl f q ls = q : case ls of
00:28:59 <lambdabot>     []   -> []
00:28:59 <lambdabot>     x:xs -> scanl f (f q x) xs
00:29:17 <zzo38> SQLite doesn't have any, but it isn't really needed, especially now that it has recursive queries
00:29:25 <dmwit> hagger: From this, you can see that the first call to the function supplies the head of the list as the first argument.
00:29:30 <zzo38> And recursive triggers
00:30:51 <hagger> dmwit : how does one view source on ghci ?
00:30:55 <zzo38> mm_freak: O, yes, it is correct. But, it does have some advantages (and disadvantages) over other systems. It is a smaller program, and can store the database in one file, without needing to run a SQL server. In some cases this is the way you would want it to be. In other case, you don't!
00:31:06 <zzo38> hagger: As far as I know, you don't.
00:31:26 <dmwit> hagger: scanl1 (\acc x -> ...) [3,4,5,3,7,9,2,1] = scanl (\acc x -> ...) 3 [4,5,3,7,9,2,1] = 3 : scanl (\acc x -> ...) ((\acc x -> ...) 3 4) [5,3,7,9,2,1]
00:31:32 <mm_freak> zzo38: i never bought the single-file argument
00:31:36 <dmwit> hagger: I don't think you can, unfortunately.
00:31:45 <mm_freak> zzo38: and if you reject that premise, then sqlite is useless
00:31:59 <zzo38> mm_freak: Well, if it is useless to you, then don't use it!
00:32:09 <hagger> dmwit : oh cool , but understood that from lamdabot given source. that sucks ..
00:32:16 <zzo38> But to me, that part, as well as other things about it, are very useful.
00:32:41 <dmwit> zzo38: Why is one file useful?
00:32:44 <zzo38> Now, using recursive triggers, you can make a Mandelbrot Set.
00:33:11 <mm_freak> zzo38: i don't…  i use acid-state, no non-haskell dependencies and sometimes orders of magnitude faster than sqlite ;)
00:33:16 <dmwit> (I don't know enough to have an opinion one way or another.)
00:33:22 <simpson> One relocatable, versioned, transferable file...
00:33:46 <dmwit> simpson: relocatable, versioned, transferable I understand. one file I do not understand
00:33:54 <mm_freak> simpson: an acid-state checkpoint is also a single file
00:34:05 <zzo38> mm_freak: Yes it can certainly be faster than SQLite.
00:34:23 <mm_freak> zzo38: s/can/is/, acid-state is about as fast as you can get
00:34:25 <zzo38> I don't know what a "acid-state checkpoint" is.
00:34:28 <simpson> mm_freak: There are *many* reasons to use SQLite, but I just realized the folly of the discussion and know that I can't convince you of things.
00:34:35 <mm_freak> because it's as fast as the underlying data structure that you use
00:34:57 <mm_freak> simpson: try it
00:35:26 <simpson> mm_freak: Proposition: There are languages that are not Haskell that are appropriate for real-world general-purpose programming at a variety of scales for a variety of purposes.
00:35:57 <zzo38> I program in many different programming languages actually, including, but not limited to, Haskell. I program in C as well.
00:36:04 <mm_freak> agreed
00:36:25 <simpson> Then it immediately follows that acid-state can't cover the use case of a system that is not crafted totally in Haskell.
00:36:38 <mm_freak> agreed
00:36:46 <zzo38> And in SQL, AWK, BASIC, TeX, FurryScript, etc...
00:37:02 <zzo38> And 6502 assembly language.
00:37:18 <simpson> So now the burden of proof's back on you to explain why SQLite is the worst; you only put forth acid-state.
00:37:29 <simpson> That's all; I'm going to bed. :3
00:38:39 * dmwit feels unconvinced and a bit confused
00:39:06 <mm_freak> simpson: sqlite is stringly typed, slow and exclusive-locked…  i wonder which interoperability scenario you /want/ to cover using sqlite without introducing a pile of additional points of failure
00:39:41 <mm_freak> even if acid-state is not applicable, sqlite feels like the worst choice you could make
00:40:14 <zzo38> I don't use SQLite in multi-user mode.
00:42:01 <mm_freak> with sqlite there is virtually no way to guarantee data consistency without implementing everything in every application you write plus guaranteeing that they agree with each other
00:42:31 <mm_freak> it's a mess, and sorry, but sqlite is a pile of crap that began as a good idea, but quickly took the wrong route
00:43:24 <zzo38> mm_freak: I do not completely understand what you mean by that. Just write the file in SQL itself, and/or use it as a software library providing data storage, embedded scripting, and a lot of other functions you would use.
00:43:48 <mm_freak> zzo38: your application expects an integer, another application writes a string or a float
00:44:27 <zzo38> mm_freak: SQLite does support CHECK constraints, but even disregarding that, I don't know why you would write such an application anyways.
00:44:56 <mm_freak> zzo38: simpson's argument was interoperability, so it's not /you/ that writes the application
00:45:04 <zzo38> But if someone does write data in the wrong format, that is their own fault, just as if any other file format!
00:45:46 <mm_freak> zzo38: yeah, and if someone writes 512 bytes into a 256 byte buffer in C, it's their own fault…
00:45:56 <zzo38> mm_freak: Yes, that too.
00:46:21 <zzo38> (Assuming that it is documented or known in the same file)
00:46:26 <mm_freak> zzo38: that was sarcasm
00:46:30 <mm_freak> assuming, assuming, assuming, …
00:47:46 <Adeon> I'm assuming that there will be large amounts of assumptions about assuming
00:47:56 <zzo38> Anyways, when I use SQLite it is usually standalone, sometimes using extensions written in C, although the main program is written in SQL, generally. (I do use it as a software library too, though)
00:48:23 <zzo38> I use it for a lot of statistical stuff especially
00:49:51 <zzo38> Locks are irrelevant since I always use it in single-user mode (although I believe it does support some level of locks if you need them)
00:51:28 * hackagebot asn1-encoding 0.8.1.3 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-encoding-0.8.1.3 (VincentHanquez)
00:51:30 * hackagebot x509 1.4.8 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.8 (VincentHanquez)
01:40:51 <ponce__> is it possible to have control over allocations and SIMD in haskell?
01:41:17 <startling> ponce__: there's a handful of approaches
01:41:48 <startling> (but yes, trivially so -- you can do that all from IO)
01:42:20 <startling> there's some work on nice auto-simd stuff, too.
01:43:14 <ponce__> I think I get what you mean for allocations (just use a typeclass Allocator or something)
01:43:21 <ponce__> but I'm more interested in explicit SIMD
01:43:31 <ponce__> like intrinsics and that sort of stuff
01:44:57 <ponce__> though sometimes in C++ letting the compiler do it turns out better
01:56:52 <c_wraith> What the heck.  I just rewrote operational in terms of free and kan-extension in about 15 lines.  How the heck is the free-operational package *so* complicated in comparison?
01:57:32 <c_wraith> Well, ok, I didn't reimplement any of the view stuff.  I guess that's a lot of the code.
01:58:19 <shachaf> Isn't operational just Free . CoYoneda?
01:58:25 <c_wraith> yes
01:58:36 <c_wraith> why is Coyoneda in kan-extensions?
01:59:05 <shachaf> It's a left Kan extension.
01:59:21 <c_wraith> I'm sure many things are Kan extensions that aren't in that package.
01:59:31 <shachaf> (Then again, what isn't?)
01:59:34 <shachaf> Right.
02:00:12 <c_wraith> I'm not using the fact that it's a kan extension.  I'm just using the fact that it's an existential wrapper around a function and a value.
02:00:44 <c_wraith> And happens to have Functor and Monad instances.
02:00:59 <shachaf> Monad?
02:01:08 <c_wraith> Hmm.  I'm not actually using the Monad instance.
02:01:13 <c_wraith> Just the Functor instance.
02:01:22 <c_wraith> the Monad instance in iterM is chosen by the user
02:02:04 <shachaf> I don't think Coyoneda f is a monad in general.
02:02:10 <c_wraith> You're right.
02:02:21 <c_wraith> It needs f to be a monad
02:02:22 <shachaf> It is when f is, I guess.
02:03:12 * shachaf is typing on a phone... Very slow.
02:03:40 <shachaf> Anyway, when f is a functor, Coyoneda f ~~ f.
02:04:00 <c_wraith> of course, in operational, f usually isn't a functor
02:04:38 <shachaf> Right. But you get the monad instance from Free.
02:04:56 <c_wraith> and the Functor that Free needs from Coyoneda
02:05:52 <c_wraith> though I'm actually using F, rather than Free - I'm not ever examining the structure.  All I'm doing with it is running iterM
02:06:04 <shachaf> What's F?
02:06:09 <c_wraith> Church-encoded
02:06:25 <c_wraith> via Control.Monad.Free.Church
02:07:26 <shachaf> (f r -> r) -> (a -> r) -> r style?
02:07:30 <c_wraith> yes
02:07:42 <c_wraith> args in the other order
02:07:44 <c_wraith> But whatever
02:08:57 <c_wraith> Heh.  After some cleanup, the full file, with plenty of whitespace, is 20 lines.
02:09:08 <hvr> brand new bikeshedding opportunity at  http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/21157 -- grab it while it's hot!
02:09:13 <c_wraith> I'm glad I don't have to understand how iterM works!
02:09:45 <shachaf> I wonder what operational (dis)advantage that gives you in itself.
02:10:02 <c_wraith> using F instead of Free?
02:10:15 <shachaf> Yes.
02:10:19 <Iceland_jack> hvr: “zeroBits” obviously :)
02:10:47 <hvr> Iceland_jack: post to the thread! :)
02:11:18 <shachaf> I should stop doing on a phone and go to sleep instead.
02:11:35 <c_wraith> Using F makes >>= associate to the right automatically, no matter what.  The downside is the representation is functions instead of constructors, so looking at the structure directly takes more work
02:12:01 <c_wraith> I actually asked edwardk about when to use F vs Free last night.  I hope I summarized his points accurately
02:12:08 <Iceland_jack> (alternatively “memsetZeroBits” to be in the spirit of bikeshedding) :)
02:12:14 <Iceland_jack> hvr: maybe I will!
02:12:15 <peterhil> geekosaur: I found Sound.Tomato.Speaker whichs lets me *easily* output some audio samples. I'll learn more of OpenAL/ALC later and forget about ALUT.
02:12:23 <shachaf> Just like DList etc., sure.
02:12:33 <c_wraith> yeah
02:12:35 <hvr> Iceland_jack: "memset" implies mutation imo
02:12:44 <shachaf> But you also get a similar effect from Coyoneda here.
02:12:54 <Iceland_jack> Yes but there needs to be one contrarian in every bikeshedding effort
02:13:26 <hvr> Iceland_jack: so it seems more balanced?
02:13:46 <Iceland_jack> Yes :)
02:14:41 <shachaf> And of course another option is Codensity . Free.
02:15:38 <c_wraith> shachaf: yes, though apparently the definition of F came out of edwardk's series "free monads for less", which showed that Codensity is stronger than necessary
02:16:03 <c_wraith> shachaf: and as such, went looking for a way to achieve the same results with a less powerful abstraction
02:16:04 <shachaf> "stronger" meaning bigger or something else?
02:16:18 <c_wraith> Yes, bigger.
02:16:44 <shachaf> Sure, it usually is.
02:20:20 * shachaf goes to sleep.
02:33:12 <the_berserker> @pl \a b -> a >>= \_ -> b
02:33:13 <lambdabot> (. const) . (>>=)
02:33:44 <Iceland_jack> @pl \a b -> a >> b
02:33:44 <lambdabot> (>>)
02:34:07 <Iceland_jack> @src (>>=)
02:34:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:34:23 <no-n> @src (+)
02:34:23 <lambdabot> Source not found. You untyped fool!
02:34:37 * no-n puts lambdabot inside lambdabot
02:34:40 <Iceland_jack> anyway
02:34:40 <Iceland_jack>     m >> n = m >>= \_ -> n
02:35:07 <Iceland_jack> the_berserker: So
02:35:07 <Iceland_jack>     \a b -> a >>= \_ -> b
02:35:07 <Iceland_jack> is the same as
02:35:07 <Iceland_jack>     \a b -> a >> b
02:35:12 <Iceland_jack> or
02:35:15 <Iceland_jack>     (>>)
02:39:48 <no-n> is there a ghc option to delete *.o and *.hi files after using them?
02:41:12 <syllogismos> what are those files anyway?
02:41:20 <Iceland_jack> object and interface files
02:41:39 <Iceland_jack> syllogismos: Object files are quite standard output of compilers
02:53:47 <Iceland_jack> no-n: http://stackoverflow.com/questions/1411089/how-to-stop-ghc-from-generating-intermediate-files
02:54:56 <no-n> Iceland_jack: thanks.
02:55:09 <no-n> I knew about -odir and -hidir but not -outputdir :3
03:32:29 <marunarkh> could anyone work with uni-htk?
03:33:08 <Axman6> what is uni-htk?
03:33:56 <troydm> Axman6: http://hackage.haskell.org/package/uni-htk
03:34:34 <Axman6> looks kinda old
03:38:19 <merijn> no-n: Why do you want to delete them anyway?
03:38:39 <no-n> 'cause they get in the way
03:38:45 <merijn> Of what?
03:38:53 <no-n> but having an output folder is fin
03:38:55 <no-n> fine *
03:39:13 <merijn> cabal by default builds in a different directory, keeping object files out of your working dirs
03:42:26 <skypers> hey
03:42:33 <skypers> I want to release something on hackage
03:42:42 <skypers> but I don’t want any license on it
03:42:57 <klrr> hmm, is there any reason not to use something like ClassyPrelude?
03:42:58 <skypers> it’s a little lib and I don’t want any restrictions
03:43:10 <skypers> oh
03:43:13 <skypers> 1) (none)
03:43:20 <skypers> I think it’s that :D
03:45:32 <Skola> I'm getting the following error when trying to install ncurses library on Mac OSX: http://lpaste.net/100265
03:45:58 <klrr> i see many projects explicitly importing lots of stuff which supposedly fits into the prelude, and while ClassyPrelude (for example) solves this i dont see anybody using it, is there any particular reason therefor?
03:46:32 <Axman6> Skola: what's on line 141 of /usr/include/string.h?
03:47:11 <Skola> char    *stpncpy(char *, const char *, size_t) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_4_3);
03:48:40 <Axman6> hmm
04:01:49 <klrr> [off-topic] how can you forkIO strictly? i mean if you pass `foo` to forkIO in a strict language doesnt it evaluate foo *before* it starts a new thread?
04:01:50 * hackagebot fixed-vector 0.6.3.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.3.0 (AlexeyKhudyakov)
04:02:50 <Saizan> klrr: in a strict impure language forkIO would take a nullary function
04:02:51 <mornfall> klrr: -evaluating- foo is usually not a problem, it evaluates to an IO computation
04:03:36 <Saizan> and you have parallel situation there, evaluating a nullary function is not the same as calling it with no arguments
04:06:15 <klrr> oh, thanks! that explains it
04:06:26 <klrr> evaluate != execute then?
04:06:33 <Axman6> yep
04:06:47 <Axman6> if they were the same, we could do IO in any function
04:07:57 <c_wraith> > putStrLn "hello" `seq` ()
04:07:59 <lambdabot>  ()
04:08:00 <skypers> huh
04:08:21 <skypers> what do I have to do with the license field in my .cabal if I want no license at all?
04:09:05 <c_wraith> set it to PublicDomain
04:09:17 <c_wraith> that's the closest you'll get to no license at all
04:09:31 <skypers> ok
04:09:33 <skypers> thank you :)
04:09:51 <skypers> huh
04:09:51 <skypers> 'ghc-options: -O2' is rarely needed. Check that it is giving a real benefit and not just imposing longer compile times on your users.
04:09:57 <skypers> this is a weird message :D
04:10:05 <skypers> rarely needed, seriously?!
04:10:20 <c_wraith> -O1 is the default, and picks up most optimizations.
04:10:42 <skypers> ok
04:10:51 <skypers> let’s upload that then!
04:11:51 * hackagebot monad-journal 0.1.0.0 - On-the-fly logging typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.1.0.0 (DimitriSabadie)
04:13:15 <no-n> @src fmap
04:13:15 <lambdabot> Source not found. :(
04:13:31 <Axman6> @src Maybe fmap
04:13:31 <lambdabot> fmap _ Nothing       = Nothing
04:13:31 <lambdabot> fmap f (Just a)      = Just (f a)
04:13:48 <no-n> ahhh
04:15:08 <klrr> is Text lazy or strict by default?
04:16:18 <Iceland_jack> @src [] fmap
04:16:18 <lambdabot> fmap = map
04:16:39 <klrr> oh nvm
04:17:49 <waldkauts> I have a problem using my already defined functions in happstack... http://pastebin.com/hAE9115L
04:18:21 <waldkauts> this is a real basic problem i guess, but i just started using haskell :)
04:19:03 <Iceland_jack> waldkauts: It seems like it's a problem of applying a function to an IO value?
04:19:38 <Iceland_jack> so if you have a function
04:19:38 <Iceland_jack>     f   :: a -> b
04:19:38 <Iceland_jack> and
04:19:38 <Iceland_jack>     val :: IO a
04:19:42 <Iceland_jack> you want something like?
04:19:45 <Iceland_jack>     f val :: IO b         -- (doesn't type check)
04:20:45 <Iceland_jack> In this case
04:20:45 <Iceland_jack>     getHtml   :: Either String QueryResult -> Html
04:20:45 <Iceland_jack>     getResult :: IO (Either String QueryResult)
04:21:30 <waldkauts> yes, i think thats the problem..
04:21:41 <Iceland_jack> okay so you want something like ‘fmap’ :)
04:21:48 <Iceland_jack> :t getLine
04:21:49 <lambdabot> IO String
04:21:51 <Iceland_jack> :t length
04:21:52 <lambdabot> [a] -> Int
04:21:54 <Iceland_jack> :t fmap length getLine
04:21:55 <lambdabot> IO Int
04:22:22 <Iceland_jack> Using that you can write
04:22:22 <Iceland_jack>     fmap getHtml getResult :: IO Html
04:22:32 <waldkauts> hmm ok
04:22:44 <waldkauts> i'll try that.. i think i really have to dig into the basics
04:22:51 <Iceland_jack> Yes possibly :)
04:23:11 <Iceland_jack> I mean you can also use do-notation
04:23:11 <Iceland_jack>     do line <- getLine
04:23:11 <Iceland_jack>        return (length line)
04:23:33 <Iceland_jack> or
04:23:33 <Iceland_jack>     do result <- getResult
04:23:33 <Iceland_jack>        return (getHtml result)
04:26:09 <marunarkh> uni-htk is a gui package, tcl/tk bindings for haskell
04:26:34 <marunarkh> like a wxHaskell
04:26:53 * hackagebot histogram-fill-binary 0.6.2.1 - Binary instances for histogram-fill package  http://hackage.haskell.org/package/histogram-fill-binary-0.6.2.1 (AlexeyKhudyakov)
04:31:34 <skypers> http://www.reddit.com/r/haskell/comments/1ymawa/monadjournal_onthefly_logging_from_any_monad/
04:31:51 <skypers> I’d like some feedback about that :)
04:36:56 <waldkauts> Iceland_jack: thanks, fmap solved the problem.. embarrassing that i couldn't figure it out
04:37:04 <Iceland_jack> No problem waldkauts :)
04:46:55 * hackagebot monad-journal 0.2.0.0 - On-the-fly logging typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.0.0 (DimitriSabadie)
04:58:29 <klrr> what is buffering?
04:58:48 <Axman6> storing some data before processing/sending it
04:59:11 <skypers> you have line buffering issues?
04:59:36 <Axman6> terminal output is often buffered until a new line is output, then the whole line is written
04:59:56 <klrr> so how does NoBuffering make it work?
05:00:19 <Axman6> it turns off buffering. no data is buffered before it's printed
05:00:39 <c_wraith> It can really slow things down, which is why there's buffering in the first place
05:00:43 <klrr> okey, and if we talk about input, what makes it differ from default?
05:01:02 <klrr> what makes it slow? anyway to prevent it?
05:01:09 <Axman6> text typed at the command line isn't send to the application until enter is pressed
05:01:21 <Axman6> in general command line apps are line buffered
05:01:45 <c_wraith> it's slow to not buffer because it makes more system calls.  the way to prevent that is to buffer.
05:02:15 <klrr> so buffering means basically "there is some special case which judge when/where we gonna stop reading and turn this input into a value"?
05:02:42 <klrr> okey, what is the reason the IRC bot here http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot uses NoBuffering then?
05:03:34 <mikeplus32> there isn't any good reason i can think of, they should have perhaps used LineBuffering
05:04:12 <Axman6> agreed
05:04:18 <klrr> so all buffering method would work? or does it change the way you deal with the Handle?
05:04:26 <Axman6> since, afaik, irc is a line based protocol
05:04:56 <mikeplus32> all buffering methods 'work', but have different uses. for irc, LineBuffering would be best
05:04:58 <klrr> okey, LineBuffering is the one i wanna use if i expect input to end by a newline ?
05:05:04 <klrr> okey, thanks!
05:05:26 <Axman6> the buffering mode doesn't change what data you get
05:05:53 <davean> Sure it does
05:06:06 <davean> in line buffering you don't see deletes
05:06:09 <davean> for example
05:06:13 <klrr> what is deletes?
05:06:23 <davean> when someone changes the input
05:06:24 <Axman6> oh that's true
05:06:40 <klrr> how can someone change the input?
05:06:46 <davean> ... using delete
05:07:14 <davean> terminals operate on a model, you get a resultant state that occures on a NL event
05:07:20 <davean> not the operations that get you TO the newline event
05:07:23 <klrr> oh, you mean if i type "blabalabl" then backspace it wont handle that?
05:07:29 <davean> It'll handle it
05:07:31 <klrr> but that shouldnt matter when dealing with IRC , right?
05:07:36 <davean> you just won't see what was there before they used backspace
05:07:43 <klrr> aa okey
05:07:45 <davean> if you do characture based, you'll see it and then see the delete
05:07:52 <davean> because you see EVERY state that occures
05:07:56 <davean> not just ones that follow a NL event
05:09:15 <benmachine> NoBuffering is conceptually the simplest thing, imo
05:09:20 <davean> This is an important disctinction in types of external models being state or event based
05:09:22 <benmachine> everything else is more-or-less a performance optimisation
05:14:57 <merijn> This also involves all the low level TTY/VTY gore
05:15:08 <merijn> like canonical mode, cooked mode, raw mode, etc.
05:16:22 <_0xAX> Hello all
05:16:52 <Axman6> 'lo
05:17:37 <no-n> if i want to call exitSuccess from inside a function whose return type is IO Foo, what's the right way to do that, exitSuccess >> return foo ?
05:17:42 <_0xAX> i'm newbie in haskell and have a question: Why Data.Binary.encode 2014 returns "\NUL\NUL\NUL\a\222" instead "\222"?
05:18:43 <Axman6> > showHex 2014 ""
05:18:45 <lambdabot>  "7de"
05:19:03 <Axman6> > 0xde
05:19:04 <lambdabot>  222
05:19:09 <Axman6> > 0xa
05:19:10 <lambdabot>  10
05:19:24 <Axman6> 10 * 256 + 222
05:19:28 <Axman6> > 10 * 256 + 222
05:19:29 <lambdabot>  2782
05:19:35 <Axman6> huh
05:19:54 <no-n> @hoogle showHex
05:19:55 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
05:20:37 <Axman6> _0xAX: it all depends on the type of 2014, which is probably Integer. so the encoding is a bit more complex
05:20:42 <Axman6> > 0x222
05:20:44 <lambdabot>  546
05:20:55 <Axman6> hmm
05:21:03 <_0xAX> Axman6: 2014 :: Int
05:22:04 <Axman6> are you sure? because writing encode 2014 will treat 2014 as an Integer
05:23:12 <_0xAX> Yes, i have a data type: data Date = Date {
05:23:12 <_0xAX>                    year :: Int,
05:23:12 <_0xAX>                    month :: Int,
05:23:12 <_0xAX>                    day   :: Int,
05:23:12 <_0xAX>                    hour  :: Int,
05:23:12 <_0xAX>                    minute :: Int,
05:23:14 <_0xAX>                    second :: Int
05:23:16 <_0xAX>                  }
05:23:20 <Axman6> don't do that!
05:23:35 <Sculptor> hi
05:23:43 <iArthur> Hi all
05:23:43 <Axman6> if you need to paste more than one line, use lpaste.org or whatever your preferred paste bin website is
05:24:20 <supki> > ord '\a' * 256 + ord '\222'
05:24:22 <lambdabot>  2014
05:24:25 <Sculptor> http://codepad.org/ can run haskell code
05:24:33 <iArthur> in Mac OS trying install binary-0.7.1.0 in sandbox and getting Error "binary-0.7.1.0 failed during the building phase.",  without sandbox it installed without problem.
05:24:33 <iArthur>  any hints?
05:24:48 <Axman6> oh obviously, thanks supki
05:28:44 <benmachine> _0xAX: it definitely does look like you're using the Integer encoding
05:28:58 <benmachine> _0xAX: try encode (2014 :: Int) and see if you get the same thing
05:33:48 <no-n> if i want to call exitSuccess from inside a function whose return type is IO Foo, what's the right way to do that, exitSuccess >> return foo ?
05:34:59 <Cale> no-n: exitSuccess is polymorphic in its result type, so you can just use it directly
05:35:02 <Maior> :t exitSuccess
05:35:09 <lambdabot> Not in scope: `exitSuccess'
05:35:11 <Cale> no-n: (of course, it never finishes, because your program exits)
05:35:23 <Cale> :t System.Exit.exitSuccess
05:35:31 <lambdabot> IO a
05:35:35 <no-n> that's why i asked. it seemed like it was needed for type correctness but weird to do because it never happens.
05:35:53 <no-n> ahh, right
05:35:58 <Cale> Its type actually sort of tells you that it doesn't return.
05:36:22 <benmachine> it can promise you that the values it provides you are of any type you like, since it doesn't return any
05:36:28 <benmachine> *provide
05:36:28 <klrr> okey, ive fiddled around a little bit with machines and pipes
05:36:41 <klrr> and i dont really understand the advantage over just using functions tbh
05:36:49 <klrr> https://gist.github.com/klrr/6ac6be03072333173e1a
05:36:59 <klrr> what am i missing?
05:37:41 <davean> klrr: they manage the control flow
05:37:47 <Cale> klrr: The part you're missing is that in order to just use functions like that, the IO actions on the input side have to do some magic to produce lazy values which cause things to happen when evaluated
05:38:28 <Cale> klrr: and when you apply something like hGetContents to get such a String, you give up the right to close the handle.
05:38:39 <Cale> So, sometimes you really want more control over resources than that
05:39:26 <skypers> stackedit <3, really lovely website to write papers :)
05:39:31 <klrr> davean: what you mean by control flow, is it that the pipes code is automatiically continuous if foo outputs more than one string?
05:40:06 <benmachine> right
05:40:06 <Cale> Well, and that's not the only case you might want something like that. In general, you might want IO-performing things to be handled in a streaming way, but you might not want to use unsafePerformIO to make that happen.
05:40:06 <klrr> Cale: what you mean with resources?
05:40:17 <Cale> klrr: Filehandles, sockets, etc.
05:40:21 <klrr> okey
05:40:27 <davean> klrr: That and more
05:40:28 <klrr> but you can use bracket?
05:40:38 <Cale> er, unsafeInterleaveIO rather
05:40:41 <benmachine> I think it's weird to bring lazy IO into this
05:40:46 <davean> klrr: like resource management and closing things at the first correct time
05:41:01 <benmachine> if it's not mentioned in the question jumping immediately to it in the answer is a bit odd
05:41:30 <klrr> hmm, i *want* to understand pipes and their advantage but as a newbie to programming i fail to see what it solves :s
05:41:46 <benmachine> klrr: I've never really used pipes in a serious way but I understand that one possible application is a gzip decoder
05:42:01 <davean> klrr: COmpare writing something that does an on-disk merge sort
05:42:03 <klrr> what's more streaming with pipes than looping some IO monadic actions?
05:42:05 <benmachine> a gzip decoder is basically a stream transformation, it gets a stream of input and produces a stream of output
05:42:19 <davean> klrr: well, ifrst off you have to write the loop ...
05:42:25 <benmachine> but it could receive its input in bits, some now some later, and likewise can be requested to produce its output in bits
05:42:27 <davean> klrr: second off, consider many interacting loops, like merge sort
05:42:43 <benmachine> and the bits of output that you request determine the bits of input that it needs in a non-obvious way
05:42:46 <davean> now you have to write - and interleave - all those loops
05:43:03 <davean> now consider you sometimes want the fist 10, other times you want the entire result
05:43:10 <davean> Now you have to go back and change your loops
05:43:13 <davean> with pipes you don't
05:43:58 <klrr> i need to read up what merge sort is
05:44:05 <Fuco> is there a way to look up all Data.List.* packages in hackage web ui somehow?
05:44:08 <davean> oh, that new? Ok, hum
05:44:36 <benmachine> klrr: merge sort is a sorting algorithm wherein you basically arbirarily split the input list into two, merge sort both halves, and then merge them
05:44:51 <benmachine> klrr: based on the observation that it's easy and fast to turn two sorted lists into one
05:45:01 <klrr> okey
05:45:24 <klrr> well, that example makes more sense
05:45:41 <davean> you don't know how many files you'll have in general
05:45:55 <davean> to do it efficiently your loop version needs to do things like keep priority queues and such
05:45:56 <benmachine> klrr: I think my advice would be is don't go looking for the problem that pipes solves
05:46:08 <benmachine> klrr: you'll run into it eventually, or else, you won't, in which case no big deal :P
05:46:20 <klrr> but that with resources ive hard to understand. yous till have to use normal hClose etc. right?
05:46:45 <davean> No
05:46:51 <benmachine> klrr: a lot of people underestimate the power of ordinary functions, and to be honest, ordinary functions can solve most problems
05:47:02 <utkarsh> Is it possible to view the source code of a function from the hoogle CLI? or any other way?
05:47:07 <davean> well, there is nothing here ordinary functiosn CAN'T do
05:47:12 <davean> pipes *are* ordinary functions
05:47:27 <davean> They're just ones with a specific API that makes your life easier
05:48:00 <benmachine> davean: pipes are not functions in a literal sense
05:48:39 <benmachine> but still, if you include things like "take care of this for me without me having to worry about it" then arguably ordinary functions can't do that
05:49:33 <klrr> is it OK to think of Producers as source, Consumers as users and Pipes as transformers (in the sense they take input and do soemthing with it producing output)?
05:51:13 <davean> benmachine: in that specific implimentation - no
05:52:02 <davean> WE're tlaking about a subset of functions
05:52:34 <klrr> how does it handle that case then? i mean if i use connectTo and fromHandle to make a Producer how does it closes that automaticallly?
05:57:10 * hackagebot pbc4hs 0.1.0.0 - pbc for HsLua  http://hackage.haskell.org/package/pbc4hs-0.1.0.0 (DavidFeng)
06:27:05 <AncientPC> How do I use minimumBy on a list of records? (e.g. list of persons; data Person = Person { age :: Int })
06:27:17 <AncientPC> where I want to find the lowest age person
06:30:56 <Dodek> AncientPC: minimumBy (comparing age) xs
06:31:11 <Dodek> comparing is in Data.Ord
06:35:44 <AncientPC> Dodek: thx
06:51:37 <klrr__> okey not yet checked if compile, but is this appropriate usage of pipes? https://gist.github.com/klrr/ae61de2d62e0bdac9211#file-ircbot-hs-L101
06:53:48 <nielsbusch> Does eclipsefp support tab completion?
07:02:51 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
07:02:51 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
07:02:51 --- names: list (clog_ seliopou kaol jfhall bearclaw maaku ustunozgur Ikarus vital zoglesby_ meandi fijimunkii bobobo1618 dolio waterlaz kakos Reite ciaranm HongFaeBu coeus NobbZ Elision s4msung ccs4ever Dashkal AleXoundOS_ Sorella iXeno minsa Lethalman orzo prototrout monochrom Endy __class__ MK_FG LeaChim timmot kalloc justinleitgeb gridaphobe nielsbusch sam_d suOya pfoetchen nominolo__ whaletechno Jonno_FTW krakrjak sigma914 aoh Kneiva wollw Philonous_ brainproxy ezrios)
07:02:51 --- names: list (jmbto1 yeltzooo eevar matheus23 s_e zabirauf stevely squidz kfish Tene Maior earthy Cale _5kg thasc iArthur geal peltchu sepp2k dabd CindyLinz idoru oscar_toro jle` OlegYch tlevine shirt cynick dsrx Shin-LaC gseitz fsvehla croyd spacekitteh eyenx quchen talzeus Kinnison_ tov descender ddellacosta obcode_ AlainODea myoriel ConstantineXVI srcerer Philonous vobi Guest74083 bjorkintosh yriw shepheb Ke iross bigos inan0 jakutis bjackman simukis_ ezyang_ dhrosa_)
07:02:51 --- names: list (aegray frihd_1 burbul aninhumer xplat 16WAAS158 boegel_ drbop Ornedan 16WAAS17J nsno Ptival shelf maexono c_14 ByronJohnson vlopez tburns_ orbital dlat tridactyla zeroskillor lightquake RoryHughes joeyh aloiscochard jagtalon so lieven_ posco___ yeshuah_ ccasin aqa Svedrin alderz- lacrosse Guest47925 Guest78819 zpconn_ leifw jetho lahwran kennycaosn_ necronian_ petantik avdi dsantiag_ annulus luite jmct` treaki__ Raynos ahf chad ibid_ kerrick jzelinskie)
07:02:51 --- names: list (rieper_ joelteon pcapriotti bryan11 jml mjrosenb_ hamishmack Neqoxec_ seanparsons hank defanor Shiryo__ lpaste_ bhek_ [[zz]] Guest21474 stvc_ ayako ousado_ cronject mietek_ bstrie_ Bigcheese_ beanmachine zeiris_ adelbertc schlumpi dv-_ DanielDiaz1 marsam thetallguy zygentoma negrala Mortomes__ JPohlman1 SaBer_ kittenso1p aristid1 bd__ estewei ktosiek_ navaati dschoepe khy jrib1 bsmt unsymbol Twey M-ou-se Betal benj_ drAgda Aetherspawn heathjs hamid)
07:02:51 --- names: list (mm_freak shanse integral elgot tristero netogallo jmob madjestic jeff_s1 jizanthapus cross ljhms Guest76469 skypers_ Laney mshoruzu bjz jobstijl0 caligula__ mars-92 \u pyykkis_ ts33kr kloeri_ kloplop321 Vorpal_ mrowez eacameron1 zachmassia Qfwfq ChongLi_ klrr__ rk[lies]_ hc helgar_ byorgey_ bitemyap1 ulfdoz bholst_ mrmonday_ mirpa_ kungp gauthier derekv2 Iloiny kipras milessabin_ johntrom_ augur robbert si14 lemao_ synonymous1 xrq` japesina- DT__ pantsman-)
07:02:51 --- names: list (_boegel_ syllogismos sellout-1 juxovec_ alpounet_ dreixel__ jedai jophish tomh-_ zso Irrenhaus3 powellc icosahedronman tarruda noam__ ompaul Sculptor piezoid tibbe n^izzo troydm djcoin HalfWayMan sbos99 kshannon PJBoy q66 Argue doomlord_ alexherbo2 john2x waldkauts gmaggior aztek ananthakumaran io2 darthdeus avaritia Roklobsta MoALTz_ TheFuzzball Achylles kludge` Thooms no-n catalyst m1dnight SoupE ski alanz necrobious funfunctor GodsDeceiver raichoo)
07:02:51 --- names: list (goldkatze_ sxn agjacome David shintah c_wraith oleo bocaneri jefimenko RichyB AntiSpamMeta AtnNn yacks mendez fridim_ apaku mniip prooftechnique zcd etabot S11001001 Targen stepkut edwardk yarou dcoutts_ tiffany lurker6 kardboardb mescalinum petermw ``rawr edsko stass AmnesiousFunes pfurla lokydor stephenmac7 Gothmog_ ormaaj runde nus thunderrd fizbin joaopizani Biohazard tdammers r444 jcristovao mirsal jonke_ Eagle_Er1in AleXoundOS simpson ijp mceier juhp)
07:02:51 --- names: list (akurilin felipe_ jj2baile silasm j2j pikhq hamilyon otterdam srhb dju sleuth lamilami phienone bergmark fiddlerwoaroof FreeFull ninegrid jrw frontendloader paz_ amosr shutdown_-h_now qpls mattp__ wilfredh qz statusfailed jayne majoh wjlroe_ sipa erikl_ majackson zomg egads OrangeDuck jlouis Rembane Cryovat Yaniel gbarboza iNode001 Axman6 DarkFox socksy betawaffle docsis arnihr_ shennyg mrb_bk flazz korpse_ rola raphie_ sweeks eribeiro l4u yan_ Jello_Raptor)
07:02:51 --- names: list (colah scshunt mokus lispy idnar bezik yusukesuzuki__ exicer_ necroyeti dmwit MitchW mjo d-snp cpa radioxid Cr8 grohne munro morolin bens ortmage etrepum flux andyo zebr zenzike asjo horlicks_ Cheery aji amiller sa1 RevJohnnyHealey Eliel Taneb saiam maskt wormphlegm joefiorini honkfestival kqr klugez leroux RogueShadow michaelpj drewr DustyDingo theDon mshroyer dlundy Zariel edwtjo_ sleepynate tych0 saarin killy9999 mikecaruso moop joshbohde catsup)
07:02:51 --- names: list (hongminhee npcomp_ vvv robinbb-freenode ilmig_ mavam clog zalzane jliikka ehamberg mtlatif_ brixen haasn ggherdov cods cryzed Deewiant Thulsadu1 dj_ryan SegFaultAX newsham cschneid_ Licenser boggle_ dh edunham noddy2000 Nik05 blast_hardcheese Kobata_ topi` BlastHardcheese Kabaka ivan` emma jbauman Internet13 mathu cpluss purefn Maxdamantus albel727 pompom streblo hpd uiop noteventime SHODAN waxjar_ levi heaumer_ WzC yano Rylee ocfx ec demolith1)
07:02:51 --- names: list (tyler_robertson pranz keyvan kmicu __main__ inarru_ Igloo dennda mnbernst1in nicoo cow-orker xintron KorriX bartavelle AshyIsMe BMeph kalz cjsarette mami Urchin Lindrian notdan profmakx ashooby Cerise shapr finster Squid_Tamer ps-auxw mortberg sw1nn apples td123 shinsuke et|kkl winocm popx_ leper` hiredman jlamothe Khisanth mmaruseacph2 vpm zorzar deevus knigitz ft muricula ttuegel hive-mind PHO_ ivanm philipp` epta Starfire ParahSailin jix evax)
07:02:51 --- names: list (jrmithdobbs qwandor peterhil Vq alexsdutton gemelen prinsen CaveJohnson obiwahn mlen Soft bergey tg hvr b2coutts Olive` TheBrayn ivan\ gibsonfs gspr jcurbo tomprince zoktar callumacrae Liskni_si niko voyd kragniz uncleBlazer rasmusto stbuehler adlan Hafydd bernalex finnrobi dflemstr jlewis BrianHV rs0 gislik marienz copumpkin tristan__ absence relrod eagleflo uniquenick pdxleif valdyn shiona karls johnw luigy KitB rawtass drmegahertz Nimatek ninzine)
07:02:51 --- names: list (FliPPeh dixie_ liori pharaun martin froztbyte ValicekB peder raek benbangert Jaak xaimus mrshoe Madarc ReinH vmesonbus Spockz nik_89 Tesseraction chrra solirc Clint Razz lab-notes ion chipdude bduc mephx spion epsylon solarus geekosaur Rockj tomejaguar vikraman fergusnoble bgamari otulp Dtgr pierreghz Adios Nafai Walther SLi heikkih h_chiro opqdonut mindleyhilner KaneTW bitraten tomaw tippenein satshaba1 cmsd2 mero `0660 Fubar^ yam fnordbert boyscared)
07:02:51 --- names: list (adnap dario pyrtsa TK009 cwvh ghorn iron_houzi zeroXten phryk Hardolaf helgikrs crs_ flori [mth] keko_ ernst wto ziman b_jonas Brando753 peddie Javafant bogner flebron Raynes taruti mononofu jrslepak jchee bcoppens melter banjiewen deavid jcp FUZxxl amontez barrucadu dawik koala_man zaphar_ps Derander osfameron spaceships 5EXAAJO7F aseidl jorendorff_away Sornaensis indigo @ChanServ _flow_ alexdoom Sagi inr petanqk kbotnen dmilith sordina1 mantovani mrd)
07:02:51 --- names: list (companion_cube Belgarion0 FreakyPenguin fall_ fayden burp)
07:04:13 <AlainODea> nielsbusch: I believe Eclipse itself does. You remap the show completions key. I remember it being unwieldy in that you can no longer use tab for anything other than completion
07:04:16 * hackagebot pbc4hs 0.1.0.0 - pbc for HsLua  http://hackage.haskell.org/package/pbc4hs-0.1.0.0 (DavidFeng)
07:04:16 * hackagebot fb 0.15.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.15.2 (FelipeLessa)
07:07:12 <Lethalman> is it possible to write take in terms of foldr only?
07:08:39 <quchen_> Lethalman: Yes
07:08:42 <Lethalman> mh
07:08:50 <klrr__> okey not yet checked if compile, but is this appropriate usage of pipes? https://gist.github.com/klrr/ae61de2d62e0bdac9211#file-ircbot-hs-L101
07:09:13 <Lethalman> quchen_, and how would you maintain the state of "n" to take?
07:09:20 <quchen_> Lethalman: It may be a little tricky though, but you'll level up once you understand how it works. It's quite similar to the idea of writing foldl in terms of foldr yourself.
07:09:53 <quchen_> Basically, you'll want to have something like "foldr go z xs n" as your main function body, for appropriate go and z.
07:10:41 <Lethalman> quchen_, ok thanks :)
07:13:28 <klrr__> okey not yet checked if compile, but is this appropriate usage of pipes? https://gist.github.com/klrr/ae61de2d62e0bdac9211#file-ircbot-hs-L101
07:27:41 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
07:27:41 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
07:27:41 --- names: list (clog ttuegel mr- maaku diadara_ LeNsTR ustunozgur maurer bxc zeroskillor zarul larsrh AtnNn PatrickRobohta vsayer aqa mindCrime__ mandu Syneh desc trobertson lightquake _zxq9_ Saizan Reite wting zabirauf jmbto1 dabd spacekitteh jang jobstijl0 Erstarrung kxra Boney_ tromp_ Ceryn OrangeDu1k davorak Tene_ kittensoup fijimunk1i mendez__ tinyghost int-e zerokarm1left ccasin jlouis_ magicman_ Dodek_ iteratee shachaf_ majackso1 waterlaz_ Corey_ lulf drbean qpls_)
07:27:41 --- names: list (_mlen vlopez jzl udoprog1 yggr_ ccs4ever1 amathew nominolo1_ tensorpudding felixsch HongFaeBu Twey ljhms_ nichtdiebohne mreh joeyh identity monochrom saurik warpy sepp2k1 ikkebr_ ystael streblo1 jamwt1 Gracenotes xinming caligula hackagebot twn Arnar__ gniourf klaut numberten ciaranm minsa aoh so aloiscochard tburns_)
08:14:00 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
08:14:00 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
08:14:00 --- names: list (clog maximumsteve simukis_1 gridaphobe ivan\ Fuco studmuf angerman dustinswan1 23LAA5N24 orbital |tch rawtass joeyh lambdabot kxra negrala predator117 mlinksva Shin-LaC tomaw tippenein satshaba1 cmsd2 mero `0660 Fubar^ yam fnordbert boyscared adnap dario pyrtsa TK009 cwvh ghorn iron_houzi zeroXten phryk Hardolaf crs_ flori [mth] keko_ ernst wto ziman b_jonas Brando753 peddie Javafant bogner flebron Raynes taruti mononofu jrslepak jchee bcoppens melter)
08:14:00 --- names: list (banjiewen deavid jcp FUZxxl amontez barrucadu dawik koala_man zaphar_ps Derander osfameron spaceships 5EXAAJO7F aseidl jorendorff_away Sornaensis indigo @ChanServ _flow_ alexdoom Sagi inr petanqk kbotnen dmilith sordina1 mantovani mrd companion_cube Belgarion0 FreakyPenguin fall_ fayden burp bitraten KaneTW mindleyhilner opqdonut h_chiro heikkih SLi Walther Nafai Adios pierreghz Dtgr otulp bgamari fergusnoble vikraman Rockj geekosaur solarus epsylon spion)
08:14:00 --- names: list (mephx bduc ion lab-notes Razz chrra Tesseraction Spockz Jaak benbangert raek froztbyte martin pharaun dixie_ FliPPeh ninzine drmegahertz johnw karls shiona valdyn uniquenick eagleflo relrod absence tristan__ copumpkin marienz BrianHV jlewis adlan callumacrae gspr TheBrayn Olive` hvr obiwahn CaveJohnson prinsen gemelen alexsdutton Vq peterhil qwandor jrmithdobbs evax ParahSailin Starfire epta philipp` ivanm PHO_ muricula ft knigitz deevus zorzar mmaruseacph2)
08:14:00 --- names: list (Khisanth winocm et|kkl td123 apples mortberg ps-auxw Squid_Tamer finster shapr Cerise profmakx notdan Lindrian Urchin mami cjsarette kalz BMeph AshyIsMe bartavelle xintron mnbernst1in Igloo inarru_ kmicu keyvan pranz ec Rylee yano WzC heaumer_ noteventime albel727 Maxdamantus cpluss mathu Internet13 emma ivan` BlastHardcheese Kobata_ dh boggle_ Licenser cschneid_ newsham SegFaultAX dj_ryan Thulsadu1 Deewiant cryzed cods haasn brixen ehamberg mavam)
08:14:00 --- names: list (robinbb-freenode vvv npcomp_ hongminhee catsup mikecaruso killy9999 tych0 egads zomg erikl_ sipa wjlroe_ majoh shutdown_-h_now amosr paz_ jrw ninegrid bergmark sleuth srhb otterdam hamilyon pikhq j2j silasm jj2baile felipe_ mceier simpson AleXoundOS Eagle_Er1in jonke_ mirsal jcristovao Biohazard joaopizani runde Gothmog_ stephenmac7 pfurla AmnesiousFunes stass edsko kardboardb dcoutts_ edwardk Targen S11001001 etabot zcd prooftechnique mniip fridim_ yacks)
08:14:00 --- names: list (AntiSpamMeta RichyB jefimenko bocaneri oleo David agjacome goldkatze_ raichoo GodsDeceiver funfunctor necrobious alanz ski SoupE m1dnight catalyst no-n Thooms kludge` Achylles MoALTz_ avaritia darthdeus ananthakumaran aztek gmaggior waldkauts alexherbo2 doomlord_ Argue q66 kshannon sbos99 HalfWayMan djcoin troydm Sculptor ompaul Irrenhaus3 dreixel__ alpounet_ syllogismos _boegel_ pantsman- japesina- xrq` lemao_ robbert augur johntrom_ milessabin_ kipras)
08:14:00 --- names: list (Iloiny gauthier mirpa_ mrmonday_ bholst_ bitemyap1 byorgey_ helgar_ hc rk[lies]_ ChongLi_ Qfwfq zachmassia eacameron1 Vorpal_ kloplop321 kloeri_ ts33kr pyykkis_ jeff_s1 netogallo elgot integral shanse Aetherspawn drAgda Betal bsmt jrib1 dschoepe ktosiek_ estewei bd__ aristid1 SaBer_ JPohlman1 zygentoma dv-_ adelbertc benmachine mietek_ cronject ousado ayako stvc_ Guest21474 bhek_ defanor hank Neqoxec_ hamishmack mjrosenb_ bryan11 pcapriotti joelteon rieper_)
08:14:00 --- names: list (kerrick ibid_ ahf Raynos treaki__ luite dsantiag_ avdi necronian_ c_14 maexono myoriel AlainODea eyenx Cale yeshuah_ abcoeud lan3y lacrosse zpconn__ lahwran mak` lattenwald glaebhoerl_ silver__ bluesm drdo Tarential sinclair|work StoneToad Guest11452 Revenrof davorb Excedrin_ XMunkki_ derdon_ e_svedang paper_ tekacs dsirenko_ Reiser ixian Iceland_jack thirsteh pnielsen Nickeeh_ lopex tobyp xrl__ yumike__ pjdelport ryanakca_ Xorlev Shou superjudge Blkt)
08:14:00 --- names: list (18WAFUHWK gfarfl uu1101 Scorchin kcliu ZsoL LordDeath djahandarie edk averell ircbrowse dp_wiz akraut hdevalence|away stephe_ raid Paprikachu Ulrar MasseR thorstadt nisstyre_ mrpantoufle Guest66206 m3ga joneshf-laptop mornfall rgr guampa DrCode S_T_A_N stiell_ dlat vobi joshsz zoglesby_ bounb tridactyla alderz_ Guest78819 jagtalon leifw ConstantineXVI kennycaosn_ petantik jmct` lpaste_ Bigcheese_ khy heathjs sellout-1 tomh-_ ``rawr docsis arnihr_ shennyg)
08:14:00 --- names: list (mrb_bk flazz korpse_ rola raphie_ sweeks eribeiro l4u yan_ Jello_Raptor colah scshunt mokus lispy idnar bezik yusukesuzuki__ exicer_ necroyeti dmwit MitchW mjo d-snp cpa radioxid Cr8 grohne munro morolin bens ortmage etrepum flux andyo zebr zenzike asjo horlicks_ Cheery aji amiller sa1 RevJohnnyHealey Eliel Taneb saiam maskt wormphlegm joefiorini honkfestival kqr klugez leroux RogueShadow michaelpj drewr DustyDingo theDon mshroyer dlundy Zariel edwtjo_)
08:14:00 --- names: list (sleepynate zoktar Svedrin Itkovian dgpratt natte honza voxpopuli bjz adimit hodapp sigma9141 stevely_ Peaker meandi_ sski_ kilian0815 OlegYch6 pi8028 talzeus_ dcoutts justinle_ omefire ddellaco_ LexicalScope` [swift] croyd_ chirpsalot coeus s_e annulus lamilami jayne betawaffle iNode001 gbarboza Yaniel Cryovat yogurt_truck thunderrd Roklobsta Axman6 DarkFox socksy \q si14_ wilfredh mtlatif_ seanparsons_ nicoo_ AleXoundOS__ bjorkintosh aloiscochard mimi_vx)
08:14:00 --- names: list (luigy DT` ownclo_ Valodim ikkebr_ ggherdov t7 17SAAICJN merijn Guest27008 cynick ccc squidz mgaare 17SAAICZF 17SAAIC4P subleq bunzen katis_ 17SAAIC8U mm_freak apaku ustunozgur jix helmut cross aleksejs_ glowcoil awfabian anRch gseitz majackson asmyers MK_FG ologNation 16WAATF8L tv dsrx iteratee CurtainGoose Adeon mr- vital fikusz ilmig peder sepp2k waxjar linduxed yarou 16WAATERM gniourf willb1 nominolo__ dagnachew twn navaati xymox schlumpi_ Chousuke_)
08:14:00 --- names: list (jaimef b2coutts nominolo_ wollw_ ginmaniac lokydor_ reizuki ThatOtherPerson bstrie_ Nshag foxnorth frontend1oader fabjan_ ckey` Ezku aleator_ nominolo obcode_ Ptival nsno 16WAAS17J Ornedan drbop boegel_ 16WAAS158 xplat aninhumer burbul frihd_1 aegray dhrosa_ ezyang_ simukis_ bjackman jakutis inan0 bigos iross Ke shepheb yriw Ikarus nema vhz ZioCrocifisso saep jackneill CosmicRay PJBoy_ voyd Phlogistique Hafydd mm_freak_ pdxleif ccs4ever1 codonnell)
08:14:00 --- names: list (fiddlerwoaroof jang mangaba_leitosa Yawgmoth_ tburns_ Dodek_ 20WABBZ0I dqd paullik1 mindCrime__ jzl jaspervdj marsam squidz_ larsrh xnyhps asm89 finnrobi bxc 20WABBZ8K Corey tdammers ccasin Endy fryguybob theorbtwo hive-mind Rembane ccc_ peltchu AncientPC cynick_ iXeno Eduard_M1nteanu merijn_ yeltzooo kakos mendez jmbto1 brandonw Wuzzy bunzen_ NickHu Elision bbee Nik05 bearclaw Saizan dju monochrom liori bernalex _janne saarin_ mgaare_ zarul LeaChim Lemmih)
08:14:00 --- names: list (ersran9 lurker6 jzelinskie kungp jophish vsayer nadirs ClaudiusMaximus bambams__ posco____ tburns Dodek lusory puzza007__ orzo Plasmastar Baughn Yawgmoth zasimov NobbZ caligula tpsinnem roconnor__ earthy waterlaz_ dflemstr phyrex1an OrangeDuck d3lxa Lethalman macron derekv 92AAAI4VK Shiryo jcurbo suOya trobertson WraithM DasIch tharper eL_Bart0 estebistec u_ magicman)
08:23:41 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
08:23:41 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
08:23:41 --- names: list (clog_ joshbohde sykora Nahra ZioCrocifisso2 earldouglas mm_freak bezik cdk dagnachew_ diadara gargawel Eliel gibsonfs bunzen helgikrs jlamothe ido Kneiva tburns saurik qz Kinnison vmeson OceanSpray mreh kaol ortmage watermind tlevine Jonno_FTW maoe jix apaku mendez_ mike2_ ocfx thasc Philonous jfischoff jonathanj Arnar_ phienone innertracks lpsmith tensorpudding Tene PatrickRobohtam prototrout cjay n^izzo dennda liyang Reite kav_ amyers Earnestea Nimatek)
08:23:41 --- names: list (anders^^ TheFuzzball kosmikus timmot oubiwann tnks sam_d ljhms shirt zeroskillor Athas Boney sdx23 Will| supki davean hamid sirdancealot dolio mike2 CosmicRa` brainproxy mrowe_away maurer clog maximumsteve simukis_1 gridaphobe Fuco studmuf angerman dustinswan1 orbital |tch joeyh rawtass lambdabot negrala predator117 Guest40510 u_ estebistec eL_Bart0 tharper DasIch WraithM trobertson suOya jcurbo Shiryo 92AAAI4VK derekv macron Lethalman d3lxa OrangeDuck)
08:23:41 --- names: list (phyrex1an dflemstr waterlaz_ earthy roconnor__ tpsinnem caligula NobbZ kxra Shin-LaC zasimov Baughn orzo lusory posco____ bambams__ nadirs vsayer jophish kungp jzelinskie ersran9 Lemmih LeaChim mgaare_ _janne bernalex liori monochrom dju Saizan Nik05 bbee Elision bunzen_ NickHu brandonw jmbto1 mendez kakos yeltzooo merijn_ Eduard_M1nteanu iXeno cynick_ AncientPC peltchu ccc_ Rembane hive-mind theorbtwo fryguybob Endy ccasin tdammers Corey 20WABBZ8K bxc)
08:23:41 --- names: list (finnrobi asm89 xnyhps squidz_ marsam jaspervdj jzl mindCrime__ paullik1 dqd 20WABBZ0I tburns_ Yawgmoth_ mangaba_leitosa jang fiddlerwoaroof codonnell ccs4ever1 pdxleif Hafydd Phlogistique voyd PJBoy_ CosmicRay jackneill saep ZioCrocifisso vhz nema Ikarus yriw shepheb Ke iross bigos inan0 jakutis bjackman simukis_ ezyang_ dhrosa_ aegray frihd_1 burbul aninhumer xplat 16WAAS158 boegel_ drbop Ornedan 16WAAS17J nsno Ptival obcode_ nominolo aleator_ Ezku ckey`)
08:23:41 --- names: list (fabjan_ frontend1oader foxnorth Nshag bstrie_ ThatOtherPerson reizuki lokydor_ ginmaniac wollw_ nominolo_ b2coutts jaimef Chousuke_ schlumpi_ xymox navaati twn dagnachew nominolo__ willb1 gniourf 16WAATERM yarou linduxed waxjar sepp2k peder ilmig fikusz vital mr- Adeon CurtainGoose iteratee dsrx tv 16WAATF8L ologNation MK_FG asmyers majackson anRch awfabian glowcoil aleksejs_ cross ustunozgur katis_ Guest27008 merijn t7 ggherdov Valodim ownclo_ DT` luigy)
08:23:41 --- names: list (mimi_vx bjorkintosh AleXoundOS__ nicoo_ seanparsons_ si14_ \q socksy DarkFox Axman6 Roklobsta thunderrd yogurt_truck Cryovat Yaniel gbarboza iNode001 betawaffle jayne lamilami annulus s_e coeus chirpsalot croyd_ [swift] LexicalScope` ddellaco_ omefire justinle_ dcoutts talzeus_ pi8028 OlegYch6 kilian0815 sski_ meandi_ Peaker stevely_ sigma9141 hodapp adimit bjz voxpopuli honza natte dgpratt Itkovian Svedrin zoktar tomaw tippenein satshaba1 cmsd2 mero `0660)
08:23:41 --- names: list (Fubar^ yam fnordbert boyscared adnap dario pyrtsa TK009 cwvh ghorn iron_houzi zeroXten phryk Hardolaf crs_ flori [mth] keko_ ernst wto ziman b_jonas Brando753 peddie Javafant bogner flebron Raynes taruti mononofu jrslepak jchee bcoppens melter banjiewen deavid jcp FUZxxl amontez barrucadu dawik koala_man zaphar_ps Derander osfameron spaceships 5EXAAJO7F aseidl jorendorff_away Sornaensis indigo @ChanServ _flow_ alexdoom Sagi inr petanqk kbotnen dmilith)
08:23:41 --- names: list (sordina1 mantovani mrd companion_cube Belgarion0 FreakyPenguin fall_ fayden burp bitraten KaneTW mindleyhilner opqdonut h_chiro heikkih SLi Walther Nafai Adios pierreghz Dtgr otulp bgamari fergusnoble vikraman Rockj geekosaur solarus epsylon spion mephx bduc ion lab-notes Razz chrra Tesseraction Spockz Jaak benbangert raek froztbyte martin pharaun dixie_ FliPPeh ninzine drmegahertz johnw karls shiona valdyn uniquenick eagleflo relrod absence tristan__)
08:23:41 --- names: list (copumpkin marienz BrianHV jlewis adlan callumacrae gspr TheBrayn Olive` hvr obiwahn CaveJohnson prinsen gemelen alexsdutton Vq peterhil qwandor jrmithdobbs evax ParahSailin Starfire epta philipp` ivanm PHO_ muricula ft knigitz deevus zorzar mmaruseacph2 Khisanth winocm et|kkl td123 apples mortberg ps-auxw Squid_Tamer finster shapr Cerise profmakx notdan Lindrian Urchin mami cjsarette kalz BMeph AshyIsMe bartavelle xintron mnbernst1in Igloo inarru_ kmicu)
08:23:41 --- names: list (keyvan pranz ec Rylee yano WzC heaumer_ noteventime albel727 Maxdamantus cpluss mathu Internet13 emma ivan` BlastHardcheese Kobata_ dh boggle_ Licenser cschneid_ newsham SegFaultAX dj_ryan Thulsadu1 Deewiant cryzed cods haasn brixen ehamberg mavam robinbb-freenode vvv npcomp_ hongminhee catsup mikecaruso killy9999 tych0 egads zomg erikl_ sipa wjlroe_ majoh shutdown_-h_now amosr paz_ jrw ninegrid bergmark sleuth srhb otterdam hamilyon pikhq j2j silasm)
08:23:41 --- names: list (jj2baile felipe_ mceier simpson AleXoundOS Eagle_Er1in jonke_ mirsal jcristovao Biohazard joaopizani runde Gothmog_ stephenmac7 pfurla AmnesiousFunes stass edsko kardboardb dcoutts_ edwardk Targen S11001001 etabot zcd prooftechnique mniip fridim_ yacks AntiSpamMeta RichyB jefimenko bocaneri oleo David agjacome goldkatze_ raichoo GodsDeceiver funfunctor necrobious alanz ski SoupE m1dnight catalyst no-n Thooms kludge` Achylles MoALTz_ avaritia darthdeus)
08:23:41 --- names: list (ananthakumaran aztek gmaggior waldkauts alexherbo2 doomlord_ Argue q66 kshannon sbos99 HalfWayMan djcoin troydm Sculptor ompaul Irrenhaus3 dreixel__ alpounet_ syllogismos _boegel_ pantsman- japesina- xrq` lemao_ robbert augur johntrom_ milessabin_ kipras Iloiny gauthier mirpa_ mrmonday_ bholst_ bitemyap1 byorgey_ helgar_ hc rk[lies]_ ChongLi_ Qfwfq zachmassia eacameron1 Vorpal_ kloplop321 kloeri_ ts33kr pyykkis_ jeff_s1 netogallo elgot integral shanse)
08:23:41 --- names: list (Aetherspawn drAgda Betal bsmt jrib1 dschoepe ktosiek_ estewei bd__ aristid1 SaBer_ JPohlman1 zygentoma dv-_ adelbertc benmachine mietek_ cronject ousado ayako stvc_ Guest21474 bhek_ defanor hank Neqoxec_ hamishmack mjrosenb_ bryan11 pcapriotti joelteon rieper_ kerrick ibid_ ahf Raynos treaki__ luite dsantiag_ avdi necronian_ c_14 maexono myoriel AlainODea eyenx Cale yeshuah_ abcoeud lan3y lacrosse zpconn__ lahwran mak` lattenwald glaebhoerl_ silver__ bluesm)
08:23:41 --- names: list (drdo Tarential sinclair|work StoneToad Guest11452 Revenrof davorb Excedrin_ XMunkki_ derdon_ e_svedang paper_ tekacs dsirenko_ Reiser ixian Iceland_jack thirsteh pnielsen Nickeeh_ lopex tobyp xrl__ yumike__ pjdelport ryanakca_ Xorlev Shou superjudge Blkt 18WAFUHWK gfarfl uu1101 Scorchin kcliu ZsoL LordDeath djahandarie edk averell ircbrowse dp_wiz akraut hdevalence|away stephe_ raid Paprikachu Ulrar MasseR thorstadt nisstyre_ mrpantoufle Guest66206 m3ga)
08:23:41 --- names: list (joneshf-laptop mornfall rgr guampa DrCode S_T_A_N stiell_ dlat joshsz bounb jmct` heathjs sellout-1 flazz l4u yan_ colah lispy yusukesuzuki__ dmwit mjo d-snp grohne munro morolin bens etrepum andyo zenzike aji RevJohnnyHealey saiam maskt wormphlegm joefiorini honkfestival kqr klugez RogueShadow drewr Zariel)
10:22:15 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
10:22:15 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
10:22:15 --- names: list (clog guymann_ leper`- gridaphobe tg krakrjak __main__ fiddlerwoaroof topi`_ shintah| cow-orke1 vyorkin tamiko mjo HugoDaniel otto_s Neqoxec sdx23 gargawel_ oubiwann int-e tyler_robertson pp^ dmwit maoe Shin-LaC cbarrett mindCrime__ brandonw _janne |tch Enigmagic naneau__ s4msung_ mescalinum colah Hafydd_ nicoo_ Lemmih rs0 papna tdammers udoprog Yawgmoth pdxleif slobo aztek_ tessier pvt_pete_ OneEyedWill Natch Will| Jonno_FTW FreeFull maaku_ nooodl_ Twey)
10:22:15 --- names: list (DanielDiaz kalloc blast_hardcheese kakos jcurbo bbee [[zz]] estebistec thasc eL_Bart0 nik_89 AlexRussia angerman nurupo tomejaguar nooodl sykora simukis_ mindCrime_ aleksejs_ bearclaw vendethiel uncleBlazer Nik05 coltfred __class__ lispy CosmicRay raichoo Elision eevar subleq pcflmb PythonNut zabirauf klugez predator117 whaletechno CindyLinz warpy mgaare RevJohnnyHealey ido larsrh studmuf stepcut saarin Clint Erstarrung jfhall Shiryo cow-orker vhz KitB)
10:22:15 --- names: list (naneau awfabian brainproxy MercurialAlchemi jix Plasmastar Th0mas skuggi iXeno trobertson ormaaj hiredman topi` marsam nemesit|znc radioxid delinquentme tnks shintah vital noam xnyhps Athas begriffs cfoch Martty_ qz Swizec juzz merijn iteratee bens Sonderblade guymann gienah greymalkin ajoox gseitz smerz_ ownclo talzeus tlevine ConstantineXVI smerz dflemstr Sculptor zeiris Cr8 orbital mhi^ joefiorini caumeslasal1 Madarc bezik MarcWeber J-KUKEN derekv)
10:22:15 --- names: list (Cerise yggr supki lpsmith blueonyx DT` lacrosse_ eyck Ralith_ carter earthy_ descender AlainODea mtlatif_ mm_freak_ Baughn joachifm_ maximumsteve jxv gthorslund Lethalman dsrx bounb ByronJohnson marcus-aurelius dcoutts n^izzo spacekitteh mrowe_away cads magicman jaspervdj necroyeti khyperia confound AtnNn apaku d3lxa d-snp Guest72158 helmut mrpantoufle kilian0815 Maior Guest97927 jang tpsinnem earldouglas RogueShadow yusukesuzuki__ Guest35620 asjo vsayer)
10:22:15 --- names: list (peltchu u_ augur_ jonathanj phyrex1an asm89- idoru yogurt_truck dqd Ikarus roconnor davorak Nimatek sa1 kqr streblo Saizan Fuco GaveUp kosmikus epsilonhalbe joneshf-laptop anders^^_ dennda mshroyer Excureo jmob ttuegel copton LeaChim Taneb mixi mlinksva_ Kinnison Guest1707 ortmage sunnavy matheus23 yogert thetallguy mreh solirc3 NobbZ Corey udevd XMunkki zalzane ddellacosta vpm Boney saurik mikeizbicki ethercrow Eliel petermw mmathis sleepynate amathew)
10:22:15 --- names: list (geal liyang jamwt1 powellc lurker6 Cryovat Yaniel gbarboza iNode001 betawaffle jayne lamilami coeus chirpsalot [swift] omefire pi8028 meandi_ stevely_ hodapp adimit honza natte \q luigy katis_ kfish zasimov Guest57038 sxn annulus lightquake Guest68188 yeshuah phischu korpse_ njcomsec thorstadt MasseR Ulrar Paprikachu raid stephe_ hdevalence|away akraut dp_wiz ircbrowse averell edk djahandarie LordDeath ZsoL kcliu Scorchin uu1101 gfarfl 18WAFUHWK Blkt Shou)
10:22:15 --- names: list (Xorlev ryanakca_ pjdelport yumike__ xrl__ tobyp lopex Nickeeh_ pnielsen thirsteh Iceland_jack ixian Reiser dsirenko_ tekacs e_svedang Excedrin_ davorb Revenrof Guest11452 StoneToad sinclair|work Tarential drdo bluesm silver__ glaebhoerl_ jzelinskie dilinger rola puzza007__ mrb_bk raphie__ Guest10309 vobi munro tomh-_ jliikka mrshoe joshsz ikkebr_ arnihr aloiscochard sweeks FireFly ``rawr hackagebot Guest24037 seanparsons PatrickRobohtam_ wilfredh fikusz_)
10:22:15 --- names: list (derdon OlegYch shachaf lattenwald nicoo cebewee q66 robx Guest35752 nschoe socksy DarkFox Axman6 Roklobsta thunderrd jmct sellout- l4u io2 Svedrin leifw_ shennyg zyaku heath conehead dlat_ kennycaosn_ eribeiro alderz_ lpaste Bigcheese nus Jello_Raptor tridactyla flux oz1 RoryHughes zeroskillor joeyh PJBoy_ majackson ggherdov Valodim si14_ zoktar stiell_ rgr nisstyre_ mak` lahwran lan3y Cale eyenx myoriel c_14 necronian_ dsantiag_ luite treaki__ ahf ibid_)
10:22:15 --- names: list (kerrick rieper_ joelteon pcapriotti bryan11 mjrosenb_ hamishmack hank defanor bhek_ Guest21474 stvc_ ousado ayako cronject mietek benmachine adelbertc dv- JPohlman1 SaBer_ aristid1 bd__ estewei ktosiek_ dschoepe jrib1 bsmt Betal drAgda Aetherspawn shanse integral elgot netogallo jeff_s1 pyykkis_ ts33kr kloeri kloplop321 Vorpal_ Qfwfq ChongLi_ rk[lies]_ hc helgar_ byorgey_ bitemyap1 bholst_ mrmonday_ gauthier Iloiny kipras milessabin_ johntrom_ robbert)
10:22:15 --- names: list (lemao_ xrq` japesina- pantsman- _boegel_ syllogismos alpounet_ dreixel__ Irrenhaus3 ompaul troydm djcoin HalfWayMan sbos99 kshannon doomlord_ alexherbo2 waldkauts gmaggior avaritia MoALTz_ Achylles kludge` Thooms catalyst m1dnight SoupE ski alanz necrobious funfunctor GodsDeceiver goldkatze_ agjacome David oleo bocaneri jefimenko RichyB AntiSpamMeta yacks fridim_ mniip prooftechnique zcd etabot S11001001 Targen edwardk kardboardb edsko stass AmnesiousFunes)
10:22:15 --- names: list (pfurla stephenmac7 Gothmog_ runde joaopizani Biohazard jcristovao mirsal jonke_ Eagle_Erwin 5EXAAMHXH simpson mceier felipe_ jj2baile silasm j2j pikhq hamilyon otterdam srhb sleuth bergmark ninegrid jrw paz_ amosr shutdown_-h_now majoh wjlroe_ sipa erikl_ zomg egads tych0 killy9999 mikecaruso catsup hongminhee npcomp_ vvv robinbb-freenode mavam ehamberg brixen haasn cods cryzed Deewiant Thulsadu1 dj_ryan SegFaultAX newsham cschneid_ Licenser boggle_ dh)
10:22:15 --- names: list (Kobata_ BlastHardcheese ivan` emma Internet13 mathu cpluss Maxdamantus albel727 noteventime heaumer_ WzC yano Rylee ec pranz keyvan kmicu inarru_ Igloo mnbernst1in xintron bartavelle AshyIsMe BMeph kalz cjsarette mami Urchin Lindrian notdan profmakx shapr finster Squid_Tamer ps-auxw mortberg apples td123 et|kkl winocm Khisanth mmaruseacph2 zorzar deevus ft muricula PHO_ ivanm philipp` epta Starfire ParahSailin evax jrmithdobbs qwandor peterhil Vq)
10:22:15 --- names: list (alexsdutton gemelen prinsen CaveJohnson obiwahn hvr Olive` TheBrayn gspr callumacrae adlan jlewis BrianHV marienz copumpkin tristan__ absence relrod eagleflo uniquenick valdyn shiona karls johnw drmegahertz ninzine FliPPeh dixie_ pharaun martin froztbyte raek benbangert Jaak Spockz Tesseraction chrra Razz lab-notes ion bduc mephx spion epsylon solarus geekosaur Rockj vikraman fergusnoble bgamari otulp Dtgr pierreghz Adios Nafai Walther SLi heikkih h_chiro)
10:22:15 --- names: list (opqdonut mindleyhilner KaneTW bitraten burp fayden fall_ FreakyPenguin Belgarion0 companion_cube mrd mantovani sordina1 dmilith kbotnen petanqk inr Sagi alexdoom _flow_ @ChanServ indigo Sornaensis jorendorff_away aseidl 5EXAAJO7F spaceships osfameron Derander zaphar_ps koala_man dawik barrucadu amontez FUZxxl jcp deavid banjiewen melter bcoppens jchee jrslepak mononofu taruti Raynes bogner Javafant peddie Brando753 b_jonas ziman wto ernst keko_ [mth] flori)
10:22:15 --- names: list (crs_ Hardolaf phryk zeroXten iron_houzi ghorn cwvh TK009 pyrtsa dario adnap boyscared fnordbert yam Fubar^ `0660 tomaw tippenein satshaba1 cmsd2 mero)
10:22:20 <mm_freak_> dynamically changing triangles that is…  but i'm sure i can get more =)
10:22:35 * hodapp is trying to use a GCC cross-compiler to compile a GCC native compiler for MIPS
10:27:35 <carter> PythonNut: paste the code to lpaste.net and share a linke
10:27:35 <carter> hodapp: funnnnnn
10:27:35 <carter> khyperia: i'm nearly ready to have alpha on hopenblas
10:27:35 <carter> which i need to rename
10:27:35 <hodapp> carter: that's a word you could use.
10:28:02 <khyperia> nice!
10:28:12 <carter> hodapp: ironically because I didnt spend an interview yesterday talking about how many hours i spend on linker errors, they assumed i only do theoretical things
10:28:16 <khyperia> also, I'm horrible at naming things. Seriously, I can't think of any names.
10:28:30 <carter> hblaspack
10:28:30 <carter> or haslablaspack
10:28:34 <carter> or hblas
10:28:39 <carter> or urFACE
10:28:40 <hodapp> haslblas
10:28:40 <carter> :P
10:28:44 <carter> nah
10:28:52 <khyperia> haslablaspack sounds like hurgleblurdursdas
10:28:52 <hodapp> sblasback
10:28:54 <bitemyap1> carter: hassleback
10:29:00 <hodapp> hasselblad
10:29:00 <hodapp> haskellblas
10:29:07 <bitemyap1> haskellblast
10:29:08 <carter> haskellblas-FOREIGN
10:29:16 <carter> with the end in all caps
10:29:20 <hodapp> HaskellBlasLibraryWrapperFunctionalityFactoryInstanceManager
10:29:24 <carter> yes
10:29:28 <carter> mebe I should do that
10:29:31 <carter> actually
10:29:40 <carter> i want people to only use it as an ffi
10:29:47 <carter> might as well give it an obnoxious name too
10:29:53 <hodapp> QAHBB (QAHBB Ain't a Haskell BLAS Binding)
10:30:44 <hodapp> I'll take that silence to mean that I'm awesome and so is my idea.
10:30:52 <carter> hodapp: that'll be the the lib that secretely just runs interpreted R code remotely on a VM
10:30:59 <hodapp> o_O
10:31:01 <carter> :P
10:31:21 <mm_freak_> 1M triangles at 15 FPS with no updates, 5 FPS with updates…  given mostly static geometry and dynamic models and particle effects within the scene, this is really fast…  alternatively the highly dynamic parts (e.g. particles) can be computed by compute shaders
10:31:34 <mm_freak_> in other words:  functional reactive games in haskell with amazing graphics are now possible =)
10:31:40 <khyperia> woo!
10:32:04 <mm_freak_> i'll release the corresponding libraries soon
10:32:42 <carter> mm_freak_:  that sounds neat
10:33:15 <mm_freak_> btw, this is yet unoptimized…  no hidden surface removal, no culling, just dumping a load of triangles to the GPU =)
10:33:41 <carter> yes
10:33:44 <carter> so promising ;)
10:35:26 <mm_freak_> also i should mention that my graphics card is three years old =)
10:37:42 <bitemyap1> mm_freak_: 3dmark benchmarks (C++) generally pump 250mm++ tris/second
10:37:53 <bitemyap1> the newer ones even more.
10:38:22 <bitemyap1> modern hardware has a theoretical limit of ~2-3 billion triangles/second
10:38:56 <carter> bitemyap1: in practice locality bites right?
10:39:36 <bitemyapp> carter: uh, there's a long chain of problems
10:39:47 <carter> including locality? :)
10:39:51 <bitemyapp> not least that triangles/second isn't the best way to measure performance, but it's a decent way to get sense of order of magnitude.
10:40:04 <bitemyapp> carter: well, I don't know how he's managing his rendering pipeline
10:40:08 <carter> true
10:40:34 <bitemyapp> carter: but locality isn't super-relevant as you're supposed to be pumping primitive manipulations into the graphics card, not smashing a world model into it over and over
10:40:44 <carter> yes
10:40:50 <carter> fair
10:40:52 <carter> i know nuttin
10:41:06 <bitemyapp> admittedly, the world model is what gives rise to the retained-mode commands, but you don't really work with the graphics primitives quite so directly, in an ideal world.
10:41:31 <bitemyapp> carter: well I mention this because functional people get too infatuated with the outdated immediate-mode rendering because it's appealing and simple - but slow and out of date.
10:41:40 <carter> yeah
10:41:42 <carter> well
10:41:49 <carter> the "modern" model is a nicer one
10:42:00 <carter> makes more sense to me from a locality / batch compute perspective
10:42:01 <zsasz> do you guys have an etoke bot
10:42:09 <bitemyapp> ...what?
10:42:29 <zsasz> one where you type !etoke
10:42:31 <zsasz> and it counts down
10:42:33 <zsasz> to the time
10:42:35 <zsasz> when it's time
10:42:36 <zsasz> to smoke weed
10:42:41 <carter> @where ops
10:42:55 <carter> copumpkin: Cale  etc yo
10:43:18 <bitemyapp> carter: the irony is that focusing on retained mode would probably make a higher level language like Haskell *more* rather than less competitive.
10:43:26 <ayako> noooo lambdabot isn't with us
10:43:33 <carter> bitemyapp: you mean the modern style?
10:43:35 <carter> yea agree
10:51:16 --- mode: ChanServ set +o geekosaur
10:51:22 --- kick: zsasz was kicked by geekosaur (zsasz)
10:51:28 --- mode: geekosaur set -o geekosaur
10:52:05 <Clint> last zsasz
10:52:07 <Clint> er
10:54:35 <NikolajK1> f x y
10:54:35 <NikolajK1> means
10:54:35 <NikolajK1> (f x) y
10:54:35 <NikolajK1> but then why does
10:54:35 <NikolajK1> 3:7:[]
10:54:36 <NikolajK1> work? shouldn't it be (3:7):[]? What kind of operation is : anyway
10:55:08 <geekosaur> it's 3:(7:[])
10:55:13 <FreeFull> : appends an element to a list
10:55:21 <FreeFull> Well, prepends
10:55:29 <FreeFull> The left side is an element, the right side a list
10:55:32 <simpson> NikolajK1: It's defined as right-associative.
10:55:32 <geekosaur> : is a list constructor
10:55:39 <geekosaur> it is infixr 5 (right associative)
10:55:42 <simpson> infixr 5 :
10:55:42 <FreeFull> > 3:[]
10:55:55 <FreeFull> No lambdabot o.o
10:55:57 <flebron> The user "batr" seems to be a spambot, linked me in privmsg to some crap as soon as I joined.
10:57:08 <NikolajK1> geekosaur: is
10:57:08 <NikolajK1> infixr 5 (right associative)
10:57:08 <NikolajK1> the formal assignment, i.e. is this code?
10:57:11 <FreeFull> simpson: What's another right-associative operator?
10:57:45 <geekosaur> the code is `infixr 5 :`
10:58:00 <geekosaur> if you load ghci and type ":info (:)", that is one of the things it will show you
10:58:00 <FreeFull> You can even do something like       infixr 5 `foo`
10:58:11 <simpson> FreeFull: How about ($) ?
10:58:14 <simpson> infixr 0 $
10:58:22 <geekosaur> (infix/infoxl/infoxr is unusual in taking an operator as an operator instead of as a function)
10:58:29 <FreeFull> simpson: I was hoping for something that would be more familiar to NikolajK1
10:58:33 <geekosaur> *infixl, infixr
10:58:54 <geekosaur> the canonical right associative operator is exponentiation
10:59:08 <FreeFull> Ah, so 3^4^5
10:59:26 <FreeFull> Or 3**4**5
10:59:30 <geekosaur> yes
10:59:40 <FreeFull> Although it takes the same type on both left and right side
10:59:44 <geekosaur> this makes sense if you think about the printed frm, wich is superscript
11:00:39 <NikolajK1> I can't read the into, looks strange, but it doesn't matter I'm just getting started
11:01:19 <geekosaur> the data declaration is truncated, it's showing only the (:) part and hiding the rest behind ...
11:01:54 <geekosaur> data [] a = [] | a : [a] -- the full one, which ironically is shorter than the "elided" version
11:04:26 <geekosaur> (you can think of `[] a` as being the same kind of thing as `Maybe a`; nobody actually writes it that way in practice though, they say `[a]`)
11:04:41 <geekosaur> unless they're being pedantic to show what's going on
11:15:19 <Guest18494> im trying to use cabal to install xmobar and its telling me that alsa-mixer is failing during the configure step
11:16:47 <geekosaur> do you havr the alsa devel libraries installed? (the runtime libraries are not enough, and redhat-likes and debian-likes split the devel libraries from the runtime)
11:17:19 <geekosaur> these are C libraries that would come from your system's package manager, not something cabal can help you with directly
11:17:27 <blueonyx> hi, why is there no more ByteString To/FromJSON instance in aeson 0.7.0.1?
11:17:38 <Guest18494> yea im on debian and i got the libasound2-dev libraries
11:18:00 <geekosaur> then I think you'll have to rerun cabal with -v3 to see what exactly is failing in configure
11:18:08 <geekosaur> (I think that's right)
11:18:48 <geekosaur> cabal install --verbose=3 alsa-mixer
11:20:17 <Guest18494> okay seems like im missing c2hs
11:21:41 <Guest18494> do i use cabal to get that or jst use apt
11:22:03 <geekosaur> oh, that's likely, cabal can't handle program-only dependencies. or, it can install it but it'll go to ~/.cabal/bin and if you didn't add that to $PATH ahead of time it won't be able to find it again
11:22:10 <mm_freak_> bitemyapp: per second, not per frame
11:22:23 <geekosaur> (~/Library/Haskell/bin on OS X, and don't actually use ~ there use $HOME)
11:22:40 <mm_freak_> bitemyapp: also those benchmarks use some techniques that i'm not using yet, like compute shaders, persistent buffers, etc.
11:22:45 <bitemyapp> mm_freak_: you had 5m tris/sec then, yes?
11:23:23 <mm_freak_> bitemyapp: 5M (fully static) to 15M (fully dynamic)
11:23:24 <bitemyapp> mm_freak_: well, where I'm at is this. If I can get within 10x of what's possible with vanilla C++ and OpenGL with no latency issues due to GC, then I might be in aciton
11:23:27 <bitemyapp> action*
11:23:42 <bitemyapp> mm_freak_: but what I'm thinking of is going to be CPU hungry so the graphics pipeline *cannot* monopolize CPU.
11:24:13 <mm_freak_> bitemyapp: GC is generally no problem…  i'm using AFRP, which has many micro-allocations and few big allocations
11:24:26 <bitemyapp> mm_freak_: heap fragmentation is a bitch.
11:24:39 <bitemyapp> mm_freak_: part of the challenge is making the gfx pipeline efficient enough that it can feed the GPU while still leaving a core or 3 handy for everything else.
11:24:59 <mm_freak_> bitemyapp: heap fragmentation does not occur most of the time…  the vertex attributes are in storable vectors
11:25:31 <bitemyapp> mm_freak_: if you say so, but I've tried to do this stuff in GC'd langs before and had huge trouble with heap fragmentation.
11:25:44 <bitemyapp> I don't doubt the unboxed types available in Haskell help a ton.
11:25:57 <mm_freak_> bitemyapp: anyway, i believe that i'm close to the edge of what my GPU can produce, so once this project is finished i'd like to see how fast it runs on modern GPUs =)
11:26:11 <mm_freak_> bitemyapp: it's the storable type in particular that makes this really efficient
11:26:17 <mm_freak_> Data.Vector.Storable that is
11:26:43 <mm_freak_> i'm now at a point where the main bottleneck is the data transfer
11:27:15 <delinquentme> For the dependency on base >=4.3 && <4.8 there are these packages: ... and base-4.6.0.1. However none of them are available.
11:27:16 <mm_freak_> this is also how well-known benchmarks achieve such a huge triangle count:  there is almost no data transfer between CPU and GPU
11:27:19 <delinquentme> what does this even mean?
11:27:22 <mm_freak_> in my case i transfer the entire scene in every frame
11:27:41 <Guest18494> geekosaur: hey thanks a lot i got it installed now
11:27:52 <geekosaur> np
11:27:55 <mm_freak_> delinquentme: old haskell platform
11:27:57 <mm_freak_> ?
11:28:17 <delinquentme> I think so
11:28:28 <mm_freak_> delinquentme: then you should perhaps update it
11:28:30 <geekosaur> delinquentme, cabal isn't smart enough to tell you what that really means, which is "your ghc is not compatible"
11:29:18 <geekosaur> base can't be installed, it includes the haskell runtime so it has to come with ghc
11:32:15 <bitemyapp> mm_freak_: you're doing immediate-mode rendering? dammit man.
11:32:35 <mm_freak_> bitemyapp: what?  no!
11:32:46 <mm_freak_> i'm using VAOs/VBOs
11:33:02 <bitemyapp> mm_freak_: why are you transferring the entire scene every time?
11:34:15 <mm_freak_> bitemyapp: to see how fast it is…  i've just made another test:  i'm generating two buffers with random values, (-1,-1,-1)-(1,1,1) for positions, (0,0,0)-(1,1,1) for colors
11:34:35 <mm_freak_> if my loop does only clear, drawArrays and swapBuffers, i get 30M tris/s, if they are far away
11:34:42 <mm_freak_> and about 15M tris/s if they are near
11:34:58 <mm_freak_> i believe that's the limit of what my GPU can do
11:35:47 <mm_freak_> if i update everything (storable vector + unsafeWith + copyArrays), it quickly drops to 2M-3M tris/s
11:35:54 <mm_freak_> then the bottleneck is copyArrays
11:36:12 <mm_freak_> using mapBufferRange, btw
11:36:47 <bitemyapp> copying isn't going to work either.
11:37:02 <bitemyapp> might be easier to treat it like command-queueing against state.
11:37:36 <mm_freak_> i've tried that:  using a pipes Producer with no actual in-memory source array
11:37:39 <mm_freak_> turned out to be much slower
11:39:07 <bitemyapp> mm_freak_: o_O
11:39:44 <mm_freak_> bitemyapp: copyArrays is essentially a memcpy() operation…  it should be about the fastest way to get stuff from CPU to GPU
11:39:57 <mm_freak_> and that one operation is the bottleneck
11:40:14 <mm_freak_> allocating/generating/populating the vector is cheap
11:40:33 <bitemyapp> mm_freak_: you have to get away from the memcpy anyway.
11:40:43 <bitemyapp> mm_freak_: you should be directly manipulated the retained primitives *in* the GPU
11:40:51 <bitemyapp> not re-smashing the whole scene against it via copy over and over
11:40:56 <bitemyapp> manipulating*
11:41:06 <mm_freak_> bitemyapp: i know, but i have yet to find an elegant way to do it
11:41:25 <mm_freak_> the idea was to write a functional shader language that you can compile to compute/tesselation shaders
11:41:29 <mm_freak_> but it's a lot of work
11:41:40 <NikolajK1> I have here this function which finds the minimum (mnm) integer of a list. it first breaks the list successively into parts and then starts from the end, comparing elements and always keeps the smaller one.
11:41:41 <NikolajK1> mnmInt :: [Int] -> Int
11:41:41 <NikolajK1> mnmInt [] = error "empty list"
11:41:41 <NikolajK1> mnmInt [x] = x
11:41:41 <NikolajK1> mnmInt (x:xs) = min x (mnmInt xs)
11:41:42 <NikolajK1> do you guys know what happens internally on the computer here: specifically, I wonder how often does the computer actually scan the list
11:41:43 <NikolajK1> in
11:41:43 <NikolajK1> mnmInt (x:xs) = min x (mnmInt xs)
11:41:44 <NikolajK1> does the computer take the first element of the list without even knowing how long the list is?
11:42:11 <RichyB> NikolajK1, please use http://lpaste.net/ if you want to paste several lines in one go. :)
11:43:03 <NikolajK1> RichyB: k
11:43:04 <mm_freak_> NikolajK1: you're essentially doing a foldr there, so you're first building an expression in memory (min a (min b (min c …)))
11:43:35 <RichyB> NikolajK1, to answer your question: say I have a list, [1, 2, 3]. That is actually 1 : 2 : 3. When a Haskell function matches it against (x:xs), the match will only look at the first (:).
11:43:35 <mm_freak_> to make this efficient you have to turn it into a left fold
11:44:11 <mm_freak_> NikolajK1: and yes, your function does not know how long the list is
11:44:18 <NikolajK1> mm_freak: what exactly is the place where the fold is more efficient?
11:44:29 <NikolajK1> what steps are left out so that it's more efficient
11:44:37 <mm_freak_> NikolajK1: well, let's do one evaluation step
11:44:43 <RichyB> NikolajK1, pattern matches in Haskell (and most languages with pattern matching, like ML and Prolog) only examine the bits of the data structure that you match against.
11:45:00 <mm_freak_> by your very definition:  mnmInt (1:[2,3]) = min 1 (mnmInt [2,3])
11:45:23 <mm_freak_> now the evaluation has to go on
11:45:45 <mm_freak_> because 'min' is strict in both arguments, it will cause the recursion to happen before giving the answer
11:46:20 <NikolajK1> min 1 (mnmInt [2,3]) … I figure it's wasted time that in the case above min looks at 1 first and then only decided to evaluate (mnmInt [2,3])
11:47:06 <mm_freak_> NikolajK1: a left fold looks like this:  mnmInt x (y:ys) = mnmInt _ _
11:47:11 <mm_freak_> now fill in the two _
11:47:36 <mm_freak_> this will still be inefficient, but it will become efficient with a small change later =)
11:50:48 <NikolajK1> mnmInt x (y:ys) = mnmInt _ _ … I don't understand why your mnmInt here seems to have 2 arguments
11:51:05 <mm_freak_> NikolajK1: that's the shape of a left fold
11:51:18 <mm_freak_> NikolajK1: it allows you to recurse directly
11:51:42 <NikolajK1> and you want to make the minimum search function a function which you pass two arguments?
11:51:59 <NikolajK1> like if I give you [3,5,1,6], what do you do
11:52:03 <mm_freak_> a general left fold looks like this:  mnmInt x (y:ys) = mnmInt (f x y) ys
11:52:04 <mm_freak_> define f
11:54:09 <NikolajK1> why are there >9000 people coming in every second
11:54:31 <mm_freak_> because freenode is having difficulties right now
11:54:38 <geekosaur> because freenode is broken today (distributed denial of service attack)
11:54:49 <NikolajK1> mm_freak: mnmInt x (y:ys) = mnmInt (f x y) ys, what is first evaluated, the mnmInt on the right hand side or the f
11:54:54 <geekosaur> entire servers in the freenode network keep losing contact with the collective and then regaining it
11:55:22 <mm_freak_> NikolajK1: ask yourself what function f needs to be for this to be a minimum function
11:57:09 <NikolajK1> mm_freak_: f=min?
11:57:31 <mm_freak_> NikolajK1: now you need one more equation:  the base case
11:57:36 <mm_freak_> mnmInt x [] = ?
11:57:48 <NikolajK1> =x
11:58:08 <mm_freak_> now evaluate 'mnmInt 1 [2,3]' for yourself
11:59:32 <NikolajK1> mnmint (min 1 2) [3]
11:59:33 <NikolajK1> mnmint (min (min 1 2) 3) []
11:59:33 <NikolajK1> min (min 1 2) 3
11:59:33 <NikolajK1> min 1 3
11:59:33 <NikolajK1> 1
11:59:48 <mm_freak_> NikolajK1: exactly
11:59:55 <mm_freak_> NikolajK1: did that make sense?
12:00:18 <NikolajK1> so the outer one does things first
12:00:26 <NikolajK1> f later
12:00:41 <mm_freak_> yes, right now
12:00:47 <NikolajK1> k
12:00:58 <mm_freak_> now let's optimize the hell out of this =)
12:01:28 <mm_freak_> mnmInt x (y:ys) = mnmInt (min x y) ys
12:01:57 <mm_freak_> this would apply mnmInt like that, but there is a way to say:  don't apply mnmInt before the 'min x y' is actually calculated!
12:02:46 <mm_freak_> mnmInt x (y:ys) = let x' = min x y in x' `seq` mnmInt x' ys
12:03:09 <mm_freak_> this may look a bit more complicated, but it's easy to explain
12:03:20 <mm_freak_> x `seq` y is the same as y, but with x evaluated
12:03:54 <mm_freak_> so at the point when the recursion happens, the intermediate is guaranteed to be evaluated
12:04:01 <NikolajK1> haven't encountered let yet, but I saw it in the type specification of hidley miller on wikipedia
12:04:16 <mm_freak_> 'let' just introduces names for values
12:04:20 <mm_freak_> let x = y in z
12:04:21 <NikolajK1> I know it's some way of specifying an internal module
12:04:38 <mm_freak_> x is defined as y within z
12:04:51 <mm_freak_> > let x = 5 in x + x
12:05:25 <applicative> lambdabot> 10
12:07:25 <NikolajK1> let x' = min x y in "x' `seq`" mnmInt x' ys
12:07:26 <NikolajK1> I don't understand the part in " ", why is this necessary
12:08:11 <mm_freak_> x' `seq` mnmInt x' ys = mnmInt x' ys
12:08:35 <mm_freak_> but it is a hint to the compiler that it should evaluate x' before evaluating mnmInt x' ys
12:09:42 <mm_freak_> it's exactly the same code as without the stuff you quoted, just a lot faster =)
12:10:01 <NikolajK1> brb eating
12:16:34 <blueonyx> hi, why are there no more ByteString instances in aeson 0.7.0.1?
12:18:14 <applicative> json is defined in terms of characters
12:18:15 <Clint> what's the right way to make a Word4 type?
12:19:34 <applicative> blueonyx: oh, here: https://github.com/bos/aeson/issues/126
12:22:11 <blueonyx> applicative: thanks :/
12:22:27 <mm_freak_> Clint: speed or correctness?
12:22:57 <Clint> mm_freak_: correctness
12:23:22 <mm_freak_> Clint: data Word2 = Word2 !Bool !Bool; data Word4 = Word4 !Word2 !Word2
12:24:10 <Clint> mm_freak_: how do i make that work with numeric constants?
12:24:24 <mm_freak_> Clint: by giving it a Num instance
12:24:34 <Clint> ah, thanks
12:24:58 <mm_freak_> Clint: you can also write:  data Word4 = Word4 !Bool !Bool !Bool !Bool
12:25:03 <mm_freak_> but that's less convenient to work with
12:25:17 <mm_freak_> rather define addition/multiplication with carry for Word2, then use that to extend it to Word4
12:26:02 * Clint nods.
12:27:42 <notdan> Are functions from data.Text faster than the functions from Data.Foldable?
12:27:45 <notdan> their conuterparts
12:27:50 <notdan> (for Text, that is)
12:28:08 <NikolajK1> mm_freak_: k, thx so far for yoour help
12:28:27 <mm_freak_> NikolajK1: you're welcome
12:28:32 <mm_freak_> notdan: unlikely
12:29:20 <mm_freak_> notdan: specialization can matter though
12:29:40 <mm_freak_> notdan: but Text is not a foldable…
12:29:58 <notdan> mm_freak_: oops, true
12:38:34 <notdan> is there a strict Text builder?
12:39:44 <mm_freak_> notdan: yes, Data.Text.Lazy.Builder
12:40:30 <notdan> but it builds.. lazy Text?
12:40:54 <mm_freak_> it builds what you want it to build
12:41:13 <juzz> Data.Text.TotallyNotLazyWinkWink.Builder
12:41:43 <lemao_> I often see discussions about function names and one recurring consideration is to what extent the name clashes with one in another library, which is used often. Considering how sophisticated type inference is in Haskell, would it be quite easy to have GHC automatically select the right function based on the types of the given arguments? And in the infrequent case where even the parameter types are the same, then resort to qualifying the import
12:41:43 <lemao_> .
12:41:44 <notdan> ah wait, let me guess, Lazy Text and stirct Text is the same datastructure?
12:41:57 <notdan> the strictness comes from functions?
12:42:20 <applicative> no, completely different types
12:42:39 <applicative> lazy text is basically a specialized [Text]
12:42:40 <lemao_> effectively 'auto' qualifying the imports to disambiguate.
12:42:47 <notdan> ok well then I don't understand how a lazy text builder can produce strict text
12:43:08 <notdan> sorry I still don't quite grasp the lazy/strict ecosystem
12:45:11 <int-e> @bot
12:45:16 <lambdabot> :)
12:46:16 <blueonyx> i dont get it, aeson parses json from a bytestring but bytestring has no json instances O.o
12:47:36 <applicative> I think it parses json from a bytestring presumed to be utf8 encoded?
12:48:39 <applicative> "Efficiently and correctly parse a JSON string. The string must be encoded as UTF-8."  http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson-Parser.html
12:49:02 <blueonyx> so?
12:49:28 <applicative> so, the parser fails if it can't find characters at any point
12:49:39 <applicative> rightly, given the specification of json
12:49:42 <applicative> if i understand
12:53:28 <applicative> blueonyx: if you want to include a binary blur in json you can use expedients like http://hackage.haskell.org/package/base64-bytestring-1.0.0.1/docs/Data-ByteString-Base64.html by the same author
12:54:10 <blueonyx> applicative: no my problem is that couchdb-conduit uses ByteStrings as ids for documents in the database
12:54:24 <blueonyx> which are basicly a url
13:02:42 <supki> blueonyx: what "json instances"?
13:02:58 <supki> aeson parses JSON with an attoparsec parser
13:03:35 <blueonyx> supki: ToJSON/FromJSON
13:04:04 <supki> yeah, you don't need them to parse ByteString to Value
13:04:55 <blueonyx> supki: but i have bytestrings that i want to encode cause the are my data which needs to be transformed to JSON
13:05:33 <supki> then you need to explicitly encode/decode them
13:05:48 <blueonyx> yea great
13:05:56 <blueonyx> so no deriveJSON for me :(
13:09:39 <AlainODea> blueonyx: you can still derive ToJSON/FromJSON if you have data types reflecting your JSON text.
13:11:27 <blueonyx> AlainODea: what you mean?
13:13:12 <AlainODea> blueonyx: I probably misunderstand you intent. Here's an example I use to write JSON for vmadm create (a SmartOS thing). https://github.com/AlainODea-haskell/zonemaker/blob/master/MachineJSON.hs
13:13:54 <AlainODea> blueonyx: if I understand Aeson correctly I should also be able to read such files into those data types with a few modifications
13:13:59 <skypers_> hi
13:14:52 <skypers_> I have a typeclass, and I’d like to express that fact that any MonadTrans where the base monad is in my typeclass is in that typeclass
13:14:56 <skypers_> if I write an instance for that
13:15:04 <skypers_> I get overlapping instances :(
13:15:06 <skypers_> any idea?
13:15:50 <geekosaur> constraints play no part in instance selection
13:16:09 <skypers_> you mean
13:16:13 <skypers_> the head?
13:16:22 <skypers_> then I can’t do what I want?
13:16:31 <blueonyx> AlainODea: machineJSON :: MachineSpec -> Value, is practically your ToJSON instance
13:16:34 <skypers_> I have to explicitely write lift . stuff, lift . zoo, lift …
13:16:39 <skypers_> for ALL monads?
13:17:01 <AlainODea> blueonyx: yeah, it could definitely be implemented more cleanly
13:17:15 <blueonyx> AlainODea: my data type contains ByteStrings, because http-conduit uses them as request paths
13:17:48 <geekosaur> if I'm understanding you correctly, you cannot
13:18:24 <skypers_> oh god…
13:18:35 <skypers_> anyone there?
13:18:45 <skypers_> damn this split and DDoS stuff
13:20:23 <AlainODea> blueonyx: you can potentially work around that with a newtype wrapping the ByteStrings and GeneralizedNewTypeDeriving. Again a newbie solution since I'm inexperienced :)
13:24:33 <blueonyx> AlainODea: yea, but then i would need to rewrite a lot of stuff in a lib i'm using and GeneralizedNewTypeDeriving is not possible, since the ByteString instances got removed ;)
13:25:20 <blueonyx> i tried it, but then i got problems with instances for hashmap and Generic stuff :(
13:33:22 <greg> whats the go-to library for http client access
13:33:23 <greg> ?
13:34:48 <pavonia> skypers_: Heh, I tried something similar once, but failed to do that for all MonadLift instances in one instance
13:35:13 <skypers_> yeah
13:35:25 <skypers_> then I think I have to explicitely write all transformers instances
13:35:28 <skypers_> and ohters
13:35:30 <skypers_> others*
13:35:37 <skypers_> like EitherT, ErrorT, and so on…
13:35:41 <skypers_> this is quite boring I guess
13:35:52 <skypers_> because the implementation will be all the same…
13:36:00 <jacco> What would be the problem with changing the meaning of String to be the implementation of Text, and all code that uses the current String would depend on [Char] instead?
13:36:24 <pavonia> skypers_: Yeah, I've read an article somewhere that you get exponential instance growth :(
13:37:02 <skypers_> yeah, this is quite annoying
13:37:07 <skypers_> there might be a way though
13:38:01 <pavonia> There actually are implementations on hackage that try to circumvent that problem, as far as I can tell, but I don't really understand them
13:40:03 <PythonNut> Hello, I'm struggling with the concept of functional purity. If I have "add x y = (add_x y) where add_x = (x+)" doesn't add_x have side-effects?
13:41:03 <ion> What kind of a side effect do you think it might have?
13:41:44 <PythonNut> It reads x (it's a closure, right?) so it's not a function
13:42:05 <ion> It also uses (+) from the scope. Using values in scope is not a side effect.
13:42:11 <geekosaur> you might think of it as a macro
13:45:03 <ion> add_x :: Integer -> Integer, or (->) Integer Integer if you will. Anything with (->) as the root in its type is a function and vice versa.
13:45:37 <roboguy_> PythonNut: it can't change x though
13:45:38 <geekosaur> anyway there is no side effect there. (x+) is a section (a partially applied operator), and in this case since x is not bound in the definition of add_to you can just drop the expansion in place of add_to
13:46:16 <PythonNut> So closures in Haskell are more like inline substitutions?
13:46:20 <geekosaur> so you get (x+) y which is application of y to the section (x+), which is the same as (x + y)
13:46:58 <sipa> PythonNut: *every* expression in haskell is pretty much inline substitution
13:47:12 <geekosaur> "closure" is kinda an imperative thing. this is referential transparency: whenever you do `x = y`, `x` and `y` are supposed to be completely interchangeable
13:47:40 <geekosaur> (modified if it takes parameters, but you just expand those into it when you swap it in)
13:47:45 <PythonNut> Okay then. I did get the feeling that closures could not exists in Haskell by definition. Thanks.
13:48:07 <geekosaur> cloures are used in the *implementation*, mostly to implement laziness
13:48:31 <skypers_> hm
13:48:35 <roboguy_> PythonNut: it's more like haskell couldn't exist without closures
13:48:36 <skypers_> this is quite annoying
13:48:49 <geekosaur> but it's not really a concept in the language itself, because it's a workaround for languages where `x = y` is an action instead of a statement of equivalence
13:49:19 <skypers_> I don’t want people need to depend on errors, transformers or other just for my lib to compile instances :–’
13:50:16 <skypers_> instance (Monad (t m), MonadTrans t, MyMonadTypeClass m) => MyMonadTypeClass (t m) where
13:50:23 <ion> pythonnut: A closure means a tuple of an environment (a table of everything in scope) and a function. It’s an implementation detail, you can just talk about “functions” in Haskell. Any expression, including function bodies, has access to the values in its scope.
13:50:26 <skypers_> ^ this would have been great
13:51:14 <skypers_> there might be a way…
13:52:41 <roboguy_> skypers_: a type class that requires itself?
13:52:53 <skypers_> roboguy_: yes
13:53:15 <skypers_> in order to hide lifting
13:53:23 <skypers_> just like WriterT does
13:53:26 <skypers_> but it’s explicit
13:53:28 <skypers_> like
13:54:12 <roboguy_> what is the kind of the argument for the class?
13:54:26 <skypers_> * -> *
13:54:50 <roboguy_> but m must be * -> * and that contradicts MyMonadTypeClass (t m)
13:54:54 <ion> pythonnut: If you choose to think of the implementation detail, this is how purity applies to a closure: the function won’t have write access to the environment part of the tuple (any more than it has to its parameters).
13:55:12 <skypers_> yes
13:55:14 <skypers_> I meant
13:55:22 <skypers_> * -> (* -> *) -> Constraint
13:55:57 <skypers_> in that example it’s (* -> *) -> Constraint
13:56:03 <PythonNut> So are Haskll functions strictly a mapping of inputs to outputs?
13:56:15 <skypers_> I was talking about MonadWriter, sorry for the misunderstanding
13:56:20 <roboguy_> ah, hmm
13:56:34 <roboguy_> PythonNut: yeah, except for infinite loops and things like that
13:56:49 <AlainODea> greg: http-client seems promising, it's based on http-conduit. https://hackage.haskell.org/package/http-client
13:56:52 <hiptobecubic> PythonNut, if you ignore Bottom (which you generally cannot)
13:57:06 <roboguy_> PythonNut: they more or less follow the mathematical definition of function (if you ignore infinite loops, etc)
13:57:20 <PythonNut> Okay, then I'm not going insane. Thanks everyone :)
13:57:31 <skypers_> I think I just can’t do what I want
13:57:39 <sipa> PythonNut: they're more like partial functions
13:57:52 <sipa> not every input needs to have a defined result
13:58:29 <PythonNut> f(x) = 1/x does not always have a defined result :)
13:58:30 <sipa> @let fun x = if x == 0 then f x else x
13:58:32 <lambdabot>  Defined.
13:58:38 <sipa> > fun 5
13:58:40 <lambdabot>  Ambiguous occurrence `fun'
13:58:40 <lambdabot>  It could refer to either `L.fun', defined at L.hs:152:1
13:58:40 <lambdabot>                        or `Debug.SimpleReflect.Expr.fun',
13:58:40 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:111:1-26
13:58:40 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
13:58:44 <sipa> grr
13:58:46 <sipa> @forget
13:58:47 <lambdabot> Incorrect arguments to quote
13:58:48 <roboguy_> that wasn't very fun
13:59:07 <hiptobecubic> harr harrrr
13:59:13 <sipa> @let ffun x = if x == 0 then f x else x
13:59:13 <roboguy_> had to say it
13:59:14 <lambdabot>  Defined.
13:59:17 <sipa> > ffun 5
13:59:18 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
13:59:19 <lambdabot>    arising from a use of `e_15'
13:59:19 <lambdabot>  The type variable `a0' is ambiguous
13:59:19 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
13:59:19 <lambdabot>  Note: there are several potential instances:
13:59:29 <sipa> i give up
13:59:47 <sipa> oh, f x instead of ffun x
14:01:01 <greg> AlainODea: thx
14:01:04 <skypers_> @unlet
14:01:04 <lambdabot>  Define what?
14:01:08 <skypers_> @let unlet
14:01:08 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:01:11 <skypers_> hm
14:01:12 <ion> @undefine
14:01:12 <lambdabot> Undefined.
14:03:03 <skypers_> hey
14:03:11 <skypers_> in MonadWriter w m, there’s a fundep
14:03:13 <skypers_> m -> w
14:03:19 <skypers_> what does that really mean?
14:03:32 <skypers_> I read that as “if we know the monad, we know the monoid”
14:03:35 <skypers_> or
14:03:47 <geekosaur> if you know what type m is, you know what type w is
14:03:53 <skypers_> “there’s only one monoid for a given monad”
14:03:57 <skypers_> ok
14:04:02 <skypers_> it’s weird then
14:04:19 <geekosaur> this means the compiler is allowed to keep track of how you use it so that you don't have to constantly tell it which one you want to use
14:04:28 <geekosaur> (with explicit type annotations)
14:04:33 <sipa> it means that if MonadWriter w1 m1 and MonadWriter w2 m2, and w1 == w2, m1 must also == m2
14:05:05 <skypers_> that means we can’t have two instances of MonadWriter if the monads part is the same but not the monoid?
14:05:48 <sipa> apologies, it's the other way around
14:06:03 <skypers_> sipa: well
14:06:05 <skypers_> m -> w
14:06:12 <skypers_> if we have Identity for m
14:06:16 <hpc> it means each m can write exactly one w
14:06:16 <skypers_> that means we know w?
14:06:19 <hpc> so if you have something like
14:06:29 <hpc> newtype Foo a = Foo (Int, String, a)
14:06:36 <johnw> skypers_: right
14:06:43 <hpc> you can't have a MonadWriter Foo Int, and a MonadWriter Foo String
14:06:44 <skypers_> johnw: it sounds stupid to me
14:06:46 <johnw> skypers_: if you have Identity for m, then you can't use Identity with other values for the monoid in that code
14:06:54 <hpc> even though both are valid, you only get one or the other
14:07:02 <skypers_> yes, so it’s stupid :/
14:07:07 <hpc> in theory, having both instances available would be useful
14:07:08 <johnw> you have to use newtypes to vary the monoid, if you want Identity underneath
14:07:15 <hpc> in practice, being able to infer types is more useful
14:07:26 <johnw> well, it may seem stupid, but what you'd have to deal with without the functional dependency would be a much worse variety of stupid
14:07:46 <johnw> as in, endless tedium and passing proxies everywhere
14:07:52 <skypers_> yeah
14:08:00 <skypers_> it would always ask the type of the monoid I guess
14:08:04 <johnw> i've done it before, gotten code like that to work without the fundep
14:08:11 <johnw> it's just not worth the expressiveness
14:08:17 <skypers_> yeah
14:08:25 <skypers_> I also have this fundep in my lib
14:08:31 <skypers_> ok, and hm
14:08:42 <skypers_> johnw: do you have a solution for the generic instancing stuff?
14:08:58 <johnw> i may have missed that part of the discussion; what is that?
14:10:00 <skypers_> I’d like to express the fact that if something is in MonadTrans and the base monad is in my typeclass, I’d like the transformer to be in there as well
14:10:18 <skypers_> I tried to express that
14:10:36 <johnw> it's very hard to craft instances fro a "subset of a having this constraint"
14:10:40 <skypers_> but i get overlapping intances due to the head not taken in account while resolving instancing
14:10:52 <skypers_> is it at least possible?
14:10:56 <johnw> can you show me what you tried?
14:11:02 <skypers_> yep, wait
14:11:29 <skypers_> johnw: http://lpaste.net/100285
14:11:39 <skypers_> this is some code of my monad-journal recent package
14:11:48 <johnw> ah, that was you!
14:11:53 <johnw> just read your blog post today
14:12:13 <skypers_> :)
14:12:16 <skypers_> yep it’s me
14:12:16 <johnw> so, I try doing this a different way
14:12:34 <johnw> class Monad m => MonadJournal' w m | m -> w ...
14:12:48 <johnw> type MonadJournal w m = (Monoid w, MonadJournal' w m)
14:13:02 <johnw> that way, every one who expresses a MonadJournal constraint, is expressing a Monoid constraint
14:13:13 <johnw> rather than trying to get the instance deciding mechanism to do it
14:13:37 <skypers_> I don’t really get the difference
14:13:48 <7JTAAAOAU> nn
14:13:50 <johnw> oh, sorry
14:13:52 <johnw> I misread the code
14:13:58 <johnw> you have MOnoid w on the *class*, not the instance
14:14:12 <johnw> your issue was with MonadTrans
14:14:25 <johnw> and the error you get is?
14:14:28 <skypers_> yes
14:14:31 <skypers_> well
14:14:36 <skypers_> i have a default transformer
14:14:37 <7JTAAAOAU> um my nick , who did that
14:14:40 <skypers_> if you have read my blog
14:14:47 <skypers_> you might have heard of JournalT
14:14:56 <johnw> yes
14:15:16 <skypers_> so I use it to express something in JournalT w (MaybeT IO)
14:15:31 <skypers_> it whines for overlapping instances
14:15:44 <skypers_> ghc doesn’t know which one to pick between the generic one
14:15:50 <johnw> do you get that "no bigger than instance head" error?
14:15:52 <skypers_> and the instance for JournalT
14:15:57 <skypers_> hm
14:15:58 <skypers_> wait
14:16:01 <skypers_> gonna try it again
14:16:47 <skypers_> johnw: http://lpaste.net/100286
14:17:13 <johnw> ah, yes
14:17:18 <johnw> because both instances are directly applicable
14:17:24 <skypers_> yes
14:17:37 <johnw> I don't know of a way to have it pick the "more concrete", i.e., JournalT w being better than t
14:17:57 <skypers_> [23:16] <johnw> I don't know of a way to have it pick the "more concrete", i.e., JournalT w being better than t
14:18:05 <johnw> yeah, sorry
14:18:05 <skypers_> well, JournalT w is more specific
14:18:12 <skypers_> it should take the more specific :(
14:18:36 <johnw> it won't even chose t vs. Int, if you have instance Num t => Foo t and instance Foo Int, I don't think
14:19:17 <skypers_> so I’m stuck to the nasty solution
14:19:30 <skypers_> depend on transformers, errors, and so on
14:19:44 <skypers_> to write dozens of time the same implementation for all transformers
14:19:46 <skypers_> :(
14:19:54 <johnw> yep
14:19:58 <johnw> welcome to the world of monad transformers
14:20:04 <johnw> I think everyone is in that boat
14:20:14 <skypers_> I don’t understand one point
14:20:40 <skypers_> why ghc does head instance resolution without checking the constraint?
14:20:48 <skypers_> does ghc*
14:20:51 <johnw> i've wondered that myself
14:21:00 <skypers_> there might be a reason for that
14:22:35 <skypers_> isn’t there an extension to that?
14:22:36 <skypers_> at first
14:22:37 <triliyn> skypers_: say you have "instance Foo t => Bar t" and "instance Bar Int". If you later write "instance Foo Int", you've potentially broken code from afar
14:22:45 <skypers_> I thought UndecidableInstances was for that
14:23:04 <johnw> ah, yes, triliyn has it
14:23:16 <skypers_> I don’t :D
14:23:18 <johnw> you don't know at compile-time how many instances of your type class will exist in the end
14:23:28 <skypers_> yes
14:23:37 <pavonia> Isn't that an overlapping instance?
14:24:05 <skypers_> oh
14:24:05 <skypers_> ok
14:24:07 <skypers_> I get it
14:24:13 <skypers_> :(
14:24:18 <triliyn> Yes, it overlaps with everything because any type COULD potentially have a Foo instance
14:24:47 <bennofs> It's called open world assumption
14:24:55 <skypers_> something that bothers me is that I’m gonna need to depend on a lot of packages
14:25:02 <skypers_> transformers, errors, and so on
14:25:07 <skypers_> and people may not use them
14:25:23 <skypers_> so forcing them to install such packages is quite aggressive
14:25:34 <skypers_> maybe I could split it up
14:25:57 <bennofs> skypers_: the layers package is an alternative to mtl which doesn't have this problem iirc
14:26:07 <johnw> i was going to mention layers, and then I didn't
14:26:25 <johnw> skypers_: depending on transformers is perfectly fine
14:26:29 <bennofs> I have only heard about it, not used it
14:26:38 <skypers_> monad-journal would only include MonadJournal and the JournalT transformer, I’d have monad-journal-instances and journal that would be a metapackage
14:26:52 <skypers_> johnw: yes but I’d also need errors
14:26:58 <skypers_> I use it a LOT
14:27:06 <johnw> skypers_: you know, you could just use monad-logger with an IORef
14:27:16 <skypers_> what do you mean?
14:27:27 <johnw> if the aim here is to log "things which are not just text"
14:27:38 <skypers_> it’s my aim, yes
14:27:44 <johnw> monad-logger gives you an interface to logging over IO; you can do anything in your monadLoggerLog function that you want
14:27:49 <skypers_> the aim is also to log stuff from anywhere
14:27:54 <skypers_> IORef is in IO
14:27:59 <johnw> right
14:28:09 <johnw> i've yet to ever want to log in pure code
14:28:14 <johnw> i use trace for debugging, and then remove it
14:28:22 <skypers_> well
14:28:40 <skypers_> my resource loading is 99% pure code
14:28:47 <skypers_> and I have a _lot_ of logs in there
14:29:13 <bennofs> skypers_: I don't think that going from "depending on a lot of packages" to "providing a package with lots of orphan instances" is an improvement
14:29:58 <skypers_> bennofs: huh
14:30:02 <skypers_> orphan instances?
14:30:16 <johnw> instances in a different module from the type class
14:30:21 <bennofs> or from the data type
14:30:35 <skypers_> arf
14:30:35 <skypers_> ok
14:30:44 <skypers_> thank you folks :)
14:30:58 <skypers_> (I always think of “thank you fox!”… might be really tired :D)
14:32:04 <johnw> i don't think have your own type class, and then making an instance for, say, Text for that type class, result in an orphan warning?
14:32:38 <johnw> in fact, a lot of the time you want instances apart from the data types
14:38:55 <foozbaz> it looks like there are several fft packages available `cabal list fft`, all in varying degrees of old-ness...
14:39:12 <foozbaz> i would imagine that the algorithm doesn't get updated much
14:39:25 <foozbaz> but does anybody have an opinion on which package might be best?
14:42:46 <carter> foozbaz: FFT === fftw binding
14:42:58 <carter> foozbaz: for fun or profit?
14:47:55 <jle`> is there a word for 'number blindness'?  where the type system won't catch me accidentally siwtching the bindings of two numbers around or using the wrong number binding
14:48:06 <jle`> i think people can solve it with those dimensional analysis packages
14:49:03 <avaritia> hey could someone explain time me why these errors happen when i uncomment the type declarations for join' and g ? http://lpaste.net/5741697493167505408
14:52:19 <johnw> i *think* that if you make them global functions, instead of in a where clause, it will work
14:53:21 <startling> jle`, "number blindness" is a good way to explain that I think
14:53:50 <johnw> jle`: I think of it as generic types vs. specialized types; when you deal with generic types, they are all interchangeable, even if in reality they aren't
14:53:59 <johnw> it's a step on the word towards dynamic typing
14:54:01 <johnw> road
14:54:16 <startling> see also "boolean blindness"
14:55:39 <pavonia> avaritia: The "arr" in g is not the same type as in filterA, it's a completely new type which is too general as you're using the arr function in g
14:56:37 <johnw> pavonia: is it the monomorphism restriction that is making them match here without the signatures?
14:57:45 <pavonia> Um, I don't think so
14:57:48 <avaritia> pavonia: thank you
14:58:48 <fooozbaz> carter: for fun i suppose
14:58:55 <pavonia> johnw: I'd think it should work if you use g :: ArrowChoice arr  => arr a (Either a a)
14:59:01 <fooozbaz> carter: (sorry; laundry called me)
14:59:02 <carter> fft is fftw bindings
14:59:20 <carter> arb-fft is a neat new thing thats not quite as fast, but nearly so, and straight haskell
14:59:21 <johnw> ahh
14:59:28 <johnw> his type is more generic that what was being inferred
14:59:34 <fooozbaz> carter: that sounds attractive
14:59:44 <carter> fooozbaz: but it only does complex to complex
14:59:46 <fooozbaz> carter: (arb i mean..)
14:59:48 <carter> yes
14:59:50 <carter> yes
14:59:57 <carter> johnw: hopenblas is nearly ready for alpha!!!!
15:00:07 <johnw> schweet!!!
15:00:23 <fooozbaz> carter: that's fine.. i can take normal data to complex with something like "complex n = n + 0i" .. right?
15:00:29 <carter> sure
15:00:33 <carter> arb-fft is also BSD :)
15:00:50 <carter> ian ross has a cool blog series on it
15:00:56 <carter> i may wanna roll my own too at some point, idk
15:01:00 <carter> skybluetrades.net/haskell-fft-index.html
15:01:11 <carter> fooozbaz: also #numerical-haskell is a real channel :)
15:01:44 <fooozbaz> carter: noo... i'm bad at life .. i'll check it out! thanks.
15:01:59 <carter> fooozbaz: soke, i'm worse
15:02:14 <carter> fooozbaz: also i don't advertise it too much
15:02:24 <carter> but its growing
15:02:38 <carter> and as johnw  will attest, LOTS of cool applied math chatter there every day or two
15:03:04 <fooozbaz> carter: haha
15:03:18 <carter> fooozbaz: the amzing thing is now its mostly other folks and not me :)
15:03:41 <fooozbaz> carter: well i may or may not be able to follow all of it.. but maybe i'll learn something lurking..
15:03:47 <carter> EXACTLY
15:03:55 <carter> edumacation by osmosis
15:03:57 <carter> ish
15:04:01 <startling> it works.
15:04:27 <carter> sometimes
15:04:28 <carter> ish
15:04:57 <startling> it's not a substitute for deep learning but it makes wide learning easier.
15:04:57 <skypers_> hop
15:05:09 <skypers_> new version with transformers and either as dependency
15:05:41 <skypers_> it’d be great haddock cronie runs much often
15:14:18 <johnw> both packages I pretty much already depend on everywhere :)
15:14:59 <johnw> throw in lens, just so we get it installed in more places
15:15:15 <carter> skypers_: which lib?
15:15:23 <johnw> monad-journal
15:16:54 <skypers_> yes monad-journal
15:17:02 <skypers_> I passed it full strict in the log type
15:17:08 <skypers_> and added convenient instances
15:17:15 <skypers_> for all transformers and EitherT
15:17:33 <skypers_> ok, it works perfectly
15:17:34 <skypers_> <3
15:20:46 <skypers_> carter:
15:20:46 <skypers_> carter: http://devskypers.blogspot.fr/2014/02/logging-flow-activity.html
15:20:47 <skypers_> I’ve decided to write blog entries yesterday
15:20:47 <skypers_> it’ll be graphics and GPU oriented
15:20:47 <skypers_> those first articles are there for practice
15:20:47 <skypers_> because I’m French, and that I’d like to enhance my english spoken :)
15:21:17 <skypers_> I’m currently writing a huge article on my own 3D engine
15:21:20 <carter> skypers_: grappics gpu or math gpu
15:21:21 <carter> cool
15:21:27 <skypers_> something with step-by-step
15:21:28 <carter> does it do any physics?
15:21:29 <skypers_> both, carter
15:21:36 <skypers_> I have a lot of skills on both
15:21:40 <carter> lurk on #numerical-haskell
15:21:41 <carter> cool!
15:21:43 <carter> from what?
15:22:05 <skypers_> carter: I write demo (as in demoscene)
15:22:09 <carter> cool
15:22:15 <skypers_> I have two 64k intros up to now
15:22:16 <carter> i know very little  about that space
15:22:19 <carter> oh/?
15:22:28 <carter> what substrate?
15:22:33 <carter> c / js / asm / c++ / what?
15:22:42 <skypers_> http://www.pouet.net/user.php?who=93160
15:22:45 <skypers_> C++11
15:22:54 <skypers_> the engine appeared in the second one
15:23:03 <skypers_> and I decided to moved it into Haskell
15:23:05 <carter> any videos of the runs/
15:23:08 <carter> cool
15:23:12 <skypers_> yep
15:23:13 <skypers_> in the link above :)
15:23:14 <carter> skypers_: have you seen llvm-general?
15:23:19 <skypers_> no
15:23:33 <carter> @hackage llvm-general
15:23:33 <lambdabot> http://hackage.haskell.org/package/llvm-general
15:23:38 <carter> (also theres #haskell-llvm)
15:24:17 <skypers_> sound pretty huge
15:24:20 <skypers_> sounds*
15:24:20 <glaebhoerl> there was a venn diagram of type system quality depicting as circles (good | bad) programs (accepted | rejected) by the type system
15:24:24 <glaebhoerl> but I can't find it
15:24:32 <glaebhoerl> anyone know where I might and/or how I should look for it?
15:24:39 <glaebhoerl> (my attempts to use google were unsuccessful)
15:24:49 <carter> skypers_: which?
15:24:49 <skypers_> no, sorry
15:24:58 <skypers_> the llvm binding
15:25:02 <carter> eh
15:25:08 <carter> its exactly the size it has to be
15:25:15 <skypers_> :)
15:25:15 <carter> but it gives you a nice haskelly way of using llmv
15:25:17 <carter> SO
15:25:26 <carter> think what that means for demo scene engineering :)
15:25:37 <carter> you could write crazy demoscene DSLs :)
15:25:52 <skypers_> I don’t know, if it outputs to C++
15:25:53 <skypers_> yes indeed
15:25:55 <absence> mm_freak_: is there some description/tutorial on the differences in netwire 5? in particular events don't seem to be inhibiting identity wires anymore but always produce (Event or NoEvent). why is that?
15:26:01 <carter> and then generate code and tell llvm  -Os
15:26:11 <carter> skypers_: it generates native code via llvm
15:26:40 <skypers_> how does it work?
15:26:40 <skypers_> I mean
15:26:49 <skypers_> my two first intros weigh something like 40kB
15:26:59 <skypers_> music included
15:27:06 <carter> well
15:27:10 <skypers_> a Haskell HelloWorld is 1,4 MB weight
15:27:10 <carter> hrm
15:27:12 <carter> yes
15:27:14 <carter> i'm saying
15:27:19 <carter> you don't compile haskell code
15:27:24 <carter> you write a wee compiler in haskell
15:27:34 <carter> LLVM is the backend used by clang
15:27:44 <carter> llvm-general lets you use that backedn
15:27:50 <skypers_> yeah, got it
15:28:01 <skypers_> sounds pretty crazy
15:28:37 <skypers_> why isn’t there any haddock on hackage?
15:28:46 <skypers_> for llvm-general for instance
15:29:12 <carter> 'cause llvm 3.4 isn't installed on the build bot
15:29:36 <skypers_> ok
15:29:37 <carter> and neither any hackage trustee nor the maintainer have done a by hand upload
15:29:40 <carter> it does build :)
15:29:57 <carter> skypers_: anyways, #haskell-llvm and #numerical-haskell
15:30:04 <carter> they relate to your interests
15:30:05 <carter> ALSO
15:30:18 <carter> newer LLVM versions let you emit NVPTX and the AMD/ATI analogue
15:32:41 <carter> skypers_: i cant find the video links on the demo scene page
15:32:59 <carter> found it
15:33:09 <kristof> odd
15:33:28 <skypers_> carter: :)
15:33:31 <kristof> this type signature....
15:33:36 <kristof> Ah, never mind, got it.
15:35:36 <dagle> Can I in any way import a module that is hidden in a package?
15:36:05 <c_wraith> dagle: nope.
15:36:14 <dagle> I need to import connect_OBJECT_STRING__NONE from gtk/gtk-signals and it's hidden.
15:37:10 <dagle> c_wraith: The solution is to patch the haskell-binding for gtk?
15:37:33 <c_wraith> dagle: yeah, that's the only thing you can do.
15:40:25 <skypers_> carter: I read about LLVM and Haskell
15:40:30 <carter> oh?
15:40:32 <carter> what'd you read?
15:40:36 <carter> where?
15:40:45 <skypers_> it says that GHC backend to LLVM is sometimes faster than the C one (gcc)
15:41:01 <skypers_> sounds really… woah!
15:41:06 <carter> skypers_: default GHC uses its own native code gen
15:41:15 <carter> there *is* a C based backend
15:41:25 <carter> but on major Architectures its not used by default ever
15:41:47 <skypers_> so, there’s a way to ask GHC to output to LLVM?
15:41:58 <carter> yes
15:41:59 <carter> -fllvm
15:42:10 <no-n> if i have zs = xs ++ ys at the module level, is the ++ operation carried out every time I ask for zs or just the first time?
15:42:14 <carter> skypers_: that said
15:42:15 <skypers_> would it decrease the size of the executables?
15:42:20 <carter> ummm
15:42:34 <carter> reducing inlining and doing dynamic linking would do that more :)
15:42:43 <dagle> Does the C backend generate ansi C yet? Last time I checked it didn't and nobody seemed to care.
15:42:55 <carter> dagle: it uses GCC extensions
15:42:59 <carter> so not gonna happen
15:43:00 <carter> afaik
15:43:08 <c_wraith> There isn't even a C backend anymore
15:43:10 <Peaker> most GCC extensions are supported by clang though
15:43:13 <carter> c_wraith: nope, there is
15:43:16 <dagle> But it had a flag for generating ansi C.
15:43:22 <carter> yes, c_wraith  is wrong
15:43:23 <dagle> But it did nothing.
15:43:29 <carter> dagle: it did?
15:43:30 <carter> where?
15:43:42 <dagle> This was 2-3 years ago.
15:43:47 <dagle> I tried it.
15:43:55 <carter> dagle: if you wanna figure out making it generate ansi C, i'm happy to help guide yah
15:44:08 <carter> that would be a nice patch
15:44:13 <c_wraith> carter: I guess I have to believe you, but that contradicts everything else I've read about GHC recently
15:44:20 <carter> c_wraith: read where?
15:44:34 <carter> c_wraith: how else would ghc run on PPC64 and friends?
15:44:35 <absence> skypers_: you're not going to get intro size executables out of ghc i'm afraid, regardless of backend
15:44:37 <Peaker> c_wraith, http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html "unregistraized mode"
15:44:44 <carter> yup
15:44:49 <Peaker> "Unregisterised compilation" that is
15:44:52 <skypers_> absence: yeah
15:44:58 <carter> skypers_: use haskell as a compiler tool
15:44:59 <skypers_> it’s not a matter anymore
15:45:04 <carter> to write a mini language for code gen
15:45:07 <skypers_> my next one will be an unlimited demo
15:45:09 <carter> and then use llvm-general to generate the code :)
15:45:12 <carter> or that
15:45:16 <dagle> Well, it would be useful from time to time, since C isn't a fast target but more portable than most code generators and such.
15:45:19 <kristof> I've heard *lots* of good things about writing compilers in Haskell.
15:45:28 <Peaker> c_wraith, you're right that it is no longer available for general use -- it's now just a way to bootstrap GHC to new platforms
15:45:30 <skypers_> probably
15:45:39 <skypers_> but it’s not the challenge I accepted
15:45:41 <c_wraith> Peaker: ah, I see
15:46:01 <skypers_> I want to prove some of my scener friends that FPL and especially Haskell can kicks asses in realtime rendering
15:46:09 <skypers_> kick*
15:46:15 <carter> skypers_: lurk on #numerical-haskell and #haskell-llvm :)
15:46:16 <carter> please
15:46:30 <absence> skypers_: weren't there a couple of haskell demos by some group?
15:46:48 <c_wraith> carter: I see. There's no C code generation unless you make a special build of GHC to do *only* C code generation.  That's quite unlike the situation a few years ago.
15:46:53 <carter> yes
15:47:08 <skypers_> absence: two or three, yes
15:47:09 <carter> well yeah, i think its because we now have our own ABI
15:47:12 <skypers_> but they’re old
15:47:25 <carter> c_wraith: also clang doesn't let you mess with ABI as much as GCC
15:47:40 <carter> like you can't say "this global variable is always in this register"
15:47:47 <skypers_> carter: I’ll be lurking tomorrow, I can’t join freenode with irssi because of the DDoS :(
15:48:02 <carter> aren't you on freenode right now?
15:48:22 <c_wraith> carter: I think the key part was "with irssi"
15:48:26 <kristof> skypers_: I was about to point you in the direction of carter but it turns out that he was already in here, ha
15:48:43 <skypers_> carter: my nick is skypers, not skypers_, I’m through a webchat
15:48:47 <absence> generating code from a haskell dsl would be interesting though. i'm toying with the same idea, only for audio synthesis instead of intros
15:49:07 <kristof> skypers_: Oh, could you not connect from your client either?
15:49:16 <skypers_> nope
15:49:22 <c_wraith> absence: have you looked at atom as an example of generating code from a dsl?
15:49:35 <skypers_> the staff from freenode just told me it’s normal
15:49:41 <skypers_> and it’s because of the attacks
15:49:55 <skypers_> generating code from a DSL in Haskell
15:49:56 <skypers_> hm
15:49:57 <skypers_> why not
15:50:11 <skypers_> but I like thinking I’m writing Haskell
15:50:21 <skypers_> not something that will be compiled into LLVM
15:50:22 <c_wraith> skypers_: atom is really clever.  It generates real time quality C code from a haskell DSL
15:50:45 <hiptobecubic> what ddos?
15:50:49 <skypers_> c_wraith: so you think you can’t write realtime Haskell?
15:51:03 <skypers_> hiptobecubic: no idea, some dudes DDoS’ed freenode’s server
15:51:22 <absence> c_wraith: briefly, but i seem to recall it confused me. i've done some very basic experiments that sort of worked though, but atm the bigger problem is figuring out what the dsl should look like :)
15:51:29 <pharaun> ddos going on with freenode? :|
15:51:41 <c_wraith> skypers_: you can't use GHC to produce hard realtime code.  It's just not engineered for that.  It allocates lots, and collects garbage with a stop-the-world collector.
15:51:51 <dagle> I think so. Freenode is really unstable on some nodes.
15:52:03 <dagle> Got connected to a server but couldn't join any rooms.
15:52:15 <pharaun> c_wraith: any particular reason behind stop-the-world collector or is it just good enough?
15:52:33 <c_wraith> skypers_: atom generates hard realtime code..  It does no allocation, uses no recursion, and so on and so forth.
15:52:43 <jle`> is there a void for Monads (and not Functors) ?
15:52:49 <skypers_> c_wraith: I see…
15:52:55 <pharaun> oh! atom
15:52:57 <pharaun> i should play with that
15:53:04 <no-n> is a definition that takes no arguments computed every time I ask for it or just the first time?
15:53:11 <skypers_> so why not directly include atom in the backend of ghc?
15:53:17 <geekosaur> freenode seems to be better now
15:53:25 <geekosaur> (watch, I just jinxed it...)
15:53:30 <jle`> no-n: i think it is not recomputed if it is not polymorphic
15:53:31 <c_wraith> pharaun: It's mostly just that it's good enough so far.
15:53:50 <carter> skypers_: atom has a restricted compute model
15:54:09 <c_wraith> skypers_: because atom can't be used for general-purpose code.  The whole point of the DSL is to only allow you to express things that fit in the hard realtime model
15:54:11 <jle`> for example, n :: Num a => a is recomputed every time I think...i don't think there is any memoization per-typeclass
15:54:15 <jle`> but n :: Int is not
15:54:35 <skypers_> c_wraith: huh
15:54:37 <skypers_> like what?
15:54:40 <jle`> this is the kind of headache that the monomorphism restriction is meant to alleviate
15:54:58 <carter> skypers_: atom has no recursion
15:55:02 <c_wraith> skypers_: you have to be able to put a hard upper bound on the memory used by every function.
15:55:04 <jle`> for example if you type n = 9, you usually would expect it to only compute once
15:55:20 <jle`> but the 9 literal is polymorphic, so it technically can't do this without per-typeclass memoization
15:55:34 <geekosaur> skypers_, atom is not intended to be part of ghc, it's a way to let you generate (non-haskell) code for embedded devices more conveniently. you may be thinking of stuff that nhc98 used to do, but it's long dead
15:56:02 <no-n> ahhh
15:56:06 <jle`> (unless the monomorphism restriction is enabled)
15:56:06 <pharaun> c_wraith: works for me, thanks :)
15:56:12 <absence> skypers_: that said, there is another haskell compiler, ajhc. it generates c code that can run on microcontrollers. probably not hard real-time, but might be interesting: http://ajhc.metasepi.org/
15:56:13 <jle`> (it's enabled by default)
15:56:18 <no-n> what's the monomorphism restriction?
15:56:30 <jle`> if you type n = 9, and later use n as an Int
15:56:36 <jle`> then it infers that the type signature of n is Int
15:56:38 <c_wraith> yeah, ajhc doesn't produce hard realtime code, but that's far from being useless.
15:56:39 <skypers_> I already know ajhc :)
15:56:39 <jle`> instead of Num a => a
15:56:46 <no-n> ahh
15:57:00 <jle`> so you can't use n as both an Int and an Integer, for example
15:57:08 <no-n> *nod*
15:57:15 <jle`> but if it's off, you can use n as any number typeclass.
15:57:20 <no-n> that's enabled by default?
15:57:29 <jle`> even if it's on, you can force polymorphism by giving an explicit type signature
15:57:33 <jle`> yes, it's enabled by default
15:57:39 <absence> c_wraith: seems it can be used to implement interrupt handlers though, which is pretty impressive!
15:57:46 <jle`> whether or not that's a good idea is a topic of much debate.
15:57:53 <no-n> *nod*
15:58:15 <jle`> because it leads to unexpected behavior a lot of times
15:58:16 <c_wraith> absence: yeah, ajhc is great for what it does..  It's just short of hard-realtime. :)
15:58:19 <jle`> actually it's mostly annoying on ghci
15:58:31 <jle`> so in 7.8 it's turned off by default
15:58:32 <Peaker> is pureMD5 fast? Or should I use md5 bindings to some c libs?
15:58:35 <jle`> for ghci only
15:58:46 <carter> Peaker: use the c bindings
15:58:56 <carter> the code generated from the pure HS stuff is ....
15:58:57 <geekosaur> but not having the monomorphism restriction also leads to unexpected behavior (specifically, lack of sharing)
15:59:02 <Peaker> http://hackage.haskell.org/package/nano-md5 ?
15:59:09 <carter> oh
15:59:13 <carter> idk that one
15:59:13 <jle`> yeah, there is unexpected behavior either way
15:59:16 <carter> that might be fine
15:59:17 <skypers_> I’m sure it’s possible to write good realtime performance stuff in haskell
15:59:18 <jle`> so ... :|
15:59:27 <carter> skypers_: yes, but the tooling isn't there yet
15:59:27 <skypers_> without LLVM, atom or anything else like that
15:59:32 <carter> skypers_: ehh
15:59:33 <skypers_> the tooling?
15:59:37 <carter> yes
15:59:43 <jle`> although with it off, the unexpected behavior is easier to expect, arguably
15:59:45 <skypers_> we already have nice profiling tools!
15:59:48 <Peaker> carter, which one do you know?
15:59:49 <no-n> :(
16:00:00 <jle`> hm
16:00:04 <jle`> did i mix that up?
16:00:06 <carter> skypers_: no, tooling for bounding latency
16:00:07 <jle`> i have no arguments either way.
16:00:13 <carter> Peaker: lemme find the crazyon one thats bad
16:00:19 <no-n> the :( was at the netsplt
16:00:26 <c_wraith> skypers_: soft realtime is probably possible with GHC, but it requires a lot of careful programming.
16:00:29 <Peaker> carter, yuck, the nano-md5 result is a String
16:00:45 <carter> https://github.com/GaloisInc/SHA/blob/master/src/Data/Digest/Pure/SHA.hs i don't like the code in ehre
16:00:47 <carter> yeah
16:00:50 <carter> i agree with c_wraith
16:01:05 <carter> skypers_: GHC doesn't have a Real Time GC option (yet)
16:01:11 <carter> no reason why it couldnt
16:01:13 <carter> just doesnt
16:01:22 <Peaker> https://hackage.haskell.org/package/cryptohash-0.6.3/docs/Crypto-Hash-MD5.html <-- seems nicer
16:01:31 <carter> coll
16:01:31 <skypers_> ok
16:01:33 <skypers_> :)
16:01:39 <carter> skypers_: are you a student or ?
16:02:06 <skypers_> not really
16:02:11 <skypers_> well
16:02:24 <skypers_> I’m studying IT engineering but I also have a job
16:02:33 <skypers_> in Essilor International
16:02:41 <c_wraith> So you're a student in spirit? :)
16:02:54 <skypers_> (I do industralization stuff, with scheduler and so on)
16:02:55 <carter> ok
16:02:56 <carter> cool
16:03:04 <skypers_> c_wraith: not really :D
16:03:07 <carter> you mean Operations Research optimization?
16:03:10 <skypers_> I hate sitting there and wait
16:03:32 <skypers_> I mean scheduling and automation
16:03:36 <carter> yes
16:03:42 <carter> whats an example
16:03:51 <skypers_> I don’t know the english term
16:04:00 <skypers_> in France we just say Industrialization
16:04:10 <carter> @google operations research
16:04:11 <lambdabot> http://en.wikipedia.org/wiki/Operations_research
16:04:11 <lambdabot> Title: Operations research - Wikipedia, the free encyclopedia
16:04:18 <skypers_> anyways
16:04:28 <skypers_> why would I be a student in spirit? :)
16:04:29 <sipa> skypers_: can you give some examples of what that entails?
16:05:15 <c_wraith> skypers_: love of learning, drive to keep learning
16:05:34 <skypers_> sipa: yes; we have clients (internal or external) that have some issues like “hey, I’d like some monitoring on that part” or “we need some purges, reboot and back each two months with these constraints”
16:05:37 <c_wraith> skypers_: the important parts of being a successful student, rather than just someone spending time in a school. :)
16:05:57 <skypers_> I think it’s related to be student, c_wraith
16:06:11 <skypers_> but I’m someone very curious and self-trainer
16:06:55 <skypers_> I mean
16:06:59 <skypers_> self-educated
16:07:27 <carter> great
16:07:27 <skypers_> I love learning, and getting more and more into complexe stuffs
16:07:32 <carter> that means you'll eventually be an expert!
16:07:39 <skypers_> but I think I’m definitely not a student
16:07:48 <skypers_> carter: in GPU? I hope so!
16:07:52 <c_wraith> skypers_: I think the problem is that you don't know the english idiom "in spirit".  You're describing exactly what I meant by "student in spirit". :)
16:08:06 <skypers_> no, I got it
16:08:12 <skypers_> we have the same idiom in France
16:08:31 <skypers_> but we definitely don’t have the same meaning for “student”
16:08:39 <c_wraith> ah, I see
16:09:39 <skypers_> in France, “student in spirit” would be like “I only trust my teachers like a blind guy and I have absolutely no professional experience, but I like reading books” you know
16:09:55 * startling is a student and also a ghost
16:10:08 <skypers_> whereas the closest spirit to your “student in spirit”, in France, would be something like “researcher in spirit” :)
16:10:13 <c_wraith> startling is the other kind of student in spirit. :)
16:10:25 <skypers_> :)
16:11:48 <skypers_> now I’m off, I’m exhausted
16:11:54 <skypers_> talk to you later folks
16:11:59 <skypers_> bye
16:32:19 <bpeak> Can I force a function to return a [Char]? https://gist.github.com/0d6cfb97778bbd356b75 is currently returning IO [Char], but I need [Char]
16:32:42 <dagle> bpeak: Yes but you shouldn't.
16:32:54 <geekosaur> what you need to do is learn how to use IO
16:33:15 <roboguy_> bpeak: where do you need it to be a [Char]?
16:33:39 <geekosaur> oh, i thoguht that looked familiar
16:33:52 <geekosaur> this is a continuation of stuff in #xmonad a few hours ago
16:34:44 <geekosaur> bpeak: you can use (>>=) to bind something that needs a [Char] into the IO computation, or you can use do notation which does that behind the scenes
16:35:05 <bpeak> roboguy_: I need a [Char] for: , ("M-a z", appendFilePrompt myXPConfig [Char]_goes_here) (xmonad)
16:35:16 <geekosaur> what you cannot do is make an IO [Char] into a [Char] directly
16:35:25 <geekosaur> @quote /bin/ls
16:35:25 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
16:35:43 <bpeak> I'd like to be able to pass a paremeter to a function, for instance "file.txt" and get a string such as "/home/bpeak/file.txt"
16:36:09 <roboguy_> bpeak: you can't get just String back though. you have to get back an IO String
16:36:22 <roboguy_> then use fmap or >>= to work with it
16:36:25 <geekosaur> so, what I showed you in #xmonad earlier:   getEnv "HOME" >>= \n -> appendFilePrompt myXPConfig (h ++ "/file.txt")
16:36:25 <roboguy_> or do notation
16:36:27 <geekosaur> er
16:36:28 <Clint> is there some library for directed cyclic graphs?
16:36:34 <jle`> IO String is not just a string wrapped in an IO container
16:36:39 <geekosaur> getEnv "HOME" >>= \h -> appendFilePrompt myXPConfig (h ++ "/file.txt")
16:36:52 <jle`> it's not something you can just pop out
16:36:52 <Earnestea> bpeak: Linux/BSD?  If it doesn't start with '/', use the PWD
16:36:52 <levi> That function would be \x -> "/home/bpeak/" ++ x ;)  If you wanted it to actually access your filesystem, it wouldn't be a function, it would be an IO action.
16:36:54 <c_wraith> Clint: does fgl work for you?
16:37:21 <geekosaur> and yes, the easiest solution is that your xmonad should be running in $HOME so you should not need a path
16:37:28 <Earnestea> None of those "HOME" + file solutions will work
16:37:33 <Clint> c_wraith: no idea, but i'll look, thanks
16:37:45 <Earnestea> There is the assumption that file is directly under HOME
16:38:04 <geekosaur> Earnestea, I think you are answering a different question that was asked
16:38:22 <Earnestea> bpeak's question?
16:38:32 <geekosaur> the original question in #xmonad was wondering why apendFIlePrompt myXPConfig "$HOME/file.txt" did not work
16:38:51 <geekosaur> you seem to be assuming the $HOME part is wrong
16:38:56 <geekosaur> as in, inappropriate
16:39:03 <Earnestea> Oh I see, so it is directly under HOME in this case
16:39:13 <Earnestea> Which sounds like an XY to me, but okay
16:39:26 <geekosaur> only if you have decided that they must not mean that
16:39:43 <geekosaur> but this is xmonad, it would be expected to be running in $HOME and I am not sure why you would asusme they mean anything else
16:39:51 <jle`> hi all. hvaving some monad transformer woes.  I have a library that lets you set callbacks using setCallback :: IO () -> IO () --- you pass it a callback and it sets the global callback to be that callback.  yes it's bad i know, not my library.  anyways, i want to move everything into MonadIO m.  My callback is itself an m ().  How do I make that setCallback :: MonadIO m => m () -> m () ?
16:40:09 <Earnestea> geekosaur: Xmonad usually runs in ~/.config/xmonad or ~/.xmonad for me.
16:40:13 <jle`> is this what hoist does?
16:40:23 <geekosaur> then you;ve hacked yours
16:40:43 <geekosaur> xmonad runs where startx or the X session goop leaves it, this is usually $HOME
16:40:46 <Earnestea> Still seems fairly poor practice to just blindly prepend the HOME env :/
16:41:03 <Earnestea> Oh well, nevermind me
16:41:33 <geekosaur> unless the name service screwed up and drpped you in / but in that case you don't usually *have* an accessible $HOME...
16:43:56 <jle`> perhaps this is just for his own custom config?
16:44:47 <levi> jle`: So you want to change setCallback to accept any MonadIO rather than just IO?
16:45:30 <jle`> levi: yes
16:45:39 <jle`> and have it return a MonadIO, as well
16:45:49 <jle`> some kind of...monad functor
16:46:19 <jle`> MonadIO m => (IO () -> IO ()) -> (m () -> m ())
16:46:40 <jle`> is this possible?
16:47:23 <Axman6> I'm not sure that makes much sense
16:47:54 <Axman6> what about things like StateT s IO a? how will the current state be communicated/set to/from the callback?
16:48:24 <levi> Well, you can lift an IO action into a MonadIO with liftIO, but I don't think you can go the other way.
16:48:54 <jle`> presumably some sort of typeclass
16:48:58 <jle`> would handle the transition
16:51:05 <jle`> if StateT instanced the MonadFunctor, the it would handle all the specifics of the transition
16:52:27 <Axman6> actually, since you're using something of tyoe (IO () -> IO ()), the inner function won't be able to access the state anyway, so it could be run with an undefined state safely
16:52:44 <jle`> yeah
16:52:57 <jle`> the transition would not be a difficult one i think.
16:53:03 <startling> jle`: I think that's MonadCatch?
16:53:17 <jle`> i'm looking through Control.Monad.Morph but i am not sure what I am looking for.
16:53:41 <startling> no, it's not.
16:53:41 <jle`> startling: hm, where would that be?
16:53:50 <startling> I know it's somewhere, I just forget what it's called. :<
16:54:13 <jle`> Control.Monad.Morph has an MFunctor typeclass but I'm not sure it's what I want
16:54:55 <startling> Well, IO () -> IO () doesn't make a whole lot of sense
16:55:18 <jle`> startling: it's a global callback setter from this regrettably constructed library
16:55:30 <jle`> it sets a global IO () callback to the IO () that you pass into it
16:56:22 <jle`> presumably it's something like setCallback cb = setIORef ref cb
16:57:10 <jle`> i guess i could dig into the source code of it and write a replacement, if it exports enough things
17:05:54 <jle`> no luck, the actual internal IO () is wrapped in a newtype that doesn't export a constructor
17:10:38 <jle`> i guess I'm looking for a (m () -> m ()) -> (t m () -> t m ())
17:11:15 <startling> jle`: what does m () -> m () do?
17:11:52 <hpc> isn't that the same as having lift and "unlift"?
17:12:18 <jle`> startling: in general? or in this case?  in general...i guess it is a monad combinator of some sort
17:12:41 <jle`> perhaps more generally (m a -> m b) -> (t m a -> t m b)
17:13:08 <jle`> i can write it without problems for a specific monad transformer, i think
17:15:47 <jle`> hm. lift the argument, unlift the output?
17:16:20 <jle`> or maybe unlift both
17:19:35 <c_wraith> jle`: that one's tough.  monad-control is a package for that particular problem.
17:20:54 <syao> hello, is there a book on software design in functional programming? I was searching, but found none.
17:21:16 <hpc> there is, i don't know the name offhand
17:21:33 <FreeFull> A lispy functional language is quite different from Haskell though
17:21:49 <FreeFull> So I'd expect for there to be both similarities and large differences
17:22:11 <hpc> pearls of functional design, or something like that?
17:24:03 <c_wraith> hpc: there is a book by that name, but it's about algorithm design, not software design
17:24:14 <c_wraith> hpc: it's also a fantastic book. :)
17:24:17 <Twey> syao: Okasaki's ‘Purely Functional Data Structures’ is great
17:25:06 <syao> Twey, yes the data structures are OK, but what about the software design?
17:25:16 <Twey> That's about data-structure design, but I think that if you get your data structures right everything else will pretty much follow
17:25:25 <hpc> Twey: i was about to mention that, but thought better of it because it's not really "software design"
17:25:33 <in_the_mist> Does anyone know what the function ($[]) is? I can't find any info anywhere.
17:25:44 <jle`> @src ($)
17:25:44 <lambdabot> f $ x = f x
17:25:48 <Twey> syao: What design decisions, exactly, are you looking for guidance in making?
17:25:58 <jle`> in_the_mist: so ($[]) f = f []
17:26:02 <Twey> in_the_mist: It's a section of ($) applied to [] (the empty list)
17:26:07 <hpc> in_the_mist: welcome to the weird world of flip ($)
17:26:28 <in_the_mist> Hm. Thanks
17:26:37 <hpc> :t ($ False)
17:26:40 <lambdabot> (Bool -> b) -> b
17:26:52 <jle`> :t ($)
17:26:52 <lambdabot> (a -> b) -> a -> b
17:27:48 <jle`> (was wondering where `b` came from)
17:28:08 <hpc> jle`: welcome to the weird world of flip ($)
17:28:12 <Twey> syao: There's the question of how to divide up your modules, but it's not really a difficult or very important decision (you can occasionally run into some recursive-import issues if you did it wrong, but it's trivial to experiment until you get the idea).  The most important thing, I think, is how you design your data structures.  That will inform the design of your API and your algorithms.
17:28:38 <hpc> or if you do it very very right, your data structures /are/ the api and algorithms
17:28:48 <jle`> heh. was refering to why it was `b` and not, say, `t` or `a`
17:28:49 <Twey> Right
17:29:14 <hpc> see also, the general concept of "lists are loops waiting to happen"
17:29:24 <Twey> syao: I guess some interesting design decisions arise when structuring concurrent or distributed programs; Simon Marlow has a good book on that, ‘Parallel and Concurrent Programming in Haskell’
17:30:11 <syao> Tway, abstractions, generalizations, granularity. Then the flexibility of changes in data structures and etc..
17:30:27 <Cale> Yeah, an important realisation is that types are our equivalent of UML
17:30:59 <Twey> Rather, UML is just an informal type system
17:32:14 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/ -- this talk by SPJ does a nice job of outlining one of the major approaches to the design of functional programs
17:32:17 <Twey> syao: Abstraction is pretty trivial in a language like Haskell.  You decide to abstract over a parameter, so you make it a parameter to the function/type/constructor and carry on as normal.  :þ
17:32:42 <tel> Is this a sane pipe combinator? Or is there an easier way to achieve this? (>>-) :: Monad m => Producer b m r -> (b -> Producer c m (Maybe r)) -> Producer c m r
17:33:00 <tel> Essentially, I want a `for` which can have early stopping
17:33:10 <syao> Twey, "non distributed" software is just a distributed software that is tightly coupled and not fault-tolerant.
17:33:16 <ski> (though there's no parameterization abstraction at the level of module boundaries)
17:33:55 <tel> p >>- f = for (p >-> dieOnEcho) f where dieOnEcho = await >>= respond >>= maybe dieOnEcho return
17:33:57 <Cale> The idea in this case being that in order to solve a problem, you figure out a language in which your problem is easy to express, and which has the property that each of its primitives has a solution, and the solution to combined problems is some combination of the solutions to the individual problems.
17:34:04 <syao> Twey, wont you have a lot of parameters in this mode?
17:34:23 <Twey> syao: That's… a valid way of looking at it, I guess
17:34:30 <Twey> syao: Only if you abstract over a lot of things…
17:34:49 <ski> well, part of the game is well chosing things to bundle
17:34:50 <Twey> (and don't combine the related parameters together somehow)
17:35:06 <ski> and where to cut up the system, so as to not have to pass some parameters to some parts
17:35:07 <Cale> and this gives you several advantages over a more direct solution to your original problem including improved flexibility to changes in requirements (since you've really solved a whole class of problems), as well as the ability to do other sorts of analyses with the problem descriptions.
17:35:55 <ski> Cale is describing the DSL approach
17:36:00 <Cale> Yeah
17:36:10 <ski> (typically, but not always, EDSL)
17:36:51 <ski> dum de dum
17:38:39 <Cale> For example, in that talk SPJ describes a domain specific language for describing financial contracts, and then once you have such a description, you can simulate the execution of the contract, or generate an English language description of it, or attempt to compute its monetary value at a given time in the future.
17:39:30 <Cale> and all of those are things whose behaviour breaks down recursively in the structure of the contract
17:41:16 <syao> Twey, as you may understand I am mainly OO programmer. I am new in fp. The question I have is: how should I abstract the ex. a location (address, geo,..) to make it flexible. I know that it is kind of OO problem, but I would like to know how should I express it in fp.
17:42:43 <Cale> syao: The answer to that question depends on your program -- what do you need to do with locations?
17:43:02 <syao> Cale, shouldn't it be flexible?
17:43:54 <Cale> syao: Oh, well yeah, once you say what your API for working with locations is supposed to look like, you have to say in which way you'd like it to be flexible.
17:44:32 <Cale> Is it more important to be able to define new basic operations on locations easily, or is it more important to be able to define new basic types of locations?
17:45:11 <syao> in theory it should not depend on the problem. I think flexibility comes with data changes and generics.
17:45:41 <Cale> There's no single silver bullet to the design of data structures.
17:45:47 <syao> so the answer is: I shouldn't pick one of them, so its both
17:46:00 <syao> then we need the dynamic ones
17:46:02 <Earnestea> Why don't you provide an example of your own using your approach?
17:48:18 <Cale> syao: There are two questions you have to consider for any data type: 1) What ways do I have to *construct* values of this type?  2) What ways do I have to *use* (or deconstruct) values of this type?
17:48:43 <c_wraith> Anyone know how fpcomplete sandboxes active code in tutorials?  I'm writing a tutorial with some code in it that isn't type safe, and I want to let people play with it to see that for themselves.  Will the fpcomplete folks get mad at me for saying "do this stuff that could segfault the interpreter if you wanted to"?
17:48:49 <Cale> There are ways to get extensibility for both of those at once, but you end up paying other prices for them.
17:49:45 <syao> Cale, and performance is the price?
17:49:48 <Cale> Usually it's more elegant to pick one of those "axes" in which you'd like to be more extensible than the other.
17:50:23 <Cale> Probably not performance, it becomes more an issue of reliability.
17:50:45 <Cale> If you can easily extend things in both directions, that means you can't rely on either one completely.
17:51:56 <syao> Cale, yes I understand that it is more practical. but lets assume that I have some software that I will develop all my life to mutate it adapt it for the requirements that change, so I cant pick one.
17:52:03 <Cale> If I fix the ways to deconstruct values of a type (i.e. the OO approach), then I get easy extensibility in terms of the ways I have to construct values of that type (I define new constructors in terms of what the objects will do when methods are applied to them)
17:52:52 <Cale> If I fix the ways to construct values of a type (i.e. the traditional FP approach), then I get easy extensibility in terms of the basic operations on values of that type, because the data is completely transparent.
17:53:09 <Cale> Both of these are easy to do in Haskell.
17:54:06 <Cale> If I want extensibility in both, then I can neither rely on my values being constructed in a particular fashion or supporting particular operations.
17:55:04 <syao> As I can see from your talk - it is discouraged.
17:55:43 <no-n> what's the best way to take all of the (key,value)'s of one Data.Map.Map and insert them into another?
17:55:48 <Cale> It's possible to make up for that in Haskell by using type classes -- with enough class constraints and instances, you can do whatever you like, but the result is perhaps not as easy to work with -- so you'd better really need that generality.
17:55:51 <geekosaur> it's discouraged because it's not very meaningful. haskell makes it harder to get into that condition, some other languages let you do it and then crap out at runtime when you forgot something
17:55:58 <Cale> no-n: union
17:56:08 <no-n> thanks ^_^
17:56:30 <geekosaur> because, if it's that utterly general, nothing can validate your code for you --- any error is necessarily a runtime error
17:57:26 <FreeFull> You could even implement a Lisp in Haskell
17:58:33 <Cale> syao: Be wary of anyone who claims that X-driven-development solves all problems, for any particular X.
17:58:43 <syao> But if you stick with one, you either have easy data abstraction or easy data manipulation. And having only one does make you "hack" when you need another one.
17:59:30 <Cale> syao: Well, one nice thing is that in Haskell if you make a change to a data type after the fact, the compiler is going to go and find all the places where your code needs to be fixed up to deal with the changes.
17:59:37 <shachaf> I,I X-Driven-Development: 1
18:00:42 <Cale> syao: I usually make the decision about which approach I want to take based on the number of constructors my data type would have.
18:01:33 <Cale> It's not nice to have either really large product types, or really large sum types, and if you end up seeming to want one, it's best to take a step back and think about how to break things down further.
18:01:45 * monochrom uses specification-driven development to solve all his problems :)
18:01:54 <syao> Cale, but I think this approach only works when you really know how you software should behave. If it is not evolving like a living thing.
18:01:59 * monochrom is old-school. waterfall ftw
18:02:45 <Cale> syao: Basing your decisions on the dynamics of how your code will change over time is usually quite hard, because you don't know much about that.
18:03:16 <Cale> If you *do* know something about it, you can perhaps prepare a little, but usually it's best to generalise things when you know precisely how they need to be general.
18:03:17 * monochrom concurs that you don't know the future. you don't know.
18:03:29 <syao> Cale, and that is the problem I am wanting to solve (kind of)
18:04:15 <FreeFull> monochrom: How do you solve problems with the specification? =P
18:04:24 <Cale> syao: In Haskell, you'll see a lot of beginners fall prey to the temptation of defining new type classes for everything, even when they only have a single instance.
18:04:49 <syao> I think haskell community is mostly advanced ones, mostly scientific that is why I came here.
18:05:04 <monochrom> every extensibility is only extensibility in one direction and harms extensibility in other directions. if you don't know the future, you always commit to the wrong extensibility.
18:05:19 <FreeFull> Cale: I never fell into that urge, but I didn't come into Haskell from an OO background
18:05:27 <Cale> It's very easy to invent and implement new abstractions in Haskell, but you have to be cautious about whether those abstractions are actually buying you anything, or if they're just distracting from what your program is.
18:05:38 <FreeFull> I don't think I have actually ever made my own typeclass
18:06:34 <lispy> Cale: amen
18:06:35 <geekosaur> I haven't in a serious program (playing around just to make sure I grok them, sue)
18:06:37 <geekosaur> *sure
18:06:40 <Cale> FreeFull: Well, it depends. I wouldn't characterise it as an OO sort of thing to do necessarily. It can even be motivated by mathematics.
18:06:52 <syao> p.s. anyone is using Dylan? Is it worth it? (please, no flame wars)
18:07:07 <lispy> syao: I've never tried it. Is it like erlang?
18:07:22 <FreeFull> Cale: I don't think beginners tend to make too many typeclasses because of mathematics, typically
18:07:34 <Cale> FreeFull: I'm referring to intermediate beginners :)
18:07:54 <Cale> Like, people who understand all the basics of the language and are setting out on their first really big program, for instance.
18:08:03 <syao> lispy, not really. please see http://en.wikipedia.org/wiki/Dylan_%28programming_language%29
18:08:14 <FreeFull> I guess I never got to the "make typeclasses" stage
18:09:05 <Cale> If you ever get the urge to define a type class, always consider what it might be like to define a type of records of those operations instead, and whether that might or might not be more helpful to you.
18:09:25 <FreeFull> Oh, I did actually define a few typeclasses it seems, for my failed Prelude replacement
18:09:48 <FreeFull> I tried to make everything an Integer, and then found out some things were hardcoded
18:09:53 <Cale> and also consider how many instances you'll have, and if that number is 1, then don't do it :)
18:10:50 <greg`> anyone know why i cant cabal install ghc78
18:11:03 <FreeFull> Turns out you can't really replace Bool with your own type and have everything work as before
18:12:21 <FreeFull> I was planning to make a Prelude where everything was a newtype wrapper around Integer, or a function
18:12:22 * hackagebot io-streams 1.1.4.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.1 (GregoryCollins)
18:12:44 <carter> FreeFull: you can, takes some work :)
18:13:04 <carter> FreeFull: in 7.8, Bool is modeled internally is a newtyped Int# :)
18:13:08 <syao> Cale, while you have one instance its OK, but when it extends? you are creating type class?
18:13:19 <greg`> why do you want to replace Bool?
18:13:21 <Cale> syao: Perhaps!
18:13:26 <lispy> greg`: you can't cabal install ghc
18:13:29 <FreeFull> carter: What about 7.6?
18:13:37 <greg`> ah
18:13:42 <Cale> syao: It depends on how you want to reuse the code which operates on values of that type.
18:13:42 <carter> its just a data thingy
18:14:05 <Cale> syao: You might also just be defining a record type consisting of the operations required.
18:14:13 <lispy> greg`: building it from source is pretty straight forward though. Unpack the tarball, configure, make, make install.
18:14:33 <geekosaur> hm, is there a ghc package on hackage for documentation purposes, like there is for base? that might be confusing if it shows up in cabal list
18:14:54 <syao> Cale, but what you are saying it's looks more like practical way of doing, but not a scientific way.. not a general way, not a formal methods way.
18:14:56 <Cale> syao: (possibly parameterised by the type of values which those operations act on, in some cases, or if they give a complete characterisation of the data involved, you might get away with replacing the type wholesale with such a record)
18:14:56 <FreeFull> Int# is still different from Integer, and I don't see how I'd make pattern matching on numbers work using my own Bool and Eq
18:14:57 <geekosaur> ah, yes, I see there is
18:15:13 <syao> Cale, but what you are saying it's looks more like practical way of doing, but not a scientific way.. not a general way, not in a formal methods way.
18:15:40 <geekosaur> sadly that is not an installable compiler, it is library entry points for the compiler and can only be installed as part of a full ghc installation
18:15:41 <Cale> syao: There are formal methods involved here: the formal part is the type system that you're working in.
18:15:45 <FreeFull> Actually, partway through I switched from using Integer to using Numeric.Natural.Natural
18:16:07 <Cale> syao: But sadly, not all problems can be solved by our machines yet, they need help.
18:16:32 <Cale> syao: Otherwise, all the conjectures of mathematics would have been solved by computers already.
18:16:48 <FreeFull> That would take infinite time
18:17:21 <Cale> Programming is really abstractly the same thing as proving theorems.
18:17:37 <syao> Cale, but it's sad that a lot of programmers sit there and make "same" software over and over again and not implementing the essence..
18:18:27 <Cale> syao: You can do better and worse at that, but the question of what the essense *is*, is not a well-posed problem.
18:18:52 <Cale> essence*
18:19:29 <Cale> syao: and how your program will turn out will depend on what you think it is :)
18:19:51 <Cale> Which are the "right" definitions to make?
18:19:59 <Cale> Well, it always depends!
18:20:00 <syao> Cale, it is changing/mutating often and we need to make it adapt
18:20:51 <jbe> Hi
18:21:00 <Cale> There's not necessarily a clear definition of right and wrong when it comes to design, it's a matter of suitability for a given task.
18:21:20 <Cale> (or class of tasks)
18:21:31 <jbe> What does $= mean in Haskell / OpenGL?
18:21:31 <jbe> displayCallback $= display
18:21:32 <jbe> reshapeCallback $= Just reshape
18:21:32 <jbe> and what does Just mean?
18:21:34 <syao> Cale, as you said, computers are not capable in making those decisions yet. But for us, people, it should get easy flexibility.
18:21:41 <Cale> (This is as true for mathematics as it is for programming)
18:21:42 <FreeFull> If the program does what you want it to do, that's one design goal met
18:22:15 <Cale> Jbeu: Just is a data constructor for the Maybe type:  data Maybe a = Nothing | Just a
18:22:30 <geekosaur> syao: every language has this issue, what differs is how it punishes you if you try to streth things too far. but all of them will, one way or another, make your life difficult
18:22:42 <syao> Cale, yes when the task is kind of simple, imagine that the task is "life"..
18:22:46 <Cale> You can think of a value of type Maybe Integer as a box which is either empty (Nothing) or contains a single Integer value (Just n)
18:22:48 <lispy> Jbeu: $= is an assignment
18:23:06 <Cale> Jbeu: $= is the OpenGL library's generalised assignment operation.
18:23:55 <Jbeu> Thanks, Cale!
18:24:01 <lispy> Jbeu: it comes from here: http://hackage.haskell.org/package/OpenGL-2.9.1.0/docs/Graphics-Rendering-OpenGL-GL-StateVar.html
18:24:01 <syao> geekosaur, every known language :)
18:24:05 <Cale> syao: Haha, what is this, "Life is easy, you just suck at it!"?
18:24:22 <geekosaur> syao: I think you are a bit optimistic there
18:24:38 <hiptobecubic> I have an app i've written in python that needs a major redesign and i'd like to rewrite it in haskell. It's going to be challenging though. It needs to run indefinitely and handle streaming data, which i've never managed to do correctly
18:24:56 <hiptobecubic> granted i've never particularly tried
18:25:11 <geekosaur> syao: that sounds a lot like claiming that someone will find a language which can solve the halting problem
18:25:16 <lispy> hiptobecubic: that might endup tricky in Haskell.
18:25:20 <Jbeu> ($=) :: s a -> a -> IO ()
18:25:45 <Cale> syao: There are fundamentally difficult issues. In general, programming will put you up against the most challenging types of intellectual problems that humans face. Not all problems are that hard, and for the easier ones, there might be general solutions which capably deal with wide swathes of them, but in general, there's almost nothing you can do.
18:25:56 <syao> geekosaur, yes :)
18:26:08 <FreeFull> Jbeu: For all s?
18:26:14 <lispy> hiptobecubic: two main reasons: a) does the gc ever give memory back to the OS? If not, it the memory requirements may monotonically increase. b) You'll need to have just the right strictness during the stream processing to make sure you evaluate everything and you're not leaving unevaluated stuff hanging around accumulating.
18:26:15 <geekosaur> ok, you just fell off the bus
18:26:30 <hiptobecubic> lispy, indeed.
18:26:45 <lispy> FreeFull: no, class HasSetter s where
18:26:46 <FreeFull> hiptobecubic: I'm guessing you would probably use something like pipes or conduit
18:27:07 <FreeFull> lispy: now that's completely different
18:27:13 <hiptobecubic> FreeFull, yes i imagine so. I don't really have a good feel for any of them though.
18:27:33 <syao> Cale, so we need to wait for AI :)
18:27:41 <syao> thats how it sounds
18:27:45 <Cale> syao: The AI will probably have the same problems that we do.
18:28:16 <Cale> Or if not, then it will have its own, different obstructions.
18:28:22 <FreeFull> hiptobecubic: Give them a try, maybe with some smaller programs first
18:28:40 <Jbeu> ($=) :: HasSetter s => s a -> a -> IO (), is the type signature I suppose
18:28:48 <lispy> right
18:29:00 <Cale> syao: There are much easier problems than programming language or library design which are computationally undecidable.
18:29:08 <lispy> and you have instances like IORef, StateVar, and SettableStateVar
18:29:23 <syao> Cale, seems so, all the problems that are in social world exist in software world. and its a pity that the solutions are not applied
18:29:36 <Jbeu> function with two arguments a and S, s has typeclass HasSetter and function returns IO monad
18:29:42 <FreeFull> hiptobecubic: I haven't used them at all myself
18:29:57 <Jbeu> matrixMode $= Projection
18:30:09 <Jbeu> matrixMode has typeclass HasSetter i suppose
18:30:19 <syao> Cale, or I could say "solutions" instead.
18:30:22 <Cale> syao: But yes, to the extent that there *are* solutions to general problems, we should use them, and Haskell does do a pretty good job of letting you write code that is *actually* reusable to a respectable extent.
18:30:25 <lispy> bjackman: function returns an IO action (which in turn generates unit when run)
18:30:35 <lispy> oops
18:30:39 <lispy> Jbeu: ^^
18:30:53 <FreeFull> Haskell's laziness helps composability, among other things
18:31:00 <FreeFull> The module system could be better though
18:31:09 <hiptobecubic> FreeFull, I see. Yeah I mean, based on my understanding of what they are trying to do, it seems like they are appropriate. I don't know which is *more* appropriate, if any.
18:31:12 <lispy> I like the simplicity of the module system
18:31:13 <Cale> Laziness helps with compositionality, yes, as well as type classes.
18:31:42 <FreeFull> It's somewhat hard to swap a module for a different one without swapping source files as well
18:31:44 <syao> Cale, P.S. why no latest languages integrate prolog(logic programming) in them?
18:31:45 <Cale> There are places where a fancy module system would do better, but Haskell's module system has a really nice power/weight ratio.
18:31:52 <FreeFull> hiptobecubic: That's open to debate
18:31:56 <Jbeu> Is there a performance penalty for writing code in imperative style in Haskell?
18:32:34 <FreeFull> Jbeu: Not necessarily, it really depends on what you're doing
18:32:43 <syao> Cale, And I am sorry for my stupid questions and reasoning..
18:32:56 <hiptobecubic> FreeFull, the app is essentially a shoutcast radio repeater/broadcaster but with some extra logic in the middle to avoid playing ads.
18:32:57 <triliyn> Jbeu: GHC does a lot of optimizations that take advantage of Haskell's functional properties that don't apply if most of your logic is imperative
18:32:58 <Cale> Jbeu: no, but depending on what you mean by "imperative style", you might be making your life harder with respect to ensuring that your program works.
18:32:58 <FreeFull> Often you'll find a piece of imperative code written in the ST monad, because that was faster
18:33:13 <Cale> syao: No, I think they're natural questions to have :)
18:33:14 <FreeFull> hiptobecubic: What does it play instead? Silence?
18:33:30 <Cale> syao: It's just that the answers happen to be a little depressing.
18:33:38 <hiptobecubic> FreeFull, changes stations
18:33:39 <Cale> (or encouraging if what you care about is job security)
18:33:52 <syao> Cale, lol
18:34:25 <Jbeu> Cale, what do you mean?
18:34:46 <Jbeu> "making your life harder with respect to ensuring that your program works."
18:34:57 <syao> Cale, you know as I see the programming did not go much from lisp/ML times, its like we are stuck..
18:35:08 <hiptobecubic> FreeFull, but the original implementation in python grew organically in 10 minute coding spurts here and there without any real time to go back and rework it, so it's not capable of some of the more interesting things I'd like it to do
18:35:35 <Cale> Jbeu: Well, things which don't have IO in their type can be tested fully in isolation of everything else, and you pretty much have a guarantee that they'll work the same way in the full program.
18:35:49 <Cale> Jbeu: IO actions might rely on any amount of context when executing.
18:35:50 <lispy> Jbeu: once you get accustomed to function programming (maybe you already are?) you'll find that often times it's easier to write a correct program in the function style. mutability is hard to reason about!
18:35:52 <hiptobecubic> FreeFull, it's hard to design something that has to work right now and stay working the entire time you are writing it :/
18:35:57 <FreeFull> hiptobecubic: So you want to rewrite it, in a more maintainable and modifiable manner?
18:35:57 <triliyn> syao: most of the major languages are rather old fashioned, but there are a bunch of fringe experimental languages doing lots of cool things with type theory
18:36:30 <Jbeu> lispy: gamedev is one of the things that's really hard to do in an idiomatic Haskell style, from what I can tell
18:36:30 <Jbeu> is that true?
18:36:46 <lispy> triliyn: Totally, and those fringe languages are so fun.
18:36:50 <hiptobecubic> FreeFull, not just that. It needs to be able to inspect the data as it's passing through, support more than one client connected to it, etc.
18:37:15 <Cale> syao: We've made a good deal of progress in terms of what our type systems let us express. Haskell is a rather evolutionary approach over ML, but there are languages being developed which let us express much more powerful things in our type system and verify them at compile time.
18:37:23 <hiptobecubic> Right now it "works" but not how i'd like. You have to be actively listening to record the data to disk for example.
18:37:27 <lispy> Jbeu: Do you mean high performance games? Those are hard to make in any language.
18:37:30 <FreeFull> Jbeu: You can write a game in Haskell in imperative style without tooo much trouble, or you could try doing something with FRP
18:38:08 <FreeFull> hiptobecubic: You can probably have it multithreaded
18:38:10 <syao> Cale, what are those labguages?
18:38:15 <hiptobecubic> FreeFull, and it's not able to inspect data on the way through so i can't identify ads by audio fingerprint or anything
18:38:16 <syao> *languages
18:38:25 <Cale> syao: Dependently typed languages such as Agda, Coq, and Idris.
18:38:47 <Jbeu> lispy: depends, all games (except turnbased) are "high performance" in the sense that you'd want rock solid 60fps. Not bleeding-edge games for sure.
18:39:10 <triliyn> There are also things like linear and fractional types but I don't know the names of any languages implementing those off the top of my head
18:39:27 <Cale> Jbeu: I think Haskell has a great deal of potential for game development, but it's one of those things where you might have to do some bushwhacking because there have only been so many games written in Haskell, and not even all of that work is open source.
18:39:37 <triliyn> (I'm pretty sure languages exist with linear types; not so sure about fractional)
18:39:42 <shachaf> Fractional types?
18:39:55 <c_wraith> Cale: what ever happened to the game project you were working on?
18:40:11 <lispy> Jbeu: If you want to learn more about this, you might look at the book "Haskell School of Expression". Also frag (a quake clone) is written in Haskell, but large parts of the source code is hard to understand because the code has been desugared from the arrow syntax.
18:40:13 <c_wraith> (I really hope that was Cale)
18:40:14 <triliyn> shachaf: I don't quite understand how they work, but apparently they correspond to pairs of logical variables
18:40:31 <lispy> Jbeu: and #haskell-game here on freenode has folks who are interested in haskell gamedev
18:40:35 <carter> o/ lispy
18:40:43 <lispy> carter: hello
18:40:48 <Cale> c_wraith: Well, we got our action RPG to the point where is was effectively a combat arena, and the combat was pretty fun, but we didn't really have enough time to put in all the RPG aspects of the game before the company ran out of funding.
18:41:06 <triliyn> shachaf: http://www.cs.indiana.edu/~sabry/papers/rational.pdf
18:41:10 <c_wraith> Cale: so the story of many games.  Sad. :(
18:41:42 <lispy> Jbeu: some people like FRP for haskell game stuff. I tried it once but I couldn't make it work very well.
18:41:50 <Jbeu> Was it written in Haskell?
18:41:56 <Cale> c_wraith: at some point Ryan and I should really return to that codebase and chop it up a bit, and perhaps open source the better part of the engine
18:41:58 <Cale> Jbeu: yes
18:42:03 <mindleyhilner> is uniqueness typing still relevant? anyone recommend a primer on it?
18:42:05 <syao> Cale, the wiki is poor for them, never heard of those languages, thank you.
18:42:10 <tlevine> Could someone give me an example of some code that uses HaskellNet.IMAP?
18:42:12 <FreeFull> lispy: I couldn't get frag to compile last time I tried
18:42:20 <Nafai> c_wraith: A game I worked on for a couple years eventually failed after I left the company when they ran out of funding.
18:42:49 <lispy> FreeFull: Hmm...I think I tried it as recently as a year ago and it worked for me. Maybe some key library changed?
18:42:57 <triliyn> mindleyhilner: I think the Clean language uses them, and maybe Mercury? I couldn't find a good primer for them though
18:43:19 <mindleyhilner> triliyn: yeah it does.
18:43:21 <lispy> FreeFull: I found that the way they calculate mouse position is busted on my mac so I couldn't actually play it, but I was very good at staring at the celing :)
18:43:25 <mindleyhilner> triliyn: but clean looks...deserted.
18:43:25 <djahandarie> Cale, what are you working on these days?
18:43:26 <triliyn> I think they are a special case of linear types, but I haven't been able to find a nice resource for that either
18:43:38 <triliyn> Unless you are comfortable with sequent calculus
18:43:46 * lispy -> dinner
18:43:52 * lispy waves
18:43:52 <Tekmo> Honestly, I don't know why people don't just use the `StateT` monad for games
18:43:52 <Tekmo> `StateT` + lenses + `pipes-concurrency` gets you like 90% of the way there
18:43:55 <triliyn> (And even then I've only seen linear LOGIC, not its application to type theory)
18:44:09 <levi> triliyn: They're somewhat different from linear types, IIRC, but in the same general family of substructural type systems.
18:44:09 <FreeFull> Two games which should compile fine without any messing around are monadius and cuboid
18:44:23 <triliyn> levi: hmmm, okay
18:44:44 <FreeFull> Tekmo: And a big record for the state?
18:45:07 <c_wraith> anyone have experience with System.Mem.Weak, and know what the concurrency properties of running a finalizer will be?
18:45:47 <Tekmo> FreeFull: Exactly
18:46:05 <Cale> djahandarie: The extent to which skedge.me has needed me decreased, so I've spent a bunch of time studying homotopy type theory. I'm thinking about possibly going to work for thoughtleadr, though I'm not sure how excited I am about that (might depend a little on how much they can pay me :)
18:46:28 <levi> triliyn: Strictly speaking, linear types ensure that all values are consumed exactly once. Affine types ensure that values are consumed *at most* once.
18:46:49 <levi> Henry Baker had a paper on "Linear Lisp" that was fairly readable, as far as I remember.
18:46:52 <Cale> Basically, considering my options for my next job
18:46:54 <mindleyhilner> levi: how do you know all this?
18:46:58 <Jbeu> Correct me if i'm wrong, but It's doesn't appear to be worth making a game in completely pure FP style. I don't see anything wrong with doing significant parts of it in imperative style.
18:47:04 <dolio> Uniqueness types are different from linear types.
18:47:10 <Cale> Jbeu: which game?
18:47:13 <triliyn> levi: and uniqueness types are just a less formal name for affine types?
18:47:19 <Tekmo> FreeFull: And you use lenses to delimit computaitons to subsets of that global record, using `zoom`
18:47:20 <djahandarie> Cale, interesting! I am somewhat surprised you haven't gone into academia.
18:47:21 <levi> No, they're still different.
18:47:25 <triliyn> oh
18:47:25 <Tekmo> Cale: Oh, you'll be in the bay area?
18:47:41 <Cale> Tekmo: I dunno! Maybe I'll move, we'll see.
18:47:42 <Jbeu> Cale: http://www.youtube.com/watch?v=i2EbFa24OOI
18:47:44 <dolio> Uniqueness types track whether a value has been duplicated yet, essentially.
18:47:52 <dolio> If they haven't you can mutate.
18:48:24 <Eduard_Munteanu> Any idea how type-level natural addition works? How do I go about proving 0 + 0 = 0? The sources in GHC.TypeLits seem to say (+) doesn't reduce at all.
18:48:31 <Tekmo> Cale: Come join us! :)
18:48:37 <Eduard_Munteanu> That is, it's just a type family declaration without any instances.
18:48:41 <Cale> Tekmo: Are you working with thoughtleadr?
18:48:52 <Twey> triliyn: ATS has linear types
18:49:05 <levi> mindleyhilner: From having read a lot of random papers and websites and such while trying to figure out what people were talking about in discussions about type theory.
18:49:09 <Tekmo> Cale: Oh, I meant San Francisco in general.  I'm at Twitter
18:49:12 <Cale> ah
18:49:46 <carter> Cale: thoughtleadr still exists?
18:49:49 <Eduard_Munteanu> Well, I want something more like n + 0 ~ 0 but still.
18:49:56 <carter> i passed on working for them ~ 2 years ago
18:49:56 <Cale> carter: It appears to!
18:50:04 <carter> still TINY
18:50:06 <levi> mindleyhilner: I never learned much of it very deeply, so I've forgotten most of it aside from bits and piece that remind me that I once read something about them. ;)
18:50:09 <Twey> levi: The Linear Lisp paper was untyped, so not really linear *types* per se
18:50:14 <Tekmo> Thoughtleader definitely still exists
18:50:21 <Twey> (they're a bit more interesting)
18:50:21 <Tekmo> They just contacted me about helping them switch to pipes
18:50:30 <carter> Tekmo: really?
18:50:32 <Tekmo> Yes
18:50:34 <syao> Cale: what are most advanced languages now (in your opinion)?
18:50:46 <Cale> syao: What does "advanced" mean?
18:51:00 <djahandarie> What does "language" mean?
18:51:10 <Cale> indeed!
18:51:19 <Iceland_jack> (what does "now" mean)
18:51:35 <carter> Cale: huh, it was like 3 people last  I looked
18:51:49 <levi> What does "mean" mean?
18:51:50 <syao> The thing I gave was words, you have to answer as you seem right :P
18:51:55 <Cale> syao: Haskell is probably the least broken language that you can write significant desktop applications in today, i.e. with reasonably good library coverage for a wide spectrum of tasks.
18:52:02 <Eduard_Munteanu> Actually, do type-level nats work at all in GHC 7.6.3? sing :: Sing (3 + 1) seems to fail because there's no instance for 3 + 1.
18:52:10 <carter> Eduard_Munteanu: won't wokr
18:52:24 <carter> 7.8 adds being able to do that
18:52:36 <carter> Eduard_Munteanu: you're better off using your own hand rolled type levle nats if you wanna compute on em
18:52:40 <int-e> Eduard_Munteanu: afaik in 7.6.3 there is no arithmetic, only equality of nats and successor.
18:52:45 <Eduard_Munteanu> Oh, hm. So practically, all 7.6 does is provide the literals for DataKinds?
18:52:50 <Jbeu> uhh
18:52:50 <Cale> syao: Coq and Agda have better type systems than Haskell does, but they're aimed more at people who are interested in proving theorems moreso than people who are interested in writing programs which do things.
18:52:53 <Eduard_Munteanu> I see, thanks.
18:52:53 <int-e> (for type level nats)
18:53:08 <carter> sadly
18:53:09 * djahandarie looks forward to edwardk's presentation on 7.8 toys because he hasn't been paying too much attention himself
18:53:29 <Cale> syao: Idris is an attempt at a practical programming language (fsvo practical) for writing desktop software that incorporates a dependent type system, but it's still very new.
18:53:45 <syao> Cale, for "advanced" I mean more capable in abstraction, generalization, auto proofing and etc. Not about just practical ways.
18:53:46 <levi> syao: There's also Idris, which also has more advanced types and is aiming to be more practical than Coq and Agda, but it is not very mature yet.
18:54:05 <Cale> levi: Hive mind ftw
18:54:24 <Twey> I get the impression that Agda is also meant to be a practical programming language, but so far nobody's got around to making it a good one :þ
18:54:31 <Cale> Twey: same for Coq
18:54:38 <jle`> is there a type system that can help me catch these darn  <<loop>>'s at compile time
18:54:38 <Eduard_Munteanu> syao: Agda has a Haskell-inspired syntax, but it goes beyond it embracing unicode and arbitrary mixfix operators, if you're interested in that.
18:54:44 <Cale> People have done practical things in Coq, but it takes dedication.
18:54:55 <Cale> For example, there's a fully certified C compiler written in Coq.
18:54:57 <Twey> Coq is meant to be a programming language in itself?  I know it has program extraction, but I've never heard of anyone running a Coq program
18:54:59 <FreeFull> I think Idris is so far more practical, compared to Coq and Agda
18:55:01 <dolio> Being a practical programming environment is int he Coq charter?
18:55:23 <Eduard_Munteanu> dolio: arguably there's more software written in Coq than Agda :)
18:55:34 <syao> Make some really practical software in prolog and it will take dedication too.
18:55:36 <dolio> That's irrelevant.
18:55:37 <levi> Coq is not really a single language, either.
18:55:50 <Cale> Well, whether or not Coq is *trying* to be practical, it *can* be used for practical programming.
18:56:04 <Twey> jle`: Yes
18:56:29 <Twey> jle`: Any kind of termination-checking, I guess
18:56:38 <jle`> Twey: ah i see.
18:56:41 <Eduard_Munteanu> Twey: see Compcert, a compiler written in Coq and OCaml
18:56:56 <Cale> It's just, maybe a bit of an uphill battle, unless having proofs of the properties of your software is at least as important to you as having the software itself.
18:56:58 <carter> Tekmo: Cale: i'd be curious to learn what thoughtleadr's up to
18:56:58 <carter> i keep on winding up doing work in adtech
18:56:58 <carter> i hate adtech
18:56:58 <carter> but they have money to give me
18:57:10 <Tekmo> carter: I can tell you.  They didn't ask me to agree to any NDA
18:57:19 <carter> Tekmo: sure
18:57:20 <Twey> Eduard_Munteanu: Is there actually Coq code involved in the compilation process?
18:57:20 <Cale> carter: I feel similarly, though I haven't actually done any work in this area yet.
18:57:52 <carter> since i'm not under NDA: the machine learning team as Spotify is a bunch of posturing bullshitters
18:57:56 <carter> *at
18:57:56 <carter> :)
18:58:05 <Tekmo> Here, it's short enough that I will paste it here:
18:58:06 <Tekmo> My company, ThoughtLeadr, has a pretty cool new product coming out this year for content analytics. Helping websites like Vice or Buzzfeed understand how users are interacting (sharing, commenting, voting, etc) with their content (articles, videos, images galleries, etc). Without going too deep, think Google Analytics with NLP laid on top.
18:58:11 <Tekmo> The system processes large amounts of browser events transforming them into higher order statistics. Our analytics codebase is all written in Haskell using a M/R-based strategy to-date (batch jobs). One of our major goals for 2014 is to move to a near realtime processing system and we've been evaluating our options.
18:58:16 <Eduard_Munteanu> Twey: AFAIK yes, most of the core stuff.
18:58:38 <carter> Tekmo: tell them I"m starting working on a M/R toolchain for haskell
18:58:43 <carter> I want Spark like
18:58:48 <djahandarie> Cale, I'd tell you to come work with me, but I don't think you're interested in moving to the East Coast and we don't have any open positions in my group ATM :p
18:58:48 <carter> but for haskell + any other native lang
18:59:04 <carter> Tekmo: was it todd or someone else who reached out to you
18:59:05 <Cale> djahandarie: I'm living in Ontario atm.
18:59:07 <Tekmo> Todd
18:59:12 * carter tell him i say hi :) 
18:59:15 <carter> tell him i say hi :)
18:59:19 <Tekmo> Alright, I will :)
18:59:25 <djahandarie> Cale, ah. Is Boston too far away?
18:59:33 <Twey> Eduard_Munteanu: I don't see any mention of Coq code being used for computation on the site, just some mentions of verification
18:59:36 <Cale> djahandarie: I was already considering moving to Boston.
18:59:41 <carter> Tekmo: hopenblas is nearly ready btw
18:59:44 <djahandarie> Cale... most interesting :-)
18:59:44 <carter> need to clean it up
18:59:44 <Eduard_Munteanu> Twey: http://compcert.inria.fr/diagram.png would tell otherwise, yeah
18:59:46 <Tekmo> carter: Awesome! :)
19:00:05 <carter> i just need to do some cleanup
19:00:13 <Eduard_Munteanu> Twey: still, it's much like what you'd do in Agda, bind to Haskell for IO stuff and such
19:00:14 <carter> and reuse the FFI wrapper work for *everything* eslse
19:00:24 <Cale> djahandarie: But I dunno! There seem to be a lot of people around Boston who would be interested in working with me though.
19:00:41 <Twey> Eduard_Munteanu: Ah, that diagram seems to suggest a large portion of the program is programmed in Coq
19:00:46 <Tekmo> Cale: Where do you currently live?
19:00:49 <djahandarie> Cale, plenty of awesome people here :D
19:00:51 <Cale> Brantford Ontario
19:01:41 <carter> Tekmo: i was in SF last week
19:01:42 <carter> or was it the week before?
19:01:46 <carter> were you tehre yet?
19:01:52 <djahandarie> Cale, I'd definitely recommend moving to the area. A critical mass of Haskellers is slowly building.
19:02:07 <Tekmo> carter: Yes, I was!
19:02:09 <Cale> It's a little city with practically nothing going for it apart from the fact that my parents and sister are here, and so my living costs are low, and we have a forest in our backyard, so that's nice.
19:02:10 <Eduard_Munteanu> Also, seL4 but I'm not sure.
19:02:18 <carter> Tekmo: pm'd yah fyi
19:02:44 <c_wraith> I'd move to California except my car is illegal there.  I don't want to deal with that.
19:03:16 <Cale> Also, it's in Canada, which automatically makes it better than anywhere in the US. ;)
19:04:17 <Cale> (Even if our PM is trying his very best to ruin as many things as possible.)
19:07:12 <syao> Cale, one more question: If we would compare lisp vs haskell(without type checking) what could be advantages of haskell? (please do not talk of turing complete)
19:08:03 <Tekmo> Idioms inspired by category/abstract algebra
19:08:23 <c_wraith> without type checking, the best parts of haskell don't even work
19:08:33 <BMeph> I would just like to interrupt here: Haskell w/o type checking is like lisp w/o macros. ;)
19:08:38 <Cale> syao: The type system is such a huge part of what makes Haskell work well that I'm not sure it makes sense to ignore it. For instance, one big thing would be type classes, which lets you do things like have a monad library rather than rewriting all those basic operations for everything which happens to be a monad.
19:09:16 <syao> that makes sense.
19:09:17 <Cale> syao: But apart from that, the lazy evaluation by default is really nice. The standard list library is very good, much better than most lisps I've tried working with, anyway.
19:09:35 <Cale> Pattern matching everywhere is really nice.
19:10:00 <Cale> You don't really fully appreciate pattern matching until you start trying to write functional programs in common lisp without it.
19:10:17 <syao> oh, yes, pattern matching (palmface)
19:10:47 <Cale> Oh, this seems trivial, but convenient syntax for function composition and lambdas
19:11:00 <Jbeu> Is it possible to have multiple functions defined with the same name, but different amount of arguments?
19:11:15 <Cale> It seems like only a few extra characters, and it is, but that actually makes a big difference in what's idiomatic.
19:11:16 <Iceland_jack> Jbeu: Yes but it's not worth it
19:11:22 <FreeFull> If you're fine with using a Scheme, the more schemeish parts of Racket have quite a few nice things
19:11:38 <Jbeu> Iceland_jack: how does that look like?
19:11:39 <Jbeu> Why not?
19:11:50 <Iceland_jack> Jbeu: Search for "variadic functions Haskell"
19:12:01 <Iceland_jack> > printf "hi" :: String
19:12:04 <lambdabot>  "hi"
19:12:06 <Iceland_jack> > printf "hi %s" "Sally" :: String
19:12:07 <Cale> Jbeu: Or look at Text.Printf as an example.
19:12:07 <lambdabot>  "hi Sally"
19:12:25 <Iceland_jack> > printf "hi %s number %d" "Sally" 10 :: String
19:12:26 <lambdabot>  "hi Sally number 10"
19:12:37 <Cale> > printf "hi %s number %d" "Sally" 10 "oops" :: String
19:12:38 <lambdabot>  "hi Sally number 10*Exception: Printf.printf: formatting string ended premat...
19:12:59 <Cale> ^^ type safety is a bit of a problem with such things
19:13:41 <Cale> (not always, but especially in the case of variadic printf -- it is possible to have a typesafe printf in Haskell, but not if your formatting specification is a String)
19:14:02 <BMeph> Does it even make sense to talk about type inference w/o type checking? Or is "type checking" something more thorough?
19:14:03 <geekosaur> and for variadic in general, it kinda plays havoc with partial application too
19:14:15 <Jbeu> Thanks!
19:14:42 <geekosaur> did you intend that call with one parameter to be the one parameter version, or partial application of the two paramater version?
19:14:51 <Cale> Jbeu: Yeah, you'll also note that we *had* to say what type the result was there, because it could always be another function, rather than the resulting String.
19:14:54 <triliyn> Wasn't there another printf package that was type safe and did something like 'printf "Hi " % d % " " % s 10 "Sally"'?
19:15:01 <geekosaur> BMeph: C does type checking, it does not do type inference
19:15:08 <Cale> triliyn: yes, I think there is such a thing
19:15:21 <Cale> (Was it written by mauke perhaps?)
19:15:25 <geekosaur> there's an applicative printf (printf-mauke?)
19:15:35 <Tekmo> I really liked Oleg's type-safe printf
19:15:44 <BMeph> geekosaur: I meant that in the other direction, though. :)
19:15:46 <triliyn> I think the one I saw had something to do with chrisdone
19:15:51 <triliyn> But maybe also mauke
19:15:52 <Cale> ah, there's one by Chris Done here http://hackage.haskell.org/package/formatting
19:16:02 <Cale> and shachaf :)
19:16:04 <geekosaur> I think type inference only makes sense if type checking is done...
19:16:45 <BMeph> geekosaur: So do I, which is what my question was meant to highlight - thanks for answering, though. :)
19:16:54 <Cale> Maybe type inference without type checking could make some kind of sense in the presence of type classes...
19:17:00 <geekosaur> anyway, you could probably say that type inference is leveled-up type checking
19:17:12 <Cale> But that would be really strange -- what do you even do when the types don't unify?
19:17:17 <syao> Cale, jbeu reminded me a problem that I had: multiple records with same name of key. I got "multiple declarations ...". Is there any work done to solve such an "simple" thing? The beautiful way.
19:17:34 <shachaf> help
19:17:38 <djahandarie> I am ashamed that printf ended up in base and not something like formatting.
19:17:45 <Jbeu> What I wanted to do was to have two little wrapper functions for glVertex*, "vertex x y = ...." and "vertex x y z = ...."
19:17:48 <shachaf> Oh, that thing.
19:18:02 <Cale> BMeph: You can use -fdefer-type-errors (I think that's what it's called) to defer the errors to runtime though :)
19:18:20 <Cale> syao: That's because the field names are not just names
19:18:26 <hiptobecubic> Jbeu, just name them vertex2 and vertex3?
19:18:33 <FreeFull> It's useful when you have a piece of code that isn't ready, but you don't run it yet anyway
19:18:38 <Cale> syao: They're also the names of functions for extracting those fields, and those functions have to be well-typed.
19:18:39 <Jbeu> hiptobecubic: i suppose, yeah
19:18:46 <geekosaur> syao: there are some extensions that help a little, but the general problem is stalled because there are pultiple approaches and not one of them is definitively better
19:18:51 <syao> Cale, yes I know that it constructs functiions for list
19:18:53 <Eduard_Munteanu> syao: lens
19:19:24 <Cale> syao: The usual thing is to stick some arbitrary prefixes or suffixes on the names, and then if you really need general operations, define type classes with the pretty names, and write instances which use the less pretty ones.
19:19:29 <BMeph> Cale: This is madness!
19:19:32 <syao> eduard, geekosaur, thanks
19:19:45 <Eduard_Munteanu> syao: it has some TH magic that generates typeclasses for fields, so the names are overloaded
19:19:57 <Cale> BMeph: What it does is generate type equality constraints which solve the equations and then implements them with error calls :)
19:20:22 <syao> Cale, the prefixes reminds me of C.. :)
19:20:45 <Eduard_Munteanu> syao: see makeFields... http://hackage.haskell.org/package/lens-4.0.4/docs/Control-Lens-TH.html
19:20:47 <BMeph> Cale: Ah, yes - "segmentation fault (core dumped)" - I Remember It Well! ;þ
19:20:51 <Cale> syao: It is valuable to know which type of record is being referred to based on the names of the fields.
19:21:14 <Cale> BMeph: heh, you don't get a segfault though
19:21:20 <Cale> BMeph: You get the actual type error message :)
19:21:35 <Cale> (as GHC would have printed it during compilation :)
19:22:00 <dolio> -finconvenient-type-erros.
19:22:06 <dolio> errors, even.
19:22:14 <FreeFull> -funsafecoerceall
19:22:33 <Cale> Yeah, this isn't the same as unsafeCoercing everything
19:22:40 <unlink> I'm running `cabal install text-icu --extra-lib-dirs=/usr/local/lib --extra-include-dirs=/usr/local/include', and it is complaining about `Missing C libraries: icuuc, icui18n, icudata'. These libraries however are plainly there in the paths that I told cabal.
19:22:40 <syao> Cale, I think it's better when you can get in scope, and map functions to other names.
19:22:49 <Cale> Things which would have worked with unsafeCoerce will still fail
19:22:51 <unlink> Adding -v3 yields no additional insight.
19:23:04 <syao> Eduard, thanks, *reading*
19:23:05 <Cale> syao: You can use the module system here too
19:23:20 <Cale> syao: Just put the data types in separate modules, and then import the modules qualified.
19:23:37 <dolio> Cale: I think we need -fdefer-scope-errors. Maybe I'll propose it in a month or so.
19:23:38 <Cale> syao: and everything will work as you expect
19:23:45 <syao> Cale, wait, can I nest modules in haskell?
19:23:52 <Cale> syao: no
19:23:57 <syao> :(
19:24:02 <syao> :D
19:24:07 <Cale> (though there's no particularly good reason that you can't)
19:24:29 <syao> Cale, what do you mean by that?
19:25:03 <Cale> Well, it's just not implemented and not part of the language spec, but adding that feature wouldn't cause any problems, it's just a bunch of additional work that nobody's cared enough to do.
19:25:14 <no-n> is there any reason to use [(k,v)] instead of Data.Map k v?
19:25:27 <no-n> Data.Map.Map *
19:25:34 <Cale> no-n: If you're going to immediately iterate over all the key/value pairs in order.
19:25:40 <unlink> In particular, I can easily compile and link a C program which uses those libraries.
19:25:49 <no-n> ok
19:26:05 <Cale> no-n: Or if all your lists are like 3 or 4 elements
19:26:15 <Cale> Then it might be faster to leave them as lists
19:26:18 <no-n> what about 30 elements?
19:26:27 <Cale> I'd use Data.Map
19:26:45 <no-n> ok
19:26:49 <Cale> Data.Map also has a more convenient API for such things anyway
19:26:50 <Cale> usually
19:27:05 <FreeFull> Isn't Data.Map inefficient?
19:27:08 <geekosaur> unlink: you might use --verbose=3 to see if it will tell you what it tried?
19:27:12 <FreeFull> Compared to the finger-tree equivalents
19:27:28 <geekosaur> Map may be inefficient for very small maps, not sure it's that inefficient in general
19:27:31 * hackagebot cab 0.2.8 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.8 (KazuYamamoto)
19:27:55 <unlink> geekosaur: Thanks, yeah, I tried that, but it doesn't tell you anything else.
19:28:40 <Cale> FreeFull: ...no?
19:28:50 <Cale> FreeFull: Data.Map is *really* finely tuned
19:29:00 <no-n> what's the difference between Data.Text and Data.ByteString?
19:29:12 <no-n> and when should you use which?
19:29:13 <geekosaur> then I don't know. maybe dcoutts is around to help? (cabal internals expertise is ... not widespread)
19:29:18 <Cale> FreeFull: It can be frustrating to try to construct something which does the same task more quickly, because its constant factors are very good.
19:29:35 <Cale> FreeFull: even when you know something more about your keys
19:29:35 <dalaing> no-n: Text is for text, ByteString is for raw data (think binary protocols)
19:29:37 <geekosaur> no-n: ByteString is for octet streams such as you get from sockets. Text is UTF8
19:29:47 <Cale> FreeFull: Well, IntMap does better for Int keys.
19:29:50 <FreeFull> Cale: Hmm, if you say so
19:29:53 <Cale> But between the two of them :)
19:29:56 <no-n> okay
19:30:10 <dalaing> no-n: Data.Text.Encoding gives you the means to get to/from Text via various encodings
19:30:15 <FreeFull> no-n: Text is for unicode text, ByteString is for binary data
19:30:20 <no-n> so a bot reading from IRC would use Tex?
19:30:20 <geekosaur> also yes, if youre working with binary records in files then you want ByteString because it's almost certainly not going to be UTF8 compatible
19:30:22 <no-n> t
19:30:22 <dalaing> no-n: Otherwise they both have pack / unpack methods as well
19:30:45 <geekosaur> no-n: not necessarily
19:30:47 <hiptobecubic> Cale, I thought hashmap was where the money was? Or is that backwards
19:30:55 <geekosaur> in particilar, IRC does not actually do locales
19:30:57 <Cale> FreeFull: There are hashmaps in unordered-containers which are competitive with Data.Map, but I've actually managed to hurt the performance of a program by switching to them before.
19:30:59 <syao> Cale: how could I implement automatic profiling of a software and automatic data migration to other data implementations on runtime?
19:31:01 <FreeFull> no-n: REading from IRC, you'd probably start with a ByteString and convert some of it into Text at some point
19:31:11 <Cale> (They're sometimes better, sometimes worse)
19:31:12 <geekosaur> most clients have hacky stuff to figure out whether a given message is UTF8 or ISO8859
19:31:15 <no-n> interesting
19:31:32 <geekosaur> ISO8859 will get errors if you try to use Text on it directly
19:31:59 <verement> Text is not actually UTF-8… I think it uses UTF-16 internally, but the encoding is opaque
19:32:08 <FreeFull> Cale: Good to know this, I would have suspected that the unordered-containers maps were almost always faster. Seems I'm wrong
19:32:15 <Cale> syao: uhhhh... I guess with some kind of module system, like use the GHC API (either directly or via libraries such as hint) to load code at runtime
19:32:21 <no-n> Text is more efficient than String?
19:32:21 <geekosaur> its interchange format is utf8, so what it uses internally is irrelevant
19:32:29 <verement> no-n: yes
19:32:31 <geekosaur> both text and bytestring are, yes
19:32:37 <no-n> okay
19:32:52 <geekosaur> String is a very wasteful format, and is only fast if it gets fully fused
19:32:55 <Jbeu> Is it possible to hotswap code in haskell? Say I have opengl/gameloop running and I change functions, datatypes, etc around while it's running?
19:33:16 <tlevine> [5~[B
19:33:17 <geekosaur> otherwise.. well, imagine a singly linked list of individual codepoints
19:33:23 <no-n> fused?
19:33:43 <geekosaur> (*indirect* codepoints, that is pointers to the storage)
19:33:44 <Cale> syao: Profiling is usually not free, and you typically can't act on that information without involving rebuilding your code, so you usually don't want to do it in production.
19:34:04 <Cale> But that said, there are tools for instrumenting your programs and getting live statistics about them
19:34:09 <no-n> is Data.Text.Lazy in "chunks" like Data.ByteString.Lazy?
19:34:11 <geekosaur> no-n: if ghc can work out what you're doing well enough, it can build and consume a String without allocating storage for it
19:34:25 <no-n> ok
19:34:39 <geekosaur> when, when it works, is a major win. but it can't be done in the general case
19:35:03 <syao> Cale, but jvm has hotspot on it, its kind of run time profiling and adapting of code that is run, it is the same, but in higher level.
19:35:18 <Cale> (trying to remember the name of a rather cool one which with one line of code adds a webserver to your program that displays statistics about it...)
19:35:24 <syao> *adaptation
19:35:25 <no-n> there's no mention of Text in LYAH :-( just ByteString
19:35:45 <startling> no-n: I think LYAH might predate TEXT
19:35:46 <geekosaur> Text was still experimental when LYAH was written
19:35:48 <startling> er
19:35:49 <startling> text
19:35:50 <startling> er
19:35:53 <no-n> ahh
19:36:50 <no-n> are the differences between Text.Lazy & Text.Strict and ByteString.Lazy & ByteString.Strict the same? (64k chunks for the Lazy ones, and all)?
19:40:16 <syao> Cale, its time for me, thank you for answering my questions. I hope we'll talk once more.
19:40:27 <Cale> syao: See you around!
19:40:36 <Cale> syao: Hopefully I can remember the name of that package
19:40:56 <syao> :)
19:41:00 <syao> See you next time haskellers! :)
19:41:01 <Cale> syao: anyway, some things to look at: http://hackage.haskell.org/package/dyre
19:41:05 <Cale> http://hackage.haskell.org/package/criterion
19:41:15 <syao> ok, thanks :)
19:41:57 <Cale> (can anyone remember the name of the package which you wrap your main in a function it provides, and it adds instrumentation for a webserver to get stats on the running code?)
19:42:51 <Cale> http://hackage.haskell.org/package/ekg
19:42:53 <Cale> syao: ^^
19:43:00 <Cale> there it is :)
19:43:17 <Cale> http://ocharles.org.uk/blog/posts/2012-12-11-24-day-of-hackage-ekg.html -- example here
19:43:38 <syao> thanks
19:44:25 <syao> yea, its hard to leave, the head is spinning around.
19:44:29 <Cale> syao: You add one line of code to your program and it gets you a webserver with lots of statistics about memory and CPU usage, and it also lets you further instrument your code with counters and such
19:44:48 <foozbazz> what do you folks use for audio routing in haskell?
19:44:59 <Jbeu> What library can you suggest to use for opening images?
19:44:59 <foozbazz> i've been using jack, but it's very unreliable and today it simply doesn't work.
19:45:07 <Jbeu> Is there a bitmap class or similar?
19:45:39 <geekosaur> Jbeu, I think JuicyPixels is the currently preferred one?
19:46:38 <Jbeu> geekosaur: Is there a one which comes with Haskell platform?
19:46:55 <geekosaur> afaik the only graphics support in the platform is opengl
19:47:05 <syao> Cale: quite good stuff. Ok, see you.
19:47:07 <geekosaur> and there are ongoing arguments about whether it should remain
19:47:10 <syao> Good luck
19:47:19 <no-n> so text from IRC would be received as ByteString?
19:47:21 <syao> and tanks again
19:47:31 <Jbeu> geekosaur: I hope it does remain
19:47:37 <geekosaur> no-n: since the only thing the IRC protocol specifies is octets, yes
19:47:44 <no-n> ok
19:47:58 <Jbeu> Thanks
19:48:17 <geekosaur> beyond that you get to prospectively attempt charset conversion of messages (but not other parts! in particular nicks are 0x20-0x7f)
19:48:31 <geekosaur> er 0x21-0x7e I think
19:48:35 <no-n> what are Texts advantages over ByteString?
19:49:00 <geekosaur> with some other things taken out of the middle, but no characters outside the old ASCII range at all
19:49:30 <geekosaur> Text understands Unicode, more or less, whereas ByteString is just octets (0-255).
19:50:14 <geekosaur> so if you want to work with concepts like "is this a letter?" then Text can do it, but ByteString can't really --- ByteString is essentially binary data
19:50:36 <no-n> *nod*
19:52:35 <geekosaur> native unpacked ByteString is [Word8]
19:53:09 <geekosaur> (there is a hacky module that pretends to give you something it calls "Char8" but that is a good way to get in trouble)
19:53:13 <no-n> so it's a linked list of char?
19:53:44 <geekosaur> no, it's a byte vector. pack and unpack translate between [Word8] and the packed byte vector
19:53:48 <startling> no-n, it's not a linked list.
19:53:53 <no-n> ahh
19:53:58 <geekosaur> the only linked list format is String (aka [Char])
19:54:17 <geekosaur> unless you count lazy ByteString chunking, which is a linked list of chunks
19:54:31 <geekosaur> but each chunk is a strict ByteString
19:54:33 <no-n> mmmmm
19:54:46 <no-n> what is packing and unpacking?
19:54:55 <startling> :t BS.pack
19:54:58 <lambdabot> [Word8] -> BSC.ByteString
19:55:04 <geekosaur> I wonder if you would be better off reading the documentation for ByteString...
19:55:05 <no-n> ahh, right
19:55:05 <startling> :t BS.unpack
19:55:06 <lambdabot> BSC.ByteString -> [Word8]
19:55:20 <no-n> sorry
19:56:57 <geekosaur> anyway pack and unpack are sometimes necessary when adapting to non-ByteString code, but should be avoided as they're obviously fairly expensive
20:07:08 <drbean>  You can't use a wildcard match for an argument which is a function but require matches for the arguments of that function?
20:09:04 <geekosaur> huh? if you pass a function, you've passed the function itself. you can't pattern match a function *invocation*, only its result
20:09:19 <geekosaur> because you can't see inside code
20:09:20 <enthropy> drbean: do you mean something like "f (Left x) = x; f (Right x) = x" being written with one equation?
20:09:49 <geekosaur> or did you mean constructors like that?
20:10:09 <geekosaur> (constructors aren't *quite* normal functions... specifically when it comes to pattern matching)
20:10:12 <enthropy> which we might imagine looking like   f (_ x) = x
20:10:41 <drbean> enthropy: yes, I want to do that.
20:14:19 <enthropy> you might have that 'f' written already (say you have    data D = C1 { f :: Int } | C2 { f :: Int })
20:15:16 <enthropy> then instead of the wildcard (which doesn't work) you can have    g (f -> 1) = ..
20:15:51 <enthropy> which needs -XViewPatterns
20:16:52 <pavonia> g (c { f = 1 }) should work too
20:17:08 <enthropy> don't think it does
20:17:11 <unlink> Extra-Libraries seems to be broken entirely for me.
20:17:31 <pavonia> enthropy: Why not?
20:17:42 <unlink> I cannot get a hello world project to `cabal configure' with Extra-Libraries: m or Extra-Libraries: c
20:18:01 <enthropy> pavonia: because it's a parse error
20:18:10 <unlink> (Using cabal-install 1.18.1.2, the latest on Hackage)
20:18:24 <enthropy> I mean it would be nice if that was acceptable
20:18:37 <pavonia> Because c isn't a constructor?
20:20:58 <randomclown> is there an updated version of strict-concurrency
20:21:01 <randomclown> that compiles?
20:26:56 <greg`> http-client or http-conduit?
20:28:04 <randomclown> IMHO conduit and pipes are over designed
20:28:19 <randomclown> when used with streams like tcp etc
20:28:49 <greg`> so just keep it client
20:30:22 <greg`> thx
20:37:32 <joelteon> http-client uses conduit internally
20:38:38 <roboguy_> if c is something bound to a D value, g (c { f = 1 }) should be fine
20:46:45 <pharaun> randomclown: how come you think they are over designed?
20:49:53 <joelteon> boy, if you think pipes is overdesigned, i hope you never look at the GHC RTS
20:52:11 <dwcook> In ghci, how can I check the type of something with all synonyms expanded?
20:54:00 <startling> dwcook: I wish I knew.
20:54:38 <pavonia> dwcook: ":t", copy the result type and feed it into ":k!"
20:55:16 <dwcook> pavonia, I just found that workaround on SO too. Thanks.
20:56:27 <startling> ":k!"?
20:56:55 <dwcook> :kind!
20:56:58 <fooozbaz> anybody know of a reliable OSX realtime audio routing library that works with haskell?
20:57:09 <pavonia> Ah right, that's the actual command
20:57:15 <fooozbaz> i was using jack-0.7 up until today, but it seems to have kicked the bucket really hard
21:05:18 <pharaun> joelteon: how easy would it be to get into/read the ghc rts?
21:05:22 <pharaun> seems like it could be informative
21:05:52 <joelteon> no idea
21:32:48 * hackagebot ace 0.0 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.0 (ChrisDone)
21:34:53 <Crowds> Hello people
21:34:57 <t4nk779> i'm still making my way through learn you a haskell (noob alert), but i was wondering if someone could help me with a question. in haskell how would you demonstrate equivalences between typeclasses? i.e. for all a, show an isomorphism between Foo a and Bar a
21:35:29 <Crowds> I'm trying to implement binarySearch in haskell, this is my code: http://lpaste.net/100309
21:36:08 <shachaf> t4nk779: Why type classes?
21:36:16 <Crowds> it successfully compiles but when I try to use my function, the interpreter throws an error
21:36:26 <shachaf> Crowds: Try compiling with -Wall
21:37:00 <shachaf> Crows: (Also note that binary search on linked lists is really inefficient, mostly (though sometimes not entirely) defeating the purpose of binary search.)
21:37:18 <shachaf> Crowds: Oh, never mind the -Wall comment.
21:37:48 <Crowds> Yeah I read that somewhere, but I still wanted to do it since I needed practice
21:38:06 <shachaf> The usual answer to "it throws an error" is "fix the error".
21:38:23 <shachaf> And if you want a more detailed answer, ask a more detailed question. :-)
21:38:30 <Crowds> anyways, the error is that "No instance for (Show (Int -> Maybe Int))"
21:38:50 <Crowds> oops sorry, I was kind of in the process =/
21:38:56 <shachaf> What are you actually typing?
21:39:41 <shachaf> That error sounds like ghci saying "I don't know how to print a function".
21:40:15 <t4nk779> shachaf: well i was trying to get a clearer understanding of some of haskell's typeclasses. as i was making my way through typeclassopedia i ran across two equivalent formulations of Applicative (i.e., the Monoidal formulation). how would i express this equivalence in haskell?
21:40:23 <startling> t4nk779, newtype Wraps a = Wraps a; instance Foo a => Bar (Wraps a);
21:40:39 <Crowds> Well I dont get it, because I'm not ordering it to print a function, I'm trying to make it print a Maybe Int
21:40:39 <monochrom> you need a 24/7 closed-circuit video of your complete unabridged dialogue with the computer
21:40:53 <startling> Crowds: I suspect you're wrong and ghci is right.
21:40:56 <shachaf> t4nk779: Well, the important thing in the case of type classes isn't just the methods; it's the laws.
21:41:05 <Tekmo> t4nk779: The simplest way I know of is to treat the type class as a record of functions and demonstrate an isomorphism between the corresponding records
21:41:18 <shachaf> So start by using the methods of type class A to implement the methods of type class B, and vice versa.
21:41:26 <shachaf> Then use the laws of A to prove the laws of B, and vice versa.
21:41:58 <t4nk779> shachaf: right. and the equivalence actually extends to the laws as well. but once i've done all that i want instances of one typeclass to automatically be the instances of the other typeclass. how would i do that?
21:42:27 <Crowds> I'm not saying the ghci is wrong, just that I don't know what I'm doing wrong
21:42:49 * hackagebot ace 0.1 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.1 (ChrisDone)
21:43:27 <monochrom> no wonder chrisdone has disappeared from us. he's working on english! :)
21:43:38 <Tekmo> t4nk779: Have you read the paper that introduced `Applicative`s?
21:44:00 <Tekmo> t4nk779: That papers talks about how the `Applicative` class is equivalent to a `Monoidal` class.  That's a good starting point for proving equivalence of type classes
21:44:02 <t4nk779> Tekmo: hmm could you elaborate? once i show that equivalence how would i use it? so that if Qu is an instance of Foo i can also use the functions defined in Bar
21:44:04 <shachaf> t4nk779: You can't really.
21:44:20 <startling> you could use a newtype, like I said.
21:44:26 <shachaf> Yes.
21:44:31 <Tekmo> t4nk779: Yeah, you use a newtype, like shachaf said
21:44:35 <startling> :<
21:44:37 <shachaf> startling said.
21:44:45 <Tekmo> t4nk779: Oops
21:44:49 <shachaf> I didn't say it because startling had already said it. :-)
21:44:49 <Tekmo> t4nk779: Like startling said
21:44:56 <startling> :>
21:44:57 <Tekmo> You said it in spirit! :)
21:45:47 <Tekmo> t4nk779: i.e. newtype Wrapped a = Wrapped a
21:45:59 <Tekmo> t4nk779: instance Foo a => Bar (Wrapped a) where ...
21:46:11 <Tekmo> t4nk779: instance Bar a => Foo (wrapped a) where ...
21:46:58 <Tekmo> t4nk779: The reason for wrapping in a newtype is to avoid OverlappingInstances
21:47:04 <t4nk834> startling: sorry got dc
21:47:09 <Tekmo> t4nk779: If you write something like: instance Foo a => Bar a where ...
21:47:16 <Tekmo> t4nk834: ... then you get lots of problems
21:47:20 <shachaf> t4nk779: You can find the logs you missed in the channel topic.
21:47:38 <t4nk834> shachaf: thanks
21:48:07 <t4nk834> Tekmo: could you elaborate on said problems or point me in the right direction?
21:48:42 <startling> t4nk834: if you write an instance like that there can be multiple instances for a type very easily
21:48:45 <startling> which is bad.
21:50:09 <t4nk834> startling: even when the instances may not be equivalent? or it's just that the compiler can't handle there being more than one (regardless of whether they're equivalent or not)?
21:50:17 <t4nk834> *may be equivalent
21:50:50 <startling> t4nk834: the latter
21:51:09 <startling> instances are global, for better or for worse.
21:51:15 <shachaf> All sorts of trickery can come from that.
21:51:24 <Tekmo> t4nk834: Basically Haskell ignores the constraint for the purpose of selecting which type class instance to use
21:51:44 <t4nk834> startling: gotcha
21:51:52 <Tekmo> t4nk834: So when you say `instance (Foo a) => Bar a where ...`, you're essentially saying that the instance should be selected for all types
21:52:17 <startling> then you get lots of "no instance Foo for x" errors
21:52:18 <Tekmo> t4nk834: Haskell does not use the constraint to detect that the type does not match
21:52:43 <t4nk834> Tekmo: ahh
21:53:02 <Tekmo> t4nk834: So that instance conflicts with all other instances, and then you have to do crazy things like use `OverlappingInstances` and even that does not work well
21:53:28 <t4nk834> ok. now it makes sense. somewhat. i think. i need to stare at this a while longer
21:56:20 <t4nk834> Tekmo: so wait, how do we not get that problem with the newtype? wouldn't the instance still be selected for all Wrapped a? or is the idea to only use Wrapped a where Foo exists (and to enforce this via manual discipline)
21:56:58 <startling> t4nk834: yes, it's selected for all Wrapped a (but that's not a problem)
21:57:02 <Tekmo> t4nk834: It is selected for all `Wrapped a`, but that doesn't conflict with other instances, since most instances won't use `Wrapped`
21:57:30 <startling> t4nk834: it's rare for people to write instances for a type unless they wrote either the class or the type.
21:57:38 <Tekmo> t4nk834: Think of `Wrapped` as behaving like an instance "namespace" that other instances are likely to not trample on
21:58:08 <u-ou> @src foldl
21:58:08 <lambdabot> foldl f z []     = z
21:58:08 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:58:45 <t4nk834> gotcha
22:00:10 <t4nk834> so now if i have Baz which is an instance of Foo, in order for me to use the methods of Bar, i would envoke it on Wrapped Baz?
22:00:39 <startling> t4nk834: oh, do you know how newtype works?
22:00:41 <t4nk834> *invoke
22:00:49 <startling> t4nk834, you need to use the constructor.
22:01:59 <t4nk834> startling: i think i understand how it works. on the constructor of Baz, correct?
22:02:23 <t4nk834> or rather use the constructor of the newtype on the constructor for Baz
22:03:11 <startling> t4nk834: on a value of type Baz, yeah.
22:03:19 <t4nk834> right, ok
22:03:44 <t4nk834> thanks i'll go back and tinker in a repl some more
22:03:46 <u-ou> @src foldr
22:03:47 <lambdabot> foldr f z []     = z
22:03:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:03:51 <Tekmo> t4nk834: That's right
22:04:47 <t4nk834> btw are there any resources that you guys can point me to which would give me a better understanding of haskell's type system. and the differences in the abilities conferred when working in the value world vs the type world?
22:04:56 <t4nk834> i guess i should check out the report?
22:05:19 <shachaf> I think an answer to "what's wrong with instance Foo a => Bar a" hasn't been given here yet.
22:05:33 <Tekmo> t4nk834: Generally, Haskell tools in the value world don't transfer well to the type world
22:05:39 <shachaf> That instance isn't overlapping, in itself. It's only overlapping when you combine it with other instances.
22:05:39 <Tekmo> t4nk834: Dependently typed languages try to change that
22:05:43 <startling> it's fine as long as no one else wants to write a Bar instance.
22:05:55 <shachaf> It's not fine in GHC, it requires UndecidableInstances.
22:06:06 <startling> it still works fine.
22:06:18 <Tekmo> t4nk834: In a dependently typed language you can have types as values and functions in type signatures
22:06:42 <Tekmo> t4nk834: You use the same language to program at the type level and the value level
22:08:50 <SANTI> hy
22:09:06 <t4nk834> Tekmo: so dependently typed languages also use the same language to program at the n-th order type (eg kinds, and whatever is above kinds etc)?
22:09:28 <Tekmo> t4nk834: Exactly!
22:10:57 <startling> there's usually "universes" to prevent russell's-ish paradoxes
22:11:01 <t4nk834> Tekmo: oh sweet. are there any which can inter-operate with haskell?
22:11:10 <Tekmo> t4nk834: Not that I know of
22:11:22 <Tekmo> t4nk834: The most Haskell-like of these languages is Idris, followed closely by Agda
22:12:30 <t4nk834> Tekmo: this is sort of dual to the advantage that a language like lisp has. i.e., the homoiconicity. here it's expressed in a slightly different manner
22:12:56 <Tekmo> Well, homoiconicity corresponds to a different concept in functional programming
22:13:12 <Tekmo> t4nk834: The closest analog to homoiconicity are the notion of "free objects"
22:13:28 <Tekmo> t4nk834: Example free objects are lists ("free monoids") and free monads
22:13:39 <Tekmo> t4nk834: There are also free categories, free applicatives, and free arrows
22:13:49 <Tekmo> t4nk834: Think of these free objects as syntactic representations of computations
22:13:58 <shachaf> free hugs
22:14:07 <Tekmo> t4nk834: For example, a free monoid (i.e. list) is just a syntactic representation of a monoid that doesn't actually combine anything
22:14:18 <Tekmo> t4nk834: So you can think of lisp as the special case where everything is a free monoid (i.e. list)
22:14:41 <Tekmo> t4nk834: However, what you will learn is that you can have syntactic representations of computations other than lists
22:14:50 <Tekmo> t4nk834: The free monad is the next most common example
22:15:00 <Tekmo> t4nk834: A free monad is basically a syntactic representation of a monadic computation
22:15:05 <t4nk834> Tekmo: so a free monoid needs to be 'eval'd?
22:15:13 <Tekmo> t4nk834: Not necessarily, but it can be
22:15:29 <t4nk834> Tekmo: well how else would it combine anything?
22:15:36 <Tekmo> t4nk834: The basic idea behind every "free X" is that you can factor every "X" through a "free X" + an interpreter
22:15:54 <Tekmo> t4nk834: You an always just leave it as the free representation (i.e. you just wanted a list, for some reason)
22:16:52 <Tekmo> t4nk834: You might find this article I wrote useful for understanding the special case of free monads: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
22:17:16 <shachaf> So how does that analogy apply to "free topological space" (i.e. discrete)?
22:17:17 <Tekmo> t4nk834: The free monad is a great example of a syntactic representation that is more awkward in Lisp than Haskell
22:17:22 <Tekmo> shachaf: I have no clue
22:17:51 <t4nk834> Tekmo: ok that makes sense. thanks for the link. are there any resources to this notion of 'free'?
22:18:19 <Tekmo> t4nk834: So most of them are not programming resources, but rather mathematical resources
22:18:50 <Tekmo> t4nk834: The reason why is that Haskell programming doesn't frequently use free objects other than the free monoid and free monad
22:19:09 <Tekmo> t4nk834: So basically if you want to stick to Haskell examples you will pretty much have to settle for lists + free monads
22:19:18 <shachaf> Lots of things are free.
22:19:26 <shachaf> Maybe gives you a free pointed set.
22:19:47 <shachaf> (Not that anyone cares about pointed sets.)
22:20:08 <shachaf> NonEmptyList gives you a free semigroup.
22:20:16 <t4nk834> Tekmo: actually, i'm more interested in the underlying concept. so math resources though denser would be preferable. or well i should say, things which tackle these concepts on a formal basis would be preferable
22:20:36 <Tekmo> A good introduction is "Category Theory" by Steve Awodey
22:21:06 <Tekmo> It's a textbook and the first chapter dives straight into free monoids and builds a good intuition for free objects in general
22:21:39 <shachaf> There are lots of different definitions of "free", though usually one ends up being a special case of another.
22:21:46 <Tekmo> There is also a good Stack Overflow answer by Edward that introduces another intuition
22:21:51 <Tekmo> Let me pull it up
22:22:27 <Tekmo> t4nk834: Try this Stack Overflow question and read through several of the answers: http://stackoverflow.com/questions/13352205/what-are-free-monads
22:22:30 <shachaf> If all you care about is free objects as in universal algebra, you can use something simpler and more direct than the categorical definition.
22:22:32 <ski> t4nk834 : "free" is relative, "from" something, "to" something else
22:23:27 <Tekmo> t4nk834: That's about free monads specifically, but Edward's answer introduces the definition of free monads in terms of adjunctions
22:23:32 <ski> t4nk834 : e.g. "free vector space over a set `S'" is the vector space with the elements of `S' as basis elements (so, "from" sets, "to" vector spaces, here)
22:24:10 <ski> t4nk834 : do you know what a partial order is ? a preorder ? a group ? an abelian group ? a monoid ?
22:24:10 <shachaf> As opposed to all those other vector spaces.
22:24:18 <ski> shachaf : indeed ;)
22:24:56 <ski> (e.g. the vector space of all translations over the euclidean plane, as specified by plane geometry axioms)
22:24:57 <t4nk834> ski: i know partial order and a group. preorder sounds familiar though i might be confusing it with something else (traversal)
22:25:38 <ski> t4nk834 : preorder is like partial order, so reflexive and transitive. but we don't insist on anti-symmetry, so given `a =< b' and `b =< a', we need not have `a = b'
22:25:46 <shachaf> Preorder is like partial order except you can have distinct x and y with x ≤ y and y ≤ x.
22:25:56 <shachaf> Not related to the traversal.
22:26:25 <ski> t4nk834 : e.g. the divisibility ordering on integers is a preorder, but not a partial order, since e.g. `3' divides `-3' and vice versa, but `3' is not equal to `-3' (we say that they are "associated")
22:26:31 <dwcook> How do I map over what a Pipes.Producer produces?
22:27:24 <t4nk834> ski: right, so i guess what i'm interested in are free Foo over X. where X is a programming language or rather value expressions in said language (excuse the notational abuse), and Foo represents set of constraints on members of X
22:27:54 <ski> t4nk834 : now, the free partial order over a preorder is when we consider all associated elements to be equal .. si in case of divisibility, we consider `-3' and `3' to be the same element in this free partial order (you can think of that element as being `|3|' which is equal to `|-3|' .. alternatively, you can use squaring)
22:28:10 <Tekmo> dwcook: compose `Pipes.Prelude.map` downstream is one way
22:28:18 <Tekmo> dwcook: i.e. `yourProducer >-> Pipes.Prelude.map f
22:28:31 <Tekmo> dwcook: You can also do it using a `for` loop
22:28:37 <shachaf> Or you can think of equivalence classes, presumably.
22:28:38 <Tekmo> dwcook: for yourProducer (yield . f)
22:28:45 <ski> t4nk834 : another way to say the same thing is that the elements of this free partial order are the equivalence classes (associatedness classes) corresponding to this equivalence relation : associatedness
22:29:00 <dwcook> Tekmo, thanks.
22:29:06 <Tekmo> dwcook: You're welcome!
22:30:07 <ski> t4nk834 : for groups, the free group over a set has elements which are lists of "positive" or "negative" elements elements from the set, with no positive and negative instance of the same element directly adjacent to each other
22:30:07 <t4nk834> ski: right. so it seems free from X to Y basically takes elements of X and applies minimal constraints (in some sense) to achieve properties of Y?
22:31:01 <ski> t4nk834 : and the free *abelian* (iow commutative) group over a set has elements which are functions which map from the set to integers, mapping at most finitely many elements to a non-zero integer (we say the function has "finite support")
22:31:08 <t4nk834> ski: actually is it true then that free X to Y. Y has to have <= members than X?
22:31:17 <shachaf> t4nk834: For algebraic structure like groups, where you have operations and laws, you can make the free object on a set as follows:
22:31:44 <ski> t4nk834 : and the free *abelian* group over any group is what you get when you *insist* on commutativity -- doing this may collapse together some elements, since you can then prove they are equal
22:31:44 <shachaf> Start with all elements of the set. Then make every possible expression you can out of these elements. Then declare two things to be equal exactly when the laws force them to be equal.
22:31:56 <shachaf> So it's equivalence classes of "ASTs".
22:32:49 <ski> t4nk834 : to be able to have a "free Foo over any (given) X", we need to have a converse way of "forgetting" information from a "Foo", yielding an "X" -- a "forgetful functor", they're usually called
22:33:01 <shachaf> I should just let ski talk.
22:33:55 <ski> t4nk834 : so, we can "forget" that a partial order satisfies anti-symmetry, so then we just "remember" that it is a preorder (obviously it still *is* a partial order, but the point is that that's no longer part of the structure we're considering)
22:34:42 <ski> t4nk834 : similarly, we can *forget* that a vector space is a vector space, retaining only the set of vectors. similarly for forgetting everything about a group (or abelian group), except the set of elements
22:34:49 <t4nk834> ski: so by forgetting you mean ignoring constraints introduced by Foo?
22:35:08 <ski> t4nk834 : and then, we can forget that an abelian group is abelian, only "remembering" that it is a group
22:35:36 <shachaf> Sometimes it's not just constraints.
22:35:59 <shachaf> If there's more than one way to make an X into a Y, then you "forget" which way you did it.
22:36:00 <ski> t4nk834 : note that in some of these cases, we're forgetting *operations* (vector space operations, group operation), while in others we're forgetting *properties/laws* (the partial order -> preorder case, and the abelian group -> group case)
22:36:18 <t4nk834> ah righ
22:37:22 <ski> t4nk834 : "so it seems free from X to Y basically takes elements of X and applies minimal constraints (in some sense) to achieve properties of Y?" -- more or less, yes -- but in the case of (reintroducing) forgotten *operations*, this means *generating* *new* elements by the operations (subject to existing laws which may state some equalities to old elements)
22:37:38 <t4nk834> hmm so what's so special about free? just the fact that we're explicitly embedding it (or whatever the right term would be) in something else and thereby making the relationship between Foo and X clearer?
22:37:42 <ski> t4nk834 : so, "actually is it true then that free X to Y. Y has to have <= members than X?", no
22:37:55 * hackagebot functor-combo 0.3.4 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3.4 (ConalElliott)
22:38:20 <ski> t4nk834 : "so by forgetting you mean ignoring constraints introduced by Foo?" more or less, yes
22:39:17 <ski> t4nk834 : if you think of a group as a tuple of a set, and operations (combination, inverse, neutral element) on it, then you normally project away (some or all of) the operations in the forgetful functor
22:39:41 <shachaf> I think of a group as a tuple of a set, operations, and laws. :-)
22:40:21 <ski> t4nk834 : and then, you *could* say that the tuple also includes as further components *proofs* that the group laws hold in the purported group, so the forgetful functor can also forget such laws (like abelian group -> group or partial order -> preorder)
22:40:35 <Tekmo> t4nk834: Think of "free X" as trying to preserve as much information as necessary in order to be able to recreate X later on
22:41:04 <t4nk834> ski: where did you learn about all this stuff? not the specific examples you're giving, but the stuff about 'free'
22:41:15 <ski> t4nk834 : sometimes (but not as common in math), we have multiple *carriers* (multiple sets), and then a free functor can forget some carriers as well (as long as all operations depending on it, and also all laws depending on them, are dropped)
22:41:40 <shachaf> What's an example with multiple carriers?
22:42:10 <t4nk834> Tekmo: so free embeddings of dependent typed languages, has that been done?
22:42:15 <ski> shachaf : a (multi-)graph, having both a carrier of vertices, and a carrier of edges
22:42:40 <shachaf> I guess so.
22:42:47 <ski> t4nk834 : "hmm so what's so special about free?" -- well, a free functor is "left adjoint" to a forgetful functor
22:43:01 <t4nk834> ski: like dropping a subset of certicies from a graph and associated edges, right
22:43:21 <Tekmo> t4nk834: So in theory you could embed a dependently typed language in Haskell in the "obvious way" (i.e. a string representation of the source code), but that alone does not make it free
22:43:45 <ski> t4nk834 : "forgetful" being perhaps somewhat vaguely defined, though. but the interesting part is that useful constructions like the various free examples are actually *are* left adjoints to such trivial, and supposedly useless concepts as the forgetful functors
22:43:59 <shachaf> Hmm, so a free topological space makes a bit more sense to me now (other than the obvious direct categorical definition).
22:44:02 <ski> t4nk834 : this connection between trivial and interesting is cool
22:44:22 <mwc> https://www.imperialviolet.org/2014/02/22/applebug.html Has anybody remarked on how this is an argument that syntax-significant whitespace is a sound sop to ingrained habits of code reading?
22:44:32 <ski> t4nk834 : "where did you learn about all this stuff? not the specific examples you're giving, but the stuff about 'free'" -- hm, here and there :)
22:44:37 <t4nk834> ski: i'm probably being overly simplistic, but i don't see why it's surprising that you can build more interesting things from simpler ones
22:44:39 <Tekmo> t4nk834: I guess the simplest way I can explain it is that the "free X" representation has to preserve exactly as much information as necessary to recreate X
22:44:40 <shachaf> But I still don't reconcile it with the equivalence-classes-of-expressions thing that you get with algebraic structures. Is there a reasonable way to do that?
22:44:45 <lispy> mwc: sop?
22:45:08 <ski> t4nk834 : some CT books, possibly some Baez this week's finds in mathematical physics, to some extent some papers, and maybe also some blogs
22:45:14 <mwc> lispy: concession
22:45:17 <Tekmo> t4nk834: The more precise intuition is the notion of free objects in terms of "adjunctions" (which are sort of like inverses)
22:45:31 <ski> t4nk834 : i didn't follow "like dropping a subset of certicies from a graph and associated edges, right"
22:45:32 <Tekmo> t4nk834: A free object is basically the "inverse" of some forgetful transformation (i.e. "forgetful functor")
22:45:49 <t4nk834> ski: vertices. i can't type today
22:45:56 <Tekmo> t4nk834: For example, the "free monoid" is sort of like the "inverse" (more precisely: adjunction) of forgetting all the monoid operations
22:46:09 <Tekmo> t4nk834: In other words, a list preserves precisely enough information to counteract the loss of monoid operations
22:46:13 <shachaf> "forgetful" is something that non-categorists don't usually bother talking about.
22:46:32 <t4nk834> ski: that was in relation to your example regd mulitple carriers
22:46:34 <ski> t4nk834 : btw, here's another group-related example : fix some group, and consider the category of all subgroups of it, and also the category of all subsets of it -- there's a forgetful function from the former to the latter that just forgets that a subset was given as a subgroup
22:46:35 <shachaf> Since usually they call both the group and the underlying set G.
22:46:56 <lispy> mwc: I haven't heard anyone make that argument, but it makes sense. <shrug> But then, I try to always use {} on my if branches when I write C.
22:47:07 <ski> t4nk834 : in the other direction, given any subset of the group, the subgroup *generated* by this subset is the free subgroup on that subset
22:47:56 <Tekmo> t4nk834: Going back to the topic of homoiconicity, the "free X" preserves enough information that you don't need to remember which interpreter you were using
22:48:08 <ski> t4nk834 : "you can build more interesting things from simpler ones" -- "build" is not quite correct, at least not always. adjunctions tend to be characterizations, not definitions. you have to build the concepts separately
22:48:15 <lispy> mwc: I don't know why C make them optional there :/
22:48:46 <mwc> lispy: me too, and the duplication between the semantically signicant { and } and the "visually significant" indentation is always jarring now that I'm used to whitespace syntax
22:48:47 <ski> shachaf : discrete topological spaces ?
22:49:02 <t4nk834> ski: you can characterize more interesting things from simpler characterizations. is that more accurate?
22:49:59 <ski> t4nk834 : better yes. or perhaps something like : "there interesting characterizing relations between definitely useful concepts and seemingly trivial and not-very-useful concepts"
22:51:48 <t4nk834> ski: i don't agree with or see the reason for the 'not-very-useful' description
22:51:50 <ski> t4nk834 : another example, there is an underlying/forgetful functor from category of graphs to category of sets. the left adjoint to this, the free graph over a set, is simply the graph with that set as nodes, and no edges (or, if you insist on identity edges in every graph, then only identity edges, say)
22:52:29 <ski> t4nk834 : now, *this* functor itself has a left adjoint, the "connectec components" functor, mapping any graph to the set of its connected components
22:53:59 <ski> t4nk834 : re "not-very-useful", some mathematicians seem to think e.g. trivial group or trivial ring isn't really interesting. or they might altogether disallow the empty graph or the plane projective geometry with exactly one point and one line
22:54:21 <shachaf> That sounds very similar to the preorder-to-poset functor.
22:54:44 <Tekmo> Maybe you and ski should take this to haskell-overflow
22:54:59 <t4nk834> ski: seems reminiscent of people underestimating the significance of zero. what's the point of having a symbol simply to denote nothing!
22:55:45 <Tekmo> I'm going to steal that
22:55:48 <ski> t4nk834 : yes, it's the same basic problem, imo
22:55:59 <t4nk834> i'm actually done for the night. it's been a refreshing discussion, thanks a lot guys
22:56:07 <Tekmo> t4nk834: You're welcome!
22:56:22 <ski> t4nk834 : also, ancient greeks didn't consider `1' to be a proper (counting) number (either)
22:57:48 <jle`> can we make let's look less awkward in do blocks
22:57:50 <ski> t4nk834 : or empty product, sum, conjunction, disjunction; or considering the empty space to be connected
22:57:57 <jle`> is there any way to indent them so that tehy don't look so weird
22:58:52 <Tekmo> jle`: They never look weird to me
22:58:53 <startling> jle`, you could do it before the do block
22:59:23 <c_wraith> startling: not if you need values bound in the do block
22:59:39 <startling> c_wraith, that's true.
22:59:51 <c_wraith> Well, I guess you could pass them..  but function arguments?  eww.
22:59:52 <c_wraith> :)
22:59:53 <startling> you could nest another do block after a new "let ... in ..." though
23:00:07 <jle`> Tekmo: how do you indent them?
23:00:15 <jle`> let on its own line
23:00:22 <jle`> or let and the first binding on the same line?
23:00:39 <Tekmo> I don't indent them
23:01:25 <c_wraith> I don't think anyone puts let on its own line.  (there will certainly be counterexamples, but it's not a common style)
23:01:26 <startling> jle`: the other thing you could do is have each binding have its own "let"
23:01:44 <ski> shachaf : .. i suppose for free topological space over a set, it might be that "nearness" is considered a constraint, so we add points, but no nearness, getting a discrete space
23:02:58 * hackagebot crypto-pubkey-types 0.4.2 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.2 (VincentHanquez)
23:05:40 <jle`> hm
23:05:47 <jle`> so every binding have its own let?
23:16:36 <no-n> can't use printf with Text or ByteString :/
23:19:02 <joelteon> don't use printf
23:20:08 <thorkilnaur_> n
23:20:47 <pharaun> y
23:22:54 <thorkilnaur_> wrong keyboard, sorry
23:25:41 <dsrx> what do you recommend for text formatting then?
23:28:01 * hackagebot asn1dump 0.1.0 - Dump ASN1 structure  http://hackage.haskell.org/package/asn1dump-0.1.0 (VincentHanquez)
23:28:03 * hackagebot crypto-pubkey-types 0.4.2.1 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.2.1 (VincentHanquez)
23:28:06 <no-n> joelteon: why not?
23:33:01 * hackagebot x509 1.4.9 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.9 (VincentHanquez)
23:37:26 <jle`> this ArrowLoop proc block created a <<loop>> by just me putting a block of code inside a rec even though there were no recursive bindings
23:37:30 <jle`> this isn't even fair :|
23:37:30 <no-n> i like printf
23:37:44 <no-n> the only thing i like better is python's str.format :}
23:38:26 <jle`> it works fine without rec, no recursive bindings...then when in a rec, it <<loop>>'s.
23:38:45 <jle`> well i guess now the implicit ordering is gone
23:50:18 <adek> What would be the library/approach to look into if I want to create a bunch of computations which will be executed with some delay, say 100ms - 5secs. It doesn't have to be super precise. Should I just create thread using forkIO and then threadDelay for each of the jobs that I would like to start in the future?
23:51:51 <shachaf> That sounds like a reasonable thing to do.
23:52:09 <JeroldHaas> adek: in OO there are many Timer objects that call a delegate or anonumous function when Timer.Complete() or similar is triggered (event handler)
23:52:47 <adek> JeroldHaas: What do you mean by OO? Objective Oriented?
23:53:01 <JeroldHaas> object oriented yes
23:53:16 <JeroldHaas> foo:Timer = new Timer()
23:53:40 <adek> shachaf: How bad will it be if I get 10k jobs to start in future? Will Haskell runtime work well?
23:53:42 <JeroldHaas> Timer.AddEventListener(Timer.COMPLETE, myTimerEvent)
23:54:10 <shachaf> adek: You should try it.
23:54:12 <adek> JeroldHaas: Yeah. I never wondered before how it is implemented under the hood.
23:54:20 <JeroldHaas> adek: if you're using Haskell make the map bound to a lazy list
23:54:26 <shachaf> In theory a large number of threads should be fine.
23:55:20 <adek> Sounds good to me. I don't expect huge load, but I am just interested if there is any way to project performance before.
23:55:28 <shachaf> Are these very fast actions or ongoing ones?
23:56:10 <adek> These are mostly blocked computations as they do IO over network - sending a few HTTP requests
23:56:48 <adek> CPU should be very low
