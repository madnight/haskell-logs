00:21:35 <Iloiny_> after i zip two lists to create a list of pairs, how would i run a filter on it, ie how do i access the second element of the pair (which the filter condition depends on)  ?
00:23:46 <BMeph> Iloiny_: Short answer, the same way you'd _filter_ any other list of values. :)
00:24:22 <Iloiny_> basically the question is how to access the element of pair
00:24:41 <Feuerbach> :t snd
00:24:42 <lambdabot> (a, b) -> b
00:26:14 <pavonia> > filter (odd . fst) $ zip [1,2,3,4,5] "abcde"
00:26:15 <lambdabot>  [(1,'a'),(3,'c'),(5,'e')]
00:28:18 <Iloiny_> ok thanks
00:54:18 <haskell-newbie> is there a good example of how to form a set from mysql quickquery result?
00:55:42 <haskell-newbie> ?
00:59:57 * hackagebot lifted-base 0.2.2.0 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.2.0 (BasVanDijk)
01:22:21 <pyon> What word do you use to verbally refer to (<*>)? (Similar to "fmap" for (<$>) or "bind" for (>>=).)
01:23:47 <apples> "ap"
01:24:13 <pyon> Ah, thanks!
01:24:47 <pyon> And what about (<|>)?
01:26:42 <apples> dunno
01:27:13 <pyon> apples: Aw. :-( Never mind, thanks!
01:28:03 <grohne> is there a tool that can extract a digraph from haskell code where the nodes are top-level symbols and and edge corresponds to "src uses target"?
01:33:15 <Feuerbach> grohne: not sure about a ready-to-use tool, but you could implement that with haskell-names with not too much effort, I think
01:34:37 <grohne> hmm. SourceGraph!
01:34:55 <Elision_> I have a constructor Foo a that I'm writing a show instance for
01:35:10 <Elision_> but I can have Foo parametrized with Foo a, nested arbitrarily
01:35:16 <bartavelle> pyon, *I* use "or", because it's an alternative, but it's not a really good name (might be mistaken for ||)
01:35:36 <Elision_> is there any way to make the show instance behave differently when it's been given a Foo a instead of a Foo?
01:35:46 <Elision_> er
01:36:10 <Elision_> when it's been given a `Foo a` as its argument?
01:40:05 <Elision_> I tried declaring one for Show (Foo (Foo a)) with -XFlexibleTypeInstances but that threw a runtime error due to overlapping instances
01:42:50 <bartavelle> Elision_, you might check the type of the argument at runtime, but I don't think how much of a good idea this is
01:42:59 <bartavelle> especially given that "Show" should produce valid haskell code
01:43:12 <apples> Elision_, check out OverlappingInstances
01:43:27 <bartavelle> and your question seems to imply you are pretty-printing
01:43:53 <apples> it will try to match the most specific instance
01:44:22 <Elision_> bartavelle: well, I'm probably going to move it out of "show" in a bit, but I have it like that so it's readable in ghci
01:44:33 <Elision_> apples: oh, neat
01:50:20 <Elision_> apples: yeah that works great, I can get (3)(x^4)y^1 now
01:50:43 <apples> yep, definitely sounds like Show abuse! :P
01:51:01 <Elision_> :p
01:52:54 <Elision_> making (Num a) => Num (Polynomial a) is *so* nice
01:58:16 <jtcwang> quickcheck doesn't seem to show the input before executing something
01:58:32 <jtcwang> i'm getting memory overflow but i don't know what the error is
01:59:10 <jtcwang> is there a way to see the input before it is run by quickcheck?
01:59:50 <Feuerbach> what do you mean by 'input'?
02:00:03 * hackagebot cereal-plus 0.3.0 - Extended serialization library on top of "cereal".  http://hackage.haskell.org/package/cereal-plus-0.3.0 (NikitaVolkov)
02:00:05 * hackagebot egison 3.2.17 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.17 (SatoshiEgi)
02:00:07 * hackagebot pipes-cereal-plus 0.3.0 - A streaming serialization library on top of "pipes" and "cereal-plus"  http://hackage.haskell.org/package/pipes-cereal-plus-0.3.0 (NikitaVolkov)
02:00:37 <jtcwang> for example here is the ouput from verboseCheck
02:00:38 <jtcwang> Passed:
02:00:38 <jtcwang> "\CAN"
02:00:38 <jtcwang> Passed:
02:00:38 <jtcwang> "O"
02:00:39 <jtcwang> Passed:
02:00:41 <jtcwang> "D"
02:00:43 <jtcwang> Passed:
02:00:45 <jtcwang> "$c7"
02:00:47 <jtcwang> Passed:
02:00:49 <jtcwang> "z\248w"
02:00:53 <jtcwang> Passed:
02:00:55 <jtcwang> "@\136L["
02:00:57 <merijn> jtcwang: Don't paste more than 1 line in the channel
02:00:57 <jtcwang> Passed:
02:00:59 <jtcwang> "W"
02:01:01 <jtcwang> Passed:
02:01:03 <jtcwang> "\ETX_"
02:01:05 <jtcwang> Failed:
02:01:07 <jtcwang> "\172\140\155\ESC\r2\a"
02:01:09 <jtcwang> *** Failed! Skipped (precondition false):
02:01:11 <jtcwang> ""
02:01:13 <jtcwang> Passed:
02:01:15 <jtcwang> "\ESC\r2\a"
02:01:17 <davison> STOP
02:01:17 <jtcwang> <interactive>: out of memorynd 0.2 shrinks)...
02:01:19 <jtcwang> oh sry
02:01:35 <davison> makes it hard to read
02:01:37 <Kinnison> Please use a pastebin
02:01:48 <jtcwang> sry
02:01:49 <dv-> @where paste
02:01:49 <lambdabot> http://hpaste.org/new/haskell
02:02:22 <jtcwang> here: http://lpaste.net/99809
02:02:32 <jtcwang> so i can't see what the input is
02:03:43 <rgr> Im trying to understand the underpinnings of a haskell setup. Currently getting docs is proving a hit and miss. ie hayoo vs hoogle or if theres anything local or not (e.g why cant I hoogle xmonad on a clean install). The way to set up hoogle is "hoogle data". What defines *what* is indexed in this case? Apparently an "extended database" can be created with "hoogle data all" - what defines an extended database?
02:04:56 <merijn> rgr: By default hoogle only index a standard set (like the website), you can tell hoogle to either index everything you have installed locally, or just index all of hackage
02:05:04 * hackagebot cereal-plus 0.3.1 - Extended serialization library on top of "cereal".  http://hackage.haskell.org/package/cereal-plus-0.3.1 (NikitaVolkov)
02:05:06 * hackagebot aws-sdk-xml-unordered 0.3.0.1 - The xml parser for aws-sdk package  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.3.0.1 (ShoheiYasutake)
02:05:15 <merijn> rgr: I forget exactly how to do the latter, but I just followed the help of the hoogle program.
02:05:55 <merijn> rgr: Probably you want to merge the extra databases you generate into the default database (which is unfortunately a bit of a memory hogging process), I remembr someone here wrote a tool to do that
02:06:14 <osa1> do we have a toTitle functino in text < 0.12 ?
02:06:17 <osa1> function*
02:06:19 <rgr> I have no man page and hoogle --help is equally terse.
02:06:43 <merijn> rgr: Additionally, if you specified "Documentation: True" in your cabal config then there will be browsable HTML docs installed locally (i.e. like the stuff the hoogle website shows)
02:07:15 <Feuerbach> jtcwang: so it looks like "\172\140\155\ESC\r2\a" is the input that fails the test
02:07:15 <merijn> rgr: Not sure about the location on linux, but probably ~/.ghc/doc or ~/.cabal/doc
02:07:41 <merijn> rgr: There should be an "index.html" there that lists all locally installed modules and what package they come form
02:07:44 <merijn> *from
02:07:56 <jtcwang> Feuerbach, oh ok. I thought quicktest is suppose to stop when it fails?
02:08:00 <codygman> How can I use Hakyll with github pages without having to have two repos?
02:08:01 <rgr> how does that tie in with hoogle? Im sorry to sound like im whining but I cant see any rhyme no reason being what is documented where. Maybe I need to take a step back. ie the command in ghci to get docs is "hoogle" but that doesnt use the html files.
02:08:25 <rgr> but thanks for your answers. They help.
02:08:30 <Feuerbach> jtcwang: it then attempts to shrink the example
02:08:32 <merijn> rgr: Hoogle is just a standalone tool someone wrote to easily search through documentation
02:08:46 <jtcwang> Feuerbach, ah ok. that's handy
02:09:08 <merijn> rgr: Haddock is the default tool used to generate documentation and it generates HTML, like: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html
02:09:36 <merijn> rgr: This documentation is just installed as static HTML files on your system (provided you configured cabal to install documentation like I mentioned)
02:10:07 <Feuerbach> jtcwang: you can print the input to find out why it runs out of memory, but that input doesn't necessarily fails the test
02:10:10 <merijn> rgr: Hoogle just indexes this documentation (either on the hackage machine, if you use the website or on your local machine if you have a local hoogle + local database)
02:10:18 <rgr> I did. So why is there no xmonad from hoogle? So hoogle uses haddock to generate the help?
02:10:34 <merijn> rgr: Right, did you install xmonad via your package manager?
02:10:35 <jtcwang> Feuerbach, i'll look into it. Thanks
02:10:37 <rgr> yes
02:10:44 <rgr> I did a complete reintall yesterday
02:10:48 <merijn> rgr: Maybe your package manager disabled the generation of documentation?
02:10:59 <rgr> oh sorry no. I read "cabal package manager".
02:11:05 <rgr> I installed all with cabal.
02:11:20 <rgr> (after setting the documentation flag in config)
02:11:40 <merijn> rgr: Have you checked ~/.ghc and ~/.cabal for a doc directory?
02:11:48 <rgr> ie which xmonad  -> .cabal/bin
02:11:53 <merijn> rgr: Let's first check if *that* worked
02:12:43 <merijn> rgr: also, if you hoogle the package name "xmonad" (http://www.haskell.org/hoogle/?hoogle=xmonad) and click on the package you will see the documentation too
02:13:44 <rgr> I get help for something like "spawn" but not "spawnOnce" for example
02:13:45 <rgr> :!hoogle --info spawn
02:13:50 <rgr> (as an example)
02:14:11 <rgr> I know about the web but being an emacs user I like to generate in buffer help.
02:14:24 <rgr> (and thank you for hand holding)
02:14:33 <merijn> rgr: Right, but is the local documentation on your machine?
02:15:14 <rgr> well if :!hoogle worked I guess? And I installed hoogle and did a "hoogle data" where tars were downloaded. Let me see...
02:15:38 <merijn> ~/.cabal/config should have an entry "doc-index-file" that lists the local help index
02:15:48 <rgr> I have a share/hoogle dir with loads of databases
02:15:49 <merijn> rgr: I would first open that and check that you see xmonad in that list
02:15:53 <rgr> ok
02:16:38 <merijn> rgr: Right, if you generate extra database you need to tell Hoogle to search those and/or merge them into the default database before hoogle will actually find anything from the extra packages, however I forgot the command to do that
02:16:42 <rgr> -- doc-index-file: $datadir/doc/index.html
02:17:05 <merijn> datadir should be defined somewhere in the same file, probably ~/.cabal, though
02:17:21 <rgr> ok then theres no doc.
02:17:23 <SpecialK> ngh cabal config has too many local-specific things :(
02:17:33 <merijn> rgr: That's weird
02:17:34 <rgr> (and it isnt defined in .cabal/config)
02:17:43 <SpecialK> does it do anything like ~-expansion?
02:18:02 <merijn> rgr: I'm not too familiar with the linux default, unfortunately
02:18:51 <rgr> the good news is I do see a xmonad file i nthe share/hoogle* directoy
02:19:12 <rgr> which now begs the question whats the difference between doc and share/hoogle
02:19:58 <rgr> and from what you're saying it seems hoogle getting the data doesnt actually make it available to the hoogle command? I need to merge it somehow?
02:20:06 * hackagebot pipes-cereal-plus 0.3.1 - A streaming serialization library on top of "pipes" and "cereal-plus"  http://hackage.haskell.org/package/pipes-cereal-plus-0.3.1 (NikitaVolkov)
02:22:26 <rgr> and I find a merge script on the wiki page which creates another database in .hoogle. Streuth ;) I'll try that.
02:25:06 * hackagebot egison 3.2.18 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.18 (SatoshiEgi)
02:35:20 <rgr> trying to do a "hoogle data all" as advised on the wiki : downloads/hoogle/reactive-glut/0.1.6/doc/html/reactive-glut.txt: hGetContents: invalid argument (invalid byte sequence)
02:39:50 <rgr> merijn: just fyi the doc was in .cabal/share as default.
02:40:07 <merijn> ah :)
02:40:23 <merijn> I'm not too familiar with hoogle to debug that problem, though
02:41:01 <rgr> Im no clearer to getting anything meaningful displayed and most of the script on the wiki seem outdated but I'll keep plugging along. I'm a bit anal when it comes to this stuff. I cant go on learning unless I have the docs "at my fingertips". probably my own downfall as I feel like giving up now... lol...
02:41:43 <merijn> rgr: Might wanna ask later when the emacs crowd shows up
02:42:11 <epredator> hello :)
02:42:29 <rgr> tried before. It's hard to get setup help from anyone. Most haskell gods dont seem to need to the docs ;)
02:45:51 <dmj`> they wrote the docs ;)
02:47:41 <rgr> true.  the script here to combine hoogle hoo files doesnt work either. http://www.haskell.org/haskellwiki/Hoogle - no --output flag anymore.
02:50:38 <BasDirks> when a function only occurs in one other function, is it usually desireable to compress them into one function, or is there no "usually"?
02:51:21 <davean> BasDirks: there is no usually, and have you considered where clauses?
02:52:06 <merijn> BasDirks: Usually you'd use "where" and make it a "local" function
02:52:07 <BasDirks> yes where clause is the obvious way of compressing them
02:52:56 <merijn> BasDirks: But yes, I prefer to avoid polluting the global scope when possible
02:54:43 <dmj`> merijn: I have some acid-state questions
02:55:54 <dmj`> how is it possible to apply a migration to a remote acid-state server w/o downtime?
02:56:47 <dmj`> what if you updated the functions as well, then all clients that connect would need to be updated as well
02:57:03 <dmj`> so you'd need to bring all servers down
02:58:28 <BasDirks> merijn, even with with IO? I am doubtful about not seperating as much pure code as possible from anything -> IO ()
02:59:15 <dmj`> BasDirks: can you show us your code?
02:59:51 <HugoDaniel> dmj`: just copy the files to the remote server :)
02:59:58 <BasDirks> no it's for work :( just going over some cosmetics
03:01:35 <dmj`> HugoDaniel: You mean the binary? The logs will sit on the server, or in an S3 bucket
03:01:57 <HugoDaniel> dmj`: copy the acid-state data dir to that other server
03:01:58 <HugoDaniel> and its ok
03:02:05 <HugoDaniel> unless you need them to be synced
03:02:46 <dmj`> HugoDaniel: I'm using Data.Acid.Remote so one server broadcasts the state and others connect to it via tcp and have their operations synched via STM
03:03:02 <HugoDaniel> if you also need them to be synced then its harder, i would probably try to use something that resembles two phase lock
03:03:18 <HugoDaniel> oh ok
03:03:42 <dmj`> HugoDaniel: stepcut added that functionality in but it wasn't really broadcast it seems
03:05:11 * hackagebot fsharp 0.0.1 - some F# operators, high priority pipes  http://hackage.haskell.org/package/fsharp-0.0.1 (Heather)
03:05:15 <HugoDaniel> BasDirks: if you really want to avoid where clauses for some strange reason, you can tell that your module only exports the functions that you will actually need outside of it, that way ghc will optimize better the stuff that is not exported
03:05:56 <rgr> I'm assuming that setting the documentation flag in .cabal/conf simply tells cabal to run "runhaskell Setup haddock --hoogle" against a newly installed library?
03:07:42 <HugoDaniel> dmj`: you want to keep two acid-state servers in sync, is that it ?
03:09:41 <dmj`> HugoDaniel: No, I have one state. It is broadcast over a port that clients can connect to, to perform operations
03:09:49 <dmj`> so in that sense it is in sync
03:10:11 * hackagebot fsharp 0.0.2 - some F# operators, high priority pipes  http://hackage.haskell.org/package/fsharp-0.0.2 (Heather)
03:10:32 <BasDirks> HugoDaniel: strange reasons would include testability/modularity
03:10:51 <BasDirks> I already explicitely export everything
03:10:57 <dmj`> HugoDaniel: What I'm worried about it downtime w/ migrations
03:11:36 <HugoDaniel> BasDirks: then its mess your code at will :)
03:11:38 <zipper> Is there a haskell offtopic?
03:11:45 <HugoDaniel> zipper: #haskell-blah
03:12:15 <zipper> HugoDaniel: Thanks :D
03:12:41 <HugoDaniel> dmj`: i did it last year, i had two servers that sometimes i needed to migrate (to restore the other server to a more recent state), and all i did was put the second server down, copy the acid-state dir from the first server to the second server, and boot it
03:13:14 <HugoDaniel> s/boot/start
03:13:17 <HugoDaniel> the service
03:14:04 <HugoDaniel> but im not sure if this is your use case
03:14:27 <HugoDaniel> i also had the case where sometimes the acid-state dir was in a inconsistent state
03:14:36 <HugoDaniel> because of bugs in the safecopy instances
03:15:00 <HugoDaniel> but it is also easy to fix if you mingle with the files in the acid-state dir
03:15:12 * hackagebot fsharp 0.0.3 - some F# operators, high priority pipes  http://hackage.haskell.org/package/fsharp-0.0.3 (Heather)
03:15:25 <HugoDaniel> and know how they are being serialized
03:15:38 <HugoDaniel> im not sure how this all goes if you start checkpointing
03:16:22 <HugoDaniel> but it should also be possible to deal with
03:20:12 * hackagebot snaplet-mysql-simple 0.1.1.4 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.1.1.4 (ibotty)
03:24:47 <kuroikaze> hi. I'm trying to build the haskell platform from source on linux, got pre-built ghc. I have a GCC compiler at /opt/gcc and I set the build to use this one, but the network package insists in being built with /usr/bin/gcc. does anyone know a workaround?
03:26:10 <adnam> kuroikaze: PATH issue?
03:26:41 <kuroikaze> I set the path before running configure :(
03:30:24 <cariveri> Hi everyone. Can I generate docs from a source.hs ?
03:34:59 <dmj`> HugoDaniel: you didnt' use safecopy's MigrateFrom ?
03:35:11 <notdan> cariveri: sure, try `man haddock`
03:35:19 <HugoDaniel> no
03:35:22 <HugoDaniel> :/
03:35:30 <notdan> cariveri: haddock source.hs --html
03:36:24 <cariveri> notdan: coolr. it is based on type signatures I guess. so do I need to add those by hand too? I mean ghc does recognize it anways, way would I not have it done by it?
03:42:24 <notdan> you can add your own typesignatures if you don't like the derived ones
03:42:43 <notdan> also type signatures help people who look at your code without looking at the haddocks
03:43:09 <notdan> btw if you are writing a library or a program you might want to use Cabal for packaging it all up
03:43:17 <notdan> you can then generate haddocks with `cabal haddock`
03:44:00 <cariveri> notdan: thats nto my point. I like type signatures, but I failed to add them continously. so a documention would look pretty empty. I want gch to add them for me, since it can infer types.
03:51:33 <cariveri> notdan: at least I foudn out that :brows lists up the infered types as well. so I can copy paste them. still its tedious.
04:11:05 <piezo> hi
04:11:09 <piezo> i still have difficulties with ScopedTypeVariables...
04:11:23 <piezo> does instance methods brings type in scope ?
04:11:58 <cariveri> whats the error?
04:13:37 <rgr> how can I ask lambdabot in ghci to do the equivalent of external command !hoogle --info funcname
04:14:24 <piezo> cariveri: i'm not sure it's helpfull, it's quite long with a lot of existensials and noise
04:14:59 <cariveri> piezo: I mean, is it a variable not in scope problem?
04:15:27 <cariveri> piezo: or does it suggest to add an instance of a method which is not implemented yet?
04:15:38 <rgr> also any ideas why using the lambdabot standard ":src" definition shipped with GOA do I get 'Plugin `sourcePlugin' failed with: state not initialized'.
04:16:53 <quicksilver> instance methods don't bring anything into scope piezo
04:17:00 <quicksilver> instances do, though
04:17:13 <quicksilver> the instance itself brings into the scope the types in the instance.
04:17:34 <quicksilver> instance Show (F a) where .... {- brings a into scope I think -}
04:17:38 * quicksilver isn't sure any more
04:18:01 <quicksilver> show the code and the error message
04:18:05 <quicksilver> who cares how long it is
04:18:06 <bernalex> anyone know vty-ui? how come I can't do foos <- plainText "foo"   -- it complains about "couldn't match expected type 'Text' with actual type '[Char]', when the documentation does the exact sam... oh right the documentation assumes you use OverloadedStrings...
04:18:30 <rgr> ok it seems its just broken  http://stackoverflow.com/questions/20195915/lambdabot-sourceplugin-failed-with-state-not-initialized Im beginning to wonder if anyone uses this stuff. Nothing seems to work as the docs say it should "out of the box".
04:20:19 * hackagebot snaplet-acid-state 0.2.6.1 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.6.1 (DougBeardsley)
04:21:03 <dyeprii> hello there. i don't know how-to haskell. Am i even allowed here?
04:21:21 <Sweden_jack> dyeprii: Of course
04:21:31 <cariveri> notdan: Thank you, by the way.
04:21:34 <Sweden_jack> Here is a good place to get started
04:21:34 <Sweden_jack> @where lyah
04:21:34 <lambdabot> http://www.learnyouahaskell.com/
04:22:02 <maikklein> Do you know a good book that covers function programming in general? -> Functional api design, functional thinking. Doesn't have to be haskell specific.
04:22:06 <dyeprii> wow thanks
04:22:06 <piezo> quicksilver: thanks that's answer my question
04:22:33 <Sweden_jack> maikklein: Simon Marlow's book has some nice projects that should give you an idea of designing programs in Haskell
04:22:48 <piezo> i didn't want to share my headache, but here it is : http://lpaste.net/99810
04:23:54 <bernalex> so does anyone happen to just know how to make widgets take up 50% space with vty-ui? I want to first split the screen in half horizontally, then split the upper half in two vertically.
04:24:03 <maikklein> Sweden_jack: Do you mean "Parallel and Concurrent Programming in Haskell"?
04:24:10 <Sweden_jack> yes
04:24:51 <Sweden_jack> not quite what you were asking for
04:28:20 <piezo> i think i need InstanceSigs to brings scoped type variables in scope with explicit forall : https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/type-class-extensions.html#instance-sigs
04:29:39 <bernalex> right I think I need to use setBoxChildSizePolicy somehow
04:35:21 <bernalex> if anyone knows vty-ui, feel free to point out what's wrong in "ui <- ((return feeds) <++> (return posts) >>= setBoxChildSizePolicy (Percentage     50)) <--> (return post)". I get "Couldn't match type 'ChildSizePolicy' with 'IORef (WidgetImpl (Box FormattedText FormattedText))'".
04:36:35 <bernalex> h right setBox.... is IO ()
04:38:34 <quicksilver> piezo: I think you are absolutely correct.
04:38:53 <quicksilver> piezo: your example is rather like theirs. If a bit more fiddly.
04:39:16 <merijn> IMO InstanceSigs should be on by default
04:39:40 <merijn> What are my odds of succesfully campaigning for that? :p
04:41:47 <piezo> merijn: yes, like MPTC, FC/I, and tons of things :)
04:42:46 <quicksilver> merijn: only in the presence of other extensions, really
04:42:54 <quicksilver> it's not important in plain haskell 2010
04:43:11 <quicksilver> but with MPTCs and TypeFamilies
04:47:39 <tomejaguar> IS there a comparison between units and dimensional?
04:49:19 <tomejaguar> And why is units's module 'Data.Dimensions' whilst dimensional's is 'Numeric.Units'?
04:50:26 <merijn> quicksilver: I like writing instance signatures even if they are unnecessary
04:51:02 <merijn> piezo: The difference is that those features aren't in the report and can make type errors a lot more complex/confusing
04:52:14 <quicksilver> merijn: fair enough.
04:52:18 <quicksilver> merijn: doesn't do any harm, I agree
04:53:03 <merijn> quicksilver: i.e. for things like Functor/Monad instance of State, Reader, etc. they can help a lot
05:00:49 <rgr> in http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#ghci-scope it says I can ':m + IO'. I cant. I can however ':m + System.IO' but then only after an explicit import. Is this a different IO or is there some sort of "shortcut" set up in the documentation authors setup?
05:01:25 <Sweden_jack> rgr: 6.6 is an old version of ghc
05:01:50 <merijn> s/old/ancient
05:01:57 <rgr> oh god. google links again. ok I'll recheck latest. sorry... again.
05:04:20 <rgr> oh good ;) The new version works as I expected. Phew.
05:05:24 * hackagebot enclosed-exceptions 1.0.0 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.0 (jcristovao)
05:20:22 <quchen> merijn: Old enough even to not appear on the releases list on haskell.org/ghc
05:23:09 <klrr_> Sweden_jack: i pressume you are swedish, you know of any haskell meetups in sweden?
05:25:04 <Clifff> klrr_: http://www.meetup.com/Haskell-Stockholm/ ;)
05:28:20 <Sweden_jack> klrr_: I'm actually Icelandic
05:28:29 <klrr_> okey
05:28:41 <Sweden_jack> but I'm currently living in Gothenburg
05:28:42 <klrr_> oh cool so sthlm have a haskell meetup
05:28:56 <klrr_> i live in gbg too
05:28:57 <Sweden_jack> there is a lot of Haskell activity here
05:29:03 <klrr_> it is? o.o
05:29:12 <Sweden_jack> at Chalmers University there is
05:29:36 <adnam> i wish i went there :-(
05:30:05 <klrr_> chalmers doesnt have a CS programme as far as i know
05:30:29 <Sweden_jack> http://www.chalmers.se/en/education/programmes/masters-info/Pages/Computer-Science-algorithms-languages-and-logic.aspx ?
05:30:51 <bernalex> what is an efficient way to do this: http://lpaste.net/1541363234529869824 -- but instead of "feed1" and "post1", let's say I have a list, fs = ["feed1".."feed100"], and ps = ["post1".."post100"]?
05:31:05 <bernalex> basically I need some forM help, I think. :->
05:31:24 <adnam> klrr_: CS is run by gothenburg university
05:31:30 <klrr_> yeah i know
05:31:43 <klrr_> so, after you got bachelor you can study CS on chalmers?
05:31:55 <Sweden_jack> It's hard to tell there GU stops and where Chalmers starts sometimes
05:31:58 <Sweden_jack> *where
05:32:02 <merijn> klrr_: Chalmers is one of the more well known haskell/agda places
05:32:10 <matheus23> I have a Data.ByteString and I wont to convert it to a Data.ByteString.Lazy.ByteString ... :(
05:32:15 <bernalex> Sweden_jack: that makes me semi-jealous at my mechanical engineer friend that attends Chalmers.
05:32:22 <klrr_> yeah i know, that's why i found it strange that i couldnt find CS course there
05:32:42 <klrr_> MD you need to study Bachelor before that right?
05:32:59 <klrr_> okey this should maybe take blace in blah
05:33:59 <matheus23> can anybody tell me how to convert the strict bytestring to a lazy bytestring?
05:34:29 <adnam> matheus23: Data.ByteString.Lazy.fromStrict
05:35:00 <merijn> adnam: That's a fairly new function, I think
05:35:11 <matheus23> adnam: Thank you! The docs somehow don't show that ?!
05:35:25 <matheus23> (couldn't find it here: http://hackage.haskell.org/package/bytestring-0.9.1.5/docs/Data-ByteString-Lazy.html) But thanks!
05:35:25 <merijn> matheus23: Because it's really new and if you're using an older version it doesn't exist
05:35:30 <matheus23> My version is new enough
05:35:42 <adnam> yeah it's not available before ghc 7.6
05:35:49 <merijn> matheus23: Those are the docs for 0.9.1
05:35:59 <matheus23> okay.
05:36:03 <merijn> matheus23: If you have a newer version you should read the docs for that version :p
05:36:04 <t7> > [ "feed" ++ show x | x <- [1..]]
05:36:05 <lambdabot>  ["feed1","feed2","feed3","feed4","feed5","feed6","feed7","feed8","feed9","fe...
05:36:09 <t7> bernalex: ^
05:36:18 <merijn> matheus23: (if you click "contents" in the top right you'll see a list of all possible versions)
05:36:22 <bernalex> t7: wat?
05:36:44 <matheus23> merijn: yeah... google gave me those docs :/
05:36:51 <t7> i wanna be in your rss app contributors now
05:36:54 <bernalex> t7: oh, I think maybe you completely missed the point.
05:37:06 <bernalex> t7: please reread and see the paste.
05:37:10 <adnam> i can recommend the Hackage-fu chrome extension
05:37:17 <merijn> matheus23: Google doesn't always go to the newest docs :\
05:37:42 <matheus23> hackage-fu? k thanks for that tip :) (I recommend creating the :hoogle shortcut in ghci, btw ;) )
05:37:47 <Sweden_jack> quite rarely actually..
05:38:13 <mm_freak_> what was that expression again that causes a type inference explosion?
05:38:25 <haasn> mm_freak_: fmap fmap fmap fmap fmap fmap ...
05:38:34 <matheus23> oh nice. hackage-fu does exactly what I need :D
05:38:45 <tomejaguar> https://twitter.com/HaskellTips/status/425503806722297856
05:38:52 <tomejaguar> ^^ Re google and hackage docs
05:38:52 <merijn> matheus23: fyi, there is no ":hoogle" shortcut in ghci, unless you programmed one yourself
05:38:57 <mm_freak_> haasn: nope, that one doesn't
05:39:06 <haasn> mm_freak_: then define “explosion”
05:39:17 <merijn> mm_freak_: Composing (.) with itself a ton of times, I think?
05:39:29 <mm_freak_> a short expression for which a screenful of type is inferred =)
05:39:33 <haasn> oh :)
05:39:34 <matheus23> Haskell tips? *follow*
05:39:41 <haasn> fmap .... just takes exponentially longer
05:40:12 <Sweden_jack> mm_freak_: I can find it if you're willing to wait
05:40:39 <mm_freak_> Sweden_jack: i am =)
05:41:19 <bernalex> t7: I think I solved it with forM.
05:41:32 <Sweden_jack>     foo = f5 () where
05:41:32 <Sweden_jack>         f0 x = (x, x)
05:41:32 <Sweden_jack>         f1 x = f0 (f0 x)
05:41:32 <Sweden_jack>         f2 x = f1 (f1 x)
05:41:35 <Sweden_jack>         f3 x = f2 (f2 x)
05:41:37 <Sweden_jack>         f4 x = f3 (f3 x)
05:41:41 <Sweden_jack>         f5 x = f4 (f4 x)
05:41:46 <Sweden_jack> that should do the trick
05:42:02 <mm_freak_> oh yeah, that was it =)
05:42:45 <bernalex> is there a way to do forM (foo, bar) $ \ (foo, bar) -> do ....?
05:42:53 <bernalex> where foo and bar are [Char] in this case
05:43:08 <mm_freak_> Sweden_jack: i think Cale mentioned a shorter version of that
05:43:20 <merijn> bernalex: "forM (zip foo bar) $ \(foo,bar) -> do"?
05:43:20 <bernalex> basically I want to do forM but with two lists at the same time
05:43:28 <Sweden_jack> bernalex: zipWithM?
05:43:29 <bernalex> merijn: they are not the same length
05:43:33 <Sweden_jack> hm
05:43:34 <piezo> bernalex: i tried something : http://lpaste.net/1541363234529869824
05:43:43 <Sweden_jack> mm_freak_: You can always make the tuple larger :)
05:43:45 <merijn> bernalex: Well, what do you want to do with the remainder after one list runs out?
05:44:10 <bernalex> merijn: waitaminute. I need two forMs anyway. never mind.
05:44:15 <piezo> bernalex: ithink <++> does the IO sequencing for you
05:44:28 <Sweden_jack> changing
05:44:28 <Sweden_jack>     f0 x = (x, x)
05:44:28 <Sweden_jack> to
05:44:28 <Sweden_jack>     f0 x = (x, x, x, x, x)
05:44:31 <mm_freak_> Sweden_jack: but yeah, it proves the point that type inference is exponential
05:44:31 <Sweden_jack> already blows it up for f2
05:44:32 <bernalex> piezo: ya using map was my second thought to forM
05:44:37 <bernalex> piezo: ah
05:44:39 <bernalex> piezo: thanks
05:44:59 <bernalex> piezo: I think maybe your way is nicer than forM. I'll try it out at least and see what looks nicer. :-)
05:45:04 <haasn> Oh! I was wondering why I couldn't do Sweden_jack's thing with join (.) . join (.) . join (.) . join (,)
05:45:16 <Sweden_jack> mm_freak_: tractability is overrated :)
05:45:18 <haasn> because join constrains both args to having the same type :(
05:45:28 <piezo> bernalex: not sure if it works
05:45:48 <mm_freak_> Sweden_jack: sure =)
05:46:25 <haasn> > text $ "f0 x = (" ++ intercalate ", " (replicate 64 "x") ++ ")"
05:46:26 <lambdabot>  f0 x = (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x,...
05:47:13 <supki> mm_freak_: hey, did you receive my question about netwire-4.* bounds on profunctors and bifunctors being too restrictive?
05:47:16 <Sweden_jack> @ty let f0 x = (x, x, x, x, x); f1 = f0.f0; f2 = f1.f1 in f2 ()
05:47:17 <haasn> > text $ "f1 = " ++ intercalate " . " (replicate 64 f0) -- did somebody mention Graham?
05:47:20 <lambdabot> (((((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (
05:47:22 <lambdabot>  Not in scope: `f0'
05:47:24 <lambdabot> ), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()))), ((((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()),
05:47:26 <lambdabot>  Perhaps you meant one of these:
05:47:28 <lambdabot>  ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ()), ((), (), (), (), ())), (((), (), (), (), ()), ((), (), (),
05:47:30 <lambdabot>    `f' (line 152), `f' (imported from Debug.SimpleReflect),
05:47:32 <lambdabot>    f' (imported from Debug.SimpleReflect)
05:47:36 <haasn> > text $ "f1 = " ++ intercalate " . " (replicate 64 "f0")
05:47:37 <lambdabot>  f1 = f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f0 . f...
05:47:39 <mm_freak_> supki: no, sorry…
05:47:40 <haasn> :)
05:48:31 <bernalex> piezo: hm there are a few things wrong
05:48:31 <supki> mm_freak_: oh, I was just wondering if releasing 4.0.8 or something with the relaxed bounds was possible
05:48:50 <bernalex> piezo:  ["post1", "feed1"]
05:48:55 <bernalex> uups
05:48:57 <supki> mm_freak_: no source code changes are needed AFAICT
05:49:43 <bernalex> piezo: let feeds = map (makeBWB fg) foos; let posts = map (makeBWB fg) bars -- then I need to make a feedBox and a postsBox out of these
05:50:18 <bernalex> piezo: i.e. posts and feeds are different boxes themselves, and they need to be <++>'d into a parent box
05:51:11 <mm_freak_> supki: oh, netwire 4 is already out of sync with almost everything…  i would ask you to port your code to netwire 5 instead…  should be very easy
05:51:40 <mm_freak_> netwire 4 was one giant maintainance hell =)
05:52:42 <piezo> bernalex: they're already Widget. but maybe you need the original Button ?
05:54:13 <laura_h> Stupid question reg. PatternMatching: When I define testFunc a b = a*b I get with  testFunc 2 3 => 6. To my understanding this is due to function-name was matched and then two parameters are evaluated.
05:54:33 <piezo> bernalex: ma <++> mb = do { a <- ma ; b <- mb ; hbox a b } -- if it can help
05:54:35 <laura_h> But why does 2 `testFunc` 3 works as well?
05:54:48 <laura_h> Its not specified and what kind of pattern is matched?
05:55:07 <bernalex> piezo: right, you make a widget per button. I believe this is undesirable. I need to play with the code a bit.
05:56:10 <bernalex> piezo: I'm not sure if each button needs to be a widget or not. better reread the docs a bit.
05:57:37 <piezo> bernalex: yeah, i know nothing about vty-ui...
05:57:59 <quicksilver> laura_h: `` is a piece of syntax to let you write function names in between parameters
05:58:06 <kusut> if I cabal install --only-dependencies in my sandbox, do the dependencies go to ~/.ghc/xxxxx/package.conf.d? not in the .cabal-sandbox/ ?
05:58:10 <quicksilver> laura_h: (f a b) is the same as (a `f` b)
06:00:08 <bernalex> piezo: I think I need makeButton fg txt = do b <- newButton $ T.pack txt; bw <- (return (buttonWidget b)); addToFocusGroup fg b
06:00:21 <laura_h> quicksilver: so something like synthetic sugar?
06:00:24 <kusut> hmm looks like I forgot to rebuild the sandbox
06:00:33 <bernalex> piezo: then let feeds = map (makeButton fg) foos; let posts = map (makeButton fg) bars
06:00:36 <pranz> is it possible to have a type like ((Show a, Read b) => Either a b) ?
06:00:52 <linduxed> any Haskell hackers from Stockholm here?
06:01:02 <bernalex> piezo: then something magic that makes feedbox <- (return (buttonWidget feeds)) work with multiple feeds.
06:01:12 <piezo> bernalex: use 'let bw = buttonWidget b' instead of bw <- return
06:02:00 <piezo> bernalex: it's simply 'map buttonWidget feed'
06:02:21 <supki> mm_freak_: hmm, I'll give it a shot, thanks
06:03:35 <quicksilver> laura_h: yes.
06:03:44 <piezo> bernalex: buttonWidget is not IO related, it's just a Button field accessor
06:03:51 <quicksilver> pranz: yes.
06:04:30 <laura_h> quicksilver: the same sugar applies then as well for the function definition?
06:04:51 <quicksilver> laura_h: you can choose to define functions in infix style if you want
06:04:54 <quicksilver> it's a bit unusual
06:05:01 <merijn> I've seen it a few times
06:05:03 <mm_freak_> supki: feel free to ask, if you run into problems =)
06:05:11 <quicksilver> > let a `f` b = a*b in f 2 4
06:05:13 <lambdabot>  8
06:05:40 <laura_h> quicksilver: and this is still called PatternMatching? (Which confuses me)
06:06:11 <piezo> laura_h: (f a) is not about pattern matching, it's function application
06:07:04 <linduxed> mods and frequenters, is it ok to drop a link here to a Haskell Event?
06:07:09 <quicksilver> piezo: it is about pattern matchin when it's on the left side of an = sign.
06:07:24 <quicksilver> laura_h: yes. although it's not an interesting example of a pattern
06:07:25 <linduxed> or would that fall within "spammy marketing"?
06:07:51 <quicksilver> but (Left x) `f` (y,z) = ..... is a more interesting pattern
06:07:54 <piezo> laura_h: pattern matching is in lhs of function or case : 'f (Just a) = a' or case maybea of Just a -> a
06:08:17 <piezo> but yes f a = ... is a simple match
06:08:34 <bernalex> piezo: right so what do I do about making box1 then?
06:08:54 <bernalex> given let feedBox = map buttonWidget feeds; let postsBox = map buttonWidget posts
06:09:22 <bernalex> well, those are not boxes, lol
06:09:31 <bernalex> feedButtons and postsButtons, I guess
06:10:07 <laura_h> quicksilver: (Left x) `f` (y,z) = ..... then f is the function and x y z are the patterns matched.... but what is then ``??? At least I didn't find it anywhere mentioned in the beginners sections...
06:10:41 <quicksilver> laura_h: `` is just a bit of syntax
06:10:51 <quicksilver> laura_h: which lets you write functions in operator-style
06:11:04 <bernalex> piezo: foldr1 (<++>) fooButtons -- doesn't work because can't match IORef (WidgetImpl Padded) with IO (Widget a1)
06:11:10 <quicksilver> it's a valid part of both pattern and expression syntax.
06:11:41 <bernalex> uhm right, that was feedBox <- foldr1...
06:11:55 <laura_h> quicksilver: uhu... thx for the explenation - which leaves me with a little wrinkle on my forehead ;)
06:11:56 <FireFly> laura_h: it's documented here: http://www.haskell.org/haskellwiki/Keywords#.60
06:12:47 <quicksilver> FireFly: although that doesn't mention you can use it in pattern position
06:12:52 <laura_h> FireFly: thx for the link
06:12:58 <FireFly> Oh, that's true
06:14:20 <quicksilver> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-240003.2
06:14:33 <quicksilver> is the canonical reference but it's fairly terse
06:15:37 <piezo> bernalex: yes it's a bit more complicated, because you want to build Widget (Box a (Box a (Box a ...)))
06:16:15 <bernalex> piezo: I reverted to using your pasted function instead.
06:16:41 <bernalex> piezo: though "Couldn't match type 'Box Padded Padded' with 'Padded'" on box1 <- foldr1 (<++>) feeds, heh.
06:17:22 <bernalex> where feeds is from let feeds = map (makeBWB fg) foos
06:17:59 <piezo> the type depend on the number of widget, so foldr/foldr1 will not work, i don't know how to solve this...
06:20:46 <piezo> maybe with a existencial type, but maybe it can be simpler
06:21:50 <bernalex> I just tested with (head feeds) <++> (last feeds) to verify if the rest of the code works, and it does. so that's nice at least.
06:22:04 <ij> :t flip map [2,3] $ flip map [[2],[3]]
06:22:05 <lambdabot> (Num ([t] -> b), Num t) => [[b]]
06:22:18 <ij> Should I need to give an function argument to it?
06:23:15 <piezo> bernalex: what do you want to do with the resulting box ?
06:24:13 <bernalex> piezo: <--> it into another box
06:24:35 <bernalex> and then set it's child size policy. and then add it to a collection.
06:26:48 <piezo> bernalex: maybe you want list widget instead of nested Boxes ?
06:26:56 <bernalex> piezo: probably
06:28:35 <bernalex> piezo: from skimming the docs, it looks appropriate
06:29:09 <bernalex> piezo: I don't even know if I need buttons. I just need a list of items that can react to being highlighted
06:30:08 <bernalex> right, "getSelected" and "getListItem" etc is probably enough. maybe I can get rid of buttons altogether then.
06:31:36 <piezo> \l fg -> mapM_ (addToList l () <=< makeBWB fg) :: Widget (List () Padded) -> Widget FocusGroup -> [String] -> IO ()
06:31:48 <piezo> bernalex: maybe newTextList if enough for your use
06:32:46 <bernalex> woah, what's that? not in the docs
06:32:52 <piezo> bernalex: lists have onItemActivated so no button are needed i think
06:33:19 <bernalex> are you reading haddoc or something? because it's not in the manual
06:33:44 <piezo> bernalex: yes : http://hackage.haskell.org/package/vty-ui-1.6.1/docs/Graphics-Vty-Widgets-List.html#v:newTextList
06:34:03 <bernalex> thanks
06:36:07 <piezo> it's something like: newList selAttr >>= forM_ (\l -> addToList list l =<< plainText l) labels
06:36:36 <bernalex> you don't need addToList
06:37:09 <bernalex> you can just do newTextList attr (map plainText foos), I think
06:38:06 <piezo> yes i was describing ther internal of newTextList (you don't need map plainText either)
06:38:31 <bernalex> ah, just T.pack then
06:40:20 <bernalex> not sure what to do about attributes though, there should be some basic attribute thingy. I find it hard to believe that you *need* to make one for this.
06:41:43 <piezo> use def_attr
06:42:52 <bernalex> piezo: right. that's better than white `on` black, heh. thanks.
06:43:04 <piezo> bernalex: or current_attr for cascaded styles
06:43:51 <bernalex> piezo: right. this now looks great! thanks a lot.
06:44:13 <bernalex> piezo: well, I don't have any of the selecting in that I got for free with buttons, but the manual seems readable, so I'll probably figure it out.
06:44:20 <bernalex> (or whine here about not figuring it out)
06:45:42 <bernalex> if I understand the manual correctly, it has, from the get go, keybindings for selecting elements. so I guess I'll just add lambdas for changing their colour when they are selected.
06:55:55 <piezo> bernalex: there is setTextAppearFocused, you can use it with custom a newTextListFocused
06:56:21 <mm_freak_> sounds like vty-ui
06:56:32 <mm_freak_> and that sounds like a good use case for reactive-banana =)
06:57:48 <benzrf> hello
06:57:56 <benzrf> if i compile to a binary, which libs are necessary to execute it?
06:57:56 <piezo> bernalex: another reason to overload newTextList is to get atached data with ActivateItemEvent to avoid text lookup
06:58:52 <piezo> mm_freak_: yes, it's not FRP oriented, it use handler functions
06:59:43 <mm_freak_> piezo: that's why reactive-banana is good here
07:00:02 <bernalex> piezo: I'm not sure what you are suggesting to do wrt overloading
07:00:35 <mm_freak_> reactive-banana turns any event-handler-based framework into an FRP framework
07:01:02 <piezo> bernalex: i'm suggesting to use newList and addToList
07:01:05 <saml> how do I dispatch methods based on input (http request)?  pattern matching?
07:01:23 <saml> is there http request pattern matching library?
07:01:49 <johnw> saml: it depends on what framework you're using
07:01:56 <johnw> they are usually called "routes"
07:02:29 <johnw> yesod has a pretty convenient way of associated handler functions with routes
07:02:34 <saml> is there pattern matching library that gives you inverse, too?
07:02:42 <johnw> what would the inverse be?
07:04:21 <piezo> saml: maybe Yesod's renderRoute ?
07:07:17 <rgr> Im trying to combine hoo files as documented here: http://www.haskell.org/haskellwiki/Hoogle#Merging_binary_databases . Both examples use a --output switch. Its illegal and the man page for hoogle makes no mention of it. Any ideas or pointers?
07:08:50 <johnw> I'd recommend combining hoo files using rehoo (cabal install rehoo)
07:08:57 <johnw> it can combines pretty much an unlimited number of hoo files
07:10:29 <rgr> ok. never heard of that before. I'll look it up. thanks.
07:11:38 <mm_freak_> saml: yesod has something builtin, and for everything else you would use web-routes-boomerang
07:11:39 <piezo> do you know an online hoogle indexing lens package ? the one at haskell.org don't
07:13:05 <rgr> oh you still need to wrap it to find hoo files. ok
07:13:31 <johnw> piezo: try fpcomplete.com/hoogle
07:13:32 <syllogismos> fpcomplete.com/hoogle
07:13:34 <bernalex> god damnit. spent forever with couldn't match IO with IORef now
07:13:50 <johnw> bernalex: ?
07:14:00 <piezo> johnw, syllogismos: thanks :)
07:14:16 <rgr> johnw: the info for it doesnt mention a file list and just says "in the curent dir". So how does one use this to combine all hoo files in the subdirectories in .cabal?
07:14:41 <johnw> rgr: you'll need to copy those hoo files to a temp directory
07:14:52 <bernalex> I have foos = "blah", "blahrg", "blahblah"], then I want to do forM foos $ \ f -> do stuff. the stuff I need to do is essentialy T.pack, followed by plainText, followed by some crap that uses the plainText.
07:14:52 <rgr> oh.
07:16:13 <johnw> bernalex: can you show code and an error?
07:16:21 <johnw> i can't glean enough from that description to help
07:16:25 <bernalex> johnw: right now I'm pursuing a different approach
07:16:41 <bernalex> with formatFeeds <- mapM (plainText . T.pack) foos
07:16:56 <johnw> I assume plainText has type a -> m b?
07:17:10 <piezo> bernalex: make a toplevel typed helper function for the forM inner work, it help separate type error
07:17:18 <bernalex> which works. but then I want to do forM_ formatFeeds $ \ f -> do setTextAppearFocused f True; addTolList feeds f, but that doesn't work because I'm too dumb to figure out how addToList really works.
07:17:42 <bernalex> johnw: /b 46
07:17:47 <bernalex> ups
07:17:51 <johnw> bernalex: I need to see real code with a real error; otherwise, this is just a bunch of words
07:17:57 <bernalex> johnw: it has a -> IO b
07:18:02 <johnw> ok
07:19:19 <bernalex> johnw: if you want to see the code, then http://lpaste.net/1605612857196544000 is my current stuff
07:19:30 <johnw> what's the error?
07:19:45 <piezo> bernalex: type Widget a = IORef (WidgetImpl a), so you try to bind 'Widget a' instead of 'IO (Widget a)'
07:19:53 <bernalex> the addToList example in the manual does addToList feeds f =<< plainText f, so I need to do something else.
07:20:09 <bernalex> piezo: not right now with the new code
07:20:22 <bernalex> johnw: couldn't match IO b1 with Widget b2 -> IO ()
07:20:34 <johnw> aha
07:20:38 <johnw> addToList wants a third argument
07:20:44 * hackagebot sgd 0.3.5 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.5 (JakubWaszczuk)
07:20:48 <Yaniel> :t addToList
07:20:49 <lambdabot> Not in scope: `addToList'
07:20:54 <Yaniel> :(
07:20:56 <bernalex> yes, like I said, in the manual they do plainText at that step
07:20:57 <Kron> is there an already implemented version of (.).(.) in some standard library?
07:20:59 <Kron> .: or something?
07:21:18 <bernalex> maybe it wants a string representation as well as the plainText representation of the same string
07:22:28 <bernalex> right
07:22:45 <johnw> Kron: (.).(.) is usually called (.:)
07:22:51 <johnw> @hoogle (.:)
07:22:51 <lambdabot> No results found
07:22:54 <bernalex> forM_ (zip foos formatFeeds) $ \ (f, ff) -> do addToList feeds f ff -- works.
07:23:08 <johnw> it's in the libraries 'composition' and 'pointless-fun'
07:23:11 <Kron> right but is it implemented already somewhere?
07:23:11 <Kron> can I just import it from Data..function or something?
07:23:27 <johnw> import Data.Composition or Data.Function.Pointless
07:23:34 <johnw> (after installing one of those two libraries
07:24:27 <grohne> is there a known structure/technique/mechanism/typeclass to split a "l :: [a]" into two components "f :: i -> a" and 2is :: [is]" s.t. "map f is == l"? how would you call it?
07:24:28 <Kron> ahhh
07:24:29 <Kron> okay
07:24:57 <johnw> grohne: that sounds a bit like a representable functor
07:25:03 <chrra> Is there a handy operator for "fmap fmap fmap" too?
07:25:03 <johnw> grohne: but I'm not completely sure
07:25:09 <piezo> bernalex: addTOList need a data argument, if you have none use 'addToList feeds () f'
07:25:11 <johnw> chrra: fmap fmap fmap is (.:)
07:25:13 <grohne> johnw: thanks, will have a look.
07:25:37 <chrra> johnw: I know, but the ones in those packages only work for functions.
07:26:11 <johnw> ah
07:26:22 <Kron> fmap fmap fmap is just .: isn't it?
07:26:35 <Kron> ah
07:26:37 <bernalex> piezo: what is this "data element" supposed to contain?
07:26:38 <chrra> if (.) = fmap, yes.
07:27:22 <bernalex> piezo: I assume this means I can in the future add, say, an RSS feed as the data, and add a string representation (like its title) of it
07:27:29 * shapr boings
07:27:37 <johnw> shapr!!!
07:27:44 <shapr> johnw!!! How's code?
07:28:00 <johnw> going well, hacking away at stuff as we speak
07:28:01 <piezo> bernalex: anything you want, a handler bound to the entry will recieve "ActivateItemEvent Int a (Widget b)" where a is this data
07:28:05 <johnw> you?
07:28:17 <bernalex> piezo: right
07:28:17 <shapr> yay! I'm still writing Python and Arduino, but wouldn't mind jumping into some Haskell soon.
07:28:53 <bernalex> OK WTF. I get "No instance for (Show b0) arising from a use of 'newList'", but only on one of the lists. they are made in the exact same way.
07:29:10 <bernalex> aha. yes. solved.
07:29:53 <bernalex> piezo: right. now I have a list where all the text widgets can appear focused.
07:29:54 <shapr> johnw: I've done lots of knitting lately, some designs get surprisingly complicated.
07:31:53 <bernalex> oh. but they don't have an instance of HasNormalAttr, so I guess you're supposed to set it some other way.
07:32:27 <bernalex> right, setFocusAttribute
07:33:18 <bernalex> no instance for HasFocusAttr. that's odd.
07:34:06 <johnw> bernalex: are you here to ask questions, or just to say things while you code?
07:34:12 <bernalex> yes
07:35:12 <bernalex> "how do you set the focus attribute of a Widget FormattedText" would be one question.
07:35:43 <johnw> what library is this that you're using?
07:35:48 <bernalex> vty-ui.
07:35:59 <johnw> ah, I remember seeing the announcement for that
07:38:20 <pranz> I have a Lens' a b, but when I try to modify b with that lens I get an error saying that my lens isn't an instance of Contravariant Mutator?
07:38:23 <pranz> what does this mean?
07:38:55 <johnw> can you show me the expression and the full error?
07:39:09 <edwardk> pranz: are you using the same lens in the same function twice? once to get and once to set?
07:39:48 <pranz> lpasting it
07:44:57 <pranz> edwardk, johnw: http://lpaste.net/99825
07:45:40 <edwardk> to vectorX  makes a Getter, not a Lens.
07:46:37 <edwardk> Easier way to write Locatable for Vector:   instance Locatable Vector were location = id;
07:47:06 <edwardk> you can get the whole thing for free more or less by using makeClassy ''Vector
07:47:21 <johnw> "Lenses for free!  Act now, limited time offer."
07:47:28 <Kinnison> hehe
07:47:29 <edwardk> data Vector = Vector { _x, _y :: Int }; makeClassy ''Vector
07:48:11 <pranz> edwardk: ah, thanks
07:48:18 <edwardk> that gives you class HasVector a where vector :: Lens' a Vector; x, y :: Lens' a Int
07:48:44 <edwardk> Vector 5 3 & x %~ succ  -- will now o what you wanted
08:04:48 <kini> anyone know if there's an emacs mode for alex files somewhere?
08:05:04 <syllogismos> listOfInts [] = []
08:05:04 <syllogismos> listOfInts '1':xs = 1: listOfInts xs
08:05:04 <syllogismos> listOfInts  _ :xs = 0: listOfInts xs
08:05:12 <syllogismos> why am i getting a parse error?
08:05:18 <quicksilver> missing ()
08:05:25 <quicksilver> ('1':xs) = ...
08:05:26 <syllogismos> ohh
08:05:26 <Sweden_jack`> syllogismos: parentheses around ('1':xs)
08:05:31 <quicksilver> and for the other case
08:05:50 * hackagebot generic-maybe 0.3.0.3 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.3.0.3 (JonathanFischoff)
08:11:54 <Wizek_> Good morning!
08:12:31 <Wizek> Anyone knows how to convert Day to unix timestamp?
08:12:54 <johnw> you can convert it to a UTCTime easily, and then from that to a timestamp
08:13:12 <johnw> see utcTimeToPOSIXSeconds
08:15:51 * hackagebot ghc-events-analyze 0.2.0 - Analyze and visualize event logs  http://hackage.haskell.org/package/ghc-events-analyze-0.2.0 (EdskoDeVries)
08:16:07 <Wizek> Attempting.
08:17:58 <rgr> johnw: what are the benefits if any of the .hoo files over the txt data? Simply one of speed? At http://www.haskell.org/haskellwiki/Hoogle#Database_Creation (which is out of date : there's no --output switch it seems) there is no indication of what the .hoo files actually provide.
08:18:33 <johnw> rgr: .hoo does some encoding work that the hoogle binary depends on.  I'm not sure why exactly Neil chose that format, you'd have to ask him
08:20:51 * hackagebot smallcaps 0.4.1.2 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4.1.2 (StefanBerthold)
08:20:53 * hackagebot git-monitor 3.0.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.0.1 (JohnWiegley)
08:21:30 <dyeprii> if i ever work on a project which requires gui, what gui library should i use?
08:23:58 <syllogismos> is using IORef sort of cheating in haskell? should I think of implementing it in another way?
08:23:59 <HugoDaniel> dyeprii: html/css/js
08:24:09 <syllogismos> where do I use IORef in general?
08:24:13 <mornfall> syllogismos: that really depends on wha tyou are doing
08:24:13 <HugoDaniel> syllogismos: it depends on what you are doing
08:24:31 <rgr> well, as you will know,  hoogle has two database types. txt and hoo.  Im assuming "runhaskell Setup haddock --hoogle"  is run per module by cabal if the conf flag "documentation" is set. This produes the txt files. Then there's pretty much nothing about what .hoo files are for or why you would want to combine them. Its kind of a chicken and egg situation : trying to get the docs in order and working kind of require you to be a haskell
08:24:31 <rgr> demi-god to understand them.
08:25:32 <HugoDaniel> rgr: is that a question ?
08:25:34 <dyeprii> HugoDaniel: what i mean is bindings for opengl, qt of some sort
08:25:45 <HugoDaniel> yes there are a few of those
08:26:10 <HugoDaniel> its up to your requirements, xlib, qt, gtk, opengl, ncurses...
08:26:22 <mornfall> syllogismos: there's an imperative language hidden inside Haskell ;-)
08:26:57 <dyeprii> aren't there any library written in haskell?
08:26:59 <mornfall> syllogismos: using IORef directly may or may not be a good idea... if you can use StateT, it might be better to use that
08:27:09 <mornfall> dyeprii: full hackage of those
08:27:37 <mornfall> dyeprii: if you want GL, check out gloss, it's pretty neat
08:27:44 <HugoDaniel> dyeprii: there are bindings to all the popular ones, and then there are a bunch of others written in haskell, its up to you
08:27:48 <syllogismos> I never used StateT, its time :D
08:27:52 <HugoDaniel> i would recommend html/css/js :D
08:27:55 <syllogismos> to learn about it
08:28:05 <mm_freak> dyeprii: what sort of application do you want to write?
08:29:18 <dyeprii> HugoDaniel: well not a webapp. i a gui frontend for a command line script
08:29:41 <mm_freak> dyeprii: sounds like a job for HTML/CSS ;)
08:29:53 <mm_freak> but if you want a native GUI, you can use wx/GTK+
08:29:53 <HugoDaniel> :D
08:29:54 <HugoDaniel> ahah
08:29:59 <HugoDaniel> dyeprii: go for it: http://hackage.haskell.org/package/ncurses
08:30:13 <mm_freak> and i'd recommend vty over ncurses
08:30:49 <HugoDaniel> cool vty :D
08:31:17 <mm_freak> anyway, the answer still depends a lot on the type of application
08:37:13 <Kron> does anyone know any good tutorials on the ST monad?
08:37:43 <sm_> has anyone noticed a performance difference between the vty and curses packages ?
08:38:13 <mm_freak> sm: vty is likely a bit slower, because it uses String for everything
08:38:41 <mm_freak> Kron: do you understand IO?
08:38:46 <Kron> I think so
08:38:58 <mm_freak> then you understand ST…  it's just a constrained IO
08:38:58 <Kron> it's still sort of confusing but I'm not thoroughly lost when handling it anymore
08:39:00 <geekosaur> sm_ a lot of that will depend on the underlying curses. ncurses never did quite achieve performance parity with System V curses in my experience, and sysv curses never caught up with original bsd curses (but it does a lot more and needs to carry around more information about each character so "well duh")
08:39:12 <johnw> Kron: think of ST like an IO that can only read/write STRefs, which are just like IORefs in terms of how you use them
08:39:20 <Kron> I hear that unlike IO, ST data is not permanently 'tainted'
08:39:22 <Kron> you can escape from it
08:39:33 <johnw> there is a runST, yes
08:39:42 <mm_freak> Kron: an ST computation is a computation with side effects that you can't observe from outside
08:39:58 <Kron> and presumably doesn't affect anything outside it too I guess
08:40:02 <mornfall> Kron: more like reverse-escape :-)
08:40:04 <sm> that's interesting - thanks. I remember thinking my vty program would be super fast ("it's just text!") but it isn't
08:40:04 <mm_freak> yes
08:40:06 <Kron> a sandbox
08:40:08 <Kron> alright
08:40:36 <geekosaur> yeh, ncurses all the heavy lifting is in C and quite fast
08:40:48 <mm_freak> sm: well, terminals simply aren't fast…  vty does a good job, and does perform better than ncurses when it comes to drawing only what's necessary, but it's far from perfect
08:41:37 <mm_freak> but in general ncurses will beat vty, simply because it uses byte arrays for everything, where vty uses the more appropriate String
08:41:40 <ski> Kron : there's also `STArray' and `STUArray'
08:41:54 <mm_freak> note for example that vty understands and handles unicode well
08:42:12 <sm> nod
08:42:32 <sm> but if you wanted to sling large quantities of text around on screen with no perceptible delay, you'd use... opengl ?
08:42:49 <mm_freak> sm: what's "large"?
08:43:01 <sm> whatever you can fit on screen
08:43:11 <johnw> for something like vty vs. curses, would one even notice the difference in speed from using String?
08:43:20 <johnw> it's not like you ever display megabytes of text at one time
08:43:23 <mm_freak> sm: text for the sake of conveying textual information or as drawing primitives?
08:43:39 <mm_freak> johnw: unlikely for most applications
08:43:39 <sm> mm_freak: either
08:43:40 <geekosaur> depends on how I'm slinging it. if I'm not doing fancy updates or pretending to do windows then I might just putStr it possibly with some ansi escapes
08:43:44 <ski> Kron : monochrom has some fun lazy `ST' examples at <http://lpaste.net/63925>
08:43:46 <Kron> what exactly is an IORef anyway...
08:43:48 <Kron> oohthanks ski
08:43:58 <Kron> ski is your name a reference to s/k/i cominator algebra?
08:44:02 <bennofs> Why is the output different for Box and () in this paste: http://lpaste.net/9198675150269054976 ?
08:44:04 <ski> aye
08:44:07 <Kron> hah
08:44:08 <mm_freak> sm: if you want to do heavy animation, vty probably does it, unless you don't find the common resolutions sufficient
08:44:08 <Kron> clever
08:44:11 <johnw> Kron: An IORef or STRef is a mutable "cell" containing some value
08:44:12 <geekosaur> ncurses or slang (not that I recall any haskell interfaces to the latter) are pretty much the fastest you'll get for fancy screen manipulation
08:44:29 <bennofs> (Also happens if I use Int instead of ())
08:44:34 <mm_freak> sm: but yeah, at some point you probably want to switch to actual graphics
08:45:06 <johnw> GPU-accelerated text rendering!
08:45:07 <mm_freak> note that OpenGL does not necessarily make it faster…  it just potentially makes it more fancy =)
08:45:15 <ski> Kron : you may think of an `IORef a' and an `STRef s a' as an index (more or less like an `Integer'), that can be used to reference a specific cell with that index in a store that is implicitly threaded around by the monad
08:45:15 <geekosaur> hm. any graphical manipulation will be slower in real terms, although that's minimized if you're on x11 and use server-side fonts
08:45:20 <mm_freak> text with real-time shadows and normal mapping =)
08:45:30 * johnw dreams of an Emacs powered by a 4-way ATI Crossfire rig
08:45:44 <bennofs> My question can be simpliefied: With data X = X and let x = X; y = (), why does :p x differ from :p y in GHCi ?
08:45:57 <bennofs> simplified*
08:46:04 <johnw> bennofs: they have different types!
08:46:10 <bennofs> johnw: well, right
08:46:11 <sm> hledger-vty showed a screenful of text, which would scroll up/down a line at a time, and scrolling was not fast. I figured that was a limitation of vty/terminals, but I'm not sure
08:46:11 <johnw> albeit isomorphic
08:46:20 <bennofs> johnw: but one is shown evaluated, while the other is not
08:46:31 <mm_freak> sm: vty doesn't understand scrolling…  it will redraw
08:46:34 <zipper> :t /
08:46:35 <lambdabot> parse error on input `/'
08:46:36 <sm> right
08:46:40 <johnw> bennofs: what do you mean?
08:46:43 <ski> Kron : so, the index doesn't contain the value; only in a monadic opertion can you (implicitly) access the state that the index references into. however, you may compare indices without needing to look at the state, which explains why there's an `Eq' instance for `IORef a' and `STRef s a' (without even requiring `a' to be in `Eq' !)
08:46:48 <geekosaur> also most terminal emulators cannot scroll quickly unless it's full width
08:46:51 <sm> I expected redrawing a screenful of text to be instant
08:46:59 <zipper> :t (/)
08:46:59 <lambdabot> Fractional a => a -> a -> a
08:47:11 <geekosaur> sm: nope
08:47:14 <sm> like on the commodore 64 for gawds sake :)
08:47:17 <bennofs> johnw: :p y gives: y = ()
08:47:26 <geekosaur> just about every terminal emulator is a bit slow about scrolling
08:47:27 <bennofs> johnw: :p x gives x = (_t16::X)
08:47:28 <zipper> I have noticed that 2/0 returns "Infinity".
08:47:33 <mm_freak> sm: a lot of indirection is going on there…  it will be fast for single-color text, but if you have a lot of visual formatting it will be slower
08:47:35 <zipper> Infinity is a string
08:47:42 <bennofs> johnw: notice the unevaluated _t16 in the :p x
08:47:42 <zipper> Waddup with that?
08:47:52 <bennofs> :t 2/0
08:47:52 <lambdabot> Fractional a => a
08:47:56 <zipper> Is it part of the fractional typeclass
08:48:01 <johnw> bennofs: try making X a newtype
08:48:04 <geekosaur> it's not actually a string, it's a special value for Float and Double
08:48:05 <merijn> zipper: No, Infinity is not a string
08:48:08 <triliyn> zipper: I think it's just a float that's printed specially
08:48:11 <bennofs> johnw: but are numbers are newtype?
08:48:13 <mm_freak> sm: if your redrawn area does not span to the vertical edges of the terminal, it has to send heavy escape codes just to switch to the next line
08:48:17 <johnw> ah, n/m
08:48:23 <geekosaur> unfortunately it does not have its own constructor so you can only generate it easily by doing e.g. 1/0
08:48:23 <triliyn> Similar to NaN
08:48:25 <merijn> zipper: Infinity is a special float value, like NaN
08:48:39 <bennofs> johnw: and is () a newtype? :i () shows it as data () = ()
08:48:42 <zipper> merijn: Shock on me
08:49:00 <mm_freak> sm: at some point you will gain better speed by sending the escapes yourself using termcap/terminfo, but it's so much effort that you may want to just go with the slower rendering =)
08:49:09 <merijn> zipper: See the IEEE754 floating point spec, which describes these things
08:49:11 <geekosaur> zipper: ieee754 is deeply annoying
08:49:28 <johnw> bennofs: no, forget the newtype comment
08:49:29 <merijn> geekosaur: I would say deeply non-intuitive, not necessarily annoying
08:49:32 <sm> I was redrawing the whole terminal. But who knows, things might have improved since
08:49:33 <ski> Kron : makes any sense ?
08:49:40 <johnw> I'm not sure why () is shown differently
08:49:46 <merijn> geekosaur: They put a lot of thought into allowing you to reason about precision, etc.
08:50:08 <merijn> But yes, if you want fixed/arbitrary precision then it'll be really annoying
08:50:38 <bennofs> johnw: also happens for Int and Char, but not for lists
08:51:10 <mm_freak> sm: you can also teach vty scrolling =)
08:51:19 <ski> bennofs : can't be a `newtype', since the constructor doesn't take an argument
08:51:25 <geekosaur> sm: not really, mm_freak is actually correct about graphics being faster if you're scrolling regions that don't span the entire width or etc. terminals really are rather slow
08:51:53 <geekosaur> I dont recall if ansi x3.64 has an extension for non-fullwidth scrolling
08:52:12 <mm_freak> terminals are actually fast at scrolling, but they want you to scroll explicitly
08:52:14 <mm_freak> vty doesn't scroll
08:52:20 <mm_freak> that's the problem
08:52:27 <mm_freak> it actually redraws the area
08:52:51 <merijn> mm_freak: If you're making a terminal UI how often does your UI actually scroll full screen?
08:53:04 <geekosaur> well, no, they're only fast at scrolling under limited conditions
08:53:13 * geekosaur has been there, too many times
08:53:22 <Kron> ski: ish!
08:53:32 <mm_freak> merijn: when you're scrolling through a list in a file selection dialog, or when you're scrolling through text in a 'less'-like program
08:53:39 <mm_freak> merijn: in fact you scroll a lot in many applications
08:53:46 <geekosaur> sure, that's full screen and full width scrolling
08:53:50 <geekosaur> it's about the only optimized case
08:53:57 <mm_freak> yeah
08:54:09 <zipper> merijn: It says that I have to sign in or purchase to read the IEEE754-2008 standard?
08:54:11 <geekosaur> full height that is mot full screen
08:54:21 <zipper> What has the world become?
08:54:25 <merijn> mm_freak: I'm not saying you don't scroll a lot, I'm saying how often will that UI be full screen
08:54:33 <mm_freak> you don't need full height…  you can do full-screen scrolling and then just redraw the destroyed parts
08:54:34 <geekosaur> zipper: you can find documentation of it lots of other places
08:54:37 <mm_freak> that's what irssi does
08:54:39 <johnw> zipper: soon you will haev to sacrifice a baby goat
08:54:56 <mm_freak> merijn: depends on the application
08:55:03 <geekosaur> standards orgs usually do charge for the official standard, but ieee754 is so pervasive that there are lots of free docs and free copies of older versions etc.
08:55:04 <merijn> zipper: Well, before reading the standard, I'd say read: http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
08:55:12 <sm> I'm still trying to recover the capabilities of 8-bit home computers. I want an easy api for manipulating the display via a memory-mapped character array
08:55:21 <mm_freak> i'm guessing that most terminal UI applications have one large text area and some small one-line widgets at the top/bottom edges
08:55:27 <geekosaur> glwt
08:55:34 <zipper> geekosaur: The 2008 one seems rare. My serching skills can't retrieve it.
08:55:42 <merijn> mm_freak: I'd argue that if you do that then vty-ui is probably overkill for you anyway
08:55:52 <johnw> zipper: http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4610935
08:55:55 <merijn> mm_freak: vty-ui is much more useful for more complex UIs
08:56:12 <johnw> looks like it's USD 88
08:56:13 <mm_freak> merijn: not quite…  vty sucks for widgets with event handling and such
08:56:28 <geekosaur> sm: you lose then since 8-bit home computers actually wrote the codepoints to video memory, on a modern machine it's all got to be rendered to bits
08:56:40 <mm_freak> merijn: writing a simple text box at the bottom of the screen and a large box filling up the rest is a bunch of lines with vty-ui but pages of code with only vty
08:56:50 <sm> geekosaur: LA LA LA I still want it
08:56:57 <geekosaur> glwt
08:57:10 <sm> surely it's a simple matter of programming
08:57:10 <zipper> johnw: Yeah that's where I had to buy to read full text
08:57:23 <johnw> was it edifying?
08:57:24 <geekosaur> I don't think I've seen a terminal emulator that offers shm access to its text buffer
08:57:39 <mm_freak> merijn: i think pure vty should only be used if you're abusing the terminal for rendering graphics in disguise =)
08:58:24 <mm_freak> and then it's so slow that you probably want to use OpenGL in the end =)
09:08:01 <murgaan> Good day, new to this channel, very new to Haskell.
09:08:22 <Kaidelong> welcome murgaan
09:08:27 <murgaan> What's the best way to get help on a particular function?
09:08:37 <Kaidelong> you could try hoogle
09:08:44 <murgaan> similar to a man page.
09:08:45 <murgaan> ok
09:08:45 <Kaidelong> then follow the link to the haddock documentation
09:08:59 <mm_freak> murgaan: the haskell equivalent to man pages is the HTML documentation and hoogle
09:09:01 <Kaidelong> (a man like system for haskell would actually be a really good idea)
09:09:13 <Kaidelong> (IE in ghci:  man: f)
09:09:20 <Kaidelong> (:man f even)
09:09:20 <mm_freak> murgaan: but in most cases you will be asking for types, in which case GHCi is sufficient
09:10:13 <mm_freak> murgaan: if all else fails, you can ask here =)
09:10:38 <murgaan> mm_freak: Thanks!
09:10:57 <mm_freak> btw, i don't even use hoogle
09:11:35 <mangaba_leitosa> murgaan: i have this page opened in my browser all the time to consult the standard library functions: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
09:12:08 <mm_freak> me, too, except that i'm using a local version with additional libraries
09:12:33 <murgaan> does the lamdabot do hoogle?
09:12:56 <bennofs> @hoogle Int -> a -> [a]
09:12:57 <lambdabot> Prelude replicate :: Int -> a -> [a]
09:12:57 <lambdabot> Data.List replicate :: Int -> a -> [a]
09:12:57 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:12:59 <bennofs> it does
09:14:41 <quicksilver> although its hoogle DB doesn't always cover all the packages that the web hoogle indexes
09:19:25 <murgaan> lamdabot ?src product
09:20:03 <geekosaur> at least two errors there :) and the @src database is not very good
09:24:11 <bennofs> ?src product
09:24:11 <lambdabot> product = foldl (*) 1
09:24:35 <johnw> really, not foldl'?
09:25:24 <mm_freak> oh, cool…  there are OpenAL bindings =)
09:25:32 <geekosaur> bitrotted I think :/
09:25:49 <monochrom> in fact, GHC used to come with OpenAL bindings
09:26:49 <merijn> johnw: You made the rookie mistake of believing @src
09:26:54 <merijn> johnw: That's the report definition
09:26:59 <johnw> ah
09:27:08 <mm_freak> geekosaur: apparently the last update was in dec. 2013
09:27:20 <geekosaur> oh, finally fixed then
09:27:24 <geekosaur> (hopefully)
09:27:30 <mm_freak> so it looks fine…  the only problem is that it depends on OpenGL 2.9
09:27:36 <mm_freak> so it's not compatible with the haskell platform =/
09:28:08 <monochrom> yikes
09:28:20 <mm_freak> but i've already considered to ignore the haskell platform for OpenGL stuff
09:28:26 <mm_freak> i want OpenGL 4.x =)
09:29:21 <johnw> monochrom: do please accuse you of seeing everything in black and white?
09:29:26 <monochrom> for a headless computer, I modify a file in haskell platform source code to skip building opengl etc :)
09:29:44 <skypers> 18:23 < mm_freak> i want OpenGL 4.x =)
09:29:47 <geekosaur> they're talking about a server variant in the future. one can hope
09:29:52 <monochrom> um, monochrom includes 256 shades of grey, dude
09:29:55 <skypers> I have OpenGL 4.3 in my engine
09:29:58 <skypers> Haskell, of course
09:30:15 <skypers> mm_freak: https://github.com/skypers/OpenGLRaw
09:30:25 <monochrom> everything is in #000000, #010101, #020202, #030303... :)
09:30:28 <mm_freak> skypers: nothing wrong with that, but the HP only gives you haskell-OpenGL 2.8, which corresponds to OpenGL 3.2
09:30:36 <johnw> monochrom: doh!  you're a 50 shades of grey man
09:30:52 <skypers> mm_freak: I don’t like HP
09:31:24 <mm_freak> i could switch to OpenGLRaw, but the OpenGL interface is annoying enough =/
09:31:47 <skypers> mm_freak: that’s why I’m writing mine
09:32:04 <mm_freak> skypers: if at any point yours starts to look like GPipe, please tell me =)
09:32:23 <mm_freak> it's sad that GPipe isn't updated anymore
09:32:28 <skypers> GPipe ?
09:32:40 <mm_freak> skypers: http://hackage.haskell.org/package/GPipe
09:32:53 <mm_freak> it's to graphics what 'accelerate' is to computation
09:33:03 <magneticduck> I have this problem.
09:33:04 <magneticduck> http://ix.io/at4
09:33:05 <monochrom> 50 shades of grey ought to be enough on EGA monochrome monitors :)
09:33:13 <skypers> mm_freak: it’s very interesting
09:33:17 <magneticduck> what... does that tell me?
09:33:20 <skypers> how is performance?
09:33:21 <magneticduck> some sort of stack overflow?
09:33:28 <magneticduck> it's the output of a program
09:33:37 <Wizek> Question related to constructing beautiful APIs with Haskell: Is there a way to make a function that has some named arguments that are optional in addition to mandatory ones? Example: https://github.com/mikeal/request . Note that only what is absolutely necessary is needed: the url. For everything else reasonable defaults are assumed that may be changed by passing in an optional hash of options.
09:33:39 <magneticduck> making something with openGL, I seem have to encountered a small technical problem
09:33:41 <mm_freak> skypers: well, it depends on how good it compiles your shaders
09:34:12 <johnw> Wizek: I'd create an ADT to represent the argument, with the other ADT fields being Maybe
09:34:15 <mm_freak> skypers: since most of the work is done on the GPU it all depends on shaders
09:34:21 <magneticduck> the program in question takes forever to terminate, and gives me those two message
09:34:24 <magneticduck> any idea what could be happening?
09:34:30 <skypers> mm_freak: that’s awesome, what’s the low-level interface?
09:34:32 <skypers> cuda ?
09:34:33 <Twey> Wizek: I'd pass a record of options with a Data.Default.Default instance
09:34:37 <mm_freak> skypers: OpenGL
09:34:50 <johnw> Twey: or just make it a Monoid and so you have mempty
09:35:00 <johnw> but maybe Monoid wouldn't be possible...
09:35:04 <mm_freak> magneticduck: would be helpful, if you could paste source code
09:35:07 <Twey> Yeah, that's nice where appropriate.  ‘def’ is shorter, though.
09:35:09 <johnw> I prefer to define a defaultFoo function, than to make Foo an instance of Default
09:35:14 <skypers> mm_freak: ah…
09:35:22 <skypers> so it’s just an OpenGL wrapper?
09:35:27 <Twey> johnw: I guess you can always define a right- or left-biased monoid, but it seems like a bit of a hack
09:35:34 <johnw> Twey: true
09:35:47 <mm_freak> skypers: not quite…  it gives you a functional shader language and abstracts away all the low-level stuff like VBOs and FBOs
09:36:10 <Twey> Oh, hey, that's cool
09:36:33 <mm_freak> you still get framebuffers, but they become first class objects =)
09:36:34 <magneticduck> mm_freak: it's on github, I'll upload latest stuff and post the link
09:36:34 <skypers> mm_freak: hm, I really wonder whether it’s a good idea
09:36:46 <mm_freak> skypers: i think it's a great idea
09:36:46 <Wizek> johnw & Twey: Could you give me an example of Haskell libs that uses those techniques?
09:36:52 <skypers> in my engine I still have gl stuff
09:36:54 <magneticduck> https://github.com/MagneticDuck/PixelGame
09:37:00 <skypers> but I wrap them in more abstract stuff
09:37:05 <magneticduck> problem situation is in example/Main.hs
09:37:08 <skypers> but in the end
09:37:11 <skypers> it’s all about IO
09:37:17 <Twey> Wizek: Pandoc uses the record
09:37:19 <johnw> Wizek: http-conduit uses it for constructing Request objects, for example
09:37:30 <mm_freak> skypers: consider that OpenGL is really just a library for interacting with the rendering pipeline…  all GPipe does is to give you a functional interface to it
09:37:51 <skypers> mm_freak: yeah
09:37:54 <skypers> I also have htat
09:37:55 <skypers> that*
09:38:02 <skypers> like with* functions, and so on
09:38:05 <Twey> skypers: It's not really about IO at all (any more than computation on the CPU is)
09:38:20 <skypers> Twey: using VBOs requires IO
09:38:37 <magneticduck> my whole system freezes up even when I run the program with nice -n 19
09:38:40 <mm_freak> skypers: that's not the same, and with GPipe most of your functionality is pure
09:38:41 <magneticduck> huh?
09:38:47 <magneticduck> literally everything freezes up
09:38:51 <magneticduck> even the sound server
09:39:08 <Twey> skypers: And using pointers requires IO, so we can't have a functional language on von Neumann?  :þ
09:39:25 <skypers> Twey: ?
09:39:33 <Twey> Yes, there's impurity there somewhere, but there's no reason it can't be abstracted away
09:39:33 <skypers> sending stuff to GPU requires IO to me
09:39:41 <Twey> skypers: But not sending stuff to the CPU?
09:39:49 <mm_freak> skypers: yes, one IO action to send
09:39:57 <mm_freak> everything else is pure
09:40:00 <johnw> Twey: programs don't run except in IO
09:40:11 <skypers> yeah, that’s what I said
09:40:18 <magneticduck> lols
09:40:25 <magneticduck> yeah, I managed to get my program to send stuff to the CPU the other day
09:40:25 <Twey> For an entry point, sure
09:40:27 <magneticduck> IO sucks
09:40:42 <matheus23> ouhhhhhhh :D
09:40:50 <johnw> magneticduck: IO can both suck and blow, all effects are possible
09:40:55 <Twey> Ha
09:40:57 <mm_freak> skypers: the problem with OpenGL is that everything is impure…  you even have to use traditional allocation/freeing…  wrapping them up in a with*-style function helps, but doesn't make your coding style declarative
09:41:00 <magneticduck> and launch missles
09:41:05 <magneticduck> anyway, my question anybody?
09:41:09 <magneticduck> kind of strange
09:41:10 <skypers> mm_freak: I know
09:41:14 <geekosaur> @remember johnw IO can both suck and blow, all effects are possible
09:41:14 <lambdabot> I will never forget.
09:41:15 <skypers> my engine is based on that
09:41:22 <TallerGhostWalt> \msg NickServ identify lvacsg
09:41:25 <mm_freak> skypers: the whole point of GPipe is to make everything except the last "send" call declarative and functional
09:41:31 <TallerGhostWalt> \msg
09:41:32 <geekosaur> welp, there's a password to change
09:41:34 <Twey> TallerGhostWalt: Uhm.
09:41:37 <geekosaur> / not \
09:41:38 <TallerGhostWalt> 11:37 <geekosaur> welp, there's a password to change
09:41:40 <matheus23> TallerGhostWalt: /
09:41:42 <TallerGhostWalt> aaand greaat
09:41:43 <TallerGhostWalt> lol
09:41:44 <skypers> mm_freak: I’m not sure it’s a good idea
09:41:52 <mm_freak> skypers: why?
09:41:53 <Twey> Hope that wasn't a high-value password :þ
09:42:01 <johnw> haha
09:42:01 <skypers> because OpenGL maintains a context
09:42:04 <matheus23> TallerGhostWalt: *laughs*
09:42:12 <skypers> it’s meant to be impure in all way
09:42:40 * johnw now tries that password and user combination on every site on the Web
09:43:03 <mm_freak> skypers: what's wrong with abstracting that away?  we've done that already with memory management, threading, state handling…  that's what haskell is all about
09:43:07 <Twey> skypers: The OpenGL ‘context’ is not significantly different to the von Neumann ‘process memory’, and there's no real reason why they can't be abstracted over in the same way (though it's useful to have multiple OpenGL contexts sometimes)
09:43:13 <merijn> skypers: Next you'll tell me that all my OpenCL coding/acceleration is "supposed to be impure"
09:43:17 <TallerGhostWalt> Fun times
09:43:36 <skypers> hm
09:43:42 <merijn> skypers: Which is counterintuitive as there's purely functional languages that compile to OpenCL/CUDA
09:43:43 <TallerGhostWalt> oh well that is why it is best to use BS passwords on here
09:44:00 <merijn> TallerGhostWalt: Or just auto-identify on connection :p
09:44:11 <skypers> merijn: so hm
09:44:15 <TallerGhostWalt> off normal pc
09:44:17 <skypers> in order to render some vertices
09:44:22 <skypers> how would you do with gpipe?
09:44:36 <merijn> I dunno, I don't do graphics I just do GPGPU coding
09:44:37 <mm_freak> skypers: i mean, parallelism "is supposed to be impure" to many people…  apparently we didn't know that when creating parallel strategeies =)
09:44:38 <TallerGhostWalt> oooorrr not be a dummy and get \ and / mixed up!
09:44:55 <skypers> in a regular engine, you’d just use a vertex buffer, maybe some IBO as well, a shader program, some blending, and go
09:45:08 <mm_freak> skypers: and it works so badly that every haskell programmer ignores the builtin parallelism and interfaces with C pthreads =P
09:45:57 <merijn> mm_freak: To be fair, automatic parallelisation and strategies are far from a solved problem
09:45:58 <skypers> it’s interesting that abstraction
09:46:07 <skypers> I’ll try to orient my engine in that direction later
09:46:10 <skypers> for noç
09:46:14 <skypers> now*
09:46:24 <skypers> I just have a bunch of MonadIO functions
09:46:24 <mm_freak> merijn: of course
09:46:44 <merijn> mm_freak: Which is fine, because else I wouldn't be employed right now :p
09:46:45 <Twey> TallerGhostWalt: You can give Freenode your NickServ details on connection, by sending the server password accountname:password
09:47:01 <avpx> TallerGhostWalt: Oops. I've done that twice. Feels bad.
09:47:09 <TallerGhostWalt> Twey: Thx
09:47:27 <Twey> No problem
09:47:44 <mm_freak> skypers: that's fine…  but i'm pretty sure you won't change your engine later, because it will be a lot of work
09:47:49 <TallerGhostWalt> avpx: yeah it aint the best thing I have ever done!
09:48:06 <skypers> mm_freak: I don’t know
09:48:10 <skypers> if it’s worth it
09:48:13 <mm_freak> skypers: but when designing your next project, keep in mind that even high performance graphics can be handled functionally =)
09:48:28 <magneticduck> graphicssssssss
09:48:29 <skypers> mm_freak: this is quite new to me
09:48:35 <skypers> I don’t even thought about it
09:48:43 <skypers> haven’t*
09:48:43 <magneticduck> I prefer to make large pixels
09:48:44 <skypers> omg :D
09:48:51 <mm_freak> hehe
09:48:59 <TallerGhostWalt> mm_freak: are you saying all the built in parallelism in ghc is bad
09:48:59 <mm_freak> one large pixel
09:48:59 <TallerGhostWalt> ?
09:49:07 <skypers> the issue is that abstracting all of that is quite of hard imho
09:49:10 <magneticduck> or like 5000
09:49:13 <mm_freak> TallerGhostWalt: i'm saying the opposite
09:49:18 <skypers> I reason about buffers, vertex array object and so on
09:49:18 <magneticduck> you don't need any optimization for 5000
09:49:22 <mm_freak> TallerGhostWalt: read my message in context =)
09:49:24 <magneticduck> optimization / acceleration / stuff
09:49:47 <Twey> Can anyone recommend a nice image manipulation library — convolution, filters, interpolation, &c.?
09:50:00 <magneticduck> no
09:50:01 <magneticduck> uh, maybe
09:50:05 <magneticduck> why, do you want one?
09:50:17 <TallerGhostWalt> mm_freak: gotcha
09:50:25 <mm_freak> Twey: we have amazing libraries for loading and saving images, but for manipulation i'm afraid you're on your own right now =)
09:50:30 <mm_freak> Twey: but see comonads
09:50:33 <Twey> Aw.  Okay.  Thanks.
09:50:40 <Twey> Hm, yes, I guess it's a comonad
09:50:47 <mm_freak> the store comonad to be precise
09:50:57 <mm_freak> s/the store comonad/store comonads/
09:51:20 <skypers> mm_freak: seriously the idea is quite awesome finally
09:51:31 <skypers> abstracting in that direction could be neat
09:51:35 <skypers> I just wonder how
09:51:47 <mm_freak> skypers: it's a working project, if you get it to compile
09:51:49 <skypers> buffers can be used to do a _lot_ of stuff
09:51:58 <mm_freak> skypers: just look into GPipe
09:52:05 <skypers> I am
09:54:28 <skypers> so mm_freak
09:54:30 <skypers> in gpipe
09:54:42 <skypers> you just alter pure stuff
09:54:56 <skypers> and update them in a single function?
09:55:12 <skypers> it sounds pretty… woot
09:58:41 <mm_freak> skypers: pretty much
09:59:03 <mm_freak> it has some weaknesses, but the overall design is great
09:59:29 <skypers> what are such weaknesses?
10:01:03 <matheus23> how do I execute an IO action for each key-value pair of Data.Map.Lazy? Or, in other words: What's the mapM_ for Data.Map.Lazy?
10:01:37 <mm_freak> skypers: it doesn't handle dynamic scenes very well, because you rebuild the vertex arrays every time…  but i believe i can improve that (i'm not the author of GPipe)
10:01:39 <avpx> matheus23: You could use toList
10:01:52 <avpx> matheus23: mapM_ f . toList $ ...
10:02:00 <mm_freak> matheus23: Map is a Foldable
10:02:07 <mm_freak> import qualified Data.Foldable as F
10:02:09 <mm_freak> F.mapM_ …
10:02:11 <matheus23> mm_freak: so can I simply use mapM_?
10:02:12 <avpx> That works better
10:02:17 <skypers> I see mm_freak
10:02:19 <matheus23> okay
10:02:22 <matheus23> thanks
10:02:27 <mm_freak> oh, wait
10:02:34 <mm_freak> mapM_ doesn't give you the keys
10:02:42 <matheus23> oh yeah... right... I need them
10:02:56 <skypers> mapM_ f . zip [1..]
10:03:07 <mm_freak> matheus23: in that case toList may work best
10:03:23 <matheus23> hmmm... I'm doing that every frame for a game. I don't think it's too performant
10:03:36 <mm_freak> matheus23: it's fine
10:03:37 <matheus23> no, w8. I don't have to do that every frame, of course
10:03:44 <matheus23> well, thanks :)
10:03:46 <mm_freak> even if you do it every frame, it's fine
10:04:15 <mm_freak> if that becomes to slow, then you've simply chosen the wrong data structure =)
10:04:23 <mm_freak> too
10:06:01 <matheus23> mm_freak: sadly, It wasn't me who chose it :/
10:06:35 <matheus23> But I can convert it to the datastructure I want, of course
10:06:50 <mm_freak> Map is usually a good start
10:07:52 <supki> :t imapM_
10:07:53 <lambdabot> (Monad m, FoldableWithIndex i t) => (i -> a -> m b) -> t a -> m ()
10:09:31 <jophish> foo :: Num a => a; foo = (\x->x) 1
10:09:42 <ananthakumaran> can I build binary from Mac OS X 10.9 that can be run on Mac OS X 10.7 and above
10:09:57 <jophish> what is the type of (\x->x) here, is it (forall b. b->b) or (a->a)
10:10:57 <johnw> I think it would be: forall a. Num a => (a -> a)
10:11:45 <jophish> johnw: and that a is distinct from the a in the type signature for foo?
10:11:51 <jophish> because it's being quantified again
10:12:08 <johnw> no, I was referring to the a from the type signature
10:12:13 <jophish> ah ok
10:13:14 <Twey> jophish: It's a → a.  GHC won't infer higher-rank types
10:13:15 <jophish> johnw: how sure are you? foo = let i = (\x->x) in (i True, i 1)
10:13:27 <jophish> this typechecks
10:13:36 <johnw> not hugely sure
10:13:47 <skypers> mm_freak: I read about gpipe
10:13:55 <skypers> and I still think it’s not that great
10:14:29 <skypers> first, it abstracts over OpenGL 2.1, which is very specific
10:14:34 <Twey> jophish: If you give it a name and you have NoMonomorphismRestriction it will be given its principle type
10:14:40 <skypers> what happens when they decide to update to 3.1?
10:14:44 <skypers> or worse, 4.3?
10:14:44 <mm_freak> skypers: GPipe hasn't been updated since 2012
10:14:50 <mm_freak> skypers: which is why i'm not using it
10:14:54 <jophish> ah ok
10:14:59 <skypers> mm_freak: the github is quite active
10:15:02 <Twey> > (\ f → (f True, f 1)) (\ x → x)
10:15:03 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
10:15:03 <lambdabot>    arising from the literal `1'
10:15:03 <lambdabot>  Possible fix:
10:15:03 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
10:15:12 <mm_freak> skypers: it still has that awkward OpenGL 2.5 dependency
10:15:16 <mm_freak> even on github
10:15:22 <johnw> jophish: from testing, it seems to be (forall b. b->b)
10:15:33 <skypers> for now I prefer my way of doing things: abstracting, but still under IO
10:15:38 <Twey> jophish: If the monomorphism restriction is on then the let will fail, too, unless you give it an explicitly polymorphic type
10:15:54 <skypers> for instances in my engine I don’t expose buffers
10:15:59 <skypers> nor vertex arrays
10:16:06 <skypers> I expose a Geometry type
10:16:11 <mm_freak> skypers: i'm mainly interested in removing the border between shader land and haskell land
10:16:16 <skypers> that might be obtain from IO
10:16:24 <skypers> yes well
10:16:28 <skypers> it’s a great idea
10:16:32 <mm_freak> everything else is nice-to-have, but this is really a huge thing
10:16:55 <skypers> I think I’m going to borrow from gpipe for the shader stuff and from OpenGL for MVar
10:17:02 <skypers> or TVar
10:17:05 <mm_freak> i want to pass arguments to my shader and not bind values to uniforms
10:17:05 <skypers> or whatever it’s called
10:17:33 <Twey> jophish: Oh, I think I lied, that only applies to top-level definitions.  The let succeeds.
10:17:45 <mm_freak> it's just a different way of thinking…  everything in OpenGL shaders is very indirect, and that makes it painful to use
10:17:54 <johnw> Twey: LIAR!!!!
10:18:07 <Twey> ☹
10:19:27 <skypers> mm_freak: well I disagree with that
10:19:31 <skypers> I think shaders are lovely
10:19:34 <jfischoff> does ghc-mod work with sandboxes?
10:19:34 <skypers> they run on the GPU
10:19:39 <skypers> it’s not indirect
10:19:46 <ski> Twey : DMR only applies if there would be constraints
10:20:03 <ski> jophish ^
10:20:09 <mm_freak> skypers: it is indirect…  uniforms, attributes and varyings should be arguments and not global variables
10:20:17 <mm_freak> skypers: a shader should be /applied/ to them
10:20:30 <jophish> ski: can you elaborate a little on that, please
10:20:30 <mm_freak> rather than that you have to destructively update a mutable variable in OpenGL
10:20:34 <skypers> mm_freak: it is actually
10:20:49 <mm_freak> skypers: i mean /application/ in the literal sense
10:20:49 <mm_freak> f x
10:20:50 <skypers> in my engine, shaders are written in terms of uniforms
10:20:56 <skypers> yes mm_freak
10:21:06 * hackagebot elm-build-lib 0.0.1 - Elm compiler wrapper  http://hackage.haskell.org/package/elm-build-lib-0.0.1 (jeremondi)
10:21:12 <mm_freak> not:  setVariable myVar x >> callShader
10:21:17 <mm_freak> and then the shader does getVariable myVar
10:21:21 <ski> jophish : even with DMR, `i = \x -> x' will get a polmorphic type. however, `f = \x -> x+1' won't
10:21:24 <mm_freak> this is stupid and anything but functional
10:21:48 <jophish> ski: because the +1 adds a Num x constraint
10:21:51 <ski> yes
10:21:54 <skypers> mm_freak: yeah I see
10:21:59 <mm_freak> shader invocation should look like 'f x', and the shader itself should look like '\x -> …'
10:22:03 <mm_freak> that's what GPipe achieves
10:22:10 <ski> jophish : but `f x = x+1' will of course get (constrained) polymorphic type
10:22:21 <skypers> mm_freak: hm
10:22:29 <jophish> in that case I don't think that my typechecker is quite working
10:22:31 <skypers> what do you do for shared variables?
10:22:42 <aleksejs_> Hi, I forgot how to skip specific package when compiling with ghc
10:22:43 <mm_freak> skypers: what do you mean?
10:22:58 <skypers> mm_freak: you can have uniforms for both vertex or tessellation control shader
10:23:03 <skypers> they’re shared
10:23:15 <mm_freak> pass them to both
10:23:23 <skypers> vertex shader also has two types of inputs
10:23:26 <ski> jophish : DMR fires iff (a) there's no explicit type signature; and (b) there's no explicit arguments to the left of the `='; and (c) there would be constraints on the "top-level" of the inferred type
10:23:26 <pranz> is Data.Map a good idea if you want a twodimensional bounded array?
10:23:34 <skypers> uniforms and attributes
10:23:44 <mm_freak> skypers: in principle a vertex shader is just a function…  it takes uniforms and attributes and gives you vertex positions
10:23:52 <ski> jophish : you're writing a type checker for Haskell ?
10:23:59 <jophish> ski: yeah
10:24:10 <ski> any particular reason ?
10:24:13 <mm_freak> skypers: and just like that a fragment shader is also just a function:  it takes uniforms and varyings and returns a color
10:24:15 <skypers> mm_freak: no
10:24:15 <jophish> ski: well, for my own little language which is a subset of Haskell98
10:24:19 <skypers> a vertex shader is not a function
10:24:22 <skypers> it’s a program
10:24:27 <jophish> Haskell98 without recursion or recursive data types
10:24:28 <skypers> it runs for each vertex
10:24:32 <mm_freak> skypers: OpenGL calls it a "program"
10:24:32 <jophish> (except tail recursion)
10:24:37 <mm_freak> skypers: mathematically it's just a function
10:24:40 <ski> jophish : hm, interesting. why that subset ?
10:24:48 <mm_freak> skypers: there is no reason to go with the imperative world-view of OpenGL
10:24:49 <jophish> ski: I'm intending to compile it to glsl
10:24:54 <ski> which is ?
10:25:03 <skypers> that’s a point, indeed
10:25:04 <jophish> a C-like shading language
10:25:05 <ski> jophish : how about higher-order functions ?
10:25:21 <jophish> ski: sure, defunctionalization can take care of all of that
10:25:29 <ski> ok
10:25:32 <jophish> I'm planning Haskell -> LLVM IR -> GLSL
10:25:43 <jophish> I have a (nearly working) backend from LLVM to GLSL
10:27:40 <jophish> Just to make sure that I've got this correct: my typechecker interprets 'foo = (\x->x) 1' as (foo :: Integer) = (\(x::a)->(x::a)) 1
10:28:05 <jophish> for the lambda, there is no type sig for it, and there are no constraints
10:28:09 <jophish> so it should be typed (a->a)
10:30:53 <prophile> quick question: can ST be implemented in Haskell?
10:31:06 <prophile> or does it need Deep Magic despite the type safety?
10:31:12 <Cale> prophile: Yes and no.
10:31:49 <Cale> It can be implemented in terms of IO easily, but then if you want runST, you need unsafePerformIO
10:32:17 <prophile> well yes
10:32:24 <_1_Souvik2> hi
10:32:29 <johnw> Cale: couldn't you implement it with State and a Map?
10:32:39 <prophile> I was imagining without resorting to IO :)
10:32:45 <mornfall> johnw: that'd be really slow
10:32:52 <johnw> he didn't ask for speed
10:32:59 <mornfall> johnw: why use ST then?
10:33:07 <Cale> johnw: Well, what should the type of the elements of your Map be?
10:33:08 <johnw> again, that wasn't the question
10:33:16 <johnw> Cale: oh, that's right
10:33:39 <monochrom> to completely simulate ST, you need a magic that turns (Typeable a => a) to (a)
10:33:45 <prophile> johnw: I think it could work with Dynamic
10:33:55 <prophile> but then every variable would need to be Typeable
10:33:56 <Cale> prophile: see monochrom :)
10:33:57 <prophile> which isn't the interface of ST
10:33:58 <prophile> yeah
10:34:01 <Cale> right
10:34:11 <johnw> unsafeCoerce!
10:34:13 <Kaidelong> unsafeCoerce
10:34:34 <mornfall> really useful guys :P
10:34:53 <mornfall> next week, implementing a haskell compiler in brainfuck
10:34:57 <skypers> mm_freak: in my engine
10:34:58 <Cale> Yeah, you can use unsafeCoerce to do it of course, but that's just as bad as using unsafePerformIO
10:35:01 <prophile> what I'm actually asking is is there some kind of mystical existential types hackery that lets it work?
10:35:04 <skypers> uniforms are abstracted in renderers
10:36:10 <skypers> you still have to write the plain GLSL code
10:36:22 <skypers> but it’s simplier to use
10:37:28 <Cale> prophile: You might be able to use a trick like this: http://hackage.haskell.org/package/hetero-map-0.21/docs/HeteroMap-Map.html
10:38:08 * prophile reads
10:38:52 <zomg> I feel like such a child because homo and hetero always give me a chuckle...
10:38:53 <zomg> lol
10:41:52 <enthropy> http://hackage.haskell.org/package/vault seems to be a more popular one
10:43:53 <Cale> enthropy: Its newKey is in IO though
10:44:59 <Twey> There's an ST version too, but maybe that's begging the question
10:45:51 <Cale> http://hackage.haskell.org/package/hetero-map-0.21/docs/src/HeteroMap-Map.html#newKey -- as you can see here, no IO is required for this one at least
10:46:39 <rusk101> Im having trouble making a coprime functio that checks if an integer is coprime with a list of integers. coprime_with a [] = True .....coprime_with a (b:rest) = coprime _?_
10:47:38 <Cale> rusk101: coprimeWith a xs = all (coprime a) xs ?
10:47:40 <monochrom> if seems like you're trying to use recursion to avoid confronting the basic problem. you will fail.
10:48:15 <monochrom> the basic problem is: when you get down to single numbers a and b, determine whether a,b are coprime with each other.
10:48:46 <rusk101> I got the basic coprime a b = gcd a b == 1
10:49:28 <monochrom> ok, so why don't you include that in your coprime_with a (b:rest) = ?
10:50:45 <rusk101> @mono. and thats it? just coprime_with a (b:rest) = coprime a b
10:50:45 <lambdabot> Unknown command, try @list
10:50:57 <monochrom> of course not. I only said "include".
10:51:27 <rusk101> Could you explain what does (b:rest) mean?
10:51:55 <Cale> (b:rest) is a nonempty list whose first element is b and where the remainder of the list is called rest
10:52:01 <monochrom> interesting. you wrote it, then ask me what you wrote means?
10:53:06 <rusk101> So how would I keep moving down the list until its empty
10:53:24 <Cale> rusk101: Well, what are you actually trying to check, in English?
10:53:40 <ned> this is a long shot but i remember reading a blog about a month ago about someone using haskell to go from tex (i think at least, it might have been markdown or something similar) and some templates to various output formats (html, pdf, and such). does anyone know what this was?
10:53:42 <rusk101> If an integer is coprime with all the integers inside a list
10:53:50 <Cale> rusk101: That a is coprime to each of the elements of the list individually?
10:53:57 <rusk101> yes
10:54:14 <rusk101> For example coprimeWith 5 [1,2,3,4,6,7] = True
10:54:21 <Cale> ned: Pandoc
10:54:31 <Cale> rusk101: okay
10:54:46 <Cale> Do you know about map?
10:54:49 <monochrom> I would not think in terms of "how to move down until whatever". it is not useful.
10:55:17 <monochrom> I would think like this: "to check against 10 numbers, check again 1 number, then check again 9 numbers"
10:55:43 <monochrom> you already know how to "check against 1 number". it's called "gcd a b == 1"
10:55:46 <rusk101> I know ma yes
10:55:55 <rusk101> map*
10:56:05 <Cale> rusk101: So, consider what happens if you map (coprime 5) over the list
10:56:06 <monochrom> you already know how to "check against 9 numbers". it's called "coprime_with a rest"
10:56:14 <ned> Cale: hm similar but not the same. this featured a build system that was haskell based as well
10:56:24 <Cale> ned: shake?
10:56:53 <ned> Cale: yes! thanks.
10:56:53 <Cale> rusk101: You'll get a list of boolean values, expressing whether each element was coprime to 5
10:56:55 <rusk101> but coprime checks two integers
10:57:11 <Cale> @let coprime a b = gcd a b == 1
10:57:12 <lambdabot>  Defined.
10:57:22 <Cale> > map (coprime 5) [1,2,3,4,5,6,7,8,9,10]
10:57:24 <rusk101> it worked...
10:57:24 <lambdabot>  [True,True,True,True,False,True,True,True,True,False]
10:57:49 <rusk101> but I would need it to return eith True or False not a list of True or False
10:58:06 <Cale> Now we just need to know whether all of those were true, so we could use 'and':
10:58:10 <Cale> > and (map (coprime 5) [1,2,3,4,5,6,7,8,9,10])
10:58:12 <lambdabot>  False
10:58:16 <Cale> > and (map (coprime 5) [1,2,3,4,6,7,8,9])
10:58:17 <lambdabot>  True
10:58:41 <Cale> However, and . map p  has a name in the Prelude, it's called 'all'
10:58:51 <Cale> > all (coprime 5) [1,2,3,4,6,7,8,9]
10:58:52 <lambdabot>  True
10:58:59 <Cale> > all (coprime 5) [1,2,3,4,5,6,7,8,9,10]
10:59:00 <lambdabot>  False
11:00:01 <rusk101> cool cool cool. But why did the professor start out the algorithm as such coprimeWith a [] = True      comprimeWith a (b:rest) =
11:00:03 <Cale> rusk101: You might wonder how to write 'and', and for this we could use recursion directly, or use something like foldr
11:00:26 <rusk101> Yea, how would I use recursion directly
11:00:30 <Cale> Because you can always write things with recursion if you can't find a better way
11:01:08 <Cale> and [] = True
11:01:20 <Cale> and (x:xs) = x && and xs
11:01:55 <Cale> Here, we're using:
11:01:57 <rusk101> whats up with the and
11:02:16 <Cale> False && x = False
11:02:18 <Cale> True && x = x
11:03:40 <exicer> Has anyone used Scotty for anything ?
11:04:05 <exicer> I can't work out how to set a custom 404, which seems like it must be there somewhere.
11:04:11 <Cale> So, in the case where the list is nonempty,  and (x:xs)  will see whether x is False, if so, producing False as the overall result. If instead x is True, then the result of  and (x:xs)  is the same as the result of  and xs
11:06:41 <rusk101> I understand the logic behind it, but just cant put it into the correct syntax
11:07:17 <Cale> rusk101: What are you trying?
11:07:22 <monochrom> the syntax is "and (x:xs) = x && and xs", as shown
11:07:49 <skypers> hey, do you know a way to compos typeclasses kinds like (* ->  *) -> (* -> *) -> (* -> *) -> Constraint?
11:08:11 <skypers> I have to classes and I’d like to combine them to make another classes
11:08:14 <skypers> -s
11:08:20 <Cale> skypers: That would be the kind of a single typeclass with three type constructor parameters
11:08:22 <skypers> like combining MonadIO and MonadWriter
11:08:31 <skypers> yes it’s a morphism here
11:08:33 <skypers> not really a kind
11:08:41 <skypers> I just want to do something like
11:08:56 <skypers> MonadIOWriter = (MonadIO m, MonadWriter m) => m
11:09:07 <rusk101> where does the coprime function go in and (x:xs) = x && and xs? im sorry about all the newbie questions
11:09:07 <skypers> maybe with existential quantification?
11:10:02 <Cale> type MonadIOWriter m = (MonadIO m, MonadWriter m)
11:10:14 <Cale> rusk101: It doesn't
11:10:18 <skypers> with ConstraintKinds extension?
11:10:22 <Cale> skypers: yes
11:10:33 <skypers> that’s great
11:10:34 <skypers> btw
11:10:41 <skypers> should “type” be “alias”?
11:10:51 <skypers> it doesn’t make sense to call it “type”
11:10:57 <monochrom> I agree
11:11:07 <skypers> D has alias keyword
11:11:09 <skypers> I like it
11:11:41 <Cale> I actually think it could perhaps be better called ""
11:11:48 <monochrom> to make you happier, "data" in haskell is called "datatype" in sml
11:11:56 <Cale> (But there are various syntactic concerns about doing that)
11:12:15 <skypers> Cale: like a function definition?
11:12:18 <jophish> Is Mark P Jones ever here?
11:12:18 <Cale> yes
11:12:19 <skypers> it’d be confusing
11:12:36 <skypers> type / classes are not expressions
11:12:44 <Cale> skypers: Well, you might be right about that in the current Haskell :)
11:13:11 <skypers> :)
11:13:20 <Cale> skypers: they're not values, but there certainly are type expressions
11:14:06 <Cale> rusk101: So, do you understand the program that I'm suggesting?
11:14:29 <Cale> rusk101: If you want, I can put it on lpaste so that you can see it all at once
11:14:43 <rusk101> Yes please. But Im most like not going to use it
11:14:53 <rusk101> I want to write it how my teacher wanted it
11:15:05 <rusk101> But I'd be happy to see how you are thinking
11:18:08 <rusk101> I know i have to use && somewhere in there
11:20:07 <Cale> rusk101: http://lpaste.net/99833
11:20:52 <Kron_> hmmmm
11:21:07 <Kron_> what's the fastest, neatest way to calculate "ceiling (logBase 2 x)"
11:21:08 <Kron_> for some x
11:21:18 <Kron_> casting to a double and then back to an int
11:21:19 <Kron_> seems not nice
11:21:26 <Kron_> (where x is an Int)
11:22:51 <Cale> You could import this and use it http://hackage.haskell.org/package/arithmoi-0.4.0.3/docs/Math-NumberTheory-Logarithms.html
11:23:41 <Twey> Cale: What syntactic concerns?
11:23:52 <Cale> Twey: It looks like a pattern binding :)
11:23:58 <Twey> Oh, right.
11:25:23 <rusk101> Very cool. Thank you Cale!
11:25:50 <Fristi> Hello there, I am running a haskell project which relies heavily on time based stuff. Using the package "time" atm.. are there any supplementary packages who ease writing stuff like date comparisions like "currentHour > 03:00".. feels abit itchy to convert UTCTime to a string and compare it that way :)
11:25:52 <SrPx> Does GHC use supercombinators or graph reduction?
11:26:31 <Cale> Fristi: why are you converting to a String?
11:26:44 <Twey> Fristi: What's wrong with just comparing?
11:27:54 <Fristi> Cale: not converting anything to a string atm..
11:29:01 <Fristi> Cale: there is nothing wrong with comparing.. dont get me wrong.. i can't find any method which looks like this 'hour :: UTCTime -> Int'
11:29:02 <jrmithdobbs> what does this even mean
11:29:05 <jrmithdobbs> "<interactive>: internal error: ARR_WORDS object entered!
11:29:19 <Cale> jrmithdobbs: Something went very very wrong
11:29:26 <jrmithdobbs> Cale: right I understand that but what
11:29:29 <Cale> jrmithdobbs: are you using unsafePerformIO at all?
11:29:31 <monochrom> UTCTime is an Ord instance. do you know that?
11:29:41 <Cale> jrmithdobbs: Or unsafeCoerce?
11:29:41 <jrmithdobbs> Cale: i'd have to dig but not afaik
11:29:54 <jrmithdobbs> :t foldMapBy
11:29:54 <lambdabot>     Not in scope: `foldMapBy'
11:29:54 <lambdabot>     Perhaps you meant one of these:
11:29:54 <lambdabot>       `foldMap' (imported from Data.Foldable),
11:30:09 <Twey> Fristi: Also, if you convert it to a LocalTime there's a todHour
11:30:10 <Fristi> monochrom: I know :) but i want to get the hour of the 'timestamp'.. UTCTime is a unix timestamp undernearth i believe
11:30:34 <Fristi> Twey: let me see! sounds good :)
11:30:54 <monochrom> I don't care about beliefs. let me see what the doc says for real. not beliefs.
11:31:37 <Cale> monochrom: It's actually not a unix timestamp ;)
11:31:42 <rusk101> Is there a prelude functions that turns a list of integers into a list of every possible tuple made from those integers?
11:31:55 <Cale> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock.html#t:UTCTime
11:32:07 <monochrom> UTCTime has a field for date and a field for how many seconds since the beginning of the day.
11:32:17 <Cale> rusk101: There's Data.List.subsequences
11:32:25 <Cale> > subsequences [1..5]
11:32:26 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
11:32:56 <Cale> rusk101: Is that what you want?
11:33:07 <monochrom> the second field is most apt for comparing "current hour" against "3 o'clock", if you are willing to instead compare "current second" against "3*60*60"
11:33:11 <rusk101> i dont have it in my ghci
11:33:19 <Cale> It's in Data.List
11:33:26 <Cale> import Data.List
11:33:28 <jrmithdobbs> Cale: foldMapBy (\x y -> T.append x y) "" (\z -> case z of Right z' -> z'; Left z' -> z') :: Data.Foldable.Foldable t => t (Either T.Text T.Text) -> T.Text
11:33:41 <skypers> :t subsequences
11:33:42 <lambdabot> [a] -> [[a]]
11:33:44 <jrmithdobbs> Cale: is exactly what i did in ghci to cause it except actually passing it an arg instead of :t
11:33:47 <skypers> sounds like inits
11:33:52 <monochrom> the second field is DiffTime, which is also an Ord instance. and Num instance. so that "3*60*60" makes sense too.
11:34:09 <Fristi> monochrom: ah i see :) nice
11:34:09 <skypers> > inits [1..5]
11:34:10 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
11:34:11 <Cale> jrmithdobbs: Where is foldMapBy defined?
11:34:17 <monochrom> beliefs are for religious channels.
11:34:26 <skypers> oh subsequences is combinatory?
11:34:26 <rusk101> No. thats not what I was looking for. Now how to I export data.list
11:34:28 <monochrom> or part of Civ V
11:34:28 <jrmithdobbs> Cale: Control.Lens.Fold
11:34:49 <jrmithdobbs> Cale: it's foldMapBy f z g = reifFold f z (foldMap (M #. g))
11:34:50 <Cale> jrmithdobbs: and T is Data.Text?
11:34:56 <jrmithdobbs> Cale: yes
11:34:59 <Cale> I just get a type error from that expression.
11:35:03 <jrmithdobbs> err reifyFold
11:35:27 <Fristi> monochrom: btw .. https://hackage.haskell.org/package/time-1.4.0.1/docs/src/Data-Time-Clock.html#getCurrentTime uses posix unixtimestamp to create a UTCTime.. not exactly a unix timestamp.. but created from it ;)
11:35:37 <Cale> oh, you also have generalised string literals...
11:35:54 <jrmithdobbs> yes overloadedstrings is turned on
11:36:05 <jrmithdobbs> you can change the "" to T.empty
11:36:21 <Cale> okay, still a type error
11:36:33 <Cale> No instance for (Foldable t0) arising from an expression type signature The type variable `t0' is ambiguous
11:36:35 <rusk101> I'm trying to expand the compareWith function to a pairwiseCoprime [Integer]->Bool
11:36:41 <nadirs> hello
11:36:52 <Cale> jrmithdobbs: Which version of GHC?
11:37:18 <skypers> >
11:37:21 <jrmithdobbs> Cale: 7.8 ...  7.7.20140204
11:37:26 <monochrom> I don't think it matters whether inside the blackbox there are unix clocks, windows clocks, or tooth fairies.
11:37:26 <skypers> > let a = [1..5] in (\a -> flip (:) [a]) <$> a <*> a
11:37:28 <lambdabot>  [[1,1],[2,1],[3,1],[4,1],[5,1],[1,2],[2,2],[3,2],[4,2],[5,2],[1,3],[2,3],[3,...
11:37:36 <Cale> rusk101: okay
11:37:59 <Cale> > [(x,y) | x <- [1..5], y <- [6..10]]
11:38:00 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
11:38:39 <Cale> rusk101: You could use a list comprehension like that
11:38:44 <monochrom> if an android phone uses caesium atoms to get you that UTCTime value, you still have a UTCTime value in your hand, not caesium atoms.
11:38:48 <nadirs> I don't understand why GHC complains when I make an instance for a type synonym with TypeSynonymInstances enabled (it allows me to do it if I use FlexibleInstances)
11:38:57 <rusk101> cool cool cool
11:39:03 <Cale> jrmithdobbs: Maybe there's some type checker bug
11:39:13 <piezoid> hi
11:39:19 <piezoid> is it possible to make 'Foldable f => f a -> f b -> f (a, b)' without building an intermediate list ?
11:40:34 <Cale> piezoid: Is it possible to make one *with* building an intermediate list?
11:41:09 <piezoid> oh i mean 'Foldable f => f a -> f b -> (a -> b -> c -> c) -> c'
11:41:11 <Cale> (I don't know which function you're looking for)
11:41:23 <piezoid> zipFoldable
11:41:49 <johnw> :t  \x y -> (,) <$> x <*> y
11:41:50 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
11:42:29 <Cale> ^^ Likely not the function you want :)
11:43:13 <piezoid> mm ok, i'm not sure i get Applicative for my type...
11:43:45 <griffins> so is the problem with computers that we design the hardware first and then the programminglanguages? maybe we should design them together. what type of hardware would make it easier to write correct programs(i.e. what hardware fits better for functional languages?)?
11:43:54 <Cale> I don't think zip is particularly easy to express in terms of foldable
11:44:11 <Cale> griffins: You might be interested in the Reduceron
11:44:18 * ski recalls expressing `zipWith' in terms of `foldr'
11:44:23 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
11:44:49 <monochrom> I think it cuts to the mustard to acknowledge that the problem is that computers are designed by humans.
11:44:59 <Cale> griffins: http://vimeo.com/15832032
11:45:31 <ski> however, i don't think it will work with `Foldable', since that looses the nesting structure, as well as any additional annotating information
11:45:36 <Cale> griffins: But the whole point of compilers is that it ought not to matter too much what the processor is like.
11:46:06 <ski> (erm, s/looses/loses/)
11:46:06 <Cale> (But certainly one could make the compiler writer's life easier by altering the hardware)
11:46:15 * hackagebot zeromq4-haskell 0.3 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.3 (ToralfWittner)
11:46:17 * hackagebot zeromq3-haskell 0.5.2 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.5.2 (ToralfWittner)
11:46:42 <ski> nadirs : what is the type synonym definition ?
11:46:45 <piezoid> ski: yes, that's why i only want to make a foldr over pairs : 'Foldable f => f a -> f b -> ((a, b) -> c -> c) -> c'
11:46:45 <schell> is anyone working on an OpenGL backend for diagrams?
11:47:25 <byorgey> schell: yes, bergey is
11:47:31 <Cale> piezoid: surely you'll need at least one more value of type c there :)
11:47:32 <Fristi> monochrom: you are right about that :) intresting though to see how the time lib is built
11:47:46 <byorgey> schell: I'm sure he would welcome help
11:47:48 <bergey> schell: hi
11:47:54 <piezoid> Cale: you're right.
11:48:02 <schell> byorgey, bergey: ah - cool, i'll...hi
11:48:04 <bergey> Yes, I certainly would
11:48:49 <schell> bergey: cool - i'll check it out and see if i can help
11:49:02 <byorgey> schell: also, feel free to join #diagrams
11:49:04 <haasn> byorgey and bergey! I think my eyes are spinning
11:49:23 <ski> piezoid : well, if you use it on `Node a0 [Node a1 [Node a2 []],Node a3 []]' and `Node b0 [Node b1 [],Node b2 [Node b3 []]]', do you want an error, or should perhaps `a2' be combined with one of `b1',`b2' or `b3' ?
11:49:29 <byorgey> haasn: we get that a lot.
11:49:41 <schell> i have a project that is doing (rudimentary) path stroke/fill stuff and then realized it may be better spending my time helping out with diagrams
11:49:55 <byorgey> schell: ah, cool
11:50:15 <rusk101> Ok so I was able to make that list of tuples. Now how do I go into each and every one of those tuples and check if they are coprime integers in there
11:50:35 <byorgey> schell: I think Vince_Juicy is working on something similar
11:50:54 <piezoid> ski: i guess, i want a partial function
11:50:54 <ski> @type all  -- rusk101 ?
11:50:55 <lambdabot> (a -> Bool) -> [a] -> Bool
11:51:16 * hackagebot rainbow 0.6.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.6.0.0 (OmariNorman)
11:51:33 <piezoid> ski : my gloal is to factor trees using a fold interface
11:52:05 <haasn> I would certainly be extremely interested in an OpenGL backend for diagrams (also one based on a popular raytracer), but I'm not sure in which ways I could support (especially knowing nothing about OpenGL)
11:52:15 <Vince_Juicy> byorgey > yup I'm working on it, especially the font loading right now
11:52:20 <ski> piezoid : well, `Foldable' forgets the nesting structure, so probably will combine `a1' with `b1',`a2' with `b2' and `a3' with `b3' (depending on whether you use pre-order traversal or some other traversal order)
11:52:25 <byorgey> Vince_Juicy: cool!
11:52:29 <ski> piezoid : "factor" ?
11:52:31 <bergey> I think it would be good to get some low-level geometric algorithms like tesselation into diagrams, so OpenGL and JuicyPixels backends can share them.
11:53:01 <byorgey> bergey: sounds great
11:53:19 <Vince_Juicy> I wonder if the current state of the library is usable
11:53:29 <bergey> haasn: Are you thinking 3D?
11:53:37 <piezoid> ski : produce a common rooted tree with a hole and two subtree
11:53:42 <haasn> bergey: oops, yes; are you working on 2D?
11:53:44 <ski> rusk101 : alternatively `and', if you prefer using list comprehensions more
11:54:05 <ski> piezoid : i don't follow. elaborate ?
11:55:02 <bergey> The current OpenGL backend only does 2D.  There's a little 3D capability, mostly with the POVRay backend.
11:55:42 <byorgey> but there's nothing preventing the OpenGL backend from supporting 3D in the future, is there?
11:55:47 <bergey> As in, we can render spheres, but I haven't merged the code for boxes and cones yet.
11:55:59 <bergey> That's why I wrote it in the first place!
11:56:42 <bergey> The hard choice is how to represent geometry in 3D.  POVRay has higher-level primatives, which makes it a little easier.
11:57:59 <nadirs> ski: I'm working through byorgey's CIS194, the definition is `type Program = [StackExp]` where StackExp is a data type
11:58:32 <piezoid> ski: it's do a depth first search of both tree, and when it find a difference, it put a node with the two divergent subtrees
11:58:59 <dart> hi
11:59:45 <rusk101> let pairwiseCompare xs = all (coprime (x,y)) [(x,y) | x <- xs, y <- xs] What am I doing wrong here?
11:59:50 <ski> nadirs : ok, so saying `instance Blah Program' is then, by `TypeSynonymInstances' equivalent to saying `instance Blah [StackExp]'. however you'd still need `FlexibleInstances' to say the latter, and hence you also still need it for the former
11:59:51 <piezoid> but yes i think a Foldable interface can't do that...
12:00:03 <ski> lo dart
12:00:35 <nadirs> ski: but GHC is fine with just FlexibleInstances (i.e. without TypeSynonymInstances)
12:00:57 <nadirs> ski: I guess they embedded the latter into the former?
12:01:37 <nadirs> ski: anyway your answer clarifies quite few things :)
12:02:39 <ski> nadirs : possibly, not sure
12:03:05 <ski> rusk101 : replace `(coprime (x,y))' by `coprime' ?
12:03:29 <ski> (`x' and `y' aren't in scope outside that list comprehension, anyway)
12:03:55 <ski> rusk101 : if you prefer, you could say `(\(x,y) -> coprime (x,y))'
12:04:30 <ski> rusk101 : another (equivalent) way is to say `pairwiseCompare xs = and [coprime (x,y) | x <- xs, y <- xs]'
12:04:39 <rusk101> THERE
12:04:41 <rusk101> thanks ski
12:04:47 <ski> @type all
12:04:48 <lambdabot> (a -> Bool) -> [a] -> Bool
12:04:49 <ski> @type and
12:04:50 <lambdabot> [Bool] -> Bool
12:05:20 <ski> (also, `pairwiseCompare' isn't a good name here. better would be e.g. `pairwiseCoprime')
12:08:25 <rusk101> ski : its not working. let pairwiseCoprime xs = and [coprime x y | x <- xs, y <- xs]
12:08:56 <ski> rusk101 : you said `coprime (x,y)' before, not `coprime x y'
12:09:09 <rusk101> but coprime passes 2 integers
12:09:32 <ski> `coprime (x,y)' is different from `coprime x y'
12:09:45 <ski> in the former, a pair `(x,y)' is passed to `coprime'
12:10:11 <ski> in the latter, `x' is passed to `coprime', and then `y' is passed to the resulting function that `coprime x' evaluates to
12:10:20 <rusk101> im using coprime a b = gcd a b == 1
12:10:50 <ski> then you shouldn't use `coprime (x,y)' here
12:10:55 <ski> @let coprime a b = gcd a b == 1
12:10:56 <lambdabot>  .L.hs:152:1: Warning:
12:10:56 <lambdabot>      Pattern match(es) are overlapped
12:10:56 <lambdabot>      In an equation for `coprime': coprime a b = ...
12:10:56 <lambdabot>  
12:10:56 <lambdabot>  <no location info>:
12:11:14 <ski> @let myCoprime a b = gcd a b == 1
12:11:15 <lambdabot>  Defined.
12:11:29 <ski> @let pairwiseCoprime xs = and [myCoprime x y | x <- xs, y <- xs]
12:11:31 <lambdabot>  Defined.
12:11:41 <ski> > pairwiseCoprime [1,2,3,5]
12:11:43 <lambdabot>  False
12:12:15 <rusk101> it should return a True
12:12:18 <ski> ok, so the problem now is that you're comparing every element of `xs' also with itself
12:12:25 <edwardk> Cale: re foldMapBy it looks like there is a bug in lens there regardless of the choice of monoi
12:12:38 <rusk101> ohhhhh
12:12:38 <edwardk> er monoid
12:12:46 <ski> a set of numbers is pairwise coprime if for each pair of *distinct* elements, they are coprime
12:13:01 <ski> so, you implemented not quite the right function
12:13:22 <Cale> edwardk: Well, in 7.6.3, I just get a type error from his code rather than a crash
12:13:50 <edwardk> Cale: in 7.6.3 witth lens 4 i get >>> foldMapBy (++) "" (\z -> case z of Right z' -> z'; Left z' -> z')  [Left "test1",Right "test2"]
12:13:51 <edwardk> "Segmentation fault: 11
12:14:13 <edwardk> with overloaded strings on i get the same error he was getting
12:14:16 <ski> rusk101 : can you see how to avoid comparing every element with itself ?
12:14:31 <edwardk> so it appears to be a legit but in lens or reflection
12:14:42 <rusk101> | x\=y
12:14:42 <Cale> same here, okay :)
12:14:42 <edwardk> bug
12:15:41 <rusk101> ski : its not working. let pairwiseCoprime xs = and [coprime x y | x <- xs, y <- xs | x/=y]
12:16:02 <ski> rusk101 : you didn't mean to use a second `|' there
12:16:06 <ski> (it means something else)
12:16:11 <bennofs> edwardk: where is foldMapBy from?
12:16:22 <edwardk> bennofs: it is in lens
12:16:41 <rusk101> Sweet
12:16:41 <edwardk> bennofs: it promotes your function an unit to a monoid and then calls foldMap with it
12:16:47 <edwardk> bennofs: er function and
12:16:49 <quchen> bennofs: Open the lens docs, click on index, Ctrl+F, foldMapBy :-)
12:16:51 <ski> rusk101 : btw, it might be nicer to use `tails' instead
12:17:00 <rusk101> how so?
12:17:06 <quchen> bennofs: You may have to click on "All" in the index for bigger packages.
12:17:27 <bennofs> Ah, I still had lens 3.10 :p
12:17:43 <edwardk> Cale: looks like rwbarton solved it
12:17:57 <edwardk> Cale: had a data where a newtype had to be
12:18:37 <Cale> cool
12:19:14 <quchen> rusk101: Your coprime function is symmetric, `coprime x y = coprime y x". The list comprehension checks both cases for all entries, but you only need one check. Using tails, you could do the check only once per pair (x,y).
12:20:15 <Eduard_Munteanu> What's a good filepath library these days? system-filepath isn't quite what I expect.
12:20:38 <rusk101> oh ok. could you provide the example
12:20:47 <quchen> The example?
12:22:27 <Eduard_Munteanu> I ended up wrapping FilePath in a more typeful wrapper, maybe I should release it at some point. Still, FilePath has rather odd behavior...
12:22:35 <bennofs> Is there a way to implement a "timeout" in pure code? I'd like to perform a calculation that optimizes something, but is able to return a non-optimal value in case a given time is exceeded. Currently, I'm putting a value in an IORef if it is better than then previous values and read that IORef when the time is over, but is there a pure way to do this?
12:22:54 <Eduard_Munteanu> head (splitDirectories "/foo/bar") == "/"  =  False   and stuff like that.
12:22:55 <johnw> in pure code?  no
12:23:24 <rusk101> let pairwiseCoprime xs = and [coprime x y | x <- xs, y <- tail [xs] , x/=y] ?
12:23:36 <bennofs> then maybe something less powerful than IO?
12:23:49 <Eduard_Munteanu> bennofs: you can run the computation on a separate thread purely and kill it when it times out.
12:23:53 <quchen> Use tails to split your xs into many sublists. Then check all those sublists for whether the first element is coprime to the rest.
12:23:53 <ski> rusk101 : no, `tails'. not `tail'
12:24:02 <ski> > tail "abcdefgh"
12:24:03 <lambdabot>  "bcdefgh"
12:24:06 <ski> > tails "abcdefgh"
12:24:07 <lambdabot>  ["abcdefgh","bcdefgh","cdefgh","defgh","efgh","fgh","gh","h",""]
12:24:33 <bennofs> Eduard_Munteanu: ok, but the computation needs to be able to produce incremental results, so it also needs to perform IO (write it's incremental result to an IORef)
12:24:45 <rusk101> let pairwiseCoprime xs = and [coprime x y | x <- tails [xs], y <- tails [xs] , x/=y] ?
12:25:12 <quchen> firstElementCoprime (x:xs) = all (coprime x) xs
12:25:14 <quchen> Something like that.
12:25:30 <ski> > [(x,y) | x <- "abc" , y <- "abc"]
12:25:31 <lambdabot>  [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c',...
12:25:33 <Eduard_Munteanu> bennofs: not sure why it has to do IO to produce incremental results. And if you're doing IO anyway then why bother keeping it out of IO? :)
12:25:44 <ski> > [(x,y) | x:ys <- tails "abc" , y <- ys]
12:25:45 <lambdabot>  [('a','b'),('a','c'),('b','c')]
12:25:52 <ski> > [(x,y) | x:ys <- tails "abcd" , y <- ys]
12:25:53 <lambdabot>  [('a','b'),('a','c'),('a','d'),('b','c'),('b','d'),('c','d')]
12:25:58 <ski> rusk101 : ok ?
12:26:08 <rusk101> ok. thanks
12:26:20 * hackagebot lens 4.0.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.3 (EdwardKmett)
12:26:35 <mm_freak> bennofs: i'd use a list for timing out…  let your algorithm produce intermediate results
12:26:53 <mm_freak> bennofs: then a separate function can take values from the list until either the last value is reached or a timeout is exceeded
12:26:55 <ski> rusk101 : this assumes that either your comparision is symmetric/commutative, or that you specifically only want to get the pair elements chosen in-order from the list
12:27:05 <mm_freak> that separate function gives you an IO action, but your actual calculation can remain pure
12:27:09 <quchen> bennofs: This might be related (speculations): http://hackage.haskell.org/package/speculation
12:27:29 <ski> rusk101 : is you need the reverse orderings of the pairs, you might use something like `select'
12:27:36 <ski> s/is you/if you/
12:27:39 <quchen> bennofs: specBy in particular might be what you're looking for
12:28:15 <mm_freak> bennofs: alternatively you can make "timeouts" pure by disconnecting them from actual clock time:  last (take 1000 xs)
12:28:32 <rusk101> I wouldn't need the x/=y anymore right
12:28:36 <quchen> Right.
12:28:38 <ski> right
12:28:51 <rusk101> cool cool cool
12:29:06 <Eduard_Munteanu> bennofs: you could also check out lambdabot/mueval's logic for timing computations out.
12:29:13 <quchen> And it'll cut the constants of your algorithm down a lot.
12:31:11 <bennofs> I think I could also make my optimizing function of the type f :: forall f. (Applicative f, Monad f) => (IncrementalResult -> f ()) -> Input -> f ()
12:31:37 <bennofs> That could be easier to work with than lists, because I'm doing a tree traversal
12:32:52 <mecossalados> hey
12:32:54 <mecossalados> metaleer
12:32:59 <mecossalados> i want to jizz on your face
12:33:05 <mecossalados> i want hot gooey strands of my jizz
12:33:13 <mecossalados> to come shooting out of my 7 inch hairy uncircumcized cock
12:33:20 <mecossalados> smacking you on your cheeks
12:33:23 <bitemyap1> @where ops
12:33:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:33:26 <mecossalados> and causing glistening balls of my semen
12:33:29 <mecossalados> to shine in your beard
12:33:29 --- mode: ChanServ set +o johnw
12:33:31 --- mode: ChanServ set +o dcoutts
12:33:35 --- mode: ChanServ set +o johnw
12:33:35 --- mode: johnw set +b *!uid25435@gateway/web/irccloud.com/x-ikdtytgcrbnnarytnil
12:33:35 --- kick: mecossalados was kicked by johnw (Kicked)
12:33:35 <Eduard_Munteanu> bennofs: if the result type is inductively-defined, you can consume it lazily, e.g. ferrying it over an MVar and forcing it
12:33:37 --- mode: johnw set -o johnw
12:33:40 --- mode: ChanServ set -o dcoutts
12:33:52 <bitemyap1> johnw: dcoutts danke
12:33:56 <dcoutts> johnw: ta, quick on the draw
12:34:06 <johnw> I saw the ops request in the corner of my eye
12:35:29 <bennofs> Eduard_Munteanu: ah, not, it's not inductive. I'm writing an AI for a game and need to determine the "best" move from my game tree, but I have a time constraint
12:35:47 * geekosaur heard notification beep but is knee deep in bugs
12:36:17 <mm_freak> bennofs: does your tree involve backtracking?
12:36:17 <jle`> hm. is there any reason why someone would use both liftM and fmap on the same line/function definition?
12:36:28 <Eduard_Munteanu> bennofs: oh, then you could try limiting the search depth
12:36:28 <mm_freak> jle`: yes
12:36:29 <johnw> jle`: not that I can think of
12:36:32 <ski> jle` : yes
12:36:41 <johnw> jle`: unless there were different constraint requirements
12:36:59 <mm_freak> jle`: Monad is not a subclass of Functor, so sometimes liftM is useful to avoid (Functor m, Monad m) constraints
12:37:10 <jophish> So, I have a big structure representing the Haskell syntax, this is parameterised over the type of terms (names, unique names, names with types)
12:37:13 <jle`> mm_freak: ah that makes sense.
12:37:19 <jle`> that looks like the case here.
12:37:22 <jophish> This is exactly how GHC does it
12:37:28 <ski> and it might be `(Functor f,Monad m)' (or `(Applicative i,Monad m)') that you want
12:37:39 <jle`> interesting that it would be you to answer it
12:37:43 <jophish> Often I find myself wanting to get all the names under a particular node
12:37:44 <jle`> given that it's your source code i was reading
12:37:46 <jle`> heh
12:37:54 <jophish> is this a good place to use deriving traversable?
12:38:13 <mm_freak> jle`: once the AMP makes it into the base library this problem will disappear =)
12:38:21 <mm_freak> then you would always use fmap
12:38:27 <jle`> hoorah!
12:38:46 <bennofs> Eduard_Munteanu: How do you mean? Just limiting the depth to a constant value doesn't work for my game, because the time needed to search to a given deep varies depending on the current game state. Also, I loose if I require too much time to generate a move
12:38:52 <quchen> liftM will stay so that you can define Functor in terms of Monad though, but that'll be the only application.
12:39:39 <quchen> (Not counting code obfuscation) ;-)
12:39:52 <cpa_> @pl \x -> (x `mod` y) == 0
12:39:52 <lambdabot> (0 ==) . (`mod` y)
12:39:57 <jrmithdobbs> bennofs: your optimization function looks suspicially like iterM from Control.Monad.Free.Church
12:40:22 <jrmithdobbs> bennofs: I don't know if that's a helpful observation ;p
12:44:04 <jle`> mm_freak: i've been playing around in my head with the idea of a turn-based game.  how much of what I learned from netwire will carry over to this new sodium/banana-type frp?  are there still parrows?
12:44:09 <jle`> s/parrows/arrows
12:48:28 <spaceships> I'm trying to get Karatsuba's multiplication algorithm to work. I can multiply two numbers of equal length correctly, but it gets wonky when they are differing lengths. Im not sure how to handle the splits - in the case that one number is 2 digits and the other is more than 2, should both be split at 1? http://lpaste.net/99835
12:59:30 <hakujin> I want to use parMap to map over an EitherT String IO monad transformer. can I just use sequence . parMap rseq instead of mapM? everything typechecks but I'm getting threadscope errors on windows and I'm not sure how else to check thread productivity
12:59:38 <madjestic> I am trying to enable profiling in cabal config, I am somewhat confused concerning the '--' prefix in front of listed options.  In the header of the file it sais that '--' are comments.  Shall I drop it, or keep it?
13:00:26 <jrmithdobbs> madjestic: huh? just --enable-library-profiling --enable-executable-profiling to the end of your cabal configure/install
13:00:42 <jrmithdobbs> madjestic: doesn't need to be in the cabal file
13:02:21 <madjestic> jrmithdobbs: I meant the ~/.cabal/config
13:02:51 <griffins> ty Cale for the reduceron.
13:02:58 <jrmithdobbs> madjestic: oh, look at the example it spits out, it takes the -- off the front
13:03:15 <madjestic> jmcarthur: so the line in .cabal/config should be -- bla bla: True   , correct?
13:03:35 <jrmithdobbs> no, that's a comment
13:04:02 <madjestic> jrmithdobbs: k, i.e. it should be:  blablaL True  then
13:04:28 <mm_freak> jle`: well, the coding style is very different
13:04:31 <madjestic> jrmithdobbs: thanks
13:04:55 <mm_freak> jle`: however, it's certainly a useful experience
13:06:04 <mm_freak> jle`: reactive-banana and sodium bring you very close to the bare essence of FRP
13:06:17 <griffins> Anyone here that is oriented in functional programming languages for embedded systems? I know about Atom and I found Hume but it does not seem to be maintained anymore. Atom is interesting but a DSL not a programming language. What more is there?
13:08:46 <jle`> mm_freak: best approach is just to start from scratch with tutorials and things then?
13:09:16 <mm_freak> jle`: likely yes…  if you're comfortable with reading type signatures you can also learn the API by reading haddocks
13:09:56 <jle`> hm. thanks
13:10:44 <jle`> also, i feel like i should have asked this a long time, but are there any large-ish scale open source games in AFRP/netwire besides ocharles's and that yampa tutorial from a decade back?
13:12:19 <jle`> > let swap = uncurry (flip (,)) in swap (1,2)
13:12:20 <lambdabot>  (2,1)
13:12:22 <jle`> heh
13:12:38 <jle`> tuples are weird :|
13:12:44 <mm_freak> jle`: none that i know of
13:12:58 <mm_freak> apparently someone wrote a 3D game engine for windows using netwire
13:13:05 <mm_freak> but i don't know what happened to that project
13:13:19 <mm_freak> and i guess it never became an actual game =)
13:13:24 <jle`> heh
13:13:39 <jle`> if i wrote some kind of game framework over ntewire then then would i be breaking new ground sorta?
13:14:00 <mm_freak> not entirely, but i really recommend not writing a "game engine"
13:14:03 <hakujin> anyone on thoughts for parMap?
13:14:13 <mm_freak> write a game and let the engine come out as a side effect
13:14:15 <jle`> i feel like every thing i am trying to tackle is stuff that i have never seen anywhere ><
13:14:20 <jle`> mm_freak: yeah, of course
13:15:05 <mm_freak> jle`: well, FRP has been around for a long time, but only now, almost two decades later, it starts making it into actual applications =)
13:15:16 <mm_freak> so don't be surprised to see many new things )
13:15:16 <mm_freak> =)
13:15:30 <jle`> but then again i feel like this with almost everyhting i do in Haskell
13:15:43 <jle`> and only months later find that someone did something similar in an obscure project and mentioned it later
13:15:59 <tomejaguar> Is System F typically considered to have type products <*,*>?
13:16:27 <mm_freak> hehe
13:18:14 <AngryBeers> metaleer
13:18:16 <AngryBeers> you will pay for it
13:18:21 <AngryBeers> i will jizz all over your face
13:18:22 <AngryBeers> my cock
13:18:23 <AngryBeers> your face
13:18:25 <AngryBeers> what a match
13:18:29 --- mode: ChanServ set +o johnw
13:18:29 <AngryBeers> such semen cum shots
13:18:32 --- mode: ChanServ set +o johnw
13:18:32 <AngryBeers> much jism
13:18:32 --- mode: johnw set +b *!~AngryBeer@200.79.251.68nil
13:18:32 --- kick: AngryBeers was kicked by johnw (Kicked)
13:18:55 <mm_freak> jle`: well, if you want to push haskell games, there are plenty of opportunities to help =)
13:19:42 <Yaniel> jle`: check #haskell-game?
13:19:54 <jle`> mm_freak: do you mean that you have something specific in mind, or that just doing what i'm doing will help?
13:20:04 <mm_freak> there are still open problems, but the FRP technology is already there…  i'm currently trying to solve, well, The OpenGL Problem =)
13:20:11 <mm_freak> jle`: both
13:20:17 <jle`> Yaniel: whoa, did not know that was there, thanks :)
13:20:41 <jle`> this feels like a life-changing moment
13:21:26 * hackagebot th-orphans 0.8.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.8.1 (MichaelSloan)
13:21:26 <mm_freak> basically i'm looking for modern GPipe and i'd appreciate any help
13:22:18 <jle`> mm_freak: GPipe is no good?
13:22:56 <mm_freak> jle`: it's horribly outdated, but i know that someone made it at least use haskell-OpenGL 2.8
13:23:13 <sykora_> Does anyone know an easy way/tool to visualize the .prof output of a program run with profiling? I've got a massive dump and I want the interesting stuff to jump out.
13:23:43 <mm_freak> jle`: the last official release was in 2012
13:25:04 <jle`> mm_freak: what are you trying at the moment?
13:28:03 <mm_freak> jle`: a new FRP library together with an OpenGL-based rendering engine
13:28:44 <mm_freak> the whole thing should evetually turn into a game
13:29:10 <jle`> what are you writing your engine over?
13:29:18 <mm_freak> what do you mean?
13:29:29 <[swift]_> do people generally find this idiom readable? foo = (bar .) . baz
13:29:33 <jle`> are you just using haskell-OpenGL
13:29:52 <jle`> or GLUT/SDL
13:29:53 <jle`> etc.
13:29:57 <mm_freak> [swift]_: i have trouble reading it after more than five years of haskell experience =)
13:30:05 <shachaf> [swift]_: No.
13:30:22 <[swift]_> hehe, i thought that might be the case
13:30:23 <mm_freak> jle`: SDL
13:30:36 <johnw> [swift]_: I'm used to reading it
13:30:42 <[swift]_> i had trouble understanding it when i first learned haskell. i recently realized that i understood it perfectly now, and was tempted to start using it =)
13:31:03 <jle`> i'm use dto reading it now that i have used it so much, but it just might be my own bad practices
13:31:10 <jle`> i wish there awas a better way to accomplish the same thing
13:31:21 <johnw> if you like it, use it, it all depends on how much you expect others to be reading or reviewing your code
13:31:28 <jle`> @pl \x y -> f (g x y)
13:31:28 <lambdabot> (f .) . g
13:31:35 <conal> [swift]_: have you seen semantic editor combinators? they give a more general idiom for that sort of thing that i find very readable and writable.
13:31:53 <johnw> [swift]_: the (.:) operator might be better
13:32:08 <[swift]_> conal: i tried to read a blog post about that back when i first started learning haskell but it was over my head. i might be able to tackle it now
13:32:10 <conal> [swift]_: e.g., (result.result) bar baz.
13:32:15 <mm_freak> foo x = bar x . baz
13:32:28 <mm_freak> if that's even the same thing
13:32:31 <ilmig> yeah, I've used to be surprised how often this tends to come up when using @pl
13:32:34 <avpx> [swift]_: edwardk's lens talk gives a brief introduction to semantic editor combinators if you're interested
13:32:37 <mm_freak> > ((f .) . g) x
13:32:38 <conal> [swift]_: sure. give it a try. it's a terrifically handy technique.
13:32:38 <[swift]_> johnw: hmm, that's interesting, i haven't seen .: before
13:32:38 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
13:32:38 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
13:32:38 <lambdabot>  from the context (GHC.Show.Show a,
13:32:38 <lambdabot>                    Debug.SimpleReflect.Expr.FromExpr c)
13:32:39 <lambdabot>    bound by the inferred type of
13:32:43 <mm_freak> > ((f .) . g) x y
13:32:44 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr b0)
13:32:44 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.g'
13:32:44 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c)
13:32:46 <lambdabot>    bound by the inferred type of
13:32:47 <johnw> [swift]_: it's in the 'composition' package
13:32:48 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr c => c
13:33:02 <mm_freak> please just use one point instead of zero or two =)
13:33:15 <[swift]_> avpx: that sounds interesting; i'll check it out!
13:33:36 <mm_freak> foo x = bar . baz x
13:33:40 <mm_freak> this is very readable, i think
13:33:51 <ion> Hear, hear
13:34:03 <ion> “(foo .) . bar” is always evil; i’m not a fan of “foo .: bar” either.
13:34:22 <johnw> ion: why is it evil?
13:34:36 <mm_freak> johnw: i just read it wrong
13:34:39 <jle`> i think i'd prefer foo x y = bar . bax x y .... my ees do not see the advantage of eliminating the single point
13:34:40 <johnw> ah
13:34:44 <shachaf> johnw: Any reason for +o?
13:34:47 <[swift]_> i sorta like the visual mnemonic of .: (though in fairness i just heard about it)
13:34:56 <johnw> i do get confused on (. foo) . bar vs. (foo .) . bar vs. foo . (. bar), etc.
13:35:01 <mm_freak> jle`: except that it's wrong =)
13:35:06 <ion> johnw: It’s pointlessness for the sake of pointlessness instead of for the sake of making the code *more* readable for us hoomans.
13:35:10 <johnw> shachaf: we had several spammers, so I was just waiting ready for the next one
13:35:11 <jle`> oh yeah heh
13:35:11 --- mode: johnw set -o johnw
13:35:24 <mm_freak> removing one point is fine, depending on the function
13:35:34 <jle`> bar (baz x y)
13:35:44 <mm_freak> if you have X -> Y -> Y, then removing one point is a good idea, because it looks like an indexed map
13:35:58 <mm_freak> if you have X -> Y -> Z, then it's probably best to keep both points
13:36:21 <jle`> eliiminating a point feels like it implies a meaningful partial application
13:36:27 <conal> [swift]_: i'd go with (result.result) foo bar, saying that you want to apply foo the the result of the result of bar. define result = (.). then extend with fmap, first, etc in place of some of the "result"s. that's the SEC style.
13:36:44 <mm_freak> jle`: it probably is
13:37:00 <mm_freak> chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n)
13:37:27 <mm_freak> it would be stupid to keep both points there or to remove both
13:37:35 <mm_freak> @pl \n -> takeWhile (not . null) . map (take n) . iterate (drop n)
13:37:35 <lambdabot> (takeWhile (not . null) .) . ap ((.) . map . take) (iterate . drop)
13:37:36 <[swift]_> conal: i'll read up on that. so many haskell techniques to learn!
13:37:38 <tomejaguar> .: makes a lot of sense, because what's going on morally is just currying and uncurrying
13:37:52 <conal> [swift]_: have fun!
13:38:05 <pantsman> instead of (foo .) . bar I use fmap foo . bar
13:38:06 <StillInSyros> hello
13:38:18 <jle`> hello StillInSyros
13:38:22 <StillInSyros> I am new to haskell and am looking for suggestions regarding a task
13:38:52 <jle`> go ahead and ask :)
13:38:56 <Twey> pantsman: I do that, too
13:39:01 <StillInSyros> I'd like to write a program that queries an online directory for the email adresses of people meeting a particular condition
13:39:22 <StillInSyros> what would be the best way to get started with that
13:39:40 <mm_freak> StillInSyros: first find an implementation of the network protocol you need
13:40:27 <ski> @where SEC
13:40:27 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:40:29 <Twey> StillInSyros: Well, you probably want libraries for querying that service; then you want to design a nice representation of your query.
13:40:30 <ski> [swift]_ ^
13:41:13 <[swift]_> hah! this was the very blog post i failed to understand a year ago =)
13:41:28 <levi> [swift]_ Does it make sense now? :)
13:41:36 <obiwahn> i guess i am not the right person to judge .. but what i do not understand that it is so hard to get lambdabot runinng. everytime i upgrade ghc or try to install it on a new system it is a world of pain. is it worth to commit time to haskell with respect to re-usability? when i wirte something i would expect that the code runs in 3 month or 5 years without much modification.
13:41:38 <StillInSyros> so the directory is exposed through a webpage
13:41:49 <StillInSyros> as in I can query from my browser
13:41:51 <Twey> StillInSyros: Then you'll be getting the query from the user somehow and probably showing them the results; that's a parsing problem and a UI problem, for which again good libraries exist
13:41:57 <[swift]_> levi: it looks much more comprehensible now =) back then i was finding the Haskell type system rather confusing
13:42:11 <Twey> obiwahn: lambdabot is kind of old and a bit crusty.
13:42:21 <mm_freak> [swift]_: you have received conflicting responses to whether that idiom is readable, and consider that using some advanced abstraction probably won't make it better =)
13:42:23 <Twey> Much older than five years, I think
13:42:24 <levi> It's a nice feeling, isn't it?  Of course, there's still plenty of things that look completely foreign to me.
13:42:40 <mm_freak> [swift]_: all of this really means:  if you do it, people will have trouble reading your code ;)
13:42:54 <mm_freak> so think twice before doing it just because it's cool
13:42:56 <StillInSyros> Twey: yeah
13:43:00 <Twey> [swift]_: But only some people, and nobody cares about them!
13:43:19 <StillInSyros> Twey: I guess I am asking for recommendations for the libraries
13:43:25 <StillInSyros> or maybe just for further reading
13:43:34 <StillInSyros> clearly I don't know much about what I'm doing
13:43:35 <[swift]_> hehe, i guess you have to know your audience when writing haskell code
13:43:36 <obiwahn> Twey: but i have just migrated form a 32bit vm to a 64bit and it is just not working like that .. even though it was working like 3 month ago ... all the libs it depends on seem to have changed
13:44:05 <obiwahn> not all but some
13:44:31 <obiwahn> is there something like a stable std/stl for haskell
13:44:43 <mm_freak> [swift]_: most notably yourself…  you may have to revisit your code in six months, and then you might regret doing it =)
13:44:59 <Twey> StillInSyros: For the Web stuff there's something called Shpider, which is supposed to be quite good.  Parsing is usually Parsec or maybe edwardk's trifecta; UI is probably going to be something like vty-ui (console) or threepenny-gui (Web) or Gtk2Hs (… GTK)
13:45:00 <obiwahn> maybe i am just missing some kind of flag for hackage
13:45:17 <obiwahn> cabal
13:45:30 <Twey> StillInSyros: If you want to be fancy about it you could probably tie everything together quite nicely with reactive-banana or some other FRP library
13:45:39 <[swift]_> mm_freak: very true. i've gotten a little too excited with golfing my haskell code in the past and paid the price later =)
13:45:48 <StillInSyros> Twey: Thanks! that sounds like a days worth of reading for me haha...
13:46:10 <Twey> StillInSyros: How you represent the query largely depends on what you want to do with it, but you'll probably want to write that part of the code yourself unless it's in a standard format like SQL or LDAP
13:46:30 <obiwahn> it is not that i am against development or a language that is alive but it seems to change a lot breaking things
13:47:07 <merijn> obiwahn: lambdabot has always been...rather brittle
13:47:11 <Twey> obiwahn: I don't think lambdabot breakage is to do with the language changing.  It just has rather complex and fragile dependencies.
13:47:14 <merijn> obiwahn: Where are you getting the source from?
13:47:41 <obiwahn> last time i tried the cabal sources
13:48:00 <obiwahn> it build somehow but i get terminated for easy expressions
13:48:01 <Twey> obiwahn: Anything written to Haskell98 will still compile with today's GHC; if you go off the standard you are, of course, on your own
13:48:19 <Twey> (not that I would recommend using Haskell98 today: Haskell2010 is quite stable too)
13:48:33 <mm_freak> [swift]_: this is such a simple case, and '\x -> f . g x' can be understood instantly…  i'd just write it that way
13:48:34 <merijn> Twey: Well, I guess you need to specify Haskell98 nowadays, no? I thought the current default was 2010
13:48:42 <Twey> merijn: Yeah
13:48:52 <geekosaur> the default is ghc, which is ahead of and somewhat different from both h98 and h2010
13:48:53 <Twey> (but you can do that in the .cabal with no changes to the code)
13:49:05 <geekosaur> but you can easily request those standards
13:49:15 <Twey> geekosaur: Hmm?  I thought GHC did Haskell2010 by default (plus pragmata)
13:49:16 <merijn> geekosaur: What's the difference other than lack of Show/Eq for Num?
13:49:32 <Twey> Oh, H2010 still has Show ⇒ Num?
13:49:36 <geekosaur> merijn, I think that's it as for h2010
13:49:50 <obiwahn> oh it crashed
13:49:54 <geekosaur> I thik we have other differences from the prelude in h98
13:50:13 <merijn> Twey: Pretty sure, yeah
13:50:14 <mm_freak> [swift]_: it's not the same feeling as tackling a super-clever abstraction, but it gives you the satisfaction of having written a fine piece of code that everybody can read, including yourself in six months =)
13:50:17 <geekosaur> (are exceptions part of the standard? I forget if we trip over catch or not)
13:50:18 <mm_freak> cleverness seldomly pays off in programming =)
13:50:27 <[swift]_> hehe, fair enough =)
13:50:29 <merijn> mm_freak: Speak for yourself :p
13:50:39 <geekosaur> "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it." --Brian Kernighan
13:50:41 <mm_freak> merijn: i'm totally not clever =)
13:50:48 <merijn> mm_freak: I am, unfortunately :p
13:51:11 <Twey> geekosaur: Exceptions are part of the standard, but there's some contention as to whether ‘error’ is an exception
13:51:11 <hc> geekosaur: twice as hard doesn't imply you need to be twice as smart
13:51:18 <mm_freak> merijn: i was "clever" when i designed the first version of netwire…  all later versions were about removing that "cleverness" =)
13:51:20 <hc> this is mainly a rhetorical statement
13:51:22 <merijn> But I like attempting the impossible via cleverness, I don't have the patience for sane code, as evidenced by my three half finished libraries lying around :>
13:51:29 * hackagebot purescript 0.3.14 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.14 (PhilFreeman)
13:51:32 <Twey> H98 says it isn't; H2010 might say it is, I'm not sure
13:52:13 <Twey> If your ‘clever’ code makes things harder, it's not clever at all, or you got stupider in the meantime :þ
13:52:23 <merijn> geekosaur: However, writing really hard code once so you can write really simple code everywhere else is clearly better than writing medium hard code everywhere
13:53:12 <geekosaur> actualy my own take on it is will you be able to understand it 6 months hence? if not, don't do it
13:55:00 <johnw> mm_freak: I have to agree that non-clever code is generally better code in the end
13:55:15 <johnw> I too recently went through a decleverization refactoring, to much gain
13:57:12 <levi> If you are going for practical, maintainable software, excess cleverness is definitely bad. But it is sometimes a fun exercise in toy programs, and occasionally you might come up with something worth the complexity.
13:58:50 <johnw> can't argue with that
13:59:10 <johnw> sometimes the concise cleverness that lens allows is just worth making your readers learn what it means
13:59:32 <skypers> woah
13:59:44 <skypers> I moved all my functions from transformers to typeclasses
13:59:50 <skypers> it’s far away better
14:00:05 <johnw> you mean, from ReaderT to MonadReader?
14:00:17 <skypers> instead of WriterT w IO, I use (MonadIO m, MonadWriter m) => m
14:00:23 <johnw> yep
14:00:23 <skypers> it’s SO convenient
14:00:29 <johnw> sometimes you can even go one better:
14:00:37 <skypers> now, I don’t even think of transformers!
14:00:45 <johnw> (MonadIO m, MonadWriter env m, HasFoo env) => m
14:01:07 <skypers> johnw: yeah, I also do that :)
14:01:14 <skypers> it’s really great
14:01:15 <johnw> that's my favorite edwardk trick of late
14:01:19 <ion> (klass m, IsMonadIO klass)
14:01:31 * hackagebot selenium-server 0.1.0.0 - Run the selenium standalone server for usage with webdriver  http://hackage.haskell.org/package/selenium-server-0.1.0.0 (JoelTaylor)
14:01:32 <skypers> the best thing about that:
14:01:38 <skypers> runWriter $ theFunction
14:01:46 <skypers> and it magically typechecks <3
14:01:54 <skypers> johnw: what’s the trick about that?
14:02:06 <johnw> oh, just that it allows  for more flexibility
14:02:13 <ion> UUO$
14:02:29 <skypers> well I might not understand that
14:03:34 <DMcGill> Hi, I'd like some feedback on the custom lenses I wrote: http://lpaste.net/99838 Is there a better formulation? Should "Getter GameState (Maybe UID)" be "Fold GameState UID" instead?
14:03:34 <levi> If your base can be other than IO, you can use MonadBase as well.
14:04:01 <skypers> levi: well
14:04:09 <skypers> I’m using MonadBaseControl right now
14:06:31 * hackagebot vinyl-gl 0.1.2 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.1.2 (AnthonyCowley)
14:09:25 <levi> DMcGill: Sorry, I'm not well-versed enough in lenscraft to offer suggestion.
14:11:32 <DMcGill> levi: np, thanks for looking
14:11:49 <tomejaguar> DMcGill: Maybe ask in #haskell-lens
14:11:56 <DMcGill> that's a good idea
14:22:49 <ion> dmcgill: selectedUID . folded is a Fold, i think.
14:23:29 <DMcGill> ah well that's simple enough
14:25:14 <ParahSailin> is hackage having problems or my brain?
14:25:45 <monochrom> usually, both have problems :)
14:26:14 <ion> Boolean or?
14:26:29 <eacameron1> can someone point me to a step-by-step explanation of how to derive the type of (.).(.)?
14:26:44 <ion> What do you mean by “deriving the type”?
14:26:48 <sipa> :t (.)
14:26:48 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:26:49 <maurer> Hey, does anyone know of a way to get the rest of the available input in a Get from the cereal package?
14:27:08 <maurer> I'm trying to retrofit a package that just takes a bytestring to parse to fit into an interface that is based on Get
14:27:15 <eacameron> I mean, given the type of (.), I can (with pen and paper) determine the type of (.).(.)
14:27:50 <prophile> maurer: looks like runGetState returns the remainder of the input
14:28:17 <ParahSailin> maurer: remaining >>= getBytes
14:28:56 <eacameron> ion: I'm trying to do it and I can't figure it out
14:29:13 <prophile> quick question for anyone familiar with kmettland: could Codensity have a MonadCont instance in general?
14:29:14 <maurer> prophile: runGetState requires that I already have the bytestring
14:29:27 <maurer> ParahSailin: Thanks
14:30:20 <shachaf> prophile: No.
14:30:23 <monochrom> @type (.)
14:30:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:30:51 <prophile> shachaf: why not?
14:31:09 <shachaf> prophile: Codensity (Const e) = Cont e, but in general you have that forall
14:31:34 * hackagebot full-text-search 0.2.0.0 - In-memory full text search engine  http://hackage.haskell.org/package/full-text-search-0.2.0.0 (DuncanCoutts)
14:31:36 <thebnq> playing with haskelldb and sqlite, how do i catch an exception from sqliteConnect?
14:31:42 <shachaf> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a works by taking an r value from one place and using it in another place.
14:32:02 <shachaf> But when everything is forall-ed you can't do that because you don't know that the rs are the same.
14:32:07 <merijn> thebnq: If you know which exception, take a look at Control.Exception
14:32:11 <prophile> I see
14:32:12 <prophile> thanks
14:33:28 <DMcGill> @pl g uid = (players . ix uid) f
14:33:28 <lambdabot> g = flip (players .) f . ix
14:33:33 <haasn> shachaf: apart from it being useless, could you do instance (f ~ Const e) => MonadCont (Codensity f) ?
14:33:36 <DMcGill> not worth it :/
14:34:20 <shachaf> haasn: Yes.
14:34:41 <shachaf> Or probably more generally instance Phantom f => MonadCont (Codensity f)
14:35:14 <shachaf> Maybe you can make it even more general. I don't know.
14:40:44 <thebnq> merijn: looking for if the table doesn't exist, not sure what error it is
14:41:37 <ion> eacameron: “(.) :: (b -> c) -> (a -> b) -> a -> c”. Let us make “f = (.); g = (.)” and think about “f . g”.
14:42:01 <ion> eacameron: “f :: (fb -> fc) -> ((fa -> fb) -> (fa -> fc))”
14:42:13 <ion> eacameron: “g :: (gb -> gc) -> ((ga -> gb) -> (ga -> gc))”
14:42:25 <eacameron> ion: fair enough
14:42:34 <ion> eacameron: If we apply (.) to f and g, we’ll get the following equations:
14:42:58 <ion> eacameron: From applying to f: “b = fb -> fc; c = (fa -> fb) -> (fa -> fc)”
14:43:19 <ion> eacameron: From applying to g: “a = gb -> gc; b = (ga -> gb) -> (ga -> gc)”
14:43:30 <eacameron> ion: so far so good
14:43:31 <ion> eacameron: Based on the two equations for “b”, what must fb and fc be?
14:43:35 <merijn> thebnq: Hopefully the sqlite bindings documentation mention possible exceptions
14:44:33 <eacameron> fb = (ga -> gb);   fc = (ga -> gc)   right?
14:44:48 <ion> eacameron: Right
14:45:43 <ion> eacameron: Substitute those values of fb and fc for the rest of the equations and you’ll see that “a -> c” ends up being the type of (.) . (.)
14:46:17 <monochrom> eacameron, ion: http://lpaste.net/99842
14:46:32 <eacameron> ion: let me try that; I like your nomencalature; my head was spinning with all the type variables
14:46:39 <ski> eacameron : in <http://tunes.org/~nef/logs/haskell/14.01.27>, i showed how to do it for `concat . concat'. perhaps that helps
14:48:28 <merijn> eacameron: I highly recommend grabbing a notebook and pen and explicitly doing substitution of types on paper until you get the hang of it
14:48:33 <eacameron> ion: your nomenclature is especially helpful
14:48:58 <merijn> eacameron: You'll notice that quickly a lot of the simple types you can do in your head. I still grab a piece of paper for complex ones, though. It's really helpful
14:51:15 <thebnq> aw, "Result signatures are no longer supported in pattern matches", from the sample code
14:52:37 <ion> @type (.) `asTypeIn` \dot -> dot ((.) :: (fb -> fc) -> (fa -> fb) -> (fa -> fc)) ((.) :: (gb -> gc) -> (ga -> gb) -> (ga -> gc))
14:52:37 <lambdabot> (((ga -> gb) -> ga -> gc) -> (fa -> ga -> gb) -> fa -> ga -> gc) -> ((gb -> gc) -> (ga -> gb) -> ga -> gc) -> (gb -> gc) -> (fa -> ga -> gb) -> fa -> ga -> gc
14:52:39 <eacameron> all: these are super helpful thank you. I have a feeling lambabot should just post one these links when someone (like me) asks... ;)
14:52:49 <DMcGill> @pl g x = (f x) x
14:52:49 <lambdabot> g = join f
14:52:49 <eacameron> and it's already done
14:53:36 <ski> thebnq : yeah, sucks :(
14:53:45 <ion> @type (.) ((.) :: (fb -> fc) -> (fa -> fb) -> (fa -> fc)) ((.) :: (gb -> gc) -> (ga -> gb) -> (ga -> gc))
14:53:46 <lambdabot> (gb -> gc) -> (fa -> ga -> gb) -> fa -> ga -> gc
15:19:22 <skypers> night
15:22:14 <jophish> Is there another name for (.) . (.)
15:22:24 <sipa> @pl (.).(.)
15:22:24 <lambdabot> (.) . (.)
15:22:36 <jophish> just what I tried
15:22:37 <simpson> jophish: Some people call it (.:)
15:22:53 <simpson> Be cautious with it; it's easy to confuse oneself.
15:23:06 <ion> Also: everyone who reads the code later.
15:23:08 <jophish> is that defined anywhere, hoogle hasn't heard of it
15:23:11 * ski introduced that practice
15:23:31 <ski> iirc, a few packages define it
15:23:33 <jophish> I recognise (f.).g as this
15:23:46 <jophish> I don't think that f .: g should be too different
15:23:54 <ion> (f .) . g is even more evil. :-P
15:24:03 <shachaf> You should use neither (f .) . g nor f .: g
15:24:07 <merijn> jophish: Boob operator?
15:24:09 <shachaf> Just write \x -> f . g x
15:24:27 <shachaf> hilarious
15:24:44 <merijn> That or "tiny-nosed face" operator
15:24:58 <jophish> merijn: I can't see the face
15:25:06 <jophish> and the navel is a little off target
15:25:16 <merijn> jophish: (.) <- eye with pupil
15:25:25 <merijn> jophish: Two eyes, dot in the middle as nose
15:25:31 <ion> ꙮ
15:25:46 <jophish> yeah, I guessed that, but I can't quite trick myself into seeing it
15:26:11 <jophish> it is a little bit like the golang mascot perhaps
15:36:12 <seanparsons> Is there any way to get a sandboxed cabal to ignore globally installed packages?
15:38:36 <seanparsons> I find myself having to reinstall packages that are already installed in the global package db pretty much every single time I create a new sandboxed build.
15:40:48 <Triclops256> Hello, all
15:41:07 <Triclops256> I'm wondering if anyone could help out a newbie haskell programmer and rip my program apart
15:41:13 <Triclops256> http://hastebin.com/xepefeyaxu.hs
15:41:52 <merijn> Triclops256: FYI lpaste.net will automatically run hlint on your program and print hints
15:42:07 <ion> triclops: The standard library provides signum which should be equal to sign.
15:42:09 <merijn> Triclops256: Like the fact that "(map toLower $ res)" is identical to just "(map toLower res)"
15:42:42 <Triclops256> merijn, ion, thanks!
15:42:54 <ion> triclops: “length foo > 0” is better done using pattern matching.
15:42:59 * ski can't see any Haskell code at <http://hastebin.com/xepefeyaxu.hs> :/
15:43:02 <merijn> Triclops256: "if (length guesses) > 0 then" <- this can be "if length guesses > 0 then"
15:43:18 <merijn> Triclops256: Similarly, "mapM_ (print)" is just "mapM_ print"
15:43:26 <Twey> Triclops256: sign is called signum
15:43:30 <ion> triclops: “if … then <IO action> else return ()” can be changed to a “when” call.
15:43:31 <Twey> :t signum
15:43:31 <lambdabot> Num a => a -> a
15:43:44 <Triclops256> merijn: As you can maybe tell, I've been a lisper for a few years :p
15:43:52 <ski> > signum (0 :+ 1)
15:43:53 <lambdabot>  0.0 :+ 1.0
15:43:55 <Triclops256> ion: when?
15:43:56 <Twey> Triclops256: readInt is redundant
15:44:06 <Twey> (you can just use read)
15:44:16 <merijn> Triclops256: It's a function
15:44:17 <merijn> :t when
15:44:18 <lambdabot> Monad m => Bool -> m () -> m ()
15:44:38 <merijn> Triclops256: if the Bool is True, it runs the action, else it just does "return ()"
15:44:41 <merijn> See also
15:44:41 <ion> triclops: It is better to use readLn than liftM read getLine.
15:44:43 <merijn> :t unless
15:44:44 <lambdabot> Monad m => Bool -> m () -> m ()
15:44:52 <monochrom> seanparsons: it is harmful to ignore global even if possible. base is there and irreplaceable.
15:45:03 <jophish> I have a tree data structure representing haskell source. I'd like to have a type class to extract all the variable names which are bound under a node. I did have class Binds a where binds :: a Name -> Set Name. I'd like to now have a class which can deal with things besides Name, class Binds a b where binds :: a b -> Set b
15:45:23 <jophish> I can get this to work with multiparametertypeclasses, however I'm having trouble writing the instance for list
15:45:33 <seanparsons> monochrom: That makes sense for base, but everything else is coming along for the ride as well.
15:45:43 <Twey> Triclops256: x ← return $ y is redundant: it's just let x = y
15:45:44 <ion> triclops: readLn will result in an immediate IO exception if read fails, liftM read getLine may result in a delayed exception in arbitrary code that just happens to evaluate the value later.
15:45:46 <jophish> previously I had instance Binds a => Binds [a] where binds = Set.unions . map binds
15:46:08 <Kristoffer> Anyone know any good introductions to really efficient pattern matching optimizating at a compiler level?
15:46:18 <Kristoffer> I know there are tons of papers out there but I'm lost on where to start
15:46:19 <merijn> Triclops256: Also, I'd sprinkle in some more blank lines for grouping
15:46:49 <seanparsons> monochrom: Would I be safe to assume that cabal sandboxes are just a bit crap and that I should investigate hsenv?
15:46:53 <merijn> Triclops256: You can have empty lines in do blocks and it can make the code less intimidating than uninterrupted blocks of code
15:47:01 <Kristoffer> Really, I'm just trying to explain to someone that yes, pattern matching is sort of like a giant conditional tree based on constructors, but it's more efficient than that
15:47:09 <monochrom> no, I don't think hsenv is any better
15:47:35 <monochrom> I do not, in fact, understand why you run into so many reinstalls and duplications
15:47:39 <jophish> ah, I've got it now
15:48:03 <Twey> kristof: Well, of course it is — it's a switch on a single tag, and you know exactly where that tag is going to be
15:48:08 <merijn> seanparsons: Also, have you tried just running "cabal install --only-dependencies" I think that should install sandbox specific version of everything?
15:48:33 <ion> triclops: This was mentioned already but i’d like to emphasize using hlint. Its suggestions tend to be very useful.
15:48:43 <kristof> Twey: what does that even mean
15:48:45 <kristof> Twey: Tagged types?
15:49:03 <kristof> Twey: But [] and [a] are going to have the same tag, aren't they?
15:49:14 <merijn> Triclops256: Oh, I have another good one
15:49:19 <Twey> kristof: Constructors are tagged — sum types are ‘tagged unions’
15:49:22 <kristof> Twey: same with x:y:[xs] and any other list
15:49:23 <Twey> kristof: No
15:49:25 <merijn> Triclops256: You can eliminate the "sign" entirely
15:49:35 <Twey> kristof: [] is an instance of the nil constructor, and it'll have a ‘nil’ tag
15:49:40 <merijn> Triclops256: Just use "compare" instead of "sign $ guess - target"
15:49:43 <merijn> :t compare
15:49:44 <Twey> kristof: [a] will have a ‘cons’ tag
15:49:44 <lambdabot> Ord a => a -> a -> Ordering
15:49:49 <seanparsons> monochrom: It's not duplications, it's stuff like libraries compiled without profiling globally causing builds that want profiling to blow up. Also those end up influencing the version of a library the dependency resolution actually uses, as it's looking in the global packages and finding one there.
15:49:52 <merijn> > compare 5 6
15:49:52 <lambdabot>  LT
15:49:53 <kristof> Twey: what about x:y:[xs] versus a simple [xs]
15:49:55 <merijn> > compare 6 6
15:49:56 <Twey> kristof: [a, b] and friends will require more than one comparison
15:49:56 <kristof> oh
15:49:56 <lambdabot>  EQ
15:49:57 <kristof> lol
15:50:01 <seanparsons> merijn: That's what I'm getting the errors from.
15:50:15 <kristof> Twey: That's a lot easier to think about, thank you
15:50:20 <monochrom> I see.
15:50:27 <merijn> Triclops256: Compare return LT, EQ or GT, instead of having to match 0, -1 and 1
15:50:40 <Triclops256> merijn: Ooh, that is good, thanks!
15:50:59 <Twey> kristof: No problem
15:51:04 <monochrom> In a correct GHC installation, libraries that come with GHC are all compiled with profiling.
15:51:23 <merijn> seanparsons: Linux?
15:51:36 <monochrom> the contrapositive: if you are looking at a library that comes with GHC but misses profiling, your GHC installation is incorrect.
15:51:44 <seanparsons> monochrom: These aren't part of the GHC installation these are libraries that are installed globally.
15:51:52 <seanparsons> merijn: Yup.
15:51:54 <kristof> Twey: can I query the tag of any datatype in GHCi?
15:52:00 <merijn> seanparsons: Ick
15:52:06 <monochrom> you did them yourself by hand?
15:52:10 <merijn> seanparsons: Installing globally is a Bad Idea (TM)
15:52:11 <kristof> > :t [a]
15:52:12 <lambdabot>  <hint>:1:1: parse error on input `:'
15:52:23 <FreeFull> `:t [a]
15:52:25 <Triclops256> http://hastebin.com/bujebaqima.hs
15:52:26 <FreeFull> :t [a]
15:52:27 <lambdabot> [Expr]
15:52:30 <FreeFull> Probably not what you wanted
15:52:34 <Triclops256> Okay, that's all  I can see so far
15:52:38 <kristof> FreeFull: probably not
15:52:39 <Triclops256> Anything else wrong
15:52:46 <Twey> kristof: If you mentally convert that into assembly, it should be obvious that a case (at least on the outermost constructor) means loading the tag into the appropriate register then performing a series of ‘jump if…’ instructions, whereas a tree of ifs will — at best — have to load the result of the condition into memory before each condition
15:52:53 <monochrom> I certainly do some myself by hand, too, but whenever I do, I make sure I also enable profiling and docs and shared-lib by hand, too
15:52:56 <seanparsons> monochrom: No, they were pulled in as dependencies of command line tools like happy for example.
15:53:18 <Twey> And at worst will suffer arbitrary nonlocality and suffer cache misses
15:53:38 <merijn> seanparsons: happy should come with GHC too...
15:53:40 <kristof> Twey: Ah, ok. Besides just the conversion to mere jumps, is there any other analysis done?
15:53:42 <Twey> kristof: Types don't have tags, constructors do
15:53:58 <kristof> Twey: I'm confused. constructors exist at runtime?
15:53:59 <Twey> The tags aren't guaranteed to be unique across data-types: there's no need for that
15:54:06 <merijn> kristof: Well, yes
15:54:08 <Twey> Yes, constructors exist at runtime, or you wouldn't be able to case
15:54:08 <ski> (data constructors, not type constructors)
15:54:09 <monochrom> ok, that doesn't make much difference. when you build happy by hand and mark it global, you should also enable profiling and docs and shared-libs etc etc
15:54:15 <merijn> kristof: How would you pattern match, otherwise?
15:54:32 <seanparsons> merijn: Not that I'm aware of it doesn't.
15:54:36 <kristof> merijn: I dunno, I guess that makes sense. But that's also an efficiency tradeoff, right?
15:54:55 <Twey> kristof: Not really
15:55:03 <merijn> kristof: Why?
15:55:05 <Triclops256|away> Thanks for all the help, guys
15:55:06 <kristof> Well, your list is now not just cons cells
15:55:07 <monochrom> yes, a correct GHC installation also comes with happy. if you don't have happy, you're looking at an incorrect GHC installation
15:55:10 <kristof> but cons cells and constructors
15:55:12 <seanparsons> merijn: I think you're thinking of haskell-platform.
15:55:20 <triliyn> All you need to know the constructor is the tag
15:55:21 <merijn> kristof: The constructor *is* the cons cell
15:55:21 <Twey> kristof: I mean, yes, you lose some bits to the tag, but the alternative is never knowing what you put into the data type, and therefore not being able to get it out again
15:55:23 <triliyn> Which is just an integer I think
15:55:29 <triliyn> (maybe smaller)
15:55:39 <monochrom> oops, sorry, nevermind, GHC doesn't come with happy.
15:55:40 <kristof> Twey: merijn: Ok, that makes sense.
15:55:46 <merijn> kristof: There is no cons cell other than the (:) constructor :)
15:55:46 <monochrom> I was thinking of haddock.
15:55:47 <dwcook> seanparsons, was that at monochrom?
15:55:51 <ski> you need some information distinguishing the different cases of an algebraic type (or disjoint/discriminated union / union / sum / variant type)
15:56:11 <dwcook> Because that was my thought – I didn't think GHC came with any Haskell packages
15:56:15 <seanparsons> dwcook: Ah sorry, yes it was, I was getting my conversation streams confused.
15:56:21 <Twey> kristof: So the question is more, ‘an efficiency trade-off compared to what?’  If you're happy with losing your data, then yes, there's no need to store a tag and you can get better performance by leaving it out.  Or you could just throw all your data into /dev/null and get infinite efficiency from then on.  :þ
15:56:24 <kristof> merijn: Well my mental model of a cons cell is just a small box with a value and a pointer to the next value
15:56:30 <triliyn> ski: hmmm, can't you recover that information from the tag?
15:56:32 <monochrom> well, at any rate, use my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
15:56:39 <triliyn> Or is that not efficient or not possible?
15:56:43 <merijn> kristof: Right, but that's pretty much what all constructors are :)
15:56:47 <ski> triliyn : yes, that's what the tag is for
15:56:53 <Twey> kristof: Note that this isn't a Haskell thing: if you want to be able to represent one of several types in, say, C, you have to do the same thing (explicitly)
15:57:02 <triliyn> ahh, okay
15:57:02 <ski> triliyn : other representations are possible, though
15:57:10 <triliyn> I thought you were contradicting <triliyn> All you need to know the constructor is the tag
15:57:37 <ion> @tell Triclops256 You might want to refactor the putStr/hFlush/readLn thing into a function.
15:57:37 <lambdabot> Consider it noted.
15:57:46 <kristof> merijn: well, to know that a pointer in a cell is an actual pointer, you'd need to know it's a cell to begin with. Or you'd just treat it like one in advance, I dunno
15:57:53 <monochrom> GHC comes with haddock, bytestring, containers, and some others
15:57:54 <kristof> merijn: ....I'm just confused, don't keep trying
15:57:54 <ski> Twey : well, depends :)
15:58:10 <kristof> merijn: I need to spend some more time in C and low level pointer mangling before I come back to this topic
15:58:14 <seanparsons> monochrom: That kinda solves half my problem, but I'd still like my builds to be a little bit more predictable when it comes to them ignoring the global packages.
15:58:24 <Twey> kristof: So you'll often see a pattern in C datatypes like: enum foo_type { BAR; BAZ; QUUX; }; struct foo { int foo_type; union { bar bar; baz baz; quux quux; } data; };
15:58:52 <levi> kristof: What Twey said is at the heart of most dynamic language interpreters.
15:58:58 <monochrom> I am not convinced that "ignore" is a solution.
15:59:02 <Twey> (if you'll pardon my terribly rusty C)
15:59:11 <kristof> Twey: ok
15:59:20 <ski> s/foo_type/foo_tag/,s/int foo_type/enum foo_tag foo_tag/
15:59:25 <monochrom> I am only convinced that either "install properly" or "don't install at all" is a solution.
15:59:30 <Twey> ski: Thanks ☺
16:00:11 <monochrom> if there is something you want ignored "because it was built wrong", well erase it. clearly.
16:00:28 <monochrom> why keep around something wrong just to be ignored?
16:00:48 <seanparsons> monochrom: Because it's depended on by something installed globally.
16:01:05 <monochrom> well that means those things were built wrong, too.
16:01:21 <seanparsons> No, it means they have different dependencies.
16:02:00 <monochrom> no, that's not what you said. you only said "did not have profiling". that's different.
16:02:15 <seanparsons> If I install happy and it pulls along library A at some version, then I'm forced to "reinstall" library A appropriately for each any every project that uses it.
16:02:32 <seanparsons> monochrom: I'm talking about _both_ of those things.
16:02:33 <monochrom> for two things that have conflicting dependencies, neither should be global. that's what sandboxing is for. end of story.
16:02:43 <Eduard_Munteanu> Are there fancier filepath libs around? I've had a good time using paths parametrised by relativeness, read-only / read-write access and such. system-filepath is annoying.
16:03:31 <Eduard_Munteanu> For instance it think it's a good idea a </> b = b when b is absolute.
16:03:40 <seanparsons> monochrom: That is what sandboxing is for, however cabal isn't doing that.
16:03:41 <monochrom> ok, I am no longer convinced that you express yourself correctly.
16:04:16 <seanparsons> monochrom: I'm convinced you're not listening.
16:05:15 <seanparsons> Reading the hsenv docs that explicitly states that the global environment wont affect the project, which is what cabal sandbox should do.
16:05:19 <levi> For sums with few cases, you could theoretically store the tag in low-order bits, since pointers must be word-aligned and so won't be using them. But those may be in use by the garbage collector or something anyway.
16:07:12 <ski> levi : Mercury does that
16:07:29 <levi> I think Ocaml does as well.
16:07:31 <ski> (i.e. the Melbourne Mercury Compiler, really)
16:08:11 <levi> Well, it uses the bits for *something* anyway, I don't remember if it's just for the gc or also for sum types.
16:08:46 <nart> how do i get as knowledgeable as you guys ? everytime i join this channel i don't know what you're talking about, i'm convinced i'll never fully graps haskell without some sort of tutor to help me.
16:09:18 * Eduard_Munteanu thinks interpreting slashes in paths is a bad idea
16:09:33 <bitemyapp> nart: https://gist.github.com/bitemyapp/8739525
16:09:41 <Eduard_Munteanu> It should just be a list of bytestrings.
16:09:44 <johnw> nart: read, code, ask questions
16:09:47 <johnw> repeat
16:09:50 <levi> nart: We were all noobs once. :)
16:09:55 <ski> nart : lurk. ask if there's something you think sound interesting and don't quite understand. perhaps try reading some mentioned blog posts and research papers ?
16:10:23 <ski> also, try stuff out
16:10:29 <bitemyapp> nart: the "coding" part is important. it makes things stick.
16:10:35 <monochrom> must you know everything we talk about? must you fully grasp haskell? are you inflicting too high requirements on yourself?
16:10:59 <sm> +1
16:11:08 <Eduard_Munteanu> monochrom++
16:11:20 <bitemyapp> nart: you don't really need to know that much to get along in Haskell and be productive.
16:11:23 <Eduard_Munteanu> Since you didn't want to make it formal, I did. :P
16:11:29 <bitemyapp> nart: just don't get into arguments with Scala users and you'll be fine.
16:12:37 <sm> nart: nevertheless, we now happily begin teaching you everything we know. Tutor is a good idea, a lot of that goes on here
16:12:49 <nart> the problem is, rigth know i'm productive with haskell (kind of) but everytime i join here you're talking weird kind of monads/types, stuff i have never heard about.
16:13:30 <nart> and when i check them out, i can't find something to code to try them out.
16:13:44 <sm> haskell is a favourite of students of computer science, and useful to them in a way few other languages are, so you hear a disproportionate amount of that talk
16:13:53 <bitemyapp> nart: you should take the gist I sent you seriously
16:13:57 <levi> nart: If it sounds interesting, look into it. Most of it is not really necessary knowledge, just *fun* for people who enjoy theory stuff.
16:14:04 <bitemyapp> nart: it will teach you the typeclassopedia and things like functors and monads.
16:14:17 <bitemyapp> levi: well, a lot of it is useful.
16:14:22 <bitemyapp> levi: or at least, the typeclassopedia is.
16:14:24 <bitemyapp> (to me)
16:14:29 <levi> Oh yeah, I agree.
16:14:30 <bitemyapp> but it's not strictly necessary.
16:15:12 <nart> ByronJohnson: thanks for the gist, i just wanna add that when i say "weird monads" i refer to stuff like "Control.Monad.Free.Church" that i read today
16:15:15 <levi> Just keep learning things a bite at a time and eventually the complex-sounding stuff will start to make sense.
16:15:43 <bitemyapp> levi: it's a lot like using vim for the first time. When you don't know any of the verbs or nouns, or how they compose, it's utterly baffling.
16:15:48 <bitemyapp> levi: then you start piecing it together...
16:16:18 <levi> Although, in the case of extremely clever/weird stuff, it might not be really worth your time digging into unless something about it seems really compelling.
16:16:29 <Eduard_Munteanu> nart: note some of that stuff is already kind of research-y, or at least a bit academic compared to more common stuff.
16:17:04 <Eduard_Munteanu> So don't be very surprised if you don't find a howto. :)
16:17:45 <levi> A lot of advanced type theory stuff has not quite been hashed out enough, usability-wise, to be of practical use yet.
16:18:16 <levi> And the people working on it are generally researchers who have devoted years to studying that particular topic.
16:19:29 <nart> ah ok got it
16:19:56 <nart> digging that NICTA / course
16:22:18 <thebnq> ohh hdbc is catching sql errors and rethrowing an ioerror whyyy
16:26:48 * hackagebot markdown2svg 0.0.1.24 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.24 (YoshikuniJujo)
16:27:22 <hpc> that's an oddly specific format conversion
16:27:28 <ion> hah
16:31:22 <Twey> Hm, yes, there should be a Pandoc SVG writer
16:36:49 * hackagebot force-layout 0.3.0.1 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.1 (BrentYorgey)
16:40:17 <phyre> When is the NFL draft?
16:40:27 <Rotaerk_> hmm I'm considering making a typeclass for upcasting... class SupertypeOf type supertype where { upcast :: type -> supertype }
16:40:43 <Rotaerk_> it seems like something that would be useful enough to be standard, but I don't see a standard one
16:40:53 <Eduard_Munteanu> phyre: this channel is about Haskell, the programming language
16:40:59 <Rotaerk_> is there a reason for that? anti-pattern in some way?
16:41:06 <syllogismos> how do i do the nicta/course? can i just git clone it finish the exercises?
16:41:18 <phyre> Ah, sorry about that.
16:41:19 <johnw> Rotaerk_: in which cases is it useful?
16:41:54 <Eduard_Munteanu> Rotaerk_: it only really makes sense for limited universes of types, e.g. for an embedded language
16:43:30 <Twey> Rotaerk_: Doesn't sound much like an ‘upcast’ and more like just a ‘conversion’ between two different types that happen to have a specific conversion
16:43:44 <enthropy> Rotaerk_: getting ghc to choose the right instance is likely to need a type annotation
16:43:51 <johnw> Rotaerk_: have you seen the 'convertible' package?
16:44:36 <Twey> Rotaerk_: We have lots of functions like fromIntegral, realToFrac, &c., but you don't get the statistics a Java programmer would expect from an ‘upcast’ and there's not a lot of point in putting it in a typeclass for most things
16:44:44 <Rotaerk_> the purpose of this is... I have independent modules, each of which can produce events, but the context in which they are all put together will need to put all their individual event types into a one stream together
16:45:06 <Rotaerk_> so the larger context would define a generalized Event type, which is a union of all the components' event types
16:45:09 <Eduard_Munteanu> I've used something like   data Value :: Type -> * where FooCon :: (s <: Foo) => ... -> Value s   at some point, where (<:) is your class.
16:45:45 <Eduard_Munteanu> But it was an attempt to model a different language.
16:45:53 <enthropy> don't you need to write :> ?
16:46:02 <Rotaerk_> so an individual module colud have a function like this:  handleEvent :: (SupertypeOf MyEvent event) => MyEvent -> [event]
16:46:16 <enthropy> then again we have type families + * - that aren't uppercase either
16:46:27 <Eduard_Munteanu> enthropy: type operator constructors don't require ':' at the beginning anymore
16:46:29 <Rotaerk_> johnw: nope, haven't seen "convertible"
16:46:44 <Eduard_Munteanu> enthropy: in fact, type operators are always type constructors
16:47:10 <enthropy> what about  a `b` c?
16:47:17 <Eduard_Munteanu> enthropy: er, excluding that
16:47:52 <Eduard_Munteanu> enthropy: you can't have symbolic type variables anymore, which is occasionally annoying but it helps DataKinds and type-level literals
16:50:35 <piezoid> Rotaerk_: maybe you want something like Data Types a la Carte : http://lambda-the-ultimate.org/node/2700
16:51:45 <Rotaerk_> piezoid: hmm, will check it out
16:51:48 <Rotaerk_> thanks
16:52:42 <hpc> Rotaerk_: or alternatively, something like https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
16:53:04 <hpc> Rotaerk_: specifically, instead of many event types, have one generic Event type with a record of "methods"
16:53:45 <hpc> blarghEvent = Event {handle = blargh}, blubEvent = Event {handle = blub}
16:54:11 * monochrom has a cunning plan!
16:54:12 <Rotaerk_> hpc: the events don't correspond to singular transforms, they need to be descriptive and even serializable
16:54:23 <Rotaerk_> hpc: different contexts handle them in different ways
16:54:35 <monochrom> x = Event{prototype = defaultEvent} :)
16:54:37 <hpc> ah, that makes more sense then
16:54:44 <hpc> monochrom: oh god what
16:55:09 <Rotaerk_> I also find it amusing that you suggested a link with "anti-pattern" in the title :P
16:55:16 <hpc> Rotaerk_: yeah, i have a problem like that for game i am working on which i am working on solving
16:55:36 <hpc> state is handled with acid-state, which brings in all sorts of wacky problems
16:55:42 <Eduard_Munteanu> Rotaerk_: if your handler needs to know about all types of events, then perhaps you want a datatype (GADT) instead of typeclasses
16:55:57 <hpc> (solves a bunch too, just makes it hard to use haskelly features)
16:56:31 <hpc> Eduard_Munteanu: also if the set of event types is closed
16:56:33 <Rotaerk_> Eduard_Munteanu: I want the individual modules to not be dependent on the outer context's event type in any way
16:57:09 <Rotaerk_> they should only care that whatever type it is ... is capable of encoding their own type, plus the types of whatever other modules are included in it
16:57:31 <jmcarthur> i kind of dislike the frequency that the existential + type class blog post is shared. it's not a very well defined antipattern. it's not always bad to use type classes and existentials, and i'
16:57:33 <jmcarthur> oops
16:57:49 <jmcarthur> *and i'm afraid of that blog post possibly scaring people away from (sometimes) good ideas
16:57:55 <hpc> jmcarthur: the particular combination described in that article is pointless
16:58:12 <hpc> there are good ways to combine the two features
16:58:15 <jmcarthur> i agree, but most readers are going to just take it as gospel and lose context
16:58:25 <Eduard_Munteanu> Rotaerk_: perhaps requiring the modules to provide a polymorphic interface could help?
16:58:26 <shachaf> jmcarthur: I think luqui agrees.
16:58:40 <Rotaerk_> Eduard_Munteanu: explain?
16:58:42 <jmcarthur> shachaf: i would be surprised if he doesn't, at least
16:58:46 <monochrom> I agree that it is not as anti as commonly advertised
16:59:00 <hpc> most readers will also ignore the age too; it predates the ability to do data Dict c = Dict (c a => a)
16:59:17 <shachaf> He mentioned recently that his opinion has changed somewhat since writing that post.
16:59:40 <jmcarthur> hpc: you mean  data Dict c = forall a. Dict (c a => a)  ?
16:59:47 <jmcarthur> hpc: your version isn't existential
16:59:50 <shachaf> But it's an important thing to think about and not really obvious.
17:00:33 <hpc> er, yes
17:00:41 <Eduard_Munteanu> Rotaerk_: for example, instead of defining a datatype containing functions, use a rank-n type thats isomorphic to it
17:00:46 <monochrom> I don't single out existentials anyway. it's just one way to generalize. I pick on all premature generalizations across the board. and I support all necessary generalizations. I just demand strong evidence on why you think yours is necessary.
17:00:48 <hpc> it's hard to remember where the foralls go in a data declaration
17:00:59 <ski> how so ?
17:01:07 <jmcarthur> yeah, i somewhat dislike the syntax for existential types
17:01:23 <jmcarthur> i understand its motivations, but it's still kind of weird
17:01:34 <Rotaerk_> Eduard_Munteanu: hmm, I wasn't planning on using data types containing functions, so I'm having trouble projecting your suggestion onto my problem
17:01:53 <shachaf> jmcarthur: Do you also dislike the use of =>?
17:01:58 <Eduard_Munteanu> Rotaerk_: ok... can you give an example of interface you'd like to expose?
17:02:25 <monochrom> it is easy for me to remember. to a large extent I just have to remember "it is not Ctor (forall ...), that would be rank-n type"
17:02:41 <c_wraith> existentials in general are way overused in designs proposed by beginners.
17:02:50 <jmcarthur> shachaf: since you asked i assume that it would be inconsistent of my to like that syntax, for some reason, but i can't think of what reason there would be for that.
17:02:54 <Eduard_Munteanu> monochrom: you mean impredicative?
17:02:59 <hpc> Rotaerk_: btw, the way you say "plus the types of whatever other modules are included in it" makes it sound like you want module imports to change program semantics
17:03:02 <monochrom> perhaps
17:03:05 <jmcarthur> *of me to like
17:03:10 <hpc> which is a haskell no-no
17:03:17 <Rotaerk_> hpc: sorry, I'm overloading terms a bit
17:03:29 <monochrom> it is morally impredicative but legally not impredicative just rank-n.
17:03:42 <Rotaerk_> hpc: I should use "component" to refer to the things exposed by a module and included into the composite
17:03:53 <monochrom> I say this because I use it to emulate impredicative
17:04:12 <c_wraith> I really wish impredicative types worked better, because I'd like the syntax for using them.  If it wasn't for all the extra type annotations.
17:04:29 <c_wraith> The rank-2 + newtype fallback isn't terrible, though
17:05:13 <Eduard_Munteanu> I've been using CPS-encoded existentials in my xmonad config, so I don't need to write out or omit ugly types for layouts. That's a marginally better usage scenario. :P
17:05:18 <hpc> i never properly learned impredicative types
17:05:56 <Rotaerk_> I was structuring it like.. each module has a simple data structure for the state of the component, and exposes another ADT for that module's "events".  for instance, I have an EntityRegistry component/data-type, and data Entity.Event = EntityCreated EntityId | EntityDestroyed EntityId
17:05:59 <c_wraith> hpc: it's more or less extending rank-n types by being able to use polymorphic types as arguments to things other than functions.
17:06:00 <monochrom> anyway, beginners don't just misuse existentials either. they misuse all generalizations and invent all ways to build a system so complicated that there are no obvious errors.
17:06:02 <Eduard_Munteanu> There isn't much to learn about them, they're just an abomination type-theory-wise.
17:06:05 <jmcarthur> hpc: there's nothing really special about them. you know when you come across a time you want them.
17:06:28 <c_wraith> hpc: err, as arguments to type constructors other than (->)
17:06:47 <jmcarthur> hpc: namely, when you want to use anything like F (forall a. ...)
17:06:53 * hackagebot diagrams-haddock 0.2.2.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.1 (BrentYorgey)
17:07:13 <hpc> jmcarthur: like a heterogenous list or something
17:07:18 <hpc> (one of the more evil uses)
17:07:25 <monochrom> hpc: when one day you write this type "Maybe (forall a. a -> a)", you understand impredicative types :)
17:07:32 <Rotaerk_> and then I would make EntityRegistry an instance of ObserverOf EntityEvent
17:07:38 <Eduard_Munteanu> They're called impredicative because Haskell wants to put them into *, but they don't really belong there.
17:08:00 <c_wraith> I always end up with things that somehow look like IO (forall a. a -> IO a)
17:08:12 <monochrom> consider "x :: Maybe (forall a. a -> a); x = Just id" :)
17:08:36 <Eduard_Munteanu> i.e. it doesn't quite distinguish 'forall a. a' from 'a' as far as kinds are concerned
17:09:13 <Rotaerk_> hmm I really need to put together a brief demonstration of the approach I'm taking... explaining in text takes too long and people lose interest
17:13:41 <kristof> Java got first class functions
17:13:42 <kristof> we won
17:13:43 <kristof> it's over
17:13:47 <kristof> we can stop using Haskell now
17:14:05 <c_wraith> time to start writing Monad libraries for java
17:14:25 <c_wraith> Don't give up until java has support for higher-kinded polymorphism!
17:14:39 <c_wraith> And after that, don't give up 'til java has support for polymorphic kinds
17:15:15 * geekosaur does not even want to know what horrors of syntax that would involve
17:15:35 <shiona> and suddenly we have 10 million problems with "developers" who try to use this stuff
17:15:36 <hpc> it's just a shorthand for an anonymous class with a run() method
17:15:37 <c_wraith> GHC syntax for polykinds still isn't great.  At least in the type pretty-printer
17:16:11 <Twey> Actually, what does Java's kind system even look like?
17:16:38 <c_wraith> java's kind system is nearly absent.
17:17:18 <Eduard_Munteanu> Java's kind system is kind of absent. :P
17:17:33 <Twey> K ::= ★ | ‹★, …› → ★ ?
17:17:54 <c_wraith> java barely even has type constructors
17:18:00 <Twey> Well, it has generics and you can't use a generic in the place of an inhabited type, right?  (okay, it only gives a warning, but still)
17:18:12 <hpc> Twey: you can
17:18:14 <c_wraith> The generic system always allowss you to elide the type arguments
17:18:22 <hpc> it defaults to foo<Object>
17:18:24 <Twey> Doesn't it warn?
17:18:33 <hpc> it warns, but who actually reads warnings
17:18:45 <Twey> Yeah, but it recognizes the difference between the two kinds
17:19:04 <c_wraith> I don't think you can call it a "system", though
17:19:17 <c_wraith> well, I guess everything's a system
17:19:29 <Twey> Indeed
17:20:17 <Twey> So, Integer : ★, List : ‹★› → ★
17:20:19 <c_wraith> But it has about 2 states.  "Types that expect an argument" and "types that don't expect an argument"
17:20:35 <Twey> And I guess primitives and objects are distinct types too
17:20:40 <c_wraith> that's true
17:20:51 <Twey> c_wraith: It also tracks the arity of types-that-expect-arguments
17:21:19 <hpc> iirc, you can even do something like
17:21:25 <Eduard_Munteanu> Does it type vectors at all, or is the array bounds check elimination not exposed at all in the language?
17:21:31 <hpc> class Foo<T, S<T>>
17:21:36 <c_wraith> Eduard_Munteanu: the latter.
17:21:41 <Twey> hpc: Yes, you can
17:21:45 <Twey> Generics are full type functions
17:21:54 <Twey> K ::= ♯ | ★ | ‹★, …› → ★
17:21:59 <monochrom> Rotaerk_: we support using existentials in your case, or at least as a reasonable option if you have many options. that much you don't have to worry :)
17:22:24 <Rotaerk_> I just read through https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:22:57 <Twey> Rotaerk_: That sounds like a reasonable use of existential types
17:23:01 <kristof> Arrays.sort(words, (s1, s2) -> s1.length() - s2.length());
17:23:09 <kristof> It's almost a first class function :)
17:23:20 <kristof> I don't think you can return lambdas, unfortunately
17:23:33 <Twey> kristof: Not even if their environment is final?
17:23:42 <kristof> Twey: I wouldn't know
17:23:56 <Rotaerk_> monochrom, twey: the "AnyWidget" approach could perhaps be used to encode "any component's event", but the problem is that events don't contain transforms, they just contain information so that something else can specify the transform
17:23:59 <kristof> Twey: What I meant was that I don't know how to return a lambda
17:24:19 <c_wraith> kristof: seems like you should be able to return a lambda, but you might have to write out its real type, not the lambda sugar.
17:24:19 <Rotaerk_> so there would need to be a way to get back from "any event type" to "component X's event type"
17:24:20 <kristof> Twey: ...it might work the way that seems most natural, who knows
17:24:27 <kristof> c_wraith: hmmmmmmmmmmmmmm
17:24:32 <kristof> I don't want to think too hard about java.
17:24:34 <Twey> Rotaerk_: The ‘antipattern’ is when it's self-contained, because you're keeping the information about which instance it is in the type and then throwing it away with the existential, which is usually pointless (you should just not keep it in the first place).  But if you're exposing both approaches and don't know which one the client code will want, it's reasonable
17:24:58 <Rotaerk_> so I'm thinking "any event type" would need to be a manually construct ADT, one constructor for each component event type
17:25:12 <Rotaerk_> at least that's what I was considering... but that's tedious
17:25:24 <Twey> kristof: I'd be surprised if you couldn't return a lambda, since that's a problem that's already ‘solved’ (er, hacked around) in Java with anonymous classes
17:25:50 <kristof> Twey: anonymous classes are different from anonymous functions/methods, I think
17:25:54 <kristof> but now Java has both!
17:26:06 <Twey> So not being able to return a lambda (that uses only final values from its environment) would be arbitrary restriction of an existing feature
17:26:15 <Twey> kristof: It's not really different
17:26:24 <kristof> Twey: I wouldn't mind returning a lambda with a mutable closure
17:26:38 <kristof> ...That's how Scheme people pretend they have objects, after all
17:26:58 <kristof> Oh, and wow people with counter examples over and over again :P
17:27:23 <Rotaerk_> it might be easier if I just write this thing, and then get people here to review it and suggest more optimal approaches
17:27:24 <darthdeus> guys i have this problem in my head that i've been trying to figure out for like a month while reading different haskell books, but haven't found a solution ... i basically need to have two "processes" that communicate with eachother via a channel (yes exactly like in Go), or anything that resembles this, how would i go about implementing this?
17:27:30 <Twey> kristof: You can already (SE 7) effectively define and use ‘function’ instances.  It's just that the syntax is horrible, which is what lambdas are supposed to fix.
17:27:46 <kristof> Twey: So this isn't a language extension, it's a syntax extension?
17:27:57 <darthdeus> and i want those "processes" to both be in the same binary, not two haskell apps talking via network or something
17:28:00 <Eduard_Munteanu> darthdeus: what does "process" really mean?
17:28:12 <darthdeus> Eduard_Munteanu: parallel unit of computation
17:28:16 <Twey> kristof: Well, that was the proposal as I understood it.  Might be they've done something more or less; this is the first I've heard that they've actually implemented it.
17:28:21 <Rotaerk_> darthdeus: I haven't really dug into it, but does this work?  http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-Chan.html
17:28:25 <Eduard_Munteanu> darthdeus: oh, then just fork a thread and use MVars or Chans
17:28:28 <Rotaerk_> I remember asking something similar and getting pointed to that
17:28:31 <kristof> darthdeus: data.chan(nel?)
17:28:32 <Twey> darthdeus: Well, the same way.
17:28:36 <kristof> there's a channel implementation out there somewhere
17:28:37 <c_wraith> DarthArachides: how is Control.Concurrent.Chan not good enough?  (there are several different ways it might not be good enough, and they affect the overall answer)
17:28:39 <darthdeus> Eduard_Munteanu: think of two web servers running at the same time, where one holds an open connection, and when the other one gets a request it sends it to the other one and it sends a response to it's open connection
17:28:42 <darthdeus> cool, thanks
17:28:42 <Rotaerk_> darthdeus: sounds like the "MailboxProcessor" of F#
17:28:44 <Twey> darthdeus: You create a channel and pass it to the processes.
17:28:53 <kristof> darthdeus: haskell has channels, find them
17:29:08 <greg``> hello
17:29:27 <kristof> darthdeus: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-Chan.html this was the first result in a simple google search
17:29:28 <darthdeus> what's the difference between MVar and IORef?
17:29:29 <c_wraith> Channels in haskell aren't a big deal, because they just are a library.
17:30:02 <Twey> Well, they're a chain of MVars, and MVars require some compiler support
17:30:04 <darthdeus> kristof: yeajh but that doesn't really tell me how to write this :) i'm sort of noob at haskell so i never did anything with concurrency
17:30:07 <Axman6> darthdeus: MVars can be empty and are blocking, IORefs are just mutable references
17:30:15 <darthdeus> hmm
17:30:22 <darthdeus> interesting
17:30:37 <darthdeus> and if i had two functions i want to execute in parallel and block forever?
17:30:41 <Axman6> darthdeus: you can't fill a full MVaar until it's emptied by someone else, and can't take from an empty one until its filled
17:30:53 <Axman6> "block forever"?
17:30:56 <darthdeus> if i wanted to have*
17:31:00 <Twey> darthdeus: As far as I can tell from your description of the Go, it's a direct translation: 1) create channel (newChan), 2) pass to processes via closure, 3) run processes, writing to channel as appropriate
17:31:06 <kristof> darthdeus: If you know how to use channels in other languages, you should be saying "give me channels!", and someone can give them to you, and off you go
17:31:22 <kristof> darthdeus: There might be a blog post somewhere, I don't know.
17:31:55 <ski> c_wraith : yeah, what's with `AnyK' ?
17:31:56 <darthdeus> Axman6: well just imagine two infinite recursions with a delay that should run in parallel
17:32:10 <darthdeus> kristof: yeah i guess you're right, my problem is probably more related to not knowing how to do concurrency in haskell
17:32:10 <c_wraith> ski: I haven't got the slightest idea.
17:32:43 <Axman6> darthdeus: check out simon marlow's book, it's excellent
17:32:49 <Eduard_Munteanu> ski: AnyK is the sort of polymorphic kinds, IIRC
17:32:50 <Axman6> do we have a @where for that book?
17:33:05 <DMcGill> we certainly should
17:33:08 <Twey> Axman6: The Simon Marlow book?
17:33:10 <darthdeus> Axman6: yeah it's on my todo list :P http://chimera.labs.oreilly.com/books/1230000000929/index.html
17:33:11 <Axman6> yeah
17:33:22 <Axman6> darthdeus: well, sounds like it's time to do ;)
17:33:24 <darthdeus> but it's so long and complicated
17:33:28 <Axman6> it's very readable
17:33:32 <ski> Eduard_Munteanu : doesn't make sense
17:33:33 <Eduard_Munteanu> ski: er, the kind for polymorphic stuff
17:33:57 <darthdeus> ok i'll check it out
17:34:02 <greg``> can someone tell me whats so good about STM
17:34:05 <darthdeus> i've already listened to the podcast like 3 times already anyway
17:34:27 <greg``> i read beautiful concurrency and was struck that actual theres nothing new
17:34:30 <ski> Eduard_Munteanu : after `newtype Flip f b a = MkF (f a b)' i get `Flip :: (AnyK -> AnyK -> *) -> AnyK -> AnyK -> *', which would make no sense if `AnyK' was "the kind for polymorphic stuff"
17:34:33 <Eduard_Munteanu> ski: are you referring to the use in GHC.TypeLits? AFAIK that's a trick to be able to refer to kinds
17:34:42 <greg``> the structures he defines are like latches and barriers in java
17:34:59 <greg``> or am i missing something?
17:35:01 <ski> *`Flip'* is supposed here to be a polymorphic type (not kind), but i don't see any trace of that in the reported kind of it
17:35:08 <kristof> darthdeus: There's an excellent boo- oh, someone already suggested it
17:35:14 <kristof> that book has amazing stuff in it
17:35:21 <fryguybob> greg``: With Haskell STM it is hard to write some common incorrect code.
17:35:21 <ski> Eduard_Munteanu : afaiui, no GHC extension gives you polymorphic kinds
17:35:28 <darthdeus> kristof: boo- oh?
17:35:30 <johnw> greg``: STM in Haskell is nice because it forbids IO; you can transactional behavior when referencing STM variables, but only that, which forces your logic to not screw things up in the way that normal async code so often does
17:35:45 <johnw> s/can/get
17:36:08 <kristof> darthdeus: book, truncated because I realized mid sentence that someone recommended it already
17:36:12 <Eduard_Munteanu> ski: is PolyKinds turned on?
17:36:27 <kristof> darthdeus: I like writing out my sentences similarly to how I would speak.
17:36:33 <darthdeus> kristof: hehe :P
17:36:52 <TallerGhostWalt> Did anyone else see that tweet DonS sent out about algebra of API's?
17:36:56 <Eduard_Munteanu> ski: if it isn't it would explain why it doesn't say f :: k -> l -> * or something like that
17:36:57 <TallerGhostWalt> are tere examples of doing this
17:37:02 <TallerGhostWalt> like case studies?
17:37:08 <ski> Eduard_Munteanu : yes. otoh afaiui `PolyKinds' don't give me any kind of polymorphic kinds (so it's a misnomer)
17:37:16 <Eduard_Munteanu> Yeah, I know.
17:38:59 <greg``> hmm ok perhaps i will write a bit of async stm code
17:39:35 <Eduard_Munteanu> Oh, I think I was confusing it with Any and Kind here: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-TypeLits.html
17:39:56 <bgamari> I wish parsec had reasonable number parsing
17:40:49 <hpc> bgamari: i remember there being a good function for it
17:40:56 <hpc> parses everything ghc can
17:41:01 <bgamari> hpc, right
17:41:09 <hpc> (and ghc does pretty much everything you could want, except 0b1010101)
17:41:10 <bgamari> hpc, but it's real overkill
17:41:22 <bgamari> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-ParserCombinators-Parsec-Token.html
17:41:56 <bgamari> hpc, I just want something like attoparsec's double, for instance
17:42:10 <johnw> greg``: the 'retry' function is almost magical
17:43:19 <monochrom> retry is the best thing since shared variables :)
17:46:50 <kristof> TallerGhostWalt: which post?
17:46:54 <kristof> link link link
17:46:59 <kristof> "algebras of APIs" sounds exciting
17:47:31 <esebelle> Is there any way to tell cabal to use a flag when building a dependency?
17:48:25 <TallerGhostWalt> kristof: from twitter The least appreciated part of API design is the algebra of the API. What properties hold? Write them down! Use it to discover the true API"
17:48:53 <kristof> hmmmmm
17:48:55 <kristof> interesting
17:48:59 <zeiris> Can't tell if serious.
17:49:13 <monochrom> that means, for example, for a functional stack, "pop . push = id" and more equations like that
17:49:17 <hpc> the real news here is dons talking about programming again
17:49:18 <kristof> Hey, question for people
17:49:37 <kristof> We usually use IO a to represent an *input* type, and IO () to represent output?
17:50:00 <Eduard_Munteanu> kristof: er, no
17:50:10 <monochrom> Text.PrettyPrint.HughesPJ has more equations like that as an example. see its doc.
17:50:30 <hpc> kristof: we use (IO a) to represent a computation that produces a value of type 'a' while touching the outside world in some way
17:50:30 <kristof> Eduard_Munteanu: Guess I'm pretty confused about IO the type constructor
17:50:43 <kristof> hpc: You know, that's actually what I meant
17:50:44 <Eduard_Munteanu> kristof: 'IO A' represents a computation that produces an 'A' as a result.
17:50:44 <avpx> kristof: It is interesting to think: what expressions can have type e :: forall a. IO a
17:51:18 <Eduard_Munteanu> kristof: when you have () instead of A, you don't expect a result, but you care about the side-effects
17:51:33 <kristof> Gotcha
17:51:37 <kristof> Yeah, that solidifies what I had in my head
17:51:47 <kristof> It's not really about input and output but about effects and return values
17:51:55 <Eduard_Munteanu> kristof: IO A can have side-effects too, it's only that you also get some useful information out of it.
17:51:59 <kristof> right
17:52:00 <Eduard_Munteanu> Yeah.
17:52:10 <avpx> kristof: So IO () has the purpose of a void function in another language
17:52:13 <kristof> When I said input, I was really thinking "get something, and make it a pure value of type a"
17:52:17 <kristof> avpx: I see
17:52:26 <alskdj> I have a function like: "Map Int String -> Proxy () a () Void IO b" and I want to make the Map be in a State so I don't have to keep re-passing it back in when the function calls itself.  I need a StateT right?  But where in the type signature does it belong?
17:52:30 <kristof> avpx: ...too many functions in other languages have void written everywhere, though
17:52:43 <Twey> kristof: Usually the IO a is the return value of a function, because you care about producing a computation that does a certain thing, and the inputs are already ‘unwrapped’ because they belong to earlier layers of monad
17:53:01 <Eduard_Munteanu> alskdj: I don't get that return type
17:53:09 <kristof> ok
17:53:26 <hpc> alskdj: that'd be one hell of a long type; perhaps a broader reconsidering of how your program is structured?
17:53:33 <Twey> kristof: So functions that take an IO a as an argument are actually transforming the computation, which is a relatively rare operation (and also tends to be generalized to all monads)
17:53:40 <greg``> johnw: what is magical about retry
17:54:02 <hpc> kristof: one of the more common examples of such an operation is forkIO
17:54:04 <hpc> :t forkIO
17:54:05 <lambdabot> Not in scope: `forkIO'
17:54:20 <alskdj> Eduard_Munteanu: its a pipe
17:54:20 <hpc> kristof: or exception handling
17:54:53 <kristof> Twey: like sequenceM_
17:55:13 <bitemyapp> kristof: you generally want to avoid IO if you mean something more specific - like ST.
17:55:17 <johnw> greg``: say you have a transaction involving 4 different variables, and you reach a point where you need for the transaction to be tried again; so you 'retry', and effectively the worker thread will sleep until it has a "better chance of succeeding", without you having to code such logic
17:55:32 <bitemyapp> kristof: because anything in IO can do *anything*, the domain of side effects/mutation is effectively infinite.
17:55:34 <kristof> bitemyapp: I'm aware, but this was a question about IO specifically at its inception
17:55:36 <johnw> it leads to some incredibly elegant code
17:56:04 <bitemyapp> kristof: well pre-1.3 I think they used to use lazy lists for sequencing IO computations?
17:56:14 <Axman6> greg``: retry won't rerun the computation again until one of the variables its read changes
17:56:15 <bitemyapp> kristof: monads were found to be nicer to write.
17:56:25 <kristof> I've heard of that
17:57:30 <Algebr> Some haskell docs say that lists are of variable length while tuples are of fixed length, but I thought that all data structures were immutable, so why say that lists are of variable length, wouldn't they also be of fixed length?
17:57:51 <kristof> Algebr: They're speaking about the types to be specific
17:57:58 <johnw> Algebr: the type [a] admins inhabitants of any length
17:58:02 <johnw> admits
17:58:11 <bitemyapp> Algebr: you know the length of a tuple statically, you do not know the length of a list statically.
17:58:19 <kristof> Algebr: You can't add a 2-tuple with a 3-tuple. You can concatenate to strings
17:58:20 <Eduard_Munteanu> Algebr: they aren't mutable in-place, but you can "mutate" things by constructing new ones, e.g. adding an element to a list
17:58:20 <bitemyapp> Algebr: lists are non-deterministic in that respect.
17:58:21 <kristof> *two
17:58:34 <Algebr> ah, thanks guys!
17:58:42 <bitemyapp> Eduard_Munteanu: you can return/accumulate new results, I wouldn't use the word mutate really.
17:59:04 <Axman6> > length (repeat 1) -- infinite list! who knows what size it is?
17:59:09 <lambdabot>  mueval: Prelude.undefined
17:59:16 <Axman6> o.O
17:59:18 <kristof> bitemyapp: you can return a new list that has one element changed, I consider that sleight-of-hand mutation :P
17:59:19 <bitemyapp> kristof: not to be an arse, but IO is: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:59:23 <avpx> Axman6: Haha
17:59:26 <Eduard_Munteanu> Well, the original question was using "mutate" in that extended sense too.
17:59:36 <Axman6> that wasn't the exception I expected
17:59:56 <verement> @src repeat
17:59:57 <lambdabot> repeat x = xs where xs = x : xs
18:00:03 <verement> @src length
18:00:03 <lambdabot> Source not found.
18:00:44 <Axman6> wut
18:00:50 <verement> :t length
18:00:50 <lambdabot> [a] -> Int
18:01:10 <avpx> > let repeat x = fix (x:) in length . repeat $ 1
18:01:15 <lambdabot>  mueval: Prelude.undefined
18:01:15 <lambdabot>  mueval: ExitFailure 1
18:01:19 <avpx> *shrug*
18:01:59 * hackagebot markdown2svg 0.0.1.25 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.25 (YoshikuniJujo)
18:02:11 <Axman6> usually it's say time limit exceded
18:02:14 <Axman6> it'll*
18:02:14 <avpx> Yeah.
18:04:21 <jmcarthur> bitemyapp: i don't think GHC's internal representation of IO is very helpful for teaching people about IO :\
18:04:40 <greg``> yes thats pretty hot
18:04:42 <avpx> jmcarthur: Yeah, agreed.
18:05:04 <jmcarthur> bitemyapp: it's not even accurate as a model
18:05:57 <bitemyapp> jmcarthur: I don't think kristof needed or wanted it explained to him necessarily
18:06:13 <bitemyapp> jmcarthur: but with that aside, what do you think *is* a good explanation?
18:06:29 <jmcarthur> bitemyapp: to see why, try explaining concurrency, or try implementing  instance MonadState RealWorld IO
18:06:44 <bitemyapp> yeah, still missing the point.
18:06:47 <jmcarthur> bitemyapp: i think there is no good explanation, but there is at least a better one...
18:07:09 <monochrom> what was the question to begin with?
18:07:27 <avpx> <kristof> We usually use IO a to represent an *input* type, and IO () to represent output?
18:07:48 <avpx> It was not really the best question for a type like IO (State# RealWorld -> (# State# RealWorld, a #))
18:08:00 <johnw>  IO a can be used to represent output too, if you don't care about the type of the output
18:08:06 <jmcarthur> bitemyapp: data Instr a where PutStrLn :: String -> Instr (); GetLine :: Instr String; ...     data IO a = Return a | forall e. Bind (Instr e) (e -> IO a)
18:08:12 <bitemyapp> avpx: kinda depends on what side of the arrow it's on.
18:08:22 <jmcarthur> bitemyapp: it's not a satisfying model, but at least it doesn't lie
18:08:46 <bitemyapp> I had a specific reason for sharing the type signature actually
18:08:55 <bitemyapp> namely, the # in the tuple.
18:09:22 <jmcarthur> now i'm lost
18:09:22 <monochrom> I use "IO X" for the type of an I/O-effectful procedure. X could be Int or (). this is orthogonal to whether I intend input, output, or a mixture of both
18:09:36 <Eduard_Munteanu> Is there an extension that adds absurd patterns?
18:09:42 <jmcarthur> i think IO is a poor name for it, honestly
18:10:04 <jmcarthur> more like StuffICouldn'tModelNicely
18:10:34 <jmcarthur> Eduard_Munteanu: EmptyCase, i think. it's new in 7.8, iirc
18:10:42 <jmcarthur> Eduard_Munteanu: or perhaps EmptyPatterns
18:10:46 <jmcarthur> but i think it's the former
18:10:47 <Eduard_Munteanu> Ah, thanks. I'm on 7.6.3 though.
18:11:05 <monochrom> if "action :: IO X", then in "action >>= \y -> ...", y has type X. and the behaviour: after "action" performs its effect, it has a value of type X to pass on to the next stage, and my y receives that value.
18:11:46 <avpx> The question was answered 15 minutes ago :-\
18:12:54 <monochrom> RealWorld is a phantom type.
18:13:08 <mm_freak> johnw: unfortunately haskell allows for a lot of cleverness =)
18:14:31 <jmcarthur> bitemyapp: an example of a paradox you run into when you take GHC's representation of IO literally: http://hackage.haskell.org/package/acme-realworld
18:15:30 <avpx> jmcarthur: So what you're saying is that we invented time travel?
18:15:50 <dhrosa> I have the function train, which is from (X, Y) -> State Classifier Mistake, how would I take a list of [(X,Y)], and get the resulting Classifier and Mistake for eaech step in the process? http://lpaste.net/99844
18:16:04 <dhrosa> I want something similar to iretae
18:16:06 <dhrosa> iterate*
18:16:59 <dhrosa> so I want to get a [(Classifier, Mistake)] out
18:18:40 <monochrom> mapM (\xy -> do { m <- train xy; c <- get; return (c,m) })
18:20:05 <monochrom> it may also be mapM (\xy -> (,) <$> train xy <*> get)
18:20:21 <dhrosa> ahhh netsplit
18:21:23 <dhrosa> :t mapM
18:21:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:23:28 <dhrosa> monochrom: so if I understand right, the state from the application of the first training gets passed to the application of the second training, etc?
18:25:14 <avpx> dhrosa: Yep. mapM f = map f . sequence
18:25:15 <avpx> Erm
18:25:16 <avpx> sequence . map f
18:26:59 <dhrosa> aha, makes sense, thanks!
18:27:16 <dhrosa> I was going to do something terrible using iterate, >=>, >>, fst, snd, map, all combined
18:27:45 <dhrosa> :t sequence
18:29:39 <dhrosa> :t sequence
18:30:49 <monochrom> sequence :: Monad m => [m a] -> m [a]
18:31:08 <hpc> > fix id
18:31:17 <monochrom> sequence [a, b, c] = do { x<-a; y<-b; z<-c; return [x,y,z] } for example
18:32:21 <monochrom> mapM example is: mapM f [t, u, v] = do { x <- f t; y <- f u; z <- f v; return [x,y,z] } and you see how it may relate to sequence
18:39:18 <jmcarthur> edwardk: "I intend to write up a post on how to 'read' universal properties as types, to help folks see where this definition for End comes from."   <-- It's been over two months, and I'm still waiting. :)
18:39:36 <edwardk> jmcarthur: one of these days
18:40:05 * jmcarthur twiddles his thumbs a bit more
18:44:39 <tac> Anyone ever experience an abnormally long linking time?
18:45:01 <jmcarthur> edwardk: i have a less obnoxious question to ask. you said in the same post, "Now that we've split the input and output parameters can we perhaps use that or something like it to more easily [manipulate environments]?", where the [...] was a link to http://www.haskell.org/pipermail/haskell-cafe/2008-November/049473.html , but it is now broken, and I don't know how to figure out what you had linked to before.
18:47:05 <jmcarthur> tac: If I had, would it still be abnormal?
18:47:51 <tac> jmcarthur: The more users, the more normal it would seem
18:47:58 <tac> I think my server is just being slow today
18:50:19 <td123> tac: I've noticed long link times with yesod
18:51:02 <tac> td123: yeah, now even typing at the terminal is slow
18:51:05 <tac> def. an issue on my end
18:56:03 <tac> @hoogle Maybe [a] -> [a]
18:56:23 <tac> Is there a library function to turn a Maybe [a] into an [a]
18:56:30 <tac> taking Nothing to [] and Just xs to xs?
18:56:51 <Eduard_Munteanu> :t concat . maybeToList
18:56:56 <lambdabot> Maybe [a] -> [a]
18:57:14 <tac> thnx
18:59:23 <jmcarthur> :t Data.Foldable.fold
18:59:28 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:59:39 <jmcarthur> :t Data.Foldable.fold :: Maybe [a] -> [a]
18:59:46 <lambdabot> Maybe [a] -> [a]
18:59:48 <jmcarthur> tac: ^^^
18:59:59 <tac> thanks
19:02:47 <ParahSailin> @src Maybe Data.Foldable.fold
19:02:47 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:03:27 <hakujin> how do I correctly use parMap with a monad transformer? sequence . parMap rseq f? threadscope is giving me an error on windows and I don't know how else to determine thread stats
19:05:02 <hakujin> @hoogle parMap
19:05:03 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:05:11 <hakujin> @hoogle mapM
19:05:11 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:05:11 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:05:11 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
19:09:15 <johannesbodannes> so i've used Haskell for a lot of hobby projects, and for a couple of serious web projects and I really enjoy the language. And I've been thinking of creating a video game as a creative outlet, and since I enjoy Haskell so much I've been contemplating the option of using that
19:09:17 <johannesbodannes> HOWEVER
19:09:36 <johannesbodannes> in my head I have huge trouble figuring out how that even would work <_<
19:10:16 <johannesbodannes> Is creating a video game along the lines of something like... idk, nethack even vaguely reasonable to contemplate in Haskell compared to using some imperative language?
19:10:36 <hakujin> johannesbodannes: sure, why not?
19:11:10 <levi> One pops up on reddit every once in a while.
19:11:49 <johannesbodannes> Mostly because the most natural way, in my head, of imagining a game is in a very object-oriented way. Like... defining what a monster is, or a bullet or a player and effecting a dynamic game world by mutating the world's state
19:12:14 <Twey> johannesbodannes: Think in terms of events instead, and use FRP
19:12:20 <thebnq> records do the job pretty well :D
19:12:43 <johannesbodannes> FRP? I will look up FRP...
19:12:50 <Twey> Or behaviours, maybe.  I guess that's pretty close to the OO approach, really.
19:12:58 <Eduard_Munteanu> I'm not sure that's very approachable.
19:14:22 <Twey> johannesbodannes: ocharles made a nice little Asteroids clone with Netwire: http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
19:14:43 <levi> There are probably a number of ways you could structure a program like nethack in Haskell. FRP is definitely one of them, but it might be easier to start with a simple state-transforming function.
19:15:01 <johannesbodannes> Thanks, Twey
19:15:21 <Twey> I think mm_freak recommends Sodium/Banana over Netwire nowadays, but the principles are there
19:16:14 <Twey> levi: I'm not sure, I feel like FRP side-steps a lot of the complexity one encounters with plumbing state between different parts of a program
19:17:17 <tac> @hoogle err
19:17:18 <lambdabot> Network.Browser err :: String -> BrowserAction t ()
19:17:18 <lambdabot> Prelude error :: [Char] -> a
19:17:18 <lambdabot> Foreign.C.Error errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
19:18:25 <Twey> When exactly does GHC print <<loop>>?
19:18:58 <Twey> I remember seeing it back in my early days, but I haven't encountered it in ages, and the obvious do-nothing loops like let x = x in x don't seem to trigger it
19:20:21 <levi> What about something like let x = 1 : 2 : 3 : x ?
19:21:02 <Cale> Twey: if you're using the threaded runtime, it's much harder (perhaps impossible?) to get it to happen
19:21:36 <johnw> I've seen <<loop>> a few times recently with the threaded runtime
19:21:57 <johnw> trying to remember what caused it...
19:22:16 <hakujin> johannesbodannes: a little bit off topic but The Realm of Racket covers building a game in a mostly functional way. Racket is a lisp and dynamic but it'll at least show you how to think and you'll learn a bunch translating to Haskell
19:22:47 <johannesbodannes> I'll check that out too, ty
19:22:55 <levi> Also, check out elm-lang.org
19:22:59 <Cale> <<loop>> happens when a thunk is entered for a second time (i.e. you have some variable you're trying to evaluate, and during its evaluation you discover that you need to evaluate it)
19:23:35 <levi> It's got a few simple FRP game examples, and although it's not quite haskell, it's a bit closer to haskell than racket.
19:23:58 <Cale> The first thing which the code for a thunk does when entered is to rewrite the code pointer to point at the black hole which throws the <<loop>> exception
19:24:48 <Cale> In a multi-threaded setting though, that can also occur if multiple threads are both trying to evaluate something, so the black hole code is replaced by code which simply blocks and waits for the evaluation to finish
19:25:04 <Cale> (which saves duplication of effort)
19:25:56 <hakujin> Cale, are you familiar with the semantics of sequence . parMap rseq?
19:25:59 <Cale> There is a very slim chance, iirc, that two threads both evaluate an expression, if the second thread gets in before the code pointer gets rewritten
19:26:30 <Cale> hakujin: sure? What monad is that?
19:26:41 <hakujin> I want to use it with EitherT String IO
19:26:49 <Cale> It's a bit of a curious thing to be sequencing after the parMap.
19:27:00 <Axman6> that's probably not going to do what you want at all
19:27:09 <Cale> parMap is only going to *evaluate* in parallel
19:27:15 <hakujin> and threadscope is throwing an error when I analyze the event log so I'm not sure if it's actually doing the work in parallel
19:27:27 <Cale> Remember that evaluating an IO action does nothing user-visible
19:27:44 <hakujin> yeah that's what I was afraid of
19:28:06 <Cale> What do you actually want to do?
19:28:34 <Cale> Evaluation just consists of reducing expressions to values
19:29:03 <Twey> levi: cycle [1, 2, 3] is never going to do it — that's even productive :þ
19:29:12 <Cale> IO actions are values which abstractly represent things which could be done in order to (potentially) make some I/O happen before producing a result
19:29:20 <hakujin> the function I'm passing parses a line of Text, then does a few database lookups
19:29:39 <Cale> So you'd just be figuring out which things to do (in parallel), and then executing each of them in sequence.
19:29:49 <hakujin> ideally I want to have a thread for every line in the file and let them block on the connection pool
19:30:51 <Twey> hakujin: Can you not use async for this?
19:30:55 <Cale> You might use the async library, yeah
19:31:05 <hakujin> it's all the same under the hood yeah? forkIO and friends?
19:31:07 <Cale> Or even just plain forkIO
19:31:25 <Twey> hakujin: Yeah, but async saves you having to do the communication yourself
19:31:29 <Cale> But async is possibly more convenient when the things you're doing concurrently have results.
19:32:19 <Cale> You could use mapConcurrently from the async package
19:32:26 <hakujin> ideally I'd use mapConcurrently but...haha yep
19:32:51 <Twey> But?
19:33:46 <hakujin> how does mapConcurrently work when you're inside something like ReaderT (Pool Connection) (EitherT String IO) a?
19:33:51 <Cale> If your problem is the EitherT, just don't use EitherT. Make a new exception type and throw that, and then wrap the mapConcurrently in a catch.
19:34:11 <Twey> hakujin: liftIO
19:34:20 <Eduard_Munteanu> hakujin: it doesn't really... unless you use lifted-base and such
19:34:26 <Cale> and ReaderT is rather trivial as well
19:34:41 <Cale> If you need the connection pool, just pass it as a parameter explicitly instead
19:35:02 <Eduard_Munteanu> hakujin: that is, you'll need to reconstruct your transformer stack somehow, or do away with it
19:35:44 <hakujin> gotcha. thanks for the answers
19:35:56 <Cale> <-- Head of the Society of People Who Think Monad Transformers Over IO Are Overrated
19:36:24 <thebnq>  > tail cale
19:36:34 <Twey> Heh
19:36:46 <scshunt> <-- Head of the Society of People Who Love Haskell But Can't Design Haskell Applications For Their Lives
19:37:13 <hakujin> Cale: primary use is to avoid a ton of case x of statements when dealing with IO right? how do you avoid your code nosediving off to the right?
19:37:13 <haasn> <-- Head of the Society of People Who Think Lenses Are Underrated
19:37:23 * Eduard_Munteanu applies some tail cale optimization
19:37:38 <scshunt> haasn: I am a member of your society, but am not sure that it's for the right reasons
19:38:14 <Eduard_Munteanu> hakujin: exceptions are sometimes nice
19:38:19 <Cale> Isn't the hype train for lenses pretty much full speed ahead?
19:38:29 <haasn> Cale: in Haskell maybe :)
19:38:30 <lispy> Cale: yeah
19:38:45 <haasn> non-Haskellers are still talking about monads. Those are so 90's
19:38:52 <thebnq> haha
19:38:56 <simpson> <-- Head of Society for Secretly Advancing Dynamically-Typed Languages in #haskell
19:38:57 <Cale> Well, lenses are almost certainly a terrible idea in most other languages.
19:39:15 <Cale> At least van Laarhoven lenses are
19:39:38 <hakujin> Eduard_Munteanu: I'm interested! when do you chose exceptions over types like Maybe/Either when designing? I can certainly see the use in my transformer stack/mapConcurrently example
19:39:43 <Cale> Perhaps simple get/set records would work okay
19:40:09 <johnw> hakujin: one way is to use Maybe/Either and exceptions to distinguish expected failure from unexpected failure
19:40:22 <scshunt> Part of the reason that they're a bad idea in other languages is that the idioms are more naturally expressed in other ways
19:40:25 <Eduard_Munteanu> hakujin: I'm not really sure either... note that if you're using stuff like "error" you're already using exceptions, sort of. :)
19:40:25 <scshunt> such as int*
19:40:42 <scshunt> :P
19:41:03 <Cale> Whether to use IO exceptions or Maybe/Either is more a matter of how likely you think it is your user is going to want to explicitly deal with that condition.
19:41:24 <kristof> Cale: Don't most languages already have lenses in the form of getters and setters? :P
19:41:31 <Cale> kristof: no
19:41:32 <levi> There's an implementation of the general idea of lenses for unix configuration files called Augeas.  It's pretty interesting.
19:41:40 <lispy> Cale: I feel like this sums it up: https://twitter.com/PLT_Borat/status/228009057670291456
19:41:41 <Eduard_Munteanu> IO exceptions unfortunately don't encode exceptions in thrower types.
19:41:46 <kristof> Cale: maybe they're not as composable, per se
19:41:51 <johnw> kristof: a lens is both a getter _and_ a setter
19:41:53 * lispy is lens neutral
19:41:55 <Cale> Using error from non-IO code is only for cases where you know you want the whole program to die if that case ever happens.
19:42:08 <johnw> I've been using lenses more and more lately; they really help with ginsuing Maps
19:42:16 <Eduard_Munteanu> So in that sense, they're somewhat inferior to EitherT.
19:42:27 <scshunt> kristof: The key difference is that a lens abstracts
19:42:38 <scshunt> It's more akin to a member pointer in C++, though more powerful
19:42:39 <Eduard_Munteanu> johnw: "ginsuing"?
19:42:48 <johnw> like ginsu knives, they cut anything
19:43:17 <kristof> scshunt: ok.
19:43:18 <haasn> Cale: (I haven't actually given it a terrible lot of thought) Why is this? Obviously ‘lens’-style Lenses won't work in pretty much any type system other than Haskell's, but the general idea of composable traversals would be pretty useful
19:43:19 <Cale> kristof: Yeah, the whole point of lenses is that they 1) involve no mutation of anything and so help you in the case where you need persistence of the old structure, and 2) they're composable
19:44:09 <Cale> haasn: Well, you can get the very basic sort of lenses going with a good deal less. The type system machinery that you need is just a bit fancy.
19:44:10 <scshunt> A lens is "some way to find a Foo inside a Bar"
19:44:10 <kristof> Cale: Welllll ok, you're right
19:44:32 <kristof> What are some cool things people have done with lenses?
19:44:39 <haasn> Cale: to be fair, the type system machinery is mainly useful in making everything work for everything
19:44:46 <Eduard_Munteanu> Where Foo may be a complex thing not necessarily structural with respect to Bar.
19:44:50 <scshunt> ^
19:45:27 <kristof> Eduard_Munteanu: I can see the power, I just haven't seen any concrete examples before
19:46:24 <haasn> kristof: my main lens use case seems to be “reducing these 4 lines of code that do some work with some arbitrary data structure into three names and two operators”
19:47:08 <haasn> that is, it allows you to write much more concise, declarative and composable (and often confusing) code to work with data structures
19:47:34 <johnw> kristof: here's a real world example of where lenses helped in our code: kristof he
19:47:36 <johnw> https://gist.github.com/8969371
19:47:51 <haasn> the other big advantage I get from ‘lens’ is its incredible wealth of functions - you can write a single lens for your data type and get a billion different standard functions on it for ‘free’
19:47:51 <kristof> johnw: "our code" where?
19:48:01 <johnw> fpcomplete.com
19:48:06 <kristof> johnw: ah :)
19:48:13 <Cale> hakujin: I think it's somewhat of a shame that we don't see more use of the IO exception system, because it's really quite nicely designed. It's just that Haskellers are very much the sort that usually want to handle errors in a very exact fashion, so we expect that just producing Either will be more convenient.
19:48:16 <kristof> fpcomplete.com is awesome
19:48:18 <johnw> in that gist, that 1 line of lens code would otherwise require those 4 lines of regular Haskell
19:48:54 <haasn> and the built-in lenses like ‘base’, ‘bits’ and so on are really useful for every-day work. lens has become my go-to solution for base conversions, binary inspections of numbers,e tc.
19:48:56 <johnw> which if you didn't care about <80 char lines could be squashed down to 1 really long line of course
19:49:24 <Eduard_Munteanu> Cale: meh, the way they currently are makes those functions partial with no hint in the type
19:49:24 <haasn> Oh, speaking of exceptions; kristof: a really cool example of lens in action is http://ekmett.github.io/lens/Control-Exception-Lens.html
19:50:12 <haasn> catching_ (_Overflow <> _Underflow <> _DivideByZero) $ do ....
19:50:17 <kristof> johnw: Ok, that was a pretty good example
19:50:43 <kristof> haasn: that is really, really concise
19:51:31 <haasn> you can even mix and match different exception types like that, if you're a bit more careful ;)
19:51:53 <levi> I need to learn those bits johnw's example uses. I have a bunch of set/map update code that could stand to be a bit more concise.
19:52:22 <kristof> haasn: <> is mappend related, right?
19:52:32 <haasn> kristof: it is precisely mappend
19:52:33 <Cale> johnw: Tell your CEO to stop writing vague cringe-worthy articles about the benefits of Haskell :S
19:52:50 <haasn> as I said, lens in action ;)
19:53:15 <kristof> haasn: I hate infix operators :(
19:53:30 <haasn> lens has prefix names for everything! Well.. almost everything
19:53:40 <Cale> Even if I think everything in this is true, I don't think it's a good way to try to popularise the language: http://venturebeat.com/2013/10/11/stop-wasting-billions-of-dollars-using-the-wrong-software-languages/
19:53:52 <kristof> lol
19:54:01 <kristof> just the title of that article is so... provocative
19:54:16 <haasn> Not quite sure what the name for (<<%@~) is, but if we pester edwardk enough I'm sure we'll be able to find one
19:54:18 <partycoder> Cale, the problem is hiring developers
19:54:39 <partycoder> if you want to ramp up quickly it is hard to get competent haskell expertise
19:55:10 <partycoder> and many of them won't be happy working on non-challenging things
19:55:27 <hakujin> partycoder: seems like that's a problem for hiring good engineers; not haskell specific
19:55:37 <Cale> partycoder: Yeah, it can be hard to find someone who knows Haskell and is also willing to write Javascript, for instance ;)
19:55:38 <kristof> haasn: what does that even do?
19:55:41 <levi> It seems to be the job of CEOs to say cringe-worthy things.
19:55:48 <Cale> partycoder: Though I'm sure you could find a bunch of people here who would be willing to jump on a Haskell position.
19:55:56 <partycoder> that's true, but
19:56:15 <Cale> (but can you afford them?)
19:56:28 <partycoder> all you say is true, the problem is
19:56:37 <partycoder> other paradigms have a lower entry barrier
19:56:38 <johnw> levi: sadly, I don't think lens works with Set
19:56:50 <johnw> Cale: you tell him! :)
19:56:52 <Cale> johnw: :D
19:56:53 <partycoder> in theory
19:56:55 <johnw> Cale: plus, you and I have had this discussion before :)
19:57:12 <partycoder> because haskell can be didactical if taught properly
19:57:18 <levi> johnw: Hmm, yeah, I remember that now. But most of the mess is in the Map updates.
19:57:18 <Cale> johnw: Yeah, I just saw this article and thought to mention it again :)
19:57:40 <haasn> kristof: the mnemonics are:  the << at the left means “return the original value as well”, the “%” stands for some form of “modify” (% as in ‘mod’), the @ stands for “indexed version of this operator” and the ~ stands for “pure result” ie. a regular function (as opposed to = which operates inside a MonadState)
19:57:51 <johnw> levi: map updates are so easy with Map that it becomes a reason to include lens as a dependency for me now
19:57:56 <johnw> with lens, I mean
19:58:11 <haasn> so overall: modify the target of an indexed lens, returning the old function as well
19:58:21 <Cale> partycoder: I don't think people have had much trouble filling Haskell programmer positions in practice, but then again, the number of such attempts is also comparatively small.
19:58:23 <haasn> the old value*
19:58:54 <haasn> johnw: “contains” works with Set
19:59:12 <johnw> haasn: nice!
19:59:17 <haasn> > S.fromList [1,3,7] ^. contains 3
19:59:19 <lambdabot>  True
19:59:22 <haasn> > S.fromList [1,3,7] ^. contains 4
19:59:23 <lambdabot>  False
19:59:26 <levi> johnw: BTW, you maintain the fpco library that sits on top of gitlib2, right? I haven't seen any consumers of it (outside of your IDE stuff, of course); I was curious whether it's in a mature state or still rapidly evolving.
19:59:33 <Cale> partycoder: Also, there are various places where they're giving Haskell EDSLs to semi-technical people and having them pick up the language as they go with quite a bit of success from what I've heard.
19:59:46 <johnw> levi: which, gitlib?
19:59:48 <haasn> > S.empty & contains () .~ True -- even updates! :)
19:59:50 <lambdabot>  fromList [()]
19:59:56 <partycoder> i've heard success stories using haskell as first language as well
20:00:13 <levi> johnw: I think that's it?
20:00:13 <johnw> levi: ah, you were meaning to say libgit2
20:00:22 <johnw> levi: yes, gitlib is fairly mature, I just released 3.0 this week
20:00:28 <levi> Oh yeah, libgit2.
20:00:49 <johnw> gitlib-libgit2 is the bridge between gitlib and hlibgit2
20:01:01 <johnw> there is a #gitlib, if you ever want to discuss anything
20:01:19 <levi> OK, I'll keep that in mind.
20:02:08 <johnw> levi: I also use gitlib to power "git-monitor", which I personally rely on every day
20:02:53 <kristof> haasn: How do you return the original value of something *and* the modified one?
20:03:06 <johnw> My git-monitor window at this moment: https://www.dropbox.com/s/06qudstae9etlej/Screenshot%202014-02-12%2021.58.21.png
20:03:15 <haasn> kristof: the only thing that would make sense is <<<  :)
20:03:20 <kristof> oh
20:03:22 <levi> I've been pondering a simple gitolite-style replacement thing for a while, or at least a simple management tool for it.
20:03:25 <haasn> (that isn't an actual prefix, sadly)
20:03:27 <kristof> I was thinking of Common Lisp's multiple value return
20:03:28 <haasn> ask edwardk!
20:03:46 <hakujin> Cale: I feel pretty strongly that encoding failure in the type rather than reading "this function throws Exception X on failure" in the haddock is going to produce better software
20:03:49 <haasn> the < << stuff is more of a little convenience imo; I've never really used it in a really elegant way
20:03:56 <johnw> kristof: you use tuples generally, and unpack them on the caller side
20:04:09 <hakujin> Cale: in what situations do you see IO Exceptions being really nice?
20:04:22 <haasn> the < << stuff does use tuples, if that's what you were asking
20:04:38 <Cale> hakujin: Well, sure, it's often nice to have that information in the type, and that's why we don't use them so much.
20:05:58 <Cale> hakujin: The reason I think the library is nice isn't so much that I really like having imprecise types, but the fact that it really nicely handles the problem of allowing arbitrary refinements and extensions of the hierarchy of exceptions.
20:07:05 <Cale> hakujin: You can take any set of exceptions and define a new exception type such that catching that type will catch any of the exceptions in your given set. You can also take any exception type and refine it, defining a new type to only catch exceptions from the old one satisfying particular conditions.
20:07:31 <hakujin> I'm listening and learning, please continue
20:07:55 <Cale> http://lpaste.net/99852
20:08:10 <Cale> This is a little example I did to show how to split up IOError after the fact :)
20:08:55 <Cale> If you throw AlreadyInUse, it's the same as throwing the original IOError. If you catch AlreadyInUse, it'll only catch that particular IOError.
20:09:51 <Cale> http://lpaste.net/99853 -- and here's another example of how you can do a union
20:10:41 <Cale> The idea is that catching Either e1 e2 will attempt to catch either of those exception types (and it's a bit Left-biased, in that if the left one succeeds, that's what you'll catch)
20:12:06 <hakujin> couldn't you mimic that behaviour in a way by using something like Either Exception a and pattern matching for the constructors you cared about?
20:12:12 <Cale> hakujin: So, I just think it's a shame that this really nicely flexible system kind of goes to waste. Of course, you could still use it with Either, for sure.
20:12:30 <Cale> (but people tend not to do that)
20:12:41 <thebnq> is it serious when a lens is described as a coalgebra for costate comonad?
20:12:56 <Eduard_Munteanu> thebnq: yes
20:13:06 <StoneCypher> coyes
20:13:14 <kristof> ...now I have to go look up what a costate comonad is
20:13:20 <kristof> must be an instance of a coburrito
20:13:22 <Eduard_Munteanu> kristof: store comonad
20:13:26 <kristof> Eduard_Munteanu: ok
20:13:36 <thebnq> hehe i'll get to it one day
20:13:39 <Eduard_Munteanu> hakujin: note certain things, IO-specific bits, can't be done with Either
20:13:40 <Cale> Yeah, calling it 'costate' is almost intentionally unhelpful
20:14:15 <StoneCypher> sometimes i think not speaking haskell at all is a great way to get extra humor out of these conversations.  it's going to make me sad when i get my act together and learn what any of this means.
20:14:50 <Eduard_Munteanu> hakujin: e.g. how do you handle a divide by 0, which isn't even IO-specific?
20:15:14 <johnw> Cale: heh, I found a webpage which says "The store comonad (better known as the costate comonad)", and I wonder, by whom?
20:15:23 <Cale> Eduard_Munteanu: Well, you *could* handle division by 0 with Either, it would just be *super* obnoxious
20:15:50 <Eduard_Munteanu> Cale: wrap all number operations in an IO-like monad? :)
20:16:09 <hakujin> Eduard_Munteanu: I suppose you could make something like div return Either ThisIsTerrible Int or soemething
20:16:20 <Cale> Eduard_Munteanu: no, just  (/) :: Fractional a => a -> a -> Either NumericalException a
20:16:23 <hakujin> I agree with Cale haha
20:16:40 <kristof> Eduard_Munteanu: Can a zipper be considered a costate comonad?
20:16:54 <Eduard_Munteanu> That won't work because by the time you get an exception from the OS it's too late.
20:17:02 <Cale> kristof: It's vaguely like that
20:17:15 <Cale> kristof: But a zipper implies a lot more generally
20:17:15 <hakujin> Eduard_Munteanu: you'd pattern match on the dividend before the division
20:17:17 <kristof> hmmm, I thought it would be more than vaguely
20:17:26 <Eduard_Munteanu> kristof: yeah, zippers are comonads
20:17:29 <kristof> Cale: sure, but I was simply talking about having a collection of values and being able to move a position throughout the store
20:17:35 <Guest98746> kristof: yes, zipper... never mind
20:17:51 <Guest98746> er
20:17:58 <ReinH> well that was weird
20:18:03 <Cale> newtype Store s a = S (s -> a, s) -- so yes, this is like a "value of type a with a hole of type s in it, together with a filler for that hole"
20:18:22 <kristof> now you're making it sound like a continuation
20:18:26 <Cale> But the whole thing about differentiation is missing.
20:18:29 <Eduard_Munteanu> kristof: however costate / store refers to a specific construction (s -> a, s), just like State refers to s -> (a, s)
20:18:36 <ReinH> kristof: have you seen edwardk's cellular automata thing?
20:18:44 <kristof> heard of it
20:18:47 <kristof> oh, I have seen that
20:18:49 <kristof> game of life?
20:18:50 <ReinH> kristof: well check it out
20:18:51 <ReinH> yes
20:18:54 <kristof> yeah, I saw it
20:18:56 <kristof> it was cooooooool :)
20:18:56 <levi> Cale: The original presentation of zippers didn't include the derivative stuff either.
20:19:06 <johnw> and from what Eduard_Munteanu said, you may be able to see how the adjunction is flipped, from -> outside of , to , outside of ->
20:19:07 <ReinH> kristof: well that's a store
20:19:09 <kristof> ReinH: but if I see the word "extend" ever again :P
20:19:10 <kristof> ok
20:19:11 <Cale> levi: But it was there :)
20:19:41 <Cale> The bit with the hole is just a function, rather than an algebraic data structure of a related type
20:19:55 <levi> I see what you mean.
20:20:09 <ReinH> kristof: I love that the "universe" is the function `(==) 0'. It's so clever and elegant
20:20:19 <ReinH> kristof: er, not game of life
20:20:26 <ReinH> kristof: wolfram coded cellular automata
20:20:36 <ReinH> but you could use a similar concept for GoL
20:20:55 <Cale> ReinH: Don't you mean Dan Piponi's thing?
20:21:00 <levi> I've run across some comonadic GoL implementations while googling.
20:21:20 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
20:21:22 <ReinH> Cale: I am referring to https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1
20:21:25 <levi> Cale: edwardk did a series on School of Haskell
20:21:29 <ReinH> Cale: maybe kristof is referring to that :)
20:21:50 <ReinH> Cale: I worked with edwardk on his cellular automata port
20:21:52 <Cale> Oh, okay
20:21:53 <ReinH> post
20:22:04 <ReinH> which is to say I write something similar in a non-comonadic way then he made that
20:22:06 <kristof> ReinH: I was
20:22:20 <Cale> Yeah, this is a modernised version of that idea :)
20:22:22 <ReinH> kristof: well check out my link too :)
20:22:31 <ReinH> it's a nice example of Store in practice
20:23:35 <roboguy_> > (map (:[]) [1..5]) & indexing traverse <<%@~ (\i x -> (i,x))
20:23:37 <lambdabot>  ([1,2,3,4,5],[(0,[1]),(1,[2]),(2,[3]),(3,[4]),(4,[5])])
20:23:42 <scshunt> Cale: I'm once again stymied by my own failure at deisng, either because I'm thinking too much or too little. I have a "kind" Foo (by which I mean it is a class of things which I am trying to implement either as a typeclass as a type), which I feel is better implemented as a typeclass. However, some Foos will refer to other Foos. If Foo is a type, then I just give it a field of type Maybe Foo and I'm done. But if it's a typeclass, I need ...
20:23:48 <scshunt> ... dependent types for this if the actual underlying type of the Foo may vary at runtime, even though I'm always using through the Foo abstraction, right?
20:23:51 <scshunt> *design
20:24:11 <Cale> scshunt: If in doubt, make it a datatype
20:24:36 <ReinH> roboguy_: o_O
20:24:44 <ReinH> roboguy_: clever use of a ridiculous operator :)
20:24:50 <scshunt> Cale: The trouble then is the lack of extensibility, sigh
20:24:55 <Cale> There's nothing wrong with good ol' functional programming with records of functions rather than type classes
20:25:02 <roboguy_> ReinH: I was trying to figure out <<%@~ since someone mentioned it (and indexed lenses in general)
20:25:09 <Cale> You get extensibility through defining new records.
20:25:23 <Cale> At least, any notion of extensibility you would have had from the type class.
20:25:38 <ReinH> scshunt: deisng is hard
20:25:52 <Cale> The only thing which type classes save you from is passing the records around explicitly.
20:25:52 <scshunt> ReinH: evidetnly
20:25:58 <ReinH> scshunt: sreiously
20:26:14 <Cale> and working out how to construct instances
20:26:23 <scshunt> I suppose. My understanding about the need for dependent types is correct, though, right? I can't have a function which returns "something which I promise you is an instance of Foo, but I'm not telling you what just now"
20:26:46 <Cale> I don't see how dependent types will help you there
20:26:57 <prophile> that sounds like existential quantification rather than dependent types
20:27:03 <Cale> Oh, are you just referring to existentials?
20:27:06 <scshunt> yeah
20:27:14 <Cale> Yeah, you can have those
20:27:18 <scshunt> oh, how?
20:27:19 <Cale> But you probably don't need them
20:27:24 <scshunt> it's possible
20:27:32 <Cale> Explain what you're trying to do and then we'll see :)
20:28:14 <Cale> Usually you can avoid the need for existentials by just having all that stuff be parameters to the function which constructs the record.
20:28:16 <scshunt> class Foo a where { bar :: a -> \exists b . Foo b }
20:28:28 <Cale> nonono
20:28:33 <Cale> what are you *actually* trying to do?
20:29:06 <Cale> (Without using 'foo' :)
20:30:46 <scshunt> I'm trying to create a parliamentary procedure framework. A motion may have a parent motion, which is fine because that can be worked out statically. But there may be a modifier placed on a motion that changes its properties and those of its parents, so the parent of a modified motion should be the parent of the underlying motion with the same modifier
20:31:16 <kristof> A+ for most interesting hobby program
20:32:07 <Cale> okay
20:32:37 <Cale> So the data you're trying to represent with your type is for an individual motion?
20:33:36 <scshunt> yes
20:34:09 <Cale> Okay, so if I have a motion, which things can I do with it?
20:35:01 <TallerGhostWalt> hmm what is the most snappy like library for haskell ?
20:35:12 <scshunt> Well, you can get at its parent. You can adopt it (which is a function on some universe state I haven't defined yet). You can put modifiers on it, some but not all of which may propagate up to parents.
20:35:23 <scshunt> you can query a number of properties that aren't very interactive
20:35:31 <scshunt> (i.e. are just Motion -> Foo)
20:36:54 <Cale> scshunt: Okay, so, let's consider something like   data Motion = M { parentMotion :: Motion; applyModifier :: Modifier -> Motion; boring :: Foo }
20:37:24 <Cale> oh, right adopt
20:37:42 <Cale> data Motion = M { parentMotion :: Motion; applyModifier :: Modifier -> Motion; adopt :: Universe -> Universe; boring :: Foo }
20:37:52 <scshunt> Cale: Now the issue is if I want to put in a bunch of extra data for some, but not all motions. I would have to add a new constructor with that data, and abstract away the fields of each, right?
20:38:06 <Cale> scshunt: *Maybe*
20:38:12 <prophile> what extra data
20:38:19 <dmj`> think I found a bug in ghc
20:38:31 <dmj`> data A = Hey { k :: Double } | J Int { k :: Double }, crashes on OSX, tc_hs_type: record
20:38:35 <Cale> scshunt: You can always have additional *private* data. It's only if you want to change this interface that you need to adjust things.
20:38:55 <Cale> dmj`: hah, wow
20:39:03 <Cale> I'd never have thought to test that syntax
20:39:13 <scshunt> Cale: I think there's an extension to make that legal?
20:39:26 <dmj`> Cale :) :)
20:39:45 <shachaf> @let data A = A Int {}
20:39:45 <lambdabot>  Parse failed: Parse error: {
20:39:48 <dmj`> Cale: should I submit a ticket?
20:39:52 <Cale> yes
20:39:58 <scshunt> oh, another important piece of interface is text :)
20:40:04 <Cale> It should certainly print a better error message than that
20:40:05 <shachaf> Hmm, that crashes my ghci.
20:40:25 <scshunt> Cale: I see where you're getting at, though
20:40:42 <thebnq> woah a bug!
20:40:45 <scshunt> rather than making the motion necessarily contain all the data, I can have a creation function which populates the interface
20:41:02 <roboguy_> dmj`: it doesn't crash 7.8
20:41:37 <Cale> scshunt: Right, this is what I consider to be the central idea of OOP, even if a lot of OO people wouldn't recognise it as such :)
20:41:52 <dmj`> roboguy_: Oh, should I still submit it then? Does any do patches for 7.6.3
20:41:56 <dmj`> anyone*
20:42:21 <haasn> dmj`: fixed in HEAD
20:42:27 <Cale> scshunt: The idea that we can have values which are determined by the way that certain methods are implemented, or equivalently, the way in which they respond to certain messages.
20:42:28 <haasn> oh, roboguy_ already mentioned
20:42:48 <haasn> dmj`: don't submit a ticket then, 7.8 is coming Soon(tm) and they already know about it if it's fixed
20:42:48 <scshunt> that
20:42:56 <scshunt> *that's type polymorphism generally, isn't it?
20:43:15 <Cale> Well, this is a very different sort of polymorphism from parametric polymorphism
20:43:18 <dmj`> haasn: k cool
20:43:42 <Cale> Remember, all the values here will have the same type :)
20:44:01 <Cale> It's just that this type is sufficiently general to capture all the things we want to be able to do with those values
20:44:28 <Cale> From Haskell's perspective, this isn't even polymorphism :)
20:44:55 <haasn> I wonder if it's worth making a distinction between “value polymorphism” and “type polymorphism”; the former meaning that values can have different forms (3, 4, 5, ...; True, False; lists of different lengths; functions which respond to messages differently) and the latter meaning that the types involved can have different forms (Maybe Int, Maybe String, Maybe (Maybe (Maybe Bool)))
20:45:03 <Cale> But in most OO languages, they foolishly tie the implementations of the methods to the type system.
20:45:24 <Cale> and so you *must* use subtype polymorphism in order to have different implementations of methods
20:46:03 <Cale> But of course, in Haskell, we have first class functions, so we don't have any such constraint :)
20:46:19 <scshunt> Cale: But, say, C++ does have first-class functions-ish
20:46:36 <Cale> If it does, that's something new :)
20:46:44 <scshunt> (I say ish because they technically aren't first class, but are approximated perfectly)
20:46:44 <Cale> which wasn't around when the language was being designed
20:46:48 <scshunt> it is
20:46:56 <scshunt> then again, C++ calls itself multi-paradigm
20:47:01 <AshyIsMe> function pointers?
20:47:12 <Cale> AshyIsMe: Nah, you need better than function pointers
20:47:14 <scshunt> AshyIsMe: I was thinking std::function
20:47:33 <scshunt> which more properly abstracts "thing that takes some inputs of these types: ... and gives you output of this type: ..."
20:47:49 <Cale> You need functions which capture the values of free variables in their body when you define them.
20:47:59 <prophile> C++ has lambdas now
20:48:14 <scshunt> though they're still limited by lifetime rules
20:48:14 <prophile> it's almost turing complete
20:48:18 <Cale> (or probably better to call them procedures since a real notion of functions in C++ is a hopeless cause)
20:48:20 <haasn> AshyIsMe: a function pointer alone won't help much unless you either package it together with closed values or have the separate ability to allocate new functions at runtime
20:48:34 <TallerGhostWalt> i'll just use snappy
20:48:38 <scshunt> they can either refer directly to the outer value, or create a copy of the value, but not both
20:48:42 <Cale> TallerGhostWalt: wtf is snappy?
20:49:04 <Cale> TallerGhostWalt: oh, this? http://hackage.haskell.org/package/snappy
20:49:29 <TallerGhostWalt> Cale: yeah
20:50:30 <ski> scshunt,Cale : "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> might be interesting, in case you've not seen it before
20:50:47 <scshunt> I have not. thanks
20:50:48 <ski> (re OO vs. ADTs)
20:51:05 <Cale> I don't think I've seen it either
20:51:16 <roboguy_> Cale: you can capture variables with C++11 lambdas
20:51:41 <roboguy_> you just have to explicitly specify which you are capturing
20:51:41 <Axman6> roboguy_: you have to be explicit about which ones you capture though right?
20:51:46 <roboguy_> yeah
20:51:57 <ski> scshunt : it's sortof an update on "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>, which is a classic
20:52:25 <ski> roboguy_ : like in Prolog :)
20:53:28 <AshyIsMe> haasn: yeah, lucky we don't have to use c++ here :P
20:54:14 <Cale> Of course, that's all a bit of a moot point, since it's much too late to be redesigning the OO features of C++
20:54:30 <TallerGhostWalt> My favorite thing about Haskell, is when I make a change to a record and poof EVERYTHING I need to do is right in front of me
20:54:44 <Cale> TallerGhostWalt: yes!
20:55:43 <Cale> TallerGhostWalt: I've gone through refactorings of that sort which involved hundreds of changes to an 8000 line library, where I just kept steamrolling GHC over the code and fixing up what it told me to for an hour or two, and then had the code actually work once it finally compiled again :)
20:56:03 <jfischoff> TallerGhostWalt: totally
20:56:33 <Cale> You can do refactorings which you would never ever dare attempt in a million years in a dynamically typed language.
20:57:05 <jfischoff> it so much easier to let new people loose on the code base
20:57:28 <prophile> Cale: I would content that a good test suite makes that feasible even in the most dynamic of languages
20:57:41 <jfischoff> fixing their stuff isn't that bad
20:58:08 <Cale> prophile: hah, I don't know about that
20:58:10 <jfischoff> prophile: haven't seen that work out
20:58:43 <prophile> I hear a string of success stories with Ruby and RSpec from some of my bearded, coffee-drinking friends
20:58:46 <Cale> prophile: It's hard to write enough tests to encode everything that the types do
20:58:47 <TallerGhostWalt> cale: yeah it is really cool
20:58:59 <Cale> prophile: yes, it's far better than nothing
20:59:21 <Cale> prophile: but it's nowhere near as good as having a type checker and a compiler to tell you *exactly* where every one of the problems is
20:59:30 <thebnq> writing simple tests feels like boring boilerplate
20:59:36 <scshunt> ski: not to be confused with Bill J. Cook, hah.
20:59:48 <Cale> Like, if there were just a bunch of tests, what would happen is I'd make the initial change, and then run the test-suite, and it would tell me "everything is fucked"
20:59:49 <prophile> Cale: I agree, but that wasn't quite the original statement :)
20:59:57 <TallerGhostWalt> seems like a lot of ppl's tests end up being something like 3 should be 3
20:59:57 <Cale> and then I'd be like "okay"
21:00:05 <Cale> and revert the changes
21:00:10 <prophile> usually tests are a little more granular than "everything"
21:00:22 <Cale> prophile: well, all my tests would fail
21:00:37 <Cale> because I've just changed some central datatype which everything in the codebase uses
21:00:45 <Cale> and now I have to find all the places which need adjusting
21:01:05 <prophile> that's still a matter of walking linearly down a list of tests and tweaking until each one passes
21:01:08 <Cale> In Haskell, I run the compiler, and it tells me everything
21:01:30 <Cale> The test suite will tell me that everything's broken, but it won't tell me where the code is that needs to change. It won'
21:01:35 <Cale> It won't give me line numbers
21:01:41 <jfischoff> We just switched test frameworks with no issues, not so easy in our PHP code base.
21:02:23 <prophile> it's a lot more poking about and detective work I grant, but it's perfectly possible
21:02:36 <Cale> Well, in some cases I might get line numbers, but in my experience, the place where things go wrong at runtime is often *far* from where the actual problem is in the source.
21:02:51 <Cale> It's not feasible, and you wouldn't attempt the same things
21:03:17 <Cale> There are many things in dynamic languages which if proposed are just tantamount to complete rewrites.
21:03:38 <TallerGhostWalt> prophet: so wouldn't it be fair to say that static typing automates a lot of that?
21:04:05 <prophile> I'm assuming that was directed towards me? :)
21:04:08 <Cale> which you can manage as a refactoring if you have a compiler which knows a lot more about how things are meant to interact and can tell you precisely where that interaction is no longer appropriate
21:04:19 <TallerGhostWalt> lol
21:04:20 <TallerGhostWalt> yeah
21:04:22 <TallerGhostWalt> prophile!
21:04:25 <TallerGhostWalt> got it
21:04:27 <prophile> my claim here isn't that dynamic languages are easier for refactoring, because that's clearly not true
21:04:48 <prophile> just that large-scale refactoring is still perfectly possible
21:05:07 <Cale> I dunno, at least *I* wouldn't be daring enough to attempt some of the things I've successfully done in Haskell with say Python or Ruby.
21:05:28 <TallerGhostWalt> Ruby isn't dynamically typed is it?
21:05:35 <TallerGhostWalt> I mean it isn't all haskelly but still
21:05:45 <Cale> It is
21:05:46 <thebnq> its totally dynamic
21:05:49 <TallerGhostWalt> oh
21:05:51 <TallerGhostWalt> lol
21:05:53 <thebnq> ducktyping is scary
21:05:54 <Platz> Cale: A failing Clojure test will actually tell you which function produced such a value as an input to your method-under-test i.e. the code as data thing
21:05:56 <TallerGhostWalt> well there you go
21:06:40 <Platz> plus being able to inspect a running system via a repl has advantages
21:06:50 <dmj`> i <3 repl
21:07:01 <Cale> Well, of course, you have a repl in Haskell as well :P
21:07:06 <haasn> I have no idea what this conversation is about but I love hacking on projects I know absolutely nothing about, in Haskell. Want to extend an ADT with some functionality? Add the constructor, let the compiler automagically show you all the cases where you need to handle it in addition.
21:07:21 <Cale> haasn: That's exactly what this discussion is about
21:07:44 <thebnq> granted, its also fun running a changed project and seeing what breaks
21:08:05 <thebnq> but maybe only on a small scale would it be fun ):
21:08:10 <Cale> Of course, you can do that in Haskell too now, if you really want to
21:08:11 <haasn> need access to an extra parameter inside a big function? Add it, let the compiler enumerate all the call sites so you can figure out what to pass there
21:08:12 <TallerGhostWalt> I sort of feel like loose typing between binaries makes sense
21:08:16 <Cale> -fdefer-type-errors
21:08:35 <TallerGhostWalt> that way I don't have to have shared data definitions everywhere
21:08:51 <TallerGhostWalt> is that going to lead down a bad path?
21:08:53 <haasn> Cale: but that's not FUN, it just crashes! There's no weird behavior you need to spend hours debugging because it turns out you swapped two parameter
21:09:03 <Cale> haasn: :D
21:09:46 <Cale> Well, there are really fun bugs you can still get while programming in Haskell, it's just that for the most part you have only the very most interesting bugs.
21:10:27 <TallerGhostWalt> MVar bugs are the worst
21:10:29 <haasn> Sure, no language can prevent the error of “the correct code I wrote isn't the problem I wanted to solve”
21:10:46 <AshyIsMe> even just the small amount of haskell ive done has been so much nicer than nodejs in that regard
21:11:11 <AshyIsMe> make a change, save the file, syntastic in vim shows me everywhere that i forgot to fix up
21:11:27 <haasn> static analysis can help a bit with that, but it also won't save you from “the static properties I thought my solution would have were wrong” ;)
21:11:30 <AshyIsMe> versus with node where you run the app and manually find the crashes
21:11:34 <colDrMcBeardman> duck typing causes more problems than it solves.
21:11:39 <haasn> Cale: the best bugs are precedence bugs
21:11:44 <AshyIsMe> and then never feel like anything is solid
21:12:27 <haasn> I remember reading about a precedence bug that interpreted an x `op` y >> handle  as x `op` (y >> handle) instead of (x `op` y) >> handle -- or something similar
21:12:30 <TallerGhostWalt> Oh and also there is the huge amount of time you spend fixing cabal hell
21:12:32 <haasn> so the ‘x’ case was unhandled
21:12:33 <TallerGhostWalt> at least me
21:12:37 <TallerGhostWalt> That isn't fun
21:13:33 <colDrMcBeardman> TallerGhostWalt, huzzah, sandboxes, the 80 per cent solution.... 80 per cent of your disk space.
21:13:44 <Cale> :D
21:15:25 <Cale> Disk space efficiency is old-fashioned
21:15:57 <colDrMcBeardman> Cale, yeah, i'm being hahaonlyserious
21:16:09 <TallerGhostWalt> ha
21:16:20 <Cale> I download maybe 1-2 TV shows almost every day, at about ~250-500MB a piece, and almost never bother to delete anything
21:16:39 <TallerGhostWalt> right but I mean sandboxes don't completely solve the problem
21:16:43 <colDrMcBeardman> although my Tuxbook pro is six years old now and after a few seasons of HD tv shows... wow, i'm hitting that wall there real soon
21:17:08 <colDrMcBeardman> TallerGhostWalt, no, they just make it so that when you solve it for project A, you don't have to nuke project B
21:17:14 <colDrMcBeardman> hence the 80 per cent solution.
21:17:18 <Platz> on the Software Engineering Radio podcast I had to laugh with ths db expert said basically all 'traditional' DB are optimized for the wrong thing now that data doesn't have to live on hard disks
21:17:42 <TallerGhostWalt> Platz: nice
21:17:53 <TallerGhostWalt> oh, yeah but that 20% is a bear
21:18:08 <Cale> Power outages are still kind of a thing
21:18:18 <ski> scshunt : dunno who that is
21:18:39 <colDrMcBeardman> lulz. SSDs? My new new rotating elevator algorithm is useless? NOOOO!
21:18:59 <scshunt> ski: one of the four bills
21:19:26 * ski doesn't know what "the four bills" is ?
21:19:36 <scshunt> http://ca.wiley.com/WileyCDA/WileyTitle/productCd-047155894X.html
21:19:37 * ski . o O ( bill of rights )
21:19:59 <colDrMcBeardman> ski, see also: bill of attainder. fun things, those.
21:20:07 <Platz> http://www.se-radio.net/2013/12/episode-199-michael-stonebraker/
21:20:44 <Cale> heh, do people refer to Alexander Schrijver as "Bill" too?
21:20:47 * ski places colDrMcBeardman under attainder
21:20:55 <scshunt> ski: lex schrijver was made an honourary bill for the occasion
21:21:32 <AshyIsMe> Cale: you don't have ssds then?
21:21:45 <colDrMcBeardman> Platz, for some reason that made me think of some presentation i saw on how to do lock-free things in C++ and how far backwards they had to bend over.
21:21:55 <Cale> AshyIsMe: I actually don't have an SSD in my machine
21:22:17 <Cale> AshyIsMe: But I do have 16GB of RAM which I fairly often put to use via /dev/shm
21:22:18 <AshyIsMe> you should, it's an amazing speedup
21:22:41 <colDrMcBeardman> building in a ram fs is the best.
21:23:04 <Cale> hehe, Path of Exile loads really quickly if you put the 6GB Content.ggpk into /dev/shm and symlink to it
21:23:16 <Platz> colDrMcBeardman: lock-free data structures do sound difficult to implement, i'm guessing
21:23:46 <colDrMcBeardman> Platz, particularly in a language that doesn't focus on controlling effects.
21:23:48 <Cale> (and it actually fixes some performance issues that exist under Windows but which are made somewhat worse by Wine)
21:25:06 <colDrMcBeardman> Cale, i remember in the goode olden days they made PCI cards that had batteries and DIMMs so you could put your OS install on solid state
21:25:23 <colDrMcBeardman> then pray to the flying spaghetti monster the battery never died....
21:29:33 <Cale> Does anyone know of an elementary development of matroid theory which is in a modern categorical style?
21:30:42 <Cale> It seems like most treatments of matroids either don't mention mappings between matroids at all, or relegate them to much later in the development of the subject and don't really treat them as something central, which it seems like they *ought* to be.
21:33:53 <Cale> *crickets* :D
21:36:10 <Platz> Went looking for the defacto 'Category Theory' app for ios and android.  None found.. That's what I call opportunity!  I did find 'Category TherAppy' though
21:37:59 <c_wraith> what would a category theory app do?
21:38:05 <thebnq> if only it was more convenient to haskell on android
21:38:38 <Platz> c_wraith: not sure.. first step is market research
21:39:31 <haasn> c_wraith: ncatlab, wherever you go!
21:39:50 <haasn> with voice recognition and dictation functionality
21:40:50 <shachaf> Category theory on the train. Commute while you commute!
21:41:08 <haasn> Order now and get the free theorem app for free
21:41:26 <Cale> maybe an android port of https://github.com/ericfinster/orchard
21:42:24 <Cale> (see the videos if you want an idea of what that's about, it's actually pretty cool)
21:50:21 <Platz> the stereo-effect hum of the fan in those videos is mesmerizing.
21:51:21 <thebnq> i actually just paused, thinking it was my computer
21:55:36 <randomclown> does -threaded usually give a performance boost to programs that use forkIO a lot?
21:57:53 <dmj`> The threaded runtime system provides the following beneﬁts:
21:57:54 <dmj`> • It enables the -N RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine
21:57:55 <haasn> that would depend on the program, I'd say; you can still have sequential behavior no matter how many threads you are running if they have linear dependencies
21:58:40 <haasn> it's certainly possible to get a straight up benefit from just enabling -threaded; but I wouldn't take anything as a golden blessing or “make my program go faster” flag
22:00:04 <randomclown> do you usually compile with -threaded?
22:02:18 <Kaidelong> what are the chances of wxhaskell or gtkhs making it into haskell platform?
22:02:24 <randomclown> 0
22:02:33 <Kaidelong> that's a shame, it'd get rid of a lot of headaches
22:02:59 <Kaidelong> one thing about .NET is that you have blessed UI libraries
22:03:17 <randomclown> I like the Java UI libraries, they do OO properly
22:03:26 <Kaidelong> or java
22:03:30 <Kaidelong> or even tcl
22:03:40 <randomclown> with .net you manually add branches to the damn trees, java you just make a treemodel
22:03:58 <Kaidelong> "manually add branches to the trees?"
22:04:16 <Cale> randomclown: If you're using threads, it typically makes sense to build with -threaded
22:04:42 <haasn> randomclown: I don't, personally, unless I'm compiling something like repa or gloss (which says you want -threaded in the documentation). -threaded would definitely make sense if you're using sane `par` annotations to annotate your code for parallelism, or if using multiple IO worker threads that do stuff like independent I/O and/or computation
22:05:14 <randomclown> ah ok, it's only using 1% of the cpu right now
22:05:20 <dyeprii> join #python
22:05:26 <randomclown> I'll switch it up if it needs more
22:06:03 <dyeprii> aw sry
22:09:07 <Kaidelong> if you're using haskell you may as well take the time to learn about par, seq, and pseq
22:09:35 <Kaidelong> it's nice to realize where you can use it
22:10:04 <Kaidelong> and then also conal's lub
22:10:47 <Kaidelong> which is unsafe but where it is safe to use it's nice to have
22:11:38 <harasskell> > \f g a b c -> f >>= a . b . c =<< g
22:11:42 <lambdabot>  Precedence parsing error
22:11:42 <lambdabot>      cannot mix `GHC.Base.>>=' [infixl 1] and `Control.Monad.=<<' [infixr 1] ...
22:12:37 <harasskell> @pl \f g a b c -> f >>= a . b . g >>= c
22:12:38 <lambdabot> ((((>>=) .) .) .) . (. (flip ((.) . (.)) . flip (.))) . (.) . (.) . (>>=)
22:12:47 <OceanSpray> what's the term used to describe a term that can't be further evaluated
22:12:56 <harasskell> @pl \x f -> f x
22:12:56 <lambdabot> flip id
22:12:58 <Kaidelong> normal form
22:13:04 <OceanSpray> oh yeah
22:13:06 <OceanSpray> thanks
22:13:33 <harasskell> @type flip id
22:13:35 <lambdabot> b -> (b -> c) -> c
22:14:18 <harasskell> @type \f -> let x = f x in x
22:14:19 <lambdabot> (t -> t) -> t
22:15:06 <harasskell> b
22:15:20 <harasskell> zp
22:15:43 <harasskell> Why isn't `haskell` a keyword?
22:16:07 <ski> for what purpose would it be used ?
22:16:30 <haasn> ski: inserting the correct operator at compile time by asynchronously asking #haskell
22:16:55 * ski doesn't follow
22:16:59 <erisco> haasn, brilliant!
22:17:01 <haasn> (I don't know)
22:17:16 <erisco> wait am I the only one who understood that? mysterious
22:17:37 <Axman6> harasskell: why would it be?
22:19:55 <harasskell> > let x = 0 : map ((+1).(*2)) x in x
22:19:56 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
22:20:50 <harasskell> > let x = map (1+) (0 : map ((+1).(*2)) x) in x
22:20:52 <lambdabot>  [1,4,10,22,46,94,190,382,766,1534,3070,6142,12286,24574,49150,98302,196606,3...
22:21:16 <erisco> harasskell, remember that you can also test on ghci
22:24:04 <Platz> haskellwiki says `seq` is srict in it's first argument, but `pseq` documentation says `seq` is strict in both arguments
22:25:14 <shachaf> Both of those statements are true.
22:26:23 <Platz> seems odd not to mention strict in second arg though
22:27:23 <Kaidelong> the problem with seq is that it doesn't actually guarantee what its name suggests it should
22:27:25 <shachaf> I wouldn't have thought to mention it because it seems obvious.
22:27:34 <harasskell_> iterate f x = scanl (const . f) x anything
22:27:39 <shachaf> I also wouldn't normally mention that id is strict.
22:28:02 <Kaidelong> f `seq` g, which will be evaluated first? Actually you don't know, you just know both will be evaluated
22:28:34 <harasskell_> > (\f x -> scanl (const . f) x (repeat ())) (*3) 1
22:28:35 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
22:29:05 <shachaf> harasskell_: You can /msg lambdabot, if you don't have a question about those expressions.
22:29:05 <startling> Kaidelong, does that matter?
22:29:27 <harasskell_> How to do so?
22:30:09 <ski> /msg lambdabot > (\f x -> scanl (const . f) x (repeat ())) (*3) 1
22:30:12 <ski> like that
22:30:32 <Kaidelong> startling: say you want to ensure in some sequence x `seq` (f `par` g `par` h) that x is evaluated first and not redone each time in the sparks generated by par
22:31:02 <shachaf> Which Of Seq's Arguments Is Evaluated First? The Answer Might Surprise You
22:31:04 <Kaidelong> startling: seq is not enough to ensure that is what actually happens
22:31:21 <startling> shachaf, haha
22:31:36 <startling> Kaidelong: hm, ok
22:32:27 * ski thinks the first argument can even be forced after returning the value forced out of the second argument
22:32:59 <Kaidelong> this is incidentally why pseq exists (also because if you just did x `par` y `seq` f(x,y) it might calculate f(x,y) before it prepares x and y in parallel)
22:33:39 <zipper> Why aren't `unwords . map reverse $ words' and `unwords . map reverse .words' the same? as far as I can tell they are all unwords (map reverse (words)) but one fails to work in let bindings
22:34:10 <shachaf> The last thing you wrote, with the parentheses, is a type error.
22:34:24 <shachaf> You should figure out why.
22:34:25 <zipper> In ghci unwords . map reverse $ words "This is a string" works
22:34:37 <shachaf> If you're being all operational about things, it might make more sense to think of seq as a compiler hint than as a function in the usual sense.
22:34:47 <Kaidelong> :t words "This is a string"
22:34:48 <lambdabot> [String]
22:34:52 <Kaidelong> :t words
22:34:52 <haasn> zipper: foo $ f x  is not the same as foo $ f
22:34:52 <lambdabot> String -> [String]
22:35:02 <haasn> since f is not the same as f x
22:35:06 <Kaidelong> :t ($ words "This is a string")
22:35:07 <lambdabot> ([String] -> b) -> b
22:35:14 <Kaidelong> :t ($ words)
22:35:15 <lambdabot> ((String -> [String]) -> b) -> b
22:35:32 <syllogismos> > do (a <- [1,2,3]; let b = 2; return a + b)
22:35:33 <lambdabot>  <hint>:1:7: parse error on input `<-'
22:35:50 <Kaidelong> syllogismos: use curly braces
22:35:59 <syllogismos> > do {a <- [1,2,3]; let b = 2; return a + b}
22:36:00 <lambdabot>  <hint>:1:42: parse error on input `}'
22:36:17 <syllogismos> > do {a <- [1,2,3]; let b = 2; return a + b;}
22:36:18 <lambdabot>  <hint>:1:42: parse error on input `;'
22:36:48 <Kaidelong> I think it wants a space actually, GHCi confused me in a similar way today because of how it didn't like [foo..]
22:36:53 <Kaidelong> but was okay with [foo .. ]
22:37:18 <syllogismos> > do{a <- [1,2,3]; let b = 2; return a + b}
22:37:19 <lambdabot>  <hint>:1:41: parse error on input `}'
22:37:24 <syllogismos> > do{a <- [1,2,3]; let b = 2; return a + b }
22:37:25 <lambdabot>  <hint>:1:42: parse error on input `}'
22:37:31 <Kaidelong> > do { a <- [1,2,3] ; let b = 2 ; return a + b }
22:37:32 <lambdabot>  <hint>:1:46: parse error on input `}'
22:37:34 <Kaidelong> oh
22:37:43 <Kaidelong> well don't listen to me
22:37:44 <kandid_> fuck freenode
22:39:14 <syllogismos> what am i missing..? :(
22:39:55 <Kaidelong> I'm baffled
22:40:03 <Kaidelong> haskell book says that should work
22:40:17 <syllogismos> > do{a <- [1,2,3]; let b = 2; return $ a + b }
22:40:18 <lambdabot>  <hint>:1:44: parse error on input `}'
22:40:31 <syllogismos> > do{a <- [1,2,3]; let b = 2; return (a + b) }
22:40:33 <lambdabot>  <hint>:1:44: parse error on input `}'
22:40:37 <Kaidelong> > do { a <- [1,2,3] ; let b = 2 ; return a + b }
22:40:39 <lambdabot>  <hint>:1:46: parse error on input `}'
22:41:31 <startling> It looks like the let is it the problem
22:41:31 <ski> > do a <- [1,2,3]; let {b = 2}; return (a + b)
22:41:33 <lambdabot>  [3,4,5]
22:41:36 <syllogismos> > do a <- [1,2,3]; let b = 2; return (a + b)
22:41:37 <lambdabot>  can't find file: L.hs
22:41:56 <startling> :<
22:42:03 <startling> > do { a <- [1,2,3]; return a; }
22:42:04 <lambdabot>  [1,2,3]
22:42:15 <ski> > do a <- [1,2,3]; return a;
22:42:16 <lambdabot>  [1,2,3]
22:42:17 <Kaidelong> yes the let appears to be the problem
22:42:19 <startling> > do { a <- [1,2,3]; let b = 2 in return (1 + b); }
22:42:20 <lambdabot>  [3,3,3]
22:42:25 <startling> er
22:42:36 <syllogismos> > do{a <- [1,2,3]; let {b = 2}; return (a + b) }
22:42:36 <Kaidelong> that's completely counterintuitive though because let is supposed to be supported in do syntax
22:42:37 <lambdabot>  [3,4,5]
22:42:46 <startling> Kaidelong: yeah. I don't understand it either.
22:42:56 <Kaidelong> syllogismos: that's surprising =(
22:43:04 <Kaidelong> haskell shouldn't be surprising
22:43:06 <syllogismos> maybe to have multiple lines in let statment
22:43:08 <startling> Maybe it's part of the whitespace rules?
22:43:08 <Kaidelong> makes me sad
22:43:26 <ski> Kaidelong : it's parsed as `do {a <- [1,2,3]; let {b = 2; return (a + b)}}', which is a syntax error
22:43:34 <syllogismos> > do{a <- [1,2,3]; let {b = 2; c= 3}; return (a + b+c) }
22:43:35 <lambdabot>  [6,7,8]
22:43:43 <thebnq> >do {a <- [1,2,3]; let b = 2; return a + b; }
22:43:45 <startling> oh, makes sense.
22:43:50 <thebnq> > do {a <- [1,2,3]; let b = 2; return a + b; }
22:43:52 <lambdabot>  <hint>:1:42: parse error on input `;'
22:44:06 <startling> > do {a <- [1,2,3]; let {b = 2}; return (a + b); }
22:44:07 <lambdabot>  [3,4,5]
22:44:23 <thebnq> weird
22:44:25 <phyre> Is there a better way of doing something like this? reverse $ (iterate ((:) 'a') "kcus") !! n, where n is the number of 'a's?
22:44:57 <ski> lesson : wrap bindings for `let',`where' and `case' in brackets, when it matters (usually only for one-liners)
22:45:05 <codygman> Hey guys, trying to compile ghc 7.8 and got this error: http://lpaste.net/99855
22:45:07 <startling> > iterate ((:) 'a') "uhh..."
22:45:08 <lambdabot>  ["uhh...","auhh...","aauhh...","aaauhh...","aaaauhh...","aaaaauhh...","aaaaa...
22:45:11 <phyre> The only other way I can think of is using repeat.
22:45:33 <startling> > replicate 12 'a' ++ "kcus"
22:45:34 <lambdabot>  "aaaaaaaaaaaakcus"
22:45:45 <roboguy_> > "suck" ++ replicate 4 'a'
22:45:46 <lambdabot>  "suckaaaa"
22:45:57 <phyre> ahh, replicate! thanks!
22:46:09 <frx> > iterate ('a':) "uhh..."
22:46:10 <lambdabot>  ["uhh...","auhh...","aauhh...","aaauhh...","aaaauhh...","aaaaauhh...","aaaaa...
22:46:28 <phyre> frx, the thing is that i'd have to reverse it.
22:46:28 <startling> > 12 (a :) "kcus" -- with church encoding
22:46:30 <lambdabot>  No instance for (GHC.Show.Show a0)
22:46:30 <lambdabot>    arising from a use of `M399138108869776965432128.show_M3991381088697769654...
22:46:30 <lambdabot>  The type variable `a0' is ambiguous
22:46:30 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:46:30 <lambdabot>  Note: there are several potential instances:
22:46:33 <startling> aw.
22:46:46 <ocfx> what is church encoding
22:47:09 <Cale> ocfx: Are you familiar with algebraic datatypes?
22:47:22 <Cale> (like those defined by the data keyword in Haskell)
22:47:28 <startling> ocfx: a way to represent a natural number n as a function that says "apply some function repeatedly n times"
22:47:34 <ocfx> no i just started learning haskell last week lol
22:48:00 <startling> > natural "kcus" ('a' :) 12 -- here we go
22:48:01 <lambdabot>  Not in scope: `natural'
22:48:02 <Cale> Okay, so the best way to understand Church encoding (at least I think so) is to understand it in terms of those
22:48:10 <startling> dang.
22:48:14 <Cale> (even though Church didn't)
22:48:27 <startling> I think Maybe/maybe is a good place to start.
22:48:33 <Rotaerk_> hmm there a way to split a single LANGUAGE pragma, listing multiple extensions, over multiple lines?
22:48:49 <Cale> So, when you define a data type in Haskell, you also define a bunch of constructors, and those constructors are new values, and may have some parameters of types that you specify
22:48:58 <startling> Rotaerk_, {-# LANGUAGE ... #-}\n{-# LANGUAGE ... #-}\n ?
22:48:59 <simpson> Rotaerk_: You can have multiple LANGUAGE pragmas.
22:49:02 <Cale> (which may even include the type being defined)
22:49:25 <Rotaerk_> k, so no then; have to use multiple, k
22:49:31 <Cale> For example, to define a type of natural numbers, we could say "Every natural number is either zero, or it is the successor of another natural number", so in Haskell that's:
22:49:37 <Cale> data Nat = Zero | Succ Nat
22:49:41 <zipper> haasn: so uh f . g . h is (f (g (h))) while f.g $ h is (f (g)) (h)
22:49:49 <zipper> haasn: I think I get it now
22:50:06 <Cale> This defines two data constructors, Zero and Succ. Zero has no parameters, and Succ has just one, which is another natural number.
22:50:17 <Cale> ocfx: good so far?
22:50:31 <ocfx> yep makes sense so far
22:50:34 <zipper> haasn: In the second one the result of f.g is trying to take a function while it expects a list
22:50:49 <Cale> ocfx: So, in the untyped lambda calculus, you don't have things like constructors built in, all you have is lambda, applications, and variables
22:51:01 <kandid_> fuck haskell
22:51:07 --- mode: ChanServ set +o Cale
22:51:51 <syllogismos> is that how Int is defined?
22:51:55 <Cale> ocfx: So, where in Haskell, you might be able to write the natural number 3 as  Succ (Succ (Succ Zero))
22:51:58 <startling> syllogismos: no.
22:52:08 <Cale> syllogismos: (no, this is a really inefficient encoding)
22:52:13 <syllogismos> data Int = Pred Int | 0 | Succ Int
22:52:27 <Cale> (but I suppose if you made the compiler very clever, you could use it)
22:52:27 <syllogismos> okay
22:52:37 <scott> Also, Int has a finite number of values. Nat has infinite.
22:52:40 <startling> syllogismos: the problem with that sort of thing is that (Pred (Succ 0)) == 0
22:52:53 <Cale> ocfx: We need a way to sort of assume that there are these things Succ and Zero so that we can use them
22:53:00 <Cale> ocfx: and to do that, we use lambda
22:53:07 <startling> syllogismos: you could do e.g. data Int = PlusOneTimes Nat | Zero | NegativeOneTimes Nat instead
22:53:13 <Cale> (\succ zero -> succ (succ (succ zero)))
22:53:21 <startling> but, no, this isn't how it's actually represented.
22:53:21 <Cale> this is the Church encoding for the number 3
22:54:04 <Cale> So, we just lambda bind all the things which would be constructors of our datatype as function parameters, and then form an expression using those corresponding to the value we want to represent
22:54:26 <Kaidelong> if you know about monoids already, there's a really simple way to explain church encoding
22:54:30 <zipper> Is f.g.h equal to f (g (h)) ?
22:54:44 <Cale> zipper: no, it's equal to (\x -> f (g (h x)))
22:54:55 <piezoid> > (\succ zero -> succ (succ (succ zero))) (+1) 0
22:54:56 <lambdabot>  3
22:54:57 <Kaidelong> by explaining what a category is, then showing that church encoding is an example of a monoid
22:55:14 <Cale> Kaidelong: wait, what?
22:55:18 <startling> "really simple"
22:55:21 <ocfx> ah okay, thank you for explaining that
22:56:03 <startling> ocfx, so, translating between church-encoded numbers and regular Ints in haskell is pretty easy.
22:56:07 <startling> ocfx: want to give it a shot?
22:56:11 <Kaidelong> Cale: church encoding encodes natural numbers by repeated applications of a function, right?
22:56:27 <Cale> Kaidelong: Oh, you're talking about natural numbers specifically
22:56:33 <Cale> Kaidelong: okay
22:56:34 <Cale> :)
22:56:36 <Kaidelong> you end up with (.) working like mappend and id as mempty
22:56:50 <Cale> I thought we were talking about all Church encodings, so your comment was confusing :)
22:57:03 <zipper> Cale: Your Op status is intimidating lol
22:57:04 <startling> Kaidelong, is that very interesting?
22:57:14 <ski> zipper : for a reason
22:57:22 <Cale> zipper: It's meant to be, I'm threatening kandid_ into behaving
22:57:26 <startling> Kaidelong, you could just say "natural numbers are a monoid (in the classical sense)"
22:57:43 <startling> I'm not sure you get anything out of the categorical veiw.
22:58:08 <Cale> ocfx: In terms of those encodings, you can actually build up more complicated operations, because by applying the resulting functions to some other lambda terms, you can effectively substitute the constructors of your data type with other values, which is the notion of a fold or what's sometimes called a catamorphism on your data.
22:58:09 <Kaidelong> it's not especially interesting but if the guy is having trouble understanding church encoding, explaining the categorical view makes it clear how church encoding works, because it relies on a kind of church encoding
22:58:20 <startling> um, iyss
22:58:58 <Cale> ocfx: For example, in order to add two natural numbers, that's basically the same as substituting the zero occurring in one of the numbers with another natural number.
22:59:20 <alex______> for aprox how many elements do you switch from association list to Map?
22:59:38 <Cale> So, we could define add to be the function (\n m -> (\succ zero -> n succ (m succ zero)))
22:59:42 <piezoid> > let a = (\succ zero -> succ (succ (succ zero))) ; (\succ zero -> succ (succ zero)); add x y = (\s z -> x s (y s z)) in add x y
22:59:43 <lambdabot>  <hint>:1:83: parse error on input `;'
22:59:52 <piezoid> > let add x y = (\s z -> x s (y s z)) ; a = (\succ zero -> succ (succ (succ zero))); b = (\succ zero -> succ (succ zero)); c = add a b in c (+1) 0
22:59:53 <lambdabot>  5
23:00:17 <codygman> Oh duh, ghc 7.8 requires a newer libc than wheezy has
23:00:21 <erisco> alex______, what is "association list"?
23:01:17 <alex______> erisco it is what Prelude.lookup accepts
23:01:21 <ocfx> im on chapter 3 of LYAH, a lot of this is going over my head a bit, i might not be ready yet :(
23:01:26 <alex______> :t lookup
23:01:27 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:01:41 <startling> ocfx, it's always safe to ignore things in this channel that go over your head.
23:01:50 <Cale> ocfx: Well, that's okay, it takes some time getting used to it, and you don't really need to know it just for the sake of programming in Haskell.
23:01:50 <startling> ocfx, if you stick with it they'll make sense someday. :)
23:02:07 <ocfx> okay cool, i like it so far
23:02:15 <Cale> ocfx: (it's more useful if you're programming in a language like the untyped lambda calculus where you need to build absolutely everything out of lambdas)
23:02:22 <erisco> alex______, that lookup has O(n) complexity, whereas Map.lookup has O(logn) complexity, so you can decide on that basis
23:02:34 <alex______> apologizing for long nick, apparently this was the first non-taken alex nick :)
23:02:48 <startling> haha
23:02:55 <Kaidelong> anyway for the categorical view, imagine a set of functions that map one type to itself, one of them is called 0, the other is called 1. Composing 0 into anything doesn't change it, composing 1 into 1 gives 2. 0 is the same as id, it's just defined let 0 x = x. 1 could be defined as let 1 x = succ x. Then we define 2 as 1 . 1, 3 as 2 . 1, 4 as 3 . 1 and so forth
23:03:26 <Kaidelong> since the lambda calculus understands function application, you can use this to directly work with numbers in the lambda calculus
23:03:41 <Cale> Kaidelong: errrr... are you sure you want 0 to be id?
23:04:07 <Cale> normally you'd want it to be (\succ zero -> zero), which isn't id
23:04:24 <startling> Kaidelong: I still don't understand what the categorical view buys you.
23:04:27 <Kaidelong> Cale: it has to be, doesn't it? otherwise the idea of a monoid being a category of one object doesn't work
23:04:35 <alex______> erisco: yeah I know, but if I have say 20 elements max I would expect lookup in list to be faster. I could be wrong
23:04:44 <Cale> Oh, well, sure it's the identity arrow of your category
23:04:51 <Cale> But it's not the identity function
23:04:58 <Cale> It's const id
23:05:39 <Cale> (\succ zero -> succ zero) is the identity function, which is the representation of 1
23:05:40 <erisco> alex______, it may be faster. I do not know when Map.lookup typically takes over
23:12:55 <kandid_> threaten me with what, cale?
23:13:45 <kandid_> i threaten the whole world every day on these networks
23:13:48 <Cale> If your only contributions to the channel will be rudeness, I will ban you.
23:14:02 <kandid_> oh, just a ban?
23:14:18 <Kaidelong> Yes, that would be the appropriate, proportionate response
23:14:23 <kandid_> you're not going to send an email to my university and tell them what a dick i am and how i ban evade and commit "hacking"?
23:14:45 <startling> um
23:15:08 <Cale> No, we'll just continue to ban any disruptive users.
23:15:35 <kandid_> i have a whole bunch of issues i would like to discuss
23:15:45 <Kaidelong> shoot
23:15:52 <Cale> If they're Haskell-related, you're welcome to discuss them here :)
23:16:00 <kandid_> really, email my university, tell them i'm harassing you and committing computer crimes by ban evading
23:16:09 <ocfx> wat
23:16:21 <phyre> o_O
23:16:42 <bitemyapp> kandid_: what's your name and student id #?
23:16:53 <alex______> are you using your ex-girlfriend's computer?
23:17:02 <Axman6> kandid_: you ok?
23:17:21 <Cale> It would be inappropriate to respond like that, because there's no way we could confirm your identity in any case
23:17:23 <notdan> alex______: ha, could be
23:17:36 <Cale> Even if it were illegal to evade IRC channel bans
23:17:49 <Cale> (which it isn't likely to be in most places)
23:18:16 <Kaidelong> I think it might be here, I think the Computer Fraud and Abuse act allows the government to prosecute for violations of private ToS agreements
23:18:17 <kandid_> are you bowing down to me?
23:18:19 <Cale> anyway, this is all off-topic
23:18:21 <bitemyapp> Cale: in the US, it could hypothetically fall under computer abuse and fraud.
23:18:40 <kandid_> Cale obviously wants to let me play king right now
23:18:58 <Cale> okay
23:19:02 --- mode: Cale set +b *!*@dhcp-225-161.eastdorm.uic.edu
23:19:02 --- kick: kandid_ was kicked by Cale (kandid_)
23:19:07 <startling> haha
23:19:08 <Kaidelong> it was made famous by the case of that one recent suicide of a tech prodigy who violates MIT terms of service
23:19:10 --- mode: Cale set -o Cale
23:19:16 <phyre> >map toLower "kandid_"
23:19:43 <Kaidelong> the government pursued a criminal case against the wishes of JSTOR whom he supposedly wronged
23:20:55 <startling> Kaidelong, aaron swartz, yes
23:21:35 <Kaidelong> the law is beyond stupid
23:22:27 <Axman6> what on earth was that all about
23:22:37 <bitemyapp> Kaidelong: that's the problem with rewarding prosecutors on the basis of criminal convictions.
23:22:50 <Cale> Kaidelong: Yeah, but that's the US, and everyone knows their laws are all at least a factor of 2 more unreasonable than anywhere else :)
23:22:53 <bitemyapp> Kaidelong: the law that enables them is part of, but not the whole, problem.
23:23:02 <Kaidelong> bitemyapp: #haskell-blah?
23:23:06 <Kaidelong> I'll follow up there
23:23:11 <bitemyapp> nah.
23:23:21 <Cale> yeah, best to move the discussion there if you have anything more to say about it :)
23:23:55 <carter> bitemyapp: still trying to figure out what my schedule is tomorrow
23:24:00 <carter> but i'm probably free mid afternoon
23:27:04 <Enigmagic> except for lunch :P
23:27:23 <carter> :)
23:27:25 <carter> Enigmagic: :)
23:27:42 <carter> Enigmagic: i figured out my main reasony CH confuses me :)
23:30:09 <bitemyapp> carter: my lunch is taken, I'm otherwise free.
23:30:54 <carter> cool
23:51:26 <alex______> I want to sort [Maybe MyData] so that Nothing elements are at the end, and Just elements are sorted with regular (not inversed) compare. is there a cute one-liner I could use or should I just write a custom comparison function?
23:52:24 <tac> Suppose I have a data structure with a record field of type Maybe Stuff and Stuff has a field x
23:52:31 <tac> However, maybeStuff . x doesn't work
23:52:37 <tac> because it can't unify Maybe Stuff with Stuff
23:52:43 <agocorona> hi
23:52:46 <tac> How can I get the "obvious" thing to work?
23:54:25 <shiona> At our university we have an automated testing tool for c++ code (called boss), that students invoke at their end and it sens code over to a sandbox in a server where it's compiled, style checked and tested and results are stored & sent back to user
23:54:39 <shiona> I'm interested in tring something similar for haskell
23:55:02 <frx> tac: x <$> record dataStruct ?
23:55:09 <shiona> is there anything similar that has already been done?
23:55:57 <agocorona> world most long applicative and monadic combinator expression ever. For a cascade menu (mainMenu)  in a web page: https://github.com/agocorona/MFlow/blob/master/Demos/Menu.hs#mainMenu
23:56:04 <shiona> and first problem I came across is that is there a way to limit which packages can be imported. other than building a sandbox for each package-setup
23:57:02 <tac> frx: It looks like traverse what what I wanted
23:57:31 <alex______> :t traverse
23:57:32 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:57:44 <alex______> o_0
23:57:55 <Cale> > sortBy (comparing isNothing <> compare) [Nothing, Just 3, Just 5, Nothing]
23:57:56 <lambdabot>  [Just 3,Just 5,Nothing,Nothing]
23:58:27 <SLi> When writing Haskell, I seem to have a problem where the toplevel definitions always end up in a rather random and unintuitive order. Perhaps I should start sorting them alphabetictally; that way they are at least in a consistent order :P
23:58:27 <alex______> Cale wow, amazing
23:58:36 <tac> alex______: In this case, t = Maybe
23:58:48 <Cale> SLi: you could topologically sort them by usage
23:59:04 <tac> So it's Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
23:59:10 <alex______> Cale I had a hideous 10 line comparer
23:59:11 <tac> I believe
23:59:15 <alex______> tac I see
23:59:28 <tac> But the types for these things are pretty horrible
23:59:49 <Cale> wow, very sort, much compare, so monoid  [[ordering intensifies]]
23:59:57 <SLi> Cale: Yeah, that would make much more sense. I wonder if there's a tool to extract the dependency graph of toplevel definitions somewhere :p
