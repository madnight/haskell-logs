00:14:23 <christiaanb> hello, could anybody tell me what heap object between '<' and '>' brackets are? as, when I run "+RTS -hd" I see objects like: <RepLib-0.5.3.1:Generics.RepLib.RepAux.sat_sw42>
00:18:24 * hackagebot packer 0.1.4 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.4 (VincentHanquez)
00:46:15 <zcd> is there a way to disable parts of the prelude?
00:46:30 <zcd> i want to try and implement the map instance of functor to better understand it
00:47:10 <boomboompwo> I have an array row =[[2]] why doesn't head head row give me 2?
00:48:05 <lieven_> zcd: import Prelude hiding ...
00:49:17 <lieven_> > let row = [[2]] in head $ head row
00:49:19 <lambdabot>  2
00:49:35 <boomboompwo> what is the difference?
00:49:52 <lieven_> you want head (head row)
00:50:20 <bergmark> zcd: you can use a newtype and write the intances
00:50:36 <boomboompwo> is it interpreting as (head head) row if I type head head row?
00:51:01 <bergmark> boomboompwo: yes
00:51:02 <lieven_> yeah
00:51:19 <boomboompwo> lieven_: now I get it, thansk!
00:51:24 <jle`> boomboompwo: you can think of the space as the 'function call operator', which associates from the left
00:51:47 <bergmark> boomboompwo: also, check the types, [['a']] :: [[Char]], head :: [a] -> a, head . head :: [[a]] -> a
00:52:13 <jle`> the reason for this is that it makes partial application/currying work a little cleaner
00:52:22 <boomboompwo> hmm
00:52:28 <jle`> remember that if f :: a -> a -> a
00:52:36 <jle`> it's just f :: a -> (a -> a)
00:52:42 <jle`> so you can 'call' it
00:52:45 <jle`> with f x y
00:52:50 <jle`> which is (f x) y
00:53:17 <jle`> if function calls associated to the right...you'd need those explicit parentheses every time
00:53:34 <jle`> otherwise if you wrote f x y it'd be f (x y)...and that's no fun
00:54:46 <boomboompwo> jle`: so if I have an array row = [[2]] and I want to map a function to 2 like map addOne row should give out [[3]] how would I do it?
00:55:36 <jle`> so remember that `map` turns a function on normal things into a function on lists
00:55:50 <jle`> so you want to turn a function on lists into a function on lists in lists
00:56:11 <jle`> > let f = map (+1) in f [1,2]
00:56:12 <lambdabot>  [2,3]
00:56:26 <jle`> > let f = map (+1); g = map f in g [[1,2]]
00:56:28 <lambdabot>  [[2,3]]
00:57:12 <giskardr1ventlov> 2
00:57:38 <boomboompwo> jle`: wow that is awesome
00:58:30 <boomboompwo> jle`: so we map a function into each element in the list, which in turn maps a function into each element of the sub lists
00:58:47 <bergmark> aye
00:58:47 <giskardr1ventlov> q
01:02:40 <jle`> boomboompwo: I like to think of it as "upgrading" functions
01:02:42 <giskardr1ventlov> haskell meraklƒ±sƒ± t√ºrk var mƒ±?
01:02:50 <merijn> En dan nog microtransactions, natuurlijk
01:02:51 <jle`> :t map (+1)
01:02:52 <lambdabot> Num b => [b] -> [b]
01:03:01 <merijn> eh, that was the wrong channel >.>
01:03:11 <jle`> :t map (map (+1))
01:03:12 <lambdabot> Num b => [[b]] -> [[b]]
01:03:24 <jle`> :t (+1)
01:03:25 <lambdabot> Num a => a -> a
01:03:41 <jle`> see how each layer of map "upgrades" (+1)
01:04:38 <boomboompwo> jle`: right I get it
01:05:54 <boomboompwo> I have one more question, I have an array like r = [SqlInt64 2,SqlInt64 2,SqlInt64 2,SqlInt64 2,SqlInt64 2] and the format for fromSql command to convert SqlInt to int is fromSql val::Int, how do I map this to each element in r?
01:06:44 <mornfall> boomboompwo: map fromSql
01:06:56 <boomboompwo> mornfall: doesn't seem to work
01:07:10 <mornfall> howso?
01:07:17 <c_wraith> boomboompwo: Please be aware that arrays and lists are different..  Your example there is a list, not an array.
01:07:18 <boomboompwo> mornfall: the syntax that works is fromSql sqlintvalhere::Integer
01:07:48 <mornfall> boomboompwo: you need to use map fromSql r :: [Int] then to get a list of Ints
01:07:50 <c_wraith> boomboompwo: map fromSql r :: [Int]
01:08:14 <boomboompwo> c_wraith: can you please explain how it works?
01:08:34 <c_wraith> mornfall's been ahead of me so far.  I'll let him handle it. :)
01:09:15 <mornfall> :D boomboompwo the :: [Int] is a signature that fixes the type of an expression
01:09:29 <mornfall> :t fromSql
01:09:30 <lambdabot>     Not in scope: `fromSql'
01:09:30 <lambdabot>     Perhaps you meant one of these:
01:09:30 <lambdabot>       `fromEq' (imported from Control.Lens),
01:09:36 <mornfall> too bad
01:09:44 <boomboompwo> mornfall: ah, so it says the return is going to be a list of int?
01:10:23 <mornfall> anyway, fromSql is polymorphic in the return type, but you can't have an actual value of an unspecified type, so you need to set a particular (mono)type
01:10:45 <mornfall> so yes, you are saying that you want to get a list of Int's out of it
01:11:02 <boomboompwo> mornfall: Cool, I'm loving haskell already :D
01:11:07 <mornfall> another approach would be to fix the type of fromSql, say map (fromSql :: Something -> Int) r
01:11:13 <boomboompwo> thanks guys, I'll be bothering you guys a little more
01:12:34 <lieven_> yet another approach is to use it in a larger expression so haskell can figure out the type by context
01:13:08 <no-n> I tried (nub $ cycle [1..3]) and ^C didn't stop it
01:14:23 <c_wraith> no-n: ghci installs its own signal handler for ^C when running haskell code.  In certain circumstances, extreme load can mess up that signal handler.
01:14:37 <mornfall> lieven_: yes, although it's less likely to work with integral types because many of their operations are polymorphic too
01:14:38 <no-n> hmm
01:14:59 <no-n> c_wraith: but how could it be extreme load as there are only 3 elements in the nubbed list
01:15:09 <no-n> cpu i suppose
01:15:23 <mornfall> no-n: there are infinitely many elements in there :D
01:15:25 <c_wraith> no-n: because it doesn't know there are only 3 elements in the result.  It has to check every element of the infinite list to see if it's ok
01:15:25 <lieven_> mornfall: it can in some cases just return a type Num a => a.
01:15:36 <lieven_> > (read "10")+0
01:15:37 <lambdabot>  10
01:15:55 <c_wraith> lieven_: that's using defaulting to default to Integer
01:16:15 <lieven_> ah ok I misunderstood then
01:16:45 <no-n> oh, yes. but it doesn't build a large list in memory because of laziness
01:17:06 <no-n> right?
01:17:10 <mornfall> no-n: it does, nub is n^2
01:17:19 <no-n> oh
01:17:36 <no-n> can that harm anything
01:17:51 <no-n> building a huge list like that
01:17:53 <mornfall> although dunno, maybe it consumes that list OK
01:18:45 <mornfall> @src nub
01:18:45 <lambdabot> nub = nubBy (==)
01:18:50 <mornfall> @src nubBy
01:18:50 <lambdabot> nubBy eq []             =  []
01:18:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:19:34 <Saizan> nub is a good lazy producer, but it does keep a reference to earlier elements so that it can filter them out of the rest
01:20:16 <no-n> so it would build a huge list?
01:21:22 <c_wraith> that particular use of nub won't use much memory
01:21:26 <c_wraith> it will use infinite CPU
01:21:35 <c_wraith> at least, if you try to find the 4th element, it will
01:21:56 <no-n> infinite CPU?
01:22:03 <mornfall> it will fail to terminate
01:22:12 <no-n> all right
01:22:13 <Saizan> it will also keep all the elements it scanned so far in memory
01:22:19 <no-n> but running it won't mess anything up on the system will it?
01:22:34 <mornfall> but the memory is bounded by the size of the output list, which is OK, IIUIC
01:22:37 <c_wraith> Saizan: it only keeps the distinct found elements in memory.  That list only has 3 elements in it, so that's not a big deal
01:22:50 <no-n> Saizan, [1,2,3,1,2,3,1,2,3,1,2,3... or just [1,2,3]?
01:23:04 <Saizan> c_wraith: (filter (\ y -> not (eq x y)) xs) <- that keeps x in memory until xs is processed
01:23:29 <c_wraith> Saizan: yes, but it doesn't keep duplicates of x in xs
01:23:54 <mornfall> yeah, there are only 3 values bound to the filters
01:24:13 <Saizan> i guess with your particular example, because of cycle, it's just [1,2,3]
01:24:16 <mornfall> well, the entire output list is always held in memory
01:24:17 <no-n> so it keeps [1,2,3 rather than [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,12,3,....?
01:24:19 <mornfall> even if part of it was consumed
01:24:21 <Saizan> i wasn't considering the sharing in the input list
01:24:23 <Saizan> no-n: yeah
01:24:28 <no-n> okay
01:24:29 <c_wraith> Saizan: even if it wasn't sharing, it would be bounded
01:24:47 <c_wraith> Saizan: only the (:)s are shared, anyway
01:25:08 <c_wraith> ghc has no way to distinguish between different 3s
01:25:15 <c_wraith> well, ok, no safe way
01:25:32 <c_wraith> And so it'd create new closures every time if it worked that way
01:25:44 * no-n is confused now
01:25:53 <mornfall> no-n: disregard them :D
01:26:01 <Saizan> c_wraith: oh, right, sorry, already seen elements don't get in the filter closure because the recursive call to nubBy doesn't get to see them
01:26:13 <no-n> does (nub $ cycle [1,2,3]) build a huge list internally yes/no?
01:26:15 <c_wraith> Saizan: yep
01:26:21 <c_wraith> no-n: no, it does not
01:26:26 <Saizan> no-n: it doesn't
01:26:26 <no-n> okay
01:26:29 <no-n> ty
01:26:56 <syllogismos> http://lpaste.net/4233871751286620160 is my State monad instance of applicative typeclass correct?
01:27:08 <no-n> so ^C didn't work because the CPU was too busy?
01:27:09 <mornfall> no-n: nub's memory use is O(size-of-output-list) and CPU use is O(size-of-output-list * size-of-input-list)
01:27:16 <Axman6> nub only uses more memory when it encounters a new value
01:27:28 <Saizan> no-n: in general (nub xs) will only keep a reference to the elements it has produced so far
01:27:36 <no-n> *nod*
01:28:02 <c_wraith> syllogismos: the second one looks about right.  The first one is definitely wrong. :P
01:28:40 <enthropy> today was first time I've had a program produce "incorrect" results due to lazy IO
01:29:09 <c_wraith> enthropy: you never fell for the withFile "foo" hGetContents trap?
01:29:20 <enthropy> usually it's just "running out of handles"
01:29:31 <mornfall> @faq can you write wrong programs in Haskell?
01:29:31 <lambdabot> The answer is: Yes! Haskell can do that.
01:29:46 <Axman6> all the time!
01:29:58 <enthropy> c_wraith: no I write a temporary file with one function
01:30:16 <c_wraith> enthropy: that's most people's first exposure to the lazy IO pitfall
01:30:18 <enthropy> so that    forM_ xs $ \x -> do mkTmp x; readTmp x
01:30:28 <enthropy> so that    forM_ xs $ \x -> do mkTmp x; print (readTmp x)
01:31:07 <mornfall> c_wraith: hGetContents only gives you grief on Windows, usually
01:31:11 <enthropy>     print =<< forM xs (\x -> do mkTmp x; readTmp x) -- gives different results
01:31:31 <syllogismos> so what is the intuition behind it? I can write various combinations of the same function that all type checks.. but what is the intuition.?
01:32:01 <c_wraith> mornfall: (withFile "foo" hGetContents) never works.  You always get an empty string, because the handles is closed before anything is demanded
01:32:05 <Saizan> syllogismos: behind State or behind Applicative?
01:32:23 <no-n> so why does the ^C not work in that situation? just because the CPU is preoccupied with the job?
01:32:44 <syllogismos> what does behind state or behind applicative mean?
01:32:48 <c_wraith> no-n: yes.  The handler is haskell code, which never gets a chance to run.
01:32:54 <no-n> aha
01:32:56 <mornfall> c_wraith: right, I don't remember trying that :D
01:32:59 <no-n> interesting
01:33:13 <Axman6> are signal handlers only checked when there's a context switch (allocation)?
01:33:26 <Saizan> syllogismos: you asked for "the intuition behind it", what is "it" there?
01:33:26 <mornfall> c_wraith: I think I always use strict (the hackage package)
01:33:47 <syllogismos> state monads instance of applicative
01:33:48 <c_wraith> Axman6: sort of.  The RTS only notices that it should run a haskell handler on an allocation
01:33:59 <Axman6> right
01:34:01 <enthropy> this was for lazy bytestring io
01:34:12 <enthropy> which is understandably lazy IO
01:34:16 <c_wraith> Axman6: if the handler isn't in haskell, then it just runs when the signal is received.
01:34:35 <Axman6> I see. interesting
01:34:52 <syllogismos> ok.. so we have a power cut.. im worried my inverter is going to give up soon.. this is exciting.. lol
01:36:44 <mornfall> syllogismos: you on solar?
01:36:49 <startling> syllogismos, "apply a possibly-state-dependent function to a possibly-state-dependent function"
01:37:02 <syllogismos> wow.. right after my inverter started making sounds of giving up.. we got power after 4 hours..
01:37:05 <startling> er, "to a possibly-state-dependent value"
01:37:13 <syllogismos> no just from a poor town in a 3rd world country
01:40:59 <syllogismos> http://lpaste.net/4233871751286620160 I added additional examples of all the instances that type checks.. and each implementaion is passing the given test cases
01:42:04 <mornfall> syllogismos: undefined always typechecks, doesn't mean it's a good implementation :-)
01:42:24 <randominternetwa> Hello, when I do head row for let row = quickQuery' conn "select * from one_statistics limit 10" [] it gives me an error
01:42:37 <syllogismos> I know mornfall.. thats why im asking which one is the right one and what is the explanation..
01:42:49 <Axman6> randominternetwa: what is quickQuery'?
01:43:04 <Axman6> I'd be very very surprised if it doesn't have an IO result
01:43:15 <randominternetwa> Axman6: it does! :O
01:43:26 <randominternetwa> but when I do r <-  quickQuery' conn "select * from one_statistics limit 10" [] and then head r, it works fine
01:43:46 <mornfall> randominternetwa: that's what IO means :)
01:43:54 <Axman6> right, let just binds the expression to a name, the do notation runs the computation (sort of)
01:44:16 <Saizan> syllogismos: the second one is the right one, because you are properly passing the state from the first computation to the second
01:44:19 <Feuerbach> syllogismos: 2 and 3 are both valid. Let me see about 1 and 4...
01:44:33 <randominternetwa> Axman6: what would be the right way to do this?
01:44:54 <syllogismos> runState (pure (+1) <*> pure 0) 0 this is the only test case given..
01:45:03 <Saizan> syllogismos: the third is not that bad but it's reversing the flow of the state
01:45:17 <Axman6> randominternetwa: the way you were doing it using <-
01:45:24 <mornfall> syllogismos: there are "typeclass laws" that you should obey to get reasonable instances
01:45:30 <Saizan> syllogismos: yeah, you need test cases which involve get and put to check that the state flows
01:45:36 <Axman6> randominternetwa: but the real right way to do it would be to find out about how to use IO in haskell ;)
01:45:55 <randominternetwa> Axman6: Can you point me to some resources on this please?
01:46:08 <mornfall> randominternetwa: don't listen to Axman6, write it in common lisp! *ducks*
01:46:24 <randominternetwa> mornfall: :/
01:46:48 * pharaun uses a macro on mornfall 
01:47:03 * mornfall suddenly feels very unhygienic
01:47:13 <Axman6> look how hygenic he is now!
01:47:15 <Feuerbach> syllogismos: the 4th is probably not associative
01:47:18 <Axman6> D:
01:47:32 <Feuerbach> syllogismos: 1st is probably valid, too
01:47:40 <Feuerbach> (as far as applicative laws are concerned)
01:50:45 <syllogismos> I'm new to this state monad thing.. and I'm just interested in the right implementation and its intuition.. for example pure must give us the minimal context monad.. so pure x gives us a stateful computation that has x as its result and doesnt alter the state..
01:51:02 <supki> jjkkk
01:51:08 <supki> :(
01:52:21 <Saizan> syllogismos: right
01:52:40 <Feuerbach> syllogismos: your instances 1-3 differ in whether they pass the state and in which direction
01:54:15 <Saizan> syllogismos: so let's also define some combinators that do deal with the state, e.g. put s = State (\ _ -> (s,())) and get = State (\ s -> (s,s))
01:54:56 <skypers_> hi
01:55:25 <Saizan> syllogismos: one thing you want, for example, is that runState (pure id <*> put 1) 0 == (1,())
01:55:31 <skypers_> http://devskypers.blogspot.fr/2014/02/kwak-drama-tellbot-was-released-in.html
01:55:43 <skypers_> if some folks here are interested in such a bot
01:55:50 <skypers_> I‚Äôll push it into hackage :)
01:56:57 <Saizan> syllogismos: the idea being that "m <*> n" is going to alter the state according to m, then take that resulting state and alter it according to n
01:57:12 <Saizan> syllogismos: for the forward State monad at least
01:57:21 <syllogismos> get gives us the current state.. and what does put s do?
01:57:44 <Saizan> syllogismos: (put s) makes s the new current state
01:57:54 <syllogismos> shouldnt pus s = State (\ _ -> ((), s) be this
01:58:23 <Saizan> syllogismos: ah, yes, sorry, i switched the order in the tuples
01:58:46 <Saizan> runState (pure id <*> put 1) 0 == ((),1) too
01:59:42 <chrisg_> sifter where is accesscontrollayer in new-staging?
02:00:52 <boothead> Hi folks, is there a pipes equivalent of catMaybes
02:02:16 <syllogismos> so second one is the correct implementation.? I kind of understand it now..
02:04:26 <Saizan> syllogismos: yeah
02:08:26 <syllogismos> why is do { x <- mx ; y <- my; return f x y} same as f <$> mx <*> my
02:09:17 <Saizan> do { x <- mx ; y <- my; return (f x y)}, btw
02:09:43 <Axman6> @src Maybe (<*>)
02:09:43 <lambdabot> (<*>) = ap
02:09:48 <Axman6> @src Maybe ap
02:09:48 <lambdabot> Source not found. Where did you learn to type?
02:09:54 <Axman6> -_-
02:10:05 <Saizan> well, for State you could just inline the implementations, in general you have to use the typeclass laws
02:10:25 <Saizan> syllogismos: btw do notation is syntactic sugar for uses of (>>=)
02:10:34 <Saizan> @undo do { x <- mx ; y <- my; return (f x y)}
02:10:34 <lambdabot> mx >>= \ x -> my >>= \ y -> return (f x y)
02:12:54 <syllogismos> this exercise is making me implement all the type classes and ints instances of various types.. so I dont have do notation available for me.. and most of the source code in base libraries does things using do notation..
02:14:35 <burbul> :t concat *** concat
02:14:36 <lambdabot> ([[a]], [[a1]]) -> ([a], [a1])
02:14:44 <burbul> is there a nicer way of writing that?
02:15:28 <burbul> Really I want
02:15:31 <Axman6> :t everywhere concat
02:15:32 <lambdabot> Not in scope: `everywhere'
02:15:36 <Axman6> hmm
02:15:40 <benj_> :t over both concat
02:15:41 <lambdabot> ([[a]], [[a]]) -> ([a], [a])
02:15:44 <burbul> :t uncurry f . concat *** concat
02:15:46 <lambdabot>     Couldn't match type `[a1]' with `(a0, b0)'
02:15:46 <lambdabot>     Expected type: [[a1]] -> (a0, b0)
02:15:46 <lambdabot>       Actual type: [[a1]] -> [a1]
02:16:09 <burbul> Grr... f is a two-argument type constructor
02:16:15 <burbul> :t uncurry (+) . concat *** concat
02:16:16 <lambdabot>     Couldn't match type `[a0]' with `(c0, c0)'
02:16:16 <lambdabot>     Expected type: [[a0]] -> (c0, c0)
02:16:16 <lambdabot>       Actual type: [[a0]] -> [a0]
02:16:24 <Axman6> note the types are different there (monomorphism restriction?)
02:16:45 <burbul> I don't understand the monomorphism restriction
02:17:06 <Axman6> afaik, it means that you can't use the same thing with two different types
02:17:08 <burbul> nm, I think I need to think more
02:17:14 <burbul> concat *** concat is not what I want
02:17:56 <Axman6> so over both concat means that both lists need to have the same type (even though the action you might be trying to perform has no real care what the types in the lists are)
02:23:13 <burbul> OK -- uncurry Test . (concat *** concat) . unzip
02:23:24 <burbul> compiles with NoMonomorphismRestriction
02:23:30 <burbul> but is there a cleaner way of writing it?
02:23:41 <syllogismos> > let p x = (\s -> (const $ pure (x == 'c')) =<< put (1+s)) =<< get in runState (filterM p $ ['a'..'h']) 0
02:23:44 <lambdabot>  ("c",8)
02:23:54 <burbul> t.s. is [([a], [b])] -> Test a b
02:24:03 <burbul> with data Test a b = Test [a] [b]
02:26:12 <syllogismos> im getting ("c", 0) so one of the my implementations of filterM, =<<, put, get, pure etc must be wrong.. I dont even know how ask this question here..
02:27:02 <Eduard_Munteanu> burbul: you don't need NoMonomorphismRestriction if you provide a type signature explicitly
02:28:39 <Axman6> so: what's your implementation of pure?
02:28:44 <burbul> Eduard_Munteanu: I have it for otehr reasosn
02:28:46 <Axman6> syllogismos*
02:28:59 <lieven_> in the Pipes.Csv example there's a line personRec ~(Person name age) = ["name" .= name, "age" .= age]. What does the ~(...) syntax do? I haven't seen it before.
02:29:01 <Eduard_Munteanu> :t ?test <$> concat <*> concat
02:29:02 <lambdabot> (?test::[a] -> [a] -> b) => [[a]] -> b
02:29:06 <burbul> (Am rewriting bfs code according to your sugestions. going well -- thanks again!)
02:29:11 <Eduard_Munteanu> Er.
02:29:31 <Eduard_Munteanu> Sure, no problem.
02:31:20 <burbul> what does the ? in ?test do?
02:31:21 <Eduard_Munteanu> :t ?test <$> first concat <*> second concat
02:31:22 <lambdabot> (?test::([a], [[a1]]) -> ([[a]], [a1]) -> b) => ([[a]], [[a1]]) -> b
02:32:17 <Eduard_Munteanu> burbul: it's a hack to get lambdabot to treat it as a parameter and show its type, it's actually an implicit param in Haskell
02:32:48 <burbul> ah -- thanks
02:33:10 <syllogismos>  pure x = State $ (\s -> (x, s)),.. Axman6 ill give you the gist.. but everything in it are custom made types.. even List, Maybe etc etc.. so hoping its not a waste of your time..
02:33:23 <Eduard_Munteanu> Nevermind my :t above, it's useless.
02:38:14 <syllogismos> https://gist.github.com/syllogismos/d2bc100de5aad8c96164 line no 116
02:38:36 <syllogismos> just below the stars..
02:50:08 <zcd> how is a type constructor different from a functor?
02:50:41 <syllogismos> functor is a typeclass
02:50:58 <syllogismos> type constructor is a function that gives you that type as a result
02:51:22 <Eduard_Munteanu> zcd: not all type constructors are (or can be applied arguments) to get a Functor
02:52:48 <zcd> so to be a Functor, something has to satisfy fmap :: (a->b) -> f a -> f b
02:53:28 <zcd> but it seems like f a and f b will be a concret type as well
02:53:29 <syllogismos> yeah for f to be a functor
02:53:34 <Eduard_Munteanu> zcd: it has to provide fmap such that Functor laws hold
02:54:24 <Eduard_Munteanu> :k Maybe
02:54:25 <lambdabot> * -> *
02:54:28 <zcd> so in the instance Functor (something), you're providing fmap with a rule to apply it as a Functor?
02:54:48 <Eduard_Munteanu> zcd: nah, you just define fmap, but it should be well-behaved
02:55:10 <bennofs> zcd: for example, if you have 'data X a = X (a -> Int)', X is not a functor, because you cannot define fmap in a well-behaved way
02:55:10 <Eduard_Munteanu> The latter isn't checked in the language.
02:55:49 <zcd> i'm not sure i'm understanding the example
02:55:58 <zcd> or what it means to be well-behaved
02:56:03 <no-n> ow, my brains
02:56:36 <bennofs> zcd: it means that 'fmap id = id' and 'fmap (f . g) = fmap f . fmap g' [Functor laws]
02:56:37 <syllogismos> do you know how simple types like [] and Maybe are functors?
02:57:15 <Eduard_Munteanu> zcd: consider fmap :: (a -> b) -> (a -> Int) -> (b -> Int)
02:57:34 <zcd> syllogismos: i follow that far
02:57:55 <zcd> Eduard_Munteanu: ok
02:59:17 <Eduard_Munteanu> zcd: you have a 'b' in the last argument, how do you apply it to the (a -> Int)?
03:00:26 <Eduard_Munteanu> zcd: there's no way you can get at the Int.
03:01:18 <zcd> which Int do you mean
03:01:24 <Eduard_Munteanu> zcd: this is actually an example of a contravariant functor: contramap :: (b -> a) -> f a -> f b   is suitable for this
03:01:24 <zcd> the one in (b -> Int)?
03:02:20 <Eduard_Munteanu> zcd: fmap f t b = ?   (where f :: a -> b, t :: a -> Int, b :: b, and you have to produce an Int as a result)
03:03:26 <Eduard_Munteanu> The function is flipped around with respect to the way you need it to be.
03:04:08 <Eduard_Munteanu> If it was f :: b -> a, you could have applied it to 'b' to get an 'a', which would get you an Int.
03:04:20 <Eduard_Munteanu> (from 't')
03:05:09 <burbul> are there monadic versions of unfoldr or iterate?
03:05:30 <Eduard_Munteanu> burbul: iterateM and such might be in monad-loops
03:05:36 <zcd> that's a lot to process, but your fmap f t b example helped
03:05:43 <zcd> please allow me a few moments to collect it together
03:07:13 <Eduard_Munteanu> zcd: contrafmap g t b = t (g b)   (where g :: b -> a), if it helps
03:07:37 <burbul> thanks!
03:08:37 <zcd> i think i understand
03:08:44 <zcd> so contravariant functor is also a typeclass?
03:09:03 <Eduard_Munteanu> zcd: yeah, not in standard libraries though
03:09:26 <zcd> but if we were to define it, it would be class CVFunctor where (your expression) ?
03:09:57 <Eduard_Munteanu> zcd: yes... contrafmap :: (b -> a) -> f a -> f b
03:10:13 <zcd> whereas a type constructor takes in a type variable and produces a concrete variable
03:10:20 <Eduard_Munteanu> zcd: note a CVFunctor isn't generally a Functor
03:10:52 <Eduard_Munteanu> zcd: er, what do you mean by concrete variable?
03:10:54 <zcd> it wouldn't be a functor at all unless a = b right?
03:11:04 <zcd> s/concrete variable/concrete type
03:11:23 <Yuu-chan_> Eduard_Munteanu: could you demonstrate a simple and useful instance of a cofunctor? Like [] and Maybe for functors.
03:11:23 <zcd> the vocab is taking a while to pick up :>
03:11:26 <Eduard_Munteanu> zcd: you don't control a and b
03:12:57 <Yuu-chan_> I'm looking at Contravariant instances and don't see a single familiar type :(
03:13:24 <zcd> i mean a = b in the sense that cofunctor would behave similar to a functor only when you're using it on two things of a and b with the same type
03:13:38 <zcd> like if i did map (\x->x) [1,2,3]
03:13:52 <Eduard_Munteanu> Yuu-chan_: Reader is contravariant in the environment type
03:14:17 <bennofs> Yuu-chan_: Perhaps 'Predicate' ?
03:14:53 <bennofs> Yuu-chan_: or Comparision. I think 'on' is just 'contramap' for a Comparision
03:17:07 <aloiscochard> benj_: hi mate, I don't think I'll go, the talk don't look that interesting. and you? what you think?
03:17:13 <xaimus_> dl
03:17:22 <xaimus_> wrong window!
03:17:59 <Eduard_Munteanu> zcd: well, sort of, if something is both covariant (Functor-like) and contravariant in the same argument it pretty much has to ignore that variable
03:18:44 <utkarsh> can this be made cleaner/shorter? "do c' <- notChar around
03:18:45 <utkarsh>    return [c']"
03:19:16 <Eduard_Munteanu> zcd: data Proxy a = Proxy, instance Functor Proxy where fmap _ Proxy = Proxy, instance Contravariant Proxy where contramap _ Proxy = Proxy
03:19:32 <Yuu-chan_> bennofs: hm, most of those newly sounding tyupes are just newtype wrappers over simple functions, thanks
03:19:39 <c_wraith> utkarsh: something like..  fmap (:[]) (notChar around)
03:19:59 <Yuu-chan_> Now I'm trying to correspond types of 'on' with contramap
03:20:15 <hc> utkarsh: (:[]) <$> notChar around    maybe?
03:20:23 <bennofs> :t on
03:20:24 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
03:20:45 <bennofs> @let import Data.Functor.Contravariant
03:20:46 <lambdabot>  <no location info>:
03:20:47 <lambdabot>      The package (tagged-0.7) is required to be trusted but it isn't!
03:20:50 <bennofs> :|
03:20:58 <c_wraith> tagged isn't trusted?
03:21:05 <utkarsh> hc, c_wraith, ah, didn't know about (:[]), thanks!
03:21:19 <c_wraith> utkarsh: it's nothing special.  It's just a section of (:)
03:21:33 <Eduard_Munteanu> Yuu-chan_: Profunctor, which is a functor contravariant in one argument and covariant in the other, may be more popular, in e.g. lens. (->) is such a thing
03:21:43 <hc> utkarsh: i didn't either ;)  but i guessed there must be such a constructor and just tried it in ghci
03:22:04 <Eduard_Munteanu> Yuu-chan_: also a lot of Haskell types are wrappers around functions, e.g. State, Reader, Writer... :)
03:22:17 <zcd> Eduard_Munteanu: that makes sense
03:24:13 <Yuu-chan_> bennofs: so, on = flip contramap?
03:24:54 <bennofs> Yuu-chan_: You need a newtype wrapper, but yes (data Binary r a = Binary (a -> a -> r))
03:26:03 <Eduard_Munteanu> zcd: but regarding type constructors, they don't need to produce concrete types.
03:26:40 <Yuu-chan_> Eduard_Munteanu: well, yeah :) I mean that when I was looking at Comonad instances, there were more familiar types, so Contravariant was a little alien at first
03:27:16 <Eduard_Munteanu> zcd: generally constructors are terms which introduce values of a type, that you get from that type's definition
03:27:39 <Eduard_Munteanu> In Haskell type synonyms are constructors too, perhaps confusingly.
03:27:48 <zcd> would a partially applied Either count as a type constructor not producing a concrete type?
03:27:57 <zcd> or is that missing the idea
03:28:59 <Eduard_Munteanu> zcd: it's not really a constructor, I was referring to fancier kinds like stuff enabled by PolyKinds
03:30:26 <zcd> barely touched on kinds, so i'll have to wait til later to see that example :)
03:30:31 <zcd> thanks for the explanations
03:30:46 <Eduard_Munteanu> zcd: with ConstraintKinds, typeclasses are constructors too, e.g. Functor :: (* -> *) -> Constraint
03:31:24 <Eduard_Munteanu> :k Functor Maybe
03:31:25 <lambdabot> Constraint
03:31:46 <zcd> i havent learned what a constraint is yet
03:33:34 <Eduard_Munteanu> zcd: things standing to the left of '=>' are constraints, basically, e.g. return :: (Monad m) => a -> m a
03:36:00 <zcd> so the kind of a functor is a map from map between concrete types into a constraint
03:36:28 <zcd> and a functor applied to the map just gives the constraint
03:36:36 <zcd> to the maybe **
03:36:38 <Eduard_Munteanu> zcd: yeah
03:39:39 <Yuu-chan_> Eduard_Munteanu: "type synonyms are constructors too" ó shouldn't constructors be able to used in patterns?
03:41:01 <haasn> type constructors, not value constructors
03:41:27 <Eduard_Munteanu> The question still stands, however I don't think constructors imply the existence of eliminators.
03:41:57 <Eduard_Munteanu> The way you pattern-match on types is stuff like typeclasses, but that's a bit different.
03:42:29 * Yuu-chan_ got confused
03:42:45 <Eduard_Munteanu> Perhaps it's better to state type synonyms are constructors syntactically.
03:43:24 <zcd> quit
03:47:24 <Eduard_Munteanu> Yuu-chan_: you can think of a definition as a name + a function which constructs it + a function that destructs it (an eliminator), e.g. data Maybe a yields Maybe, introNothing :: Maybe a, introJust :: a -> Just a, elimMaybe :: b -> (a -> b) -> Maybe a -> b
03:47:46 <Eduard_Munteanu> Er, 'Maybe a', not 'Just a'
03:47:52 <Eduard_Munteanu> :t (Nothing, Just, maybe)
03:47:53 <lambdabot> (Maybe a, a1 -> Maybe a1, b -> (a2 -> b) -> Maybe a2 -> b)
03:52:50 <Yuu-chan_> Eduard_Munteanu: I think I can understand value constructors intuitively, but type constructors are still a problem
03:52:56 <Yuu-chan_> (a problem of time, maybe)
03:53:15 <burbul> <Eduard_Munteanu> unfoldrM-based approach is much nicer than original. Thanks v. much!
03:53:26 <benj_> aloiscochard, I'm mostly interested in the second talk, because I spoke to the presenter a few months ago just as he was starting his new company
03:53:53 <Eduard_Munteanu> Nice.
03:55:44 <benj_> aloiscochard, but I agree, a talk about the Num typeclass doesn't exactly get me beating down the door ;)
03:55:56 <benj_> maybe it will turn out to have an exciting twist, who knows!
03:56:47 <aloiscochard> benj_: haha :-) I see, you right who knows! I'll see next week what I have to do, might go then. I'll probably learn some stuff with quickcheck I haven't used it much
03:57:01 <benj_> anyway, we have enough monad tutorials, maybe prospective monad tutorial authors should try a Num tutorial instead, maybe they will write something people understand
03:57:01 <aloiscochard> benj_: i will let you know anyway
03:57:09 <aloiscochard> :-D
03:57:14 <aloiscochard> yeah indeed
03:57:35 <aloiscochard> benj_: you saw that probably http://t.co/H74DfksIDQ I love the part about monad tutorial :-D
03:57:46 <benj_> yep
04:02:49 <ethercrow> is there an irc channel or mailing list about sodium?
04:11:23 <c_wraith> Woo.  I fixed free-operational.  Also, it's 7am.  These are probably related.
04:11:31 <exicer_> Has anyone got any experience using QuickCheck in conjunction with Persistent ?
04:11:33 <no-n> :)
04:17:52 <bennofs> WHat does *** Exception (reporting due to +RTS -xc): (THUNK_STATIC), stack trace:  mean ?
04:17:57 <bernalex> you can do a ++ b ++ c, how do I make a function which does the "++ b ++" part? i.e. take something, ++ b to it, and return a function that takes c
04:18:25 <bennofs> bernalex: use a lambda?
04:18:26 <c_wraith> bernalex: \b a c -> a ++ b ++ c
04:18:54 <c_wraith> bernalex: currying is awesome
04:19:02 <no-n> yes
04:19:07 <no-n> yes it is
04:20:26 <bernalex> c_wraith: right, so what I want is (\a b -> a ++ "some string here" ++ b)
04:20:45 <bernalex> and yes, I can do it with lambda, that's what I am currently doing. I was just wondering if there was another way to do it. :-)
04:20:48 <c_wraith> If the string is a constant, sure.
04:21:05 <ilmig> @pl \a b -> a ++ "some string here" ++ b
04:21:06 <lambdabot> (. ("some string here" ++)) . (++)
04:21:18 <bernalex> oh right
04:21:19 <c_wraith> Heh. You *could* write it like that, but...  why?
04:21:30 <Twey> fmap (++) . flip (++)
04:21:42 <merijn> Twey: Yeah, that's much better >.>
04:21:45 <bernalex> c_wraith: I won't, I was just curious.
04:21:47 <bennofs> How do I debug a stack overflow in haskell?
04:21:50 <bernalex> flip makes me twitch
04:21:51 <Twey> merijn: Glad we agree :-D
04:22:18 <Axman6> bennofs: you share the code, we tell you where it is and tell you how to avoid it in the future ;)
04:22:45 <bennofs> Axman6: unfortunaly, it's not so easy to isolate. That's part of the question: How do I find where the stack overflow occured?
04:23:06 <Twey> bernalex: There's a proposal that would let you write (++ b ++)
04:23:18 <bernalex> Twey: that's what I would like
04:23:25 <Axman6> bennofs: it's not an easy question to answer. the point where the evaluation causes the overflow can be a long way from where the thunk was created
04:23:55 <Twey> bernalex: But it hasn't been implemented.  So get used to flip, or lambdas.  :√æ
04:24:52 <Twey> bernalex: https://ghc.haskell.org/trac/ghc/ticket/8304
04:25:13 <bernalex> Twey: interesting, thanks
04:25:22 <bennofs> Axman6: do you know the ghc option to change the length of cost centre names?
04:25:36 <bennofs> Axman6: nvm, looking at the help helps :) It's -L
04:26:09 <ilmig> most often I find lambdas to be more readable than point-free style. Is this because I'm still a beginner? I.e. does point-free style get more readable with more experience?
04:26:38 <Twey> ilmig: Yes, in non-pathological cases
04:28:06 <bernalex> so is there a zipWithN? heh
04:28:36 <hpc> bernalex: it's called "transpose" ;)
04:28:40 <Twey> bernalex: Yes, there's ZipList
04:28:55 <c_wraith> 5 patches to free-operational, for a total of 8 lines changed.  I hope the pull request is, you know, acknowledged.
04:29:40 <bernalex> Twey: hirr. how does that work?
04:29:47 <Twey> zipWith f xs ys ‚âà f <$> ZipList xs <*> ZipList ys; zipWith3 f xs ys zs ‚âà f <$> ZipList xs <*> ZipList ys <*> ZipList zs; &c.
04:29:48 <utkarsh> can the hoogle cli tool show the source code of a function? if not, is there any other way?
04:29:53 <bernalex> Twey: I have a few [[Char]] that I want to zip with f.
04:30:05 <bernalex> Twey: oh
04:30:28 <prophile> is (a, ()) - or ((), a) - liable to use the same space as just a, or alternatively is there some kind of 'pseudo-pair' type for which this is true?
04:31:01 <c_wraith> prophile: because of laziness, each of those is different from a
04:31:24 <prophile> c_wraith: I had a suspicion that might be the case
04:31:27 <prophile> ah well
04:31:29 <bernalex> Twey: what's "&c."?
04:31:32 <prophile> is there an alternative?
04:32:19 <Twey> bernalex: Abbreviation for ‚Äòet cetera‚Äô, a Latin phrase meaning ‚Äòand others‚Äô
04:32:21 <c_wraith> prophile: nope.  You could try making a strict pair, but it still would have different strictness properties.  The evaluation of the () passed to it might fail.
04:32:31 <bernalex> Twey: f <$> ZipList a <*> ZipList b <*> ZipList c -- gives me Couldn't match type `[Char]' with `[Char] -> b0' Expected type: [Char] -> [Char] -> [Char] -> b0 Actual type: [Char] -> [Char] -> [Char]
04:32:42 <bernalex> Twey: I know what etc is, but I have never ever seen anyone write "&c."
04:32:53 <prophile> c_wraith: could I work around it with type families if I can be sure to wrap a in a newtype?
04:33:21 <c_wraith> prophile: possibly.  Or maybe a data family.
04:33:29 * prophile considers this
04:33:40 <Twey> bernalex: Now you have!
04:33:54 <Twey> bernalex: Sounds like your function takes the wrong number of arguments
04:34:17 <Twey> (for the context where you've used it)
04:35:33 <c_wraith> I'm still kind of surprised you can add newtypes as instances for data families.
04:35:41 <c_wraith> Even though it does make sense.
04:36:34 <Twey> bernalex: Oh, and you'll need to extract the contents with getZipList afterwards, too
04:37:10 <bernalex> Twey: oh
04:38:12 <Twey> c_wraith: Data families are just compile-time; newtype is a run-time thing
04:38:52 <c_wraith> Twey: yeah, all that really matters is that you create a constructor.  As far as the type checker is concerned, that's good enough
04:39:05 <bernalex> Twey: why is ZipList capitalised btw?
04:39:22 <Twey> bernalex: Because it's a constructor
04:39:23 <c_wraith> Twey: how the constructor gets compiled differs, but the type checker only cares that the constructor exists.
04:39:32 <bernalex> oh of course
04:39:54 <Twey> bernalex: ZipList is just a newtype wrapper around [] to carry the zipping Applicative instance
04:39:58 <bernalex> Twey: where do you getZipList though?
04:40:15 <testuser> lets say I have a set aa = [1,2,3] and bb = [1,4,5] isn't the notation [x|x<-aa, x<-bb] supposed to give [1]?
04:40:26 <bernalex> since :t f <$> ZipList a <*> ZipList b <*> ZipList c <*> ZipList d fails, I assume it's not just prefacing it with getZipList $
04:40:29 <Twey> bernalex: getZipList is the function (actually, it's a record field) that gets the list back out of the ZipList when you're done zipping it
04:40:47 <Twey> bernalex: It is
04:41:04 <bernalex>     Couldn't match type `[Char]' with `[Char] -> [Char] -> a0'
04:41:05 <Twey> bernalex: There's something else wrong in your code; I don't know what it is without seeing the code
04:41:05 <bernalex>     Expected type: [Char] -> [Char] -> [Char] -> [Char] -> a0
04:41:07 <bernalex>       Actual type: [Char] -> [Char] -> [Char]
04:41:13 <bernalex> zipWith f ab works fine
04:41:36 <bernalex> *a b
04:41:40 <bernalex> f ATM is just f a b = a ++ "\t" ++ b
04:41:59 <Twey> testuser: No.  ‚Üê is not a membership predicate, it means ‚Äòtake each element from this list‚Äô
04:42:01 <bernalex> so [Char] -> [Char] -> [Char]. a, b, c and d are [[Char]].
04:42:20 <Twey> testuser: I think you mean [ x | x ‚Üê aa, elem x bb ]
04:43:04 <testuser> Twey: but isn't the set notation for x belongs to aa and x belongs to bb [x|x<-aa, x<-bb]?
04:43:53 <Philonous> Twey, Ha, I've always read that <- as an epsilon, as in "member"
04:43:53 <Twey> > let f a b = a ++ "\t" ++ b; as = ["foo", "bar", "baz"]; bs = ["quux", "arthur", "ribbit"] in getZipList $ f <$> ZipList as <*> ZipList bs
04:43:55 <lambdabot>  ["foo\tquux","bar\tarthur","baz\tribbit"]
04:44:19 <Twey> testuser: List comprehensions aren't set notation. ‚ò∫
04:44:35 <bernalex> Twey: so for a and b that works
04:44:40 <bernalex> Twey: but I am doing it with three more
04:44:43 <bernalex> *two
04:44:43 <testuser> Twey: :/ they look the same :-(
04:45:00 <bernalex> getZipList $ f <$> ZipList a <*> ZipList b -- works, getZipList $ f <$> ZipList a <*> ZipList b <*> ZipList c -- fails
04:45:06 <Twey> Philonous: Do you mean ‚àà?  I think it's designed to evoke that
04:45:14 <Twey> bernalex: How many arguments does f take?
04:45:17 <bernalex> getZipList $ f <$> ZipList a <*> ZipList b <*> ZipList c <*> ZipList d also fails.
04:45:45 <bernalex> Twey: two. I guess I was being unclear. I want a zipWith that accumulates N.
04:45:51 <Philonous> Twey, But the unicode symbol seems to be left arrow rather than epsilon.
04:46:13 <Twey> bernalex: Aha.  Yes, that's not zipWith at all.
04:46:21 <bernalex> Twey: sorry for being unclear
04:47:18 <Twey> > let f = intercalate "\t"; as = ["foo", "bar", "baz"]; bs = ["quux", "arthur", "ribbit"] in map f $ transpose [as, bs]
04:47:19 <lambdabot>  ["foo\tquux","bar\tarthur","baz\tribbit"]
04:47:27 <bernalex> I want to take N lists. so if I have the lists ["foo"], ["fu"], ["bar"], and ["baz"], I want to make the list ["foo\t... right. that.
04:47:28 <Twey> bernalex: Is that better?
04:48:03 <Twey> Philonous: Œµ (epsilon) and ‚àà (in) are separate characters to start with :√æ
04:48:19 <bernalex> Twey: oh wow, thanks!
04:48:48 <Philonous> Twey, The second is an alternate form of epsilon, isn't it?
04:48:55 <Twey> Philonous: Especially since Œµ is often used for ‚Äòempty‚Äô, so it's not a type error to see an expression like e ‚àà Œµ  :√æ
04:49:07 <Twey> Philonous: No, you're thinking of the lunate epsilon, but that's also a different character
04:49:15 <Twey> œµ
04:49:44 <testuser> how can I say any value in elem, like p = [[1,2,3],[2,2,4],[2,3,5]] and I want to match [1,2,3],[2,2,4]
04:49:46 <bernalex> though now that I think about it and see it in practice, it's not good enough, lol
04:50:45 <bernalex> because if I have ["foo","bar"] and ["one","two","three","four"], then I want "\tthree" and "\tfour", not "three" and "four".
04:53:26 <Twey> bernalex: You can just tweak f, then: f [x] = '\t' : x; f xs = intersperse '\t' xs
04:53:52 <Twey> bernalex: But it sounds like you might be doing pretty-printing, in which case there are several excellent libraries
04:54:02 <Philonous> Twey, The English Wikipedia doesn't elaborate on the history of the element symbol, but according to the German Wikipedia it is a (stylized) epsilon.
04:55:38 <Philonous> Twey, Though maybe you where talking about unicode.
04:56:05 <Twey> Philonous: Interesting!  I was, though, yes (or TeX/modern mathematics, equivalently)
04:56:54 <Twey> ¬´ This notation was invented by Peano, from the first letter of the Greek word ŒµŒØŒΩŒ±Œπ, meaning is. ¬ª
04:57:27 <Twey> Great, the very symbol we use for membership is the result of a membership/identity confusion :√æ
05:01:48 <bernalex> where does the naming convention "nub" and "nubby" come from?
05:03:18 <Fuco> what is this syntax {..} mean? Does it expose all the "records" in the data type? fmap f (z@ListZipper{..}) = z { list = fmap f list }, where data ... =  ListZipper { list :: [a] , index :: Int }
05:03:35 <Twey> bernalex: It's not ‚Äònubby‚Äô, it's ‚ÄònubBy‚Äô.  The ‚Äònub‚Äô of something is the important part, the distinguishing part; the -By suffix is a convention for functions that are like other functions, but with some kind of user-supplied comparison function (e.g. groupBy, sortBy, &c.)
05:03:55 <bernalex> Twey: right, of course. because nub is just nubBy (==)
05:04:57 <Twey> Fuco: It's called ‚Äòrecord wildcards‚Äô, enabled with {-# LANGUAGE RecordWildCards #-}, and it's completely equivalent to { foo = foo, bar = baz, baz = baz, ‚Ä¶ } for all fields of a record
05:05:20 <Fuco> okey, thanks. I see the pragma now :P
05:05:31 <Twey> Fuco: So yes, it can be used to extract all fields of a record into the current scope; it can also be used to *build* a record according to names in the current scope
05:05:53 <mm_bureau> i think, "nub" translates to "essence"
05:05:58 <Twey> @let data Record { _int ‚à∑ Int, _bool ‚à∑ Bool }
05:05:58 <lambdabot>  Parse failed: Parse error: {
05:06:00 <mm_bureau> but i don't know what language that is
05:06:04 <Twey> @let data Record = Record { _int ‚à∑ Int, _bool ‚à∑ Bool }
05:06:04 <lambdabot>  Parse failed: Parse error: ÔøΩ
05:06:06 <Twey> Bah
05:06:09 <Twey> mm_bureau: English
05:06:10 <bennofs> Does GHC have "stack profiling" ?
05:06:13 <Fuco> Twey: I can imagine it, thanks :D
05:06:16 <mm_bureau> ah =)
05:21:07 * hackagebot data-default-generics 0.3 - A class for types with a default value  http://hackage.haskell.org/package/data-default-generics-0.3 (jcristovao)
05:22:18 <DrAwesomeClaws> is there any reason one can't use a where clause in a lambda that contains a do block?
05:25:56 <skuggi_> i don't think you can use a where clause in any lambda
05:26:11 <DrAwesomeClaws> thanks skuggi_, that explains it then.
05:26:40 <skuggi_> DrAwesomeClaws: you can use let, though.
05:30:51 <DrAwesomeClaws> thanks again skuggi_.  That worked.  Just wanted a few helper functions to make things easier to read
05:37:47 <Twey> DrAwesomeClaws: where-clauses are part of the syntax of a case branch, so they can only be used in things like name definitions or case-expressions
05:40:16 <DrAwesomeClaws> Twey: interesting.  I've always just associated them with do blocks, haha.  But i've only been using haskell for a week or so.
05:40:44 <DrAwesomeClaws> ghc is the soup nazi of compilers
05:40:56 <Maior> er, what?
05:41:25 <DrAwesomeClaws> "No binary for you!"  it yells at me like the soup nazi
05:41:54 <dmj`> can i make a safecopy instance for a type than contains IO ()? Can I serialize IO actions basically
05:42:13 <DrAwesomeClaws> http://www.youtube.com/watch?v=WZ3AOmZ2fps  reference in case anyone is unfamiliar and thinks i'm just being randomly racist or somehting
05:45:09 <Twey> dmj`: No
05:48:10 <dmj`> Twey: I want to save websocket connections in acid-state
05:50:48 <Twey> dmj`: That doesn't sound like something that makes sense
05:51:51 <Twey> dmj`: You can save a token representing the session, but once the connection is gone you can't get it back unless the client decides to connect again
05:53:36 <dmj`> Twey: in a load-balanced environment w/ many web-servers that could fail, MVars will be erased (upon crash). Suppose a client is still connected (or thinks it is), a server goes down, another one can pick up his place by reading the websocket connection from a shared remote state
05:53:57 <_d0t> Hi. Is there any way to make cabal produce an executable ready for profiling without configure options?
05:54:05 <dmj`> Twey: Also, from what I've read, getting load balancers working w/ websockets is a pita
05:54:53 <Twey> dmj`: I'm not sure TCP is capable of that.  But I'm no network expert.  Either way, I don't see how that requires you to store an IO action.
05:55:43 <dmj`> Twey: In order to store a WS.Connection in acid-state I'd need to make an safe-copy instance for it. WS.Connection contains an IO action
05:55:50 <dmj`> a*
05:56:14 <dmj`> data ConnectionOptions
05:56:15 <dmj`>   = ConnectionOptions {connectionOnPong :: IO ()}
05:56:15 <dmj`>         -- Defined in `Network.WebSockets.Connection'
06:33:57 <jdnavarro> I remember there was a module for debugging concurrent programs where there was a function to query thread statuses but now I can't remember the name of this module...
06:34:03 <jdnavarro> anyone knows?
06:34:41 <bennofs1> @hoogle threadStatus
06:34:42 <lambdabot> GHC.Conc.Sync threadStatus :: ThreadId -> IO ThreadStatus
06:34:43 <lambdabot> GHC.Conc threadStatus :: ThreadId -> IO ThreadStatus
06:34:43 <lambdabot> GHC.Conc.Sync data ThreadStatus
06:35:28 <jdnavarro> that's the one! thanks
06:36:18 * hackagebot yesod-auth-oauth2 0.0.1 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.1 (PatrickBrisbin)
06:36:27 <DrAwesomeClaws> haskell is freaking me out.  I keep majorly refactoring things without really knowing what I'm doing.... and it keeps just working
06:55:53 <zipper> :t System.Random.random
06:55:54 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
06:56:55 <Iceland_jack> > random (mkStdGen 15)
06:56:57 <lambdabot>  (5117352288778814409,67368610 2103410263)
07:14:15 <zipper> Doesn't System.Random come with ghci?
07:14:52 <zipper> or the haskell platform?
07:15:09 <geekosaur> platform yes, I don't recall it being a bootlib
07:19:44 <Twey> Hrm‚Ä¶ is there no way to generate random numbers in the Report?
07:20:19 <Twey> I always thought it was standard
07:36:26 <shapr> GOOD MORNING!
07:36:28 * shapr hops randomly
07:36:37 <merijn> shapr: No such thing :p
07:36:45 <shapr> sure is quiet in here today.
07:37:38 <zygentoma> I must say, this "learn you a haskell" book I found last week, it's just awesome ‚Ä¶
07:38:46 <zygentoma> I've read "real world haskell" before and it almost made me never want to try haskell anymore ‚Ä¶
07:39:54 <AlainODea> zygentoma: LYAH is really great. RWH is simultaneously extremely demanding and has enough errors to be a real bore. I made it most of the way through RWH with blogs and comments to fix the issues
07:40:35 <zipper> I expected System.Random to be standard too.
07:40:38 <hc> hmm, it was the other way round with me
07:40:41 <zipper> Batteries included
07:40:46 <AlainODea> zygentoma: RWH is a good follow up because it makes you think functionally to solve problems
07:43:33 <AlainODea> zygentoma: jekor's Haskell from Scratch videos helped me realize monads and IO are no big deal and are actually quite elegant in Haskell
07:44:19 <zygentoma> AlainODea: well, there was actually one chapter int R
07:44:20 <user`> is there a tutorial that explain in high level, instead of tons of examples
07:44:56 <zygentoma> *RWH that I partly liked because you could really think into that stuff he did with all the folds
07:46:06 <zygentoma> user`: do you know functional programming languages?
07:46:23 <user`> yes
07:46:26 <merijn> AlainODea: RWH isn't so much filled with errors, as it refers to quite a lot of libraries (which is good, it familiarises you with how Haskell libraries work), but those libraries have updated their APIs since the book was written
07:46:36 <user`> zygentoma yes
07:47:55 <zygentoma> user`: then I don't know, unfortunately. everything I know still introduces how functional programming works
07:49:02 <AlainODea> merijn: good point. It's more of an issue with how fast moving a target these libraries were at the time
07:50:27 <merijn> AlainODea: I still think a lot of the chapters are useful
07:50:47 <merijn> AlainODea: For example, the parsec chapter deals with parsec 2, so the code samples may not work with parsec 3, but the general overview does
07:50:57 <merijn> Understanding the parsec haddocks is much easier after reading the book
07:51:23 <AlainODea> merijn: I agree. I learned a lot from it.  The concepts are generally well explained
07:53:48 <merijn> I usually recommend reading it after LYAH, though
07:57:31 <zipper> Why is man cabal `No manual entry for cabal'?
07:57:36 <zipper> smh
08:00:22 <utkarsh> any ideas on refactoring this? https://gist.github.com/e2381ce06f2c7fbea164
08:00:36 <utkarsh> there's a lot of repeated code, but I can't seem to group them
08:02:49 <shapr> byorgey_: Busy in October? Think you might have time to give a talk at a Haskell Con in Nashville?
08:04:14 <quchen> zipper: Did you install it via `cabal install cabal-install`?
08:04:23 <quchen> Or to a non-standard directory?
08:04:24 <shapr> utkarsh: Can you factor out: where thing n = anyChar >> skipSpace >> n <$> pCombinedSelector
08:04:36 <zipper> quchen: I have used cabal install random
08:05:02 <zipper> quchen: and it's working ok
08:05:18 <shapr> I was hoping cabal install random would pick a random package and install it :-(
08:05:33 <dcoutts> shapr: ;-)
08:06:06 <quchen> shapr: Preferrably ByteString-0.5 or something
08:06:12 <utkarsh> shapr, nice idea, I didn't even think of using `where` for this, let me try
08:06:33 <shapr> dcoutts: I'd see if I could bribe you to speak at a Haskell Con in Nashville, but I think flying you over might be too expensive.
08:06:59 <dcoutts> shapr: sadly. If I'm over for another reason some time it'd be plausible
08:17:21 <user`> is there a place where the specification for the Haskell language is defined?
08:18:00 <geekosaur> http://www.haskell.org/onlinereport/haskell2010/
08:27:10 <awilkins> Holy monkey this channel has a lot of users
08:27:43 <awilkins> Ok ; so, I'm trying to patch Pandoc. I think I've found the bit I want. I may have questions.
08:33:37 <awilkins> So
08:33:57 <awilkins> ref' <- if labIsRef then lab else ref
08:34:09 <awilkins> How do I make lab lowercase
08:34:29 <quicksilver> map toLower lab
08:34:43 <quicksilver> > map toLower "haPPy BUnNy"
08:34:43 <awilkins> Doesn't compule
08:34:45 <lambdabot>  "happy bunny"
08:34:58 <quicksilver> it does for me.
08:34:59 <Cale> awilkins: What is the type of lab?
08:35:21 <Cale> You probably don't want to make lab itself lowercase, it's probably not a string, given that code.
08:35:36 <Cale> Maybe you want to make ref' lowercase?
08:35:52 <Cale> Or perhaps you want to  fmap (map toLower) lab  ?
08:35:58 * geekosaur won ders if that just needs to be let instead of <-
08:36:07 <Cale> It's hard to tell what's right here, not knowing the types
08:37:00 <awilkins> Says it's an F Inlines
08:37:18 <awilkins> Can you reassign variables in Haskell?
08:37:25 <meretrix> Anyone know the timeframe for ghc-7.8.1_rc2?  A few days or more like a month?
08:37:27 <geekosaur> they are not variables and therefore no
08:37:35 <Cale> They are variables :P
08:37:36 <awilkins> So could I do ref' <- map toLower ref'  ?
08:37:41 <geekosaur> no
08:37:45 <Cale> They're just not mutable
08:37:52 <awilkins> Yeah, grr, functional, etc
08:38:04 <Cale> awilkins: you could write  let ref'' = map toLower ref'
08:38:14 <geekosaur> I am thinking you need to read a tutorial, you're trying very hard to write python in haskell and it just doesn't work...
08:38:15 <awilkins> My problem : pandoc has implicit linking for headers
08:38:37 <awilkins> But   # Topic Header   will only link from [Topic Header] and not [topic header]
08:38:43 <awilkins> ie - case sensitive
08:38:51 <awilkins> Want to patch this so it's insensitive
08:39:07 <Cale> ah, so this is in pandoc's code?
08:39:12 <Cale> Where are you looking right now?
08:39:32 <awilkins> Yeah this is the block starting at line 1604 of Markdown.hs as of current HEAD
08:39:35 <awilkins> From github
08:40:00 <awilkins> Line I've edited is line 1628
08:40:41 <awilkins> It just seems might inconvenient and unintuitive to have to write [topic header](#topic-header)
08:41:03 <awilkins> To link to # Topic Header
08:41:23 <Cale> ah, okay, so that has nothing to do with strings at all, so we need to look at what the heck an Inlines is
08:41:34 <Cale> Also, it might be nice to know what this F monad is.
08:44:27 <Cale> https://github.com/jgm/pandoc/blob/56320f479e13bd643168d4f7217407490dbaf9ca/src/Text/Pandoc/Parsing.hs#L126 -- okay, so F is defined here, it's apparently just a reader monad
08:44:53 <Cale> (I find this kind of thing a little questionable, but okay)
08:46:20 <bennofs1> Oh, pandoc is also going to be broken with AMP?
08:47:19 <passiveobserver> What's the best implementation for for/while loop that supports 'break'/'continue' out there?
08:47:23 <Cale> https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Builder.hs -- Inlines is defined here
08:47:57 <bennofs1> passiveobserver: if you only need break, runMaybeT $ forever $ ...
08:48:03 <Cale> passiveobserver: You could use ContT with callCC along with any other kind of loop.
08:49:25 <Cale> callCC $ \break -> forM_ xs $ do ... when something $ break () ...
08:50:00 <bennofs1> Cale: you don't need callCC for that. MaybeT is enough
08:50:34 <Cale> sure
08:50:44 <bennofs> Btw, is there a recommended library for memoizing?
08:51:10 <dhrosa> lternative question, is nuking my ~/.config safe?
08:51:21 <dhrosa> oops
08:51:24 <dhrosa> wrong window
08:51:39 <awilkins> Thinking now that just mapping ref' to lowercase isn't going to fix it because the keys in headers are mixed case
08:52:01 <Cale> bennofs: I like data-memocombinators as a first approach. It doesn't always perform the best, but it's rather elegant and an easy first thing to try.
08:52:04 <awilkins> Also need to map headers to have lowercase keys
08:53:51 <monochrom> w00t callCC :)
08:53:52 <Cale> ref' also isn't a String, it's an Inlines, which is apparently a sequence of values of type Inline
08:54:16 <Cale> awilkins: and Inline is a data type with a good 20 or so constructors
08:54:18 <Twey> awilkins: You're going about this the wrong way.  You shouldn't be patching Pandoc to do this, you should be writing a function to transform the Pandoc document tree before you write it
08:54:24 <Cale> https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs#L223
08:55:00 <bennofs> Cale: Do you know if there is a library providing some template haskell to just create a static lookup table at compile time for functions having a bounded input type?
08:55:27 <Cale> bennofs: Sounds like a reasonable idea, but I don't know of one
08:56:59 <quicksilver> also sounds like the kind of think data-memocombinators does a reasonable job of anyway
08:57:12 <Cale> bennofs: They'd also probably have to be functions whose results can be succinctly turned into Haskell literals, if the point is to avoid runtime costs of computing them
08:57:40 <jophish_> Does it make sense to have MonadPlus a, MonadPlus b => MonadPlus (a,b)
08:57:51 <Cale> jophish_: I don't think so
08:57:52 <jophish_> For a writer monad with multiple output streams
08:58:04 <Twey> jophish_: Well, (a, b) isn't generally a Monad
08:58:13 <Twey> It has the wrong kind
08:58:17 <Cale> Yeah, that's a kind error
08:58:30 <Cale> If you have MonadPlus a, then (a,b) is a kind error
08:58:33 <jophish_> oh yes, of course
08:58:34 <Twey> jophish_: s/MonadPlus/Monoid/ and that certainly makes sense, though
08:58:50 <Twey> s/MonadPlus/Monoid/g rather
08:58:57 <jophish_> I think that's what I meant
08:59:08 <monochrom> there is no such thing as (Maybe, [])
08:59:14 <Cale> (and the instance for Monoid already exists)
08:59:15 <jophish_> ah, that's already an instance of Monoid
08:59:40 <quicksilver> monochrom: not canonically, anyway. It's clear enough what that should mean.
08:59:51 <Twey> :k (Maybe, [])
08:59:52 <lambdabot>     Expecting one more argument to `Maybe'
08:59:52 <lambdabot>     In a type in a GHCi command: (Maybe, [])
09:00:01 <bennofs> Cale: why would they? Doesn't this also work for a function of type (Enum type with 6 Elements) -> S.Set Something ?
09:00:07 <quicksilver> data Pair2 f g x = (f x, g x)
09:00:17 <monochrom> it is not clear to me at all
09:00:24 <quicksilver> although there is also data Pair2' f g x y = (f x, g y)
09:00:34 <Twey> Seems like that should work, yeah, as (Œõ x ‚Üí Maybe x, Œõ x ‚Üí [x])
09:00:39 <bennofs> Cale: with sufficient sharing, it would at least avoid the allocation of the set each time
09:01:19 <Twey> Kind (‚òÖ ‚Üí ‚òÖ, ‚òÖ ‚Üí ‚òÖ) perhaps
09:01:44 <ParahSailin> looks like aeson on hackage does not build with 7.8 rc1, the template-haskell 2.9 api has changed
09:01:59 <Twey> Ugh, that seems unpleasant because of tuple syntax
09:02:23 <monochrom> hm, template haskell changes again? :)
09:03:08 <Twey> Kind (‚òÖ ‚Üí ‚òÖ, ‚òÖ ‚Üí ‚òÖ) for '(Maybe, []) makes sense under DataKinds
09:03:44 <Twey> I can't think of a sane interpretation for (Maybe, []) where (,) is the normal type constructor
09:04:32 <Twey> Well, sane and non-surprising; quicksilver's is reasonable and potentially useful but would be quite surprising
09:05:36 <Twey> That bites me with ConstraintKinds a lot, actually ‚Äî I want to be able to pass a ‚òÖ ‚Üí Constraint like Œõ a ‚Üí (Show a, Read a) around
09:07:20 <pseudolio> You would get bitten a lot more with first-class type functions floating around in the system.
09:07:46 <Twey> pseudolio: Well, as someone who likes Agda‚Ä¶ :√æ
09:08:17 <Twey> But yes, I see where you're coming from; I was just using the syntax to illustrate the type I wanted
09:08:50 <Twey> We already have type functions like ‚ÄòShow‚Äô, but there's no way to produce an equivalent function for (Show a, Read a)
09:10:11 <pseudolio> The point is that only dealing with partially applied constructors makes a lot more inference tractible, which makes the majority of cases easy, and rules out a few.
09:10:23 <pseudolio> Instead of making everything difficult, but enabling certain extra things.
09:11:09 <Twey> pseudolio: Are you saying that allowing functions on larger constraints (specifically) breaks type-checking?
09:11:32 <pseudolio> Allowing arbitrary functions on the type level breaks inference.
09:11:47 <Twey> Absolutely, but that wasn't what I was proposing
09:11:52 <pseudolio> So you add lots of annotations to your code.
09:12:12 * hackagebot quickcheck-property-monad 0.1 - quickcheck-property-monad  http://hackage.haskell.org/package/quickcheck-property-monad-0.1 (BennoFuenfstueck)
09:13:00 <Twey> It seems to me that (Œõ a ‚Üí (Show a, Read a)) has essentially the same properties as (Œõ a ‚Üí Show a)
09:13:36 <pseudolio> One is eta reducible to a construtor, and one is not.
09:14:26 <tpsinnem> hey -- ghci question: i try to do ":list getFC" and get "cannot list source code for getFC: module Idris.ParseHelpers is not interpreted". what command could i use to be able to do this?
09:14:30 <Twey> pseudolio: But it could be, if you defined (Show, Read) as a constructor
09:15:46 <Twey> tpsinnem: You need to have loaded the module source into GHCi, e.g. by running :l Idris/ParseHelpers.hs, rather than loading a pre-compiled module
09:15:57 <Twey> Otherwise you can't see the source, for obvious reasons
09:16:36 <tpsinnem> twey, ok i guess i had done the latter
09:16:36 <tpsinnem> thansk
09:21:14 <bennofs> does GHC translate 'if x == Constr1 then ... else if x == Constr2 then ... else ...' to 'case x of { Contr1 -> ...; Constr2 -> ...; _ -> ... }' ?
09:24:11 <pseudolio> Twey: (,) is already so overloaded already, I guess it doesn't hurt to add more.
09:25:09 <pseudolio> Already already.
09:28:26 <FreeFull> pseudolio: is (,) overloaded?
09:28:42 <pseudolio> Yeah.
09:28:58 <pseudolio> It's tuple value, tuple type and conjunction of constraints.
09:28:58 <FreeFull> It does get used in different contexts, but those are clearly separated
09:29:08 <FreeFull> No way to mix them up
09:29:15 <pseudolio> That's not true anymore.
09:29:37 <pseudolio> As soon as people start adding type level stuff to replicate things up one level and having constraint kinds and whatnot....
09:29:45 <pseudolio> All those things get mixed together, and it's terrible.
09:30:17 <pseudolio> So now you have (5, 6) :: (Int, Int), and then '(Int, Int) :: (*, *).
09:30:35 <FreeFull> I suppose that is a problem
09:30:44 <pseudolio> And does 'type Foo a b = (a, b)' mean that a and b are Constraint or *?
09:30:48 <bennofs> (5,6) :: (Nat, Nat) :)
09:31:36 <adelbertc> question about the "algebra of algebraic data types" post (http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/) - for List zippers it says the derivative of 1/(1-a) // representing the algebraic form of a list // is 1 / (1-a)^2 which is L(a)^2. Shouldn't that be 1 / (a-1)^2, in which case this thing sort of goes down the drain? (i'm sure theres an explanation, im just wondering what)
09:32:23 <FreeFull> pseudolio: I would let them be both
09:32:43 <pseudolio> That's not possible without further extending the type system.
09:33:39 <pseudolio> You'd need a super-kind that contains Constraint and *, and then Foo would be polymorphic over that.
09:33:52 <pseudolio> But that doesn't exist right now.
09:34:39 <pseudolio> As far as I know.
09:42:42 <yyyyy> cabal install idris, solved?
09:42:56 <yyyyy> :p
09:43:37 <pseudolio> I assume idris just has everything in the same namespace, and you don't get all this punning.
09:43:42 <pseudolio> Which I think is a better situation.
09:44:38 <jophish_> What was the motivation behind implicit parameters?
09:45:05 <pseudolio> I want to plumb things around in my code, but not write it in monadic style.
09:45:07 <pseudolio> Probably.
09:46:56 <pseudolio> If you want to do that kind of thing a _lot_, it has some advantages over what you could easily do with reader, too.
09:47:09 <pseudolio> But I don't think they tend to get much use.
09:48:42 <jophish_> awesome, thanks pseudolio
09:49:39 <yyyyy> pseudolio, that's right.
09:50:44 <zipper> How do I fix this error I got while installing xmonad:
09:50:46 <zipper> Warning: haddock-interfaces: /usr/share/doc/xmonad-contrib-0.11.2/html\ /xmonad-contrib.haddock doesn't exist or isn't a file
09:56:52 <enthropy> zipper: you can safely ignore it and just read docs from http://xmonad.org/xmonad-docs
10:02:48 <_sebastian_> hi all
10:04:54 <_sebastian_> let's compare Monoid and Stringlike classes (Stringlike may have instances for String, Lazy ByteString, Strict ByteString, Lazy Text and Strict Text)
10:05:11 <_sebastian_> mappend == ++
10:05:18 <_sebastian_> mempty = []
10:05:30 <_sebastian_> mconcat = concat
10:05:38 <_sebastian_> null = ... ?
10:06:56 <_sebastian_> Eq a, Monoid a => mnull :: a -> Bool
10:07:40 <shachaf> ByteStrings aren't string-like at all.
10:08:02 <shachaf> Well, unless "string" means "sequence".
10:08:04 <haasn> other than being strings over the alphabet of ‚Äúbytes‚Äù
10:08:13 <WraithM> Is there a good way to kill threads in ghci? I
10:08:57 <_sebastian_> shachaf: http://hackage.haskell.org/package/string-conversions-0.3.0.2/docs/Data-String-Conversions.html this are instances for ByteStrings
10:08:57 <WraithM> I guess I'm testing some multi-threaded stuff, and the other threads keep running after I kill main.
10:09:46 <haasn> ‚ÄúAssumes UTF-8 encoding for both types of ByteStrings‚Äù :(
10:09:47 <shachaf> Well, it uses UTF-8 to encode the ByteString.
10:10:01 <haasn> hey, at least it's not .Char8
10:10:39 <shachaf> Which is probably better than any other choice for an instance, but maybe still a bit fishy.
10:10:40 <haasn> bugs from using UTF-8 where it's not appropriate are probably rarer (and harder/subtler to track down) than bugs from not using UTF-8 where it could have been not appropriate
10:10:54 <haasn> could have been appropriate*
10:12:19 <_sebastian_> UTF-8 ist fine, if you want to convert strings
10:13:09 <haasn> but why not use encodeUtf8 and decodeUtf8
10:13:13 <haasn> I don't understand why this typeclass exists
10:14:43 <_sebastian_> haasn: because using "cs" is much easier than TL.fromStrict $ BS.decodeUtf8 $ ... $ BS.encodeUtf8 $ TL.toStict
10:15:36 <damien____> hey folks, can't seem to decipher the error message http://lpaste.net/100192
10:15:45 <_sebastian_> haasn: as in https://github.com/hunt-framework/hunt/blob/master/hunt-client/src/Hunt/Server/Client.hs#L138
10:17:19 <edwardk> You know you've been off writing javascript too long when you start putting semicolons at the end of your lines in Haskell. ‡≤†_‡≤†
10:18:06 <djahandarie> SPJ does it!
10:18:15 <bennofs> Can you put semicolons at the start of the lines, like they do in GHC, in javascript? WOuld probably confuse too many people ...
10:18:16 <Reite> I hate semicolons
10:18:17 <applicative> damien____: you need x ** y, rather than x ^ y
10:18:21 <haasn> _sebastian_: looks to me like that's just T.unpack / T.pack
10:18:27 <applicative> > 2 ** 2.2
10:18:29 <lambdabot>  4.59479341998814
10:18:37 <haasn> come to think of it: is there something like a Text.lift :: (String -> String) -> Text -> Text?
10:19:00 <damien____> >2^0.63
10:19:07 <haasn> :t over packed
10:19:08 <edwardk> bennofs: the problem is dynamic semicolon insertion so most of the time you do that you are just inserting extra semicolons and blank statements
10:19:08 <lambdabot>     Not in scope: `packed'
10:19:08 <lambdabot>     Perhaps you meant one of these:
10:19:08 <lambdabot>       `BS.pack' (imported from Data.ByteString),
10:19:19 <damien____> > 2 ^0.63
10:19:20 <lambdabot>  Could not deduce (GHC.Real.Integral b0)
10:19:21 <lambdabot>    arising from a use of `GHC.Real.^'
10:19:21 <lambdabot>  from the context (GHC.Num.Num a)
10:19:21 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
10:19:21 <lambdabot>  The type variable `b0' is ambiguous
10:19:23 <vozz_> So I can do :t to find the type of something.. what do I do to find out more about a type? Is there some command i can do to find its definition?
10:19:32 <damien____> applicative : I see what you mean
10:19:39 <edwardk> :t under Data.Text.Lens.packed
10:19:40 <lambdabot> T.IsText b => (String -> String) -> b -> b
10:19:41 <haasn> :t under T.packed -- :)
10:19:41 <lambdabot> T.IsText b => (String -> String) -> b -> b
10:19:47 <edwardk> :t under Data.Text.Strict.Lens.packed
10:19:48 <lambdabot> (String -> String) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
10:20:01 <haasn> Is there an infix equivalent for under?
10:20:04 <edwardk> :t over Data.Text.Strict.Lens.unpacked
10:20:05 <lambdabot> (String -> String) -> Data.Text.Internal.Text -> Data.Text.Internal.Text
10:20:10 <applicative> :t (T.pack .)
10:20:11 <lambdabot> Couldn't find qualified module.
10:20:12 <edwardk> you can use over unpacked instead
10:20:23 <haasn> ah
10:20:29 <edwardk> an no there is no infix equivalent
10:20:40 <haasn> _sebastian_: unpacked %~ urlEncode -- lens strikes again
10:20:51 <_sebastian_> haasn: haha, ty :)
10:21:09 <haasn> anyway, T.pack / T.unpack isn't that much longer than cs / cs
10:21:11 <_sebastian_> haasn: ahyway, there were two conversions nececarry
10:21:25 <_sebastian_> args
10:21:28 <haasn> _sebastian_: why? urlEncode is defined on String, and Text <-> String is packed
10:21:44 <haasn> oh, is this a different urlEncode?
10:22:02 <_sebastian_> http://hackage.haskell.org/package/http-types-0.8.3/docs/Network-HTTP-Types-URI.html#v:urlEncode
10:23:04 <haasn> _sebastian_: then you need decodeUtf8/encodeUtf8 yeah
10:23:07 <haasn> but that's still not two conversions
10:23:42 <_sebastian_> ?
10:23:45 <haasn> I won't comment on whether using ByteString for urlEncode is correct in the first place since I don't know enough about HTTP
10:24:00 <haasn> _sebastian_: decodeUtf8 :: ByteString -> Text
10:24:06 <haasn> (is UTF-8 even correct here?)
10:24:06 <vozz_> Okay so I've figured you can do :info to tell you where it's defined... Is there a way to print the definition or those lines of code into ghci?
10:24:23 <_sebastian_> haasn: Strict Text or lazy Text?
10:24:33 <haasn> ah, lazy probably
10:24:49 <haasn> no, both exist
10:24:57 <haasn> Data.Text.Encoding vs Data.Text.Lazy.Encoding
10:25:01 <_sebastian_> yep
10:25:20 <_sebastian_> I think I'll stick with cs
10:25:28 <haasn> edwardk: didn't we have Data.Text.Encoding.lens?
10:25:31 <haasn> .Lens*
10:25:52 <haasn> for an Utf8 prism
10:26:02 <_sebastian_> I just don't want to wait for a type error to choos the correct function
10:26:50 <haasn> up to you I guess, I'd rather have the safety/sanity provided by using less overloaded functions
10:27:33 <haasn> oh, we have utf8 in Data.Text.Strict.Lens etc.
10:27:58 <haasn> edwardk: might be worth adding that to the IsText class?
10:29:16 <haasn> oh, the ByteString types change?
10:29:23 <pranz> :t interact
10:29:24 <lambdabot> (String -> String) -> IO ()
10:29:41 <_sebastian_> haasn: I would like to write concrete type independed functions
10:29:51 <_sebastian_> for example with monoids
10:29:55 <haasn> _sebastian_: under utf8 urlEncode -- ;)
10:30:40 <_sebastian_> iirc I'm already importing lens
10:32:38 <haasn> hmm, under doesn't work here does it
10:35:19 <_sebastian_> haasn: utf8 == System.IO.utf8 ?
10:35:58 <haasn> edwardk: I need some help with my lens-fu, how would I do something like ‚Äúfrom‚Äù for Prisms? I want to use the reviewed prism for the forward direction, then map my stuff over that, then ‚Äòpreview‚Äô the getter back and get a Maybe overall (or maybe without the Maybe depending on whether the laws allow it)
10:36:07 <edwardk> re
10:36:25 <edwardk> re gives you a getter in the opposite direction
10:36:28 <edwardk> but it doesn't turn around twice
10:36:57 <haasn> re won't let me modify
10:37:10 <edwardk> that's true
10:37:12 <haasn> hmm, I guess I'll just have to use two individual lens ‚Äúexpressions‚Äù for that
10:37:32 <haasn> (f $ review p val) ^? p
10:38:09 <riceandbeans> am I alone in looking at haskell on wikipedia and feeling more confused than before I looked at wikipedia?
10:38:19 <bennofs> haasn: doesnpreview $ re p.to f.p
10:38:20 <riceandbeans> I've never touched a functional language
10:38:28 <bennofs> haasn: doesn't 'preview $ re p.to f.p' work?
10:39:12 <haasn> bennofs: oh, right
10:42:49 <augur> anyone familiar with implicit args happen to know what this will do:
10:43:29 <augur> (\x -> (x,x)) foo foo   where  foo :: (?x :: A) -> A ; foo = ?x
10:43:54 <augur> er, dont double the foo :x
10:44:23 <augur> i presume actually that ?x will resolve to be the unique A in the context that it can find
10:44:47 <augur> so there shouldnt be any question about what this is -- (a,a) where a = that unique A in the context
10:46:17 <haasn> I don't think implicit arg resolution has anything to their types and/or their contexts, unless I'm mistaken
10:46:32 <haasn> :t (?x :: Int, ?x :: Char)
10:46:33 <lambdabot>     Couldn't match type `Int' with `Char'
10:46:33 <lambdabot>     When using functional dependencies to combine
10:46:33 <lambdabot>       ?x::Int,
10:47:01 <augur> haasn: ?
10:47:04 <haasn> their uniquenesses in their contexts*
10:47:34 <augur> haasn: i bet it has to, otherwise there's no one answer, surely
10:49:34 <edwardk> haasn: there isn't anything that does exactly what you want
10:49:51 <augur> well i guess actually you use implicit param binding? hm
10:50:04 <haasn> not sure if that message got through (and I can't find the logs)
10:50:29 <Feuerbach_> augur: not sure what you're asking
10:51:19 <augur> Feuerbach_: well, its hard to ask the question in haskell, to be honest :p
10:52:02 <Feuerbach_> (\x -> (x,x)) foo is the same as (foo, foo), isn't it
10:52:12 <augur> Feuerbach_: in an ideal world :)
10:52:40 <augur> Feuerbach_: imagine tho if foo could resolve ?x to two different A's
10:52:42 <haasn> I *think* the context (?x :: T) is more like (Has "x", TypeOf "x" ~ t) in terms of instance resolution (where TypeOf is an associated type)
10:52:43 <augur> and so there's a choice
10:53:16 <augur> now: if you resolve it first, you get   (\x -> (x,x)) a0 = (a0,a0)   where a0 is the A that foo's implicit param resolved to
10:53:16 <Feuerbach_> what do you mean by "resolve ?x to two different A's"?
10:53:33 <augur> well, i dont really mean implicit params like they official are
10:53:40 <augur> i mean something more like agda's instance args
10:53:45 <Feuerbach_> oh
10:53:51 <augur> something in scope with the right type, please fill it in for me type checker
10:53:53 <Feuerbach_> then I've no idea
10:54:22 <augur> but if foo can beta reduce first:   (foo,foo)   then resolve ?x for each foo differently, you could get   (a0,a1)
10:54:31 <augur> this is an interesting and curious possibility
10:54:48 <haasn> in haskell, that would mean (\x -> (x,x)) is rank-2
10:55:15 <augur> haasn: eh. not really.
10:55:28 <augur> i mean it depends on how this implicit stuff is solved
10:55:45 <augur> so one thing you could do is insert dummy values for applications
10:55:51 <augur> like holes
10:55:58 <augur> and then resolve the holes
10:56:07 <augur> (\x -> (x,x)) (foo _)
10:56:13 <haasn> :t (\x -> (x,x)) :: ((?x::t) => t, (?x::u) => u) -- hmm
10:56:14 <lambdabot>     Illegal polymorphic or qualified type: (?x::t) => t
10:56:14 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
10:56:14 <lambdabot>     In an expression type signature: (?x :: t => t, ?x :: u => u)
10:56:14 <augur> but do you beta then resolve, or resolve then beta?
10:57:00 <augur> and do you tag holes or just know that they're holes?
10:57:07 <augur> if its not just _ but _0 say
10:57:10 <augur> then it doesnt matter the order
10:57:26 <augur> _0 here and _0 there, its one hole, in multiple places
10:57:38 <augur> but if its just _ then you "duplicate" things
10:57:56 <augur> also if you resolve later, then you could in principle capture variables, which might be good, or it might be bad
10:58:10 <augur> depending on what the answer to the hole-naming convention is
10:58:23 <haasn> (\x -> (x,x)) :: (forall t. (?x::t) => t) -> ((?x::t) => t, (?x::u) => u)
10:58:24 <haasn> this type checks!
10:58:26 <augur> if you name holes, then you have to be creful you done capture scope on a variable thats outside the scope
10:58:32 <haasn> (not sure what relevance it has, but I thought it's neat that it does)
10:58:53 <augur> like   (\x -> _0, _0)   where one occurance of _0 could choose x, but the other cant
10:59:21 <augur> obviously you could say that the context for _0 is the context that they have in common
10:59:44 <augur> so that if _0 only appears under some binder, it can see that variable, but if it occurs outside it, it cant see the var
10:59:59 <augur> this question goes away if you resolve first then beta
11:00:10 <augur> but there might be times where capture is desired
11:00:45 <augur> i dont know. its tricky stuff! interesting questions
11:00:49 <lpsmith> hmm, with haddock is there a way to have a numbered list where some of the numbers have multiple paragraphs?
11:00:52 <enthropy> you want implicit parameters to do what dyn does in TH?
11:00:59 <augur> enthropy: no idea :)
11:01:03 <augur> enthropy: i just want pronouns :)
11:01:07 <enthropy> dynamic binding
11:01:26 <augur> enthropy: im trying to think of how to properly capture pronouns in a TTic fashion
11:01:37 <enthropy>  let a = 1 in let ?x = a in let a = 2 in ?x -- should be 2?
11:01:50 <augur> oh no
11:01:53 <augur> thats not what i meant
11:02:43 <enthropy> well then I'm not seeing what you mean by "it can't see the var"
11:03:04 <augur> dont worry, its just some random stuff. ill write some agda for you if you're really curious :p
11:03:17 <augur> but not right now
11:04:55 <monochrom> lpsmith: I think the newest haddock does, but the one came with GHC 7.6.3 is not that new
11:05:23 <Feuerbach_> lpsmith: it may be fixed in the latest haddock. talk to Fuuzetsu
11:05:40 <Feuerbach_> right
11:07:23 * hackagebot HipmunkPlayground 5.2.1.1 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.1.1 (FelipeLessa)
11:08:17 <lpsmith> monochrom, Feuerbach_,  thanks
11:09:17 <Fuuzetsu> what's up?
11:10:12 <lpsmith> Fuuzetsu, with haddock is there a way to have a numbered list where some of the numbers have multiple paragraphs?
11:10:25 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/109031
11:10:52 <monochrom> hrm, it comes with GHC 7.8
11:11:12 <lpsmith> monochrom, thank you
11:11:52 <Feuerbach_> you don't have to upgrade ghc to install a fresh haddock, btw
11:12:01 <lpsmith> what is this picture syntax for haddock?  are the docs easily viewable online?
11:12:13 <Fuuzetsu> yes, see the message monochrom posted but basically you'll have to have an empty line after your list element and then write your pragraphs indented 4 spaces
11:12:17 <monochrom> I'm too lazy to compile haddock :)
11:12:23 <lpsmith> monochrom++
11:12:35 <Fuuzetsu> lpsmith: http://www.haskell.org/haddock/doc/html/ch03s08.html#idp1371424996
11:12:37 <lpsmith> So am I
11:12:52 <Feuerbach_> it's cabal-install away (assuming it's on hackage)
11:12:58 <Fuuzetsu> (scroll up for example of the paragraphs thing)
11:13:08 <lpsmith> ahh,  yeah I knew about that already,  somehow
11:13:13 <lpsmith> I think I copied ekmett
11:13:39 <Fuuzetsu> Feuerbach_: He might considering that Haddock is tightly bound to GHC‚Ä¶ Newer version of Haddock need newer version of GHC to compile
11:13:50 <Fuuzetsu> GHC API*
11:13:51 <edwardk> lpsmith: note i have some custom Setup.hs code copying the images around as well
11:13:57 <lpsmith> as he was using images in some of his packages.   But he was hosting them on imgur,  I figured out how to mildly abuse Setup.hs to copy images into the haddock directory
11:14:08 <lpsmith> edwardk, yeah I wrote it :0
11:14:13 <edwardk> lpsmith: heh
11:14:18 <breadmonster> Guys?
11:14:31 <breadmonster> I'm done reading LYAH.
11:14:41 <Fuuzetsu> IIRC edwardk had a problem with the images being too big which cause Haddock to crash or something; I haven't seen a ticket on Haddock Trac for it though so it might as well not exist.
11:15:03 <Feuerbach_> Fuuzetsu: you mean the GHC API has changed significantly since 7.6?
11:15:13 <breadmonster> How do I make the transition to actually programming in Haskell?
11:15:16 <Fuuzetsu> Feuerbach_: sure
11:15:19 <edwardk> in my case i was using data: url, so it was admittedly a 400k <<data:....>> tag
11:15:28 <ReinH> breadmonster: write some programs. :)
11:15:50 <breadmonster> ReinH: Are there any projects I can contribute to or something?
11:15:50 <iross_> There's a feature in the newest Cabal to allow you to list "extra-doc-files" in the Cabal file -- you can use that for images.
11:16:04 <breadmonster> Ideally having to do with statistics and so on?
11:16:04 <iross_> Unfortunately, Hackage doesn't have it yet...
11:17:08 <Fuuzetsu> iross_: you could make noise in #hackage and see if they could integrate that or something
11:18:10 <monochrom> conclusion: edwardk and lpsmith plagiarised from each other. send both to the inquisition
11:18:19 <iross_> I had a quick skim and could only find a couple of other packages using Haddock images, so I didn't bother to make a fuss (just hosted them somewhere else).  But maybe there's a reason no-one else is using them...
11:18:32 <dcoutts> iross_: do you know what version of the Cabal lib has it?
11:18:33 * monochrom is grading student homework and has to look out for plagiarism!
11:18:36 <alpounet> breadmonster: find cool things to implement! whether it will belong to an existing library or not is not important. ideally, you'd pick something that's not already done of course (although it may be great for you for learning purposes in some cases), and just give a shot at implementing it
11:18:50 <iross_> dcoutts: It worked on my machine with 1.18.
11:18:53 <dcoutts> iross_, Fuuzetsu: presumably we would just need to update the version of cabal that the doc builder client is using
11:19:00 <lpsmith> Feuerbach_, yes haddock is just a cabal install away,  but on the other hand I find that the older haddock is generally good enough
11:19:12 <breadmonster> Hmm, will do.
11:19:37 <breadmonster> Also, how do I apply for GSoC with Haskell?
11:19:38 <iross_> breadmonster: Or help with some infrastructure.  You'll make friends quickly that way, and people will be keen to give you advice.
11:19:40 <Fuuzetsu> edwardk: Well, if you feel like filing a bug even if it was 400K then please do.
11:20:01 <Fuuzetsu> breadmonster: Come up with a project, pitch it on mailing lists and then once Google opens their GSoC site, put it there
11:20:23 <alpounet> breadmonster: you'll see posts/emails about this on /r/haskell and haskell-cafe when the time comes :) you can start thinking about a good proposal though
11:20:24 <dcoutts> iross_: hmm, we're already using cabal-install-1.18.0.2 built against Cabal-1.18.1.3
11:20:33 <iross_> breadmonster: What about a "statistics" page for Hackage? (https://github.com/haskell/hackage-server/issues/107)
11:20:37 <breadmonster> iross_ : infrastructure as in?
11:21:01 <dcoutts> iross_: actually now that I come to think of it I think we updated in part to fix that issue, so it should work now
11:21:02 <iross_> breadmonster: Hackage, Cabal, tools.  GHC, if you're feeling punchy.
11:21:16 <iross_> dcoutts: OK.  I last tried it a couple of weeks ago.
11:21:17 <alpounet> iross_: with d3.js charts and everything? :P
11:21:25 <lpsmith> iross_, did you find mine?   http://hackage.haskell.org/package/split-channel-0.2.0.1/docs/Control-Concurrent-Chan-Split.html#v:split
11:21:27 <iross_> alpounet: If you like!
11:21:32 <dcoutts> iross_: so we may just need to delete the docs from old ones and get them rebuilt
11:21:57 <iross_> dcoutts: Right.
11:22:06 <dcoutts> iross_: you tried? which package?
11:22:27 <iross_> lpsmith: No, I didn't.  That truly is a thing of beauty.
11:22:34 <iross_> dcoutts: arb-fft
11:22:34 <alpounet> iross_: I have been using some plotting packages in js, this week. they really are dead easy to use, so a statistics page for hackage could actually be a fun task for, say, a haskell hackathon that would happen in, say June
11:22:42 <monochrom> my gradual process of transitioning to writing actual haskell program was a gradual processing of writing programs less and less toyish
11:23:01 <iross_> alpounet: Have you seen http://openbrainsrc.github.io/Radian/ ?  It's fantastic.
11:23:49 <iross_> alpounet: I already have another suggestion from dcoutts for ZuriHac, but there should be enough people to do a couple of things.  Assuming I can browbeat enough people into working on Hackage...
11:24:38 <alpounet> iross_: i know nothing about angularjs (for now), would that be a problem?
11:24:54 <iross_> alpounet: Yes.  I was kidding.  Radian is a thing I wrote.
11:25:12 <alpounet> just having to write html sounds neat though
11:25:13 <iross_> alpounet: There are lots of people who don't like JS in their Hackage pages, so we might have to work out some way of getting round that.
11:25:28 <iross_> alpounet: Probably rendering pages on the server.
11:25:35 <iross_> s/pages/images/ obvs.
11:25:44 <alpounet> yeah
11:25:48 <Maior> er, where's the actual class of Monad defined?
11:25:50 <alpounet> chart-diagrams with the svg backend could do
11:25:56 <Maior> I assumed http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html but seemingly not
11:26:21 <iross_> alpounet: That's a good idea.
11:26:41 <dcoutts> iross_: haddock pages use js already a bit of course, though are usable without JS enabled
11:27:12 <iross_> dcoutts: Yes, it's the graceful degradation that's tricky if you do all your plotting using D3.js.  You can degrade to "Sorry, no plots...".
11:27:16 <monochrom> I like javascript. Fuuzetsu, how do I add javascript to my haddock comments, hahaha
11:27:41 <lpsmith> I do upgrade my cabal and cabal-install though,  but those aren't tied to a particular GHC either.
11:29:33 <skuggi> Maior: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html
11:31:48 <Maior> skuggi: ah thanks!
11:33:13 <lpsmith> Ugh, postgresql is by a wide margin the least worst SQL I've used... but...
11:33:41 <johnw> what does that have to do with Haskell?
11:33:52 <lpsmith> There are still a lot of little gotchas and corner cases that make it difficult to write a really good basic access library like postgresql-simple.
11:34:11 <startling> I'm not sure SQL makes sense anymore.
11:34:19 <lpsmith> startling, it depends
11:34:28 <lpsmith> I'm slightly wary of NoSQL
11:34:35 <startling> well, "feeding strings of SQL to my database".
11:34:40 <lpsmith> Although it certainly has it's place
11:34:48 <startling> I'd have no problem with an API analogous to SQL that builds expressions.
11:34:53 <johnw> if you want to debate SQL, please do so elsewhere
11:35:01 <startling> lpsmith, yeah, I don't think I mean NoSQL.
11:35:19 <monochrom> . o O ( hasql )
11:37:26 * hackagebot ircbot 0.6.0 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.6.0 (JeremyShaw)
11:37:41 <magneticduck> hey guys, I don't understand buffers.
11:37:51 <magneticduck> if you say something like "getContents h >>= print"
11:37:59 <XaiKa> Hello, i'm trying to implement 2d perlin noise in haskell, but i don't quite get the algorythim itsself.
11:38:06 <magneticduck> I would expect getContents to get a string...
11:38:09 <magneticduck> and then send it to print
11:38:16 <magneticduck> but instead, it seems like print it being called multiple times
11:38:19 <magneticduck> uh
11:38:21 <magneticduck> hm
11:38:27 <lpsmith> magneticduck, not quite
11:38:33 <magneticduck> (every time hGetContents gets something new)
11:38:35 <lpsmith> that's a streaming algorithm
11:38:37 <XaiKa> Can you please share a link to explanation with zero backgorund assumed?
11:38:46 <XaiKa> Or maybe help me to understand it?
11:38:52 <magneticduck> lpsmith: okay
11:39:11 <magneticduck> I mean, normally you'd have something like (return "hey" >>= print)
11:39:19 <magneticduck> hGetContents has the same type as (return "hey")
11:39:24 <magneticduck> yet it doesn't behave like it at all
11:39:27 <magneticduck> it's.. dynamic or something
11:39:33 <magneticduck> I understand the concept of streams I suppose
11:39:41 <magneticduck> but I'm still a bit ... confused about things
11:40:20 <lpsmith> magneticduck, it uses unsafeInterleaveIO to lift a certain amount of IO into the "pure" lazy layer of haskell.
11:40:38 <magneticduck> !
11:40:47 <magneticduck> ahah, something strange IS going on with hGetContents
11:40:54 <magneticduck> lols
11:41:03 <magneticduck> hm
11:41:06 <magneticduck> sounds very strange
11:41:10 <geekosaur> it is
11:41:18 <lpsmith> (I'm assuming you are using a string or lazy bytestring of course,  and not a strict bytestring,  which would behave more as you expect.)
11:41:22 <ReinH> breadmonster: sorry, was afk for a sec. You might find something on hackage but you can also experiment with your own projects!
11:41:22 <geekosaur> it also can cause strange errors if you aren't careful
11:41:31 <magneticduck> geekosaur: yeah, sounds like it
11:41:45 <lpsmith> magneticduck, think about thunks.   Haskell doesn't compute anything when you return it,  but rather when you look at it.
11:42:08 <lpsmith> So basically,  instead of performing some pure computation to get the next character,  it's doing IO
11:42:30 <zipper> Uh for some reason this seems to have broken my use of mod4 in xmonad, could someone help me? https://gist.github.com/urbanslug/9118738
11:42:31 <lpsmith> Of course there's some buffering in there so that you aren't literally issuing a system call for every byte of a file.)
11:42:32 <magneticduck> I see
11:42:38 <ReinH> magneticduck: how much would you say that you understand monads?
11:42:51 <magneticduck> strange as it may seem, I'm not that bad =P
11:42:57 <magneticduck> I'm just kind of untrained
11:43:02 <magneticduck> I understand monads pretty well
11:43:10 <magneticduck> ReinH: but this doesn't really have to do with that, I don't think
11:43:16 <magneticduck> yes, the IO monad is magic
11:43:19 <magneticduck> that's kind of what's going on here
11:43:36 <magneticduck> (the same type of magic that Unix uses to make streams work)
11:43:55 <magneticduck> well, they don't need magic to make streams work
11:44:01 <magneticduck> they need magic to make everything else work
11:44:01 <Ralith> streams aren't remotely magic...
11:44:04 <magneticduck> yeah
11:44:11 <lpsmith> You don't really need to think about monads here,  just thunks and lazy evaluation
11:44:11 <geekosaur> just as long as you are aware that it is not monads that are magic, but specifically that one weird monad that breaks all the rules and tries to hide it behind a monad...
11:44:25 <startling> ^ this is important
11:44:26 <magneticduck> yeah I understand =P
11:44:29 <magneticduck> I'm pretty fine with pure haskell
11:44:42 <lpsmith> Of course,  a lot of people aren't happy with hGetContents for a variety of reasons,  so there's a cottage industry of alternatives to expressing streaming algorithms
11:44:57 <magneticduck> what are a few
11:44:57 <ReinH> Well, specifically with hGetContents you are talking about unsafeInterleaveIO.
11:45:05 <monochrom> getContents is strange. but still does not call print multiple times
11:45:07 <magneticduck> I do feel a bit unsafe dealing with streams like this
11:45:14 <magneticduck> monochrom: yes I understand now
11:45:20 <monochrom> ok good
11:45:23 <lpsmith> magneticduck, conduit, pipes, and io-streams seem to be the most popular these days
11:45:26 <magneticduck> print never finishes
11:45:32 <ReinH> magneticduck: if you want to talk about "streaming", let's avoid monads altogether.
11:45:37 <magneticduck> it was just the unsafeInterleaveIO that was missing from my picture
11:45:39 <lpsmith> iteratee and enumerator are older solutions
11:45:46 <magneticduck> I heard about pipes
11:45:49 <magneticduck> I'll check it out
11:45:54 <magneticduck> but I'll see the other stuff too
11:45:59 <magneticduck> any personal reccomendation?
11:46:23 <ReinH> magneticduck: let's just talk about laziness for now
11:46:28 <ReinH> magneticduck: specifically, how does this work?
11:46:30 <lpsmith> I like io-streams, I don't have to think too hard.
11:46:33 <ReinH> > take 10 . map succ $ [1..]
11:46:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
11:46:35 <lpsmith> pipes is interesting.
11:46:48 <ReinH> how can I map over an infinite list?
11:46:49 <monochrom> please enjoy my http://lpaste.net/77374
11:46:51 <magneticduck> interesting things are cool
11:47:00 <lpsmith> not used conduit much,  but iteratee and enumerator are often pretty difficult to use.
11:47:06 <ReinH> monochrom: lol
11:48:25 <startling> :t map -- ReinH
11:48:26 <lambdabot> (a -> b) -> [a] -> [b]
11:48:27 <startling> ;)
11:49:08 * Ralith is still vaguely hoping edwardk will polish up machines and make it the de-facto streaming standard
11:49:27 <edwardk> some day ;)
11:49:33 <johnw> then we can all debate pipes vs. conduit vs. machines
11:49:46 <startling> machines is FRP too!
11:49:46 <johnw> mapipeuits
11:49:51 <monochrom> "the rise of the machines"
11:49:52 <lpsmith> magneticduck, so when you return a value,  you are actually returning a thunk,  which is a pointer to a closure which computes the value you want.
11:50:04 <iross_> machines will win because it will have a better logo.  Who can draw a conduit?  Or a pipe?  But machines can have some sort of killer robot thing.
11:50:11 <startling> haha
11:50:23 <lpsmith> When that thunk is evaluated,  it replaces the closure for the actual value you want.
11:50:34 <lpsmith> so you don't keep re-evaluating the same thunk over and over again
11:50:44 <zipper> Could someone using archlinux dmenu and emacs please help me with their xmonad config?
11:51:07 <lpsmith> Now, normally,  for a variety of good reasons,  thunks are only allowed to perform pure computations.
11:51:16 <Eduard_Munteanu> zipper: you're more likely to get help asking directly about your issue. :)
11:51:18 <monochrom> a pipe is already drawn in the game Clues or Cluedo
11:51:28 <startling> monochrom: haha, good point
11:51:37 <lpsmith> But unsafeInterleaveIO and unsafePerformIO allow thunks to also perform side effects as part of their computations.
11:52:06 <lpsmith> unsafeInterleaveIO tends to be somewhat safer.
11:52:17 <lpsmith> But they have different use cases
11:52:21 <zipper> Eduard_Munteanu: This config seems to have broken my use of mod4 or something. So now just mod4+f2 is working.
11:52:27 <zipper> Eduard_Munteanu: https://gist.github.com/urbanslug/9118738
11:52:54 <magneticduck> lpsmith: I see
11:52:56 <magneticduck> cool thanks
11:53:07 <Eduard_Munteanu> zipper: myKeys is the issue
11:53:26 <zipper> Eduard_Munteanu: What is wrong with it?
11:53:27 <startling> magneticduck: normally IO is strictly ordered
11:53:45 <zipper> Eduard_Munteanu: It is the only way I am able to use dmenu in a shortcut
11:53:46 <Eduard_Munteanu> zipper: you probably want   keys = M.union (keys kdeConfig) myKeys
11:53:52 <Eduard_Munteanu> Er.
11:54:05 <magneticduck> streblo: hm?
11:54:10 <startling> magneticduck, i.e. sequence [a, b, c] >>= return . last does 'a', then 'b', then hands you the results of 'c'.
11:54:13 <Eduard_Munteanu> zipper: M.union myKeys (keys kdeConfig), since it's left-biased.
11:54:28 <zipper> Eduard_Munteanu: Could you please gist that? I am new to haskell. :(
11:54:41 <startling> magneticduck: this is because in general it doesn't make sense to execute effectful actions out-of-order
11:54:47 <magneticduck> startling: yes
11:54:54 <magneticduck> that's how I like my IO
11:55:03 <Eduard_Munteanu> zipper: the problem is you've completely removed the default key mappings and only provided that single one
11:55:17 <magneticduck> but handling streams like that can be a bit of a problem right?
11:55:19 <zipper> Eduard_Munteanu: Ah I suspected that.
11:55:32 <startling> magneticduck: but if you unsafeInterleaveIO, it won't do 'a' and 'b'.
11:55:56 <Eduard_Munteanu> zipper: I'm not sure how to edit that, but the change is easy, just write what I said in main's definition
11:56:35 <startling> magneticduck: another way to put it: unsafeInterleaveIO (print 1 >> print 2) prints nothing.
11:56:50 <magneticduck> huh...
11:56:56 <zipper> Eduard_Munteanu: On it
11:57:19 <zipper> Eduard_Munteanu: Look again and tell me what you think.
11:57:23 <lpsmith> magneticduck, the streaming IO solution depends on which community you are in;  they are the most popular in web-dev,  yesod uses conduit (and thus most of the community does as well),  snap currently uses enumerator but will be moving to io-streams (and there are some pipe users there as well, too).
11:57:25 <zipper> Eduard_Munteanu: Please :)
11:57:30 <lpsmith> pipes isn't necessarily about IO though.
11:57:33 <monochrom> hmm, I think I now how to trigger that to print
11:57:39 <Eduard_Munteanu> zipper: you forgot the  keys =
11:57:53 <startling> magneticduck: unsafeInterleaveIO (print 1 >> getLine) prints the \" from the beginning of the string from getLine, goes back and prints 1, and then waits for input. :)
11:58:10 <Maior> so I'm writing my first typeclass and suspect I'm Doing It Wrong: https://github.com/doismellburning/lux/commit/e146ad6e1b551df3418aa9abfeb656419cb9c98b
11:58:34 <zipper> Eduard_Munteanu: keys = M.union myKeys (keys kdeConfig)
11:58:42 <Eduard_Munteanu> zipper: yes
11:58:48 <Maior> I suspect actually my use of typeclasses is terrible
11:59:27 <startling> magneticduck: meanwhile unsafeInterleaveIO (print 1) >> unsafeInterleaveIO getLine never prints 1.
11:59:44 <startling> (In retrospect I think my initial description is slightly off)
12:00:41 <monochrom> do { () <- unsafeInterleaveIO (print 1 >> print 2); print 3 }  results in 1, 2, 3
12:01:03 <erisco> Maior, well the first error (line 18) is because ghc cannot infer which class instance it should use
12:01:05 <Eduard_Munteanu> zipper: er, I think we forgot myKeys takes that config parameter, do you know how to fill it up?
12:01:24 <startling> magneticduck: but anyway, unsafeInterleaveIO lets you do nice things like lazy IO at the cost of potentially-deeply-strange ordering of effects
12:01:47 <startling> monochrom: that's a good point.
12:01:59 <zipper> Eduard_Munteanu: I got an error while loading the config. No I don't know how to fix it
12:02:26 <Maior> erisco: use...for what?
12:02:38 <startling> (but do { _ <- unsafeInterleaveIO ... } doesn't.)
12:02:58 <Maior> :t mapM
12:02:59 <erisco> Maior, for commandThread... that is a member of your class yes?
12:02:59 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:03:32 <monochrom> in my "it gets better than Mordor" example, I have one more unsafeInterleaveIO than I need, and so I have to add an "evaluate one" to balance it
12:03:39 <benbangert> what do folks typically use to create packages for various OS's (.deb's, rpm, .pkg, etc.) of their haskell executable? ie, cmake?
12:03:57 <startling> magneticduck: so, here's the source of hGetContents http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO-Handle-Text.html#hGetContents
12:04:06 <Maior> erisco: commandThread? nope, defined below (commandThread :: Command c => BC.BoundedChan Response -> c -> IO ThreadId)
12:04:14 <Eduard_Munteanu> zipper: my bad... revert that line to what you had before, instead add   M.union (keys kdeConfig) .    before M.fromList in myKeys definition
12:04:28 <startling> benbangert, cabal mostly
12:04:40 <benbangert> startling: cabal can create them?
12:04:50 <startling> benbangert, no. you just install things via cabal instead.
12:04:56 <Maior> erisco: ....oh, I think I realise where I'm failing
12:05:08 <erisco> Maior, oh okay, but commandThread uses type 'c' which is constrained to the Command class. The compiler cannot figure out what 'c' is
12:05:12 <startling> benbangert, I'm not sure there's any automated tools for creating OS packages, which is a little unfortunate
12:05:13 <benbangert> startling: I mean, I want to package up the resulting binaries so that end-users don't *need* to have ghc or cabal installed
12:05:26 <zipper> Eduard_Munteanu: I forgot what the line read.
12:05:45 <Eduard_Munteanu> zipper: keys = myKeys
12:06:04 <Maior> erisco: if I have `instance Foo Bar` and `instance Foo Baz`, I can't have a [Bar, Baz] :: Foo, can I
12:06:48 <erisco> Maior, lists must be homogenously typed
12:06:49 <Eduard_Munteanu> Maior: you can, if you mean -XDataKinds
12:06:52 <startling> benbangert: yeah; I wish I had an answer.
12:07:06 <Eduard_Munteanu> Actually, nevermind. :)
12:07:23 <erisco> Maior, if your class is "Foo", "Foo" is not a type. it is a class
12:07:42 <startling> Maior, you can do something like that with a Haskell extension called ExistentialQuantification.
12:07:50 <startling> Maior: often it's better not to use it, though.
12:07:52 <Maior> er, sorry, [Bar, Baz] :: Foo a => [a]
12:08:26 <startling> Maior: what do you typicall do with a Foo?
12:08:27 <Maior> essentially I'm probably going to have a lot of..."things", each of which can be turned into an IO Response
12:08:28 <BeardedCoder> Maior: The wiki has good solutions to hetero list. http://www.haskell.org/haskellwiki/Heterogenous_collections
12:08:30 <Eduard_Munteanu> Maior: that no
12:08:49 <Eduard_Munteanu> Maior: the 'a' there is polymorphic but *fixed*
12:09:05 <Maior> and I'm not sure how to do this nicely
12:09:16 <startling> Maior, what operations does your typeclass give you?
12:09:17 <monochrom> perhaps turn them all into IO Response before storing in the list
12:09:20 <erisco> Maior, if you want runtime polymorphism you can use existential typeclasses (which turn type classes into something more like interfaces in OOP languages)
12:09:27 <zipper> Eduard_Munteanu: I tried this but it won't typecheck https://gist.github.com/urbanslug/9118738
12:09:51 <Maior> erisco: that sounds like what I'm aiming for
12:09:52 <Eduard_Munteanu> zipper: you forgot the ' . '
12:10:04 <erisco> Maior, but that is a significant investment, so be sure that is the best way to solve your problem
12:10:12 <Maior> it's quite possible that I'm thinking of this a bit too...OOPily
12:10:13 <Eduard_Munteanu> zipper: M.union (keys kdeConfig) . M.fromList $
12:10:38 <startling> Maior: it's possible. :)
12:10:43 <Maior> startling: right now, just `run` (which turns an instance into an IO Response)
12:10:50 <Eduard_Munteanu> Maior: likely... even though you can make heterogenous lists (and sort of nicely as of -XDataKinds), you likely don't want that.
12:11:32 <Eduard_Munteanu> Those heterogenous lists are more like list-y tuples.
12:12:10 <Maior> the idea being that I'd end up with Lux.Inputs.Munin where I have, say, `data MuninPlugin = MuninPlugin String Int`, my `data NagiosPlugin = NagiosPlugin String` in Lux.Inputs.Nagios, etc.
12:12:11 <Eduard_Munteanu> And as such they record the type of each element in the list type.
12:12:15 <Maior> mmm
12:12:28 * hackagebot clckwrks-plugin-ircbot 0.6.8 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.8 (JeremyShaw)
12:13:03 <Maior> then I could define a `NagiosPlugin -> IO Response` in Lux.Inputs.Nagios, a `MuninPlugin -> IO Response` in L.I.M, etc.
12:13:09 <zipper> Eduard_Munteanu: I tried i with the . but it failed to pass in the emacs haskell interpreter so I removed it.
12:13:15 <Maior> rather than massive filtered functions
12:13:21 <Maior> filtered? pattern-matchy
12:13:26 <Eduard_Munteanu> zipper: pastebin what you wrote
12:13:27 <zipper> Eduard_Munteanu: I have updated with the .
12:13:36 <zipper> Eduard_Munteanu: https://gist.github.com/urbanslug/9118738
12:14:22 <erisco> Maior, it is difficult to advise without a clear picture of your problem.
12:14:33 <Eduard_Munteanu> zipper: what's the error?
12:14:47 <Maior> erisco: yeah sorry, not being hugely clear
12:15:03 <Eduard_Munteanu> zipper: nevermind, I figured it
12:15:39 <zipper> Eduard_Munteanu: What is it?
12:16:00 <Eduard_Munteanu> zipper: myKeys cf@(XConfig {XMonad.modMask = modMask}) = M.union (keys kdeConfig cf) . M.fromList $
12:16:16 <Eduard_Munteanu> zipper: notice the lhs changed too
12:16:36 <Maior> erisco: given https://github.com/doismellburning/lux/blob/feature/reorganise/src/Lux/Main.hs I didn't want to have to have runCheck grow in length every time I add a new Command
12:16:54 <monochrom> You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
12:17:07 <Eduard_Munteanu> Maior: wow, what's with that indentation?
12:17:12 <erisco> Eduard_Munteanu, tabs
12:17:29 * hackagebot clckwrks-plugin-bugs 0.7.1 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.1 (JeremyShaw)
12:17:30 <iross_> monochrom: I bet you could make some cool problems like that with lattices.
12:17:34 <Eduard_Munteanu> Ha, and non-8-space-wide tabs.
12:17:47 <Maior> Eduard_Munteanu: yeah, sorry, that probably needs some love
12:18:03 <zipper> Eduard_Munteanu: Yes it passed the emacs haskell interpreter.
12:18:13 <zipper> What is the cf@ for?
12:18:20 <startling> monochrom: haha, awesome
12:18:30 <monochrom> please @remember it! :)
12:18:37 <Eduard_Munteanu> zipper: it lets you pattern match the parameter, but retain a reference to the entire thing
12:19:01 <startling> monochrom: I would but copying from my client is a pain.
12:19:16 <monochrom> then I'll do it myself!
12:19:20 <Eduard_Munteanu> > let foo jn@(Just n) = show n ++ " " ++ show jn in foo (Just 5)
12:19:22 <lambdabot>  "5 Just 5"
12:19:29 <Eduard_Munteanu> zipper: ^
12:19:31 <monochrom> @remember monochrom You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
12:19:32 <lambdabot> Good to know.
12:19:42 <startling> @quote river
12:19:42 <lambdabot> NealStephenson says: Long names get worn down to three-letter nubbins like stones smoothed by a river.
12:19:50 <startling> close enough.
12:19:59 <Eduard_Munteanu> Heh.
12:20:02 <milfjord> ls /etc
12:20:12 <erisco> Maior, data Person = Person { name :: String, greet :: Person -> String }; erisco = Person "erisco" (\x -> "heya " ++ name x); maior = Person "Maior" (\x -> "hello " ++ name x)
12:20:32 <erisco> Maior, this is another approach that does not use any extensions
12:21:32 <zipper> Eduard_Munteanu: Man I am not at monads yet
12:21:51 <Eduard_Munteanu> zipper: what does that have to do with monads?
12:22:09 <Maior> erisco: good point, thanks
12:36:06 <c_wraith> Anyone know if Louis Casillas (sacundim on github) is still actively maintaining his packages?
12:41:44 <zipper> Eduard_Munteanu: Man I can't find any article on "@" in haskell
12:42:25 <Eduard_Munteanu> zipper: it's called an "at pattern"
12:42:37 <Eduard_Munteanu> zipper: it's not easy to google symbols, yeah
12:42:43 <monochrom> it is a reserved symbol rather than an operator name. and few tutorials discuss it
12:42:51 <zipper> Eduard_Munteanu: Yes not easy at all.
12:42:54 <iross_> Or an "as pattern": see section 3.17.1 of the report (file:///home/iross/misc-doc/computing/haskell/language/haskell2010/haskellch3.html#x8-580003.17)
12:43:08 <bitemyapp> zipper: http://symbolhound.com/?q=%40+Haskell
12:43:14 <Eduard_Munteanu> Er, iross_ is right, "as pattern" is more common.
12:43:18 <bitemyapp> it's perfectly easy to search symbols, but the answer is not to use Google.
12:43:33 <monochrom> in SML, they really use the reserved word "as"
12:43:34 <Sornaensis> google doesn't like symbols
12:43:34 <iross_> Eduard_Munteanu: But completely wrong about the the Language Report as a reference for a beginner!
12:43:40 <bitemyapp> use Symbolhound if you need to search glyphs.
12:43:49 <Eduard_Munteanu> Mm, I wouldn't say so.
12:44:28 <c_wraith> edwardk: should thing that use the free package use F and FT instead of Free and FreeT in general?
12:44:30 <monochrom> Haskell "f s@(x:_) = 0" -> SML "fun f (s as (x::_)) = 0"
12:44:30 <iross_> This is better: just search for "@" in it -- http://learnyouahaskell.com/syntax-in-functions#pattern-matching
12:44:30 <Eduard_Munteanu> I don't think beginners should stay away from formal definitions, they complement less formal sources.
12:44:48 <zipper> bitemyapp: That link is broken or something
12:45:05 <Eduard_Munteanu> iross_: though your link is a local file:// link :)
12:45:18 <bitemyapp> zipper: works for me.
12:45:33 <iross_> Oops.  Well, you want to have the Language Report at your fingertips, you know?
12:45:35 <monochrom> I actually applaud sending a local file:// link. it reminds you that you also have it on your hard disk
12:45:37 <bitemyapp> zipper: go to symbolhound.com
12:45:40 <Eduard_Munteanu> Heh.
12:45:44 <bitemyapp> zipper: search: @ Haskell
12:46:08 <zipper> bitemyapp: Nice :)
12:46:14 <Eduard_Munteanu> bitemyapp: does it use Google at all?
12:46:19 <monochrom> people spend lifetimes exploring the web and not one minute exploring their own hard disks
12:46:34 <bitemyapp> Eduard_Munteanu: iunno.
12:46:35 <edwardk> c_wraith: depends on usecase
12:46:36 <Eduard_Munteanu> IOW is there some Google API or something which exposes richer searches?
12:46:48 <bitemyapp> Eduard_Munteanu: no.
12:46:59 <startling> Google API, heh
12:47:02 <edwardk> c_wraith: f you're going to inspect it and pattern match on it over and over and reshape it? no. if you are interpreting off it directly? probably
12:47:17 <Eduard_Munteanu> I wish search engines provided at least some limited form of regular expressions.
12:47:45 <Eduard_Munteanu> Say, without backreferences.
12:48:24 <c_wraith> edwardk: ok, related, then..  Is calling improve before interpreting once ever a win?
12:48:31 <bitemyapp> Eduard_Munteanu: ElasticSearch :)
12:48:43 <bitemyapp> Eduard_Munteanu: gotta fill it with input data yourself though :)
12:48:53 <Eduard_Munteanu> Oh, still, it seems rather cool.
12:48:56 <edwardk> yes. improve is useful when you are building up a term and there are ever left associated (>>=)'s in it
12:49:43 <osa1> what's that <<loop>> error and why is this happening? how can I track this bug?
12:50:04 <c_wraith> osa1: it's generated by the non-threaded RTS when attempting to evaluate a thunk requires evaluating that thunk
12:50:09 <Saizan> osa1: you have some circular definition
12:50:35 <c_wraith> osa1: usually if you're getting it accidentally, you're shadowing a name and not realizing it, possibly via typo
12:50:39 <milfjord> it's an infinite loop
12:50:55 <osa1> hmm
12:51:04 <osa1> thanks for pointers, I'll check my code again.
12:51:10 <c_wraith> > let xs = tail xs in xs
12:51:14 <lambdabot>  mueval-core: Time limit exceeded
12:51:22 <c_wraith> mueval runs the threaded runtime?
12:51:39 <Eduard_Munteanu> @faq Can Haskell solve the halting problem? (I asked this so you don't have to. :P)
12:51:40 <lambdabot> The answer is: Yes! Haskell can do that.
12:52:01 <Eduard_Munteanu> (on a more serious note, no.)
12:52:09 <Sornaensis> :(
12:52:22 <Eduard_Munteanu> You had high hopes, right? :)
12:54:12 <enthropy> what do people use instead of http://hackage.haskell.org/package/ipprint ?
12:54:27 <enthropy> that package tends to break easily because Extra drags in everything
12:55:03 <joelteon> ugh, I hate packages like that
12:55:11 <Eduard_Munteanu> Hm, I didn't know about Extra.
12:55:13 <wuqq> if you have a lot of taking and releasing of semaphores all over your problem then probably you have designed something wrong? just feels like a bad and error prone design to have synchronization spread out all over the program. is multithreading generally simpler in haskell than java? if OO is so natural then why all java programs become so intertwined? maybe im just bad...
12:55:15 <startling> me neither.
12:55:25 <joelteon> I'd just write one myself using ansi-wl-pprint
12:55:34 <joelteon> it's fairly intuitive
12:55:41 <Eduard_Munteanu> It seems rather cool though, I have implemented a few of those things in the past myself.
12:55:49 <c_wraith> wuqq: if you're got really complex stuff going on, using STM removes all the complexity.
12:56:22 <c_wraith> Well.  It removes the synchronization complexity.
12:56:28 <c_wraith> Doesn't do anything about logical complexity
12:56:35 <osa1> interesting. what happens when same thing happens in threaded RTS?
12:56:45 <c_wraith> osa1: the thread just hangs indefinitely
12:57:08 <monochrom> OO is not natural. multithreading is simpler in haskell. you did nothing wrong. you missed nothing.
12:57:35 <c_wraith> osa1: because in the threaded runtime, it can't tell the difference between "this thread is currently evaluating the thunk I need" and "some other thread is currently evaluating the thunk I need"
12:57:36 <enthropy> joelteon: the idea is that you don't have to write your own pretty printer
12:57:40 <startling> purity makes parallelism and concurrency muh easier.
12:57:52 <enthropy> anything that has a derived Show instance looks ok with pprint
12:58:05 <c_wraith> osa1: whereas in the non-threaded runtime, of course it's "this thread" that's problematic.
12:58:07 <zipper> Eduard_Munteanu: lol after so long I see what you did there.
12:58:14 <joelteon> enthropy: oh, really?
12:58:16 <joelteon> interesting
12:58:59 <enthropy> you don't get output from ghci like http://lpaste.net/100197 ?
12:59:42 <Eduard_Munteanu> zipper: without the as-pattern I would have needed to pattern-match in the rhs (e.g. case-of) or reconstruct the value
12:59:51 <enthropy> with some indentation done it looks much better
13:00:30 <Eduard_Munteanu> zipper: btw, do you understand why your myKeys didn't work?
13:01:39 <joelteon> well yeah I get output like that
13:02:26 <zipper> Eduard_Munteanu: Without the as pattern I am thinking https://gist.github.com/urbanslug/9123092
13:02:57 <no-n> my setup doesn't have UI.HSCurses.Curse, how do I install it?
13:03:32 <Eduard_Munteanu> zipper: that won't work because XConfig { ... } discards the rest of the xconfig
13:03:57 <no-n> hmm, it looks like there are a few curses libraries for Haskell
13:04:48 <Eduard_Munteanu> zipper: it's as if you matched on a pair like (a, _) and put it back together as (a, _)... you can't. :)
13:05:43 <zipper> Eduard_Munteanu: I am thinking of how to do it without the @
13:06:14 <Eduard_Munteanu> zipper: an alternative would be   myKeys cf = ... ((XMonad.modMask cf, xK_F2) ...
13:07:19 <Eduard_Munteanu> zipper: or less convenient,   myKeys cf = case cf of XConfig { ... } -> ...
13:09:28 <zipper> Eduard_Munteanu: I honestly don't think I'll have got what that config is doind by tonight.
13:09:31 <zipper> *doing
13:10:12 <Eduard_Munteanu> zipper: you mean myKeys? It merely takes the key mappings from an existing config and adds your M+F2 binding to it.
13:11:11 <Eduard_Munteanu> zipper: similar to the way your main alters that kde config
13:11:28 <Sornaensis> what is the best ncurses lib
13:13:43 <Eduard_Munteanu> zipper: btw, there's an #xmonad channel aroud
13:13:45 <Eduard_Munteanu> *around
13:20:44 <zipper> Eduard_Munteanu: Well I guessed that I am talking more about "(XConfig {XMonad.modMask = modMask})"
13:22:07 <Eduard_Munteanu> zipper: you might want to look up record syntax
13:24:57 <Eduard_Munteanu> zipper: data RecT = RecD { fieldA :: TypeOfA, fieldB :: TypeOfB, ... }   is similar to   data RecT = RecD TypeOfA TypeOfB ...   except you get names for those constructor parameters, and a way to update them more succintly, e.g. someRecD { fieldB = ValueOfB } only changes the 2nd parameter
13:26:00 <Eduard_Munteanu> And you can pattern match them too, which is what myKeys is doing.
13:27:55 <zipper> Eduard_Munteanu: I am familiar with record syntax.
13:28:25 <bennofs> :o ghc panic that only appears with -fext-core
13:33:35 <zipper> OMFG these whatsapp and facebook stuff is still on CNN someone shoot me!
13:33:35 <zipper> s/these/this/
13:33:36 <shergill> so is there something similar to yesod devel i.e. automatic recompilation on source change, for non-yesod projects?
13:33:43 <bennofs> Is there something for emacs that makes .hcr files readable? (.hcr files are generated by ghc -fext-core)
13:36:19 <hakujin> when using fmap, do you guys usually use it prefix as fmap, infix as `fmap` or <$>? (non applicative situations)
13:36:32 <jle`> hakujin: it depends on the context
13:36:39 <hakujin> this is 100% a style question
13:36:51 <zipper> Eduard_Munteanu: I guess I need to finish LYAH first.
13:38:51 <haasn> I will almost always use <$> over `fmap`
13:38:58 <haasn> The latter is mainly useful when the line is already too symbol-heavy
13:39:06 <jle`> i use fmap when i am conceptually lifting a function
13:39:19 <hakujin> haasn: will you explicitly import Data.Functor or Data.Applicative just to get it?
13:39:31 <jle`> when i am more interested in fmap :: (a -> b) -> (f a -> f b)
13:39:34 <hakujin> err Control.Applicative*
13:39:56 <bennofs> I use fmap when it allow to use $: fmap f $ some long expression here $ another long expression instead of f <$> (....)
13:41:51 <haasn> hakujin: yeah
13:41:51 <haasn> C.A always
13:42:22 <haasn> bennofs: fmap f . some long expression here $ another -- is what I would use
13:42:54 <bennofs> haasn: well, ok, but the point is that you do not use (<$>) :)
13:43:08 <haasn> agreed
13:43:24 <haasn> f .: some long expression $ foo   ;)
13:46:01 <jle`> is there a column-wise fold?  fold/collapse along all the columns of [[x]] (or the rows? i never got the convention)
13:46:37 <jle`> ie summing would be [[1,2,3],[4,5,6],[7,8,9]] -> [12,15,18]
13:46:43 <Clint> map sum
13:46:45 <bennofs> jle`: first transpose and the fold?
13:46:52 <Clint> oh, misread
13:46:59 <bennofs> map sum . transpose
13:47:09 <jle`> oh that's neat.
13:47:18 <jle`> > map sum . transpose $ [[1,2,3],[4,5,6],[7,8,9]]
13:47:19 <lambdabot>  [12,15,18]
13:47:44 <Fuuzetsu> monochrom: no such functionality and I sure as hell ain't putting one in ;P
13:47:45 <ssaa> would it work to replace the whole java environment in android with haskell or is haskell not well suited for mobile programming?
13:47:46 <jle`> is that...performant?
13:47:52 <Fuuzetsu> I think we only use JavaScript for the synopsis box
13:48:09 <jle`> i guess i mean
13:48:12 <jle`> is it subject to fusion?
13:48:19 <statusfailed> jle`: I don't know, but I would guess no
13:48:24 <statusfailed> don't take that as an answer though I have no idea
13:48:42 <jle`> would it be faster than writing a foldAcross
13:48:52 <jle`> a fold with a list accumulator and using zipWith
13:49:01 <jle`> i guess i could profile
13:49:03 <bennofs> jle`: benchmark it :)
13:49:11 <statusfailed> jle`: here I have a solution I think
13:49:18 <hakujin> ssa I think the issue is "haskell doesn't have good JNA bindings to all the android frameworks" rather than "haskell is not well suited to mobile programming"
13:49:22 <jle`> *benchmark
13:49:32 <statusfailed> jle`: foldl1 (zipWith mappend) . map (fmap Sum)
13:49:37 <hakujin> ssaa*
13:49:48 <statusfailed> jle`: you need Data.Monoid
13:49:55 <hakujin> s/JNA/JNI
13:50:05 <bennofs> statusfailed: that doesn't look more performant to me :)
13:50:07 <jle`> if i were to do mobile development with haskell on android i would do it using html5 and javascript probably
13:50:14 <statusfailed> > foldl1 (zipWith mappend) . map (fmap Sum) $ [[1,2,3], [4,5,6], [7,8,9]]
13:50:16 <lambdabot>  [Sum {getSum = 12},Sum {getSum = 15},Sum {getSum = 18}]
13:50:24 <merijn> hakujin: More relevantly, most mobiles platforms are ARM and GHC's ARM support is work-in-progress
13:50:25 <statusfailed> jle`: howzat? :)
13:50:36 <statusfailed> > fmap getSum . foldl1 (zipWith mappend) . map (fmap Sum) $ [[1,2,3], [4,5,6], [7,8,9]]
13:50:37 <hakujin> merijn: I thought it was full steam ahead for 7.8?
13:50:37 <jle`> > foldl' (zipWith (+)) (repeat 0) [[1,2,3],[4,5,6],[7,8,9]]
13:50:37 <lambdabot>  [12,15,18]
13:50:38 <lambdabot>  [12,15,18]
13:50:56 <statusfailed> but I like monoids
13:51:28 <statusfailed> I guess that works fine too :)
13:53:46 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub | Need an op? Try: @where ops'
13:53:46 --- topic: set by johnw!~johnw@c-69-245-200-160.hsd1.il.comcast.net on [Mon Feb 17 18:32:10 2014]
13:53:46 --- names: list (clog s4msung_ ozgura_ lcfrs_ AntiSpamMeta erisco_ ThatOtherPerson LexicalScope` cwu dev__ NNOTM darthdeu Kron__ Quashie_ zalzane|alt kadoban martinga_ travisstaton iArthur jonke jayne michaelneale nominolo_ nominolo nominolo__ StoneToad aqa no-n Vorpal jliikka nycs CosmicRay ehamberg yeshuah scottj trideon bonobo123 zabirauf gniourf kgadek Sauvin Enigmagic tero-_ d3lxa yumike__ AncientP1 innertracks mescalinum mtlatif_ blit32 mgsloan mendez_ percival)
13:53:46 --- names: list (brixen lcfrs kloeri yyyyy puzza007_ ssaa 77CABJXK7 yesthisisuser pp^_ haasn ggherdov troydm hakujin kilian08151 derekv ryanbooker samrat__ wagle xnyhps cods cryzed mengxi_ kennycaosn rhodesd-alt Fuco_ iswilson alang Laney kian__ egads robinbb Deewiant eyck Thulsadu1 dj_ryan SegFaultAX newsham_ cschneid_ Licenser boggle_ dh Guest41766 cdk_ tril_ rk[lies] pjdelport mtjandra__ njcomsec ryanakca_ gnuvince Drezil_ cyphase_ udevd_ canta1 Jeanne-Kamikaze pqmodn_)
13:53:46 --- names: list (joogi xplat_ adelbertc_ edunham ccasin_ mietek_ ChongLi_ Xorlev__ Elision trillioneyes posco___ aford noddy2000 Nik05_ acomar_ Natch_b lenstr MrGwen1 blast_hardcheese shachaf r444 xrq```` AleXoundOS_ ts33kr flojistik Guest95727 stepkut` dsirenko wires Kobata_ klaut_ platz tzbob1 mmb fizbin1 rraval_ jamwt1 annulus QQQ topi` crembo lattenwald smerz_ smerz meoblast001 Sgoettschkes JesuZ prattmic Nizumzen bigos thorstadt MasseR Ulrar Paprikachu Reiser raid)
13:53:46 --- names: list (stephe_ hdevalence akraut bobry dp_wiz ircbrowse BlankVerse_ thirsteh_ ocharles averell edk djahandarie LordDeath tekacs cross ZsoL kcliu pnielsen Iceland_jack Scorchin uu1101 gfarfl 18WAFUHWK Blkt superjudge Shou mimi_vx bluesm LeaChim Guest43550 dcoutts erkin ZioCrocifisso Thooms halu BlastHardcheese conehead Kabaka Reite plucas OlegYch0 brainproxy jophish lahwran Bigcheese apaku zymurgy Watcher7 mtjandra_ ivan` malaclyps drbean phyrex1an necrobious)
13:53:46 --- names: list (tensorpudding zarul dan64 Nshag k00mi henk davean kaol acfoltzer Lemmih_ Kneiva Ptival Martty__ brandonw aegray_ zeiris dhrosa brisbin geal Ezku bstrie Excedrin mjrosenb aoh minsa4 oubiwann-home Spaceghost cowtown jmct jroesch zoglesby PatrickRobotham lpaste CADD_ avdi bgyss dyreshark neurocyte stephenmac7 davorb utkarsh ConstantineXVI petantik leifw carter Vbitz gereedy bounb TakSuyu ikkebr DarkLinkXXXX__ jzelinskie lacrosse seanparsons Raynos qrada)
13:53:46 --- names: list (hodapp orzo stvc JPohlmann seanz SaBer zpconn_ cbarrett anders^^ saml e_svedang aristid mindCrime_ jrib noam_ alderz_ scott wilfredh donri kylcarte neptunepink meretrix Kruppe heath mikecaruso vendethiel carum FireFly lamilami emma zhov_ Betal ido jesyspa bhek_ jfischof1 jbauman wayne__ thoughtp1lice tinyghos1 yggr ceedubs cfoch c_14 etabot alevy J-KUKEN pantsman S11001001 augur_ japesinator zxq9 u__ structuralist pcflmb NemesisD_ pvt_petey M-ou-se)
13:53:46 --- names: list (rekahsoft chuzz gabor madjestic alpounet darthdeus nema nichtdiebohne kalloc bjackman erisco yng trism ologNation Ymesio mikeyhc Internet13 sxn fronx qwitwa mreh apostate jmbto hattmammerly afarmer_ amyers chidy Lethalman merijn codesoup HugoDaniel startling Rarrikins pdpi ceii ozgura Eduard_Munteanu fiatjaf jizanthapus eL_Bart0 bytbox Excureo ktosiek tjohnson user` sepp2k TravisD jefimenko mornfall Ralith oleo powellc snhmib damien____ q66 pamojarpan ijp)
13:53:46 --- names: list (rtmt subbyyy tristero _sebastian_ lpsmith jle` edwardk Atran chirpsalot patchwork davidfetter_disq hexagoxel ystael cpluss simukis_ fijimunkii jxv JobV purefn lllllllllllll Sculptor enthropy amathew _5kg Maxdamantus PaulVisschers tpsinnem albel727 jeff_s1 jml bbloom tanguy` seschwar nbouscal_ Kron_ jetho nooodl nilg armyriad ilmig ioanel frihd_ streblo sellout- raichoo dumbhat murgaan roconnor importantshock armlesshobo bjz_ hiptobecubic c_wraith netogallo)
13:53:46 --- names: list (mgodshall derdon alexherbo2 coltfred nus joaopizani Th0mas drAgda pmade tlbakh DarwinIsGod marr srhb_ randomclown BeardedCoder hpd bjorkintosh uiop zasimov vili_ noteventime Feuerbach_ dilinger_ guymann paper SHODAN passiveobserver frontend1oader waxjar_ iteratee Jefferson_ krakrjak_ mrpantou1le bxc_ lusory_ prototro1t warpy Flint earthy integral_ nurupo boegel_ Philonous_ ompaul levi` bennofs vozz_ io2 elgot_ GHCI heaumer_ thetallguy1 WzC dgpratt_ `Jake`)
13:53:46 --- names: list (sirdancealot zipper yano Rylee monochrom ayako_ BartAdv_ wollw magicman bearclaw mbrock ocfx ec otto_s_ mrowez goldkatze_ AleXoundOS demolith1 Yawgmoth tyler_robertson [[zz]] cdidd pranz skuggi keyvan shesek Valodim kmicu thorkilnaur_ Plasmastar sleuth_ __main__ edran_ ninegrid_ phienone_ inarru_ Arnar__ ethercro1 |tch_ bunzen_ confound Igloo predator217 natte _arch colDrMcBeardman luite_ jackhill dennda paz hpc_ mnbernst1in Gracenotes_ cjay_ vasilvv)
13:53:46 --- names: list (theorbtwo DarkTigII jaspervd1 isaacd_ byorgey_ Iloiny stass joshbohde [swift] nicoo watermind Mortomes_ RayNbow` pseudolio shintah mavam mr- MK_FG suOya Achylles estewei LexicalScope nsno PJBoy doomlord_ MindlessDrone talzeus DanielDiaz cow-orker effy Guest7681 yorick Earnestly Icewing silver Irrenhaus3 whaletechno ccc Sorella ousado chatsiri_ kludge` burbul xintron hrehf_ thasc mm_freak_ sykora boothead juhp SoupE MrWoohoo KorriX mirsal AlexRussia)
13:53:46 --- names: list (onthesta1rs caumeslasal1 iXeno bsmt stepcut chad nkoep fredyr MercurialAlchemi agjacome bobobo1618 nisstyre jcullen cmears m3ga macron bartavelle npcomp vsayer jcristovao GaveUp Athas bbee mist11`off AshyIsMe defanor RichyB seliopou guampa L8D kfish milfjord BMeph shanse kalz hamishmack tv saep studmuf kerrick xinming cjsarette jmob centrinia sclv mshoruzu mceier TheFuzzball fridim_ mami pieter__ cognominal Urchin onthestairs katis dmead Lindrian notdan)
13:53:46 --- names: list (profmakx waterlaz aleksejs_ ashooby inan0 xymox Cerise shapr finster fxr araujo ckx WraithM lambdabot lemao ugglan Baughn zso nilg` Squid_Tamer ps-auxw jakutis mortberg pcapriotti sw1nn slobo shepheb hackagebot maoe liyang ginmaniac kloplop321 gienah amosr apples dolio td123 Zalami shinsuke joachifm lostman OceanSpray et|kkl winocm popx_ GGMethos yeltzooo Fuuzetsu maximumsteve ljhms hc Tarential unsymbol NickHu Boney andrewsw mars-92 benj_ verement aural_)
13:53:46 --- names: list (MarcWeber shergill leper` jedai earldouglas hiredman tlevine spacekitteh jlamothe Khisanth ixti bholst mmaruseacph2 honza Nyyx yriw vpm zorzar deevus tsou srcerer \q ofan lurker6 benmachine DexterLB ixian drdo sohum funfunctor pfurla dreixel knigitz ft divyansr__ muricula mada ttuegel hive-mind mcglk PHO_ ivanm caligula philipp` bitemyapp sShintah epta Starfire dv- kshannon stiell isenmann ParahSailin jix evax jrmithdobbs qwandor gridaphobe simpson)
13:53:46 --- names: list (peterhil Vq alexsdutton gemelen prinsen pyykkis Tehnix Matrixiumn cfallin greymalkin linduxed obiwahn nullcone xahry nemesit|- Corey saarin Saizan maurer_ ciaranm sunnavy_ copton_ fiddlerwoaroof tromp__ mlen Revenrof Soft bergey Ikarus tg Dodek killy9999 tomboy64 fikusz_ hvr tessier tdammers ``rawr zachmassia b2coutts ezyang akurilin Olive` marsam robj_ plhk tavelram arrdem maaku TheBrayn ivan\ ejls gibsonfs gspr wchun jcurbo papna zalzane tomprince)
13:53:46 --- names: list (hellome asQuirreL sm DasIch deni Dashkal omefire1 FreeFull helmut zoktar Twey majoh qz erikl_ supki jlouis hongminhee ahf wting zerokarmaleft callumacrae Liskni_si dqd fryguybob niko mrmonday voyd julmac kragniz Syneh uncleBlazer eyenx`off _d3f mikeplus64 tov rasmusto mandu shutdown_-h_now zomg bd_ Martingale jaimef stbuehler skypers nwf mixi ezrios adlan DT`` stelleg Hafydd bernalex finnrobi dflemstr jlewis BrianHV ibab _janne saurik rs0 gislik marienz)
13:53:46 --- names: list (Biohazard copumpkin tristan__ absence relrod eagleflo uniquenick pdxleif valdyn shiona __class__ karls johnw luigy KitB si14 AlainODea aloiscochard jodaro Xebia rawtass drmegahertz tiqs Draggor rieper sunhay mgaare Adeon eevar Nimatek ninzine FliPPeh dixie_ liori pharaun tadeo2 martin froztbyte ValicekB peder raek johntromp benbangert Jaak xaimus mrshoe Madarc ReinH vmesonbus Spockz nik_89 Tesseraction jj2baile chrra solirc Clint Razz lab-notes ion)
13:53:46 --- names: list (chipdude bduc mephx spion kakos go|dfish Jonno_FTW ahihi mike2 Hyphen-ated Maior stevely adimit DigitalKiwi Eridius vhz mangaba_leitosa kittensoup jfhall jang Chousuke kaw_ lulf XMunkki statusfailed epsylon Sibi__ Ornedan_ fabjan pfoetchen Ceryn solarus smarter NobbZ geekosaur Rockj tomejaguar tomaw tippenein satshaba1 cmsd2 mero `0660 Fubar^ yam fnordbert qpls boyscared adnap dario pyrtsa TK009 cwvh ghorn iron_houzi zeroXten phryk Hardolaf helgikrs crs_)
13:53:46 --- names: list (flori [mth]_away keko_ Eagle_Erwin ernst wto ziman b_jonas Brando753 peddie Javafant bogner flebron Raynes taruti OrangeDuck mononofu jrslepak jchee bcoppens melter banjiewen deavid jcp FUZxxl amontez sipa barrucadu dawik koala_man zaphar_ps sdx23 Derander osfameron franksh spaceships 5EXAAJO7F duairc aseidl jorendorff myme Sornaensis CindyLinz dsrx dschoepe indigo otterdam cynick identity bind2 dustinswan1 joelteon Erstarrung @ChanServ iulian necronian)
13:53:46 --- names: list (idoru s4msung Nickeeh hungryblank jonathanj Kinnison vital_ davorak_ helgar larsrh kipras`away tmssgrdn rgrinberg _flow_ alexdoom Sagi inr petanqk kbotnen dmilith bergmark Nahra Gothmog_ dju robbert pi8027 asm89 bambams moop sordina1 mantovani mrd companion_cube gseitz Belgarion0 FreakyPenguin fall_ fayden burp descender Will| shelf jmcarthur Ke jzl mlinksva aninhumer peltchu bitraten KaneTW mindleyhilner opqdonut liesen__ nkpart h_chiro heikkih SLi drbop)
13:53:46 --- names: list (Walther Nafai Adios pierreghz Tene Dtgr otulp iross_ harski conehead__ ccs4ever bgamari dagle lopex sam_d tamiko Svedrin fergusnoble xrl__ vobi bicgena tautologico upgrayeddd davidbe__ numberten twn knyppeldynan int-e obcode jrw og01 s_e_zz ibid jagtalon tobyp Rembane Cale vikraman mak` kosmikus)
13:53:54 <merijn> hakujin: I believe 7.8 moves it to official "tier 2" or "tier 3"
13:54:05 <hakujin> merijn: interesting, thanks
13:54:46 <merijn> hakujin: See https://ghc.haskell.org/trac/ghc/wiki/Platforms
13:56:18 <merijn> hakujin: But at least building basic things for ARM should be much less hacky in 7.8
14:14:19 <Peaker> Hey, I'm considering using ResourceT in my server, so that the "async" (which I use in lieu of forkIO) calls can be auto-cleaned up in case my server is killed, yet be removed from the clean-up list if they die naturally
14:14:53 <Peaker> but "async :: IO a -> IO (Async a)", can't really nest ResourceT blocks inside the async action
14:15:56 <Peaker> IO monad transformers don't seem to work that well in the presence of negative IO stuff :(
14:16:09 <Peaker> if ResourceT was an IO facility and not a transformer, this would probably be easy
14:16:35 <Peaker> or maybe this nesting is wrong in the first place, hmm..
14:23:06 * hackagebot clckwrks-plugin-bugs 0.7.1 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.1 (JeremyShaw)
14:23:06 * hackagebot wai-routing 0.2 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.2 (ToralfWittner)
14:26:30 <jle`> there's no reason to drop nested lists for an array library of all I'm doing is mapping, zipping, and folding right? and never any random access or indexing?
14:27:00 <monochrom> I believe yes
14:27:01 <Peaker> arrays should be much better at iteration than lists
14:27:05 <startling> jle`: haven't we had this conversation already? :)
14:27:08 <Peaker> If they really exist
14:27:15 <Peaker> (as opposed to fused away into nothing by ghc)
14:27:38 <Peaker> they are cache-local and require less pointer chasing
14:28:23 <yesthisisuser> I am reading about streams, and I see how they are similar to how the standard unfoldr function operates. However, unfoldr uses a simple function s -> Maybe (a, s), but streams also have a field Skip.. could someone explain the intuition behind that?
14:29:08 <yesthisisuser> a constructor Skip i should say
14:29:22 <monochrom> yesthisisuser: Skip is there to help with things like "filter"
14:29:49 <monochrom> some input items do not correspond to output items
14:29:54 <yesthisisuser> monochrom: aah. ok. i guess i should read on and it will show up
14:30:13 <levi> I'm pretty sure they do explain what it's for in the papers discussing them.
14:31:03 <jle`> startling: yes, but I'm impatient and on the bus haha
14:31:50 <shachaf> It's like (s -> Maybe (Maybe a, s))
14:32:21 <shachaf> You can yield a new s without producing a value.
14:33:13 <bsqrd> hello
14:34:04 <bsqrd> i am a bit stumped (maybe) on something. i'm attempting to implement a folding function for Data.Tree.
14:34:13 <bsqrd> my first attempt was:
14:34:23 <c_wraith> bsqrd: please don't paste code here
14:34:30 <bsqrd> ok
14:34:34 <monochrom> lpaste.net is a good paste bin
14:34:35 <c_wraith> @where lpaste
14:34:36 <lambdabot> http://lpaste.net/new/haskell
14:35:00 <bsqrd> c_wraith: thanks for pointing this out
14:35:07 <bsqrd> uh, what just happened?
14:35:09 <monochrom> netsplit is so annoying. maybe I should go shopping
14:35:38 <c_wraith> bsqrd: what would be a small net split in most channels looks very large here..  Pay no mind to it.
14:37:36 <bsqrd> c_wraith: fair enough. i don't know if i ever noticed a net split before
14:38:09 <c_wraith> bsqrd: anyway, feel free to put your code on lpaste and ask us about it.  It's just bad form to paste code in here. :)
14:39:03 <bsqrd> c_wraith: i'm putting it in there now. i've pasted code in here before without realizing it was bad nettiquette. won't happen again
14:39:29 <bsqrd> http://lpaste.net/100200
14:40:20 <levi> One-liners or so are okay here, on occasion, especially when using Lambdabot to demonstrate something. But not big chunks of code.
14:42:26 <bsqrd> i'm a bit confused on how to combine the results between levels. for example, if i have a binary tree of integers, and want a sum of all of them, the folding function is something like: f = x + f l + f r
14:42:53 <bsqrd> so, f is combining the values, in this example, via addition
14:43:54 <bsqrd> for a Data.Tree, where the children are stored in a list, it's a bit more tricky.
14:44:33 <bsqrd> if i wanted to sum them, that would work just fine. i could add the root node, and fold on the children list with +, recursing on each child along the way
14:44:41 <startling> bsqrd, if only we had a way to apply a function to an entire tree and get a result. :)
14:44:49 <dmj> bsqrd: suppose we have a binary tree
14:44:51 <dmj> data Tree a = Empty | Node a (Tree a) (Tree a)
14:44:57 <dmj> and an instance
14:44:59 <dmj> g = Node 3 ((Node 3) Empty Empty) Empty
14:45:24 <milfjord> :t Node
14:45:24 <lambdabot> a -> Forest a -> Tree a
14:46:19 <dmj> you can sum them via pattern matching and recursion
14:46:19 <dmj> gsum (Node val left right) = val + gsum left + gsum right
14:46:19 <dmj> gsum Empty = 0
14:46:19 <dmj>  
14:46:20 <milfjord> fold :: (a -> [b] -> b) -> Tree a -> b
14:46:20 <dmj> there are nicer ways to do that though...
14:46:28 <bsqrd> yes, that part i get
14:47:11 <milfjord> fold f (Node x ts) = f x (map (fold f) ts)
14:53:23 <bsqrd> milfjord: i was making that much harder than it needed to be. for some reason i had a problem with the fact that the second argument of the function was a list.
14:53:48 <bsqrd> milfjord: but that's ok, i just needed to account for that in the fold function
14:54:00 <bsqrd> <-- enlightened
14:54:07 <bsqrd> thank you
14:55:24 <Clint> is there a Maybe-like type where Nothing /= Nothing?
14:55:51 <Peaker> wrote myself a little ResourceT-like thingie that's just an ordinary IO bracket, and currently specific to async-cleanups...
14:56:20 <acowley> Has anyone used the graphs package for anything?
14:56:42 <Peaker> bracketed foo = AsyncContext.new $ \ctx -> do { ... AsyncContext.spawn ctx $ do ... ; AsyncContext.spawn ctx $ do ... ; foo }
14:57:19 <Peaker> if bracketed is killed, it will properly kill all its children.. "withAsync" is close to this behavior, but if the async dies, the "withAsync" protector is still in memory :(
14:57:46 <Peaker> so that would leak if there's a long running server spawning child asyncs and wants to kill em all when it itself dies
14:57:48 <acowley> Also, does anyone know of an OpenGL font rendering library that makes use of modern OpenGL interfaces?
14:58:08 <Peaker> acowley, does FTGL use modern interfaces?
14:58:22 <acowley> Peaker: Probably not
14:59:54 <acowley> Oh, I was probably wrong there!
15:00:27 <acowley> Well, it hasn't been updated in three years
15:00:57 <acowley> the underlying ftgl library that is
15:02:57 <acowley> Great, so now I get to shave the graph yak and the text rendering yak :(
15:04:59 <Peaker> acowley, why do you care about modern interface use?
15:05:06 <Peaker> doesn't FTGL work well enough?
15:08:04 * hackagebot wai-routing 0.3 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.3 (ToralfWittner)
15:10:56 <skypers> night folks
15:13:43 <Twey> Clint: I hope not.  Asymmetric (==) is evil.
15:14:26 <Twey> Clint: I guess you could use Either Float a and make the Float be NaN (which is already evil, so you can feel slightly less bad :√æ)
15:15:01 <Clint> Twey: i'm doing ((Just (==) <*> foo <*> bah) == Just True) but it seems a bit silly
15:15:52 <Twey> Clint: pure f <*> x = f <$> x
15:16:11 <Clint> yeah
15:16:12 <Twey> ((==) <$> foo <*> bah) == Just True
15:16:19 <Twey> Is a bit less silly
15:16:30 <Twey> And probably what I'd go for
15:17:08 <vozz_> How do I install a cabal package I that isn't in the repo? I.e. something I found on github?
15:17:33 <geekosaur> "cabal install" in the directory containing the *.cabal file
15:17:39 <geekosaur> (note no package name)
15:18:02 <vozz_> Ah, thanks
15:18:18 <pranz> if you're in a directory with a cabal file, cabal works similiar to make
15:23:05 <Philippa> has anyone done the inevitable Invader Zim/monad t-shirt yet?
15:23:29 <Philippa> (a monad is like your house being taken over by a taco-crazed robot)
15:25:13 <Eduard_Munteanu> Can I query Hackage about which packages depend on a given package?
15:25:14 <acowley> Peaker: I'll end up using FTGL
15:26:21 <acowley> Eduard_Munteanu: http://packdeps.haskellers.com/reverse
15:26:27 <Eduard_Munteanu> acowley: thanks
15:45:17 <Brian666>  Free Windows 7 Machine ! Connect via  Team Viewer User ID:  826749216 Password : 9870
15:46:11 <Eduard_Munteanu> @where ops
15:46:11 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:46:17 --- mode: ChanServ set +o monochrom
15:46:22 --- mode: monochrom set +b *!*@75.115.64.76
15:46:22 --- kick: Brian666 was kicked by monochrom (Brian666)
15:46:31 <hpc_> a curious kind of spam
15:47:00 <davidfetter_disq> it was a trojan
15:47:16 * Eduard_Munteanu sometimes isn't sure whether to let that stuff pass, it's not worth highlighting all ops.
15:47:58 <Eduard_Munteanu> (well, if it's a onetime thing or if it gets noticed in other channels as well)
15:48:07 <Philippa> eh, only got me checking if someone'd responded to my bad t-shirt proposal
15:48:20 <Eduard_Munteanu> Heh.
15:48:34 <Philippa> GUI clients generally flash a channel-specific notification - I get #haskell highlit blue, for example
15:48:38 <Iceland_jack> Philippa: Maybe if you throw in an Adventure Time monad
15:48:43 <Iceland_jack> (T-shirt)
15:49:11 <Philippa> not enough doom
15:49:21 <Iceland_jack> I see.
15:50:07 <FreeFull> Silence of the lambdas
15:51:05 <khyperia> I heard people talking about a T-shirt that I really want that says "What part of [the Hindley-Milner type algorithm] don't you understand?"
15:52:44 <Saizan> hah
15:53:04 <Saizan> i was still young when that was around!
15:54:04 <jle`> is there some kind of combinator that lets me streamline f x >> f y ?
15:54:16 <Iceland_jack> @ty on
15:54:16 <Iceland_jack> ?
15:54:17 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
15:54:30 <Eduard_Munteanu> jle`: sequence_
15:54:53 <jle`> sequence_ . map f $ [x,y]
15:54:54 <jle`> ?
15:55:01 <Iceland_jack> you mean mapM_?
15:55:05 <Iceland_jack> :t mapM_ f [x,y]
15:55:06 <lambdabot> (Monad m, FromExpr (m b)) => m ()
15:55:10 <jle`> oh neat
15:55:18 <Eduard_Munteanu> jle`: ah, I thought you only cared about (>>)
15:55:29 <jle`> oh yeah i wanted to use `f` on both
15:56:04 <Iceland_jack> If you just want the two, you can do
15:56:05 <Iceland_jack> :t (>>) `on` (undefined :: b -> IO a)
15:56:06 <lambdabot> a -> a -> IO a1
15:56:07 <jle`> hm mapM_ is nice but i would be hard pressed to argue for it over f x >> f y.  but i guess what was i even asking for?
15:56:41 <Iceland_jack> I mean I'd never personally use ‚Äòon (>>)‚Äô but hey :)
15:56:46 <jle`> ((>>) `on` f) x y ?
15:56:49 <Iceland_jack> yeah
15:56:53 <jle`> hahaha
15:56:58 <jle`> that's perversely beautiful
15:57:08 <Iceland_jack> jle`: That's exactly what I was going for
15:57:22 <jle`> on (>>) f x y
15:57:50 <Eduard_Munteanu> :t (>>) <$> ?f <*> ?f
15:57:51 <lambdabot> (Monad m, Applicative f, ?f::f (m a)) => f (m a)
15:58:03 <jle`> ah
15:58:04 <jle`> of course
15:58:11 <Eduard_Munteanu> Well, more useful if you want f x >> g x
15:58:24 <jle`> oh yeah
15:58:32 <jle`> mixed it up for a sec
15:58:36 <jle`> ty though
15:58:51 <FreeFull> :t join liftA2 ?f
15:58:52 <lambdabot> (?f::(b -> c) -> b -> c) => ((b -> c) -> b) -> (b -> c) -> c
15:58:53 <jle`> probably just going to do f x >> f y, cause i don't think i could make it any more expressive/readable
15:59:21 <Eduard_Munteanu> jle`: yeah, for that one in particular
15:59:24 <FreeFull> :t join (liftA2 (>>)) ?f
15:59:25 <lambdabot> (Monad m, Applicative f, ?f::f (m a)) => f (m a)
15:59:40 <Iceland_jack> /me goes in the opposite direction
15:59:40 <Iceland_jack>     do f x
15:59:40 <Iceland_jack>        f y
16:00:15 <joelteon> what's the easiest way to (debuggingly, so with unsafePerformIO or whatever) show how long it takes to evaluate some expression
16:00:19 <Eduard_Munteanu> :t (>>) <$> ?f <*> ?f $ ?x
16:00:20 <lambdabot> (Monad m, Applicative ((->) t), ?f::t -> m a, ?x::t) => m a
16:01:16 <heatsink> joelteon, in IO?
16:01:36 <Eduard_Munteanu> joelteon: 'criterion' perhaps?
16:01:45 <joelteon> well im just trying to figure out how long this parse atkes
16:01:47 <joelteon> takes
16:01:52 <Iceland_jack> joelteon: Second ‚Äòcriterion‚Äô
16:02:07 <Eduard_Munteanu> joelteon: oh, then you should profile first, I think
16:02:28 <Eduard_Munteanu> I thought you wanted to do that programatically, at runtime.
16:02:36 <joelteon> I do
16:02:41 <joelteon> want to do it programmatically at runtime
16:02:58 <Iceland_jack> and you don't want to do it in the IO monad?
16:03:28 <Iceland_jack> where would the information go? to std{out,err}, logged to a file, database, ...?
16:03:37 <joelteon> stderr
16:03:54 <joelteon> i don't care if it happens in IO or not, I just need to debug this
16:03:58 <Kaidelong> frustration: wanted an interactive environment to test if expression gets optomized. GHCi approach to optomization: "nope"
16:04:28 <heatsink> Does it take longer than 100ms?
16:04:42 <heatsink> Some time functions aren't accurate for short intervals
16:04:43 <Kaidelong> desire: see if version without optomization works better than one with, easily
16:06:07 <joelteon> heatsink: yes, it does
16:07:02 <joelteon> heatsink: this is not really for performance testing, but this program is taking a ridiculously long time
16:07:17 <heatsink> If you want to make the program faster, you should profile
16:07:25 <Kaidelong> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-obj.html this is halfway there I think
16:07:28 <joelteon> ok
16:07:29 <heatsink> Put an {-# SCC "parsing" #-} annotation on the parser expression
16:07:50 <Kaidelong> now need a way to compile one thing with one set of ghc parameters and another thing with another
16:07:53 <heatsink> Do you know how to run the profiler?
16:11:11 <enthropy> how does one get a ChangeLog to show up in hackage?
16:11:39 <c_wraith> enthropy: put a file name changelog in your package
16:11:40 <enthropy> http://hackage.haskell.org/package/HList has a ChangeLog in the source distribution
16:11:52 <enthropy> but it doesn't show up
16:12:04 <c_wraith> it appears to be showing up to me
16:12:13 <enthropy> doh
16:12:13 <c_wraith> enthropy: http://hackage.haskell.org/package/HList-0.3.2.0/changelog
16:12:13 <heatsink> ^
16:18:11 * hackagebot HList 0.3.4.0 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.3.4.0 (AdamVogt)
16:18:13 * hackagebot dns 1.2.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.2.0 (KazuYamamoto)
16:21:41 <Sgeo> :t "My sanity is slipping away"
16:21:42 <lambdabot> [Char]
16:23:11 * hackagebot concurrent-dns-cache 0.0.0 - Concurrent DNS cache  http://hackage.haskell.org/package/concurrent-dns-cache-0.0.0 (KazuYamamoto)
16:31:43 <bennofs> If a haskell program gets a signal, and another thread (not the main thread) is currently running, will that thread be interrupted and control returned to the main thread?
16:33:17 <Eduard_Munteanu> bennofs: no
16:33:38 <Eduard_Munteanu> bennofs: what do you mean "running"? As opposed to what?
16:34:49 <Eduard_Munteanu> bennofs: it also depends what you do with the signal, but normally uncaught signals result in killing everything.
16:36:19 <geekosaur> there is also the question of how the platform deals with signals (POSIX signals vs. threads probably doesn't do what you would na√Øvely expect) and how Haskell threads get multiplexed onto OS threads
16:38:02 <c_wraith> I actually haven't got the slightest clue how posix signals interact with native threads
16:38:02 <geekosaur> (if you're not using the threaded runtime then the latter doesn't matter much)
16:38:14 * hackagebot Rlang-QQ 0.2.0.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.2.0.0 (AdamVogt)
16:39:01 <geekosaur> the signal is delivered to whichever thread is currently running (or would be scheduled next without the signal)
16:39:27 <c_wraith> I guess that's as good a policy as any
16:39:29 <geekosaur> I haven't looked to see what the ghc runtime does
16:39:34 <bennofs> Ok, maybe I should say what I want to do: I want to kill a thread after a given amount of time. I cannot use a realtime os. It's really bad if I exceed the timeout, killing the thread a little bit earlier is ok (but I want to maximize the time that the thread is running). What is the closest I can get in haskell? threadDelay?
16:39:53 <geekosaur> if you're not using an RTOS, you lose
16:40:11 <geekosaur> there is no guarantee *the OS* won't deliver the signal up to a second later
16:40:21 <c_wraith> yeah, no OS GHC runs on will give you guarantees about when notifications happen
16:40:24 <Eduard_Munteanu> bennofs: sounds like the opposite of the guarantees you normally get from sleeps, what is your exact application?
16:40:42 <c_wraith> I mean, no OS GHC runs on give you guarantees you're not running under a VM that might be suspended for 30 days
16:41:15 <bennofs> Eduard_Munteanu: I'm writing an AI player for a game compitition, and I only have 2 seconds for the turn. I want to maximize the time I spent computing, without risking to loose because of a timeout
16:41:24 <geekosaur> basically, without an RT OS it is impossible for any application to give you that guarantee
16:41:44 <geekosaur> no application can be more accurate than the OS it runs on
16:42:31 <bennofs> I currently do `waitEitherCancel` (threadDelay 1800), but sometimes, the actual time spent goes up to 2.1 seconds
16:42:40 <Eduard_Munteanu> bennofs: spawn a thread doing the crunching and report intermediate results to another thread, which just sends it before the timeout. You can kill the thread later.
16:42:53 <bennofs> Eduard_Munteanu: yeah, but when do I send?
16:43:55 <Eduard_Munteanu> bennofs: whatever thing you send your result to should provide a way to cancel timely
16:44:22 <bennofs> Eduard_Munteanu: ? I cannot revert a turn once I send it I think
16:44:29 <Eduard_Munteanu> bennofs: for example, you could store the result in a predefined location, and it could sample after killing your AI.
16:44:31 <c_wraith> bennofs: usually, a difference of 0.3 seconds indicates that your worker thread didn't repond promptly
16:45:47 <bennofs> Eduard_Munteanu: I do not control the server, I can only send one move per turn to the server. So I still have to determine when to send that turn
16:45:49 <heatsink> Estimate the timeslice size used by the OS.  Send the result a few timeslices before the deadline.
16:45:53 <Eduard_Munteanu> Likely GC might be an issue at some point.
16:46:24 <heatsink> GC could be an issue if live data is many megabytes in size.
16:46:54 <bennofs> Hmm, that could actually be it. The game tree is pretty large
16:47:04 <Eduard_Munteanu> bennofs: then have another thread do the sending, concurrently with killing the computing thread
16:47:34 <bennofs> Eduard_Munteanu: I think I still don't understand. How do I determine the time after which I send the move?
16:47:53 <Eduard_Munteanu> bennofs: you can't really do that
16:48:34 <Eduard_Munteanu> The GHC RTS isn't realtime at all, not even soft realtime by a longshot.
16:49:11 <Eduard_Munteanu> You may be able to trigger garbage collection manually, say earlier during the computation.
16:49:21 <bennofs> Turning of the idle GHC seems to help
16:49:30 <bennofs> s/GHC/GC/
16:49:56 <Eduard_Munteanu> bennofs: also, can you compute while your opponent thinks / server responds?
16:49:59 <c_wraith> yeah, turning off idle GC and running a full GC manually can really make things more predictable
16:50:04 <bennofs> Eduard_Munteanu: yes, I think I can
16:50:36 <bennofs> GHC doesn't have a way to suppress GC for some time, does it?
16:50:41 <c_wraith> Nope
16:50:51 <c_wraith> If it needs to allocate and doesn't have space available, it will run GC
16:51:36 <bennofs> So ghc never does a GC if I set the heap size large enough and disable idle gc?
16:51:55 <Eduard_Munteanu> bennofs: consider talking to a C wrapper or distinct Haskell process to handle the networking stuff
16:51:59 <c_wraith> maybe if you set every generation large enough
16:52:35 --- mode: monochrom set -b *!*@75.115.64.76
16:52:41 --- mode: monochrom set -o monochrom
16:53:20 <c_wraith> well, if the GC never runs, you only need the nursery generation.  Make it big enough and the GC will never run, sure.
16:53:27 <syllogismos> http://lpaste.net/100211 can someone tell me whats wrong with my findM function, line no 128
16:54:18 <syllogismos> i feel like its traversing the entire list, instead of stopping when the function gets the first True value..
16:54:47 <cmears> syllogismos, I think it is doing that
16:54:57 <c_wraith> syllogismos: you're not actually using the monad interface
16:55:27 <c_wraith> syllogismos: in order for the structure of the calculation to change based on intermediate results, you need to use the monad interface, not just the applicative interface
16:56:02 <syllogismos> i have no idea how to do findM, i implemented in based on filterM from control.monad
16:56:24 <cmears> "fun <$> xx <*> yy" is equivalent to "do xx, then do yy, then pass the results to fun"
16:56:25 <c_wraith> syllogismos: the difference is that filterM will *always* traverse the full list.
16:56:47 <c_wraith> syllogismos: you want to traverse only as much of the list as necessary to find an element that matches
16:56:56 <cmears> so yy is always run before "fun" even gets a look at the result of xx
16:57:22 <Eduard_Munteanu> cmears: I don't think so
16:57:36 <syllogismos> so what do i do?
16:57:46 <c_wraith> syllogismos: use *monad* functions, not applicative ones.
16:59:15 <syllogismos> im gonna try for an hour okay.. im struck here for 3 days.. tell me after an hour
16:59:36 --- mode: pratchett.freenode.net set +b *!*@75.115.64.76
17:00:09 <heatsink> syllogismos: As cmears said, findM is currently evaluating f x, then evaluating findM f yy, then deciding what to return.
17:00:31 <heatsink> syllogismos: What should it do in the right-hand side of findM f (x :. xs) = ?
17:05:22 <syllogismos> if f x is true then return x and if it isnt check the rest of the list..
17:05:46 <syllogismos> sorry my imperative is leaking..
17:06:06 <heatsink> That sounds right
17:06:23 <heatsink> Can you translate that into Haskell using do notation?
17:06:27 <monochrom> that is, in fact, the exact flow you should code up in Haskell
17:07:30 <monochrom> when you're coding up IO, you are right to be imperative. not the "every variable is mutable" part, no. but "imperative control flow" is right.
17:07:54 <syllogismos> ohh.. but I can't use do notatation here.. because I have bind typeclass instead of monad that is similar to monad..
17:07:59 <no-n> which package is best for ncurses stuff?
17:08:11 <Iceland_jack> syllogismos: What do you mean ‚Äòbind typeclass‚Äô?
17:08:18 <monochrom> do-notation can be translated to bind-notation
17:08:45 <Eduard_Munteanu> With RebindableSyntax it will just pick whatever (>>=) and return are in scope.
17:08:50 <monochrom> to me, in fact, the difference vanishes, I see through petty syntax
17:09:02 <syllogismos> this is sort of introductory course.. they made me implement everything from List to Maybe applicative etc etc
17:09:33 <syllogismos> Bind is just Monad
17:10:25 <syllogismos> this is not homework.. im not in uni just putting it out there
17:10:28 <monochrom> hey! so public lpaste posts now surpass 100000 posts? we should celebrate!
17:10:59 <identity> brb writing bot to spam lpaste for more celebrations
17:11:15 <monochrom> haha
17:11:16 <Algebr> Are modules the primarily way means of encaspulations?
17:11:38 <c_wraith> Algebr: yeah, pretty much
17:11:47 <monochrom> ooohhhh the Bind class speaks of =<<
17:11:49 <c_wraith> Algebr: they're the only means of hiding definitions
17:12:06 <Algebr> thanks
17:12:26 <c_wraith> Algebr: well, other than scoping.  So they're the only means of hiding definitions that can't be scoped, like data definitions
17:12:35 <Algebr> right, yea, that's what I was going for
17:12:42 <levi> Modules hide definitions, but not type class instances, so they're not perfect encapsulation.
17:14:43 <monochrom> do { b <- f x; if b then pure (Full x) else findM f xs } = (\b -> if b then pure (Full x) else findM f xs) =<< f x
17:15:08 <monochrom> this cannot be done by Applicative, due to the conditional there.
17:19:03 <joneshf-laptop> does cabal actually run cpp if you are trying to use it in setup.hs?
17:21:47 <Fuuzetsu> @src join
17:21:47 <lambdabot> join x =  x >>= id
17:21:57 <Fuuzetsu> thought it would be
17:22:19 <Fuuzetsu> :t id >=> id
17:22:20 <lambdabot> Monad m => m (m c) -> m c
17:22:28 <Fuuzetsu> that'd be funnier
17:22:49 <monochrom> nice!
17:23:21 <Eduard_Munteanu> @unpl id >=> id
17:23:21 <lambdabot> (\ h c -> h ((\ b -> b) c) c)
17:23:46 <Eduard_Munteanu> @@ @pl @unpl id >=> id
17:23:46 <lambdabot>  join
17:24:01 <bitemyapp> :t join
17:24:02 <Eduard_Munteanu> Interesting.
17:24:02 <lambdabot> Monad m => m (m a) -> m a
17:25:07 <Algebr> What does something => mean? Like (Eq k) => k, does that mean that k is something of an instance of the Eq class?
17:25:08 <Fuuzetsu> is @@ a command or are you abusing the correction to @.
17:25:21 <Fuuzetsu> Algebr: yes
17:25:34 <Algebr> thanks
17:25:37 <Eduard_Munteanu> Fuuzetsu: it lets you compose commands
17:25:38 <geekosaur> @help @@
17:25:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:25:43 <geekosaur> oh feh
17:25:47 <syllogismos> oh I got it now.. and in a straight forward way too findM f (x :. xs) = f x >>= \t -> if t then pure (Full x) else findM f xs
17:25:49 <magicman> @help @
17:25:49 <lambdabot>  @@ [args].
17:25:49 <lambdabot>  @@ executes plugin invocations in its arguments, parentheses can be used.
17:25:49 <lambdabot>  The commands are right associative.
17:25:49 <lambdabot>  For example:    @@ @pl @undo code
17:25:49 <lambdabot>  is the same as: @@ (@pl (@undo code))
17:25:53 <geekosaur> anyway it looks for @cmds in a string
17:25:53 <Fuuzetsu> Eduard_Munteanu: No, I know it does but the command is @., isn't it?
17:26:00 <Fuuzetsu> Guess not.
17:26:01 <geekosaur> nope
17:26:10 <magicman> @help .
17:26:10 <lambdabot> . <cmd1> <cmd2> [args].
17:26:10 <lambdabot> . [or compose] is the composition of two plugins
17:26:10 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
17:26:15 <geekosaur> although you can do simple cases of @. with @@
17:26:17 <Fuuzetsu> @. @pl @unpl id >=> id
17:26:17 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
17:26:18 <Eduard_Munteanu> @compose @unpl @pl id
17:26:18 <lambdabot> Plugin `compose' failed with: Unknown command: "@unpl"
17:26:22 <Eduard_Munteanu> Er.
17:26:29 <Eduard_Munteanu> @compose unpl pl id
17:26:29 <lambdabot> (\ a -> a)
17:26:45 <monochrom> you're looking at $ vs .
17:26:57 <Fuuzetsu> Ah.
17:27:09 <Fuuzetsu> should have gone with @$
17:27:14 <monochrom> consequently, you're now talking like a beginner, "what is the difference between $ and . ?" :)
17:27:28 <Fuuzetsu> Maybe I am a beginner!
17:27:30 <Fuuzetsu> am*
17:28:38 <monochrom> "hi, I'm a lambdabot beginner. how to convert String back to IO String?" :)
17:28:42 <Fuuzetsu> Oh, there was no typo to begin with; I think I just shouldn't be posting today‚Ä¶ (I did have to correct ‚Äòtype‚Äô to ‚Äòtypo‚Äô in this sentence though)
17:29:09 <Fuuzetsu> monochrom: Simple, just use the ‚Äò>‚Äô function!
17:29:14 <monochrom> don't worry about typos, I don't see them
17:29:16 <Fuuzetsu> > putStrLn "I don't do IO"
17:29:18 <lambdabot>  <IO ()>
17:29:26 <jophish> Ok, so I have a big ol' data structure representing Haskell source. As a small example of what I want to do, when a type signature is parsed, type variables bindings are constructed by either Unkinded :: Name -> TyVar or Kinded :: Name -> Kind -> TyVar, if they have an explicit kind signature. Is there any way of asserting at the type level (probably using GADTs) that a function will only return TyVars construc
17:29:26 <jophish> ted by Kinded? This is for the kind inference pass, I want to prohibit the kindchecker for outputting Unkinded variable bindings.
17:29:28 <Fuuzetsu> oh, that's not even String
17:29:31 <Eduard_Munteanu> Algebr: generally, types have a form like 'forall <variables>. <context> => <expression>' and <context> consists of typeclass (and other constraint) applications, which limit the type variables to instances of said things.
17:30:00 * monochrom 's beginner questions are deep! \‚à©/
17:30:21 <jophish> The kindchecker is at the moment a function of type HsSyn -> HsSyn
17:30:56 <jophish> and I'd like something like: HsSyn KindedAndUnkindedVariableBindings -> HsSyn JustKindedVariableBindings
17:31:19 <_jmcarthur> halp! i have a function -> string but now i need to apply it to an IO monad
17:32:45 <_jmcarthur> i guess it is unfair, downright rude even, of me to make fun of such questions. i apologize to all readers.
17:33:01 <Eduard_Munteanu> Algebr: you asked about '(Eq k) => k' which more formally it's a 'forall k. (Eq k) => k'. You can read it as "for any k that is an instance of Eq, this type is k"
17:35:14 <Algebr> Eduard, thank you, that is very clear!
17:35:24 <Eduard_Munteanu> The forall may look gratuitous, but it's the thing that binds/introduces the type variable, formally.
17:37:05 <joneshf-laptop> here's  the real question, why is it that every cabal question i have seems to go unanswered?
17:37:11 <joneshf-laptop> is cbaal really thatcryptic?
17:37:37 <joneshf-laptop> or am i just in some dusty corner of cabal all the time?
17:39:55 <bennofs> joneshf-laptop: setup.hs is compiled by ghc, and ghc does run CPP. There aren't any useful macros defined by cabal itself, though
17:40:39 <joey_> I'm trying to install the "clocked" package on linux, and cabal gives the following error:
17:40:49 <joey_> cabal: The pkg-config package QtCore is required but it could not be found.
17:40:49 <monochrom> your questions are specialized. I cannot answer them.
17:40:53 <geekosaur> don't paste in channel please
17:40:55 <geekosaur> @paste
17:40:56 <lambdabot> Haskell pastebin: http://lpaste.net/
17:41:18 <joey_> Sorry, I assumed it was fine, it was a one-liner
17:41:27 <finlay> Hello haskellers
17:41:37 <joey_> I'm confused, because my package doesn't rely on qt at all, nor does clocked
17:41:43 <joey_> Anybody know of a resolution?
17:41:57 <geekosaur> it doesn't seem to have come through anyway?
17:42:21 <geekosaur> (most ghc errors aren't 1 line unless they're parse errors in which case the code is kinda needed to even begin to figure them out)
17:42:33 <joey_> ok, fair enough
17:43:07 <joey_> Here it is: http://lpaste.net/100212
17:43:23 <bennofs> haha
17:43:26 <geekosaur> oh, I see it now
17:43:45 <geekosaur> so why does it need the Qt C libs?
17:43:46 <geekosaur> oy
17:44:37 <geekosaur> http://hackage.haskell.org/package/clocked-0.4.1.3/clocked.cabal
17:44:56 <geekosaur> it doesn't depend on a Haskell Qt package but it depends on the Qt libraries
17:45:40 <geekosaur> so you need to install those (devel libs, not just runtime) via your system package manager
17:46:19 <geekosaur> (see at the bottom of the linked .cabal file above, starting at extra-libraries:)
17:50:17 <Nafai> joey_: Which OS are you on?  If you are on a Debian-based system, my guess is you need to install the libqtcore4 package
17:50:47 <geekosaur> libqtcore-dev
17:50:52 <geekosaur> er, libqtcore4-dev
17:51:03 <geekosaur> libqtcore4 won't have the pkgconfig foo
17:51:17 <Nafai> hrm, there isn't a -dev package
17:51:37 <geekosaur> huh. maybe they punted on splitting that one up (qt4 is pretty big and complex...)
17:51:50 <geekosaur> but I thought that was one of the Thou Shalt Nots
17:52:26 <Nafai> libqt4-dev looks like
17:57:32 <joey_> I'm on ubuntu
17:57:38 <joey_> sorry for delay
17:57:59 <joey_> Also, I'm unclear why it's a dependency, as Clocked doesn't need Qt at all...
17:58:08 <joey_> I'll try libqt4-dev
17:58:28 <monochrom> we are as lost as you on why, yes
17:58:38 <joey_> oh well, thanks muchly!
18:01:32 <monochrom> it's tarball has a README. it points to http://patch-tag.com/r/shahn/clocked/wiki/ . it says why Qt is involved
18:03:42 <monochrom> apparently Qt is being used as a very common clock source? :)
18:04:53 <khyperia> Has anyone here played with the plugins library? I'm getting linker errors when I try to use a library
18:06:09 <c_wraith> khyperia: errors about having loaded the same library twice?
18:06:17 <khyperia> no, about symbol not found
18:06:43 <c_wraith> ah.  I don't know a solution anyway..  I was just thinking about other issues people have reported with it recently
18:06:45 <khyperia> technically "blahblah.o: unknown symbol `big_scary_name'"
18:21:43 <levi> khyperia: I have got symbol not found errors when trying to link an application to a binary produced by the same cabal file. I'm not sure why; I just added the library source dir to the list of dirs in the application and it recompiles things for the application now.
18:22:28 <luite_> levi: you might've forgotten to add some of the modules to the exposed-modules or other-modules fields
18:23:48 <vozz_> What is wrong here? There's no error http://lpaste.net/100213
18:24:15 <khyperia> wait, levi, are you using System.Plugins.Make or invoking ghc on it's own?
18:24:31 <cmears> vozz_, I think you need to look at the full log file to see the whole error
18:24:34 <levi> luite_: Hmm. I re-exported all my modules in the top-level module, I think.
18:25:57 <levi> It's a yesod app with a subsite, and the symbol that's missing is probably one that's generated by the TH for route definitions.
18:26:22 <levi> I will dig more into it later; got plenty of more immediate issues. :)
18:27:30 <luite_> levi: you still need to list everything in the cabal file, even modules that aren't in the public api
18:29:15 <khyperia> how does lambdabot do it's plugins?
18:30:50 <levi> luite_: I mean that the module X in the cabal file has 'module X (module X, module X.A, module X.B) where...' and X.A and X.B are the only other modules.  Do I need to explicitly put them in the cabal file even though X re-exports them?
18:31:42 <levi> khyperia: I'm not using plugins at all; I just have a cabal file that builds both a library and a thing executable wrapper around it.
18:31:58 <khyperia> ah, then never mind
18:32:02 <vozz_> cmears: here's the full log: http://lpaste.net/100214
18:33:45 <luite_> levi: yes, under other-modules
18:34:26 <levi> Ah, that must be the problem then.
18:34:41 <cmears> vozz_, and there's the error
18:36:32 <vozz_> What does it mean?
18:38:14 <cmears> vozz_, it's essentially a type error
18:43:29 * hackagebot etcd 0.1.0.2 - Client for etcd, a highly-available key value store  http://hackage.haskell.org/package/etcd-0.1.0.2 (wereHamster)
18:44:03 <jle`> has anybody ever worked on something that can translate ghc error messages into more newbie-friendly ones?  although it would probably be bad to have new people rely on it
18:44:36 <ts1984> Does anyone know of a simple example for a call-by-need lambda evaluator in Haskell?
18:44:45 * enthropy thinks they are intended to be newbie-friendly
18:44:59 <enthropy> it's just not easy telling people that they contradicted themselves
18:45:02 <jle`> enthropy: some things are kind of foreign to new peoples and could be spelled out in probably plainer english
18:45:10 <jle`> things like instance Num Bool
18:45:32 <jle`> i mean it spits out other stuff, but to someone new it is not as easily understandable as to someone with a day or two of experience
18:45:40 <jle`> or someone who has asked people for help
18:46:14 <jle`> for example, built-in/programmed responses to the common instance Num/Fractional etc. messages
18:47:14 <jle`> "You probably meant to use a number here, but you actually used a ___.  ___ is not a number, so either give us a way to convert it into a number or just use a number here."
18:47:24 <jle`> also, with context-aware error messages
18:47:27 <jle`> we can reclaim map for Functor
18:47:43 <jle`> if you have a custom error message if you try to (f)map a list
18:47:59 <jle`> we can also claim (.) and id for Category woot woot.
18:48:16 <enthropy> @google haskell gopher language
18:48:17 <lambdabot> http://en.wikipedia.org/wiki/Gofer_(programming_language)
18:48:17 <lambdabot> Title: Gofer (programming language) - Wikipedia, the free encyclopedia
18:49:00 <enthropy> they put effort into maing gofer / hugs friendly
18:49:13 <jle`> and the moral is that it's a bad idea?
18:50:03 <enthropy> my point is that people have tried and there's some progress
18:50:21 <enthropy> ghc has a spell checker as of 7.6 or so
18:50:38 <jle`> ah, thanks
18:50:51 <zRecursive> Is Idris  a strict haskelll ?
18:51:12 <Iceland_jack> zRecursive: Not really
18:51:26 <Iceland_jack> Idris is strict and similar to Haskell but there's much more to it
18:51:38 <enthropy> jle`: http://www.open.ou.nl/bhr/phdthesis/introduction.html
18:51:57 <zRecursive> Iceland_jack: Idris needs haskell to install
18:52:03 <enthropy> maybe there are one or two people working on the same project
18:52:14 <Iceland_jack> zRecursive: Sure, Idris is written in Haskell
18:52:15 <jle`> enthropy: thanks
18:52:25 <Iceland_jack> that doesn't make it Haskell though
18:52:35 <enthropy> but since they are doing research, I don't think they just collect heuristics like the ones you're proposing
18:52:39 <jle`> good to know that it's a topic of research
18:52:39 <zRecursive> A new language
18:52:48 <jle`> because i am sure we have all heard
18:53:11 <enthropy> the contributions they make are more like "a better way to specify those heuristics"
18:53:11 <jle`> that error messages was one of the bigger barriers to newcomers in haskell
18:53:37 <jle`> or well, it has been said
18:53:41 <jle`> not sure if it's precisely true.
18:53:51 <johnw> which error was that?
18:53:56 <NemesisD> is this the right channel to ask some questions about haskell jobs? i'm curious about people's experiences
18:54:10 <jle`> but i have even heard it claimed that Java etc. are superior to Haskell in terms that languages like Haskell have awful error messages
18:54:11 <zRecursive> no jobs here :)
18:54:21 <jle`> i'm not going to back up the argument becuase it's kinda silly
18:54:35 <jle`> but the fact that people have even said it is also something that might be addressed
18:54:50 <NemesisD> not really asking for a job, just want to ask some questions of people who do haskell professionally
18:54:59 <dolio> Error messages in GHC are awesome compared to 10 years ago.
18:55:03 <enthropy> some older compilers have terrible error messages
18:55:28 <zRecursive> NemesisD: go ahead
18:55:42 <johnw> NemesisD: shoot
18:55:44 <jle`> also i really wish that map was fmap, and maybe back in the day, had they had better heuristics and error messages, it could have stayed fmap :/
18:56:11 <NemesisD> i was curious if people had haskell jobs and worked remotely, and how remotely (different part of the country or different country entirely)
18:56:17 <jle`> and mapM could be mapM from Traversable
18:56:27 <enthropy> it's not really a big deal to import ClassyPrelude
18:56:31 <johnw> i have a haskell job, work remotely, and my coworkers are in Seattle, Italy and Israel
18:56:36 <alpounet> NemesisD: currently doing interconinental contract work
18:56:39 <NemesisD> i'm starting to realize if i want to do haskell in my next job it will very likely have to be remote work
18:56:52 <enthropy> write some code with it... you might change your mind and come running back to Prelude
18:56:55 <jle`> ah i guess that's the main purpose of classy preludes?
18:57:01 <NemesisD> johnw: where is the company based? and does that affect your tax situation? are you independent contractor?
18:57:07 <johnw> I use ClassyPrelude on my work projects
18:57:09 <jle`> or one of them
18:57:30 <johnw> NemesisD: the company is based in San Diego, I work on contracting terms.  It means I have to file quarterly estimated taxes
18:58:30 * hackagebot hOpenPGP 1.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.1 (ClintAdams)
18:58:49 <NemesisD> johnw: is that generally disadvantageous compared to standard employment? i'm also happy to take this conversation to PM to avoid bugging folks
18:58:51 <dolio> I don't see how not liking classy prelude would entail the current state of the prelude is better than what it once was.
18:59:44 <johnw> classy prelude makes some function, like map and fold, etc., much more generalized by default.  And other functions too, like length
18:59:50 <johnw> NemesisD: I'll PM you
19:00:33 <johnw> but it does just make map = fmap.  I uses MonoTraversable so that map is generalized even over Text and ByteString, for example
19:01:40 <dolio> I know what it does. That doesn't mean that if you don't like it's specific choices, that there aren't other choices that are better than 'everything is monomorphic.'
19:01:52 <dolio> Its, even.
19:02:32 <enthropy> dolio: is there a prelude that you prefer?
19:02:33 <johnw> I was more clarifying for others listening in
19:02:40 <dolio> Haskell 1.4 was better.
19:03:47 <johnw> I'm torn on ClassyPrelude.  In some ways I really like the convenience, but in other way I like import more "standard" modules
19:05:37 <dolio> map was the current fmap. (++) was mplus. There was a separate MonadZero with a member called zero (I believe). You had monad comprehensions....
19:05:40 <dolio> There was no fail.
19:06:11 <dolio> There's probably other stuff I'm not remembering.
19:06:13 <Iceland_jack> <dolio> There was no fail.
19:06:13 <Iceland_jack> literally
19:06:25 <prophile> programs were so slow that nobody discovered that if they actually started all that happened was that simon peyton jones crawled out of your nose
19:06:32 <Iceland_jack> ‚Äòfail‚Äô is autological
19:07:14 <Rarrikins> The typechecker deleted your source code if the types were incorrect.
19:07:32 <dolio> I don't think that was in the standard.
19:07:40 <Rarrikins> It should be.
19:08:28 <dolio> Maybe next year we'll finally be closer to on par with 1.4's prelude.
19:08:38 <dolio> With (<|>) and (<$>) at least.
19:09:28 <dolio> And monad comprehensions are back.
19:09:34 <dolio> If you switch them on.
19:10:57 <dolio> Probably actually better with the inclusion of Applicative.
19:11:14 <dolio> And associated stuff.
19:20:18 <vozz_> Why doesn't this work? http://lpaste.net/100215
19:20:49 <dolio> genrandnums (length - 1)
19:21:00 <vozz_> ah, thanks!
19:21:26 <Iceland_jack> vozz_: There are many issues with the code
19:21:53 <dolio> list ++ num probably won't work, either.
19:21:59 <ion> I wonder if it would be useful to have types like ‚Äú!Foo -> !Bar‚Äù: the compiler will implicitly convert a ‚ÄúFoo‚Äù to ‚Äú!Foo‚Äù by adding a seq at the call site, also a ‚Äú!Foo‚Äù can be implicitly converted to ‚ÄúFoo‚Äù without doing anything. The potential benefit would be that if you have a !Foo, it‚Äôs guaranteed to be evaluated to WHNF and passing that to something else that requires a !Foo
19:22:01 <ion> doesn‚Äôt need branching to a thunk in the generated code.
19:22:06 <Iceland_jack> 'length-1' should be (length-1)
19:23:12 <Iceland_jack> vozz_: You seem to be confused about how effectful computations
19:23:33 <Iceland_jack> You're using the pure randomness functions and lifting them into the IO monad
19:24:20 <vozz_> It's pure? But it's random?
19:24:29 <Iceland_jack> vozz_: randomR is pure
19:24:55 <geekosaur> vozz_: getting an initial seed can be impure. after that, it's just a PRNG
19:25:12 <Iceland_jack> > randomR (0, 100) (mkStdGen 42)
19:25:13 <geekosaur> none of which are actually random
19:25:13 <lambdabot>  (25,1720602 40692)
19:25:14 <Iceland_jack> > randomR (0, 100) (mkStdGen 42)
19:25:15 <lambdabot>  (25,1720602 40692)
19:25:36 <Iceland_jack> vozz_: Look at the type
19:25:36 <Iceland_jack> @type randomR
19:25:37 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
19:25:38 <Iceland_jack> it's pure
19:25:51 <vozz_> Ah. Where does the seed come from?
19:25:56 <geekosaur> (in any language/library. PRNGs are just math, and any randomness comes from injecting a random initial seed)
19:26:06 <vozz_> Is it the same each time it runs or is it random?
19:26:08 <Iceland_jack> vozz_: You're passing the seed with getStdRandom
19:26:16 <Iceland_jack> Instead of that, just use randomRIO
19:28:05 <Iceland_jack> also you should rather have the O(1):
19:28:05 <Iceland_jack>     genrandnums (length-1) (num:list)
19:28:05 <Iceland_jack> than
19:28:08 <Iceland_jack>     return $ genrandnums length-1 (list ++ num)
19:28:11 <Iceland_jack> which is O(n) and a type error and a syntax error :)
19:28:23 <Iceland_jack> okay, not a syntax error
19:28:51 <Iceland_jack> vozz_: There is a function which does basically what you want called ‚Äòrandoms‚Äô
19:29:46 <Iceland_jack> :t do gen <- newStdGen; return (take 15 (randoms gen))
19:29:47 <lambdabot> Random a => IO [a]
19:29:55 <Iceland_jack> Now you have 15 random numbers
19:30:21 <Iceland_jack> > randoms (mkStdGen 42) :: [Int] -- now you have an infinite list of random numbers
19:30:22 <lambdabot>  [-3907187990116499535,-2519438828217931933,-8264534369199619667,868871358309...
19:30:24 <vozz_> Iceland_jack: Doesn't newStdGen give the same seed each time?
19:30:42 <Iceland_jack> vozz_: try it out yourself in GHCi
19:31:01 <Iceland_jack> I get
19:31:01 <Iceland_jack> ghci> newStdGen
19:31:01 <Iceland_jack> 655184748 40691
19:31:01 <Iceland_jack> ghci> newStdGen
19:31:06 <Iceland_jack> 655224762 1655838863
19:31:41 <vozz_> Could I take Chars instead of Ints?
19:32:03 <Iceland_jack> > randoms (mkStdGen 42) :: String
19:32:04 <lambdabot>  "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835\8904...
19:32:06 <Iceland_jack> Yes
19:35:04 <Iceland_jack> vozz_: If you want to implement it yourself you can do something like
19:35:04 <Iceland_jack>     genRandNumbs :: Integer ‚Üí IO [Integer]
19:35:04 <Iceland_jack>     genRandNumbs num = replicateM num (randomRIO (0, 51))
19:35:28 <vozz_> Doing it as a string doesnt work for me: http://lpaste.net/100220
19:35:29 <Iceland_jack>     replicateM 4 (randomRIO (0, 51))
19:35:29 <Iceland_jack> generates a list of 4 random numbers
19:35:47 <Iceland_jack> because the types are wrong
19:36:12 <vozz_> I don't understand
19:36:24 <vozz_> It's what you typed earlier and lambdabot liked it
19:36:34 <Iceland_jack> You should do
19:36:34 <Iceland_jack>     return $ take 15 (randoms gen :: String)
19:36:45 <vozz_> oh
19:36:46 <vozz_> thanks
19:36:51 <Iceland_jack> no problem
19:37:04 <Iceland_jack> What you should do is check the type yourself in GHCi
19:37:55 <Iceland_jack>     ghci> let gen = mkStdGen 42
19:37:55 <Iceland_jack>     ghci> :t randoms gen
19:37:55 <Iceland_jack>     randoms gen :: Random a => [a]
19:38:28 <Iceland_jack> and then you can try to make that of type [Char] (which works because Char is an instance of Random)
19:38:28 <Iceland_jack>     ghci> :t randoms gen :: [Char]
19:38:28 <Iceland_jack>     randoms gen :: [Char]
19:38:45 <vozz_> Ah
19:38:56 <vozz_> How come it gives me a load of \23525
19:38:59 <vozz_> etc
19:39:06 <vozz_> rather than actual characters?
19:39:07 <Iceland_jack> Well those are the random characters it's picking
19:39:10 <Iceland_jack> those are characters
19:39:24 <vozz_> Why doesn't it display like an ordinary string?
19:39:36 <Iceland_jack> Because that's the Show instance for Char
19:39:43 <Iceland_jack> try writing 'Œª' into GHCi
19:39:48 <startling> > 'Œª'
19:39:49 <lambdabot>  '\955'
19:40:08 <vozz_> I get back ' '
19:40:20 <Iceland_jack> vozz_: What do you mean?
19:40:33 <vozz_> If I type ' ' into ghci i get ' ' displayed as a response
19:40:44 <Iceland_jack> That shouldn't be a space, it should be a lambda
19:40:48 <vozz_> oh
19:41:00 <cmears> > 'È'
19:41:01 <lambdabot>  '\65533'
19:41:03 <Iceland_jack> Try writing
19:41:03 <Iceland_jack>     ghci> putStrLn "\955"
19:41:03 <Iceland_jack> in GHCi
19:41:04 <vozz_> ah
19:41:20 <vozz_> can I restrict the chars to a-z A-Z 0-9?
19:41:32 <Iceland_jack> vozz_: sure, just like you restricted numbers
19:41:42 <vozz_> it'd probably be easier to do it with numbers and then map it wouldnt it?
19:41:54 <Iceland_jack> :t randomRs
19:41:55 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
19:42:11 <Iceland_jack> :t randomRs ('a', 'z') (mkStdGen 42)
19:42:12 <lambdabot> [Char]
19:42:18 <Iceland_jack> > randomRs ('a', 'z') (mkStdGen 42)
19:42:19 <lambdabot>  "ndfeolyrgnvdecmnpxdaqmqgsycsbembciyzoumzkiqqkszcbikcasnfqdkqrkfgtcsjwzpprbw...
19:42:25 <vozz_> but I mean a-z and A-Z and 0-9 all at once
19:42:49 <vozz_> > randomRs ('a', 0) (mkStdGen 42)
19:42:50 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
19:42:50 <lambdabot>    arising from the literal `0'
19:42:50 <lambdabot>  Possible fix:
19:42:50 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Char)
19:42:56 <vozz_> worth a try
19:43:04 <vozz_> oh wait
19:43:08 <vozz_> > randomRs ('a', '0') (mkStdGen 42)
19:43:09 <lambdabot>  "EEA>@YBE8I?MJB4]U1[T@4P\\T>X`[HRSFZ^QRFJ5N2T8>D[N_R:ZFP3;`=PHUX3>E^`1<37KAY...
19:43:21 <vozz_> > randomRs ('a', 'Z') (mkStdGen 42)
19:43:23 <lambdabot>  "aa_\\^a`a\\]_]^`Z[aa[Z`Z^`^\\\\\\a`Z]`Z`a\\`^_\\\\\\\\``a\\[\\`Z\\`a[^a\\\\...
19:43:40 <vozz_> odd.
19:43:48 <Iceland_jack> it's not very odd
19:44:02 <vozz_> I would have thought a-z and A-Z would be next to each other
19:44:06 <vozz_> oh
19:44:13 <Iceland_jack> Are you familiar with ASCII?
19:44:13 <vozz_> > randomRs ('Z', 'a') (mkStdGen 42)
19:44:14 <lambdabot>  "aa_\\^a`a\\]_]^`Z[aa[Z`Z^`^\\\\\\a`Z]`Z`a\\`^_\\\\\\\\``a\\[\\`Z\\`a[^a\\\\...
19:44:19 <vozz_> vaguely
19:44:26 <Iceland_jack> may want to read up on that
19:44:40 <vozz_> ah
19:44:50 <vozz_> theres's symbols between upper and lowercase
19:44:52 <vozz_> never realised
19:45:02 <vozz_> > randomRs ('A', 'z') (mkStdGen 42)
19:45:03 <lambdabot>  "d`Ra_`eFMjTDcgQXpZDOoks]ecWubCYrmswpYEmVACQAQcViZAeQCoTr]Lm_TmRkzewDMxzT\\b...
19:45:08 <vozz_> closer
19:45:11 <Iceland_jack> if you're on a unix system you can do ‚Äòman ascii‚Äô
19:45:16 <khyperia> it's actually kinda smart, if you flip a bit (forget which one) you switch upper/lower
19:45:23 <vozz_> oh right
19:45:28 <Iceland_jack> if you xor with 32 :)
19:45:46 <Iceland_jack> > ord ' ' -- aka
19:45:47 <lambdabot>  32
19:46:03 <Iceland_jack> > chr $ ord ' ' `xor` ord 'a'
19:46:04 <lambdabot>  'A'
19:46:07 <Iceland_jack> > chr $ ord ' ' `xor` ord 'U'
19:46:08 <lambdabot>  'u'
19:46:14 <vozz_> Is there a way I can combine multiple ranges?
19:48:29 <cmears> Generate a random index from 0 to whatever
19:48:42 <cmears> Then use that as an index into a sequence of the things you want to draw from
19:48:49 <vozz_> > filter (`elem` (['0'..'9']++['a'..'z']++['A'..'Z'])) $ randomRs ('0', 'Z') (mkStdGen 42)
19:48:50 <lambdabot>  "T47WUXUV8KZUR1Y31D436U8H0U9FALJ3S1UZ140V1MXV8K7H4HX72ZSWMEZQ7WFY3K2LBNTNQZZ...
19:49:03 <Iceland_jack> or alternatively define a new data type with a Random instance
19:49:08 <vozz_> well that nearly worked
19:49:21 <vozz_> > filter (`elem` (['0'..'9']++['a'..'z']++['A'..'Z'])) $ randomRs ('0', 'z') (mkStdGen 42)
19:49:22 <lambdabot>  "wEspYBwQ0fctMvn1BTYfiCmpGtHRSxAQ9JNgKmQvBNF9SsFPLTy7zUXeyJn3P2sYGa1On0AaZiw...
19:49:25 <vozz_> yay!
19:49:43 <vozz_> > filter (`elem` (['0'..'9']++['a'..'z']++['A'..'Z'])) $ randomR (mkStdGen 42)
19:49:44 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
19:49:44 <lambdabot>              with actual type `g0 -> (a0, g0)'Couldn't match expected type `(...
19:49:44 <lambdabot>              with actual type `System.Random.StdGen'
19:50:09 <vozz_> > filter (`elem` (['0'..'9']++['a'..'z']++['A'..'Z'])) $ (randoms :: [Char]) (mkStdGen 42)
19:50:11 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
19:50:13 <lambdabot>              with actual type `g0 -> [a0]'Couldn't match expected type `Syste...
19:50:15 <lambdabot>                                -> [GHC.Types.Char]'
19:50:17 <lambdabot>              with actual type `[GHC.Types.Char]'
19:50:23 <vozz_> whatever, i'll go with the first
19:50:56 <Iceland_jack> > map ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) (randomRs (0, 61) (mkStdGen 42))
19:50:57 <lambdabot>  "X9VUInAh01rRaK4P3rbwasaee4YaLuslqe4hCuOxs0guqeNu74eIgyn1kDI8tYtu98qhALdvh54...
19:51:02 <Iceland_jack> It's not a nice solution thuogh
20:01:03 <Iceland_jack> > let set = ['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'] in map (set !!) (randomRs (0, length set - 1) (mkStdGen 42)) -- without the magic number
20:01:04 <lambdabot>  "X9VUInAh01rRaK4P3rbwasaee4YaLuslqe4hCuOxs0guqeNu74eIgyn1kDI8tYtu98qhALdvh54...
20:07:42 <no-n> how do I sort a list of strings without case sensitivity?
20:07:52 <Iceland_jack> :t sortBy
20:07:53 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
20:08:40 <Iceland_jack> > sortBy (comparing toLower) "HELLOhello"
20:08:41 <lambdabot>  "EeHhLLllOo"
20:08:49 <Iceland_jack> Does that answer your question no-n?
20:08:50 <no-n> thanks
20:08:53 <no-n> yes :)
20:08:55 <jmcarthur> :t sortBy (comparing $ map toLower)
20:08:56 <lambdabot> [[Char]] -> [[Char]]
20:09:13 <Iceland_jack> oh a list of strings
20:09:19 <Iceland_jack> yes, you need ‚Äòmap toLower‚Äô
20:09:23 <Clint> there's also the case-insensitive package
20:09:57 <Iceland_jack> no-n: where
20:09:57 <Iceland_jack>     comparing (map toLower)
20:09:57 <Iceland_jack> is the same as
20:09:57 <Iceland_jack>     \str1 str2 -> compare (map toLower str1) (map toLower str2)
20:10:00 <Iceland_jack>  
20:10:40 <no-n> I see
20:11:20 <Iceland_jack> If you wanted a sort a list of numbers by their absolute value you'd write
20:11:21 <Iceland_jack> > sortBy (comparing abs) [-5..5]
20:11:22 <lambdabot>  [0,-1,1,-2,2,-3,3,-4,4,-5,5]
20:11:43 <no-n> interesting :)
20:12:26 <Iceland_jack> I think there should be a function called
20:12:26 <Iceland_jack>     sortOn = sortBy . comparing
20:12:26 <Iceland_jack> but meh :)
20:12:54 <no-n> hehe
20:13:38 * hackagebot flamethrower 0.0.3.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.3.0 (charmander)
20:14:07 <Iceland_jack> Someone called ‚Äòcharmander‚Äô publishing a package called ‚Äòflamethrower‚Äô :)
20:43:51 <enthropy> when parsing an AST do people apply associativity/precedence when parsing, or later on?
20:44:43 <simpson> enthropy: Depends on the language.
20:45:12 <enthropy> data LM v = V v | Op (LM v) Op (LM v) | Tuple [LM v]
20:45:16 <enthropy> is what I currently have
20:45:23 <enthropy>  data Op = Mul | Plus | ...
20:45:39 <vozz_> Why is getSession working but not setSession? I think I've done something wrong with the forM_ http://lpaste.net/100224
20:45:51 <enthropy> everything is infixl with equal weight for now
20:46:07 <enthropy> actually infixr
20:46:58 <enthropy> vozz_: "(?x ->"  should be "\x ->" ?
20:47:11 <vozz_> Oh damn I'm an idiot
20:47:17 <vozz_> Thanks a lot
20:47:38 <pavonia> Is that compiling?
20:48:29 <vozz_> It's not that, that was just a weird copy paste error.
20:48:36 <vozz_> It's compiling, yeah
20:48:36 <enthropy> @pl \(a,b) -> f a b
20:48:36 <lambdabot> uncurry f
20:48:42 * hackagebot purescript 0.4.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.4.2 (PhilFreeman)
20:52:13 <vozz_> It's working now it seems
20:52:16 <vozz_> weird
20:52:53 <carter> enthropy: would be easy to pick out the fixity / associative decs after tokenization / lexing
20:52:59 <carter> and before parsing
20:53:10 <carter> (if say, you were doing it in haskell)
20:53:24 <carter> otoh
20:53:26 <carter> idk
20:53:33 <enthropy> no I'm not parsing haskell, the fixities are predetermined
20:53:37 <carter> ok
20:53:44 <carter> well
20:53:47 <carter> theres 2 cases
20:53:50 <carter> the no parens case
20:53:57 <carter> or the parens case right?
20:54:33 <carter> in the no paren case you'll have an alternating list that starts and  ends with values / expressions
20:54:40 <carter> and is interleaved with operators right?
20:54:47 <carter> idk
20:54:56 <carter> theres more than one way to organize it
20:54:58 <enthropy> well I already have a list
20:55:30 <enthropy> "y ~ x*f(c) + z" ==> Op (V "y") Tilde (Op (V "x") Mul (Op (Op (V "f") App (Tuple [V "c"])) Plus (V "z")))
20:56:54 <carter> so you can then do the greedy thing
20:56:59 <carter> right?
20:57:19 <enthropy> dunno what that one is
20:57:23 <carter> ah
20:57:33 <carter> you can then resolve it
20:57:36 <carter> top down
20:57:37 <carter> or bottom up
20:57:42 <carter> highest fixity
20:57:44 <carter> or lowest
20:57:45 <carter> right?
20:57:51 <carter> oh yeah
20:57:58 <carter> do lowest fixity first
20:58:02 <carter> then you get two sub problems!
20:58:13 <carter> that are independent
20:58:42 <carter> idk if that makes sense
20:58:42 * hackagebot rex 0.5 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.5 (MichaelSloan)
21:05:48 <enthropy> dunno if that makes sense
21:05:54 <enthropy> seems like I have something working
21:06:12 <enthropy> hard to check that it's good without doing the pretty printer
21:06:45 <carter> ok
21:06:49 <carter> hrmm
21:07:01 <carter> you know how if you have a lowest precedence operators
21:07:09 <carter> call it L
21:07:19 <carter> you essentiall now have  (exp1) L (exp2)
21:07:31 <carter> and you can parse exp1 and exp2 indepdnently?
21:09:33 <anders0> does anyone know if haskell.org is doing gsoc this year?
21:09:48 <carter> anders0: ALWAYS
21:09:53 <lispy> anders0: we applied, but IIRC we don't know for sure yet
21:10:06 <carter> lispy: we can probably assume a slot will happen
21:10:10 <carter> right?
21:10:21 <carter> like, isn't haskell.org one of the orgs that slowly gets more slots?
21:10:24 <anders0> ok, that's what i thought :) (lispy: the accepted orgs are listed on the 24th)
21:10:34 <carter> anders0: are you a student?
21:10:35 <carter> :)
21:10:44 <anders0> yup
21:10:51 <carter> what sort of thing are you hoping to do?
21:11:11 <anders0> i was hoping to do something with the idris compiler, if that's allowed
21:11:25 <anders0> (it's written in haskell, obviously, which is why i'm asking.)
21:11:47 <lispy> carter: They've enjoyed working with haskell.org in the past.
21:12:00 <carter> lispy: vs?
21:12:11 <lispy> anders0: Do you know about #idris?
21:12:37 <lispy> anders0: If not, you might hang out there and get to know the folks
21:12:39 <carter> anders0: have you worked on the idris compiler yet?
21:12:42 <carter> yeah
21:12:45 <enthropy> might be a hard sell
21:13:02 <carter> yeah
21:13:04 <carter> i agree
21:13:06 <enthropy> tools like haddock and cabal and ghc are easier justify
21:13:18 <carter> also high risk unless you've done a lot of work on idris before
21:13:21 <anders0> yeah, that's what i was thinking :(
21:13:22 <lispy> carter: vs nothing :) You asked how likely it was. Nothing is certain, but they have had good experiences with us.
21:13:23 <enthropy> since lots of people use them... irdis is not that popular as far as I can tell
21:13:42 * Ralith isn't sure gsoc is exclusively interested in popularity
21:13:47 <carter> true
21:13:47 <carter> BUT
21:14:08 <carter> neat projects only get slotted in if the student can demonstrate its a low risk project
21:14:18 <lispy> Ralith: from google's perspective the goal is mentoring people in FOSS contributions and retention in the community
21:14:23 <carter> yeah
21:14:34 <carter> that too
21:14:43 <carter> Ralith: like, i'm trying to get some folks interested in hacking on pandoc
21:14:48 <carter> because i think that'd have nice impact
21:14:52 <lispy> Ralith: From our perspective, it's about contributions that improve the ecosystem and community
21:14:53 <Ralith> it would
21:15:13 <carter> Ralith: which contributions?
21:15:16 <Ralith> lispy: well, there's no doubt that idris has the potential to be influential
21:15:18 <Ralith> carter: ?
21:15:34 <carter> Ralith: a gsoc project isn't  "help with X"
21:15:35 <Ralith> lispy: I suppose it's arguably too early, though
21:15:38 <carter> its "do a b c on X"
21:15:46 <Ralith> carter: I do not understand what you are asking me
21:15:47 <lispy> Ralith: Right on both acconts
21:15:57 <carter> i'm not asking you anything
21:16:01 <carter> i'm being explainingy
21:16:06 <Ralith> carter: then why was there a question mark
21:16:16 <carter> because its after midnight
21:16:21 <Ralith> >_>
21:16:23 <carter> and you know i can't type after midnight
21:16:34 <Ralith> it doesn't make any more sense with a period!
21:17:29 <carter> sure
21:17:35 <carter> point being
21:17:54 <carter> Ralith: even student GSOCs on GHC are risky and a hard sell soemtimes
21:18:19 <carter> anders0: have you been hacking on idris already?
21:18:35 <jxv> is there a convenient/standard func that converts bytestring to text?
21:18:47 <carter> jxv: the unpack and packs migth work ok
21:18:58 <carter> T.pack . B.unpack
21:19:04 <lispy> jxv: is your bytestring encoded?
21:19:15 <lispy> jxv: or rather, what encoding does it have?
21:19:32 <carter> anders0: also #haskell-gsoc is a thing
21:19:39 <jxv> it's just ascii I think
21:19:45 <jxv> word8?
21:21:40 <lispy> jxv: if it's ascii then you can proabbly just do the unpack/pack thing
21:22:03 <carter> oh yeah
21:22:06 <carter> i forgot about then
21:22:13 <carter> i'm a bad engiener :)
21:22:16 <carter> and speller
21:23:28 <jxv> lispy, okay. I was wondering if there was a commonly defined func for this because it's an often occurence.
21:23:34 <hakujin> jxv: Data.Text.Encoding has what you want
21:23:57 <jxv> hakujin, thanks
21:24:14 <hakujin> see the Text.Lazy.Encoding flavour too
21:28:13 <no-n> it's hard to write good code sometimes
21:28:23 <carter> fact
21:28:25 <carter> and good night
21:28:40 <enthropy> bottom-up reassociating http://lpaste.net/100226
21:30:07 <enthropy> simpson: ^^ I thought I would be more involved
21:31:41 <simpson> enthropy: Depends, but looks like you've got something that works for you.
21:35:42 <vozz_> I'm getting ambiguous occurance of `map' because there's a map in Data.ByteString, but I have Data.ByteString qualified as BS so there's no conflict, why am I still getting the error?
21:36:32 <milfjord> show the error message and the code
21:36:33 <Ralith> paste your code
21:37:54 <vozz_> nevermind, I forgot to type qualified... just had import Data.ByteString as BS
21:38:16 <Rotaerk_> enthropy: given your example, how would an IsPlacementFailure x be matched against?
21:38:45 * hackagebot rex 0.5.1 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.5.1 (MichaelSloan)
21:39:23 <enthropy> what do you mean matched against?
21:39:44 <enthropy> if you know how that version works... the -XDataKinds version behaves the same
21:40:18 <enthropy> besides the minor issue of needing Proxy to pass around values that have the promoted types
21:40:40 <Rotaerk_> enthropy: given this:  place :: (IsPlacementFailure pf, Failure pf f) => entity -> CellIndex -> CellGrid entity -> f (CellGrid entity)
21:40:51 <c_wraith> vozz_: that one catches everybody at least once.
21:41:28 <enthropy> it just says that pf can be one of the types you make an instance of IsPlacementFailure
21:41:34 <enthropy> only one
21:41:46 <Rotaerk_> ah..
21:42:04 <enthropy> so that you don't get nonsense like   Failure Bool f => ...
21:43:28 <Rotaerk_> well the place function can fail with *either* IndexOutOfBounds *or* EntityAlreadyInGrid, but the caller would be forced to choose which one to allow
21:44:07 <Rotaerk_> wouldn't be able to have logic built around the kind of failure
21:44:22 <enthropy> then you do    (Failure pf f, Failure ix f) =>
21:44:47 <enthropy> or maybe   Failures [pf,ix] f =>
21:44:55 <levi> Hmm, is there any way to convince ghc-mod or hdevtools to get the current directory right when running Template Haskell expansions that run getDirectoryContents?
21:45:28 <Rotaerk_> enthropy: well, this signature compiles:  (Failure Foo f, Failure Bar f) => x -> f y
21:45:36 <Rotaerk_> but nothing is going to be an instance of both of those..
21:45:58 <enthropy> why not?
21:47:29 <enthropy> levi: that gets loaded by your editor? Maybe they use the same working directory as the program that starts them
21:47:39 <enthropy> at least that would be the sane thing to expect
21:47:52 <Rotaerk_> hmm the standard instances of (Failure e) are Maybe, List, IO, and Either, none of which would work
21:48:16 <Rotaerk_> I suppose I could write an instance just for that function
21:51:11 <Rotaerk_> I think this would break the intent of Failure
21:51:46 <Rotaerk_> the purpose of it seems to be to allow you to decide, at the callsite, which method of failure-reporting you want to use... Either, Maybe, throw, etc
21:51:53 <Rotaerk_> but doing this invalidates all those
21:55:18 <joneshf-laptop> is there soemthing to expand the tilde in a path?
21:55:30 <joneshf-laptop> canonicalizePath doesn't seem to do anything for me
21:57:16 <Rotaerk_> yea, if I did:  data Foo; data Bar; someFunc :: (Failure Foo f, Failure Bar f) => x -> f y
21:57:53 <Rotaerk_> then in order to perform logic on the type of error, I'd need to create something like..
22:00:39 <Rotaerk_> data FooBar x = FB_Foo Foo | FB_Bar Bar | Result x;  instance Monad FooBar where return = Result; instance Failure Foo (FooBar x) where failure = FB_Foo; instance Failure Bar (FooBar x) where failure = FB_Bar
22:01:30 <Rotaerk_> which brings me back to the same problem I had to start with, just roundabout
22:12:31 <pavonia> joneshf-laptop: You can easily replace the tilde using System.Directory.getHomeDirectory
22:15:16 <vozz_> I've got an error I sortof understand but dont know how to fix: http://lpaste.net/100227 The error is at the bottom, what do you suggest?
22:16:10 <thirsteh> I have an application that creates so much garbage that 50% of the CPU time is spent by the GC. Is there any existing tools to implement some kind of buffer pool (even though it obviously breaks referential transparency, but I can live with it if there's some loose guarantee that nobody references a buffer anymore.) Particularly, reusing old Text arrays? Or any other possible tricks to reduce GC time?
22:16:44 <pavonia> vozz_: Is SessionMap a synonym for M.Map T.Text ByteString?
22:16:50 <vozz_> pavonia: yes
22:17:05 <Kaidelong> maybe just replace let sess = with sess <- ?
22:17:32 <thirsteh> what Kaidelong said
22:17:37 <ezyang> thirsteh: That can't be right: the more garbage you have, the faster your GC runs!
22:17:50 <vozz_> That fixed it, thanks a load!!
22:17:59 <thirsteh> ezyang: unfortunately it's large pieces of garbage (new, huge Texts, constantly)
22:18:17 <thirsteh> texts from JSON too :/ (unfortunately I can't control the delivery)
22:19:24 <thirsteh> they have extremely short lifetimes, so I was thinking there might be something I can do wrt nursery settings
22:20:55 <ezyang> How short is "extremely short"?
22:20:58 <Yaniel> not sure if sarcasm but how is GC faster if there is more garbage?
22:21:06 <ezyang> If they die before the next GC, they literally should not impact GC time
22:21:20 <ezyang> Yaniel: In a copying collector, dead data (garbage) never gets traced
22:21:29 <thirsteh> ezyang: Parsed by aeson, then scanned once. Probably not short enough to die before one gc
22:21:56 <thirsteh> (for other reasons--there is some processing unrelated to the texts going on before they go out of scope)
22:23:50 <thirsteh> ezyang: my dream scenario is for me to somehow get Data.Text/aeson to magically reuse the underlying arrays that would have been collected
22:24:01 <ezyang> Furthermore, text has no pointers in it, so it shouldn't materially affect the time that GC takes
22:24:19 <ezyang> I'm sure there is a problem, but it seems like you're misdiagnosing it.
22:24:20 <thirsteh> although it would have to be some kind of fixed-chunk-size thing, probably, so it looks pretty bleak wrt library integration
22:25:01 <thirsteh> ezyang: ran -pa, aeson allocates the vast majority of memory
22:26:07 <thirsteh> I'm really not kidding. It's a lot of garbage, and it's all transmitted in JSON. Optionally base64-encoded HTTP response bodies ad nauseam
22:26:12 <ezyang> can you post your profile here http://heap.ezyang.com/
22:29:08 <Yaniel> hmm I'll read more about GC then
22:29:13 <ezyang> also can you post +RTS -s output
22:29:27 <ezyang> If you have a workload where things are fast, post the heap profile and GC statistics of that too.
22:29:55 <ezyang> How big is your program?
22:30:04 <thirsteh> ezyang: I'm not sure I can. I'll have to strip out some things or make a more narrow example.
22:30:15 <thirsteh> I can show you the top, at least
22:30:28 <ezyang> Didn't you run -ha?
22:30:59 <thirsteh> yes. I can't for non-technical reasons. Confidentiality
22:31:26 <ezyang> Ah. Well, then it will be difficult to help you debug this.
22:32:21 <ezyang> Anyway, what I would suggest is trying to make the lifetimes of the strings go down, and seeing if you are doing unnecessary allocation
22:33:08 <ezyang> If the heap graph is going straight up, probably the strings are being retained when they shouldn't, be aware of Text's behavior of creating slices of the original string when you ask for substrings
22:33:20 <ezyang> (use copy as necessary)
22:33:30 <PythonNut> @pl \x -> x
22:33:31 <lambdabot> id
22:33:55 <thirsteh> ezyang: I appreciate it. Don't get me wrong, I'd really like your help. I'll figure out a way to get you a profile later.
22:34:03 <thirsteh> ezyang: I can show you this, at least: http://lpaste.net/4044956029929127936
22:34:21 <thirsteh> (realizing it's almost certainly not sufficient)
22:34:33 <thirsteh> thanks for the pointer
22:34:59 <thirsteh> I'm not slicing the strings at all, so I don't think it's that
22:35:36 <PythonNut> @pl \x y -> rem x y == 0
22:35:36 <lambdabot> flip flip 0 . ((==) .) . rem
22:36:06 <PythonNut> @pl \x -> rem x y == 0
22:36:06 <lambdabot> (0 ==) . flip rem y
22:36:19 <ezyang> thirsteh: Then what is your aeson parser doing?
22:36:31 <PythonNut> @pl \y -> rem x y == 0
22:36:31 <lambdabot> (0 ==) . rem x
22:37:06 <thirsteh> ezyang: ah, true. I guess a value in some JSON array is sliced from the original JSON blob Text
22:37:51 <thirsteh> Text value, I mean
22:38:15 <PythonNut> @pl \x -> rem x y == 0
22:38:15 <lambdabot> (0 ==) . flip rem y
22:38:47 <PythonNut> @pl \x -> floor (sqrt (fromIntegral x))
22:38:47 <lambdabot> floor . sqrt . fromIntegral
22:38:59 <ezyang> thirsteh: Yep, that's pretty standard.
22:40:45 <PythonNut> @pl \x y-> rem x y == 0
22:40:45 <lambdabot> flip flip 0 . ((==) .) . rem
22:41:34 <PythonNut> @pl \x -> ((<x) . (^2))
22:41:35 <lambdabot> (. (^ 2)) . flip (<)
22:41:47 <ion> It works in private, too.
22:42:10 <PythonNut> @pl \x -> null [q | q<-[3, 5..floor (sqrt (fromIntegral x))], rem x q == 0]
22:42:10 <lambdabot> null . ap ((:) . ((q | q) <-) . enumFromThenTo 3 5 . floor . sqrt . fromIntegral) (return . (0 ==) . flip rem q)
22:44:03 <thirsteh> ezyang: I am also running 7.6.2 on a 32-core Xeon box, so I'm looking forward to test 7.8
22:44:25 <thirsteh> IIRC there were improvements to 8+-core GC recently?
22:47:40 <ezyang> nah, you're probably thinking of the new IO manager
22:48:03 <thirsteh> ah, thought there was something about gc.
23:43:59 * hackagebot HTTP 4000.2.11 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.11 (GaneshSittampalam)
23:46:09 <codygman> If I have very simple json like {"advertisers":["Target"]} how would I write the FromJSON instance using aeson like this example: https://github.com/bos/aeson/blob/master/examples/Simplest.hs
23:47:08 <supki> codygman: what's the datatype you want to parse JSON to?
23:47:49 <codygman> I'm using this: Advertiser { name :: String } and expect it to return [Advertiser]
23:50:15 <supki> parseJSON (Object o) = fmap Advertiser (o .: "advertisers"); parseJSON _ = empty
23:51:38 <supki> hm, I should probably check that works before pasting in IRC
23:52:46 <codygman> supki: Thanks for the help
23:52:53 <codygman> It did work
23:56:10 <supki> really?
23:57:22 <supki> It actually should be  instance FromJSON [Advertiser] where parseJSON (Object o) = fmap (map Advertiser) (o .: "advertisers"); parseJSON _ = empty
23:58:20 <codygman> supki: I made a mistake
23:59:00 * hackagebot network-api-support 0.0.8 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.8 (MarkHibberd)
23:59:42 <codygman> supki: It works fine with FlexibleInstances. Is FlexibleInstances safe to use?
