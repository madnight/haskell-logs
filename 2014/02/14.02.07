00:00:12 <Heather> getExecutablePath is IO FilePath so I just need to add String to it and make it not IO
00:03:33 <supki> you can't make it "not IO" once it's "IO"
00:04:24 <bitemyapp> supki: unsafePerformIO                    kekekekeke
00:04:27 <supki> what you can is to lift  </> "sync.xml"  to work on IO action results
00:04:49 <supki> like  fmap (</> "sync.xml") getExecutablePath
00:04:57 <prophile> unsafePerformIO is such an unwieldy name, I think it should be called 'run'
00:05:06 <bitemyapp> prophile: evil haskell tip
00:05:14 <bitemyapp> prophile: alias unsafePerformIO to run so you can use it more.
00:05:22 <prophile> of course!
00:05:31 <bitemyapp> prophile: are you wotton?
00:05:46 <prophile> wotton to the core?
00:05:55 <bitemyapp> jesus lol
00:11:00 * hackagebot yesod-core 1.2.6.7 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.7 (MichaelSnoyman)
00:11:00 * hackagebot hsimport 0.2.8 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.8 (DanielTrstenjak)
00:12:54 <Twey> @quote /bin/ls
00:12:54 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:13:01 <Twey> Heather: ↑
00:25:37 <ReinH> bitemyapp: yet another reason to avoid ($)
00:26:55 <jle`> Heather: yeah, it doesn't really make any sense to turn an IO String into a String
00:27:06 <jle`> getExecutablePath isn't a string wrapped in an IO flag
00:27:18 <ReinH> Heather: why not just use do notation? do { path <- getExecutablePath; return path </> "sync.yml" }
00:27:19 <xintron> How can I check if there is no data from stdin to be read?
00:27:39 <ReinH> it's a lot easier to understand than infix fmap if you aren't used to it
00:27:39 <bitemyapp> ReinH: die. I like $
00:27:47 <jle`> such hostility
00:27:48 <ReinH> bitemyapp: ?
00:27:56 <bitemyapp> ReinH: <3
00:28:08 <ReinH> bitemyapp: <3
00:28:21 <ReinH> bitemyapp: seriously though I don't like ($)
00:28:38 <ReinH> er, return (path </> "sync.yml") rather
00:28:40 <ion> I wish it was infixl.
00:29:01 <jle`> ever since a fateful discussion here a couple of weeks ago i've noticed my usage of ($) declining a lot
00:29:09 <jle`> i do a lot of (f . g . h) x now
00:29:30 <ReinH> I basically use it when required for do blocks and rarely otherwise
00:29:36 <jle`> i feel like if ($) was infixl then it would be abused much more
00:29:44 <jle`> and we'd see so many f $ g $ h $ x
00:29:46 <ReinH> liftIO $ do <a few lines>
00:29:47 <ReinH> etc
00:29:56 <ion> I also wish “foo do bar”. “foo \bar -> baz”, “foo case …” et al. worked.
00:30:06 <jle`> ReinH: I think that ($) is actually magic in that case
00:30:18 <ReinH> magic?
00:30:20 <jle`> so you technically aren't using ($) but a language syntax/keyword
00:30:30 <ion> No, you are using both.
00:30:30 <ReinH> jle`: no, you can just wrap the whole do block in parens
00:30:40 <ReinH> but... you know... I'd rather not
00:30:43 <jle`> ReinH: yeah, but if you use $ in that case, you are using syntax/keyword
00:30:50 <ion> No, you’re using ($)
00:30:54 <ReinH> no, ($) is still ($)
00:31:23 <ion> > 5 + do 2
00:31:24 <lambdabot>  7
00:31:26 <ion> That (+) is still (+)
00:31:39 <dalaing> @type ($)
00:31:40 <lambdabot> (a -> b) -> a -> b
00:31:59 <jle`> there is some compiler magic i think for multi-line do blocks
00:32:38 <ion> But that doesn’t have anything to do with the ($) that may or may not be there.
00:33:18 <dalaing> @type (.)
00:33:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:33:24 <jle`> fair enough
00:33:40 <ReinH> jle`: the do block gets desugared, yes, but that always happens
00:33:44 <jle`> :t (<=<)
00:33:45 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
00:35:03 <jle`> ReinH: i think it's the idea that you can't define your own ($) and have it work the same way
00:35:17 <ion> It’s actually the layout code that he’s thinking about. do \n foo <- bar \n baz is changed into do { foo <- bar ; baz }
00:35:18 <jle`> in that usage
00:35:19 <bitemyapp> ReinH: I like it fine. I pretend in my head that it's like |'ing data, but in the opposite direction.
00:35:24 <Heather> ReinH: sorry, wasn't here
00:35:30 <ion> jle: You can’t?
00:35:38 <jle`> ion: let me check
00:35:51 <bitemyapp> ReinH: I'm from Clojure where we have silly wastes of time like -> and ->> (threading macros) so simple things amuse me for no particularly good reason.
00:36:01 <ion> > let f ! x = f x in runIdentity ! do return 42
00:36:02 <lambdabot>  Couldn't match expected type `GHC.Arr.Array (m0 a1) e0'
00:36:02 <lambdabot>              with actual type `Data.Functor.Identity.Identity a0 -> a0'
00:36:19 <ion> > let f ^^^ x = f x in runIdentity ^^^ do return 42
00:36:20 <lambdabot>  42
00:38:33 <jle`> hm i guess you can. i wonder why i thought that i read that you couldn't (for multiline)
00:39:15 <quchen> ReinH: Re "magic ($)", I think the operator actually does have some magic: special inference rules when used with rank-n types.
00:39:34 <jle`> http://stackoverflow.com/questions/20795747/haskells-is-a-magic-operator
00:39:35 <quchen> That's why "dotting" things like runST fails
00:39:51 <ion> jle: “Multiline” is not relevant at all for the operator.
00:40:00 <jle`> yeah, i misunderstood when i read it :|
00:40:05 <quchen> Right, multiline has nothing to do with anything magic.
00:42:36 <ion> There are just not-too-complicated rules that transform “do”, “foo <- bar”, “baz” into “do { foo <- bar ; baz }” and the ($) doesn’t need to know or care about that.
00:44:33 <Twey> jle`: Your definition of ‘abuse’ sounds a lot like the normal definition of ‘use’ :þ
00:45:13 <quchen> You can't spell abuse without use
00:45:23 <Twey> jle`: The ($) for do-notation is just because you can't open a do-block next to an identifier, for some reason.  It doesn't have to be ($) — you can use any operator.
00:45:38 <Twey> quchen: Special inference rules?
00:46:12 <jle`> Twey: yeah, i misunderstood something i read earlier about impredicative types
00:46:22 <Twey> Oh, I see
00:46:29 <Twey> Weird!
00:46:53 <arrdem> bitemyapp: fine I'll pay attention in here.
00:46:54 <jle`> it doens'st have to do with do blocks at all actually
00:47:19 <quchen> Twey:
00:47:20 <quchen> http://lpaste.net/99592
00:47:25 <lieven_> something else I've wondered for a while. Is Enum's .. notation magical or can it be user defined?
00:47:33 <quchen> foo works, bar doesn't
00:47:45 <quchen> lieven_: Magic.
00:47:49 <Twey> quchen: Yep, I just saw the post and tried it in my GHCi
00:47:57 <Twey> Terrifying
00:48:07 <Twey> lieven_: But you can ‘user-define’ it by making your own Enum instance
00:48:08 <quchen> lieven_: Syntactic sugar for the enumFrom(To(Then)) functions.
00:48:41 <lieven_> Twey: yes I know.
00:48:41 <Twey> :t runST
00:48:42 <lambdabot> (forall s. ST s a) -> a
00:48:52 <Twey> :t runST $ undefined
00:48:53 <lambdabot> a
00:49:03 <Twey> :t let b = ($) in runST `b` undefined
00:49:04 <lambdabot> b
00:49:15 <Twey> Hmph
00:49:23 <quchen> Oh, Lambdabot knows ST? Interesting.
00:49:24 <sopvop> $ gets special treatment iirc
00:49:24 <Twey> :t let b = ($) in runST `b` (undefined >> undefined)
00:49:25 <lambdabot>     Couldn't match expected type `forall s. ST s b0'
00:49:25 <lambdabot>                 with actual type `m0 b1'
00:49:26 <lambdabot>     In the second argument of `b', namely `(undefined >> undefined)'
00:49:31 <Twey> :t let b = ($) in runST $ (undefined >> undefined)
00:49:32 <lambdabot> a
00:49:34 <Twey> There we are
00:49:50 <quchen> So I guess we can ShachafSort in this channel then?
00:49:54 <quchen> @quote shachaf array
00:49:54 <lambdabot> shachaf says: (\l -> Data.Array.IArray.elems $ runST $ do { arr <- newListArray (0,length l - 1) l :: ST s (STArray s Int Int); (`fix` 0) $ \loop i -> do { v <- readArray arr i; writeArray arr i (v^2); when (i < (length l - 1)) (loop (i+1))}; iarr <- unsafeFreeze arr; return (iarr :: Array Int Int) })  That's the best way to square all the
00:49:54 <lambdabot> elements of a list in Haskell, by far.
00:49:56 <Twey> sopvop: I know, I'm just being terrified of it
00:50:10 <quchen> Oh, it was squaring. Nevermind.
00:50:15 <Twey> Heh
00:50:26 <Twey> Whoever said Haskell is the best imperative language clearly intended there to be a DSL on top
00:50:48 <jle`> well
00:50:58 <jle`> it's a little cleaner on multiple lines
00:51:03 <jle`> (but not too muc)
00:52:42 <quchen> Twey: That was SPJ. Haskell is that intended DSL. :-þ
00:53:08 <jle`> is that the fix from Control.Monad.Fix ?
00:53:14 <quchen> Data.Function
00:53:17 <quchen> It's the usual fix
00:53:20 <quchen> :t fix
00:53:21 <lambdabot> (a -> a) -> a
00:53:44 <jle`> ah! that's where it is
00:53:54 <jle`> i have been importing the wrong thing this whole time :)
00:54:05 <jle`> i wonder why Function is in Data
00:54:11 <jle`> i guess because functions are data
00:54:17 <quchen> Yes, that would be one reason.
00:54:29 <quchen> Notice that Functors are data, but Monads are control structures.
00:54:31 <pavonia> What predicate is recommended to be used with Network.URI.escapeURIString?
00:54:40 <quchen> In other words, data vs. control is pretty arbitrary.
00:54:57 <dalaing> how do you ask lambdabot for free theorems again?
00:55:00 <Twey> quchen: Hahah.
00:55:01 <DemonMonkeysAreC> hey guys, newbie here. Was wondering how I should connect to a mysql database. I used the code here http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0/docs/Database-HDBC-MySQL.html but it gives me an error "Database.HDBC.MySQL" not found.
00:55:02 <jle`> i can see functors being data
00:55:05 <Twey> dalaing: @djinn
00:55:13 <dalaing> @djinn frix
00:55:13 <lambdabot> -- f cannot be realized.
00:55:15 <quchen> First, /q lambdabot. Then @djinn.
00:55:17 <dalaing> woops
00:55:31 <dalaing> @djinn fix
00:55:31 <lambdabot> -- f cannot be realized.
00:55:34 <quchen> Note that /q lambdabot part. It's important.
00:55:37 <Axman6> DemonMonkeysAreC: have you installed HDBS-mysql?
00:55:45 <Twey> DemonMonkeysAreC: You'll need to install the package before you can use its modules.
00:55:55 <DemonMonkeysAreC> via cabal
00:55:57 <DemonMonkeysAreC> ?
00:56:03 <Axman6> yes
00:56:19 <Twey> pavonia: Predicate for what?
00:56:26 <Twey> DemonMonkeysAreC: That's the usual way, yes
00:56:29 <DemonMonkeysAreC> I did try cabal install HDBC-mysql but it says no such package found
00:56:40 <Axman6> cabal update?
00:56:50 <pavonia> Twey: For that function to properly escape a URI
00:56:51 <DemonMonkeysAreC> ah now it works
00:56:57 <DemonMonkeysAreC> thanks a ton! you rock!
00:57:03 <quchen> pavonia: What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong?
00:57:07 <jle`> happy haskelling!
00:57:08 <quchen> Also, paste some code.
00:57:14 <quchen> I should add that to the copypasta.
00:57:39 <dalaing> @free fix
00:57:40 <lambdabot> f . g = h . f => f (fix g) = fix h
00:57:47 <dalaing> aha - that's the one
00:58:01 <pavonia> quchen: There are several predicates in that module, I don't know which is the one to choose to get the standard escaping
00:58:29 <DemonMonkeysAreC> Guys one more thing, it says mysql_config required, how do I install that>
00:58:34 <Twey> pavonia: Ah.  Well, it depends where you're going to be using it.  If it's a whole URI by itself, you can use isUnescapedInURI; otherwise, if you're going to be embeddeng it into something like a query string, you should use isUnescapedInURIComponent
00:58:35 <DemonMonkeysAreC> Guys one more thing, it says mysql_config required, how do I install that?
00:58:38 <Twey> embedding**
00:58:49 <Twey> DemonMonkeysAreC: It comes with mysql
00:59:02 <Twey> (or mysql-devel if you're on a system that likes to separate these things)
00:59:19 <DemonMonkeysAreC> I am on Ubuntu 12.04
00:59:26 <jle`> ubuntu does separate them
00:59:54 <pavonia> Twey: A component is one of the parts after '?'?
01:00:03 <Twey> DemonMonkeysAreC: libmysqlclient-dev apparently
01:00:04 <Twey> pavonia: Yes
01:00:13 <pavonia> Okay, thanks!
01:00:14 <Twey> pavonia: The part after the first ? is called the query string
01:00:23 <Twey> (up to the #, after which it's a fragment)
01:00:42 <Twey> (the fragment is also a component)
01:00:59 * hackagebot smallcaps 0.4 - A library and a program for pre-processing LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4 (StefanBerthold)
01:01:04 <DemonMonkeysAreC> but I have installed mysql-server and mysql-client :-(
01:01:13 <Twey> DemonMonkeysAreC: But do you have libmysqlclient-dev?
01:01:35 <DemonMonkeysAreC> No
01:01:41 <Twey> Well, then.
01:02:08 <Twey> DemonMonkeysAreC: http://lmgtfy.com/?q=ubuntu+mysql_config
01:02:36 <DemonMonkeysAreC> my bad :-( sorry
01:02:37 <Twey> For future reference
01:02:45 <Twey> No problem ☺
01:02:49 <DemonMonkeysAreC> I thought it was a haskell related thing
01:03:26 <DemonMonkeysAreC> thanks a ton guys, you all rock!
01:05:24 <Twey> pavonia: Generally you should try to avoid manually escaping things unless you're implementing a library that will do it for you
01:05:30 <Twey> (in case that's not what you're doing )
01:06:00 * hackagebot citation-resolve 0.4.2.3 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.4.2.3 (TakayukiMuranushi)
01:06:01 <Twey> It's a better idea to have escaped and unescaped strings in different types, so the type-system can keep track of them and make sure you don't open yourself up to an injection attack
01:06:50 <pavonia> Hhm, I'm preparing URIs for an external curl call
01:06:57 <xintron> Can a record have clashing "names" and if so, how do I access them? Tried Record.<name> but that didn't work
01:08:02 <pavonia> xintron: Not among different data types
01:08:07 <jle`> xintron: you can import packages namespaced
01:08:35 <jle`> import Data.Text as T, so you can use blah as well as T.blah, when there is a conflict.  or import qualified Data.Text as T, so you always have to use T.blah
01:08:51 <xintron> ah, so if I define it in my main package it should be under "Main.<name>" then?
01:09:34 <supki> xintron: no, they can't. usual workarounds are a) to place records in different modules, and then call Module1.name or Module2.name b) use lenses
01:09:48 <xintron> ok.
01:09:52 <xintron> Thanks
01:10:15 <jle`> also you probably don't want to import Main
01:10:36 <jle`> because you can't use anything that imports Main in Main itself
01:10:44 <jle`> it's an import loop
01:10:51 <jle`> but you probably weren't going to do that
01:14:06 <Heather> how to get directory of FilePath
01:15:31 <codygman_> Guys, I'm sorry for breaking haskell: https://twitter.com/codygman/status/431716022412787712/photo/1
01:15:32 <jle`> Heather: takeDirectory, i believe
01:16:01 * hackagebot egison 3.2.14 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.14 (SatoshiEgi)
01:16:16 <Heather> jle` thanks, I'll try
01:16:46 <bitemyapp> arrdem: ding maddafakka
01:16:56 <bitemyapp> arrdem: pane it up.
01:17:15 <Twey> Heather: http://hackage.haskell.org/package/filepath-1.1.0.2/docs/System-FilePath-Posix.html#5
01:17:16 <arrdem> bitemyapp: you have my 3rd monitor and now you have my attention.
01:17:22 <jle`> Heather: http://hackage.haskell.org/package/filepath-1.3.0.1/docs/System-FilePath-Posix.html#v:takeDirectory
01:17:25 <Axman6> codygman_: GIGO ;)
01:17:50 <bitemyapp> arrdem: you had my curiosity, now you have my attention.
01:18:32 <codygman_> Axman6: I am tired and forgot how to make an ADT somehow... lol
01:18:34 <Heather> jle and it's not crossplatform :S
01:18:48 <Heather> jle` should I use #if #endif stuff
01:18:56 <jle`> Heather: hm?
01:19:02 <Twey> I wonder why the FilePath stuff isn't in a typeclass.
01:19:04 <bitemyapp> arrdem: I'm in that awkward middle territory.
01:19:12 <jle`> takeDirectory should be cross platform i think
01:19:16 <bitemyapp> arrdem: could possibly go to sleep, might not be enough sleep to be worth it.
01:19:18 <Twey> I don't think so
01:19:21 <jle`> oh
01:19:27 <bitemyapp> arrdem: leaning towards sleep but not really sure.
01:19:28 <jle`> it's under Posix
01:19:30 <Twey> foo\bar\baz is one identifier in *nix
01:19:31 <Heather> jle` #if defined(mingw32_HOST_OS) || defined(__MINGW32__) ... windows filepath #else linux filepath
01:19:48 <bitemyapp> arrdem: what's driving the triple monitor?
01:19:49 <arrdem> bitemyapp: I'm gone. just realized how the next compilers project needs to work and started my idleminer script
01:19:50 <Heather> jle` and under windows too
01:20:09 <Twey> Heather: The usual way is to CPP the import.  The Windows and POSIX packages export the same interface, so you don't have to test at every call site, just do a conditional import of the right package.
01:20:11 <arrdem> bitemyapp: two Nvidia 560TIs
01:20:25 <bitemyapp> arrdem: is the second one strictly necessary to drive three displays?
01:20:25 <arrdem> bitemyapp: ~350KH/s of DOGGIE
01:20:31 <arrdem> bitemyapp: yarp.
01:20:37 <supki> Heather: System.FilePath is crossplatform
01:20:51 <supki> it chooses what module to re-export depending on your OS
01:20:56 <Heather> supki: but it can't dot TakeDirectory thing
01:21:01 <arrdem> g'night.
01:21:01 <Twey> Oh, yeah, System.FilePath does that for you
01:21:14 <jle`> http://hackage.haskell.org/package/filepath-1.3.0.1/docs/src/System-FilePath.html
01:21:20 <bitemyapp> arrdem: g'night
01:21:26 <jle`> Heather: System.Filepath re-exports takeDirectory
01:21:38 <Heather> hm...
01:21:48 <jle`> but only the takeDirectory that works for your system
01:22:13 <Heather> ah right
01:22:54 <Twey> codygman_: 7.6 says ‘Illegal deriving item `show'’
01:26:02 * hackagebot packed-dawg 0.2.0.2 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.2 (AndrasKovacs)
01:27:04 <Heather> okay.... how can I simplefie it : (</> "sync.yml") <$> takeDirectory <$> getExecutablePath >>= \yml -> doesFileExist yml >>= \isCfgEx ->
01:27:14 <Heather> yml because I will use fname in future
01:28:17 <Axman6> use do notation for one thing...
01:28:20 <jle`> well, (f <$> g <$>) is ((f . g) <$>)...but i this case i would just use do notation
01:29:22 <merijn> Is there a nice comprehensive explanation on why DatatypeContexts is bad? I'm trying to convince someone of removing them from existing code, but want to avoid writing down an elaborate explanation...
01:29:35 <jle`> do { yml <- getExecutablePath; isCfgEx <- doesFileExist (takeDirectory (yml </> "sync.yml")) ... }
01:29:41 <jle`> but i'm not totally sure what you are trying to do
01:29:48 <jneen> Heather: you can eta-reduce that lambda with doesFileExist
01:29:52 <jneen> >>= doesFileExist
01:30:13 <ReinH> do notation and fmap would be so much better
01:30:18 <Heather> jneen: that's why I said that I will need yml in future
01:30:19 <jneen> i dunno
01:30:25 <jneen> oh i see
01:30:34 <jneen> yeah, do notation is probably better in haskell
01:30:54 <jneen> although i wish left-to-right chaining were more idiomatic
01:30:57 <merijn> jle`: doesFileExist is almost always a bad idea
01:31:11 <jle`> merijn: just directly translating his code :|
01:31:29 <merijn> jle`: doesFileExist almost always results in a race condition
01:31:37 <merijn> jle`: (in any language, btw)
01:31:50 <merijn> What if some other process deletes the file after doesFileExist returns True?
01:32:12 <merijn> Best approach to checking for file existence is just trying to open it and catching any exceptions
01:32:56 <ReinH> do { yml <- fmap (flip combine "sync.yml" . takeDirectory . getExecutablePath) getExecutablePath ; ... }
01:33:08 <supki> I'd use replaceFileName instead of takeDirectory/</> dance
01:33:25 <ReinH> but checking for the file before doing stuff assuming the file exists is a bug like merijn says
01:33:29 <supki> (well, I'd actually use lens thing, but whatever)
01:34:29 <Twey> Is there something in the date/time/calendar libraries for printing out a date like ‘the 31st of October, 2011’?  I can't find any functions to produce an ordinal suffix
01:34:48 <ReinH> race condition, specifically TOCTOU
01:34:56 <Twey> TOCTOU?
01:35:11 <ReinH> time-of-check time-of-use https://cwe.mitre.org/data/definitions/367.html
01:35:21 <Twey> Ah
01:35:27 <startling> Twey: I wish.
01:35:34 <Twey> Aw.
01:35:38 <startling> Ruby has these, and the reverse thing too.
01:35:46 <startling> It's something I really miss.
01:35:47 <Twey> Even PHP has one
01:35:47 <ReinH> Twey: FFI to strftime? :p
01:35:54 <Twey> ReinH: strftime doesn't do it
01:36:03 <Twey> (isn't that what ‘formatTime’ does?)
01:36:03 <ReinH> :(
01:36:16 <jle`> well you could shell it out to date(1) :P
01:36:35 <jle`> (don't do that)
01:36:40 <ReinH> do it
01:36:40 <Twey> I could, or I could write one line of Haskell to do it natively :þ
01:36:47 <lieven_> Twey: not really that good an idea if you consider i18n
01:37:08 <Twey> lieven_: strftime (and formatTime) already have plenty of locale-specific options
01:37:16 <Twey> Heck, there's even an ‘American date format’ switch.
01:37:38 <dv-> :t Data.Time.Format.formatTime
01:37:39 <lambdabot> Data.Time.Format.FormatTime t => System.Locale.TimeLocale -> String -> t -> String
01:37:40 <Heather> ahm
01:37:48 <Heather> can't find proper yml example
01:37:48 <mm_freak_> Twey: i found this one, <http://hackage.haskell.org/package/fuzzytime>, but it uses old-time, which sucks
01:37:59 <Twey> Aye
01:38:07 <Heather> thought I need create some yml and encode it
01:38:18 <Twey> What's yml?
01:38:31 <Heather> Twey: alike json
01:38:40 <Heather> or xml
01:38:53 <merijn> Twey: YAML - Yet Another Markup Language
01:39:19 <Twey> Oh, I know YAML
01:39:29 <Heather> there was weird thing for haskell code formatting that is using YML, I think I should check it
01:39:30 <mm_freak_> Twey: oh, but there is <http://hackage.haskell.org/package/friendly-time>
01:39:49 <Heather> Twey: right... yaml
01:39:52 <startling> Data.Time.Format.Human, haha
01:40:17 <Twey> mm_freak_: That's cool, but not what I was looking for
01:40:24 <Twey> Heh
01:40:49 <mm_freak_> Twey: well, you can always set a custom time locale =)
01:41:43 <Heather> stylish-haskell is using yaml
01:41:43 <Twey> mm_freak_: I feel like really TimeLocale should define what escapes are accepted by formatTime :-\
01:43:10 <mm_freak_> Twey: i don't think that there are any escapes at all
01:44:55 <Twey> mm_freak_: TimeLocale actually doesn't allow for this behaviour at all.  Everything's specified in terms of strings that are pieced together — nothing's a function of the date as it should be.
01:45:16 <Twey> mm_freak_: I meant escapes like "%D" and "%m" in the formatTime string.
01:45:22 <mm_freak_> could be more flexible, yeah
01:47:28 <mm_freak_> type FormatTime t = t -> ShowS
01:48:43 <Twey> Mm, yes
01:52:35 <l4u> in vim, if I have syntastic do I still need ghcmod-vim?
01:53:07 <mm_freak_> i believe that format strings are demons from some ancient time, but apparently they're still among us
02:03:24 <bartavelle> l4u: ghcmod-vim gives you type inference, I find this valuable
02:04:26 <l4u> thanks bartavelle  i guess it's more than syntastic then
02:04:41 <ReinH> l4u: syntastic will use ghc-mod or hdevtools for syntax checking
02:04:49 <ReinH> by default
02:05:25 <ReinH> but you might be able to get it to just use :make and a ghc "compiler" (the vim concept)
02:06:40 <bartavelle> l4u : this is a visual demo of the type inference functionnality https://github.com/eagletmt/ghcmod-vim#ghcmodtype-ghcmodtypeclear
02:08:30 <l4u> that looks cool. I'm finding vim plugins for learning haskell.
02:19:44 <xintron> Which command-line option parser would you guys recommend?
02:24:25 <Feuerbach> xintron: optparse-applicative
02:26:50 <tomejaguar> xi
02:27:00 <tomejaguar> xintron: optparse-applicative too
02:27:56 <xintron> I guess it's settled then :)
02:28:00 <xintron> thanks
02:32:37 <aleksejs_> hi, is there any one-liner for lazy infinite pi number digits?
02:34:04 <awestroke> > pi
02:34:05 <lambdabot>  3.141592653589793
02:34:23 <aleksejs_> infinite
02:34:46 <awestroke> isn't 15 or so enough to calculate the circumference of the visible universe with <1meter error bound?
02:35:06 <awestroke> it was something like that
02:35:51 <aleksejs_> awestroke, I don't need pi, I need a lazy infinite list of pi number digits
02:35:57 <Cale> > let { g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) } in g(1,180,60,2)
02:35:58 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
02:36:07 <aleksejs_> Cale, thanks!
02:36:28 <awestroke> Cale: is that the real pi or an approximation?
02:36:31 <Cale> real
02:36:37 <Axman6> yeah I thought it was something like 40 places gives you enough accuracy to draw the circumference of the known universe without deviating by more than the thickness of an electron
02:37:02 <Cale> there's also...
02:37:39 <Cale> > let g(q,r,t,k,n,l) = if 4*q+r-t<n*t then n : g(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n,l) else g(q*k,(2*q+r)*l,t*l,k+1,div(q*(7*k+2)+r*l)(t*l),l+2) in g(1,0,1,1,3,3)
02:37:40 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
02:37:42 <Axman6> > pi :: CReal
02:37:43 <lambdabot>  3.1415926535897932384626433832795028841972
02:37:59 <awestroke> > pi :: IninitePrecisionFloat
02:38:00 <lambdabot>  Not in scope: type constructor or class `IninitePrecisionFloat'
02:38:09 <Cale> CReal is infinite precision
02:38:18 <Cale> > showCReal 100 pi
02:38:19 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
02:38:25 <Axman6> > showCReal 100 pi
02:38:26 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
02:38:29 <Axman6> heh
02:38:32 <aleksejs_> nice!
02:38:39 <Axman6> > last $ showCReal 1000 pi
02:38:40 <lambdabot>  '9'
02:38:45 <Axman6> > last $ showCReal 10000 pi
02:38:48 <lambdabot>  mueval-core: Time limit exceeded
02:38:57 <Cale> CReal is also pretty slow :/
02:39:09 <Axman6> yeah
02:39:12 <Axman6> how's it defined?
02:39:16 <Cale> I wonder how this will fare
02:39:17 <Cale> > let { g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) } in g(1,180,60,2) !! 10000
02:39:20 <awestroke> where can I find CReal? hoogle gives nothing
02:39:21 <lambdabot>  mueval-core: Time limit exceeded
02:39:31 <Axman6> @hoogle CReal
02:39:32 <lambdabot> No results found
02:39:33 <Cale> not much better anyway
02:39:35 <Axman6> huh
02:40:25 <shachaf> @google CReal haskell
02:40:25 <lambdabot> http://hackage.haskell.org/package/numbers-2009.8.9/docs/Data-Number-CReal.html
02:40:25 <lambdabot> Title: Data.Number.CReal
02:40:29 <Cale> btw, the paper I got that from: http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf
02:40:33 <shachaf> You can find it in the package called "numbers".
02:40:43 <Axman6> Cale: it's also in the language shootout
02:41:50 <Cale> There are some more readable versions in the paper
02:45:53 <merijn> Is there a nice explanation of why DatatypeContexts is bad that I can link to when trying to convince someone of that fact?
02:46:51 <Axman6> make
02:46:54 <Axman6> whoops
02:50:35 <Cale> merijn: The Haskell Report? ;)
02:52:31 <Cale> merijn: I'd think it would be kind of obvious once you understand that all that context does is to constrain the types of the constructors while not removing any responsibility to have those contexts on functions manipulating the data.
02:56:00 <merijn> Cale: Sure, but now I have to explain all that in a GitHub pull request
03:00:17 <pharaun> is there any good pointer for dimensional units? I believe i tried to do that before in haskell and found it a bit on the verbose side
03:12:31 <HugoDaniel> hi
03:12:37 <HugoDaniel> how can i pretty print aeson output ?
03:12:44 <Aetherspawn> pharaun: why would you want that
03:12:49 <Aetherspawn> for unit conversions?
03:13:08 <Taneb> mm_freak_, I'm trying to use netwire and I'm finding making something like (a -> m b) into Wire s e m a b trickier than I'd like
03:14:13 <pharaun> Aetherspawn: pretty much
03:14:29 <pharaun> Aetherspawn: i'll be doing a bunch of math/physics so would be neat to be able to tag/track the units
03:14:39 <Aetherspawn> maybe this helps
03:14:40 <Aetherspawn> https://hackage.haskell.org/package/units
03:14:43 <Taneb> @hackage aeson-pretty HugoDaniel
03:14:43 <lambdabot> http://hackage.haskell.org/package/aeson-pretty HugoDaniel
03:15:11 <pharaun> Aetherspawn: yeah i've looked at it before but it all felt a bit chunky when i had to pull in non-unital number but i'll give it another shot :)
03:15:53 <Aetherspawn> It recommends you read the README from the github repo rather than the haddock documentation
03:16:15 <pharaun> yeah i've poked at the readme :p
03:16:23 <pharaun> seems like its for ghc 7.8+ i think
03:16:30 <pharaun> hmm
03:16:55 <Aetherspawn> Dec 18 2013
03:17:00 <Aetherspawn> wouldn't be for the RC
03:17:21 <Aetherspawn> if it doesn't build on your GHC, chances are you might need 7.6, but I doubt that would be the case.
03:18:22 <pharaun> well
03:18:28 <pharaun> The Glorious Glasgow Haskell Compilation System, version 7.6.3
03:18:55 <pharaun> anyway hm 1.0.1 and 1.1 is for base 4.7 or newer, isn't that 7.8?
03:19:13 <Aetherspawn> yeah, and that's really wierd.
03:19:21 <Aetherspawn> weird*
03:19:59 <pharaun> > July 12, 2013: units-1.0.0 released. This package requires GHC HEAD.
03:20:00 <lambdabot>  <hint>:1:8: parse error on input `,'
03:21:00 <pharaun> looks like its a nice library from what i can see of the examples
03:51:18 * hackagebot hruby 0.2.5 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.5 (SimonMarechal)
03:55:41 <merijn> pharaun: Some of the nice type families stuff like closed families are only in 7.8, so I can see why they'd want to use 7.8 for a package like that
04:01:52 <nooodl> "No instance for (FromJSON (Map String Foo)) arising from a use of `Data.Yaml.decode'" -- but there's a FromJSON v => FromJSON (Map String v) instance! what gives?
04:02:07 <nooodl> i've defined the instance for Foo myself, of course
04:06:20 * hackagebot language-puppet 0.12.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.12.0 (SimonMarechal)
04:08:52 <shlevy> Is there a reason cabal init doesn't add a trailing newline to .cabal?
04:09:18 <hpc> because it was written that way ;)
04:09:28 <hpc> (i doubt there's a reason)
04:09:47 <shlevy> OK
04:09:51 * shlevy goes to write a PR
04:38:42 <xintron> Is there any way of making `read` case insensitive when reading a value constructor??
04:39:19 <xintron> so that (read "foo" :: Foo)
04:41:02 <lieven_> define your own read instance for Foo
04:42:33 <quicksilver> don't do that, though
04:42:35 <xintron> and then take the input, lowercase it and match?
04:42:41 <quicksilver> that's not what 'read' is for.
04:42:59 <quicksilver> if you want custom parsing write a simple parser and don't call it 'read'.
04:43:22 <xintron> I'm currently doing a string comparison and if matching (toLower) then I use the proper value constructor
04:43:39 <xintron> But it's becoming a large list :)
04:43:51 <xintron> (on the other hand I guess this will be more efficient)
04:44:03 <osa1_> in cabal sandbox, is there a way to load test program into "cabal repl"?
04:45:17 <bennofs> osa1_: cabal repl <name of test program>
04:46:22 <osa1_> bennofs: http://lpaste.net/99594
04:46:47 <bennofs> osa1_: run cabal configure --enable-tests before
04:46:49 <osa1_> bennofs: and I can't pass --enable-tests because it then says cabal: unrecognized option `--enable-tests'
04:47:07 <osa1_> bennofs: awesome. many thanks.
04:48:13 <supki> I like how suggestion to run cabal update and cabal configure --enable-tests differ in formatting
04:48:24 <supki> much consistent, wow
04:52:56 <osa1_> how to randomly generate n numbers in range [n..m] ?
04:53:21 <Axman6> :t randomRs
04:53:22 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
04:53:48 <Axman6> > randomRs (newStdGen 12874) (5,10) :: [Int]
04:53:49 <lambdabot>  Couldn't match expected type `a0 -> (GHC.Types.Int, GHC.Types.Int)'
04:53:49 <lambdabot>              with actual type `GHC.Types.IO System.Random.StdGen'
04:53:51 <osa1_> which library has that?
04:53:57 <Axman6> > randomRs (stdGen 12874) (5,10) :: [Int]
04:53:58 <lambdabot>  Not in scope: `stdGen'
04:54:14 <Axman6> > randomRs (5,10) (newStdGen 12874) :: [Int]
04:54:15 <lambdabot>  Couldn't match expected type `a0 -> g0'
04:54:15 <lambdabot>              with actual type `GHC.Types.IO System.Random.StdGen'
04:54:29 <Axman6> bleh, anyway, it's in the Random library, it comes with GHC
04:54:35 <Axman6> @hoogle randomRs
04:54:35 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
04:54:40 <osa1_> okay thanks.
04:55:46 <osa1_> what's a good way to generate a StdGen?
04:55:53 <merijn> :t newStdGen
04:55:54 <lambdabot> IO StdGen
04:55:59 <merijn> :p
04:56:02 <merijn> :t makeStdGen
04:56:03 <lambdabot>     Not in scope: `makeStdGen'
04:56:03 <lambdabot>     Perhaps you meant `mkStdGen' (imported from System.Random)
04:56:10 <merijn> :t mkStdGen
04:56:11 <lambdabot> Int -> StdGen
04:56:25 <osa1_> which one?
04:56:55 <osa1_> what is seed of newStdGen?
04:56:58 <merijn> osa1_: Either, depending on what you want
04:57:11 <quicksilver> newStdGen picks a random seed using some OS-provide randomness source
04:57:11 <merijn> osa1_: I think newStdGen either uses a random syscall or the RTS global seed as seed
04:57:23 <quicksilver> mkStdGen you choose a seed
04:57:26 <osa1_> okay, that should be good enough for me.
04:57:28 <quicksilver> which is useful if you want something reproducible
04:57:32 <quicksilver> normally, newStdGen
04:57:42 <osa1_> thanks.
04:57:43 <merijn> If you want to have repeatable randomness, mkStdGen, if you just want "random" newStdGen
04:58:03 <merijn> If you want crypto random, don't write crypto code! :p
05:00:38 <osa1_> um, Random library is in haskell98, right?
05:01:17 <merijn> Why does pandoc-citeproc take literally ages to compile? :\
05:02:59 <osa1_> using haskell98 as a dependency make prelude module ambiguous ...
05:03:04 <osa1_> is there a similar module in Base?
05:03:10 <osa1_> (similar to Random in haskell98)
05:03:17 <quicksilver> yes, it's called System.Random
05:03:20 <quicksilver> don't use haskell98
05:03:21 <Axman6> you need System.Random I believe
05:03:24 <osa1_> ahh
05:03:34 <osa1_> why it's not here http://www.haskell.org/ghc/docs/latest/html/libraries/
05:03:48 <merijn> There's a 1100 line module in pandoc-citeproc and it's literally taking >1 hour to compile that one module, that can't be right...
05:03:58 <merijn> (This one: https://github.com/jgm/pandoc-citeproc/blob/master/src/Text/CSL/Input/Bibtex.hs)
05:04:23 <quicksilver> osa1_: because it's not in base any more
05:04:27 <quicksilver> osa1_: http://hackage.haskell.org/package/random-1.0.1.1
05:04:35 <merijn> Not to mention, it's running my machine performance into the ground :\
05:04:38 <quicksilver> osa1_: they tried to cut base down a bit
05:04:44 <quicksilver> merijn: sounds like a GHC bug to me.
05:05:10 <bennofs> merijn: it's not even using TH
05:05:21 <quicksilver> it has some very big records and case statements
05:05:45 <merijn> quicksilver: Actually, last night GHC stack overflowed while trying to build the profiled version :\
05:06:36 <quicksilver> I think random still comes with ghc, though
05:06:47 <shlevy> Hi. Using Safe Haskell	None
05:06:48 <quicksilver> I'm not sure how to get an authoritative list of what packages come with ghc.
05:06:50 <shlevy> whoops
05:07:05 <quicksilver> I don't know why its docs wouldn't be at http://www.haskell.org/ghc/docs/latest/html/libraries/
05:07:39 <shlevy> Using Network.Wai.Middleware.RequestLogger.logStdoutDev, somehow writes to 1 are failing with EPIPE when piping into cat
05:08:29 <shlevy> I've checked strace and the only other syscall to 1 that I can see is a TCGETS ioctl
05:08:37 <shlevy> Which shouldn't somehow close the other side of the pipe
05:08:43 <shlevy> Any ideas?
05:09:26 <shlevy> Ah and a select
05:18:22 <osa1_> liftM B.pack $ readFile file fails with exception ("invalid utf-8 stream") but B.readFile works ... (where B is ByteString)
05:20:14 <Hafydd> Sounds right to me.
05:22:02 <osa1_> Hafydd: why is this happening?
05:22:30 <luite> osa1_: a normal readFile reads a text stream, decodes according to the current locale
05:22:53 <Hafydd> Yes. readFile tries to construct a Unicode string, but B.readFile just reads some bytes.
05:25:19 <Twey> pharaun: Henning Thielemann's NumericPrelude includes dimensioned quantities, amongst other things
05:36:30 * hackagebot Binpack 0.4.1 - Common bin-packing heuristics.  http://hackage.haskell.org/package/Binpack-0.4.1 (DavidFeng)
05:46:31 * hackagebot linux-inotify 0.2.0.1 - Thinner binding to the Linux Kernel's inotify interface  http://hackage.haskell.org/package/linux-inotify-0.2.0.1 (LeonSmith)
06:09:47 <makalu> I have a function with multiple arguments. Some of them come from IO, some are pure. Can I use Applicative with mixed pure/Applicative arguments?
06:10:59 <ion> foo <$> (bar :: IO a) <*> pure (baz :: b)
06:11:02 <ion> or
06:11:15 <ion> (\bar' -> foo bar' baz) <$> (bar :: IO a)
06:11:23 <ion> or
06:12:14 <ion> Actually, this was not good advice because i bet foo :: something -> IO c.
06:12:17 <makalu> I thought of your first two suggestions but thought that maybe there was an operator.
06:12:31 <ion> do { b <- bar :: IO a; foo b baz }
06:13:02 <ion> Given the latter type for foo, you would have needed a “join” around the first two alternatives.
06:13:41 <makalu> no my function was pure
06:13:46 <makalu> but thank you
06:39:10 <xintron> Where should I start when I want to look at profiling my code?
06:43:44 <pjdelport> xintron: Have you looked at http://book.realworldhaskell.org/read/profiling-and-optimization.html and http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program ?
06:43:55 <pjdelport> Those should provide some starting points
06:44:37 <xintron> pjdelport, going through realworldhaskell as I asked this but feels like some stuff in there is often outdated (hence my question about new "tools") :)
06:50:58 <exicer> Anyone know of a library that will allow me to resize images ?
06:55:38 <finster> exicer: not a library, but the convert program of imagemagick can do this
06:58:36 <fizbin> exicer: finster's answer also implicitly points at http://hackage.haskell.org/package/imagemagick
07:00:07 <Skyraven> hello guys :) I'm pretty new (since a few hours) to Haskell...and just needed it for some office/work reporting..so I'm pretty much a newbie in it (and a dummie)
07:00:23 <Skyraven> I have a simple function
07:00:24 <Skyraven> triples n hours xfac yfac zfac sumfac = [(x,y,z,xfac*x*13.5 + yfac*y*13.5 + zfac*z*13.5,sumfac) | x <- [1..n],       	      	     y <- [1..n], 		     z <- [1..n], 		     xfac*x*13.5 + yfac*y*13.5 + zfac*z*13.5 <= sumfac, 		     x + y + z == n]
07:00:32 <Skyraven> is there any way that I can just put a newline
07:00:36 <Skyraven> between each (x,y,z....) output ?
07:00:42 <Skyraven> instead of having it all on one row ?
07:00:50 <Skyraven> sorry for asking such a beginner question
07:03:20 <td123> Skyraven: mapM_ print [(1,2),(3,4)]
07:03:26 <td123> >mapM_ print [(1,2),(3,4)]
07:03:35 <td123> > mapM_ print [(1,2),(3,4)]
07:03:36 <lambdabot>  <IO ()>
07:03:43 <td123> :)
07:04:14 <dhrosa> I think he means that he wants newlines in his source code
07:04:27 <exicer> fizbin: Thanks, will check it out.
07:05:21 <td123> oh like (x, "\n", y, "\n", ...)?
07:05:41 <dhrosa> no, as in his function definition is really long and on one line
07:05:51 <td123> oh..
07:06:25 <Skyraven> td123: I'm afraid I terribly suck at this :( I tried to add in my function mapM print [(x,y,z,xfac*... , sumfac] | x <- [1..n],... but seems I got the wrong syntax
07:06:32 <Skyraven> pff googling now
07:06:59 <dhrosa> wait, what did you  actually mean Skyraven ?
07:07:18 <dhrosa> you wanted a newline in the output between each element, or did you want to break up your source function over multiple lines?
07:09:18 <Skyraven> dhrosa: I have this defined http://pastebin.com/CsMHDdQ3  which I call by hand
07:09:27 <Skyraven> well without the mapM print in it, it works
07:09:48 <Skyraven> I just want the (x,y,z...) output to be printed with newlines each time (each pair of values, then newline, then the next pair)
07:10:30 <dhrosa>  ohhh
07:10:33 <dhrosa> oops
07:11:10 <td123> Skyraven: you should mapM_ print the return of triples
07:11:21 <td123> Skyraven: so mapM_ print (triples ..)
07:12:10 <Rarrikins> Skyraven: printLn :: Show a => a -> IO (); printLn = putStrLn . show
07:13:16 <Skyraven> td123: thanks, trying now; p.s. what would be a good start page for the Haskell stuff if I wanted to at least learn things in a more structured  way ? Now I just needed a quick and dirty solution and this was by far the fastest when compared to the alternatives
07:15:36 <td123> Skyraven: I would go with reading learn you a haskell which is free on the internet
07:16:31 <Skyraven> td123: ok, will do that :) thanks for the tip and for the help !
07:17:25 <td123> Rarrikins: print is defined the same way as your function :)
07:17:39 <Rarrikins> Oh
07:18:31 <merijn> Well, that's 2 of the 4 vim tag solutions I can discount :\ lushtags only generates tags for the current file and hothasktags jumps to the wrong location :\
07:18:43 <TheBrayn> emacs! :P
07:19:43 <merijn> TheBrayn: And you have a confirmed working way to get tags working properly in emacs?
07:27:22 <justinleitgeb> Hey folks. Is the 'time' package the best thing to use right now for simple time parsing? Also, why would the new time package still depend on old-locale? http://beta.hackage.haskell.org/package/time
07:27:49 <dcoutts> justinleitgeb: yes
07:28:09 <geekosaur> because someone made a mistake back when the old time package was moved to old-time
07:28:14 <dcoutts> justinleitgeb: because though the plan was for there to be a new local lib, none got written
07:28:25 <geekosaur> and fixing it at this point means a pointless midification required to hundreds of packages
07:28:43 <dcoutts> and perhaps someone will step up and write a better one, like they did for time
07:29:16 <justinleitgeb> Thanks very much for the explanation!
07:36:44 * hackagebot strict-base-types 0.2.3 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.2.3 (SimonMeier)
08:01:46 * hackagebot tamarin-prover 0.8.5.1 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.5.1 (SimonMeier)
08:01:48 * hackagebot tamarin-prover-utils 0.8.5.1 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.8.5.1 (SimonMeier)
08:01:50 * hackagebot tamarin-prover-term 0.8.5.1 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.8.5.1 (SimonMeier)
08:06:48 * hackagebot tamarin-prover-theory 0.8.5.1 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-theory-0.8.5.1 (SimonMeier)
08:18:40 <saml> how can I peel off Maybe?
08:19:08 <bartavelle> saml : the simplest was is a pattern matching, with a case statement
08:19:16 <saml>  Maybe (Maybe String, Maybe String) ->  (String, String)      with default string is ""
08:19:52 <sm> xintron: the GHC manual is a good up to date starting point
08:20:13 <saml> case Nothing -> ("", ""); case Just (a, b) -> (a or "", b or "")
08:20:26 <sm> xintron: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
08:20:27 <adnam> saml: there are several helpers for this in Data.Maybe: maybe, fromMaybe are probably most interesting for you
08:20:43 <saml> where (Just x) or default = x;   None or default = default
08:20:49 <saml> thanks
08:31:31 <benj_> > bimap fold fold . fold $ Just (Just "foo", Nothing) :: (String, String)
08:31:33 <lambdabot>  ("foo","")
08:32:39 <dhrosa> why does calling Fold on a Nothing return ""?
08:32:42 <dhrosa> fold*
08:32:47 <dhrosa> oh wait
08:32:51 <dhrosa> i'm thinking of join
08:32:56 <dhrosa> that's why I'm confused
08:33:15 <dhrosa> :t fold
08:33:16 <lambdabot> (Foldable t, Monoid m) => t m -> m
08:41:52 * hackagebot smallcaps 0.4.0.1 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.4.0.1 (StefanBerthold)
08:42:32 <merijn> If I have profiling enabled globally, how do I temporarily override it to not build profiling libs for one package?
08:43:24 <bennofs> merijn: cabal install <packages> --disable-profiling?
08:43:54 <merijn> bennofs: That's not actually an existing option
08:44:17 <bennofs> merijn: it isn't? --disable-library-profiling then
08:45:22 <merijn> Ah, that seems to work
08:51:53 * hackagebot fixed-vector 0.6.2.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.2.0 (AlexeyKhudyakov)
09:06:34 <navaati> hi
09:07:08 <navaati> i'm trying to test ghc 7.8 (on gentoo linux), and i've got a problem with cabal install
09:07:08 <tantalum> Hey
09:08:32 <Ankhers> What is the problem?
09:08:40 <navaati> last version requires array >=0.1 && <0.5 and thus is incompatible with ghc 7.8 (a lot of packages suffer from this)
09:08:40 <Ankhers> navaati: ^
09:09:08 <navaati> Ankhers: (another problem is me writing slowly, it seems :)
09:10:06 <navaati> and cabal-install from git requires cabal-1.19, which is unreleased
09:10:48 <navaati> so... who on this chan is maintener for cabal-install ? i think we need a minor release here
09:11:08 <enthropy> dcoutts
09:11:45 <navaati> enthropy: thanks. well, waiting for pong :)
09:11:56 <enthropy> chances are that he knows about the issue already (and maybe wants to fix other things before releasing?)
09:12:11 <navaati> actually, yeah
09:13:04 <dfmr> Is there much of a consensus on what error handling mechanism to use for libraries these days? I've read several articles, including http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/ , but would appreciate a bit of contemporary commentary.
09:16:00 <enthropy> dfmr: also take a look at http://hackage.haskell.org/package/monad-control or http://hackage.haskell.org/package/exceptions
09:16:49 <enthropy> since an issue that doesn't seem to be discussed in ezyang's article is that sometimes you mix exceptions and monad transformers
09:17:22 <ocharles> RAGH. Yet again I am wanting a Semigroup v => Monoid (HashMap k v) instance >.<
09:19:10 <dfmr> enthropy: let me ask a slightly-different question. Which of the 5 or so plausible options (given the two you just mentioned) are most actively being used these days? Are libraries converging on one or two of the approaches? I'm playing around with writing a small app, some of which is quite library-like, and I'd rather not just use error/fail (both seem like bad options) on one hand, or tear up the error handling several times on the o
09:19:10 <dfmr> ther hand.
09:21:19 <enthropy> dfmr: they aren't mutually exclusive though. error is just fine for cases you cannot sensibly recover from
09:22:39 <enthropy> I don't have any stats saying which is most popular
09:22:52 <enthropy> http://hackage.haskell.org/package/hslogger might also be worth looking into
09:23:16 <dfmr> they're not mutually exclusive, but all the code that works with things which call error vs checked exceptions vs a stack of monad transformers will look fairly different
09:24:04 <Twey> dfmr: There are different kinds of ‘error’, and they bear handling in different ways
09:24:50 <dfmr> Twey: yes, but probably not this many different ways
09:25:30 <Twey> dfmr: Oh, many more, I think :þ
09:25:36 <quicksilver> in general if I was writing a library, I would use the "Left error" or "Right value" approach
09:25:47 <quicksilver> I might use a monad internally but at the API boundaries I'd just do that
09:25:49 <dfmr> some approaches are just poor in most contexts, some could be badly implemented, etc - hence wanting to know what people are using in practice in haskell these days
09:25:58 <quicksilver> unless my library had an inherently monadic interface
09:25:58 <dfmr> quicksilver: ok - why? :-)
09:26:06 <quicksilver> because that's universal.
09:26:32 <quicksilver> as you correctly point out, fail/error is bad because it's not reliably catchable, and your user doesn't want uncatchable errors from deep in the library
09:26:47 <quicksilver> so if you are giong to somehow return errors then a simple Left/Right is a universal interface
09:26:49 <dfmr> http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/ specifically claims Either is also a bad approach
09:27:06 <quicksilver> your caller can easily embed that in whatever he is using himself.
09:27:09 * dfmr wonders where the difference in opinion comes from
09:27:14 <Twey> I'd choose the Either by default too, but exceptions are nice for truly exceptional cases where you're already in IO, and error is good for can't-happen error reporting in pure code
09:27:34 <quicksilver> dfmr: no, he doesn't.
09:27:40 <Twey> And sometimes your error report is so trivial that there's no point using Either, and you might as well just return a Maybe
09:27:48 <quicksilver> dfmr: he specifically claims "Either String" is a bad approach
09:27:51 <quicksilver> that's quite a different claim
09:27:55 <quicksilver> his beef is with the String
09:27:57 <quicksilver> not the Either
09:28:07 <dfmr> quicksilver: ah. Good point
09:30:18 <dfmr> I'll give Either enum a a go for now
09:32:38 <bartavelle> navaati, I built latest cabal-install on ghc 7.8 rc1 without problem
09:33:00 <tac> "No reason to use this, it’s around for hysterical raisins.
09:33:00 <tac> "
09:33:41 <bartavelle> navaati, isn't it complaining about the fact that *other* packages are going to be broken ?
09:35:14 <navaati> bartavelle: no no, it asks for array <0.5. the commit fixing this is https://github.com/haskell/cabal/commit/4a5cf2c7600ac6534243ac6cea7855d687ea314a
09:35:25 <tac> > fail
09:35:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable1 m0)
09:35:27 <lambdabot>    arising from a use of `M13098847361145138803482.show_M13098847361145138803...
09:35:27 <lambdabot>  The type variable `m0' is ambiguous
09:35:27 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:35:27 <lambdabot>  Note: there are several potential instances:
09:35:52 <navaati> which happened after cabal v1.18.0.2
09:35:58 <geekosaur> that looks kinda fail, all right >.>
09:36:06 <navaati> bartavelle: which version do you have ?
09:36:21 <bartavelle> Cabal 1.18.1.3  - cabal-install version 1.18.0.2
09:36:41 * bartavelle wonders if it's not a cabal-install built with ghc 7.6.3
09:36:54 <navaati> bartavelle: 1.18.1.3 is not even on hackage
09:37:46 <bartavelle> strange indeed, I must have grabbed it :/ I had to tweak so many packages I must have forgot about this
09:37:48 <bartavelle> strange though
09:38:08 <bartavelle> no it comes with ghc
09:38:13 <bartavelle> » ghc-pkg list Cabal
09:38:13 <bartavelle> /usr/local/lib/ghc-7.8.20140130/package.conf.d
09:38:13 <bartavelle>    Cabal-1.18.1.3
09:38:24 <navaati> unreleased, then
09:38:30 <bartavelle> yes, but it's in the rc
09:38:51 <bartavelle> and indeed I can't build cabal-install !
09:38:56 <bartavelle> sorry for the noise
09:39:05 <navaati> still, Cabal alone is not enough, i need the new cabal-install. i'll install from git a7e41b3d61e9dd55b0cf1ff74f738028988c9ee4
09:39:53 <navaati> (oh gentoo wonders, i can select a commit in my package manager)
09:40:08 <navaati> aaaaand, it works
09:40:44 <`^_^v> @hoogle (a, a) -> Bool -> a
09:40:45 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
09:40:45 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
09:40:45 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
09:42:18 <SpecialK> does anyone know a good library for defining a series of config options that can be defined in a file and/or overridden on the command line?
09:43:16 <bartavelle> SpecialK, http://hackage.haskell.org/package/configurator, but it doesn't have command line support
09:43:19 <bartavelle> it has reloading though
09:44:11 <SpecialK> bartavelle: mmm, not what I'm after but thanks
09:45:28 <navaati> bartavelle: just to verify, your cabal-install was the old one from the 7.6 era right ?
09:47:58 <sm> http://hackage.haskell.org/packages/#cat:Configuration , also search for ini
09:55:27 <zipper> When we say that this is now eq is defines for example:
09:55:43 <zipper> x == y = not (x /= y); x /= y = not (x == y)
09:55:56 <adelbertc> need help with installing packages for testing in cabal (sandboxed) project, seem to be having dependency conflicts? http://lpaste.net/6814778935880974336
09:56:35 <dcoutts> adelbertc: looks ok to me
09:57:07 <tac> zipper: was there a question in there? :)
09:57:10 <zipper> I don't get how  not (x /= y) means not equal
09:57:25 <tac> it doesn't mean that
09:57:27 <ion> x /= y means not equal
09:57:31 <tac> x /= y = not (x == y)
09:57:35 <ion> not (not equal) means equal
09:57:52 <dcoutts> adelbertc: those packages listed at the end will be unusable from within the sandbox, but that's ok if you're not using them (which you're not or it'd complain about conflicts)
09:57:53 <tac> we define the function (/=) to mean "not . (==)"
09:58:04 <zipper> but right under that we define /= as not (==)
09:58:10 <ion> I don’t think it’s defined as not . (==)
09:58:17 <tac> zipper: ah yeah
09:58:19 <tac> ion: oops, you're right
09:58:26 <zipper> So it will check what not (/=) is and end up with not(==)
09:58:28 <tac> zipper: The idea is that you can define one, and the other comes "for free"
09:58:33 <zipper> Looks endless loopy to me
09:58:34 <adelbertc> dcoutts - should i try a force-reinstall?
09:58:41 <dcoutts> adelbertc: yes
09:58:47 <tac> zipper: But you need to give a definition for one or the other, otherwise, yes, it gets stuck in a loop
09:59:04 <dcoutts> adelbertc: your sandbox env consists of the global packagedb + a local one. The things you're installing in the local one will mean those few packages from the global db will be unusable within the sandbox, but that is ok.
09:59:26 <dcoutts> adelbertc: and in particular, it will not affect the global db, user db or other sandboxes
09:59:27 <adelbertc> dcoutts - ah makes sense, got it.
09:59:47 <zipper> tac: ion uh in this http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
09:59:50 <adelbertc> do i need to do cabal configure --enable-tests first? it seems to be asking me to add -any to the end but i notice some people dont do that
10:00:09 <zipper> tac: ion Look at how they say eq is implemented
10:00:34 <tac> zipper: http://lpaste.net/99602
10:00:41 <dcoutts> adelbertc: the -any is not needed. So you just say: cabal install --enable-tests --only-dependencies --force-reinstalls [--dry-run]
10:00:43 <ion> zipper: yes
10:00:57 <adelbertc> dcoutts - coolio, cheers
10:01:04 <dcoutts> adelbertc: and then you can cabal configure --enable-tests
10:01:04 <platz> tac: is there a way to enforce at least one from a set of default functions from an instance be re-implemented?
10:01:08 <tac> zipper: Those are default definitions. If you _don't_ give a definition for one of the methods, it defaults to that one
10:01:18 <tac> platz: Not in Haskell, no
10:01:24 <adelbertc> dcoutts - will do, thanks!
10:01:35 <platz> read the docs ;)
10:01:37 <tac> platz: There is also no way to enforce the "laws" often associated with typeclasses (the Monoid laws, for instance)
10:01:56 <tac> zipper: That code I linked to above will get stuck in a loop
10:02:31 <zipper> tac: So this is what is in LYAH https://gist.github.com/urbanslug/8868098
10:02:42 <platz> tac: yeah, i knew that was the case with laws.  btw what do you call "re-defining", overridding?
10:02:51 <tac> zipper: Yes. That's how Eq (the class) is defined
10:03:01 <zipper> I don't quite get what you mean by "If you _don't_ give  a definition for one of the methods, it defaults to that  one"
10:03:08 <tac> zipper: It's also here: http://www.haskell.org/onlinereport/standard-prelude.html
10:03:18 <tac> or not... whoops, nvm
10:03:34 <ion> zipper: Instance definitions can override the defaults in the class definition.
10:03:35 <tac> platz: You could call it overriding. I don't think there's a name for it, though.
10:03:42 <tac> You are just giving a definition for that instance
10:04:22 <zipper> So when I derive eq and say `x /= y = false' I have overidden the defaults?
10:04:23 <`^_^v> is there any facility for a haskell code review? i have a fairly simple <200 loc program that is probably bad
10:05:05 <silasm> zipper: yes, although that particular definition only really makes sense for ()
10:05:11 <ski> zipper : s/derive/make an instance for/
10:05:36 <silasm> zipper: and the other definition (for ==) stays the same, but now has a different meaning since (/=) has a different meaning
10:05:45 <tac> zipper: In an ideal world, Eq would _only_ contain (==)
10:06:14 <tac> But the reason (/=) is included is that (theoretically, I guess?) sometimes it's easier to define when things are unequal
10:08:08 <zipper> I'll read more on it. Right now I am confused.
10:08:39 <platz> lyah uses the term "overwrite"
10:08:41 <tac> zipper: I'd say -- don't worry about it :)
10:09:07 <tac> zipper: When you define Eq instances for your types, you usually end up using "deriving Eq" anyway
10:09:43 <zipper> tac: I'd feel better and be more confident if I understood it.
10:09:56 <tac> It will become obvious in time
10:10:04 <tac> You will feel embarrassed for dwelling on it :)
10:10:20 <zipper> tac: lol
10:10:46 <tac> You can think of it like this: Every instance of Eq NEEDS to override either (==) or (/=) or both
10:10:51 <tac> Otherwise, it's broken
10:11:22 <zipper> Ah I seee it now
10:11:36 <zipper> Every instance of eq overrides it
10:11:38 <bizarrefish> Hi all
10:12:04 <tac> yes
10:12:11 <tac> That's why you have methods. So you can give a meaningful meaning to them :)
10:12:16 <zipper> So every instance makes a new function with type signature (==) :: a -> a -> Bool
10:12:16 <joneshf-laptop> hmm, is there some concise way to combine two applicatives? like if I wanted to the non-determinism of a list applied to maybe? i.e. pure (+) <*> [1,2,3] <*> Just 1 -- [2,3,4]
10:12:32 <joneshf-laptop> or do i have to transform them to the same applicative?
10:12:34 <tac> zipper: Right. But those a's are "fixed"
10:12:42 <ion> joneshf-laptop: <*> maybeToList (Just 1)
10:12:43 <zipper> tac: but as it is defined in Prelude it is an endless loop.
10:12:51 <zipper> tac: Yeah yeah
10:12:52 <tac> So if you wrote a type Foo, you have "instance Eq Foo where .... "
10:12:59 <tac> and you have to define (==) : Foo -> Fool -> Bool
10:13:00 <joneshf-laptop> ion, is there a more general way?
10:13:04 <tac> (not a -> a -> Bool, see?)
10:13:44 <platz> you'd think it wouldn't be so hard to the compiler to enforce that an instance provides such a method, but perhaps this is more a special case an in full generality it would be hard to formulate
10:13:50 <adelbertc> ok, now having issues with building my cabal project in the presence of tests? more info: http://lpaste.net/1380069560249483264
10:13:54 <zipper> tac: I believe I do.
10:14:05 <zipper> tac: Glad I asked.
10:15:14 <joneshf-laptop> hmm, i guess you couldn't really do it huh?
10:15:15 <dfmr> What testing packages are widely used and play nicely with cabal these days?
10:15:24 <dcoutts> adelbertc: your file name does not match the module name
10:15:28 <joneshf-laptop> how woudl yo uknow which applicative to use
10:15:46 <bizarrefish> I'm getting acquainted with haskell, and was wondering what it would take for the following code to work: http://lpaste.net/99603. I'm familiar with the Coroutine monad whose Yield has a continuation which returns a coroutine of identical type (forcing you to make all yieldables part of one sum type, and all returnables part of another, which seems unsatisfactory to me)
10:16:00 <adelbertc> dcoutts - so i have to rename FooSuite.hs to Main.hs? or can i also rename Main to FooSuite
10:16:02 <dcoutts> adelbertc: ghc is looking for the module Foo.Bar.BazSuite and so looks at the file test/Foo/Bar/Baz.hs, but you called it something else
10:16:21 <dcoutts> adelbertc: erm, sorry, other way around
10:16:21 <adelbertc> oh so the fiel has the match the module
10:16:48 <dcoutts> adelbertc: ghc is looking for the module Foo.Bar.BazSuite and so looks for the file test/Foo/Bar/BazSuite.hs, but you called it test/Foo/Bar/Baz.hs
10:17:16 <adelbertc> dcoutts - aha there you go, thanks again :-)
10:17:47 <dcoutts> adelbertc: test/FooSuite.hs is allowed to be called that rather thain test/Main.hs, but only because nothing imports it (so ghc never has to look for it)
10:20:18 <adelbertc> dcoutts - got it
10:21:48 <pharaun> Twey: thanks :) (re numeric-prelude)
10:48:22 <TallerGhostWalt> if I have a list of records of type Address
10:48:51 <TallerGhostWalt> and I want to use template haskell to generate the names of the list and also a list of the records
10:48:59 <TallerGhostWalt> how do I do that?
10:49:18 <zipper> The sound in this talk makes me strain too much to hear what he is saying :( http://www.youtube.com/watch?v=Dn74rhQrKeQ
10:49:26 <zipper>  Faster persistent data structures through hashing - Johan Tibell
10:49:48 * zipper out!
10:50:56 <TallerGhostWalt> like if I have a :: Address , b :: Address and I want to generate addressList = [a,b] and addressNames = ["a","b"]
11:03:18 <pankajmore> ;s
11:09:17 <codygman_> A friend of mine mentioned something about ghc linking in integer-gmp being horrible for performance. However he's quite biased and would use C all the time if he could. I'm just wondering if there is any truth to that statement or alternatively under what conditions there is truth.
11:10:03 <codygman_> Should I ask this in numerical haskell?
11:13:35 <predator117> codygman_: http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/integer_pt1.html might be of interest
11:14:22 <obiwahn> hoogle-4.2.28 depends on haskell-src-exts-1.14.0.1 which failed to install.
11:14:27 <obiwahn> where do i find that?
11:15:53 <maxiepoo_> wow is it just me or is CmdArgs completely opaque ?
11:16:25 <predator117> obiwahn: what is the error during install?
11:16:47 <obiwahn> yes - i missed happy
11:33:55 <obiwahn> http://paste.debian.net/80702/
11:38:18 <erisco> I want to be able to feed in an HTML document (well-formed) and get back a parse tree. What package is ideal for this?
11:38:50 <Yaniel> HTML or is XHTML okay?
11:39:38 <erisco> hmm... what significant differences am I facing there?
11:40:13 <monochrom> HXT does both HTML and XHTML
11:40:37 <monochrom> I don't know what is ideal for you. it is ideal for me.
11:41:05 <erisco> String -> ParseTree is as sophisticated as I need
11:41:21 <dhrosa> @pl return . f
11:41:21 <lambdabot> return . f
11:41:53 <monochrom> you probably mean: @pl (\return -> return . f), which is (. f)
11:44:02 <monochrom> obiwahn: interesting, I can't reproduce the problem here. Data.Aeson.Types.Internal compiles fine. it's just GHC 7.6.3 here. I can't reproduce the problem.
11:44:38 <obiwahn> ghc-7.4.1
11:45:49 <obiwahn> it was on 386 machine and now it is on 64 i hoped that i can just cabal install all the stuff ... i remeber that it was some work to make the bot run
11:46:08 <obiwahn> especially because i am not good in writing haskell :)
11:46:48 <monochrom> perhaps you should switch to 7.6.3
11:48:20 <obiwahn> would that make things easier?
11:48:26 <monochrom> yes
11:48:30 <obiwahn> i would need to build it ...
11:48:39 <obiwahn> well ok.)
11:48:41 <monochrom> no
11:48:45 <obiwahn> no?
11:49:00 <monochrom> no
11:49:06 <geekosaur> there's a generic binary distribution
11:49:16 <geekosaur> for linux
11:49:48 <geekosaur> uyou haven't said what platform though, so maybe not relevant (there is also a generic win32 and win32-64bit though)
11:50:15 <monochrom> for almost all platforms there are already binaries.
11:50:25 <Yaniel> erisco: well XHTML is HTML written as XML
11:50:29 <obiwahn> nice
11:51:40 <monochrom> xhtml requires "<p>hello</p>" (the </p> is optional in html), "<br/>", and "<meta ... />"
11:51:42 <obiwahn> :) a bit apt pinning and i get it from unstable:)
11:55:42 <shlevy> Is there no way to tell haskell "No, really, distribute all the files in this directory as data files"?
11:55:46 <shlevy> s/haskell/cabal
11:56:22 <codygman_> predator117: Thanks for that. I remember passing by this, i wish there were some updates on progress, though it's a very large project :P
11:59:02 <AndChat|271284> Hello
11:59:57 <AndChat|271284> Does anybody knows of any good online courses to learn Haskell ?
12:00:25 <rusk> Hey guys
12:00:27 <dfmr> AndChat|271284: maybe "learn you a haskell for great good" - learnyouahaskell.com/‎
12:00:55 <AndChat|271284> Thanks i will check it.
12:01:33 <AndChat|271284> I am just a newbie struggling to learn Haskell.
12:01:48 <AndChat|271284> My background is strictly OO
12:01:52 <rusk> whats wrong with this code. let divAlg a b = if a < b then (0,a) else let (q,r) = divAlg (a-b,b) in (q+1,r)
12:02:15 <monochrom> is it wrong?
12:02:30 <codygman_> AndChat|271284: I just randomly came across this and it looks to be quality: https://github.com/tonymorris/course    However, I'd recommend LYAH followed by RWH, a toy project, and reading typeclassopedia.
12:02:45 <rusk> its a basic division algorithm.. i just started learning haskell
12:03:32 <AndChat|271284> Thank you so much !!! Highly appreciated.
12:04:00 <monochrom> ok, replace "divAlg (a-b, b)" by "divAlg (a-b) b"
12:04:50 <rusk> YOU ARE AMAZING. THANK YOu
12:04:53 <rusk> so simple too
12:05:05 <rusk> gosh... can't believe i didnt see that
12:05:13 <monochrom> no, the computer is amazing, it tells me an error message
12:05:45 <rusk> gotcha. the expected type V the actual type
12:11:55 <rusk> @MONOCHROM how would you write that code using | symbol and otherwise
12:11:55 <lambdabot> Unknown command, try @list
12:12:16 * hackagebot HTF 0.11.2 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.2 (StefanWehr)
12:13:02 <monochrom> I would, but not religious about it
12:13:22 <monochrom> every code I understand is good code
12:14:03 <dmwit> I don't think "yes" is an appropriate answer to a "how" question.
12:14:27 * dmwit . o O ( "How do you spell 'yes'?" )
12:14:40 <Hafydd> Say "otherwise" instead of "Yes".
12:14:59 <rusk> would it be something like this let divAlg a b = a b | a < b = (0,a) | otherwise = let (q,r) = divAlg (a-b) b in (q+1,r)
12:15:27 <dmwit> divAlg a b | a < b = (0, a) | otherwise = let (q, r) = ... in ...
12:15:39 <benmachine> i.e. yes
12:15:49 <rusk> thanks
12:15:58 <benmachine> optionally, you could also write
12:16:20 <benmachine> divAlg a b | a < b = (0, a) | otherwise = (q + 1, r) where (q,r) = divAlg (a - b) b
12:16:43 <monochrom> oh oops, I misread
12:17:21 <obiwahn> configure: error: readline not found, so this package cannot be built
12:17:29 <obiwahn> is the c readline missing
12:17:34 <erisco> wow much impress. there is already a hackage library for dealing with typescript sources. thanks Mr. Freeman
12:17:45 <obiwahn> or is cabal talking about haskell readline
12:17:55 <monochrom> yes, likely the c readline is missing
12:18:01 <geekosaur> install the dev packagew
12:18:07 <triliyn> The haskell readline is called haskeline I think
12:18:07 <geekosaur> the runtime package is not sufficient
12:18:31 <monochrom> a haskell lib missing leads to a very different error message
12:19:46 <obiwahn> how do you remove a package form .ghc?
12:19:58 <monochrom> look into ghc-pkg
12:20:15 <monochrom> GHC also has a user's guide
12:21:16 <dmwit> What if you don't remove a package from .ghc?
12:22:17 * hackagebot chain-codes 0.1.0.0 - Library decoding chain codes from images  http://hackage.haskell.org/package/chain-codes-0.1.0.0 (MateuszKowalczyk)
12:22:20 <monochrom> then some problem lurks around
12:23:13 <dmwit> what if you fix ghc
12:23:18 <dmwit> 3% serious
12:24:02 <monochrom> the only "fix" is to disable inlining altogether.
12:24:20 <dmwit> I did not know that! I thought more precise dependency tracking would be enough.
12:24:20 <obiwahn> i hate this bot
12:25:01 <obiwahn> ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-imports","-l","/home/lambdabot/.lambdabot/State/L.hs","--expression=2 + 3","+RTS","-N2","-RTS"]
12:25:14 <obiwahn> Terminated
12:25:18 <obiwahn> waht could that be?
12:25:50 <monochrom> I guess you're right
12:26:03 <obiwahn> > 2 + 3
12:26:04 <lambdabot>  5
12:26:10 <obiwahn> meow :)
12:26:21 <Eduard_Munteanu> Hm, I wasn't aware... it seems you can do   type Io a = forall io. (MonadIO io) => io a   and use it everywhere where IO is wanted, as long as you liftIO (but it often works to liftIO just after the '=')
12:27:29 <monochrom> no, more precise dependency tracking may be inadequate
12:27:45 <Eduard_Munteanu> Well, you might want Monad and Applicative as constraints too.
12:27:54 <shachaf> Eduard_Munteanu: But why?
12:28:06 <monochrom> it may just prevent some and give earlier warning of some more
12:29:27 <Eduard_Munteanu> shachaf: to avoid having to write the MonadIO constraint everywhere, and it also works in arguments of things like forkIO
12:29:32 <Eduard_Munteanu> :t forkIO
12:29:33 <lambdabot> Not in scope: `forkIO'
12:29:38 <Eduard_Munteanu> @hoogle forkIO
12:29:38 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
12:29:38 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
12:29:38 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
12:29:54 <dhrosa> @pl onLow func val = let lo = fromIntegral val :: Word8 in (fromIntegral (func lo)) .&. val
12:29:55 <lambdabot> onLow = (`ap` ((:: Word8) . fromIntegral)) . flip . (((.&.) . fromIntegral) .)
12:30:03 <dhrosa> haha
12:30:04 <Eduard_Munteanu> With a constraint synonym you need to quantify in the first argument separately as well.
12:30:58 <joelteon> :t (::)
12:30:59 <lambdabot> parse error on input `::'
12:31:00 <joelteon> rats
12:31:04 <joelteon> that would be really nice
12:31:21 <Eduard_Munteanu> e.g. foo :: (MonadIO io) => Foo -> (forall io. MonadIO io => Foo -> io Bar) -> io Bar
12:32:10 <Eduard_Munteanu> But you can just write   foo :: Foo -> (Foo -> Io Bar) -> Io Bar   with the rank-n type synonym above.
12:32:46 <shachaf> Why not Foo -> (Foo -> IO Bar) -> IO Bar?
12:33:35 <obiwahn> » ./mueval-core  -E "5*2"
12:33:37 <obiwahn> Could not find module `ShowQ'
12:33:39 <obiwahn> Use -v to see a list of the files searched for.
12:33:47 <obiwahn> could that be the problem?
12:33:53 <Eduard_Munteanu> shachaf: abstracting over IO is useful for transformer stacks
12:34:00 <monochrom> catch :: Exception e => (forall u. MonadIO u => u a) -> (e -> forall p. MonadIO p => p a) -> (forall x. MonadIO x => x a)
12:34:21 <monochrom> that is going to be a whole can of worms
12:34:24 <shachaf> This isn't really much of an abstraction, though.
12:34:25 <Eduard_Munteanu> Note you can't only quantify in the outer scope.
12:34:48 <shachaf> (forall x. MonadIO x => x A) is isomorphic to (IO A)
12:34:49 <dmwit> Eduard_Munteanu: I thought forkIO and friends didn't really play nicely with transformer stacks anyway.
12:35:17 <Eduard_Munteanu> dmwit: they don't if you forall only once
12:35:31 <dmwit> monochrom: I am mildly interested in why dependency tracking is not enough. Do you think 2-3 minutes is enough to explain why?
12:35:53 <dmwit> Eduard_Munteanu: I meant semantically, independent of typing.
12:36:12 <Eduard_Munteanu> monochrom: why is it a can of worms?
12:36:34 <dmwit> Eduard_Munteanu: I retract my complaint.
12:36:45 <monochrom> I have X-1. I build Y, it depends on X, X-1 is chosen.
12:36:53 <monochrom> I now add X-2.
12:37:05 <monochrom> I now build Z, it depends on X, X-2 is chosen.
12:37:40 <monochrom> I now build B, it depends on Y and Z. now you need a time machine to go back and regret not foreseeing this.
12:37:48 <dmwit> Incorrect.
12:37:59 <dhrosa> @pl onLow func val = (val .&. (0xFFFF00)) .|. (fromIntegral (func (fromIntegral val)))
12:37:59 <lambdabot> onLow = liftM2 (.|.) (.&. 16776960) . (fromIntegral .) . (. fromIntegral)
12:38:04 <dmwit> I now build B, it depends on a new copy of Y which depends on X-2 and the current copy of Z which depends on X-2.
12:38:08 <dhrosa> that's slightly better, but still gross
12:38:19 <Eduard_Munteanu> shachaf: actually it's weaker than IO
12:38:23 <monochrom> ok, I see
12:38:23 <dmwit> It can even be a new copy of the *same version* of Y -- just with a different dependency tree.
12:38:32 <shachaf> Eduard_Munteanu: Why?
12:38:36 <dhrosa> @pl onLow val = (val .&. (0xFFFF00)) .|. (fromIntegral (f (fromIntegral val)))
12:38:36 <lambdabot> onLow = liftM2 (.|.) (.&. 16776960) (fromIntegral . f . fromIntegral)
12:38:45 <monochrom> I guess that's like JHC
12:38:49 <Eduard_Munteanu> shachaf: it lacks Functor, Applicative and Monad instances I think
12:39:06 <shachaf> liftIO :: IO a -> Io a; "id" :: Io a -> IO a
12:39:42 <intrados> Do people have opinions on fold vs mapM with state? For example: http://lpaste.net/99611
12:40:10 <Eduard_Munteanu> shachaf: yeah, though doing liftIO everywhere sort of sucks
12:40:28 <tac> How do you become a strong Haskeller?
12:40:38 <tommd> Work-out
12:40:40 <tac> You need to lift a lot of IO.
12:40:41 <Eduard_Munteanu> tac: you commute to the university :P
12:40:48 <monochrom> fold and mapM sound unrelated. why vs?
12:41:09 <monochrom> it's like violet vs mug
12:41:16 <dmwit> "mapM with state" is a clause
12:41:25 <dmwit> Which meant "mapM with State"
12:41:28 <monochrom> ok, still sound unrelated
12:42:29 <intrados> monochrom: They're not generally related related but I found that I was sometimes using folds for things which I think "mapM with state" expresses more clearly
12:43:14 <monochrom> then use the clearer one
12:43:30 <monochrom> on a case-by-case basis. there is no rule of thumb.
12:43:36 <Eduard_Munteanu> Actually I'm unsure this plays well when you add other constraints like MonadReader... if you call IO functions directly under a single big liftIO, almost the entire definition is in IO, monomorphically.
12:46:08 <rribeiro>  /qyuit
12:51:01 <prophile> @free traverse
12:51:02 <lambdabot> Extra stuff at end of line in retrieved type "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
12:51:21 <prophile> :<
12:55:49 <Eduard_Munteanu> Hm, right, it doesn't reduce applications of liftIO when you do both io and IO.
12:55:54 <Eduard_Munteanu> But at least...
12:55:57 <Eduard_Munteanu> :t length <$> liftIO getContents
12:56:01 <lambdabot> (Functor f, MonadIO f) => f Int
12:56:38 <Eduard_Munteanu> Now it would be annoying to attach those constraints to every IO occuring in certain types.
12:57:25 <shachaf> :t length <$> getContents
12:57:25 <lambdabot> IO Int
12:58:27 <Eduard_Munteanu> shachaf: that works when you use IO specifically, it won't work for polymorphic types like (MonadReader Foo io, MonadIO io) => ... -> io Bar
12:58:32 <obiwahn> user error (The package requires Cabal library version -any && >=1.16 but no
12:58:34 <obiwahn> suitable version is installed.)
12:59:39 <geekosaur> obiwahn, there are two things referred to as cabal, one is the library and is part of the compiler+runtime, the other is the command line utility
13:00:12 <geekosaur> you *may* be able to install a new version of the library; unlike most of the things that come with the compiler it is relatively safe to upgrade
13:00:13 <Eduard_Munteanu> :t length <$> liftIO getContents :: (MonadReader Int io, MonadIO io) => io ()
13:00:14 <lambdabot>     Couldn't match type `Int' with `()'
13:00:15 <lambdabot>     Expected type: [Char] -> ()
13:00:15 <lambdabot>       Actual type: [Char] -> Int
13:00:22 <Eduard_Munteanu> Er.
13:00:25 <Eduard_Munteanu> :t length <$> liftIO getContents :: (MonadReader Int io, MonadIO io) => io Int
13:00:26 <lambdabot>     Could not deduce (Functor io1) arising from a use of `<$>'
13:00:26 <lambdabot>     from the context (MonadReader Int io, MonadIO io)
13:00:26 <lambdabot>       bound by the inferred type of
13:02:15 <Eduard_Munteanu> And if I want to use constraint synonyms, things like   foo :: ... => io () -> io () -> io ()   , which pass those actions to plain IO functions (e.g. forkIO), won't work.
13:02:56 <dhrosa> @pl \s -> setPC (onLow (const (eval val s)) (getPC s)) s
13:02:56 <lambdabot> setPC =<< ap (onLow . const . eval val) getPC
13:03:00 <monochrom> aw, please don't spread the myth that possessing a different Cabal lib version is safe. it is no longer safe.
13:03:13 <byorgey> obiwahn: what package is that?
13:03:20 <geekosaur> oh? figures
13:03:22 <dhrosa> :t ap
13:03:23 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:04:05 <monochrom> if you use ghc-mod, it gets confused by multiple Cabal libs
13:04:05 <obiwahn> byorgey: i am trying to install lamdabot now haskeline-0.7.1.2 does not want to install
13:04:47 <byorgey> obiwahn: what version of GHC do you have?
13:04:55 <obiwahn> it is a system with debian stable and i would prefer not switch libc6
13:05:27 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/109197 is another one affected
13:05:30 <byorgey> I was going to say that there are precious few packages that actually require Cabal >= 1.16, but haskeline might be one of them
13:07:04 <enthropy> @unmtl WriterT m (State String a)
13:07:04 <lambdabot> Plugin `unmtl' failed with: `WriterT m (State String a)' is not applied to enough arguments, giving `/\A. (State String a) (A, m)'
13:07:10 <enthropy> @unmtl WriterT m (State String) a
13:07:11 <lambdabot> (State String) (a, m)
13:08:03 <dv-> @botsnack
13:08:04 <lambdabot> :)
13:08:44 <enthropy> is there a parser that is like  ErrorT msg ReadP?
13:09:13 <enthropy> parsec and such need much prodding to get them to backtrack
13:09:30 <Eduard_Munteanu> enthropy: attoparsec backtracks automatically
13:09:38 <enthropy> don't you need a try?
13:09:52 <Eduard_Munteanu> enthropy: nope, in fact you can't stop it from backtracking :)
13:11:24 <Eduard_Munteanu> enthropy: don't be confused by 'try' and such in the docs, they probably copied the descriptions from Parsec as they were
13:12:09 <Eduard_Munteanu> try :: Parser a -> Parser a [...] This combinator is provided for compatibility with Parsec. Attoparsec parsers always backtrack on failure.
13:12:16 <twopoint718> Has anyone had any experience with Amazon AWS libs? In particular S3? Preferences?
13:13:57 <ownclo> enthropy: attoparsec provides an Alternative instance, so you can just use <|>. It's all-or-nothing, so you have backtracking for free.
13:14:37 <enthropy> > parseOnly ( many (fmap Left anyChar <|> fmap Right anyChar) <* endOfInput) "abc"
13:14:39 <lambdabot>  Not in scope: `parseOnly'Not in scope: `anyChar'Not in scope: `anyChar'Not i...
13:14:43 <enthropy> that gives me a list of all Lefts
13:16:20 <enthropy> > readP_to_S (Control.Applicative.many (fmap Left get +++ fmap Right get) <* eof) "abc"
13:16:21 <Eduard_Munteanu> enthropy: that's expected
13:16:21 <lambdabot>  Not in scope: `readP_to_S'Not in scope: `eof'
13:16:45 <enthropy> that's not what I want
13:17:03 <Eduard_Munteanu> enthropy: both alternatives have the same parser, they'll both fail or succeed
13:17:14 <`Jake`> where is instance Functor ((->) a) defined?
13:17:25 <ownclo> enthropy: you want them to be interleaved?
13:17:45 <enthropy> the readP version prints out [([Left 'a',Left 'b',Left 'c'],""),([Left 'a',Left 'b',Right 'c'],""),([Left 'a',Right 'b',Left 'c'],""),([Left 'a',Right 'b',Right 'c'],""),
13:17:48 <enthropy> ...
13:17:57 <enthropy> covering all the combinations of Left and Right
13:18:20 <enthropy> this is inefficient
13:18:24 <enthropy> but I have a small input
13:19:21 <Eduard_Munteanu> enthropy: 'many' doesn't do that, it merely applies a parser multiple times to the same input, consuming it
13:19:51 <Eduard_Munteanu> enthropy: er, not the same input, I mean by the time you apply it the second time the input has been consumed
13:20:49 <enthropy> ok so how do you handle ambiguous grammars in attoparsec?
13:21:05 * enthropy thinks the answer is "you don't"
13:22:06 <cbw> rewrite the grammer
13:22:16 <Eduard_Munteanu> enthropy: not sure how you expect 'Left <$> foo <|> Right <$> foo' to ever match the right branch
13:24:13 <enthropy> Eduard_Munteanu: it does with ReadP
13:24:50 <`Jake`> ah, found it, Control.Monad.Instances
13:26:45 <enthropy> seems to be the uu-parsinglib has a non-biased <|>
13:27:01 <Eduard_Munteanu> enthropy: perhaps you can use ListT Parser ...  and do something like   a <- ListT (anyChar >>= \x -> return [Left x, Right x])
13:27:17 <enthropy> and with that I have to lift everything
13:30:16 <grady_player> having some difficulty figuring out a simple syntax problem: http://cl.ly/code/0X040a3l1R1O
13:30:38 <Eduard_Munteanu> enthropy: it seems the sort of backtracking you want isn't in the parser itself... perhaps you want to combine parsers using arrow combinators, such that you run them in parallel on the same input?
13:31:26 <grady_player> error output: http://cl.ly/image/2T0z1M3g0z08
13:32:31 <koala_man> grady_player: (x:xs)
13:32:47 <grady_player> ha! thank you
13:33:07 <koala_man> (x,xs) is a two element tuple, (x:xs) is a list's head and tail
13:39:03 <lukeqsee_server> \quit
13:54:39 <zipper> How do I call lamdabot?
13:55:01 <zipper> > String -> Bool
13:55:02 <lambdabot>  <hint>:1:8: parse error on input `->'
13:55:15 <ParahSailin> @hoogle String -> Bool
13:55:16 <lambdabot> Network.URI isAbsoluteURI :: String -> Bool
13:55:16 <lambdabot> Network.URI isIPv4address :: String -> Bool
13:55:16 <lambdabot> Network.URI isIPv6address :: String -> Bool
13:55:46 <zipper> > String -> String
13:55:47 <lambdabot>  <hint>:1:8: parse error on input `->'
13:56:34 <zipper> > existsInString :: Char -> String -> Bool
13:56:35 <lambdabot>  Not in scope: `existsInString'
13:56:44 <zipper> > Char -> String -> Bool
13:56:46 <lambdabot>  <hint>:1:6: parse error on input `->'
13:57:25 <zipper> > :t Data.map
13:57:26 <lambdabot>  <hint>:1:1: parse error on input `:'
13:57:31 <`Jake`> :t Data.map
13:57:33 <lambdabot> Couldn't find qualified module.
13:57:37 <`Jake`> :t Data.Map
13:57:38 <lambdabot> Couldn't find qualified module.
13:58:02 <zipper> I am totally unable to use this bot but it is fun for sure.
13:58:02 <`Jake`> well, modules don't have types
13:58:04 <Nolrai66> :t Data.Map.Map
13:58:05 <lambdabot> Not in scope: data constructor `Data.Map.Map'
13:58:11 <CandyCorns> Hey all! Can anyone explain why ":module Control.Monad" doesn't automatically import ":module Control.Monad.Writer"? Isn't the latter just a submodule of the former?
13:58:12 <jfischoff> :t M.Map
13:58:12 <lambdabot> Couldn't find qualified module.
13:58:18 <jfischoff> I don't know
13:58:29 <shachaf> There is no such thing as a submodule.
13:58:33 <zipper> `Jake`: Wow and I learn something new.
13:58:47 <Nolrai66> CandyCorns: no is the short answer.
13:58:49 <zipper> > :t map
13:58:50 <lambdabot>  <hint>:1:1: parse error on input `:'
13:59:01 <hpc> CandyCorns: the tree structure of modules is really for organization only
13:59:04 <`Jake`> CandyCorns: for that to be the case, Control.Monad would have to explicitely export module Control.Monad.Writer
13:59:06 <hpc> there's nothing like java's import foo.bar.*
13:59:28 <zipper> > :t filter
13:59:29 <lambdabot>  <hint>:1:1: parse error on input `:'
13:59:34 <`Jake`> :t filter
13:59:35 <lambdabot> (a -> Bool) -> [a] -> [a]
13:59:40 <hpc> to some extent, you wouldn't want to use that kind of importing in haskell
13:59:47 <zipper> What did I do wrong?
13:59:51 <shachaf> zipper: You should experiment with lambdabot using /msg, not in here, unless you're demonstrating something.
13:59:54 <`Jake`> you wrote a >
14:00:00 <shachaf> zipper: ">" is for running code only. ":t" is for asking for types.
14:00:04 <shachaf> "@help" will tell you more.
14:00:13 <hpc> you might install a package later that adds Control.Monad.BreakEverything
14:00:21 <hpc> containing evil Monad instances
14:00:23 <CandyCorns> :hpc :`Jake` Thanks!
14:00:46 <hpc> those get brought into scope the next time you use some unrelated code and bad things happen without any "code changes"
14:00:56 <zipper> shachaf: Using it in PM now
14:01:36 <zipper> There wasn't much going on before I started talking to thr bot anyway.
14:01:49 <hpc> java's type system is different in just the right ways that imports on their own don't cause code behavior to change
14:02:33 <hpc> (to be precise, you can do what i described without going through a stray import)
14:04:31 <bitemyapp> so if I wanted to structure my code as going left to right
14:04:38 <bitemyapp> what would I use instead of $?
14:05:02 <bitemyapp> ReinH: ^^
14:05:06 <bitemyapp> ReinH: your golden opportunity.
14:05:16 <`Jake`> So, I just read the first few pages of byorgey's typeclassopedia, and he claims that you can't make Set an instance of functor in haskell because Set requires it's elements to be instances of Ord, whereas a Functor needs to work with any types a and b. However, that doesn't stop me from copying Data.Set.Base and making Set a working instance of Functor. Did I break some rules or is the typeclassopedia wrong here?
14:05:29 <`Jake`> s/it's/its
14:05:50 <shachaf> `Jake`: You broke either the Functor laws or the Set laws.
14:05:57 <`Jake`> shachaf: ok, thanks
14:06:31 <opqdonut> probably, your fmap will keep the order of the elements, which will violate the ordering property of the set
14:06:32 <`Jake`> are the set laws written down somewhere?
14:06:39 <`Jake`> opqdonut: ah, yeah
14:06:41 <`Jake`> I see
14:06:45 <bitemyapp> `Jake`: nah, we pay a dude to keep 'em memorized
14:06:50 <bitemyapp> `Jake`: he's only available on tuesdays tho
14:07:02 <Nolrai66> >.<
14:07:02 <bitemyapp> so Friday ain't a good day to do anything with SEts
14:07:13 <`Jake`> I see, whole week would be too expensive
14:07:33 <CandyCorns> Is it generally preferred to import "Data.Map.Lazy" instead of "Data.Map"? Is the difference between the two purely historical?
14:08:29 <shachaf> `Jake`: Probably in the source code of Data.Set.
14:08:42 <shachaf> Since without that you can't really break the laws.
14:08:48 <bitemyapp> ReinH: I'm writing flip (.), I hope you're happy.
14:08:54 <`Jake`> shachaf: doesn't look like it
14:09:13 <shachaf> bitemyapp: None of us are happy. Write whatever you want.
14:10:15 <Nolrai66> Okay I know this is easy but I am having a brain blip. I a "l :: [b]" and an "f :: b -> Int" and I want to get the list of b's such that f b is >= to all other f b's in the list.
14:10:16 <shachaf> `Jake`: Well, maybe in the paper it links to, then.
14:10:23 <byorgey> CandyCorns: once upon a time, all we had was Data.Map, and it was lazy, and everything was happy.  Then some people came along complaining that they wanted a strict version.  So then it was split into .Lazy and .Strict, with Data.Map re-exporting .Lazy for backwards compatibility.
14:10:28 <bitemyapp> shachaf: :(
14:10:40 <`Jake`> shachaf: yeah, that's probably the case. Thanks
14:10:47 <CandyCorns> :byorgey Ah okay. Thank you!
14:11:04 <sm> that's not good, here you go y'all, http://24hoursofhappy.com/
14:11:57 <hpc> @hoogle happy -- bitemyapp
14:11:57 <lambdabot> Parse error:
14:11:57 <lambdabot>   happy -- bitemyapp
14:11:57 <lambdabot>           ^
14:12:10 <geekosaur> heh
14:13:06 <[swift]> Nolrai66: sounds like a fold if i understand you correctly. so foldM?
14:13:07 <dwcook> Nolrai66, wouldn't you get either an empty list or a singleton list that way?
14:13:09 <`Jake`> @hoogle --
14:13:10 <lambdabot> No query entered
14:13:10 <lambdabot> Try --help for command line options
14:13:42 <[swift]> oh, sorry. i saw >>= and not >=. my mistake
14:14:30 <[swift]> dwcook: nah, because you can have multiple b's such that f b has the same value
14:15:48 <[swift]> Nolrai66: still sounds like a fold though, because you need to keep some state (about the maximum f b you've seen and the set of b's that generate it) as you progress through the list
14:16:03 <Nolrai66> dwcook: only if f was surjective.
14:16:18 <Nolrai66> Which in my case it isn't
14:16:31 <dwcook> Yeah I thought about it wrong
14:17:08 <Nolrai66> Oh your right it is a fold! I think its just a foldl' actually.
14:17:11 <grady_player> is there a short blurb that can help me understand the different number types in haskell, I don't understand why I can't do ((6/7) < 100)
14:17:32 <ion> > ((6/7) < 100)
14:17:33 <lambdabot>  True
14:17:39 <dwcook> grady_player, you can do ((6/7) < 100)
14:17:57 <monochrom> sounds like an XY problem
14:18:32 <frx> grady_player number literals are polymorphic. perhaps you tried it with a non-literal?
14:18:40 <grady_player> well I cant do ((n/x) <100)
14:18:51 <monochrom> that's more like it
14:18:52 <grady_player> No instance for (Fractional Integer) arising from a use of `/'
14:18:55 <haasn> http://www.haskell.org/onlinereport/haskell2010/haskell2x.png
14:19:04 <alorente> is there a good writeup about the whys and wherefores of different string types in haskell? I think I know when to use String vs. Lazy.ByteString vs. ByteString, but I don't know where Text fits in...
14:19:08 <haasn> this chart contains the standard numeric type classes and their instances
14:19:28 <haasn> alorente: Text is to String what ByteString is to [Word8]
14:19:34 <ion> alorente: ByteString is not a text type. String and Text are text types.
14:19:35 <haasn> alorente: you shouldn't be using ByteStrings as “strings”
14:19:36 <tac> alorente: Text is efficient Unicode
14:19:38 <geekosaur> Text is a fast Unicode type. String is a slow but convenient Unicode type. ByteString is an octet type
14:19:53 <frx> grady_player / is not defined for Integers. see fromIntegral
14:20:03 <frx> :t fromIntegral
14:20:04 <lambdabot> (Integral a, Num b) => a -> b
14:20:07 <alorente> ahhh that makes sense
14:20:11 <alorente> thanks!
14:20:14 <haasn> String should generally only be used as an intermediate representation when eg. processing individual characters. Text should be used for storing any sort of text
14:20:32 <haasn> Text is basically the equivalent to having some “string” object lying around in other languages (that have unicode strings)
14:20:43 <haasn> String is really inefficient in terms of representation
14:21:30 <Nolrai66> grady_player: integer division is "div".
14:21:31 <haasn> In general I would use string when you can benefit from streaming/laziness
14:21:48 <tac> String is a linked list. To allocate (and fully normalize) a 1000 characters requires 1000 memory allocations
14:21:49 <haasn> and Text when you need whole chunks in memory
14:21:49 <Nolrai66> > 22 `div` 10
14:21:50 <lambdabot>  2
14:22:00 <haasn> tac: and lots and lots of overhead
14:22:11 <tac> (at least, unoptimized, maybe GHC is magical?)
14:22:19 <haasn> in the worst case scenario, on 64-bit platforms, String has 40 bytes per codepoint
14:22:27 <grady_player> thank you everyone... such a learning curve, I will get there
14:22:32 * hackagebot QuickCheck-GenT 0.1.0 - A GenT monad transformer for QuickCheck library.  http://hackage.haskell.org/package/QuickCheck-GenT-0.1.0 (NikitaVolkov)
14:23:26 <haasn> what about if you rewrite (n/x) < 100 as n < 100*x ?
14:24:04 <ion> tac: In some specific cases, the entire list data structure can be optimized away.
14:24:54 <Nolrai66> whats the flag to tell ghc where to look for .hs files?
14:25:47 <ion> nolrai66: I don’t remember offhand, but in case you’re writing a .cabal file, you can use hs-source-dirs.
14:26:09 <dcoutts_> Nolrai66: the ghc flag is -i
14:26:42 <haasn> tac: I got curious and in a simple case like main = putStrLn "Hello, world!" It seems like the “Hello, world!” isn't allocated as a bunch of (:) constructors in memory, but as a GHC.CString.unpackCString# "Hello, world!"
14:27:00 <Nolrai66> I should have just guessed. Thanks!
14:27:26 <tac> haasn: It's already an insane design to start with. They had to make it slightly less insane :)
14:27:26 <shachaf> haasn: What do you mean by "allocated"?
14:27:56 <shachaf> I assume that when you actually look at that string at runtime, all those (:)s will be allocated.
14:28:37 <alorente> just to make sure I'm understanding correctly:
14:28:37 <alorente> a String is a linked list of Unicode characters, which may be a single byte of ascii and may be several bytes of non-ascii-representable (or are ascii-representable characters several bytes of mostly zeroes?)
14:28:37 <alorente> a ByteString is some datastructure containing a series of bytes that *could* be encoded Unicode but might be a jpeg or whatever
14:28:37 <alorente> a Lazy ByteString is like a ByteString but uses a datastructure that's more efficient in some contexts
14:28:37 <alorente> a Text uses the ByteString datastructure, but each element is a Unicode character
14:29:14 <haasn> shachaf: Hmm, I hadn't considered that; but now that you mention it, I realized that unpackCString# actually returns a [Char] from a GHC.Prim.Addr#
14:29:17 <ion> alorente: Unicode characters are not a single byte or several bytes, specific encodings of Unicode may be.
14:29:25 <haasn> For some reason I was thinking it would return a CString
14:29:27 <shachaf> The implementation of Text does not use ByteString, not that you have to care.
14:29:47 <shachaf> "blah blah" in Core is a CString#.
14:30:04 <shachaf> But you have an ABI to maintain here. You can't just change representations of things.
14:30:10 <c_wraith> alorente: and specifically, lazy ByteString is just a linked list of strict ByteString chunks. The advantage to that is that links can be followed lazily. It's somewhat slower, but can lead to improvements in memory use.
14:30:22 <alorente> c_wraith: yes
14:31:02 <haasn> alorente: a String is a linked list of Unicode *codepoints* (characters may consist of multiple code points), which may have any internal representation the compiler happens to like. there are a little over 2^16 of them though, iirc.
14:31:22 <shachaf> There are approximately 17*2^16 code points.
14:31:36 <ion> > logBase 2 (fromIntegral (ord maxBound))
14:31:38 <lambdabot>  20.087461546321563
14:31:39 <shachaf> (Not quite that many because some are invalid.)
14:31:49 <ParahSailin> > maxBound ::Char
14:31:50 <lambdabot>  '\1114111'
14:31:54 <haasn> Ah, okay
14:32:18 <c_wraith> haasn: it went over 16 bits immediately after java permanently committed to a 16 bit value.
14:32:37 <verement> poor Java
14:32:52 <dcoutts_> Windows API suffered too
14:32:58 <ion> Exposing the internal representation of text is such a great idea.
14:33:01 <haasn> alorente: the haskell specification doesn't say anything about how Char is implemented internally, it could be the case that it's always 64 bits and for ascii values is mostly zero. But it could also be the case that it's implemented using a variable length encoding or something internally. Whatever the compiler desires
14:33:36 <alorente> gotcha
14:34:37 * dcoutts_ notes that the Haskell report doesn't say how much is implemented at all
14:34:42 <dcoutts_> erm
14:34:54 <dcoutts_> it doesn't say much about how anything is implemented
14:34:59 <haasn> I think GHC usually picks whatever native machine integer size that platform has (32 bits on x86, 64 bits on amd64); together with extra overhead for the constructor tag and further overhead for the linked list itself, which is where the “40 bytes per codepoint” figures from
14:35:40 <geekosaur> although it does leave some spare room for implementation choices (see for example the minimum size of an Int)
14:37:14 <luite> haasn: yeah, a Char is 2 machine words with GHC (2x32 or 2x 64 bit), a cons cell is 3 words
14:37:23 <prinsen> How do I disable 'defined but not used' errors of declared functions in GHC?
14:37:33 <haasn> luite: certain Chars are smalled
14:37:34 * hackagebot cio 0.1.0 - A monad for concurrent IO on a thread pool  http://hackage.haskell.org/package/cio-0.1.0 (NikitaVolkov)
14:37:38 <haasn> smaller*
14:37:56 <luite> haasn: only if you unbox them somehow, this is the general case
14:38:15 <luite> also Word16, Word32, Word8 all take 64 bit in a closure on a 64 bit OS
14:38:16 <haasn> luite: apparently, GHC's RTS statically preallocates the codepoints 0-255 so references to those don't need extra representations in memory beyond the cons cell
14:38:34 <haasn> which does indeed slightly optimize the ASCII case
14:38:36 <monochrom> but let's say [Int] has a pretty predictable, uniform, and irreducible size :)
14:39:01 <luite> haasn: oh that's true, the Char itself is still 2 words, but the memory manager consolidates references and points them all to that static one
14:39:29 <luite> perhaps the unpackCString# primitive also does that, probably yes
14:39:38 <monochrom> "smalled" is a cool word :)
14:39:53 <monochrom> better than "downsized" :)
14:39:57 <shachaf> haasn: The best part is what happens when you write the string "abc\0def"
14:39:59 <haasn> littled
14:40:12 <luite> haasn: good point though, i think i might not yet have done this optimization in ghcjs
14:40:15 <haasn> shachaf: what happens when you do that?
14:40:44 <luite> haasn: so i'll check, and emsmallen them if i haven't already
14:40:47 <shachaf> haasn: Well, unpackCString# is in trouble because CString#s are \0-terminated.
14:41:13 * monochrom tries
14:41:32 <haasn> says GHC.CString.unpackCStringUtf8# "abc\NULdef"
14:41:51 <haasn> I wonder how that works
14:41:57 <shachaf> It's a puzzle.
14:42:20 <shachaf> (It uses an invalid overlong UTF-8 sequence.)
14:42:43 <haasn> (maybe that's why it's Utf8# and not Utf8)
14:42:55 <geekosaur> yeh, there's a commonish hack to use a technically invalid utf8 sequence to encode NUL
14:43:02 <shachaf> But you won't see it by looking at the Core.
14:43:07 <shachaf> Probably -ddump-cmm will show you.
14:43:07 <monochrom> yeah, 97, 98, 99, 192, 128, 100, 101, 102. the 192,128 part is for \0
14:43:16 <ion> Heh, interesting.
14:43:31 <monochrom> well I go all out and -ddump-asm. completely settles it.
14:43:39 <luite> oh
14:43:41 <haasn> -ddump-cmm does indeed show it
14:43:43 <shachaf> Yep, 11000000 10000000 to encode 0.
14:43:48 <monochrom> accept no substitute!
14:43:52 <luite> another thing i might not have done properly in ghcjs!
14:44:10 <shachaf> This means that Data.Text's UTF-8 decoder has to be invalid.
14:44:11 <luite> i learn so much from you guys
14:44:27 <shachaf> I don't know why it doesn't just use a length.
14:44:58 <ion> People could confuse us with Pascal then.
14:44:58 <monochrom> yeah that's too bad
14:45:19 <monochrom> I thought we were already Pascal :)
14:45:37 <luite> oh silly me, i forgot that ghcjs has a different representation for chars, it unboxes them all
14:45:48 <luite> so no optimization with static closures for me
14:45:51 <athan> Why do list comprehensions and do-notation both use (<-)? Could a list comprehension be made out of any Monad?
14:46:07 <ion> athan: There’s a MonadComprehensions extension.
14:46:14 <ion> Or at least there was one.
14:46:22 <silasm> athan: they can be in idris :)
14:46:25 <tac> athan: Yes. They are the "same" notation, in a sense.
14:46:33 <monochrom> did you know: edwardk dreams of a Turbo Haskell :)
14:46:46 <athan> silasm: idris?
14:46:48 <silasm> monochrom: heh
14:46:50 <athan> ion: Thank you!!
14:46:59 <haasn> shachaf: it doesn't seem like Data.Text actually uses unpackCStringUtf8#; or what did you mean by that?
14:47:04 <athan> tac: Oh wow! cool, I'll try it out!
14:47:13 <silasm> athan: haskell with dependent types, but more programming-oriented than agda
14:47:18 <luite> monochrom: with a blue background and yellow text!
14:47:24 <shachaf> haasn: No, it uses a rewrite rule that turns unpackCStringUtf8# into something else.
14:47:41 <shachaf> But it has to be compatible with strings containing \0.
14:47:45 <athan> silasm: agda o.o
14:48:03 <silasm> (also I should mention it's not a superset of haskell, it just is designed similarly)
14:48:22 <darth_lumbergh> Scala also has a single syntax for list/monad stuff
14:49:08 <monochrom> [ x+1 | y <- a, x <- g y ] can be rewritten do { y <- a; x <- g y; return (x+1) }
14:49:15 <ion> luite: Add Comic Sans and you have reached SPJ’s slides.
14:49:36 <monochrom> the compiler may generate slightly different code. that's its business and none of mine.
14:49:45 <silasm> athan: idris/agda are languages with similar designs to haskell that have first-class types which can depend on values. Check out #idris or idris-lang.org if you want.
14:49:58 <luite> ion: oooh
14:50:00 <prinsen> How do I disable 'defined but not used' errors of declared functions in GHC?
14:50:11 <haasn> and the latter can be rewritten as the former, if you have MonadComprehensions enabled ;)
14:50:14 <monochrom> by controling exports
14:50:24 <athan> silasm: Sorry, it's just the first time I've heard of them! Thank you, I'll check them out!
14:50:26 <ion> prinsen: Export them or don’t define them.
14:50:34 <silasm> athan: but if you're beginning with Haskell I'd stick to that for now ;)
14:50:38 <luite> is there a latex beamer template spj style available?
14:51:09 <athan> silasm: I agree xD I'm reading the haskell road to logic + mathematics right now
14:51:22 <monochrom> MonadComprehension is the best thing since Wadler's "comprehending monads" :)
14:52:30 <prinsen> ion: im using TH
14:52:45 <ion> prinsen: So export them maybe?
14:53:58 <monochrom> I guess disable the warning itself then.
14:54:03 <prinsen> ion: In TH you return all decs toplevel
14:54:19 <monochrom> if Buddha gives you that warning, kill Buddha. if -Wall gives you that warning, kill -Wall
14:54:46 <ion> {-# OPTIONS_GHC -fno-warn-something #-} or something
14:55:08 <luite> prinsen: errors or warnings? do you mean that validate fails?
14:55:14 <luite> -fno-warn-unused-binds
14:55:59 <prinsen> luite: just 3k warnings
14:56:10 <jeronimo> > map ($10) [(+2), (*2), (2^)] [1..10]
14:56:12 <lambdabot>  Couldn't match expected type `[t1] -> t0' with actual type `[b0]'
14:56:13 <prinsen> luite: which is quite boring
14:56:22 <jeronimo> > map ($10) [(+2), (*2), (2^)]
14:56:23 <athan> what does that mean?
14:56:23 <lambdabot>  [12,20,1024]
14:56:26 <athan> b0?
14:56:32 <athan> and t1/t0?
14:56:40 <athan> are they just type variables?
14:57:04 <luite> prinsen: yeah just disable the warning then :)
14:57:05 <platz> silasm: after watching brady's talk on Idris, I also really liked how he seems to have found a better way to represent monad transformers with the Eff construct
14:57:17 <athan> > map ($10) [(2+), (2*), (2^)]
14:57:18 <ion> map ($10) [(+2), (*2), (2^)] :: [A], you’re trying to use it as if it was :: [B] -> C by applying a list to it.
14:57:18 <lambdabot>  [12,20,1024]
14:57:31 <platz> no lifting... that alone is great
14:57:32 <athan> map ($10) [(2+), (2*), (2^)]
14:57:34 <silasm> platz: yeah, effects are nice. Though haskell isn't devoid of effects support iirc.
14:57:39 <tac> Is it known if Effects and monad transformers are "equivalent" in any sense?
14:57:58 <platz> i see
14:58:00 <silasm> Dependent types give you some nice tools for working with effects though
14:58:10 <monochrom> map ($10) [(+2), (*2), (2^)] [1..10] = [10+2, 10*2, 2^10] [1..10] = brain fart
14:58:21 <monochrom> definition: a brain fart is a type error
14:58:41 <jle`> mm_freak: found a way to dynamically add wires to a collection using only the combinators, notably krSwitch.  now need to figure out a way to subtract wires from a collection/list :)
14:58:50 <athan> lol
14:59:51 <Earnestly> Sorry, but what does ($10) mean?  Specifically refering to the '$' in this case?
15:00:00 <monochrom> function application
15:00:08 <silasm> Earnestly: "apply 10"
15:00:21 <monochrom> sin $ 10 is the same as sin 10
15:00:22 <luite> Earnestly: a $ b = a b
15:00:25 <silasm> err kinda backwards
15:00:30 <Earnestly> luite: No, I know that
15:00:35 <Earnestly> Or do I…
15:00:50 <luite> Earnestly: the $ is the same here, the operator is used in a section
15:00:51 <silasm> :t ($10)
15:00:52 <monochrom> but having an explicit operator $ for that allows you to write sections ($ 10) and (sin $)
15:00:52 <lambdabot> Num a => (a -> b) -> b
15:00:54 <Earnestly> a b -> (a -> b)?
15:01:01 <luite> Earnestly: ($b) a = a $ b = a b
15:01:28 <monochrom> luite's formula is good. always work with formulas. always. do not think. calculate.
15:01:37 <Earnestly> True enough
15:03:28 <Earnestly> I just didn't realise you could use $ like that
15:04:22 <darth_lumbergh> yeah, as a newbie/outsider you never see anyone using $ in a section, it just looks like special syntax at first
15:04:33 <Earnestly> Indeed
15:05:15 <obiwahn> meh so much work a little bot:) now i have a backport of ghc to stable:)
15:05:27 <monochrom> [f 10, g 10, h 10] = map ($ 10) [f, g, h] is pretty nifty, if you need it
15:06:06 <Earnestly> Yeah, it certainly is.  I just noticed it as it cuts out quite a lot of code
15:06:38 <jfischoff> monochrom: oh yeah I forgot that is cool when first see it.
15:06:48 <monochrom> obiwahn, you will soon empirically find that "let me just get GHC from debian" leads to the greatest amount of work, as most people already knew
15:07:20 <darth_lumbergh> or macports...bloody hell
15:07:32 <geekosaur> wut
15:07:36 <darth_lumbergh> ...now you have the wrong version of perl
15:07:54 <monochrom> haha great, it affects your perl
15:08:03 <geekosaur> hrm, is it still pulling in perl? or are you using an ancient ports tree?
15:08:10 <ion> obiwahn: I always do this. https://gist.github.com/ion1/2815423
15:08:17 <geekosaur> the evil mangler should be long gone I think
15:08:29 <ivanm> monochrom: if you use sandboxes for development work, I think that using distro packages becomes more viable now
15:08:46 <grady_player> :) ... brew install haskell-platform was pretty painless
15:09:00 <darth_lumbergh> oh, this was on an ancient-ish mac
15:09:06 <geekosaur> so you never updated
15:09:09 <monochrom> that really depends on which distro. archlinux is no problem, I know.
15:09:21 <monochrom> debian and ubuntu? they always give you the wrong version
15:09:22 <geekosaur> back years ago, ghc included a perl script to postprocess gcc output
15:09:42 <geekosaur> since trusting apple perl is never a wise idea, it pulls in macports perl
15:09:58 <geekosaur> (actually trusting apple anything is not a wise idea, as homebrew learned the hard way)
15:10:23 <monochrom> wrong version means you're always out of touch with the current stable haskell platform, which is already pretty conservative
15:10:33 <darth_lumbergh> had a job interview in Haskell last year, going from never writing a single line in it, so had to prepare fast - then macports was just cruelty
15:10:36 <obiwahn> mh ion thank you
15:10:49 <geekosaur> really, port selfupdate occasionally
15:11:07 <grady_player> port has gone the way of fink for me
15:11:15 <darth_lumbergh> brew all the way now!
15:11:19 <grady_player> yeah
15:11:20 <geekosaur> iiiick
15:11:32 <grady_player> brew is just systemically better
15:11:35 <geekosaur> sorry I like software that does not make my stomach churn every time I see the latest gross hacks
15:11:42 <geekosaur> it's systematically terrible
15:11:49 <darth_lumbergh> I shut my eyes
15:11:59 <bitemyapp> the last time I PR'd against homebrew
15:12:02 <geekosaur> unfortunately, since it's ruby, what anyone else would call terrible is the greatest thing ever (see Rails)
15:12:08 <bitemyapp> I came close to going on a rampage
15:12:47 <monochrom> ruby laser is the best thing since the knife that slices bread :)
15:13:09 <earthy> different kind of ruby though
15:13:20 <platz> darth_lumbergh: what domain was the haskell work in? web?
15:13:33 <darth_lumbergh> finance
15:13:41 <platz> ah nice
15:14:03 <darth_lumbergh> it's only nice in theory and remuneration :)
15:14:24 <darth_lumbergh> the reality of finance is a zillion legacy nightmares spewing XML at each other
15:14:33 <darth_lumbergh> if you're lucky
15:15:40 <platz> makes sense.. interesting mix of job postings in finance for low-latency C++, some functional stuff, some java
15:16:31 <darth_lumbergh> most of the banks have started to embrace functional programming :)
15:17:23 <grady_player> there is probably some comfort in an algorithm being mathematically provable over some domain.
15:17:46 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/87535/ is my theory
15:17:46 <darth_lumbergh> that would be a luxury
15:18:05 <platz> darth_lumbergh: only for back-office though?  or do they run that stuff in the markets too
15:18:57 <bitemyapp> monochrom: I like it.
15:19:01 <darth_lumbergh> it's hard to generalise
15:19:32 <darth_lumbergh> a few places have brought in Scala to use as a better Java
15:19:43 <grady_player> it is easy to generalize... flowers are good, security dudes are jerks
15:20:40 * geekosaur guesses target said that last a lot...
15:20:45 <darth_lumbergh> I think you generalised the generalisation a bit there
15:21:31 <Cale> I have a friend who is working in finance on derivative valuation, and who has a background in algebraic topology funnily enough, and I've been trying to get him interested in filling the gap between those two with functional programming and HoTT :)
15:22:00 <apples`> algebraic topology is pretty fun! unfortunately it's also pretty hard :(
15:23:41 <darth_lumbergh> assuming it's all done in Excel? :)
15:24:26 <Cale> Yeah, he said they're currently using Excel and C++, and there's a lot of stupid BS which seems like it would be much more nicely done in a functional programming setting
15:26:05 <mornfall> Stupid BS can always be done nicely in functional programs. :-P
15:26:30 <darth_lumbergh> picking the right tool is always a political battle
15:26:55 <mornfall> sounds like a contradiction in terms
15:27:01 <darth_lumbergh> just as difficult as getting more than one programmer to agree on anything
15:27:19 <mornfall> if there was a right tool, it'd be an obvious choice
15:27:24 <Cale> Apparently they have a lot of the "Curiously recurring template pattern"
15:27:35 <mornfall> Cale: performance reasons?
15:27:45 <prinsen> How do I disable 'defined but not used' errors of declared functions in GHC?
15:28:01 <darth_lumbergh> oh gawd, I googled that... now I have to read C++ :(
15:28:08 <dwcook> prinsen, did you see someone's answer earlier?
15:28:16 <prinsen> dwcook: no sry
15:28:31 <mornfall> darth_lumbergh: it's a pretty simple trick to avoid the costs of late binding
15:28:32 <prinsen> dwcook: well yes but they dont work
15:28:42 <prinsen> dwcook: as I use TH
15:28:52 <dwcook> prinsen, okay, try prepending _ to the identifier
15:28:57 <darth_lumbergh> is there a dumbed-down explanation so I don't have to make any effort to understand it? :D
15:29:01 <darth_lumbergh> *ducks*
15:29:04 <Cale> mornfall: Of course, it was claimed that they need to use C++ for performance reasons, but all their C++ code ends up being used via Excel which is hilariously slow at what it does anyway.
15:29:06 <mornfall> darth_lumbergh: mostly useful for statically optimized mixins
15:29:18 <prinsen> dwcook: isn't there a compiler flag?
15:29:25 <obiwahn> ls
15:29:27 <obiwahn> ls
15:29:30 <dwcook> prinsen, I don't know.
15:29:33 <mornfall> Cale: I wouldn't underestimate excel unless you have numbers to back that up.
15:29:44 <Cale> mornfall: Well, supposedly :)
15:30:00 <mornfall> I also somehow doubt excel is involved in inner loops. :P
15:30:13 <darth_lumbergh> you'd be surprised. and horrified
15:30:23 <mornfall> Cale: but I meant for CRTP and performance, not C++ as such
15:30:43 <joelteon> How do I enable -xc during a cabal test?
15:31:08 <mornfall> Indirect calls can get pretty expensive, especially because they also prevent inlining.
15:31:30 <dhrosa> :t id . (+)
15:31:31 <lambdabot> Num a => a -> a -> a
15:31:31 <mornfall> (And that screws over a whole lot of optimisations down the line.)
15:31:36 <dhrosa> :t (+1) . (+)
15:31:37 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
15:31:54 <dhrosa> > (+1) . (+) $ 0 2
15:31:55 <Cale> mornfall: Oh, I got the impression that they're just doing that wherever they're simulating having first class functions.
15:31:56 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> a))
15:31:56 <lambdabot>    arising from the ambiguity check for `e_1102'
15:31:56 <lambdabot>  from the context (GHC.Num.Num (a -> a),
15:31:56 <lambdabot>                    GHC.Num.Num a,
15:31:56 <lambdabot>                    GHC.Num.Num (a1 -> a),
15:32:01 <darth_lumbergh> that. is. awesome.
15:32:05 <dhrosa> woop
15:32:06 <Cale> Regardless of whether it's actually needed
15:32:16 <darth_lumbergh> one of my interview questions that nearly killed me: they asked what the type of (.) . (.) is
15:32:25 <darth_lumbergh> and no lambdabot :(
15:32:32 <darth_lumbergh> :t (.) . (.)
15:32:32 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:32:38 <darth_lumbergh> yes!
15:32:38 <mornfall> darth_lumbergh: typing is easy
15:32:39 <Cale> (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
15:32:52 <Cale> dang, lambdabot too fast
15:33:13 <Cale> It's easier to follow if you think of it as fmap . fmap
15:33:24 <Cale> and then specialise to the function instance :)
15:33:27 <mornfall> Cale: you can always do it mechanically you know
15:33:28 <darth_lumbergh> nothing's easy in a 3.5 hour interview when you don't really know the language...
15:33:36 <jfischoff> darth_lumbergh: that is a lame question
15:33:48 <mornfall> jfischoff: why?
15:33:49 <joelteon> also, how do I enable exception stack traces in ghci?
15:33:50 <Cale> I think it's kind of an okay question...
15:33:52 <joelteon> I used to know how to do that
15:34:23 <Cale> Certainly, given a bit of time, even if you don't already know what the type of (.) . (.) is, you ought to be able to work it out.
15:34:24 <darth_lumbergh> I think, as a newb, fmap . fmap would confuse me further because of adding the f type constructor into the mix (though I guess that's ->)
15:34:46 <jfischoff> mornfall: because you can be a useful Haskell programmer and not know it
15:34:47 <Cale> darth_lumbergh: Well, the thing is, it gets rid of some of the arrows temporarily
15:34:49 <mornfall> darth_lumbergh: fmap . fmap makes it less likely that you mix up the ->'s
15:34:58 <Cale> :t fmap
15:34:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:35:15 <jfischoff> I understand what it is testing, I guess I don't find it the most important test
15:35:18 <bitemyapp> :t (fmap . fmap)
15:35:19 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:35:28 <jfischoff> :t fmap fmap fmap
15:35:29 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:35:40 <Cale> fmap fmap fmap is one step too far ;)
15:35:48 <jfischoff> :D
15:35:51 <bitemyapp> :t join . fmap . fmap
15:35:53 <lambdabot>     Occurs check: cannot construct the infinite type:
15:35:53 <lambdabot>       f0 = (->) (f0 (f1 a0))
15:35:53 <lambdabot>     Expected type: (f1 a0 -> f1 b0)
15:35:58 <bitemyapp> kekekeke
15:36:44 <bitemyapp> jfischoff: nice meeting you last night! I'd really like a chance to further drain you of your knowedge though :)
15:36:45 <Cale> darth_lumbergh: But you can see how if fmap :: (a -> b) -> (f a -> f b), then you'd get  fmap . fmap :: (a -> b) -> (g (f a) -> g (f b))
15:36:57 <jfischoff> Cale: Some of the haskell programmers at work would struggle with that, but are able to write perfectly useful code
15:36:59 <mornfall> jfischoff: I'd say the question gives you a fair value for the cost
15:37:13 <mornfall> jfischoff: struggle with what?
15:37:14 <jfischoff> bitemyapp: yeah that
15:37:27 <dwcook> @type fmap (fmap fmap) $ fmap fmap
15:37:28 <lambdabot> (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
15:37:36 <jfischoff> how the end of the night goes, too fast
15:37:42 <jfischoff> mornfall: I'm guessing
15:37:45 <darth_lumbergh> Cale: yup, if I squint a fair bit!
15:38:33 <darth_lumbergh> but under interview pressure I was tied in a knot
15:38:35 <mornfall> jfischoff: well, if they did more than marginal amount of haskell, they sure know how terms are typed?
15:38:36 <Cale> darth_lumbergh: and then if you know that  f t = e -> t  where  fmap = (.)  is a possibility, you can get the thing you were after
15:38:53 <jfischoff> mornfall: No I don't think so
15:39:10 <Cale> darth_lumbergh: Right, I wouldn't expect you to just come up with that off the top of your head if you didn't already know it :)
15:39:22 <dwcook> darth_lumbergh, it could be useful to be able to do type inference in your head anyway
15:39:26 <mornfall> jfischoff: I'm not saying you are supposed to answer instantly, but with a pencil and a piece of paper you surely can work that out
15:39:27 <Cale> But I'm telling you just as a good way to think about it if it comes up again
15:39:45 <subleq> i'm struggling with how to derive the type of (.) . (.)
15:39:46 <dwcook> As someone mentioned, there is a perfectly mechanical method, one that a compiler might use, to type that expression
15:39:51 <darth_lumbergh> the kind of type inference we do in our heads seems much more efficient than HM...
15:39:53 <Cale> But yeah, there is a more mechanical approach to working out what the type should be
15:40:00 <dwcook> subleq, well look at the type of (.)
15:40:01 <bitemyapp> platz: I liked your response to the shitbag.
15:40:02 <dwcook> @type (.)
15:40:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:40:04 <darth_lumbergh> ...it sometimes goes wrong though :)
15:40:08 <subleq> what is the mechanical approach?
15:40:27 <mornfall> jfischoff: I'd go as far as say that you should be able to work the type out even if you don't know anything in particular about type systems as someone gives you a reasonable description of ->
15:40:30 <dwcook> Realize that the . in the middle is just infix application and you really have this: (.) (.) (.)
15:40:58 <dwcook> Now you need to find a, b, and c such that they fit the types of the values passed in
15:41:05 <Cale> subleq: give each subexpression a type variable, then use what you know to get a bunch of equations of type variables, and solve the equations to compute the type of the whole expression
15:41:28 <Cale> (this is roughly how type inference works)
15:41:34 <jfischoff> mornfall: I understand your argument, but my point is that knowledge of the type system does not equal value for a companies customer.
15:41:43 <dwcook> b has to be whatever's on the right side of the arrow in the type of (.), so, (b' -> c'), and c has to be what's on the left, so, (a' -> b') -> a' -> c'
15:41:47 <jfischoff> I would rather say, write a website
15:41:56 <darth_lumbergh> that would be my preferred approach
15:41:59 <mornfall> jfischoff: that solely depends on what you are hiring for
15:42:14 <dwcook> Substitute those in where they appear, then you just have to figure out what a is similarly
15:42:15 <jfischoff> then what is this type of this function, that I don't think anyone should use anyway
15:42:19 <platz> bitemyapp: hah thanks
15:42:45 <bitemyapp> platz: that's generally my attitude towards such assertions though. Things are easy when you're knocking down strawmen and facile CRUD crap.
15:42:46 <dwcook> Sorry, I wrote "right" and "left" in the wrong places. Switch them.
15:43:27 <monochrom> subleq: always use the mechanical approach. do not think. calculate.
15:43:51 <mornfall> jfischoff: but the answer is not why you ask -- the goal isn't to make something, but figure out if the candidate is good at doing certain things
15:43:59 <silasm> subleq: oh my god I love your nick.
15:44:12 <subleq> silasm: thank you
15:44:15 <bitemyapp> monochrom: mechanical? as in following the steps of a reduction?
15:44:16 <Earnestly> monochrom: do not think. repeat. ❤
15:44:19 <`Jake`> I personally find it somewhat helpful to think of (.) . (.) as fmap fmap fmap. But that might just be me
15:44:25 <darth_lumbergh> interviews aren't very scientific, the subconscious push towards hiring someone like yourself is strong
15:44:25 <monochrom> haha Earnestly
15:44:31 <jfischoff> @remember monochrom always use the mechanical approach. do not think. calculate.
15:44:31 <lambdabot> Done.
15:44:34 <darth_lumbergh> but I felt like I should've been able to answer that question!
15:44:44 <mornfall> darth_lumbergh: you indeed should have ;-)
15:45:16 <mornfall> darth_lumbergh: if you are going to work with someone, expertise is not the only important variable -- cohesion of the team you throw together is a factor too
15:45:55 <darth_lumbergh> mornfall: this is the elephant in the room though, teams have people of differing ability levels
15:46:49 <mornfall> darth_lumbergh: obviously, but you usually have to settle for someone you can have even if they fall short somewhere... as opposed to waiting forever for the perfect fit :-)
15:47:07 <mornfall> and some variance is good for everyone
15:47:07 <darth_lumbergh> if you're a rockstar, it's hard to understand how a "dumb" person can contribute
15:47:21 <athan> is there a way to specify that the argument of a function is of polymorphic airty but of a single type?
15:47:35 <merijn> athan: What does that mean?
15:47:47 <athan> like (Bool -> Bool) or (Bool -> Bool -> Bool)
15:47:51 <Cale> Even though I know it's meant to stand for "subtract and branch if less than or equal to", when I see "subleq" it makes me imagine some weird LaTeX relation symbol, something like "subset or less than or equal to"
15:47:56 <mornfall> darth_lumbergh: depends on priorities; I found that mentoring can be quite beneficial to both parties involved
15:48:01 <athan> but allowing an argument of any arity
15:48:06 <athan> the number of arguments
15:48:08 <merijn> athan: Ah, so variable number of arguments? No, not really
15:48:09 <jfischoff> athan: using a list if going to be the easiest thing
15:48:17 <merijn> athan: Unless you resort to typeclass hackery
15:48:43 <merijn> With 7.8 I could probably hack together something for this with closed type families, haven't tried yet :)
15:48:49 <darth_lumbergh> oh definitely, that was one of the reasons I applied for the job - being the dumb one is an opportunity to learn fast
15:48:52 <athan> like how lists work with a fully polymorphic type, you could have a list of functions of the same arity
15:48:53 <mornfall> darth_lumbergh: but when you are rushing for a deadline, it might not be the best thing to spend time on
15:48:54 <athan> hmm
15:49:08 <athan> i think typeclass hackery would make it possible, but lame
15:49:22 <dwcook> athan, what's the goal of doing this?
15:49:23 <merijn> athan: There's no other way to do it
15:49:45 <athan> you would have to supply an instance for 2-ary, 3-ary, 4-ary etc function
15:50:01 <athan> I just wanted to see if you could create general proofs
15:50:09 <Cale> athan: No, you just need one base instance and one "recursive step"
15:50:13 <athan> like, for instance, DeMorgans laws
15:50:17 <athan> in boolean logic
15:50:28 <darth_lumbergh> athan: couldn't you cook something up with TH?
15:50:46 <mornfall> darth_lumbergh: yuck
15:50:58 <darth_lumbergh> :)
15:51:09 <athan> and that way, I could accept any airty of a value and still validly prove that the expression holds to the laws
15:51:10 <dwcook> athan, it kind of sounds to me like a list would serve you well
15:51:10 <mornfall> you could surely cook something up with CPP too :P
15:51:14 <merijn> athan: No, you can to typeclass recursion, the typeclass hackery would only require 2 or 3 instances
15:51:21 <athan> I think that what I'm thinking of is a different kind of language...
15:51:38 <darth_lumbergh> I suppose with TH or CPP the type checker will still tell you it didn't work...
15:51:38 <merijn> athan: Although I guess it'd require an explicit "apply" function
15:51:42 <Cale> class Foo b where foo :: b;  instance Foo Bool where foo = ...;  instance (Foo b) => Foo (Bool -> b) where foo x = ...
15:52:11 <athan> idk
15:52:24 <Cale> ^^ this is essentially the trick which printf uses
15:52:33 <mornfall> it becomes a problem if your head grows too big :P
15:52:56 <Cale> > printf "%d ~~~ %s" 6 "Hello" :: String
15:52:57 <lambdabot>  "6 ~~~ Hello"
15:53:19 <Cale> :t printf
15:53:20 <lambdabot> PrintfType r => String -> r
15:53:30 <darth_lumbergh> why do you need the :: String?
15:53:41 <darth_lumbergh> because it thinks it's [Char]?
15:53:44 <Cale> because the result is also allowed to be an IO action or a function accepting more arguments
15:54:04 <darth_lumbergh> oh, :: binds more loosely
15:54:32 <mornfall> darth_lumbergh: [Char] and String are the same thing
15:54:42 <mornfall> (you could consider that a bug or a feature)
15:55:12 <darth_lumbergh> I mis-parsed that as printf ... ("Hello" :: String), hence the confusion
15:55:45 <dwcook> Function application binds more tightly than anything else that I'm aware of
15:55:59 <mornfall> > printf "%d"
15:56:00 <merijn> dwcook: Nope, only second tightest :)
15:56:01 <lambdabot>  No instance for (Text.Printf.PrintfType a0)
15:56:01 <lambdabot>    arising from a use of `e_1'
15:56:01 <lambdabot>  The type variable `a0' is ambiguous
15:56:01 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:56:01 <lambdabot>  Note: there are several potential instances:
15:56:07 <mornfall> blah
15:56:10 <dwcook> Hmm, what did I miss?
15:56:11 <mornfall> > printf "%d" :: String
15:56:12 <lambdabot>  "*Exception: Printf.printf: argument list ended prematurely
15:56:17 <merijn> dwcook: Record syntax :)
15:56:21 <dwcook> Oh, fun
15:56:43 <benmachine> function application binds more tightly than anything anyone cares about :P
15:56:50 <benmachine> (untrue, but not by much)
15:56:52 <merijn> dwcook: The effective fixities are: type annotation (-1), operator (0-9), function application 10, record syntax 11
15:56:56 <zipper> :t id
15:56:57 <lambdabot> a -> a
15:57:06 <jmob> darth_lumbergh, Who did you interview with that asked Haskell questions?
15:57:12 <darth_lumbergh> Barclays
15:57:16 <zipper> id is a weird function.
15:57:22 <merijn> zipper: How come?
15:57:24 <mornfall> zipper: how so?
15:57:45 * hackagebot markdown2svg 0.0.1.1 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.1 (YoshikuniJujo)
15:57:53 <zipper> I just didn't expect such to exist that's all.
15:58:06 <mornfall> @djinn a -> a
15:58:06 <lambdabot> f a = a
15:58:12 <bitemyapp> zipper: did you study lambda calculus at all?
15:58:20 <zipper> bitemyapp: No
15:58:35 <zipper> bitemyapp: I guess I can self study though.
15:58:43 <darth_lumbergh> I didn't take the job, but I did discover that I really like Haskell :)
15:58:47 <bitemyapp> zipper: it can help with your "intuition"
15:58:49 <merijn> darth_lumbergh: \o/
15:58:57 <zipper> bitemyapp: I understand f a = a easily though.
15:59:21 <zipper> darth_lumbergh: Barclays where>
15:59:23 <zipper> *?
15:59:30 <darth_lumbergh> London
15:59:34 <triliyn> zipper: there's never much of a reason to call id directly, but it can be useful to pass it into higher-order functions
15:59:35 <zipper> So much Haskell in Banking it seems.
15:59:37 <darth_lumbergh> Canary Wharf
15:59:38 <jfischoff> zipper: a good way to learn about the lambda calculus is write an evaluator in Haskell :)
15:59:54 <mm_freak> jle`: great, and for removing you use the same idea =)
16:00:09 <merijn> zipper: Yeah, there's Standard Chartered and a couple others
16:00:13 <mornfall> jfischoff: extra points for figuring out why you did it wrong :-)
16:00:14 <bitemyapp> > filter id [True, False, True, False, False]
16:00:15 <lambdabot>  [True,True]
16:00:16 <mm_freak> Taneb: it's tricky, because in 99% of all cases it's wrong to do it =)
16:00:20 <zipper> I listened to a podcast about this haskeller working for standard chartered.
16:00:31 <Taneb> mm_freak, oh?
16:00:34 <bitemyapp> zipper: Kmett?
16:00:36 <merijn> zipper: Lennart?
16:00:47 <merijn> bitemyapp: edwardk isn't at Standard Chartered last I checked
16:01:04 <zipper> Don Stewart
16:01:16 <mm_freak> Taneb: lifting a -> m b can easily violate FRP
16:01:26 <mm_freak> so in netwire it's not straightforward to do it
16:01:39 <zipper> triliyn: When would I want to pass it into a higher order function?
16:01:48 <mm_freak> Taneb: in fact in the new abstraction i'm currently working on the underlying monad is gone altogether
16:01:57 <merijn> zipper: All the banks using Haskell, combined with Simon Marlow and bos at facebook is good for haskell legitimacy when selling it to management :)
16:01:58 <Taneb> !
16:02:11 <merijn> zipper: This is a nice example:
16:02:11 <mm_freak> Taneb: i simplified 'Wire s e m a b' to 'Wire a b' =)
16:02:19 <bitemyapp> merijn: I can't remember all the banks people are at.
16:02:20 <darth_lumbergh> merjin: one of the interview questions was "how would you sell FP to management"!
16:02:22 <mornfall> merijn: well...
16:02:24 <prophile> mm_freak: how does it work?
16:02:26 <triliyn> zipper: the best example I can think of is if you have a list of functions a -> a and you want to compose them all
16:02:33 <merijn> :t foldr id [(+1),(/2),(*3)]
16:02:34 <lambdabot> Fractional a => [[a -> a] -> [a -> a]] -> [a -> a]
16:02:35 <zipper> merijn: I see no example
16:02:39 <triliyn> Like [(+1), (*8), (/2)]
16:02:43 <zipper> No I do
16:02:45 * hackagebot markdown2svg 0.0.1.2 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.2 (YoshikuniJujo)
16:03:00 <mm_freak> prophile: pretty much like netwire, except that it's much harder to violate FRP and it's orders of magnitude faster
16:03:02 <merijn> whoops, wrong one >.>
16:03:04 <merijn> I meant
16:03:09 <merijn> :t foldr id (.) [(+1),(/2),(*3)]
16:03:10 <lambdabot> Fractional ((b -> c) -> (a -> b) -> a -> c) => (b -> c) -> (a -> b) -> a -> c
16:03:15 <prophile> mm_freak: do you have source I could devour?
16:03:17 <merijn> :t foldr
16:03:19 <lambdabot> (a -> b -> b) -> b -> [a] -> b
16:03:21 <mm_freak> prophile: i focussed on simplicity instead of features you'll never use anyway
16:03:23 <merijn> oh, blah
16:03:23 <mm_freak> prophile: soon
16:03:23 <mornfall> merijn: fact that the elite of a particular language's community got jobs is hardly noteworthy :P
16:03:32 <merijn> :t foldr (.) id [(+1),(/2),(*3)]
16:03:33 <lambdabot> Fractional b => b -> b
16:03:41 <jfischoff> there you go ;)
16:03:53 <silasm> I've come to the conclusion that I don't want my friends to start programming Haskell because it's good, but rather because it's fun. The good design is just a bonus :P.
16:03:57 <merijn> zipper: The fact that "id" is the empty element for function composition works well with folds, for example :)
16:04:07 <darth_lumbergh> the fun is a well-kept secret, unfortunately
16:04:14 <merijn> zipper: There's other tricks like that
16:04:22 <prophile> mm_freak: without meaning to sound frantic about it, how soon?
16:04:24 <jfischoff> silasm: that's actually a better way to sell it I find
16:04:31 <zipper> merijn: I sadly just can't wrap my head around folds of all things in haskell
16:04:50 <zipper> but I am going through what you wrote
16:04:55 <merijn> > foldr (.) id [f,g,h]
16:04:56 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
16:04:56 <lambdabot>    arising from a use of `e_1'
16:04:56 <lambdabot>  The type variable `b0' is ambiguous
16:04:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:04:56 <lambdabot>  Note: there are several potential instances:
16:05:03 <merijn> aww
16:05:05 <merijn> > foldr (.) id [f,g,h] :: Expr
16:05:06 <jfischoff> zipper: think of it like this https://twitter.com/HaskellTips/status/427145320250613760
16:05:06 <lambdabot>  Couldn't match type `a0 -> b0' with `Debug.SimpleReflect.Expr.Expr'
16:05:08 <lambdabot>  Expected type: (b0 -> c0)
16:05:08 <mm_freak> prophile: i'm developing the new abstraction hand in hand with a small game, because i want to get the key points right for practical development…  netwire does a few things wrong
16:05:10 <lambdabot>                 -> Debug.SimpleReflect.Expr.Expr -> Debug.SimpleReflect.Expr....
16:05:12 <lambdabot>    Actual type: (b0 -> c0) -> (a0 -> b0) -> a0 -> c0Couldn't match expected t...
16:05:14 <lambdabot>              with actual type `a1 -> a1'
16:05:23 <mm_freak> prophile: in the next few days, as soon as the API has stabilized
16:05:39 <merijn> > foldr (.) id ([f,g,h] :: [Int -> Int])
16:05:41 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Int)
16:05:41 <lambdabot>    arising from a use of `Debug.SimpleReflect.Vars.f'
16:05:41 <lambdabot>  Possible fix:
16:05:41 <lambdabot>    add an instance declaration for
16:05:41 <lambdabot>    (Debug.SimpleReflect.Expr.FromExpr GHC.Types.Int)
16:05:47 <prophile> mm_freak: shiny, I don't suppose I could trouble you to keep me posted?
16:06:14 <silasm> jfischoff: yeah, the hard truth is that most people will probably only use it on personal projects anyways, and I think in that case it's more important that the language be fun than anything.
16:06:34 <mornfall> zipper: folds are simple, they just replace constructors with an operation
16:06:41 <zipper> jfischoff: Wow how cool. The way LYAH describes it as taking an accumulator which clearly it is not totally confused me.
16:07:04 <mornfall> zipper: if you have (1:2:3) folding it with (+) substitutes + for :, getting you (1+2+3)
16:07:08 <jfischoff> silasm: you can sell management on the idea its fun so ... you'll work more :p
16:07:19 <mornfall> zipper: the only tricky bit is getting the parentheses right I guess
16:07:23 <roboguy_> zipper: well it sort of is taking an accumulator, but I've always thought the substitution description is more clear
16:07:27 <jfischoff> zipper: yeah now think of the compose example
16:07:35 <merijn> zipper: "foldr (.) id [f,g,h]" -> "f . (foldr (.) id [g,h])" -> "f . g . (foldr (.) id [h])" -> "f . g . h . (foldr (.) id [])" -> "f . g . h . id"
16:08:08 <platz> I thought the substitution analogy only worked for right folds
16:08:09 <mm_freak> prophile: http://hub.darcs.net/ertes/wires
16:08:11 <mornfall> heh, I guess I just said what jfischoff's url says
16:08:19 <mm_freak> prophile: as soon as that URL starts existing, that's where you will find the source =)
16:08:20 <roboguy_> mornfall: you mean the right fold of 1:(2:(3:[])) with + and 0 gives you 1+(2+(3+0)) right
16:08:27 <prophile> mm_freak: grand, thanks :)
16:08:41 <merijn> roboguy_: Yes, the left fold starts with the 0 and ignores the []
16:09:05 <merijn> roboguy_: i.e. "(((0 + 1) + 2) + 3)"
16:09:50 <roboguy_> yeah
16:10:34 <mornfall> oh dear
16:10:38 <roboguy_> zipper: these might help right fold: http://www.haskell.org/haskellwiki/File:Right-fold-transformation.png left fold: http://www.haskell.org/haskellwiki/File:Left-fold-transformation.png
16:10:54 <mornfall> the cloud hit the ground
16:11:02 <bitemyapp> roboguy_: that only helps if you know what the hell a spine is
16:11:20 <merijn> zipper: Anyway, the idea was that if you're composing functions than "id" is a nice "0" element that doesn't do anything
16:11:20 <athan> Has anyone here read "the haskell road to logic, math and programming"?
16:11:23 <roboguy_> bitemyapp: I didn't know what the hell a spine was when I first saw them, and they helped me a lot
16:11:25 <bitemyapp> roboguy_: most people don't come tabula rasa with an understanding of how spines arise from lazy eval + recursion.
16:11:26 <mornfall> bitemyapp: you mean the stuff that holds you up?
16:11:46 <athan> Why did they use the symbol for bottom as the False constant in their logic syntax??!?
16:11:47 <silasm> does lambdabot have :sprint?
16:11:55 <silasm> actually that wouldn't make sense.
16:12:06 <mornfall> athan: because it's flipped T
16:12:07 <roboguy_> bitemyapp: the same concept works in strict languages with fold too
16:12:11 <mornfall> athan: and T is for True
16:12:11 <darth_lumbergh> isn't _|_ a bit like saying "never true" in logic?
16:12:13 <mm_freak> prophile: my pleasure…  this toy game will hopefully remove all doubt that haskell is a viable language for real-time 3D games =)
16:12:23 <athan> mornfall: :(
16:12:26 <darth_lumbergh> the word escapes me, but the opposite of a tautology
16:12:26 <prophile> hah
16:12:28 <prophile> lovely
16:12:31 <athan> mornfall: They should've just used false :(
16:12:34 <darth_lumbergh> contradiction
16:12:35 <silasm> darth_lumbergh: contradiction
16:12:38 <merijn> athan: Well, it's not so much False as "contradiction" in logic
16:12:39 <mornfall> athan: who's they?
16:13:06 <merijn> athan: Incidentally, contradiction and bottom are nicely related via Curry-Howard
16:13:08 <athan> merijn: ? What do you mean? Like a negation?
16:13:28 <athan> merijn: Oh wow, interesting... nevermind haha.
16:13:31 <merijn> athan: _|_ is the value of "not(A) v A"
16:13:44 <athan> merijn: ahh
16:13:49 <mornfall> athan: a /\ -a -> _|_
16:13:53 <merijn> eh
16:13:57 <athan> right
16:13:59 <merijn> I think I mean /\
16:14:07 <merijn> I suck at remembering which is and :)
16:14:10 <athan> yeah you're right
16:14:11 <mornfall> merijn: I hope you do :D
16:14:43 <athan> v is union
16:14:45 <darth_lumbergh> v looks like a U for Union :)
16:14:55 <merijn> athan: Basically (I don't have time to go into this, I'm going to bed) types in functional languages can be seen as a different view to view logical proofs in an intuitionistic logic
16:15:01 <mornfall> cap, cup, wedge, vee :-)
16:15:01 <darth_lumbergh> ^ looks like an A for AND
16:15:09 <darth_lumbergh> maybe that just makes it worse...
16:15:13 <subleq> phew, managed to work out (.) . (.)
16:15:16 <mornfall> darth_lumbergh: also, join and meet
16:15:33 <mornfall> darth_lumbergh: (which they incidentally are)
16:15:34 <merijn> athan: i.e. if "A -> B" is the logic "A implies B" then a function with "A -> B" can be seen as a proof of that implication
16:15:37 <athan> WOW
16:15:42 <subleq> (b'' -> c'') -> (a' -> a'' -> b'') -> a' -> a'' -> c'', right?
16:15:49 <subleq> @t (.) . (.)
16:15:49 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
16:15:55 <subleq> :t (.) . (.)
16:15:55 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:15:56 <merijn> athan: But if you google Curry-Howard (or ask around here) then there's a lot to read on this
16:15:58 <athan> merijn: Interesting!
16:16:09 <athan> merijn: Yeah, I really need to finish this book
16:16:24 <darth_lumbergh> I don't have the maths background to have come across join and meet, but I'll look it up...
16:16:26 <mornfall> merijn: care to give a good reference?
16:16:32 <athan> merijn: I've written some haskell programs here and there and understand the basics, but I really need to get this stuff
16:16:46 <athan> merijn: I can tell it will help me understand a lot more
16:16:50 <zipper> merijn: I have it I guess. foldr (.) id [(+1), (/2), (*3)] is (+1).(/2).(+3).id
16:16:56 <merijn> mornfall: I got most of this in lecture notes from courses, so don't really know any books
16:16:59 <merijn> zipper: Yeah
16:17:07 <athan> merijn: Thank you :) Good night! Sleep well!
16:17:17 <mornfall> merijn: bummer, we don't have anyone to teach that stuff here... sleep well, too
16:17:19 <zipper> merijn: Sadly after doing it I see no use case for it.
16:17:20 <roboguy_> folds are less difficult than they seem at first
16:17:30 <Sgeo> How does Racket's #lang frtime compare/contrast to Haskell FRP libraries?
16:17:34 <mornfall> darth_lumbergh: lattice is the keyword :)
16:18:18 <merijn> mornfall: I have "Proofs and Types" by Girard (translated by Taylor and Lafont), only read bits of it, but it seems to cover this in-depth
16:18:22 <mm_freak> Sgeo: depends on what frtime is/does
16:18:22 <darth_lumbergh> I would need to start somewhere before lattice
16:18:38 <zipper> merijn: (+1).(/2).(+3).id is (+1).(/2).(+3) since id will just return what it gets.
16:18:41 <Sgeo> It's a Racket language for FRP
16:18:41 <mornfall> darth_lumbergh: there's basically just sets before lattices
16:18:52 <darth_lumbergh> semi-lattices?
16:18:53 <merijn> zipper: Yes, but foldr needs a terminating case for empty lists
16:18:56 <merijn> :t foldr
16:18:57 <lambdabot> (a -> b -> b) -> b -> [a] -> b
16:19:03 <mornfall> darth_lumbergh: :D I don't think that'd help.
16:19:10 <Sgeo> http://docs.racket-lang.org/frtime/
16:19:14 <Sgeo> It's a bit low on examples :(
16:19:17 <merijn> zipper: Else what would it replace the [] with?
16:19:26 <zipper> merijn: I see it now
16:19:30 <mornfall> darth_lumbergh: Like with algebra, the less structured the stuff gets the more complicated it is to think/reason about.
16:19:30 <merijn> zipper: The fact that id does nothing is the entire point of using it in the fold :)
16:19:37 <Sgeo> And I'm not fond of the implication of needing a separate language... I'd need to read the source to see if it's usable as just a library
16:19:45 <roboguy_> zipper: there is also foldr1, but that only works on non-empty lists
16:20:11 <mm_freak> Sgeo: looks like a mixture between reactive-banana and yampa
16:20:23 <roboguy_> and also the type is a bit different
16:20:25 <roboguy_> :t foldr1
16:20:26 <lambdabot> (a -> a -> a) -> [a] -> a
16:20:27 <Sgeo> I don't know either well enough :(
16:20:33 <darth_lumbergh> mornfall: I get the feeling I'd have an easier time relating it to programming examples
16:20:52 <mm_freak> Sgeo: you seem to get reactive-banana's first class behaviors and events as well as yampa's real time signal functions (integral, for example)
16:21:35 <darth_lumbergh> e.g. monoids for summing a list of numbers
16:21:38 <mornfall> darth_lumbergh: I find that idea somewhat dubious -- in some ways, worrying about computability is a curse
16:21:52 <mm_freak> Sgeo: the overall design looks a lot like reactive-banana
16:22:26 <levi> Hrm, I recall some lecture notes from some well-known Haskeller (Wadler perhaps?) on domain theory that had a very approachable description of basic ordering/lattice stuff.
16:22:37 <mm_freak> Sgeo: it even includes the 'changes' hack
16:22:47 * hackagebot purescript 0.3.10 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.10 (PhilFreeman)
16:23:03 <Sgeo> A brief glance at the code had a lot of reimplemented functions and macros :( like they were copy-pasted. Racket languages can redefine what function application syntax mean, but HOFs defined elsewhere don't pick up on the new meaning, which sucks
16:23:28 <Sgeo> mm_freak: changes hack?
16:23:30 <bitemyapp> Sgeo: Racket was pretty unprincipled anyway.
16:23:39 <mm_freak> Sgeo: i believe that you will get a much nicer experience with a haskell FRP library, and probably a lot better performance as well
16:23:51 <mm_freak> Sgeo: FRP is just something non-static languages handle very badly
16:23:53 <Sgeo> But I'm on a Racket kick right now :(
16:24:05 <bitemyapp> Sgeo: tell me what you want and I will free you :P
16:24:18 <mm_freak> Sgeo: changes :: Behavior a -> Event a
16:24:24 <mm_freak> Sgeo: this function is wrong
16:24:27 <levi> Oh, it was Graham Hutton.
16:24:57 <mm_freak> Sgeo: but reactive-banana and the very similar sodium define it to make it easier to interface the (pure) reactive formulation to the (impure) real world
16:25:02 <levi> darth_lumbergh: http://www.cs.nott.ac.uk/~gmh/domains.html
16:25:47 <darth_lumbergh> thanks :)
16:26:26 <ksira> hi all
16:27:28 <Sgeo> handle very badly... because of a culture that thinks some bad ideas are good, rather than for any technical limitation that makes static languages work better?
16:27:33 <Sgeo> I can imagine that
16:27:59 <mornfall> levi: uh oh :-)
16:28:03 <Sgeo> People trying to translate monads to dynamically typed languages often seem to think that implicit joins depending on the type of the value is a good idea
16:28:11 <levi> mornfall: Hmm?
16:28:35 <mm_freak> Sgeo: both…  the lack of type information makes your code both slower and less safe
16:28:56 <mornfall> levi: I'm not sure I'd exactly call that introduction to basic ordering/lattice stuff.
16:29:10 <mm_freak> Sgeo: in the case of FRP the speed difference is very noticable…  it's difficult enough to write a fast FRP abstraction
16:29:14 <Sgeo> Typed Racket is a thing that exists... but it bends over backwards to allow typing of idiomatic Racket
16:29:48 <mornfall> levi: unless I picked the wrong pdf, anyway
16:29:48 <Sgeo> Plus, not sure how to get different Racket languages to compose. Pretty sure it's possible to mechanically combine them, at least
16:29:55 <Sgeo> Maybe
16:30:04 <mm_freak> Sgeo: one thing you will notice when switching to a typed language is that 'signal' is gone
16:30:10 <levi> mornfall: Well, it talks about partially ordered sets anyway.
16:30:36 <mornfall> levi: Sure, but it starts out pretty complex... lattices are simple.
16:31:04 <Sgeo> I only noticed today that %/fcomplete are the syntax I've been dreaming of for monads, I... think
16:31:07 <Sgeo> Need to test it out
16:31:19 <mornfall> levi: I acknowledge the desire to motivate lattices as a semantic playground, but you don't really need to.
16:31:29 <roboguy_> Sgeo: %/fcomplete?
16:31:40 <Sgeo> Do people in languages with first-class continuations tend to notice they really, really do not need to emulate Haskell's do? I think not
16:31:40 <levi> mornfall: I guess I never went looking for a description of *just* lattices.
16:32:18 <Sgeo> Haskell has do, therefore do is the best syntax sugar for monads in any language, no matter what features that language may offer that Haskell doesn't
16:32:44 <Sgeo> roboguy_: A pair of operators for delimited continuations
16:32:48 * hackagebot markdown2svg 0.0.1.3 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.3 (YoshikuniJujo)
16:33:13 <Sgeo> % delimits, and takes in a 'handler' function, which receives a value and a continuation, fcontrol sends the current continuation and a value to the handler
16:33:19 <mornfall> levi: I don't need to justify an object if it's pretty. :-) Or at least somewhat elegant.
16:33:43 <Sgeo> If I understand it properly
16:33:47 <Sgeo> I really should experiment with it
16:33:55 <darth_lumbergh> levi: maybe it's the time of night, but I ran aground on page 5
16:33:56 <roboguy_> Sgeo: hmm, how do you feel about haskell's delimited continuations?
16:34:09 <levi> mornfall: I am not trying to justify it. That is just the context I learned about lattices in.
16:34:20 <darth_lumbergh> not really grokking what "comm" is
16:34:37 <mornfall> levi: What I *would* want to see justified is the horrible [[ ]] notation :D
16:34:50 <mornfall> levi: I don't know who invented it or why, but it always irked me.
16:35:05 <darth_lumbergh> oxford braces?
16:35:10 <Sgeo> roboguy_: I think you can't get a continuation in Haskell from just inside any expression, but only from (>>=)
16:35:10 <Cale> which horrible [[ ]] notation?
16:35:21 <mornfall> Cale: for semantic functions
16:35:30 <Sgeo> (Or similar functions, but (>>=) means you get to use do to express continuation-enabled code
16:35:36 <mornfall> I guess the idea is to avoid confusion of metalevels.
16:35:40 <Cale> Why does it bother you?
16:35:56 <Cale> Would you prefer a more usual sort of functional notation?
16:35:57 <mornfall> Can't tell, really. Maybe I just have bad childhood memories. :-)
16:36:13 <levi> darth_lumbergh: Just skim over that bit, it's introducing the problem that the theory he's going to introduce just after was meant to solve.
16:36:18 <mornfall> I mean I can't pinpoint anything that'd be really wrong with it.
16:36:27 <Sgeo> mornfall: I'd prefer a notation where you marked not the 'pure' values with a function to make them impure, but the 'impure' values. (Sorry for the imprecise terminology)
16:36:53 <Cale> It's sometimes very necessary to avoid confusion, because your language often contains symbols which also appear in your metatheory.
16:36:54 <roboguy_> Sgeo: that depends on what you mean, I guess. You can use Cont
16:36:59 <Sgeo> Let me see if I can write an example with %/control
16:37:42 <mornfall> Cale: Obviously. But the [[ ]] braces feel pretty ad-hoc about that. I think I have seen some author(s) underline metasymbols, eg.
16:38:05 <Cale> Well, you can invent anything you like as a delimiter
16:38:28 <levi> darth_lumbergh: The bit about bottom and ordering starts on page 11 (1.9)
16:38:44 <Sgeo> I feel like Racket is excellent for syntactic manipulation, but... not so excellent at normal programming
16:38:45 <Sgeo> :(
16:39:28 <levi> I thought it was pretty reasonable for normal programming back when I used it for some normal programming.
16:39:32 <obiwahn> mh
16:39:43 <obiwahn> lbot gave me:   Could not find module `SimpleReflect'
16:39:45 <Sgeo> It doesn't even have a lens library yet :(
16:39:51 <darth_lumbergh> levi: gotcha, that symbol is like "subtype of"
16:40:03 <roboguy_> Sgeo: I was actually thinking about that earlier. it would probably need type classes first
16:40:06 <obiwahn> how i have build all the ghc and libs in the user's home
16:40:07 <levi> darth_lumbergh: Subtyping is just another kind of ordering.
16:40:36 <levi> There are lots of different kinds of orderings.
16:40:43 <Sgeo> roboguy_: for some representations of lenses, maybe?
16:40:58 <Sgeo> Because there's the trivial one: struct containing get and modify functions
16:41:31 <roboguy_> Sgeo: that's true. you can get some extra things that are nice with the Functor/Applicative representation though
16:41:43 <levi> darth_lumbergh: top and bottom in a subtyping ordering are different than the top and bottom in a "definedness" ordering such as he's talking about there.
16:41:47 <Sgeo> I don't know enough about lenses to grasp those
16:42:01 <mornfall> Cale: I have always felt like math notation could use a little more "type discipline" if you will...
16:42:02 <Sgeo> I don't consider being able to use standard compose to be 'nice enough'
16:42:18 <Sgeo> To make it worth the representation
16:42:20 <roboguy_> Sgeo: it's not really as complicated as it looks. at least the basics aren't
16:42:22 <Sgeo> There may be other things though
16:42:40 <darth_lumbergh> levi: there's still a correlation right? undefined/bottom is substitutable for other values, so it's technically a subtype of everything
16:42:48 <levi> I mean, they're the same in the sense that they represent the same sort of element in the ordering, but different in that the ordering is a different one.
16:42:52 <mornfall> Cale: (incidentally the notes levi linked seem to do fairly well in that respect)
16:43:50 <Cale> mornfall: Well, that notation is itself a kind of type discipline, isn't it? We're being explicit about what is part of our formal language, and what is a statement about the interpretations of those.
16:43:58 <roboguy_> you also get polymorphic updates, but I guess that doesn't really matter in a dynamically typed language
16:44:19 <Cale> mornfall: Or are you saying that you'd like the interpretation brackets themselves to be indexed explicitly by the type of expression we're interpreting?
16:44:28 <levi> darth_lumbergh: bottom is a value, though; subtyping talks about types.
16:44:28 <bitemyapp> jfischoff: ;_; you are killing me
16:44:42 <mornfall> (another point of aversion to semantic functions that I have is that half the time when someone starts using that, they are just being uselessly verbose *and* making up shit anyway)
16:44:47 <bitemyapp> jfischoff: I would've mentioned you in the tweet I made earlier but I was out of characters.
16:44:51 <jfischoff> bitemyapp: ?
16:45:02 <Cale> mornfall: I'm not sure where you get that from :)
16:45:25 <levi> darth_lumbergh: There is a value 'bottom' that inhabits all types. Kind of like there's a Nil that inhabits all polymorphic lists.
16:45:32 <mornfall> Cale: Yes, the brackets are a kind of type discipline in the sense I meant. Which is a point in their favour.
16:45:39 <bitemyapp> jfischoff: I had just gotten done showing off the sequence thing to J and K users for the same exact inputs.
16:45:44 <Cale> mornfall: We're interpreting the language in what will hopefully be some model, and often what they do will be very nontrivial.
16:45:48 <jfischoff> heh
16:45:55 <Cale> (but hopefully still compositional!)
16:46:05 <jfischoff> never thought of that before
16:46:20 <bitemyapp> jfischoff: sequence is like half of how I explain monads to people.
16:46:38 <jfischoff> hmm
16:46:42 <bitemyapp> jfischoff: especially to Clojurians who already have juxt.
16:46:53 <jfischoff> I've never explained a monad to anyone actually
16:46:57 <mornfall> Cale: Maybe from reading too many theses where people promise semantics that never correspond (most often even remotely) to what they actually implemented.
16:47:02 <darth_lumbergh> levi: right - coming from Scala, it's hard not to think of bottom having its own type (Nothing) which subtypes everything else
16:47:19 <Cale> mornfall: hmm, okay
16:47:20 <defanor> i want to play with agda or idris, but can't pick one (and not sure if will have enough time for both in the nearest future); ideally, i'd like to use them in practice (for "real" programming tasks), stating and proving some theorems about functions, and looks like idris is aimed to be more "practical" (and has a nice C FFI, which i have not found in/for agda), but agda's approach seems more strict, which i like more, and also it seems
16:47:21 <defanor> more mature. oh, and there's also ivor for haskell, and smth about dependent types simulation in haskell (but the latter sounds like a hack). what would you guys suggest?
16:47:25 <bitemyapp> jfischoff: rephrase: I try to avoid "explaining" monads and instead just demonstrate/elaborate on how they work.
16:47:43 <bitemyapp> jfischoff: it's not a one-off thing, it's just part of an overall typeclasses overview.
16:47:49 <Cale> mornfall: I'm coming at that sort of notation from seeing it in the context of formal logic / model theory
16:47:50 * hackagebot markdown2svg 0.0.1.4 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.4 (YoshikuniJujo)
16:47:54 <jfischoff> bitemyapp: I mean no one has ever asked me really, I've never had to
16:48:11 <mornfall> Cale: It turns out that mapping out normal-+ to meta-+, etc., can take many pages without costing much to type.
16:48:13 <levi> darth_lumbergh: Well, there's a different bottom in the subtyping relation and of course if you're interpreting types as semantic domains, it has a bottom *value* as well, because all types are inhabited by the bottom value.
16:48:45 <darth_lumbergh> levi: yup, makes sense
16:48:54 <bitemyapp> jfischoff: people who hear about it via the internets, especially people who think they're already secure in FP knowledge due to knowing Clojure can be touchy about it sometimes
16:49:08 <Sgeo> Ok, so apparently, I don't actually understand fcontrol :(
16:49:17 <levi> darth_lumbergh: (I had the same thought when I read about subtype ordering, and it took me a while to realize that the domain bottom was not quite the same thing)
16:49:33 <mornfall> Cale: I know the notation is pretty much innocent. :)
16:49:37 <Cale> mornfall: Well, the fun bit is where you start interpreting the primitives in your language by more involved operations, like maybe + turns into some kind of convolution operation involving an integral or something
16:49:47 <Cale> and then it becomes really important that the double brackets are there
16:50:14 <jfischoff> bitemyapp: yeah I'm just realizing I don't know how I would explain a monad. I like join and fmap, but that's not how we use them
16:51:08 <jfischoff> I think I wouldn't, I would just talk about a few concrete instances, Maybe, [], IO or something, its not important to know what they are at first really, at least thats what I think.
16:51:13 <bitemyapp> jfischoff: my favorite trick is round-tripping from fmap -> <*> (list comprehensions) -> mempty/mappend/mconcat -> join (mention mconcat) + fmap to bind -> then sequence [] and Traversable sequence.
16:51:14 <levi> darth_lumbergh: Anyway, to bring this full circle, consider a 'truth' ordering. What are top and bottom in that context?
16:51:23 <bitemyapp> jfischoff: I use Maybe and [] primarily when explaining them
16:51:37 <darth_lumbergh> true and false?
16:51:43 <bitemyapp> jfischoff: especially Maybe as it's useful to make them stop thinking about "collections" and more about non-determinism and inversion of control.
16:52:17 <mornfall> bitemyapp: non-determinism is a dangerous term :)
16:52:36 <tommd> Only sometimes.  You can't count on it being dangerous.
16:52:43 <bitemyapp> mornfall: uncertainty at compile-time.
16:52:47 <enthropy> Cont is absent
16:53:04 <bitemyapp> mornfall: you can't know statically if a (Maybe a) will necessarily be Just or Nothing, if you're using it right.
16:53:18 <bitemyapp> mornfall: you generally don't know statically if a [] will have 0, 1, or infinity elements.
16:53:30 <mornfall> bitemyapp: you often can
16:53:36 <mornfall> bitemyapp: even if you are using it right
16:53:39 <bitemyapp> mornfall: you're missing the point
16:53:47 <mornfall> bitemyapp: maybe :-)
16:53:53 <Sgeo> Is there a term for monads where bind only ever uses its function argument at most once? (As in, no f 1 then f2 etc, list monad is right out)?
16:54:06 <mornfall> (statically is another dangerous word :D)
16:54:08 <Sgeo> Because such monads can be modeled with just coroutines, I think
16:54:08 <bitemyapp> mornfall: the point is to straw a line in the sand for statically deterministic/known things vs. things that are best interacted with via IOC
16:54:15 <Aetherspawn> sigh
16:54:21 <rntz> Sgeo: hm, interesting hypothesis
16:54:21 <Aetherspawn> just got an error higher than my terminal from lens
16:54:25 <obiwahn> ion: still there?
16:55:04 <shachaf> imo "affine"
16:55:08 <mornfall> Aetherspawn: rename lens to boost.haskell and sell it ten bucks apiece :P
16:55:23 <bitemyapp> jfischoff: Haskell tips has 2.5x the followers Clojure Tips has.
16:55:34 <Aetherspawn> I dislike the overengineering of types
16:55:38 <ion> obiwahn: Kinda. I’m not too far from falling asleep.
16:55:43 <levi> darth_lumbergh: For standard boolean logic, yeah. I imagine there are other logics in which there are still a top and bottom but maybe they aren't the only values in the relation.
16:55:47 <bitemyapp> Aetherspawn: I don't think Lens is overengineered.
16:56:00 <Aetherspawn> lots of libraries are starting to *require* lens to use
16:56:06 <darth_lumbergh> levi: SQL comes to mind...but not long enough to do much damage
16:56:08 <Aetherspawn> and errors are slowly getting bigger and more unreadable
16:56:09 <Sgeo> Just because Haskell types can lead to ugly errors, doesn't mean all type systems similar to Haskell's must have ugly errors
16:56:21 <Sgeo> Although, I don't have any ideas on how to fix that
16:56:27 <mornfall> you know, this really does remind me of C++ :-)
16:56:29 <Aetherspawn> ie, how am I supposed to read this
16:56:30 <Aetherspawn> http://lpaste.net/99620
16:56:32 <jrmithdobbs> lens is a great example of minimalism i think, it's concept just apply broadly so having instances of all of it for everything is handy
16:56:41 <jrmithdobbs> s/apply/applies/
16:56:58 <obiwahn> ion: i have real trouble with lambda bot i try now for several hours
16:57:06 <obiwahn> lambdabot@serv:~/.cabal/bin
16:57:07 <levi> Functor is so overengineered. It's everywhere!!
16:57:07 <obiwahn> » ./mueval-core
16:57:09 <obiwahn> Ambiguous module name `Control.Monad.Cont':
16:57:22 <roboguy_> Sgeo: I don't think that's really a haskell monad
16:57:24 <obiwahn> is that something that is ok?
16:57:49 <Aetherspawn> you make fun of it, but the general populus of programmers will throw their computer out the window if they get an error like this
16:57:52 * hackagebot tidal 0.2.13 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.2.13 (AlexMcLean)
16:57:54 <Sgeo> roboguy_: hmm?
16:57:59 <Aetherspawn> C++ errors are easier to read than is as much as you mock it.
16:58:06 <roboguy_> Sgeo: the using a function argument once thing
16:58:06 <Sgeo> I didn't paste the not quite a monad code I just wrote, so... ?
16:58:15 <ion> obiwahn: Perhaps try using ghc-pkg to hide one of the installed packages that provide Control.Monad.Cont. Perhaps someone else has a better idea of what’s going on.
16:58:15 <rntz> Aetherspawn: that is a pretty terrifying error, yeah
16:58:23 <rntz> although I have definitely seen worse C++ errors
16:58:45 <roboguy_> Sgeo: I don't think there's a way to guarantee that
16:58:46 <Cale> Aetherspawn: This sort of error is precisely why I have extreme reservations with even mentioning pipes to beginners.
16:58:50 <Sgeo> roboguy_: f 1, not allowed to apply f to anything else. Sure, a bit silly to say in Haskell, but afaict has implications in languages with coroutines but not first-class continuations
16:58:57 <Sgeo> roboguy_: but we can name monads that behave like that:
16:59:02 <Sgeo> Identity, Maybe
16:59:13 <obiwahn> and the anwser to > 4 + 4 is: Could not find module `SimpleReflect'
16:59:22 <jrmithdobbs> Aetherspawn: template compile errors even? that's a pretty rude accusation ;p
16:59:36 <Cale> Aetherspawn: but at the same time, you can probably gloss over most of the error message, and just look at the line number
16:59:40 <jrmithdobbs> (they're about the same level of line noise or worse, tbqh)
16:59:45 <roboguy_> Sgeo: hmm, I'm not sure I follow... what do you mean you're not allowed to apply f to anything else?
17:00:09 <mornfall> jrmithdobbs: when was the last time you've seen a template compile error? :P
17:00:11 <Aetherspawn> I've written a library for pipes and all the rewrite rules for shortcut fusion yadda yadda
17:00:14 <rntz> roboguy_: in the definition of (k >>= f), you are allowed to call f at most once
17:00:15 <jrmithdobbs> Cale: ya skim the whole thing looking for an extension suggestion first, then a needed type specification, *then* read the error ;p
17:00:15 <Aetherspawn> I now fail to write an example for it
17:00:19 <jrmithdobbs> especially with lens
17:00:21 <mornfall> jrmithdobbs: it's not 2005 anymore
17:00:22 <Aetherspawn> >.<
17:00:23 <bitemyapp> copumpkin: I'd thought you'd already followed me for some reason.
17:00:26 <rntz> iiuc
17:00:41 <bitemyapp> copumpkin: maybe you got tired of my trolling? :P
17:00:43 <Sgeo> Maybe I should describe my thinking... in do { a <- m1; b <- m2; return c}, not allowed to revisit m1 after having gone past it
17:00:48 <copumpkin> bitemyapp: hey, I don't put out on the first date
17:00:50 <roboguy_> rntz: are you sure?
17:00:58 <Cale> Aetherspawn: So what type does 'decoded' have?
17:01:04 <rntz> roboguy_: hm? that's what I think Sgeo is talking about, yes.
17:01:05 <Aetherspawn> its from pipes-binary
17:01:09 <fragamus_> @pl (\x->(x^2,x/2))
17:01:09 <lambdabot> liftM2 (,) (^ 2) (/ 2)
17:01:16 <roboguy_> rntz: oh. I thought you meant in general
17:01:17 <bitemyapp> copumpkin: I just noticed your followers. I knew you were well known in the FP community, but what the *fuck* man?
17:01:19 <dwcook> Sgeo, what use would a term for that be?
17:01:21 <rntz> roboguy_: no no no
17:01:26 <levi> Aetherspawn: That error doesn't look that bad. The first two lines tell you the high-level types.
17:01:45 <Sgeo> dwcook: It would describe monads that can have a nice syntax sugar in languages that have coroutines but not first-class continuations
17:01:53 <roboguy_> Sgeo: you might be able to have something like that, I'm not sure. that might not be a monad though
17:02:01 <Sgeo> e.g. a = yield m1; b = yield m2;
17:02:05 <roboguy_> (i.e. something that obeys the monad laws)
17:02:18 <rntz> roboguy_: um, this isn't about "a thing" that is a monad. it's about a class of definitions of monads.
17:02:52 <Sgeo> roboguy_: for Maybe, ma >>= f, the result of that either calls f zero or one times
17:03:07 <Aetherspawn> here's the actual code http://lpaste.net/99622#line92
17:03:13 <roboguy_> Sgeo: true, but you can use ma again later if you want to
17:03:25 <roboguy_> rntz: ok, now I really don't think I follow
17:03:47 <jrmithdobbs> Aetherspawn: anyways, that error isn't so bad, you've got something swapped around in your calls probably ... you passed an Either a b instead of a PushWorkReply
17:03:49 <rntz> roboguy_: okay. call any monad whose definition of (k >>= f) calls f at most once "affine".
17:04:10 <Sgeo> The list monad is not affine. The maybe monad is affine
17:04:11 <rntz> that's it. that's all I am trying to convey. that one can separate monads into those which may call f more than once, and those which don't.
17:04:29 <roboguy_> alright
17:05:06 <rntz> you can also make a distinction between linear monads and affine monads, I think. linear being "calls f exactly once", eg. State.
17:05:18 <rntz> it seems like linear monads can't add error-like functionality?
17:05:29 <rntz> because you have to call the continuation, you can't bail out somewhere else
17:05:38 <rntz> but that's a very informal statement
17:05:44 <jrmithdobbs> rntz: yes you can
17:05:56 <rntz> jrmithdobbs: explain?
17:05:59 <jrmithdobbs> unless you consider fail a continuation for some odd reason
17:06:20 <rntz> oh, I typically pretend fail doesn't exist
17:06:27 <rntz> it's a hack, it's not actually part of what monads are
17:06:35 <levi> Aetherspawn: Just a guess; maybe there's a precedence problem? I would try breaking that into smaller and more explicit pieces, then figure out the right way to put them back together.
17:06:37 <jrmithdobbs> rntz: right well this is why it does' it just sucks that it takes a [Char]
17:06:45 <jrmithdobbs> s/,/,/
17:06:48 <jrmithdobbs> s/'/,/
17:07:10 <Aetherspawn> looks like encode is the wrong type
17:07:21 <Aetherspawn> I broke it up into
17:07:23 <Aetherspawn> view decoded (recieve endp) >-> P.map doWork >-> for cat encode >-> send endp mast
17:07:29 <Sgeo> rntz: does IO count as linear or not linera?
17:07:31 <Sgeo> linear
17:07:44 <rntz> IO isn't definable, it's magic, so the definition doesn't even apply
17:08:16 <Sgeo> Yet I'm having trouble imagining IO being non-affine
17:08:19 <jrmithdobbs> i like how by the time you understand the crappy IO analogies you realize why they're all crappy (magic)
17:08:24 <mm_freak> rntz: IO is definable
17:08:34 <ParahSailin> @src IO
17:08:35 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:08:41 <jrmithdobbs> mm_freak: oh?
17:08:51 <rntz> Sgeo: well, it doesn't backtrack, but it can "error out" (eg. exitWith)
17:09:00 <mm_freak> data IO :: * -> * where GetLine :: IO String; PutStrLn :: String -> IO (); …
17:09:00 <ParahSailin> well, its defined in ghc.base anyway
17:09:12 <rntz> so it "feels like it is" affine but not linear. but the "how is >>= defined" definition doesn't really apply.
17:09:20 <Cale> ParahSailin: That "implementation" is a cheat though.
17:09:27 <mm_freak> i mean a real definition, not the internal State# stuff of GHC's implementation
17:09:33 <FreeFull> The IO as AST analogy is handy
17:10:08 <Cale> GHC's implementation is to cheat and use impure functions whose domain is an empty type :P
17:10:13 <mm_freak> it's not just handy…  you could actually implement IO that way
17:10:17 <rntz> mm_freak: you get into trouble with IORefs.
17:10:21 <mm_freak> rntz: no
17:10:37 <Aetherspawn> whats the opposite of view
17:10:40 <Aetherspawn> in lens
17:10:43 <Cale> set
17:10:48 <Axman6> rntz: and forkIO surely
17:11:04 <Aetherspawn> so if I have an Iso like decoded and I want to run the encoding rather than the decoding
17:11:05 <Aetherspawn> I'd use set?
17:11:07 <rntz> Axman6: nah, you can just emulate having multiple processes. mm_freak , iiuc, is talking about "emulating" IO entirely inside haskell.
17:11:20 <mm_freak> rntz: it's not emulation
17:11:34 <rntz> mm_freak: does it actually print to the screen? if not, it is emulation.
17:11:37 <mm_freak> the RTS is an interpreter for a small DSL called IO
17:11:42 <dwcook> You don't have to include the runtime system in the definition of IO within Haskell
17:12:01 <rntz> okay now we are just arguing about terminology
17:12:03 <mm_freak> rntz: then every interpreted language is just emulation
17:12:08 <Eduard_Munteanu> Aetherspawn: use from
17:12:09 <Eduard_Munteanu> :t from
17:12:10 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
17:12:13 <mm_freak> there is nothing wrong with implementing IO as above
17:12:28 <rntz> oh, now I see what you are saying.
17:12:29 <jrmithdobbs> edwardk's blog posts about free monads (the 'for less' series) ends in a very interesting discussion of alternate ways of implementing IO for haskell-like languages, i think
17:12:29 <FreeFull> You could
17:12:32 <Eduard_Munteanu> :t view . from
17:12:33 <lambdabot> MonadReader a m => AnIso s s a a -> m s
17:12:38 <FreeFull> Although AFAIK GHC does something cleverer
17:12:38 <Cale> Aetherspawn: if you want to run the Iso in reverse, you can apply 'from' to it
17:12:49 <mm_freak> FreeFull: no, it does something faster =)
17:12:50 <Cale> Aetherspawn: which will get you the Iso in the other direction
17:12:53 <rntz> okay, but that is not an "implementation" of IO in the same way that State is an implementation of statefulness.
17:12:53 <Aetherspawn> hmm, it's not in lens-family-core
17:12:57 <rntz> it is merely a representation of an AST
17:13:09 <Cale> Aetherspawn: Oh, you're not using lens?
17:13:15 <FreeFull> mm_freak: Cleverer in that sense
17:13:16 <rntz> that's interesting but completely irrelevant to the current discussion
17:13:20 <jrmithdobbs> Aetherspawn: why aren't you using lens?
17:13:22 <Aetherspawn> I was told it would be OK to use lens-family-core
17:13:25 <mm_freak> rntz: why not?  state does not require an actual mutable memory cell…  state is just a concept
17:13:28 <Eduard_Munteanu> Aetherspawn: also look at wrapped / unwrapped if you're working with a newtype wrapper
17:13:32 <Aetherspawn> since its a lighter dependency
17:13:35 <Eduard_Munteanu> :t wrapped
17:13:36 <lambdabot> (Functor f, Profunctor p, Wrapped s t a b) => p a (f b) -> p s (f t)
17:13:58 <jrmithdobbs> Aetherspawn: yes, isos/prisms require profunctors and bifunctors and stuff so you can't avoid the deps
17:14:05 <rntz> I'm not going to continue this discussion. I'm not certain whether I'm being trolled but it's certainly not worth my time. sorry.
17:14:08 <FreeFull> mm_freak: On the other hand, all monads are representable by a free monad AST and then something to run it
17:14:15 <mm_freak> rntz: it's not irrelevant…  my point is that IO is just magic to be fast…  there is no inherent reason for it to be magic
17:14:16 <jrmithdobbs> Aetherspawn: and most interesting uses of lens require the use of isos/prisms ;p
17:14:36 <Aetherspawn> hmm, the error is now 3x the height as befoer.
17:14:38 <Aetherspawn> :P
17:14:39 <zipper> I heard in a podcast (the haskell cast). "If you need to find the 5th element in a list then you should be using another data structure" Which one would be good for such and why is a list so bad?
17:14:44 <jrmithdobbs> mm_freak: it doesn't even need to be magic to be fast was my point
17:14:45 <jrmithdobbs> heh
17:14:52 <mm_freak> indeed =)
17:14:58 <mm_freak> the GADT approach would actually be a fast IO
17:15:09 <Cale> zipper: Arrays, perhaps
17:15:19 <Cale> zipper: Or Vectors, or Maps
17:15:20 <Eduard_Munteanu> zipper: lists are bad for random access patterns
17:15:23 <FreeFull> zipper: Depends what you're doing
17:15:24 <dwcook> mm_freak, would extensibility of IO be an issue? e.g., FFI
17:15:25 <mm_freak> but GHC's implementation replaces a huge pattern match by a simple data dependency, which makes it a lot faster and a lot more compact
17:15:31 <dwcook> (under the GADT interpretation)
17:15:37 <Cale> zipper: xs !! n takes O(n) steps to reduce
17:15:38 <zipper> Eduard_Munteanu: What are they good for?
17:15:48 <Cale> zipper: and it might just crash, if the index is out of bounds
17:15:52 <bitemyapp> if your access pattern doesn't resemble "streaming" you probably don't want []
17:15:53 <hpc> more generally, needing the fifth element of a list usually means you are using a list in place of something that's not a collection at all
17:15:53 <mm_freak> dwcook: CallFunction :: Address -> [Arg] -> IO Result
17:15:57 <Aetherspawn> why can't we just leave all the APIs seperate from lens
17:16:00 <dwcook> Neat.
17:16:00 <Axman6> zipper: iteration
17:16:01 <Aetherspawn> why does hackage have to creep into lens QQ
17:16:02 <Eduard_Munteanu> zipper: stacks, things that you simply process in order...
17:16:04 <FreeFull> Vectors often are used when you have some code that operates on lists already, and want to speed it up
17:16:05 <geekosaur> zipper: a list is, more or less, a loop
17:16:07 <Cale> zipper: So generally, you try to avoid using !! as much as possible
17:16:39 <mm_freak> in fact IO is almost free in GHC-haskell
17:16:51 <jrmithdobbs> because it's a null token
17:16:52 <jrmithdobbs> heh
17:16:55 <Eduard_Munteanu> zipper: mind just getting the 5th element always isn't the problem... you have a problem if you expect fast access to arbitrary elements other than the head of it.
17:17:11 <mm_freak> about two years ago i wrote a little benchmark that created an SDL window and continuously filled it with random colors using Storable
17:17:17 <mm_freak> it was almost as fast as the C version
17:17:55 <zipper> Thank you
17:18:00 <zipper> everyone
17:18:07 <Eduard_Munteanu> zipper: also Data.Sequence in addition to what Cale suggested, btw
17:18:38 <Cale> zipper: Just as every loop either doesn't happen at all (because its precondition isn't met, say), or consists of an iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
17:18:40 <Eduard_Munteanu> Usually if you need access to both ends.
17:19:15 <jrmithdobbs> mm_freak: not gonna lie, how ghc implements it made me mad at first, not because it's not adequate, but because i wasted time on all the analogies of passing the world and bs instead of just looking at how it was implemented, which makes infinitely more sense (imho, at least)
17:19:18 <mm_freak> a total and element-strict variant of (!!) would be useful sometimes
17:19:22 <jle`> zipper: lists are more like control flow mechanisms than containers
17:19:26 <Cale> Yeah, Data.Sequence has some rather magical-seeming asymptotic complexities, where you can do arbitrary splitting and concatenation in time proportional to the log of the size of the smaller piece
17:19:45 <Axman6> jrmithdobbs: how is it implemented then?
17:20:10 <copumpkin> fingertree
17:20:22 <FreeFull> monoids
17:20:23 <zipper> jle`: Wow I thought lists were containers my whole life lol
17:20:41 <Axman6> zipper: that's just an implementation detail ;)
17:20:47 <jrmithdobbs> Axman6: ok, "passing the world" is *easier to say* fair ;p
17:20:48 <copumpkin> have you seen RRB trees?
17:21:04 <copumpkin> might be worth implementing in Haskell
17:21:05 <Eduard_Munteanu> Really Red Black trees? :)
17:21:22 <mm_freak> really really black trees
17:21:30 <dhrosa> red red black trees
17:21:51 <copumpkin> http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
17:22:04 <Yaniel> round robin black trees?
17:22:05 <FreeFull> jle`: Data.Vector is probably better for control flow, stream fusion and all
17:22:38 <obiwahn> relaxed radix balanced
17:23:33 <Eduard_Munteanu> Makes it sound like Reiser4's dancing trees... "relax, mate, I'll balance it a bit later". :P
17:23:43 <obiwahn> http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
17:23:48 <obiwahn> ah
17:24:01 <obiwahn> the link was already there:)
17:24:13 <copumpkin> :)
17:26:42 <dhrosa> @pl zipWith ($)
17:26:42 <lambdabot> zipWith id
17:26:50 <dhrosa> that's.. interesting?
17:27:24 <FreeFull> $ is infix id
17:29:32 <FreeFull> :t (`id`)
17:29:32 <lambdabot> parse error on input `)'
17:29:32 <FreeFull> :t \x y -> (x `id` y)
17:29:32 <lambdabot> (t1 -> t) -> t1 -> t
17:29:32 <FreeFull> :t \x y -> (x $ y)
17:29:32 <lambdabot> (t1 -> t) -> t1 -> t
17:31:14 <dhrosa> also lambdabot doesn't feel like listening to my private messages anymore for some reason
17:31:15 <dhrosa> oh, i'm experiencing severe irc lag
17:32:09 <dwcook> Freenode sure is moody lately
17:35:20 <Cale> dwcook: I wonder if the DDoS is still continuing to some extent
17:35:40 <dwcook> Good thought. Maybe
17:44:14 <jtcwang> i'm using ghci :l to load a .hs file with a module
17:44:41 <jtcwang> even though i'm only exporting two functions from the module, every function is loaded in ghci
17:44:57 <jtcwang> is there a way to make it work like an actual module load?
17:45:10 <geekosaur> that's normal for from-source. if there is a compiled version then only the exports are loaded
17:45:26 <geekosaur> so use ghc -c
17:45:26 <jtcwang> can you use :m
17:45:27 <jtcwang> instead?
17:45:43 <jtcwang> simple :m +ModuleName is not working
17:45:48 <jtcwang> is there a way to specify a file?
17:46:16 <pavonia> You could create a new file with an import of your module and load that file into GHCi
17:46:23 <jtcwang> i see
17:46:39 <monochrom> :m has a different meaning than what you think. read the GHC user's guide for details
17:46:54 <jtcwang> sigh thx guys
17:47:36 <jtcwang> i'll read the docs and see what i can find
17:48:08 <Cale> jtcwang: Basically if you compile your module first, then ghci will load the compiled object and the things which weren't exported shouldn't be in scope
17:48:46 <jtcwang> yeah i understand that, just feels weird that there isn't a way to load it as a module
17:48:47 <Cale> jtcwang: Another option would be to make a new .hs file which imports the module and load that
17:48:56 <jtcwang> something like :l blabla.hs -m would be awesome
17:49:33 <monochrom> that is a case of http://www.vex.net/~trebla/humour/tautologies.html #2
17:49:33 <Cale> The only difference is which names are brought into scope. The tacit assumption here is that if you're loading a module in ghci, you probably want to test that module
17:49:43 <Cale> So it's more helpful to bring everything into scope
17:49:51 <monochrom> because the more popular demand is, in fact, "I want the unexported things"
17:50:09 <Cale> right
17:50:21 <jtcwang> i'm not saying its bad that it acts that way
17:50:39 <jtcwang> just having the option would be good
17:50:44 <Cale> I've only ever been bitten in the other direction, personally
17:50:46 <monochrom> I know. I'm saying that the -m option does not enjoy enough demand. it will not happen.
17:51:01 <jtcwang> yeah i guess so
17:51:26 <Cale> I kind of wish that if the source was present alongside the object file that I could still access the unexported things (while benefitting from compilation for the things which were exported)
17:51:46 <Cale> That's probably tricky though
17:52:02 <Cale> Or perhaps at least require some special syntax to load the object code when the source was there
17:52:23 <Cale> because it usually happens somewhat unexpectedly, and then I have to reload the module with a * before it
17:52:32 <Cale> or more often, delete the .o file
17:52:49 <jtcwang> oh that
17:53:01 <jtcwang> loading the object file instead of the source u mean?
17:53:26 <Cale> jtcwang: If the .o and .hi are present, ghci will load those, and you won't have access to things which weren't exported
17:53:33 <Cale> (which usually sucks)
17:54:18 <jtcwang> i would
17:54:21 <jtcwang> i'll keep that in mind
17:56:09 <jle`> mm_freak: not sure how to remove :|  with krSwitch i only get access to the entire old wire.  i replace it with an old wire that uses the results of the old wire...but getting the results out of the old wire involve running the entire old wire, so i always need the entire old one :|
17:56:16 <jle`> maybe my old wire should instead be a list of wires.
17:57:16 <jle`> or instead of my old wire being a wire being a Wire [a] [b] by zipping up a bunch of Wire a b's...maybe it shoud be a wire Wire [a] [Wire a b]
17:57:18 <jle`> hm.
17:57:45 <pranz> I'm having some problem with installing ncurses with cabal, when it compiles a certain C program it expects to find ncurses.h in a subfolder ncursesw but it is directly in my library path, is there any workaround?
17:59:30 <dhrosa> @pl flip id
17:59:30 <lambdabot> flip id
17:59:32 <dhrosa> err
17:59:34 <dhrosa> @pl flip (.)
17:59:35 <lambdabot> flip (.)
17:59:57 <jle`> lol
18:00:01 <pranz> dhrosa: @pl removes any bound names, and that only
18:00:22 <pranz> @pl \(x,y) -> (y,x)
18:00:22 <lambdabot> uncurry (flip (,))
18:00:38 <dhrosa> is there a reversed ($)?
18:01:14 <pranz> @hoogle a -> (a -> b) -> a
18:01:15 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
18:01:15 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
18:01:15 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:01:32 <jle`> dhrosa: there is (&) from lens
18:01:48 <pranz> @hoogle a -> (a -> b) -> b
18:01:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:01:49 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:01:49 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:06:28 <xxen> dhrosa >>> = flip .
18:15:20 <dwcook> pranz, that's not quite true (re: pl)
18:15:56 <dwcook> except my counterexample went out of my mind
18:16:10 <dwcook> Oh wait
18:16:53 <Haynesy> @help
18:16:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:17:49 <dwcook> @pl (>>= id)
18:17:50 <lambdabot> join
18:18:01 <pranz> dwcook: ah, sweet
18:18:39 <johnw> dwcook: how is that a counter example?
18:19:02 <dwcook> To the statement "pl removes any bound names, and that only"
18:19:06 <johnw> id is a bound name
18:19:11 <dwcook> (>>=) and id are both free
18:19:11 <johnw> @pl return . fmap f
18:19:12 <lambdabot> return . fmap f
18:19:17 <johnw> @pl \f -> return . fmap f
18:19:17 <lambdabot> (return .) . fmap
18:19:26 <johnw> "id" is a function known to lambdabot
18:19:28 <johnw> "f" is not
18:20:12 <dwcook> It'll actually leave in bindings it doesn't know about too. Trivial example
18:20:14 <dwcook> @pl f
18:20:14 <lambdabot> f
18:20:21 <Cale> Well, it primarily removes lambdas, and then does a bunch of simplification
18:20:38 <dwcook> It just can't transform f since it knows nothing about it
18:20:38 <Cale> (because the way it does that tends to result in ridiculous complicated messes)
18:27:14 <johnw> dwcook: sorry, I often get mixed up on the meaning of "bound"
18:28:46 <dwcook> No worries
18:29:00 <dwcook> Although I was slightly consistent too
18:29:07 <dwcook> I referred to "f" as a binding when it was free
18:29:13 <dwcook> s/consistent/inconsistent/
18:29:18 <verement> @help pl
18:29:19 <lambdabot> pointless <expr>. Play with pointfree code.
18:33:14 <dmj> noob question, how do I check if all elements of a list are equal to each other
18:33:27 <Axman6> (==)
18:33:48 <Axman6> > [1,2,3] == (1:2:3:[])
18:33:49 <dmj> Axman6: but I don't know what the elements are, I just know they're instances of Eq
18:33:50 <lambdabot>  True
18:34:00 <Axman6> right, use (==)
18:34:14 <Axman6> :t ([] ==)
18:34:15 <lambdabot> Eq a => [a] -> Bool
18:34:44 <dhrosa> you could compare every element to the first one
18:34:54 <dmj> dhrosa: w/ a fold?
18:34:59 <Axman6> oh, misread
18:35:03 <dhrosa> yeah, or a specialized fold, like all
18:35:04 <dhrosa> :t all
18:35:05 <Axman6> yeah foldl1 would work
18:35:05 <lambdabot> (a -> Bool) -> [a] -> Bool
18:35:29 <dhrosa> allEq xs = all (== head xs) xs
18:35:33 <dhrosa> :t allEq xs = all (== head xs) xs
18:35:34 <lambdabot> parse error on input `='
18:35:36 <dhrosa> err
18:35:48 <dhrosa> > let allEq xs = all (== head xs) xs in [1,1,1]
18:35:50 <lambdabot>  [1,1,1]
18:35:56 <dhrosa> > let allEq xs = all (== head xs) xs in allEq [1,1,1]
18:35:57 <lambdabot>  True
18:35:59 <dhrosa> > let allEq xs = all (== head xs) xs in allEq [1,1,2]
18:36:00 <lambdabot>  False
18:36:08 <dhrosa> dmj: ^
18:36:50 <dhrosa> > let allEq = all =<< ((==) . head) in allEq [1,1,2]
18:36:50 <magicman> Obligatory warning about head being partial, and that you still need to handle the [] case.
18:36:51 <lambdabot>  False
18:37:39 <dhrosa> > all (==1) []
18:37:40 <lambdabot>  True
18:38:04 * hackagebot purescript 0.3.10.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.10.1 (PhilFreeman)
18:38:52 <dwcook> > let allEq xs = all (== head xs) xs in []
18:38:53 <lambdabot>  []
18:38:58 <dwcook> wops
18:39:01 <dwcook> > let allEq xs = all (== head xs) xs in allEq []
18:39:03 <lambdabot>  True
18:39:11 <dhrosa> interesting
18:39:18 <dwcook> Oh of course, base case doesn't apply the function
18:39:26 <roboguy_> > all undefined []
18:39:27 <lambdabot>  True
18:40:01 <dwcook> @src all
18:40:01 <lambdabot> all p =  and . map p
18:40:08 <dwcook> @src and
18:40:08 <lambdabot> and   =  foldr (&&) True
18:40:14 <magicman> Oh, right. Neat-o.
18:40:34 <dwcook> This is one of those cases where head happens to be harmless
18:40:40 <dwcook> rare though they may be
18:40:58 <magicman> It feels icky, though. But yeah, it works.
18:45:44 <roboguy_> magicman: if it makes you feel better, you could do an irrefutable pattern match on safeHead
18:45:50 <dmj> dhrosa: thanks, im testing for a full house condition in the game of poker
18:46:08 <dwcook> roboguy_, how is that better?
18:46:15 <roboguy_> dwcook: line numbers in errors
18:46:28 <dmj> dhrosa: if interested, http://lpaste.net/99624
18:46:43 <roboguy_> > let x = head [] in x
18:46:45 <lambdabot>  *Exception: Prelude.head: empty list
18:46:48 <roboguy_> > let Just x = Nothing in x
18:46:49 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
18:46:50 <dmj> oh crap there's an error
18:48:31 <dmj> fixed here http://lpaste.net/99625
18:49:55 <ratskin> :t second
18:49:56 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:50:00 <ratskin> :t second sort
18:50:01 <lambdabot> Ord a => (d, [a]) -> (d, [a])
18:50:39 <ratskin> :t (\(x, xs) -> (x, sort xs))
18:50:40 <lambdabot> Ord a => (t, [a]) -> (t, [a])
18:50:43 <orzo> TChan question: if a thread is done with a dupped TChan, is there some way to ensure the TChan is removed from memory and the queue doesn't just fill up by another thread continuing to write?
18:51:53 <dwcook> orzo, it most likely gets destroyed once out of scope everywhere.
18:52:01 <dwcook> But not necessarily immediately.
18:52:22 <ratskin> :k second sort
18:52:23 <lambdabot> Not in scope: type variable `second'
18:52:23 <lambdabot> Not in scope: type variable `sort'
18:52:55 <dmj> why isn't allEq in Data.List?
18:53:10 <roboguy_> :k Ord a => (t, [a]) -> (t, [a])
18:53:11 <lambdabot> *
18:53:14 <Axman6> because it pretty rarely needed
18:53:26 <copumpkin> :t not . null . group
18:53:27 <lambdabot> Eq a => [a] -> Bool
18:53:29 <Eduard_Munteanu> @hoogle allEq
18:53:31 <lambdabot> No results found
18:53:38 <copumpkin> oh wait
18:53:39 <copumpkin> not null
18:53:49 <copumpkin> :t null . drop 1 . group
18:53:50 <lambdabot> Eq a => [a] -> Bool
18:53:55 <orzo> foldr1 (==)
18:54:04 <orzo> heh
18:54:05 <dmj> @src group
18:54:05 <lambdabot> group = groupBy (==)
18:54:10 <dmj> @src groupBy
18:54:10 <lambdabot> groupBy _  []       =  []
18:54:10 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
18:54:10 <lambdabot>     where (ys,zs) = span (eq x) xs
18:54:14 <dwcook> copumpkin, surely adjacency shouldn't matter
18:54:25 <copumpkin> dwcook: it doesn't
18:54:51 <orzo> dwcook: not necessarily immediately sounds awful to me
18:55:05 <copumpkin> @let allEq = null . drop 1 . group
18:55:06 <lambdabot>  .L.hs:142:25:
18:55:06 <lambdabot>      No instance for (Eq a0) arising from a use of `group'
18:55:06 <lambdabot>      The type variable `a0' is ambiguous
18:55:07 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
18:55:07 <lambdabot>        allEq :: [a0] -> Bool (bound at .L.hs:142:1)
18:55:10 <dmj> > not . null . group $ [1,1,2]
18:55:11 <lambdabot>  True
18:55:19 <dmj> > not . null . group $ [1,1,1]
18:55:20 <lambdabot>  True
18:55:24 <copumpkin> I changed it
18:55:26 <dwcook> The DMR strikes again
18:55:42 <copumpkin> @let allEq a = null . drop 1 . group $ a
18:55:44 <lambdabot>  Defined.
18:55:46 <dmj> http://www.youtube.com/watch?v=y8Kyi0WNg40
18:55:49 <copumpkin> > allEq [1,1,2]
18:55:51 <lambdabot>  False
18:55:55 <copumpkin> > allEq [1,1,1]
18:55:56 <lambdabot>  True
18:55:57 <dwcook> Oh I see
18:55:57 <copumpkin> > allEq []
18:55:59 <lambdabot>  True
18:56:04 <copumpkin> > allEq [1,1,2,1]
18:56:06 <lambdabot>  False
18:56:23 <dwcook> There will only be one element if they're all equal and you drop that and check if there are more
18:56:25 <copumpkin> > allEq $ [1,2] ++ repeat 0
18:56:27 <lambdabot>  False
18:56:28 <dmj> > allEq []
18:56:29 <lambdabot>  True
18:56:44 <ratskin> for my lambda function (\(x, xs) -> (x, sort xs)) hlint suggested to use "second sort" instead but I don't understand why it works..
18:57:04 <shachaf> second :: (a -> b) -> (e,a) -> (e,b)
18:57:11 <dhrosa> ratskin: second takes a function and applies it only to second element of a tuple
18:57:13 <dwcook> orzo, I'm not sure if you can guarantee better, at least in GHC; but you might be interested in reading up on GHC's garbage collection.
18:57:19 <shachaf> It has an Arrow-nonsense type but you can ignore that.
18:57:19 <dwcook> (I'm not that familiar with it myself.)
18:57:23 <shachaf> :t second
18:57:24 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:57:36 <johnw> fmap sort would work too
18:57:36 <shachaf> "a x y" is "x -> y"
18:57:47 <dwcook> a = (->) here
18:57:51 <dwcook> Woop
18:58:51 <dwcook> Arrow a => a b c -> a (d, b) (d, c) is the same as Arrow a => b `a` c -> (d, b) `a` (d, c) except you can more easily pretend the a's are function arrows
18:59:02 <dwcook> Also I don't remember if that syntax actually exists
18:59:29 <dwcook> Ah, with TypeOperators it does
19:00:08 <shachaf> Arrow is the scow of type classes, anyway.
19:00:33 <shachaf> For the most part people just use it with a = (->)
19:00:43 * ski . o O ( `second :: Arrow (~>) => (b0 ~> b1) -> ((a, b0) ~> (a, b1))' )
19:01:05 * ski . o O ( `second :: Arrow ar => ar b0 b1 -> ar (a, b0) (a, b1)' )
19:01:34 <Eduard_Munteanu> I think type operators have to be type constructors in recent GHC versions.
19:01:45 * shachaf . o O ( `second :: Arrow k => k a b -> k (e,a) (e,b)' )
19:02:31 <ratskin> got it now thanks.
19:02:44 <roboguy_> shachaf: I have heard that there are some useful (non (->)) applications of it, but I haven't really seen them myself. I've also heard that even then, it's not ideal
19:03:42 <Eduard_Munteanu> roboguy_: sure, Kleisli m for Monad m.
19:04:03 <Eduard_Munteanu> Though that's still rather conservative.
19:04:08 <roboguy_> Eduard_Munteanu: well, I mean other than Kleisli too
19:04:29 <roboguy_> Cale said that he used it for something useful, but I think he also said he ended up redesigning the type class a bit
19:05:05 <johnw> for some uses of Arrow, is Profunctor better?
19:05:41 <Cale> roboguy_: Arrow?
19:05:53 <roboguy_> Cale: I *thought* you said that a while ago. I might be mistaken though
19:05:57 <Cale> yes, I did
19:06:03 <roboguy_> johnw: that's what I would think too
19:06:23 <dwcook> Cale, what resulted from the redesign?
19:06:31 <Eduard_Munteanu> I think you can make an arrow out of the indexed state monad / indexed store comonad.
19:07:08 <roboguy_> Eduard_Munteanu: indexed in the sense of that "Kleisli Arrows of Outrageous Fortune" paper?
19:07:10 <Cale> dwcook: Basically we ended up with something damn close to this: http://www.cs.berkeley.edu/~megacz/garrows/
19:07:24 <Eduard_Munteanu> roboguy_: er, don't remember what that defined
19:08:04 <Eduard_Munteanu> roboguy_: however you may also generalize Kleisli to Bikleisli
19:08:04 <Cale> Essentially, Arrow is trying to be a formulation of symmetric monoidal categories in the sense that Category is a formulation of categories.
19:08:32 <roboguy_> Eduard_Munteanu: that's okay, I only sort of understood it haha. It sort of defined a special kind of Functor/Applicative/Monad that worked on natural transformations
19:08:35 <Cale> and if you put in all the extra isomorphisms that such things are supposed to have around as explicit methods of the class
19:08:44 <Cale> then you don't need to use 'arr' nearly so much
19:09:05 <Cale> and you can translate the proc/do notation in a way which doesn't just turn everything into a black box
19:09:18 <jle`> anything that is useful as a Category is useful as an Arrow
19:09:24 <jle`> so a lot of AFRP
19:09:46 <jle`> arrows are just a set of combinators over Category that makes working with them easier anyway
19:09:48 <dwcook> How do those turn things into black boxes?
19:09:51 <roboguy_> Cale: I know I said this last time, but if you wrote an article about your thoughts on arrows, etc, I'd definitely read it
19:09:58 <Cale> (only cases where you do pattern matches against non-pair datatypes, or cases where you have something other than nested pairs of variables to the right of -< will require arr)
19:10:27 <Cale> roboguy_: Yeah, RyanT5000 and I eventually intend to write a paper, but it's something that we've put off for a long time.
19:10:39 <Cale> (and blackh too :)
19:11:08 <Eduard_Munteanu> Arrow is stronger than Category though, it just happens to be rather mundane for Hask.
19:11:35 <Eduard_Munteanu> Probably because CCC and stuff.
19:12:27 <Cale> But yeah, basically, Arrow as it is right now kind of screws you for just the very applications that it looks like it ought to be good for: cases where you want to be able to build up a graph structure for your computation ahead of time (because of the way that Arrow makes all the binding very explicit) and apply various optimisation steps to it
19:13:09 <Cale> The heavy reliance on arr for all the basic wiring around of results inserts black boxes in between almost every pair of computations though
19:13:31 <Cale> making it essentially impossible to analyse anything until you do something to eliminate the uses of arr
19:13:42 <Eduard_Munteanu> I suspect it's more particularly useful / interesting for categories that are closed monoidal but not CCCs?
19:14:03 <Cale> actually, we only really used  (Hask, (,), ())
19:14:16 <Cale> or rather (C, (,), ())
19:14:21 <Eduard_Munteanu> IIRC they relate to trace monoidal categories.
19:14:24 <Cale> where C is some funny category built on Hask's objects
19:14:25 <Eduard_Munteanu> *traced
19:14:33 <Cale> i.e. we only really used pairing
19:15:16 <Cale> The really important part of how we generalised Arrow wasn't the pairing bit, but the part about including all the explicit isomorphisms like
19:15:22 <Cale> swap :: (a,b) ~> (b,a)
19:15:37 <Cale> assocr :: ((a,b),c) ~> (a,(b,c))
19:15:39 <Cale> and so on
19:16:15 <Eduard_Munteanu> I really don't want a MacLane pentagon in a type. :P
19:16:31 <Cale> Those bits are actually super-important
19:16:54 <Cale> Because you can implement them by constructors and then reason about what your computations are going to do before you try to run them
19:17:19 <Cale> (or by some sort of heterogeneous graph structure)
19:17:47 <Cale> and in our case, that let us do many very important optimisations in our FRP system
19:19:29 <Cale> (the heterogeneous graph structure involved some rather serious type hackery though... some of that stuff was among the most complicated code I've ever worked on, but it made sense in the end, and the type system was very helpful in doing refactorings and making the whole enterprise possible at all)
19:19:40 <i_might_> hey there
19:20:28 <dwcook> Cale, type-level graphs?
19:20:31 <Cale> (The stuff which was going on was complicated enough I think that if we didn't have Haskell's type system, we would have just never gotten it working at all, but it was really something better suited to dependent types)
19:20:54 <Cale> dwcook: There was a lot of GADT reflection of types, and at least one (safe!) use of unsafeCoerce
19:21:06 <i_might_> i was told to learn programming.i'm sorry
19:21:13 <Cale> i_might_: hm?
19:21:19 <roboguy_> i_might_: why are you sorry?
19:21:23 <Cale> i_might_: You're in the right place if you want to learn Haskell
19:21:29 <dwcook> Is the existence of safe uses of unsafeCoerce a sign of a weakness in the type system?
19:21:45 <dwcook> i_might_, here's a good place to start:
19:21:48 <dwcook> @where lyah
19:21:48 <lambdabot> http://www.learnyouahaskell.com/
19:22:07 <dwcook> Feel free to ask questions in here too
19:22:55 <i_might_> i know a little python actually. but can't get enough motivation to continue
19:23:00 <Cale> dwcook: kinda. It would have been avoidable, but only by way of another, oh, 1.27 olegs worth of type hackery.
19:23:00 <ski> i_might_ : two other resources for learning programming, in this case using the language Scheme rather than Haskell are :
19:23:03 <ski> @where HTDP
19:23:03 <lambdabot> http://www.htdp.org/
19:23:05 <ski> @where SICP
19:23:05 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
19:23:11 <Eduard_Munteanu> dwcook: sure, unsafeCoerce :: Void -> a   :)
19:23:19 <monochrom> no one except you can solve your motivational problem
19:23:44 <ski> i_might_ : the SICP videos won't take that much time to view, and will possibly be interesting. if you want to learn more, you could check out the book itself
19:23:50 <dwcook> Eduard_Munteanu, that exists in another form and is called absurd :P
19:23:50 <monochrom> unless you just want me to hypnotize you with "learn programming. obey me."
19:24:10 <i_might_> what possible things can i get done with haskell?
19:24:14 <Cale> WOW    VERY OBEY   MUCH COMPLY
19:24:24 <Eduard_Munteanu> i_might_: the Wikipedia article might provide an overview and possibly make Haskell seem weird enough to be worth bothering about :)
19:24:46 <i_might_> monochrom: can you?
19:24:48 <dwcook> i_might_, anything you could do in C, albeit with less bit twiddling
19:24:48 <Cale> i_might_: With enough work, pretty much anything your computer is capable of doing.
19:24:55 <monochrom> I don't know
19:25:03 <dwcook> Or Python even
19:25:13 <roboguy_> i_might_: haskell is a general purpose programming language, so everything
19:26:33 <ski> i_might_ : learning Haskell will probably teach you useful concepts and some good habits, and will quite possibly be quite fun (and mindbending)
19:26:39 <dwcook> Though in Python's case it's less bit twiddling and more class twiddling :P
19:28:52 <i_might_> i'm running archlinux on virtualbox. how do i start?
19:30:04 <i_might_> what package do i install?
19:30:10 <dwcook> i_might_, I'm not that familiar with Arch but it looks like you can get haskell-platform from the AUR.
19:30:33 <Eduard_Munteanu> i_might_: Google turns up... https://wiki.archlinux.org/index.php/Haskell_package_guidelines
19:30:35 <dwcook> Are you familiar with the AUR? It's something you'd have to have set up manually.
19:30:44 <dwcook> (Of course, much the same can be said of Arch in general.)
19:31:04 <i_might_> i have package manager installed, aura
19:31:21 <dwcook> I don't know what that is. Is there any particular reason you're running it in a VirtualBox, by the way?
19:31:33 <dwcook> The Haskell Platform is fairly likely to be available for your host system as well.
19:31:55 <i_might_> i am on windows xp. and learning linux. just for the fun of it. and learning to use vim :P
19:32:09 <dwcook> You can use Haskell and Vim on Windows as well.
19:32:20 <i_might_> plus. i do not own this computer
19:32:27 <dwcook> Okay, fair enough.
19:32:55 <Iceland_jack> It can be trickly learning many things at a time, just keep that in mind
19:32:57 <dwcook> You'll want to read the Arch wiki, no doubt.
19:33:01 <Eduard_Munteanu> How do I tell GHC where to look if I 'cabal build' a package without installing it and I want to refer to it from a .hs somewhere else?
19:33:11 <Iceland_jack> other than that there are plenty of resources for getting started with Haskell on Arch
19:33:13 <i_might_> i have to set up everything everytime the computer restarts. damn deepfreeze
19:33:30 <dwcook> You'll have better luck using an online IDE then.
19:33:35 <dwcook> Try the one at fpcomplete.
19:33:49 <Eduard_Munteanu> @google tryhaskell
19:33:50 <Iceland_jack> i_might_: You can use an online IDE or run your operating system from a bootable USB or a live CD
19:33:50 <lambdabot> http://tryhaskell.org/
19:34:16 <Eduard_Munteanu> i_might_: the above or private chats with lambdabot in here might get you started
19:34:29 * Iceland_jack . o O ( people still use CD's? )
19:35:21 <i_might_> whew. i don't want to signing up just to use their service.
19:35:41 <Cale> i_might_: Install GHC
19:35:46 <Eduard_Munteanu> i_might_: /query lambdabot     then :)
19:35:58 <Eduard_Munteanu> > 1 + 1
19:36:00 <lambdabot>  2
19:36:03 <Cale> http://www.haskell.org/ghc/
19:36:09 <Iceland_jack> Eduard_Munteanu: Quite limited but works ;)
19:36:15 * dwcook wonders if someone's made a GHC for installation on USB drives
19:36:18 <i_might_> 1 + 1
19:36:20 <Iceland_jack> > sequence_ print [1..5]
19:36:22 <lambdabot>  Couldn't match expected type `[[t0] -> a0]'
19:36:22 <lambdabot>              with actual type `a1 -> GHC.Types.IO ()'
19:36:29 <Iceland_jack> oops.. duh
19:36:32 <Iceland_jack> > mapM_ print [1..5]
19:36:34 <lambdabot>  <IO ()>
19:36:42 <roboguy_> ". o O" means a thought bubble doesn't it? I *just* realized that
19:36:46 <Cale> You'll probably find a version in your package manager, or you can get a generic linux binary from that website I linked.
19:36:54 <Iceland_jack> roboguy_: It does!
19:37:06 <roboguy_> haha, I can't believe it took me so long to figure that out
19:37:11 <Cale> I don't even have a CD/DVD drive in my desktop machine.
19:37:30 <Cale> I just use the network or USB sticks for everything.
19:38:18 <dwcook> One of my many technological eccentricities is that I only buy music on CD albums.
19:38:20 <Eduard_Munteanu> Cale: I bet it's pretty tough to play catch with an USB stick, although Cat5e cable might be fun too :P
19:39:17 <Eduard_Munteanu> But yeah, CD/DVDs have been and are annoying.
19:39:27 <Cale> I suck at catch anyway, because I'm stereoblind.
19:40:23 <i_might_> haskell-platform isn't in any repo yet. But the wiki suggests an alternative anyway.
19:42:37 <dwcook> i_might_, did you try the AUR?
19:42:46 <dwcook> You need to specifically install that.
19:42:46 <i_might_> yup
19:43:01 <dwcook> All right. That probably about ends my usefulness with Arch.
19:44:41 <i_might_> sorry. they have https://aur.archlinux.org/packages.php?K=haskell-platform
19:48:08 <dwcook> Alternatively you could see if you can access just a ghc package even if haskell-platform's not available for some reason.
19:48:14 <dwcook> That's all you really need to begin Haskell.
19:50:07 <dwcook> Or, as someone mentioned earlier, tryhaskell.org is a quick way to learn the basics.
19:50:19 <Eduard_Munteanu> Argh, '-i' is a static flag. So much for using an OPTIONS_GHC pragma for my runhaskell scripts.
19:50:21 <MrWoohoo> How aggressive is the compiler at computing constant expressions at compiler time? If I use from list to create a map from a list of constants, does that map get created at compile-time or runtime?
19:50:38 <Eduard_Munteanu> MrWoohoo: quite conservative
19:50:56 <MrWoohoo> I can see how it might cause issues :)
19:51:01 <MrWoohoo> thanks
19:51:18 <roboguy_> MrWoohoo: you mean something doing something like "map (+1) [1..10]" at compile time? ghc doesn't really do that
19:51:23 <Eduard_Munteanu> MrWoohoo: you could build it in a TH splice
19:52:28 <Eduard_Munteanu> MrWoohoo: however I don't think you can eliminate building the map itself
19:52:47 <i_might_> how to run hs scripts without running ghci? something like python script.py?
19:52:59 <Eduard_Munteanu> i_might_: runhaskell foo.hs
19:53:43 <Eduard_Munteanu> i_might_: unlike Python you can compile Haskell to native code, and run it as a straight executable.
19:53:56 <jrmithdobbs> why is TH so convoluted anyways? meta-programming can be confusing/complicated enough already =/
19:53:57 <Eduard_Munteanu> e.g.  ghc foo.hs
19:54:15 <Eduard_Munteanu> jrmithdobbs: it's not very convoluted really
19:54:39 <jrmithdobbs> Eduard_Munteanu: it's not very approachable either with the terse seemingly obsfucated naming of everything
19:54:46 <enthropy> there's lots of syntax you can generate
19:55:35 <Eduard_Munteanu> jrmithdobbs: in many cases you can quote Haskell expressions instead of building an AST from pieces, e.g. [d| data Foo = Bar | Baz |]
19:55:38 <jrmithdobbs> (not implying it really is intentionally obsfucated, i know it's not, but it LOOKS that way trying to read it not being familiar)
19:55:51 <Eduard_Munteanu> It's just an AST really.
19:56:04 <jrmithdobbs> Eduard_Munteanu: ya but that doesn't help reading "other people"s TH
19:56:13 <jrmithdobbs> which is usually how you first encounter it
19:56:59 <roboguy_> jrmithdobbs: unless you're working in lisp or forth, you probably will have some convolution when doing metaprogramming
19:57:13 <i_might_> are there any styleguide for haskell? like whitespaces tabs?
19:57:25 <roboguy_> i_might_: never, *never* use tabs in haskell
19:57:33 <roboguy_> it will cause a lot of problems
19:57:51 <i_might_> why?
19:58:00 <jrmithdobbs> Eduard_Munteanu: eg, i was trying to figure out why Control.Monad.Free.TH couldn't understand a structure to generate the helpers and, well, look at it, heh: http://hackage.haskell.org/package/free-4.5/docs/src/Control-Monad-Free-TH.html#makeFree
19:58:07 <Eduard_Munteanu> i_might_: like Pythom, Haskell is indentation-sensitive, mind
19:58:12 <roboguy_> i_might_: sometimes things look like they line up with tabs, but they actually don't
19:58:34 <roboguy_> it's much easier and better to just use spaces with haskell
19:59:08 <i_might_> my vimrc has translate to tabs to space. is that alright?
19:59:34 <Eduard_Munteanu> i_might_: expandtabs and ts=8?
20:00:04 <jmcarthur> i_might_: i disagree with Eduard_Munteanu's characterization of haskell's syntax. haskell's layout sensitive syntax is not like python's indentation sensitive syntax. haskell is more concerned with blocks and alignment than with where something is merely indented further or not. tabs make it less clear how you intend your code to be aligned, since not everybody even agrees on how wide they should be
20:00:06 <i_might_> something like that? i just copied my vimrc.
20:00:10 <jrmithdobbs> Eduard_Munteanu: aeson's is a better example where that's not as much a problem since it's all done with splices but, that example from 'free' is more akin to most of the TH code i've seen =/
20:00:18 <roboguy_> i_might_: yeah, that should be good
20:00:36 <roboguy_> i_might_: the main thing is that you really should avoid tab characters and use spaces instead, and that should take care of that
20:00:39 * Eduard_Munteanu doesn't really know much Python :)
20:01:00 <jrmithdobbs> it's so much better than python's layout rules they don't compare ;p
20:01:03 <enthropy> jrmithdobbs: people shy away from using [| |] because it doesn't work in all cases you want to
20:01:06 <roboguy_> jmcarthur: that's true. I could see valid arguments for using tabs in python, but not so much for haskell
20:01:07 <jrmithdobbs> except that they both involve whitespace
20:01:14 <enthropy> but they go overboard
20:01:27 <jmcarthur> python basically just uses indentation to determine tree structure
20:01:35 <enthropy> opType  = foldr (AppT . AppT ArrowT) (AppT (VarT m) retType) ps
20:01:37 <jmcarthur> haskell uses layout to structure code into blocks
20:02:14 <dwcook> And no matter what language you use, tabs are inexcusable for alignment (as opposed to indentation)
20:02:23 <enthropy> could instead be something like:    foldr (\a b -> [t| a -> b |]) [t| $m $retType |] ps
20:02:32 <jmcarthur> dwcook: right. exactly why tabs might make sense in python, but not in haskell
20:02:34 <enthropy> if everything was TypeQ instead of Type
20:02:46 <jrmithdobbs> tabs are just inexcusable in humane-editable plaintext documents really ;p
20:03:07 <jrmithdobbs> human* but i think i like the typo better.
20:03:07 <dwcook> I try to make sure my programs are humane. They don't harm any animals, for example
20:03:14 <enthropy> err, foldr (\a b -> [t| $a -> $b |]) [t| $m $retType |] ps
20:03:20 <jmcarthur> my programs only harm humanes
20:03:23 <Eduard_Munteanu> Tabs-only would be useful in Haskell if editors handled layout automatically.
20:03:45 <Eduard_Munteanu> In the structural editing sense.
20:05:03 <roboguy_> Eduard_Munteanu: hmm, I don't think I'd trust that even if it existed, especially since someone might use another editor that doesn't do that
20:05:10 <jrmithdobbs> i've not found an auto-layout mode (lighttable is surprisingly close, i'll admit) that doesn't annoy me more than it helps =/
20:06:07 <Eduard_Munteanu> That's mainly because most editors use dumb regexps and whatnot to indent. Also because monospaced layout is expected.
20:06:15 <jrmithdobbs> yi's is nifty but it's an unusable piece of software in general, heh (try opening fun things like 16G files or /dev/null with it, =/)
20:06:27 <jrmithdobbs> i want monospaced layout
20:07:06 <Eduard_Munteanu> I don't :). I think monospace fonts in programming is a hack / kludge. :)
20:07:41 <roboguy_> lighttable doesn't do haskell (at the moment) right?
20:07:47 <Eduard_Munteanu> Open your favorite math article with aligned eqs and other nice things. Are any of those monospaced? :)
20:08:03 <jrmithdobbs> i'm not exactly the epitome of examples for a modern ser either, my favorite piece of software is a toss up between tmux and the newer versions (10.5+) of terminal.app ;p
20:08:11 <jrmithdobbs> s/ser/user/
20:09:00 <Eduard_Munteanu> I'd also be open to typesetting code "out-of-band", TBH, i.e. as additional markup.
20:09:05 <jmcarthur> Eduard_Munteanu: in the absense of a monospaced font, you have to use some sort of additional metadata to encode many kinds of visually pleasing/useful alignments
20:09:14 <jmcarthur> err, yeah that :)
20:09:19 <roboguy_> jrmithdobbs: does that major tmux bug still exist in OS X?
20:09:25 <jmcarthur> i do also agree that that isn't entirely unappealing
20:09:33 <jrmithdobbs> roboguy_: what bug?
20:09:40 <roboguy_> it did when I checked last, but I don't have mavericks yet
20:10:12 <roboguy_> jrmithdobbs: if you want your computer to immediately restart, open up Terminal.app, start emacs, run ghci in emacs and then try to close emacs normally
20:10:15 <roboguy_> *normally
20:10:27 <jrmithdobbs> roboguy_: problem spotted: emacs
20:10:41 <roboguy_> jrmithdobbs: actually, it happens with any tmux-like subprocess thing
20:10:58 <roboguy_> it's pretty major, in my opinion
20:11:44 <jrmithdobbs> tell me the magic combo to launch ghci inside emacs
20:11:47 <jrmithdobbs> and i will try it
20:12:49 <Eduard_Munteanu> jrmithdobbs: C-c C-l ?
20:12:49 <jrmithdobbs> i'm lucky to remember ^x^c
20:13:07 <jrmithdobbs> C-c C-l is undefined
20:13:14 <roboguy_> jrmithdobbs: alright, make sure everything is saved, etc. basically, I think if you just open a haskell file in emacs haskell-mode, do C-x C-l (I think) to load it into ghci then C-x C-c to close emacs it'll reboot
20:13:21 <Eduard_Munteanu> jrmithdobbs: do you have haskell-mode installed?
20:13:24 <roboguy_> err, C-c C-l to load
20:13:30 <jrmithdobbs> no because i don't use emacss
20:13:56 <jrmithdobbs> is launching emacs inside of tmux sufficient to answer your question? heh
20:13:56 <roboguy_> jrmithdobbs: there's a way to do it with any kind of terminal multiplexing (like tmux), but I can't remember how off the top of my head
20:13:59 <Eduard_Munteanu> It needs a bit of configuration.
20:14:36 <Eduard_Munteanu> roboguy_: a way to do what?
20:14:47 <roboguy_> Eduard_Munteanu: trigger the bug
20:14:50 <Eduard_Munteanu> Ah.
20:14:55 <roboguy_> jrmithdobbs: I think this is the same bug http://comments.gmane.org/gmane.comp.terminal-emulators.tmux.user/1852
20:15:16 <roboguy_> I remember something about negative open counts, I think
20:15:38 <Eduard_Munteanu> I'd suggest using Emacs with X windows.
20:16:05 <Eduard_Munteanu> You can configure it to look just like a terminal.
20:16:09 <jrmithdobbs> roboguy_: oh, i don't use the paste buffer crap
20:16:12 <roboguy_> Eduard_Munteanu: I don't use X windows in OS X, I just use the Cocoa version of emacs
20:16:22 <Eduard_Munteanu> Or that. :)
20:16:24 <jrmithdobbs> roboguy_: well, i use it extensively, but not to bubble up to the aqua session
20:17:00 <roboguy_> jrmithdobbs: hmm, I don't really know anything about paste buffers. I *think* it just has something to do with running a subprocess in a multiplexer-like thing and then closing the multiplexer while the subprocess is still running
20:17:12 <roboguy_> if that makes sense
20:17:45 <jrmithdobbs> roboguy_: no it has to do with, if it's the same bug, doing that while running a hack to tie said multiplexer into a different type of session in OS X and not closing it properly
20:18:21 <jrmithdobbs> roboguy_: so if you enable clipboard sharing it may cause issues depending on how you enable it and which howto you follow
20:18:32 <jrmithdobbs> roboguy_: or whose tmux.conf you copy =/
20:18:34 <Eduard_Munteanu> Perhaps you can avoid tmux if you run an Emacs server, assuming that covers your usecase?
20:18:54 <jrmithdobbs> of course it doesn't, emacs wishes it could window as well as tmux
20:19:01 <roboguy_> well, all I know is that running emacs in Terminal with a ghci subprocess and then closing it without closing ghci first is a very bad idea right now
20:19:11 <Eduard_Munteanu> Ah, windows.
20:19:12 <jrmithdobbs> Eduard_Munteanu: tmux's client/server protocol is what emacs server wishes it was to begin with ;p
20:19:48 <Eduard_Munteanu> jrmithdobbs: I thought maybe you were using tmux as a way to keep a persistent emacs session running
20:20:10 <jrmithdobbs> Eduard_Munteanu: no i just mentioned tmux and terminal.app were my two favorite pieces of software and he asked me about some bug i've never encountered :)
20:21:39 <roboguy_> I'm a little frustrated that the bug has been known for so long and still exists, haha
20:21:59 <jrmithdobbs> roboguy_: anyways, with *my* tmux.conf i can launch emacs inside of tmux and close the window and i'm still chatting at you (which should trigger the same behavior)
20:22:47 <jrmithdobbs> roboguy_: just killed the tmux server too ...
20:23:04 <roboguy_> jrmithdobbs: are you on mavericks?
20:23:09 <jrmithdobbs> yes
20:23:47 <roboguy_> hmm, maybe it's fixed in mavericks. I'm on mountain lion
20:24:02 <jrmithdobbs> why are you running a 4 year old os
20:24:38 <roboguy_> 4 years? didn't mountain lion come out in 2012?
20:25:06 <jrmithdobbs> 10.6? did i get names bixed up?
20:25:24 <roboguy_> it's 10.8, the one right before mavericks. I didn't upgrade yet because I've heard mavericks still has some bugs to sort out
20:25:45 <jrmithdobbs> oh, my bad
20:25:47 <roboguy_> specifically 10.8.5
20:26:07 <roboguy_> yeah, I can never keep track of the names either. I had to look it up
20:26:29 <jrmithdobbs> i've been using tmux since ~10.5 and only ever had issues once and it also involved clipboard sharing stuff ;p
20:27:08 <jrmithdobbs> i'd guess haskell mode is to blame
20:27:10 <jrmithdobbs> tbqh
20:27:26 <jrmithdobbs> probably turns on clipboard sharing stuff by default, or tries to
20:28:52 <roboguy_> this is probably a bit of a stupid question, but what is clipboard sharing? is it pretty much what it sounds like?
20:28:53 <l4u> I am trying to read a list of integers from stdin. I got IO [(Int, Int)]   how do I convert it to [(Int, Int)] ?
20:29:08 <copumpkin> you don't
20:29:15 <copumpkin> you move into the IO so you can work on it
20:29:46 <dmj> lf4u: a <- readInts, a now has the type [(Int, Int)]
20:29:47 <copumpkin> the simplest answer is to write something like do listOfPairsOfInts <- ioListOfPairsOfInts; use listOfPairsOfInts
20:30:29 <dmj> what is the most efficient haskell hashtable-like structure, in terms of memory consumption. A judy array?
20:30:39 <jrmithdobbs> copumpkin: so what's the most complicated answer then? ;p
20:31:15 <Eduard_Munteanu> l4u: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
20:31:17 <copumpkin> well, somewhere along the way you encounter a lax 2-functor from a terminal bicategory
20:31:28 <copumpkin> @quote monochrom IO
20:31:28 <lambdabot> monochrom says: premature opinion is the root of all evil.
20:31:31 <copumpkin> @quote monochrom IO
20:31:32 <lambdabot> monochrom says: "customers who used == also liked: foldr, map, Ord, continuation passing style"
20:31:35 <copumpkin> gah
20:31:44 <Eduard_Munteanu> @quote /bin/ls
20:31:44 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:32:15 <monochrom> do you mean: http://www.vex.net/~trebla/photo/unorganized/IO-String.png
20:32:47 <copumpkin> <lambdabot>	 monochrom says: How do I extract the IO out of IO String?
20:32:48 <copumpkin> yeah that one
20:34:12 <novochar> I'm reading http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html Why is the object file required in `ghc -o simple Main.hs SimpleJSON.o`?
20:34:26 <l4u> Eduard_Munteanu my function now returns an IO Int, how do I perform the actual getLine operation so that it returns Int?
20:35:02 <jrmithdobbs> l4u: you can't
20:35:11 <jrmithdobbs> is the short version
20:35:21 <monochrom> "ghc -o simple Main.hs" may eliminate that need altogether
20:35:22 <roboguy_> l4u: you don't. you can turn a function that takes an Int into a function that takes an IO Int and returns something in IO though
20:35:33 <roscareyes> are people under 18 allowed to be in this channel?
20:35:39 <monochrom> yes
20:35:48 <roscareyes> are there people under 18 here?
20:35:49 <roboguy_> l4u: for instance, if you have a function Int -> String, you can turn it into a function IO Int -> IO String
20:35:50 <Eduard_Munteanu> l4u: if foo :: IO Int, then in 'foo >>= \i -> ...', i :: Int
20:35:53 <Eduard_Munteanu> :t (>>=)
20:35:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:36:57 <monochrom> Haskell's IO story is story of don't call us, we'll call you.
20:37:01 <roscareyes> note to all programming teen boys between the ages of 14 and 16.... i am looking for a young geeky looking teen boy interested in letting a fun-loving 40 y/o guy suck him off and going surfing
20:37:11 <roscareyes> anybody here fit the bill?
20:37:23 <jrmithdobbs> really
20:37:46 <ratskin> what does IORef do?
20:37:57 <Eduard_Munteanu> l4u: or, in do notation, do { i <- foo; ... }
20:38:09 <l4u> Eduard_Munteanu so for "foo >>= \i -> "  can I store the read results in a let statement?
20:38:10 --- mode: ChanServ set +oo monochrom dolio
20:38:18 --- mode: monochrom set +b *!*@gateway/web/irccloud.com/x-gntqsyveocjescej
20:38:18 --- kick: roscareyes was kicked by monochrom (roscareyes)
20:38:23 <ratskin> a mutable variable in the IO monad
20:38:28 --- mode: ChanServ set -o dolio
20:38:34 <Eduard_Munteanu> ratskin: it's a mutable cell you can write to and read from
20:38:38 <roboguy_> l4u: it is already stored in i
20:39:01 <novochar> k
20:39:29 --- mode: monochrom set -b+b *!*@gateway/web/irccloud.com/x-gntqsyveocjescej $a:roscareyes
20:39:35 <Eduard_Munteanu> l4u: the only way you can get at 'i' is through (>>=), and (>>=) requires you to return something in IO in the second argument.
20:39:40 <monochrom> (is that the right syntax? $a:roscareyes)
20:39:59 <L8D> Where should I go to get an unbiased opinion on what language and framework I should use?
20:40:10 <jrmithdobbs> the internet, of course!
20:40:14 <roboguy_> L8D: unbiased? I have no idea
20:40:26 <L8D> roboguy_: There was one place, but now I'm banned from there.
20:40:42 <L8D> Because I leaked all of the NickServ passwords
20:41:02 --- mode: monochrom set -o monochrom
20:41:46 <sccrstud92__> @hoogle (a -> Maybe a) -> a -> [a]
20:41:47 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:41:47 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:41:47 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:42:00 <ratskin> :t writeIORef
20:42:01 <lambdabot>     Not in scope: `writeIORef'
20:42:02 <lambdabot>     Perhaps you meant `writeSTRef' (imported from Data.STRef)
20:42:12 <sccrstud92__> damn
20:42:20 <ratskin> writeIORef :: IORef a -> a -> IO ()
20:42:29 <excarna> Why am I getting force-reinstall notices in a cabal sandbox?
20:42:33 <L8D> sccrstud92__: mapMaybe is what you want
20:42:34 <dwcook> sccrstud92__, mapMaybe really looks like what you wanted. What else did you have in mind?
20:43:04 <ratskin> shouldn't it be IORef a -> a -> IO (IORef a)
20:43:10 <ratskin> i don't know
20:43:11 <L8D> dwcook: aren't you famous or something in the haskell communities?
20:43:22 <ratskin>  where do we use IORef ingeneral?
20:43:25 <L8D> I've seen your nick/username in a lot of places
20:43:27 <dwcook> L8D, haha, no. I haven't even published anything significant
20:43:49 <L8D> maybe I'm thinking of something else.
20:43:53 <dwcook> I don't know, have you ever been to ##javascript? I used to op there
20:43:59 <sccrstud92__> i wanted an unfolding function that is a specialization of unfoldr that takes a -> Maybe a instead of a -> Maybe (a, b)
20:44:47 <sccrstud92__> mapMaybe is not what i wanted. it doesnt match the type i gave
20:44:51 <dwcook> sccrstud92__, then you wrote the wrong type signature.
20:44:56 <roboguy_> :t \f x -> maybeToList (f =<< return x)
20:44:57 <lambdabot> (a1 -> Maybe a) -> a1 -> [a]
20:45:05 <dwcook> mapMaybe strictly generalizes the type you gave.
20:45:06 <L8D> sccrstud92__: why would you need the type you gave?
20:45:19 <sccrstud92__> @hoogle (a -> Maybe a) -> a -> [a]
20:45:20 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:45:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:45:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:45:22 <sccrstud92__> :t unfoldr
20:45:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:45:24 <pavonia> ratskin: When using IO with event handlers and such, where you need to access a access and change value from different parts of your code
20:45:42 <sccrstud92__> in this unfold the accumulator is the elements as well
20:45:45 <L8D> sccrstud92__: You want to convert a Maybe into a list?
20:45:50 <sccrstud92__> nope
20:45:51 <dwcook> sccrstud92__, could you give some sample inputs and outputs? I'm unclear on what you're looking for.
20:45:53 <sccrstud92__> i want to unfold
20:46:00 <L8D> sccrstud92__: that's what you're doing.
20:46:00 <sccrstud92__> sure
20:46:15 <l4u> roboguy_ but the i cannot be used outside the block. is it possible for me to store it outside the scope?
20:46:31 <L8D> sccrstud92__: would there ever be more than 1 item in the list returned?
20:46:37 <roboguy_> l4u: you pretty much have to use it inside that block. what are you trying to do?
20:47:05 <sccrstud92__> take 10 $ unfold (Just . (+1)) 0 = [0,1,2,3,4,5,6,7,8,9]
20:47:19 <sccrstud92__> or even
20:47:29 <sccrstud92__> take 10 $ unfold (Just . (+1)) 0 = [1,2,3,4,5,6,7,8,9,10]
20:47:30 <dwcook> Ah, you want a generalized iterate
20:47:31 <sccrstud92__> would be fine
20:47:32 <l4u> roboguy_ for the first read IO, i want to build a tree.  for the second IO, i want to use the tree. I now can do the first IO and build a tree, but the tree cannot be used in the second IO
20:47:32 <dwcook> @type iterate
20:47:33 <lambdabot> (a -> a) -> a -> [a]
20:47:34 <L8D> @src unfoldr
20:47:34 <lambdabot> unfoldr f b  = case f b of
20:47:34 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
20:47:34 <lambdabot>    Nothing        -> []
20:47:42 <sccrstud92__> yeah
20:47:51 <sccrstud92__> it would eb a generalization of either one
20:47:54 <L8D> sccrstud92__: It's just converting a Maybe to a list
20:48:05 <L8D> with some other stuff
20:48:10 <jrmithdobbs> well, you can myioint >>= \x -> return undefined >> something else with x >>= something more with x
20:48:14 <sccrstud92__> srry generlization of iterate, specialization of unfoldr
20:48:18 <roboguy_> l4u: what about something like readLn >>= buildTree >>= useTree?
20:48:20 <dwcook> It's a bit more than that. But anyway, I'm not sure it exists in some library.
20:48:25 <jrmithdobbs> but that is probably not what you're really after
20:48:30 <L8D> you might as well do the other stuff in a seperate function and then use fmap
20:50:11 <the_berserker> @pl \f g x -> g (f x) x
20:50:11 <lambdabot> flip flip id . (ap .) . flip (.)
20:50:30 <roboguy_> l4u: or, actually, what about do { input <- readLn; let tree = buildTree; ... useTree tree } ?
20:50:45 <L8D> :T flip flip id . (ap .) . flip (.)
20:50:50 <roboguy_> sorry, I mean do { input <- readLn; let tree = buildTree input; ... useTree tree }
20:51:05 <the_berserker> > return 2 >>= (+)
20:51:06 <lambdabot>  <Integer -> Integer>
20:51:16 <dwcook> > let iterateMaybe f x = x : case f x of Nothing -> [] ; Just x' -> iterateMaybe f x' in iterateMaybe (\x -> if x < 10 then Just (x + 1) else Nothing) 0
20:51:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
20:51:25 <dwcook> sccrstud92__, ^ ?
20:51:31 <the_berserker> > (return 2 >>= (+)) 5
20:51:31 <jrmithdobbs> roboguy_: why not: readLn >>= buildTree >>= processTree >>= outputTree
20:51:32 <lambdabot>  7
20:51:56 <jrmithdobbs> s/outputTree/outputResult/
20:52:15 <excarna> Why would one still get force-reinstalls within a cabal sandbox?
20:52:31 <excarna> I was under the impression that you would just install everything anew
20:52:32 <sccrstud92__> dwcook: yup thats the one
20:52:40 <jrmithdobbs> excarna: dynamic linking enabled can cause it and mismatches with base packages i think
20:52:51 <excarna> ugh
20:52:55 <L8D> What's the term used to describe a language that has macros?
20:53:00 <L8D> Homoiconicity?
20:53:07 <sccrstud92__> dwcook: i take it its not a library function though
20:53:34 <sccrstud92__> L8D: that might be the term u are looking for but i dont think thats exactly what it means
20:53:50 <sccrstud92__> L8D: i that that meant that code and data were the same
20:54:02 <L8D> sccrstud92__: the term used to describe quine programs
20:54:18 <L8D> programs that can be used to write other programs
20:54:24 <sccrstud92__> L8D: and it's not quine?
20:54:30 <L8D> sccrstud92__: no
20:54:31 <excarna> a macroscopic language
20:54:43 <sccrstud92__> metaprogramming
20:54:44 <jrmithdobbs> L8D: metaprogramming is the act of writing it
20:54:46 <sccrstud92__> template programming
20:54:51 <roboguy_> l4u: I might need to see an example
20:54:53 <L8D> jrmithdobbs: METAPROGRAMMING
20:54:54 <sccrstud92__> metaprogram then?
20:54:54 <L8D> that's it
20:55:01 <L8D> that's what I was looking for
20:55:03 <sccrstud92__> np
20:55:08 <L8D> sccrstud92__: thanks
20:55:32 <L8D> FORTH has metaprogramming
20:55:32 <l4u> roboguy_ https://gist.github.com/l4u/5d6c2ae5263f49ec9326  thanks. the issue is at line 12 i.e. the second IO
20:55:48 <jrmithdobbs> so does bash
20:56:03 <jrmithdobbs> bash: the worlds least appreciated impure functional language :(
20:56:03 <dwcook> sccrstud92__, yeah, I don't know of it existing in a library, but you're right, I think you can write that with unfoldr if you want
20:56:04 <roboguy_> speaking of, I actually wrote a small forth compiler in haskell that has metaprogramming a couple weeks ago
20:56:54 <sccrstud92__> roboguy_: did you post it on reddit? someone posted a forth interpreter on reddit (today?_
20:57:42 <roboguy_> sccrstud92__: nope, I didn't post it anywhere. it's pretty ugly right now, and it probably only works on OS X because I hand wrote the code generator (since the llvm bindings didn't work on ghc head at the time. they might now, I'm not sure)
20:58:00 <roboguy_> I always wanted to write a forth with quoting and see what I could do with it
20:58:03 <l4u> roboguy_ my guess is to fix line 10-11 so that let tree is at the outer scope. but not sure how
20:58:12 <sccrstud92__> > let unfoldr' f = unfoldr (fmap (id &&& id) . f)
20:58:13 <lambdabot>  not an expression: `let unfoldr' f = unfoldr (fmap (id &&& id) . f)'
20:58:22 <sccrstud92__> :let unfoldr' f = unfoldr (fmap (id &&& id) . f)
20:58:30 <dwcook> You forgot the "in" part
20:58:41 <sccrstud92__> dwcook: there is a way to define function
20:58:43 <dwcook> lambdabot's different from ghci
20:58:47 <roboguy_> l4u: try changing "read_tree(n) ..." into "tree <- read_tree n"
20:58:48 <dwcook> Well there's @let
20:58:52 <excarna> @let foo = id
20:58:53 <roboguy_> and working from there
20:58:53 <lambdabot>  Defined.
20:58:55 <sccrstud92__> @let unfoldr' f = unfoldr (fmap (id &&& id) . f)
20:58:56 <lambdabot>  Defined.
20:58:58 <sccrstud92__> ty
20:59:23 <sccrstud92__> > take 10 $ unfoldr' (Just . (+1))
20:59:24 <lambdabot>  Couldn't match expected type `[a0]' with actual type `a1 -> [a1]'
20:59:26 <dwcook> I'm thinking that function isn't terrible transparent at first glance :D
20:59:29 <sccrstud92__> > take 10 $ unfoldr' (Just . (+1)) 0
20:59:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:59:39 <dwcook> terribly*
20:59:47 <sccrstud92__> agreed
21:00:22 <sccrstud92__> @let unfoldr' = unfoldr . (fmap (id &&& id) .)
21:00:22 <lambdabot>  .L.hs:152:1:
21:00:22 <lambdabot>      Multiple declarations of unfoldr'
21:00:22 <lambdabot>      Declared at: .L.hs:143:1
21:00:23 <lambdabot>                   .L.hs:152:1
21:00:25 <l4u> thanks roboguy_  it works
21:00:37 <sccrstud92__> oh well
21:00:38 <roboguy_> l4u: no problem!
21:00:47 <dwcook> Try checking the @help, possibly in a PM
21:00:54 <dwcook> There might be an @unlet maybe?
21:00:55 <dwcook> @unlet
21:00:56 <lambdabot>  Define what?
21:01:04 <L8D> @hoogle [a] -> [a]
21:01:06 <lambdabot> Prelude cycle :: [a] -> [a]
21:01:07 <lambdabot> Data.List cycle :: [a] -> [a]
21:01:07 <lambdabot> Prelude init :: [a] -> [a]
21:01:09 <sccrstud92__> @unlet unfoldr'
21:01:09 <lambdabot>  Parse failed: TemplateHaskell is not enabled
21:01:17 <L8D> @src init
21:01:17 <sccrstud92__> interesting
21:01:17 <lambdabot> init [x]    = []
21:01:17 <lambdabot> init (x:xs) = x : init xs
21:01:17 <lambdabot> init []     = undefined
21:01:39 <L8D> -.-
21:01:59 <L8D> > init [1..10]
21:02:01 <lambdabot>  [1,2,3,4,5,6,7,8,9]
21:02:01 <dwcook> Runtime safety is for the weak
21:02:11 <sccrstud92__> i think head and init and last and tail should all have unsafe at the front
21:02:12 <L8D> > [1..10]
21:02:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:04:00 <trobertson> sccrstud92__: and have safe versions like head :: [a] -> Maybe a
21:04:24 <sccrstud92__> trobertson: ofc. but they have those already just named differently
21:05:03 <roboguy_> lens essentially has safe versions of head and tail etc
21:05:10 <sccrstud92__> or some sort of non-empty list type that is a hassle to integrate with normal lists
21:05:38 <dwcook> Haskell is sweating dependently typed languages so hard
21:05:43 <dwcook> Or is it the other way around? Or both?
21:06:06 <roboguy_> > [] ^? _head
21:06:08 <lambdabot>  Nothing
21:06:15 <roboguy_> > [1,2,3] ^? _head
21:06:17 <lambdabot>  Just 1
21:06:24 <Twey> I'd rather just have statically-typed vectors
21:06:42 <Twey> head ∷ Vec (suc n) a → a
21:07:03 <sccrstud92__> Twey: whats wrong with Array?
21:07:05 <Twey> Oh wait, we have those :þ
21:07:06 <haasn> sccrstud92__: the “unsafe” prefix apparently tends to mean “can cause segfaults if used incorrectly”
21:07:22 <sccrstud92__> haasn: thats a good point
21:07:25 <Twey> sccrstud92__: That's not the same thing at all.
21:07:26 <haasn> and not “may throw an exception”
21:07:39 <sccrstud92__> haasn: is there any naming convention for partial functions?
21:07:42 <haasn> I'm fairly sure I want unsafe to remain a big warning flag, bigger than what head/tail/etc deserve
21:07:57 <sccrstud92__> Twey: how so?
21:07:59 <haasn> sccrstud92__: there was a question on the mailing lists recently asking basically this; not really
21:08:06 <L8D> What's the language setting that let's you do the \case of
21:08:16 <greedo> so, I have a Map
21:08:27 <geekosaur> L8D: LambdaCase
21:08:35 <Twey> sccrstud92__: I was talking about length-indexed lists; nothing to do with arrays.  :þ
21:08:35 <geekosaur> (LANGUAGE pragma)
21:08:44 <L8D> geekosaur: cool
21:08:45 <greedo> and I have tried to convert it to a List
21:08:49 <Twey> L8D: And it's just \case
21:08:54 <sccrstud92__> Twey: why cant you do that with arrays?
21:09:00 <greedo> using toList
21:09:01 <L8D> Twey: \case 0 -> 0; 1 -> 1
21:09:04 <L8D> Like that?
21:09:07 <dwcook> sccrstud92__, arrays don't include their length in the type
21:09:21 <sccrstud92__> dwcook: but there are already types that encode length
21:09:24 <Twey> sccrstud92__: Um, I guess you can have length-indexed arrays too if you want, but we were talking about lists
21:09:47 <sccrstud92__> Twey: u said vector originally so i just assumed you didnt mean lists
21:10:13 <greedo> I think I should be able to return multiple values from it now
21:10:18 <Twey> sccrstud92__: A ‘vector’ in a functional context generally means a list type indexed by length
21:10:20 <dwcook> To paraphrase some manual I read, "vector" in the dependently typed literature often basically means a list whose type includes its length
21:10:20 <roboguy_> sccrstud92__: confusingly, in dependently typed languages, lists with their length encoded in types are called "vectors"
21:10:25 <sccrstud92__> dwcook: and i see why i was wrong about Arry. that type parameter is for the index type with would not be the same as the length type
21:10:43 <Twey> sccrstud92__: The Haskell array package by the same name is unfortunate :þ
21:10:44 <sccrstud92__> roboguy_: my mistake. my noobiness is showing
21:10:46 <roboguy_> greedo: ?
21:10:58 <roboguy_> sccrstud92__: I found that out recently myself, actually
21:11:11 <dwcook> greedo, what is the problem you're having?
21:11:15 <sccrstud92__> roboguy_: so did i
21:11:56 <sccrstud92__> get it
21:11:56 <greedo> I have function that takes a list of fields and returns a Data.Map
21:11:59 <sccrstud92__> cuz it just happened
21:12:07 <sccrstud92__> the learnings
21:12:10 <Twey> sccrstud92__: A ‘vector’ Vec n a is the type of a list of n elements of type a
21:12:45 <greedo> in the example they use Data.Map.lookup to rreturn a specific entry
21:12:47 <Twey> sccrstud92__: By setting n = suc n, you get a non-empty list for free, in a way that's compatible with all your other uses of vectors
21:12:49 <greedo> return*
21:13:08 <Twey> sccrstud92__: And if you use an existential type to throw away the n you get basically a list
21:13:15 <greedo> however I need all the entries in the Map
21:13:25 <dwcook> greedo, and what's the issue with using toList?
21:13:26 <sccrstud92__> Twey: i was thinking you could do that with Array using the extra type param but i quikcly realized that was ludicrous
21:13:44 <Twey> sccrstud92__: Extra type param?
21:13:56 <sccrstud92__> Array i e
21:13:57 <greedo> dwcook: it's ok, except the Map is inside a Maybe
21:14:11 <sccrstud92__> Vector a
21:14:23 <dwcook> greedo, you have a Maybe (Maybe Foo Bar) for some Foo and Bar? Well, just pattern match the Maybe away.
21:14:24 <roboguy_> greedo: what about fmap toList?
21:14:28 <dwcook> Or that.
21:14:42 <sccrstud92__>  i see why i was wrong about Arry. that type parameter is for the index type with would not be the same as the length type
21:14:43 <Twey> sccrstud92__: Which of these is ‘extra’?  :þ  i is the type of indices into the array, not the size of the array
21:14:58 <greedo> dwcook: I have a IO (Maybe (Map (QuoteSymbol, QuoteField) QuoteValue))
21:15:02 <sccrstud92__> Twey: exactly. thats why it would be lludicrous
21:15:13 <Twey> sccrstud92__: But you can have an Array (Fin n) a, which has size n
21:15:22 <Twey> So it's not totally silly
21:15:32 <greedo> dwcook: but I want more than one QuoteField
21:15:43 <dwcook> greedo, and what type are you after? IO (Maybe [((QuoteSymbol, QuoteField), QuoteValue)]), or something else?
21:15:49 <roboguy_> greedo: what do you want to have?
21:15:52 <Twey> (well, one would *hope* it has size n, though there's nothing in Haskell to stop you having a bigger index than you support)
21:15:52 <sccrstud92__> Twey: are you talking about Haskell arrays? or some other Array type
21:16:00 <Twey> Haskell arrays :þ
21:16:20 <sccrstud92__> Twey: but the operations would have the wrong types
21:16:44 <Twey> sccrstud92__: Hmm?
21:16:57 <Rotaerk> hmm, makeLenses produces a Q [Dec] ... is there any way to pretty-print that?
21:17:14 <sccrstud92__> Twey: like if you map over the indexes and change their type the array length is actually the same
21:17:16 <Rotaerk> pprint takes an Exp
21:17:16 <sccrstud92__> so its lying to you
21:17:18 <joelteon> -ddump-splices
21:17:28 <Rotaerk> hmm k
21:17:37 <roboguy_> sccrstud92__: it looks to me like you might be confusing the index type with the length type
21:18:07 <roboguy_> sccrstud92__: a "vector" in the sense of a dependently typed list is just like [a] but it has extra type level information that stores it's length
21:18:10 <Twey> sccrstud92__: If your indexes are of type Fin n, you can shuffle them around, but you're still going to have n of them
21:18:21 <sccrstud92__> Twey: what is Fin?
21:18:37 <greedo> roboguy_: I believe IO String needs to be returned
21:18:46 <greedo> and then lift handles it
21:18:47 <Twey> sccrstud92__: Fin n is the type containing precisely n distinct elements
21:19:01 <hydrospell> test.
21:19:06 <sccrstud92__> Twey: okay thats where my confusion came from
21:19:06 <augur_> data Phantom a = Phantom ;   foo :: Phantom Int ; foo = Phantom ;   bar :: Phantom String ; bar = foo   <--- this will type error, for interesting reasons
21:19:08 <Twey> sccrstud92__: So (up to isomorphism) Fin 0 is Void, Fin 1 is (), Fin 2 is Bool, &c.
21:19:28 <sccrstud92__> Twey: n nested Maybes
21:19:40 <Twey> Right
21:19:46 <Twey> (up to ⊥)
21:19:53 <L8D> :t (return [] >>= 1:)
21:19:53 <dwcook> greedo, how are you going to compute this String?
21:19:54 <lambdabot>     The operator `:' [infixr 5] of a section
21:19:54 <lambdabot>         must have lower precedence than that of the operand,
21:19:54 <lambdabot>           namely `>>=' [infixl 1]
21:19:58 <L8D> :t (return [] >>= (1:))
21:19:59 <lambdabot> Num b => [b]
21:20:06 <sccrstud92__> Twey: that symbol after the word "to" youu type looks strange to me
21:20:15 <sccrstud92__> Twey: my font might not support it
21:20:16 <roboguy_> sccrstud92__: essentially, data Vector n a where { Empty :: Vector Zero a; Cons :: a -> Vector n a -> Vector (Successor n) a }
21:20:27 <dwcook> sccrstud92__, "bottom", also written _|_ in imitation of the symbol
21:20:29 <sccrstud92__> Twey: looks like a squre with 4 circles in it
21:20:31 <Twey> sccrstud92__: It's the symbol ‘bottom’.  It should look something like an upside-down capital T.
21:20:49 <Twey> That's not how it should look.  ☺  Install more fonts?
21:20:58 <sccrstud92__> Twey: gotcha. yeah its broken in this font, looks nothing like that
21:21:06 <dwcook> Únícódé rócks
21:21:33 <sccrstud92__> if i could find a good font that supports all unicode i would definately consider it
21:21:33 <greedo> dwcook: I need to combine several values from the Map
21:21:42 <sccrstud92__> but unicode is huge so not a lot do
21:21:48 <dwcook> greedo, okay, do you have a Map Foo Bar -> String ?
21:22:15 <dwcook> (Where Foo is your key type, Bar is your value type, written that way for brevity)
21:22:42 <joelteon> is (+1) bijective
21:22:49 <dwcook> joelteon, for what type?
21:22:54 <joelteon> Integer
21:22:57 <greedo> dwcook: yes, the problem is Foo is a Key-Value pair
21:23:12 <dwcook> joelteon, yes, I believe so.
21:23:19 <sccrstud92__> Twey: so I know what S/Succ/Successor and Fin represent. are they any other basic type notations in that vein I should know?
21:23:20 <greedo> dwcook: but I need a Key-Values pair
21:23:21 <dwcook> greedo, no it's not.
21:23:35 <dwcook> Ah, you want to associate more than one value with any given key?
21:23:55 <dwcook> Sounds like you want maybe a MultiMap, if that exists
21:24:06 <greedo> dwcook: I want to lookup more than one value
21:24:09 <sccrstud92__> dwcook: or its multiple keys per value
21:24:26 <dwcook> sccrstud92__, that's nothing more than a Map does already
21:24:40 <dwcook> greedo, how so? Give an example.
21:24:42 <greedo> each Key has multiple Values
21:24:52 <dwcook> @hackage multimap
21:24:52 <lambdabot> http://hackage.haskell.org/package/multimap
21:24:55 <joelteon> Map a [k]?
21:24:56 <dwcook> There's that, or you can make your values lists
21:24:58 <joelteon> err
21:25:00 <joelteon> Map k [a]
21:25:14 <sccrstud92__> or Map a (Set b)
21:25:26 <dwcook> But if you do the latter you'll have to manage it yourself, which sort of defeats the purpose of using an abstraction
21:25:36 <dwcook> Not that it'd be hard to write one on top of Map
21:25:50 <greedo> dwcook: key: ("YHOO","c") returns "24.00"
21:26:03 <dwcook> greedo, I thought you wanted to return multiple values?
21:26:19 <dwcook> I think we're suffering from a disparity in our terminology.
21:26:23 <greedo> but I need ("YHOO", "c", "m1")
21:26:41 <dwcook> 3-tuples are a different type from 2-tuples. You can't mix them together in the same Map.
21:26:45 <greedo> dwcook: http://hackage.haskell.org/package/Finance-Quote-Yahoo-0.7.0/docs/Finance-Quote-Yahoo.html
21:26:58 <greedo> it's strange
21:27:24 <greedo> see quoteFieldsList = ["s","l1","c"]
21:27:27 <dwcook> If you need varying lengths, use a collection type such as a list or a set or related.
21:27:54 <L8D> :t (>>= \(x:xs) -> x)
21:27:55 <lambdabot> Monad m => m [m b] -> m b
21:28:05 <greedo> so I want to "c" ++ "l1"
21:28:22 <dwcook> At this point I'm completely lost as to what you want.
21:28:36 <Twey> sccrstud92__: Uhh, probably.  :þ
21:28:37 <dwcook> Could you please give examples?
21:28:46 <sccrstud92__> Twey: haha
21:29:15 <sccrstud92__> Twey: is the name for that stuff just dependant types?
21:29:25 <Twey> They're usually obivous enough from context
21:29:26 <Twey> obvious**
21:29:34 <dwcook> greedo, write down some applications of this hypothetical function you want, with inputs and outputs specified.
21:29:42 <Twey> Not really; we can have both of those types in Haskell, for example, which  doesn't have dependent types
21:29:43 <dwcook> If you can.
21:29:54 <greedo> dwcook: ok, thanks
21:30:50 <Twey> sccrstud92__: Dependent types just gets you the ability to use the same values on both the value and type levels.  So long as you're willing to use a separate type-level representation of things like naturals, you can do this just as well in, say, Haskell.
21:31:10 <L8D> Is there anything I can be doing to clean up this code? https://gist.github.com/L8D/8007803
21:31:18 <L8D> I want to seperate it into two chunks
21:31:34 <sccrstud92__> Twey: so its called something else? I just looking for something i can google to find more information
21:31:35 <L8D> one being the words which deal the with stack in a pure manor (wrapped with fmap)
21:31:36 <Twey> sccrstud92__: (and you can transport data between them using singletons or equivalent tricks)
21:31:44 <L8D> and the others being directly used with the IO
21:31:56 <Twey> sccrstud92__: I guess ‘type-level computation’ is about as correct as you'll get
21:32:10 <dwcook> L8D, I notice you can factor out an fmap from lines 12-22
21:32:27 <Twey> sccrstud92__: In Haskell terms, I guess they're type families
21:32:36 <L8D> dwcook: how?
21:32:58 <Twey> They do most often come up in the context of dependent types, though, because a lot of the interesting things you'd want to do with type families are kind of clumsy without dependent typing
21:33:07 <dwcook> L8D, put it in front of the case expression
21:33:19 <L8D> dwcook: but what about line 20?
21:33:32 <dwcook> L8D, ah, sorry, missed that.
21:33:32 <sccrstud92__> Twey: but haskell also has something called "dependent types" doesnt it?
21:33:39 <Twey> (and some of them, especially things that involve reflection of code, are effectively impossible by virtue of the type- and value-level representations of things being the same)
21:33:44 <L8D> dwcook: that's why everything is in IO
21:33:48 <Twey> sccrstud92__: No, Haskell is not a dependently-typed language
21:34:05 <sccrstud92__> Twey: i thought there was an extension
21:34:06 <Twey> (though its type system is powerful enough that you can pretend a lot of the time)
21:34:13 <Twey> There isn't
21:34:16 <sccrstud92__> Twey: though maybe i just assumed there was
21:34:21 <Twey> (… so far)
21:34:31 <L8D> dwcook: any ideas on how I could seperate the two?
21:34:33 <dwcook> I can't help but think you could organize this with a transformer stack built over IO, but I'm too tired to think of how just now
21:34:47 <dwcook> In fact I should go to bed. Good night everyone.
21:34:52 <L8D> dwcook: oh wait...I have an idea
21:35:07 <dwcook> L8D, sure, I'll hear it before I go
21:35:34 <greedo> dwcook: http://lpaste.net/7242741743681011712
21:36:52 <greedo> see they didn't design the function to return multiple values
21:37:01 <L8D> dwcook: not ideal, but reload the page
21:37:21 <Cale> sccrstud92__: There are some things which are sort of heading in the direction of adding some of the flavour of dependent type systems to Haskell, but they don't really go the whole way there.
21:37:57 <dwcook> L8D, maybe. Though honestly even my suggestion was a kind of trivial improvement
21:38:18 <L8D> dwcook: it does what I want it to, but I have to keep the indentation
21:38:50 <dwcook> Okay, I'm gonna hit the sack now. Good night.
21:38:55 <L8D> night
21:38:59 <greedo> night
21:44:42 <L8D> @hoogle Int -> Bool
21:44:43 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
21:44:43 <lambdabot> Data.IntSet member :: Key -> IntSet -> Bool
21:44:43 <lambdabot> Data.IntSet notMember :: Key -> IntSet -> Bool
21:52:40 <L8D> To all who are good haskell programmers, is this a good way to structure an interpreter? https://gist.github.com/L8D/8007803
21:53:44 * hackagebot purescript 0.3.10.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.10.1 (PhilFreeman)
21:53:44 * hackagebot markdown-pap 0.0.1.0 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.0 (YoshikuniJujo)
21:55:01 <orzo> hi
21:55:21 <bicgena> I just realized I've barely even scratched the surface of Mathematica. I spent an hour hacking together a solution for Project Euler's #66 (implementing the continued fraction hint) and then I go to the forum and this guy brute-forced it (taking advantage of Mathematica's lazy evaluation) with a one-liner: http://pastie.org/private/qaq8jbbp7mottrapa6kxsa
21:55:21 <bicgena> how would I do this in haskell?
21:55:39 <orzo> I've come up with a type class and i'm not sure what to name it.  I've documented my idea here: http://jerkface.net/~joe/Name-this-type-class.html
21:55:44 <Twey> L8D: Why is the stack wrapped in IO?
21:55:46 <L8D> bicgena: this is #haskell, not #mathematica
21:55:56 <L8D> Twey: for all the IO operations
21:56:03 <L8D> right now, the only one is one line 12
21:56:06 <bicgena> L8D: I asked how I'd do that in mathematica
21:56:06 <Twey> L8D: Also, why do you hate pattern-matching at the top-level?  :þ
21:56:09 <bicgena> er, haskell*
21:56:27 <Twey> L8D: No, that's why the *interpreter* is in IO
21:56:27 <L8D> Twey: because it's a lot more verbose
21:56:28 <orzo> So i'm wanting feedback on the name and also whether the whole idea is a little daft and can be solved more simply
21:56:53 <Twey> L8D: You don't need the stack (the second parameter to your function) to be in IO
21:56:59 <Twey> Only the return value
21:57:13 <L8D> Twey: omg
21:57:16 <L8D> you just blew my mind
21:57:21 <L8D> thanks
21:57:25 <L8D> I didn't think about that
21:57:28 <Twey> At the point where you interpret a new word, you should have already evaluated everything necessary to build the current stack
21:58:14 <Twey> In general I think most people would advocate using a top-level function over a case
21:58:26 <L8D> Twey: for which function?
21:58:40 * hackagebot markdown2svg 0.0.1.5 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.5 (YoshikuniJujo)
21:58:50 <Twey> All of them :þ
21:59:25 <L8D> Twey: I couldn't do it for interpret, and I could do it for the first level of execWord, but that's because I recently made the change and forgot to change that
21:59:48 <L8D> otherwise I'd have a gazillion lines of execWord "..." = ...
22:00:01 <L8D> which I couldn't do without a strong wrapper
22:00:02 <Twey> L8D: That's generally considered better style
22:00:10 <L8D> with*
22:00:31 <Twey> For interpret you can use pattern guards or just the ‘maybe’ eliminator
22:01:16 <orzo> so can i get any attention for my type class
22:01:38 <Twey> L8D:interpret (x : xs) ys = interpret xs . maybe (execWord (map toLower x) ys) (fmap (x :) ys) $ maybeRead x
22:01:52 <DrAwesomeClaws> hi folks.  I've been digging through this tutorial http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot  and have run into an issue.  After refactoring w/ a State monad (after the line: "The monadic, stateful, exception-handling bot in all its glory") I get this exception https://gist.github.com/anonymous/5ad1cfbf631842bff9c5    I've tried just copy/pasting the code from the page, have the same issue.
22:02:06 <Twey> Err
22:02:32 <geekosaur> DrAwesomeClaws, that code is a bit out of date (someone should probably update it), the exception handling stuff has changed
22:03:12 <DrAwesomeClaws> geekosaur: ah.  Good to know.  Thanks
22:03:12 <Twey> L8D: interpret (x : xs) ys = interpret xs $ maybe (execWord $ map toLower x) (fmap . (:)) (maybeRead x) ys
22:03:40 * hackagebot markdown2svg 0.0.1.6 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.6 (YoshikuniJujo)
22:03:49 <geekosaur> you might be able to fix it by adding {-# LANGUAGE ScopedTypeVairables #-} at the top and changing (const $ return ()) to (\(e :: SomeException) -> return ())
22:04:03 <geekosaur> (I think that's right... probably better ways to write it too)
22:04:42 <geekosaur> hm, actually that might be a bit excessive as it means you can't exit with control-c
22:05:32 <geekosaur> instead of SomeException you may want IOException
22:07:31 <DrAwesomeClaws> thanks geekosaur, that worked.  I was just looking up the docs on Exception handling and was working toward a similar solution, but couldn't figure out the correct syntax, hshs
22:07:32 <DrAwesomeClaws> haha
22:07:45 <Twey> orzo: How is this different from the Functor instance of Either?
22:08:01 <Twey> (or Either a, rather)
22:09:21 <Aetherspawn> Does anyone know how to get the tools
22:09:25 <Aetherspawn> llc, opt, etc from llvm on OSX?
22:09:50 <geekosaur> you need to install full llvm from somewhere (fink, macports, homebrew, ...)
22:09:58 <orzo> Twey: i'm not sure i understnad your question.
22:10:01 <Aetherspawn> when I do that I don't get the tools
22:10:04 <Aetherspawn> I've been installing 3.3 from brew
22:10:12 <geekosaur> huh.
22:10:38 <Aetherspawn> yeah its wierd
22:10:45 <geekosaur> I know you get them from the macports llvm ports, looking at homebrew's code leaves me disinterested in examining it further
22:10:46 <Twey> orzo: I'm not sure I understand your typeclass :þ
22:10:48 <orzo> Twey: Either would sensibly implement Unfunctor by defining un (Left _) = Nothing and un (Right x) = x
22:10:51 <L8D> :t fmap . (:)
22:10:52 <lambdabot> Functor f => a -> f [a] -> f [a]
22:11:04 <L8D> :t maybe
22:11:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:12:02 <Twey> orzo: Right, but what do you gain by doing so?
22:12:30 <Twey> orzo: It seems like Unfunctor g => g a is the same thing as Either a a
22:13:27 <Haynesy> :t folds
22:13:28 <lambdabot>     Not in scope: `folds'
22:13:28 <lambdabot>     Perhaps you meant one of these:
22:13:28 <lambdabot>       `foldr' (imported from Data.List),
22:13:46 <Haynesy> :t foldr
22:13:47 <lambdabot> (a -> b -> b) -> b -> [a] -> b
22:14:24 <L8D> Twey: is that better? reload the page
22:14:24 <Haynesy> :t foldl
22:14:25 <lambdabot> (a -> b -> a) -> a -> [b] -> a
22:14:27 <orzo> Twey: say i have a type data ConnectionEvent x = Connect | Got x | NeedsPing | EOF, and i want feed it to a processor to transform  [ConnectionEvent x] -> [ConnectionEvent y] given a parser [x]->[y]
22:14:47 <Aetherspawn> oh
22:14:50 <Aetherspawn> the right formula is
22:15:02 <Aetherspawn> llvm3{3,4} instead of just llvm
22:15:13 <Twey> L8D: There's still a spurious IO on interpret
22:15:22 <orzo> Twey: ConnectionEvent would implement un (Got x) = x and un _ = Nothing
22:15:26 <Twey> L8D: (/= "") = notNull
22:15:57 <orzo> then the parser could let the nullary elements through and just do its job on parsing the data
22:16:02 <L8D> Twey: you'd rather me put (not . null) ?
22:16:22 <Twey> L8D: No, there's actually a function called notNull
22:16:28 <Twey> I don't know why, but you might as well use it
22:16:29 <L8D> @hoogle notNull
22:16:29 <lambdabot> No results found
22:16:44 <Twey> Oh, apparently I misremembered
22:16:49 <Twey> Okay
22:16:58 <Twey> Guess I was thinking of notElem
22:17:04 <L8D> What do you mean by spurious IO though?
22:17:24 <Twey> L8D: Your interpret function doesn't take a stack, it takes an IO action that will generate a stack
22:17:25 <L8D> did you mean superflous?
22:18:14 <Twey> Oh, I wrote ‘spurious’
22:18:19 <Twey> Well, I guess that works too :þ
22:18:20 <L8D> Twey: so... do the recursion internally with the IO?
22:18:28 <L8D> in a where-clause
22:18:49 <Twey> L8D: I'm not sure what that means
22:19:00 <L8D> could you show me what you mean?
22:19:20 <L8D> You want it into [String] -> [Int] -> IO [Int]
22:20:17 <Haynesy> @hoogle String -> [String]
22:20:18 <lambdabot> Prelude lines :: String -> [String]
22:20:18 <lambdabot> Data.List lines :: String -> [String]
22:20:18 <lambdabot> Data.String lines :: String -> [String]
22:23:12 <orzo> Twey: I guess what i gain is being able to use Got x|EOF|NeedsPing|Connected instead of Right x|Left EOF|Left NeedsPing|Left Connected
22:26:57 <zain_> Is there anyone here?
22:26:59 <L8D> Twey: like this?
22:27:23 <zain_> Hey
22:27:42 <L8D> zain_: Hi?
22:27:49 <zain_> This my first time talking on this channel
22:27:53 <L8D> oh
22:27:59 <zain_> I am from China
22:28:04 <L8D> zain_: oh cool!
22:28:14 <L8D> Simplified or Traditional?
22:28:29 <zain_> simplified
22:28:59 <zain_> You are the administrator here ?
22:29:25 <zain_> Are you the administrator here?
22:29:35 <L8D> zain_: 你好
22:29:44 <zain_> I am not good at engish
22:29:45 <L8D> sorry, my pinyin translator is messed up
22:29:56 <L8D> zain_: I am not the administrator
22:29:58 <zain_> You are right
22:30:02 <startling> haha
22:30:15 <zain_> We say hello like that
22:30:21 <L8D> and both of those sentences have correct grammer.
22:30:32 <L8D> zain_: I know basic chinese
22:30:45 <zain_> but i have no chinese input method on my working computer
22:31:16 <zain_> L8D: where are you come from?
22:31:27 <L8D> zain_: You could either just write pinyin or use a pinyin to unicode writer
22:31:33 <L8D> zain_: I live in the U.S. currently
22:31:55 <L8D> I work with a lot of western asians though
22:32:13 <zain_> oh i see
22:32:28 <L8D> zain_: Do you use haskell?
22:32:55 <zain_> No, just interested in haskell
22:33:27 <zain_> And i do not know anyone of i knew use it
22:33:44 * hackagebot markdown2svg 0.0.1.7 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.7 (YoshikuniJujo)
22:34:01 <zain_> What's haskell usually use for?
22:34:10 <L8D> zain_: is 你好 and 你是好 synonymous?
22:34:12 <mzero> anything!
22:34:48 <L8D> zain_: a lot of people use haskell for data analysis and data processing
22:34:49 <ParahSailin> latter is not grammatical
22:35:12 <L8D> 你是好人
22:35:15 <L8D> there
22:35:27 <zain_> haha
22:35:32 <L8D> that is 'grammatical'
22:36:17 <zain_> Am i the first chinese who appears on this channel?
22:36:31 <pavonia> No
22:36:36 <mzero> unlikely
22:36:40 <zain_> Are you?
22:36:50 <L8D> zain_: not very many people reveal their nationality on IRC
22:37:16 <pavonia> zain_: I'm not Chinese but I know one has been here before
22:37:23 <zain_> oh
22:37:55 <zain_> cause i was use chinese on the XChat before
22:38:29 <L8D> zain_: so, what would you like to learn about haskell?
22:38:47 <Platz> Paradoxically my intuition is the more specialized the group, the more diverse the demographics
22:38:59 <zain_> I am just interested in haskell
22:39:16 <zain_> I am not sure will gonna to learn it or not
22:39:38 <zain_> I am using Java now
22:40:26 <L8D> zain_: what are you using Java for?
22:40:27 <greedo> zain_: have you heard of Scala?
22:40:38 <sccrstud92__> @hoogle [a] -> (a, [a])
22:40:39 <lambdabot> Data.Char readLitChar :: ReadS Char
22:40:40 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
22:40:40 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
22:40:40 <zain_> L8D:Android
22:40:53 <sccrstud92__> @hoogle [a] -> Maybe (a, [a])
22:40:53 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
22:40:53 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (forall e. Data e => a -> e -> (a, q)) -> a -> d -> (a, [q])
22:40:53 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:40:54 <zain_> greedo: yes
22:41:10 <L8D> zain_: oh, unfortunately writing android apps in Haskell is fairly difficult
22:41:32 <L8D> zain_: but, as greedo hinted, I highly recommend a look at Scala
22:41:51 <Twey> L8D: http://lpaste.net/982224759641079808 — like this
22:41:52 <Platz> There's scaloid for adnroid at least.
22:41:58 <zain_> L8D_: Maybe i will learn haskell for fun
22:42:14 <Twey> orzo: *nod* Okay :þ
22:42:22 <sccrstud92__> is the java vm the only thing that you can develop on for android?
22:42:45 <Twey> sccrstud92__: You can  write native code, but it'll be platform-specific
22:42:52 <Platz> but you have to be careful with GC'ing too many objects if really embracing the immutable style
22:42:59 <zain_> sccrstud92__: yeah, it seems true for now
22:43:01 <Twey> And there are various toolkits that compile to both Android and iOS
22:43:05 <L8D> Twey: noooo
22:43:07 <Twey> (and Windows Phone now, too)
22:43:12 <L8D> you have the operators backwards
22:43:45 <Twey> L8D: I do?
22:44:11 <sccrstud92__> what flags prompy ghc to perform buildr/(..) fusion?
22:44:20 <sccrstud92__> i forget what its called
22:44:26 <L8D> Twey: it sohuld be (x0:x1:xs) = f x1 x0 : xs
22:44:38 <Twey> Oh, so I do
22:44:48 <Twey> I didn't actually run it :þ
22:45:08 <Twey> But you get the idea
22:45:09 <enthropy> -O or -O2 should do it
22:46:13 <L8D> > negate . fromEnum $ True
22:46:14 <lambdabot>  -1
22:46:18 <L8D> > negate . fromEnum $ False
22:46:19 <lambdabot>  0
22:46:36 <L8D> Twey: you sly sonofabitch
22:46:55 <L8D> I mean that in the politest way possible
22:47:00 <Twey> Haha
22:47:47 <Twey> You can also use  Data.List.Lens._head %~ f  instead of \(x : xs) → f x : xs
22:48:18 <Twey> Oh, I ended up not using bool
22:48:25 <L8D> Twey: I really don't want to use lens
22:48:30 <sccrstud92__> is there an "uncons"? ie [a] -> (a, [a])
22:48:36 <Twey> Hm
22:48:44 <Twey> sccrstud92__: No ☹
22:48:56 <Twey> sccrstud92__: You can use (head &&& tail)
22:49:33 <sccrstud92__> hmm
22:49:39 <sccrstud92__> splitAt 1 would work too
22:49:46 <sccrstud92__> except its
22:49:50 <sccrstud92__> ([a], [a])
22:49:55 <sccrstud92__> hmm
22:50:03 <sccrstud92__> gonna go with urs twey, probably
22:50:34 <Twey> You can first head . splitAt 1
22:50:45 <Twey> Not much point, though, since you have to pull in Arrow anyway
22:51:37 <L8D> Twey: I think using the dict is a little too much, but otherwise thanks
22:51:49 <L8D> You cleaned it up a lot and now the IO works lazily
22:52:07 <L8D> (as in, doesn't wait until stdin closes to run everything)
22:53:19 <L8D> Twey: Why didn't you put (-->) in dict's where-clause?
22:53:30 <Twey> Added it later
22:53:43 <Twey> I think the dict is entirely appropriate
22:53:46 * hackagebot hi 0.0.8 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.8 (DaisukeFujimura)
22:53:52 <Twey> Especially if you're going to introduce a facility to define words later
22:53:57 <L8D> Twey: omg
22:54:02 <L8D> thanks
22:55:38 <L8D> I think I'll do dict = [...IO functions...] ++ map return [ ...pure functions...]
22:58:38 <L8D> :t lookup
22:58:39 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:03:47 * hackagebot pipes-courier 0.1.0.0 - Pipes utilities for interfacing with the courier message-passing framework.  http://hackage.haskell.org/package/pipes-courier-0.1.0.0 (KyleVanBerendonck)
23:04:45 <Twey> L8D: Oh, yeah, I was going to do that but forgot
23:06:21 <L8D> Twey: how would you define execWord like that?
23:08:40 <Twey> L8D: http://lpaste.net/982224759641079808
23:09:05 <L8D> Twey: okay cool
23:11:16 <L8D> @pl \(a,b) -> (a, return . b)
23:11:16 <lambdabot> second (return .)
23:11:24 <L8D> :t second
23:11:25 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
23:12:23 <shachaf> Does "data k *> a = k => Foo a" exist in a library?
23:13:08 <L8D> Twey: I know it's not completely your style, but I wanted to avoid using arrow or lens
23:13:19 <L8D> https://gist.github.com/L8D/8007803
23:14:09 <enthropy> shachaf: http://hackage.haskell.org/package/exists-0.2/docs/Data-Exists.html
23:14:17 <Aetherspawn> do I have to do anything special to get haddock docs
23:14:22 <enthropy> with a different name
23:14:24 <Aetherspawn> or does hackage automatically generate them with a cron
23:14:31 <shachaf> enthropy: That's a different type.
23:14:41 <shachaf> Mine is not existential.
23:14:52 <enthropy> true
23:15:09 <mzero> Aetherspawn: I believe it does
23:15:31 <Aetherspawn> cool
23:15:50 <Twey> L8D: Why?  :þ
23:15:52 <shachaf> ski always uses *>
23:15:56 <Twey> Well, it's just a lambda anyway
23:16:11 <shachaf> But I think as a language built-in, not a data type.
23:16:15 <L8D> Twey: because sometimes I need things to compile in hugs
23:16:19 <Twey> L8D: You realize you're not actually using OverloadedStrings, right?
23:16:29 <Twey> L8D: But you were fine with LambdaCase :þ
23:17:20 <Twey> Well, looks like you've got the important stuff down
23:18:09 <L8D> Twey: booya
23:18:12 <L8D> Twey: thanks again
23:18:15 <L8D> just cuz
23:18:22 <L8D> ur awezum
23:18:49 * hackagebot markdown-pap 0.0.1.1 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.1 (YoshikuniJujo)
23:18:51 <L8D> now on to some restructuring to have the dict passed around
23:20:28 <orzo> Twey: does this name make it seem less daft? http://jerkface.net/~joe/FunctorToMaybe.html
23:20:32 <orzo> heh
23:21:03 <Twey> orzo: No :þ
23:21:26 <Twey> Quite the opposite :þ
23:21:59 <ski> shachaf : i suppose you could simulate it that way, yes
23:22:00 <orzo> you're saying yo ulike the old name better?
23:22:17 <Twey> orzo: No, the new name is much more informative
23:22:28 <Twey> It's just that it's informing you that the class is silly :þ
23:22:48 <shachaf> Speaking of which, how would type inference for existential types work, if at all?
23:23:41 <ski> shachaf : i suspect it could work, given some manual signature specification (like with poly. rec., higher-rank and GADTs, e.g.)
23:24:15 <orzo> Twey: has it escaped you that functorToEither actually magicaly transformed the type f a to f b without any a->b function?
23:24:46 <orzo> putting that kind of trickery in a type class makes sense to me
23:25:08 <ski> shachaf : e.g. if you say `[True,"False"]', it's not obvious which properties of the types `Bool' and `String' that you'd want to not hide. so some amount of explicit specification would be required, at least
23:25:28 <orzo> it only works because of a gaurontee youre making that it is safe to fmap undefined... those kinds of gaurontees are what type clsases are for
23:25:28 <shachaf> ski: Right.
23:25:48 <shachaf> The same problem exists for rank-2 types, of course, since you can use them to encode existentials.
23:25:56 <Twey> orzo: The guarantee you're making is that you have Either a a, not Either a b
23:26:05 <shachaf> E.g. \f -> [f True, f "False"]
23:26:36 <ski> (with universals, we can attempt to give the thing with the (possibly) universal type the most general type it could have, without having to take into account (non-cyclic) uses of it, and then it'll automatically also work for those uses. for existentials, the picture is reversed, in some sense)
23:26:46 <shachaf> Right.
23:26:57 <shachaf> You choose which information you want to capture and which you want to hide.
23:27:25 <ski> so the main question is to what extent one can distribute down explicitly specified existential information down in the type checking, in an appropriate way, i think
23:27:29 <shachaf> E.g. exists x. (Show x, Eq x) *> x gives the consumer more information.
23:27:39 <shachaf> (Than just one of the constraints, or no constraint at all.)
23:27:43 <orzo> Twey: no, when you define un x = Nothing, you are telling the compiler that it is safe to write (fmap undefined x) to transform its type
23:28:38 <ski> (i wonder whether type inference for rank-2 would be interesting to look at here, to compare with ?)
23:28:42 <orzo> so you can change (Nothing :: Maybe Int) to (Nothing :: Maybe Char)
23:28:50 * hackagebot markdown-pap 0.0.1.2 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.2 (YoshikuniJujo)
23:29:01 <shachaf> I think type classes make it too complicated so first I'd like to understand how it would work without type classes.
23:29:09 <ski> yes
23:29:25 <shachaf> (\x -> x x) has multiple valid rank-2 types
23:30:10 <shachaf> People say rank-2 types are inferrable but I don't really know what they mean.
23:30:54 <ski> if you write `[(True,show),("False",id)]', then it would seem to be easier to handle the "how much non-abstract" question
23:31:08 <ski> shachaf : i haven't looked into it, so i dunno either :/
23:32:09 <ski> (mayhaps it can infer an intersection type of all valid rank-2 types, or something along those lines)
23:37:28 <L8D> :t (>=>)
23:37:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:38:51 * hackagebot markdown2svg 0.0.1.8 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.8 (YoshikuniJujo)
23:39:55 <startling> markdown-to-svg? o.o
23:42:32 <StoneCypher> *blinks*
23:42:36 <StoneCypher> that's ... a strange conversion.
23:42:45 <StoneCypher> i am having a hard time imagining why someone would want that.
23:43:04 <StoneCypher> not to mention that html, when wrapped in <svg>, would be a perfectly valid representation
23:44:10 <L8D> @pl flip (f x) [] . g
23:44:10 <lambdabot> flip (f x) [] . g
23:45:22 <dmwit> Why is markdown to SVG any stranger than other formats for rendering markdown?
23:46:55 <StoneCypher> well, for one, i can't think of a reason to want it
23:47:00 <StoneCypher> maybe if you can you'd share?
23:47:20 <dmwit> Seems like just as cromulent a thing to want as HTML.
23:47:58 <dmwit> I don't see why browsers are the clear winners in terms of markdown viewers.
23:49:37 <StoneCypher> well, if you think rendering text into a vector image format makes sense, more power to you
23:49:38 <dmwit> For example, perhaps you want to include the result somewhere that allows images, e.g. a presentation tool or similar.
23:49:48 <dmwit> HTML is a vector image format.
23:49:53 <StoneCypher> it is no such thing
23:49:54 <dmwit> A crappy one, but definitely is one.
23:50:01 <StoneCypher> okay.  :|
23:50:13 <dmwit> My ctrl+scroll wheel says it is. =)
23:50:40 <StoneCypher> your ctrl+scroll wheel is deeply confused about the meanings of the words "vector" and "image"
23:50:45 <StoneCypher> i recommend you take advice elsewhere in the future
23:51:10 <dmwit> Convince me.
23:51:16 <dmwit> HTML sure doesn't seem raster-like to me.
23:51:26 <dmwit> And images are allowed to have text in them.
23:52:34 <StoneCypher> i don't really want to, to be honest.  there's a level at which if common sense doesn't kick in, there's nothing fun to discuss.
23:52:37 <dmwit> HTML lets me draw lines and curves, position text, adjust foreground and background colors, give things opacity, ...
23:53:17 <L8D> Twey: I'm stumped
23:53:29 <Twey> L8D: With what?
23:53:44 <L8D> I'm not sure how to setup word definitions
23:53:44 <dmwit> Common sense is often wrong. Facts are better.
23:53:55 <StoneCypher> cool story bro.
23:53:58 <shachaf> This doesn't seem like the right channel for this.
23:54:06 <Twey> L8D: You need to thread the dictionary through your functions
23:54:15 <L8D> Twey: I know
23:54:16 <StoneCypher> shachaf: kay.
23:54:36 <L8D> But I can't do that without creating a recursive type definition
23:54:40 <Twey> L8D: So every [Int] → IO [Int] becomes a (Dictionary, [Int]) → IO [Int]
23:54:47 <Twey> Er
23:54:52 <Twey> L8D: So every [Int] → IO [Int] becomes a (Dictionary, [Int]) → IO (Dictionary, [Int])
23:54:53 <L8D> type WordDict =[(String, (WordDict, [Item] -> IO [Item]))]
23:55:14 <Twey> L8D: That's fine; use a newtype to make the compiler accept your recursive type
23:55:17 <jfeltz> OT: I just bombed a quant finance job interview (was entirely programming problems), does doing practice problems/contest problems help? I didn't participate in them while doing my undergrad in CS (I was also a returning adult student (>30)), or should I just give up, as this is an age thing?
23:55:22 <L8D> Twey: oh
23:55:47 <Twey> L8D: But you probably want [(String, (WordDict, [Item]) -> IO [Item])]
23:56:08 <dmwit> You probably should not give up. You probably do not need to succeed at the programming problems to succeed at the interview. You probably can improve your performance on these tasks by practicing.
23:57:15 <StoneCypher> jfeltz: some practice problems help; others don't.  i find that the prolog 99 set is quite useful.
23:57:17 <L8D> Twey: how do I use the newtype?
23:58:03 <Twey> L8D: That's now your Dictionary
23:58:46 <Twey> L8D: You can unwrap it with pattern-matching (or use record syntax to define a getter) to get the equivalent to your original [(String, [Int] → IO [Int])] back
23:59:00 <Twey> Erm
23:59:18 <jfeltz> StoneCypher, thanks, I've not heard of those before, I've been told to do the euler problems (and I've done a few of them so far), I just don't know if that is the kind of developer that I am
23:59:25 <L8D> I'm using type Item = Int and type Stack = [Item] or Stack = (WordDict, [Item])
23:59:50 <Twey> L8D: Brief diversion into (concatenative) language design: you can have ‘late-binding’ functions, in which you use whatever names you want and they're looked up in the environment when the function is actually executed, or ‘early-binding’ functions, which can only access the names in scope when they're defined
23:59:55 <jfeltz> dmwit: understood, thanks
