00:00:08 <shachaf> (\x -> x x) has a rank-2 type, but it's probably not what you want.
00:00:24 <c_wraith> I'm happy with the extension's compromises - everything is assumed to be rank-1 unless you specify otherwise.
00:00:50 <shachaf> I'm happy except in some cases.
00:01:16 <c_wraith> are those cases interactions with further type system extensions?  Those can get hairy.
00:01:21 <Kaidelong> I can't find mention of the Rank-2 <-> Rank-N isomorphism except for a brief mention on the page of the Rank-N types proposal for GHC
00:01:44 <Kaidelong> which mentions that most of the real world cases are allowed by Rank-2 and the ones that are better done with Rank-N can in principle be done with Rank-2
00:01:57 <Kaidelong> I can't find mention of a paper that mentions a way to automatically translate from one to the other
00:02:04 <shachaf> OK, but they could mean something different there.
00:02:08 <Kaidelong> maybe there isn't a general way to do it in principle
00:02:22 <shachaf> Like wrapping rank-2 types in newtypes (which isn't allowed in Haskell 2010).
00:02:29 <Kaidelong> kind of like how even if N=NP there may be no general way to rewrite an NP algorithm to an N one
00:02:59 <c_wraith> ...  N?
00:03:03 <Kaidelong> P
00:03:05 <Kaidelong> bah
00:03:05 <c_wraith> :)
00:06:00 <shachaf> It's a shame that we can only get the pseudo-subtyping that lens does with rank-2 types.
00:09:15 <Kaidelong> isn't Rank-2 polymorphism what allows GHC to safely encapsulate IO in principle?
00:09:44 <shachaf> A hack is what allows GHC to safely encapsulate IO.
00:09:48 <Kaidelong> because information about the outside world that has to be passed around in impure code can be "lost" by using a rank-2 type
00:09:58 <shachaf> I'm not sure that there's any principle involved. Well. Probably some.
00:10:04 <shachaf> Maybe you're thinking of ST.
00:10:18 <Kaidelong> isn't IO internally a special case of ST?
00:10:39 * hackagebot ansi-terminal 0.6.1.1 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6.1.1 (RomanCheplyaka)
00:10:39 * hackagebot mime-mail 0.4.4 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.4 (MichaelSnoyman)
00:11:56 <Kaidelong> which has to be provided specifically to avoid exposing certain constructors
00:12:35 <Kaidelong> well I guess it's not about the constructors, the types themselves
00:13:10 <shachaf> IO is a newtype around the thing that ST is a newtype around except without doing the whole rank-2-type deal.
00:22:48 <Aetherspawn> Does local haddock documentation generate those gray module crosslinks
00:22:53 <Aetherspawn> I can't get it to generate no matter what I do..
00:25:06 <jle`> if `Maybe` is a functor, what is `Maybe a` ?
00:26:11 <sccrstud92> a concrete type?
00:26:20 <sccrstud92> that is polymorphic?
00:28:43 <jle`> can we relate it to the idea of a functor in any way
00:28:55 <jrmithdobbs> um wtf
00:29:04 <startling> jle`: "functorial action"
00:29:09 <jle`> startling: heh
00:29:31 <jle`> could we call `f a` a "producer of `a`" ?
00:29:44 <jle`> where `f` is the Functor
00:29:50 <jrmithdobbs> i was at a loss trying to get something typechecking in ghci and did :: Free (Type Text [Type Text undefined ()]) ()
00:29:54 <jrmithdobbs> and it worked
00:29:58 <jrmithdobbs> how
00:30:27 <startling> jle`, Proxy is a functor.
00:30:39 <scott> In a type, 'undefined' would just be a type variable
00:31:02 <startling> jle`: (data Proxy a = Proxy)
00:31:06 <jrmithdobbs> scott: on the righthand side of an expression that's still true?
00:31:13 <startling> jrmithdobbs: yes.
00:31:32 <jrmithdobbs> ok, i see how it worked then
00:31:38 <jle`> startling: from where? HTTP?
00:31:48 <startling> jle`: no, 'tagged'
00:32:25 <jle`> hm
00:32:33 <startling> (and it doesn't produce anything)
00:32:40 <jle`> so is there no meaningful name for `Functor f => f a` ?
00:32:59 <jle`> but i would consider Proxy a degenerate case.
00:33:15 <startling> is a list of Strings a "producer of strings"?
00:33:28 <jle`> it is under certain operations
00:33:42 <jle`> which vary depending on the specific functor
00:33:56 <kazagistar> ugh, I can't figure out how to unbreak everything cabal on my OSX, only place I can get it to work is on the school computers where it is preinstalled :/
00:34:23 <startling> kazagistar, rm -rf ~/.ghc should do it (but you will have to reinstall everything you cabal installed)
00:34:47 <jle`> producer is the only general enough word i have found to be able to describe the entire body of useful functors without too much shoehorning
00:35:17 <notdan> well the most descriptive name for this concept is 'functor'
00:35:25 <jrmithdobbs> kazagistar: brew unlink ghc haskell-platform; then rm -rf them from /usr/local/Cellar then rm -rf ~/.ghc, then brew install ghc haskell-platform, update cabal and use sandboxes ;p
00:35:50 <jle`> notdan: well
00:35:53 <jle`> functor describes f
00:35:55 <jle`> but not f a
00:35:59 <notdan> There were one or two discussions on reddit on functor analogies and it has been demonstrated that all analogies fail
00:36:04 <merijn> kazagistar: On OSX you will want to nuke ~/Library/Haskell/<ghc-version here>
00:36:05 <ReinH> jle`: reasoned argument for calling them "containers": http://bartoszmilewski.com/2014/01/14/functors-are-containers/
00:36:15 <notdan> `f a` = image of `a` under a functor `f`
00:36:20 <supki> jle`: I think producer/consumer metaphor is mostly useful when contrasting covariant and contravariant functors (in Haskell)
00:36:28 <supki> otherwise I don't see much point
00:36:40 <jle`> supki: just looking for a term for f a
00:36:40 <startling> merijn: oh?
00:37:01 <notdan> ReinH: this is a somewhat contravertial view http://www.reddit.com/r/haskell/comments/1v7dci/functors_are_containers/
00:37:06 <merijn> startling: On OSX everything gets put there for consistency with all other frameworks and the native environment
00:37:31 <notadog> can't get any form of a combobox to work properly. I can see the box when i run my app, but it doesn't have anything displayed in its cells.
00:37:36 <notadog> cb <- comboBoxNewText
00:37:37 <notadog>   comboBoxAppendText cb "Continuous"
00:37:38 <jrmithdobbs> merijn: brew's packaging fixes that.
00:37:39 <notadog>   comboBoxAppendText cb "Discontinuous"
00:37:41 <notadog>   comboBoxAppendText cb "Delayed"
00:37:43 <notadog>   comboBoxSetActive cb 0
00:37:57 <merijn> jrmithdobbs: You mean breaks that >.>
00:37:59 <jle`> i think it's as useful/valid to say that functors are containers as it is to say monads are containers
00:38:00 <startling> merijn: I'm on OS X and I don't even have that directory.
00:38:10 <kazagistar> … cannot satisfy -package-id mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62
00:38:14 <jle`> (as in not much...but that's just my opinion)
00:38:24 <jrmithdobbs> merijn: no, I don't. :)
00:38:36 <startling> oh, yeah, I installed with brew.
00:38:39 <merijn> startling: Maybe if you use homebrew/macports for installing platform, which is silly
00:38:50 <ReinH> jle`: you might want to actually read the thing I linked
00:38:53 <startling> merijn, I don't even use the platform.
00:39:14 <startling> but, uh, automatic upgrades are nice.
00:39:26 <kazagistar> I installed with brew, then uninstalled it when I couldnt get it to work, then installed with the installer, and it still fails
00:39:38 <ReinH> notdan: I didn't say it was correct, I said it was reasoned. :)
00:39:45 <jrmithdobbs> merijn: why is that silly? they ship checksummed binaries over https, better than upstream ...
00:40:07 <kazagistar> I have cleared all the caches, but I keep getting random errors that have something to do with clang according to google?
00:40:16 <startling> oh.
00:40:17 <tdammers> formally speaking, it's "I'm sorry, can't make it, but I'll send our countries finest instead"
00:40:18 <jle`> ReinH: thanks, I'll give it a read
00:40:29 <merijn> kazagistar: oh, you have 10.9?
00:40:40 <kazagistar> merijn: yep
00:40:45 <merijn> kazagistar: Have you looked at the link in the topic on 10.9 issues?
00:41:05 <ReinH> jle`: if you're looking for some word other than "functor" it provides at least a reasoned argument for choosing one in particular
00:41:14 <tdammers> sorry wrong channel
00:41:28 <merijn> kazagistar: 10.9 no longer has gcc, only clang and this broke GHC, there's a fix in the topic. GHC 7.8 fixes this and will be in the next platform to fix this issue
00:41:48 <merijn> jle`: Well, why do you need a word for "f a" anyway?
00:42:36 <ReinH> I just say "some f a where f is a functor" or "Functor f => f a" depending
00:42:38 * ReinH shrugs
00:43:12 <kazagistar> merijn: and 7.8 is officially in the bugfixing stages, right?
00:43:14 <merijn> I usually just abuse words and the fact that humans can infer things and call it a functor :p
00:43:28 <merijn> kazagistar: Yeah, 1st release candidate came out last week
00:43:40 <kazagistar> call it a functored?
00:45:36 <jle`> merijn: i was trying to say... if `r` is a Category, then `r a b` is a morphism from `a` to `b`.  If `f` is a Functor, then `f a` is .... ?
00:45:39 * hackagebot libjenkins 0.4.1.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.4.1.0 (MatveyAksenov)
00:46:04 <shachaf> If you say "Functor f => f a" then you're writing something very odd.
00:46:42 <shachaf> ("where f is a Functor" is much better. "=>" does not express your intent here.)
00:46:50 <merijn> jle`: morphism from Hask to Hask :)
00:47:08 <jle`> but it could just be that the Category typeclass admits a much more standard vocabulary for describing its 'projections'/concrete types than Functor does
00:47:14 <c_wraith> merijn: f is a morphism from hask to hask.  f a isn't a morphism at all.  It's just a type.
00:47:31 <shachaf> "f" is a morphism if you happen to decide that "morphism" means "functor"
00:47:32 <jle`> by the nature of its semantics
00:48:05 <ReinH> shachaf: er. We say `Functor f => f a' in type signatures all the time...
00:48:07 <shachaf> (Which is a perfectly reasonable thing to decide. But you have to know what a functor is first.)
00:48:25 <merijn> c_wraith: I'll abuse semantics as much as I damn well please! :p
00:48:27 <shachaf> ReinH: blah :: Functor f => f a is uninhabited. Even blah :: Functor f => f A for some type A is uninhabited.
00:49:26 <shachaf> Even if f isn't free, something strange is going on here. If you give me "blah :: Functor F => F A", you're asking *me* to give you a Functor instance. Even though you picked F.
00:50:06 <shachaf> What you mean is probably a bit closer to "Functor f *> f a", using ski's notation. But I think the English is the simplest.
00:50:25 * ReinH sighs
00:51:09 <jle`> i guess the only thing meaningful to say is that Category is a typeclass that implements (.) and id, following certain laws.  BUT unlike other typeclasses, there is a standard vocabulary to describe concrete types cat a b, "morphism".  But this vocabulary cannot be expected to be found in general for other typeclasses.
00:51:21 <shachaf> With the implication "oh, such a nitpicker"?
00:51:53 <jle`> s/this vocabulary/the existence of such a vocabulary
00:53:44 <shachaf> i should not assume bad faith
00:54:38 <ReinH> shachaf: it's just tedious having you always choose the least generous interpretation of everything I say
00:54:58 <ReinH> what I actually meant was "when I want to specify that some f a is a functor in a type signature"
00:55:10 <dncr> Is it true that the only way to go from someNumberOfSeconds to "2012-06-30 23:59:60 UTC" (the last leap second) with the "time" library is by supplying the correct tai-utc.dat file to parseTAIUTCDATFile in Data.Time.Clock.TAI?
00:55:36 <ReinH> shachaf: in many cases I appreciate the correction
00:56:39 <dncr> I expected the library to know about the official leap seconds up to the time of the release of that version of the library.
00:57:15 <ReinH> what was that tautology about communication?
00:58:07 <kazagistar> even after running the 10.9 patch I keep getting an error when I try to install regex.compat.tdfa
00:58:14 <shachaf> I'm not sure what the difference is between that and what I thought you meant.
00:58:38 <ReinH> :t fmap
00:58:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:58:45 <ReinH> That.
00:59:29 <shachaf> I don't think I chose the least generous interpretation of what you said. But that's probably off-topic for this channel. I would discuss it in another place if you wanted.
01:00:21 <kazagistar> I give up, I guess I will just wait for 10.9 and make due until then :/
01:00:27 <kazagistar> er, I mean 7.8
01:01:06 <shachaf> I'm not sure what that is. Other than the type of fmap.
01:01:30 <ReinH> Ok. Never mind.
01:02:48 <notadog> Anyone have experience with combo boxes in gtk? I can't for the life of me seem to get one going. It displays, but doesn't render the actual strings. http://lpaste.net/99500
01:04:31 <shachaf> OK. I don't think this issue is a very big issue. But I don't want people to think that I choose the least generous interpretation of everything. (I might almost say that that seems like the least generous interpretation of what I say, but...)
01:06:00 <shachaf> So if you think that's true and that it's something that you can say anything about, I'll be happy to listen (but it really doesn't belong in this channel by now).
01:10:47 * hackagebot yesod-dsl 0.1.1.10 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.10 (TeroLaitinen)
01:15:47 * hackagebot pipes-text 0.0.0.1 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.1 (MichaelThompson)
01:24:08 <tero-> when trying to install mmorph-1.0.1 with ghc 7.4.1 "Could not find module `Control.Applicative.Backwards'"
01:25:16 <shachaf> That's from transformers.
01:25:23 <shachaf> Maybe there's a transfomers version issue.
01:26:52 <tero-> I installed transformers package manually and now it seems to work. Initially I tried to install yesod-platform
01:27:23 <Kaidelong> maybe you should run cabal update?
01:27:34 <Kaidelong> I made windows schedule it for 2:29 PM every day
01:28:33 <tero-> I did a cleanup "rm -rf .ghc .cabal && cabal update" before installing anything
01:29:15 <adnam> tero-: you don't need to remove .cabal
01:29:36 <tero-> adnam: ok. I'm a bit paranoid :)
01:30:21 <adnam> tero-: at least leave .cabal/bin so you have a recent cabal :-)
01:30:49 * hackagebot setenv 0.1.1.1 - A cross-platform library for setting environment variables  http://hackage.haskell.org/package/setenv-0.1.1.1 (SimonHengel)
01:35:49 * hackagebot stateWriter 0.2.1 - A faster variant of the RWS monad transformers.  http://hackage.haskell.org/package/stateWriter-0.2.1 (SimonMarechal)
01:37:52 <developerNew> Hi. Does anyone know if there is a vim plugin for haskell, that would recompile (and output errors if any) on file save?
01:39:19 <tsou> developerNew: i use :make for something like that
01:39:38 <tsou> developerNew: it seems like an overkill to force it on every file save, btw..
01:40:04 <developerNew> tsou: SublimeHaskell has such a feature, and it  works pretty well (no overkill)
01:40:28 <developerNew> tsou: executing :make everytime is more work than just a save
01:40:50 * hackagebot pipes-text 0.0.0.2 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.2 (MichaelThompson)
01:42:03 <tsou> developerNew: it should be trivial to add a something like that, probably with :autocmd
01:43:00 <tsou> developerNew: what i meant by overkill, is that for example say that I've edited just a comment, I don't want to have to recompile my software after that
01:43:42 <Twey> developerNew: If you use ghc-mod it will recompile on the fly without requiring you to even save :þ
01:45:50 * hackagebot pipes-text 0.0.0.3 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.3 (MichaelThompson)
01:46:50 <developerNew> Twey: For some reason it doesn't do that for me. Is there some specific that I have to do?
01:47:55 <codygman> I have a type error I can't seem to figure out: http://lpaste.net/99502
01:48:14 <developerNew> Twey: Although it seems to work if I do Esc -> :w
01:55:54 * hackagebot pipes-text 0.0.0.4 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.4 (MichaelThompson)
01:58:13 <supki> developerNew: hdevtools does that
01:58:27 <supki> it requires some work if you use cabal sandboxes but overall it's pretty nice
01:59:08 <Twey> codygman: Just as it says: you've said you'll return an IO (Either String FilePath) but you've actually returned an Either String (IO FilePath)
01:59:26 <developerNew> supki: is there a guide how to set that up with cabal sandboxes?
01:59:35 <Twey> codygman: You probably wanted: return $ Right tmpDir, and likewise return . Left $ …
01:59:53 <Twey> (or you could just do return $ case …)
02:00:13 <Aetherspawn> :t fix
02:00:14 <lambdabot> (a -> a) -> a
02:00:19 <Twey> (and Right tmpDir)
02:00:37 <Aetherspawn> is fix safe
02:00:42 <Aetherspawn> ie, not like replicateM
02:00:44 <merijn> Aetherspawn: Define "safe"
02:00:53 <Aetherspawn> replicateM destroys the stack
02:00:57 <Aetherspawn> does fix stream properly
02:01:05 <Twey> Erm
02:01:13 <supki> developerNew: I've never seen one
02:01:21 <merijn> Aetherspawn: Well, any non-streaming result for fix will infinite loop, rather than crash the stack :p
02:01:38 <supki> developerNew: personally I use some awful vimscript to automatically find sandboxes
02:01:41 <Aetherspawn> heh
02:01:47 <merijn> > fix (1:) -- streaming!
02:01:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:02:19 <Twey> Aetherspawn: replicateM doesn't necessarily destroy the stack; it just keeps track of a list of n things if you run n actions (as it has to, given its semantics)
02:02:32 <Twey> If that's too big for your stack, maybe you should be keeping track of fewer things :þ
02:02:37 <merijn> Aetherspawn: Basically, fix will only do something sensible if it's argument function returns a partial result immediately (i.e. "(1:)" immediately returns the head of the list)
02:03:15 <merijn> Aetherspawn: If your function *doesn't* return a partial result immediately, fix can't return anything at all
02:03:19 <merijn> > fix (.)
02:03:20 <lambdabot>  Occurs check: cannot construct the infinite type: b0 = a0 -> b0
02:03:20 <lambdabot>  Expected type: (b0 -> c0) -> b0 -> c0
02:03:21 <lambdabot>    Actual type: (b0 -> c0) -> (a0 -> b0) -> a0 -> c0
02:03:26 <merijn> aww, that doesn't work :(
02:03:28 <Twey> > fix id
02:03:32 <lambdabot>  mueval-core: Time limit exceeded
02:03:36 <merijn> Right, that's a better example
02:03:45 <Twey> > fix show
02:03:47 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
02:04:01 <ij> So it basically recurses?
02:04:04 <Aetherspawn> okay, so it's my responsibility then
02:04:09 <Twey> ij: Right, it's a recursion operator
02:04:24 <ij> Oh... I thought it does some magic because of "fix".
02:04:31 <Aetherspawn> huh
02:04:32 <Aetherspawn> fix not in scope
02:04:35 <Twey> Aetherspawn: But fix and replicateM aren't similar at all
02:04:39 <codygman> Twey: Thanks, I have it compiling now. Would you (or anyone else) write this any differently: http://lpaste.net/99506
02:04:40 <Twey> It's in Data.Function
02:04:45 <merijn> Aetherspawn: I don't think fix is in Prelude
02:05:24 <merijn> ij: In fact, if you look at (for example) TaPL, fix is *the* primitive operation for adding support for general (i.e. "infinite") recursion to a language
02:05:55 * hackagebot asynchronous-exceptions 1.0 - Distinguish between synchronous and asynchronous exceptions  http://hackage.haskell.org/package/asynchronous-exceptions-1.0 (RomanCheplyaka)
02:06:00 <fhjohn32> let M(S) be a free monoid generated by a one element set S.  What is the underlying set of M(S)? Is it just {1} or is it the infinite set {{},1,1*1,1*1*,1*1*1,...}?
02:06:10 <Twey> codygman: Seems reasonable to me
02:06:19 <Twey> Not sure why you return tmpDir
02:06:37 <Twey> (the user already knows what tmpDir is: they passed it in!)
02:06:47 <codygman> Twey: I'm going to be using it in a web application and getting the images generated.
02:08:29 <Twey> codygman: Okay, but you could use Either String () or use IO () and throw an exception on failure and the caller would have exactly the same information
02:08:42 <Aetherspawn> is there soemthing more concise than
02:08:48 <Aetherspawn> either (const f) (const g)
02:10:06 <Twey> codygman: Also, returning a String in the event of a failure is a bit of an antipattern: it would be better to return the useful value (say, the exit code) and let presenting the error to the user happen further up the callstack with the rest of the user interaction
02:10:31 <Twey> codygman: Which suggests a nicer return value: IO ExitCode
02:10:49 <Twey> And then you can just say ‘return exit’
02:11:24 <Twey> s/value:/type:/
02:11:24 <supki> :t either `on` const
02:11:25 <lambdabot> c -> c -> Either a a -> c
02:11:33 <Twey> :t on either const
02:11:33 <lambdabot> c -> c -> Either a a -> c
02:12:03 <supki> so cute
02:12:06 <fhjohn32> Please help if you can, I've went through a pile of textbooks and google and it seems nobody cares to mention if the underlying set contains only the generator element or all combinations of it. Maybe it's too obvious to some...
02:12:15 <Twey> I love ‘on’
02:12:20 <Aetherspawn> aww
02:12:31 <Aetherspawn> it causes the type to become very restricted
02:12:34 <Twey> But it's unfortunately named, because it makes people want to write it infix for no reason :þ
02:12:54 <Aetherspawn> it's not quite the same as either (const f) (const g)
02:13:01 <Twey> Yeah
02:13:16 <Aetherspawn> which is unfourtunate because nobody has Either with the same two types
02:13:16 <Aetherspawn> :P
02:13:32 <Twey> It happens!
02:13:36 <startling> it does.
02:14:08 <startling> :t liftA2 either
02:14:09 <lambdabot> Applicative f => f (a -> c) -> f (b -> c) -> f (Either a b -> c)
02:15:06 <quicksilver> fhjohn32: the underlying set is all the elements.
02:15:21 <quicksilver> fhjohn32: the 'generating set' is just the generators
02:15:36 <fhjohn32> quicksilver: thanks!
02:15:39 <quicksilver> the endofunctor T :: generators -> underlying sets is a monad
02:15:56 * hackagebot pipes-text 0.0.0.5 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.5 (MichaelThompson)
02:15:57 <quicksilver> classic example of a monad
02:16:17 <quicksilver> "make free construction" and "return to underlying set" are adjoints
02:20:50 <fhjohn32> quicksilver: so the bijection between homsets should've informed me that both sides have the same number of elements. great
02:23:47 <merijn> fhjohn32: That sounds like the pigeon hole principle, so yes
02:24:50 <the_berserker> @pl (f :: a -> b) >>= g
02:24:50 <lambdabot> (line 1, column 11):
02:24:50 <lambdabot> unexpected '>'
02:24:50 <lambdabot> expecting operator
02:25:16 <the_berserker> @pl f >>= g
02:25:16 <lambdabot> g =<< f
02:26:27 <the_berserker> @pl let map f l@(x:xs) = if l == [] then [] else f x : map f xs
02:26:27 <lambdabot> (line 1, column 12):
02:26:28 <lambdabot> unexpected "@"
02:26:28 <lambdabot> expecting pattern or "="
02:27:02 <Twey> the_berserker: f x : map f xs
02:27:27 <Twey> The test never succeeds by virtue of the pattern construction: if it were empty it wouldn't have matched this clause
02:27:31 <the_berserker> @pl let map f l = if l == [] then [] else f (head l) : map f (tail l)
02:27:31 <lambdabot> (line 1, column 66):
02:27:32 <lambdabot> unexpected end of input
02:27:32 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
02:28:18 <the_berserker> @pl let map f l = if l == [] then [] else f (head l) : map f (tail l) in map
02:28:18 <lambdabot> fix ((ap (flip if' [] . ([] ==)) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
02:29:08 <the_berserker> > (fix ((ap (flip if' [] . ([] ==)) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))) (+1) [0..]
02:29:09 <lambdabot>  Not in scope: if'
02:29:09 <lambdabot>  Perhaps you meant f' (imported from Debug.SimpleReflect)
02:30:21 <merijn> the_berserker: What, exactly, are you trying to accomplish?
02:30:32 <the_berserker> @help
02:30:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:30:48 <the_berserker> @help type
02:30:48 <lambdabot> type <expr>. Return the type of a value
02:30:57 <merijn> the_berserker: Also, note that you can private message lambdabot using
02:31:33 <the_berserker> @type let if' True a _ = a; if' False _ b = b in fix ((ap (flip if' [] . ([] ==)) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
02:31:34 <lambdabot> Eq a1 => (a1 -> a) -> [a1] -> [a]
02:32:26 <the_berserker> > let ($) x = x in (2 $)
02:32:27 <lambdabot>  2
02:32:43 <Aetherspawn> pfft
02:33:03 <Aetherspawn> who do I murder for not putting isLeft/isRight in Data.Either
02:33:05 <Aetherspawn> honestly.
02:34:41 <merijn> Aetherspawn: No one, but you should go stand in a corner and feel ashamed for wanting those
02:35:23 <Aetherspawn> is it too much to ask to not need to pull out a pattern guard when I could do it easily with a regular guard
02:35:27 <Aetherspawn> >.>
02:35:46 <merijn> Aetherspawn: Or you could just use a pattern match/case?
02:36:04 <startling> > has _Left <$> [Left 1, Right 2]
02:36:07 <lambdabot>  [True,False]
02:36:16 <Aetherspawn> I'm trying to make it fit sanely in a rewrite rule...
02:36:17 <Aetherspawn> <.<
02:36:52 <Aetherspawn> I have to fuse this into for cat $ \... form
02:36:52 <Aetherspawn> https://github.com/kvanberendonck/pipes-courier/blob/master/src/Pipes/Courier.hs#L51
02:36:58 <Aetherspawn> otherwise it doesn't get pipes fusion
02:37:20 <Aetherspawn> its really proving to be hard to do without duplicating work
02:37:54 <phyre> > let one = 1 in one
02:37:55 <lambdabot>  1
02:39:39 <the_berserker> What is the `(->) a` monad?
02:40:51 <Aetherspawn> Reader
02:41:26 <merijn> Anyone that has suggestions for doing this in a better way? http://lpaste.net/99507
02:45:08 <ivanm> with sandboxes, "cabal build" brings in dependencies used with add-source that have changed... is it possible to do so without actually compiling the current package?
02:45:36 <ivanm> (as that means "cabal repl" will load the compiled modules rather than the source, so I can't access the internals of the module)
02:46:54 <Feuerbach> ivanm: cabal install --only-dep
02:46:55 <mm_freak> when will OpenGL 2.9 be in the haskell platform?  are there any plans?
02:47:13 <mm_freak> because when i write an OpenGL 2.9 application many people will have trouble compiling it
02:47:15 <Feuerbach> ivanm: although there should be a better way to solve your ghci problem
02:47:29 <mm_freak> (i want to use compute and geometry shaders)
02:47:49 <Aetherspawn> merijn: here's where your suggestion got me
02:47:50 <Aetherspawn> https://gist.github.com/kvanberendonck/8821004
02:47:51 <Aetherspawn> :C
02:50:25 <ivanm> Feuerbach: huh, I had issues last time I tried to do --only-dep multiple times... might have been a one-off
02:50:56 <Twey> merijn: load "test" >>= (<$> getResourceBody) . fmap . (++) . itemBody — is this ‘better’?
02:51:00 * hackagebot asynchronous-exceptions 1.1 - Distinguish between synchronous and asynchronous exceptions  http://hackage.haskell.org/package/asynchronous-exceptions-1.1 (RomanCheplyaka)
02:51:23 <Twey> Ooh
02:51:58 <merijn> Twey: Not a lot, I had high hopes for "liftA2 (++) <$> load "test" <*> getResourceBody" until I realised Item doesn't have an Applicative instance :(
02:53:00 <Twey> It doesn't?
02:53:18 <Twey> Hm
02:53:19 <merijn> Twey: Nope, and it can't have a law abiding one
02:53:36 <Twey> You can still: fmap . (++) . itemBody <$> load "test" <*> getResourceBody
02:53:41 <merijn> Twey: Since (this is hakyll, btw) Item has the underlying file info, which is not a monoid
02:59:39 <phyre> I feel like I'm cheating when using Haskell to go through these project euler problems.
02:59:51 <Feuerbach> ivanm: be sure to file issues for all the problems you run into. Mikhail does a pretty good job handling them
03:00:39 <ivanm> *nod*
03:01:18 <ivanm> IIUC, this is an issue more because the sandbox brings the dist/ directory into scope
03:16:48 <Aetherspawn> my haskell programs always run into IO issues when I run them in terminal
03:17:15 <Aetherspawn> after 10,000 socket reads or whatever, Prelude.print stops working and the terminal becomes dead
03:20:39 <mm_freak> ocharles: i don't know if you will laugh or cry, but just for experimentation with my little toy game i have reduced Wire to the following:  Wire a b = Double -> a -> (Maybe b, Wire a b)
03:20:56 <mm_freak> so far i didn't miss the extra features
03:21:29 <mm_freak> if this turns out to be sufficient, i will make a new AFRP library based on this
03:21:47 <mm_freak> to be honest, i actually like it =)
03:22:04 <startling> what's the Double?
03:22:08 <mm_freak> time delta
03:22:09 <bartavelle> time ?
03:22:23 <startling> mm_freak: ah
03:23:20 <mm_freak> it makes so many things so much simpler…  and i'm getting a huge speed boost as well
03:23:40 <mm_freak> i'm back to 100M-200M FPS =)
03:23:49 <mm_freak> (not in the game, just raw wire computation)
03:25:23 <mm_freak> btw, another part of this little toy game is a functional shader language that compiles to OpenGL GLSL =)
03:25:36 <mm_freak> inspired by the accelerate library
03:26:13 <mm_freak> if all this works well, you can expect three new libraries that will make the life of game developers a lot easier =)
03:26:22 * hackagebot asynchronous-exceptions 1.1.0.1 - Distinguish between synchronous and asynchronous exceptions  http://hackage.haskell.org/package/asynchronous-exceptions-1.1.0.1 (RomanCheplyaka)
03:26:24 * hackagebot hruby 0.2.3 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.3 (SimonMarechal)
03:27:19 <bartavelle> hum the lens build issue is annoying
03:28:42 <ocharles> mm_freak: cute!
03:29:00 <ocharles> mm_freak: so it's really just partial automaton
03:29:23 <mm_freak> yeah
03:29:29 <mm_freak> + time
03:29:33 <ocharles> I think LambdaCube is also about compiling FRP to GLSL
03:29:39 <ocharles> How are you passing time around?
03:29:44 <ocharles> oh, double
03:30:16 <mm_freak> well, i believe that LambdaCube doesn't give me control over the rendering pipeline
03:30:19 <ocharles> I can't say I've ever needed 'm' or 'e', so it makes sense to me!
03:30:29 <ocharles> no, but LambdaCube isn't about rendering anymore, iirc.
03:30:33 <ocharles> More general purpose computing
03:30:37 <mm_freak> ah
03:30:45 <ocharles> I could be totally wrong there, but I think they aren't trying to be Ogre-for-Haskell
03:30:47 <mm_freak> interesting…  i will look into it
03:31:11 <mm_freak> i'm not either…  ogre is OO, and i'm FRP =)
03:31:16 <ocharles> :)
03:31:50 <mm_freak> ocharles: also i've made the separation between frameworks and applications a lot clearer
03:32:16 <ocharles> by simplifying Wire?
03:32:35 <mm_freak> no, by writing helper functions for framework developers
03:32:49 <mm_freak> the library itself deals with calling pollEvent, for example
03:32:59 <mm_freak> you just tell it how to poll for the next event
03:33:04 <ocharles> ah
03:33:08 <ocharles> Got anything I can see?
03:33:29 <mm_freak> i can upload the current state
03:33:57 <ocharles> sure, just a tarball would be fine
03:34:09 <mm_freak> i'll put it on hub
03:36:28 * hackagebot syntactic 1.11 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.11 (EmilAxelsson)
03:36:30 * hackagebot filecache 0.2.5 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.5 (SimonMarechal)
03:37:01 <mm_freak> ocharles: be patient…  i'll make a few adjustments before uploading
03:38:24 <ocharles> mm_freak: no rush, I have a job I should probably be doing :)
03:50:54 <quchen> Just read this on the mailing list: "If I understand correctly, NoMonomorphismRestriction is now the default for GHC 7.8." -- That's not right, is it? The changelog only talks about GHCi having it disabled.
03:59:27 <merijn> quchen: Seems unlikely
03:59:34 <merijn> quchen: That would be incompatible with the report
04:00:14 <ocharles> not only that, I don't have a 500 post thread on the ML about it
04:00:23 <quchen> That makes sense. (As much sense as the monomorphism restriction does, anyway.)
04:00:58 <quchen> I'm always ε away of just compiling GHC with certain extensions enabled by default.
04:04:26 <merijn> Anyone here know of a good explanation of the Hakyll internals? I'm just reading the source now to figure out what I want, but I was wondering if someone already did that hard work for me :p
04:09:27 <lasfakj> what does the function fix does?
04:09:30 <lasfakj> :t fix
04:09:31 <lambdabot> (a -> a) -> a
04:09:39 <ion> @src fix
04:09:39 <lambdabot> fix f = let x = f x in x
04:09:51 <ion> > let x = "hello" : x in x
04:09:52 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
04:09:57 <ion> > fix (\x -> "hello" : x)
04:09:57 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
04:11:32 <lasfakj> let x = fix id 1
04:12:46 <dv-> > let fac = fix (\f n -> if n == 1 then 1 else n * f (n - 1)) in fac 7
04:12:47 <lambdabot>  5040
04:13:00 <lasfakj> > let x = fix id 1
04:13:00 <lambdabot>  not an expression: `let x = fix id 1'
04:13:13 <lasfakj> > fix id 1
04:13:16 <dv-> fix allows you to make anonymous recursive functions
04:13:16 <lambdabot>  mueval-core: Time limit exceeded
04:14:38 <merijn> lasfakj: Do you understand the following example?
04:14:44 <merijn> > let ones = 1 : ones in ones
04:14:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:15:02 <johnw> sccrstud92: pong
04:15:18 <quchen> lasfakj: fix is also known as the "fixed point" or "y" combinator.
04:15:57 <lasfakj> I dont get it. sorry..
04:15:58 <quchen> You don't really need it very often in Haskell, but it's important for theoretical reasons.
04:16:15 <johnw> I find it most handy for writing recursive anonymous lambdas
04:16:22 <quchen> fix $ \loop -> ...?
04:16:25 <johnw> exactly
04:16:25 <mada> say I found a trivial bug in trac with a proposed solution and all, how would I go about contributing a patch?
04:16:33 <johnw> especially as a statement in a Monad, can be quite handy
04:16:37 <lasfakj> i was looking for 'on' and came across this..
04:16:50 <quchen> johnw: Yeah that's pretty much all the use cases I can think of
04:17:40 <merijn> mada: Clone GHC head, fix bug, test patch, use "git diff" to produce a patch file, attach patch to Trac bug report and mark as "patch"
04:17:53 <lasfakj> you guys gave enough examples.. im gonna read them after taking a walk.. its for some reason going over my head
04:18:10 <quchen> fix is tricky in the beginning.
04:18:31 <quchen> Especially when you're using Haskell to learn about it (instead of a book about lambda calculus, for example) ;-)
04:18:46 <johnw> lasfakj: fix is a function such that fix f = f (fix f).  In math it's expressed as f x = x, where our 'x' in this case is "fix f"
04:18:48 <merijn> mada: If you need GHC dev help, you can also join #ghc and ask there for how to get things accepted and feedback on your patch
04:18:59 <mada> alright, thank you merijn
04:26:00 <Aetherspawn> fix is awesome
04:26:12 <quchen> :t fmap fix return
04:26:13 <lambdabot> a -> a
04:26:15 <Aetherspawn> first time ever it fix(ed) (dudum-tss) a problem for me today
04:26:16 <quchen> > fix error
04:26:17 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
04:26:24 <Rembane> :D
04:26:31 <quchen> Hope that was convincing!
04:29:19 <johanneslippmann> Hi there
04:29:51 <johanneslippmann> I want to change the show function of Data.Vector.
04:30:01 <johanneslippmann> I think the existing one is ugly.
04:30:16 <johanneslippmann> can I do this?
04:30:21 <quchen> No.
04:30:27 <ocharles> johanneslippmann: then you would make a newtype, and then define a new Show instance for that
04:30:43 <hpc> or write a different function that displays it how you want
04:30:54 <quchen> Show isn't for displaying things nicely, it's for ad-hoc serialization. Prettyprinting is *not* the purpose of Show.
04:31:08 <quchen> Similarly, Read is not a parser, it's an un-serializer.
04:31:28 <hamid> hpc, that kinda feels wrong way coming from a c++ background. but feelings doesn't matter!
04:31:41 <johanneslippmann> So what has the purpose of prettyprinting?
04:31:57 <ocharles> pretty-show
04:32:12 <ocharles> @hackage pretty-show
04:32:12 <lambdabot> http://hackage.haskell.org/package/pretty-show
04:32:45 <mornfall> quchen: considering the existence of showPrec, you aren't entirely correct on this
04:32:48 <ocharles> 'ppShow' is what you want
04:33:19 <johanneslippmann> I see. Thank you guys ;)
04:33:26 <merijn> mornfall: I don't see how showPrec affects his point?
04:33:28 <johanneslippmann> And girls ;)
04:33:40 <quchen> I'm sufficiently correct in order to suggest not using Show as a prettyprinter to a beginner at least.
04:33:41 <mornfall> merijn: it's useless for serialisation
04:34:00 <hamid> erlangen
04:34:09 <merijn> mornfall: How so?
04:34:15 <Elision> @pl \x -> \y -> \s -> (s !! x) !! y
04:34:15 <lambdabot> flip . ((!!) .) . flip (!!)
04:34:28 * quchen uses Show as a "GHC, do give me this thing as String, sacrifice a virgin unicorn if you have to".
04:34:34 <Elision> pfffft
04:34:37 <merijn> (also, show isn't for serialisation either, it's for debug printing)
04:34:57 <mornfall> merijn: you can always kill showprec by inserting enough parens
04:35:20 <quchen> merijn: Hence me saying "ad-hoc serialization" :-)
04:39:53 <merijn> mornfall: Which hampers readability when debugging
04:42:49 <xintron> For parsing ascii data there's no point in using Data.Text over Data.ByteString?
04:44:00 <quchen> ASCII is always 7-bit, which fits into a BS.
04:44:49 <quchen> Not sure how the APIs compare to do this though.
04:44:53 <quchen> Also, don't use ASCII.
04:45:08 <quchen> :-(
04:45:33 <merijn> quchen: You have to for some protocols
04:45:34 <Aetherspawn> xintron: correct
04:45:44 <merijn> Which incidentally is the only acceptable use for ASCII :p
04:46:01 <xintron> merijn, and is exactly the situation I'm in :)
04:46:07 <quchen> merijn: Yes, in that case … stop spoiling my hate though!
04:46:16 <quchen> xintron: Oh, okay
04:46:19 <merijn> xintron: Right, if you're doing something like network protocols ByteString is fine
04:46:52 <madjestic> http://lpaste.net/99509  I am trying to use typeclass instances here in order to be able to call, roughly ~ 'draw Triangle' and 'draw Red Triangle', however compiler does not like it.  Anything obvious I may be missing here?
04:46:59 <merijn> xintron: You can also use the OverloadedStrings extensions which converts String literals to ByteString for that (in all other situations it's evil as it just drops non-ASCII characters, be warned!)
04:47:32 <merijn> madjestic: You may want to read:
04:47:38 <merijn> @where existential-antipattern
04:47:38 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
04:47:59 <merijn> madjestic: In other words, you probably don't want to use typeclasses for this
04:48:29 <ij> How can I add some package to my local hoogle db?
04:48:53 <ij> I'm looking at hxt currently, in particular.
04:55:37 <tomejaguar> A cabal file can have multiple 'executable' entries, and each has its own dependencies.  Is there a way to set the dependencies for all the 'executable' entries once and for all?
04:56:39 <ocharles> tomejaguar: I don't think so
04:57:12 <tomejaguar> That's a shame.  It's annoying to have to bump everything at once.
05:00:44 <ocharles> yea
05:00:57 <ocharles> I get to report lots of test-suite failures because those dependencies fall out of date
05:01:02 <madjestic> merijn: thanks.  My intention is to make interface to my library flexible, enough to allow user to ommit some arguments, e.g. color, letting the program to choose a default argument value in such case.  I am looking at your link, but it is not obvious how that is related.
05:02:37 <madjestic> merijn: if you think that it is, I will dig deeper
05:02:44 <merijn> madjestic: Do the ommitted arguments have sensible defaults?
05:03:02 <merijn> madjestic: Because then there's another common alternative
05:03:18 <madjestic> merijn: yes.  E.g. a color would default to black.
05:03:42 <merijn> madjestic: It's very common to define a record for configuration parameters, like "data MyConfig = Config { colour :: Colour, shape :: Shape }" etc.
05:04:11 <merijn> madjestic: Then you would define "defaultConfig = Config { colour = Red, shape = Triangle }" users can then simply use record update syntax
05:04:42 <merijn> madjestic: i.e. "someFunction defaultConfig{ shape = Square }", this will make a copy of defaultConfig with "shape" set to "Square"
05:04:55 <merijn> madjestic: (and then call someFunction on the new config)
05:05:16 <merijn> Where "someFunction :: MyConfig -> Whatever"
05:06:04 <madjestic> merijn: thanks.  Looks like there's a number of options I could use
05:06:21 <merijn> madjestic: So as long as your defaultConfig sets sensible default field values users then only have to override the fields they want to
05:08:32 <madjestic> merijn: typeclass approach that I posted above seems to work in some cases (I was experimenting with Integers and Strings, various number of arguments for instances), but not for this particular case.  Somehow compiler can't choose a propper instance.  Oh well, I guess I will drop flexible interfaces for now and just stick to readability, till I level up my haskell-foo skill
05:09:12 <merijn> madjestic: Typeclasses solutions like this tend to be rather fragile, the record approach is usually much easier to implement and more robust
05:13:55 <tomejaguar> You can also just use Maybe.
05:19:46 <madjestic> thanks everybody
05:19:56 <merijn> tomejaguar: Then users have to always specify a value for every argument, though
05:25:00 <madjestic> another little moster that keeps biting me: http://lpaste.net/99511  There must be a standard way to coerce types in a situation like this, isn't it?  What it makes further confusing is that GLclampf is a type synonim for Float type, defined inside OpenGL library - so what a heck? :)  why GHC can't just figure it out? (tag: boob :( )
05:25:24 <madjestic> *noob
05:27:14 <supki> there are no implicit coercions in haskell
05:27:14 <mm_freak_> madjestic: GLclampf = CFloat
05:27:22 <mm_freak_> madjestic: and CFloat is a Real
05:27:29 <mm_freak_> madjestic: and Float is a Fractional
05:27:34 <mm_freak_> :t realToFrac
05:27:35 <lambdabot> (Fractional b, Real a) => a -> b
05:28:43 <supki> and I wouldn't trust links that contain "Hugs"
05:28:59 <mm_freak_> and boob tags
05:29:13 <madjestic> hehe
05:29:41 <mm_freak_> madjestic: when calculating an OpenGL scene i nowadays keep my code polymorphic in the component types
05:30:00 <mm_freak_> data Scene a = Scene { camPos :: V3 a }
05:30:31 <mm_freak_> madjestic: then when rendering i set a = GLfloat
05:30:56 <madjestic> mm_freak_: that's a good tip, thanks
05:31:07 <mm_freak_> that helps not to pollute my non-rendering code with GL types
05:33:24 <lasfakj> https://twitter.com/EvilHaskellTips/status/429785828655505408 what does he mean?
05:33:56 <lasfakj> we should not use head, read, fromJust normally?
05:33:57 <Maior> lasfakj: those three functions aren't total
05:33:58 <mm_freak_> lasfakj: it's an evil haskell tip =)
05:34:23 <mm_freak_> lasfakj: those functions can crash your program
05:34:43 <mm_freak_> > fromJust Nothing
05:34:44 <lambdabot>  *Exception: Maybe.fromJust: Nothing
05:34:55 <Maior> > head []
05:34:57 <lambdabot>  *Exception: Prelude.head: empty list
05:35:13 <lasfakj> oh i understand what he means now
05:35:59 <mm_freak_> lasfakj: 'head' is a particularly bad example, because using it often implies that you're using the wrong type to solve a problem
05:36:17 <madjestic> read "a" :: Int
05:36:49 <lasfakj> mm_freak_: explain?
05:36:54 <mm_freak_> and 'head' usually comes with her companion, mr. evil boolean blindness =)
05:37:22 <quchen_> if isTrue x then True else False
05:37:25 <mm_freak_> lasfakj: when you call 'head' you're making assumptions
05:37:43 <madjestic> > read "a" :: Int
05:37:44 <lambdabot>  *Exception: Prelude.read: no parse
05:38:53 <lasfakj> when you say you're probably using the wrong type to solve a problem, what does it mean..
05:39:32 <mm_freak_> lasfakj: problems can be defined in terms of non-empty lists or streams
05:39:43 <mm_freak_> if you allow a list type to be empty, then 'head' is dangerous
05:41:44 <mm_freak_> lasfakj: example: you have an infinite sequence of increasing numbers
05:41:52 <mm_freak_> > iterate (\x -> x^2 + 1) 0
05:41:54 <lambdabot>  [0,1,2,5,26,677,458330,210066388901,44127887745906175987802,1947270476915296...
05:42:09 <mm_freak_> you want to find the first number that is greater than 100
05:42:26 <mm_freak_> > dropWhile (<= 100) . iterate (\x -> x^2 + 1) $ 0
05:42:27 <lambdabot>  [677,458330,210066388901,44127887745906175987802,194727047691529644955970344...
05:42:51 <mm_freak_> so far so good, but this is still a list
05:43:03 <mm_freak_> /you/ know that it is infinite, so /you/ know that it's safe to call 'head'
05:43:08 <mm_freak_> but the compiler doesn't
05:43:12 <fantasticsid> http://lpaste.net/99512
05:44:07 <fantasticsid> I was reading Simon Marlow's <<parallel and concurrent programming in Haskell>>, and this example I wasn't sure if it's possible there's a possibility of deadlock, anyone can help have a look?
05:45:07 <johnw> are you asking if there is, or if there isn't?
05:45:17 <fantasticsid> if there is
05:45:57 <fantasticsid> is therer? I think there is..
05:46:07 <johnw> why do you think that?
05:47:04 <madjestic> mm_freak_: interesting.  So, part of what you are saying is that humans are still better at making assumptions than some compilers, ghc in this case.  Can that be improved?
05:47:38 <mm_freak_> madjestic: no, that wasn't my point
05:47:40 <fantasticsid> cause 'wait' basically will call readMVar, which is not atomic when there's another producer
05:48:06 <madjestic> mm_freak_: I know that you were answering a different question
05:48:07 <johnw> I don't really understand what you mean by that, fantasticsid.  In what way is it not atomic?
05:48:51 <mm_freak_> madjestic: it's an unsafe function and was abused to work around having started with the wrong type to begin with
05:48:56 <fantasticsid> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-MVar.html#v:readMVar
05:48:59 <quchen_> readMVar isn't atomic, but it does not matter here.
05:49:00 <fantasticsid> documentation
05:49:10 <mm_freak_> madjestic: the proper solution is to use Stream, for which 'head' is total
05:49:22 <fantasticsid> why? there are two producers here
05:49:26 <quchen_> Make empty MVar, fork lots of computations that race for putting their value into the MVar, return the MVar's contents.
05:49:33 <madjestic> mm_freak_: thanks for explaining
05:49:38 <mm_freak_> data Stream a = (:>) { head :: a, tail :: Stream a }
05:50:46 <fantasticsid> problem is wait uses readMVar, which gets takeMVar and then putMVar
05:51:22 <quchen_> wait doesn't use MVars, it's STM-based.
05:51:23 <fantasticsid> there's possibility that wait successfully takeMVar, but then blocks at putMVar because second producer successfully putMVar before wait
05:51:54 <quchen_> Maybe the example is given in the book before the STM chapter though. I think Async is refined in a later chapter with that in mind.
05:52:55 <fantasticsid> in the book Async is defiend before STM chapter
05:53:39 <johnw> @src readMVar
05:53:39 <lambdabot> readMVar m = block $ do
05:53:39 <lambdabot>     a <- takeMVar m
05:53:39 <lambdabot>     putMVar m a
05:53:39 <lambdabot>     return a
05:53:52 <FreeFull> That doesn't look atomic
05:54:27 <FreeFull> What if another thread does putMVar after the take, and before this thread does?
05:55:20 <quicksilver> that is correct
05:55:29 <quicksilver> (did anybody claim readMVar was atomic?)
05:56:09 <fantasticsid> the documentation says it's not atmoic when there are other producers
05:56:15 <quicksilver> right.
05:56:27 <quicksilver> readMVar is atomic modulo a certain discipline
05:56:42 <quicksilver> "everyone takes before putting"
05:56:50 <quicksilver> but if you break that rule...
05:57:28 <prophile> all hell doth break loose?
05:57:37 <fantasticsid> the book did not mention this
05:59:01 <FreeFull> STM doesn't have catches like that
06:09:56 <ij> How do I add pkgs to local hoogle db?
06:34:24 <ocharles> There's not really anyway for a log :: String -> IO () function to know the source information about the caller, is there?
06:34:40 <ocharles> Certainly not without running in profiling mode
06:38:31 <nimish> ocharles: is there not a __LINE__ macro in ghc?
06:39:25 <ocharles> nimish: that would only tell me a line number inside log itself
06:39:27 <ocharles> not about the caller
06:39:38 <nimish> oh I see, hmm
06:40:05 <nimish> I guess you could pass the info as a parameter, but then log becomes hard
06:40:54 <nimish> maybe template haskell could auto-generate the info and you could pass it in?
06:41:14 <nimish> or am i misunderstangin
06:52:26 <jophish> Yo yo yo
06:58:03 <jophish> I asked about fixed sized arrays the other day. I've just found out that DataKinds provides something approaching what I want, Array 5 Int.
06:59:23 <jophish> hmm, Language.Haskell.Exts doesn't seem like to parse Literals in types though
07:01:14 <jophish> Ah, I see https://github.com/haskell-suite/haskell-src-exts/issues/30
07:16:01 <ocharles> Hrmm, do you have to do any magic to get `cabal repl` to work with `extra-libraries`?
07:16:09 <ocharles> '<command line>: user specified .o/.so/.DLL could not be loaded (libsystemd-journal.so: cannot open shared object file: No such file or directory)'
07:16:23 <ocharles> I don't really know where it's trying to look, either
07:16:41 <ocharles> `cabal build` seems happy enough
07:17:11 * hackagebot yaml 0.8.6.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.6.1 (MichaelSnoyman)
07:18:17 <ocharles> Hmm, might be a Nix problem actually
07:21:46 <ocharles> ok yea, cabal configure --extra-lib-dirs sorts it out
07:26:41 <exicer> I'm using flycheck in emacs, but it doesn't seem to deal with relative imports. Any idea how I can fix this ?
07:29:39 <x77686d> I'm a Haskell newbie so I'm surprised this compiles: http://lpaste.net/99518
07:29:53 <x77686d> Shows type as this: g :: (Eq t, Num t, Num [a], Num a) => [t] -> [a]
07:31:14 <[Bergi]> Hi!
07:31:14 <[Bergi]> Does anyone know whether there is a term for "joining" different monads together? For example I have IO (Maybe (IO a)) and want to get IO (Maybe a)
07:31:14 <[Bergi]> I can use (>>= Data.Traversable.sequence), but how would one name this function?
07:31:15 <greymalkin> x77686d: Why? It will only work with empty arrays, or arrays full of 5s.
07:31:15 <shiona> x77686d: to my knowledge, this is because "5" as a literal has no strict type
07:31:31 <ibid> x77686d: good luck making any call to it compille, though
07:31:39 <ibid> greymalkin: no arrays in that code
07:34:35 <mm_freak_> [Bergi]: natural transformations
07:35:18 <mm_freak_> trans :: forall a. IO (Maybe (IO a)) -> IO (Maybe a)
07:35:39 <mr-> You could almost call it distributivity
07:36:09 <mm_freak_> trans c = c >>= maybe (return Nothing) id
07:36:12 <ibid> x77686d: the reason it compiles is that haskell allows you to define previously non-numeric types into numeric types, and the compiler cannot rule it out that you've done that to lists somewhere (making "5" a legitimate list value)
07:37:07 <ij> Assuming I've retreived the nodes I want with HXT's "deep", how do I pass 'em to a function to manipulate with their information?
07:38:07 <x77686d> ibid: I see!  Thanks!
07:45:49 <[Bergi]> mm_freak_: Cool, thanks, I guess I'll have to read the large Wikipedia article about that. Do you know whether there are predefined functions for this in some package? I couldn't find any
07:50:43 <mm_freak_> [Bergi]: for the usual haskell functors a natural transformation from F to G is really just a function 'trans' of type 'forall a. F a -> G a' with the following law:  trans c . fmap f = fmap f . trans c
07:51:25 <mm_freak_> uhm
07:51:39 <mm_freak_> trans . fmap f = fmap f . trans
07:55:43 <ij> Why is nothing being printed?http://sprunge.us/PZiO
07:56:02 <[Bergi]> mm_freak_: OK, thanks!
07:56:20 <[Bergi]> I see, there is not much more than this simple function.
07:56:41 <mm_freak_> [Bergi]: such a function is a special case
07:57:12 <mm_freak_> [Bergi]: the Functor type class represents endofunctors on Hask, not functors in general
07:57:41 <mm_freak_> [Bergi]: 'return' and 'join' are also natural transformations, but they are incompatible with the type above
07:58:02 <mm_freak_> return :: Identity a -> M a
07:58:19 <mm_freak_> join :: Double M a -> M a
07:58:35 <mm_freak_> where newtype Double m a = Double (m (m a))
07:58:42 <Maior> what is it with people using sprunge?
08:00:49 <[Bergi]> mm_freak_: Yup, I think I get it (though usually too much theory overwhelms me). One single 'trans' function per special case of natural transformation. Tanks again!
08:01:56 <ij> shapr, mind taking a look of something I posted a 6 mins back, if you're not busy?
08:06:16 <joneshf-laptop> can you use hlint with stdin?
08:06:22 <joneshf-laptop> is there a flagi'm missing?
08:06:24 <kstt> GTK is infinite madness
08:06:58 <kstt> 50+ lines to display a list in a table
08:07:25 <kstt> all in IO, with 'setFooToBar foo bar' all along
08:07:34 <mm_freak_> kstt: you can use reactive-banana
08:08:02 <mm_freak_> it probably won't give you less lines, but it will make your lines a lot easier to digest =)
08:08:18 <kstt> maybe, but franckly my brain hurts enough for the moment
08:08:29 <kstt> it is just plain madness
08:08:35 <joneshf-laptop> ah
08:08:45 <mm_freak_> imperative stuff always hurts your brain
08:08:48 <joneshf-laptop> fwiw the flag is -
08:08:52 <joneshf-laptop> so like: hlint -
08:08:55 <kstt> I'd have been way faster with a Html interface
08:09:02 <joneshf-laptop> that should be documented
08:09:25 <mm_freak_> kstt: event handlers and property setters always hurt my brain
08:09:48 <mm_freak_> regardless of whether in a GUI toolkit or in HTML javascript
08:10:19 <kstt> HTML has been so easy in comparison, even with the most basic haskell servers
08:10:57 <kstt> displaying data is trivial, interface fragments are highly reusable
08:11:19 <kstt> and forms, although limited, are absolutly trivial to handle
08:13:08 <mm_freak_> after five years of haskell i have serious trouble thinking imperatively
08:15:12 <ownclo> mm_freak_: is it better than the opposite?
08:15:23 <mm_freak_> ownclo: "it"?
08:15:36 <fizbin> mm_freak_: Are you using haskell professionally?
08:15:46 <mm_freak_> fizbin: yeah
08:15:50 <ownclo> mm_freak_: the troubles in thinking imperatively
08:16:05 <ij> mm_freak_, What for?
08:16:07 <mm_freak_> ownclo: it got me into trouble
08:16:11 <mm_freak_> from time to time
08:16:32 <mm_freak_> paraphrased:  "why the hell are you using bacon.js and not angular?!"
08:16:48 <mm_freak_> ij: freelance
08:17:14 <ij> So you solve problems that have not specified lang requirements or haskell specifically?
08:17:49 <mm_freak_> ij: the former
08:18:04 <ij> You're a pretty cool guy then!
08:18:21 <mm_freak_> ij: i'm just watching my health
08:18:50 <ij> Hm?
08:19:34 <mm_freak_> ij: years ago i was a professional PHP and C++ developer…  it's unhealthy
08:20:28 <ij> I see. May I ask anything about hxt?
08:20:38 <ij> To you specifically, because I asked the channel already. :)
08:20:49 <mm_freak_> ij: i'm afraid i won't be able to help =)
08:21:05 <fizbin> mm_freak_: Oh, so you have to go Haskell after that. If you were just a recovering java programmer you could go only slightly functional by playing with scala and scalaz.
08:21:09 <ij> Too bad. :)
08:21:35 <tdammers> PHP and JavaScript pay my bills. Haskell keeps me sane.
08:21:50 <mm_freak_> fizbin: seriously?  even PHP has anonymous functions…
08:22:37 <mm_freak_> if i had programmed java instead of PHP/C++, then i'd be dead by now
08:22:54 <tromp> dead or broke?
08:23:10 <tromp> i guess you cant go broke on java
08:23:11 <ij> You can't be broke with java, I think.
08:23:23 <ij> Not that I've done java.
08:23:52 <fizbin> mm_freak_: It depends where. There are java environments that suck out your soul, true. Mostly though, the soul-sucking factory-style java is outsourced to India or elsewhere these days.
08:23:54 <tromp> i put up with C++/perl
08:23:59 <platz> you'd be in management probably
08:24:00 <tromp> until i can retire:)
08:24:05 <fizbin> But not every java environment is like that.
08:24:11 <mm_freak_> PHP is bad, really bad, but i was able to implement contracts and based on them i could use some sensible patterns
08:24:27 <fizbin> E.g., java at Google was quite a pleasant experience.
08:24:29 <mm_freak_> java doesn't allow that…  you have to go with bullshit patterns
08:25:03 <mm_freak_> fizbin: this isn't about environment, but about the language itself
08:25:53 <jophish> Is there something along the lines of :: TypecheckedModule -> String
08:26:25 <fizbin> mm_freak_: Right, and I'm saying the language is a bit verbose but not nearly as bad as standard factory-produced java may have led you to believe.
08:26:39 * ski stares at jophish
08:27:11 <mm_freak_> fizbin: that's not the point, but let's not start a language war, especially not between PHP and java =)
08:27:11 <fizbin> Any language - artificial or natural - has a two-way path of influence with the surrounding environment where it's used.
08:27:19 * hackagebot libsystemd-journal 1.0.0 - Haskell bindings to libsystemd-journal  http://hackage.haskell.org/package/libsystemd-journal-1.0.0 (OliverCharles)
08:27:22 <jophish> To elaborate: I'd like to print out some human readable representations of GHC's internal representations of Haskell as it's being transformed
08:29:23 <mm_freak_> fizbin: to me the line between usable and useless crosses anonymous functions with free variables
08:29:44 <t7> > let let let let a = 1 in b = 2 in c = 3 in d = 4 in (a, b, c, d)
08:29:45 <mm_freak_> that makes PHP usable and java useless…  this is my point of view, and it's completely subjective
08:29:46 <lambdabot>  <hint>:1:13: Parse error in pattern: let a = 1 in b
08:30:34 <t7> > let a = 1 in let b = 2 in let c = 4 in let d = 4 in (a, b, c, d)
08:30:36 <lambdabot>  (1,2,4,4)
08:30:48 <fizbin> mm_freak_: Ah. Yes, that is a bit of an issue. The guava libraries cover about 80% of the use cases you'd think to reach for that for, but the remaining 20% is common enough to stub your toe on it regularly.
08:31:41 <mm_freak_> btw, by that standard lazy k is usable and brainfuck is useless =)
08:33:16 <mbrock> hm, anonymous functions are syntactically verbose in java, but they're not absent or entirely unusable. I've used them a lot...
08:36:07 <fizbin> mbrock: I think mm_freak_ is placing emphasis on the "with free variables" bit, but that's not a burden in java if you go make local variables final.
08:36:28 <fizbin> But hey, we're haskellers, right? "final" is what we should be used to...
08:37:10 <fizbin> mm_freak_: Seriously though, since you're using haskell professionally, have you invested in your haskell environment?
08:37:29 <Maior> "invested in your haskell env"?
08:37:31 <fizbin> That is, paid for an IDE or a server specifically for compiles, or that sort of thing?
08:38:04 <Yaniel> paid for an IDE?
08:38:11 <Sornaensis> lol?
08:38:12 <mbrock> yeah, the `final' restriction is surprising and ugly, but it's never been a serious problem for me
08:38:23 <platz> anyone tried eclipseFP ?
08:38:41 <Maior> ?
08:38:44 <Maior> I pay for my IDE
08:38:46 <Yaniel> for a compile server, maybe (preferrably a CI server though)
08:38:56 <yyyyy> anyone knows what's the preferred way to run tasks periodically (referencing some time reference, be it pure or coming from IO) on a Haskell application?
08:39:01 <fizbin> Hey, my employer bought my team a behind-the-firewall copy of FP Complete's IDE for Christmas.
08:39:03 <platz> saw it mentioned in that new apress book.  apparently it's a haskell plugin for eclipse that also gives you scala-like "worksheets"
08:39:14 <yyyyy> for simple cases, not something where you'd use full-blown FRP.
08:39:15 <Maior> IDEA + Travis ftw
08:39:23 <fizbin> I mean, not *for* Christmas, the timing just worked out that way.
08:39:48 <platz> personally I'm fine with vim for now, not sure how much and IDE has to offer w/ haskell
08:39:57 <yyyyy> fizbin, how fast do you consider it versus using something like Emacs or Sublime Text?
08:40:12 <Yaniel> oh right, there is fpcomplete
08:40:15 <yyyyy> in responsiveness, not productivity
08:40:23 <yyyyy> (of course)
08:41:05 <fizbin> yyyyy: Usually, it's fine. Sometimes my home DSL gets screwy and then I might see a slight delay, but in general the editor feels like a local text editor.
08:42:03 <fizbin> My biggest complaint is that we're using some libraries not in the standard suite of libraries and the IDE needs to recompile those every time it starts up.
08:42:49 <fizbin> (Which it needs to do if you've left it idle for 10 or more minutes - you can edit during that time, but it won't compile your stuff until it's done)
08:43:40 <ij> Can I ask ghci to get some definitions for me?
08:45:06 <fizbin> I really should think about maybe maintaining fgl and uu-parsinglib for the standard library suite they use.
08:46:31 <rtpg> Is there a place where I can find a big lens example
08:46:45 <rtpg> as in: just a big file to use as a reference for all the operators and whatnot
08:46:59 <mm_freak_> fizbin: in most cases the hardware is not mine, and i use emacs
08:47:49 <fizbin> rtpg: Maybe ask #haskell-lens ?
08:48:50 <mm_freak_> fizbin: my "environment" consists of emacs, GHC, nix and zsh
08:49:03 <mada> Apparently I have a messy haskell installation. I have happy installed through arch's pacman and it's interfering with building git's ghc (which expects a newer version)
08:49:29 <mada> how can I go about getting things in order to be able to build a ghc regardless of the system-wide installation?
08:49:55 <monochrom> use a virtual machine :)
08:50:31 <yyyyy> fizbin, if recompiling is lengthy that would be cumbersome. say, the time it takes to compile yesod itself if you're using it.
08:50:42 <yyyyy> (only the time, yesod is of course there)
08:50:52 <mm_freak_> is hasktags smart enough to skip uninteresting directories?  most notably _darcs
08:50:57 <mm_freak_> fizbin: oh, and darcs =)
08:51:18 <fizbin> It's usually done by the time I've typed a full function out, if it even takes that long.
08:51:21 <mada> monochrom: really? D:
08:52:12 <ParahSailin> why does it take so long to compile source files defining long list values?
08:52:43 <c_wraith> ghc doesn't compile large literals well.  I think it's just not something that's ever been optimized for.
08:52:54 <mm_freak_> fizbin: hasktags?
08:53:12 <mm_freak_> oh
08:53:15 <mm_freak_> nevermind =)
08:53:21 <ParahSailin> ive got one where its an 8000 item list of overloaded bytestring literals and its taking a long time
08:53:50 <ParahSailin> and i think compiling with -prof is taking even longer
08:54:50 <ParahSailin> should i just keep waiting?
08:56:48 <jfischoff> I'm struggling to come with a procedure for finding space leaks.
08:57:03 <jfischoff> As a test I created one in a little program
08:57:47 <tvynr> Does anyone know of problems using LANGUAGE pragmas in .hs-boot files?  I've written a typeclass instance requiring FlexibleContexts in my .hs-boot file and placed the FlexibleContexts pragma at the top, but the compiler continues to indicate that I need the pragma.
08:57:51 <jfischoff> And I'm using the profiling rtsopts but its seems that it would very easy to miss something
08:59:07 <jfischoff> Its seems to really pinpoint a space leak requires -hr -hspecificCostCenter but narrowing down that cost center is tricky
08:59:39 <jfischoff> I feel like I am missing part of the reasoning process or something
09:00:22 <c_wraith> tvynr: you'll probably find most people don't use .hs-boot files at all. They have too many gotchas.
09:00:23 <SrPx> If graph reductions are inherently parallel, why has nobody made a graph reducer for a FPL that runs on the GPU?
09:00:51 <c_wraith> SrPx: they're not inherently parallel.  consider a diamond graph.
09:01:26 <ij> I want to use arrows for HXT, but I don't really get them right now. I know about how to use monads(not so much for the theoretical foundations.) Suggest me something readable.
09:01:26 <SrPx> c_wraith: I do not know what that is
09:01:58 <c_wraith> SrPx: that is, a simple 4 node graph.  node 1 depends on 2 and 3.  2 and 3 each depend on 4.
09:02:30 <jmct> SrPx: People have written ways to compute functional programs on GPUs. The issue issue is that not all programs are suited for data-parallelism
09:02:35 <c_wraith> SrPx: if you naively start parallel computations for 2 and 3, you're not going to end up gaining anything.
09:02:51 <SrPx> c_wraith: that does not happen in a program
09:03:01 <c_wraith> SrPx: that happens all the time.
09:03:03 <SrPx> jmct: where?
09:03:09 <SrPx> c_wraith: for example?
09:03:32 <jmct> SrPx: Look up DPH (Data Parallel Haskell)
09:03:44 <c_wraith> SrPx: let a = somecomplicatedvalue ; b = f a ; c = g a in h b c
09:03:54 <c_wraith> SrPx: there you go.  A simple diamond graph
09:04:07 <SrPx> fmapE: but it does not run on the GPU :/
09:05:06 <c_wraith> SrPx: most programs are not trees.
09:05:29 <jmct> SrPx: Also look up Accelerate
09:05:34 <shiona> depends on what level you look at the program
09:06:14 <jmct> Also, you need to keep in mind that GPUs are not well suited for all classes of computations
09:06:51 <jmct> they are optimized for a very specific set of mathematical computations used for graphics
09:07:35 <c_wraith> shiona: When talking about graph reduction, the evaluation graph is the only possible level to look at the program.
09:08:42 <SrPx> c_wraith: I don't understand the problem but I'll trust you
09:09:24 <jmct> SrPx: take the function f x y = (x ** x) + (y ** y)
09:09:44 <jmct> you could evaluated the two operations in brackets independently of each other (in parallel)
09:09:46 <SrPx> jmct: yes?
09:10:02 <jmct> but the addition of them forces a dependency on both
09:10:10 <jmct> forming a diamond in the dependency graph
09:10:23 <SrPx> the addition just waits for the others to be complete
09:10:29 <jmct> yep
09:10:44 <SrPx> s,o where it breaks?
09:10:47 <SrPx> so,*
09:11:26 <jmct> it doesn't break, the point is that the parallelism isn't independent
09:11:37 <ParahSailin> what exactly is the bottleneck of ghc compiling large list literalls
09:14:04 <wolv> Why can't I write the type ((->) e) as (e ->)?
09:14:44 <quchen> wolv: There are no type-level sections in the Haskell grammar
09:15:13 <enthropy> is there something better than fficxx for doing ffi to c++?
09:15:38 <wolv> quchen: Thanks. Why?
09:16:07 <enthropy> it seems with that one you have to write out the type in a long format that can have a mistake (you'll find out about at runtime) https://github.com/wavewave/fficxx/blob/master/sample/snappy-generator/SnappyGen.hs#L55
09:16:23 <quchen> wolv: There's no good reason as far as I know. It's just not there.
09:17:05 <ij> What does "first" do?
09:17:13 <enthropy> @type first
09:17:14 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
09:17:44 <enthropy> > first (+1) (1,'a')
09:17:46 <lambdabot>  (2,'a')
09:17:48 <jle`> ij: turns a function on a normal value into a function on the first item in a tuple
09:18:06 <jle`> :t first (+1)
09:18:07 <lambdabot> Num a => (a, d) -> (a, d)
09:18:07 <ij> but... it needed only one argument...
09:18:26 <jle`> :t (+1)
09:18:28 <lambdabot> Num a => a -> a
09:18:33 <ij> oh
09:18:50 <enthropy> it doesn't only have to be used with (Arrow (->) =>)
09:18:50 <jle`> (+1) is a -> a, first (+1) is (a,d) -> (a,d)
09:19:04 <jle`> *turns an Arrow
09:19:05 <enthropy> what's confusing is that we have two different 'a'
09:19:23 <jle`> yeah i never liked the convention of using 'a' for Arrow
09:19:29 <jle`> i use r normally when talking about it
09:19:46 <jle`> first :: Arrow r => r b c -> r (b, d) (c, d)
09:19:53 <jle`> or for r ~ (->)
09:20:08 <jle`> first :: (b -> c) -> ( (b,d) -> (c,d) )
09:20:11 <ij> aha
09:20:15 <ij> !
09:20:50 <philipdexter> in haskell-mode (emacs) if you call align on a function, specifically `haskell-indent-align-guards-and-rhs', it will also align the type `:: ...' to the equal sign. I've looked through other Haskell projects and I have never seen this indentation used. is there a way to turn this off? if the answer is `look at the code' then that is fine, as I'm comfortable with elisp. I just wanted to know if there was a quick existing way to
09:20:50 <philipdexter> accomplish this
09:21:37 <ij> jle`, Are there any non (->) examples?
09:21:46 <jle`> well i'm writing about one heh.
09:22:11 <jle`> but maybe Kleisli is another one
09:22:15 <alpounet> yep
09:22:59 <jle`> :t Kleisli
09:23:01 <lambdabot> (a -> m b) -> Kleisli m a b
09:23:23 <SrPx> So fine, but you still didn't answer whether there is a FPL running on the GPU entirely
09:23:27 <jle`> > first (Kleisli Just) (1,2)
09:23:31 <lambdabot>  Couldn't match expected type `(t1, t2) -> t0'
09:23:31 <lambdabot>              with actual type `Control.Arrow.Kleisli
09:23:31 <lambdabot>                                  Data.Maybe.Maybe (c0, d0) (c0, d0)'
09:24:39 <jle`> um let me fix that
09:25:00 <jmct> SrPx: That I know of, there is not one. But there were similiar things
09:25:11 <jle`> > runKleisli (first (Kleisli Just)) (1,2)
09:25:12 <lambdabot>  Just (1,2)
09:25:22 <jle`> not a very good example though heh
09:25:46 <jmct> SrPx: Look up the GRIP machine from the 90's. And ALICE
09:26:10 <silasm> jmct: papers? I couldn't find any free ones on GRIP
09:26:34 <jle`> > runKleisli (first (Kleisli (Just . (+10)))) (1,2)
09:26:35 <SrPx> 90's!? hmm
09:26:35 <lambdabot>  Just (11,2)
09:27:05 <jle`> ij: http://en.wikibooks.org/wiki/Haskell/Arrow_tutorial
09:27:08 <jle`> has an example
09:27:30 <ij> I'll check them.
09:28:11 <SrPx> jmct: what alice?
09:28:25 <jle`> hm
09:28:31 <jle`> anyone here use netwire?
09:29:07 <jle`> or arrows in general
09:29:15 <SrPx> jmct: nvm
09:29:29 <jmct> SrPx: It was a machine built for parallel reduction of functional programs
09:29:40 <jle`> how do i use a wire that is returned by a wire later on in the same proc block?
09:29:45 <jle`> as a wire
09:29:57 <jle`>  wire is not ArrowApply so -<< doesn't quite work
09:30:34 <jmct> SrPx: Do you know of _any_ languages that run completely on the GPU? Are you thinking of things like CUDA?
09:31:50 <ij> How far from Control.Category are arrows?
09:32:09 <ij> What are their relations?
09:33:52 <SrPx> jmct: yes but I meant a functional language... I'm implementing an interpreter for the ULC using shaders and textures but I hate reinventing the wheel...
09:34:18 <jle`> the Category typeclass represents the essential ideal of "function-like" things/ morphisms
09:34:26 <jle`> it only provides id and (.)
09:34:36 <jle`> the Arrow typeclass provides useful combinators on morphisms
09:34:38 <jmct> SrPx: And something like Accelerate doesn't help?
09:34:43 <ij> Prelude provides those too, doesn't it?
09:34:52 <jle`> ij: 'provides' in a typeclass sense
09:35:00 <jle`> Prelude only defines id and (.) for (->)
09:35:22 <jle`> but Category uses id and (.) as typeclass operators and members
09:35:22 <SrPx> jmct: I don't know enough about accelerate, honestly, but probably not, as I wanted something simple so I could learn and copy/adapt... doesn't look like I would learn how to implement such an interpreter by looking at accelerate source ?
09:35:53 <jle`> it'd be like Prelude defining mempty = [], and mappend = (++)...but Data.Monoid generalizing mempty and mappend to all monoids
09:36:16 <jle`> (luckily prelude doesn't do that)
09:36:45 <jle`> (otherwise we'd have to use import Prelude hiding (mempty, mappend) before using mappend and mempty on monoids in general
09:37:07 <jmct> SrPx: Ah, so you're looking to implement your own functional language on GPUs?
09:37:13 <ij> jmct, Why isn't it like that for ./id?
09:37:16 <jle`> but we do have to import Prelude hiding (id,(.)) to work on Categorys in general
09:37:20 <jle`> well
09:37:30 <jle`> the type errors you'd get are pretty intimidating
09:37:32 <jle`> if you're new
09:37:52 <jle`> it's the same reason why we don't use map = fmap and not have map be list-specific
09:37:53 <jmct> ij: I don't understand. Do you mean the language 'id'?
09:38:11 <jle`> imagine starting out Haskell, writing `map`, and getting a type error about Functors instead of about Lists
09:38:12 <ij> jmct, Read that as (.)/id from prelude
09:38:20 <ij> / being OR
09:38:27 <jle`> imagine writing (.)/id and getting a type error about Categories
09:38:30 <jle`> instead of about functions
09:38:41 <jle`> (as a Day 1 haskeller)
09:39:07 <jmct> ij: I think you responded to the wrong person ;)
09:39:17 <jle`> still a lot of people think that map should = fmap and Prelude should have (.) and id as the Category (.)/id
09:39:22 <ij> jmct, oh, indeed! sorry
09:39:36 <jle`> also monad comprehensions
09:39:39 <jle`> etc.
09:40:01 <ij> I'm starting to think that too.
09:40:16 <jle`> anyways a readily available example is the Kleisli Arrow, (a -> m b), for monads m
09:40:30 <silasm> jle`: thankfully languages like Idris / Agda can do that (though I'm not sure they do)
09:40:33 <jle`> you can compose kleisli arrows with (<=<)
09:40:51 <jle`> like f <=< g
09:40:58 <silasm> since most people going to those have some haskell knowledge anyways
09:41:18 <jle`> and the identity for the kleisli arrow is return :: a -> m a
09:41:29 <jle`> but because we already have a Category instance for (->), we have to wrap it in a newtype
09:41:55 <jle`> newtype Kleisli m a b = Kleisli { runKleisli :: (a -> m b) }
09:42:21 <jle`> so Kleisli return :: Kleisli m a a
09:42:38 <jle`> so now we can do things like (Kleisli Just) . (Kleisli return)
09:42:41 <jle`> to compose kleisli arrows
09:42:48 <jle`> or better
09:42:52 <jle`> (Kleisli Just) . id
09:42:54 <jle`> :)
09:43:12 <jle`> where id = Kleisli return
09:44:01 <jle`> the whole point is that we abstract over all morphisms so that we can treat them in the same language/terminology/vocabulary/syntax, despite them all being of vastly different implementation
09:44:15 <jle`> so we can work with any morphism we want using . and id
09:44:35 <jle`> if you use netwire or FRP, this is invaluable
09:44:39 <jle`> *AFRP
09:45:12 <ij> I will one day understand all of what you said and be happier with myself.
09:45:14 <jle`> because wires can be thought of as stateful boxes with input and output channels, so we can compose wires using (.) and "think of them" just as if they were functions.
09:45:34 <jle`> it's just like how a lot of things are "mappable"
09:45:39 <jle`> so we use the functor typeclass
09:45:43 <jle`> and now we can treat all mappable things the same way
09:45:57 <jle`> and reason about them similarly
09:46:42 <jle`> fmap for IO and fmap for Maybe are completely different, implementation-wise...but because we have Functor, we can work with them both the same way and apply the same functor reasoning
09:46:46 <ij> I've been thinking about functions as wires, it's a nice way to think about them.
09:48:17 <jle`> wires you can chain and link together.  (.) is the linking, id is a wire that just spits out what was put into it
09:48:35 <jle`> you can think of Arrow typeclass as providing little wire splitters and wire re-fusers
09:48:56 <jle`> so you can apply two functions to the same value side-by-side/in parallel and recombine them afterwards
09:49:29 <ij> *** applies two args in parallel, but how do I syntactically use it? x *** y $ arg?
09:49:39 <jle`> > ((+1) &&& (*2)) 10
09:49:41 <lambdabot>  (11,20)
09:49:56 <jle`> > ((+1) *** (*2)) (5,10)
09:49:57 <lambdabot>  (6,20)
09:50:18 <jle`> you use them the same way you'd use (.)
09:50:20 <jle`> syntactically
09:50:44 <jle`> all three are binary operators on morphisms
09:50:46 <ij> hmm, right
09:51:06 <jle`> r something -> r something -> r something
09:51:26 <jle`> put in two morphisms and it spits out a new composed morphism
09:51:34 <Reite> Is there a haskell library that will convert a PDF to a image (JPG/PNG)?
09:51:53 <jle`> you can name the new one if you want, or just use it anonymously like i did just now
09:52:53 <cschneid> Reite: can't reuse imagemagick? it does that well
09:52:59 <ij> jle`, Okay, got the arrow part now. But I had lost you when you talked a bit about Kleisi, was that rather important?
09:53:32 <jle`> kleisli was just another example of a Category that i used because it might be familiar-ish
09:53:57 <jle`> people don't really use the Kleisli type and its Category instance all too often i don't think (i could be wrong)
09:54:22 <jle`> but it is probably useful to understand that functions (a -> m b) are morphisms under a category
09:54:27 <jle`> that you can compose
09:54:36 <jle`> using <=<
09:54:37 <ParahSailin> Reite: pdf rendering is quite involved
09:54:49 <jle`> and that has an identity, return :: a -> m a
09:55:29 <jle`> Just is a common kleisli arrow, a -> Maybe a....so is putStrLn :: String -> IO String
09:55:32 <jle`> er
09:55:35 <jle`> sorry
09:55:40 <Reite> cschneid: Would prefer pure haskell if available, but if it isnt I will use that
09:55:40 <jle`> String -> IO ()
09:55:54 <jle`> and you can compose and chain them one after the other
09:55:59 <jle`> in plain old haskell using <=<
09:56:10 <jle`> or as instance of Category, using (.)
09:56:35 <Reite> I dont get why PDF is so complex
09:57:27 <jle`> so i have an arrow g = (\_ -> readLn) and an arrow f = putStrLn
09:57:35 <jle`> i could compose them using <=<
09:57:49 <jle`> :t putStrLn <=< (\_ -> readLn)
09:57:50 <lambdabot> a -> IO ()
09:58:02 <jle`> which reads something, and then puts it
09:58:33 <jle`> the Kleisli Arrow is just a newtype wrapper that lets us use (.)
09:58:45 <jle`> :t (Kleisli putStrLn) . (Kleisli (\_ -> readLn))
09:58:46 <lambdabot>     Couldn't match expected type `b0 -> c0'
09:58:47 <lambdabot>                 with actual type `Kleisli IO String ()'
09:58:47 <lambdabot>     In the return type of a call of `Kleisli'
09:59:02 <jle`> aw
10:00:32 <jle`> oh, it uses the prelude (.)
10:01:23 <jle`> :t (Kleisli putStrLn) Control.Category.. (Kleisli (\() -> getLine))
10:01:24 <lambdabot> Kleisli IO () ()
10:01:54 <jle`> so the composition of getLine and putStrLn is a kleisli arrow that takes in nothing and outputs nothing (it just gets and puts what it gets, and returns nothing)
10:02:10 <jle`> :t putStrLin <=< (\() -> getLine)
10:02:11 <lambdabot>     Not in scope: `putStrLin'
10:02:11 <lambdabot>     Perhaps you meant one of these:
10:02:11 <lambdabot>       `putStrLn' (imported from Prelude),
10:02:17 <jle`> :t putStrLn <=< (\() -> getLine)
10:02:18 <lambdabot> () -> IO ()
10:02:49 <jle`> the cool thing about seeing Kleisli as a category
10:03:07 <jle`> is that the category laws for kleisli arrows give you the monad laws
10:03:38 <jle`> recall that the category laws are id . k == k, k . id == k, k . (j . l) == (k . j) . l
10:04:27 <jle`> return <=< k == k, k <=< return == k, k <=< (j <=< l) == (k <=< j) <=< l....which if you do some rearranging, are exactly the monad laws
10:05:01 <ij> So why are thre two of them?
10:05:10 <jle`> two of what?
10:05:48 <jle`> Reite: what do you think PDF is?
10:06:27 <ij> Why is there a monad, if category can be reduced to monads?
10:07:09 <jle`> well, Kleisli is an instance of Category
10:07:17 <jle`> just like Maybe is an instance of Functor
10:07:24 <jle`> there are a lot of Functors, but only one Maybe
10:07:36 <jle`> lots of Categories, but only one Kleisli / category over monad functions (a -> m b)
10:08:39 <jle`> but you might have been asking why are there explicit monad laws?  well, yeah, the monad laws are redundant :)  you just need to say that (a -> m b) form a category under (<=<) and return, and the monad laws come for free :)
10:09:16 <bennofs> Can I customize quickcheck's behaviour in a failure case? The output produced by Show is too big for my datastructure
10:09:46 <jle`> just like saying "What are the `map` laws?" for List --- map id xs = xs, map (f . g) xs = (map f . map g) xs
10:10:10 <jle`> these are the laws that `map :: (a -> b) -> [a] -> [b]` must hold
10:10:23 <enthropy> bennofs: you can use quickCheckWithResult
10:10:24 <jle`> buuuuut we can just say that List is a functor
10:10:39 <jle`> with fmap = map
10:10:49 <enthropy> set chatty=False, and print the Result however you like
10:10:53 <tvynr> I have a piece of Template Haskell which generates a lot of very nice boilerplate for me.  The routine takes a member data type (e.g. Inner) and defines a container type (e.g. Outer).  Unfortunately, in my case, Inner is defined in terms of Outer; there's a cyclic dependency.  Template Haskell's scoping rules don't make this easy.  Does anyone have any suggestions how I resolve such a problem?
10:11:39 <jle`> and recall the Functor laws, fmap id x = x, fmap (f . g) x = (fmap f . fmap g) x, where x is [a] for List
10:11:59 <jle`> and so we see that we don't need to define a separate "map law for lists", we cna just say that list is a functor and we get the "map law for lists" for free
10:12:23 <Reite> jle`: I know its complex because its self contained, but Im pretty ignorant about the challenges that entails. I understand it supports flash and video too, and I dont see the need for that. Have no idea how its implemented though and what kind of complexity it adds
10:15:15 <tekul> Quick question on cabal. Is there a way I can override one of the dependency versions when installing a package? I tried to use a constraint: 'cabal install --constraint="attoparsec==0.11.1.0" crypto-pubkey-openssh' but it doesn't like that. "(conflict: crypto-pubkey-openssh => attoparsec==0.10.*)"
10:16:03 <troydm> tekul: no
10:16:05 <dcoutts> tekul: not yet except by editing the .cabal file. People are working on a feature to allow selectively ignoring constraints
10:16:14 <tekul> Ok, thanks.
10:20:16 <jfischoff> tvynr: generate both in one splice
10:22:22 <tvynr> jfischoff: Yeah; I'm reaching a similar conclusion, I think.  I can actually get away with something a bit looser; I can just manually construct the TH representation of the Outer type from within the slice that declares Inner and then use that TH.Type in the Inner slice definition.  The whole problem seems to be resolving my code fragments.
10:22:28 <tvynr> jfischoff: Thanks.  :)
10:28:05 <bennofs> I'm writing tests for a game logic implementation. I have a function nextMoves :: Board -> [PossibleMove] and a function applyMove :: PossibleMove -> Board -> Board. I also have a starting board. I'd now like to write tests that picks a random nextMove, applies it, and then checks that some basic assertions hold. I'd also like to get useful output in case of a failure. Also, the assertions after each turn
10:28:07 <bennofs> need some extra state that is preserved between "turns".
10:28:33 <bennofs> Can/How do I use QuickCheck for this task?
10:29:09 <tomejaguar> Have a datastructure which holds Board and the extra state?
10:36:09 <bennofs> tomejaguar: ok, thanks. I think I missed that I don't need to use `forAll` with quickcheck, I can get nicer output if I use `printTestCase` directly
10:37:46 <AncientPC> I don't understand why this test is failing to compile when it works in GHCi: http://lpaste.net/8973820770371239936
10:38:51 <AncientPC> the function returns a Bool, yet it's complaining about no instance for (Eq a0) because `a0` is ambiguous.
10:39:04 <supki> AncientPC: what Eq instance should GHC choose?
10:39:24 <supki> GHCI has extended defaulting rules and chooses ()
10:39:49 <supki> (you can enable them in your file with a pragma)
10:40:44 <supki> AncientPC: usually you solve this kind of problem by providing a type annotation for []
10:41:21 <AncientPC> ohhhhh
10:41:57 <AncientPC> thanks supki
10:42:34 <jophish> What is the distinction between a Function binding and a Pattern binding?
10:42:56 <merijn> jophish: Can you clarify what you mean by a "function binding"?
10:43:08 <jophish> merijn: as seen here
10:43:09 <jophish> http://hackage.haskell.org/package/haskell-src-exts-1.13.5/docs/Language-Haskell-Exts-Syntax.html#t:Decl
10:43:23 <jophish> it consists of a list of matches http://hackage.haskell.org/package/haskell-src-exts-1.13.5/docs/Language-Haskell-Exts-Syntax.html#t:Match
10:43:45 <jophish> a pattern binding seems to be just a single match
10:44:46 <merijn> jophish: I'm guessing (note, guessing) a pattern bind refers to binding the variables in a single pattern match, whereas a function binding is a list of potential pattern matches?
10:45:57 <shepheb> what's the current go-to for binary file parsing?
10:46:23 <luite> shepheb: attoparsec usually
10:46:56 <jophish> merijn: I'll see if I can get either of them out of the parser
10:47:58 <shepheb> I don't even really need parsing, just a binary read into a UArray i Word8
10:50:30 <enthropy> jophish: you're allowed to write   Just x = 3 -- at top-level
10:50:38 <enthropy> or in a let
10:50:44 <merijn> shepheb: For simple things cereal or binary
10:50:57 <jophish> enthropy: ah
10:50:58 <enthropy> and that can't get expressed in terms of Match (what's the Name?)
10:51:10 <jophish> I see
10:51:12 <jophish> thanks enthropy
10:51:17 <enthropy> there's some redundancy I think
10:51:56 <enthropy> x = 3 -- is this a Match with the [Pat] empty, or is it a PatBind (PVar "x")?
10:52:46 <jophish> enthropy: a PatBind
10:53:18 <adelbertc> where would one go if one wanted a FIFO queue?
10:53:21 <jophish> weird
10:55:19 <benedikt> can i change the location for temp files for cabal? I have /tmp mounted as noexec, which makes cabal fail
10:56:04 <monochrom> does "cabal install --help" tell you?
10:56:07 <dcoutts> benedikt: iirc it respects $TEMP
10:56:20 <benedikt> dcoutts: nice. should have thought of that
10:56:24 <benedikt> but isn't it $TMPDIR
10:56:31 <dcoutts> benedikt: whatever is the standard
10:57:23 <merijn> adelbertc: For what purpose? Communication between threads?
10:57:31 <adelbertc> merijn - bfs through a graph
10:57:59 <merijn> adelbertc: Right, then I would say Control.Concurrent.Chan, bonus for the ability to more easily parallelise it later :)
10:58:25 <suls> what binding is missing here? http://lpaste.net/99521 (complete beginner warning)
10:58:31 <adelbertc> hm, seems a bit weird to use something in Control.Concurrent for something like a queue, but i'll go with it :-P
10:59:16 <adelbertc> merijn - eh, everything returns IO (which makes sense in the Concurrent context), though not exactly for my purposes i don't think
10:59:18 <merijn> adelbertc: Alternatively you can use "([a], [a])" as a nice queue, append to second list, pop from first. If first list is empty replace the first list with 'reverse secondList" and secondList with []
10:59:32 <merijn> O(1) append/pop (amortised)
10:59:39 <adelbertc> merijn - banker's queue innit - is there an existing impl somewhere or should i just code it myself
10:59:54 <merijn> THere's bound to be an implementation, but don't ask me where :)
10:59:58 <negatratoron> suls: the case where the list has exactly one element is missing
11:00:14 <suls> right
11:00:22 <adelbertc> merijn - heh alright ill look around
11:00:24 <suls> cheers!
11:00:24 <prinsen_> Is there any way to cast a Dynamic to a runtime specified typerep?
11:00:25 <adelbertc> thanks
11:00:56 <monochrom> adelbertc: http://hackage.haskell.org/package/EdisonCore has banker's queue
11:01:18 <adelbertc> author: Chris Okasaki :O
11:01:44 <adelbertc> monochrom - cheers
11:10:46 <jrmithdobbs> is the "shared record name" stuff 7.8 or planned for 7.10?
11:10:50 <jrmithdobbs> forget where i heard about it
11:12:10 <shepheb> also for some reason my cabal-install stopped printing the "[n of m] Some.Module" messages. what's up with that?
11:12:36 <shepheb> luite: or was that one of the GHCJS fork changes?
11:13:43 <bennofs> shepheb: cabal-1.18 does use multiple jobs by default iirc, and then it doesn't print the build output (because that would look weird, mixed build output from multiple compilations)
11:13:43 <k00mi> shepheb: it doesn't print those when you're building in parallel
11:13:57 <shepheb> I see.
11:13:59 <bennofs> shepheb: try cabal install -j1 <package>
11:14:54 <shepheb> ah, I see.
11:16:20 <enthropy> is there a newer alternative to http://hackage.haskell.org/package/EnumMap ?
11:17:38 * hackagebot unbounded-delays 0.1.0.6 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.6 (BasVanDijk)
11:18:27 <prinsen_> Is there anyway to cast a dynamic to a specific TypeRef at runtime?
11:20:36 <luite> shepheb: yep parallel builds reduce the verbosity :)
11:20:54 <AncientPC> How do you use an as-pattern on an association list? I'm trying `all@[(k,v)]`. It compiles but doesn't work...
11:21:29 <ReinH> AncientPC: do you expect that to match a list exactly one element?
11:21:33 <ReinH> *with exactly
11:21:51 <ReinH> because that's the only thing it will match
11:21:52 <AncientPC> ReinH: no, multiple
11:21:53 <AncientPC> oh ok
11:22:09 <ReinH> just like [x] matches a list with a single element
11:22:31 <ReinH> if you want to specify that your list is an association list you can do that at the type level
11:23:57 <AncientPC> you mean declare another type just for association lists?
11:24:39 <jle`> AncientPC: what are you trying to do, exactly?
11:24:44 <jle`> do you want k to match the list of all keys?
11:24:49 <jle`> and v to match the list of all v's?
11:25:24 <AncientPC> well I'm checking if there are any duplicate keys in an association list and if so throw an error
11:25:31 <AncientPC> if not, then process the list accordingly
11:25:33 <davidfetter_disq> hello
11:25:50 <jle`> AncientPC: then you can use an as pattern on the list, yeah
11:26:10 <davidfetter_disq> has anybody here built a grammar-aware tab completion tool, especially one for SQL?
11:26:24 <jle`> you can also get a list of keys from an association list
11:26:35 <jle`> :t map fst
11:26:36 <lambdabot> [(b, b1)] -> [b]
11:26:50 <jle`> map fst takes [(k,v)] and returns [k]
11:27:06 <AncientPC> ahh ok, I wrote a hasDuplicateKeys for association lists
11:27:08 <AncientPC> but that works too
11:27:20 <jle`> if you just want to as-pattern your list
11:27:25 <jle`> you can do all@list
11:27:26 <AncientPC> I was trying to extract the first k,v because I need to process them if no duplicates
11:27:30 <jle`> oh
11:27:33 <jle`> in that case
11:27:38 <jle`> all@((k,v):rest)
11:27:46 <jle`> the same way you match against anything x:xs
11:28:17 <jle`> in that case, k is your first key and v is your first value
11:28:28 <AncientPC> jle`: thanks, that's what I needed
11:28:32 <AncientPC> was so close xD
11:28:46 <jle`> :)
11:28:53 <jle`> alternatively if you did not know off-hand
11:29:08 <jle`> you can do all@(x:xs) = case x of (k,v) -> ...
11:29:30 <enthropy> _prinsen: you mean TypeRep?
11:29:31 <jle`> and then see that you can pull (k,v) into x in the pattern
11:30:04 <AncientPC> I didn't know that. :)
11:30:25 <dhrosa> do functions not have a Monoid instance? I thought they were a monoid over composition?
11:30:39 <jle`> dhrosa: functions that return monoids have monoid instance
11:30:51 <merijn> dhrosa: The monoid instance for function composition is Endo
11:30:52 <jle`> and 'endo'functions :: a -> a have a monoid instance as well
11:31:04 <jle`> in the Endo newtype wrapper
11:31:04 <AncientPC> Man with Python I just write and write and add tests and debug. With Haskell I'm just staring at the same 5 lines of code for forever. :P
11:31:06 <dhrosa> sorry, specifically a -> a functions
11:31:15 <dhrosa> ah
11:31:26 <zomg> AncientPC: because with Haskell you only need 5 lines? ;)
11:31:27 <jle`> AncientPC: you get used to it ;)  how long have you been writing python? and Haskell?
11:31:38 <jle`> haha that too
11:31:46 <merijn> AncientPC: So do I, but my 5 lines of haskell do more :)
11:31:46 <bennofs> http://lpaste.net/99523 -- Is there a haskell2010 equavilent of that idiom?
11:32:22 <AncientPC> jle`: I've been writing Python professionally for ~4 years now. Haskell on the side for a few months.
11:32:39 <AncientPC> although my Python has gotten a lot more functional after learning Haskell. xD
11:32:40 * hackagebot bindings-levmar 1.1.0.2 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.1.0.2 (BasVanDijk)
11:32:55 <jle`> AncientPC: then it's not a fair comparison :)  come back and say the same thing after using Haskell for 4 years professionally :P
11:33:17 <AncientPC> I refuse to do MS stack or Java jobs, it was hard enough finding a Python position.
11:33:23 <AncientPC> I can't imagine trying to find a Haskell one.
11:33:26 <fragamus> hey guys I tried to install edwardk linear package and i got scary failure installing the dependencies
11:33:49 <fragamus> adjunctions-4.0.1 depends on transformers-compat-0.1.1.1 which failed to
11:33:49 <fragamus> install.
11:33:54 <zomg> AncientPC: I think it's a good sign when a developer stands behind his choices enough to not just accept any job :)
11:33:54 <merijn> AncientPC: They aren't advertised (much)
11:34:24 <jle`> bennofs: i'd just use a guard?
11:34:36 <jle`> if the if is at the top level
11:34:38 <merijn> AncientPC: There's haskellers.com, I've been approached 3 times through that. Furthermore just going around in the community you hear about more positions
11:34:51 <bennofs> jle`: yes, but I have if's and normal monadic statements mixed
11:35:01 <AncientPC> merijn: yeah, at least Bay Area has a Haskell meet up group. I'll probably start going to that.
11:35:04 <ReinH> merijn: seriously considering picketing Galois until they hire me :)
11:35:08 <AncientPC> There's no such community in Austin that I'm aware of.
11:35:17 <bennofs> jle`: I should probably use EitherT :p
11:35:45 <jle`> bennofs: EitherT would probably have just as much boilerplate i think, unless you do this a lot
11:35:45 <ReinH> bennofs: well, I'm spotting some boolean blindness there
11:35:46 <bennofs> then I can just do when cond $ left returnVal
11:35:58 <bennofs> ReinH: it's a stripped down example
11:36:09 <bennofs> ReinH: in the real code, I want to return an error string in case of failure
11:36:17 <AncientPC> zomg: I turned down a C++ position with the MS Azure group recently. Don't know if that decision will haunt me in the future.
11:36:21 <ReinH> bennofs: errors adds a few niceties to EitherT http://hackage.haskell.org/package/errors
11:36:53 <zomg> AncientPC: you can probably get a job at MSFT later on too if you're any good
11:37:22 <fragamus> AncientPC: where in the bay area are you
11:37:35 <AncientPC> Obviously there are many lucrative C++ / Java positions, but I feel like the state of programming needs to move on to the next generation.
11:37:44 <AncientPC> but adopting a PL is a highly social decision
11:37:56 <AncientPC> fragamus: I'm in Austin, moving to SF in June.
11:38:09 <AncientPC> although with the current rent prices, probably East Bay
11:38:41 <fragamus> I recently told someone I'm using Haskell and he said "Why are you using Haskell?"
11:38:51 <AncientPC> My ideal location would be Noe Valley.
11:38:55 <fragamus> "because I don't want my children to grow up ugly"
11:38:58 <bennofs> @hoogle eitherT
11:38:59 <lambdabot> package EitherT
11:39:06 <AncientPC> fragamus: "I believe in a better future."
11:39:48 <AncientPC> I've had more than enough "fun" chasing down memory leaks / race conditions in large C++ programs.
11:42:35 <avaritia> AncientPC: now you've got only space leaks to care about xD
11:43:35 <WarzoneCommand> Question, is there a way to define a type level list with a fixed kind?
11:43:36 <bennofs> What is quickCheck's exhaustive member of Testable?
11:48:02 <shapr> edwardk: I appear to have lost the rabbit, so I'm using the GNU I bought off RMS instead.
11:48:30 <shapr> ij: Sorry, I am busy.
11:49:53 <fragamus> hey guys I tried to install edwardk linear package and i got scary failure installing the dependencies
11:50:02 <fragamus> adjunctions-4.0.1 depends on transformers-compat-0.1.1.1 which failed to
11:50:02 <fragamus> install.
11:50:28 <sm> shapr: hi! and carry on :)
11:51:08 <shapr> sm: Howdy Simon! How's code?
11:51:28 * shapr checks to see if joyful.com still works
11:52:50 <sm> shapr: great! and how's yours, esteemed haskell sponsor
11:53:43 <adelbertc> how do I export a function name that clashes with Prelude (e.g. "null") ? The function definition itself uses Prelude.null. When I try to export it it says it's ambiguous - makes sense. I try to qualify the export with the module name, didn't work. help?
11:55:17 <pmade> adelbertc: Do you:  import Prelude hiding(null); import qualified Prelude as P; ?
11:55:40 <merijn> Data.List has a stripPrefix but not stripSuffix? :(
11:55:46 <fragamus> dist/build/autogen/Paths_cabal_install.hs:21:13:  Not in scope: `catch'
11:56:03 <fragamus> Having horrible issues here
11:56:23 <adelbertc> pmade - works! cheers
11:56:48 <merijn> fragamus: How old is this code and which GHC are you using?
11:57:22 <fragamus> The Glorious Glasgow Haskell Compilation System, version 7.6.3
11:57:31 <fragamus> but my cabal is ancient
11:57:35 <merijn> Bah, stripSuffix exists for Text, just not String/[a] :\
11:58:17 <merijn> fragamus: Exceptions changed (a while ago, but I dunno how old your code is)
11:58:36 <merijn> fragamus: So a module that *used* to export catch (I think System.Error or something) no longer does
11:58:55 <triliyn> merijn: reverse, stripPrefix, reverse again!
11:59:01 <fragamus> i am going to wipe my haskell platform
11:59:13 <triliyn> (That was initially supposed to be a joke but actually I'm not sure there's a better way to strip a suffix from a singly-linked list)
12:00:23 <merijn> triliyn: Pretty sure there is
12:01:16 <merijn> I can think of at least one that is only n+k (where n is list length, and k suffix length)
12:01:20 <jle`> i feel like this should be really simple, but how do i make an wire that fires an event at random intervals?  i could do it using became . noise, but i don't think that is clean...i think it has something to do with wackelkontakt
12:01:30 <merijn> reverse, strip, reverse is 2n+k at least
12:01:40 <triliyn> hmmm
12:01:56 <triliyn> I wonder if you can do asymptotically better?
12:02:43 * hackagebot zeromq4-haskell 0.2 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.2 (ToralfWittner)
12:04:05 <jle`> you can...use a fold to find the last non-whitespace
12:04:10 <jle`> the position of it
12:04:16 <jle`> and then take up til it?
12:04:39 <jle`> oh stripSuffix
12:07:44 * hackagebot mcpi 0.0.1.2 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.1.2 (DouglasBurke)
12:07:46 * hackagebot zip-archive 0.2.1 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.1 (JohnMacFarlane)
12:08:56 <bennofs> What do you think about this use of quickcheck: http://lpaste.net/99527
12:09:30 <merijn> I think this is the most efficient stripSuffix: http://lpaste.net/99528
12:10:07 <merijn> n+2k complexity
12:10:50 <merijn> Or is it 3k? Could be shorter if "drop (length needle)" was replaced by one that dropped while recursing over needle and input at the same time
12:10:57 <merijn> Then it'd be n+2k
12:12:19 <merijn> I guess it might overflow for large lists, though
12:12:45 * hackagebot cpphs 1.18 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18 (MalcolmWallace)
12:13:06 <merijn> If one uses "[a] -> [a] -> [a]" instead of the "[a] -> [a] -> Maybe [a]" by stripPrefix it's more efficient
12:13:09 <triliyn> Do people actually use giant lists like that? Except maybe for control flow
12:17:33 <merijn> triliyn: Dunno, but why break if you don't have to
12:17:50 <triliyn> merijn: yeah, of course
12:18:11 <triliyn> I was just wondering because I've seen people talking about obscenely large lists more often than I'd expect
12:18:12 <gspr> Roughly how expensive is it to take an (uncontested) MVar?
12:18:53 <merijn> gspr: I dunno in absolute time, but fairly cheap
12:19:10 <merijn> gspr: What are you thinking of?
12:20:06 <merijn> hmm, should I just roundtrip through Text to strip the suffix of a String?
12:20:50 <gspr> merijn: Well, I'm building a Pipes thing where one segment involves some FFI'ing to a C library. I will need to run the Pipe in a thread of its own *and* in other threads interact with said library, so I need locking.
12:21:21 <gspr> merijn: However, the main work will be in the pipes part, where the lock might be taken every 10 ms
12:21:41 <gspr> merijn: "other interaction" with the library will happen very very rarely, so the lock will almost always be uncontended
12:21:52 <codygman> I'm getting an error installing lens in a fresh sandbox: http://lpaste.net/99530
12:22:39 <merijn> gspr: I don't feel qualified to answer that
12:22:44 <edwardk> you may need to ping bos about that one, as anything in aeson itself is outside of my scope ;)
12:22:45 <gspr> merijn: OK :)
12:22:48 <merijn> gspr: You can always benchmark using criterion
12:23:35 <gspr> merijn: I did some non-serious benchmarking, wherein the locking version didn't increase the CPU usage of my program (as measured by staring at top)
12:24:03 <pavonia> Why do you need aeson to install lens? O.o
12:24:33 <edwardk> aeson moved into the platform. lens supports the platform, so lens 4 rolled in a version of lens-aeson
12:24:44 <edwardk> 'batteries included'
12:24:58 <pavonia> I see
12:25:13 <tomejaguar> Is that more maintainable than having a separate package?
12:25:14 <merijn> edwardk: Don't you mean "Abstraction-powered Death Machine"? :p
12:25:41 <edwardk> tomejaguar: my experience is yes, as it means i don't have to leave users fighting with orphans
12:25:54 <tomejaguar> Oh yeah, orphans.
12:26:17 <edwardk> tomejaguar: also there was a breaking change in the API of aeson, so the lens 3.10 + lens-aeson    -> lens 4 break was a way to address the change
12:26:19 <tomejaguar> The most important thing about an abstraction-powered death machine is that it is composable.
12:27:00 <tomejaguar> edwardk: Well I fully expect this is the decade where lens subsumes all of Haskell, so why not start now?
12:27:15 <edwardk> merijn: well, if lens is an abstraction-powered death machine, it is at least well powered, if somewhat less lethal than originally hoped.
12:27:25 <codygman> edwardk: You were telling me I should ping bos right? How would I best do that? The github issues page for aeson?
12:27:33 <edwardk> codygman: probably
12:27:43 <edwardk> never seen the problem before that you are having
12:33:46 <tomejaguar> codygman: It needs a Data instance for HashMap, which only seems to appear in 0.2.3.0, but aeson's dependency is only on 0.1.3.0.
12:34:33 <tomejaguar> IIRC there's some flag to cabal where you can force it to use a particular version of a package, but someone more knowledgeable here will have to tell you what that is.
12:35:13 <dcoutts> tomejaguar: --constraint="foo == 1.0"   or  --constraint="foo < 2"   or whatever
12:36:18 <merijn> I have another challenge for people that like to codegolf for excellence, how do I do this prettier: http://lpaste.net/8878674995518111744
12:36:58 <tomejaguar> dcoutts: Thanks.  Does that require a particular version of cabal?
12:37:20 <dcoutts> tomejaguar: anything non-archaic
12:37:31 <tomejaguar> OK great.
12:37:37 <dcoutts> so in practice, no
12:38:54 <tomejaguar> Does 0.14 count as archaic?
12:39:26 <merijn> tomejaguar: ouch, why are you still using 0.14?
12:39:39 <tomejaguar> Hmm, I think I've been asked that question before ... :)
12:40:03 <merijn> tomejaguar: You'll probably be asked again later too :p
12:40:09 <codygman> tomejaguar, dcoutts: Thanks, I'll try that.
12:40:11 <tomejaguar> :) I think you're right
12:40:34 <tomejaguar> The partial answer is that it's a special deployment of a more recent version than the default 0.8.2 that is installed on my client's system.
12:40:43 <tomejaguar> I'm also using GHC 7.4.
12:41:17 <tomejaguar> And I think basically no one can be bothered to change it.
12:42:25 <xintron> Is it good practice to only include the modules used or include the whole module?
12:43:01 <tomejaguar> xintron: Do you mean import only the names used?
12:43:07 <xintron> tomejaguar, yes
12:43:12 <merijn> It depends, I'd say
12:43:26 <xintron> so import Data.Text vs Data.Text (foo)
12:43:35 <merijn> I import only used names for rare/name clashing libraries
12:43:39 <tomejaguar> Personally I always import only the names used, because otherwise I get confused as to where things come from.
12:43:50 <merijn> For common stuff like "Control.Applicative" I just import everything
12:44:12 <tomejaguar> I hate reading code where I can't find the source of the identifier.
12:44:34 <Fuuzetsu> tomejaguar: load into GHCi and :i
12:44:52 <tomejaguar> Fuuzetsu: Sometimes it's code on the web, for example
12:44:59 <tomejaguar> Sometimes it's code that doesn't typecheck
12:45:18 <platz> does anyone use classy-prelude or basic-prelude ?
12:45:43 <merijn> platz: Not a lot of people, I expect
12:45:53 <platz> ahhh, good to know
12:47:30 <tomejaguar> codygman: Worth filing a bug on aeson if that suggested fix does actually get it to work.
12:54:22 <greg`> hi fellas,  during a cabal install im seeing Ambiguous module name 'Prelude'
12:54:49 <codygman> tomejaguar: Yeah, I'm finishing up the bug report now with the fix... and trying to see what the upper bound on dependency is. unordered-lists 0.2.3.3 had some sort of CPP ffi error.
12:54:56 <greg`> it was found in multiple packages: base haskell98-2.0.0.3
12:55:01 <greg`> h
12:55:08 <greg`> there is only one prelude surely
12:55:28 <merijn> greg`: Looks like it's trying to compile with the wrong haskell version?
12:55:34 <geekosaur> greg`, actually you'd be wrong, *but* that is a symptom of a package that is years out of date and unmaintained
12:55:52 <greg`> im trying to install haddock
12:55:55 <geekosaur> (ghc supports two different versions of the Haskell standard, plus a native mode)
12:55:58 <merijn> greg`: Eh
12:55:59 <greg`> is that really old?
12:55:59 <geekosaur> er
12:56:08 <merijn> greg`: Haddock should be installed when you install GHC
12:56:13 <geekosaur> you are trying to install an ancient version of haddock then
12:56:15 <merijn> greg`: You can't install Haddock on its own
12:56:18 <merijn> I think?
12:56:28 <geekosaur> and it should normaly come with ghc these days, because it was folded intot he compielr so it would get types right
12:56:31 <greg`> ah ok , im being a plum
12:58:58 <greg`> im getting a problem installing pointfree is that really old too?
13:00:23 <codygman> tomejaguar: It looks like something (unorderd-containers I think) depends on cpphs in my current situation but doesn't list it as a dependency.
13:01:38 <AlainODea> I'm working on fixing a bug in System.Posix.fileAccess. Where is eACCES defined? http://hackage.haskell.org/package/unix-2.7.0.0/docs/src/System-Posix-Files.html#access
13:03:27 <geekosaur> AlainODea, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Foreign-C-Error.html
13:03:40 <AlainODea> geekosaur: thank you :)
13:04:26 <tomejaguar> codygman: You found two bugs? :)
13:05:05 <codygman> tomejaguar: It seems I have... but I'm not sure where one of them is yet.
13:05:18 <tomejaguar> Nice
13:05:37 <tomejaguar> Improving the ecosystem two bugs at a time
13:06:30 <alaksdjf> Hi, is there a recommended Haskell library for accessing "basic" AES? I really just need access to the PRF (i.e., I give the function a key and a 128-bit message and it returns a block). I'm working around ECB mode in another package (this is just for a homework assignment), but that feels hacky.  I wanted to use (http://hackage.haskell.org/package/Crypto-4.2.0/docs/Codec-Encryption-AES.html), but it's using some crazy type construc
13:06:31 <alaksdjf> out of two 64-bit words, which I don't like dealing with (I'm using ByteStrings).
13:06:32 <fragamus> I am trying to burn my haskell platform to the ground. I need to get rid of cabal too. I am able to get rid of platform but cabal persists.
13:07:50 <merijn> There's no prettier way to do a double fmap than "(fmap.fmap) f foo" or "fmap f <$> foo", right?
13:08:01 <mm_freak_> does cereal encode type information?  i mean, if i try to decode a serialized Int into a Word, will it fail?
13:08:21 <merijn> mm_freak_: No
13:08:27 <mm_freak_> too bad
13:08:29 <merijn> mm_freak_: oh, wait
13:08:38 <merijn> mm_freak_: You mean the Serialise/Word instances?
13:08:44 <merijn> I'm not sure about those
13:08:52 <merijn> eh Serialize/Binary, whatever it's called
13:08:56 <mm_freak_> merijn: i mean Serialize in general
13:09:07 <merijn> I dunno, tbh, I mostly use the Get monad
13:09:12 <mm_freak_> but there is no Typeable constraint, so i guess not
13:09:27 <merijn> I don't really expect it to, though
13:09:36 <tekul> alaksdjf: Did you look at http://hackage.haskell.org/package/cipher-aes ?
13:10:22 <alaksdjf> tekul: Give me a second to look that over. There are a lot of crypto libraries, so it's hard to remember which is which.
13:10:40 <jophish> yo yo yo
13:12:07 <jophish> I'm using a RWST (transforming the Error monad) to do some work. I'd really like to send the writer's output into the reader for this monad. I know that tying the knot like this is possible with lazy monads, I'm not entirely sure about how to go about this though
13:13:37 <c_wraith> jophish: assuming you're not using the strict variant, it should be as easy as just tying the knot.  And then not accidentally introducing an infinite loop in the processing.
13:13:38 <enthropy> why don't you use the state instead?
13:13:40 <simpson> jophish: Why do you want that instead of just having more stuff in your State type?
13:13:46 <dhrosa> @pl update val (_:as, bs) = (val:as, bs)
13:13:46 <lambdabot> update = (`ap` snd) . (. fst) . (. tail) . ((,) .) . (:)
13:13:59 <dhrosa> that's terrble
13:14:13 <jophish> enthropy: simpson, I thought it would be neat to feed the writer into the reader
13:14:26 <mm_freak_> but yeah, i think i finally found a feasible way to serialize automata/wires
13:14:48 <c_wraith> :t first ((?val:) . tail)
13:14:49 <lambdabot> (?val::a) => ([a], d) -> ([a], d)
13:15:00 <c_wraith> dhrosa: ^
13:15:11 <dhrosa> :t (?)
13:15:12 <lambdabot> Not in scope: `?'
13:15:20 <dhrosa> what does the question mark do?
13:15:22 <merijn> dhrosa: ?x is implicit parameters extension
13:15:43 <jophish> I can get it done fine with RWS, but RWST is making things a little tricky
13:15:49 <merijn> dhrosa: You'd want to do "update val = first ((val:) . tail)"
13:15:59 <codygman> How could I clone the aeson repository locally and use it as the source for aeson after I edit the dependencies? I need to make sure my bugfix works.
13:16:18 <c_wraith> I wouldn't really write it that way, though
13:16:35 <merijn> codygman: Just 'cd' into your check out and run "cabal build"/"cabal install" there without arguments
13:16:40 <enthropy> > ("abc", True) & _1 . ix 0 .~ 'x'
13:16:42 <c_wraith> it relies an an irrefutable pattern match, which I don't like to do in real code.
13:16:42 <lambdabot>  ("xbc",True)
13:16:48 <mm_freak_> so yeah…  next improvement:  savegames for free =)
13:16:57 <codygman> merijn: does that work automatically with cabal sandbox?
13:17:03 <jle`> mm_freak_: :D
13:17:20 <c_wraith> the lens version, on the other hand, is probably good.
13:17:35 <enthropy> > ("", True) & _1 . ix 0 .~ 'x'
13:17:37 <lambdabot>  ("",True)
13:17:44 <enthropy> > ("", True) & _1 . at 0 .~ Just 'x'
13:17:45 <lambdabot>  No instance for (Control.Lens.At.At [GHC.Types.Char])
13:17:45 <lambdabot>    arising from a use of `Control.Lens.At.at'
13:17:45 <lambdabot>  Possible fix:
13:17:45 <lambdabot>    add an instance declaration for
13:17:45 <lambdabot>    (Control.Lens.At.At [GHC.Types.Char])
13:18:15 <enthropy> hmm, works for Maps, not sure if that instance is missing on purpose?
13:18:33 <c_wraith> enthropy: doesn't really make sense for that instance to exist.  If you reference location 500, do you want it to create 499 cells when passed an empty list?
13:18:43 <enthropy> yes and fill them with undefined
13:18:52 <c_wraith> that doesn't sound safe
13:18:54 <enthropy> or maybe mempty
13:19:34 <jle`> mm_freak_: on an unrelated note, is there a good way to make a wire that emits an event randomly?  i feel like emitRandomly g = now . stdWackelkontakt g --> emitRandomly (g+1) is not too clean
13:19:58 <jrmithdobbs> hrm, is there a valid monoid definition for Free
13:20:19 <bergey> codygman: `cabal install <path>` from the directory where you created your sandbox, where <path> is the path to your aeson.
13:21:18 <mm_freak_> jle`: what would be a clean way?
13:21:18 <alaksdjf> tekul: Eh, encryptECB there works just like the other libraries that provide ECB access, but I suppose that's not a problem. It doesn't hurt anything to have a primtive in my assignment that can handle more than 16 bytes, so this works. I just wondered if there was a lower-level interface to AES that was easier to use. It really doesn't matter at all in the grand scheme. Thanks for the help.
13:23:23 <jle`> mm_freak_: maybe someothing without explicit seed progression?  also it loops needlessly if wackelkontakt is initially inhibiting
13:23:54 <codygman> bergey: Thanks!
13:25:39 <mm_freak_> jle`: well, you can't really have this kind of randomness in a pure setting
13:26:29 <mm_freak_> jle`: if you followed an earlier discussion, i'm developing a game right now, mainly to experiment with a number of technologies, including wires
13:27:01 <jle`> hm
13:27:06 <madjestic> mm_freak_: which frp library did you try?
13:27:12 <mm_freak_> jle`: it is almost certain that the next Wire will not include m anymore
13:27:19 <mm_freak_> madjestic: i'm the author of netwire
13:27:27 <jle`> okay, i guess i can accept this because this is only a testing function
13:27:41 <beeepbooop_> test?
13:27:49 <jle`> so i can be as ugly as i want i guess heh.
13:27:52 <mm_freak_> jle`: you should accept it for real projects as well =)
13:28:06 <roboguy_> jrmithdobbs: maybe you could have something like instance (Monoid a, Monoid (f (Free f a))) => Monoid (Free f a)
13:28:12 <jle`> mm_freak_: accept the ugliness?
13:28:26 <madjestic> mm_freak_: i cee.  Is it worth asking what do you think of netwire as in relation too, say, reactive banana?  I am about to dive into the world of frp so it is a practical question for me.
13:28:46 <merijn> madjestic: They have very different goals, imo
13:29:09 <mm_freak_> jle`: no, accept the purity…  there is probably a way without carrying generators around
13:29:22 <madjestic> merijn: which are..?
13:29:25 <mm_freak_> jle`: but i'm not yet at a point where i need randomness, so i will tackle this later =)
13:29:36 <mm_freak_> madjestic: what kind of application do you want to write?
13:29:49 <madjestic> a game
13:29:54 <jle`> mm_freak_: ah. well i am one step closer on my walk to enlightenment
13:30:10 <mm_freak_> madjestic: real time game or rather something like a board game?
13:30:33 <sccrstud92> mm_freak_: u wrote netwire?
13:30:39 <merijn> madjestic: reactive banana is designed to play nice with IO/callback based existing libraries/frameworks
13:30:44 <mm_freak_> sccrstud92: as said =)
13:31:03 <merijn> madjestic: netwire is more aimed at using FRP to describe your own application logic
13:31:07 <sccrstud92> mm_freak_: just wanted to confirm i wasn't missing something since i just got here.
13:31:20 <madjestic> mm_freak_: I would prefer to have flexiblity.  Are those exclusive?
13:31:22 <jrmithdobbs> roboguy_: i was thinking more along the lines of xs <> ys = (fmap Free xs) >> (fmap Free ys)
13:31:25 <sccrstud92> mm_freak_: i as working on a tic tac toe game with it
13:31:30 <sccrstud92> its pretty cool
13:31:39 <sccrstud92> probably gonna try something realtime next
13:31:44 <jrmithdobbs> roboguy_: as in, a monoid instance in terms of free not a monoid instance for a free that contains a monoid
13:32:16 <mm_freak_> madjestic: reactive-banana, as merijn said, is made for interfacing with toolkit libraries based on event handlers…  when you want to write a GTK/wx application or perhaps a stateful network application, it's great for that
13:32:21 <jrmithdobbs> roboguy_: my head hurts a bit with the circular thinking required to form that sentence, ha
13:32:21 <sccrstud92> mm_freak_: do you prefer arrow style or applicative style?
13:32:38 <roboguy_> jrmithdobbs: hmm, what would mempty be?
13:32:42 <mm_freak_> madjestic: other applications are rather frame-based, most notably real-time games and simulations…  in this case netwire is the framework of choice
13:32:45 <jrmithdobbs> roboguy_: Pure ()
13:33:29 <mm_freak_> madjestic: and no, the choice is not exclusive…  if you're writing a board game, you can express the UI in terms of reactive-banana and the animations in terms of netwire =)
13:33:34 <mm_freak_> they are easy to combine
13:33:46 <mm_freak_> sccrstud92: depends
13:34:24 <madjestic> mm_freak_: interesting. That's a good summary.  Is there a reason for not using netwire for GUI?
13:34:25 <sccrstud92> mm_freak_: it is possible to write an ArrowApply instance for Wire?
13:34:31 <jrmithdobbs> i mean, that seems, intuitively, valid, i mean a free monad is by definition a free monoid in functor right? ...
13:34:34 <mm_freak_> sccrstud92: no
13:34:39 <jrmithdobbs> not sure how correct my usage is there
13:34:45 <ziggystar> Hi. I tried to import Data.Function.Memoize, but it's not there. I installed ghc in Ubuntu (though 12.04). Is it a new package and therefore not installed?
13:34:57 <sccrstud92> mm_freak_: okay good. cuz i couldnt do it lol
13:35:13 <sccrstud92> mm_freak_: and I figured it would be in there if it was possible
13:35:24 <mm_freak_> madjestic: yes…  netwire is AFRP, which means that behaviors and events are wire-bound
13:35:34 <roboguy_> jrmithdobbs: then all the data must be stored in the layers, right?
13:35:52 <mm_freak_> madjestic: a Behavior can leave the Moment monad in reactive-banana, which is desirable for the kind of applications you would write with it
13:35:53 <jrmithdobbs> roboguy_: yes
13:36:11 <merijn> ziggystar: Which library is that from?
13:36:14 <mm_freak_> sccrstud92: it is possible in a special case
13:36:20 <mm_freak_> sccrstud92: when 'm' is a comonad
13:36:46 <mm_freak_> however, even then it is completely useless, because it eats more time and memory the more frames pass
13:36:54 <ziggystar> @merjin I'm new to Haskell. So the modules are grouped in libraries? I have no idea. I used online Hoogle to find it.
13:36:54 <lambdabot> Unknown command, try @list
13:37:06 <madjestic> mm_freak_: in a summary: it is worth learning both?
13:37:06 <dhrosa> ziggystar: that module is in the memoize package, which you probably don't h ave installed
13:37:41 <mm_freak_> madjestic: yes, definitely
13:37:50 <mm_freak_> madjestic: start with reactive-banana and write a little GUI
13:37:55 <ziggystar> @dhrosa I found some haskell related Ubuntu packages mentioning memoization. I'll try those.
13:37:55 <lambdabot> Unknown command, try @list
13:37:57 <ziggystar> Thank you.
13:38:00 <mm_freak_> it is a lot easier to get into
13:38:18 <dhrosa> ziggystar: I would reccomend using cabal to install haskell packages, there's more availability and the packages are newer
13:38:28 <sccrstud92> mm_freak_: for turn based games, does using pure () for the session make sense?
13:38:36 <dhrosa> ziggystar: cabal install memoize
13:38:41 <AlainODea> ziggystar: you are much better off using cabal install on Ubuntu. apt-get install haskell-platform and then use cabal install to get packages.
13:38:46 <mm_freak_> sccrstud92: if you don't need time, yes
13:38:49 <ziggystar> @dhrosa Ok, I'll try that first.
13:38:49 <lambdabot> Unknown command, try @list
13:39:02 <madjestic> mm_freak_, merijn thanks
13:39:12 <greg`> >/join #ghc
13:39:21 <ziggystar> Oh, It's also much quicker than Ubuntu package installation. :)
13:39:34 <mm_freak_> sccrstud92: basically it will disable all timing-based wires, including 'time' itself and all integral wires
13:39:42 <ziggystar> Seems like my problem is fixed now. Thank you.
13:39:59 <sccrstud92> mm_freak_: thats what i gathered from looking at the implementation
13:40:28 <sccrstud92> worked pretty well for tic tac toe
13:40:37 <mm_freak_> =)
13:40:42 <mm_freak_> did you use netwire 5?
13:40:59 <sccrstud92> i used whatever was the newest version about a month ago
13:41:10 <mm_freak_> so 5
13:41:15 <AlainODea> ziggystar: throw this in .profile and .bashrc so cabal installed commands will also work. PATH=$HOME/.cabal/bin:$PATH
13:41:24 <uniquenick> if I want to hold a db connection in some sort of exclusive "only one thread can have this at a time" container, what am I looking for?
13:41:29 <sccrstud92> are there big differences between 5 and the previous version(s)?
13:41:40 <mm_freak_> uniquenick: MVar
13:41:51 <tac> sccrstud92: I beg your pardon
13:41:59 <sccrstud92> tac: lol
13:42:11 <mm_freak_> uniquenick: take when using, put back when finished…  be sure to use 'bracket' for taking and putting
13:42:17 <sccrstud92> tac: where are tic and toe
13:42:49 <mm_freak_> uniquenick: withDB = bracket (takeMVar dbVar) (putMVar dbVar)
13:43:24 <mm_freak_> sccrstud92: fundamentally no
13:43:39 <tac> sccrstud92: They are into Ruby and Scala respectively.
13:43:57 <sccrstud92> tac: well then i guess u win the cool contest
13:44:02 <mm_freak_> sccrstud92: it is very likely that there will be no version 6, because i'm working on a new and much simpler abstraction right now that has some distinct advantages
13:44:36 <sccrstud92> mm_freak_: sounds very cool. i will be interested to see it. does it have a name?
13:44:58 <mm_freak_> sccrstud92: it's still Wire, but has only two arguments
13:45:00 <mm_freak_> Wire a b, done
13:45:37 <sccrstud92> mm_freak_: what about monadic effects?
13:45:43 <mm_freak_> sccrstud92: they're gone
13:46:02 <sccrstud92> mm_freak_: is this new Wire less powerful?
13:46:12 <mm_freak_> yes and no
13:46:18 <beeepbooop_> maybe
13:46:23 <sccrstud92> Maybe*
13:46:26 <mm_freak_> yes, because you don't get monadic effects
13:46:48 <beeepbooop_> it depends
13:46:52 <mm_freak_> no, because you get a few new features, including free savegames (since today) =)
13:47:06 <sccrstud92> you have anything on hackage?
13:47:10 <mm_freak_> not yet
13:47:12 <piezoid> mm_freak_: so how do you get time ? at the "interpretation step" ?
13:47:36 <mm_freak_> piezoid: i'm back to using Double for time
13:47:47 <beeepbooop_> dont use double
13:47:52 <sccrstud92> no more nimaldifftime?
13:47:57 <sccrstud92> nominaldifftime*
13:47:59 <jle`> so the whole parameterized time thing was a phase? :P
13:48:06 <beeepbooop_> yes
13:48:18 <schell> is this netwire or a different thing altogether?
13:48:28 <mm_freak_> sccrstud92: you wouldn't want to do anything with NominalDiffTime other than convert it to Double anyway =)
13:48:35 <mm_freak_> schell: something different
13:48:47 * schell is checking hackage
13:48:49 <codygman> edwardk: lens uses cpphs right? Ever seen an error in a cabal sandbox where it isn't detected? That seemed to be the second bug I found.
13:48:54 <sccrstud92> mm_freak_: haha i didnt even get that far since i only used the empty session
13:49:07 <mm_freak_> jle`: i've got a request to make the time type polymorphic
13:49:13 <mm_freak_> so it became 's'
13:49:14 <edwardk> codygman: we just updated HEAD not to need it
13:49:40 <edwardk> codygman: can probably shove it out to hackage soon
13:49:40 <sccrstud92> schell: he said its not on hackage yet
13:49:49 <schell> ah - missed that
13:49:54 <sccrstud92> np
13:50:03 <sccrstud92> mm_freak_: do they still inhibit?
13:50:10 <mm_freak_> sccrstud92: sure
13:50:18 <mm_freak_> but 'e' is gone
13:50:40 <sccrstud92> do they have a monomorphic inhibit type then?
13:50:46 <mm_freak_> yeah
13:50:50 <mm_freak_> Either e a became Maybe a
13:50:51 <sccrstud92> unit?
13:50:54 <sccrstud92> ah
13:50:59 <sccrstud92> that helps
13:51:02 <sccrstud92> simplify
13:51:26 <sccrstud92> i found myself having trouble choosing how much logic to embed into wire inhibition
13:51:34 <mm_freak_> it's a lot easier to understand, easier to work with and orders of magnitude faster =)
13:52:10 <codygman> edwardk: Oh alright, was just wondering whether to submit a bug report or not.
13:52:21 <sccrstud92> is there something that "replaces" monadic effects?
13:52:46 <mm_freak_> sccrstud92: yes, the producer of the input value and the user of the output value
13:53:01 <mm_freak_> sccrstud92: the only sensible monads were Readers and Writers
13:53:08 <edwardk> codygman: let me finish up what i'm hacking on and ship out the update to hackage
13:53:16 <mm_freak_> and you don't really need them
13:53:20 <sccrstud92> by "were" u mean in netwire 5?
13:53:27 <mm_freak_> uh, yeah
13:53:47 <sccrstud92> i was using IO as the base monad
13:54:01 <sccrstud92> or it was polymorphic
13:54:22 <sccrstud92> is the code on github?
13:54:31 <mm_freak_> sccrstud92: which is wrong…  the problem with the monad is that you can easily violate FRP, if you want to
13:55:13 <sccrstud92> mm_freak_: i probably decimated it
13:57:44 <sccrstud92> mm_freak_: is there a name for this new library? or is it sitll gonna be called netwire?
13:58:08 <mm_freak_> sccrstud92: right now i'm just calling it 'wires'
13:58:11 <jle`> i keep on getting thread blocked indefinitely on MVar even after adding a hundred delay's T.T i wonder what's going on
13:58:31 <jle`> i never really understood where those came from and how they are different from <<loop>>
13:58:48 <mm_freak_> jle`: you're taking an MVar you're never putting to
13:59:02 <jle`> mm_freak_: when does netwire take from MVars?
13:59:06 <c_wraith> jle`: it happens when there are no threads available to read from or write to (whatever would unblock) the MVar a thread is waiting on.
13:59:12 <mm_freak_> jle`: try this:  main = newEmptyMVar >>= takeMVar
13:59:22 <merijn> Is there something like Data.List.Split which returns a tuple, rather than a list of lists?
13:59:23 <mm_freak_> jle`: huh?  netwire doesn't
13:59:40 <jle`> mm_freak_: hm. i'm getting it from netwire. perhaps it is in the graphics backend i'm using
13:59:42 <sccrstud92> merijin: partition?
13:59:49 <mm_freak_> jle`: more likely, yeah
13:59:49 <merijn> :t partition
13:59:50 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
13:59:59 <jle`> but it only happens under certain wires. how odd
14:00:03 <jle`> well time to dig into this
14:00:15 <mm_freak_> jle`: do you have IO in your monad stack?
14:00:15 <sccrstud92> merijin: is that what your looking for?
14:00:18 <merijn> sccrstud92: That'd work if it used a sequence as a splitting criteria, instead of an individual element
14:00:22 <jle`> mm_freak_: i do
14:00:28 <sccrstud92> what are you splitting on?
14:00:37 <jle`> not for any real reason
14:00:40 <jle`> i didn't know what else to put there heh
14:00:46 <mm_freak_> jle`: Identity
14:00:52 <jle`> oh that is probably a better idea.
14:01:02 <jle`> heh
14:01:12 <sccrstud92> what should happen if the sequence occurs more than one time in the list?
14:01:33 <merijn> And "isInfixOf" returns a boolean, instead of an index :\
14:01:36 <mm_freak_> merijn: splitAt?
14:01:41 <merijn> sccrstud92: Further occurences are irrelevant
14:01:46 <merijn> :t splitAt
14:01:46 <lambdabot> Int -> [a] -> ([a], [a])
14:01:55 <merijn> mm_freak_: If I knew how to find the Int, that'd work
14:01:55 <mm_freak_> merijn: or 'break'
14:01:56 <sccrstud92> so something like
14:02:06 <mm_freak_> (or 'span')
14:02:08 <merijn> mm_freak_: But there's no way to find the index of a sequence :\
14:02:18 <mm_freak_> merijn: what's the application?
14:02:35 <sccrstud92> (x:xs) = split....
14:02:36 <enthropy> @where revdeps
14:02:36 <lambdabot> http://packdeps.haskellers.com/reverse
14:02:44 <sccrstud92> tup = (x, concat xs)
14:02:53 <merijn> mm_freak_: I have [Char] and want to split at the first occurence of another Char sequence
14:03:05 <mm_freak_> merijn: "another"?
14:03:27 <sccrstud92> he wants to split at the index of the first substring
14:03:48 <merijn> mm_freak_: i.e. 'split "xx" "abcxxdef"' -> ("abc", "def")
14:03:49 <mm_freak_> so you want 'break' for infixes instead of individual elements
14:04:03 <sccrstud92> :t break
14:04:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
14:04:05 <mm_freak_> merijn: use Text instead of String then
14:04:15 <merijn> mm_freak_: Yes, Data.List.Split does that, but only returns [[Char]] instead of ([Char], [Char])
14:04:27 <merijn> mm_freak_: That means I have to roundtrip everything just for this function :\
14:04:38 <mm_freak_> merijn: Data.Text.breakOn
14:04:46 <merijn> mm_freak_: The rest of Hakyll uses String everywhere (unfortunately)
14:04:59 <mm_freak_> merijn: then pack and unpack
14:04:59 <jle`> mm_freak_: oh yeah, i was using it because countSession_ required a MonadIO for some reason i did not understand
14:05:23 <mm_freak_> jle`: the MonadIO countSession_ requires is not the same as the wire's underlying monad
14:05:56 <sccrstud92> merijin: whats wrong with taking the head of the result of split and concatting the tail of the same result?
14:06:20 <mm_freak_> jle`: see the type signature of 'testWireM' to understand the relationship
14:06:29 <mm_freak_> it's in Control.Wire.Run
14:06:41 <jle`> mm_freak_: i get a type error saying that it can't instance MonadIO with whatever underlying monad, hm. i'l read over that
14:06:41 <colDrMcBeardman> i have a big svg file and i need to surround certain swaths of it with <a>. I hate XML and am totally lost. Can anyone give me some pointers?
14:07:19 <mm_freak_> jle`: your application runs in some monad, i'll just assume IO, and your wire's underlying monad is 'm'
14:07:20 <hpc> colDrMcBeardman: open it in a browser, press f12
14:07:26 <merijn> sccrstud92: I was jut hoping there'd be a more efficient solution than that
14:07:31 <mm_freak_> jle`: the only requirement is that there is a natural transformation from 'm' to IO
14:07:42 <hpc> if you need to do it programatically, i hate XML too ;)
14:07:54 <sccrstud92> merijin: efficient in what sense?
14:07:58 * hackagebot Wheb 0.0.1.0 - The easy Haskell WAI Framework  http://hackage.haskell.org/package/Wheb-0.0.1.0 (hansonkd)
14:08:07 <mm_freak_> jle`: if you're writing your own framework you can relax that requirement, but that's the basic idea
14:08:45 <merijn> sccrstud92: In sense of me not having to write a lot of silly wrapper functions :)
14:09:09 <colDrMcBeardman> hpc, yeah, i'm fairly familiar now with the document's structure, but not so sure how to do what i'm up to with hexpat.
14:09:11 <mm_freak_> merijn: asText f = T.unpack . f . T.pack
14:09:12 <mm_freak_> ;)
14:09:24 <brainsturgeon> Hello. Is there an official torrent for the platform binaries? The download at haskell.org is rather slow. I'm on Windows.
14:09:25 <colDrMcBeardman> (or anything else, picked hexpat because it's performance-oriented)
14:09:50 <brainsturgeon> I mean the Haskell Platform.
14:10:44 <hpc> brainsturgeon: there used to be one 3 years ago apparently
14:10:49 <hpc> http://www.reddit.com/r/haskell/comments/bhl35/torrents_for_haskell_platform_now_available/
14:11:14 <hpc> the links in the comments aren't going anywhere useful though :(
14:11:40 <mm_freak_> also a torrent from three years ago may be slightly outdated =)
14:12:01 <hpc> just a wee bit
14:12:42 <hpc> you're only missing GADTs, constraint kinds, type families, data kinds
14:12:57 <hpc> wait no, 2010 was 4 years ago
14:12:59 <greedo> twtr fails
14:12:59 <hpc> time flies
14:13:00 <merijn> mm_freak_: Or this beauty: "join (***) unpack . breakOn "\n-- more --\n" . pack" :p
14:13:04 <brainsturgeon> hpc: Yeah I saw that when Googling for it, pretty outdated.
14:13:13 <greedo> huge surprise
14:13:52 <jle`> mm_freak_: thanks, that turned my MVar block into a <<loop>>, which makes slightly more sense
14:14:53 <mm_freak_> jle`: it may be a value recursion issue
14:16:05 <mm_freak_> :t join (***) (undefined :: Char -> Int)
14:16:05 <lambdabot> (Char, Char) -> (Int, Int)
14:16:38 <jle`> mm_freak_: these usually go away with throwing in a delay here and there...the idea is that you need a base case to start the chain, right?
14:16:54 <jle`> *usually have gone away
14:17:45 <mm_freak_> jle`: you need to work with the "depends" annotations in the documentation
14:18:53 <maurer> Anyone know a function that renders a ByteString as a hex string?
14:18:59 <maurer> Hoogle isn't giving me anything obvious
14:19:32 <shachaf> :: ByteString -> String?
14:19:46 <maurer> shachaf: Ideally yes
14:20:13 <shachaf> :t concatMap (printf "%02x") . BS.unpack
14:20:14 <lambdabot> IsChar b => BSC.ByteString -> [b]
14:20:19 <shachaf> You could do something like that.
14:20:26 <maurer> Yeah, I probably will
14:20:31 <maurer> I just thought it might be a function already
14:20:54 <jle`> mm_freak_: is there a guide for working through that?
14:21:14 <mm_freak_> jle`: if a wire's documentation says "depends: now", then you can't give it its own output, neither directly nor indirectly, without delay
14:21:21 <sccrstud92> :t showInt
14:21:22 <lambdabot> Integral a => a -> ShowS
14:22:01 <adelbertc> is there something that is [a] -> [(a, a)] where [1,2,3,4] = [(1, 2), (2, 3), (3,4)]
14:22:24 <shachaf> zip xs (tail xs)
14:22:41 <adelbertc> > zip [1,2,3] (tail [1, 2, 3])
14:22:42 <lambdabot>  [(1,2),(2,3)]
14:22:47 <shachaf> Oh, hmm.
14:22:52 <jle`> mm_freak_: ah. i think i got it, thanks
14:22:55 <adelbertc> shachaf - seems to work
14:23:10 <mm_freak_> > zip [] undefined
14:23:11 <lambdabot>  []
14:23:17 <mm_freak_> lucky ;)
14:24:48 <codygman> tomejaguar: lol: https://github.com/bos/aeson/pull/183/files
14:25:01 <adelbertc> is there safeHead/safeTail? or [a] -> Maybe (a, [a])
14:25:09 <adelbertc> seems like there's uncons for Stream and stuff, but not list
14:25:49 <jle`> adelbertc: you can use listToMaybe, and then drop 1
14:25:58 <adelbertc> jle` - ah listToMaybe
14:26:03 <adelbertc> bit of a weird name, but looks like what i want
14:26:42 <jle`> adelbertc: well...you can think of Maybe as a special-case list with either 0 or 1 element
14:26:47 <jle`> but yeah it's not exactly a name you'd search for
14:28:00 * hackagebot inserts 0.1.1 - Stupid simple bytestring templates.  http://hackage.haskell.org/package/inserts-0.1.1 (JosephAbrahamson)
14:28:50 <adelbertc> jle` - cheers
14:31:29 <briennetheblue> how do i open a file (for writing) only if it doesn't already exist?
14:31:37 <ij> Being able to define expression's type as "(->) a b" instead of "a -> b" confuses me. Because it looks like "somedatatype a b", which feels completely different.
14:32:01 <johnw> briennetheblue: in C there is a mode for O_CREAT that will give an error if the file is already there, I believe
14:32:10 <johnw> there should be some equivalent for Haskell...
14:32:21 <johnw> maybe in the unix package
14:33:12 <sccrstud92> johnw: hey
14:33:17 <johnw> sccrstud92: hi
14:33:18 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-IO.html#t:OpenFileFlags
14:33:22 <briennetheblue> johnw: that's the behaviour i want, i'll look around a little more
14:33:34 <sccrstud92> i rewrote the counting sort with pipes and it worked
14:33:39 <briennetheblue> geekosaur: thanks
14:33:46 <sccrstud92> dont tell snoyman i used pipes =P
14:33:51 <johnw> sccrstud92: haha
14:33:56 <ij> What does function application mean?
14:33:57 <johnw> sccrstud92: why did you choose pipes, if I may ask?
14:34:06 <johnw> ij: calling a function, basically
14:34:06 <codygman> sccrstud92: You conduit
14:34:08 <sccrstud92> i wanted to learn pipes
14:34:16 <jle`> ij: (->) is a function that takes two types and returns a new type
14:34:24 <sccrstud92> conduit was designed for yesod specifically
14:34:27 <jle`> so (->) is kind of like a Type constructor with two arguments
14:34:32 <sccrstud92> pipes seems very general to me
14:34:44 <jle`> so like, Just is a data constructor that takes one argument
14:34:47 <johnw> conduit is not designed for yesod
14:34:51 <sccrstud92> granted i havent looked a lot into conduit because i did pipes instead
14:34:52 <johnw> it is just as general
14:34:57 <jle`> (the argument being a data thing)
14:35:05 <jle`> Maybe is a type constructor that takes one type
14:35:11 <sccrstud92> wasnt conduit created for the yesod framework?
14:35:24 <johnw> i doubt it, it is was probably created for persistent if anything
14:35:28 <johnw> but nowadays it is completely standalone
14:36:05 <jrmithdobbs> how to tell you're having too much fun and should probably get back to work: Occurs check: cannot construct the infinite type:
14:36:23 <sccrstud92> regardless, i wanted to learn pipes
14:36:40 <sccrstud92> if i learn conduit and some point i would be able to say which one i like better
14:36:41 <levi> I'm pretty sure you can still go back and read the blog entries describing the motivations for creating Conduit, Pipes, etc.
14:36:52 <johnw> sure, and now you know conduit more or less :)  they are super similar
14:36:57 <mm_freak_> in the long run pipes will probably replace conduit
14:36:58 <sccrstud92> the example u showed me was in conduit
14:37:05 <johnw> mm_freak_: I really doubt that nowadays
14:37:08 <sccrstud92> and i wanted to make sure i understood what was happeneing
14:37:14 <mm_freak_> johnw: why?
14:37:22 <sccrstud92> since i had an example in conduit i might be tempted to copy-paste
14:37:32 <levi> There's also the Iteratee libraries, io-streams, Machines, etc.
14:37:36 <johnw> Tekmo just doesn't care as much about prompt finalization, and that is one of snoyberg's most important design points for conduit
14:37:49 <jrmithdobbs> mm_freak_: because pipes can be defined in terms of conduit but not vice versa atm i thought?
14:37:55 <sccrstud92> its not that he doesnt care, i think its that its hard
14:37:59 <ij> jle`, But to denote going from one type to another with application, we use -> again.
14:38:02 <mm_freak_> johnw: your information may be a bit out of date =)
14:38:13 <ij> It really frustrates me.
14:38:27 <johnw> mm_freak_: really?  the very last blog post from Tekmo that I read about pipes indicated as such; please point me to new information
14:38:42 <sccrstud92> Tekmo = Gabriel, correct?
14:38:45 <johnw> yes
14:38:51 <platz> are haskell's iteratees like scala's iteratees ?
14:39:07 <sccrstud92> i am interested in machines also
14:39:10 <mm_freak_> johnw: SafeIO is pretty much ResourceT in disguise
14:39:24 <mm_freak_> and pipes-parse terminates ASAP
14:39:29 <johnw> it's not just about ResourceT, btw
14:39:31 <sccrstud92> i havent looked at them though because read that edk was still working on them
14:39:41 <johnw> ResourceT releases resources consumed by the *entire* pipeline
14:39:51 <levi> platz: I think Scala's were based on the Haskell ones, or at least on the same stuff from Oleg.
14:39:55 <johnw> conduit is about to free resources used by segments of the pipeline the instant that segment is completed
14:40:16 <johnw> also, there is the matter of leftovers
14:40:27 <johnw> anyway, this has all been debated ad nauseum before, I'm not adding anything new
14:40:33 <sccrstud92> what have a done...
14:40:41 <mm_freak_> johnw: ResourceT has resource regions with finalization spots, just like SafeIO…  if a producer reaches its end, it releases, otherwise SafeIO does
14:40:43 <johnw> it mostly comes down to a matter of categorical purity vs. convenience
14:41:13 <x77686d> Does the Haskell community have a term like "Pythonic", meaning to best exemplify proper form?
14:41:25 <mm_freak_> to be honest, i don't find conduit more convenient…  the only remaining selling point for conduit is the number of libraries
14:41:27 <sccrstud92> Haskellian?
14:41:29 <startling> "elegant", maybe.
14:41:29 <ij> jle`, So I by application I push the applicated value into the leftmost arbitrary value, would I be right if I said so?
14:41:31 <startling> "nice".
14:41:33 <sccrstud92> idiomatic
14:41:35 <platz> levi: cool, they looked interesting, apparently they can model the 'back-pressure' that a straight-up pull model (reactive extensions) isn't very good at
14:41:58 <levi> x77686d: It's not nearly as coherent in style as the Python community is.
14:42:13 <beeepbooop_> no not at all
14:42:13 <platz> but it was harder to see at a glance what was going on with the composition between producer and consumer
14:42:36 <mm_freak_> johnw: also conduit still has this strict pipeline approach, while pipes has moved on:  count (lines stdin)
14:42:38 <platz> err, pull=push
14:42:55 <mm_freak_> i can't imagine anything more convenient and elegant
14:43:03 <levi> platz: Most of the recent libraries were created to address difficulties in using Iteratees.
14:43:14 <mm_freak_> it's like applying list functions, except you get the full power of stream processing
14:43:31 <dmj> how would I write this point free?
14:43:35 <dmj> printell msg = sequence_ [tell msg, prnt msg]
14:43:44 <platz> levi: recent iteratee libraries or non-iteratee libraries?
14:43:47 <sccrstud92> @pl printell msg = sequence_ [tell msg, prnt msg]
14:43:47 <lambdabot> printell = sequence_ . liftM2 (:) tell (return . prnt)
14:44:11 <levi> platz: I mean things like Conduit, Pipes, etc. They were created in reaction to Iteratee libraries.
14:44:17 <sccrstud92> dmj: u can use @pl like so
14:44:19 <platz> ahh, thanks
14:44:34 <sccrstud92> i believe it means "pointless" so u dont forget
14:44:39 <johnw> dmj: what happen to your backtick??  I barely recognized you
14:44:45 <mm_freak_> nowadays pipes is 'iteratees done right'
14:44:57 <sccrstud92> johnw: he made a grave mistake chaning his nick
14:45:01 <johnw> mm_freak_: except for the fact that some people don't agree :)
14:45:17 <mm_freak_> johnw: some = snoyman =)
14:45:19 <x77686d> Interesting Google results re Haskellian :)
14:45:24 <johnw> i don't agree either
14:45:33 <dmj> johnw! yea, I dunno! Decided to not be infix today :)
14:45:59 <dmj> sccrstud92: thats cool, but the point free version is much longer :(
14:46:12 <sccrstud92> yup
14:46:16 <sccrstud92> sometimes its not worth
14:46:24 <dmj> prntell msg = prnt msg >> tell msg would even be better
14:46:48 <sccrstud92> @pl prntell msg = prnt msg >> tell msg would even be better
14:46:48 <lambdabot> prntell = liftM2 (>>) prnt (flip (flip (flip (flip tell would) even) be) better)
14:46:52 <mm_freak_> johnw: which problem doesn't it solve then?  it gets leftovers right, it gets finalization right, it's not eager, even if you use stream splitters and such…  what's the disadvantage?
14:46:55 <sccrstud92> oops lol
14:47:10 <johnw> mm_freak_: sorry, I don't have time to repeat the whole debate now, I shouldn't have brought it up
14:47:10 <sccrstud92> @pl prntell msg = prnt msg >> tell msg
14:47:10 <lambdabot> prntell = liftM2 (>>) prnt tell
14:47:12 <Adeon> flip those lambdas
14:47:20 <mm_freak_> johnw: but i'm interested
14:47:27 <sccrstud92> johnw: it was my fault
14:47:34 <merijn> mm_freak_: Snoyman thinks the finalisation should be more immediate, I believe
14:47:40 <merijn> mm_freak_: Not sure about the details
14:47:49 <merijn> mm_freak_: I believe there's several blog posts on the issue
14:47:57 <mm_freak_> merijn: i'm not sure how you can get more immediate than as-soon-as-possible
14:48:07 <Adeon> how would I know which blog post to trust
14:48:11 <johnw> if people want to use pipes, have at it; I'm much more eager to see some real world production code using it, rather than argue theoretical points.  I'm quite happy to see the best solution survive, and if pipes is that, I want to know, but I also want to see some experiential data
14:48:16 <gspr> Since you're having this discussion - can somebody recommend somewhere to read about terminating and cleaning up pipes? I'm having a bit of trouble getting it right.
14:48:20 <merijn> mm_freak_: Pretty sure Tekmo believes conduit behaviour is wrong
14:48:41 <mm_freak_> johnw: this is not theoretical…  i have processed terabytes of data with pipes, commercially
14:48:50 <dmj> @pl prntell msg = prnt msg >> tell msg
14:48:50 <lambdabot> prntell = liftM2 (>>) prnt tell
14:49:00 <mm_freak_> johnw: with all the fancy features, networking, many open files, etc.
14:49:06 <johnw> mm_freak_: nice, that's a good data point
14:49:07 <gspr> (What I just said is *not* an entry in the debate - I haven't even looked at conduit, ever)
14:49:27 <johnw> mm_freak_: how do you handle leftovers?
14:49:57 <sccrstud92> johnw: box em up and take em home. put em in the fridge
14:50:00 <mm_freak_> johnw: using the FreeT approach of pipes-parse
14:50:12 <johnw> mm_freak_: ok
14:50:13 <studmuf> I'm working on this example problem http://lpaste.net/99536 from a book I have and I'm not sure how to approach it. Any pointers are appreciated
14:51:08 <johnw> mm_freak_: so, when I was talking about conveience, one of the things I meant was not having use the FreeT approach, and the different set of functions it requires
14:51:13 <johnw> take vs. takeP, for example
14:51:22 <johnw> or whatever is calls the FreeT version
14:51:33 <sccrstud92> studmuf: start with pattern matching on the JSON constructos in the show function
14:51:48 <mm_freak_> johnw: that's because you consider FreeT as a necessary evil
14:52:08 <mm_freak_> johnw: the truth is that FreeT is what makes all of this easy and convenient
14:52:16 <mm_freak_> FreeT enables this:  count (lines stdin)
14:52:27 <joneshf-laptop> someone remind me
14:52:38 <joneshf-laptop> nvm, it came to me as i hit enter :)
14:52:46 <mm_freak_> and this:  byRequest handleRequest socket
14:52:54 <sccrstud92> jonshf-laptop: ur welcome
14:52:58 <johnw> I regard the FreeT trick as pretty clever.  But when you find yourself deep into code using conduit, and suddenly realize you need to use a leftover, you aren't required to backup and change all the code to now use FreeT
14:53:14 <codygman> How do I import forall as used in this tutorial: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
14:53:26 <shachaf> forall is a keyword.
14:53:32 <shachaf> You can turn it on with various extensions.
14:53:46 <sccrstud92> he needds to know which extension to enable
14:53:51 <mm_freak_> johnw: this is because you think in conduit…  what you are saying is like an imperative programmer asking, "but what if i want to sum by updating a mutable variable?"
14:53:52 <shachaf> Oh, wait.
14:53:56 <sccrstud92> rank2types maybe
14:54:02 <shachaf> No, that's forall the value.
14:54:09 <mm_freak_> johnw: the answer is:  you don't do it
14:54:30 <shachaf> Maybe they mean "forAll" from quickcheck.
14:54:36 <sccrstud92> oh yeah
14:54:36 <codygman> sccrstud92, shachaf: I looked it up and figured out it was a keyword, but that still doesn't help me follow along with the tutorial :P
14:54:42 <sccrstud92> its forAll not forall
14:54:44 <shachaf> codygman: Oh, it's explained in that paragraph.
14:54:47 <studmuf> sccrstud92: ok thanks
14:54:57 <shachaf> codygman: "It's actually a lie". It doesn't exist.
14:55:07 <sccrstud92> i mean nvrm
14:55:13 <sccrstud92> i was wrong
14:55:13 <shachaf> This is a bizarre way of phrasing a law.
14:55:14 <codygman> shachaf: Well that's embarrasing :D
14:55:16 <mm_freak_> johnw: FreeT splitting is not just a new feature, it is a different paradigm
14:55:29 <johnw> mm_freak_: like I said, I don't have the time to debate it now
14:56:39 <funky_lambda> I'm pretty comfortable with monads but how do I understand monad transformers? I can't for life implement them in any way
14:56:48 <mm_freak_> johnw: it's just that i'm sick of this "but pipes is for theory freaks, while conduit is practical" bullshit…  in my applications pipes has proved far more practical than conduit, even when i had to implement stuff myself
14:57:02 <mm_freak_> s/even/especially/
14:57:30 <johnw> mm_freak_: I'm tired of pipes answer to conduit's differences to always be "just don't that"
14:57:36 <johnw> there are reasons why we do some of the things that we do
14:57:40 <shachaf> if you're going to not-debate it, you should not-debate it in #haskell-overflow or something
14:58:07 <johnw> but I have a feeling we aren't going to reach agreement on this anymore than Tekmo and snoyberg have in all these months.  And yes, let's rant over in -overflow
14:58:45 <sccrstud92> funky_lambda: are you trying to implement them to learn them?
14:58:45 <dmj> funky_lambda: I'd start with understanding kinds
14:58:53 <Axman6> @unmtl StateT s IO a
14:58:53 <lambdabot> s -> IO (a, s)
14:59:08 <Axman6> funky_lambda: Start with that
14:59:10 <funky_lambda> sccrstud92: Yes, that's how I learned monads
14:59:26 <funky_lambda> dmj: Any good resources?
14:59:28 <mm_freak_> johnw: i believe we both have work to do, so let's leave this debate to tekmo and snoyberg =)
14:59:37 <johnw> agreed :)
14:59:43 <bitemyapp> mm_freak_: can you join haskell-overflow please? I don't have a horse in this race but I wanted to hear about what sort of problem worked out better for you in pipes than conduit.
14:59:45 <dmj> funky_lambda: grabmuller, http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
14:59:57 <funky_lambda> dmj: Thanks!
15:00:32 <mm_freak_> bitemyapp: quick answer:  fast-and-convenient-at-the-same-time stream splitting, chunk mapping and rejoining
15:00:59 <mm_freak_> bitemyapp: split into lines, do something with individual lines, rejoin
15:01:06 <mm_freak_> stuff like that
15:01:09 <bitemyapp> mm_freak_: that sounds pretty cool! Thanks.
15:01:59 <mm_freak_> bitemyapp: most notably this runs in constant space even if the lines are gigabytes in length
15:02:19 <mm_freak_> (which is a major difference to conduit)
15:06:54 <sclv> anyone play around with ihaskell type stuf fhere?
15:08:04 <johnw> mm_freak_: conduit can achieve the constant space trick too: http://www.yesodweb.com/blog/2013/09/folding-lines-conduit
15:08:17 <johnw> sclv: what is ihaskell?
15:08:28 <ivanm> johnw: using ipython to run ghci IIUC
15:08:35 <johnw> oh, interesting
15:08:43 <sclv> http://gibiansky.github.io/IHaskell/
15:08:45 <sclv> yeah.
15:09:00 <sclv> i just mentioned elsewhere that cloud.sagemath has basic haskell support
15:09:07 <sclv> and bill stein is open to more if someone jumps in
15:09:16 <sclv> like if someone wants to help him run ihaskell that would be amazing
15:09:44 <sclv> it obv runs ipython and sage already
15:10:12 <ivanm> I had a look at the ihaskell source once; IIRC it was full of unsafePerformIOs :s
15:12:04 <enthropy> sclv: come to #ihaskell?
15:13:04 <mm_freak_> johnw: the problem of the conduit approach is the loss of composability…  the "inversion" point is really a non-issue
15:13:06 <Eduard_Munteanu> Any chance String / FilePath uses in base modules like System.Directory fuse away?
15:13:08 <studmuf> ok started working on show and i'm stuck on show JStr and JObj http://lpaste.net/99537
15:13:16 <johnw> mm_freak_: come to #haskell-overflow :)
15:13:37 <Eduard_Munteanu> I find it a bit annoying String pops up everywhere.
15:13:56 <mm_freak_> johnw: as you said, we probably won't reach agreement anyway, and i don't feel like joining another channel =)
15:14:16 <johnw> ok, I can accept agreeing to disagree as good enough for today ;)
15:14:17 <Eduard_Munteanu> It's not even an internal representation or anything, AFAICT.
15:17:06 <mm_freak_> johnw: i'm happy to continue this discussion another time =)
15:17:14 <studmuf> pointers on how to implement show for JStr and JObj http://lpaste.net/99537
15:17:27 <johnw> mm_freak_: sure, and maybe by voice would be quicker too
15:18:04 <mm_freak_> johnw: but i recommend giving pipes a shot…  not in a little toy program, but in an actual real world application, and without trying to write conduit in pipes =)
15:18:08 <mm_freak_> johnw: sure
15:18:21 <dmj> studmuf: you might need to concat the list
15:18:35 <johnw> mm_freak_: i've done a bit of work to prove that modulo certain features, the core types are isomorphic.  And I've written a pipes UI layer for conduit in conduit-extras
15:18:41 <dmj> studmuf: show (JArr xs) = xs >>= show
15:19:46 <studmuf> the output needs to look like the examples found here http://lpaste.net/99536
15:20:47 * ivanm shudders at the custom Show instance
15:21:28 <studmuf> ivanm: Ha ha. I'm trying to understand how show works
15:21:53 <ivanm> in terms of what it does?
15:22:17 <ivanm> Show and Read are meant to produce and parse equivalent Haskell source code for debugging
15:22:31 <ivanm> not for pretty-printing (which is what you seem to be doing)
15:23:00 <ivanm> typically the only time you'd write a custom Show instance is when a) GHC can't do it for you (weird types, etc.) or b) you want to hide constructors
15:23:05 <dmj> studmuf: is this hmwk?
15:23:22 <ivanm> dmj: "hmwk"?
15:23:39 <Twey> Haha
15:23:42 <studmuf> dmj: this problem is
15:24:11 <studmuf> dmj: I'm not looking for an answers just pointers
15:24:17 <Twey> I often write custom Show instances when the output of the default instance would be completely unreadable and therefore useless for debugging
15:25:04 <sccrstud92> dmj: he's doing an online tutorial i think
15:25:09 <Discoloda> hello, is there a way to limit the memory used to compile a package. i keep running out of space and it gets killed
15:25:18 <ivanm> Discoloda: ulimit ?
15:25:21 <sccrstud92> and i dont think xs >>= show is appropriate in that context
15:25:44 <studmuf> sccrstud92: I was doing a online tutorial but decided to switch to the hw
15:25:57 <sccrstud92> ah
15:26:14 <sccrstud92> you still dont want to use xs >>= show unless you understand how it works
15:26:15 <Twey> Discoloda: Not as far as I know, but you could try adding more swap to your system
15:26:25 <sccrstud92> also i dont believe it ouputs correct json regardless
15:26:32 <studmuf> sccrstud92: I don't so won't
15:26:40 <dmj> ivanm: "homework"
15:26:50 <ivanm> ahhh, right
15:26:58 <briennetheblue> wish i got haskell homework :(
15:26:59 <studmuf> I thought I could do it with map
15:27:22 <johnw> briennetheblue: here's some Haskell homework for you: come up with a good extensible records proposal
15:27:36 <studmuf> show (JArr xs) = map show xs
15:27:56 <Twey> studmuf: Almost — that returns [String], but Show needs it to return String
15:28:00 <dmj> studmuf: what is the type of show
15:28:00 <briennetheblue> i guess this is a case of be careful what you wish for
15:28:03 <sccrstud92> studmuf: that returns a list of strings, but show has to return a string so that wont work
15:28:07 <Discoloda> Twey: i have added 2GB, but its still killing it, im looking at ulimit
15:28:18 <Twey> Discoloda: ulimit will just kill it faster :þ
15:28:43 <sccrstud92> studmuf: show (JArr xs) = show xs might work
15:28:51 <x77686d> studmuf: What's the tutorial you were doing?
15:29:03 <studmuf> sccrstud92: I tried that initially with no luck
15:29:15 <dhrosa> that code won't work, that returns a l ist of strings
15:29:25 <dhrosa> maybe you want unlines (map show xs) ?
15:29:39 <merijn> @hoogle (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:29:39 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:29:40 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:29:40 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:29:40 <dhrosa> or just show xs?
15:29:41 <sccrstud92> dhrosa: look at the example output
15:29:55 <sccrstud92> just show xs should work, im trying it now
15:30:03 <studmuf> dmj: the data type and instance def of JSON and Show can be seen here http://lpaste.net/99537
15:30:24 <studmuf> dmj: is that what you meant? sorry i'm still very new to haskell
15:30:33 <briennetheblue> :t fmap . fmap
15:30:34 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:31:59 <Discoloda> `ulimit -a` tells you what the current limits are, it seems it doesnt touch the swap space and 'ld' is on top for a while
15:32:00 <fragamus> how does cpphs get installed?
15:32:02 <dmj> studmuf: what is the type of map?
15:32:03 <studmuf> sccrstud92: retired show (JArr xs) = show xs and it works for JSON types but not for this example
15:32:10 <studmuf> JArr [1..4]
15:32:29 <studmuf> map :: (a -> b) -> [a] -> [b]
15:33:05 <studmuf> dmj: Oh! I think i get what your hinting at.
15:33:10 <sccrstud92> studmuf: the JArr constructos takes a [JSON]
15:33:19 <sccrstud92> [1..4] its a list of regular numbers
15:33:33 <studmuf> sccrstud92: indeed
15:33:40 <sccrstud92> so it doest work because JArr [1..4] doesnt make any sense
15:33:51 <sccrstud92> look at this http://lpaste.net/99538
15:34:05 <sccrstud92> it prints the first example correctly
15:34:55 <sccrstud92> it works because the show instance for lists [] autmatically shows the elements separated by commas and surround by brakcets
15:34:56 <studmuf> sccrstud92: Thanks I completely over looked the type of JArr after I typed it in.
15:35:43 <studmuf> sccrstud92: so any pointers for JObj?
15:35:51 <sccrstud92> yeah
15:35:51 <dmj> sccrstud92: I think his teacher wants him to make use of intercalate tho
15:35:57 <studmuf> not sure how t start that one
15:35:59 <sccrstud92> that is for JObj
15:36:05 <sccrstud92> i was getting to that
15:36:09 <studmuf> dmj: oh yes he does
15:36:32 <dmj> studmuf: can you rewrite JArr using intercalate?
15:36:41 <dmj> the show instance
15:36:51 <sccrstud92> studmuf: dmj: that might be a good idea
15:37:01 <sccrstud92> using the show instance for list there is almost like cheating
15:37:15 <sccrstud92> if u rewrite it  using intercalate that will help with JObj also
15:37:21 <studmuf> sccrstud92: haha yes
15:37:39 <studmuf> dmj: sccrstud92: ok i'll try rewriting
15:37:54 <sccrstud92> remember these functions
15:37:57 <sccrstud92> :t intercalate
15:37:58 <lambdabot> [a] -> [[a]] -> [a]
15:38:03 <sccrstud92> :t concat
15:38:03 <lambdabot> [[a]] -> [a]
15:38:09 <sccrstud92> :t show
15:38:10 <lambdabot> Show a => a -> String
15:38:45 <DMcGill> Could somebody give a quick look over this function for me please? I can't help but feel it can be made a fold that shortcircuits somehow. http://lpaste.net/99540
15:39:03 <sccrstud92> actually u dont need concat because intercalate concats for  you
15:39:37 <sccrstud92> i gtg but ill be back later
15:39:42 <dmj> sccrstud92: hush you :)
15:39:43 <sccrstud92> studmuf: gl
15:39:50 <sccrstud92> dmj: T.T
15:39:55 <DMcGill> it essentially goes up a vector (starting at the index `less') and finds the new index that's greater or equal to a given i
15:40:09 <DMcGill> index that has a value that's*
15:40:15 <studmuf> sccrstud92: thanks for the help. later
15:44:10 <studmuf> when i try > :t intercalate I get > Not in scope: `intercalate'
15:44:22 <studmuf> any ideas why that would be?
15:44:39 <geekosaur> @index intercalate
15:44:39 <shiona> imported Data.List?
15:44:39 <lambdabot> bzzt
15:44:45 <geekosaur> meh, ancient dbs
15:44:49 <geekosaur> but yes, Data.List
15:44:52 <geekosaur> it's not in Prelude
15:45:06 <studmuf> shiona: thanks
15:45:13 <jrmithdobbs> Data.List or which ever intercalate you're actually looking for (bytestring, tex, etc have them)
15:46:11 <studmuf>     Could not find module `DATA.List'
15:46:11 <studmuf>     Use -v to see a list of the files searched for.
15:46:21 <studmuf> Now i have this
15:46:29 <geekosaur> case matters
15:46:32 <geekosaur> Data.List
15:46:40 <studmuf> geekosaur: thanks
15:47:32 <dmj> anyone know how to pass custom command line parameters into the SnapletInit monad? I'd like to set the IP address of stuff there
15:47:58 <dmj> like "./app -ip 192.168.0.2 -p 8080 -e prod +RTS -I0 -A4M -qg1"
15:48:06 <Eduard_Munteanu> dmj: a link to the docs might help
15:49:20 <flebron> Hi. I have some pure code I'd like to run in parallel, it's a bunch of lookups on a Data.HashMap. Is there something like "waitForJust :: [Maybe a] -> Maybe a"? (I can encapsulate those as an IO thing if need be)
15:49:43 <flebron> (Or in an Async, or whatever :p It's pure code.)
15:50:03 <dmj> Edward_Munteanu: it seems like this function will do it..http://hackage.haskell.org/package/snap-server-0.9.3.3/docs/Snap-Http-Server-Config.html#v:extendedCommandLineConfig
15:50:34 <Eduard_Munteanu> flebron: how about 'par' and the likes if it's pure code?
15:51:39 <flebron> Eduard_Munteanu: Forgive the newbieness, how can par help here? (I look at the docs and it isn't immediately obvious)
15:52:17 <studmuf> I'm not sure how intercalate is suppose to help. I currently have show (JArr xs) = map show (intercalate "," xs) but know that can't be right
15:53:19 <flebron> Eduard_Munteanu: parMap seems close, but it'd give me a [Maybe a]. If I then head . catMaybes (or use MonadPlus), that'd still force the list sequentially, right?
15:53:22 <Eduard_Munteanu> flebron: par lets you evaluate stuff speculatively
15:54:40 <sccrstud92> :t map show undefined
15:54:41 <lambdabot> [String]
15:54:58 <dmj> studmuf: intercalate allows you to intersperse the commas
15:55:00 <joneshf-laptop> hmm, is there something more concise for parsec than: spaces >> someParser >> spaces
15:55:01 <joneshf-laptop> ?
15:55:06 <sccrstud92> stdumuf: after mapping show you have a list of strings
15:55:11 <Eduard_Munteanu> flebron: for example, if you have a, b, c :: Maybe Foo, you can parallelize evaluation and pretend to check them in order.
15:55:21 <sccrstud92> so like dmj said, you can intercalate the commas afterwards
15:55:30 <dmj> > intercalate "," (map show [1,2,3])
15:55:31 <lambdabot>  "1,2,3"
15:56:01 <sccrstud92> >intercalate "," $ map show $ [1,2,3]
15:56:06 <joneshf-laptop> for that matter, is there some way to just ignore whitespace when parsing
15:56:10 <sccrstud92> > intercalate "," $ map show $ [1,2,3]
15:56:11 <lambdabot>  "1,2,3"
15:56:16 <sccrstud92> > intercalate "," . map show $ [1,2,3]
15:56:17 <lambdabot>  "1,2,3"
15:56:23 <joneshf-laptop> like a general, forget about whitespace thing?
15:56:31 <sccrstud92> dmj is probably the one to use though
15:56:43 <dmj> joneshf-laptop: are you using parsec
15:57:02 <joneshf-laptop> dmj, yes
15:57:58 <funky_lambda> > print . sum =<< replicateM 10 (randomRIO (0,100))
15:58:00 <lambdabot>  <IO ()>
15:58:43 <verement> joneshf-laptop: look into the lexeme combinator
15:58:58 <FreeFull> funky_lambda: lambdabot doesn't do IO
15:59:09 <funky_lambda> I can see that
15:59:13 <sccrstud92> lol
15:59:24 <joneshf-laptop> verement, thanks
15:59:44 <FreeFull> I get around 500
15:59:50 <sccrstud92> i wish there was a haskell class at my school
15:59:51 <FreeFull> In ghci
16:00:12 <briennetheblue> haskell is too cool for school sadly
16:00:23 <sccrstud92> yeah[
16:00:30 <studmuf> sccrstud92: where do you go to school?
16:00:51 <sccrstud92> university on the east coast
16:00:58 <sccrstud92> of America
16:01:01 <mornfall> :D
16:01:31 <funky_lambda> i bet they teach visual basic
16:01:50 <studmuf> I'm at a university on the west coast of the USA. Which school?
16:01:52 <Rembane> That's just because they want you to be able to hack a GUI to track an IP-address
16:02:14 <funky_lambda> Rembane: no you have it all wrong
16:02:20 <funky_lambda> Rembane: its called a GUI INTERFACE
16:02:27 <funky_lambda> Rembane: not GUI, get ur facts right
16:02:45 <sccrstud92> have to agree with funky here
16:02:51 <sccrstud92> GUI interface is correct
16:03:00 <sccrstud92> you also have to use visual basic though
16:03:22 <dmj> Rembane: looool
16:03:23 <funky_lambda> in my schoo we used VB and turbo pascal to make a GUI interface for tracking TCP protocol traffic with a ROM memory module
16:03:39 <Rembane> funky_lambda: Darn it! I winged it and failed!
16:03:44 * geekosaur wonders why you insist on "Graphical User Interface Interface"
16:04:02 <simpson> geekosaur: It's a joke from a movie.
16:04:14 <sccrstud92> tv show*
16:04:21 <sccrstud92> and it wasnt a joke
16:04:22 <funky_lambda> do not watch it
16:04:25 <funky_lambda> you will cringe
16:04:45 <dvnous> http://www.youtube.com/watch?v=hkDD03yeLnU
16:05:14 <sccrstud92> lol i just found the exact same link
16:05:15 <Rembane> It's awesome techno babble. Sadly the individual words means something.
16:05:19 <hpc> one of my favorite videos
16:05:19 <Rembane> Me too. :D
16:05:35 <hpc> second favorite is numbers: "it's a 32-bit ipv4 address"
16:05:36 <dvnous> it's a classic
16:05:40 <sccrstud92> at least they put visual and basic together
16:05:53 <dmj> Eduard_Munteanu: even if you could use extendedCommandLineConfig, it's in MonadSnap not SnapletInit
16:06:13 <sccrstud92> hpc: at least thats not wrong, just redundant
16:06:49 <funky_lambda> i wonder how on earth some tv shows can come up wit hthat shit
16:07:01 <funky_lambda> do the producers seriously not realize
16:07:16 <hpc> funky_lambda: it's easy - https://github.com/headprogrammingczar/synonyminator
16:07:16 <Rembane> Nope. :D
16:07:25 <briennetheblue> i think at least half of the time it's an intentional joke
16:07:28 <briennetheblue> or at least hope
16:07:32 <dmj> they probably realize 99% of their viewers don't know what tcp/ip is
16:07:52 <funky_lambda> I mean, what the f***: http://www.youtube.com/watch?v=u8qgehH3kEQ
16:08:00 <flebron> there was a description on Numb3rs of what irc was. something to do with passing ships
16:08:12 <hpc> that one is great too
16:08:34 <briennetheblue> funky_lambda: exactly, that's got to be an intentional joke :p
16:08:49 <sccrstud92> there was an ama on reddit where a writer said they have a competition to see who can get the most ridiculous stuff on air
16:08:56 <funky_lambda> no wonder then
16:09:04 <DMcGill> DOUBLE TYPING
16:09:19 <hpc> joss whedon must get in on this bet
16:09:36 <funky_lambda> it's like porn popups popping up faster than you can close them
16:09:39 <sccrstud92> the double typing was the WORST
16:09:44 <sccrstud92> the absolute worst
16:09:51 <sccrstud92> worse than gui interface
16:10:18 <DMcGill> stuff like ATM machine or PIN number is pretty normal and I tend to just let it slide
16:10:24 <sccrstud92> http://www.youtube.com/watch?v=u8qgehH3kEQ
16:11:10 <funky_lambda> bollywood should have a shot at hacking
16:11:28 <funky_lambda> if ridiculity is the goal
16:11:33 <funky_lambda> i wonder what they'd come up with
16:11:37 <sccrstud92> in bollywood hacking is preceded by a dance number and followed by jumping out of an airplane
16:11:55 <hpc> the hilarity of technobabble is that it's so ridiculous, but also put alongside the rest of a show that's completely serious
16:11:56 <sccrstud92> or the other way around
16:12:04 <dmj> trinity on matrix uses nmap like a pro
16:12:29 <sccrstud92> seriously how hard is it to get a technical consultant
16:12:45 <dmj> http://www.youtube.com/watch?v=0PxTAn4g20U
16:12:51 <funky_lambda> why get one when 99% of the audience doesnt care
16:13:12 * hackagebot kickchan 0.1.0.4 - Kick Channels: bounded channels with non-blocking writes  http://hackage.haskell.org/package/kickchan-0.1.0.4 (JohnLato)
16:13:34 <funky_lambda> if they cared for technical minorities they'd have to hire bunch of consultants from all subjects
16:13:35 <simpson> funky_lambda: There's an Indian movie called "Endhiran" which you might like.
16:14:06 <funky_lambda> simpson: I've never liked an Indian movie
16:14:38 <DMcGill> Endhiran is pretty amazing though
16:14:53 <DMcGill> if you look on youtube you can find all the good bits - it's based on Terminator
16:15:05 <funky_lambda> It has 7.0 on imdb though so maybe it is good
16:15:12 <simpson> funky_lambda: There's a lot of great Indian movies.
16:15:29 <simpson> funky_lambda: A great film, if you don't mind sports and you've got four hours, is the epic "Lagaan."
16:15:44 <funky_lambda> simpson: I dont doubt that, it's just that I have no taste for them
16:16:30 <funky_lambda> simpson: with the exception of slumdog millionaire, that was great
16:17:04 <funky_lambda> simpson: lagaan has some good reviews though, ill remember it
16:17:59 <flebron> Hrmph. Data.HashMap is taking less time than Data.HashTable.IO to do a length . toList . fromList. Weird.
16:21:05 <studmuf> sccrstud92: Hey if you can take a look at how i'm approahcing show JObj http://lpaste.net/99538
16:22:00 <studmuf> Couldn't match expected type `[Char]'
16:22:00 <studmuf>                 with actual type `[([Char], a0)] -> [Char]'
16:22:06 <studmuf> I'm receiving the error
16:22:22 <dmj> studmuf: great job on JArr
16:22:38 <DMcGill> studmuf: pairs is a function
16:22:56 <Cale> Yeah, presumably you meant to apply pairs to xs
16:23:00 <DMcGill> stufmuf: but you've written: "{" ++ pairs ++ "}"
16:23:01 <studmuf> dmj: thanks sccrstud92 and you helped alot
16:23:28 <Cale> You could have just defined pairs not as a function though
16:23:30 <sccrstud92> studmuf: np, and those guys are right
16:23:32 <studmuf> DMcGill: pairs is a function
16:23:35 <studmuf> ?
16:23:42 <Cale> (just using the second definition, and the xs already in scope)
16:23:52 <sccrstud92> does he need that definition of pairs []? doesnt pairs xs work for the base cas as well?
16:23:54 <DMcGill> Cale is right though, pairs shouldn't be a function at all
16:23:58 <Cale> pairs = intercalate "," (map showPair xs)
16:24:20 <Cale> and yes, that base case is equivalent to the other case
16:24:27 <Cale> > intercalate "," []
16:24:28 <lambdabot>  ""
16:24:51 <DMcGill> can anybody have a look at this for me please? http://lpaste.net/99540 I'm sure it can be a fold
16:24:57 <studmuf> ok so lose the pairs
16:25:00 <sccrstud92> except for that small change it looks really good
16:25:22 <studmuf> sccrstud92: thanks
16:25:32 <Cale> studmuf: Well, just define pairs like I showed
16:25:38 <sccrstud92> DMcGIill: can folds "terminate" early?
16:25:44 <Cale> studmuf: using the xs which is already in scope :)
16:25:54 <Cale> sccrstud92: yes
16:26:02 <Cale> (right folds can)
16:26:31 <sccrstud92> i dont mean from laziness
16:26:35 <Cale> Let's see, what are we folding over here...
16:26:37 <sccrstud92> is that what u were saying Cale?
16:26:59 <Cale> Well, I don't know what it would mean if not from laziness
16:27:20 <sccrstud92> like lets say you have a list of numbers
16:27:21 <Cale> You're talking about operational behaviour if you're saying "terminate early"
16:27:32 <sccrstud92> and you want to change each number in the first half of the list to 0
16:27:38 <studmuf> Cale: sccrstud92: DMcGill: dmj: works great thanks all
16:27:43 <sccrstud92> i mean
16:27:53 <sccrstud92> to stop folding halfway through the list
16:28:11 <DMcGill> > foldl (&&) [True, False, undefined]
16:28:12 <lambdabot>  Couldn't match expected type `GHC.Types.Bool'
16:28:12 <lambdabot>              with actual type `[GHC.Types.Bool]'
16:28:19 <DMcGill> > foldl1 (&&) [True, False, undefined]
16:28:20 <lambdabot>  False
16:28:32 <Cale> DMcGill: Is the code you pasted working?
16:28:38 <DMcGill> Cale: yep, just ugly
16:28:41 <Cale> (what's i?)
16:28:49 <DMcGill> I probably should have removed the W newtypes to show it here
16:28:53 <Cale> I guess I should just ignore that :)
16:29:18 <DMcGill> so it essentially works out subvector that's lower than i
16:29:43 <DMcGill> that way, `take less' vws' are all <= i
16:30:00 <dmj> studmuf: great job
16:30:13 <DMcGill> and it's happening inside a loop hence less getting updated to less'
16:30:22 <sccrstud92> DMcGill: is this like partition (<= i)? but for vectors?
16:30:28 <DMcGill> and since the list is sorted, less' >= less
16:30:42 <DMcGill> sccrstud92: essentially yes but it's keeping the index rather than the partitions
16:30:53 <sccrstud92> ah i see
16:31:11 <DMcGill> as passing the index around and changing it is easier than repeatedly making new paritions
16:31:12 <Cale> Maybe something like...
16:31:22 <Cale> less' = foldr (\j r -> if getW (vws U.! j) > W i) then j else r) maxIx [less .. maxIx - 1] where maxIx = U.length vws
16:32:04 <Cale> I'm not sure that's really any better
16:32:16 <Cale> The bang pattern you have on j is unnecessary though
16:32:34 <Cale> Because the guard compares j using == to maxIx, which will force its evaluation in any case.
16:32:38 <dleedev> hi all, what's the best library to use for SQL?
16:33:06 <joelteon> persistent is pretty good
16:33:07 <sccrstud92> i tend to keep the bang anyway in scenarios like that
16:33:22 <dleedev> joelteon: it seems like persistent to trying to be non-relational?
16:33:27 <Cale> I generally try not to have any bang patterns unless they're absolutely required.
16:33:29 <joelteon> is it
16:33:50 <Cale> Because whenever I see them, I have to think about why they're there.
16:33:52 <Cale> :)
16:34:05 <DMcGill> I just tend to put them on inner loop Ints
16:34:42 <DMcGill> also, how bas is
16:34:43 <DMcGill> bad*
16:35:00 <DMcGill> unsafeSort v = runST $ do {vM <- U.unsafeThaw v
16:35:01 <DMcGill> ; H.sortBy (comparing getW) vM;
16:35:01 <DMcGill>  U.unsafeFreeze vM}
16:35:17 <Cale> bad
16:35:19 <DMcGill> I don't use that vector anywhere else
16:35:38 <DMcGill> nothing happens to it before it gets passed to that function
16:36:28 <Cale> Well, things might work out for you, but it's terrible :P
16:36:36 <DMcGill> it works on my sample but I'm just wondering if I'm setting myself up for a race condition or something
16:36:59 <benzrf> hey
16:37:07 <benzrf> im trying to install djinn and it gives:
16:37:07 <benzrf> gcc: error: unrecognized command line option ‘-Wl’
16:37:11 <Cale> How are you creating the array that you're sorting like that?
16:37:35 <DMcGill> fromListN
16:37:54 <DMcGill> although I might switch it to replicateN inside a Parsec do-block
16:38:02 <DMcGill> replicateM even
16:38:07 <Cale> Wait, where's fromListN defined?
16:38:22 <DMcGill> @hoogle fromListN
16:38:22 <lambdabot> No results found
16:38:35 <DMcGill> all over the place as with all vector functions :/
16:38:41 <Cale> Ah, vector
16:38:45 <DMcGill> @hoogle fromListN +vector
16:38:45 <lambdabot> Could not find some databases: vector
16:38:45 <lambdabot> Searching in:
16:38:45 <lambdabot>   .
16:38:53 <Cale> I thought this was UArray
16:39:00 <Cale> or STUArray or something
16:39:11 <DMcGill> fromListN :: Vector v a => Int -> [a] -> v a
16:39:11 <DMcGill> {-# INLINE fromListN #-}
16:39:11 <DMcGill> fromListN n = unstream . Stream.fromListN n
16:39:55 <Cale> Anyway, it would be better to do a single freeze
16:40:18 <fragamus> edwardk: ed can you please tell me how to get the magnitude of a V3 the right way
16:40:33 <fragamus> I just need to normalize it
16:40:52 <DMcGill> Cale: hmm I could populate it while parsing, sort and then freeze it. That sounds good.
16:40:55 <jawsh> anyone have much experience with accelerate?
16:41:02 <jawsh> I'm having issues getting the opencl backend to compile
16:41:09 <roboguy_> benzrf: what version of gcc do you have?
16:41:40 <roboguy_> benzrf: -Wl is usually used to pass options to the linker
16:41:51 <benzrf> http://bpaste.net/show/175989/
16:42:12 <Cale> DMcGill: and if you define a variant of runST which does the unsafeFreeze for you, then it becomes safe.
16:42:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-ST.html see runSTArray here
16:43:05 <flebron> Hi. I'm using the following code to find collisions in two lists (essentially), each of size at most 2^20: http://lpaste.net/3863952733547528192 . The first part (lefts) inserts a the first list into a Data.HashMap. The second part queries it for collisions with the second list. Can this be improved (performance wise) in a simple way? Is there some "obviously parallel" thing? (I'm thinking the insertions
16:43:07 <flebron> into the HashMap?)
16:43:48 <DMcGill> Cale: oh ok, I'll do that. I  mean in my code I'll just call runST and unsafeFreeze myself since it's only once and I can just make sure that the freeze is the last action
16:43:48 <benzrf> roboguy_: ^thats gcc -v
16:43:57 <DMcGill> Cale: thanks for your help
16:44:28 <Cale> DMcGill: I don't know why analogous operations don't seem to exist in vector, though I might've just missed them
16:44:31 <DMcGill> I'll need to intersperse the ST monad and Parser though
16:45:13 <DMcGill> there doesn't seem to be a ParserT :/
16:46:22 <Cale> flebron: Perhaps consider trying Data.Set.intersection?
16:46:38 <sccrstud92> :t create
16:46:39 <lambdabot> Not in scope: `create'
16:46:57 <johnw> DMcGill: no ParserT for which parser?
16:47:08 <DMcGill> sccrstud92: create :: Unbox a => (forall s. ST s (MVector s a)) -> Vector a
16:47:17 <DMcGill> johnw: I'm using attoparsec at the moment
16:47:24 <johnw> ah
16:47:28 <johnw> then I can believe that
16:47:34 <DMcGill> gotta zoom zoom
16:47:43 <Cale> flebron: (or Data.Map.intersection)
16:47:59 <roboguy_> benzrf: it looks like newer versions of gcc don't recognize -Wl. You could try removing it and see if it works
16:48:45 <benzrf> lame :\
16:48:47 <benzrf> roboguy_: removing what?
16:49:08 <roboguy_> benzrf: the -Wl option
16:49:31 <studmuf> I'm taking a break from prolog and back to this haskell assignment. I'm now trying to implement toJson and fromJson for doubles and arrays http://lpaste.net/99544
16:49:44 <sccrstud92> Cale: im sorry i got dced
16:49:53 <sccrstud92> Cale: did you see what i said about create?
16:50:00 <DMcGill> is there any advantage to using (Int, (Int,Int)) over (Int, Int, Int)?
16:50:23 <studmuf> I'm wondering how the fromJson for the double should work?
16:50:29 <benzrf> roboguy_: how i do?
16:50:33 <Cale> sccrstud92: no
16:50:40 <roboguy_> benzrf: probably in the cabal file
16:50:49 <benzrf> bah
16:50:52 <Twey> DMcGill: You can use the functions defined on pairs, like fst, snd, first, and second
16:50:58 <sccrstud92> Cale: i believe create is the runSTarray equivalent for vectors
16:51:01 <benzrf> :t first
16:51:02 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
16:51:14 <benzrf> DMcGill: why not use an ADT
16:51:19 <Twey> > first (+ 2) (3, 5)
16:51:20 <lambdabot>  (5,5)
16:51:56 <Twey> But yeah, if you have a structure bigger than a pair it's often (but not always!) a sign that you should have defined a datatype
16:52:04 <johnw> Twey++
16:52:08 <sccrstud92> studmuf: fromJSON has type JSON -> a where a is the type you are defining the instance for
16:52:11 <benzrf> johnw: we dont do that here
16:52:15 <sccrstud92> so for the Double instance
16:52:16 <johnw> do what?
16:52:18 <Twey> We don't?
16:52:18 <benzrf> Twey' = Twey + 1
16:52:21 <Twey> Heh
16:52:23 <johnw> haha
16:52:26 <johnw> succ Twey
16:52:27 <sccrstud92> fromJSON :: JSON -> Double
16:52:34 <Twey> lambdabot tracks (used to track?) things of the form ‘foo++’
16:52:52 <Twey> C was always very high up the rankings, for some reason
16:53:02 <johnw> I tried to avoid 3-tuples and higher pretty rigorously; giving names to more complex products almost always pays off
16:53:56 <Twey> The only time a higher tuple (or, indeed, a tuple in general) is worthwhile is when you're almost always going to want to deconstruct it as soon as it's returned from the function
16:53:58 <johnw> I even like to wrap types like Int and Text in newtypes sometimes
16:54:17 <DMcGill> johnw: in this case, (Unbox a, Unbox b => Unbox (a,b))
16:54:36 <studmuf> sccrstud92: do you have to implement a typecast from JNum to Double?
16:54:49 <Twey> I.E. when there's absolutely no semantic connection between the components, they just happen to all be generated at the same time (by e.g. an IO action)
16:54:59 <DMcGill> johnw: oh I've got newtypew Value and Weight over Int and they've saved my loads of trouble. It took me ages to work out that my c code wasn't working because typedefs aren't compiler enforced
16:55:04 <johnw> Twey: true, I use that too
16:55:22 <benzrf> product types woo
16:55:35 <studmuf> for the current code at http://lpaste.net/99544 gives me the error Not in scope: data constructor `Double'
16:55:45 <johnw> information-rich types are almost always worth the small amount of trouble
16:56:34 <sccrstud92> gah i keep dcing
16:56:51 <sccrstud92> what irc client should i use if im on windows
16:57:16 <benzrf> sccrstud92: gnu/linux
16:57:36 <sccrstud92> benxrf: i dont understand
16:58:13 <Cale> sccrstud92: I tend to use XChat regardless
16:58:26 <DMcGill> anyway thanks for the help with my code
16:58:32 <sccrstud92> Cale: dont you have to pay for XChat after 20 days?
16:58:45 <Cale> http://www.silverex.info/download/
16:58:47 <benzrf> sccrstud92: the correct irc client for windows is install gnu/linux
16:58:47 <DMcGill> XChat 2 is free
16:58:48 <Cale> no
16:58:49 <benzrf> then irc from a better OS
16:59:18 <qwitwa> Why not Hexchat?
16:59:20 <sccrstud92> benzrf: i wasn't asking for OS recommendations
16:59:39 <sccrstud92> benzrf: its dumb to recommend an OS only because its good with irc clients
17:00:01 <johnw> sccrstud92: http://www.makeuseof.com/tag/top-7-free-irc-clients-windows-7/
17:00:12 <benzrf> sccrstud92: i was teasing you
17:00:18 <qwitwa> http://hexchat.github.io/
17:00:19 <benzrf> sccrstud92: but seriously if youre going to be doing programming
17:00:26 <benzrf> at very least put mint in a vm
17:00:30 <benzrf> ಠ_ಠ
17:00:34 <studmuf> sccrstud92: have you heard of pidgin?
17:00:36 <sccrstud92> johnw: i just read that article haha
17:00:38 <Twey> johnw: I'm not sure I trust that list.  It's got mIRC at the top.
17:00:45 <benzrf> ew ew ew mirc
17:01:05 <indigo> sccrstud92: You can also run irssi off of a VPS (which is what I do)
17:01:15 <Twey> Quassel's supposed to be pretty cool
17:01:17 <johnw> and there are browser-based IRC clients
17:01:21 <sccrstud92> studmuf: sounds familiar but idk what it is
17:01:22 <Cale> qwitwa: Ah, that's probably newer than the last time I used Windows.
17:01:51 <dhrosa> @pl (as, _) +++ (bsLeft, bsRight) = (as ++ bsLeft, bsRight)
17:01:51 <lambdabot> (line 1, column 4):
17:01:51 <lambdabot> unexpected ","
17:01:51 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:01:55 <dhrosa> fai
17:02:02 <dhrosa> @pl f (as, _) (bsLeft, bsRight) = (as ++ bsLeft, bsRight)
17:02:02 <lambdabot> f = (`ap` snd) . (. fst) . ((,) .) . (++) . fst
17:02:07 <dhrosa> yep. nope.
17:02:13 <qwitwa> Cale: Possibly. I think it's at least 2 years old though.
17:02:24 <studmuf> sccrstud92: I've never used it but I've heard good things. I combines many chat clients with IRC
17:02:39 <Cale> Then yeah :)
17:03:14 <qwitwa> Pidgin is basically the go-to plugin-able gui chat client.
17:03:30 <qwitwa> I think I usually hear about it in the context of it's OTR plugin.
17:03:30 <dhrosa> I run irssi through screen on my server, so I can log in and be right where I left off from any computer
17:03:48 <qwitwa> Ew, screen.
17:03:56 <qwitwa> I jest, I've never used anything but Tmux to compare to.
17:04:07 <sccrstud92> k im on xchat now
17:04:38 <sccrstud92> benzrf: i love gnu/linux and bash and vim and i use them a lot
17:04:54 <benzrf> ugh
17:04:57 <sccrstud92> benzrf: just cuz i use windows doesnt mean i dont use those things
17:05:00 <benzrf> alright ;p
17:05:07 <benzrf> im trying to build djinn from source
17:05:13 <qwitwa> sccrstud92: No love for zsh?
17:05:13 <benzrf> and its giving me ambiguous instance erros
17:05:14 <benzrf> :(
17:05:29 <sccrstud92> qwitwa: havent used it =)
17:06:05 <qwitwa> sccrstud92: The killer feature is the plugin architecture and ecosystem the oh-my-zsh framework provides.
17:07:09 <dhrosa> @pl f (as, _) (bsLeft, bsRight) = (as, bsLeft ++ bsRight)
17:07:09 <lambdabot> f = (`ap` snd) . (. fst) . (. (++)) . (.) . (,) . fst
17:07:15 <qwitwa> Gonna go to bed soon. Looking forward to drifting off to The Haskell Cast ;P
17:07:16 <dhrosa> still horrendeous
17:09:30 <randomclown> dhrosa: why not use arrows
17:09:46 <Twey> benzrf: Djinn is dead.  ☹
17:10:11 <DMcGill> \(left, right) -> left ++ right
17:10:15 <DMcGill> == uncurry (++)
17:10:29 <dhrosa> randomclown: I realized that that function isn't actually what I want any
17:10:33 <dhrosa> anywya*
17:10:36 <dhrosa> anyway
17:10:48 <Twey> curry $ fst *** uncurry (++)
17:11:26 <benzrf> nooodl:
17:11:29 <benzrf> *noo
17:12:13 <qwitwa> What does *** mean?
17:12:21 <DMcGill> :t (***)
17:12:21 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:12:38 <DMcGill> take two functions (arrows) and make them work pairwise
17:12:42 <hpc> or in nicer language with (->)
17:12:58 <hpc> (a1 -> b1) -> (a2 -> b2) -> (a1, a2) -> (b1, b2)
17:14:47 * qwitwa wonders if there's an easy way to figure where random functions like that are from
17:14:52 * qwitwa remembers hoogle.
17:15:31 <FireFly> @hoogle (a1 -> b1) -> (a2 -> b2) -> (a1,a2) -> (b1,b2)
17:15:31 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:16:23 <sccrstud92> @hoogle a b c -> a b' c' -> a (b, b') (c, c')
17:16:23 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:16:47 <sccrstud92> i guess hoogle has a problem with (->) ~ a
17:16:53 <Twey> That's unfortunate
17:17:09 <hpc> hoogle isn't the best at searching instances in general
17:25:06 * BMeph_ thinks "someone else" should either make a better hoogle, or make a hoogle better.
17:26:37 * BMeph_ also, prefers '(a ~> b) -> (c ~> d) -> (a, c) ~> (b, d)' as a type description for ***
17:27:29 <qwitwa> :t ~>
17:27:30 <lambdabot> parse error on input `~>'
17:27:36 <qwitwa> :k ~>
17:27:37 <lambdabot> parse error on input `~>'
17:27:42 <qwitwa> My noobage is showing.
17:27:55 <DMcGill> qwita: ~> isn't actually defined
17:27:59 <Cale> can't have infix type variables any more
17:28:15 <DMcGill> BMeph_ means: Arrow (~>) => (a ~> b) -> ...
17:28:23 <DMcGill> but as Cale said, you can't do that anymore anyway
17:28:37 <qwitwa> You could at some point?
17:29:47 <qwitwa> And not even if they're special characters and you infix them with backticks?
17:30:07 <DMcGill> qwitwa: you can do it with functions
17:30:33 <DMcGill> > let (.:.) = (+) in 3 .:. 4
17:30:34 <lambdabot>  7
17:30:42 <DMcGill> you just can't do it in type signatures
17:31:25 <qwitwa> What's the reasoning for that?
17:33:41 <DMcGill> hmm it says you can still do Arrow (~>) => here
17:33:41 <DMcGill> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html
17:33:44 <DMcGill> Cale?
17:34:34 <Cale> oh, that's interesting
17:34:43 <DMcGill> not here though: http://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/data-type-extensions.html
17:35:24 <DMcGill> I guess 'latest' is the latest released and hence hasn't been updated with the changes yet while 7.8.1-rc1 has
17:36:05 <DMcGill> it looks like to be infix, it needs to start with a colon
17:38:48 * qwitwa needs to sleep.
17:38:51 <qwitwa> Bye!
17:43:12 <Kaidelong> is there much reason to use Parsec over Attoparsec if you're parsing Text?
17:43:25 <fragamus> edwardk: how do I get the magnitude of a V3
17:43:27 <prophile> it shortens your .cabal file
17:45:49 <joey_> Can somebody help me with some cabal issues? I'm getting a dependency conflict because of a package "bin-package-db" which is a dependency of ghc, which is a dependency of ghc-mod. I can't find it on hackage, but it's conflicting with the version of binary which another package (Elm) is using
17:46:24 <Twey> fragamus: ‘norm’, http://hackage.haskell.org/package/linear-1.6/docs/Linear-Metric.html#t:Metric
17:46:37 <fragamus> ok
17:46:53 <fragamus> metric looked like it was meant for some freaky sparse matrix stuff
17:46:59 <Twey> Heh
17:47:21 <Twey> It helps to be familiar with mathematical terminology when reading edwardk's docs :þ
17:48:40 <Eduard_Munteanu> Kaidelong: Parsec error reporting is nicer, you can get a general purpose language tokenizer from it, it probably deals better with layered parsing... but I tend to use attoparsec too :)
17:49:40 <Eduard_Munteanu> Not only for performance but attoparsec is nicer to work with in a few ways.
17:56:22 <jmcarthur> yeah, pre-7.6 i think, or if not that, pre-7.4
17:56:31 <jmcarthur> oh, i was scrolled up
17:56:33 <jmcarthur> sorry
18:06:48 <studmuf> I'm back with the same question. How to implement toJson and fromJson for Doubles and lists given this info http://lpaste.net/99544
18:07:24 <studmuf> Do I have to create a type cast from my data type JNum to a double?
18:08:15 <BMeph_> Yes.
18:12:24 <studmuf> BMeph_: thanks. How would I go about that?
18:12:41 <mgoszcz2> What can I use instead of Lists if I need random access (!!) and can only use the Base package?
18:13:42 <Eduard_Munteanu> mgoszcz2: functions :)
18:14:29 <Eduard_Munteanu> mgoszcz2: actually wait, base is larger... use Data.Map.
18:14:52 <startling> possibly IntMap
18:14:58 * Eduard_Munteanu for some reason remembered those being in 'containers'
18:15:04 <startling> if you're not expecting sparse datasets, there are arrays.
18:15:14 <startling> Data.Map is in containers.
18:15:38 <Eduard_Munteanu> The docs show it in 'base' as well. :/
18:15:41 <startling> mgoszcz2, only using base is an onerous requirement.
18:15:48 <startling> eh? http://hackage.haskell.org/package/base
18:16:28 <Eduard_Munteanu> Hrm, I must have clicked somewhere else.
18:16:56 <studmuf> I think I have the toJson done correctly but i'm still not seeing how to implement the fromJson http://lpaste.net/99544
18:17:16 <jmcarthur> oh, i didn't realize Data.HashTable is in base
18:17:21 <mgoszcz2_> Crap. I must set up battery warning in XMonad..
18:17:28 <jmcarthur> it's pretty terrible though
18:18:06 <BMeph_> studmuf: ...I'd suggest you reread the sections of how 'data' 'class' and 'instance' work. I'd noemally just tell you, but.... ;)
18:18:12 <jmcarthur> there's always good ol' Foreign.Marshal.Array </sarcasm>
18:18:25 <BMeph_> Err, *normally
18:19:08 <mgoszcz2_> jmcarthur: Yes but it sound scary...
18:19:15 <jmcarthur> mgoszcz2_: was a joke
18:19:46 <Twey> jmcarthur: Why is it terrible?
18:19:48 <jmcarthur> mgoszcz2_: i think if you are constraining yourself to base you will end up using either Data.HashTable, which sticks you in IO just to use it, or writing your own data structure
18:20:04 <Twey> Oh, because it's in IO
18:20:05 <jmcarthur> Twey: not as fast as it really should be, requires IO
18:20:16 <Twey> Seems like it should work in ST
18:20:24 <jmcarthur> agreed
18:20:27 <jmcarthur> at minimum
18:20:34 <studmuf> BMeph_: Thanks for not just telling me that is a great idea. will do
18:20:43 <jmcarthur> Twey: http://hackage.haskell.org/package/hashtables is much much nicer
18:21:03 <Twey> Ah yes
18:21:08 <jmcarthur> and of course there's unordered-containers
18:21:33 <mgoszcz2_> jmcarthur: While using hash tables looks like an overkill it seems to be the best way..
18:21:41 <Twey> The Cuckoo version seems nice
18:21:51 <Twey> I wonder why it isn't default
18:21:59 <jmcarthur> because it's not generally as fast
18:22:14 <jmcarthur> it just has some nicer guarantees on the lookup time
18:22:18 <Twey> The docs say it's faster on insert and slower ond lookup
18:22:22 <Twey> on**
18:22:28 <jmcarthur> overall maybe
18:22:53 <startling> mgoszcz2_, Data.Map is not a hash table
18:22:53 <jmcarthur> but the worst case bounds on lookup for a cuckoo hashtable can be constant time (maybe not true in that package?)
18:23:01 <jmcarthur> startling: Data.Map is not in base
18:23:01 <startling> mgoszcz2_, Data.HashTable shouldn't be used
18:23:17 <startling> mgoszcz2_: why do you think you can only use base?
18:23:21 <jmcarthur> mgoszcz2_: why the restriction to base, anyway?
18:23:25 <Twey> jmcarthur: As opposed to what?  :þ
18:23:36 <jmcarthur> Twey: linear or logarithmic time
18:23:36 * Twey would like to see a sub–constant-time hash table
18:23:50 <jmcarthur> Twey: most hash tables don't provide worst case constant time lookup
18:24:04 <jmcarthur> Twey: since the buckets can still contain an arbitrary number of values
18:24:06 <Twey> Oh, right, I thought you were making a point against Cuckoo
18:24:08 <startling> That's only possible with a perfect hash function.
18:24:09 <startling> Yeah.
18:24:19 <jmcarthur> no, it was a point for cuckoo
18:24:29 <Twey> Right.  That makes much more sense now.
18:24:32 <jmcarthur> on the other hand, it's slower on average
18:24:55 <mgoszcz2_> jmcarthur: Programming compettions (here's what I'm trying to speed up http://lpaste.net/99547)
18:25:13 <jmcarthur> mgoszcz2_: the containers package is usually included with ghc
18:25:25 <jmcarthur> mgoszcz2_: so try Data.IntMap
18:25:35 <startling> mgoszcz2_: lines 10 and 12 do nothing
18:25:36 <mgoszcz2_> jmcarthur: Ignore the 'seq' - I was wondring wether getting all data first woule speed it up (it didn't)
18:25:37 <Twey> mgoszcz2_: You found a programming competition that accepts Haskell?
18:25:45 * Twey expects they're probably using Hugs
18:26:22 <startling> well, next to nothing.
18:26:46 <Twey> mgoszcz2_: That doesn't get all the data anyway
18:27:06 <sccrstud92> Twey: ive been doing https://www.hackerrank.com/. It accepts haskell for everything AND has a section dedicated to functional programming
18:27:07 <startling> mgoszcz2_: you can reorganize solve to not need (!!).
18:27:10 <jmcarthur> mgoszcz2_: also consider using something like Data.ByteString instead of String
18:27:16 <Twey> It'll evaluate to WHNF, i.e. force the spine up to the first character :þ
18:27:23 <mgoszcz2_> Twey: Australian Informatics Olimpiad Programme seems happy enough with Haskell
18:27:30 <Twey> Neat
18:28:01 <sccrstud92> mgoszcz2: how big is the input file?
18:28:02 <Twey> With the ACM ones you're lucky if you get C++11
18:28:48 <mgoszcz2_> startling: How?
18:29:39 <mgoszcz2_> sccrstud92: 1 <= n, q <= 10,000
18:30:07 <startling> mgoszcz2_, maybe I'm mistaken, but I think folding over ns will do less work
18:30:29 <startling> mgoszcz2_: is it actually a rule that you can only use base?
18:31:04 <startling> mgoszcz2_: if you can use anything in the haskell platform, http://hackage.haskell.org/package/array would make it pretty simple.
18:31:19 <startling> btw, you should be benchmarking
18:31:20 <mgoszcz2_> startling: Their description: Glasgow Haskell Compiler, Version 6.12.1, for Haskell 98, stage 2 booted by GHC version 6.12.1 (using -O -fglasgow-exts)
18:31:49 <mgoszcz2_> startling: I'm profiling it using RTS
18:32:00 <startling> mgoszcz2_: ok, so include the array package in your source.
18:32:07 <startling> or a subset of it.
18:32:53 <startling> how much data are you expecting?
18:33:03 <startling> (small enough to fit in memory?)
18:33:30 <startling> mgoszcz2_: I recommended benchmarking since I would be very surprised if lines 10 and 11 made even a small change.
18:34:03 <startling> you probably want http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-Unboxed.html
18:34:16 <mgoszcz2_> startling: Yup. C can do it in 0.04s. My one berly made it under 1s
18:34:46 <mgoszcz2_> startling: I think if said that they didn't: I just forgot to remove the from the paste
18:35:12 <mgoszcz2_> :%s/if/I/
18:37:02 <sccrstud92> ah a vim user?
19:05:37 <novochar> Is Control.Concurrent.Async the standard method for controlling asynchronous operations?
19:06:00 <novochar> What is the difference between that and http://haskell-distributed.github.io/static/doc/distributed-process-platform/Control-Distributed-Process-Platform-Async.html
19:07:10 <L8D> Does haskell have anything for quickly defined number systems
19:07:12 <L8D> like base42
19:07:22 <L8D> and a way of encoding and decoding them?
19:07:34 <L8D> Or would I need to do all that manually
19:08:12 <c_wraith> L8D: Hmm.  In recent version of GHC, you could actually do that generically, using a type-level literal to put the base in the type.
19:08:25 <c_wraith> L8D: I'm not sure anyone *has*, but it wouldn't be too hard.
19:08:25 <Eduard_Munteanu> L8D: there are libs implementing particular well-known encodings like Base64
19:08:33 <L8D> c_wraith: well, it's more of a custom thing
19:08:36 <L8D> for a coding competition
19:08:48 <prophile> http://hackage.haskell.org/package/digits
19:09:14 <L8D> base42 where a-z is 10-35 and !?@#$% are 36-41
19:09:29 <L8D> and 0-9 is 0-9
19:09:41 <jle`> it looks like digits would work for you
19:09:52 <c_wraith> there's *something* in base that could be used for that, too
19:10:12 <jle`> you'll need to make a custom conversion of your digit to your char of course
19:10:14 <c_wraith> I never can remember the name of it, though
19:10:29 <jle`> because i don't think !?@#$% is anything standard
19:11:11 <L8D> jle`: okay, not too bad
19:11:12 <magicman> http://hackage.haskell.org/package/base-4.6.0.1/docs/Numeric.html showIntAtBase and readInt can be used.
19:11:12 <prophile> map ("0123456789abcefghijklmnopqrstuvwxyz!?@#$%" !!) . digits 42
19:11:19 <jle`> (['0'..'9'] ++ ['a'..'z'] ++ "!?@#$%") !! digit
19:11:23 <novochar> MVar and STM seems to have been the standard for awhile, how do you build apps with distributed memory?
19:13:04 <jle`> novochar: i assume you've read simon marlow's book?
19:13:34 <L8D> I need to decode it
19:13:36 <L8D> not encode
19:14:04 <magicman> See readInt in that module I linked.
19:14:26 <jle`> magicman: awesome
19:14:46 <jle`> i'll forget it exists within a day though and someone will ask again in two :|
19:15:41 <novochar> Within Control.Concurrent.Async.concurrently, are child threads killed if parent threads die for any reason?
19:15:47 <novochar> jle`: No, what is it about?
19:16:06 <jle`> novochar: http://chimera.labs.oreilly.com/books/1230000000929
19:16:31 <L8D> magicman: thanks
19:16:34 <L8D> I think this will work
19:16:36 <jle`> there is a distributed chapter
19:16:52 <jle`> ch 14
19:17:14 <magicman> L8D: You can use something like Data.List.elemIndex for the single character decoding.
19:19:46 <jle`> or a Map Char Int :D
19:21:01 <jle`> fromList (zip digitlist [0..])
19:25:15 <L8D> @src read
19:25:15 <lambdabot> read s = either error id (readEither s)
19:26:38 <prophile> left error . readEither
19:26:39 <prophile> :(
19:27:06 <L8D> @pl \s -> either error id (readEither s)
19:27:06 <lambdabot> either error id . readEither
19:27:11 <L8D> :(
19:31:29 <novochar> What is the difference between STM and Clojure's Core.Async?
19:31:55 <novochar> I think they both use queues
19:33:20 <startling> novochar, that's kind of a confused question.
19:33:20 <AlainODea> novochar: does Core.Async do transactions? I thought that was done elsewhere in Clojure
19:33:44 <novochar> "STM is the preferred concurrency model for Clojure and Haskell." https://stackoverflow.com/questions/17283359/are-there-concurrent-designs-where-the-actor-model-isnt-good-for
19:34:21 <startling> novochar, STM in Haskell is a way to provide mutable variables across multiple concurrently-executing things.
19:35:04 <L8D> @hoogle ReadS a -> Maybe a
19:35:05 <lambdabot> No results found
19:35:10 <AlainODea> novochar: that comment runs directly counter to Stu Halloway's explanation of the Clojure landscape in the Clojure Inside Out course. He said STM is rarely used in practice on Cllojure if I heard him correctly
19:36:32 <startling> That's what I've heard also.
19:37:47 <AlainODea> novochar: Haskell is in a better position to provide STM with sensible guardrails since it can make the use of non-transaction effects compile errors.
19:38:13 <AlainODea> novochar: Datomic solves this problem in a different way entirely from what I understand.
19:43:36 <studmuf> Having trouble figuring out where I'm going wrong in this http://lpaste.net/99548
19:44:14 <studmuf> The output makes me think I approach this problem the wrong way
19:50:29 <pavonia> studmuf: lines 39-40 seem weird, you insert x and y multiple times
19:51:35 <studmuf> pavonia: ok that makes sense
19:51:57 <studmuf> pavonia: should it look something like this
19:52:33 <studmuf> | x > k = (Node x y (ins l) r)
19:53:06 <studmuf> | otherwise = (Node x y l (ins r))
19:53:08 <studmuf> ?
19:53:18 <pavonia> No, you should leave the old x and y untouched
19:53:44 <studmuf> so
19:53:53 <studmuf> | x > k = (Node (ins x y l) r)
19:54:08 <studmuf> | otherwise = (Node l (ins x y r))
19:54:13 <studmuf> ?
19:54:18 <pavonia> Now they are missing completely :)
19:54:46 <studmuf> Haha
19:55:00 <studmuf> Ok
19:55:22 <pavonia> What are the variable names of the old x and y?
19:55:59 <studmuf> what do you mean by old variable names?
19:56:43 <pavonia> I mean the key/values already present in that Node
19:56:56 <studmuf> Ohhhhh!
19:57:05 <pavonia> When you pattern match on the node, you give a name to them
19:57:36 <studmuf> so in my code that would be k and v
19:57:50 <studmuf> being the existing key value pairs
19:58:05 <pavonia> k is correct but you ignore the old value
19:58:31 <studmuf> and if the key exist it is replaced by new value y (line 38)
19:58:59 <studmuf> That sound right?
19:59:10 <pavonia> yes
20:00:56 <pavonia> studmuf: Note that in the pattern "Node k _ l r" you're ignoring v by using a wildcard, so you can't use the old value for v on the right-hand side
20:01:01 <studmuf> ok so then on line 39 I check the new key (x) against the old key (k) and if x is greater I call insert again passing in the new key and value (y) to the left branch
20:01:33 <studmuf> pavonia: thanks missed that
20:03:19 <studmuf> pavonia: that fix has not changed my output at all
20:03:42 <pavonia> Yeah, because you function definition is still incorrect :p
20:04:13 <enthropy> @hoogle linspace
20:04:13 <lambdabot> No results found
20:04:16 <studmuf> haha
20:05:26 <pavonia> "x > k = (Node x y (ins x y l) r)" <-- x and y are the new key/value pair to be inserted, so you use it in the old node *and* in all subordinate nodes
20:06:31 <fragamus> @pl flatten (map makePairs x)
20:06:31 <lambdabot> flatten (map makePairs x)
20:06:53 <studmuf> pavonia: I'm assuming that's not what that line is doing...
20:06:54 <fragamus> @pl (\x->flatten (map makePairs x))
20:06:54 <lambdabot> flatten . map makePairs
20:07:26 <pavonia> studmuf: That is what it's doing but not what you want
20:07:43 <studmuf> oh ok.
20:08:02 <fragamus> hey guys flatten . map seems like it should be replaced here   can you weigh in
20:08:43 <studmuf> so instead maybe "x > k = (ins x y l) r
20:08:51 <studmuf> pavonia: ???
20:09:10 <pavonia> No, now you don't create the new node
20:09:18 <studmuf> haha
20:09:22 <studmuf> i'm lost
20:10:06 <studmuf> that's why i had the Node creation
20:10:28 <pavonia> How do you create a node that is exactly the same as the old node?
20:10:41 <studmuf> copy it?
20:11:10 <pavonia> So it loks like what?
20:11:38 <studmuf> x > k = (Node k v (ins x y l) r)
20:12:21 <pavonia> hhm, that's not the answer to my question but the correct solution for your problem :)
20:13:29 <pavonia> If your pattern match looks like "Node k v l r" you'll get the same node by using "Node k v l r" on the right-hand side
20:13:30 <studmuf> pavonia: thank you for painfully pulling me through that. I'm so tired but need to get this right
20:13:45 <pavonia> you're welcome
20:13:54 <td123> studmuf: you could also give it a pattern synonym
20:14:08 <studmuf> td123: how would that work?
20:14:14 <td123> so node@(Node a b c d) = node
20:14:35 <pavonia> That wouldn't help in that definition, though
20:14:35 <td123> node on the right side would refer to Node a b c d
20:16:41 <studmuf> pavonia: still not quite right. http://lpaste.net/99548
20:17:43 <pavonia> That may be your Show instance. Why not deriving an instance?
20:18:16 <studmuf> part of the learning experience =D
20:19:15 <pavonia> Okay, so you have to show l before v
20:20:36 <pavonia> Also, "show foo" and "(show foo)" yield the same result. If you want parentheses in your output, you have to use  "(" ++ show foo ++ ")"
20:20:50 <studmuf> because it's on the left! makes sense
20:22:04 <pavonia> I think your tree is sorted backwards
20:22:39 <studmuf> I'm thinking so as well
20:26:15 <studmuf> I flipped the sign on line 38 so it reads x < k = (Node k v (ins x y l) r))
20:26:32 <studmuf> which gave me> "ipsum""Lorem""sit""dolor""amet"
20:26:50 <studmuf> still seems like things are flipped
20:27:09 * studmuf well doesn't seem. is
20:27:50 <pavonia> Could you update the paste please?
20:27:56 <studmuf> sure
20:28:36 <fragamus> @pl (\x->filter (\(k,v)->k==x) (pairsForEach vocabulary))
20:28:36 <lambdabot> flip filter (pairsForEach vocabulary) . (`ap` snd) . (. fst) . (const .) . (==)
20:29:14 <studmuf> http://lpaste.net/99548
20:30:13 <pavonia> line 48
20:30:46 <studmuf> pavonia: thanks
20:37:21 <fragamus> @pl filter (\(k,v)->k==key)
20:37:21 <lambdabot> filter ((key ==) . fst)
20:39:17 <fragamus> @pl (\key->hits key (pairsForEach vocabulary))
20:39:17 <lambdabot> flip hits (pairsForEach vocabulary)
20:39:39 <Twey> fragamus: Some people prefer (pairsForEach vocabulary `hits`)
20:40:03 <fragamus> yes me 2
20:40:09 <Twey> Er, (`hits` pairsForEach vocabulary)
20:41:12 <fragamus> can you magic this:    filter ((key ==) . fst)
20:42:10 <Twey> fragamus: Re. the earlier question, if you have a function ‘flatten’ you might have a Monad, in which case you can use (>>=)
20:42:20 <Twey> It depends on your type, though
20:42:38 <Twey> fragamus: ‘Magic’ it how?  It's already point-free
20:42:46 <Twey> And flip-free :þ
20:42:55 <fragamus> Yeah
20:44:06 <Twey> fragamus: For example the list monad's ‘flatten’ (usually called ‘join’) is concat, so:
20:44:16 <Twey> > ["foo", "bar", "baz"] >>= reverse
20:44:17 <lambdabot>  "oofrabzab"
20:45:02 <fragamus> nice
20:45:17 <fragamus> you can have a look at my paste in a bit
20:45:32 <Twey> Hooray!  Thanks!  :þ
20:47:58 <hakujin> is the preferred hash map these days Data.HashMap from unordered-containers?
20:49:08 <Cale> hakujin: Yeah, if you really want one which does hashing
20:49:48 <jle`> is there any way to drop a diagonal from a list-of-lists matrix?
20:49:52 <jle`> any clean way
20:49:54 <jle`> :|
20:50:43 <jle`> hm actually i remember seeing one in simon marlow's book
20:51:29 <fragamus> http://lpaste.net/99552
20:51:30 <Twey> ‘Drop’?
20:51:52 <Twey> There are two ways to remove the diagonal from a matrix
20:52:01 <jle`> [[1,2,3],[4,5,6],[7,8,9]]  --> [[2,3],[4,6],[7,8]]
20:52:41 <jle`> actually what i really wanted was [1,2,3] --> [[2,3],[1,3],[2,3]], and i already have something for that i think
20:57:31 <Twey> > zipWith (++) (inits l) (drop 1 <$> init (tails l))
20:57:32 <lambdabot>  Couldn't match expected type `[a0]'
20:57:32 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
20:57:32 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
20:57:50 <Twey> > let l = [1, 2, 3] in zipWith (++) (inits l) (tail <$> init (tails l))
20:57:51 <lambdabot>  [[2,3],[1,3],[1,2]]
20:59:13 <Twey> > zipWith (++) <$> inits <*> (fmap tail . init . tails) $ [1, 2, 3]
20:59:14 <lambdabot>  [[2,3],[1,3],[1,2]]
20:59:22 <Twey> Eh, unnecessary brackets
20:59:53 <jle`> > let l = [1,2,3]; go xs [] = []; go xs (y:ys) = (xs++ys):go (y:xs) ys in go [] l
20:59:55 <lambdabot>  [[2,3],[1,3],[2,1]]
21:00:10 <jle`> oh, does not preserve ordering. how unfortunate
21:08:07 <meditans> hi, I'm experiencing some problems in installing the "hat" package (haskell tracer)
21:08:35 <meditans> http://lpaste.net/99554
21:10:39 <Cale> meditans: oh wow, Hat still exists!
21:11:39 <meditans> cale: and it's not advertized.. i was searching for something like this and stumbled upon it by chance
21:12:02 <meditans> cale: only thing, it's not running xd
21:12:35 <Cale> I'll see if I get the same build error you do
21:13:05 <meditans> cale: thanks, it seems it's something related to the source, not external packages
21:18:24 <Cale> meditans: aha, here's a similar problem in a different program
21:18:27 <Cale> https://github.com/djv/VisualProf/issues/3
21:18:41 <Cale> Apparently haskell-src-exts has changed some of its datatypes
21:18:57 * hackagebot pipes-attoparsec 0.4.0 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.4.0 (RenzoCarbonara)
21:18:59 <Cale> and so the version of it that gets used needs to be constrained a bit better
21:20:59 <Cale> I'm going to try  cabal unpack hat  and then set the dependency haskell-src-exts==1.13.3
21:21:00 <meditans> cale: I see.. I'm changing the cabal file to costrain it to version 1.13.3, as it's written in the page you posted. Thanks!
21:22:29 <enthropy> Cale: you know you can  cabal install hat --constraint haskell-src-exts==1.13.3?
21:23:04 <Cale> enthropy: ah, I didn't know that
21:23:36 <enthropy> it should be relatively easy to update hat
21:23:39 <meditans> enthropy: great, I'm doing that!
21:24:00 <enthropy> might be that it has been updated already, just not released yet?
21:28:20 <jfischoff> enthropy: that's a good tip about --constraint
21:29:00 <jfischoff> I want to post it on @HaskellTips, I'll credit you if have a twitter handle
21:29:01 <meditans> cale, enthropy: ok, installing with the fixed dependency worked, thanks!
21:29:33 <enthropy> no credit needed, it (should be) common knowledge
21:29:40 * jfischoff nods
21:30:06 <jfischoff> to the twittermobile!
21:31:26 <bitemyapp> jfischoff: I was forced to use constraint to experiment with what it would take to get a build working the other day, it's fantastic.
21:31:54 <bitemyapp> jfischoff: but the reason I knew it existed was because the read the documentation. People should read documentation/man-pages more often, even if you don't remember syntax precisely, it makes a mental map of what's possible.
21:32:16 <bitemyapp> jfischoff: perhaps a Haskell tip about documentation?
21:32:27 <jfischoff> hey glad your coming to the Dojo this Thursday. Last time it was a bunch of Haskell lightning talks
21:33:06 <jfischoff> yeah that is what a lot of the tips are turning into :p
21:33:28 <jfischoff> basically the doc slowly distributed in twitter form
21:35:44 <jfischoff> bitemyapp:you gave me an evil tip ;)
21:36:55 <jmob> hey it's that guy I gave a ride to at the last meetup :-P
21:40:00 <orzo> does haskell have matches operator
21:40:14 <orzo> a ~ [] would be true if the pattern matches
21:40:20 <orzo> if a is the empty list
21:41:17 <apples`> ~ can be a constraint for type equality, i think. to do something like what you said, i think you'll have to use a case
21:43:05 <orzo> hm, thats what i thought
21:43:19 <sccrstud92__> @pl f factor = sum . map (* factor)
21:43:19 <lambdabot> f = (sum .) . map . (*)
21:43:39 <sccrstud92__> @pl f (factor, ps) = sum . map (* factor) $ ps
21:43:40 <lambdabot> f = uncurry ((sum .) . map . (*))
21:44:26 <bitemyapp> jmob: are you in the bay area?
21:45:25 <jmob> yes, I work in sf, live in dc
21:45:55 <bitemyapp> jmob: there's a meetup tomorrow, if you're in SF I can give you a ride down.
21:45:59 <roscareyes> jmob
21:46:01 <roscareyes> fuck you idiot
21:46:08 <bitemyapp> well that's rude.
21:46:08 <roscareyes> i am going to beat the living shit out of you
21:46:26 <roscareyes> this will be the last time you cheat on me
21:46:37 <roscareyes> it was my mistake for dating a 14 y/o boy bitemyapp
21:46:39 <roscareyes> sorry
21:46:41 <roscareyes> well
21:46:46 <roscareyes> i met him a a coffee shop
21:46:50 <maxiepoo> @ops
21:46:50 <lambdabot> Maybe you meant: pl oeis docs
21:46:53 <roscareyes> he looked at me with a twinkle in his eyes
21:47:08 <roscareyes> and I offered him some weed in exchange for him letting me suck his dick
21:47:14 <roscareyes> he accepted
21:47:27 <maxiepoo> @where ops
21:47:28 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:47:37 <roscareyes> and i slurped on it until his hot sweet salty cum gushed into my mouth and down my throat
21:47:40 --- mode: ChanServ set +o copumpkin
21:47:44 --- mode: copumpkin set +b *!uid25044@gateway/web/irccloud.com/x-iabzwrutnxuxjlqg
21:47:44 --- kick: roscareyes was kicked by copumpkin (go away)
21:47:47 --- mode: copumpkin set -o copumpkin
21:47:47 --- mode: ChanServ set +o edwardk
21:47:48 <L8D> > tail []
21:47:49 <lambdabot>  *Exception: Prelude.tail: empty list
21:47:55 <bitemyapp> copumpkin: thank you kindly.
21:48:12 <L8D> > take 1 []
21:48:13 <lambdabot>  []
21:48:22 <bitemyapp> L8D: please don't write tailMaybe and headMaybe except as pedagogy.
21:48:40 <L8D> bitemyapp: what?
21:49:05 <L8D> > drop 1 []
21:49:06 <lambdabot>  []
21:49:12 <jmob> bitemyapp: yeah? I work downtown
21:49:17 <bitemyapp> L8D: teasing a bit. new people will get irritated that tail/head are partial and write their own versions that wrap in Maybe.
21:49:29 <bitemyapp> jmob: doesn't matter precisely where as I have a car, but I work in SOMA.
21:49:33 <L8D> bitemyapp: nah, I'll just use take 1 or drop 1
21:49:53 <bitemyapp> L8D: you can't just pattern match? :P
21:49:59 <L8D> I could
21:50:06 <L8D> but I'm not writing function
21:50:08 <L8D> ss
21:51:49 <L8D> @pl foo bar baz
21:51:49 <lambdabot> foo bar baz
21:51:55 <L8D> @pl foo bar `id ` baz
21:51:56 <lambdabot> (line 1, column 12):
21:51:56 <lambdabot> unexpected " "
21:51:56 <lambdabot> expecting operator
21:51:58 <L8D> @pl foo bar `id` baz
21:51:58 <lambdabot> foo bar baz
21:52:11 <L8D> foo `id` bar `id` baz
21:52:16 <L8D> @pl foo `id` bar `id` baz
21:52:16 <lambdabot> foo bar baz
21:52:29 <L8D> @pl foo $ bar $ baz
21:52:29 <lambdabot> foo (bar baz)
21:53:03 <L8D> @pl fromJust . (`elemIndex` xs)
21:53:03 <lambdabot> fromJust . (`elemIndex` xs)
21:53:07 <L8D> :(
21:54:01 * hackagebot purescript 0.3.9 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.9 (PhilFreeman)
21:54:03 * hackagebot ipopt-hs 0.3.0.0 - haskell binding to ipopt including automatic differentiation  http://hackage.haskell.org/package/ipopt-hs-0.3.0.0 (AdamVogt)
21:55:25 <BlankVerse_> In a monad, say IO, i can extract the Bool out of IO Bool using <-  and then use the Bool value in a case statement
21:55:42 <BlankVerse_> f :: IO Bool
21:55:52 <BlankVerse_> v <- f
21:55:56 <BlankVerse_> case v of ...
21:56:13 <BlankVerse_> how do I do it directly in case :- case f of ..
21:56:21 <L8D> BlankVerse_: yes, as long as whatever you're returning is IO
21:56:36 <jrmithdobbs> you cannot with IO because it's type constructors aren't exposed
21:56:50 <L8D> jrmithdobbs: return?
21:56:52 <BlankVerse_> case f wont work, it expects IO Bool
21:57:13 <BlankVerse_> whereas I am trying to match with the result of type Bool
21:57:41 <L8D> BlankVerse_: Either do v <- f;case v of ... or f >>= \v -> case v of ...
21:58:12 <jrmithdobbs> :t f >>= (\x -> case x of True -> True; False -> False)
21:58:13 <lambdabot>     Couldn't match expected type `m0 b0' with actual type `Bool'
21:58:13 <lambdabot>     In the expression: True
21:58:13 <lambdabot>     In a case alternative: True -> True
21:59:03 <L8D> :t return True >>= (\x -> if x then True else False)
21:59:04 <lambdabot>     Couldn't match expected type `m0 b0' with actual type `Bool'
21:59:04 <lambdabot>     In the expression: True
21:59:04 <lambdabot>     In the expression: if x then True else False
21:59:29 <L8D> oh
21:59:33 <jrmithdobbs> right
21:59:39 <L8D> :t return True >>= (\x -> if x then return True else return False)
21:59:40 <lambdabot> Monad m => m Bool
21:59:44 <L8D> there we go...
21:59:46 <jrmithdobbs> the error was my point :)
21:59:48 <L8D> or...
22:00:00 <L8D> :t return True >>= (\x -> return if x then True else False)
22:00:01 <lambdabot> parse error on input `if'
22:00:05 <L8D> :(
22:00:15 <L8D> I haven't used haskell conditionals in a while
22:00:26 <L8D> jrmithdobbs: he can still use fmap though
22:00:35 <L8D> no need for a bunch of messy returns
22:01:06 <BlankVerse_> can I do something in the case statement, say
22:01:33 <BlankVerse_> case (magic f) of True -> do something False-> something else
22:01:56 <BlankVerse_> so that magic f evaluates f and returns a bool for pattern matching
22:02:13 <jrmithdobbs> :t fmap
22:02:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:02:37 <jrmithdobbs> :t fmap id (Just True)
22:02:38 <lambdabot> Maybe Bool
22:03:08 <L8D> BlankVerse_: I'm not entirely sure what you're asking for...
22:03:23 <studmuf> :t map
22:03:24 <lambdabot> (a -> b) -> [a] -> [b]
22:03:59 <L8D> perhaps: (\v -> case v of True -> do something; False -> do something) `fmap` f
22:04:20 <L8D> BlankVerse_: do you want a boolean to see if something pattern matched?
22:05:28 <jrmithdobbs> BlankVerse_: you're wanting some IO a -> a function, basically, if I'm understanding you?
22:08:02 <enthropy> > [1,2,3] >>= \case 2 -> 'a'; _ -> 'b'
22:08:03 <lambdabot>  <hint>:1:14: parse error on input `case'
22:08:31 <L8D> enthropy: [] is not a monad
22:08:36 <enthropy> need some -XLambdaCase
22:08:46 <enthropy> you would be surprised
22:09:02 <enthropy> > [1,2,3] >>= \x -> case x of 2 -> "a"; _ -> "b"
22:09:03 <lambdabot>  "bab"
22:09:14 <L8D> wtf
22:09:55 <BlankVerse_> L8D: you guessed it right -> (\v -> case v of True -> do something; False -> do something) `fmap` f
22:10:08 <BlankVerse_> i thought I could have some syntatic sugar for it
22:10:20 <BlankVerse_> inside the case statement
22:11:06 <L8D> BlankVerse_: why not do an if then statement?
22:11:16 <enthropy> it's pretty much sugar if you have a lambdacase, and use >>= or maybe the <&> (flipped <$>)
22:11:17 <L8D> It's cleaner and will stay on one line if you need it
22:11:19 <giantdildo> how much money do male escorts make?
22:11:42 <L8D> (\v -> if v then do something else do something) `fmap` f
22:11:44 <enthropy> L8D: case fits on one line too
22:11:52 <L8D> enthropy: with the ugly ;
22:12:43 <BlankVerse_> I was looking for the following
22:13:16 <BlankVerse_> case (magic f) of True -> do something;False -> do something) <==> (\v -> case v of True -> do something; False -> do something) `fmap` f
22:14:01 <BlankVerse_> and this can only be done by syntatic transformation
22:15:14 <Twey> BlankVerse_: I wouldn't use case at all; I would use bool f t p = if p then t else f, and say: f >>= bool x y
22:15:28 <giantdildo> let's have a giant orgy
22:15:37 <L8D> what Twey said
22:15:47 <Twey> For bigger data-types it can be useful to use >>= and LambdaCase, like: f >>= \case True → x; False → y
22:16:50 <Twey> And of course if you're just going to ‘return’ both branches you can use <&>:  f <&> bool x y  /  f <&> \case True → x; False → y
22:17:21 <zipper> There is someone with a name starting with Yohan who writes on data structures in haskell. What is his full name?
22:17:46 <Twey> zipper: Are you thinking of Johan Tibell?
22:18:03 <zipper> Twey: Aha I think that is the name
22:18:05 <bitemyapp> ah yes the unordered-containers person.
22:18:06 <Twey> (IRC nick ‘tibbe’)
22:18:09 <bitemyapp> much love for that character.
22:18:27 <zipper> I heard "Read what yohan tibel writes on data structures"
22:18:55 <zipper> but I was afraid I'd get the whole name wrong. Not even sure if I had heard right.
22:18:58 <prophile> it seems like every well known haskeller aside from the simons can be found in #haskell
22:19:04 <Twey> zipper: It's ‘Johan’ — it's a German(ic) name
22:19:20 <zipper> Twey: Oh lol my apologies
22:19:26 <zipper> @seen tibbe
22:19:27 <lambdabot> TIBB3
22:19:38 <Twey> Heh
22:19:39 <zipper> This bot is weird
22:19:49 <Twey> She's… idiosyncratic
22:19:56 <Twey> Full of personality!
22:20:23 <bitemyapp> prophile: the cool people are here.
22:20:38 <bitemyapp> zipper: go look at unordered-containers, then Johan's blog.
22:20:40 <jle`> huh where is preflex these days
22:21:07 <jle`> wouldn't it be funny if lambdabot has been a real person this whole time
22:22:00 <zipper> It feels like everyone in Haskell is really really smart and with tons of experience.
22:22:20 <bitemyapp> zipper: nope.
22:22:22 <L8D> zipper: nope
22:22:41 <zipper> bitemyapp: Looking at then and all I can find is still tibbe on github
22:22:43 <Twey> @vixen Are you a real person?
22:22:44 <lambdabot> The press is the enemy.
22:22:55 <bitemyapp> zipper: you learn by learning not by having been statically installed into some lofty tier of knowledge.
22:22:57 <Twey> Hm, could go either way.
22:23:29 <bitemyapp> zipper: http://www.youtube.com/watch?v=Dn74rhQrKeQ http://blog.johantibell.com/
22:23:41 <L8D> zipper: also, even though it seems like Haskell takes a lot of skill in mathematics and such...it really doesn't
22:24:03 <Twey> Haskell's easy.  It's just that it's sufficiently powerful that people like to do crazy stuff with it.
22:24:19 <jle`> in haskell it's just right there like low hanging fruit
22:24:21 <L8D> Haskell is remarkably easy compared to writing really nice and compliant low-level C code
22:24:27 <zipper> bitemyapp: Thanks mate :)
22:24:53 <bitemyapp> if you do any Haskell for a living, Johan's blog is seriously the tops.
22:25:01 <Twey> L8D: I think that's rather comparing two different kinds of difficulty :þ
22:25:09 <bitemyapp> great ops, general coding, data structures, etc stuff
22:25:10 <L8D> Twey: that's the point
22:25:22 <bitemyapp> L8D: THANK YOU
22:25:35 <bitemyapp> L8D: I *hate* this meme that writing C, let alone correct C, is somehow easy.
22:25:39 <Twey> Haskell is hard(er) to write and easy(/-ier) to get right.  C is easy(/-ier) to write and damn hard to get right.  :þ
22:25:46 <L8D> most of my non-haskell coder friends think that haskell is some ideal and crazily complicated mathematics language
22:25:49 <bitemyapp> experienced C programmers are freakin' alwyers for a reason.
22:25:52 <bitemyapp> lawyers*
22:26:10 <zipper> bitemyapp: lawyers?
22:26:19 <Twey> bitemyapp: It's because the language never tells you when you've screwed up, so you need to know all the ways you can possibly go wrong in advance.  :þ
22:26:52 <bitemyapp> Twey: retaining the UB/etc in your head is insane.
22:27:04 <bitemyapp> zipper: you have to memorize the C standard to know what's permissible/safe and what isn't.
22:27:13 <dolio> bitemyapp: I thought not being easy was the point.
22:27:15 <L8D> also, there's javascript
22:27:19 <Twey> zipper: ‘Language lawyers’, I presume
22:27:20 <bitemyapp> zipper: there's a huge surface area, sometimes with rather scary source->sink distances of things that can fuck you
22:27:23 <zipper> bitemyapp: Wow that must suck.
22:27:25 <dolio> That way when you do it you're awesome.
22:27:38 <bitemyapp> dolio: I have people tell me C is "simple" all the time.
22:27:42 <Platz> L8D: I've noticed a lot of discussion surrounding haskell involves CT, so yeah, math
22:27:44 <dolio> Huh.
22:27:50 <bitemyapp> I assume that they haven't written much C when say that to me.
22:27:54 <zipper> Twey: I thought it meant that they couldn't make money programming and turned to law.
22:27:54 <dolio> Maybe that's because they're so awesome.
22:28:02 <bitemyapp> I used to write a lot of C, I remember fear and loathing and blood-splattered walls.
22:28:08 <bitemyapp> not "simple"
22:28:09 <Twey> C is simple(…ish).  Writing C that works is less so.
22:28:18 <bitemyapp> when I started compiling my code with g++, I actually started catching more errors.
22:28:29 <bitemyapp> Twey: it's really not simple at all. Nothing about C is simple.
22:28:42 <L8D> Platz: I've seen haskell primarily used for data analysis, but I primarily use it for data translation...
22:28:44 <bitemyapp> Twey: not the language syntax, semantics, standard, writing it, none of it.
22:28:52 <jle`> C is easy...just pretend you're working in assembly
22:28:55 <Twey> The C standard is pretty easy to follow compared to, say, C++.
22:29:07 <bitemyapp> C++ is worse in some places, but you can at least recruit the somewhat stronger type system to save you occasionally.
22:29:14 <jle`> and don't use arrays or dynamically allocate anything
22:29:20 <L8D> Platz: But all the *real* mathematicians who write programs use languages that are truly compliant to mathmetical principals
22:29:21 <jle`> dynamic allocation is the devil
22:29:23 <zipper> I'm surprised MSFT research has so much on haskell.
22:29:26 <Twey> And it has less syntax than Haskell (that you'll encounter on a daily basis)
22:29:28 <bitemyapp> Twey: yeah but you're more likely to get some classes of mistakes caught statically in C++.
22:29:33 <zipper> Don't they have F# to worry about.
22:29:35 <L8D> *cough cough* agda *cough cough*
22:29:40 <jle`> bitemyapp: at least C doesn't baby you
22:29:43 <jle`> :P
22:29:44 <Twey> zipper: SPJ works at MSR
22:29:44 <bitemyapp> Twey: and C++ has a better culture around automatic memory allocation.
22:29:50 <Twey> Aye
22:29:56 <zipper> Plus everyone says MSFT is not cool so that adds to the shock
22:30:00 <Twey> I didn't say it was *better*, I just said it was simpler :þ
22:30:02 <zipper> Twey: Who?
22:30:08 <bitemyapp> zipper: MSR is an incredible organization.
22:30:12 <giantdildo> I CAN SAY NIGGER ON THE INTERNET
22:30:16 <bitemyapp> MSR redeems MSFT as a company and then some.
22:30:19 <bitemyapp> @where ops
22:30:19 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:30:24 <Platz> L8D: yes, I agree.  I'm talking less aobut how haskell is used, versus what people talk about when discussing it
22:30:28 --- mode: ChanServ set +o dolio
22:30:29 <Twey> zipper: Simon Peyton-Jones, one of the original people behind Haskell/GHC.
22:30:32 --- mode: ChanServ set +o Cale
22:30:33 <Twey> dolio: Ah, thank you
22:30:34 --- mode: edwardk set +b *!~smoke@pool-71-177-95-243.lsanca.fios.verizon.net
22:30:35 --- kick: giantdildo was kicked by edwardk (Your behavior is not conducive to the desired environment.)
22:30:37 <Twey> Haha
22:30:42 <dolio> Damn.
22:30:42 <bitemyapp> dolio: thank you. What's going on with the trolls tonight?
22:30:44 <zipper> giantdildo: I am black and I wish you could not say nigger anywhere.
22:30:53 --- mode: ChanServ set -o dolio
22:30:53 <bitemyapp> zipper: don't respond to trolls.
22:31:03 <bitemyapp> zipper: they're gone anyway.
22:31:27 <dolio> Oh, edwardk was already opped.
22:31:31 <dolio> Wasn't fair.
22:31:40 <c_wraith> dolio: banning isn't a race.
22:31:47 <bitemyapp> c_wraith: yes it is >:)
22:31:48 <edwardk> dolio: yeah. after the first troll of the evening i tend to stay armed
22:31:52 <Twey> dolio: But you were already paying attention to the channel!
22:31:59 <bitemyapp> edwardk: repeat offenders swapping IP addresses?
22:32:04 <copumpkin> dolio is used to giantdildo
22:32:05 * edwardk shrugs
22:32:10 <zipper> Twey: lol yeah I'm often surprised by all the cool stuff coming out of MSR
22:32:26 <Twey> zipper: It's a shame how little of it makes it into MS' product line
22:32:37 <L8D> Is there some kind of F# equivalent for Java?
22:32:41 <L8D> not clojure
22:32:42 <Twey> L8D: There's Scala
22:32:46 <dolio> Heh.
22:32:46 <Twey> But, er, well.
22:32:47 <zipper> Twey: Then why does MS fund them?
22:32:49 <Platz> L8D: So folks dropping by r/haskell or #haskell probably get more CT exposure than use dictates.  Plus, don't forgot all the speakers at conferences, CT seems to be very popular to talk about these days
22:32:50 <iross> Twey: Very true.  MSR sometimes seems like a marketing thing for MS.
22:32:50 <bitemyapp> L8D: Scala, but Scala is spooky and ooky and icky.
22:33:02 <jle`> scala is trendy these days
22:33:03 <zipper> iross: marketing how?
22:33:03 <bitemyapp> iross: it's an excellent way to recruit smart people.
22:33:13 <bitemyapp> iross: MSR is a better tenure for smart people in CS than actual tenure.
22:33:18 <zipper> Platz: CT?
22:33:18 <Twey> zipper: They do integrate *some*.  It's just surprisingly little compared to MSR's overall output.
22:33:26 <iross> zipper: They get their name all over some very cool papers.
22:33:31 <L8D> something like F# for Java.
22:33:42 <L8D> It needs to have some of the semantics of ML/Haskell
22:33:43 <Platz> zipper: category theory
22:33:46 <L8D> and the same syntax
22:33:48 <bitemyapp> L8D: there's an ML derivative for the JVM called Yeti.
22:33:55 <bitemyapp> that's the closest thing you'll get.
22:33:56 <iross> bitemyapp: Oh yeah, I'd rather be at MSR than in a uni CS dept.
22:33:57 <L8D> not groovy, clojure, or scala
22:33:59 <bitemyapp> Good luck compiling it.
22:34:02 <dolio> There are Haskell-like things.
22:34:02 <L8D> bitemyapp: I'll check that out
22:34:06 <bitemyapp> iross: precisely.
22:34:09 <dolio> Frege, CAL.
22:34:14 <zipper> Since I started learning haskell I have seen many papers on haskell.
22:34:14 <bitemyapp> if you want Haskell, then Frege, but Frege is similarly...young.
22:34:19 <zipper> from MSR
22:34:24 <zipper> actually most
22:34:59 <iross> MSR does a huge amount of really interesting work.  It just seems that MS, the company, doesn't exploit it a lot.
22:35:15 <Platz> I'm keeping my eye on FStar http://research.microsoft.com/en-us/projects/fstar/
22:35:33 <Twey> iross: I think that's perhaps ascribing a bit too much cohesion to MS
22:35:50 <L8D> bitemyapp: frege looks like
22:35:52 <L8D> nice*
22:35:56 <Twey> The impression I get is that they're effectively many different companies now, and there isn't much communication between them
22:37:12 <bitemyapp> iross: eh, they do.
22:37:28 <bitemyapp> iross: LINQ, a lot of C# and F# stuff, Kinect have all come from MSR work.
22:37:45 <bitemyapp> it's just that they generally don't shanghai a good swath of their MSR people directly into product dev.
22:38:32 <zipper> http://www.youtube.com/watch?v=iSmkqocn0oQ
22:39:12 <NemesisD> hey guys. i'm trying to do something along the lines of: do x <- xs; y <- maybeY x; z <- maybeZ x; return (x, y, z); this is essentially combining the list and maybe monads
22:39:13 <iross> bitemyapp: Huh. Didn't know Kinect was an MSR thing!
22:39:20 <triliyn> Isn't there a person named frege who apparently hangs out in this channel?
22:39:30 <triliyn> *occasionally
22:39:36 <NemesisD> is there something i could do with transformers to make this work? or should i just use the maybe monad and wrap everything in a mapM or something
22:40:00 <zipper> Industry research branches are writing more papers than academia :)
22:40:08 <zipper> O_o
22:40:13 <bitemyapp> iross: all the research behind the CV involved was MSR, yeah.
22:40:30 <iross> bitemyapp: Interesting.
22:40:40 <Twey> NemesisD: do { x ← xs; return $ do { y ← maybeY x; z ← maybeZ x; return (x, y, z) } }
22:40:55 <bitemyapp> I've nabbed one person, does anybody else in SF need a ride to MV tomorrow for the Haskell meetup?
22:41:21 <Twey> NemesisD: Or, equivalently, do { x ← xs; return $ (,,) <$> x <*> maybeY x <*> maybeZ x }
22:42:55 <zipper> Although haskellers really nned to start puting the commas at the end of statements when writing in record syntax and not at the beginning. Looks less cryptic that way.
22:43:37 <Twey> NemesisD: Or you can give it a type like MaybeT [] (x, y, z) and say: do { x ← xs; y ← lift $ maybeY x; z ← lift $ maybeZ x; return (x, y, z) } (and analogous Applicative equivalents)
22:44:10 <dolio> Maybe C people should start putting their semi-colons at the beginning of lines.
22:44:11 <codygman> zipper: Really? I think it looks nicer. It looks weird to have the type signature followed by a comma
22:46:01 <jle`> zipper: i think leading comma actually looks a lot nicer...and it's also a lot more practical, and makes more sense to align
22:46:39 <zipper> I read that these "syntax things" that don't really add value should go at the end and they make reading easier that way since they don't get in the way. I got accustomed to it.
22:46:43 <NemesisD> Twey: ah wait, the result of this computation should be [(x,y,z)], and a nothing on y or z should move on to the next one
22:47:18 <NemesisD> Twey: so would it actually have to be ListT (which i hear is broken?)
22:49:04 <Twey> NemesisD: So where does the Maybe come in?
22:49:19 * SaBer used (and still uses) leading commas in C++ initializer lists before even knowing haskell exists
22:49:27 <Twey> Sounds like you're actually just using []
22:50:24 <NemesisD> Twey: so if [] is pulling each element off of the list and proceding through the monad, a Nothing in either one of those should move to the next element
22:52:24 <NemesisD> Twey: actually, you know how list comprehensions move on on when they hit a pattern match fail? i wonder if i could exploit that
22:52:49 <quicksilver> is there an concise way to get the 'single-traversal' version of map fst &&& map snd ?
22:52:58 <quicksilver> :t map fst &&& map snd
22:52:59 <lambdabot> [(b, b1)] -> ([b], [b1])
22:53:25 <sccrstud92__> :t unzip
22:53:26 <lambdabot> [(a, b)] -> ([a], [b])
22:53:27 <jawsh> :t &&&
22:53:27 <lambdabot> parse error on input `&&&'
22:53:33 <NemesisD> Twey: like [(x,y,z) | x <- xs, let (Just y) = maybeY x, let (Just z) = maybeZ x]
22:53:34 <jawsh> :t (&&&)
22:53:34 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:53:38 <quicksilver> sccrstud92__: d'oh
22:53:42 <quicksilver> sccrstud92__: thanks :)
22:53:44 <sccrstud92__> np
22:53:53 * quicksilver is clearly very rusty indeed
22:55:06 <Twey> NemesisD: So you actually have a return type of [Maybe (x, y, z)] ?
22:56:21 <bizarrefish> Hi all
22:56:33 <NemesisD> Twey: i was wrong, lets blow up on pattern match failures, my return type is [(x,y,z)], lets say every time maybeY or maybeZ returns a Nothing, then the result would be []
22:57:02 <bitemyapp> bizarrefish: hi!
22:57:17 <Twey> NemesisD: And otherwise the result is [(x, y, z)] (a singleton list)?
22:58:05 <Twey> Either way, you want something like: do { x ← xs; maybeToList $ (,,) <$> x <*> maybeY x <*> maybeZ x }
22:58:40 <Twey> Well, I guess it must be a singleton list, yes
22:58:54 <Twey> NemesisD: So your maybeToList = maybe [] return
22:59:09 * hackagebot shake 0.11.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.1 (NeilMitchell)
22:59:11 * hackagebot either 4.1.1 - An either monad transformer  http://hackage.haskell.org/package/either-4.1.1 (EdwardKmett)
23:00:51 <NemesisD> Twey: i guess it could be [Maybe (x,y,z] and i could just catMaybes
23:01:05 <NemesisD> Twey: no, it wouldn't be a singleton list, if there are 3 items in xs, and they all produce justs in those maybe functions, it would be a 3 element list
23:01:33 <Twey> NemesisD: Right, but each individual element produces a singleton list (i.e. you only get one result back from each run)
23:01:36 <bizarrefish> I just managed to confuse myself yet again after I thought I grasped things, heh. The last line gives a compile error: http://lpaste.net/99556
23:02:00 <NemesisD> Twey: oh, each run produces a triple or nothing at all
23:02:11 <NemesisD> Twey: i think i figured it out:
23:02:24 <Twey> :t let xs = undefined ∷ [Int]; maybeY = undefined ∷ Int → Maybe Bool; maybeZ = undefined ∷ Int → Maybe Char in do { x ← xs; maybe [] return $ (,,) <$> x <*> maybeY x <*> maybeZ x }
23:02:25 <lambdabot> lexical error at character '\136'
23:02:30 <Twey> Bah
23:03:06 <NemesisD> mapMaybe buildTriple where buildTriple x = (,,) <$> pure x <*> maybeY x <*> maybeZ x
23:03:27 <apples`> bizarrefish, it's because getBall game and getPaddle game have different types
23:03:32 <bizarrefish> As far as I knew, this should map each "DrawableObject" through the "draw" functions of each, returning a list of pictures. It seems to be having a hard time with the "draw" function, assuming it to be either Ball or Paddle
23:03:37 <Twey> > let xs = undefined :: [Int]; maybeY = undefined :: Int -> Maybe Bool; maybeZ = undefined :: Int -> Maybe Char in do { x <- xs; maybe [] return $ (,,) <$> Just x <*> maybeY x <*> maybeZ x }
23:03:38 <lambdabot>  *Exception: Prelude.undefined
23:03:42 <Twey> :t let xs = undefined :: [Int]; maybeY = undefined :: Int -> Maybe Bool; maybeZ = undefined :: Int -> Maybe Char in do { x <- xs; maybe [] return $ (,,) <$> Just x <*> maybeY x <*> maybeZ x }
23:03:43 <lambdabot> [(Int, Bool, Char)]
23:04:18 <bizarrefish> apples`: So is it impossible to create a: [DrawableObject] in haskell?
23:05:28 <Twey> NemesisD: Yes
23:05:34 <Twey> NemesisD: That's equivalent
23:05:35 <NemesisD> Twey: alright i think i've got a handle on this. thanks for talking me through it
23:05:40 <Twey> No problem
23:05:50 <Twey> > 0 ∷ Int
23:05:51 <lambdabot>  0
23:05:55 <apples`> bizarrefish, you can achieve what you want with an existential type, though i'm not sure i'd recommend it..
23:06:00 <Twey> Why does > have UnicodeSyntax but :t not?
23:06:25 <apples`> bizarrefish, i would just call draw on each piece individually
23:07:05 <bizarrefish> I guess I assumed that every java/c#/c++ expression mapped cleanly to standard haskell :P
23:07:39 <apples`> well, you're essentially asking for something akin to a heterogeneous list
23:08:44 <apples`> can you compose Picture types? maybe you could make a DrawableObject instance for PongGame that used the instances of Ball and Paddle
23:10:06 <bizarrefish> I think I'm coming around to the reasoning, after some thought. A heterogeneous list wouldn't be all that useful.
23:11:10 <bitemyapp> bizarrefish: heterogenous lists are a copout. Don't succumb.
23:12:15 <bizarrefish> Cheers for the pointers, apples` . I think I'm on the way to enlightenment :) . I'd be interested in hearing more arguments against heterogenous lists.
23:13:29 <apples`> bizarrefish, how would you express a heterogeneous list in the type system?
23:13:50 <bizarrefish> apples`: in terms of a typeclass, rather than a concrete type.
23:14:01 <bizarrefish> So, DrawableObject in this case.
23:14:12 <Twey> bizarrefish: There are no problems with heterogeneous lists.  They're called tuples.  :þ
23:14:30 <bitemyapp> Twey: I'd like to see you write code striding 1,000 element tuples.
23:14:36 <bitemyapp> and lens is cheating.
23:14:59 <Twey> What you want are *untyped* heterogeneous lists, where you throw away the type of the value when you put it in, with no way to get it out again afterwards
23:15:14 <bitemyapp> most of the time when somebody thinks they need HList, they actually need ADTs or typeclasses or...virtually anything else.
23:15:36 <Twey> And while wanting to do that is a legitimate thing to do, it suggests that you probably don't want to be tracking that information in the type system in the first place
23:16:06 <apples`> bizarrefish, sure, but when you have something like DrawableObject a => ... -> [a] -> ..., once the type for `a' is chosen, it won't change
23:16:19 <Twey> You could, for example, keep a list of Picture, which would be equivalent here
23:16:26 <apples`> it can't be Ball and Paddle at the same time
23:17:00 <Twey> bitemyapp: I've written programs in concatenative languages; does that count?  :þ
23:17:28 <bitemyapp> Twey: better you than me. I still say Forth is a community of unabombers-in-waiting.
23:18:16 <Twey> bitemyapp: FORTH is the C of the concatenative world (and it's still a better C than C), but there are languages like Factor and Kitten too, which are quite nice
23:19:13 <bitemyapp> Twey: a language that rolls a client for a news website into the core library is not "nice".
23:20:06 <Twey> bizarrefish: For the rare case where you do want to track the type to start with and then throw it away later, there are existential types
23:20:16 <Twey> bitemyapp: It's *comprehensive*!
23:20:45 <bizarrefish> apples`: That's what I was thinking about which would be an issue. One way I realised you could achieve this is an ADT which 'wraps' the two types for the purposes of drawing. data DrawableObject = DrawBall Ball | DrawPaddle Paddle.
23:20:45 * bitemyapp makes jazz hands in Twey's direction and rolls eyes
23:20:54 <Twey> It's less that it's in the ‘core library’ and more that the ‘core library’ is all there is
23:21:04 <apples`> bizarrefish, right, putting it into a sum type is one approach
23:21:12 <Twey> So everything's in there.  It does have namespacing, though, unlike some languages we could mention.
23:21:17 <bitemyapp> bizarrefish: or you could make Drawable a typeclass.
23:21:46 <bitemyapp> instance for each type you want to be drawable.
23:22:38 <bizarrefish> bitemyapp: That would require the Existential Quantification extension, wouldn't it?
23:22:59 <bitemyapp> this is where the fact that I haven't looked at the lpaste in several minutes becomes obvious. uno momento.
23:24:00 <Aetherspawn> anyone done serial communication with haskell
23:24:12 <Aetherspawn> is the "more supported" library the 2009 one or the 2012 one?
23:24:50 <bitemyapp> bizarrefish: I think I see the awkwardness.
23:24:57 <bitemyapp> bizarrefish: I'd go with the ADT.
23:27:04 <bizarrefish> Anyone know of any interesting discussions/blogs focusing on this issue? for vs against existential quantified types, etc..
23:27:27 <apples`> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:28:07 <bizarrefish> Right, I gotta go to work now. Ta Muchly, guys.
23:28:13 <jle`> is there any way to go from [f a] -> f [a] with only functor?
23:28:21 <jle`> or do i have to roll an applicative instance
23:28:33 <jle`> so tedious :'(
23:28:40 <dmj> @typ sequence
23:28:41 <lambdabot> Monad m => [m a] -> m [a]
23:28:52 <jle`> :t sequenceA
23:28:53 <lambdabot>     Not in scope: `sequenceA'
23:28:53 <lambdabot>     Perhaps you meant one of these:
23:28:53 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
23:28:58 <apples`> no, i don't think so
23:28:59 <jle`> :t T.sequenceA
23:29:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
23:29:23 <jle`> oh well.
23:29:37 <jle`> such is life
23:29:38 <dmj> jle: I bet you could do it w/ a functor if somehow you did it recursively
23:30:12 <jle`> i would rather do that than write an applicative instance becuase i feel like the app instnace was left off intentionally, from this library
23:30:19 <jle`> even though implementing it would be very straightforward
23:30:31 <jle`> but...i'm not sure it's possible
23:31:36 <jle`> @hoogle sequenceF
23:31:36 <lambdabot> No results found
23:32:33 <Twey> jle`: I think you need Monad, actually
23:33:02 <Twey> You don't get that out of Applicative unless the a happens to be Monoid
23:33:16 <jle`> really?
23:33:27 <jle`> @src T.sequenceA
23:33:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:33:35 <Twey> Or you have some other a → a → a combining function
23:33:38 <apples`> [] is a Traversable
23:37:18 <Twey> Oh right, I guess that's enough
23:38:05 <Twey> Yes, of course, silly me
23:39:13 <dmj> jle: I don't think it's possible because you can't get at the underlying type 'a' in such a way to isolate it and concatenate it to others
23:39:25 <shachaf> People care in Haskell a little bit too much about types and not enough about behavior.
23:40:16 <dmj> @src sequence
23:40:16 <lambdabot> sequence []     = return []
23:40:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:40:17 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
23:40:19 <Twey> dmj: You can, because they only want list output — so you can use (:) to build up a list
23:40:58 <Twey> shachaf: The idea is to make types such that your behaviour comes for free
23:41:48 <shachaf> Yes. But Haskell's type system won't let you do that enough.
23:41:51 <Twey> shachaf: There's a neat paper recently in which the authors derive classical mechanics from a sufficiently finely-typed Lagrangian operator
23:41:56 <dmj> Twey: using only fmap and (:), how can you go from Functor f => [f a] -> f [a]
23:42:05 <Twey> shachaf: You can pretend :þ
23:42:19 <Twey> dmj: jle` also specified Applicative f
23:42:36 <dmj> Twey: he wanted to avoid Applicative
23:42:59 <Twey> Oh, right, that's what you meant.  Yes, I don't believe it can be done with Functor alone.
23:43:36 <Twey> You get no ‘combining’ behaviour out of Functor
23:43:57 <shachaf> Can you write a total foo :: Functor f => f [a] -> [f a]?
23:44:00 <shachaf> (Yes: const [])
23:44:47 * Twey wonders what the *real* intended type of that function was
23:45:01 <Twey> (i.e. one that disallows const [])
23:47:58 <Twey> I guess foo ∷ (Functor f, Traversable t) ⇒ f (t a) → t (f a)
23:48:10 <jle`> Twey: something ugly and that actually doesn't do what i want :P
23:48:20 <jle`> was just a thought experiment.
23:48:29 <shachaf> There was no intended type.
23:48:55 <shachaf> If you're looking for a type like that, maybe you're thinking of Distributive (but of course [] isn't Distributive).
23:49:16 <jle`> on the other hand i am loving these free monoids
23:49:22 <jle`> using them left and right
23:49:31 <jle`> whoever thought of them was onto something
23:52:37 <dmj> f :: Applicative f => [f a] => f [a]; f [] = pure []; f (c:cs) = (:) <$> c <*> f cs
23:53:24 <dmj> from the applicative programming w/ effects paper
23:53:36 <Twey> Right, that's Data.Traversable.sequenceA
23:53:38 <jle`> yeah, was thinking about that; it's a straight translation of the monadic sequence.  even in best hopes, you're going to need pure
23:53:43 <jle`> for the base case with the empty list
23:53:49 <jle`> ...i think
23:55:08 <dmj> what's the best way to "get" traversable
23:55:53 <jle`> ?
23:56:19 <jle`> to wrap something in a traversable?
23:56:21 <jle`> or to understand
23:56:38 <dmj> to understand, like what are good practical use cases
23:57:03 <jle`> i use it a lot for Maybe
23:57:35 <dmj> what can it do for you that the functions in Data.Maybe cannot, or when do you find yourself using it
23:57:38 <jle`> it's nice to have a forM/forM_ (Foldable) that works for more than just lists
23:57:42 <jle`> oh
23:58:26 <jle`> case something of Just x -> m x; Nothing -> return ()
23:58:47 <jle`> admittedly i use the Foldable more often
23:59:00 <jle`> forM_ something $ \x -> m x; etc;
23:59:25 <jle`> where something can be a list
23:59:29 <jle`> or a Maybe
23:59:33 <jle`> or anything foldable
