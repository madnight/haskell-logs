00:06:41 * hackagebot instrument-chord 0.1.0.6 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.6 (AlanHawkins)
00:11:14 * hackagebot reducers 3.10.2 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.2 (EdwardKmett)
00:11:14 * hackagebot instrument-chord 0.1.0.6 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.6 (AlanHawkins)
00:16:50 <sayyid_> hi everyone. i was wondering if you could help me out with some issues i'm having while performing some calculations
00:17:45 <sayyid_> i know i shouldn't really expect much of such a request, but i'm trying to get the result of 7^(10^12), which my computer seems to have trouble finding
00:18:17 <milfjord> is this project euler?
00:18:54 <startling> > 10 ^ 12
00:18:55 <lambdabot>  1000000000000
00:19:07 <startling> > 7^(10 ^ 12)
00:19:12 <lambdabot>  mueval: Prelude.undefined
00:19:13 <shachaf> > 7**(10**12)
00:19:16 <lambdabot>  Infinity
00:19:18 <shachaf> There you go.
00:19:43 <milfjord> > 7 ** 1e12
00:19:44 <lambdabot>  Infinity
00:20:30 <sayyid_> haha, thanks anyways, i sort of knew that the answer.
00:20:57 <sayyid_> milford, yes it is
00:22:00 <sayyid_> milfjord*. i'm thinking of something related to it, but i cant help but think they wouldn't require such an extenuous calculation
00:22:13 <milfjord> then I bet you don't need the result of 7^(10^12)
00:23:01 <sayyid_> but i also think we need the result of a combination of sorts, since it is after all a problem about permutations of lists.
00:23:06 <sayyid_> i'll try to think of something else.
00:23:10 <sayyid_> thanks.
00:23:32 <pavonia> Are modulo operations involved here? That would make the calculation easier
00:23:41 <sayyid_> i'm afraid not.
00:24:31 <predator217> http://www.wolframalpha.com/input/?i=7^(10^12)
00:41:22 <joelteon> 10^(10^(10^1.0765))
00:42:55 <jle`> hm
00:43:04 <jle`> i wonder if reverse state would be useful
00:43:10 <jle`> for some simple constraint satisfaction
00:43:27 <jle`> could we implement backtracking through it?
00:43:32 <randomclown> @pl \x -> (x-1, x-1)
00:43:33 <lambdabot> ap ((,) . subtract 1) (subtract 1)
00:43:38 <randomclown> @src substract
00:43:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:43:49 <randomclown> The what?
00:45:20 <dissipate> anyone know what this compiler error means? Not in scope: type constructor or class `Overloading'
00:45:40 <randomclown> dissipate: show code
00:47:31 <dissipate> randomclown, https://github.com/nwf/dyna/blob/master/src/Dyna/XXX/MonadUtils.hs#L87
00:49:31 <kazagistar> I took interest in a remark in a talk about closure serialization. It seems like closures could, in theory, be serializable, but only if all their free variables are serializable. What are the difficulties preventing this from being in the existing haskell implementations?
01:00:22 <mm_freak_> jle`: because it's not possible
01:00:49 <mm_freak_> if you remove the 'm' it becomes possible, but the resulting monad's (>>=) is completely useless
01:01:15 * hackagebot yocto 1.0.0 - A Minimal JSON Parser & Printer for Haskell  http://hackage.haskell.org/package/yocto-1.0.0 (ajg)
01:02:57 <startling> kazagistar: it ruins parametricity.
01:03:47 <startling> though it could be done in IO.
01:04:45 <randomclown> @hoogle overloading
01:04:45 <lambdabot> No results found
01:05:23 <randomclown> dissipate: don't you need to import that symbol?
01:05:57 <kazagistar> startling: hmm, somehow I don't see how it ruins it, could you point me to a simple example?
01:06:17 <startling> kazagistar, well, consider fmap :: (a -> b) -> f a -> f b
01:06:46 <startling> kazagistar: if an fmap implementation could serialize that (a -> b), it could do different things based on the types involved.
01:07:51 <dissipate> randomclown, so it's just 'import Overload'?
01:08:56 <dissipate> randomclown, er, i mean 'Overloading'
01:10:34 <kazagistar> startling: ugh, my intuition here is really lacking I think… doesn't haskell have any way of expressing that a passed function have a specific typeclass, like "serializable"?
01:11:06 <fragamus_> http://lpaste.net/99682
01:11:11 <fragamus_> WTF
01:11:16 * hackagebot sdl2-image 0.1.0.1 - Haskell binding to sdl2-image.  http://hackage.haskell.org/package/sdl2-image-0.1.0.1 (cailei)
01:11:20 <mm_freak_> kazagistar: you mean like…  (C a) => (a -> b) -> c?
01:11:44 <mm_freak_> kazagistar: or…  ((C a) => a -> b) -> c?
01:12:19 <mm_freak_> kazagistar: or…  (forall a. (C a) => a -> b) -> c?
01:14:52 <Cale> fragamus_: Where are cross/norm/normalize defined?
01:15:02 <fragamus_> Linear
01:15:04 <kazagistar> well, i would have to be (C a b => … ) wouldn't it? If you wanted to express that, say, an sfmap has to take a Serializable a->b closure?
01:15:05 <Twey> kazagistar: Haskell doesn't include closure environments in the function's type
01:15:47 <Twey> So the difference between a serializable vs. non-serializable function would be effectively invisible, and therefore useless
01:15:55 <startling> Twey: oh, good point.
01:16:06 <mm_freak_> kazagistar: the function wouldn't really have a choice when passing an instance to the function
01:16:12 <mm_freak_> because instances are global
01:16:39 <mm_freak_> so you can just as well just use the constraint in the top level
01:16:47 <mm_freak_> (C a) => (a -> b) -> c
01:17:01 <Twey> Hm
01:17:34 <mm_freak_> the only time when you would sensibly use a context on a function argument is when it is rank-1-polymorphic
01:17:41 <mm_freak_> (forall a. (C a) => a -> b) -> c
01:17:55 <mm_freak_> because now the function can choose the instance (by choosing the type 'a')
01:17:55 <Twey> kazagistar: You could overload the lambda syntax, so that a lambda expression has type Serializable (a → b) ⇒ (a → b) iff all its free variables are Serializable
01:18:36 <startling> You could also just build a serializable AST that can be interpreted (= transformed into a Haskell function).
01:19:03 <startling> Obviously this is only as expressive as you make it, but ...
01:19:24 <Cale> fragamus_: try putting a type signature on normX
01:19:37 <mm_freak_> i don't know what you are doing, but it sounds so wrong that it probably is a bad idea =)
01:20:00 <Twey> kazagistar: I think a context like that requires some extensions that don't play well with type inference, though, so I think you'd end up needing some extra type signatures
01:20:31 <mm_freak_> function argument contexts don't make sense without rank-1 polymorphism
01:21:21 <Twey> mm_freak_: The question was, what needs to be done in Haskell to allow functions to have Serializable instances?
01:21:35 <mm_freak_> it's impossible
01:21:50 <Twey> In Haskell as it stands, yes, but that was rather the question :þ
01:21:54 <Cale> (but see distributed-process)
01:22:00 <kazagistar> impossible is an ugly word :P
01:22:11 <Twey> Not *all* functions, just the ones that can be serialized
01:22:30 <dissipate> hmm, that's strange
01:22:37 <mm_freak_> if you represent your functions by data (what Cale said), then it's possible, but you need to provide an interface
01:22:41 <mm_freak_> see distributed-static
01:22:57 <kazagistar> hmm, I guess the whole issue just worries me because abandoning passing functions is a rather high cost to pay for parallelization in a functional language
01:23:12 <mm_freak_> huh?
01:23:15 <dissipate> when i search for 'Overloading' on http://holumbus.fh-wedel.de/hayoo/hayoo.html, it has a couple hits for Control.Lens.Type. but when i go in there, there is no 'Overloading'
01:23:28 <Twey> kazagistar: Do you mean distribution?
01:23:43 <mm_freak_> kazagistar: serializing functions is simply impossible, because it is undecidable
01:23:47 <Cale> kazagistar: You can pass functions around in a single process just fine.
01:23:53 <mm_freak_> other language work around the problem by serializing source code
01:24:00 <mm_freak_> or object code
01:24:01 <Cale> (if you want SMP parallelism, that's all you need)
01:24:16 <mm_freak_> but if you would do that, it would be a side effect
01:24:26 <Cale> It's only if you have to communicate them over a network that this becomes an issue
01:24:34 <kazagistar> mm_freak_: undecidable means you have to restrict it, not that it is impossible
01:24:47 <dissipate> anyone know why 'Overloading' doesn't show up in the source for 'Control.Lens.Type'?
01:25:06 <mm_freak_> kazagistar: no, it is undecidable unless you require functions to be total, and haskell does not enforce that
01:25:14 <mm_freak_> so it's impossible in haskell
01:25:28 <kazagistar> Cale: I mean, "over a network" can become an issue if you decide you quite like process isolation, even on the same system
01:25:30 <Twey> mm_freak_: Why is it undecidable?
01:25:36 <mm_freak_> Twey: halting problem
01:25:54 <mm_freak_> and even if haskell would have totality checking, it would still be either very expensive or a side effect
01:26:07 <dissipate> mm_freak_, that's why you just serialize a subset of the language
01:26:10 <Twey> mm_freak_: But you can serialize finite representations of infinite functions (or we wouldn't be able to represent them)
01:26:37 <mm_freak_> in the first case you would have to evaluate the function at every possible point, and in the second case you get to tell 'id' from '\x -> () `seq` x'
01:26:41 <mm_freak_> so it would be a side effect
01:27:04 <Twey> Hrm
01:27:51 <mm_freak_> haskell does The Right Thing with respect to function serialization…  you have to represent functions by data in order to serialize them
01:27:54 <Twey> mm_freak_: If you control the ‘Serializable’ instance enough that the only thing you can do with it after it's been serialized is to get a function back, you don't have that side effect
01:28:02 <dissipate> mm_freak_, clearly  you serialize a *subset* of the language
01:28:29 <mm_freak_> dissipate: you serialize a subset that isn't there, unless you /create/ the subset of the language as data
01:28:36 <mm_freak_> that's what distributed-static does
01:29:36 <dissipate> mm_freak_, have  you heard of EDN?
01:29:43 <Cale> fragamus_: btw, I just tried the code you pasted, and it works fine
01:29:44 <mm_freak_> Twey: once (->) is your top-level constructor it's impossible, and there is nothing you can do about it
01:29:47 <mm_freak_> dissipate: ?
01:29:57 <Cale> (as is)
01:30:11 <kazagistar> test :: Int -> Serializable (a -> b) { or something like that }; test a = (a+); serialize a
01:30:55 <Cale> Also note that having functions be serializable by default spoils referential transparency
01:31:18 <mm_freak_> what Cale said…  function serialization is either wrong or a side effect
01:31:21 <dissipate> mm_freak_, extensible data notation: https://github.com/edn-format/edn
01:32:12 <mm_freak_> dissipate: haskell is not a lisp though
01:32:18 <Twey> mm_freak_: Why? class Serializable a where serialize ∷ a → Serialized; unserialize ∷ Serialized → Maybe a (where Serialized is an opaque type); then you produce a Serializable (a → b) ⇒ (a → b) by (e.g.) overloading lambda and the only thing you can do with its equivalent Serialized is to get back a function Serializable (a → b) ⇒ (a → b)
01:32:37 <dissipate> mm_freak_, EDN can be used by other languages
01:32:49 <mm_freak_> dissipate: but not by haskell
01:32:52 <Twey> It only spoils referential transparency if you give Serialized an Eq instance or similar, which is the same as giving functions an Eq
01:32:55 <Cale> Well, I don't know if I'd even call it a "side effect", it's just that it spoils function extensionality, because you can have f x = g x for all x, and yet it becomes possible for serialise f /= serialise g
01:33:11 <Cale> (so it's inappropriate to say that f = g)
01:33:14 <dissipate> mm_freak_, why not?
01:33:16 <mm_freak_> Twey: define that Serializable
01:33:24 <mm_freak_> dissipate: try to port it to haskell
01:33:40 <Twey> mm_freak_: newtype Serializable = Serializable ByteString with a non-exported constructor?
01:34:09 <dissipate> mm_freak_, why can't haskell have something similar? a serialization notation that is a subset of haskell itself.
01:34:25 <mm_freak_> dissipate: it does have distributed-static
01:34:39 <mm_freak_> it encodes functions as data and provides some TH helpers to define serializable functions
01:34:59 <mm_freak_> but there is simply no general function serializer
01:35:19 <Cale> btw, if you're actually interested in distributed computation, you'll probably actually want to use Control.Distributed.Process.Closure in distributed-process
01:35:24 <dissipate> mm_freak_, functions shouldn't be serializable. that's crazy.
01:35:54 <Axman6> it's not that crazy...
01:36:27 <Cale> That also includes some useful TH stuff for creating the closures and some other stuff that's needed by distributed-process
01:36:37 <kazagistar> dissipate: there are valid cases for wanting functions to be serializable, and not being able to do so actually gives an edge to objects
01:37:03 <Twey> Cale: It's equally appropriate to say that serialize f = serialize g as it is to say that f = g (i.e. nominally yes, but you can't observe it)
01:37:06 <Cale> kazagistar: Anyway, it sounds like you're looking for Cloud Haskell
01:37:20 <k1tt3n> Hi,
01:37:24 <Cale> Twey: what?
01:37:27 <k1tt3n> I have problems initializing an empty Map in Haskell
01:37:30 <dissipate> Axman6, a function would have to be serialized as a closure with its entire runtime enviroment. that is just nuts.
01:37:33 <kazagistar> Cale: ill take a good hard look at it for sure
01:37:39 <k1tt3n> I do the import (import Data.Map)
01:37:56 <mm_freak_> kazagistar: no doubt, but function serialization is wrong in general, and distributed-static is an good approximation for practical distributed computing
01:38:04 <Axman6> dissipate: no it wouldn't, only its bound arguments and referenced values
01:38:06 <Twey> Cale: If you can say that f = g, and the only thing you can do with serialize f is get back f, then you can say serialize f = serialize g just as well
01:38:06 <Cale> k1tt3n: Use   import qualified Data.Map as Map; import Data.Map (Map)
01:38:10 <k1tt3n> ... and a declaration like 'let m = Map.empty in ... '
01:38:22 <Cale> k1tt3n: and then  Map.empty  should work
01:38:33 <Twey> Cale: I.E. they're conceptually equal, but don't have an Eq instance
01:38:34 <k1tt3n> Cale: thanks, I'll try that!
01:38:49 <Axman6> k1tt3n: you can only use Map.empty when you've imported Data.Map qualified
01:39:02 <Axman6> or named it at least, using as
01:39:10 <kazagistar> dissipate: or with just a dependency that the runtime environment at the other end have a consistent definition for the function and its definitions
01:39:13 <dissipate> Axman6, what if modules are getting loaded dynamically at runtime? the function's behavior would change completely
01:39:14 <Cale> Twey: I'm assuming here that serialize is going to produce a ByteString or something
01:39:27 <Cale> Twey: and if it does, then you can certainly compare those
01:39:34 <Axman6> dissipate: we don't tend to load modules at runtime
01:39:44 <Axman6> it's possible, but rare
01:39:59 <Twey> Cale: It can produce a wrapped ByteString so long as the ByteString is opaque, but it mustn't allow Eq on the ByteString, obviously
01:40:07 <Twey> Er, so long as the type is opaque**
01:40:16 <dissipate> Axman6, might be rare, but it could happen. i can't even fathom serializing functions.
01:40:25 <Twey> (see the class/datatype I proposed above)
01:40:48 <Cale> Well, that might help a bit, but eventually you'll want to do something with the serialised value, and at that point, you'll be able to tell the difference.
01:41:01 <Axman6> dissipate: really it should be easier in Haskell than most languages
01:41:14 <Twey> Basically, you make Serialized a datatype whose only visible operation is to unserialize
01:41:43 <k1tt3n> Cale, Axman6: thanks, now it works!
01:41:44 <kazagistar> in something like Forth, all words you use are closed over. If the other runtime has the same foundation as yours, then you only have to ensure that the differences from the common foundation are in place
01:41:46 <startling> Can we unload modules at runtime yet? :/
01:41:56 <Cale> Twey: If that's all you want, then I could define  newtype Serialised t = Serialised t
01:42:04 <mm_freak_> i don't know why you insist on this general function serialization…  distributed-static really gets it right and convenient at the same time without spoiling correctness
01:42:11 <Cale> But that's not enough for the purposes people are talking about :)
01:42:34 <dissipate> mm_freak_, i am not insisting on it. i'm saying it is nuts.
01:42:45 <Cale> dissipate: What's nuts?
01:42:45 <startling> mm_freak_: wow, distributed-static looks cool
01:42:50 <Twey> Cale: You can unserialize and call the function on the argument purely, which doesn't allow observation of the difference; or you can do things in IO like stuffing their source into ByteStrings or passing them over the network, which does allow observation of the difference (but we can already do this with functions)
01:43:08 <dissipate> Cale, serializing functions
01:43:19 <mm_freak_> dissipate: it was addressed mainly to Twey and kazagistar =)
01:43:31 <Cale> dissipate: We can certainly serialise codes for functions.
01:43:37 <mm_freak_> distributed computing using distributed-process is eeeeaaaaasy
01:43:46 <mm_freak_> much easier than in most other languages
01:43:52 <kazagistar> if you serialize (3+), it only needs to reference "standard +", and "standard 3", no problems there
01:43:53 <Twey> mm_freak_: Nobody's insisting on serializing functions.  I'm trying to answer kazagistar's question (‘what would need to be done in Haskell to make serializing functions make sense?’).
01:44:05 <dissipate> Cale, not with dynamic loading of modules at runtime
01:44:23 <Twey> (‘for functions whose environments can be serialized’)
01:44:42 <mm_freak_> Twey: the correct answer to that is:  "nothing, because serializing functions doesn't make sense without giving up some of the fundamental assumptions haskell makes"
01:44:42 <Cale> dissipate: Well, that depends entirely on whether you ensure the same module has been dynamically loaded at all points.
01:44:53 <Cale> dissipate: (on all nodes)
01:45:11 <dissipate> Twey, what would need to be done? dump your program's entire memory
01:45:32 <Twey> mm_freak_: But I just gave an example of a Serializable class that upholds exactly the same assumptions as functions in Haskell already do
01:45:39 <Cale> dissipate: significantly less than that, in practice
01:45:54 <mm_freak_> Twey: but you haven't written that class in actual code…  just try it
01:46:04 <Twey> mm_freak_: So long as you can't *observe* the source of the function, it's fine to store it and pass it around (as we already do for functions, in computer memory)
01:46:12 <Cale> dissipate: I take it you're not familiar with Cloud Haskell?
01:46:22 <Twey> mm_freak_: It would require a language extension
01:46:29 <mm_freak_> Twey: namely?
01:46:37 <Twey> (the one I suggested way back at the beginning of the conversation)
01:46:47 <dissipate> Cale, why is this even a controversy? everyone knows that functions operate radically different depending on runtime environments. unless you close over the entire runtime environment, serializing functions is just silly.
01:47:01 <dissipate> Cale, nope, should i be?
01:47:03 <mm_freak_> Twey: give me a short summary…  ideally by giving me a type signature
01:47:11 <Twey> mm_freak_: The compiler has to produce the serializing instance for functions that can be serialized
01:47:26 <Cale> dissipate: The assumption here is that you're running the same program in both locations when you serialise and deserialise the thing.
01:47:46 <dissipate> Cale, that's a horrible assumption
01:47:50 <Cale> why?
01:47:54 <Cale> It's often just fine
01:48:10 <mm_freak_> Twey: there is a problem with that
01:48:12 <dissipate> Cale, completely defeats the purpose of serialization!
01:48:20 <Twey> mm_freak_: class Serializable a where serialize ∷ a → Serialized; unserialize ∷ Serialized → Maybe a (where Serialized is an opaque type); then you produce a Serializable (a → b) ⇒ (a → b) by (e.g. overloading lambda and the only thing you can do with its equivalent Serialized is to get back a function Serializable (a → b) ⇒ (a → b)
01:48:36 <Cale> The goal being that you spin up a bunch of nodes on EC2 or some such and they're allowed to communicate to each other, even if what's being communicated are functions.
01:48:41 <Twey> mm_freak_: What's the problem with that?  The compiler already has a representation of the function
01:48:59 <Twey> (as a source term, hopefully)
01:49:01 <Cale> and all those nodes are going to receive the same binary
01:49:11 <mm_freak_> Twey: how do you serialize on an x86 and rebuild on a powerpc?
01:49:12 <dissipate> Cale, that's a very narrow use case. that's not general serialization.
01:49:24 <Twey> mm_freak_: As a Haskell source term (for example)
01:49:41 <mm_freak_> Twey: so every program would need to include a compiler
01:49:49 <Twey> Alright
01:49:58 <Cale> There's a whole bunch of (admittedly somewhat similar) scenarios where the same sort of serialisation will totally suffice.
01:50:00 <kazagistar> dissipate: well, we agree the general problem has no/bad solutions, but the specific problem is still worthwhile to solve
01:50:20 <Twey> The bloat is unpleasant, but it doesn't break the concept :þ
01:50:26 <mm_freak_> Twey: without even considering the security implications, i'm just going to say that this is something lisp could do (and does), but it's just not the right approach in haskell
01:50:46 <Twey> I'm not saying it's the right approach, I'm just saying it makes sense
01:50:49 <Cale> Even stuff in lisp tends not to do that.
01:50:58 <dissipate> kazagistar, sure, i can agree with that.
01:51:25 <Cale> e.g. consider something like the Continue web server
01:51:29 <mm_freak_> Twey: and i'm saying you shouldn't be so sure that it makes sense…  if it really would make sense, it should be implementable in haskell
01:51:45 <bitemyapp> ddellacosta: hi!
01:51:52 <Twey> mm_freak_: Like HoTT? ;)
01:52:01 <mm_freak_> Twey: let me give you a concrete example
01:52:13 <Twey> Please do
01:52:15 <mm_freak_> Twey: id = (\x -> () `seq` x)
01:52:25 <Twey> Okay
01:52:33 <mm_freak_> but: serialize id ≠ serialize (\x -> () `seq` x)
01:52:36 <mm_freak_> do you see the problem?
01:52:44 <Twey> mm_freak_: Sure, but that's not observable
01:52:52 <Cale> It uses (cryptographically encrypted) serialised closures representing continuations in order to allow the web server to send people links that when clicked will continue executing code where the server left off before.
01:53:10 <Twey> mm_freak_: serialize id ≠ serialize (\x → () `seq` x) in exactly the same way that id ≠ (\x → () `seq` x) in the first place
01:53:22 <mm_freak_> Twey: no, they are the same function
01:53:30 <Cale> It's quite similar in that respect (modulo the cryptography) to how Cloud Haskell does things
01:53:59 <Twey> mm_freak_: And the Serialized value is ‘the same’ value.  But the representations are different, so to preserve referential transparency we need to hide the representations (in both cases).
01:54:33 <mm_freak_> Twey: you think it's not observable, but allow me to give you a way to observe it
01:54:42 <mm_freak_> serialize (const undefined)
01:54:44 <Twey> mm_freak_: ‘unserialize’ knows the difference, and function application knows the difference, but nothing else does (unless you start doing stuff with them in IO, at which point all bets are off anyway)
01:54:52 <mm_freak_> vs.
01:55:10 <mm_freak_> serialize (fix id)
01:55:17 <mm_freak_> gives you a way to tell one bottom from another
01:55:35 <mm_freak_> serialize (fix id) /should/ be bottom
01:56:04 <Cale> dissipate: you can do things like this: http://docs.racket-lang.org/web-server/servlet.html#%28def._%28%28lib._web-server%2Fservlet%2Fweb..rkt%29._send%2Fsuspend%29%29
01:56:06 <Twey> Oh, that is true
01:56:12 <Twey> Does it work up to bottom?
01:56:23 <Twey> Wait
01:57:43 <Twey> > const undefined
01:57:44 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
01:57:44 <lambdabot>    arising from a use of `M779516523870709439613.show_M779516523870709439613'
01:57:44 <lambdabot>  The type variable `a0' is ambiguous
01:57:44 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
01:57:44 <lambdabot>  Note: there are several potential instances:
01:57:45 <Twey> > fix id
01:57:49 <lambdabot>  mueval-core: Time limit exceeded
01:57:55 <Twey> These are already observable
01:58:02 <mm_freak_> Twey: not without IO
01:58:14 <dissipate> Cale, sure. in that case the state of the program is saved and executed again when the request to do so is made
01:58:18 <mm_freak_> observing the difference must be a side effect
01:58:32 <mm_freak_> Twey: with some arbitrary limitations you can probably make this somewhat usable, but it's just a very fragile base to build on
01:58:34 <Twey> Hm
01:58:37 <Twey> Actually
01:58:45 <mm_freak_> i think the approach of distributed-static is the correct one
01:59:06 <Twey> mm_freak_: (with the opaque ByteString wrapper I suggested above)  Neither serialize (fix id) nor serialize (const undefined) is bottom
01:59:20 <mm_freak_> it's slightly less convenient (for the implementor of the abstraction), but it preserves the basic assumptions we make about functions
01:59:30 <Twey> They both evaluate to Serialize _
01:59:45 <Twey> You can only observe the difference by inspecting the ByteString, which isn't allowed outside of IO
02:00:01 <Twey> Oh wait, I used a newtype — scratch that, then
02:00:13 <Twey> data Serialized = Serialized ByteString
02:00:21 <Cale> dissipate: The rest of the program as a function of the result of this computation is serialised (in the sense we've been using) into a URL and passed as a parameter
02:00:46 <mm_freak_> Twey: there is in principle no difference between an infinite function and a looping function…  the result of 'serialize' should be bottom, otherwise you can observe the difference
02:01:20 <dissipate> Cale, but the webserver is maintaining the runtime environment all throughout
02:01:54 <Twey> mm_freak_: There's no way to observe the difference with data Serialized = … except by unserializing it, which gives you back const undefined and fix id, respectively
02:01:57 <Cale> This will work even if it's stopped and restarted
02:02:16 <mm_freak_> Twey: again, you can make this work with some arbitrary limitations, but it would be too fragile for my taste…  something that doesn't really fit well with the general haskell approach
02:02:39 <Twey> (because the compiler can pass a thunk through unserialize . serialize without evaluating it; it only needs to be evaluated if the actual ByteString is inspected)
02:03:03 <dissipate> Cale, nope, it can be broken. all i need to do is write a program that accesses the memory directly and swaps out symbols.
02:03:04 <Twey> mm_freak_: We haven't imposed any limitations so far
02:03:18 <Cale> dissipate: What? :)
02:03:27 <Cale> dissipate: "broken" in which sense?
02:03:33 <Twey> I agree it's probably not practical (the compiler-embedding is a big turn-off, to start with), but it seems to make sense in principle
02:03:55 <dissipate> Cale, in the sense that the behavior cannot be guaranteed once the runtime environment is reset
02:04:23 <Cale> dissipate: Obviously, if you're allowed to fiddle with the webserver's memory, you could break it. Just replace all the webserver's code with nops, or requests to load 0
02:04:53 <dissipate> Cale, i could leave everything intact and just change the 1 function.
02:05:44 <dissipate> Cale, the entire concept of serializing a function is just absurd.
02:06:31 <Cale> dissipate: Change what function? I believe what happens if you change and recompile a different webserver between the time that the URL is constructed and when a client clicks on it, what they get is an error message informing them that their URL has expired.
02:08:00 <Cale> (because the URL contains a hash of the webserver's code, along with a token for which continuation it is, and the serialised environment for that closure)
02:09:52 <bitemyapp> I need a package for charting, ideally one that I can continually feed data and see update on the fly.
02:09:57 <dissipate> Cale, yes. but my point is precisely this: you cannot assume anything about runtime *behavior*. but potentially, some guarantees on behavior is implied when you serialize a function. if, however, you are very explicit in stating that the serialized function is strictly data on par with some other immutable data structure or value, then that might be OK.
02:10:37 <kazagistar> thanks for the discussion, I gained a lot of new insight I think… I am off to sleep
02:10:41 <startling> bitemyapp: what's a chart?
02:10:44 <startling> bitemyapp: (hi, btw)
02:11:06 <bitemyapp> startling: hi
02:11:18 <Cale> dissipate: How is that not data on par with some other immutable data structure or value?
02:11:42 <bitemyapp> startling: do I know you?
02:11:54 <dissipate> Cale, it is on par, as long as any inclination of guarantees on behavior are off the table.
02:12:32 <startling> bitemyapp: we met at and after the clojurescript thing in SF a few weeks ago
02:12:43 <Cale> dissipate: Well, you do have guarantees on behaviour
02:13:08 <dissipate> Cale, i thought we just agreed there are none?
02:13:28 <Cale> dissipate: The semantics seem pretty straightforward to me
02:13:57 <dissipate> Cale, all it takes is for a program to modify its symbol table at run time, and all bets are off
02:14:11 <Cale> Obviously, if you change the program in the middle, all bets are off (though there's a lot you can do to detect this and fail gracefully).
02:14:26 <bitemyapp> startling: well, good to see you again, although that only narrowed it down to 3 or 4 people.
02:14:43 <startling> bitemyapp: (I'm tim)
02:14:53 <bitemyapp> Okie dokie. Now I know.
02:15:00 <Cale> dissipate: I don't know why you're working under the assumption that forcibly modifying this poor program's code while it's running is a reasonable thing to do here.
02:15:11 <bitemyapp> startling: http://stackoverflow.com/questions/7625695/dynamically-updating-a-plot-in-haskell roughly what I want is this, but I need the code to actually work.
02:15:20 <bitemyapp> there's a typeclass instance missing somewhere.
02:15:46 <Cale> dissipate: If the program *itself* wants to load additional code, that should work fine. If we screw with it from the outside, sure that'll break things, but that could always break things.
02:16:03 <dissipate> Cale, to make an analogy. i can see it working in the way that Linux is modified and used as a Real Time operating system. Linux is not a real time OS, but it is used as such. and for the vast majority of applications it will be fine, but there is always a disclaimer that an instruction might not be executed in the designated time window.
02:16:33 <Cale> It's nothing so low-level as that
02:16:36 <bitemyapp> how nice to see people using the term real-time with the proper meaning.
02:17:17 <avaritia> there is no such thing as real life
02:17:22 <dissipate> Cale, so i serialize a function and hand it off to you. 99.999999% of the time it behaves the same. but one day you write an app that is modifying the symbol table at run time all over the place. boom, serialized function is sunk.
02:17:47 <Cale> dissipate: We're talking about programs written in Haskell
02:18:25 <Cale> also, we're only talking about programs deserialising functions that they themselves serialised earlier
02:18:27 <dissipate> Cale, a program in Haskell cannot modify its symbol table at run time?
02:18:42 <Cale> Why would it?
02:18:51 <Cale> There's no reason to.
02:19:01 <the_berserker> @pl \x y -> (x,y)
02:19:01 <lambdabot> (,)
02:19:28 <the_berserker> @pl \f (x,y) -> f x y
02:19:29 <lambdabot> (`ap` snd) . (. fst)
02:19:50 <dissipate> Cale, there could be a reason. personally, i think doing such a thing is pretty crazy and is going to make reasoning about the program a nightmare.
02:19:53 <the_berserker> @pl \f (x,y,z) -> f x y z
02:19:53 <lambdabot> (line 1, column 9):
02:19:54 <lambdabot> unexpected "z"
02:19:54 <lambdabot> ambiguous use of a non associative operator
02:20:04 <dissipate> Cale, but someone could do it
02:20:26 <Cale> dissipate: We can blame that person when their program breaks.
02:20:42 <the_berserker> Why the error?
02:20:55 <Cale> the_berserker: because @pl doesn't know that triples exist
02:21:37 <Cale> (i.e. they don't exist in the little language that it parses)
02:21:38 <dissipate> Cale, that's my point. if the onus is entirely on the person deserializing the function, then it's fine, as long as the function executes in a reasonable way under reasonable conditions to produce the desired behavior.
02:22:00 <Cale> dissipate: Yeah, these libraries actually do work in practice.
02:22:12 <Cale> (and they're very useful)
02:22:42 <dissipate> Cale, but if the person serializing the function is dynamically loading modules at runtime?
02:22:52 <the_berserker> @pl \() -> 2
02:22:52 <lambdabot> (line 1, column 4):
02:22:52 <lambdabot> unexpected " "
02:22:52 <lambdabot> expecting operator, pattern or "->"
02:23:53 <the_berserker> @pl \x -> x
02:23:53 <lambdabot> id
02:24:07 <the_berserker> @pl \m _ _ -> m
02:24:07 <lambdabot> const . const
02:24:34 <dissipate> Cale, actually, there is a way to create a stronger contract (but not guaranteed). the function gets serialized with a test suite, to at least give the receiver of the function some idea of the function's desired behavior.
02:24:57 <the_berserker> @pl \x f y -> f x y
02:24:57 <lambdabot> flip id
02:24:59 <dissipate> Cale, i seriously doubt this library you speak of has this functionality
02:25:10 <the_berserker> > fix id
02:25:14 <lambdabot>  mueval-core: Time limit exceeded
02:25:46 <the_berserker> @pl \x -> let t = x(t) in t
02:25:46 <lambdabot> fix
02:25:59 <the_berserker> > fix (+3)
02:26:03 <lambdabot>  mueval-core: Time limit exceeded
02:26:32 <simpson> dissipate: I am reminded of E's auditors; they are actually allowed to inspect the AST of the serialized code objects and verify that they behave in certain ways.
02:27:42 <dissipate> simpson, that's interesting. sounds like a good thing to have.
02:29:13 <dissipate> simpson, could you port E's functionality to Haskell's serialization libs?
02:29:26 <the_berserker> @pl \f x -> scanl (\m _ -> f m) x (repeat ())
02:29:26 <lambdabot> flip flip (repeat ()) . scanl . (const .)
02:29:29 <Cale> dissipate: All we're talking about doing is serialising the name of the closure (which we will have a name for because you're required to declare every one of the things which you'll later serialise instances of) along with the arguments to which it has been partially applied.
02:29:46 <the_berserker> > (\f x -> scanl (\m _ -> f m) x (repeat ())) (+1) 0
02:29:46 <simpson> dissipate: Nope; E's dynamically-typed in ways that Haskell can't easily accomodate.
02:29:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:29:57 <Cale> dissipate: This comes back to the instance of the program on the other end, and it has a copy of the code for the function body already, because it's literally the same program.
02:30:08 <simpson> I've tried two or three times to replicate that kind of type system in Haskell and haven't enjoyed the process.
02:30:08 <the_berserker> @pl \f x -> scanl (\m _ -> f m) x
02:30:09 <lambdabot> scanl . (const .)
02:30:49 <dissipate> Cale, what about cases where you want to serialize a function and send it to some other program? why not serialize unit tests and send those along as well?
02:31:15 <Cale> dissipate: Well, that's difficult then, because what could you even send?
02:31:40 <Cale> You can't send a name for that code, because the other program won't know what you're referring to.
02:32:06 <Wizek> Morning!
02:32:14 <the_berserker> > (.) scanl ((.) const) [0..] (*2) 1
02:32:15 <lambdabot>  Couldn't match expected type `(a0 -> a0) -> a0 -> a0'
02:32:15 <lambdabot>              with actual type `[t0]'
02:32:30 <dissipate> Cale, you wrap the function to be sent in another function that runs the unit tests when it is called
02:32:51 <the_berserker> @type \f x -> scanl (\m _ -> f m) x (repeat ())
02:32:52 <lambdabot> (a -> a) -> a -> [a]
02:33:07 <the_berserker> @type \f x -> scanl (\m _ -> f m) x
02:33:07 <Cale> dissipate: No, you misunderstand -- you can't serialise the thing in a way which will make any sense to the receiving program if it doesn't already know about it ahead of time.
02:33:08 <lambdabot> (a -> a) -> a -> [b] -> [a]
02:33:30 <Cale> dissipate: Unless you're talking about sending source code for the program across and having it compiled on the other end.
02:33:39 <Wizek> Is there a simple and elegant way to collapse Maybes? `Maybe (Maybe a) -> Maybe a`
02:33:50 <opqdonut> join
02:33:51 <Cale> (and even then, there are lots of problems with making it possible to turn functions back into source code at runtime)
02:33:59 <jle`> Wizek: funny you should ask
02:34:02 <dissipate> Cale, yep, you can just do an eval as well.
02:34:04 <the_berserker> @pl \f x -> scanl (\m _ -> f m) x l
02:34:04 <lambdabot> flip flip l . scanl . (const .)
02:34:05 <opqdonut> > join (Just (Just 1)) -- Wizek
02:34:06 <lambdabot>  Just 1
02:34:12 <opqdonut> > join (Just Nothing) -- Wizek
02:34:13 <lambdabot>  Nothing
02:34:27 <jle`> Wizek: that's actually more or less the exact ability that a monad gives you
02:34:31 <opqdonut> Wizek: in some sense join is the fundamental operation of a Monad, the ability to collapse Maybe like that makes it a Monad
02:34:34 <jle`> the ability to collapse a nested structure
02:34:41 <the_berserker> @pl \l -> flip flip l . scanl . (const .)
02:34:41 <lambdabot> flip (flip . scanl . (const .))
02:34:42 <Cale> dissipate: But of course, if you're sending source code, you don't have to send unit tests, you just have to send *enough* code.
02:35:05 <the_berserker> @type flip (flip . scanl . (const .))
02:35:05 <Cale> i.e. provide enough that there are no remaining free variables in it
02:35:06 <lambdabot> [b] -> (a -> a) -> a -> [a]
02:35:17 <Wizek> Thanks, trying it out.
02:35:36 <the_berserker> @type const iterate
02:35:37 <lambdabot> b -> (a -> a) -> a -> [a]
02:35:54 <jle`> Wizek: in fact you could even say without too much of a stretch that monads are 'defined' as such collapsible structures.  equipped with also a wrapping function.  implemented in reasonable ways.
02:36:39 <jle`> > join :: [[a]] -> [a]
02:36:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
02:36:40 <lambdabot>    arising from a use of `M1679740196814494849717.show_M1679740196814494849717'
02:36:40 <lambdabot>  The type variable `a0' is ambiguous
02:36:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:36:40 <lambdabot>  Note: there are several potential instances:
02:36:44 <jle`> why did i > that
02:37:28 <startling> there's a stupid Show instance for functions.
02:37:56 <Wizek> startling: what do you mean?
02:38:04 <Cale> > join :: [[Integer]] -> [Integer]
02:38:05 <lambdabot>  <[[Integer]] -> [Integer]>
02:38:05 <jle`> i am aware of the show but i probably did not intend to actually send it to lambdabot
02:38:11 <the_berserker> @pl \c a b -> if c then a else b
02:38:11 <lambdabot> if'
02:38:53 <the_berserker> @pl \c a b -> if c then Left a else Right b
02:38:53 <lambdabot> flip flip Right . ((.) .) . (. Left) . if'
02:39:08 <jle`> Wizek: lambdabot has a Show instance for functions that comes from Typeable/typeOf
02:39:20 <jle`> :t ord
02:39:21 <lambdabot> Char -> Int
02:39:39 <cpa> I have this expression and I want to see each value of my list as it passes through dropWhile first012 = head . dropWhile isOk so I tried this:
02:39:42 <cpa> ofirst012 n = filterM (\w -> print w >> return $ not $ isOk w) n >>= return . head
02:39:45 <cpa> but now it leaks memory
02:39:50 <the_berserker> > join . return . putStrLn $ "Hello world!"
02:39:51 <lambdabot>  <IO ()>
02:40:21 <dissipate> Cale, BTW, you wouldn't happen to know why Control.Lens.Type shows up in a search for 'Overloading' on 'hayoo'? http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:Overloading
02:40:23 <cpa> and doesn't work on infinite list too, any ideas why?
02:40:46 <dissipate> when i go to the source code for 'Control.Lens.Type', there is no Overloading anywhere
02:40:59 <the_berserker> > >>=)
02:41:00 <lambdabot>  <hint>:1:1: parse error on input `>>='
02:41:02 <jle`> @src filterM
02:41:02 <lambdabot> Source not found. Abort, Retry, Panic?
02:41:08 <the_berserker> > (>=)
02:41:09 <lambdabot>  <() -> () -> Bool>
02:41:35 <Cale> dissipate: Probably whatever version of lens was latest when it last indexed it defined something called Overloading in that module
02:41:49 <Wizek> cpa: Debug.Trace.trace or Data.List.scanl?
02:41:51 <jle`> cpa: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#filterM
02:42:12 <Cale> type Overloading p q f s t a b = p a (f b) -> q s (f t)
02:42:17 <Cale> http://hackage.haskell.org/package/lens-3.9.0.3/docs/Control-Lens-Type.html
02:42:19 <the_berserker> > \f g x -> m x >>= n
02:42:20 <lambdabot>  Couldn't match expected type `t0 -> m0 a0'
02:42:20 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
02:42:20 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
02:42:28 <jle`> try doing manual substitution/equational reasoning stuff and see that it builds up an infinite IO object
02:42:36 <jle`> for an infinite list
02:42:48 <the_berserker> > \f g x -> f x >>= g
02:42:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable1 m0)
02:42:49 <lambdabot>    arising from a use of `M49190486860698269159777.show_M49190486860698269159...
02:42:49 <lambdabot>  The type variable `m0' is ambiguous
02:42:49 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
02:42:49 <lambdabot>  Note: there are several potential instances:
02:42:58 <Cale> type Optical p q f s t a b = p a (f b) -> q s (f t)
02:43:04 <Cale> ^^ aha, it's been renamed
02:43:04 <startling> clearly
02:43:12 <jle`> but i guess i also have to explain why it isn't lazy
02:43:19 <dissipate> Cale, ah, i see. thanks. looks like i need to install the older version of the module.
02:43:32 <Cale> dissipate: You could just rename Overloading to Optical
02:43:43 <cpa> jle`: no no I get it. Stupid mistake.
02:43:47 <Wizek> join works as expected, thanks!
02:43:52 <cpa> but how I can do, then
02:44:05 <the_berserker> @pl \ m n x -> do {y <- m x; n y}
02:44:05 <lambdabot> (line 1, column 15):
02:44:05 <lambdabot> unexpected '{'
02:44:05 <lambdabot> expecting variable, "(", operator or end of input
02:44:11 <jle`> > head (filter (> 3) [1..])
02:44:12 <lambdabot>  4
02:44:19 <milfjord> the_berserker: @undo first
02:44:22 <cpa> Wizek: debug.trace hurts performance a lot in my experience, not sure how to use scanl
02:44:24 <the_berserker> @pl \m n x -> m x >>= n
02:44:24 <Wizek> Btw, can I somehow provide partial type declarations for my values/functions?
02:44:25 <lambdabot> flip . ((>>=) .)
02:44:45 <startling> Wizek: not really.
02:45:12 <jle`> cpa: not sure if any sort of stdout printing would be faster than debug.trace, if that is your bottleneck
02:45:13 <cpa> jle`: but I want to see the progression of filter, since it is a very long list
02:45:21 <milfjord> Wizek: http://okmij.org/ftp/Haskell/types.html#partial-sigs
02:45:23 <cpa> oh, okay
02:45:38 <jle`> don't know for sure though
02:45:58 <jle`> Tekmo wrote an article about this recently though
02:46:03 <jle`> if you're willing to learn some pipes
02:46:14 <dissipate> Cale, ah, that worked. but now something else bombed out during compilation of this app.
02:46:32 <jle`> cpa: http://www.haskellforall.com/2014/02/streaming-logging.html
02:46:40 <the_berserker> @pl \m f g -> (m >>= f) >>= g
02:46:40 <lambdabot> ((>>=) .) . (>>=)
02:46:52 <Wizek> Yay! "Contrary to a popular belief, both of the above are easily possible, in Haskell98." Now I just need to figure out how. :)
02:47:01 <startling> the_berserker, that's just m >>= f >>= g
02:47:19 <milfjord> Wizek: follow the first link
02:47:22 <the_berserker> @pl \m f g -> m >>= (\x -> f x >>= g)
02:47:22 <lambdabot> (. (flip . ((>>=) .))) . (.) . (>>=)
02:47:26 <cpa> jle`: thanks, I'll take a look
02:48:37 <jle`> it's not exactly about what you are doing, it expands on it with some extra stuff
02:49:05 <jle`> but i think in this case if you want to just debug
02:49:15 <jle`> Debug.Trace should be as good as anything
02:49:45 <jle`> what are you trying to do exactly, in the long run?
02:50:13 <cpa> working on problem 303 on project euler
02:50:54 <cpa> nothing fancy, but I have some very long lists of possible values and I stop whenever I reach a value that satisfies the condition
02:51:22 <cpa> fact is, this value can be very far from the head of the list
02:52:17 <cpa> so the possible value always increase, so I want to make sure I'm not overflowing my Word64 or something, which would throw me in an infinite loop
02:52:37 <cpa> but since I use laziness to create those values, it's quite hard to monitor anything
02:53:46 <startling> cpa, tryToInc n = let n' = n + 1 in if n' > n then Just n' else Nothing
02:54:01 <startling> cpa: (why are you using a Word64?)
02:54:29 <cpa> because I wanted to use the larget unsigned int type I could
02:54:35 <cpa> largest*
02:54:40 <startling> cpa, an Integer will save you a headache.
02:54:42 <jle`> why not Integer?
02:54:42 <milfjord> how about Integer?
02:54:51 <cpa> it's much slower
02:55:19 <startling> cpa, it's much slower than using a Word64 and not checking. is it much slower than using a Word64 and checking?
02:55:22 <jle`> (\/) (',,,,') (\/) . o O ( Why not Integer? )
02:55:48 <bitemyapp> jle`: *snort*
02:55:49 <milfjord> Z
02:56:08 <bitemyapp> startling: well, I've only found one Stack Overflow post that addresses my question and the code in it was broken.
02:56:08 <startling> cpa, there's also http://hackage.haskell.org/package/nats which provides an "unsigned" wrapper around Integer.
02:56:19 <bitemyapp> (admittedly so, according to an edit from the original author)
02:56:21 <startling> bitemyapp: yeah, I don't have any idea about that. sorry. :(
02:56:31 <bitemyapp> so, I appear to be up the proverbial creek for streaming data into a chart/plot
02:56:36 <bitemyapp> this is...sub-optimal.
02:56:37 <cpa> I don't want to check for every operation, just for some very specific values
02:56:49 <cpa> oh right, for those values I could just use an Integer
02:57:00 <startling> bitemyapp, does it have to be a native GUI thing? I feel like there's a javascript graphing library that does this.
02:57:03 <startling> cpa: haha, yes
02:57:06 <cpa> mmhh, call me stupid, I'll do that right now
02:57:32 <startling> bitemyapp: ( http://smoothiecharts.org/ )
02:57:47 <bitemyapp> startling: that's javascript.
02:58:09 <bitemyapp> startling: It doesn't necessarily need to be native, but the data source is Haskell
02:58:15 <startling> bitemyapp, so write a Haskell backend and a web frontend.
02:58:25 <bitemyapp> yeah, that's sounding the most practical right now
02:58:34 <bitemyapp> guess I'd better track down how to do websockets.
02:58:50 <bitemyapp> Hopefully http://hackage.haskell.org/package/wai-websockets works.
03:05:17 <bitemyapp> startling: thanks for the smoothie link
03:27:33 <dissipate> why don't cabal packages that depend on the Cabal library have it as a dep?
03:29:17 <obiwahn> 12:24:03   @obiwahn │ > let time x = 12+(1/60)*(x+12) in map time [30,45]                                                              │
03:29:20 <obiwahn> 12:24:03      +hbot │  Terminated
03:29:37 <obiwahn> how do i debug lambdabot?
03:29:48 <obiwahn> i am not sure how to pass the -v
03:31:09 <startling> bitemyapp: apparently d3 can do it too: http://mbostock.github.io/d3/tutorial/bar-2.html
03:31:37 <Wizek> http://stackoverflow.com/q/21658438/499478 <-- Further defined what I am looking for under 'partiall function signatures'. Anyone knows a nice way to do it?
03:32:19 <bitemyapp> startling: I really do not like d3.
03:32:37 <xintron> Is there any way to specify the amount of decimal points for `formatTime` (%q that is)
03:33:02 <startling> bitemyapp: fair enough!
03:36:55 <dissipate> anyone else having trouble installing the test-golden-framework package?
03:37:34 <dissipate> or more specifically test-framework-golden-1.1.3
03:44:03 <Feuerbach> dissipate: what's the trouble?
03:44:40 <dissipate> Feuerbach, ambiguous 'catch'
03:45:09 <Feuerbach> oh. what ghc version do you have?
03:45:17 <kuribas> WHat's a good cross platform GUI toolkit?  I need to be able to draw bezier curves...
03:46:29 <dissipate> Feuerbach, http://pastebin.com/NZ7r42nD
03:46:34 * hackagebot haroonga 0.1.0.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.0.0 (cosmo0920)
03:47:04 <dissipate> Feuerbach, 7.4.2
03:47:32 <Aetherspawn> .. lens is really really hard once you move past Lens'
03:47:36 <Aetherspawn> is there any tutoral for Iso' and such
03:47:45 <Aetherspawn> and just explaining what all those are without the confusing laws.
03:49:44 <obiwahn> > let time x = 12+(1/60)*(x+12) in map time [30,45]
03:49:45 <lambdabot>  [12.7,12.95]
03:51:23 <Feuerbach> dissipate: if it's your code that uses test-framework-golden, I highly recommend using tasty-golden instead. Otherwise, file an issue at github and I'll be able to upload a fix later today
03:52:10 <dissipate> Feuerbach, nope, it's not my code. i'm trying to build an app from a github repo.
03:52:24 <Feuerbach> dissipate: which one? just curious
03:54:30 <bennofs> I want to implement the following using conduit: given two Sources, a and b, run the source a first, and iff a doesn't produce any output, run b
03:54:34 <bennofs> How do I do this?
03:56:10 <dissipate> Feuerbach, the dyna language project: https://github.com/nwf/dyna
03:57:04 <Feuerbach> dissipate: cool. got to leave now. just file an issue, and I'll fix it later. You can also patch it locally by hiding catch from Prelude
03:57:26 <dissipate> Feuerbach, ok, will do.
03:57:53 <dissipate> BTW has anyone here successfully built dyna? https://github.com/nwf/dyna
03:58:14 <Feuerbach> dissipate: btw, if you're only interested in building it, you can disable the test suite
03:58:21 <Feuerbach> i.e. cabal install --disable-tests
03:58:52 <Feuerbach> then it won't try to install test-framework-golden and other testing-related packages
03:59:25 <dissipate> Feuerbach, i actually got past the problem by installing version 1.1.1 instead. but then another error with a different package occurred. :(
04:00:09 <Feuerbach> feel free to paste errors here — I'm sure people here will help you to get past them
04:01:36 <dissipate> Feuerbach, cool, thanks
04:03:36 <Aetherspawn> that moment when you read a type for like the 15th time
04:03:43 <Aetherspawn> and oohhh I get it. ;)
04:04:51 <dissipate> just got this error: src/Dyna/Analysis/Automata/NamedAut.hs:8:14:    Unsupported extension: InstanceSigs make: *** [build] Error 1
04:06:36 * hackagebot snap-cors 1.2.1 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.1 (OliverCharles)
04:10:04 <bennofs> Is there a better way to write: \a b -> flip execStateT False (a $$ awaitForever (\x -> lift (lift $ yield x) >> lift (put True))) >>= flip unless b ?
04:11:32 <mm_freak_> bennofs: yes, use a Writer instead
04:12:05 <mm_freak_> see Or in Data.Monoid
04:12:19 <bennofs> like: \a b -> runWriterT (a $$ awaitForever (\x -> lift (lift $ yield x) >> lift (tell $ Any True))) >>= flip unless b . getAny ?
04:12:21 <bennofs> @ty getAny
04:12:22 <lambdabot> Any -> Bool
04:12:46 <bennofs> > mempty :: Any
04:12:47 <lambdabot>  Any {getAny = False}
04:13:03 <bennofs> :t Or
04:13:04 <lambdabot> Not in scope: data constructor `Or'
04:13:31 <mm_freak_> oh yeah
04:13:32 <mm_freak_> Any
04:14:23 <mm_freak_> and to get rid of the lifts you can use a Writer/WriterT as the producer's base monad
04:14:44 <mm_freak_> see Pipes.Lift
04:14:54 <bennofs> mm_freak_: ah, forgot to mention, it's conduit
04:14:58 <mm_freak_> oh
04:15:17 <mm_freak_> since it's based on a similar technology, it probably has something like Pipes.Lift
04:16:16 <greg`> anyone use emacs with haskell data center?
04:16:37 * hackagebot digestive-functors-aeson 1.1.5 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.5 (OliverCharles)
04:16:56 <mm_freak_> bennofs: see transPipe in Data.Conduit
04:17:07 <mm_freak_> bennofs: oh, nevermind…  it won't work
04:17:50 <bennofs> I think I also need (hoist (lift . lift) a) instead of a, if a isn't polymorphic in it's base monad
04:18:41 <mm_freak_> bennofs: transPipe = hoist
04:18:54 <mm_freak_> but you can't use execWriter/runWriter with hoist
04:19:36 <mm_freak_> so i guess you can't really get rid of the lifts
04:19:54 <bennofs> mm_freak_: ($$) :: Source a m -> Sink a m -> m () I think
04:20:25 <bennofs> mm_freak_: Why can I not use execWriter/runWriter with hoist?
04:20:55 <mm_freak_> bennofs: because it's a type error
04:21:08 <mm_freak_> they aren't natural transformations
04:21:11 <bennofs> ah, you mean I cannot hoist execWriter ?
04:21:15 <bennofs> Yes, that's true
04:21:15 <mm_freak_> yeah
04:21:38 * hackagebot cabal-rpm 0.8.8 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.8 (JensPetersen)
04:22:02 <mm_freak_> at least switching to WriterT is an improvement
04:22:32 <bennofs> I could do the folding directly, using Data.Conduit.List.foldM I think
04:22:38 <bennofs> that would get rid of the writer
04:24:11 <bennofs> (a $$ CL.foldM (_ a -> True <$ lift (yield a)) False) >>= flip unless b
04:25:10 <mm_freak_> well, the WriterT isn't bad
04:25:15 <FreeFull> bennofs: "(_ a -> " What is this?
04:25:17 <mm_freak_> it's a good specification of intent
04:25:25 <FreeFull> Or did you miss a \
04:25:27 <bennofs> FreeFull: it's a lambda typo
04:25:31 <FreeFull> Ok
04:26:09 <mm_freak_> bennofs: alternatively you can delay the yielding to after the loop
04:26:16 <mm_freak_> bennofs: then you can use WriterT with Last instead of Any
04:26:18 <bennofs> mm_freak_: no, I don't want to do that
04:26:36 <bennofs> mm_freak_: I need the yielding to be instant
04:26:38 * hackagebot json-assertions 1.0.1 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.1 (OliverCharles)
04:28:00 <mm_freak_> bennofs: btw, you should probably use a strict writer
04:28:36 <bennofs> I think I'm going to use the foldM version, because it's simpler (IMO) and shows that the result is constant if there is at least one value produced by a. The WriterT version looks like it might still "add" to the result, even if you cannot ever change a 'Any True' to something else using only mappend
04:37:11 <greg`> lo?
04:37:44 <greg`> decided to stop masturbating over haskell theory and actually write something useful today
04:38:05 <nsno> :')
04:38:33 <randomclown> > haskell theory
04:38:35 <lambdabot>  Not in scope: `haskell'Not in scope: `theory'
04:41:27 <jophish_> haha! my typechecker works!
04:41:40 * hackagebot rdf4h 1.2.4 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.4 (RobStewart)
04:53:53 <pyr> hi haskellers!
04:55:37 <Twey> Hello pyr!
04:56:26 <troydm> pythoner?
04:56:59 <pyr> so I'm trying to do something with data.aeson which I can't figure out how to do
04:57:29 <pyr> i've built a few instances of FromJSON for custom types
04:57:43 <greg`> troydm you sound like you've spotted an intruder! lol
04:57:59 <pyr> and I'm stumbling on a specific use-case
04:58:09 <troydm> greg`: i've actually did! lol :)
04:58:39 <pyr> i'm parsing a list of objects which are all single-key, where the key represents the "type"
04:59:12 <pyr> [{"foo": "arg"}, {"bar": ["arg1", "arg2"]}]
05:00:09 <pyr> my dest type looks like: data Payload = FooArg String | BarArg [String], and in this case I'm parsing a [Payload]
05:04:26 <Twey> pyr: So, you'll want separate cases in your FromJSON instance for when the key is "foo" vs. when it's "bar"
05:05:30 <pyr> forwarding to different parsers based on the output of .:?
05:05:33 <pyr> for instance
05:06:35 <moop> sup peoples, how is threading done in haskell?
05:06:48 <Twey> fromJSON (Object v) | member "foo" v = FooArg <$> v .: "foo" | member "bar" v = BarArg <$> v .: "bar"
05:07:03 <Twey> pyr: That's another way, sure: you'll need to use Parser's Monad instance if you want to do that
05:07:17 <pyr> Twey: ah your way looks much better
05:07:19 <Twey> Oh, and | otherwise = empty
05:08:43 <Twey> Or, you might want to use: | keys v == ["foo"] = … to make sure you explicitly reject objects like { "foo" : "bar", "baz" : "quux" }
05:11:28 <Twey> pyr: The way you were thinking of would look like: fromJSON (Object v) = do foo ← v .:? "foo"; bar ← v .:? "bar"; case (foo, bar) of (Just foo', Nothing) → FooArg <$> foo'; (Nothing, Just bar') → BarArg <$> bar'; _ → empty
05:12:03 <pyr> Twey: yes, which ends up being a bit more clunky than what you propose
05:12:12 <Twey> pyr: Sorry, fromJSON (Object v) = do foo ← v .:? "foo"; bar ← v .:? "bar"; case (foo, bar) of (Just foo', Nothing) → return $ FooArg foo'; (Nothing, Just bar') → return $ BarArg bar'; _ → empty
05:12:17 <Twey> Yes
05:12:31 <Twey> I'd go with the guards myself
05:14:40 <Twey> moop: However you like ;)
05:15:02 <Twey> moop: The best default is probably to use forkIO and STM
05:15:41 <Twey> There are various other options along the elegance <=> power continuum, if that doesn't suit you
05:17:11 <Twey> moop: Notably, if you just want asynchronous pure computation you can use the ‘async’ package, which handles all the communication for you; or if you need better communication performance than STM will give you and don't mind writing locks yourself, you can use MVars and the Control.Concurrent module
05:18:38 <Twey> moop: s/pure // sorry — async also handles impure computation
05:19:28 <moop> Twey: ill check that out, thanks
05:20:26 <Twey> Fuuzetsu: Haddock bug: links in headers break the remainder of the header link: https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html (see ‘Contents’ section)
05:22:26 <Twey> moop: Also, if your problem can be expressed as a map over an array, the ‘Repa’ library lets you take advantage of GPUs and stuff
05:25:16 <pyr> Twey: works wonders, thanks a bunch
05:25:22 <Twey> No problem
05:26:45 * hackagebot data-stringmap 1.0.0 - An efficient implementation of maps from strings to arbitrary values  http://hackage.haskell.org/package/data-stringmap-1.0.0 (SebastianPhilipp)
05:30:45 <jophish_> what does import {-# SOURCE #-} mean?
05:32:13 <Twey> jophish_: https://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
05:34:01 <jophish_> super, thanks Twey
05:34:39 <Twey> No problem
05:36:03 <greg`> ive asked this before just grokking now
05:36:10 <mm_freak_> Twey: repa won't give you GPU support
05:36:14 <mm_freak_> but accelerate does
05:36:17 <greg`> does id match (a -> b) ?
05:38:40 <Twey> mm_freak_: Sorry, yes, that's what I was thinking of; moop ↑
05:39:02 <Twey> greg`: Yes
05:39:30 <Twey> greg`: The ‘b’ there (as well as the a) is a ‘non-rigid’ type variable, i.e. the compiler is free to instantiate it to whatever it pleases
05:39:48 <Twey> greg`: If you put id somewhere with that type, it will choose that b = a
05:40:11 <Twey> Or rather, b = a = a', where a' is the a from id
05:40:38 <greg`> thanks
05:41:13 <Twey> greg`: However, if you say foo ∷ a → b; foo = id you'll get a compiler error, because you've fixed the type variables by giving it a type signature
05:41:41 <greg`> aha , right thats what i am seeing in the compiler
05:41:50 <Twey> So while id *matches* a → b, doesn't itself have the type a → b
05:42:06 <Twey> id doesn't**
05:42:45 <greg`> oooooh
05:43:02 <greg`> thats like soo strange to me right now
05:43:43 <FreeFull> You can have a function   f :: (a -> b) -> (a -> b)    and give it id, and it will work
05:43:45 <greg`> ok fair enough i can dig it, acceptance must come before understanding
05:43:51 <Twey> It's perfectly intuitive logically, but it can be a little confusing when considered operationally
05:44:20 <FreeFull> And  f id  will end up having the type  a -> a
05:44:40 <FreeFull> (Or possibly b -> b depending on things, but those are equivalent)
05:45:36 <ion> The *caller* of “foo :: a -> b” gets to pick both “a” and “b”. If you implement it as “id” it will have the constraint that a = b because id :: a' -> a'. But that’s not what the type signature claims.
05:46:06 <greg`> thats exactly it , i totally get it , but im stuck on why
05:46:42 <ion> > let foo :: (a ~ b) => a -> b; foo = id in foo 42
05:46:44 <lambdabot>  42
05:47:03 <Twey> greg`: You can think of it like a ‘type function’: a type like a → b is really ∀ a b. a → b, where ∀ x. y is the type-level equivalent of the value-level lambda λ x → y
05:47:36 <FreeFull> ∀ is pronounced forall
05:48:46 <Twey> greg`: If you have FreeFull's f ∷ ∀ a b. (a → b) → (a → b), and you pass it id ∷ a' → a', you're implicitly giving it the type arguments a' a', so the resulting type is (a' → a’) → (a' → a')
05:49:52 <Twey> greg`: But you can't *say* you'll write a function ∀ a. a and then only implement it for *some* a for the same reason you can't say you'll write a lambda that takes an Int and then only define it for the case where the argument is 5
05:50:12 <Twey> (well, you can at the type level in Haskell, but it's partial, so we look upon it with scorn :þ)
05:50:22 <Twey> Er, at the value level**
05:51:42 <ion> Dunno if this line of thought is helpful or confusing: in an imaginary language in which you have explicit parameters for types, “foo :: {a} -> {b} -> a -> b” could be used like “foo Int Char 42” and “id :: {a} -> a -> a” could be used like “id Int 42”. If you implement foo as “foo = id {a} a”, the id can not return a value of type b because you never gave it {b}.
05:51:48 * hackagebot hspec-meta 1.8.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.8.2 (SimonHengel)
05:53:15 <greg`> ....*ruminates*
05:53:57 <ion> Uh, i meant “foo :: {a} -> {b} -> a -> b; foo {a} {b} a = id {a} a”. This is probably just confusing, just ignore me.
05:54:15 <greg`> ah i get it
05:54:25 <Twey> IMO it's clearest explained like that
05:54:33 <greg`> so the type declaration you are saying for all a
05:55:03 <greg`> forall a id is such that a -> a
05:55:18 <Twey> Right
05:56:04 <greg`> whereas the runtime can infer the types?
05:56:44 <Twey> Compare to a value-level function: ∀ a. a → a  promises to give a function a → a for any type a you pass in the same way  λ x → x + 1  promises to give a value x + 1 for any x you pass in
05:56:49 * hackagebot hspec 1.8.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.8.2 (SimonHengel)
05:57:12 <Twey> greg`: The compiler (not the runtime) just decides which type to instantiate that ‘a’ with
05:57:26 <Twey> I.E. which type to pass into the type-level function
05:58:43 <milfjord> types are almost completely a compile time thing
06:00:36 <merijn> greg`: In GHC (this is implementation specific and not required for other haskell implementations) types are erased at compile time
06:00:50 <merijn> greg`: i.e. there is no such thing as  a *type* in the compiled code
06:02:58 <greg`> ooooooh
06:03:14 <greg`> yes im familiar with the concept of erasure from java
06:03:40 <merijn> I'm pretty sure java doesn't erase types, does it?
06:03:53 <hpc> it "erases" them
06:03:54 <merijn> You can use "instanceof" in java, right?
06:04:04 <hpc> but you can still get stuff like... well that
06:04:17 <hpc> and .class, and reflection
06:04:40 <merijn> greg`: Does the term "unification" mean anything to you?
06:10:43 <greg`> merjn not particularly
06:10:54 <greg`> unification - no cant say ive heard of it
06:13:56 <merijn> greg`: unification is basically the process of taking two types "a -> Foo" and "b -> c" for example and trying to see if they match (you're trying to unify them), you do this by treating it as a system of equations and if you can succesfully solve, they match
06:14:20 <merijn> greg`: For example, unifying those two types gives us the following equations "a == b" and "Foo == c"
06:15:05 <merijn> greg`: In this case you'd be done, but imagine there are more types around and a, b and c are used elsewhere too. You keep matching and seeing if you can still solve all the constraints succesfully
06:15:16 <merijn> If not, you have a type error, if so than it type checks
06:15:31 <merijn> This, for example is why I can do:
06:15:36 <merijn> :t id :: Int -> Int
06:15:37 <lambdabot> Int -> Int
06:16:04 <merijn> greg`: id has type "a -> a" and if I unify that with "Int -> Int" I get the constraint "a == Int", which succeeds
06:16:19 <merijn> greg`: (since a variable like 'a' can succesfully match any type)
06:16:55 <merijn> greg`: It'd fail with "id :: Int -> Float" as that'd give me two constraints: "a == Int" and "a == Float", obviously 'a' can't be both an Int *and* a Float
06:19:57 <cpa> how do I convert a Set Int into an IntSet?
06:20:19 <merijn> > IS.fromList . S.toList -- ?
06:20:20 <lambdabot>  <Set Int -> IntSet>
06:21:34 <cpa> will it be constant space?
06:21:57 <cpa> I thought about that but wasn't sure it's the most efficient way to do it
06:22:01 <merijn> Maybe? I don't know?
06:22:51 <nh2> what guarantees me that realToFrac is a no-op between Double and CDouble?
06:29:10 <FreeFull> nh2: It won't be a no-op, but it should be O(1). Not sure how it behaves for -Inf, NaN and Inf
06:30:45 <Twey> newtype CDouble = CDouble Double -- Defined in `Foreign.C.Types'
06:30:50 <Twey> It's probably a no-op
06:31:32 <kosmikus> nh2: it'll be a noop in many situations. CDouble normally is a newtype wrapper around Double. There are GHC Rule pragmas that'll turn realToFrac between Double and CDouble into a realToFrac between Double and Double by applying the constructor. Applying the constructor is a no-op, and there's a Double/Double instance having id as implementation.
06:32:08 <FreeFull> Ah, I forgot to consider rewrite rules
06:32:18 <kosmikus> nh2: that being said, it's known that while simple applications of newtype constructors are newtypes, that doesn't translate to all contexts (such as mapping the constructor over a datastructure, for example)
06:32:56 <FreeFull> kosmikus: realToFrac isn't part of a typeclass though, it is defined as realToFrac = fromRational . toRational
06:34:38 <kosmikus> FreeFull: hm, you're right, I've been looking at the wrong place. let's check again.
06:35:24 <bennofs> I have a Data.Map Int [Int]. I now want to remove the head element from the list for a given key (the list can assumed to be non empty) and also get the removed element. Is there a Data.Map operation which combines the modification with the lookup?
06:36:40 <nh2> kosmikus, FreeFull: I really hope that realToFrac has rewrite rules for Double/CDouble and Float/CFloat (since *all* FFI tutorials use it), but I can't find the rules in the code
06:37:07 <kosmikus> FreeFull, nh2: ok, I was wrong about the type class. realToFrac has a rewrite rule for Double/Double mapping to id though (in GHC.Float).
06:37:48 <kosmikus> FreeFull, nh2: so it's still a combination of two rewrite rules which will say that from Double to CDouble you just have to apply the newtype constructor.
06:37:59 <nh2> kosmikus: and that works through the newtype, I see
06:38:17 <bennofs> > M.insertLookupWithKey (\_ xs _ -> tail xs) 3 (error "This should not be used!") $ M.fromList [(1,[1,2,3]), (3, [2,3,4])]
06:38:19 <lambdabot>  (Just [2,3,4],fromList [(1,[1,2,3]),(3,*Exception: This should not be used!
06:38:33 <bennofs> Can anyone explain this? I thought this would be lazy in the error argument
06:39:09 <nh2> bennofs: do you know this one? http://neilmitchell.blogspot.co.uk/2013/08/destroying-performance-with-strictness.html
06:40:11 <kosmikus> nh2: compile "Rule fired: realToFrac/a->CDouble
06:40:11 <kosmikus> Rule fired: realToFrac/Double->Double
06:40:16 <kosmikus> sorry, wrong paste
06:40:45 <kosmikus> nh2: compile "print (realToFrac (2 :: Double) :: CDouble)" with -O -ddump-rule-firings
06:41:01 <kosmikus> nh2: then you can see that both realToFrac/a->CDouble and realToFrac/Double->Double fire
06:41:32 <bennofs> nh2: But I'm not even using the Strict Map! It's from the lazy one
06:41:32 <kosmikus> one is defined in Foreign.C.Types, the other in GHC.Float
06:42:42 <bennofs> Btw, did the alterF proposal get accepted?
06:45:57 <jmcarthur> > M.insertLookupWithKey (\_ xs _ -> tail xs) 3 (error "This should not be used!") $ M.fromList [(1,[1,2,3]), (3, [2,3,4])]
06:45:58 <lambdabot>  (Just [2,3,4],fromList [(1,[1,2,3]),(3,*Exception: This should not be used!
06:46:02 <jmcarthur> > M.insertLookupWithKey (\_ _ xs -> tail xs) 3 (error "This should not be used!") $ M.fromList [(1,[1,2,3]), (3, [2,3,4])]
06:46:04 <lambdabot>  (Just [2,3,4],fromList [(1,[1,2,3]),(3,[3,4])])
06:46:10 <jmcarthur> bennofs: ^^
06:47:22 <jmcarthur> bennofs: the type of that function is a bit confusing, is all.
06:47:49 <milfjord> wait, xs was the error?
06:48:26 <jmcarthur> bennofs: actually, it's kind of dumb. it's (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a), but it seems like it could be (Key -> a -> b -> a) -> Key -> b -> IntMap a -> (Maybe a, IntMap a)
06:48:36 <jmcarthur> oops
06:48:52 <jmcarthur> i mean:   (Key -> b -> a -> a) -> Key -> b -> IntMap a -> (Maybe a, IntMap a)
06:49:08 <jmcarthur> milfjord: the error was the argument ordering
06:49:09 <bennofs> jmcarthur: wait, you mean the value to be inserted comes first? :O
06:49:26 <bennofs> That's really confusing
06:49:32 <milfjord> jmcarthur: I mean the (error "...") expression
06:49:50 <jmcarthur> bennofs: think of it this way:    (Key -> a -> a -> a) -> (Key -> a -> IntMap a -> (Maybe a, IntMap a))
06:50:09 <jmcarthur> bennofs: the first argument of the function is meant to have the same argument ordering as the rest of the function
06:50:22 <bennofs> ah ok
06:51:28 <bennofs> jmcarthur: Do you know if the alterF proposal get accepted?
06:51:52 <jmcarthur> oh, i see why the type is that way (value to insert is same type as values in IntMap). it needs that for when the key doesn't already exist in the map
06:52:03 <jmcarthur> oh, somewhere along the lines i switched to IntMap. sorry
06:52:15 <jmcarthur> bennofs: no idea. it seemed to have a positive reception
06:53:06 <bennofs> I could write this so much nicer, without using undefined, if I had alterF :|
06:56:51 <merijn> EvilHaskellTips on twitter is my kind of person :>
06:59:40 <haasn> merijn: awesome
07:01:06 <jmcarthur> bennofs: http://hackage.haskell.org/package/lens-4.0.2/docs/Control-Lens-At.html#t:At
07:02:09 <bennofs> jmcarthur: I know of at, but I think the implementation is currently not so efficient because there is no alterF
07:05:20 <jrmithdobbs> weren't there changes in ix/at to address that in 4 i thought?
07:05:41 <jrmithdobbs> (thought that was why ixed dropped a type param)
07:06:59 <lostman> is there a way in yesod to make the _SESSION cookie work with multiple subdomains? by default it is sent to all paths in approot but I also want foo.approot
07:10:33 <jmcarthur> bennofs: yes, but i thought you were basically just after the expressibility
07:15:24 <jrmithdobbs> does anyone have an (good) example somewhere of a non RD parser for a templating/substitution language? I have expressions marked by a delimiter (lets say $(expr)) and everything outside of that delimitter needs to be copied verbatim but inside the delimiter I want recursive substitution... the exprs are fairly trivial but the structure isn't =/
07:16:04 <jrmithdobbs> if i want to parse lambda calculus i can find a million great examples ;p
07:19:54 <jmcarthur> why non-RD?
07:21:12 <haasn> “If you're confused enough to want to pen a monad tutorial, write a Lens tutorial instead. At least you'll know you're confused.” :
07:21:13 <haasn> :)
07:23:03 <jrmithdobbs> right now i just have a simple attoparsec parser that searches out the expr marker and shoves the tokens into a rose tree from Data.Tree (and yes, that really is the structure i want, pretty sure) the tokens atm, before complicating things (and why I'm looking at changing the parser), are basically just Maybe (Either Text Text) where the state is whether or not they've been processed (eg, Just Left == plain string, Just Right == more processing requ
07:23:56 <jmcarthur> interesting. why make it stateful like that?
07:23:59 <jrmithdobbs> and then walks the tree and hopes for termination
07:24:20 <jrmithdobbs> jmcarthur: I need to be able to do the actual "processing" in different user defined ways
07:26:33 <jmcarthur> jrmithdobbs:   class FromString a => Template a where substitute :: a -> a       newtype AnyTemplate = AnyTemplate (forall a. Template a => a)      templateParser :: Parser AnyTemplate
07:26:47 <jrmithdobbs> by structuring the tokens like that the structure of the tree defines the operation, eg a Node with an Empty root and no children == noop (parser hit end of string right after end of expr or begining of expr right at begining of string, eg), Node with a Just Left head and no children is a plain string, anything else needs processing
07:27:05 <jmcarthur> jrmithdobbs: well, and i guess you might want it to be a Monoid too, so just add that as a constraint on Template or in AnyTemplate
07:28:38 <jmcarthur> jrmithdobbs: so one possible implementation would be    newtype SimpleTemplate = SimpleTemplate ((String -> Maybe String) -> Either Error String)   where that argument is kind of an environment
07:29:02 <jmcarthur> but you could define whatever others you want. importantly, no state is required in the result unless the implementation demands it
07:29:56 <jrmithdobbs> ya it's currently actually Monad m => (Text -> m Text) -> Text (and scope is passed by partially applying a lookup function before passing)
07:30:19 <jrmithdobbs> err with another -> Text there
07:31:16 <jrmithdobbs> jmcarthur: ok well, basically you just told me to do it the way i'm already doing it, lol
07:31:32 <jmcarthur> i don't see where this stateful iteration over the tree comes in
07:31:40 <jmcarthur> what i have in mind doesn't involve that
07:32:06 <jmcarthur> i also don't see what any of it has to do with the parser itself
07:33:34 <jrmithdobbs> jmcarthur: terms like $(ex$(ex$(expr)pr)pr) work from the tree and i'm trying to extend the actual expressions past simple interpolation and realized how annoying it is with how the parser currently works
07:34:09 <jrmithdobbs> right now it'd be easier to do a 2-phase parse (pull out exprs then parse them)
07:34:16 <jrmithdobbs> and i'm trying to avoid that
07:34:39 <jrmithdobbs> jmcarthur: the thing is this lookup once generated in the tree will be used over and over and over again with different scopes
07:35:46 <jmcarthur> sorry, i just still don't see it, although i didn't realize you are trying to generalize it. what kind of operations are you wanting to support?
07:37:29 <jrmithdobbs> just some basic iteration stuff initially (eg for/while) but that takes it from simple map lookups to a whole different beast ;p
07:38:42 <jmcarthur> i assume that since you are doing loops you are also adding some ability to work with state, like "mutable" variables or something
07:39:06 <jmcarthur> in which case this sounds like a fairly complicated templating language :)
07:39:31 <jrmithdobbs> that is a possibile future enhancement yes, i'm trying to not make that painful later, basically ;p
07:44:46 <jrmithdobbs> jmcarthur: but ya, i guess you're right, the parser doesn't have much to do with my concerns now that i think about it
07:46:44 <jrmithdobbs> maybe the problem is i *should* just extend the exprs to a form of lambda calculus and use bound, lol
07:47:11 <jrmithdobbs> (not actually an option
07:49:44 <merijn> Anyone know how I can get decent tags integration with vim? I tried several options now (lushtags only generates for a single file, hothasktags results in jumping to case insensitive matches, vim-hdevtools is supposed to somehow let you jump to definitions, but I haven't figured out how..)
07:49:56 <Twey> jrmithdobbs: Why not an option?  :þ
07:50:09 <jrmithdobbs> Twey: target audience
07:50:23 <Twey> jrmithdobbs: They don't have to know what your templating system looks like inside
07:50:42 <jrmithdobbs> that's true, i guess i could implement it that way and expose a simpler syntax
07:51:12 <Twey> Templates are basically functions; substitution is just function application
07:51:38 <Twey> You might want to hide the higher-order templates from the end-users though :þ
07:51:48 <Twey> (or maybe not)
07:51:59 <jrmithdobbs> :)
07:52:51 <Twey> Some templating languages have macro systems, which sounds a lot like higher-order templates to me
07:53:02 <mm_freak_> jrmithdobbs: i use blaze-html with functions for templating
07:54:01 <mm_freak_> it's a sensible "template engine", because it's both powerful (you hold the power of full haskell in your hands) and simple (it's just a very simple monoid)
07:54:03 <magthe> Does anyone know what `ghc-split` is used for?
07:54:27 <mm_freak_> and yeah, higher order templates are very nice to work with =)
07:55:05 <exicer> How does bind look for Either ?
07:55:39 <merijn> exicer: Left x >>= f = Left x; Right x >>= f = f x
07:56:04 <jmcarthur> @src Either (>>=)
07:56:04 <lambdabot> Left  l >>= _ = Left l
07:56:04 <lambdabot> Right r >>= k = k r
07:56:46 <jrmithdobbs> mm_freak_: unfortunately i'm not templating anything as standardized as html, heh
07:57:09 <mm_freak_> jrmithdobbs: functions work for everything =)
07:57:17 <mm_freak_> jrmithdobbs: functions and monoids ideally
07:57:20 <exicer> merijn: Ah, okay thanks!
07:57:58 <exicer> Is there a way to enter a do-block of a different monad within a do block? Does this question even make sense ?
07:58:54 <jrmithdobbs> mm_freak_: ya, i'm already parsing into a rosetree and the walking over it with a user supplied monad (errors besides parsing as treated as empty strings so don't need monadplus even, could almost do it with a monoid except the sequencing for the recursion)
07:59:05 <tomejaguar> exicer: You can have a do inside a do.  They don't have to be in the same monad.
08:00:37 <mm_freak_> exicer: don't ask yourself such a question without looking at types
08:00:54 <exicer> mm_freak_: I think it should make sense, but was not sure.
08:01:25 <mm_freak_> exicer: the question only makes sense in combination with a type
08:01:51 <exicer> Hm, yeah I guess
08:02:00 <mm_freak_> exicer: for example there is a function from 'STM a' to 'IO a'
08:02:12 <mm_freak_> so you can write:  do …; atomically (do …); …
08:02:23 <mm_freak_> this is not notation…  it's related to the type of 'atomically'
08:02:29 <mm_freak_> atomically :: STM a -> IO a
08:02:45 <exicer> I don't know what atomically is
08:02:57 <exicer> Actually I don't even remember hearing about it :p
08:03:03 <mm_freak_> exicer: it's not important (it runs an STM transaction)
08:03:10 <tomejaguar> You don't have to know it, you have to look at its type.
08:03:31 <exicer> Ah, true
08:04:27 <exicer> So it relies on their being a function between the two monads ?
08:05:54 <merijn> exicer: Right
08:06:55 <merijn> exicer: You can also take a look at how do-notation desugars, then look at the types of the desugared code to see if they make sense
08:13:23 <jrmithdobbs> mm_freak_: I'm actually toying with (semi-successfully) not even taking a user supplied monad but just a monoid and doing the sequencing with Free
08:13:28 <jrmithdobbs> mm_freak_: it's ... interesting
08:15:16 <mm_freak_> jrmithdobbs: i don't know how to respond
08:15:42 <jrmithdobbs> mm_freak_: haha, i said toying ;p
08:16:07 <mm_freak_> =)
08:34:14 <DMcGill> the package bimap hasn't been updated since 2008, are there any better alternatives to encode a binary relation?
08:36:58 <Twey> DMcGill: Bimap is just two maps in a pair; I'm not sure what updates one would expect it to get :þ
08:37:08 * hackagebot hopfli 0.1.0.0 - zlib compatible compression using Zopfil Compression Algorithm  http://hackage.haskell.org/package/hopfli-0.1.0.0 (ananthakumaran)
08:38:42 <DMcGill> hmm I might define my own then because I'm really after a commutative bimap (i.e. a symmetric relationship)
08:39:37 <exicer> Can anyone point me to some detailed examples of using the persistent module? I am finding it quite cumbersome to use, probably because I don't quite understand the types.
08:39:37 <Twey> I think you'll end up just writing bimap
08:40:27 <Twey> exicer: Combersome how, exactly?
08:41:58 <Twey> Cumbersome** damn, my typing has gone down the drain lately
08:44:22 <DMcGill> Twey: you were right, `areRelated x1 x2 bimap = B.pairMember (x1,x2) bimap || B.pairMember (x2,x1) bimap' is fine for my use
08:45:09 <exicer> For instance, I would like to have some test data to play around with while I develop. So I insertBy some users, and then want to insert some blogposts based on the keys that those insertBy's return.
08:45:14 <exicer> Twey: ^
08:45:47 <exicer> I am certain there is some good way to do this, but I am getting confused by all of these monad transformers
08:51:15 <Twey> exicer: So something like: mapM insert yourUserList >>= mapM insertSomeBlogPostsBasedOn
08:52:56 <Twey> Where insertSomeBlogPostsBasedOn key = insert $ BlogPost { title = "Foo", content = "Bar", author = key }
08:53:30 <exicer> Twey: Yes, so I can do that if I use an in memory database. I don't know how I can do this with an on disk database though (since it will try to insert stuff again that should be unique)
08:53:36 <merijn> Which package had the local hoogle program?
08:53:55 <Twey> exicer: You should be using a fresh database for your tests
08:54:33 <exicer> I say tests, what I really mean is me messing around while I try to learn what is going on :p
08:54:40 <Twey> Aha :þ
08:54:51 <Twey> Well, you can use insertUnique to ignore keys that already exist
08:55:12 <exicer> Oh, that is exactly what I'm looking for
08:55:33 <Twey> mapM insertUnique yourUserList >>= \case Nothing → {- already exists, nothing to do here -} return (); Just key → mapM insertSomeBlogPostsBasedOn key
08:55:41 <Twey> (LambdaCase is lovely, use more of that)
08:56:18 <Twey> (though in this case you could also say >>= maybe (return ()) (mapM insertSomeBlogPostsBasedOn)
08:56:35 <Twey> Oh, no you couldn't, that's a list, sorry
08:56:53 <Twey> You need to do that case in insertSomeBlogPostsBasedOn
08:57:01 <Twey> (or maybe)
08:57:18 <exicer> Okay, that doesn't look so bad then.
08:57:38 <exicer> Thanks :)
08:57:41 <Twey> No problem
08:58:53 <Twey> Also,  mapM insertUnique yourUserList >>= mapM insertSomeBlogPostsBasedOn  ≡  mapM (insertUnique >=> insertSomeBlogPostsBasedOn) yourUserList, of course
08:59:50 <Twey> The fact that it's a monad transformer doesn't even come into it unless you want to use IO, in which case you just have to make sure you wrap the IO action in liftIO
08:59:59 <Twey> Though it doesn't sound like you do
09:01:14 <Fuuzetsu> Twey: post that link again for the Haddock stuff
09:01:43 <Twey> Fuuzetsu: http://hackage.haskell.org/package/async-2.0.1.4/docs/Control-Concurrent-Async.html
09:02:28 <Fuuzetsu> ty
09:05:49 <drostie> Curiosities about Haskell after 2 years of playing with it:
09:06:02 <drostie> (1) passing the typechecker is that same sort of logic-puzzle exercise that Sudoku is.
09:07:06 <drostie> (2) Haskell notation is missing some things which I need in my mathematical physics context, but I'm getting more and more convinced that we should switch to Haskell syntax for day-to-day mathematics.
09:07:11 <Twey> drostie: Except not trivially decidable :þ
09:07:21 <Twey> drostie: You might enjoy Agda.
09:07:43 <Twey> Agda is basically Haskell with more freedom of syntax and a more advanced type system.
09:07:48 <Fuuzetsu> Twey: I bet that could even be used to insert images into the Contents. Anyway, http://trac.haskell.org/haddock/ticket/276
09:08:05 <nooodl> more freedom of syntax? like if_then_else_?
09:08:11 <Twey> Fuuzetsu: Dzięki
09:08:18 <Fuuzetsu> Twey: don't forget no libs
09:08:26 <Fuuzetsu> and being slow
09:08:56 <drostie> Twey: interesting... but I guess what I'm saying is that Haskell has a nice syntax. It's sort of lispy in the sense that you can figure out what exactly the parse tree is while you're writing something.
09:09:10 <drostie> So more freedom of syntax is not necessarily what I want. ^_^
09:09:22 <Twey> Fuuzetsu: If you'd join forces with me to build Adage, we could help fix that… :þ
09:09:36 <Fuuzetsu> is Adage going to be written in Haskell
09:09:42 <Fuuzetsu> why not just re-use Hackage?
09:10:42 <Twey> drostie: Aha.  Yes, Haskell syntax is not bad.  Prima facie, I prefer Lisp syntax for its simplicity (did you know there's a project called FunMath where Sussman [I think] advocates using sexprs for mathematical notation?); but the way Haskell syntax integrates with the semantics of the language is much more elegant
09:10:55 <drostie> or when you write foldDefault f ta = runConst (traverse (Const . f) ta), the syntax is nice because you can just see that both ta and f are at the end of the tree so there is a point-free version, and with a bit of rule-based reasoning you can figure out what that is.
09:11:22 <Saizan> 18
09:11:29 <Twey> Fuuzetsu: I don't know about ‘re-use’.  You could certainly *fork* Hackage.
09:11:43 <Twey> Or patch it to accept Agda modules, I suppose
09:11:56 <Fuuzetsu> Twey: Did you know that there's a project called <insert anything> where <someone> advocates using sexprs for <something> notation?
09:12:11 <Twey> Heheh
09:12:12 <Fuuzetsu> Twey: Well, yeah, that's what I mean. Just use their code and host own instance.
09:12:19 <drostie> I knew about Sussman's desire to do math and physics with Lisp; there's actually a Structure and Interpretation of Classical Mechanics book out there. ^_^
09:12:24 <Twey> It would need some tweaking
09:12:31 <Twey> drostie: Ha, really?  I wasn't aware of that
09:12:47 <Fuuzetsu> Twey: Much less effort than re-writing the thing;
09:13:02 <Twey> drostie: You might also like type-theoretical physics: http://bentnib.org/conservation-laws.html :þ
09:13:17 <Twey> Fuuzetsu: True that
09:13:30 <Fuuzetsu> Well, I guess what would have to actually be done is patching Cabal rather than Hackage
09:13:43 <Twey> The interesting part would be adapting Hoogle
09:14:01 <Fuuzetsu> that's a funny idea of ‘interesting’
09:14:14 <Fuuzetsu> also that's a separate project anyway
09:14:34 <Twey> Yes, I was originally thinking it would be one project, but that's a bad idea
09:14:48 <drostie> Twey: thanks for that link, bookmarked for later. :D
09:15:22 <drostie> I'll also say that LiveScript syntax is pretty good even though it's basically the exact opposite of Haskell. What I'm always surprised by is how *few* parens I need to write in LiveScript.
09:15:47 <cpa> @pl runConst (traverse (Const . f) ta)
09:15:47 <lambdabot> runConst (traverse (Const . f) ta)
09:15:56 <Twey> drostie: Opposite how?
09:16:04 <cpa> @pl \f ta -> runConst (traverse (Const . f) ta)
09:16:04 <lambdabot> (runConst .) . traverse . (Const .)
09:16:48 <Twey> It looks quite Haskelly to me
09:17:55 <Fuuzetsu> Twey: Post on cabal devel asking if they'd be interesting in hosting Agda packages (and of course patching Cabal a bit to support it although I don't think much work will have to be done there)
09:18:21 <drostie> Twey: `1 + floor random! * 50` parses as (+ 1 (floor (* (random) 50))). So a b c is implicitly a (b c) and not (a b) c as in Haskell, and operators like * are higher-precedence than function application rather than lower.
09:18:29 <Twey> cabal-devel is the list for Hackage?
09:19:02 <Twey> drostie: Huh, weird!
09:19:18 <Twey> Oh, wait, this is what APL does
09:19:25 <Twey> (and J after it)
09:19:48 <Twey> drostie: Does LiveScript have a concept of operator precedence other than that?
09:19:54 <Fuuzetsu> Twey: well, it's basically the same people working on it, I don't think there's a separate Hackage ML. There's #hackage but that's not too active.
09:19:57 <drostie> Yeah, I think Haskell is greedy nom (i.e. left-associative) while APL is lazy nom (i.e. right-associative) in terms of how functions nom args.
09:20:47 <drostie> Twey: the normal JS operator precedence hierarchy, yes. Those operators are from JS and are not polymorphic; see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence .
09:21:55 <Twey> drostie: Ah, right.
09:22:08 <Guest16892> exit
09:22:12 <Guest16892> bye
09:22:27 <Twey> drostie: It's strange that that works well with function currying
09:23:56 <drostie> Twey: commas become used for that because JS has multi-arg functions anyway. So you write add = (a, b) -> a + b for your function literal and can either create a curried function add 3 or the full application add 3, 4.
09:24:27 <drostie> that's the sneakiness. It's not as *clean* as Haskell.
09:24:51 <drostie> Commas are basically where you actually need parens in livescript.
09:25:22 <drostie> times add 4, 5, 3 becomes ambiguous and I think parses as times(add(4, 3, 5)).
09:25:37 <drostie> when you really want times (add 4, 5), 3.
09:25:47 <Twey> Ah, I see
09:27:08 <jophish_> Would someone be able to spend a minute describing how a Haskell98 typechecker differs from a vanilla HM typechecker. I think that I understand how HM works, and I've got a typechecker implementing algorithm W on a (tiny) subset of the Haskell syntax. Perusing the GHC source has given me the impression that a Haskell typechecker is immensely more complex than what I have at the moment. From what I can glean fr
09:27:08 <jophish_> om GHC it seems to create sets of Constraints and then run some fancy typechecker on those. I've not been able to find anything very similar to what I have.
09:28:52 <drostie> jophish_: so in Haskell you have these things like (>>=) :: (Monad m) => m a -> (a -> m b) -> m b. The (Monad m) thing is a type constraint which enables polymorphism in Haskell.
09:29:04 <drostie> I think that's not vanilla HM?
09:29:29 <jophish_> drostie: yeah, that's a good example
09:29:30 <Twey> Yeah, HM doesn't have typeclasses
09:31:03 <drostie> jophish_: in turn you can say things like instance (Monoid m) => Applicative (Const m) where { pure = const mzero; Const a <*> Const b = Const (a `mappend` b) }.
09:32:12 <jophish_> drostie: sure, The thing I'm unsure about if how to get something like algorithm W to handle constraints and classes
09:32:12 <drostie> So that's saying that f = Const a is *only* known to be an Applicative f, if we first know that a is known to be a Monoid.
09:32:14 * hackagebot test-framework-golden 1.1.3.1 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.3.1 (RomanCheplyaka)
09:33:17 <drostie> jophish_: okay, so the simplest way that I know of is to imagine that the part before the fat arrow is a list of libraries which must be passed as arguments to the function.
09:33:37 <jophish_> drostie: sure, I understand how to implement the code generation side of these things
09:33:51 <jophish_> sorry if the question was a little fuzzy
09:33:55 <drostie> Presumably those could then be typechecked by HM?
09:34:28 <drostie> Or, I guess it's a little different, you need to test whether you have a library in the first place to stick in there as that argument.
09:36:24 <laura_h> beginner question: The following defintion data Bool = True | False is more or less standard. But when I code something like data Test4 = True|False then
09:37:00 <laura_h> then I get in a function like test2 10 = True a Warning with
09:37:02 <laura_h> Ambiguous occurrence `True'
09:37:10 <drostie> jophish_: the system is I think called F_\omega ?
09:37:38 <laura_h> Any reason why I cannot define the data Test4?
09:37:40 <drostie> jophish_: not sure how to typecheck in that without just trying to keep track of constraints and unioning the sets of constraints all together.
09:37:45 <laura_h> resp. why this makes a problem?
09:37:55 <k00mi> laura_h: the compiler doesn't know what True you mean, since you now have a True of type Bool and one of type Test4
09:38:20 <k00mi> you can rename your True to True' or something and it'll work
09:39:15 <Feuerbach> dissipate: I've released the fix for test-framework-golden
09:39:22 <laura_h> but why do I need to rename True? I was just thinking about a new data-type?
09:39:45 <drostie> laura_h: so when you write data Test4 = True | False you are saying that there is this type Test4 which has two functions, True and False, which you can use to construct it. It already has a type data Bool = True | False which has two functions, True and False, which construct values of that type. When you say "True" now, the compiler is asking you, "which function named True did you mean? The function from nothing to Bools or the
09:39:45 <drostie>  function from nothing to Test4?"
09:40:15 <k00mi> drostie: those aren't functions
09:40:32 <Twey> laura_h: Because there's already a constructor called ‘True’
09:40:43 <Twey> laura_h: Your name ‘True’ clashes with it
09:41:12 <drostie> laura_h: to get rid of it in a .hs file you might import the Prelude, "hiding True, False" and then it knows which functions you mean.
09:41:21 <laura_h> uhu, I understand now. Cause True is bound to Bool therefore I cannot re-bind it. Right?
09:41:35 <k00mi> jophish_: did you have a look at the original paper on typeclasses?
09:41:57 <jophish_> k00mi: I read it some time ago. It may be time to revisit it
09:42:32 <drostie> laura_h: you could also just wrap the Bool type in another; data Test4 = Test4 Bool, which would give you a 'Test4 True' and 'Test4 False' .
09:43:41 <c_wraith> I'm really dissatisfied with unfoldr.  It's so verbose to use.
09:44:06 <Twey> laura_h: Well, names should be unambiguous in general, not just for type constructors.  You can get around this by putting them in separate modules (so if your module is called Foo, you *can* refer to your new True as Foo.True and the old one as Prelude.True).
09:45:08 <drostie> c_wraith: you can get around it in many cases if you like.
09:45:54 <laura_h> drostie: now I am little bit confused. What is the difference between data Test4=Bool and data Test4=Test4 Bool ???
09:46:11 <laura_h> drostie: Isn't the second some kind of recursive definition?
09:46:35 <drostie> laura_h: okay, so on the right hand side, the grammar is "list of constructors separated by | ".
09:46:48 <FreeFull> :t unfoldr
09:46:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:47:05 <FreeFull> Yeah, it does tend to be verbose
09:47:13 <drostie> laura_h: a constructor is defined as "name (types...)" which are the types of the arguments that the constructor will take as its arguments.
09:47:32 <Twey> It's verbose because it introduces a pair and a Maybe
09:47:33 <laura_h> Twey: When I put them into different modules, then I might separte them. Fine. But I was more or less curious why I cannot construct my own data type with already specified values
09:47:47 <drostie> laura_h: data Test4 = Bool defines a singleton type -- a type which only has one constructor with no arguments.
09:48:02 <Twey> laura_h: You can — but when referring to them you have to give them their fully-qualified names, so the compiler knows which one you mean
09:48:32 <c_wraith> is there a particular name for when you're unfolding over a list?  That is, in the type of unfoldr, b is a list of something or other?
09:48:57 <c_wraith> And especially when that list decreases in size by one every time?
09:49:11 <drostie> c_wraith: b is the state variable.
09:49:22 <c_wraith> drostie: do you have any idea what I'm asking about?
09:49:45 <Twey> c_wraith: A map?  :þ
09:49:48 <drostie> oh, I see.
09:50:09 <c_wraith> Twey: no, it's not a map, because it looks at more than just the current element of the list
09:50:19 <c_wraith> Twey: it just happens to pass the tail each time
09:50:30 <Twey> Oh, right
09:50:33 <Twey> Hmm
09:50:42 <drostie> you are using unfoldr to do [b] -> Maybe (a, [b]) -> [b] -> [a]...
09:50:49 <c_wraith> yep
09:51:14 <Twey> It's a pretty pattern.  I don't know if it has a name.
09:52:12 <c_wraith> http://lpaste.net/99699 is what I'm doing.  I got curious about using proper composition of lazy pieces to solve that problem
09:52:47 <c_wraith> (traverse the list twice, and you lose laziness - that's why I ended up using unfoldr)
09:52:59 <drostie> tail_unfold :: ([b] -> a) -> [b] -> [a]; tail_unfold f = unfoldr \bs -> case bs of [] -> Nothing; x:xs -> Just (f bs, xs) would simplify the case?
09:53:23 <c_wraith> Yeah, it would simplify it.  I was just wondering if it had a name in literature already
09:53:38 <drostie> You could try to hoogle that type?
09:54:51 <FreeFull> drostie: That type reminds me of extend
09:55:00 <c_wraith> comonadic extend?
09:55:03 <FreeFull> Except lists don't have a Comonad instance
09:55:04 <FreeFull> Yeah
09:55:04 <c_wraith> Huh.  It is related
09:56:25 <c_wraith> If lists did have a Comonad instance, it wouldn't do the same thing, I don't think.
09:56:51 <c_wraith> Well, nonempty lists do have Comonad instances.  I suppose it's possible to check.
09:57:00 <c_wraith> In my particular case, the list is guaranteed to be nonempty!
09:57:45 <FreeFull> I forget what you have to import for non-empty lists
09:58:25 <c_wraith> Me too
09:59:10 <c_wraith> Oh, interesting.  That tail_unfold also guarantees it'll never call its first argument with an empty list.
09:59:25 <c_wraith> which makes it look even *more* like a comonad
09:59:51 <FreeFull> Data.List.NonEmpty it seems
10:00:31 <FreeFull> http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html
10:00:45 <jmcarthur> c_wraith: i think i would call unfolding where the seed is a list a "fold" in haskell ;)
10:01:53 <jmcarthur> i wouldn't call it that in all languages, since some might distinguish between data and codata or something.
10:01:56 <c_wraith> jmcarthur: Is there morphism-related term for it, though?  (Remember when this channel used to be all about *morphisms?)
10:01:59 <Twey> jmcarthur: Except that the unfold gives you access to the remainder of the original list, whereas a fold gives you access to the *transformed* remainder
10:02:22 <edwardk_> FreeFull: while lists aren't a full comonad, they do form a semicomonad, so there is an Extend instance for them
10:02:32 <jmcarthur> Twey: a paramorphism then?
10:02:46 <jmcarthur> c_wraith: ^^
10:02:50 <Twey> Could be
10:03:16 <c_wraith> edwardk_: does that Extend instance do what I'm looking for?  ie, pass only the tail at each point?
10:03:32 <edwardk_> :t extended
10:03:33 <lambdabot> Not in scope: `extended'
10:03:35 <c_wraith> edwardk_: also, should I interpret this as meaning you have an alert on the word "comonad"? :)
10:03:41 <edwardk_> @let import Data.Functor.Extend
10:03:41 <Twey> Heh.
10:03:42 <lambdabot>  <no location info>:
10:03:42 <lambdabot>      The package (comonad-4.0) is required to be trusted but it isn't!
10:03:47 <edwardk_> shucks
10:03:49 <edwardk_> anyways, yes
10:03:54 <edwardk_> and yes
10:04:18 <FreeFull> Huh, I wouldn't have expected comonad to be untrusted
10:04:25 <FreeFull> I guess that's something to fix
10:04:28 <edwardk_> it gets the tail from there on in the list. its 'tails' sans the extra []
10:04:51 <c_wraith> so I wasn't wrong.  There *is* a saner thing than unfoldr for my specific use case.
10:04:53 <FreeFull> There is an Extend instance for []
10:05:15 <edwardk_> > (init . tails) [1..3]
10:05:17 <lambdabot>  [[1,2,3],[2,3],[3]]
10:05:33 <FreeFull> That's the same as extended id [1..3]
10:05:34 <edwardk_> is basically what the comonad does
10:05:42 <edwardk_> er semicomonad
10:05:44 <edwardk_> yea
10:06:05 <c_wraith> ok, what package do you have semicomonads in?
10:06:25 <edwardk_> one of these days i'll rename Bind to Semimonad, Apply to Semiapplicative, Extend to Semicomonad,
10:06:30 <zrho> semicomonads?
10:06:32 <edwardk_> c_wraith: semigroupoids, obviously =)
10:06:37 <c_wraith> oh, of course.
10:06:50 <zrho> Comonads without extract?
10:06:54 <c_wraith> yep
10:06:54 <edwardk_> zrho: extend, but not extract, yeah
10:07:19 <zrho> Are there any other useful applications besides lists?
10:07:33 <Rylee> sometimes, when I look in this channel, I can't tell if you're talking about math concepts that are above my head or performing evil demon summoning chants.
10:08:07 <drostie> It's demon-summoning. After all, edwardk_ showed up right when Twey incanted, "comonad, comonad, comonad."
10:08:11 <zrho> Rylee: Most of the time, the latter.
10:08:48 <FreeFull> Extend has Maybe and Either instances too
10:08:48 <drostie> or, sorry, FreeFull.
10:08:52 <c_wraith> so..  edwardk_ *is* the demon.  That clears everything up.
10:09:51 <edwardk_> drostie: Alas, becoming an atheist took all the joy out of collecting mens' souls.
10:10:22 <zrho> Hm, is there a point in using matroids for optimization problems? Are there problems for which some matroid algorithm is optimal or at least feasible?
10:10:29 <drostie> You can still collect them, though. You just need a lens into the appropriate data structure.
10:12:28 <jmcarthur> c_wraith: expressed as a fold something like:   foldr (\x xs -> (if null xs then x == 0 else x >= 0) : xs) []
10:13:02 <zrho> edwardk_: are there some open problems/interesting questions open rg. lenses or other interesting algebraic structures in Haskell you know of, which one could investigate in a bacchelor's thesis?
10:13:03 <drostie> edwardk_: I finally understood what all of the Const stuff was going on in your YouTube talk as of yesterday at a barbecue joint, so I'm kidding you with love. :D
10:13:04 <jmcarthur> still not so pretty though
10:13:48 <c_wraith> jmcarthur: oh, right.  That would work.
10:14:30 <zrho> drostie: It was kind of an enlightening moment for me, too, when I finally got van Laarhoven lenses, if you are referring to Gettings.
10:14:47 <zrho> I literally jumped out of my chair in an intense moment of joy.
10:14:57 <drostie> zrho: implement Eric Demaine's functional tries in Haskell with lenses, then tell me about it and I will use your thesis work. :D
10:15:39 <drostie> The idea is kind of simple and straightforward and yet whenever I sit down to write it out in Haskell, I kind of just stare at the cursor and have no idea where to start.
10:15:53 <drostie> It blinks at me, mockingly.
10:16:39 <zrho> For me, the turning point was, when I saw _1 f (a, b) = (, b) <$> f a
10:17:18 <zrho> That fits the intuition of splitting the value in a constructor with a hole and the lensed value.
10:17:51 <edwardk_> drostie: i have a bunch of demaine's structures lying arond here
10:18:36 <edwardk_> zrho: hrmm. i have some hard open problems there, but they are just that hard open problems. trying to find something at the right level for  a B.S. thesis
10:22:24 <Forgetaboutit> hey guys :). Is there a way in Aeson to flatten a list of Value instances (of the same type) into a single array Value?
10:23:07 <c_wraith> edwardk_: Do you have a Comonad instance for Data.List.NonEmpty.NonEmpty somewhere?
10:23:32 <Twey> Forgetaboutit: Array . Vector.fromList ?
10:23:35 <edwardk_> c_wraith: it should just be there if you have both in scope
10:24:04 <c_wraith> edwardk_: oh.  I'm looking at haddocks, neither of which list it, but it's possible that's just due to how they're generated
10:24:05 <edwardk_> c_wraith: it is in Control.Comonad directly ;)
10:24:37 <Forgetaboutit> Twey: Thank you, kind Sir! Exactly what I've been looking for :)
10:25:11 <kristof> bitemyapp: Haskell is beautiful
10:25:19 <kristof> bitemyapp: I'm suffering from a bad case of awe right now
10:25:27 <Twey> Forgetaboutit: If you look at http://hackage.haskell.org/package/aeson-0.7.0.1/docs/Data-Aeson-Types.html#t:Array you can see that Array just wraps a Data.Vector.Vector
10:25:34 <djahandarie> edwardk_, I'd be interested in your "bunch of demaine's structures lyring around" :P
10:25:43 <djahandarie> I've been going through an implementing some of them recently
10:25:49 <kristof> bitemyapp: but it's not really haskell that's beautiful, it's the kind of structured programming that's possible in Haskell that's beautiful and so by extension that makes Haskell as beautiful as the theory it supports
10:25:54 <Twey> Forgetaboutit: And Vectors are created with Data.Vector.fromList
10:26:15 <Forgetaboutit> Twey: I was aware of that.  However, I didn't know I can simply convert it like that.
10:26:43 <Twey> Forgetaboutit: If you have a constructor ‘Foo Bar’ for a type Baz, then Foo is a function that takes a Bar and produces a Baz
10:26:46 <Forgetaboutit> Twey: Haskell always makes sense if explained and none otherwise :D
10:26:54 <kristof> bitemyapp: I'm just sitting here trying to recuperate from reading a couple of posts on Gabriel Gonzalez's blog which made me realize just how awesome category theory is
10:26:55 <Twey> Hehe
10:27:19 <edwardk_> djahandarie: when i get more free time i'll see what i can bundle up
10:27:24 <zrho> kristof: true. it is possible to write immensely beautiful software in Haskell, yet that is just the upper bound which is higher than in other languages. I have seen some really disturbing code in Haskell, too.
10:27:25 <kristof> bitemyapp: Specifically, restructuring my understanding of functors as mappings from one category to another. ._.
10:27:45 <FreeFull> zrho: What was the most disturbing code you saw?
10:27:45 <Twey> kristof: What posts?
10:28:39 <drostie> edwardk_: I'd even look forward to github.com/ekmett/demaine :D
10:28:52 <FreeFull> > fmap each const [1,2,3] ['a','b']
10:28:55 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
10:29:02 <djahandarie> edwardk_, awesome. I haven't completed any of my implementations to the point I'd want to release any of them myself
10:29:04 <kristof> Twey: I've read quite a few posts from his blog that made me appreciate category theory but it was these two that amazed me this morning: http://www.haskellforall.com/2012/08/the-category-design-pattern.html
10:29:08 <edwardk_> drostie: well, i mostly care about things on the succinct side, and none of what i have is exactly textbook =)
10:29:13 <zrho> FreeFull: Some of the code produced by fellow students in a 4 man Haskell battleships implementation. unsafePerformIO instead of liftIO all over the place.
10:29:19 <kristof> Twey: and http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
10:29:39 <kristof> Twey: I think this is what I was talking about the other day when I said that there should be a large TOME dedicated to important "design patterns" found in functional programming languages
10:30:15 <kristof> Twey: The real icing on the cake was this one-two punch from both posts: 1) structure your program using categories so that 2) you can use functors to have arbitrary compatibility and code reuse between your components
10:31:35 <kristof> Twey: And people have been trying to tell this to me for a while, but I kept thinking of map as map :: (a -> b) -> [a] -> [b] when REALLY I should have added some more parens to get map :: (a -> b) -> ([a] -> [b])
10:32:02 <zrho> In fact Haskell gets code reuse right. I wasn't able to reuse nearly as many libraries in any other language than Haskell.
10:32:57 <pjdelport> kristof: or better, fmap :: Functor f => (a -> b) -> (f a -> f b)
10:33:16 <kristof> pjdelport: Well, everyone knows that
10:34:30 <haasn> zrho: yeah, you just write one lens and you get everything for free
10:34:48 <edwardk_> zrho: that is pretty much why i write haskell
10:35:31 <haasn> over (setting map) is faster than map
10:35:39 <edwardk_> zrho: i worked in other languages for a long time before haskell, but it is here that i've finally started to be able to accrete critical mass. before libraries would just bitrot away or not be applicable to the next problem, etc.
10:35:41 <haasn> (probably not actually. but I haven't tested.)
10:35:47 <edwardk_> haasn: =)
10:35:53 <edwardk_> haasn: only for Data.Text ;)
10:36:17 <edwardk_> alas over (setting (over (setting map))) doesn't speed up again
10:36:58 <Twey> kristof: Nice!  I should learn Pipes.
10:37:03 <Forgetaboutit> edwardk_: but that would be lisp ;)
10:38:11 <drostie> kristof: yeah, thinking of fmap as (a->b) -> (f a -> f b) gives you a bit of a leg up when you get to Applicative; where f(a->b) -> (f a -> f b) does a similar thing.
10:38:38 <haasn> (a -> m b) -> (m a -> m b)
10:38:47 <haasn> is (=<<)
10:38:51 <drostie> yeah, monads too.
10:40:08 <Twey> drostie: That's actually just Functor
10:40:13 <Twey> :t fmap
10:40:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:40:28 <dwcook> Twey, there was an f in front
10:40:39 <Twey> Oh, so there was; beg pardon
10:40:43 <drostie> heh.
10:40:53 <Twey> I blame your formatting ;)
10:40:59 <haasn> I still prefer to think of Applicative as f a -> f b -> f (a, b)
10:41:21 <c_wraith> edwardk_: have you checked the docs for Data.Functor.Extend recently? They've got some extend/extended typos, and a reference to a (->-) function that is..  well, not defined there.  (I don't know where it's defined.)
10:41:22 <Twey> haasn: Why?
10:41:42 <edwardk_> c_wraith: patch!
10:41:58 <c_wraith> edwardk_: tell me where (->-) is defined, and I'll consider it. :P
10:42:04 <edwardk_> c_wraith: the docs definitely bitrotted after Extend was refactored
10:42:08 <edwardk_> its not
10:42:22 <c_wraith> Oh.  Does that mean "just remove that part"?
10:42:28 <edwardk_> it was originally in there and moved t Control.Comonad i think when comonad shed the extend dependency
10:42:40 <edwardk_> to become more like Monad and ease adoption
10:43:06 <haasn> Twey: it just seems conceptually simpler to me, a way to “merge together” effects associatively, with pure as the identity (all up to iso)
10:43:12 <kristof> Twey: Am I late to the game for thinking of functors as transformations between categories? I mean I always knew that, I just never put that in an actual computational context.
10:43:15 <haasn> there's none of the notion of “applying” a function
10:43:16 <roboguy_> does ghc 7.8 do profiling differently? I get a cryptic error when I try to build with -prof
10:43:25 <haasn> which seems a bit orthogonal and needlessly complicating
10:45:03 <dwcook> haasn, it's probably less convenient that way though – you probably want to apply a function to those values anyway
10:46:39 <dwcook> And if you really did want the pair then you can do liftA2 (,)
10:46:51 <haasn> dwcook: it's certainly less practical in that you have to go through tuples and fmap app every time. I'm not suggesting a redefinition of the class, at all
10:47:10 <haasn> I'm simply explaining how I conceptually imagine and reason about Applicative instances
10:47:14 <merijn> Is there a way to get cabal sandboxes to use the global packages for everything but 1 or 2 libraries?
10:47:22 <haasn> eg. to answer “can this type be made Applicative?”
10:47:30 <dwcook> Okay, makes sense.
10:47:45 <haasn> And I think it might have some pedagogical value to explain applicative that way, too
10:48:25 <dwcook> Well the orthogonality with fmap is indeed nice
10:48:26 <kristof> edwardk_: What's the most interesting thing you've ever done with comonads?
10:48:29 <Twey> kristof: That's what a functor is :þ
10:48:37 <haasn> come to think of it, it's all monoids; Applicative is a “sideways” monoid (f a -> f b -> f (a,b) which is associative and has an identity), and Monad is a “vertical” monoid (m (m a) -> m a which is associative and has an identity)
10:48:37 <kristof> Twey: shhhh
10:48:59 <Twey> kristof: The Functor typeclass is named for the structure-preserving category mapping
10:49:02 <edwardk_> kristof: lens
10:49:09 <kristof> edwardk_: :o
10:49:31 <dwcook> though Haskell's Functor is more appropriately called Endofunctor
10:49:43 <dwcook> Nobody wants to write that every time though :P
10:49:44 <merijn> @where reversedeps
10:49:44 <lambdabot> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html http://packdeps.haskellers.com/reverse
10:50:09 <c_wraith> edwardk_: pull request sent
10:50:10 <edwardk_> kristof: flip the type signature for lens and it is an indexed comonad coalgebra
10:50:14 <edwardk_> c_wraith: thanks!
10:50:58 <merijn> No sandbox experts? :(
10:51:19 <dwcook> That always reminds me of this https://twitter.com/PLT_Borat/status/228009057670291456
10:52:09 <AlainODea> merijn: you want source deps for a couple of exceptional cases, but not for everything?
10:52:59 <merijn> AlainODea: I have pandoc + dependencies installed, I want to make some changes in one of the pandoc dependencies and then test pandoc.
10:53:11 <merijn> AlainODea: Reinstalling all the untouched pandoc dependencies seems a waste of CPU time
10:53:27 <Fuuzetsu> merijn: Can't you just add-source for the 1 or 2 packages and the rest is global?
10:53:38 <merijn> Fuuzetsu: I dunno, hence my question :)
10:53:50 <Fuuzetsu> try and see
10:53:51 <AlainODea> merijn: AFAICT it uses global packages if the sandbox doesn't have then installed.  You can add-source for a specific package.
10:54:18 <levi> I think that it only pulls in dependencies to the sandbox if they aren't in the global packages, though add-source probably overrides that.
10:54:18 <Fuuzetsu> I have some sandboxes with like 10 other sandboxes linked to them, it's a mess ;/
10:54:27 <Fuuzetsu> better than ending up in cabal hell though
10:54:34 <Twey> dwcook: I love how those slides seem to imply that the main motivation for Lens is to avoid code that looks like a >
10:54:41 <merijn> Let's see
10:54:58 <AlainODea> merijn: https://gist.github.com/AlainODea/7852276
10:55:20 <levi> I used the mechanism to try to get a gtk app working at one point, and it seemed to be behaving as I described.
10:55:25 <sigma914> Hi, I want to compile a 32bit .so with 64bit ghc 7.6.3, I've been googling around and found references to 7.8 having good cross-compile support, but can't find anything about 7.6.3
10:55:43 <sigma914> does anyone have any links related to cross compiling?
10:55:55 <AlainODea> merijn: it seems to work pretty well. It appears to find matching deps on source, then sandbox source, then sandbox install, then global
10:56:39 <jmcarthur> haasn: i like the uncurried version of that even more.   (f a, f b) -> f (a, b)
10:56:51 <levi> sigma914: Your best bet is probably to use a virtual environment (chroot, etc.) to use a 32 bit ghc. Cross compiling might work, but the virtual environment is almost certainly going to be easier.
10:57:51 <levi> I beleive hsenv is designed to do that kind of thing.
10:58:08 <sigma914> levi: cool, thanks
10:58:16 <dwcook> Twey, well, having code that does not look like a giant > does make it easier to reason about :P
10:58:44 <Twey> Hehe, true
11:01:02 <dwcook> "Semigroup" is a confusing name, since it seems to imply it weakens group in only one way
11:01:55 <dwcook> To me having "group" in the name implies the existence of inverses, but maybe there are others that don't fit that pattern
11:02:29 <levi> It's probably best to not assume anything about something based on its name when the name comes from abstract algebra.
11:02:29 * hackagebot hsimport 0.2.9 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.9 (DanielTrstenjak)
11:02:50 <bennofs> If you don't have mempty, inverses don't make sense. Aren't inverses defined as a <> a^-1 == mempty? So what would you translate that to for Semigroup?
11:03:05 <dwcook> bennofs, good point
11:03:26 <dwcook> Instead of saying it's confusing, I should have said "it confused me"
11:04:00 <dwcook> This came up because I was surprised that a semigroupoid with identities is a category, when I thought it would be stronger
11:04:09 <roboguy_> is there a type constructor that lifts a type Monoid to a Group, similar to how Maybe lifts a Semigroup to a Monoid?
11:05:41 <levi> I don't think there's one in common use, but there's likely to be something lying about in some of the more algebraically-inspired packages.
11:06:31 <dwcook> So basically, you'd need to append inverses for all elements except the identity?
11:06:42 <bennofs> I can't even imagine how you implement something like that
11:06:46 <dwcook> s/append/add in/
11:07:16 <dwcook> I can't imagine how you'd do that in Haskell starting from a monoid, but a semigroup maybe
11:07:42 <dwcook> I might be going at this all wrong though
11:07:52 <levi> With an inverse operator?
11:08:05 <roboguy_> hmm, would Either a a work?
11:08:08 <zrho> You could construct the free group and add some evaluator function
11:08:30 <roboguy_> well, Eq a => Either a a I mean
11:08:42 <dwcook> roboguy_, you're missing an identity
11:09:00 <fragamus_> haskell installler just said "this will take 1.21 GB "  I was reminded of the ONE POINT TWENTY ONE GIGAWATTS" line in back to the future
11:09:07 <zrho> and what is Left x * Right y ?
11:09:09 <dwcook> I think you'd need Maybe (Either a a)
11:09:40 <dwcook> And yeah, the hard part is actually defining the operator
11:09:51 <kristof> fragamus_: GIGAwatts?!?!?!?!
11:10:05 <zrho> data Val a = V a | I a
11:10:18 <zrho> type FreeGroup = [Val a]
11:10:32 <zrho> then some function eval :: Monoid m => FreeGroup m -> m
11:10:49 <zrho> You need Eq m, too
11:11:00 <zrho> to reduce [V x, I x] to [mempty
11:11:19 <dwcook> Yeah, ick.
11:11:31 <kristof> fragamus_: Did you know that "Jiga-" is the correct pronunciation? Soft g.
11:11:38 <bmulder> @type map
11:11:39 <lambdabot> (a -> b) -> [a] -> [b]
11:11:40 <dwcook> That seems questionably useful to me.
11:11:41 <kristof> ...Just found that out in the youtube comments of that scene
11:11:46 <fragamus_> JIGAWATTS?
11:12:17 <simpson> kristof: Either is allowed; it's one of those Greek-to-Latin-to-English things where there's two valid ways to interpret the sound.
11:12:36 <dwcook> The correct pronunciation is what speakers of the language accept
11:12:54 <kristof> dwcook: blasphemous.
11:13:00 <kristof> simpson: If you say so!
11:13:10 <zrho> One interesting property would be, that you get a correct monoid instance for FreeGroup m defined like that for free.
11:13:58 <dwcook> Hmm, you only need to eliminate adjacent pairs, right?
11:14:06 <zrho> Yes
11:14:16 <dwcook> But if you had commutativity as well then you'd need to check the whole list
11:14:17 <zrho> and the pairs that become adjacent then etc.
11:14:50 <zrho> Yes; FreeGroup is the free non-commutative group, regardless whether m is a commutative monoid or not
11:15:12 <dwcook> Yeah, just making an observation. It seemed odd to me that strengthening something made it harder to compute.
11:15:13 <fragamus_> there would be no controversy if the haskell platform were under a jigabyte
11:15:25 <fragamus_> or over a terrabyte
11:15:25 <kristof> lol
11:15:26 <zrho> Map m Int would be the free abelian group, basically a free Z-module.
11:15:34 <dwcook> Or no, I'm thinking about this wrong again
11:15:55 <kristof> zrho: the free abelian group is useful for something, but I can't remember what
11:16:41 <dwcook> @google free abelian group
11:16:43 <lambdabot> http://en.wikipedia.org/wiki/Free_abelian_group
11:16:43 <lambdabot> Title: Free abelian group - Wikipedia, the free encyclopedia
11:16:48 <kristof> zrho: errrr specifically the free abelian group with basis one, I saw it used in the solution of a problem but I can't remember what
11:17:31 * hackagebot data-checked 0.3 - Type-indexed runtime-checked properties  http://hackage.haskell.org/package/data-checked-0.3 (MikhailVorozhtsov)
11:18:10 <zrho> Here it is used for linear functions in a set of variables: http://hackage.haskell.org/package/glpk-hs-0.3.4/docs/Data-Algebra.html#t:LinFunc
11:26:00 <zq> :t elements
11:26:01 <lambdabot>     Ambiguous occurrence `elements'
11:26:01 <lambdabot>     It could refer to either `Lens.elements',
11:26:01 <lambdabot>                              imported from `Control.Lens' at /home/lambda/.lambdabot/State/L.hs:42:1-43
11:26:26 <haasn> jmcarthur: that one is also nice, yes :) reminds me of strong functor
11:26:45 <haasn> huh, apparently jmcarthur is a strong lax monoidal functor
11:26:51 <haasn> suddenly it's all clicking into place
11:26:58 <haasn> err, not jmcarthur. Applicative :)
11:27:14 <haasn> I don't know if jmcarthur is strong, lax or both, unfortunately
11:27:24 <FreeFull> lambdabot: Either Lens.elements or what?
11:27:26 <dmwit> ski: I'm not sure how your example contradicts my claimed "seq" promise, and also I'm pretty sure seq promises more than "eventually".
11:27:47 <someguy23> 1
11:27:48 <dmwit> ski: Like it would not be living up to the promise if "foo `seq` bar" returned the WHNF for bar and then evaluated "foo" ten years from now.
11:28:01 <FreeFull> Seriously, lambdabot, either Lens.elements or what?
11:28:29 <haasn> @more
11:28:33 <haasn> ah
11:28:39 <haasn> FreeFull: do the same in a /msg lambdabot
11:29:40 <monochrom> wow, people really talk to computers
11:31:11 <FreeFull> haasn: I did
11:31:14 <FreeFull> It didn't give me anything more
11:31:14 <dwcook> monochrom, it's called programming :)
11:31:42 <monochrom> I guess so!
11:32:13 <roboguy_> haasn: I've heard all haskell functors are strong, but I don't really know what that means
11:33:07 <haasn> roboguy_: it essentially means you get :: (a, f b) -> f (a, b)
11:33:13 <monochrom> did you know of the scene in movie Star Trek V where Scotty talked to the Mac Classic mouse? :)
11:33:48 <haasn> roboguy_: as we can see this is free in Hask via \(a, f) -> fmap (a,) f
11:34:02 <joelteon> @pl \(a,f) -> fmap (a,) f
11:34:02 <lambdabot> (line 1, column 18):
11:34:02 <lambdabot> unexpected ","
11:34:02 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
11:34:07 <joelteon> @pl \(a,f) -> fmap ((,) a) f
11:34:07 <lambdabot> uncurry (fmap . (,))
11:34:29 <dwcook> Is there another term for "strong functor"? nlab comes up with nothing obviously relevant
11:34:55 <roboguy_> haasn: I did know that (a, f b) -> f (a, b) somehow related to functor strength but I didn't know if it generalizes more than that
11:35:07 <haasn> roboguy_: http://nlab.mathforge.org/nlab/show/tensorial+strength
11:35:26 <haasn> roboguy_: https://en.wikipedia.org/wiki/Strong_monad
11:35:42 <magneticduck> looking into GPipe... I've already been playing around with GLUT / openGL, but I'm a bit lost in the "graphics pipeline"
11:35:50 <magneticduck> how... do you use GPipe with GLUT?
11:35:59 <magneticduck> openended question alert
11:36:36 <Earnestea> magneticduck: (It might be helpful if you show the channel what you've tried so far)
11:36:38 <magneticduck> oh, GPipe-examples
11:37:15 <magneticduck> k
11:38:16 <haasn> err, that was aimed at dwcook
11:38:16 <magneticduck> https://github.com/MagneticDuck/PixelGame/tree/master/src/PixelGame/Graphics
11:38:19 <magneticduck> I haven't done much at all
11:38:21 <dwcook> haasn, cool
11:38:50 <haasn> roboguy_: I'm not sure; costrength is (f a, b) -> f (a, b) right? it seems like a mixture of both
11:39:28 <dwcook> Wouldn't costrength just be the transformation going in the other direction?
11:39:37 <dwcook> Or is this another case of naming being untrustworthy?
11:40:38 <roboguy_> hmm, is there an easy way to have an unboxed 2D Vector? or would I need an unboxed Array for something like that?
11:40:41 <magneticduck> can I use GPipe to write to the.. framebuffer or something, from inside, say, a GLUT callback?
11:40:47 <magneticduck> I'm really not seeing the light
11:42:12 <magneticduck> is drawing-combinators... fast enough for a 2d game?
11:42:28 <magneticduck> is that the kind of thing it's aimed at?
11:48:10 <obiwahn> lambdabot> let time x = 12+(1/60)*(x+11) in map time [30,45]
11:48:12 <obiwahn>  Parse failed: Parse error: in
11:48:20 <obiwahn> > let time x = 12+(1/60)*(x+11) in map time [30,45]
11:48:22 <lambdabot>  [12.683333333333334,12.933333333333334]
11:48:31 <obiwahn> what is wrong with my lambdabot?
11:48:52 <d3lxa> does anyone knows something of the form: Maybe (m a) -> m (Maybe a), please? would be really useful in my case thx
11:49:06 <notdan> d3lxa: maybe traverse?
11:49:09 <notdan> :t traverse
11:49:10 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:49:14 <notdan> :t fold
11:49:15 <lambdabot> (Foldable t, Monoid m) => t m -> m
11:49:19 <Taneb> :t sequence
11:49:20 <lambdabot> Monad m => [m a] -> m [a]
11:49:25 <notdan> hm
11:49:27 <Taneb> :t Data.Foldable.sequence
11:49:28 <lambdabot> Not in scope: `Data.Foldable.sequence'
11:49:31 <haasn> :t Data.Traversable.sequence
11:49:32 <roboguy_> :t sequenceA
11:49:32 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:49:33 <lambdabot>     Not in scope: `sequenceA'
11:49:33 <lambdabot>     Perhaps you meant one of these:
11:49:33 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
11:49:38 <haasn> There we go :)
11:49:50 <notdan> yeah, that one :)
11:49:58 <haasn> :t T.sequenceA -- more general
11:49:58 <d3lxa> oh, again sequenceA :) used it once and here to stay :)
11:50:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
11:50:01 <simpson> :t maybe (return ()) (\ma -> fmap Just)
11:50:02 <lambdabot>     Couldn't match type `f0 (Maybe a0)' with `()'
11:50:02 <lambdabot>     Expected type: f0 a0 -> ()
11:50:02 <lambdabot>       Actual type: f0 a0 -> f0 (Maybe a0)
11:50:26 <haasn> simpson: drop the lambda :)
11:51:43 <d3lxa> cool, I think it improves my code, http://sprunge.us/ZTJj what do you think? any better way?
11:53:41 <simpson> haasn: Yeah, I wasn't thinking.
11:54:34 <d3lxa> notdan, haasn: thank you :)
11:54:37 <haasn> :t sequenceOf _Just
11:54:38 <lambdabot> Monad m => Maybe (m b) -> m (Maybe b)
11:54:44 <haasn> -- lens improves everything
11:55:02 <obiwahn> mh
11:55:05 <d3lxa> :i _Just
11:55:45 <d3lxa> I kind of magical Lens definition for Maybe?
11:55:47 <obiwahn> any haskell lambdabot guru here like the "james c." guy?
11:56:02 <x77686d> Is it proper to say that 'take5 = take 5" is a point-free function declaration?
11:56:04 <edwardk_> aka 'sequence'
11:56:07 <edwardk_> :t _Just id
11:56:08 <lambdabot> Applicative f => Maybe (f b) -> f (Maybe b)
11:56:42 <d3lxa> x77686d: it's just a partical function application, no?
11:56:48 <d3lxa> s/partical/partial
11:58:00 <enthropy> x77686d: sounds ok
11:58:32 <enthropy> might help to also say, it can be expanded to  take5 x = take 5 x
11:58:58 <enthropy> http://www.haskell.org/haskellwiki/Eta_conversion
11:59:20 <roboguy_> d3lxa: _Just is a prism for the Just values of a Maybe (I think)
11:59:22 <x77686d> I'm writing some slides on point-free style, which I'd used for years in ML without knowing it had a name! :)
11:59:38 <roboguy_> d3lxa: it's just a normal function name, it just happens to look like "Just"
12:00:55 <roboguy_> > (_Just .~ 5) (Just 1)
12:00:57 <lambdabot>  Just 5
12:01:02 <roboguy_> > (_Just .~ 5) Nothing
12:01:04 <lambdabot>  Nothing
12:03:42 <L8D> roboguy_: why do people use lens?
12:04:03 <roboguy_> L8D: lots of nice data structure manipulation for one
12:04:04 <simpson> L8D: Because, once you start thinking in terms of lenses, life gets easier.
12:04:06 <L8D> It's a bunch of bloat that you don't need if you do pattern matching properly
12:04:28 <simpson> :t zoom
12:04:30 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
12:04:34 <L8D> It needs to be a lot simpler
12:04:49 <L8D> less junk in the global namespace
12:04:50 <simpson> L8D: ^^^ zoom doesn't have much to do with pattern matching.
12:04:53 <roboguy_> L8D: the core of it isn't that complicated, it just has a lot of extra helper stuff
12:05:04 <roboguy_> also, pattern matching isn't really a replacement
12:05:16 <L8D> roboguy_: well that extra helper stuff should go in another module
12:06:47 <tomejaguar> L8D: Lens has lots of different modules.  Just import what you need.
12:06:54 <simpson> L8D: It *is* in other modules. If you don't want everything, you can import piecemeal.
12:07:06 <L8D> Isn't _2 in Data.Lens ?
12:07:08 <simpson> Importing Control.Lens gives you everything precisely because most of it's useful.
12:07:26 <edwardk_> L8D: i use lens because it provides two separate vocabularies. one for describing what to do, and one for describing what to do it to, that happens to be more compositional. YMMV and you are welcome to your opinion, but please forgive me if I don't leap to sharing it. ;)
12:07:57 <roboguy_> L8D: I don't think that's in Data.Lens
12:08:20 <roboguy_> well, it probably is but not under that name
12:08:47 <tomejaguar> edwardk_: I can see how lenses describe "what to it to", but how do they describe "what to do"?
12:08:51 <L8D> roboguy_: Control.Lens, whatever
12:08:57 <edwardk_> Data.Lens used to use fstLens sndLens naming
12:09:23 <roboguy_> L8D: no, it's in Control.Lens.Tuple
12:09:41 <edwardk_> tomejaguar: the lenses/traversals/etc are the 'what to do it to' the combinators are what to do to it. mapMOf_   sumOf     %~     +=  etc.
12:09:51 <tomejaguar> Ah right.
12:09:54 <L8D> roboguy_: Really? Because when I import Control.Lens, I have _2 in the namespace for some reason.
12:10:09 <edwardk_> L8D: Control.Lens re-exports most of Control.Lens.*
12:10:13 <roboguy_> L8D: Control.Lens doesn't actually have anything. it just reexports a bunch of the submodules
12:10:22 <tomejaguar> They're sort of delenses.
12:10:22 <L8D> -.-
12:10:23 <roboguy_> http://hackage.haskell.org/package/lens-4.0.2/docs/Control-Lens.html
12:10:33 <roboguy_> L8D: but that's why you can import what you need as needed
12:10:44 <roboguy_> because it's not all just thrown into Control.Lens
12:12:34 <L8D> @pl \(a, b) f -> (a, f b)
12:12:34 <lambdabot> uncurry ((. flip id) . (.) . (,))
12:12:44 <tomejaguar> I think there's a good case for 'My.Package.Name' not to be the default point for re-exporting everything, but really it's not a big deal.
12:12:52 <roboguy_> L8D: flip fmap
12:13:05 <L8D> @pl flip fmap
12:13:05 <lambdabot> flip fmap
12:13:31 <L8D> @pl \(a, b) f -> (f a, b)
12:13:31 <lambdabot> uncurry (flip . ((,) .) . flip id)
12:13:45 <milfjord> :t flip first
12:13:46 <lambdabot> (b, d) -> (b -> c) -> (c, d)
12:14:08 <roboguy_> > flip fmap (1, 2) (*10)
12:14:11 <lambdabot>  (1,20)
12:14:16 <roboguy_> the trick is mapping over the first element
12:14:40 <roboguy_> which is (one of the many places) that lens comes in
12:14:47 <L8D> @src flip
12:14:47 <lambdabot> flip f x y = f y x
12:14:50 <L8D> @src first
12:14:50 <lambdabot> Source not found. My brain just exploded
12:14:55 <L8D> @src first
12:14:55 <lambdabot> Source not found. Whoa.
12:15:14 <L8D> :t first
12:15:14 <roboguy_> @src (->) first
12:15:14 <lambdabot> first f = f *** id
12:15:14 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:17:13 <roboguy_> that is another possibility, but you can extend this concept to any arbitrary field of any data structure, which is where lens really starts to become useful
12:17:26 <FreeFull> :t first
12:17:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:17:29 <FreeFull> :t second
12:17:30 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
12:17:42 <roboguy_> > first (*10) (1,2)
12:17:44 <lambdabot>  (10,2)
12:19:20 <roboguy_> > over _3 (*10) (1,2,3)
12:19:22 <lambdabot>  (1,2,30)
12:19:40 <FreeFull> Lenses are more flexible
12:19:51 <navaati> hi
12:20:06 <Hafydd> (f, s), (fs, sn), (fst, snd), (frst, scnd), (first, secnd), (______, second)
12:20:16 <FreeFull> > fromJust $ (.) _2 const (Just 3) (9,9)
12:20:18 <lambdabot>  (9,3)
12:20:34 <tomejaguar> firrst
12:20:49 <Hafydd> firsst?
12:21:10 <milfjord> primum
12:21:29 <Hafydd> (primum, coprimum)
12:23:32 <FreeFull> :t fromJust $ (.) _2 ? (Just 3) (9,9)
12:23:33 <lambdabot> Not in scope: `?'
12:23:36 <FreeFull> :t fromJust $ (.) _2 ?a (Just 3) (9,9)
12:23:38 <lambdabot> (Num a, Num t, Num t1, ?a::Maybe a -> p t1 (Maybe b), Indexable Int p) => (t, b)
12:23:42 <navaati> so, i see a lot of packages supposedly related to the same stuff, namely monad transformers. so what is the difference between transformers and mtl ?
12:24:50 <tomejaguar> mtl uses typeclasses to make lifting more convenient.  I don't know of any other difference.
12:24:57 <pjdelport> (car, cdr)
12:25:01 <geekosaur> mtl 2.x is a wrapper over transformers providing an interface compatible with 1.x?
12:25:24 <geekosaur> as for transformers, it went along with an experiment in different implementations of monads (fundeps vs. type families)
12:25:58 <geekosaur> (the actual relationship's a bit more complex than that, though)
12:27:11 <geekosaur> but if you look at the dependencies for current mtl you'll see that it uses transformers underneath
12:27:38 <roboguy_> L8D: anyway, I personally think that it's worth it to give lens a try. there are other lens libraries that are smaller, but the added utility of the lens library definitely grows on you
12:27:42 * hackagebot oauthenticated 0.1.1 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.1 (JosephAbrahamson)
12:27:52 <roboguy_> *of the lens package
12:27:54 <geekosaur> (IIRC the actual relationship is transformers at base then monads-fd and monads-tf as the testbed and mtl2 went with the fd basis)
12:29:40 <d3lxa> sequence/A doesnt seem to do what I need, I got stuck with this http://sprunge.us/cYgA it's weird, any idea please?
12:30:35 <merijn> navaati: mtl provides convenience stuff over transformers, but the convenience uses extensions and is thus less portable to other (i.e. non-GHC) haskell implementations
12:30:50 <_sebastian_> I
12:31:24 <_sebastian_> I'm tired of errors lile "Couldn't match expected type `ByteString'  with actual type `ByteString'"
12:31:42 <merijn> _sebastian_: You're mixing lazy and strict ByteStrings
12:31:44 <tomejaguar> Yeah it's super confusing.
12:32:41 <_sebastian_> merijn: tomejaguar, happens, if you use modules, where one module is using strict and the other one is using lazy.
12:33:33 <roboguy_> I'm not sure if it's the case in older ghcs, but in 7.8 they add clarification about where each ByteString is coming from
12:34:08 <tomejaguar> Yes and if you haven't imported one of the types it says "bytestring-x.x.x.Data.ByteString.Internal.ByteString" or something, which is more confusing.
12:34:11 <tomejaguar> Haven't tried 7.8.
12:37:21 <_sebastian_> and thy had to use different types and not different set of functions on the same type
12:37:32 <roboguy_> it also has something that says "NB: ‛BS.ByteString’ is defined in ‛Data.ByteString.Internal’\n‛Data.ByteString.Lazy.Internal.ByteString’ is defined in ‛Data.ByteString.Lazy.Internal’"
12:40:25 <pharaun> that's nice improvement, i've had fun with *that* before :)
12:43:29 <authchir> hi there, I am looking for a higher order function for a specific manipulation of Monad and can not find it
12:43:50 <Twey> I think the incompatibility is deliberate — it would be unpleasant to debug if you accidentally used one where the other was intended and your performance went down the drain
12:45:21 <authchir> Is there something that would look a little bit like that? Monad m => (a -> b -> mb) -> [a] -> m b
12:45:33 <FreeFull> Where would the b come from?
12:46:02 <authchir> the b would come from the m b of the last call
12:46:10 <FreeFull> Where would the first b come from?
12:46:11 <shachaf> That's a bit magical. Where do the "b"s come from?
12:46:12 <authchir> while iterating over the list of a
12:46:19 <dmwit> :t foldM
12:46:20 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:46:34 <dmwit> also:
12:46:41 <dmwit> ?hoogle Monad m => (a -> b -> m b) -> [a] -> m b
12:46:42 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
12:46:43 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
12:46:43 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
12:47:40 <shachaf> None of those will give you the type you asked for, though, because it's not possible
12:47:44 * hackagebot sqlite-simple 0.4.5.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.5.0 (JanneHellsten)
12:47:56 <Twey> authchir: What about the b for the *first* call?
12:48:07 <dmwit> Remember: people don't know what they want. They'll ask for a toaster in their car because they don't wake up early enough.
12:48:26 <dmwit> What they really want is an alarm clock.
12:48:38 <Twey> @remember dmwit Remember: people don't know what they want. They'll ask for a toaster in their car because they don't wake up early enough.
12:48:38 <lambdabot> Okay.
12:48:50 <pharaun> dmwit: can i have a toaster in my car? :)
12:49:02 <dmwit> =D
12:49:13 <authchir> OMG, a forgot space made my hoogle search return me nothing
12:49:27 <authchir> That should have been obvious
12:49:41 <authchir> Thank you, I was sure there was such a functino
12:49:49 <dmwit> (That analogy was not invented by me, though.)
12:50:13 <pharaun> i figured :) i've heard something like that before
12:50:20 <Twey> authchir: You can do it if you add a b into the type
12:50:22 <Twey> dmwit: Aww.
12:50:30 <authchir> and for the *first* b, you are right, I forgot to add it in the parameters
12:50:51 <Twey> authchir: (a → b → m b) → [a] → m b is foldM
12:50:55 <Twey> Err
12:50:59 <Twey> authchir: (a → b → m b) → b → [a] → m b is foldM
12:51:08 <pharaun> fancy unicode!
12:51:25 <Twey> (well, approximately)
12:51:25 <authchir> that's nice
12:51:27 <Twey> :t foldM
12:51:28 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:51:49 <Twey> Actually, that's exact, isn't it
12:51:54 <dmwit> authchir++ for checking Hoogle first
12:52:16 <Twey> authchir: You just have to have something to pass into the first call
12:52:16 <dmwit> not exact
12:52:33 <dmwit> (a -> b -> m b) vs (a -> b -> m a)
12:52:54 <Twey> Ugh
12:52:59 <dmwit> very close, though =)
12:53:55 <Twey> (b → a → m a) → a → [b] → m a -- in terms of the foldM type variables
12:54:04 <Twey> So yes, just a flipped function away
13:02:46 * hackagebot hArduino 0.9 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.9 (LeventErkok)
13:04:50 <dwcook> What was the terminology that described who provided a specific argument in a function type? e.g., in (Foo -> Bar) -> Bar, the function provides a Foo but the user provides a Bar.
13:05:18 <triliyn> dwcook: positive/negative?
13:05:29 <dwcook> Yeah, that. Where can I read about that?
13:06:56 <dmwit> You should read about game semantics for logic!
13:07:04 <triliyn> hmmm, I saw a nice blog post a while ago, but I can't find it again
13:07:17 <dagnachew> hi all
13:07:33 <Ymesio> Hm, I'm reading Learn You A Haslkell
13:07:37 <Ymesio> Pretty impressed so far
13:07:39 <dmwit> https://en.wikipedia.org/wiki/Game_semantics
13:07:44 <dmwit> Hi dagnachew and Ymesio!
13:07:46 <dmwit> Welcome.
13:07:55 <esebelle> hey umm
13:08:06 <dmwit> Howdy, esebelle.
13:08:08 <esebelle> how can I set a custom output for Cabal's TestSuite result?
13:08:20 <esebelle> it seems to just use a default "show" instance
13:08:22 <dwcook> Huh, neat. Thanks
13:08:31 <esebelle> which means that the string gets printed out escaped
13:08:43 <esebelle> like this:
13:08:43 <esebelle> Test case Ext.Data.List: Fail "groupByCount 100 \"ab\" = [\"ab\"]\nexpected:
13:08:44 <esebelle> [\"ab\"]\n but got: [\"ba\"]"
13:09:02 <esebelle> which I think you can see is terribly ugly
13:09:12 <esebelle> want to set a custom output manager
13:09:38 <dmwit> I suppose you will have to write your own test runner instead of the default (and, I might add, kind of dumb) one.
13:10:02 <dmwit> Although I will admit I'm not an expert on this stuff.
13:10:03 <esebelle> we already had to write like 150 LOC just to translate from HUnit tests to cabal tests
13:10:13 <hakujin> little fuzzy on the entire pipes/conduit streaming paradigms; for small http json responses is there any benefit to incremental parsing vs just handing the full response body to attoparsec/aeson?
13:10:32 <esebelle> hakujin: memory usage
13:11:05 <hakujin> esebelle: isn't that an issue only with larger data streams?
13:11:06 <esebelle> hakujin: sometimes you don't need to keep the whole structure around and can throw away bits as you're done with them
13:11:10 <esebelle> or just keep the necessary parts
13:11:13 <hakujin> typical json responses are tiny
13:11:18 <esebelle> also
13:11:26 <esebelle> it means you're not blocked on IO waiting for the whole thing to get through
13:11:31 <esebelle> before you start using it
13:11:53 <esebelle> on the flipside
13:11:58 <aleksejs_> offtop: this is why I like safe languages http://javascript-puzzlers.herokuapp.com/
13:11:59 <esebelle> it makes error management/recovery harder
13:12:03 <esebelle> because if something goes wrong
13:12:21 <esebelle> you have to throw away all the work you've been doing and report the error etc.
13:12:33 <esebelle> for small responses I'd just parse the whole thing, you don't need incremental
13:12:45 <esebelle> unless you expect them to get bigger in the future and want it to be scalable
13:12:47 * hackagebot MonadRandom 0.1.13 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.13 (BrentYorgey)
13:13:01 <esebelle> umm, I suppose you might want to make sure you set a maximum size though
13:13:06 <esebelle> to prevent a DoS opportunity
13:13:38 <esebelle> dmwit: honestly cabal test-suites suck so far
13:14:13 <esebelle> dmwit: this is what I have so far, for translation: http://pastebin.com/YPDDQUEj
13:14:20 <dmwit> You can use exit-stdio and whatever other tool you thought was better.
13:14:31 <dmwit> There's no need to use detailed-0.9 or whatever it is called.
13:14:54 <esebelle> I wanted tagging
13:15:00 <esebelle> so I could have cabal run subsets of my testsuite
13:15:16 <esebelle> maybe hunit provides that
13:15:18 <hakujin> esebelle: good point with blocking on IO until the body is fully downloaded. is there any overhead I should be aware of? some break point where "this is too tiny just parse it all at once" -> "this is big enough, start incrementally parsing"?
13:15:27 <dmwit> Have you looked into the other tools? I think there are several that provide ways of choosing subsets of the tests to run.
13:15:37 <esebelle> hakujin: umm, if you expect any responses are going to be big enough, I'd do it one way
13:15:45 <esebelle> hakujin: having two codepaths is overkill
13:15:46 <hakujin> define big enough :)
13:17:08 <merijn> hakujin: >50MB
13:17:28 <dmwit> wat
13:17:28 <merijn> hakujin: Possibly >100MB depending on how many concurrent things
13:17:30 <hakujin> merijn: interesting, do you have a source?
13:17:38 <merijn> hakujin: No, just making it up
13:17:39 <merijn> :)
13:18:18 <esebelle> it depends on your requirements
13:19:17 <esebelle> dmwit: haha I'm just well, my day-job has been ruby on rails for a while now
13:19:19 <esebelle> and it's like
13:19:26 <esebelle> there's a "right way to do things"
13:19:33 <esebelle> moving back to the freedom of haskell is interesting
13:20:07 <procyon1> Help appreciated: I am trying to build an application that does multiple, async HTTP requests to multiple servers. I'd like to queue up the responses so that my main loop can pull in the updates each iteration... First off, am I smoking crack, or is this sounding reasonable.
13:20:20 <esebelle> I suppose I'll use a different tool
13:20:24 <esebelle> cabal test-suite is terrible
13:20:33 <esebelle> oh, btw, is cabal freeze out yet?
13:20:38 <esebelle> I've been wanting that for so long
13:20:40 <hakujin> procyon1: sounds reasonable
13:21:26 <hakujin> the 'async' package on hackage is probably where you want to start
13:21:28 <esebelle> procyon1: look into control.concurrent.chan
13:21:34 <esebelle> probably exactly what you want
13:21:42 <esebelle> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-Chan.html
13:21:56 <esebelle> you may want to build your own wrapper around it though
13:21:58 <milfjord> no, async
13:21:59 <esebelle> it's a primitive
13:22:11 <esebelle> oh sorry, what's async?
13:22:17 <procyon1> hakujin: Okay, good. Next step... I was building this with http-streams, but that seems to need an external async library and connection pool manager. http-client seems to come with this baked in. Am I missing something about http-streams? I don't want to build my own connection pool if possible.
13:22:28 <esebelle> ooh this is new!
13:22:32 <esebelle> never seen async before
13:22:47 <esebelle> awesome
13:23:20 <esebelle> looks fairly non-primitive :P
13:24:00 <procyon1> Anyone played with http-client vs http-streams+control.concurrent.chan? Will the http-client library really just "work" batteries included and give me a concurrent connection pool?
13:27:07 <dagnachew> what is the best highlight script for weechat ?
13:27:29 <hakujin> procyon1: looking at the http-conduit (abstraction over http-client, which you probably want) it says the manager is thread safe and intended to be shared
13:28:04 <hakujin> async + http-conduit I assume will give you what you want
13:28:10 <dmwit> dagnachew: Maybe you could ask in a channel devoted to weechat.
13:28:27 <thoughtpolice> procyon1: i haven't used either, but http-client uses its own internal connection pool from my understanding. alternatively, a package like resource-pool makes it very easy to write your own pool, and you can probably just combine it with async and http-streams
13:28:45 <joneshf-laptop> hmm
13:28:48 <thoughtpolice> (granted http-client may also take care of other trickier problems, like exception handling, etc)
13:28:57 <joneshf-laptop> why does parsec have `eof`, but not `eol`?
13:29:44 <dmwit> joneshf-laptop: I would guess because "eof" is stream-independent, but "eol" depends on all kinds of things.
13:29:54 <dmwit> joneshf-laptop: That said, have you looked in the module that contains String-specific stuff?
13:29:57 <procyon1> hakujin: I'll look at http-conduit. That might just do the trick.
13:30:05 <dmwit> There's probably something like "eol" in there, or something you can use to build it easily.
13:30:20 <dmwit> Like "char '\n'".
13:30:27 <dwcook> There's newline, but it's not analogous to eof since it consumes input
13:31:10 <joneshf-laptop> do people just not worry about `eol` when using parsec?
13:31:23 <esebelle> dwcook: it's trivial to write yourself
13:31:32 <joneshf-laptop> like is the standard way to deal with it, `unlines` then parse?
13:31:41 <esebelle> umm, just write it yourself?
13:31:43 <esebelle> it's trivial
13:32:29 <hakujin> esebelle: I'm sure he'd appreciate an example, or a link to more parsec info
13:32:29 <esebelle> define eol without lookahead
13:32:40 <joneshf-laptop> it's not about the triviality of it
13:32:42 <esebelle> and if you want to lookahead use "lookAhead eol"
13:32:55 <joneshf-laptop> or rather
13:32:57 <milfjord> joneshf-laptop: '\n' isn't that special
13:33:02 <joneshf-laptop> if it's so trivial, why isn't it in there?
13:33:03 <dagnachew> dmwit: am sorry I tought I was in #weechat
13:33:35 <esebelle> hakujin: been a while since I used parsec, looking into writing it
13:33:43 <joneshf-laptop> but in any case
13:33:51 <joneshf-laptop> different systems make it less trivial
13:34:07 <esebelle> it's "\r\n", "\n", or "\r"
13:34:23 <joneshf-laptop> in any case: http://hackage.haskell.org/package/parsec-extra-0.1.0.3/docs/Text-Parsec-Extra.html
13:34:25 <milfjord> it's \n if you've done your decoding right
13:34:57 <jmcarthur> haasn: indeed, Applicative = strong lax monoidal functor
13:35:34 <dwcook> Handles carry information about how line endings are to be transformed, with the ultimate goal that you get \n instead of whatever weird ending you'd otherwise get
13:35:43 <esebelle> ((lookAhead (string "\r\n") >> (string "\r\n)) <|> oneOf "\r\n")
13:35:46 <esebelle> how's that?
13:36:06 <esebelle> missing a "
13:36:13 <esebelle> eol ((lookAhead (string "\r\n") >> (string "\r\n")) <|> oneOf "\r\n")
13:36:14 <dwcook> On the other hand, it's imaginable that there are circumstances where you'd want to handle it yourself
13:36:21 <dwcook> Like with IRC and bytestrings
13:36:36 <joneshf-laptop> isn't there also "\n\r"?
13:36:39 <esebelle> no?
13:36:40 <dwcook> joneshf-laptop, doubtful
13:36:40 <joneshf-laptop> on some obscure system
13:36:48 <dwcook> There's \n, \r\n, and \r
13:36:52 <dwcook> But \r is antiquated, I believe
13:36:59 <esebelle> yeah, old mac systems
13:37:09 <milfjord> I wonder
13:37:18 <jmcarthur> i wish the standard libs provided something lower level and lighter weight than handles. i don't always want that additional buffering and "intelligence".
13:37:20 <milfjord> does Haskell define '\n' as '\10'?
13:37:30 <dwcook> > '\10' == '\n'
13:37:31 <lambdabot>  True
13:37:35 <jmcarthur> i guess there's posix stuff available
13:37:44 <jmcarthur> but that's a bit *too* low level
13:37:51 <dwcook> Dunno whether the report says anything about it though
13:37:53 <esebelle> >
13:37:53 <esebelle>  <dwcook> On t
13:38:02 <esebelle> > ((lookAhead (string "\r\n") >> (string "\r\n")) <|> oneOf "\r\n")
13:38:03 <lambdabot>  Not in scope: `lookAhead'Not in scope: `string'
13:38:03 <lambdabot>  Perhaps you meant one of these:
13:38:03 <lambdabot>    `storing' (imported from Control.Lens),
13:38:03 <lambdabot>    `trying' (imported from Control.Exception.Lens),
13:38:03 <lambdabot>    `trying' (imported from Control.Monad.Error.Lens)Not in scope: `string'
13:38:09 <esebelle> heh no parsec
13:38:14 <dwcook> esebelle, yes, I saw you say that already
13:38:27 <esebelle> dwcook: didn't mean to ping you. copy-paste error
13:38:36 <dmwit> jmcarthur: You want something other than a binary handle with NoBuffering?
13:38:42 <geekosaur> if you're capturing output from another system, some older telnets will send \r\n as \r\0\n or even \r\0\0\n
13:39:07 <dmwit> I think we've successfully answered the "why is there no eol" question now. There's too many correct choices.
13:39:41 <dwcook> dmwit, keeping in mind they still settled on char '\n' for newline's definition
13:39:55 <dwcook> Which I think is the sanest default, really
13:40:07 <joneshf-laptop> http://en.wikipedia.org/wiki/Newline#Representations
13:40:41 <joneshf-laptop> anyway, parsec-extras has something that'll work
13:42:28 <joneshf-laptop> though it doesn't seem to check all these obscure cases
13:42:29 <jmcarthur> dmwit: all handles support lookahead, even with buffering "disabled"
13:42:42 <jle`> mm_freak_: is there anything then that is Wire s e m a (Wire s e m a b) -> Wire s e m a b...taking in `a` to give a resulting ouput wire, and then feeding in that same `a` to the resulting wire and getting the `b` from inside?
13:43:05 <dmwit> jmcarthur: huh
13:43:46 <jmcarthur> dmwit: at least for one Char, iirc
13:44:55 <jmcarthur> well, i guess i'm speaking about readable handles only, of course
13:45:11 <jmcarthur> i don't know if there is any reason for a writable handle to have a buffer if you don't want it
13:45:17 <jmcarthur> *write-only
13:46:18 <geekosaur> performance with large amounts of data written in small chunks
13:46:44 <jmcarthur> geekosaur: "if you don't want it."
13:47:07 <jmcarthur> geekosaur: i was referring to the fact that even though the interface appears to support it, you can't actually make a readable handle unbuffered
13:47:16 <geekosaur> not sure what that adds, since reasons for not wanting ot are rarely directly tied to that
13:47:37 <jmcarthur> geekosaur: one reason not to want buffering on a writable handle is for scatter gather purposes
13:47:51 * hackagebot regex-pcre-builtin 0.94.4.8.8.34 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.8.8.34 (AudreyTang)
13:48:15 <mm_freak_> jle`: what would such a function denote?
13:48:58 <esebelle> so does anyone have a good suggestion for a test running framework we could use with both hunit and quickcheck?
13:49:45 <roboguy_> esebelle: tasty is supposed to be pretty good
13:51:42 <enthropy> hspec
13:54:59 <khyperia> I just read through a lens tutorial for the first time... I think my head is broken now.
13:55:35 <dwcook> jle`, isn't that just join?
13:55:44 <dwcook> @type join
13:55:45 <lambdabot> Monad m => m (m a) -> m a
13:56:52 <dwcook> @type join `asAppliedTo` (undefined :: Wire s e m a (Wire s e m a b))
13:56:53 <lambdabot> Not in scope: type constructor or class `Wire'
13:56:53 <lambdabot> Not in scope: type constructor or class `Wire'
13:56:58 <dwcook> Oh well.
14:01:12 <esebelle> "Ingredients make your test suite tasty. " - https://hackage.haskell.org/package/tasty-0.7/docs/Test-Tasty-Runners.html
14:01:18 <esebelle> ok I like this already XD
14:01:42 <dmwit> dwcook: Depends. He's just asking for a type; join comes with a type and a promise.
14:02:02 <dmwit> I suspect he's asking because it's already known that you can't have something with the appropriate type that also satisfies the promise.
14:02:12 <dmwit> But you might reasonably have something with the right type and no promise.
14:02:53 * hackagebot hspec-meta 1.8.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.8.3 (SimonHengel)
14:02:55 * hackagebot hspec 1.8.3 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.8.3 (SimonHengel)
14:03:31 <Feuerbach> esebelle: http://documentup.com/feuerbach/tasty is a good place to start with tasty
14:04:27 <esebelle> what's the point of golden testing?
14:04:55 <esebelle> just seems like something you do if you're too lazy to write proper unit tests
14:04:58 <esebelle> >_>
14:04:59 <greedo> what does parse error on input `=' usually mean?
14:05:18 <dmwit> golden tests are unit tests with the outputs stored on disk
14:05:25 <milfjord> greedo: you have a syntax error somewhere
14:05:25 <dmwit> instead of in the program itself
14:05:36 <esebelle> but...
14:05:37 <esebelle> why?
14:05:55 <esebelle> because your output is really big?
14:05:55 <dmwit> greedo: Look for indentation errors or parenthesis matching errors. Those are the most common things for me.
14:06:00 <dmwit> esebelle: for example, yes
14:06:04 <esebelle> ah, ok
14:06:08 <Feuerbach> esebelle: 1. they are easier to update; 2. large outputs are better stored in files than encoded in source files
14:06:17 <esebelle> ok that makes sense
14:06:18 <Twey> greedo: If you're defining things in GHCi, you need to use the ‘let’ keyword.
14:06:48 <DrAwesomeClaws> another dumb question.  Getting a syntax error on line 18 https://gist.github.com/anonymous/fbb0e01d41d337a9e520  " parse error on input `case'"    Modifying code based on http://book.realworldhaskell.org/read/extended-example-web-client-programming.html     Don't see why my usage of case differs from the example.
14:06:52 <esebelle> I was thinking it was more like "I'm too lazy to write unit tests" "I know, I'll just dump tons of outputs to a file and see if it changes"
14:06:53 <Feuerbach> esebelle: in fact, tasty can update golden files when you tell it to do so
14:07:03 <identity> Okay.. What do I do when makeLenses is causing ordering in Haskell files to be important? As in, I can't define an ADT below another ADT if the latter uses the first
14:07:07 <greedo> milfjord dmwit Twey: thanks, it's most likely something simple
14:07:16 <esebelle> neat :)
14:07:21 <milfjord> DrAwesomeClaws: alignment error
14:07:31 <milfjord> DrAwesomeClaws: 'case' doesn't line up with 'resp'
14:07:52 <DrAwesomeClaws> ah,  guess i should look into how alignment actually works in haskell, haha.  Thanks mildfate
14:07:53 <DrAwesomeClaws> err
14:07:55 <DrAwesomeClaws> milfjord:
14:08:12 <dmwit> greedo: If you post some code (try lpaste.net), we can help you try to spot the problem.
14:08:19 <esebelle> ooh
14:08:39 <identity> Nevermind -- I figured it out. makeLenses should be below all ADT declarations if many ADTs that are intertwined are defined in the same file
14:08:44 <esebelle> what's the best way to test highly polymorphic things in Haskell?
14:08:57 <esebelle> should I define concrete things to use it with in my test case?
14:08:57 <dmwit> {quick,small}check
14:09:14 <esebelle> or pull in concrete things from elsewhere and use them with it?
14:10:34 <greedo> dmwit: http://lpaste.net/8138863090620956672
14:10:48 <esebelle> like.. let's say I wrote a Monadic version of fmap
14:11:21 <alorente> So I was poking around in ghci, just seeing if various operators are defined, and I encountered some weird behavior: Normally, if you say `:t asdfasdf` you get a "Not in scope" error. But `:t (=>)` gives a parse error instead.
14:11:21 <alorente> Is that just a quirk of the parser, and I should read it as not-in-scope, or is there a reason `=>` specifically is a syntax error?
14:11:36 <dmwit> greedo: Everything in "main" needs to be indented.
14:11:37 <esebelle> fmapM f = (>>= (return . f))
14:11:42 <esebelle> how do I test that?
14:11:48 <esebelle> do I just pull in tons of monads and test them with it?
14:11:49 <triliyn> alorente: => is syntax, not a function
14:11:52 <milfjord> alorente: => is not an operator
14:11:55 <dmwit> greedo: And functions must use lower-case first letters, so change Cool to cool.
14:12:30 <dmwit> esebelle: You could consider testing it with the free monad.
14:12:39 <greedo> dmwit: the indents in the main are there, I just did a bad paste
14:13:01 <alorente> Oh! Because (=>) can show up in type signatures. Got it. Thanks
14:13:57 <Axman6> that's the only place it can show up really
14:13:58 <AshyIsMe> man there's too many programming languages
14:14:12 <Axman6> AshyIsMe: and still not enough!
14:14:13 <AshyIsMe> i want to learn an apl next like J
14:14:28 <AshyIsMe> Axman6: gotta catch em all!
14:14:39 <absence> has anyone tried compiling the "world's worst synthesizer" example with reactive banana 0.8?
14:15:11 <absence> i get an error that it can't deduce Show (reactive-banana-0.8.0.0:Reactive.Banana.Types.Future Note)
14:15:48 <absence> and being a complete banana noob i have no idea how to fix it even though i understand what it means :)
14:16:00 <greedo> dmwit: thank you, I did have some bad indenting
14:16:31 <greedo> is there a style guide for haskell?
14:17:04 <dmwit> http://urchin.earth.li/~ian/style/haskell.html seems well agreed on
14:17:10 <dmwit> Though I have my own views, of course. ;-)
14:18:41 <greedo> sure, there is one for python and I try to stick to it, so my code is beautiful and readable
14:21:23 <roboguy_> absence: what are you trying to do?
14:21:26 <melonmechanic> is anybody here familiar with the neco-ghc plugin for vim? I'm fairly new to vim so i'm having trouble figuring out how to get it installed
14:22:45 <hakujin> melonmechanic: I use it
14:22:53 <absence> roboguy_: compile the example
14:23:06 <esebelle> dmwit: wait does the free monad obey the monad laws?
14:23:13 <enthropy> absence: is means that it used to be possible to show a Future Note
14:23:31 <esebelle> > Pure 2
14:23:32 <lambdabot>  Not in scope: data constructor `Pure'
14:23:36 <enthropy> now you can't (because the instance is gone, or maybe it's in a module that you didn't import)
14:24:12 <esebelle> dmwit: like is >> associative?
14:24:42 <absence> enthropy: i understand the haskell part of what it means, i wonder what has changed in reactive banana since the tutorial was written that has added a Future or whatever it is that has happened
14:25:47 <roboguy_> esebelle: doesn't it obey the laws by definition?
14:26:03 <roboguy_> it's the free monad for a functor
14:26:06 <dmwit> esebelle: Well.
14:26:08 <esebelle> you can make Monad instances that break the monad laws...
14:26:24 <esebelle> "[] is not a free Monad (in this sense) because join [[a]] smashes the lists flat. "
14:26:26 <dmwit> esebelle: The free monad obeys the laws. No idea if there's a suitable Haskell implementation of it, though. =P
14:26:35 <dmwit> esebelle: I know there's a monad called Free lying around.
14:26:42 <enthropy> absence: probably the implementation of Future was changed, and no Show instance exists anymore
14:26:47 <dmwit> esebelle: But it probably assumes some kind of observational equivalence.
14:27:15 * esebelle nods
14:27:17 <enthropy> currently it seems to be  type Future = Dated; type Dated = RWS () Time Vault
14:27:26 <shachaf> (Free f) is a free monad on f and obeys the monad laws.
14:28:07 <enthropy> so to get what Note it actually is, you'd have to provide some Vault
14:28:10 <absence> enthropy: the Future type didn't exist in the version used
14:28:14 <dmwit> Does it obey them on the nose, or only up to some equalities that we are supposed to assume live outside of Haskell-land?
14:28:26 <roboguy_> esebelle: which law are you concerned about?
14:28:32 <esebelle> roboguy_: give me a sec
14:28:49 <absence> enthropy: so i don't think the problem is that Future needs a Show instance. i think i somehow need to extract the value from the Future?
14:29:01 <melonmechanic> exit
14:29:38 <identity> If I have  MonadState computation over Foo which contains Bar which contains a Map, how would I lens into that map? Something like "use bar ^. myMap ^. at blah" or something?
14:29:55 <identity> Which doesn't work because ^. isn't 'monadic' or something, I think. Looks like what the types are saying, anyhow
14:30:10 <shachaf> It obeys them on all three noses.
14:30:18 <shachaf> (Assuming the functor laws.)
14:30:20 <rawtass> If I have a lazy list which is based on runGetIncremental, is it possible to use parallel processing on that list without messing up the order of which the file is parsed?
14:30:46 <dmwit> neat
14:30:52 <shachaf> identity: use (bar . myMap . at blah)?
14:30:57 <roboguy_> shachaf: right on all three noses huh?
14:31:12 <shachaf> The main point of lenses is that they are composable.
14:32:04 <esebelle> roboguy_: well I read the bit that was like "A free Monad is one that does no work during the normalization step beyond simply grafting the two monadic values together. "
14:32:14 <esebelle> and that seemed to imply non-associativity to me
14:32:22 <esebelle> like
14:32:31 <esebelle> [a, [b, c]] != [[a, b], c]
14:32:43 <esebelle> but I'm still trying to understand exactly what the free monad does
14:32:45 <shachaf> It does the minimal amount of work required to maintain associativity (and the other laws).
14:32:59 <roboguy_> esebelle: well, list isn't a free monad for one
14:33:09 <roboguy_> for that very reason, actually
14:33:29 <esebelle> ooooooh
14:33:31 <esebelle> I get it
14:33:39 <identity> shachaf: that seems to do it indeed, yes. thanks. still getting the hang of lens
14:33:41 <esebelle> right
14:33:46 <jophish_> Do people always follow the advice of HLint?
14:33:46 <esebelle> == can be an equivalence relation
14:33:51 <esebelle> it doesn't have to be syntatic equivalence
14:33:54 <esebelle> is that why?
14:34:00 <dmwit> no
14:34:01 <shachaf> Wait, which (==) are you talking about?
14:34:06 <jophish_> for example sometimes eta reducing can make the code hader to follow
14:34:14 <dmwit> esebelle: The free monad simply isn't [].
14:34:25 <dmwit> esebelle: So anything you write about lists is off-base.
14:34:46 <shachaf> Well, [] gives you the free monoid, which is close enoguh that it can give you some intuition.
14:35:00 <absence> enthropy: ah, had to use reactimate' instead of reactimate and add an fmap
14:35:00 <Twey> jophish_: I think if the function is simple enough that it can be η-reduced, said reduction wouldn't make it harder to follow
14:35:10 <shachaf> But you have to approach it from the right perspective.
14:35:17 <roboguy_> jophish_: sometimes it tells me to make things quite a bit less clear (in my opinion), like when it tells me to turn a case statement into forM. so not always
14:35:17 <Twey> Extra variables are purely redundancy at that point
14:35:32 <Twey> roboguy_: Case statement… into forM?  o.@
14:35:32 <jophish_> Twey: sure, but it's nice for them to have descriptive names
14:35:37 <roboguy_> in fact, that sort of thing is why I turned off automatic hlint
14:35:46 <esebelle> gahh I'm supposed to be driving to visit this cute guy
14:35:51 <jophish_> Twey: case over Nothing and Just x could be a forM
14:35:51 <esebelle> and instead I'm thinking about Haskell
14:35:53 <esebelle> gotta go
14:35:56 <Twey> jophish_: If your names need to be descriptive, your types aren't descriptive enough
14:36:01 <mellum> I want  a list of indices where a list is not zero. The best I could come up with is map fst . filter ((/= 0) . snd) . zip [1..n]. Is there something more elegant?
14:36:23 <jophish_> Twey: I think that may be a bit of an over generalisation
14:36:25 <Twey> jophish_: Consider using type synonyms to make your intent more clear, if you can't actually constrain the types any further
14:36:26 <roboguy_> Twey: yeah. it was for the Maybe monad
14:36:42 <Twey> :t forM
14:36:43 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
14:36:47 * Twey scratches his head.
14:37:08 <jophish_> Twey: the example I have at the moment is this: funTy t1 t2 = TAp (TAp tArrow t1) t2, for constructing the types of functions
14:37:24 <jophish_> I think that this is a lot quicker to understand at a glance than funTy t1 = TAp (TAp tArrow t1)
14:37:34 <Twey> jophish_: funTy = TAp .: TAp tArrow
14:38:20 <Twey> Er
14:38:28 <roboguy_> Twey: unfortunately, I don't have that particular example anymore. I mentioned it in #haskell-lens earlier, but I don't think there's an IRC log of that channel
14:38:28 <Twey> It doesn't even need that, does it
14:38:34 <Twey> TAp . TAp tArrow
14:38:55 <jophish_> usually I really like clever things like that. But (In my opinion in this case) I don't think that it gets clearer than: funTy t1 t2 = TAp (TAp tArrow t1) t2
14:39:13 <Twey> roboguy_: I guess you could probably squeeze it through an extra intermediate list, but it seems like a strange kind of ‘simplification’
14:39:24 <Twey> jophish_: Function composition isn't clever :þ
14:40:18 <jophish_> I think simplifying it to something like that is pointless
14:40:45 <Twey> jophish_: I think adding arbitrary points in is pointless :þ
14:40:51 <jophish_> :)
14:41:05 <Twey> jophish_: I lost my aversion to writing things point-free when I realized that every function application in Haskell is implicitly point-free
14:41:20 <identity> is there an incomplete lens for indexing into a map? "at" returns Maybe a. E.g. I want what is Data.Map.! to Data.Map.lookup but a lens.
14:41:22 <jophish_> Twey: what do you mean by that?
14:41:36 <shachaf> identity: There is ix, which gives you a Traversal.
14:41:39 <Twey> TAp is (\x → TAp x), tArrow is (\x → tArrow x)
14:41:52 <pranz> if you were to implement the natural numbers ala peano, would it make any difference in performance or memory if you defined it as either the common peano implementation or as a list of units?
14:42:13 <Twey> Point-free is the default mode of expression in Haskell; making things pointful is the ugly/hard-to-comprehend part
14:42:18 <roboguy_> is there a good way to make an unboxed 2 dimensional Vector, or is an unboxed Array the way to go for that?
14:42:25 <jophish_> ah, I see
14:42:28 <Twey> And if you do it consistently you end up with a terrible mess
14:42:56 <jophish_> but nobody writes completely point free programs
14:43:05 <jophish_> I think that there is a balance to be struck
14:43:11 <roboguy_> identity: is a Traversal ok?
14:43:15 <Twey> And point-free is intrinsically linked to good style: quite often, if you can't make a function obviously point-free, it's because your function is too complicated and should be broken down
14:43:29 <Twey> jophish_: Sure, some functions just have innately complex data flow
14:43:39 <Twey> But that example isn't one of them
14:43:55 <Twey> Nor any function that can be η-expanded trivially enough that HLint can figure it out :þ
14:44:04 <roboguy_> identity: if so, how about ix?
14:44:06 <Twey> Er, -reduced
14:44:23 <jophish_> Twey: you make a convincing point.
14:44:34 <jophish_> I think I'll follow your advice here
14:44:37 <shiona> any pointers on how to implement  Maybe a -> Maybe [a] -> Maybe [a], I think it's some sort of lift, but I can't make one work
14:44:38 <jophish_> thank you
14:45:08 <mellum> Incidentally. Is there a way to write \[u, v] -> (u, v) point-free?
14:45:12 <shiona> (:) within maybe
14:45:23 <roboguy_> shiona: do you know about Applicative?
14:45:28 <dwcook> shiona, liftA2 (:)
14:45:39 <Twey> mellum: Not a nice one ☹
14:45:50 <shiona> roboguy_: heard and tried once or twice
14:45:57 <dwcook> @type liftA2 (:)
14:45:58 <Twey> (because tuples are magic and not recursively defined)
14:45:58 <lambdabot> Applicative f => f a -> f [a] -> f [a]
14:46:10 <pranz> mellum: head &&& (head . tail)
14:46:11 <mm_freak_> dwcook: Wire does not give you a Monad instance
14:46:12 <pranz> i think works
14:46:19 <roboguy_> :t \x y -> (:) <$> x <*> y
14:46:20 <lambdabot> Applicative f => f a -> f [a] -> f [a]
14:46:21 <Twey> Like I said :þ
14:46:23 <pranz> mellum: (&&&) is from Control.Arrow
14:46:28 <shiona> I really think I should go through and try to understand applicative and monad and how they compare
14:46:32 <mellum> pranz: whoa. I have to look up what it does
14:46:37 <identity> sorry -- girlfriend called. I'm not sure. Let me try it out @ shachaf & roboguy_
14:46:41 <roboguy_> shiona: there's a definition using Applicative
14:47:19 <roboguy_> shiona: it might help to think of <$> and <*> as whitespace in a context (if that makes sense)
14:47:38 <dwcook> mm_freak_, hmm, guess not. I was confusing it with something else
14:47:50 <roboguy_> shiona: for instance, "f <$> x <*> y" conceptually applies the function f to the values x and y in a certain Applicative "context"
14:47:59 <roboguy_> in this case, maybe
14:48:01 <roboguy_> *Maybe
14:48:14 <dwcook> That's practically what liftA2 does
14:48:16 <dwcook> @src liftA2
14:48:16 <lambdabot> liftA2 f a b = f <$> a <*> b
14:48:34 <roboguy_> dwcook: yeah, but I figured it would be good to learn the more fundamental/general form first
14:48:51 <dwcook> Right, I wasn't saying not to think of it that way, I was just giving a means of understanding the suggestion I made
14:50:05 <shiona> thank you, it seems to work for now
14:50:41 <Twey> pranz: You might as well go the whole hog and write  (head &&& (!! 1))  or  on (&&&) (!!) 0 1  :þ
14:50:59 <Twey> Or flip (!!), rather
14:51:10 <Twey> Eh, that suddenly doesn't look as nice
14:51:26 <identity> using ix I get an instance error regarding Monoid. Namely 'a' in Map k a not being an instance of Monoid.
14:51:58 <identity> @ roboguy_
14:52:00 <roboguy_> identity: are you using it with ^.?
14:52:25 <dwcook> identity, the solution might be to add such a constraint to a
14:52:31 <dwcook> (Monoid a) => …
14:52:40 <pranz> Twey: exactly :P  I'll rather nest tails as long as there aren't more than 2
14:52:49 <roboguy_> identity: there's not really a way to get around the potential non-existence of a key (unless you have a Monoid)
14:52:54 <roboguy_> or use Maybe
14:52:54 <pranz> I'd*
14:53:08 <Twey> pranz: ((!! 0) &&& (!! 1)) has a pleasing symmetry
14:53:27 <identity> roboguy_: Yes. I'm doing something like: do { f <- use foo; return $ foo ^. bar . ix key ^. lensIntoKeyType; }
14:53:35 <identity> dwcook: 'a' isn't a monoid in this case.
14:53:45 <roboguy_> identity: you pretty much have to use Maybe
14:53:55 <identity> roboguy_: Ah, well.
14:53:57 <roboguy_> identity: like with ^?
14:54:00 <joelteon> Isn't there a make-ish tool written in Haskell?
14:54:05 <pranz> Twey: mm that's more convincing
14:54:06 <joelteon> oh, shake
14:56:54 <pranz> hmm, I would almost like a unary version of flip
14:57:00 <pranz> but it would probably do more harm than good
14:57:13 <Twey> pranz: We have a unary version of flip
14:57:15 <Twey> It's flip
14:57:31 <roboguy_> pranz: what do you mean?
14:57:58 <pranz> I mean like a prefix symbol or something
14:57:59 * hackagebot HaskellNet-SSL 0.2.2 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.2 (DanielWright)
14:58:04 <Twey> flip ∷ (a → b → c) → (b → a → c)
14:58:09 <pranz> like `f = flip f
14:58:15 <Twey> Oh
14:58:30 <Twey> I'd probably go all the way and have Clojure-style numbered holes
14:58:57 <Twey> flip f = (f %2 %1)
14:58:58 <identity> roboguy_: So what do I need to apply a lens into a Maybe, like with: do { f <- use foo; return $ foo ^. bar . at key ?? lensIntoKeyType; }
14:59:41 <roboguy_> identity: hmm, I'm not totally sure what you mean
14:59:44 <roboguy_> :t (^?)
14:59:45 <lambdabot> s -> Getting (First a) s a -> Maybe a
14:59:53 <roboguy_> identity: ^ something like that?
15:00:53 <identity> I'm not really sure, that type signature means little to me apart from the fact it returns a Maybe. What I mean is that the key type contains a Double in my concrete case. so after doing .. at key, I'd like to return "Maybe Double"
15:01:47 <identity> myMap . at key -- returns Maybe KeyType. KeyType contains a double. myMap . at key ?? getDouble
15:01:51 <roboguy_> > M.fromList [(1, "a"), (2, "b")] ^. at 1
15:01:53 <lambdabot>  Just "a"
15:02:28 <identity> > M.fromList [(1, (3, 4))] ^. at 1 ^. _1
15:02:29 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field1
15:02:29 <lambdabot>                      (Data.Maybe.Maybe
15:02:30 <lambdabot>                         (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
15:02:30 <lambdabot>                      (Data.Maybe.Maybe
15:02:30 <lambdabot>                         (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
15:02:35 <identity> basically something like that.
15:02:57 <edwardk_> > M.fromList [(1, (3,4))] ^? ix 1._1
15:02:59 <lambdabot>  Just 3
15:03:05 <edwardk_> > M.fromList [(1, (3,4))] ^? at 1.traverse._1
15:03:07 <lambdabot>  Just 3
15:03:10 <tomejaguar> What's the relationship between HM and System F?  Are the HM expressions a subset of the System F expressions?
15:03:14 <identity> .. and the wizard himself appears!
15:03:48 <edwardk_> pay no attention to the man behind the curtain
15:04:06 <merijn> tomejaguar: Hindley-Milner is a type inference algorithm, System F a typed lambda calculus variation
15:04:07 <dwcook> Curtain? Is that a categorical structure I don't know about?
15:04:34 <Saizan> tomejaguar: well, let's say you can turn an HM expression into an equivalent System F one after you're done with type inference
15:04:35 <identity> edwardk_: That did the trick! thanks for the help roboguy_ & edwardk_. I'm sure I'll grasp lens at some ponint.
15:04:40 <merijn> tomejaguar: i.e. they have no relation other than "HM can be applied to System F and some variations to do type inference", afaik
15:05:05 <Saizan> tomejaguar: because in System F polymorphism is more explicit, and also less restricted
15:06:55 <tomejaguar> HM is also a lambda calculus isn't it?
15:07:07 <tomejaguar> It's not *just* an algorithm.
15:07:57 <identity> edwardk_: Given that I have a few functions that basically all lens all the way into the inner map like in the previous example, I would like to construct a general lens to get me there and then pass lenses to that lens -- I can do this, but the type signature is crazy. Wasn't there something wrt more specific type signatures looking better, or something? It's very general, the resulting type signature that ghci tells me
15:08:00 * hackagebot logict 0.6.0.2 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.6.0.2 (DanDoel)
15:08:27 <Saizan> tomejaguar, merijn: the algorithm is defined on a specific calculus
15:08:44 <Saizan> which is STLC + let
15:09:00 <roboguy_> identity: well, there are type synonyms that can make things look nicer like Lens, Traversal and Prism
15:09:08 <roboguy_> what sort of signature is it giving you?
15:09:11 <shachaf> Saizan: Does STLC have polymorphism?
15:09:33 <copumpkin> no
15:09:43 <Saizan> shachaf: nope, i was going to add that :)
15:09:51 <tomejaguar> In STLC you don't make the polymorphism explicit, but I guess the type system can determine some terms to be polymorphic.
15:09:54 <Saizan> shachaf: but i guess "let" could include it
15:10:17 <copumpkin> tomejaguar: how so?
15:10:31 <shachaf> Saizan: What do you mean?
15:10:32 <copumpkin> it can't even describe polymorphic types
15:10:54 <Saizan> shachaf: i mean when i say "let" you could read into it also its typing rule
15:11:00 <copumpkin> I made a super simple model of a polymorphic typed syntax in agda a while ago
15:11:07 <copumpkin> others have probably done it better
15:11:39 <identity> roboguy_: forall (m :: * -> *) a. MonadState MyOuterState m => ((a -> Const (First a) a) -> MyMapValueType -> Const (First a) MyMapValueType) -> MyMapKeyType -> m (Maybe a)
15:12:16 <L8D> Does Data.Set have syntactic sugar yet?
15:12:20 <tomejaguar> copumpkin: In STLC you can write the expression '\x -> x'
15:12:28 <copumpkin> sure
15:13:02 <tomejaguar> And HM will deduce a polymorphic type.
15:13:10 <roboguy_> identity: is this function supposed to act as a general lens into a property (i.e. a getter and setter)?
15:13:17 <copumpkin> why call it STLC though?
15:13:19 <copumpkin> if it isn't STLC
15:13:19 <roboguy_> or field, I should say
15:13:35 <tomejaguar> Oh I didn't, Saizan did.  But I guess you could say that the terms of HM are the terms of STLC.
15:13:39 <Saizan> tomejaguar: but that type won't be a valid STLC type
15:13:43 <identity> roboguy_: Yes -- it would be very useful to have it both as a getter and a setter.
15:13:46 <tomejaguar> Saizan: Agreed.
15:13:59 <Saizan> tomejaguar: i meant thevolt a°_°
15:14:04 <Saizan> sorry
15:14:09 <roboguy_> identity: I suspect that there is something restricting that from happening in the definition, but I'm not an expert on lens signatures
15:14:11 <tomejaguar> But the term language may be the same even if the type system differs.
15:14:11 <Saizan> anyhow, i think we are in agreement here
15:14:13 <dpwright> I've been getting into using (<$>) quite a bit recently to make working with things like Maybe values look nicer
15:14:25 <copumpkin> https://gist.github.com/copumpkin/6458462
15:14:30 <roboguy_> identity: are you composing lenses with something other than .?
15:14:37 <tomejaguar> I can't be in agreement with anyone, because I don't know anything.
15:14:43 <dpwright> but, even more recently, I've found myself wanting to do something similar within some other monad
15:14:52 <Saizan> tomejaguar: wrt terms you only need to add "let .. = .. in .."
15:14:53 <shachaf> tomejaguar: Just agree with monochrom, in that case.
15:15:16 <dpwright> so I'm in IO, or Reader, or whatever, but I have a maybe value, and I want to run a monadic function on it if it's Just a value and return Nothing if it's Nothing
15:15:16 <tomejaguar> Does monochrom also have an uninhabited set of knowledge?
15:15:27 <identity> roboguy_: My instinct, which is based on very, very, very little lens experience, is that if I made it more specific (E.g. my own monad stack instead of MonadState in general, etc) it would make it a bit less insane, but I don't really know.
15:15:31 <identity> tomejaguar: Yes, ^.
15:15:47 <dpwright> I don't know how to do that, so I end up just using a case statement, but I'm sure there must be a neater way
15:15:52 <dpwright> probably involving MaybeT?
15:16:07 <tomejaguar> Saizan: Whereas to get the expression language of System F you have to add what?
15:16:16 <dpwright> can anybody point me in the right direction?
15:16:34 <identity> do {f <- use foo; return $ bar ^. myMap ^? ix myKey . myInnermostLens; }
15:17:01 <dpwright> I guess what I'm essentially looking for is an fmap, where the function is monadic
15:17:12 <d3lxa> have anyone already used .>>=. :: m a -> (a -> q (m b)) -> q (m b)  or am I becoming insane? urgh
15:17:16 <Saizan> tomejaguar: type abstraction adn application
15:17:32 <roboguy_> identity: hmm, maybe you should start by ignoring the State monad stuff and make a function that just accesses the fields outside of all that
15:17:36 <roboguy_> then use that in the other funciton
15:17:38 <roboguy_> *function
15:17:42 <copumpkin> tomejaguar: my link has a simple/simplistic model of it, I think
15:18:18 <tomejaguar> Saizan: But that's to the type language, not the expression language, isn't it?
15:18:27 <roboguy_> identity: what if you had something like myLens myKey = ix myKey . myInnermostLens
15:18:35 <Saizan> tomejaguar: it's to the expression language
15:19:13 <tomejaguar> companion_cube: Does agda have the .hs suffix?
15:19:15 <Algebr> Hi, I have a silly question, but why don't have I have to declare types
15:19:36 <Algebr> I have to*
15:19:38 <Saizan> tomejaguar: e.g. the polymorphic identity function is written "/\ (a : *). \ (x : a) -> a" where /\ is supposed to be a capital lambda
15:19:54 <dpwright> hmm, just hoogled "(a -> m b) -> f a -> m (f b)" and mapM from Data.Traversable came up... looks promising, maybe I'll try that
15:19:54 <roboguy_> Algebr: Haskell has type inference
15:20:17 <copumpkin> tomejaguar: no, but github doesn't highlight .agda
15:20:21 <copumpkin> so I lie and make it .hs
15:20:30 <roboguy_> Algebr: so the compiler (or interpreter, if you're using one) can figure out the types of things (usually) when it compiles things
15:20:31 <Algebr> roboguy_: But if it has type inference, why do function declarations at all?
15:20:34 <companion_cube> tomejaguar: no idea?
15:20:45 <copumpkin> you can see the polymorphic identity function in there near the bottom
15:20:45 <identity> roboguy_: It looks a little bit less scary, but still not something I'd be using in my code.
15:20:46 <roboguy_> Algebr: it makes things way, way nicer to have type declarations at the top level
15:20:57 <roboguy_> identity: ?
15:21:02 <identity> roboguy_: I'll figure this out later, but thanks for your help. I'd rather write the implementation than focus on the details
15:21:06 <tomejaguar> Saizan: Ah right, I see.  Then specialization is given by type application?
15:21:18 <roboguy_> Algebr: if you make a type error somewhere, it can be very hard to find if you don't write out what you *expect* the types to be
15:21:40 <Saizan> tomejaguar: yeah, you write stuff like "id [Int] 5"
15:22:00 <Saizan> [..] is syntax
15:22:11 <tomejaguar> Oh, not a list :) I was wondering ...
15:22:16 <Algebr> roboguy_: Much appreciated, while I have your ear, Haskell doesn't realy have variables then right, like say x = "dogs", that's really a function that takes no arguments and returns the string "dogs"?
15:22:38 <roboguy_> Algebr: it's not a function, but it also can't be changed
15:22:41 <tomejaguar> OK that makes sense to me, thanks.
15:22:44 <shachaf> tomejaguar: It's just like Core!
15:22:57 <tomejaguar> shachaf: True.  Multicolored core no less.
15:23:31 <Algebr> roboguy_: if not a function then what 'is' it? Like to me, it looks like doing in Python something like def x():return "dogs"
15:23:32 <tomejaguar> Now my set of knowledge is inhabited but contractible.
15:23:49 <roboguy_> Algebr: it binds x to the value "dogs"
15:24:05 <pranz> Algebr: everything in hask is values, not functions
15:24:12 <pranz> Algebr: the thing is that functions are also values
15:24:51 <roboguy_> Algebr: this goes into more detail about this http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:25:09 <Algebr> roboguy_:wow, blowing my mind, reading link, thank you!
15:25:48 <roboguy_> Algebr: eventually, it will be good to learn about thunks too which is sort of a related concept
15:25:53 <tomejaguar> Algebr: It is the binding of the name x to the value "dogs"
15:25:54 <pranz> Algebr: you do type signatures as a way to proof your program, and to make polymorphic functions be type-specific'
15:26:25 <pranz> a = mempty :: [a] for example, means a = []
15:26:41 <merijn> Algebr: Haskell has variables, but like variables in math they are just "names" for a value, rather than a box with a value inside
15:27:06 <merijn> Algebr: C and python have the "box with a value inside" type variables, hence why they can be changed (by changing the value in the box)
15:27:25 <roboguy_> merijn: aren't variables of math really more like functions though?
15:27:56 <merijn> Algebr: In haskell what you're doing when you say 'x = "dogs"' is stating "from now on, the name 'x' shall refer to the value "dogs""
15:28:14 <pranz> ^ is the best explanation
15:28:20 <pranz> you associate a name to a value
15:28:21 <Sagi> Does it make sense to make Identity an instance of MonadIO?
15:28:33 <merijn> roboguy_: No, take for example "f(x) = x" here 'x' is a variable, because on every invocation of 'f' the 'x' will have a different value
15:28:33 <Sagi> it seems to solve my problem, but at the same time, it does not make sense at all.
15:28:44 <roboguy_> merijn: good point
15:28:50 <merijn> roboguy_: i.e. the value of 'x' "varies" between invocations (hence why it's called a variable)
15:28:57 <roboguy_> right
15:29:01 <merijn> s/invocations/applications
15:29:11 <augur> hm. i think i should put my lens tutorial up somewhere
15:29:23 <augur> any suggestions?
15:29:31 <tomejaguar> Sagi: How do you define 'liftIO :: IO a -> Identity a'?
15:29:55 <pranz> augur: github pages
15:29:57 <roboguy_> augur: do you have a github? I think github lets you put up webpages
15:30:05 <Algebr> merijn, roboguy_: Thank you, had to reread a few times.
15:30:17 <Sagi> tomejaguar: well, I don't, which gives a big fat warning. Perhaps I should explain how I manouvered myself there in the first place.
15:30:29 <augur> pranz, roboguy_: i meant more some sort of semi-official place
15:30:42 <tomejaguar> Sagi: OK ... but this seems very unlikely to work ..
15:30:49 <augur> oh hey, Cale, are we gonna write that book full of goodies? :)
15:30:51 <roboguy_> augur: maybe school of haskell on fpcomplete?
15:31:00 <augur> roboguy_: hmm.. thats probably a good choice
15:31:20 <Sagi> tomejaguar: I need a function of type IO (MyReader Int) and I cannot seem to make that work. Let me paste that.
15:31:45 <Algebr> merijn, roboguy_: A somewhat philosophical question, but regarding side-effects. Printing is considering a side effect, but is it a side effect because haskell has to pass off some state change to an outside party? Say we had an OS written in haskell, wouldn't then printing to the screen just be a matter of calling a function?
15:32:16 <merijn> Algebr: It has a side effect because doing it once is different from doing it twice
15:32:16 <DMcGill> Algebr: consider the presence of parallelism or 'retry'
15:32:44 <pranz> Algebr: printing requires modifying the memory in some way
15:32:51 <merijn> Algebr: "1 + 1" I can do a billion times and get the same result and the outside world would be none the wise
15:33:00 <DMcGill> pranz: that's hardly reserved for printing!
15:33:15 <mellum> is there some shortcut for \m -> match m with Nothing -> [x] | Just l -> x : l
15:33:24 <pranz> DMcGill: hmm yeah that was a poor explanation :P
15:33:42 <Algebr> merjin: why is it different from doing it twice? Python: print "hello" yields same result as print "hello"
15:33:44 <Sagi> tomejaguar: http://lpaste.net/99713
15:34:09 <roboguy_> Algebr: print "hello";print "hello" is different than print "hello"
15:34:11 <DMcGill> mellum: [x] ++ listToMaybe m
15:34:24 <Sagi> tomejaguar: so my goal is not to get a monadIO instance, my goal is to make that function work :-)
15:34:51 <DMcGill> mellum: sorry I mean [x] ++ maybeToList m
15:35:00 <Algebr> roboguy_: feeling dumb, but not seeing the difference, is it difference because the state of stdout, probably some terminal, is different at the beginning of the first print statement when compared to the second one?
15:35:03 <wavewave> hi
15:35:04 <roboguy_> Algebr: and yet the return value of the function is the asme
15:35:06 <roboguy_> *same
15:35:11 <roboguy_> Algebr: yeah
15:35:13 <byorgey> Sagi: you appear to be trying to use  liftIO to turn an IO action into an NMLReader action
15:35:14 <Platz> Algebr: the letters the second time happened to be the same, but it surfaced on a different spot on your screen, at a different point in time
15:35:24 <byorgey> Sagi: this cannot work since NMLReader does not have IO in it
15:35:33 <wavewave> question on new cabal (1.18): How can I disable redirection of log?
15:35:37 <tomejaguar> Sagi: And this actually works?
15:35:55 <wavewave> I want to have the same behavior as previous one (<= 1.16.xx).
15:36:18 <dpwright> Data.Traversable.traverse is what I wanted (the action didn't actually need to be monadic).  Mapped it to (<<$>>).
15:36:46 <Sagi> tomejaguar: it compiles. I'm pretty sure it doesn't work. But it confused me enough to ask here. byorgey's explanation helps though. I now understand why this won't work (in addition to why I don't want it in the first place).
15:37:12 <tomejaguar> Sagi: Have you tried running it?  That's normally a good thing to try!
15:37:18 <DMcGill> Sagi:
15:37:29 <DMcGill> " I now understand why this won't work (in addition to why I don't want it in the first place)." : #haskell hard at work!
15:37:38 <Sagi> :-)
15:37:48 <Sagi> I always have that experience around here, it's wonderful.
15:37:55 <tomejaguar> Sagi: If I were you I'd make a monad transformer called 'NMLReaderT' and then apply it to IO
15:37:56 <augur> http://www.reddit.com/r/haskell/comments/1xh0as/inventing_lenses_a_lens_tutorial/ at any rate
15:38:05 <tomejaguar> Or just put IO at the bottom of your stack
15:38:11 <roboguy_> Algebr: a function without side effects does not change anything other than it's return value
15:38:21 <khyperia> Oh hey I read my first lens tutorial today, let's blow my mind some more. *clinks augur's link*
15:38:22 <roboguy_> also, given the same input it must return the same value
15:38:40 <roboguy_> khyperia: lens is pretty cool
15:38:46 <Sagi> hmm, how would I go about defining this transformer?
15:39:14 <Sagi> tomejaguar: I'm pretty sure I don't want IO at the bottom, because I have written almost a thousand lines of code without needing it, better keer it pure.
15:39:22 <Sagi> keep*
15:39:26 <byorgey> Sagi: NMLReaderT m a = NMLReaderT { ... replace Identity with m ... }
15:39:33 <roboguy_> Algebr: if a function changes something outside of it's return value, that is considered a side effect
15:39:44 <Algebr> roboguy_:But if functions are values, then function values are indeterminate until being called right? Say double x = x + x, until double get's an argument, what is it's value? Seems like Haskell would be useless/broken without lazy evaludation.
15:39:44 <byorgey> Sagi: then  you can define  NMLReader a = NMLReaderT Identity a
15:39:53 <Sagi> oh, that makes sense too!
15:40:15 <byorgey> Sagi: I don't know if that's necessarily what you want.  I think you need to think carefully about what getMinSpeed is supposed to do.  It seems confused.
15:40:28 <roboguy_> Algebr: I'm not sure I understand... what's the question?
15:40:48 <byorgey> i.e. I can't even infer what it is *supposed* to do, much less how you could get it to work
15:41:02 <Algebr> roboguy_: Question: If functions are values, what is the value of double x = x + x before double is called?
15:41:09 <tomejaguar> Sagi: Then make it a transformer.
15:41:16 <roboguy_> Algebr: it's a function value, the same as in python
15:41:30 <mellum> http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Strict.html#v:alter why is this O(log n), shouldn't it be O(min(n, W)) like all the others?
15:41:39 <tomejaguar> Sagi: newtype NMLReaderT m a = NMLReader { unwrapNMLReader :: ReaderT NMLData (WriterT PropCheckLog m) a}
15:42:07 <tomejaguar> Oh byorgey already said it.
15:42:09 <Sagi> hmm
15:42:41 <roboguy_> Algebr: I'm not sure I see how that relates to side effects though
15:43:07 <Algebr> roboguy_:Sorry, question just came to mind tangentially. I'm good about side effects now.
15:43:12 <roboguy_> ahh, ok
15:43:36 <Sagi> perhaps the problem starts at getMinSpeed. Basically, I want to look up a property of NetworkObject using NMLReader, namely its speed and exit the program when it doesn't have one, because that means the user didn't select the proper input.
15:43:52 <pranz> Algebr: the value of what exactly? the value of double?
15:43:53 <Sagi> It felt as if I wanted a function with :: IO (NMLReader Int)
15:44:09 <tomejaguar> Sagi: Well you can have that without liftIO.
15:44:12 <roboguy_> Algebr: being a value really just means we can do things like bind things to it and pass it to functions
15:44:38 <roboguy_> which is actually really useful
15:44:39 <Algebr> pranz:yes, value of double before it is called.
15:45:00 <Sagi> tomejaguar: I was having trouble with the first argument to >>= needing to be of type IO
15:45:02 <roboguy_> Algebr: it is the same as after it is called
15:45:21 <pranz> Algebr: the value of double is (\x -> x + x), and that remains however often you call it
15:45:44 <Sagi> It seems I can either unwrap NMLReader and not have IO, or the other way around. :-\
15:45:56 <tomejaguar> Oh I see the Maybe is inside the NMLReader
15:46:00 <byorgey> mellum: I'm not sure, I think you might pay for the extra generality.  Note the others are not actually implemented in terms of alter.
15:46:05 <tomejaguar> So I guess you can't.
15:46:05 <Sagi> tomejaguar: yes
15:46:28 <tomejaguar> Anyway, I can't suggest anything because I don't know what your is for.
15:46:55 <Sagi> There should be some way to convert Nothing to an errormessage + exit, right?
15:46:58 <tomejaguar> But have a think if you want NMLReader actions interleaved with IO actions.  If so, you need a transformer.
15:47:30 <Sagi> but making NMLReader into a transformer means that I get to rewrite large parts of my library, right :-\
15:47:34 <tomejaguar> Sagi: The quick and dirty way would be to make it a transformer, I think.
15:48:13 <tomejaguar> Sagi: No, just define the transformer as above, and define 'type NMLReader = NMLReader Identity a'.  Then everything stays the same.
15:49:00 <tomejaguar> Saizan: If you're still around, would it be fair to say that the expressions of HM are actually expressions of the *un*typed lambda calculus?
15:50:01 <Sagi> tomejaguar: ah, I got distraced by all the errors about the changed Data Constructor.
15:50:07 <Saizan> tomejaguar: the untyped LC doesn't have let..
15:50:31 <tomejaguar> Saizan: Ah right, untyped LC + let.
15:50:36 <Sagi> tomejaguar, byorgey: thank you both for you help, I'll dive in with the transformer solution and see if that gets me anywhere!
15:50:47 <tomejaguar> Sagi: You're welcome, good luck.
15:56:24 <Iceland_jack> Are there any optimization that attempt to improve functions traversing a data structure more than once, keeping it in memory like 'sum xs / genericLength xs'?
15:57:24 <Algebr> ALL - Is there anything that I can get quick reference for a function? Again python example, help(map). I can't fully comprehend :t foldl yet, and hoogle foldl doesn't help either? Does such a utility exist in the Haskell land?
15:57:33 <identity> Algebr: Hoogle
15:57:43 <identity> Algebr: Or :info function or :t function (in ghci)
15:57:44 <dwcook> Algebr, Hackage
15:57:51 <identity> @info map
15:57:51 <lambdabot> map
15:57:52 <dwcook> which Hoogle will link you to
15:57:59 <Iceland_jack> Algebr: You can find it on Hackage
15:57:59 <identity> well, never mind lambdabot. she sucks.
15:58:00 <dwcook> @hackage Data.List
15:58:00 <lambdabot> http://hackage.haskell.org/package/Data.List
15:58:01 <roboguy_> Iceland_jack: have you read this? http://squing.blogspot.com/2008/11/beautiful-folding.html
15:58:05 <tomejaguar> Iceland_jack: Are you asking for an optimization that *does* keep it in memory, or one that doesn't?
15:58:16 <dwcook> Well, that didn't go as planned.
15:58:20 <Iceland_jack> tomejaguar: One that doesn't :)
15:58:45 <roboguy_> Algebr: foldl is basically the same as reduce in python
15:59:01 <tomejaguar> Iceland_jack: Then roboguy_'s link, and http://www.haskellforall.com/2013/08/composable-streaming-folds.html
15:59:06 <dwcook> Algebr, http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#g:3
15:59:12 <Algebr> Thanks!
15:59:16 <Iceland_jack> roboguy_: I have seen that actually, I was wondering if there is some effort for the compiler to perform that work
15:59:39 <Algebr> dwcook: How can I access hackage off line, like a man page or something
15:59:59 <roboguy_> Iceland_jack: I suspect that that would not be possible in general but I'm not sure
16:00:29 <Iceland_jack> I suspect as much but it would be interesting :) that's why I'm asking
16:00:32 <dwcook> Algebr, I've never done so, but you can build docs locally for a given package using cabal, I believe
16:00:36 <identity> Algebr: You should consider doing "cabal install hoogle".
16:00:48 <identity> Algebr: You can also set up commands inside ghci to search hoogle easily
16:00:49 <roboguy_> Algebr: I think haskell platform comes with an offline copy of the base docs
16:01:32 <Algebr> identity: I have hoogle installed, but doing hoogle foldl doesnt give like descriptions, just where foldl is used, I take it.
16:01:42 <identity> Algebr: try hoogle --info foldr
16:02:01 <tomejaguar> Iceland_jack: Well if you know that sum and generic length are both folds then you can theoretically rewrite them as such and then use some fusion rule for folds.
16:02:05 <Algebr> identity: Yes! Awesome, thanks!!
16:02:13 <BMeph> identity: The issue here, is that to find the xs in common, you have to go down two function applications: first the '/', and then the respective sum or length.
16:02:20 <roboguy_> identity: huh, I didn't know about --info
16:02:42 <Iceland_jack> I assume that was for me BMeph
16:02:49 <tomejaguar> I assume so too.
16:03:05 <BMeph> Ah, yes; sorry, I Fail at tab completion. :)
16:03:23 <tomejaguar> Anyway, personally I'm not a fan of optimizing stuff which has a trivial by-hand optimization.
16:03:36 <BMeph> identity: Sorry, I mean that last for Iceland_jack, not you. :)
16:03:39 <identity> Algebr: Here's my .ghci with hoogle doc and hoogle commands. https://github.com/saevarb/dotfiles/blob/master/home/.ghci#L10
16:03:41 <Iceland_jack> I was rereading Wadler's paper on deforestation and he brings 'sum xs/length xs' up so I thought I'd ask
16:03:41 <tomejaguar> I'm not sure if there's a larger scale use case for this.
16:03:45 <identity> BMeph: No worries. :)
16:04:00 <identity> roboguy_: It came as a surprise for me when I saw it somewhere as well
16:04:06 <tomejaguar> Iceland_jack: Interesting, I did not know he mentioned that.
16:04:19 <Iceland_jack> He just mentioned it to say that it doesn't apply to it!
16:04:20 <Algebr> identity: Nice, so its just like an .rc file
16:04:29 <tomejaguar> Iceland_jack: Ah!
16:04:58 <identity> Algebr: What you put in .ghci is simply executed at startup.
16:05:00 <tomejaguar> G'Night all.
16:05:05 <Iceland_jack> tomejaguar: It depends on what you call ‘trivial’, stream fusion can be ‘trivially’ implemented by the user but that's not what you'd want to do
16:05:15 <Iceland_jack> thanks for the answers :)
16:12:38 <roboguy_> hmm, should "hoogle data" take a really long time?
16:15:18 <Algebr> ALL - Last annoying question, is there any difference to using print/putStrLn/show in ghci? Which one can work from within a source file that will be compiled?
16:16:08 <roboguy_> Algebr: I'm not sure what you mean by the last sentence, but they all have different types
16:16:13 <roboguy_> so they do different things
16:16:14 <khyperia> Algebr, they all do different things. Check the type signatures.
16:16:33 <Algebr> roboguy_: I mean in my .hs file, I want to print something
16:16:58 <roboguy_> Algebr: they are all in the haskell prelude so they all can work in an hs file. they do different things though
16:18:02 <Iceland_jack> @srt print
16:18:02 <lambdabot> print x = putStrLn (show x)
16:18:03 <khyperia> show = take a "thing" and turn it int a string, putStrLn = take a string and dump it to stdout, print = putStrLn . show
16:18:32 <Iceland_jack> so
16:18:32 <Iceland_jack>     print 5
16:18:32 <Iceland_jack> is
16:18:32 <Iceland_jack>     putStrLn (show 5)
16:18:35 <dwcook> Algebr, ghci, possibly confusingly, will execute IO actions *and* display pure values
16:18:35 <Iceland_jack>     putStrLn "5"
16:18:56 <dwcook> That might be why you're lumping them together – but in fact, putStrLn and print both result in IO actions while show results in a String
16:19:47 <roboguy_> putStrLn takes a String, print takes anything that can be printed
16:19:54 <roboguy_> *show'ed
16:20:07 <roboguy_> > putStrLn 1
16:20:09 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
16:20:09 <lambdabot>    arising from the literal `1'
16:20:09 <lambdabot>  Possible fix:
16:20:09 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Base.String)
16:20:12 <roboguy_> > print 1
16:20:13 <lambdabot>  <IO ()>
16:20:27 <roboguy_> pretend lambdabot said 1
16:21:41 <Iceland_jack> dwcook: That's the same as most interpreters though, ipython does differentiate between values and output
16:21:41 <Iceland_jack>     In [1]: 'hi'
16:21:41 <Iceland_jack>     Out[1]: 'hi'
16:21:41 <Iceland_jack>     In [2]: print 'hi'
16:21:44 <identity> Gah. Lens has my brain in knots.
16:21:44 <Iceland_jack>     hi
16:21:48 <Iceland_jack>  
16:22:07 <identity> How would I just modify a Maybe using lens?
16:22:16 <dwcook> I wonder if lambdabot can take advantage of that pure IO someone made a bit ago
16:22:30 <roboguy_> > Just 1 & _Just .~ 10
16:22:31 <lambdabot>  Just 10
16:22:36 <roboguy_> > Nothing & _Just .~ 10
16:22:37 <lambdabot>  Nothing
16:22:39 <roboguy_> ^ identity
16:22:40 <identity> Ah.
16:23:08 <khyperia> What does & mean?
16:23:09 * hackagebot parsergen 0.2.0.6 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.6 (JohnLato)
16:23:23 <roboguy_> khyperia: flip ($)
16:23:28 <roboguy_> :t (&)
16:23:28 <lambdabot> a -> (a -> b) -> b
16:23:30 <roboguy_> :t ($)
16:23:31 <lambdabot> (a -> b) -> a -> b
16:23:41 <khyperia> Ah. Dunno why I didn't know that, that's kinda basic
16:23:50 <roboguy_> khyperia: well, it's part of lens not Prelude
16:23:54 <khyperia> ahh
16:24:46 <roboguy_> it's pretty handy for lens. it's nicer than writing:
16:24:56 <roboguy_> > (_Just .~ 10) (Just 1)
16:24:57 <lambdabot>  Just 10
16:27:24 <dwcook> @type (.~)
16:27:25 <lambdabot> ASetter s t a b -> b -> s -> t
16:27:32 <dwcook> Well that explains everything.
16:28:10 <milfjord> stabby stab
16:28:31 <dwcook> type ASetter s t a b = (a -> Identity b) -> s -> Identity t -- o_0
16:28:37 <dwcook> Why is Identity necessary there?
16:28:39 <milfjord> :t _Just
16:28:40 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
16:28:59 <milfjord> :t (.~) `asAppliedTo` _Just
16:29:00 <lambdabot> ASetter (Maybe a) (Maybe b) a b -> b -> Maybe a -> Maybe b
16:29:39 <triliyn> dwcook: it is needed so that it fits with certain other lens types which use an arbitrary functor in place of the Identity
16:29:48 <triliyn> So this way it unifies with those more general types
16:29:48 <dwcook> Oh, neat.
16:30:47 <Aetherspawn> type holes in function types would be really cool
16:33:55 <kristof> bitemyapp: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html this is terrifying and I'm not comfortable with it at all
16:34:27 <Fuuzetsu> Aetherspawn: They would and it has been discussed a bit before but what can you do. Personally I defined ‘data Hole’ and then put down Hole anywhere I want GHC to complain.
16:34:28 <shachaf> Then you should probably not do it.
16:34:39 <shachaf> There's a program which does that transformation for you.
16:34:40 <edwardk_> Aetherspawn: yeah
16:35:19 <roboguy_> dwcook: a getter uses Const I believe
16:35:51 <kristof> shachaf: Do you find value-level classes better than typeclasses?
16:36:11 <shachaf> Does "value-level classes" mean something other than "values"?
16:36:27 <kristof> shachaf: I just mean doing the kind of typeclass transformation he does.
16:36:30 <roboguy_> shachaf: I think he means passing the "class dictionary" manually
16:36:34 <kristof> So no, just "values".
16:36:43 <davidfstr> I have encountered the following non-standard syntax in a Markdown document that is intended to be rendered via pandoc. Anyone know what it is: $$\frac{}{\mathtt{zero}\ \textbf{even}}{\rm Z\scriptsize ERO}$$
16:37:29 <dwcook> davidfstr, LaTeX, probably
16:37:41 <roboguy_> kristof: I don't think you get very much benefit of what that article is describing for some type classes like Functor. lens wouldn't really work very well either if it didn't use any type classes
16:37:56 <jonkri> Is there a function to go from a list of list to combinations, like so: [[1,2],[3,4]] -> [[1,4], [1,5], [1,6], [2,4]...] ?
16:38:07 <jonkri> Sorry.
16:38:17 <kristof> roboguy_: Ironically, he mentioned as a supporting example that Lens is a value type, not a typeclass (which wouldn't work)
16:38:20 <roboguy_> > sequence [[1,2],[3,4]]
16:38:20 * shachaf wonders where the 6 came from.
16:38:21 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
16:38:24 <roboguy_> ^ jonkri
16:38:26 <jonkri> Thanks.
16:38:57 <roboguy_> kristof: I mean using the "Functor f => (a -> f b) -> s -> f t" formulation of lenses
16:39:09 <kristof> roboguy_: But I also can't imagine stuff like Ord not being a typeclass
16:39:18 <kristof> roboguy_: right, I agree with you
16:39:31 <roboguy_> kristof: yeah, that article is a bit extremist. but type classes are definitely over-used sometimes
16:39:36 <jonkri> I didn't find it because it was in Control.Monad... :)
16:40:07 <edwardk_> jonkri: the Data.Traversable version is better
16:40:19 <roboguy_> edwardk_: yeah I was just thinking I should have used that one...
16:40:29 <roboguy_> > T.sequenceA [[1,2],[3,4]]
16:40:30 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
16:40:32 <dwcook> edwardk_, better in what sense?
16:40:58 <edwardk_> dwcook: more general, works over any traversable not just lists
16:41:09 <roboguy_> :t T.sequenceA
16:41:10 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
16:41:22 <roboguy_> works with any Applicative too
16:41:25 <edwardk_> sequenceA generalizes it further from monads to applicatives
16:41:33 <edwardk_> :t T.sequence
16:41:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:41:45 <edwardk_> :t Control.Monad.sequence
16:41:45 <lambdabot> Monad m => [m a] -> m [a]
16:42:27 <roboguy_> sequence doesn't really need to exist, does it?
16:42:41 <roboguy_> (if we assume AMP is in effect)
16:42:44 <edwardk_> once the AMP goes through it'll be an alias
16:43:12 * hackagebot HaskellNet-SSL 0.2.3 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.3 (DanielWright)
16:44:01 <dwcook> AMP?
16:44:12 <Iceland_jack> Applicative Monad proposal
16:44:18 <dwcook> Ah, yes.
16:44:21 <edwardk_> dwcook: 'applicative monad proposal' making applicative a superclass of monad
16:44:58 <edwardk_> the commit i plan to make to base the day after 7.8 really ships and the 7.9 branch starts
16:45:19 <Fuuzetsu> I can't wait for edwardk's monster commit to go all over base.
16:45:35 <khyperia> speaking of, when is that actually happening?
16:45:40 <khyperia> any estimation?
16:45:43 <Fuuzetsu> by the way edwardk_, 7.9 already started
16:45:44 <edwardk_> when 7.8 finishes up
16:45:59 <geekosaur> 7.8 is in rc, I would hope 7.9 is already branched
16:46:04 <geekosaur> (or vice versa really)
16:46:15 <edwardk_> Fuuzetsu: fair enough. hadn't looked to see how the 7.9 branch was being handled
16:46:34 <edwardk_> i'd like to see 7.8 truly shipped though, not just an rc
16:46:37 <Fuuzetsu> geekosaur: it was branched on the same day that 7.8 was branched, like a week ago? Maybe more now
16:46:56 <Fuuzetsu> well, there's still rc-2 coming AFAIK so it might be a couple more days
16:47:51 <geekosaur> I mean, as soon as 7.8 is in release engineering, any added patches to HEAD should be independent of it
16:48:07 <geekosaur> not sure 7.9 should be an actual branch
16:48:09 <edwardk_> but pretty much once there is a 7.8.1 official, the core libraries committee gets to wake up out of torpor an start doing things
16:48:24 <Fuuzetsu> well, not exactly considering you still need to cherry-pick changes onto 7.8 before the stable release
16:48:36 <edwardk_> geekosaur: i was trying to avoid complicating cherry picking for the meantime
16:49:11 <geekosaur> mmm. seems to me if you have that then you've kinda removed the point of a vcs with proper branch support
16:49:22 <edwardk_> geekosaur: as i just don't want anything _else_ bogging down the release of 7.8
16:49:25 <Fuuzetsu> edwardk_: how's the move going to look like? Are you going to put 7.8 as a dependency in all relevant cabal files?
16:49:51 <davidfstr> dwcook: Yep it was LaTeX. Thanks!
16:50:31 <Fuuzetsu> Oh, that doesn't matter I suppose as long as things depend on each other properly.
16:51:04 <edwardk_> well, there is a theoretical benefit to be had, but to be honest, i don't want to bog thoughtpolice down with thrashing, and that cutover is as good a time as any. yes, it is some 'unnecessary blocking', but it isn't like I'm starving for tasks ;)
16:51:30 <DrAwesomeClaws> so close, yet so far.  I'm attempting to glue together various code i've found online to make an irc bot which can post updates to an rss feed into the channel.  I have the feed data (in theory) coming from getFeedData :: FeedSource -> IO [FeedData]     I need to somehow take this IO [FeedData] and print it out to the channel.  I'm trying to do so around line 105 of the first file... but it seems to want [F
16:51:30 <DrAwesomeClaws> eedData] not IO [FeedData].
16:51:33 <dwcook> The proposal says it's not removing fail. So when *will* that get removed? :P
16:51:35 <DrAwesomeClaws> https://gist.github.com/anonymous/fa06b606240168c29f50
16:51:45 <jle`> who is in charge of the ghc progress? is it actual academic departments at glasgow?
16:51:55 <jle`> like professors and researchers at the university?
16:52:00 <DrAwesomeClaws> i've tried various combinations of mapM and map, even put liftIO in random spots, haha
16:52:09 <roboguy_> I'm sure you guys have heard this a lot lately, but is there an ETA on the official 7.8 release?
16:52:18 <Fuuzetsu> jle`: it's all the lovely people who sit down and write patches, there's no overlord governing it
16:52:39 <edwardk_> dwcook: spj has indicated to me that he's willing to listen to the core libraries committee on what happens to fail. so what needs to happen is somewhere on a 7.10 timetable, someone needs to come up with a proposal that doesn't suck, we can wire up warnings for it in 7.10 and make the change in 7.12
16:52:52 <dwcook> DrAwesomeClaws, use a do block or explicitly use (>>=)
16:52:55 <dwcook> @type (>>=)
16:52:56 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:53:10 <dwcook> edwardk_, \o/
16:53:13 * hackagebot generic-maybe 0.1.0.0 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.1.0.0 (JonathanFischoff)
16:53:15 * hackagebot generic-maybe 0.1.0.1 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.1.0.1 (JonathanFischoff)
16:53:30 <dwcook> DrAwesomeClaws, pretend instead of m it says IO
16:53:47 <jle`> DrAwesomeClaws: you can use guards at `eval` at line 72 :)  it's like a case switch sorta
16:53:47 <DrAwesomeClaws> thanks dwcook.  That gives me a thread to research
16:53:51 <edwardk_> dwcook: with 7.10  i'd really rather focus on making the changes we've already bit off since any MonadFail tweaks will require CPP hacks, etc. on the part of users and necessarily take them outside of haskell 98 compatibility further. so there is a standardization discussion to be had about how we proceed that goes beyond GHC
16:53:51 <dwcook> (>>=) :: IO a -> (a -> IO b) -> IO b
16:54:03 <edwardk_> and starts to look like a Haskell Prime issue
16:54:06 <edwardk_> dwcook: hence 'not soon'
16:54:20 <DrAwesomeClaws> jle`: thanks, I'm sure there's plenty that can be refactored in tehre, haha
16:54:34 <jle`> DrAwesomeClaws: just throwing it out there :)
16:54:35 <dwcook> edwardk_, yeah, I figured not. Does it tend to take a while to amend the language itself?
16:55:28 <jle`> DrAwesomeClaws: also, your forever is already in Prelude
16:55:29 <edwardk_> dwcook: never tried
16:55:34 <roboguy_> it's a little surprising to me that the design by committee thing has worked out so well for ghc
16:55:38 <edwardk_> dwcook: we're going to be learning as we go ;)
16:55:38 <jle`> or if not Prelude then Control.Monad
16:55:38 <roboguy_> and haskell in general
16:55:58 <edwardk_> roboguy_: there is an excellent overview of how that happened in the haskell retrospective
16:56:37 <roboguy_> edwardk_: you mean the "Being Lazy with Class" paper? I haven't gotten around to reading that yet, but I've heard it's good
16:56:54 <edwardk_> roboguy_: thats the one
16:57:05 <roboguy_> I like the subtitle quite a bit, haha
17:02:59 <jfischoff> how long does hackage documentation take to build these days?
17:03:07 <Martingale> Does `~ * s (Scalar u)` mean (Scalar u) has type s which has kind * ?
17:03:14 * hackagebot lvish 1.1.2 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.1.2 (RyanNewton)
17:03:47 <dagle> Why is it that when I join this channel, I figure out why it doesn't work. Thank you guys.
17:03:51 <Cale> Martingale: I suspect it does. GHC's pretty printer sometimes gets confused about type equality constrants.
17:04:11 <roboguy_> I wondered about that
17:04:16 <Martingale> Cale thx
17:04:16 <Cale> It should probably just say s ~ Scalar u
17:04:19 <geekosaur> rubber duck debugging at its finest!
17:06:59 <roboguy_> one thing I've been wondering... could nullary type classes be used to emulate a more advanced module system, like the one SML has?
17:08:14 * hackagebot png-file 0.0.1.0 - read/write png file  http://hackage.haskell.org/package/png-file-0.0.1.0 (YoshikuniJujo)
17:08:28 <dwcook> roboguy_, how did you have in mind?
17:10:46 <dwcook> I mean, it makes sense for them to be possible, inasmuch as it makes sense for relations between zero things to be possible
17:11:19 <roboguy_> dwcook: using a nullary type class to express the interface required and then making an instance to give them a specific definition
17:11:33 <dwcook> roboguy_, you mean a typeclass with no methods
17:11:52 <roboguy_> dwcook: I mean a typeclass with no arguments, i.e. class Example where ...
17:13:04 <jle`> joneshf-laptop: interesitng package you got there
17:13:15 * hackagebot png-file 0.0.1.1 - read/write png file  http://hackage.haskell.org/package/png-file-0.0.1.1 (YoshikuniJujo)
17:13:35 <joneshf-laptop> jle`, ?
17:13:39 <dwcook> roboguy_, I don't follow. An example maybe?
17:13:45 <jle`> oh sorry, wrong nick
17:13:56 <jle`> um
17:14:18 <jle`> does jonathan fischoff hang out here?
17:14:27 <dwcook> jle`, jfischoff
17:14:39 <jle`> jfischoff: interesting package you got there
17:14:45 <jle`> dwcook: thanks :)
17:15:34 <k00mi> roboguy_: translating ML's module system to haskell is possible: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
17:16:18 <Iceland_jack> roboguy_: So you're asking for a type class with no parameters?
17:16:25 <jfischoff> joe`: it was in response to this: https://twitter.com/hdgarrood/status/432345046982332416
17:16:43 <roboguy_> Iceland_jack: I don't know what you mean by "asking for one", but I'm wondering if you could use one to emulate SML-style modules
17:17:03 <jfischoff> jle`: autocorrect. I had thought it was possible, not sure if its that useful
17:17:35 <jle`> jfischoff: ah
17:17:42 <Iceland_jack> Well type classes must have 1+ parameters so the answer to that is a no, whether you can emulated it in other ways seems to be k00mi's answer
17:17:48 <jfischoff> the names all weird, I don't know. I'm gonna make the either one, it will be easier.
17:17:58 <jle`> jfischoff: it's an interesting concept though
17:18:02 <jfischoff> eyah
17:18:07 <jle`> i have a few maybelikes.
17:18:09 <jle`> hm
17:18:12 <jle`> is there a Bool-like?
17:18:26 <jle`> with generic not, any, all... ?
17:18:33 <jle`> would that be of any use
17:18:38 <jfischoff> that would be pretty easy
17:18:41 <Iceland_jack> You can check ticket #7642 if you're interested
17:18:41 <jfischoff> yeah I think so
17:18:46 <jle`> using generics?
17:18:54 <jle`> haven't dabbled in that area much.
17:19:09 <jfischoff> it's kind of a pain
17:19:16 <jle`> but i have so many types like data Filling = Filled | Unfilled
17:19:24 <jfischoff> you strip all the meta information away
17:19:47 <jle`> and make it...generic?
17:19:49 <jle`> :)
17:19:51 <jfischoff> jle`: that's what I was thinking, but its a little tricky, which should be false?
17:20:14 <roboguy_> Iceland_jack: hmm, I thought they were implemented recently
17:20:23 <jle`> jfischoff: it might depend on the ordering, to mirror Bool's Ord stuff
17:20:25 <jle`> but
17:20:31 <jfischoff> right
17:20:37 <jle`> yeah, it's not as obvious. boolean blindness
17:20:50 <jle`> but it'd be useful to have a generic not.
17:20:57 <jle`> but very marginally
17:21:00 <Iceland_jack> They're in 7.7 actually
17:21:09 <Iceland_jack> hm
17:21:12 <Iceland_jack> my bad
17:21:45 <jle`> alternatively you can just type Filling = Bool; filled = True; unfilled = False
17:21:53 <jle`> :|
17:22:17 <jle`> oh well. i'll be keeping an eye on this
17:22:23 <jle`> and for the Either version
17:24:14 <Cale> You can't solve boolean blindness by defining a type which is straightforwardly the same as Bool.
17:24:18 <jfischoff> cool
17:24:54 <Cale> Boolean blindness is the fact that when you case on a Bool, the branches of the case have the same type, and so can be swapped without causing a type error.
17:25:04 <jle`> Cale: i meant boolean blindness as in there is nothing inherently different about True and False
17:25:08 <jle`> oh yeah.
17:25:18 <jle`> and so it's a problem with making a generic Bool
17:25:26 <roboguy_> this might not be the best example, but this is sort of what I had in mind: http://lpaste.net/99717
17:25:30 <jle`> in that you can't really meaningfully define which is true-like and which is false-like
17:25:38 <Cale> i.e. whenever case b of False -> x; True -> y typechecks, then so does  case b of False -> y; True -> x
17:25:43 <jle`> the bool alias isn't mean to solve boolean blindness
17:28:00 <dagle> Earnestea: Is it ugly to depend on xdg-open?
17:35:06 <roboguy_> DrAwesomeClaws: forever already exists
17:35:29 <roboguy_> @src forever
17:35:29 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
17:35:43 <roboguy_> regardless of what lambdabot says
17:35:49 <DrAwesomeClaws> that's cool roboguy_, not the issue i'm having now though, haha.  that forever implementation is from haskell wiki, was following that
17:35:56 <Iceland_jack>     forever a = do
17:35:56 <Iceland_jack>         a
17:35:56 <Iceland_jack>         forever a
17:36:02 <dwcook> @let forever x = x >> forever x
17:36:03 <lambdabot>  .L.hs:145:18:
17:36:03 <lambdabot>      Ambiguous occurrence `forever'
17:36:03 <lambdabot>      It could refer to either `L.forever', defined at .L.hs:145:1
17:36:03 <lambdabot>                            or `Control.Monad.Writer.forever',
17:36:03 <lambdabot>                               imported from `Control.Monad.Writer' at .L.hs:5...
17:36:25 <Iceland_jack> <roboguy_> DrAwesomeClaws: forever already exists
17:36:25 <Iceland_jack> that's rather deep
17:36:31 <DrAwesomeClaws> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot  this still includes implementing forever.  But i'm glad it does, makes it more clear what's going on
17:36:45 <roboguy_> Iceland_jack: haha, yeah. that's why I wanted to say it
17:36:59 <dwcook> Oh, I bet @src draws from a different source from the things defined in lambdabot's interpreter
17:37:11 <Iceland_jack> @src is just a bloody mess
17:37:11 <lambdabot> Source not found. It can only be attributed to human error.
17:37:17 <Iceland_jack> (oops!)
17:37:46 <DrAwesomeClaws> basically i'm at a point that i think is common for those new at haskell.  I want a simple way to pull a value out of a monad, and have just read about why being able to do that would be a bad thing, haha
17:38:01 <Iceland_jack> I wouldn't mind :src and :hoogle being included in ghci by default, like it is in Clojure and (Python and Clojure) respectively
17:38:18 <Iceland_jack> DrAwesomeClaws: How would you pull a value out of a list?
17:38:22 <DMcGill> DrAwesomeClaws: be inside a do block and use <-
17:38:28 <dwcook> DrAwesomeClaws, instead of taking the value out, you put a function in
17:38:46 <DMcGill> which is the same as dwcook's answer
17:39:08 <Iceland_jack> @quote /bin/ls
17:39:08 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:39:30 <dwcook> That's basically what this type says
17:39:32 <dwcook> @type (>>=)
17:39:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:39:41 <DrAwesomeClaws> yeah, trying to do it in a do block with <- now... not having much success but i'm learning through lots and lots of failure, slowly
17:40:10 <Iceland_jack> DrAwesomeClaws: Here's an example of printing a single line of input in reverse
17:40:10 <Iceland_jack>     reverseInput = do
17:40:10 <Iceland_jack>       line <- getLine
17:40:10 <Iceland_jack>       putStrLn (reverse line)
17:40:43 <Iceland_jack> that <- part is 'drawing' the value out of getLine (that's a twisted way of thinking about it anyway)
17:41:17 <Iceland_jack> getLine will have type
17:41:17 <Iceland_jack>     getLine :: IO String
17:41:17 <Iceland_jack> and line will have type
17:41:17 <Iceland_jack>     line    ::    String
17:41:39 <Jesin> <iXeno> pyon: it only means that haskell is not fully functional - if the io monad really was consistent, then hClose h would leave h unchanged, and produce a closed h as a new value
17:41:41 <Jesin> D:
17:41:45 <Jesin> GUYS
17:41:47 <Jesin> is this true?
17:42:03 <Iceland_jack> Which is why you can write 'reverse line'
17:42:03 <Iceland_jack> @ty reverse :: String -> String
17:42:04 <lambdabot> String -> String
17:42:07 <dwcook> Jesin, that person misunderstands IO.
17:42:15 <Iceland_jack> dwcook: Who *doesn't*
17:42:17 <Iceland_jack> :)
17:42:27 <Jesin> :t hClose
17:42:28 <lambdabot> Not in scope: `hClose'
17:42:29 <DrAwesomeClaws> if i just try every permutation of code possible it'll compile eventually
17:42:31 <dwcook> Jesin, an IO value is a description of a computation. It doesn't, itself, do *anything*.
17:42:34 <kristof> Is there a good reason to store strings internally as lists of chars as opposed to arrays?
17:42:35 <Jesin> :t System.IO.hClose
17:42:36 <lambdabot> GHC.IO.Handle.Types.Handle -> IO ()
17:42:53 <Iceland_jack> kristof: Simplicity, certainly not efficiency
17:42:58 <Iceland_jack> that's what Text is for
17:43:04 <DMcGill> kristof: pattern matching too
17:43:15 <Jesin> dwcook: I know, but does "hClose" break that?
17:43:15 <dwcook> Jesin, the IO system takes such a value and executes it. Execution is allowed to be impure; it's evaluation, the computing of values, that is pure.
17:43:18 <kristof> Iceland_jack: I see. But arrays aren't tremendously complex, are they? :P
17:43:18 <DMcGill> and if you're just mapping over them then it doesn't really matter
17:43:19 * hackagebot markdown-pap 0.0.1.4 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.4 (YoshikuniJujo)
17:43:31 <dwcook> Jesin, no, hClose is a completely pure function.
17:43:41 <zrho> Jesin: hClose does not close a handle. It produces an action, of type IO (), which, when executed, closes the handle
17:43:45 <DMcGill> dynamically lengthed arrays are more complex yes
17:43:46 <Iceland_jack> kristof: If you look at the definition of Prelude/Data.List versus Data.Text and if you look at the history of Haskell then yes they are
17:43:47 <kristof> DMcGill: How do list representations help pattern matching? You'd think having constant time access to any substring is a lot better for matching on
17:43:57 <kristof> Iceland_jack: Ok, I trust you.
17:44:09 <Jesin> alright
17:44:10 <mm_freak> Jesin: given a handle you always get the same action:  the action that closes the handle
17:44:22 <DMcGill> kristof: `head (x:xs) = Just x; head [] = Nothing'
17:44:37 <Iceland_jack> kristof: Because you can do
17:44:37 <Iceland_jack>     foo []     = ...
17:44:37 <Iceland_jack>     foo (x:xs) = ...
17:44:37 <Iceland_jack> and have it work on both strings and lists without having to write two functions [a] → [a] and String → String
17:44:38 <mm_freak> @quote /bin/ls
17:44:38 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:44:48 <Jesin> mm_freak: alright, but if you have a global variable of type Handle
17:44:48 <DMcGill> kristof vs: `head arr = if null arr then Just (arr[0]) else Nothing
17:44:58 <dwcook> mm_freak, that quote is so popular :D
17:45:11 <Iceland_jack> That's certainly simpler, and with Data.Text you can't pattern match on the empty and non-empty case (without recent extensions)
17:45:20 <activez> Hi guys... I am developing a function that runs in the IO monad. The return type is now IO (Either String MyType). I am ending with a lot of nested if else statements. I know that I could do something with a monad transformer to mix both and have something like ifThisHappen $ Left "error bla bla bla" that would not continue to process the rest of the statements (like with maybe monad). But I am lost on how to do it. Any advice? thanks! :)
17:45:23 <Iceland_jack> You can use ViewPatterns, which are also extensions
17:45:38 <mm_freak> Jesin: how would you create such a value?
17:45:39 <kristof> Ah, I see.
17:45:40 <Iceland_jack> DrAwesomeClaws: You can do that *or* you can start small and work yourself up :)
17:45:50 <DMcGill> activez: ErrorT has this behaviour
17:46:08 <activez> DMcGill: Thanks! I will take a look
17:46:14 <DMcGill> activez: the docs have examples usage: http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Error.html#v:ErrorT
17:46:17 <Iceland_jack> DrAwesomeClaws: Do you for example understand the ‘reverseInput’ example?
17:46:30 <DrAwesomeClaws> Iceland_jack: yeah, i see what it's doing in that situation
17:47:22 <dwcook> Jesin, your thought is incomplete. But what's been said is true unconditionally.
17:47:32 <DMcGill> activez: mostly it's just to use `return' when you would have used Right and `throwError' when you would have used Left. Change the type sigs, add a catch function and you're done!
17:47:40 <Iceland_jack> DrAwesomeClaws: Could you define an action which prints the input string twice: once normally and then reversed?
17:48:37 <activez> DMcGill: Thanks! that makes sense
17:49:39 <dwcook> Jesin, do you understand in what sense hClose is pure?
17:49:58 <Jesin> my apologies
17:50:44 <dwcook> By the way, there are top-level bindings for Handles – stdin, stdout, and stderr
17:50:46 <DrAwesomeClaws> Iceland_jack: I don't see why not. But I'm kind of lost on the context here.
17:50:59 <Jesin> this appears correct, I do not have a proof that it does not break referential transparency but I also lack proof that it does
17:51:11 <Iceland_jack> DrAwesomeClaws: Can you elaborate on where you're lost?
17:51:30 <mm_freak> Jesin: just view IO as a language for imperative actions
17:51:50 <mm_freak> Jesin: then view the compiled program as an interpreter of that language
17:52:22 <Jesin> as an interpreter?
17:52:35 <DrAwesomeClaws> Iceland_jack: well, i get that i don't have the fundamental knowledge to be trying to do what i'm doing... but my brain is kind of stuck on my specific problem because I feel like i'm so close, haha    I'm sure I could write a function which takes a string and outputs it normal and reversed though
17:52:36 <Jesin> I was following you until "interpreter"
17:52:38 <dwcook> Jesin, okay, let's say you have a handle h. You can make a whole mess of applications of hClose h, and the result of each one will be identical – They are all *representations of computations that close a handle*. Nothing gets executed and thereby changed at this point.
17:52:44 <Iceland_jack> mm_freak: Personally that view wouldn't have helped me before I was familiar with IO
17:52:54 <dwcook> s/close a handle/close that handle/
17:52:56 <mm_freak> this has two advantages:  firstly you get I/O in a pure language without breaking purity, but a highly underrated advantage is that you get first class actions
17:53:06 <DrAwesomeClaws> i do appreciate the help Iceland_jack, just frustrated and terse right now.
17:53:16 <mm_freak> ever noticed that 'catch' is a regular library function in haskell? =)
17:53:33 <Jesin> :t catch
17:53:33 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
17:53:43 <Iceland_jack> DrAwesomeClaws: No problem, I can't do much to help if I don't have a clear sense of where you're stuck :)
17:54:07 <DMcGill> DrAwesomeClaws: if you paste some code (on lpaste or suchlike) we can give more specific pointers
17:54:13 <Jesin> I see
17:54:20 <Jesin> nice.
17:54:30 <mm_freak> Jesin: if you view IO as regular data, like bytecode, then you can picture the compiled program as two parts:  the bytecode and an interpreter for it
17:54:49 <mm_freak> of course that would be slow, so this isn't how it's actually implemented, but it is a good way to look at it
17:54:52 <DrAwesomeClaws> sec, ill post some updated code in a sec.  Think somehting just came to me though
17:55:04 <Jesin> meh
17:55:06 <DMcGill> Jesin: IO a is an IO action that returns a value of type a. Creating an IO action, like hClose does, is pure. It's only when you evaluate it that side-effects happen.
17:55:19 <Jesin> I prefer the "first-class action" idea.
17:55:24 <Jesin> alright.
17:55:27 <mm_freak> DMcGill: s/evaluate/execute/
17:55:33 <Jesin> ^
17:55:33 <mm_freak> evaluation of IO actions is pure
17:55:35 <DMcGill> mm_freak: yeah, sorry
17:55:48 <DMcGill> and execution only happens from Main.main
17:55:53 <mm_freak> no!
17:55:57 <DMcGill> no?
17:55:59 <mm_freak> it does not happen at all in haskell
17:56:22 <mm_freak> execution is an effect of something outside of haskell interpreting the IO action called 'main'
17:57:12 <DMcGill> fair enough
17:57:37 <mm_freak> say main = getLine
17:57:53 <mm_freak> that outside interpreter has to first evaluate main, which will result in an IO action that reads a line from stdin
17:58:04 <mm_freak> then it executes that action
17:58:17 <mm_freak> this in turn may cause further evaluations and executions
17:58:31 <mm_freak> but it all happens outside of haskell/main
18:01:12 <DrAwesomeClaws> ok, basically I have a function which returns IO [FeedData]   I'm attempting to map each FeedData value of the list to a function of type FeedData -> Net () (which would take the FeedData element and write some of the data to the channel)      https://gist.github.com/anonymous/c1cc8dc0538ea78684d1  That is the code.  You can see where I'm failing at line 104 (writeFeedData)    The idea is an irc bot which f
18:01:12 <DrAwesomeClaws> etches rss feeds and updates the channel.
18:01:48 <Iceland_jack> @src mapM
18:01:48 <lambdabot> mapM f as = sequence (map f as)
18:01:53 <Iceland_jack> @ty mapM
18:01:53 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:01:55 <Iceland_jack> @ty mapM_
18:01:56 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
18:02:09 <mm_freak> DrAwesomeClaws: so you have FeedData -> Net ()
18:02:15 <mm_freak> what's the type of the result you want?
18:02:33 <DrAwesomeClaws> mm_freak: writeItem should be FeedData -> Net () I believe (I should prob verify that)
18:03:02 <DrAwesomeClaws> oh snap, i see another problem
18:03:35 <mm_freak> f :: FeedData -> Net ()
18:03:55 <mm_freak> map f :: [FeedData] -> [Net ()]
18:04:04 <mm_freak> fmap (map f) :: IO [FeedData] -> IO [Net ()]
18:05:38 <DMcGill> mm_freak: Net = ReaterT Bot IO
18:05:41 <DMcGill> Reader*
18:06:04 <sccrstud92__> is there a name for an algorithm that can isolate "islands" in a grid? i was thinking i could modify a flood fill algorithm but i wanted to know if something like this already exists
18:06:27 <mm_freak> c :: IO [FeedData]
18:06:32 <mm_freak> lift c :: Net [FeedData]
18:06:50 <mm_freak> alternatively:  liftIO c :: Net [FeedData]
18:07:18 <mm_freak> it's all a question of types =)
18:07:20 <DMcGill> DrAwesomeClaws: as mm_freak says, `lift' is what you want to use here to turn IO actions into Net actions
18:07:41 <DrAwesomeClaws> yeah, i've gotten it to Net [FeedData] , but it didn't help me.  I think i just need to take a step back and learn some more basic monad stuff.  They make so much sense before i try to use them.
18:07:46 <mm_freak> usually liftIO is what you want for IO actions
18:07:51 <mm_freak> although 'lift' works here as well
18:08:45 <mm_freak> DrAwesomeClaws: liftIO c >>= f
18:08:48 <DMcGill> and then if you have `f :: Feedback -> Net IO' then mapM_ f :: [Feedback] -> Net ()
18:08:55 <DrAwesomeClaws> holy crap, i got it to compile
18:08:56 <mm_freak> where f :: [FeedData] -> Net a
18:09:08 <DrAwesomeClaws> but i don't know what i did, i was just typing and watching boardwalk empie
18:09:12 <DrAwesomeClaws> empire
18:09:17 <mm_freak> you have FeedData -> Net () and want [FeedData] -> Net ()
18:09:38 <mm_freak> mapM_ does that conversion for you
18:10:52 <mm_freak> DrAwesomeClaws: it's always the same idea:  you have some basic function, and then you use lifting and mapping to apply it to your scenario
18:11:05 <DrAwesomeClaws> thanks folks.  I think i'll be able to figure this out.  Now that it compiles I know I'm somewhat closer
18:11:26 <DrAwesomeClaws> mm_freak: i'm starting to get that... it just isn't intuitive yet.  Too many years in imperative land
18:11:38 <mm_freak> in this case you have IO [FeedData], and you have liftIO :: IO a -> Net a
18:11:45 <mm_freak> so applying liftIO gave you Net [FeedData]
18:12:16 <DMcGill> DrAwesomeClaws: my usual approach when writing code is to write a bunch of types, type sigs and undefineds. It compiles. Then I slowly fill out the function definitions and every step of the way I get type errors if it doesn't compile!
18:12:29 <mm_freak> and you have FeedData -> Net (), so applying mapM_ :: (a -> Net ()) -> ([a] -> Net ()) gives you a list version of that
18:12:35 <mm_freak> finally you connect the two using (>>=)
18:12:50 <DrAwesomeClaws> I should have probably started with Hello, World rather than rss fetching irc bot
18:12:54 <mm_freak> (>>=) :: Net [FeedData] -> ([FeedData] -> Net ()) -> Net ()
18:13:00 <mm_freak> DrAwesomeClaws: no, that's fine =)
18:13:23 * hackagebot selfrestart 0.1.0 - Restarts the current executable (on binary change)  http://hackage.haskell.org/package/selfrestart-0.1.0 (NiklasHambuechen)
18:13:38 <mm_freak> this is a useful exercise to learn the basic idea of lifting and mapping, which is pretty much what haskell is all about
18:13:55 <kazagistar1> sccrstud92__: you can always ask in #algorithms, though it sounds like you want a graph connectivity algorithm?
18:14:00 <DrAwesomeClaws> thanks mm_freak
18:14:49 <DrAwesomeClaws> once i get this little bot posting feeds in the channel it'll be useful enough for what i want to use it for.  Then i plan to take a step back and go through Learn you a haskell again.
18:15:04 <mm_freak> =)
18:15:18 <kazagistar1> sccrstud92__: for which the solution is indeed depth first or breadth first search
18:15:23 <enthropy> sccrstud92__: I don't think theres a threshold & contouring done in haskell. None of the many opencv bindings have gotten that far I think
18:15:54 <sccrstud92__> kazgistar1: thanks for the recommendation. ill look into that. is #algorithms on this server?
18:16:07 <enthropy> or maybe the grid is not an image
18:16:09 <sccrstud92__> enthropy: am I the one you meant to say that to?
18:16:28 <sccrstud92__> enthropy: idk what that means
18:17:07 <sccrstud92__> entrohpy: oh i think i see what you mean
18:17:26 <enthropy> dunno if your problem is the same as http://en.wikipedia.org/wiki/Image_segmentation
18:17:46 <sccrstud92__> entrophy: no the grid is no an image, i just though flood fill might work in this case, though graph connectivity might be more appropriate as kazing suggested
18:18:23 * hackagebot honi 0.1.0.0 - OpenNI 2 binding  http://hackage.haskell.org/package/honi-0.1.0.0 (NiklasHambuechen)
18:19:01 <sccrstud92__> enthropy: that is similar but in my case im just dealing with two colors and a very precise definition of a boundary
18:24:46 <sccrstud92__> kazingstar: enthropy: http://en.wikipedia.org/wiki/Connected-component_labeling is looking promising
18:25:26 <kazagistar1> sccrstud92__: I know this is python, but look at this implementation, its really simple: http://networkx.lanl.gov/_modules/networkx/algorithms/components/connected.html#connected_components
18:28:21 <kazagistar1> (I reach for networkx because they tend to have well documented and very simple graph algorithm implementations)
18:28:55 <Fernandos> hi
18:28:58 <kazagistar1> here is the similarly nicely labeled haskell version: http://hackage.haskell.org/package/containers-0.3.0.0/docs/src/Data-Graph.html#components
18:30:00 <sccrstud92__> kazigistar: my grid representation is Array (Int, Int). i would like to avoid processing it into a graph then converting it back
18:30:21 <Fernandos> just curious.. Is there are Code Unterstanding tool that has for providing haskell programmers security insights and Static/Dynamic Analysis features? Commercial and OSS.
18:30:30 <Fernandos> s/are/a/g
18:31:47 <kazagistar1> sccrstud92__: right, so you should probably go with something like the python version, but replace "look at neighboring vertexes" with "look at neighboring grid positions if they are the same color"
18:32:13 <Iceland_jack> Fernandos: why the /g? :) yes, types
18:32:49 <Iceland_jack> You can search for security types or check out the general idea of using restricted monads to restrict effects
18:33:23 <Iceland_jack> (also short plug for a proof of concept package I made called Capabilities)
18:34:01 <kazagistar1> sccrstud92__: and use a second grid as your marking to see if it has been visited instead of a "seen" set, but in the end it is just a dfs
18:34:26 <Fernandos> Iceland_jack: those are language centric types, but not code understanding and analysis tools that you're speaking, are they?
18:34:35 <sccrstud92__> kazigistar1: alright, thanks
18:34:46 <jophish_> Is it more conventional to have library imports above or below local imports?
18:35:04 <Iceland_jack> Fernandos: What do you mean by “language centric types”?
18:35:22 <Hafydd> I don't know what's conventional, but putting local imports below makes sense to me personally.
18:35:32 <kazagistar1> sccrstud92__: now that I think about your problem space a bit more, there probably is a way to do it more efficiently though…
18:36:03 <sccrstud92__> kazingstar1: agreed
18:36:15 <Fernandos> Iceland_jack: am basically asking for http://www.grammatech.com/ alternatives for Haskell
18:36:15 <trumpetting> umm, so i was reading a textbook, and i found something.
18:36:17 <trumpetting> Davey,Priestley 'Intro to Lattices and Order': "Accordingly, computer scientists commonly choose models which have bottoms, but prefer them topless." -_-
18:37:03 <Iceland_jack> Fernandos: When you said “language centric”, you were asking if it would work in other languages than Haskell?
18:37:32 <Taneb> Today I used arrow notation for the first time
18:38:26 <Ymesio> There is one thing that is not very clear for me in Haskell
18:38:28 <Iceland_jack> There is no such tool for Haskell that I'm aware of, but you can model a lot of security properties with the type system and a lot of the vulnerabilities aren't possible in Haskell (unless you're using the FFI, in which case you can use SafeHaskell)
18:38:30 <kazagistar1> sccrstud92__: a scanline at a time: mark each item in each row by its connectivity with the previous row, and then merge groups… does that make sense?
18:38:39 <Fernandos> Iceland_jack: No. I know that Haskell provides provability, by Monads, but they Haskell programs aren't prone to security issues and bugs.
18:38:52 <Ymesio> e.g. we have binary tree, and we add an element, new tree is created, correct?
18:38:57 <Iceland_jack> Fernandos: Haskell provides provability by monads??
18:39:02 <Iceland_jack> Provability of what
18:40:09 <sccrstud92__> kazingstar1: i believe so, yes. not sure what the extraction set would be
18:40:17 <sccrstud92__> extraction step*
18:40:19 <Taneb> Ymesio, yes?
18:40:32 <joneshf-laptop> Ymesio, in theory sure, but pretty sure it just updates that node
18:40:44 <joneshf-laptop> Ymesio, lemme see if i can find that link
18:41:11 <Fernandos> Iceland_jack: Haskell is often used for formal proofs of algorithmic correctness, if I'm not mistaken.
18:41:11 <Ymesio> Taneb: joneshf-laptop Sure, thanks. I'm just trying to understand what happens when we create an empty tree and then ad 100 elements
18:41:19 <Iceland_jack> Fernandos: Haskell is not a proof assistant
18:41:24 <Iceland_jack> Fernandos: “CodeSonar's static analysis engine identifies problems that developers care about finding, like data races, deadlock, buffer overruns, leaks, null-pointer dereferences, uses of uninitialized variables, and other security vulnerabilities.”
18:41:37 <Iceland_jack> Most of those things aren't possible to create in Haskell anyway
18:41:45 <sccrstud92__> kazigistar1: i want to end up with a list of arrays that represent the subcomponents, but i dont want the running time to be dependent on the subcomponents because there could be a lot. so if there was a method to extract after labelling that required a constant number of passes that would be ideal
18:41:48 <Ymesio> Will it just toss the ones that are not referenced anywhere?
18:41:54 <Taneb> Ymesio, theoretically, it'd create 100 trees, but the compiler's clever enough to do it in-place
18:42:04 <Taneb> It'll just overwrite them :)
18:42:05 <joneshf-laptop> Ymesio, i mean the right way to think about it is that you do get a new tree each time
18:42:06 <Fernandos> Iceland_jack: I know. There is Coq and Agda that I've heard of. But I was looking for Code Understanding tools for Haskell.
18:42:19 <joneshf-laptop> Ymesio, but because of physical constraints that's just not practical
18:42:23 <roboguy_> Fernandos: that is more the domain of languages like agda and idris
18:42:55 <Ymesio> joneshf-laptop: Taneb: I see, so in real life compiler is smart enough and will optimize things...
18:43:10 <Iceland_jack> Fernandos: It sounds like you have some misunderstanding of Haskell which you should consider looking into before considering external static verifiers, where verifiers don't exist for Haskell to my knowledge anyway
18:43:28 <Iceland_jack> Haskell doesn't have null-pointers, Haskell doesn't allow uninitialized variables, Haskell doesn't have buffer overflows etc.
18:43:43 <roboguy_> I guess there wouldn't be too much for a Haskell static verifier to do
18:43:49 <sccrstud92__> doesnt have null pointers or variables either
18:43:49 <Iceland_jack> You can avoid deadlocks by STM
18:43:58 <Fernandos> Iceland_jack: that's the answer I was looking for. It's ok, if there is none, I just wanted to know, if there is one and which, in the case there is one.
18:44:00 <Iceland_jack> sccrstud92__: Haskell has variables
18:44:08 <Iceland_jack> Fernandos: I said one didn't exist before :)
18:44:15 <roboguy_> hlint is probably the closest thing
18:44:19 <sccrstud92__> Lceland_Jack: like what?
18:44:34 <Iceland_jack> sccrstud92__: A variable ≠ mutable reference
18:44:38 <roboguy_> sccrstud92__: IORef
18:44:40 <kazagistar1> sccrstud92__: sorry, but I am pretty sure your algorithm is going to be bound as linear to the size of the overall grid no matter what, which will outweigh basically any other part of the algorithm?
18:45:22 <sccrstud92__> kazigistar1: it could theoretically be bound by the number of subcomponents as well, no?
18:45:24 <roboguy_> sccrstud92__: STRef too, for that matter
18:45:37 <Fernandos> Iceland_jack: What if someone writes super obfuscated, or generated code Haskell code? How will you try to understand that, if it additionally comes with over a thousand files in example?
18:46:06 <roboguy_> Fernandos: would a static verifier help with that anyway, though?
18:46:16 <Iceland_jack> Fernandos: What on Earth is your use case?
18:46:22 <roboguy_> haha
18:46:30 <Fernandos> Iceland_jack: I'm curious
18:46:57 <sccrstud92__> kazigistar1: i dont want to just extract one subcomponent per pass
18:47:17 <kazagistar1> sccrstud92__: the number of subcomponents is a lot less then the size of the grid… really though, a simple dfs is going to get you within a factor of 2 of the minimum memory space and something like 4 of the minimum comparisons
18:47:18 <Fernandos> roboguy_: not so much, but it's a lot of help compared to manually trying to grasp the code
18:47:18 <Iceland_jack> Fernandos: If you can control the type you could specify properties of the massive, ten trillion lines of code and see that it satisfies that property using the type
18:47:30 <kazagistar1> sccrstud92__: oh I see, no, that would be bad
18:47:40 <roboguy_> Fernandos: hlint can help some
18:47:40 <Iceland_jack> if you don't control the type then it depends on what you want to know
18:47:59 <Iceland_jack> ‘x’ would be called a variable in math in the following function definition
18:47:59 <Iceland_jack>     f(x) = x² + sin(x + 4)
18:47:59 <Iceland_jack> even though it's not a mutable cell :)
18:48:07 <dhrosa> @pl \x y -> sum (zipWith (*) x y)
18:48:07 <lambdabot> (sum .) . zipWith (*)
18:48:07 <roboguy_> if something is obfuscated though, it will be hard to read (by definition)
18:48:41 <Iceland_jack> dhrosa: You can also use (.:)
18:48:45 <Fernandos> roboguy_: if hlint is the equivalent of the linters written in other languages, then I fear that it would be of almost no help in this case.
18:48:54 <khyperia> Can someone point me to a lens tutorial that includes all four lens parameters? I've only ever seen type Lens' a b = Lens a a b b
18:49:08 <sccrstud92__> kazingstar1: i think i could determine the boundaries in one pass, and then create the arrays and copy the grids over in another pass
18:49:09 <Iceland_jack> Fernandos: Yes but what is your case exactly?
18:49:22 <dhrosa> @hoogle (.:)
18:49:23 <lambdabot> No results found
18:49:36 <dhrosa> :t (.:)
18:49:38 <lambdabot>     Not in scope: `.:'
18:49:38 <lambdabot>     Perhaps you meant one of these:
18:49:38 <lambdabot>       `.' (imported from Data.Function),
18:49:48 <roboguy_> Fernandos: can you give an example?
18:49:50 <Iceland_jack> @let (.:) = (.) . (.)
18:49:51 <lambdabot>  Defined.
18:50:03 <Iceland_jack> :t sum .: zipWith (*)
18:50:04 <lambdabot> Num c => [c] -> [c] -> c
18:50:12 <enthropy> > (1,2) & _1 .~ "khyperia"
18:50:14 <lambdabot>  ("khyperia",2)
18:50:16 <Iceland_jack> I would advice you to write:
18:50:16 <Iceland_jack>     foo x y = sum (zipWith (*))
18:50:16 <Iceland_jack> personally
18:50:23 <Iceland_jack> *advise
18:50:40 <Fernandos> Iceland_jack:  as I said, I'm just curious, it's hypothetical (atm.) and I want to know what tools are available for reverse-engineering Haskell code that was obfuscated with the intent to either protect or hide malicious code/backdoors.
18:50:53 <Iceland_jack> Fernandos: nope
18:50:56 <kazagistar1> sccrstud92__: yes, and that would save you some of the memory space and maybe increase cache locality over DFS, though the big-oh is the same
18:50:59 <Iceland_jack> not that I know of.
18:51:03 <khyperia> enthropy, what about that?
18:51:05 <Fernandos> I see
18:51:24 <roboguy_> Fernandos: I don't think there is much call for reverse engineering obfuscated haskell code at the moment
18:51:25 <sccrstud92__> kazigistar1: ok
18:51:31 <enthropy> that one has s/=t and a/=b
18:51:47 <sccrstud92__> Does anyone even obfuscate Haskell code? even for shits and giggles?
18:51:50 <khyperia> I don't even know what s, t, a, and b even *mean*. They're letters.
18:51:56 <roboguy_> sccrstud92__: I've done it for fun before
18:52:31 <Fernandos> Iceland_jack: can Haskell code be converted into another language? I think the llvm based compiler could translate it to C/C++/Javascript afaik..
18:52:43 <Iceland_jack> Fernandos: Sure
18:52:52 <khyperia> although I must admit, I chucked a bit when I saw fromEq's type signature - Equality s t a b -> Equality b a t s... stab bats?
18:52:53 <Iceland_jack> Any programming language can
18:53:22 <Iceland_jack> In particular, Haskell is converted to C, LLVM bitcode, JavaScript, etc. etc.
18:53:26 <enthropy> khyperia: the _1 has type  Lens (Int,Int) (String,Int) Int String
18:53:29 <Iceland_jack> *Haskell has been
18:53:31 <Fernandos> Iceland_jack: would information get lost during that process, I mean would it be harder to find the malicious code/backdoor or reverse engineer the code?
18:53:46 <roboguy_> sccrstud92__: trig ratios: t i b c m x=foldr(\a n->(n+(((-1)**a)*(foldr(\e r->r*((x^2)/(((2*e)+i)*(2*e))))((x^b)/c)[2..a]))))(x^m)[1..4];p=print;r=readLn;main=do{n<-r;mapM(\_->r)[1..n]>>=mapM_(\n->p(t 1 3 6 1 n::Double)>>p(t(-1)2 2 0 n))}
18:54:18 <enthropy> hopefully you can match that up with the types in (1,2), ("khyperia",2), and "khyperia"
18:54:24 <Iceland_jack> Yes information would certainly be lost, that's the case for any translation that's not injective
18:54:40 <khyperia> enthropy, alright... so lemme take a guess at it... Lens fromWhole toWhole fromSubpart toSubpart?
18:55:03 <sccrstud92__> roboguy: did you see that one post where aa guy wrote haskell to look like C?
18:55:06 <enthropy> yeah
18:55:16 <roboguy_> sccrstud92__: hmm, I don't think so
18:55:24 <enthropy> dunno how much more there is to it than that
18:55:29 <roboguy_> sccrstud92__: my favorite bit of obfuscated haskell is fix$(<$>)<$>(:)<*>((<$>((:[{- Jörð -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
18:55:32 <khyperia> Ah, alright, thanks.
18:55:46 <khyperia> roboguy_, what the heck does that *do*
18:55:53 <Fernandos> hahaha that's obfuscated!
18:55:57 <sccrstud92__> roboguy: even got unicode for funnsies, nice
18:56:04 <roboguy_> khyperia: it's a list of all powers of 2
18:56:12 <khyperia> ah, neato!
18:56:34 <roboguy_> > take 10 $ fix$(<$>)<$>(:)<*>((<$>((:[{- Jörð -}])<$>))(=<<)<$>(*)<$>(>>=)(+)($))$1
18:56:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
18:56:36 <Iceland_jack> fix + reader instance, yup it's obfuscated Haskell!
18:56:51 <Iceland_jack> and an Icelandic comment in the middle thrown in for good measure
18:57:13 <Fernandos> Iceland_jack: the reason I ask, is because I've recently read a paper about optimized obfuscation, which if applied into practice would require "Code Understanding" tools for Haskell
18:57:14 <roboguy_> there's a walkthrough of how it works here http://stackoverflow.com/questions/12659951/how-does-this-piece-of-obfuscated-haskell-code-work
18:58:12 <Iceland_jack> Fernandos: I haven't seen anyone interested in obfuscating their Haskell code nor anyone interested in running obfuscated Haskell code
18:58:36 <Fernandos> Wait till Haskell get's (more) popular
18:58:47 <zoku> I thought haskell was obfuscated by default?
18:58:48 <Iceland_jack> Fernandos: Sure, I will
18:58:49 <zoku> tehehe
18:58:53 <Iceland_jack> zoku: Good one!
18:58:58 <sccrstud92__> roboguy: is that unicode bit just an inline comment?
19:00:04 <Fernandos> Or an evil group decides to write their next release in obfuscated haskell code for use in cyber war
19:00:27 <Iceland_jack> Fernandos: and they would distribute the source code?
19:00:51 <roboguy_> sccrstud92__: yep
19:01:21 <Fernandos> Iceland_jack: In reality? No. But even if, how would you be able to understand the code if it was really optimzed obfuscation?
19:01:30 <roboguy_> Fernandos: I think there's a utility to pretty print haskell. that could help *some* I guess
19:02:14 <Fernandos> Iceland_jack: It would be a good reason to release the obfuscated code after the successful attack to hire  people who have the potential to understand it
19:03:10 <Fernandos> roboguy_: you mean hlint? Is that really so powerfull that you could make an arbitarily large number of files with interwoven functionality readable?
19:03:37 <roboguy_> Fernandos: no (on both counts)
19:03:44 <thebnq> if anything, obfuscated haskell code should be easier to understand compared to other languages..
19:04:00 <Fernandos> thebnq: Can you please elaborate?
19:04:08 <roboguy_> thebnq: well, I wouldn't say *that*
19:04:22 <Fernandos> thebnq: because I think it could be easier to obfuscated it even harder than in other languages.
19:04:39 * Fernandos k, someone ate my grammar tonight
19:05:01 <thebnq> hm i guess i was just thinking about substitution
19:05:18 <thebnq> i guess it can be bad afterall
19:05:22 <dzisentuboca> I would love to fuck somebody in the mouth
19:05:24 <dzisentuboca> thebnq
19:05:28 <dzisentuboca> are you a taker?
19:05:34 <dzisentuboca> or do you hate fucking niggers?
19:05:43 <thebnq> well
19:05:44 <dzisentuboca> let me suggest to you a wonderful website
19:05:56 <dzisentuboca> it is called chimpout forum, the best nigger hating forum on the web\
19:06:02 <simpson> @where ops
19:06:02 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:06:11 <dzisentuboca> do you want to know why it is the best nigger hating forum on the web?
19:06:11 --- mode: ChanServ set +o copumpkin
19:06:16 --- mode: ChanServ set +o Cale
19:06:16 <dzisentuboca> because we are not white supremacists!
19:06:17 --- mode: copumpkin set +b *!~CLIENTE04@187.153.59.178
19:06:17 --- kick: dzisentuboca was kicked by copumpkin (go away)
19:06:26 --- mode: copumpkin set -o copumpkin
19:06:40 <Aetherspawn> sorry
19:06:42 <Fernandos> whoa, what was that?
19:06:45 <Aetherspawn> did someone try and message me
19:06:47 <geekosaur> an asshole
19:06:49 <Aetherspawn> I got notifications but I was away
19:07:05 <shapr> ok then
19:07:19 <nexx> I think it was the first time I saw a kick in this channel
19:07:24 * geekosaur a trifle slow, network rewiring is fun
19:07:34 <shapr> nexx: it happens
19:08:47 <Fernandos> nexx: I only saw something like that twice in ten years on freenode, but it happens often in undernet etc.
19:09:19 <dario|> oftc also has spammers more often, from my subjective perspective
19:09:33 <Fernandos> thebnq: why? did you say/do something?
19:09:53 <Cale> Fernandos: Undernet is still going? I haven't been there since ~1996 or so :)
19:10:27 <Fernandos> Cale: why did you leave, hehe and what's the new undernet?
19:10:29 <Iceland_jack> I would actually be interested in how well obfuscation would translate to Core :)
19:11:17 <thebnq> Fernandos: i take back my thought kind of since you can do most anything
19:11:44 <thebnq> i was just thinking of pure substitution =(
19:12:18 <Cale> Fernandos: Well, the channels I wanted to visit just eventually all ended up being elsewhere.
19:13:48 <Fernandos> Cale: hmm.. where, if I may ask?
19:14:10 <Cale> Here for the most part
19:14:24 <Fernandos> Here's the paper http://eprint.iacr.org/2013/451.pdf and utility of it http://eprint.iacr.org/2013/454.pdf
19:14:45 <Fernandos> heh, would be fun if someone implemented it
19:22:09 <intrados> Is there a way to make a Prism' that returns `Left "error"` in the case of failure rather than Nothing?
19:27:36 <benzrf> hey
19:27:38 <benzrf> im havin an issue with parsec
19:27:43 <benzrf> > spaces
19:27:44 <lambdabot>  Not in scope: `spaces'
19:27:44 <lambdabot>  Perhaps you meant one of these:
19:27:44 <lambdabot>    `space' (imported from Text.PrettyPrint.HughesPJ),
19:27:44 <lambdabot>    `braces' (imported from Text.PrettyPrint.HughesPJ)
19:27:48 <benzrf> aw
19:28:16 <benzrf> anyway, I have 'foo `sepBy` bar`, but if I have foobarfoobarfoobar it tries to consume the last bar and fails
19:28:20 <benzrf> I would like it to ignore the last bar
19:28:24 <benzrf> is there anything i can do?
19:28:31 * hackagebot markdown-pap 0.0.1.5 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.5 (YoshikuniJujo)
19:28:46 <benzrf> to be precise im working on a parser where you should be able to have whitespace between any tokens
19:32:38 <Aetherspawn> benzrf: you mean like
19:32:48 <joneshf-laptop> :hoogle sepEndBy1
19:32:48 <Aetherspawn> foo,foo,foo type thing?
19:32:50 <joneshf-laptop> :hoogle sepEndBy
19:32:55 <joneshf-laptop> erm, whatever
19:33:04 <Aetherspawn> thats the one I was thinking of too ^
19:33:14 <joneshf-laptop> @hoogle sepEndBy
19:33:14 <lambdabot> Text.Parsec.Combinator sepEndBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
19:33:14 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepEndBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
19:33:14 <lambdabot> Text.Parsec.Combinator sepEndBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
19:33:30 <benzrf> joneshf-laptop: sepEndBy?
19:33:43 <benzrf> what does that do differently from endBy
19:34:00 <joneshf-laptop> it combines both
19:34:12 <khyperia> benzrf, why not (many (parser <* spaces))?
19:34:16 <benzrf> i tried
19:34:21 <benzrf> it gives 'many on empty'
19:34:57 <benzrf> also why is there no <<
19:34:57 <khyperia> well, then parser can accept the empty string, which is a problem
19:35:06 <benzrf> idk how it can
19:35:08 <benzrf> o-o
19:35:27 <c_wraith> Well, somehow it can.  figure it out!
19:35:37 <joneshf-laptop> does lambdabot have parsec?
19:35:41 <dwcook> many means "zero or more"
19:35:49 <dwcook> some means "one or more"
19:35:50 <benzrf> oh sepEndBy worked
19:35:56 <benzrf> some vs many1?
19:36:13 <dwcook> At least if you're using Control.Applicative's
19:37:14 <joneshf-laptop> benzrf, λ: parse (string "foo" `sepEndBy` string "bar") "" "foobarfoobarfoobar"
19:37:15 <joneshf-laptop> Right ["foo","foo","foo"]
19:37:25 <c_wraith> benzrf: there's no (<<) because it's ambiguous what it would mean.  Your options are following the (>>=)/(=<<) semantics, or the (*>)/(<*) semantics.
19:37:39 <benzrf> how do they differ?
19:37:49 <benzrf> I thought *> is just >>
19:38:02 <joneshf-laptop> :t (*>)
19:38:03 <lambdabot> Applicative f => f a -> f b -> f b
19:38:04 <joneshf-laptop> :t (>>)
19:38:06 <lambdabot> Monad m => m a -> m b -> m b
19:38:06 <benzrf> but implemented in terms of applicatives
19:38:12 <c_wraith> it is.  But there are two different things (<*) could mean
19:38:17 <benzrf> whats the diff?
19:38:21 <c_wraith> err, two different things (<<) could mean
19:38:32 * hackagebot markdown-pap 0.0.1.6 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.6 (YoshikuniJujo)
19:38:34 <c_wraith> one is flip (>>)
19:38:46 <c_wraith> the other is liftM2 const
19:39:12 <c_wraith> :t liftM2 const
19:39:13 <lambdabot> Monad m => m r -> m a2 -> m r
19:39:21 <c_wraith> yeah, that's the other one.
19:39:28 <c_wraith> That's the equivalent of (<*)
19:39:33 <benzrf> ah I see i think
19:39:36 <joneshf-laptop> :t flip (>>)
19:39:39 <lambdabot> Monad m => m b -> m a -> m b
19:39:40 <benzrf> order of execution
19:39:44 <c_wraith> yes
19:39:56 <benzrf> with the flip version...
19:40:03 <c_wraith> because (=<<) = flip (>>=)
19:40:14 <benzrf> putStrLn "foo" << putStrLn "bar" will do bar first
19:40:19 <benzrf> with <* it will do foo first
19:41:07 <kristof> So, uh
19:41:16 <kristof> When's the next time the Haskell Synopsium votes on something?
19:41:36 <kristof> *symposium
19:41:48 <BMeph> > (flip (>>) [1] [2,2] -- another difference...
19:41:49 <lambdabot>  <hint>:1:46:
19:41:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:42:05 <BMeph> > (flip (>>)) [1] [2,2] -- another difference...
19:42:06 <lambdabot>  [1,1]
19:42:30 <c_wraith> basically, the two are only the same with commutative monads
19:42:34 <c_wraith> like Maybe
19:42:40 <m3ga> kristof: 'haskell symposium' is the haskell talkfest thats held with icfp. i think you mean something different, possible haskell prime?
19:42:46 <dwcook> Maybe's not commutative
19:42:53 <c_wraith> dwcook: yes it is.
19:43:07 <m3ga> kristof: https://ghc.haskell.org/trac/haskell-prime
19:43:22 <dwcook> Isn't combining two Justs a counterexample?
19:43:48 <benzrf> well i got what i came here for
19:43:50 <benzrf> bbl :)
19:44:04 <c_wraith> commutative monads are specifically those for which (>>) is commutative
19:44:09 <dwcook> > Just 'a' >> Just 'b'
19:44:10 <lambdabot>  Just 'b'
19:44:12 <dwcook> > Just 'b' >> Just 'a'
19:44:13 <lambdabot>  Just 'a'
19:44:16 <kristof> m3ga: Ah, I see. So that's not annually; luckily, there is one this year!
19:44:16 <dwcook> See? Not commutative.
19:44:21 <c_wraith> err, the effects are commutative
19:44:33 <dwcook> What do you mean by "effects" then?
19:44:39 <c_wraith> no monad can be fully commutative, because >>'s type doesn't work that way
19:45:19 <jophish_> This typechecker is so much fun
19:45:27 <jophish_> I've got it sorted now, nothing can stop me
19:47:28 <c_wraith> dwcook: how about this, as a formalization:  a monad is commutative iff \f x y -> do {a <- x ; b <- y ; f a b } is the same as \f x y -> do {b <- y ; a <- x ; f a b }
19:47:59 <dwcook> c_wraith, okay, works for me.
19:48:18 <dwcook> Then I agree that Maybe is commutative in that sense.
19:48:26 <c_wraith> That can probably be simplified.
19:48:33 * hackagebot markdown2svg 0.0.1.10 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.10 (YoshikuniJujo)
19:48:42 <Iceland_jack> also Reader
19:48:56 <c_wraith> Reader is barely a monad at all.  :P
19:49:08 <Iceland_jack> Why not?
19:49:31 <c_wraith> iirc, there's nothing enabled by treating Reader as a monad that you don't get from treating it as Applicative, in terms of functoinality
19:49:46 <jle`> :O
19:49:57 <startling> c_wraith: that's interesting.
19:50:30 <dwcook> For that matter, Identity.
19:50:53 <Iceland_jack> c_wraith: Well that doesn't not make it a monad
19:50:55 <dwcook> Look at me, I know how to apply functions to regular values :)
19:51:05 <jmcarthur> :t (<*>) (<*>) (pure <*>)
19:51:07 <lambdabot> (a -> a -> b) -> a -> b
19:51:11 <jmcarthur> ^^ join
19:51:14 <jle`> perhaps more accurate to say it is not worth talking about as a monad
19:51:48 <Cale> Reader is less trivial than some monads I could name. There ought to be a word for monads such that M^2 is naturally isomorphic to M
19:52:06 <c_wraith> Iceland_jack: you are correct.  It is a monad.  It's just..  limited in a strange way
19:52:18 <jmcarthur> c_wraith: limited?
19:52:33 <c_wraith> as cale points out, M^2 is isomorphic to M
19:52:41 <Cale> Not true for Reader
19:52:59 <c_wraith> oh, I suppose it's not
19:53:00 <Cale> e -> (e -> a) is not at all the same thing as e -> a
19:53:06 <c_wraith> join does something interesting
19:53:19 <Cale> I was thinking of cases like the completion of a metric space
19:54:39 <jmcarthur> any monad constructed with Free basically has this property
19:55:08 <kristof> Cale: My opinion really isn't important but I still prefer dynamically scoped variables to Reader :(
19:55:15 <jmcarthur> M^2->M just drops a return somewhere
19:55:25 <Cale> I prefer ordinary function parameters to Reader most of the time
19:55:36 <jmcarthur> yeah, me too
19:55:41 <Cale> Unless you're using local a whole bunch, like in some interpreters.
19:55:47 <Iceland_jack> Reader by itself isn't much use, ReaderT on the other hand
19:55:54 <kristof> Sure, but passing things along as parameters gets verbose, especially if you're just trying to emulate a dynamically scoped variable
19:55:58 <Cale> Actually, ReaderT even moreso
19:56:00 <jmcarthur> i *especially* don't like using reader when i want to use local a lot
19:56:15 <Cale> jmcarthur: Interesting :)
19:56:23 <jle`> kristof: he is saying that you can do the same thing without the Reader monad
19:56:35 <jle`> by just using the(->) monad instance
19:56:37 <startling> ReaderT is so nice. You guys are wrong.
19:56:40 <jle`> (i think)
19:56:43 <Cale> jle`: No, actually, even without the monad instance
19:56:47 <jle`> oh
19:56:51 <Cale> Just explicitly passing parameters really isn't so bad
19:57:07 <Cale> Especially if the alternative is using ReaderT and having to lift things
19:57:19 <jmcarthur> Cale: for one, the type of MonadReader's local is unnecessarily constrained :\
19:57:29 <Cale> jmcarthur: ah, okay
19:58:04 <dwcook> @type local
19:58:06 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
19:58:22 <jmcarthur> @src (->) local
19:58:22 <lambdabot> local f m = m . f
19:58:29 <jmcarthur> :t \f m -> m . f
19:58:30 <lambdabot> (a -> b) -> (b -> c) -> a -> c
19:58:34 <dwcook> jmcarthur, the first parameter should be able to map onto another type, you mean?
19:58:34 * hackagebot yocto 1.0.1 - A Minimal JSON Parser & Printer for Haskell  http://hackage.haskell.org/package/yocto-1.0.1 (ajg)
19:58:39 <jmcarthur> yes
19:58:55 <jmcarthur> as i just demonstrated with lambdabot
20:02:23 <kristof> Cale: While you're here, what do you think of Oleg's extensible effects?
20:02:29 <kristof> As a replacement for monad transformers.
20:04:59 <DrAwesomeClaws> yay.  I can now fetch information from RSS feeds and spit it out to irc channel.  All the connections are there, now to make it useful (the fun part).  Thanks for the help earlier everyone.
20:05:20 <jle`> DrAwesomeClaws: congrats!
20:05:53 <alorente> I'm confused about the build-depends section of a cabal file. Is there a cabal command that means "install the dependencies for this build"?
20:07:29 <Cale> kristof: Not entirely sure what you're referring to
20:08:07 <kristof> http://okmij.org/ftp/Haskell/extensible/exteff.pdf
20:08:09 <kristof> Cale: ^
20:08:36 * hackagebot markdown2svg 0.0.1.11 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.11 (YoshikuniJujo)
20:08:53 <kristof> Cale: The short and skinny is that monad transformers impose awkward, static layering of monads, when really what people want is just one giant pool in the background they can stick their hand into and grab an effect from
20:08:55 <jmcarthur> kristof: most of the "extensible effects" stuff i've seen is literally just a monad transformer with some parameterization. i still don't think i even understand what the benefits are supposed to be.
20:09:06 <kristof> jmcarthur: Then you didn't read that paper ^^^
20:09:20 <kristof> jmcarthur: No more lifting, just reach in with a type signature and pull the effect out that you need
20:09:25 <Cale> Yeah, I think that's a bunch of fancy machinery that I would basically never use
20:09:33 <Iceland_jack> Good job DrAwesomeClaws!
20:09:56 <Cale> If you're using monad transformers correctly, none of your library's users should be able to tell from outside that you're using them
20:10:04 <ddere> alorente: `cabal install --only-dependencies [--enable-tests]` is that what you are after?
20:10:36 <jmcarthur> kristof: nope, i have actually read that one (well, skimmed)
20:10:46 <kristof> Cale: Just give the paper a shot! I think the type signatures end up being more verbose but I liked the idea.
20:11:01 <Cale> I see what's going on here
20:11:04 <kristof> ... er, what I mean is that I liked the idea enough to put up with the type signatures
20:11:11 <Cale> (I've seen similar things in the past)
20:12:02 <kristof> Well, if ok
20:12:08 <jmcarthur> kristof: the main claimed benefit of the paper as far as i can tell is basically that the effects are commutative. that just means i can't mix noncommutative effects in with them. that combined with more complicated types makes me question the real value.
20:12:09 <kristof> god, my typing is terrible today
20:12:34 <alorente> ddere: yes! That's doing what I was after. Thanks!
20:12:41 <Cale> Most of my uses of monad transformers have been things like  StateT s []
20:12:55 <ddere> alorente: np :)
20:12:58 <jophish_> is sequence a general form of catMaybes?
20:13:04 <jophish_> :t catMaybes
20:13:05 <lambdabot> [Maybe a] -> [a]
20:13:05 <Cale> I tend never to transform IO
20:13:06 <kristof> Cale: Well, if you checked it out and don't really see a use for it, I don't think I could say anything to convince you
20:13:09 <jophish_> :t sequence
20:13:10 <lambdabot> Monad m => [m a] -> m [a]
20:13:15 <jmcarthur> jophish_: no, they are different
20:13:20 <jophish_> ah yes, I see
20:13:36 <kristof> jmcarthur: No, that's not the point at all and there is no such restriction because IO is not (supposed to be) commutative and there are IO effects represented
20:13:38 <jophish_> sequence is returning the results in a monad
20:13:59 <jophish_> it seems a lot like it should have a general form
20:14:09 <jmcarthur> kristof: that's just because it is, as i said earlier, actually a monad transformer. you can slap it onto IO, which is what they did.
20:14:16 <Cale> kristof: Idris has an experimental thing which is not unlike this either
20:14:38 <Cale> It has some cute features, but I think it's realistically kind of silly
20:14:41 <kristof> Cale: I was talking to someone about that, yeah.
20:15:05 <jmcarthur> oh, i take it back. it looks like they obscured the transformerness a bit
20:15:24 <kristof> jmcarthur: There are no transformers. Your effects are munged into a single monad that is a typed-indexed union.
20:15:32 <Cale> "Combining effects" isn't something that you really often want to do in the sense that people mean it here.
20:15:46 <Cale> Or at least, I've never really seen a whole lot of need for it
20:15:52 <kristof> Cale: Probably not, but just because it's infrequent does not mean that people wouldn't want to do it sometimes
20:16:13 <Cale> There are a few libraries whose construction is made slightly more convenient by monad transformers, and that's cool.
20:16:55 <Cale> But overall I think monad transformers are somewhat overrated.
20:17:26 <Cale> Not because they're bad at what they do, but because the problem they solve isn't really that frequent.
20:19:15 <jmcarthur> kristof: it's actually quite literally a monad transformer. it is just disguised. note that the "lift" effect terminates the effects. you can only handle that effect once all others have been handled. in transformer speak, it's the monad being transformed.
20:20:05 <kristof> jmcarthur: you lost me
20:20:06 <jmcarthur> kristof: and i agree with Cale that transformers are overrated, which is why i'm also not enthusiastic about the latest extensible effects research
20:20:14 <jmcarthur> kristof: section 4.2
20:21:24 <jmcarthur> kristof: take special note of the "important difference" mentioned in that section
20:21:40 <MrRacoon> win 5
20:22:06 <kristof> jmcarthur: That section is with regard to interoperating with existing monads.
20:22:28 <jmcarthur> kristof: exactly
20:22:33 <kristof> well?
20:22:35 <jmcarthur> kristof: the meat and potatos of transformers
20:22:44 <kristof> Er
20:22:59 <jmcarthur> kristof: it shows that the whole thing is just a transformer
20:23:30 <jmcarthur> kristof: it transforms some (only one, as you would expect) base monad.
20:23:43 <kristof> jmcarthur: It's a single transformer to change a base monad into an Eff monad
20:23:52 <kristof> jmcarthur: after which you can layer as many effects as you want
20:23:53 <mildfate> is IO a type constructor?
20:24:00 <mildfate> :t IO
20:24:01 <lambdabot>     Not in scope: data constructor `IO'
20:24:01 <lambdabot>     Perhaps you meant `In' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
20:24:05 <mildfate> :k IO
20:24:05 <lambdabot> * -> *
20:24:15 <DrAwesomeClaws> actually, is there a standard way to implement setInterval (javascript) type behavior?  Run a function every t seconds?  I'm guessing Coroutine Monad?  I thought this would be trivial but i just realized i have no idea how to approach it, haha
20:24:29 <jmcarthur> kristof: it just happens to be a transformer that supports some modular effects (all of which can be supported in other transformers, too)
20:24:30 <frx> Cale only slightly more convenient? I must be missing something, because I reduced the code of a function that took good use of them by a factor of 3 or 4.
20:24:41 <kristof> jmcarthur: I'm not sure the point you're trying to make, but if you mean to say "look, Effects are just transformers!" then no, I don't think that's the case.
20:25:05 <startling> mildfate: it is a type constructor, it is not a data constructor
20:25:11 <copumpkin> DrAwesomeClaws: the usual question with that kind of thing is whether you want simultaneous things to fire off if a specific one takes a while
20:25:28 <kristof> :k Functor
20:25:30 <lambdabot> (* -> *) -> Constraint
20:25:48 <DrAwesomeClaws> copumpkin: well, I want the code to check an rss feed every <time interval>
20:25:49 <bitemyapp> kristof: hello.
20:25:51 <jmcarthur> kristof: my point is that Eff is just another way of looking at the same old idea. the interface is slightly different, but the end result is the same. it doesn't really bring anything new to the table.
20:25:51 <kristof> (just had to check that, sorry)
20:25:53 <kristof> bitemyapp: hy!
20:26:05 <bitemyapp> kristof: gave somebody a tutorial on friday on some basic Haskell. t'was fun.
20:26:07 <DrAwesomeClaws> times would be significantly long, not waiting for computation or anything though
20:26:29 <kristof> bitemyapp: With emphasis on what? What was their background? Where did they stumble? What did they like? What did you think of that experience?
20:26:47 <copumpkin> DrAwesomeClaws: well, I'd fire off a thread that sleeps for an interval, then does the other thing, and keeps doing that forever/until you ask it to stop
20:27:02 <bitemyapp> kristof: Clojurian, I emphasized typeclasses and the beginnings of the typeclassopedia.
20:27:05 <copumpkin> DrAwesomeClaws: that other thing can be firing off another thread if you want the action to happen every time interval, even if individual calls take a while
20:27:15 <bitemyapp> kristof: they grokked functors and monoids, sorta got applicatives and monads.
20:27:24 <DrAwesomeClaws> copumpkin: ok, thanks.  I'll head down that path and see how far i get, haha.
20:27:31 <copumpkin> or you could just use something like http://hackage.haskell.org/package/timers-0.2.0.2/docs/Control-Concurrent-Timer.html
20:27:36 <kristof> jmcarthur: I encourage you to look through all the examples in that paper and find a single "lift" being used (besides the one where they interact with vanilla monads)
20:27:38 <bitemyapp> copumpkin: couldn't you use channels/ivars/mvars and timeouts for this?
20:27:51 <copumpkin> bitemyapp: you could do many things, but why? :)
20:27:53 <kristof> jmcarthur: I also encourage you to look at the interpreter example
20:28:00 <copumpkin> threads are super cheap
20:28:08 <bitemyapp> copumpkin: that toolkit is just how I'm used to doing it.
20:28:16 <bitemyapp> copumpkin: not really for "cheapness", but because they're data.
20:28:21 <kristof> bitemyapp: Very cool. Did you read what I said earlier about the Pipes-author guy?
20:29:19 <bitemyapp> kristof: no, what?
20:29:39 <jmcarthur> kristof: anyway, in practice, if i need the ability to control what effects are available where, i end up just using type classes. i leave everything polymorphic as much as possible. i only have to determine the ordering of the effects i'm using as i apply run functions, and i don't really have to deal with lifting at all.
20:30:03 <joelteon> is there a library that provides cross-platform access to the null device
20:30:03 <joelteon> or something in the standard lib
20:30:35 <jmcarthur> kristof: e.g. if my function f needs Foo effects and Bar effects, it will just return a (Foo m, Bar m) => m Int or whatever
20:31:24 <kristof> jmcarthur: Can you do that kind of restraint on m?
20:31:32 <kristof> jmcarthur: I didn't think you could do both
20:31:48 <jmcarthur> why not?
20:31:49 <kristof> with monads
20:32:00 <kristof> (Reader m, IO m) => m Int
20:32:04 <kristof> that doesn't make sense to me
20:32:06 <jmcarthur> no
20:32:26 <jmcarthur> those are type constructors. i'm talking about constraints.
20:32:39 <kristof> o...k...
20:32:50 <kristof> I'm not in the proper state of mind to grok anything right now
20:32:52 <jmcarthur> i would elsewhere have some concrete implementations that i "reveal" my usage of by using their run functions
20:33:01 <bitemyapp> kristof: hum?
20:33:01 <kristof> I'm actually quite busy
20:33:09 <bitemyapp> kristof: what about tekmo?
20:33:14 <kristof> I've really just been idling in here waiting for bitemyapp to come on
20:33:21 <kristof> bitemyapp: the haskellforall.com guy
20:33:40 <kristof> bitemyapp: that blog is friggin' sweet and I've read a lot of its posts on and off but there were two posts I read this morning which blew my mind
20:33:57 <jmcarthur> kristof: a more proper translation of what you tried to do would be:   (MonadReader m, MonadIO m) => m Int
20:34:33 <bitemyapp> kristof: which posts?
20:34:57 <jmcarthur> kristof: note that i can use that type even in contexts that want other effects available as well. note also that it doesn't care about the relative ordering of that MonadReader constraint with some other, say, MonadState constraint.
20:35:20 <jmcarthur> kristof: and finally, note that the only lifting i ever need to do there is for IO, which would also be needed with Eff.
20:35:58 <jmcarthur> but that's all MTL stuff, which i think is not as useful as more domain specific type classes, usually.
20:36:05 <jmcarthur> so it weakens this example.
20:36:11 <kristof> bitemyapp: was looking for them. 1) http://www.haskellforall.com/2012/08/the-category-design-pattern.html and 2) http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
20:36:37 <kristof> jmcarthur: Ok. I haven't stacked enough transformers together to run into trouble yet, I just thought that eventually it would become unwieldy.
20:37:43 <mildfate> I have this type: "symbol :: Parser Char" and this type "spaces :: Parser ()", what does this line mean: "(spaces >> symbol)"?
20:37:48 <jmcarthur> kristof: it depends on how you use them
20:37:53 <kristof> bitemyapp: The one-two punch for me was that first, you structure your programs into categories so that you get these arbitrarily awesome compositions, and second, you use functors to map between those categories for unlimited code reuse
20:38:12 <kristof> bitemyapp: ...by unlimited code reuse, I just mean that a lot of code meant for one category can always and easily be lifted to another one using a functor
20:38:14 <bitemyapp> kristof: yeah, that's what I was trying to explain to my student on Friday.
20:38:19 <jmcarthur> kristof: generally you don't want to just throw a bunch together. you typically want to make higher level abstractions out of them, and so you will usually not even end up using more than one at a time.
20:38:26 <levi> mildfate: It means "match spaces, then match symbol"
20:38:28 <bitemyapp> kristof: as long as you obey the laws, you reuse the same infrastructure over and over.
20:38:31 <kristof> bitemyapp: Well, getting to the point of understanding that has taken me a year of learning functional programming and thinking about this stuff :P
20:38:39 <bitemyapp> kristof: there is some crazy GHC.Generic stuff I've been learning about lately
20:38:56 <kristof> bitemyapp: Oh, and reading those blog posts. But those posts wouldn't have made sense to me without having had my feet kind of wet first
20:39:04 <bitemyapp> kristof: yeah all of it is like that.
20:39:10 <bitemyapp> kristof: none of it makes sense unless you poke around.
20:39:41 <kristof> bitemyapp: I'm just still in a little bit of awe
20:40:32 <levi> mildfate: spaces is a Parser (), so it has no useful value aside from the action of matching. On the other hand, symbol is a Parser Char, so in addition to matching it will produce a Char. Since it's on the right hand side of the >>, the () from the spaces parser is discarded and the Char from symbol is returned by the whole expression.
20:43:01 <mildfate> so spaces >> symbol produces a Char?
20:43:14 <levi> kristof: If I'd had any idea that abstract math was so useful for structuring programs, I would have taken a lot more math in school, or otherwise learned more of it before now.
20:43:34 <mildfate> I thought the "Parser ()" just meant, parser type constructor with no values
20:43:56 <bitemyapp> levi: at least you know now.
20:44:06 <bitemyapp> levi: there's still plenty of people out there that don't know any of this stuff yet :)
20:44:11 <levi> mildfate: Well, it evaluates to a Parser Char. The parsing infrastructure lets you apply that Char to some data type and save it for later.
20:44:56 <bicgena> at what point would you say you "know" a programming language?
20:45:25 <bitemyapp> everybody has a different standard.
20:45:53 <bitemyapp> I know some people that would say they know their "primary" language but I'd argue they don't really know any languages at all, including their primary one.
20:46:16 * DrAwesomeClaws reads about haskell on wikipedia... adds "Haskell expert" to resume
20:46:18 <levi> bitemyapp: I'm giving a presentation in a couple of days to a bunch of functional programming people (mostly Clojure programmers, it seems) introducing Haskell, and I'm trying to give a taste of the usefulness of Haskell's mathematical structure without it being too abstract or overwhelming.
20:47:07 <bitemyapp> levi: I'm a very active Clojure developer, I teach Haskell to a lot of Clojure people.
20:47:12 <amalloy> doing it wrong, DrAwesomeClaws: http://ro-che.info/ccc/11
20:47:16 <bitemyapp> levi: I can offer pointers if you want. I typically focus on typeclasses.
20:47:35 <amalloy> shouldn't have even read the wikipedia article first
20:47:50 <DrAwesomeClaws> haha
20:49:06 <levi> bitemyapp: So far, I start with lazy evaluation, then algebraic types, then parmetric polymorphism, then type classes in general, and a couple of basic but interesting type class examples.
20:49:59 <fragamus> edwardk_: I need to make a "camera matrix" given a camera point and a point of interest.
20:50:32 <edwardk_> lookup http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml
20:50:52 <edwardk_> you'll also need some up vector
20:51:13 <kristof> levi: Math is the study of abstract structure. Why is it surprising that the study of structure is useful for structure?
20:51:38 <fragamus> yeah I derived something like that but it didn't work right
20:51:56 <bitemyapp> levi: I only mention lazy evaluation in passing as an alternative to macros.
20:52:10 <levi> kristof: Well, I can see that's true now, but it's not exactly apparent while slogging through Calculus classes.
20:52:12 <bitemyapp> levi: ADTs are good, parameteric polymorphism is only advantageous in the presence of typeclasses and free theorems.
20:52:48 <edwardk_> bitemyapp: even in their absence it is better than a sharp stick in the eye ;)
20:53:04 <bitemyapp> edwardk_: yeah but he's talking to clojurians.
20:53:14 <bitemyapp> edwardk_: polymorphism is "free" in that world (for some ghetto value of free)
20:53:33 <bitemyapp> edwardk_: you cannot explain Haskell to Clojure users effectively unless you show how it does things *better&
20:53:36 <bitemyapp> *better*
20:54:05 <levi> Well, the ideas of purity and laziness are fairly intertwined in the design of Haskell, and happen to provide 'enough' purity for free theorems to be useful.
20:54:05 <enthropy> if I compile a .c file with ghc does -O3 get passed through?
20:54:49 <edwardk_> bitemyapp: i usually just let S11001001 do to explaining where clojurites are concerned, he's got a good collecton of absurdities
20:55:10 <levi> They can help you reason about how to implement things, and even if *you* don't use them to prove things, library authors can and that allows them to give you libraries with fusion transformations.
20:57:04 <bitemyapp> edwardk_: I'm a Clojurian trying to steal people on my way out.
20:57:43 <edwardk_> bitemyapp: then stephen might be a good person to talk to for ammunition ;)
20:57:44 <levi> Which, in the end, lets you write programs that are pretty efficient but are still made out of composable pieces instead of low-level recursive functions with accumulators.
20:58:00 <kristof> levi: Calculus sucks. America gets stuck in the calculus trap, even when there's a lot more to mathematics.
20:58:15 <bitemyapp> kristof: I hated calculus, love the abstract algebra and category theory.
20:58:18 <fragamus> does linear have a gluLookAt equivalent
20:58:28 <bitemyapp> edwardk_: I know Clojure really well. I know what's fucked and what's not :)
20:58:30 <edwardk_> fragamus: no. its kind of outside of its purview
20:58:31 <kristof> bitemyapp: I used to like calculus but after Differential Equations, I am done with it :(
20:58:37 <edwardk_> bitemyapp: =)
20:58:42 * hackagebot cabal-rpm 0.8.9 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.9 (JensPetersen)
20:59:19 <edwardk_> kristof: i have to say it wasn't until real analysis that i actually gained an appreciation for calculus
20:59:40 <edwardk_> it isn't taught well, because its needed early to make the other majors happy
20:59:46 <kristof> edwardk_: Been reading some introductory texts, can't say I appreciate it
20:59:51 <edwardk_> so it becomes symbol pushing
20:59:53 <levi> Calculus is tremendously useful, just not for writing most programs.
21:00:45 <kristof> edwardk_: Er, I mean to say that I didn't like it, but I at least appreciated the sort of magic that happened
21:00:48 <erisco> kristof, I am studying those now :o
21:01:20 <kristof> edwardk_: I actually have a copy of "Counterexamples in Analysis", which is a fun read sometimes!
21:01:39 <edwardk_> levi: depends on what you want to do. much of the most profitable code i've written in the last 5 years has centered around really understanding calculus well =P
21:02:01 <kristof> all the good jobs require it
21:02:09 <edwardk_> and `ad` seems to be working out well for the financial sector
21:03:16 <levi> edwardk_: Sure, there are a lot of programs that do require calculus, but I think more as part of the 'domain expertise' than relating to the structure of programs in general.
21:04:19 <levi> In the end, math in general is a lot more useful than many programmers would like to admit.
21:04:30 <edwardk_> basically it shows up whenever you need to optimize something. want to write an optimizer for something? need to tune those constants automatically so you aren't getting bug reports when load factors vary out of expected ranges? tc.
21:04:32 <levi> Whether it be calculus or category theory.
21:04:52 <enthropy> to follow up, it seems that ghc does not pass -O3 on to gcc
21:05:02 <edwardk_> personally i view it as an indispensible tool in my tool bag, but YMMV. i know i didn't value it when i didn't have it down pat
21:05:22 <enthropy> since pushing more things into the C world has produced a speed-up
21:05:26 <levi> Like most things, you don't realize how useful it will be until you understand how useful it is.
21:05:56 <edwardk_> i feel similarly about a good understanding about Bayesian statistics, until I had it I had no idea what I was missing.
21:06:36 <djahandarie> Bayesian statistics and calculus. Two things I don't know and feel like I probably should.
21:07:00 <djahandarie> (NB, doing something in college has nothing to do with knowing it.)
21:07:16 <levi> Oh geez, I really need a chip that will give me instant knowledge of Bayesian statistics and related things in that area. I could apply it *right now*.
21:08:43 <djahandarie> Thanks to college I can solve integrals and derivatives all day (or at least with a couple hours of referesher), but what the hell is the point of that? I have mathematica. I wish I had a better understanding of applications of calculus to computer science.
21:09:08 <kristof> should people use a calculator if they can't add?
21:09:29 <kristof> Recognizing scenarios that are amenable to a calculus based treatment demands knowledge of calculus
21:09:29 <djahandarie> Should people use bad analogies? No, but they do.
21:12:36 <levi> It's one thing to learn all the tools and techniques; it's another to be able to see how they apply to novel situations. I'm not sure how much the latter can be taught; if it can, I don't think we generally do a good job of it.
21:13:13 <levi> Could be the fault of the learners as much as the teachers or "system", though.
21:13:19 <erisco> levi, courses move too quickly for me to consider the latter :(
21:13:44 * hackagebot markdown-pap 0.0.1.8 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.8 (YoshikuniJujo)
21:18:45 * hackagebot markdown2svg 0.0.1.12 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.12 (YoshikuniJujo)
21:19:12 <levi> On the other hand, courses do a good job of keeping me focused on one thing for long enough to cover a broad topic. I struggle at that on my own. :P
21:22:59 <edwardk_> levi: find the name of something, spend a half hour googling it, by the end you'll have a good clue. ;)
21:23:34 <edwardk_> and if what you find is too advanced for you at the time, go drill into something that depends on
21:23:57 <edwardk_> eventually you circle back when you find you need the thing you started with  ;)
21:24:43 <levi> edwardk_: I do that a lot.  I mean, a *lot*.  I guess I just don't have demanding enough projects to force me to dig really deep anywhere, so I graze in random patterns.
21:26:27 <levi> Occasionally it's proven very handy, but mostly it leaves me with a vague feeling of being extremely uninformed about a vast number of topics I wouldn't have otherwise been aware of.
21:29:24 <intrados> Is there a lensy way to do this? (without the <$>) `(_1 .~ 'e') <$> [('a', 'b')] ^? ix 0`
21:30:13 <edwardk_> > [('a','b')]^?ix 0._1 .~ 'e'
21:30:15 <lambdabot>  Couldn't match type `Data.Maybe.Maybe GHC.Types.Char'
21:30:15 <lambdabot>                with `(a0 -> Control.Lens.Internal.Setter.Mutator GHC.Types.Char)
21:30:15 <lambdabot>                      -> s0 -> Control.Lens.Internal.Setter.Mutator t0'
21:30:15 <lambdabot>  Expected type: Control.Lens.Setter.ASetter s0 t0 a0 GHC.Types.Char
21:30:15 <lambdabot>    Actual type: Data.Maybe.Maybe GHC.Types.Char
21:30:35 <edwardk_> > [('a','b')] & ix 0._1 .~ 'e'
21:30:37 <lambdabot>  [('e','b')]
21:30:45 <edwardk_> you want the Maybe result ?
21:30:58 <edwardk_> :t failover
21:30:59 <lambdabot> MonadPlus m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t
21:31:19 <edwardk_> > failover (ix 0._1) (const 'e') [('a','b')]
21:31:21 <lambdabot>  No instance for (Control.Monad.MonadPlus m0)
21:31:21 <lambdabot>    arising from a use of `e_101'
21:31:21 <lambdabot>  The type variable `m0' is ambiguous
21:31:21 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:31:21 <lambdabot>  Note: there are several potential instances:
21:31:32 <edwardk_> bah, cant remember how that works =)
21:31:39 <intrados> Ah, thanks.
21:31:47 <edwardk_> :t failover (ix 0._1)
21:31:48 <lambdabot> (Num (Index t), MonadPlus m, Field1 (IxValue t) (IxValue t) a b, Ixed ((,) Any) t) => (a -> b) -> t -> m t
21:31:57 <edwardk_> :t failover (ix 0._1) id
21:31:58 <lambdabot> (Num (Index t), MonadPlus m, Field1 (IxValue t) (IxValue t) b b, Ixed ((,) Any) t) => t -> m t
21:32:09 <edwardk_> :t failover (ix 0._1) id [(1,2)]
21:32:10 <lambdabot> (Num t, Num t1, MonadPlus m) => m [(t, t1)]
21:32:18 <edwardk_> > failover (ix 0._1) id [(1,2)] :: Maybe (Int, Int)
21:32:20 <lambdabot>  Couldn't match expected type `(GHC.Types.Int, GHC.Types.Int)'
21:32:20 <lambdabot>              with actual type `[(t0, t1)]'
21:32:27 <edwardk_> > failover (ix 0._1) id [(1,2)] :: Maybe [(Int, Int)]
21:32:28 <lambdabot>  Just [(1,2)]
21:32:43 <edwardk_> had to pick the instance
21:33:04 <edwardk_> > failover (ix 0._1) (const 'e' [('a',2)] :: Maybe [(Char, Int)]
21:33:06 <lambdabot>  <hint>:1:63:
21:33:06 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:33:12 <edwardk_> > failover (ix 0._1) (const 'e') [('a',2)] :: Maybe [(Char, Int)]
21:33:14 <lambdabot>  Just [('e',2)]
21:33:20 <edwardk_> i should have moved this to #haskell-lens =)
21:33:22 <edwardk_> there
21:33:48 * hackagebot purescript 0.3.12 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.12 (PhilFreeman)
21:33:55 <intrados> Err.. Is there a way to do that extracts the element from the list so `Just ('e', 2)` rather thn `Just [('e', 2)]`
21:35:24 <intrados> I guess you can just throw an `^? ix 0` on the end...
21:38:48 * hackagebot c-dsl 0.2 - A higher level DSL on top of language-c  http://hackage.haskell.org/package/c-dsl-0.2 (jozefg)
21:41:00 <jle`> are lists efficient structures for zipping?
21:41:15 <jle`> i have two lists that all they are ever used is to zip with eachother
21:41:29 <jle`> well and then using the results later
21:41:37 <jle`> would i gain anything from Vector or stuff?
21:41:40 <bitemyapp> jle`: benchmark
21:41:51 <jle`> bitemyapp: heh, thanks
21:42:52 <bitemyapp> jle`: I'm sorry, I'm not trying to be an asshole, it's just...use empiricism.
21:43:36 <startling> jle`, are they consumed lazily?
21:44:09 <jle`> bitemyapp: no problem. just wanted to maybe ask a conceptual question as well, though. benchmarking might tell me how it works in a narrow test but i'd be more interested to know about inherent properties of lists vs vectors
21:45:01 <jle`> startling: hm. they are always used all at once, if that's what you are asking?
21:46:37 <bitemyapp> jle`: I share startling's intuition, but I still think benchmarking is wiser.
21:46:40 <bitemyapp> I don't like to assume.
21:47:06 <startling> there's nothing inherently inefficient about using lists for zipping, but using something else may be more performant.
21:47:10 <bitemyapp> it's typically the case that full comprehension means vectors will win, but again, prefer to measure.
21:47:23 <startling> I'd be surprised if it was a bottleneck in your code, though.
21:48:19 <startling> so, yes, profile, and then benchmark if it looks like it's worth optimizing.
21:48:42 <jle`> hm thanks all
21:49:18 <jle`> was just musing around. my code doesn't even work yet so i can't even identify bottlenecks :'(
21:49:48 <startling> haha
21:59:36 <kusut> what do you suggest for newbies? ghc-mod or hdevtools? any particular quirks I should be aware of?
21:59:48 <jle`> kusut: why not cabal sandboxing?
22:00:28 <intrados> jle`: Is that in the same category?
22:00:36 <jle`> oh sorry
22:00:43 <jle`> i don't even know what i was thinking
22:00:44 <jle`> :|
22:00:46 <jle`> must be late.
22:00:53 <jle`> ignore me heh
22:01:01 <levi> I sometimes get hsenv and hdevtools confused
22:02:13 <levi> kusut: IIRC, ghc-mod is cabal sandbox aware now. But there is also a way to get hdevtools to be okay with cabal sandboxes... I just can't remember what it is now.
22:02:14 <intrados> kusut: I've never used hdevtools, but ghc-mod highlighting of errors and type insertion (the features I most care about) work for me
22:02:15 <vvvroom> I've had problems with hdevtools and source that requires preprocessing with CPP
22:02:32 <vvvroom> also - ghc-mod seems to work better with cabal sandboxes
22:03:14 <kusut> I tried both and they seem to be aware of sandboxes
22:03:23 <levi> hdevtools uses a client/server model, which can significantly improve interaction latency, but I've had it get confused before and had to manually kill it.
22:03:52 <kusut> I see. It is noticably faster though
22:04:41 <levi> ghc-mod has a nice 'ghc-mode' that integrates with haskell-mode in emacs. On the other hand, hdevtools has some flycheck rules that work well for instantly catching type errors as you make them!
22:05:32 <kusut> you cant catch type errors with ghc-mod?
22:05:51 <levi> You can catch type errors with either.
22:06:02 <kusut> I tried them both in like a day, so maybe I didnt use them long enough to spot any quirks
22:06:16 <levi> There are some subtle differences between them, but the largely do the same thing.
22:07:46 <kusut> this ghc-mod integration with haskell mode, is that the C-c C-l thingy?
22:08:05 <levi> No, I think that starts inferior-haskell-mode
22:08:10 <levi> That uses ghci by default
22:09:21 <levi> ghc-mod is a command-line tool that you can use to analyze your program without actually trying to compile it.  And you can ask for the type of terms at specific line/column offsets in your code.
22:10:21 <levi> With ghc-mode installed, it will show you the type of any term you cursor over in the input buffer at the bottom.
22:10:34 <kusut> can hdevtools do that? or it is just for general checker?
22:10:41 <intrados> You have perhaps already seen this, but here's a list of basic ghc-mod features available from emacs: http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
22:11:16 <kusut> looks like ghc-mod has more features
22:12:35 <kusut> intrados: yeah saw that. got this feeling that hdevtools is the more modern version of ghc mod, with long running process. Im probably wrong
22:13:47 <bitemyapp> kusut: there was something like hdevtools before ghc-mod but people switched for the features I think
22:14:59 <kusut> bitemyapp: switched to ghc-mod right?
22:15:09 <bitemyapp> kusut: da.
22:15:27 <bitemyapp> I think it was...Scion?
22:16:01 <platz> hdevtools seems more popular on vim for some reason
22:16:23 <kusut> thanks everyone. I just started here. Trying to setup my editor before doing any coding
22:17:24 <intrados> kusut: Don't mean to make things more complicated, but structured-haskell-mode might also be of interest: https://github.com/chrisdone/structured-haskell-mode
22:17:57 <kusut> yup saw that :D
22:18:35 <kusut> one question though, is that style guide compatible with other styles? like snap code guidelines etc
22:19:55 <Cale> http://urchin.earth.li/~ian/style/haskell.html is compatible with pretty much everything
22:20:08 <Cale> I'm unsure which guide you're referring to
22:20:44 <Cale> Well, the 80 column limit is a little harsh for some people.
22:21:10 <Cale> But everything else there is totally uncontroversial
22:21:15 <kusut> Cale: shm is following this guide https://github.com/chrisdone/haskell-style-guide
22:21:17 <kusut> okay
22:22:31 <Cale> Some of that stuff is really picky
22:23:25 <Cale> (especially the stuff about ordering of things and not using let)
22:25:58 <platz> hrm, don't use ($) or (<$>) ?
22:28:51 <enthropy> it's not very consisten with respect to newlines after keywords that introduce layout
22:29:47 <enthropy> "case () of\n" but "do x"
22:31:41 <Cale> That's pretty normal
22:40:40 <levi> Basically, there's no "one true haskell style", although there are a number of stylistic points that most people follow. Cale's link is probably close to the common ground, although SPJ seems to be fond of explicit braces and semicolons.
22:41:59 <enthropy> leading semicolons and underscores
23:01:54 <qrada> uh.. so data.vector is sick
23:02:47 <jfischoff> yes. yes it is
23:03:53 <verement> sick?
23:04:01 <ivanm> verement: it needs to see a doctor
23:04:10 <ivanm> :p
23:04:19 <qrada> s/sick/amazing
23:04:20 <qrada> ;f
23:04:31 <verement> ah
23:09:13 <zRecursive> it is Data.Vector not data.vector ?
23:13:47 <Heather> how to make >>= and when work together
23:14:00 * hackagebot egison 3.2.15 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.15 (SatoshiEgi)
23:15:04 <verement> :t (>>=)
23:15:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:15:08 <verement> :t when
23:15:09 <lambdabot> Monad m => Bool -> m () -> m ()
23:15:21 <Heather> t: (>>= when)
23:16:32 <Heather> it seems like I can't just >>= when $ do
23:17:33 <verement> :t (>>= when)
23:17:34 <lambdabot> Monad m => (m () -> Bool) -> m () -> m ()
23:18:09 <Heather> :t (>>= when $ do)
23:18:10 <lambdabot>     The operator `>>=' [infixl 1] of a section
23:18:10 <lambdabot>         must have lower precedence than that of the operand,
23:18:10 <lambdabot>           namely `$' [infixr 0]
23:18:18 <verement> that doesn't seem like what you'd want
23:18:54 <Heather> well with >>= \x -> when x $ do stuff it should work
23:19:12 <Heather> now I want to drop x
23:20:11 <verement> :t (>>= flip when)
23:20:12 <lambdabot> Monad m => (Bool -> m ()) -> Bool -> m ()
23:22:02 <verement> :t (>>=) . flip when
23:22:03 <lambdabot> Monad m => m () -> (m () -> Bool -> b) -> Bool -> b
23:23:51 <Heather> :S
23:27:58 <verement> @pl \x -> when x a
23:27:59 <lambdabot> flip when a
23:28:45 <verement> Heather: so try foo >>= flip when $ do ...
23:30:19 <Heather> verement: seems like works wrong
23:30:53 <Heather>  Couldn't match expected type `IO () -> IO ()' with actual type `IO b0'
23:31:19 <Heather> The first argument of ($) takes one argument ...
23:31:43 <Heather> but its type `IO b0' has none
23:31:54 <verement> oh, yes
23:32:08 <Heather>     Expected type: Bool -> Bool -> m0 ()  Actual type: Bool -> m0 () -> m0 ()
23:32:34 <verement> probably needs to be: foo >>= (flip when $ do …)
23:32:55 <Heather> verement: is it possible to pipe instead of brackets somehow?
23:33:11 <verement> I don't know what you mean by pipe
23:33:13 <Heather> ну около 35тр
23:33:25 <Heather> zz werid paste
23:33:42 <Heather> verement: I mean avoid brackets
23:33:48 <Heather> verement: maybe with .
23:34:15 <verement> it's getting a little awkward
23:34:58 <verement> I would probably prefer: x <- foo; when x $ do ...
23:35:18 <Heather> verement: with do?
23:35:34 <verement> eh?
23:36:00 <verement> yes, with do
23:40:09 <dmj`> Heather: what are you trying to do?
23:40:44 <Heather> dmj`: use >>= with when ...
23:45:24 <dmj`> Heather: getLine >>= \x -> when (length x > 2) $ do { print "cool" }
23:46:29 <ivanm> though in that case the do is redundant :p
23:47:52 <dmj`> ivanm: sure
23:48:04 <Heather> dmj`: yes I wanted to avoid \x also
23:49:26 <dmj`> @pl getLine >>= \x -> when (length x > 2) $ do { print "cool" }
23:49:26 <lambdabot> (line 1, column 44):
23:49:26 <lambdabot> unexpected '{'
23:49:26 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
23:52:18 <dmj`> Heather: that's a pickle
23:53:01 <Heather> dmj`: eh?
23:54:03 <dmj`> Heather: I'm not sure how you'd do it
23:55:26 <milfjord> @pl getLine >>= \x -> when (length x > 2) $ print "cool"
23:55:26 <lambdabot> ($ print "cool") . when . (> 2) . length =<< getLine
23:55:59 <dmj`> that's pretty
23:56:04 <dmj`> pretty ugly
23:56:59 <dario|> dmj`: it's not the worst @pl-output i've seen ;)
