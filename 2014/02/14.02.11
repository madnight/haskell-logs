00:06:49 <dmj`> anyone know a CI server that will build both C# and haskell
00:11:40 * hackagebot conduit-extra 0.1.5 - Experimental helper functions for conduit.  http://hackage.haskell.org/package/conduit-extra-0.1.5 (MichaelSnoyman)
00:11:40 * hackagebot template 0.2.0.9 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.9 (JohanTibell)
00:16:10 <tdammers> dmj`: I wrote a super-minimalist one a while ago... distributed CI server, completely build system and language agnostic, with worker processes distributed over a network of build boxes. 250 lines of python.
00:16:22 <tdammers> dmj`: unfortunately, I don't have the code, and I don't own the copyright
00:16:25 <tdammers> :(
00:17:03 <tdammers> I might do a rewrite some time
00:21:08 <pyon> I want to make a Trifecta parser that supports skipping tokens as if they were whitespace. Do I have to make my own wrapper around Text.Trifecta.Parser.Parser just so that it can have a TokenParsing instance where someSpace skips comments as well?
00:29:14 <dmj`> > take 15 $ zipWith3 (\a b c -> concat (a:b:c:[])) (cycle $ replicate 2 "" ++ ["fizz"]) (cycle $ replicate 4 "" ++ ["buzz"]) (cycle [""])
00:29:15 <lambdabot>  ["","","fizz","","buzz","fizz","","","fizz","buzz","","fizz","","","fizzbuzz"]
00:29:24 <dmj`> starting: ^
00:29:28 <dmj`> startling:
00:29:44 <dmj`> @pl take 15 $ zipWith3 (\a b c -> concat (a:b:c:[])) (cycle $ replicate 2 "" ++ ["fizz"]) (cycle $ replicate 4 "" ++ ["buzz"]) (cycle [""])
00:29:44 <lambdabot> take 15 (zipWith3 (((join .) .) . (. ((. return) . (:))) . (.) . (:)) (cycle (replicate 2 [] ++ ["fizz"])) (cycle (replicate 4 [] ++ ["buzz"])) (cycle [[]]))
00:31:37 * hackagebot scotty-session 0.0.3 - Adding session functionality to scotty  http://hackage.haskell.org/package/scotty-session-0.0.3 (AlexanderThiemann)
00:31:48 <ocfx> oo marcus aurelius' meditations are interesting
00:36:43 <darkf> did sandboxes not make it into cabal 1.18? :/
00:36:56 <dmj`> darkf: they did
00:37:36 <darkf> oh, for some reason my binary is still on 1.16
00:38:10 <dmj`> cabal install cabal-install
00:39:24 <dmj`> does ghc use CI for building on windows?
00:39:39 <startling> dmj`, travis does C# I think
00:40:21 <darkf> ah it installs to my local cabal/bin which isn't in my PATH, ok
00:40:38 <startling> dmj`, that fizzbuzz doesn't give you the numbers
00:40:50 <startling> dmj`, also the cycle [""] is useless
00:41:31 <dmj`> startling: yea, guess all we need is zipwith2
00:41:46 <dmj`> startling: I think travis ci for C# is mono only :/
00:42:14 <dmj`> zipWith :) there is not zipWith2
00:42:31 <startling> haha
00:42:37 <startling> dmj`: yeah, I think it is.
00:46:02 <dmj`> > take 15 $ zipWith (++) (cycle $ replicate 2 "" ++ ["fizz"]) (cycle $ replicate 4 "" ++ ["buzz"])
00:46:04 <lambdabot>  ["","","fizz","","buzz","fizz","","","fizz","buzz","","fizz","","","fizzbuzz"]
00:47:40 <startling> > getZipList $ ZipList ["a"] <> ZipList ["b"]
00:47:41 <lambdabot>  No instance for (Data.Monoid.Monoid
00:47:41 <lambdabot>                     (Control.Applicative.ZipList [GHC.Types.Char]))
00:47:41 <lambdabot>    arising from a use of `Data.Monoid.<>'
00:47:41 <lambdabot>  Possible fix:
00:47:41 <lambdabot>    add an instance declaration for
00:47:44 <startling> aw.
00:48:16 <grohne> what techniques can I use to understand/debug non-trivial (10kloc) haskell code bases?
00:48:36 <startling> grohne, haddock
00:48:52 <grohne> startling: thanks, will have a look.
00:49:12 <startling> grohne: (it's just a documentation generator, only useful if your code is appropriately documented)
00:49:27 <dmj`> > take 15 $ zipWith (,) (zipWith (++) (cycle $ replicate 2 "" ++ ["fizz"]) (cycle $ replicate 4 "" ++ ["buzz"])) [1..]
00:49:28 <lambdabot>  [("",1),("",2),("fizz",3),("",4),("buzz",5),("fizz",6),("",7),("",8),("fizz"...
00:50:14 <dmj`> grohne: what errors are you having
00:51:16 <startling> grohne: there are also a handful of tips for keeping things decoupled (e.g. use MonadWriter etc rather than Writer etc) but I'm not sure those are helpful to you.
00:51:18 <grohne> dmj`: different semantic behaviour on ghc6 vs ghc7
00:51:39 * hackagebot generic-maybe 0.2.1.0 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.2.1.0 (JonathanFischoff)
00:51:57 <grohne> startling: hmm. I don't quite see how to invoke haddock at all. receiving error: Ambiguous module name `Control.Monad.State': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
00:52:24 <grohne> startling: modernizing the codebase in the process of understanding it, is not an unwanted sideeffect. ;-)
00:52:40 <startling> grohne: you want to cabal haddock instead (assuming you are using cabal)
00:52:55 <dmj`> grohne: I've seen that before, I usually just ghc-pkg unregister monads-tf, since I personally use mtl more...
00:53:01 <dmj`> but I don't know your code so
00:53:11 <grohne> dmj`: I already figured that fail :: Either a b changed its behaviour, but now I am facing an endless loop in the ghc7 version
00:53:33 <grohne> startling: thanks
00:54:05 <grohne> startling: that was the missing piece for haddock!
00:54:38 <startling> ghc doesn't know anything about choosing packages, it can only list which packages provide a module. cabal has you choose which package versions you require, so you don't get that error.
00:54:57 <grohne> startling: haddock doesn't grok the th code. :-(
00:55:10 <startling> grohne, I think a newer version does.
00:55:40 <startling> (cabal install haddock)
00:55:44 <grohne> I did
00:55:50 <grohne> and the comments are not haddock-formatted
00:55:59 <grohne> i.e. syntax error inside comments
00:56:05 <startling> ah.
00:56:09 <dmj`> grohne: is this a pkg from hackage?
00:56:10 <startling> yeah, that's a problem. :)
00:56:28 <grohne> dmj`: no, but the idea is to upload it to hackage once it works (again)
00:56:53 <grohne> dmj`: darcs clone http://www.iai.uni-bonn.de/~grohne/darcs/igor2/
00:57:39 <grohne> dmj`: view the last patches to see what kind of issues I fixed already. ;-)
00:57:49 <startling> grohne: may be useful: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
00:57:58 <prophile> > [words(show n++" Fizz Buzz FizzBuzz")!!((19142723`shiftR`(n`mod`15*2)`mod`4))|n<-[1..]]
00:57:59 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
00:58:04 <startling> grohne: ctrl-f base
00:58:06 <grohne> startling: will have a look, thanks.
00:59:21 <dmj`> prophile: list comps, nice
00:59:48 <startling> prophile: wow
01:00:23 <dmj`> prophile: bit shiftin' like a pro
01:00:51 <jle`> what's the trendy csv library these days?
01:01:16 <prophile> it's a transliteration of the shortest version I could make for ruby
01:01:39 <prophile> I was quite pleased with the lookup-table-in-a-number hack
01:03:22 <dmj`> jle`:  intercalate ","
01:03:25 <dmj`>  ;)
01:04:25 <dmj`> no gaurds in list comps?
01:04:28 <dmj`> [ (x,num) | num <- [1..15], x <- num | num `mod` 3 == 0 = "fizz" ] ?
01:05:24 <grohne> startling: for instance the behaviour change of "fail" is not documented in the document you sent me.
01:06:27 <dmj`> > take 15 [ (x,num) | num <- [1..15], let x | num `mod` 3 == 0 = "fizz" | num `mod` 5 == 0 = "buzz" | num `mod` 15 == 0 = "fizzbuzz" | otherwise = "" ]
01:06:28 <lambdabot>  [("",1),("",2),("fizz",3),("",4),("buzz",5),("fizz",6),("",7),("",8),("fizz"...
01:06:41 * hackagebot yes-precure5-command 5 - Extended yes command to reproduce phrases in Yes! Precure 5  http://hackage.haskell.org/package/yes-precure5-command-5 (igrep)
01:06:49 <dmj`> > take 15 [ x | num <- [1..15], let x | num `mod` 3 == 0 = "fizz" | num `mod` 5 == 0 = "buzz" | num `mod` 15 == 0 = "fizzbuzz" | otherwise = "" ]
01:06:50 <lambdabot>  ["","","fizz","","buzz","fizz","","","fizz","buzz","","fizz","","","fizz"]
01:06:52 <startling> grohne, sorry, no idea
01:06:59 <startling> grohne, ghc 6 was before my time
01:09:31 <grohne> startling: any other idea, how I can gain an understanding of the code base? a big problem for me is the extensive use of monad transformers each of which carry significant state (and thus code like "lift . lift . lift")
01:10:33 <dmj`> grohne: which part
01:10:45 <Feuerbach> grohne: to understand it, try to refactor it (whether you end up using the refactored code or not)
01:11:00 <Feuerbach> that's what works for me
01:11:15 <grohne> Feuerbach: refactoring is a welcome side effect. is there some strategy I can use?
01:11:32 <dmj`> grohne: is it not compiling?
01:12:05 <grohne> dmj`: there is the "igor monad" IM which basically is a state monad with lots of state.
01:12:29 <grohne> dmj`: in the darcs repository I mentioned, it does compile now. it just does not behave as expected on the accompanying examples.
01:12:36 <Feuerbach> what I usually do is take a piece of code, then simplify/rewrite/split it until it makes sense
01:12:41 <bartavelle> are the states parts of other dead states ?
01:13:02 <startling> grohne: ugh, what a pain.
01:13:15 <startling> grohne, a MonadX class might be useful.
01:13:27 <grohne> bartavelle: cannot tell yet
01:13:29 <Feuerbach> e.g. if there are many lifts, you can add type annotations to understand what conversions are performed
01:13:38 <startling> grohne, you can change a StateT s (StateT t ...)) into a StateT (s, t) ...
01:13:40 <bartavelle> grohne, that would explain the name
01:13:41 <grohne> startling: will have a look
01:14:24 <startling> grohne: you can also only lift at the outermost place possible
01:14:45 <Feuerbach> Igor? Is it the author's name?
01:14:49 <startling> grohne, e.g. instead of lift (lift ...) >> lift (lift ...) do "lift . lift $ ... >> ..."
01:14:56 <startling> Feuerbach: it's a joke.
01:15:53 <startling> grohne, the last thing you could do is write modifyX f = lift (lift ... (modify f)) for each part of the state
01:16:09 <grohne> Feuerbach: no, upstream information available in german at http://www.cogsys.wiai.uni-bamberg.de/effalip/
01:16:12 <dmj`> grohne: the tictactoe function is 1000 lines long...
01:16:31 <dmj`> grohne: it compiled and the examples in the expl folder seem to work
01:16:44 <codygman> Anyone used the HPDF library much? http://hackage.haskell.org/package/HPDF   I am having trouble making a simple pdf with text.
01:17:12 <grohne> dmj`: it is not about compiling the examples.
01:17:29 <grohne> dmj`: igor is intended to use the examples to infer small functions (< 1000 lines ;)
01:18:15 <Feuerbach> I heard they're doing something similar at MSR
01:18:23 <dmj`> grohne: that's cool, so you're just trying to get a feel for it before you put it on hackage?
01:19:46 <grohne> dmj`: well I want to make it work on the provided examples, then put it on hackage (once I have permission from the authors) and then extend it in application-specific ways
01:21:36 <grohne> Feuerbach: referring to http://research.microsoft.com/en-us/um/people/sumitg/pubs/synthesis.html?
01:22:52 <Feuerbach> yes. there was a cool video of how they're gonna apply it in excel
01:35:28 <myname_> test
01:35:46 <myname_> \q
01:49:12 <lieven_> http://lpaste.net/99765
01:49:30 <lieven_> does someone see the error in this? As far as I can tell, there is a valid instance
01:51:26 <Cale> lieven_: Your use of liftIO is different between the line with a <- and b <-
01:52:07 <Cale> Is that intentional?
01:52:21 <lieven_> Cale: yeah. the first one doesn't do any DB stuff
01:53:22 <haasn> quick question: What's the preferred way of displaying a poly-kinded type operator if I want to include the kind?  should I display something like (a == * b) or something like (* a == b) or something like * (a == b) ?
01:53:40 <haasn> for non-operators the current syntax is just (Foo * a b c) which works out fine
01:53:55 <haasn> what does GHC do here?
01:54:27 <Cale> haasn: I believe its prettyprinter gets confused and displays something like == * a b
01:54:35 <Cale> Though I could be wrong :)
01:54:40 <haasn> looks like it does (<>) k a b
01:54:49 <haasn> err (==) * a b
01:54:57 <Cale> oh, good if it puts the parens in
01:55:17 <dmj`> lieven_: you call performGC once w/ liftIO and once w/o
01:55:29 <jle`> what's a fuzzy matching haskell library?
01:55:34 <jle`> for text
01:55:43 <dmj`> lieven_: you should post the entire code, error msg is cryptic
01:56:05 <lieven_> dmj`: sure. just a sec. this is really confusing me.
01:56:47 * hackagebot yaml 0.8.7 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.7 (MichaelSnoyman)
01:57:53 <lieven_> http://lpaste.net/99766
01:58:55 <exicer> I have a list of [(a, b)], which I would like to partition into n lists where the a values are equal. What function should I looking at ?
01:59:21 <merijn> :t groupBy
01:59:22 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
01:59:47 <merijn> :t groupBy ((==) `on` fst)
01:59:48 <lambdabot> Eq b => [(b, b1)] -> [[(b, b1)]]
02:00:20 <identity> exicer: There's also 'comparing' from Data.Ord
02:00:35 <identity> > groupBy (comparing fst) [(3, 4), (4, 3), (3, 2)]
02:00:36 <lambdabot>  Couldn't match type `GHC.Types.Ordering' with `GHC.Types.Bool'
02:00:36 <lambdabot>  Expected type: (a0, b0) -> (a0, b0) -> GHC.Types.Bool
02:00:36 <lambdabot>    Actual type: (a0, b0) -> (a0, b0) -> GHC.Types.Ordering
02:00:42 <identity> :t groupBy
02:00:43 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
02:00:46 <identity> :t comparing
02:00:47 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:00:49 <identity> ah, dur.
02:00:56 <identity> never mind comparing.
02:01:30 <exicer> Hehe, okay thanks!
02:01:36 <haasn> Cale: it's Haddock that gets it wrong and prints (* == a) b, hilariously, actually
02:03:45 <Cale> haasn: haha
02:04:10 <merijn> What's the term for the average numbers of neighbours in a graph? Branch factor?
02:05:17 <Cale> haasn: That might actually be valid though...
02:05:37 <Cale> haasn: assuming you can give the explicit kind parameter
02:06:17 <haasn> Cale: pretty sure you can't give explicit kind parameters in GHC
02:06:20 <lieven_> merijn: average degree
02:06:28 <haasn> it's an artifact of the pretty printer that they even show up, I don't know why they do
02:06:38 <haasn> Cale: you can do (<>) (a :: k) b -- but I don't know of any other method
02:08:24 <haasn> I can't seem to even distinguish between type variables and kind variables in GHC, they're all just “HsType”, “TyVar” etc.
02:27:55 <dmj`> lieven_: your code compiles for me
02:28:01 <dmj`> and runs
02:31:05 <lieven_> dmj`: ouch
02:32:19 <lieven_> then it comes down to versions or something
02:36:52 * hackagebot foldl 1.0.2 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.2 (GabrielGonzalez)
02:40:08 <lieven_> dmj`: funny thing. I rearranged to call liftIO on performGC everywhere so all the asyncs have the same type and I still get the same error
02:55:02 <haasn> Cale: fixed :)
02:58:45 <lieven_> jdm`: thanks for the help. I nuked my .cabal and .ghc caches and it compiles
03:01:48 <mvcorrea> Hi there, any possibility to put a question?
03:02:04 <mvcorrea> a newbie one
03:02:41 <Yaniel> "don't ask to ask" :)
03:03:18 <mvcorrea> how do I pass command line args to a module? can I put code here?
03:04:24 <Yaniel> see /topic
03:04:27 <Yaniel> "Paste code/errors: http://lpaste.net/new/haskell"
03:04:49 <mvcorrea> tks
03:08:44 <mvcorrea> cool I just need to paste the url??? http://lpaste.net/99767
03:08:58 <Yaniel> yep
03:11:52 <Yaniel> easiest would probably be to make input an argument to your sample function
03:11:58 <Yaniel> other than that I don't know
03:13:10 <mvcorrea> you mean passing directly to sample? I tried to include the "input<-getContent" in the sample without lucky
03:16:03 <Yaniel> sorry, haven't used commandline args i nhaskell
03:16:18 <mvcorrea> thanks!
03:37:11 <jlkjljlkjlkj> Hi. Anybody know about any kind of screencast for haskell learning?
03:38:17 <jlkjljlkjlkj> s/any kind/good
03:38:20 <merijn> mvcorrea: What's your question, do you want to pass command line argument to your program or do you want to pass the input to sample0?
03:38:41 <kusut> jlkjljlkjlkj: some haskell here http://www.youtube.com/user/jekor/videos
03:38:56 <merijn> mvcorrea: If you mean the latter,
03:39:14 <merijn> mvcorrea: sample01 doesn't take any argument, which doesn't seem right...
03:39:46 <jlkjljlkjlkj> Thank you, kusut  :)
03:57:01 * hackagebot numtype 1.1 - Type-level (low cardinality) integers.  http://hackage.haskell.org/package/numtype-1.1 (BjornBuckwalter)
04:02:01 * hackagebot dimensional 0.12.3 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.12.3 (BjornBuckwalter)
04:07:54 <SLi> If I'm parsing a C-like language (with preprocessor directives, so it needs to know about lines) with parsec, is the sensible way to write a separate tokenizer? Were it not for the preprocessor directives (mostly like '#line 123 sourcefile.c'), I think it would definitely be easiest to not write a separate tokenizer.
04:08:44 <t7> SLi: should it not be a 2 step process
04:09:02 <t7> i dont think the c pre-processor cares about parsing C
04:09:17 <t7> that may be wrong
04:09:49 <SLi> Yeah, I need to parse the C-like language (to an extent), the preprocessor directives are there mostly just to annoy me, I need to know just enough about them to not be able to just discard them ;)
04:11:27 <merijn> SLi: Why not preprocess before parsing?
04:12:39 <SLi> merijn: The files are actually outputted by the C preprocessor... I've thought about just discarding the preprocessor directives and just could get away with it. It does seem, though, that I lose the way to give helpful error messages that way (with source position information)...
04:14:56 <mm_freak> SLi: CPP optionally writes source position information
04:16:04 <mm_freak> just don't use -P
04:16:15 <tdammers> mm_freak: but then you lose that information
04:20:48 <SLi> Maybe I could have a separate step that really doesn't tokenize it, only removes the preprocessor directives and annotates with source positions (like a separate scanner, but with Char being the token type).
04:22:04 * hackagebot numtype-tf 0.1.2 - Type-level (low cardinality) integers, implemented  using type families.  http://hackage.haskell.org/package/numtype-tf-0.1.2 (BjornBuckwalter)
04:23:13 <SLi> But then I'm not sure I can still use all of the convenient parsers like string, oneOf etc that come with Parsec.
04:40:08 <mvcorrea> hi merijn
04:41:36 <mvcorrea> I just want to pass the input to Sample01, sorry for the delay I needed to leave for an instant
04:43:34 <mvcorrea> As I said I tried sample01 with  input<-getContent/getArgs without sucess :(
04:48:31 <Axman6> mvcorrea: you know getArgs and getContent have different types right?
04:48:43 <Axman6> @google getContent
04:48:44 <lambdabot> http://www.w3schools.com/jquery/jquery_dom_get.asp
04:48:44 <lambdabot> Title: jQuery Get Content and Attributes
04:48:47 <Axman6> @hoogle getContent
04:48:48 <lambdabot> Prelude getContents :: IO String
04:48:48 <lambdabot> System.IO getContents :: IO String
04:48:48 <lambdabot> Data.ByteString.Lazy getContents :: IO ByteString
04:48:54 <Axman6> @hoogle getArgs
04:48:54 <lambdabot> System.Environment getArgs :: IO [String]
04:48:54 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
04:48:54 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
04:49:42 <mvcorrea> I suppose, getContent:string getArgs:list of strings
04:51:36 <mvcorrea> in the code http://lpaste.net/99767 input is a string... to be passed to sample01
04:53:41 <merijn> mvcorrea: You can't pass a String to sample01, because sample01 is not a function
04:57:08 * hackagebot dimensional 0.13 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.13 (BjornBuckwalter)
04:59:38 <mvcorrea> let me try with a function
04:59:52 <suOya> > take 10 $ iterate (^2) 2
04:59:54 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
05:02:09 * hackagebot dimensional-tf 0.3 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.3 (BjornBuckwalter)
05:09:02 <codygman> I'm trying to do this: ActionM [Param] -> HashMap [Char] [Char] with scotty: http://hackage.haskell.org/package/scotty-0.6.2/docs/src/Web-Scotty.html#params However I'm not sure how to get the value out of the ActionM monad.
05:14:50 <Lethalman> codygman, you don't, why do you want that?
05:14:50 <Lethalman> codygman, you can ActionM [Param] -> ActionM (HashMap [Char] [Char])
05:14:53 <Lethalman> maybe with runAction you can get out of the monad, not sure how safe it is
05:22:51 <codygman> Lethalman: I want to pass paramaters I get from an html form to an external library.
05:23:05 <Lethalman> codygman, you can do that inside an ActionM
05:23:29 <Lethalman> codygman, do params <- theFunctionThatGivesYouHashMap then call your library
05:23:47 <Lethalman> the function has to be ActionM [Param] -> ActionM (HashMap ....)
05:23:54 <Lethalman> errr
05:24:02 <Lethalman> codygman, [Param] -> ActionM (HashMap ...)
05:24:22 <Lethalman> shouldn't be a problem to stay in the monad, no?
05:25:39 <mvcorrea> thanks merijn, all, I have the code working, i didnt known I could pass vars directly to a module "constructor alike"
05:25:51 <codygman> Lethalman: Well I want all the params to be sent to the external function. It seems like the easiest way to do things. I'm going to try what you said though, it's a bit past my knowledge level atm though. Need to sleep anyway :)
05:27:28 <merijn> mvcorrea: I don't understand what you mean by "passing vars to a module" and "constructor alike"
05:27:48 <merijn> mvcorrea: To be honest, you sound rather confused about what you're doing. Which book/tutorial are you following?
05:31:44 <peteretep> Does >> have a special name, like >>= is bind?
05:31:58 <bennofs> `sequence` maybe?
05:32:06 <bennofs> or `then`?
05:33:39 <tdammers> sequence is a function already
05:33:44 <tdammers> :t sequence
05:33:45 <lambdabot> Monad m => [m a] -> m [a]
05:35:03 <bennofs> Also http://www.haskell.org/haskellwiki/Pronunciation
05:35:49 <peteretep> ahah, thanks
05:41:49 <epta> bennofs: could someone please add some lens operators there?
05:44:47 <xintron> Is there an (reasonable) easy way of keeping a socket handle open between reloads of a program?
05:45:20 <tdammers> xintron: I don't think sockets work that way, not sure though. Might wanna look into something like zeromq
05:46:04 <xintron> tdammers, I know they doesn't work like that but a lot of software does work around this (somehow, just look at nginx)
05:46:16 <shiona> I'm quite sure you need some process to take the handle away from the program that is shutting down, and give it back to the restarted one
05:46:26 <tdammers> yeah
05:46:36 <merijn> xintron: Yes
05:46:42 <tdammers> the typical approach with web servers AFAIK is to have workers and a supervisor
05:46:48 <xintron> shiona, something like C sendmsg()?
05:46:52 <merijn> xintron: Ignore tdammers, it's actually impossible to zeromq sockets open
05:46:58 <merijn> xintron: I know, because I've tried
05:47:13 <shiona> xintron: no idea about that
05:47:15 <merijn> xintron: I assume you only care about *nix portability?
05:47:21 <xintron> merijn, yes
05:47:29 <merijn> xintron: Right, then it's Easy*
05:47:32 <shiona> I thought about nohup and draw an analogy there
05:47:34 <merijn> * - for some value of easy
05:47:45 <xintron> nhehe :)
05:47:55 <merijn> xintron: The thing you need to know is this: neither fork nor exec close open file descriptors
05:48:17 <merijn> xintron: So it is possible to fork a new process, exec a new binary and still keep the file descriptors (and thus sockets) open
05:48:54 <merijn> xintron: What you need to do is have the old binary and new binary communicate (via command line arguments, unix sockets, files, whatever) which file descriptors are open (and whatever program state you wish to maintain)
05:48:56 <xintron> ok, so if I start one process (PID 20) I could start a new one which would dup(?) the fd from PID 20?
05:49:31 <merijn> xintron: That lets you fork, exec new binary, transmit state from parent (old binary) process to child (new binary) process and keep running
05:49:49 <merijn> If the parent exits, the child will just keep running with the file descriptors from the parent
05:50:18 <merijn> xintron: For examples google for "MUD hot copy-over", it's a functionality many muds used to have, should turn up some articles on it
05:50:34 <xintron> ah, ty :)
05:52:20 <tdammers> merijn: I didn't mean using zeromq to manage sockets. Obviously that doesn't work.
05:52:31 <tdammers> merijn: I meant using zeromq *instead* of raw sockets
05:52:47 <merijn> tdammers: Yes, but that doesn't help as zeromq doesn't let you restart without losing messages
05:52:51 <xintron> merijn, just to clarify, if I have a running process it's that process that runs exec on the new binary (thereby inheriting the file descriptors) and the parent PID will always stay the same?
05:52:53 <merijn> tdammers: At least not without a lot of work
05:53:21 <merijn> xintron: PID are always static, they can't change while the process runs
05:53:26 <tdammers> merijn: no, you'd have to implement some kind of sync handshake in the application layer protocol
05:53:55 <merijn> tdammers: Which is an utter pain, it's actually one of the reasons I started working on a haskell ZMQ implementation to allow ZMQ binaries to do hot copyover like this :)
05:54:40 <merijn> (Don't ask about progress it's been in "nearly alpha" state for months now, work keeps getting in the way)
05:55:28 <tdammers> is that the one that actually reimplements the zeromq protocol in haskell?
05:55:43 <merijn> tdammers: Yes
05:55:43 <tdammers> instead of just binding to the official 0mq implementation, that is?
05:55:46 <tdammers> ah
05:55:58 <tdammers> "nearly alpha" sounds interesting :D
05:56:23 <merijn> tdammers: As in, most of the protocols work, but it only implements one authentication scheme and 1 of the 8 socket types :p
05:56:35 <merijn> But I need to go supervise the compiler course now
05:57:00 <tdammers> well, go be important then
05:57:07 <xintron> merijn, so the idea is that the exec will "block" the old binary and the new one is the one actually running from that point on?
05:58:41 <Aequi> Hello.
06:00:09 <Aequi> I'm working with haskell to import email form gmail and outlook(outlook.com), and i need to distinguish meeting requests from regular email. I know this is not a haskell specific question but still i'll be glad to hear
06:00:17 <Aequi> your suggestions.
06:02:51 <tdammers> Aequi: import how? IMAP?
06:15:28 <Aequi> tdammers: Yep.
06:20:21 <tdammers> in that case, you'll have to parse the messages I think
06:20:27 <tdammers> not sure though
06:20:44 <tdammers> but IIRC, appointments are ical attachements in regular messages
06:27:19 * hackagebot PasswordGenerator 0.1.0.0 - Simple library for generating passwords  http://hackage.haskell.org/package/PasswordGenerator-0.1.0.0 (VictorDenisov)
06:31:09 <fatho> Aequi: perhaps meeting requests contain special headers. not sure though
06:35:11 <Aequi> tdammers: And there is no standrt way to form meeting request email, ugh.
06:35:15 <Aequi> fatho: Let me check.
06:37:36 <tdammers> not really, no
06:37:52 <tdammers> you'll have to parse the messages and extract anything that looks like an iCal appointment
07:12:30 * hackagebot gitlib-s3 3.0.1 - Gitlib repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-3.0.1 (JohnWiegley)
07:13:32 <Aequi> Okay, found how to distinguish meeting requests: all these meeting invitation emails are multipart and containg part with content type text/calendar.
07:13:55 <Aequi> At least gmail and outlook.com initations.
07:14:47 <tdammers> so pretty much what I said
07:15:04 <tdammers> regular messages with icalendar attachments
07:20:58 <Sagi> how do I specify a working dependency on base in a .cabal file? On some systems ==4.6.* seems to work, but not on all of them. I would expect ==4.6.* to match 4.6.0.0 or 4.6.0.1, but that's not the case :?
07:21:23 <adnam> Sagi: it matches both
07:21:37 <Sagi> well, then why does it tell me that it rejected those? :\
07:21:54 <Sagi> rejecting: base-4.5.0.0/installed-40b... (conflict: netPropCheck =>
07:21:54 <Sagi> base==4.6.*)
07:21:54 <Sagi> rejecting: base-4.6.0.1, 4.6.0.0, 4.5.1.0, 4.5.0.0, 4.4.1.0, 4.4.0.0, 4.3.1.0,
07:21:54 <Sagi> 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0, 4.1.0.0, 4.0.0.0, 3.0.3.2, 3.0.3.1 (global
07:21:55 <Sagi> constraint requires installed instance)
07:22:05 <adnam> you have base 4.5
07:22:17 <adnam> it's tied to ghc so you can't update it
07:22:21 <dcoutts> Sagi: the only one it could pick would be base-4.5.0.0, as that's the one that is installed
07:22:29 <Sagi> oh
07:22:41 <Sagi> so, I can't switch base versions in my cabal sandbox?
07:22:45 <dcoutts> Sagi: you'll note that it does say why it cannot pick those others ones "global constraint requires installed instance"
07:23:21 <Sagi> ah, is that what 'global' refers to. I thought that referred to the .cabal file too. Well that makes sense then.
07:23:22 <dcoutts> Sagi: no, base is special, you cannot install it from source, it's fixed with your ghc version.
07:23:47 <Sagi> hrrm, okay, that means upgrading my ghc version then. Thanks a lot dcoutts, adnam!
07:24:02 <adnam> you can have multiple versions of ghc installed and switch between them though
07:24:11 <dcoutts> Sagi: or possibly doing a bit of work to make that package work with the older base
07:24:51 <Sagi> it's for a performance comparison, so I'd like to keep the changes to my development environment minimal.
07:24:59 * dcoutts has 8 versions of ghc installed
07:25:03 <Sagi> so I guess I'll just update ghc, it's just a vm after all.
07:25:38 <adnam> dcoutts: :o
07:25:51 <adnam> i thought i was pretty cool with 3
07:25:54 <dcoutts> and I'm missing 3 versions!
07:26:05 <chrra> Aequi: any text/calendar mime entity is an iTIP (iCalendar Transport-independent Interoperability Protocol) message. To see what type you need to inspect the iCalendar.
07:32:47 <osa1> can anyone help me with this error: http://lpaste.net/99778 I think I need to instantiate variables of existential quantification but I have no idea how can I do that ..
07:36:26 <supki> osa1: you can't use let with existentially qualified values
07:36:30 <supki> switch to case
07:38:39 <supki> ..and viewForm is not a function (what's its type?)
07:48:02 <benzrf> mapM on readers is just map right?
07:48:35 <benzrf> @hoogle mapA
07:48:35 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:48:35 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
07:48:35 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:48:37 <benzrf> hm
08:14:15 <jophish> How does one use pprPrec?
08:14:25 <jophish> what the the rational indicate?
08:14:46 <jophish> the precedence of the surrounding context?
08:19:31 <quito_bro> Hey guys!
08:19:43 <quito_bro> I have a question about unpacking an IO String into a String
08:20:06 <quito_bro> the type of `readFile` is String -> IO String
08:20:21 <quito_bro> but I want to pass the unpacked String result to another function that takes a String, not an IO String
08:20:52 <quito_bro> this doesn't compile...
08:20:52 <quito_bro>  unpackIoString :: IO String -> Pandoc unpackIoString fp =     do       unpacked <- fp       readMarkdown def unpacked
08:21:09 <geekosaur> @quote /bin/ls
08:21:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:21:20 <geekosaur> there's nothing to unpack
08:21:56 <quito_bro> @geekosaur the fp argument is an IO String (or IO Filepath)
08:21:56 <lambdabot> Unknown command, try @list
08:22:44 <geekosaur> but I'm not familiar with the pandoc api so am not sure if there's an IO you can use there or if you need to produce an IO Pandoc or if you're just doing this wrong and need to write the pure parts purely and lift them into IO
08:22:57 <quito_bro> Probably the latter...
08:22:57 <geekosaur> in any case you need to understand how IO works
08:23:13 <npcomp> @list
08:23:13 <lambdabot> What module?  Try @listmodules for some ideas.
08:23:18 <benzrf> what pumpkin?
08:24:04 * geekosaur should probably not have replied, work is popping a bit
08:24:30 <quito_bro> No worries
08:25:25 <chrra> fmap (readMarkdown def) (readFile "filename") :: IO Pandoc -- should do it
08:26:36 <cschneid> quito_bro: to simplify what chrra just said.  Instead of thinking of "how to unwrap", think of "put my function in that context".  fmap does that. so  `fmap head (readFile "filename")` would put the generic head function (get first element of list) into IO, and return an `IO Char`
08:27:18 <cschneid> quito_bro: so what chrra did was to put the `readMarkdown` function into the IO context, without ever attempting to "unwrap" the IO value
08:30:51 <ReinH> or you could wrote your own function using do notation if it makes more sense: readMarkdown f = do { contents <- readFile "filename"; return (readMarkdown def contents) }
08:31:15 <ReinH> then you might try translating that from do notation and using the monad laws to prove to yourself that it's equivalent to the fmap version
08:32:12 <ReinH> s/"filename"/f
08:34:11 <zipper> Are folds lazy?
08:34:24 <ion> foldr is, foldl' is not.
08:34:43 <CindyLinz> foldl (without ') is lazy, too.
08:34:52 <ion> But rarely useful
08:35:19 <CindyLinz> XD
08:37:04 <fragamus> theres flowers on the haskell platform download page
08:37:49 <Yaniel> sweet
08:38:48 <fragamus> um haskell is a badass programming language for badass programmers
08:40:00 <Feuerbach> foldr is not lazy
08:42:41 * hackagebot ewe 0.1.0.40 - An language using in Programming Languages teaching  http://hackage.haskell.org/package/ewe-0.1.0.40 (JuanFranciscoCardonaMcCormick)
08:44:07 <byorgey> flowers are actually pretty badass.
08:45:06 <Yaniel> haskell is also elegant
08:45:22 <companion_cube> it's nice, isn't it?
08:45:36 <Yaniel> (which makes it just more badass)
08:46:36 <BasDirks> edwardk: heya, who other than lispy was working on a 6502 emulator?
08:52:08 <Sagi> my program terminates with "Program: out of memory (requested 2097152 bytes)"
08:52:25 <Sagi> but the machine has 32G available, how can I make it use more memory before quitting?
08:52:46 <CindyLinz> Sagi: There might be too many thunks generated..
08:53:06 <edwardk> BasDirks: joshcough was playing around in that space. i've forgotten who else. i get pinged about once a week by someone writing some emulator or cpu simulator with lens in haskell ;)
08:53:40 <BasDirks> hehe cheers
08:55:50 <jozefg> If someone has a moment, could they proof read http://jozefg.bitbucket.org/posts/2014-02-10-types-kinds-and-sorts.html
08:57:46 <CindyLinz> Sagi: There's an RTS option -M, but it should be unlimited @@" # http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
09:02:30 <Sagi> CindyLinz: yeah, that was what I found
09:02:51 <Sagi> I don't understand why there is a 2G limit on -something-
09:04:20 <mornfall> Sagi: signed 32b integer?
09:06:51 <CindyLinz> Sagi: I've also tried my simple program:  let a = sum [1..] ; putStrLn $ show a
09:07:06 <CindyLinz> Sagi: And I also set the ulimit -S -v to 4G or 6G
09:07:23 <CindyLinz> Both they report t: out of memory (requested 2097152 bytes)
09:07:55 <CindyLinz> Thought when I'm watching the 'top', they seems consume 3.xG or 5.xG
09:08:05 <Sagi> so there seems to be some 'hard' limit on something.
09:08:36 <m09> @let f x y = (x == y)
09:08:38 <lambdabot>  Defined.
09:08:38 <CindyLinz> I thought the reported number is not the same as what it really consumed..
09:08:50 <m09> @let f' = (\x y -> x == y)
09:08:51 <lambdabot>  .L.hs:147:18:
09:08:51 <lambdabot>      No instance for (Eq a0) arising from a use of `=='
09:08:51 <lambdabot>      The type variable `a0' is ambiguous
09:08:51 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
09:08:51 <lambdabot>        L.f' :: a0 -> a0 -> Bool (bound at .L.hs:147:1)
09:09:34 <supki> @where dmr
09:09:34 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:09:39 <supki> m09: ^
09:10:08 <m09> thanks, I was investigating a strange behavior in ghci
09:10:36 <m09> where f would return the correct Eq a => a -> a -> Bool but f' would return () -> () -> Bool
09:10:37 <supki> in ghci it's a bit different because of -XExtendedDefaultRules
09:10:57 <supki> it chooses () as an instance of Eq
09:11:04 <m09> ok :)
09:11:42 <pjdelport> m09: in ghci, you can :set -XNoMonomorphismRestriction
09:11:53 <m09> noted :)
09:12:45 * hackagebot generic-maybe 0.3.0.0 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.3.0.0 (JonathanFischoff)
09:15:48 <YellowOnion> I'm trying to write a poker telnet server to learn a bit more about haskell, is there a better way to do this than just turning channels in to an event queue?
09:16:23 <johnw> well, you could use something like cloud haskell
09:16:35 <johnw> if you'd rather have a lot of the "actor" machinery done for you
09:18:20 <johnw> but if it's about learning Haskell, I'd use STM and TChan's
09:18:23 <johnw> STM is a great thing to know
09:19:44 <YellowOnion> johnw: Don't really need distributed concurrency, so might try STM then, thanks!
09:20:21 <ReinH> YellowOnion: you should read http://chimera.labs.oreilly.com/books/1230000000929
09:22:34 <YellowOnion> ReinH: sweet, thanks.
09:22:46 <alcabrera> YellowOnion: I second ReinH's recommendation. It's very thorough about concurrency/parallelism handling, including existing libraries. It's recent, too, as of July 2013.
09:28:30 <ReinH> also it's by, you know, Simon Marlow
09:29:05 <Fuuzetsu> pfft, what does he know about GHC's RTS
09:31:33 <benj_> whenever I read about "The Eval Monad" my brain turns it into "the evil monad"
09:32:59 <Fuuzetsu> I hope that's what the intention was
09:33:17 <adnam> that's what happens after you've seen other peoples php/javascript code
09:36:23 <ReinH> Fuuzetsu: a lot actually! ;)
09:36:33 <Fuuzetsu> I know, I kid
09:37:23 <bitonic> I'm looking for a very simple templating library, I just want to substitute names for `ByteString's in an existent `ByteString'
09:37:52 <bitonic> the things I looked at (`HStringTemplate', `hastache') seem to be overkill
09:38:02 <bitonic> I ruled out `hastache' because it needs IO to work
09:38:13 <bennofs> bitonic: maybe a regex library?
09:38:22 <bitonic> `HStringTemplate' seems only to work with String as input
09:38:30 <bennofs> bitonic: (only if your strings don't contain regex special chars)
09:38:32 <prophile> Has anyone looked into using RULES magic to turn >>= into <*> where that's permissible, if that's even possible?
09:39:06 <bitonic> bennofs: so you're proposing to use a regex library to search and replace into the `ByteString'?  if possible I'd like to have some existing to to avoid to screw up subtly
09:39:20 <bitonic> *something existing
09:39:36 <Kinnison> bitonic: I started to write such a beast, but gave up because I wanted fairly complex stuff.  I was playing with Twine at the point I stopped doing stuff
09:40:15 <bennofs> bitonic: ok, agreed, using a regex library might not be such a good idea :P
09:40:23 <johnw> prophile: there's a proposal currently to do something similar automatically for do-blocks
09:40:38 <Kinnison> bitonic: https://github.com/jamessanders/twine
09:40:41 <prophile> johnw: oh, shiny - is there anywhere I can read up on that?
09:41:51 <zipper> Can anyone recommend a haskell podcast?
09:42:04 <johnw> prophile: https://groups.google.com/forum/#!topic/haskell-cafe/-JsZ8FPs_pU
09:42:07 <bennofs> bitonic: I have no experience, but a hackage search turned up this:
09:42:13 <bennofs> @hackage stringsearch
09:42:14 <lambdabot> http://hackage.haskell.org/package/stringsearch
09:42:16 <prophile> zipper: the haskellcast is pretty good
09:42:19 <prophile> zipper: http://haskellcast.com/
09:42:24 <prophile> johnw: thanks
09:42:33 <zipper> prophile: but that had just 4 episodes
09:42:53 <prophile> zipper: 5, they're once a month
09:43:04 <bitonic> bennofs, Kinnison: thanks, I might actually quickly roll out something myself
09:43:05 <prophile> I'm afraid I don't imagine there's much else
09:43:18 <prophile> the haskell podcast market doesn't strike me as being likely to be saturated
09:43:20 <zipper> prophile: Why so few?
09:43:25 <Kinnison> bitonic: I ended up writing something for myself for Myrosinase
09:43:39 <prophile> zipper: because they're published once a month and it's been going for five months, I'd imagine
09:43:39 <Kinnison> bitonic: But it had iterations, list comprehensions, nested includes, etc
09:43:40 <bennofs> I think stringsearch looks quite good
09:43:59 <zipper> prophile: as in why once a month?
09:44:11 * zipper wants more
09:44:30 <prophile> well, hassle ReinH :)
09:44:32 <brofunctor> you can't handle more!
09:44:43 <brofunctor> every episode knocks me senseless for at least a week
09:44:54 <zipper> brofunctor: Me too
09:45:19 <zipper> Haskell is not for people who want to read a quick tutorial
09:46:05 <brofunctor> I am quietly hoping that jekor makes another "Haskell from Scratch" series, that was like crack to me, I was glued to YouTube for a whole weekend just watching it
09:46:07 <HugoDaniel> haskell is for everyone!
09:46:30 <zipper> brofunctor: There was a haskell from scratch series
09:46:57 <zipper> HugoDaniel: lol then why is it taking me so long to feel like I am really good at it?
09:47:19 <brofunctor>  zipper, I know, I want another one ;)
09:48:04 <HugoDaniel> zipper: because nobody is ever good at anything, haskell just starts showing you that :)
09:49:13 <zipper> I listened to Edward Kmett talk about how programming had stopped being a challenge for him until he found haskell
09:49:26 <zipper> So I would say haskell is pretty challenging
09:52:04 <zipper> lol I thought it was just me who was getting their mind blown by the podcasts glad to know it happened to everyone.
09:52:50 <tomejaguar> Yeah it does.
09:53:48 <zomg> zipper: I kind of agree with programming not being a challenge
09:53:55 <alcabrera> it happened to me, too, zipper.
09:54:05 <alcabrera> I've found that I keep learning every time I go back to LYAH, even.
09:54:21 <zomg> I mean writing code itself is not much of a challenge, the challenge really is in architecting bigger solutions and in how to actually solve problems
09:54:21 <alcabrera> I've gone through Real World Haskell at least twice now, and I keep finding something new each time. :P
09:55:02 <zomg> I'm not sure if the challenge in Haskell comes from not having used it so much though =)
09:55:14 <zomg> but it certainly feels more interesting just as a language vs many others I've used
09:55:26 <exicer> I have a datatype data Pair a b = Pair a b, where a is text and b is an int or something. I want to define my own infix addition operator, but I want it to only work when the first field is the same. What should I return in the case where it is not the same?
09:56:01 <exicer> Or should I just make an addition function instead ?
09:56:52 <peteretep> exicer: Well the easiest thing would be to get it to return (error "some error")
09:57:11 <peteretep> exicer: The question really is: what behaviour do you want when they don't match?
09:57:18 <peteretep> exicer: System failure?
09:57:29 <peteretep> exicer: Some kind of nice magical "fixes it" code?
09:57:42 <hc> probably they want the compiler to complain
09:58:00 <exicer> Hah, well I suppose if I were just making a function it would be Either with an error message in left.
09:58:10 <exicer> But I'm quite new to all this, so that might be stupid anyway
09:59:09 <zipper> zomg: What about using safter and faster and more efficient data sructures
09:59:21 <zipper> That part of programming interests me.
09:59:47 <zipper> zomg: It's challenging because I think imperativeley lol
10:00:27 <bennofs> Is there a standalone version of the `Automation` like in netwire?
10:00:49 <peteretep> woo, I've finished my first Monad tutorial
10:00:53 <peteretep> that is surely a rite of passage
10:01:25 * brofunctor coughs
10:01:35 <tac> Is there a convenient function to conjoin a list of strings with a separator?
10:01:36 <zipper> So if I read real world haskell should I still watch haskell from scratch videos? As in do they cover the same topics?
10:01:54 <johnw> peteretep: now you get to spend your time undoing the damage it did to your understanding of monads :)
10:01:58 <adnam> tac: intercalate or intersperse
10:01:58 <tac> @hoogle [String] -> String -> String
10:01:58 <lambdabot> System.Process showCommandForUser :: FilePath -> [String] -> String
10:01:58 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:01:58 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
10:02:08 <byorgey> tac: intercalate
10:02:27 <tac> which modules would you find those in?
10:02:34 <brofunctor> zipper, the HfS videos are very focused, I wouldn't consider them interchangeable with RWH at all.
10:02:47 <byorgey> tac: the modules are listed right there
10:02:52 <tac> oh
10:02:56 <tac> I didn't see it in the search results :)
10:03:16 <jfischoff> is there way to specify that a tasty test should only run for so long?
10:03:19 <zipper> brofunctor: Thanks :D
10:03:29 <peteretep> johnw: :-)
10:03:39 <brofunctor> zipper, the nice thing about watching those videos, for me, was seeing a real development process, rather than something contrived for a book.
10:03:43 <peteretep> Well I didn't understand them at all when I started
10:03:43 <peteretep> so
10:03:46 <jfischoff> Instead of specifying a level for smallcheck I want to specify the max time
10:04:39 <jfischoff> @message feuerbach is it possible to configure tasty and smallcheck with a max time to run, as opposed to a level?
10:04:39 <lambdabot> Maybe you meant: messages messages-loud messages?
10:04:48 <jfischoff> :p
10:04:58 <jfischoff> @tell feuerbach is it possible to configure tasty and smallcheck with a max time to run, as opposed to a level?
10:04:58 <lambdabot> Consider it noted.
10:06:09 <Sagi> CindyLinz: strangely enough it seems to work with explicit values for -K and -M
10:06:21 <Sagi> perhaps the 'default' is not so 'default' after all.
10:06:52 <tac> thanks byorgey adnam
10:06:56 <tac> that did the trick
10:07:08 <zipper> So what is haskell-cafe about? Is there just a haskell google group?
10:07:59 <johnw> it's a mailing list for discussing Haskell
10:14:18 <CindyLinz> Sagi: !
10:17:39 <CindyLinz> Sagi: ./t +RTS -M4194304000   then reports t: out of memory (requested 65011712 bytes)
10:18:02 <CindyLinz> it enlarged!
10:18:38 <zipper> Is there a mailing list called haskell? For some reason my search results won't load.
10:19:10 <johnw> yes, that's haskell-announce
10:20:27 <zipper> johnw: So haskell cafe and haskell-announce?
10:25:11 <johnw> that's two of them
10:30:25 <Kaidelong> I really think allowing partial type signatures are a good idea
10:31:03 <Kaidelong> the type system doesn't allow enough encapsulation of implementation details
10:31:30 <merijn> Kaidelong: Word.
10:31:32 <Yaniel> can someone explain currying to me?
10:31:35 <johnw> example?
10:31:51 <merijn> Kaidelong: At least, by partial type system you mean a "I can't be arsed to write this" marker for inside types?
10:31:55 <Hafydd> @src curry
10:31:55 <lambdabot> curry f x y = f (x, y)
10:31:59 <Yaniel> I understand it means calling a function with another function as its argument to get "more arguments to one function"
10:32:02 <Hafydd> There's your explanation.
10:32:04 <milfjord> Yaniel: no
10:32:18 <milfjord> Yaniel: it's the opposite (returning a function from another function)
10:32:23 <Kaidelong> merijn: I think so, kind of like type holes right now but actually allowed to compile and also respected by Haddock
10:32:39 <notdan> @ty curry
10:32:40 <lambdabot> ((a, b) -> c) -> a -> b -> c
10:32:40 <milfjord> Yaniel: what programming languages do you know?
10:32:41 <notdan> @ty uncurry
10:32:42 <lambdabot> (a -> b -> c) -> (a, b) -> c
10:32:48 <johnw> Yaniel: http://en.wikipedia.org/wiki/Currying
10:33:03 <merijn> Kaidelong: Right, so basically a placeholder with "whatever this happens to unify with" rather than a type variable. I've frequently wanted that to partially specify my types
10:33:13 <intrados> When profiling, would excess laziness only show up as high % in GC or are there other ways it might present?
10:33:29 <johnw> what is "excess laziness"?
10:33:33 <merijn> intrados: excess laziness would usually show up as either stack overflow or memory leak
10:33:37 <Kaidelong> johnw: ST is probably the best example, you rarely ever care about what the first parameter in ST actually is, you may as well just write ST _ t
10:33:38 <tomejaguar> merijn: Do you want it while prototyping, or do you want to leave signatures like that in the completed code?
10:33:39 <johnw> you mean, too many unevaluated thunks?
10:33:47 <johnw> Kaidelong: ah
10:33:48 <merijn> tomejaguar: Both would be fine by me
10:33:57 <Yaniel> so.. like defining f as g(x) with a certain value of x?
10:34:20 <merijn> tomejaguar: For example, with lens I would know the outer bit looks like "Foo (Bar _) _" but I'm not quite sure what _ is supposed to be
10:34:33 <milfjord> Yaniel: I want to establish common vocabulary
10:34:34 <Kaidelong> johnw: it also prevents people from going on wild goose chases when reading your haddock files by hiding UnimportantDataType behind _
10:34:40 <merijn> tomejaguar: Or if I need a long complex type (due to some type level encoding) and I just can't be arsed to write all of it
10:34:40 <intrados> johnw: In this context, I mean that the program takes longer to run than it would under an optimal balance of strictness/laziness
10:35:13 <Kaidelong> as well as not making them write UnimportantDataType in their own signatures
10:35:31 <mm_burea1> Yaniel: instead of taking two arguments, take one argument and return a function…  that's currying =)
10:35:37 <merijn> tomejaguar: Basically I want to partially specify something because I know the "rough" shape of the type, but not the complete type and I don't want to let the compiler infer it because 1) it can't (think RankNTypes) or 2) it infers something way to general
10:35:43 <Yaniel> milfjord: C, java, python; studied haskell for about a week's worth
10:35:55 <milfjord> Yaniel: python works best for this
10:36:04 <merijn> tomejaguar: However you can't use type variables as those can unify with *anything*, whereas I want to write "just fill in what you're inferring here"
10:36:07 <milfjord> Yaniel: instead of f(x, y) you do f(x)(y)
10:36:09 <Kaidelong> Yaniel: "defining f as g(x) with a certain x" is exactly right
10:36:11 <mm_burea1> curried:  lambda x: lambda y: …
10:36:11 <tomejaguar> RankNTypes is a nice example.  You might be able to specify enough to make it derivable, but not want to write it all.
10:36:16 <mm_burea1> not curried:  lambda x y: …
10:36:22 <merijn> tomejaguar: Right
10:36:39 <mm_burea1> note that in haskell "\x y ->" is the same as "\x -> \y -> …"
10:36:48 <mm_burea1> haskell is curried by default, while most languages are uncurried by default
10:37:01 <milfjord> most languages have a special construct called a "parameter list"
10:37:17 <Kaidelong> Yaniel: in haskell currying works because functions of multiple arguments are generally implemented as functions that return functions, so by default f x y == (f x) y, f x makes a function that then takes y
10:37:22 <milfjord> if everything's curried, every function takes exactly one argument
10:37:24 <Kaidelong> you don't think about it much
10:37:58 <Kaidelong> there are some languages like Javascript where you need to worry more explicitly about currying because it's not the default behavior and it has greater implications for how things actually work
10:38:59 <milfjord> in javascript you have to write something clumsy like function f(x) { return function (y) { ... }; }
10:39:00 <Kaidelong> but in haskell you can just think of functions as sometimes not being fully applied
10:39:06 <Kaidelong> example:
10:39:11 <Kaidelong> @ty 5 + 5
10:39:12 <lambdabot> Num a => a
10:39:17 <Kaidelong> @ty (5 +)
10:39:18 <lambdabot> Num a => a -> a
10:39:18 <milfjord> and in python you have to be even more verbose and define a named inner function
10:40:13 <tomejaguar> I belive GHC is clever and compiles specialised version for each partial application.
10:40:46 <tomejaguar> (Of function definitions)
10:40:52 <Yaniel> ah right and because of lazy evaluation unknown arguments don't matter?
10:41:02 <Kaidelong> no, nothing to do with evaluation strategy
10:41:05 <mm_bureau> Yaniel: there is no such thing as an unknown argument
10:41:15 <Yaniel> well if I define foo x y z
10:41:29 <mm_bureau> Yaniel: then 'foo x' is a function that takes two arguments
10:41:32 <Kaidelong> all ML-likes do functions this way, not just haskell
10:41:45 <Kaidelong> and most of the ML-likes do strict evaluation
10:41:49 <mm_bureau> Yaniel: then 'foo x y' is a function that takes one argument
10:41:59 <mm_bureau> and 'foo x y z' is whatever you defined it to be
10:42:15 <mm_bureau> @let func x y z = x*y + z :: Integer
10:42:16 <pjdelport> milfjord: you can decorate with partial(partial, partial) in Python
10:42:16 <lambdabot>  Defined.
10:42:17 <Yaniel> so (((foo x) y) z) ?
10:42:17 <pjdelport> but yeah
10:42:21 <mm_bureau> Yaniel: see here:
10:42:22 <Kaidelong> the main thing lazy evaluation allows is as far as function arguments go is letting you say "notReallyAFunction" rather than "notReallyAFunction()"
10:42:26 <mm_bureau> :t func
10:42:26 <lambdabot> Integer -> Integer -> Integer -> Integer
10:42:34 <mm_bureau> func is now a function that takes four arguments
10:42:41 <mm_bureau> uhm
10:42:42 <mm_bureau> three
10:42:50 <milfjord> > length [x,y,z]
10:42:51 <mm_bureau> but in reality it takes a single argument and returns a function that takes another two arguments
10:42:52 <lambdabot>  3
10:43:03 <johnw> Kaidelong: even C lets you refer to a function as a value by mentioning its name
10:43:07 <mm_bureau> Integer -> Integer -> Integer -> Integer = Integer -> (Integer -> Integer -> Integer)
10:43:14 <milfjord> > (((func 1) 2) 3)
10:43:16 <lambdabot>  5
10:43:17 <johnw> so I wouldn't call that the "main thing lazy evaluation allows"
10:43:20 <mm_bureau> look at the type of 'func 3', i.e. func applied to one argument
10:43:20 <Kaidelong> johnw: that's not what I was talking about
10:43:22 <mm_bureau> :t func 3
10:43:23 <lambdabot> Integer -> Integer -> Integer
10:43:47 <Kaidelong> johnw: in ML making things of type () -> a is how you defer evaluation of a until it is actually needed
10:43:47 <mm_bureau> then to two arguments:
10:43:51 <mm_bureau> :t func 3 5
10:43:52 <lambdabot> Integer -> Integer
10:43:54 <merijn> johnw: You mean when you take the address of it's name :p
10:44:02 <johnw> right
10:44:06 <johnw> Kaidelong: ah
10:44:06 <mm_bureau> this is the function which takes an argument z and returns 3*5 + z
10:44:16 <merijn> johnw: If you see people write "foo" instead of "&foo" to assign function pointers, slap them
10:44:22 <milfjord> merijn: names don't have addresses
10:44:28 <mm_bureau> Yaniel: does that make sense?
10:44:35 <milfjord> merijn: I'll punch you
10:44:37 <Yaniel> let me think about it for a moment
10:44:50 <mm_bureau> Yaniel: try to read everybody's messages in isolation =)
10:44:54 <milfjord> merijn: why would you ever use &foo?
10:44:57 <cariveri> hi. whats a good way to skip head until head is equivalent to a specific elem?
10:45:00 <merijn> milfjord: Did I misremember? I remember checking the standard on this...
10:45:02 <mm_bureau> Yaniel: you've had around five people explain currying in different ways now =)
10:45:04 <milfjord> cariveri: dropWhile
10:45:09 <mm_bureau> Yaniel: which is the downside of a very helpful channel =)
10:45:14 <merijn> To the standard mobile!
10:45:52 <Yaniel> hehe
10:46:52 <Yaniel> yeah I guess the (((foo x) y) z) example explains it
10:47:13 <mm_bureau> Yaniel: application is left associative: f x y = (f x) y
10:47:23 <milfjord> -> in types is right associative
10:47:29 <mm_bureau> and correspondingly the function arrow is right-associative:  a -> b -> c = a -> (b -> c)
10:47:34 <pjdelport> Yaniel: something that should be mentioned is the difference between implicit and explicit currying
10:47:51 <mm_bureau> pjdelport: that's misleading
10:48:02 <cariveri> milfjord: thanks. its nice.
10:48:02 <mm_bureau> there is a concept called currying and a process called currying
10:48:13 <Yaniel> I was a bit confused by thinking of something like foo(\( \( \(z) ) y) x) ie. isolating the function from the arguments
10:48:14 <mm_bureau> the concept is about functions returning functions to emulate multiple arguments
10:48:16 <ocfx> curry is yummy
10:48:20 <pjdelport> currying is not unique to functional languages like Haskell: it's a general transformation that you can apply in any language (with first-class functions)
10:48:31 <mm_bureau> the process is about converting an uncurried function to its curried form
10:48:52 <pjdelport> so in Haskell, functions are implicitly curried by default
10:49:08 <mm_bureau> Yaniel: here is an example of currying in action:
10:49:08 <pjdelport> but in Scheme or Python or so on you can still curry functions explicitly
10:49:19 <mm_bureau> > concatMap (replicate 3) "abcd"
10:49:20 <lambdabot>  "aaabbbcccddd"
10:49:32 <mm_bureau> replicate takes two arguments
10:49:39 <simpson> Currying depends on calling convention.
10:49:40 <mm_bureau> but if you apply only one argument, you get a function as result
10:49:49 <Yaniel> ah
10:50:00 <Yaniel> yeah
10:50:00 <merijn> milfjord: "The operand of the unary & operator shall be either a function designator,"
10:50:11 <merijn> milfjord: 6.5.3.2.1
10:50:12 <milfjord> merijn: #haskell-blah?
10:50:15 <mm_bureau> that's why you write just "concatMap (replicate 3)" instead of "concatMap (\x -> replicate 3 x)"
10:50:36 <bgamari> Does anyone else agree with me that Hoogle is a bit confused about the first result here? http://www.haskell.org/hoogle/?hoogle=runStateT
10:50:51 <bgamari> Namely runStateT :: StateT s a -> s -> m (a, s)
10:51:07 <bgamari> very odd
10:51:29 <Kaidelong> that is strange
10:51:35 <mm_bureau> and here is the view from above:
10:51:47 <mm_bureau> replicate :: Int -> a -> [a]
10:51:53 <mm_bureau> so:  replicate :: Int -> (a -> [a])
10:51:58 <mm_bureau> (because they are the same by law)
10:51:59 <Kaidelong> maybe one of them is from an older version of mtl?
10:52:20 <mm_bureau> so:  replicate 3 :: a -> [a]
10:52:36 <Yaniel> thanks for the clarification!
10:53:26 <mm_bureau> Yaniel: currying is also the reason why you get this unusual arrow notation for function types =)
10:53:27 <Yaniel> I need to think of functions more as "objects" instead of as "procedures" I guess
10:53:36 <Yaniel> yeah
10:53:39 <mm_bureau> Yaniel: as functions
10:53:43 <mm_bureau> in the math sense
10:53:44 <pjdelport> Yaniel: if you're interested, you can also read about partial application, of which currying can be considered a special case
10:53:58 <mm_bureau> Yaniel: you can have currying in math
10:54:04 <Kaidelong> mm_bureau: I think it's actually because mathematicians use the arrow notation
10:54:12 <mm_bureau> uncurried:  f : ℕ×ℤ → ℝ
10:54:21 <mm_bureau> curried:  f : ℕ → (ℤ → ℝ)
10:54:52 <mm_bureau> Kaidelong: yes, but haskell does not bother providing a shorter syntax, because it wouldn't make sense
10:55:00 <tomejaguar> Mathematicians don't like currying much.  It confuses them for some reason.
10:55:08 <mm_bureau> yeah, indeed
10:55:32 <mm_bureau> probably because their function application syntax is a bit weird =)
10:55:34 <mm_bureau> f(x)
10:55:45 <Kaidelong> tomejaguar: It doesn't really matter that much cause it turns out a -> (b -> c) and (a,b) -> c are isomorphic
10:55:52 <Kaidelong> you can just rewrite the one to the other
10:55:54 <mm_bureau> that makes curried application syntax even weirder:  f(x)(y)
10:55:57 <Yaniel> heh, so haskell-like "this is just math... but it mathematicians hate it"
10:56:13 <Kaidelong> mathematicians have no authority when it comes to notation
10:56:23 <Kaidelong> if you don't believe me look at a textbook on linear algebra
10:56:33 <milfjord> mathematicians haven't yet figured out that you can combine letters to form words
10:56:55 <Yaniel> I only need to look at the slides from my last la course for that...
10:57:03 <mm_bureau> Yaniel: we do quite a bunch of math stuff that many mathematicians don't like =)
10:57:15 <mm_bureau> Yaniel: for example we use type theory instead of set theory
10:57:19 <Yaniel> I've noticed :D
10:57:38 <kristof> mm_bureau: are you mmfreak in disguise
10:57:43 <Yaniel> and lambdas... lots of them
10:57:50 * mm_bureau is da mm_freak in da bureau
10:57:56 <mm_bureau> kristof: /whois mm_bureau
10:57:56 <kristof> which burea is that?
10:57:57 <mm_bureau> =)
10:57:58 <tomejaguar> Computer scientists do a lot of things better than mathematicians.
10:58:06 <kristof> tomejaguar: not math, certaintly
10:58:06 <mm_bureau> kristof: my bureau =)
10:58:10 <kristof> *certainly.
10:58:10 <mm_bureau> i'm at work
10:58:14 <Kaidelong> mm_bureau: what is the difference exactly?
10:58:15 <kristof> mm_bureau: Which work is that?
10:58:25 <Kaidelong> I thought types were just sets
10:58:36 <mm_bureau> Kaidelong: the difference is that we don't need arbitrary axioms for defining natural numbers =)
10:58:43 <mm_bureau> kristof: i'm a programmer
10:58:50 <intrados> Is my intuition that `mapM_ print (foldMap foo vec)` should print elements "as they become available" wrong?
10:58:50 <intrados>  
10:59:08 <rgr> I'd like to replace some external calls to scripts which use Zenity for user IO (confirm to quit pretty much) and would be interested in doing it directly using haskell and some sort of gui binding : what would you recommend I look it?
11:00:14 <mm_bureau> rgr: the common ones are GTK+ and wx
11:00:21 <milfjord> intrados: ghc -e 'mapM_ print [0 ..]'
11:00:40 <mm_bureau> rgr: unless you want to write a fancy OpenGL confirmation dialog =)
11:00:45 <intrados> milfjord: Okay, thanks. That's what I thought. Something else must be going on...
11:00:47 <rgr> no. but googling gtk+ and haskell is less than forthcoming. Im pretty new to haskell.
11:01:11 <kristof> rgr: You'd have to have haskell language bindings to gtk+
11:01:29 <mm_bureau> rgr: http://projects.haskell.org/gtk2hs/
11:01:34 <kristof> if those don't exist... I guess you could call the c bindings from haskell instead?
11:01:45 <rgr> thats kind of what Im asking. Are there no cabal libraries for basic user IO using pop up widgets?
11:01:46 <kristof> mm_bureau: I read that as "gtk2" and almost interjected
11:02:10 <rgr> ah ok
11:02:20 <kristof> rgr: Well what you're actually asking is "are there no cabal libraries for interoperating with a widget toolkit"... which implies language bindings to GTK
11:02:52 <rgr> well yes. Obviously. Thanks.
11:03:13 <kristof> that felt like a sarcastic thanks :(
11:03:16 * kristof scampers away
11:03:18 <mm_bureau> indeed
11:17:17 <prophile> does anyone know offhand of some kind of Future type implementing Alternative for racing values?
11:17:45 <prophile> (or at least, "return the value that occurs first")
11:18:58 <prophile> because it occurs to me that Conal Elliott's frp types are Cofree Future
11:19:05 <tomejaguar> prophile: How about this?  https://www.fpcomplete.com/hoogle?q=race
11:19:42 <prophile> ah yes, async has the Concurrently type doesn't it?
11:19:59 <johnw> yes
11:20:15 <prophile> I wonder if it satisfies left-catch too
11:20:48 <nikita_> I am trying to install lesksah via cabal, but runing cabal install leksah gives me error:
11:20:50 <nikita_> src/Text/PrinterParser.hs:230:42: Not in scope: `catch' Failed to install ltk-0.8.0.6
11:21:43 <Jeanne-Kamikaze> reminds me of old ghc 7.03 package
11:22:15 <Jeanne-Kamikaze> you could contact the maintainer if that's the case
11:22:53 <dhrosa> jthe "catch" function has been moved around to a different module, O've had that problem with another package too
11:23:30 <nikita_> and what did you do?
11:24:33 <mm_bureau> prophile: what's Future?
11:25:12 <prophile> in a very informal sense a "value which may not yet have arrived"
11:25:47 <Forgetaboutit> prophile: Is there  a difference to a promise?
11:26:03 <prophile> Forgetaboutit: synonymous as far as I understand
11:26:36 <mm_bureau> prophile: how is that related to FRP?
11:27:36 <prophile> mm_bureau: Conal Elliott wrote a paper defining reactives/behaviours in terms of futures
11:27:43 <prophile> http://conal.net/papers/push-pull-frp/push-pull-frp.pdf
11:28:57 <conal> that push-pull work, and particularly the future values, came out of an attempt to have a practical implementation that is very close to the denotation.
11:30:31 <conal> The trick is to use a non-flat type of times, so that one can learn something about min s t without fully knowing either s or t yet.
11:30:39 <prophile> I guess I shouldn't be surprised any more when everyone's actually in #haskell
11:30:41 <prophile> (hi!)
11:31:25 <prophile> conal: this is the thing for adding upper and lower bounds to times?
11:31:42 <conal> prophile: that's part of it.
11:32:08 <conal> prophile: warren burton explored similar ideas in the 80s. great stuff.
11:32:25 <conal> prophile: "improving values" and "improving intervals".
11:32:37 <conal> ... along with his student ken jackson.
11:33:13 * prophile reads some things
11:33:56 <kazagistar> does anyone know of a "unused symbol finder" tool? Something that searches for chains of random symbols that no one has used before in another haskell package?
11:36:22 <quchen> kazagistar: I'm not sure how he did it, but edwardk did a search like this to find out how to name the lens functions.
11:36:33 <quchen> He's not online right now though.
11:38:25 <shachaf> ezyang has a list of all the operator (infix) names in hackage by how often they're defined
11:40:08 <joelteon> where is it?
11:40:15 <mm_bureau> ah
11:41:46 <intrados> Does it make sense that `foldmap id` seems to be asymptotically worse than `V.concat . V.toList`? http://lpaste.net/99783
11:43:09 * hackagebot yaml 0.8.7.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.7.1 (MichaelSnoyman)
11:53:45 <tomejaguar> intrados: I guess foldMap is creating a lot of intermediate Vectors.
12:00:01 <tomejaguar> (Which would make it O(n^2))
12:00:29 <xintron> Is it a problem having multiple threads doing read/writes to one single socket Handle at the same time?
12:01:31 <Forgetaboutit> what does a `forall` in a type signature mean?
12:02:11 <magneticduck> forgetaboutit
12:02:13 <magneticduck> heh
12:02:21 <magneticduck> it's what forall means anywhere else
12:02:37 <magneticduck> (forall a) => a -> a
12:02:44 <magneticduck> is a function that, for any type a, represents a function on that type
12:04:00 <WraithM> Is there a good way to read Text to an Int?
12:04:04 <Forgetaboutit> magneticduck: I'm not sure I understand.  What kind of function on a type?
12:04:32 <magneticduck> it's a function f for that, if (A : a), ((f a) : a)
12:04:42 <magneticduck> for any value of type a, it returns a value of tyep a
12:04:46 <magneticduck> s/tyep/type
12:05:13 <erisco> Forgetaboutit, "forall A ..." means the function is defined for all members of type A
12:05:22 <lpsmith> hey, I don't suppose somebody with a mac and ghc handy could do me a quick favor?
12:05:38 <Forgetaboutit> magneticduck: I saw `forall` in a function, specifically this one: forall typ. PersistField typ => Update
12:05:56 <tomejaguar> 'forall a. < type expression involving a >' means that the caller can choose a specific type to substitute for 'a'.
12:05:58 <erisco> Forgetaboutit, but in Haskell this does not mean the function necessarily "works" for all members of type A... so that is potentially confusing
12:06:09 <exicer> If I have [Pair x y], and a function addPair :: Pair a b -> Pair c d -> Maybe Pair e f, is there some function that lets me fold using addPair? I can think of a few ways to do it, but all are ugly!
12:06:28 <magneticduck> Forgetaboutit: that's not the whole function, right? O.o
12:06:37 <exicer> The goal being to get Maybe (Pair x y)
12:06:49 <magneticduck> (that's not a function, and it doesn't make sense as a value)
12:07:20 <magneticduck> exicer: you want monads!
12:07:23 <magneticduck> monads to the rescue
12:07:34 <magneticduck> @type (>>=)
12:07:35 <Forgetaboutit> magneticduck: uh, no.  It's a constructur following.  I just left it out because I want to understand its type first :).
12:07:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:07:57 <magneticduck> exicer: look good? =P
12:08:01 <magneticduck> well
12:08:04 <supki> WraithM: there's Data.Text.Read
12:08:12 <tomejaguar> That doesn't look like it has anything to do with monads.  exicer: you'll have to be more specific.  Your question doesn't seem to make much sense.
12:08:19 <erisco> Forgetaboutit, I believe "forall" is only used for scoped type variables (in Haskell), but I may be mistaken
12:08:42 <tomejaguar> Not only.  It's also used in RankNTypes, ExistentialTypes ...
12:09:02 <erisco> okay, so one of those too then
12:09:40 <Forgetaboutit> Ok, as I'm still pretty new to Haskell, do I need to care right now?  I still don't understand the difference between `forall a => a -> a` and `a -> a`
12:09:40 <Forgetaboutit>  
12:09:47 <erisco> I think it is just an notational excuse to assign names to types... ie the tacit quantifier on type variables is always "forall"
12:09:55 <magneticduck> Forgetaboutit: forget about it =P
12:10:08 <magneticduck> there isn't, really
12:10:11 <tomejaguar> 'forall a => a -> a' is not a valid type signature.  You probably mean 'forall a. a -> a'.  'a -> a' is a shorthand for it.
12:10:18 <magneticduck> yeah
12:10:20 <exicer> tomejaguar: Hm, well I have a datatype with a function to add them together. So, addPairs (Pair a b) (Pair c d) can only work if a and c are equal, giving either Just (Pair a (b + d)) or Nothing. I have a list of such pairs, and would like to reduce them to a single Maybe Pair !
12:10:58 <tomejaguar> But in [Pair a b] all the first types are equal and all the second types are equal!
12:11:12 <Forgetaboutit> magneticduck: I will :).  Man, I didn't think about everybody making bad puns about my nick, it was only intended to be done myself ;).
12:11:25 <magneticduck> it was a bad pun?
12:11:30 <exicer> tomejaguar: Uh, the first types are, but the second types are not ?
12:11:30 <jrmithdobbs> exicer: so it's not really Pair a b -> Pair c d -> Maybe (Pair e f) it's Pair a b -> Pair a c -> Pair a d
12:11:41 <Forgetaboutit> magneticduck: Not specifically, at least :)
12:11:45 <exicer> jrmithdobbs: Yes
12:11:52 <jrmithdobbs> there's a big difference thre
12:11:59 <tomejaguar> But still, how are you creating a list of them?
12:12:01 <exicer> Ah, I suppose taht is true
12:12:07 <exicer> tomejaguar: It comes from parsing a webpage
12:12:09 <pjdelport> Forgetaboutit: some of http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do and https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#The_forall_keyword may be interesting
12:12:22 <jrmithdobbs> exicer: is Pair a functor?
12:12:25 <tomejaguar> You can't have a list of type [Pair a b] where the types of the b differ.  By definition they're all the same!
12:12:31 <exicer> Not at the moment, but it could be
12:12:40 <Forgetaboutit> pjdelport: Thanks, will look into that!
12:12:42 <exicer> tomejaguar: Sorry! the types are the same, the values differ.
12:12:45 <quchen> (Pair a) can be a Functor.
12:13:01 <jrmithdobbs> exicer: just make (Pair a) a functor and it'll be fine
12:13:09 <erisco> what is the point of Pair a b? why not (a, b)? The purpose of "Pair" is usually Pair a a
12:13:21 <exicer> quchen: jrmithdobbs: Oh man, that is true. I've never actually made my own functor.
12:13:28 <pjdelport> Forgetaboutit: you can think of forall as lambda at the type level
12:13:40 <tomejaguar> exicer: Do you mean that you have 'Pair a b -> Pair a b -> Maybe (Pair a b)'?
12:13:42 <exicer> erisco: This is actually a simplification, it is a more complicated datatype that stores info from a page
12:13:43 <jrmithdobbs> exicer: can probably derive it, even, with -XDeriveFunctor
12:13:55 <exicer> tomejaguar: I do, I am a poor type signature write :(
12:14:12 <quchen> Before you derive a Functor, you should probably know how to define the instance yourself.
12:14:30 <exicer> quchen: I'm pretty sure I can. I'll have a go, and come back if I get stuck.
12:14:39 <tomejaguar> exicer: Then I think you want 'foldM'.  (You don't need a Functor instance, despite how exciting that may sound).
12:14:49 <quchen> data Pair a b = Pair a b; instance Pair <fill this in>
12:14:55 <Forgetaboutit> pjdelport: Does that mean I can somehow restrict `a` in `forall a. a -> a`?
12:15:10 <pjdelport> given a type like map :: forall a b. (a -> b) -> [a] -> [b] you "instantiate" it by supplying specific types for a and b
12:15:12 <tomejaguar> Forgetaboutit: You can restrict it to a concrete type.
12:15:29 <erisco> tomejaguar, that was a mistake though, so may as well instance Functor too
12:15:30 <haasn> (you can also restrict it to a more specific polymorphic type)
12:15:32 <pjdelport> that usually happens without you having to think about it, and the forall is generally implied and left out
12:15:35 <haasn> :t id `asAppliedTo` []
12:15:36 <lambdabot> [a] -> [a]
12:16:17 <erisco> :t asAppliedTo
12:16:17 <lambdabot> (a -> b) -> a -> a -> b
12:16:35 <Forgetaboutit> pjdelport: ok, so it's only necessary to use it explicitly in which cases?
12:16:36 <quchen> asAppliedTo = const :: (a -> b) -> a -> (a -> b)
12:16:49 <tomejaguar> exicer: Well then I'm confused as to what you want, but I think you should check out 'foldM'.
12:17:01 <pjdelport> Forgetaboutit: those links i gave explain a couple of cases
12:17:18 <pjdelport> existential types are one common one
12:17:26 <jrmithdobbs> tomejaguar: he wants to be able to fmap or bimap, one of the two (i'm unclear as well)
12:17:46 <Forgetaboutit> pjdelport: So many new things to learn, hehe.
12:18:13 * hackagebot hedis 0.6.4 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.4 (FalkoPeters)
12:18:16 <pjdelport> look at https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists for example
12:18:25 <tomejaguar> jrmithdobbs: I don't think so.  He wants to fold with a function like 'A -> A -> Maybe A'.
12:18:26 <supki> mm_bureau: any chance you'll release netwire-4.* with relaxed profunctors/bifunctors bounds eventually?
12:18:34 <Forgetaboutit> pjdelport: I guess Haskell is the only language so far where there's no shortcut to learn
12:18:55 <haasn> the others that come to mind are scoped type vars, rank-n types and probably some obscure corner case involving polykinds and datakinds
12:19:25 <jrmithdobbs> tomejaguar: no i think the maybe came from his not noticing it was Pair a b -> Pair a c -> Pair a d and thinking it was a b/c d/e f
12:19:34 <quchen> :t let addPair :: (a,b) -> (a,b) -> Maybe (a,b); addPair = undefined; pairs :: [(a,b)]; pairs = undefined in foldM addPair -- exicer
12:19:35 <lambdabot> (a, b) -> [(a, b)] -> Maybe (a, b)
12:19:54 <quchen> Actually the 'pairs' part is redundant
12:20:04 <quchen> Anyway, foldM for the Maybe Monad
12:20:19 <tomejaguar> jrmithdobbs: Oh, well earlier he claimed he wanted to reduce a list.  So I don't know ...
12:21:10 <pjdelport> Forgetaboutit: It's always rewarding! Haskell just packs the knowledge very densely and without fluff. :)
12:24:48 <Forgetaboutit> pjdelport: I see.  Can you recommend "advanced introductions"?  I read "Learn you a Haskell for great good" so far and now I'm kinda stuck with how to approach the more advanced stuff.
12:25:07 <pjdelport> it depends entirely on what you're interested in
12:25:09 <tomejaguar> Forgetaboutit: Graham Hutton's book is supposed to be good.
12:25:22 <supki> mm_bureau: (it builds without any changes with the latest versions of both profunctors and bifunctors AFAICT)
12:25:29 <quchen> It's even more basic than LYAH though, tomejaguar.
12:25:44 <quchen> After LYAH there's RWH and then you're on your own for the most part.
12:26:19 <Forgetaboutit> pjdelport: Everything :D
12:26:21 <tomejaguar> Oh I thought it was supposed to be quite advanced.
12:27:03 <quchen> On your own means you won't find many long and coherent books/articles anymore, just small snippets. You then write code, learn your way around the library ecosystem, and read interesting blog posts.
12:27:03 <tomejaguar> I've never read a Haskell book though.
12:27:21 <pjdelport> Forgetaboutit: as a research vehicle, there's probably more to learn about Haskell than you can ever fit into a lifetime (unless your name is Oleg)
12:27:24 <tomejaguar> Yeah that's basically what I did.  It's an OK method I think.
12:28:18 <erisco> Forgetaboutit, what parts of the language are you shaky on?
12:28:35 <Forgetaboutit> Ah ok.  Are you guys also reading papers or do you stick to blog posts etc. pp.?
12:28:44 <mornfall> pjdelport: I guess Пётр wouldn't work? :P
12:29:06 <quchen> Papers can be interesting, but they're usually very specific. I don't think they make a good companion on the way to becoming an intermediate.
12:29:25 <mornfall> quchen: depends on where your intermediate happens to be
12:29:26 <quchen> They typically tackle advanced problems you may not even be aware of.
12:29:40 <erisco> ie the language itself is one thing (syntax, semantics), and applications of the language is something else
12:29:45 <Forgetaboutit> erisco: I only read LYAH and some parts of RWH.  So I'm not very proficient in general.
12:29:53 <pjdelport> Forgetaboutit: you could always just systematically work your way through the common abstractions (Functor, Monoid, Monad, Applicative, ...)
12:29:55 <kristof> Don't read some parts of RWH. Read all of it!
12:30:01 <tomejaguar> I think one of the things that helped me learn Haskell was hanging out here, and the other was reading Haskell Reddit.
12:30:06 <mornfall> Forgetaboutit: do you have background in some other language, say ML?
12:30:16 <pjdelport> understanding and getting an intuition for them, and how they're related
12:30:20 <erisco> after you know most of the syntax and semantics, you are then able to apply the language to general problems
12:30:29 <quchen> RWH is half an advanced recap of LYAH and half a safari through common libraries.
12:30:51 <quchen> tomejaguar: #haskell osmosis! :-)
12:30:54 <erisco> and there is no "general problem" book... so you need to pick something you want to actually research/develop and start experimenting
12:30:56 <kristof> Forgetaboutit: What quchen just said. Personally, I think "programming in the large" in a language like Haskell has no immediate resource, and deserves one.
12:31:22 <mornfall> kristof: I don't think programming in the large has an immediate resource in any language
12:31:23 <kristof> Which is a shame, because the level of abstraction from which you can comfortably work with in Haskell is... very, very high up.
12:31:24 <pjdelport> and yeah, http://www.reddit.com/r/haskell and http://stackoverflow.com/questions/tagged/haskell
12:31:48 <kristof> mornfall: Well, I meant something like GOF Design Patterns that OO software engineers swear by
12:32:03 <pjdelport> kristof: and also swear by
12:32:07 <mornfall> kristof: that won't teach you half the stuff you need to know though
12:32:23 <Forgetaboutit> mornfall: I learned a lot about Lisps and the usual mainstream languages.  I wouldn't call me experienced in any language, however, since I've only worked for one and a half years more professionally on programming.
12:32:44 <Forgetaboutit> kristof: I sure intend to :)
12:33:01 <nineczar> sorry to interrupt, but does anyone know how to make show on a double not do scientific notation
12:33:14 * hackagebot hedis 0.6.5 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.5 (FalkoPeters)
12:33:22 <erisco> nineczar, do not use show
12:33:25 <mornfall> nineczar: you'll probably need a different printer
12:33:37 <erisco> nineczar, or make a newtype wrapper and your own Show instance
12:33:46 <rgr> one of the lovely things about learning this language is there is no shortcuts. You have to read. And read again. Type Classes in learnyouahaskell being a great example. read it. pause. What? back again...
12:33:48 <simpson> nineczar: What do you want it to show?
12:33:59 <nineczar> just a double
12:34:11 <nineczar> well actually a list of doubles but the list part isn't a problem
12:34:26 <mornfall> rgr: what would be an example of a shortcut in "other languages"?
12:34:27 <simpson> > 3.1415926 -- what's wrong with this?
12:34:28 * quchen is confused by what people mean with languages and shortcuts.
12:34:29 <lambdabot>  3.1415926
12:35:25 <mornfall> > 123456.654321
12:35:25 <lambdabot>  123456.654321
12:35:45 <notdan> shortcut as in: do not learn anything and try to produce code?
12:35:47 <triliyn> > 3 :: Double
12:35:48 <lambdabot>  3.0
12:35:56 <erisco> > 30!
12:35:57 <lambdabot>  <hint>:1:4:
12:35:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:35:59 <mornfall> notdan: how is haskell different? :)
12:36:01 <erisco> oops :(
12:36:05 <rgr> being a seasoned programmer and just learning the new APIs and slightly different constraints its easy to skip along. With this I feel I need to be sure of each point before moving on. Possibly I mean moving or learning a functional language like this in general.
12:36:26 <nineczar> for whatever reason when I have a double that's 0.0211 and I show it I get 2.11e-2
12:36:43 <mornfall> rgr: works with haskell just fine ... you get in similar sorts of trouble too
12:37:00 <notdan> mornfall: not different at all, that's why I am baffled myself
12:37:01 <simpson> > show 0.0211
12:37:02 <lambdabot>  "2.11e-2"
12:37:08 <rgr> possibly I didnt make my point too well. It doesnt matter.
12:37:19 <simpson> nineczar: What's wrong with that, though? What are you building?
12:37:27 <quchen> nineczar: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-like-this-show-instance
12:37:48 <nineczar> its for a machine learning class and I just want the output to look almost exactly like the input
12:37:49 <rgr> but if you dont think its a stepper learning curve getting into Haskell for the first time over moving from say php to java I'm somewhat surprised. Still, whatever. All to their own.
12:37:54 <rgr> steeper
12:37:56 <nineczar> it's probably not an actual problem I just want to be thorough
12:38:15 * hackagebot lrucache 1.1.1.4 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.1.4 (CarlHowells)
12:40:14 <notdan> rgr: it's true in that it is a paradigm shift
12:40:17 <Forgetaboutit> rgr: I think it's because the languages themselves are not that different and becoming a better programmer often seems to mean learning the APIs instead of new concepts.
12:40:26 <notdan> rgr: but even with java you have to learn different OOP techniques, patterns and stuff
12:40:34 <nineczar> hmm, guess I'm just expecting too much from show. Thanks for the tips guys
12:40:58 <haasn> quchen: useful link
12:41:06 <quchen> nineczar: No, you're expecting the wrong thing from show.
12:41:15 <quchen> Not too much.
12:41:34 <nineczar> quchen: that's pretty much what I meant
12:41:44 <quchen> haasn: I got tired of teaching XChat autoreplace tokens for copypasta :-þ
12:42:03 <mornfall> Forgetaboutit: ah, but going from Java to C++11 is likely pretty tricky, even though maybe subtler than to Haskell
12:42:11 <rgr> like I said. its my experience from setup to concepts to types etc. There's nothing to compare the two. And to suggest moving to haskell isnt a major paradigm shift somewhat surprises me.
12:42:30 <mornfall> rgr: that largely depends on what you do in other languages
12:42:31 <Forgetaboutit> mornfall: because you get more ways to shoot yourself in the foot, right? ;)
12:42:45 <mornfall> Forgetaboutit: nah, just different ways
12:43:14 <pjdelport> Forgetaboutit: http://www.haskell.org/haskellwiki/Shooting_your_self_in_the_foot
12:43:17 <mornfall> you also get a turing-complete (well, up to a depth limit) compile-time language
12:43:28 <Forgetaboutit> mornfall: I would argue that Java protects you from some pitfalls, but I don't want to get into this discussion :)
12:43:36 <pjdelport> Forgetaboutit: you can track your learning process by how many of those jokes you understand :)
12:43:36 <haasn> mornfall: you get that in Haskell too!: )
12:43:43 <haasn> except without the depth limit I think.
12:43:54 <mornfall> haasn: do you mean TH or UndecidableInstances? :)
12:43:56 <quchen> haasn: The typechecker isn't Turing-complete, is it?
12:43:58 <haasn> mornfall: yes
12:43:59 <mornfall> TH doesn't really count
12:44:26 <haasn> quchen: is with UndecidableInstances
12:44:42 <quchen> haasn: Hmm. What does it do? (RTFM?)
12:44:43 <mornfall> haasn: you sure?
12:44:49 <Forgetaboutit> quchen: Didn't someone already implement a Turing-complete language on top of Haskell's type system?  I remember having read something about that somewhere ...
12:44:51 <sisban> hey! I am considering to use Haskell and Repa for matrix multiplication (using mmultP). Is there a way to get this to work with Complex values (not a Double array)?
12:45:06 <mornfall> quchen: it lifts the syntactic constraint on instance head size
12:45:19 <quchen> I have no idea what that means :-s
12:45:31 <mornfall> quchen: (which is a simple way to ensure termination -- each step shrinks the context)
12:45:52 <haasn> Forgetaboutit: it's relatively easy to embed a TC language on top of the type system
12:45:58 <haasn> with MPTCs and FunDeps or with TypeFamilies
12:46:06 <avpx> Forgetaboutit: There is an example of the SKI combinator calculus at the type level using UndecidableInstances
12:46:08 <mornfall> anyway, it doesn't exist in Java :-)
12:46:18 <avpx> Forgetaboutit: It's on the Wiki somewhere
12:46:20 <haasn> and probably more that I haven't though about :)
12:46:54 <erisco> can they do useful work though?
12:47:29 <haasn> SK seems easy, yes;  instance res ~ x => Eval (App (App K x) y) res
12:47:33 <haasn> similar for S
12:47:36 <haasn> erisco: certainly
12:47:46 <mornfall> erisco: ask Oleg about it
12:48:08 <haasn> erisco: you can use (Eval x ~ Result) as constraint for a function, for example
12:48:13 <Forgetaboutit> haasn, avpx: Wow, that sounds pretty amazing, but I don't understand a word :D
12:48:22 <haasn> erisco: you can even use it for instance selection!
12:48:43 <haasn> eg. see http://hub.darcs.net/nand/units for an example
12:49:31 <avpx> Forgetaboutit: SKI combinators are basically just a way to represent the lambda calculus with only three functions, called S, K, and I. You don't actually need I.
12:49:47 <mornfall> haasn: how does that compare to dimensional?
12:50:37 <haasn> mornfall: it's way more flexible, the syntax is cleaner and there's more TH magic to help you along
12:50:43 <haasn> it's also more modern (requires GHC 7.8 actually)
12:50:53 <erisco> I do not understand type families so I'll have to save that for another day
12:51:00 <haasn> mornfall: eg. see http://hub.darcs.net/nand/units/browse/src/Units/SI.hs
12:51:02 <mornfall> haasn: Yeah, I spotted DataKinds ;)
12:51:09 <haasn> those are all “user-defined” basically
12:51:16 <haasn> SI.hs doesn't need anything end-users don't have access to
12:51:44 <mornfall> I always found TH extremely unwieldy...
12:52:08 <sisban> Does anybody have experience with Repa and Complex values?
12:55:27 <thoughtpolice> haasn: looks similar to the units package (which also uses 7.8 closed type families to achieve a nice representation.)
12:55:43 <haasn> sisban: it seems to me that you might be able to just naively define mmult yourself on (Complex Double)
12:55:48 <haasn> same as http://hackage.haskell.org/package/repa-algorithms-3.2.4.1/docs/src/Data-Array-Repa-Algorithms-Matrix.html#mmultP
12:55:55 <haasn> I can't see anything that would obviously prevent it
12:56:06 <haasn> thoughtpolice: the units package? :)
12:56:24 <thoughtpolice> @hackage units
12:56:24 <lambdabot> http://hackage.haskell.org/package/units
12:56:26 <haasn> ah, indeed
12:56:40 <haasn> I think I remember collaborating with the author, even
12:56:43 <thoughtpolice> this was actually one of the examples in the Closed Type Families paper, since it makes defining new types in terms of other canonical types very easy
12:56:54 <thoughtpolice> (Richard also implemented closed type families themselves :P)
12:56:57 <haasn> it looks incredibly similar to mine!
12:58:01 <sisban> haasn: I see. For this I would use the Array defined in Data.Array.Repa.Algorithms.Complex?
13:00:08 <ocfx> > map (+1) [1..10]
13:00:09 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:00:11 <ocfx> ugh
13:00:19 <ocfx> when i try to run that on my own hosted one
13:00:20 <ocfx> it goes
13:00:22 <ocfx> terminated
13:00:55 <haasn> sisban: that doesn't even seem to define anything, other than its own silly Complex reimplementation!
13:01:04 <haasn> sisban: I would use the existing Complex from base or wherever
13:01:08 <haasn> since it's also strict, iirc
13:01:21 <sisban> Alright, thanks!
13:02:38 <haasn> quchen: https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x is this a bug?
13:02:52 <haasn> the haskell report clearly specifies (e op) = \ x -> e op x
13:03:36 <conal> modulo re-evaluation of 'e op', i hope.
13:05:00 <shachaf> I don't think the Report would specify anything about re-evaluation.
13:06:06 <thoughtpolice> haasn: http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2
13:06:14 <thoughtpolice> "As a consequence, ⊥ is not the same as \x -> ⊥, since seq can be used to distinguish them. For the same reason, the existence of seq weakens Haskell’s parametricity properties."
13:06:29 <ciaranm> there is no such thing as seq!
13:06:42 <tomejaguar> Also, somewhat related: http://cstheory.stackexchange.com/q/19165/18145
13:06:47 <shachaf> thoughtpolice: Yes, I think haasn is aware.
13:06:49 <mada> :t seq
13:06:49 <lambdabot> a -> b -> b
13:07:01 <mada> what exactly is seq?
13:07:02 <shachaf> Hence the issue with (x `op`) being _|_
13:07:14 <mada> force the evaluation of a and then of b?
13:07:33 <shachaf> I think this issue is not quite important enough to care about making GHC compliant.
13:07:41 <shachaf> I would probably rather have PostfixOperators go into the Report.
13:07:47 <tomejaguar> mada: Rough, "force a until you can see it's not _|_, then b"
13:07:54 <WraithM> Is there a better way to put an Int into a ByteString (encoded in ascii) than: Data.ByteString.Char8.pack . show
13:08:08 <thoughtpolice> oh, i misread. the *sections* are the complaint. i take back my annoying quote of the report
13:08:18 * hackagebot generic-maybe 0.3.0.1 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.3.0.1 (JonathanFischoff)
13:08:28 <shachaf> I think "then" is misleading.
13:08:49 <mada> tomejaguar: I see. I believe _|_ is bottom, right? what is that?
13:08:56 <shachaf> seq doesn't guarantee order of evaluation.
13:09:40 <tomejaguar> mada: Yes _|_ is bottom.  It's a concept from semantics of programming languages.
13:10:06 <mada> "a computation that never completes successfully", says the wiki
13:10:28 <WraithM> :t Data.ByteString.Char8.pack . show
13:10:28 <lambdabot> Show a => a -> BSC.ByteString
13:10:35 <theorbtwo> Is _|_ eqivelent to error "bottom" ?
13:10:41 <jrmithdobbs> mada: type "undefined" without quotes into ghci, that's bottom
13:11:03 <mada> > [1, 2, undefined]
13:11:04 <lambdabot>  [1,2,*Exception: Prelude.undefined
13:11:08 <quchen> theorbtwo: error x is bottom for all values of x.
13:11:51 <jrmithdobbs> > fromJust Nothing
13:11:52 <lambdabot>  *Exception: Maybe.fromJust: Nothing
13:12:02 <pantsman> git swt
13:12:06 <pantsman> oops
13:12:13 * shachaf sighs
13:13:30 <theorbtwo> Is there a point to the strange name, or is it just Haskell's normal from-the-other-angle nomenclature?
13:13:46 <zipper> In say f (f (f 0 1) 2) 3 where f is + a clear example being    (+) ( (+) ( (+) 0 1  ) 2 ) 3
13:14:01 <shachaf> theorbtwo: What name would you use?
13:14:06 <theorbtwo> shachaf: undefined.
13:14:20 <zipper> Do we start evaluation from the innermost bracket going out
13:14:20 <theorbtwo> Or, if you prefer, undef, nil, NULL, ...
13:14:22 <Earnestly> But _|_ is not undefined?
13:14:29 <mada> `bottom` does make it sound like "under everything else"
13:14:36 <shachaf> undefined is a particular example of _|_ which works by crashing your program.
13:14:42 <mada> or that one 'gets' to the bottom
13:15:00 <shachaf> There are other things that are also _|_, and (from the perspective of your program) indistinguishable from undefined.
13:15:06 <shachaf> For example, an infinite loop like let x = x in x
13:15:22 <zipper> or do we move from the left then reducing because we need the first argument's value to evvaluate the +
13:15:39 <quchen> mada: Maybe this talk helps a bit. https://vimeo.com/67174266
13:15:52 <shachaf> The reason for the name _|_ is that it's the bottom of a particular semilattice.
13:15:58 <shachaf> See e.g. http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
13:16:08 <quchen> Short version: you can defined a hierarchy of the definedness of things, and bottom is the lower end of things that are defined.
13:16:24 <theorbtwo> shachaf: So does that also splat, or does it infinitely loop?
13:16:39 <shachaf> That depends on your implementation of Haskell.
13:16:44 <theorbtwo> Fair enough.
13:16:45 <shachaf> GHC will catch it.
13:16:50 <mada> quchen: thank you
13:16:53 <shachaf> But there are infinite loops that GHC can't catch.
13:17:37 <quchen> mada: "undefined" has a bit of a misleading name here. It's a defined value (namely bottom), but it's used as a placeholder for code you haven't implemented yet.
13:17:44 <Earnestly> We always try to kludge the past up to explain the novel
13:18:06 <Earnestly> so _|_ should be called something else because it's similar to what I know even if it's not technically correct.  Right?
13:18:19 <theorbtwo> shachaf: Naturally; it would take an infinite amount of time to catch all infinite loops.
13:18:44 <shachaf> Well, _|_ exists the way it does because we can't solve the halting problem.
13:18:49 <Earnestly> Agda can do something about infinate loops iirc (but that's all I know)
13:19:06 <shachaf> Yes, there are other approaches.
13:19:24 <quchen> Earnestly: Not have them, that's Agda's solution to infinite loops.
13:19:32 <Earnestly> Right
13:20:01 <Cale> Earnestly: Essentially, by insisting that you structure your program so that it is its own termination proof.
13:22:20 <exicer> tomejaguar, quchen: Sorry for the confusion I caused! I went to get dinner. It turns out what I actually meant to do was use foldM, as quchen suggested. To clarify: I had a list of [(Pair a b)], and a function addPair :: Pair a b -> Pair a b -> Maybe Pair a b. The maybe comes from the fact that the a in Pair a b is a string, and addition can only happen if the strings are equal.
13:22:38 <exicer> I wanted to then reduce a list to a single Maybe Pair a b
13:25:01 <tomejaguar> OK, glad you've got it solved!
13:25:24 <zebr> hi all. is there a nice way to solve a problem like this?: http://sprunge.us/WLYC that is, i have a StateT X M Y and within it want to use a State X Y (i.e. StateT X Identity Y).
13:25:59 <notdan> hm, maybe hoist?
13:26:34 <notdan> http://hackage.haskell.org/package/mmorph-1.0.2/docs/Control-Monad-Morph.html#g:1
13:28:19 <tomejaguar> Yeah, I think it's 'hoist return' in this case. I don't know if there's a more standard name.
13:31:00 <zebr> ah, i got it to work with 'hoist generalize'
13:31:02 <zebr> thanks a lot :)
13:31:06 <notdan> tomejaguar: hoist generalize
13:31:09 <notdan> return won't work
13:31:13 <notdan> oj too late
13:32:10 <tomejaguar> Ah yes.  'return . runIdentity'
13:35:52 <notdan> nice little library. I would like to see it in platform
13:35:58 <notdan> anyway, off to bed, night
13:36:00 <tomejaguar> Night
13:36:20 <zipper> I am looking at foldr and foldr implementation and I don't get why foldr can work on infinite lists while foldl can't. Even after reading this http://www.haskell.org/haskellwiki/Fold
13:36:44 <tomejaguar> zipper: foldl has to consume the whole list before it produces a result.
13:36:55 <zipper> I still find that we have to reduce everything to values before either foldr or foldr return values
13:37:13 <zipper> tomejaguar: and as far as I can see so does foldr
13:37:16 <geekosaur> nope
13:37:48 <geekosaur> at any given step, foldr needs to resolve a single (x:_) link in the list
13:37:49 <zipper> say I have foldr (+) 0 [1..]
13:37:57 <zipper> and I only want to evaluate to 2
13:38:03 <geekosaur> we don't need to know what _ is until something demands it
13:38:15 <zipper> I end up in a situtation that looks like
13:38:18 <tomejaguar> zipper: It won't work with (+)!   The combining function has to be lazy.
13:38:31 <tomejaguar> Anyway, what would the result be with (+)?
13:38:47 <zipper> f 1 ( f 2 (foldr f 0 [3..]))
13:38:57 <zipper> if f was +
13:39:01 <geekosaur> you don't understand non-strict evaluation
13:39:24 <geekosaur> the trick is that it doesn't need to evaluate that inner foldr unless something demands that result
13:39:30 <zipper> tomejaguar: Oh it won't work with +
13:39:34 <zipper> Wow
13:39:46 <zipper> So what will foldr work with then?
13:39:46 <geekosaur> if you only use the first two, and the combiner is lazy, then the inner foldr there won't be evaluated
13:40:11 <zipper> I wish they said that in the wiki
13:40:39 <zipper> geekosaur: So uh forexample which lazy function would replace f?
13:40:47 <tomejaguar> zipper: (:) for example
13:40:57 <tomejaguar> Although that's rather a trivial case.
13:41:01 <aleksejs_> actually, I was always wondering, why foldl doesn't work on infinite lists, but scanl does
13:41:02 <geekosaur> for a simple one you could use (:) which should actually be the identity transformation (since you're replacing a (:))
13:41:06 <tomejaguar> Any (lazy) constructor.
13:41:28 <zipper> tomejaguar: So if I was using :
13:41:34 <tomejaguar> 'Branch ()' if you have some suitibly defined 'data Tree a = Branch a a | Leaf'
13:41:36 <aleksejs_> @src foldl
13:41:36 <lambdabot> foldl f z []     = z
13:41:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:41:40 <aleksejs_> @src scanl
13:41:40 <lambdabot> scanl f q ls = q : case ls of
13:41:40 <lambdabot>     []   -> []
13:41:40 <lambdabot>     x:xs -> scanl f (f q x) xs
13:41:44 <Hafydd> Why would one ever use the Any monoid instead of just using any and ||?
13:41:53 <simpson> Hafydd: Writer?
13:41:54 <codygman> I've looked at that Fold wiki page a few times, and I still can't figure out how the "fold'" they define with seq is tail recursive. Perhaps I need to read it more carefully. Any other tips?
13:41:55 <aleksejs_> ok, now I see it
13:42:10 <tomejaguar> Hafydd: Maybe you want to pass it to a polymorphic function that manipulates Monoid.
13:42:19 <Hafydd> simpson: how would one use Any with Writer? tomejaguar like what?
13:43:06 <simpson> > runWriter $ do { tell $ Any True; tell $ Any False; return 42; }
13:43:07 <tomejaguar> Hafydd: Any API that someone else has defined that manipulates Monoid.
13:43:08 <lambdabot>  (42,Any {getAny = True})
13:43:10 <zipper> tomejaguar: If I was using : as f in 1: (2 : (foldl f : [3..]))
13:43:24 * hackagebot haskelm 0.0.4 - Elm to Haskell translation  http://hackage.haskell.org/package/haskelm-0.0.4 (jeremondi)
13:43:36 <tomejaguar> codygman: I don't see a seq
13:43:55 <tomejaguar> zipper: Yes then that would work.
13:44:08 <quchen> codygman: foldl' isn't tail recursive.
13:44:12 <AlainODea> codygman: seq evaluates one level deep (formally weak head normal form). It's special.  simonmar's Parallel and Concurrent Programming in Haskell explains this way better than I can ;)
13:44:24 <Hafydd> simpson: fair enough.
13:44:29 <zipper> tomejaguar: When/how would it replace `foldl f : [3..]` with [] because I only wanted the first two?
13:44:36 <kristof> AlainODea++
13:44:38 <simpson> Hafydd: Just the first thing that comes to mind. Monoids have plenty of other uses.
13:44:50 <Hafydd> tomejaguar: I understand, but I'm asking for a specific motivating example.
13:45:05 <tomejaguar> zipper: It wouldn't.  That part of the computation would remain unevaluated.
13:45:17 <codygman> Thanks tomejaguar, quchen, and AlainODea. I've been meaning to check out simonmar's book and now I have another reason.
13:45:34 <AlainODea> codygman: my pleasure :)
13:45:44 <pjdelport> zipper: if you want to limit how much of the list gets consumed, apply a function like take n before passing it to foldr
13:46:08 <zipper> tomejaguar: If it wouldn't then when would I get the [1,2] I want?
13:46:40 <tomejaguar> zipper: You can say 'take 2 $ foldr (:) [] [1..]' and you will get '[1,2]'
13:46:59 <tomejaguar> Yes like pjdelport says.
13:47:11 <geekosaur> the "take 2" turns the crank on the foldr twice, getting 2 results, and then drops the rest on the floor so it's never evaluated
13:47:32 <geekosaur> with foldl, the first crank has to traverse the whole list to find the (_:[]) at the end
13:48:09 <AlainODea> geekosaur: great analogy!
13:48:25 <quchen> That's not an analogy, that's what actually happens
13:48:36 <kristof> there is no crank in the haskell runtime
13:48:37 <kristof> :P
13:48:58 <pjdelport> mnemonically, you can read foldl as "fold towards the left", and foldr as "fold towards the right"
13:49:08 <tomejaguar> There is a crank in the haskell runtime. It's called 'case'.
13:49:13 <kristof> Not just mnemonically, that's what it means
13:49:19 <kristof> tomejaguar: I thought we were talking about thunks
13:49:25 <kristof> I thunk we were talking about thoughts?
13:49:35 <tomejaguar> kristof: Yeah case is what forces a thunk.
13:49:40 <kristof> ah, didn't know that
13:49:46 * quchen doesn't understand what "towards the left/right" means.
13:49:56 <quchen> Both of them walk the list from left to right.
13:50:05 <pjdelport> kristof: well, it's formally defined in terms of associativity
13:50:08 <tomejaguar> They are the left/right associative vernions.
13:50:10 <jle`> @src foldr
13:50:10 <lambdabot> foldr f z []     = z
13:50:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:50:11 <tomejaguar> *versions.
13:50:24 <kristof> pjdelport: gotcha
13:50:40 <jle`> for a good time, try applying any foldr by hand
13:50:40 <pjdelport> the "towards" isn't actually accurate, except for having an intuition why foldl needs a finite list and foldr doesn't
13:50:49 <jle`> @src take
13:50:49 <lambdabot> take n _      | n <= 0 =  []
13:50:49 <lambdabot> take _ []              =  []
13:50:49 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:50:53 <zipper> Ok on that note how come take 2 1:2:[3] fails while take 2 [1..] and take 2 $ 1:2:[3..] doesn't?
13:50:55 <jle`> and apply take n $ fold ...
13:50:56 <pjdelport> what quchen said :)
13:51:05 <jle`> by hand-substitution
13:51:14 <Richie> hi guys! i have a warning : Pattern match(es) are non-exhaustive, how can solve http://lpaste.net/99788 ?
13:51:42 <tomejaguar> zipper: 'take 2 1:2:[3]' tries to apply both 2 and 1 as arguments to take.  You need parentheses or $ as you noted.
13:51:42 <geekosaur> Richie, you're not handling the empty list
13:51:43 <jle`> Richie: you aren't matching implodeText []
13:51:43 <quchen> zipper: take 2 1:2:[3] ≡ (take 2 1):2:[3] ≡ type error
13:51:55 <geekosaur> you handle (x:[]) but not []
13:52:04 <pjdelport> Richie: maybe you meant implodeText xs ?
13:52:20 <zipper> :t take
13:52:20 <lambdabot> Int -> [a] -> [a]
13:52:30 <quchen> Also don't use "null xs", pattern match for empty xs.
13:52:50 <zipper> tomejaguar: Because take must take an int and a list
13:53:25 * hackagebot monad-control 0.3.2.3 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.2.3 (BasVanDijk)
13:53:27 * hackagebot haskelm 0.0.5 - Elm to Haskell translation  http://hackage.haskell.org/package/haskelm-0.0.5 (jeremondi)
13:54:01 <Richie> but how can? i add | [ ] = "" , and error
13:54:15 <milfjord> remove |
13:54:18 <jle`> you can specify that xs is null at the function declaration
13:54:30 <jle`> and not even use a guard
13:54:36 <jle`> implideText (x:[]) = x
13:54:45 <zipper> tomejaguar: I would appreciate a YES right about now.
13:54:50 <kazagistar> I would like to put a mutable array inside a larger data structure… should I make it of type "IO (IOArray Int Whatever)" and place them in the larger data structure?
13:54:58 <jle`> implodeText (x:xs) = x ++ " " ++ + implodeText xs
13:55:03 <jle`> but what if you get an empty list?
13:55:04 <milfjord> kazagistar: that's not an array
13:55:06 <jle`> implodeText [] = ????
13:55:09 <tomejaguar> zipper: YES
13:55:22 <zipper> tomejaguar: Thanks man
13:55:29 <tomejaguar> zipper: No problem man
13:55:30 <zipper> I want all doubts dead
13:55:35 <rgr> I'm trying to set up a nicer ghci experiences using the instructions here : http://www.haskell.org/haskellwiki/GHC/GHCi#The_:def_command .  in 2.5.1 it shows use of ":source" but I get "Unknown command". Any pointers?
13:55:37 <Richie>  i got it  !
13:55:44 <Richie> haskell is fantastic
13:55:51 <kristof> meh
13:55:54 <zipper> When I am playing around and I call a function with the wrong type everything goes wrong. But then what happens in production when the wrong type is passed to a function? I assume everything going wrong is BAD!
13:56:19 <kristof> zipper: if the code compiled, the wrong type never got passed
13:56:31 <rgr> for the ":src foldr" example I get  Plugin `sourcePlugin' failed with: state not initialized
13:56:40 <kristof> zipper: Haskell gives me 99 problems but incorrect type signatures at run time are not one
13:56:44 <rgr> I have installed both packages it tells me to.
13:56:51 <zipper> kristof: Ok maybe I am more used to scripting languages
13:56:54 <kazagistar> milfjord: right. But how DO I construct, say, a record containing a couple arrays and whatnot, so that mutating the arrays is efficient?
13:56:57 <kristof> zipper: Where what happens?
13:57:05 <zipper> kristof: If I was doing IO and it expected an int
13:57:12 <zipper> a user gave a char
13:57:15 <zipper> what then?
13:57:18 <zipper> kristof: ^
13:57:33 <kristof> How do you input an int on your keyboard?
13:57:34 <kristof> :P
13:58:01 <zipper> kristof: lol uh "Enter a number"
13:58:06 <zipper> User enters "a"
13:58:25 <kristof> zipper: you'd have to handle that manually, but you wouldn't get a TYPE error
13:58:26 <rgr> the ":m -Prelude" doesnt seem to work either but I can ":m+ GOA" and then ":m- GOA".
13:58:27 <tomejaguar> If the user enters "56" that's still not an int!
13:58:32 <kristof> zipper: ^
13:58:48 <kristof> zipper: You have to explicitly convert the char-code that represents a number... to a real number.
13:58:55 <absence> can netwire be used with only applicative and monad like reactive-banana, or is the arrow instance required?
13:59:00 <zipper> tomejaguar: So what will happen?
13:59:15 <milfjord> zipper: that depends on what you're doing with it
13:59:15 <zipper> kristof: In my case the user entered a Char
13:59:24 <milfjord> no, 4 chars
13:59:31 <tomejaguar> If you want to parse an integer you can use a function like 'readMay :: String -> Maybe Int'.  If it's not an integer then you'll get Nothing and have to handle that case another way.
13:59:34 <milfjord> assuming "a"
13:59:37 <zipper> milfjord: Yes or 4 chars
13:59:45 <milfjord> zipper: so what's your code?
13:59:49 <kristof> zipper: What you're talking about is trying to use whatever was input as an integer.
13:59:52 <tomejaguar> I think this is hypotheticaly.
14:00:03 <milfjord> everything is
14:00:08 <zipper> milfjord: No it is not something that happened I am being curious.
14:00:08 <thoughtpolice> kazagistar: you put the type 'IOArray Int Whatever' as a field in the data structure itself, and just use readArray/writeArray as you would expect. this will work fine.
14:00:23 <kristof> zipper: But what you got was a Char, always. So to use that char as an integer, you need to convert it to one. :P
14:00:23 <milfjord> zipper: curious about what?
14:00:27 <zipper> I guess it would need an exception or a maybe
14:00:42 <zipper> kristof: Users don't think in ASCII
14:00:50 <zipper> do they?
14:00:53 <milfjord> irrelevant
14:00:55 <zipper> kristof: :D
14:00:57 <milfjord> they type in ascii
14:01:17 <mornfall> milfjord: only some of them :)
14:01:18 <kristof> milfjord: or unicode
14:01:24 <thoughtpolice> kazagistar: 'IO (IOArray Int Whatever)' would presumably just be the definition of something that creates the array and returns it, which is not what you want. you'll have to be in IO anyway to use readArray/writeArray, so you can just create it in IO, stuff it in the data structure, and pull it out and read/write later.
14:01:26 <zipper> milfjord: I see no other way to convert char into an int except for ascii and other encoding
14:01:47 <zipper> 65
14:01:48 <milfjord> zipper: I have no idea what you're talking about now
14:01:48 <mornfall> there probably is a way to get a unicode point out of a Char
14:01:52 <tomejaguar> Yes, so you have a function which takes your encoding and returns 'Maybe Int', like I said.
14:01:55 <startling> :t ord
14:01:55 <lambdabot> Char -> Int
14:02:02 <milfjord> :t fromEnum
14:02:03 <lambdabot> Enum a => a -> Int
14:02:07 <zipper> milfjord: "< kristof> zipper: But what you got was a Char, always. So to use  that char as an integer, you need to convert it to one. :P"
14:02:12 <startling> tomejaguar, unicode is encoding-independent
14:02:22 <milfjord> zipper: yeah
14:02:29 <startling> there's no Maybe about it.
14:02:32 <peteretep> Is `let` in do blocks syntactic sugar?
14:02:39 <peteretep> And if so, where is that defined?
14:02:45 <startling> peteretep, it's sugar for "let ... in", I think.
14:02:50 <zipper> startling: What are you saying? I thought unicode is encoding.
14:02:56 <milfjord> peteretep: do { let { X }; ... } ==> let { X } in do { ... }
14:03:06 <peteretep> perfect, that makes sense
14:03:27 <startling> zipper: no. unicode is a big table mapping numbers to characters. utf-8 etc are encodings.
14:03:33 <tomejaguar> Unicode is an encoding of character streams.  There are also encodings of bytestrings to unicode.
14:03:41 <startling> yeah, fair enough.
14:03:58 <kristof> zipper: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Char.html#v:digitToInt read and be done with it :P
14:04:10 <milfjord> > digitToInt 'z'
14:04:11 <lambdabot>  *Exception: Char.digitToInt: not a digit 'z'
14:04:12 <pjdelport> peteretep: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
14:04:25 <startling> > ord '☃'
14:04:25 <peteretep> perfect, thanks
14:04:26 <lambdabot>  9731
14:05:09 <startling> > ord '🐸''
14:05:10 <lambdabot>  <hint>:1:9:
14:05:10 <lambdabot>      lexical error in string/character literal at end of input
14:05:17 <pjdelport> zipper: encodings are what you use to translate between Unicode and actual bytes
14:05:21 <kristof> zipper: milfjord you get an exception, in which case you should probably have an exception handler around the input code
14:05:48 <pjdelport> Unicode itself is just a data model
14:06:07 <startling> > ord '🐸'
14:06:08 <lambdabot>  128056
14:06:08 <milfjord> kristof: I'd rather not catch exceptions from pure code
14:06:10 <startling> there we go.
14:06:12 <peteretep> Unicode is impossible to get right
14:06:18 <startling> that's not true.
14:06:20 <kristof> milfjord: input is not pure.
14:06:23 <peteretep> startling: Yes it is
14:06:29 <startling> peteretep, it really isn't.
14:06:42 <milfjord> kristof: but digitToInt is
14:06:43 <startling> unicode breaks a lot of expectations developers have about text, yeah.
14:06:48 <peteretep> startling: Start by telling me what a Unicode string length function should return then
14:07:08 <pjdelport> startling: human text breaks a lot of expectations developers have about text
14:07:09 <tomejaguar> Maybe there shouldn't be one.
14:07:22 <peteretep> tomejaguar: I think that's probably true
14:07:26 <startling> peteretep, it depends what you want.
14:07:38 <kristof> peteretep: length of what? The bytestream or the string?
14:07:39 <startling> Haskell's 'length' is very wrong for some purposes in this regard.
14:07:39 <peteretep> startling: Certainly does
14:07:48 <peteretep> kristof: Or the graphemes? Or the codepoints?
14:07:54 <peteretep> kristof: Or the syllables?
14:08:04 <kazagistar> thoughtpolice: ok, I see, I think the array types are slowly making sense… IOArray is the "box" or "reference" which points to the array, and MArray is the typeclass it implements which allows you to actually do mutation that emits the monadic "actions"…?
14:08:12 <startling> peteretep, so, yes, unicode breaks the expectation "text has a well-defined length"
14:08:26 <kristof> peteretep: .....................My point was that I would suggest lengthOfBytestream, lengthOfString, etc. that take Unicode strings (of a particular encoding)
14:08:37 <peteretep> Next up! What's the correct normalization methodology for passwords?
14:08:40 <peteretep> NFD?
14:08:49 <peteretep> Should you be NFD'ing passwords before crypting them?
14:08:52 <kristof> I don't even know what normalization is
14:08:54 <milfjord> peteretep: none
14:08:55 <startling> h̦̝̟͙̠̱̩̱̟̑̎ͧͧ̎́͟͠e̷̡͎͖̳̼̬͚͕̼̫͉̣̠͔͎̠̤̙ͨ̀ͨͣ̽̓̋͋ͬͥ͋̑̃͘ ̯͇̠̺͔͚̳̱̫̦ͮ͛̌̌͊̈͒̈ͤͭ͜͝c̷̷̨̤̹̤͓ͬ̓̍͛̎̿̑̔̓ͫ̈́̽͆̾̐o̴̧͓̼͉̼̳̮ͬͮ͊̀̿́͋͗̓̀̈̿͂̈͗͞͞m͒͛͋̂͗҉̘̥̠͚̠̀̕eͭͩ͆ͬͦ̍̏͝͝҉͓̞̬͓̠͔̮̤̖̻̜̻͡sͤ̆͑̏̃̀ͫ͛ͪ͑̔ͣ͐͌͌ͥ̌̚͡҉͚͕͈͈͚
14:09:08 <kristof> jesus christ
14:09:14 <kristof> I'm out
14:09:16 * kristof bounces
14:09:27 <maskt> what did you do to my terminal
14:09:36 <milfjord> by your characters combined
14:09:48 <startling> haha
14:10:02 <peteretep> milfjord: Your user has rung up, and they're complaining that their password of "École" doesn't work on their mom's computer, but does on theirs
14:10:07 <startling> maskt: congratulations! your terminal displays unicode correctly.
14:10:31 <startling> peteretep, is there something wrong with NFD? I'm not aware of one.
14:10:48 <geekosaur> kristof: many unicode characters can be encoded in multiple ways (for example there is a single codepoint version of ü and one that is made from the codepoint for "u" and one for combining double-dot diacritical)
14:11:05 <peteretep> startling: Wrong with it? No?
14:11:13 <tomejaguar> Ouch.  If I were doing passwords, I'd let them only be ASCII.
14:11:15 <milfjord> peteretep: tell them it's a security feature so their mom can't hack them
14:11:16 <geekosaur> normalization is remapping things like that so that they can be treated consistently
14:11:51 <startling> peteretep: you phrased it as if there was something wrong with using NFD for normalizing passwords.
14:12:03 <peteretep> startling: Ah, so you think passwords should be normalized?
14:12:05 <hpc> tomejaguar: fun fact - the konami code is a valid unix password
14:12:11 <startling> (zalgo works by stacking lots of combining characters)
14:12:15 <startling> peteretep: why shouldn't they?
14:12:46 <peteretep> startling: Well I've never seen an implementation of anything where they /are/
14:12:57 <startling> peteretep, you haven't been looking very hard.
14:13:10 <peteretep> Every time you think you understand Unicode, you're wrong.
14:13:21 <startling> ummm, ok.
14:13:31 <thoughtpolice> kazagistar: yes. IOArray isn't the only MArray instance, hence why it's a typeclass. note there are several different kinds of array types, so picking one carefully is important
14:13:36 <kristof> This just got pretty hostile.
14:13:38 <thoughtpolice> (but the type classes make it pretty easy to switch out)
14:13:53 * kristof sits peteretep and startling down and encourages them both to have a scone.
14:14:08 <peteretep> The user presents with two characters that should either be rendered as a Taiwanese flag, or as the letters TW, depending on the poltical posture of your country of residence toward China
14:14:08 <startling> peteretep: I guess I'm not sure what you're point is.
14:14:30 <startling> peteretep: you're reiterating the fact that your average developer gets unicode wrong, which is orthagonal to how this discussion began.
14:14:53 <peteretep> No, I'm categorically stating that all developers get Unicode wrong
14:15:07 <kristof> peteretep: Even Rob Pike?
14:15:09 <peteretep> due to its deeply unholy nature
14:15:26 <milfjord> kristof: especially rob pike
14:15:32 <kristof> blasphemous
14:15:39 <kristof> milfjord: doth thou not liketh the gophers?
14:15:45 <startling> peteretep: that's not my experience.
14:16:11 <startling> and in any case the answer isn't "we shouldn't use unicode", as you seem to be implying?
14:16:24 <peteretep> That's Dunning–Kruger effect
14:16:24 <startling> it's "learn more about unicode before you write code that deals with it".
14:16:43 <startling> peteretep, hilarious.
14:16:54 <Dfeuer> I'm used to the basics of types in Haskell, and now I'm taking a class that uses Java. Are Java generics as insane as they appear?
14:17:00 <startling> Dfeuer: yes.
14:17:30 <kazagistar> I learned the other way around, so I never quite saw what was so crazy about generics?
14:18:24 <kristof> peteretep: That was a little bit too condescending, don't you think?
14:18:39 <startling> Dfeuer: luckily Philip Wadler designed them, so you can still sometimes use haskellisms in Java. 8)
14:18:46 <Cale> kazagistar: It's mostly in the interaction between type parameters and subtyping where things start to go bad.
14:18:47 <peteretep> kristof: Probably. Sorry
14:19:04 <peteretep> For what it's worth, I consider myself far from an expert on Unicode
14:19:44 <peteretep> I note that I was about 100% confident I understood Unicode after I first got started, and my confidence in it has shrunk as I have become more and more competent
14:20:27 <startling> I don't consider myself an expert either. I know enough to think "hey, there are some assumptions in this code that I should double-check on".
14:20:54 <kazagistar> I feel like I have learned enough about unicode to know that I should just avoid handling strings myself if at all possible…
14:22:44 <kazagistar> the only thing that I would really really like to change about unicode is that different codepoints or sets of codepoints can result in the same visual glyph
14:23:08 <startling> kazagistar, it's complicated.
14:23:38 * hackagebot lifted-base 0.2.1.2 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.1.2 (BasVanDijk)
14:24:25 <peteretep> kazagistar: That's useful
14:24:25 <Dfeuer> @startling, I'm looking at the Comparable interface and thinking it's utterly insane—it never makes sense to talk about T implementing Comparable <U> unless T is a subtype of U and U implements Comparable<V> for some supertype V of U. But none of that is actually in the interface. Cuckoo, that is.
14:24:26 <lambdabot> Unknown command, try @list
14:24:39 <mmmm> Recommended introduction to zippers?
14:24:56 <peteretep> kazagistar: And also what normalization forms are all about
14:25:38 <merijn> mmmm: The wikibook was decent, I remember?
14:25:46 <merijn> mmmm: Also, LYAH has a chapter on them
14:26:36 <startling> Dfeuer: right - the big drawback is that there's no 'this' type.
14:26:48 <startling> Dfeuer: so every A implements Comparable<A>
14:28:10 <peterhil> I think I found a bug in ghci version 7.4.1:
14:28:12 <peterhil> Prelude> floor (-4.5)
14:28:14 <peterhil> [1]    58986 segmentation fault  ghci
14:28:47 <startling> peterhil, that sounds like one, yeah.
14:28:58 <Cale> Dfeuer: I think your bounds there aren't strict ones though (that really would be silly, it would imply an infinite chain of instances would have to exist before any other could be defined), but you may have equality of types between some of those (and usually just T = U)
14:29:13 <Cale> peterhil: wow, what?
14:29:16 <peterhil> Any negative value seems to cause seg fault. I have an iMac with Core i7 processor.
14:30:07 <Cale> https://ghc.haskell.org/trac/ghc/ticket/7043
14:31:06 <Dfeuer> Cafe, no, they're not strict. The chain can be arbitrarily long, but must be finite.
14:31:15 <skypers> woh, I have something like five monad transformers stacked up
14:31:17 <Dfeuer> Sorry, Cale.
14:31:18 <skypers> it scares me :D
14:31:21 <peterhil> Cale: ok, maybe I shuold update to newest version...
14:31:30 <startling> skypers: heh
14:31:37 <Cale> peterhil: Or else try the 64 bit version
14:31:38 <startling> skypers: you're using the MonadX things, right? :)
14:31:48 <skypers> define things
14:31:58 <startling> skypers: e.g. MonadState rather than StateT
14:32:07 <skypers> typeclass then
14:32:11 <skypers> well no
14:32:25 <NikolajK> Hi,
14:32:25 <NikolajK> I want to-
14:32:25 <NikolajK> a) read out text files which contain the data of a graph,
14:32:25 <NikolajK> b) want to work on the data,
14:32:25 <NikolajK> c) want to draw (subsets of) the graph and
14:32:26 <NikolajK> d) have it displayed dynamically/interactively on the web
14:32:26 <NikolajK> -are there any standard tool/packages for some of these tasks I ought to use?
14:32:26 <startling> you probably should be. it helps enormously with composability.
14:32:31 <Cale> skypers: I always deal with such things by creating a newtype
14:32:44 <skypers> Cale: it’s what I do
14:32:53 <skypers> well startling
14:32:59 <Cale> and then defining various primitive operations on that newtype in terms of the things given by the monad transformers
14:33:08 <merijn> NikolajK: one sec, a colleague just showed me a graph drawing tool earlier this week
14:33:11 <Cale> and then subsequently forgetting that the monad transformers were ever there
14:33:13 <skypers> I want to fix some stuff
14:33:15 <startling> a newtype is sometimes nice, but a lot of my code ends up not requiring the entire stack
14:33:26 <skypers> I have two monads that are always the same
14:33:30 <Cale> I don't like client code to be able to see that monad transformers are involved
14:33:30 <startling> haha
14:33:43 <merijn> NikolajK: Gephi, apparently
14:33:48 <skypers> EitherT Error (StateT Logqueue m)
14:33:53 <skypers> the m can be more complex
14:34:01 <skypers> now it’s a RWS with some other things inside
14:34:14 <startling> skypers: you might like Writer
14:34:16 <Cale> (In fact, I rarely use monad transformers anyway)
14:34:21 <skypers> startling: well
14:34:21 <rgr> gah. GOA provides wrong case answers/URLs for things like ":docs Prelude". http://www.haskell.org/ghc/docs/latest/html/libraries/base/prelude.html - doesnt work because its actually Prelude.html
14:34:23 <skypers> no
14:34:30 <startling> ok! just a suggestion.
14:34:35 <skypers> the issue with Writer to me is that I can’t sink output
14:34:39 <skypers> I want that
14:34:44 <skypers> and State enables that
14:34:53 <Cale> If you're using monad transformers over IO, it's rarely a worthwhile exercise.
14:35:03 <skypers> Cale: what do you mean?
14:35:07 <Cale> (apart from things like ParserT or ContT perhaps)
14:35:36 <Cale> IO already has so many facilities in it that you kind of don't need additional environment or state.
14:35:39 <skypers> you create your own monad with class instance?
14:36:24 <Cale> Some people disagree with me, it's a stylistic thing that reasonable people can disagree about
14:36:35 <skypers> well, how would you create a monad in which you can do IO, log things and handle errors through Either?
14:36:49 <Cale> But I usually much prefer to pass parameters than to transform IO in any way
14:37:03 <zebr> is there a particular 'monadic reason' i can't say "do Just x | ok x <- f" or is it just a syntactic limitation?
14:37:09 <NikolajK> NikolajK: thanks for the suggestion. I'll probably go for 2D now and much smaller graphs
14:37:32 <skypers> Cale: do you mean something like
14:37:43 <avpx> zebr: Are you asking why you can't have a binding like "x <- m" at the end of a do block?
14:37:54 <skypers> a data on IO
14:38:02 <merijn> zebr: I don't understand what that example is supposed to do?
14:38:07 <skypers> and make it instance of MonadState, MonadError, and so on?
14:38:13 <zebr> avpx: sorry, no, i mean why can't i have a pattern guard in 'x <- f' do syntax
14:38:35 <merijn> zebr: What would it do if the guard failed?
14:38:46 <zebr> make the pattern fail
14:38:48 <Cale> skypers: To admit logging, I would pass an explicit function parameter (String -> IO ()) or some such. I usually deal with Either just directly with case, or by defining operations that abstract what I'm doing at the time -- there's rarely all that much in the way of nesting of matches really.
14:38:53 <zebr> so it 'fail's
14:39:07 <skypers> woh Cale
14:39:10 <merijn> zebr: The fact that fail exists is widely considered a misfeature, so adding more failing things is bad
14:39:13 <skypers> you might have very verbose code
14:39:15 <zebr> hm, i suppose you can't let Just x | ok x = ... either.
14:39:32 <Cale> skypers: Nah, it's like 6 of one, half a dozen of the other
14:39:45 <Cale> skypers: You also pay for using monad transformers, by having to lift all your IO acitons
14:39:46 <zebr> merijn: mm. there is already such a thing as a pattern mismatch, though. so it would just do that, whatever those semantics are.
14:39:49 <Cale> actions*
14:39:57 <skypers> Cale: well
14:40:04 <skypers> it’s juste a word and a dot
14:40:12 <skypers> not very verbose
14:40:19 <skypers> and I often lift blocs of IO actions
14:40:30 <skypers> (and I have some combinators that hide lifting)
14:40:33 <Cale> Passing a parameter is typically just a word. ;)
14:40:41 <avpx> zebr: Well, a failing irrefutable pattern match usually causes a crash
14:40:41 <zebr> merijn: what would you say is the solution to 'fail', then? making mismatching fatal? no patterns in lets or <- ?
14:40:48 <skypers> Cale: well, you have to duplicate that in all your fuctions
14:40:50 <Cale> (and often that parameter doesn't need to be passed)
14:40:52 <skypers> I don’t with transformers
14:41:01 <skypers> what do you mean?
14:41:16 <zebr> avpx: i spose. not in comprehensions, though. would you want that gone too?
14:41:33 <merijn> zebr: No incomplete patterns in <-, with the exception patterns in MonadPlus, in which case failing pattern could use mzero
14:41:53 <Cale> e.g. if my concern is just logging and I'm passing around a function (String -> IO ()), then I only have to pass that to things which are actually going to log something.
14:42:34 <joshinct> I'm working my way through LYAH (still early on) and trying some problems from Project Euler. I have a solution to a problem for finding the largest prime factor of a given number, which works in pencil and paper, but I can't seem to get the type declarations right when I try to code it. http://pastie.org/8723921#2
14:43:03 <joshinct> Should I keep trying, or come back to this after I've read much further into the tutorial.
14:43:04 <skypers> something interesting though: if I want to add logging to IO with Writer, I can use WriterT w IO, or something like data IOLogged = IOLogged Writer … IO … deriving (MonadWriter); which one’s the best?
14:43:07 <zebr> merijn: mm, i suppose that makes sense. but then, my specific use case is actually a MonadPlus
14:43:08 <skypers> Cale: hm
14:43:09 <Cale> Sometimes I'll be a bit cruder about things if I have a lot of this contextual stuff that I'm passing around by defining a type which it all goes in, so that I only have one parameter to deal with.
14:43:33 <merijn> joshinct: number uses both / and calls smallPrime which uses mod
14:43:35 <skypers> so you dislike transformers?
14:43:37 <avpx> zebr: Yeah, I'm not really sure how that should be handled. My experience with irrefutable patterns using "let" says that you probably should only use "let Just x = ..." or "Just x <- ..." if you expect a failing match to crash your program.
14:43:47 <merijn> joshinct: / only works on fractionals, mod only on Integrals, so those don't match
14:43:56 <Cale> skypers: Trivial ones over IO, yes.
14:44:09 <merijn> joshinct: You'll want to use fromIntegral somewhere to convert integrals into fractionals
14:44:13 <merijn> :t (/)
14:44:14 <lambdabot> Fractional a => a -> a -> a
14:44:15 <merijn> :t mod
14:44:16 <skypers> Cale: I actually love them
14:44:16 <lambdabot> Integral a => a -> a -> a
14:44:19 <skypers> especially RWST
14:44:31 <merijn> > 3 / (5 `mod` 2)
14:44:32 <lambdabot>  No instance for (GHC.Show.Show a0)
14:44:32 <lambdabot>    arising from a use of `M751713108738499966319733.show_M7517131087384999663...
14:44:32 <lambdabot>  The type variable `a0' is ambiguous
14:44:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
14:44:32 <lambdabot>  Note: there are several potential instances:
14:44:39 <merijn> > 3 / fromIntegral (5 `mod` 2)
14:44:39 <skypers> being able to access some environment with just ask(s) is just neat
14:44:40 <lambdabot>  3.0
14:44:44 <Cale> skypers: I used to think they were rather cool, but having written a lot of code with and without them now, I kind of think they're overrated.
14:44:58 <merijn> > 3 / fromIntegral (5 `mod` 3)
14:44:59 <Cale> Now, if you have something like, oh, ContT or ParserT or LogicT something like that, it's more interesting.
14:44:59 <lambdabot>  1.5
14:45:08 <skypers> Cale: do you have an example of consistent code?
14:45:20 <Cale> Or if the monad you're transforming isn't IO, then that's another thing altogether.
14:45:33 <Cale> e.g. StateT s [] is a really cool monad
14:46:05 <joshinct> merijn: Thanks! I'll woodshed it and see if I can't get it working.
14:46:09 <jle`> is there any really interesting thing you can do with Category besides composing a bunch of them in a row
14:46:12 <skypers> Cale: I’m not sure to understand your point with your (String -> IO ()) function
14:46:17 <DogeHayashi> Question I'm not entirely sure how to word in a non-confusing manner: Is there any natural representation for functions-in-the-relation sense?  As in, you'd use a list of pairs for relations, but when wanting to mandate that each input only maps to one output, is there any elegant way of doing so?
14:46:20 <skypers> it sounds pretty annoying to me
14:46:36 <Cale> skypers: It's not -- you're just passing along a function which says how to log something.
14:46:53 <DogeHayashi> I'd build a literal function using pattern matching and recursion on previously defined versions of the function, but that seems expensive for little gain in elegance
14:47:00 <skypers> Cale: yes so you find that in the type sig of the function
14:47:06 <skypers> which is quite of annoying
14:47:07 <Cale> mhm
14:47:19 <skypers> whereas the monad hides that
14:47:21 <Cale> Nah, it's not any worse than WriterT String
14:47:21 <merijn> joshinct: Also, ask ghci (using :t) what type it infers for your functions
14:47:58 <merijn> joshinct: With the following hint, if you see "(Integral a, Fractional a) => ..." you have a problem as there are no types that are *both* Integral and Fractional
14:48:04 <skypers> Cale: anyway
14:48:05 <Cale> (obviously, it means something different from WriterT String, but at the end of the day, you're getting the same stuff done)
14:48:27 <skypers> what do you think of typeclasses vs monad transformers?
14:48:43 <Cale> ... those aren't comparable notions?
14:49:06 <skypers> Cale: if I have a monad and want to add stateful computations support to it
14:49:09 <joshinct> merijn: Will investigate with the benefit of your advice, thank you.
14:49:18 <startling> I think skypers means the abstract typeclassy versions of monad transformers.
14:49:23 <Cale> Another thing which my approach allows for is that I can pass in something like writeChan c, and have another thread reading the channel.
14:49:24 <startling> e.g. MonadState vs StateT
14:49:27 <skypers> I could use a StateT, or a newtype with deriving (MonadState)
14:49:32 <skypers> yes startling
14:49:51 <Cale> Well, this isn't really a great example, since you'd expect that sort of thing anyway
14:49:59 <Cale> But for instance, if I'
14:50:09 <Cale> If I'm setting up thread communication in the first place
14:50:18 <skypers> I never thought of that actually (unstacking my transformers by instancing!!)
14:50:27 <skypers> I wonder how it’s good
14:50:35 <Cale> I'll often do that kind of thing, preferring to pass around the abstracted ends of a piece of mutable state than the MVar or Chan or whatever it is.
14:50:54 <skypers> ok Cale
14:50:58 <skypers> I see
14:51:12 <Cale> and that frequently gives me logging :)
14:51:30 <mornfall> I guess the problem with abstract typeclassy transformers is that it's not obvious what the calls actually mean in a particular stack.
14:51:38 <Cale> in that, I can then log all the changes to that state by adjusting the function I'm passing in
14:51:50 <skypers> mornfall: so you think it’s better using transformers?
14:51:52 <Cale> to something which logs the changes
14:52:01 <skypers> what’s the main difference anyway?
14:52:08 <mornfall> skypers: not necessarily
14:52:11 <skypers> the typeclass version might be simplier to use
14:52:22 <triliyn> skypers: transformers come with the typeclass instances automatically
14:52:22 <skypers> because there wouldn’t be any lifts, right?
14:52:41 <skypers> triliyn: yes I know
14:52:43 <Cale> skypers: There already won't be lifts for those things
14:52:43 <skypers> but I mean for stacking
14:52:47 <mornfall> lift itself comes from a typeclass
14:52:52 <triliyn> But yes, if you use the transformer interface directly, you need to lift, which means your code depends on your monad stack
14:53:02 <triliyn> Change your stack and you have a million type errors to fix
14:53:10 <skypers> triliyn: yes
14:53:17 <skypers> so stacking is not a great idea?
14:53:19 <mornfall> triliyn: unlike with typeclasses, where you change the stack and you have a subtle runtime bug :-)))
14:53:27 <Cale> Because the implementation of e.g.  instance MonadState s m => MonadState s (WriterT w m)  will apply the lifts for you
14:53:47 <skypers> my monads are stacks
14:53:52 <skypers> if I change the stacks
14:53:52 <startling> I've never run into stack-ordering bugs. Is that a common thing?
14:53:56 <skypers> I break 90% of my code
14:54:03 <skypers> is this insane?
14:54:07 <Cale> skypers: That's bad, yeah
14:54:09 <startling> skypers: yeah, it kind of sucks.
14:54:12 <mornfall> startling: possibly if you thread exceptions through transformers
14:54:17 <startling> mornfall: ah.
14:54:18 <triliyn> skypers: I think interacting explicitly with the stack is generally less nice than using the typeclass interface, but it doesn't really matter whether you construct your monad with transformers or directly with a newtype
14:54:22 <skypers> how would I fix that?
14:54:26 <skypers> with instance?
14:54:35 <mornfall> startling: well, any non-trivial threading of effects is prone to break when the stack changes
14:54:39 <Cale> skypers: You want to as quickly as possible abstract over the stack of transformers, and hide the newtype constructor by a module boundary
14:54:50 <startling> skypers, derive instances for your newtype (with GeneralizedNewtypeDeriving) if you have one.
14:54:58 <skypers> ok
14:54:58 <mornfall> startling: exceptions are great in that they will make the stack lose state in a very uncommon situation, so it's likely you won't notice for a while :-P
14:54:59 <skypers> for now
14:55:00 <startling> otherwise just use the typeclass methods.
14:55:02 <Cale> So that you know that if you change the stack of monad transformers, it's only the stuff in that one module which will need adjusting.
14:55:03 <skypers> I don’t have newtype
14:55:05 <skypers> only type
14:55:06 <skypers> wait
14:55:31 <skypers> https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Monad.hs#L84
14:55:36 <skypers> something like that
14:55:39 <startling> mornfall, can it come up with your standard Reader/State/Error stacks?
14:55:40 <skypers> so it’s wrong?
14:55:56 <Cale> Yeah, I'd make those newtypes
14:56:14 <mornfall> startling: dunno, I don't remember the details, but some stacks are more tricky than others
14:56:14 <Cale> and not export the data constructor
14:56:26 <startling> mornfall: got it. good to know in any case. thanks!
14:56:26 <mornfall> startling: I think the main problem are stacks over IO, with IO having its own exception stuff in it
14:56:33 <startling> mornfall, right, ok.
14:56:36 <Cale> and then that will confine all the basic primitive operations in my newly defined monad to that one module
14:56:37 <skypers> like, newtype SkyT = ? ; derive insance MonadState…?
14:56:44 <skypers> I don’t use EitherT anymore?
14:56:47 <skypers> nor StateT
14:56:49 <startling> I know IO exceptions are a pain in the ass to deal with.
14:57:09 <startling> skypers, newtype SkyT m a = SkyT (EitherT SkyError (StateT LogQueue m) a)
14:57:24 <startling> deriving MonadError, StateT
14:57:34 <mornfall> there are also some smart typeclasses for threading exceptions through transformer stacks
14:57:49 <Cale> startling: IO exceptions are pretty nice though! Nobody bothers to understand them properly.
14:57:59 <mornfall> that let you catch things in a remotely sane-looking way, not sure it's actually sane though
14:58:01 <skypers> startling: ok
14:58:06 <Cale> (I shouldn't say that, probably many people do)
14:58:08 <skypers> so the main difference is that now
14:58:20 <skypers> if I want to use the Either part
14:58:29 <skypers> I don’t have to lift whereas to use the State part I have to
14:58:34 <skypers> and in the deriving version
14:58:35 <startling> skypers: no.
14:58:42 <skypers> I don’t have to lift the State part?
14:58:43 <startling> skypers, MonadState gives you get/set/modify without lifting
14:58:43 <Cale> But yeah, the interaction of exceptions with monad transformers isn't great
14:58:59 <skypers> yes, but I don’t have that _now_
14:59:05 <startling> oh, I see.
14:59:10 <startling> actually no, you do.
14:59:10 <mornfall> Cale: any control-flow monad is going to give you pain if it's in the middle of a stack
14:59:12 <Cale> skypers: You do have that now...
14:59:17 <startling> you just don't use it. :)
14:59:25 <skypers> ?
14:59:27 <Cale> skypers: There's an instance (MonadState s m) => MonadState s (EitherT e m)
14:59:34 <Cale> skypers: So you can use get and put directly.
14:59:39 <startling> skypers: you can avoid that lifting, yeah.
14:59:48 <skypers> .
14:59:49 <skypers> :D
14:59:52 <startling> heh
15:00:03 <skypers> actually
15:00:03 <startling> I would write this without a newtype at all tbh.
15:00:10 <mornfall> Cale: there was a reason why those instances are not defined in terms of MonadTrans, care to remind me what it was? :P
15:00:11 <startling> and just use MonadError and MonadState in the signatures.
15:00:20 <skypers> the main problem of my design now is that my code depends on the transformers stacks ordering, right?
15:00:25 <Cale> mornfall: What do you mean by that?
15:00:32 <startling> skypers: I don't think it does, it just acts like it does.
15:00:42 <Cale> mornfall: Are you thinking of the instance-which-would-overlap-with-everything?
15:00:42 <skypers> what? :D
15:00:52 <mornfall> Cale: I guess so.
15:01:10 <mornfall> I.e. replace EitherT with t, where MonadTrans t.
15:01:15 <Cale> startling: It kind of does
15:01:27 <Cale> startling: It relies on StateT being at least one level deep
15:01:36 <startling> Cale: ok, fair enough
15:02:13 <mornfall> startling: if it floats to the top, you can always add IdentityT :D
15:03:00 <skypers> ok so I just have to use a newtype and derive the proper monad
15:03:18 <skypers> what if a monad transformers stack has two same transformers?
15:03:21 <skypers> like hm
15:03:25 <startling> skypers: then you need lift, yeah.
15:03:38 <Cale> So, if you let the abstraction leak, then monad transformers can seem like they're saving you lots of trouble, but if you do the right thing with newtypes and implement a small core of operations and then hide the newtype constructor, then I don't think they actually save you all that much.
15:03:39 <skypers> EitherT … (StateT … (ContT … (StateT …
15:03:59 <startling> skypers: then the inner one's instance is hidden by the outer's
15:04:02 <Cale> (The other way has harsh problems with it though!)
15:04:15 <startling> skypers: it's often better to do StateT (s, t) than StateT s (StateT t ...)
15:04:18 <skypers> startling: will even the generalize deriving work?
15:04:28 <startling> skypers: yes, but it will only give the outer one
15:04:40 <skypers> I don’t always control all the inner monad
15:05:02 <skypers> :t listen
15:05:04 <lambdabot> MonadWriter w m => m a -> m (a, w)
15:05:09 <mornfall> I'm always vaguely concerned about strictness with StateT. To derail the discussion a little.
15:05:40 <startling> mornfall, StateT operations don't make sense without the strictness StateT requires.
15:05:40 <mornfall> Wasn't there a strict version of StateT somewhere?
15:05:55 <Cale> Also, I've seen cases where there was a stack of monad transformers, and someone went and replaced it with a hand-implemented version and things ran a factor of 10 faster.
15:06:06 <startling> Cale: ouch.
15:06:20 <nomeata> Hi. Is there an easy answer to the question “In a Haskell program that should run on Windows and Linux, I want to play Ogg Vorbis files without a fuzz. How”?
15:06:29 <mornfall> RWST IO for everyone...
15:06:43 <Cale> nomeata: What do you mean "without a fuzz"?
15:07:09 <mornfall> nomeata: unless alsa comes with windows these days, I don't think it's going to be very peachy
15:07:37 <startling> there's a cross-platform GNOME thing iirc
15:07:40 <mornfall> I'd try for SDL.
15:07:40 <skypers> hm
15:07:54 <skypers> startling: so if I have such a situation (two StateT)
15:08:03 <skypers> I can just lift the inner one?
15:08:19 <nomeata> Cale: "import SomeModule (playOggFile)" with "playOggFile :: FilePath -> IO ()"
15:08:35 <startling> skypers: with your newtype, lift get would get the inner one.
15:08:36 <nomeata> SDL is a good idea
15:08:38 <Cale> nomeata: I think probably the simplest way would be to use one of the SDL bindings
15:08:44 * hackagebot purescript 0.3.13.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.13.1 (PhilFreeman)
15:08:51 <Cale> yeah
15:08:55 <skypers> yep startling, ok
15:09:03 <skypers> I’m gonna try that out
15:09:18 <startling> skypers: (you need to derive MonadTrans too in this case)
15:09:28 <mornfall> nomeata: there's playMusic in SDL-mixer ... now the question is how to get Music from Ogg files :)
15:10:04 <nomeata> mornfall: loadMUS?
15:10:06 <Cale> loadMUS does it
15:10:29 * nomeata tries it out
15:10:36 <mornfall> it can load vorbis? that'd be cool
15:10:55 <Cale> iirc yeah
15:11:07 <Cale> also note http://hackage.haskell.org/package/SDL-mixer-0.6.1/docs/Graphics-UI-SDL-Mixer-Types.html#t:MusicType
15:12:14 <nomeata> if just all these Int arguments were documented...
15:12:25 <rgr> something fundamental I dare say but . I can declare 'myEq :: (Eq a) => a -> a -> Bool' fine. Why not 'myLarger :: (Ord a) -> a ->a -> Bool' - my understanding is bot Eq and Ord are type classes here.
15:12:25 <mornfall> nomeata: try upstream SDL docs
15:12:53 <startling> rgr, what's the problem you're having?
15:13:03 <Cale> rgr: You should be able to do both
15:13:15 <Cale> oh, you typoed the => thouhg
15:13:20 <Cale> though*
15:13:23 <rgr> ok. Maybe I'm being frightened by type warnings.
15:13:26 <startling> nomeata, gstreamer is the one i couldn't remember
15:13:37 <Cale> It should be myLarger :: (Ord a) => a -> a -> Bool
15:13:44 <mornfall> startling: I don't think you get gstreamer on windows easily...
15:13:56 <mornfall> (although I'm not saying it's impossible)
15:14:03 <startling> mornfall: afaik it's cross-platform
15:15:06 <rgr> hmm. maybe its some fluff from haskell mode. I have Ord hilited as an error and ' Predicate `Ord a' used as a type'
15:15:18 <merijn> > let myLarger :: Ord a => a -> a -> Bool; myLarger x y = x > y in myLarger 6 5
15:15:20 <lambdabot>  True
15:15:44 <triliyn> rgr: you wrote "(Ord a) -> ..."; it needs to be "(Ord a) => ..."
15:15:47 <mornfall> startling: hmm, they do have an .msi installer these days
15:15:51 <rgr> oh yes!!!!
15:15:56 <triliyn> Type classes need fat arrows
15:15:58 <rgr> goddam it.
15:16:01 <rgr> sorry
15:16:11 <merijn> rgr: :)
15:16:14 <mornfall> startling: but then, SDL is probably a lot more mature, so if it works...
15:16:18 <bitemyapp> triliyn: fat arrows. that's the terminology I wanted. Thank you.
15:16:21 <triliyn> I would have missed it too if not for Cale
15:16:30 <triliyn> It's difficult to catch by eyeballing!
15:16:33 <startling> me too.
15:17:12 <mornfall> triliyn: that's the builtin typo-correction in your brain :-)
15:19:15 <mornfall> triliyn: by the time you read that class constraint, it's dead obvious that => is what follows ;)
15:19:25 <rgr> Im trying to use lambdabot. I set up like in the wiki but it says in ghci "Unknown command, try @list" when I try the documented example ":source Data.Maybe" despite my .ghci conmtaining a line ':def source    lambdabot "fptools"' . Any ideas?
15:19:32 <triliyn> mornfall: of course
15:19:49 <skypers> @index MonadError
15:19:49 <lambdabot> Control.Monad.Error
15:22:28 <nomeata> hmm. it runs, but I hear nothing ...
15:23:58 <nomeata> (hehe, but the haskell program was not the reason... thx)
15:25:18 <startling> nomeata: volume? :)
15:26:32 <rgr> :t myTri
15:26:33 <lambdabot> Not in scope: `myTri'
15:26:54 <rgr> heh. oops.
15:27:01 <nomeata> startling: audio device in gnome-control-center
15:27:38 <nomeata> but I somehow doubt that installing SDL-mixer is going to be easy for the average windows user
15:28:23 <Earnestly> nomeata: (Stop treating your users like idiots :P)
15:29:15 <startling> nomeata, you can always distribute binaries
15:29:36 <nomeata> Earnestly: nah, the idiots are us computer scientist that just cannot solve such issues properly :-)
15:30:10 <nomeata> startling: true. or at least find someone running windows and willing to create binaries, and fiddle with DLLs and whatnot
15:30:11 <Earnestly> That's not really a justification though
15:30:22 <startling> nomeata: that's what I meant. 8)
15:31:13 <skypers> hm
15:31:18 <skypers> MonadError is not a great class…
15:31:24 <startling> why not?
15:31:43 <nolrai66> So I find my self wanting implicit paramaters, but I remember something about them not being a good idea?
15:32:00 <startling> nolrai66, I've never heard anything bad about implicit parameters
15:32:18 <nolrai66> fair enough.
15:32:24 <skypers> startling: because it needs some stupid constraint on the error type
15:32:30 <skypers> an “Error” class
15:32:34 <startling> skypers: no, that's ErrorT
15:32:43 <skypers> oh
15:32:44 <davean> nolrai66: why do you find yourself wanting them?
15:32:50 <skypers> ok
15:32:52 <startling> skypers, that's why EitherT is the thing to use
15:32:57 <skypers> yes
15:32:59 <skypers> I love EitherT
15:33:00 <startling> bu MonadError is fine.
15:33:40 <roboguy_> why does Error exist, anyway?
15:34:06 <startling> roboguy_, historical reasons
15:34:45 <startling> you can read a short edwardk rant here: http://hackage.haskell.org/package/either-4.1.1/docs/Control-Monad-Trans-Either.html
15:36:20 <skypers> roboguy_: oh you’re there!
15:36:33 <skypers> have you noticed carmack answered me back?
15:36:55 <fooozbaz> where has the on-disk haskell documentation gone in the latest haskell platform?
15:37:16 <fooozbaz> it used to be in /Library/Haskell or ~/Library/Haskell or somesuch...
15:37:18 <nolrai66> applyForce force timeStep = changeVelocity >>> changePosition -- I want to float timeStep up but I don't really want to use MonadReader...but now I cant remember why.
15:37:22 <roboguy_> skypers: yep. it's a shame that he doesn't still have it
15:38:31 <rgr> in the debugger in ghci is it possible to trim the location status? e.g Stopped at /home/rgr/development/haskell/learning/qsort.hs: is a tad long.
15:40:56 <nolrai66> daven: applyForce force timeStep = changeVelocity force timeStep >>> changePosition timeStep -- I want to float timeStep up but I don't really want to put everything in a monad yet.
15:42:30 <skypers> roboguy_: yeah…
15:43:11 <roboguy_> nolrai66: you could probably do something like applyForce force = (>>>) <$> changeVelocity force <*> changePosition
15:44:15 <roboguy_> if that's what you mean
15:44:23 <startling> :t (>>>)
15:44:24 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
15:45:54 <roboguy_> @pl applyForce timeStep = changeVelocityWithForce timeStep >>> changePosition timeStep
15:45:54 <lambdabot> applyForce = liftM2 (>>>) changeVelocityWithForce changePosition
15:46:31 <x77686d> newbie question: Am I correct in thinking that it's not possible to write reverse in terms of a foldr with a lambda that uses only cons?
15:46:35 <roboguy_> I like my way a little more, but that's also a possibility
15:46:57 <merijn> x77686d: eh, define "only uses"
15:47:00 <shachaf> That depends on what you mean.
15:47:19 <shachaf> I suppose you don't like "reverse . foldr (:) []"
15:47:51 <x77686d> shachaf: correct
15:47:59 <nolrai66> @t (>>>) <$> a <*> b
15:47:59 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
15:48:07 <nolrai66> @ty (>>>) <$> a <*> b
15:48:08 <lambdabot>     Couldn't match expected type `f0 (cat0 a0 b0)'
15:48:08 <lambdabot>                 with actual type `Expr'
15:48:08 <lambdabot>     In the second argument of `(<$>)', namely `a'
15:48:23 <roboguy_> :t (>>>) <$> ?a <*> ?b
15:48:24 <lambdabot> (Applicative f, ?a::f (cat a b), ?b::f (cat b c), Category cat) => f (cat a c)
15:50:08 <roboguy_> :t ((>>>) <$> ?a <*> ?b) ?c
15:50:09 <lambdabot> (Applicative ((->) t), ?a::t -> cat a b, ?b::t -> cat b c, ?c::t, Category cat) => cat a c
15:52:33 <roboguy_> x77686d: you can emulate foldl with a foldr
15:52:47 <roboguy_> (you can't emulate foldr with foldl though)
15:53:19 <roboguy_> so it really depends on what you mean by a lambda that "only" uses cons
15:53:27 <x77686d> Interesting -- let think about that.
15:59:12 <intrados> What's the best/most idiomatic way to `takeWhile1 (/= "ab")` with Attoparsec? (Actual takeWhile1 takes Chars)
16:01:10 <skypers>     Can't make a derived instance of `MonadTrans SkyT'
16:01:11 <skypers>       (even with cunning newtype deriving):
16:01:11 <skypers>       cannot eta-reduce the representation type enough
16:01:13 <skypers> ouch
16:01:18 <skypers> how should I fix that?
16:02:52 <roboguy_> skypers: I think you'll have to write it by hand
16:05:43 <skypers> roboguy_: I might fail to write a correct newtype for my transformer stack?
16:05:51 <skypers> something like newtype SkyT m a = …
16:06:09 <skypers> deriving (MonadTrans m) results in something wrong
16:09:11 <roboguy_> x77686d: let me know if you want a hint
16:10:09 <roboguy_> skypers: hmm, I'm not sure what you mean
16:10:09 <rgr> yikes. get  accept-process-output  blocking and an emacs freeze using ghci in emacs 24  if I accidentally focus out of ghci into another emacs buffer.
16:10:42 <x77686d> roboguy: Maybe tomorrow! :)
16:11:16 <skypers> roboguy_: well, MonadTrans waits for (* -> *) -> * -> *
16:11:21 <skypers> expects, sorry*
16:11:37 <skypers> it expects a monad, a type and yields a type
16:11:42 <skypers> :k MonadTrans
16:11:43 <lambdabot> ((* -> *) -> * -> *) -> Constraint
16:12:07 <skypers> I don’t understand why I can’t derive it
16:15:07 <startling> skypers, we'd need to see your actual code to tell you.
16:15:38 <skypers> startling:
16:15:38 <skypers> newtype SkyT m a = SkyT {
16:15:38 <skypers>     runSkyT' :: EitherT SkyError (StateT LogQueue m) a
16:15:38 <skypers>   } deriving (Monad,MonadError SkyError,MonadState LogQueue)
16:16:40 <skypers> btw, I wonder why I have to put the type of error in the MonadError deriving, or the state for MonadState
16:17:43 <roboguy_> skypers: those are multiparameter type classes
16:18:04 <geekosaur> because it can only derive for kind *? and it's possible to have more than one MonadState or etc. in there, although you don't at the moment
16:18:20 <roboguy_> so instances look like "instance MonadError SkyError SkyT ..." rather than "instance MonadError SkyT ..."
16:18:39 <skypers> hm
16:18:39 <skypers> ok
16:18:47 <skypers> so why can’t I derive MonadTrans?
16:18:57 <joshinct> merijn: And, the answer, on which I will iterate as I learn more, but is now working thanks to your help debugging: http://pastie.org/8724147#1,7,11 Thanks immensely!
16:21:22 <rgr> could someone hold me my hand and show me how to dynamically "find out things about commands" in ghci. I want to use the ":doc" (its not defined in my .ghci) command. It tells me rather rudely that opera.exe is not there (of course not I use Linux!). So what are the steps for me to find out about ":doc" and what facilities are there for me to customise to get it working. Can it be done dynamically from the prompt. I assume yes.
16:21:52 <roboguy_> rgr: :h lists the ghci commands
16:21:59 <rgr> yes.
16:22:06 <roboguy_> are those the commands you mean?
16:22:09 <rgr> no
16:22:25 <roboguy_> you mean library functions and things like that?
16:22:27 <rgr> but if they were the same Q would apply.
16:22:53 <rgr> info is sparse. Im trying to have the system describe itself to me if you get my drift.
16:23:18 <roboguy_> rgr: I'm not sure I do... what about :!hoogle --info functionName?
16:24:19 <rgr> well lets start with ":doc". What is it and where is it. "hoogle --info doc" gives me something about a doc-review.
16:24:34 <roboguy_> oh. you can define your own commands. some people make one called ":doc"
16:24:49 <roboguy_> usually they have :doc ... translate into :!hoogle --info ...
16:24:50 <rgr> yes. I realise that. But how do I query where and what it is
16:25:22 <rgr> but not fixating on ":doc" :anotherdoc" would do.
16:25:30 <rgr> but not fixating on ":doc" ":anotherdoc" would do.
16:25:40 <roboguy_> ohh, you mean how to define new commands etc?
16:25:43 <rgr> no.
16:26:49 <rgr> see above "steps to find out about :doc". Im running blind here. I thought the system might tell me where it is and what it is and hat can be customised. Maybe it is hoogle? But I get nothing from that relevant.
16:26:58 <bicgena> How would you write " find the millionth element of the lexicographically sorted permutations of {0,...,9}." in haskell?
16:27:09 <benmachine> bicgena: getting the algorithm right is the hard part
16:27:26 <hakujin> rgr check ~/.ghci
16:27:30 <roboguy_> rgr: well, like I said, ":doc" is just a command that people define in their .ghci
16:27:40 <rgr> its not in my .ghci
16:27:47 <rgr> possibly its in something pulled in.
16:27:49 <benmachine> is it in a .ghci that isn't in ~
16:27:52 <bicgena> benmachine: here's how I did it in mathematica http://pastebin.com/Lr6nASgf
16:28:01 <benmachine> bicgena: I saw that but didn't understand it :P
16:28:44 <rgr> right. OK. Shoot me on this one again. :doc -> :docs ... sheesh. ok
16:28:45 <roboguy_> I think people usually hand write :doc
16:29:06 <roboguy_> oh I see
16:29:07 <rgr> ouch
16:29:23 <rgr> :def docs lambdabot "docs"
16:29:40 <roboguy_> rgr: try checking !/.ghc/ghci.conf
16:29:50 <roboguy_> I mean ~/.ghc/ghci.conf
16:29:53 <roboguy_> that's where mine is
16:30:00 <rgr> no need. :doc is the same as typing :docs it seems.
16:30:12 <rgr> so me being a noob.
16:31:06 <hakujin> intrados: manyTill anyChar $ string "ab" works but isn't as fast as takeWhile et al
16:33:24 <skypers> hm
16:33:40 <skypers> to write the MonadTrans instance of my monad stack
16:33:47 <skypers> can’t I just do something like
16:33:51 <skypers> return . lift . lift … . lift
16:33:51 <skypers> ?
16:34:34 <rgr> oh rats. I didnt have documentation on in my .cabal conf.
16:34:44 <bicgena> benmachine: what would your algorithm look like
16:35:43 <skypers> I said bull***
16:35:54 <skypers> lift = SkyT . lift . lift
16:35:55 <benmachine> bicgena: work out the digits one by one
16:36:17 <skypers> it’s funny GHC fails to infer that MonadTrans instance
16:36:23 <benmachine> bicgena: all the permutations with 1 first come before all the permutations with 2 first, etc.
16:36:29 <syllogismos> :t join (+)
16:36:29 <lambdabot> Num a => a -> a
16:36:46 <syllogismos> wat
16:36:51 <roboguy_> > join (+) 15
16:36:52 <lambdabot>  30
16:36:56 <benmachine> bicgena: it's easy to calculate how many permutations have 1 first
16:37:10 <roboguy_> syllogismos: that is using the ((->) r) Monad instance
16:37:15 <geekosaur> syllogismos, function application is a monad (the primitive reader monad)
16:37:25 <benmachine> likewise 2, etc.
16:37:32 <geekosaur> (that is, the Reader monad is just a fancy wrapper for this)
16:37:38 <benmachine> when you get up to your index, you spit out the first digit and then recurse
16:37:45 <benmachine> (I'm being intentionally vague on the details here)
16:38:03 <roboguy_> join (,) 5
16:38:05 <roboguy_> > join (,) 5
16:38:06 <lambdabot>  (5,5)
16:38:39 <SpecialK> :t join
16:38:40 <lambdabot> Monad m => m (m a) -> m a
16:38:49 <syllogismos> > (join (+) >>= (+) ) 15 -- evil haskell tip to multiply by 3
16:38:50 <lambdabot>  45
16:39:03 <SpecialK> heh I just saw that on the twitters
16:39:09 <skypers> syllogismos: the f*…
16:39:19 <roboguy_> multiplying by 3 the long way
16:39:22 <colDrMcBeardman> re: the doc thing, is there something that will spit out the local haddock html page of something searched for?
16:39:32 <colDrMcBeardman> it would be really cool if hoogle did that on the command line.
16:39:38 <skypers> oh
16:39:43 <skypers> that’s quite simple actually
16:40:07 <skypers> :t join (+) >>= (+)
16:40:08 <lambdabot> Num a => a -> a
16:40:31 <skypers> night
16:40:33 <syllogismos> :t (+) >>= (+)
16:40:34 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
16:40:34 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0 -> a0
16:40:34 <lambdabot>       Actual type: (a0 -> a0) -> (a0 -> a0) -> a0 -> a0
16:40:44 <roboguy_> in this case, join fn just takes "fn :: a -> a -> b" and gives you a "a -> b"
16:41:05 <benmachine> :t (+) >>= id >>= (+)
16:41:07 <lambdabot> Num a => a -> a
16:41:12 <skypers> :t (+) >>= (+1)
16:41:13 <lambdabot> (Num a, Num (a -> a)) => a -> a
16:41:24 <skypers> Num (a -> a)
16:41:25 <skypers> what?
16:41:27 <skypers> :D
16:41:32 <benmachine> bad idea
16:41:46 <roboguy_> :t join
16:41:47 <lambdabot> Monad m => m (m a) -> m a
16:41:47 <skypers> (+) >>= (+1) $ 3
16:41:57 <skypers> > (+) >>= (+1) $ 3
16:41:58 <lambdabot>  No instance for (GHC.Show.Show a0)
16:41:58 <lambdabot>    arising from a use of `M511288787503336685820855.show_M5112887875033366858...
16:41:58 <lambdabot>  The type variable `a0' is ambiguous
16:41:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:41:58 <lambdabot>  Note: there are several potential instances:
16:42:02 <skypers> yeah
16:42:10 <skypers> L.magicNumber
16:42:20 <roboguy_> if we substitute ((->) r) for m, we get (r -> (r -> a)) -> (r -> a) which is the same as (r -> r -> a) -> r -> a
16:42:57 <benmachine> @djinn (r -> r -> a) -> r -> a
16:42:57 <lambdabot> f a b = a b b
16:42:58 <roboguy_> "(Num b) => Num (a -> b)" might not be a bad idea
16:43:11 <skypers> > (+) >=> (*) 2 1
16:43:12 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
16:43:12 <lambdabot>    arising from a use of `M757282410387500779020865.show_M7572824103875007790...
16:43:12 <lambdabot>  The type variable `c0' is ambiguous
16:43:12 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:43:12 <lambdabot>  Note: there are several potential instances:
16:43:15 <skypers> ahah
16:43:17 <benmachine> roboguy_: fromInteger = const is not my idea of friendly
16:43:19 <skypers> ok, night ;)
16:43:45 <quchen> :t (+) >>= id >>= (+) -- Prettier this way. :-)
16:43:46 <lambdabot> Num a => a -> a
16:43:47 <lightquake> > 1 2 3 4 5
16:43:48 <lambdabot>  Could not deduce (GHC.Num.Num
16:43:48 <lambdabot>                      (GHC.Integer.Type.Integer
16:43:48 <lambdabot>                       -> GHC.Integer.Type.Integer
16:43:48 <lambdabot>                       -> GHC.Integer.Type.Integer
16:43:48 <lambdabot>                       -> GHC.Integer.Type.Integer
16:43:49 <kazagistar> eh, it probably still compiles down to the same assembly as x * 3 :P
16:44:05 <quchen> I don't think so.
16:44:32 <quchen> (+) and (*) are independent functions, and x+x need not be x*2.
16:45:07 <quchen> If you specialize the types to be Int, then this might be optimized. However, when you leave the types maximally polymorphic, such an optimization is illegal.
16:45:16 <roboguy_> I guess Num b => Num (a -> b) is covered by the Monoid instance for Monoid b => (a -> b) anyway
16:45:22 <roboguy_> for + and *
16:50:15 <Redz> how can i mark code in comments for haddock?
16:50:56 <ivanm> Redz: use @...@ for inline
16:51:04 <ivanm> or for a block, start each line with >
16:51:17 <ivanm> or have @<newline>code<newline>@
16:51:54 <Redz> ivanm: thank you. :)
16:52:13 <ivanm> np
16:54:07 <cmiller_> Hello all. Is anyone aware of any good papers or friendly documentation for the Control.Parallel module?
16:54:23 <Axman6> cmiller_: seen Simon Marlow's book?
16:55:01 <ivanm> that book is awesome; I bought it despite not having a need for concurrency or parallelism but found it rather easy to follow and interesting
16:56:29 <cmiller_> Axman6: No. Worth a read?
16:56:55 <bitemyapp> cmiller_: if you want to understand Control.Concurrent and Parallel? Absolutely.
16:57:20 <Axman6> cmiller_: uh, yeah, very much so
16:57:46 <cmiller_> bytemyapp: That's great. I just did brute force KNN with it and was super pleased how easy it came out.
16:58:56 * hackagebot markdown2svg 0.0.1.21 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.21 (YoshikuniJujo)
17:01:49 <rgr> googling it seems I need to reinstall to enable library profiling and docs for libraries already installed. using the following command I get the attached paste. is this the start of "cabal hell"? Easy to correct?
17:01:50 <rgr> cabal install --reinstall world --dry-run  -- http://dpaste.com/1606376/ (yanked)
17:01:50 <rgr>  
17:03:19 <dcoutts_> rgr: looks like base is in your world file, which is a bit odd, you could try removing it and trying again
17:03:42 <dcoutts_> rgr: but in general it's not always possible to install all of your "world" packages with consistent dependencies
17:03:56 <rgr> ok thanks. will try. (everysthing is installed from cabal fresh yesterday after installing haskell-platform)
17:04:16 <dcoutts_> rgr: ~/.cabal/world
17:04:40 <rgr> dcoutts: you were spot on. It was in there.
17:04:57 <rgr> I wont pretend to understand why thats a problem though.
17:05:09 <rgr> a rerun of the dry-run succeeds.
17:05:10 <dcoutts_> rgr: it meant you were effectively asking to install the base package from source, but that's not possible
17:05:37 <rgr> from source as opposed to what in haskell vernacular?
17:05:46 <dcoutts_> rgr: as opposed to an installed instance
17:06:00 <dcoutts_> rgr: note the bit in the error message where it says "only already installed instances can be used"
17:06:21 <dcoutts_> it's referring to the fact that the solver is not allowed to pick any source version of base
17:06:54 <dcoutts_> but by asking it to install base with --reinstall, you're also saying it must install a source from base, and not pick an installed instance
17:07:02 <dcoutts_> and those two constraints are inconsistent
17:07:58 <dcoutts_> erm, sorry not very clear. it must build base from source / pick a source instance of base, rather than installed
17:08:14 <rgr> ok thanks. compiling away. I guess thats me done for the day now.
17:08:57 * hackagebot markdown2svg 0.0.1.22 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.22 (YoshikuniJujo)
17:09:57 <rgr> oh god. its fallen over. sob. ok. I'll do a clean install.
17:10:40 <rgr> could not find module Prelude. wtf?
17:11:36 <Iloiny_> any clues as to how i could insert an element to a list n times? (ie at the front)
17:12:05 <structuralist> is it possible to simulate inductive-recursive definitions in Haskell?
17:12:13 <rgr> but I cant install ghx-dynamic because then I get a mashed system. Crikey this is complicated.
17:12:18 <rgr> ghc- even
17:12:54 <dcoutts_> Iloiny_: have you met the (:) operator?
17:13:33 <dcoutts_> structuralist: can you clarify what you're referring to?
17:13:59 <structuralist> dcoutts_: I'd like to do something like this: https://personal.cis.strath.ac.uk/conor.mcbride/pub/DepRep/DepRep.pdf
17:14:18 <structuralist> http://en.wikipedia.org/wiki/Induction-recursion_(type_theory)
17:14:38 <lightquake> > appEndo (mconcat . replicate 10 . Endo $ (1:)) [0,1,2]
17:14:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,0,1,2]
17:14:43 <jrmithdobbs> so, i know this sounds weird, but is there a sane way to do a recursive free monad? as in, using a type with Free/F that itself contains a Free/F ?
17:14:43 <lightquake> simple :)
17:14:47 <verement> > sort (permutations [0..9]) !! (1000000 - 1)
17:14:51 <lambdabot>  mueval-core: Time limit exceeded
17:15:05 <jrmithdobbs> i got something kind of working but it's extremely annoying to work with in general
17:15:09 <dcoutts_> structuralist: it'll probably come down to whether it needs dependent types or not
17:15:12 <jrmithdobbs> think: free funlist
17:15:26 <pranz> Iloiny_: insert n x xs = if (n == 0) then (insert x (n-1) (x:xs)) else xs
17:15:29 <pranz> like that?
17:15:59 <structuralist> dcoutts_: I've been playing around with data kinds and singleton types and type families to sort of do dependent types
17:16:00 <Iloiny_> i suppose - cheers
17:16:11 <MrRacoon> doh really?
17:16:11 <Axman6> except that runs forever on infinite lists pranz
17:16:18 <jrmithdobbs> it's mostly annoying because you can't inspect the future if represented as F but you can't convert from F to Free to do so if the type contains F and not Free =/
17:16:27 <structuralist> wondering whether it's possible to go as far as induction-recursion with available machinery
17:16:57 <pranz> Axman6: hmm? Why would it?
17:17:26 <dcoutts_> structuralist: there are people around here who could give you a better answer than me. If you pushed me to guess I'd say no.
17:17:34 <Axman6> pranz: why the recursive call to insert when n == 0?
17:17:56 <pranz> Axman6: oh, should be the other way around of course
17:18:14 <Axman6> actually, the whole function is quite confusing
17:18:35 <jrmithdobbs> i'll take that as a no ;p
17:19:07 <pranz> if (n /= 0)
17:19:14 <Redz> is there a nicer way to write (\x->x-r) ?
17:19:29 <geekosaur> (subtract r)
17:19:38 <novochar> I want to declare a dependency for my package, is there a command line command for this?
17:19:41 <Redz> thanks. :)
17:19:46 <novochar> cabal get_dependencies_for_this_package
17:19:48 * geekosaur grumbles at the syntactic hackery of unary minus
17:20:05 <dcoutts_> structuralist: so in the paper Conor is looking at representing dependently typed object languages in a type safe way in a host language, and relies on the host language being dependently typed
17:20:52 <dcoutts_> novochar: you mean you want to add an extra dep to the .cabal file, or you want to install the deps of the package?
17:21:32 <Redz> i run into a bug, because i've wrote ((-)r) ...
17:21:43 <structuralist> dcoutts_: yes, and my understanding is that Haskell can fake dependent types with e.g. http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf
17:22:03 <geekosaur> right, that's because (-) is the prefix form of subtraction and you supplied it the left parameter
17:22:17 <geekosaur> but (-r) doesn;t work because of unary minus, so it's not the section you'd expect
17:22:40 <geekosaur> (flip (-)) also works (and is the definition of subtract, IIRC)
17:24:09 <jfischoff> structuralist: with great difficult and in limited way
17:24:10 <pranz> Axman6, Iloiny_: improved it, now works on infinite insertions (if n is negative)
17:24:11 <pranz> insert n x xs = if (n /= 0) then (x : insert (n-1) x xs) else x
17:24:19 <dcoutts_> structuralist: I would be extremely surprised if you could do it all with encodings using singletons
17:24:41 <novochar> dcoutts_: I want to add an extra dependency to the cabal file based on what i've already downloaded?
17:24:51 <Axman6> pranz:  then x or then xs?
17:25:15 <Axman6> pranz: I'm pretty sure that doesn't type check
17:25:25 <dcoutts_> novochar: ok, just edit the .cabal file, it's supposed to be edited by humans, add your dep to the build-depends of the relevant component(s) in your .cabal file
17:25:38 <novochar> e.g.: cabal install word24 && #from here, I want a command that figures out the dependency and inserts it into my .cabal file
17:25:55 <novochar> If there isn't a command, is it normal for people to manually insert the dependencies themselves?
17:26:07 <novochar> how do you get the current version of a package you have installed?
17:26:19 <jrmithdobbs> ghc-pkg list
17:26:24 <jrmithdobbs> and yes
17:26:27 <dcoutts_> novochar: cabal does not have any commands to edit existing .cabal files. There's an init command to generate an initial .cabal file but that's it.
17:27:02 <dcoutts_> novochar: you can find out the version of an installed (or not installed) package using cabal info <pkgname>
17:27:32 <novochar> thanks dcoutts_
17:27:39 <dcoutts_> novochar: note that the set of packages you have installed, and the dependencies in a local .cabal file are quite different things
17:28:25 <jfischoff> dcoutts_: that's a good tip. I didn't know that
17:28:33 <jfischoff> cabal info
17:29:20 <dcoutts_> jfischoff: next up is making cabal list/search any good :-)
17:29:46 * dcoutts_ has a simple full-text search lib that he wants to use
17:29:53 <jrmithdobbs> dcoutts_: fix sandboxes with dynamic linking first please ;p
17:30:01 <jfischoff> oh I didn't know about list either
17:30:03 <dcoutts_> :-)
17:30:35 <dcoutts_> jrmithdobbs: is that combo borked?
17:30:38 <pranz> Axman6: x : xs
17:30:42 <pranz> Axman6: it does typecheck and run
17:30:53 <jrmithdobbs> dcoutts_: with .18 and 7.8.x branch builds it seems so at least on os x
17:31:20 <pranz> Axman6: oh, din't copy the last x
17:31:22 <pranz> s*
17:31:50 <jrmithdobbs> dcoutts_: if you cabal sandbox init; cabal install --dependencies-only; (normal stuff here); everything works great, until you cabal clean, and then you realize your libs all ended up in /usr/local instead of .cabal-sandbox and it can no longer link against any of them because dist/ is gone :(
17:31:50 <dcoutts_> jrmithdobbs: ah ok, but that's not special to sandboxes, the existing cabal-install doesn't know about ghc-7.8 using dynamic libs by default
17:32:04 <dcoutts_> jrmithdobbs: oh, hmm
17:32:05 <jrmithdobbs> dcoutts_: even using it explicitly
17:32:28 <dcoutts_> jrmithdobbs: presumably this is reported on the cabal bug tracker right?
17:32:49 <jrmithdobbs> dcoutts_: i haven't reported it, i just figure out what was going on earlier today
17:32:54 <jrmithdobbs> s/figure/figured/
17:33:10 <dcoutts_> jrmithdobbs: ok, make sure you do report it, if it's not already been
17:33:19 <jrmithdobbs> dcoutts_: i'll check in a bit
17:33:21 <dcoutts_> ta
17:33:35 <jrmithdobbs> no, thank you, sandboxes are awesome :)
17:34:03 <jrmithdobbs> cabal is almost to the point of bundler's usefulness, and that's a pretty high compliment imho ;p
17:35:02 * dcoutts_ didn't do most of the sandbox work, just advised, reviewed etc
17:35:22 <jrmithdobbs> meh, take the compliment :)
17:36:59 <dcoutts_> heh :-)
17:37:00 <jfischoff> dcoutts_: https://twitter.com/HaskellTips/status/433413219562971136
17:37:47 <dcoutts_> jfischoff: nice
17:40:02 <jfischoff> HaskellTips is like a 1/3 cabal flags and 1/3 Haskell Report :p
17:40:27 <bitemyapp> jfischoff: and 1/3 wizardry.
17:40:35 <jfischoff> ah
17:41:17 <jfischoff> bitemyapp: that's just Haskell!
17:42:40 <novochar> So if you wanted to use the library base24 in your package, could you specify a new dependency like this:  `build-depends: base24`
17:44:22 <bitemyapp> jfischoff: true.
17:44:32 <Hafydd> jfischoff: I think you meant: "You can't partially apply a type synonym; it usually best to define them with as few variables as possible, e.g."
17:45:22 <jfischoff> I did
17:45:38 * jfischoff goes to see what he actually said :p
17:46:12 <Hafydd> (You used a comma instead of a semicolon, and "i.e." instead of "e.g.")
17:46:44 <jfischoff> good to know
17:47:45 <jfischoff> I should learn the difference between i.e. and e.g. I guess
17:48:55 <geekosaur> id est/that is, exempli gratia/for example
17:49:13 <geekosaur> granted, it helps to know some Latin
17:49:34 <jfischoff> ah
17:49:47 <jfischoff> good to know
17:50:09 <geekosaur> the mnemonic might be "e.g." the "e" as in "example"
17:50:25 <geekosaur> (think "example given")
17:50:30 <jfischoff> I tell there is nothing like messing up in front of thousand peers to really help you remember something :)
17:50:58 <Axman6> or just e.g. == egzample ;)
17:51:01 <jophish_> What do people prefer: return $ f x, return . f $ x, or return (f x)
17:51:16 <Axman6> jophish_: I often use the former
17:51:17 <jophish_> or even return $ f $ x
17:51:23 <Axman6> well, the first
17:51:42 <geekosaur> depends on the person, really. some people are really allergic to $
17:51:47 <jophish_> Axman6: yeah, me too. I think that if f x doesn't contain too many parentheses that return (f x) is a little cleaner
17:51:58 <jophish_> too many $ sure is ugly
17:52:00 <jophish_> but the same for ()
17:52:10 <S11001001> jophish_: in such a case it typically looks like blah >>= \x -> return (f x) which is just liftM f blah.  So I collapse it
17:52:13 <Axman6> I tend to catch myself using quite a few $'s
17:52:24 <jfischoff> return (f x) looks the best to me, but I use the first
17:55:38 <jrmithdobbs> jophish_: i like (return . f) x
17:56:04 <jophish_> ah damn, I thought I forgot one
17:56:07 <jrmithdobbs> jophish_: separates the function "chain" from data distinctly while still highlighting the former with the ()
17:56:17 <novochar> build/exit
17:57:18 <dwcook> Given that f x is prettier than any way of presenting (g . h) x, I like to write a definition (e.g., in the where clause) for it sometimes, especially when it would make it clearer
18:01:08 <rgr> what do I need to do so my local hoogle command generates docs for xmonad libraries? A fresh install and then hoogle data but calling haskell-hoogle for something like namedScratchpadAction gives no data back. I have documentation flag set in .cabal/conf too.
18:02:49 <Redz> is `instance (Applicative v, Num a) => Num (v a)` a good idea?
18:04:19 <dwcook> Redz, probably not, since you can imagine someone wanting another instance for * → *.
18:04:27 <dwcook> Redz, define a newtype wrapper, maybe?
18:05:00 <dwcook> Err, I stated that wrong – but basically imagine a v that's something not necessarily Applicative
18:06:08 <Redz> should i write a dummy type class?
18:06:28 <dwcook> For what purpose?
18:07:25 <dwcook> When I say "imagine", I mean you can imagine someone wanting that, which doesn't gel with the instance you want to write, since then you'd have overlapping instances
18:07:47 <Redz> and a dummy type class would solve this.
18:08:01 <dwcook> I don't see how. Explain.
18:08:47 <Algebr> All - How is the Haskell list implemented? is it really a linked list??
18:09:11 <dwcook> Algebr, doesn't matter how it's implemented, but yes, it behaves like a linked list
18:09:40 <Algebr> dwcook:But then surely it must be really slow to work with?
18:09:48 <dwcook> Algebr, only if you use it wrong.
18:10:00 <Redz> all in all for a small geometry library. i added Vector v to the constraints. now everyone who want to add a type, who is a Vector and Applicative with a Num type is automatically a Num itself.
18:10:19 <Algebr> dwcook:Do things like hash tables even make sense for Haskell?
18:10:25 <dwcook> There are various other structures available for grouping things. See Seq, Array, Map, Set, Text (specialized to Chars), or various others
18:10:41 <dwcook> Well you can use a hash table in Haskell, but what you probably want is a Map
18:11:41 <Algebr> dwcook: Feelin' ignorant, but I thought Map/hash table was synonmous
18:11:55 <Iloiny_> is there the equivalent of C++'s std::accumulate for a list? or do i need to write a recursive function?
18:12:04 <dwcook> No, hash table is a way of implementing a map
18:12:25 <dwcook> The Map I'm referring to, from Data.Map, is actually implemented as a tree
18:13:08 <dwcook> Iloiny_, is it anything like foldr?
18:13:11 <dwcook> @type foldr
18:13:11 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:13:13 <dwcook> If not, what's it do?
18:13:18 <Algebr> dwook:Thank you.
18:13:21 <dwcook> (Was just guessing from the name)
18:13:23 <Algebr> dwcook*
18:14:02 <dwcook> Iloiny_, you don't often *need* to write a recursive function, since the right operations usually exist
18:14:20 <Iloiny_> dwcook, yes fold does nicely
18:14:33 <jrmithdobbs> holy shit, i just found a workable answer to my weird recursive free monad question in the last issue of the monad reader, this is what I really want
18:14:36 <jrmithdobbs> http://hackage.haskell.org/package/HLearn-algebra
18:21:34 <Algebr> I don't understand how it is that ghc can infer types but other compilers, say java/gcc can't. What is it about Haskell that type inference is so good/easy?
18:22:12 <Fuuzetsu> a different type system
18:22:23 <ThatOtherPerson> Algebr: Haskell has an algebraic typesystem - basically, it's designed to be able to reason about types algebraically
18:22:54 <ThatOtherPerson> Algebr: Have you ever used C++ templates?
18:23:18 <Algebr> ThatOtherPerson:No, but I did use Java generics, persumably that's similar?
18:23:23 <Fuuzetsu> a.k.a. the clusterfuck
18:23:33 <ThatOtherPerson> Not quite the same
18:23:38 <ThatOtherPerson> But maybe similar
18:23:57 <ThatOtherPerson> Haskell basically lets you do the same things, but in a more consistent and prettier way
18:23:59 <Fuuzetsu> templates are more powerful but they serve pretty much the same purpose
18:24:39 <Algebr> So its not like say Python/Ruby where the type becomes known at run-time, its actually known at compile time?
18:24:45 <ThatOtherPerson> yep
18:24:53 <Axman6> Algebr: Java's generics comes from some Haskell people iirr
18:25:04 <rgr> I'm confused again now. Ive installed everything with documentation (according to .cabal/config). I've generated hoogle data. Why do I still not get any hoogle data for xmonad modules? Or am i totally confused as to what hoogle is? Or do different things choose how and if they provide docs? I thought it was kind of a javadoc generation.
18:25:05 <Fuuzetsu> Axman6: source?
18:25:08 <dwcook> Python/Ruby have no ability to reason about types at compile-time – They are, in effect, languages with just a single type containing every value
18:25:34 <dwcook> Haskell, in that sense, is more powerful, since it has many types :)
18:25:34 <Fuuzetsu> rgr: did you combine the database you generated with the one used by your hoogle command?
18:25:45 <dcoutts_> rgr: doesn't xmonad install its stuff in a separate package db, and not as normal installs via cabal?
18:26:03 <rgr> thats the first I read anything about combining databases.
18:26:15 <rgr> ye gods its poorly documented. :( Sorry. I'm tired.
18:26:43 <Axman6> Fuuzetsu: http://www.acooke.org/cute/JavaGeneri1.html "Which explains why Philp Wadler, one of the people responsible for"
18:26:46 <Axman6> Haskell, was part of a team that wrote GJ (Generic Java),
18:26:51 <rgr> I installed xmonad with cabal. Thats all I know.
18:26:58 <dwcook> I wonder if it's fair to say Haskell has a category whereas Python has a monoid
18:27:51 <Fuuzetsu> Axman6: nice, that's good to know
18:37:13 <Fuuzetsu> Hask is a very boring category
18:37:35 <ddere> hehe i agree
18:39:06 <Fuuzetsu> and anyway, can you explain how exactly Python ‘has a monoid’?
18:39:21 <carter> @tell int-e thanks!
18:39:21 <lambdabot> Consider it noted.
18:39:53 <dwcook> Well, if you could form a category of Python's types in the same way you can with Haskell's, it'd end up having exactly one object
18:40:13 <dwcook> I just don't know whether it's fair to say that you *can* form such a category, mostly because I've barely contemplated it
18:40:19 <enthropy> rgr, dcoutts_ xmonad installs the library part just like other libraries do
18:40:23 <Fuuzetsu> dwcook: you can form the trivial monoidal category from Python's types, considering there's only one
18:40:34 <dwcook> Right, all I meant was that
18:40:35 <enthropy> there's no additional xmonad package db
18:40:48 <enthropy> but maybe we could/should do that
18:41:00 <Fuuzetsu> dwcook: problem is that the trivial monoid is very boring so that's not really saying anything ;P
18:41:18 <enthropy> since that would tie a particular /usr/bin/xmonad to the right library
18:41:40 <dwcook> Are you saying monoids in general are boring, or just the one with Python's values as the underlying set?
18:42:14 <ElmoOnLSD> a quick question, is there a way to load a haskell source file in a script being executed via runghc, similar to how it's done in ghci, ex: :load <filename>? Specifically, is there a way to accomplish this without having to explicitly define a module?
18:42:37 <dwcook> Either way, I'd say that Python is not as mathematically interesting as Haskell is
18:42:39 <Fuuzetsu> dwcook: I'm saying that single element monoid is boring
18:42:47 <dwcook> It's not a single element monoid
18:42:51 <cmiller_> Casting a python value to it's base type is an application of the forgetful functor.
18:43:14 <Fuuzetsu> dwcook: Well, what is it then? I asked but you haven't answered.
18:43:51 <dwcook> I'm not sure when you're referring to, but I already implied what I meant – Python values are the elements
18:44:09 <Fuuzetsu> oh, we're using values
18:45:29 <Algebr> dwcook: But how can we say that Python only has one type? I get a TypeError when doing "2" + 4
18:45:50 <dwcook> Algebr, that's not actually a type error, not in the sense we mean it here
18:45:52 <Fuuzetsu> I don't feel qualified enough to make an accurate call on what (non-boring) category we can form with Python values. I think I'll retire for today and continue reading the CT book.
18:46:18 <Fuuzetsu> Algebr: that's just an exception you can catch I believe
18:46:26 <Algebr> dwcook, what can I read to understand what you mean?
18:46:34 <Algebr> dwcook, right, TypeError is an exception
18:46:54 <johnw> Algebr: type errors as we mean them happen statically before the program is run; as opposed to runtime errors which result in exceptions
18:47:11 <johnw> in Haskell, you can't compile a program that attempts to add "2" and 4
18:47:16 <sipa> Algebr: types either refer to properties of _expressions_ (known at compile time), or properties of _values_ (at run time)
18:48:19 <Algebr> So Python doesn't "really" have types since there's no compile stage?
18:48:32 <ElmoOnLSD> Hello there, I was hoping someone might have a moment answer a question about loading functions from a file in Haskell?
18:48:33 <dwcook> Algebr, it has a compile stage, but it's more trivial than Haskell's
18:48:41 <dwcook> Python has exactly one type, not no types
18:49:03 <dwcook> This means that all operations are permitted on all values from the compiler's point of view
18:49:12 <simpson> Nothing's stopping people from implementing a Python that has more types, BTW.
18:49:17 <dwcook> But the runtime system may object; it can object in Haskell too
18:49:23 <simpson> It's totally possible, just of questionable utility.
18:49:53 <frx> simpson it would be a different language though, would it not?
18:49:58 <dwcook> For example, it objects when it tries to evaluate bottom, for example, when you try to apply head []
18:50:23 <simpson> frx: I'm going to say that no, you could implement the same semantics while having those types.
18:50:38 <Fuuzetsu> ElmoOnLSD: just ask
18:50:41 <simpson> frx: You'd just be lazy about when you report the errors; you'd wait until the actual moment of evaluation to report the error.
18:50:46 <simpson> (Sounds like another language that I know!)
18:51:29 <Fuuzetsu> it wouldn't really be Python because it would not be Guido Approved™
18:51:31 <johnw> dwcook: I'm not sure if there's any effective difference between "no types" and "exactly one type".  How could any language have no types at all?
18:51:38 <Fuuzetsu> also it'd be unpythonic for the same reason
18:51:41 <ElmoOnLSD> Thanks Fuuzetsu: here's my question: is there a way to load a haskell source file in a script being executed via runghc, similar to how it's done in ghci, ex: :load <filename>? Specifically, is there a way to accomplish this without having to explicitly define a module?
18:51:48 <frx> simpson would this compile? if True: 1 + 2\n else: "1" + "2"
18:51:50 <dwcook> johnw, I don't think it's possible.
18:52:21 <frx> simpson add print there since for a moment I forgot that if is just a statement
18:52:21 <johnw> yeah, so when he says that Python has no types, I think that's correct too, in the sense that there is no way to distinguish values as having different types at compile-time
18:52:34 <Fuuzetsu> ElmoOnLSD: I can't say I understand. Can you give a use-case?
18:52:49 <Fuuzetsu> Perhaps you're looking for ‘import’?
18:53:05 <simpson> Fuuzetsu: Note that GvR's stamp of approval has not graced any of the alternative Pythons, nor does it need to.
18:53:15 <Fuuzetsu> simpson: UNPYTHONIC
18:53:41 <simpson> frx: Sure, it'd compile; it'd compile to 3, doing type-checking on each literal and each operation opportunistically.
18:53:48 <ElmoOnLSD> Fuuzetsu: Sure, lets say you have a set of functions defined in a file foo.hs. And you have a script in another file myScript.hs. Inside the do block of myScript.hs I want to be able to invoke functions from foo, however I'd like to avoid having to go through the trouble of putting those functions inside a module.
18:54:17 <simpson> frx: (Also note that current CPython can already do most of that! In Python 3, even a trivial optimising Python compiler should be able to do that ahead of time.)
18:54:20 <ElmoOnLSD> in ghci, I'd just use :load foo
18:54:32 <ElmoOnLSD> is there an analog inside of a do block?
18:54:36 <dwcook> johnw, actually, I think having no types implies having no values
18:54:50 <johnw> dwcook: ooh, good point!
18:54:54 <frx> simpson then I fail to see in what way would python with more types be different than the python we have now.
18:55:12 <Fuuzetsu> ElmoOnLSD: Then no, you can't really do that because myScript doesn't know how to find foo.hs. You can make foo.hs into a module (perhaps like ‘module Utils where’) and then ‘import Utils’ in myScript at which point you can use your functions
18:55:28 <simpson> frx: Yeah, I've been saying that for a long time, but people around here really *really* like the idea that all dynamically-typed languages have only one type. Dunno why.
18:56:20 <ElmoOnLSD> Fuuzetsu: That's what I thought, just wanted to make sure. Thanks for the response :)
18:56:49 <Fuuzetsu> No problem. I'm unsure why you're reluctant on making foo.hs a module, it's just a question of adding a single line at the top.
18:58:09 <dwcook> johnw, I'm trying to think of a language useful despite having no values and failing
18:58:32 <ElmoOnLSD> Fuuzetsu: That would require renaming the file in order to accommodate the module name requirement of starting with a Capital letter. The assignment I'm working out explicitly states the filenames must be all lowercase. I was hoping to write some test scripts without having to change the file names
18:58:43 <tatts> how many lists will be allocated in here: (replicate 3 '!') ++ "bar"?
18:59:00 <S11001001> simpson: Perhaps because Harper's article is convincing?
18:59:08 <dwcook> I mean, you could imagine a procedural language for a robot that has no sensors and just goes left and right at fixed intervals. But that's boring.
18:59:21 <dwcook> s/procedural/imperative/
18:59:27 <simpson> S11001001: IYSS.
18:59:48 <S11001001> simpson: Sure.
19:01:21 <tatts>  will compiler creating "!!!" first, and then append "bar" to it, finally creating "!!!bar", or will it recognize it can be done in a single step without creating "!!!" first?
19:01:52 <tatts> *create
19:02:01 <kazagistar> can I make a monad out of "type Instruction a = Machine -> IO a"?
19:02:26 <dwcook> kazagistar, yes, that's isomorphic with a particular transformer stack, ReaderT Machine IO
19:02:50 <Algebr> I've saw that Haskell can use C libraries, how it is possible for one language to use stuff from another one?
19:02:57 <mikeplus64> > replicate 3 '!' ++ error "bar"
19:02:58 <lambdabot>  "!!!*Exception: bar
19:03:47 <Axman6> Algebr: everything compiles down into machine code, all you need to do is push the right things on the stack and make the call, exactly the same way C programs call other C functions
19:04:43 <Axman6> kazagistar: sure, that's just ReaderT Machine IO a
19:04:54 <dwcook> Axman6, beat you to it :)
19:04:56 <Axman6> kazagistar: what's it do?
19:05:04 <pavonia> tatts: I don't think GHC evaluates expressions like this at compile-time
19:05:09 <Axman6> dwcook: you missed the a :P
19:05:11 <Algebr> Axman6, thanks.
19:05:48 <dwcook> Yeah, I guess. I was describing Instruction, not Instruction a. Merely the referent was ambiguous. :P
19:06:15 <Algebr> Axman6, but presumably that would be that both languages would have to have been compiled for the same architectures, say both for x86 or both for arm
19:06:25 <Algebr> mean that*
19:06:39 <Axman6> Algebr: of course
19:07:51 <Axman6> Algebr: luckily, most operating systems only one a single architecture, maybe two (x86 and x86_64). OS X used to be able to run 4 (those two and PPC and PPC64)
19:08:01 <kazagistar> Axman6: this is my second haskell program of any size… its a virtual machine for an assembly language, and I am trying to make the operations easy to compose. Many involve IO, so I was thinking this might be the best method
19:08:22 <Axman6> kazagistar: what is Machine?
19:09:17 <Fuuzetsu> ElmoOnLSD: That sounds terrible and you should speak to however set the task. As a workaround, you could use a CPP directive to include foo.hs verbatim inside the module and work that way.
19:10:45 <kazagistar> Axman6: http://lpaste.net/99794
19:10:58 <tatts> so (replicate 10000000 'a') ++ string would be very inefficient? how to do it more efficiently?
19:11:59 <dwcook> kazagistar, did you consciously choose IORef as opposed to, say, TVar, or did you just choose that by default? IORef is among the less safe IO variable types
19:12:00 <pavonia> tatts: What do you mean by inefficient?
19:12:03 <tatts> without rewriting replicate and or ++ hopefully
19:12:22 <Axman6> kazagistar: are you sure you need IO at all? seems ST should be enough
19:12:56 <Axman6> dwcook: it's fine if you aren't doing anything concurrently
19:13:22 <tatts> pavonia: as far as I understand it will allocate 1 million char string first, then allocate another 1 million and 3 char string
19:13:24 <dwcook> Ah right, I sort of assumed concurrency for some reason. I've been doing a lot of concurrency :P
19:13:46 <Axman6> and IORefs are great for many concurrent uses too
19:13:58 <tatts> (assuming string has 3 characters)
19:13:59 <dwcook> Well sure, but I wouldn't *default* to it nonetheless
19:14:04 <kazagistar> Axman: dunno, I have instructions, they need to mutate the machine AND some need to be able to access IO, so they were going to be in IO anyways, and are the only things that touch the machine really
19:14:18 <kazagistar> er dwcook
19:14:38 <dwcook> kazagistar, as Axman6 points out, you might be fine
19:14:39 <pavonia> tatts: No, the string is allocated lazily depending on how it is used
19:16:03 <tatts> pavonia: if we just printed the resulting string how many times would it be allocated?
19:16:30 <kazagistar> In any case, I will try to figure out how ReaderT works… still wrapping my head around monads at all lol
19:17:17 <dwcook> kazagistar, ReaderT is just (Monad m) => r -> m a
19:17:29 <pavonia> tatts: once
19:17:47 <tatts> hmm
19:17:52 <dwcook> kazagistar, in other words, the thing you put in the reader is the same as if you gave it as an argument
19:17:54 <tatts> why?
19:18:12 <Axman6> kazagistar: figuring out how to make your own Machine -> IO a type into a monad will be educational and I recommend you give it a try
19:18:29 <pavonia> tatts: Because it read lazily, no part of the string is constructed/allocated before it is needed
19:18:43 <pavonia> *it's read
19:18:44 <kazagistar> dwcook: I'm not yet to the point where what it is tells me how to use it :/
19:19:13 * hackagebot markdown-pap 0.0.1.10 - markdown parser with papillon  http://hackage.haskell.org/package/markdown-pap-0.0.1.10 (YoshikuniJujo)
19:19:18 <pavonia> > take 3 (replicate 3 'a') ++ error "bar"
19:19:19 <lambdabot>  "aaa*Exception: bar
19:19:20 <bsqrd> howdy folks
19:19:27 <pavonia> err O.o
19:19:38 <tatts> hmm ^_^
19:19:44 <pavonia> > take 3 ((replicate 3 'a') ++ error "bar")
19:19:45 <lambdabot>  "aaa"
19:19:48 <dwcook> @hoogle Control.Monad.Reader
19:19:48 <lambdabot> Control.Monad.Reader module Control.Monad.Reader
19:19:48 <lambdabot> Control.Monad.Trans.Reader module Control.Monad.Trans.Reader
19:19:48 <lambdabot> Control.Monad.Trans.Reader type Reader r = ReaderT r Identity
19:19:50 <zorg24> I'm looking to learn functional programming, any recommened tutorials, MOOCs, etc (doesn't have to be Haskell but I'd prefer it); I have experience with java, python, ruby and RoR
19:19:54 <dwcook> Erm
19:19:57 <tatts> ah
19:20:05 <Axman6> zorg24: LYAH:
19:20:06 <dwcook> kazagistar, check this out http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Reader.html
19:20:07 <Axman6> @where lyah
19:20:08 <lambdabot> http://www.learnyouahaskell.com/
19:20:09 <ElmoOnLSD> Fuuzetsu: not sure what you mean
19:20:51 <tatts> pavonia: but you never reached 4th character. it is at that point I would expect second allocation to kick in
19:21:32 <zorg24> thanks Axman6 I'll check it out, does it have projects to do? (b/c typically that's how I've found a language best)
19:21:45 <dwcook> zorg24, you're in for a treat. Haskell is quite different from all of those.
19:21:50 <Axman6> it has exercises
19:21:53 <dwcook> zorg24, not projects per se, but it's good to follow along with the examples.
19:22:27 <Axman6> real world haskell has some case studies which are like projects, but I'd recommend using LYAH before moving to RWH
19:22:43 <pavonia> tatts: Yes, but then the first part is already read and isn't needed anymore, so its memory can be released by the garbage collection
19:22:50 <kazagistar> I still haven't finished LYAH, but it is certainly one of the better textbooks I have used
19:22:59 <zorg24> dwcook: ok cool you'll probably see me hanging around here asking questions in that case
19:23:36 <dwcook> zorg24, I look forward to it
19:24:11 <kazagistar> wow, reader monad is… so handy :D
19:24:21 <tatts> pavonia: i see. so two allocations will happen if we store the resulting string to some variable?
19:24:31 <tatts> or if we return it
19:24:32 <dwcook> kazagistar, was that facetious or no? :P
19:24:43 <pavonia> tatts: It's different if you do something like "let a = replicate 100000 'a'; print a; let b = a +++ "bar"; print b" because then a has to be kept in memory and be reused when b is created.
19:25:03 <tatts> yeah I think I am getting it
19:25:24 <dwcook> Reader is basically just (->), after all
19:25:27 <kazagistar> not at all, it makes doing certain compositions really easy
19:25:36 <kazagistar> ie exactly what I needed
19:25:40 <bsqrd> i have a question about streams. i want to write a function to interleave streams. this does the trick: interleaveStreams (Cons a as) bs = Cons a (interleaveStreams bs as) :: Stream a -> Stream a -> Stream a
19:26:05 <bsqrd> in my first attempt, i did this: interleaveStreams (Cons a as) (Cons b bs) = Cons a (Cons b (interleaveStreams as bs))
19:26:43 <bsqrd> i wanted to use that function in the following manner:  foldr1 interleaveStreams (map streamRepeat [0..])
19:27:15 <bsqrd> if i use the first version i sent, it works fine. if i use the second, it doesn't finish.
19:28:50 <bsqrd> i'm not sure why this is happening. It's obviously due to the way i originally wrote interleaveStreams. the second Cons (i.e., Cons b) must be forcing evaluation
19:29:55 <bsqrd> In the first definition, (interleaveStreams bs as) is a thunk
19:31:03 <zorg24> hey Axman6 I'm looking at the drop and take examples so based on the little bit I know about functional programming those are just returning the value but not mutating the variable right?
19:31:18 <bsqrd> in the second, (interleaveStreams as bs) is a thunk (i think). so, there must be something about "Cons a ( Cons b" that's forcing more evaluation than i want
19:32:26 <kazagistar> zorg24: just assume that no variables get mutated, and you will be essentially correct ;)
19:32:51 <zorg24> ok, although I also figured it out playing with ghci :D
19:33:46 <kazagistar> use :t with everything and learn to read type signatures as fast as you can and you will have an easier time
19:34:15 <zorg24> out of curiousity what's the reasoning behind banning mutability?
19:34:15 * hackagebot markdown2svg 0.0.1.23 - markdown to svg converter  http://hackage.haskell.org/package/markdown2svg-0.0.1.23 (YoshikuniJujo)
19:35:11 <kazagistar> zorg24: you know how globals are considered hard to reason about because stuff outside your current context might mess with it without you knowing, and it thus increases coupling?
19:35:37 <zorg24> ya
19:35:42 <Axman6> zorg24: it's the root of all evil
19:35:57 <zorg24> lol had a feeling someone would say that
19:36:18 <Axman6> immutability as the default is far far more sane than mutability
19:36:38 <kazagistar> my eyes were opened to it from the "clojure/complect" talk
19:36:55 <Axman6> zorg24: heard of software transactional memory?
19:37:21 <zorg24> Axman6: yes when reading about PyPy but I don't understand it
19:38:01 <jle`> assuming immutability makes your code a lot easier to reason with, as well.  almost of all the complications from reasoning about imperative code is keeping track of the mutations.
19:38:01 <Axman6> well, several different languages have tried to implement STM, and so far Haskell is the only one that has managed it in a nice way that isn't broken
19:38:13 <Axman6> and that's because we control mutability and side effects
19:38:16 <kazagistar> zorg24: http://www.infoq.com/presentations/Simple-Made-Easy  (hopefully no one minds that it is about clojure, but it explains it pretty well in my opinion)
19:39:05 <jle`> and remember that we talk about immutability at the language level, not at the implementation level.  At the implementation/compiler level, the compiler can take advantage of mutability to perform things quickly.  but at the language level, we are only given immutable ways to "think" about things.
19:39:08 <zorg24> oh gosh lisp like syntax always confuses the heck out of me for some reason
19:39:28 <jle`> and yes, these days immutability is very important for things like parallel and concurrent programming
19:40:17 <kazagistar> zorg24: I am not particularly fond of it either, its not needed to understand the video
19:40:25 <zorg24> ok cool
19:40:42 <jle`> 2but even for single-threaded programming, immutabijkjkjk
19:40:55 <jle`> sorry, client exploded v.v
19:40:55 <kazagistar> zorg24: not sure he even shows any clojure at all
19:41:00 <Axman6> zorg24: maybe you'll like http://www.haskell.org/haskellwiki/Why_Haskell_matters
19:41:28 <zorg24> i think maybe if the matching parens were colored I could read but I've never seen something like that
19:41:46 <Axman6> they tend to use indentation for that
19:41:50 <dabd> I am learning Haskell by reading LYAH and just when I am finishing the book (in the penultimate chapter) I bought the new 'Beginning Haskell -  a project based approach'  and it seems good.
19:42:19 <dabd> The author seems to be like FunctionalFP as an IDE. I thought most haskellers used Emacs
19:42:30 <Axman6> dabd: that book seemed a bit sus to me, no one seems to have ever heard of the author
19:42:31 <jle`> dabd: why do you think that? :P
19:42:54 <zorg24> I know I just have the notion of indentation being associated with blocks engrained in my head
19:43:54 <kazagistar> I use sublime text :P
19:44:22 <kazagistar> but that is probably because I am not really a proper haskell programmer yet :P
19:44:31 <dabd> Axman6:  I found it through reddit http://www.reddit.com/r/haskell/comments/1wtdlf/new_haskell_book_beginning_haskell_a_projectbased/. So you think the author is not reputable?
19:44:44 <jle`> dabd: i've only heard good things about the book so far
19:44:56 <zorg24> sublime text was what I was planning on using
19:45:14 <dabd> jle`: so eclipseFP is popular?
19:45:34 <jle`> dabd: i do not have enough information to say
19:45:55 <jle`> but haskell users develop on a wide variety of ide's and editors
19:46:00 <jle`> haskell programmers
19:46:17 <dabd> can anyone more experienced in Haskell give an opinion on the book?
19:46:19 <jle`> it would be interesting to see a distribution though
19:46:22 <Platz> Axman6: the author makes some endorsements of EclipseFP ( haskell in Eclipse ) but it seems ok in general.  Main benefit is seeing concrete exapmles for each of the major language features
19:46:34 <zorg24> my experience with eclipse plugins is that they are nice just don't expect the same level of integration that java has with eclipse
19:48:43 <dabd> My learning plan was to finish read LYAH then go through Brent Yorgey's lectures http://www.seas.upenn.edu/~cis194/lectures.html and do the homework exercises
19:50:19 <Platz> Heres a comment to consider for learning http://www.johndcook.com/blog/2014/02/10/real-world-haskell/comment-page-1/#comment-262223
19:50:57 <Algebr> I'd love to work in Haskell for a day job, but I don't really see job offers for it. Who actually gets paid for coding Haskell?
19:52:19 <Axman6> there's several banks using it, companies like galois, some other financial places, and companies like FP Complete
19:52:53 <Algebr> Hmm, I work in Finance and never heard of anyone using Haskell, the closest is Ocaml at Jane street.
19:53:43 <Algebr> :(
19:53:52 <Axman6> several of the biggest investment banks are using it (JP Morgan I think is one, can't remember the others)
19:54:17 <dabd> Platz: thanks for the link. Will follow Kmett's advice
19:55:07 <stolaruk> I'm new to vim but trying to get vim-hdevtools working. When I open a .hs file in vim, I see "hdevtools: hdevtools is not executable!" Anyone know what this could be?
19:55:18 <zorg24> Axman6: why would Haskell by advantageous for a bank?
19:55:30 <Axman6> Algebr: http://www.haskell.org/haskellwiki/Haskell_in_industry has a (probably a bit out of date) list of commercial users
19:56:01 <Algebr> zorg24, probably because you could parallelize complicated pricing algos.
19:56:09 <Axman6> zorg24: well, immutability by default makes reasoning about code much easier, so their code gives very high assurances
19:56:32 <zorg24> gotcha
19:56:36 <Axman6> also STM lets them handle complex interactions between concurrent procedures elegantly
19:56:41 <kazagistar> so now I have a couple of functions which are "Something -> Machine -> IO Stuff"… should it be easy to convert them to "Something -> ReaderT Machine IO Stuff"? or does that not even make sense?
19:57:14 <Axman6> kalloc: that's exactly what you've got =)
19:57:17 <Axman6> uh, kazagistar
19:58:05 <kazagistar> ill take it as the latter and keep thinking :)
19:58:49 <startling> :t let x _ = return () :: () -> IO () in ReaderT x
19:58:49 <lambdabot>     Couldn't match type `()' with `IO ()'
19:58:50 <lambdabot>     Expected type: () -> IO ()
19:58:50 <lambdabot>       Actual type: () -> ()
20:06:17 <startling> :t ReaderT
20:06:18 <lambdabot> (r -> m a) -> ReaderT r m a
20:06:58 <startling> :t let x :: () -> IO (); x _ = return (); in ReaderT x
20:06:59 <lambdabot> ReaderT () IO ()
20:07:02 <startling> there we go.
20:07:06 <startling> kazagistar, ^
20:11:10 <kazagistar> … I wish I knew what that meant
20:13:23 <stolaruk> If anyone wonders about my question above, putting the hdevtools executable in my path fixed it
20:16:43 <startling> :t ReaderT -- kazagistar
20:16:43 <lambdabot> (r -> m a) -> ReaderT r m a
20:19:50 <zorg24> so I was just reading the explanation of the benefits of lazy sort but it doesn't seem like a big deal finding the lowest k elements in a list seems trivialy doable in linear time
20:20:37 <zorg24> oh wait well I guess not if don't know how big k is upfront.... nvr mind I get it now
20:20:54 <dhrosa> n*k time?
20:21:05 <Axman6> we get optimal time for free
20:21:06 <kazagistar> Couldn't match expected type `ReaderT Machine IO Address' with actual type `Machine -> IO Int' … hmm :(
20:21:16 <Axman6> which is n*log k
20:21:21 <frx> zorg24, if all you do is the first element from a sorted list nothing else needs to be sorted
20:21:28 <frx> is take the first element*
20:21:47 <Axman6> kalloc: they're not exactly the same, but something of type ReaderT Machine IO a contains something of type Machine -> IO a
20:22:52 <zorg24> axman6 you're saying if don't know k upfront right? otherwhise I'd think its n time and k space
20:25:23 <zorg24> wait how do you "get it for free" are you saying I could just write any old sorting algo and that would just work? I would think it'd only work for some algos (eg doesn't seem like it work for binary sort)
20:25:39 <frx> in a lazy language we can implement min like this: `take 1 (sort list)'. in a strict language it would be inefficient because entire list would be sorted before we could take the first element.
20:26:10 <kazagistar> Axman6: so I have to wrap up each thing I wish to use in the ReaderT?
20:26:14 <Axman6> zorg24: no, it works because sort is merge sort, which lazily produces results
20:26:31 <alex__> @src map
20:26:31 <lambdabot> map _ []     = []
20:26:31 <lambdabot> map f (x:xs) = f x : map f xs
20:26:36 <zorg24> Axman6: oh ok
20:26:38 <Axman6> kazagistar: you don't have to, if you want top use all the definitions ReaderT has, then yes
20:28:59 <kazagistar> Axman6: I was just looking at the Simple Reader example from the Control.Monad.Reader docs and it seems like it just understood that Bindings -> Int was a Reader Bindings Int  monad, but ReaderT does not work the same way?
20:29:18 <zorg24> I wouldn't think merge sort would work for that, b/c how would know when you've merged the smallest element
20:29:38 <Axman6> @src Reader
20:29:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:29:41 <Axman6> bleh
20:29:46 <Axman6> @hoogle Reader
20:29:46 <lambdabot> Control.Monad.Reader module Control.Monad.Reader
20:29:46 <lambdabot> Control.Monad.Trans.Reader module Control.Monad.Trans.Reader
20:29:46 <lambdabot> Data.Text.Lazy.Read type Reader a = Text -> Either String (a, Text)
20:30:15 <Axman6> hmm
20:30:31 <kazagistar> link: http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Reader.html
20:30:58 <alex__> @hoogle (a, b) -> b
20:30:59 <lambdabot> Prelude snd :: (a, b) -> b
20:30:59 <lambdabot> Data.Tuple snd :: (a, b) -> b
20:30:59 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
20:31:00 <jtbandes> Why doesn't this work as expected? "foo x = bar ... where bar x = 3 ; bar _ = 4"
20:31:14 <jtbandes> I would expect the "x" to match only if it's identical to foo's argument
20:31:47 <Axman6> jtbandes: haskell doesn't do that
20:32:05 <Axman6> x could be a function, so it's not possible to pattern match like that
20:32:20 <enthropy> it works that way if you have 'x' or "x" or 5
20:32:33 <alex__> it could be allowed if x is not a function
20:32:39 <enthropy> which adds an Eq constraint
20:33:06 <jtbandes> enthropy: but if I simply added foo :: Eq x => ... that wouldn't change the behavior, would it?
20:33:15 <enthropy> no
20:33:20 <zorg24> I just checked the source for list it actually has qsort and a merge sort, I can't tell how it chooses which to use though...
20:33:36 <enthropy> you can write   foo x = bar ... where bar x' | x == x' = 3 ; bar _ = 4
20:34:22 * hackagebot generic-maybe 0.3.0.2 - A generic version of Data.Maybe  http://hackage.haskell.org/package/generic-maybe-0.3.0.2 (JonathanFischoff)
20:34:49 <enthropy> it might be quite reasonable to disallow shadowing of variables, and have things work as you were expecting
20:35:07 <enthropy> but that's just not how they decided to design the language
20:35:59 <Heather> :t ($)
20:36:00 <lambdabot> (a -> b) -> a -> b
20:36:13 <Heather> :t (.)
20:36:14 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:36:27 <Heather> :t (<<)
20:36:28 <lambdabot>     Not in scope: `<<'
20:36:28 <lambdabot>     Perhaps you meant one of these:
20:36:28 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
20:36:40 <kazagistar> I still have no idea why my code isn't working… it seems like the examples….
20:36:40 <Heather> :t (=<<)
20:36:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:37:23 <Heather> $ is left pipe? right?
20:37:41 <jle`> it's
20:37:43 <jle`> @src ($)
20:37:43 <lambdabot> f $ x = f x
20:37:58 <jle`> > length [1,2,3]
20:37:59 <lambdabot>  3
20:38:00 <jle`> > length $ [1,2,3]
20:38:02 <lambdabot>  3
20:38:12 <jle`> it's kinda silly actually
20:39:05 <Axman6> well, no, it's not
20:39:15 <jle`> jtbandes: why would bar y = 3 behave differently than bar x = 3?
20:39:23 <Axman6> > sum . map length $ [[1,2,3],[4],[]]
20:39:24 <lambdabot>  4
20:40:23 <Heather> > putStrLn $ 2 + 2
20:40:25 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
20:40:25 <lambdabot>    arising from a use of `GHC.Num.+'
20:40:25 <lambdabot>  Possible fix:
20:40:25 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Base.String)
20:40:36 <jle`> :t putStrLn
20:40:37 <lambdabot> String -> IO ()
20:40:37 <Heather> > putStrLn $ "2" ++ "2"
20:40:38 <lambdabot>  <IO ()>
20:40:45 <enthropy> jle`: there's an x already in scope
20:41:03 <frx> > map ($'a') [toUpper, toLower]
20:41:04 <lambdabot>  "Aa"
20:41:31 <Heather> jle` why I can't pass stuff to putStrLn with $ ?
20:41:42 <jle`> Heather: you can, you just did
20:41:50 <Heather> > putStrLn ( "2" ++ "2" )
20:41:51 <lambdabot>  <IO ()>
20:41:57 <jle`> et voila
20:42:03 <frx> lambdabot does not execute IO
20:42:17 <jle`> you can think of $ as the spine of a butterfly spreading its parentheses wings around both sides of it
20:42:25 <jle`> Heather: look at the type of putStrLn
20:42:28 <jle`> :t putStrLn
20:42:29 <lambdabot> String -> IO ()
20:42:35 <jle`> it takes a String and returns an IO object
20:42:41 <jle`> it does not return a string
20:42:47 <jle`> and it does not execute a print instruction
20:42:56 <jle`> it is an IO object representing the act of printing a string
20:43:31 <Heather> jle` should it be in do ?
20:43:36 <jle`> which you can give to ghc which it can compile that act to assembly...or haste where it can compile that act to javascript, etc.  it's an abstract data structure representing a printing action
20:43:41 <randomclown> Your patience with my incessant trolling as paid off
20:43:48 <randomclown> I've finished my haskell project
20:43:56 <jle`> putStrLn does not print anything inherently
20:44:22 <jle`> you can think of it as a little packet of C code that prints a string, even
20:44:34 <jle`> it is just an abstract thing representing the act of printing a string
20:44:41 <Heather> anyways I've got situation where foo ( bar ) works and foo $ bar doesn't
20:44:52 <Axman6> > map head . words $ "they don't think it be like it is, but it do"
20:44:53 <lambdabot>  "tdtibliibid"
20:44:59 <Heather> so I think they are not the same, possibly priority difference
20:44:59 <Cale> Heather: does it involve runST?
20:45:13 <Heather> Cale: what is runST?
20:45:18 <Cale> :t runST
20:45:19 <lambdabot> (forall s. ST s a) -> a
20:45:22 <jle`> Heather: can you...post an example?
20:45:44 <Heather> >> putStrLn ( replicate 92 '_')
20:45:58 <Heather> jle`: it's working variant
20:46:03 <Cale> Some versions of GHC really don't like to unify type variables with polymorphic types, and so runST $ ... won't work while runST (...) will
20:46:07 <enthropy> Cale: ghc's typechecker has a special case for ($) that lets that one work :)
20:46:20 <Cale> But yeah, in some recent versions there's a special case
20:46:33 <enthropy> probably it's been that way for a few years?
20:46:35 <enthropy> dunno
20:47:01 <Cale> Could be!
20:47:18 <jle`> > length $ replicate 92 '_'
20:47:19 <lambdabot>  92
20:47:23 <Cale> I tend to forget exactly when little things like that happened
20:47:27 <jle`> > length (replicate 92 '_')
20:47:28 <lambdabot>  92
20:47:52 <jle`> > putStrLn (replicate 92 '_')
20:47:53 <lambdabot>  <IO ()>
20:48:01 <jle`> > putStrLn $ replicate 92 '_'
20:48:02 <lambdabot>  <IO ()>
20:48:04 <jtbandes> jle`: because x has meaning from the scope of the definition of "foo"
20:48:09 <Cale> I think that's somewhat unfortunate actually. With little things like that, I think I'd prefer there be some general solution, or no solution at all.
20:48:32 <Cale> Special cases like that complicate understanding the behaviour of the type system.
20:48:33 <jle`> jtbandes: yeah, but it's a little spooky, isn't it?
20:48:48 <ion> 0) make “runST do { … }” work, 1) remove the ($) kluge. :-P
20:48:50 <jle`> (\x -> f x) is diferernt than (\y -> f y) ?
20:48:54 <Heather> jle`: the thing is that I've got >> before it
20:49:11 <Heather> jle`: so >> got  more priority than $ I think
20:49:13 <jle`> this kinda ruins the whole alpha substitution equivalence thing
20:49:15 <Cale> jle`: It's probably better to say, btw, that the *evaluation* of putStrLn "hello" doesn't print anything, while the *execution* of it inherently does.
20:49:35 <jle`> Heather: everything has more priority than ($)
20:49:36 <Cale> jle`: hm?
20:49:43 <jle`> Cale: oh, referring to jtbandes
20:49:45 <enthropy> jle`: type variables tend to work that way
20:50:09 <Cale> What case seems to ruin alpha equivalence?
20:50:19 <Heather> jle`: then I need left pipe with high priority
20:50:36 <jle`> Cale: he wants to say foo x = ...; where bar x = ....
20:50:41 <jle`> and have it mean
20:50:42 <Heather> jle`: how haskell build priority table by operators?
20:50:50 <jle`> foo x = ...; where bar x' | x' == x = ...
20:51:02 <enthropy> myEq x x = True; myEq x y = False
20:51:05 <Cale> oh, yeah, that'll never happen :)
20:51:19 <jtbandes> jle`: only a little. I think my knowledge of prolog is coloring my opinion :)
20:51:20 <jle`> Heather: every operator has a number that specifies its precedence
20:51:30 <Heather> jle`: like if I will define my own left pipe just like $ but call it <| will it have more priority?
20:51:39 <jle`> Heather: you can manually specify the precedence
20:51:51 <Heather> how
20:51:51 <Cale> jtbandes: Generally you can expect that every variable occurring in a pattern is a binder
20:51:56 <jle`> infixr (<|) 4
20:51:58 <jle`> or infixl
20:52:07 <jle`> um. the number is zero to nine?
20:52:10 <jle`> i forgot exactly
20:52:49 <Cale> (I suppose I should make some exception for ViewPatterns, but even there the rule is pretty clear, the stuff on the right of an <- is an expression, and the left is a pattern)
20:53:10 <jle`> you should find a good explanation in the report
20:53:30 <dmj`> "A fixity declaration gives the fixity and binding precedence of one or more operators. The integer in a fixity declaration must be in the range 0 to 9. "
20:53:46 <Heather> but isn't there something already like left pipe with high priority, maybe in lens ?
20:54:05 <edwardk> Heather: (&)
20:54:19 <Cale> Heather: It's probably saner just to write your function applications in a normal way...
20:54:24 <Heather> :t (&)
20:54:25 <lambdabot> a -> (a -> b) -> b
20:54:28 <Cale> and/or use function composition
20:54:36 <edwardk> Heather: it has priority 1, not very tightly binding
20:54:45 <frx> > "foo" & length
20:54:47 <lambdabot>  3
20:54:55 <Heather> @hoogle (&)
20:54:55 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
20:54:55 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:54:55 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
20:55:02 <edwardk> it is designed to bind just slightly tighter than ($)
20:55:04 <enthropy> jle`: http://www-ps.informatik.uni-kiel.de/currywiki/ for a language that does have such patterns
20:55:27 <Heather> edwardk: is it from lens? :S
20:55:27 <jle`> it's weird :'(
20:55:31 * Cale kind of wishes this sort of thing wasn't around to tempt beginners
20:55:34 <edwardk> Heather: yes
20:55:43 <edwardk> Cale: sorry =)
20:56:18 <jle`> i would take alpha equivalence over implicit equality tests. but i guess there are languages that take the other route, and people who believe it is saner
20:56:42 <Cale> jle`: It gets really confusing in the presence of nonstrict semantics as well
20:56:59 <Cale> because the order in which the equality tests are done can affect the strictness of functions
20:57:08 <jle`> is Curry a unification-based language?
20:57:30 <jle`> (i invented that term just now i think)
20:58:06 <Cale> There's a bit of discussion of this possibility (nonlinear patterns) in SPJ's book on the implementation of functional programming languages
20:59:04 <DarkFox> Anyone here have any view for how or for if "hashtables" would be suitable for a base when creating a DHT?
20:59:06 <jle`> i feel like it'd make things a little less modular
20:59:16 <Heather> edwardk: but still & has less priority than >> ?
20:59:33 <jle`> but i guess where bindings throw away some degree of modularity
20:59:50 <enthropy> Heather: you can :info >>   :info &  to check that
21:00:02 <Heather> :info >>
21:00:10 <jle`> on ghci :)
21:00:10 <Heather> :info (>>)
21:00:12 <enthropy> in ghci, too bad lambdabot doesnt know
21:00:12 <jle`> also (>>)
21:00:27 <enthropy> no parens
21:00:34 <jle`> :O
21:00:34 <edwardk> heather: lambdabot doesn't do :info, but ghci does
21:00:47 <jle`> how odd
21:00:52 <enthropy> oh parens don't hurt
21:01:01 <jle`> oh how odd it is that parens aren't required
21:01:03 <DarkFox> :t (>>)
21:01:04 <lambdabot> Monad m => m a -> m b -> m b
21:01:18 <enthropy> because info is for single identifiers not whole expressions
21:01:22 <Heather> they've got 1, both
21:01:32 <Heather> then who first?
21:01:59 <edwardk> Heather: if they agree on being l or r  then they go in nesting order, if they don't then you can't use them together without explicit parens
21:02:11 <jle`> just like 6 / 3 * 7
21:02:32 <jle`> in normal math
21:02:54 <Heather> but I can write 6 / 3 * 7 without caring what will first...
21:03:03 <edwardk> Heather: can you?
21:03:10 <jle`> > 6 / (3 * 7)
21:03:11 <lambdabot>  0.2857142857142857
21:03:16 <jle`> > (6 / 3) * 7
21:03:17 <lambdabot>  14.0
21:03:18 <edwardk> > (6 / (3 * 7), 6 / 3 * 7)
21:03:19 <lambdabot>  (0.2857142857142857,14.0)
21:03:24 <Axman6> 6 / (3*7) /= (6/3)*7
21:03:45 <Axman6> Q.E.D
21:03:48 <Axman6> >_>
21:03:58 <jle`> well
21:04:08 <Heather> ahm ) sure
21:04:36 <edwardk> :t (const & id) >> id, const & (id >> id), const & id >> id)
21:04:37 <lambdabot> parse error on input `,'
21:04:40 <edwardk> :t ( (const & id) >> id, const & (id >> id), const & id >> id)
21:04:41 <lambdabot> (a -> a, a1 -> b -> a1, a2 -> a2)
21:05:02 <edwardk> thy are both infix so note that they get associated to the left, like the first case there
21:05:13 <Heather> > 6 / $ 3 * 7
21:05:15 <lambdabot>  <hint>:1:5: parse error on input `$'
21:05:16 <edwardk> x & y >> z = (x & y) >> z
21:05:35 * DarkFox assumes either no one has a view for the hashtables as a possible base for a DHT or it was missed... 
21:06:14 <edwardk> DarkFox: i think its mostly that not many people in here like to think about imperative hash tables =
21:06:15 <Heather> > (* 7) <$> 6 / 3
21:06:16 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
21:06:16 <lambdabot>    arising from a use of `M620791017407098114822689.show_M6207910174070981148...
21:06:16 <lambdabot>  The type variables `b0', `f0' are ambiguous
21:06:16 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:06:16 <lambdabot>  Note: there are several potential instances:
21:06:32 <frx> > (* 7) $ 6 / 3
21:06:33 <lambdabot>  14.0
21:06:48 <DarkFox> edwardk: Would a DHT really require to be imperative?
21:06:50 <orzo> is it possible to use TVars and STM within the ST monad?
21:06:59 <Heather> > * 7 $ 6 / 3
21:07:00 <lambdabot>  <hint>:1:1: parse error on input `*'
21:07:07 <edwardk> DarkFox: you said the hashtables package didn't you?
21:07:20 <Axman6> orzo: no, nore should it be. ST is for pure computations only
21:07:26 <Heather> so it's situation when I need brackets or left pipe with 2 priority ... ?
21:07:27 <Axman6> nor*
21:07:32 <lispy> @tell jfischoff "To use the module for you type," your* :)
21:07:33 <lambdabot> Consider it noted.
21:07:33 <DarkFox> edwardk: Hashtables imperative?
21:07:37 <edwardk> Heather: yes
21:07:40 <edwardk> DarkFox: yes
21:07:56 <edwardk> Heather: or to just restructure the code to not use operators there
21:08:00 <Heather> edwardk: lens got no pipe with 2 priority?
21:08:08 <edwardk> a pair of parentheses isn't _that_ hard on the eyes
21:08:12 <edwardk> Heather: correct
21:08:21 <Heather> omg, lens got no something...
21:08:34 <edwardk> Heather: 10 operators to hit every precedence desire isn't a good usability story ;)
21:08:49 <DarkFox> edwardk: Where imperative?
21:08:59 <edwardk> we used t have a high priority one (^&) or something, but its gone now.
21:09:11 <edwardk> DarkFox: IO and ST s everywhere as far as the eye can see
21:09:11 <Heather> edwardk: well... left pipe is core operator and priority variants should be good
21:09:34 <edwardk> Heather: it is core... in f# because they need it to work around bad inference.
21:09:40 <DarkFox> Hmm
21:09:44 <edwardk> Heather: it isn't a big part of the culture here
21:09:59 <Heather> edwardk: but I used to use F# a lot and my brain is F# damanged
21:10:35 <edwardk> Heather: then beat your head against the haskell way of thinking for a while and eventually you'll pound out a few dents ;)
21:10:44 <DarkFox> edwardk: I thought hashtables was preferred for the different lookups...
21:11:01 <Heather> edwardk: well pipe is better then brackets, isn't it just mandatory true?
21:11:20 <edwardk> Heather: failed to parse that ;)
21:11:49 <Heather> edwardk: ok... I'll try to be shorter ) isn't pipes better than brackets
21:12:16 <levi> Woot, I just gave an introductory presentation on haskell to a local users group.
21:12:26 <DarkFox> levi: :D
21:12:27 <Heather> edwardk: my English is terrible when I try to say what is coiming in my head without trying to form it in English :S
21:12:34 <DarkFox> levi: Country/region?
21:12:37 <edwardk> i can't recall the last time i needed to use the two together. remember you have do sugar available.
21:13:10 <edwardk> use the >> and >>= operators when they make code clearer, fall back to 'do' when they do not.
21:13:17 <levi> There were notable PLT researchers in the audience, too. It was a little bit intimidating.
21:13:50 <DarkFox> levi: Well you can relax now :D
21:14:21 <kazagistar> edwardk: should I use fmap with >>=? It comes up all the time, but hlint does not like it
21:14:33 <Heather> edwardk: revert ^& !
21:14:48 <kazagistar> it wants me to do this thing <$> which makes the "order" jump back and forth
21:15:16 <levi> DarkFox: Heh, yeah. Fortunately they were not the heckling type. ;)
21:15:34 <DarkFox> levi: :)
21:16:22 <kazagistar> er, I mean (return .)
21:16:38 <edwardk> kazagistar: i tend to take hlint as a series of eager suggestions by a well meaning undergrad reading over my shoulder.
21:17:00 <levi> I need to do this more often so I can get a better sense of how to plan the right amount of material. :P
21:18:02 <kazagistar> well, I am an undergrad and am trying to to figure out best practices
21:18:07 <edwardk> kazagistar: i assign the suggestions about that level of credibility. every once in a while it catches me out on an obvious mistake but it spends about 90% of its time suggesting illegal eta-reductions and obsessed with style changes that pessimize performance =)
21:18:21 <Heather> edwardk: It will be my haskell "startup" , Control.FsharpDamaged library :D
21:18:32 <Heather> edwardk: good idea ? :S
21:18:59 <edwardk> Heather: you can probably get Jon Harrop to join ;)
21:19:26 <enthropy> has he been active recently?
21:19:35 <lispy> edwardk: are you saying it's a Harropible idea?
21:19:42 <edwardk> enthropy: not terribly
21:20:00 <Heather> oh I read him on twitter :D
21:22:42 <thoughtpolice> edwardk: shockingly, not even *i* can change hackage ACLs!
21:22:50 <thoughtpolice> (well, not legitimately anyway :P)
21:23:04 <edwardk> heh
21:23:31 <edwardk> thoughtpolice: so who officially holds those keys?
21:24:01 <thoughtpolice> Duncan is the key-master, AFAIK. i'm not actually sure if anyone else is an admin-level user on Hackage
21:24:17 <enthropy> ross?
21:24:45 <thoughtpolice> i doubt it. Ross didn't even want to maintain Hackage 1, and didn't really have anything to do with the rollout (we did it at ICFP.)
21:26:09 <kazagistar> omg… does (>>^) work on monads?
21:26:54 <kazagistar> I am trying to find a way to do something like fmap, but infix and backwards, so it does not break my shove chain
21:35:29 <carter> thoughtpolice: and i'm only a trusty
21:35:37 <carter> and probably too spazzy to have the power tools
21:35:49 <carter> *trustee
21:36:01 <Heather> edwardk: wait... there are <| |> which are cons and sons
21:36:08 <Heather> edwardk: what are they are
21:36:52 <dario> @type (<|)
21:36:52 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
21:37:02 <dario> @type (|>)
21:37:02 <lambdabot> Snoc Control.Lens.Internal.Review.Reviewed Identity s s a a => s -> a -> s
21:37:11 <kazagistar> wanna do something like "getLine >>= (+"!!!") >>= print" but of course I cant
21:37:41 <Axman6> getLing >>= print . (++"!!!")
21:38:05 <kazagistar> right, but then the flow seems out of order to me?
21:38:20 <kazagistar> start, then end, then middle
21:38:34 <Axman6> print . (++"!!!") =<< getLine
21:38:56 <kazagistar> hmm, that is a better idea I think
21:39:02 <Heather> > length <| "foo"
21:39:04 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[a0] -> GHC.Types.Int'
21:39:15 <kazagistar> easier to chain more together without getting confused
21:40:03 <frx> > print . (++"!!!") =<< getLine
21:40:04 <lambdabot>  <IO ()>
21:41:09 <ocfx> > nub "potato"
21:41:10 <lambdabot>  "pota"
21:41:13 <ocfx> lol
21:41:20 <ocfx> nub
21:41:34 <syllogismos> :t nub
21:41:35 <lambdabot> Eq a => [a] -> [a]
21:41:41 <syllogismos> @src nub
21:41:41 <lambdabot> nub = nubBy (==)
21:41:44 <Heather> <| is not pipe in lens, right :S
21:42:03 <kazagistar> man, lambdabot cannot even count to potato
21:42:06 <ocfx> ahahha
21:42:25 <verement> @src nubBy
21:42:25 <lambdabot> nubBy eq []             =  []
21:42:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:07:19 <amalloy> i'm looking for a function like Eq a => [a] -> [a] -> Bool, which tells me if the two lists have all the same elements, ignoring order. i don't really care about performance, it's just for small lists in a unit test
22:07:57 <amalloy> i think i could use xs \\ ys == [] && ys \\ xs == 0, but that seems a bit lame
22:08:05 <amalloy> er, not 0, but [], of course
22:08:17 <shachaf> Can't have Ord?
22:08:18 <Axman6> :t delete
22:08:18 <lambdabot> Eq a => a -> [a] -> [a]
22:08:49 <amalloy> uhhhhh, yes, i suppose these types are Ord as well
22:08:56 <shachaf> (compare `on` sort)?
22:09:00 <Axman6> you could use Set then
22:09:06 <ocfx> > delete 'p' "potato"
22:09:07 <lambdabot>  "otato"
22:09:08 <shachaf> Set will discard duplicates.
22:09:17 <Axman6> foo xs ys = fromList xs == fromList ys
22:09:32 <syllogismos> > nub "abcd"
22:09:33 <lambdabot>  "abcd"
22:09:39 <syllogismos> > nub "acbd"
22:09:40 <lambdabot>  "acbd"
22:09:42 <amalloy> yeah, duplicates are important, so set is a no-go
22:09:48 <Axman6> > let foo xs ys = Set.fromList xs == Set.fromList ys in foo "hello" "ellho"
22:09:49 <lambdabot>  Not in scope: `Set.fromList'
22:09:49 <lambdabot>  Perhaps you meant one of these:
22:09:49 <lambdabot>    `Seq.fromList' (imported from Data.Sequence),
22:09:49 <lambdabot>    `S.fromList' (imported from Data.Set),
22:09:49 <lambdabot>    `IM.fromList' (imported from Data.IntMap)Not in scope: `Set.fromList'
22:09:59 <frx> sort xs == sort ys ?
22:09:59 <shachaf> You could find a bag type. Or just use a sorted list, as above.
22:09:59 <Axman6> > let foo xs ys = S.fromList xs == S.fromList ys in foo "hello" "ellho"
22:10:00 <lambdabot>  True
22:10:01 <amalloy> but compare on sort looks good, shachaf
22:10:24 <amalloy> yeah. i didn't actually realize my objects were Ord until you asked. given that they are, sorting is simple enough
22:12:28 <kazagistar> I have been banging my head against ReaderT for the the past few hours to no avail :(
22:13:07 <shachaf> ReaderT is too simple for hours of head-banging. You might be looking for something that isn't there.
22:13:15 <kazagistar> probably
22:13:47 <NemesisD> does anyone use right alt for their xmonad key
22:13:58 <syllogismos> > S.fromList "hello"
22:13:59 <lambdabot>  fromList "ehlo"
22:14:12 <kazagistar> I am looking for a way to do "do notation" with things that return stuff like (Machine -> IO a)
22:14:24 <Heather> edwardk: look: https://github.com/Heather/Control.FSharp \o/
22:14:43 <Hafydd> NemesisD: I tried that, but it results in horrible hand contortions.
22:14:45 <jmob> heather: why does f# imply drain bramage
22:14:49 <Cale> kazagistar: So all your computations are functions of Machine?
22:15:11 <NemesisD> Hafydd: so my problem is that i'm starting to use emacs, and both xmonad and emacs want the left alt
22:15:18 <Axman6> kazagistar: give making a Monad instance a go, like I said, it's very educational. people can help you here
22:15:20 <Hafydd> NemesisD: I use left-Super.
22:15:38 <Hafydd> Well, both Super keys, actually.
22:15:40 <NemesisD> Hafydd: that has its own ergonomic challenges though, your thumb has to fold way under your hand
22:15:44 <Heather> jmob: why don't you like it?
22:15:48 <kazagistar> um no, my computations are functions that return functions of Machine that return IO wrapped things, and I am trying to compose them
22:15:50 <Hafydd> I agree; but I got use to it, somehow.
22:15:52 <NemesisD> for me i have to almost make a fist
22:15:53 <Hafydd> *used
22:15:55 <Heather> edwardk: jmob: usage -> https://github.com/Heather/Sharingan/commit/729e043fecd21bb754deb63c234ddf93a0d2f5a9
22:16:11 <Axman6> newtype Instruction a = Inst (Machine -> IO a); instance Monad Instruction where ...
22:16:39 <jmob> heather: never used it, just wondering the cause of your opinion
22:16:39 <Axman6> return ~:: a -> (Machine -> IO a), that should be easy enough to implement
22:17:08 <Cale> kazagistar: Perhaps you're looking for (>=>)?
22:17:12 <Cale> :t (>=>)
22:17:13 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:17:25 <Cale> or of course, sometimes (<=<) is more convenient
22:17:28 <Cale> :t (<=<)
22:17:29 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
22:17:42 <Cale> compare with:
22:17:44 <Cale> :t (.)
22:17:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:18:08 <kazagistar> no I just…. don't know why my signatures aren't matching?
22:18:20 <Cale> hmm
22:18:22 <Axman6> kazagistar: it would help if you shared some actual code
22:18:42 <Cale> kazagistar: Do you have working code which you'd like to make cleaner? We could also look at your broken code I suppose :)
22:18:59 <kazagistar> Axman6: sure, I can share both my old version and my rewrite which also does not work at all lol
22:19:52 <f-a> hello people, can somebody take a look at this compile error? http://pastebin.com/DpbagpDt I tried solving it but have no idea. (library bindings problems)
22:19:56 <kazagistar> the old code I had some handle on what I was doing at least
22:20:09 <Cale> kazagistar: Probably the best way to fix repetition you find in your code, is just to define the part that's being repeated as a function, and then use that function, and then figure out if that function already has a name somewhere.
22:21:51 <f-a> (disregard my message, found the error)
22:23:39 <Heather> how can I upload my two operators to hackage?
22:24:27 <f-a> do you have a cabla package for them, Heather ?
22:24:27 <amalloy> is the syntax for letting a function inside of a do-block anything weird? i expected http://lpaste.net/99796 to work, but line 3 makes ghc say "parse error (possibly incorrect indentation or mismatched brackets)"
22:24:50 <f-a> else grabs the next line too
22:24:55 <kazagistar> Cale, Axeman6: http://lpaste.net/99797
22:24:55 <Heather> unrecognised command: package (try --help)
22:24:59 <f-a> no indentation magic for it, amalloy
22:25:36 <Cale> kazagistar: This is the broken code?
22:25:38 <f-a> Heather: not a command, http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
22:25:52 <shachaf> amalloy: Try indenting the "if" past the "f"
22:26:24 <kazagistar> Cale: no the working code, it compiles. However, I want to do make Instruction a monad so I can define instructions with do notation
22:26:51 <Cale> Okay, well, Instruction is already a monad, but perhaps not in the sense that you'd like it to be.
22:27:26 <amalloy> aha! that makes it work, shachaf. is that required in ordinary (ie, not inside a do) function-letting as well? i
22:27:37 <Cale> Why don't you use do-notation?
22:27:46 <Cale> and lambda instead of flip?
22:28:14 <Cale> also, you have a bind to pure . (+o) here...
22:28:22 <Cale> which could probably be replaced with a let
22:28:33 <Heather> f-a: you mean cabal file?
22:28:54 <kazagistar> Cale: yeah, in my rework that does not work at all I was trying to switch to do notation, and it was much nicer indeed
22:29:22 <f-a> Heather: if you want to upload to hackage, you create a tarball using cabal and then upload it to hackage
22:30:36 <Heather> f-a: I need account :S mailed admin@hackage
22:31:05 <Cale> kazagistar: See my annotation
22:31:23 <f-a> http://hackage.haskell.org/users/register-request Heather ?
22:31:26 <Cale> kazagistar: I don't know about you, but I think that's more readable, personally ;)
22:31:44 <Heather> f-a: yes, so far nothing recieved
22:32:04 <f-a> I don't recall whether there is a bot or a real person
22:32:26 <kazagistar> Cale: I agree, but what do you mean "Instruction is already a monad"? I want to be able to compose functions that look like (a -> Instruction b), (b -> Instruction c) into (a -> Instruction c)
22:33:05 <Cale> Oh, I suppose it's not really. (->) Machine is a monad.
22:33:25 <Cale> We could use  ReaderT Machine IO
22:33:51 <kazagistar> which is what I was trying to do and failing to understand what changes would be needed to my code
22:33:58 <Cale> okay
22:34:40 * hackagebot distributed-process-p2p 0.1.2.2 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.2.2 (AlexanderBondarenko)
22:35:14 <kazagistar> I mean, I can just swap out for "type Instruction a = ReaderT Machine IO a" but that just breaks everything…
22:36:19 <Cale> Yeah, let's not do that, let's do it the right way with a newtype if we're going to be using a monad transformer
22:39:46 <f-a> where does cabal look for 'external' libraries? $PATH?
22:44:04 <BlankVerse_> which haskell values lie in heap vs stack?
22:44:41 * hackagebot snake-game 1.0 - Snake Game Using OpenGL  http://hackage.haskell.org/package/snake-game-1.0 (AkashJagdhane)
22:45:26 <kazagistar> Cale: I am looking up newtypes and I am not understanding, sorry :(
22:45:42 <Cale> kazagistar: One sec, making a paste for you
22:45:46 <kazagistar> ok
22:50:00 <Cale> kazagistar: http://lpaste.net/99798
22:50:56 <Cale> kazagistar: So initially, this makes more of a mess, but the idea is that eventually we'll have enough things like load and save built up that we won't have to use primIO or primAsks any longer.
22:51:40 <Cale> kazagistar: If you think that's tedious, and don't care about keeping these Instruction computations abstract, we could take this in another direction.
22:52:25 <Cale> (derive MonadReader Machine and give primIO a nicer name)
22:52:43 <Cale> (and then asks would be usable directly)
22:55:00 <kazagistar> … huh, deriving (Functor, Applicative, Monad), I see
22:55:10 <Cale> Yeah, that's NewtypeDeriving
22:56:03 <Cale> It's an extension you'll have to turn on with {-# LANGUAGE GeneralizedNewtypeDeriving #-}
22:56:52 <Cale> oops, I left the old Instruction in there
22:57:05 <Cale> (removed it, refresh if you care :)
22:57:44 <Cale> oh, there's another mistake I just spotted as well
22:57:46 <kazagistar> ok, that makes sense, I was getting a confusing idea of what newtype might do
22:58:16 <Cale> there, fixed another one
22:58:30 <kazagistar> I'm not sure I care about the abstraction so much
22:59:14 <Cale> So, if you wanted to do away with the abstraction, you could add  MonadReader Machine  and  MonadIO  to the list of derived classes
22:59:30 <Cale> and then use asks in place of primAsks and liftIO in place of primIO
22:59:31 <kazagistar> I see
22:59:43 * hackagebot snake-game 1.1 - Snake Game Using OpenGL  http://hackage.haskell.org/package/snake-game-1.1 (AkashJagdhane)
23:00:09 <Cale> I'm not sure this is all worthwhile, myself :)
23:00:18 <Cale> But it's certainly something you can do to your code
23:00:34 <kazagistar> the full program is only going to be like 4 times this long, ever… having to use a extention is a little scary too?
23:00:53 <Cale> oh, you can avoid the extension
23:01:10 <Cale> But then you'd need to write some trivial instances of those classes
23:01:44 <kazagistar> right… I am thinking that Axman6's advice about implementing it myself might not be totally off
23:02:12 <Cale> It'll all come out quite similar with respect to how load and save will look in the end
23:03:07 <Cale> Personally, I don't tend to think that being able to get rid of the extra explicit function parameter is worth all the extra lifting of IO actions.
23:03:14 <verroq> Finally finished my pool server in Haskell
23:03:27 <dpwright> is there a typeclass which will give me a function that will always give me some sort of float/real/rational value, if I pass it any Num?
23:03:28 <verroq> github.com/dogestreet/proxypool
23:03:52 <Cale> But that's just me, and there are cases where this sort of thing is a useful thing to do, especially if you want to carefully control how much IO can be done by computations in your monad.
23:04:44 * hackagebot snake-game 1.2 - Snake Game Using OpenGL  http://hackage.haskell.org/package/snake-game-1.2 (AkashJagdhane)
23:04:48 <Axman6> I thought the idea was to have a nice clean DSL for an assembly language
23:04:49 <kazagistar> I am also reconsidering using records already, since they are eating hard into namespaces… it might be nicer to have memory' = liftIO memory or something, to remove the verbosity
23:04:54 <Axman6> and the monad instance would give that
23:04:58 <Cale> dpwright: no
23:05:07 <Cale> dpwright: Num is too weak for that
23:05:09 <dpwright> I have a function which may take either Int or Float or Double, for which I've given the constraint Num a, and I want to do some floating point / fractional division stuff with it, and then floor it and return it as an Int in the end
23:05:20 <Cale> dpwright: You could have instances of Num like square 5x5 matrices
23:05:32 <dpwright> Cale: is there a better typeclass I could use?
23:05:36 <dpwright> Real?
23:05:39 <Cale> dpwright: Depends on what you want to get
23:05:39 <kazagistar> :t /
23:05:40 <lambdabot> parse error on input `/'
23:05:46 <kazagistar> :t (/)
23:05:46 <Cale> :t fromIntegral
23:05:47 <lambdabot> Fractional a => a -> a -> a
23:05:47 <lambdabot> (Integral a, Num b) => a -> b
23:05:49 <Cale> :t fromIntegral
23:05:50 <lambdabot> (Integral a, Num b) => a -> b
23:05:57 <Cale> :t realToFrac
23:05:57 <lambdabot> (Fractional b, Real a) => a -> b
23:06:20 <Cale> ^^ usually it's either fromIntegral or realToFrac that you want
23:06:37 <dpwright> I'm not set on Num, but I know my inputs are either Int, Float, or Double, that most of the operations I want to perfom are not with Integral numbers, and that I eventually want to output an Integral using floor
23:06:55 <Cale> There are also things like floor/round/ceiling and truncate
23:08:48 <Cale> You could use realToFrac
23:09:38 <Cale> Though I usually wouldn't intentionally write stuff which would happily accept either Int or Double
23:09:57 <Cale> Those are two very different datatypes as far as I'm concerned.
23:10:22 <Cale> Well, stuff that'll work with an arbitrary instance of Num is fine
23:10:49 <dpwright> Cale: yeah... maybe you're right.
23:10:52 <Cale> But it seems a bit weird to start your computation off by applying realToFrac and converting everything to Double, say.
23:11:22 <Cale> If you're going to do that, better just to inform your users that you'd like it done, and only accept Doubles
23:12:43 <dpwright> yeah... ok, thanks, will take another look at my interface
23:15:46 <OceanSpray> so ghc ran out of memory
23:15:57 <OceanSpray> this computer has 512MB
23:16:01 <OceanSpray> should this be happening
23:16:09 <Cale> Maybe?
23:16:18 <Cale> It depends on what you asked it to do
23:16:21 <OceanSpray> I'm just trying to install text-1.1.0.0
23:16:36 <OceanSpray> ghc: out of memory (requested 2097152 bytes)
23:16:36 <OceanSpray> Failed to install text-1.1.0.0
23:16:50 <Cale> okay, then you ran out of memory
23:17:04 <OceanSpray> time to go to the hardware store
23:17:39 <Cale> Let me see how much it uses on my machine
23:17:58 <Cale> ~336 MB peak so far
23:18:09 <Cale> 360
23:18:26 <OceanSpray> yeah meminfo says I have only 112MB free
23:19:09 <Cale> My damn window manager is using 479 MiB :)
23:19:22 <OceanSpray> xmonad?
23:19:28 <Cale> no, cinnamon
23:19:39 <OceanSpray> I don't even have a WM running
23:19:40 <Cale> (I guess it's a bit more than a WM)
23:19:44 <OceanSpray> this is happening over ssh
23:19:45 * hackagebot aws-sdk-xml-unordered 0.3 - The xml parser for aws-sdk package  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.3 (ShoheiYasutake)
23:20:10 <Cale> This machine has 16GB in it though, so I basically don't care about anything's memory usage anymore.
23:21:00 <dmj`> I'm trying to make a SafeCopy instance for a linear hashtable from the hashtables pkg
23:21:13 <dmj`> ghc keeps telling me I'm using an illegel type synonym
23:21:28 <dmj`> http://lpaste.net/99803
23:21:39 <dmj`> I keep trying to drill down to find the core type, but to no avail
23:22:32 <dmj`> any ideas?
23:22:56 <Cale> http://hackage.haskell.org/package/hashtables-1.1.2.1/docs/src/Data-HashTable-IO.html#BasicHashTable
23:23:07 <Cale> So, unfolding this...
23:23:26 <f-a> cabal install package --extra-lib-dirs=/home/user/media/vcs/zeromq-3.2.4/src/.libs <-- there is a lib.o there and cabal seems not able to find it. What could be the problem?
23:23:33 <Cale> L.HashTable (PrimState IO) k v
23:23:45 <Cale> (import qualified Data.HashTable.ST.Linear as L)
23:27:15 <Cale> f-a: I'm not entirely sure what type of file it's looking for, but on my machine, I have libzmq.{a,la,so,so.3,so.3.1.0}
23:27:42 <Cale> What error are you getting?
23:27:59 <dmj`> instance (SafeCopy k, Eq k, SafeCopy v, Hashable k) => SafeCopy (L.HashTable (PrimState IO) k v) where
23:28:05 <dmj`>     Illegal type synonym family application in instance:
23:28:05 <dmj`>       L.HashTable (PrimState IO) k v
23:28:05 <dmj`>     In the instance declaration for `SafeCopy (L.HashTable (PrimState IO) k v)'
23:28:05 <dmj`> Failed, modules loaded: none.
23:28:05 <dmj`>  
23:28:10 <Cale> oh, haha
23:28:29 <Hafydd> libzmq.{do,re,mi,fa,sol,la,si}
23:28:38 <c_wraith> isn't PrimState a type family?
23:28:50 <Cale> ah, yes it is
23:28:56 <c_wraith> PrimState IO = Realworld, or something
23:29:06 <dmj`> class Monad m => PrimMonad m where
23:29:06 <dmj`>   type family PrimState m1 :: *
23:29:06 <dmj`>  
23:29:34 <dmj`> do I need to use GHC.Prim?
23:29:46 * hackagebot egison 3.2.16 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.16 (SatoshiEgi)
23:33:23 <Cale> dmj`: What happens if you turn on FlexibleInstances?
23:33:30 <Cale> (or is it already on?)
23:34:12 <dmj`> Cale: it's already on
23:34:37 <xintron> Morning
23:35:04 <xintron> For a socket handle, is it safe to read/write from two threads simultaneously (with line-buffering)?
23:35:19 <lcfrs> I have a Free Monad question if anyone's listening
23:35:22 <Cale> Depends on what you mean by "safe".
23:35:30 <f-a> it is looking for .so Cale
23:35:45 <dmj`> http://lpaste.net/99804
23:35:46 <f-a> and apparently cabal doesn't look into the directory I am pointing it to
23:35:55 <xintron> Cale, Safe as in reading/writing will work ;)
23:36:11 <Cale> xintron: It'll work, but you'll get an interleaved mess when you write
23:36:19 <Cale> Writes aren't atomic
23:37:22 <lcfrs> > data Q a r = Q a r deriving Functor
23:37:23 <lambdabot>  <hint>:1:1: parse error on input `data'
23:37:33 <lcfrs> hmmm... I guess that doesn't work
23:38:06 <lcfrs> Anyway, q = Q 1 (Q 'a' ())
23:38:22 <xintron> Cale, But implementing a locking solution would be a mess as well, setting timeouts on reads etc
23:38:41 <lcfrs> I can construct a Q with different types embedded
23:39:03 <Cale> xintron: The usual solution is to create a Chan and forkIO a thread which does nothing except read complete Strings from the Chan and write them to the Handle
23:39:18 <lcfrs> but how do I involve the Free monad? for e.g.: qq = liftF (Q 1 ()) >> liftF (Q 2 ())
23:39:47 <xintron> Cale, so one thread doing all the reading/writing
23:39:48 <Cale> lcfrs: I'm not sure what you mean here
23:40:06 <Cale> lcfrs: What's the type of Q 1 (Q 'a' ()) ?
23:40:07 <lcfrs> So then qq :: Free (Q Int) ()
23:40:24 <Cale> Q Int (Q Char ()) ?
23:40:29 <lcfrs> yes
23:40:30 <Cale> so you're just talking about pairs?
23:40:54 <Cale> Pairs aren't a free monad.
23:40:58 <lcfrs> I'm not sure if I am, I see how they can be
23:41:17 <lcfrs> I see
23:41:40 <Cale> (they're not even a monad, unless you have a Monoid instance for the first component)
23:42:04 <lcfrs> ok
23:42:27 <lcfrs> I guess I need to hit the books again
23:42:41 <Cale> lcfrs: What are you trying to do?
23:43:07 <Cale> The fact that something is or isn't a monad isn't usually a terribly big deal
23:43:28 <lcfrs> OK, I'll try to explain
23:45:29 <lcfrs> Let's say I have functions a2b :: A -> B and b2c :: B -> C. and, I can compose them into A -> C, but I want to do so in a way where I can substitute B->C with another B->D perhaps, and also print out the structure of the composition
23:45:30 <shachaf> Well, ([a],) ~~ Free (a,)
23:46:11 <Cale> lcfrs: Well, you're not going to have much luck with printing functions
23:46:42 <Cale> lcfrs: But you can at least keep pairs of functions, or even composable chains of them, using a GADT
23:46:53 <lcfrs> Cale: right but I mean let's say I had a data F a b = F String (a -> b) where I could give the function an associated name
23:47:22 <lcfrs> and instance Show F where show (F name _) = name
23:47:45 <lcfrs> hi shachaf: what does ~~ denote?
23:48:27 <lcfrs> Cale: do edwardk's PHOASs have any relevance?
23:48:31 <Cale> data Chain :: (* -> * -> *) -> * -> * -> * where Nil :: Chain f i i; Cons :: f i j -> Chain j k -> Chain i k
23:48:36 <Cale> oops
23:48:41 <Cale> data Chain :: (* -> * -> *) -> * -> * -> * where Nil :: Chain f i i; Cons :: f i j -> Chain f j k -> Chain f i k
23:49:25 <shachaf> lcfrs: "isomorphic", in this case.
23:50:15 <lcfrs> shachaf: interesting, though I'm not sure how to use that
23:50:27 <Cale> lcfrs: Does this GADT look like what you want?
23:51:20 <lcfrs> Cale: I think so...
23:51:21 <Cale> The idea is that Chain (->) a b will consist of composable sequences of functions from a to b
23:51:36 <lcfrs> is f = (->)?
23:51:43 <Cale> When f = (->)
23:51:45 <lcfrs> Oh right, I see you answered
23:51:54 <Cale> But you could replace f with some other data type if you like
23:52:30 <lcfrs> but doesn't Q a r also give me that?
23:52:50 <Cale> Q a r is just (a,r), the way you defined it
23:53:03 <lcfrs> I see I see, it doesn't know anything about its neighbors
23:53:07 <lcfrs> or whatever the term is
23:53:44 <lcfrs> I'll have to play around with Chain
