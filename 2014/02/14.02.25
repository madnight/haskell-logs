00:08:47 * hackagebot cabal-bounds 0.1.8 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.8 (DanielTrstenjak)
00:08:47 * hackagebot cabal-bounds 0.1.9 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.9 (DanielTrstenjak)
00:16:10 <Yuu-chan_> What's the best introduction to FRP?
00:41:42 <bezirg> hey guys, is this function I wrote tail-recursive? http://lpaste.net/100373
00:43:33 <supki> bezirg: if you desugar do-notation it should be clear
00:43:37 <supki> it's not a function though
00:43:51 <supki> functions take arguments
00:44:11 <bezirg> supki: y I left that out to make it easier
00:44:35 <bezirg> supki: there are arguments both to spawn and loop
00:45:08 <bezirg> supki: y u r right if I desugar it, it will be more clear
00:45:36 <ion> *twitch*
00:47:01 <c_wraith> bezirg: that function isn't syntactically tail-recursive.   On the other hand, IO's implementation is very careful to make recursive calls in the final position of a chain of binds into tail calls
00:47:50 <bezirg> c_wraith: y it is not syntactically tail-recursive. but I was worried if this thread will leak stack if it is not-tail recursive
00:48:32 <c_wraith> bezirg: syntactically, tail-recursion means that a function reduces to a call to itself.  That function reduces to a call to (>>=) or (>>)
00:48:56 <johnw> is y short for yes?
00:49:06 <bezirg> johnw: y :D
00:49:10 <bezirg> johnw: yes
00:49:16 <johnw> ok :)
00:49:59 <bezirg> c_wraith: so should I be fine you think with it?
00:51:05 <c_wraith> bezirg: it won't allocate space for extra calls to loop.  However, if the argument to loop builds up a big thunk, that becomes a problem instead
00:52:12 <bezirg> c_wraith: good to know that. Is there a countermeasure? Should I force the arguments to loop?
00:53:12 <c_wraith> bezirg: Well, make sure that they're evaluated in one way or another.  If that case matches one of the args, it'll take care of forcing it, for instance
00:55:11 <bezirg> c_wraith: the args to loop are strict Maps to hold some info (example lookup registeredUsersMap registeredAdminsMap)
00:57:26 <c_wraith> bezirg: maps get complicated.  You have 3 things to consider.
00:58:00 <c_wraith> bezirg: first, the map thunk overall.  It could represent a big chain of function calls to build up the map.  If you make sure it's forced, you escape that.
00:58:03 <akurilin2> Super newbie question: which packages would you recommend for simple type-safe interaction with a Postgres db? No SQL dsl for now, for simplicity sake. There's persistent and hdbc from what I understand. Am I missing one?
00:58:24 <johnw> persistent
00:58:29 <johnw> it's very easy to use
00:58:37 <johnw> when your needs grow, you can upgrade to esqueleto pretty painlessly
00:59:06 <c_wraith> bezirg: Second, the keys are evaluated insofar as necessary to build the search tree. That *could* be a problem, if the keys are long strings that are distinguished by the first couple characters.
00:59:08 <akurilin2> johnw: ok sounds good.
01:00:35 <c_wraith> bezirg: third, the values in the map.  the .Strict interface to Data.Map ensures that values are put in WHNF by the evaluation of the insertion function. But once again, if the value is some non-strict data type, that'll only force the top level data constructor.
01:01:43 <c_wraith> ..  I suppose that understanding laziness really does require being detail-oriented.
01:02:28 <bezirg> c_wraith: thanks for these in-depth comments! I will stick to as it is for now, and if laziness becomes a bottleneck, then I will try to force stuff
01:11:12 <pavonia> This is a function for calculating the moving average of a list of sample values, i.e. the average of the last n values in chronological order at a given time point (the key of the Map). Any ideas how to make it more readable, especially the f part? http://lpaste.net/100374
01:23:24 <bartavelle> pavonia, that might be a stupid question, but did you really need a Map in the first place ?
01:25:09 <bartavelle> (also I don't think you need to mapAccumWithKey, toDescList gives you the elements in descending order)
01:25:40 <pavonia> Well, I need quick access for a value at a given time point
01:26:13 <bartavelle> ok I can't read code
01:26:22 <pavonia> so the implementation was easier with a Map than with a vector
01:26:32 <bartavelle> disregard my parenthesized comment
01:27:08 <bunzen> -win 16
01:27:16 <bunzen> sorry
01:29:31 <bartavelle> pavonia, this is minor, but you might use mapAccum instead of mapAccumWithKey, as you don't use the key
01:30:48 <pavonia> yup, the mp can be eta-reduced too :)
01:32:50 <pavonia> But I was also wondering if I even need to store the last n values in a list over and over again. I don't really care about speed here but maybe there's a simpler way to do that
01:34:37 <bartavelle> well, your "xs' = x : xs" does reverse
01:34:58 <bartavelle> if there was something with "([a] -> b) -> [a] -> [b]" you could probably write it simply
01:35:12 <bartavelle> hmm
01:41:38 <bartavelle> pavonia, I don't think my solution looks better :) http://lpaste.net/996827008497352704
01:43:54 <pavonia> Hhm, the idea to process it backwards might reduce the need to store the counter value
01:47:21 <pavonia> bartavelle: Ah well, I have to go. Thanks for your input! I'll look at it again later
01:54:00 * hackagebot uni-util 2.3.0.1 - Utilities for the uniform workbench  http://hackage.haskell.org/package/uni-util-2.3.0.1 (ChristianMaeder)
01:56:38 <czro_> Im fiddling with monad transformers where I have a ReaderT with some configuration data on top of IO. I tried to change to ST instead of IO but things seem a lot more complicated. Is ST generally a bad idea in this context?
01:57:26 <czro_> I need to generate random numbers to do some calculations on a datastructure.
02:00:31 <jle`> just caught myself typing return $ x + y in C++
02:00:31 <jle`> heh
02:00:31 <jle`> czro_: i think in general if you can use ST, it is preferred over IO
02:02:58 <Yuu-chan_> czro_: I found myself to like to get a generator in IO, generate an infinite list of random values, and pass it into a pure function which needs them
02:04:03 <czro_> Yuu-chan_: I'll try that. Not used to think in terms of infinite stuff :) Thanks.
02:07:06 <Yuu-chan_> czro_: btw, why did you consider ST complicated?
02:11:27 <Yuu-chan_> For me it was kind of "fat free" IO with only mutable memory stuff (STRef ~ IORef, STArray ~ IOArray and so on), laced with magically typed runST :)
02:15:00 <quicksilver> there isn't normally much reason to use STRefs in a monad transformer stack compared to just using State
02:15:10 <quicksilver> the reason to use ST is normally the performance of STArrays
02:15:38 <quicksilver> occasionally the ability of STRefs to create new references of arbitrary types is useful.
02:17:02 <czro_> I want to keep as much as possible pure so the possibility of escaping from ST is a nice feature. The problem I've had is the threading of the "s" parameter. Guess I'm structuring my code wrong. I think I can get the ST stuff to be more local to avoid having to thread around the s.
02:18:07 <merijn> czro_: Well, the "threading around the 's'" is exactly what lets GHC enforce that what you're doing is "safe" and the reason why you can escape from ST
02:18:37 <merijn> czro_: Without seeing the code it's hard to say whether the threading 's' around issue is a problem from code structure or just because what you want isn't really pure
02:19:35 <merijn> czro_: Completely different approach: Would it work to just put your configuration in StateT?
02:21:17 <czro_> I think the infinite list thing is an approach that will work good.
02:21:24 <czro_> brb
02:22:34 <czro_> I'll have to continue this later. Thanks for the advice.
02:29:51 <xrz> Can anyone please help - I need to define Test.QuickCheck.Arbitrary instance for type, which looks like  data D = A | B | C
02:30:48 <ion> See arbitraryBoundedEnum
02:32:00 <ion> As for shrink, shrink A = []; shrink _ = [A] for instance.
02:32:24 <Iceland_jack>  xrz: oneOf
02:32:24 <Iceland_jack> or sorry, elements
02:32:57 <ion> Or perhaps shrink A = []; shrink B = [A]; shrink C = [B]
02:33:17 <Iceland_jack> xrz: You can either do
02:33:17 <Iceland_jack>     elements [A, B, C] :: Gen D
02:33:26 <Iceland_jack> or you can do what ion suggested an make an Enum instance for D
02:34:15 <Iceland_jack>     ghci> data D = A | B | C deriving Show
02:34:15 <Iceland_jack>     ghci> sample' (elements [A, B, C])
02:34:15 <Iceland_jack>     [C,C,B,C,C,C,B,A,A,B,C]
02:35:18 <Iceland_jack> You can then define an arbitrary instance
02:35:18 <Iceland_jack>     instance Arbitrary D where
02:35:18 <Iceland_jack>         arbitrary = elements [A, B, C]
02:35:18 <Iceland_jack> 	shrink    = {- what ion said -}
02:37:09 <ion> If you have an Enum instance, this would work as well. shrink A = []; shrink x = [pred x]
02:37:12 <xrz> Iceland_jack: Um, that is approximately what I ended with. Do you know if there is any possibility to not list constructors explicitly?
02:37:22 <ion> xrz: See arbitraryBoundedEnum
02:37:23 <Iceland_jack> xrz: What do you mean?
02:37:38 <Iceland_jack> You can do what ion just suggested if you're okay with an Enum instance
02:39:31 <xrz> Iceland_jack: Ok, I did not understand it yet, will try first. As for my previous question, I am reluctant to list all constructors more than once. Just need them to be used randomly in my tests.
02:39:53 <Iceland_jack> xrz: Do you know how Enum works?
02:39:57 <xrz> ion: Thanks, will definitely try that
02:41:05 <Iceland_jack> @let data D = A | B | C deriving (Enum, Show)
02:41:06 <lambdabot>  Defined.
02:41:08 <xrz> Iceland_jack: Yes, I do
02:41:08 <Iceland_jack> > [A .. C]
02:41:10 <lambdabot>  [A,B,C]
02:41:33 <Iceland_jack> then you can define arbitrary as
02:41:33 <Iceland_jack>     instance Arbitrary D where
02:41:33 <Iceland_jack>         arbitrary = arbitraryBoundedEnum
02:41:40 <ion> shrinkBoundedEnum x | x == minBound = [] | otherwise = [pred x]
02:41:40 <mindleyhilner> wha the hell
02:41:42 <mindleyhilner> :t A
02:41:43 <lambdabot> D
02:41:50 <mindleyhilner> @src D
02:41:50 <lambdabot> Source not found. Just try something else.
02:41:56 <mindleyhilner> @hoogle D
02:41:57 <lambdabot> Prelude data Double :: *
02:41:57 <lambdabot> GHC.Exts data Double :: *
02:41:57 <lambdabot> Data.Char DashPunctuation :: GeneralCategory
02:42:01 <Iceland_jack> mindleyhilner: I just defined D some lines back
02:42:05 <Iceland_jack> @undef
02:42:05 <lambdabot> Undefined.
02:42:05 <Iceland_jack> @let data D = A | B | C deriving (Enum, Show)
02:42:06 <lambdabot>  Defined.
02:42:22 <mindleyhilner> whoa, that's possible. didn't see that.
02:42:34 <Iceland_jack> :) anything is possible if you set your mind to it
02:42:49 <c_wraith> ...  Though to be fair, that wasn't possible in \bot 2 years ago.
02:42:58 <c_wraith> Then someone put their mind to it.
02:43:03 <mindleyhilner> i argue that D is isomorphic to Either () Bool
02:43:21 <Iceland_jack> mindleyhilner: Sure :)
02:43:22 <c_wraith> mindleyhilner: that's true if you ignore bottoms
02:43:35 <c_wraith> Either () Bool has room for 2 more bottoms, though.
02:43:42 <ion> i argue that Either () Bool is less useful
02:43:55 <magicman> Maybe (Maybe (Maybe Void))
02:44:09 <magicman> (modulo bottoms, of course <_< >_>)
02:49:28 <mindleyhilner> :k Void
02:49:29 <lambdabot> Not in scope: type constructor or class `Void'
02:50:10 <Iceland_jack>     newtype Void = Void Void
02:50:10 <Iceland_jack> :)
02:51:18 <mr-> :t fix Void
02:51:19 <lambdabot> Void
02:51:22 <mr-> :-)
02:51:55 <Iceland_jack> gosh :)
02:52:19 <Iceland_jack> mindleyhilner: http://hackage.haskell.org/package/void-0.5.1/docs/Data-Void.html
02:52:27 <magicman> A type with no non-bottom values.
02:53:15 <Iceland_jack>     Void has no values
02:53:15 <Iceland_jack>     () has one value
02:53:15 <Iceland_jack>     Bool as two values
02:53:15 <Iceland_jack> modulo bottom
02:53:15 <magicman> I love that it depends on semigroups XD
02:53:42 <Iceland_jack> Yeah where would we be without Void as a semigroup
02:57:03 <hc> moin
02:57:07 <hc> i've written a small function:
02:57:09 <hc> allfail = (== 0) . Prelude.length . Prelude.filter (/= Nothing)
02:57:26 <hc> i want to pass a list such as [Just "foo", Just 123, Nothing] and it returns if all elements are Nothing
02:57:43 <hc> any simple way to get the list to accept different a for Maybe a?
02:57:58 <opqdonut> well, there is, but you probably don't want to do that
02:58:07 <bennofs> How can I allocate a new Ptr of some foreign type? For example, I want to allocate a Ptr () with enough memory to hold a value of the C-type sem_t
02:58:29 <Iceland_jack> hc: all isNothing ?
02:58:35 <merijn> bennofs: There's allocation primitives for that in the FFI libraries
02:58:41 <Iceland_jack> > all isNothing [Nothing, Nothing, Nothing]
02:58:42 <lambdabot>  True
02:58:44 <merijn> bennofs: Probably Foreign.Pointer or something
02:58:45 <Iceland_jack> > all isNothing [Nothing, Just 'a', Nothing, Nothing]
02:58:46 <lambdabot>  False
02:58:48 <opqdonut> > let allfail :: [forall a. Maybe a]; allfail = (== 0) . Prelude.length . Prelude.filter (/= Nothing) in allfail [Just 123, Just "asd"]
02:58:49 <lambdabot>  Illegal polymorphic or qualified type: forall a. Data.Maybe.Maybe a
02:58:49 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
02:58:51 <bennofs> merijn: I know, my question then turn into "how do I get the size of sem_t?"
02:58:58 <opqdonut> right, you need an extension
02:59:23 <ion> hc: You don’t want to compute the length and then compare to 0. You’ll want to use pattern matching instead.
02:59:27 <opqdonut> hc: I suggest looking for another solution, heterogenous lists are certainly possible in haskell, but often not worth the bother
02:59:46 <hc> opqdonut: i though of using forall. and declaring a new datatype, but it's not worth the hassle
02:59:59 <bernalex> lambdabot: who is your creator?
03:00:10 <bernalex> bad ai =(
03:00:24 <merijn> bennofs: You have two options: 1) implement a C wrapper that returns it or 2) implement a Storable instance for sem_t
03:00:32 <hc> what i'm actually doing is write a parser with attoparsec and i have six subparsers. each returns Maybe a of a different a. if all 6 subparsers fail, the parser should fail, else return whatever the succeeding subparsers returned
03:00:37 <merijn> bennofs: The former is probably simplest
03:00:57 <hc> opqdonut: i'll try your list syntax, though
03:01:01 <opqdonut> hc: that sounds like a use case for the maybe monad
03:01:04 <bennofs> merijn: even for the Storable instance, I will still have to obtain the size, right?
03:01:08 <merijn> hc: Won't work
03:01:18 <merijn> bennofs: Storable class includes a sizeOf function :)
03:01:39 <merijn> bennofs: "sizeOf :: Storable a => a -> Int"
03:01:42 <bennofs> merijn: yeah, but if I want to write it, I still need the size
03:02:10 <merijn> bennofs: Right, which usually involves writing hsc macros to figure out the size
03:02:17 <bennofs> merijn: how does that work?
03:02:36 <merijn> bennofs: So probably defining a C file with "int size = (sizeof sem_t);" and then using that is faster :p
03:02:49 <hc> opqdonut: a maybe monad inside the attoparsec monad?
03:07:48 <bennofs> merijn: I think I can use #const sizeof(sem_t)
03:09:14 <hc> opqdonut: here's the code extract that i'm talking about: http://lpaste.net/100375
03:09:30 <hc> opqdonut: any hints on simplyfying this are appreciated!
03:12:02 <hc> wxParser is part of a larger parser; it is a requirement that wxParser fails if it cannot parse any input
03:14:11 * hackagebot cabal-bounds 0.1.10 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.10 (DanielTrstenjak)
03:14:29 <opqdonut> hc: use something like Phenomenon intensity <$> desc <*> prec <*> obfs <*> othr
03:14:34 <opqdonut> hc: to get a Maybe Phenomenon
03:14:46 <opqdonut> hc: using Maybe-values for the fields
03:15:48 <opqdonut> > let f a b c = show a ++ show b ++ show c in f <$> Just 1 <*> Just "abc" <*> Just []
03:15:49 <lambdabot>  Just "1\"abc\"[]"
03:15:59 <opqdonut> > let f a b c = show a ++ show b ++ show c in f <$> Just 1 <*> Nothing <*> Just []
03:16:00 <lambdabot>  Nothing
03:16:04 <mr-> hpc: how does that not complain about types when you do [desc, prec,..] ?
03:16:05 <opqdonut> see?
03:16:18 <opqdonut> mr-: it does, and that's kinda the problem
03:17:24 <hc> opqdonut: would that mean i get Nothing whenever one of the subparsers fail?
03:17:29 <opqdonut> hc: yes
03:17:39 <hc> opqdonut: i need the opposite behaviour -- it must only fail if all subparsers fail
03:17:44 <opqdonut> hc: ah, right
03:17:52 <Iceland_jack> hc: You may want MonadPlus
03:18:18 <Iceland_jack> > msum [Nothing, Nothing, Just 5, Nothing]
03:18:19 <lambdabot>  Just 5
03:18:20 <Iceland_jack> > msum [Nothing, Nothing, Nothing]
03:18:21 <lambdabot>  Nothing
03:18:37 <opqdonut> monadplus probably would only make the code more complicated
03:19:07 <opqdonut> hc: okay, how about just writing: when (all [isNothing desc, isNothing prec, isNothing obfs, isNothing othr]) ...
03:19:18 <Iceland_jack> opqdonut: You mean "and"?
03:19:35 <opqdonut> I mean and, yes
03:19:37 <opqdonut> :t and
03:19:38 <lambdabot> [Bool] -> Bool
03:19:40 <hc> opqdonut: sounds like a practical solution
03:19:53 <opqdonut> hc: yeah, you can figure out a fancy one afterwards if you wish :)
03:20:06 <hc> okay, i'll do that
03:20:19 <hc> thanks
03:29:11 <bahamas> hello. why does 2 ^ 1/2 work, but 2 ^ 0.5 doesn't? testing their type, ghci tells me that they have the same type, so what's the difference?
03:29:15 <bahamas> :t 1/2
03:29:16 <lambdabot> Fractional a => a
03:29:21 <bahamas> :t 0.5
03:29:22 <lambdabot> Fractional a => a
03:30:15 <ClaudiusMaximus> bahamas: 2^1/2 = (2^1)/2
03:31:32 <bahamas> ClaudiusMaximus: oh, it's the precedence of the operator
03:31:41 <bahamas> ClaudiusMaximus: thanks
03:31:55 <ClaudiusMaximus> bahamas: you probably want (**)
03:33:17 <bahamas> ClaudiusMaximus: ah, so there's an operator for Integral and one for Floating exponents
03:34:23 <Cale> yeah
03:34:26 <Cale> :t (^)
03:34:27 <lambdabot> (Integral b, Num a) => a -> b -> a
03:34:30 <Cale> :t (^^)
03:34:31 <lambdabot> (Fractional a, Integral b) => a -> b -> a
03:34:34 <Cale> :t (**)
03:34:35 <lambdabot> Floating a => a -> a -> a
03:42:03 <makalu> if I install packages in a cabal sandobx, what should I use instead of runhaskell?
03:46:18 <ion> > x^9
03:46:19 <lambdabot>  x * x * (x * x) * (x * x * (x * x)) * x
03:46:25 <ion> > x**9
03:46:26 <lambdabot>  x**9
03:49:25 * hackagebot hamlet 1.1.9.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.9.2 (MichaelSnoyman)
03:55:15 <Kaidelong> is there anything really stopping the use of Graphics.Gloss.Interface.IO.Game in the real world?
04:09:55 <Axman6> Kaidelong: its representation of graphics isn't particularly efficient
04:10:05 <zomg> Bleh, why is the fpcomplete Haskell VM so totally outdated
04:11:09 <zomg> well, let's see how long it takes to compile GHC 7.6.3 in it :P
04:37:35 <ocharles> Hey, does anyone know how to use GHC to compile a dynamic/shared .so file that uses template haskell?
04:38:03 <ocharles> Currently I am ussing: ghc -O2 foo.c --make -dynamic -shared -fPIC foo.hs -o foo.so
04:38:23 <ocharles> But I get: final link ... ghc: foo.o: unknown symbol `__stginit_foo'
04:38:37 <ocharles> If I remove {-# LANGUAGE TemplateHaskell #-} and template haskell using code from foo.hs, it all works fine
04:53:36 <AlainODea> ocharles: I suggest building with Cabal.  It lets you specifiy language extensions and package dependencies.
04:56:08 <quicksilver> not sure it's going to answer his question about dynamic libs and TH though
04:57:03 <AlainODea> quicksilver: good point :)
04:57:15 <bennofs> ocharles: have you tried doing the compiling and linking seperately?
04:59:24 <bezirg> question: can I have haskell's pattern matching behave like Erlang's pattern matching?
04:59:38 <bennofs> bezirg: how does Erlangs pattern matching behave?
05:00:19 <quicksilver> the bit where you can use existing variables on the left, you mean?
05:00:22 <xpika> how can i write a function f where if i give it an Int it prints "Integer!" otherwise it calls show on the function.
05:00:25 <bezirg> quicksilver: yes
05:00:41 <quicksilver> no, it's not a good conceptual match for haskell
05:00:47 <Iceland_jack> bezirg: Why do you want to do that?
05:00:53 <bartavelle> is it possible to write "constraint synonyms" ?
05:00:54 <quicksilver> pattern matching is an important lower-level operation on Data
05:01:01 <bezirg> bcs I am translating a language that has this Erlang pattern matching to Haskell
05:01:09 <bartavelle> SYN m => a -> m b
05:01:13 <quicksilver> and that behaviour requires equality
05:01:21 <bezirg> should I do just equality?
05:01:24 <Iceland_jack> bezirg: yes
05:01:26 <bartavelle> so that I don't have to write (MonadX m, MonadY m, MonadZ m) all the time ?
05:01:28 <bezirg> ok
05:01:33 <bezirg> ty ppl
05:01:35 <quicksilver> haskell doesn't have a primitive notion of equality - just the Eq class
05:01:40 <quicksilver> I'd use a guard with ==
05:01:47 <bennofs> bartavelle: -XConstraintKinds and then just use type SYN = (MonadX m, MonadY m, MonadZ m)
05:01:48 <Iceland_jack>     foo x y | x == y    = ...
05:01:48 <Iceland_jack>             | otherwise = ...
05:01:49 <bezirg> quicksilver: yeah that's what I thought to
05:01:54 <bartavelle> bennofs, thanks !
05:01:58 <haasn> xpika: you can't without some dubious trickery. Haskell is not designed to let you decide what to do based on the type of a parameter
05:02:02 <tdammers> xpika: what kind of type signature would that function have?
05:02:05 <bennofs> bartavelle: s/type SYN/type SYN m/ ofc
05:02:14 <haasn> And there is no need to; if something is polymorphic, that means it shouldn't care about the specifics of the type
05:02:18 <bernalex> I'm a bit confused about the connections between base and prelude and ghc. can someone summarise them for me?
05:02:29 <xpika> tdammers: f :: Show a -> String
05:02:36 <Iceland_jack> xpika: That's wrong
05:02:46 <xpika> Show a => a -> String
05:02:48 <bernalex> as in, what's the difference between prelude and base, and are they distributed with ghc? where do you get the src for prelude?
05:02:48 <haasn> bernalex: ‘base’ is a package distributed with GHC that exports the Prelude, among other things
05:02:56 <bernalex> haasn: OK I see
05:03:00 <xpika> Iceland_jack: ^
05:03:02 <haasn> bernalex: Prelude is part of the haskell standard and defines a set of functions/types that *must* be defined by any Haskell implementation
05:03:04 <bennofs> bernalex: Prelude is the only module that is imported by default. It's included in the 'base' package.
05:03:06 <Iceland_jack> Right, you can define
05:03:07 <Iceland_jack>     f :: Show a => a -> String
05:03:07 <Iceland_jack>     f = show
05:03:07 <Iceland_jack> :)
05:03:10 <bernalex> haasn: so if you want to look at the prelude src, that's not in the ghc repo?
05:03:10 <Iceland_jack> @ty show
05:03:11 <lambdabot> Show a => a -> String
05:03:33 <xpika> Iceland_jack: when an integer is given, "Integer!" is returned
05:03:39 <haasn> bernalex: It's careful not to confuse things here - there's a reference Prelude in the Haskell Report that you can look at
05:03:40 <xpika> Iceland_jack: otherwise show function
05:03:42 <bernalex> bennofs: haasn: right, I've read about prelude in the report so I sort of know what prelude is, but I wasn't sure about its relationship to base.
05:03:52 <Iceland_jack> xpika: You normally shouldn't do that, but you can make a type class
05:04:03 <haasn> bernalex: but many things in the formally defined Prelude are abstract; and implementations are also free to provide their own implementations provided they have identical semantic
05:04:06 <bernalex> so does base implement prelude?
05:04:10 <Iceland_jack> But you probably don't want to do that
05:04:11 <haasn> yes
05:04:16 <quicksilver> bernalex: the Prelude is a single module which is implicitly imported.
05:04:24 <xpika> Iceland_jack: could you show me?
05:04:30 <quicksilver> bernalex: 'base' is a package which comes with GHC and implements the prelude among other things.
05:04:36 <bernalex> so the "prelude source" I am looking for would then be the base src which is in the ghc repo?
05:04:37 <haasn> bernalex: ‘base’ is intrinsically tied to GHC, it's GHC's base package that implements a lot of GHC's basic stuff; including some that are abstract in the real Prelude
05:04:47 <haasn> bernalex: you can look at “base”'s source code to see GHC's definitions for many of the Prelude functions
05:04:48 <bernalex> haasn: yes, I understand this now, thanks.
05:04:49 <bennofs> bernalex: Here is the git repo for base: http://git.haskell.org/packages/base.git/
05:04:57 <xpika> Iceland_jack: I want to do that
05:05:01 <haasn> bernalex: and it is distributed with ghc as well, under ./libraries/base
05:05:05 <quicksilver> it's easier to browse the source via the online docs, IMO, bennofs, bernalex
05:05:06 <bernalex> bennofs: oh, I thought it was in the ghc repo. but it makes sense to split it. thanks.
05:05:22 <quicksilver> e.g. - http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html
05:05:23 <Iceland_jack> xpika: ...how do you know that you do? :)
05:05:23 <Iceland_jack>     class Show a => ShowInt a where
05:05:23 <Iceland_jack>         showInt :: a -> String
05:05:23 <Iceland_jack>         showInt = show
05:05:24 <bennofs> quicksilver: but you cannot see non-exported modules there
05:05:26 <bernalex> quicksilver: I have done that a lot, but I want to look at it in vim. :-)
05:05:36 <quicksilver> bernalex: ah well you can via a trick if you know what they are called
05:05:40 <quicksilver> bernalex: just edit the URL :)
05:05:59 <quicksilver> bernalex: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html
05:06:00 <bernalex> I want the revision history and commit msgs as well.
05:06:02 <quicksilver> for example
05:06:07 <bennofs> hmm, haddock should hyper-link the html. That would be awesome
05:06:08 <xpika> Iceland_jack: can you complete the code
05:06:08 <quicksilver> well of course then you want the git repo
05:06:14 <bernalex> :-)
05:06:25 <quicksilver> haddock does hyperlink the source, just not the hidden modules
05:06:25 <bernalex> haasn: oh right, thanks
05:06:48 <bennofs> quicksilver: I mean, in the highlighted source code, make each symbol a link to it's definition
05:06:55 <Iceland_jack> xpika: I would first like to know what you plan on doing :)
05:07:05 <Iceland_jack> Instead of solving what you think you should be doing
05:07:23 <haasn> Iceland_jack: you still need overlapping instances which is ugly
05:07:28 <haasn> even with a TC
05:07:32 <xpika> Iceland_jack: im writing a web based haskell interpreter plugin
05:07:43 <Iceland_jack> haasn: Yes
05:07:45 <bennofs> haasn: closed type families!
05:07:49 <Iceland_jack> Also undecidable instances?
05:07:54 <quicksilver> bennofs: yes, that would be awesome.
05:08:01 <haasn> xpika: what you could do is create your own newtype of Int; eg newtype MyInt = M Int
05:08:02 <quicksilver> bennofs: (although it would make for some very big HTML files...)
05:08:07 <xpika> Iceland_jack: i want a function which renders html table of either html entities or showable entities
05:08:10 <haasn> xpika: and your own instance Show MyInt where show _ = "Integer!"
05:08:31 <haasn> this way you'd be able to use “show :: Show a => a -> String” and get it to show your MyInts as “Integer!”
05:08:33 <xpika> this is proof of concept
05:09:11 <quicksilver> can you brose the library source in FPComplete? That would make it hyperlinked, as I understand it.
05:10:43 <aleator_> xpika: I did something similar, but ended up doing what youre apparently doing by inserting the expressions from the web inside different functions and using ghc-api to check which one of them typechecks first.
05:14:52 <greg`> hi i wonder if you can help im trying to cabal install cabal-install and im getting the following rejecting: deepseq-1.3.0.2/installed-6f6... (conflict: deepseq =>
05:14:53 <greg`> array==0.5.0.0/installed-0cd..., cabal-install => array>=0.1 && <0.5)
05:14:53 <greg`> rejecting: deepseq-1.3.0.2, 1.3.0.1, 1.3.0.0, 1.2.0.1, 1.2.0.0, 1.1.0.2,
05:14:53 <greg`> 1.1.0.1, 1.1.0.0, 1.0.0.0 (conflict: process =>
05:14:57 <greg`> deepseq==1.3.0.2/installed-6f6...)
05:15:56 <xpika> http://lpaste.net/100376
05:16:31 <xpika> is this simple problem documented somewhere?
05:16:43 <supki> greg`: I think you need to install cabal-install from upstream
05:17:08 <greg`> supki: what does that mean?
05:17:17 <supki> I mean the github repo
05:17:30 <greg`> ug, really? now way around that?
05:17:39 <supki> greg`: array-0.5.0.0 looks like you're using RC or something
05:17:42 <xpika> aleator_: ouch, i would prefer ghc to handle it
05:17:45 <greg`> i run on arm , really dont want to have to compile arm again
05:18:05 <greg`> although i could probably contribute by releasing the binary for all the pi's out there and whatnot
05:18:09 <fikusz> how can I run the example netwireIsCool at the end of http://hub.darcs.net/ertes/netwire ?
05:18:14 <greg`> yeah i am
05:18:48 <greg`> xpika, show int on unit comma string?
05:18:51 <xpika> haasn: could ou please show me?
05:18:57 <greg`> smells a bit
05:19:01 <fikusz> I get weird type errors if I try to compile it
05:19:44 <greg`> is ghc 7.8 out yet?
05:19:45 <aleator_> xpika: You really can't do it with your current approach. Typeclasses are open, so if you give instance for arbitrary a, you can't no longer make an instance for Int without the instances overlapping.
05:20:19 <greg`> well showInt takes an Int
05:20:32 <Taneb> What's the best way to see if all the elements of a list are unique?
05:20:38 <greg`> i dont see how we can make showInt then take two parameters
05:20:46 <greg`> Taneb but them in a set?
05:20:51 <haasn> bennofs: I'm actually curious to know how you'd do that with closed type families
05:20:54 <Cale> :t showInt
05:20:55 <lambdabot> Integral a => a -> ShowS
05:21:03 <haasn> bennofs: oh, wait, I think I know
05:21:07 <Cale> type ShowS = String -> String
05:21:07 <Taneb> greg`, I think that'd by overkill
05:21:15 <Cale> > showInt 46 "apple"
05:21:16 <lambdabot>  "46apple"
05:21:29 <greg`> well its an O(n) operation isnt it
05:21:45 <Cale> the reason it produces a String -> String function is that composing functions (which is O(1)) is more efficient than concatenation (which is O(n))
05:21:45 <bennofs> haasn: I think you could map Int to 'True and any other type to 'False and then write your instances for 'True and 'False?
05:21:48 <Taneb> greg`, well, for me n will be a maximum of 9
05:22:04 <haasn> bennofs: via something like data Type = Show | Int; type family ShowType a where ShowType Int = 'Int; ShowType a = 'Show ?
05:22:06 <haasn> yeah
05:22:12 <Cale> oh
05:22:21 <Cale> You're talking about showInt from a paste :)
05:22:28 <greg`> yes
05:22:31 <greg`> lol
05:22:51 <greg`> Taneb: putting them in a set is O(n)
05:23:12 <greg`> comparing each element in the list with all the others is probably O(n^2)
05:23:24 <Taneb> greg`, as I said, n is sufficiently small in my case
05:23:26 <xpika> the results should be "Integer!"\n((),"hi")\n
05:23:43 <haasn> and then class MyShow (t :: Type) a; instance MyShow 'Int a where show' _ = "Integer!"; instance Show a => MyShow 'Show a where show' = show;  foo :: MyShow (ShowType a) a => a -> String -- ?
05:23:56 <Taneb> greg`, also, putting them in a set is n log n
05:24:14 <greg`> ~ n
05:24:19 <ocharles> bennofs: I haven't tried that
05:24:27 <Cale> xpika: You appear to be missing an instance for pairs (at the very least)
05:24:29 <ocharles> AlainODea: I'm not sure cabal can even build .so files like this
05:24:35 <ocharles> I'm not sure though
05:24:47 <ocharles> I'm building a shared library callable from C
05:25:04 <xpika> Cale: i want to piggy back on the Show type for all other types
05:25:15 <Cale> xpika: You still have to write the instances.
05:25:20 <aleator_> xpika: Actually, I think Cale was accidentally right on how you could do it: see instance ShowInt Int where showInt a = "Integer!"
05:25:31 <Cale> xpika: Even if you're going to write showInt = show
05:25:37 <aleator_> Oops. Meant: https://hackage.haskell.org/package/base-4.3.0.0/docs/src/GHC-Show.html#showList
05:25:48 <greg`> Taneb i cant think of any way around it , the best sorting algos are n log n ,
05:25:52 <Cale> you'll have to write something like
05:26:07 <Taneb> greg`, thanks for your help
05:26:19 <Cale> instance (Show a, Show b) => ShowInt (a,b) where showInt = show (a,b)
05:26:27 <Cale> er
05:26:30 <Cale> instance (Show a, Show b) => ShowInt (a,b) where showInt (a,b) = show (a,b)
05:26:39 <bennofs> ocharles: Shouldn't just setting c-sources: foo.c be enough for that? (with cabal configure --enable-library-dynamic --enable-shared)
05:26:52 <Cale> xpika: and so on, for each type you'd like to apply showInt to
05:27:31 <tanmaig> Hi all! My first time here. In Template Haskell : [d| data MyType = Either String Int |] is valid. How would I do something like [d| data Mytype = Either String [Int] |] ?
05:27:44 <xpika> Cale: is there no way to cover all types?
05:28:14 <Cale> xpika: Well, if you wrote an instance which covered all types, it would overlap with your existing instance
05:28:44 <ocharles> bennofs: Dunno :)
05:28:46 <ocharles> I'll try it soon
05:28:51 <xpika> Cale: what im looking for is a ghc extesion. something like a {#- LANGUAGE PrioritizedInstances -}
05:28:52 <Cale> tanmaig: Are you sure you mean data there?
05:29:01 <ocharles> But I probably need a custom build phase, because I'm meant to be using pg_config to find some libraries to link with
05:29:05 <Cale> tanmaig: You're defining a data type with a single constructor named Either
05:29:21 <Cale> tanmaig: Which takes both a String and Int as parameters
05:29:40 <Cale> xpika: What are you actually trying to use this for?
05:30:11 <tanmaig> Cale: Right, that's what I want to do. But supposed the second parameter was to be [Int] how would I write them with the Oxford brackets?
05:30:26 <tanmaig> Cale: Does that make sense?
05:30:38 <Cale> tanmaig: I don't understand what the problem is?
05:30:48 <Cale> tanmaig: You should be able to write either one?
05:31:05 <xpika> Cale: I have a function that renders a html table, its for an interactive web based haskell interpreter. I would like it to be able to render both regular html elements in the table as well as all instances of show
05:31:33 <tanmaig> The thing is, I get a parse error with ghci at '['
05:32:19 <tanmaig> Cale: Oh wait. Bugger. It just worked!
05:32:34 <tanmaig> Cale: Sorry, I don't know what was wrong initially. Sorry!
05:32:42 <xpika> i would like it if possible ghc could prioritize my instances from most specific to least specific
05:33:11 <quicksilver> xpika: lots of people would like that but it doesn't make sense.
05:33:31 <quicksilver> it's not compatible with the open world assumption or haskell's semantics for polymorphism.
05:33:58 <quicksilver> in a different system with different assumptions, sure :)
05:34:07 <quicksilver> (although it would be hard to implement separate compilation for that system)
05:34:38 <mornfall> quicksilver: separate compilation is overrated :-P
05:34:46 <quicksilver> mornfall: yes, it is.
05:35:19 <quicksilver> mornfall: but most compilation techniques are O(n^2) at least in source file size. So all-in-one compilation is not feasible for sufficiently large programs.
05:35:43 <quicksilver> although modern software engineering tools brute force their way through plenty of O(n^2) problems these days.
05:36:09 <mornfall> quicksilver: what's the n in your n^2 here? number of toplevel definitions?
05:36:10 <xpika> quicksilver: isn't that what ghc extensions are for?
05:36:19 <quicksilver> mornfall: it doesn't really matter does it?
05:36:29 <quicksilver> mornfall: some metric of source file size. Definitions. Terms. Characters.
05:36:35 <quicksilver> xpika: yes.
05:36:42 <quicksilver> xpika: and overlappinginstances does what you want.
05:36:49 <quicksilver> xpika: but it also doesn't, because it can't
05:36:54 <quicksilver> so it works in some cases and fails in others.
05:37:00 <quicksilver> it's good to understand which/why.
05:37:24 <mornfall> quicksilver: it matters because for different types of n you can do different optimisations to that brute-force n^2 :-)
05:37:28 <quicksilver> sure
05:37:33 <quicksilver> well, details vary, mornfall
05:38:00 <quicksilver> GHC has in the past had various cases where compilation of a single expression was O(n^2) in the number of terms within the expression.
05:38:00 <mornfall> but anyway, LTO -- optimizers run on the entire linked programs these days anyway
05:38:07 <quicksilver> some of those have been fixed.
05:38:35 <mornfall> and optimizers are a good chunk of the time spent in compilation
05:39:41 <quicksilver> mornfall: you overstate the case.
05:39:51 <quicksilver> mornfall: "some" optimisers run on entire linked programs.
05:39:52 <mornfall> (because not inlining across compilation unit is fairly expensive too :)
05:40:00 <mornfall> units*
05:40:02 <quicksilver> there are a wide range of optimisation stages in modern compilers
05:40:07 <quicksilver> some are quite local and some are very global.
05:40:47 <mornfall> sure, but for the local ones, program size doesn't matter much
05:41:16 <mornfall> they are localised by other means than compilation units
05:41:41 <prophile> an advantage of optimisations at the compilation unit level is you effectively get caching on the results
05:41:51 <prophile> rather than one change in a compilation unit meaning rerunning optimisations on the entire program
05:50:52 <mornfall> prophile: that's a crude way to do it, but sure... you can also cache them per toplevel definition just as well, or whatever fits your language... ghc/cabal already don't use make
05:51:25 <prophile> it may be crude but it's quite effective
05:51:48 <prophile> and doesn't involve introducing any extra caches
05:52:48 <mornfall> prophile: storing per-unit object files is a form of an extra cache
05:53:01 <mornfall> prophile: you just off-load that to make, or whatever build manager
05:53:18 <prophile> you're right, but that's because I didn't make my meaning clear enough
05:53:21 <mornfall> prophile: and since make can only work with simple file->file mappings, that's what you do then
05:53:42 <prophile> existing build systems do produce per-unit object files, so one doesn't need an *extra* cache
05:54:09 <mornfall> prophile: the question is whether the existing build system is worth bending your language
05:54:24 <mornfall> prophile: practice shows that many many languages end up with custom build systems sooner or later anyway
05:54:37 <mornfall> prophile: they just inherit the file model from make, because that's how they started
05:54:52 <mornfall> (see ant, cabal, rake, setuptools, ...)
05:56:57 <khyperia> prinsen, have you gotten any progress on the plugins library?
06:02:47 <Benzi-Junior>  I'm trying to have xmobar display the network status but when I edit the .xmobarrc and add a "commands" argument all the fields in xmobar display "Could not execute command ..." any idea what's wrong ?
06:05:29 <ndrei> Hi Benzi, can you paste your .xmobarrc somewhere?
06:06:08 <geekosaur> Benzi-Junior, hard to say without seeing the xmobar config, sadly xmobar is really lousy about config file errors (the file looks like haskell but is not)
06:07:50 <mm_freak_> Benzi-Junior: remember to compile xmobar with extensions enabled
06:08:05 <mm_freak_> Benzi-Junior: cabal install -fall_extensions xmobar
06:08:34 <mm_freak_> i'll count that as a "xmobar sucks! i'll switch to …" =)
06:09:07 <mm_freak_> Benzi-Junior: remember to compile xmobar with extensions enabled:  cabal install -fall_extensions xmobar
06:09:23 <mm_freak_> not sure if the flag is correct…  see the homepage for the exact flag
06:10:34 <Benzi-Junior> trying that
06:19:33 <Benzi-Junior> mm_freak_: still doesn't work
06:22:17 <phao> Heya... sorry the off-topic, but isn't there a channel for quicktest?
06:22:52 <Cale> QuickCheck, you mean?
06:23:22 <phao> ops, yes!
06:23:27 <Cale> I don't think it has its own channel
06:23:38 <Cale> You should probably just ask questions about it here
06:24:38 <phao> cale I'm watching this http://www.infoq.com/presentations/automated-testing and it seems really (!!!) interesting
06:35:29 <zomg> Anyone had problems with Scotty sending random looking junk when using `file` to serve a file as a response?
06:35:41 --- mode: ChanServ set +o roconnor
06:35:42 <zomg> It sends the whole file and then some junk shows up in the end
06:35:49 --- mode: roconnor set -o roconnor
06:37:43 <zomg> nevermind, I did a `cabal clean` and then tried to rebuild my app, and oh look, suddenly missing packages...
06:37:55 <zomg> that's probably causing this then... :P
06:49:54 <guymann> hi
06:49:58 <geekosaur> siiigh. why does the haskell community feel saving developers a little work is so much more important than saving end users expecting a curated collection of reliable libraries from masses of incomprehensible type errors?
06:50:26 <geekosaur> obviously we must jettison the PVP because it hurts the devs so much, because the users *ought* to be the ones who suffer...
06:50:42 * geekosaur is grumpy today, yes.
06:52:15 <Twey> geekosaur: We did *what* to the PVP?  o.@
06:52:48 <geekosaur> we haven't yet but the arguments on the libraries list are getting louder again about how the PVP just sucks developer time and is broken
06:53:09 <Twey> Broken how?
06:53:53 <geekosaur> because developers shouldn't have to set and maintain upper limits on their dependencies, because obviously breakages in major versions never happen
06:54:04 <geekosaur> except they do happen, with some regularity
06:54:43 <merijn> Twey: He's complaining about the mailing list discussion
06:54:43 <merijn> Twey: In that it produces more non-building packages than lack of PVP does
06:55:14 <Twey> Hrm
06:55:26 <Twey> Well, the *API* obviously breaks between major versions — isn't that what major versions are for?
06:55:30 <geekosaur> whatever. yes, push it all off on the end users, they know all about how to deal with the resulting breakages
06:55:31 <quicksilver> the problem is that it's a very hard problem which most of the people who spend time arguing about it don't actually understand completely.
06:55:48 <Twey> Backpack?  :þ
06:56:03 <quicksilver> and comparison with how other languages solve it tend to focus on ruby, python, or perl, which have quite different tradeoffs in play.
06:56:22 <Twey> And quite different end-goals
06:57:09 <quicksilver> I think it might be true that the PVP doesn't work quite as well as we hoped when we drew it up.
06:57:09 <quicksilver> (inclusive sense of the word 'we' intended)
06:57:37 <geekosaur> a lot of this pain wouldn't exist if ghc didn't do cross-module inlining, but it's looking like that is essential to get code that actually runs at anything like reasonable speed :(
06:58:11 <geekosaur> the PVP has flaws but the specific argument about upper bounds is the one that pushes pain points from the developers to the users
06:58:59 <quicksilver> yes.
06:59:14 <quicksilver> I agree with you. I have unfortunately no time to take part in the mailing list argument.
06:59:24 <geekosaur> and I would argue that pushing the pain point onto users is almost always wrong
07:00:05 <quicksilver> I think there might be a scope for a system which does test compilations automatically and weakens upper bounds when a test compilation proves it works. FSOV proves. But it is probably a lot of work to get that right, and somebody has to do it.
07:01:59 <Twey> quicksilver: Sounds like an approximation to Backpack's functionality
07:02:38 <Twey> (a rather slow and less theoretically-pleasant one)
07:02:48 <quicksilver> Twey: does it? I haven't read anything about it beyond the titles of the articles.
07:03:05 <hamid> hey
07:03:47 <Twey> quicksilver: Modules have signatures like in SML; a package can be built against any other package that exports the right signature
07:05:29 <quicksilver> Twey: of course package versions might be semantic promises not just signature promises
07:05:38 <quicksilver> Twey: occasionally they might even be performance promises
07:05:56 <quicksilver> but you could argue that a package upgrade changing a semantic or performance promise is bad style.
07:06:03 <quicksilver> (such things surely deserve a new name)
07:07:30 <Saizan> won't the developers complain that they have to write the signatures, then?
07:07:36 <Twey> quicksilver: I would, and furthermore those are concerns not covered by any of the alternatives :þ
07:08:21 <Twey> quicksilver: The type-theoretic answer is probably ‘then make your types better’
07:08:43 <Saizan> i guess you can infer quite specific ones by doing a dependency analysis on a compilation against a version known to work
07:08:49 <quicksilver> Saizan: it infers them doesn't it?
07:09:56 <Twey> quicksilver: You need (IIRC) to specify the signatures you *require*
07:10:07 * quicksilver nods
07:10:24 <Twey> But I think if people are okay with writing type signatures then they can shut up and write module signatures as well.  ☺
07:10:50 <quicksilver> ignoring rankN types and similar features surely it's possible to infer the types demanded of external symbols?
07:10:52 <Saizan> yeah, that kind of inference is pretty much undecidable, but you can take a hint if you have a specific package that's known to fit the desired signature
07:11:13 <Saizan> quicksilver: i think it gets into rankn territory even if your code isn't
07:11:19 <Twey> I don't know if this is included in the Backpack proposal, but… yeah, all you should really need to specify is where the names come from, via explicit imports or qualified imports
07:11:28 <quicksilver> although you might infer an overly specific type
07:11:51 <Twey> Saizan: Where does the rank-n come from?
07:11:57 <quicksilver> Saizan: because of typeclasses which are secretly rank 2?
07:12:04 <quicksilver> otherwise I don't see how
07:13:18 <Saizan> Twey, quicksilver: (map chr xs, map ord ys) <- suddenly you have to infer a polymorphic type for map
07:13:50 <Twey> Saizan: Is that rank-n, though?  It's at worst rank-2
07:14:04 <Twey> Which I believe is inferrable?
07:14:34 <Saizan> add some constructor classes and you can go higher, i think
07:14:43 <Saizan> but it'd be nice if it actually ended up inferrable
07:16:16 <Twey> :t sequence
07:16:17 <lambdabot> Monad m => [m a] -> m [a]
07:16:48 <Twey> ∀ a m. Monad m ⇒ [m a] → m [a]; where does the rank go up?
07:16:58 <Saizan> inside Monad m
07:17:38 <Saizan> but also, inferring class and types declarations is going to be worse still
07:17:43 <Twey> Oh, because return ∷ ∀ a. a → m a ?
07:18:06 <Twey> Hrm, true that
07:19:11 <Saizan> maybe given the classes you can get as far as requiring instances though
07:19:21 <quicksilver> Twey: yes, the dictionary encoding of rank-1 type classes turns you into rank-2 data
07:20:01 <quicksilver> Twey: this is a slight issue with my rant "don't use type classes, just use data types"
07:20:28 <quicksilver> :t \map xs ys -> (map chr xs, map ord ys)
07:20:28 <lambdabot>     Couldn't match type `Char' with `Int'
07:20:29 <lambdabot>     Expected type: Int -> Char
07:20:29 <lambdabot>       Actual type: Char -> Int
07:30:37 <NobbZ> Hi there! Can someone help me with my problem? Posted on SO: http://stackoverflow.com/questions/22018670/after-reading-a-file-i-have-io-char-but-i-need-io-char
07:31:01 <mr-> quicksilver: how do you make that line work? ;-)
07:31:24 <quicksilver> mr-: how would you make it typecheck?
07:31:43 <quicksilver> mr-: but turning on higher rank types and giving the 'map' parameter an explicit polymorphic type.
07:31:47 <quicksilver> s/but/by/;
07:32:24 <Cale> NobbZ: It would be more meaningful to go from [IO Char] (i.e. a list of IO actions each of which produces a single character if executed) to an IO [Char] (a single action which if executed will produce a list of characters)
07:32:27 <quicksilver> NobbZ: "sequence" is the name of the function which turns [IO Char] into IO [Char]
07:32:32 <mr-> quicksilver: I am good with the first part, and struggling with the second
07:32:40 <Cale> and yeah, the thing which does that is called  sequence
07:32:44 <quicksilver> and that's actually what you need, I think you just read the error message backwards
07:32:46 <Cale> @src sequence
07:32:47 <lambdabot> sequence []     = return []
07:32:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:32:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:33:04 <Cale> also,  x >>= return  is always the same thing as x
07:33:27 <Cale> and  putStrLn . show  has a name, it's called  print
07:33:29 <quicksilver> mr-: \(map :: forall a b . (a -> b) -> [a] -> [b]) , I think
07:34:08 <quicksilver> mr-: althouhg you need another extension to annotate in patterns
07:34:14 <quicksilver> otherwise you have to annotate the whole think
07:35:18 <Cale> NobbZ: You probably want something like  intify = do xs <- readNumber; return (map digitToInt xs)
07:35:44 <NobbZ> I know about print shortcut and about x>>=return stuff, that are artifacts, left by shortening the actual source to the relevant part
07:35:58 <mr-> quicksilver: Thanks, I was too stupid to actually see that the types of the lists have to be [Int] and [Char]..
07:36:28 <mr-> (and didn't understand the two pages of type-errors that scrolled by :-)
07:36:34 <quicksilver> mr-: :)
07:41:11 <osa1> do we have mapMaybe for Data.Set.Set ?
07:43:20 <NobbZ> OK, thank you, this works for now!
07:44:36 <quicksilver> osa1: http://hackage.haskell.org/package/set-extra-1.3.1
07:44:54 * hackagebot casadi-bindings 1.8.2.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.8.2.1 (GregHorn)
07:46:47 <mm_freak_> when rounding a Float/Double to an Int, is there an easy way to detect overflows?
07:46:59 <mm_freak_> > round (2**100) :: Int
07:47:00 <lambdabot>  0
07:48:13 <mr-> That absolutely is a mistake I would not have caught
07:48:46 <Iceland_jack> > fromIntegral (round (2**100) :: Int) /= (round (2**100) :: Integer)
07:48:46 <Iceland_jack> :)
07:48:47 <lambdabot>  True
07:49:07 <mm_freak_> without going through Integer
07:49:27 <mm_freak_> i have to perform millions to billions of those checks
07:51:15 <dagle> > round (2**100) :: Integer
07:51:16 <lambdabot>  1267650600228229401496703205376
07:52:17 <dagle> > maxBounds :: Int
07:52:18 <lambdabot>  Not in scope: `maxBounds'
07:52:18 <lambdabot>  Perhaps you meant `maxBound' (imported from Prelude)
07:52:23 <dagle> > maxBound :: Int
07:52:24 <lambdabot>  9223372036854775807
07:52:32 <dagle> mm_freak_: You can use that?
07:53:08 <mm_freak_> dagle: how exactly would i use that without going through Integer?
07:54:22 <Iceland_jack> > let val = 2**100 in if val < 9223372036854775807 then Just (round val) else Nothing
07:54:23 <lambdabot>  Nothing
07:54:28 <Iceland_jack> > let val = 2**10 in if val < 9223372036854775807 then Just (round val) else Nothing
07:54:29 <lambdabot>  Just 1024
07:55:19 <dagle> mm_freak_: You know that Float/Double haven't overflowned?
07:55:45 <dagle> If so, take the maxBound of int, convert it to a double and compare?
07:57:40 <mindleyhilner> :t maxBound
07:57:41 <lambdabot> Bounded a => a
07:57:47 <mindleyhilner> oh, he beat me to it
08:00:00 <Iceland_jack> I thought mm_freak_ was only thinking about overflow when rounding
08:00:58 <quicksilver> I imagine millions or billions of Float/Double ">" range checks can be performed rather quickly on a GPU
08:01:30 <Iceland_jack> dagle: Isn't that the same thing I posted?
08:01:44 <Iceland_jack> absolutely
08:19:57 * hackagebot idempotent 0.1.0 - Idempotent monoids  http://hackage.haskell.org/package/idempotent-0.1.0 (alynn)
08:19:59 <Guest7610> @djinn a->a
08:19:59 <lambdabot> f a = a
08:20:03 <Guest7610> @djinn a->b
08:20:04 <lambdabot> -- f cannot be realized.
08:20:08 <Guest7610> @djinn a->Int
08:20:09 <lambdabot> Error: Undefined type Int
08:20:13 <Guest7610> @djinn a->[a]
08:20:13 <lambdabot> Error: Undefined type []
08:20:27 <Guest7610> @djinn a->[a]->[a]
08:20:27 <lambdabot> Error: Undefined type []
08:20:37 <Guest7610> @djinn Either a b -> a
08:20:37 <lambdabot> -- f cannot be realized.
08:20:43 <Guest7610> @djinn Either a b -> Either b a
08:20:44 <lambdabot> f a =
08:20:44 <lambdabot>     case a of
08:20:44 <lambdabot>     Left b -> Right b
08:20:44 <lambdabot>     Right c -> Left c
08:21:06 <Guest7610> @djinn (a,b)->Either a b
08:21:06 <lambdabot> f (a, _) = Left a
08:21:13 <Guest7610> @djinn (a,b)->Either a c
08:21:13 <lambdabot> f (a, _) = Left a
08:21:22 <quicksilver> @djinn Either a b -> (b -> a) -> a
08:21:22 <lambdabot> f a b =
08:21:22 <lambdabot>     case a of
08:21:22 <lambdabot>     Left c -> c
08:21:22 <lambdabot>     Right d -> b d
08:21:40 <prophile> usefully, lambdabot works in /msg :)
08:22:07 <Guest7610> @djinn (x->a)->a
08:22:08 <lambdabot> -- f cannot be realized.
08:22:15 <Guest7610> @djinn (()->a)->a
08:22:15 <lambdabot> f a = a ()
08:22:36 <Guest7610> @djinn (((()->a)->a)->a->a)
08:22:36 <lambdabot> f a b = a (\ _ -> b)
08:22:44 <MMuse> so... my first experience with Haskell has been pretty bad. The assignment was to make a binary tree with n nodes of minimum depth. and I spent about 3 hours fiddling with trying to get it to convert between integers and realfracs and ints and integrals and all this and I don't get it at all :< it was nice up to the point where I needed to do arithmetic
08:23:07 <quicksilver> MMuse: you should have just come here and asked?
08:23:18 <Guest7610> @djinn ((((()->a)->a)->a)->a)
08:23:18 <lambdabot> f a = a (\ b -> b ())
08:23:33 <monochrom> I fail to see why realfracs should be involved
08:23:38 <MMuse> It was for homework :s
08:23:44 <quicksilver> Int -> Integer is fromIntegral; Int(eger) -> Double is realToFrac;
08:23:44 <quicksilver> Double -> Int is 'round' but think about whether that's what you want.
08:23:55 <monochrom> trivially, for "divide by 2", div works, and stays integer
08:24:15 <MMuse> monochrom: leftsize n = toInteger $ ceiling $ ((fromInteger n)-1)/2
08:24:23 <MMuse> need ceiling for one side, and floor for the other
08:24:58 <monochrom> let me see what does that really accomplish
08:25:18 <monochrom> > map (\n -> toInteger $ ceiling $ ((fromInteger n)-1)/2) [0 .. 10]
08:25:19 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5]
08:25:50 <quicksilver> MMuse: you could just leftsize n | odd n = n-1 `div` 2 | even n = n `div` 2
08:26:03 <monochrom> > map (\n -> div (n-1) 2) [0 .. 10]
08:26:04 <lambdabot>  [-1,0,0,1,1,2,2,3,3,4,4]
08:26:25 <prophile> :t \a -> let (q, r) = a `quotRem` 2 in (q, q + r)
08:26:26 <lambdabot> Integral t => t -> (t, t)
08:26:30 <monochrom> > map (\n -> div n 2) [0 .. 10]
08:26:31 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5]
08:26:31 <prophile> MMuse: ^
08:26:40 <mm_freak_> dagle: i don't trust that the maxBound of Int will be converted from a Float to an Int successfully
08:26:49 <monochrom> toInteger $ ceiling $ ((fromInteger n)-1)/2  is simply div n 2
08:27:01 <mm_freak_> at this point i have set an arbitrary maximum to 2**30
08:27:04 <quicksilver> but I do agree that the (Int .. Integer .. Double) cycle is a bit of pain until you get your way around it and could be more clearly documented in a single place somewhere
08:27:48 <MMuse> Ok :s well if I ever get a handle on it tjh
08:27:50 <quicksilver> mm_freak_: well int has more precision than Float there but I'd think you can be sure it won't overflow. It will just come out a bit low.
08:27:54 <prophile> @test let splitInt a = (let (q, r) = a `quotRem` 2 in (q, q + r)) in \x -> uncurry (+) (splitInt a) == a
08:27:54 <lambdabot> Maybe you meant: tell list let leet
08:27:59 <prophile> @check let splitInt a = (let (q, r) = a `quotRem` 2 in (q, q + r)) in \x -> uncurry (+) (splitInt a) == a
08:28:01 <lambdabot>  *** Failed! Falsifiable (after 1 test):
08:28:01 <lambdabot>  ()
08:28:09 <MMuse> Err, then I'll write that tutorial
08:28:13 <monochrom> "the homework specifies floor and ceiling" is not an excuse to literally use floor and ceiling
08:29:12 <monochrom> the whole point of programming is that you use a different technique, a better one, than literally transliterating the specification, and still get the same answer efficiently and effectively
08:30:03 <mm_freak_> quicksilver: portably?
08:31:02 <prophile> ah rats, typical quickcheck
08:31:03 <prophile> you get the idea anyway ^^
08:31:08 <quicksilver> > round (2 ** 32 :: Float)
08:31:08 <quicksilver> actually on second thoughts you can't be sure.
08:31:08 <quicksilver> you'd have to check :)
08:31:08 <quicksilver> yes, it rounds up to maxBound+1
08:31:09 <lambdabot>  4294967296
08:31:52 <mm_freak_> quicksilver: the problem is that i'm not even finished when i have the Int
08:32:29 <quicksilver> mm_freak_: it's probably portable because truncating things is going to give a mutiple of 2^n for some n
08:32:40 <quicksilver> mm_freak_: in fact, (maxBound :: Int) - 63 rounds up to maxBound+1
08:32:40 <quicksilver> mm_freak_: but (maxBound :: Int) - 64 rounds back down to maxBound - 64
08:32:51 <quicksilver> mm_freak_: which is consistent with Float having 6 less bits for the mantissa, I guess.
08:33:35 <quicksilver> mm_freak_: 00380
08:33:39 <quicksilver> http://lpaste.net/100380
08:33:43 <quicksilver> clumsy paste :)
08:34:00 <MMuse> the homework didn't specify floor and ceiling, it was just how I intuitively thought of to solve it, not knowing that it would give me problems with type conversions.
08:34:38 <monochrom> then it is a story of "XY problems waste 3 hours" instead
08:34:55 <MMuse> more or less :P
08:36:07 <quicksilver> MMuse: but you triumphed through it and had a satisfying conversation here on the back of it. Seems like the homework was a complete success :)
08:36:23 <osa1> will stylish-haskell ever support MultiWayIf? is it related with haskell-src-exts or some other dependency?
08:36:55 <quicksilver> MMuse: The slightly painful nature of the Int(eger) -> Double roundtrips has taught me to prefer Int math if at all possible, even if the algorithm looks slightly worse written that way.
08:37:08 <quicksilver> I think that's actually a good thing, you get better code that way.
08:37:18 <MMuse> eheh... well.. I ended up with a bad, but working solution... I don't know if that's a triumph :P but, I see your point
08:37:37 <MMuse> I see now how it could be done with div, and would be nicer
08:37:38 <monochrom> I prefer explicit conversions.
08:38:00 <quicksilver> MMuse: the *purpose* of a homework exercise is not to produce a solution. The *purpose* is to foster enlightenment. The solution is just the waste product of that process.
08:38:07 <monochrom> there is no such thing as "the computer can guess what you want"
08:38:19 <MMuse> Do What I Mean
08:38:24 <quicksilver> it's unfortunate that if you get graded on the waste product, but life sucks.
08:38:40 <monochrom> that is, until humans have USB 3.0 ports in their heads
08:38:43 <thebnq> they need some heuristic for presenting progress (:
08:39:13 <MMuse> It's an intro course so the grade is just 'is it correct' not 'is it good'
08:41:06 <mm_freak_> quicksilver: i got rid of the Int altogether now
08:41:14 <mm_freak_> it will quickly blow up on 32 bit systems
08:41:42 <MMuse> use BigInt now?
08:41:48 <mm_freak_> MMuse: Float
08:41:49 <MMuse> or whatever the...thing
08:44:46 <monochrom> Float still blows up on 32-bit systems. and also 64-bit systems.
08:45:11 <prophile> use a type with at least consistent sizes across all systems
08:45:14 <prophile> I recommend ()
08:45:45 <monochrom> it is almost like "I switch to Word8 so it blows up on 16-bit systems too"
08:46:29 <prophile> well, if you fill out the Num instance for () you'll discover it shares with Integer the property that it can never overflow
08:46:45 <prophile> which gets rid of the blowing up problem
08:47:02 <startling> [()] would work too
08:47:33 <prophile> presumably (forall r. (r -> r) -> (r -> r)) too were one so inclined
08:47:39 <MMuse> how does Integer actually work? is it like a string, but with binary digits?
08:47:53 <Cale> You can, however, fill your entire memory with Integer goodness, and then run out of space.
08:47:54 <MMuse> or I guess 256-bit or word-size digits
08:48:01 <startling> MMuse: you can think of it as a list of Ints, I guess
08:48:07 <monochrom> be careful when you perform binary operations on (). see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
08:48:18 <startling> "like a String but with binary digits" is kind of a weird way to put it.
08:48:19 <MMuse> ok
08:48:40 <MMuse> forgive my newbie way of expressing things :P
08:49:06 <startling> MMuse, i.e. it's a base-n digital represetation of a number where n is maxBound or something
08:49:07 <haasn> MMuse: Integer is implementation-dependent
08:49:14 <startling> but yeah, this too ^
08:49:21 <MMuse> ah...
08:49:22 <haasn> MMuse: GHC usually uses integer-gmp, which is an implementation that calls out of GMP internally
08:50:06 <startling> there's not a reason you couldn't write a pure-haskell version though
08:50:16 <haasn> indeed, and there's also an integer-pure drop-in replacement for integer-gmp
08:50:18 <MMuse> do you have to worry about cache pages or anything or is that too low-level for a haskell program
08:50:23 <haasn> or integer-simple or whatever
08:51:35 <Cale> In GHC, Integer internally has two data constructors, one which simply holds an Int, and the other of which gives a size together with a (pointer to) a byte array for use with GMP.
08:52:58 <mm_freak_> monochrom: Float does not blow up in my application…  i need the range, not the precision
08:53:50 <monochrom> I understand. 2^128 is still too limiting for me. i.e., 8-bit signed exponent
08:54:14 <quicksilver> MMuse: well, worrying about cache pages is more difficult when you have less control over memory layout, but it will still make a difference to performance of CPU-bound code
08:54:40 <MMuse> btw, unrelated but I'm having trouble downloading the haskell platform. it usually gets to about 3-6 mb and then times out. I was playing with browser-based tools to do my assignment but...
08:54:44 <quicksilver> MMuse: haskell programmers can still choose data structures and data types which have good cache locality.
08:55:01 * hackagebot amazon-emailer-client-snap 0.1.0.0 - Client library for amazon-emailer daemon  http://hackage.haskell.org/package/amazon-emailer-client-snap-0.1.0.0 (DanielPatterson)
08:57:31 <MMuse> quicksilver: I see... so that depends on your environment somewhat still?
08:58:07 <quicksilver> MMuse: what do you mean?
08:58:46 <mm_freak_> monochrom: i would use Double, but as i mentioned earlier i will be handling something between millions and billions of those
08:59:07 <MMuse> like.. making an arraylist as opposed to a linked list... I'm not sure, I guess I don't know enough about the language to be worrying about this sort of thing yet.
09:00:01 * hackagebot profiteur 0.1.0.0 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.0.0 (JasperVanDerJeugt)
09:05:29 * hackagebot profiteur 0.1.0.1 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.0.1 (JasperVanDerJeugt)
09:06:24 <quicksilver> MMuse: absolutely. I'm not sure if that's what I'd call 'environment'. But yes, choice of data structure may make a big diffrence to performance.
09:06:57 <quicksilver> MMuse: fortunately the type system makes refactoring data structures relatively easy so it's not normally a big cost to start with the "simplest to code with" and change if performance becomes an issue.
09:07:22 <MMuse> well what I mean is, is there a way to define a linkedlist differently from an arraylist in Haskell
09:09:00 <MMuse> I guess x.x
09:09:31 <quicksilver> yes
09:09:41 <quicksilver> standard haskell lists are singly-linked.
09:09:41 <hakujin> MMuse: standard haskell lists are linked lists. If you need an array like structure for performance check out Data.Vector
09:09:59 <MMuse> ok, that's interesting
09:10:00 <quicksilver> other 'packed in memory' structures exist like Vector and UVector.
09:10:41 <MMuse> and they're both implemented in pure Haskell? or are they provided by the compiler or w/e
09:10:46 <hakujin> I'm with quicksilver; unless you know you need a Vector use a List
09:11:11 <quicksilver> MMuse: Vector uses compiler extensions to be efficient.
09:11:55 <MMuse> ok, I think that answers my question
09:20:24 <opensourcegeek> hello guys - i'm hitting a problem when importing module I think
09:20:41 <opensourcegeek> I'm quite new to haskell, and I was wondering if someone could help
09:21:18 <hiptobecubic> opensourcegeek, paste the error at lpaste and ask directly
09:22:39 <ReinH> hakujin: on the other hand, if you are using lists for data processing you are probably doing it wrong
09:22:59 <startling> opensourcegeek: (include the files, too)
09:23:13 <hiptobecubic> ReinH, what are data structures for if not processing data?
09:23:29 <ReinH> linked lists are control structures
09:23:41 <startling> heh.
09:24:01 <startling> but ~*~ homoiconicity ~*~
09:24:56 <ReinH> Ok, linked lists are also good for processing trivially small amounts of data :D
09:25:14 <quicksilver> ReinH: yes, in a sense. But it may sometimes lead to the simplest program. And the simplest program is the best one until you realy understand the performance constraints.
09:25:35 <quicksilver> ReinH: (if you're rewriting an existing system you might already know what the performance constraints are going to be)
09:25:45 <ReinH> Right, but sometimes you know that you're doing enough text processing to want Data.Text, etc
09:25:50 <opensourcegeek> http://lpaste.net/100381
09:26:06 <ReinH> Which is, you know, basically anything more complex than command line arguments :p
09:26:32 <opensourcegeek> I've just copy pasted the error with the modules code
09:28:36 <jeronimo> ReinH, you are talking rubbish as usual. when processing textual data as a stream linked list can be appropriate
09:29:25 <jeronimo> if you are processing char by char there will be no overhead of a linked list, because it won't even be allocated in memory
09:29:47 <ReinH> "talking rubish as usual"
09:29:50 <ReinH> jeronimo: that's not very nice
09:29:55 <pavonia> opensourcegeek: The imports list has to follow the "module ... where" part
09:30:37 <jeronimo> ReinH you are clueless about basic data structures, and haskell in general, and are just parroting what others have said
09:30:46 <ReinH> jeronimo: you are rude.
09:31:05 <ReinH> and since I don't remember having dealings with you on here, I'm not sure where you got the idea that I'm clueless.
09:31:19 <ReinH> But I'm not interested in having some random person be rude to me
09:31:34 <quicksilver> jeronimo: irrespective of the merits of ReinH's arguments, that's not a pleasant way to behave
09:32:13 <jeronimo> ReinH being puzzled why binary tree can't be implemented with Eq is one example among many
09:32:35 <quicksilver> opensourcegeek: you want the import statements after the module statement.
09:32:39 <ReinH> jeronimo: stop.
09:32:43 <ReinH> It's rude.
09:33:08 <quicksilver> opensourcegeek: that extremely strange error means that, because it didn't see a "module" statement as the first line of the source file, it's assuming the module is called Main
09:33:08 <ReinH> jeronimo: the fact that you seem to spend so much time cataloging a list of my supposed faults says a lot more about you than it does about me
09:34:02 --- mode: ChanServ set +o monochrom
09:34:05 <hiptobecubic> jeronimo, i'd rather ReinH be clueless than you ruin the atmosphere here. There are plenty of knowledgeable people to make up for any shortcomings in a response. You might be better suited for ##c.
09:34:08 --- mode: monochrom set +b *!*@mistero.ircgate.it
09:34:09 --- kick: jeronimo was kicked by monochrom (jeronimo)
09:34:33 <ReinH> God forbit someone make a mistake.
09:34:34 * ReinH sighs
09:34:47 <ReinH> Oh look I just typoed. I must be clueless about spelling.
09:35:02 <raichoo> ReinH: Chill :)
09:35:10 <ReinH> raichoo: calmer than you are ;)
09:35:17 <raichoo> You sure :D
09:35:24 <ReinH> I think it's funny and slightly absurd.
09:35:26 <monochrom> I have already bannished him. your sarcasm is in vain. :)
09:35:34 <ReinH> monochrom: :p
09:35:47 <raichoo> ^^
09:35:55 <opensourcegeek> pavonia, thanks for that
09:35:56 * raichoo goes back to idris hacking ^^
09:36:12 <ReinH> raichoo: well I don't know how calm you are, but I'm pretty chill. :)
09:36:41 <raichoo> ReinH: Laying on the couch with a nice cup of tea, I'm chilled to the max ^^
09:36:54 <MMuse> people usually calm down on their own and don't want to admit they're worked up. so it's suboptimal to recommend chilling since it leads to this sort of ongoing thing
09:36:54 <ReinH> raichoo: I have a kitten lying in his little kitten bed on my desk.
09:37:03 <ReinH> raichoo: petting kittens is a very relaxing activity :)
09:37:03 <MMuse> ;o
09:37:47 <raichoo> ReinH: Kitten? Ok, you won. I can't compete with that ^^
09:37:49 <mm_freak_> what's the current state of the art in observable sharing?
09:37:53 <quicksilver> opensourcegeek: module Blah where ... should always be the first line (Except comments)
09:38:09 <ReinH> MMuse: true, but I don't really get riled up over this sort of thing. I just want them to stop being disruptive.
09:38:10 <prophile> speaking of talking rubbish though
09:38:11 <prophile> ReinH: is there a new haskellcast on the way, if I might ask?
09:38:24 <ReinH> prophile: recorded on Sunday, it's awesome :)
09:38:35 <ReinH> just editing now
09:39:03 <prophile> shiny
09:39:15 <ReinH> MMuse: my "ongoing thing" with raichoo was, to my mind, entirely chill as well :)
09:39:16 <ocharles> ReinH: yaaaaaay!
09:39:20 <ReinH> ocharles: yay! :D
09:39:43 <MMuse> QED
09:39:51 <ReinH> MMuse: no it isn't!
09:39:53 <ReinH> ok I'm done
09:39:53 <MMuse> :D
09:40:08 <MMuse> I'm just teasing sorry
09:40:12 <ReinH> MMuse: me too :)
09:40:40 <ReinH> ocharles: I'll go ahead and spoil the surprise. We interviewed Tekmo and Snoyman AT THE SAME TIME :D
09:40:49 <ReinH> It was a sort of Haskell Thunderdome episode.
09:40:55 <raichoo> Oh nice \o/
09:41:01 <ReinH> Where two Haskellers enter
09:41:05 <ReinH> and then have a polite conversation and leave
09:41:17 <Fuuzetsu> >polite
09:41:28 <Fuuzetsu> Haskell cast needs some spice
09:41:32 <klrr> what chunk size should i use for IRC?
09:41:34 <Fuuzetsu> you should get some troublemakers on the show
09:42:02 <pavonia> klrr: Chunk size for what?
09:42:29 <klrr> the connection socket
09:42:36 <hiptobecubic> 256 MB
09:42:46 <hiptobecubic> then you can just check it once a wekk
09:42:48 <hiptobecubic> week*
09:42:49 <klrr> (i dont know what im talking about)
09:43:04 <ReinH> sorry can't type because of kitten headbutts
09:45:44 <ReinH> Fuuzetsu: who would you suggest?
09:46:15 <MMuse> Hello esteemed Customer. We regret to inform you that your software will be delayed because : kiten hedbuts
09:48:38 <pavonia> http://spl.smugmug.com/Humor/Lambdacats/i-MHs3MKC/A
09:51:46 <Fuuzetsu> ReinH: No idea! I'm sure something could be arranged.
09:52:44 <Fuuzetsu> pavonia: I really dislike that site, it requires JavaScript to just view a bunch of images… I'm really thinking about rehosting them.
09:55:15 <t4nk479> hi, i'm making my way through mcbride's paper on Applicative. and in there he talks about how "any expression built from the Applicative combinators can be   transformed to a canonical form in which a single pure function is `applied'   to the effectful parts in depth-first order" what is meant by depth-first in this context? simply left to right?
09:55:40 <t4nk479> this is on page 4 of the "Applicative programming with effects" functional pearl
09:56:30 <quicksilver> t4nk479: I think he means that it might be depth-first in the original expression (which can have a more complex shape)
09:56:32 <pavonia> Fuuzetsu: That'd be a good idea
09:56:46 <quicksilver> t4nk479: but it can be transformed to the simpler form when, as you say, it is now merely left to right
09:56:49 <ReinH> MMuse: pretty much
09:58:27 <t4nk479> quicksilver: so depth-first in the pre-canonical form?
09:58:41 <quicksilver> t4nk479: yes.
09:59:07 <quicksilver> t4nk479: and the canonicalisation is basically a kind of reassociating, so it preserves depth first ordering into left-right ordering
09:59:10 <ReinH> the problem with papers is that they generally don't offer a lot of exercises for the reader...
09:59:25 <ReinH> Still, working some out on your own might help
09:59:41 <t4nk479> quicksilver: ah ok. yeah ReinH i'm going to be doing that
10:02:01 <t4nk479> so it's the next statement which has me somewhat confused as well (points to me needing to do more examples probably): "computa-   tions have a fixed structure, given by the pure function, and a sequence of   sub- computations, given by the effectful arguments". i don't see what he means by fixed structure. surely a monadic computation will have a fixed type too (which is what i'm interpreting as structure)
10:02:15 <SrPx> (λ(((λy.(λz.i y z))l)((λk.k)o))(((λi.v i)e)((λl.l)u))) awn
10:03:22 <opensourcegeek> Doh!! working now, thanks guys
10:04:22 <quicksilver> t4nk479: I think the point he's getting at is that any complex operation can be separated into effectful subcomputations "done first" and then a pure function applied to the results of those
10:04:41 <quicksilver> t4nk479: monadic operations can interleave and depend on each others results in a way which can't be split like that.
10:05:09 <opensourcegeek> I've hit a different problem now, when using cabal - I can use runhaskell, but `cabal build` throws Could not read symbol, "pthread_sigmask@@GLIBC_2.2.5"
10:05:18 <t4nk479> quicksilver: ah. so the fixedness of the structure is the fact that you can bubble up the pure function as it were
10:05:34 <quicksilver> t4nk479: and that the effectful parts don't inter-relate.
10:05:45 <t4nk479> quicksilver: right. thanks!
10:06:08 * t4nk479 goes back to working out some examples
10:07:18 <opensourcegeek> has anyone hit that problem before?
10:18:37 --- mode: monochrom set -b *!*@mistero.ircgate.it
10:18:42 --- mode: monochrom set -o monochrom
10:24:55 * hackagebot profiteur 0.1.0.0 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.0.0 (JasperVanDerJeugt)
10:24:55 * hackagebot profiteur 0.1.0.1 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.0.1 (JasperVanDerJeugt)
10:38:08 <marcel__> lol
10:40:24 <Heffalump> is there a simple guide somewhere to replacing record access and update with lens?
10:40:42 <Heffalump> the lens documentation just has this scary type hierarchy
10:41:18 <bernalex> Heffalump: please /msg me if you find anything relevant... I need to look at this too.
10:41:34 <Heffalump> I guess StackOverflow is the next stop :-)
10:43:26 <johnw> Heffalump: use makeClassy and ^. and .~
10:43:38 <johnw> if all you need is record update, that's mostly what you'll use
10:44:36 <cschneid> Heffalump: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
10:44:53 * hackagebot inflections 0.1.0.2 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.2 (jsl)
10:46:13 <cschneid> or this one: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing
10:46:39 <johnw> I think lens comes into its own outside of record management
10:46:47 <Heffalump> thanks
10:46:52 <johnw> namely: Maps, traversals, prisms
10:46:53 <cschneid> I agree, although accessing nested records is pretty slick all by itself
10:46:55 <Heffalump> johnw: yes, but I want to adopt it first, then do more stuff.
10:47:02 <Heffalump> i.e. refactor some existing code step by step
10:47:09 <johnw> yeah, it's neat; but pedestrian compared to the awesome factor of some of its other features
10:47:22 <johnw> Heffalump: I recommend *not* using lens for all record access
10:47:31 <cschneid> yep. The lens-aeson syntax was what forced me to figure out lensing more.
10:47:37 <johnw> use it for the records where it saves you lots of code otherwise, like deeply nested structures
10:47:43 <johnw> doing it everywhere becomes a nuisance, actually
10:49:04 <johnw> the right amount of lens leads to functions whose whole definition is just:
10:49:05 <johnw> files ^? pfFiles.at path._Just.pfiModuleStatus.to statusModuleName.folded
10:49:16 <johnw> that would have been a lot more code in the "traditional" way
10:49:21 <johnw> this is even more readable
10:54:54 * hackagebot indentation 0.1.0.0 - Indentation sensitive parsing combinators for Parsec  http://hackage.haskell.org/package/indentation-0.1.0.0 (OmerAgacan)
10:59:55 * hackagebot profiteur 0.1.1.0 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.1.0 (JasperVanDerJeugt)
11:04:00 <edwardk_> 	that simplifies to  files ^? pfFiles.ix path.pfiModuleStatus.to statusModuleName.folded    at foo._Just can always be ix foo
11:10:25 <johnw> ah, nice!
11:11:59 <Philonous> I have a package with a lot of exposed module, but most of them have {-# OPTIONS_HADDOCK hide #-}, that's enough so they won't show up in the local documentation, how do I get hackage to not display them, either?
11:12:59 <johnw> you have to not expose them
11:14:01 <Philonous> That's inconvenient.
11:14:22 <greg> ooooh tethered on train
11:14:24 <hiptobecubic> why do you want them exposed but not documented?
11:14:56 * hackagebot pontarius-xmpp 0.4.0.0 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.4.0.0 (JonKristensen)
11:17:03 <Philonous> hiptobecubic, They are "internal" modules. Most people won't be interested in them and they clutter up the documentation. But I find it extremely annoying when I have to copy-paste code from a library because it wasn't exported or - worse yet- have to modify the library because the author didn't implement a function and I can't do it because the cosntructors aren't exported.
11:17:54 <hiptobecubic> 'clutter up' the documentation? Just stick them in .internals or something
11:19:57 * hackagebot profiteur 0.1.2.0 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.2.0 (JasperVanDerJeugt)
11:20:19 <Fuuzetsu> Philonous: as pointed out, if it's exposed then it will show up. You could try using the prune Haddock option, see http://www.haskell.org/haddock/doc/html/module-attributes.html
11:20:43 <Fuuzetsu> but really, stick it in the .Internal module or something
11:21:25 <zomg> ufff, not sure how anyone can use Scotty.. 0.6.2 seems to spit random gunk to end of things served using `file` and 0.6.0 doesn't even compile on ghc 7.6.3...
11:21:34 <zomg> guess I'll try .1 then :P
11:24:55 <Eduard_Munteanu> Suppose   data TaggedList t a = TNil | TCons a (TaggedList t a)   ...  can GHC optimize retagging it without using unsafeCoerce? E.g. if I   retag TNil = TNil; retag (TCons a as) = TCons a (retag as)
11:25:16 <Eduard_Munteanu> Perhaps just a RULES?
11:25:36 <zomg> Well .1 has the same behavior. Fun times.
11:27:12 <greg> = because haskell
11:35:38 <prophile> idris can compile to java
11:35:42 <prophile> idris can compile to _JAVA_
11:36:03 <prophile> my brain is pouring out of my ears
11:36:18 <startling> prophile, what does that mean?
11:36:37 <startling> I mean: is it pouring out of your ears in a good way or a bad way?
11:36:46 <prophile> the former
11:36:48 <Heffalump> johnw: the thing is I want to replace an existing flat record with a nested one, so I see lens as a way to abstract from the data representation.
11:37:41 <startling> prophile: ah. We've had people in #idris loudly complain that cabal install idris installs some java crap, so I had to double check. :)
11:39:10 <prophile> startling: the idea of being able to do game logic for libgdx games in a functional and _dependently typed_ language is making all the blood drain out of my head
11:39:26 <zomg> Oh that's interesting, Scotty uses Wai's responseFile, I wouldn't imagine Wai to have a bug where it just sticks random stuff into the file...
11:39:36 <zomg> What the hell is causing this >_>
11:49:21 <johnw> Heffalump: it's definitely good at that
11:50:26 <prinsen> I have a tricky question. I need a Data.Map with "polymorphic keys", in this case ToJSON => Pipes.Consumer (Maybe Dynamic) IO (Maybe r), is that possible?
11:50:35 <flazz> I find myself doing (flip f "") where f :: a -> ShowS. I feel that i'm not using ShowS right, am I missing something?
11:51:30 <Cale> prinsen: The only requirement for the keys of a Map is that they be an instance of Ord
11:52:07 <prinsen> Cale: Ok, i get the error (r ~ OutputOutputGoogleSearch)
11:52:24 <prinsen> when i try to put a Consumer (..) IO (Maybe Output...)
11:52:25 <MephAtWork> flazz: Not really. ShowS exists, to make it more convenient to "add" things to the end of a string.
11:52:55 <Cale> prinsen: I doubt you have an instance of Ord for such things anyway?
11:53:24 <Cale> prinsen: What are you trying to do?
11:53:24 <flazz> MephAtWork: are there combinators that can do stuff like [ShowS] -> String?
11:54:00 <dmwit> :t undefined :: ShowS
11:54:01 <lambdabot> ShowS
11:54:14 <dmwit> I don't suppose \bot does :k!, huh?
11:54:25 <Cale> prinsen: It's also impossible to have an instance of a type class for a polytype as far as I know. (You can have polymorphic instances, but not impredicative ones)
11:54:32 <shachaf> @src ShowS
11:54:33 <lambdabot> type ShowS = String -> String
11:54:52 <dmwit> :t ($"") . foldr (.) id :: [ShowS] -> String
11:54:53 <lambdabot> [ShowS] -> String
11:55:12 <prinsen> Cale: Im dynamically composing pipes
11:55:19 <dmwit> :t mconcat :: [ShowS] -> String -> String
11:55:20 <lambdabot> [ShowS] -> String -> String
11:55:21 <MephAtWork> flazz: shachaf and dmwit seem eager to help, as well. ;)
11:55:43 <dmwit> ...although that's admittedly a very different kind of conversion than the one you're probably asking for.
11:55:48 <prinsen> Cale: I have a bunch of API:s, which have a input and output type
11:55:55 <MephAtWork> :t `mconcat`"world!"
11:55:56 <lambdabot> parse error on input ``'
11:56:01 <Cale> prinsen: Why do you want the keys of your map to be Consumers? Probably the right thing is to give your Consumers some sort of names, and key the map on those names.
11:56:03 <dmwit> :t mconcat . map Endo :: [ShowS] -> Endo String
11:56:03 <MephAtWork> :t (`mconcat`"world!")
11:56:04 <lambdabot> [ShowS] -> Endo String
11:56:04 <lambdabot> Monoid ([Char] -> t) => [[Char] -> t] -> t
11:56:21 <dmwit> :t appEndo
11:56:22 <lambdabot> Endo a -> a -> a
11:56:39 <flazz> dmwit: i think its the right conversation
11:56:41 <dmwit> :t (`appEndo`"") . mconcat . map Endo
11:56:41 <flazz> thanks
11:56:41 <lambdabot> [[Char] -> [Char]] -> [Char]
11:56:48 <prinsen> Cale: I think there is some misunderstanding, the Map is String -> Consumer
11:56:49 <Cale> prinsen: In general, you won't even be able to tell when two Consumer values are equal
11:57:02 <prinsen> Cale: The Consumer is the key
11:57:14 <Cale> What's the type of the Map?
11:57:19 <dmwit> flazz: Well, it might be the right thing by accident if you apply it to "".
11:57:31 <Cale> If it's Map String (Consumer ...), then the keys of your Map are Strings
11:57:32 <dmwit> flazz: But try applying it to "no lol" and see if you still think it's the right conversion. =)
11:57:38 <Cale> the *values* of the Map are consumers
11:58:18 <Cale> If you want to put polymorphic consumers in your Map, you'll need to construct a wrapper type, I think
11:58:18 <prinsen> Cale: ToJSON r => Map String (Consumer (Maybe Dynamic) IO (Maybe r)
11:58:29 <dmwit> > mconcat [\s -> "hello, " ++ s, \s -> "world!" ++ s] "no, lol"
11:58:30 <lambdabot>  "hello, no, lolworld!no, lol"
11:58:38 <MephAtWork> :t (`mconcat`"world!")::[ShowS] -> String
11:58:39 <lambdabot> [ShowS] -> String
11:59:30 <prinsen> Cale: Can you clearify?
11:59:37 <Cale> data Foo = Foo (forall r. ToJSON r => Consumer (Maybe Dynamic) IO (Maybe r))
11:59:47 <Cale> Then you can have  Map String Foo
12:00:15 <Cale> and it'll be possible to unpack the polymorphic field and use it at any appropriate type r
12:00:47 <prinsen> Cale: fancy!
12:00:55 <prinsen> Ill give it a try
12:00:55 <Cale> You might also be able to turn on ImpredicativeTypes, but I don't know whether that extension is in a working state or not at the moment.
12:01:24 <Cale> (that would let you just write  Map String (forall r. ToJSON r => Consumer (Maybe Dynamic) IO (Maybe r))
12:01:26 <Cale> )
12:02:12 <pavonia> Weren't impredicative types removed?
12:02:35 <Cale> cale@ender:~$ ghc --supported-languages | grep Impred
12:02:36 <Cale> ImpredicativeTypes
12:02:43 <Cale> Seems to still be listed anyway
12:02:59 <Cale> (in 7.6.3)
12:03:03 <pavonia> Hhm
12:03:04 <geekosaur> not removed
12:03:09 <shachaf> whoa, --supported-languages
12:03:16 <geekosaur> rewritten, quite often
12:03:47 <Cale> But in any case, RankNTypes should do the trick, if you define yourself a wrapper like that
12:05:02 * hackagebot cabal-bounds 0.1.11 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.11 (DanielTrstenjak)
12:10:03 * hackagebot cabal-bounds 0.1.12 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.12 (DanielTrstenjak)
12:19:34 <prinsen> Cale: Expected type: Pipes.Core.Consumer
12:19:34 <prinsen>                      (Maybe Data.Dynamic.Dynamic) IO (Maybe r)
12:19:34 <prinsen>       Actual type: Pipes.Core.Consumer
12:19:34 <prinsen>                      (Maybe Data.Dynamic.Dynamic) IO (Maybe OutputOutputGoogleSearch)
12:19:37 <prinsen>     In the first argument of `Data.Pipe.JSON.JSONConsumer'
12:19:53 <prinsen> Cale: were JSONConsumer is the datatype you described before
12:19:54 <haasn> Can somebody link me to a good resource on what impredicative types are, why the extension was so unpopular, what problems it may have posed and what the currently preferred method, if any exists, of mimicking its functionality is?
12:21:00 <prinsen> Cale: Could not deduce (r ~ OutputOutputGoogleSearch)
12:21:16 <bennofs> haasn: I think it makes type inference worse and the recommended "workaround" is just defining a new data type
12:21:23 <carter> Cale: you can get impredicativity with a newtype
12:21:42 <haasn> bennofs: fair enough, I wonder what some concrete examples of problematic situations would look like though
12:21:43 <carter> haasn: becaues its to darn hard and SPJ hasn't had the time
12:21:50 <carter> and its hard
12:22:31 <carter> haasn: https://ghc.haskell.org/trac/ghc/ticket/8808#comment:1 for something this past week by spj
12:22:44 <Cale> prinsen: You supplied an argument which was monomorphic
12:23:54 <Cale> prinsen: you said you wanted it to be polymorphic, so that's what I gave you, but if you don't, then you could always just write OutputOutputGoogleSearch there
12:24:47 <Cale> (or maybe you actually wanted an existential type?)
12:25:05 * hackagebot pontarius-xmpp 0.4.0.1 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.4.0.1 (JonKristensen)
12:25:17 <prinsen> Cale: There is about 1000 different consumers, all with different OutputType
12:25:33 <prinsen> But all the output types implements ToJSOn
12:26:31 <prinsen> so either I make the consumer convert it to JSON and instead be Consumer (..) IO (Maybe Value)
12:26:41 <Cale> Okay, then try  data JSONConsumer = forall r. ToJSON r => JSONConsumer (Consumer (Maybe Dynamic) IO (Maybe r))
12:26:42 <haasn> carter: thanks, that pretty much replaces what I was looking for
12:26:50 <haasn> I wonder: “ However the internal intermediate language, Core, is fully impredicative and always has been. No difficulties there.” is this because core has explicit type applications?
12:26:57 <carter> yes
12:27:00 <carter> Core is fully explcit
12:27:03 <Cale> prinsen: Or that
12:27:10 <Cale> prinsen: That's probably more sensible, really :)
12:27:21 <prinsen> Cale: Yes might be :)
12:27:50 <Cale> prinsen: If all you know about a type is that it's an instance of ToJSON, then that type might as well be Value
12:28:13 <prinsen> Cale: Might be more added later tough
12:29:00 <johnw> Cale: that's a good point, since converting to Value is pretty much the only thing you can do with it
12:29:49 <Cale> right
12:35:07 <haasn> “GHC can also generate C code as an intermediate target for porting to new platforms.” Should this be removed from the front page description?
12:35:36 <bennofs> haasn: why? It can still be used for porting to new platforms, can't it?
12:35:50 <haasn> I thought the C target was removed altogether in a not-too-recent version of GHC?
12:36:05 <carter> haasn: nah, its supported
12:36:09 <haasn> But I guess you can use old versions, then iteratively compile from there
12:36:11 <haasn> ah, okay
12:36:11 <carter> haasn: i thought  so too
12:36:15 <carter> its actually there
12:36:23 <carter> its actually used for every unregisterirzed platform
12:36:24 <carter> i know
12:36:32 <carter> i broke ith this fall and then got some people sad
12:36:37 <carter> got fixed shortly after
12:36:45 <haasn> interesting
12:36:45 <quicksilver> haasn: the optimised C target was removed.
12:36:56 <quicksilver> haasn: the 'unregisterised' C target remainds for bootstrapping
12:37:07 <haasn> ah, okay
12:37:09 <carter> quicksilver: no, its also used for building period
12:37:09 <haasn> thanks for clearing that up
12:37:15 <carter> on those unregisterized platforms
12:37:23 <carter> quicksilver: what "optimized one"
12:37:43 <carter> its -fvia-c
12:37:44 <carter> thats always been there
12:38:02 <carter> link?
12:38:26 <quicksilver> carter: yes, indeed, good point
12:38:45 <carter> (this is something I should know...)
12:38:48 <quicksilver> carter: the registerised via-C
12:38:55 <carter> what does that mean?
12:39:38 <carter> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021794.html
12:39:38 <carter> k
12:40:08 <MMuse> completely unrelated but how feasible is it to write a 3d game in haskell? I guess one could model game state as a function of input events and timestep events, and define some IO thingy that takes a game state and produces a list of opengl calls? or something
12:40:54 <milfjord> wasn't there like a quake in haskell?
12:41:05 <milfjord> so ... 100% feasible
12:41:51 <MMuse> I heard there was such a thing but idk whether it was nice, smooth, efficient etc. or a hacky mess
12:41:55 <Ralith> there was; it was slow and glitchy
12:44:09 <quicksilver> carter: I thought they'd removed the registereised port rather than let it bit-rot
12:44:17 <quicksilver> it takes work to keep updating it for new GCC versions
12:44:21 <quicksilver> and keeping the evil mangler working
12:44:24 <quicksilver> maybe I'm wrong.
12:44:30 <prinsen> Cale: Thats the consumer end of the pipe working :) Is there any way of doing the same with the Producer part, but with FromJSON?
12:45:03 <prinsen> Cale: give me a sec to formulate a better question :)
12:45:28 <carter> quicksilver: i think your'e righ
12:50:08 * hackagebot bytestring-from 0.1.1 - A type-class to convert values from ByteString.  http://hackage.haskell.org/package/bytestring-from-0.1.1 (ToralfWittner)
12:50:52 <prinsen> Cale: (or anyone else interested) Could you have the "producer" to be a FromJSON r => Pipe (r) (Maybe Dynamic) IO (...), and then compose it with an arbitrary producer doing a yield $ decode text?
13:14:30 <ijp> what's the current thinking on let-polymorphism: yay or nay?
13:16:15 <benmachine> ijp: I have a vague recollection that MonoLocalBinds fell out of favour
13:16:18 <benmachine> but don't hold me to that
13:24:13 <absence> is there a library function for combining two and two elements of a list?
13:24:29 <milfjord> u wot m8
13:24:38 <simpson> absence: Could you show an example?
13:25:07 <absence> [1, 2, 3, 4] -> [1 `f` 2, 3 `f` 4]
13:25:30 <milfjord> chunksOf 2
13:25:34 <joelteon> what about [1,2,3]?
13:28:49 <absence> milfjord: followed by map fold or something? chunksOf gives me [[1,2],[3,4]]
13:28:57 <absence> joelteon: won't occur
13:29:56 <milfjord> map (\[x, y] -> f x y)
13:31:05 <absence> mm, a bit clunky but it will do. thanks!
13:32:30 <skypers> hey, I’m listening to a song
13:32:36 <skypers> and the singer says “thar”
13:32:40 <skypers> what does that mean?
13:32:47 <skypers> (remember
13:32:51 <skypers> I’m French)
13:32:54 <koala_man> as in "thar she blows?"
13:32:57 <skypers> ahah
13:32:58 <skypers> yes
13:33:04 <ijp> thar=there
13:33:08 <skypers> oh
13:33:16 <skypers> is it slang?
13:33:16 <joelteon> absence: why are you using a list for this?
13:33:21 <startling> skypers: it's a cliched accent thing
13:33:27 <joelteon> if you had [(a,b)] you could use map (uncurry f)
13:33:35 <njcomsec> that's how irish people say "there"
13:33:35 <joelteon> or rather, why are you using a flat list for it
13:33:38 <joelteon> instead of a list of 2-tuples
13:33:42 <skypers> I see
13:33:42 <levi> It sounds like pseudo-"pirate talk"
13:33:44 <startling> skypers: http://en.wiktionary.org/wiki/there_she_blows
13:33:49 <skypers> it’s quite nice
13:33:58 <ijp> skypers: stereotyped whaler / pirate / west country accent
13:34:27 <skypers> ok, thank you :)
13:35:06 <skypers> http://www.youtube.com/watch?v=lmDGSwggq98
13:35:14 <skypers> (careful tho, not really sfw :D)
13:36:43 <joneshf-laptop> so i've got a: function with type `InputT (StateT mT IO) ()` and i want to call a few functions with return types `IO (Either a b)`. Is it possible to use the `Either` monad's do notation to clean up the cruft of checking forLefts and Rights?
13:36:51 <joneshf-laptop> without putting the EitherT into the stack?
13:38:33 <benmachine> joneshf-laptop: you don't have to have only one stack
13:38:47 <benmachine> joneshf-laptop: you can adopt EitherT when it suits you and then cruelly cast it aside
13:39:04 <joneshf-laptop> hmm?
13:39:15 <levi> You can temporarily wrap your stack in EitherT, running the possibly-failing actions and then unwrapping.
13:39:18 <NemesisD> *leans in*
13:39:23 <NemesisD> this is relevant to my interest
13:39:42 <joneshf-laptop> mid-function call?
13:39:49 <benmachine> this is Haskell
13:39:53 <benmachine> everything is mid-function call :P
13:39:57 <joneshf-laptop> heh
13:40:02 <levi> I was about to type that.
13:40:07 <levi> <- too slow.
13:40:21 <benmachine> joneshf-laptop: maybe try putting something on lpaste.net and we'll see what we can do for it
13:41:24 <levi> I've found the errors package (http://hackage.haskell.org/package/errors) handy as a collection of helpers for using monads to deal with errors.
13:42:24 <absence> joelteon: good question. i'm parsing a binary file and get a bunch of bytes, but i should rearrange into pairs! thanks for the tip
13:46:25 <joneshf-laptop> benmachine, i appreciate that, i might take you up on it in a bit (once i get stuck), for now i'd prefer to try and implement it first
13:47:14 <benmachine> joneshf-laptop: that works too :)
13:48:19 <greg``> im trying to use cabal sandbox , but when i do a cabal install it
13:48:19 <greg``> 	 says i need to force reinstalls looks like my .cabal folder is still
13:48:19 <greg``> 	 full of junk ,
13:48:31 <greg``> anyone know why ?
13:48:33 <joneshf-laptop> wait, there's no EitherT in mtl or transformers?
13:48:54 <jroesch_> greg``: what steps did you take? sandbox init; install
13:48:57 <jroesch_> ?
13:49:07 <greg``> yeah i did a sandbox init
13:49:20 <greg``> then from the project i did a cabal install
13:49:41 <greg``> i did a cabal install cabal-install first
13:49:50 <greg``> so i still have 1.1.16 installed
13:50:13 <greg``> do i need to clear it out first , i thought sandbox init should give me a clean slate
13:50:31 <jroesch_> the cabal-install version must be running as 1.1.18 or it will ignore the sandbox
13:50:50 <joneshf-laptop> greg``, you are probably calling the original cabal
13:50:53 <monochrom> 1.18, not 1.1.18 :)
13:51:08 <monochrom> enter "cabal --version" and play with PATH
13:51:09 <joneshf-laptop> greg``, what does `which cabal` say?
13:54:11 <greg``> 1.18.1.2
13:56:56 <flazz> i have a type family via a type class C with a dependent type D, i can make functions that operation on C a => a -> ..., but how can I express a's D in a type sig? apologies for butchering the terminology
13:57:38 <greg``> is there a way i can find out which folder my cabal is looking in for libraries?
13:58:09 <startling> greg``: it looks in a lot of places for libraries
13:58:20 <sellout-> flazz: Do you mean a type D that is an instance of C?
13:58:26 <startling> greg``: what issues are you having?
13:58:54 <startling> greg``: cabal sandbox init pulls in a handful of system libraries needed by ghc
13:59:02 <sellout-> flazz: You just want D -> …, unless I’m misunderstanding you.
13:59:41 <sellout-> flazz: someFun :: D -> Bool (or whatever)
13:59:44 <greg``> i run cabal install  after running cabal sandbox init
14:00:10 <greg``> and i see that warnings saying that lots of my cabal 1.16 packages will be broken
14:00:22 <greg``> which i didnt expect after init'ing a sandbox
14:00:45 <greg``> i can force reinstall but it isnt the clean slate i was hoping for
14:02:49 <startling> greg``, what does cabal sandbox hc-pkg list say?
14:03:22 <startling> what do you mean "my cabal 1.16 packages"? Things you had previously installed with cabal?
14:04:01 <flazz> sellout-: class C a where { type D :: * }
14:04:14 <greg``> /var/lib/ghc/package.conf.d
14:04:14 <greg``>    Cabal-1.16.0
14:04:14 <greg``>    array-0.4.0.1
14:04:14 <greg``>    base-4.6.0.1
14:04:17 <greg``>    bin-package-db-0.0.0.0
14:04:20 <greg``>    binary-0.5.1.1
14:04:23 <startling> greg``: please don't paste the whole thing here
14:04:23 <greg``>    bytestring-0.10.0.2
14:04:24 <sellout-> flazz: Ah, sorry :D
14:04:26 <greg``>    containers-0.5.0.0
14:04:30 <greg``>    deepseq-1.3.0.1
14:04:33 <greg``>    directory-1.2.0.1
14:04:36 <greg``>    filepath-1.3.0.1
14:04:41 <greg``>    ghc-7.6.3
14:04:44 <greg``>    ghc-prim-0.3.0.0
14:04:44 <greg``>    haskell2010-1.1.1.0
14:04:47 <greg``>    haskell98-2.0.0.2
14:04:47 <startling> sigh.
14:04:50 <greg``>    hoopl-3.9.0.0
14:04:53 <greg``>    hpc-0.6.0.0
14:04:56 <greg``>    integer-gmp-0.5.0.0
14:05:00 <greg``>    old-locale-1.0.0.5
14:05:03 <greg``>    old-time-1.1.0.1
14:05:06 <greg``>    pretty-1.1.1.0
14:05:09 <greg``>    process-1.1.0.2
14:05:12 <greg``>    rts-1.0
14:05:15 <hpc> stiiill pasting
14:05:16 <greg``>    template-haskell-2.8.0.0
14:05:17 <greg``>    time-1.4.0.1
14:05:20 <c_wraith> sometimes, I wish clients didn't all have flood protection via rate limiting
14:05:20 <greg``>    unix-2.6.0.1
14:05:26 <greg``> sorry hpaste?
14:05:34 <hpc> yes, hpaste
14:05:43 <startling> lpaste now.
14:05:44 <c_wraith> I'd prefer if they had flood protection via saying "no, that's too many lines, find some other way to say it"
14:05:51 <hpc> c_wraith: i wish clients would rate limit in real-time
14:06:06 <hpc> you might want to do a huge paste in PM, for instance
14:06:21 <hpc> but you should be able to see it happen and say "damn, this is taking too long" and stop it
14:06:23 <ReinH> c_wraith: irssi does that :)
14:06:24 <startling> Do those all come with GHC?
14:06:26 <hpc> or "whoops, wrong channel" and stop it
14:06:34 <greg``> http://pastebin.com/fbnxGWzC
14:06:37 <hpc> ReinH: irssi only asks, and then you can continue the paste anyway
14:06:44 <ReinH> hpc: but at least it does that
14:06:54 <hpc> but you always just say yes
14:06:56 <uvelichitel> It looks nice, cleare, simple. API was changed twice for last week. Any futher plans?
14:06:58 <ReinH> "Press ctrl-k if you really want to annoy people"
14:06:58 <hpc> it doesn't stop accidental pastes
14:07:03 <startling> we could just pipe things into irc
14:07:05 <hpc> er, it only stops accidental pastes
14:07:11 <ReinH> hpc: true
14:07:17 <hiptobecubic> weechat asks first, then slow-pastes
14:07:22 <c_wraith> hpc: yeah, that'd be a nice feature.
14:07:30 <startling> greg``: perhaps some of those are system packages?
14:07:42 <greg``> startling: meaning?
14:07:42 <hpc> hiptobecubic: and you can see it happen live, and you can abort a big paste?
14:07:58 <startling> greg``, installed with apt or whatever
14:08:12 <startling> most of it looks pretty standard but I'm not sure about pretty and hoopl
14:08:14 <hiptobecubic> hpc, No unfortunately.
14:08:45 <greg``> ah yes i think thats possbile,
14:09:01 <greg``> is that why it still appears although ive switched to cabal 1.18
14:09:49 <startling> greg``: possibly.
14:09:52 <greg``> i suppose even a force reinstall wont fix it
14:09:59 <greg``> ok , ill clean up
14:10:03 <startling> I don't ever install things system-wide, so I don't know. Maybe someone else does.
14:10:04 <greg``> sorry about the paste again
14:10:17 * hackagebot JuicyPixels 3.1.4 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.4 (VincentBerthoux)
14:10:20 <startling> greg``: the nice thing about using apt or whatever is that they generally provide a way to uninstall
14:11:04 <monochrom> startling: did you know: debian packages for haskell libs do not perform the safety check that "ghc-pkg register" does
14:11:17 <startling> monochrom: what's that?
14:12:20 <monochrom> "ghc-pkg register" checks for pre-existing before registering
14:12:56 <startling> heh
14:13:12 <monochrom> debian packages do not call "ghc-pkg register". they modify the database directly
14:13:39 <greg``> how did you install ghc?
14:13:48 <greg``> from src?
14:14:04 <monochrom> I use the binaries from GHC's website
14:14:28 <greg``> hmmmm
14:14:29 <startling> > let 0 = 2 in 0 -- why isn't this a syntax error?
14:14:30 <lambdabot>  0
14:14:39 <startling> or any kind of error
14:14:43 <greg``> i think i might need to nuke my haskell installation
14:14:45 <monochrom> why should it be a syntax error?
14:15:08 <startling> when does it make sense for a numeric literal to be alone on a RHS?
14:15:08 <greg``> startling because of scope?
14:15:29 <hiptobecubic> LHS?
14:15:45 <startling> er, LHS, yeah.
14:15:50 <greg``> because there are no literals only symbols
14:15:50 <monochrom> the rule "let <pattern> = <expression in ..." (plus type-checking) is simple and elegant. any exception inflicted upon it is a road to PHP
14:16:08 <hpc> what's the semantics of it though?
14:16:17 <joneshf-laptop> ugh, this is getting real ugly with `ErrorT`
14:16:17 <monochrom> every numeric literal is a valid pattern. unless you don't want to allow "f 0 = True"
14:17:12 <startling> > let True = 10 in True
14:17:13 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
14:17:13 <joneshf-laptop> there's got to be some way to express: "Hey i'm like twelve levels deep in this transformer stack, but just run this one thing in some other monad that isn't part of the stack, and then lift it to the top"
14:17:13 <lambdabot>    arising from the literal `10'
14:17:13 <lambdabot>  Possible fix:
14:17:13 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
14:17:25 <startling> > let True = False in True
14:17:25 <lambdabot>  True
14:17:31 <startling> :/
14:17:33 <monochrom> the semantics is "v = case <expression> of ~<pattern> -> ..." for each variable v appearing in <pattern>
14:18:06 <startling> joneshf-laptop: "lift it to the top"?
14:18:08 <monochrom> the irrefutable non-strict ~ is deliberate. "let" is non-strict pattern matching
14:19:10 <greg``> so i take it you guys downloaded ghc and not haskell platform
14:19:13 <benmachine> I sometimes think there should be a GHC warning for lazy patterns that do not bind anything
14:19:18 <benmachine> but it's hard to imagine you'd ever trip it
14:19:35 <greg``> lazy patterns ?
14:19:37 <benmachine> by "lazy pattern" I mean "irrefutable pattern" I think
14:19:56 <greg``> i still dont understand perhaps an example
14:20:07 <monochrom> I can talk "lazy" too, iff everyone agrees that the opposite is "eager" not "strict"
14:20:13 <hpc> it could be lumped under -fwarn-unused-matches
14:20:18 * hackagebot JuicyPixels 3.1.4.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.4.1 (VincentBerthoux)
14:20:38 <monochrom> if you say "strict" then I refuse to say "lazy". it's strict vs non-strict. it's never black vs sweet.
14:21:33 <monochrom> "Control.Monad.State.Strict" and "Control.Monad.State.Lazy" is totally wrong. make up your mind.
14:22:07 <monochrom> and every time I point out this flaw, people mansplain it to me
14:22:08 <hpc> Control.Monad.State.NonLazy
14:22:29 <conal> it's unfortunate that haskell is often described as a lazy language.
14:22:43 <hpc> yeah, it's just the programmers that are lazy
14:22:52 <monochrom> well, so far, implementations have been highly lazy
14:23:18 <hc> do the haskell specs allow a completely non-nonstrict implementation?
14:23:33 <conal> monochrom: and highly eager as well, once strictness analysis has been done.
14:23:39 <monochrom> no, it prescribes non-strictness
14:23:50 <monochrom> yes
14:23:57 <joneshf-laptop> startling, i have `InputT (StateT m IO) ()` function, want to call `IO (Either a b)` and have the `Either a b` available (because i need to use it later in the stack) without resorting to the cruft of another transformer
14:24:06 <joneshf-laptop> benmachine, it does work, so thanks for that idea!
14:24:18 <joneshf-laptop> just feels like i'm doing the wrong thing
14:24:28 <startling> :t liftIO -- joneshf-laptop
14:24:28 <lambdabot> MonadIO m => IO a -> m a
14:24:30 <monochrom> well, how about this: so far, implementations have been observationally equivalent to highly lazy, even when you also observe time spent, memeory spent, etc
14:24:56 <monochrom> time spent, memory spent, and CPU cycles spent, and cores used.
14:25:05 <conal> laziness and eagerness are both sequential strategies, in that they both answer the same sequentiality-assuming question: what one step of evaluation do we do next.
14:25:56 <conal> whereas much of the motivation of pure functional programming historically has been massively parallel evaluation
14:27:48 <monochrom> I suppose an exception that says "an irrefutable pattern must contain at least one variable" is not really a bad amendment, and the slippery-slope argument doesn't quite apply.
14:28:24 <monochrom> well, that doesn't solve "let (x,True) = (False,False)", does it? :)
14:29:19 <benmachine> monochrom: clearly we need -fsolve-problems
14:29:37 <benmachine> not -fwarn-problems
14:29:41 <benmachine> it actually edits your source file
14:30:08 <monochrom> darn, I guess it does, it's merely "case (False,False) of ~(x,True)" not "case (False,False) of ~(x, ~True)".
14:30:19 * hackagebot FontyFruity 0.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.1 (VincentBerthoux)
14:31:55 <c_wraith> benmachine: remember the stories of the GHC version that solved your type errors by deleting your source files?
14:32:06 <monochrom> well, that is a runtime error, not a compile-time error. so the problem is only half-solved.
14:32:09 <benmachine> :P yes
14:33:07 <monochrom> so I bet that the exact same consideration was already done in the haskell committee, concluding with "doesn't completely eliminate the problem anyway, let's not bother"
14:33:27 <joneshf-laptop> startling, sure, that part i've got, it was more the "use some other arbitrary monad over here without putting it into the stack"-part
14:33:42 <startling> joneshf-laptop, there's a lot of MonadX typeclasses
14:33:51 <startling> joneshf-laptop: e.g. MonadReader, MonadState
14:34:06 <benmachine> monochrom: that sounds like a fair conclusion in principle, although I don't think compiler warnings are the domain of the haskell committee
14:34:46 <benmachine> it's much easier to have a why-not approach to warnings
14:35:20 * hackagebot FontyFruity 0.1.0.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.1.0.1 (VincentBerthoux)
14:35:22 * hackagebot wai-routing 0.3.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.3.1 (ToralfWittner)
14:37:49 <joneshf-laptop> startling, i don't follow
14:38:01 <startling> :t ask
14:38:01 <lambdabot> MonadReader r m => m r
14:38:27 <startling> :t ask :: StateT a (Reader r) r
14:38:27 <lambdabot> StateT a (Reader r) r
14:38:37 <startling> :t ask :: WriterT w (StateT a (Reader r)) r
14:38:37 <lambdabot>     No instance for (Monoid w1) arising from a use of `ask'
14:38:38 <lambdabot>     Possible fix:
14:38:38 <lambdabot>       add (Monoid w1) to the context of
14:38:47 <startling> :t ask :: Monoid w => WriterT w (StateT a (Reader r)) r
14:38:48 <lambdabot> Monoid w => WriterT w (StateT a (Reader r)) r
14:38:55 <startling> and so on
14:39:13 <levi> startling: Are you asking about those or trying to point them out to joneshf-laptop, or what?
14:39:46 <startling> I'm illustrating it to joneshf-laptop.
14:39:59 <joneshf-laptop> startling, sorry, i'm still not following what you're trying to suggest
14:40:04 <MephAtWork> levi: Does you use of "trying" imply that he isn't succeeding? ;)
14:40:41 <startling> joneshf-laptop: I guess I should ask what your concrete question is.
14:41:09 <joneshf-laptop> heh
14:41:29 <newsham> got a haskell-mode question.  I installed haskell mode from git (13.x), and put the eval-after-load command to bind c-c c-c, but for some reason c-c c-c still isnt bound.
14:41:45 <newsham> i'm not much of an emacs user.
14:41:47 <levi> joneshf-laptop: The point is that they all wrap actions on a specific monad in your stack so that you don't have to recall the precise number of lifts you need for those actions.
14:41:59 <newsham> anyone know whats wrong?
14:42:27 <joneshf-laptop> levi, oh, yeah that was what benmachine suggested
14:42:29 <joneshf-laptop> andthat works
14:43:08 <joneshf-laptop> i guess what im asking is, why isn't it possible to just use one monad's bind inside another monad
14:43:53 <levi> You can, you just have to arrange for the correct unwrapping/wrapping.
14:44:03 <levi> Which is what 'lift' and friends do.
14:44:18 <joneshf-laptop> well sure, i mean without that implicit wrapper
14:44:28 <joneshf-laptop> explicit*
14:44:37 <merijn> joneshf-laptop: Because it's undesirable to make GHC "guess" what you wanted
14:44:45 <levi> Well, because although a do expression looks like a bunch of sequential statements, it's really not.
14:44:58 <merijn> joneshf-laptop: Suppose I have multiple layers of nested monad, I don't want GHC to guess and pick an arbitrary one
14:45:10 <monochrom> is it really meaningful to begin with?
14:45:21 <merijn> monochrom: Probably not
14:45:22 * MephAtWork does not tell GHC how to roll dice.
14:45:37 <newsham> joneshf: different classes have different needs.  you cant use the same "add" function for floats and for ints, either.
14:45:43 <newsham> or for 32-bit ints and 64-bit ints
14:45:55 <monochrom> I may be convinced that 10 special cases can be given their special meanings. but you're talking across-the-board, every pair of monads.
14:46:05 <levi> joneshf-laptop: It's really a composition of a bunch of 'action arrows', and they only fit together if they're from the same Monad.
14:47:10 * MephAtWork would say "when" vice "if," but he Smells what levi is Stepping In.
14:51:49 <soy>        )\
14:51:49 <soy>       (_/
14:51:49 <soy>  .-#-|  |-#-.
14:51:49 <soy>    __|__|_.#'
14:51:49 <soy>  .'  |  |   .
14:51:50 <soy>  '#--|  |-#'
14:51:50 <soy> xemu_|__|
14:52:41 <simpson> soy: Wrong channel.
14:53:18 <soy> ah, Shit, Yeaj
14:54:06 <hiptobecubic> :D
14:54:30 <Eduard_Munteanu> Doesn't seem to be the wrong channel.
14:55:30 <soy> I'll be honest, I've got bugger all idea what this channel is about, I was given the information by a friend
14:55:33 <joneshf-laptop> whati mean is, something like this: http://lpaste.net/100392 seems like it "should" work
14:55:48 <joneshf-laptop> and i'm not sure why it can't work
14:56:12 <Eduard_Munteanu> joneshf-laptop: Just isn't a type constructor
14:56:17 <monochrom> f looks ok
14:56:19 <Eduard_Munteanu> @src Maybe
14:56:20 <lambdabot> data Maybe a = Nothing | Just a
14:56:36 <monochrom> yeah "Just Int" is not a type. "Maybe Int".
14:56:44 <joneshf-laptop> Eduard_Munteanu, whoops, you know what i meant ;)
14:56:48 <monochrom> "Just Int Bieber"
14:57:07 <joneshf-laptop> actually, that example type chcecks, so maybe my specific case has soemthing elese going on
14:57:17 <Eduard_Munteanu> monochrom: you can actually make it "Just In" given Mu. :)
14:57:18 <joneshf-laptop> i dunno, i think i just have to deal with it
14:57:23 <monochrom> yikes
14:57:40 <Eduard_Munteanu> joneshf-laptop: perhaps you have DataKinds on
14:57:51 <Eduard_Munteanu> Actually that wouldn't work.
14:58:34 <Eduard_Munteanu> (Maybe isn't a kind with inhabited types.)
15:01:53 <joneshf-laptop> Eduard_Munteanu, what wouldn't work?
15:02:23 <Eduard_Munteanu> joneshf-laptop: passing the typechecker with Just in there
15:03:01 <joneshf-laptop> Eduard_Munteanu, i dunno, it made a binary
15:03:31 <Eduard_Munteanu> Perhaps you defined a type synonym Just.
15:03:50 <Eduard_Munteanu> Or maybe we're talking about different things. :)
15:06:27 <joneshf-laptop> okay that's really weird
15:06:58 <joneshf-laptop> it compiles on mymachine, but fpcomplete wont have it
15:07:08 <Eduard_Munteanu> joneshf-laptop: how do you compile it?
15:07:37 <joneshf-laptop> ghc foo.hs
15:08:00 <Eduard_Munteanu> joneshf-laptop: do 'less foo.hs' and check the contents
15:08:25 <joneshf-laptop> it looks the same to me
15:09:03 <cmears> The fpcomplete website says: "If you're not logged in as School and are seeing this, somethings broken. This is the Schools private repository."
15:09:07 <cmears> So I guess something is broken (:
15:09:20 <startling> cmears: uh-oh
15:09:40 <johnw> cmears: can you please file a bug, or e-mail the steps to reproduce to me?  johnw@fpcomplete.com
15:09:53 <cmears> Sure
15:10:03 <cmears> But the step to reproduce is just "go to https://www.fpcomplete.com/school"
15:10:14 <cmears> (without being logged in)
15:11:21 <johnw> cool, thanks
15:11:31 <joneshf-laptop> Eduard_Munteanu, fwiw: https://www.fpcomplete.com/user/joneshf/autocloned/no-title
15:12:01 <cmears> johnw, I sumbitted a bug report too
15:12:05 <Eduard_Munteanu> joneshf-laptop: I get a "Not Found" page
15:12:37 <joneshf-laptop> oh, how do i make that public,hmm...
15:12:41 <johnw> cmears: awesome, thanks
15:12:50 <Eduard_Munteanu> joneshf-laptop: just pastebin it on lpaste
15:12:56 <Eduard_Munteanu> @where lpaste
15:12:56 <lambdabot> http://lpaste.net/new/haskell
15:13:53 <joneshf-laptop> http://lpaste.net/100392
15:14:21 <Eduard_Munteanu> joneshf-laptop: well, that looks fine, no more Just in the type
15:15:36 <joneshf-laptop> hmm, seems like it was something with ghc
15:15:57 <Eduard_Munteanu> Er, what do you mean?
15:15:58 <joneshf-laptop> as 7.8 on fpcomplete seems to compile it fine
15:16:06 <joneshf-laptop> and my 7.6 does it also
15:18:37 <benzrf> wtf is this error:
15:18:38 <benzrf>     Couldn't match expected type `ParsecT s0 u0 m0 LispVal'
15:18:40 <benzrf>                 with actual type `parsec-3.1.2:Text.Parsec.Prim.ParsecT
15:18:47 <benzrf> what the hell kind of type is that?!
15:18:52 <benzrf> package prefixes?
15:18:59 <Eduard_Munteanu> benzrf: yes
15:19:03 <monochrom> you have too many parsecs
15:19:05 <cmears> Is it possible you have two versions of parsec installed?
15:19:27 <benzrf> .......yes
15:19:29 <Eduard_Munteanu> More likely they're two different Parsec modules.
15:19:40 <benzrf> oh god i am not good with cabal pls to halp
15:19:40 <cmears> For me that sort of error message usually means "time to use a sandbox"
15:19:41 <Eduard_Munteanu> Like Text vs Bytestring.
15:19:58 <merijn> benzrf: You have a library that's wanting one version of parsec and your code is trying to use a different version
15:20:03 <benzrf> how do i do a sandbox?
15:20:13 <Eduard_Munteanu> benzrf: what imports do you have?
15:20:22 <benzrf> erm
15:20:23 <benzrf> some
15:20:30 <monochrom> Eduard_Munteanu, it is really too many parsecs.
15:20:36 <benzrf> text.parsec{,.numbers}
15:20:37 <merijn> Eduard_Munteanu: No, package prefix usually implies using multiple packages
15:20:54 <benzrf> im doing global installs <_<
15:20:58 <benzrf> pls forgive my soul
15:21:00 <merijn> benzrf: You can try just unregistering (using "ghc-pkg unregister") all but one parsec
15:21:08 <benzrf> :|
15:21:33 <monochrom> global is fine. multiple is not.
15:21:48 <Eduard_Munteanu> Hm, maybe... I had that happening with (atto)parsec, though I can only remember the package qualifier appearing when I defined a type with the same name myself.
15:22:08 <benzrf> gluh
15:22:17 <benzrf> is there a way to wipe all packages forever and start over
15:22:18 <benzrf> <_<
15:22:24 <merijn> benzrf: Yes
15:22:28 <benzrf> how o-o
15:22:35 <merijn> benzrf: Which OS?
15:22:39 <monochrom> yes, read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
15:22:51 <monochrom> in fact, read the whole thing
15:23:03 <SKImask> @pl \f v -> fmap (const v) p
15:23:03 <lambdabot> const (flip fmap p . const)
15:23:13 <merijn> monochrom: Do you have access to update that page?
15:23:19 <benzrf> merijn: loonix
15:23:22 <benzrf> ubuntu tpb
15:23:22 <monochrom> yes, what needs updated?
15:24:01 <merijn> monochrom: Maybe add a note that the binary install of Haskell Platform on OSX uses ~/Library/Haskell/ghc-version as path
15:25:33 <merijn> I believe homebrew/macports just leave it under ~/.ghc/arch-ghcversion, but the binary platform tries to follow the OS layout
15:26:02 <merijn> benzrf: In that case just follow monochrom's link and nuke ~/.ghc/whatever-ghcversion
15:26:02 <geekosaur> macports also leaves it in the normal place, it's just the haskell.org/platform installer that uses that path
15:26:35 <benzrf> i have global installs
15:26:35 <merijn> geekosaur: That's what I figured, but that's probably useful as a footnote
15:26:35 <benzrf> <_<
15:27:08 <geekosaur> benzrf, normally the bootlibs (come with compiler) and platform are global and should not be upgraded nor should you be doing global package installs
15:27:21 <geekosaur> if you did, well, you get to wipe and reinstall your whole ghc setup
15:27:23 <monochrom> for global, replacing GHC is enough to reset global packages
15:27:27 * benzrf weeps
15:27:45 <benzrf> so like
15:27:48 <benzrf> remove/install ghc?
15:27:56 <monochrom> yes
15:28:18 <monochrom> if you want the whole haskell platform, replace the whole haskell platform
15:28:18 <geekosaur> note, package sinstalled via apt-get also become global --- but uyou must choose: either install ghc+platform that way and everything else via cabal instead of apt-get, or use apt-get for everything
15:28:50 <benzrf> >that feel
15:28:52 <geekosaur> anything else will get you in trouble. (this is not haskell specifc even, the same rules apply to python, perl, and ruby for example. not so much for c/c++ but they have their own ugly hacks to deal with it
15:29:08 <geekosaur> (pkgconfig, I'm looking at you)
15:29:27 <monochrom> yes, see the end of my article for safe use of apt-get
15:30:27 * hackagebot control-event 1.2.1.1 - Event scheduling system.  http://hackage.haskell.org/package/control-event-1.2.1.1 (ThomasDuBuisson)
15:31:04 <Benjamin__> Hi guys, I was wondering if anyone in this chat room might be able to help me with a haskell problem i'm having. I think i'm having trouble rewiring my brain to stop thinking about objects :)
15:31:25 <geekosaur> it helps to ask the actual question :)
15:31:29 <njcomsec> Have you tried meditation?
15:31:41 <Benjamin__> i asked a question on stack overflow about it but it just generated a couple of not-very helpful comments
15:31:52 <Benjamin__> haha, i'm getting to it ;)
15:31:55 <monochrom> it is too bad you have to rewire. I only needed to create a virtual machine inside my head.
15:32:00 <bennofs> How do people usually determine lower bounds for packages? Just try to build with each major version? But that could take ages. Or do I just put a lower version bound on whatever is latest?
15:32:38 <Benjamin__> So i'm trying to implement an event-sourced domain model and I'm having trouble with the logic that determines which event-stream a given event should be written to
15:32:50 <geekosaur> mostly you et a lower bound based on what you have tested, which may be the current version only (I mean, do you also hsenv up a ghc 6.12.1 to test against?)
15:33:02 <geekosaur> you're not expected to be omniscient
15:33:30 <benzrf> excuse me but
15:33:36 <geekosaur> if someone else wants to test with an older version and tell you the result, you can update your dependencies to reflect it
15:33:49 <benzrf> i apt-get removed haskell-platform and reinstalled
15:33:54 <benzrf> but i still have all my pkgs ;-;
15:33:58 <benzrf> should i try ghc instead?
15:34:03 <Eduard_Munteanu> Hmm... I wonder if an indexed monoid makes sense / is useful (don't say "indexed monads" :P).
15:34:05 <geekosaur> (sadly, the no upper ;limit thing *does* involve claims of omniscience, and those claims are probabilistically incorrect)
15:34:06 <monochrom> ok, purge instead of remove
15:34:21 <Benjamin__> Event Store has the concept of "event streams" (which roughly map onto aggregates) and "categories" of event streams (which roughly map onto classes of aggregates). In an object language I'd have a PlayerEvent and GameEvent base classes with constant strings for the category and stream names
15:34:29 <geekosaur> afaik apt-get does not remove packages globally installed manually
15:34:44 <Benjamin__> and i'd use messaging to determine which stream/category to write each event to
15:34:51 <geekosaur> since they're not registered with dpkg, they can't be auto-removed --- and the package.conf.d files stick around and are inherited by the new install
15:34:54 <benzrf> thx monochrom
15:35:03 <monochrom> debian and rpm packages etc for haskell are painful
15:35:03 <Benjamin__> object-polymorphic messaging, i should say
15:35:15 <geekosaur> o you'd have ot apt-get purge, then manually remove whatever's left in the global package.conf.d
15:35:23 <benzrf> geekosaur: no dice
15:35:25 <benzrf> *monochrom
15:35:34 <Eduard_Munteanu> Something like   class IMonoid w where imempty :: w 0; imappend :: w i -> w j -> w (i + j)
15:35:58 <monochrom> ok, what is the directory called again? /var/lib/ghc-blahblah/what? nuke it anyway
15:36:08 <benzrf> O:
15:36:13 <Benjamin__> anyway in haskell i've found myself writing this:    class Event e where eventCategory :: e -> String
15:36:50 <Benjamin__> which is a ugly because eventCategory doesn't actually need the event itself, it just needs to know the type of e
15:37:04 <Benjamin__> but the type system says there has to be a e in the type signature
15:37:11 <monochrom> you need to read my article to see what it is and why. I am not going to repeat myself. the whole point of putting up a web page.
15:37:36 <Eduard_Munteanu> Benjamin__: any reason you can't make a 'data' with different constructors for each?
15:38:06 <Benjamin__> Eduard_Munteanu It shouldn't be possible to apply a PlayerEvent to a Game aggregate and vice versa
15:38:48 <Benjamin__> so I wrote data PlayerEvent = PlayerCreated Name | NameUpdated Name and operations on Player require a PlayerEvent
15:39:20 <Eduard_Munteanu> Ok.
15:39:33 <Benjamin__> anyway here's my stack overflow question which explains my question in more detail, and a sketch of how i might try to implement it in an object language http://stackoverflow.com/questions/22027772/what-should-i-do-when-i-feel-the-urge-to-use-object-style-polymorphic-messaging?noredirect=1#comment33394587_22027772
15:40:16 <Peaker> I'm having some thread issues I'm wondering about solving with STM, and having trouble structuring it nicely
15:40:42 <Peaker> I want to run a sub-process cmd, that may create some unknown amount of connections to a server I run, and eventually close those connections and die
15:41:41 <Peaker> problem: When the process dies, it closed all connections, but my concurrent server may not have received all connection msgs yet and sent them to me
15:42:03 <Peaker> and I want to guarantee receiving of all messages from the process...
15:42:03 <johnw> you're probably going to want async
15:42:17 <johnw> and a TChan to receive the data on
15:42:41 <Peaker> I prefer TMVar/MVar to TChan/Chan because they give flow control
15:42:43 <johnw> (or TVar, depends on how you transmit the data)
15:42:45 <Peaker> Chan's are all unbounded, right?
15:42:51 <johnw> TBChan is bounded
15:43:03 <johnw> TBQueue is a bit faster
15:43:05 <Benjamin__> i also wrote a previous question that's related to the same thing, it explains a bit more about my original choice for that data model http://stackoverflow.com/questions/22026038/strongly-typed-events-in-haskell
15:43:05 <Eduard_Munteanu> Peaker: well, don't use lazy IO then?
15:43:10 <Peaker> johnw: what's the difference?
15:43:26 <Peaker> Eduard_Munteanu: I don't -- but concurrency means I can't guarantee the connection msgs will be received before the process death
15:43:38 <johnw> Peaker: TBQueue is a bit simpler, it doesn't allow dup'ing
15:43:44 <johnw> same diff as TQueue vs TChan
15:43:59 <Peaker> so basically I want to wait until both   process death   and    0 active connections   hold
15:44:09 <johnw> that's easy with async
15:44:10 <Peaker> johnw: ah, is there also Queue vs Chan?
15:44:20 <johnw> create a list of Async actions and then wait on them all
15:44:31 <johnw> I've never heard of Queue
15:44:46 <Peaker> johnw: but connections are made in a server in a different thread
15:44:50 <johnw> async does a good job of handling exceptions
15:44:53 <johnw> that's fine
15:45:40 <Eduard_Munteanu> Peaker: I don't understand, what is that process? An external command ran using System.Process?
15:45:48 <Peaker> I want to have an event source that gives me the next message from the process, repeatedly, until it finally says EOF (when both above conditions hold)
15:45:53 <Peaker> Eduard_Munteanu: yeah
15:46:41 <Eduard_Munteanu> Peaker: then how is it going to die if it didn't finish sending?
15:46:56 <johnw> do chan <- ...; mapConcurrently (doConnection chan) (list of inputs)
15:47:10 <Peaker> johnw: Waiting until all connections die, when new ones can be created all the time sounds a bit challenging. I have an existing solution, but it does some of the IO handling in the context of the server itself, and I want everything to message a centralized loop that gets the events as described above
15:47:32 <johnw> you could always have a TChan filled with Async
15:47:32 <Peaker> The central position is the subprocess creator, not the server
15:47:48 <Eduard_Munteanu> I mean it sounds to me like the external command controls the actual connections.
15:47:48 <johnw> that way you can add new subcommands at will, and also know when they are all done
15:47:50 <SKImask> @pl (\a (f,r) -> f a r)
15:47:51 <lambdabot> (`ap` snd) . flip fst
15:48:11 <Peaker> johnw: how do you wait on all the Asyncs received on a TChan until there are no more?
15:48:27 <Peaker> Eduard_Munteanu: it does, it can create any number of connections at any time (until process death)
15:48:57 <johnw> Peaker: you could use waitSTM
15:49:00 <Peaker> Eduard_Munteanu: theoretically, process death signifies 0 active connections, but on the concurrent server, the death of the connections may be delayed behind some messages I've not received yet
15:49:06 <johnw> anyway, I have to go back to work :)
15:49:17 <Peaker> johnw: but how do I both do wait on the chan, and on the asyncs, and dynamically add the asyncs?
15:49:19 <Peaker> johnw: ok :)
15:49:27 <johnw> Peaker: that's the magic of retry
15:49:32 <johnw> you can wait on everything at once
15:49:49 <Eduard_Munteanu> Peaker: how could they be delayed, unless you use asynchronous I/O?
15:49:54 <Peaker> johnw: that's where I got confused, I tried implementing some loop based on retry, but didn't manage to work it out
15:50:18 <johnw> show me your loop
15:50:30 <Peaker> Eduard_Munteanu: the server thread is concurrent to the message handling thread (which receives the messages from the server thread and the process death indication from the subprocess thread)
15:50:32 <Eduard_Munteanu> If this is a C program or anything similar, you do blocking I/O naturally.
15:50:53 <Eduard_Munteanu> Oh.
15:51:32 <Peaker> johnw: http://lpaste.net/100397
15:52:12 <johnw> yes, that is wrong :)
15:52:15 <johnw> let me try
15:52:38 <Peaker> johnw: I used a simple TVar Int  for the connection count and I wait for both the cmdAsync to complete and the connection count to go to 0
15:52:43 <Benjamin__> OK well i'm going to bed now. Thanks for listening to a noob anyway :) If anyone here has any experience with event-sourcing in haskell, or any advice for me, i'd love to hear from you benjamin.hodgson@huddle.com
15:52:50 <Eduard_Munteanu> Peaker: you should make the external command an async too, and wait until all threads finish
15:53:01 <Peaker> Eduard_Munteanu: My external command is an async
15:53:14 <SKImask> @pl \p q -> (,) <$> p <*> q
15:53:15 <lambdabot> (((,) <$>) .) . (<*>)
15:53:33 <Eduard_Munteanu> Peaker: and how does it talk to the other threads?
15:53:34 <Peaker> Eduard_Munteanu: so I have a master loop, a bunch of concurrent server threads which aren't asyncs (and if they were, I would need to somehow send them to the master), and a cmd async
15:54:17 <johnw> Peaker: https://gist.github.com/9220517
15:54:31 <Eduard_Munteanu> Peaker: IOW, if your message handler threads read from some pipe, then process death means the pipe will EOF at some point
15:54:34 <Peaker> Eduard_Munteanu: sec, examining johnw's code :)
15:55:02 <johnw> that code gets all outstanding asyncs, polls them all, checks whether any are still working
15:55:07 <johnw> oh, I have some logic wrong there
15:55:32 <johnw> it should be length (catMaybes results) == length asyncs
15:55:40 <Eduard_Munteanu> Also if additional asyncs spawn in the meanwhile, you can wait on whoever spawns them.
15:55:56 <johnw> they can't be added to the TBQueue in the meanwhile
15:55:58 <Peaker> johnw: what is check?
15:56:05 <johnw> check says "retry if this is not true"
15:56:20 <johnw> thus, this transaction will only succeed when everything is done
15:56:26 <Peaker> johnw: isn't that the same as using waitSTM instead of pollSTM, and not check'ing?  I thought waitSTM retried if not done
15:56:42 <johnw> if you use waitSTM, you'll retry on the first one that is not ready
15:56:44 <johnw> yeah, I guess you're right!
15:56:56 <johnw> i didn't know if maybe you wanted to do something with the intermediate results
15:57:11 <Peaker> johnw: well, I also have a stream of messages coming in from these server threads until they die
15:57:11 <johnw> in that case just mapM waitSTM
15:57:16 <johnw> and it won't finish until they are all done
15:57:25 <Peaker> so I have 3 event sources: 1) Death of all connections  2) Stream of messages from connections  3) Process death
15:57:29 <fragamus> oooh I just watched the interview about STM
15:57:38 <johnw> anyway, got to go :(
15:57:39 <Peaker> I need to accumulate all of 2)    until   1&3
15:57:48 <Peaker> johnw: ok, thanks!
15:58:26 <Iceland_jack> SKImask: liftA2 (,)
15:58:31 <Iceland_jack> @ty liftA2 (,)
15:58:31 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:58:36 <johnw> so, what we wrote was "block until all are dead"
15:58:44 <johnw> you can modify it to a predicate "check if all are dead"
15:58:53 <johnw> and then have another "drain all pending messages"
15:58:59 <johnw> and then cycles between these two separate transactions
15:59:09 <Peaker> johnw: drain into some TBChan?
15:59:19 <johnw> you would drain from the TBChan into a list
15:59:23 <johnw> that's what I use untilM for
15:59:29 <Peaker> A list in a TVar?
15:59:47 <johnw> so the logic would be: drain pending messages.  are all dead?  yes, stop.  no, do it again.
15:59:54 <johnw> accumulate the mesages in a TBChan
16:00:09 <Peaker> but wouldn't the draining itself be rolled back if the continuation of the transaction retries?
16:00:09 <johnw> the logics reads them into a list, and sends them elsewhere within that loop
16:00:18 <johnw> use two different transactions
16:00:20 <Peaker> i.e: not all dead yet
16:01:10 <Peaker> so an STM action that drains in its own transaction is going to need its own thread to loop around it, wouldn't it?
16:01:14 <johnw> fix $ \loop xs -> do xs <- atomically (drain); alive <- atomically (check if any alive); if alive then do { process xs; loop } else process xs
16:01:28 <johnw> drops the "xs" parameter there
16:01:59 <Peaker> doesn't this busy-wait?
16:02:16 <benzrf> atomically?
16:02:19 <benzrf> :t atomically
16:02:20 <lambdabot> Not in scope: `atomically'
16:02:23 <johnw> not if the chan is empty
16:02:27 <Peaker> benzrf: atomically :: STM a -> IO a
16:02:35 <johnw> it's basically saying "process elements that arrive as soon as you can, until everything sin dead"
16:02:40 <Eduard_Munteanu> benzrf: it's a STM thing
16:02:55 <Peaker> johnw: but if "atomically (drain)" blocks, it may block forever if all died
16:03:01 <Peaker> johnw: if it doesn't block, it will busy-loop?
16:03:13 <johnw> it can only loop if there was something to get
16:03:38 <johnw> but yes, if everything dies while it is empty, it will throw an exception
16:03:41 <johnw> you could catch that exception
16:03:55 <johnw> exs <- try (atomically drain)
16:03:58 <Peaker> how do you make it throw an exception in such a case?
16:04:05 <Peaker> instead of blocking forever?
16:04:10 <johnw> it will happen automatically
16:04:19 <johnw> STM never blocks forever if there is no chance for it to succeed
16:04:29 <Peaker> ah, that's interesting
16:04:37 <johnw> the moment every subthread is dead, that transaction becomes invalid and will throw an exception
16:04:39 <Peaker> sounds like a fishy thing to guarantee?
16:04:50 <johnw> i'm not sure if it's 100%
16:04:59 <johnw> but the exception is "Waiting for in an STM transaction" or something like that
16:05:07 <johnw> it means that you are listening to a TBChan that no one else knows about
16:05:20 <johnw> which is pretty easy to detect, actually
16:05:23 <Peaker> It sounds like it depends on the GC actually collecting all the references that can write to that loop?
16:05:30 <johnw> yes
16:05:32 <johnw> that is exactly right
16:05:40 <Peaker> Depending on GC sounds dangerous/brittle :(
16:05:43 <johnw> but nothing here is RT precise
16:05:51 <Eduard_Munteanu> Well, Linux's lockdep detects deadlocks only by looking at locks.
16:05:52 <johnw> STM scheduling itself is rather imprecise
16:05:52 <Peaker> but GC is not even guaranteed to happen at all
16:06:02 <johnw> there is an idle GC that fires at intervals
16:06:09 <Eduard_Munteanu> That is, you don't need an improbable scenario to occur.
16:06:15 <johnw> unless you disable it, you WILL get a GC soonish
16:06:30 <Eduard_Munteanu> So it shouldn't be very surprising. :)
16:06:33 <johnw> but yeah, there may be other ways to design this
16:06:35 <Peaker> johnw: latency matters though -- it's a build system, so I don't want a command to take an extra 1ms or more for this
16:06:39 <johnw> I"m only half-thinking about it still
16:06:47 <Peaker> (many thousands of commands in sequence are probable)
16:08:52 <Peaker> Anyway, I have plenty of food for thought, thanks :)
16:10:26 <johnw> the reason to have two transactions is to allow more asyncs to be added to the "group" while monitoring the output channel.  But it will need more finesse than what we've written so far
16:11:05 <Eduard_Munteanu> Is there a "popular" package that provides DataKinds-specific structures, like HLists or length-indexed lists?
16:11:41 <Peaker> I'm thinking of having a simple non-STM bounded chan/MVar   and having conn_up, conn_msg, conn_down, and cmd_end   all just send messages to this chan, having a single master thread read this chan and translate this event sequence to a stream of messages until it knows there are 0 connections and process death
16:12:22 <Peaker> This translator can be an explicit state machine
16:13:05 <Peaker> I'm not used to designing stuff the STM/concurrency-primitives way.. I usually write the inverted-control stuff, so it's much easier for me to frame a correct solution in such terms
16:13:06 <johnw> sure, an actor model approach
16:13:19 <johnw> that works with STM too
16:13:23 <Iceland_jack> Eduard_Munteanu: equational-reasoning uses it but it's not really "popular"
16:13:32 <Iceland_jack> @hackage equational-reasoning
16:13:32 <lambdabot> http://hackage.haskell.org/package/equational-reasoning
16:14:26 <Eduard_Munteanu> Iceland_jack: ah, I was rather interested if there's a library I should depend on, instead of writing them myself
16:14:33 <johnw> Peaker: you should try that GC-based approach though, I bet it would work better than you think
16:14:35 <Iceland_jack> Sadly I don't think so
16:14:40 <johnw> and it would result in very little code
16:15:02 <johnw> maybe a 6 line function to do the monitoring-and-consumption-and-exit-when-all-done
16:15:28 <Peaker> johnw: I am worried about writing something which may have problems in the future that are hard for me to rule out right now..  I'd rather have a solution (even if more complex) that I understand why I can trust
16:15:52 <Peaker> (since I intend on forgetting the implementation details here, so swapping them into my brain later will be expensive :-) )
16:16:20 <johnw> btw, that one scenario: no act subthreads with an empty queue, is hardly to be the most likely case
16:16:25 <johnw> s/act/active
16:49:09 <metanat> Is this as appropriate place to ask basic questions?
16:49:15 <Eduard_Munteanu> metanat: sure
16:49:29 <Iceland_jack> metanat: Absolutely
16:50:46 <metanat> Say if I have a data type like "data Token = Token { name :: String, value :: Double } deriving (Show)"
16:50:54 <metanat> And I have a list of these Tokens
16:51:31 <metanat> What is the best way to do a list comprehension on them?
16:51:45 <Iceland_jack> metanat: You can pattern match on the value constructor Token
16:51:52 <Iceland_jack> @let data Token = Token { name :: String, value :: Double } deriving (Show)
16:51:52 <lambdabot>  Defined.
16:51:56 <metanat> I want to so something like "[ Token n (tf'' v) | Token n v <- t ]"
16:52:13 <metanat> So calling a function on the value and producing a new list
16:52:14 <Eduard_Munteanu> metanat: that'd work
16:52:20 <Iceland_jack> > [ name | Token name _ <- [Token "sally" pi] ]
16:52:21 <lambdabot>  ["sally"]
16:52:38 <c_wraith> ...  This is one of those cases that makes me lament how limited record syntax is.  And that lens is hard to sell to absolute beginners.
16:53:26 <Eduard_Munteanu> Well, lens could use a simpler API with a bunch of wrappers to make types less frightening.
16:53:49 <monochrom> what does tf'' mean?
16:53:52 <Eduard_Munteanu> There's something in that direction there already, IIRC.
16:53:59 <edwardk> Eduard_Munteanu: doesn't work for any combinator basically
16:54:17 <monochrom> if tf'' already has the right type, [ Token n (tf'' v) | Token n v <- t ] already works
16:54:19 <metanat> monochrom: It is a term frequency function
16:54:30 <metanat> monochrom: I know the code works
16:54:31 <edwardk> Eduard_Munteanu: when you take a lens-like in negative position you get the scary ass type signatures or you lose the magic overloading
16:54:37 <monochrom> what does that mean? what is its type?
16:54:38 <c_wraith> edwardk: thanks for the nice comment on my article, by the way.
16:54:43 <metanat> I am just wondering if that is a typical convention
16:54:55 <monochrom> it is
16:54:59 <metanat> Okay cool
16:55:00 <edwardk> c_wraith: np. i enjoyed the article a lot, it is very much "how i think"
16:55:14 <metanat> So I am not doing anything that isn't typical. Thanks
16:55:14 <Eduard_Munteanu> edwardk: like ALens? Yeah, though beginners could use simpler accessors and such
16:55:41 <Iceland_jack> metanat: Sure, you can also make it simpler if you only need one of the fields
16:55:57 <metanat> Iceland_jack: example?
16:56:20 <metanat> Because I have another area when I only use one field
16:56:23 <Eduard_Munteanu> metanat: usually you don't use a comprehension for that, though
16:56:27 <Iceland_jack> > map (map toUpper . name) [Token "Sally" pi, Token "Bob" (pi*2)]
16:56:28 <lambdabot>  ["SALLY","BOB"]
16:56:40 <Iceland_jack> since 'name' is a function from Token to String
16:56:41 <edwardk> Eduard_Munteanu: "ALens" is a good example. lets consider it for a sec. by saying ALens you require exactly a Lens. it doesn't take a Traversal or a Getter so you can't transparently work with anything better or worse
16:56:42 <Iceland_jack> @ty name
16:56:43 <edwardk> just exactly a lens.
16:56:43 <lambdabot> Token -> String
16:56:58 <Eduard_Munteanu> Ah, I see.
16:57:00 <edwardk> Eduard_Munteanu: very few of the combinators in lens are that specific
16:57:03 <metanat> Iceland_jack: Right. Nice that you
16:57:06 <metanat> thank
16:57:30 <edwardk> Eduard_Munteanu: almost all of them do 'the right thing' when handed a generalization or a limited form of what you' expect them to take if it can be done sensibly
16:57:45 <edwardk> and the types prevent you from passing anything that don't make sense. but for that to happen, the TYPES have to be there =P
16:57:51 <Iceland_jack> metanat: Note that you can also pattern match in anonymous functions, but that has different semantics if it fails than in list comprehensions
16:58:36 <Iceland_jack> > [ a | Just a <- [Nothing, Just 1, Nothing, Just 2, Nothing] ]
16:58:37 <lambdabot>  [1,2]
16:58:42 <metanat> \Token {name = n'}
16:58:46 <metanat> I have used that
16:58:50 <metanat> Is that what you mean?
16:58:57 <metanat> Or \Token n _
16:59:00 <Iceland_jack> yes
16:59:03 <monochrom> both
16:59:06 <edwardk> Eduard_Munteanu: When you see LensLike Foo (a,c) (b,c) a b   i'm deliberatey exposing Foo there, because if Foo is Applicative it'll take a traversal, if it is a functor, it'll take a lens, if its both functor/contravariant it'll take any getter, etc.
16:59:26 <edwardk> no alias can kind that away
16:59:45 <edwardk> since almost every combinator takes a different 'Foo'
16:59:46 <Eduard_Munteanu> edwardk: hm, I see... I suspect you'd need a bunch of typeclasses just for this purpose, to overload them.
16:59:50 <monochrom> you will need a data type of two or more cases to see the difference
17:00:02 <Iceland_jack> Like Maybe a
17:00:07 <edwardk> Eduard_Munteanu: yeah, lets make one up, and parameterize it.. we could call it "LensLike" =)
17:00:14 <Eduard_Munteanu> Heh.
17:00:26 <monochrom> if you already know Maybe, [x | Just x <- [Nothing]] is differen from map (\ Just x -> x) [Nothing]
17:00:32 <Iceland_jack> > map (\(Just a) -> a ) [Nothing, Just 1, Nothing, Just 2, Nothing]
17:00:33 <lambdabot>  [*Exception: <interactive>:3:6-19: Non-exhaustive patterns in lambda
17:00:44 <edwardk> For further generalization w might use something else and call it "Optic" for when its not lens-like but wants to cover prisms, isos, etc. ;)
17:00:44 <Eduard_Munteanu> @undo [x | Just x <- [Nothing]]
17:00:45 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) [Nothing]
17:00:53 <monochrom> but the difference is only because Maybe has two cases. Token has only one case, you will do fine.
17:01:05 <edwardk> Eduard_Munteanu: that is where the current scary names came from in lens
17:01:20 <Eduard_Munteanu> Hm, I see. :)
17:01:30 <edwardk> and a lot of why we expose fake signatures for folks to reason with
17:01:46 <Eduard_Munteanu> Or the Mutator stuff, I presume.
17:01:52 <Iceland_jack> metanat: Does this answer your question?
17:02:01 <edwardk> Mutator was so we could give typeclass errors not unification errors for most problems
17:02:28 <metanat> It does
17:02:52 <metanat> I am really a beginners so I am merely trying to validate the sanity of what I am doing
17:03:21 <Iceland_jack> Okay :) what you're doing is perfectly reasonable
17:03:29 <edwardk> No instance of Gettable Mutator or Settable Accessor was the old errors, but that didn't survive well when we switched to using Contravariant for Getters/Folds, so we switched back to Const and Identity as no instance of Contravariant Identity is somthing you can tease apart without knowledge of lens internals, and n instance of Contravariant Mutator means nothing to anyone outside the developers ;)
17:04:20 <Eduard_Munteanu> edwardk: btw, it's possible to get some sort of type-level 'error' function these days with DataKinds, IIRC
17:04:55 <Eduard_Munteanu> Or well, without datakinds if you name stuff accordingly, but datakinds let you use Symbol for that.
17:05:08 <edwardk> Eduard_Munteanu: yeah but when it goes wrong. the type errors oh my god the type errors
17:05:33 <Eduard_Munteanu> Yeah, the kinds pop up everywhere.
17:06:32 <edwardk> i think the cure is typically worse than the disease
17:09:01 <monochrom> I like such kind of cures :)
17:18:56 <mkramer> I'm having a hard time using lets inside of guards…I get a parse error at the first pipe on line 3 http://lpaste.net/100400
17:18:59 <mkramer> am I doing this wrong?
17:19:35 <mkramer> Well…I mean…how am I doing it wrong
17:20:41 <shachaf> Does GHC just say "parse error"?
17:21:18 <shachaf> OK, in this case I see the issue. Actually I see several issues so I don't know which one you're asking about.
17:22:22 <mkramer> The actual error when I pull it into GHCi is: parse error on input `|'
17:22:34 <mkramer> a line and char indicating that first pipe
17:22:38 <geekosaur> yes, the = on the previous line is wrong
17:22:57 <geekosaur> foo x | x == 1 = ... | x == 2 = ...
17:23:19 <mkramer> doh
17:24:18 <mkramer> That was an error, now it's complaining about the pips in the lets
17:24:36 <mkramer> the first pipe of the first in clause
17:24:48 <geekosaur> yes, what is that supposed to be doing?
17:25:11 <geekosaur> `in` is followed by an expression, not a guard
17:26:01 <mkramer> Alright, well, I'd like to chose a different expression based on guards
17:26:36 <mkramer> perhaps I could could do: case () of _  and then guard that?
17:26:53 <geekosaur> perhaps you want the let binding (not the ensuing expression) to have guards? or use case if you must have guards there
17:27:10 <psquid> Just a quick question: whereabouts should I be looking (if it's even an option) for a way to have case statements where multiple cases (which bind no variables/the same variables, so no problems there) share a right-hand-side?
17:27:48 <geekosaur> you can't do it directly. you could use a where clause to bind a common expression you can then reference in multiple cases
17:28:30 <psquid> Alrighty. Thanks!
17:28:47 <mkramer> thanks geek
17:29:08 <haasn> (Disclaimer: I don't know the full context) “stand-alone guards” can be had with MultiWayIf; eg. if | cond1 -> expr1 | cond2 -> expr2 | ...
17:30:20 <metanat> In certain imperative languages I can spot syntax errors and programming mistake fairly quickly. Sometimes immediately. Do the experienced haskellers in the channel have the same experience with haskell?
17:30:47 <geekosaur> I can spot some of them fairly quickly, others not so quickly
17:31:13 <haasn> I think the hardest to spot are type errors. Fortunately, you don't need to spot those manually
17:31:43 <geekosaur> mostly it's just familiarity with syntax
17:32:25 <haasn> but to answer your question; yes metanat, after a few years of Haskell you're just as “fluent” with it as after a few years of certain imperative languages
17:33:30 <metanat> that is good to know. it feels that way. that I will get better at seeing things quickly
17:34:16 <sipa> years? nonsense, you can learn c++ in 21 days: http://abstrusegoose.com/249
17:34:28 <johnw> metanat: most certainly you will
17:34:37 <johnw> metanat: it wasn't long ago that Haskell looked like completely magic to me
17:34:37 <metanat> what are some good example problems for someone learning haskell but with good programming experience?
17:35:00 <johnw> metanat: the best example problem is a problem you want a solution to, like a script or some kind of library
17:35:12 <Clint> or fixing all my bugs
17:35:15 <johnw> small in scope, but meaningful, provides good motivation
17:35:31 <johnw> to this day I still use the first Haskell program I ever worte
17:35:32 <metanat> i am working on a classifier at the moment
17:36:13 <metanat> johnw: What was it?
17:36:23 <johnw> http://hackage.haskell.org/package/una
17:37:29 <roconnor> metanat: can you write a function to commpute IRR for me (bonus points for computing XIRR)?
17:37:39 <roconnor> *compute
17:38:08 <Peaker> johnw: I went with a simple solution:  IORef Int   holds 1+activeConnections (1 represents running process).  New connections do atomic inc on the int. Disc do atomic dec.  Cmd completion does dec too (not via async, but a `finally` on the cmd action).  Dec that reaches 0 sends EOF to an MVar. Incoming msgs send a msg to the same mvar.  Then I can loop receiving on that mvar
17:38:27 <metanat> roconnor: "Internal rate of return"?
17:38:36 <johnw> Peaker: nice
17:38:40 <Peaker> (EOF is guaranteed to signify no more msgs)
17:39:10 <roconnor> metanat: yes
17:39:27 <c_wraith> Peaker: that description makes me worry about building chains of thunks, but I doubt I need to warn you about that.  (I'm warning you about it anyway.)
17:39:56 <metanat> roconnor: Probably :) not right now though. I am meant to be working
17:40:02 <Peaker> c_wraith: I'm hoping my use of atomicModifyIORef' and comparing to 0 after every inc/dec is going to force those thunks
17:40:29 <c_wraith> Peaker: atomicModifyIORef' should handle it by itself.  Sounds good.
17:42:38 <metanat> johnw: Cool :)
17:51:10 <Peaker> how can I use bracket in ResourceT IO?
17:51:53 <Peaker> I have a   withAllocatedFoo $ \foo -> do ..    which worked well in IO.  Now I am thinking about lifting the whole computation into ResourceT
17:52:05 <newsham> anyone good with emacs and haskell-mode?  i'm an emacs n00b and i have no idea why C-c C-c is not getting bound to haskell-compile
17:52:08 <Peaker> but what can I do with/to withAllocatedFoo to make it work in ResourceT?
17:53:25 <johnw> use allocate
17:53:35 <sid> What do I need to import to use the showFinType function? I tried Data.Number.Fin.Integer and all the prefixes none of them work.
17:53:41 <OneEyedWill> :t +
17:53:41 <lambdabot> parse error on input `+'
17:53:42 <johnw> and yes, you can use bracket
17:53:44 <johnw> use lifte-
17:53:51 <johnw> use lifted-base, and import Control.Exception.Lifted
17:53:55 <alkabetz> OneEyedWill: You need parens around the infix operator
17:53:57 <johnw> then bracket will work
17:53:59 <OneEyedWill> :t (+)
17:53:59 <alkabetz> :t (+)
17:53:59 <lambdabot> Num a => a -> a -> a
17:54:00 <lambdabot> Num a => a -> a -> a
17:54:00 <Peaker> johnw: ah, cool, thanks
17:54:04 <OneEyedWill> alkabetz: thanks
17:54:14 <alkabetz> OneEyedWill: No problem
17:55:04 <Targen> Is it possible to rebind an implicit parameter?
17:55:12 <Peaker> johnw: MonadBaseControl seems so ad-hoc/hacky -- does it really capture monads that have a sensible bracket like behavior?
17:55:25 <johnw> I don't think it's hacky at all
17:55:33 <johnw> it's simply a way of saving and restoring transformer state
17:55:57 <johnw> so, it works for any transformer that can do that
17:57:11 <Peaker> johnw: I think the assumption that transformer is even about "state" or can represent its context as some state value is weird
17:57:22 <johnw> why is that?
17:57:41 <johnw> WriterT clearly has a state -- the monoid being accumulated
17:57:47 <Peaker> what is the transformer state for ContT, ListT, ?
17:57:54 <johnw> there isn't one for ContT
17:58:04 <Peaker> StateT, ReaderT, WriterT are all special cases of StateT
17:58:12 <Peaker> many transformers are special cases of StateT
17:58:17 <Peaker> but many aren't
17:58:22 <johnw> what's your point?
17:58:50 <Peaker> that MonadBaseControl is basically about being some sub-case of StateT, and has a weird name for that?
17:58:50 <Clint> StateT is a special case of StateT?
17:58:59 <Peaker> Clint: yes, in a degenerate way :)
17:59:10 <geekosaur> pretend the transformer is Identity :p
17:59:29 <johnw> Peaker: I don't see the complaint; it has a usefulness for a certain class of transformers.  Are you saying that because it doesn't generalize to everything it's bizarre and should not be used?
17:59:35 <Iceland_jack> A special case is specialization of a concept no?
18:00:12 <Peaker> johnw: well, if the set of transformers it captures is exactly the set of transformers with a sensible bracket -- then no complaint
18:00:42 <johnw> the only time I've ever wanted MonadBaseControl and couldn't have it is inside a conduit.  And so I wrote the gatherFrom/drainTo functions in stm-conduit to get around this restriction
18:00:50 <Peaker> johnw: but if it's just an ad-hoc way to capture a way to do bracket, but many transformers who could do it cannot be instances because they don't have such a "state", then there's a complaint
18:01:03 <johnw> it's *far* more useful than just bracket
18:01:19 <johnw> I use the "control" primitive quite often
18:01:26 <johnw> i just used it today in fact
18:01:45 <Peaker> what is it?
18:02:20 <mm_freak> Peaker: i don't really buy the monad-control argument, and i hate Monad*Control…  ever written an instance for that one?  it's ugly and incomprehensible
18:02:32 <johnw> control $ \runInTransformer -> do { ... do something in IO ... ; x <- runInTransformer (... do something in transformer ...) ; ... do something else in IO ; return x }
18:02:39 <Targen> Is there some way to implement nSucc in the following to make the result of the whole thing be the string "41" (without cheating of course)?  let foo :: (?n :: Int) => String; foo = show ?n; nSucc :: ((?n :: Int) => a) -> ((?n :: Int) => a); nSucc f = ??? in (let ?n = 42 in nSucc foo)
18:02:57 <johnw> monad-control is a very powerful tool in my toolbox, I see no reason to hate on it
18:02:59 <mm_freak> it does provide some guarantees that the more traditional MonadCatchIO does not provide, but i believe that the cost is too high
18:03:02 <johnw> but yes, writing instances is ugly as sin
18:03:13 <johnw> MonadCatchIO is horrible
18:03:48 <mm_freak> johnw: i've written an instance once, and i didn't understand it…  the reason why i somewhat trusted my instance was because i got the types right and bracket and forkIO seemed to work
18:03:55 <mm_freak> i didn't understand my own code…
18:04:10 <Clint> i have the same problem
18:04:22 <Clint> but i don't know how to do it without lifted-base
18:04:23 <johnw> mm_freak: well, I must admit that I didn't fully understand monad-control until I re-implemented myself from scratch during ICFP -- only to realize that Baas' implementation is quite good, if a bit impenetrable
18:04:30 <mm_freak> also it was one of the weird cases where you could write MonadBaseControl, but no MonadTransControl
18:04:46 <johnw> you can always write just a MonadBaseControl
18:04:55 <johnw> just don't use Baas' defaultLift* functions
18:05:02 <mm_freak> snoyman explained in a mail that he has the same problem, and honestly he writes only MonadBaseControl, too
18:05:19 <Targen> (sorry, I meant "43" — otherwise the name nSucc would be confusing :)
18:05:20 <johnw> yeah, I totally ignore MonadTransControl
18:05:22 <johnw> never needed it
18:05:49 <Clint> i needed it for EitherT i think
18:06:41 <mm_freak> johnw: what's your opinion about the 'exceptions' library?
18:06:47 <johnw> this is a prototypical "MonadBaseControl" only instance: https://gist.github.com/9222026
18:06:52 <Peaker> An alternative would be to have ResourceT like bracketing in simple IO, without transforming IO?
18:06:55 <johnw> as I said, ugly; that's one I wrote two weeks ago
18:07:12 <johnw> Peaker: what is "ResourceT like bracketing"?
18:07:50 <johnw> mm_freak: I like 'exceptions'.  I'm currently in discussions with snoyberg and edwardk about improving it toward something I think everyone should use to express the idea of exceptional errors
18:07:52 <Peaker> johnw: something like:   resourceBracket $ do { .. register resource .. release resource .. unprotect resources .. }
18:07:57 <johnw> and Tekmo
18:08:05 <Peaker> johnw: very much like runResourceT, but without the "ResourceT" type
18:08:30 <johnw> Peaker: so what are you going to register to?
18:08:31 <Peaker> actually, it'd be more like:   resourceBracket $ \rsc -> do { .. register rsc ... ... }
18:08:42 <Peaker> (no monad transformer in sight here
18:08:44 <Peaker> )
18:08:45 <johnw> ah, that's just exposing the internal state of ResourceT
18:08:53 <mm_freak> johnw: because honestly all i've ever needed monad-control for was lifting brackets and finallies
18:09:05 <johnw> mm_freak: I use async-lifted constantly
18:09:17 <johnw> in fact, so much so that I rarely use normal async anymore
18:09:25 <Peaker> johnw: it exposes the implicitly carried registration context as an explicit variable, but that's not an "implementation detail"
18:09:32 <acowley> async-lifted is awesome
18:09:37 <acowley> but it's a shame it's needed
18:09:37 <mm_freak> i don't, because it feels so wrong to lift concurrency through monad-control that i wouldn't trust my own code
18:09:59 <johnw> what feels so wrong about it?
18:10:12 <mm_freak> johnw: well, what's the semantics of lifting StateT?
18:10:16 <acowley> The fact that it's needed at all!
18:10:23 <johnw> Peaker: what about the Resource wrapper at the bottom of http://hackage.haskell.org/package/resourcet-0.4.10/docs/Control-Monad-Trans-Resource.html?
18:11:05 <Peaker> johnw: it's nice -- but there are certain significant disadvantages to prevalent transformers vs. flat IO
18:11:09 <johnw> mm_freak: in that case you have to decide: do you want to propagate changes made to the State from inside the thread back to the parent, or not
18:11:22 <johnw> if you don't want that, then don't do it
18:11:35 <mm_freak> johnw: and how do you decide that?  there is only one instance for StateT
18:11:44 <Peaker> well, in flat IO, I'd still like to be able to dynamically register resources to a cleanup that is guaranteed to happen at the end (or earlier)
18:12:09 <mm_freak> johnw: and how do you actually know which decision you made?
18:12:14 <johnw> mm_freak: you'd do the 'wait' call in its own runStateT
18:12:35 <johnw> x <- async ...; get >>= runStateT (wait x)
18:12:41 <johnw> and then abstract that into asyncDiscard
18:13:20 <johnw> the tradeoff is which thing you're making easier to do: sharing the state between parent and thread, or not allowing sharing at all
18:13:23 <mm_freak> johnw: what if your 'async' is inside a StateT?  what's the semantics?  can you answer this question without reading monad-control source code?
18:13:25 <johnw> for things like LoggingT, sharing is awesome
18:13:28 <johnw> for StateT, it kind of sucks
18:13:41 <mm_freak> ok, if StateT sucks, let's use WriterT
18:13:48 <mm_freak> or ResourceT
18:13:50 <mm_freak> or …
18:14:02 <johnw> if your async is inside of StateT (as it was in my example up there), then the state at that moment is the same in both the parent and the thread, and then begins to potentially diverge in both
18:14:04 <mm_freak> pretty much any monad transformer other than ReaderT =)
18:14:12 <johnw> a "wait" would overwrite the parent's state with the thread's state
18:14:25 <johnw> ResourceT is evil where async-lifted is concerned
18:14:29 <johnw> in fact, it will cause an exception
18:14:35 <johnw> snoyberg is going to put out a blog article on that in the next few days
18:14:46 <mm_freak> i wouldn't have known that
18:14:59 <johnw> because when you "wait", it will close ResourceT's internal state
18:15:09 <johnw> and then when the parent finishes its runResourceT, it too will close the same state
18:15:11 <johnw> boom
18:15:28 <mm_freak> i wouldn't ever expect states to merge in a potentially diverging setting
18:15:53 <mm_freak> but this is a question i simply can't answer without reading monad-control's source code
18:16:06 <johnw> I guess I've read it too many times
18:17:14 <johnw> mm_freak: ah, snoyberg already has an answer to this: reosurceForkIO
18:17:34 <mm_freak> sure, but that one is unrelated to monad-control =)
18:17:51 <johnw> well, it uses lifted-base's bracket_ :)
18:18:22 <johnw> so, we could create a resourceAsync that used resourecForkIO instead of forkIO, and then it should be safe
18:18:58 <mm_freak> unrelated in the sense that it doesn't use ResourceT's own instance
18:19:12 <johnw> anyway, if you want to argue that not understanding the intricacies of monad-control is reason not to use it in your code, that's fine; but I don't think that's reason to say its evil or should never be used
18:19:16 <mm_freak> and you would begin doing code duplication
18:19:24 <mm_freak> a Fork class would solve this problem
18:19:38 <mm_freak> as said, i don't buy the basic monad-control premise:  that you need one class to rule them all
18:19:51 <johnw> my primary use of MonadBaseControl has been to share ReaderT and LoggingT environments
18:20:02 <johnw> I generally avoid anything more exotic
18:20:33 <johnw> but when you have ReaderT env (LoggingT IO) a, it's sooo nice to just use "async" and have all the right things happen behind the scenes
18:20:37 <johnw> doing it manually is a PITA
18:20:58 <johnw> (and right now, nearly every application I work on has a global transformer fitting just that pattern)
18:21:10 <haasn> johnw: how does una compare to unp (ie. http://packages.qa.debian.org/u/unp.html)?
18:21:22 <johnw> I have no idea
18:21:31 <johnw> when I wrote una, I didn't realize there were like 5 other utilities that all did the same thing
18:21:43 <mm_freak> my main problem with monad-control is semantics:  you can't know what your code is doing, unless you use it only with reader-like monads or you have a global agreement on what the semantics of certain monads should be
18:21:49 <johnw> una is also fully recursive; it will even descend into .iso's
18:22:10 <johnw> mm_freak: ok
18:22:34 <johnw> I do agree that if you use monad-control with StateT, you're begging for some brain twisters
18:22:45 <mm_freak> that's because the definition of, say, forkIO is completely disconnected from the MonadBaseControl instance of the monad in question
18:23:09 <johnw> well, I use "fork" from lifted-base :)
18:23:27 <mm_freak> hopefully only with readers ;)
18:23:37 <johnw> pretty much
18:23:59 <johnw> I've found that readers and ResourceT consistute the vast majority of my need for application-wide transformers; WriterT and StateT can usually be focused in on specific algorithms
18:24:16 <johnw> and even then, it's just for convenience
18:24:31 <johnw> like throwing in a runMaybeT to avoid quadruply-nested case switches
18:25:53 <acowley> Yeah, Reader and something like Resource are super useful for large things
18:27:56 <stevejb> hello, I have a quick question about installing cabal.  I am trying to install ghc 7.8 rc 1 on an EC2 instance. I seem to have ghc installed okay, however, when trying to run bootstrap.sh to install cabal, I am getting the folloing error:  undefined reference to `__gmpz_powm_sec'
18:29:00 <alkabetz> Is your GHC installation working properly?
18:29:12 <alkabetz> That sounds like a linking issue, and so I would be unsurprised if GHC just didn't work
18:29:15 <stevejb> it seems to be. ghc --version seems okay
18:29:26 <alkabetz> Have you tried compiling anything, though?
18:29:38 <alkabetz> (Other than Cabal, that is)
18:29:40 <stevejb> no
18:29:48 <alkabetz> Would you be willing to try building a hello, world?
18:29:57 <stevejb> yes tryign right now
18:30:00 <alkabetz> Cool, thanks.
18:30:32 <stevejb> oh you're right, nothing can link
18:30:43 <stevejb> I get the exact same error
18:30:45 <alkabetz> Have you installed libgmp-dev (or whatever the GMP development package is on your distro)?
18:31:29 <stevejb> I tried installing gmp-devel.x86_64, but that did not have the .so.10 file, so I built and installed it by hand
18:32:20 <alkabetz> Is the .so.10 actually what GHC 7.8 needs?  (I'm not sure what version of the so it actually needs; I'm curious if you've checked)
18:32:33 <Targen> Oh, the ImplicitParams issue I had a bit ago went away with Rank2Types and a couple signatures.  Never mind :)  For reference, this yields "43" as desired:let foo :: (?n :: Int) => String; foo = show ?n; nSucc :: ((?n :: Int) => a) -> ((?n :: Int) => a); nSucc f = (let n = ?n in (let ?n = succ n in f)) in (let ?n = 42 in nSucc foo)
18:33:53 <stevejb> yes that is what it needs. i think it may just be in the wrong place
18:35:03 <metanat> Say if you have two data types that use the same name in their record definition is there a way around this? I understand that functions are created and this is why it doesn't work, but does this mean that I need to avoid using this pattern to play nicely with other libraries?
18:35:42 <monochrom> two types defined in separate modules will not clash
18:36:30 <alkabetz> metanat: The trollish answer is 'use lens and mkFields', but if you're not already using lens for your project, it's probably not worth it
18:36:57 <metanat> monochrom: thanks! that is what I needed to know
18:38:22 <Targen> metanat: A rather uncomfortable alternative that sort of works is to put each record definition in a separate module and import their field selectors qualified.  It’s not much of a solution, though.
18:38:48 <metanat> Targen: Right
18:39:15 <metanat> so if I import a module that uses a data type with a record syntax that clashes with another record syntax then I will have a problem?
18:39:38 <geekosaur> this is a well known pain point that nothing is being done about because there are multiple proposals and no consensus...
18:39:48 <geekosaur> you'd have to import it qualified
18:39:56 <metanat> but I have options to modify things when importing?
18:40:04 <metanat> geekosaur: okay cool
18:40:40 <geekosaur> import qualified Foo [as Bar]
18:41:28 <geekosaur> you see lots of people doing "import qualified Map as M" because there are collisions between Map functions and many list functions, for example
18:41:41 <metanat> right
18:41:48 <Targen> import qualified Foo as F (Foo(Foo, field)); import qualified Bar as B (Bar(Bar, field)); quux foo bar = (F.field foo, B.field bar)
18:42:14 <geekosaur> well, Data.Map these days, one hopes; H98 is kinda old :p
18:42:19 <metanat> super helpful, thanks all!
18:42:41 <Targen> metanat: Take a look at -XDisambiguateRecordFields
18:46:01 <Targen> By the way, does OverloadedRecordFields help with this?
18:48:01 <metanat> Targen: I am not actually facing this problem, but I can see the potential for it and just wanted to learn
18:54:08 <codonnell> I'm trying to write something using the ncurses library, but I'm running into some type trouble and was hoping someone would have an idea of how to help.
18:54:35 <codonnell> I have a value inside the NCurses monad, but my event handler needs something in the IO monad.
19:02:12 <codonnell> I pasted code here: http://lpaste.net/100401
19:04:46 <geekosaur> generally the answer there is liftIO
19:05:53 * hackagebot husk-scheme 3.16 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.16 (JustinEthier)
19:07:04 <codonnell> So liftIO will lift something in IO into NCurses, but I need the opposite. Perhaps that is just impossible, and I need to structure my code in a different way?
19:08:06 <geekosaur> hm? you want to use liftIO to run the putStrLn in IO, from what I see?
19:09:04 <geekosaur> that said, if you're doing curses, you probably do not want to do normal I/O to stdout at the same time
19:09:11 <geekosaur> since curses is using it
19:09:57 <codonnell> Good point. I should rethink how to put this test together. I just wanted to test getting keyboard input from ncurses and acting on it using reactive-banana.
19:10:02 <tmhedberg> It looks like he's only using curses for input key events and not actually drawing anything with it
19:10:08 <metanat> If I have a Doubles in a list, why can't I use (^2) as a function in a map?
19:10:27 <codonnell> Actually, the putStrLn is compiling ok. It's the last line (forever ...) that I'm having trouble with.
19:10:44 <metanat> am I forced to use (\x -> x*x) ?
19:11:17 <codonnell> (^2) is working fine for me
19:11:20 <geekosaur> hm, forever does not care what monad it is in
19:11:32 <geekosaur> > map (^2) [2.0, 4.0]
19:11:33 <lambdabot>  [4.0,16.0]
19:11:42 <metanat> hmm, weird
19:11:54 <Clint> metanat: what's the type of (^)
19:12:09 <codonnell> This is my error message, if it helps
19:12:16 <codonnell> Movement.hs:25:42:
19:12:18 <codonnell>     Couldn't match type `IO' with `UI.Curses'
19:12:19 <codonnell>     Expected type: Maybe UI.Event -> UI.Curses ()
19:12:21 <codonnell>       Actual type: Handler (Maybe UI.Event)
19:12:22 <codonnell>     In the second argument of `(>>=)', namely `fireKey'
19:13:05 <metanat> "Defaulting the following constraint(s) to type `Integer'"
19:13:05 <geekosaur> you might need to liftIO that then, although I don't know reactive-banana well enough to be certain
19:13:08 <metanat> That is that I get
19:13:11 <metanat> a warning...
19:13:34 <Noldorin> can anyone recommend a good intro haskell book for a mathematician?
19:13:48 <geekosaur> metanat: pastebin your actual code please? (I suspect you don't actually have Double-s there)
19:13:50 <geekosaur> @paste
19:13:50 <lambdabot> Haskell pastebin: http://lpaste.net/
19:14:12 <michaelt>       forever (UI.getEvent w Nothing >>= liftIO . fireKey) does typecheck, codonnell
19:14:24 <codonnell> Ok, thanks!
19:15:57 <watermind> fmap can be derived from the (haskell) definition of monad using return and >>=
19:16:05 <watermind> that doesn't work with comonad now, does it
19:16:19 <codonnell> Yeah, that helps a lot. I think I have a better idea of how to work with the two monads.
19:17:00 <watermind> i.e. can we, using the comonad class methods, and  associated comonadic functions (e.g. extend) derive fmap?
19:17:10 <prophile> watermind: I think so?
19:17:20 <watermind> prophile: really?
19:17:28 <prophile> :t liftW
19:17:28 <lambdabot>     Not in scope: `liftW'
19:17:29 <lambdabot>     Perhaps you meant one of these:
19:17:29 <lambdabot>       `liftM' (imported from Control.Monad.Writer),
19:17:32 <geekosaur> wouldn't you get a cofunctor?
19:17:57 <watermind> my guess was no because the counit removes moves you from TA -> A
19:17:58 <prophile> yeah
19:18:07 <prophile> fmap f = extend (f . extract)
19:18:25 <watermind> that works?
19:18:30 <geekosaur> (but I seem to recall cofunctor may be the same thing as functor or something like that?_
19:18:34 <watermind> extract : T A -> A
19:18:41 * geekosaur not good with this stuff, sadly
19:18:47 <prophile> it's liftW in the comonad package
19:18:52 <prophile> and yeah, it works
19:18:53 <metanat> geekosaur: I fixed things..
19:18:55 <watermind> so f cannot be of the form f: A-> N
19:19:05 <prophile> extract :: w a -> a, extend : (w a -> b) -> w a -> w b
19:19:23 <prophile> (f . extract) is w a -> b, substitute that in for the first argument of extend
19:19:47 <watermind> then f :w a -> w b
19:19:54 <michaelt> Noldorin: I'm not sure that there is a haskell primer that is especially suitable for mathematicians; once you learn a bit of it, there is plenty of material, according to your taste.
19:19:55 <prophile> no, f : a -> b
19:20:15 <watermind> oh god
19:20:16 <prophile> :t \f -> extend (f . extract)
19:20:17 <lambdabot> Not in scope: `extend'
19:20:17 <lambdabot> Not in scope: `extract'
19:20:21 <watermind> you're right
19:20:25 <prophile> ಠ_ಠ
19:20:32 <Noldorin> michaelt, I see. I've tried LYAH twice but find it too waffly and not sufficiently precise
19:20:38 <prophile> :t \f -> Control.Comonad.extend (f . Control.Comonad.extract)
19:20:39 <lambdabot> Control.Comonad.Comonad w => (b1 -> b) -> w b1 -> w b
19:20:42 <metanat> geekosaur: Here is the code, though I have fixed the issue. I am a noob btw, just started learning a few days ago http://lpaste.net/100402
19:20:49 <prophile> :t Control.Comonad.liftW
19:20:50 <lambdabot> Control.Comonad.Comonad w => (a -> b) -> w a -> w b
19:20:57 <Noldorin> I want something that isn't afraid to properly motivate the language features with maths
19:21:03 <watermind> prophile: somehow I wrote that definition, just by making the dual of the monad one, and managed to confuse myself
19:21:09 <watermind> I can't even...
19:21:26 <prophile> TYPES \D:/
19:21:34 <watermind> yeah
19:22:00 <michaelt> Noldorin: yes, I can imagine; I think though you will find plenty of such material, but not at the stage LYAH is pitched to.  Its actually pretty good for what it is; or I thought so
19:22:31 <johnw> Noldorin: have you seen http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf?
19:23:04 <Noldorin> michaelt, hmm. it just lost me when it got to (applicative) functors. there's zero motivation for it, and it rambles, so it's hard to pick out the nub of what's pertinent
19:23:09 <Noldorin> johnw, no, but I'll have a look!
19:23:32 <michaelt> what's wrong with a 'lax monoidal functor' or whatever they call it
19:24:17 <Noldorin> johnw, ah. that's more about doing maths in haskell it seems... which is cool (thank you), although I want to learn it as a general language first
19:25:21 <hakujin> Noldorin: Real World Haskell is an option: http://book.realworldhaskell.org/read/
19:25:24 <michaelt> Noldorin: the more mathematical characterization is that in an applicative functor you have (f a , f b) -> f (a,b) and the like
19:25:57 <chirpsalot> Is it just me or is the documentation for the state monad all over the place? :(. I want the new stuff?
19:26:00 <prophile> applicative functors are like burritos
19:26:27 <chirpsalot> Should you be using runState with the state monad now?
19:26:28 <Noldorin> hakujin, interesting. seems like it doesn't even cover functors though
19:26:49 <michaelt> chirpsalot: ah, you have an old tutorial or something
19:26:54 <khyperia> what are my options for IRC libraries?
19:27:11 <Noldorin> michaelt, that's an improvement on what I just read, for sure :)
19:27:36 <chirpsalot> michaelt: all of the tutorials I find seem to be old. Got a better one?
19:28:34 <michaelt> Noldorin: I guess you need a method to get a f () from nothing. but the interpretation in terms of <$> <*> is better suited to the language; they're interdefinable
19:28:47 <michaelt> chirpsalot: you mean on the StateT business in particular?
19:30:24 <chirpsalot> michaelt: trying to get the state monad in my brain... Current goal is writing a monte carlo pi approximator.
19:30:40 <johnw> Applicative is a monoidal functor specialized for function composition.  If a monoidal functor in general maps F (a ⋆ b) → F a ⊗ F b (the "lax" property means it can't go the other way), then if we specialize F to be an endofunctor in Hask, and ⋆ and ⊗ to both be function composition but in different type contexts, then we can arrive at Applicative
19:30:59 <johnw> not composition, I mean application
19:31:00 <johnw> a -> b
19:33:52 <michaelt> chirpsalot: anyway, what I think you bumped into is just a change a few years ago from the special non-transformer version, newtype State s a = State {runState :: s -> (a,s)} to just using the 'transformer' version
19:35:00 <michaelt> newtype StateT s m a = StateT {runStateT :: s -> m (a,s) } , runState is still used for the 'pure' case :: StateT s Identity a -> s -> (a,s)
19:35:11 <enthropy> chirpsalot: the definitions changed, but user code at most needs to be changed to use 'state' instead of 'State'
19:35:53 <michaelt> right, that's the typical problem, State isn't a constructor, but a defined function
19:36:09 <chirpsalot> So, that's the only difference that I have to worry about?
19:36:21 <chirpsalot> (thus far, anyway)
19:36:53 <chirpsalot> I don't really know much about monad transformers yet! Other than a vague idea of what they are used for.
19:37:13 <michaelt> If there is pattern-matching on State in the thing you're looking at there maybe be more problems, but otherwise you just replace it with 'state'
19:37:56 <chirpsalot> Ah. What motivated the change? Maybe I don't have the background to understand that yet.
19:38:20 <michaelt> chirpsalot: it is a little annoying, but it makes the whole system smooth; but it's a little less beginner friendly
19:38:24 <geekosaur> State used to be a standalone thing different from StateT
19:38:53 <michaelt> chirpsalot: but you can just define State yourself as I did above.  Write the Functor and Monad instances; it's worth doing I'd think.
19:38:57 <geekosaur> these days it is a type alias for StateT Identity, which means they're shared and work better but the old State constructor no longer exists, so a function `state` was added to replace it
19:39:51 <chirpsalot> michaelt: yeah... I'm pretty sure I understand the point of the state monad and what it does, but for some reason I find all of this to be a bit confusing. I guess part of it is that I know "something changed" and now I don't trust any tutorial because it might be "old".
19:40:25 <michaelt>  newtype State s a = State {runState :: s -> (a,s)} ; instance Functor (State s) where fmap f (State g) = State $ \s -> (...,...) etc
19:42:36 <michaelt> chirpsalot: But, there is another way of looking at it; you just have to define State yourself. The availability of the type hasn't changed.
19:44:52 <michaelt> Maybe there should be an 'untransformers' package with State, Writer, Reader and company.  Data.Monad.State or something.
19:46:27 <johnw> mtl has Control.Monad.State
19:47:13 <michaelt> SensibleOldTutorial.Monad.State
19:54:42 <chirpsalot> Thanks, though. Clears some things up :).
19:55:58 * hackagebot yi 0.7.1 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.7.1 (DmitryIvanov)
19:56:00 * hackagebot yi-contrib 0.7.1 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.7.1 (DmitryIvanov)
20:21:01 * hackagebot visual-prof 0.5 - Create a visual profile of a program's source code  http://hackage.haskell.org/package/visual-prof-0.5 (DanielVelkov)
20:31:57 <hcaulfield57> I'm trying to understand mtl (again), I'm looking at the Reader monad, but I'm just not getting it.
20:32:05 <hcaulfield57> I see this example runReader (ask >>= \x -> return (x*3)) 2 which make sense, but so what?
20:32:40 <dwcook> hcaulfield57, Reader a b is roughly the same as a -> b
20:33:03 <dwcook> It just hides away the parameter in the ask action
20:33:43 <dwcook> So that expression you just mentioned is like (\x -> x * 3) 2
20:34:38 <dwcook> In fact in evaluating that you'd probably eventually get to the expression I just mentioned
20:36:09 <hcaulfield57> Is there an up to date mtl tutorial? Most seem to be out of date, and I'm too dense to understand them
20:38:03 <hcaulfield57> dwcook: I think my real problem is with the type parameters, I get confused with things like ask :: m r
20:38:43 <startling> hcaulfield57: Reader is not super interesting
20:38:53 <dwcook> hcaulfield57, ah, you're looking at the polymorphic version, the method of MonadReader. If you're working with the type Reader, you can just set m = Reader r
20:39:04 <startling> hcaulfield57: you use it for two things: 1) stupid tricks in lambdabot, and b) as a monad transformer
20:39:24 <startling> :t (filterM, filterM (>))
20:39:24 <lambdabot> (Monad m, Ord a1) => ((a -> m Bool) -> [a] -> m [a], [a1] -> a1 -> [a1])
20:39:59 <startling> (the second one uses the Monad ((->) r) instance analogous to Reader r's)
20:40:17 <hcaulfield57> startling: I was trying to figure it out, becasue I assumed it would be the easiest
20:40:17 <hcaulfield57> When trying to learn Haskell, I think I understand everything up to MTL, then it all goes south
20:41:10 <startling> hcaulfield57, ok! so, Reader's (>>=) chains computations in a way that "hides" arguments that will be applied later.
20:41:33 <startling> hcaulfield57: I can walk you through writing the instance if you'd like, but if you haven't looked at Identity and Maybe it might be more productive to start there
20:41:35 <levi> Getting used to functions as instances of higher-kinded type classes takes a bit of getting used to.
20:42:22 <hcaulfield57> startling: I think I understand Maybe alright, but the more complicated monads I'm just not getting.
20:42:29 <startling> levi: you're right, I probably should not have brought that up yet.
20:42:45 <startling> hcaulfield57: ok. so, do you know what data Reader r a looks like?
20:43:03 <levi> Have you looked at functions as instances of simpler type classes like Monoid?
20:43:12 <dwcook> hcaulfield57, don't imagine Reader as anything special or complicated; it's sugar for functions, that's all
20:44:34 <hcaulfield57> startling: No, isn't it 'type Reader r = ReaderT r Identity', see I don't even know what that is
20:44:56 <startling> hcaulfield57: yeah, that's complicated, let's pretend it's simpler. :)
20:45:17 <startling> hcaulfield57, a "Reader r a" is a value of type 'a' that depends on a value of type 'r'.
20:45:17 <hcaulfield57> levi: Awhile ago I looked at Monoid, it's been a few months, I gave up on Haskell like 5 months ago, decided I wanted to try again today.
20:45:42 <startling> hcaulfield57, so, we'll say "data Reader r a = Reader (r -> a)". Does that make sense?
20:45:43 <hcaulfield57> startling: So r and a can be any type though?
20:46:07 <levi> hcaulfield57: Sometimes a bit of time away gives your brain a chance to digest what it learned last time.
20:46:13 <hcaulfield57> startling: Yes, you could make a Reader value by Reader and then a function that takes r and returns a right?
20:46:19 <dwcook> ReaderT isn't even that complicated; you can freely convert between ReaderT r m a and r -> m a, or functions from some value onto a monadic value
20:46:30 <hcaulfield57> levi: That's why I wanted to try, and because my beginner Java class is super boring.
20:46:36 <startling> hcaulfield57: a value of type Reader r a gets to pick which r it wants. You can have things like "Reader Int String" etc.
20:46:39 <startling> hcaulfield57: but yes.
20:46:54 <dwcook> But yeah, starting with the simpler Reader is a good idea
20:47:08 <hcaulfield57> startling: Yea, got that, I think
20:47:17 <startling> hcaulfield57: so, we need to write (>>=) and return for our Reader r if we want to show that it's a Monad. Are you familiar with those?
20:48:15 <hcaulfield57> startling: yes
20:48:41 <startling> hcaulfield57: ok, so "return :: a -> Reader r a" for our instance. Do you think you can write that?
20:49:14 <startling> don't overthink it. :)
20:49:27 <dwcook> If you can write a function a -> r -> a, you can write that one
20:49:40 <startling> shhh.
20:49:54 <dwcook> I already mentioned earlier that Reader r a is just r -> a :P
20:50:25 <hcaulfield57> startling: return a = Reader r a ??
20:50:32 <hcaulfield57> Sorry I'm rusty, it's been months
20:50:43 <michaelt> return a = Reader (\r -> ....)
20:51:23 <startling> hcaulfield57, where did "r" the value come from?
20:51:33 <startling> remember the type of our constructor Reader
20:51:55 <levi> hcaulfield57: It looks like you might be confusing type variables and value variables.
20:52:26 <hcaulfield57> levi: Yea I think so too
20:53:13 <hcaulfield57> Well could you to like return a = Reader (\r -> r a) ?
20:54:02 <jfischoff> would be correct to say higher rank types are specialized at runtime?
20:54:17 <jfischoff> s/would be/would it be
20:54:34 <dwcook> hcaulfield57, you don't have any information that says r is a function, so you can't apply it
20:54:57 <hcaulfield57> dwcook: Okay, I see that.
20:55:18 <startling> hcaulfield57, so, let's talk about sematics
20:55:25 <startling> hcaulfield57, return :: a -> Reader r a
20:55:49 <startling> hcaulfield57: that type signature says "take some value and turn it into a type that looks like it depends on a value of type r"
20:56:22 <startling> since we start out with a value of type 'a', we don't actually need to depend on a value of type 'r' to get it. Does that make sense?
20:56:40 <startling> It's the Reader that doesn't actually care what you give it.
20:57:12 <hcaulfield57> startling: somewhat
20:57:41 <dwcook> Much like how in a -> r -> a, there's nothing reasonable you can do with the r other than ignore it
20:57:53 <startling> hcaulfield57, so, we say return x = Reader (...)
20:58:37 <hcaulfield57> startling: Okay
20:58:37 <startling> hcaulfield57: the type of what we need to fit in that elipsis is "r -> a" ('a' is the type of 'x').
20:58:53 <hcaulfield57> got it
20:59:10 <startling> hcaulfield57: so, what's the elipsis? :)
20:59:51 <hcaulfield57> r -> a right?
20:59:59 <levi> That's its type
21:00:00 <dwcook> That's a type; you want a value
21:00:04 <startling> hcaulfield57: no, that's the type of that value.
21:00:08 <startling> hcaulfield57: what's the value?
21:00:13 <startling> hcaulfield57: it's a fill-in-the-blank
21:00:18 <hcaulfield57> a?
21:00:29 <levi> hcaulfield57: Write me a function that takes any value and returns 3
21:00:43 <hcaulfield57> f x = 3
21:00:49 <startling> right.
21:00:57 <levi> Now write it as a lambda expression
21:00:59 <startling> hcaulfield57: are you familiar with lambda notation?
21:01:07 <hcaulfield57> (\x -> 3)
21:01:11 <startling> hcaulfield57: perfect.
21:01:24 <startling> so, "return x = Reader (...)"
21:01:29 <startling> what's the ...?
21:02:46 <hcaulfield57> Just guessing: return x = Reader (\_ -> x)
21:02:56 <startling> hcaulfield57, that's exactly it.
21:02:58 <michaelt> awesome
21:04:02 <startling> hcaulfield57, so, the next thing we need is (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b
21:04:08 <startling> hcaulfield57: do you think you're up to it?
21:04:18 <hcaulfield57> Lemme try
21:04:51 <startling> hcaulfield57: I'll get you started: "Reader f >>= g = ..."
21:06:28 <codygman> What indent mode works with structured-haskell-mode in emacs?
21:07:02 <levi> Keep in mind that Reader r a is just a wrapper around r -> a, so when thinking about the types you can substitute (r -> a) for Reader r a, just as long as you remember you need to unwrap the Reader value to get at the function.
21:07:03 <OceanSpr1y> is "forall a. a -> Int" supposed to unify with "forall b. b -> b"?
21:07:12 <levi> codygman: It has its own indent mode.
21:07:13 <OceanSpr1y> no, right?
21:07:37 <codygman> levi: Interesting, something must be wrong then, because it's not indenting for me.
21:08:02 <startling> OceanSpr1y: it should unify to Int -> Int, I think
21:08:03 <levi> codygman: Are you hitting C-j instead of enter?
21:08:29 <codygman> levi: Yep.
21:08:45 <startling> :t let f = undefined :: forall a. a -> Int; g = undefined :: forall b. b -> b; in f `asTypeOf` g
21:08:46 <lambdabot> Int -> Int
21:08:48 <OceanSpr1y> startling: but the expressions are inside universal quantifiers
21:08:50 <startling> OceanSpr1y: ^
21:08:53 <OceanSpr1y> huh
21:08:55 <OceanSpr1y> HUH
21:09:06 <levi> codygman: Do you see its highlighting around the current expression?
21:09:07 <startling> OceanSpr1y: I think you're misunderstanding forall.
21:09:07 <hcaulfield57> Reader f >>= g = return (f g)
21:09:10 <hcaulfield57> I don't think that's right now
21:09:22 <codygman> levi: Yes, everything else seems to work except indentation
21:09:22 <startling> hcaulfield57: nope. you don't want to 'return' at all.
21:09:52 <michaelt> hcaulfield57: Reader f >>= g = Reader (\r -> ???)
21:10:01 <startling> hcaulfield57, something like this, yeah ^
21:10:21 <codygman> levi: Actually lsit indenting works, it is the first example using a guard that does not work.
21:10:24 <codygman> list*
21:10:42 <levi> OceanSpray: Haskell type variables have an implicit universal quantifier in prenex position (on the far left) by default.
21:11:45 <levi> codygman: To get the behavior you want, you may have to hit ) a time or two until it highlights the expression that you want the next line to be at the same level of.
21:12:24 <levi> I'm not a fan of the ) binding in SHM. I will probably bind that to something else if I try it again.
21:13:11 <codygman> levi: hit ")"? That just makes a parens. Were you assuming I was using vim?
21:13:26 <codygman> levi: Nevermind
21:13:29 <hcaulfield57> Yea, I'm confused
21:13:31 <levi> codygman: It shouldn't make parens if you're in SHM.
21:13:41 <carter> who else is happy cmccann is back on irc
21:15:18 <michaelt> hcaulfield57: when I get lost in things like this, I will occasionally write things like Reader r2a >>= a2Reader_r_b = Reader (\r -> ...r....)  . Its then sort of clear what I can do with r
21:16:36 <hcaulfield57> I think I probably need to start reviewing Haskell more and things will make more sense. I think I'm doing better, but it's slow progress
21:17:11 <bitemyapp> hcaulfield57: the pedagogy surrounding Haskell has a lot of room to improve.
21:17:27 <startling> hcaulfield57: it's possible. I would walk you through it more but suddenly I am very sleepy.
21:17:34 <hcaulfield57> Well this channel is pretty awesome so far!
21:17:39 <bitemyapp> hcaulfield57: This is my recommended sequence for learning Haskell: https://gist.github.com/bitemyapp/8739525
21:17:40 <hcaulfield57> startling: Me too haha!
21:17:56 <cmccann> carter: I ended up not having much time for hobby programming for a while
21:18:04 <carter> in a good way?
21:18:11 <cmccann> and then I kept thinking "oh, once the new GHC is out I'll get back into it"
21:18:16 <cmccann> and we can all guess how that worked out
21:18:22 <carter> delayed 4 months
21:18:25 <carter> for months
21:18:26 <carter> :)
21:18:29 <cmccann> yes
21:18:29 <carter> tis in RC now
21:18:41 <levi> hcaulfield57: You might want to take a step back from Monad and check out Monoid and Functor first. Functor is really straightforward to write instances for.
21:18:50 <carter> cmccann: i'm actually starting to get some of my libs ready :)
21:19:00 <michaelt> Oh, but it will come out soon, then, carter?  I installed the rc1 today, not sure why.
21:19:02 <levi> And both Monoid and Functor have TONS of practical uses.
21:19:03 <hcaulfield57> startling: Thanks for all the help, I really appreciate it, I'm sure I'll be back
21:19:16 <carter> michaelt: rc2 is due shortly
21:19:18 <startling> hcaulfield57: no problem! other people here would also probably be able to help
21:19:19 <carter> and release thereafter
21:19:20 <hcaulfield57> levi: I will look at them again, I remember understanding them, but like I said it was a long time ago
21:19:22 <cmccann> I'm looking forward to ghcjs being more approachable. that's supposed to be a thing in the new ghc, right?
21:19:26 <carter> yes
21:19:28 <cmccann> like just cabal install and go
21:19:30 <carter> thers some bug hunting
21:19:32 <carter> but yeah
21:19:39 <carter> cmccann: that saidm pure script seems cool too
21:19:41 <cmccann> I've been using the vagrant machine thing to play with it and it is a hassle.
21:20:02 <levi> Hmmm, I keep meaning to play with PureScript.
21:20:20 <carter> michaelt: cmccann  i'm allegedly getting a last bug fix patch into 7.8 shortly
21:20:27 <carter> if i can get that sorted out
21:20:35 <levi> I wonder how hard a lua backend for PureScript would be to write.
21:20:41 <carter> ooo
21:20:42 <carter> levi: do that
21:20:51 <carter> then haskell could sneak into game scripting langs
21:21:12 <startling> heh
21:21:12 <cmccann> so far I have a hackjob that converts .obj files into binary blobs suitable for gl and then compiled-to-js stuff that loads it via an xmlhttprequest and displays the model
21:21:18 <levi> carter: Have you seen lua fun? It's a functional programming library that targets the optimizations that LuaJIT does.
21:21:24 <carter> levi: yeah
21:21:26 <carter> i looked a teeny bit
21:21:41 <carter> a good jit customized to your langauge does magic
21:21:59 <levi> Can compile maps with lambdas down to tight loops!
21:22:02 <hcaulfield57> Although trying to learn Haskell the first time, has actually made other languages easier to learn I think.
21:22:17 <startling> ooh, purescript looks nice
21:22:28 <startling> hcaulfield57, I think I experienced that too fwiw
21:22:41 <bitemyapp> hcaulfield57: it does.
21:22:42 <cmccann> it handles normals and texture coords and all that so pretty nice
21:22:47 <michaelt> Oh I know why I installed it; I noticed that base now has the Foldable instances for base types that it should, e.g. Either.
21:22:54 <levi> hcaulfield57: It definitely teaches you how to think about programs in a more orderly way, I think.
21:23:01 <cmccann> the main obstacle has been getting distracted learning how to use blender :T
21:23:04 <codygman> In structured Haskell mode is it normal for me to type "foo<C-j>|" and it not indent the guard correctly? Am I expected to indent the guard myself?
21:23:27 <hcaulfield57> I picked up Java really fast, only having known C and some Haskell first
21:23:31 <levi> codygman: Did you do what I said with ) ?
21:23:41 <codygman> levi: It doesn't seem to do anything
21:23:52 <levi> Hmm.
21:24:15 <hcaulfield57> But generics in Java are confusingly similar to paramaterized data types but different enough it's confusing haha
21:24:20 <codygman> levi: Just to clarify "foo<C-j>|<Shift+0>"
21:25:52 <levi> Normally if you have a line "... | expression foo bar" it will have just "bar" hilighted, and when you hit ) it will expand the hilight back towards the "|".  When you have "expression foo bar" hilighted and you hit C-j, you should get the proper indentation and a pipe inserted for you.
21:27:13 <levi> hcaulfield57: Yeah, generics in Java are a bit confused by their nature. They were inspired by Haskell/ML parametric types, but they don't quite fit as cleanly with Java's subtyping system.
21:27:46 <levi> Plus, people compare them to C++ templates instead, and then get highly annoyed that their types are erased at runtime.
21:28:03 <hcaulfield57> levi: That's what confused me, they don't actually create new types.
21:29:15 <hcaulfield57> But I'm still pretty new to Java
21:29:38 <levi> That's the point of parametric polymorphism, though. When you write a paremetrically polymorphic function, it must behave identically for all types. So it only has to exist *once*. Whereas in C++, you have to generate a new function for every type you instantiate the template with.
21:29:38 <hcaulfield57> Whoever gave me that list of things to read for Haskell, thanks I'm taking a look right now
21:30:50 <hcaulfield57> levi: I was thinking like Maybe Char is different from Maybe Int, but it doesn't seem to be the case in Java
21:31:37 <levi> Maybe Char and Maybe Int are different types, but the functions that take Maybe a values can't tell the difference.
21:31:49 <levi> It is the same in Java, more or less.
21:32:00 <Iceland_jack> Just to make it clear, levi means values of type 'Maybe a'
21:32:10 <Iceland_jack> a is not an indefinite article
21:32:23 <hcaulfield57> Okay, yea I see what ou mean
21:33:22 <cmccann> note that in Java you have subtyping, which gives you entirely new ways to throw away type information by upcasting.
21:33:31 <cmccann> why limit yourself to just normal type erasure?
21:33:37 <levi> Maybe is a type constructor; it's a type that has kind * -> *. It takes a type of kind * and forms a new type of kind *.
21:33:38 <Iceland_jack> hcaulfield57: We can define a function which uses the value of 'Maybe a' regardless of the actual type instantiated to 'a'
21:33:38 <Iceland_jack>     foo :: Maybe a -> [a]
21:33:38 <Iceland_jack>     foo (Just x) = [x, x, x]
21:33:38 <Iceland_jack>     foo Nothing  = []
21:33:41 <Iceland_jack>  
21:34:28 <Iceland_jack> where "foo (Just 'u')" evaluates to "uuu" and "foo (Just 3)" evaluates to [3,3,3]
21:34:41 <levi> So 'Maybe Int' is a normal type of kind *, while 'Maybe' is a type of kind * -> *, or a 'higher-kinded' type.
21:35:08 <hcaulfield57> Yea, I understand kinds I think, and Iceland_jack's example makes sense
21:36:09 <hcaulfield57> Just some of the abstraction in Haskell is really hard for me, I think it's easier to think about int's and char's, but I'm a little slow
21:36:31 <Iceland_jack> hcaulfield57: One step at a time, you don't really need to worry about kinds
21:36:53 <levi> This property of paremetricity is actually nice, because it means that the signature of a function places more constraints on what functions actually inhabit the type, which can help guide you to the right implementation when you get the hang of reasoning about it.
21:36:55 <Iceland_jack> hcaulfield57: If you want to understand kinds just think of things with kind * as being concrete types (Int, (), Bool, [String], ...) and * -> * being type constructors (Maybe, [], ...)
21:37:23 <hcaulfield57> I think I have kinds figured out, but I tried to understand Arrows once, and I about went insane
21:37:38 <johnw> i keep wondering why people want to learn Arrows
21:37:57 <Iceland_jack> Yeah there are definitely more important concepts to learn than Arrows
21:38:22 <Iceland_jack> @kind []
21:38:23 <lambdabot> * -> *
21:38:24 <levi> Anyway; type classes initially applied only to normal types of kind *; they were invented so you could use the same numeric operators for different kinds of numbers, and so you could compare lots of different things for equality with the equals operator.
21:38:25 <dwcook> The way I hear it, most people don't touch Arrow stuff other than specializing to (->)
21:38:25 <Iceland_jack> @kind [] Int
21:38:26 <lambdabot> *
21:38:29 <johnw> i've yet to ever use them, and I use a whole lot of crazy features
21:38:41 <hcaulfield57> My goal is to get a good handle one what I learned few months ago, shouldn't be tough, then to learn the mtl things
21:39:07 <levi> I think applicative functors stole a lot of the use cases that arrows were aimed at.
21:39:08 <Iceland_jack> hcaulfield57: I don't know what you learned a few months ago but it sounds like a good plan
21:39:18 <Iceland_jack> just don't give up :)
21:39:32 <hcaulfield57> Iceland_jack: Thanks man :) I learned everything up to Monads, and then gave up
21:40:38 <Iceland_jack> @kind (,,,,,,,)
21:40:39 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> *
21:41:10 <levi> The idea to apply Monads to IO actually predated the introduction of 'constructor classes', i.e. type classes that apply to types of kind * -> *.  Monads were much more awkward to use!  There's an interesting paper by Guy Steele where he invents something he calls "Pseudomonads" to try to get around the awkwardness of using Monads before the Monad type class and Monad Transformers were introduced to normal Haskell programming.
21:42:41 <dwcook> @kind ReaderT
21:42:42 <lambdabot> * -> (* -> *) -> * -> *
21:44:19 <levi> Actually, I'm not sure if Monads were applied to IO at that point yet; maybe people were just playing with the idea of Monads in functional programs. It was long before I first started with Haskell, anyway.
21:44:23 * dwcook wonders if there are people crazy enough to write/use monad transformer transformers
21:45:03 <johnw> you mean some type u like "u t m b"?
21:45:34 <dwcook> A type :: ((* -> *) -> * -> *) -> ((* -> *) -> * -> *), I think
21:45:37 <prophile> monad transformer transformers get a little hairy with the "lift" operation
21:46:05 <prophile> I couldn't work it out
21:46:10 <dwcook> prophile, hairy = requiring GHC extensions?
21:46:18 <levi> There's Tekmo and his MFunctor class.
21:47:07 <prophile> I think it did require UndecidableInstances of something of that ilk but I was more referring to getting the types right
21:47:10 <hcaulfield57> How does this work? https://github.com/NICTA/course/
21:47:16 <levi> Not quite the type you describe, but a bit hairy nonetheless.
21:47:42 <levi> hcaulfield57: You check it out and work through the .hs files, which have a bunch of unimplemented functions.
21:48:03 <levi> hcaulfield57: It's got a test suite, so as you get them implemented you can check to see if they pass the tests.
21:48:22 <hcaulfield57> Oh, I thought you just entered ghci and was like interactive or something
21:50:06 <levi> Nope; that's a common misconception though.
21:50:39 <levi> Would be a good exercise to work through, anyway.
21:53:08 <levi> Control.Monad.Morph has some head-scratchers in it.
21:53:19 <johnw> i mostly just use "hoist"
21:54:12 <joelteon> what's hoist from?
21:54:21 <syllogismos> hcaulfield57 im midway through nicta..
21:54:27 <johnw> mmorph
21:54:40 <syllogismos> not really midway.. around 40%
21:56:07 <hcaulfield57> syllogismos: I think I will do it, but I gotta practice a little first
21:56:12 * hackagebot yesod-form 1.3.5.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.5.2 (MichaelSnoyman)
21:56:23 <johnw> if you have a Monad m => m a, you can map a -> b to make an m b with liftM.  And if you have that same Monad m => m a, you can map forall a. (Monad m, Monad n) m a -> n a to make a Monad n => n b with hoist.
21:56:41 <johnw> the difference from a natural transformation is that the Monad is preserved
21:56:51 <johnw> aka "monad morphism"
21:57:10 <johnw> sorry, n a
21:57:47 <syllogismos> you finish all the error "todos" in the File.hs and run > doctest -isrc -Wall -fno-warn-type-defaults src/course/File.hs
21:58:18 <syllogismos> hcaulfield57 you might also find exercism.io helpful..
21:59:30 <syllogismos> you write some code and people review it and make suggestions.. personally i found it very helpful..
22:00:09 <syllogismos> by some code I mean, they give you exercises and you have to do them.. not just any haskell code
22:00:52 <hcaulfield57> hmm interesting
22:07:37 <gabemc> Anybody have any ideas about why when I include DeriveDataTypeable as a language extension, I still get " Not in scope: type constructor or class `Data'" ? Am I missing an import somewhere?
22:08:23 <joelteon> import Data.Data
22:08:28 <joelteon> (seriously)
22:08:58 <monochrom> yes, extensions don't bring any names into scope, names are always from modules
22:09:04 <gabemc> Interesting. Is that a new thing. I see nothing about that in the docs I'm reading around the web.
22:09:07 <gabemc> ?
22:09:18 <joelteon> well, it's in base
22:09:52 <monochrom> similarly, for use of ConstraintKind, the name Constraint is also from a module, not from the extension
22:10:23 <gabemc> I'm trying to use CmdArgs, and I'm following http://spin.atomicobject.com/2012/12/13/using-haskells-cmdargs-package/ , but it makes no reference, which is why I was confused. Something must have changed since then.
22:10:52 <monochrom> I bet nothing has changed.
22:11:18 <monochrom> yes or no: is "Data" a reserved word or not. law of excluded middle.
22:11:38 <shachaf> gabemc: Are you following it exactly?
22:11:44 <monochrom> if it is not a reserved word, then an extension has no business adding it.
22:11:50 <enthropy> the System.Console.CmdArgs exports the Data class
22:11:51 <shachaf> If you follow it exactly, I bet that it would work.
22:12:17 <gabemc> Hah. The law of excluded middle does not apply universally in Intuitionistic Propositional Logic.
22:12:54 <monochrom> that is right but useless. intuition logic does not apply universally. period.
22:13:07 <gabemc> Ahhhh.... I'm working in a separate submodule, not importing the CmdArgs package. That explains everything. Thanks!
22:13:59 <monochrom> people follow logical conclusions of rules too little, and think "I want this" too much.
22:14:11 <joelteon> in type Foo a = (Eq a, Ord a), is Foo a "constraint kind"? is that where the name of the extension comes from?
22:14:21 <monochrom> I think yes
22:14:22 <joelteon> or does it literally refer to the Constraint kind
22:14:38 <monochrom> both
22:14:51 <shachaf> Foo is not a kind
22:15:22 <joelteon> well I was curious why ghci doesn't like :k Foo in that case
22:16:46 <monochrom> :set -XConstraintKinds and try again
22:17:34 <shachaf> For the same reason it doesn't like "type Foo a = Maybe a" and then ":k Foo"
22:17:50 <monochrom> ah
22:18:27 <monochrom> "Type synonym `P' should have 1 argument, but has been given none" says it all
22:18:46 <monochrom> (I call it P. Foo is overrated.)
22:20:04 <joelteon> shachaf: ok, what is it
22:20:23 <shachaf> Reading the error message is going too far.
22:20:37 <monochrom> it has to be "Foo Int" or "Foo Bool" or "Foo Char"
22:20:44 <monochrom> "Type synonym `Foo' should have 1 argument, but has been given none" says it all
22:21:19 <joelteon> so why does let foo a = Just a; :t foo work
22:21:53 <monochrom> because type synonyms suffer more restrictions
22:22:04 <joelteon> you can define partially applied type synonyms and GHC understands them
22:22:32 <monochrom> ok, are you trying to argue with people?
22:22:48 <joelteon> no, I'm just confused and annoyed
22:22:49 <monochrom> I am not saying arguing is bad. but choose your target.
22:22:52 <utkarsh> Can I shorten this using some inbuilt function? `a <- getContents; let b = f a; print b`
22:23:00 <joelteon> I'll let it rest
22:23:13 <monochrom> arguing with people here is pointless. argue with GHC source code. fork it and modify it to do what you want.
22:23:15 <c_wraith> utkarsh: fmap f getContents >>= print
22:23:22 <shachaf> do { b <- f <$> getContents; print b }
22:23:35 <shachaf> Or (getContents >>= (print . f))
22:23:46 <shachaf> (<$>) is the same as fmap
22:24:03 <c_wraith> and <- in a do block turns into >>=
22:24:16 <c_wraith> Which is why the first version shachaf gave is identical to what I suggested. :)
22:24:19 <utkarsh> c_wraith, shachaf, thanks!
22:24:53 <utkarsh> `print =<< parseString <$> getContents` looks a bit cleaner to me
22:28:20 <bergmark> i prefer to use =<< over >>= when <$> or . are involved so you can read the expression rtl
22:28:54 <jle`> >>= introduces such a weird bipolarism in haskell anyway
22:29:06 <jle`> i feel like it's only popular because of do notation
22:29:35 <jle`> also (>>>)
22:29:38 <jle`> who even does that
22:29:47 <monochrom> I do
22:29:52 <jle`> oh ok :)
22:30:00 <jle`> (>>>) is awesome :D
22:30:03 <bergmark> >>> forces you to use parens
22:30:10 <bergmark> if you mix it with monadic operators
22:30:51 <jle`> hm?
22:31:19 <bergmark> :t \f g h -> f >>= g >>> h
22:31:19 <lambdabot>     Precedence parsing error
22:31:20 <lambdabot>         cannot mix `>>=' [infixl 1] and `>>>' [infixr 1] in the same infix expression
22:32:03 <jle`> did you mean that as a good thing or as a bad thing?
22:33:35 <bergmark> bad, i always want f >>= (g >>> h), not (f >>= g) >>> h
22:34:17 <ion> h . g =<< f
22:34:28 <bergmark> right, that's why i use =<< :-)
22:34:40 <jle`> i just mean tthat (>>>) and (>>=) (and (>=>) etc.) invert the normal 'pure' right-to-left style in the rest of haskell land
22:34:56 <jle`> and i feel like we'd all be using (=<<) if it weren't for do notation
22:35:09 <jle`> it's weird when you have to jump back and forth in your mind
22:35:10 <bergmark> yeah, i got that
22:35:11 <cmccann> don't forget the best possible use for (>>>)
22:35:13 <cmccann> @type (>>>) <<< (>>>) <<< (>>>) <<< (>>>)
22:35:14 <lambdabot> Category cat => cat a b -> (((cat a c3 -> c2) -> c1) -> c) -> ((cat b c3 -> c2) -> c1) -> c
22:35:33 <jle`> cmccann: yes that is the only legitimate usage of (>>>)
22:36:32 <cmccann> quite so
22:43:32 <kaction> @where ops
22:43:33 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:43:51 <kaction> @:t id
22:43:51 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
22:43:58 <kaction> @t id
22:43:58 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:44:14 <kaction> @id
22:46:20 <Iceland_jack> kaction: Why did you notify the ops?
22:49:23 <stevejb> hello, trying to install ghc 7.8 RC1 on amazon linux
22:49:31 <stevejb> I get thef ollowing error: checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory
22:51:01 <stevejb> installing gmp-devel only gives me libgmp.so.3
22:54:27 <johnw> try libgmp10?
22:55:50 <stevejb> is that installable with yum?
22:55:58 <johnw> oh, i don't know
22:55:59 <stevejb> I don't know much about how yum works. I usually use arch
22:56:08 <johnw> yum search libgmp10
22:56:31 <stevejb> no results. I just built it from source. I will give that at try
22:58:58 <stevejb> ack, now need to upgrade glibc :)
23:12:52 <stevejb> johnw: I installed libgmp by hand, and ./configure seemed to work correctly, but trying to run ghc does not work, and I get an undefined reference to some gmp function
23:13:10 <johnw> :(
23:13:40 <stevejb> indeed!
23:21:22 * hackagebot snaplet-css-min 0.1.0 - A Snaplet for CSS minification  http://hackage.haskell.org/package/snaplet-css-min-0.1.0 (TimothyJones)
23:27:15 <monochrom> depending on where you put libgmp, you may need one of: "sudo ldconfig"; play with LD_LIBRARY_PATH
23:27:59 <stevejb> monochrom: thanks. It seems related to http://www.haskell.org/pipermail/glasgow-haskell-users/2014-February/024640.html
23:28:11 <monochrom> it is a common user oversight to put *.so in /usr/local/lib and then do not know that "sudo ldconfig" is necessary
23:28:36 <stevejb> I built libgmp with --prefix-/usr
23:28:42 <stevejb> so I think everything went in /usr/lib
23:28:52 <monochrom> actually, that also requires sudo ldconfig
23:29:02 <stevejb> hmm...okay I will have to try that.
23:29:14 <stevejb> I got frustrated and terminated my instance
23:29:15 <stevejb> :)
23:29:29 <monochrom> as you can see from post-install scripts of every bloody deb package and rpm package
23:30:12 <stevejb> so, I can just build libgmp, then sudo make install, then sudo ldconfig
23:30:24 <monochrom> hrm, wait, I think I misremembered, /usr/lib and /lib don't quite require ldconfig. but postinstall scripts do it anyway.
23:31:23 * hackagebot snaplet-css-min 0.1.1 - A Snaplet for CSS minification  http://hackage.haskell.org/package/snaplet-css-min-0.1.1 (TimothyJones)
23:31:29 <stevejb> so, is the issue that ghc somehow does not know where libgmp is, or is libgmp somehow installed incorrectly
23:31:37 <monochrom> then again, ldconfig does several things. /usr/local/lib needs ldconfig for one reason. /usr/lib may need ldconfig for a different reason
23:31:55 <monochrom> the issue is ld does not know where libgmp is
23:32:06 <monochrom> and dlopen. and the kernel. etc etc
23:32:21 <stevejb> ah okay. I really don't know a ton about systems stuff.
23:32:31 <stevejb> thank you for the explanation
23:36:24 <monochrom> the only reason I dabbled into this stuff is that I wanted to make *.so from Haskell code and let C programs use it. since Haskell *.so are put in non-standard places, I had to dig up how to tell exes to find it. and it turns out to be a pretty messy story.
23:37:31 <monochrom> http://www.vex.net/~trebla/haskell/so.xhtml
23:37:40 <stevejb> thanks
23:37:46 <stevejb> so, I just built libgmp
23:37:49 <stevejb> sudo make install
23:37:51 <stevejb> sudo ldconfig
23:37:51 <stevejb> ?
23:37:58 <monochrom> I think so
23:38:25 <stevejb> ok let me try something
23:38:59 <stevejb> I just made a new instance. I am guessing that ./configure will still complain about glibc
23:40:18 <stevejb> no, I just downloaded the ghc 7.8 x86_64 and get
23:40:19 <stevejb> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory
23:40:19 <stevejb> configure: error: cannot determine current directory
23:47:01 <metanat> can someone explain what is going on when I do something like map (* 2) x? So (*) is a infix operator, but why can I curry the second argument?
23:47:15 <metanat> ( * )
23:47:23 <Cale> (* 2) is translated to (\x -> x * 2)
23:47:33 <metanat> yep, but why?
23:47:43 <metanat> is there something special going on?
23:47:45 <Cale> It's special syntax
23:48:03 <Cale> You can do it with any infix operator (except subtraction because of negation)
23:48:48 <shachaf> This is called a section.
23:48:53 <shachaf> http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
23:49:30 <metanat> oh right, because it isn't the same as ( * ) 2 ...
23:49:46 <shachaf> That article is nearly correct. Cale's translation is even more correct.
23:50:50 <metanat> Cale's translation is in the article
23:50:54 <Cale> Yeah, the translation only produces a lambda term in the case of right sections, and in the left section case just applies the function.
23:51:02 <metanat> well, a form of it \x -> x ^ 2
23:51:11 <metanat> thanks all
23:51:57 <shachaf> No, it's specified in the report to be (\x -> 2 * x)
23:52:13 <shachaf> You need an extension in GHC to make (2 *) translate into (*) 2
23:53:39 <metanat> i don't follow
23:55:12 <pavonia> shachaf: What extension is that?
23:55:24 <shachaf> metanat: It's not a very important detail.
23:55:29 <shachaf> pavonia: PostfixOperators
23:55:37 <shachaf> (Even in that case I'm not sure whether it eta-expands or not.)
23:56:27 * hackagebot linux-file-extents 0.1.0.0 - Retrieve file fragmentation information under Linux  http://hackage.haskell.org/package/linux-file-extents-0.1.0.0 (MariosTitas)
23:56:43 <shachaf> > let ($$) = succ in (5 $$)
23:56:44 <lambdabot>  6
23:56:53 <shachaf> > let ($$) x = undefined in (5 $$) `seq` ()
23:56:54 <lambdabot>  *Exception: Prelude.undefined
23:57:18 <pavonia> I think this is just confusing beginners
