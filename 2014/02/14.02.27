00:01:10 <codygman> Is it true that monad composition keeps walking through the computation after encountering Nothing as said here: http://www.reddit.com/r/programming/comments/1z1d44/at_last_c_is_getting_sometimes_called_the_safe/cfpsx65
00:02:17 <milfjord> I'm just gonna mumble something about associativity
00:03:19 <jle`> can i have a Data.Map intersection with 'default values' on one of the maps?
00:03:35 <jle`> intersectionWith, i mean
00:03:49 <jle`> something like zipWith f xs (ys ++ repeat def)
00:03:57 <pavonia> > do { x <- Just 1; y <- Nothing; z <- error "foo!"; return (x,y,z) }
00:03:58 <lambdabot>  Nothing
00:04:10 <pavonia> Aw, he left
00:05:37 <johnw> @src Maybe (>>=)
00:05:37 <lambdabot> (Just x) >>= k      = k x
00:05:38 <lambdabot> Nothing  >>= _      = Nothing
00:05:41 <johnw> that pretty much answers it
00:05:54 <carter> short circuits ftw
00:05:56 <carter> ok
00:05:58 <carter> night all
00:06:08 <jle`> night carter
00:08:00 <pavonia> jle`: So you want to replace everything in m1 if it also is in m2, but give it a default value if it isn't in m2?
00:08:59 * hackagebot time-exts 2.0.0 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-2.0.0 (EnzoHaussecker)
00:08:59 * hackagebot tiempo 0.0.0.0 - Specify time intervals in different units (secs, mins, hours, etc.)  http://hackage.haskell.org/package/tiempo-0.0.0.0 (RomanGonzalez)
00:16:02 <jle`> pavonia: i want to combine m1 and m2 with a combining function, with m2 having a default value if it's in m1 but not in m2
00:17:09 <pavonia> I think you could use combineWithKey for that
00:18:33 <jle`> pavonia: where is that?
00:18:51 <pavonia> in Data.Map
00:19:26 <pavonia> jle`: Oh sorry, it's called mergeWithKey
00:19:56 <riceandbeans> is /= the same as != ?
00:20:14 <pavonia> (/=) is "not equal"
00:20:29 <riceandbeans> right
00:20:38 <riceandbeans> to the rest of the world, that's !=
00:20:40 <pavonia> I don't know what (!=) is
00:20:57 <pavonia> Ah, you mean other languages
00:21:29 <riceandbeans> yeah
00:21:35 <riceandbeans> well, some use <>
00:21:39 <riceandbeans> but still
00:21:47 <riceandbeans> != is pretty universally understood
00:21:53 <riceandbeans> ! negates in general
00:22:00 <pavonia> Well, /= is closer to the mathematical symbol than !=, I guess that's why it was chosen
00:22:06 <flux> pascal, modula and Objecti Caml have <> !
00:22:16 <riceandbeans> flux: I said some use <>
00:22:19 <flux> to add to the confusion OCaml also has !=, which is for comparing identity :)
00:22:39 <riceandbeans> flux: that reminds me of PHP that I hate
00:22:43 <riceandbeans> ===
00:22:45 <flux> riceandbeans, yes, didn't notice that as I started checking for facts before you said that :)
00:22:51 <riceandbeans> same type
00:23:02 <riceandbeans> !== not the same type
00:23:07 <riceandbeans> I hate PHP
00:23:28 <riceandbeans> yet I somehow love perl and the secret operators
00:23:50 <flux> haskell should just use ≠
00:24:14 <Adeon> IS NOT EQUAL TO
00:24:35 <pavonia> @base-unicode-symbols
00:24:35 <lambdabot> Unknown command, try @list
00:24:41 <pavonia> @hackage base-unicode-symbols
00:24:41 <lambdabot> http://hackage.haskell.org/package/base-unicode-symbols
00:25:05 <flux> great! with that it finally becomes acceptable to do copy'n'paste-programming ;-)
00:25:53 <inr> riceandbeans, ada and fortran also use /= :-)
00:27:04 <riceandbeans> ada makes more sense to me than haskell so far
00:27:23 <jle`> yeah who doesn't use ≠
00:27:26 <riceandbeans> ada is weird and ridiculously strictthough
00:27:55 <Cale> Also Eiffel
00:28:06 <riceandbeans> what causes buffer overflows is C just sets a variable to 0 in ada
00:28:11 <riceandbeans> it's weird
00:28:16 <pavonia> riceandbeans: What doesn't make sense to you in Haskell?
00:28:39 <riceandbeans> pavonia: I'm reading learn you a haskell, while doing 5 other things at the same time right now
00:28:44 <Cale> I would say Haskell is an order of magnitude stricter than Ada is.
00:29:07 <riceandbeans> Cale: in ada, your file name must match your package name
00:29:17 <riceandbeans> if it doesn't the compiler will turn you away
00:29:25 <Cale> That's generally true in Haskell as well.
00:29:30 <Cale> (module name)
00:29:36 <Dtgr> riceandbeans: and I think such features should not exist in any language
00:29:37 <riceandbeans> module, package, same thing
00:29:41 <Cale> yeah
00:29:56 <riceandbeans> Dtgr: yeah, that is an annoying one
00:30:26 <Cale> Well, in the Haskell world, a "package" is an even bigger unit of structure, consisting of a bunch of related modules for distribution.
00:30:26 <riceandbeans> new random question
00:30:34 <riceandbeans> oh good
00:30:45 <riceandbeans> more terms that translate differently to haskell
00:30:48 <riceandbeans> :)
00:31:10 <riceandbeans> let's say I'm in BSD and I write haskell and I want it to run on Windows
00:31:15 <Cale> Well, you have to expect with any language that words are going to be used differently
00:31:32 <riceandbeans> is that a huge thing?
00:31:48 <Cale> riceandbeans: Shouldn't be too hard.
00:31:48 <riceandbeans> I'd assume not because everything is static
00:32:04 <Cale> You'll have to avoid bindings to C libraries which don't exist on Windows of course.
00:32:30 <Cale> But generally, it's easy to write things which are cross-platform.
00:32:52 <Cale> (at least, as easy as could reasonably be expected)
00:37:36 <johtso> hmm, when pattern matching, is there a nicer way to match if either of two arguments match a certain value, other than defining two patterns? I seem to have this problem with all binary functions..
00:39:01 <flux> no, other than a guard clause, but that's perhaps missing the point :)
00:42:53 <Cale> johtso: It can even matter (for strictness) which one you match first. If you don't care about that though, sometimes you can turn things around and handle those as the fallthrough cases.
00:44:29 <Cale> johtso: For example, if you were defining logical implication on Bool, it would be more concise to match:  implies True False = False  and then handle the rest like  implies _ _ = True
00:46:19 <riceandbeans> how do I close haskell?
00:46:45 <Axman6> "close haskell"?
00:46:50 <Axman6> do you mean exit GHCi?
00:46:58 <Axman6> if so, :quit
00:47:23 <Dtgr> ctrl+d works as well
00:47:26 <Dtgr> at least in unixes
00:49:36 <milfjord> ^Z, kill %1
00:49:43 <tsukimori> :q
00:50:20 <Axman6> I guess riceandbeans doesn't really want help...
00:50:51 <riceandbeans> milfjord: that's cheating
00:50:58 <riceandbeans> but yeah I meant ghci
00:51:36 <johtso> can I have a type constraint of TypeA OR TypeB?
00:51:53 <milfjord> no
00:52:09 <milfjord> @src Either
00:52:09 <lambdabot> Source not found. Where did you learn to type?
00:53:28 <johtso> I'm trying to write something a bit like an addition function, that can take two different types
00:55:05 <pavonia> johtso: If you want overloaded function, you'd have to use type classes
01:03:34 <mm_freak> jle`: identifiers generally mean trouble, because instead of just using a value you now reference it…  instead of just pattern matching you now need to perform a lookup, which, as you know has a Maybe in there…  in many cases you know that you will always get Just, but only you know that; it's not encoded in types or known to the compiler
01:03:58 <jle`> ah
01:04:05 <jle`> well i kinda handle the latter part
01:04:09 <mm_freak> jle`: effectively identifiers make you boolean-blind, so they are good/bad for the same reasons that 'head' and 'tail' are good/bad
01:04:29 <jle`> if there is no corresponding input stream, then you define a default input
01:04:41 <jle`> oh i'm not sure if i explained the context well enough
01:05:05 <jle`> maybe the way i am using it is different than the bad way
01:09:00 <jle`> did you catch the conversation i had with johnw?
01:09:53 <mm_freak> jle`: yes, and if i got this right you're using a combination of switchting and id-indexed wires
01:13:15 <jle`> so it's a dynamic Map of wires
01:13:24 <jle`> whose input streams come in inside a Map
01:13:55 <jle`> so it is...
01:14:11 <jle`> internally holding a Map k (Wire a b)
01:14:30 <jle`> and the total wire is Wire (Map k a) (Map k b)
01:15:06 <jle`> or more specifically Wire (Event [Wire a b], Map k a) (Map k b)
01:17:38 <adas> hoogle or hayoo?
01:19:10 <adas> im confused about which one to use? maybe i can use both..but does the haskell community prefer one over the other?
01:19:44 <pavonia> adas: hoogle is for query by type, hayoo for query by name
01:20:36 <adas> oh cool.. i thought both could query by type and by name and that one was simply better than the other.
01:22:24 <mm_freak> jle`: have you modelled this in the language of behaviors and events?
01:22:37 <kamatsu> so, i know this isn't the right place to ask, but it's for an ICFP submission so I suppose it's kosher
01:22:50 <pavonia> adas: You can search for names in hoogle too, but yahoo usually yields more results
01:22:58 <pavonia> *hayoo :)
01:23:04 <kamatsu> LaTeX keeps inserting line-breaks to wrap my equations
01:23:08 <jle`> mm_freak: i have not, actually
01:23:18 <mm_freak> jle`: you should
01:23:28 <kamatsu> sometimes halfway through a formula in a non-pretty way :(
01:23:38 <jle`> i actually haven't ever attempted to do it with wires carrying wires
01:23:48 <jle`> behaviors returning behaviors
01:23:58 <jle`> (is that what this even is?)
01:24:18 <mm_freak> jle`: (Ord k) => Event [Behavior a -> Behavior b] -> Behavior (Map k a) -> Behavior (Map k b)
01:25:27 <jle`> oh that's neat
01:25:32 <pavonia> kamatsu: Inline or display equations?
01:25:47 <jle`> (technically it also has to be Enum k because the key is incremented)
01:25:51 <jle`> hm
01:25:56 <jle`> so my previous wire zipper
01:26:07 <jle`> which kept an internal list of wires and zipped the list with its inputs
01:26:10 <jle`> would have been...
01:26:34 <jle`> Event [Behavior a -> Behavior b] -> Behavior [a] -> Behavior [b] ?
01:27:00 <jle`> wait, what does Behavior a -> Behavior b mean?
01:27:47 <jle`> Behavior a is Time -> a ?
01:28:06 <jle`> so Behavior a -> Behavior b is (Time -> a) -> (Time -> a) ?
01:28:08 <jle`> er
01:28:15 <jle`> (Time -> a) -> (Time -> b) ?
01:29:08 <pavonia> Conceptually, yes
01:29:40 <jle`> and Event a is [(Time,a)] ?
01:29:46 <jle`> so...
01:30:12 <jle`> Event [(Time,[(Time -> a) -> (Time -> b)])] -> ...
01:30:16 <jle`> let me think about what this means.
01:31:18 <mm_freak> jle`: yes, spell out the actual types
01:31:48 <mm_freak> jle`: http://hub.darcs.net/ertes/wires/browse/Control/Wire/Model.hs
01:33:11 <pavonia> "Event [Behavior a -> Behavior b] -> Behavior [a] -> Behavior [b]" -- Is that really the correct type?
01:34:25 <mm_freak> pavonia: well, not quite
01:34:31 <mm_freak> it's an approximation
01:34:52 <mm_freak> the problem with AFRP in general is that there is no 'Behavior' wrapper
01:35:14 <mm_freak> so in principle 'a' could end up being an event instead of a behavior
01:36:23 <CindyLinz> Is there a handy function in Haskell that makes ["abc", "def", "xx"] into "abc,def,xx" ?
01:36:41 <mm_freak> CindyLinz: intercalate ","
01:36:47 <mm_freak> :t intersperse
01:36:48 <lambdabot> a -> [a] -> [a]
01:36:58 <CindyLinz> !
01:37:03 <CindyLinz> mm_freak: Thanks!
01:37:21 <jle`> > @src intercalate
01:37:22 <lambdabot>  <hint>:1:1: parse error on input `@'
01:37:24 <jle`> heh
01:37:27 <mm_freak> > intercalate "," ["abc", "def", "xx"]
01:37:28 <lambdabot>  "abc,def,xx"
01:37:28 <jle`> @src intercalate
01:37:28 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
01:37:35 <jle`> yeah, it's defined in terms of intersperse
01:39:34 <bahamas> hey. in lyah, why does the author define the type signature of replicate' as replicate' :: (Num i, Ord i) => i -> a -> [a]. the original replicate has type signature replicate :: Int -> a -> [a]
01:40:20 <Feuerbach> bahamas: he just decided to generalize it for some reason. Nothing deep here, really
01:40:28 <CindyLinz> I think that it should be Integral
01:41:27 <jle`> yeah Integral makes more sense than Num >.>
01:41:30 <quicksilver> with Ord you can manage without integral
01:41:36 <quicksilver> presumably that's the point of it
01:41:42 <jle`> ah
01:41:55 <quicksilver> keep subtracting one until <1 or <0 (depending what you think it's supposed to mean)
01:42:05 <quicksilver> or even <0.5 might be another reasonable choice
01:42:32 <Feuerbach> that would require fractional
01:42:59 <quicksilver> <0.5 would, yes
01:43:04 <bahamas> Feuerbach: aha.
01:43:17 <pavonia> replicate 3.75 'o' == "oooc"?
01:43:19 <bahamas> how do you guys remember all the different types and types classes and the relationships between them?
01:43:38 <quicksilver> bahamas: (1) practice (2) ghci can tell me any I forget
01:43:56 <bahamas> quicksilver: does ghci say what types implement a type class?
01:44:06 <Feuerbach> yes, :i Class
01:44:23 <Feuerbach> although the instances have to be in scope
01:44:38 <Feuerbach> e.g. :i Num
01:44:40 <quicksilver> bahamas: yes, and also what classes a type implements
01:44:44 <quicksilver> bahamas: see :i Int
01:45:49 <jle`> that and also ghc errors
01:45:52 <jle`> :)
01:46:10 <jle`> i usually leave my typeclass restrictions off until it nags me
01:46:21 <bahamas> oh, cool. this is very helpful
01:46:58 <quicksilver> bahamas: good familiarity with exploring stuff in ghci is the key to learning quickly
01:47:07 <quicksilver> because you can try stuff so fast, in a REPL
01:47:52 <bahamas> quicksilver: I agree. I'm used to python where I use the REPL a lot as well
01:48:46 <bahamas> I like the fact that ghci also shows function that use a type class as a restriction
01:50:27 <bahamas> can I see all functions that apply to a data structure? for example, all functions that apply on lists?
01:54:22 <quicksilver> bahamas: that would be a long list :) hoogle will help you do searches along those lines.
01:54:33 <quicksilver> bahamas: http://www.haskell.org/hoogle/
01:54:54 <quicksilver> bahamas: try, for example, typing "[a] -> Int" into the search box
01:55:38 <jle`> is there a sequenceA for Monads ?
01:55:54 <quicksilver> bahamas: otherwise, browse the documentation for appropriate modules (i.e. http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html)
01:56:03 <jle`> t (m a) -> m (t a)
01:56:05 <quicksilver> jle`: yes. It's just called sequence.
01:56:16 <quicksilver> jle`: oh, you want the traversable version?
01:56:22 <jle`> oh
01:56:27 <bahamas> quicksilver: oh, ok. the second one sounds like what I was thinking about. thanks
01:56:28 <quicksilver> I think you use sequenceA in that case.
01:56:35 <jle`> it looks like Data.Traversable also exports sequence
01:56:39 <jle`> the one i want
01:56:45 <jle`> over all traversables
01:56:46 <quicksilver> ah, does it? good.
01:56:52 <quicksilver> all monads should be applicatives
01:56:56 <quicksilver> so sequenceA should work too :)
01:57:04 <jle`> yes but i am writing generic functions
01:57:10 <quicksilver> @type Data.Traversable.sequence
01:57:11 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:57:13 <jle`> and it nags me to put down both Applicative and Monad constraints
01:57:14 * quicksilver nods at jle` 
01:57:16 <jle`> :/
01:58:27 <jle`> oh
01:58:32 <jle`> i need the Applicative constraint anyway
01:58:44 <jle`> because Data.Map's traverseWithKey is only for Applicatives
01:58:51 * jle` shrugs
01:59:04 <jle`> are we ever getting typeclass constraint aliases?
02:03:11 <zomg> Is there some simple way to determine the source of some function/type/other?
02:03:22 <Feuerbach> jle`: yes, already
02:03:27 <Feuerbach> type MyEq = Eq
02:03:30 <zomg> I occasionally look through some Haskell code to find things etc., and sometimes it's hard to determine where some function it uses comes from
02:03:31 <Feuerbach> with ConstraintKinds
02:03:49 <jle`> Feuerbach: no way
02:04:04 <jle`> that's great.
02:04:08 <jle`> is this considered good practice?
02:04:31 <jle`> :k Eq
02:04:32 <lambdabot> * -> Constraint
02:04:33 <Feuerbach> why not (apart from compatibility considerations)
02:04:54 <jle`> just wondering
02:04:55 <Feuerbach> one problem is that you cannot newtype them, so you cannot lambda-abstract
02:04:55 <jle`> thanks though
02:05:00 <jle`> hm what do you mean?
02:05:07 <supki_> @type Data.Map.traverseWithKey
02:05:08 <jle`> oh
02:05:08 <lambdabot> Applicative t => (k -> a -> t b) -> M.Map k a -> t (M.Map k b)
02:05:15 <supki_> @type imapM
02:05:15 <Feuerbach> e.g. you can define type X a = (Eq a, Ord a)
02:05:15 <lambdabot> (Monad m, TraversableWithIndex i t) => (i -> a -> m b) -> t a -> m (t b)
02:05:16 <jle`> my qustion was more can i alias multiple constraints?
02:05:23 <jle`> ah
02:05:35 <Feuerbach> but X doesn't have kind * -> Constraint itself
02:05:39 <Feuerbach> because it's a synonym
02:05:43 <Feuerbach> and has to be fully applied
02:06:09 <Feuerbach> there's another workaround for aliases that has worked forever
02:06:41 <Feuerbach> class (Eq a, Ord a) => X a; instance (Eq a, Ord a) => X a
02:06:51 <Feuerbach> now X should be equivalent to Eq + Ord
02:07:03 <Feuerbach> (that's a stupid example because Eq => Ord, but you get the idea)
02:07:44 <whaletechno> ./quit
02:09:08 * hackagebot Spock 0.4.1.0 - Another Haskell web toolkit based on scotty  http://hackage.haskell.org/package/Spock-0.4.1.0 (AlexanderThiemann)
02:11:49 <jle`> Feuerbach: thanks
02:14:09 * hackagebot network-conduit-tls 1.0.4.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.4.2 (MichaelSnoyman)
02:14:31 <bahamas> can anyone tell me what's wrong with my reasoning here http://lpaste.net/100440?
02:15:01 <bahamas> I don't understand what this means, for example " Could not deduce (a ~ Int)"
02:15:21 <quicksilver> bahamas: well the error means "I have this type 'a' and I couldn't prove it was 'Int'"
02:15:42 <quicksilver> bahamas: the *reason* is that you are writing a polymorphic function which works for any Integral type 'a'
02:15:47 <quicksilver> but "take" works only for Int.
02:15:57 <Feuerbach> no, it's length
02:15:59 <quicksilver> sorr, misread your code.
02:16:05 <quicksilver> length always returns Int
02:16:05 <quicksilver> :)
02:16:15 <Feuerbach> bahamas: try genericLength instead
02:16:26 <Feuerbach> or write your own generalized version if you want
02:16:55 <bahamas> alright. but Int implements Integral. isn't that enough?
02:16:58 <Feuerbach> (genericLength comes from Data.List)
02:17:19 <Feuerbach> yes, but not every Integral type is Int
02:17:29 <Feuerbach> and you claim it works for any a
02:17:43 <Feuerbach> (that's how type variables are interpreted in Haskell)
02:19:04 <bahamas> so Int is required somewhere?
02:19:28 <quicksilver> you can convert hte Int returned by length
02:19:34 <quicksilver> into "any Integral"
02:19:41 <quicksilver> or you can call genericLength, as Feuerbach suggested.
02:20:16 <quicksilver> the conversion functions you need to know for 90% of haskell numeric hierarchy questions are fromIntegral and realToFrac.
02:20:27 <bahamas> yes, yes. I'm trying to understand why that is before fixing things
02:20:41 <quicksilver> it's just that length is defined to return an Int
02:20:49 <quicksilver> and you're comparing it with 'n'
02:21:01 <quicksilver> and, as it happened "<=" doesn't let you compare numbers of two different types.
02:21:15 <quicksilver> you can see this as a limitation of <= if you like, although of course there are reasons it's like that.
02:21:32 <bahamas> quicksilver: ah, so that's the problem. it's not enough that both numbers implement Ord?
02:21:42 <quicksilver> correct, that's not enough
02:21:49 <quicksilver> <= is for comparing two things of the same type
02:21:53 <bahamas> actually, you're right
02:22:02 <bahamas> because otherwise 'a' <= 5 would be valid
02:22:05 <quicksilver> right.
02:22:15 <quicksilver> You could define a more felxible comparions function if you chose:
02:22:41 <bahamas> alright. now I understand. thanks
02:22:41 <quicksilver> @type let lessthan a b = (toInteger a) <= (toInteger b) in lessthan
02:22:42 <lambdabot> (Integral a, Integral a1) => a -> a1 -> Bool
02:22:54 <bahamas> aha
02:22:56 <quicksilver> ^^ there is a comparison which would work for any two (potentially different) Integral types.
02:23:08 <quicksilver> it works, as you can see, by converting both to Integral first.
02:23:17 <quicksilver> gah
02:23:25 <quicksilver> it works, as you can see, by converting both to *Integer* first.
02:23:30 <quicksilver> stupid disobedient fingers.
02:23:35 <Aiph2> hello
02:24:10 <Aiph2> why are the mentioning ((->) e) in http://www.haskell.org/haskellwiki/Typeclassopedia#Instances?
02:24:22 <Aiph2> it doesn't really makes sense since -> is not a function
02:24:27 <Aiph2> and not a type
02:24:32 <Feuerbach> it's a type constructor
02:24:40 <dibblego> (->) is a type function — pass it two types and you get a type back
02:24:41 <Feuerbach> a -> b is the same as (->) a b
02:25:15 <Aiph2> No, it's a syntatic sugar.
02:25:23 <Aiph2> :t (,)
02:25:23 <lambdabot> a -> b -> (a, b)
02:25:27 <dibblego> What exactly is the practical difference between -XSafe and using safe inference? GHC docs give this handwavy distinction, "...for which Safe Haskell is intended: compiling untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don't care about Safe Haskell."
02:25:32 <Aiph2> Constructor ^
02:25:40 <Aiph2> :t (->)
02:25:41 <lambdabot> parse error on input `->'
02:25:43 <Aiph2> Sugar ^
02:25:48 <dibblego> Aiph2: (->) is a type constructor
02:25:51 <bahamas> quicksilver: yup. I understand. thanks, quicksilver
02:25:56 <Aiph2> dibblego: nope.
02:25:59 <ion> “:t” takes values, not types or type constructors.
02:25:59 <dibblego> Yes.
02:26:06 <bahamas> I'm slowly getting used to thinking more strictly :)
02:26:13 <dibblego> Aiph2: (,) is also a data constructor, which is how you used it above and why :t works
02:26:21 <ion> :t "hello"
02:26:22 <lambdabot> [Char]
02:26:24 <ion> :t String
02:26:25 <lambdabot> Not in scope: data constructor `String'
02:26:30 <dibblego> :t will only work on data constructors — (->) is not a data constructor, it is a type constructor
02:26:31 <lambdabot> parse error on input `data'
02:26:33 <dibblego> @kind (->)
02:26:34 <lambdabot> * -> * -> *
02:26:36 <quicksilver> Aiph2: many type constructors are also data constructors, which is arguably confusing.
02:26:46 <dibblego> @kind (,)
02:26:47 <lambdabot> * -> * -> *
02:26:47 <Aiph2> okay, got it, thanks
02:26:51 <dibblego> @kind (,) int
02:26:52 <lambdabot> Not in scope: type variable `int'
02:26:54 <dibblego> @kind (,) Int
02:26:55 <lambdabot> * -> *
02:26:57 <dibblego> @kind (,) Int String
02:26:58 <lambdabot> *
02:27:02 <dibblego> @kind (->) Int
02:27:03 <lambdabot> * -> *
02:27:05 <dibblego> @kind (->) Int String
02:27:06 <lambdabot> *
02:27:17 <dibblego> here we see the (->) type constructor constructing a type
02:27:34 <dibblego> now, about this Safe Haskell …
02:27:40 <quicksilver> I'm undecided if (,) is worse because it uses exactly the same syntax at the type level and value level, or if [] is worse for being at both levels but using completely different syntax ;)
02:29:10 * hackagebot validation 0.3.1 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.3.1 (TonyMorris)
02:29:55 <pharaun> hello, i'm not sure how to begun to figure out - HandshakeFailed (Error_Packet "partial packet: expecting 2461 bytes, got: 1357") - when i try to connect to say freenode via tls
02:36:53 <lizzin> Why would this cause an error 'Int a => a -> a -> a', while 'Int -> Int -> Int' works?
02:37:04 <bergmark> lizzin: Int is not a type class
02:37:32 <lizzin> oh
02:37:41 <lizzin> It is a constructor?
02:37:46 <bergmark> it's a type
02:37:49 <bahamas> can guards and patterns be combined in a function definition?
02:38:12 <Feuerbach> yes
02:38:22 <Feuerbach> f (Foo x) | even x = ...
02:38:39 <bahamas> then I'm doing something wrong
02:39:08 <lizzin> bergmark: thanks
02:39:36 <ion> lizzin: Num is an example of a class, Int is an example of a type. Classes go to the left hand side of =>, types to to the right.
02:41:03 <bahamas> ion: are there any other types of classes besides type classes?
02:41:10 <lizzin> ion: That is last sentence is very helpful. I had not read that yet
02:41:32 <ion> bahamas: They are the same thing.
02:42:18 <bahamas> ion: no, I meant if there are other kinds of classes besides type classes
02:43:17 <Feuerbach> no, there aren't
02:43:49 <ion> bahamas: I mean, they are really the same thing: the relationship is =, not ∈. There are no other kind of classes, which is the same statement as there are no other kind of type classes.
02:45:58 <bahamas> ok, that's what I wanted to know. thanks
02:49:13 * hackagebot shake 0.11.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.3 (NeilMitchell)
02:56:42 <haasn> there are other things on the type level but none of them are classes
02:59:08 <bahamas> haasn: yeah, type variables, type constructors are the ones I know so far
03:16:42 <bahamas> hm, looking at the haskell implementation, I finally understood quicksort
03:17:36 <Peaker> bahamas: which one?
03:17:55 <bahamas> Peaker: the one in lyah
03:18:00 <hiptobecubic> real quicksort in haskell is not particularly understandable
03:18:01 <Peaker> bahamas: the   (filter (<=pivot) xs ++ [pivot] ++ filter (>pivot) xs) ?
03:18:13 <Peaker> bahamas: that's not truly quick sort, unfortunately :)
03:18:43 <haasn> depends on what “real” means; doesn't one usually use the last element as the pivot?
03:19:11 <hiptobecubic> Peaker, what's wrong with it? It's not a good implementation by any stretch but it's still quicksort in spirit isn't it?
03:19:19 <bahamas> Peaker: the one here http://learnyouahaskell.com/recursion
03:19:23 <haasn> It's not in place, but I'm not sure that's relevant
03:19:23 <Peaker> hiptobecubic: "in spirit", maybe :)
03:19:32 <haasn> because neither are the other [] sorting algorithms
03:19:57 * hiptobecubic prefers heap and merge sorts anyway
03:19:59 <Peaker> Quicksort also talks about how to do the in-place swapping to move stuff before/after the pivot
03:20:20 <haasn> Ah, re: pivot never mind https://en.wikipedia.org/wiki/Quick_sort#Choice_of_pivot
03:20:30 <mm_freak> the proper sorting algorithm for lists is mergesort
03:20:33 <haasn> merge sort is particularly elegant in Haskell I think
03:20:34 <hiptobecubic> haasn, pivot doesn't have to be last, yeah
03:20:44 <haasn> especially since you need extra space anyway
03:20:49 <haasn> which is its only real drawback
03:20:51 <Peaker> lists are great for loops, they're not so good as data structures
03:20:54 <mm_freak> quicksort is for sorting mutable arrays
03:21:02 <Peaker> and if you're sorting, you've got a data structure more than a for loop
03:21:10 <hiptobecubic> i think you need randomly chosen to be safe, although it still might end up On² if you're unlucky
03:21:37 <tv> anyone knows a tutorial with lens-4? because it seems i cannot apply what i've read about lens-3... and reading the haddock isn't helping me too much :)
03:21:54 <haasn> hiptobecubic: still much less likely to end up with the worst case pivot every time if you're sorting the relatively common case of a nearly pre-sorted list
03:23:05 <dagle> Is there a function that does this: (a -> Bool) -> [a] -> [[a]] ? I want to split a list each time I find certain things in it.
03:23:15 <dibblego> @where split
03:23:15 <lambdabot> http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
03:23:18 <hiptobecubic> haasn, indeed. Although with heap/merge you are guaranteed n log n in exchange for giving up constant space (above the list itself)
03:23:20 <dibblego> dagle: ^^
03:23:43 <dibblego> http://hackage.haskell.org/package/split-0.2.2/docs/src/Data-List-Split-Internals.html#splitWhen
03:24:27 <dagle> dibblego: Ty, it was hoogle that wouldn't show me that function.
03:26:13 <haasn> in-place heap doesn't give up constant space, does it? it just gives up stability
03:29:17 * hackagebot cabal-bounds 0.1.14 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.14 (DanielTrstenjak)
03:29:56 <Maior> ! <3
03:34:18 * hackagebot cabal-bounds 0.1.15 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.15 (DanielTrstenjak)
03:34:20 * hackagebot cabal-bounds 0.1.16 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.1.16 (DanielTrstenjak)
03:47:37 <pjdelport> hiptobecubic: the usual list sort is actually a deforested tree sort
03:51:13 <hiptobecubic> pjdelport, not familiar
03:51:39 <pjdelport> hiptobecubic: http://www.reddit.com/r/programming/comments/2h0j2/real_quicksort_in_haskell
03:53:00 <pjdelport> a tree sort is basicaly when you convert a list to a binary search tree, and then flatten it back to a list (using an in-order traversal)
03:54:05 <hiptobecubic> oh, yes ok.
03:55:11 <pjdelport> you deforest it, to get rid of the intermediate tree data structure, you get that usual algorithm that's usually called quicksort, somewhat  inaccurately
03:56:39 <pjdelport> the only thing it has in common with quicksort is that there's a pivot, but this is due to tree construction: it never performs the array-based swapping scan that defines quicksort
03:57:23 <merijn> pjdelport: I've had this argument 4 plus times here, the people who call it quicksort will keep calling it quicksort >.>
03:57:38 <merijn> Anyway in a functional language mergesort is much nicer anyway
03:59:00 <c_wraith> with a sufficiently large list, mergesort is much nicer anyway.
03:59:09 <c_wraith> that is, more than a few memory pages
03:59:37 <haasn> pjdelport: interesting; a class mate of mine actually came up with that sorting algorithm while discussing heap sort and I realized how close it's to quick sort, but I never realized the haskell “qsort” is precisely that
03:59:40 <pjdelport> The deforestation just means that the tree constructed by the tree sort becomes implicit in the evaluation order, instead of being a reified tree.
04:00:41 <c_wraith> When virtual memory gets involved, quicksort causes *way* more paging than mergesort.  To the point that it actually is an asymptotic hit, iirc.
04:01:23 <haasn> what about heap sort? Is it possible to make heap sort cache-friendly by organizing the heap so that a root-to-leaf traversal tends to stay on the same page?
04:01:28 <pjdelport> (In fact, you can translate the Haskell algorithm directly to C, and it would still be a tree sort instead of quicksort, with the tree evaluation embedded in C's call stack.)
04:02:29 <pjdelport> merijn: I know, that's why say "the algorithm usually called quicksort". :)
04:02:56 <pjdelport> "why I say" , even
04:03:12 <honza> is there a way to pattern match on both the values inside a custom data type and the data type as a whole inside a function definition?
04:04:08 <c_wraith> haasn: merge sort is nearly the best possible for locality.  It's why all the super-advanced sort algorithms are all modified merge sorts, at a high level.
04:04:50 <pjdelport> > let ab@(a, b) = (1, 2) in (ab, a, b)
04:04:51 <lambdabot>  ((1,2),1,2)
04:04:56 <honza> e.g. data Cartesian = Cartesian { x, y, z } and then someFnName (Cartesian x y z) = ...
04:05:17 <honza> is there a way to match x, y, z and the whole Cartesian type?
04:06:10 <c_wraith> honza: exactly what pjdelport just showed
04:06:12 <pjdelport> honza: in that case, someFnName triple@(Cartesian x y z) = ...
04:06:43 <pjdelport> honza: You can read the @ symbol as "as"
04:06:54 <honza> pjdelport: c_wraith: nice! thanks
04:07:51 <pjdelport> c_wraith: Do you know Timsort? :)
04:08:19 <c_wraith> pjdelport: I don't know the details, but I know it's one of the highly optimized cases of mergesort. :)
04:08:25 <pjdelport> yeah
04:09:12 <c_wraith> iirc, it's a merge sort at the high level, with lots of optimizations for handling cache-line size sections more efficiently.
04:13:58 <pjdelport> c_wraith: It also has particular rules for when to construct and merge runs.
04:14:22 * hackagebot minioperational 0.4.3 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.3 (FumiakiKinoshita)
04:24:23 * hackagebot wai-middleware-etag 0.1.0.0 - WAI ETag middleware for static files  http://hackage.haskell.org/package/wai-middleware-etag-0.1.0.0 (ameingast)
04:30:02 <makalu> nesting if then else expressions looks bad. Can I have something like guards in an expression (NOT a function definition)?
04:30:25 <c_wraith> makalu: you can have guards on any binding
04:30:54 <Cale> makalu: You can have a case expression
04:31:09 <Cale> case () of _ | ... -> ...
04:32:02 <c_wraith> you don't even need a case expression.  let { foo | x == y = bar | otherwise = baz }
04:32:29 <makalu> thanks c_wraith that's what I was looking for
04:49:02 <quicksilver> makalu: also consider doing a 'case' on the two conds. That looks neater if you have code in three or four 'branches' of the if then else
04:49:22 <quicksilver> case (cond1,cond2) of (True,True) -> ...; (True,False) -> ...; (False,False) -> ...; etc
04:49:38 <quicksilver> many ways to do it.
04:50:21 <Iceland_jack> Yes, I'm partial to using a case-expression with tuples
04:50:35 <makalu> I like reading guards more
04:55:16 <c_wraith> Is GHC smart enough to remove the pattern-match on a constructor known at compile time?  I guess I should check the core.
05:00:21 <quicksilver> c_wraith: yes.
05:00:42 <quicksilver> c_wraith: I think that can happen in two different ways
05:00:49 <quicksilver> (1) sufficient inlining (2) SpecConstr
05:01:29 <haasn> {-# LANGUAGE MultiWayIf #-} if | x == y = bar | otherwise = baz
05:01:48 <quicksilver> I think the point of SpecConstr is to make it work even if you can't inline it because it's a recursive call to yourself
05:01:51 <quicksilver> but I'm not sure.
05:02:03 <haasn> s/ = / -> /g
05:26:24 <t7> > let foo :: [forall a. Show a => a] -> String; foo [] = ""; foo (x:xs) = show x ++ foo xs in foo [1, "hi", (1, 'a')]
05:26:25 <lambdabot>  Illegal polymorphic or qualified type:
05:26:25 <lambdabot>    forall a. GHC.Show.Show a => a
05:26:25 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
05:26:57 <t7> > let foo :: [forall a. Show a] -> String; foo [] = ""; foo (x:xs) = show x ++ foo xs in foo [1, "hi", (1, 'a')]
05:26:58 <lambdabot>  Illegal polymorphic or qualified type: forall a. GHC.Show.Show a
05:26:58 <lambdabot>  Perhaps you intended to use -XImpredicativeTypes
05:27:08 <merijn> t7: You can't write that
05:27:18 <merijn> t7: You need an ExistentialQuantification wrapper
05:27:32 <t7> i thought you could do it if you specified
05:27:45 <merijn> t7: No, only with ImpredicativeTypes, which is broken
05:30:01 <t7> > (\f -> (f 1, f "Hello")) ((\x -> x) :: forall a. Show a => a -> a)
05:30:02 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
05:30:02 <lambdabot>    arising from the literal `1'
05:30:02 <lambdabot>  Possible fix:
05:30:02 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
05:30:20 <t7> oh wrong thing
05:30:44 <t7> > (\f -> ((f :: forall a. Show a => a -> a) 1, f "Hello")) (\x -> x)
05:30:45 <lambdabot>  Could not deduce (a ~ [GHC.Types.Char])
05:30:45 <lambdabot>  from the context (GHC.Num.Num t, GHC.Show.Show t)
05:30:45 <lambdabot>    bound by the inferred type of
05:30:45 <lambdabot>             it :: (GHC.Num.Num t, GHC.Show.Show t) => (t, [GHC.Types.Char])
05:30:45 <lambdabot>    at Top level
05:30:53 <t7> ok i will stop spamming
05:35:15 <supki_> > (\(f :: forall a. Show a => a -> String) -> (f 1, f "Hello")) show
05:35:16 <lambdabot>  ("1","\"Hello\"")
05:54:22 <merijn> Any clues why I could be getting "cabal: At least the following dependencies are missing: Cabal ==1.18.*"
05:54:29 <merijn> Even though I have 1.18.0 installed?
06:03:58 <Feuerbach> is it installed in a sandbox?
06:06:46 <merijn> Yeah
06:07:10 <merijn> Well, the program I'm trying to compile is in a sandbox
06:07:20 <Feuerbach> try installing it in the user db
06:07:30 <merijn> I have cabal 1.18 in my user db
06:07:53 <merijn> I only have this project itself and 2 dependencies unrelated to cabal in the sandbox
06:08:20 <Feuerbach> so you have Cabal-1.18 both in the user db and in the sandbox?
06:08:46 <merijn> No, just in the user db
06:09:09 <merijn> Why would it install cabal-1.18 in the sandbox if it's already installed globally?
06:09:20 <merijn> (well, user db, not global db)
06:09:24 <Feuerbach> to compile Setup.hs
06:09:45 <Feuerbach> then try installing it in the sandbox
06:10:27 <Feuerbach> or just file an issue on github, and you'll get the definite answer :)
06:10:34 <merijn> File an issue on which github?
06:10:40 <merijn> I'm not even sure what the problem is
06:10:58 <Feuerbach> github.com/haskell/cabal
06:11:49 <merijn> That's all nice and well, but not very helpful in solving why a completely trivial operation that works in other cases doesn't work
06:12:44 <merijn> It's finding the other 10 dependencies in my user db just fine, only cabal it fails on
06:29:07 <merijn> ugh, conflicting version dependency but cabal didn't report that >.>
06:29:18 <merijn> Please tell me 7.8 will ship with Cabal-1.18
06:29:37 <jacks-> can haskell replace something like python for prototyping? or is dynamically types language more suited for that
06:30:07 <Maior> jacks-: yes
06:30:09 <merijn> jacks-: FWIW, I've started using Haskell over Python for my one-off shell script programs
06:30:39 <merijn> jacks-: So, yes, I believe Haskell can replace python, but it may take a while before you're proficient enough in haskell to do that
06:30:51 <Iceland_jack> What merijn said
06:31:19 <remdezx> Hello! I'm currently working on a project which is going to distribute computations over nodes in a cloud (like Amazon). Are there any good frameworks in Haskell for distributed computing?
06:31:47 <remdezx> I mean something similar to Erlang (or better ;) )
06:31:52 <quicksilver> cloud haskell
06:31:56 <quicksilver> funnily enough
06:32:09 <quicksilver> no idea if it's any good, I've never used it.
06:32:17 <Iceland_jack> remdezx: Why not Erlang?
06:32:20 <quicksilver> it certainly has some clever ideas, I've read some of the propaganda
06:32:34 <quicksilver> (there are some older bitrotted projects too)
06:33:05 <remdezx> Iceland_jack: cause I already use Haskell in other parts of this project
06:34:08 <bennofs> Can I upgrade 'unix' or is it one of the 'non-upgradeable' libraries?
06:34:59 <remdezx> quicksilver: do you think that cloud haskell is stable enough?
06:35:49 <merijn> argh
06:36:09 <merijn> How do I import a specific version of a package in ghci?
06:36:20 <merijn> i.e. Cabal-1.16 instead of Cabal-1.18
06:36:25 <startling> merijn, you can use that extension
06:36:31 <Iceland_jack> PackageImports
06:36:38 <startling> ^ this one
06:36:43 <quicksilver> remdezx: I know nothing about it at all I'm afraid
06:37:02 <quicksilver> remdezx: (other than what I garnere form a couple of blog posts and some poking around in some docs)
06:37:04 <bennofs> merijn: :set -package Cabal-1.16 should work
06:38:04 <merijn> "Can't be satisfied"
06:38:05 <danilo2> By the way, does somebody know if cloud haskell is production ready? Did anyone used it? And a small second question - what are the best benefits of using it instead of for example making workers using mvars or other communication mechanism, that makes them sleep until there is data to process?
06:38:06 <remdezx> quicksilver: I'll be interested in this posts? Do you have some links?
06:38:14 <merijn> Right, so how do I unhide a package?
06:38:49 <merijn> danilo2: MVars can't communicate across processes, let alone across machines
06:41:45 <danilo2> merijn: Ok, that makes sense. Are there any "channels" in haskell that can communicate between processes, in particular between machines? I mean like "google go's" channels ?
06:41:46 <quicksilver> remdezx: http://www.well-typed.com/blog/68 http://www.well-typed.com/blog/70 http://www.well-typed.com/blog/74 http://www.infoq.com/interviews/coutts-haskell
06:42:09 <merijn> danilo2: Go channels can't communicate between processes or machines either
06:42:21 <bennofs> levi: I found out why threadDelay solved my issue yesterday: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#g:14 -- Apparently, even if exceptions are masked, they mall still be received, you only have to do that explicitely by using interruptible functions
06:42:23 <remdezx> quicksilver: thanks, I'll check this out
06:42:56 <amalloy> can someone look at the comment thread on http://stackoverflow.com/a/22065983/625403 and tell me if i'm wrong? i'm pretty sure Nothing has kind *, but can't seem to find any evidence that is simple enough to present to this user3974391 fellow
06:43:24 <merijn> amalloy: Nothing doesn't have a kind, as it's value
06:43:35 <merijn> amalloy: Values have types and types have kinds
06:44:05 <merijn> amalloy: Therefore Nothing does not have a kind, it has type "Maybe a" (or "forall a . Maybe a")
06:44:22 <merijn> And the *type* Maybe has *kind* "* -> *"
06:45:20 <Iceland_jack> amalloy: Nothing doesn't have a kind, the type of Nothing (Maybe a) has kind * though
06:46:00 <Iceland_jack> (as do the types of all values)
06:46:00 <amalloy> okay, that's true. values don't have kinds, they have types; and the type that they have is always of kind *. yes?
06:46:06 <Iceland_jack> Yes
06:46:18 <merijn> amalloy: In Haskell, yes
06:47:03 <merijn> amalloy: Well, there is a special kind for unboxed values, iirc, but that's something you should probably pretend doesn't exist here :p
06:47:30 <danilo2> merijn: they can in go, as far as I know. Look here: http://golang.org/doc/effective_go.html#leaky_buffer - you can write servers and clients communicating over channels
06:47:44 <quicksilver> the confusion in some of the answers to that question is that there are two different dichotomies; (1) "concrete types/ground types" vs "higher kinded types" (2) polymorphic types vs monomorphic types
06:48:04 <merijn> amalloy: Actually, I guess that values still always have kind "*" in other languages, as those languages mostly define values (in the term sense) as having types with kind *
06:48:14 <quicksilver> probably the word 'concrete' is used sometimes as a synonym for monomorphic and in other places as a synonym for ground.
06:48:36 <merijn> danilo2: Those examples are still in a single process
06:49:01 <merijn> danilo2: They're just using lightweight threads with a "server thread" and "client thread"
06:49:08 <merijn> danilo2: I'm referring to proper posix processes
06:49:32 <merijn> I dislike this entire "concrete" type distinction to begin with
06:51:18 <quicksilver> there is something quite subtle about polymorphic types in haskell, as well
06:51:42 <quicksilver> polymorphic types are a bit slippery, they're not first class (in standard haskell)
06:51:58 <danilo2> merijn: hmm, brb - I'm reading about it - thanks :)
06:58:53 <danilo2> merijn: Hm, that is interesting. I was sure that channels in go can handle communication between real processes, but it seems you are right! Hmm, so I understand, that the only (and best) way to go with haskell computations over amazon machines is cloud haskell ?
06:59:47 <merijn> Well, that or just writing your own networking
06:59:51 <cizra> Hi! I've developed in a certain dynamically-typed, snake-shaped language for a while now, and I'm thinking of having a refreshing gulp of type safety for a change. I need to write a simple web-based frontend to filesystem, supporting browsing, downloading and uploading files. It'll be hosted on Linux, but it'd be better if it supported Windows and Mac as well. Which Haskelly hammer is appropriate for such thing? I've looked at http://www.haskell.org/haske
07:00:14 <Maior> danilo2: just use the aws lib?
07:00:46 <hcaulfield57> Am I correct in the following understanding, fmap applies a function to data that is in some context, <*> applies a function that is in some context to data that is in some context, and >>= extracts some data from a context applies a function to it and returns it back into that context?
07:01:10 <Maior> :t fmap
07:01:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:01:29 <Maior> :t (<*>)
07:01:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:01:35 <haasn> depends on what you mean by “data that is in some context”. those aren't very haskell-y terms, ‘m’ can mean a lot of things
07:03:32 <merijn> cizra: The usual suspects are Yesod, Snap and happstack
07:03:45 <hcaulfield57> haasn: Well that was just how I thought of it, I don't know how else to explain it.
07:04:17 <merijn> hcaulfield57: I usually recommend not worrying about monads in the abstract
07:04:36 <merijn> hcaulfield57: Memorise the type, think of what it means for *concrete* monads (i.e., maybe, list, either, etc)
07:04:58 <merijn> hcaulfield57: Trying to find an accurate generic description of monad is enterprise doomed to confusion
07:06:01 <hcaulfield57> merijn: Well I think I understand that,
07:06:07 <merijn> hcaulfield57: I think a lot of people get confused due to overthinking "what" it means, but in practice it doesn't really matter that much
07:06:18 <mr-> Also, that seems like an academically hard question. Everything you can say about monads in general is going to be a property that _every_ monad you can define in haskell is bound to have.. Sounds like a "deep" theorem :-)
07:07:17 <hcaulfield57> Okay, well now I need to try and understand the more complex monads, like State
07:07:18 <danilo2> Maior: hmm, interesting, I did not see it before! Thanks! Do you know any differences between the aws library and cloud haskell? Does one has some better solutions over the other in some use cases?
07:07:52 <Maior> danilo2: I've no idea what "cloud haskell" is
07:07:53 <merijn> hcaulfield57: Well, "State s a" is pretty much "s -> (a, s)"
07:08:08 <Maior> danilo2: but surely all you need is SQS?
07:08:43 <Maerten> (beginner question) I have a Data.Map.Map String Int that i want to encode as JSON. This works but the keys are not in order, what would be the easiest way to sort the map by key in alphabetical order?
07:09:06 <Maior> Maerten: why do you care about key order?
07:09:12 <Maior> (that's usually a bad sign)
07:09:13 <remdezx> Maior: Isn't aws for just binding to Amazon api? How can I distribute computations with it?
07:09:15 <merijn> hcaulfield57: So if you look at "(>>=) :: m a -> (a -> m b) -> m b" it becomes "(>>=) :: State s a -> (a -> State s b) -> State s b" which becomes "(>>=) :: (s -> (a, s)) -> (a -> (s -> (b, s)) -> (s -> (b, s))"
07:09:31 <hcaulfield57> merijn: How would you normally construct a value of State, you can't use something like Just
07:09:33 <Maior> remdezx: depends on the computations and how you're wanting to distribute them
07:09:54 <Maerten> Maior: well it's just for readability of the output.. the keys are dates and its hard to spot problems if they are shuffled
07:09:58 <Maior> remdezx: or do you just want some generic "make these machines be like one"
07:10:22 <merijn> hcaulfield57: "state :: (s -> (a, s)) -> State s a", but usually you'd use either of these: "get :: State s s" or "put :: s -> State s ()"
07:10:41 <Maior> Maerten: I'd be inclined to use jsonlint or something with the sortkey option
07:10:52 <merijn> hmm, my last example is bracketed wrong, but you get the idea, I hope
07:11:09 <danilo2> Maior: http://www.haskell.org/haskellwiki/Cloud_Haskell . Basically I need to distribute a lamda function across different machines feeding it with different data
07:11:58 <hcaulfield57> merijn: Yea, it helps, I'm going to try a few things with State, and see if I understand
07:12:26 <hcaulfield57> Thank you
07:12:26 <merijn> hcaulfield57: For example, you'd write "inc :: State Int ()" as "inc = do { oldState <- get; put (oldState + 1) }"
07:12:40 <remdezx> Maior: as danilo2 said, but it will be great if I could both 1) control which nodes will perform these computations and 2) load balance them
07:12:50 <Maerten> Maior: hm. is there no way to do it easily in haskell itself? thanks anyway for the suggestion.
07:12:51 <merijn> hcaulfield57: Which is identical to "inc = get >>= \oldState -> put (oldState + 1)"
07:12:59 <Maior> Maerten: probably
07:13:11 <Maior> Maerten: don't know one though
07:13:32 <merijn> hcaulfield57: It's very helpful to grab a piece of paper/whiteboard and pen and work out all the types by hand
07:15:45 <remdezx> Maior: do you have some examples of how to use aws to "make machines to be like one"? It will be interesting though
07:15:52 <Maior> remdezx: non-aws specific
07:15:59 <randomclown> @pl \xs -> (f $ x) : xs
07:16:13 <randomclown> > "wtf"
07:16:21 <randomclown> lambdabot !!!!
07:16:31 <Maerten> Maior: just fyi i found something in the Aeson.Encode.Pretty package
07:16:46 <randomclown> lambdabot:
07:17:22 <remdezx> Maior: it would be great too
07:19:45 <hcaulfield57> merijn: Okay, but practically how would someone use something like the inc example you gave me with the State monad, pass it as a parameter to some function?
07:20:44 <remdezx> Does somebody know any other frameworks than aws and cloud haskell for distributed computing? Which of them is better?
07:21:10 <merijn> hcaulfield57: Yes, or use it to define bigger state actions like "incThreeReturnOld = do { oldState <- get; inc; inc; inc; return oldState }"
07:21:25 <merijn> hcaulfield57: However, we already have a bunch of neat functions for stuff like this
07:21:49 <merijn> Like:
07:21:52 <hcaulfield57> merijn: Is using things like the State monad how people keep from using global variables in Haskell, or make up for it.
07:21:53 <merijn> :t replicateM
07:22:04 <merijn> aww, lambdabot is gone
07:22:21 <Maior> remdezx: aws isn't really "for distributed computing" like c-h is
07:22:31 <merijn> hcaulfield57: It is a possible way, yes. There are multiple solutions depending on the exact problem you're attempting to use global state for
07:23:11 <remdezx> Maior: okay, so the c-h is the only way?
07:23:16 <merijn> hcaulfield57: The neat thing is that you can do things like "replicateM :: Monad m => Int -> m a -> m [a]" which repeats an action multiple times
07:23:19 <Maior> remdezx: pass
07:23:33 <hcaulfield57> merijn: Becasue some Haskell programs I've made in the past, all have to pass like a billion variables around, so I was wondering.
07:23:46 <merijn> hcaulfield57: Since it works for any monad you can use it for IO to repeat an IO action 3 times, i.e. "replicateM :: Int -> IO a -> IO [a]"
07:23:53 <Maior> remdezx: while I do a fair amount with distributed systems, I know little about "automagic distribution"
07:24:15 <merijn> hcaulfield57: Probably it's a matter of learning to structure functional programs and using tools like State/Reader
07:24:39 <cizra> merijn: Thanks, and between them I could choose at random?
07:24:45 <merijn> hcaulfield57: Reader is essentially for "read-only" state, so you usuall use it to pass configuration parameters to multiple functions
07:25:03 <hcaulfield57> merijn: Probably, I'm pretty new to Haskell
07:25:13 <merijn> cizra: Well, there's some differences, but I'm not big in the web thing
07:25:50 <merijn> cizra: Yesod tries to verify as much as possible statically, which is nice, but it's use of template haskell can make errors...inscrutable. Snap and Happstack are more minimal frameworks
07:26:08 <merijn> cizra: But I think all 3 have channels here on freenode, so you may want to ask there about strengths, etc.
07:26:14 <remdezx> Maior: as fair as I know, c-h doesn't do "automagic distribution" and it has no load balancer and need to send tasks to specific nodes manually.
07:26:17 <merijn> cizra: Or just pick the one whose docs you like best :p
07:27:05 <remdezx> Maior: You said you have background in distributed computing. If you had to, will you use c-h or implement it other way?
07:27:17 <Maior> remdezx: I know little about your problem
07:30:32 <remdezx> Maior: okay. I don't know what you need to know more... I just want to distribute lambdas with different arguments across the available machines to compute and gather results.
07:31:03 <remdezx> and do it as efficient as possible
07:32:41 <Maior> remdezx: sounds vaguely like map-reduce; EMR exists
07:33:09 <x0l> Hi all. With pandoc and LHS is it possible to render `->` (and alikes) as unicode operator (like vim conceal) ?
07:33:42 <remdezx> Maior: what is EMR?
07:33:52 <Maior> remdezx: Elastic Map Reduce
07:35:04 <mm_freak> x0l: pandoc has the "smart" mode
07:35:09 <mm_freak> x0l: but i don't know if it handles arrows
07:35:21 <kadoban> is there some way i can get Data.Map.Strict to exist without totally reinstalling a new version of haskell platform? i'm using my OS's version of haskell, which was easy to install. can cabal do it for me somehow?
07:35:24 <mm_freak> it handles stuff like ellipsis, quotes, etc.
07:35:34 <x0l> mm_freak: thanks, i'll try that right now
07:36:13 <mm_freak> kadoban: if you installed the haskell platform it's probably a bit difficult, because you would have two versions of 'containers', which probably gives you dependency hell quickly
07:36:21 <remdezx> Maior: oh, thats interesting, thanks! I'll take a look ;)
07:36:42 <kadoban> mm_freak: :( i just installed whatever's in ubuntu's package system thing
07:36:45 <mm_freak> kadoban: you can try to hide the global containers package by using ghc-pkg, but then you will break existing libraries
07:36:57 <x0l> mm_freak: does not work for arrows. I'll guess i'll preprocess the file.
07:37:12 <kadoban> mm_freak: hmm, yeah that sounds like something i should avoid i guess. oh well, thanks
07:37:16 <mm_freak> kadoban: well, if you don't have Data.Map.Strict, then your HP version is probably obsolete anyway
07:37:31 <kadoban> it's 7.4.1 i guess? which...yeah i guess that's rather old now
07:37:47 <mm_freak> x0l: or set up your xmodmap and put the arrows on a key combination
07:38:37 <mm_freak> kadoban: alternatively you could install nix (the package manager)…  it allows you to install conflicting versions
07:38:47 <mm_freak> but learning nix may be too steep =)
07:39:24 <kadoban> hehe, i'll look into it at least, sounds kind of interesting. sucks that i'm so far behind...looks like all else i can do is totally upgrade away from the current LTS of ubuntu
07:39:40 <remdezx> Maior: It seems that EMR have no bindings to Haskell...
07:39:52 <TovenaarKlus> Hey, does anyone have a good resource on when to use monads and when not to? I'm kind of unsure about that.
07:39:53 <c_wraith> kadoban: the standard solution is installing GHC yourself, instead of from ubuntu's package manager.  It's actually pretty easy.
07:39:58 <mm_freak> kadoban: or ignore the ubuntu package and install the HP yourself…  but that's probably a bad idea for different reasons
07:40:21 <mm_freak> if you do that, you may want to create your own deb for it
07:40:34 <kadoban> c_wraith: is it? it's kinda weird that HP just points me to the ubuntu packages that i curretnly have
07:40:35 <mm_freak> such that your package manager is at least aware of it
07:40:44 <kadoban> what do i install otherwise? just ghc and then go from there?
07:41:05 <mm_freak> kadoban: GHC and the cabal-install utility should be enough to get the rest up and running
07:41:31 <kadoban> i can give that a go i guess. maybe i'll try in a vm i don't care about first, just in case. thanks guys
07:42:30 <mm_freak> kadoban: i believe that you can install them in your home directory
07:42:46 <c_wraith> edwardk: would you merge a patch to free that adds (iterTM :: (Monad m, Monad (t m), Functor f, MonadTrans t) => (f (t m r) -> t m r) -> FT f m r -> t m r) to Control.Monad.Trans.Free and Control.Monad.Trans.Free.Church?
07:42:54 <kadoban> hmm, that might be a good idea
07:43:05 <c_wraith> yeah, that's what I do.  local installs
07:43:26 <edwardk> c_wraith: i could live with it i suppose
07:43:36 <c_wraith> edwardk: (Changing FT to FreeT where appropriate)
07:43:57 <edwardk> c_wraith: i reserve the right at some point to rename the whole iterT, iterTM mess, but sure
07:44:00 <c_wraith> Any particular reason it's merely "live with it"?  Is there a downside to that construction that's subtle?
07:44:28 <remdezx> Maior: did you ever used  EMR with haskell?
07:47:10 <njcomsec> "did you ever use"
07:47:33 <Maior> remdezx: yes
07:48:20 <remdezx> how? any suggestions? I'm really sorry asking so many questions
07:48:46 <Maior> remdezx: read the EMR docs
07:49:00 <Maior> it's language-agnostic
07:49:27 <remdezx> Maior: okay
07:52:14 <augur_> is there a nice little library for enumerating elements of a datatype?
07:54:18 <quicksilver> well there is [minBound..maxBound]
07:54:24 <quicksilver> if you derive Enum and Bounded
07:54:47 * hackagebot data-stringmap 1.0.1.1 - An efficient implementation of maps from strings to arbitrary values  http://hackage.haskell.org/package/data-stringmap-1.0.1.1 (UweSchmidt)
07:55:01 <quicksilver> outside of that I bet there is something via Generics
07:56:36 <augur_> ah hm. Enum requies a successor method
07:56:55 <augur_> but for tree-like data its not a total ordering per se so much as a well-ordering
07:57:14 <quicksilver> you can view the total ordering as abitrary
07:57:31 <quicksilver> but if you're trying to do a complete breadth-first enumeration of a tree with more than one branch
07:57:37 <quicksilver> then you need a different approach.
07:57:40 <augur_> quicksilver: yes, you can, but its a hell of a lot harder to make successorship clear :)
07:57:48 <quicksilver> sorry "more than one infinte branch"
07:57:49 <quicksilver> I meant.
07:58:11 <augur_> with a well-ordering its easy: navigate to the leaves, and push them out non-deterministically
07:58:26 <quicksilver> augur_: can't find it. the words are too overloaded and misused. I bet there is one, though.
07:58:31 <quicksilver> edwardk: ?
07:58:54 <Sculptor> hi
07:58:55 <edwardk> ?
07:59:17 <edwardk> augur_: dmwit has one
07:59:23 <augur_> edwardk: oh?
07:59:47 <edwardk> http://hackage.haskell.org/package/universe
07:59:48 * hackagebot git-annex 5.20140227 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140227 (JoeyHess)
07:59:54 <augur_> ahh yes
08:00:15 <edwardk> c_wraith: mostlly its just a very complex type with little motivation is all
08:00:56 <augur_> edwardk: does that offer a derivable instance?
08:00:57 <edwardk> quicksilver: lens has a breadth first traversal in it ;)
08:01:46 <edwardk> augur_: it appears to use Enum/Bounded by default, rather than use GHC.Generics
08:01:54 <augur_> ah
08:02:10 <quicksilver> it doesn't help that over the years there have been so many implementations of 'Generic' programming for haskell/GHC
08:02:10 <edwardk> i have a GHC.Generic version somewhere for hilbert's epsilon
08:02:19 <c_wraith> edwardk: It's the analog to iterM for Free or F, for transformers. iterM replaces Free or F with an arbitrary monad. iterTM (iterMT? Naming is hard) would replace FreeT or FT with an arbitrary monad transformer
08:02:24 <quicksilver> and they all had similar names and googling often gets you the wrong one.
08:02:40 <c_wraith> edwardk: it has approximately the same use case as iterM for Free or F
08:02:59 <edwardk> c_wraith: i understand the motivaton, but the placements of the m's gets a bit arbitrary
08:03:11 <c_wraith> In the type signature, or the name?
08:03:16 <edwardk> c_wraith: yes ;)
08:04:04 <edwardk> this one isn't so bad, just the name is a bit of an eyesore ;)
08:04:48 * hackagebot git-repair 1.20140227 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20140227 (JoeyHess)
08:05:10 <edwardk> augur_: http://www.haskell.org/pipermail/haskell-cafe/2012-June/101699.html has a ghc.generics form of hilbert's epsilon that can be used for searching
08:05:20 <c_wraith> edwardk: The name is a bit bad.  Huh.  This looks really inefficient for FT.  It didn't look *so* bad, until I looked at what hoistFT does.  Maybe I need to reconsider this implementation
08:06:17 <edwardk> c_wraith: if nothing else throw an issue up and work through it there. there are a couple of guys over on ##team-free working on free documentation/instances, etc. for a class project if you want to join.
08:06:33 <augur_> edwardk: ill give it a look, thanks :)
08:06:51 <c_wraith> edwardk: I have working implementations for each.  Just trying to make them not-dumb, in addition to working. :)
08:06:53 <edwardk> augur_: i hpasted an updated version of that also at some point, hrmm
08:07:31 <edwardk> augur_: http://lpaste.net/69758 looks like it might be it
08:14:48 <Zol|Work> Wish I could turn on colours in the webchat for this channel..
08:16:32 <kgadek> hi. kind of newbie here. what's the best module(s) to scrape data from HTML pages? hxt? handsomesoup? other?
08:17:09 <kgadek> would be perfect to migrate my python+beautifulsoup to haskell. there I use CSS/XPATH selectors quite often
08:18:15 <jcristov1o> kgadek: perhaps http://hackage.haskell.org/package/dom-selector
08:18:51 <jcristov1o> hxt works, but its quite memory intensive
08:20:15 <kgadek> jcristov1o: so HXT + dom-selector if memory is not a big issue. okay, will check that. thanks :)
08:20:52 <jcristov1o> sorry... dom-selector is for html-conduit
08:20:58 <jcristov1o> that's the base package
08:21:18 <jcristov1o> hxt is an alternative
08:21:57 <jcristov1o> hxt uses arrows, html-conduit uses monads
08:23:20 <kgadek> thx for explaining :)
08:34:04 <paolino> hello, is it ok to export an instance of a data defined in another package ?
08:34:56 <c_wraith> paolino: did you define the class in your package?
08:35:08 <paolino> like Binary for Data.List.Zipper, when to export it ?
08:35:16 <paolino> c_wraith, no
08:35:36 <c_wraith> paolino: ah, in that case, it'd be an orphan instance.  They're fine to use in your own code, but probably shouldn't be uploaded to hackage
08:36:28 <paolino> so everyone write its own
08:38:38 <bennofs> How bad are orphan instances in leaf packages (executables for example)? I have lots of storable instances that distract from the main code, so would it be bad to move them into a module like StorableInstances?
08:39:10 <zipper`> This: << (\x -> ['a', 'b']) >>. What does that function/lamda do? or better why is it doing what it does. It returns "ab" each time it is called. When called with a list it returns [Sting] with elements equal to the number of times it was called.This: << (\x -> ['a', 'b']) >>. What does that function/lamda do? or better why is it doing what it does. It returns "ab" each time it is called. When called with a list it returns [Sting] with
08:39:10 <zipper`> elements equal to the number of times it was called.
08:39:53 <Iceland_jack> zipper`: Are you using << ... >> as quotes?
08:40:15 <zipper`> Iceland_jack: No I am binding it to a variable with a let then calling it.
08:40:16 <Iceland_jack> (\x -> ['a', 'b']) is just a constant function on "ab"
08:40:51 <zipper`> let lam = (\x -> ['a', 'b'])
08:40:53 <Iceland_jack> Yes but the '<<', '>>' parts of your question is not Haskell code
08:40:54 <Iceland_jack> Right.
08:41:20 <Iceland_jack> @ty \x -> ['a', 'b']
08:41:21 <lambdabot> t -> [Char]
08:41:22 <Iceland_jack> @ty const "ab"
08:41:23 <lambdabot> b -> [Char]
08:41:24 <Iceland_jack> same thing
08:41:31 <zipper`> Iceland_jack: << >> is not haskell code. They are cool quotes
08:42:01 <dwcook> zipper`, it was confusing because (<<) and (>>) are actual functions in Haskell's base library
08:42:01 <bennofs> You mean « like this » ?
08:42:08 <Iceland_jack> Right, that was my question. Otherwise it's a fairly uninteresting function that ignores its argument and returns "ab"
08:42:25 <zipper`> dwcook: lol I get it.
08:42:32 <paolino> zipper`, it's preserving the structure if it's used in a traversal
08:42:52 <Iceland_jack> > (\x -> "ab") undefined
08:42:53 <lambdabot>  "ab"
08:43:45 <Iceland_jack> > (const "ab") undefined
08:43:46 <lambdabot>  "ab"
08:44:08 <Iceland_jack> dunno what more to say about it zipper`, it's quite a dull function
08:44:17 <zipper`> Iceland_jack: Ah I see because ['a', 'b'] is a way of writing "ab"
08:44:20 <Iceland_jack> yes
08:44:21 <dwcook> zipper`, it's not a very interesting function in itself. Did you see it used in some code?
08:44:31 <paolino> > map (const 1) []
08:44:32 <lambdabot>  []
08:44:45 <dwcook> Oh I see, the confusion was not knowing that type String = [Char] ?
08:44:49 <Iceland_jack> or rather "ab" is way of writing ['a', 'b'] which is a way of writing 'a':'b':[] in turn
08:45:01 <Iceland_jack> Since "ab" is sugar for ['a', 'b'] is sugar for 'a':'b':[]
08:45:22 <Iceland_jack> > ("abc", ['a', 'b', 'c'], 'a':'b':'c':[])
08:45:23 <lambdabot>  ("abc","abc","abc")
08:46:04 <zipper`> Well it does ignore it's input when called with a bind
08:46:30 <Iceland_jack> zipper`: What are you referring to?
08:46:30 <zipper`> Like [] >>=  (\x -> ['a', 'b'])
08:46:31 <dwcook> It ignores its input regardless
08:46:37 <quicksilver> your question, zipper, is really about the list monad
08:46:51 <Iceland_jack> what dwcook said, (\_ -> "ab") always ignores its input
08:46:52 <quicksilver> it is the defiition of >>= for lists which controls the number of times that gets duplicated
08:46:56 <zipper`> quicksilver: Yes I got the function from the list monad
08:47:15 <quicksilver> > [1,2,3] >>= \_ -> "ab"
08:47:16 <lambdabot>  "ababab"
08:47:34 <quicksilver> > [sin,cos,tan] >>= \_ -> "ab"
08:47:35 <lambdabot>  "ababab"
08:47:52 <quicksilver> > [(+),(-),(*)] >>= \_ -> "ab"
08:47:54 <lambdabot>  "ababab"
08:48:24 <zipper`> quicksilver: I see. When called with an empty list the function is called 0 times and to represent this failure the empty list is what is returned
08:48:59 <quicksilver> the implementation of >>= in the list monad is to call the function once for each argument on the left
08:49:04 <quicksilver> and concatenate the results
08:49:31 <quicksilver> > [1,2,3] >>= \x -> [x+1,x-1,x*2]
08:49:32 <lambdabot>  [2,0,2,3,1,4,4,2,6]
08:50:40 <zipper`> Where does it say to return an empty list in case of failure. I am looking at the code but I don't quite see it
08:50:45 <zipper`> quicksilver: ^
08:51:09 <zipper`> Oh fail _ = []
08:51:17 <joelteon> no
08:51:20 <zipper`> in this case we just ran concat on []
08:51:26 <joelteon> it's the definition of (>>=)
08:51:39 <joelteon> > map (\x -> error "unused") []
08:51:40 <lambdabot>  []
08:52:07 <joelteon> zipper`: (>>=) is just map, then concat on the result
08:52:10 <quicksilver> zipper`: there's no failure going on in your example
08:52:17 <dwcook> Hackage says it's: m >>= k             = foldr ((++) . k) [] m
08:52:17 <joelteon> if you map over an empty list, you get an empty list
08:52:21 <joelteon> if you concat an empty list, you get an empty list
08:52:30 <quicksilver> zipper`: >>= runs the function once per item in the list on the left
08:52:39 <quicksilver> no items in list on left = no runs = empty result
08:52:39 <dwcook> >> foldr ((++) . k) [] []
08:52:46 <dwcook> > foldr ((++) . k) [] []
08:52:47 <lambdabot>  Couldn't match expected type `a0 -> [a1]'
08:52:47 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
08:52:51 <zipper`> concat (map (\x -> "ab") []) becomes concat ([]) which becomes []
08:52:52 <dwcook> Erm woops
08:52:58 <joelteon> right
08:53:01 <hcaulfield57> I'm playing around with the Writer monad, could someone explain to me what happens to the [String] part in the do expression in the function addPet: http://lpaste.net/100449
08:53:07 <zipper`> :t concat
08:53:07 <joelteon> :t foldr ((++) . ?k) [] []
08:53:08 <lambdabot> [[a]] -> [a]
08:53:08 <lambdabot> (?k::a -> [a1]) => [a1]
08:53:41 <zipper`> but concat takes type [[a]] yet we fed it [a] in terms of []
08:53:42 <joeyh> Loading package gnutls-0.1.5 ... ghc.exe: internal error: Misaligned section: 18206e5b
08:53:42 * joeyh wonders what to do about this. Other than wish I were not porting to windows
08:53:44 <dwcook> Anyway, when you give foldr [] as the list argument, it gets replaced with the second argument, which is just [] in this example
08:53:48 <dwcook> @src foldr
08:53:48 <lambdabot> foldr f z []     = z
08:53:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:54:36 <dwcook> Sorry, English syntax and Haskell syntax were somewhat ambiguous in what I just said >_<
08:55:01 <dwcook> But the relevant case is the first one in foldr there
08:55:24 <levi> hcaulfield57: What were you expecting to see?
08:55:55 <quicksilver> joeyh: [A]bort [C]ancel [R]edo from start
08:57:17 <hcaulfield57> levi: I just wondered how it kept track of the string after it extracted the Int value, but it has a tempoary variable behind the scenes doesn't it.
08:59:33 <levi> hcaulfield57: If you want to know how a Monad instance keeps track of things, you need to look at its definition of (>>=).
09:00:36 <hcaulfield57> levi: Yea I did, that's how. I think I'm actually kind of understanding the Writer monad, awesome what happens when you read books.
09:01:27 <levi> Yeah, looking at books and source code is pretty enlightening. :)
09:02:58 <hcaulfield57> My example makes sense to me, but I need to look for more ways to extend it.
09:03:53 <zipper`> I wonder why people don't talk about applicatives as much as they do about monads.
09:04:00 <levi> You might try playing with some of the other functions that Writer supports.
09:04:22 <Iceland_jack> zipper`: Monads are older and used for IO
09:04:25 <levi> zipper`: Monads are more integrated with the Prelude, and Applicatives are a newer development.
09:04:59 <geekosaur> also, while you can use Applicatives for IO now, that was a later development even relative to Applicatives IIRC
09:05:09 <zipper`> Still I like them because they are cool and hardly talked about.
09:05:11 <Iceland_jack> People think Haskell can't do IO since it's pure ⇒ people mention the IO monad ⇒ people start talking about monads (they also have a complicated name)
09:05:22 <zipper`> Especially because people don't talk about it.
09:05:33 <Iceland_jack> zipper`: Hardy talked about? People talk about applicatives quite a lot
09:06:06 <Iceland_jack> It's not like Applicatives are an obscure concept within Haskell
09:06:10 <zipper`> I see tweets about monads but I only saw applicatives in LYAH
09:06:27 <bitemyapp> zipper`: LYAH has multiple chapters on monads.
09:07:12 <quicksilver> Iceland_jack: monads are much more visible outside the haskell echo chamber
09:07:16 <zipper`> Let me say people don't tweet the word applicative as often.
09:07:26 <Iceland_jack> zipper`: Because those are probably non-Haskellers :)
09:07:27 <levi> zipper`: Applicative doesn't sound nearly as odd as Monad does.
09:07:34 <hcaulfield57> levi: I am, trying out tell
09:08:12 <levi> hcaulfield57: Are you familiar with the Monoid type class?
09:09:13 <hcaulfield57> levi: Somewhat, I understand the basic concept
09:11:13 <Achylles> How do I set ghci to autocomplete square brackets, quotes and the like?
09:11:49 <hakujin> votes on pronunciation of monad? mon-ad vs mo-nad? does it follow the pattern set by mon-oid?
09:11:52 <`^_^v> write a readline wrapper probably
09:12:08 <zipper`> Iceland_jack: levi Are you saying that applicatives are for haskell alone?
09:12:15 <aleksejs_> Hi! Could anyone help me with happstack sessions? http://vpaste.net/ZipRL how do I fix this code?
09:12:22 <Clint> hakujin: mon-ad
09:12:33 <Iceland_jack> zipper`: How did you reach that conclusion?
09:12:56 <zipper`> Iceland_jack: "<Iceland_jack> zipper`: Because those are probably non-Haskellers :)"
09:13:05 <Iceland_jack> Yes, non-Haskellers that are sending those teets
09:13:06 <hakujin> Clint: that was my thought as well until I heard Simon Marlow pronounce it like mo-nad on one of the Haskell podcasts
09:13:07 <quicksilver> hakujin: I think UK tends to pronounce to rhyme with "gone bad" and  and USA tends to pronounce it to rhyme with 'gonad'
09:13:07 <Iceland_jack> *tweets
09:13:12 <Chousuke_> is there any reason why monad ends in -ad? I suppose the name is supposed to remind the reader of monoids but otherwise it seems arbitrary
09:13:24 <levi> zipper`: Of course not; but neither are Monads. It's just that few languages other than Haskell have a way of constructing and naming their libraries of abstractions like Haskell does.
09:13:48 <Iceland_jack> zipper`: Just to make it clear, I was not talking about applicatives there: there are other languages that have applicative functors just fine
09:13:56 <dwcook> móʊnæd
09:14:13 <Iceland_jack> Chousuke_: For the same reason as dyad
09:14:32 <Iceland_jack> and triad etc.
09:15:18 <Chousuke_> ah. hmm.
09:15:19 <levi> hcaulfield57: Anyway, every Writer has a Monoid instance as well, which is what provides the bit that keeps track of what you 'tell' it.
09:15:43 <mm_freak> aleksejs_: you may want to ask in #happs and be patient =)
09:15:47 <Iceland_jack> Chousuke_: http://en.wiktionary.org/wiki/dyad#Etymology
09:16:05 <aleksejs_> mm_freak, already did yesterday and today
09:16:32 <hcaulfield57> levi: So it can just mappend the 'tell' part?
09:16:58 <Achylles> is there a wall of autocomplete quotes, square brackets and son on in interactive Ghci/Prelude?
09:18:00 <levi> hcaulfield57: Yup. So, you can customize the way a Writer works based on the Monoid you provide to it. And there are a lot of fun Monoids besides lists.
09:19:57 * hackagebot antisplice 0.7.2.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.7.2.0 (implementation)
09:22:04 <ReinH> levi: so many
09:22:19 <Guest37511> any way to do this more simple (Circle is a data structure) ?       c <- Circle `liftM` read `liftM` (getEnvDefault "SOMETHING" "1")
09:22:50 <ReinH> Guest37511: Circle <$> read <$> getEnvDefault "SOMETHING" "!"
09:22:52 <levi> And we were just talking about Applicatives...
09:23:08 <ReinH> liftM = fmap = (<$>)
09:23:27 <hcaulfield57> levi: Yea, glad I'm starting to understand this a little
09:23:30 <bitemyapp> ReinH: listened to the Yorgey cast, really enjoyed it
09:23:46 <ReinH> bitemyapp: awesome!
09:23:51 <bitemyapp> ReinH: I'm stil learning for material that bridges the gap from the typeclassopedia to edwardk mode.
09:23:55 <bitemyapp> yearning*
09:24:02 <ReinH> bitemyapp: me too :) I think I'm going to start writing a bit
09:24:08 <ReinH> based on my relatively mediocre knowledge
09:24:09 <bitemyapp> that would be very welcome.
09:24:19 <bitemyapp> take what I can get, you know more than I do.
09:24:25 <ReinH> bitemyapp: also we recorded again on Sunday :)
09:24:26 <bitemyapp> I know barely any cat theory, I only have basic intuitions.
09:24:29 <ReinH> Just editing it, will be posted soon
09:24:34 <bitemyapp> Sweet.
09:24:37 <levi> I'm not sure edwardk mode is something that can come from a book.
09:24:48 <levi> Or blog posts or whatever.
09:24:57 * hackagebot ironforge 0.1.0.5 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.5 (implementation)
09:24:59 * hackagebot ironforge 0.1.0.6 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.6 (implementation)
09:25:20 <ReinH> levi: or from anything other than being edwardk
09:25:26 <Guest37511> good point, thanks
09:26:19 <levi> Well, of course some aspects follow from being edwardk, but I think a lot of it is just due to obsessively writing tons of code to work out details of things.
09:29:09 <levi> Few things really cement understanding as well as working through things yourself.
09:30:33 <hakujin> levi: agreed
09:33:12 <ReinH> levi: yep
09:33:38 <bitemyapp> levi: pretty sure he read books along the way.
09:33:42 <bitemyapp> but there are other things.
09:33:51 <bitemyapp> Anything can be taught, some things are just harder than others to teach or to learn or both.
09:34:21 <bitemyapp> I do not like notions that say you have to be an anointed one to have learned something, that takes the wrong view of human progress and education.
09:35:05 <levi> Sure, I certainly didn't mean to suggest anything contrary to that.
09:35:13 <Achylles> Is there a way of matching quotes, square brackets and the like in interactive mode Prelude or Ghci?
09:35:56 <quicksilver> Achylles: you've asked that three times.
09:36:06 <Achylles> quicksilver, yes
09:36:22 <quicksilver> you got an answer the first time "write a readline wrapper probably"
09:37:52 <Achylles> quicksilver, I did not see the answer. Probably because it was not highlighted here
09:37:58 <levi> I meant that "edwardk mode" is achievable by anyone who is willing to put the level of work that edwardk did into learning things, and that a lot of his knowledge (based on what he's said, anyway) came from working through problems and writing code rather than waiting for someone to write tutorials.
09:39:36 <Twey> We already have a readline wrapper, don't we?
09:39:39 <levi> That said, I would certainly welcome more intermediate-level tutorial or other documentation.
09:40:02 <quicksilver> Achylles: there is no core ghci support for that
09:40:20 <quicksilver> Achylles: some people run ghci inside emacs which will syntax highlight and balance brakcets
09:40:30 <bitemyapp> levi: you're right but progress comes from pedagogy, not from everybody bootstrapping the same things over and over.
09:40:40 <bitemyapp> levi: nobody expects you to derive calculus yourself, you just get taught it.
09:42:08 <chirpsalot> bitemyapp: some would argue you don't really learn calculus unless you derive it yourself :P
09:42:58 <Achylles> quicksilver, yes. I know that it can be done in emacs and vim as well, but I was interested in doing that interactively in Ghci/Prelude. In python, I think it is possible to do that.
09:43:01 <chirpsalot> Granted you can definitely get a working knowledge of it without.
09:43:12 <Twey> Chousuke_: I think it's the other way around, actually.  X-oid usually means ‘something that's like an X’ (humanoid = something with the shape of a human but not actually human, groupoid = something that has group structure, but spread across multiple levels, android = something that's like a man but not, cuboid = something that's like a cube but doesn't necessarily have all its edges the same length)
09:43:34 <chirpsalot> Achylles: Python uses readline.
09:43:49 <hcaulfield57> Cool, this program almost does something useful with Writer: http://lpaste.net/100450
09:44:15 <chirpsalot> Achylles: but you can just use something like rlwrap maybe, and write a script to call ghci with it.
09:44:19 <levi> bitemyapp: I'm not disagreeing with you. I think effective pedagogy is extremely important as well.
09:44:33 <Achylles> chirpsalot, could you point me to a place were I could write this readline for ghci?
09:45:14 <chirpsalot> Achylles: it's already been done: http://freecode.com/projects/rlwrap
09:45:17 <c_wraith> bitemyapp: good pedagogy means teaching people to learn without being spoonfed.
09:45:41 <bitemyapp> chirpsalot: that's a symptom of broken teaching anyway. Calculus classes are often ick and taught when they shouldn't be.
09:45:50 <bitemyapp> c_wraith: sure?
09:46:02 <chirpsalot> bitemyapp: oh yeah, and linear algebra courses are even worse.
09:46:05 <levi> hcaulfield57: Cool. :)
09:46:17 <chirpsalot> Achylles: Essentially you just write a program that forks ghci into a separate process and then in the main process you grab input with readline and pass that input to the ghci process.
09:46:17 <bitemyapp> c_wraith: but that should be so that can be primed to explore undiscovered country, not retread already known material.
09:46:29 <chirpsalot> Achylles: and that's what rlwrap does.
09:46:29 <Achylles> chirpsalot, quicksilver thx :)
09:46:55 <quicksilver> Achylles: it's a fair point. I don't know why it isn't more commonly thought about. I tend to use emacs' sexp navigation commands as soon as I'm dealing with 'big' expressions in ghci, personally.
09:47:15 <c_wraith> bitemyapp: I don't see a difference between those two, except for how much time you're willing to put into researching whether something is already known or not.
09:47:28 * bitemyapp eyeroll
09:47:29 <monochrom> I like discussing learning and teaching, but it is #haskell-blah material. meanwhile, you can learn haskell without deriving haskell. :)
09:47:51 <hakujin> Achylles: you can already configure the readline behavior somewhat inside ~/.haskeline
09:47:55 <hakujin> Achylles: see http://hackage.haskell.org/package/haskeline-0.7.1.2/docs/System-Console-Haskeline.html
09:48:01 <monochrom> (but, oh wait, you can't learn Show by "deriving Show" haha)
09:48:03 <Achylles> quicksilver, perhaps this feature should come by default, as in Python, upon installing haskell
09:48:28 <chirpsalot> Achylles: then you'll want to look up how to change your GNU readline settings to show blinking matching parentheses or whatever. Don't ask me how to do it :P.
09:49:00 <Achylles> :)
09:49:08 <chirpsalot> Why doesn't ghci use GNU readline anyway?
09:49:13 <hello> quick q: does this exist anywhere in the std lib: byN :: Int -> [a] -> [[a]];  byN n [] = []; byN n xs = take n xs : byN n (drop n xs); , so for example byN 3 [1,2,3,4,5,6] gives [[1,2,3],[4,5,6]] ? I don't see anything from hoogle/hayoo
09:49:26 <levi> Lots of things don't use GNU readline due to license issues.
09:49:35 <quicksilver> chirpsalot: license issues, yes.
09:49:36 <chirpsalot> levi: aaaaaah, okay fair :).
09:49:48 <hcaulfield57> levi: Is that kind of a way you could use Writer, I mean I assuming you did something practical with the Writer somewhere else
09:49:56 <monochrom> hello: I think the package "split" has it
09:50:06 <hello> ok, thanks
09:50:33 <monochrom> it also comes with Haskell Platform
09:50:44 <monochrom> the module name is Data.List.Split
09:50:49 <levi> hcaulfield57: Yes, actually, logging things or accumulating things that are not part of the primary calculation that's going on is a very common use case for Writer.
09:51:03 <hcaulfield57> levi: cool, got it, I think.
09:51:05 <monochrom> chunksOf
09:51:14 <hello> yep, see it now
09:51:18 <hello> thanks a lot!
09:52:03 <levi> hcaulfield57: Many DSLs are built around a Writer that accumulates some structure based on the actions you run in the monad.
09:53:18 <tolt> Does anyone have resources about having a remote repository for cabal that's private
09:53:44 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#remote-repo
09:54:09 <dcoutts> tolt: quite a few companies do that, often using an instance of the hackage-server (but a "dumb" archive on an ordinary web server is also possible)
09:54:35 <hcaulfield57> dsl?
09:54:39 <tolt> dcoutts: Alright. Thanks. I'll look into mirroring hackage
09:54:50 <dcoutts> tolt: you don't have to mirror it
09:55:05 <dcoutts> tolt: you can configure cabal to use two servers, a local and the community one
09:55:05 <tolt> dcoutts: Yeah. Sorry. I said the wrong thing.
09:55:08 <levi> hcaulfield57: A 'domain-specific language'
09:56:41 <dcoutts> monochrom: I like your description of our UI dilemma in "cabal install ≠ Setup install"
09:56:51 <monochrom> \∩/
09:57:15 <dcoutts> monochrom: you're quite right that we ended up with an annoying clash there with meanings from two contexts
09:58:01 <dcoutts> and I think the reason we've not resolved it properly is that doing it properly involves tracking dependencies better
09:59:20 <zipper> How can I write: [1..50] >>= (\x -> if (x < 7) then (return x) else return 0)  So that it acts like:  [x | x <- [1..50], x < 7]
10:00:53 <quicksilver> zipper: [1..50] >>= \x -> guard (x<7)
10:01:11 <zipper> guard
10:01:12 <zipper> OMG
10:01:12 <quicksilver> > [1..50] >>= \x -> guard (x<7)
10:01:13 <lambdabot>  [(),(),(),(),(),()]
10:01:20 <quicksilver> sorry
10:01:25 <quicksilver> > [1..50] >>= \x -> guard (x<7) >> return x
10:01:26 <lambdabot>  [1,2,3,4,5,6]
10:01:27 <dcoutts> zipper: or with monad comprehensions then you can just use [x | x <- [1..50], x < 7]
10:01:45 <levi> hcaulfield57: For example, this project is essentially a reader monad with a bunch of actions that have the effect of building a set of CSS rules that can then be rendered to a CSS document: http://fvisser.nl/clay/
10:01:47 <quicksilver> dcoutts: I think zipper is just trying to understand how to desugar list comps into list monad operations.
10:02:12 <quicksilver> dcoutts: (you don't need monad comprehensions, the monad here is fixed by the occurrence of [1..50] ;)
10:02:13 <dcoutts> ok, and I'm wrong anyway, it's concretely the list monad
10:02:22 <dcoutts> quicksilver: yep :-)
10:02:29 <quicksilver> zipper: you can do it with if, as well
10:02:45 <quicksilver> > [1..50] >>= \x -> if x<7 then return x else fail
10:02:46 <lambdabot>  Couldn't match expected type `[b0]'
10:02:46 <FreeFull> dcoutts: guard works for any MonadPlus though
10:02:46 <lambdabot>              with actual type `GHC.Base.String -> m0 a0'
10:02:50 <quicksilver> > [1..50] >>= \x -> if x<7 then return x else fail ""
10:02:52 <lambdabot>  [1,2,3,4,5,6]
10:03:21 <FreeFull> Well, I suppose you could use monad comprehensions
10:03:48 <FreeFull> If you use something more general that [1..50]
10:05:02 * hackagebot linux-cgroup 0.1.1.0 - Very basic interface to the Linux CGroup Virtual Filesystem  http://hackage.haskell.org/package/linux-cgroup-0.1.1.0 (clord)
10:05:37 <ski> @undo [x | x <- [1..50], x < 7]
10:05:37 <lambdabot> concatMap (\ x -> if x < 7 then [x] else []) [1 .. 50]
10:06:04 <zipper> quicksilver: How come this fails: [1..50] >>= (\x -> if (x < 7) then (return x) else return ())
10:06:15 <ski> @src guard
10:06:16 <lambdabot> guard True  =  return ()
10:06:16 <lambdabot> guard False =  mzero
10:06:34 <ski> `mzero' isn't `return ()'
10:06:59 <ski> if you use `if (x < 7) then (return x) else return ()', then `return x' must have same type as `return ()', so `x' has type `()'
10:07:01 <quicksilver> zipper: because () is not the same type as '1'
10:07:05 <levi> zipper: a conditional must have the same type in both branches.
10:07:13 <levi> Ah, too slow.
10:07:17 <quicksilver> zipper: your action must either be returning numbers or ()s, not both.
10:08:14 <quicksilver> > [1..50] >>= (\x -> if (x < 7)then (return (Left x)) else return (Right ()))
10:08:15 <lambdabot>  [Left 1,Left 2,Left 3,Left 4,Left 5,Left 6,Right (),Right (),Right (),Right ...
10:08:24 <quicksilver> unless you choose a type which contains both possibilities
10:08:26 <ski> @let instance Num () where () + () = (); () - () = (); () * () = (); negate () = (); abs () = (); signum () = (); fromInteger 0 = ()
10:08:28 <lambdabot>  Defined.
10:08:29 <quicksilver> but that's quite different.
10:09:03 <c_wraith> > 7 :: ()
10:09:05 <lambdabot>  *Exception: L.hs:153:9-26: Non-exhaustive patterns in function fromInteger
10:09:14 <ski> @let instance Num () where () + () = (); () - () = (); () * () = (); negate () = (); abs () = (); signum () = (); fromInteger _ = ()
10:09:16 <lambdabot>  Defined.
10:09:19 <ski> > [1..50] >>= (\x -> if (x < 7) then (return x) else return ())
10:09:21 <lambdabot>  [()]
10:09:47 <ski> > 7 :: ()
10:09:48 <lambdabot>  ()
10:10:07 <ski> (the trivial ring)
10:10:54 <ski> hmm
10:12:00 <ski> it might be nice if a method implementation for `fromInteger' could specify the case for `1', but otherwise rely on a default implementation to get the other ones
10:12:55 <ski> however, i think with the current system either you use a default implementation of an operation, or all of it gets replaced (with no way to refer to the default implementation in the new one either)
10:13:13 <ski> @src when
10:13:13 <lambdabot> when p s = if p then s else return ()
10:13:19 <ski> zipper ^
10:14:23 <zipper> ski: Thanks for the when.
10:14:48 * ski . o O ( ⌜⤚⎯→⌝ )
10:15:06 <Twey> ski: It might be nice in general if you could override part of a derived instance but not the rest, referring back to the derived instance
10:15:44 <ski> Twey : you mean for `deriving' ? or for an explicit subclass of a derived instance ?
10:15:52 <Twey> For ‘deriving’
10:16:00 <Twey> It's really annoying when writing ‘show’ instances for types with a lot of constructors, *one* of which contains a lambda
10:16:34 <bitemyapp> Twey: I usually just ddump-deriv
10:16:42 * ski thinks it's really annoying that if you use record notation sugar for a constructor, then `Show' insists to use that
10:16:53 <Twey> It would be much better if I could say show (HardCase _) = whatever; show _ = derivedShow;
10:17:07 * ski sometimes defines the `Show' manually (with `showsPrec' and `showParen' and so on), just to get around that
10:17:15 <Zolomon> Can anyone recommend any good library similar to Perl's and Python's Mechanize?
10:17:19 <ski> Twey : *nod*
10:17:51 <ski> bitemyapp : hehe, i suppose i run that in my head
10:17:55 <Twey> Yeah, it would be nice to be able to specify parameters to derived instances, as well
10:18:05 <Twey> bitemyapp: But it won't match the formatting of the rest of my file :<
10:18:19 <Cale> Zolomon: Perhaps http://hackage.haskell.org/package/HTTP-4000.2.11/docs/Network-Browser.html
10:18:19 <bitemyapp> Twey: so reformat it. :|
10:18:31 <ski> elaborate on what you mean by "parameters to derived instances" ?
10:18:38 <Twey> Zolomon: http://hackage.haskell.org/package/webdriver ?
10:18:41 <Cale> (I had to look up what Mechanize was though, so I might have the wrong idea)
10:19:21 <Zolomon> Twey: Is webdriver headless, or does it need a browser to actually perform?
10:19:22 <Cale> oh, I see
10:19:40 <Cale> Yeah, that's somewhat higher level in nature than Network.Browser, I suppose.
10:20:07 <zipper> @src when
10:20:08 <lambdabot> when p s = if p then s else return ()
10:20:20 <Twey> Zolomon: It needs a browser, but the browser can be PhantomJS, which is headless
10:20:51 <Twey> (but it looks like there aren't currently PhantomJS controls included with the package; you'd have to write those [and preferably submit a patch] but it shouldn't be too hard)
10:21:01 <Twey> Oh, actually
10:21:29 <Twey> Yeah, I think you can just use the core stuff: the browser-specific packages are just for browser-specific extensions to the protocol, so the package should drive PhantomJS fine
10:21:35 <zipper> I really don't see why monads are useful. There seems to be other ways for achieving some of this stuff.
10:22:01 <ski> which "this stuff" are you thinking about ?
10:22:13 <levi> zipper: Just because there are other ways to do things doesn't mean that monads aren't useful.
10:22:23 <c_wraith> zipper: Monad is an abstraction.  What it gives you is a way to treat many things uniformly.  Every concrete thing that you can do with monads, you can do without.
10:22:44 <Cale> zipper: It's just an abstraction. You get the stuff in Control.Monad for free when you happen to notice that the library you're writing defines a monad
10:22:45 <Cale> That's it
10:22:47 <zipper> but people on twitter talk about monads like they are god's gift to programmers
10:22:55 <Cale> zipper: Well, those people are silly
10:22:56 <zipper> I just had to know what they were
10:22:56 <ski> monads in Haskell are mostly useful as a way to avoid some boilerplate, by being able to reuse operations in `Control.Monad',`Data.Traversable', and so on
10:23:40 <Twey> zipper: Various things with monadic structure are very useful.  It's also very nice to be able to reüse monad-agnostic code.
10:23:42 <zipper> and when I did I am disappointed. I expected them to be super hard because I don't know lamda calculus and doing majical things.
10:23:43 <Cale> Recognising that certain things happen to be monads is nice, but even if you never did it, those same libraries would be just as useful
10:24:09 <Cale> (it would just be more tedious to write them, because you'd have to write the equivalent of Control.Monad for each one)
10:24:09 <zipper> c_wraith: exactly it is an abstraction
10:24:14 <c_wraith> zipper: in general, the hard part is convincing people monads are not hard. :)
10:25:17 <ski> zipper : on another level, monads are useful because they enable a way to encode effects without side-effects
10:25:17 <zipper> Well before I knew what a lamda was I used to see people always tweet about lamdas like they were some beast that solves all your problems.
10:25:22 <Cale> The bigger thing is the general approach to writing embedded domain specific languages or combinator libraries
10:25:24 <zipper> Programming is a lie
10:25:37 <dwcook> Twey, interesting that you wrote that with a diuresis
10:25:47 <Cale> and that may or may not give you a monad, but in any case, it's a good approach to many problems
10:25:51 <ski> zipper : or perhaps i should say, specific monads enable a way to encode specific effects without side-effects
10:26:20 <Twey> dwcook: ‘Diæresis’.  I like them and want to bring them back into fashion.  ☺
10:26:22 <Cale> zipper: Well, having lambda vs. not having lambda is a pretty big deal.
10:26:33 <Cale> It changes the way that you write programs
10:26:38 <ski> zipper : you have to admit that not being able to factor out "an expression with a hole" from some piece of code is pretty annoying
10:26:40 <zipper> Cale: True
10:26:41 <levi> zipper: Programming is, in some sense, one of the most honest activities. If you lie to the computer, it will catch you in it.
10:26:52 <dwcook> Twey, woops, yeah, just wrong enough word to be terrible >_<
10:26:58 <Twey> zipper: These all sound very unimpressive, until you try to go back to a language without them… :þ
10:27:04 <dwcook> Twey, what purpose did it serve there?
10:27:11 <Cale> Twey: I think they're silly.
10:27:14 <Twey> dwcook: Very terrible :þ
10:27:19 <zipper> Twey: I assume so :)
10:27:26 <Cale> LOOK OUT THERE'S A VOWEL NEXT TO ANOTHER VOWEL HERE
10:27:30 <Twey> Cale: Yes, but you hate fun.  And kittens.
10:27:51 <Twey> dwcook: It indicates that the two vowels are to be pronounced separately, not as a diphthong
10:27:54 <levi> Evangelizing programming languages, on the other hand, is not always quite so honest.
10:28:11 * ski thinks they look silly *and* fun ..
10:28:44 <Twey> dwcook: For example, ‘coop’ (a place to keep chickens) vs. ‘coöp’ (a shortening of ‘coöperative’), or ‘unionize’ (banding together to form a union) vs. ‘
10:29:01 <Twey> Er, no, I meant to delete that last one: that's not relevant
10:29:17 <Cale> zipper: In a similar way, I suppose that having the monad abstraction around changes the way that we approach writing our libraries. I personally don't think that it's *always* a good effect, but anything that gets people into taking the approach of writing EDSL-style libraries is a good thing.
10:29:37 <Kaidelong> that's just like Afrikaans
10:29:41 <Cale> I tend to think that we shouldn't set out to define monads though, just notice when they happen to occur.
10:29:41 <Twey> ‘Unionize’ vs. ‘un-ionize’ is an interesting distinction but sadly the diæresis doesn't solve it.  ☹
10:29:51 <ski> someone ought to start writing diæresis below consonants immediately following other consonants
10:29:58 <zipper> Quite honestly if you read on types then functors then applicatives and monoids I guess monads aren't that hard. But I won't call them easy until I have successfully applied them in real life programming.
10:30:28 <Cale> zipper: They're really no big deal. The hard part for most people is just learning functional programming.
10:30:29 <levi> zipper: Monads were "invented" or "developed" completely outside of the realm of programming. They were first brought into the discussion surrounding programming because they helped to organize mathematical descriptions of what programs work, precisely because they are good at capturing the idea of effects that are associated with computations.
10:30:36 <Twey> ski: You have to be pretty conservative with these things, or all conversations degenerate into conversations about your orthography.  It's very sad.
10:30:44 <Kaidelong> Twey are you talking about Dutch? Do they also run into needing ï like in "geïnstalleer"
10:30:44 <levi> s/what programs work/what programs mean/
10:30:54 <Twey> Kaidelong: I don't know about Dutch, sorry
10:30:58 <dwcook> Twey, okay if I bring this topic to -blah?
10:31:02 <Twey> dwcook: Sure
10:31:39 <Cale> zipper: Like, if you look at the State monad specifically, that's a really hardcore application of functional programming -- you're working with functions as values, and combining them together via higher order functions, and if you're not comfortable with that, that's going to be tricky, but the reason has nothing to do with the monad abstraction.
10:32:54 <Cale> Similarly, if you're writing a parser combinator library for the first time, for example, there's lots of stuff about that which takes getting used to on its own.
10:33:23 <zipper> True
10:34:18 <levi> The monad abstraction itself is a bit tricky to describe precisely; it's easy to talk about its definition in terms of laws, but a bit more difficult to describe the ideas and intuitions that go into it.
10:34:34 <Cale> The monad abstraction itself will tend to be a tiny fragment of the API of many of these libraries, but it's one with a pretty good power/weight ratio: you implement return and (>>=), and you get a few dozen things from Control.Monad and Data.Traversable and then lots of stuff from other libraries that people have written.
10:35:35 <Cale> But yeah, the sort of library which happens to be able to define a monad tends to be a serious exercise in functional programming, once you get past a couple really simple examples.
10:35:39 <zipper> levi: I see it in terms of laws to be honest.
10:36:06 <levi> zipper: There's nothing wrong with that; that's the definition, after all.
10:36:51 <levi> But I think people who are pondering Monads are trying to work out the *implications* of the laws and the context in which they arise.
10:38:00 <levi> That's not necessary to use them, of course, but it's interesting and can help you recognize when something has monadic structure and where you might expect to find that structure.
10:39:58 <Cale> I've also seen cases where people have tried extra hard to force the issue, and turned things which ought to be much simpler into monads in contrived and probably not helpful ways.
10:40:06 <hcaulfield57> Could anyone suggest improvement for this program? It's like 8 lines http://lpaste.net/100456
10:40:12 <Cale> (especially things which are naturally monoids)
10:40:50 <chirpsalot> I always liked the "Monads are programmable semicolons" metaphor. That's what started to make them click for me.
10:42:52 <amalloy> hcaulfield57: well, cat h = hGetContents h >>= (hPutStr stdout), i think
10:43:05 <levi> But when you look into the structure of monads and how it relates to other structures, you can recognize that there is something of a monoidal structure to a monad, and that can help you see when it's more appropriate to use a monoid and when the extra structure of a monad is called for.
10:43:41 <hcaulfield57> amalloy: Thank you, yea that works too
10:43:42 <Cale> amalloy: Well, that's equivalent to the do-block that was written. It's a matter of taste which one you prefer
10:44:01 <Cale> You could also write  cat = hGetContents >=> hPutStr stdout
10:44:47 <YayMe> Can you define a catamorphism in terms of a functor?
10:45:03 <triliyn> You can also combine lines 13 and 14 into "mapM_ (cat >=> open) argv", I think
10:45:10 <Cale> YayMe: Yes, as the unique map given by an initial F-algebra
10:45:10 <amalloy> ah, thanks Cale. i knew there was some monad-oriented version of . but i always forget about it
10:45:34 <triliyn> Maybe <=<
10:45:39 <triliyn> I never remember which one is which
10:45:46 <Cale> <=< is the one which is more like composition
10:45:55 <Cale> and >=> is backwards :P
10:46:19 <triliyn> hmm, so I guess there is an analogy with >>= and =<<
10:46:32 <triliyn> But yes, they're kind of weird operators
10:46:34 <Cale> cat = hPutStr stdout <=< hGetContents  -- probably a bit nicer?
10:46:54 <YayMe> Cale: Anything you can point me to that shows a catamorphism in terms of a functor?
10:47:02 <levi> Depends on whether you want to think of it as a function composition or an action pipeline, I guess.
10:47:11 <triliyn> If you really wanted to do line golf you could get rid of the definition of cat entirely
10:47:35 <triliyn> mapM_ (hPutStr stdout <=< hGetContents <=< open) argv
10:48:19 <Cale> YayMe: Okay, so given a functor F, an F-algebra consists of some object A, together with a specified arrow a: FA -> A
10:48:24 <YayMe> it interesting how >>= and >=> become the standard just because much of Haskell begs you to read it right to left rather than left to right.
10:48:26 <hcaulfield57> Wow, I didn't know about >=>
10:49:26 <Cale> YayMe: and a homomorphism h between F-algebras (A,a) and (B,b) is an arrow h: A -> B such that h . a = b . Fh
10:49:41 <Cale> (perhaps it's best to actually draw the diagram)
10:50:28 <Cale> So, you'll have a: FA -> A along the top, and b: FB -> B along the bottom, and then Fh and h going vertically to form the sides of the square
10:50:38 <YayMe> Cale: I've seen enough of the category theory diagrams to be with you this far - but making the leap from the functor to the catamorphism is where I'm missing the link
10:50:48 <levi> YayMe: Most of the papers that talk about 'catamorphism' introduce it in terms of functors.  'Functional Programming With Bananas, Lenses, Envelopes, and Barbed Wire' is one example: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
10:51:03 <Cale> YayMe: Okay, so for any functor F, we have a category of F-algebras. This category might have an initial object.
10:52:47 <Cale> If it does, then that initial object is some F-algebra (X, x: FX -> X) such that for any other F-algebra (A, a: FA -> A), there's a unique F-algebra homomorphism X -> A (and this is the catamorphism, in a way that I'll show by example)
10:53:00 <Cale> So, consider the example of Maybe
10:53:07 <YayMe> Cale: Oh, so does the derivation generalize it by saying a catamorphism is reaching for the seed "initial" object rather than the perspective that the category of F-algebras is the seed?
10:53:51 <YayMe> (I'm not convinced what I just said makes any sense at all.)
10:54:09 <Cale> Catamorphisms are things which exist for initial F-algebras. For example, the natural numbers are an initial F-algebra, and you have a catamorphism which gives maps out of the natural numbers
10:54:24 <Cale> For the natural numbers, F is Maybe :)
10:54:31 <Cale> Let's have a look at that
10:54:44 <Cale> What's a Maybe-algebra homomorphism?
10:55:42 <Cale> Well, suppose we have maps a: Maybe A -> A and b: Maybe B -> B, then our Maybe-algebra homomorphism h will be a function A -> B, such that h . a = b . fmap h
10:56:21 <Cale> Both sides of that equation are functions Maybe A -> B, let's apply them to constructors of Maybe and simplify a little:
10:56:30 <YayMe> hmm... is recursion necessary for the definition even with the map?
10:56:34 <Cale> h (a Nothing) = b (fmap h Nothing)
10:56:57 <YayMe> that might be where I'm getting hung up; I'm trying to think about how you can get the catamorphism from the functor without recursing
10:57:00 <Cale> So: h (a Nothing) = b Nothing
10:57:16 <Cale> Just follow along with what I'm doing for now, we'll get to recursion in a moment
10:57:26 <YayMe> Ok.
10:57:35 <Cale> and similarly, we have
10:58:00 <Cale> h (a (Just x)) = b (fmap h (Just x)) = b (Just (h x))
10:58:16 <joelteon> hi, anybody familiar with pipes-network-tls? it has two separate functions for building a ByteString Producer, and a ByteString Consumer
10:58:23 <joelteon> should I be using both of those?
10:58:36 <joelteon> if I want to use a bidirectional TCP socket
10:58:43 <Cale> Now, I claim that  data Nat = Zero | Succ Nat  is an initial Maybe-algebra (ignoring issues about partially-defined values)
10:59:20 <Cale> Well, first of all, I have to say how it's a Maybe algebra, by specifying a function  Maybe Nat -> Nat
10:59:36 <Cale> So I'm going to give the function:
10:59:45 <Cale> n Nothing = Zero
10:59:48 <YayMe> Cale: wherein Zero is Nothing?
10:59:58 <Cale> n (Just x) = Succ x
11:00:24 <YayMe> Cale: Ok, yeah that was my intuition about a Maybe-algebra using Nat..
11:00:28 <Cale> Now, suppose we're given some other Maybe-algebra A
11:00:36 <Cale> with a: Maybe A -> A
11:00:37 <amalloy> Cale: ITYM Succ (n x)?
11:00:47 <Cale> nope
11:00:51 <amalloy> oh, i misread
11:01:05 <Cale> I'm just defining n :: Maybe Nat -> Nat
11:01:29 <Cale> So, let's consider what it means for h to be a Maybe-algebra homomorphism (Nat,n) -> (A,a)
11:02:00 <Cale> Actually, if you'll allow it, let's use (B,b) instead, because it'll work better with the above
11:02:16 <Cale> So we had in general  h (a Nothing) = b Nothing
11:02:23 <Cale> and here a = n
11:02:28 <Cale> and n Nothing = Zero
11:02:37 <Cale> So we know that  h Zero = b Nothing
11:02:58 <Cale> and in general, we had  h (a (Just x)) = b (fmap h (Just x)) = b (Just (h x))
11:03:17 <Cale> and we know that n (Just x) = Succ x
11:03:38 <Cale> So h (Succ x) = b (Just (h x))
11:04:16 <Cale> These form a recursive definition of h, there's exactly one function h which will work here.
11:04:27 <Cale> and that's the catamorphism for Nat
11:04:59 <YayMe> n (Just x) = Succ x therefore h (n (Just x)) = h (Succ x) = b (fmap (h (Succ x)))
11:05:04 <Cale> To make it look a little more like something you'd usually expect to see as a "fold" over natural numbers, i.e. something which takes replacements for the constructors of Nat as parameters, we can split this up
11:05:10 <YayMe> So I see the recursion there...
11:05:31 <Cale> b (fmap h (Just x)) rather
11:05:40 <Cale> which is b (Just (h x))
11:05:54 <Cale> (by the definition of fmap for Maybe)
11:06:11 <YayMe> ahh
11:06:15 <simonal> Does anyone know why haskell-mode in emacs isn't able to find files in other directories even though they're defined in the .cabal file? Constantly getting "Could not find module <..>"
11:06:47 <Cale> So let's define z = b Nothing, and s x = b (Just x)
11:06:49 <Kaidelong> has anyone written a windowing toolkit in haskell?
11:07:01 <levi> simonal: You must be using hdevtools or ghc-mod, and they are probably not configured correctly.
11:07:08 <Cale> z and s uniquely determine what function b is
11:07:30 <YayMe> Cale: Yeah my confusion what around the recursion; I thought through defining fold in terms of bind which is easy without recursion, then when I tried to think through the same using fmap my reasoning fell down because I was thinking not using recursion
11:07:48 <Cale> and with those, we can write this as  h Zero = z  and  h (Succ x) = s (h x)
11:07:55 <simonal> levi: are both of those emacs modes?
11:08:22 <Cale> and that's much more like you'd expect a fold to look
11:08:35 <YayMe> Sure, that makes sense
11:08:40 <levi> simonal: No, they're haskell programs that are run to do checking of your programs by emacs modes.
11:08:54 <Cale> foldNat z s = h where h Zero = z; h (Succ x) = s (h x)
11:09:05 <simonal> levi: roger, looking into it :)
11:09:44 <levi> simonal: Did you just install haskell-mode on a vanilla emacs config, or do you have something like emacs prelude installed?
11:10:37 <Cale> YayMe: So yeah, in general, the technique is to hopefully capture recursive data types as fixed points of certain functors, and in the case where that's possible, those fixed points will be initial F-algebras for those functors F.
11:10:49 <Cale> and you'll get catamorphisms
11:12:27 <simonal> levi: using prelude, so I'm running flycheck
11:12:40 <Kaidelong> looks like if I am going to learn from previous efforts I should look at Haggis and HToolkit
11:13:13 <Kaidelong> but the haggis source code doesn't seem to be hosted anymore so never mind about that
11:13:19 <levi> simonal: flycheck is set up to use hdevtools, and hdevtools doesn't understand cabal sandboxes natively. This means you need to pass it some ghci parameters to explicitly tell it about the sandbox.
11:14:53 <simonal> levi: some global parameters or do I need to specify some for a specific project?
11:16:39 <levi> simonal: Well, the flycheck configuration for haskell already looks up this stuff automatically; it's just not set up yet (as of a week or so, I guess) to give the correct parameters to hdevtools, which requires a rather awkward way of passing ghci parameters. I have hacked something up, but I am far from expert at elisp. :/
11:18:22 <simonal> levi: well that's a shame :) can I see the code you came up with somehow?
11:20:11 * hackagebot deka 0.4.0.2 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.4.0.2 (OmariNorman)
11:20:30 <levi> Hmm. Let me see if I can get to it from here.
11:20:45 <simonal> Thanks!
11:27:39 <levi> simonal: https://gist.github.com/pinealservo/9257248
11:28:01 <levi> This is probably not the right way to do it, but hopefully it can help you figure out the right way. :)
11:30:27 <simonal> awesome! I will take a shot at it :)
11:30:36 <Peaker> Dealing with EOF anywhere (any line might end with an EOF) in a Parsec parser seems much more difficult than it should be
11:31:04 <johnw> i've never had to deal with EOF before
11:31:08 <johnw> so maybe you're doing something wrong
11:31:53 <Peaker> For example, I have some noise-eating parser:  noiseLine = (many horizSpace *> optional comment *> (P.eof <|> P.char '\n'))   and I want to skip noise lines by using:  skipMany noiseLine
11:32:58 <Peaker> but noiseLine, in case of EOF, eats 0 input
11:32:59 <johnw> try: many ((horizSpace >* optional comment) `sepBy` newline)
11:33:15 <d3lxa> I would like to group elements of a list, to use with lookup later, I've come with (a->b)->[a]->[(b,[a])] but there is no standard function, any hint? thx
11:33:24 <merijn>  The arrows in the bananas, lenses, envelopes and barbed wire paper are profunctors, no?
11:33:28 <Peaker> johnw: thanks
11:33:43 <Rembane> d3lxa: What about group?
11:33:52 <Peaker> johnw: seems like the sepBy takes care of the outer "many" too
11:34:19 <Javran> I'm reading the paper about FingerTree, wondering what is an "ordinary 2-3-tree"?
11:34:19 <johnw> yeah, you're right
11:34:35 <johnw> javran: 2-3-tree are a very old balanced data structure
11:34:45 <levi> Javran: I think they mean one that doesn't have the annotations.
11:34:47 <johnw> the CLR book has a chapter on them, I'm pretty sure
11:35:09 <Rembane> d3lxa: Nevermind.
11:35:19 <merijn> johnw: Do you mean CLRS?
11:35:21 <levi> They just have the 2-3 structural invariant.
11:35:23 <d3lxa> Rembane: group uses Eq but it won't do it, I could use groupBy but that's not very convenient, I could extract the key I use then
11:35:26 <johnw> I guess I do
11:35:51 <Rembane> d3lxa: Okay, then I think a custom function would help you the most.
11:36:05 * ski thinks `P.eof' is evil
11:37:15 <ski> d3lxa : not sure how your `(a->b)->[a]->[(b,[a])]' would work, without an `Eq b', say
11:37:16 <Javran> johnw: ok, I found it on wikipedia, just thought there were lots of "x-y trees" following some implicit convention
11:37:37 <d3lxa> ski: yup, that's true, I forgot to say Eq b
11:37:53 <ski> @type group
11:37:53 <lambdabot> Eq a => [a] -> [[a]]
11:37:55 <ski> @type groupBy
11:37:56 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
11:38:34 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
11:38:36 <lambdabot>  Defined.
11:38:41 <Peaker> Is there an applicative parser package, rather than a monadic parser package -- so that I can describe the parser without worrying about efficiency concerns?   e.g: with monadic parsers, if    a <|> b <|> c    all start with x *> y *> z    that part should be extracted, but at the expense of modularity
11:38:56 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
11:38:57 <lambdabot>  Defined.
11:39:13 <ski> @type groupBy (comparing snd)
11:39:14 <lambdabot>     Couldn't match type `Ordering' with `Bool'
11:39:14 <lambdabot>     Expected type: (a0, a0) -> (a0, a0) -> Bool
11:39:14 <lambdabot>       Actual type: (a0, a0) -> (a0, a0) -> Ordering
11:39:27 <ski> @type comparing
11:39:27 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:39:49 <merijn> Peaker: Don't you need the arrow parsing stuff by Swierstra for that?
11:39:49 <levi> Peaker: I know that uu-parsinglib does some optimizations if you eschew the monadic operations in your parser constructions. I don't think it's the only one, though.
11:39:57 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
11:39:58 <lambdabot>  Defined.
11:40:04 <ski> @type groupBy (equating snd)
11:40:05 <lambdabot> Eq b => [(a, b)] -> [[(a, b)]]
11:40:13 <Peaker> merijn: arrow is just applicative + category + cumbersome
11:40:25 <ski> @type map (head &&& map snd) . groupBy (equating snd)
11:40:25 <lambdabot> Eq b => [(a, b)] -> [((a, b), [b])]
11:40:38 <ski> @type map ((fst . head) &&& map snd) . groupBy (equating snd)
11:40:39 <lambdabot> Eq b => [(a, b)] -> [(a, [b])]
11:40:56 <ski> @type \f -> map ((fst . head) &&& map snd) . groupBy (equating snd) . map (graph f)
11:40:57 <lambdabot> Eq b => (a -> b) -> [a] -> [(a, [b])]
11:40:57 <Peaker> levi: it doesn't allow IO though, which I use in Parsec for include parsing (which I guess is a monadic part anyway)
11:41:15 <ski> hm, no
11:41:27 <ski> @type \f -> map ((snd . head) &&& map fst) . groupBy (equating fst) . map (graph f)
11:41:28 <lambdabot> Eq a => (a -> b) -> [a] -> [(b, [a])]
11:41:33 <d3lxa> \o/
11:41:34 <ski> d3lxa : there ^ ?
11:42:09 <levi> Peaker: If you're in a monad transformer, you are stuck with bind anyway, so you're not going to get your Applicative optimization.
11:42:25 <Peaker> levi: that's true, but perhaps the effect would be localized
11:42:34 <ski> hmm
11:42:37 <ski> actually
11:42:42 <Peaker> levi: so that the actions in both sides of the bind, which were applicatively bound would be optimized
11:42:42 <ski> @type \f -> map ((snd . head) &&& map fst) . groupBy (equating snd) . map (graph f)
11:42:43 <lambdabot> Eq b => (a -> b) -> [a] -> [(b, [a])]
11:42:51 <levi> If you can chunk your input, then you can feed pure chunks into a resumable parser, which uu-parsinglib is.
11:42:52 <ski> d3lxa : since you wanted to compare the `b's
11:42:54 <jle`> when should i be manually writing inline pragmas?
11:43:58 <d3lxa> ski: I'm reading your functions, that's cool :P
11:44:44 <Peaker> levi: but I need a parser to chunk my input
11:44:52 <Peaker> levi: I need to find an "include" directive
11:45:22 <d3lxa> ski: thank you very much :)
11:45:38 <ski> @type ap (,)
11:45:38 <lambdabot> (a -> b) -> a -> (a, b)
11:45:44 <levi> Peaker: Yeah, this is not a trivial problem.
11:45:45 <ski> @type graph
11:45:45 <lambdabot> Arrow ar => ar a b -> ar a (a, b)
11:46:08 <Peaker> levi: Parsec is the only transformer :(
11:46:09 <ski> d3lxa : you can use `ap (,)' or something like that instead of the arrow (or category) based `graph' version
11:46:17 <levi> Peaker: I'm actually working on an asciidoc parser, which also needs to do inclusion.
11:46:57 <ski> d3lxa : and btw, the `head' is ok since `group' (and `groupBy') generates a list of non-empty lists
11:47:03 <levi> My plan at the moment is to parse in multiple phases and join the parse trees at inclusion points.
11:47:31 <ski> otherwise one should be wary about `head',`tail',`fromJust',`fromLeft',`fromRight' and such things
11:48:40 <d3lxa> yes, of course
11:54:08 <Twey> :t graph
11:54:09 <lambdabot> Arrow ar => ar a b -> ar a (a, b)
11:54:17 <Twey> What is this magic?
11:54:53 <dwcook> > graph id "hey"
11:54:55 <lambdabot>  ("hey","hey")
11:54:56 <Twey> :t equating
11:54:57 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
11:55:07 <shachaf> http://hackage.haskell.org/package/profunctors-3.1.1/docs/Data-Profunctor.html#v:lenticular
11:55:08 <dwcook> > graph (+1) 0
11:55:08 <Twey> equating = on (==) ?
11:55:10 <lambdabot>  ((),())
11:55:10 <shachaf> That's my class!
11:55:16 <dwcook> Wait what
11:55:27 <Twey> dwcook: Haha, someone defined a Num instance for ()
11:55:29 <dwcook> > graph (+1) (0 :: Integer)
11:55:30 <lambdabot>  (0,1)
11:55:41 <Twey> Now 0 defaults to 0 ∷ ()
11:55:47 <dwcook> I'm hoping that wasn't me
11:55:48 <pyon> Twey: apply function and then test for equality I guess
11:56:02 <Twey> pyon: Yeah, on (==)
11:56:05 <dwcook> I vaguely recall contemplating Num ()
11:56:08 <pyon> Where are graph and equating defined, though?
11:56:08 <Twey> Which is one character shorter :þ
11:56:39 <Twey> shachaf: What's ‘upstar’?
11:56:48 <dwcook> No never mind, I was contemplating Num [()]
11:56:59 <pyon> wat
11:57:04 <shachaf> Twey: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
11:57:10 <dwcook> pyon, in lambdabot
11:57:13 <Twey> Oh, thanks
11:57:15 <aristid> :t graph
11:57:17 <lambdabot> Arrow ar => ar a b -> ar a (a, b)
11:57:31 <aristid> > 0
11:57:34 <lambdabot>  ()
11:57:37 <aristid> wtf
11:57:40 <Twey> @undefine
11:57:40 <lambdabot> Undefined.
11:57:43 <Twey> > 0
11:57:45 <lambdabot>  0
11:57:46 <Twey> Phew.
11:57:48 <dwcook> \o/
11:57:58 <aristid> lambdabot allows @define for instances now?
11:58:04 <Twey> aristid: Yep
11:58:08 <Twey> And types
11:58:17 <Twey> And classes
11:58:51 <aristid> Twey: so basically any string that happens to be valid haskell syntax?
11:58:59 <Twey> @define class Pointed a where point :: a -> m a
11:59:00 <lambdabot>  Defined.
11:59:09 <Twey> aristid: I think it just appends it to L.hs
11:59:20 <Twey> Damn, that was wrong
11:59:22 <Twey> @undefine
11:59:22 <lambdabot> Undefined.
11:59:27 <Twey> @define class Pointed m where point :: a -> m a
11:59:28 <lambdabot>  Defined.
11:59:35 <aristid> @define LET US SEE WHETHER IT CHECKS ANY SYNTAX
11:59:35 <lambdabot>  Parse failed: TemplateHaskell is not enabled
11:59:39 <Twey> Heh.
11:59:52 <shachaf> let us see whether it accepts /msg
12:03:24 <ski> aristid : probably not modules
12:10:16 * hackagebot pipes-postgresql-simple 0.1.2.0 - Convert various postgresql-simple calls to work with pipes  http://hackage.haskell.org/package/pipes-postgresql-simple-0.1.2.0 (OliverCharles)
12:25:13 <haasn> I think just lines that would be valid if appended to L.hs
12:28:02 <riceandbeans> anyone here good with networking want to give me a hand with something
12:28:05 <riceandbeans> totally not haskell related
12:28:59 <Clint> i totally don't want to
12:29:06 <riceandbeans> but you totally will
12:29:11 <riceandbeans> right?
12:29:12 <riceandbeans> :)
12:29:24 * BMeph_ Milky Ways
12:29:39 * BMeph_ stops, pauses, then...
12:29:45 * BMeph_ Snickers!
12:29:57 <riceandbeans> some systems on my network can't be tracerouted to by Linux/BSD by UDP
12:30:30 <riceandbeans> but with Windows (where you can't change tracert protocol and it defaults to UDP) and OS X (god only knows), you can traceroute by UDP
12:30:43 <riceandbeans> but with Linux/BSD, if I traceroute with ICMP, it works fine
12:31:17 <riceandbeans> but since VPN traffic has to go across those networks on UDP for Linux/BSD systems, it's an issue because the core switch is dropping them
12:31:37 <riceandbeans> but OS X/Windows use HTTPS for their VPN
12:31:43 <riceandbeans> proprietary client
12:31:49 <riceandbeans> I'm getting nagged to make it work
12:31:54 <riceandbeans> I'm about out of ideas
12:32:20 <peddie> riceandbeans: this is probably not the channel in which to solicit ideas about this
12:32:58 <riceandbeans> peddie: most active channel I'm in right now and was just probing because I'm curious and I've got network engineers nagging me to fix it, and you guys are smarter than me
12:33:25 <riceandbeans> I'm not going to make a big deal out of it, was just hoping someone knew right away OH THAT'S BLAH BLAH
12:33:46 <BMeph_> riceandbeans: I'd definitely suggest #haskell-blah - you have started by saying this is "totally not haskell related".
12:34:00 <riceandbeans> I know
12:34:19 <BMeph_> riceandbeans: And yet, you continue on.... :)
12:34:26 <riceandbeans> how about, if I want to use Haskell to fix this issue at work?
12:34:28 <riceandbeans> :P
12:34:29 <riceandbeans> better?
12:34:57 <riceandbeans> tough crowd
12:35:16 <riceandbeans> well, I'm going to stare at electric sheep
12:40:32 <ski> Twey : `graph' computes the graph of a function, and `cograph' naturally computes the cograph
12:41:50 <BMeph_> ski: Wouldn't 'cograph' conaturally mpute the cograph? ;þ
12:42:37 * BMeph_ dedicates that one to copumpkin!
12:43:11 <ski> BMeph_ : that would probably be an isomorphic way to state the same thing, yes
12:57:38 <shapr> sm: stupid question, where should I expect to find the binary after I've done cabal install rss2irc ?
12:58:04 <milfjord> ~/.cabal/bin
12:58:37 <shapr> Ok, so it really doesn't exist.
12:59:50 <sm> if you're using a cabal sandbox, then .cabal-sandbox/bin
13:01:00 <sm> and somewhere else if you're on windows
13:01:28 <shapr> sm: I tried cabal install rss2irc from a fresh Ubuntu install, it fails to compile
13:02:03 <sm> shapr: which ghc versino ?
13:02:08 <johnw> shapr: hello!
13:02:15 <shapr> hi johnw!
13:03:10 <shapr> sm: ghc 7.6.3, Utils.hs fails with result http://lpaste.net/100461
13:03:14 <shapr> johnw: How's code?
13:03:29 <johnw> going well, just working on a heavy-duty upgrade of our server technology these past two motnhs
13:04:07 <shapr> I've been trying to write elisp some the past day, I can barely remember how it works!
13:04:11 <johnw> hahah
13:04:21 <johnw> yeah, I haven't done hardly any elisp in the past year and a half
13:04:35 <sm> shapr: and what version does ghc-pkg list feed report ?
13:04:36 <johnw> Haskell has consumed me
13:05:13 <shapr> sm: 0.3.9.2
13:05:22 * hackagebot FontyFruity 0.1.0.3 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.1.0.3 (VincentBerthoux)
13:05:23 <kristof> Ok, so
13:05:30 <shapr> johnw: that's not a bad thing... if you switch to Yi, then we know your conversion is complete :-)
13:05:33 <kristof> Values in haskell are boxed by their type constructors!
13:05:38 <shapr> kristof: really?!
13:05:47 <johnw> hoh
13:05:49 <johnw> heh
13:05:57 <kristof> Is this a true statement?
13:06:20 <shapr> Apocalisp: one day, you wil be Apocahaskell!
13:06:30 <shapr> kristof: I think so?
13:06:32 <n-dolio> kristof: No.
13:06:43 <kristof> n-dolio: So how do we pattern match?
13:06:50 <n-dolio> Type constructors are type-level things.
13:06:56 <n-dolio> Like Maybe and Int.
13:07:01 <kristof> n-dolio: Surely they exist at runtime.
13:07:21 <n-dolio> Value level things are just constructors.
13:07:43 <kristof> Er
13:07:47 <kristof> I guess I meant value constructors, then
13:07:50 <kristof> like Cons
13:07:56 <sm> shapr: feed api has changed between 0.3.9.1 and 0.3.9.2, that's bad
13:08:15 <shapr> sm: so, force 0.3.9.1 and I can use rss2irc? :-)
13:08:34 <sm> yup, or I'll release a new rss2irc in a sec with the tighter upper bound
13:08:40 * ski . o O ( "Apocahaskas" )
13:08:49 <shapr> sm: spiffy, thanks!
13:09:02 <shapr> It's sooo handy to actually know the author of the code you want to use :-)
13:09:09 <kristof> n-dolio: Care to clear up my misunderstanding?
13:09:21 <n-dolio> kristof: Then yes.
13:09:32 <n-dolio> Just is a value constructor, Maybe is a type constructor.
13:09:54 <ski> kristof : data constructors exist at run time, corresponds to tags in lisps (but different types may reuse the same tags for data constructors)
13:09:57 <n-dolio> And data creates constructors that box things.
13:10:25 <ski> kristof : type constructors don't exist at run-time, though, we have type erasure, compilation removes all traces of types (proper)
13:10:35 <kristof> n-dolio: Then values in haskell are boxed by their value constructor at runtime, which impedes performance perhaps slightly because you need to unbox values to get to them, but it allows for glorious pattern matching. And if you need sheer unboxed values, then there are unboxed vector implementations, right?
13:10:50 <ski> (there can still in some cases be values which is *evidence* of some types, or which track them to some extent)
13:11:15 <kristof> ski: Not *all* traces, right? Because erasure isn't perfect. :P
13:11:17 <n-dolio> newtypes do not box things, either.
13:11:39 <n-dolio> They have exactly one constructor with one argument.
13:12:02 <n-dolio> And can't contain 'unboxed' types like Int#.
13:12:15 <kristof> Oh, I'm not familiar with the unboxed types
13:12:18 <n-dolio> But they don't further box already boxed things.
13:12:46 <ski> kristof : all traces, iiui. obviously code which treats some word as an `Int32' will still apply the correct machine code operations to it. but there's no information left to enable *checking* that that word really was meant to be interpreted as an `Int32'
13:13:12 <kristof> Interesting.
13:13:21 <sm> extra-source-files for a changelog, not extra-doc-files, right
13:13:24 <kristof> Love me some haskell <3
13:13:32 <ski> (rather than as a tag, which we for some reason want to do some arithmetic on, in the low-level implementation)
13:14:09 <ski> kristof : the boxing needed for thunks is different from the boxing needed for multiple data constructors in a type
13:14:13 <simon> it seems that my cabal libraries are messed up. I want to 'cabal install yesod', but it tells me this: https://gist.github.com/sshine/044081c01df4a4f81eab
13:15:05 <kristof> ski: any good reason for that?
13:15:19 <simon> I have no idea why yesod-1.2.1 would break when I install yesod, I'm pretty sure "yessir" is just a package I made myself when experimenting, and I don't know why yesod-platform-1.2.1 is installed either.
13:15:23 <sm> shapr: done, thanks for the report
13:15:24 * hackagebot rss2irc 1.0.5 - watches an RSS/Atom feed and writes it to an IRC channel  http://hackage.haskell.org/package/rss2irc-1.0.5 (SimonMichael)
13:15:30 <shapr> sm: hurrah! many thanks for the instant fix!
13:15:36 <simon> should I just --force-reinstall it?
13:15:59 <shapr> sm: Does anyone use rss2irc to announce github commits?
13:16:33 <ski> kristof : dynamic typers sometimes think that the tags needed to `case' is a trace of type information, but that's because they commonly think of such tags, and what we think of as types, as being shades of the same thing (since there's perhaps no clear distinction here in a dyn. typed (strongly typed) language)
13:17:02 <ski> kristof : still, imo, our notion of what is and what isn't type information makes sense, i think
13:17:09 <sm> shapr: I don't know.. I think I did once
13:18:23 <sm> rss2irc -r5 GITFEED should announce a few things on the console
13:18:45 <kristof> ski: dependently typed languages, on the other hand...
13:19:11 <kristof> ski: I know the Idris folks are really proud of the type erasure that they've got at the moment
13:19:33 <ski> kristof : well, e.g. to distinguish between `Left x' and `Right y', you need at least one extra tag bit (perhaps put in the low two or three bits, due to word-alignment) -- that wouldn't work if `x' was to be an unboxed `Int32#' on a 32-bit system, though
13:20:00 <kristof> I see
13:20:25 <kristof> ski: Speaking of low level representations, what do first class functions look like at the memory level?
13:20:28 <sm> shapr: a bug I must warn you about, if the feed has an outage and then comes back up while rss2irc is running, it can re-announce all items
13:21:02 <ski> kristof : yeah, dependent types gives more opportunity for useful applications of type erasure (because the type system is more powerful, you can use the already existing type erasure in more interesting (but still safe) ways) -- though GADTs do give some of the power of some of the simplest applications of dep. types
13:21:44 <kristof> ski: well, GADTs aren't powerful enough to express type level contract stuff, right?
13:22:44 <ski> kristof : otoh, for thunks, we need a code pointer (and possibly an environment pointer, aka a static link) -- one could consider something like `data Thunk a = Value a | Computation (() -> a)' in a strict language, and then changing the tag from `Computation' to `Value', and replacing the `() -> a' function with the resulting `a' value
13:23:15 <shapr> sm: I can live with that
13:23:35 <ski> kristof : another version is to just store a `() -> a', and replace it with another function that just returns the result directly -- iiuc, this is what GHC does
13:24:15 <ski> kristof : probably depends on the type level contract in question -- but for advanced cases, probably no
13:25:03 <ski> kristof : i don't know that much details about the actual representation GHC uses, though. i think it would make sense that it would need to store a code pointer and a static link, at least
13:25:30 <kristof> ski: I got that far when I was thinking about it, but then I started thinking about runtime generated code
13:25:38 <kristof> ski: runtime generated functions, I mean
13:30:24 <ski> kristof : if you're really talking about RTCG (such as `foreign import ccall "dynamic"' and `foreign import ccall "wrapper"' at <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-160004.1>), then you need some area to generate the code in, and then you just use a code pointer to that area (maybe making sure the code block can be GCed properly later)
13:30:53 <ski> kristof : otherwise, i.e. for returning functions constructed by lambda, or other functions like `(.)', &c., you need no RTCG
13:31:23 <ski> you just need the environment / static link in the closure
13:34:10 <ski> kristof : you could conceptually think of `(->)' as being defined like `data a -> b = forall x. Clos# (# x , (# x , a #) #-> b #)', compare with `struct a_to_b { void *opaque_env; b (*code)(void *opaque_env, a arg); };' if you know any C
13:34:26 <kristof> I do know C but dear god
13:37:45 <ski> kristof : basically, C unortunately lacks existentials, so that is uglier than it should be
13:39:48 <ski> (of course, C also lacks parametric polymorphism / universals. at least you can get some kind of version of that (though code duplication) in C++)
13:40:06 <Actreka> Is there a reason why haskell isn't used much in real-life applications (except xmonad and darcs)?
13:40:24 <Feuerbach> and pandoc
13:40:29 <Feuerbach> and git-annex
13:41:17 <peddie> Actreka: ask standard chartered, who have >1M lines of haskell in their codebase . . .
13:41:34 <ski> kristof : see "Existential Types for Imperative Languages" in 2002-04 at <http://www.cs.washington.edu/homes/djg/papers/exists_imp.pdf>, and "Quantified Types in an Imperative Language" in 2006-05 at <http://www.cs.washington.edu/homes/djg/papers/qtil.pdf>, both by Dan Grossman, for the Cyclone language, a low-level language meant to resemble C a bit, but being safer
13:42:34 <ownclo> ski: where can I find additional information to understand that 'Clos# (# x, .......' notation? What does '(# ..... #)' means?
13:43:21 <ski> kristof : `a #-> b' above is meant to be the type of "global" functions from `a' to `b', i.e. like bare C pointers, which can, apart from its arguments and things constructed from them, only refer to things being defined in the global extent, iow existing as long as the process exists
13:44:01 <Actreka> peddie: So the real reason haskell isn't used with most software companies is becuase it's not that popular (yet?)?
13:44:30 <peddie> Actreka: I can't tell you for sure, but that could be :)
13:46:49 <Actreka> Might be a stupid question, but is there something of importance that is impossible in haskell but that OOL can do?
13:46:59 <joelteon> no
13:47:02 <peddie> Actreka: not that I know of
13:47:29 <Zolomon> I know this isn't Haskell code, but what is the purpose of https://github.com/scalaz/scalaz/blob/HEAD/core/src/main/scala/scalaz/Yoneda.scala ? It's way over my head, but would like to understand the use of it.
13:47:49 <ownclo> I believe that the control of side effects is of considerable importance
13:47:50 <ski> kristof : this `a #-> b' logically corresponds to Lewis' strict implication/conditional ⌜A ⥽ B⌝ <http://en.wikipedia.org/wiki/Strict_implication>,<http://en.wikipedia.org/wiki/Clarence_Irving_Lewis#Logic>, which is the same as ⌜□ (A → B)⌝, where the modal "necessity" operator ⌜□⌝ expresses that something is "global (extent)"
13:48:08 <peddie> Actreka: is there something you'd like to use Haskell to do but can't figure out how?
13:48:40 <kristof> ski: Introducing existential types to an imperative language, to me, sounds a little like putting turbo jets onto a horse-drawn cart.
13:48:49 <ownclo> omg misread your question, sorry
13:50:23 <pavonia> Zolomon: Maybe that article helps https://www.fpcomplete.com/user/bartosz/understanding-yoneda
13:50:27 * hackagebot stomp-queue 0.1.4 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.1.4 (TobiasSchoofs)
13:50:29 * hackagebot stomp-patterns 0.0.1 - Stompl MOM Stomp Patterns  http://hackage.haskell.org/package/stomp-patterns-0.0.1 (TobiasSchoofs)
13:50:32 <Actreka> peddie: Kind of, I'm just asking lots of questions because I'm so used to OOL that it seems like FL are missing something. I'm trying to figure out how to create layouts in xmonad, but I guess I have to finish reading learnyouahaskell so that I at least know what a monad is.
13:51:03 <Zolomon> pavonia: Oh, thanks! Haven't seen that article.
13:51:30 <kristof> Actreka: On the contrary. Some people describe FL and OO as being "different" paradigms looking at the same problems, but in fact, (besides inheritance) OO is entirely encapsulated by functional programming as a discipline and is more general.
13:51:53 <kristof> Actreka: Yeah, don't try to hack XMonad without understanding Haskell first.
13:51:55 <supki_> Zolomon: you may want to ask this question in #scalaz too ;)
13:52:48 <ownclo> kristof: did you say that OO is more general?
13:53:18 <peddie> Actreka: I'm not sure you need to understand what a monad is to define new layouts; it looks like you can just build them out of the core ones from XMonad.Layout
13:53:49 <Actreka> kristof: So are you saying FL is a superset of OOL, does that mean that all OOL are compiled to a functional language before it becomes a binary?
13:53:51 <peddie> Actreka: you mean "create layouts" like in http://hackage.haskell.org/package/xmonad-contrib-0.11.2/docs/XMonad-Layout-Spiral.html for example?
13:54:36 <kristof> Actreka: I meant that SEMANTICALLY, you can express "Object Oriented Programming" in terms of functional programming (with side-effects, of course)
13:55:08 <tautologico> you can also express functional programming using objects
13:55:18 <kristof> Actreka: Everytime you write obj.method(arg1 arg2), you're really writing method(obj arg1 arg2) where the type of obj specializes the implementation of method.
13:55:28 <Actreka> peddie: Wow, it is just what I'm looking for. Thanks. Do I just add those lines then I'll have a new layout?
13:55:47 <peddie> Actreka: you can import XMonad.Layout.Spiral and you'll have access to the Spiral layout that's defined in that module
13:55:55 <ownclo> kristof: I think that it's vice-versa.
13:55:57 <kristof> tautologico: Try writing "sort" in Java prior to Java 8 (which just introduced lambdas and first class methods).
13:56:15 <peddie> Actreka: if you click the 'Contents' tab at the top of that page, there are a _lot_ of layouts defined for you in that package
13:56:49 <Actreka> peddie: This is really great, thank you :)
13:56:54 <peddie> Actreka: if you click the 'Source' tab at the top of that page, you can see how the Spiral layout is implemented in terms of XMonad's basic layout functions; that might be a good place to start if you want to define your own
13:57:00 <peddie> Actreka: you're very welcome!
13:57:10 <Actreka> kristof: Now the whole programming-bit seems to make more sense actually when you explained it
13:58:17 <Actreka> kristof: I see you mentioned lambdas, is that something I will learn later in the haskellbook? Is it connected to lambda calculus?
13:58:55 <tautologico> kristof: that's beside the point, my point being that you can express objects using closures, but you can also express closures using objects
13:59:25 <Actreka> kristof: Never mind, I can see that I will learn about Lambdas on the page I'm reading just now
13:59:32 <kristof> Actreka: Heh.
13:59:39 <njcomsec> my head is gonna explode
13:59:47 <kristof> tautologico: You missed the context of what I said because you joined midway through what I was saying
14:00:32 <ski> kristof : imo, existentials are sorely needed in languages like C,C++ (less so in Java and C#,because they don't have the same kind of function pointers. existentials would still be useful there as well, though)
14:00:35 <kristof> tautologico: Your referring to the Guy Steele observation :P I agree with it. I'm just talking about FP being a generalizaiton of OO.
14:00:38 <Actreka> njcomsec: That was my feeling when I started learning haskell two days ago, but it's still there :)
14:01:01 <johnw> just think of the sun: sustained, continual explosion
14:01:02 <ski> kristof : many classes of unsafe casts (the whole `void *' business) could be avoided, by universals and existentials
14:01:10 <kristof> ski: I would prefer C be strongly typed before I utilize its type system in such a way.
14:01:20 <peddie> Actreka: I believe there's also an #xmonad channel if you want more xmonad help
14:01:45 <ownclo> kristof: could you explain that point any further? I cannot see why you consider one paradigm to be a superset of the other
14:02:06 <tautologico> it's not a generalization, they're duals
14:02:09 <ski> @quote yoneda
14:02:09 <lambdabot> edwardk says: you can view Yoneda f as enforced fmap fusion and Codensity f as enforced bind fusion.
14:02:13 <ski> hm, no
14:02:28 <ownclo> tautologico: that's what I think too
14:02:29 <ski> @quote enterprise.industry
14:02:29 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
14:02:34 <ski> (apropos <https://www.fpcomplete.com/user/bartosz/understanding-yoneda>)
14:02:40 <kristof> ownclo: Read what I wrote at 13:54 about obj.method == method (obj)
14:03:02 <Actreka> peddie: I was just there asking about the layouts before I came here, they said something about learning monads first
14:03:27 <peddie> oh, huh
14:03:31 * peddie shrugs
14:03:48 <tautologico> it's not an observation just by Guy Steele, lots of people have investigated the relation between objects and functions, encapsulation, existential types and etc
14:03:53 <Actreka> peddie: Using the hackage packages you showed me seemed like a better solution though
14:04:00 <ownclo> kristof: I read that. Why don't you flip the equation and voila? FP is a subset of OO?
14:04:19 <peddie> Actreka: yeah, xmonad-contrib has 22 million modules; it's great
14:04:55 <kristof> ownclo: Because there are some functions you can't express in pure object orientation. Like I said: how do I write the map function in Java, prior to lambdas?
14:05:19 <Actreka> peddie: What?! 22 million different modules? Can anyone add a module of their own on hackage?
14:05:30 <peddie> Actreka: I'm exaggerating
14:05:30 <kristof> ownclo: To express those kinds of things, you have to break free of the computational paradigm of "objects sending messages to one another" and accept functional programming constructs. ... but then, suddenly, you're not pure OO anymore.
14:05:45 <tautologico> kristof: with an anonymous inner class
14:05:46 <peddie> Actreka: anyone can upload a library; the xmonad-contrib library contains a lot of useful things, is what I meant to say
14:06:11 <tautologico> kristof: anything is expressible with OO too, you're just not seeing how... if a function has any parameter at all, it can be a receiver
14:06:15 <ownclo> kristof: I'd suggest some weird 'List.map(MyMapper.new ... )'
14:06:24 <Actreka> peddie: These libraries are just haskell sourcefiles or binaries?
14:06:39 <tautologico> I suggest reading the TaPL chapters on existentials
14:06:59 <kristof> tautologico: Every method a slave to a class. :'( 1) anonymous classes are verbose for what they're trying to express, usually, and 2) classes that are never instantiated as objects are missing the point of classes and shoehorning concepts into a paradigm that doesn't accept them.
14:07:02 <peddie> Actreka: they're stored on the server as Haskell source and some metadata; if you use the 'cabal install' command, it will download it and its dependencies and compile them to binary libraries and programs for you
14:07:25 <ski> kristof : this would be a step towards making C closer to being strongly type
14:07:28 <ski> kristof,Actreka : if we restrict ourselves to some typical parts of FP vs. OOP, then "FL and OO as being \"different\" paradigms looking at the same problems" is true, they're dual -- this doesn't take into account all the usual extra baggage in both cases, though
14:07:30 <kristof> I'm going to stop making off topic conversation in #haskell. Join me in #haskell-offtopic if you care to continue this!
14:07:38 <peddie> Actreka: see http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html#installing.haskell.software
14:08:05 <peddie> Actreka: if you installed the haskell platform, you already have the 'cabal' command
14:08:17 <Actreka> peddie: Great, I just install cabal on my system now
14:08:22 <kristof> *haskell-blah
14:08:41 <Actreka> peddie: I just had the GHC, but maybe it's because Archlinux splits it up
14:08:47 <tautologico> I'm talking from a theory standpoint, the pragmatics are different because most people who make OO languages know very little about the theory of programming languages, while most people creating FP languages know a lot about it :)
14:08:52 <ski> kristof,Actreka : it's true that OOPLs often has a mishabit of encouraging the dogma "everything is an object". FPLs don't seem to fall into the "everything is a function" trap as commonly
14:08:54 <peddie> Actreka: you could see whether Arch Linux has a haskell platform package
14:09:16 <`^_^v> i disagree, most people that make OO languages know a lot about it
14:09:22 <kristof> ski: tautologico, to haskell-blah >.>
14:09:28 <johnw> ski: even this discussion is an object
14:09:40 <Actreka> peddie: What do you mean by platform in this case?
14:09:49 <tautologico> `^_^v: that's not what I get from the basic language design errors I see in languages like Python and Ruby
14:10:02 <binroot> Hey guys, I'm having trouble installing the hstats library. cabal says Ambiguous module name `Prelude`
14:10:05 <peddie> @where platform
14:10:05 <lambdabot> http://hackage.haskell.org/platform/
14:10:09 <peddie> Actreka: ^
14:10:12 <binroot> help please?
14:10:46 <`^_^v> i dont know ruby, but i'm interested in hearing your complaints about python
14:10:48 <tautologico> also, Java is type unsafe to this day because of co-variance
14:10:50 <`^_^v> in PM maybe
14:11:21 <kristof> tautologico: so you're not going to jump into #haskell-blah?
14:11:49 <Actreka> peddie: Thank you, but will having a platform be any different than using only GHC and GHCI with cabal?
14:11:50 <ski> tautologico : i suppose you mean for arrays
14:12:01 <`^_^v> fwiw python wasn't designed as an OO language
14:12:11 <peddie> Actreka: it will bring in a lot of helpful packages, and the stuff in the platform is pretty well supported
14:12:14 <`^_^v> objects are just an afterthought
14:12:16 <tautologico> ski: yes
14:12:23 <ski> tautologico : worse, in Eiffel, method argument types are covariant
14:12:50 * ski doesn't see Actreka in #haskell-blah
14:12:53 <peddie> Actreka: you can just use ghc with cabal-install if you like; it's fine
14:12:56 <tautologico> `^_^v: python's scoping rules are weird too, this is probably because GvR didn't really understand lexical scoping when he started python
14:13:52 <Actreka> peddie: To use these packages I just do "import packagename", and then it's done?
14:13:59 <tautologico> I mostly like python as a language, actually
14:14:17 <peddie> Actreka: once it's installed, yes, e.g. "import XMonad.Layout.Spiral"
14:15:27 <`^_^v> no, he understood it. he made a conscious decision not to have the kind of scope you refer to, though
14:15:56 <levi> Most scripting languages have bizarre scoping rules, mostly out of pragmatic concerns regarding the syntax.
14:16:21 <Actreka> peddie: Sweet, you've been really helpful, thanks
14:16:35 <peddie> Actreka: good luck!
14:17:00 <`^_^v> i agree its harder to reason about, but there are use cases for it, and it almost kind of makes sense given python's dynamic nature
14:19:17 <regexkind> has anyone used Data.Binary.Put?
14:19:18 <levi> I'm curious what you mean by that.
14:19:41 <levi> regexkind: I have, but I don't remember too many details.
14:20:01 <levi> Go ahead and ask; hopefully *someone* will know the answer or at least where to find an answer.
14:20:25 <regexkind> I think my troubles originate in not quite understanding monads properly
14:20:27 <regexkind> but here goes:
14:20:31 * hackagebot FontyFruity 0.1.0.4 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.1.0.4 (VincentBerthoux)
14:20:32 <`^_^v> by which part
14:20:49 <regexkind> I want to put a datastructure to bytestring
14:21:24 <regexkind> but I am having difficulty constructing the right kind of equation for my putter
14:22:03 <regexkind> like I wanted my type to be
14:22:12 <regexkind> putWavHeaderData :: Put (WavMap)
14:22:16 <regexkind> but that's not allowed
14:22:41 <anothernick> how do I know when my EditText is being touched? I want to delete all text in it the FIRST time it is touched.
14:22:49 <regexkind> because defining a  put won't allow you to give args?
14:23:31 <regexkind> the compiler tells me that `Put' is applied to too many arguments
14:23:47 <regexkind> which makes sense with what the haddock documentation says
14:24:03 <regexkind> but I am not really sure exactly how I'm supposed to give anything to Put
14:24:06 <levi> Ahh. Well, Put doesn't need to be parameterized because it's always just binary data.
14:24:37 <monochrom> it seems to me you should be typing it as WavMap -> Put
14:24:53 <regexkind> I'll try that, thanks
14:26:19 <levi> Put is actually an alias for PutM (), but again you probably don't need that because the binary output is wrapped in PutM's Writer monad.
14:27:24 <levi> And by 'binary output' I mean the builder that you construct with the Put monad actions.
14:27:55 <regexkind> It Links! thanks :D
14:28:06 <levi> Cool!
14:28:56 <levi> `^_^v: I mean I was curious why you think that Python's dynamic nature and its scoping rules go along together.
14:30:48 <`^_^v> because its scoping rules are more dynamic than static scope?
14:31:31 <levi> The scoping rules are static, though. They're just confusing.
14:32:12 <astropirate> Hello friends!!
14:32:26 <astropirate> Is Learn you a Haskell still the best place to learn haskell?
14:32:36 <shiona> what's confusing about pythons scoping? I thought they were just like C's or Java's
14:32:37 <astropirate> how do the fpComplete tutorials compare?
14:32:39 <levi> It's still a good place to learn it, yes.
14:32:39 <tautologico> it is a good place, I think
14:32:40 * haasn .oO( “Static scoping isn't dynamic enough for a dynamic language! Dynamic languages are supposed to be hip and reactive!” -hopefully nobody )
14:32:55 <haasn> astropirate: it's not objectively “the best” because there is not a metric for that; but it's certainly quite popular and often recommended
14:32:57 <monochrom> the best for me is A Gentle Introduction to Haskell. but people stone me to death for this.
14:32:58 <milfjord> shiona: #haskell-blah?
14:33:07 <shiona> milfjord: ok, I'll shus up
14:33:11 <tautologico> though it does include a lot of material that is not exactly beginner stuff by the end
14:33:13 <astropirate> monochrom, why?
14:33:14 <milfjord> shiona: noo :-(
14:33:24 <haasn> #haskell-blah does not mean “shut up”, it means “continue talking by all means, in #haskell-blah”
14:33:24 <monochrom> I don't know
14:33:42 <shiona> I have too many channels as it is
14:33:44 <`^_^v> i guess the rules themselves are static, but python's scope is definitely not
14:33:44 <conal> The Gentle Intro was my intro to Haskell. I loved it.
14:33:52 <astropirate> I will give tha a try
14:34:00 <milfjord> `^_^v: yes, it is
14:34:03 <tautologico> if you're an experienced programmer you may begin straight with Real World Haskell
14:34:07 <astropirate> i tried LYAHFGG last year and go to the Monads chapter, but then stoped
14:34:14 <hakujin> anyone know how GHC fares on FreeBSD vs Linux? any RTS performance differences?
14:34:26 <monochrom> then you should continue it. sunk cost policy :)
14:34:32 <levi> It's pretty weird these days to come across a language with dynamic scope. But elisp is an example of one that's still around.
14:35:00 <astropirate> monochrom, I plan to. the trouble is i don't remember the stuff :p
14:35:08 <monochrom> haha ok
14:35:11 <levi> A little review never hurts. :)
14:35:11 <astropirate> i made a few simple physics calculation applicaitons but thats it
14:36:07 <carter> hakujin: it should be decent
14:36:30 <`^_^v> in the code try: e = NameError; nonexistent \n except e: print "caught", e escapes its lexical block
14:36:30 <carter> hakujin: if you find any issues, figure out a small repro example and file a bug report
14:38:22 <levi> `^_^v: Python isn't block-scoped, but it is statically scoped.
14:39:32 <`^_^v> ok, i see what you mean
14:39:48 <hpc> levi: is it indentation-scoped? ;)
14:39:56 <carter> its funny scoped
14:41:36 <levi> http://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules
14:42:15 <carter> the history of python scoping is crazy]
14:42:35 <milfjord> if you want a "scripting language" with sane scoping, look at perl
14:42:45 <carter> or scheme
14:42:48 <carter> or haskell
14:42:49 <carter> or c
14:42:51 <carter> or lua
14:43:01 <levi> Scripting languages tend to do stupid things out of the desire to avoid making you declare local variables.
14:43:03 <milfjord> those are not commonly considered scripting languages (except lua)
14:43:47 <hakujin> runhaskell disagrees, as does almost all schemes?
14:44:35 <monochrom> hehe
14:44:37 <levi> "scripting language" is not a well-defined term.
14:44:40 <Earnestly> tcc?  *hides*
14:46:24 <RichyB> levi, I'm partial to the predicate, "can I put #!/path/to/interpreter on the first line of a text file and have it run from that?"
14:46:31 <RichyB> IIRC tcc qualifies! :)
14:46:47 <levi> I think this paper is the origin of the dichotomy: http://www.tcl.tk/doc/scripting.html
14:47:26 <Earnestly> RichyB: But then that sort of applies to anything :P
14:48:24 <levi> (tcl, by the way, is another example of dynamic scope)
14:48:35 <RichyB> Earnestly, well, not Java! There aren't any JVMs that I'm aware of which will skip a #! line for you. :)
14:48:49 <Earnestly> RichyB: Write a wrapper :p
14:49:42 <RichyB> No, because I *also* don't want to encourage people to write "scripts" in a language which takes ~50ms+ just for the VM to wake up on my machine with a hot cache. :P
14:50:11 <Earnestly> But it satisfies your predicate heh
14:50:22 <monochrom> buy a larger cache :)
14:50:29 <levi> Of course, you can do dynamic scoping in a monad in Haskell, too: http://hackage.haskell.org/package/CC-delcont-0.2
14:50:34 * hackagebot Rasterific 0.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.1 (VincentBerthoux)
14:51:21 <RichyB> monochrom, I suppose I should buy one of those new Haswell chips with a 128MB L3? ;P
14:51:42 <RichyB> I suspect that the Oracle JVM still thrashes L3 even on that. :P
14:53:08 <carter> RichyB: also you can't write good numa code for jVM :/
14:55:33 <RichyB> I wouldn't know, I have never tried.
14:56:35 <carter> i don't think you can guarantee threads pinned to cores
15:00:35 * hackagebot MemoTrie 0.6.2 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.6.2 (ConalElliott)
15:00:59 <astropirate> I know most of us here are emacs/vi users, but are there any IDE's for Haskell with proper autocompletion and stuff?
15:01:07 <bitemyapp> carter: not natively, just with JNI
15:01:21 <carter> bitemyapp: yuck :)
15:01:24 <carter> bitemyapp: i figured as such
15:01:31 <carter> its one of my arguments aginst jmv
15:01:33 <carter> *jvm
15:01:53 <carter> (at least when people talk about hpc perf)
15:01:55 <Earnestly> astropirate: (I doubt you use `vi` :p)
15:02:07 <Earnestly> astropirate: (no buffers, one level of undo, fun)
15:02:08 <astropirate> VIM VIM VIMMM
15:02:08 <RichyB> carter, well, C can't do that (from just what's in the standard) either. But current JVMs lack green threads, so you do know that JVM threads are 1:1 with OS threads, and you can JNI.
15:02:12 <Earnestly> astropirate: :D
15:02:22 <carter> wait really?
15:02:26 <bennofs> astropirate: there is leksah, eclipsefp and the fpcomplete ide (runs in browser, free only if you don't want to download your code)
15:02:28 <carter> jvm threads are heavy?
15:02:34 <RichyB> Earnestly, I use vi! On servers. :)
15:02:41 <carter> there yi too
15:02:44 <cdh473__> RichyB++
15:02:48 <carter> and i may yak shavemy own in a few months
15:03:16 <RichyB> I haven't seen yi compile in ages. I thought it was only a pure text editor, though?
15:03:21 <Earnestly> RichyB: vi is ex (or nvi)
15:03:25 <astropirate> bennofs, I have been burned by "cloud/browser" IDEs in the past, do you know which is the most mature of the native IDEs?
15:03:49 <cdh473__> leksah seemed pretty nice
15:03:58 <cdh473__> i've not used the others
15:04:04 <carter> astropirate: i use sublime text
15:04:07 <levi> RichyB: I compiled yi just the other day.
15:04:08 <carter> i don't ide
15:04:12 <cdh473__> and i switched back to emacs anyways
15:04:13 <bennofs> astropirate: using emacs myself, I don't know :)
15:04:30 <RichyB> levi, oh, good. Someone has improved it. :)
15:04:47 <levi> RichyB: It's got both emacs and vi emulation modes, and is somewhat extensible, although I didn't dig deeply into the code.
15:05:21 <astropirate> wow I wasn't expecting this level of maturity in the IDEs
15:05:32 <astropirate> definatly better than Go IDE support
15:05:45 <RichyB> I like the idea of having an editor that can be scripted as easily as Emacs can, but with a nicer programming language than elisp. I'm still nowhere near getting over the *sheer amount* of stuff that's already lying around for Emacs, though.
15:05:46 <levi> It's got an interesting incremental parser in it for handling syntax, too.
15:06:14 <RichyB> ooh, Leksah is in Fedora 19's repos.
15:07:04 <bennofs> What I miss in yi is: undo-tree and magit. I haven't yet had the time to look into how to configure yi properly to do all my emacs can do :=)
15:07:07 <levi> Textadept is an interesting editor that's extensible in lua.
15:07:45 <levi> bennofs: Yeah, that's one reason I never end up using another editor for long.
15:09:10 <jle`> are we talking about editors now
15:09:16 <jle`> have yall heard of that new hip one Atom
15:09:33 <tautologico> yeah
15:09:51 <jle`> have any of you tried it for Haskell?
15:10:01 <tautologico> someone imported from a textmate bundle and there's already a basic syntax highlighting for haskell
15:10:15 <jle`> i'd imagine it'd be a nice editor because it is technically super extensible like vim/emacs and it's native
15:10:27 <jle`> still i do most of my editing over ssh so i don't know how useful it'd be for me
15:10:47 <r444> i'm amazed with all that hype for new editors
15:10:58 <tautologico> it will probably have remote editing eventually
15:11:07 <jle`> hm
15:11:13 <r444> it just seems useless, once you've learned vi or emacs
15:11:13 <tautologico> like emacs
15:12:01 <jle`> i've been using vim but something that i can actaully extend and write plugins for myself without giving me headaches, and is not emacs, would be nic
15:12:28 <jle`> but i spent all this time making my perfect vim setup so i would probably be hard pressed to move until i found something to replace everything
15:12:50 <Rembane> jle`: neovim will be good in a couple of years, if it takes off.
15:12:54 <astropirate> jlamothe, development over SSH? :O  why do you do that?
15:13:12 <jle`> astropirate: so i have a persistent unix server and stuff
15:13:18 <jle`> that i can leave things running and stuff when my laptop is off
15:13:29 <jle`> i don't have a desktop
15:13:31 <astropirate> hmm interesting
15:13:38 <astropirate> isn't it slow?
15:13:39 <jle`> it's nice not having to worry about moving around and stuff
15:13:41 <jle`> slow?
15:13:46 <astropirate> don't you notice a "lag" when yo utype fast?
15:13:49 <jle`> nah
15:13:50 <levi> Mmm, emacs tramp mode.
15:13:59 <jle`> ssh has almost no delay
15:14:01 <levi> Local emacs, remote files.
15:14:06 <jle`> because it's so lightweight
15:14:27 <jle`> only frustrating thing is when i don't have internet or the connection is choppy...but my phone tethering is more than enough and i have things backed up on my laptop in case of a blackout
15:14:31 <astropirate> jle`, thats wiered, because everytime i am configuring stuff on my servers over SSH it feels sluggish to type in vim
15:14:38 <jle`> with dropbox and btsync and stuff
15:14:43 <jle`> bittorrent sync
15:14:48 <jle`> astropirate: really?
15:14:51 <astropirate> yes
15:15:05 <astropirate> with multiple ISPs / computers and server and server providers
15:15:06 <jle`> perhaps the server is busy or slow?
15:15:08 <astropirate> I just took at as fact
15:15:21 <astropirate> i must have configured stuff wrong then
15:15:24 <jle`> when i'm sshing with a normal connection i never noticed any lag
15:15:43 <jle`> and i've used both cloud servers and rack/physical ones
15:16:02 <xpika> does anyone know how to modify the structure of html using the blaze html library?
15:16:07 <jle`> also i like leaving my irc client on 24/7 :)
15:16:31 <jle`> so if someone mentions me i get a notification on my phone and i feel happy about myself
15:16:35 <xpika> for example removing all child elements of a node
15:16:45 <jle`> xpika: i...tried it once
15:16:53 <jle`> i think Cale helped me look into it
15:16:53 <astropirate> jle`, hehe I was really big into IRC, then I got busy :(
15:17:16 <daphnesfear> jle`: might consider sparkleshare, requires nothing fancy server-side besides ssh, and i think rsync
15:17:17 <jle`> astropirate: :) it's really handy having a persistent server for many reasons
15:17:27 <jle`> and you don't realize it until you have it
15:17:38 <daphnesfear> jle`: and uses git for tracking
15:17:39 <xpika> failing that, does anyone know of another such library which can do this sort of thing?
15:17:56 <levi> xpika: Hmm. I'm not sure blaze is your best bet for manipulating; it's designed as a very fast builder, IIRC.
15:17:56 <jle`> xpika: yeah, the conclusion we came to was that blaze wasn't really meant for people to edit the structure
15:18:11 <jle`> it goes out of the way to make it very very hard
15:18:14 <jle`> with all of its existentials
15:18:56 <levi> The xmlhtml package from the Snap Framework might be a good one to try.
15:21:57 <xpika> levi: that package is interesting in that it has a function Html(from blaze) to [Nodes]
15:22:19 <xpika> levi: would be really cool if i could use lens prisms over this stuff
15:22:53 <xpika> levi: i'll give it a go
15:22:56 <jle`> xpika: try xmlhtml or maybe tagsoup
15:23:32 <jle`> daphnesfear: git for tracking is nice :)  happy with btsync for now...although...its lack of open sourceness sometimes bothers me
15:23:50 <levi> jle`: Have you looked at unison?
15:24:21 <jle`> levi: i have not, but i am now :)
15:24:22 <daphnesfear> jle`: yeah. i you have a half hour free ever, sparkleshare i think looks like a fine dropbox replacement
15:24:57 <jle`> ty, it sounds promising
15:26:45 <levi> There's hexpat and hexpat-lens
15:28:56 <levi> xmlhtml has a custom zipper structure for navigating and editing a document, though.
15:29:24 <cgag> Haskell noob here: I'm trying to add a web server to my project.  I tried just dropping in scotty and running the sample code (http://hackage.haskell.org/package/scotty).  I think from multiple libraries using OverloadedStrings? http://lpaste.net/100469
15:30:09 <xpika> levi: that could work too
15:31:21 <levi> cgag: You may need to add explicit type annotations to some of your string literals to help the compiler out.
15:33:11 <xpika> cgag: another option is too turn off OverloadedStrings and use functions like Data.Text.pack
15:33:33 <pavonia> cgag: Also, you probably want ``["<h1>Scotty ", beam, " me up!</h1>"]''
15:33:55 <riceandbeans> is pavonia a female name?
15:34:04 <bitemyapp> riceandbeans: who cares?
15:34:22 <riceandbeans> just random
15:34:24 <bitemyapp> riceandbeans: are you attractive?
15:34:28 <riceandbeans> nope
15:34:31 <pavonia> It's not a real name
15:34:45 <riceandbeans> ok
15:34:53 <bitemyapp> riceandbeans: you probably don't want to creep on other people.
15:34:55 <riceandbeans> you could be a dude for all I care
15:35:07 <riceandbeans> was just curious if the name itself was female
15:35:10 <levi> cgag: Using OverloadedStrings turns each string literal into a 'fromString <literal>' expression. So as long as there's a type annotation somewhere that tells the compiler what sort of stringlike type that it's expecting, it will select the correct fromString implementation.
15:35:11 <bitemyapp> riceandbeans: google it.
15:35:16 <riceandbeans> I shall
15:35:48 <cgag> pavonia: you're a genius
15:35:55 <khyperia> I had an idea today, could I have some thoughts? - pattern matching is different behavior based on which data constructor is used, and typeclasses are different behavior based on which type is used. Is that correct? Are there more abstractions that generalize that?
15:36:06 <cgag> pavonia: that missing comma seems to have been the source of all my errors
15:36:22 <pavonia> hehe
15:36:52 <riceandbeans> from wikipedia
15:36:54 <riceandbeans> Pavonia is the Latinized form of Pauw's surname, which means "peacock".[
15:37:01 <riceandbeans> random
15:37:19 <cgag> levi: yeah I had tried adding some type annotations but they weren't helping, I thought I might have been going down the wrong pat, but it looks like it was just the comma
15:37:29 <riceandbeans> back to work...
15:37:38 <levi> cgag: Glad you got it worked out!
15:37:51 <artyomkazak> khyperia: and type families are different *types* based on which type is used
15:37:55 <artyomkazak> basically, it
15:38:04 <artyomkazak> ouch, accidentally pressed Enter
15:38:39 <artyomkazak> khyperia: basically, typeClass :: Type -> Dictionary, and typeFamily :: Type -> Type
15:39:15 <khyperia> Huh, alright, cool
15:39:43 <levi> khyperia: I wouldn't try to draw too many inferences by comparing pattern matching with type classes, though.
15:40:10 <khyperia> yeah, pattern matching in the sense of restricting it to... uh... "decomposing a constructor"
15:40:21 <khyperia> and not value-matching or anything like that
15:41:03 <levi> Even so, there are significant differences.
15:43:54 <riceandbeans> question
15:44:07 <riceandbeans> in haskell I can set a function equal to a function
15:44:31 <riceandbeans> so like doubleMe x = x + x
15:44:37 <riceandbeans> and I can do this too
15:44:52 <riceandbeans> doubleUs x y = doubleMe x + doubleMe y
15:45:10 <riceandbeans> ...but what happens if you set them in an endless internal loop?
15:45:29 <milfjord> you get an infinite loop
15:45:41 <milfjord> or sometimes an exception if the RTS detects it
15:45:43 <n^izzo> you are stuck in limbo
15:46:29 <levi> Top-level definitions aren't evaluated when they're defined; you would have to examine the value before it would be executed.
15:47:51 <n^izzo> wow what just happened
15:47:52 <levi> So, you can write: nums = [1..]
15:48:22 <levi> That, if you evaluate it as-is, goes on forever.
15:48:33 <levi> But just writing out the definition doesn't evaluate it.
15:48:48 <levi> You can later write: take 10 nums
15:50:25 <pavonia> > let nums = 1 : nums in take 10 nums
15:51:41 <levi> Aww, we lost lambdabot.
15:52:09 <Kron> D:
15:52:18 <Kron> what happened to it? I was expecting a readout too
15:52:32 <Kron> anyway, that should've produced [1,1,1,1,1,1,1,1,1,1]
15:53:02 <joneshf-laptop> so the other day when i was talking about using arbitrary monads within other monads
15:53:15 <joneshf-laptop> i wanted something like this: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html at the bottom, in the "flaws" section
15:53:18 <levi> Maybe a netsplit? I have all the join/part messages turned off.
15:53:26 <hpc> it was not quite a netsplit
15:53:26 <joneshf-laptop> where you tell the donotation which monad to use
15:53:33 <hpc> everyone timed out
15:53:48 <joneshf-laptop> why isn't that a thing?
15:54:51 <Kron> I think you can mark a type anywhere within the do block, or even around the do block
15:54:57 <Kron> and it'll hindley-milner to figure it out?
15:59:58 <prinsen> Is there any way to supress Defined but not used errors in GHC? gettig thousands while working with TH
16:01:03 <monochrom> yes but I forgot its name. look into GHC user's guide chapter 4
16:04:17 <int-e> @bot
16:04:24 <lambdabot> :)
16:05:18 <prinsen> monochrom: only thing I can find is -fno-warn-unused-binds and it doesn't work
16:05:35 <jcarpenter2> Anyone recognize the function const :: (b -> b) -> a -> b -> b ?
16:05:52 <levi> joneshf-laptop: I'm not sure that does what you were trying to do.
16:06:17 <jcarpenter2> I would have expected const :: () -> a
16:06:24 <FreeFull> const :: a -> b -> a
16:06:33 <ski> @djinn () -> a
16:06:38 <lambdabot> -- f cannot be realized.
16:06:45 <ski> @djinn a -> ()
16:06:49 <FreeFull> :: (b -> b) -> a -> b -> b   is a valid instantiation of  :: a -> b -> a
16:06:53 <lambdabot> f _ = ()
16:07:40 <jcarpenter2> I see, so the above is a constant function whose constant must be a function of type b -> b
16:07:49 <merijn> jcarpenter2: Correct
16:08:01 <merijn> :t const
16:08:08 <lambdabot> a -> b -> a
16:08:15 <merijn> :t const :: (b -> b) -> a -> b -> b
16:08:24 <lambdabot> (b -> b) -> a -> b -> b
16:08:28 <joneshf-laptop> jcarpenter2, the last parens are dropped off, easier to see as: (b -> b) -> a -> (b -> b)
16:08:40 <jcarpenter2> I understand currying :)
16:09:58 <joneshf-laptop> levi, that would do exactly what i wanted in the specific case. I probably didn't explain it well enough.
16:10:49 <levi> Yeah, I must have misunderstood what you were trying to do then.
16:11:08 <joneshf-laptop> levi, I wanted to chain some Either calls together, either getting the Right at the end, or thefirst Left along the way. and do that while inside a transformer stack. If I could've said `do :: Either a b {...}` it would'v been perfect
16:11:09 <joneshf-laptop> ;)
16:11:40 <joneshf-laptop> but maybe it just needed to be moved out of that doblock
16:11:45 <joneshf-laptop> into its own function
16:11:48 <joneshf-laptop> and lifted
16:11:59 <levi> But you can do that, if you just need to work on pure Either values.
16:12:30 <joneshf-laptop> oh right
16:12:38 <joneshf-laptop> it was `IO (Either a b)`
16:13:30 <levi> Yeah. If you're inside an IO do block, and you have functions that return Either values, you can do a nested Either do block.
16:14:54 <pavonia> joneshf-laptop: Maybe you want to use the EitherT transformer? EitherT a IO b ≈ IO (Either a b)
16:17:01 <levi> If you actually *like* explicit dictionary passing, OCaml may be the language for you. ;)
16:18:02 <joneshf-laptop> haah, nah, i'm over it already. it's just not something that's easily done in do notation
16:19:08 <pavonia> There's also a monad instance for Either
16:19:26 <rs0_> levi: are you referring to first class modules?
16:19:27 <joneshf-laptop> pavonia, i didn't want to add another dependency but ErrorT sufficed
16:19:49 <levi> pavonia: Yeah, but he was wanting to use the monad instance for Either when he had functions returning IO (Either a b).
16:20:22 <pavonia> Ah, that's the use case for EitherT/ErrorT then, I guess
16:22:28 <levi> rs0_: The Core library in OCaml makes heavy use of abstractions like Monad, but you have to explicitly say what types are involved via the module system rather than having the compiler infer them.
16:22:52 <joneshf-laptop> i dunno though, an explicit dict passing would be less cruft than shoving an `ErrorT` on every call and `runErrorT` on the outside of the loop
16:22:58 <joneshf-laptop> can't we get the best of both worlds
16:23:15 <joneshf-laptop> a do syntax that takes a dict when you wantt o do that
16:23:23 <joneshf-laptop> s/a/another/
16:24:19 <levi> If you look at the examples, he's still got all the 'runX' stuff along with the explicit dictionaries.
16:24:59 <levi> You can always make a little helper function to clean things up.
16:25:52 <joneshf-laptop> yeah that's the best way i think
16:26:01 <foobazbar> Hi guys, was just wondering if there is a set notation and a map notation within haskell?
16:26:08 <foobazbar> comprehension*
16:26:58 <levi> There's list comprehension notation, which is similar to set notation.
16:27:05 <dwcook> foobazbar, nope, the closest you really get is, e.g., fromList ['a', 'b', 'c']
16:27:14 <dwcook> (For a Set Char)
16:27:16 <foobazbar> Ah
16:27:38 <foobazbar> That's a shame - I was hoping to learn how map comprehension worked by playing about with haskell :P
16:27:39 <riceandbeans> so I tried to install xmonad on debian
16:27:42 <riceandbeans> it installed
16:27:45 <hpc> > Set.fromList [x % 11 | x <- [2, 4, 6, 8, 10]]
16:27:46 <riceandbeans> or said it did
16:27:47 <lambdabot>  Not in scope: `Set.fromList'
16:27:47 <lambdabot>  Perhaps you meant one of these:
16:27:47 <lambdabot>    `Seq.fromList' (imported from Data.Sequence),
16:27:47 <lambdabot>    `S.fromList' (imported from Data.Set),
16:27:47 <lambdabot>    `IM.fromList' (imported from Data.IntMap)
16:27:53 <hpc> > S.fromList [x % 11 | x <- [2, 4, 6, 8, 10]]
16:27:55 <lambdabot>  fromList [2 % 11,4 % 11,6 % 11,8 % 11,10 % 11]
16:28:04 <riceandbeans> lightdm tried to load it but nothing came up
16:28:05 <dwcook> foobazbar, well as levi suggested, there are list comprehensions. Those can be used to create maps and sets using the appropriate fromList
16:28:58 <dwcook> @type Map.fromList
16:28:59 <lambdabot> Couldn't find qualified module.
16:29:03 <dwcook> @type Data.Map.fromList
16:29:04 <lambdabot> Ord k => [(k, a)] -> M.Map k a
16:29:04 <levi> List comprehensions are more general; you can always turn the list into a set or map or whatever sort of Monoid you'd like.
16:29:27 <foobazbar> I'm learning about map comprehensions ATM, but I wanted to play around with them on a 'real language'
16:29:28 <joneshf-laptop> hmm
16:29:32 <foobazbar> :P
16:29:37 <joneshf-laptop> could you do somthing with a quasiquoter?
16:29:43 <dwcook> > Data.Map.fromList [(c, Data.Char.ord c) | c <- ['a'..'z']]
16:29:44 <lambdabot>  Not in scope: `Data.Map.fromList'
16:29:47 <dwcook> :(
16:29:49 <joneshf-laptop> [set| 1,2,3,4|]
16:29:49 <levi> foobazbar: What language are you doing "map comprehensions" in?
16:29:51 <joneshf-laptop> or something
16:30:10 <foobazbar> levi VDM
16:31:28 <mm_freak_> > M.fromList [(1, 'a'), (2, 'b')]
16:31:31 <lambdabot>  fromList [(1,'a'),(2,'b')]
16:31:46 <levi> It looks like mapping comprehensions are implementable via Haskell list comprehension syntax.
16:32:13 <mm_freak_> what's wrong with using regular list comprehensions?
16:33:05 <levi> mm_freak_: Nothing. I just don't think foobazbar knows how the VDM things map to Haskell things due to not knowing Haskell very well yet.
16:34:10 <foobazbar> levi Additionally not knowing VDM very well yet ;)
16:34:11 <mm_freak_> levi: ok, it sounded like you were suggesting implementing a language extension =)
16:34:37 <kadoban> so, i dunno if this is going to be an annoying question, but: i'm doing these programming exercises, and one of them has this test harness: https://github.com/exercism/exercism.io/blob/master/assignments/haskell/robot-name/robot-name_test.hs
16:34:39 <levi> Oh, no. I was suggesting that you could directly use list comprehensions.
16:34:56 <kadoban> can i change the test harness so i can write my code in the State monad instead of the IO monad? i'm on pretty shakey ground
16:35:00 <foobazbar> Having some experience of haskell has made things in VDM easier like the types, functions and list comprehensions
16:35:04 <kadoban> i have to implement the Robot module, if it wasn't clear
16:35:12 <foobazbar> But now i'm trying to learn vdm via haskell :)
16:35:38 <mm_freak_> never heard of VDM before
16:35:39 <cgag> vdm?
16:35:52 <levi> It's a specification language, apparently.
16:36:03 <levi> http://en.wikipedia.org/wiki/Vienna_Development_Method
16:36:30 <foobazbar> that link doesn't do it justice with the notation used
16:37:13 <kadoban> actually, shouldn't i be able to change that harness somehow so i can use whatever monad my heart desires? or is that not really possible?
16:39:09 <nolrai66> So is there really no common operator such that "f `op` (a,b) = (f a, f b)" ?
16:39:43 <levi> Well, all Haskell programs run in the IO monad. But you can evaluate pure functions and use other monads within the IO monad actions.
16:40:39 <levi> nolrai66: I think that's an Arrow operator.
16:40:58 <geekosaur> :t (***)
16:41:10 <geekosaur> rip freenide
16:41:42 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:42:03 <levi> kadoban: The manual for the test harness is here: http://hunit.sourceforge.net/HUnit-1.0/Guide.html
16:42:05 <kristof> Oh, Data.Set is a size balanced binary tree... cool stuff :)
16:43:47 * mgsloan likes that type better as Arrow (~>) => (a ~> b) -> (a' ~> b') -> ((a, a') ~> (b, b'))
16:45:29 <nolrai66> :ty (&&)
16:45:44 <nolrai66> @ty (&&)
16:45:47 <levi> kadoban: HUnit asserions are all IO actions, though, so it looks like you're stuck in IO by the way the tests are written.
16:47:15 <mmmm> What's the proper way to use cabal? it just seems like whatever I do I end up in cabal hell
16:47:34 <levi> mmmm: What are you trying to do?
16:48:24 <mmmm> so cabal install pandoc for example has a screenful of warnings saying that if I install it I will break all these libraries, I take it that's not a good sign
16:49:28 <dwcook> Is Freenode still under attack?
16:49:51 <levi> Well, in that case you can do 'cabal unpack pandoc', cd to the directory it unpacks to, 'cabal sandbox init', then 'cabal install'
16:50:00 <kadoban> levi: ah okay, thanks for looking
16:50:46 <levi> kadoban: I haven't looked at exercism very deeply... are there any instructions that go along with the exercises aside from the test suite?
17:04:24 <levi> foobazbar: You should find basic haskell pretty familiar after learning VDM.
17:06:11 <microatxslim_> hi
17:07:22 <levi> microatxslim_: Hi.
17:07:44 <microatxslim_> levi how haskell is better than c++?
17:08:18 <microatxslim_> levi isnt c++ best language?
17:08:42 <copumpkin> microatxslim_: we don't answer questions like that
17:08:45 <levi> Haskell is better than C++ for writing haskell programs.
17:08:49 <mgsloan> microatxslim_: http://bartoszmilewski.com/2013/09/19/edward-chands/
17:08:50 <levi> C++ is better for writing C++ programs.
17:08:55 <Iceland_jack> levi: Well... ;)
17:09:04 <hpc> i write all my C++ in CPP
17:09:17 <microatxslim_> copumpkin, why
17:09:27 <levi> Well, some might prefer to write haskell programs to write their C++ for them.
17:09:30 <copumpkin> microatxslim_: because it's a useless question. how is french better than italian?
17:09:42 <copumpkin> microatxslim_: do you want to learn haskell? there are many resources for doing it. Then you can decide for yourself. Our job isn't to sell it to you
17:10:07 <regexkind> quick question: is there a preexisting
17:10:07 <microatxslim_> copumpkin, its bad comparison. some programming languages are better at some uses and worse at other uses
17:10:21 <copumpkin> microatxslim_: yeah, but it's also massive flamebait that's not worth going into
17:11:07 <regexkind> Preludesque function for grouping lists into pairs? like [1,2,3,4,5,6] -> [(1,2),(3,4),(5,6)]
17:11:45 <kadoban> regexkind: zipWith xs (drop 1 xs) ?
17:11:55 <johnw> that won't quite do it
17:11:59 <microatxslim_> copumpkin i have to know at what uses haskell is good if i to use this language
17:12:01 <johnw> you need the odds from one, and the evens from the other
17:12:10 <regexkind> johnw: yep
17:12:10 <kadoban> oh yeah
17:12:21 <njcomsec> i heard haskell is good for financial and analysis stuff
17:12:22 <copumpkin> microatxslim_: I use it for everything I can use it for. It's good for most things.
17:12:25 <njcomsec> like calculations
17:12:38 <copumpkin> microatxslim_: I like writing imperative code in it more than I like doing so in C
17:12:41 <microatxslim_> copumpkin, but so is c++. what then to use: c++ or haskell
17:12:42 <levi> haskell is good for computing and calculating in general.
17:13:05 <microatxslim_> levi same could be said about any language especially c/C++
17:13:07 <copumpkin> microatxslim_: whichever you feel more comfortable in.
17:13:12 <copumpkin> exactly
17:13:23 <microatxslim_> copumpkin, which is more comfortable for most people?
17:13:33 <microatxslim_> what are differences between c++ and haskell
17:13:33 <copumpkin> C++
17:13:43 <copumpkin> microatxslim_: seriously, this is all trivially searchable on google.
17:13:49 <microatxslim_> copumpkin, why c++ is more comfortably
17:14:05 <kadoban> microatxslim_: what are the differences? pretty much everything
17:14:14 <copumpkin> read up on it and ask us specific questions you're confused about
17:14:32 <joneshf-laptop> > zip . uncurry $ partition even [1..6]
17:14:33 <lambdabot>  Couldn't match type `(a1, b0) -> c0' with `[a0]'
17:14:33 <lambdabot>  Expected type: (a1 -> b0 -> c0) -> [a0]
17:14:33 <lambdabot>    Actual type: (a1 -> b0 -> c0) -> (a1, b0) -> c0Couldn't match expected typ...
17:14:33 <lambdabot>              with actual type `([a2], [a2])'
17:14:53 <joneshf-laptop> beh
17:15:03 <joneshf-laptop> > uncurry zip $ partition even [1..6]
17:15:04 <lambdabot>  [(2,1),(4,3),(6,5)]
17:15:09 <joneshf-laptop> > uncurry zip $ partition odd [1..6]
17:15:10 <lambdabot>  [(1,2),(3,4),(5,6)]
17:15:40 <levi> It's much harder to write programs in that style in C++.
17:15:53 <regexkind> joneshf-laptop: thanks :D
17:15:53 <joneshf-laptop> regexkind, ^ does that work?
17:16:17 <microatxslim_> copumpkin, can you write programs in haskell that use directx? winapi?
17:16:25 <regexkind> > uncurry zip $ partition odd [6..1]
17:16:41 <johnw> well, I thought he wanted it based on odd/even indices
17:16:44 <johnw> not odd/even values
17:16:48 <FireFly> @faq can you write programs in haskell that use directx? winapi?
17:16:55 <regexkind> oh. then yes. that is the rub
17:17:00 * FireFly pokes lambdabot
17:17:04 <microatxslim_> how do i find which language is best for me? (not just about haskell and c++)
17:17:04 <kadoban> microatxslim_: learn some, try them out, see what you like
17:17:05 <lambdabot> The answer is: Yes! Haskell can do that.
17:17:06 <lambdabot>  []
17:17:21 <joneshf-laptop> regexkind, of course, now the idea is to make it work on ... okay i thought so
17:17:36 <microatxslim_> kadoban, already did, but cant learn every of them
17:17:36 <microatxslim_> kadoban, for now, best for me is a mix between c and c++
17:17:57 <FireFly> microatxslim_: you shouldn't learn *one* language. You should learn muliple languages of widely different paradigms, because it broadens your knowledge and teaches you new ways to attack problems
17:18:27 <FireFly> "which tool in the toolbox should I learn to use? Should I specialise in hammers?"
17:18:28 <microatxslim_> firefly i did learn few ones
17:18:38 <copumpkin> microatxslim_: you learn multiple languages and see what suits your thinking the best. Other people can't tell you. You can use directx and winapi if you put some work into it, but I don't know of libraries that already exist for it
17:19:25 <joneshf-laptop> *few*
17:19:28 <treehouse> 123
17:19:30 <levi> microatxslim_: If you are trying to find the best language for you, you should probably choose one to learn from various families of languages, and then search more in the families that work the best for what you want to do.
17:19:33 <microatxslim_> copumpkin so its seems you have to use c++ if you want comfortably make directx/winapi
17:19:35 <treehouse> joneshf-laptop: no
17:19:52 <joneshf-laptop> treehouse, ?
17:20:10 <johnw> > let xs = [1,2,3,4,5,6] in uncurry (zipWith (\(_,x) (_,y) -> (x,y))) $ Data.List.partition (even . fst) (zip [1..] xs)
17:20:15 <prinsen> Is there any way to print a type during runtime?
17:20:24 <lambdabot>  [(2,1),(4,3),(6,5)]
17:20:27 <johnw> > let xs = [5,7,9,11,5,6] in uncurry (zipWith (\(_,x) (_,y) -> (x,y))) $ Data.List.partition (even . fst) (zip [1..] xs)
17:20:28 <lambdabot>  [(7,5),(11,9),(6,5)]
17:20:31 <treehouse> joneshf-laptop: you can't, hence no
17:20:49 <johnw> regexkind: ^^
17:20:54 <hpc> prinsen: not arbitrary types, unfortunately, but there's a type class for it
17:20:57 <hpc> Typeable, iirc
17:21:00 <regexkind> johnw: thanks :D
17:21:10 <joneshf-laptop> treehouse, i'm  not sure what we're talking about
17:21:20 <johnw> use 'odd' instead to flip the order
17:21:26 <treehouse> joneshf-laptop: don't be silly, you can stop trolling now :)
17:21:28 <hpc> prinsen: ghc erases type information during compilation (java people give it the name "type erasure" because it causes major semantic issues over there)
17:22:17 <microatxslim_> what language is most similar to haskell and why: c, c++, c#, assembly, java, php, javascript, visualbasic
17:22:21 <prinsen> hpc: Im using alot of TH, but im deriving Typable instances for all types
17:22:25 <FireFly> >.>
17:23:24 <treehouse> joneshf-laptop: lol, stop :P
17:23:59 <copumpkin> microatxslim_: you don't have to, but it might be easier because people have already done the work for you. Not many haskellers use those so you'll be on your own for some of it
17:23:59 <copumpkin> prinsen: ask for a Typeable instance
17:24:03 <joneshf-laptop> johnw, surely there's a way to combine those zips
17:24:51 <copumpkin> microatxslim_: none of those.
17:25:06 <prinsen> copumpkin: Sure, But i need some pretty printing, with field names for record types etc.
17:25:27 <copumpkin> prinsen: hmm, can't do that without horrific hackery. Why do you want to?
17:25:36 <microatxslim_> i said "most"
17:25:37 <microatxslim_> there are no jobs to write haskell code
17:25:47 <copumpkin> microatxslim_: they're literally all the same distance from Haskell
17:25:52 <copumpkin> microatxslim_: you're sounding more and more like a troll
17:26:02 <copumpkin> microatxslim_: please just read up on haskell and demonstrate that you've done some research
17:26:05 <prinsen> copumpkin: Im asking users to write code transforming TOut -> TIn
17:26:09 <levi> If you ask Erik Meijer, Visual Basic is the closest to Haskell. ;)
17:26:33 <copumpkin> microatxslim_: which is most similar to italian? chinese, japanese, or thai?
17:26:35 <microatxslim_> copumpkin if i learned haskell i could use only for personal projects, as there no jobs for haskell
17:26:38 <prinsen> copumpkin: where TOut and Tin are TH-generated types, kind of hard for the user if they doesn't see the types
17:27:01 <copumpkin> microatxslim_: no, there are a few jobs for Haskell. But you're right, it's not used at most companies. Many companies that don't use it look for it, though.
17:27:33 <microatxslim_> copumpkin, i need something that will made me rich, haskell dosent seem to be able to
17:27:39 <mgsloan> For an entertaining 7-years ago comparison of the strategies of C# and Haskell: http://channel9.msdn.com/Blogs/Charles/Simon-Peyton-Jones-Towards-a-Programming-Language-Nirvana
17:27:39 <copumpkin> okay, then go find something that does
17:27:47 <microatxslim_> copumpkin, like what
17:27:53 <copumpkin> that's not our job to find
17:28:12 <prinsen> microatxslim_: you are not a CS student right?
17:28:18 <microatxslim_> prinsen, no
17:28:23 <microatxslim_> im not
17:28:31 <copumpkin> microatxslim_: try #cobol
17:29:01 <microatxslim_> copumpkin, cobol is old as hell, only old software is maintained in it
17:29:03 <prinsen> copumpkin: Guess I have to generate that data in TH
17:29:19 <copumpkin> microatxslim_: anyway, I'm done with this conversation. You aren't interested in haskell, so please desist from asking about other languages in here
17:29:37 <copumpkin> prinsen: ah yeah, TH makes things ugly :/
17:29:45 <prinsen> copumpkin: yes :(
17:29:56 <copumpkin> who generated them in TH?
17:30:03 <prinsen> copumpkin: me :)
17:30:14 <copumpkin> and that's a necessity? just making sure you aren't overcomplicating this
17:30:16 <prinsen> copumpkin: i generate types from xml-files
17:30:30 <levi> microatxslim_: We are more than happy to answer questions about writing programs in haskell, but not really interested in debating whether someone should use it or not.
17:30:33 <copumpkin> prinsen: ah, okay
17:31:01 <microatxslim_> i go somewhere else then
17:31:02 <hpc> we're also not exactly the most unbiased people to answer that particular question ;)
17:31:40 <levi> microatxslim_: If you decide to learn haskell, you're more than welcome to come back and ask questions then.
17:31:46 <hpc> that's okay, freenode
17:31:51 <hpc> i wasn't using my scrollback
17:32:07 <joneshf-laptop> heh
17:38:37 <regexkind> I am beginning to suspect the way I'm going about what I'm doing is un-haskell-ish
17:39:22 <carter> regexkind: no  such thing
17:39:26 <regexkind> I want to take a list of [Word8] and process them into a list half as long of [Word16], divide the elements in this list by 2, and then split back into [Word8]
17:39:59 <carter> regexkind: so you wanna encode simd operations as streaming list operations
17:40:10 <regexkind> simd?
17:40:16 <carter> "cpu vector math"
17:40:17 <carter> :)
17:40:23 <carter> regexkind: ooo, have you read hackers delight? :)
17:40:38 <levi> Single Instruction Multiple Data is what it stands for.
17:40:43 <regexkind> I've yet to do so
17:40:55 <levi> And yeah, there are lots of bithacks for that kind of thing.
17:41:31 <carter> regexkind: i'm actually hoping to be abel to budget some time this summer to improve how well ghc optimizes bit hacks :)
17:41:53 <carter> regexkind: sooo
17:42:00 <kadoban> okay, so here's a question: i'm forced into the IO monad for this one exercise...how do i have persistent state in this?
17:42:01 <carter> lets write otu the stupid version
17:42:18 <carter> kadoban: you use let :)
17:42:28 <carter> regexkind: so niavely
17:42:45 <carter> you wanna peal off pairs of word8, zero extend them to word16
17:42:57 <kadoban> ugh, this is so annoying, i don't even understand how to do this, haha...wish i could just skip this dumb problem
17:42:58 <carter> shift one up 8 spaces, add em together, then shift em down one,
17:43:12 <carter> kadoban: sometimes its good to just take a break and go for a walk
17:43:14 <carter> i should do it more :)
17:43:51 <numberten> window 17
17:44:07 <levi> kadoban: An IORef is one way. The example for that problem shows another one.
17:44:10 <ReinH> carter: o/
17:44:17 <carter> zomg ReinH
17:44:22 <carter> ReinH: have you seen rasterific yet?
17:44:25 <carter> it landed on hackage today
17:44:28 <carter> i'm excited
17:44:33 <carter> @hackage rasterific
17:44:34 <lambdabot> http://hackage.haskell.org/package/rasterific
17:44:34 <kadoban> levi: sorry, the example for which?
17:44:42 <carter> @hackage rasteriffic
17:44:42 <lambdabot> http://hackage.haskell.org/package/rasteriffic
17:44:44 <levi> The robots name thing.
17:45:00 <carter> @hackage Rasterific
17:45:00 <lambdabot> http://hackage.haskell.org/package/Rasterific
17:45:05 <carter> (i can't spell )
17:45:21 <regexkind> carter: thanks, I'll dink around with that, since I'm going to end up doing this a lot I should probably write something of the form [Word8] -> (Word16->Word16) -> [Word8], but this should work, thanks
17:45:46 <carter> ReinH: ooo
17:45:52 <carter> regexkind: whats you use case>?
17:45:54 <kadoban> i'm probably missing something really obvious, maybe i should take a break, sigh. be better if i really thought this problem was useful in any way, i kind of just want to skip it
17:46:04 <carter> kadoban: its a godo exercise
17:46:11 <carter> kadoban: take a break
17:46:25 <carter> head banging just leads to sore necks and head injuries
17:46:34 <kadoban> hehe, yeah :) thanks
17:46:51 <regexkind> carter: writing a quick .wav library as a learning exercise
17:47:11 <regexkind> carter: already done the IO stuff, and now just have to write some transforms on the data
17:47:16 <carter> neat
17:47:24 <carter> regexkind: have you seen juicy-pixels?
17:47:28 <c_wraith> kadoban: you can pass state around in recursive IO, the exact same way you can in recursive non-IO functions.  It's probably simpler than whatever you're thinking.
17:47:32 <carter> it kinda does some related stuff for jpeg
17:47:32 <regexkind> carter: nope
17:47:36 <levi> regexkind: Is there any particular reason you're working with lists of Word8?
17:47:44 <carter> probably for learning?
17:47:55 <carter> for a "real" version, i'd hope its with vectors
17:48:22 <regexkind> levi: I could keep the stuff in ByteString format, but I'm coming in from a scheme background so my tendency to use lists as a crutch is quite high,
17:48:46 <levi> regexkind: If you look at the API for ByteString, you will find it very familiar.
17:49:09 <carter> regexkind: no
17:49:11 <carter> Vector Storable
17:49:16 <carter> please
17:49:17 <carter> use that
17:49:22 <carter> or Unbox
17:49:23 <carter> depending
17:49:31 <carter> look at how juicy-pixels does it
17:49:37 <regexkind> carter: ok, will do
17:49:43 <carter> its not the same domain
17:49:45 <carter> but its a related one
17:50:39 <levi> Well, in any case, [Word8] is low on the list of practical choices for this problem.
17:50:51 <dwcook> I think unless you're using concurrency you don't need mutable containers at all. Correct me if I'm wrong
17:51:06 <dwcook> re: the IOREf thing
17:51:15 <carter> dwcook: depends
17:51:30 <ReinH> carter: guess what audio I'm exporting right now
17:51:33 <ReinH> carter: what is rasterific?
17:51:40 <c_wraith> kadoban: here's a really simple example of passing state around in IO - http://lpaste.net/100471
17:52:14 <carter> ReinH: is a "vector graphics -> Raster array" lib the juicy-pixels dude released to hackage today
17:52:31 <carter> means you'll now be able to render vectory things to png / jpg with no foreign deps
17:52:59 <ReinH> carter: sounds shiny!
17:53:03 <carter> YE
17:53:04 <carter> S
17:53:07 <ReinH> YA
17:53:08 <ReinH> Y
17:53:12 <carter> WER
17:53:12 <carter> D
17:53:18 <ReinH> ok that's enough of that
17:53:21 <carter> ReinH: whos the newest haskell cast victem?
17:53:35 <kadoban> c_wraith: hmm, thanks. that seems to make great sense by itself. i'll try again after a break...think i am probably making it more complicated than it should be in my mind
17:53:36 <ReinH> carter: *ahem* victems
17:53:42 <dwcook> carter, example?
17:53:45 <carter> dwcook:?
17:53:48 <carter> of what
17:53:56 <dwcook> carter, you said "depends" and didn't elaborate further as far as I can tell
17:54:03 <c_wraith> kadoban: it's easy to get caught up that way when you're starting out.  A break's a good idea.
17:54:17 <Aetherspawn> nominolo: was reading a cool article on optimizing interpreters when I realized it was your blog \o/ great post
17:54:40 <carter> dwcook: ReinH  c_wraith  http://hackage.haskell.org/package/Rasterific-0.1/docs/Graphics-Rasterific.html is cool
17:54:51 <mrmonday> Is there a way to map over the rows of Data.Matrix? Can't seem to manage it.
17:55:18 <dwcook> carter, sorry, I should have clarified: When would you need a mutable container while not doing concurrency?
17:55:27 <dwcook> (I wasn't referring to whatever that link was about)
17:55:27 <carter> dwcook: FFI calls
17:55:34 <c_wraith> carter: that does look pretty cool, but why was that directed at me? :)
17:55:34 <dwcook> Ah, okay.
17:55:47 <ReinH> mrmonday: if you need to map over the rows then you probably don't want Data.Matrix?
17:55:48 <carter> dwcook: though, probably not for IO Ref things
17:55:57 <carter> mrmonday: ReinH  whats this
17:55:59 <carter> umm
17:56:06 <carter> ReinH: dpeends on thematrix type
17:56:07 <ReinH> mrmonday: Data.Matrix stores the matrix as a flat vector
17:56:10 <c_wraith> dwcook: also, rarely, for efficiency.  Though that's mostly with arrays, rather than single mutable cells.
17:56:17 <carter> wheres data.matrix?
17:56:20 <carter> whose lib?
17:56:26 <ReinH> @hackage matrix
17:56:26 <lambdabot> http://hackage.haskell.org/package/matrix
17:56:28 <ReinH> I'm assuming
17:56:41 <mrmonday> that's the one
17:56:55 <carter> oh no thats terirble
17:56:58 <ReinH> heh
17:57:04 <carter> data Matrix a = M {
17:57:04 <carter>    nrows :: {-# UNPACK #-} !Int -- ^ Number of rows.
17:57:04 <carter>  , ncols :: {-# UNPACK #-} !Int -- ^ Number of columns.
17:57:04 <carter>  , mvect :: (V.Vector a) -- ^ Content of the matrix as a plain vector.
17:57:04 <carter>    } deriving Eq
17:57:06 <carter> you can't do slices
17:57:11 <ReinH> indeed
17:57:12 <carter> noon noonononononononononon
17:57:14 <carter> NOO
17:57:15 <carter> nonononono
17:57:16 <carter> nonono
17:57:18 <carter> i'll stop
17:57:20 <ReinH> so no?
17:57:22 <carter> yes
17:57:27 <carter> mrmonday: whats your use case
17:57:27 <ReinH> heh
17:57:32 <mrmonday> it's frustrating, since I could do what I want if I could access mvect:3
17:57:38 <ReinH> if you need to map over rows you probably don't have a matrix
17:57:39 <carter> mrmonday: i have a wip one
17:57:43 <carter> ReinH: noenoneonenoen
17:57:50 <ReinH> carter: ?
17:57:54 <carter> ReinH: row oriented matrix folds are valid pattern
17:58:00 <ReinH> carter: ok
17:58:01 <carter> theres just shittty tooling in the current libs
17:58:10 <carter> mrmonday: i've a wip lib that has slices
17:58:15 <carter> but isn't quite ready for use
17:58:21 <carter> but you could mebe use
17:58:32 <carter> mrmonday: whats your use case/
17:59:12 <mrmonday> carter: 2d array of data -> transpose -> map over rows
17:59:15 <carter> also #numerical-haskell is a thing
17:59:18 <carter> ok
17:59:25 <carter> umm
17:59:29 <carter> why transpose
17:59:33 <ReinH> Data.Array?
17:59:34 <carter> why not map over columns
17:59:38 <mrmonday> that's it, at that point I've got a nice data structure and can pretend I never went near a matrix
17:59:56 <carter> just use Data.Map :)
17:59:59 <carter> if you dont care
18:00:08 <ReinH> heh
18:00:16 <carter> idk
18:00:24 <ReinH> IntMap with encoded indices :p
18:00:28 <carter> nah
18:00:34 <carter> thats harder to do the by hand transpose with
18:02:29 <ReinH> carter: these things are worth doing; not because they are easy, but because they are hard. Or something.
18:02:37 <mrmonday> carter: I've gotta make several passes over the data, and mapping over columns is really slow (unless it's not in haskell for some reason I don't know)
18:02:51 <ReinH> mrmonday: are you sure you have to make multiple passes?
18:02:54 <carter> mrmonday: you mean row vs column ord matrices
18:03:00 <carter> mem locality is a thing
18:03:14 <carter> and honestly most of the dim > 1 array libs in haskell land are meh
18:04:16 <mrmonday> ReinH: technically, no, but I don't wanna have to rewrite a load of code I already have just yet P
18:04:21 <mrmonday> s/P/:P/
18:06:19 <carter> whats the goal / use case?
18:06:29 <ReinH> use vector and have it magically fuse everything!
18:06:50 <ReinH> carter: should I stop making bad suggestions now?
18:06:57 <carter> mebe
18:07:09 <carter> if the work load is simple enough, repa might actually be kinda nice
18:07:16 <carter> mrmonday: have you played with repa?
18:07:21 <carter> just use the basic stuff,
18:07:25 <carter> but it might be nice
18:11:30 <mrmonday> I cheated and just mapped over 0..num rows then used it's silly accessor to get the row :<
18:11:34 <mrmonday> ugly, but it works
18:12:06 <copumpkin> > partition odd [1..]
18:12:07 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:12:19 <copumpkin> @src partition
18:12:19 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:12:19 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:12:19 <lambdabot>                               | otherwise = (ts, x:fs)
18:12:28 <copumpkin> cute
18:12:56 <copumpkin> not sure why the p gets passed in there :)
18:13:28 <johnw> maybe it's a code artifact
18:15:33 <copumpkin> looks like it's still there: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#partition
18:16:00 <ion> Well, that one doesn’t have the select in a “where”.
18:16:13 <ion> Nothing else seems to be using select, though.
18:21:06 <OneEyedWill> Can some one give me the run down on how to get the type of a variable "v". ie. if v == Int
18:21:19 <joneshf-laptop> carter, why can't you get a slice?
18:21:28 <ion> oneeyedwill: For what purpose?
18:22:32 <OneEyedWill> ion: I want to check the type of a variable so that I can handle to cases
18:22:51 <joneshf-laptop> OneEyedWill, Either?
18:22:59 <ion> oneeyedwill: ↑
18:23:18 <joneshf-laptop> carter, surely you can do some math and construct a new matrix if you want to slice the old one up
18:23:25 <microatxslim_> hey, this guy says haskell is shit http://bartoszmilewski.com/2013/09/19/edward-chands/#comment-3995
18:23:28 <microatxslim_> is he right?
18:23:43 <joneshf-laptop> microatxslim_, yes
18:23:46 <microatxslim_> >Haskell promote a coding style where your data is sparse (terrible data locality), and even basic data types are boxed
18:23:47 <joneshf-laptop> s/math/computation
18:23:52 <microatxslim_> >Use a vector? Not idiomatic Haskell! You have to use some tree!!
18:23:55 --- mode: ChanServ set +o copumpkin
18:24:00 <microatxslim_> copumpkin, ?
18:24:00 <joneshf-laptop> heh
18:24:35 <c_wraith> here's the thing.  For 95% of your code, performance is irrelevant, and haskell gives you tools to make the remaining 5% fast.
18:24:52 <copumpkin> microatxslim_: you've already said you aren't interested in it. At this point it looks like you're trying to provoke a reaction in us.
18:24:58 <c_wraith> Unlike many languages, which are slower by default and don't give you tools to improve code.
18:25:02 <microatxslim_> > For 95% of your code, performance is irrelevant,
18:25:03 <lambdabot>  <hint>:1:9: parse error on input `of'
18:25:04 <microatxslim_> disagree
18:25:09 <c_wraith> then you're wrong.
18:25:27 <microatxslim_> but maybe its because im also game developer..
18:25:52 <microatxslim_> c_wraith, is C or C++ slow by default?
18:25:52 <johnw> ah, true
18:26:01 <copumpkin> microatxslim_: please stop.
18:26:06 <microatxslim_> copumpkin, i just read about c++ and accidentialy saw that comment
18:26:14 <microatxslim_> copumpkin, article is about c++
18:26:18 <copumpkin> please stop.
18:26:20 <c_wraith> microatxslim_: no, but for some reason people write applications that makes billions of dollars in languages like ruby and python
18:26:26 <dwcook> microatxslim_, you are about to get kicked
18:26:40 <copumpkin> microatxslim_: if you have questions about Haskell, ask them
18:26:43 <microatxslim_> i didnt want to hurt your religious beliefs
18:26:58 <copumpkin> it's not religion, but you're joining a channel of haskell enthusiasts asking "is haskell shit? this guy says it is"
18:27:03 <copumpkin> what do you expect us to say? "yes"?
18:27:07 <copumpkin> you're clearly trying to argue with us
18:27:15 <microatxslim_> c_wraith, like what apps?
18:27:17 <copumpkin> and I'm not interested in that
18:27:24 <copumpkin> so please stop
18:27:25 <microatxslim_> copumpkin, no, i want you to tell if guy is right
18:27:28 <microatxslim_> or wrong
18:27:34 <copumpkin> he's wrong. let's move on
18:27:37 <hcaulfield57> Okay, could someone explain to me functional dependencies? in "class (Monoid w, Monad m) => MonadWriter w m | m -> w where"
18:27:43 <microatxslim_> copumpkin, why is he
18:27:48 <hcaulfield57> All Google says is m depends on w, what does that mean?
18:27:50 <joelteon> hcaulfield57: m is uniquely determined by w
18:27:54 <joelteon> is that right? do i have it backwards?
18:28:00 --- mode: copumpkin set +q microatxslim_!*@*
18:28:02 --- mode: copumpkin set +z
18:28:06 <dwcook> Given a specific m you know what w is
18:28:10 --- mode: copumpkin set -o copumpkin
18:28:10 <joelteon> anyway, one of them is uniquely determined by the other.
18:28:18 <c_wraith> joelteon: you have it backwards
18:28:23 <johnw> joelteon: m uniquely determines w
18:28:25 <joelteon> w is uniquely determined by m
18:28:27 <joelteon> ok
18:28:31 <hcaulfield57> What does that mean for me the programmer though?
18:28:36 --- mode: ChanServ set +o copumpkin
18:28:38 <thirdlife> OneEyedWill: Checkout the Typeable class.
18:28:49 <johnw> it means that if you know what monad you're in, the compiler knows what 'w' is
18:28:50 <quchen> hcaulfield57: I think this post might be helpful: http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell
18:29:03 <c_wraith> hcaulfield57: it means that if the compiler knows m, it knows what w is..  Unlike normal MPTCs
18:29:37 <c_wraith> hcaulfield57: normally, knowing one type in an MPTC doesn't tell you anything at all about other types the instance depends on
18:29:42 <joneshf-laptop> OneEyedWill, is that whwat you were looking for?
18:30:31 <OneEyedWill> joelteon: thirdlife: ion: I think I figured it out. Thanks for the suggestions guys
18:31:24 <ion> oneeyedwill: In Haskell, types are a compile-time thing, not a runtime thing.
18:36:59 <carter> microatxslim_: joneshf-laptop  i meant that that array lib is crap
18:37:25 <carter> someone said osmething about memory locality
18:37:28 <carter> are they still here?
18:37:49 <carter> microatxslim_: i'm personally using haskell to write "fast as / faster than fortran" code
18:37:53 <carter> well
18:37:55 <carter> actually
18:38:03 <carter> i'm trying to make it easy for EVERYON E to do that
18:38:35 <Fuuzetsu> carter: I believe he's muted.
18:38:39 <carter> kk
18:38:54 <hcaulfield57> I've read through the stack overflow page, but it still doesn't make sense to me what it's doing.
18:38:55 <hcaulfield57> Well I have another question, given the definition class (Monoid w, Monad m) => MonadWriter w m | m -> w where what is the "m a" in listen :: m a -> m (a, w)?
18:40:05 <c_wraith> hcaulfield57: the type m from the definition, and a universally-quantified type variable, a.  The a can be any type (with kind *)
18:40:30 <c_wraith> hcaulfield57: are you familiar with type constructors?
18:41:33 <jfischoff> hcaulfield57: its hard to understand type class definition without knowing what kinds are
18:41:44 <hcaulfield57>  c_wraith: Kind of familiar, but I thought listen took a type of Writer a b, but clearly it does not
18:41:49 <dwcook> hcaulfield57, m is the m bound by the typeclass, a is bound implicitly by the signature of listen
18:41:49 <dwcook> m a is a concrete type representing the application of the type constructor m to that a
18:42:20 <joneshf-laptop> carter, fortran you say? What are your thoughts on julia?
18:42:21 <c_wraith> hcaulfield57: actually, it does...
18:42:33 <carter> joneshf-laptop: i think julia has some nice ideas
18:42:52 <carter> hangoon, i'm actually nerd sniping the troll
18:42:53 <carter> ;)
18:42:57 <c_wraith> hcaulfield57: change the writer signature, though, to eliminate overlap.  Writer x y unifies with m a as m = Writer x, a = y
18:43:30 <hcaulfield57> c_wraith: Oh, I see, that makes sense, thank you
18:45:34 <hcaulfield57> So if you added a Writer Char Char to listen you would get a Writer (Char, Char) ?
18:46:13 <c_wraith> Err.  If the input to listen is of type Writer Char Char, the output will be Writer Char (Char, Char)
18:46:35 <c_wraith> though Char isn't a monoid, so that's not all that likely. :)
18:47:41 <hcaulfield57> Okay, I'm beginning to understand, the whole type system is still a little hard for me though
18:48:19 <hcaulfield57> I need to have a second go through RWH, it's been several months now since my Haskell hiatus
18:48:21 <c_wraith> That's fine.  Just relax and and allow it to make sense in its own time.  It does make sense, but you just need to play with it
18:48:37 <carter> joneshf-laptop: i think it has good ideas
18:48:38 <carter> BUT
18:48:45 <carter> "being better than matlab"
18:48:48 <carter> is such a weak goal
18:49:04 <hcaulfield57> Yea, just doing examples is helpful, I understand monads I think better than I ever did
18:49:13 <hcaulfield57> I'm not writing a tutorial yet though :)
18:49:27 <Fuuzetsu> We always need more burritos.
18:49:40 <carter> hcaulfield57: i just treated em like cooties
18:53:56 <hcaulfield57> carter: avoided them and hoped they'd go away?
18:58:10 <bidybombooop> Hey all I'm getting a warning about overlapped patterns but I don't see it can someone give me a sanity check: http://pastie.org/8810811
19:00:42 <ion> “s'” and “error” are the same pattern.
19:00:46 <carter> hcaulfield57: nah
19:00:59 <carter> monads are kinda an algebraic formulation of cooties :)
19:01:42 <bidybombooop> ion: How?
19:01:48 <bidybombooop> I don't see it?
19:02:01 <ion> > case 42 of s' -> s' + 1
19:02:02 <lambdabot>  43
19:02:05 <ion> > case 42 of error -> error + 1
19:02:06 <lambdabot>  43
19:02:24 <ion> > case 42 of { s' -> s' + 1; anything -> anything + 2 }
19:02:25 <lambdabot>  43
19:02:28 <Fuuzetsu> bidybombooop: you're simply binding the result to ‘error’
19:02:41 <bidybombooop> Fuuzetsu: ion: I see
19:03:28 <bidybombooop> So would I need to evalE_maybe on the expression?
19:03:38 <carter> joneshf-laptop: but basically, they missed the boat on memory lcoalty
19:04:28 <ion> bidybombooop: Modify evalS to be :: Statement -> Store -> Maybe Store
19:04:39 <carter> joneshf-laptop: matlab / c / fortran "naive" idioms have 1000x perf gap from bad locality
19:04:43 <Fuuzetsu> bidybombooop: I think that you should turn evalS into evalS_maybe and return Nothing instead of stopping the world with error
19:04:49 <ion> bidybombooop: Or Either. In any case, get rid of “error” in that one.
19:08:34 <bidybombooop> Fuuzetsu: ion: That all makes sense. Thanks guys
19:10:29 <ion> bidybombooop: ‘error "foo"’ more or less means “please crash the program”, not “please return a useful value”
19:10:50 <bidybombooop> ion: got it
19:10:52 <bidybombooop> thanks
19:18:00 <zRecursive> :t (&&&)
19:18:01 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:20:55 <joneshf-laptop> carter, i'm not ignoring, just distracted
19:21:33 <carter> joneshf-laptop: i'm trying to get numerical haskell ready this month / next
19:21:35 <carter> plus work
19:21:36 <carter> :)
19:22:18 <carter> block oriented recursive algs with a small in memory base case
19:22:28 <carter> give good perf outcomes
19:37:10 <Algebr> So in a nutshell, pattern matching is Haskell's way to provide the functionality of function overloading or like python's optional paramters, right
19:37:50 <carter> nah
19:37:55 <carter> but you can use it like that
19:38:49 <Fuuzetsu> Algebr: Where did you get that idea from?
19:39:16 <Fuuzetsu> carter: Function overloading through pattern matching? I'm unsure what you mean.
19:39:30 <carter> Fuuzetsu: i'm thinking GADTS
19:39:36 <carter> but thats closed universe overloading
19:39:40 <Fuuzetsu> oh
19:39:53 <Fuuzetsu> I'm pretty sure that's not what Algebr is referring to here ;P
19:40:06 <taktoa_> pattern matching is kind of like putting a switch expression on every function... kind of
19:40:37 <Algebr> Fuuzetsu: because my function can return either an empty list or a list of items depending on say if the argument is an empty or non empty list
19:41:32 <lvmt> Does anyone know what the AST type that GHC Core uses when applying arguments to a type constructor. I.e. what is Just when I apply (Just 3), is Just a Type or a Var?
19:41:51 <taktoa_> Just is a type constructor
19:41:52 <taktoa_> for Maybe
19:42:00 <taktoa_> it is a function of arity 1
19:42:01 <lvmt> But what is int CoreSyn datatype?
19:42:29 <Fuuzetsu> Algebr: Sure, but how is that overloading? In Python you'd just check with an if statement or something.
19:42:46 <Algebr> Fuuzetsu: hmm, okay, I mispoke.
19:42:50 <carter> soke
19:42:59 <carter> learning how to describe what you wanna do can be tricky
19:43:54 <taktoa_> err... unary
19:44:00 <taktoa_> that was the word I was looking for
19:44:43 <carter> :t Just
19:44:44 <lambdabot> a -> Maybe a
19:44:48 <carter> :k Maybe
19:44:49 <lambdabot> * -> *
19:44:55 <Fuuzetsu> lvmt: You could ask in #ghc (or simply put together an example quickly and inspect it with Outputable or something)
19:45:52 <lvmt> Like for the datatype : data Maybe a = Just a | Nothing is Just in CoreSyn like (App (Var "Just") (I# 3)) or (App (Type (TyCon Just etc...) (I# 3)))
19:46:01 <lvmt> for (Just 3)
19:46:30 <lvmt> It all pretty prints the same way when I -ddump-simpl so I'm trying to understand
19:48:19 <Iceland_jack> Algebr: Haskell provides ad-hoc polymorphism (similar to operator overloading) by letting (+) in
19:48:20 <Iceland_jack>     a + b
19:48:20 <Iceland_jack> be a different function depending on if 'a, b :: Int' or 'a, b :: Double' or what ever
19:48:59 <Iceland_jack> So 'a + b' might turn into something like
19:48:59 <Iceland_jack>     plusInt a b
19:48:59 <Iceland_jack>     doubleInt a b
19:48:59 <Iceland_jack>     ...
19:49:02 <Iceland_jack> depending on the types of the operands
19:49:53 <Iceland_jack> In regular Haskell pattern matching doesn't have any influence on the types
19:49:57 <carter> lvmt: its a bit more complex than that
19:50:02 <carter> I think
19:50:11 <carter> what are you trying to udnerstad?
19:50:45 <lvmt> @carter I'm trying to understand what is getting applied in Core when you apply an argument to a type constructor
19:50:46 <lambdabot> He's leading down the path to the chicken coup.
19:50:54 <lvmt> @carter like the internal AST node it uses
19:50:54 <lambdabot> He's feathering his own empire.
19:50:56 <carter> oh
19:51:04 <carter> what the hell
19:51:07 <carter> @carter
19:51:07 <lambdabot> There's nothing like stealing the barn door after the horse is gone.
19:51:10 <carter> @hvr
19:51:10 <lambdabot> Maybe you meant: v arr
19:51:17 <carter> @c
19:51:17 <lambdabot> Maybe you meant: check choice-add choose cide clear-messages clear-topic compose v rc @ ? .
19:51:21 <carter> @ca
19:51:22 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
19:51:24 <carter> @car
19:51:24 <lambdabot> Maybe you meant: yarr part faq arr
19:51:27 <carter> @cart
19:51:28 <lambdabot> Not enough privileges
19:51:31 <carter> @carte
19:51:31 <lambdabot> Maybe you meant: paste part
19:51:33 <carter> @carter
19:51:34 <lambdabot> We need to screw our noses to the grindstone.
19:51:38 <taktoa_> lolwut
19:52:04 <ski> lvmt : please refrain from prefixing people's nicks with `@' on IRC
19:52:10 <trillioneyes> @farmer
19:52:11 <lambdabot> This mess would make Humpty Dumpty bleed.
19:52:12 <lvmt> oh, sorry about taht
19:52:58 <carter> i'm confused about theh lambdabot  command
19:53:05 <trillioneyes> lambdabot's autocorrection can be so confusing sometimes
19:53:11 <ski> @list quote
19:53:11 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s pinky brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
19:53:17 <ski> @help farber
19:53:17 <lambdabot> Farberisms in the style of David Farber.
19:53:24 <trillioneyes> ahh, I was close
19:54:06 <xnil> carter: is your first name carter?
19:54:10 <carter> yes
19:54:17 <trillioneyes> It might be worthwhile to change lambdabot's command character to something less likely to be the first character of a message
19:54:27 <xnil> you're the 2nd person i've ever met with my first name
19:54:35 <xnil> click here to claim your prize
19:54:37 <carter> nope
19:54:42 <carter> i was here first
19:54:42 <xnil> aw shucks
19:54:55 <carter> are you the one who emailed libraries
19:55:06 <carter> and i was like "no one bikeshed on haskell math"
19:55:16 <xnil> what is haskell?
19:55:29 <carter> i gues not
19:55:33 <xnil> :P
19:56:34 <taktoa_> carter x xnil is the cartesian square of two carters
19:56:52 <xnil> hot
19:56:59 <xnil> OTP
19:57:14 <taktoa_> lol
19:57:59 <xnil> on our tree in the field of flowers is written "carter^2"
19:58:16 <xnil> instead of the typical "A x B"
19:59:19 <carter> no comment
20:18:59 <dabd> doing my first steps in haskell. Is there a better way to write this function? http://lpaste.net/100475
20:20:02 <cmears> dabd, you could use a pattern guard to make it look slightly nicer
20:20:18 <cmears> toDigits i | i <= 0 = 0
20:20:26 <cmears>           | otherwise = map ...
20:20:32 <ski> that's an ordinary guard, not a pattern guard
20:21:01 <cmears> argh, yes, just a guard
20:21:09 <ski> instead of `show' and `digitToInt', you could use integral division
20:21:09 <cmears> it just goes near the pattern (:
20:21:23 <ski> > 1234 `quotRem` 10
20:21:24 <lambdabot>  (123,4)
20:22:01 <ski> > (1234 `quot` 10,1234 `rem` 10)
20:22:02 <lambdabot>  (123,4)
20:24:19 <[1]grant> Cabal question: I'm developing a program that uses some config files to change some program behavior. Where should I keep these sort of files in my project?
20:25:53 <twiceler> [1]grant: Perhaps System.Directory.getAppUserDataDirectory?
20:26:43 <[1]grant> I thought you were joking but that actually exists. Reading.
20:28:15 <twiceler> And to package up your default config file, I guess you might want to do something like this http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
20:28:38 <[1]grant> ahhh exactly what I was looking for, thanks a lot
20:33:04 <clintm> Is the haskell platform still the recommended way to get things set up, despite the latest release being over a year old?
20:33:30 <joelteon> new release is painfully close
20:33:37 <taktoa_> arch linux + cabal sandbox
20:34:12 <clintm> I tried downloading the latest of everything.  latest ghc, checked out cabal from github, etc, and it all exploded. :/
20:34:39 <taktoa_> what OS are you on
20:34:44 <clintm> osx
20:35:01 <clintm> maverickwhateverislatest.
20:36:03 <dabd> can someone please show me how can I fix toDigitsRev? http://lpaste.net/100475
20:36:24 <startling> clintm: what is "exploded"
20:36:32 <clintm> taktoa_: somehow I have gcc installed, it seems.  Can't remember ever installing it.
20:36:52 <geekosaur> taktoa_, in the /topic: "XCode 5 issues? http://is.gd/H4sEub"
20:36:57 <geekosaur> apple broke stuff
20:37:01 <dwcook> dabd, what ought it do?
20:37:10 <geekosaur> that's part of why the next haskell platform is delayed
20:37:20 <dabd> same as toDigits but in reverse order
20:37:29 <clintm> startling: Cabal the library would build just fine.  cabal-install, however, wouldn't build due to ... hell, it's been a couple of weeks.  I don't remember specifics offhand.  Though maybe I'll try it again.
20:37:37 <dwcook> dabd, then just compose reverse after toDigits
20:37:44 <dwcook> reverse . toDigits
20:37:46 <startling> clintm: oh, there's known issues with mavericks
20:37:55 <startling> clintm: do what geekosaur said
20:37:56 <geekosaur> alternately if you install via macports or homebrew (possibly with a shim needed in the latter case) you should get a working platform
20:38:18 <dabd> dwcook,  ofc thanks. But why isn't toDigitsRev compiling?
20:38:22 <clintm> startling: beyond xcode 5?  I've been over that page before I came here and asked. :)  I try to be a good citizen.
20:38:41 <geekosaur> you'll have to show us what errors you're getting then
20:38:45 <clintm> OH
20:38:50 <geekosaur> the xcode 5 issue reveals as preprocessor errors
20:39:09 <clintm> geekosaur: I missed the brew message.  Trying it now.
20:39:18 <dwcook> dabd, it does compile
20:39:42 <geekosaur> note, you should probably remove the hp package before using a different one
20:40:05 <geekosaur> there should be an uninstall script with the official one
20:40:52 <dabd> dwcook, it shows me this error http://lpaste.net/100480
20:41:01 <dabd> when i load it in ghci
20:41:29 <dwcook> dabd, sorry, I misread and thought you said toDigits
20:41:59 <dwcook> dabd, well why are you saying that s :: Integer there?
20:42:02 <dabd> ah i see now
20:42:17 <dabd> the lambda is returning an integer
20:42:27 <dabd> instead of [Integer]
20:42:33 <geekosaur> also I should note that I'm a macports guy, there are other folks (although between time and freenode glitches, possibly not around now) that know more about homebrew
20:42:36 <dwcook> Right
20:42:49 <dwcook> And since that's the leftmost thing being composed, its result is the composition chain's result
20:42:59 <dwcook> So your type signatures contradict each other
20:43:58 <dabd> dwcook, nvm i fixed thanks
20:49:47 <randomclown> > "wtf"
20:49:48 <lambdabot>  "wtf"
20:49:53 <randomclown> @pl \xs -> (f $ x) : xs
20:49:53 <lambdabot> (f x :)
20:51:06 <dwcook> randomclown, the expression (f $ x) might as well (almost) always be written as f x
20:52:40 <monochrom> (f $ x) : xs = f x : xs
20:56:07 <randomclown> dwcook: f is actually a huge stack of functions I didn't want to type oout
20:56:22 <randomclown> @pl \xs -> (f $ g b $ x) : xs
20:56:22 <lambdabot> (f (g b x) :)
20:56:27 <Fuuzetsu> bleh, vinyl produce some ugly types
20:56:57 <dwcook> Aw, lambdabot's smiling at you!
20:57:09 <Fuuzetsu> > "I'll eat dwcook alive"
20:57:10 <lambdabot>  "I'll eat dwcook alive"
20:57:15 <monochrom> (f . g b) x : xs
20:57:16 <dwcook> D:
20:58:48 <monochrom> when I eat sushi, I eat raw fish. (great tautology)
20:58:55 <ReinH> monochrom: :p
20:59:16 <ReinH> monochrom: hey I have a question and you might be a good person to ask :)
20:59:42 <randomclown> atomicModifyIORef or modifyMVar?
20:59:45 <randomclown> which one is faster?
21:00:02 <randomclown> which one works better under high contension
21:00:03 <monochrom> atomicModifyIORef is faster
21:00:05 <ReinH> monochrom: the foldr . map rule, foldr f z . map g = foldr (f . g) z, is it a free theorem? What's the easiest way to prove it? Structural induction?
21:00:21 <randomclown> monochrom: is there a particular reason why?
21:00:47 <dwcook> randomclown, keep in mind that IORef and MVar behave slightly differently – an MVar is more like an (up-to-)one-element queue
21:01:26 <randomclown> Ok, I have a list that many threads write to
21:01:29 <monochrom> it is not a free theorem. induction is a good way.
21:01:40 <randomclown> every 2 seconds, the master thread comes and empties this list
21:01:49 <randomclown> what would be the best set up?
21:01:50 <ReinH> monochrom: hmm, ok thanks
21:02:31 <monochrom> it really depends on how abstractly you define map and foldr.
21:02:45 <randomclown> there can be thousands of thread writing to the list
21:02:47 <randomclown> dwcook:
21:03:11 <dwcook> randomclown, I don't know what to do with that information.
21:03:32 <randomclown> I've tried using a MVar but it seems to fall over under the high contentsion
21:03:42 <randomclown> so I'm going to try atomicModifyIORef
21:03:48 <dwcook> Okay. Good luck.
21:03:54 <taktoa__> I really wish building haskell programs wasn't so fragile
21:04:00 <randomclown> dwcook: was using a Chan before
21:04:03 <randomclown> it seems to work
21:04:05 <carter> randomclown: noooooo
21:04:12 <ion> taktoa: In what way?
21:04:15 <carter> randomclown: you probably should do an mvar for now
21:04:18 <carter> or STM
21:04:20 <taktoa__> well, cabal hell
21:04:25 <carter> taktoa__: yesod?
21:04:28 <carter> what things
21:04:29 <carter> tell me
21:04:40 <taktoa__> building anything large and cross platform with haskell
21:04:46 <taktoa__> just seems like a big hassle
21:04:51 <randomclown> carter: MVar was really slow though
21:04:51 <carter> taktoa__: depends
21:05:03 <carter> randomclown: can you share you your code?
21:05:21 <randomclown> carter: can I private message?
21:05:23 <carter> sure
21:05:30 <cem__> i feel haskell is quite complicated :(
21:05:49 <taktoa__> I kind of wish there were a VM backend for haskell
21:05:49 <ReinH> randomclown: you should read Simon Marlow's Parallel and Concurrent Haskell book. It's free.
21:06:30 <ReinH> taktoa__: hmmm, from what I've seen it's exactly the opposite.
21:06:49 <ion> cem: Programming is quite complicated.
21:07:06 <carter> and we're all working hard to make it saner and more pleasant
21:07:13 <clintm> nice.  After lots of time installing, it looks like I have a sane environment.  Thanks for the help.  I'd call you out but apparently the netsplit I was in blew those messages out of the message buffer. :(
21:07:26 <ReinH> taktoa__: we have a haskell cast episode where dons talks about developing and maintaining million+ LoC haskell programs
21:07:26 <clintm> cem__: so is chess, in much the same way.
21:07:55 <clintm> ReinH: that's a good one.
21:08:06 <ReinH> clintm: :) thanks
21:08:13 <dwcook> Haskell's complexity is generally directed at making the language easier to use, rather than being interesting as a strategy game :)
21:08:31 <jfischoff_> cem__: it's less complicated then C++ more than C I would say
21:08:31 <ReinH> cem__: it's complex in a way you are unfamiliar with, that's all :)
21:09:00 <ReinH> clintm: new one coming out this week, very awesome.
21:09:01 <cem__> clintm: chess is  different ,
21:09:03 <cem__>  the language syntax is weird
21:09:13 <ReinH> cem__: do you think Chinese is a weird language?
21:09:29 <taktoa__> I guess I could look into GHCJS or (a)jhc or haskerl etc.
21:09:29 <cem__> ReinH: yep
21:09:29 <ReinH> cem__: that's just because you don't speak it.
21:09:29 <monochrom> haskell is the simplest programming language I have seen. I have seen C, SML, Java, Javascript, Lisp, Scheme, a bunch of others.
21:09:35 <ReinH> it's perfectly normal to people that speak Chinese.
21:10:04 <kvda> monochrom, umm
21:10:04 <jfischoff_> monochrom: in what way do you mean (honest question)?
21:10:05 <nisstyre> monochrom: how is Haskell simpler than Scheme?
21:10:05 <taktoa__> monochrom: you haven't seen Jot
21:10:11 <clintm> I bet, to people who speak chinese, English is some messed up, unorganized crap.
21:10:21 <monochrom> Definition: Suppose f(x)=x+x. a language is simple iff this law holds: f(g(y)) = g(y) + g(y). Haskell satisfies this. none other in my list does.
21:10:27 <jfischoff_> there are definitely languages with less constructs
21:10:32 <ion> cem: The language syntax is weird compared to what?
21:10:39 <monochrom> Does Jot satisfy f(g(y)) = g(y) + g(y)?
21:10:39 <ReinH> clintm: yeah, probably similar to how Haskellers feel about imperative languages ;)
21:10:59 <dwcook> Though it would be interesting to do a Prisoner's Dilemma sort of thing in Haskell much like people have done in Lisp
21:11:11 <taktoa__> Jot is just Unlambda, with only the U combinator and parentheses
21:11:15 <jfischoff_> ah simple to reason about
21:11:19 <monochrom> also, I speak Chinese. English is a mess regarding when to use plural, when to use "less", when to use "fewer", etc
21:11:20 <taktoa__> it is the ultimate turing tarpit
21:11:45 <cem__> js also functional but its quite nice :?
21:11:52 <monochrom> I do not know Unlambda either. does Unlambda satisfy f(g(y)) = g(y) + g(y)?
21:12:55 <ReinH> monochrom: wait what?
21:13:04 <monochrom> Definition: Suppose f(x)=x+x. a language is simple iff this law holds: f(g(y)) = g(y) + g(y). Haskell satisfies this. none other in my list does.
21:13:06 <taktoa__> speak lojban
21:13:30 <ReinH> monochrom: I don't speak chinese but I did pick it as a relatively sane langauge in comparison with English ;)
21:13:46 <monochrom> oh ok! we're in agreement :)
21:13:54 <kvda> monochrom, well done, you're basing 'simple language' on one rule among many
21:13:56 <twiceler> monochrom: It sounds like Unlambda is just combinatory logic... so it would be referentially transparent
21:13:59 <ReinH> cem__: if you spend more time with Haskell it'll become more familiar-feeling :)
21:14:17 <nisstyre> monochrom: http://codepad.org/OKdJzIrj
21:14:26 <monochrom> yes kvda, see my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
21:15:38 <monochrom> an explicit criterion is better than subjective judgment
21:16:34 <nisstyre> forgot to substitute the y's but you get the point
21:16:47 <nisstyre> monochrom: how does Scheme fail that test?
21:16:49 <twiceler> nisstyre: It has to hold for *anything*
21:17:11 <nisstyre> twiceler: well numbers are immutable in Scheme
21:17:11 <taktoa__>  /s
21:17:18 <taktoa__> http://en.wikipedia.org/wiki/Iota_and_Jot
21:17:19 <monochrom> you have not tried, let's say, (f (random 6)) vs (+ (random 6) (random 6))
21:17:26 <monochrom> see my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
21:17:34 <nisstyre> monochrom: so you want referential transparency?
21:18:01 <ReinH> monochrom: is that your page? Nice.
21:18:11 <monochrom> I no longer know what is referential transparency. apparently, that term is not referentially transparent! but I guess I should just say yes.
21:18:19 <monochrom> yes I wrote it
21:18:20 <ReinH> ha
21:18:56 <nisstyre> monochrom: anyway, Clean passes with flying colours
21:19:20 <twiceler> + Agda, Idris
21:19:23 <Heather> hi
21:19:24 <monochrom> I was too lazy to learn Clean. that is all. oh and Unlambda, Idris, Agda, a couple others.
21:19:35 <Heather> suggest me how can I recode this: opts <- foldl (>>=) (return defaultOptions) actions
21:19:36 <nisstyre> monochrom: Clean is very similar to Haskell
21:19:40 <ReinH> monochrom: where does Liebniz's Law come from?
21:19:52 <monochrom> Leibniz himself, I think.
21:20:00 <nisstyre> it uses uniqueness types to do side-effects though, which preserves type safety and referential transparency
21:20:16 <ReinH> monochrom: heh. Sorry. Where can I find it?
21:20:23 <nisstyre> similar to how IO in Haskell is done with a monad
21:20:24 <twiceler> nisstyre: Is that like ST state threads in Haskell?
21:20:27 <nisstyre> well, similar goal
21:20:37 <nisstyre> twiceler: does that do mutation?
21:20:40 <monochrom> yeah you see my article says "haskell does one way. there are other ways." I have Clean in mind when I said "there are other ways."
21:20:42 <AlecTaylor> hi
21:20:47 <AlecTaylor> How do I make my RESTful application engineering DRY-er? - http://programmers.stackexchange.com/q/230739
21:20:53 <nisstyre> Clean can do mutation while preserving type safety
21:20:57 <ReinH> Heather: well, it could be opts <- foldl (>=>) return actions $ defaultOptions, but I'm not sure what direction you want to go in
21:21:02 <monochrom> ReinH, I have only learned it from Dijkstra's articles
21:21:21 <twiceler> nisstyre: Yes, it does mutation, and allows you to "pull out" a pure value at the end
21:21:27 <milfjord> :t foldl (>>=) (return ?defaultOptions) ?actions
21:21:28 <lambdabot> (Monad m, ?defaultOptions::a, ?actions::[a -> m a]) => m a
21:21:35 <ReinH> monochrom: I'm trying to find a source and failing :(
21:21:40 <nisstyre> twiceler: I'm not sure if they're similarly implemented
21:21:41 <twiceler> runST :: (forall s. ST s a) -> a
21:21:45 <ReinH> monochrom: it's relevant to a talk I'm giving in a week
21:21:50 <ReinH> monochrom: so I am interested :)
21:22:05 <nisstyre> twiceler: but yeah probably a similar effect
21:22:23 <nisstyre> but this has the benefit of being language supported
21:22:28 <twiceler> the ST monad is really fascinating as far as having mutability in a functional language. And it's how IO is done (although IO can do other things too)
21:22:39 <nisstyre> unfortunately not many people use Clean so there are not many good libraries
21:23:13 <kadoban> ReinH: http://en.wikipedia.org/wiki/Leibniz%E2%80%93Clarke_correspondence i think it's from here, from what i remember
21:23:47 <ReinH> kadoban: um...
21:24:02 <dabd> I wrote a function doubleEveryOther that takes a list of integers and doubles every other starting from the right. http://lpaste.net/100485
21:24:03 <jfischoff> Heather: I guess you should use fold' there, not that it will matter :p
21:24:07 <kadoban> that page kind of sucks, but...yeah...i just googled the title, haha
21:24:13 <dabd> Any simpler way to achieve this? Comments on indentation?
21:24:21 <kadoban> i'm sure it's available free somewhere or other
21:24:46 <monochrom> ReinH: http://en.wikipedia.org/wiki/Identity_of_indiscernibles may or may not help
21:25:12 <ReinH> monochrom: ah.
21:25:20 <twiceler> nisstyre: Ahh, yes, uniqueness types are similar to the ST monad in Haskell
21:25:48 <clintm> 'cabal-dev install snap' .... and so it begins.
21:25:53 <ReinH> monochrom: but that's not math, that's philosophy :p
21:26:02 <nisstyre> twiceler: okay, yeah, you end up doing state threading in Clean too, despite the ability to mutate
21:26:07 <ReinH> monochrom: so I'm giving a talk on math for ruby developers :)
21:26:18 <ReinH> monochrom: it's going to be a lot of fun even if my hands will be very tired by the end from all the waving.
21:26:25 <jfischoff> dabd: why the reverse?
21:26:29 <twiceler> When we talk about an action of type ST s a, it is a function (s -> (a, s)) where you can think of the "s" as being a unique handle to all mutable references
21:26:39 <dabd> because i need to start from the right
21:26:55 <dabd> i was thinking maybe a foldr could do it
21:26:56 <kadoban> well, unless i'm very wrong, the principle was derived from his philisophical work, ReinH
21:27:06 <jfischoff> oh yes you said that
21:27:12 <nisstyre> and you can't do anything weird because the type system knows if you, say, reused a handle to /dev/random or whatever without having it be "different"
21:27:18 <ReinH> kadoban: makes sense :)
21:27:22 <twiceler> So if you look at the primitives in GHC Core (http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#g:12) you'll see types that I imagine look like what you do in Clean
21:27:51 <nisstyre> twiceler: this has some info http://wiki.clean.cs.ru.nl/download/supported/ObjectIO.1.2/doc/tutorial.pdf
21:28:20 <ReinH> dabd: why do you need to reverse twice?
21:28:42 <dabd> because in the end I need the list in the same initial order
21:29:11 <ReinH> > let f i x = if odd i then 2 * x else x in zipWith f [0..] [1,2,3,4]
21:29:12 <lambdabot>  [1,4,3,8]
21:29:18 <dabd> is it ok to indent the second reverse like that? doesn't look right
21:29:18 <ReinH> ?
21:29:58 <ReinH> reverse . reverse = id :p
21:30:22 <dabd> your code is not behaving like i intend. I want to double every other starting from the butlast element
21:30:43 <ReinH> dabd: Oh. Ok then. That's about the best you can do.
21:31:08 <ReinH> I would probably use a where binding instead of an anonymous lambda
21:31:09 <zRecursive> @src foldl
21:31:09 <lambdabot> foldl f z []     = z
21:31:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:31:28 <dabd> show me how pls
21:31:47 <nisstyre> twiceler: anyway you'll notice that the core of the IO programs in Clean are basically taking in a World and returning a new one
21:32:05 <ReinH> doubleEveryOther = reverse . go . reverse where go x i | odd i = x * i; | otherwise = x
21:32:14 <ReinH> I think you could do it in a single pass with a foldr actually
21:32:22 <ReinH> hmm, no
21:32:37 <ReinH> hmm, yes
21:32:51 <ReinH> maybe
21:33:14 <zRecursive> @src foldr
21:33:14 <lambdabot> foldr f z []     = z
21:33:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:33:15 <dabd> it should be possible but you need to keep track of the index somehow
21:33:55 <levi> I'm pretty sure I wrote a foldr version of that... let me see if I can find it.
21:34:06 <ReinH> not the index, just whether or not you are doubling
21:34:29 <dabd> btw this is an exercise from this haskell course http://www.cis.upenn.edu/~cis194/lectures.html
21:36:20 <levi> Ahh, the exercise I did was similar but not quite the same.
21:37:03 <ReinH> monochrom: also as a result of our previous conversation https://twitter.com/reinh/status/439266144931676160
21:37:07 <levi> It splits a list into even and odd elements via a foldr
21:37:26 <ReinH> levi: "implement `partition' as a foldr"? ;)
21:38:48 <levi> Well, it's a bit less obvious than some folds.
21:39:18 <nisstyre> ReinH: English is actually much simpler than most languages, from a syntactic point of views
21:39:19 <satc> Is there a way to use DefaultSignatures for associated type families of a class ?
21:39:36 <nisstyre> its complexity is in the morphology and spelling system
21:39:51 <nisstyre> the latter is mostly because people never changed the spelling of words when the sounds changed
21:39:52 <enthropy> dabd: make foldr take a 4th argument
21:39:57 <taktoa__> and orthography
21:40:09 <nisstyre> so sort of like bad documentation if you want to make a programming analogy
21:40:21 <taktoa__> huh, I guess Lojban would be like Prolog, and Latin would be like Common Lisp
21:40:26 <nisstyre> you change a function but don't change the old documentation
21:40:35 <enthropy>  foldr f z xs True -- basically gets to pass the True from the end of the list up
21:40:48 <enthropy> if you pick f and z to be appropriate functions
21:41:07 <enthropy> and you have the opportunity to pass (not b) on too
21:41:13 <dabd> if I write the function using where http://lpaste.net/100488 is the where indented correctly?
21:41:41 <nisstyre> taktoa__: because it's a dead language?
21:41:51 <dabd> or should it be aligned with the reverse in the previous line
21:41:57 <taktoa__> well, not exactly
21:41:59 <nisstyre> which mutated into several different child languages?
21:42:04 <nisstyre> that would be the original lisp though
21:42:08 <taktoa__> yea
21:42:24 <enthropy> dabd: that one is fine
21:42:38 <dabd> enthropy, but with a foldr it becomes harder to read
21:42:43 <dabd> it seems...
21:43:02 <nisstyre> taktoa__: and the PIE of programming languages is something like Frege's logic
21:43:03 <[1]grant> When fmap and liftM can be used interchangeably, which should be preferred?
21:43:08 <levi> http://lpaste.net/100489
21:43:12 <shachaf> fmap
21:43:16 <taktoa__> lol
21:43:25 <Heather> by the way, why people use Irdis?
21:43:27 <enthropy> > foldr (\ e k b -> let e' | b = 2*e | otherwise = e in e' : k (not b) )  (const []) [1,2,3] True
21:43:28 <lambdabot>  [2,2,6]
21:43:29 <[1]grant> Why fmap?
21:43:34 <taktoa__> Idris has dependent types
21:43:45 <taktoa__> i.e.: types that depend on values
21:43:48 <enthropy> is what I was thinking of, but goes from the front
21:43:53 <ReinH> [1]grant: it can sometimes be implemented more efficiently than liftM, which can only use the monad behavior.
21:43:58 <nisstyre> taktoa__: and the ability to have type:type
21:44:11 <nisstyre> well, type::type :P
21:44:12 <[1]grant> K, thanks
21:44:13 <Heather> what is it?
21:44:14 <enthropy> the ability to use : for types?
21:44:25 <nisstyre> no, I was using : as type of
21:44:30 <ReinH> [1]grant: liftM is the default fmap you get for any monad. Some functors have more efficient ways to write fmap.
21:44:53 <nisstyre> enthropy: i.e. an expressive kind system
21:45:25 <enthropy> swapping the : and :: probably makes sense though
21:45:32 <ReinH> enthropy: clever.
21:45:44 <enthropy> ReinH: it doesn't do the right thing though
21:45:52 <ReinH> enthropy: not clever enough then
21:45:59 <enthropy> anyways it's a ghci-aided function
21:46:08 <nisstyre> enthropy: yeah I think it's seen as a wart of Haskell that : is cons
21:46:09 <Heather> irdis looks like even harder than haskell :S
21:46:12 <levi> dabd: Did you look at my foldr paste? http://lpaste.net/100489
21:46:13 <nisstyre> and :: is type of
21:46:13 <enthropy> :t \f z xs -> foldr f z xs True
21:46:14 <lambdabot> (a -> (Bool -> t) -> Bool -> t) -> (Bool -> t) -> [a] -> t
21:46:24 <enthropy> then fill in some more parts
21:46:57 <ReinH> heh
21:47:02 <enthropy> it's a pretty wart then
21:47:18 <enthropy> you're supposed to use more lists than type signatures
21:47:33 <dabd> levi, yes
21:47:45 <ReinH> Eh. I don't understand why : can't do double duty as both
21:47:47 <ReinH> [] already does.
21:48:06 <dabd> but i don't see how it helps solve the exercise
21:48:35 <enthropy> > (\(f :: Bool) -> not f) True
21:48:36 <lambdabot>  False
21:49:06 <nisstyre> ReinH: yes you could do it with a little forward looking parsing I think
21:49:24 <levi> dabd: It could be re-written to solve it by changing the 'place' function.
21:49:56 <nisstyre> ReinH: something like "if what follows parses as a type expression"
21:50:02 <nisstyre> that might be really inefficient though, idk
21:50:08 <dabd> levi, sorry i'm not following
21:50:09 <Heather> Irdis compiles to C with GC? :S
21:50:13 <ReinH> nisstyre: yeah, it makes the parsing more difficult because you can't just look for a ::, definitely
21:50:25 <dabd> haskell newbie here
21:50:57 <enthropy> parsing haskell is already a nightmare
21:51:08 <monochrom> after all, GHC used to compile Haskell to C with GC, too :)
21:51:55 * monochrom loves to point out that "the world is scarier than you think!" :)
21:52:29 <nisstyre> enthropy: I think it would actually be easy to implement, though I don't know how the GHC parser is structured
21:52:35 <nisstyre> but it would require a lot of lookahead
21:52:39 <monochrom> and conversely, sometimes other people tell me how the world is scarier than I think. that is fun too :)
21:52:52 <enthropy> it uses happy
21:53:48 <Heather> and it's available on hackage :S
21:54:15 <nisstyre> actually now that I think about it, a : Foo (Bar b) would be ambiguous
21:54:32 <nisstyre> so it would have to know that Foo and/or Bar are types
21:54:33 <ReinH> monochrom: the world is scarier than anyone things.
21:54:35 <levi> dabd: It's basically the same thing as enthropy is doing, but with the 'more parts' filled out differently and a type isomorphic to Bool
21:54:38 <ReinH> *thinks
21:54:44 <ReinH> what has happened to my typing :(
21:54:49 <monochrom> for example, a long time ago, I laughed at the idea of "theorem prover written in javascript". then I found http://www.umsu.de/logik/trees/
21:55:21 <ReinH> monochrom: wait what...
21:55:57 <zRecursive> wow, `cabal install cabal-install` seems frozed ...
21:56:18 <zRecursive> 66/72 now
21:56:19 <milfjord> it's frozen when your heart's not open
21:56:30 <monochrom> well, this one is not exactly a very powerful theorem prover. but it can do your vanilla first-order logic homework. it's good enough for me :)
21:56:43 <zRecursive> milfjord: how open ?
21:56:51 <milfjord> about 2
21:57:00 <monochrom> cabal-install takes a while to compile, don't worry.
21:57:06 <ReinH> milfjord: maybe 2.5
21:57:25 <zRecursive> monochrom: waiting now
21:57:57 <milfjord> monochrom: ISTR you saying something about less/fewer being confusing
21:58:18 <milfjord> do you think the same way about much/many?
21:58:24 <monochrom> yes
21:58:38 <monochrom> well, I can cope. I have already coped, clearly.
21:58:40 <ReinH> As a native English speaker I still mess up less/fewer.
21:58:51 <shachaf> i'm ok with less/fewer but i find more/more confusing
21:58:51 <milfjord> ReinH: but do you mess up much/many?
21:58:53 <nisstyre> the convention is that discrete objects use fewer
21:59:01 <ReinH> And some of my friends derive many pleasure from snidely correcting me
21:59:08 <ReinH> milfjord: (actually no, I don't)
21:59:09 <nisstyre> yeah they're dumb
21:59:20 <monochrom> but just a few days ago I was grading computability homework, and a student wrote "less steps" instead of "fewer steps". I sympathize with that.
21:59:22 <milfjord> I thought so, and that's fascinating
21:59:39 <ReinH> monochrom: oddly, that one is obvious to me. Some cases are just not obvious.
21:59:47 <ReinH> I don't understand how my brain decides these things.
21:59:51 <ReinH> But I am disappointed with it.
22:00:02 <milfjord> German has the much/many distinction but not less/fewer
22:00:07 <monochrom> oh, I still have philosophical objections to "money" and "hair" being "uncountable"
22:00:22 <nisstyre> btw, it's not all variations of English that make a distinction between fewer and less
22:00:22 <ReinH> heh
22:00:29 <nisstyre> just the high status varieties
22:00:46 <ReinH> monochrom: Do you have too many moneys?
22:00:49 <nisstyre> and obviously some people who know the standard variety mess up
22:00:57 <monochrom> I have too few!
22:01:23 <milfjord> monochrom: countability is a property of the word, not the object it refers to
22:01:41 <ReinH> basically english is terrible
22:01:55 <nisstyre> ReinH: people are terrible
22:01:59 <milfjord> but wait, then you have things like "much liquid" and "many liquids"
22:02:00 <ReinH> also true
22:02:08 <johnw> is this really #haskell? :)
22:02:10 <levi> dabd: Did you figure out how to write it as a foldr?
22:02:14 <ReinH> johnw: :)
22:02:57 <monochrom> well, I know how to make it relevant to #haskell. x and xs, hair and hairs...
22:03:03 <ReinH> wow, it's 10pm and I am tired. I think I'm going to go to sleep. This must be what being an adult is like.
22:03:28 <nisstyre> monochrom: I love the over regularized use of -s for lists of stuff
22:03:37 <nisstyre> catss
22:03:38 <levi> dabd: I did look up the exercise and verify that a couple of changes to the helper functions make it satisfy the specification.
22:03:42 <johnw> ReinH: you haven't said when you got up or how much you slept the night before
22:03:46 <ReinH> nisstyre: a list of lists of cats, of course
22:03:51 <johnw> everything is about context :)
22:04:02 <ReinH> johnw: I got up at 8am and went to sleep at about 11pm last night. What is happening to me.
22:04:11 <ReinH> johnw: also my kitten is an excellent alarm clock.
22:04:15 <monochrom> in fact just half a day ago in #haskell-tw (taiwan) they were talking about exactly how it makes naming difficult, e.g., sometimes it's "s" sometimes it's "es" etc
22:04:17 <johnw> awwww
22:04:37 <jle`> ReinH: as your twitter testifies, yes?
22:04:39 <jle`> (or was that somebody else)
22:04:46 <dabd> levi, i'm trying to finish the exercise with my version
22:04:57 <dabd> foldr looks too complicated for me now
22:05:05 <ReinH> jle`: yep.
22:05:14 <ReinH> johnw: he has a little kitten bed on my desk https://twitter.com/ReinH/status/437992128099016704
22:05:34 <ReinH> it's pretty much the most adorable thing ever.
22:05:46 <jle`> aw Tekmo is not online
22:05:50 <johnw> they make it all worth it, I must say :)
22:05:59 <jle`> i always thought that he was perpetually online
22:06:02 <ReinH> johnw: https://twitter.com/reinh
22:06:05 <ReinH> er not that
22:06:17 <jle`> he once paused in the middle of a conversation to mention that he was on his vacation and relaxed on #haskell
22:06:19 <ReinH> johnw: this https://twitter.com/ReinH/status/438743630174367745
22:06:24 <ReinH> jle`: heheh :)
22:06:39 <ReinH> jle`: btw we just recorded a haskell cast episide with Tekmo and Snoyman :D
22:06:43 <ReinH> was pretty awesome
22:06:56 <jle`> ReinH: there is a Haskell cast?
22:06:58 <ReinH> also *episode I am so ashamed of my spelling right now :(
22:07:05 <ReinH> jle`: uh, which rock have you been living under? :p
22:07:08 <johnw> were they nerf bats?
22:07:12 <johnw> were there*
22:07:14 <jle`> could this be the solution to my lack-of-good-podcast woes?
22:07:19 <ReinH> jle`: maybe
22:07:24 <monochrom> yes absolutely
22:07:47 <ReinH> jle`: episodes so far: edwardk, Don Stewart, Simon Peyton Jones, Simon Marlow, Brent Yorgey :)
22:07:54 <jle`> 'haskell cast' on google autocompletes as 'haskell cast to int'
22:07:56 <jle`> heh
22:07:56 <ReinH> jle`: haskellcast.com
22:07:57 <nisstyre> I would like to see someone related to GHC on the FLOSS weekly podcast, they had Matthew Flatt on a while ago (Racket)
22:07:57 <ReinH> ha
22:07:58 <jle`> oh wow
22:08:03 <ReinH> and /end shameless plug
22:08:28 <jle`> also Rein i am appalled at your abomination of a mixture of doge and lolcat.
22:08:35 <ReinH> jle`: ?
22:08:40 <gabemc> I have a question about optparse-applicative. I'm trying to make an 'argument' optional, but I'm not having any luck with `<*> (optional . argument) auto (metavar "FILE")`
22:08:41 <jle`> in your twitter picture :)
22:08:42 <nisstyre> oh and they did Yesod
22:08:48 <ReinH> jle`: it's a panda.
22:08:49 <nisstyre> I just remembered that
22:08:51 <ReinH> an angry panda.
22:08:57 <monochrom> perhaps one day, we can cast haskell to agda, too
22:09:03 <ReinH> monochrom: heh :D
22:09:09 <ReinH> gabemc: what happens when you do that?
22:09:12 <jle`> "We have a new kitten! Such purr wow."
22:09:19 <jle`> oh i did not notice that there was no period after purr
22:09:39 <ReinH> jle`: I code switch. Deal with it. ;)
22:09:53 <jle`> i am a purist.
22:10:16 <supki_> gabemc: optional applies to the whole parser
22:10:22 <gabemc> ReinH: http://lpaste.net/100493
22:10:26 <nisstyre> ReinH: you might like this btw http://www.npr.org/blogs/codeswitch/
22:10:27 <supki_> gabemc: like  optional (argument auto (metavar "FILE"))
22:10:39 <ReinH> nisstyre: oh I do :)
22:10:48 <levi> nisstyre: Matthew Flatt goes to my local functional programming meetups. Gave a fun Racket presentation a couple of months ago.
22:11:02 <Fuuzetsu> code switch? Is that like bait-and-switch where you promise safety of Agda but deliver PHP software instead?
22:11:02 <gabemc> ReinH: You rock, thanks.
22:11:07 <nisstyre> levi: awesome!
22:11:34 <dabd> levi, my solution http://lpaste.net/100494
22:11:38 <nisstyre> Fuuzetsu: more like starting a PHP program and then switching to Haskell halfway through
22:11:41 * hackagebot MemoTrie 0.6.2 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.6.2 (ConalElliott)
22:11:41 * hackagebot mono-traversable 0.3.0.3 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.3.0.3 (MichaelSnoyman)
22:11:42 <levi> William Byrd was there last time, too.
22:12:24 <jle`> ReinH: do you mind submitting your podcast to Stitcher if you ever have the time/desire? :) http://www.stitcher.com/content-faq
22:12:41 <monochrom> @hoogle optional
22:12:42 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
22:12:42 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
22:12:42 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
22:12:51 <levi> dabd: I updated my previous paste with the foldr version of doubleEveryOther, too.
22:13:00 <dabd> levi, ok ty
22:13:11 <ReinH> jle`: good idea thanks
22:13:21 <jle`> for some reason i can't add arbitrary rss feeds
22:13:23 <jle`> as a user
22:13:26 <jle`> this is kinda silly
22:14:41 <ReinH> jle`: :(
22:14:54 <ReinH> :t optional
22:14:55 <lambdabot> Alternative f => f a -> f (Maybe a)
22:15:00 <jle`> i think they do it so that they can partner with distributors/podcast creators?
22:15:12 <ReinH> gabemc: I don't think you want to compose there
22:15:14 <jle`> i think they also try to be  a distributino platform as well
22:15:19 <levi> dabd: Your solution looks nice.
22:15:22 <ReinH> jle`: I guess. :/
22:15:30 <ReinH> jle`: what platform do you listen to podcasts on?
22:15:51 <johnw> I found the iTunes feed
22:15:57 <jle`> i used to use beyondpod and it was nice
22:16:03 <levi> ReinH: So when's the next episode?
22:16:04 <dabd> thanks
22:16:12 <levi> dabd: Do you see how the foldr works now?
22:16:13 <jle`> i switched to Stitcher because it synec my stuff on all my different devices/platforms
22:16:21 <jle`> but also i like how the experience is sort of all integrated together
22:16:23 <dabd> yes
22:16:27 <jle`> like a continuous radio stream
22:16:29 <jle`> so i stuck with it
22:16:30 <ReinH> levi: just finished editing it today, should be posting soon
22:16:57 <ReinH> jle`: shame about the walled garden thing :/
22:17:00 <levi> ReinH: Oh, nice! I wasn't expecting there to actually be one soon.
22:17:05 <jle`> on this note are there any other haskell-related podcasts?
22:17:07 <ReinH> but I guess that's how they plan on making money? I'd prefer they just charged people.
22:17:11 <jle`> ReinH: yeah, id idn't realize it until now
22:17:11 <ReinH> jle`: not really afai
22:17:14 <ReinH> afaik
22:17:29 <ReinH> levi: :)
22:17:36 <ReinH> levi: we try to release one monthly
22:17:37 <jle`> but it's the sacrifice for the nice integration of everything
22:17:43 <ReinH> jle`: I guess so
22:17:46 <jle`> i preferred its listening experience to other podcast managers
22:17:51 <jle`> i have used
22:17:52 <levi> ReinH: I was only partially following conversation here; missed the bit where you said you just finished recording.
22:17:54 <ReinH> jle`: nice, shame about the business model :)
22:17:58 <ReinH> levi: no worries :D
22:18:17 <jle`> well, some might call it a necessary tradeoff
22:18:22 <jle`> look at apple
22:18:45 <ReinH> jle`: apple has a significant advantage there :p
22:18:49 <levi> I'm curious to hear how their live communication resembles their reddit discussions.
22:19:02 <ReinH> levi: heh, it was very friendly
22:19:15 <ReinH> they are much less snarky in person
22:19:30 <ReinH> there's probably some sort of lesser internet not-quite-anonymous fuckwad theorem
22:19:32 <jle`> hey, normal people don't really care too much about walled gardens :)
22:19:42 <ReinH> where even known people are slightly more rude on the internet
22:19:43 <jle`> and i straddle the border
22:19:47 <zRecursive> "Installed cabal-install-1.18.0.2" ok :)
22:19:55 <ReinH> zRecursive: heh welcome back ;)
22:19:59 <jle`> between normal and non-normal
22:20:04 <ReinH> jle`: well, they do when the wall gets in the way :p
22:20:08 <zRecursive> ReinH: thanks
22:20:17 <levi> Well, they don't strike me as super snarky on reddit, just a big aggressively promotional of their pet packages.
22:20:32 <randomclown> @pl \xs -> ([], xs)
22:20:33 <lambdabot> (,) []
22:20:35 <ReinH> levi: they've gotten into a few... scenes.
22:20:36 <jle`> well constructed walls are engineered in such a way to avoid such feelings
22:20:49 <jle`> randomclown: oh wow. just section it :)
22:21:01 <ReinH> eh, (,) [] is fine
22:21:15 <jle`> i do tend to be over-zealous about sections
22:21:19 <jle`> ghc-mod yells at me
22:21:21 <ReinH> although ([],) is too, I guess.
22:21:21 <jle`> when i use flip
22:21:33 <jle`> for two-argument functions
22:21:36 <randomclown> ReinH: ([],) looks too much like typo
22:21:40 <ReinH> heh
22:21:40 <jle`> so i have been classically conditioned
22:21:50 <ReinH> :)
22:21:58 <jle`> but really do you always need to do (`f` y) instead of (flip f y) ?
22:22:04 <randomclown> I hated python 's (x,)
22:22:18 <ReinH> jle`: no, that's silly
22:22:22 <randomclown> (x,) is a typle with 1 element in python
22:22:27 <randomclown> tuple*
22:22:31 <jle`> someone tell the hlint people that >.<
22:22:38 <levi> The not-a-tuple. :)
22:22:38 <randomclown> (x) is of course, just x
22:22:55 <jle`> tuple with one element
22:23:01 <ReinH> the indistinguishable-from-a-1-tuple
22:23:02 <jle`> interesting concept
22:23:07 <jle`> python's tuples are immutable lists?
22:23:12 <jle`> right?
22:23:16 <jle`> if i recall correctly
22:23:16 <ReinH> And of course () is a 0-tuple
22:24:50 <jle`> ah they are immutable lists with tuple semantics
22:25:47 <lpsmith> wow, there's some solid improvements in object code size in GHC 7.8
22:26:07 <lpsmith> still a little embarrasing,  but definitely a move in the right direction
22:26:10 <randomclown> @pl \xs -> (f : xs, ())
22:26:10 <lambdabot> flip (,) () . (f :)
22:26:14 <randomclown> eh
22:26:21 <ion> lpsmith: How much of an improvement?
22:26:23 <levi> Is dynamic linking turned on, or is it just a smaller static binary?
22:27:00 <lpsmith> smaller static binary
22:27:05 <jle`> (,()) . (f:)
22:27:11 <jle`> eh
22:27:57 <lpsmith> ion:  I spent some time tweaking postgresql-libpq today,  optimizing for code size,  shaved off another 10 kilobytes or so
22:28:16 <ion> Out of how many megabytes? :-P
22:28:41 <lpsmith> compiling with ghc-7.7.20140110 shaved off 80 kilobytes
22:28:53 <lpsmith> ion:  617 kilobytes
22:28:57 <ion> ok
22:28:58 <jle`> i wish haskell/ghc could derive Enum for newtypes
22:29:11 <lpsmith> ion, that's still several times larger than libpq itself :-.
22:29:14 <lpsmith> :-P
22:29:28 <ion> heh
22:31:36 <enthropy> jle`: use -XGeneralizedNewtypeDeriving?
22:31:45 <jle`> enthropy: oh sweet
22:32:12 <jle`> :D
22:32:35 <lpsmith> anyway,  after the improvements I've moved from 617 -> 607 kilobytes on ghc-7.6,   and the dev version of GHC I happen to have installed,  it's gone from 524 -> 520 kilobytes.
22:33:10 <ion> That would almost fit in the RAM of an unexpanded Amiga 500.
22:33:55 <lpsmith> ion, the tweaks are mostly eliminating closures,  so it should be a small improvement in runtime,  due to fewer allocations and fewer indirect jumps.
22:34:00 <jle`> hm so basically i can derive anything that the wrapped type instances?
22:34:37 <lpsmith> yeah,  it's pretty mind-boggling how trivial that amount of RAM is these days.
22:35:21 <lpsmith> and how mind-boggling how completely impractical these code objects would be on machines of yesteryear.
22:36:00 <lpsmith> (or, for that matter,  embedded microcontrollers which might have anywhere from a few kilobytes to a few megabytes of RAM.
22:36:23 <lpsmith> and flash memory a few times larger than that.
22:37:02 <Fuuzetsu> yesod is impossible to install, the dependencies are just too much…
22:38:46 <lpsmith> ion,  I grew up on a C64,  an even more limited machine.   Although I know 64K was a living in absolute luxury compared to what some people in the haskell community cut their teeth on.
22:46:06 <levi> Fuuzetsu: Are you doing a cabal install of yesod-platform?
22:48:11 <Fuuzetsu> yes; well, for now I managed to get it to start compiling into a sandbox so I'll play with it there for now
22:48:17 <Fuuzetsu> even that came with difficulty
22:50:59 <Fuuzetsu> nowadays I end up spending more time inside cabal repl than I don't…
22:53:42 <Fuuzetsu> what's a good lib for using network sockets?
22:53:56 <johnw> I prefer network-conduit
22:53:58 <Fuuzetsu> in Java we'd import java.net.Socket and read/write to that
22:54:03 <Fuuzetsu> I'll have a look
23:00:19 <ion> lpsmith: :-) I wish i had a C64. It would have been cooler than the Amstrad CPC-464 with a monochrome display.
23:16:42 <supki_> Fuuzetsu: judging from Java docs Network{,.Socket} from network package is closer to java.net.Socket
23:17:02 <supki_> Fuuzetsu: but if you say "nice" then I'd second network-conduit suggestion ;)
23:21:03 <Fuuzetsu> Well, I can't say I'm particularly hung up on any Java interfaces, was just comparing to something I already know. network-conduit looks like it will do fine
23:22:00 <Twey> supki_: What's wrong with pipes-network?
23:39:03 <randomclown> Twey: I
23:39:07 <randomclown> I avoid conduit-network
23:39:11 <randomclown> and *-network
23:39:17 <randomclown> because they abstract away too much
23:39:32 <dabd> i installed hlint with cabal install hlint. When i run hlint the shell can't find the command. The wiki says it is installed locally by default but i don't know how to fix this http://www.haskell.org/haskellwiki/Cabal-Install#I_just_installed_packages.2C_but_now_the_packages_are_not_found
23:39:35 <randomclown> say I'm on pipes-network
23:39:52 <randomclown> and connection drops, what happens to the pipe?
23:40:04 <randomclown> how do I reconnect without making a mess
23:40:23 <randomclown> how do I control buffering to optimise my network
23:40:54 <randomclown> that's why you go `import Network`
23:41:18 <hellwolf> pythags4 = do
23:41:18 <hellwolf>   let z = [1..]
23:41:18 <hellwolf>   return z
23:41:24 <hellwolf> hello, everyone
23:41:40 <hellwolf> why would this:  print $ take 10 pythags4 be infinite? Thanks
23:41:51 <randomclown> > [1..]
23:41:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:42:00 <randomclown> hellwolf: I rest my case
23:42:04 <randomclown> wait
23:42:07 <hellwolf> I use take 10
23:42:11 <hellwolf> pythags2 = do
23:42:11 <hellwolf>   z <- [1..]
23:42:11 <hellwolf>   return z <-- this doesn't
23:42:21 <hellwolf> I am confused, what's going on here
23:42:33 <randomclown> well you are in a monad so there will be monadic effects
23:42:56 <randomclown> hellwolf: put a type signature on pythags4
23:43:26 <randomclown> :t do { let z = [1..]; return z }
23:43:27 <lambdabot> parse error on input `}'
23:44:16 <hellwolf> hmm :t pythags4 shows [[Integer]]
23:44:18 <hellwolf> but how
23:44:28 <ion> :t do { let { z = [1..] }; return z }
23:44:29 <lambdabot> (Enum t, Monad m, Num t) => m [t]
23:45:58 <randomclown> hellwolf: because you have that return z on the end
23:46:15 <randomclown> you have to understand that when you use do, you are involing a monad
23:46:40 <randomclown> and since (take 10) is expecting a list, it's assuming context to be a list monad
23:46:47 <randomclown> instead
23:47:00 <randomclown> pyargs2 = let z = [1..] in z
23:47:05 <randomclown> would give you the right type
23:48:31 <hellwolf> ok, thanks @randomclown for helping. I need to digest a little bit what's going on here though
23:48:44 <hellwolf> http://pastebin.com/An8zVjQb
23:50:29 <kbotnen> det smaker pepper av kaffien.
23:50:31 <kbotnen> wtf.
23:50:42 <Twey> hellwolf: Bind in the list monad is concatMap.  So when you use let z = [1, 2, 3]; return z you get z = [1, 2, 3], and then return z gives you [[1, 2, 3]].  However, when you invoke bind by using the <- syntax, you get, in turn, z = 1, then z = 2, then z = 3, so return z gives you first [1], then [2], then [3], and then the results are concatenated together
23:50:47 <kbotnen> wrong window, sorry.
23:50:59 <Twey> kbotnen: Sounds tasty
23:51:38 <kbotnen> the fact that my coffe tastes pepper, I think Ill go get myself a new cup :)
23:51:46 * hackagebot mi 0.0.1 - Multiple Instance for Haskell  http://hackage.haskell.org/package/mi-0.0.1 (matt)
23:52:02 <Twey> hellwolf: <- gives you the ‘extracted’ value in the remainder of the do-block, whereas ‘let’ binds exactly the value you give it.
23:52:56 <hellwolf> Twey, good explanation, cheers.
23:52:57 <Twey> hellwolf: And print $ take 10 [[1 ..]] executes forever because take 10 [[1 ..]] is [[1 ..]] and [1 ..] is infinite
23:53:45 * hellwolf signs that Monads are things that you could only understand yesterday, and goes back to emacs
23:55:46 <Fuuzetsu> pfft, leaving emacs
