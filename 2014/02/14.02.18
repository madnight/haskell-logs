00:06:51 <richo> Is there some neat way to execute a map and only return the last result?
00:07:09 <richo> right now I'm just doing last $ map <invocation>
00:07:16 <simpson> richo: What's wrong with that?
00:07:26 <richo> but I'm concerned that non strict application might wind up doing Not What I Want?
00:07:59 <aspidites> being naive by asking, i'm sure, but couldn't you just apply the function to the last element in the list?
00:08:11 <aspidites> or are you needing the rest for later application?
00:08:24 <richo> aspidites: I need everything applied. basically I"m using a hash instead of a alist
00:08:24 <fizbin> The only way that would happen is if the function you're mapping has side effects. Is the function you're mapping something like a -> IO b ?
00:08:42 <richo> so the old implementation I could just reduce with ++ to get the result
00:08:56 <richo> but now my func updates the hash in place, so I just need the last result which has all the results inserted
00:09:39 <aspidites> fizbin: why would it need to have side effects?
00:09:40 <fizbin> I do not understand "in place" in haskell. Are you working inside some sort of monad?
00:09:55 <richo> sorry, it's M.insert, so it returns the updated hash
00:10:10 <richo> in any case, it doesn't return anything I can usefully reduce with a binary operator
00:10:26 <aspidites> given a pure function foo, you can "foo $ last list
00:10:30 <fizbin> richo: Oh. Sounds like you want a foldl, not a map.
00:10:43 <fizbin> @type foldl
00:10:44 <lambdabot> (a -> b -> a) -> a -> [b] -> a
00:10:55 <richo> fizbin: I tried that, but foldl didn't seem to like the look of my invocation. I couldn't figure out how to make it work
00:11:06 <richo> so I figured I'd just write suboptimal code I would still understand tomorrow
00:13:08 <richo> Can someone tell me what I'm doing wrong with map and apply? I want to use apply to unpack my array as arguments to setVar: https://gist.github.com/eeb929d34eb28c9a3576
00:13:30 <fizbin> > foldl (\m (k,v) -> M.insert k v m) M.empty [("a", 1), ("m", 13), ("c", 3)]
00:13:31 <lambdabot>  fromList [("a",1),("c",3),("m",13)]
00:15:05 <kania> good morning
00:15:49 <fizbin> @type foldM_
00:15:51 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m ()
00:16:24 <richo> fizbin: Thanks! that's exactly what I wanted. Unpacking the args in an anon-function, no idea why it didn't occur to me :)
00:17:11 <fizbin> @type mapM_
00:17:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
00:18:52 <fizbin> richo: I think your line 4 should be: mapM_ (uncurry (setVar env)) bindings  followed by a line 5 of: return env
00:19:22 <richo> fizbin: I'm trying to make a foldl solution work, now that you basically showed me how
00:19:31 <richo> I'm still in type system hell, but I think I understand what's going on (more) now
00:24:44 <cbarrett> heh, found this edwardk post from 2005 http://www.mail-archive.com/haskell@haskell.org/msg17244.html
00:24:59 <cbarrett> edwardk: interestingly, this same paper is what got me interested in comonads as well
00:27:41 <eliasdiem> Hi. What's the "default" way of parsing a string for a double/number?
00:29:20 <Feuerbach> :t read
00:29:23 <lambdabot> Read a => String -> a
00:29:32 <Feuerbach> > read "123" :: Int
00:29:35 <lambdabot>  123
00:30:04 <fizbin> > read "123" :: Double
00:30:05 <lambdabot>  123.0
00:31:23 <lieven_> or readMay if you worry about parsing errors
00:38:57 <eliasdiem> thanks guys!
00:39:25 <richo> fwiw, I got it working. I butched an existing implementation I had and then made bindVars use foldM. Thanks!
00:52:15 <fizbin> Anyone familiar with advanced forall usage in types? http://lpaste.net/100095
00:53:07 <johnw> what's the question?
00:54:39 <Feuerbach> fizbin: look at the constraints package
00:54:47 <Feuerbach> and the Forall module in particular
00:55:25 <fizbin> johnw: The "even then I couldn't get it to work" at the bottom. How do I do that?
00:56:47 <fizbin> Feuerbach: Describing the documentation on http://hackage.haskell.org/package/constraints-0.3.4.2/docs/Data-Constraint-Forall.html as "minimalist" would be a vast overstatement.
00:56:58 <johnw> hmm
00:57:47 <Feuerbach> fizbin: agreed
00:57:53 <pdxleif> The language on this confuses me a lil. "Is Predicate a Functor?" - sounds like asking "Is Z a Group?" to me. In other words - huh? https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
00:57:56 <johnw> haha
00:58:16 <Feuerbach> there's an SO question where I give an example...
00:59:25 <Feuerbach> fizbin: http://stackoverflow.com/a/12718620/110081
01:05:01 <pjdelport> lole: http://hackage.haskell.org/package/bifunctors-4.1.1/docs/Data-Bifunctor-Clown.html , http://hackage.haskell.org/package/bifunctors-4.1.1/docs/Data-Bifunctor-Joker.html
01:05:43 <pjdelport> (sorry, that was intended for a different channel)
01:08:29 * hackagebot cpphs 1.18.1 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.1 (MalcolmWallace)
01:12:57 <keep_learning> Hello all
01:13:10 <keep_learning> I am trying to write a while language interpreter
01:13:11 <keep_learning> http://lpaste.net/100096
01:13:18 <keep_learning> but getting error.
01:13:32 <keep_learning> My problem is aExpression
01:13:56 <keep_learning> where I have problem
01:14:07 <keep_learning> iwhat to return.
01:14:36 <keep_learning> if I get string while parsing then I will return Var String :: AExpr String
01:14:57 <keep_learning> and when I have number then Num Integer :: AExpr Integer
01:15:11 <keep_learning> After doing little bit of search
01:16:04 <keep_learning> it's some how parametric polymorphism and I using forall we can solve the problem.
01:16:18 <keep_learning> but it seems like some thing is wrong with my concept.
01:16:31 <keep_learning> Could some one please tell me why
01:16:44 <keep_learning> the code is not working ?
01:16:51 <Feuerbach_> keep_learning: you cannot dynamically decide what type you will return
01:16:56 <Feuerbach_> based on the contents of your string
01:17:25 <Feuerbach_> types have to be known during the compile time
01:19:06 <keep_learning> Feuerbach: but after reading little bit about forall
01:19:21 <keep_learning> to me it seems like that it chose the appropriate type
01:20:14 <keep_learning> http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/
01:20:57 <Feuerbach> keep_learning: universal quantification says that you are able to return *any* type, not *some* type
01:21:09 <Feuerbach> for your case you'd need existential quantification
01:22:05 <Feuerbach> but it will probably defeat the purpose of your phantom type
01:22:59 <keep_learning> Feuerbach: means in this context once "any" is decided then it can't be changed ?
01:23:30 * hackagebot wai-route 0.1.1 - Minimalistic, efficient routing for WAI  http://hackage.haskell.org/package/wai-route-0.1.1 (romanb)
01:23:32 <Feuerbach> not sure what you mean
01:23:57 <Feuerbach> basically, no Haskell extension can let you know the future
01:24:14 <johnw> what about {-# LANGUAGE Prognostication #-}?
01:24:15 <Feuerbach> and at the compile time the contents of your string is in the future
01:24:37 <johnw> it sounds like keep_learning wants a dependently typed language
01:25:03 <keep_learning> johnw: I don't know but I am somehow thinking that
01:25:14 <keep_learning> forall will solve the problem :)
01:25:28 <Feuerbach> johnw: oh, nice, I didn't know about that one. Time to write a weather forecast app in Haskell :)
01:25:39 <keep_learning> It's very hard to grasp the concept of forall
01:28:25 <johnw> keep_learning: if you're on when shachaf is around, he's pretty strong in the ways of the forall
01:28:56 <keep_learning> johnw: Thank you
01:29:17 <johnw> it's not a way to get dynamic typing, though
01:29:49 <merijn> Which forall are we talking about? ExistentialQuantification, RankN, or SCTV? :p
01:34:21 <shachaf> It's all the same forall.
01:34:56 <merijn> shachaf: Sure, but I wouldn't explain it in the same way for each of those contexts
01:35:09 <shachaf> (Why am I being volunteered here?)
01:35:41 <johnw> because you're pretty good at discerning the subtleties of forall usage
01:36:30 <Feuerbach> shachaf: I wouldn't say that existential and universal foralls are the same. The concepts are rather different (although there are connections, of course).
01:37:17 <Feuerbach> I'd even say that their conflation in Haskell syntax is unfortunate
01:37:38 <shachaf> They're not really conflated.
01:37:49 <Feuerbach> I mean, they use the same keyword
01:38:05 <shachaf> It's unfortunate (and slightly bizarre) that many people independently get idea "forall = existential type".
01:38:18 <Hafydd> It like they've never even heard of predicate logic.
01:38:42 <shachaf> But I don't mind the way the syntax works.
01:38:56 <shachaf> Can you think of an obvious way to improve it?
01:39:22 <Feuerbach> well, there's the GADT syntax that doesn't need foralls to introduce existentials
01:39:36 <shachaf> Well, the foralls are just implicit there.
01:39:41 <Feuerbach> yes
01:40:01 <Feuerbach> I'm specifically against using forall to create existential types
01:40:10 <Feuerbach> because it's confusing for beginners
01:40:21 <shachaf> Are you also against data Foo a = Show a => Blah a?
01:40:38 <shachaf> (I mean, the syntax, not that particular type.)
01:41:52 <Feuerbach> probably not. I think it rarely used, so hard to say if it's confusing for beginners
01:41:57 <Feuerbach> *it's
01:42:55 <quicksilver> Feuerbach: "I wouldn't say that existential and universal foralls are the same"
01:42:57 <quicksilver> why not?
01:42:59 <quicksilver> they are the same
01:43:02 <quicksilver> there is only one forall.
01:43:22 <quicksilver> it might be considered a baroque syntactical trick by which forall creates an existential type
01:43:26 <quicksilver> but it's still the same forall
01:43:44 <shachaf> Short of GADTs -- which are a reasonable answer, if a bit extreme to use for all data types -- how would you prefer existential types to be defined?
01:44:17 <Feuerbach> data Foo = Foo a ?
01:45:52 <keep_learning> Hello everyone
01:45:56 <keep_learning> My problem is
01:46:02 <keep_learning> similar to http://comments.gmane.org/gmane.comp.lang.haskell.beginners/13051
01:46:20 <keep_learning> and some it boils down ot
01:46:30 <keep_learning> to* existential
01:46:44 <keep_learning> but I am still not able to figure out
01:47:29 <maybefbi> is there a nice little category theory object that behaves like this: http://lpaste.net/100097
01:48:14 <Axman6> anyone know if there's a portable function to convery something in little/big engian into native endian (being id where appropriate for each system)
01:48:56 <shachaf> OK, I guess that's magical in roughly the same way GADT forall is magical.
01:49:12 <maybefbi> Axman6, are we talking bytestring -> bytestring
01:49:32 <Axman6> no, Int/Word -> Int/Word
01:49:48 <Axman6> specifically whatever the result of peek on a certain memory location will be
01:49:53 <shachaf> Seems reasonable to me. But in both cases I don't object to the forall being explicit.
01:50:04 <Axman6> (so it's LE on x86)
01:50:40 <shachaf> Why are you peeking on a memory location?
01:50:45 <skypers_> hi
01:51:15 <Axman6> binary parser monad I'm writing
01:51:25 <skypers_> I have a tagged value (using plain and old phantom types), and I’d like to compute a different value regarding such a phantom types
01:51:26 <merijn> keep_learning: The short answer is: That's really difficult to do
01:51:34 <skypers_> I tried using GADTs, but it’s annoying
01:51:38 <skypers_> now
01:51:47 <Feuerbach> shachaf: my point is, the existential forall is equally magical (syntactically speaking). Its use before the constructor doesn't follow in any way from the syntax of RankNTypes. But in addition to that, it's also confusing
01:51:48 <merijn> It needs ImpredicativeTypes which I'm repeatedly told are broken in GHC
01:51:53 <maybefbi> Axman6, it would be possible to write an instance of Data.Bits a
01:51:54 <skypers_> I have the type like data Uniform a = Uniform { nothingToDoWithA }
01:51:57 <skypers_> and a class
01:52:09 <skypers_> in which I can return something different for a different a
01:52:14 <skypers_> do you know a better way?
01:52:39 <Axman6> maybefbi: I might leave it for now, currently things are in the right endianess for me
01:52:50 <maybefbi> ok
01:52:50 <Axman6> but it'd be nise to work on big endian systems too
01:53:15 <maybefbi> Axman6, implement this: changeToSystemEndian :: (Data.Bits a) => a -> a
01:53:27 <Feuerbach> skypers_: you could use Data.Proxy or Data.Tagged from the tagged package instead, if you like
01:53:33 <maybefbi> Axman6, use the functions inside Data.Bits
01:53:49 <maybefbi> Axman6, to implement changeToSystemEndian
01:53:52 <skypers_> do they provide a way to pattern match on the type?
01:53:56 <skypers_> on the tag, I mean
01:53:59 <Axman6> sure, I just wanted to know if it already existed in a more optimised form
01:54:10 <skypers_> the thing is, it’s just for one function that I need that
01:54:12 <skypers_> in other cases
01:54:18 <skypers_> the phantom type is not required
01:54:30 <maybefbi> Axman6, read Hackers Delight by MIT Press. they have it using the functions inside Data.Bits
01:54:39 <keep_learning> merijn: is there any way to do this ?
01:54:40 <maybefbi> Axman6, very optimal
01:54:48 <skypers_> I plan to use such phantom type later in a EDSL
01:55:12 <skypers_> up to know all computations using this type don’t care about the phantom type
01:55:13 <keep_learning> merijn: I have written the parser for https://github.com/mukeshtiwari/whileinterpreter/blob/master/src/Parser.hs
01:55:15 <keep_learning> and it works fine
01:55:25 <skypers_> so I don’t want to split them up and pattern match the 16 ctors…
01:55:30 <Axman6> maybefbi: yeah I've got the eBook
01:55:47 <keep_learning> but I saw this https://gist.github.com/curiousleo/5427396
01:55:59 <maybefbi> Axman6, bet there is section for this. gimme a sec let me download it on this machine
01:56:01 <merijn> keep_learning: The problem you have is that your type claims to return "Expr a", which means that *I*, the caller get to decide which 'a' you return
01:56:18 <merijn> keep_learning: i.e. I can say "I want a 'Expr Bool'" and your parser has to give me that
01:56:23 <merijn> keep_learning: But that's not what you intend
01:56:29 <Axman6> maybefbi: I can find it
01:56:45 <merijn> keep_learning: You intended to write a parser that returns *some* "Expr a", and I don't get to pick which
01:57:14 <merijn> But, as I said this requires impredicative types, which according to what people tell me every time I want them, don't work in GHC
01:57:25 <maybefbi> Axman6, chapter 7 section 1
01:58:20 <maybefbi> Axman6, use that to implement changeToSystemEndian :: (Data.Bits a) => a -> a
01:58:57 <keep_learning> merijn: but should not the inside forall a force to chose both Bool and Int  based on context
01:59:24 <merijn> keep_learning: You can't write a type for that
01:59:33 <keep_learning> I mean it should keep in mind that may be in future I can encounter either Var Sring or Num Int
01:59:44 <merijn> keep_learning: No, it can't
01:59:50 <merijn> keep_learning: How would it know which would happen?
02:00:02 <maybefbi> Axman6, http://n-pn.info/repo/Hailass/security/Addison%20Wesley%20-%20Hackers%20Delight.pdf
02:00:09 <merijn> keep_learning: Haskell doesn't let you write functions that work on "sometimes String, sometimes Int"
02:00:39 <Axman6> maybefbi: I've already go ti, I plan to get the dead tree version soon though
02:01:03 <tdammers> merijn: it does, but you have to make it explicit
02:01:04 <merijn> It's my main problem with GADTs, you can't deserialise GADTs with phantom types nicely
02:01:06 <maybefbi> Axman6, nice. it is a good book to have on desk
02:01:22 <Axman6> yep
02:01:38 <merijn> tdammers: Only as an argument, you can't return a type like that without impredicative types
02:01:53 <tdammers> merijn: have to wrap them, yes
02:01:54 <merijn> tdammers: i.e. you can't write "Parser String (forall a . Expr a)"
02:02:00 <tdammers> indeed
02:02:02 <merijn> And I want that so badly :(
02:02:13 <tdammers> write that parser in PHP
02:02:15 <keep_learning> merijn: so could you please tell me http://comments.gmane.org/gmane.comp.lang.haskell.beginners/13051 what Brent mean by this "existentially hides the expression type"
02:02:16 <tdammers> :(
02:02:34 <merijn> tdammers: Why, it's perfectly possible to type check that just fine
02:03:15 <merijn> keep_learning: Yes, he means you have to wrap it existentially to hide the type parameter i.e. turn "Expr a" into "Expr"
02:03:20 <tdammers> my gut feeling says you have to make concessions elsewhere to keep the type system consistent and unambiguous
02:03:32 <tdammers> haven't really thought it through though
02:03:34 <merijn> tdammers: Wrapping it existentially means you lose the entire benefit of using a GADT + phantom type in the first place
02:03:46 <merijn> tdammers: Well, there is a -XImpredicativeTypes
02:04:08 <keep_learning> merijn: then in that case type variable a can take both values Bool and Int depend on context ?
02:04:48 <merijn> keep_learning: No, you effectively eliminate the type variable
02:05:11 <merijn> keep_learning: "But doesn't that mean you lose all the nice static guarantees of having that extra type variable?" 'Yes, yes it does.'
02:06:48 <keep_learning> merijn: So no advandage of using GADT if I am using the given method ?
02:07:17 <keep_learning> merijn: Any idea how I can wrap this idea of forall ?
02:07:38 <keep_learning> I studied little bit of System F and came to know that
02:07:46 <keep_learning> when we use forall then
02:07:54 <keep_learning> caller don't chose the type
02:08:07 <merijn> keep_learning: But you didn't use forall
02:08:08 <keep_learning> but callee decides itself what type to chose
02:08:28 <merijn> keep_learning: And the only way you *can* use it is using a GHC extension that isn't not well-tested or maintained
02:08:51 <keep_learning> merijn: aExpression :: Parser (  forall a. AExpr a )
02:09:14 <merijn> keep_learning: Oh, my bad, I was looking at the mailing list one
02:09:31 <merijn> keep_learning: That is the right forall, but requires aforementioned unstable extension, so you're still boned
02:10:25 <keep_learning> merijn: Mean the caller of aExpression will not chose the type
02:10:38 <keep_learning> merijn: but callee will decide
02:10:39 <keep_learning> ?
02:11:03 <merijn> keep_learning: You are theoretically right, but in practice you still can't do it
02:11:42 <keep_learning> merijn: :) At least I got something correct ( concept ).
02:11:55 <keep_learning> merijn: GHC is asking me put LiberalTypeSynonyms,ImpredicativeTypes
02:12:05 <keep_learning> but even these are also not helping
02:13:10 <merijn> keep_learning: I just told you need ImpredicativeTypes, but it's broken so the short answer I gave you 10 or so minutes ago is "You can't"
02:13:33 <keep_learning> merijn: Thank you for your time.
02:13:35 <merijn> keep_learning: Nothing is helping you, because nothing *can* help you
02:13:36 * hackagebot shakespeare 1.2.1.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.2.1.1 (MichaelSnoyman)
02:13:38 * hackagebot yesod-platform 1.2.7.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.7.1 (MichaelSnoyman)
02:13:45 <merijn> Well, other than hacking GHC to make it work :)
02:14:06 <keep_learning> merijn: No problem. At least the concepts correct although little bit
02:14:11 <Ikarus> I keep forgetting, is it possible to define a type that is allowed to be a Char or the symbol Foo ?
02:14:26 <merijn> keep_learning: The closest possible thing you can do is the following
02:14:50 <startling> Ikarus, data Ikarus = Some Char | Foo
02:15:25 <merijn> "(forall a . Expr a -> b) -> Parser String b" (or similarly: "(forall a . Expr a -> Expr b) -> Parser String (Expr b)")
02:16:10 <merijn> keep_learning: i.e. use a RankN function on the Impredicative Type immediately to turn it into a non-impredicative type and return that
02:18:25 <keep_learning> merijn: Thank you. I will try it.
02:25:44 <Ikarus> *sigh* according to ghci the impossible has happend
02:27:51 <Axman6> @hoogle Decoder
02:27:52 <lambdabot> package decoder-conduit
02:27:52 <lambdabot> GHC.IO.Encoding.Types mkTextDecoder :: TextEncoding -> IO (TextDecoder dstate)
02:27:53 <lambdabot> GHC.IO.Encoding mkTextDecoder :: TextEncoding -> IO (TextDecoder dstate)
02:38:06 <Ikarus> startling: no matter what I do with that, this doesn't make 'a' match the type Ikarus as in your example, and I am forgetting something really obvious, I know
02:40:44 <startling> Ikarus, what 'a' are you talking about?
02:40:57 <startling> oh.
02:41:06 <startling> Ikarus, you need to use the constructor.
02:41:13 <startling> Ikarus, 'Some' in that example.
02:41:29 <Ikarus> startling: ah, silly me
02:41:29 <startling> Ikarus, Some 'a' :: Ikarus
02:41:39 <Ikarus> startling: see, I always forget the bleeding obvious
02:41:47 <Ikarus> been out of Haskell for a bit
02:42:53 <joneshf-laptop> hmm
02:43:32 <joneshf-laptop> how can i try one parser, and if it fails try another parser, if they have different types?
02:43:39 <joneshf-laptop> aside from explicit pattern matching
02:44:00 <ezyang> What would you like the type of the combined parser to be?
02:44:09 <joneshf-laptop> whichevery one succeeds
02:44:26 <Axman6> ...
02:44:28 <joneshf-laptop> s/whichevery/which ever/
02:44:30 <Axman6> that's not well typed
02:45:00 <ezyang> OK, posed differently, if you put a hole int he place of where you're going to use the parser, what is the type of the hole?
02:45:19 <Axman6> joneshf-laptop: what type should tryElse (a :: Parser a) (b :: Parser b) have?
02:46:02 <tdammers> tryElse :: Parser a -> Parser b -> Parser (Either a b)
02:46:04 <tdammers> :D
02:46:13 <Axman6> exactly ;)
02:46:18 <joneshf-laptop> har
02:46:44 <Axman6> the result can't be 'whichever one succeeds'
02:48:25 <joneshf-laptop> well it's within an `InputT IO ()` loop, so I really don't care what it ends up parsing as, just need to handle whichever was given by the user
02:48:30 <joneshf-laptop> so i can branch and do soemthing with it
02:48:44 <ezyang> ah, tack a >> return () to the parser
02:48:52 <Axman6> yeah
02:48:58 <Axman6> beat me to it
02:49:10 <joneshf-laptop> cool, i'll try that
02:50:13 <Axman6> well, to each of the parsers you're trying to run
02:52:08 <merijn> or prefix them with "void $"
02:53:40 * hackagebot yesod-dsl 0.1.1.11 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.11 (TeroLaitinen)
02:54:14 <zipper> Someone help with this IO issue. ./temp7136: openFile: resource busy (file is locked) https://gist.github.com/urbanslug/9068543
02:54:47 <zipper> I guess I tried accessing a file while it was already in use but I don't see that happening anywhere.
02:57:11 <joneshf-laptop> hmm, tat didn't really work
02:57:20 <zipper> joneshf-laptop: Mine?
02:57:27 <joneshf-laptop> here's what i'm trying to avoid: http://lpaste.net/100103
02:58:12 <Axman6> yeah that definitely does not seem like the right way to do it
02:58:29 <zipper> Axman6: Who are you talking to?
02:58:42 <Axman6> I'm talking to joneshf-laptop
02:59:09 <zipper> Someone help with this IO issue. `./temp7136: openFile: resource busy (file is locked)' https://gist.github.com/urbanslug/9068543
02:59:55 <Axman6> zipper: please don't keep repearing your question. if someone has an answer for you, they'll give it to you. but remember, it's not our job
03:00:16 <zipper> FML
03:00:32 <Axman6> is, perhaps, the file you're trying to open locked?
03:01:56 <joneshf-laptop> maybe it's time to sleep
03:02:12 <zipper> Axman6: That's what the error says but I don't see it anywhere.
03:02:13 <joneshf-laptop> i'm pretty sure that's not helping me think straight
03:02:13 <Axman6> joneshf-laptop: which parsing combinator are you using?
03:02:47 <frihd_> zipper:  i bet this is lazy IO
03:02:54 <troydm> what's the quickest way to create an cabal package?
03:03:05 <dcoutts_> cabal init
03:03:05 <troydm> i don't see any cabal create command
03:03:11 <troydm> ohh
03:03:18 <troydm> should i first create a directory?
03:03:24 <zipper> frihd_: It's not something in my code?
03:03:31 <troydm> or it  doesn't works the same way maven does
03:03:58 <dcoutts_> troydm: yes, make a dir, cd into it. If you have any code already, add it to that dir etc.
03:04:17 <dcoutts_> troydm: see the quick start guide in the Cabal user guide
03:04:36 <troydm> dcoutts_: ic, thx
03:04:48 <troydm> dcoutts_: thought there was some tool that does that for you
03:04:54 <troydm> but i guess i was wrong
03:06:42 <joneshf-laptop> Axman6, `Parsec String u Foo` and `Parsec String u Bar` in the example
03:06:47 <frihd_> zipper yes (in the sense you can fix it) and no (in the sense it's not intuitive)
03:06:49 <joneshf-laptop> Axman6, so theyre supposed to parse data types
03:06:56 <dcoutts_> troydm: that makes the dir? no. The assumption is you probably already have a simple version of your code and you're making it into a package (though having code already is not needed)
03:07:04 <frihd_> look at this thread http://stackoverflow.com/questions/5053135/resource-busy-file-is-locked-error-in-haskell ; no time to run your code zipper :o
03:07:12 <Axman6> joneshf-laptop: parserFoo <|> parserBar should work I think
03:07:18 <Axman6> @hoogle <|>
03:07:20 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:07:20 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:07:20 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:07:25 <Axman6> uh, no
03:07:34 <joneshf-laptop> yeah
03:07:38 <joneshf-laptop> don't worry about ti too much
03:07:44 <joneshf-laptop> i thought there was a simple thing i was missing
03:07:48 <Axman6> joneshf-laptop: (parserFoo >> return ()) <|> (parserBar >> return ()) should work I think
03:08:38 <joneshf-laptop> :t (string "a" >> return ()) <|> (char 'a' >> return ())
03:08:41 <lambdabot>     Not in scope: `string'
03:08:41 <lambdabot>     Perhaps you meant one of these:
03:08:41 <lambdabot>       `storing' (imported from Control.Lens),
03:08:46 <joneshf-laptop> bleh
03:08:59 <joneshf-laptop> hmm
03:09:08 <joneshf-laptop> :m + Text.Parsec
03:09:14 <joneshf-laptop> :t (string "a" >> return ()) <|> (char 'a' >> return ())
03:09:15 <lambdabot>     Not in scope: `string'
03:09:15 <lambdabot>     Perhaps you meant one of these:
03:09:15 <lambdabot>       `storing' (imported from Control.Lens),
03:09:18 <joneshf-laptop> ah well
03:10:34 <joneshf-laptop> well, but how do i do anything with what was parsed?
03:10:50 <joneshf-laptop> because i'll be geting back a unit
03:11:00 <Axman6> I thought you said you didn't need what was parsed
03:11:01 <joneshf-laptop> but i want the parsed value
03:11:17 <joneshf-laptop> no, i need it, i just dont care which of the two it is
03:11:30 <Axman6> (fmap Left $ parserFoo) <|> (fmap Right $ parserBar)
03:11:31 <joneshf-laptop> it's a choice point in the loop
03:11:47 <Axman6> well, they're different types, so you have to care...
03:12:44 <Axman6> :t (fmap Left $ return 1) <|> (fmap Right $ return "hello")
03:12:45 <lambdabot> (Monad f, Num a, Alternative f) => f (Either a [Char])
03:14:50 <joneshf-laptop> i dunno, i think we might just have to rethink this whole section of the loop
03:15:03 <joneshf-laptop> ah well, thanks for thehelp
03:15:04 <joneshf-laptop> night
03:25:36 <Axman6> hmm, I'm not sure what to name my strange parser library. the parser is called Decoder, works on ByteStrings as input and output. Data.Decoder seems like not a good name, but I can't think what to put between
03:28:13 <Axman6> Perhaps Data.ByteString.Decoder
03:52:37 <zipper> frihd_: Turns out my issue wasn't laziness but I had openTempFile had opened the file after creating it and I had to close it before writing to it. https://gist.github.com/urbanslug/9068543
03:54:13 <mornfall> zipper: that creates a race though
03:54:54 <mornfall> zipper: there's a good reason why openTempFile gives you a handle
03:55:36 <merijn> zipper: That's wildly unsafe
03:55:40 <mornfall> zipper: use hPutStr instead of writeFile
03:55:56 <merijn> Why are you opening a TempFile before you need it anyway?
03:57:59 <cokea> Sup
03:58:02 <cokea> Is there anyone from India here?
03:58:44 <quchen> "hClose tempHandle --So that we can later write to it because it is open."
03:58:46 <quchen> Huh?
04:00:05 <quchen> `add` should take a (String, String) or String -> String, not [String]
04:00:19 <quchen> view should take a String, not a [String]
04:00:42 <quchen> main should handle emty cmd args
04:00:56 <quchen> main should handle Nothing in the let binding
04:02:27 <quchen> zipper: ^
04:04:38 <quchen> I wonder why there is no withTempFile. merijn?
04:04:55 <quchen> Am I overlooking something that prevents lazy IO craziness here?
04:15:28 <merijn> quchen: No clue, historical reasons? I'd just use bracket
04:17:59 <quchen> merijn: That wouldn't help I think. It would make sure the handle is closed for sure, but not that all data is written before.
04:18:48 * hackagebot http-conduit 2.0.0.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.0.0.6 (MichaelSnoyman)
04:19:52 <merijn> quchen: With lazy IO you can't be sure data is written anyway
04:20:03 <merijn> quchen: The simple answer is: Don't use lazy IO :p
04:20:28 <quchen> merijn: Using withFile you're guaranteed the data is written before closing the handle, no?
04:20:56 <quchen> Hmm wait,  withFile name mode = bracket (openFile name mode) hClose
04:21:08 <merijn> quchen: No
04:23:05 <quchen> Okay, before this explodes into a "fixing lazy IO riddle" type of conversation I'll just go back to using pipes :-)
04:23:12 <quicksilver> merijn: the standard libraries have no lazy writing
04:23:21 <quicksilver> so that's not really true
04:23:44 <quicksilver> "lazy" IO is IO "on-demand"
04:23:50 <quicksilver> writing can't really be demanded later
04:24:19 <quicksilver> although of course you can imagine reasons to defer and batch writing, and OSes, filesystems, and firmware all do that
04:24:19 <merijn> Ah, I guess, yeah
04:24:28 <quicksilver> but that's not a haskell issue :)
04:36:06 <k_bx> l
04:36:28 <k_bx> Hi everyone! For some reason, exception is not being masked here http://lpaste.net/100104 Please help me figure out. Thanks!
04:38:34 <k_bx> (updated to show output)
04:39:03 <Feuerbach> k_bx: blocking operations are interruptable
04:39:12 <Feuerbach> (such as threadDelay)
04:39:27 <Feuerbach> is that what you're asking about?
04:39:34 <k_bx> Feuerbach: hmm, I see. I think yes!
04:39:55 <k_bx> Feuerbach: are networking operations interrupttable, like if I need to acquire some resource that involve IO action?
04:40:24 <Feuerbach> they are interruptible only when they block
04:40:35 <Feuerbach> i.e. if you're waiting for input, you can be interrupted
04:40:51 <Feuerbach> if the data is available, then you won't be interrupted (I think)
04:43:01 <k_bx> Feuerbach: very interesting, thank you! I'll try uninterruptableMask
04:43:54 <k_bx> Yup, uninterruptible one did the job as I expected.
04:44:13 <quicksilver> it seems to me that this isn't documented properly :(
04:44:23 <quicksilver> http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html is a maze of interlinks
04:44:29 <quicksilver> none of which actaully contain the whole story
04:45:09 <k_bx> quicksilver: it seems to me this may lead to potential leaks, like if you press Ctrl+C when request to open a new db transaction was sent, but you still wait for a network response, but I'm not an expert here.
04:46:00 <quicksilver> that kind of leak is pretty much endemic in unix like OSes
04:46:14 <Feuerbach> what would leak in that case?
04:46:16 <quicksilver> the notion that "you can just kill a process and things will get tidied up"
04:46:21 <quicksilver> is rather ingrained
04:46:34 <Feuerbach> db will eventually drop the connection after timeout
04:46:34 <k_bx> Feuerbach: well, you would not call "cleanup / close" action in this case
04:46:36 <quicksilver> and if you have examples of resources which aren't automatically cleaned up on process death you need to be very careful.
04:46:56 <waidmann> :wq
04:47:18 <k_bx> Feuerbach: if you use bracket openTransaction doStuff closeTransaction , in this situation it may be opened, but not closed. But I'm not 100% sure.
04:47:44 <Feuerbach> well, if openTransaction is *transactional*, everything is fine
04:47:58 <Feuerbach> (e.g. if it's an atomic stm action)
04:48:13 <Feuerbach> if not, then inside openTransaction you have to take care of exceptions, too
04:48:17 <k_bx> Feuerbach: I mean if it does some blocking network-request
04:48:49 <k_bx> Yeah, anyway thanks, I'll need to rethink all those exceptions now a bit :)
04:49:31 <Feuerbach> k_bx: yw. Be sure to read SimonM's book :)
04:51:12 <k_bx> Feuerbach: I have it on my list just after I finish Mr. Okasaki's work
04:58:52 <b80905> what does the operator >>= do?
04:59:43 <Hafydd> It binds a value of a Monad instance to a function returning a value of the same type, in an instance-specific way.
04:59:57 <Hafydd> And hopefully one obeying the Monad axioms.
05:00:16 <b80905> Hafydd: how do you call it?
05:00:17 <quchen> The value can be of a different type.
05:00:25 <quchen> m a -> (a -> m b) -> m b
05:00:28 <Hafydd> Oh... yes.
05:00:35 <quchen> The Monad has to be the same though.
05:00:43 <Feuerbach> b80905: we call it "bind"
05:00:56 <quchen> b80905: Have you read the LYAH chapter on monads?
05:01:19 <b80905> quchen: no
05:01:31 <Hafydd> For IO, it produces an IO computation that performs the right-hand function given the value produced by the left-hand value.
05:03:03 <quchen> b80905: I don't think >>= can be explained in a few lines so that you understand it. Monads have no good analogies, and the mathematically correct ways of understanding them aren't very practical in the beginning. You'll need to develop some intuition about them, and the LYAH chapter might be a good start (same for the rest of LYAH).
05:03:08 <quchen> Also this: https://github.com/quchen/articles/blob/master/fbut.md#i-dont-understand-monads
05:03:51 <Aetherspawn> dcoutts: not really interested in writing a patch for it, sorry. It was a ticket on behalf of some guy who came on here a month or so ago and complained his downloads were all wonky
05:04:19 <dcoutts> Aetherspawn: thank's for filing it
05:05:00 <dcoutts> Aetherspawn: tbh, download numbers are always going to be a bit wonky
05:05:12 <dcoutts> so many ways to under and overcount
05:05:29 <Aetherspawn> yeah, it's always going to be hard to get an accurate "user count"
05:05:41 <quchen> dcoutts: Are you talking about Hackage download counters?
05:05:56 <Aetherspawn> this: https://github.com/haskell/hackage-server/issues/184
05:06:06 <dcoutts> quchen: right
05:06:38 <quchen> I was wondering what they actually count the other day. Cabal installs? HTTP downloads? Viewing the directory listing?
05:06:52 <Hafydd> "getLine >>= (\line -> return $ map toUpper line) >>= putStrLn" is an example of >>= for IO.
05:07:01 <dcoutts> quchen: what we display on the site to users is the http downloads in the last 30 days
05:07:04 <quchen> The numbers seemed pretty low, I was expecting a lot more
05:07:20 <dcoutts> quchen: we just got a patch to also display all-time downloads
05:07:35 <quchen> dcoutts: Aah. Maybe that should be mentioned somewhere. I heard the "wow, nobody really uses Haskell, here are the numbers from your own site" a couple of times now.
05:07:58 <quchen> Oh, nevermind then :-)
05:07:59 <Hafydd> Or, shorter, "getLine >>= return . map toUpper >>= putStrLn"
05:08:08 <dcoutts> quchen: and we have more info internally but we don't display it all
05:08:17 <khyperia> Hafydd, note, whenever you have "thing >>= return . something" you probably actually want to write "fmap something thing"
05:08:31 <Hafydd> Ah, yes.
05:09:23 <khyperia> or "getLine >>= putStrLn . map toUpper"
05:09:53 <Hafydd> But that doesn't demonstrate as well how >>= can build a computation pipeline.
05:09:58 <khyperia> yeah, heh
05:10:13 <khyperia> perhaps "getLine >>= readFile >>= putStr"
05:14:24 <quchen> dcoutts: What's that internal information?
05:14:32 <quchen> The full log of download+time?
05:15:00 <pranz> why does "cabal run" take so much longer than just running the executable manually?
05:30:17 <jarmar> hi, i have a problem with cabal where i have a sandbox, i am able to do install --only-dependencies without errors, but when i compile i still run into type errors with mismatching bytestrings. what am i missing?
05:30:44 <merijn> jarmar: Mismatching type error with ByteString sounds like mixing strict and lazy ByteStrings
05:32:11 <zebr> hi all. does anyone know of any results on a typed lambda calculus with rational types (i.e. like simply-typed lambda calculus but without occurs checks at type unification)?
05:35:13 <zebr> ah, found some results just calling them 'recursive types'. turns out you can make a Y combinator.
05:38:56 * hackagebot fb 0.15.0 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.15.0 (FelipeLessa)
05:43:56 * hackagebot fb 0.15.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.15.1 (FelipeLessa)
05:48:56 * hackagebot bert 1.2.2.1 - BERT implementation  http://hackage.haskell.org/package/bert-1.2.2.1 (RomanCheplyaka)
05:48:58 * hackagebot fb-persistent 0.3.2 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.3.2 (FelipeLessa)
05:49:20 <jarmar> merijn: thank you, that seems to have been it. now i'm a bit frustrated that packages don't declare in an obvious way which type of bytestrings they are using..
05:51:44 <quchen> When building multiple executables from the same code base (i.e. only the main modules differ), each executable has to list all the dependencies, which creates a lot of redundancy in the .cabal file. How good of an idea would it be to build the entire codebase into a library, and then provide tiny main modules ("main = RealMain.main") that depend only on Base and that library?
05:52:01 <quchen> It's essentially factoring out the absolutely necessary parts of the executables.
05:52:08 <dcoutts> quchen: you can do that within the one .cabal file
05:52:11 <supki> jarmar: what would be more obvious than a type signature?
05:52:29 <quchen> dcoutts: Yes, I know. I was just wondering whether that's a good idea to do.
05:52:38 <merijn> quchen: Define a library for the common core of your executables and use that as dependency for the executables?
05:52:51 <merijn> quchen: You can define said library in the same cabal file as the executables
05:53:11 <skypers_> hi
05:53:18 <skypers_> I’m creating an EDSL for my GPU shaders
05:53:30 <skypers_> I can do that :
05:53:32 <merijn> supki: The type signature usually just lists "ByteString" and you have to mouseover the link to see which it is
05:53:41 <quchen> merijn: Yes, my current plan is writing "main" modules in the library that export only a "main" function.  These will be the only exposed modules by the library.  The actual main modules for the executables could be tiny then, with minimal dependencies.
05:53:46 <skypers_> GConst 1 + GConst 4 * GConst 3
05:53:51 <skypers_> it will output that:
05:53:55 <skypers_> 1 + 4 * 3
05:54:04 <skypers_> now I want it to output (1 + 4) * 3
05:54:10 <skypers_> I have a GParens ctor for the Expr type
05:54:16 <skypers_> but I don’t know how to mix it with Num
05:54:18 <skypers_> any idea?
05:54:41 <skypers_> I can parens everything, but is it a good idea?
05:54:46 <supki> merijn: well, that's arguably a haddock bug
05:55:09 <quicksilver> skypers_: you either have to parens everything or you have to enrich your datatype to encode "current level of precedence"
05:55:26 <quicksilver> skypers_: so that it knows whether or not at add parens depending on the next operator.
05:55:50 <skypers_> quicksilver: what do you mean?
05:56:08 <skypers_> how would I differentiate 1 + 3 * 4 and (1 + 3) * 4?
05:56:14 <osa1> how can I configure cabal so that cabal repl loads modules for an executable defined in the cabal file?
05:56:21 <jarmar> supki: from the source it is (relatively) obvious, but looking at the haddock it just says ByteString everywhere, which suggests to a beginner that there is only one type of ByteString or at least that any different types are compatible.
05:56:25 <quicksilver> skypers_: they're completely different
05:56:33 <dcoutts> osa1: cabal repl <component>
05:56:34 <skypers_> well
05:56:40 <quicksilver> skypers_: one is GTimes (GSum 1 3) 4
05:56:55 <quicksilver> skypers_: and the other is GSum 1 (GTimes 3 4)
05:57:02 <quicksilver> apologies for guessing at your constructor names.
05:57:06 <osa1> thanks.
05:57:14 <quicksilver> there is no question of your EDSL confusing them
05:57:15 <skypers_> In term of combinators, quicksilver
05:57:20 <osa1> (actually I was already trying this but apparently I had a typo in <component> part)
05:57:31 <quicksilver> the question is - how much work are you prepared to do to make the pretty-printer not display unneeded parens?
05:57:45 <quicksilver> skypers_: have a look at the docs for 'showsPrec' and 'showParen'
05:57:48 <skypers_> GConst 1 + GConst 3 * GConst 4 => 1 + 3 * 4, this is ok
05:57:55 <quicksilver> skypers_: (which is how the standard deriving Show code does this)
05:57:58 <skypers_> I’d also like to go with
05:58:05 <skypers_> (GConst 1 + GConst 3) * GConst 4 => (1 + 3) * 4, this is ok
05:58:20 <supki> jarmar: you can't do much about it as a package author, unfortunately
05:58:21 <skypers_> or I can use a little function for that
05:58:57 * hackagebot skein 1.0.9 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.9 (FelipeLessa)
05:59:09 <skypers_> I have a combinator, $., that does the same thing $ does
05:59:13 <skypers_> but for my GExpr
05:59:21 <skypers_> then
06:00:52 <joschka> Real World Haskell, just arrived, I can't wait to digg in, which me luck! :)
06:01:28 <jarmar> supki: i guess not. i suppose it could be written into the description, but once you've run into this problem once i guess you'll check the source each time anyway. :)
06:02:32 <skypers__> quicksilver: ok so it has nothing to do with my EDSL then?
06:03:56 <quicksilver> skypers__: no, not raelly, it's just something to do with you how pretty print it.
06:04:06 <skypers__> ok
06:04:07 <quicksilver> skypers__: your abstract syntax tree is not ambigous
06:04:10 <skypers__> good then
06:04:16 <skypers__> yes
06:04:16 <quicksilver> it knows whether it's * or + at the top
06:04:19 <skypers__> I use GADTs for that
06:04:34 <quicksilver> but when you are printing it out you either put in every single parenthesis, or you use an algorithm to hide ones which aren't needed
06:04:51 <skypers__> ok
06:04:56 <skypers__> I’ll see that later I guess
06:05:53 <pyr> hola dear haskell people
06:06:17 <pyr> i love the interface exposed by codec.crypto.rsa and the fact that it doesn't require openssl like hsopenssl does
06:06:45 <pyr> i just can't figure out which companion package i'm supposed to use to load private keys from pem files to use it
06:07:09 <pyr> it knows how to generate keyparis, but apparently not how to load them from files
06:07:16 <pyr> *keypairs
06:08:53 <pyr> also, hoogle returns nothing for "PrivateKey": sadpanda
06:08:58 * hackagebot HipmunkPlayground 5.2.1 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.1 (FelipeLessa)
06:12:09 <fryguybob> pyr: fpcomplete.com/hoogle gives several hits for PrivateKey.
06:13:15 <pyr> fryguybob: ah, indeed i wasn't using that one
06:13:41 <pyr> fryguybob: still, the only privatekey reading function it surfaces deals with another data PrivateKey, i'll keep looking, thanks!
06:18:59 * hackagebot fb 0.15.1.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.15.1.1 (FelipeLessa)
06:22:02 <raneem> Hello, I am new to haskell. I know python and perl and I am looking for a nice (but not boring) intorduction to haskell. I have a degree in math so I think haskell might be more interesting to me than other languages. Can you recommend a good book to start?
06:22:26 <hc> the haskell report maybe?
06:22:57 <hc> http://www.haskell.org/onlinereport/
06:23:11 <ilmig> raneem: I liked "Learn you a Haskell": http://learnyouahaskell.com/
06:23:40 <ilmig> also as exercises to become fluent: https://github.com/NICTA/course/
06:24:01 <dhrosa> +1 for LYAH
06:24:42 <DarkLinkXXXX> So why does cabal break things so much? I've never had this problem with python.
06:24:44 <raneem> Any other books than learn you a haskell?
06:24:54 <Maior> raneem: I did LYAH, RWH, then Par/Conc
06:25:05 <Earnestly> The Craft of Functional Programming
06:25:17 <r444> Maior: i'm stuck on RWH
06:25:22 <raneem> Maior: RWH ?
06:25:31 <Maior> raneem: Real World Haskell
06:25:31 <Earnestly> raneem: Real World Haskell
06:25:32 <r444> slipped to "Beginning Haskell"
06:25:34 <Maior> r444: stuck?
06:25:57 <r444> Maior: it is kinda boring, lost interest
06:26:08 <r444> it's so slow
06:26:33 <r444> maybe some power-skipping will come to aid
06:26:54 <hc> i think with a degree in mathematics the official haskell report is a good first choice
06:26:56 <raneem> I was hoping for something with examples on mathematics
06:26:56 <raneem> but seems lyah is the book
06:27:08 <ilmig> there is also a meta tutorial: http://www.haskell.org/haskellwiki/Meta-tutorial
06:27:35 <ilmig> if LYAH starts too slow for you, you could also have a look at: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
06:28:00 <raneem> hc: what is the offical report?
06:28:10 <hc> raneem: http://www.haskell.org/onlinereport/
06:28:23 <hc> it's basically a description of the language
06:29:00 * hackagebot yesod-fb 0.3.1 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.3.1 (FelipeLessa)
06:29:03 <raneem> ilmig: haskell the hard way! I like that! :D
06:30:20 <ilmig> raneem: but please don't get frustrated from reading it. I only really understood it after reading LYAH. But then it turned out to be an excellent summary.
06:31:08 <jonkri> Could `Tree a' (<http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Tree.html>) implement Ord for `Ord a'?
06:31:25 <raneem> ilmig: I think I can handle it *Hopefully*
06:32:20 <alcabrera> hmmm, isn't the official current report 2010?: http://www.haskell.org/onlinereport/haskell2010/
06:33:31 <ilmig> and I can't recommend https://github.com/NICTA/course/ enough. You get to reimplement the most important part of the standard library, which consists mainly of one liners. This alone makes it a lot of fun!
06:33:39 <hc> alcabrera: you're right
06:33:57 <John_John_> i would like to get started with haskell and i would like to ask you what is the most preffered way to install it in a linux machine. from their official repositories or from haskell download site ?
06:34:25 <raneem> ilmig: will check that
06:35:03 <ilmig> raneem: I think it would be a good second step after you read "haskell the hard way"
06:35:36 <alcabrera> John_John_: the official way is usually to install the haskell platform from your distribution's package manager: http://www.haskell.org/platform/
06:35:46 <alcabrera> s/official/recommended
06:36:29 <ilmig> there is something deeply satisfying about reimplementing Haskell's most important and powerful functions and realizing that they are almost exclusively simple one-liners
06:37:07 <raneem> ilmig: I agree with you
06:37:28 <supki> John_John_: it's fine to start with haskell-platform provided by your distro's package manager
06:37:38 <Hafydd> Why is this an http://lpaste.net/100106
06:37:48 <Hafydd> ...an "illegal instance declaration"?
06:38:41 <supki> Hafydd: well, the error message describes why
06:39:00 * hackagebot yesod-auth-fb 1.6.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.1 (FelipeLessa)
06:39:15 <Hafydd> Oh, I suppose it does...
06:41:09 <jason__> hi, i'm new to haskell going through Brent Yorgey's class here: http://www.seas.upenn.edu/~cis194/ i'm having trouble w/using foldr to balance trees
06:41:27 <jason__> wondering if this is a good place to ask for help
06:42:06 <John_John_> do i need all these ?  haskell-platform, ghc-mtl, ghc-zlib
06:42:35 <pjdelport> jason__: This is a good place, yes
06:42:55 <alcabrera> John_John_: yes, that sounds right.
06:43:07 <pjdelport> jason__: See pastebin in the topic to paste code.
06:43:07 <quchen> John_John_: Installing haskell-platform and ghc (which is probably automatically installed by haskell-platform) should be sufficient.
06:43:47 <quchen> John_John_: The mtl and zlib packages are contained in the Platform as well I think. In any case, you don't really need the for your first installation (and it's easier to install them via cabal later in case you don't have them).
06:44:21 <quchen> I don't recommend installing anything more than GHC and Platform from your repos. Third party libraries are better installed via cabal (which you get with the Platform).
06:44:23 <jason__> i was able to balnace a tree using recursion, but, i'm not sure how to translate it to foldr
06:44:50 <John_John_> what is cabal ?
06:44:53 <jason__> the assignment is to balance a tree from an [a]
06:45:00 <John_John_> haskells package manager ?
06:45:12 <ocharles> Does anyone have any tips for what to run with to do heap profiling? '-hc' just gives me one huge bar called "MAIN"
06:45:22 <jason__> excersise 2 here http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf
06:45:31 <quchen> John_John_: It's not a package manager, but it automatically downloads dependencies and builds your stuff. It's basically a makefile that writes itself.
06:45:48 <quchen> Want the async package? cabal install async
06:45:50 <quchen> Done.
06:45:58 <ocharles> using -fprof-auto
06:46:37 <jason__> convert a string "ABCDEFGHIJ" and convert it into a balnaced tree, each node contains it's height in the tree
06:46:52 <John_John_> another thing is that even haskell-platform is a whole bunch of RPM's to download
06:47:16 <John_John_> so maybe it's better to compare with those coming with my distro right ?
06:47:32 <John_John_> let me check and tell you if they are the save versions actually
06:47:55 <quchen> John_John_: Just install the Platform and all dependencies. I just meant to say that after installing the Platform, don't go back to your distro's repos to install further libs.
06:48:29 <jason__> here's the recursive function http://lpaste.net/100108
06:49:01 * hackagebot yesod-recaptcha 1.2.1 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.2.1 (FelipeLessa)
06:49:18 <John_John_> it's 47 RPM's !!!
06:49:35 <John_John_> http://koji.fedoraproject.org/koji/buildinfo?buildID=482836
06:50:17 <John_John_> god damn linux, that's why i am a mac user after all !!!
06:50:34 <Yaniel> the mac version has just the same packages :D
06:50:35 <quchen> Because your package manager contains packages!?
06:50:41 <quchen> That's a good reason to hate it, yes.
06:50:47 <Yaniel> just packaged differently
06:52:52 <John_John_> i see now and the mac distribution is one click away :)
06:53:09 <John_John_> probably i ll be using haskell on my mac...
06:53:32 <John_John_> but i would like to make it work on linux for professional reasont too
06:54:39 <quchen> And the problem is ..?
06:55:01 <John_John_> but let me get this straight please cause i am a total beginner here. i really do have to install all those 47 RPM's from the link i gave you before, right ?
06:55:19 <quchen> Just install the Platform and all dependencies.
06:55:27 <quchen> In other words, just install the Platform.
06:55:38 <ilmig> John_John_: I don't understand your problem. Shouldn't be the installation just one command (or click) with your package manager (e.g. something like yum install haskell-platform)
06:55:42 <alcabrera> John_John_: yum install haskell-platform should do the trick (assuming yum-based rpm system)
06:56:02 <ilmig> your package manager will sort out the dependencies. That's its job after all...
06:56:04 <jason__> here's a completely unbalanced tree - http://lpaste.net/100111  the node heights are correct, but i'm not sure how to add the element being folded to the right/left side of the tree appropriately
06:56:40 <mm_freak_> ocharles: ping
06:57:57 <John_John_> i thought you told me not to use my system's repo's and to use the official site RPM's right ??
06:58:38 <ilmig> Usually the packages in your distribution's repo should be fine
06:58:57 <John_John_> because with yum i assume it's easy yes
06:59:20 <mm_freak_> John_John_: if you have a haskell platform package, that's probably what you want to install
06:59:27 <quchen> No, I said after installing the Platform, don't use your repos to install further packages.
06:59:31 <mm_freak_> and it's common to install the rest through the cabal command line utility
06:59:39 <quchen> In particular, I said "just install the Platform" twice.
07:00:04 <ocharles> mm_freak_: hi
07:00:10 <mm_freak_> ocharles: hi there =)
07:00:25 <mm_freak_> ocharles: i'm currently making a rather difficult decision about wire behavior, and i'd like to discuss it first
07:00:29 <mm_freak_> if you have time =)
07:00:57 <ocharles> sure, just once I fix this space leak :)
07:02:05 <mm_freak_> ocharles: a brief history of time:  in the first (never released) netwire version time would stop for a wire that doesn't run, in particular here:  w1 <|> w2
07:02:52 <mm_freak_> i then quickly considered this to be a bad idea and added time propagation such that w1 <|> w2 would accumulate the time that w2 has missed
07:03:29 <mm_freak_> here is the trouble:  gameMenu <|> game
07:03:47 <John_John_> ok guys i think i understood what you told me now
07:03:52 <mm_freak_> while the menu is running, the game is paused and accumulates time
07:04:12 <John_John_> what is the latest version of haskell just to be sure ?
07:04:30 <silver> HEAD
07:04:32 <silver> :)
07:04:50 <quchen> GHC 7.6.3 is the current release of GHC.
07:05:02 <mm_freak_> at the point when you leave the menu and go back to the game, it will make a jump, because suddenly you get a time delta of 10 seconds instead of 1/60
07:05:03 <John_John_> and what is ghc ?
07:05:12 <quchen> 7.8 will be out in a few weeks, and a Platform based on 7.8 in a couple of months.
07:05:21 <quchen> GHC is the de-facto standard compiler.
07:05:35 <mm_freak_> this makes me question time accumulation (which is why 's' has a Monoid constraint in netwire)
07:05:55 <mm_freak_> and at this point i'm inclined to remove it
07:06:30 <John_John_> in general, is haskell hard to learn if you know OOP programming ?
07:06:34 <ocharles> mm_freak_: the stopping time thing I actually expected at first
07:06:59 <ocharles> mm_freak_: using a mario example again, even if you pick up a mushroom, the game would normally freeze entirely, except for mario animating while he grows
07:07:21 <quchen> John_John_: It's something entirely different.
07:07:23 <alcabrera> John_John_: in many ways, yes. it's a whole new way of thinking about things. instead of objects, you have functions and interfaces (typeclasses) over data. It takes a lot of unlearning/relearning
07:07:28 <Earnestly> John_John_: Be like the water Bruce Lee mentions
07:07:35 <ocharles> mm_freak_: but then maybe that is more a 'modes' thing
07:08:12 <mm_freak_> ocharles: the question is whether it's a good idea if 'modes' and (<|>) disagree on the nature of time =)
07:08:36 <John_John_> Earnestly: i know this saying i am a bruce lee fun you know and yun fun arts
07:09:25 <mm_freak_> ocharles: the hacky solution is to provide 'paused'…  a function that would take a wire and stop it from accumulating time (in netwire 5 the wires themselves do that, not the (<|>) operator)
07:09:42 <mm_freak_> ocharles: but then observe this:  mkGen (… paused …) <|> …
07:09:59 <mm_freak_> 'paused' wouldn't have any effect, because it will itself receive a huge time delta
07:10:06 <mm_freak_> 'modes' has the same problem
07:10:11 <ocharles> not sure I follow there
07:10:21 <mm_freak_> well, 'modes' stops time
07:10:25 <ocharles> right
07:10:40 <John_John_> can i use haskell for modern back end development ? for example to create restful web services in order to be consumed by a front end javascript client ?
07:10:59 <mm_freak_> ocharles: but it may not have the opportunity to stop it:  w1 <|> modes w . w2
07:11:29 <mm_freak_> when and why 'modes' works is a delicate, complicated topic
07:11:48 <quchen> @quote Jafet research
07:11:49 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
07:11:55 <alcabrera> John_John_: definitely! :)
07:12:06 <mm_freak_> ocharles: that's because 'modes' disagrees with pretty much everything else about what time is
07:12:25 <alcabrera> There's several RESTful (and slightly less RESTful) frameworks available in haskell land.
07:12:49 <alcabrera> I'd recommend checking out http://www.yesodweb.com/ for starters. It also has a nice book that introduces this space pretty well.
07:13:11 <mm_freak_> lol
07:13:13 <mm_freak_> i like that quote
07:13:17 <Maior> me too
07:13:23 <guymann> [✔] Same
07:13:52 <ocharles> mm_freak_: so you're thinking of having time be wire local by default?
07:14:36 <mm_freak_> ocharles: i'm not sure…  none of the two approaches really feels right…  what do you think?
07:15:28 <ocharles> the "suspended time" between alternatives seemed to be what I expected
07:15:28 <John_John_> thank you very much guys !!
07:15:38 <ocharles> i can't say I've ever had a need for accumulation between alternatives
07:15:49 <ocharles> remember I also had this problem of understanding this when I carried keypresses in the session type
07:15:59 <ocharles> it's the same problem - I didn't want to accumulate all the key presses when I switched alternatives
07:17:07 <mm_freak_> ocharles: perhaps it's time to ask the grand question:  was builtin inhibition a good idea?  or would it have been better to have a bunch of specialized operators?
07:17:36 <ocharles> I'm not sure I can answer that :) I must say I do like inhibition, but maybe that's because i've never tried it any other way
07:17:59 <John_John_> and does haskell have drivers/support for the well known RDBMS's ? like MSSQL, ORACLE, MYSQL, POSTGRESQL, SQLITE and the like ?
07:18:03 <mm_freak_> inhibition is great, because it gives you very easy "switching back"
07:18:36 <zomg> John_John_: I would say the answer to about 95% of questions like that would be "yes"
07:19:10 <mm_freak_> ocharles: on the other hand you can make this kind of switching work in other ways:  (~|~) :: Wire m a (Maybe b) -> Wire m a (Maybe b) -> Wire m a (Maybe b)
07:19:22 <nbouscal> John_John_: searching around on hackage might be a good idea for you to get familiar with what's available
07:19:35 <John_John_> hackage ?
07:19:48 <mm_freak_> ocharles: and perhaps even get a well-defined result out of that:  (~|) :: Wire m a (Maybe b) -> Wire m a b -> Wire m a b
07:20:02 <tdammers> John_John_: the central repository of community-created haskell packages
07:20:10 <alcabrera> John_John_: it's the PyPI/Gems/npm of haskell - a web site where all available third-party packages are listed
07:20:23 <John_John_> aha
07:20:58 <mm_freak_> ocharles: in particular (-->) would get a very nice type:  (-->) :: Wire m a (Maybe b) -> Wire m a b -> Wire m a b
07:21:06 <mm_freak_> this works great, because (-->) is right-associative
07:21:45 <ocharles> hmmm, so --> is like <|> for Maybe
07:22:01 <ocharles> well, sort of
07:22:03 <mm_freak_> no, they are the same thing, except that (-->) doesn't switch back
07:22:13 <mm_freak_> and it doesn't accumulate
07:22:28 <John_John_> ok i gave mysql in the search box and it gave me 20 choices. is this the right channel/community to ask more specific questions about it ?
07:22:51 <mm_freak_> John_John_: in haskell you would commonly use a high level database abstraction
07:23:11 <ij> If I were to generate giant permutation lists and didn't request one branch of them, would they get calculated?
07:23:14 <John_John_> ok so what library is for me then for mysl lets say ?
07:23:15 <mm_freak_> John_John_: also for small to mid-size applications acid-state is much nicer to work with and makes you independent of RDBMSes
07:23:18 <ij> with Data.List.permutations
07:23:41 <mm_freak_> ij: 'permutations' is extremely lazy
07:23:53 <mm_freak_> > permutations [1..] !! 50000
07:23:57 <lambdabot>  [9,6,7,5,3,2,4,8,1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:24:10 <John_John_> can you point me to the right package for mysql please ?
07:24:16 <John_John_> http://hackage.haskell.org/packages/search?terms=mysql
07:24:21 <ij> mm_freak_, Oh. Cool then, thanks.
07:24:22 <quchen> mm_freak_: Wooot
07:24:32 <quchen> I would never have expected that to terminate :-)
07:24:36 <nbouscal> John_John_: There are quite a few different packages depending on what you're looking for. I'd google around a bit, look on StackOverflow, etc
07:24:39 <monochrom> that is quite impressive :)
07:24:51 <mm_freak_> John_John_: do you want to write SQL by hand?
07:25:24 <John_John_> yes sql by hand but mostly to call stored procedures with parameters
07:25:40 <mm_freak_> John_John_: in that case try HDBC-mysql
07:26:31 <mm_freak_> John_John_: wait, no
07:27:00 <mm_freak_> i've just looked and apparently it has become unmaintained…  if all else fails, you can always use the 'mysql' package on which all others are based
07:29:04 * hackagebot css-text 0.1.2 - CSS parser and renderer.  http://hackage.haskell.org/package/css-text-0.1.2 (GregWeber)
07:29:32 <ViperLD50> Howdy partners
07:30:02 <ViperLD50> Looking for the most basic of help
07:30:19 <ViperLD50> About how to run some Haskell code in OSX
07:30:20 <mm_freak_> John_John_: apparently mysql-simple is also widely used
07:30:35 <John_John_> let me check that please
07:31:47 <ViperLD50> Anyone able to help a noob out? - I have downloaded the Haskell Platform and I have a basic Haskell program I got off of Github and I'm just looking for a little help how to make the thing "go"
07:32:23 <quicksilver> ViperLD50: ghc --make NameOfFile.hs
07:32:29 <mm_freak_> ocharles: i'll experiment with explicit intervals…  btw, i also brought the monadic argument back, because it's really necessary for efficient OpenGL, if you have a complicated scene
07:32:43 <quchen> quicksilver: --make is on by default
07:32:52 <mm_freak_> quchen: really?
07:33:10 <ViperLD50> I already compiled the code by running
07:33:17 <ViperLD50> "ghci"
07:33:25 <mm_freak_> ViperLD50: the "i" stands for "interpreter" =)
07:33:39 <ViperLD50> and then at the Prelude> prompt I did "load boggle_generator.hs"
07:33:44 <mm_freak_> ViperLD50: btw, you can use the interpreter:  runhaskell MyProg.hs
07:33:44 <tdammers> I thought it stood for "interactive" :x
07:33:47 <quchen> mm_freak_: "This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the ––make option can be omitted." http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html
07:33:50 <ViperLD50> and it said it compiled the file
07:33:59 <ViperLD50> but now I don't know what to do to make it actually do what the program does
07:34:07 <mm_freak_> ViperLD50: it does for internal use, and it only compiles to bytecode
07:34:14 <mm_freak_> tdammers: yeah, i guess
07:34:27 <ViperLD50> Please keep in mind I know nothing about Haskell and hardly anything about programming
07:34:31 <mm_freak_> ViperLD50: ghci is for interactive interpreted sessions…  mainly for debugging, not for compilation
07:34:41 <monochrom> ViperLD50: you may like http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci.html . it is also somewhere on your hard disk.
07:34:46 <ViperLD50> I'm just trying to generate a list of Boggle boards using someone's code I found on github
07:34:58 <fryguybob> mm_freak_: The i is for interactive.
07:35:09 <mm_freak_> sorry =)
07:35:23 <fryguybob> :D
07:35:23 <John_John_> can you tell me what database systems are most commonly used cross platform with haskell ?
07:35:31 <tdammers> mm_freak_: now write out "the i is for interactive" 500 times
07:35:39 <Maior> John_John_: eh?
07:35:41 <mm_freak_> John_John_: most choose between postgresql and acid-state
07:36:05 <mm_freak_> tdammers: done =)
07:36:07 <monochrom> mm_freak_: ghci does say "compiling" even though it interprets
07:36:07 <quchen> mapM_ print (repeat 500 "the i is for interactive") -- tdammers: Haskell saving the day once again!
07:36:11 <John_John_> i have never heard of acid state
07:36:22 <mm_freak_> John_John_: it's haskell-specific
07:36:24 <tdammers> John_John_: it's a Haskell thing
07:36:33 <zomg> John_John_: oh right you were on the node channel yesterday weren't you =)
07:36:37 <tdammers> John_John_: not really a DBMS, more a persistence library
07:36:47 <John_John_> yes i was !!!!!!!
07:36:53 <zomg> hehe
07:36:55 <John_John_> now i am in the office
07:36:56 <mm_freak_> John_John_: you define a type in haskell and acid-state makes it ACID =)
07:37:29 <John_John_> zomg: nice memory :)
07:38:08 <John_John_> and what is the most uptodate-valid driver for postgresql. can you point that for me ?
07:38:34 <mm_freak_> John_John_: postgresql-simple for low level
07:38:39 <mm_freak_> i.e. writing SQL
07:39:00 <arpunk> John_John_: I've used postgresql-simple, is fantastic if you write your own queries
07:39:02 <quicksilver> quchen: only on recent versions of haskell
07:39:06 <quicksilver> quchen: :)
07:39:20 <John_John_> i read that and it says that is distributed only for debian, or i understood wrong ?
07:39:57 <tdammers> John_John_: most likely you want to use cabal to install Haskell packages, not your distro's package manager
07:40:26 <John_John_> aha so cabal will also install that postgres driver right ??
07:40:38 <tdammers> not the "driver", but the library
07:40:54 <John_John_> ok library sorry
07:41:20 <napping> Compared to O'Caml records with mutable fields, can you get a data type with the same kind of layout in Haskell?
07:41:35 <mm_freak_> napping: like a record of IORefs?
07:41:38 <napping> I think an IORef field ends up as a separately allocated object
07:41:49 <mm_freak_> napping: likely
07:41:55 <John_John_> ok guys thanks for now...catch you laterzz
07:41:58 <napping> The semantics are fine, just more indirections
07:42:45 <quicksilver> and IORef (or MVar) containing a record is normally a good solution
07:42:48 <mm_freak_> napping: it's not possible to get mutable records…  you can emulate them by using a mutable vector or Storable
07:42:51 <quicksilver> and it is less fiddly to use.
07:43:18 <quicksilver> you don't really need mutable records when it's so cheap to construt a new record which is the same in all respects as an old one except one field.
07:43:44 <mm_freak_> napping: i would go with regular records and leave making updates efficient to the garbage collector =)
07:43:48 <mm_freak_> it's surprisingly efficient
07:43:51 <quicksilver> a record with IORefs in each field might be useful in some rare cases to do with the way you share stuff around the program. But I would almost always expect a better way.
07:43:59 <dcoutts> napping: I don't think you can achieve a memory layout of a bunch of mutable fields next to each other in memory. Your building blocks are single refs (IORef/MVar/STRef etc) and arrays of those.
07:44:28 <napping> Yeah, I didn't think I was forgetting anything
07:44:29 <monochrom> I now wonder if strict fields plus unbox-strict-fields does it
07:44:33 <dcoutts> napping: obviously the array versions give you a bunch of them together, but of the same type and variable length. There's no "tuple" equiv
07:44:34 <mm_freak_> napping: as a first step go without mutability
07:44:52 <dcoutts> monochrom: no, IORefs will not unbox
07:45:02 <monochrom> oh well haha
07:45:11 <napping> monochrom: You'd need to be able to extract and pass around the IORef
07:45:20 <mm_freak_> well, it is actually possible to get mutable records using MVector
07:45:24 <dcoutts> they have special state GC associated with them (clean/dirty)
07:45:31 <mm_freak_> but it's ugly and the interface is horrible
07:45:38 <dcoutts> so they have a fixed representation
07:46:02 <mm_freak_> write/derive an Unbox instance for your record type and create an MVector with a single item
07:46:13 <mm_freak_> that effectively gives you an unboxed record with variable size fields
07:46:13 * fryguybob hopes to unbox TVars...but it will be a lot of work.
07:46:22 <mm_freak_> but again, i don't recommend doing that
07:46:25 <napping> TVars would actually be the interesting case
07:47:13 <napping> Not that I necessarily need to unbox them, but the interesting semantics is a parallel rewriting system, where rewrites affecting disjoint parts of the term ought to be able to really be concurrent
07:47:35 <quchen> When I `cabal install` in a sandbox, the lib will only be registered in the sandbox, right?
07:47:44 <mm_freak_> napping: sounds like a TVar of a record
07:47:56 <napping> well, more like a tree of terms wired together we TVars, but yes
07:48:12 <mm_freak_> napping: or if the computation is pure, it's really just data parallelism
07:48:25 <mm_freak_> napping: write a parallel strategy for your record in that case
07:48:29 <napping> I wonder how much would break horribly if you just mutated the a pointer field in an object
07:48:55 <monochrom> yes quchen
07:49:01 <mm_freak_> explicit mutation is something that isn't well supported in haskell
07:49:19 <mm_freak_> in-place mutation should be considered an optimization, not a coding style
07:49:29 <napping> mm_freak_: It's more complicated than that - rules can do read-only checks on part of the term, and only make changes elsewhere
07:49:30 <monochrom> in general see my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox
07:49:50 <mm_freak_> napping: have you checked the parallelizability of your algorithm?
07:50:17 <napping> then two rules reading a common part and touching disjoint parts are independent
07:50:42 <napping> Haven't checked anything, this comes from giving a "true concurrency" operational semantics to programming languages
07:50:58 <dareTake> Hi, I have a doubt. How would I translate
07:51:00 <dareTake> do
07:51:03 <mm_freak_> napping: have you read The Book?
07:51:06 <dareTake>  res <- n
07:51:09 <mm_freak_> napping: http://chimera.labs.oreilly.com/books/1230000000929
07:51:21 <napping> Oh, that's new
07:51:27 <napping> I'm not really worried much about performance
07:51:30 <merijn_> dareTake: Translate it to what?
07:51:33 <dareTake> return $ res * 10 + (digitToInt cur)
07:51:39 <dwcook> dareTake, that's not a valid do block.
07:51:43 <dwcook> Oh, now it is.
07:51:43 <tdammers> dareTake: care to paste?
07:51:44 <dareTake> in term of (>>=) and (>>) ?
07:51:53 <napping> Rather, I'm doing some stuff in O'Caml anyway - because we're using Coq for other stuff - and was reminded of some semantic differences
07:51:55 <dareTake> k sec
07:51:58 <merijn_> dareTake: Fun fact, you can priv msg lambdabot and use the @undo command
07:52:01 <mm_freak_> dareTake: fmap (\res -> res * 10 + (digitToInt cur)) n
07:52:07 <tdammers> also, the word you're looking for is "desugar"
07:52:14 <merijn_> @undo do { foo; x <- bar; return $ xyzzy x }
07:52:14 <lambdabot> foo >> bar >>= \ x -> return $ xyzzy x
07:52:15 <monochrom> n >>= \res -> return (res * 10 + (digitToInt cur))
07:52:57 <dareTake> thnx
07:52:59 <mm_freak_> dareTake: the translation is quite straightforward, but you have an interesting special case there
07:53:05 <monochrom>  @undo is good only when you write one single line :)
07:53:14 <dwcook> That can also be transformed into an application of (<*>) if I'm not mistaken
07:53:28 <mm_freak_> dareTake: you have 'do x <- c; return (f x)'
07:53:38 <dareTake> I tried  n >>= ( * 10) >>= (+ digitToInt cur) >>+ return
07:53:39 <dwcook> Oh that's what mm_freak_ is about to get at
07:53:50 <mm_freak_> dareTake: and that's just:  'fmap f c'
07:54:03 <dwcook> Orrr that :D
07:54:15 <mm_freak_> dwcook: (<$>)
07:54:26 <ij> What is >>+?
07:54:28 <jfischoff> does ScopedTypeVariables work type variables of kind Constraint?
07:54:32 <dareTake> er >>= return . What is wrong is that statement?
07:54:33 <mm_freak_> because that's just fmap, but i don't want to dump new operators on a beginner =)
07:54:35 <ij> :t >>+
07:54:38 <mm_freak_> jfischoff: yes
07:54:38 <lambdabot> parse error on input `>>+'
07:54:41 <jfischoff> or actually
07:54:46 <jfischoff> * -> Constraint
07:54:50 <mm_freak_> jfischoff: yes
07:55:03 <dwcook> mm_freak_, right, I wasn't thinking straight – you can transform some do blocks into a combination of <$> and <*>
07:55:05 <monochrom> dareTake: it uses wrong intuition. that's what's wrong.
07:55:24 <jfischoff> mm_freak: I can't seem to get it to work
07:55:26 <mm_freak_> dwcook: that's liftM2, liftM3, liftM4 …
07:55:28 <dareTake> monochrom, can you elaborate?
07:55:31 <mm_freak_> jfischoff: are you using "forall"?
07:55:38 <monochrom> no.
07:55:39 <jfischoff> yes http://stackoverflow.com/questions/21847326/scopetypevariables-is-failing-to-help-inference
07:55:50 <mm_freak_> jfischoff: forall (c :: * -> Constraint). …
07:56:09 <jfischoff> I didn't think I needed a kind signature
07:56:17 <jfischoff> because I didn't get a kind error
07:56:58 <mm_freak_> jfischoff: that was just for clarity
07:57:20 <mm_freak_> jfischoff: note that you have a bunch of higher rank types there…  that's probably where your error is
07:57:31 <jfischoff> I have one
07:57:31 <mm_freak_> your use of ScopedTypeVariables seems correct
07:57:33 <jfischoff> e
07:59:19 <jfischoff> i will try a simple test
08:16:56 <nbouscal> window level ALL -JOINS -PARTS -QUITS
08:16:59 <nbouscal> mt sorry
08:18:23 <dareTake> monochrom, understood it now
08:18:28 <dareTake> thnx
08:19:10 * hackagebot language-puppet 0.12.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.12.2 (SimonMarechal)
08:23:59 <jfischoff> @hpaste
08:23:59 <lambdabot> Haskell pastebin: http://lpaste.net/
08:29:10 * hackagebot css-text 0.1.2.0.1 - CSS parser and renderer.  http://hackage.haskell.org/package/css-text-0.1.2.0.1 (GregWeber)
08:40:49 <troydm> Could not find module `Text.Parsec.String':
08:40:56 <troydm> what might be wrong?
08:41:06 <troydm> it finds Text.Parsec module without problem
08:41:40 <troydm> parsec-3.1.3 version ghc 7.6.3
08:41:52 <velbin> ahh it's a wonderful day
08:45:11 <klrr> is there any freenode channel dedicated to type theory?
08:48:08 <sqdfsq> if I would like to write a monoid which works on all ordered types, what would the instance definition be
08:48:24 <sqdfsq> instance Monoid (Ord a) where
08:48:25 <sqdfsq> ...?
08:48:48 <S11001001> @hoogle Min
08:48:49 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Min :: BlendEquation
08:48:49 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax module Graphics.Rendering.OpenGL.GL.PixelRectangles.Minmax
08:48:49 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters type MinificationFilter = (TextureFilter, Maybe TextureFilter)
08:48:52 <S11001001> eh.
08:49:14 <alcabrera> klrr: there appears to be a ##hott channel, which is dedicated to Homotopy Type Theory (ref: http://homotopytypetheory.org/)
08:51:03 <scott> S11001001: Hmm, I thought there was something like Min/Max in Data.Monoid... I don't see them.
08:51:25 <scott> sqdfsq: Are you trying to write a min or max monoid?
08:52:47 <scott> Oh, Max/Min can't have mempty.
08:53:10 <scott> I guess they're in Data.Semigroup, which is like Monoid without mempty.
08:54:16 <dwcook> scott, with Bounded they can, can't they?
08:54:57 <scott> Yeah, that should work
08:55:04 <dwcook> (Although Bounded is too strong for either one of those individually; really we'd want UpperBound and LowerBound)
08:55:38 <dwcook> That said, I suppose the semigroup would suffice for many applications
08:55:57 <bergey> There's also Data.Monoid.Inf, which makes a monoid by adjoining infinity.
08:56:04 <jfischoff> http://lpaste.net/100112
08:56:09 <dwcook> Ah, that's pretty neat
08:56:25 <jfischoff> mm_freak: Here this simple case shows my problem: http://lpaste.net/100112
08:56:32 <scott> The bounded one would be a bit odd, though. mconcat of an empty list for (Max Int) would be something like (Max 9223372036854775807), which might not be very nice.
08:56:49 <dwcook> scott, you meant Min Int
08:57:08 <dwcook> The identity of minimum is the greatest value and maximum the least value
08:57:23 <scott> Oh, right.
08:57:24 <jfischoff> I think the way type inference works with constraints, and the way type inference works with type variables are at odds
08:58:10 <scott> With Semigroup you can't sconcat the empty list at all, which might be more sensible.
08:58:46 <sqdfsq> scott, yes
09:00:21 <sgraf> Hi, I'd really like to try vim for haskell coding, but I'm constantly running into issues setting the tools up on my mac under iTerm2 and mvim. Currently I'm trying to get haskellmode to work correctly, but the commands accessing GHC (_t, _T, etc.) don't work until I do a :GHCReload. :make doesn't help although it is invoking ghc correctly.
09:00:50 <scott> Here's an implementation of Min/Max using Ord and Bounded: https://ghc.haskell.org/trac/ghc/ticket/1952
09:00:58 <mm_freak_> jfischoff: not sure how that is related to ScopedTypeVariables?
09:01:16 <jfischoff> I think it is more fundamental
09:01:28 <mm_freak_> i remember that to be your original question =)
09:01:35 <erisco> command line argument parsers... which one is popular?
09:01:36 <jfischoff> ScopedTypeVariables also doesn't help there
09:01:50 <mm_freak_> jfischoff: also i guess there is a typo
09:01:50 <enthropy> jfischoff: seems somewhat related to "not-being-able-to-infer-rank-N-types"
09:02:09 <jfischoff> enthropy: maybe
09:02:13 <mm_freak_> jfischoff: but yes, for higher rank types the type system often needs some help
09:03:01 <mm_freak_> jfischoff: and that was my original point:  ScopedTypeVariables is not your problem, RankNTypes is =)
09:03:12 <enthropy> probably it comes down to show needs that 'c' type variable to contain Show, but no reason it cannot have other things in there
09:03:16 <jfischoff> well sort of
09:04:16 <mm_freak_> scoped constraints are possible, but your case is a lot more complicated
09:04:37 <mm_freak_> note that foralls at higher-rank positions do /not/ introduce scoped type variables
09:04:42 <mm_freak_> because that simply doesn't make sense
09:04:46 <jfischoff> I know
09:05:31 <jfischoff> I'm not capturing a variable I should not be able to
09:06:56 <mm_freak_> the reason why it needs help is because you are passing a type variable that is only used in higher-rank position, so the type system has no way to figure out which constraint to pass
09:07:39 <mm_freak_> so it's really just a fancy version of "ambiguous type variable" =)
09:09:46 <jfischoff> hmm I'm going to try to get rid of the higher rank types for this test and just have the constraint kind
09:10:50 <mm_freak_> btw, constraint polymorphism is an interesting idea
09:11:09 <mm_freak_> i've never seen that in use before
09:13:21 <jfischoff> I can't seem to get the compiler to infer the constraint a passed in function
09:14:32 <jfischoff> s/constraint a/constraint by using a
09:15:24 <mm_freak_> this is actually a weird case
09:15:30 <mm_freak_> i too would have expected GHC to infer this
09:15:47 <mm_freak_> it's probably related to some internal ordering
09:16:23 <mm_freak_> in core language 'show' probably takes the type first and then the corresponding Show dictionary
09:17:06 <mm_freak_> i'm guessing that's why inference fails
09:24:53 <jeeooe> https://test.net/index.php?a=$.get(%27http://localhost:8181/script.js%27)
09:24:55 <jeeooe> oops
09:31:53 <utkarsh> Is there a shorter way to do this?: [(x, y) | x <- xs, y <- ys]
09:32:45 <tromp__> yes
09:33:51 <tromp__> hint: [ map (x,) | x <- xs]
09:34:15 * hackagebot yesod-pagination 0.3.1.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-0.3.1.0 (JoelTaylor)
09:34:17 <utkarsh> I actually have a function like "f xs ys = [(x, y) | x <- xs, y <- ys]"
09:35:45 <tromp__> > [ map ('a',) | x <- "bcd"]
09:35:48 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:35:49 <lambdabot>    arising from a use of `M526064101569746976325803.show_M5260641015697469763...
09:35:49 <lambdabot>  The type variable `a0' is ambiguous
09:35:49 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:35:49 <lambdabot>  Note: there are several potential instances:
09:36:23 <tromp__> > [ map (x,) | x <- "bcd"]
09:36:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:36:24 <lambdabot>    arising from a use of `M171702252485800477525812.show_M1717022524858004775...
09:36:24 <lambdabot>  The type variable `a0' is ambiguous
09:36:24 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:36:24 <lambdabot>  Note: there are several potential instances:
09:36:34 <tromp__> :t ('a',)
09:36:37 <lambdabot> t -> (Char, t)
09:37:19 <petermw> Hm, how about "liftM2 (,)"?
09:37:23 <utkarsh> found one way: liftM2 (,)
09:37:29 <petermw> :)
09:37:44 <utkarsh> :)
09:37:59 <jophish> The Reader monad is a bit of a weird one
09:38:45 <tewlz> shapr: you around, friend?
09:38:52 <tromp__> > [ map (x,) "123" | x <- "abc"]
09:38:53 <lambdabot>  [[('a','1'),('a','2'),('a','3')],[('b','1'),('b','2'),('b','3')],[('c','1'),...
09:39:07 <shapr> tewlz: you called?
09:39:26 <tewlz> shapr: dmcguire here, just sending you an irc poke :)
09:39:43 <shapr> tewlz: Yeah, I know who you are :-)
09:42:35 <dhrosa> :t ap
09:42:37 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:42:42 <dhrosa> :t (<*>)
09:42:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:42:53 <dhrosa> does ap provide you anything more  than <*> does?
09:44:03 <quchen> ap = <*>
09:44:34 <quchen> More accurately,  ap ≡ <*>  (mod bad taste)
09:46:38 <Yaniel> not exactly studying haskell right now but how correct is "if you want to do something that has side effects, you use a monad"?
09:47:32 <quchen> Incorrect.
09:48:02 <Yaniel> thanks. I'll just discard that bit of information then
09:48:22 <quchen> Some monads abstract over things you might call "side-effects", but you could do the same without monads.
09:48:33 <quchen> Monads are the abstraction, not the enabler in the first place.
09:48:53 <Yaniel> I see
09:52:33 <ocharles> Is there anyway to ask GHC RTS to dump some sort of call stack on a signal?
09:52:46 <CaptainK> a monad is a monoid in the category of endofunctors
09:53:47 <klrr> CaptainK: what's endofunctors
09:54:15 <jfischoff> ocharles: you probably know this, but you can catch the signal and call traceStack
09:55:04 <ocharles> jfischoff: I knew about traceStack, I was just hoping I could get it more for free ;)
09:55:14 <ocharles> I'll register a signal handler though, that's not particularly hard
09:55:40 <ltebbs> can anyone recommend a good OS project I could get involved with to help me learn haskell?
09:55:43 <CaptainK> endofuncotrs?  made up word I think...found here:http://tinyurl.com/oe6gr6f
09:55:44 <jfischoff> you could override the uncaughtExceptionHandler to always print the stack
09:55:50 <jfischoff> that's what we do
09:56:04 <jfischoff> Not sure if that would help actually ...
09:57:12 <syao> hello,  I was searching info on loose coupling in haskell software but couldn't find it. Do you know any topic worth reading?
09:57:29 <__jim__>  quick IO question for someone kind of new to haskell
09:57:46 <CaptainK> http://tinyurl.com/36rwd8s endofunctors explained
09:58:21 <__jim__> so I am trying to read from stdin using getContents, break it into lines then apply a function to each line for testing (using lines and mapM_ f)
09:58:40 <__jim__> what is the most idiomatic way in haskell to quit reading lines when a newline is hit?
09:58:54 <__jim__> I guess, what would an elegant solution be?
10:02:57 <quchen> __jim__: You could try implementing `takeWhileM`, which is the monadic counterpart to `takeWhile`.
10:03:33 <__jim__> quchen: that seems really obvious now, thank you
10:03:56 <dhrosa> perhaps lines <- dropWhile (/= '\n') <$> getContents?
10:04:42 <quchen> dhrosa: That would cut off everything before the newline.
10:04:51 <dhrosa> err woop
10:04:54 <dhrosa> takeWhile*
10:05:44 <quchen> Then you would still only be able to read one line, but he wants to read multiple lines until there's a blank one.
10:05:54 <dhrosa> oh
10:05:54 <quchen> If I understand the question correctly.
10:09:14 <mm_freak_> ocharles: i've studied this a bit further, and halting time doesn't make much sense =/
10:09:31 <ltebbs> main = do
10:09:31 <ltebbs>   inText <- getContents
10:09:31 <ltebbs>   let broken = lines inText
10:09:31 <ltebbs>   let matches = takeWhile (/= "") broken
10:09:34 <ltebbs>   mapM_ putStrLn matches
10:09:37 <ltebbs>  
10:09:55 <mm_freak_> ocharles: ArrowChoice requires the clock to keep ticking
10:10:19 <mm_freak_> i have no model for an ArrowChoice that halts time
10:10:46 <mm_freak_> and the model for continuous time sucks
10:10:54 <quchen> Or you could use Pipes. stdinLn >-> takeWhile (/= "\n") >-> <consumer>
10:10:58 <mm_freak_> because it relies on me constructing a constant behavior
10:11:04 <mm_freak_> it feels arbitrary and wrong
10:11:31 <quchen> Wh, make that "takeWhile (not . null)"
10:11:53 <mm_freak_> conal: FRP causes serious trouble =)
10:14:42 <mm_freak_> left :: (Behavior a' -> Behavior a) -> (Behavior (Either a' b) -> Behavior (Either a b))
10:15:20 <mm_freak_> left f b t = case b t of Left x -> Left (f (const x) t); Right x -> Right x
10:15:42 <mm_freak_> this works, but it feels so wrong that i'm considering removing the ArrowChoice instance
10:16:27 <mm_freak_> time accumulation is already a big pain for ArrowChoice…  has always been
10:19:04 <mm_freak_> ocharles: have you actually used ArrowChoice anywhere?  (that's if/case within proc blocks)
10:19:15 <ocharles> I have, but it didn't do what I wanted
10:19:26 <ocharles> I forget exactly what I was doing
10:19:37 <ocharles> but I remember I *didn't* want all the wires ticking, I wanted to choose which wire to run
10:19:39 <ocharles> and that's not arrowchoice
10:19:49 <mm_freak_> yeah
10:19:59 <ocharles> jfischoff: no luck with getCurrentCallStack - i just get an empty stack :(
10:20:06 <mm_freak_> i tried implementing a non-ticking ArrowChoice, but i can't construct a correct model for it
10:20:10 <ocharles> I dunno how that plays with threads - we have numerous threads running
10:21:05 <mm_freak_> so i'll remove ArrowChoice for now and revisit it later when my topological FRP model is finished
10:21:15 <mm_freak_> perhaps i can find a way to get this working
10:22:09 <mm_freak_> btw, ArrowLoop is total now =)
10:22:22 <skypers> is there a way to write a parser that needs a line not to begin by a certain string?
10:22:38 <skypers> (noneOf "@ *> noneOf "\r\n" <* eol)
10:23:04 <skypers> this is ok, but I want to include the first char read my noneOf "@"
10:23:33 <ocharles> mm_freak_: what do you mean by total?
10:23:37 <ocharles> it's impossible to make it spin?
10:25:09 <mm_freak_> ocharles: it doesn't error anymore
10:25:27 <mm_freak_> ocharles: if your wire is loopfree, loop is total
10:26:22 <mm_freak_> skypers: (<|>) only tries the alternative, if the left parser did not consume
10:26:54 <mm_freak_> if the left parser failed /and/ consumed, it fails unconditionally without trying the alternative
10:27:02 <skypers> I know
10:27:08 <mm_freak_> skypers: then you know how to do this =)
10:27:16 <skypers> well
10:27:20 <skypers> I do something like
10:27:37 <skypers> fc <- noneOf "@"; s <- many (noneOf "\r\n"); eol; return $ fc : s
10:29:44 <Dustin> I am trying to write a function which takes a least-to-greatest ordered list of numbers and a value as arguments, and returns the index of the first number in the list that is greater than the value. For example, if I have [1, 4, 9, 16, 25] as my list, and 12 as my value, it should return 3 (as 3 is 16's index in the list and 16 is the 1st number in the list which is greater than 12).
10:30:39 <enthropy> @hoogle findIndex
10:30:40 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
10:30:40 <lambdabot> Data.ByteString.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
10:30:40 <lambdabot> Data.ByteString.Lazy.Char8 findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
10:31:02 <tromp__> @src Data.List findIndex
10:31:03 <lambdabot> Source not found. My pet ferret can type better than you!
10:31:21 <enthropy> > findIndex (>12) [1, 4, 9, 16, 25]
10:31:23 <lambdabot>  Just 3
10:32:19 <Dustin> Yes, but why does it have the word "just"
10:32:31 <enthropy> > findIndex (>125) [1, 4, 9, 16, 25]
10:32:32 <lambdabot>  Nothing
10:33:16 <enthropy> sometimes it just can't find an index
10:33:17 <Dustin> I wish it could say "3" rather than "Just 3"
10:33:58 <enthropy> then you have to decide what it should say or do when there isn't an element in the list that satisfies the given function
10:36:36 <Cale> Dustin: If you can decide what your function is supposed to produce when there is no such element, then you can get rid of the Just by pattern matching with case against Nothing and Just x
10:36:58 <Cale> (or using one of the functions like maybe or fromMaybe which does that)
10:37:06 <quchen> Dustin: It would be wrong to say "3".
10:37:29 <quchen> See https://github.com/quchen/articles/blob/master/fbut.md#i-dont-like-this-show-instance
10:37:58 <Cale> > case findIndex (>125) [1, 4, 9, 16, 25] of Nothing -> -1; Just k -> k -- horrible C programmer's solution to the problem
10:38:00 <lambdabot>  -1
10:38:29 <Cale> > case findIndex (> 10) [1, 4, 9, 16, 25] of Nothing -> -1; Just k -> k -- it works in other cases though
10:38:31 <lambdabot>  3
10:39:21 <joelteon> :t iterate (join (*))
10:39:22 <Cale> Dustin: Does that make sense?
10:39:23 <lambdabot> Num a => a -> [a]
10:39:29 <joelteon> > iterate (join (*)) 3
10:39:30 <lambdabot>  [3,9,81,6561,43046721,1853020188851841,3433683820292512484657849089281,11790...
10:39:45 <Dustin> Cale, yes
10:39:51 <joelteon> > map (length . show) $ iterate (join (*)) 3
10:39:55 <lambdabot>  mueval-core: Time limit exceeded
10:39:58 <joelteon> :(
10:42:46 <jfischoff> quchen: I like your articles
10:43:23 <jfischoff> I'm going to leak them out: https://twitter.com/HaskellTips/status/435845990273142784
10:43:23 <quchen> Well, that's really just a FAQ-style thing
10:43:51 <jfischoff> it's worth reading
10:44:27 <ystael> quchen: is it intentional that the name of that document contains "but"? because most of the headings could start with "but..." :)
10:44:28 <quchen> Let time be the judge of that. I don't want to start any trends with that file ;-)
10:44:52 <jfischoff> too late ;)
10:45:12 <quchen> ystael: From the articles repo readme: fbut.md is a list of Frequently Brought Up Topics in #haskell for easy reference. It's like an FAQ, except that the "F" stands for "frequently" instead of "someone thought this may be worth mentioning".
10:45:38 <ystael> yes, I saw the initialism, I just thought the other thing was a funny coincidence
10:46:25 * davidfetter_disq wonders how one might arranged a system of Questions Actually Asked Frequently and keep it current
10:46:41 <davidfetter_disq> vs. a "FAQ" which by its nature is a static document
10:47:01 <quchen> I read FAQs like EULAs and readmes: not.
10:47:09 <quchen> That's why I thought I should use a new abbreviation.
10:47:19 <quchen> Anyway, OT.
10:47:44 <davidfetter_disq> maybe the tooling around it could be written in Haskell
10:48:16 <nooodl> joelteon:
10:48:18 <nooodl> > [floor ((2 ^ x) * log 3 / log 10) + 1 | x <- [1..]]
10:48:19 <quchen> Sure it could. But it would be work, and I want that file to save me time for other things.
10:48:20 <lambdabot>  [1,2,4,8,16,31,62,123,245,489,978,1955,3909,7818,15635,31269,62538,125075,25...
10:48:55 <nooodl> um that should be [0..] i guess
10:54:30 <skypers> oh
10:54:34 <skypers> there’s no liftA4
10:54:43 <skypers> I guess I’ll use <$> and <*> then
11:00:26 <verement> :t ap
11:00:28 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:01:31 <skypers> do you know a better name for (Stream s m Char) => ParsecT u s m a?
11:01:37 <skypers> I read something about GenCharParser
11:01:40 <skypers> or something like that
11:12:37 <ltebbs> can anyone recommend a good open-source project I could get involved with to help me haskell better?
11:13:46 <Peaker> Is there a nice Data.Map API to return the value of an existing key, or if it doesn't exist, insert a given key and return that instead?
11:14:10 <Peaker> (For use with atomicModifyIORef, so that I  can race threads and have one of them "win" and get to put its own key in the map)
11:14:50 <Peaker> I can split it to a lookup and insert, but that might be painful under atomicModifyIORef
11:15:28 <johnw> Peaker: it would need to return the value and the new map
11:15:28 <shachaf> Insert a different key from the one you were looking up?
11:15:47 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/containers-0.5.0.0/Data-Map-Strict.html#v:insertLookupWithKey ?
11:15:53 <geekosaur> (or the Lazy variant)
11:15:53 <Peaker> johnw, yeah
11:15:58 <geekosaur> oh
11:16:06 <Peaker> no, that just does both things at once
11:16:23 <Peaker> though it may be useful for me
11:16:41 <Peaker> I guess it's pretty close :)
11:16:45 <Cale> Why would that be painful under atomicModifyIORef?
11:17:38 <Cale> You might also consider using async to race the threads, and then put the result into the map after?
11:18:23 <shachaf> Maybe the answer to my question was too obvious.
11:19:01 <Peaker> does it sillily pass the given function as args the other given args?
11:19:08 <Peaker> that's unnecessary and confusing :(
11:19:24 * hackagebot arrow-improve 0.1.0.0 - Improved arrows.  http://hackage.haskell.org/package/arrow-improve-0.1.0.0 (alynn)
11:19:25 <Cale> wat
11:20:31 <johnw> Peaker: using lens the function is not that hard: f k v m = m & at k .~ ((m ^. at k) `mplus` Just v)
11:20:38 <johnw> but I'm not aware of anything already available
11:20:47 <johnw> oh, sorry, that doesn't even return the element
11:20:49 <johnw> n/m
11:21:03 <Peaker> insertLookupWithKey -- it takes a function from a user and feeds it stuff the user just did, seems silly
11:21:15 <Peaker> k -> a -> a -> a   when it probably should be:   a -> a
11:21:58 * shachaf sighs
11:24:08 <Peaker> shachaf, I didn't understand your question, sorry
11:25:09 <shachaf> I should say the same thing.
11:25:23 <shachaf> «Is there a nice Data.Map API to return the value of an existing key, or if it doesn't exist, insert a given key and return that instead?» -- is "existing key" different from "given key"?
11:29:48 <shachaf> Oh well.
11:30:08 <johnw> Peaker: anyway, you can certainly write a new function to achieve the behavior you want, even if it's not in the core libraries
11:32:37 <jonkri> What's the monadic equivalent of the mapAccum functions?
11:32:41 <shachaf> It is nearly in the core libraries, and Peaker is gone.
11:32:56 <jonkri> Well, "monad equivalent"...
11:34:56 <johnw> jonkri: you could always achieve the same effect using foldM returning a tuple, and then read out the member of the tuple you want at the end
11:35:11 <johnw> I'm not finding a mapAccumML anywhere...
11:35:52 <johnw> ah, wait, someone has written one
11:37:04 <johnw> hmm... here: http://hackage.haskell.org/package/test-framework-0.8.0.3/docs/Test-Framework-Providers-API.html
11:37:07 <johnw> if you wanted to copy it out
11:37:55 <jonkri> Thanks, johnw!
11:41:54 <arpunk> jonkri: Hi, didn't see you here :), I just replied on the issue in lambdatrade-server
11:42:53 <jonkri> arpunk: Hi! Cool, thanks. :) I'm super-busy with some other things at the moment, so I will have to get back to you when things calm down a little bit.
11:43:38 <arpunk> jonkri: Sure thing, I'm busy too so I'll probably check things out in a few days, no hurries
11:48:28 <d3lxa> how can I told my cabal sandbox to ignore package installed on my system? or to install everything needed in the sandbox?
11:48:51 <bennofs> d3lxa: cabal sandbox cannot ignore system packages
11:49:07 <dcoutts> d3lxa: your sandbox will ignore your user package db, but always includes the global one
11:49:08 <bennofs> d3lxa: it does ignore user packages through
11:49:20 <geekosaur> maybe you want hsenv instead of cabal sandbox?
11:50:43 <d3lxa> then if a package A is already on my system but outdated, can't I tell my sandbox to install the new version inside?
11:51:39 <bennofs> d3lxa: it's a limitation of GHC. GHC cannot ignore the system (global) package database, iirc
11:51:56 <d3lxa> I can't get to install yesod-platform on my machine although I just did on my laptop, seems the system packages are outdated and conflict with them
11:52:48 <bennofs> d3lxa: Have you tried installing only ghc and cabal via your system package manager, and installing the rest through cabal?
11:53:37 <edwardk> johnw:	f k v m = m & at k .~ ((m ^. at k) `mplus` Just v)   is probably better as    f k v m = m & at k %~ (<|> Just v)   -- one pass
11:53:42 <d3lxa> bennofs: I did install some packages with my PM, that's the problem, yeah
11:55:01 <johnw> edwardk: ah, nice, thank you!
11:55:37 <edwardk> i guess you can trim it further
11:55:45 <d3lxa> oh it seems I can just do Use --force-reinstalls if you want to install anyway. << hum
11:55:49 <edwardk> f k v = at k %~ (<|> Just v)
11:56:08 <geekosaur> you can do that but beware of stuff breaking
11:56:57 <d3lxa> geekosaur: really? but, why? it could break *inside* the sandbox, not outside right
11:58:00 <geekosaur> "diamond dependency". package A was built against package B, you install a new version of package B, then try to build something that uses A and B at the same time so you are trying to link against both versions of B
11:58:09 <geekosaur> (ghc is sometimes a pain in the arse)
11:59:16 <c_wraith> just never have more than one version of the same package installed in the same context.  It never leads to good things.
11:59:59 <geekosaur> which is difficult when one of them is a system package and impossible if it's a bootlib (that is, one installed with and used by ghc itself)
12:00:02 <d3lxa> geekosaur: oh yeah I see thank you; then if you could install all packages from scratch, that would solve the problem, unfortunatly you said it's not possible
12:00:16 <geekosaur> that would be my pointing to hsenv earlier
12:00:40 <bennofs> d3lxa: just only install ghc and cabal from your system package manager and install then rest trough cabal in a sandbox
12:00:53 <geekosaur> you can install a separate ghc with minimal packages (only bootlibs) and then install eveyrthing you need as user packages, without disturbing or risking breaking the main one
12:01:19 <d3lxa> bennofs: yeah I know, but I didn't know when I've setup my system first, I did it correctly on my laptop though :)
12:01:20 <c_wraith> yeah..  If you never use system packages, things are way better.
12:01:32 <bennofs> d3lxa: Can't you uninstall the offending packages?
12:02:02 <d3lxa> bennofs: yeah, I started but my system is not a clean state, hum :) I plan to migrate anyway, hum
12:02:06 <geekosaur> (cabal sandboxes user packages, hsenv sandboxes an entire installation)
12:03:41 <d3lxa> c_wraith: if there wasn't yesod-platform to fix deps versions, everything would be a nightmare to install due to dependency problem, etc, I had them
12:04:30 * geekosaur rather suspects that at some point we're going to end up doing whole-program compilation to deal with this stuff
12:05:19 <bennofs> Why don't packages just depend on exact versions of their dependencies? To benefit from security, etc fixes in their dependencies without changing the package?
12:06:21 <bennofs> Hmm, I just noticed that that wouldn't solve this issue (having multiple versions of the same package), it would even complicate it
12:06:30 <geekosaur> because it's not a question of what source versions it is compatible with, it is that versions do not capture ABIs
12:06:57 <geekosaur> and package internals getting exposed for inlining means *exact* binary compatibility is required for a compiled package
12:09:51 <d3lxa> geekosaur: that's why some use version with ABI/API compatibility: major/minor etc
12:10:17 <geekosaur> I am apparently not explaining things very well
12:10:23 <d3lxa> I don't know if the haskellers use this strategy but it works in system packages
12:10:23 <geekosaur> it is not a question of versioning
12:10:43 <geekosaur> d3lxa: system packages don't change what's exported for inlining every time thery are compiled
12:10:50 <d3lxa> you can tell whether the ABI changed with a new major version, no?
12:11:13 <geekosaur> ok, I am clearly failing to communicate
12:11:13 <d3lxa> maybe that's an over-simplification
12:11:28 <d3lxa> I think I'm the one at fault geekosaur :) sorry
12:11:32 <geekosaur> the parts exported for inlining are not just the exported API
12:12:08 <geekosaur> it's internals, and the exact parts of the internals and their exact binary implementation changes when recompiled (this could be argued as a bug but it's a hard one to fix)
12:12:19 <geekosaur> so it is not a version. it is an exact compiler output
12:13:49 <d3lxa> oh okay I see, thanks
12:13:51 <geekosaur> if you recompile the exact same source with the same version of the same compiler, the result is not binary compatible with the first one
12:14:22 <geekosaur> this is a massive pain in the *ss and the cause of what is miscalled "cabal hell"
12:14:33 <dart_> hi
12:14:46 <geekosaur> cabal's just the messenger, trying to figure out how to not trigger ghc being stupid
12:14:57 <dart_> has anyone any experience with the ATS language ?
12:18:35 <prophile> so, quick arrow question - an arrow forms a category, Arrow gives products and a functor from Hask, and ArrowChoice gives coproducts; is there a similar interpretation for what ArrowLoop adds?
12:22:35 <simpson> prophile: IIUC it adds recursion. What's with the improved arrows package? What does it do? There aren't any docs...
12:23:02 <prophile> simpson: apologies, I'm new to the whole hackage situation
12:23:34 <simpson> prophile: No worries. I just saw Cale's "wat" and would like to add my own "wat". I know that there's a lot of problems with existing Arrows and was wondering what your package aims to improve.
12:23:48 <prophile> ah, I'm afraid I'm going to greatly disappoint you
12:24:00 <prophile> it's roughly just the equivalent of coyoneda for arrows
12:24:04 <ownclo> Hi! Is a functional language needs to be strongly typed?
12:24:09 <Cale> ownclo: no
12:24:26 <ownclo> I always thought that typing and functional-ity are orthogonal
12:24:32 <Cale> ownclo: There are quite a few which are dynamically typed.
12:24:34 <prophile> as in it's just a trick to make sure that arr f >>> arr g is merged into arr (g . f)
12:24:49 <ownclo> Cale: these are still strongly typed
12:25:08 <prophile> perl has a lot of functional aspects
12:25:11 <Cale> ownclo: Okay, what's your definition of "strongly typed"?
12:25:12 <prophile> and it's weakly typed
12:25:36 <Cale> "strong" isn't actually a technical term, but I took what you said to mean "statically typed"
12:25:51 <ownclo> Cale: I agree that the term is a bit vague
12:26:39 <Cale> In certain company, I'd tend to call languages "untyped" if all they have is a dynamic type system.
12:26:40 <ownclo> I think that the main point of "strong" typing is the absence of implicit coercions
12:26:48 <simpson> "Strength" of typing systems is, in the dynamically-typed language world, how seriously values of types resist being coerced automatically or implicitly.
12:27:13 <simpson> For example, Python is "stronger" than C is "stronger" than Perl is "stronger" than JS is "stronger" than PHP.
12:27:31 <Cale> heh
12:27:42 <Cale> Okay
12:27:53 <ownclo> I was at the erlang talk, where the speaker told that "Erlang is pure because, among other reasons, it is strongly typed"
12:28:03 <ownclo> I said, like, "wat?"
12:28:10 <Cale> Well, most variants of lisp do some amount of implicit numeric conversion.
12:28:13 <prophile> it refers to how hard you press the keys when you type programs in it
12:28:15 <simpson> Ugh, "pure" is nebulous.
12:28:19 <avpx> Words: do they actually mean anything?
12:28:21 <Cale> ownclo: Yeah, that's nonsense.
12:28:48 <prophile> in that sense PHP is very strongly typed because I half destroy keyboards whenever I have to use it
12:28:53 <Cale> hah
12:29:13 <ownclo> Cale: He said that in order to be referentially transparent, a language need to be strongly typed (either dynamically or statically)
12:29:25 <ownclo> so, that is a nonsense, right?
12:29:39 <Cale> Right.
12:29:43 <avpx> yeah, wat?
12:30:01 <ownclo> Few.. Thank you so much, I felt myself a man from another universe
12:32:07 <jgross_> I'm trying to port some code from an old version of GraphViz.  They seem to have removed the URL datatype, calling it broken, but I don't see any way to get a URL into an SVG file.  Is there a good way to do this?
12:32:26 <ziggystar> Anyone using EclipseFP? I'm rather new to Haskell and it seems I'm getting nowhere with this program. I want to run the tests from within EclipseFP, But I simply cannot create a test run configuration from any context menu. And when I somehow force-create one from the menu it doesn't work. But the tests run with `cabal test`.
12:32:46 <pjdelport> quick question: how do you force stdout to be unbuffered?
12:32:56 <bennofs> pjdelport: hSetBuffering stdout NoBuffering
12:33:04 <bennofs> pjdelport: you need import System.IO for that
12:33:10 <pjdelport> thanks :)
12:45:10 <jrmithdobbs> can anyone think of a reason why aeson is holding on to ~4X mem as the size of the document being streamed from stdin before any values ever reach "stuff" in let foldit = (ifoldr (\x y z -> z |> (x,y)) S.empty) . (^. _2._Object) in runResourceT (sinkHandle stdin =$= CA.conduitParser json' =$= CL.mapFoldable foldit =$= stuff $$ sinkHandle stdout)
12:46:06 <jrmithdobbs> i've played around and replaced stuff with something that just re-encodes the data and it still eats the same ammount of ram =/
12:46:24 <jle`> i have notice that haskellers do a lot of squinting
12:47:19 <bitemyapp> jle`: yeah, I've caught myself doing more of that - the more I learn Haskel
12:47:21 <bitemyapp> Haskell*
12:47:48 <bitemyapp> jle`: good example, this quote from HN: "it's much better to catch bugs at run-time, because ... your compiler takes much longer to run than your REPL does to eval."
12:47:53 <bitemyapp> I squinted hard.
12:48:37 <jrmithdobbs> profiler says all that ram except for the ~document size chunk where I expect it in my code there thanks to that seq is inside of jstring_ :(
12:49:34 <syao> hello, wanted to ask: how does Law of Demeter apply to haskell?
12:50:22 <jrmithdobbs> hrm, maybe it's the escaping in the source document, i knew it'd backtrack on escaping fairly badly but didn't think about ram usage
12:50:24 <prophile> syao: I'm not sure it does
12:50:39 <prophile> the law of demeter is about objects and methods is it not?
12:51:12 <ziggystar> In EclipseFP, I'm always getting the following warning on the console: "<command line>: cannot satisfy -package Cabal-1.19.2
12:51:13 <ziggystar>     (use -v for more information)" Does this mean anything?
12:51:33 <ziggystar> I have cabal 1.19.2 installed.
12:52:06 <syao> prophile, kind of yes, IMO the idea can be extended to haskell too.
12:53:31 <mornfall> prophile: LoD only applies to OOP by extension :) otherwise, it's a good and fairly universal guiding principle in design
12:54:02 <jrmithdobbs> heh, removing the escaping cut out >25% of the runtime (fuzzy testing document, heh) but didn't affect the ram usage ... i can't figure out wtf is doing this
12:54:11 <mornfall> prophile: opaque newtypes are a good example, and so are (some) typeclasses
12:54:22 <prophile> ok
12:54:31 * hackagebot shake 0.11.2 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11.2 (NeilMitchell)
12:55:47 <syao> p.s. do you know good IRC channel for functional programming languages (the universal one)?
12:57:17 <jordan_> I have a quick question about haskell type signatures.
12:58:17 <ziggystar> So is this the wrong place to get some help about EclipseFP?
12:58:35 <bitemyapp> ziggystar: it's not the worst place.
12:58:44 <jordan_> I'm trying to implement the Extended Euclidean Algorithm, and I'm fairly new to Haskell. I have this type signature: temp :: (Num a) => (a, a, a) -> (a, a, a) -> (a, a, a) and the function temp b (_, _, 0) = (1, 2, 3)
12:58:48 <bitemyapp> ziggystar: don't ask to ask, just beg forgiveness if people tell you it's the wrong place.
12:59:01 <bitemyapp> it's an obvious enough place to check that you'd get the benefit of the doubt anyway.
12:59:21 <ziggystar> I already asked, but got no response. So I was wondering whether no one here uses it.
13:00:04 <prophile> jordan_: Num doesn't contain division
13:00:13 <ziggystar> Just trying to estimate my odds.
13:00:34 <prophile> jordan_: Integral may be a more useful typeclass here
13:00:41 <jordan_> prophile: Oh, okay, thanks
13:00:52 <prophile> jordan_: and the extended euclidean algorithm would be a -> a -> (a, a, a), wouldn't it?
13:00:57 <jordan_> I was going to use quot since it floors the result
13:01:04 <bitemyapp> ziggystar: eh. IRC questions often don't get immediate answers, especially if they address a subset of the people in the channel.
13:01:11 <prophile> quot is part of the Integral typeclass, not Num :)
13:01:12 <bitemyapp> ziggystar: is it an Eclipse problem or an eclipse fp problem?
13:01:12 <c_wraith> ziggystar: eclipsefp isn't that popular.  You're probably best off going to more specialized places, if any exist
13:01:18 <jordan_> I'll try that! Thanks!
13:01:32 <bitemyapp> ziggystar: most Haskell users are on Emacs/vim/sublime text
13:02:24 <jordan_> prophile: I was going to have two function, eea and eea'. The eea function creates the first two rows in the EEUA table, and passes those as tuples to eea'
13:02:45 <jordan_> And I use the word 'create' very losely
13:02:51 <prophile> okay, gotcha
13:02:52 <benbangert> so uh, when running cabal update, I get "cabal: Codec.Compression.Zlib: premature end of compressed stream", is there a problem with hackage or my cabal?
13:02:54 <ziggystar> I'm already using vim and find the support for Haskell ok. But I'm somehow expecting a bit more, so I wanted to try EclipseFP.
13:03:08 <prophile> benbangert: I've had exactly the same thing today
13:03:18 <prophile> I would speculate that it's hackage
13:03:21 <jordan_> It worked! thanks prophile!
13:03:30 <prophile> jordan_: no worries :)
13:08:17 <burbul> I need a simple queue. Data.Queue docs suggest using Data.Seq, but thaat looks like overkill. (view patterns, etc.)
13:08:34 <burbul> any pointers would be welcome
13:10:16 <jrmithdobbs> Seq really is probably what you want, just don't use the bits you don't need
13:10:33 <burbul> ok -- thanks
13:13:15 <benbangert> prophile: is there anyone in here that could alert the hackage admins to the issue?
13:13:16 <burbul> data ViewL a     = EmptyL   | a :< Seq a
13:13:27 <prophile> benbangert: no idea
13:13:30 <prophile> :<
13:13:48 <burbul> is (:<) just a normal type constructor?
13:13:51 <c_wraith> Seq is kinda slow, in terms of constant factors.  A standard double-list queue has better amortized constant factors, at the cost of higher worst-case constant factors.
13:13:55 <prophile> burbul: yes
13:14:09 <c_wraith> err,  data constructor, not type constructor
13:14:09 <geekosaur> data constructor?
13:14:28 <c_wraith> burbul: you don't need to use ViewL at all to use Seq
13:14:30 <FreeFull> Just is a data constructor
13:14:32 <burbul> yes, sorry. havent seen operator-as-data-constructor before
13:14:39 <FreeFull> Maybe is a type constructor
13:15:12 <burbul> so you can just write
13:15:27 <burbul> data A  = Int +++ Int
13:15:33 <c_wraith> no
13:15:40 <c_wraith> operator constructors must start with :
13:15:47 <burbul> ok
13:15:49 <burbul> thanks
13:16:02 <c_wraith> It's a "capital letter".  :)
13:16:46 <burbul> ah!
13:16:52 <c_wraith> remember, in Haskell you must be able to distinguish data constructors from other identifiers lexicographically, for pattern matching
13:17:04 <vozz> Is there some guide somewhere to figuring out ghc error messages? Half the time I have no idea what it's talking about
13:17:16 <c_wraith> That lexical determination is done by "does it start with a capital letter?"
13:17:26 <burbul> vozz: google the msg?
13:17:47 <vozz> burbul: that's what I always end up doing but it isn't always helpful. It'd be nice to understand them
13:17:53 <c_wraith> And so : is treated as a capital letter for operators.  It's the only "capital letter" for operators.
13:18:08 <burbul> vozz: give an ex.?
13:18:32 <burbul> c_wraith:thanks
13:18:43 <vozz> burbul: no instance for *something* arising from a use of *other thing*
13:19:01 <c_wraith> vozz: the first thing in *something* will be the name of a class
13:19:15 <c_wraith> vozz: *other thing* will be code that uses functionality from that class
13:19:37 <c_wraith> vozz: the rest of *something* will be the type(s) inferred, which aren't an instance of the necessary class
13:20:04 <burbul> google works fairly well there: http://stackoverflow.com/questions/16154592/haskell-no-instance-for-eq-a-arising-from-a-use-of
13:20:16 <burbul> (searched for 'arising from a use of')
13:20:22 <dagle> Can you disable warnings for unused bindings for 1 file in a project?
13:20:30 <burbul> not saying it always works, but...
13:20:48 <c_wraith> dagle: you can put an {-# OPTIONS_GHC #-} pragma disabling it at the top of the file
13:20:51 <vozz> Ah thanks, I think I understand now
13:21:01 <dagle> c_wraith: Ty.
13:21:27 <quchen> dagle: GHC also won't emit warnings for names that start with "_".
13:21:45 <quchen> So `f x y _unused = x*y` won't emit a warning for the unused parameter.
13:22:05 <dagle> Hmm.
13:22:28 <c_wraith> right..  That also has the advantage of documenting that you're not using that binding intentionally
13:22:32 <quchen> I think this is also the recommended behaviour of the Haskell Report.
13:22:38 <burbul> failing google, people here are really nice in my exp.
13:22:52 <burbul> or stackoverflow
13:23:06 <dagle> Well, it's because I use aeson to generate from and to json bindings.
13:24:44 <dagle> I guess I could add a _, that will be later though.
13:25:37 <quchen> Underscores make your intention explicit, and when you add another unused name to the same file later that one will emit a warning.
13:26:04 <quchen> When you turn off all "unused" warnings in the compiler that might bite you later.
13:29:02 <burbul> can you have a 'type' statement local to a function?
13:29:12 <burbul> so e.g if I have
13:29:12 <geekosaur> no
13:29:28 <burbul> no extensions to let you do it? :(
13:29:55 <burbul> [It would be nice to be able to locally hide the polymorphism]
13:30:50 <syao> what do you think, haskell is ready for production and enterprise?
13:30:51 <codonnell> cabal is giving me some real trouble right now; I was hoping someone had an idea of how to fix this
13:31:10 <codonnell> whenever I try to 'cabal update' I get the error cabal: Codec.Compression.Zlib: premature end of compressed stream
13:31:32 <codonnell> I put up the output of cabal update -v3 at http://pastebin.com/Va102hcH
13:32:11 <geekosaur> codonnell, others are seeing it and it's believed to be a problem with hackage
13:32:14 <dcoutts> codonnell: it's started doing this this afternoon, I'm currently investigating
13:32:25 <prophile> it's also causing travis builds to fail
13:32:28 <prophile> it's quite interesting
13:32:40 <codonnell> ok, as long as other people are having the same problem
13:32:53 <codonnell> and it's being looked into
13:34:34 * hackagebot vinyl 0.2.1 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.2.1 (JonSterling)
13:42:16 <sordid> Hi,
13:42:30 <sordid> I have a hard time wrapping my head around state monads.
13:42:45 <sordid> The return value of one function is State Env Int
13:42:56 <sordid> ...and I want to use that Int to add it to a string
13:43:04 <sordid> ...but I can't figure out how to do it
13:43:11 <sordid> I've pasted a code fragment here:
13:43:12 <joelteon> code?
13:43:16 <sordid> http://lpaste.net/6306113245912498176
13:43:28 <vozz> Why does every tutorial about the state monad use State, when it isn't exported from Control.Monad.State?
13:43:31 <sordid> This does not compile
13:43:42 <sordid> in lines 18-21 I try to make use of those Int values
13:43:50 <joelteon> sordid: you should be using "l1 <- newLabel"
13:43:54 <geekosaur> vozz: a lot of them are old, State went away somewhat recently
13:44:15 <geekosaur> (the standalone State monad was replaced with a transformer over Identity)
13:44:24 <vozz> geekosaur: What should I be using instead?
13:44:46 <geekosaur> if you replace State with state, it should generally work
13:45:29 <geekosaur> (you can't name functions with initial uppercase so it's not possible to make a completely drop-in replacement without going back to duplicated code for State and StateT_
13:45:30 <sordid> joelteon: thanks a lot! It works now. :)
13:46:02 <joelteon> sordid: do you understand why that makes it work?
13:47:13 <sordid> joelteon: I'm not sure, to be honest
13:47:50 <joelteon> do you understand how 'do' notation works, and how it relates to monads?
13:48:17 <sordid> yes, I know about that
13:48:26 <sordid> so the a
13:48:29 <joelteon> but you're not sure about how the state monad works?
13:48:41 <sordid> the arrow is necessary for any kind of interaction with monads?
13:48:53 <sordid> the state monad itself is something I haven't encountered until today
13:49:12 <sordid> but we did cover 'do notation' in some detail already
13:49:18 <joelteon> do { a <- f; return a } expands to f >>= \a -> return a
13:49:21 <joelteon> which is a bit redundant
13:49:26 <joelteon> but it's important to know how (>>=) works
13:51:05 <sordid> I'm not sure if I'm really firm in this, but in my understanding, >>= passes the results of the previous computation on
13:51:10 <sordid> is this approximately correct?
13:51:23 <mm_freak_> sordid: have you looked at its type?
13:51:33 <mm_freak_> :t (>>=)
13:51:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:52:20 <mm_freak_> replace 'm' by your favorite monad, which is of course IO
13:52:27 <mm_freak_> IO a -> (a -> IO b) -> IO b
13:52:47 <sordid> Ah!
13:53:10 <mm_freak_> putStrLn has the problem that it takes a String, not an IO String
13:53:19 <mm_freak_> so (>>=) is the glue to combine getLine with putStrLn
13:53:30 <mm_freak_> getLine :: IO String; putStrLn :: String -> IO ()
13:53:35 <mm_freak_> getLine >>= putStrLn :: IO ()
13:53:38 <sordid> okay, I think I get it now
13:53:46 <tac> >>= is what pulls the String out of the IO String for you to work with
13:53:53 <mm_freak_> and all of do-notation translates to (>>=)
13:54:11 <mm_freak_> 'do str <- getLine; putStrLn str' = getLine >>= putStrLn
13:55:02 <jfischoff> does this have a name? foo f = either f id
13:55:10 <mm_freak_> jfischoff: unlikely
13:55:14 <mm_freak_> just use 'either'
13:55:38 <mm_freak_> jfischoff: oh, well, it does sometimes have a name
13:55:46 <jfischoff> oh?
13:55:49 <mm_freak_> 'catch'
13:56:00 <jfischoff> cool
13:56:15 <mm_freak_> interpret Right as result, Left as exception
13:56:25 <mm_freak_> then Either is a family of exception-monads indexed by exception type
13:59:23 <mm_freak_> jfischoff: i guess a more sensible name would be runEither
13:59:28 <mm_freak_> :t \f -> either f id
13:59:29 <lambdabot> (a -> c) -> Either a c -> c
13:59:32 <mm_freak_> :t catch
13:59:33 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
13:59:52 <mm_freak_> in the case of 'catch' the monad does not disappear
14:00:37 <bennofs> flip either id is short enough IMO
14:01:15 <Taneb> :t (+++)
14:01:16 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
14:01:21 <Taneb> :t (|||)
14:01:22 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
14:01:25 <jfischoff> maybe foldLeft/foldRight ?
14:01:27 <Taneb> :t (||| id)
14:01:28 <lambdabot> (b -> a) -> Either b a -> a
14:03:35 <mm_freak_> jfischoff: either is a fold
14:03:43 <mm_freak_> or rather it's /the/ fold
14:03:49 <jfischoff> yes that is where I got the name from
14:04:11 <mm_freak_> but i do agree with bennofs here
14:04:37 * hackagebot stomp-queue 0.1.3 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.1.3 (TobiasSchoofs)
14:05:17 <mm_freak_> i even prefer 'maybe x id' over 'fromMaybe x'
14:06:43 <jfischoff> mm_freak: you crazy ;)
14:07:35 <jrmithdobbs> mm_freak_: fromMaybe comes in handy when you have multiple levels of maybe and need to do something before the final join though
14:14:58 <stevejb> Hello! I am using  Control.Monad.Par.parMap (mapping in parallel), on a list that may take a few minutes to evaluate. How can I monitor the progress of the mapping operation in a way that I can report to a user?
14:17:22 <pranz> app ((+1), 1)
14:17:30 <pranz> > app ((+1), 1)
14:17:33 <lambdabot>  2
14:17:48 <darkPassenger> Hi guys,
14:18:11 <darkPassenger> how can I use an operator defined in an instance in a class ?
14:18:47 <darkPassenger> http://pastebin.com/Q0jU7rQz
14:18:54 <darkPassenger> im trying to use the operator ==
14:19:00 <darkPassenger> and i dont understand what I am doing
14:19:04 <darkPassenger> i try ..
14:19:14 <milfjord> what
14:19:23 <Yaniel> :t ==
14:19:24 <lambdabot> parse error on input `=='
14:19:35 <pranz> :t (==)
14:19:36 <simpson> :t (==)
14:19:36 <lambdabot> Eq a => a -> a -> Bool
14:19:37 <lambdabot> Eq a => a -> a -> Bool
14:19:44 <pranz> darkPassenger: try to use names that aren't already used
14:19:45 <milfjord> first off, there's already a >= in the Prelude
14:19:50 <pranz> there already is a function (>=)
14:19:55 <milfjord> second, 'true' is not in scope
14:20:16 <milfjord> third, 'if X then True else False' can be simplfied to 'X'
14:20:32 <milfjord> fourth, that code doesn't even contain ==
14:21:21 <pranz> x >= y = not (x < y)
14:22:17 <darkPassenger> So i have to use operators that arent in the language already
14:22:26 <darkPassenger> well in whats already loaded (prelude)
14:22:37 <geekosaur> no, you have to use operators that are not defined by classes
14:22:50 <geekosaur> although it's a good idea not to try to steal other operators as well
14:23:01 <darkPassenger> geekosaur: so i have to make it up
14:23:07 <geekosaur> (andin fact there are ways to "steal" those operators, but it's a very bad idea)
14:23:09 <darkPassenger> like ^[ operator
14:23:32 <pranz> darkPassenger: yeah sure
14:23:42 <darkPassenger> no shit ?
14:23:44 <darkPassenger> i men
14:24:03 <simpson> darkPassenger: Well, what are you trying to build?
14:24:15 <geekosaur> basically, in C++ you reuse operators because you must. the result is horrors like >> meaning either bit shift or output depending on context
14:24:39 <milfjord> *input
14:24:44 <darkPassenger> simpson: im really just trying to get the whole class idea in haskell and to be able to override an operator ...
14:24:49 <geekosaur> sorry, input yes
14:25:00 <geekosaur> btu completely unrelated, and this is very bad design
14:25:09 <simpson> darkPassenger: Don't override; create new operators for the operations that you want.
14:25:35 <pranz> darkPassenger: do you mean make your type an instance of Ord so you can *implement* operators?
14:25:48 <milfjord> (best part: >> on integers has no side effects (>>= does but that doesn't work for I/O))
14:26:11 <pranz> darkPassenger: I'm guessing what you really want is operator overloading
14:26:11 <darkPassenger> pranz: not likely , since i havnt understood very well what you just said
14:26:34 <darkPassenger> ahem, yes, as in c++ for example, but I will use whats the mostly used,
14:27:00 <darkPassenger> im trying to explain the class concept to myself in haskell
14:27:02 <geekosaur> you don't use operator overloading for that in Haskell
14:27:13 <darkPassenger> yeah...
14:27:37 <geekosaur> so you define an instance of Ord for your type, and in that instance specify what e.g. (>=) does
14:27:46 <milfjord> classes and operators are unrelated
14:28:04 <milfjord> maybe start with Show or something
14:28:56 <darkPassenger> he4re is a new version that compiles
14:28:58 <darkPassenger> http://pastebin.com/CMZ6aunF
14:29:00 <aloiscochard> how can I print the AST of an expression in the REPL? basically I want to call GHC parser
14:29:18 <darkPassenger> now I coded that in hoping i could do things like that : position 1 2
14:29:32 <darkPassenger> that uses the operator defined in the class
14:29:42 <darkPassenger> is that what classes are used for
14:30:09 <darkPassenger> sorry for the heavy questionning guys..
14:32:10 <simpson> darkPassenger: Typeclasses are used to collect common behaviors of values.
14:32:32 <simpson> Eq is for equality of values, Ord is for ordering of values, etc.
14:32:46 <darkPassenger> so that similar value have similar behavior by "adopting" the classes operator (defined) behavior ?
14:32:56 <pranz> darkPassenger: classes is used to have polymorphic functions to make your code more modular
14:34:27 <pranz> darkPassenger: for example, if you make a collection type and make it an instance for Foldable, Traversable, Functor you'll have a crazy amount of functions at your disposal, even though you only implemented less than 10 functions for your actual type
14:34:29 <milfjord> you keep talking about "classes operator" as if they were inherently related
14:35:06 <pranz> I suggest reading the haskell wiki
14:35:33 <darkPassenger> milfjord: I somehow had the idea that classes were used to define operators on data when you want them to behave one way or another...
14:35:58 <pranz> http://en.wikibooks.org/wiki/Haskell/Classes_and_types
14:36:04 <milfjord> no, classes are used to define methods
14:36:28 <milfjord> those methods can be operators, yes; but that has nothing to do with classes per se
14:36:47 <milfjord> did you look at Show yet?
14:36:57 <milfjord> or Enum
14:37:02 <milfjord> or Bounded
14:38:00 <darkPassenger> milfjord: no,
14:38:26 <darkPassenger> but im reading right now
14:51:17 <dcoutts> codonnell, geekosaur: ok, should be all fixed
14:52:59 <jmob> I'd like something similar to project Euler, but more programming centric, any suggestions?
14:53:13 <jmob> (rather than math centric)
14:56:31 <merijn> @where exercises
14:56:32 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
14:56:39 <merijn> jmob: ^^
14:57:17 <jmob> Wonderful, thanks!
15:06:42 <altschuler> Is there a way to make hlint ignore certain files?
15:12:27 <monochrom> jmob: http://uva.onlinejudge.org/
15:18:27 <benbangert> when using ConfigFile, I parse a file and it seems to sorta work, except I get: Right *** Exception: Prelude.read: no parse. code looks like this: http://paste.ofcode.org/sDUy3dUhSFbw4XapP5vihx
15:18:37 <benbangert> if I leave out one of the keys it needs, I get a proper Left error....
15:19:08 <monochrom> so colourful
15:19:11 <benbangert> it appears as if I almost get a proper Right response out, but then an exception hits
15:20:08 <benbangert> monochrom: ah, there's a theme toggle at the button if there's too many colors in the way ;)
15:20:27 <benbangert> just wondering what is going on since the code seems pretty basic....
15:22:10 <monochrom> I don't know ConfigFile. I can't see what goes wrong
15:41:17 * joe_kiniry Just received a copy of Mena's "Beginning Haskell" this week and am sharing it around the office (@GaloisInc).
15:41:28 <jmob> monochrom, sweet
15:42:29 * monochrom fakes news headline: "Galois employees upgrade Haskell-fu by reading Beginning Haskell"
15:42:47 <joe_kiniry> LOL
15:45:07 <hpc> nonono, they are studying the initial haskell in the programming algebra
15:45:46 <monochrom> haha
15:45:52 <hpc> (which is also coterminal, of course)
15:47:28 <jmob> Anyone know rumors of a 2nd edition for real world haskell?
15:47:33 <Rembane> joe_kiniry: Is it good or are you evil? :)
15:47:41 <erisco> is there a function to take a string with whitespace and convert the whitespace to equivalent escape squences (\n, \r, etc)
15:48:08 <joe_kiniry> Hey, I'm good Joe these days!  I shaved, after all.
15:49:28 <hpc> joe_kiniry: you wear your goatee on the inside!
15:50:07 <joe_kiniry> And my long hair.
15:50:07 <joe_kiniry>  
15:51:34 <RichyB> erisco, show :: String -> String, might be what you want. ((read :: String -> String) . (show :: String -> String)) == id
15:52:00 <erisco> RichyB, no because I do not want to add quotes or escape quoting
15:52:05 <erisco> it is okay I can just write something myself
15:52:34 <RichyB> erisco, why do you want to do that? If it's to escape text that's meant to be embedded into some other context then you'll need a quoting function specific to that context
15:53:31 <monochrom> wut? GHC 7.8 comes with transformers?
15:54:27 <sipa> is there a function optimus' ?
15:54:39 <djahandarie> Damn it, beat me to it.
15:54:41 <monochrom> oh! because GHC API wants it
15:54:51 <erisco> RichyB, yes this is true. thanks
15:54:58 * djahandarie was going with "Yeah. They didn't have enough money to package in the decepticons though."
15:55:26 <monochrom> about optimus prime, you may like: http://www.vex.net/~trebla/photo/unorganized/optimus-prime.jpg
15:59:13 <monochrom> it's taken outside a math club in a university :)
16:00:40 <ion> hah
16:01:13 <ion> d Optimus = dx times Optimus Prime
16:01:56 <monochrom> or, Optimus Prime times dx, which looks totally normal, like f'(x) dx
16:03:49 <benbangert> monochrom: I was trying to read a value in a context that required a Bytestring, and Configfile can't read Bytestring's directly. so weee, fixed :)
16:10:54 <simpson> @src sequence
16:10:54 <lambdabot> sequence []     = return []
16:10:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:10:54 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:42:38 <n3hima> what's the easiest way to create a file and write to it?
16:45:15 <monochrom> writeFile
16:45:30 <fragamus> hey guys I have some numbers that range from 0 to 255   I want to write them to stdout as ascii    how is this done without translation
16:45:49 <n3hima> but when I try to use writeFile to write to a file that doesn't exist yet, it gives me a file not found error
16:45:58 <monochrom> the range 128-255 is not ascii. please revise the question
16:46:13 <fragamus> well… binary
16:46:16 <geekosaur> "without translation" so you have a terminal that doesn't do utf8? or do you just not have any idea how locales work at all?
16:46:19 <fragamus> I want to write binary
16:46:24 <n3hima> fragamus: mapM_ (putStrLn . show) [0..255]
16:46:28 <n3hima> maybe?
16:46:31 <geekosaur> so you think there's some magic the program can do that will cause the terminal to not do utf8
16:46:46 <fragamus> im using posix pipes and it's video data
16:46:51 <fragamus> not characters
16:47:10 <monochrom> then Data.Bytestring has some I/O routines you will like
16:47:15 <fragamus> yay
16:48:06 <monochrom> writeFile works for me, pre-existing or not
16:48:41 <vozz> Anyone use vim for haskell? What plugins do you use?
16:48:49 <n3hima> emacs
16:49:38 <davidfetter_disq> http://projects.haskell.org/haskellmode-vim/ <-- from the site. not sure what it'll do, though
16:49:55 <vozz> Apparenlty it hasn't been updated in years
16:49:56 <hpc> i use just the default haskell syntax highlighting
16:50:05 <davidfetter_disq> more stuff http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
16:55:11 <jmcarthur> vozz: i use emacs + evil-mode, if you are willing to possibly miss out of some of the more advanced vim features in favor of some of the more advanced emacs/haskell-mode features
17:05:32 --- mode: ChanServ set +o geekosaur
17:06:04 * johnw wonders when they are going to come out with diabolical-mode
17:07:05 --- mode: geekosaur set -b yellowfish!*@*
17:07:20 <dagle> Can you with cabal see what modules are installed and depending on that choose what files to build for your project?
17:07:21 --- mode: geekosaur set -o geekosaur
17:07:24 <dagle> Or something like that.
17:07:32 <johnw> what files to build?
17:07:54 <dagle> Well, the package is a collection of tools for taffybar.
17:08:06 <dagle> And my dependecy list is growing really fast.
17:08:30 <dagle> And I don't want people to be required to have them all or having tons of flags.
17:08:30 <johnw> I'm not sure I understand what it is that you want
17:08:34 <johnw> list of installed packages: ghc-pkg list
17:08:39 <dcoutts_> dagle: you can have optional dependencies controlled by flags
17:08:46 <johnw> oh, yeah, what dcoutts_ said
17:10:56 <dagle> dcoutts_: But then the user needs to use these flags or will cabal by default compile everything that you have dependencies for?
17:11:21 <johnw> cabal does not do such selective compilation
17:11:38 <johnw> not without the intervention of flags to enable whatever extra things you want to offer
17:12:02 <OceanSpray> so what's the definition of "column" in parsec?
17:12:09 <dcoutts_> dagle: if the user does not specify the flags then the solver will pick a true/false value for them to make things work
17:12:09 <OceanSpray> specifically, w.r.t. spaces and tabs
17:12:34 <johnw> dcoutts_: really?  that's cool
17:12:44 <dcoutts_> dagle: the solver will try where possible to follow the default flag value given in the .cabal file
17:14:05 <dcoutts_> johnw: it's what lets us balance authors desire for fairly automatic optional dependencies with the need for the builder to remain in control
17:14:05 <monochrom> yes, cabal's if-then-else has prolog semantics, not algol semantics
17:15:10 <dcoutts_> johnw: authors sometimes want to do optional deps like "oh I see you have blah installed, in that case I'll use it..."
17:15:18 <monochrom> "if myflag then depend on base==10 else depend on base==5" means: if base-10 is found, set myflag to true; if base-5 is found, set myflag to false
17:16:51 <dcoutts_> johnw: but that just doesn't work. 1. it means the person building cannot say they don't want the extra optional dep, and 2. if the user wanted the optional feature, it's hard for them to work out what was needed to enable it
17:18:13 <dcoutts_> johnw: so we designed the flags stuff to make the connection clear, and still declarative. And so as monochrom says, we found we needed prolog-style semantics.
17:18:32 <n3hima> ok I have a bug with writeFile
17:19:22 <n3hima> writeFile "/tmp/whatever" "sdf" works fine
17:19:56 <n3hima> but (writeFile "~/whatever" "sdf") gives me *** Exception: ~/whatever: openFile: does not exist (No such file or directory)
17:20:15 <monochrom> is "~/whatever" a valid path?
17:20:20 * sm thinks a lot of cabal users don't know about this
17:20:21 <n3hima> yes
17:20:35 <monochrom> that's the problem. it is not valid.
17:20:46 <johnw> I don't think it handles "~", does it?
17:20:49 <n3hima> oh
17:20:51 <n3hima> derp
17:21:08 <n3hima> hmm but I was having the same problem when specifying the path explicity earlier
17:21:14 <n3hima> but now it seems to no longer be reproducible
17:21:16 <n3hima> that is annoying
17:21:42 <monochrom> I hope you do not mean "next, I tried $HOME/whatever" :)
17:22:30 <n3hima> no that would be silly
17:22:37 <monochrom> you need to video-tape your complete dialogue with the computer 24/7 for postmortem analysis :)
17:22:58 <johnw> monochrom: I've contemplated doing that during debugging sessions
17:23:06 <ij> n3hima, ~ has to be programmatically expanded and the kernel doesn't do that
17:23:07 <johnw> really big hard drive + screen recorder
17:23:10 <n3hima> clearly that is what is necessary ;)
17:23:17 <sm> monochrom: is your example exact ? I would have guessed it to mean something more like: if myflag is true (by default or by user request) and there's an install plan with base 10, use that; otherwise look for an install plan with base 5
17:23:35 <n3hima> ij: cool, but I thought haskell might, but obviously not
17:23:40 <monochrom> my example is inexact and incomplete
17:23:56 <johnw> n3hima: I'm pretty sure that are FilePath libraries that will expand that for you
17:24:28 <n3hima> johnw: it's not particularly necessary for my purposes
17:25:42 <ij> n3hima, Btw, almost no bare writefile-like routine in other langs does that.
17:26:45 <n3hima> oh interesting
17:26:47 <n3hima> something to remember
17:27:08 <n3hima> I suppose not everything is unix
17:27:51 <johnw> everything which is not Unix serves to make me love Unix more
17:28:00 <monochrom> on the bright side, more than 80% of the operating systems are like unix :)
17:28:18 <joelteon> @pl \f x y -> f (g x) (g y)
17:28:18 <lambdabot> flip flip g . ((.) .) . (. g)
17:28:26 <johnw> ooh, that's pellucid
17:28:27 <joelteon> :t flip flip
17:28:30 <lambdabot> b -> (a -> b -> c) -> a -> c
17:28:31 <sm> johnw: you haven't tried plan 9 or inferno yet ?
17:28:40 <johnw> i've actually played with plan9 a fair bit
17:29:57 * hackagebot krpc 0.6.1.0 - KRPC protocol implementation  http://hackage.haskell.org/package/krpc-0.6.1.0 (SamTruzjan)
17:30:00 <sm> it sounds like unix but more so
17:30:40 <johnw> there are features in eshell directly derived from the plan9 shell and 9term
17:38:18 <erisco> what is the popular/easy regex library?
17:38:28 <johnw> regex-applicative is pretty  easy
17:38:55 <erisco> thanks I'll take a loo
17:38:57 <pavonia> also regex-compat
17:38:57 <erisco> k
17:39:18 <johnw> the reason I like regex-applicative is that you can upgrade to full on parsec/attoparsec/trifecta with little code change
17:43:04 <erisco> johnw, that is quite enjoyable thanks.
17:43:10 <maurer_> Is there a good way to make cabal link in _everything_ statically, not just haskell libraries?
17:43:25 <maurer_> I'm trying to use yesod keter, which ships a compiled binary, but I get a glibc mismatch on the target system
17:43:45 <maurer_> and I'm willing to just ship my glibc over, bulky though it may be, but don't know of a clean way to tell the cabal file to link it in like that
17:44:20 <johnw> maurer_: --ghc-option=-static?
17:44:58 * hackagebot multiarg 0.24.0.2 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.24.0.2 (OmariNorman)
17:45:30 <maurer_> johnw: e.g. cabal build --ghc-option=-static?
17:45:50 <Algebr> All- Why do we even bother with currying, I'm not understanding its benefit. Is it of similar benefit to like using partial from python's functools?
17:46:00 <johnw> maurer_: yes
17:46:24 <maurer_> johnw: just tried it, resulting binary is still dynamically linked
17:46:28 <johnw> Algebr: currying is how math defines functions of multiple arguments
17:46:32 <johnw> maurer_: :(
17:48:06 <Algebr> johnw, I never remember talking about currying in my math classes...
17:48:31 <kristof> because you never had to actually talk about the act of partially evaluating a function
17:48:33 <johnw> you probably only had functions of one variable, right?
17:48:36 <kristof> but that becomes important in computer science
17:48:52 <Algebr> Not necessarily, I took multi-variable calculus
17:49:21 <Algebr> maybe we did do currying, but it wasn't called that there?
17:49:44 <kristof> Algebr: Here's a better question to ask. Why would you want to not have currying?
17:50:24 <Algebr> kristof, I don't know.
17:50:40 <kristof> Algebr: Partial application of functions pops up in a lot of places in such a way that there aren't any huge, massive advantages to having it, but instead there are lots of little conveniences so that if you were to take them all away someone would feel bummed.
17:50:57 <Algebr> So other programming languages don't have currying?
17:51:09 <kristof> Algebr: Depends what you mean.
17:51:22 <kristof> Algebr: Do you actually use Haskell? I recommend just holding off all your questions until you work through LYAH
17:51:30 <hpc> a very few do, in the sense haskell does
17:51:33 <Algebr> Yes, I'm using it.
17:51:48 <kristof> Algebr: This is more of a convencience thing, but do you know of point free notation?
17:52:05 <johnw> currying adds spice to my functions
17:52:08 <Algebr> no, will have to read up on that.
17:53:45 <kristof> Algebr: fun1 x y = fun2 z x y
17:53:56 <kristof> Algebr: That might be a normal function definition. Because you can curry, you can just write
17:54:01 <kristof> Algebr: fun1 = fun2 z
17:54:29 <Algebr> So you're returning a function with some of the arguments already evaludated?
17:54:34 <Algebr> evaluated*
17:55:06 <kristof> Algebr: double x = 2 * x can turn into double = *2. It's really a convenience thing.
17:55:12 <monochrom> "map (map f) xs" requires currying, look at the "map f" there. you are, of course, welcome to write "map ((\y -> map (f, y)), xs)". I won't join you, thanks but no thanks.
17:55:14 <kristof> Algebr: Lazy language, so know. But if you mean applied, then yes.
17:55:32 <Algebr> ah, many thanks.
17:56:52 <kristof> Algebr: monochrom's example demonstrates the definite convenience you get sometimes. In all honesty, if you're using a language that can return functions, you also want a language that can partially apply them (because you want to return those kinds of functions).
17:57:13 <erisco> johnw, it would be nice if I could complement the parser... ie to say "a match is not this"
17:59:05 <bergmark> did some hacks in fay to get partial application when calling fay functions from js, so that f(x)(y) is the same as f(x,y), something you can't usually do in js since you can always apply extra arguments to functions if you feel like it
17:59:22 <kristof> bergmark: I detect runtime inefficiency
17:59:26 <johnw> erisco: I don't think regex can do that either
18:00:06 <erisco> johnw, regular languages are closed under complement
18:00:50 <bergmark> kristof: not that much i'd imagine. but sure, there's some overhead
18:01:57 <erisco> johnw, if I get time in the future I should augment the library with those operations
18:02:01 <johnw> indeed!
18:02:40 <n3hima> also concatenation, star, union
18:02:43 <kristof> bergmark: Well, you're telling it to construct a function
18:02:51 <n3hima> and is there another one?  I forget
18:03:11 <kristof> bergmark: I just think that you can get away with that in Haskell because of compilation and graph reduction, but you can't get away with that in Javascript (unless you just don't care)
18:03:13 <n3hima> regular languages and GNFA were last semester
18:03:25 <kristof> bergmark: But this is all speculation. Only benchmarks will tell
18:03:36 <johnw> I wonder why some authors say "catenation" instead of "concatenation".  Makes me think they like their chile simple "carne"
18:03:48 <n3hima> haha
18:03:50 <monochrom> intersection
18:04:07 <bergmark> johnw: i like it
18:04:31 <n3hima> hmm yeah intersection I guess
18:04:40 <n3hima> I don't remember that being in the book though, I wonder if there was a reason for that
18:05:12 <monochrom> they think "you know complement, you know union, you can deduce the rest yourself"
18:05:44 <monochrom> for example, symmetric difference, haha
18:05:57 <n3hima> oh yeah it's a footnote after union
18:06:33 <mgsloan_> If you've got complement and union, then you've also got intersection :)
18:06:51 <n3hima> sure but complement and union aren't axiomatic themselves
18:07:02 <monochrom> context-free has a less nice story
18:07:05 <n3hima> anyway bedtime
18:09:14 <erisco> n3hima, yes indeed. given complement and union you can define subtraction
18:09:39 <khyperia> I'm creating a personal IRC bot, and I want it to be plugin-based (so modules can be reloaded at runtime). How would I do this? The "plugins" package?
18:09:53 <erisco> n3hima, concatenation and star are part of the definition of regular languages, so that happens to be a trivial truth
18:10:20 <erisco> n3hima, also with complement and union you can define intersection
18:10:26 <n3hima> yes
18:10:56 <khyperia> If so, it looks like it only supports evaluation of expressions and not files - do I really need to compile to object files first if I want to load a module?
18:11:29 <Rarrikins> khyperia: Either that or use an interpreter somehow.
18:11:46 <khyperia> Ah, never mind, found the module System.Plugins.Make for runtime compilation of modules.
18:16:02 <n3hima> erisco: I've only ever seen regular languages defined as those which can be recognised by a finite automaton
18:16:37 <n3hima> and concatenation and star are not trivial to prove with automata
18:17:03 <n3hima> (they're not hard, obviously, but intersection is at least as hard)
18:17:15 <n3hima> anyway I really need to go to bed
18:17:24 <n3hima> lectures in 6 hours
18:18:02 <erisco> n3hima, a terminal is regular; for regular x, y: x `concatenate` y is regular; for regular x: x* is regular ... then you can show that a finite automaton recognizes exactly regular languages
18:18:13 <erisco> or you can start with the finite automaton as the definition and prove the former :)
18:19:08 <triliyn> Don't you also need alternation?
18:19:20 <erisco> yes thank-you. I figured I forgot something
18:19:38 <erisco> for regular x, y: x | y is regular
18:29:24 <fragamus> Hey guys
18:29:44 <Rarrikins> Sorry. We're closed for lunch!
18:37:34 <igraves> Hey haskell o/
18:37:55 <igraves> I was curious if anybody knew of a Haskell front end (typechecker/parser) that emits type annotated Haskell source
18:38:32 <igraves> GHC seems to emit source that's wrapped up in System FC-style type annotations and I was curious if there was an alternative that's more approachable
18:39:20 <FreeFull> igraves: So just something that adds type signatures to something?
18:39:27 <FreeFull> I mean, for everything
18:39:56 <igraves> FreeFull: Yeah.  Resolving polymorphic types to their actual specialized types would be a major plus, too
18:40:20 <igraves> That's what GHC waits until Core to do, but I'd prefer to avoid working in Core
18:45:08 * hackagebot rainbow 0.6.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.6.0.2 (OmariNorman)
18:50:19 <jforce> Hey, I'm kind of new to Haskell. I'm trying to create the type signature for a function that takes in a list of tuples, and outputs a list of tuples (I'm implemented the Row Reduction algorithm for my Linear Algebra class). I know I could do "rowReduce :: [(Int, Int, Int)] -> [(Int, Int, Int)]" if the matrix width was 3, but what would the type signature be if I didn't know the length of each tuple?
18:51:37 <n^izzo> I have a uber n00b question here; I have a finction; "doubleStr str = str ++ str" when I run doubleStr a I get "<interactive>:10:11: Not in scope: `a'" why?
18:52:10 <Rarrikins> n^izzo: Search for a.
18:52:19 <jforce> n^izzo: Is "a" defined? Did you use "let a = something"
18:52:49 <Algebr> Is the reason we have to do let in ghci because ghci is like inside some kind of function? I mean, I thought that let was used to set local variables inside of a function.
18:53:47 <jforce> To be honest, I'm not sure why. I just know you do. If you meant it as in 'doubleStr "a"' --> "aa", then that's a different story (just use quote marks!)
18:53:51 <igraves> Algebr: being inside ghci is kind of like being inside of the IO Monad, or it's exactly like being inside the IO monad
18:55:25 <n^izzo> Rarrikins: Ok I have closed and opened ghci to make sure I'm not trying to use a int as a string and it still bugs out
18:55:45 <Rarrikins> n^izzo: Did you use the a key at all when typing it in?
18:56:07 <jforce> Hey, could someone help me with a type signature?
18:56:20 <n^izzo> Rarrikins: I'm sorry... key?
18:56:28 <bergmark> jforce: you probably want [[Int]], and then do runtime checks to make sure matrices match, you would need dependent types to pull this all out to the type level
18:56:40 <Rarrikins> n^izzo: Yes. ghci is complaining about the variable a.
18:56:49 <Rarrikins> n^izzo: You're probably using a somewhere.
18:56:51 <jforce> bergmark: Thanks! I will do that!
18:57:32 <n^izzo> Rarrikins: Thanks for your help I found it
18:57:35 <n^izzo> ◕ ◡ ◕
18:57:37 <Rarrikins> n^izzo: No problem.
19:04:21 <cmiller_> jforce, I think what you're going for is pretty hard.
19:04:41 <cmiller_> There is no type "All tuples"
19:09:36 <pingu> Anyone ever seen a <<loop>> from a readChan?
19:09:44 <pingu> seems a bit odd.
19:11:40 <Algebr> In this case: check::Integer check = 2, is check a function that takes no arguments and returns 2? or is check a global variable?
19:12:18 <fragamus> Data.ByteString.putStr is giving me a divide by zero
19:12:33 <pingu> Algebr: a function, that's being used as a 'global variable'
19:12:53 <cmiller_> I guess the purists here would say it's an 'expression
19:12:55 <cmiller_> '
19:12:56 <Algebr> Hmm, I'm surprised that haskell allows functions that take no arguments.
19:13:25 <Cale> Algebr: uh
19:13:35 <Cale> Algebr: I wouldn't call anything with 0 arguments a function.
19:13:56 <Cale> (also to pingu)
19:14:03 <cmiller_> It's a function from null to Int.
19:14:15 <cmiller_> For every value of null it returns 2.
19:14:18 <Cale> If you're going to start doing that, then "function" and "value" are synonymous, which is dumb.
19:14:34 <pingu> If you want to get technical, it's going to become a CAF
19:14:51 <Cale> A function is a value whose type is of the form A -> B for some types A and B
19:14:51 <pingu> If you want to get mathematical, call it whatever you like. It's the same as a function syntactically though.
19:14:53 <Cale> and nothing else
19:15:19 <Cale> All functions in Haskell really have exactly one parameter
19:16:34 <ivanm> Cale: we just prefer not to have to write lots of useless one-parameter-only functions just to make that explicit? :p
19:16:46 <ivanm> (and one-use-only functions)
19:19:58 <mgsloan> Algebr: The idea that such definitions are 0-argument-functions is a rather popular misconception.  Here's a good discussion of it: http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:20:25 <Algebr> mgsloan:Ah, my bad, I had read that before, but it didn't click sink in.
19:22:39 <fragamus> let movie =    (   (Prelude.map  Data.ByteString.pack)  .  (Prelude.map ([70,82,65,77,69,10]++)) .    (chunksOf $ fromInteger numBytesPerFrame) . (Prelude.map (`mod`256)) ) [0..]
19:23:02 <fragamus> ok now, if you try this, and get the head of the list, you get a divide by zero
19:23:05 <Cale> pingu: You can't apply non-functions to parameters
19:28:29 <fragamus> why do I get a divide by zero when I take the head of that
19:30:46 <ivanm> > 0 `mod` 256
19:30:49 <lambdabot>  0
19:32:25 <fragamus> ok it stopped happening when I replaced that (`mod` 256) with (\_->77)
19:32:28 <fragamus> weird
19:33:26 <fragamus> i am flabbergasted
19:33:48 <mgsloan> fragamus: What's the type of movie?
19:34:08 <fragamus> movie :: [ByteString]
19:34:17 <mgsloan> ah, of course
19:34:35 <mgsloan> So that means we're dealing with Word8
19:34:36 <fragamus> its a romantic comedy
19:34:42 <fragamus> yeah
19:35:05 <mgsloan> > 0 `mod` 256 :: Word8
19:35:05 <mgsloan> *** Exception: divide by zero
19:35:08 <lambdabot>  *Exception: divide by zero
19:35:21 <mgsloan> It's because 256 is 0 for Word8
19:35:22 <dhrosa> 256 as  a Word8 is 0
19:35:24 <Rarrikins> 256 is congruent to 0.
19:35:32 <fragamus> now i see
19:35:48 <fragamus> well thank you
19:35:49 <mgsloan> Also, (`mod` 255) is id for Word8
19:36:00 <mgsloan> Since Word8 is already modulo 255
19:36:02 <erisco> erm darn... seems to be no way to match end of string with regex applicative
19:36:07 <mgsloan> err 256
19:36:48 <fragamus> ok I have integers bigger than 256 and I am using mod to bring them down but it's just crappy test data so I'll use something else to set this up
19:37:24 <mgsloan> Well, this is currently forcing your input data to be Word8
19:38:11 <mgsloan> > length ([0..] :: [Word8])
19:38:14 <lambdabot>  256
19:38:55 <mgsloan> Maybe use (map (pack . fromIntegral)) or something like that
19:39:55 <mgsloan> err, I mean (map (pack . map fromIntegral))
19:53:02 <Fuuzetsu> Is there an HTML combinator library which statically assures that the generated HTML is always valid?
19:56:22 <bergmark> Fuuzetsu: valid in what sense, valid HTML5?
19:56:41 <Algebr> noob question, do either reflection or introspection make sense in haskell?
19:56:57 <LambdaFan> Data.ByteString.Base64.URL wants the type ByteString defined in Data.ByteString.Internal. I am trying to use both the Char8 and Word8 version of readFile. Neither of those work. How can I convert either of those to a form of ByteString that Base64.URL likes?
19:57:04 <Fuuzetsu> bergmark: Yeah.
19:57:35 <Fuuzetsu> There's a bug in Haddock where we nested a <a href…> in generated output and it makes me feel like it could have been stopped.
19:57:49 <jfischoff> Data.ByteString.Internal is just Data.ByteString
19:58:02 <jfischoff> vs Data.ByteString.Lazy
19:58:34 <bergmark> Fuuzetsu: ok, i don't think there is one. sounds pretty hard to encode all the invariants and still have an an acceptable interface
19:59:28 <LambdaFan> jfischoff, I'm getting type mismatches no matter which version I use
19:59:43 <jfischoff> Algebr: I would both Data.Data.Data and GHC.Generics qualify as reflection, that's me
19:59:49 <bergmark> Algebr: there's generics, template haskell, and Data.Dynamic, depending on what you are trying to accomplish
19:59:55 <Fuuzetsu> bergmark: I think it could be done by just piling type classes restricting what's allowed where and while it doesn't sound pretty, I think it'd work. You could probably do something fancier for a nicer interface.
20:00:38 <Algebr> Does haskell let you change say, function definitions at run time?
20:00:43 <jfischoff> LambdaFan: Both Data.ByteString.Char8 and Data.ByteString are the same type btw
20:00:46 <bergmark> Algebr: nope
20:00:48 <LambdaFan> Couldn't match expected type `bytestring-0.10.0.2:Data.ByteString.Internal.ByteString'
20:00:51 <Fuuzetsu> Algebr: Haskell doesn't let you change anything ;P
20:01:08 <Algebr> lol, right, that's still sinking in for me.
20:01:08 <LambdaFan> jfischoff: then is there a non-obvious explanation for the error I am seeing?
20:01:14 <jfischoff> Algebr: you can load pluggins that sort of let you do that
20:01:38 <jfischoff> LambdaFan: Does the error include a version number?
20:01:56 <LambdaFan> jfischoff: yes that must be it!
20:02:13 <streblo> what's the best stuff to get if you're writing haskell with vim?
20:02:25 <streblo> vim2hs? haskellmode-vim?
20:03:19 <jfischoff> LambdaFan: https://twitter.com/HaskellTips/status/428344025519624192
20:03:20 <bergmark> Algebr: you can have some type data R = R { fun :: a -> foo, value :: a } and then replace fun during runtime to do something else
20:05:20 <streblo> im going to go with vim2hs
20:06:43 <enthropy> both modes work decently
20:07:02 <enthropy> I seem to recall vim2hs is based on the older haskellmode-vim
20:14:47 <kakos> I'm trying to derive a Typeable instance with: "deriving instance Typeable t => Typeable (DSum t)", but I get the error "Derived Typeable instance must be of form (Typeable DSum)  In the stand-alone deriving instance for  ‛Typeable t => Typeable (DSum t)"
20:14:55 <DrAwesomeClaws_> hey folks.  In http://book.realworldhaskell.org/read/extended-example-web-client-programming.html   the connect function has signature connect :: FilePath -> IO Connection     Does anyone know where Connection comes from?     Trying to compile some similar code and getting > not in scope: type constructor or class `Connection'
20:15:00 <kakos> If I change it to "Typeable DSum", it gives me a different error.
20:15:01 <kakos> Any idea?
20:15:34 <DrAwesomeClaws_> i guess it's supposed to be IConnection, now that i think about it
20:20:20 * hackagebot shakespeare-css 1.0.7.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.7.1 (MichaelSnoyman)
20:22:17 <DrAwesomeClaws_> is real world haskell still updated?  It seems this problem is an issue with new versions of hdbc and real world haskell being a bit out of date.  If i can figure it out it'd be nice to be able to get it updated for future folks.
20:22:22 <enthropy> kakos: deriving instance Typeable1 DSum
20:22:48 <enthropy> but if you use ghc-7.8 it should accept/require  deriving instance Typeable DSum
20:23:18 <zq> is 7.8 out already?
20:23:29 <enthropy> only a release candidate
20:25:47 <enthropy> DrAwesomeClaws_: I think they have comments in the online version: you could suggest the correction there?
20:26:09 <kakos> enthropy: Sorry. Forgot to mention. I'm in GHC 7.8
20:26:10 <enthropy> or bother the authors... that can't hurt either
20:26:24 <DrAwesomeClaws_> enthropy: yeah, they have comements but those seem to be out of date or not paid much attention to.  Though, i will put in a comment if i figure out how to fix it, haha
20:26:40 <enthropy> kakos: works here. What's whole file?
20:27:38 <kakos> enthropy: https://github.com/mokus0/dependent-sum/blob/master/src/Data/Dependent/Sum/Typeable.hs
20:27:40 <enthropy> http://lpaste.net/7881662083656318976
20:27:48 <kakos> enthropy: I'm trying to get dependent-sum working with 7.8
20:29:01 <enthropy> that package seems like HList's Variant
20:29:43 <enthropy> but anyways, you should be allowed to just write a  "deriving instance Typeable DSum"
20:29:51 <DrAwesomeClaws_> there are 3 results in google regarding this issue.  http://agda.orangesquash.org.uk/2011/June.log.html  that seems most relevant to what I'm running into.  Trying to figure out wtf a postulate is so i can try to fix it in my code, haha
20:29:54 <zq> cd ..
20:29:56 <zq> cd musi
20:30:59 <kakos> enthropy: Hmm. That did get past that error. Though I'm running into a new one. Not sure if it's related. Thanks.
20:32:10 <DrAwesomeClaws_> maybe i should just downgrade hdbc until it works, haha
20:39:49 <DrAwesomeClaws_> do pragma's generally work in ghci?
20:40:25 <jle`> DrAwesomeClaws_: you can use :set
20:40:32 <DrAwesomeClaws_> thanks jle`
20:40:44 <enthropy> they work if they are in a file you are loading in ghci
20:41:24 <DrAwesomeClaws_> I'm trying to grok COMPILED_TYPE and trying to play with setting one in ghci
20:41:24 <enthropy> but extensions enabled in a file don't propagate to the repl
20:42:12 <jle`> mm_freak_: i got it to work!  two armies of various soldier types/weapons fighting eachother on a field, with swords and arrows and health and auto recovery
20:42:29 <jle`> mm_freak_: and without breaking FRP :D
20:43:32 <erisco> jle`, well done :)
20:43:37 <jle`> well...that i know of
20:43:39 <jle`> heh
20:43:59 <jle`> mm_freak_: ty for all your help and patience, if i don't catch you latre
20:44:02 <jle`> erisco: thanks :)
20:49:15 <erisco> for HXT is there any alternative to readString which does not return in IO?
20:49:29 <erisco> :t unsafePerformIO
20:49:31 <lambdabot> Not in scope: `unsafePerformIO'
20:50:59 <mmachenry1> You can do stuff with unsafe IO but it's not recommended for anything other than tests.
20:51:25 * DrAwesomeClaws throws hdbc out the window
20:51:47 <erisco> well, when it parses the string, presumably it is not doing any IO. of course that is an assumption... refactoring around this is a bit annoying is all
20:52:24 <johnw> "presumably"
20:52:33 <erisco> kaboom
20:52:43 <johnw> yeah, assumptions and unsafePerformIO do not mix well
20:53:03 <mmachenry> erisco: Are you reading from a string, not an input channel?
20:53:11 <erisco> correct mmachenry
20:54:54 <mmachenry> erisco: Where is this readString you're using defined?
20:55:03 <erisco> in HXT
20:55:20 <erisco> http://hackage.haskell.org/package/hxt-9.3.1.3/docs/Text-XML-HXT-Arrow-ReadDocument.html
20:55:26 <mmachenry> Ah
20:56:04 <mmachenry> Hmm, no experience with those IOStateArrow types.
20:56:08 <mmachenry> Reading
20:59:58 <mmachenry> erisco: This doesn't seem to be in the IO monad anyway.
21:00:35 <erisco> the only function I know to get out of their arrow is runX
21:00:39 <erisco> which lands you in the IO monad
21:00:47 <bergmark> erisco: try something like runLA xread
21:03:27 <erisco> bergmark, I do not know what "xread" is for
21:03:35 <erisco> or how to use "runLA xread" I am afraid
21:04:50 <bergmark> runLA xread :: String -> [Text.XML.HXT.DOM.TypeDefs.XmlTree]
21:05:05 <erisco> ah wait I think I understand the structure how
21:05:06 <erisco> now
21:05:34 <erisco> ah yes thank-you bergmark
21:06:01 <LambdaFan> quit
21:10:13 <jle`> mm_freak_: oops. okay, is it okay to make a wire that holds the last Just value?  is that anti-frp?
21:12:12 <jle`> mm_freak_: i could do it by composing events with an event for every Just value and using hold...but...that breaks discrete event semantics
21:21:56 <erisco> jle`, frp in general is not so well defined as to exclude such a thing... may depend on the stance your lib takes
21:23:08 <jle`> erisco: from what i have heard, for continuous-time frp, anything that leaks a discrete time breaks the semantics
21:23:35 <jle`> so i don't think a holdJust does that, assuming its input is continuous
21:23:39 <erisco> jle`, if your library includes a system for discrete events, I would think that some delay function would be already implemented
21:24:21 <jle`> a delay function is there but it's bad i think :| it's a necessary implementation-level evil as i understand it
21:24:38 <jle`> but i am still a noob.
21:25:22 <jle`> there is a delay function
21:25:32 <jle`> but i don't know how to use it to compose stuff to make a holdJust
21:25:35 <jle`> :|
21:26:03 <erisco> jle`, what library are you using? I have barely looked at event stuff and I am not sure how it plays with behaviours
21:26:11 <jle`> i'm using netwire
21:26:13 <jle`> 5.0
21:26:35 <jle`> the way it handles events sort of "lets" you preserve continuous-time semantics
21:26:47 <jle`> but it has no static way to guaruntee it
21:27:11 <jle`> it's just that the built in event/behavior combinators all keep it, but it's trivial to write one yourself to break it
21:27:44 <jle`> making a wire that fires an event at every timestep obviously breaks continuous time
21:28:55 <jle`> the creator of netwire promises an up and coming frp abstraction/implementation that makes this harder
21:29:06 <jle`> but i do not know much of it
21:29:50 <erisco> jle`, how exactly is the continuous abstraction broken?
21:29:58 <jle`> well
21:30:00 <jle`> ...
21:30:07 <jle`> hm.
21:30:25 <jle`> it introduces the idea of a discrete time step
21:30:31 <jle`> if you have something that fires an event at every time step
21:30:50 <erisco> I do not inherently see the problem in this
21:30:57 <jle`> it's not obvious that you can "use" it to do something more breaking
21:31:07 <jle`> but
21:31:20 <jle`> hm
21:31:29 <jle`> maybe i am wrong.
21:31:35 <erisco> for instance, you can have a continuous behaviour of Bool, and do something at the instance it jumps
21:31:52 <jle`> that is okay, i think
21:32:06 <jle`> actually mm_freak_ has claimed that it is bad
21:32:18 <jle`> i think he worked out a paper proof
21:32:20 <erisco> I do not see how that is contrary to your example
21:32:36 <jle`> how would i use something like that to implement holdJust?
21:32:43 <jle`> well
21:33:14 <jle`> say the input signal switches between Just and Nothing in continuous blocks
21:33:20 <erisco> I do not know what holdJust does :( my helpfulness is limited because I am only just reading on the library now
21:33:21 <jle`> and the Just value changes
21:33:24 <jle`> ah sorry.
21:33:36 <jle`> holdJust :: Wire (Maybe a) a
21:33:49 <jle`> where the value outputted is the value of the most recent Just value
21:34:30 <jle`> i cannot figure out how to construct it out of the safe primitives
21:34:57 <jle`> so perhaps it is a fault of my own incompetence :/
21:35:40 <jle`> but whenever i have to make my own primitive
21:35:44 <jle`> i get worried that i might be breaking something
21:38:18 <n^izzo> I want to learn to do things the haskell way so.. shoudl I have more verbose names or less verbose?
21:38:18 <n^izzo> trivial function example; "insertSubStr str insStr pos = take pos str ++ insStr ++ drop (length insStr + pos) str"
21:39:06 <erisco> jle`, "once" and "became" may be of use to you
21:40:02 <johnw> n^izzo: I'd probably called that insertAt, and let the types indicate that it's for strings
21:40:16 <erisco> jle`, and I presume there is some way to do recursion
21:41:15 <n^izzo> erisco: after I hit enter I re read it and thught I shoudl call it instertList to make it more generic
21:41:31 <erisco> jle`, basic idea is "when becomes a Just value, signal once, then when becomes a Nothing value, recurse"
21:41:49 <erisco> jle`, this is a basic way to discretize a continuous value
21:41:52 <shachaf> There are probably more relevant "haskell way" things than the naming scheme to worry about here.
21:42:37 <n^izzo> shachaf: lol, Please creteque
21:42:39 <shachaf> For instance, avoiding writing that function at all. Indexing on lists can be a sign that you're doing something wrong (either the indexing or the lists).
21:42:57 <shachaf> Or, if you write that function, writing it without using length (for the same reason).
21:42:58 <erisco> jle`, using that setup I then find no need for the "event" concept, but alas I have more to learn :)
21:43:40 <jle`> erisco: the event concept is actually supposed to be almost completely superceded by the inhibition/switching concept i think, but sometimes it is more convenient
21:43:57 <jle`> also i think the main intended usage is for frameworks and gui stuff to send events into the wire
21:44:46 <erisco> the algorithm I described should spit out the first Just value, then ignore the following Just values until a Nothing arrives. not sure if that is precisely what you need
21:44:49 <jle`> Events are just normal Maybe-like values, NoEvent/Event x, but with just attached discrete-instants semantics, so it's under Unsafe
21:45:12 <erisco> to hold precisely the last (not current) Just value, some extra tweaking would be needed
21:45:44 <jle`> erisco: ah er well, i want it be holding the current Just value, and when it's Nothing, hold the last Just seen
21:45:49 <n^izzo> shachaf: hmm so for the list that I am instering I will need to do a length to find how much I need to remove
21:45:59 <erisco> jle`, ah, well then it is simpler to fix
21:46:21 <johnw> n^izzo: another thing you could do is to generalize the function and call it "splice", so that it takes a string, two indices (which may or may not exist), and a replacement string to splice in, and then does effectively what Python would do under the same circumstances with the same four arguments.  I've written such a function before and it can be handy
21:46:23 <shachaf> As a challenge, make it work when the second argument is an infinite list.
21:47:22 <jle`> shachaf always leaves dramatically after his challenges
21:47:54 <jle`> erisco: hm?
21:48:13 <jle`> what kind of tweaking did you have in mind?
21:48:51 <n^izzo> johnw: so it can instert a list of (x - x) into a list of x
21:48:55 <n^izzo> ?
21:48:55 <erisco> jle`, maybe it is not quite that simple :P
21:49:55 <erisco> jle`, you cannot do it with the Maybe wire alone
21:50:11 <erisco> because there is no concept of a "last" value when it is continuous
21:50:14 <n^izzo> shachaf: but then it would never append the tail of the original list
21:50:16 <johnw> n^izzo: like this: splice "hello" 1 10 "john" ==> "hjohn".  That's effectively what "hello"[1:10] = "john" would do in Python (if it supported assignment to string objects)
21:50:56 <jle`> erisco: well it kind of makes sense. think of it as moving a pen around a paper, and the line only being drawn when the pen is down (Just)
21:51:08 <jle`> in this case this would return the "end" of the last drawn line
21:51:21 <erisco> jle`, actually I think that is fair reasoning, yes
21:51:22 <n^izzo> johnw: it does that already :D
21:51:26 <jle`> in my usage it is a compass needle that points to a continuously varying behavior
21:51:31 <jle`> in 2d space
21:51:40 <erisco> jle`, is there a way to "snapshot" the value of a wire?
21:51:41 <jle`> except sometimes the bheavior can inhibit (or be Nothing)
21:51:51 <jle`> so it should hold the last needle position
21:51:58 <jle`> hm maybe inhibition is a better way to model this
21:52:04 <jle`> than Maybe
21:52:44 <erisco> jle`, oh sorry I know what I meant now
21:53:02 <n^izzo> johnw: λ insertSubStr "hello" "john" 1
21:53:02 <n^izzo> "hjohn"
21:53:08 <erisco> there is a last value, but there is no last Just value
21:53:12 <johnw> n^izzo: mind you, I've needed to use such a function in any of my Haskell projects
21:53:20 <johnw> I've never needed
21:53:28 <jle`> hm
21:53:29 <erisco> because the right bound is the Nothing... what is before that is unknown
21:53:31 <jle`> oh
21:53:43 <johnw> so there are some things which, although it would be easy to import into Haskell from other languages, may not be appropriate or "Haskelly" at all
21:53:51 <n^izzo> johnw: Its a learning exercise for me
21:53:59 <johnw> sure, in that case have at it!
21:54:11 <jle`> erisco: not sure i understnad
21:54:28 <johnw> n^izzo: make sure your function is valid for all possible inputs too
21:54:34 <erisco> jle`, you have a wire sending a continus 'Maybe Int' value, lets pretend, right?
21:54:39 <jle`> yeah
21:55:06 <n^izzo> johnw: I'm not sure how I test for that... stackoverflow here I come
21:55:13 <erisco> jle`, okay, so when the value is 'Nothing', you are effectively asking "what is the previous value?"
21:55:25 <erisco> jle`, but we know that there is no concept of a previous value
21:56:30 <erisco> jle`, there is a last value, yes, but it is the Nothing value, which you do not want :)
21:56:42 <erisco> and there is no "last" value before the Nothing
21:56:56 <erisco> because that would be equivalent to the previous value before Nothing
21:57:45 <jle`> hm. not sure i follow, cause we have stateful wires like integral
21:58:16 <erisco> the 'Maybe a' value is changing continuously over time, yes?
21:59:38 <jle`> yeah
21:59:49 <jle`> it's just a normal continuous value
21:59:55 <erisco> sure, okay
21:59:56 <jle`> i probably should be using inhibition instead of Maybe
22:00:40 <erisco> image we sample the values...  Just 1, Just 2, Just -1, Just 0, Nothing
22:00:53 <jle`> yeah
22:00:53 <erisco> what is the value before Nothing?
22:01:00 <jle`> ah i see
22:01:12 <erisco> :)
22:01:18 <jle`> hm
22:01:37 <jle`> i see your point
22:01:52 <jle`> but how come it makes sense in a continuous world :|
22:02:08 <jle`> when i make analogies like a pen drawing on paper
22:02:10 <erisco> what makes sense?
22:02:21 <jle`> it's the endpoint of the last pen stroke
22:02:36 <erisco> yes but your endpoint is Nothing
22:02:43 <jle`> ah
22:02:46 <jle`> i see
22:02:59 <jle`> or dear
22:03:03 <jle`> *oh dear
22:03:33 <erisco> so to overcome this dilemma you need a way to discretize the value. that way you can talk about "previous" and "next" and the sort
22:03:36 <jle`> that's probably why it has been said that `became` and the like break semantics
22:04:00 <jle`> well, we can have became-like behavior
22:04:04 <jle`> using switches
22:04:17 <jle`> that make things magically semantic somehow
22:04:27 <jle`> instead of became (> 4)
22:04:42 <erisco> jle`, you can discretize the value without breaking continuous semantics
22:04:45 <jle`> we use unless (> 4) --> something
22:05:09 <jle`> unless (> 4) --> now . pure myEvent
22:05:20 <jle`> erisco: hm, how do you mean?
22:05:29 <erisco> a discretized function can be seen as one that holds a constant value every fixed interval
22:05:34 <ivanm> what's the default fixity of using backticks to make a function infix?
22:05:44 <erisco> therefore this "discretized function" is continuous
22:06:06 <erisco> you just need to pick a sample rate to define the function
22:07:14 <erisco> ivanm, same as for function application afaik
22:07:44 <ivanm> so 10 ?
22:08:04 <jle`> erisco: and, to be clear, this sample rate must be chosen and independent of the simulation timestep?
22:08:11 <erisco> I don't know what the fixity for function application is. I thought it was off the scale
22:08:29 <jle`> must be 11
22:08:34 <jle`> :P
22:08:42 <jle`> but i heard they make 12's now
22:09:27 <erisco> jle`, well, I do not see any reason it cannot be synchronous to the time step. Also you can use a variable interval... really you are just interested in a function which is not always changing over a vanishingly small delta of time
22:10:05 <jle`> erisco: hm but if you 'know' the simulation time step, then it's leaking the disrete timeness
22:10:29 * hackagebot xml-lens 0.1.5 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.5 (FumiakiKinoshita)
22:10:55 <erisco> jle`, hm, I am not sure where the leak happens
22:11:33 <erisco> perhaps the inhibitors you were speaking of are the ideal solution in NetWire. I am not sure
22:14:06 <erisco> I was just trying to highlight that you can map a smooth function to a "blocky" continuous function, using some sample interval, and that you can then talk about "previous" and "next" values
22:15:45 <erisco> and you can do this because, given an appropriate interval function, there are then countably infinite values
22:17:07 <erisco> imagine a function "record" that saves every new value to a list. this is still semantically valid, but only computationally useful using the above technique
22:18:24 <erisco> (well, you can argue that the list is linear, and the diagonalization argument shows you cannot then list everything... but we could replace with a set)
22:24:54 <erisco> jle`, if you find a solution in NetWire I'd be interested to hear what it is. I am exploring ideas because sometime down the road I am making a FRP language
22:25:04 <jle`> erisco: i see what you mean by saying that mapping a smooth function to a staircase blocky function is ok
22:25:23 <lispy> erisco: FRP language or dsl?
22:25:24 <jle`> but in order to do this i think you have to specify your timestep in your discretization/blocking
22:25:34 <erisco> lispy, language
22:25:41 <jle`> you can't just say 'blockize' and have it do it for you
22:25:46 <jle`> because now blockize will behave differnetly
22:25:50 <jle`> depending on the simulation timestep
22:25:55 <lispy> erisco: cool. Have you seen elm-lang.org?
22:26:19 <jle`> you'd have to make a blockize :: t -> Wire a a
22:26:29 <erisco> lispy, yes :) if they did not abstract away from CSS and HTML I might have used it for work
22:26:34 <jle`> that way it will behave the same regardless of your simulation timestep
22:26:55 <jle`> if your behavior changes based on the simulation timestep...that is what i would regard as leaking
22:27:16 <lispy> erisco: Does that mean you wanted/needed more direct control over CSS/HTML?
22:27:18 <erisco> lispy, they expose the FRP semantics still as a library, but the compiler has special optimisations for it. I am bringing the semantics right down
22:27:34 <lispy> right down?
22:28:34 <jle`> erisco: i'll shoot you something if i figure out a solution.  i think the blockize might work but for now and for performance reasons i'm going to use a primitive wire as a hack
22:28:34 <erisco> lispy, I think the term is "first-class"
22:29:43 <lispy> erisco: Sorry, I think I'm being dense. What will become first class? The semantics or the CSS/HTML?
22:30:07 <erisco> jle`, I do not have the entire picture, but I might see what you are saying if the simulation timestep is not throttled
22:30:49 <erisco> lispy, the FRP semantics
22:31:08 <jle`> the thing is that if you adjust the simulation timestep, the entire thing should be expected to behave identically --- the timestep is abstracted over
22:32:10 <jle`> so if your blockize behaves differently depending on your simulation timestep (it provides a discretization at every tick) then i think there is some leaking
22:32:14 <erisco> jle`, ah I presume this simulation step is tied directly into how NetWire evaluates
22:32:30 <jle`> for example you can have a wire that computes the timestep
22:32:44 <jle`> by counting the number of blockizations per second
22:33:00 <jle`> and then it's all game from there
22:33:06 <jle`> erisco: ah, yes, sorry
22:33:15 <jle`> netwire's abstraction is based on the automation arrow
22:33:40 <jle`> which is like a composable stateful function
22:33:46 <erisco> they have built in considerations for timers so I suppose that makes sense
22:34:06 <jle`> ah yeah
22:34:21 <jle`> every 'advance' of the arrow has an implicit timestep parameter
22:34:29 <jle`> so when we say Wire a b
22:34:33 <lispy> erisco: sorry, I got pulled away. Reading what you wrote now.
22:34:34 <jle`> we really mean Auto (dt,a) b
22:34:51 <jle`> Auto being a mealy machine abstraction
22:35:11 <jle`> so the timestep is built into the whole thing
22:35:25 <jle`> but all of the primitives are very careful to never 'leak' or expose it
22:35:43 <erisco> yes it makes sense to hide that information then
22:36:03 <jle`> this was likely what was lost in translation :)
22:36:05 <lispy> erisco: Making the semantics first-class is probably quite challenging. Unless, perhaps you would configure your semantic choice using library functions?
22:36:05 <erisco> how do you time your frames?
22:36:21 <jle`> erisco: i use fixed time steps
22:36:22 <erisco> lispy, what do you mean by configure?
22:36:38 <jle`> and i adjust my graphics backend to 'slave' to it
22:36:43 <jle`> not sure what the correct term is
22:37:04 <erisco> jle`, sure. okay neat
22:37:05 <lispy> erisco: I'm imagining a library that has different combinators and the ones you use determines the specific FRP semantics. It's probably a different model than you had in mind.
22:37:09 <jle`> but if my timestep is 1/120 and i am at 1/60 fps
22:37:14 <jle`> i step twice
22:37:36 <jle`> etc
22:40:07 <erisco> lispy, for my purposes, that would be like saying the language should be a superset of other languages... but no one expects the Haskell compiler to work on PHP code
22:40:38 <erisco> lispy, so it is a particular set of decisions that make me happy ;)
22:41:12 <lispy> erisco: I don't think I've understood what you meant when you said the semantics would be first-class.
22:41:47 <lispy> erisco: I'm struggling to figure out what to ask to clarify. So, I'll try some shots in the dark. Would you consider any of the Haskell FRP libraries to have first class semantics?
22:42:05 <lispy> erisco: also, what is an example where the semantics are not first-class?
22:42:08 <erisco> lispy, what I mean is that every expression in the language uses FRP-like semantics
22:42:32 <lispy> gotcha. So FRP becomes a "paradigm" baked into the language?
22:42:48 <lispy> Like FP vs. Logic vs. imperative vs. oop
22:42:53 <erisco> lispy, yes
22:43:05 <lispy> That is much simpler than I thought :)
22:43:51 <lispy> I've been learning a wee bit of VHDL. And to my novice eyes (novice with both FRP and moreso with VHDL), it has something FRP-like bake in.
22:43:56 <lispy> baked*
22:44:35 <erisco> I have not looked at VHDL but there is certainly precedence for what I am doing
22:45:43 <erisco> lispy, it is dataflow programming basically
22:47:01 <lispy> The 2-3 VHDL examples I coded up felt a lot like using yampa
22:47:36 <lispy> You bind a name to the result of some computation and the order you bind the names doesn't matter and if any of the inputs change the output automatically updates.
22:47:52 <lispy> That's a lot like recursive arrow notation
22:47:59 <erisco> sure sounds very related
22:52:07 <erisco> lispy, the exercise I am undertaking is to implement the semantics in a functional-style language (particularly I am looking to Haskell) without introducing any extra primitives. I am most interested in the evaluation model and semantics wrt tying-the-knot
22:52:33 <erisco> and the semantics involving recursion in general
23:05:06 <joelteon> (==#) is Int# -> Int# -> Bool, right?
23:05:13 <joelteon> but it changes in 7.8
23:05:49 <makalu> what's the simplest, cheapest (few dependencies), cross-platform way to display an image in a window?
23:06:17 <levi> Ascii art!
23:07:07 <makalu> :)
23:07:43 <levi> Either that or using a web browser for the window.
23:07:47 <cki> makalu please excuse my ignorance I'm brand new to haskell: maybe serve it to a web browser or use sdl?
23:08:33 <levi> Yeah, SDL bindings are probably pretty cheap and cross-platform, too.
23:09:10 <makalu> I actually thought about that. Thanks for confirming :)
23:09:17 <makalu> (that = SDL)
23:10:04 <levi> I have never used Haskell bindings for it, but ocharles did an asteroids clone with it IIRC.
23:10:35 <erisco> makalu, maybe this function/lib will work http://hackage.haskell.org/package/hledger-0.22.1/docs/src/Hledger-Cli-Utils.html#openBrowserOn
23:10:47 <erisco> bonus is that it is only one function to call :)
23:11:39 <klrr> levi: yup, using sdl1.2 though, new binds for sdl2.0 is being worked on though (if not already finished)
23:12:06 <makalu> nice, mingw32 → firefox.exe :)
23:12:49 <erisco> of course! :P well you could improve the function a bit
23:13:32 <erisco> though primitive the browser will offer a lot more functionality wrt the image than just an SDL window
23:14:16 <makalu> that's true
23:16:39 <lispy> makalu: You'll have better cross platform luck with GLFW-b
23:16:56 <lispy> makalu: Getting all the SDL stuff setup on windows is a bit harder (the last time I tried it at least)
23:17:08 <lispy> makalu: http://hackage.haskell.org/package/GLFW-b
23:17:23 <lispy> makalu: that package is a bit more 'automagic'. Just 'cabal install' and you should be good to go.
23:17:33 <makalu> what is hard to set up? The haskell bindings or SDL itself? I remember using SDL from C++ on Windows a long time ago and it worked very well.
23:17:49 <lispy> The non-Haskell bits
23:18:11 <lispy> If you don't mind installing the C libraries and telling cabal where to find them, then sdl works quite well.
23:19:02 <klrr> sdl worked very good, except for my space invader clone, it simply did not work (lots of other peeps have looked on it and not find any reason why it doesnt work either)
23:20:40 <lispy> makalu: I also find that glfw is a bit more streamlined if your goal is to simply display an image in a window.
23:20:43 <klrr> it did lenghten a cube instead of moving it i.i
23:21:34 <lispy> klrr: You must have been tickling a weird bug. SDL is what valve uses (at least 2.x is developed by them), so I would expect it to be pretty solid.
23:23:58 <klrr> lispy: yup, it was sdl1.2 i used but im stock on old ubuntu release so i dont have sdl2.0 packaged :s
23:24:36 <klrr> i gonna move to nixos when i get some free time, currently reading tapl and learning pipes :p
23:25:36 <makalu> what's tapl?
23:25:48 <makalu> types and ... something book?
23:26:08 <klrr> yup
23:26:12 <levi> Types and Programming Languages
23:26:17 <carter> TAPL
23:26:22 <carter> i read that at tapi
23:26:29 <thebnq> @where tabl
23:26:30 <lambdabot> I know nothing about tabl.
23:26:36 <thebnq> well
23:26:39 <thebnq> @where tapl
23:26:40 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
23:28:00 <lispy> klrr: cheers. Sounds like worthwhile endeavors!
23:31:24 <orzo> I need to serialize SockAddr and ipv6 addresses in particular.  The FlowInfo and ScopeID fields are very mysterious.  Do they need to be serialized or can I somehow deduce them?  Do they really need to be 32 bits each?
23:36:45 <lispy> orzo: It comes from this struct: http://pic.dhe.ibm.com/infocenter/iseries/v6r1m0/index.jsp?topic=/rzab6/cafinet6.htm
23:37:02 <lispy> So yes, they need to be Word32
23:37:20 <lispy> I'm not sure if you need to serialize them
23:37:40 <lispy> This is probably a better resources than that IBM article: http://linux.die.net/man/7/ipv6
23:38:51 <lispy> orzo: and wikipedia says: Flow Label (20 bits)
23:38:52 <lispy> Originally created for giving real-time applications special service.[1] The flow label when set to a non-zero value now serves as a hint to routers and switches with multiple outbound paths that these packets should stay on the same path so that they will not be reordered.[5][6] It has further been suggested that the flow label be used to help detect spoofed packets.[7]
23:39:00 <lispy> orzo: http://en.wikipedia.org/wiki/IPv6_packet
23:39:25 <lispy> orzo: that makes me think that if you ignored it you'd be mostly okay, but whatever optimizations it provides would be gone?
23:39:45 <orzo> i have a server using SockAddr as a lookup key and now i need to encode/decode the key so that it will still work after decoding
23:40:12 <orzo> but my encoding is going into an xml attribute, and i want to keep it small
23:40:44 <lispy>  can't tell what scopeid means
23:40:48 <lispy> I have to run
23:40:50 <lispy> Good luck!
23:40:54 <orzo> thanks
23:40:57 <lispy> yw
23:42:09 <orzo> sin6_scope_id is an ID depending on the scope of the address. It is new in Linux 2.4. Linux only supports it for link-local addresses, in that case sin6_scope_id contains the interface index (see netdevice(7)
23:42:22 <orzo> guess the scopeid indicates the interface for link-local
23:43:06 <orzo> i can probably deduce whether it is link-local from the address and omit the scopeid accordingly
23:44:13 <orzo> also, probably okay to limit it to one byte, as i dont really think i need to support greater than 256 interfaces heh
23:44:26 <orzo> but that's assuming they start at 0 and number them sensibly
23:57:26 <treehouse> orzo: wtf, stop sending me PMs
23:58:56 <orzo> um
23:59:09 <treehouse> wtf, stop sending me porn links orzo!
23:59:10 <hc> /mode treehouse +R  stops PMs from unregistered users
23:59:15 <orzo> treehouse: i've sent you nothing
23:59:22 <hc> /mode treehouse +g stops anyone not on a whitelist from sending PMs
