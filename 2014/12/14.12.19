00:08:52 * hackagebot cndict 0.4.6 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.6 (DavidHimmelstrup)
00:08:52 * hackagebot crypto-pubkey 0.2.6 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.6 (VincentHanquez)
00:18:40 <texasmynsted> anybody use hindent?  I think I have a cabal issue.  Is there a cabal specific channel?
00:20:05 <Peaker> chrisdone: thanks for the video! it behaves differently here. Maybe it's the custom GHC I have installed that makes it fail
00:23:47 * hackagebot io-streams-http 0.2.0.0 - http-client for io-streams  http://hackage.haskell.org/package/io-streams-http-0.2.0.0 (DavidJohnson)
00:27:47 <vishaalk> does anyone know how to do a clean wipe of the haskell-platform off OS X 10.10 ?
00:28:07 <vishaalk> I found the gist that steakknife put up on Github, but it aborts saying it found a different Haskell version
00:32:58 <dmj`> vishaalk: what does "which uninstall-hs" give you?
00:33:47 * hackagebot io-streams-http 0.2.0.1 - http-client for io-streams  http://hackage.haskell.org/package/io-streams-http-0.2.0.1 (DavidJohnson)
00:34:15 <vishaalk> nothing, /Library/Haskell is gone
00:34:21 <vishaalk> but ~/.cabal is leftover
00:34:41 <vishaalk> and which ghc gives /usr/local/bin/ghc
00:35:21 <dmj`> vishaalk: are you trying to install everything fresh?
00:35:52 <dmj`> vishaalk: this is probably a better distribution, less frills, saner default install locations, https://ghcformacosx.github.io/
00:36:16 <dmj`> I'd wipe ~/.cabal and rm /usr/local/bin/ghc*
00:36:37 <vishaalk> thanks for the link. the reason I want a fresh install is I had issues with cabal cabal-install where it said 1.22 depended on 1.20 and 1.20 depended on 1.18 and whatnot
00:36:45 <vishaalk> my cabal was at 1.16 and I had no idea what to do
00:38:55 <kvanb> brew install cask
00:39:08 <kvanb> cask install ghc
00:39:08 <kvanb> (done)
00:40:08 <dmj`> vishaalk: I just install cabal and ghc from scratch, keep them in ~/.cabal/bin/cabal and /usr/local/ghc(i) etc, then add to your path
00:40:29 <dmj`> vishaalk: never install anything global, just use sandboxes
00:46:33 <vishaalk> thanks dmj`!
00:46:41 <vishaalk> everything works now i believe
00:48:47 * hackagebot http-client-streams 0.2.0.0 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.2.0.0 (DavidJohnson)
00:52:33 <dmj`> vishaalk: sweet
00:53:11 <nkar> my program looks like this: 'do ...; void $ forkIO $ void $ rawSystem "foo" ...; action' where "foo" runs in a loop.  I expected ghc to kill the child thread when the main thread exits, but it doesn't seem to be the case.  running 'killThread' explicitly after 'action' doesn't help either.  it seems that "foo" keeps looping preventing the main thread from exiting.  any ideas?
01:01:52 <trap_exit> ar emailboxes a bad idea in ahskell because sum type suck? and we should use channels intead?
01:03:14 <trap_exit> fizbin: got the msg via lambdabot, thanks! We should write a paper on this
01:33:43 <hihi> random
01:33:53 <hihi> [1..10]
01:34:53 <hihi> @run [1..5]
01:34:54 <lambdabot>  [1,2,3,4,5]
01:53:47 * hackagebot process 1.2.1.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.1.0 (HerbertValerioRiedel)
01:57:08 <emmanueloga> hi. Can someone help me decipher this thing: let n = ((*2) + (+10)) 1. I don't understand the type signature: n :: (Num (a -> a), Num a) => a
01:57:44 <emmanueloga> in fact, I don't even understand how it is valid to add two functions...
01:58:47 * hackagebot unix 2.7.1.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.7.1.0 (HerbertValerioRiedel)
01:58:48 <hamid> emmanueloga, Curried functions. Do you know the concept?
01:59:07 <lyxia> emmanueloga: A standard way to define this is (f + g) = \x -> f x + g x...
01:59:14 <emmanueloga> hamid: I know what a curried function is, I just don't understand what happens when you add two curried functions..
01:59:22 <alpounet> emmanueloga: that's exactly the thing. (*2) + (+10)  -> the + operator is defined in a typeclass, Num. This means you can virtually make any type you want usable with +. So for this bit of code to be valid, GHC just deduces you'll eventually call it with function types that have a Num instance (i.e "usable with +" so to speak)
01:59:44 <hamid> emmanueloga, another curried function :P
01:59:48 <alpounet> that's why you have the Num (a -> a) constraint
02:00:29 <emmanueloga> so what would be a way of calling "n" ?
02:01:22 <alpounet> instance Num a => Num (a -> a) where f + g = \x -> f x + g x -- etc.. -- emmanueloga
02:01:44 <alpounet> you can even make this instance Num b => Num (a -> b) where ..
02:02:39 <shachaf> You can even make it (Applicative f, Num b) => Num (f b), I suppose.
02:03:22 <emmanueloga> ah.. wait. So haskell thinks the thing I defined in 'n' *could* be valid, if at some point someone (me?) defined that "+" function? But if I don't do that, the expression is still valid but when I try to run it, there's no valid (+) yet?
02:04:03 <alpounet> emmanueloga: well, there's no Num instance in the base libraries for functions
02:04:07 <alpounet> so that won't work
02:04:25 <alpounet> but if you write one or import one from some library that has it, that bit of code can actually run :)
02:06:33 <alpounet> emmanueloga: http://lpaste.net/116848
02:09:45 <emmanueloga> cool, txs!
02:10:39 <emmanueloga> so the fact my expression works even w/o implementing (+) has to do with haskell's laziness / non-strictness?
02:10:51 <emmanueloga> works == is accepted by the compiler
02:12:54 <shachaf> No, non-strictness has nothing to do with type checking.
02:14:34 <alpounet> emmanueloga: no, it's just that if you use + in a function that just sums its variables, for example
02:14:45 <alpounet> > let f a b c = a + b + c in f 1 4 5
02:14:47 <lambdabot>  10
02:15:03 <alpounet> then this function has an actually quite generic type
02:15:12 <alpounet> :t \a b c -> a + b + c
02:15:13 <lambdabot> Num a => a -> a -> a -> a
02:15:45 <alpounet> so our function will work on any type that has a Num instance
02:16:04 <alpounet> even functions if we want, like you saw a little earlier
02:18:17 <alpounet> you're not actually being tied to a particular integer type or something here. you just rely on being able to use + => this adds a Num constraint to your whole expression
02:18:34 <emmanueloga> gotcha
02:18:47 * hackagebot moan 0.2.0.1 - Language-agnostic analyzer for positional morphosyntactic tags  http://hackage.haskell.org/package/moan-0.2.0.1 (vjeranc)
02:21:15 <emmanueloga> the reason I thought it had something to do with strictness is that I was able to assign n even when + was not defined for functions... but this seems to work only in ghci. If I define it on a file, even if I don't call the function, the compiler complains.
02:22:07 <nkar> solirc: around?
02:28:47 * hackagebot moan 0.2.0.2 - Language-agnostic analyzer for positional morphosyntactic tags  http://hackage.haskell.org/package/moan-0.2.0.2 (vjeranc)
02:32:45 <danilo2> Hello! :) I understand that Data.Text is much better and faster when dealing with large number of characters, especially when they are unicode. So I've got one question - should I handle are the system paths in my application using Text also? If not, why not?
02:34:18 <ChristianS> danilo2: for short strings it doesn't really matter, and the standard functions for dealing with filenames use String
02:34:41 <ChristianS> danilo2: just use what's more convenient and call T.pack|unpack as needed to convert
02:35:03 <danilo2> ChristianS: I know, but is it wrong to use here Text also? I mean - almost all my functions operate on Text so it would be a little wrong that some of them would base on Strings, hm? :)
02:35:33 <ChristianS> danilo2: yeah, like i said, then use Text and unpack it when a String is needed
02:35:41 <danilo2> ChristianS: I understand. So am I right, that even for short strings, text shoudl be equal or outperform Strings? :)
02:36:06 <ChristianS> danilo2: for short string you probably won't measure a difference
02:36:22 <danilo2> ChristianS: Ok, great :) Thank you very much! :)
02:38:47 * hackagebot concraft-hr 0.1.0.1 - Part-of-speech tagger for Croatian  http://hackage.haskell.org/package/concraft-hr-0.1.0.1 (vjeranc)
02:41:33 <danilo2> And one more question regarding Text vs ByteString - when I'm parsing with Trifecta, should I feed it with Text or ByteString? (I'm parsing text files with code) cc: edwardk
02:45:42 <ChristianS> danilo2: don't know about about Trifecta, but ByteString is no String substitute, it's for byte sequences rather then textual data
02:49:13 <aphorisme> Say I want a "enum" or something similiar, i.e. a type which instances I'll use as flags. I see two possibilities: 1) "data Flag = A | B | .." or via PatternSynonyms. For what should I go?
02:50:42 <ChristianS> aphorisme: i'd use  data Flag , no need for anything more complicated
02:51:38 <aphorisme> Okay, thanks.  : )
02:51:56 <danilo2> ChristianS: I know, butt the example on Trifecta github uses bytestring to read text file and to parse it
02:58:22 <maukem> aphorisme: can flags be combined?
02:59:01 <aphorisme> Haven't thought about this yet. Hm, would be a problem with these approaches. Maybe a list of Flag.
02:59:24 <maukem> I like records for that
02:59:44 <maukem> data Flag = Flag{ a, b, c :: Bool }
03:00:00 <maukem> especially if you have sensible default
03:00:01 <maukem> s
03:00:22 <maukem> then you can provide a default flag set for the user to modify
03:00:38 <maukem> doStuffWith defaultFlags{ b = True }
03:01:11 <aphorisme> hm... but can I pattern match against True/False? Hm, guards might help here.
03:01:29 <aphorisme> but a nice idea.
03:01:34 <maukem> yes, you can
03:01:39 <maukem> Bool is just another enum
03:02:01 <maukem> if x then y else z = case x of True -> y; False -> z
03:02:13 <Peaker> maukem = mauke ?
03:02:37 <maukem> but with more m
03:03:05 <Peaker> I guess not :)
03:03:24 <maukem> it depends on how you define equality
04:09:05 <eXeC64> maukem: I read somewhere that all Haskell can be reduced to two types of statements, case and another. What was the second?
04:10:04 <apo> NOR
04:10:07 <apo> :D
04:10:25 <eXeC64> You can implement NOR with case.
04:10:29 <gazay> hello! I want to make small site for myself on haskell and trying to follow this post - http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html. Is stack there a good and still modern? Also I’m a little bit confused and can’t find some open sourced example of application written that way with complex structure - views in separate files etc. It’s pretty different with Sinatra and Rails way :) Maybe you know some good examples?
04:10:47 <chpatrick> exeC64: lambda?
04:11:00 <eXeC64> chpatrick: That's probably it
04:11:21 <Qfwfq> Petition to rename Haskell LambdaCase
04:11:26 <zomg> gazay: seems like a decent approach. You might also want to take a look at Happstack and/or Snap and/or Yesod
04:11:29 <eXeC64> Qfwfq: Seconded!
04:12:13 <chpatrick> that's pretty much what Core is expression-wise, no?
04:12:41 <zomg> gazay: with the approach in that guide, you could quite easily split views into separate files. Simply create another haskell file and put the blaze-html related code there, then import it in your main module
04:16:19 <gazay> I tried to do exactly how they explain there, but it throws me exception that in template file there is no functions from modules I import in main file (html, li etc.) Maybe I messed up with directories structure or my cabal file. Thank you! I just worried that it can be outdated
04:20:48 <aphorisme> is this tail recursion: loop = do { stuff; if X then Y else do { stuff2; loop } } ?
04:22:47 <maukem> not directly
04:22:54 <maukem> that thing is a call to (>>)
04:24:13 <aphorisme> hm.. so I should avoid this if this is the "main loop"?
04:24:32 <maukem> no
04:24:39 <maukem> tail recursion is overrated
04:25:24 <eXeC64> maukem: What alternative to tail recursion would you propose?
04:25:32 <eXeC64> Or are you just stating it's overrated?
04:25:34 <maukem> non-tail recursion
04:25:44 <maukem> are you worried about overflowing the call stack?
04:25:49 <maukem> haskell doesn't have a call stack
04:25:59 <eXeC64> Oh, how does it keep track of the current context?
04:26:19 <maukem> there's only one context
04:26:24 <maukem> well, not really
04:26:36 <eXeC64> Well, there's still a big tree of thunks, aren't there?
04:26:38 <maukem> there is a stack for forcing thunks
04:26:41 <eXeC64> They'll consume memory
04:26:57 <maukem> i.e. evaluation of nested expressions
04:28:10 <eXeC64> Is there a good article/paper somewhere on how Haskell's evaluation of expressions behaves?
04:28:26 <eXeC64> From an optimisation/don't-consume-lots-of-memory perspective
04:28:39 <maukem> good question
04:29:32 <eXeC64> It'd certainly help for knowing when strict evaulation is appropriate
04:32:45 <aphorisme> okay, thank you.
04:32:59 <aphorisme> I'll just go with this solution and will see if I have to optimize it in some way.
04:33:01 <k00mi> the STG paper should be relevant, although the details are likely outdated
04:36:05 <zomg> gazay: imports are only available within the module where you do the import, so you need to import the functions you need in your template module as well
04:36:41 <gazay> zomg: oh I see. Will try today. Thanks again
04:38:49 * hackagebot vault 0.3.0.4 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.0.4 (HeinrichApfelmus)
04:39:47 <gazay> also I’ve made https://github.com/gazay/haskell-users. It has same idea and implementation as https://github.com/HashNuke/elixir-users (project should help find Elixir meetup groups or provide head count to organize Elixir meetups in newer places). Maybe someone will find it helpful and help me to add some information.
04:48:49 * hackagebot sai-shape-syb 0.3.0 - Obtain homogeneous values from arbitrary values, transforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.3.0 (AndrewSeniuk)
04:53:49 * hackagebot deepseq-bounded 0.5.0 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.5.0 (AndrewSeniuk)
04:53:51 * hackagebot seqaid 0.1.1 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.1.1 (AndrewSeniuk)
04:53:53 * hackagebot leaky 0.1.0.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.1.0.0 (AndrewSeniuk)
04:59:36 <artemshitov> gazay: Have you seen http://www.haskellers.com/ ?
05:05:32 <gazay> artemshitov: nice! nope, I’ve not seen this before) My repo is unnecessary then)
05:13:49 * hackagebot hxt 9.3.1.10 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.10 (UweSchmidt)
05:26:23 <clrnd> so why do maths people prefer join to bind when talking about Monads?
05:26:49 <hpc> it's easier to define, and more convenient for proofy things
05:27:01 <clrnd> that's a very reasonable answer
05:27:16 <clrnd> thks
05:27:42 <hpc> (>>=) is mainly more convenient in programming because it's easy to define in ways that mean "do this, then this"
05:27:52 <hpc> which many people think in terms of
05:32:28 <eXeC64> Hmm, how would join be used in haskell? I'm looking at its type but can't quite picture usage
05:34:09 <Chathurga> eXeC64: You could turn Just (Just 5) into Just 5
05:34:15 <Chathurga> or [[a]] into [a]
05:34:57 <Chathurga> It's basically if you have some Monad that's nested and you want to flatten it out
05:35:32 <eXeC64> Chathurga: So, for [] is it the same as concat??
05:35:51 <Chathurga> eXeC64: Exactly
05:36:20 <Chathurga> join m = m >>= id
05:36:46 <Chathurga> And for lists... (>>=) m f = concat . fmap f m
05:37:14 <Chathurga> so join for lists... join xs = concat (fmap id xs)
05:37:20 <Chathurga> which is just concat xs
05:37:23 <eXeC64> Huh, sneaky.
05:37:39 <Chathurga> Yeah I like that example
05:38:11 <Chathurga> [slight mistake, had "concat . fmap f m" above, should be "concat (fmap f m)"]
05:49:47 <suppi> Hi, beginner here. I'm in the middle of embedding a small language to represent a small calculator and I can use a code review. would anyone want to help?
05:50:13 <hpc> just post your code, someone with time to spare might look at it
05:50:19 <suppi> thanks
05:50:24 <suppi> it's here: https://bitbucket.org/suppi/calc-lang/src/cf84c6be0f6c?at=master
05:50:25 <hpc> generally asking to ask on irc will get you nowhere ;)
05:50:57 <wei2912> https://bitbucket.org/suppi/calc-lang/src/cf84c6be0f6cb9ad5e95868aa02fca3f9db8f99a/src/AST.hs?at=master
05:51:03 <wei2912> that's a lot of expressions :P
05:51:31 <hpc> looks fine to me in about 30 seconds of scanning the code
05:52:11 <wei2912> suppi: ah, you said that it was a small language to represent a small calculator
05:52:24 <clrnd> yep, looks fine to mee too. love the comments
05:52:31 <suppi> hpc, thanks :)
05:52:34 <suppi> wei2912, yes
05:52:39 <suppi> clrnd, thank you
05:53:46 <chpatrick> suppi: I would recommend lambdacase :)
05:53:59 <chpatrick> suppi: it would make this a lot nicer: https://bitbucket.org/suppi/calc-lang/src/cf84c6be0f6cb9ad5e95868aa02fca3f9db8f99a/src/Eval.hs?at=master#cl-20
05:54:29 <suppi> chpatrick, can you tell me where specifically?
05:54:40 <suppi> chpatrick, I used lambdacase on line 29 for example
05:55:51 <chpatrick> suppi: I would do evaluate env = \case
05:55:51 <chpatrick>   Var str -> ...
05:55:51 <chpatrick> etc
05:56:04 <suppi> oh, I see
05:56:10 <chpatrick> that way you don't need to parenthesize the patterns or repeat "evaluate env"
05:56:25 <chpatrick> I think it looks a lot cleaner but that's just my personal style
05:56:47 <quchen2> eXeC64: Another example: Reader. `join = (.)` whereas `m >>= f = \r -> f (m r) r`.
05:57:03 <suppi> chpatrick, thanks :)
05:57:15 <chpatrick> suppi: also I would write liftM (Atom . sum)     (mapM (evalToInteger env) exps) as Atom . sum <$> mapM (evalToInteger env) exps
05:57:15 <quchen2> Eh wait
05:57:16 <suppi> I will try it out
05:57:24 <quchen2> join f x = f x x, pardon.
05:57:30 <quchen2> Anyway, much simpler.
05:57:40 <exio4> fmap quchen2! fmap!
05:57:48 <quchen2> Right.
05:57:51 <suppi> chpatrick, thanks, will try that too
05:58:22 <chpatrick> suppi: also in the AST I think I would do Add Expr Expr instead of Add [ Expr ]
05:58:32 <danilo2> Hello! Coudl anybody tell me how can I use lenses but fix the uglyness they introduce with datatypes with different constructors with different fields? I mean, when I refactor my code and change name of a field I do not get error using lenses - instead they construct the object from monoid and this is horrible. Here is example: http://lpaste.net/116851
05:58:34 <chpatrick> you don't really lose anything that way but it means that Add [] is not possible
05:59:02 <chpatrick> it would simplify evaluation a bit too
05:59:09 <suppi> chpatrick, I changed it from Add Expr Expr to Add [Expr] to make it more scheme like
05:59:33 <suppi> and Add [] will evaluate to 0
05:59:34 <chpatrick> suppi: fair enough
06:00:02 <suppi> that's how it behaves in clojure at least
06:05:41 <sleepomeno> danilo2: you could use makePrisms instead of makeLenses. if you then write 'view _B.y b' you will get an error
06:06:56 <danilo2> sleepomeno: Oh, that i nice. But better would be to get the behaviour from standard haskell - that I could write the view y, but get error in runtime. is it possible?
06:07:53 <danilo2> sleepomeno: Additional, with makePrisms I cannot set the arguments :(
06:09:55 <suppi> thank you all for your help. will appreciate more code review :) https://bitbucket.org/suppi/calc-lang/src
06:11:33 <sleepomeno> danilo2: using the lens api i don't think you can 'manage getting a runtime error'. in general, that's exactly what should be prevented by the type system in the first place! sry, need to leave now, bye
06:13:49 * hackagebot dynamic-graph 0.1.0.4 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.4 (adamwalker)
06:22:49 <indiagreen> danilo2: you could use ^?! if you don't want to use makePrisms for some reason
06:25:01 <artemshitov> How can I check which versions of dependencies did cabal build my package with?
06:26:40 <Saizan> artemshitov: ghc-pkg describe
06:28:48 <artemshitov> Saizan: thanks
06:30:22 <danilo2> indiagreen: Ok, and what with other operators like %~ or .~, are there appropriate ones?
06:40:23 <indiagreen> danilo2: not that I know of, but you can use singular on your field traversal to achieve the same effect – e.g. «blah ^. singular _y»
06:41:08 <indiagreen> which means you'll be getting very unhelpful errors when something goes wrong, like “singular: empty traversal”
06:41:55 <danilo2> indiagreen: hmm, could you look at this example and tell me how can I use singular here? http://lpaste.net/116851  I just cannot make it working :(
06:42:32 <indiagreen> instead of “view y b”, say “view (singular y) b”
06:44:52 <indiagreen> however, I really hope that if someone else apart from you is going to use this program, you would put effort into making error messages better, even if it means clumsier code
06:44:59 <danilo2> indiagreen: oh, interesting! Do you know if it performs in the same way as without singular btw? :)
06:45:40 <indiagreen> do you mean same performance?
06:45:52 <danilo2> indiagreen: Yes, this is the only way of making it. The only problem is that even names in multidatatypes in haskell are ugly and can blow up in runtime. This is a little bit broken
06:46:00 <danilo2> indiagreen: yes
06:46:08 <indiagreen> no idea, to be honest
06:46:15 <indiagreen> I suggest using criterion to benchmark it
06:48:11 <danilo2> indiagreen: ok, thank you very much. So I understand that If we want to make really good programs in haskell we should not use lenses and even names in datatypes which have got more than 1 constructor?
06:48:50 * hackagebot urlpath 0.1.0.1 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.1.0.1 (athanclark)
06:52:35 <izohask> nego /quit
06:58:50 <indiagreen> danilo2: I wasn't talking about not using functions which can fail at runtime (albeit some do argue that you shouldn't ever use partial functions) – but if you do, avoid completely useless error messages. E.g. if you're going to just go with singular here, the error message you're going to get would be equivalent to “something somewhere doesn't exist and I thought it would, darn”. One thing you could do:
06:58:50 <indiagreen> http://lpaste.net/diff/116851/116860
07:09:55 <crobbins> is there any way to have template haskell recompiled via ghci/cabal repl?
07:10:19 <danilo2> indiagreen: I understood that one. I'm sorry, I was just thinking about these partial functions and all the dangers they introduce :(
07:12:08 <geekosaur> crobbins, TH is wired into the compiler, necessarily
07:12:21 <geekosaur> since it is manipulating compiler internals
07:12:33 <geekosaur> you cannot afely update it without upgrading the compiler
07:12:49 <crobbins> geekosaur: for instance, i want my yesod templates to be recompiled via ghci
07:12:54 <crobbins> geekosaur: so, that's not possible?
07:13:12 <geekosaur> it is not. pretty much anything you'd want in a newer version requires matching changes to the compiler
07:13:43 <crobbins> geekosaur: a newer version?  because TH is creating a "newer" compiler?
07:13:58 <geekosaur> ... I find myself wondering how you think TH works
07:14:17 <geekosaur> let me put it this way: the part of TH that you see simply exposes parts of the compiler internals
07:14:30 <crobbins> geekosaur: haha, well, i see it as splices that are executed at compile time
07:14:32 <geekosaur> if you upgrade that, it will be trying to expose things that are not inyour compiler
07:16:04 <geekosaur> sadly, "splices that are executed at compile time" glosses over the rather important question of *how* they are executed at compile time
07:16:21 <geekosaur> what's actually going on is it's manipulating compiler internal structures directly
07:16:53 <liyang_> You can helpfully think of it as user-defined compiler-plugin.
07:17:25 <crobbins> so, for instance, i have a hamlet template
07:17:30 <geekosaur> those structures change all the time, and any new functionality involves modifying the form those structures take (their types, specifically)
07:17:30 <crobbins> i update the template file
07:18:23 <geekosaur> so the TH library's types for those compiler internals must match those of the compiler exactly or any attempt to use TH will lead to at best weird type errors and at worst (same type, different semantics) compiler core dumps or panics
07:18:49 <geekosaur> oh, maybe I misundersood your question. you just want to run spliuces from ghci
07:19:00 <crobbins> geekosaur: maybe
07:19:03 <geekosaur> I think that may be theoretically possible but ghc as it exists now does not support it
07:19:44 <crobbins> i am not writing TH, if that helps
07:19:49 <crobbins> the TH code is not changing
07:19:50 <geekosaur> as I understand it, because (a) both use the bytecode interpreter and it's not reentrant (b) the whole thing about staging (what's visible where/when) gets weird in an interactive environment
07:20:14 <geekosaur> it could be made to work but it's believed to require a lot of effort and a lot of understanding of ghc's guts
07:20:18 <crobbins> i am just using Yesod's facilities to handle my templates
07:20:28 <crobbins> hmmm
07:20:51 <crobbins> so, :r will reload my sources, but just skips over splices?
07:21:09 <crobbins> or rather, uses the previously expanded form
07:21:15 <crobbins> see, this is my problem
07:21:21 <crobbins> i can do -ddump-splices
07:21:27 <crobbins> and i see the sources generated
07:21:37 <crobbins> why couldn't ghci do that?
07:21:38 <geekosaur> hm. I would expect it to throw an error about not being able to use TH in the interpreter
07:21:53 <crobbins> no, it works just fine
07:21:54 <geekosaur> because you ikmagine it is generating sources
07:21:57 <crobbins> it just doesn't "reload" the splices
07:22:03 <geekosaur> because that;s what dump-splices shows you
07:22:12 <geekosaur> it's not actually generating sources. itmanip
07:22:13 <crobbins> huh
07:22:33 <geekosaur> it's manipulating an internal abstract syntax tree, and dump-splices is showing you a decompile of that
07:22:36 <crobbins> well, what's the point in -ddump-splices
07:22:38 <crobbins> ?
07:22:51 <geekosaur> the problem is that the act of generation requires running Haskell code in the bytecode interpreter
07:22:56 <EvanR> in any multiparameter type class do you have to use functional dependencies, if not, which ones
07:23:06 <geekosaur> but in ghci, the bytecode interpreter is already being used to interpret your program
07:23:43 <crobbins> geekosaur: so, you have to kill ghci and launch it again to reload splices
07:23:44 <geekosaur> (well, in both cases to "compile" --- TH splices are Haskell code that must be compiled into bytecode and then that is interpreted)
07:23:52 <geekosaur> pretty much
07:23:55 <crobbins> ugh
07:24:01 <geekosaur> I think the current behavior is a compromise, it used to just fail outright
07:24:11 <crobbins> yeah
07:24:26 <geekosaur> but now it just hopes it can reuse the original because it will corrupt the program it's :r-ing if it tries to compile a splice
07:24:57 <geekosaur> to fix this, someone needs to make the bytecode backend reentrant or make it possible to have multiple instances of it
07:25:16 <geekosaur> (so TH can run in its own independent instance instead of in the one that is currently compiling your source in ghci)
07:27:16 <aikidoka> anybody around that might be able to answer a cross compliation question?
07:29:37 <bennofs> aikidoka: just ask the question. maybe somebody can answer the question even if they don't feel like they're an expert in "cross compilation questions"
07:29:56 <aikidoka> Ok, in reference to https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
07:30:04 <mikeplus64> EvanR: dunno if i've groked your question correctly, but here goes: no, you don't have to use FDs. you would use FDs when some class parameters uniquely determine others, which will probably have the nice effect of loosening how much type info you need to "get to" an instance
07:30:08 <geekosaur> also, if nobody can answer here, you might try subscribing to the haskell-cafe mailing list and ask there
07:30:55 <aikidoka> If I only want to build a Stage 1, so GHC generates files for target, but does not run on target itself, do I need to specify the target's gcc, ld, nm, etc.  Or is that only if building a stage 2, so GHC actually runs on target.
07:31:51 <geekosaur> EvanR: mikeplus64 is basically correct. ghc can't infer types properly around uses of a multiparameter type class, so you use FDs (or type families) to provide it guidance; otherwise you must specify types whenever you're using the MPTC
07:32:02 <aikidoka> In config.log I see if using the i586 gcc I sepecified as the x86_64 gcc whenever I pass it --with-gcc=<target gcc>
07:32:19 <aikidoka> if=it
07:33:09 <aikidoka> or if anybody knows of an OE recipe that builds GHC as a cross compiler they can point to, that would probably answer any question on it I could have.  :)
07:33:18 <geekosaur> aikidoka, there's at least two kinds of compilation going on in stage 1. in particular it must build a runtime for the target so that generated code for the target will actually have a context to run in; that must be compiled and linked using the target's tools
07:33:27 <mikeplus64> geekosaur: unless you do something cheeky like "instance b ~ thing => Foo a b" anyway
07:34:07 <EvanR> mikeplus64: geekosaur: so normal amounts of type signatures may or may not be enough? the type class im thinking of is Category, but maybe this doesnt event count as MPTC
07:34:08 <geekosaur> (note that there are parts of the runtime written in C)
07:34:40 <aikidoka> geekosaur:  Ok, so that means I do need it if the runtime is built with Stage 1.  Question then is why does the config.log show it using the i586 as the x86_64 gcc.  That could be somehow caused by OE itself perhaps.
07:34:47 <mikeplus64> EvanR: yeah, Category has only one parameter
07:35:26 <EvanR> ok nevermind
07:36:07 <athan> Can I put type signatures in let statements?
07:36:39 <geekosaur> athan: yes
07:36:39 <aikidoka> unless there is something that needs to be patched.  I am trying to build 7.2.2 at the moment.  Might need to start with latest and work backwards.  Ultimately need to get to 6.12.3 if possible
07:37:03 <athan> geekosaur: via `let foo :: Someting; let foo = ...`?
07:37:16 <geekosaur> athan: they go in the same let. remember that let uses layout
07:37:35 <geekosaur> if this is in ghci, you probably need braces: let  { foo :: ...; foo = ... }
07:37:36 <athan> geekosaur: I'll give it a shot, thank you :)
07:37:44 <athan> ahh perfect
07:38:18 <geekosaur> aikidoka, building older versions is already a problematic issue and you pretty much need to step backwards: 7.8 to build 7.6 to build 7.4 to ...
07:38:30 <besenwesen> hm. so i build https://github.com/ScrambledEggsOnToast/tetris-hs using cabal, but the program segfaults, and when i load it in ghci, ghci segfaults as well. is there some way of finding out exactly what’s messing up?
07:38:35 <geekosaur> I can well imagine that combining that with cross-compilation makes that explode
07:38:50 * hackagebot caramia 0.5.0.0 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.5.0.0 (Adeon)
07:39:34 <aikidoka> geekosaur: to figure out patches or to get an eventual build?  If I can build the 6.12.3 cross compiler in the end with 6.12.3 on the host then that would work for now.
07:40:15 <besenwesen> maybe using RTC switches or something?
07:40:16 <aikidoka> The goal is to allow a 64-bit build machine for a project before all the Haskell code is fixed to compile with 7.
07:41:36 <aikidoka> Or see if it will compile with an early version of 7.  I think I read that around 7.4 was when some deprecated stuff got completely removed.  Been reading too many mailing list items recently.
07:41:44 <geekosaur> aikidoka, I'm not even sure what you are asking there. my ppoint is that any given ghc version will compile the immediately preceding version but usually not older ones. neither building older versions nor cross compilation is well supported, and combining them is likely to cause problems\
07:41:58 <geekosaur> I think you need to ask this on the glasgow-haskell-users mailing list
07:42:18 <geekosaur> since you're mixing two poorly-supported things
07:42:43 <EvanR> poorly-supported ** 2
07:43:10 <aikidoka> ok.  Yeah, the build system is quite old.  (Squeeze 32-bit)
07:43:26 <aikidoka> Lots of work now to get all that resolved.
07:44:09 <aikidoka> geekosaur:  Thanks for the help!  I will get something on the list and see what comes back.
07:48:10 <aikidoka> oh, last question.  Being OE I have the option of running ./configure or letting it do autoconf and running the resulting ./configure.  What's the take on autoconf in regards to ghc?  Don't use it and just run the already included configure?
07:49:10 <greymalkin> I'm having trouble finding the canonical way to take an Int and putWord32be it.
07:49:27 <Clint> the canonical way
07:49:49 <greymalkin> .... s/canonical/most efficient/
07:50:04 <greymalkin> s/most efficient/standard/
07:50:16 <Clint> what do you want to do if the Int isn't 32-bit
07:50:28 <greymalkin> truncate.
07:50:41 <greymalkin> maybe fail is okay.
07:50:46 <liyang> :t putWord32be . fromIntegral
07:50:47 <lambdabot> Not in scope: ‘putWord32be’
07:50:52 <greymalkin> (but not error
07:51:43 <geekosaur> aikidoka, think you need the ghc folks for that, my recollection is you don't run autoconf directly but the "boot" script which does it and a bunch of other things for you
07:51:51 <greymalkin> *shameface*
07:51:57 <greymalkin> yeah.
07:52:23 <geekosaur> I don't know whether boot just runs a plain autoconf or passes any special options etc.
07:53:43 <greymalkin> geekosaur: If there's already a 'configure' script, then autoconf is complete, the configure stands on its own; just use it.
07:54:01 <geekosaur> true
07:54:27 <geekosaur> although this is about cross compilation so the question arises whether the configure you have is suitable for cross-comp
07:54:35 <geekosaur> or expects to target the host
07:59:05 <indiagreen> can I attach some debug routine to a Haskell value to find out when it's being garbage collected?
07:59:18 <EvanR> theres finalizers
08:01:35 <indiagreen> hm, no, I think I don't need it after all
08:01:37 <indiagreen> nevermind
08:03:50 * hackagebot concraft-hr 0.1.0.2 - Part-of-speech tagger for Croatian  http://hackage.haskell.org/package/concraft-hr-0.1.0.2 (vjeranc)
08:04:40 <crobbins> geekosaur: actually, ghci DOES reload TH
08:04:56 <crobbins> i just had to load the specific file that contained the TH
08:05:14 <crobbins> for instance, if i do ` :l Application.hs ` all is well
08:06:35 <crobbins> for my use case, even ` :l DevelMain ` works
08:06:51 <crobbins> it seems that :l will fully reload everything, including TH
08:07:01 <crobbins> so :r is useful when you are not dealing with TH
08:07:33 <EvanR> would you call this data structure parameterized by a a RegularExpression a = Concat [a] | Union [a] | Star a | Empty
08:07:48 <EvanR> or regular language, or something else
08:08:07 <bkulbida> Hi guys. What is the best source to start learning Haskell? I’m experienced Ruby and Python dev but want to dive into Haskell world…
08:08:40 <bkulbida> probably this question is general for all newcomers in H.
08:08:58 <EvanR> learn you a haskell for great good, standard answer
08:09:05 <stewtj3> Does anyone know of any Haskell libraries that support multivariate linear regression?  Seems that statistics-linreg and the other libraries handle single variable linear regression only.  Thanks!
08:09:56 <EvanR> and i messed up my data type, it should refer to itself recursively, Star (RE a)
08:11:37 <stewtj3> bkulbida I really liked Learn You a Haskell (http://learnyouahaskell.com/).  Stephen Diehl has a great resource that is useful for folks at different skill levels (http://www.stephendiehl.com/what/).
08:13:11 <bkulbida> stewtj3: awesome, thanks.
08:13:13 <EvanR> the artwork is great
08:14:22 <stewtj3> bkulbida you're welcome.  I hope you enjoy learning Haskell.  I'm still learning it and I love it.
08:15:24 <suppi> bkulbida, LYAH was the first book on haskell I read too. but since it doesn't have exercises i felt that i can't really write haskell even after finishing it
08:16:12 <suppi> but I did feel like I understand the mindset of Haskell pretty well, so I would recommend it
08:17:27 <bkulbida> yeah, to prepare your brain for Haskell is definitelly right first step :)
08:18:37 <suppi> have a nice journey :) it never ends
08:18:55 <suppi> a lot more material will be waiting for you when you finish LYAH
08:22:23 <joe9> Any classyPrelude users? Can I replace Prelude with classyPrelude yet? Is it mature and well-used/popular?
08:23:36 <fresheyeball_> hey everyone
08:24:48 <aikidoka> geekosaur:  Thanks!
08:34:21 <fresheyeball_> Can anyone recommend an http client lib that would work well with wai and warp?
08:35:21 <athan> fresheyeball_: I thought Network.HTTP did pretty good
08:35:21 <endiruna> hello I am a very neeewb to haskel and i am trying to follow some online book
08:35:29 <athan> wait, what are you trying to do?
08:35:52 <endiruna> i do                 prova  :: Int -> Int
08:36:03 <fresheyeball_> I need to serve static file, expose a restful json api, and do server to server requests
08:36:04 <endiruna> and get Not in scope: ‘prova’
08:36:16 <athan> endiruna: You need to declare it!
08:36:28 <athan> ghci can be seen as an expression, mid-interpreted
08:36:32 <endiruna> i thought that is the declaration of type
08:36:36 <endiruna> then i do  prova x = x +1
08:36:41 <endiruna> it gives me an error
08:36:49 <athan> endiruna: well, see that's from a file
08:36:59 <athan> when you declare stuff in a `.hs` file, you have that freedom
08:37:03 <fresheyeball_> I looked at Network.HTTP but it says its stability is experimental
08:37:05 <athan> because you're not actually inside an expression
08:37:18 <athan> endiruna: use a `let prova ...` statement in GHCi :)
08:37:21 <marchelzo_> endiruna, try "let prova x = x + 1"
08:37:27 <endiruna> oh i see
08:37:44 <endiruna> so let needs always to be used to declare a function
08:37:46 <endiruna> ?
08:37:48 <marchelzo_> endiruna, no
08:37:55 <endiruna> only on ghci?
08:37:56 <marchelzo_> ghci is weird
08:37:58 <marchelzo_> yes
08:37:59 <athan> fresheyeball_: I mean, I'm pretty sure Data.Text is experimental lol
08:38:18 <fresheyeball_> ok
08:38:19 <EvanR> ghci is sort of in an implicit do under IO
08:38:22 <athan> fresheyeball_: I would give it a shot
08:38:24 <marchelzo_> endiruna, more generally, any thing that is not a top level definition needs let
08:38:31 <marchelzo_> Or a "where" clause
08:38:32 <athan> I think there's also a libcurl binding, actually!
08:38:33 <EvanR> in fact let for a function at the top level will not work in haskell source
08:38:53 <endiruna> thanks! and what does top level mean
08:39:02 <athan> endiruna: Not in an expression :)
08:39:03 <EvanR> outside a declaration
08:39:22 * athan goes back to the cellar :(
08:39:23 <EvanR> floating about
08:39:38 <endiruna> thanks a lot and sorry for the stupid questions
08:39:53 <fresheyeball_> also Request type from Network.HTTP conflicts with Request type from  wai
08:40:09 <fresheyeball_> I would preffer not to have multiple request types in the app
08:40:39 <athan> ahhh, shoot yeah
08:40:40 <athan> hmm
08:41:17 <athan> fresheyeball_: Do you need deep details in the REST api? If so, you might want to stay with Network.HTTP and put all your data handling and client-stuff in a separate module
08:41:33 <athan> fresheyeball_: But if you're just pinging for the data, libcurl might be an idea
08:43:05 <fresheyeball_> hmm
08:43:30 <fresheyeball_> my understanding is that Network.HTTP does not have tools for serving static asset paths or even basic routing
08:43:38 <athan> correct!
08:43:44 <fresheyeball_> wai and warp give me the basics of what I need
08:43:47 <fresheyeball_> but no client stuff
08:43:47 <athan> I think it's just a client lib + some defs for http :/
08:43:58 <athan> you can intermingle any libs with each other!
08:44:07 <athan> if you can make the seams cooperate (over modules)
08:44:38 <fresheyeball_> ok so thats another good question
08:44:51 <fresheyeball_> how can I import 2 modules with conflicting types?
08:45:01 <athan> fresheyeball_: there's a lot of ways
08:45:19 <athan> I use qualified imports often for Data.Text, for instance
08:45:51 <fresheyeball_> ok
08:45:53 <athan> or sometimes I'll make a wrapper module for one, just to get the info I need in my own data tpyes
08:46:14 <fresheyeball_> so I've seen `import Foo as F` and `import qualified Foo as F`
08:46:19 <fresheyeball_> what is the difference?
08:46:40 <znst> how do I say this? `type Application = Request -> ResourceT IO Response`
08:48:50 * hackagebot binary-typed 0.3 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.3 (quchen)
08:49:43 <athan> I'm actually not sure :/ I've never used the first
08:49:43 <athan> I think documentation, maybe..?
08:50:11 <jtanguy> import .. as .. will try to bring symbols into scope
08:50:44 <jtanguy> whereas the qualified import will not
08:51:05 <athan> jtanguy: Will it not for clashes
08:51:08 <athan> ?
08:51:22 <athan> (not bring the symbols into scope if there's a clash)
08:52:15 <athan> znst: That should work :s
08:52:33 <athan> @src Reader
08:52:33 <lambdabot> Source not found. stty: unknown mode: doofus
08:52:50 <jtanguy> i don't know
08:53:06 <znst> "a WAI Application takes a Request and returns a Response, used in the context where I/O is possible and resources are well managed."
08:53:34 <znst> i'm reading this http://www.aosabook.org/en/posa/warp.html#sec.warp.arch
08:54:14 <dfeuer> I wonder ....
08:55:42 <athan> znst: We can declare function signatures as a type (or data type if you want more rigour) -- `type Foo a = a -> Int` will work, for instance
08:57:01 <znst> that makes my brain feel good
08:57:55 <athan> znst: GOOOD, goooood >:D
09:00:47 <athan> How should I sync my library dependencies and test suite dependencies? I just feel like installing all test suite dependencies manually, like `cabal install QuickCheck hspec ...` can be annoying, just to `cabal repl` :\
09:01:03 <greymalkin> Is there anyway to get the first (only) element of a ABT's constructor without explicitly matching the constructor?
09:01:47 <greymalkin> athan: I just do 'cabal install' -- it fails when it gets to my program (usually) but it does pull/build all the dependencies.
09:02:02 <glguy> greymalkin: $ cabal install --dry-run --enable-tests --only-dependencies
09:02:05 <glguy> err
09:02:10 <glguy> athan :)
09:03:06 <athan> glguy: Doh! Thanks :)
09:03:50 * hackagebot leaky 0.1.0.1 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.1.0.1 (AndrewSeniuk)
09:09:30 <greymalkin> So, I tried writing fn (_ a) = doSomething a ; but it won't compile.
09:10:14 <greymalkin> Is there anyway to match an ABT that has many single-parameter data constructors (only) and get the parameter only?
09:10:49 <ReinH> greymalkin: I think you mean "ADT", and no.
09:11:01 <exio4> what would the type of that?
09:11:04 <ReinH> You must pattern match on contructors.
09:11:10 <greymalkin> Ugh.
09:11:16 <greymalkin> yeah, adt, typeo
09:18:50 * hackagebot servant-server 0.2.2 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.2.2 (AlpMestanogullari)
09:23:35 <joe9> http://www.stephendiehl.com/what/#prelude talks about not using Data.List.filter. Just wanted to check what the alternative is, please?
09:24:22 <jfischoff> partition?
09:24:38 <joe9> jfischoff: thanks, will check on partition
09:24:40 <jfischoff> oh wait
09:24:43 <jfischoff> just read the link
09:25:00 <jfischoff> He is just recommending using a more general filter
09:25:42 <joe9> jfischoff: I am not sure where to find a more general filter.
09:25:57 <jfischoff> yeah actually let me read this thing :p
09:26:20 <athan> I want a general lookup, too :(
09:27:37 <jfischoff> joe9: yeah I think that is an accident or I am missing something
09:28:07 <jfischoff> because there is no general filter in Data.Foldable
09:28:13 <jfischoff> or Traversable
09:28:50 * hackagebot deepseq-bounded 0.5.1 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.5.1 (AndrewSeniuk)
09:28:50 <joe9> jfischoff: yes, that is what I am finding.
09:29:06 <joe9> jfischoff: and, neither do classy-predule or basicprelude.
09:29:26 <jfischoff> joe9: my bet is it was mistake, I would just ignore it
09:31:31 <ReinH> jfischoff: hi!
09:31:42 * jfischoff waves at ReinH 
09:31:45 <ReinH> jfischoff: mind if I pm?
09:31:57 <jfischoff> not at all
09:31:59 <johnw> ReinH: o/
09:33:51 <ReinH> johnw: hi! I am org-mode-ing all the things now! It's really nice. I've been using a somewhat GTD approach.
09:34:09 <johnw> cool, I've seen org/GTD articles lying around
09:38:48 <jtanguy> Is there a reason for the Alternative typeclass ? It seems equivalent to (Applicative f, Monoid f)
09:38:50 * hackagebot seqaid 0.1.2 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.1.2 (AndrewSeniuk)
09:38:52 * hackagebot typedquery 0.1.0.0 - Parser for SQL augmented with types  http://hackage.haskell.org/package/typedquery-0.1.0.0 (tolysz)
09:39:22 <glguy> jtanguy: The constraint is at a different kind, so Alternative f     allows you to use the operation on f a, f b, f c, etc
09:39:27 <EvanR> you probably want alternative to do something different from monoid
09:39:53 <glguy> to express that with Monoid you'd need to know all the types you wanted to support in advance: Monoid (f a), Monoid (f b), etc...
09:40:00 <EvanR> oh
09:40:24 <johnw> i.e., difference in kind
09:41:25 <jtanguy> i'd need a forall a. Monoid (f a) ?
09:41:39 <ReinH> johnw: Yeah, I looked at one.
09:41:53 <johnw> I never could get into the whole GTD thing
09:42:00 <glguy> jtanguy: you'd need some syntax that doesn't exist similar to that
09:43:16 <uniquenick> what does "cabal init" want git for?  and is there an option I missed to tell it not to?
09:43:35 <johnw> It just allows pointing at the repository for the project, but it should be totally optional
09:43:50 * hackagebot mysql-simple-typed 0.1.0.0 - Typed extension to mysql simple  http://hackage.haskell.org/package/mysql-simple-typed-0.1.0.0 (tolysz)
09:43:52 * hackagebot postgresql-simple-typed 0.1.0.0 - Typed extension for PostgreSQL simple  http://hackage.haskell.org/package/postgresql-simple-typed-0.1.0.0 (tolysz)
09:43:56 <uniquenick> it just barfs with "git: command not found"
09:44:05 <johnw> oh, huh
09:44:11 <johnw>  I didn't realize that
09:44:13 <jtanguy> I think it tries to guess your name and email from git/darcs/hg
09:44:35 <kadoban> Really? Weird
09:44:46 <dcoutts> uniquenick: file a ticket, it ought to handle that gracefully
09:47:52 <crobbins> @i Decimal
09:47:53 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
09:48:08 <crobbins> > read "10" :: Int
09:48:10 <lambdabot>  10
09:48:13 <crobbins> > read "10" :: Decimal
09:48:14 <lambdabot>  Not in scope: type constructor or class ‘Decimal’
09:48:35 <crobbins> is there a standard fixed-precision type?
09:48:50 * hackagebot leaky 0.1.0.2 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.1.0.2 (AndrewSeniuk)
09:48:52 * hackagebot sqlite-simple-typed 0.1.0.0 - Typed extension to sqlite simple  http://hackage.haskell.org/package/sqlite-simple-typed-0.1.0.0 (tolysz)
09:49:06 <johnw> "standard"?   do you mean in the Haskell report?
09:49:19 <johnw>  because there's a lot of functionality that you just need to import
09:49:35 <johnw>  I'm pretty sure that Decimal is in base
09:49:50 <glguy> There's http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Fixed.html
09:49:52 <crobbins> nah, you have to install Decimal
09:50:04 <johnw> crobbins: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Fixed.html
09:50:07 <johnw> try Fixed
09:50:18 <crobbins> yeah, i have been using Decimal, but it's read instance is apparently whack
09:50:30 <crobbins> `read "10" :: Decimal` works
09:50:40 <crobbins> but `read "Just 10" :: Maybe Decimal` fails
09:52:02 <EvanR> > read "10" :: Pico
09:52:08 <lambdabot>  mueval: ExitFailure 1
09:52:13 <EvanR> > read "10" :: Pico
09:52:13 <crobbins> > read "10" :: Centi
09:52:15 <lambdabot>  10.00
09:52:18 <lambdabot>  mueval: ExitFailure 1
09:52:22 <ReinH> johnw: I'm just going to steal the practices that seem valuable, which is more than none of them...
09:52:22 <crobbins> > read "99.12" :: Centi
09:52:24 <lambdabot>  99.12
09:52:31 <crobbins> ok, Centi is where it is at
09:52:32 <EvanR> > read "10" :: Nano
09:52:34 <crobbins> i am ditching Decimal
09:52:37 <lambdabot>  mueval: ExitFailure 1
09:52:41 <EvanR> > read "10" :: Micro
09:52:42 <lambdabot>  10.000000
09:52:45 <EvanR> wtf
09:52:51 <ReinH> johnw: but wow, it's so easy to get tasks into your system with capture and refile...
09:53:04 <johnw> yep
09:53:05 <ReinH> That workflow alone is so valuable
09:53:26 <dnivra> Hello everyone! Is there something similar to PySchools, Code Academy or CheckiO for learning Haskell? I tried looking but didn't find anything so thought I'd ask here.
09:53:37 <timmy_tofu> Is there a way to propagate flags to local cabal dependencies? Ex I have library a depending on library b, can I cabal configure -fMYFLAG and have library b compile with that flag set (assuming it's properly defined in its cabal file)?
09:56:48 <sm> johnw, ReinH: did you see this one ? nice and short
09:56:59 <ReinH> sm: which?
09:57:00 <glguy> timmy_tofu: as far as I know you can't depend on flags
09:57:27 <sm> hehe.. I forget we are not telepathic. This: http://hamberg.no/gtd/
09:57:46 <ReinH> sm: there's a college course with open lecture notes and exercises and such that some folks like, see https://github.com/bitemyapp/learnhaskell for more info
09:58:28 <ReinH> sm: that seems nice. Thanks!
09:58:33 <ReinH> sm: Making a task to read that later. ;)
09:58:47 <sm> np. It's got me back into it, been quite helpful
09:59:43 <ReinH> God I love org-mode.
09:59:48 <johnw> ReinH: :)
10:00:09 <ehamberg> Glad you found it useful, sm :)
10:00:11 <ReinH> johnw: I'm using weechat.el so I didn't even have to switch windows...
10:00:15 <ReinH> ehamberg: ha!
10:00:22 <ehamberg> ;)
10:00:33 <johnw> I use ERC, but in a separate Emacs process
10:00:35 <sm> ehamberg: ha! thank you!
10:00:45 <shapr> johnw: because of locking?
10:00:50 <Peaker> is anyone using ghci-ng? Wondering if anyone can help debug why it never finds my modules when trying to load them
10:00:53 <ReinH> johnw: Ah. Yeah, I really like weechat's remote features. So much better than any bouncer I've tried.
10:00:58 <johnw> I just find myself needing to restart Emacs too often
10:01:13 <johnw> Peaker: I've never tried it
10:01:16 <apo_> weechat's too sluggish for me
10:01:17 <Peaker> guessModule always returns Nothing
10:01:24 <ReinH> Peaker: I have used it a bit, not sure I know how to debug that. chrisdone is here and in #haskell-emacs if you're using ghci-ng with emacs...
10:01:32 <shapr> I'm using ERC to a ZNC process.
10:01:51 <johnw> shapr: same
10:02:00 <dfeuer> ReinH, johnw, I think I made it *somewhat* more understandable. Still haven't worked out a nice way to handle cases 4-9 though.
10:02:02 <ReinH> I tried that, wasn't very happy. To each their own.
10:02:21 <RchrdB> shapr: I stopped using ERC because I found it *too* good at telling me when there were outstanding unread messages because it was always *right there* in the status line in the file I'm trying to concentrate on. :)
10:02:45 <shapr> RchrdB: yeah, I have to do erc-track-disable sometimes
10:02:46 <Peaker> ReinH: yeah, chrisdone is the best guy for this, I don't think he's unavailable though :)
10:03:06 <johnw> let's move our delicious editor discussions to #haskell-emacs!
10:10:41 <deech> Is The Monad Reader on hiatus? Haven't seen one in a while.
10:22:09 <benzrf> how do i do space and time profiling again
10:23:51 <johnw> that's such a general question, benzrf
10:24:05 <johnw> have you asked Google about profiling in Haskell?  There are many resources
10:27:16 <benzrf> fft
10:27:22 <benzrf> its way easier to ask vague questions in irc
10:33:38 <WigglesMcMuffin> benzrf: You use a space and time profiler. There is your vague answer
10:34:59 <benzrf> thanks <3
10:48:50 * hackagebot uhc-light 1.1.8.2 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.2 (AtzeDijkstra)
10:51:09 <benzrf> is there a way to do profiling from runhaskell w/o compiling
10:57:16 <geekosaur> benzrf, I don't think so, mostly because nobody trusts profiling output from the interpreter
10:57:36 <johnw> there ARE ways to do profiling in that scenario, but they won't have results you'd care about
10:57:52 <benzrf> oh
10:57:54 <benzrf> bwuh
10:57:59 <benzrf> i thought it compiled it but like uh
10:58:01 <benzrf> i dunno
10:58:13 <johnw> system-level stochastic profiling will always work
10:58:23 <johnw> but it lacks any information about your program
10:59:25 <chrisdone> papers should have a tl;dr so that you can skip all the justification for why it's a good idea =p
10:59:35 <chrisdone> and skip straight to the meat :3
11:00:02 <chrisdotcode> hi chrisdone
11:00:08 <chrisdone> blah-blah-blahs are useful for blah blah blah[2], blah blah[3], blah. yeah, i get it that's why i'm reading this paper
11:00:19 <chrisdone> hi chris
11:00:22 <johnw> chrisdone: isn't that what the abstract is?
11:00:41 <schell> does anyone know the recommended way to install ghc7.8.3 on nixos?
11:00:49 <johnw> nix-env -i ghc
11:01:06 <schell> that easy huh? haha
11:01:29 <schell> i’m looking through packages with nix-env -qa | grep ghc and didn’t see that one i guess?
11:01:39 <johnw> hmm
11:01:44 <johnw> nix-env -qaP '*' | grep -i ghc
11:01:45 <schell> it’s my first time driving
11:01:50 <sivteck> haskellPackages.ghc
11:02:05 <johnw> oh, you may need nix-env -iA ghc
11:02:16 <johnw> it's possible that the "common" name is ghc-wrapper or something
11:02:40 <chrisdone> peaker: did you see the video i linked you yesterday?
11:02:40 <schell> i’m assuming nix-env -iA ghc is “install all ghc”? or similar?
11:02:59 <johnw> -A specifies the package by attribute name
11:03:50 <mmachenry> Is there a simple way to use a cabal project that I have with all the libraries I've installed and written but write a new executable for testing without editing my .cabal file and adding a new record for it?
11:03:55 <timmy_tofu> Does anyone know of a reason a C preprocessor flag would be visible in one module of a library, but not another? We have a snap application and the DEVELOPMENT flag works fine in Main.hs, but not in Site.hs when running the executable (but when "running" the library via cabal repl, the flag does take). My colleague asked in the snap-framework room a while ago but they had no answer.
11:04:29 <dcoutts> timmy_tofu: LANGUAGE CPP
11:04:32 <dcoutts> pragma
11:04:49 <timmy_tofu> dcoutts: yeah, I got that
11:04:50 <dcoutts> mmachenry: sure, just install the lib, then you can compile progs against it using ghc or ghci
11:05:01 <schell> johnw: thanks :)
11:05:21 <timmy_tofu> as I said, it works fine in ghci as a library, only when doing cabal run is it a problem. It works in Main.hs, but not in Site.hs
11:05:56 <mmachenry> dcoutts: Will cabal install do that?
11:06:13 <dcoutts> mmachenry: right
11:06:27 <mmachenry> Hm, that doesn't seem to work for me. Let me test again.
11:06:31 <dcoutts> timmy_tofu: are they in the same component in the .cabal file?
11:06:54 <WigglesMcMuffin> Is there a name for mapping a map to something. As in I have an array of arrays? I could have sworn I've heard someone referring to it as a spreadmap or a starmap (maybe in groovy) but I wasn't able to find anything on it at all
11:07:58 <timmy_tofu> dcoutts: they = the two source files?
11:08:07 <dcoutts> timmy_tofu: yeah
11:11:57 <timmy_tofu> The executable black has no explicit mention of the Site source file, just Main (as main-is:). I know of no way to mention other stuff in an executable block (exposed-modules is nonsensical, for instance)
11:13:08 <jtanguy> you have other-modules
11:13:54 <timmy_tofu> Yeah, that hasn't helped
11:15:31 <mmachenry> dcoutts: I'm doing something wrong here. I have a cabal managed project with a sandbox. I did a cabal install. But ghc still doesn't find my library when I import it.
11:15:41 <timmy_tofu> I'm not sure what it's role in the executable block is, in fact. Despite the documentation, I've seen no difference between including and excluding things from that as an executable
11:15:57 <dcoutts> mmachenry: ah, if you're in a sandbox then there's another step
11:16:07 <mmachenry> Oh yeah?
11:16:07 <kadoban> mmachenry: GHC doesn't know about cabal sandboxes by itself.
11:16:11 <dcoutts> mmachenry: ghc is not directly aware of the packages registered in the sandbox
11:16:20 <dcoutts> but you can tell it with a flag or env var
11:17:44 <dcoutts> mmachenry: or I think cabal exec can do that now
11:17:57 <mmachenry> dcoutts: ghci -i ./cabal-sandbox myprog?
11:18:13 <dcoutts> try cabal exec bash
11:18:19 <dcoutts> and then run ghc from there
11:19:12 <kadoban> mmachenry: I think 'cabal repl' is mostly a replacement for ghci. It doesn't work quite the same exactly though.
11:19:30 <dbushenko> hi all!
11:19:41 <dbushenko> have a look at this piece of code: http://lpaste.net/116875
11:19:42 <chrisdone> ahoy
11:20:09 <dbushenko> if I run it and navigate to not existing ID (see the last route) then exception occures and the whole server hangs
11:20:25 <dbushenko> how to catch all the exceptions to prevent server freezing?
11:20:38 <sm> tsk tsk
11:22:30 <sm> dbushenko: maybe one of the other web frameworks handles it better ?
11:22:46 <sm> like Spock
11:23:03 <dbushenko> maybe... but is there some common way to catch everything?
11:23:04 <Arnob> Hi all
11:23:27 <Arnob> I was wondering if anyone could point me to the library cabal uses to parse its config file
11:23:31 <chrisdone> dbushenko: are you compiling with -threaded?
11:23:37 <dbushenko> no
11:23:39 <sm> sure, but "here be dragons".. unless you're interested in that I'd find a lib that handles it right
11:23:58 <chrisdone> dbushenko: add it. without it your program isn't multithreaded
11:24:19 <dbushenko> oops...
11:24:21 <chrisdone> when an exception is thrown on a thread, just that thread dies, not the whole program
11:24:25 <sm> aha
11:24:32 <dbushenko> let me try...
11:24:55 <timmy_tofu> dbushenko: The problem is bound to be in showArticle, it's probably running a query, assuming there will be one row returned, pattern matching based on that assumption, and throwing an error when querying a non-existant id returns zero rows. You'll want to handle it better there
11:26:06 <dbushenko> timmy_tofu, yes, you are perfectly right. but I thought that there could be some general way to catch all the exceptions, even if I can't predict what type of the exceptions might occur
11:27:36 <chrisdone> dbushenko: you catch exceptions with `catch' and if you want to catch everything you catch the SomeException type
11:27:38 <timmy_tofu> dbushenko: There are a few ways, none of which should be your first option. See catch, catchE and friends
11:28:03 <dbushenko> chrisdone, thanks!
11:28:08 <jtanguy> Scotty also bakes some error managment
11:29:19 <dbushenko> jtanguy, really? let me see if I can find any examples...
11:29:26 <jtanguy> with raise, rescue, next and defaultHandler
11:30:11 <juliohm> Backing again to spy the current haskell state, this is the language of my dreams
11:30:45 <johnw> current haskell state is looking pretty good, with more work needed on larger infrastructure
11:30:50 <christmasdotcode> All haskel needs is dependent/refinement typing in core, and overloadedrecordfields to win my heart for ever.
11:30:55 <jtanguy> dbushenko: here is an example: https://github.com/jtanguy/minipaste/blob/master/src/Main.hs
11:30:58 <dbushenko> jtanguy, yeah, thanks!
11:31:03 <dbushenko> I've found an example
11:31:06 <johnw> christmasdotcode: do you use liquid haskell presently?
11:31:12 <juliohm> Do you guys have any performance comparison with the new Julia language? http://julialang.org/
11:31:23 <juliohm> See the performance table, how would Haskell fit there?
11:31:35 <dbushenko> jtanguy, oh, thats your app on Scotty?
11:31:39 <juliohm> Can anyone write those benchmarks in Haskell?
11:31:52 <dbushenko> how do you handle sessions there
11:31:53 <dbushenko> ?
11:32:02 <christmasdotcode> johnw: Not currently. I can't figure out the different between dependent and refinement/ waiting until LH is a bit more mature/ gets a bit of a nicer syntax
11:32:12 <indiagreen> juliohm: have you checked out the benchmarks game?
11:32:18 <juliohm> indiagreen, yes
11:32:18 <johnw> juliohm: are performance benchmarks a deciding factor for you/
11:32:21 <johnw> ?
11:32:30 <juliohm> johnw, in some sense they are
11:32:37 <juliohm> I need performance for my engineering apps
11:32:41 <Arnob> I was wondering if anyone could point me to the library cabal uses to parse its config file
11:32:49 <jtanguy> dbushenko: no, unfortunately
11:33:05 <chrisdone> Arnob: sorry i forgot your question above. it's in the Cabal package
11:33:12 <chrisdone> @hackage Cabal
11:33:12 <lambdabot> http://hackage.haskell.org/package/Cabal
11:33:25 <chrisdone> look in PackageDescription.Parse
11:33:33 <Arnob> ah ok... I am looking at the source for that package
11:33:40 <johnw> christmasdotcode: one difference: refinements are a restrained category of decidable propositions
11:33:45 <chrisdone> http://hackage.haskell.org/package/Cabal-1.20.0.2/docs/Distribution-PackageDescription-Parse.html#v:parsePackageDescription
11:33:58 <Arnob> but not sure where the parser is located
11:33:58 <Arnob> https://github.com/haskell/cabal/tree/master/Cabal
11:33:59 <johnw> christmasdotcode: whereas dependent type is arbitrarily and requires separate proofs of correctness
11:34:15 <johnw> refinements are specific enough that they can be determined by a solver
11:34:25 <jtanguy> dbushenko: here there is a small app with http basicAuth: https://github.com/divarvel/scotty-short
11:34:28 <christmasdotcode> johnw: Interesting. I thought dependent types *were* that, from the explanation I got from Elm.
11:34:35 <johnw> dependent types are way more
11:34:43 <johnw> refinements are one tiny subset of what dependent types can express
11:35:17 <dbushenko> jtanguy, nice!
11:35:30 <dbushenko> jtanguy, I've already done that but as as json REST service
11:35:42 <dbushenko> I also don't have sessions
11:35:49 <juliohm> johnw, what is your comment about performance?
11:35:59 <johnw> juliohm: what do you mean?
11:36:09 <juliohm> johnw, how Haskell would fit in that table?
11:36:17 <johnw> I have no idea
11:36:25 <juliohm> Any estimate?
11:36:31 <johnw>  I have never needed to care about performance to such a degree that I would have to abandon Haskell for another language
11:36:39 <juliohm> Anyone willing to write the benchmarks for the Julia website?
11:36:53 <johnw>  Haskell is always either been fast enough, or I've been able to make it fast enough by changing algorithms or other aspects of the code
11:36:54 <juliohm> I'm really curious about it
11:36:57 <chrisdone> i would worry about finding libraries for things in haskell
11:37:01 <chrisdone> rather than its performance in particular
11:37:13 <chrisdone> julia's catered for a specific domain, so it has all the libraries
11:37:14 <juliohm> chrisdone, that is also true
11:37:48 <juliohm> Haskell is so nice language but misses some libraries for daily scientific work
11:37:57 <znst> http://www.aosabook.org/en/posa/warp.html#the-performance-of-warp
11:38:07 <juliohm> Does it have an image library?
11:38:15 <juliohm> To manipulate images
11:38:22 <chrisdone> several afaik
11:38:38 <juliohm> How about Qt support?
11:38:51 <dmwit> ?unmtl StateT s [] a
11:38:51 <lambdabot> s -> [] (a, s)
11:39:03 <chrisdone> i think there's support but i don't know anything about its quality
11:39:06 <clrnd> unmtl lol~
11:56:07 <xplat> johnw: actually 'refinement type systems' usually refer to refinement with a decidable language of propositions, but 'refinement types' could also involve separate proofs.  also a 'type refinement' is something else entirely, expressed for example as a functor between two categories of types.
11:56:26 <johnw> xplat: ah, ok, thanks for the clarification
11:58:51 * hackagebot torrent 10000.0.0 - BitTorrent file parser and generater  http://hackage.haskell.org/package/torrent-10000.0.0 (JoeyHess)
11:59:35 <xplat> highest version number -> best torrent package!
11:59:47 <MP2E> ^ lol
11:59:49 <kadoban> Indeed
11:59:52 <MP2E> 10000.0.0
11:59:55 <MP2E> quite the version number
12:00:38 * kadoban wonders how high it can go...
12:02:01 <clrnd> version 9999 wasn't that good
12:02:34 <jtanguy> the package maintenance was taken over, and the old version was date-based
12:02:39 * monochrom instead ponders how infinitestimal increments can go, e.g., 10000.0.0000000000000000000000001
12:02:54 <kadoban> Why not both? 100000000000000000.0.000000000000000000000001
12:02:59 <joeyh> well, it's bittorrent, perhaps the version number is in binary ;)
12:04:21 <monochrom> I use base 10.
12:04:35 <monochrom> (tautology!)
12:05:03 <kadoban> Hah
12:06:39 <xplat> 10.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1
12:07:00 <xplat> a documentation patch that doesn't change the glyph shape of any of the letters
12:07:00 <johnw> the best thing about tautologies is the best thing about tautologies
12:07:31 <xplat> the first rule of tautology club is the first rule of tautology club
12:07:43 <znst> johnw: lol
12:08:24 <monochrom> http://cowbirdsinlove.com/comics/43/base10.png
12:08:33 <MP2E> the first rule of haskell club is <<loop>>
12:10:47 <clrnd> xplat lol
12:11:07 <xplat> the first rule of quine club is to write, followed by itself in quotes: "the first rule of quing club is to write, followed by itself in quotes: "
12:14:32 <spopejoy> can anybody help me understand why "ask", "reader" etc don't work under an 'EitherT a (ReaderT b m) c' stack, when it DOES work under an 'EitherT a (RWST b c d m) e' stack?
12:15:04 <bennofs> spopejoy: where did you import ReaderT from?
12:15:16 <spopejoy> Control.Monad.Trans.Reader
12:15:43 <bennofs> spopejoy: you need to one from Control.Monad.Reader. Control.Monad.Trans.Reader doesn't provide the required type class instances
12:16:01 <bennofs> In particular, Control.Monad.Reader is provided by the '
12:16:13 <xplat> more importantly, it doesn't even have the version of 'reader' or 'ask' that uses the typeclass
12:16:17 <monochrom> yeah, "ask" etc in Control.Monad.Trans.Reader are ordinary functions rather than general methods
12:16:28 <spopejoy> Oof. Confusing. But OK works, thanks!
12:16:37 <bennofs> ooops, linebreak: 'mtl' package while Control.Monad.Trans.Reader is from 'transformers' (which doesn't include typeclasses like MonadReader)
12:17:00 <monochrom> it's because there are people who do not want the type class generality but still want the same names.
12:17:03 <xplat> well, there's more to transformers than meets the eye.
12:17:47 <monochrom> it's a bit like both Data.List and Data.Bytestring provide "filter"
12:19:11 <xplat> that one can be a little annoying :(
12:19:37 <spopejoy> MaybeT is just transformers, and seems to be suitably polymorphic for everything
12:19:45 <xplat> someone please develop the 'Filterable' class
12:20:23 <monochrom> I think it has been done. there is a package generalizing over [], Bytestring, and Text.
12:20:39 <shachaf> Someone was just talking about ways to make that class nice.
12:20:51 <monochrom> so my analogy should be "it's a bit like both Data.Bytestring and <that package> provide 'filter'"
12:21:01 <shachaf> @hackage witherable
12:21:01 <lambdabot> http://hackage.haskell.org/package/witherable
12:21:23 <shachaf> I don't know if I'm that happy with that class.
12:21:57 <xplat> Kinoshita is such a great name for a functional programmer :)
12:24:13 <xplat> shachaf: what do you find wrong with it
12:24:25 <nkar> why does this program keep printing "hi" after the main thread exits? http://dpaste.com/1BQZ6X3
12:26:00 <iElectric> ocharles_: hey, what web framework would you recommend for a simple RESTful api with JSON and SQL backend?
12:26:42 <xplat> nkar: a process doesn't kill all its children when it exits.
12:27:25 <nkar> xplat: okay, how should I rewrite this program to make it exit?
12:29:33 <xplat> nkar: well, you'd have to save the pid in order to kill the subprocess with a signal
12:29:50 <xplat> nkar: btw wrapping process in forkIO doesn't really buy you much
12:30:12 <ocharles_> Hey iElectric :) If it's a small service - probably scotty + postgresql-simple
12:30:19 <ocharles_> assuming SQL = PostgreSQL
12:31:15 <nkar> xplat: should terminateProcess work?  I tried it, but it doesn't seem to make a difference.
12:31:43 <xplat> well, i guess it does buy you something when you're using rawSystem since that waits for completion, but since you're throwing away any info you get at completion anyway you may as well just spawn the subprocess in a nonblocking way
12:32:24 <nkar> xplat: sorry, I forgot to mention that I replaced rawSystem with spawnProcess when I tried it.
12:33:28 <nkar> also, is -threaded required?
12:34:10 <xplat> -threaded shouldn't be required if you're seeing "bye" at all
12:34:27 <xplat> you could try "interruptProcessGroupOf" and see if that works
12:35:06 <zipper> So under which category is a haskell wrapper around a JSON api when running cabal init? The categories include Math, Concurrency, Codec, Language etc
12:35:23 <xplat> Web?
12:35:33 <zipper> xplat: Thanks
12:36:30 <zipper> In cabal init what does field mean in this context "Include documentation on what each field means"
12:36:42 <clrnd> why is wai so far down in techempower.com's performance benchmarks?
12:37:20 <dcoutts> zipper: it'll add comments into the .cabal file explaining what things are
12:37:28 <dcoutts> zipper: it's useful the first few times
12:37:45 <dcoutts> after that it just takes up space
12:37:48 <zipper> dcoutts: Oh I don't think I need that.
12:38:32 <dfeuer> dcoutts, no can making this enumFrom stuff work. Stuff I need isn't exported. But I actually think a better answer might be to add some methods to IsList to support such things.
12:41:10 <nkar> xplat: thank you so much, I would still be scratching my head without your help
12:51:36 <iElectric> ocharles_: nice, that looks way better than yesod
12:51:51 <ocharles_> iElectric: I have never used yesod, but it's not to my test
12:51:53 <ocharles_> taste*
12:51:58 <ocharles_> We use Snap at work
12:52:25 <christmasdotcode> type-safe urls are nice
12:53:02 <iElectric> ocharles_: cool, and for facebook api I guess haxl?
12:53:15 <ocharles_> no, haxl is for data access in general
12:53:21 <ocharles_> it's a glue layer, if you will
12:53:26 <ocharles_> for facebook I use the "facebook" library
12:53:32 <ocharles_> (or is it called `fb`? I forget)
12:53:56 <iElectric> fb
12:54:16 <iElectric> it's that feeling of trying another language, it's like being born again
12:54:18 <iElectric> ocharles_: tnx
13:00:54 <tdammers> hmm, is there a way to somehow integrate Aeson into a Parsec parser?
13:01:50 <benzrf> who knows
13:01:52 <benzrf> @google aeson parsec
13:01:54 <lambdabot> http://stackoverflow.com/questions/19511678/conduit-with-aeson-attoparsec-how-to-exit-cleanly-without-exception-once-sour
13:01:54 <lambdabot> Title: haskell - Conduit with aeson / attoparsec, how to exit cleanly without except...
13:02:06 <benzrf> n-never mind
13:02:31 <tdammers> guess not
13:02:34 <tdammers> shame
13:02:59 <tdammers> I have a little query language that is similar-ish to SQL, but it accepts JSON for value literals
13:03:21 <tdammers> it would be lovely to be able to just hook Aeson into it, but I guess that's not an option
13:03:36 <johnw> why not?
13:03:52 <johnw> if you can parse out the json "blocks", then you can use aeson to parse those blocks
13:04:20 <tdammers> yeah, except that parsing out the json blocks pretty much amounts to parsing JSON
13:04:28 <johnw> like the way that pipes-parse can segregate an incoming stream into multiple separate streams, each of which you can parse as you like
13:04:40 <tdammers> might as well harvest the actual value as I go, then there'd be no reason to use Aeson
13:04:40 <johnw> ah
13:05:34 <tdammers> if I could somehow get a handle to the remaining stream, pass it to Aeson, have aeson parse out a JSON value and hand me back the remainder of the stream, that would be cool
13:05:50 <tdammers> can't find anything in Aeson documentation in this direction though
13:08:22 <t4nk042> Can someone tell me what this symbol means (Latex \sqsubset) ⊏? Google did not help much.
13:10:29 <ocharles_> t4nk042: any context?
13:11:43 <t4nk042> ocharles: I was going through http://www.cs.nott.ac.uk/~gmh/cat2.pdf. It is used in describing a Functor on pre-ordered sets in page 5
13:13:51 * hackagebot git-annex 5.20141219 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141219 (JoeyHess)
13:28:18 <[derek]> want to install GHC, currently doing apttiude upgrade :(
13:29:48 <Rufflewind> Does anyone know how to get this rank-2 type to pass GHC's type checker?
13:29:54 <Rufflewind> > let { foldr = undefined :: forall c . (() -> c -> c) -> c; foldr' = foldr :: (() -> T -> T) -> T; } in ()
13:29:55 <lambdabot>  Not in scope: type constructor or class ‘T’Not in scope: type constructor or...
13:30:30 <Rufflewind> > let { foldr = undefined :: forall c . (() -> c -> c) -> c; foldr' = foldr :: (() -> (forall s . s -> s) -> forall s . s -> s) -> forall s . s -> s; } in ()
13:30:31 <lambdabot>  Couldn't match type ‘s1 -> s1’ with ‘forall s2. s2 -> s2’
13:30:31 <lambdabot>  Expected type: (() -> (forall s. s -> s) -> forall s. s -> s)
13:30:31 <lambdabot>                 -> s1 -> s1
13:31:28 <[[derek]]> > let how to haskell?
13:31:29 <Rufflewind> It works if I wrap 'forall s . s -> s' into a newtype but I've not found a way to get it to work otherwise :/
13:31:29 <lambdabot>  <hint>:1:20:
13:31:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:32:04 <[[derek]]> I've forgotten pretty much all of my haskell knoweledge since I last looked at it
13:32:49 <mauke> > 2 + 2
13:32:50 <lambdabot>  4
13:33:04 <[[derek]]> Also my laptops brightness controls have broken so I'm stuck at full brightness during the night
13:33:07 <[[derek]]> my eeeyes
13:34:43 <Peaker> Rufflewind: A value of type (forall s. s -> s) is not very useful, it's equivalent to "id"
13:34:53 <Peaker> Rufflewind: (a parameter of that type will always be "id")
13:35:06 <jtanguy> [[derek]]: did you take a look at f.lux ?
13:35:17 <luite> [[derek]]: you can wear sunglasses
13:35:32 <burp> or redshift http://jonls.dk/redshift/
13:35:41 <kristof> Someone ported a big chunk of prelude to C89
13:35:45 <kristof> http://ideone.com/qKzAAl
13:35:56 <zipper> Shouldn't Main be by default an exposed module if I want my users to interact with it and therefore list it in my exposed modules in my .cabal file?
13:36:14 <[[derek]]> jtanguy: my laptop does go to a really low brightness which is fine, its just that my current update broke the brightness drivers, yay debian unstable!
13:37:11 <Rufflewind> Peaker: I simplified the problem a bit so I'm not actually using forall s . s -> s  :)
13:37:32 <[[derek]]> really looking forward to trying the haskell scheme intrepreter tutorial
13:37:38 <Rufflewind> Peaker: I didn't want to paste a huge blob here, but the example I gave reproduces the problem I encountered
13:38:58 <jtanguy> zipper: usually Main is for an executable. If you want to expose it as a library, you should find another name for the module
13:39:30 <zq> Rufflewind: -XImpredicativeTypes
13:39:31 <Peaker> Rufflewind: I think it's impredicativity -- same reason "runST . forever" doesn't type-check either
13:41:32 <[[derek]]> good news! brightness is working again
13:41:53 <Rufflewind> but is there a workaround?  you can write let f x = runST (forever x) and have it type-check
13:42:20 <Rufflewind> and I can also do it with newtypes, without specifying ImpredicativeTypes
13:44:39 <Rufflewind> (Also I've not found a way to make it work even with ImprecativeTypes)
13:49:24 <geekosaur> ImpredicativeTypes is known to be erratic
13:49:51 <chrisdone> when ghc suggests to enable an extension when something doesn't compile
13:50:09 <chrisdone> i've never ever enabled ImpredicativeTypes and then my code compiled
13:50:19 <chrisdone> is there a practical use for that extension in ghc?
13:50:36 <kadoban> Just based off the name, I thought that was from acme-*
13:50:55 <benzrf> kadoban: impredicative is a math werd
13:51:11 <benzrf> chrisdone: so youve never used a forall inside a type constructor ?
13:52:07 <kadoban> benzrf: Oh, I see. It sounds like...recursive, for types/sets
13:52:26 <jtanguy> maybe there will be a 24doge article on this extension
13:52:47 <Rufflewind> from what I heard people don't like that extension very much
13:52:56 <Rufflewind> it was almost removed at one point
13:53:29 <Rufflewind> hence why I'm trying to avoid it
13:54:22 <geekosaur> well. it's indispensable for some things. but it's also proved very, very difficult to make work properly
13:54:37 <chrisdone> in one ghc version it did say "this will be removed in the next version of GHC"
14:05:19 <Evilsparza> hey, what should I do to clean up this mess after a failed installation? http://lpaste.net/152801016402673664
14:05:24 <nyancat> http://ideone.com/PFQokx
14:05:30 <Evilsparza> cabal clean [package] doesn't work
14:05:47 <nyancat> Hi, is it possible to simplify this code to have the IO binding done at the same time as the Provider object is created?
14:05:58 <nyancat> This is all hapening inside an IO monad.
14:09:12 <pavonia> Evilsparza: Clean up what?
14:10:05 <pdxleif> Evilsparza_: haskell-src-exts didn't install; you could clean it out of Users\admin\AppData\Roaming\cabal\libs if you see a dir in there for it
14:10:17 <pdxleif> You shouldn't see it in ghc-pkg list
14:10:26 <Evilsparza_> alright
14:10:27 <pdxleif> You can run ghc-pkg check to see if anything looks broken
14:12:18 <Evilsparza_> gee ghc-pkg check gives me about a bazillion errors :/
14:12:26 <Evilsparza_> now I can't update anymore as well
14:12:33 <Evilsparza_> I think it's best I just reinstall it
14:16:17 <vrooom> haskell is just so wonderful, to bad it is onyl for the desktop
14:16:37 <vrooom> functional programming is one of those rare things i find truly beautiful
14:17:12 <vrooom> ill put functional programming next to scarlett johansson on humanities best efforts
14:17:34 <vrooom> > map "awesome" ["haskell", "scarlett"]
14:17:35 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> b’
14:17:36 <lambdabot>              with actual type ‘[GHC.Types.Char]’
14:17:51 <vrooom> > map (++"awesome") ["haskell", "scarlett"]
14:17:53 <lambdabot>  ["haskellawesome","scarlettawesome"]
14:18:58 <dv-> it's okay, i guess
14:19:14 <vrooom> > map (\x->x*x+1) [0..10]
14:19:15 <lambdabot>  [1,2,5,10,17,26,37,50,65,82,101]
14:19:27 <vrooom> okay? defineately the best thing since sliced bread
14:20:11 <EvanR> shes ok
14:20:15 <dv-> you can use map in a lot of languages
14:20:41 <athan> Is there an integer parser widely used, with a signature of `String -> Maybe Integer`? (or integral)
14:20:49 <athan> I just don't want runtime exceptions from `read` :/
14:20:58 <dv-> :t Text.Read.readMaybe
14:20:59 <lambdabot> Read a => String -> Maybe a
14:21:33 <EvanR> @hoogle String -> Maybe Integer
14:21:35 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
14:21:35 <lambdabot> Prelude fail :: Monad m => String -> m a
14:21:35 <lambdabot> Control.Monad fail :: Monad m => String -> m a
14:21:39 <vrooom> i didnt say ma made it awesome
14:21:40 <vrooom> that would be ridic
14:22:17 <chrisdone> athan: use Data.Text.Read
14:22:28 <athan> chrisdone: Thank you :)
14:22:46 <chrisdone> =3
14:22:57 <athan> >< Can I just have strings? D:)
14:23:56 <dv-> yeah, look up a bit
14:23:57 <EvanR> > reads "ab10" :: Integer
14:23:57 <geekosaur> I don't see what's wrong with http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Text-Read.html#v:readMaybe
14:23:58 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
14:23:58 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
14:24:16 <EvanR> > reads "ab10" :: [(Integer, [String])]
14:24:17 <geekosaur> (note, not Data.Text.Read)
14:24:17 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
14:24:17 <lambdabot>  Expected type: [(GHC.Integer.Type.Integer, [GHC.Base.String])]
14:24:17 <lambdabot>    Actual type: [(GHC.Integer.Type.Integer, GHC.Base.String)]
14:25:11 <athan> I'm just gonna fold =/
14:25:16 <athan> thanks guys :)
14:25:38 <dv-> am i in the twilight zone or something
14:25:38 <geekosaur> what
14:25:49 <Evilsparza> all them little files, haskell installs. my poor ssd :>
14:26:17 <geekosaur> ok, I have no idea what problem athan is having if Text.Read.readMaybe is for some reason unsuitable
14:27:00 <EvanR> > Text.Read.readMaybe "1234" :: Maybe Integer
14:27:01 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
14:27:18 <athan> geekosaur: It's just.. it makes me feel _wrong_ :C
14:27:22 <geekosaur> ???
14:27:47 <athan> geekosaur: (I'm just being silly. I'm working with `getArgs`, it's only one flag I'm parsing)
14:27:48 <geekosaur> in some sense it's supposed to, because the recommended way is to use parsec. (which is to my mind not really a good answer for soemthing so commonly needed)
14:27:53 <athan> (which returns [String])
14:28:19 <geekosaur> but why would something that is basically a version of read that returns a Maybe instead of throwing an exception be wrong?
14:28:40 <athan> geekosaur: Hahaha, I'm just kidding! I don't want the extra dependency, either :s
14:28:51 <geekosaur> it's in base
14:28:52 <EvanR> isnt that in base
14:29:21 <geekosaur> base-4.6.0.1/Text-Read.html
14:29:30 <geekosaur> suppose you might have too old a ghc...
14:29:38 <geekosaur> (I think that's lambdabot's problem)
14:31:04 <athan> geekosaur: Oh woah... wow. Okay, well... shoot
14:31:16 <athan> thank you
14:31:32 <geekosaur> actually if you have an older ghc, I think its somewhere in the GHC hierarchy
14:31:50 <danilo2> Hello! I would love to ask you how exactly tinplates / uniplates are implemented in Lenses - are they created fully with some overloaded typeclasses or is there other magic behind them? If they are fully created with overloaded typeclasses, why they introduce any performance slowdown and if they are not, why?
14:32:19 <christmasdotcode> does anybody know where I can find the maintainer of system-filepath?
14:32:24 <christmasdotcode> John Millikin, or FPComplete in general?
14:32:39 <christmasdotcode> I'll email him, of course, but it's easier if he's already here.
14:33:44 <geekosaur> looks like michael snoyman uploaded the last version, but I don't think he's usually on irc
14:33:51 * hackagebot leveldb-haskell-fork 0.3.4.2 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-fork-0.3.4.2 (ifesdjeen)
14:34:05 <vrooom> to use memoization in haskell do i need the io monad?
14:34:13 <vrooom> i need some state between calls
14:35:13 <geekosaur> it depends. for some things there are tricks involving top level CAFs and sharing, like the infamous fibonacci implementation
14:35:14 <sipa> vrooom: a single variable memorize
14:35:26 <sipa> a function application won't
14:35:56 <sipa> let x = bla bla in ... x ... x, will only evaluate bla bla once
14:36:01 <vrooom> yes im doing fib with memoization and realized i cant just have a functyion
14:37:35 <kadoban> vrooom: In case you're doing that for some reason other than to learn memoization: there's better/faster ways to calculate fibs.
14:37:52 <vrooom> yes but i wanted to learn memo
14:38:41 <sipa> vrooom: one trick is putting all values in a list
14:38:51 * hackagebot hoopl 3.10.0.2 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.10.0.2 (HerbertValerioRiedel)
14:38:53 * hackagebot leveldb-haskell-fork 0.3.4.3 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-fork-0.3.4.3 (ifesdjeen)
14:38:57 <sipa> which forces a single variable for each result
14:39:06 <kadoban> Then depending on if you want to learn generalized or not, yeah there's cute tricks for memoizing fib. Remember that you only need the previous 2 values
14:39:58 <meoblast001> i think i forgot some syntax.. i have two existing types i created with newtype, FilePath and ImageData. now i'm trying to create a sumtype out of them: data Texture = FilePath | ImageData
14:40:17 <meoblast001> i'm getting an error that FilePath and ImageData already exist, understandably, but i can't recall the syntax which would allow me to do this
14:40:22 <sipa> > let fiblist = [1, 1] + [(fiblist !! i) + (fiblist !! (i + 1)) | i in [0..]] in fiblist
14:40:24 <lambdabot>  <hint>:1:67: parse error on input ‘in’
14:40:36 <sipa> > let fiblist = [1, 1] + [(fiblist !! i) + (fiblist !! (i + 1)) | i <- [0..]] in fiblist
14:40:37 <lambdabot>  No instance for (GHC.Show.Show t0)
14:40:37 <lambdabot>    arising from a use of ‘M108164289222150750632495.show_M1081642892221507506...
14:40:37 <lambdabot>  The type variable ‘t0’ is ambiguous
14:40:49 <sipa> > let fiblist = [1, 1] ++ [(fiblist !! i) + (fiblist !! (i + 1)) | i <- [0..]] in fiblist
14:40:49 <EvanR> meoblast001: you need two new constructor names
14:40:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:40:54 <kadoban> meoblast001: You need to give them constructor names that will turn the others into your new type.
14:41:21 <meoblast001> ah okay. thanks
14:41:37 <sipa> @let fiblist = [1, 1] ++ [(fiblist !! i) + (fiblist !! (i + 1)) | i <- [0..]]
14:41:40 <lambdabot>  Defined.
14:41:44 <sipa> > fiblist !! 100
14:41:46 <lambdabot>  573147844013817084101
14:41:50 <sipa> > fiblist !! 1000
14:41:52 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
14:46:40 <dfeuer> Drawing these pictures is hard. Anyone know of some nice GUI software for drawing trees (and maybe other graphs) that works on Linux?
14:47:40 <quchen> dfeuer: What kind of graphs? I've used Gephi in the past to look at large lumps of things, e.g. https://raw.githubusercontent.com/quchen/amoeba/master/doc/network_example.png
14:47:40 <EvanR> dont draw... program! http://projects.haskell.org/diagrams/ ;)
14:47:47 <averell> maybe https://github.com/josteink/wsd-mode if you don't like drawing
14:48:14 <dfeuer> quchen, I'm trying to explain my Sequence <*> implementation, and it desperately needs good diagrams.
14:48:20 <dfeuer> To show what the trees look like.
14:48:20 <vrooom> > take 5 $ replicate 5
14:48:22 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘a0 -> [a0]’
14:48:31 <dfeuer> With nice boxes to group things together and so on.
14:48:47 <quchen> dfeuer: Draw it with pen and paper and take a picture.
14:49:00 <dfeuer> quchen, my handwriting is ... a problem.
14:49:13 <dfeuer> No one else will understand anything.
14:49:54 <quchen> Uhmmm write so carefully slow that it's painful then? :-s How much text is in your diagram?
14:50:26 <dfeuer> quchen, I'm trying. I really am. I also get layout confusing, etc....
14:50:28 <dfeuer> Anyway.
14:50:28 <quchen> I'm just saying that not much can match the accuracy of freeform drawings when it comes to putting concepts to paper
14:50:52 <joseph07> I work at a company that mainly uses java, and I wrote a retry library where retry policies form a monoid as in the retry package on hackage. I'm writing about this on our internal engineering blog. Anyone have resources they'd like to recommend on monoids as a design approach?
14:51:08 <dfeuer> quchen, it's a point.
14:51:43 <quchen> dfeuer: Even if your drawing sucks at explaining the issue, it can still give people an idea what software would be good for a computer image
14:55:48 <Evilsparza> hey do you know how to use ghc 7.8 on OS X? I installed it, and did "sudo activate-hs", it said it's using 7.8.3 now, but when I do ghc --version it still says 7.6.3
14:57:26 <WigglesMcMuffin> Is there a inarray function in prelude I don't know about?
14:57:49 <joseph07> WigglesMcMuffin: like elem?
14:57:51 <Evilsparza> or can you tell me how to completely remove ghc/haskell platform from os x so that I can reinstall a clean version?
14:58:25 <WigglesMcMuffin> joseph07: That's the one, thank you
14:58:31 <WigglesMcMuffin> I just didn't know what it was called
14:58:59 <joseph07> WigglesMcMuffin: woo! Don't forget notElem is a thing too. I think it was over a year before I quit doing (not . elem) everywhere
14:59:32 <WigglesMcMuffin> I wouldn't be surprised if that really all notElem is :D
14:59:46 <WigglesMcMuffin> s/that/that's/
15:00:15 <kwf> @source notElem
15:00:15 <lambdabot> Unknown command, try @list
15:00:20 <kwf> :source notElem
15:00:27 <kwf> @list
15:00:27 <lambdabot> What module?  Try @listmodules for some ideas.
15:00:50 <hughfdjackson> morning all :)
15:00:55 <kwf> @src notElem
15:00:55 <lambdabot> notElem x = all (/= x)
15:01:01 <joseph07> @src elem
15:01:01 <lambdabot> elem x = any (== x)
15:01:05 <joseph07> neat
15:01:28 <kwf> WigglesMcMuffin: So, they're not defined in terms of each other, but they could be...
15:01:47 <WigglesMcMuffin> Those are also incredibly simple definitions
15:01:50 <hughfdjackson> if i were to want to make a game engine, in which each entity might be renderable, collidable, etc, i would intuitively store all renderables in a list of Renderables
15:01:54 <kwf> @src all
15:01:54 <lambdabot> all p = and . map p
15:01:57 <kwf> @src any
15:01:57 <hughfdjackson> and then fold to blip renderables
15:01:57 <lambdabot> any p = or . map p
15:02:06 <kwf> @src and
15:02:07 <lambdabot> and  = foldr (&&) True
15:02:10 <kwf> @src or
15:02:10 <hughfdjackson> and likewise do the necessary operations with the collisions, movements, etc
15:02:10 <lambdabot> or = foldr (||) False
15:02:29 <hughfdjackson> :p i can't do that without existential types, but i keep hearing that they're a terrible idea
15:02:38 <hughfdjackson> for this use case, are they? and if so .. any explanation around as to why?
15:03:07 <EvanR> hughfdjackson: if you have a bunch of objects with different properties for different purposes, perhaps store them as an indexed set of entities, attributes, and values?
15:03:21 <kwf> hughfdjackson: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:03:27 <mitchty> anyone seen this error when trying to update cabal-install on osx? https://gist.github.com/mitchty/6e680533fb5b33778d89 note, that is in a virtual machine (vagrant in this case) and setup is all automated (via ansible installing the haskell platform) and worked fine last week with 1.20.0.3
15:03:38 <EvanR> then they can be collected into sets that make sense for some particular purpose without crippling the other cases
15:04:06 <hughfdjackson> EvanR: ah; that makes sense
15:04:30 <EvanR> in theory ;)
15:05:36 <EvanR> example structure is IxSet
15:05:41 <hughfdjackson> EvanR: so.. a Data.Map of EntityId to Renderable (where Renderable is just a datatype?) + a list of EntityIds
15:06:01 <Zol_> I'm working on writing a MUD-like game and am curious on different ways to handle the change of data. Will creating data record types be a sustainable idea, or are there better data structures in hackage I perhaps am not aware about?
15:06:05 <EvanR> whats Renderable?
15:06:06 <hughfdjackson> fold over the list of EntityIds, and render each associated Renderable if it exists?
15:06:28 <hughfdjackson> EvanR: some datatype that contains .. say, x, y coordinates and an image
15:06:33 <hughfdjackson> not a typeclass
15:06:35 <ClaudiusMaximus> Zol_: maybe look at safe-copy and/or acid-state
15:07:06 <EvanR> to find things that should be renderable, search the index for attribute renderable to get the entities, then search for the relevant properties of those entities
15:07:19 <EvanR> using the entity index
15:07:40 <Zol_> ClaudiusMaximus: Thanks!
15:09:24 <hughfdjackson> EvanR: hrm, i think you might be suggesting something different to what i originally thought
15:09:31 <EvanR> probably
15:09:51 <tempay> Is there a way to have a list of items restricted by typeclass without losing the type information? Like, a mixture of types which meet the definition of a typeclass but have additional information?
15:10:01 <hughfdjackson> :) i'm sure some googling will see me right - thanks for the suggestion!
15:10:41 <tempay> I'm guessing not, but I'm having trouble finding an alternative
15:13:36 <EvanR> hughfdjackson: so if theres 6 total data types for values (number, string, etc), youd have 6 indexes of the forms Map (e,a) v, Map (a,v) e ...
15:14:02 <EvanR> where the type of v is different in each family
15:14:26 <EvanR> tempay: theres Dynamic
15:14:37 <EvanR> though you dont have the typeclass constraint
15:15:28 <tempay> EvanR: Yeah, i'm looking for something safe. Maybe found a solution with multiparameter typeclasses, I'll come back later :)
15:15:29 <EvanR> tempay: you could make the set WhateverClass and Typeable, for what thats worth
15:16:24 <EvanR> but actually, you can get around the existentials and typeclasses by including whatever operations you want to do on *any* of those things with the things
15:16:56 <EvanR> when types dont match up, they can be hidden using partial application of the operations
15:17:42 <tempay> EvanR: I'm not sure what you mean about partial application
15:17:42 <mitchty> ok interesting, on linux i'm still getting 1.20.0.3 after a new install of the ghc platform and cabal update
15:18:11 <spearman> hey guys, quick question: what kind of methods could i use to ensure a datatype is created and stays with some property? eg a type of (Int,Int) where the Ints are always sorted <?
15:18:40 <EvanR> tempay: imagine that you have a hetero list of things where for a given thing e you want to do some e -> String -> IO ()
15:18:54 <chrisdone> spearman: make a newtype wrapper with a smart constructor?
15:19:01 <EvanR> tempay: so to satisfy the requirement, make a list of [String -> IO ()] instead
15:19:08 <geekosaur> mitchty, if you don't have $HOME/.cabal/bin at the front of $PATH, add it. if you do, "hash -r"
15:19:28 <tempay> EvanR: right, the problem is that some types may offer more operations
15:19:31 <EvanR> tempay: by applying that e -> String -> IO () earlier, to the possibly differently type es
15:19:37 <spearman> chrisdone: thanks, i had not heard of smart constructors
15:19:45 <tempay> EvanR: I actually think what I'm trying to do might not be well defined
15:19:58 <EvanR> tempay: well, if some of the things dont have the operation at all, what do you want to happen?
15:19:58 <tempay> EvenR: I see what you're saying though, that's an interesting approach
15:20:26 <tempay> EvanR: They'd all have the operation, but some of them would have additional operations
15:20:36 <tempay> EvanR: pretty sure that's just unsafe
15:20:39 * EvanR repeats the question
15:20:48 <mitchty> geekosaur will do, was doing that with my sandboxes, but will add it here and retry, its all a stupid virtual machine so easy enough, but odd that it worked before
15:20:50 <EvanR> about the things without the additional operations
15:20:52 <mitchty> https://github.com/mitchty/bootstrap/blob/master/cabal.yml#L37
15:20:53 <mitchty> err that
15:21:18 <tempay> EvanR: I would pattern match on them later
15:21:39 <tempay> EvanR: I wanted to pattern match without them being of the same type, basically, which is cheating
15:21:50 <EvanR> right, which you wouldnt have to do if you had it split up earlier
15:22:07 <tempay> EvanR: yep
15:22:14 <tempay> EvanR: I think I just need to restructure a bit
15:22:18 <tempay> EvanR: thanks again
15:24:25 <EvanR> [Either GimpyType BeefyType]
15:24:32 <EvanR> eg
15:32:49 <Zol_> If I have two .hs files, should I make a third file with a new module where I put my data types that I want to be accessible from the two first .hs files, and import the module in those?
15:34:54 <EvanR> Zol_: as opposed to what, putting the datatype (and its operations) in one of the two original files?
15:34:54 <chrisdone> yeah
15:34:59 <monochrom> not necessary. sometimes convenient. sometimes not. do what is convenient.
15:35:10 <chrisdone> Project.Types is common
15:35:14 <monochrom> go with your heart
15:35:28 <Zol_> monochrom: chrisdone: Thanks!
15:35:29 <chrisdone> Billy, what does your heart tell you?
15:35:40 <benzrf> ok wtf is going on here
15:35:40 <EvanR> hsboot ftw
15:35:42 <monochrom> sometimes people do that just to avoid circular dependencies between modules. that is all.
15:35:43 <benzrf> liftAM :: (forall t. f t a -> g t b) -> AnyMoment f a -> AnyMoment g b
15:35:43 <benzrf> liftAM f am = anyMoment (f <$> now am)
15:36:03 <Zol_> EvanR: I guess I was just feeling a bit insecure and needed some confirmation that my idea wasn't as bad as I (perhaps illogically) thought.
15:36:11 <benzrf> ^this is apparently taking up 27.9% of my program's running time and 41.4% of allocation
15:36:14 <benzrf> /noninherited/
15:36:17 <EvanR> you cant go wrong making the third file
15:36:31 <chrisdone> benzrf: is that an FRP thing?
15:36:34 <benzrf> chrisdone: yep
15:36:40 * chrisdone nods 
15:36:51 <benzrf> oh boy
15:36:55 <benzrf> what have i done this time ;-;
15:37:29 <Zol_> EvanR: Thanks
15:38:16 <chrisdone> You are using an experimental abstraction with unstable technology, are you sure you want to proceed (y/n)?
15:38:29 <benzrf> i just dont understand
15:38:36 <benzrf> now is a newtype accessor
15:38:41 <benzrf> and anyMoment puts it back
15:39:02 <benzrf> oh wait.
15:39:23 <joseph07> benzrf: quack
15:39:46 <benzrf> there are 12502500 entries for one of the functions
15:39:48 <benzrf> that cannot be good
15:40:06 <benzrf> b-but
15:40:14 <benzrf> 0 entries for liftAM?
15:40:23 <benzrf> what the heck?
15:40:55 <mitchty> geekosaur well i'll be, it worked, thanks geekosaur, also yay for automation, not sure how it worked before though to be honest
15:44:33 <EvanR> benzrf: what library is that
15:46:56 <benzrf> reactive banana
15:56:59 <fresheyeball> hey out there
16:03:52 * hackagebot monad-journal 0.6 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.6 (DimitriSabadie)
16:04:00 <fresheyeball> hey folks
16:04:10 <fresheyeball> I am still struggling with a ghci problem
16:04:22 <fresheyeball> import Network.Wai.Application.Static (staticApp, defaultFileServerSettings)
16:04:36 <fresheyeball> this line fails in ghci saying module not found
16:04:41 <fresheyeball> but cabal build works fine
16:05:00 <fresheyeball> I'm finding it really difficult to code without ghci
16:05:26 <RchrdB> fresheyeball: are you invoking ghci just as "ghci" or are you running "cabal repl"?
16:05:32 <geekosaur> sandbox? use cabal repl
16:05:32 <fresheyeball> ghci
16:05:38 <fresheyeball> in a sandbox
16:05:40 <RchrdB> fresheyeball: you want cabal repl.
16:06:20 <fresheyeball> that worked!
16:06:24 <fresheyeball> holy craps!
16:06:25 <RchrdB> Yay! :)
16:06:33 <fresheyeball> its been days I've been dealing with this
16:06:38 <RchrdB> "cabal repl" invokes ghci with the contents of the current sandbox visible.
16:06:48 <RchrdB> Yeah, snagging issues are often like that. :/
16:06:51 <tommd> cabal exec ghci
16:06:56 <mmmm> You can also do "cabal exec bash" and then "ghci ...." (or any other command and your packages will be in scope"
16:08:19 <fresheyeball> ok so how about ghc-mod
16:08:29 <fresheyeball> my text editor is showing the same error I got in ghci
16:08:42 <iElectric> ocharles_: any suggestions what to use as restful client?
16:08:52 * hackagebot hs-pkg-config 0.2.0.0 - Create pkg-config configuration files  http://hackage.haskell.org/package/hs-pkg-config-0.2.0.0 (PeterTrsko)
16:09:00 <ocharles_> iElectric: you mean doing HTTP requests with JSON?
16:09:06 <ocharles_> iElectric: Perhaps `wreq`
16:09:15 <jfischoff> why does network use unsafe ffi calls, even when threaded for send and recv?
16:09:56 <iElectric> ocharles_: cool, tnx
16:09:56 <jfischoff> unlike ghc’s implementations of read/write on fds?
16:09:59 <johnw> jfischoff: are you saying that it makes an unsafe call to "send"?
16:10:11 <jfischoff> unsafe ffi call yes
16:10:16 <johnw> perhaps the C code uses its own thread to do the sending?
16:10:57 <jfischoff> unsafe ffi and uninterruptable
16:11:06 <jfischoff> so it can hurt concurrency
16:11:36 <jfischoff> I’m wondering if it just has not been benchmarked?
16:12:00 <jfischoff> it would simple enough to test
16:16:05 <RchrdB> jfischoff: oh! I think they're not blocking.
16:16:17 <jfischoff> yes that is true
16:16:30 <jfischoff> but same with the file IO
16:17:04 <dedgrant> @pl \o x y p -> o x >>= \x' -> o y >>= \y' -> p x' y'
16:17:04 <lambdabot> liftM2 flip (((.) . (.) . (>>=)) .) (((.) . (>>=)) .)
16:17:13 <dedgrant> ouch
16:17:18 <johnw> oh yeah, so much clearer!
16:17:23 <RchrdB> send(2) and recv(2) on non-blocking sockets won't ever block; just return the number of bytes enqueued, and the socket creation functions always set the non-blocking flag on your sockets.
16:17:47 <jfischoff> non-blocking just means if I ask the socket for more bytes than it has, it will return will block, and then event manager will put the thread to sleep and wake it up when the fd is ready
16:18:18 <johnw> "send() normally blocks, unless the socket has been placed in non-blocking I/O mode"
16:18:20 <johnw> from the send man page
16:18:26 <jfischoff> sure
16:18:39 <jfischoff> but network sets those flags if you are not on windows
16:19:05 <jfischoff> I understanding what non-blocking IO means, safe/unsafe affects the scheduler
16:19:19 <jfischoff> brb
16:22:41 <RchrdB> Handing that off to another thread will not be quicker than doing it in-thread. In the case where they don't have to block, send() and recv() are pretty much "jump into the kernel, memcpy(), return to userland".
16:23:51 <fresheyeball> ok so what is cabal repl?
16:24:21 <RchrdB> In the case where they do return EWOULDBLOCK/EAGAIN, it wraps the send/recv calls with Network.Socket.Internal.throwSocketErrorWaitWrite, which uses the I/O manager to pause the thread until the socket becomes writeable (or throwSocketErrorWaitRead for recv).
16:26:03 <RchrdB> fresheyeball: "cabal repl" runs ghci with your cabal sandbox's packages loaded.
16:26:21 <fresheyeball> is there a way to get the same results with ghci command?
16:26:32 <fresheyeball> I'm trying to get sublime-haskell running again
16:26:37 <RchrdB> someone posted it earlier, uh
16:26:54 <RchrdB> "cabal exec bash", and then you can run "ghci" in that shell
16:30:48 <johnw> how about cabal exec ghci then?
16:31:45 <RchrdB> johnw: tommd mentioned that first. :)
16:31:57 <johnw> aha
16:32:51 <tommd> yay for being first.  I didn't write it and I didn't think it up but I mentioned it at the correct time :-)
16:38:10 <iElectric> ocharles_: one last thing, is there a development server for scotty?
16:38:26 <ocharles_> iElectric: that I'm not sure about, but I think perhaps no..
16:39:23 <ocharles_> iElectric: there is #scotty though
16:40:22 <RchrdB> iElectric: as in one that restarts automatically when you hit 'save' in your editor like "paster serve --reload" does?
16:41:03 <iElectric> yeah
16:41:26 <RchrdB> I don't know if there is, but you could hack that up with inotifywait.
16:46:42 <mmmm> iElectric: Look up "reserve"
16:47:49 <jfischoff> I’m looking a profile for a server, stop the world GC is takes up 80ms of 200ms response, crazy
16:50:46 <iElectric> mmmm: tnx
16:54:21 <dmnd> Apologies for the non-haskell-specific question, but is there a reasonably "standard" but terse argument name for the accumulator in a reduce/fold function? By "standard", I mean something like i for an index or x for an element
16:54:58 <mmmm> go is quite common
16:55:09 <glguy> I use "go" for my helper function and "acc" for the accumulator variable
16:55:36 <dmnd> sorry, I meant the accumulator variable, not the function
16:56:05 <mmmm> iElectric: https://github.com/sol/reserve
16:56:11 <Dashkal> I use acc for the accumulator and a for the value.
16:57:21 <dmnd> cool, thanks all
16:57:56 <banjiewen> Is there any information available about the status of the ghc-lwc2 work? Is that still an active project?
16:58:52 * hackagebot bdd 0.1.0.0 - Behavior-Driven Development DSL  http://hackage.haskell.org/package/bdd-0.1.0.0 (irekjozwiak)
17:01:22 <erikd> banjiewen: i'd not heard of that before, but the last commit to the ghc-lwc2 branch was september last year
17:07:34 <banjiewen> Yeah, that's why I asked :D
17:07:49 <banjiewen> The paper behind it was interesting: http://community.haskell.org/~simonmar/papers/conc-substrate.pdf
17:13:12 <marchelzo_> @pl \e -> findWithDefault e e m
17:13:12 <lambdabot> flip (join findWithDefault) m
17:15:05 <marchelzo_> It would be neat if Data.Map had a function like "Ord k => (k -> a) -> k -> Map k a -> a"
17:16:21 <zq> marchelzo_: what would that do?
17:16:29 <zq> marchelzo_: and why the ord constaint?
17:17:12 <glguy> :t \f k -> findWithDefault (f k) k
17:17:13 <lambdabot>     Not in scope: ‘findWithDefault’
17:17:13 <lambdabot>     Perhaps you meant one of these:
17:17:13 <lambdabot>       ‘IM.findWithDefault’ (imported from Data.IntMap),
17:17:17 <marchelzo_> It would be like findWithDefault but instead of giving a default value, you give a default way to get a value
17:17:19 <glguy> :t \f k -> M.findWithDefault (f k) k
17:17:20 <lambdabot> Ord k => (k -> a) -> k -> M.Map k a -> a
17:17:39 <glguy> there you go
17:18:39 <marchelzo_> It would allow "flip (join findWithDefault) m" to be written "flip (newFunction id) m"
17:19:23 <glguy> better to just write it out than to have to memorize a new name
17:19:52 <marchelzo_> I guess, but I think it could replace findWithDefault.
17:19:59 <zq> :t findWithDefault
17:20:00 <lambdabot>     Not in scope: ‘findWithDefault’
17:20:00 <lambdabot>     Perhaps you meant one of these:
17:20:00 <lambdabot>       ‘IM.findWithDefault’ (imported from Data.IntMap),
17:20:06 <zq> :t M.findWithDefault
17:20:07 <lambdabot> Ord k => a -> k -> M.Map k a -> a
17:20:20 <zq> i swear there's a function like that
17:20:26 <zq> :t M.findWithDefaultBy
17:20:27 <lambdabot>     Not in scope: ‘M.findWithDefaultBy’
17:20:27 <lambdabot>     Perhaps you meant one of these:
17:20:27 <lambdabot>       ‘M.findWithDefault’ (imported from Data.Map),
17:20:58 <glguy> Hoogle, GHCi and /msg are better for searching for functions
17:21:02 <zq> :t M.lookupDefault
17:21:03 <lambdabot> Not in scope: ‘M.lookupDefault’
17:21:22 <zq> it's friday, spamming is allowed
17:21:31 <zq> in particular on-topic spam
17:21:42 <glguy> Sorry, we ended that policy on Thursday
17:22:20 <zq> never mind, i was thinking about:
17:22:38 <zq> :t M.insertWith
17:22:39 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:22:45 <marchelzo_> ah
17:23:41 <marchelzo_> Also useful would be "a -> Map a a -> a" or the flipped version. Not really generic enough to be in Data.Map though I suppose.
17:23:55 <marchelzo_> Also most of these are easy enough to write as glguy pointed out.
17:46:01 <ReinH> marchelzo_: what would that function do?
17:46:22 <ReinH> I assume you don't want `const'.
17:48:17 <marchelzo_> ReinH, If the map contained the argument as a key, it would return the corresponding value, else it just returns the argument.
18:11:20 <benzrf> so uh
18:11:57 <benzrf> is trying to design a system based around the idea of adding and removing newly-created events to and from an existing, running network fundamentally flawed.
18:16:13 <benzrf> [frp]
18:36:21 <ParahSailin> is anyone working on making TExp a -> IO a a bit less ugly than this? https://github.com/mainland/th-new/blob/master/Language/Haskell/TH/Compile.hs
18:37:08 <ReinH> marchelzo_: liftA2 (.) fromMaybe lookup :)
18:38:02 <ReinH> :t let (<.>) = liftA2 (.) in fromMaybe <.> lookup
18:38:03 <lambdabot> Eq a => a -> [(a, a)] -> a
18:39:07 <heatsink> A, 2, and D
18:40:35 <marchelzo_> :t liftA2 (.) fromMaybe M.lookup
18:40:36 <lambdabot> Ord c => c -> M.Map c c -> c
18:42:41 <marchelzo_> I'm still not too comfortable with the applicative instance for ((->) e)
18:47:50 <chron_> Is there an easy way of applying different functions to different elements of a list? i.e. I want to have test [1,2,3,4,5 [f,g,h,i]
18:48:53 * hackagebot hydrogen-prelude 0.9 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.9 (JulianFleischer)
18:49:04 <HeladoDeBrownie> chron_, not sure if you mean this, but perhaps zipWith ($)
18:49:07 <HeladoDeBrownie> @type zipWith ($)
18:49:08 <lambdabot> [b -> c] -> [b] -> [c]
18:49:22 <HeladoDeBrownie> Or to put it in the same order you did you'd just flip it.
18:49:25 <HeladoDeBrownie> @type flip zipWith ($)
18:49:26 <lambdabot>     Couldn't match expected type ‘[a]’
18:49:26 <lambdabot>                 with actual type ‘(a0 -> b0) -> a0 -> b0’
18:49:26 <lambdabot>     Probable cause: ‘($)’ is applied to too few arguments
18:49:28 <HeladoDeBrownie> Er
18:49:34 <HeladoDeBrownie> @type flip (zipWith ($))
18:49:35 <lambdabot> [b] -> [b -> c] -> [c]
18:50:09 <ReinH> marchelzo_: \k m -> fromMaybe k (lookup k m) = \k m -> (fromMaybe k . lookup k) m = \k -> fromMaybe k . lookup k = \k -> (.) (fromMaybe k) (lookup k) = \k -> liftA2 (.) fromMaybe lookup k = liftA2 (.) fromMaybe Lookup
18:50:48 <ReinH> marchelzo_: since \x -> f (g x) (h x) = liftA2 f g h
18:51:50 <ReinH> marchelzo_: you can think of the Applicative instance for ((->) e) as threading an e value through the computation.
18:52:10 <glguy> marchelzo_: It's OK if it seems confusing. It's not something you should see much outside of lambdabot commands
18:52:22 <ReinH> glguy: I dunno, I use it quite a bit
18:53:18 <glguy> Wouldn't fly at work
18:53:34 <marchelzo_> ReinH, that little "derivation" there was pretty helpful :) I can follow it, but it's not something I'd come up with naturally in my code.
18:54:18 <ReinH> glguy: This is not the best example
18:57:05 <rtf2> if i have a list and a list of functions, is there a simple(ish) way of applying each function to its corresponding element? i.e. [1,2,3] and [f,g,h] would give [f 1, g 2, h 3].
18:57:17 <HeladoDeBrownie> @type zipWith ($)
18:57:18 <lambdabot> [b -> c] -> [b] -> [c]
18:57:19 <HeladoDeBrownie> rtf2, that
18:59:06 <rtf2> ahhh ty
19:02:00 <chrisdone> what are the odds of that? =)
19:02:10 <chrisdone> <chron_> Is there an easy way of applying different functions to different elements of a list? i.e. I want to have test [1,2,3,4,5 [f,g,h,i]
19:02:11 <chrisdone> <rtf2> if i have a list and a list of functions, is there a simple(ish) way of applying each function to its corresponding element? i.e. [1,2,3] and [f,g,h] would give [f 1, g 2, h 3].
19:02:16 * chrisdone 's homework alarm is going off
19:02:27 <HeladoDeBrownie> Yeah, I thought the original asker hadn't noticed my answer and was asking again XD
19:03:00 <HeladoDeBrownie> Oh, and it turns out they didn't hear me anyway because they left -_-
19:03:25 <chrisdone> ah, probably the same person
19:03:55 <HeladoDeBrownie> Same IP, looks like you're right
19:04:55 <dfeuer> carter, I sent you something.
19:05:21 <dfeuer> Luke is a nice name.
19:05:43 <Luke> dfeuer: yeah i like it
19:05:54 <chrisdone> a life-time of Darth Vader dad jokes
19:06:02 <dfeuer> That is a downside.
19:08:38 <carter> dfeuer:  reading now
19:08:44 <dfeuer> OK.
19:15:39 <t4nk247> So I have a list of lists and I want to apply one function to the first element of every list, then another function to the second element of every list, then.... and so on.
19:15:46 <t4nk247> Is there an easy way of doing this?
19:16:02 <dfeuer> Hmm... New nick; same homework assignment.
19:17:11 <fresheyeball> has anyone in here seen this error:
19:17:17 <fresheyeball> ghc: --interactive can't be used with -prof or -unreg.
19:17:20 <benzrf> t4nk247: interesting
19:17:31 <benzrf> :t transpose
19:17:32 <lambdabot> [[a]] -> [[a]]
19:17:48 <dfeuer> Benzrf, I think there's a better way.
19:17:54 <HeladoDeBrownie> t4nk247, I don't know if this is on purpose, but it seems kind of sketchy that you keep leaving and then returning with a new nick :P Anyway, *is* this homework? Because if so, it's probably best if you understand how to get the answer given what you know rather than just having someone tell you (like I did before).
19:17:56 <benzrf> oh?
19:18:08 <benzrf> :t \fs -> zipWith map fs . transpose
19:18:09 <lambdabot> [a -> b] -> [[a]] -> [[b]]
19:18:15 <HeladoDeBrownie> t4nk247, in other words we'll still help, but we'll take a slightly different approach
19:18:29 <dfeuer> benzrf, I don't think you need any transpose.
19:18:34 <dfeuer> Just reorder things some.
19:18:41 <benzrf> dfeuer: explain
19:19:35 <dfeuer> Explained in PM.
19:20:21 <HeladoDeBrownie> Well, they'll probably be back.
19:20:41 <cyberace> Hello I am looking for a linux security pro to groom me in the way of the hacker as I am trying the gain the hands on skills to take me to the next level in my career. Any takers please IM me
19:20:57 <johnw> cyberace: that is not appropriate in this channel
19:21:06 <HeladoDeBrownie> cyberace, that may not even be appropriate for the Freenode network
19:22:07 <cyberace> please explain
19:22:16 <johnw> we're here to talk about Haskell
19:22:27 <johnw> not for people to solicit anything they want just because there is a large number of people here
19:22:37 <cyberace> sorry
19:22:42 <cyberace> what is haskell?
19:22:52 <johnw> it's a general purpose, functional language
19:22:52 <HeladoDeBrownie> cyberace, cracking is off-topic on Freenode, according to the policy. https://freenode.net/policy.shtml#offtopic
19:22:53 <Chathurga> ...!
19:23:19 <cyberace> its certainly not illegal
19:23:23 <dfeuer> Non-Haskell-specific functional programming, category theory, programming language semantics, etc., questions may or may not be on topic.
19:23:30 <benzrf> cyberace: i suspect you may be trolling
19:23:41 <HeladoDeBrownie> cyberace, I didn't say it was. However, it is off-topic on this network.
19:23:51 <cyberace> @benzrf come on man
19:23:51 <lambdabot> Unknown command, try @list
19:24:03 <johnw> benzrf: we don't need to be antagonistic
19:24:16 <johnw> he might really want to learn about Haskell once he learns what it is
19:24:29 <cyberace> @johnw thank you
19:24:29 <lambdabot> Not enough privileges
19:24:43 <dfeuer> @quote johnw
19:24:44 <lambdabot> johnw says: lens makes one into a mutating ninja
19:24:54 <heatsink> You need more privileges to johnw
19:24:57 <HeladoDeBrownie> lambdabot doesn't think you have enough privileges to thank johnw.
19:24:58 <Cale> cyberace: Haskell is a functional programming language with a lot of really cool features.
19:25:02 <johnw> hahah
19:25:09 <johnw> there we go, I was hoping Cale would appear
19:25:19 <dfeuer> Cale is a teacher of extraordinary skill.
19:25:29 <cyberace> hmmmm
19:25:45 <cyberace> I know some python and some java
19:25:52 <dfeuer> Cale, take a look at this amazing thing: https://github.com/haskell/containers/pull/104/files
19:25:56 <cyberace> but not enough to consider myself aprogramme rby any means
19:26:36 <fresheyeball> I need help http://stackoverflow.com/questions/27576627/haskell-leksah-and-ghci
19:26:46 <zRecursive> first reporting bug: https://ghc.haskell.org/trac/ghc/ticket/9905
19:26:47 <Cale> cyberace: It's especially characterised by its relatively powerful static type system which helps catch many bugs at compile time, and lazy evaluation (or really, nonstrict semantics for the pedantic) which lets you work with infinite or very large datastructures that are computed as needed.
19:26:50 <HeladoDeBrownie> cyberace, knowledge of Python and Java may either help or hinder you learning Haskell. It's qualitatively different from those languages.
19:27:53 <gratimax> welllll
19:27:59 <dfeuer> HeladoDeBrownie, Java has a type system, and Java Generics and interfaces aren't too horribly distant in general flavor from some things Haskell does.
19:28:02 <zq> the sun is either visible or invisible
19:28:11 <gratimax> I would say learning classes hinders most people from understanding haskell
19:28:15 <zq> chewing gum may either help or hinder you in learning haskell
19:28:17 <gratimax> python has some great functional programming features
19:28:44 <Cale> zq: What is this? Attempting to get stuff onto monochrom's list of tautologies?
19:28:49 <HeladoDeBrownie> zq, my point was that it will not definitely help to know those languages already, unlike what some people may think.
19:29:02 <dfeuer> I know almost no Python, but I noticed that it has fallen prey to the "Let's make lots of syntax! It'll be convenient!" fad.
19:29:13 <Cale> oh, I see, it was a response to HeladoDeBrownie :)
19:29:14 <Hermit> just like lenses....
19:29:28 <johnw> when syntax comes from libraries, I'm all for it
19:29:30 <Cale> Well, it'll *both* help and hinder you.
19:29:31 <gratimax> lol python does not have that much syntax compared to some languages...
19:30:08 <dfeuer> Haskell has a lot of syntax, and somewhat overly complicated syntax, but with rare exceptions, there's a good reason for it, and it's well thought out.
19:30:16 <Cale> Knowing how to program in a traditional imperative language might get in your way a bunch at first, because you'll expect things to work one way and Haskell is different.
19:30:18 <johnw> Haskell actually has relatively little syntax
19:30:25 <Cale> However, a lot of knowledge really does translate.
19:30:26 <zq> Cale: ever so perceptive, teacher of extraordinary skill
19:30:31 <HeladoDeBrownie> dfeuer, I feel like saying both "Java has a type system" and "Haskell has a type system" is making a misleading comparison.
19:30:52 <gratimax> subtyping is the difference, that's why I think people dislike Haskell's type system
19:30:52 <johnw> things like "$" in Haskell aren't syntax at all
19:31:07 <gratimax> johnw: they're syntax hidden behind functions
19:31:13 <johnw> yep, syntax from libraries
19:31:16 <johnw> the best kind
19:31:29 <dfeuer> johnw, and the fact that $, in particular, is not syntax turns out to be problematic.
19:31:31 <Cale> So once you get over the initial portion of just learning language basics, you'll be in a better position to start translating everything you knew about imperative and/or object oriented programming.
19:32:01 <dfeuer> $ actually *should* be syntax. Since it's not, GHC's type checker has a very special case *just for $*
19:32:04 <johnw> I came from the world of C++, where syntax gets added to the core language constantly in an attempt to keep up with the development of new abstractions in programming
19:32:18 <HeladoDeBrownie> dfeuer, what are you referring to?
19:32:29 <heatsink> runST $ do ...
19:32:48 <dfeuer> HeladoDeBrownie, what heatsink said.
19:32:51 <johnw> anyway, not only does Haskell have very little syntax, but most of the syntax that it does have is opt-in
19:32:56 <HeladoDeBrownie> dfeuer, how is that special?
19:33:00 <dfeuer> It's actually an undocumented special case.
19:33:00 <Cale> dfeuer: I disagree, and think that special case should just be removed.
19:33:09 <dfeuer> Cale, that will break a *lot* of code.
19:33:14 <Cale> ehhhhh
19:33:18 <Cale> Not really that much code
19:33:26 <Cale> It's really just occurrences of runST for the most part
19:33:31 <dfeuer> I suppose.
19:33:35 <Cale> and ST doesn't get used *that* much
19:33:41 <dfeuer> I suppose not.
19:33:57 <heatsink> HeladoDeBrownie: runST takes a polymorphic argument of type (forall s. ST s a), however, the type of ($) can't be instantiated to take a polymorphic argument under the normal inference rules
19:34:00 <dfeuer> If you propose that, I'll +1. I don't use ST ;-P
19:34:25 <Cale> Well, I don't really mind the special case so long as it's no pain for the maintainers
19:34:39 <Cale> But the instant it becomes annoying to maintain, I'd support removing it.
19:35:06 <HeladoDeBrownie> heatsink, ah, I see. Thanks for explaining.
19:35:17 <dfeuer> There was an attempt to add "impredicative polymorphism" to the type system using an inference method called "boxy types", but it turned out that system was too complicated and fragile for anyone to understand or work with. So they took it out, and left behind just one special case.
19:35:28 <Cale> Yeah, pretty much
19:35:39 <marchdown> why can't use . in do blocks? What should I use instead? ex: https://gist.github.com/marchdown/7c4b38b6409d89e95c5c
19:35:48 <Cale> I actually kind of started to understand it, but the error messages were really confusing at first.
19:36:06 <HeladoDeBrownie> marchdown, you can use it, however getContents is not a function. Perhaps you want read . lines <$> getContents
19:36:13 <HeladoDeBrownie> (<$>) is just infix fmap.
19:36:19 <HeladoDeBrownie> @type read . lines <$> getContents
19:36:20 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Char’
19:36:21 <lambdabot>     Expected type: String -> String
19:36:21 <lambdabot>       Actual type: String -> [String]
19:36:23 <HeladoDeBrownie> Oops.
19:36:31 <Cale> marchdown: That's really super cute that you had this issue. If (.) were fmap like I suggested a long long time ago, then your code would work.
19:36:37 <dfeuer> Cale, I think the whole boxy types thing must've happened between the time when I first really tried learning Haskell and my present run of Haskell playing.
19:36:38 <HeladoDeBrownie> Oh, that wouldn't have worked quite that way anyway.
19:36:45 <Cale> marchdown: But what you want is  fmap (read . lines) getContents
19:37:21 <HeladoDeBrownie> marchdown, Cale, actually I think that wouldn't typecheck, see above. marchdown, what was your intent with that line?
19:37:35 <dfeuer> marchdown, why are you doing "getLine" and not using the result?
19:37:40 <marchdown> HeladoDeBrownie, Cale, thank you.
19:37:56 <Cale> :t fmap (read . lines) getContents
19:37:57 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Char’
19:37:57 <lambdabot>     Expected type: String -> String
19:37:57 <lambdabot>       Actual type: String -> [String]
19:38:00 <Cale> oh, derp
19:38:03 <Cale> :t fmap (map read . lines) getContents
19:38:04 <lambdabot> Read b => IO [b]
19:38:06 <Cale> yes
19:38:22 <HeladoDeBrownie> marchdown, is what Cale just said what you were after? (Try and see if necessary.)
19:38:23 <Cale> read does not take a list of strings, it just wants one string :P
19:38:31 <dfeuer> Cale, when did you propose (.)=fmap?
19:38:46 <Cale> dfeuer: uhhh, like back in... 2006 ish?
19:39:01 <dfeuer> That would've been much too late, no?
19:39:02 <marchdown> dfeuer: it's an online judge problem, first line says how many more are there, but I don't need this information, so I just discard it. Would you suggest doing it differently?
19:39:05 <Cale> dfeuer: yep
19:39:16 <cyberace> im all for learning new languages
19:39:16 <Cale> dfeuer: But it's mostly compatible
19:39:22 <cyberace> I am currently a QA analyst
19:39:27 <Cale> dfeuer: So we could have been aggressive about it
19:39:38 <cyberace> And programming is a must if i wish to stay on top of my game
19:39:43 <Cale> dfeuer: It was always a little bit of a "modest proposal" of sorts
19:39:50 <Cale> dfeuer: But I actually kind of liked it.
19:40:00 <cyberace> So if you guys are lending a helping hand id love to be a part of the community
19:40:19 <dfeuer> cyberace, we're very open to new people if they're willing to learn.
19:40:37 <dfeuer> Especially if they're also willing to make their efforts useful to others.
19:41:15 <dfeuer> Cale, is (.) fmap in the reader monad or something?
19:41:46 <Cale> dfeuer: Yeah
19:41:53 <cyberace> hatsoff to HeladoDeBrownie @ Cale
19:42:28 <Cale> dfeuer: and the law that  fmap (f . g) x = fmap f (fmap g x)  becomes  (f . g) . x = f . (g . x)  when written with (.) = fmap :)
19:42:46 <cyberace> So
19:42:52 <cyberace> Where to from here
19:43:00 <johnw> cyberace: check out LYAH
19:43:02 <johnw> @where lyah
19:43:02 <lambdabot> http://www.learnyouahaskell.com/
19:43:14 <johnw> see if the first few chapters interest you
19:43:41 <Cale> cyberace: Also some people seem to swear by this course http://www.seas.upenn.edu/~cis194/
19:43:53 <Cale> (there are lectures and assignments linked from there)
19:44:18 <dfeuer> And other swear by
19:44:21 <dfeuer> @where rwh
19:44:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:44:33 <johnw> i don't like RWH at all for brand new people
19:44:35 <dfeuer> But I'd go with Learn You A Haskell to start.
19:44:41 <benzrf> no guys
19:44:43 <benzrf> the correct answer ius
19:44:46 <benzrf> @where to-start
19:44:46 <dfeuer> ONLY GIRLS
19:44:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:45:00 <dfeuer> benzrf, why is that "the correct answer"?
19:45:03 <benzrf> ^^^the 1 true answer^^^
19:45:10 <benzrf> dfeuer: because it links to cis194 :)
19:45:16 <dfeuer> Pfff
20:38:28 <jle`> in that case can we generalize Functor to arbitrary categories too
20:50:04 <fresheyeball> hey
21:04:21 <marcusbuffett> Hey guys, I'm trying to get cabal-install to work on a fresh install of OS X, and it's refusing to update for some reason, I run 'cabal install cabal-install', it finishes without any errors, but then when I run 'cabal update' again, it says there's a new version. I'm assuming this is because I somehow have two versions of cabal-install on my computer, and I can find the location of the one being us
21:04:27 <marcusbuffett> ed with 'which cabal', but I can't figure out how to find the other one, any ideas?
21:04:52 <Welkin> add ~/Library/Haskell/bin to your path
21:06:03 <glguy> My computer gets into a state where cabal install won't replace executables which are already installed and I end up having to manually symlink the binaries it creates into ~/Library/Haskell/bin
21:06:09 <glguy> I don't know if that's what's happening to you, or not
21:08:32 <marcusbuffett> Welkin: I don't have a Haskell folder in my library, could that be my issue?
21:08:38 <jle`> marcusbuffett: use `which cabal`
21:08:42 <jle`> and tell us which one shows up
21:09:24 <marcusbuffett> /usr/local/bin/cabal
21:09:52 <jle`> ah so it's still calling the original binary, instead of the newly installed binary
21:10:24 <marcusbuffett> jle`: Do you know where the newly installed binary is?
21:11:32 <Welkin> how did you install haskell then?
21:11:40 <Welkin> haskell platform? homebrew?
21:12:23 <marcusbuffett> homebrew
21:12:33 <bsmt> something similar to that happens to me, using homebrew as well
21:13:41 <Welkin> homebrew installs in /user/local/Cellar
21:13:43 <Welkin> usr*
21:14:30 <Welkin> add you could add that to the beginning of your PATH
21:15:26 <marcusbuffett> Welkin: Sounds good, I'll try that now
21:15:34 <Welkin> I don't know how homebrew works internally
21:15:45 <Welkin> it might symlink the binaries somehow
21:18:51 <marcusbuffett> Strangely, 'which cabal' still gives me '/usr/local/bin/cabal' after I add /usr/local/Cellar to the beginning of my path
21:21:07 <Welkin> did you add it to your path in your bash profile or did you export it directly in the shell?
21:21:51 <Welkin> if the former, reload your profile with . .bash_profile
21:22:33 <marcusbuffett> Welkin: Oh I just exported it directly in the shell, should I have added it to my .bash_profile instead?
21:23:12 <shachaf> No.
21:23:38 <shachaf> Does an executable file /usr/local/Cellar/cabal exist, and does your PATH start with "/usr/local/Cellar:"?
21:25:11 <marcusbuffett> An executable file /usr/local/Cellar/cabal-install/1.20.0.3_1/bin/cabal exists, my path starts with /usr/local/Cellar
21:25:28 <marcusbuffett> Do I need to specify the exact folder or will it search within the folders?
21:25:38 <shachaf> So the answer is no to both questions?
21:25:46 <marcusbuffett> Yes to second
21:25:46 <shachaf> Yes, you need to specify the full directory.
21:25:48 <marcusbuffett> No to first
21:25:57 <marcusbuffett> Okay, will do
21:26:18 <shachaf> Having / in your PATH won't search your entire disk.
21:28:57 <marcusbuffett> Okay, I added it, confirmed it was pointed to the right cabal with 'which cabal', ran 'cabal install cabal-install', but 'cabal --version' is still showing the old version, and there's no new version in /usr/local/Cellar/cabal-install
21:30:55 <jle`> hm. try clearing your path cache? `hash -r`
21:31:19 <jle`> or `hash -d cabal`
21:34:04 <marcusbuffett> Found the issue, the actual cabal I needed was in .cabal/bin, so I added that to my path and it worked, thanks for all the help guys
21:36:04 <tavoe> Quick question. In an anonymous function, is there a way to use parameter guards?
21:38:53 * hackagebot highlighting-kate 0.5.11.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.11.1 (JohnMacFarlane)
21:39:49 <Welkin> what are parameter guards?
21:46:38 <glguy> tavoe: You can get MultiWayIf or LambdaCase extensions to get multiple cases in an anonymous function, but in normal Haskell you can't use guards in anonymous functions
21:47:40 <Welkin> tavoe: if your anonymous function needs to be that complex, just write a local function in a where or let clause
21:48:13 <Welkin> or even write it as a top-level function
21:57:30 <tavoe> glguy/welkin. Thanks.
21:58:14 <Modius> glguy:  I needed the "selectRandom" in your example from yesterday to give me back the tree with the element subtracted out; but figured out how to change your example after reading up on fingerTree docs.
21:58:39 <glguy> Oh, very cool
22:00:08 <Modius> glguy (of course I never would have figured out the basics of this in the first place without your example).  Dunno if it showcases fingertree to its full extent but it sure made an interesting example to me.
22:03:28 <glguy> There's a paper on them if you're looking for something to read, beyond the neat stuff you can do with various measures with them, their actual implementation is interesting
22:08:54 * hackagebot texmath 0.8.0.1 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.0.1 (JohnMacFarlane)
22:18:54 * hackagebot hack2-contrib-extra 2014.12.20 - Hack2 contrib extra  http://hackage.haskell.org/package/hack2-contrib-extra-2014.12.20 (JinjingWang)
22:33:05 <jakun> lalok
23:03:11 <hunter_> how do you get lambdabot to list available commands?
23:03:17 <hunter_> i tried @list as it suggests in
23:03:24 <hunter_> @help, but that asked me to pick a module
23:03:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:03:33 <hunter_> @list, see?
23:03:33 <lambdabot> No module "see?" loaded
23:31:09 <hunter_> not very active tonight
23:37:00 <ab9rf> that could change
23:38:52 <ab9rf> but probably won't
23:39:53 <dts|pokeball> maybe
23:49:31 <Fuuzetsu> it's ~8am in EU
23:53:05 <texasmynsted> In the entire EU?
23:54:31 <texasmynsted> jk of course
