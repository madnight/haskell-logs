00:01:23 <shachaf> > getConst $ liftA3 undefined (Const (N 1)) (Const (N 2)) (Const (N 3))
00:01:25 <lambdabot>  (N 1 ◇ N 2) ◇ N 3
00:01:27 <shachaf> > getConst $ liftA3' undefined (Const (N 1)) (Const (N 2)) (Const (N 3))
00:01:29 <lambdabot>  N 1 ◇ (N 2 ◇ N 3)
00:01:30 <shachaf> There you go.
00:01:56 <glguy_> Is that stuff in lambdabot by default or are you loading it in /msg
00:02:02 <shachaf> /msg
00:02:12 <shachaf> I think it would be useful to have it in there.
00:02:39 <shachaf> I convinced Milan to switch it to right-associated mappend because we usually like our trees right-biased better than left-biased.
00:02:56 <shachaf> But I didn't think about the Traversable instance (and presumably he didn't either).
00:03:14 <shachaf> I was going to send him an email about it but I didn't figure out how to do it nicely.
00:03:34 <glguy_> On the bright side, this way we have both a way to fold it right and left biased ^_^
00:10:28 * hackagebot relational-query 0.0.1.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.1 (KeiHibino)
00:10:28 * hackagebot persistable-record 0.0.1.1 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.0.1.1 (KeiHibino)
00:18:58 <KangaAkale> Hello all
00:19:16 <KangaAkale> please my Query is messing up in haskell
00:19:37 <speak> KangaAkale: Just state your question, and someone will help you if they can
00:20:16 <glguy_> :t \f a b c -> liftA2 (\x k -> k (f x)) a (liftA2 (\y z k -> k y z) b c)
00:20:17 <lambdabot> Applicative f => (a -> a1 -> b -> c) -> f a -> f a1 -> f b -> f c
00:20:47 <glguy_> shachaf: Maybe if you don't like tuples you like functions? Maybe there's a pattern here I don't see yet ^_^
00:20:52 <gamegoblin> LOL in the System.Random code when you get a random Float it just gets a random Double and casts it to a Float. The comment above the code says:
00:20:55 <gamegoblin> -- hah, so you thought you were saving cycles by using Float?
00:21:25 <shachaf> glguy_: Yes, I probably like functions more than tuples and that's the sort of thing I had in mind. But it's even more awkward.
00:21:39 <jle`> lol gamegoblin
00:21:39 <thang1> mmm...
00:23:04 <KangaAkale> here is my question http://lpaste.net/391936171149623296
00:24:37 <thang1> why is everything on one line?
00:25:03 <pavonia> KangaAkale: Try putting single quotes around the ?'s
00:25:54 <mauke> pavonia: wrong
00:26:16 <pavonia> Double quotes?
00:26:38 <thang1> Does the formatting not give anyone else an anuryism?
00:26:41 <mauke> terrible
00:27:10 <mauke> thang1: http://lpaste.net/raw/391936171149623296
00:27:46 <KangaAkale> pavonia: the single quotes could not handle it
00:27:46 <thang1> Yeah but the entire function and query is on one line and it makes my eyes bleed
00:27:49 <glguy_> The ? stuff is just for parameters
00:27:55 <glguy_> thang1: then stop looking at it
00:28:04 <thang1> I believe the ? would have to be surrounded by backticks, not single quotation marks
00:28:18 <glguy_> retrieveFixtures probably needs a type signature. It would help to know more about the library in use.
00:28:49 <mauke> thang1: wtf
00:28:57 <mauke> could you please stop trying to break the sql
00:29:04 <thang1> The point I'm trying to get at is that if one splits the function up into a more clearly formatted one, errors are much easier to spot. Especially since the eye sees multiple lines better than multiple columns (a reason for "80 column" widths in code)
00:29:21 <mauke> the problem is probably just wrong data
00:29:39 <mauke> either the db doesn't contain what you think it does, or your parameters aren't what you think they are
00:29:54 <thang1> mauke: I was thinking of something else when I mentioned backticks, my bad.
00:30:21 <KangaAkale> thangl http://lpaste.net/391936171149623296
00:30:30 <KangaAkale> it has been done
00:30:37 <thang1> ahh, much better
00:31:04 <KangaAkale> mauke: it is not wrong data< if i hard code it to the query it retrieve
00:31:24 <thang1> There's a space between ID and ", and the " has no space between it and the paramaters. Is it supposed to be that way?
00:31:24 <KangaAkale> so i guess it is the space
00:32:13 <thang1> I've dealt with stuff that was unbelievably picky about stupid stuff like that before, so while I'd normally say it doesn't matter...
00:32:20 <mauke> KangaAkale: I don't think it's the space
00:32:48 <gamegoblin> Man, whoever wrote the System.Random code back in the day made some weird style choices
00:33:04 <thang1> You could say their style choices were...
00:33:05 <thang1> ... random?
00:33:06 <tdammers> KangaAkale: what's the definition of 'team'? What is its type? How does it implement toSql?
00:33:13 <tdammers> KangaAkale: and what's the schema?
00:33:15 <gamegoblin> case statements with only 1 pattern to match instead of just using a let, etc
00:33:36 <thang1> Maybe they're too used to C/C++, gamegoblin?
00:33:49 <gamegoblin> thang1: perhaps, no idea. Not very haskelly code.
00:35:22 <tdammers> single-pattern case expressions *might* be the result of big sweeping refactorings, idk
00:35:24 <glguy_> > case undefined of (_,_) -> True
00:35:27 <lambdabot>  *Exception: Prelude.undefined
00:35:28 <glguy_> > let (_,_) = undefined in True
00:35:30 <lambdabot>  True
00:35:45 <glguy_> There's a difference between single-case case and let
00:35:45 <gamegoblin> the weirdest thing is the single-pattern case looks like this:
00:35:50 <KangaAkale> tdammers team is just a string the is passed to the function at runtime
00:35:57 <KangaAkale> from the console
00:36:04 <tdammers> so its type is String?
00:36:06 <gamegoblin> case expression of pattern -> let f x in y
00:36:14 <shachaf> glguy_: Is there a difference between "let p = x in e" and "case x of ~(p) -> e"?
00:36:20 <gamegoblin> so they go and use a let .. in in the case...
00:36:29 <KangaAkale> yes
00:36:57 <mauke> shachaf: polymorphism?
00:37:19 <shachaf> Fair enough.
00:37:26 * glguy_ was verifying before he blurted that out
00:37:37 <tdammers> KangaAkale: then I suspect, as others have said, that your data is not what you think it is
00:37:56 <thang1> Pretty sure "let p = ..." defines p explicitly while case x of p allows for more polymorphism and doesn't mean that "p" itself is defined in the buffer
00:38:10 <thang1> But I'm rustier on my haskell than I'd like to be
00:38:18 <tdammers> KangaAkale: could you paste the CREATE TABLE for the table in question? Maybe there are issues there...
00:38:34 <KangaAkale> tdammers: please see the block of code that invokes it
00:38:56 <shachaf> I have no idea what thang1 means.
00:39:29 <thang1> shachaf: It's also 12:40am here, and there's a good chance that I worded that absolutely terribly
00:39:32 <shachaf> I guess "let f ... = ... in ..." is also a case, depending on what you allow p to be.
00:40:21 <KangaAkale> tdammers: it works fine for teams that do not have 2 words ex Arsenal or Chelsea, but does not retrieve for teams with two words ex West Ham or Newcastle United
00:41:00 <mauke> KangaAkale: if you keep that shit up, you may get kicked out from this channel
00:41:06 <KangaAkale> tdammers: but if i hardcode the name of these teams with two words it retrieves
00:41:12 <tdammers> KangaAkale: I'm sorry, I must have missed where you pasted the CREATE TABLE statement
00:41:47 <mauke> KangaAkale: and by "that shit" I mean not answering/ignoring questions, instead repeating your guesses
00:42:42 <mauke> and the general attitude of "my program doesn't do what I expect; tell me what to do"
00:42:56 <pecanpy> KangaAkale: this seems like more of a sql question. How is the library replacing the "?"s with values? Is it quoting them properly? this seems like debugging 101. print out the constructed query.
00:43:23 <mauke> pecanpy: if the library is any kind of sane, it's not going to quote or construct a query
00:43:54 <wei2912> :P
00:44:15 <phaazon> hi
00:44:32 <phaazon> I read something about -XStaticPointers
00:44:36 <phaazon> for GHC 7.10
00:44:49 <phaazon> does those introduce mutability ?
00:44:51 <KangaAkale_> mauke: you just kick me out
00:44:54 <phaazon> I don't get it
00:45:21 <KangaAkale_> what is my offence, is it a offence to ask questions
00:45:32 <sivteck> KangaAkale_, KangaAkale is here :)
00:45:36 <mauke> there you go again
00:45:37 <sivteck> you were not kicked
00:45:49 <mauke> seemingly ignoring what I've just said
00:45:59 <sivteck> KangaAkale_, * KangaAkale has quit (Ping timeout: 246 seconds)
00:46:00 <KangaAkale_> ok
00:46:14 <mauke> oh ho
00:46:21 <mauke> ok, maybe you didn't see any of that
00:46:39 <KangaAkale_> Please I am very sorry for the wrong accusation
00:46:40 <mauke> sorry, I didn't see the timeout
00:47:32 <KangaAkale_> tdammers here is the link i was talking about
00:47:38 <KangaAkale_> http://lpaste.net/391936171149623296
00:47:54 <phaazon> no one for -XStaticPointers? :(
00:48:01 <mauke> phaazon: never heard of it
00:48:30 <KangaAkale_> tdammers: please check (annotation) (annotation)
00:49:27 <phaazon> mauke: https://ghc.haskell.org/trac/ghc/wiki/StaticPointers
00:49:43 <phaazon> I think a StaticPtr a is just a « distributed » a
00:49:48 <phaazon> which sounds weird to be
00:49:57 <phaazon> since « a » is already distributed, rigt?
00:50:02 <phaazon> let x = 3 in (x,x)
00:50:14 <phaazon> the x in the pair is implented via pointers
00:50:30 <phaazon> implemented
00:50:54 <pecanpy> KangaAkale: at runtime print out the constructed query. then copy it into dbeaver and take a screen shot of the output run against your db. otherwise i cant imagine how anyone is going to debug your issue
00:51:23 <pecanpy> (since you claim the query works if it is hardcoded)
00:52:04 <pecanpy> does your db have a transaction log?
00:52:06 <mauke> phaazon: I know nothing about cloud haskell (so I don't understand the motivation), but I don't see anything about mutability there
00:52:23 <mauke> pecanpy: what "constructed query"?
00:52:34 <KangaAkale_> no
00:52:45 <phaazon> mauke: yeah I meant immutability*
00:53:02 <mauke> and I can imagine it just fine: show and compare the hardcoded query and the parameters of the other one
00:53:10 <mauke> er
00:53:16 <mauke> *imagine how to debug it
00:53:21 <pecanpy> mauke: quickQuery "blah blah ? ? ?" [args], im guessing it is replacing the "?"s qwith the args? Lets see what its actually building
00:53:28 <mauke> pecanpy: it's not
00:53:32 <mauke> if it's a sane library
00:53:34 <mauke> as I've said before
00:53:57 <pecanpy> mauke: ok then print out the args
00:54:37 <pecanpy> why the fuck am i even getting involved, lol. nvm :)
00:55:31 <phaazon> I'm vey curious about that StaticPointers stuff
00:55:38 <phaazon> and what issue it addresses
00:56:35 <phaazon> it originates from the Cloud Haskell report
00:56:41 <phaazon> to share computations across nodes
00:56:46 <phaazon> so I guess the use is very limited
00:57:11 <phaazon> hence I don't see the difference between a StaticPointer and inner GHC's implementation of let expressions
00:57:18 <lpaste> glguy pasted “reassociating ap” at http://lpaste.net/116225
00:57:43 <glguy_> shachaf: I want to believe if I find the right base case I'll find an operator I can reuse to do this
00:57:50 <glguy_> or at most two
01:01:12 <phaazon> I think it's just for serialization
01:05:31 <lpaste> glguy revised “reassociating ap”: “No title” at http://lpaste.net/116225
01:05:39 <hariso> 7quit
01:09:04 <shachaf> Does base have instance Monoid e => Monad (e,)?
01:09:18 <shachaf> I thought it did but I might be mixing it up.
01:11:18 <glguy_> I don't think it does, but I've seen it implemented somewhere where I didn't implement it
01:11:23 <glguy_> (and on my computer)
01:12:22 <shachaf> Amazingly enough it's on my computer too now.
01:15:36 <jle`> is that the unwrapped Writer?
01:20:33 <ReinH> Isomorphic to
01:20:40 <ReinH> @unmtl Writer w a
01:20:40 <lambdabot> (a, w)
01:20:56 <sinelaw> I'm seeing very slow binary deserialization for fixed point values. Is this a known issue?
01:21:30 <jle`> no reason why it wouldn't be in base i guess
01:21:35 <jle`> unwrapped Reader is already in base
01:21:54 <jle`> s/wouldn't/shouldn't
01:23:44 <shachaf> Haskell isomorphism is pretty boring. It disregards almost all structure.
01:23:44 <phaazon> jle`: unwrapped Reader?
01:23:51 <phaazon> you mean ((->) r)?
01:23:56 <jle`> yes
01:24:03 <jle`> i meant to say, the Monad instance for the unwrapped Reader is already in base
01:24:10 <phaazon> oh, yeah, sure
01:24:15 <jle`> so it would make sense that the Monad instance for the unwrapped Writer to be too
01:24:31 <phaazon> shachaf: I hate the monomorphism restriction
01:24:52 <glguy_> shachaf: instance Data.Monoid.Monoid a => Applicative ((,) a) -- Defined in ‘Control.Applicative’
01:25:00 <glguy_> That's the one I was thinking of
01:25:07 <shachaf> Yes, Applicative it certainly has.
01:25:28 <shachaf> phaazon: An understandable attitude, but why are you telling me? :-)
01:26:27 <phaazon> shachaf: because your isomorphism made me think of it
01:26:44 <phaazon> how I'm bored when a function gets wrongly typed inferred
01:26:57 <phaazon> and I have to explicitely gives it a sig
01:27:00 <phaazon> give*
02:13:08 <marchdown> How can I write map (\ n -> (id n, prime n)) [1,3..1000] more concisely, e.g. without explicit argument?
02:13:31 <dibblego> id &&& prime
02:14:35 <marchdown> thanks
02:15:19 <dibblego> @type runState . gets
02:15:20 <lambdabot> (s -> a) -> s -> (a, s)
02:18:36 <marchdown> &&& is fanout from Control.Arrows, right? What should I read/do to grok arrows?
02:19:33 <shachaf> No need to, if you just want to use (&&&).
02:19:51 <jeltsch> marchdown: (->) is an instance of the Arrow class.
02:19:53 <shachaf> Arrow isn't a particularly widely-used abstraction.
02:20:19 <jeltsch> marchdown: The arrow combinators can also be very useful if you just work with functions.
02:20:28 <jeltsch> For functions, (&&&) is defined as follows:
02:20:45 <jeltsch> (f &&& g) x = (f x, g x)
02:21:11 <jeltsch> > (succ &&& abs) (-3)
02:21:13 <lambdabot>  (-2,3)
02:21:37 <marchdown> jeltsch: I’ve only used -> in case expressions, and I can’t find (->) in docs. What did you mean?
02:21:59 <jeltsch> With (->), I mean the function type constructor.
02:22:04 <marchdown> oh
02:22:08 <jeltsch> -> is an infix operator, like in Int -> Bool.
02:22:14 <jeltsch> (->) means the constructor itself.
02:22:23 <jeltsch> Like (+) is the addition functions.
02:22:43 <jeltsch> There is instance Arrow (->) where …
02:22:45 <marchdown> But that only works with types, not actual values.
02:22:55 <jeltsch> What does only work with types?
02:23:26 <marchdown> Well, the type constructur. You can’t just drop it in code, you can only use it in type annotations.
02:24:26 <jeltsch> My point was that you can take any binary operator, put it in parentheses, and get a kind of identifier.
02:24:38 <jeltsch> This works for operators on values, and it also works for ->.
02:24:51 <jeltsch> So instead of Int -> Bool, you could write (->) Int Bool.
02:25:17 <dibblego> liftA2 (,) id prime
02:25:47 <marchdown> I kind of get it but not quite. Are you saying that (+) somehow restricts which functions we talk about?
02:25:56 <jeltsch> No.
02:26:03 <jeltsch> it is all about syntax.
02:26:25 <jeltsch> Infix operators are just a nice syntax. They are not fundamentally different from ordinary functions.
02:26:42 <marchdown> Oh, I get it then. a -> b is equivalent to (->) a b in the same way as (+) n m is equivalent to n + m.
02:26:51 <jeltsch> Yes, exactly. :-)
02:27:28 <marchdown> Thank you, that clarifies things somewhat.
02:40:28 * hackagebot hackage-db 1.10 - access Hackage's package database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.10 (PeterSimons)
02:40:30 * hackagebot yesod 1.4.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1.1 (MichaelSnoyman)
02:41:22 <osa1> typeclasses are annoying sometimes
02:42:06 <osa1> I'd love to be able to specify which show function to use in HUnit/QuickCheck but I have to wrap types using newtypes and implement instances.
02:45:28 <kraljev1> Hey, is there a shorter way to write this function:
02:45:30 <kraljev1>     f []      =  []
02:45:32 <kraljev1>     f (t:ts)  =  [(t, ts)]
02:45:49 <tasker> ok, so I've written some code and am getting terrible performance. I wrote some bechmarks using criterion, which give me nonsense results, and I don't understand why. What should I do to start trying to speed things up ?
02:46:18 <shachaf> kraljev1: Usually that function appears returning Maybe (a,[a]) rather than [(a,[a])], and is called uncons.
02:46:24 <shachaf> It's not in base, though.
02:46:52 <shachaf> :t maybeToList . uncons :: [a] -> [(a,[a])] -- if you have uncons and really want a list
02:46:53 <lambdabot> [a] -> [(a, [a])]
02:47:40 <osa1> can I override an instance implementation in my module?
02:48:26 <jstolarek> If I have a record data type how can I apply a function to one of its fields?
02:48:53 <tdammers> jstolarek: with vanilla Haskell, it's a bit cumbersome
02:49:16 <tdammers> something like x { foobar = f (foobar x) }
02:49:25 <lpaste> jstolarek pasted “No title” at http://lpaste.net/116228
02:49:33 <tdammers> where x is your original record, and f is the function you want to apply to the foobar field
02:49:44 <jstolarek> tdammers: exactly
02:50:01 <jstolarek> that's the kind of awkwardness I;m trying to avoid
02:50:03 <waressearcher2> "vanilla Haskell", by the way you reminded me of something, is there some incompatible versions of haskell ? similar to "Perl 5 VS Perl 6" or "Python 2.x VS Python 3.x" ? or could it happen in future ?
02:50:35 <shachaf> jstolarek: Doing that sort of thing is one of the main points of lenses.
02:50:48 <tdammers> yes, lens is what i was getting at
02:51:10 <jstolarek> waressearcher2: as far as I know Haskell 2010 is compatible with Haskell 98, but GHC extensions are often backwards incompatible between GHC versions
02:51:19 <tdammers> foobar %~ f $ x
02:51:26 <jstolarek> shachaf, tdammers: yes, I was affraid lenses might be the answer
02:51:33 <shachaf> lens is one package that provides lenses, yes. Any of the other ones would work too. :-)
02:51:37 <kraljev1> when is uncons going to be added? https://ghc.haskell.org/trac/ghc/ticket/9550
02:51:44 <jstolarek> but I don;t think I would convince GHC devs to pull in lenses as a dependency to GHC :-)
02:51:47 <kraljev1> which release of ghci?
02:52:07 <shachaf> Looks like GHC 7.10.
02:52:12 <trap_exit> is there a good way to use haste or fay with happstack?
02:52:15 <shachaf> I don't know that it should be added, but it looks like it's too late.
02:52:28 <trap_exit> i want the client side to be more than just forms
02:52:40 * shachaf generally buries his head in the sand as far as anything involving dfeuer is concerned.
02:54:56 <phaazon> there's no way to do guards in lambda functions?
02:55:13 <phaazon> \e | e == "x" -> ... | otherwise -> ...
02:55:28 <shachaf> Guards are part of pattern matching syntax.
02:55:59 <zomg> phaazon: I think you could use MultiWayIf to have a similar style
02:56:00 <shachaf> GHC has an extension: \e -> if | ... -> ... | ... -> ...
02:56:25 <phaazon> yeah, well, I could also create another function
02:56:35 <phaazon> though it's funny it doesn't work with lambdas
02:56:47 <phaazon> foo e | e == "x" = ... | otherwise = ...
02:56:51 <phaazon> that should work with lambda as well
02:56:57 <phaazon> since we can pattern match in lambdas
02:57:03 <shachaf> In your case, you can pattern-match, and GHC has another extenion: \case "x" -> ...; e -> ...
02:57:12 <shachaf> No it shouldn't.
02:57:20 <phaazon> shachaf: why?
02:57:39 <phaazon> map (\(x,y) -> x + y) [(1,2),(3,4)]
02:57:41 <phaazon> that's legit
02:57:45 <phaazon> > map (\(x,y) -> x + y) [(1,2),(3,4)]
02:57:47 <lambdabot>  [3,7]
02:57:58 <shachaf> Yes, I know you can do that in lambdas.
02:58:33 <phaazon> shachaf: so why can't we use guards?
02:58:56 <phaazon> > map (uncurry (+)) [(1,2),(3,4)]
02:58:58 <lambdabot>  [3,7]
02:59:06 <phaazon> ahah I love that function
03:00:41 <shachaf> If you want to add it, sure. But it's not naturally a part of existing syntax, it's a proposed addition.
03:01:10 <shachaf> Just like matching on multiple patterns in one lambda was.
03:01:44 <phaazon> shachaf:
03:02:02 <phaazon> case x of | x == "x" -> ...
03:02:07 <phaazon> that is already a weird syntax
03:03:08 <shachaf> Yes, it's a syntax error.
03:04:56 <phaazon> hm, yeah, wait.
03:07:41 <phaazon> yeah I got it shachaf
03:08:11 <lpaste> phaazon revised “No title”: “Weird stuff” at http://lpaste.net/116229
03:08:15 <phaazon> ^ shachaf
03:08:50 <shachaf> Yes, case-of syntax is one of the places that supports guards.
03:10:15 <sinelaw> Just noticed this:
03:10:20 <sinelaw> Prelude> :t [1,2,3]
03:10:21 <sinelaw> [1,2,3] :: Num t => [t]
03:10:21 <sinelaw> Prelude> :t [1..3]
03:10:21 <sinelaw> [1..3] :: (Num t, Enum t) => [t]
03:10:34 <phaazon> sinelaw: that's normal
03:10:49 <sinelaw> if surprising
03:10:54 <phaazon> no
03:10:55 <phaazon> it's not
03:11:00 <sinelaw> no when you think about it
03:11:04 <sinelaw> *not
03:11:10 <phaazon> :t (:+:)
03:11:11 <sinelaw> but when you don't consider it
03:11:11 <lambdabot>     Not in scope: data constructor ‘:+:’
03:11:11 <lambdabot>     Perhaps you meant ‘:+’ (imported from Data.Complex)
03:11:17 <sinelaw> it can surprise you
03:11:27 <phaazon> :t (:+)
03:11:28 <lambdabot> a -> a -> Complex a
03:11:42 <phaazon> :t [1..3] :: [Complex Int]
03:11:43 <lambdabot>     No instance for (Enum (Complex Int))
03:11:44 <lambdabot>       arising from the arithmetic sequence ‘1 .. 3’
03:11:44 <lambdabot>     In the expression: [1 .. 3] :: [Complex Int]
03:11:46 <sinelaw> leads to some weird behavior in my program - something converges with [1,2,3] and diverges with [1..3]
03:11:51 <phaazon> oh I thought so
03:12:01 <shachaf> not surprising when you think about it
03:12:10 <phaazon> sinelaw: that's because [1,2,3] only needs (Num a)
03:12:14 <phaazon> because of fromInteger
03:12:26 <phaazon> [1..3] needs both fromInteger and Enum (because of ..)
03:12:54 <sinelaw> phaazon, I realize that. but I have some difference in behavior due to this, which IS surprising
03:12:57 <phaazon> I thought (Enum a) => Complex a would be Enum
03:13:15 <sinelaw> not sure why yet.
03:13:21 <phaazon> :t fromEnum $ 1 :+ 3
03:13:22 <lambdabot>     No instance for (Enum (Complex a0))
03:13:22 <lambdabot>       arising from a use of ‘fromEnum’
03:13:22 <lambdabot>     In the expression: fromEnum
03:14:13 <phaazon> hm
03:14:13 <sinelaw> ok something is wrong here.
03:14:14 <phaazon> no
03:14:18 <phaazon> that makes sense
03:14:22 <sinelaw> this tiny program diverges
03:14:26 <phaazon> succ (1 :+ 1) is undefined
03:16:02 <sinelaw> Can anyone explain this behavior? http://lpaste.net/116232
03:16:07 <sinelaw> very strange
03:17:08 <thang1> Why do you need the $ in there?
03:18:17 <sinelaw> thang1, no good reason, but that's beside the point
03:19:34 <sinelaw> why does that program diverge?
03:21:08 <otulp> stiell: DiffTime does not run [1, 2, 3, 4... ], but generates an enormous list.
03:21:21 <otulp> I meant stinelaw.
03:21:26 <marchdown> Can it be that it takes extra time to construct the list or to expand the ellipsis? How can we check this?
03:23:55 <sinelaw> otulp, why an enormous list?
03:24:08 <otulp> sinelaw: succ (1 :: DiffTime) is not 2.
03:24:19 <otulp> It is 1.0000....tinyamount
03:25:00 <sinelaw> otulp, ok, thank you
03:25:04 <ChristianS> ?pl \a b -> a
03:25:04 <lambdabot> const
03:25:13 <ChristianS> ?pl \a b -> b
03:25:14 <lambdabot> const id
03:25:14 <sinelaw> > [1..2] :: [Data.Time.DiffTime]
03:25:15 <lambdabot>  Not in scope: type constructor or class ‘Data.Time.DiffTime’
03:25:45 <ChristianS> can anyone explain that 'const id' case above ^^ ? i don't understand what exactly happens there...
03:25:46 <osa1> QuickCheck is driving me crazy
03:26:00 <osa1> it should have provided a way for users to specify failure messages.
03:26:10 <moop> haskell doesn't fail
03:27:44 <shachaf> ChristianS: What's the issue?
03:27:59 <sinelaw> otulp, https://stackoverflow.com/questions/27421598/why-does-this-haskell-program-diverge/27421685#27421685
03:28:05 <shachaf> Which step is missing?
03:28:22 <shachaf> const = (\x -> (\y -> x)); id = (\z -> z)
03:28:31 <pantsman> ChristianS: it should make sense if you manually evaluate (const id) a b
03:28:55 <shachaf> const id = (\x -> (\y -> x)) (\z -> z) = (\y -> (\z -> z))
03:29:39 <pantsman> (const id) a b = id b = b
03:30:07 <ChristianS> pantsman: ah, that's it, thanks! now i get it...
03:30:25 <jcpetruzza> osa1: what about the "counterexample" function
03:31:16 <osa1> jcpetruzza: whoa how come I didn't see it? I guess it's doing exactly what I want, right?
03:31:49 <jcpetruzza> osa1: look also at the (===) operator
03:32:01 <jcpetruzza> which is defined in terms of counterexample
03:32:20 <osa1> no really I need most general function available
03:32:25 <osa1> counterexample looks like what I need
03:35:10 <jle`> is there any way i can use co-do notation today?
03:36:17 <jle`> oh there's a quasiquoter
03:38:00 <thang1> osa1: why do you need the most general function available?
03:38:36 <osa1> thang1: I want to be able to provide whatever failure message I want
03:38:44 <thang1> And wouldn't the type of such a function be something like a b = a b ?
03:38:58 <torpet> slightly offtopic: i was having the idea of running unit tests via web interface
03:39:07 <torpet> people could select the unit test and paste their code and then press run
03:39:29 <thang1> What do you need the failure message for? Seems to me that if you have a function which is using guards (for example) you could simply have a guard like | if failed = output "muh durn error message"
03:39:30 <torpet> i am already running a linux, what is the absolutely easiest way to deploy this functionality with as little coding as possible?
03:39:39 <thang1> no need for a special super duper failure message function?
03:39:40 <torpet> *a linux vps
03:40:30 * hackagebot relational-query 0.0.1.2 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.2 (KeiHibino)
03:41:03 <thang1> torpet: Hmm... Naive guess: A small website where you have them click a unit test, upload code and then you parse the code by running it through ghc [or however you would unit test it] in the back end, and then output whatever is relevant to the users when you're done
03:41:54 <torpet> hm yeah that was my first guess. i have stumbled upon this articles on hacker news: https://halcyon.sh/
03:41:57 <thang1> You would simply have pre-configured unit tests which execute depending on which link they select (this doesn't seem too useful to me. Even as generic as haskell can get, it seems awfull limiting to only have a list of unit tests to choose from)
03:42:00 <torpet> could that help me in my case?
03:42:36 <thang1> You've heard of the school of haskell (fpcomplete) yes?
03:42:41 <thang1> https://www.fpcomplete.com/school
03:42:58 <torpet> no actuqlly i havent
03:43:08 <thang1> One of the nice features is that their code is "runnable" on their server. So you can edit some of the snippets and play around with it, then click 'run' right inside the tutorial and see the results
03:43:19 <torpet> oh ok will look into it, thanks
03:43:44 <thang1> https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics take a look at this for a quick demo
03:44:01 <thang1> just ctrl+f "Declarations and variables" and there's two small 'runnable' examples right there
03:44:14 <thang1> It's worth looking into how they implement their runnable code
03:44:30 <thang1> Alternatively, depending on what you want the unit test server for, you might look into creating a custom build-server
03:45:28 <thang1> The programming practice of continuous integration (http://en.wikipedia.org/wiki/Continuous_integration) makes heavy use of them, and that might be what you want
03:45:56 <torpet> Thank you!
03:46:16 <thang1> The main premise is that programmers merge into a shared mainline several times a day, effectively having a continuously improving "master branch" which progresses through thousands of micro-changes
03:47:05 <thang1> Build servers have developed to the point where many will take the code you've uploaded, automatically run any relevant unit tests on them (that you've designed), check for everything to pass, and then once it all passes it'll merge it with the main branch and compile everything. It will also notify you of the status (success or not) for every step of the process
03:48:15 <prinsen> Can a cabal package contain 2 .cabal files? I would like the main .cabal file to use makefiles, and have that call cabal install for the other .cabal file which uses the Simple build-type
03:49:29 <dcoutts> prinsen: no, a cabal package itself is the unit of distribution. A single package can currently contain at most one lib and many exes (plus test suites and benchmarks)
03:49:42 <dcoutts> packages can of course depend on each other though
03:52:30 <stillwater> haskell newbie here
03:52:33 <stillwater> :/
03:52:45 <moop> why the long face
03:52:50 <prinsen> dcoutts does cabal passes which source files that should be build to make?
03:53:11 <stillwater> Dont know where exactly to start
03:53:24 <stillwater> I am learning from a lots of places
03:53:25 <dcoutts> prinsen: no, it just calls make and the default target is supposed to build everything.
03:53:25 <bernalex> stillwater: https://github.com/bitemyapp/learnhaskell this is rather popular
03:53:50 <moop> stillwater: start reading learnyouahaskell.com
03:54:05 <bernalex> @LYAH
03:54:05 <lambdabot> Unknown command, try @list
03:54:10 <moop> @lyah
03:54:10 <lambdabot> Unknown command, try @list
03:54:14 <stillwater> I started off with LYAH
03:54:17 <moop> !lyah
03:54:23 <stillwater> then someone recommended real world haskell
03:54:24 <bernalex> oh it's
03:54:26 <bernalex> @learn
03:54:26 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
03:54:32 <stillwater> and then the interactive tutorial
03:54:37 <stillwater> and now i am confused
03:54:38 <bernalex> stillwater: I would not use RWH TBH. some people like it.
03:55:02 <moop> i thought you should read rwh after you done with lyah
03:55:07 <bernalex> stillwater: first of all, it has *a lot* of case studies, which can be boring if you don't find them interesting. secondly, it's not for complete newbies. thirdly, it's very outdated.
03:55:16 <bernalex> stillwater: do you know any other programming languages or paradigms?
03:55:28 <stillwater> I work on .NET for my day job
03:55:31 * hackagebot extensible-effects 1.8.1.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.8.1.0 (shergill)
03:55:36 <otulp> prinsen: You could perhaps generate the .cabal file (and other resources) from the Makefile? Not sure if that would make sense for your problem at all.
03:55:40 <bernalex> stillwater: then Learn You A Haskell should be suitable.
03:56:06 <dcoutts> prinsen: what are you trying to do overall?
03:56:07 <stillwater> the github link looks great.Thanks!
03:56:31 <bernalex> stillwater: enjoy. this channel is very nice if you have questions along the way.
03:56:45 <jle`> MonadComprehensions with (-> r)/Reader r. interesting.
03:56:55 <stillwater> Heard plenty of good things abt the channel
03:56:59 <stillwater> :)
03:57:04 <bernalex> jle`: I wish MC were on by default. the only reason they're not is because "meh nobody cares" lol
03:57:32 <bernalex> and I guess "more difficult error msgs for newbies", but now with Foldable/Traversable that's a bit moot.
03:57:43 <jle`> a part of me still feels weird about it
03:57:55 <thang1> I might as well throw my own opinion in with the lot. I don't recommend Real World Haskell, it's several years old and that's just a crime with a language as quickly changing/adapting as Haskell currently is. I don't really recommend Learn You A Haskell for Great Good either
03:58:01 <bernalex> jle`: MC with IO is a bit confusing at first, but mostly I think they're very nice.
03:58:17 <moop> thang1: what you reccomend then?
03:58:26 <stillwater> thang1 what do you recommend?
03:58:35 <thang1> LYAH is very good at giving you a "I understand this! Great! Awesome!" type of feeling about Haskell, but then when you actually try to 'do' anything, you quickly realize you don't really understand it and it quickly gives you a bad feeling about the whole thing
03:58:40 <prinsen> otulp: dcoutts: I have written a TH library that needs to be compiled in stages. Currently I have a .cabal file with Simple build-type that builds the stages, and a Makefile to invoke cabal install with different flags, but I want to upload it to hackage so this method doesn't work
03:58:40 <stillwater> I want to get my hands as dirty as possible learning haskell
03:58:43 <bernalex> thang1: RWH is full of stuff that doesn't compile. some of it didn't even compile when the book came out. they actually have output of their commands, printed in the book, that's just type errors. that's hardly motivating.
03:58:49 <moop> i learned haskell from this youtube video https://www.youtube.com/watch?v=RqvCNb7fKsg
03:58:53 <thang1> I recommend bernalex's first option, which was the github link, actually
03:59:31 <thang1> https://github.com/bitemyapp/learnhaskell is awesome. It's written by someone who actually teaches haskell "as fast as possible" to several people
03:59:53 <jle`> too bad lambdabot doesn't have MC on
03:59:54 <bernalex> moop: I recommend https://www.youtube.com/watch?v=IcoWB5E4CaE for more advanced topics
04:00:05 <dcoutts> prinsen: can you give more detail, why can't it be one package? what are the different stages and the flags for the stages?
04:00:11 <bernalex> jle`: ikr? I forget about it probably once a month and try to use it
04:00:16 <thang1> Best part is that it gives you a step by step to install haskell (surprisingly difficult for many people, especially if they're not familiar with it)
04:00:25 <mostalive> stillwater: I find writing small programs helped (e.g. command line prog to manipulate csv helpful). Now I'm working on a bigger app with someone who knows haskell better so I can do things without having to know everything in one go.
04:00:33 <moop> bernalex: that's a very interesting video, thank you
04:00:49 <stillwater> The github link recommends LYAH and RWH in that order
04:01:03 <thang1> I would make one change from the github recommendation, however. Instead of learning CIS194 from the website itself
04:01:11 <bernalex> stillwater: it recommends byorgey's course first
04:01:16 <thang1> ^ exactly
04:01:39 <bernalex> stillwater: with LYAH & RWH as supplemental references.
04:01:43 <thang1> Instead of learning CIS194 from the website (which is awfully old), I would take it here: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
04:01:47 <prinsen> dcoutts: I want it to be one package. The different stages generate files used in the comming stages. The flags are -fhsc, -fswig and -fffi and they basically control which files are compiled by cabal
04:02:09 <thang1> It's the same exact thing as Byorgey's course, but they fixed small niggles and you have runnable and dynamic code things you can click on to get the result!
04:02:13 <moop> thang1: should add a pull request to replace the link
04:02:35 <prinsen> dcoutts: http://lpaste.net/116234
04:02:35 <byorgey> thang1: it's not the same exact thing, actually, it's only the first half =)
04:02:46 <byorgey> but for the first half it's indeed great
04:02:58 <stillwater> Now i am confused
04:03:03 <stillwater> even more
04:03:08 <thang1> It allows you to go directly from reading to going "oh cool let's see how that works *click*" and you can even open an "IDE" to play with the code immediately
04:03:35 <stillwater> thang1 you are talking abt the FPSchool link?
04:03:45 <thang1> Yes I am, stillwater
04:03:46 <stillwater> FPComplete*
04:03:56 <moop> what is fp complete anyways
04:04:02 <moop> is it an ide?
04:04:16 <thang1> tl;dr. Go to FPComplete with this course: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell to take the first half of CIS-194
04:04:27 <byorgey> moop: it is a company, one of whose main products is a web-based IDE
04:04:27 <thang1> and then take the second half of it from the original website that's listed in the github link
04:05:10 <thang1> The reason I recommend the FPcomplete link over just doing the entire thing in the original website is because you have runable and working snippets to test things out with. You're going to be really confused for the first little bit of learning haskell
04:05:37 <thang1> so the less things you have to "figure out" the better. Having an IDE that works with one button, code snippets you can click to run (that go with the examples), and having everything laid out really clearly
04:05:38 <stillwater> Alright
04:05:41 <thang1> will help a LOT for the assignments
04:06:01 <thang1> By the time you're done with the first half you should be able to survive the second half of CIS-194 "offline" with no problem :)
04:06:01 <stillwater> I am going to stick with fpcomplete for a few weeks and see how it goes
04:06:05 <dcoutts> prinsen: ah I see, your ffi one is doing something that cabal does not really support: constructing shared libs for use by C code
04:06:21 <stillwater> Sounds cool
04:06:25 <dcoutts> prinsen: but I don't yet understand why any of that requires multiple phases.
04:06:28 <thang1> Do the 'introduction to haskell' one. FPcomplete has several different tutorials on there, but that one's my favorite.
04:07:04 <thang1> An aside: I was super excited to see that the FPcomplete website had vim keybindings, but that was just my browser plugin... Sadness...
04:07:05 <prinsen> dcoutts: Phrase it like this, you cant compile with the -ffi flag if you have't compiled with -fhsc first
04:07:06 <dcoutts> prinsen: but if it really does, then using multiple packages that depend on each other would be more straightforward and fit the standard packaging approaches
04:07:38 <prinsen> dcoutts: as it creates files
04:07:48 <stillwater> I'm taking a look at fpcomplete's "Introduction to Haskell".The IDE thing is neat!!!
04:07:52 <prinsen> dcoutts: I also need to run hsc2hs
04:09:15 <prinsen> dcoutts: I suspect it might be easiest to use a makefile, as I need to generate SWIG wrappers after cabal install -fffi anyways
04:09:54 <dcoutts> prinsen: I still don't see the problem. Cabal will call hsc2hs automatically. And the _stub.h files are generated before we compile the .c files that use them.
04:11:23 <dcoutts> prinsen: I note that your ffi section does not list the TH.HSC in other-modules
04:12:13 <dcoutts> prinsen: let me ask it anther way: what would go wrong if you had no flags there in the .cabal file and you had all this within the main library section?
04:12:14 <stillwater> Thanks for the recommendations everyone
04:12:45 <prinsen> dcoutts: Can you list .hsc files in cabal? Right now I generate the .hsc files in step 1, call hsc2hs, and then have the .hs files included in step 2
04:12:51 <dcoutts> prinsen: there's clearly some ordering problem you're trying to work around, but I have not yet seen what that ordering problem is
04:13:11 <dcoutts> prinsen: cabal will look for .hs, .lhs, .hsc, ... and a few other known pre-processors
04:13:48 <dcoutts> prinsen: so you just have to list the modules, and Cabal will do the right thing with known pre-processors
04:14:17 <prinsen> dcoutts: But the .hsc files wont exist before TH.HSCs has been compiled
04:14:37 <prinsen> dcoutts: didn't know that, cool
04:14:48 <dcoutts> prinsen: are you saying that you have TH code that writes out new .hsc files?
04:14:52 <prinsen> yes
04:15:00 <dcoutts> ah, then you need to do this differently
04:15:34 <dcoutts> you can make an executable within your package that acts as the pre-processor
04:15:42 <dcoutts> and make the library depend on that build-tool
04:15:59 <prinsen> thats pretty smart
04:16:07 <prinsen> i will give it all a try
04:16:07 <dcoutts> you can register custom pre-processors with Cabal, if you use a build-type: Custom
04:17:42 <prinsen> dcoutts: that build tool will leave a trash executable tough?
04:18:08 <dcoutts> prinsen: the simplest way is to integrate it is to invent a file extension for your pre-processor
04:19:16 <dcoutts> prinsen: that's true
04:19:44 <dcoutts> prinsen: though I suspect that's hackable within the Setup.hs by fiddling with the install hook
04:20:05 <dcoutts> by filtering out that exe from the package description
04:20:08 <dcoutts> or rather copy hook
04:22:16 <prinsen> dcoutts: I think thats the most promising
04:22:45 <prinsen> dcoutts: there is no "preprocessor". Its a TH file that reads pairs of files and spits out a .hsc file
04:23:23 <dcoutts> prinsen: sounds like it'd be easily adaptable to be one
04:25:10 <prinsen> dcoutts: Is there any solution to my extra-libraries section?
04:26:06 <dcoutts> prinsen: for linking the shared lib that exports a C API. No not yet. Cabal does not directly support producing system shared libs yet, just exes and Haskell libs.
04:29:44 <osa1> can I set a timeout in QuickCheck?
04:33:06 <prinsen> dcoutts: How do I make the library depend on the executable, just placing it under build-depends dont work
04:33:25 <dcoutts_> prinsen: build-tools
04:33:25 <sinelaw_> @hoogle Char -> Word8
04:33:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:33:27 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
04:33:27 <lambdabot> Prelude error :: [Char] -> a
04:33:30 <sinelaw_> :(
04:36:36 <flaggy> hello guys. I have the following pattern: https://gist.github.com/aflag/8d855b4549dc8a10361f
04:36:46 <Th30n> hello everyone
04:37:02 <flaggy> It seems to me that I could somehow not write that otherwise all the time
04:37:09 <flaggy> but I can't figure out how
04:37:10 <Th30n> is there any vehicle routing problem framework for haskell? like open-vrp for common lisp?
04:37:51 <flaggy> maybe I could use a case or an if instead of patter matching and guards, but it doesn't seem like it is going to look that pretty either
04:39:21 <BoR0> flaggy, remove the otherwise from each guard, and add nextPos _ _ (x, y) = (x, y)
04:40:38 <BoR0> (I think that should work)
04:42:34 <bberry> So, I am reading through LYAH (great book so far!), but I'd like some challenges or problems to do to test my understanding.  I saw that haskell is on codewars.com, but are there any similar places that provide a challenge and supply the answer when youve completed it?
04:43:12 <Th30n> bberry: try www.hackerrank.com
04:43:27 <Th30n> it has various domains and functional language specific one
04:43:43 <bberry> Th30n, very cool, will do, thanks!
04:49:36 <otulp> flaggy: You could also write something like "nextPos grid dir loc = bounded update", where "update" pattern matches on the direction and makes a new location and "bounded" substitutes the updated location for loc if it is out-of-bounds.
04:50:32 * hackagebot lifted-base 0.2.3.1 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.1 (BasVanDijk)
04:53:38 <flaggy> otulp: good idea
04:54:03 <prinsen> dcoutts_: I get Installing executable(s) in /home/fabian/.cabal/bin
04:54:03 <prinsen> setup-Simple-Cabal-1.20.0.2-x86_64-linux-ghc-7.8.3:
04:54:03 <prinsen> dist/build/api-apis-preprocessor/api-apis-preprocessor: does not exist
04:54:04 <prinsen> cabal: Error: some packages failed to install:
04:55:33 * hackagebot hackage-db 1.11 - access Hackage's package database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.11 (PeterSimons)
04:57:13 <gansteed__> i got an `Not in scope: `catch``error when i am learning exceptions
04:57:14 <gansteed__> here is the code: http://lpaste.net/116235
04:58:03 <bitonic> is there any parser generator that works well when parsing languages similar to Haskell -- layout rule and operators with user-defined fixities?
04:58:25 <otulp> gansteed__: Import Control.Exception (catch)
04:58:47 <otulp> gansteed__: Lower-case import, not Import. Sorry.
04:59:08 <gansteed__> otulp: :D
05:00:58 <gansteed__> otulp: wow, it works! thank you very much! i think i should main author of learnyouahaskell to fix this bug :D
05:03:31 <thang1> Example numbero one why I don't like recommending books in print for a fast moving language like Haskell :p
05:04:21 <Cale> gansteed: He used to hang around here, but disappeared shortly after publishing the book
05:05:33 * hackagebot streaming-commons 0.1.7.2 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.7.2 (MichaelSnoyman)
05:06:05 <wdanilo> Hello! Is there in haskell something like Data.Map but one that does not bases on Ord but my custom comparison function / typeclass ?
05:06:05 <gansteed> thang1: well, actually, i read it on line.
05:06:21 <gansteed> Cale: i got his e-mail :D
05:07:56 <phaazon> @pl do { _ <- a; b }
05:07:56 <lambdabot> (line 1, column 4):
05:07:56 <lambdabot> unexpected '{'
05:07:56 <lambdabot> expecting variable, "(", operator or end of input
05:08:02 <phaazon> @pl do { _ <- a; b; }
05:08:02 <lambdabot> (line 1, column 4):
05:08:02 <lambdabot> unexpected '{'
05:08:02 <lambdabot> expecting variable, "(", operator or end of input
05:08:03 <thang1> It's not that they're available online that's the problem, is the fact that they're "in print" so they don't change and update to match the changes in the language
05:08:30 <phaazon> > (print >> print) 3
05:08:32 <lambdabot>  <IO ()>
05:09:39 <phaazon> @pl do { _ <- a x; b x }
05:09:39 <lambdabot> (line 1, column 4):
05:09:39 <lambdabot> unexpected '{'
05:09:39 <lambdabot> expecting variable, "(", operator or end of input
05:10:06 <phaazon> oh, got it
05:10:14 <phaazon> I might need Kleisli f >> Kleisli g
05:14:22 <phaazon> yeah it's not Kleisli
05:14:22 <phaazon> hm
05:14:58 <phaazon> :t Kleisli
05:14:59 <lambdabot> (a -> m b) -> Kleisli m a b
05:15:09 <phaazon> :t Kleisli print >> Kleisli print
05:15:10 <lambdabot> (Show a, Monad (Kleisli IO a)) => Kleisli IO a ()
05:15:22 <phaazon> why can't I runKleisli that?
05:15:30 <phaazon> :t runKleisli (Kleisli print >> Kleisli print)
05:15:31 <lambdabot> (Show a, Monad (Kleisli IO a)) => a -> IO ()
05:15:57 <phaazon> :t runKleisli (Kleisli print >> Kleisli print) 314
05:15:58 <lambdabot>     No instance for (Show a0) arising from a use of ‘print’
05:15:58 <lambdabot>     The type variable ‘a0’ is ambiguous
05:15:58 <lambdabot>     Note: there are several potential instances:
05:16:06 <phaazon> :t runKleisli (Kleisli print >> Kleisli print) (314 :: Int)
05:16:07 <lambdabot>     No instance for (Monad (Kleisli IO Int)) arising from a use of ‘>>’
05:16:07 <lambdabot>     In the first argument of ‘runKleisli’, namely
05:16:07 <lambdabot>       ‘(Kleisli print >> Kleisli print)’
05:16:10 <phaazon> dammit
05:17:11 <phaazon> the monadic version is a bit dumb to me
05:17:34 <phaazon> foo app = do { sink app'; run app'; } where app' = logic app
05:17:44 <phaazon> sink >> run doesn't do what I want
05:18:29 <phaazon> hm, maybe... sequence [sink,run]
05:27:49 <phaazon> hm...
05:28:04 <phaazon> sequence . sequence [print,print] != print >> print
05:28:12 <phaazon> I would say it's the same thing
05:28:29 <phaazon> sequence_ . sequence [print,print] != print >> print
05:28:34 <phaazon> ^ fixed
05:28:49 <phaazon> so, print >> print actually prints only once
05:28:58 <phaazon> while sequence_ . sequence [print,print] prints twice
05:30:10 <phaazon> hm
05:30:26 <phaazon> print >> print = do { _ <- print; print }
05:30:36 <lpaste> breadmonster pasted “Type error?” at http://lpaste.net/116236
05:30:37 <phaazon> that means the IO () is never used
05:30:51 <butyoudonot> wdanilo: what is wrong with Data.Map if you need an ordered container?
05:30:53 <phaazon> now, sequence_ . sequence [print,print]
05:31:00 <breadmonster> Can someone tell me what's wrong with that code?
05:31:20 <phaazon> oh
05:31:22 <phaazon> ok, get it
05:31:22 <breadmonster> Specifically, why encode has type [()] -> [((), int)]
05:31:27 <breadmonster> ?
05:31:32 <phaazon> sequence will take out the value
05:32:04 <phaazon> since it collects the value
05:32:21 <phaazon> and the upper sequence_ discards them, but they were already evaluated
05:33:21 <wdanilo> butyoudonot: One simple thing - I want to use keys, that should be considered the same even if they Ord instance shows they are different. A funny thing :D
05:35:00 <phaazon> yay
05:35:05 <phaazon> so I can write my stuff like this:
05:35:21 <phaazon> sequence_ . sequence [sink,run] . adapter
05:35:21 <phaazon> :)
05:35:27 <breadmonster> butyoudonot: Do you mind giving me a hand?
05:35:44 <elfeck> heyoh, really new to haskell. Question about ( ):
05:35:44 <elfeck> Is f (g x) or  f g (x) correct?
05:36:01 <phaazon> elfeck: depends
05:36:05 <phaazon> both are correct Haskell syntax
05:36:14 <tdammers> wdanilo: you could wrap your key in a newtype that overrides the Ord instance
05:36:15 <elfeck> I want f after g of x
05:36:22 <phaazon> f could be a high order function, so that f g (x) == f g x is correct
05:36:31 <phaazon> elfeck: the former then
05:36:38 <elfeck> okay, thanks
05:36:43 <phaazon> you could also write (f . g) x
05:36:47 <elfeck> I know
05:36:53 <elfeck> wasnt sure about the ( ) though
05:37:02 <phaazon> () is just for delimiting
05:37:07 <phaazon> it has nothing to do with calling
05:37:17 <phaazon> think of it as in math ;)
05:37:22 <elfeck> yep, thats clear now, thanks!
05:37:29 <phaazon> 3 + 1 * 4 vs. (3 + 1) * 4
05:37:36 <phaazon> exactly the same thing in Haskell with parameters and calls
05:38:08 <wdanilo> tdammers: I know, but that's a bit ugly I think. You know, Ord and Eq means that something is bigger or smaller or eqal and I've got here some kind of multinames, what I mean: data MultiName = MultiName {base::String, segments:: [String]} and I want to use them as a keys but using only the base value. Making an instance of Ord even with newtype is a bit ugly here I think, am I wrong?
05:38:15 <breadmonster> Is there a bug in WinGHCi?
05:41:03 <thang1> Probably
05:41:20 <thang1> Is there one in particular you're thinking of?
05:41:49 <breadmonster> thang1: Yup.
05:41:50 <breadmonster> One second.
05:42:12 <lpaste> breadmonster pasted “Interesting error?” at http://lpaste.net/116237
05:42:27 <breadmonster> thang1: ^
05:43:37 <breadmonster> I think I'll file a bug report.
05:43:43 <ClaudiusMaximus> breadmonster: monomorphism restriction and defaulting can combine to give less polymorphic than expected types
05:43:44 <thang1> Did you try cloning it in the IDE?
05:44:09 <breadmonster> ClaudiusMaximus: From an abstract type to ()?
05:44:14 <breadmonster> thang1: No, how do you do that?
05:45:03 <ClaudiusMaximus> breadmonster: yeah - solution is to add an explicit polymorphic type signature, or :set -XNoMonomorphismRestriction
05:46:10 <thang1> In the link you gave me there's a line of buttons right below "Interesting error?"
05:46:33 <thang1> There's "expand" "edit" "annotate"...etc. Rightmost is "Clone in IDE". It'll open up a in-browser IDE to try the code out in
05:47:31 <thang1> If you think there's a bug in WinGHCi you can always try that out. Most likely, there's probably just an error in the code. GHC is a very smart compiler and is rarely wrong/buggy with most code
05:49:00 <breadmonster> ClaudiusMaximus: Why on earth is this set?
05:49:53 <ClaudiusMaximus> breadmonster: https://www.haskell.org/haskellwiki/Monomorphism_restriction
05:52:07 <breadmonster> ClaudiusMaximus: Can you explain to me how it prevents multiple evaluation?
05:52:36 <oliffea> is there a way to force the haskell program to consume at most a specified amount of memory?
05:52:41 <oliffea> a haskell program*
05:53:14 <oliffea> i am running in cygwin if that helps
05:53:56 <thang1> Cgywin won't do much to help, either way
05:54:04 <ClaudiusMaximus> breadmonster: if you have say  primes :: Integral a => [a]  then it can't share the computation if you use it at different types, defaulting to [Integer] with the monomorphism restriction means primes can be shared
05:54:38 <thang1> However, why do you want to limit Haskell to a certain amount of memory? Haskell has a garbage collector so really you shouldn't bother worrying about the memory and just code the program cleanly and let the memory take care of itself
05:54:48 <oliffea> my actual issue is that when a program consumes all system memory, the computer hard-locks
05:54:55 <thang1> Ahhh
05:55:00 <ClaudiusMaximus> breadmonster: not sure if GHC or other compilers share polymorphic values anyway, you could feasibly have two lists, one of Int and one of Integer, behind the scenes, each shared
05:55:03 <breadmonster> thang1: How do you code un-cleanly in Haskell?
05:55:15 <breadmonster> ClaudiusMaximus: This is really interesting.
05:55:27 <thang1> Code in an imperative style and force imperative mindsets on a functional language
05:55:45 <ClaudiusMaximus> oliffea: try compiling with -rtsopts and running with +RTS -? to see available heap/stack limiting options
05:56:22 <oliffea> ClaudiusMaximus: settint -M has no effect
05:56:24 <ClaudiusMaximus> oliffea: alternatively, seeing as this is not just a haskell problem, you could use OS-level limits (limits.conf on linux, for example)
05:56:24 <sinelaw_> oliffea, if it's your program, then fixing the space leak is what you want anyway
05:56:24 <thang1> There's also a large difference between coding in Haskell and coding efficiently in Haskell. If you arent (somewhat) careful, it's not too difficult to accidentally be too liberal with Haskell's laziness and end up creating an incredibly large buffer as haskell "waits" to evaluate things
05:56:27 <breadmonster> thang1: How exactly do you do that?
05:56:30 <breadmonster> the IO monad?
05:56:48 <oliffea> sinelaw_: usually i find that my program has such a leak by running it, which then requires me to reboot my system, takin ~10 minutes
05:56:52 <oliffea> this is what i want to avoid
05:57:01 <thang1> Not just the IO monad, but you can code fairly imperatively in Haskell if you really feel like it...
05:57:08 <sinelaw_> yeah, that's a pain
05:57:24 <oliffea> ulimit would work perfectly, but it doesnt exist in cygwin :(
05:57:30 <breadmonster> thang1: Wow okay, I didn't know that. Any examples?
05:57:36 <thang1> You can write something like while :: (Monad m) => Bool -> m () -> m ()
05:57:47 <thang1> while cond action = do
05:57:53 <thang1> (tab) c <- cond
05:57:58 <thang1> (tab) if c
05:58:08 <thang1> (2x tab) then action >> while cond action
05:58:10 <thang1> else return ()
05:58:16 <breadmonster> I didn't get the last two.
05:58:17 <thang1> Boom, imperative style while loop
05:58:32 <breadmonster> Oh right that's a code block.
05:58:36 <thang1> http://stackoverflow.com/questions/6622524/why-is-haskell-sometimes-referred-to-as-best-imperative-language
05:58:42 <breadmonster> But that's also only limited to inside a monad.
05:58:43 <thang1> Should've just linked this, really
05:58:43 <nshepperd> I think you mean m Bool -> m () -> m ()
05:58:58 <nshepperd> all those things are in monad-loops though yeah
05:59:15 <thang1> Indeed I did. Forgot the m infront of Bool by mistake
05:59:17 <nshepperd> you can actually do everything IO like that
05:59:26 <nshepperd> and use IORefs for 'variables'
06:00:03 <thang1> 'do' notation also allows you to go pretty much full on imperi-tard if you abuse it enough
06:00:34 <nshepperd> (or ST/STRefs if you feel more sophisticated and don't want to be doing actual I/O)
06:01:46 <breadmonster> Can someone link me to a tutorial on IORefs/STRefs?
06:02:00 <breadmonster> Also, does Haskell have classes?
06:02:06 <thang1> http://www.amazon.com/The-Programming-Language-4th-Edition-ebook/dp/B00DUW4BMS
06:02:28 <thang1> All you'll ever need to know about I/O and variables :p
06:02:33 <breadmonster> lol
06:03:19 <wei2912> breadmonster: no, it isn't OO
06:03:30 <thang1> But really, though. IOrefs/STrefs are only useful if you are doing really performance sensitive code and you KNOW what you're doing
06:03:42 <thang1> Even then...
06:03:47 <wei2912> breadmonster: assuming you are talking about OO-style classes, not type classes
06:03:50 <wei2912> afaik
06:04:22 <breadmonster> wei2912: Yeah, OO style classes and inheritance and all taht.
06:04:25 <thang1> I wouldn't worry much about the dirtier side of Haskell until you actually need it for something you're programming
06:04:51 <thang1> breadmonster: OO is a paradigm of programming. It's a "style", a regulated approach to structuring your code
06:05:19 <thang1> Some languages have stuff built into them to make it easier to program in an "OO" way, but you can technically program in an "OO" style in damn near anything
06:05:22 <breadmonster> thang1: What about imperative and functional?
06:05:37 <breadmonster> thang1: How do you do inheritance in Haskell then?
06:05:44 <thang1> Those are overarching properties of languages
06:06:12 <HeladoDeBrownie> breadmonster, you generally don't, not the way you're talking about
06:06:12 <thang1> If a language is imperative, it executes instructions in order line by line. If a language is functional it executes instructions function by function (roughly speaking...)
06:06:39 <thang1> Those are properties of the language. it either IS functional or IS imperative or has properties of both
06:06:55 <breadmonster> HeladoDeBrownie: How do you do it in any way?
06:07:04 <thang1> Object Oriented programming is a way to structure your codebase to make it more manageable as it grows larger
06:07:25 <thang1> breadmonster: What HeladoDeBrownie means is that "inheritance" is simply a way to get something done in a language
06:07:27 <HeladoDeBrownie> breadmonster, on the other hand, some things you might need inheritance for in certain other languages, such as specifying behavior, come much easier in Haskell; e.g., a data type's field can be a function.
06:07:34 <thang1> That same objective can be achieved, but it's not through 'inheritance'
06:08:07 <tdammers> thang1: disagree on the "properties of a language" part
06:08:36 <thang1> It's early in the morning, I haven't slept for a while, I'm probably phrasing it badly... What do you disagree on?
06:08:38 <tdammers> functional vs. imperative is a matter of paradigm, and IMO this is first and foremost about how you *think* about programming problems
06:08:48 <thang1> I agree
06:08:53 <tdammers> JavaScript can be imperative, or functional, it's what you make of it
06:08:56 <prinsen> Im about to release a Haskell package. How should I go about setting the versions of my dependencies?
06:09:07 <prinsen> tdammers: Did you try the JS engine?
06:09:20 <tdammers> and ofc, some languages lend themselves better to one paradigm than another
06:09:21 <thang1> Haskell, howver, is fully functional. It's incredibly hard to actually make a mutable program in it, if not impossible sometimes
06:09:27 <tdammers> prinsen: which one? the ecma262 thing?
06:09:37 <prinsen> tdammers: yes
06:09:40 <tdammers> not yet
06:09:55 <thang1> So I would say being functional is a "property" of Haskell since it's literally built around it, while functional vs imperative is more of a paradigm with a language like C++ which allows both (to an extent)
06:09:59 <tdammers> thang1: depends how you look at it
06:10:03 <HeladoDeBrownie> thang1, I think that's a mischaracterization. You can mutate things easily in Haskell, but the mutation has to happen in a controlled environment, such as IO or ST.
06:10:19 <k00mi> thang1: that's not true, it's not hard to write imperative-style haskell
06:10:29 <tdammers> even without IO or ST, you can create "imperative islands" within a pure context
06:10:36 <thang1> You can mutate things easily, but I wouldn't say that imperative == mutation, but rather that imperative is a line by line execution of logic
06:10:50 <thang1> Plenty of mutable code in Haskell exists without necessairly being line-by-line logic execution
06:11:11 <thang1> I feel like we missed answering breadmonster's question, though
06:11:14 <tdammers> it's just sugar over a state monad, but then, FP on a real computer can be argued to be just sugar over imperative machine code...
06:11:15 <k00mi> prinsen: https://www.haskell.org/haskellwiki/Package_versioning_policy
06:11:47 <HeladoDeBrownie> breadmonster, I wouldn't worry about trying to do inheritance in Haskell. Haskell has other tools that are capable of solving the same sorts of problems as those you might solve that way in a more OO language. Have you read LYAH, by the way?
06:12:01 <breadmonster> HeladoDeBrownie: Yup, I have.
06:12:26 <thang1> What kinds of things would you see yourself doing with inheritance anyway, breadmonster?
06:12:52 <breadmonster> thang1: Nothing really, it's not something I "get"
06:14:20 <tdammers> frankly, I believe OOP itself has plenty of tools that solve those problems better than inheritance does
06:14:57 <tdammers> almost anything can be solved more elegantly by means of explicit interfaces and composition
06:16:33 <mada> m >>= f  = TardisT $ \ ~(bw, fw) -> do  -- What does '~' mean in that lambda's arguments?
06:18:18 <otulp> mada: Lazy pattern match.
06:18:22 <HeladoDeBrownie> mada, irrefutable pattern. It will match the constructor only when bw or fw need to be evaluated
06:18:32 <ClaudiusMaximus> mada: irrefutable pattern match (defers pattern match failure to when the contents are used) - tuples only have one constructor so can't fail to match, but the ~ defers the checking making the function more lazy
06:19:07 <mada> thank you (times 3)
06:19:45 <otulp> 2.2, I'd say. I used the wrong word. :)
06:20:36 * hackagebot system-canonicalpath 0.2.0.0 - Abstract data type for canonical paths with pretty operations  http://hackage.haskell.org/package/system-canonicalpath-0.2.0.0 (d12frosted)
06:23:47 <breadmonster> Guys, how do I get the CS underlying Haskell?
06:25:03 <sinelaw_> breadmonster, uh
06:26:24 <sinelaw_> breadmonster, which part of CS do you mean?
06:26:45 <breadmonster> Well, all the implementation things.
06:26:53 <breadmonster> and things like what a hylomorphism is.
06:27:02 <breadmonster> Something interesting that I just found out about today.
06:27:20 <sinelaw_> breadmonster, there are several different unrelated subjects  / theories
06:27:36 <breadmonster> Well, I have to start somewhere, right?
06:27:40 <sinelaw_> breadmonster, type theory is more CS-oriented, but there is also category theory (which is much further away from the code)
06:27:56 <HeladoDeBrownie> I think most Haskell users have no idea what a hylomorphism is
06:28:02 <sinelaw_> neither do I
06:28:11 <sinelaw_> but type theory is both interesting and useful to know
06:28:26 <breadmonster> Okay, is there a first CS book?
06:28:30 <sinelaw_> breadmonster, so one thing you can do is learn about type theory
06:28:35 <geekosaur> yes. most haskellers don't really bother with the underlying CS, just as most OOP programmers don't bother with the CS underlying OO (which there is quite a lot of)
06:28:37 <sinelaw_> breadmonster, Types and Programming Language
06:28:43 <sinelaw_> *s
06:28:47 * HeladoDeBrownie was about to suggest that book too
06:28:54 <sinelaw_> @where tapl
06:28:54 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:28:56 <breadmonster> geekosaur: I'm really interested in what Tsuru does.
06:30:24 <sinelaw_> breadmonster, TAPL is more than enough to start with
06:30:35 <sinelaw_> one of my favorite books
06:30:40 <breadmonster> sinelaw_ geekosaur: I wanted to learn Haskell after hearing about them.
06:31:01 <sinelaw_> breadmonster, I have no idea what both of those are.
06:31:52 <breadmonster> http://www.tsurucapital.com/en/
06:32:26 <breadmonster> sinelaw_: That.
06:32:45 <sinelaw_> ok.
06:32:48 <sinelaw_> that is not CS.
06:34:25 <hodapp> if it has "capital" at the end of the name, run away.
06:34:50 <breadmonster> hodapp: Why? :P
06:34:53 <breadmonster> Jane Street uses some pretty awesome CS.
06:34:54 <tdammers> hodapp: the older I get, the more red flags I see
06:35:05 <breadmonster> tdammers: Like what?
06:35:10 <hodapp> breadmonster: They're parasites.
06:35:17 <breadmonster> hodapp: How so?
06:35:53 <tdammers> breadmonster: dunno, it just gets increasingly hard to find a job ad that doesn't tell me "working there probably sucks big time"
06:35:56 <sinelaw> breadmonster, a lot of companies use "pretty awesome CS"
06:36:06 <breadmonster> tdammers: Hmm, okay.
06:36:13 <breadmonster> I'd really like to work for Jane Street though.
06:36:18 <sinelaw> so learn ocaml
06:36:38 <breadmonster> sinelaw: easier said than done, they take Haskell programmers too though.
06:36:42 <breadmonster> And Haskell is more beautiful.
06:36:49 <sinelaw> but they use ocaml.
06:37:20 <breadmonster> sinelaw: Is it going to be too hard to learn?
06:37:51 <sinelaw> no.
06:39:10 <pantsman> Facebook uses OCaml, and Haskell
06:39:50 <hodapp> breadmonster: Are they dominantly in the business of high-frequency trading?
06:40:07 <breadmonster> hodapp: Yup.
06:40:34 <wei2912> breadmonster: speaking of inheritance... i had a similar effect in https://github.com/wei2912/counter/blob/master/src/Data/Counter.hs
06:40:37 * hackagebot Allure 0.4.100.0 - Near-future Sci-Fi roguelike and tactical squad game  http://hackage.haskell.org/package/Allure-0.4.100.0 (MikolajKonarski)
06:41:03 <wei2912> breadmonster: though not exactly
06:41:09 <srenatus> I've seen some haskell in google cloud IIRC
06:43:21 <aleksanb_> is there an easy way to do function application when the number of arguments differ?
06:43:43 <aleksanb_> i have Int -> Int -> Bool, and Bool -> Int, but i can't use (.) as there are a different number of operands
06:43:59 <aleksanb_> I'm trying to convert True to 1, False to 0, as i couldn't find any default way to do it
06:44:28 <breadmonster> aleksanb_: if True then 1 else 0
06:44:40 <breadmonster> Though you don't typically want to do that.
06:44:43 <aleksanb_> yup, that part's okay
06:44:45 <aleksanb_> i did it with guards
06:45:02 <aleksanb_> I have a function that maps from Opcodes, returning a function that computes the same (Doing constant folding atm)
06:45:10 <aleksanb_> so opcode Plus would return (+)
06:45:15 <ClaudiusMaximus> > map fromEnum [False ..]
06:45:17 <lambdabot>  [0,1]
06:45:44 <aleksanb_> would that work when the other arguments are on the outside?
06:45:51 <aleksanb_> typ opcode(someOp) arg1 arg2
06:46:02 <aleksanb_> atm i'd like to return somehting like binaryToInt . (==)
06:46:44 <ClaudiusMaximus> @pl \a b -> fromEnum (a == b)
06:46:44 <lambdabot> (fromEnum .) . (==)
06:46:52 <aleksanb_> ah, now we're talking!
06:48:01 <aleksanb_> where are functions like fromEnum defined btw? I was googling quite a while for that :)
06:48:40 <ClaudiusMaximus> @index fromEnum
06:48:40 <lambdabot> Prelude
06:48:52 <ClaudiusMaximus> :t fromEnum
06:48:53 <lambdabot> Enum a => a -> Int
06:48:54 <aleksanb_> all those sweet ircbot tricks
06:49:33 <ClaudiusMaximus> it's part of the Enum class, which exists to make [a..b] syntax work
06:50:17 <aleksanb_> aha!
06:50:25 <aleksanb_> thanks mate
06:54:46 <c_wraith> I wonder how much real-world code would be broken by making the Enum instances for Double and Float actually sane.  I bet it's not much.
06:56:40 <tolt> c_wraith: Can you imagine debugging that though?
06:56:49 <c_wraith> iy'
06:57:01 <athan> what packages actually use the instances?
06:57:10 <c_wraith> err, hand in the wrong spot.  It'd be pretty easy, with the instances I have in mind. :P
06:57:11 <Ferdirand> what's insane about them ? (just curious)
06:57:22 <athan> like... javascript math insane?
06:57:23 <c_wraith> They don't actually enumerate values in the type!
06:58:46 <c_wraith> I want the instances to return consecutive elements in the type.  that is, [0..1] :: Double would have... uh...  very large number...  of values.
06:58:58 <c_wraith> Too many to iterate, really.
06:59:01 <Ferdirand> ah, in that sense
06:59:14 <c_wraith> Trust me, no one would miss that change
06:59:25 <c_wraith> But even as it stands..
06:59:27 <Ferdirand> yes, that doesn't sound immensely useful
06:59:47 <c_wraith> Actually, it'd make pred and succ quite useful
06:59:55 <c_wraith> But comprehensions wouldn't be so useful
07:00:13 <hodapp> athan: what's insane about JavaScript math?
07:00:30 * hodapp ponders whether he should have a drink in his hand when asking this
07:00:33 <athan> hodapp: floats are weird
07:00:38 * hackagebot markup 0.0.2 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.2 (athanclark)
07:00:39 <athan> hahaha
07:00:44 <hodapp> athan: and everything is floats, right?
07:00:52 <c_wraith> But almost every time you want to do a comprehension over floating-point values, you really shouldn't anyway.  Much better to have the comprehension be over an integral type, then map a division
07:01:06 <athan> hodapp: http://stackoverflow.com/questions/588004/is-floating-point-math-broken
07:01:22 <c_wraith> athan: what's that got to do with js?
07:01:26 <athan> c_wraith: That sounds awesome
07:01:33 <athan> c_wraith: EVERYTHING
07:01:41 <hodapp> athan: I thought rule 1 of Float Club was you DO NOT compare Floats?
07:01:56 <c_wraith> athan: isn't that just floating-point math?  what's js got to do with it?
07:02:29 <c_wraith> Oh, it's that js only has one numerical type, and you might always accidentally be working with floats.
07:04:42 <Kinnison> hodapp: You don't compare them for equality certainly
07:05:37 <c_wraith> I compare floats for equality all the time.  But when I do so, it's because I know exactly what I'm doing.  They're not random - the behavior is well-specified.
07:05:45 <Kinnison> heh
07:09:18 <c_wraith> > 1 + 2 == (3 :: Double)
07:09:20 <lambdabot>  True
07:09:28 <c_wraith> That'll always be True!
07:10:01 <c_wraith> Just..  not if you distribute a (* 0.1) through all the arguments first. :)
07:10:19 <c_wraith> though if you distribute a (* 0.5) through all the arguments, it'll stay true.
07:11:48 <c_wraith> It's just a matter of know how the underlying representation works, and what operations induce error. :)
07:15:39 * hackagebot relational-query 0.0.1.3 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.3 (KeiHibino)
07:15:41 * hackagebot plist 0.0.5 - Generate and parse Mac OS X property list format  http://hackage.haskell.org/package/plist-0.0.5 (YurasShumovich)
07:20:02 <tolt> I'm having trouble finding the difference between using "instance Class SomeType" vs "instance Class SomeType where" for deriving an instance
07:20:21 <athan> tolt: It depends on how much you have to define
07:20:39 <athan> if the instance can be inherited from a superclass, or if the typeclass is empty, then you don't need a `where`
07:21:04 <athan> > class Foo a; instance Foo Int
07:21:05 <lambdabot>  <hint>:1:1: parse error on input ‘class’
07:21:07 <athan> :(
07:21:16 <athan> I don't think lambdabot handles typeclasses
07:21:21 <tolt> That makes sense.
07:23:10 <tolt> Thanks athan
07:23:25 <athan> tolt: No problem :) feel free to bug me if you have issues
07:23:51 <tolt> I've just never looked into the difference because I've never ran in to the issue
07:25:47 <athan> tolt: There's also standalonederiving instances, which look like `deriving instance Foo a => Foo (b a)`
07:40:05 <nerium> Is there a way to print an arbitrary value in haskell before returning ut?
07:40:50 <ClaudiusMaximus> nerium: for debugging there is traceShow, otherwise there is print
07:42:08 <nerium> ClaudiusMaximus: Thanks, that worked!
07:43:46 <nerium> Is there an online (or build in) beautifyer for haskell?
07:43:50 <nerium> I need to format some code
07:44:12 <osa1> I'm pretty sure QuickCheck's `within` is broken
07:44:42 <ClaudiusMaximus> nerium: lhs2Tex, hscolour
07:45:22 <nerium> ClaudiusMaximus: I'll have a look
07:45:46 <nerium> ClaudiusMaximus: Is there any online tools for this?
07:45:59 <osa1> I have a quickcheck test with `within 100` and it's running since minutes
07:46:36 <ClaudiusMaximus> i think lpaste uses hscolour (or something equivalent), you might be able to copy/paste the html but it isn't designed for it
07:47:45 <ClaudiusMaximus> osa1: you're probably running into a GHC issue where non-allocating loops can't be interrupted - i think the suggested fix is compiling with -fno-omit-yield or so
07:48:17 <nerium> ClaudiusMaximus: It looks like it only added color http://lpaste.net/2943125489180475392
07:48:26 <osa1> ClaudiusMaximus: interesting. let me try that.
07:49:02 <ClaudiusMaximus> nerium: oh, you want pretty-printing, not formatting
07:49:14 <nerium> ClaudiusMaximus: Yeah, sorry missed that detail
07:49:30 <osa1> ClaudiusMaximus: is there an open issue about this?
07:50:08 <osa1> ClaudiusMaximus: I installed my app with `cabal install --enable-tests --ghc-options=-fno-omit-yields` but it still takes forever
07:50:13 <osa1> I don't think it worked
07:50:26 <osa1> do I need to cabal clean first?
07:50:45 <ClaudiusMaximus> nerium: you might be able to knock something together using http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Pretty.html
07:51:15 <nerium> I'll have a look
07:51:40 <indiagreen> nerium: https://github.com/chrisdone/hindent
07:52:23 <ClaudiusMaximus> osa1: https://ghc.haskell.org/trac/ghc/ticket/367
07:53:08 <statusfailed> hm. I want to map types to values, but I can't declare a class "data Value = A | B; class HasValue t where value :: Value"
07:53:14 <statusfailed> There's probably a better way, but what it is?
07:54:10 <statusfailed> what is it*
07:54:28 <sinelaw> I'm running ghc with -ddump-simpl, but no output is printed.
07:54:49 <sinelaw> like so, what am I doing wrong here? $ ghc -ddump-simpl -O simple.hs
07:55:48 <sinelaw> oh ok, existing file prevented a new build. never mind.
07:58:16 <nerium> indiagreen: I got a lot of error trying to install that
07:58:22 <nerium> I think I need an online tool
08:00:00 <osa1> ClaudiusMaximus: I'm having this problem even if I compile without -threaded
08:00:15 <nerium> hehe, I manage to use jsonlint.com
08:01:36 <ClaudiusMaximus> osa1: you need to compile the loop with -fno-omit-yields, if the loop is compiled already (in a library) then it won't help
08:02:07 <ClaudiusMaximus> osa1: in the worst case you might need to recompile ghc/base/etc
08:02:56 <osa1> ClaudiusMaximus: wait I just cabal clean && cabal installed and I think it works when I omit -threaded
08:02:59 <ClaudiusMaximus> osa1: it's a 10-year-old issue, with a partial workaround, i wouldn't expect a complete fix any time soon
08:03:00 <osa1> yep, it works
08:03:04 <ClaudiusMaximus> osa1: cool!
08:03:10 <osa1> seriously, this is awful
08:05:40 * hackagebot ekg-bosun 1.0.3 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.3 (OliverCharles)
08:05:42 * hackagebot relational-query 0.0.1.4 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.4 (KeiHibino)
08:13:28 <ywfn> HI everyone, I was wondering is there a way to use Hspecs shouldSatisfy with a predicate that returns IO(Bool)
08:15:24 <saep> ywfn: predicate `shouldReturn` True
08:16:32 <ywfn> Thanks saep;
08:16:57 <ywfn> That didn't occur to me. Thanks again!
08:20:40 <mizu_no_oto> Does anyone know of some really cool uses of phantom types?  Something that most people probably haven't seen, at any rate.
08:20:41 * hackagebot linear 1.15.5 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.5 (EricMertens)
08:22:11 <dfeuer> mizu_no_oto, there's a paper called "Fun with Phantom Types".
08:22:23 <dfeuer> You could start there.
08:33:33 <albeit> @pl \x -> if (x==123) then Nothing else Just x
08:33:33 <lambdabot> ap (flip if' Nothing . (123 ==)) Just
08:34:00 <Denommus`> damn
08:34:45 <Denommus`> ghc-mod on Stackage is either broken or I don't know how to properly use it
08:34:49 <exio4> @pl \x -> Nothing (Just x) (x==123)
08:34:49 <lambdabot> liftM2 Nothing Just (123 ==)
08:34:54 <Denommus`> trying to run ghc-mod boot gives me /home/<user>/Projetos/SpellChat/dist/setup-config: hGetContents: invalid argument (invalid byte sequence)
08:34:59 <exio4> er, whatever
08:35:42 <dfeuer> exio4, that's a type error.
08:35:48 <dfeuer> @pl type error
08:35:48 <lambdabot> type error
08:35:57 <merijn> Denommus`: What is your locale?
08:35:57 <dfeuer> See?
08:36:20 <merijn> Denommus`: hGetContents attempts to decode based on locale, which is wrong for haskell source, since haskell source must always be utf-8
08:36:28 <Denommus`> merijn: pt_BR.UTF-8
08:36:59 <Denommus`> merijn: so, what would be a way of solving it?
08:38:05 <merijn> Denommus`: I recommend checking whether all of LANG, LC_ALL and LC_CTYPE are set correctly and verifying the haskell source is indeed utf-8. If that's all done and it still doesn't work, then you need more debugging brainpower than I have after waking up at 6am
08:38:18 <exio4> dfeuer, yeah
08:38:23 <exio4> @pl \x -> bool Nothing (Just x) (x==123)
08:38:24 <lambdabot> ap (bool Nothing . Just) (123 ==)
08:38:31 <Denommus`> merijn: only LANG is set in my /etc/locale.conf
08:38:40 <exio4> :t ap (bool Nothing . Just) (123 ==)
08:38:41 <lambdabot> (Num a, Eq a) => a -> Maybe a
08:39:33 <merijn> Denommus`: Try setting LC_ALL="pt_BR.UTF-8" and "LC_CTYPE=UTF-8"
08:41:48 <Denommus`> merijn: do I need to restart my session, or just open a new terminal?
08:43:14 <merijn> Denommus`: I think opening a new terminal should be sufficient, but you can check by typing "export" in your shell (assuming you're using something bourne shell-like) and it should dump all environment variables including those
08:43:36 <prinsen> Is it horrible to use a unallocated top level name? I have a package that implements the YQL engine, which doesn't really fit anywhere
08:44:04 <Denommus`> merijn: there's the locale command, and it doesn't show any changes
08:44:52 <Denommus`> well, it seems I'll have to reboot
08:44:53 <merijn> prinsen: No
08:45:00 <merijn> prinsen: In fact, I strongly advocate doing so
08:45:16 <merijn> prinsen: As long as you don't squat so me generic name
08:46:16 <merijn> prinsen: Take a look at, for example, pipes which just puts everything under Pipes.X instead of this silly Control.KitchenSink.Yay.Nested.Modules
08:46:40 <prinsen> merijn: cool
08:48:29 <merijn> prinsen: You should probably not take something like "Windows", "Files", or similarly generic, but put everything under FooYQL or whatever name you pick for your library should be fine
08:49:33 <prinsen> merijn: You wouldn't like to try out my package suit? First contribution to hackage
08:49:55 <prinsen> I have uploaded them as candidates for now
08:56:27 <mmachenry> Does anyone know how to make an installation process from a cabal-based project that will do things like install my program to /usr/bin, put config files in /etc/, and create sym links in /etc/init.d ?
08:56:57 <mmachenry> I've found cabal-rpm but there's really no mention of performing the extra actions I just mentioned.
08:57:02 <prinsen> There seem to be a bug in cabal, in extra-source-files, apis/foo/*.json doesn't find apis/foo/a.b.json
08:57:08 <merijn> mmachenry: cabal isn't intended for that sorta thing, you should probably use whatever package manager your OS has
08:58:18 <mmachenry> merijn: Ah, I was hoping to find some way to write these things into my Setup.hs. That's not going to be a good path?
08:59:25 <chpatrick> is there any kosher way to do defaulting?
08:59:52 <chpatrick> specifically I'd like if I have "MyClass a => a", then use "MyFastImpl"
09:00:22 <merijn> chpatrick: Why not explicitly specify that?
09:01:34 <chpatrick> so I have two implementations with the same semantics
09:01:46 <chpatrick> ideally you wouldn't have to worry which one is being used
09:02:41 <Kaidelong> GHC has a built in mechanism like this, but I don't think it is extensible
09:02:55 <chpatrick> yeah
09:03:01 <chpatrick> and I don't think it's considered kosher
09:03:24 <Kaidelong> I guess the question then becomes, what are you using overloading for?
09:03:35 <Kaidelong> you could use a default parameter instead
09:03:41 <Kaidelong> with a record of overloadable functions
09:04:25 <Kaidelong> https://www.haskell.org/haskellwiki/Implicit_parameters
09:04:54 <Kaidelong> then MyFastImpl is a record that a caller can modify with a record expression if they want to change its behavior
09:06:07 <Kaidelong> I'm not aware of much use of this language extension in the wild but I'm not sure it's considered un-idiomatic and it may be better than polluting the global namespace that typeclass instances hang around in
09:06:37 <Chath> What, I never knew implicits params exists
09:06:40 <Chath> *existed
09:08:27 <Kaidelong> if you absolutely must use a type class consider using iso from Data.Lens to make working with this approach to overloading better
09:08:31 <merijn> Chath: They're not all that useful in practice
09:08:52 <marcoloporto_> ciao
09:09:06 <Kaidelong> essentially if there isn't one obviously correct implementation for your type then typeclasses may not be the appropriate thing to use to handle it
09:09:51 <Kaidelong> Oh wait, I got off track
09:09:58 <marcoloporto_> ciao
09:10:04 <Kaidelong> the real question is about how to default in a monomorphic way
09:10:19 <marcoloporto_> ciao
09:10:42 <Kaidelong> I guess implicitparams would not help there either
09:11:00 <Kaidelong> I guess the best you can do is this:
09:11:06 <Kaidelong> @ty asTypeOf
09:11:07 <lambdabot> a -> a -> a
09:11:24 <Kaidelong> IE, no way to do it implicitly
09:16:49 <tbo`> hi, i'm creating a program using multi threads. i can't decide to use which, MVar (HashMap Key Obj) or MVar (HashMap Key (MVar Obj)). Obj will be rewritten frequently by many threads. Which is more efficient? or is there other answer?
09:17:58 <tnks> dibblego: a while ago I remember you talking about how you got little value out of arrows.
09:18:12 <tnks> did I misunderstand?
09:18:35 <tnks> it's not like arrows are lawless, right?
09:18:56 <tnks> (anyone else, feel free to answer as well)
09:20:05 <merijn> tnks: They're not lawless, but generally not considered all that useful
09:20:28 <merijn> Since you can replace Arrow with Applicative + Category, both of which are more useful
09:21:07 <tnks> knyon: you catching this?
09:21:11 <albeit> If I have an 8-core machine, and I run two separate Haskell processes that use 4 cores each - will they use different cores? Will one process ever be affect by the other process pausing cores for GC?
09:21:28 <knyon> tnks: yeah
09:21:41 <merijn> albeit: "it depends"
09:22:08 <merijn> albeit: GC will never affect other programs
09:22:26 <merijn> albeit: But there's no guarantee two processes won't end up using the same cores and interfering
09:23:04 <albeit> merijn: And by interfering you mean just sharing the processing power of that core, possibly to the detriment of one process's performance?
09:23:27 <merijn> Right
09:23:41 <albeit> Cool, thanks!
09:24:31 <merijn> albeit: Although, obviously the OS scheduler will attempt to minimise interference
09:24:57 <merijn> So 2 times 4 threads on an 8 core system should have minimal interference
09:30:44 * hackagebot yackage 0.7.0.5 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0.5 (MichaelSnoyman)
09:39:19 <Athas> How can I figure out whether my GHC was built with libcharset or langinfo.h support?
09:39:40 <mmachenry> I am creating a release process for my production systems team to follow. I find the instructions I wrote complicated. Is there anyway to simplify what I've done here by using existing tools? http://lpaste.net/116259
09:39:41 <Athas> GHC.IO.Encoding.Iconv.localeEncodingName gives me unexpected results, and I'm trying to figure out why.
09:41:46 <athan_> Anyone know what I'm doing wrong? http://stackoverflow.com/questions/27428945/linked-cabal-sandboxes-shared-libraries-not-found-from-cabal-repl
09:48:04 <Denommus> merijn: I ended up breaking my locale with all the changes and reverted to the single line. Couldn't manage to get ghc-mod to work
09:50:20 <ReinH> mmachenry: Well, you're making some assumptions here, like the developer's machines compiling an exec-compatible binary format to the deployment machines
09:50:51 <ReinH> mmachenry: If I were you, I would use a build system like Jenkins to automate the delivery of the RPMs
09:52:21 <mmachenry> ReinH: Thanks. I have considered and tested to ensure the compiled binaries work on the production machine.
09:52:30 <mmachenry> Let me take a look at Jenkins
09:52:39 <ReinH> mmachenry: Right, but you're locking your developers into a particular machine architecture
09:53:25 <ReinH> And in any event having any developer randomly compile, build and deliver an RPM from their development machine is not a reliable, repeatable, auditable, traceable process
09:53:38 <mmachenry> ReinH: Yep, that will always be the case. We all develop on a set of machines that are all binary compatible with the production machines.
09:54:02 <ReinH> mmachenry: I would never allow my developers to build and push a deliverable themselves.
09:54:35 <mmachenry> ReniH: Only the prod-sys team can install to production and this is their specific instructions to build on the dev boxes, which are compatible with production.
09:54:59 <ReinH> mmachenry: (FWIW part my job is building managing the continuous integration, delivery, and deployment processes for our Haskell services)
09:55:09 <ReinH> s/building/building and
09:55:27 <mmachenry> ReinH: Developers won't be following these instructions and if they develop on different machines, and check in code, and as long as release engineering likes it, it'll check in.
09:55:39 <mmachenry> ReinH: Do you see issues with this?
09:55:44 <ReinH> Checking in code is fine.
09:56:05 <ReinH> I'm talking about how the system is delivered to production.
09:56:20 <fragamus> ReinH: Do you work at FP Complete
09:56:25 <ReinH> fragamus: I don't.
09:57:14 <mmachenry> ReinH: What's the issue you see?
09:57:51 <mmachenry> Only one team is deploying to production and they are instructed to run this process above on an off-line build system that mirrors production before it's installed there.
09:57:52 <ReinH> mmachenry: Any manual process will have user errors, and developers don't generally have skin in the "this had better work in production or I'll be awake at 2am" game.
09:58:38 <mmachenry> ReinH: But developers can only check in code.
09:59:04 <ReinH> mmachenry: Your lpaste describes a process for "development machines" that includes "Create an RPM".
09:59:09 <ReinH> So I guess I am confused.
09:59:45 <mmachenry> There are production mirror machines called development machines.
09:59:51 <ReinH> Oh.
10:00:07 <mmachenry> All my developers are required to test and run their code on these systems before it's checked in.
10:00:33 <ReinH> We push code to pull requests where it is built and tested
10:00:34 <mmachenry> Also the release engineering team does some regression tests and ensures basic properties.
10:00:45 * hackagebot lmdb 0.2.1 - Lightning MDB bindings  http://hackage.haskell.org/package/lmdb-0.2.1 (dmbarbour)
10:01:13 <mmachenry> Then the prod-sys team will run this process I wrote on one of the development machines (which mirror production) and then install an RPM to production once it's made
10:01:46 <mmachenry> ReinH: That'a basically what's happening. What I wrote is the instructions of what to do after it's been pulled.
10:02:05 <mmachenry> But we're not logging in to production to run the compiler.
10:02:17 <maukem> http://devopsreactions.tumblr.com/post/104833538121/deploying-staging-cookbook-to-production
10:02:17 <ReinH> Ok, so you can check in code before it's run on these systems.
10:02:19 <mmachenry> We have a compiler on an off-line system
10:02:28 <mmachenry> ReinH: Yes
10:02:41 <ReinH> maukem: heh
10:03:41 <ReinH> I mean, if you just write a little shell script to automate the RPM creation process, that would help
10:04:20 <pavonia> Hi! I'm compiling a Gtk GUI program with LD-Options -mwindows, so that the final binary doesn't start with an extra console window on Windows. The problem is, when my program quits, it crashes with an error message "<stdout>: hPutChar: invalid argument (Bad file descriptor)". How can this error be resolved?
10:04:22 <mmachenry> ReinH: I didn't want to write to the user's .bashrc
10:04:34 <ReinH> No, just to create the RPM
10:04:46 <mmachenry> Oh
10:05:22 <pavonia> The weird thing is, if I compile it without that flag, there isn't any console output (at leats not visibly)
10:06:37 <ReinH> mmachenry: The thing I'm confused about is: you describe a process for a "development machine", and then go on to talk about the user's .bashrc, which made me assume a "development machine" was, well, a developer's machine.
10:08:26 <Denommus`> ok, my problem with ghc-mod seems to be the cabal version, according to stack overflow
10:12:01 <hodapp> Hmm, if a type check fails with "no instance for..." should I take this to mean specifically that some argument violates a typeclass constraint in some way?
10:13:15 <mmachenry> ReinH: No the development machines are servers we all log into
10:13:45 <ReinH> mmachenry: I get that now. But then why would someone be upgrading cabal, and why would you care about whether you write to a .bashrc file if it's on a machine you control?
10:13:50 <mmachenry> Development machine = Oracle Linux. Production machine = same, developer's machine = I don't know Mac OS?
10:14:11 <ReinH> The development machine should be managed, so cabal should already be upgraded to whatever version is required.
10:14:53 <mmachenry> ReinH: Good question. I always just install haskell-platform which comes with an old cabal-install and then I upgrade cabal install with cabal itself. Which only does this for one user.
10:15:13 <mmachenry> Perhaps I should get the prod sys team to permanently upgrade cabal across the whole machine.
10:15:15 <ReinH> Why do you need multiple users?
10:15:33 <mmachenry> Well anyone in prod-sys might do this for us when we release code.
10:15:46 <ReinH> But anyone can ssh in as a single deployment user.
10:16:14 <mmachenry> Well yeah, but only like 5 people can actually take the binary them build and put it into production.
10:16:43 <ReinH> And any of them can ssh deploy@whatever or whatever
10:16:50 <ReinH> Or you can manage it per-user
10:16:52 <c_wraith> hodapp: not exactly.  The return value could, too.
10:16:59 <ReinH> With something like puppet, chef, ansible, etc
10:17:04 <c_wraith> > read "" :: (Int -> Int) -- hodapp
10:17:05 <lambdabot>  No instance for (GHC.Read.Read (GHC.Types.Int -> GHC.Types.Int))
10:17:05 <lambdabot>    arising from a use of ‘Text.Read.read’
10:17:38 <mmachenry> ReinH: I'm sorry, I'm not following.
10:17:49 <mmachenry> We do use puppet on the production servers.
10:18:07 <ReinH> mmachenry: Then you can use it on the development servers to ensure that cabal is installed to the correct version for all 5 of those users
10:18:21 <ReinH> puppet can also manage their .bashrc files
10:18:26 <mmachenry> On a related note, how can I update cabal to 1.20 for all users permanently using cabal install cabal-install as root?
10:18:58 <ReinH> mmachenry: replace the binary that all the users are using, or put one where all users can access it (like /usr/local/bin)
10:18:59 <mmachenry> ReinH: That sounds like a good idea.
10:19:48 <mmachenry> So have root "cp ~mmachenry/.cabal/bin/cabal /usr/bin" ?
10:20:07 <mmachenry> that sounds a little unstructured. I guess have puppet ensure that's always happening
10:20:30 <ReinH> When I say "you" I don't literally mean mmachenry. I mean your config management system.
10:21:13 <ReinH> Everything on those machines should be managed via puppet. That way you have a consistent configuration that is self-documenting and repeatable.
10:22:13 <ReinH> mmachenry: Anyway, perhaps we should take this to #haskell-blah
10:22:29 <mmachenry> Oh sure.
10:22:57 <mmachenry> Also thanks for the help. I am pretty unaware of this kind of stuff.
10:24:22 <mmachenry> ReinH: Were you interested in continuing that now? I am in #haskell-blah if you still have time.
10:29:30 <hodapp> ugh, calling into things from Ivory would be a lot easier if this SDK didn't use bullshit typedefs everywhere.
10:34:11 * chrisdone pats hodapp on the shoulder
10:38:02 <hodapp> oh well, if I can just figure out how to do one opaque pointer, I should be able to reproduce this throughout
10:38:16 <hodapp> also, how do I enable languages features (e.g. DataKinds) in GHCi?
10:38:43 <hodapp> nevermind, think I just found it
10:38:58 <chrisdone> :set -XFoo
10:39:58 <hodapp> hmmm, it is still complaining at me that maybe I meant DataKinds
10:42:44 <chrisdone> you're  writing :set -XDataKinds ?
10:46:34 <pavonia> Okay, there actually was some output because of a file writing error ... so follow-up question: How can I prevent any data from being written to stdout?
10:47:31 <chrisdone> you can redirect the output of stdout
10:47:38 <renxx__> is there a way to combine two binary functions into 4 quaternary function
10:47:40 <chrisdone> but it's kinda icky
10:47:48 <renxx__> is there a way to combine two binary functions into 1 quaternary function
10:48:23 <pavonia> chrisdone: Any hint where to look at?
10:48:59 <chrisdone> yeah, um
10:49:28 <athan_> renxx__: depends on the types and if you can reuse one of the 2-ary functions
10:50:06 <chrisdone> pavonia: there's dup2 support in base somewhere
10:50:53 <chrisdone> http://hackage.haskell.org/package/base-4.3.0.0/docs/GHC-IO-Handle.html#v:hDuplicateTo
10:51:12 <athan_> renxx__: `foo :: A -> B -> C`, `bar :: B -> C -> D`, `\a b c (d :: B) -> bar b (bar b c) (foo a b)` ?
10:51:28 <chrisdone> and hDuplicate
10:52:13 <pavonia> Duplicate meaning it is redirected?
10:52:58 <chrisdone> pavonia: see example here http://stackoverflow.com/a/9449800/89574
10:53:22 <pavonia> Ah, thank you
10:53:54 <hodapp> this is probably an issue largely of documentation, but I am finding Ivory a total maze to navigate, when it comes to a practical matter of 'I have something of type X, and I need to get it either composed or compatible with type Y'
10:55:05 <chrisdone> pavonia: the docs are pretty poor, but the dup2 man page is better
10:55:59 <chrisdone> pavonia: “If the descriptor newfd was previously open, it is silently closed before being reused.”
10:56:45 <chrisdone> pavonia: iow, stdout is closed and re-used, where it and oldfd (your first Handle) can be used interchangeably
10:57:35 <chrisdone> hodapp: you mean navigating Ivory's codebase?
10:58:25 <pavonia> I'm looking at the silently package atm, looks like nice interface to what I want
10:58:53 <hodapp> chrisdone: Not really navigating the codebase, just trying to figure out how to practically use it.
10:59:00 <chrisdone> pavonia: yeah, silently uses duplicateTo underneath
10:59:38 <chrisdone> hodapp: there's at least :browse in ghci
10:59:51 <chrisdone> hodapp: you could generate haddocks for the package?
10:59:59 <hodapp> chrisdone: I am looking at the docs presently.
11:00:47 <hodapp> I see that MemArea is "Externally defined memory areas." and a Ref is a "Non-null reference", but I cannot find any sort of notion of which I should be using when all I want is a pointer to some externally-defined C symbol, or how to achieve that.
11:03:27 <hodapp> types and terse descriptions are sort of half-documentation, half-maze here.
11:08:24 <moop> how do i become master at haskells
11:09:59 <pecanpy> moop: the only way is too eat well and exercise
11:10:04 <dfeuer> What are the chances of ScopedTypeVariables making it into the next Report?
11:10:34 <xplat> the lowdown on unethical gummy candies: gumdrops/spearmint leaves/orange slices are usually mainly safe, since they are made with corn starch (cheap) or pectin (deluxe).
11:10:41 <sivteck> same as the possibility of the next Report.
11:10:42 <xplat> oop, wrong channel
11:15:48 * hackagebot quickcheck-unicode 1.0.0.0 - Generator and shrink functions for testing  Unicode-related software.  http://hackage.haskell.org/package/quickcheck-unicode-1.0.0.0 (BryanOSullivan)
11:51:08 <stephen_> Is anyone from Galois online at the moment?
11:55:50 * hackagebot text 1.2.0.2 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.0.2 (BryanOSullivan)
11:59:10 <sm> g'day all
12:00:03 <sm> what's a concise way to get the first Just from a sequence of maybes ?
12:01:36 <zomg> you could use `head . catMaybes`
12:02:00 <zomg> although it would cause an error if there are zero Justs, so if that's a possibility, you'd need to check the length of the result from catMaybes
12:02:21 <pavonia> > listToMaybe $ catMaybes [Nothing, Just 1, Nothing]
12:02:22 <lambdabot>  Just 1
12:02:28 <pavonia> > listToMaybe $ catMaybes [Nothing, Nothing, Nothing]
12:02:29 <lambdabot>  Nothing
12:02:50 <zomg> Oh that one is better =)
12:03:09 <zomg> forgot that listToMaybe behaved like that
12:04:44 <wasteland> hi , newbie question...
12:06:56 <Iceland_jack> wasteland: Ask away
12:07:13 <sm> pavonia:, zomg: thanks!
12:07:15 <wasteland> when i open some apple like firefox, I don't see a menu bar at the top: “File Edit View ..." how can I enable the menu bar ?
12:07:33 <pecanpy> say whaaaat
12:08:17 <Iceland_jack> wasteland: Not really a Haskell question, but you should be able to right click some empty space around there and you should get an item "_Menu bar"
12:08:22 <Iceland_jack> *Bar
12:10:50 * hackagebot aws-kinesis-reshard 0.1.0.0 - Reshard AWS Kinesis streams in response to Cloud Watch metrics  http://hackage.haskell.org/package/aws-kinesis-reshard-0.1.0.0 (JonSterling)
12:11:24 <dfeuer> What are the chances of a new Haskell Report next year with ScopedTypeVariables, BangPatterns, and AMP?
12:12:25 <xplat> 13%, with scattered showers in the evening
12:12:44 <wasteland> Iceland_jack: thx, gonna check ...
12:15:11 <geekosaur> dfeuer, I suspect they'll want AMP to playtest a bit
12:16:41 <dfeuer> geekosaur, really? I thought that was pretty uncontroversial as a concept.
12:17:05 <geekosaur> yes, but the committee has trouble with large changes >.>
12:17:21 <geekosaur> for that matter I suspect they'd be terrified of ScopedTypeVariables breaking something
12:17:29 <geekosaur> if made default
12:18:03 <geekosaur> right thing to do there is convince ghc hq to make it default in 7.12 (too late for 7.10) and see what happens, before proposing it as a language change
12:20:51 * hackagebot aws 0.11 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.11 (AristidBreitkreuz)
12:27:10 <jrc12> I had a question with regard to recursion schemes.
12:27:15 <jrc12> :t para
12:27:15 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
12:27:37 <jrc12> Data.Functor.para
12:27:40 <jrc12> :t Data.Functor.para
12:27:41 <lambdabot> Not in scope: ‘Data.Functor.para’
12:28:00 <jrc12> :t Data.Functor.Foldable.para
12:28:00 <geekosaur> Plated constraint doesn't sund like Data.Functor
12:28:00 <lambdabot> Not in scope: ‘Data.Functor.Foldable.para’
12:28:21 <jrc12> :t Data.Functor.Foldable.para
12:28:22 <lambdabot> Not in scope: ‘Data.Functor.Foldable.para’
12:28:23 <geekosaur> Control,Lens.plated maybe?
12:28:30 <geekosaur> er
12:28:36 <geekosaur> Control,Lens.Plated.para maybe?
12:28:52 <jrc12> Nope from Data.Functor.Foldable
12:29:14 <jrc12> https://hackage.haskell.org/package/recursion-schemes-0.2/docs/Data-Functor-Foldable.html
12:29:17 <bennofs> jrc12: What's your question?
12:30:07 <geekosaur> lambdabot's not going to know anything about that package
12:30:51 * hackagebot mustache-haskell 0.1.0.5 - Straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.5 (DanielChoi)
12:31:35 <jrc12> When I run para with the Base [a] as the base functor and the function I give it simply pairs the list and the associated value at that point, the associated list lacks the first element
12:32:53 <jrc12> Wait, I'll make a paste to make it more clear
12:33:15 <bennofs> jrc12: I think the associated list represents the "rest" of the structure at any point
12:33:26 <bennofs> jrc12: the "rest" is the current tail (which was already processed)
12:37:58 <jrc12> http://lpaste.net/116269
12:39:07 <jrc12> bennofs: Agreed for the case of the list. But if I do the same thing on a tree, the context seems to be the entire rooted at that point and not the rest (not sure what that would be).
12:39:22 <bennofs> jrc12: what version of recursion-schemes do you use?
12:39:43 <jrc12> bennofs: uhm not sure how to verify :P
12:39:51 <bennofs> jrc12: ghc-pkg list recursion-sche,es
12:39:57 <bennofs> s/,/m
12:40:17 <jrc12> 4.1
12:42:49 <bennofs> jrc12: oh, then you're hit by this bug: https://github.com/ekmett/recursion-schemes/issues/new
12:42:56 <bennofs> oops
12:43:39 <bennofs> jrc12: https://github.com/ekmett/recursion-schemes/pull/9 i meant
12:44:23 <jrc12> bennofs: 4.1
12:44:45 <bennofs> jrc12: seems the fix wasn't released on hackage yet
12:45:07 <bennofs> jrc12: it's a bug. para for trees should behave like in the list case
12:45:23 <jrc12> ahh.. ok. So what would the rest of a tree be?
12:47:03 <bennofs> jrc12: in NodeF b a b, the first field would be the left child of the current node, while the second field would be the right one
12:47:05 <jrc12> wait never mind. Figure it out
12:47:26 <jrc12> bennofs: Thanks
12:48:35 <elfeck> why is :t fin not [[a]] -> Maybe [a] ?
12:48:35 <elfeck> let s = fromList [1,2,3]let f = (+)
12:48:35 <elfeck> *Main> let fin = find ((toList s) `elem`)
12:48:35 <elfeck> *Main> :t fin
12:48:46 <elfeck> shit sorry formatting
12:49:07 <EvanR> :t find
12:49:08 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:50:09 <elfeck> ((toList s) `elem`) should be [[a]] -> bool correct?
12:52:00 <geekosaur> elfeck, at a guess you have the monomorphism restriction enabled
12:52:26 <ReinH> Try giving it an explicit type annotation
12:53:30 <elfeck> okay will try
12:56:30 <dfeuer> geekosaur, ScopedTypeVariables won't be default in GHC unless it's in the Report, I don't think. Adding it to the Report can't break currently-compliant code unless that code uses the name `forall`, which is probably not too common.
12:57:20 <geekosaur> mm, in the past it's always been the other way around, the committee won't consider it unless ghc has play-tested it
12:57:39 <dfeuer> I'm not sure what play-tested means.
12:57:41 <geekosaur> in at least one actual release
12:58:00 <dfeuer> Hrrmm
12:58:14 <geekosaur> they want real world usage to back up any proposed change
12:58:28 <geekosaur> which in practice means it goes into ghc first, in at least one public release
12:58:53 <dfeuer> Well, the problem is that it can potentially break (non-standard) code.
12:59:03 <geekosaur> exactly :)
12:59:06 <dfeuer> Which makes the GHC people nervous.
12:59:08 <lpaste> elfeck pasted “Why error?” at http://lpaste.net/116270
12:59:22 <geekosaur> it makes the committee even more nervous, which is why they want to see it in the real world first
12:59:36 <elfeck> can someone point out the error?
12:59:37 <elfeck> http://lpaste.net/116270
12:59:46 <mauke> elfeck: what error?
12:59:56 <geekosaur> elfeck, you should also paste the full error message(s)
13:00:16 <elfeck> okay
13:00:18 <elfeck> sorry
13:00:45 <dfeuer> geekosaur, so this wonderful extension just gets to stay an extension forever because no one wants to bite the bullet?
13:00:53 <geekosaur> pretty much
13:01:04 <geekosaur> there's a number of extensions in that category...
13:01:35 <monochrom> which one is the wonderful extension you're talking about? :)
13:01:56 <sinelaw> :/
13:02:02 <sinelaw> or rather
13:02:04 <sinelaw> :O
13:02:14 <elfeck> geekosaur found my error while trying to show it to you
13:02:22 <elfeck> thanks!
13:02:33 <geekosaur> rubber duck debugging at its finest!
13:02:37 <pecanpy> why isn't listToMaybe defined as a partial function? wouldn't it be better for listToMaybe [1, 2] to throw an error?
13:03:15 <Iceland_jack> Obviously it should be [a] -> Maybe (Maybe a)... :-)
13:03:40 <dfeuer> monochrom, the two I personally would like to see standardized are ScopedTypeVariables and BangPatterns.
13:04:14 <monochrom> I love ScopedTypeVariables. especially since it somehow includes types in patterns
13:04:49 <monochrom> indispensible for http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#typing !
13:05:46 <monochrom> bang patterns are also pretty handy and reduces clutter
13:05:53 * hackagebot kan-extensions 4.1.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.1.1 (EricMertens)
13:05:56 <dfeuer> monochrom, also, it lets you write type signatures you otherwise couldn't, which you sometimes need to do to get rid of static arguments.
13:07:43 <bernalex> dfeuer: let's do it
13:07:48 <Nik05> cool there are new exercises for the CIS 194 course
13:07:57 <bernalex> dfeuer: oh. my scroll was stuck. that was RE new haskell report. \
13:08:03 <bernalex> dfeuer: I also want monad comprehensions.
13:08:31 <sivteck> new haskell report is never going to come right?
13:08:38 <dfeuer> bernalex, I also want a couple Prelude fixes (get rid of that silly inits implementation in favor of one int-e wrote)
13:08:50 <bernalex> dfeuer:
13:08:53 <dfeuer> sivteck, it might.
13:08:58 <bernalex> dfeuer: I want '&' in prelude, but people might fight me.
13:09:01 <dfeuer> Oh, and a fix for words/unwords.
13:09:06 * sivteck doesn't see any activity here https://ghc.haskell.org/trac/haskell-prime
13:09:07 <geekosaur> only if there's reason to do it, which means someone pushing extensions like these, which means convincing ghc hq to get them into a release so the committee has real world experience to look at when deciding
13:09:12 <dfeuer> @type (&)
13:09:13 <lambdabot> a -> (a -> b) -> b
13:09:13 <geekosaur> (as defaults that is)
13:09:20 <bernalex> dfeuer: I put it in Data.Function.
13:09:28 <sinelaw> sivteck,  :(
13:09:52 <sinelaw> sivteck, but wasn't that what ended up being haskell2010?
13:09:54 <bernalex> sivteck: haskell & ghc is community driven. we just need a few wiki articles, some emails, and lots of enthusiasm!
13:10:01 <geekosaur> ^
13:10:06 <bernalex> sinelaw: haskell' means "the next standard".
13:10:09 <geekosaur> committee does nothing if nobody has requested changes
13:10:12 <sivteck> true
13:10:17 <dfeuer> geekosaur, bernalex, take a look at https://ghc.haskell.org/trac/ghc/ticket/9515
13:10:17 <sinelaw> I request a change.
13:10:18 <geekosaur> you're seeing the start of that process right now
13:10:39 <bernalex> I'm srs. dfeuer let's do this. we can make it happen.
13:10:41 * bernalex hifives dfeuer
13:10:51 * sinelaw shivers
13:11:01 <dfeuer> bernalex, I'm all in favor, but I'm not one of the high gurus.
13:11:09 <bernalex> dfeuer: that's the beauty. you don't have to be.
13:11:21 <bernalex> momentum trumps everything
13:11:26 <dfeuer> BTW, I don't think the Foldable/Traversable stuff should go in.
13:11:38 <bernalex> I do, but we'll have plenty of time for that bikeshed lol
13:11:39 <sivteck> sinelaw, i asked because, "at regular intervals (currently 12 months), a new revision of the language standard will be released" <https://ghc.haskell.org/trac/haskell-prime/wiki/Process>
13:11:50 <sinelaw> sivteck, "currently"
13:12:03 <sivteck> hmm ;d
13:12:13 <bernalex> dfeuer: abstract all the things! well. I might not want to argue for making (->) polymorphic in Prelude.
13:12:14 <sinelaw> but seriously, we do have now some comittees pushing real changes
13:12:38 <sinelaw> Traversablegate being one
13:13:10 <bernalex> sinelaw: hehe
13:13:17 <dfeuer> bernalex, I just don't think Foldable is a good abstraction.
13:13:23 <sinelaw> yeah, I made myself chuckle too
13:13:29 <geekosaur> sivteck, so what happened after that was Haskell2010 followed by several years of the committee not even bothering to meet because there was nothing to do
13:13:33 <geekosaur> nobody proposed anything
13:13:36 <bernalex> dfeuer: I agree. but it's better than list.
13:13:46 <xplat> dfeuer: lens has kinda convinced me that Foldable is a good abstraction
13:13:51 <fragamus> sinelaw:what is trav gate
13:13:53 <johnw> +1 for Foldable
13:14:00 <bernalex> I do like Traversable a bit though
13:14:06 <dfeuer> bernalex, nah, when you have a list, you have a list. When you have a Foldable, you have no idea what operations are efficient.
13:14:11 <phaazon> @hoogle a -> k -> Map k a -> Maybe a
13:14:13 <lambdabot> Data.Map.Lazy findWithDefault :: Ord k => a -> k -> Map k a -> a
13:14:13 <lambdabot> Data.Map.Strict findWithDefault :: Ord k => a -> k -> Map k a -> a
13:14:13 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
13:14:16 <jaccob> hi
13:14:23 <phaazon> ahah
13:14:27 <phaazon> why not lookupDefault
13:14:27 <bernalex> dfeuer: I am a hand-waving academic. srsly. I work as a researcher. I do not care *at all* about perf.
13:14:29 <geekosaur> I'd have to figure out where it's all archived but there was annual mailing list discussion "should we meet?" 'is there anything to do?" "no" "no"
13:14:34 <bernalex> dfeuer: so now you know my bias. ;-)
13:14:47 <sinelaw> fragamus, the controversial change in Prelude being introduced in ghc 7.10
13:15:09 <geekosaur> dfeuer: I feel like that ticket is subtly different, but also that it might be reopened *if* there were sufficient pressure to do so
13:15:21 <geekosaur> nobody pushed on the ticket, so inactivity prevailed
13:15:21 <xplat> dfeuer: with lists you know it's 'none unless they fuse away'.  which is also a safe assumption to make about an unspecified Foldable.
13:15:52 <dfeuer> geekosaur, it's related. Why don't you get to be the one who opens up the official "make ScopedTypeVariables default" discussion, so I can not look quite so annoying?
13:15:53 <geekosaur> basically, if the chance exists for breakage then the *community* has to get behind it for it to happen
13:15:55 <jaccob> tell me haskell is the fastest platform known to man!
13:15:58 <geekosaur> rather than ghc hq just doing it
13:16:06 <sinelaw> jaccob, it isn't
13:16:21 <jaccob> sinelaw, hmm, so what's so great about it
13:16:30 <benzrf> jaccob: its an excellent language
13:16:36 <fragamus> yeah
13:16:36 <dfeuer> xplat, the trouble is that you don't know which (if either) side you want to fold along to get things to be strict or lazy in certain ways.
13:16:51 <bernalex> jaccob: it's fast at some things. it's very hard to make fast at other things. it's not particularly slow.
13:17:22 <jaccob> benzrf, I am liking it so far, just started reading yesterday, but if I had to pit and moan already I'd say "recursion hell"
13:17:27 <xplat> dfeuer: if you care about doing that, you're probably specialized to a particular Foldable.
13:17:30 <bernalex> jaccob: what's great with haskell, to me, is that it lets me express my ideas much more closely to how they form in my brain than other language so -- where I need to put in a significant amount of effort to express things. furthermore, haskell code is also very easy to read and modify for many of the same reasons.
13:17:32 <geekosaur> dfeuer: because I'm neutral on the proposal?
13:17:37 <benzrf> jaccob: that means that you arent using enough HOFs
13:17:41 <geekosaur> the person pushing it should probably have some incentive :)
13:17:46 <jaccob> bernalex, I like the shortened syntax for sure
13:17:47 <benzrf> jaccob: recursion hell is FP's GOTO hell
13:17:57 <sinelaw> jaccob, there are many, many considerations when writing software. performance is a vague concept anyway - haskell can be fast too, depends on what you're trying to do.
13:18:08 <benzrf> jaccob: if GOTOs are getting on your nerves clearly you need to be using actual control structures
13:18:18 <jaccob> benzrf, come on man, FP's, HOFs, no idea
13:18:19 <benzrf> jaccob: if recursion is getting on your nerves clearly you need to be using higher order functions
13:18:26 <benzrf> jaccob: FP = functional programming
13:18:30 <jaccob> oh
13:18:31 <benzrf> jaccob: HOF = higher order function
13:18:32 <bernalex> jaccob: it is not about having little synax (Lisp languages are even cleaner, check them out). it is about having powerful abstractions, and more than that -- programmable abstractions. in C you can't program your kleisli arrow, you're stuck with it!
13:18:51 <sinelaw> bernalex, that has always bothered me.
13:18:56 <StoneCypher> be sure to say it as opaquely as you can
13:19:03 <benzrf> StoneCypher: ( ͡° ͜ʖ ͡°)
13:19:05 <bernalex> jaccob: a higher order function is a function that you pass a function. read about "fold".
13:19:05 <sinelaw> bernalex, j/k of course
13:19:05 <jaccob> well, I am aint quiting yet
13:19:13 <bernalex> sinelaw: it bothers me quite a bit.
13:19:14 <jaccob> thx guys
13:19:29 <Black-Heaven> Hello all, is there a way to transpose Fix to type level? Thanks in advance for your help.
13:19:34 <benzrf> Black-Heaven: Mu
13:19:36 <bernalex> jaccob: https://www.haskell.org/haskellwiki/Fold this is nice
13:19:36 <StoneCypher> benzrf: someone struggling with recursion will not know what "you can't program your kleisli arrow" means
13:19:45 <benzrf> StoneCypher: i didnt say that, bernalex did
13:19:46 <EvanR> lisp syntax cleaner? maybe in principle
13:19:47 <benzrf> sheesh
13:19:49 <StoneCypher> whoops
13:19:54 <sinelaw> StoneCypher, you mean bernalex
13:20:08 <StoneCypher> wait nom i was responding to [13:15:45] <benzrf> StoneCypher: ( ͡° ͜ʖ ͡°)
13:20:09 <dfeuer> bernalex, I think you got jaccob's syntax comment backwards or something, because Haskell has pretty complicated (but generally well-thought-out) syntax.
13:20:19 <xplat> StoneCypher: Kleisli arrow sounds cooler than monad.
13:20:24 <benzrf> Black-Heaven:
13:20:26 <benzrf> @src Mu
13:20:26 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:20:27 <EvanR> thinking of the syntax shenanigans you can / are encouraged to pull in common lisp and clojure...
13:20:32 <bernalex> jaccob: basically all functions that are "recurse through a list and do stuff to it" can be implemented using fold. it might be tough to grok at first, but they are very nice!
13:20:58 <benzrf> Black-Heaven:
13:20:59 <benzrf> :t cata
13:21:00 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
13:21:01 <EvanR> folds are annoying to have to do manually as well
13:21:06 <bernalex> dfeuer: he said "shortened syntax". I do not think Haskell has "shortened syntax" compared to Lisps was my point.
13:21:14 <xplat> and also people aren't taught to have fear and loathing of Kleisli arrows yet
13:21:33 <benzrf> xplat: who loathes kleisli arrows :{
13:21:55 <bernalex> StoneCypher: I make no assumptions when I talk to people, but I am happy to explain the concepts I use.
13:22:06 <xplat> benzrf: they're not.  but people spread FUD about monads
13:22:10 <bernalex> so with that said, jaccob, if I say a scary word, just ask me what it means. it's probably not that scary!
13:22:10 <fragamus> :t hylo
13:22:11 <lambdabot> Not in scope: ‘hylo’
13:22:40 <fragamus> :t banana
13:22:41 <lambdabot> Not in scope: ‘banana’
13:22:42 <bernalex> xplat: it's partly haskellers' fault for saying things like "the IO monad", which does not make much esnse.
13:23:07 <benzrf> bernalex: yes, it is the simple words to be scared of
13:23:08 <benzrf> ;)
13:23:30 <bernalex> xplat: you don't say [1, 2, 3] is the terms 1, 2 and 3 operating in the list monad.
13:23:32 <benzrf> "zoom"
13:23:37 <xplat> bernalex: it makes sense, it's just maybe ... premature? when a lot of people first hear it
13:23:51 <bernalex> xplat: you also do not say "here I am using the IO functor to putStrLn a getLine".
13:24:21 <bernalex> "how do you do IO in Haskell?" is better answered with "the IO type" than "the IO monad", IMO.
13:24:28 <Iceland_jack> bernalex: agreed
13:24:30 <jaccob> bernalex, thx,
13:24:47 <benzrf> bernalex: most certainly
13:24:54 <benzrf> bernalex: even better
13:24:54 <exio4> bernalex, if it wasn't monad but something nice looking like "contextual expression" or something like that, it'd change a bit too
13:25:00 <benzrf> "values that represent effects"
13:25:03 <sivteck> type IO a = <scary stuff>
13:25:08 <mauke> bernalex: we should talk more about the "function monad"
13:25:11 <benzrf> StoneCypher: data IO a actually
13:25:12 <xplat> bernalex: like calling a car an 'automotive conveyance' and saying 'conveyances are cool because we can drive them with wheels and levers!  conveyances include trucks, buses, and backhoes.  today we're going to learn about driving conveyances with one of the more common conveyances, the automotive conveyance.'
13:25:21 <benzrf> mauke: well we do say reader monad
13:25:28 <mauke> benzrf: mistab?
13:25:30 <Denommus> no specific channel for Haste, right?
13:25:36 <benzrf> mauke: no
13:25:36 <bernalex> exio4: I dislike the inherent anti-intellectualism of F# and elm who strive to use words like "computational expression", which is vague and non-explanatory like "object" or "class" in OOP.
13:25:43 <mauke> benzrf: yes
13:25:55 <xplat> bernalex: and without even the benefit of being short!
13:25:56 <benzrf> er, sivteck was
13:26:18 <sivteck> benzrf, hehe sorry, data IO a = <scary-stuff>
13:26:18 <dfeuer> WHEW
13:26:26 <exio4> bernalex, it is "less scary", so people don't mind "learning them"
13:26:42 <bernalex> exio4: which is a terrible idea. see OOP.
13:26:48 <benzrf> bernalex: hue
13:26:54 <exio4> bernalex, I never said it was a good idea!]
13:27:35 <jle`> Reader isn't just a Monad though
13:27:39 <jle`> i don't like saying Reader Monad either
13:28:01 <jle`> i use the Applicative instance much more than I use the Monad instance
13:28:02 <bernalex> teaching people "less scary" words that mean nothing means they get very confused about things later on. I prefer being confused by something complicated and then understanding it to "learning" an oversimplified version and then becoming confused later on.
13:28:12 <Iceland_jack> Take it to #haskell-blah maybe
13:28:18 <bernalex> starting out confused is a lot better than ending up confused.
13:28:21 <Kaidelong> bernalex: I don't agree with your hypothesis that it is anti-intellectual
13:28:21 <johnw> bernalex++
13:28:31 <xplat> maybe we should just call them 'transformer stacks'.  unlike 'contextual expression' it's actually true
13:28:32 <Kaidelong> Monad and Functor are also vague and non-explanatory
13:28:37 <Black-Heaven> benzrf: Thanks but I mean at type-level, doing recursion over types.
13:28:49 <Kaidelong> they were trying to improve on that
13:29:06 <bernalex> Iceland_jack: I think this discussion deserves to be in #haskell and is sufficiently haskell-related. my ¢2 anyway.
13:29:10 <Kaidelong> programmers use different language that is more rooted in what their tools are and this is okay
13:29:10 <Black-Heaven> By the way, I can't figure out what are the difference between Fix and Mu
13:29:17 <xplat> and it sounds like cool and stuff.  i know what a stack is, and i know that a transformer is more than meets the eye
13:29:34 <benzrf> Black-Heaven: yes, Fix
13:29:36 <benzrf> er, Mu
13:29:40 <benzrf> @src Mu
13:29:40 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:29:55 <Iceland_jack> bernalex: No prob
13:30:13 <ReinH> "contextual expression" has the quality of being nice looking, which I consider non-essential. It does not have the quality of accurately describing its subject, which I consider essential.
13:30:18 <Black-Heaven> benzrf: you can't do a :k In in ghci for example
13:30:23 <benzrf> :k Mu
13:30:24 <int-e> Black-Heaven: there is none. mu is just a greek letter that some people use for representing least fixed points.
13:30:24 <lambdabot> (* -> *) -> *
13:30:37 <xplat> "transformer stack"!
13:30:39 <benzrf> Black-Heaven: so you don't have it imported
13:30:51 <Kaidelong> also it wouldn't really be accurate to describe computation expressions as monads anyway
13:30:58 <Kaidelong> I mean in practice they often are
13:31:10 <bernalex> J uses the term "monad" in a completely offensive way. it's hilarious.
13:31:11 <Kaidelong> but fundamentally it's more like -XRebindableSyntax in its implementation
13:31:29 <ReinH> bernalex: J uses monad the same way that APL does, right?
13:31:31 <xplat> bernalex: that use actually has valid history though
13:31:32 <Kaidelong> in fact in F# you can't even be polymorphic over higher kinded types
13:31:53 <ReinH> That use of "monad" is just as valid as ours.
13:31:55 <bernalex> ReinH: I don't know what it means in APL. in J it means one-arity use of a "word", as oppose to dyadic, binary use.
13:31:56 <xplat> bernalex: even in maths, c.f. Monadic Second Order Logic
13:32:00 <ReinH> Yep.
13:32:01 <Hijiri> > cata (fromMaybe 100) $ In (\x -> Just x)
13:32:03 <lambdabot>  Couldn't match expected type ‘a0 -> Data.Maybe.Maybe a0’
13:32:03 <lambdabot>              with actual type ‘Data.Maybe.Maybe
13:32:03 <lambdabot>                                  (Lambdabot.Plugin.Haskell.Eval.Trusted.Mu Da...
13:32:11 <ReinH> bernalex: J borrows that, and most other things, from APL.
13:32:12 <bernalex> ReinH: xplat: I did not call it wrong.
13:32:23 <ReinH> You called it "offensive", which is worse.
13:32:33 <EvanR> not even wrong
13:32:36 <Kaidelong> also don syme did come up with a version of do syntax that is actually quite a lot nicer IMO than haskell's
13:32:38 <Hijiri> > cata (fromMaybe 100) $ let x = In (Just x) in x
13:32:42 <lambdabot>  mueval-core: Time limit exceeded
13:32:52 <Kaidelong> so they might as well call it something different
13:33:00 <ReinH> That usage of "monad" is over 40 years old https://www.youtube.com/watch?v=_DTpQ4Kk2wA
13:33:03 <jaccob> bernalex, true, the expressiveness matching one's ideas.
13:33:20 <bernalex> ReinH: being wrong is certainly worse than being offensive. it is offensive to my brain which is accustomed to the other meaning.
13:33:47 <ReinH> I hope being wrong isn't worse than being offensive. Most people are wrong many times a day.
13:33:49 <bernalex> ReinH: something being "offensive" means it arouses a visceral reaction, which that use of monad certainly does for me.
13:33:53 <xplat> Kaidelong: where can i find a quick description of that syntax?
13:34:41 <Kaidelong> xplat: not quick, but comprehensive, http://msdn.microsoft.com/en-us/library/dd233182.aspx
13:34:41 <nitrix> How do I use GHC's integerLog2# function?
13:34:43 <EvanR> just dispose of monad terminology please
13:34:48 <nitrix> The # seems to create issues.
13:34:51 <ReinH> EvanR: And replace it with what?
13:34:58 <EvanR> i dont know, effects
13:35:05 <ReinH> But monads aren't effects.
13:35:07 <nitrix> I'm seriously considering https://hackage.haskell.org/package/arithmoi-0.4.0.1/docs/Math-NumberTheory-Logarithms.html instead, which has integerLog2
13:35:08 <bernalex> EvanR: we use monad in a very nice way in haskell IMO
13:35:12 <EvanR> they arent
13:35:16 <xplat> it confuses me that people can think that one of 'being wrong' and 'being offensive' is worse independently of subject and context
13:35:18 <bernalex> it is extremely clearly defined.
13:35:19 <ReinH> I'm not interested in replacing an accurate term with an inaccurate one
13:35:32 <bernalex> xplat: I meant in this specific context.
13:35:34 <Kaidelong> xplat: how difficult would it be to make a GHC extension that can implement this?
13:35:53 <EvanR> you can program with effects using monad style
13:36:01 <EvanR> but applicative is the same way
13:36:05 <bernalex> you can program with effects without them too.
13:36:13 <bernalex> and you can use monads and not have effects.
13:36:21 <sivteck> monads aren't even that useful, functors and applicatives are more general ;/
13:36:30 <johnw> the Reader monad has no "effect"
13:36:31 <bernalex> FSVO "effect". see where this is headed? effect is already not very well defined, compared to monad.
13:36:33 <int-e> nitrix: You could enable the MagicHash language extension.
13:36:33 <Kaidelong> I guess the first step would be to figure out what typeclasses things like x.Delay() correspond to
13:36:38 <johnw> I prefer the word "context"
13:36:40 <ReinH> Is it really that hard to learn new vocabulary words? I don't think that's the problem.
13:36:49 <EvanR> ok, context
13:36:58 <Kaidelong> (looks like it might be MonadFix?)
13:37:01 <int-e> ReinH: it's not.
13:37:20 <bernalex> EvanR: monads are more than merely "computational contexts". they have clearly defined laws.
13:37:22 <EvanR> its just that monads have some sort of disruptive terminology effect
13:37:31 <bernalex> EvanR: in haskell there are clearly defined morphisms in the Monad typeclass.
13:37:31 <xplat> Kaidelong: "Delay" would be trivial in haskell
13:37:31 <ReinH> I think part of the problem is some people's insistence on avoiding real explanations of these concepts and using various euphemisms and dodges instead.
13:37:35 <Adeon> monads are monads
13:37:53 <bernalex> ReinH: I agree. I much prefer explaining monad through the Monad typeclass and its API.
13:38:00 <ReinH> "Monads are just a way of programming with effects." No. "Monads are just a way of sequencing computations." No.
13:38:03 <EvanR> for example if we were only interested in monad uses and behavior, we wouldnt be having this discussion
13:38:08 <jle`> using doges to explain monads?  sounds like a good idea
13:38:10 <EvanR> it would be over
13:38:30 <ReinH> Monads, per se, have almost no behavior, like most other objects we can describe in Hask.
13:38:32 <bernalex> I have a t-shirt that says "monads are like t-shirts", heh.
13:38:36 <sinelaw> "Monads are just an interface"
13:38:38 <xplat> monads have a new word because they are a new concept
13:39:04 <ReinH> Various type constructors that are instances of Monad have interesting behaviors, but you don't need to talk about "what monads are" to explain them.
13:39:05 <EvanR> the same idea is used in many papers without being referred to as such
13:39:14 <EvanR> complete with do notation
13:39:16 <bernalex> sinelaw: hmmm. I'm not going to chew too much on that. but in Haskell there is a Monad typeclass with a set of functions. and I think explaining them with those functions is the simplest way of explaining them.
13:39:39 <xplat> you can try to explain to people that 'snow is just fractally-organized frozen water' or 'snow is just cold fluffy stuff' but you really have to go out and play in the snow
13:39:47 <benzrf> monads are just a way of not having to deal with super deep nested functors
13:39:47 <bernalex> ReinH: hallo BTW! seldom we are awake at the same hours.
13:39:49 <sinelaw> bernalex, I was actually serious
13:39:58 <jle`> programming with effects can be achieved through monadic api's, but that's not what monads *are*.  that's like seeing someone use a computer to draw a picture and saying "compures?  they are just picture drawing things!"
13:39:59 <bernalex> sinelaw: I am replying seriously too.
13:40:07 <ReinH> A monad is a type constructor of kind * -> * equipped with functions return and (>>=) such that $LAWS. That's it. Done.
13:40:13 <benzrf> i mean we could have main :: IO (IO (IO (IO (IO (IO (IO (IO ())))))))
13:40:16 <sinelaw> bernalex, I'm not sure if we're in agreement or not.
13:40:18 <bernalex> ReinH: that's what I use too.
13:40:19 <benzrf> but that would get annoyin fsat
13:40:21 <benzrf> *fast
13:40:28 <bernalex> sinelaw: I am not as bombastic as you, but we seem to kind of agree.
13:40:54 * hackagebot elm-core-sources 1.0.0 - Source files for the Elm runtime and standard libraries  http://hackage.haskell.org/package/elm-core-sources-1.0.0 (jeremondi)
13:41:00 <xplat> sinelaw: i am more bombastic than you, but we seem to kind of agree.
13:41:11 <elfeck> why is
13:41:11 <elfeck> let plusmod3 = (`mod` 3) . (+)
13:41:11 <elfeck> not compilable but not working for plusmod3 2 2?
13:41:13 <bernalex> ReinH: sometimes, if it makes sense in the context, I use the morphisms' type signatures instead of saying "return and >>=" though.
13:41:26 <ReinH> bernalex: yep, the types are really the important thing anyway
13:41:32 <jle`> elfeck: try expanding the definition of (.)
13:41:36 <jle`> @src (.)
13:41:36 <lambdabot> (f . g) x = f (g x)
13:41:38 <jle`> and you shall see.
13:41:48 <bernalex> elfeck: uhm see the type
13:41:56 <elfeck> hm
13:41:56 <bernalex> :t (`mod` 3) . (+)
13:41:57 <lambdabot> (Num a, Integral (a -> a)) => a -> a -> a
13:42:01 <sinelaw> now I need someone exactly as bombastic as myself
13:42:01 <bernalex> it doesn't make that much sense.
13:42:12 <elfeck> how can I do plusmod3 then?
13:42:21 <ReinH> elfeck: what do you want plusmod3 to do?
13:42:43 <ReinH> \x y -> (x + y) `mod` 3 ?
13:42:43 <elfeck> (mod 3) after (+)
13:42:55 <Hijiri> @let plusmod3 x y = (x + y) `mod` 3
13:42:56 <lambdabot>  Defined.
13:42:57 <Hijiri> alternatively
13:43:01 <jle`> (`mod` 3) . (+) = \x -> mod (x +) 3.  modding a function by 3.  not what you want, see :)
13:43:02 <ReinH> Then I would define it as plusmod2 x y = (x + y) `mod` 3
13:43:05 <Hijiri> @pl plusmod3 x y = (x+y) `mod` 3
13:43:05 <lambdabot> plusmod3 = flip flip 3 . (mod .) . (+)
13:43:08 <bernalex> elfeck: let plusmod3 a b = mod (a + b) 3
13:43:09 <ReinH> er plusmod3 obv
13:43:14 <ReinH> or that
13:43:15 <xplat> let plusmod3 = ((`mod` 3) .) . (+)
13:43:25 <elfeck> okay lots of solutions
13:43:29 <ReinH> This isn't a reasonable thing to write pointfree
13:43:39 <elfeck> thanks I will see how they work
13:43:44 <jle`> \x y -> (x + y) `mod` 3 is probably the most readable
13:43:53 <jle`> cause...there's no way you can misread it
13:43:58 <jle`> and you'll see it instantly
13:43:59 <ReinH> indeed
13:44:03 <sinelaw> Agreed. pl is overrated.
13:44:04 <bernalex> flip flip 3 . (mod .: (+))
13:44:11 <jle`> pl is a means to an end, not an end
13:44:12 <ReinH> stahp
13:44:14 <xplat> ReinH: yeah, it's not really nice pointfree, i was going for the version that if you stared at it long enough you would figure out the problem with the original version
13:44:25 <ReinH> :)
13:44:34 <quchen>  ?pl should probably go the ?faq way.
13:44:34 <bernalex> xplat: mine is nicer than yours
13:44:54 <ReinH> Sometimes you are trying to reason about function application. In those cases, it's best to write your function using function application than composition. This is one of those cases.
13:44:56 <bernalex> I am a sucker for elegant use of n-ary compositions.
13:45:12 <bernalex> ReinH: if your function starts with "flip flip" you need to eta-abstract it, lol.
13:45:54 <ReinH> I am not. :p
13:45:56 <quchen> (\flip -> flip flip 3 . (mod .: (+))) flip -- bernalex, is this fine too?
13:46:06 <xplat> lawl
13:46:17 <int-e> quchen: that won't type-check easily
13:46:23 <bernalex> quchen: that's pretty good
13:46:48 <bernalex> I sometimes give this cute example of n-ary composition
13:46:51 <bernalex> hmsToDiffTime :: Hour h -> Minute m -> Second s -> DiffTime
13:46:54 <bernalex> hmsToDiffTime = (secondsToDiffTime . timeVal) .:. asSeconds
13:47:15 <quchen> FSVO cute
13:47:25 <jle`> @pl \a b c d e f g -> a (g e f) (a b) (b g) (f c)
13:47:27 <lambdabot> ((const .) .) . flip flip (flip id) . (((.) . flip . (liftM2 flip .)) .) . join . ((flip . ((flip . (ap .)) .)) .) . ((.) =<< flip . ((flip . (flip .)) .) . (. (flip . flip id)) . (.) . (.))
13:47:27 <xplat> .:. = quaternary composition?
13:47:33 <bernalex> I think that's a nice way to write it. I would never use flip flip .::. or whatever seriously.
13:48:00 <pecanpy> so many flips and no one has said it. its making me twitch
13:48:02 <bernalex> xplat: it is equivalent to (f .:. g) x y z = f (g x y z)
13:48:15 <xplat> never flip anything twice, except a USB cable
13:48:19 <bernalex> so (.:.) = (.).(.:)
13:48:22 <MP2E> haha
13:48:48 <bernalex> it is the biggest composition I have defined in one of my libraries. i.e. I have never needed a bigger one in production code. :-]
13:49:10 <pecanpy> http://tinyurl.com/oguwglr
13:50:06 <elfeck> I think I will use a flip-less version, thanks a lot for the solutions
13:50:29 <bernalex> elfeck: please use a pointful version! the pointfree version is pointless.
13:50:47 <EvanR> @fl (flip . flip)
13:50:48 <lambdabot> Not enough privileges
13:51:06 <bernalex> flip . flip is id.
13:51:15 <EvanR> i wanted flip-less to tell me that
13:51:23 <EvanR> @unpl (flip . flip)
13:51:23 <lambdabot> (\ i -> i)
13:51:27 <ReinH> well there you go
13:51:30 <EvanR> @pl @unpl (flip . flip)
13:51:30 <lambdabot> (line 1, column 1):
13:51:30 <lambdabot> unexpected "@"
13:51:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:51:32 <bernalex> @pl flip . flip
13:51:32 <lambdabot> id
13:51:47 <ReinH> btw you can @. pl unpl
13:52:00 <EvanR> @. pl unpl (flip . flip)
13:52:00 <lambdabot> id
13:52:03 <EvanR> bad. ass.
13:52:17 <bernalex> :t id
13:52:17 <lambdabot> a -> a
13:52:20 <ReinH> @. pl undo  is a particularly useful one
13:52:20 <lambdabot> is a particularly useful one
13:52:28 <EvanR> forall a . a -> a
13:52:44 <bernalex> hm. I kind of wish 'id' was another type than that.
13:52:45 <ReinH> @. pl undo do { x <- getLine; putStrLn x }
13:52:45 <lambdabot> putStrLn =<< getLine
13:52:55 <ReinH> bernalex: Er. What other possible type could it be?
13:53:07 <bernalex> ReinH: not monomorphic to (->)
13:53:15 <ReinH> bernalex: Ah, so Control.Category.id
13:53:29 <bernalex> ReinH: for instance
13:53:42 <EvanR> heh, doubly polymorphic?
13:53:57 <jle`> superId :: forall a b. a -> b
13:54:04 <ReinH> wat
13:54:07 <sinelaw> huh
13:54:10 <EvanR> forall a -> . a -> a
13:54:14 <EvanR> hehe
13:54:41 <EvanR> -XOperatorVariables
13:54:55 <xplat> forall a b. Category a => a b b
13:55:09 <quchen> Is 7.10's manual already uploaded it somewhere?
13:55:09 <jle`> :t C.id
13:55:10 <lambdabot> Category cat => cat a a
13:55:34 <quchen> I remember Austin publishing it for 7.8 around the time of the feature freeze, maybe he's done it as well this time
13:56:00 <bernalex> I kind of sort of wish everything was using categories
13:56:20 <bernalex> and that '->' was just an infix type variable used for readability
13:56:22 <jle`> but...pedagogy ;_;
13:56:37 <ReinH> Type operators are fun. data (.) f g = Compose f g; data (~>) f g = Nat { runNat :: forall a. f a -> g a }; join :: Monad m => m . m ~> m
13:57:04 <bernalex> jle`: I have been thinking about making a haskell environment where you need to "unlock" things. so you start out with a very basic list prelude, and "unlock" more generic stuff as you go. kind of like a game.
13:57:06 <sinelaw> we should also have kinda-higher types
13:57:30 <ReinH> return :: Monad m => Identity ~> m
13:57:31 <sinelaw> or was it higher kinda-types
13:57:32 <ReinH> ;)
13:57:44 <Hijiri> @let superId :: forall a b. a -> b; superId = absurd.transburst
13:57:45 <lambdabot>  Defined.
13:57:49 <bernalex> return :: a b b
13:57:53 <ReinH> Hijiri: lmao
13:59:15 <jle`> having everything be implicitly Identity would make a lot of things nicer
13:59:36 <jle`> then we can get rid of ($) and (.)
13:59:36 <Denommus> is there any way to compile Haste code in a "cabal compile"?
13:59:42 <jle`> and just use <$>, <*>, (=<<)
13:59:54 <EvanR> you mean the other way around?
14:00:07 <jle`> (<=<) instead of (.), etc.
14:00:16 <EvanR> use the shorter one
14:00:27 <EvanR> $ now is fmal
14:00:29 <EvanR> fmap
14:00:42 <jle`> ah yes.
14:00:44 <jle`> indeed
14:00:45 <johnw> and then State would be the same as StateT over Identity
14:00:45 <bernalex> not sure I agree.
14:00:49 <jle`> no wait no
14:01:07 <bernalex> the shorter the name, the more likely it is that someone wants to use it themselves.
14:01:29 <EvanR> just saying if theres expected to be no use for $ and lots of <$> then...
14:01:29 <bernalex> furthermore, all of these things are *terrible* in haskell. we should have mnemonic operators like f#. e.g. |>, <|, >> and <<.
14:02:36 <sivteck> Prelude.Fhash
14:03:18 <bernalex> I have been seriously contemplating putting |>, <|, >> and << in our company's prelude. I'll revisit the idea when we have more than 10KSLOC of publicly available code.
14:03:51 <jle`> can't use # in module names?
14:03:51 <nitrix> How do I find the previous power of two from a number?
14:03:52 <sivteck> I hate my name too.
14:03:56 <sinelaw> bernalex, what do you have publicly available now?
14:04:09 <jle`> nitrix: bitshift
14:04:21 <jle`> :)
14:04:22 <bernalex> sinelaw: not sure. probably around 5-6K of haskell? I actually really don't know.
14:04:42 <jle`> or you can just divide by two....
14:04:44 <jle`> hmmmmmmm
14:04:51 <nitrix> jle`: I tried everything shiftL 1 n, shiftR ...
14:04:53 <jle`> > 16 / 2
14:04:54 <lambdabot>  8.0
14:04:57 <jle`> looks like it works
14:05:11 <nitrix> It'd need a floor though, if I go the /2 way.
14:05:12 <xplat> bernalex: wait, what are those mnemonic for?
14:05:16 <bernalex> xplat: directions.
14:05:22 <nitrix> jle`: It's an Integer, not an Int in my case.
14:05:29 <xplat> bernalex: directions of what?
14:05:32 <jle`> `div` ?
14:05:36 <jle`> > 16 `div` 2
14:05:38 <lambdabot>  8
14:05:38 <bernalex> xplat: f <| x, x |> f, f >> g, g << f.
14:05:52 <xplat> bernalex: remember i don't use F#
14:05:58 <bernalex> xplat: I have never used F#.
14:06:00 <pecanpy_> theyre also used in Elm
14:06:04 <xplat> or elm
14:06:10 <sinelaw> or elM
14:06:12 <jle`> also ELM
14:06:14 <jle`> oh
14:06:15 <nitrix> jle`: I see, so `div` is what I was looking for :)
14:06:29 <nitrix> That's counter intuitive.
14:06:43 <bernalex> nitrix: people commonly get burnt by that.
14:06:54 <bernalex> I would use bitshifts for that btw.
14:07:09 <sinelaw> "Int" and "Integer". Another crime against humanity.
14:07:15 <nitrix> bernalex: I can't get the bitshifts to work though, like seriously, I'm getting the wrong results.
14:07:20 <schell> is anyone here a user at http://lobste.rs, and if so, would you mind inviting me?
14:07:20 <nitrix> Give me another minute.
14:07:25 <ReinH> If you really care about performance, use an unsafe bitshift
14:07:26 <bernalex> schell: numbers in general are awkward.
14:07:33 <bernalex> ReinH: :-D
14:07:41 <bernalex> ReinH: unsafePerformPreviousPowerOfTWo
14:07:46 <ReinH> (you almost never care that much about performance)
14:07:53 <schell> bernalex: you mean sinelaw? ;)
14:07:58 <sinelaw> ReinH, I just spent half a day caring about it
14:08:04 <bernalex> sinelaw: sorry yeah sinelaw
14:08:04 <sinelaw> schell, probably
14:08:07 <bernalex> sinelaw: hallo btw!
14:08:09 <ReinH> sinelaw: almost never, not never :p
14:08:10 <bernalex> god damnit
14:08:14 <jle`> what are numbers
14:08:22 <bernalex> schell: HALLO. my tab-fu is bad late at night.
14:08:31 <ReinH> bernalex: oh, HALLO btw.
14:08:32 <sinelaw> :P
14:08:34 <ReinH> Sorry.
14:08:36 <EvanR> what are numbers really
14:08:40 <schell> bernalex: all good! i usually get mixed with shachaf
14:08:41 <EvanR> number tutorial
14:08:46 <sinelaw> EvanR, \x.x = 0
14:08:50 <bernalex> ReinH: now I feel like I'm in that legendary erlang film.
14:09:08 <ReinH> bernalex: which what?
14:09:13 <EvanR> sinelaw: how does that decode
14:09:21 <bernalex> ReinH: https://www.youtube.com/watch?v=xrIjfIjssLE -- take the time to watch it. it's glorious.
14:09:25 <jle`> hm
14:09:32 <nitrix> bernalex: The problem is bitshifts or divs yields 33 for 66, when I'd expect 64. I want the immediate previous power of two.
14:09:54 <shachaf> schell: I can't bring myself to get annoyed at you for pinging me. :-)
14:10:06 <sinelaw> EvanR, oops. \f x. x = 0
14:10:15 <sinelaw> Church, etc. etc.
14:10:20 <jle`> how come \x x -> x is different than \x -> \x -> x
14:10:25 <jle`> they compile differently
14:10:25 <schell> shachaf: :) tag!
14:10:34 <jle`> isn't the latter supposed to be the desugaring for hte former?
14:10:35 <bernalex> jle`: they should not
14:10:38 <bernalex> jle`: yes
14:10:45 <jle`> :t \x x -> x
14:10:46 <bernalex> jle`: try without optimisation & threads & crap
14:10:46 <lambdabot>     Conflicting definitions for ‘x’
14:10:46 <lambdabot>     Bound at: <interactive>:1:2
14:10:46 <lambdabot>               <interactive>:1:4
14:10:48 <nitrix> bernalex: So essentially, only the first most significant bit is what I want I guess.
14:10:49 <jle`> :t \x -> \x -> x
14:10:49 <lambdabot> t -> t1 -> t1
14:10:55 <jle`> only one compiles
14:10:55 * hackagebot urlpath 0.0.6 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.6 (athanclark)
14:10:59 <bernalex> jle`: well not \x x
14:11:02 <chrisdone> well, pattern matching affects it
14:11:05 <ReinH> nitrix: Oh. Er... why did you expect (/) to work then?
14:11:38 <johnw> chrisdone!
14:11:48 <bernalex> johnw: \x x won't compile
14:11:51 <chrisdone> i'm vaguely suspicous that \(P x) (Z k) -> y has different strictness than \(P x) -> \(Z k) -> y
14:11:52 <bernalex> god damnit
14:11:54 <nitrix> ReinH: I think it was someone's suggestion but I'm pretty sure it's wrong.
14:11:56 <bernalex> jle`: \x x won't compile
14:11:59 <jle`> ikr
14:11:59 <chrisdone> johnw =3
14:12:05 <bernalex> jle`: those are conflicting definitions for 'x'.
14:12:09 <jle`> but shouldn't it just be a mechanical desugaring
14:12:17 <jle`> with desugaring/rewriting rules
14:12:31 <jle`> desugar first, then compile?
14:12:33 <ReinH> Well, one option is (2 ^) . floor . logBase 2
14:12:49 <jle`> oh i guess because the variables are given unique names.
14:12:56 <ReinH> > (2 ^) . floor . logBase 2 $ 66
14:12:58 <lambdabot>  64
14:13:14 <jle`> so \x y -> x is actually \x1042034 x57894345 -> x1042034
14:13:15 <Kaidelong> xplat: apparently haskell's extended list comprehensions has that feature in the form of the comma
14:13:17 <sinelaw> Today I explained basic lambda calculus to a 7 year old. I think it was easier to understand than most of the stuff they try to force-feed him
14:13:29 <Kaidelong> so I guess I could use a monad comprehension
14:13:33 <bernalex> jle`: "\x y -> x" is a different type to "\x -> \x -> x"
14:13:40 <Kaidelong> a bit of a clunky syntax though
14:13:42 <ReinH> There are probably some bit twiddlings that are faster... let me pull out Hacker's Delight real quick.
14:13:43 <bernalex> :t (\x y -> x)
14:13:44 <lambdabot> t1 -> t -> t1
14:13:49 <bernalex> :t (\x -> \x -> x)
14:13:50 <lambdabot> t -> t1 -> t1
14:13:51 <sinelaw> I'll try Church booleans tomorrow.
14:13:55 <xplat> > let kill2 x = x & -x in fromMaybe 0 . listToMaybe . reverse . takeWhile (/= 0) . iterate kill2 $ 66
14:13:56 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ a -> b
14:13:56 <lambdabot>  Relevant bindings include
14:13:56 <lambdabot>    x :: a (bound at <interactive>:1:11)
14:14:07 <EvanR> yeah LC is easier than long division in base ten
14:14:12 <nitrix> ReinH: If you can, it's what I'm looking for, otherwise I'll fallback to what you suggested.
14:14:21 <Kaidelong> > [x, y, z | x <- Nothing, y <- Just 3, z <- Just 5]
14:14:22 <lambdabot>  <hint>:1:10: parse error on input ‘|’
14:14:23 <bernalex> ReinH: the one I was thinking of is from hacker's delight.
14:14:27 <xplat> > let kill2 x = x .&. -x in fromMaybe 0 . listToMaybe . reverse . takeWhile (/= 0) . iterate kill2 $ 66
14:14:28 <lambdabot>  Precedence parsing error
14:14:28 <lambdabot>      cannot mix ‘Data.Bits..&.’ [infixl 7] and prefix `-' [infixl 6] in the s...
14:14:35 <EvanR> both may fail to terminate
14:14:42 <xplat> > let kill2 x = x .&. (-x) in fromMaybe 0 . listToMaybe . reverse . takeWhile (/= 0) . iterate kill2 $ 66
14:14:44 <sinelaw> EvanR, I meant stuff like "here is an ambiguous question, answer it correctly"
14:14:46 <lambdabot>  mueval-core: Time limit exceeded
14:14:55 <Kaidelong> mmm, did I mess up the comprehension syntax?
14:14:57 <sinelaw> xplat :/
14:15:00 <xplat> give up, someone else ftfm
14:15:28 <xplat> > let kill2 x = x .&. (x-1) in fromMaybe 0 . listToMaybe . reverse . takeWhile (/= 0) . iterate kill2 $ 66
14:15:29 <lambdabot>  64
14:15:38 <ReinH> nitrix: The problem is that this is not a right-to-left problem. You need to find the left-most 1.
14:15:43 <EvanR> sinelaw: yes and later when presented with carefully constructed precise questions they freak out
14:15:47 <xplat> > let kill2 x = x .&. (x-1) in fromMaybe 0 . listToMaybe . reverse . takeWhile (/= 0) . iterate kill2 $ 75
14:15:48 <lambdabot>  64
14:16:19 <xplat> this would be easy if i could bitreverse
14:16:23 <sinelaw> He found the identity function very amusing
14:16:34 <sinelaw> If you give it an elephant, it gives it back!
14:16:39 <xplat> C doesn't have bitreverse
14:16:43 <Kaidelong> maybe I misunderstood and monad comprehensions still don't give a yield/yield!
14:16:45 <EvanR> whats the encoding of an elephant in LC
14:16:48 <EvanR> i forget
14:16:48 <jle`> Kaidelong: yes, you can only put expressions in the [ .. |, but you put something like x,y,z
14:16:51 <xplat> sinelaw: if you gave him an elephant, he would keep it!
14:16:57 <jle`> which isn't an expression
14:17:07 <jle`> also monad comprehensions aren't enabled in lambdabot, heh
14:17:07 <shachaf> xplat: Not to be confused with bitraverse.
14:17:15 <sinelaw> EvanR, I'm sure Church had it covered
14:17:47 <sinelaw> "there is a very elegant proof but I don't have room to write it in the footnotes"
14:17:56 <Kaidelong> oh that's a shame then, it was mentioned that for full monad comprehension syntax you need a MonadPlus instance
14:18:02 <Kaidelong> so I was hoping you could do something like that
14:18:16 <Kaidelong> F#'s yield basically works using something like that
14:18:27 <nitrix> ReinH: What about (2 ^) . finiteBitSize n ?
14:18:27 <jle`> i'm not sure what you would expect that to result in
14:18:32 <Denommus> uh
14:18:46 <Denommus> what options do I have for web application frameworks?
14:18:50 <Denommus> besides yesod, that is
14:18:51 <benzrf> bbl
14:18:57 <sinelaw> Denommus, snap
14:18:59 <benzrf> Denommus: snap maybe
14:19:03 <benzrf> scotty
14:19:03 <nitrix> Ah nevermind, that's for fixed integer widths.
14:19:05 <Kaidelong> jle`: return x `mplus` return y `mplus` return z
14:19:07 <chrisdone> yesod, snap, happstack
14:19:13 <EvanR> use combinators not frameworks
14:19:29 <sinelaw> libraries
14:19:31 <Denommus> EvanR: how so?
14:19:38 <ReinH> nitrix: You can play a trick with unsigned shift
14:19:43 <ReinH> > 66 .&. (-3)
14:19:45 <lambdabot>  64
14:20:02 <chrisdone> haskell web frameworks tend to just be a collection of libraries anyway
14:20:32 <sinelaw> chrisdone, there is also how they are presented in the docs / tutorials
14:20:46 <sinelaw> which for a newcomer matters most
14:21:14 <jaccob> what does haskell do particularily fast?
14:21:42 <chrisdone> jaccob: confuse newbies
14:21:46 <nitrix> ReinH: > 68 .&. (-3)  === yields 68 not 64.
14:21:55 <sinelaw> jaccob, is there a specific use case that you need that makes you care so much about performance?
14:22:00 <Denommus> compared to what?
14:22:02 <Hijiri> jaccob: get written
14:22:04 <ReinH> nitrix: Yep, that doesn't work.
14:22:10 <Kaidelong> jaccob: theoretically lazy evaluation should help with some numerical applications but I'm not sure if this actually gets done
14:22:50 <nitrix> ReinH: I expect the previous power of two <= Integer I provide.
14:23:01 <ReinH> nitrix: Yes I understand.
14:23:21 <ReinH> nitrix: You can use a nlz from Data.Bits.Extras, one sec
14:23:27 <Kaidelong> jaccob: haskell has a pretty good implementation for massive parallelism in its run time system
14:23:43 <Kaidelong> so I guess for tasks that are highly parallel haskell sparks might be a good option
14:23:58 <Kaidelong> but then you can still do better with things like CUDA, OpenMP, OpenCL
14:24:04 <mmachenry> chrisdone: lol
14:24:29 <chrisdone> mmachenry: =p
14:24:31 <Kaidelong> it's probably more informative to say that Haskell lies somewhere inbetween things like C and python
14:24:50 <Kaidelong> thus it's neither particularly slow nor fast
14:24:59 <nitrix> ReinH: Does it has an instance for Integer, I don't think so :S
14:25:01 <Kaidelong> at any particular tasks
14:25:07 <chrisdone> i wish elem's args were reversed
14:25:18 <chrisdone> i almost never want it without flip
14:25:29 <Kaidelong> @ty elem
14:25:30 <lambdabot> Eq a => a -> [a] -> Bool
14:25:40 <Kaidelong> okay well
14:25:54 <Kaidelong> that might be better named as hasElem I guess
14:25:59 <Kaidelong> but the point of it is to use it infix
14:26:15 <ReinH> nitrix: If you're using Integer, you don't care about fast bit twiddling.
14:26:23 <mmachenry> jaccob: Haskell does er,um, most stuff pretty fast. According to the programming languages benchmarks game Haskell falls in the camp of languages that are as fast as Java, OCaml, etc. A bit slower than low-level languages like C and way faster than Perl or Python, et al
14:26:25 <Kaidelong> in which case it's analogous to the element test operator from mathematics
14:26:31 <ReinH> So you can just use (^ 2) . floor . logBase 2
14:27:18 <mmachenry> You might not like the benchmarks game but it's a hard thing to quantify they are the only ones I know of who are trying.
14:27:30 <nitrix> ReinH: Mhhh, so I just assume that logBase will never return something bigger than an Int ?
14:27:41 <EvanR> :t (`elem` x)
14:27:42 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
14:27:42 <lambdabot>     In the second argument of ‘elem’, namely ‘x’
14:27:42 <lambdabot>     In the expression: (`elem` x)
14:27:46 <EvanR> :t (`elem` [])
14:27:47 <lambdabot> Eq a => a -> Bool
14:28:01 <shaykha> :k elem
14:28:02 <lambdabot> Not in scope: type variable ‘elem’
14:28:13 <shaykha> :k 'elem`
14:28:14 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:28:23 <ReinH> nitrix: for logBase 2 x to exceed the maximum size of int, x would be a number larger than you can represent on your machine.
14:28:34 <EvanR> shaykha: *
14:29:01 <EvanR> we nevermind :k only works on types and type constructors
14:29:03 <nitrix> ReinH: I see, probably implemented as a size_t. Thx/
14:29:13 <shaykha> oh right
14:29:19 <Denommus> did anyone try the Haste approach for web dev?
14:29:32 <EvanR>  :k :: Type -> Kind
14:29:39 <EvanR>  Kind :: ??
14:29:55 <ReinH> 2 ^ (maxbound :: Int) is roughly equal to 10^10^18
14:30:19 <Denommus> being honest, what I really wanted was just a simple library/framework to use to generate and consume content, but that I could combine with a Haste front-end single-page application
14:30:24 <Denommus> sharing types and all that
14:31:09 <jaccob> chrisdone, sinelaw Hijiri Kaidelong mmachenry thx
14:31:11 <xplat> haskell speed can vary widely, it's almost always faster than python and almost always slower than C but in all cases it depends on optimization effort put into the code and underlying libraries
14:31:18 <jaccob> sinelaw, just curious in general
14:31:36 <ReinH> nitrix: you would need over an exabyte to store 2^ (maxbound :: Int) as an Integer...
14:31:55 <sinelaw> jaccob, ok, because in my experience performance isn't as central as other concerns, in most cases
14:32:05 <sinelaw> such as having correct code
14:32:12 <sinelaw> or maintainability
14:32:44 <EvanR> being in some sense more or less done by a dead line
14:32:53 <EvanR> perhaps sacrificing correctness and maintainability
14:33:00 <EvanR> but for some reason not performance
14:33:11 <ReinH> nitrix: so you literally can't represent a number x large enough that logbase 2 x would be an Integer at anything less than google scale.
14:33:17 <sinelaw> and not getting fired
14:33:23 <sinelaw> or going bankrupt
14:33:41 <EvanR> if were going to be doing things wrong, be damned we might as well do it at high speed
14:33:53 <sinelaw> maybe nobody will notice
14:34:32 <pikitgbhs> Hi friends :), how i can to know what is the equivalent to Char on Integer like in Hex for example 'A' == 1010
14:34:45 <sinelaw> pikitgbhs, hoogle is your friend
14:34:49 <sinelaw> @hoogle Char -> Int
14:34:51 <lambdabot> Data.Char digitToInt :: Char -> Int
14:34:51 <lambdabot> Data.Char ord :: Char -> Int
14:34:51 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
14:35:00 <sinelaw> pikitgbhs, ^^ ord
14:35:04 <sinelaw> > ord 'A'
14:35:06 <lambdabot>  65
14:35:18 <glguy> > digitToInt 'A'
14:35:20 <lambdabot>  10
14:35:34 <sinelaw> err. yes.
14:35:44 <xplat> ReinH: you could store it as a float though
14:35:48 <ReinH> nitrix: I'm not even aware of a filesystem that can address an exabyte of contiguous storage, even if you could build that much storage. So I don't think you need to worry about it.
14:35:56 <xplat> ReinH: some kind of bigfloat
14:36:04 <pikitgbhs> glguy: digitToInt dont's work on my ghci ?<interactive>:315:1: Not in scope: `digitToInt'
14:36:10 <jle`> it must be a pretty big float
14:36:12 <jaccob> sinelaw, and cross platform
14:36:26 <xplat> jle`: just the exponent, the mantissa could be 2 bits
14:36:27 <ReinH> I think ext4 can theoretically support up to 1 exabyte
14:36:35 <sinelaw> jaccob, that also.
14:36:48 <jle`> xplat: the exponent is still considerably large, i think
14:36:57 <sinelaw> jaccob, AFAIK people are running haskell on iPhones, for example
14:37:04 <pikitgbhs> sinelaw: Thanks for the answ i will hoogle it :P
14:37:05 <sinelaw> god knows what for
14:37:10 <jaccob> sinelaw, yep, I noticed
14:37:13 <ReinH> I'm trying to put into words how much of a non-problem "what if logbase 2 is larger than maxint" is...
14:37:20 <jaccob> sinelaw, I'm mostly interested in the browser
14:37:35 <EvanR> ReinH: i think this exists, the exabyte range filesystem
14:37:40 <sinelaw> jaccob, oh then I would look at Purescript too, even though it isn't really haskell
14:37:54 <xplat> there are cluster filesystems that go that big i think
14:37:54 <sinelaw> jaccob, besides GHCJS, Haste, and whatnot
14:37:57 <ReinH> EvanR: Huh. Apparently it is.
14:38:15 <sinelaw> pikitgbhs, with pleasure.
14:39:13 <dmj`> is it redundant to use a resource-pool if I'm already using a mananger (from http-client)? I assume so...
14:40:54 <jaccob> sinelaw, nice, thx
14:45:26 <ReinH> dmj`: manager has its own resource pool, so probably
14:46:53 <chrisdone> in a less scrupulous language Manager would be a global
14:53:47 <chrisdone> lol https://twitter.com/Johnrealpo/status/542619773326999552
14:53:54 <chrisdone> pls respond
14:54:31 <bernalex> chrisdone: wtflol. is that srs?
14:54:42 <chrisdone> no idea. just looked at my twitter notifications and saw it
14:54:51 <sinelaw> huh
14:54:56 <sinelaw> hilarious
14:54:57 <chrisdone> made me chuckle anyway
14:54:59 <sinelaw> is that a troll?
14:55:05 <bernalex> chrisdone: also did you tell them "You need to define a Show instance for (Num (a -> a), Num a) => a"?
14:55:12 <Athas> Hm, how does GHCi set the locale?  Does it run setlocale(LC_ALL, "")?
14:55:48 <monochrom> I think GHCi gets the locale rather than sets.
14:55:48 <pecanpy_> someone respond with http://tryhaskell.org/
14:55:57 * hackagebot steeloverseer 1.1.0.3 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-1.1.0.3 (SchellScivally)
14:56:36 <jaccob> !l
14:56:39 <chrisdone> sinelaw: it as an "urgent matter i have $500,000 in bank would like to deposit ..." spam kind of feel to it
14:57:24 <sinelaw> the best kind
14:57:45 <EvanR> num instance for functions to the rescue
14:58:11 <monochrom> "I have $((*3)*(2+))5 in bank would like to deposit..."
14:58:11 <sinelaw> omg omg omg whats fmap.fmap.fmap id ((((3,()),(),())) plz respond asap
14:58:15 <pecanpy_> try haskell is chris too. lol. i didnt realize
14:58:29 <sinelaw> pecanpy_, yip
14:58:31 <chrisdone> i'm everywhere!
14:58:58 <chrisdone> don't look behind you
14:58:59 <EvanR> is that AIJohn AImario or Al or A1 or
14:59:07 <sinelaw> chrisdone, if this was spam the picture would be of a young woman
14:59:12 <sinelaw> may be real.
14:59:36 <EvanR> no body real uses "a-words" at the beginning of their name unless they are spammin
14:59:55 <chrisdone> unless they are a-spammin'
15:00:04 <sinelaw> AI john AI mario
15:00:11 <sinelaw> kind of suspsicious, that is
15:00:17 <sinelaw> *suspicious
15:00:31 <monochrom> yikes, I use Albert at the beginning of my name. am I spamming?
15:00:32 <sinelaw> the times are a-spammin'
15:00:49 <EvanR> hes probably making some extra money and knows about haskell
15:01:04 <chrisdone> Albert l**AI**
15:01:15 <chrisdone> i knew it!!
15:01:28 <EvanR> AIbert AImonochrom?
15:02:36 <pecanpy_> just out of curiosity. why does tryhaskell give the type constraints in a different order (I know the order doesnt matter). :: (Num (a -> a), Num a) => a -> a  vs :: (Num a, Num (a -> a), Num a) => a -> a
15:03:09 <pecanpy_> vs. ghci, i mean
15:04:06 <twanvl> it might have to do with which extensions are turned on
15:05:00 <chrisdone> also the ghc version of tryhaskell is 7.6
15:05:11 <chrisdone> i noticed some other slightt differences like that with 7.8
15:05:14 <rola> did gwern have something to do with tryhaskell
15:05:25 <pecanpy_> and my ghci is 7.8.3
15:05:27 <chrisdone> gwern wrote mueval, which tryhaskell and lambdabot use
15:05:46 <chrisdone> (for sandboxed evaluation)
15:05:52 <rola> ah
15:06:12 <sinelaw> hot swappable too
15:06:27 <pecanpy_> thanks. i know it was a trivial observation, it just picqued my interest
15:08:46 <dotsspwe> Hi, a better way to do this in hs without use the Data.Char or native libs ?  http://lpaste.net/116275
15:09:40 <chrisdone> fe, fi, fo, fas, i smell the blood of homework task!
15:09:53 <dotsspwe> hahaha
15:10:05 <c_wraith> dotsspwe: at the very least, use pattern-matching
15:10:14 <pecanpy_> put all the results in a list, and use the index to look them up
15:10:16 <EvanR> nah you cant use pattern matching either
15:10:26 <c_wraith> dotsspwe: in general, consider the use of "if" to be a sign of bad code.
15:10:47 <dotsspwe> c_wraith:  Yes i know, but how i use guards here ?
15:11:04 <c_wraith> dotsspwe: don't - use pattern-matching.  you can match on Char literals
15:11:41 <chrisdone> i.e. case x of ...
15:11:58 <monochrom> I would simply use tools from the Numeric module
15:13:09 <monochrom> readHex can input hexadecimal, showIntAtBase can output binary.
15:13:49 <dotsspwe> monochrom:  thanks let me see
15:14:34 <gilligan_> any nix users around ? Having a weird dependency problem right now : http://lpaste.net/8961190160611934208
15:15:07 <gilligan_> There are problems in package text-1.2.0.0: dependency "array-0.5.0.0-b8a3e03cc1fe2faa719c34f245086f0e" doesn't exist
15:18:49 <johnw> gilligan_: better asked in #nixos btw
15:19:12 <johnw> try removing ~/.ghc entirely and then running your command again
15:19:24 <johnw> and make sure "which ghc-pkg" is coming from within /nix
15:20:15 <gilligan_> well from ~/.nix-profile/bin anyway
15:20:21 <johnw> ok
15:20:45 <dredozubov> hmm, it seems i need to somehow search by set inclusion
15:20:59 <dredozubov> simplest solution i can come up with now to make it relatively fast is generating a list of polymorphic tries(to hold my types) and search though it
15:21:35 <dredozubov> it's not clicking at all
15:21:59 <jeltsch> Hi, where are the sources of module GHC.ST? I didn’t find them in the GHC source bundle. :-O
15:22:00 <dredozubov> it doesn't click*
15:22:13 <dredozubov> any ideas?
15:24:19 <jeltsch> Ah, sorry. I searched only for ST.hs, but it is in a file ST.lhs.
15:33:58 <mjrosenb> @dj a -> (b, [a]) -> (b, [a])
15:33:58 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver do
15:34:05 <mjrosenb> @djinn a -> (b, [a]) -> (b, [a])
15:34:06 <lambdabot> Error: Undefined type []
15:34:09 <jle`> djinn isn't too great with recursive types
15:34:18 <mjrosenb> jle`: it was worth a shot.
15:34:21 <jle`> also [] isn't defined yet
15:34:45 * mjrosenb also suspects the [] isn't actually important
15:35:15 <mjrosenb> @hoogle a -> (b, c) -> (a -> c -> d) -> (b, d)
15:35:16 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
15:35:24 <mjrosenb> iirc, this is one of the arrow functions
15:35:33 <mjrosenb> but I can never keep all that line noise straight.
15:36:10 <mjrosenb> @hoogle (a->b) -> (c, a) -> (c, b)
15:36:10 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:36:10 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:36:10 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
15:36:20 <jle`> :t \x t f = first (f x) t
15:36:21 <lambdabot> parse error on input ‘=’
15:36:24 <mjrosenb> ... that is not closer.
15:36:25 <jle`> :t \x t f -> first (f x) t
15:36:26 <lambdabot> t -> (b, d) -> (t -> b -> c) -> (c, d)
15:36:36 <mjrosenb> :t first
15:36:37 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:36:48 <jle`> :t first `asAppliedTo` (undefined :: a -> b)
15:36:49 <lambdabot> (a -> b) -> (a, d) -> (b, d)
15:37:09 <jle`> just applies the function to the first element of the tuple
15:37:14 <jle`> actually in your case you should use `second`
15:37:55 <bernalex> annoys me that both isn't in there with second and first
15:38:26 <jle`> join (***) i guess, but Arrow really isn't the best abstraction for tuple manipulation anyway
15:38:36 <jle`> is it in bifunctor?
15:39:01 <bernalex> jle`: join (***) is what I want, yes. it is in bifunctor and in lens.
15:39:02 <bernalex> :t both
15:39:04 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
15:39:12 <jle`> can we just get bifunctor into base then
15:39:13 <bernalex> and bitraversable apparently.
15:39:35 <jle`> that way people can stop complaining about Arrow ;_;
15:39:38 <bernalex> jle`: the answer to "can we just [...] base" is often "no".
15:40:05 <jle`> the answer has been yes several times so i am witholding hope
15:41:14 <bernalex> jle`: suggest it? it's just a quick email off to libraries.
15:41:31 <jle`> i feel like i am not the first one
15:41:36 <jle`> but that might just be an assumption
15:41:40 <bernalex> search the archives
15:42:11 <jle`> my usual process is just to bug edwardk on freenode
15:42:56 <bernalex> jle`: yup :-P
15:43:50 <mjrosenb> @hoogle Arrow a => Bool -> a b b -> a (b, b) -> a (b,b)
15:43:51 <lambdabot> Data.Graph.Inductive.NodeMap delMapEdges :: (Ord a, DynGraph g) => NodeMap a -> [(a, a)] -> g a b -> g a b
15:43:51 <lambdabot> Data.Graph.Inductive.NodeMap delMapEdge :: (Ord a, DynGraph g) => NodeMap a -> (a, a) -> g a b -> g a b
15:43:51 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
15:44:05 <mjrosenb> lambdabot: wat... arrow isn't even in there.
15:44:16 <jle`> all Arrow functions are in Control.Arrow btw, if you want to look
15:44:43 <mjrosenb> also, I'm not sure if that is a generic arrow, or if it only works with a b c == b -> c
15:45:13 <jle`> a (b,b) isn't even properly kinded :/
15:45:16 <mjrosenb> jle`: I just wrote condApp True = first; condApp False = second
15:45:23 <mjrosenb> jle`: derp.
15:45:33 <mjrosenb> let me punch this into ghci to find out what its type actually is.
15:46:19 <mjrosenb> @hoogle  Arrow a => Bool -> a c c -> a (c, c) (c, c)
15:46:19 <lambdabot> No results found
15:46:26 <mjrosenb> ... where did b go?
15:46:44 <jle`> :t join (***)
15:46:44 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
15:47:11 * mjrosenb thought the last step was to just label all varibles starting with the lowest available letter?
15:47:37 <jle`> hm?
15:48:16 <mjrosenb> jle`: the type that ghci gave for my condApp implementation had a single type variable, 'c', no 'b'.
15:48:42 <bitemyapp> anybody here use `cabal repl --with-ghc` for ghci-ng lately?
15:48:44 <jle`> it's probably because it knows that your function is b -> b
15:48:50 <jle`> instead of the more general b -> c
15:48:53 <bitemyapp> I can't get `cabal repl` to respect the --with-ghc argument pointing to a different ghci.
15:49:00 <bitemyapp> It seems to be ignoring it and I'm not sure why.
15:55:06 <benzrf> :t \x -> x
15:55:07 <lambdabot> t -> t
15:55:09 <benzrf> mjrosenb: ^
15:55:32 <jle`> i'm going to have to remember transburst
15:55:39 <jle`> :t first `asAppliedTo` transburst
15:55:40 <lambdabot> (a -> b) -> (a, d) -> (b, d)
15:55:42 <mjrosenb> benzrf: ... odd, how does it choose letters then?
15:55:46 <benzrf> idk
15:55:52 <benzrf> :t transburst
15:55:53 <lambdabot> a -> b
15:55:54 <jle`> the letter oracle
15:55:56 <benzrf> whaa
15:56:04 <jle`> now i can stop writing (undefined :: a -> b)
15:56:12 <jle`> :t fmap `asAppliedTo` transburst
15:56:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:56:17 <mjrosenb> @src transburst
15:56:17 <lambdabot> Source not found. Where did you learn to type?
15:56:23 <jle`> although writing transburst might be considerably more confusing
15:56:25 <benzrf> oh snaap
15:56:32 <jle`> :t flip fmap `asAppliedTo` transburst
15:56:33 <lambdabot> (a -> b1) -> (b1 -> b) -> a -> b
15:56:38 <benzrf> jle`: u got this merged into lamdanbot?
15:56:47 <jle`> no i saw someone use it today
15:56:53 <jle`> and i was like oh that's neat
15:56:58 <jle`> and then i was like
15:57:03 <jle`> i'm going to have to remember that
15:57:06 <jle`> and then here we are
15:57:10 <benzrf> @undef
15:57:10 <lambdabot> Undefined.
15:57:13 <benzrf> :t transburst
15:57:14 <lambdabot> Not in scope: ‘transburst’
15:57:17 <benzrf> [sad trombone]
15:57:26 <jle`> whataaaaat
15:57:28 <rom1504> what happens after z
15:57:33 <jle`> Hijiri
15:57:48 <jle`> deceiver of worlds
15:57:52 <benzrf> @let transburst :: a -> b; transburst = undefined
15:57:53 <lambdabot>  Defined.
15:59:31 <jle`> @let foolproofCoerce :: a -> b; foolproofCoerce = undefined
15:59:32 <lambdabot>  Defined.
16:00:11 <mjrosenb> :t let a = (.) . (.); b = a . a; c = b . b; d = c . c in d . d
16:00:12 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 -> a18 -> a19 -> a20 -> a21 -> a22 -> a23 -> a24 -> a25 -> a26 -> a27 -> a28 -> a29 -> a30 -> a31 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> a16 -> a17 ->
16:00:12 <lambdabot> a18 -> a19 -> a20 -> a21 -> a22 -> a23 -> a24 -> a25 -> a26 -> a27 -> a28 -> a29 -> a30 -> a31 -> c
16:00:25 <mjrosenb> well, it just uses a whole bunch of numbers.
16:00:39 <dibblego> @type over _1
16:00:40 <lambdabot> Field1 s t a b => (a -> b) -> s -> t
16:01:21 <rom1504> right
16:02:00 <mjrosenb> 18:58 <lambdabot> [7 @more lines]
16:02:02 <mjrosenb> oh, good.
16:04:35 <kuribas> Anyone good in math?
16:04:58 <mjrosenb> kuribas: nope, nobody on earth is good at math.  sorry.
16:05:00 <hiptobecubic> kuribas, if you mean math with numbers in it you'll have to go elsewhere :)
16:05:19 <kuribas> hiptobecubic: calculus actually.
16:05:26 <kuribas> mjrosenb: lol
16:05:28 <jle`> ##math is pretty friendly :)
16:05:35 <jle`> so is #haskell-blah
16:05:42 <jle`> ##math is one of the friendlier channels on freenode, i've found
16:05:50 <kuribas> jle`: They are too busy...
16:06:41 <xplat> what kind of calculus, the kind with numbers, or the kind where you differentiate datatypes?
16:07:19 <mjrosenb> uhh, oops? lambdabot doesn't seem to have a timeout set on typechecking?
16:07:28 <kuribas> xplat: partial differentiation.
16:07:48 <mjrosenb> this seems bad, what with the 2^2^n case and whatnot.
16:08:33 <mjrosenb> thank god I only went up to c.c!
16:08:48 <kuribas> http://mathb.in/24908
16:08:54 <mjrosenb> 19:03 <lambdabot> [935 @more lines]
16:10:31 <mjrosenb> kuribas: what does \frac {\partial (y,z)}{\partial (u,v)} dx mean?
16:10:35 <benzrf>     
16:11:06 <kuribas> mjrosenb: You cannot see the latex math?
16:11:21 <kuribas> mjrosenb: It's just latex source.
16:11:41 <mjrosenb> kuribas: I can, but I don't know what that expression *means*
16:11:56 <kuribas> mjrosenb: Oh, it's the jacobian.
16:12:05 <mjrosenb> kuribas: i know what all the symbols are, I've just never seen a parial operator take two arguments before
16:12:11 <mjrosenb> jacobian in differential calculus?
16:12:19 <kuribas> yes
16:12:21 * mjrosenb goes to wikipedia
16:13:26 <xplat> hm, the jacobian is a matrix.  that's almost not a number.
16:13:54 <mjrosenb> ahh, that is a very different jacobian from the one that I am used to.
16:14:41 <mjrosenb> so, who should I poke about lambdabot?
16:14:42 <kuribas> mjrosenb: d(y,z)/d(u,v) is det([[dy/du dy/dz][dz/du dz/dv]]).
16:15:24 <mjrosenb> kuribas: ahh, so you are implicitly taking the determinant... or the variant that is the post-determinant scalar.
16:15:30 <kuribas> So with subscript notation (y_u*z_v - y_z*z_u).
16:15:58 <mjrosenb> kuribas: this sounds a whole lot like the curl being zero.
16:16:17 <kuribas> mjrosenb: possibly, but curl is the next chapter...
16:16:38 <mjrosenb> also, take what I say with a grain of salt, I took 3d calc in 2004.
16:20:31 <mjrosenb> kuribas: I'm also going to take a guess that the dx, dy, dz in the long equation with jacobians are supposed to be infetesmal basis vectors, rather than just 'dx', since the jacobians don't require an extra dx.
16:22:54 <jle`> mjrosenb: int-e, but i think the issue is already known
16:23:34 <mjrosenb> jle`: if it is a known issue, then can I bump that up to d . d, and see what lambdabot does? :-p
16:23:55 <jle`> i am not an enabler
16:26:01 * hackagebot atlassian-connect-core 0.1.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.1.0.0 (RobertMassaioli)
16:26:08 <kuribas> mjrosenb: the dx is an approximation to a difference.  It's defined as (dx/du)*du + (dx/dv)*dv, when x is a function of u and v.
16:26:20 <kuribas> mjrosenb: du and dv can be any value.
16:27:09 <kuribas> mjrosenb: That's how it is explained at least...
16:28:14 <kuribas> mjrosenb: So when substituting du and dv in the equation, it should hold for any du and dv...
16:35:38 <mjrosenb> kuribas: that doesn't sound like how infinitesimals work.
16:36:01 * hackagebot peyotls 0.1.6.3 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.3 (YoshikuniJujo)
16:36:44 <calvinx> so the main difference between “<-“ and “=“ is that “=“ does not allow you to change your mind later on; while for “<-“, you can re-assign (or in haskell terminology, re-bind) another value to a variable.  is this the correct understanding of “<-“ versus “=“ in Haskell?  This makes “<-“ a lot like “=“ in other imperative languages?
16:37:35 <mjrosenb> calvinx: noooot really.
16:37:50 <calvinx> :( damn, I thought I am beginning to understand the two notations…
16:38:02 <calvinx> So how would you correct my supposition above?
16:38:03 <HeladoDeBrownie> calvinx, well, both are parts of specific syntax that have different purposes. For example, do { x' <- x ; f x' } is just sugar for x >>= \x' -> f x'
16:38:06 <mjrosenb> calvinx: you can re-bind things that you bound with =, just it takes a new context
16:38:08 <ClaudiusMaximus> in do { a <- f; a <- g a ; ... } the second a just shadows the first one
16:38:20 <mjrosenb> > let x = 1 in let x = 2 in x
16:38:22 <lambdabot>  2
16:38:44 <HeladoDeBrownie> And then there's let syntax as mjrosenb demonstrated, which simply binds a variable to a value
16:39:49 <mjrosenb> calvinx: they are used in completely disjoint places in the syntax tree.  <- is only available in do blocks, and other do-like areas (e.g. list comprehensions), and = is only allowed top level (source code only), and in let binding blocks.
16:39:58 <HeladoDeBrownie> And then certain top-level declarations also use =, and you can think of those as similar to what let does, albeit with the scope being the whole file. E.g., f x = x at top-level creates an f accessible anywhere in that file and that can also be exported.
16:40:04 * mjrosenb hopes that didn't get cut off.
16:40:10 <HeladoDeBrownie> mjrosenb, looks complete to me
16:41:15 <calvinx> I got the second point about “they are used in completely disjoint places in the syntax tree.  <- is only available in do blocks, and other do-like areas (e.g. list comprehensions), and = is only allowed top level (source code only), and in let binding blocks.”
16:41:20 <mjrosenb> kuribas: oh, maybe dx, dy and dz are supposed to b F_x, F_y, and F_z?
16:41:46 <calvinx> I didn’t quite understand the point about this “> let x = 1 in let x = 2 in x” ?
16:42:04 <HeladoDeBrownie> calvinx, there are two distinct x there, the inner one shadowing the outer one as long as it's in scope
16:42:12 <calvinx> aaaahhhhhhhhh
16:42:21 <Iceland_jack> > let x = 1 in (let x = 2 in x)
16:42:22 <lambdabot>  2
16:42:27 <Iceland_jack> > let x = 1 in 2
16:42:27 <calvinx> “>” is not part of the syntax yes
16:42:28 <lambdabot>  2
16:42:32 <calvinx> what’s with the “>” ?
16:42:40 <mjrosenb> > let x = 1 in (let x = 2 in x, x)
16:42:41 <Iceland_jack> calvinx: It's a way to evaluate it with lambdabot
16:42:41 <lambdabot>  (2,1)
16:42:47 <mjrosenb> calvinx: that asks lambdabot to evaluate something
16:42:56 <calvinx> O! Cool.
16:42:58 <calvinx> LOL
16:42:59 <mjrosenb> ok, I'm not sure I'm good with scoping working quite like that.
16:43:01 <kuribas> mjrosenb: I don't think so..
16:43:06 <Iceland_jack> If you put parentheses around 'let ... = ... in ...' the scope will make more sense
16:43:16 <Iceland_jack> > let x = 1 in ((let x = 2 in x), x)
16:43:18 <lambdabot>  (2,1)
16:43:37 <Iceland_jack> To rename them to x1 and x2:
16:43:38 <Iceland_jack> > let x1 = 1 in ((let x2 = 2 in x2), x1)
16:43:39 <lambdabot>  (2,1)
16:43:44 <mjrosenb> Iceland_jack: yes, I realize that, but I also instinctively left them out because you never need parens in a tuple, unless you are making a nested tuple.
16:44:14 <kuribas> mjrosenb: For my book: "if delta_x = dx and delta_y = dy are small, then dz is a close approximation of delta_z".  The quantities dx and dy, called differentials of x and y respectively, need not be small.
16:44:28 <calvinx> OK, now I understand this statement earlier “you can re-bind things that you bound with =, just it takes a new context"
16:44:44 <Iceland_jack> mjrosenb: You're fine not using parentheses, I added them for explicitness
16:45:04 <calvinx> Or read another way, I can say that within the same context, you cannot re-bind things with “=“.
16:45:18 <calvinx> Would that be a correct statement to make?
16:45:50 <HeladoDeBrownie> calvinx, there are some syntaxes that use = where you can't have one thing shadow another, by the way; e.g., the compiler will complain if you have multiple declarations of the same name at the same level. E.g., f x = x + 1 ; f x = x + 2
16:46:10 <kuribas> mjrosenb: So if x is a function of u, v f(u, v), then dx is a function of du and dv.
16:46:12 <HeladoDeBrownie> Although you can easily have a more local f
16:46:22 <calvinx> yes, that’s what I learnt earlier this week. (compiler complains if I have multiple declarations of same name at same level with “=".
16:46:42 <mjrosenb> calvinx: yes, also, in let-binding blocks, bindings are recursive, and inside of do blocks, they are not.
16:46:45 <HeladoDeBrownie> Actually, wait, I messed up. That might be parsed as multiple patterns of the same function
16:46:48 <calvinx> And yes, I also learnt that I can use “let” to localize bindings
16:47:12 <calvinx> O.
16:47:30 <mjrosenb> e.g.
16:47:33 <calvinx> so, do blocks are very imperative by nature.
16:47:46 <HeladoDeBrownie> Oh here's an actual example
16:47:48 <mjrosenb> > let l = [] in let l = 1:l in l
16:47:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:47:57 <HeladoDeBrownie> f = \x -> x ; f = \x -> x + 1
16:48:03 <calvinx> lol. lambdabot is cool.
16:48:05 <HeladoDeBrownie> *That* is a pair of conflicting definitions
16:48:26 <HeladoDeBrownie> Although I could just as well have written: f = 1 ; f = 2
16:48:30 <mjrosenb> HeladoDeBrownie: well, it is a definition that is never used, then a second definition that ignores the first :-)
16:48:34 <calvinx> Ok, thanks for the clarification HeladoDeBrownie
16:49:08 <xplat> if you want recursive do you can use {-# LANGUAGE RecursiveDo #-}
16:49:20 <HeladoDeBrownie> mjrosenb, which are you talking about? That's not true of any of the examples I gave, anyway. The first I gave was overlapping patterns where the second will never be reached, which isn't what I meant to be demonstrating.
16:49:22 <xplat> but that only works for some kinds of do
16:49:39 <calvinx> http://lpaste.net/116276
16:49:47 <mjrosenb> calvinx: I would avoid using the word imperitave, but most of the time, thinking about them as evaluating sequentially is pretty good.
16:50:07 <mjrosenb> HeladoDeBrownie: oh, I thought you were talking about my example with l, and 1,1,1,1,1....
16:50:09 <calvinx> per HeladoDeBrownie’s point
16:50:29 <calvinx> mjrosenb: isn’t that just semantics?
16:50:43 <mjrosenb> calvinx: not really, you can't have multi-line statements inside of ghci
16:50:45 <calvinx> evaluating sequentially is the same as imperative
16:51:02 <mjrosenb> calvinx: you want let f = 1; f = 2;
16:51:09 <HeladoDeBrownie> calvinx, to demonstrate properly what I wrote, you'd either need to separate with ; or use ghci's line continuation syntax. Try writing it in a source file instead for a proper demo if you want to write multiple lines exactly like that
16:51:10 <calvinx> my bad
16:51:17 <aaronweiss74> calvinx: It resembles imperative code,but it is not itself truly imperative.
16:51:24 <calvinx> this  http://lpaste.net/116277
16:51:35 <HeladoDeBrownie> calvinx, yep, there you go
16:52:08 <mjrosenb> calvinx: do doesn't really have semantics, it is just some syntactic sugar.
16:52:11 <HeladoDeBrownie> (I actually couldn't remember how to do line continuations in ghci :P)
16:52:24 <calvinx> O. I see.
16:52:39 <calvinx> do is syntactic sugar
16:52:50 <calvinx> but it is finally something I am familiar with :D
16:53:05 <calvinx> it feel very imperative, python, C, golang like :D
16:53:06 <calvinx> haha.
16:53:09 <calvinx> *feels
16:53:26 <calvinx> step by step processing
16:54:53 <mjrosenb> > do {[x <- [1,2]; y <- ['a', 'b', 'c']; return (x,y) }
16:54:54 <lambdabot>  <hint>:1:8: parse error on input ‘<-’
16:55:02 <mjrosenb> > do {x <- [1,2]; y <- ['a', 'b', 'c']; return (x,y) }
16:55:04 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]
16:55:04 <HeladoDeBrownie> Depending on the specific Monad instance, it actually can represent sequentially executed programs. E.g, IO
16:55:19 <mjrosenb> calvinx: that is not very sequential at all.
16:55:50 <exio4> > do { x ← Just 2; y ← Just 3; return (x+y); }
16:55:51 <lambdabot>  Just 5
16:56:24 <calvinx> > >>
16:56:26 <lambdabot>  <hint>:1:1: parse error on input ‘>>’
16:56:31 <calvinx> > :type >>
16:56:32 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:56:37 <HeladoDeBrownie> :t (>>)
16:56:38 <lambdabot> Monad m => m a -> m b -> m b
16:56:48 <calvinx> > :type (>>)
16:56:49 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:56:57 <HeladoDeBrownie> (The > thingy just causes evaluation of expressions)
16:57:03 <calvinx> :t (>>)
16:57:04 <lambdabot> Monad m => m a -> m b -> m b
16:57:12 <calvinx> o damn, monad.
16:57:18 <calvinx> I haven’t reached that chapter yet :D
16:57:33 <calvinx> just got introduced to do blocks and <-
16:57:41 <aaronweiss74> That seems a little bit... backwards.
16:57:47 <HeladoDeBrownie> Those are sugar for (>>=), (>>), lambdas, and some other stuff
16:58:24 <HeladoDeBrownie> As I mentioned earlier: do { x' <- x ; f x' } = x >>= \x' -> f x'
16:58:24 <aaronweiss74> :t (>>=)
16:58:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:58:31 <calvinx> I see I see. Ok, will get freeze my brain with what all this monad thing is all about...
16:58:35 <HeladoDeBrownie> And do { x ; y } = x >> y
16:58:38 <calvinx> * will go
16:59:00 <aaronweiss74> Once you start understanding monads, I imagine do notation will make more sense.
16:59:02 <HeladoDeBrownie> I will warn you there is a tendency to overthink Monad. Anyway, have fun :)
16:59:12 <aaronweiss74> HeladoDeBrownie: An absolutely incredible tendency.
16:59:14 <calvinx> haha. thanks!
16:59:18 <calvinx> appreciate your help!
17:01:02 * hackagebot peyotls 0.1.6.4 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.4 (YoshikuniJujo)
17:08:36 <mjrosenb> calvinx: just read scrollback.  Monads are pretty simple and straightforward, just two things: monads are *not* do syntax, and for the love of god, don't start with the IO monad.
17:10:03 <Welkin> start with the Maybe monad
17:10:07 <Welkin> and the List monad
17:12:43 <uman> hi, does there exist scanl/scanr for monads?
17:13:14 <latro`a_> there's foldM and sequence, does that do the job?
17:13:22 <uman> which would be related to scanl in the same way mapM is related to map
17:13:54 <latro`a_> sequence seems like the pertinent "primitive"
17:14:02 <latro`a_> (it is for mapM too)
17:20:22 <nitrix> Are haskell git projects typically seen with the files at its root or in a subfolder like "src" ?
17:21:03 * hackagebot peyotls 0.1.6.5 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.5 (YoshikuniJujo)
17:21:26 <nitrix> Also, I tend to separate the different concerns of my application into modules; are Haskell modules suited for that?
17:21:30 <HeladoDeBrownie> nitrix, I tend to see the latter. You'll often see at the root project.cabal and Setup.hs and then a source directory containing the module structure
17:21:40 <HeladoDeBrownie> nitrix, yes, they are
17:22:26 <nitrix> HeladoDeBrownie: As long as the dependencies are linear, right? Because I tried for fun and with circular dependencies, GHC simply bails out.
17:22:42 <HeladoDeBrownie> You *can* do circular dependencies, but it's a pain. I'd avoid them if possible.
17:23:00 <nitrix> Good to know. Of course.
17:23:03 <HeladoDeBrownie> Technically nothing about the Haskell language itself says you can't do recursive modules, but GHC isn't good with them.
17:23:10 <nitrix> HeladoDeBrownie: Appreciated, thanks :)
17:24:13 <bllp> hi, quick question
17:24:24 <Welkin> how quick?
17:24:27 <bllp> i have this type:
17:24:29 <bllp> data Turing alpha omega = Turing alpha alpha omega (TransRel (alpha, omega) (alpha, omega, Move)) alpha (Tape omega)  deriving (Eq)
17:24:42 <bllp> and i'm trying to write a show instance, like this:
17:24:44 <bllp> instance Show (Turing alpha omega) where
17:24:44 <bllp>          show (Turing start end space trans current tape) = "state:   " ++ (show current)
17:25:10 <bllp> ghci doesn't like this at all. it won't show "current" because current is declared as a polymorphic type alpha
17:25:38 <bllp> i'm actually going to pass an Int  as current field
17:25:47 <bllp> any idea how i could print this item, assuming it's an int?
17:26:08 <HeladoDeBrownie> bllp, add a (Show alpha) constraint to the instance
17:26:19 <HeladoDeBrownie> instance (Show alpha) => Show (Turing alpha omega) where ...
17:27:08 <bllp> thank you so much :D, this works, i tried to add something like that in a lot of places alreday but didn't get the syntax right
17:27:11 <bllp> have a great day
17:27:14 <HeladoDeBrownie> You too
17:27:29 <nitrix> They should stay after getting help :(
17:27:36 <nitrix> So they can help someone else in turn D:
17:27:44 <HeladoDeBrownie> Maybe they're busy
17:36:04 * hackagebot hashable 1.2.3.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.3.0 (JohanTibell)
17:36:31 <zmoazeni> Hi folks, I’m getting some linker trouble with cabal sandboxes. Does this sound familiar at all? https://gist.github.com/zmoazeni/b68c66f5e15654948946
17:37:05 <zmoazeni> I found something like this on the mailing list and I’m following the instructions, but it’s not working https://gist.github.com/adinapoli/d4c33a9d1ea85bcaebdf
17:38:53 <marchdown> what does ~ mean in Data.List definition of select: select p x ~(ts,fs) | p x ...
17:38:57 <marchdown> ?
17:39:33 <marchdown> And where am I supposed to look before asking?
17:39:56 <HeladoDeBrownie> marchdown, irrefutable pattern. It defers matching until ts or fs is needed.
17:40:11 <HeladoDeBrownie> marchdown, it's hard to look up things like that, but now that you have a name, you can read more in the report if you like.
17:40:39 <HeladoDeBrownie> This chapter may help https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
17:41:17 <HeladoDeBrownie> Actually "defers matching" is wrong; it always success at matching. But it diverges if it got it wrong. You don't need to worry about that with tuples though since they have only one constructor.
17:41:31 <HeladoDeBrownie> succeeds*
17:43:19 <marchdown> thanks. I would like to see the reasoning behind it (other than helping write lazy code), but that's as good place to start as any.
17:43:44 <HeladoDeBrownie> It's often used to make code not more strict than it needs to be
17:44:11 <marchdown> Doesn't that contradict laziness-by-default?
17:44:23 <HeladoDeBrownie> Doesn't what?
17:45:35 <HeladoDeBrownie> Basically some places where you use patterns matches them strictly and other places not. I don't know the exact design decisions behind it, but you do have tools like ~ to make a pattern non-strict.
17:45:36 <marchdown> Introduction of a syntactical feature to enforce laziness? It makes it explicit, which means that we default to being strict here.
17:48:50 <_Vi> Can System.Plugins from direct-plugins-1.1 be used in a stand-alone portable application or it requires Haskell Platform to be installed?
17:56:06 * hackagebot atlassian-connect-core 0.2.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.2.0.0 (RobertMassaioli)
18:01:44 <ReinH> _Vi: nothing requires the platform
18:01:59 <ReinH> _Vi: Packages have dependencies in other specific packages which will be installed by cabal
18:02:02 <ReinH> s/in/on
18:02:57 <ReinH> marchdown: pattern matches are not lazy by default. This makes them lazy.
18:02:58 <_Vi> I got used that ghc (on Windows, for example) produce convenient exe files which just runs out of the box on other systems. How do plugins affect this?
18:03:21 <ReinH> _Vi: Unsure.
18:04:07 <_Vi> I don't see the "file path of dll to safely load plugin from" option...
18:10:00 <_Vi> If a program wants to compile and run some Haskell modules (which can depend only on limited set of libraries), must the entire Haskell platform be included into it, or it can be just some part?
18:10:44 <mjrosenb> _Vi: you almost certainly don't need the whole platform.
18:11:06 * hackagebot atlassian-connect-core 0.3.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.3.0.0 (RobertMassaioli)
18:11:37 <_Vi> Can the compiler (including all optimisations) be embedded into the program, to keep it a one file?
18:12:13 <mjrosenb> _Vi: not that I know of.
18:12:52 <_Vi> I.e. my program wants to do "ghc -XSafe -shared SomeExternalCode.hs" and load this library, but also be portable.
18:14:12 <_Vi> (here "portable" means "can copy files to USB drive and launch on neighbouring system" in addition to "support WIn,Lin,OSX")
18:15:10 <mjrosenb> _Vi: I don't think ghc has a dependable cross compiler, so that may be difficult.
18:15:33 <mjrosenb> as long as "neighbouring system" may not have the same OS.
18:15:44 <_Vi> Cross-compiling is not needed. The program should carry compiler to make its own plugins.
18:16:09 <ReinH> I've never seen anyone try to embed GHC into an executable, so you're on untrodden ground.
18:16:50 <Hijiri> the GHC distribution with no libraries is pretty big on its own
18:16:52 <ReinH> Generally, cabal projects don't need all of the platform: they only need to install their dependencies.
18:16:57 <_Vi> System.Eval.Haskell from "plugins" seem to call "ghc". Making it internal instead of external seems logical.
18:17:01 <Hijiri> I haven't checked home much space it actually takes up when installed though
18:17:38 <Hijiri> you could probably install ghc with the prefix being the top level of the usb stick or something
18:17:52 <Hijiri> or inside the program's folder, or whatever
18:18:01 <Hijiri> and then try to run it in that environment
18:18:28 <ReinH> I'm not sure that `plugins' makes any claims towards portability
18:18:37 <_Vi> Can ghc be told where its home directory does reside using environment variable (or command line parameter)?
18:19:05 <Hijiri> I think there's an environment variable, I don't remember though
18:19:12 <Hijiri> cabal sandboxes manipulate it
18:20:13 <ReinH> _Vi: You can look in the user guide https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
18:21:07 <_Vi> GHC_PACKAGE_PATH ?
18:22:36 <monochrom> what does "ghc's home directory" mean? technically nothing is called that. so what do you mean?
18:24:37 <porges> are there any short descriptions of what an 'untouchable' type variable is?
18:25:12 <Hijiri> it does dirty jobs
18:25:48 <Hijiri> actually I've never heard 'untouchable' used in the context of type variables
18:26:00 <Hijiri> maybe it could mean universally-quantified?
18:26:11 <Hijiri> or existential
18:26:24 <porges> i found https://ghc.haskell.org/trac/ghc/ticket/9223 which basically just says "understand the OutsideIn algorithm"
18:36:07 * hackagebot persistable-record 0.0.1.2 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.0.1.2 (KeiHibino)
18:36:46 <prinsen> When i compile with -fno-code I get the error
18:36:47 <prinsen> ByteCodeLink.lookupCE
18:36:48 <prinsen> During interactive linking, GHCi couldn't find the following symbol: THziAPI_generateAPIs_closure
18:37:11 <prinsen> It seems like GHC continues with linking even with -fno-code
18:38:21 <athan> Is there anything "in-between" a multiparameter typeclass and functional dependencies? Something like unique inference, but with flexible & constrained instances?
18:38:48 <athan> prinsen: I've had a similar issue between linked sandboxes :/
18:40:09 <prinsen> athan: seem to be a bug
18:41:44 <fread2282> is there any FRP lib that allows multiple arbitrary data sources and builds an AST or something that I can inspect to see what sources it uses?
18:44:36 <platz> fread2282: i think all the haskell-inspired libs allow multiple sources; maybe the kind of 'arrowized' frp libs are better for inspection
18:45:28 <fread2282> platz: but do they optimize it to callback code?
18:45:45 <platz> fread2282: not sure
18:46:08 * hackagebot atlassian-connect-core 0.4.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.4.0.0 (RobertMassaioli)
18:46:50 <xplat> there was one library that was arrowized with special arrows for SUPER optimization.  but i dunno if they got around to actually optimizing the things before the company ran out of money and it's not open source
18:46:58 <porges> solved my problem by replacing "(forall m. (B m, m ~ P) => t) -> t" "((B P) => t) -> t", doh
18:47:58 <xplat> i would feel bad pinging the person here who was involved tho since this person is here like way often anyways
18:54:03 <mmachenry> This simple test of hsyslog is printing to STDERR as expected but it doesn't create anything in my /var/log directory. Does anyone know why? http://lpaste.net/116280
19:17:30 <bitemyapp> what's the right way to express alternate options for a build depends, given a range of base / GHC versions?
19:17:57 <bitemyapp> Cabal can't intersect the versions in my package for 7.6, builds fine on 7.8.
19:18:06 <bitemyapp> creating a custom flag for this feels silly, like I'm missing something.
19:20:36 <bitemyapp> the answer is impl.
19:22:24 <liyang> Is there a channel for Pipes?
19:23:28 <HeladoDeBrownie> liyang, this one. Alternatively, you can email Tekmo.
19:23:33 <xplat> not afaik.  Gabriel isn't a big IRCer, when he is on he goes by Tekmo
19:23:42 <HeladoDeBrownie> I've emailed with him before, he's quite responsive and helpful.
19:24:15 <liyang> Ah okay. Was just wondering whether there was a more real-time alternative to the mailing list.
19:24:32 <xplat> often one or more of the other major peeps on the ML are here though
19:25:21 <liyang> I suppose if I do ask questions there I'm likely to actually spend the time phrasing things better.
19:38:44 <johnw> liyang: what questions do you have?
19:40:21 <liyang> johnw: none so far. I just wanted some code critiqued…
19:41:57 <johnw> liyang: I would love to take a look
19:42:16 <liyang> It being my first foray into Pipes, having buried my head in sand from conduits or iteratees for all these years.
19:42:29 <johnw> I am currently transitioning over to using pipes in all of my code, after having used conduit for a while
19:46:29 <platz> I found it interesting that some new work (such as one of the Stripe libs) was rewritten from conduit to io-streams
19:46:56 <platz> i.e. for simple libraries, is it necessary to interleave io operations with other monadic effects
19:47:24 <platz> even though pipes is clearly more powerful
19:47:57 <johnw> I'm going to be rewriting simple-conduit as pipes-simple, and then you will have yet another option for much simpler streaming, in those cases where the full power of pipes is not needed and yet you want a similar interface to streaming of effects
19:48:23 <johnw> Tekmo and I have talked about a way to integrate it that would make the use of such simplified libraries pretty seamless with full pipes
19:48:45 <johnw> kind of like how you can code against lens-family, and yet still allow people to use lens if they prefer
19:50:26 <platz> hrm that sounds nice.  what did you think of his 'library-agnostic streaming sources' post? too general to be of use in a practical steaming library?
19:50:30 <dfeuer> johnw++
19:50:39 <platz> i.e. MonadPlus
19:50:39 <johnw> platz: I haven't read it yet
19:51:04 <platz> ahh
19:51:15 <ReinH> johnw: nice!
19:53:15 <dfeuer> Anyone want to talk data structures? I'm trying to understand why replicate and replicateA in Data.Sequence prefer Three and Four digits rather than Two and Three digits.
19:54:21 <HeladoDeBrownie> dfeuer, what do you mean about digits?
19:54:26 <crundar> basic first-time question.
19:54:33 <johnw> crundar: shoot
19:54:34 <dfeuer> I would think that preferring Two and Three digits would make the tree more flexible, allowing more deque-like operations before needing deep restructuring.
19:55:24 <dfeuer> HeladoDeBrownie, 2-3 fingertrees are based loosely on a "numeric representation", so certain pieces sort of represent digits in a weird sort of number system.
19:55:37 <crundar> after I cabal install cabal-install, it says I've installed cabal-install-1.20.X.Y, but when I then do cabal --version, it says I'm on cabal-install version 1.18.0.5. Do I need to set something else to path? Where's the new location of the newly installed one? Or how do I find it?
19:55:40 <dfeuer> *finger trees
19:55:45 <HeladoDeBrownie> Ah, no idea about that then
19:55:52 <dfeuer> crundar, yes, path.
19:56:15 <HeladoDeBrownie> crundar, add $HOME/.cabal/bin to your PATH
19:56:17 <crundar> any ideas where I'd look for the new version?
19:56:19 <danclien> crundar: ~/.cabal/bin
19:56:29 <glguy_> Preferring 34 nodes would help with dequeue, wouldn't it. You wouldn't have to go as deep to get nodes at first
19:56:47 <glguy_> And the tree would be shorter and more compact
19:56:57 <dfeuer> glguy_, but once you want to insert something, boom.
19:57:01 <crundar> danclien: that location doesn't exist. Should that be expected
19:57:15 <dfeuer> glguy_, but yeah, it's more compact.
19:57:19 <HeladoDeBrownie> crundar, you didn't run it as root, did you?
19:57:22 <dfeuer> *sigh*
19:57:28 <glguy_> But it's only one boom and then you have room
19:57:39 <SparkySparkyBoom> ?
19:57:47 <HeladoDeBrownie> crundar, (that's not advice, don't run it as root)
19:57:58 <danclien> crundar: Listen to HeladoDeBrownie. :)
19:58:01 <crundar> HeladoDeBrownie: don't think so. I installed with haskell-platform, under my user on OS X
19:58:11 <dfeuer> glguy_, Milan Straka wrote the new "fromFunction" function to prefer 2-3 digits, and I wrote a patch that changed it, and then a patch that reverted, and now I feel like I don't have a clue which is better.
19:58:16 <crundar> so, doesn't look like it
19:58:21 <liyang> johnw: still WIP, but here: https://github.com/liyang/value-change-dump
19:58:30 <HeladoDeBrownie> crundar, no, I meant the cabal install cabal-install command. Although I think we were assuming you were on Linux. I haven't the faintest about OS X
19:58:46 <HeladoDeBrownie> crundar, presumably it will go wherever application files usually go
19:58:55 <crundar> there is a .cabal file
19:58:58 <HeladoDeBrownie> user-local application files, that is
19:59:01 <HeladoDeBrownie> That's not what you need
19:59:02 <crundar> err... directory
19:59:05 <HeladoDeBrownie> Ah, yes
19:59:12 <HeladoDeBrownie> Is there a bin in there?
19:59:13 <crundar> and there's a wheres-my-stuff.txt file. Investigating
19:59:27 <johnw> liyang: how come states has type Producer (Time, a) m r -> Producer (Duration, a) m r rather than Pipe (Time, a) m (Duration, a) r?
19:59:32 <HeladoDeBrownie> If you found a .cabal and it contains bin, great, add that bin directory to your PATH
19:59:36 <danclien> crundar: I prefer using ghcformacosx.github.io over Haskell Platform.
19:59:52 <liyang> johnw: also https://gist.github.com/liyang/23e879906551207061d1 if you want to try the example.
19:59:54 <glguy_> Dfeuer, I'd have to measure it. I just think that the preference wouldn't matter in the long term
20:00:20 <crundar> danclien: any obvious reason?
20:00:26 <liyang> johnw: because I want to yield a final state after the (Time, a) stream has terminated…
20:00:50 <johnw> liyang: ah
20:00:53 <liyang> johnw: that's the only way I could see how to do it…
20:01:21 <crundar> close the terminal, reopen the terminal :)
20:01:30 <HeladoDeBrownie> \o/
20:01:49 <HeladoDeBrownie> So it's picking up the latest cabal now?
20:02:15 <liyang> johnw: having read one Snoyberg's blog posts, I get the impression that's the only way to do it too. Am I on the right lines?
20:02:19 <crundar> HeladoDeBrownie: sure is. now for idris.
20:02:20 <liyang> *one of
20:02:22 <danclien> crundar: Updated more often (may be equally quick now). Fewer libraries included out of box so less issues with dependencies (for my anyways).
20:02:26 <johnw> liyang: which post?
20:02:32 <nitrix> Hey guys, I've used fpcomplete.com for the past couple days and I think it's brilliant. The most useful are the hints sometimes, like () unecessary or sequence . map into mapM, etc. I also like being able to select expressions to know their types.
20:02:43 <nitrix> Is there any equivalent you'd recommend for vim, ideally?
20:02:58 <nitrix> And, does GHC has those hints?
20:03:04 <HeladoDeBrownie> nitrix, I don't know about vim but lots of people seem to like haskell-mode for emacs
20:03:52 <Welkin> haskell-mode is nice
20:04:02 <Welkin> not perfect, but it works well
20:04:03 <glguy_> Nitric, those tips might be generated by hlint
20:04:17 <Welkin> I'd prefer slightly different formatting but cannot be bothered to change it
20:04:35 <Welkin> for example, having the | line up with the = in a data declaration
20:04:49 <liyang> johnw: took me a while to find it again: http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit
20:04:50 <Welkin> as well as <|>
20:04:52 <nitrix> glguy_: hlint?
20:05:07 <nitrix> Source code suggestions. Yeah that might be it!
20:05:11 <nsxt> noob here. is there a way to eliminate the lambda from this expression? xor = foldr (\_ acc -> not acc) False . filter id
20:05:54 <platz> nitrix: ghc-mod will give you types of exprs in vim. (w/ ghcmod-vim).  I also install haskellmode-vim, and neco-ghc gives autocompletion
20:06:09 <Welkin> nsxt: you could use arrows
20:06:15 <Welkin> the function `second`
20:06:19 <Welkin> :t second
20:06:20 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
20:06:36 <platz> nitrix: http://haskelllive.com/environment.html has some links
20:06:38 <nsxt> Welkin: i'm not quite there yet, but i'll research that, thank you!
20:07:04 <glguy_> Nsxt: you can use const, but you don't necessarily get points for eliminating lambdas
20:07:23 <nsxt> i'm slightly baffled why an expression like sum' = foldl (+) 0  works... is it because of the "arity" of (+)?
20:07:43 <nsxt> (whereas something like foldr (not) ... doesn't)
20:07:44 <danclien> > 2 + 3
20:07:45 <lambdabot>  5
20:07:48 <johnw> liyang: I see, you want the return value from your producer to be dependent on the return value from another producer, whereas if you use a Pipe, you have one or the other but no interaction
20:07:49 <danclien> > (+) 2 3
20:07:51 <lambdabot>  5
20:07:59 <Welkin> because the folding function takes two parameters
20:08:03 <Welkin> :t foldr
20:08:04 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:08:08 <Welkin> a and b
20:08:15 <Welkin> :t not
20:08:16 <lambdabot> Bool -> Bool
20:08:20 <Welkin> they don't match
20:08:23 <Welkin> :t (+)
20:08:25 <lambdabot> Num a => a -> a -> a
20:08:25 <nsxt> okay, i figured as much
20:08:28 <Welkin> that does
20:08:30 <nsxt> thanks for the clarification
20:08:48 <glguy_> :t foldr (const not)
20:08:49 <lambdabot> Bool -> [a] -> Bool
20:08:53 <nsxt> can one speak of "arity" in Haskell, or is there a better term for that
20:09:27 <dmj`> arity is the number of parameters a function or kind has
20:09:33 <dmj`> er type
20:09:35 <nitrix> Arity seems fine, it's not limited to haskell.
20:09:51 <dmj`> I guess kinds can have arity too
20:10:11 <nsxt> right, but with currying, it seems that it's technically wrong to say something like foldr has an arity of two
20:10:18 <liyang> johnw: actually no, the yield (maxBound a0) part is what I really wanted.
20:10:34 <liyang> johnw: otherwise the last state change is never output.
20:10:36 <dfeuer> glguy_, yeah, probably going to depend on exactly how the thing is used.
20:10:39 <nsxt> errr... the folding function*
20:10:57 <nitrix> nsxt: It depends how you present it. The function keeps its arity, the partially applied function wont.
20:10:58 <dfeuer> Arity is a bit strange in Haskell.
20:11:08 <johnw> liyang: ah, I see, this is how you are detecting termination of upstream
20:11:15 <liyang> johnw: I figured maxBound was as good as forever.
20:11:23 <dfeuer> Because Haskell lets functions be bottom.
20:11:47 <johnw> I can't say whether this is the right way to do it, but it makes sense to me
20:13:10 <nsxt> glguy_: can you explain what you mean by not eliminating the lambda when using const?
20:14:26 <liyang> johnw: one thing I'm not sure about is… whether my implementation of Data.VCD.parse.{decs,sims} is idiomatic or not.
20:15:43 <glguy> nsxt: I was saying that you can eliminate the lambda using const like this:  foldr (const not), but that eliminating lambdas doesn't necessarily mean you code is more clear
20:16:14 <johnw> isn't Producer Declaration (StateT (Producer ByteString m ()) m) the same thing as Producer Declaration (Parser ByteString m)?
20:16:16 <ReinH> crundar: I think maybe Haskell Platform puts it in some non-standard place
20:16:23 <johnw> (where Parser is from Pipes.Parse)
20:16:43 <liyang> johnw: that's what the comment alludes to. But try actually writing it. :)
20:16:45 <nsxt> glguy: oh, sorry... misunderstood you. thank you.
20:16:53 <ReinH> nitrix: Those hints come from hlint and you can use something like Syntastic with vim to run hlint for you
20:17:07 <liyang> johnw: GHC complains because type Parser … isn't fully applied.
20:17:14 <johnw> ah, yes
20:17:19 <johnw> that aspect of type synonyms
20:17:44 <liyang> And you can't just change the definition of type Parser upstream, because of that forall.
20:22:39 <evanrthomas> hi all, i'm a new haskell user
20:22:47 <evanrthomas> also, this is my first time using irc
20:22:58 <evanrthomas> I have a general question about types in haskell
20:23:05 <evanrthomas> is this the correct place to ask?
20:23:08 <HeladoDeBrownie> Yep, go ahead
20:23:28 <evanrthomas> cool, ok so as one of my first project in haskell, just to get my feet wet
20:23:37 <evanrthomas> i'm building an expression evaluator
20:23:44 <evanrthomas> I want a Token type
20:23:51 <evanrthomas> made up of other types
20:23:57 <evanrthomas> what I really want to do is
20:24:06 <evanrthomas> data Parens = OpenParens | CloseParens
20:24:17 <evanrthomas> data Operator = Plus | Minus | Mult
20:24:26 <HeladoDeBrownie> Just so you know, in general, IRC users frown on using the enter key as punctuation
20:24:28 <evanrthomas> data Token = Parens | Operator | Int
20:24:38 <HeladoDeBrownie> and for code of multiple lines there's lpaste, linked in the topic
20:24:48 <evanrthomas> ok thanks
20:24:57 <evanrthomas> anyway
20:25:11 <evanrthomas> when I do data Token = Parens |Operator | Int
20:25:24 <evanrthomas> ghc interprets the things on the rhs as constructors correct?
20:25:31 <HeladoDeBrownie> Correct
20:25:51 <HeladoDeBrownie> Parens, Operator, Int :: Token
20:25:58 <evanrthomas> so what i'd like to say is "a token is anything that's a Parens or Operator or Int"
20:26:02 <HeladoDeBrownie> (I.e., Parens, Operator, and Int are all values of type Token)
20:26:05 <evanrthomas> so that I can have a function
20:26:09 <evanrthomas> that returns a a token
20:26:15 <evanrthomas> or I can have a list of tokens
20:26:20 <HeladoDeBrownie> Well one thing you could do is: data Token = ParensToken Parens | OperatorToken Operator | IntToken Int
20:26:31 <HeladoDeBrownie> I added the word Token to the constructor names, although that's not strictly necessary
20:26:35 <evanrthomas> yea, so a friend told me to do that
20:26:38 <HeladoDeBrownie> I think it enhances clarity though
20:26:40 <evanrthomas> but that seems really nasty
20:26:54 <evanrthomas> suppose I want to extend my Token class
20:26:54 <HeladoDeBrownie> It's how things are often done. What would you have preferred?
20:27:02 <HeladoDeBrownie> Token is a type, not a class like you have in OO
20:27:12 <HeladoDeBrownie> Types are closed
20:27:16 <evanrthomas> now I want to include derivatives and integrals and all sorts of other things
20:27:35 <evanrthomas> it seems nasty to have all these seperate constructors
20:27:51 <evanrthomas> actually, here's a better complaint
20:28:09 <evanrthomas> suppose I have a function charToOperator
20:28:14 <HeladoDeBrownie> Well, there are certain ways to make it more open-ended, although it depends partly on what you want
20:28:22 <evanrthomas> that just takes a character and returns the operator it has
20:28:34 <HeladoDeBrownie> The operator it has?
20:28:35 <evanrthomas> sorry, takes a character and returns the operator it represents
20:28:38 <HeladoDeBrownie> Okay
20:28:42 <HeladoDeBrownie> So Char -> Maybe Operator
20:28:46 <evanrthomas> now i'm already using that in a bunch of code somewhere
20:29:05 <evanrthomas> yes, Char -> Maybe Operator
20:29:20 <evanrthomas> now I want to have a list of Tokens
20:29:53 <evanrthomas> so I want to say tokenlist = tokenlist ++ [charToOperator operatorCharacter]
20:30:19 <evanrthomas> I wont be able to do that because tokenlist has type Token a
20:30:24 <HeladoDeBrownie> You'd have to perform a couple of transforms on the second operand
20:30:35 <evanrthomas> but charToOperator has type Operator
20:30:43 <evanrthomas> what I really want is java like interfaces
20:30:56 <HeladoDeBrownie> Mmm, didn't you just say charToOperator :: Char -> Maybe Operator ?
20:31:00 <evanrthomas> where a function can return something of whatever type it likes
20:31:24 <evanrthomas> and other functions can interpret that as any supertype of that return type
20:31:25 <HeladoDeBrownie> Well we have something like that in Haskell, but let's go through the requirements first
20:31:39 <HeladoDeBrownie> For now, don't think in terms of classes or inheritance, just the result you want
20:32:15 <HeladoDeBrownie> So, for one thing, it looks like you want to mutate tokenlist? That's not the way we do that in Haskell
20:32:35 <rofer> Wow, #haskel forwards here. That's pretty convenient.
20:32:39 <HeladoDeBrownie> Maybe you could provide some code for context? Use lpaste
20:32:51 <evanrthomas> not actually
20:33:01 <evanrthomas> the tokenlist = tokenlist ++ was bad
20:33:04 <HeladoDeBrownie> Okay
20:33:07 <evanrthomas> i'm just trying to build up a list
20:33:24 <HeladoDeBrownie> What are you building up the list based on?
20:33:29 <platz> i'd think it's okay if it's just shadowing the previous binding
20:33:31 <evanrthomas> a string
20:33:55 <HeladoDeBrownie> So you have a function String -> ? What do you want from the String?
20:34:12 <HeladoDeBrownie> (I just wrote ? because I don't know what type you want, that's not actual syntax)
20:34:27 <evanrthomas> how do I use that lpaste command you gave me?
20:34:31 <evanrthomas> i've never used irc before
20:34:43 <evanrthomas> i'll just post the whole function that I want to write
20:34:46 <HeladoDeBrownie> Do you see the link in the topic? Depending on your client, the topic may be displayed at the top of your window.
20:34:58 <HeladoDeBrownie> It says http://lpaste.net/new/haskell
20:35:39 <rofer> Quick question, I'm writing an application I want to be able to handle HTTP requests. Am I going to want to use something like happstack?
20:36:02 <rofer> I'm not actually hosting an webpages, just proving info to JS running elsewhere.
20:36:04 <HeladoDeBrownie> Anyway, showing off a function that makes guesses at how to do things is often less helpful than talking through what type and other information about the function you want
20:36:13 * hackagebot markup 0.0.3 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.3 (athanclark)
20:36:15 * hackagebot atlassian-connect-descriptor 0.2.0.1 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.2.0.1 (RobertMassaioli)
20:36:25 <evanrthomas> I see the link
20:36:32 <evanrthomas> but it's not very helpful
20:36:36 <HeladoDeBrownie> How so?
20:36:37 <evanrthomas> I paste the code into there
20:36:41 <evanrthomas> but the result isn't a command
20:37:10 <HeladoDeBrownie> You should be able to enter code there, hit Private or Public, and get a new page whose url you can paste here.
20:37:13 <geekosaur> no, it's there so other people can read your code
20:37:36 <geekosaur> because pasting directly into the channel is (a) obnxious (b) hard to read the code because of fonts, interspersed comments from others, etc.
20:37:43 <evanrthomas> ah I see, I thought it was a command to run that posted multiple lines or something
20:37:44 <evanrthomas> http://lpaste.net/116289
20:37:55 <platz> rofer: happstack, snap, scotty will all do that.  If you don't need a lot of routing or component logic maybe just wai and perhaps wai-routes
20:37:55 <geekosaur> some clients interpret random things as smilies or whatever (ugh)
20:37:57 <evanrthomas> by the way, thanks for being patient with me
20:38:10 <evanrthomas> forget about line 9
20:38:10 <HeladoDeBrownie> Yep
20:38:30 <HeladoDeBrownie> Okay, so this is sort of what I was talking about, it makes guesses about how to do things, when I think in this case it'd be more helpful to talk through what you want
20:39:02 <evanrthomas> ok sure
20:39:06 <HeladoDeBrownie> So, revisiting my earlier question: You have a String. What do you want from the String?
20:39:06 <rofer> platz: Yeah, I don't think I need much fancy routing. I just want to respond to HTTP requests with JSON
20:39:15 <evanrthomas> ahhh, what I want is a tokenize function
20:39:22 <benzrf> ok so i figured out that its almost trivial to write a polymorphic bind that autolifts or not depending on the result type of the kleisli arrow
20:39:35 <HeladoDeBrownie> That's what we're discussing. Assume you have a String. What do you want to do with it?
20:39:36 <evanrthomas> that takes a string
20:39:44 <evanrthomas> and just returns a list of some type
20:39:44 <benzrf> i-is there a reason this is apparently never used?
20:39:54 <HeladoDeBrownie> What should be in the list?
20:40:00 <evanrthomas> I haven't thought through much of what I want the objects to do
20:40:14 <evanrthomas> but I want them to all be Token Objects
20:40:25 <evanrthomas> so later if I want to add some method to all tokens
20:40:26 <HeladoDeBrownie> Okay, so you want String -> [Token], correct?
20:40:31 <evanrthomas> it's easy to do that
20:40:37 <Welkin> ...?
20:40:38 <evanrthomas> yes
20:40:42 <Welkin> methods and objects?
20:40:46 <evanrthomas> also, before we go on
20:40:49 <Welkin> this isn't OOP
20:40:52 <evanrthomas> i'm using webchat.freenode.net
20:40:55 <HeladoDeBrownie> So, do you basically just want to go through and pull out all the tokens you see in the String?
20:40:57 <evanrthomas> and this is a real pain
20:41:10 <platz> rofer: there aren't any solid answers, ppl have their favorites.  imho i'd go with either scotty or wai+wai-routes
20:41:12 <evanrthomas> firstly, it doesn't scroll down whenever someone posts a new line
20:41:28 <HeladoDeBrownie> You could try using xchat. There are also various other options. I use irssi but it's not to everyone's tastes
20:41:35 <evanrthomas> secondly i'm getting all these notifications about people loggin in and out and all sorts of other garbage
20:41:37 <rofer> platz: Looking at wai right now, thanks!
20:41:45 <HeladoDeBrownie> Yeah, that happens. Some clients let you hide those.
20:41:45 <Welkin> evanrthomas: that is normal
20:41:55 <Welkin> evanrthomas: have you never used IRC?
20:41:55 <platz> rofer: but I don't release a lot of haskell software either ;)
20:42:02 <evanrthomas> ok cool, i'll look at those once we're done here
20:42:09 <evanrthomas> so let's continue I guess
20:42:12 <HeladoDeBrownie> Okay.
20:42:21 <evanrthomas> I want a String -> [Token] function
20:42:22 <HeladoDeBrownie> So what should your tokenize function "do"?
20:42:58 <evanrthomas> It should take something of the form "1 + (2 -3)"
20:43:02 <evanrthomas> ignore all the whitespace
20:43:08 <evanrthomas> and return an array
20:43:21 <evanrthomas> [1, +, (, 2, -, 3]
20:43:21 <HeladoDeBrownie> Is part of your goal specifically to write a parser from scratch?
20:43:27 <evanrthomas> yes
20:43:31 <evanrthomas> i do want to write it from scratch
20:43:37 <HeladoDeBrownie> Because there are options out there, like parsec, that make this much easier
20:43:40 <evanrthomas> the point of this is to get my feet wet
20:43:43 <HeladoDeBrownie> Okay
20:43:51 <evanrthomas> a friend of mine told me about parsing libraries
20:44:03 <evanrthomas> but that would defeat the purpose of learning about haskell
20:44:18 <evanrthomas> anyway, once I have the array of tokens
20:44:19 <HeladoDeBrownie> Not necessarily, but if it's your goal to do this from scratch, it's up to you
20:44:32 <Welkin> why not create something useful?
20:44:38 <evanrthomas> i'll write another function, evaluate
20:44:42 <Welkin> there are better project for learning haskell
20:44:45 <Welkin> like writing a game
20:44:49 <Welkin> or writing a DSL
20:44:51 <evanrthomas> of type [Token] -> Int
20:44:59 <HeladoDeBrownie> Welkin, this is for a DSL, according to what they said
20:45:09 <Welkin> well, you can use PArsec or Attoparsec to write the DSL
20:45:16 <HeladoDeBrownie> Welkin, they actually said expression evaluator or something along those lines
20:45:18 <HeladoDeBrownie> But yeah
20:45:31 <evanrthomas> sure, i'll write something useful later
20:45:33 <glguy_> He's got something he wants to learn how to do. Stand back and let heraldo help
20:45:39 <Welkin> you can look at the source for Parsec to learn how it works
20:45:42 <HeladoDeBrownie> evanrthomas, okay, cool. Seems doable. Let's talk about this tokenize function real quick though. What happens if you get invalid input?
20:46:09 <HeladoDeBrownie> Say you receive "1 + a - 2"
20:46:18 <HeladoDeBrownie> Presumably 'a' is an invalid token, right?
20:46:31 <evanrthomas> so as I understand you can return error in haskell correct? or something like that
20:46:34 <evanrthomas> so maybe i'll do that
20:46:41 <evanrthomas> or maybe i'll return Maybe [Token]
20:46:42 <HeladoDeBrownie> You *can*, but that doesn't mean it's a good idea most of the time
20:46:47 <HeladoDeBrownie> Yes, Maybe [Token] would be better
20:46:50 <evanrthomas> instead of [Token]
20:47:02 <evanrthomas> ok then, let's do that
20:47:18 <HeladoDeBrownie> Okay, sounds good. But, what if your input is empty? There are no invalid tokens, there are just none at all.
20:47:18 <evanrthomas> tokenize is now String -> Maybe [Token]
20:47:21 <HeladoDeBrownie> "" is your input
20:47:38 <evanrthomas> then I would return Nothing
20:47:50 <evanrthomas> anything that isn't a valid expression
20:47:55 <evanrthomas> will return Nothing
20:48:14 <HeladoDeBrownie> Well, part of the problem is you can't necessarily know at the tokenisation stage what ends up forming a valid expression.
20:48:32 <HeladoDeBrownie> Normally, parsers that tokenise also have a step where they build up ASTs from those tokens.
20:48:46 <HeladoDeBrownie> (Parser in general generally build ASTs, for that matter)
20:49:17 <HeladoDeBrownie> Are you familiar with the concept of ASTs?
20:49:31 <evanrthomas> yes
20:49:38 <evanrthomas> i'm thinking about this
20:49:45 <evanrthomas> if it would solve my problem
20:49:59 <HeladoDeBrownie> So, I would say it's not an error at the tokenisation stage to have no tokens. It would be Just []. But then we need another stage of processing.
20:50:12 <HeladoDeBrownie> That's where we give actual structure to the expression.
20:50:27 <HeladoDeBrownie> Effectively, we'd have [Token] -> AST
20:50:34 <joe9> error: http://codepad.org/Vz40d3qu , source: http://codepad.org/MnlYvY10 . I cannot figure out what I am missing. Any help, please?
20:50:46 <evanrthomas> so if I want a function that builds an AST from [Token]
20:51:06 <evanrthomas> I still need something that returns [Token]
20:51:22 <evanrthomas> it doesn't help to have final = buildAST . tokenize
20:51:34 <evanrthomas> because tokenize runs into the same problem it did before
20:51:36 <HeladoDeBrownie> Sure, and tokenise :: String -> [Token] can do that for you. But then you compose that with parse :: [Token] -> Expr (or AST or whatever you wanna call it)
20:51:49 <HeladoDeBrownie> compose . tokenise :: String -> Expr
20:51:59 <HeladoDeBrownie> Errr
20:52:04 <HeladoDeBrownie> parse . tokenise *
20:52:11 <HeladoDeBrownie> Mixed up the words in my head :P
20:52:22 <HeladoDeBrownie> . stands for function composition
20:52:38 <HeladoDeBrownie> Actually woops, I got the types wrong there
20:52:46 <HeladoDeBrownie> Because we said tokenise :: String -> Maybe [Token]
20:52:52 <evanrthomas> that's fine
20:53:05 <evanrthomas> i understand what you're getting at
20:53:07 <mauke> joe9: your log returns a String. your groomLog is declared to return an 'a'
20:53:12 <HeladoDeBrownie> And for that matter, parse can fail. So really we have [Token] -> Maybe Expr
20:53:21 <evanrthomas> we still have a problem in tokenise :: String -> Maybe [Token]
20:53:34 <HeladoDeBrownie> So what we need is some way to compose String -> Maybe [Token] with [Token] -> Maybe Expr.
20:53:52 <evanrthomas> yes
20:53:59 <HeladoDeBrownie> And we have that. It's called (>=>).
20:54:09 <evanrthomas> what does that operator do?
20:54:16 <evanrthomas> i've never seen it
20:54:33 <evanrthomas> oh, sure
20:54:37 <joe9> mauke: got it, thanks.
20:54:38 <HeladoDeBrownie> Suffice to say for now that it lets you compose String -> Maybe [Token] and [Token] -> Maybe Expr into String -> Maybe Expr.
20:54:51 <evanrthomas> it just composes a Maybe A  with an A -> B
20:55:05 <HeladoDeBrownie> No, it composes A -> Maybe B with B -> Maybe C.
20:55:12 <evanrthomas> ok great
20:55:28 <HeladoDeBrownie> So we end up with: tokenise >=> parse
20:55:36 <evanrthomas> yes
20:56:08 <joe9> mauke: http://codepad.org/QeQFohLQ is there a better way of writing line 19?
20:56:16 <HeladoDeBrownie> Given that, do you have a better idea how to put this all together?
20:56:42 <HeladoDeBrownie> If you have any more questions, feel free to ask.
20:56:54 <evanrthomas> well I see now a nice way to move from tokenise to a final expression
20:57:02 <evanrthomas> but the original problem was never solved
20:57:08 <evanrthomas> which is ...
20:57:13 <prinsen> The function typeOf :: forall v a. (SubType v (ECMA a)) => v -> Type requires AllowAmbiguousTypes. As a isn't used in the function, can this be solved using RankNTypes?
20:57:14 <HeladoDeBrownie> You'll notice a lot that in Haskell we often ask what types of functions we need to move from one data type to another
20:57:26 <evanrthomas> I want tokenise to build a list of tokens
20:57:38 <evanrthomas> and I want to use constructors of other types
20:57:45 <evanrthomas> which happen to be instances of tokens
20:57:48 <HeladoDeBrownie> Ah, sure
20:57:50 <evanrthomas> sorry
20:57:54 <evanrthomas> happen to be instances of Token
20:58:00 <HeladoDeBrownie> No need to apologize, I took us on a track I thought would benefit you
20:58:04 <HeladoDeBrownie> Oh, okay
20:58:17 <evanrthomas> the only solution seems to be making
20:58:39 <evanrthomas> data Token = TokenParens Parens | TokenOperator Operator | TokenInt Int
20:58:46 <evanrthomas> but that's messy
20:58:49 <glguy> prinsen: Which package is that from?
20:58:54 <HeladoDeBrownie> For now, try to get a basic Token type together the way I mentioned. Then, if you want to make it more general later, you can ask here how to extend it.
20:58:59 <HeladoDeBrownie> Yes, doing that.
20:59:19 <prinsen> glguy: My own, and I want to support earier GHC versions
20:59:29 <HeladoDeBrownie> evanrthomas, the other thing is often that is exactly the sort of solution you want
20:59:29 <prinsen> glguy: that does not have that extension
20:59:40 <HeladoDeBrownie> You may not even need to extend it
20:59:42 <glguy> joe9: groomedLog s = do log (groom s); return s -- you can use a newline where the semicolon is
20:59:53 <prinsen> glguy: ecma262 (candidate on hackage)
21:00:16 <evanrthomas> I actually will probably never extend this
21:00:37 <evanrthomas> it's just a hello world project basically
21:00:43 <evanrthomas> that i'll throw away soon
21:00:51 <HeladoDeBrownie> Sure, but you could always grow it into something bigger for the sake of learning
21:01:03 <HeladoDeBrownie> I've even written my own general-purpose parsing libraries before for kicks
21:01:06 <evanrthomas> ok
21:01:17 <glguy> prinsen: I don't know how RankNTypes will help, but you could make the type unambiguous by adding a proxy parameter:   typeOf :: forall v a. (SubType v (ECMA a)) => proxy a -> v -> Type
21:01:19 * hackagebot brainfuck-monad 0.0.1 - BrainFuck monad  http://hackage.haskell.org/package/brainfuck-monad-0.0.1 (JoeyHess)
21:01:27 <evanrthomas> I think what i'm getting at thought is a fundamental limitation of haskell
21:01:43 <evanrthomas> I think what I want to do is something i'll often times want to do
21:01:49 <HeladoDeBrownie> evanrthomas, it's a fundamental limitation of closed datatypes, like the ones you're using. Haskell does have other solutions for other problems.
21:01:52 <prinsen> glguy: was thinking of typeOf :: forall v. (SubType v (forall a. ECMA a)) => v -> Type
21:01:54 <evanrthomas> and I can't do it cleanly
21:02:04 <evanrthomas> basically, I want a list of many different types
21:02:17 <evanrthomas> that all happen to have a common function defined on them
21:02:32 <HeladoDeBrownie> evanrthomas, then why not store the function or output thereof in the list?
21:02:36 <joe9> glguy, thanks.
21:03:10 <evanrthomas> i'm not sure I understand that
21:03:12 <Welkin> evanrthomas: just define TokenInt as Int with a type synonym
21:03:24 <Welkin> for your comment several lines up
21:03:26 <HeladoDeBrownie> evanrthomas, some other time, it won't help you much with this specific project, but you may want to read up on typeclasses. I was nervous to mention them earlier because they are sometimes overused, but they're good to know.
21:03:28 <prinsen> glguy: but thats not correct
21:03:47 <hodapp> hmm, interesting that PureScript is written in Haskell... I wonder if it exposes enough that one could use it within Haskell
21:03:56 <evanrthomas> I think typeclasses should be the way to go hear
21:04:06 <evanrthomas> i've read them in learnyouahaskell
21:04:36 <evanrthomas> learnyouahaskell says something to the effect of "typeclasses are simmilar to java interfaces"
21:04:36 <HeladoDeBrownie> evanrthomas, you implied you weren't planning on needing any other possible token types besides those you already mentioned, right?
21:04:45 <evanrthomas> if I were in java that's exactly what i'd do
21:04:45 <glguy> evanrthomas: If you want to vary function implementations for the various elements of a list you can also make a record that has functions in it a bit like virtual function tables in an OO context
21:04:48 <HeladoDeBrownie> That's a gross simplification, but sure
21:05:32 <evanrthomas> suppose for example, I want to allow multiple string representations for each token
21:05:51 <evanrthomas> so
21:05:58 <evanrthomas> when i'm tokenising
21:06:06 <evanrthomas> if I run across a {, [, or (
21:06:13 <evanrthomas> i'll interpret it as an OpenParens
21:06:21 <evanrthomas> and if I see a + or a ++
21:06:26 <hodapp> "What would I do if I were in Java?" is hardly a good way to find a solution...
21:06:28 <evanrthomas> i'll interpret it as a plus
21:06:51 <evanrthomas> so now it turns out that I want to have this "multiple representation" thing for all my tokens
21:07:01 <evanrthomas> but when I print out an expression I want it standardized
21:07:06 <glguy> evanrthomas: If you want your tokenizer to be more flexible, you might add extra arguments to it to configure it's behavior
21:07:08 <evanrthomas> so I define a function
21:07:20 <evanrthomas> tokenToStandardPrint :: Token -> String
21:07:34 <evanrthomas> which no matter what kind of OpenParens it gets
21:07:44 <evanrthomas> that is, "(", "{", or "["
21:07:52 <evanrthomas> it always prints out "("
21:08:06 <evanrthomas> this example is a bit convoluted
21:08:14 <evanrthomas> sorry about that, making it up on the fly
21:08:27 <evanrthomas> anyway, I want to make a function, prettyprint
21:08:36 <evanrthomas> prettyprint [Token] -> String
21:08:42 <HeladoDeBrownie> I've basically made the suggestion I'm going to stick with. I don't think you need to fiddle with typeclasses for this project.
21:09:13 <evanrthomas> which just does something like prettyprint = join " " (map standardTokenRepresentation tokenlist)
21:09:20 <HeladoDeBrownie> Thinking of datatypes as Java classes and typeclasses as Java interfaces is going to lead you to some serious misconceptions.
21:09:26 <evanrthomas> err
21:09:27 <Welkin> you parse it as OpenParens then
21:09:32 <evanrthomas> prettyprint tokenlist = join " " (map standardTokenRepresentation tokenlist)
21:09:47 <Welkin> and make the Show instance of OpenParens = "("
21:10:30 <evanrthomas> ok then maybe that was a poor example because I could just use show
21:10:49 <evanrthomas> maybe instead I want to give a [Token] to a function that reads each token out loud
21:11:05 <Welkin> ?
21:11:07 <evanrthomas> like, a voice that goes through the speakers
21:11:21 <Welkin> you convert each token into its respective type as you read the in
21:11:23 <evanrthomas> so what I want is a tokenToSound :: Token -> Sound
21:11:36 <Welkin> as soon as you read a "(" you produce OpenParen
21:11:44 <evanrthomas> but converting each token individually seems messy
21:11:55 <Welkin> that is how it works in a parser
21:12:05 <Welkin> you read in a stream and gradually produce the output
21:13:04 <evanrthomas> oh, wait, i'm sorry. Converting each token into its respective type is completley reasonable
21:13:07 <HeladoDeBrownie> A proper parser combinator library will let you do things like bind individual (parts of) parsers to a variable. E.g., openParen = const OpenParen <$> (token '(' <> token '{' <> token '[')
21:13:15 <evanrthomas> infact that's exactly what i'm trying to do
21:14:05 <evanrthomas> so as I read in a bunch of tokens, I want them to end up in  tokenlist :: [Token]
21:14:35 <evanrthomas> hmm, and now i've confused myself. Why can't I do that?
21:14:48 <evanrthomas> ahh, I know why I can't
21:15:08 <evanrthomas> so back to this here
21:15:08 <barrucadu> You can, that's what everyone has been saying
21:15:08 <evanrthomas> http://lpaste.net/116290
21:15:38 <evanrthomas> so there, i'm trying to convert it to a token as soon as it gets read in
21:16:05 <evanrthomas> but I can't say OpenParens:tokenlist
21:16:16 <evanrthomas> because tokenlist is of type [Token]
21:16:27 <evanrthomas> and OpenParens is of type Parens
21:16:35 <evanrthomas> the fundamental problem
21:16:44 <barrucadu> Why does Parens need to be a different type to Token?
21:16:46 <evanrthomas> is that tokenlist won't accept things of type Parens
21:17:00 <evanrthomas> just for organization
21:17:02 <barrucadu> Why can't you have data Token = OpenParens | CloseParens | Plus | Minus | Mult | Int Int | ...
21:17:13 <evanrthomas> maybe later I want to use Parens in a different place
21:17:32 <evanrthomas> you're right that I could have data Token = OpenParens | CloseParens | Plus | Minus | Mult | Int Int |
21:17:40 <evanrthomas> and that would completley fix my problem
21:17:54 <evanrthomas> but maybe later I want to have some function defined only on operators
21:18:07 <evanrthomas> and then after that I want something defined only on Parens
21:18:09 <HeladoDeBrownie> "Maybe later" is a poor justification :)
21:18:49 <evanrthomas> I think "Maybe later" is the thing you say all the time when you're thinking about code extensibility right?
21:18:54 <Welkin> evanrthomas: perhaps you should look at Write Yourseld a Scheme in 48 hours
21:19:03 <Welkin> Yourself*
21:19:06 <evanrthomas> if I don't address the "Maybe Later" question
21:19:08 <Welkin> it explains all of this
21:19:22 <Sgeo> @djinn Maybe (Either a b) -> Either (Maybe a) b
21:19:22 <lambdabot> f a =
21:19:22 <lambdabot>     case a of
21:19:22 <lambdabot>     Nothing -> Left Nothing
21:19:22 <lambdabot>     Just b -> case b of
21:19:22 <lambdabot>               Left c -> Left (Just c)
21:19:24 <lambdabot>               Right d -> Right d
21:19:26 <prinsen> Is there an explanation why a function typeOf :: forall v a. .. compiles, but not without the expicit forall?
21:19:30 <HeladoDeBrownie> The problem is there are infinite layers of "maybe later". You have to pick the most reasonable one, and often that's the least abstract thing that serves its purpose.
21:19:30 <barrucadu> evanrthomas: It's hard to think of a case where you'd want to define a function only over OpenParens | CloseParens
21:20:09 <evanrthomas> I'll look at that Welkin
21:20:43 <evanrthomas> barrucadu: i'll admit that this it's hard to think of a case where i'd want to define something only over OpenParens | CloseParens
21:21:14 <evanrthomas> and that in this specific instance, I could avoid the problem i'm having by just not giving it its own type
21:21:54 <evanrthomas> but making an interface, which is just the composition of a bunch of other interfaces is something I do all the time
21:22:19 <evanrthomas> ok here's a better example I suppose
21:22:22 <Welkin> what do you mean by an "interface"?
21:22:29 <evanrthomas> I'm still building an expression parser
21:22:38 <evanrthomas> oh, by "interface" I meant typeclass
21:22:45 <evanrthomas> using java words
21:22:50 <evanrthomas> anyway
21:22:57 <evanrthomas> i'm building an expression class
21:23:08 <evanrthomas> but this time i'm allowing much more complicated expressions
21:23:24 <evanrthomas> I have data CalculusFunction = Integral | Derivative
21:23:40 <evanrthomas> data BasicOperator = Plus | Minus | Mult | Divide
21:24:06 <evanrthomas> data Token = BasicOperator | CalculusFunction | Int | Double
21:24:27 <evanrthomas> now it seems much more reasonable that i'll want to have some functions on CalculusFunction
21:24:30 <HeladoDeBrownie> Normally for an embedded expression language you'd include the parameters of those operations. E.g, data Expr = Plus Expr Expr | Minus Expr Expr | Literal Int | ...
21:24:40 <evanrthomas> that only operate on calculs functions
21:25:00 <Welkin> look here: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
21:25:10 <Welkin> why would you want to even store the parens?
21:25:23 <Welkin> store it as an AST
21:25:33 <HeladoDeBrownie> I think part of the problem is that you're mixing up tokens and ASTs
21:25:50 <HeladoDeBrownie> Tokens aren't strictly necessary, by the way
21:26:46 <Welkin> here are your primitive operators: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1#Adding_basic_primitives
21:27:36 <Welkin> the parsing is only a tiny portion of a DSL anyway
21:27:56 <Welkin> once you read the stream into an AST, you are done parsing
21:30:31 <evanrthomas> ok so I didn't read everything
21:31:36 <evanrthomas> but I think the argument you're trying to make is "the way you're making your expression evaluator would be made easier if you did it this other way", correct?
21:32:06 <evanrthomas> I think that argument is too specific to the program i'm trying to write right now
21:32:26 <evanrthomas> the more fundamental problem i'm facing is, I want to make a list of things
21:32:45 <evanrthomas> all I care about on those things is that they have functions f, g and h defined on them
21:32:59 <evanrthomas> other than that, I don't care what types are in the list
21:33:05 <evanrthomas> now
21:33:18 <evanrthomas> it seems like I can't make this list
21:33:25 <evanrthomas> scratch that
21:33:32 <Welkin> a list of what?
21:33:37 <evanrthomas> say this list is to be composed of 50 different types
21:33:40 <Welkin> you mean an AST?
21:34:02 <evanrthomas> not necessarily AST
21:34:24 <evanrthomas> this problem extends to other programs, not just tokenize/parse/evaluate programs
21:34:32 <evanrthomas> so I'm writing some program
21:34:42 <evanrthomas> and it's unimportant what that program does
21:35:03 <evanrthomas> the point is, at some point the program wants to make a large list of things
21:35:12 <evanrthomas> I don't know what those things are
21:35:35 <Welkin> lists must contain only elments of the same type
21:35:42 <evanrthomas> yes
21:35:48 <Welkin> this is why the datatype LispVal exists in the example
21:35:53 <evanrthomas> so what you want to do then is make a typeclass
21:36:00 <evanrthomas> hmmm
21:36:06 <Welkin> it encompasses all of the types i nthe system
21:36:07 <evanrthomas> wait a second
21:36:09 <Welkin> no
21:36:12 <Welkin> not a typeclass
21:36:16 <Welkin> a typeclass is not a type
21:36:18 <prinsen> evanrthomas: You can do it using a data type data A = forall b. Contstraints => A b
21:36:39 <prinsen> ie Existential types
21:37:24 <barrucadu> But that's usually not the right solution
21:37:57 <Welkin> evanrthomas: if you don't know what the types are, how can you even write the program?
21:38:14 <evanrthomas> ah, actually I think prinsen's answer is exactly the sort of thing I'm looking for
21:38:15 <Welkin> the only possible types are known at compile time
21:38:25 <evanrthomas> I just looked them up
21:38:28 <Welkin> you cannot create a new type at runtime
21:38:35 <evanrthomas> and I haven't read much about htem
21:38:39 <evanrthomas> them*
21:38:55 <evanrthomas> but hiding types is the sort of thing that I want to do
21:39:08 <evanrthomas> I agree that the compiler should know the types of all things at runtime
21:39:28 <evanrthomas> but it should also be possible to hold a collection of multiple different types
21:39:37 <evanrthomas> hmm, do I agree with that last statement?
21:40:00 <evanrthomas> yes I do
21:40:10 <evanrthomas> for example, it should be possible to have a list of Showables
21:40:17 <barrucadu> Why?
21:40:24 <evanrthomas> just a list of a bunch of things that you can show
21:40:30 <barrucadu> The only operation on a type implementing Show is 'show'
21:40:38 <Welkin> evanrthomas: I think you are approaching this in the wrong way
21:40:47 <Welkin> stop thinking in java
21:40:48 <barrucadu> So there's no advantage over a list of Strings
21:40:50 <Welkin> and think in haskell
21:40:58 <evanrthomas> I agree with that barrucadu
21:41:02 <Welkin> they are not the same thing
21:41:57 <evanrthomas> ok yes. That's correct Welkin
21:42:09 <evanrthomas> if I just want a list of showables I might as well have a list of strings
21:42:25 <evanrthomas> ohhhhhh
21:42:51 <evanrthomas> actually, welkin that's pretty illuminating
21:43:21 <evanrthomas> let me think for a bit
21:44:12 <evanrthomas> ok yes
21:44:53 <evanrthomas> so I was going to counter your "So there's no advantage over a list of Strings" comment with "well then suppose I want a list of Playables instead"
21:45:14 <evanrthomas> where Play is a typeclass that that defines a play function
21:45:33 <evanrthomas> and play Playble plays some sound to the speaker
21:45:51 <evanrthomas> but in that case, you can always just hold a list of whatever type play returns
21:45:57 <barrucadu> Yes
21:45:58 <evanrthomas> instead of the playables themselves
21:46:05 <Welkin> putting constraints on your data types is wrong
21:46:13 <Welkin> the only place constraints should be placed is on functions
21:46:22 <prinsen> The ugliness comes if you have multiple  constraints, or the typeclass has many functions you need, but I don't know when you would want that
21:47:00 <evanrthomas> great
21:47:03 <evanrthomas> thanks guys
21:47:14 <evanrthomas> i'm now convinced that the original solution isn't messy
21:48:51 <evanrthomas> yes, my real problem was that I didn't need a Token class at all
21:49:08 <evanrthomas> i included with the reasoning "it will help this be extendable"
21:49:43 <Welkin> class?
21:49:48 <evanrthomas> typeclass
21:49:53 <Welkin> why?
21:49:58 <Welkin> that doesn't make sense
21:50:22 <Welkin> if you implement a Token, it would be a type that encompasses all possible tokens
21:50:27 <evanrthomas> i'm confusing myself thinking about it, but there's definitley something there
21:50:31 <Welkin> not a typeclass
21:50:36 <evanrthomas> let me think for a sec
22:02:57 <evanrthomas> ok guys, hope you're still here
22:03:03 <evanrthomas> I had myself a long think
22:03:36 <evanrthomas> so at one point I said "having a list of showables is something that you should be able to do in principle"
22:04:14 <evanrthomas> and the counter was, "no, in that case you could just as easily have a list of Strings"
22:04:27 <evanrthomas> and likewise for the playables example
22:05:29 <evanrthomas> so I thought that my issue was that I was caring too much about what was in the list, when what I should be caring about is what to do with the list
22:05:48 <evanrthomas> if you have a list of showables, the only thing you can do with that is turn them all into strings, so you might as well have strings
22:05:54 <evanrthomas> likewise for playables
22:06:06 <evanrthomas> but what if you wanted a list of Complexables
22:06:14 <evanrthomas> ignore that last statement
22:06:30 <Welkin> it is not a "list of showables" though
22:06:36 <Welkin> Showable is a typeclass
22:06:38 <Welkin> er
22:06:40 <Welkin> Show
22:06:47 <evanrthomas> the reason it's easy to dispute the showable list as unnecessary is because showable is a very simple typeclass
22:06:59 <Welkin> you do not put constraints on data
22:07:03 <Welkin> only on functions
22:07:29 <Welkin> the function will reject the data if it doesn't conform to the constraints
22:07:36 <Welkin> and fail
22:07:46 <evanrthomas> so I think that might be the fundamental thing I disagree with
22:07:56 <evanrthomas> I think you should be able to put constraints on data
22:07:58 <evanrthomas> suppose
22:08:02 <Welkin> you technically can
22:08:03 <evanrthomas> err
22:08:05 <Welkin> but no one does it
22:08:26 <evanrthomas> it all goes back to the list of Showables
22:08:27 <evanrthomas> you say
22:08:28 <Welkin> then you have needless boilerplate copied everywhere
22:08:33 <evanrthomas> you can never have a list of showables
22:08:48 <evanrthomas> it doesn't make sense
22:09:22 <evanrthomas> but what if that's what I really care about? That every item in my list is showable
22:09:29 <Welkin> prettyPrint :: Show a => [a] -> b
22:09:33 <Welkin> that is your function
22:09:37 <evanrthomas> Showable is only a poor example because it's very simple
22:09:56 <evanrthomas> suppose I want a list of things
22:10:16 <evanrthomas> and I know there are 20 functions that i'll end up wanting to define on each element of this list
22:10:39 <bergmark> evanrthomas: one example where we do something like this is in rest-core, we have a list of handlers for different mime types and these hide the constraints (such as ToJSON) internally
22:10:45 <evanrthomas> and I also know that in the future, it's also likley that there will be 50 functions that i'll want to call on every element of this list
22:11:00 <evanrthomas> say the functions are f1, f2, f3 ...
22:11:20 <evanrthomas> then what I want is a list of {f1 ... fn}ables
22:11:36 <bergmark> evanrthomas: https://github.com/silkapp/rest/blob/master/rest-core/src/Rest/Dictionary/Types.hs#L124
22:11:38 <evanrthomas> now in the showable case, you only have one function to call on this "showables list"
22:11:40 <evanrthomas> namely show
22:11:49 <evanrthomas> so you might as well just have strings
22:12:01 <evanrthomas> but if there are 50 things I want to do on elements of this list
22:12:22 <Welkin> evanrthomas: then you just derive instance of that data type for the given typeclass
22:12:27 <evanrthomas> firstly
22:12:40 <Welkin> data MyType = MyType deriving Show
22:12:46 <evanrthomas> let's say the elements of this list are [a1, a2 ... an]
22:12:54 <Welkin> data MyType = MyType deriving (Show, Eq, Ord)
22:14:06 <evanrthomas> so you're presupposing that this list is a list of things that all have the same type
22:14:12 <Welkin> ...
22:14:15 <evanrthomas> that the list only has things of MyType in it
22:14:20 <Welkin> that is a fundamental requirement of lists
22:14:25 <evanrthomas> which I realize must be true in haskell
22:14:29 <evanrthomas> yes
22:14:45 <evanrthomas> i'm arguing that it shouldn't be a fundamental requirement of lists
22:14:45 <Welkin> a Type is *not* a Typeclass
22:15:18 <evanrthomas> by the way, I think i've come to the conslusion that the thing I want to do just isn't doable in haskell
22:15:31 <evanrthomas> or better yet
22:15:33 <Welkin> or you just want to do something in a poor way
22:15:55 <evanrthomas> doing things the way I want to do them isn't doable in haskell
22:16:08 <evanrthomas> yes
22:16:11 <Welkin> you seem to want to write haskell like it's java
22:16:20 <Welkin> that won't work
22:16:20 <evanrthomas> I think you think i'm trying to do something in a poor way
22:16:22 * hackagebot opendatatable 0.0.0 - A library for working with Open Data Tables  http://hackage.haskell.org/package/opendatatable-0.0.0 (FabianBergmark)
22:16:24 * hackagebot ecma262 0.0.0 - A ECMA-262 interpreter library  http://hackage.haskell.org/package/ecma262-0.0.0 (FabianBergmark)
22:16:26 * hackagebot cndict 0.4.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.0 (DavidHimmelstrup)
22:16:32 <evanrthomas> and i'm trying to argue that it's something you want to do sometimes
22:16:36 <evanrthomas> and haskell doesn't let you
22:16:45 <Iceland_jack> Haskell doesn't let you have a list of Show-able things?
22:16:45 <Welkin> I have never wanted a list of multiple types
22:16:46 <evanrthomas> so continuing
22:16:58 <Welkin> what use is that?
22:17:11 <Iceland_jack> It's possible if you really want
22:17:15 <evanrthomas> it's useful if you don't actually care what type it is
22:17:21 <Welkin> you cannot have a list of multiple types in python either
22:17:24 <evanrthomas> you just care about what you can do to the elements of the list
22:17:30 <Welkin> many languages have that constraint
22:17:30 <Iceland_jack>     data Showable where
22:17:30 <Iceland_jack>       MkShowable :: Show a => a -> Showable
22:17:34 <Iceland_jack> Boom, there you go
22:17:46 <Iceland_jack>     type ShowList = [Showable]
22:18:24 <evanrthomas> I disagree with you Welkin that you cannot have a list of multiple types in python
22:18:39 <evanrthomas> I just typed a = [1, "hello", True] in a python terminal
22:18:39 <Iceland_jack> Using it for the concrete Show typeclass is somewhat useless but you can do a lot of interesting things
22:18:46 <Welkin> it's not something you can agree or disgree with
22:18:46 <evanrthomas> and it seemed to work
22:18:50 <Welkin> it either is or is not
22:19:08 <Iceland_jack> I hope you're not making the point of dynamic languages being unityped
22:19:11 <glguy> evanrthomas: You should wait until you've learned more about Haskell before bothering to form many opinions about what's possible
22:19:14 <Welkin> oh, perhaps I am mistaken about python
22:19:19 <evanrthomas> well, the python program "print [1, 'hello', True]" is a valid python program
22:19:52 <evanrthomas> ok, so if forming a list of Showables is possible, like Iceland_jack said
22:20:05 <evanrthomas> then I am wrong, and the thing I want to do is posible
22:20:58 <evanrthomas> hmm, give me a second to think about your thing Iceland_jack
22:21:33 <Iceland_jack> @let data Showable where MkShowable :: Show a => a -> Showable
22:21:34 <lambdabot>  Defined.
22:21:35 <Iceland_jack> @let s :: [Showable]; s = [MkShowable 4, MkShowable False]
22:21:36 <lambdabot>  Defined.
22:22:11 <Iceland_jack> Then it's as easy as:
22:22:11 <Iceland_jack> > map (\(MkShowable showable) -> show showable) L.s
22:22:13 <lambdabot>  ["4","False"]
22:22:51 <jle`> the list is basically equivalent to s = [show 4, show False], though
22:23:10 <Iceland_jack> What jle` said
22:23:16 <jle`> you can't do anything with that list that you can't do with the [show 4, show False] list...and vice-versa
22:23:26 <evanrthomas> oh,
22:23:28 <jle`> well.  if we pretend that Show only has `show` ;)
22:23:39 <Iceland_jack> not anything interesting at least ;)
22:23:45 <evanrthomas> Iceland_jack, i've never seen data Type where
22:23:52 <evanrthomas> i've only seen class Type where
22:23:59 <Iceland_jack> evanrthomas: Oh then ignore what I said
22:24:01 <evanrthomas> and instance Typeclass Type where
22:24:03 <Iceland_jack> because you will not be using this
22:24:28 <Iceland_jack> :-) or rather should consider to not use it..
22:25:21 <evanrthomas> no no, what you're saying Iceland_jack is exactly the thing that I was saying haskell can't do
22:25:30 <evanrthomas> I don't actually need it for my parser program
22:25:35 <Iceland_jack> Okay nice :)
22:25:39 <evanrthomas> and I won't use it
22:25:49 <TakSuyu> I take it that's what the syntax sugar is doing huh?
22:26:02 <evanrthomas> can you explain how "data Type where" works
22:26:06 <Iceland_jack> It's really useful and fun when you manage to "abstract" away from the actual, concrete 'Show' class
22:26:18 <Iceland_jack> evanrthomas: it's called GADTSyntax
22:26:23 * hackagebot yql 0.0.0 - A YQL engine to execute Open Data Tables  http://hackage.haskell.org/package/yql-0.0.0 (FabianBergmark)
22:26:25 * hackagebot apis 0.0.0 - A Template Haskell library for generating type safe API calls  http://hackage.haskell.org/package/apis-0.0.0 (FabianBergmark)
22:26:27 * hackagebot streaming-commons 0.1.7.3 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.7.3 (MichaelSnoyman)
22:26:28 <Iceland_jack> but the interesting part is the existential variable
22:26:29 * hackagebot monad-logger 0.3.11 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.11 (MichaelSnoyman)
22:26:52 <Iceland_jack> You can write:
22:26:52 <Iceland_jack>     data Bool = False | True
22:26:52 <Iceland_jack> as:
22:26:52 <Iceland_jack>     data Bool where
22:26:56 <Iceland_jack>       False :: Bool
22:27:00 <Iceland_jack>       True  :: Bool
22:27:07 <Iceland_jack> using GADT syntax
22:27:42 <carter> Iceland_jack: doesnt GADT syntax change how certain things work?
22:27:43 <carter> i forgt
22:28:31 <Iceland_jack> What I wrote could have been written without GADT syntax, but closer to:
22:28:31 <Iceland_jack>     data Showable = forall a. Show a => a
22:28:44 <Iceland_jack> No not GADTSyntax by itself
22:29:10 <glguy> carter: Maybe you're thinking of this: Any data type that can be declared in standard Haskell-98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching.
22:29:18 <glguy> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/data-type-extensions.html
22:29:34 <carter> glguy: or maybe i'm thinkign of the deriving machinery
22:29:39 <carter> doesn't it fall over on gadts
22:29:55 <Iceland_jack> If you type:
22:29:55 <Iceland_jack>     ghci> :set
22:29:55 <Iceland_jack>     <list of extensions>
22:29:58 <Iceland_jack>     ghci> :set -XGADTSyntax
22:30:02 <Iceland_jack>     ghci> :set
22:30:03 <Iceland_jack>     <list of extensions + GADTSyntax, nothing more>
22:30:06 <Iceland_jack> that's how I check when I forget anyway
22:31:12 <glguy> GADT syntax doesn't mess up deriving, GADTs do: data B where Tru, Fal :: B deriving Show -- is fine
22:31:32 <Iceland_jack> Yeah, GADTs enable a bunch of extras though
22:32:02 <Iceland_jack> ..."bunch" maybe an overstatement
22:32:08 <glguy> carter: but perhaps there's some corner case that I just don't know about
22:32:29 <carter> i could be misremembering
22:34:04 <joe9> ghc -ddump-minimal-imports --make Main.hs -- I use this command to generate the .imports file that I can use to adjust the .hs file imports.
22:34:22 <joe9> The command adds the .o and .imports file to the current directory.
22:34:31 <evanrthomas> yes, great. I think GADT just clicked. That's exactly the thing I was looking for
22:34:33 <joe9> Is there any way to tell the ghc to write it to a different directory.
22:34:46 <evanrthomas> it's not necessary at all for what i'm doing righ tnow
22:35:01 <Iceland_jack> GADTs are great though
22:35:02 <evanrthomas> but it's nice to know that haskell has a way of making a list of Xables
22:35:24 <Iceland_jack> it's just this use of their 'existential' part that tends to be done better in other ways
22:35:47 <evanrthomas> so I can have a list of things, and all I care about the things in this list is that I can call functions {f1 ... fn} on them
22:36:23 <Iceland_jack> You can do that by using existentials like I did earlier
22:36:24 * hackagebot brainfuck-monad 0.1.0 - BrainFuck monad  http://hackage.haskell.org/package/brainfuck-monad-0.1.0 (JoeyHess)
22:37:12 <evanrthomas> what are existentials again?
22:37:13 <johnw> evanrthomas: Perhaps it's better to think about this without involving type classes at all
22:37:14 <Iceland_jack>     data ShowableOrPrintable
22:37:14 <Iceland_jack>       = forall a. Show a => SHOW
22:37:14 <Iceland_jack>       | Print (IO ())
22:37:28 <evanrthomas> it's hard to read through all this irc garbage
22:37:35 <evanrthomas> and find where you posted it earlier
22:37:47 <Iceland_jack> evanrthomas: You should cover basics better before getting into those (existentials, ...)
22:38:08 <Iceland_jack> *SHOW a
22:38:34 <Welkin> johnw: we tried to convince him of that a couple hours ago
22:38:40 <Welkin> he doesn't want to listen
22:41:24 * hackagebot bloodhound 0.5.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.5.0.0 (bitemyapp)
22:41:29 <evanrthomas> ok great
22:41:32 <evanrthomas> I'm satisfied
22:41:36 <evanrthomas> so ...
22:42:03 <evanrthomas> it seemed pretty clear to me at some point during this that my question wasn't "I want to write an expression evaluator and I don't know how"
22:42:36 <evanrthomas> it was "I want to write an expression evaluator in this specific way and I don't know how"
22:42:46 <dibblego> evanrthomas: the likely scenario is that you want a list of a sum type, denoting a closed set of your types.
22:42:48 <zq> hi #haskell
22:43:01 <Iceland_jack> evanrthomas: That's fair enough
22:43:04 <zq> how to define a kind without type definition byproducts?
22:43:08 <dibblego> > [Left "abc", Right 72] -- a list of (String or Integer)
22:43:09 <lambdabot>  [Left "abc",Right 72]
22:43:19 <evanrthomas> namely, I wanted to have a list of things and I didn't care about what the things were themselves
22:43:19 <zq> eg, avoid the effect provided by DataKinds
22:43:32 <evanrthomas> I just cared about what I could do to those things
22:43:51 <dibblego> evanrthomas: that would be specific to the operation, not the data type
22:44:19 <evanrthomas> yes. I agree dibblego. I was not thinking "hakelly"
22:44:24 <evanrthomas> "haskelly"*
22:44:31 <dibblego> evanrthomas: it's more "sum typely" than it is haskell
22:44:44 <evanrthomas> in most languages, the things I can do to the data is a property of the data itself, not the functions I call on the data
22:44:45 <dibblego> it's a principle that applies to most type systems that have sum types in them
22:44:53 <lucs> haskellily?
22:46:24 * hackagebot relational-record-examples 0.1.0.0 - Examples of Haskell Relationa Record  http://hackage.haskell.org/package/relational-record-examples-0.1.0.0 (yuga)
22:47:05 <dibblego> suppose you have a list of a sum type, denoting types T or U or V, then there might be some operation (f) that applies to all types and possibly (but not necessarily), the sum type itself. The principle is that data types denote structure, distinct to operations (and their constraints). You can apply this in all languages (including python  I have done it!). It might be a different way of thinking though, especially if one is unfam
22:47:05 <dibblego> iliar with sum types.
22:50:16 <evanrthomas> dibblego: yes. I think that's pretty illuminating. What did you mean though that (f) doesn't necessarily apply to the sum itself, just the types in the sum
22:50:24 <evanrthomas> if (f) applies to all types in the sum
22:50:32 <evanrthomas> doesn't that mean it applies to the sum?
22:50:44 <dibblego> Well, that operation might apply to any of T, U, V, (T or U or V)
22:50:55 <evanrthomas> yes
22:51:13 <dibblego> data TorUorV = IsT T | IsU U | IsV V -- this is how we write the sum
22:51:24 * hackagebot relational-record 0.0.1.1 - Meta package of Relational Record  http://hackage.haskell.org/package/relational-record-0.0.1.1 (KeiHibino)
22:51:25 <dibblego> then you might have a list of TorUorV
22:52:06 <evanrthomas> yes ok. makes sense
22:52:19 <dibblego> goodo, give it a try, let us know if you get stuck
22:52:23 <evanrthomas> and it's exactly the case that I was thinking about
22:52:34 <dibblego> yeah, it's a common situation
22:52:45 <glguy> Have you heard of The Expression Problem, Evan?
22:52:50 <evanrthomas> no
22:53:30 <glguy> You should put it on you list of topics to type into Google. :) the idea
22:53:52 <evanrthomas> yea I just googled it, and i'm reading over it
22:54:19 <zq> guys
22:54:28 <zq> how do i define a kind?
22:54:36 <zq> without datakinds
22:54:41 <zq> pls
22:55:38 <glguy> Is that it's generally going to either be hard to add new operations or new kinds of data. The problem is to figure out how to make both easy. It's not solved really but you might find the work done so far interesting
22:57:40 <evanrthomas> sorry to steal the chat client
22:57:48 <evanrthomas> please continuing ansering zq
22:57:54 <evanrthomas> but as you do that ..
22:58:08 <evanrthomas>  I think at some point the conversation got removed from the specific expression evaluator I was writing. And it became a much more general question about how to make a list of Xables
22:58:30 <evanrthomas> and I think it also became a much longer discussion than this chat client is used to seeing
22:58:32 <glguy> Seems so
22:58:50 <evanrthomas> I get the feeling that this is supposed to be a quick question answer place
22:59:03 <evanrthomas> is there some other forum that's more suitable to this sort of discussion?
22:59:14 <glguy> Zq: I don't think you can. Such an extension has been discussed but I don't think it's implemented
22:59:41 <johnw> zq: can you show an example of the kind of type you'd like to write?
22:59:48 <zq> glguy: is there a way to undef data types?
22:59:56 <prinsen> Any Haskeller here that works on Facebook or Google?
23:00:02 <glguy> I don't know one. Just stick to topic most interesting to you
23:00:17 <zq> johnw: i wanna data ARealKind = Ty0 | Ty1
23:00:26 <evanrthomas> cool. Thanks guys
23:00:30 <zq> johnw: with {-# LANGUAGE DataKinds #-}
23:00:31 <johnw> ah, that's exactly what DataKinds does
23:00:33 <evanrthomas> see ya
23:00:37 <glguy> Zq : don't import it, but that's probably it
23:00:43 <zq> johnw: but then i don't want ARealKind polluting my type namespace
23:00:57 <johnw> ARealKind will be a kind
23:01:02 <johnw> ah, I see what you are getting at
23:01:06 <zq> johnw: ARealKin will also be a type
23:01:07 <glguy> Then just don't export it. That's as good as it gets
23:01:11 <zq> johnw: specifically 'ARealKind
23:01:15 <zq> ok ok ok don't export it
23:01:21 <zq> wait
23:01:28 <zq> how do i even selectively export the kind and not the type?
23:01:55 <glguy> So many constraints :)
23:02:38 <zq> alright i'll take one for the team and pollute the namespace
23:06:25 * hackagebot extensible-effects 1.9.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.9.0.0 (shergill)
23:07:35 <Welkin> holy shit
23:07:41 <Welkin> that guy finally left
23:10:49 <Welkin> did he ever accept anyone's answer?
23:11:15 <johnw> Welkin: we respect everyone's questions
23:11:15 <Welkin> or was the previous 4 hours a waste?
23:11:52 <Welkin> yes johnw, but when they are unwilling to accept any answer it is frustrating
23:12:18 <bernalex> Welkin: I don't know, but spending time complaining about the approach of someone who is not even here to hear your complaints is most certainly a waste of your time.
23:12:29 <Welkin> you are correct
23:12:43 <Welkin> it just gave me a headache
23:13:03 <Welkin> I should rest
23:14:00 <dibblego> you should
23:28:08 <prinsen> Download my library, its supercool https://hackage.haskell.org/package/apis-0.0.0
23:34:07 <bergmark> prinsen: +1 for cool last name
23:35:02 <prinsen> bergmark: Haha thanks, same to you
23:50:46 <prinsen> Man its really hard to get people to try your stuff
23:51:26 * hackagebot wreq 0.3.0.1 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.3.0.1 (BryanOSullivan)
23:56:27 * hackagebot bloodhound 0.5.0.1 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.5.0.1 (bitemyapp)
23:57:32 <liyang> prinsen: I think the done thing is to make an [ANN] post to libraries@haskell.org or something. Although I've never done so myself.
23:59:25 <shachaf> I think libraries@ is about the standard libraries, not announcing everyone's projects.
23:59:35 <Fuuzetsu> correct
23:59:43 <Fuuzetsu> post to café
