00:02:37 <Pamelloes> What does illegal datatype context mean?
00:03:07 <HeladoDeBrownie> Pamelloes, data types cannot have constraints, that feature has been removed from the language
00:03:16 <Pamelloes> oh.
00:03:20 <Pamelloes> Well then.
00:04:07 <HeladoDeBrownie> Pamelloes, the generally accepted way to solve whatever problems that used to be used to "solve" is to just include those constraints in the operations over that type
00:04:31 <HeladoDeBrownie> the reason it was removed is because it was noted that it didn't actually solve the problems it was being used to solve
00:04:49 <HeladoDeBrownie> namely, the constraints still exist in the operations anyway, you're just putting an extra constraint on the type
00:05:31 <HeladoDeBrownie> if you *do* want to only construct values of that type whose types have that constraint, consider a "smart constructor", i.e., a function you write yourself that does any logic necessary and may or may not have a restricted type but underlyingly uses the actual constructor
00:06:07 <Pamelloes> Right now, I'm unsuccessfully trying to make the free monad support Show.
00:06:30 <Pamelloes> Throwing on a type restriction was a desperate attempt to make things magically "work"
00:06:56 <HeladoDeBrownie> Pamelloes, if the type of the underlying Functor has Show, then there is Show for the Free Monad of that type as well
00:07:23 <LordBrain> Zemyla, i'm not sure what you're after, but change type CurryFunc in the class definiton to CurryFunc a b :: *
00:07:33 <HeladoDeBrownie> search this page for "Show" http://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Monad-Free.html
00:07:35 <Zemyla> :t uncurry (,,)
00:07:35 <lambdabot> (a, b) -> c -> (a, b, c)
00:08:18 <Zemyla> LordBrain: That doesn't work because b isn't in the class definiton.
00:08:42 <HeladoDeBrownie> Pamelloes, here is the head of that instance: (Show (f (Free f a)), Show a) => Show (Free f a)
00:08:55 <LordBrain> hmm worked in 7.4.1
00:09:04 <HeladoDeBrownie> Pamelloes, does that make sense to you?
00:09:10 <Pamelloes> HeladoDeBrownie: Ah, thanks. More or less.
00:09:26 <LordBrain> works in 7.8.3
00:09:30 <LordBrain> i tested
00:09:42 <Pamelloes> I realize that I misunderstood the definition of Free f a, which was why I couldn't get it to work.
00:10:02 <HeladoDeBrownie> ah, so you're on the right track now then?
00:10:22 <Pamelloes> I think so.
00:10:35 <HeladoDeBrownie> \o/
00:10:54 <LordBrain> what compiler do you use Zemyla ?
00:17:45 <Zemyla> ghc 7.8.3.
00:18:19 <Zemyla> LordBrain: I took the type family dec;aration out of the class instance.
00:18:37 <LordBrain> my solution compiles
00:18:47 <HeladoDeBrownie> bedtime. good night all
00:19:34 <Zemyla> :t curry id
00:19:35 <lambdabot> a -> b -> (a, b)
00:19:36 <LordBrain> you didnt try it
00:19:53 * hackagebot crypto-numbers 0.2.5 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.5 (VincentHanquez)
00:20:10 <Zemyla> Well, I got it to compile in 7.8.3/
00:20:19 <LordBrain> so did i
00:21:22 <LordBrain> i guess the only reason to have it in the class tho is if you want to use it like a type function, as in refer to in code outside the instance
00:21:51 <Pamelloes> "Non type-variable argument in the constraint: Show (f (Free f a))"
00:21:55 <Pamelloes> What does that mean?
00:22:23 <LordBrain> what is f Pamelloes ?
00:23:04 <Pamelloes> oh. huh.
00:23:15 <Pamelloes> It looks like I had a typo that I completely missed...
00:25:26 <int-e> Pamelloes: But anyway,  f (Free f a)  is indeed not a type variable. Haskell 2010 only allows constraints with type variables like (Show a).
00:26:37 <numberten> can anyone tell me why this function doesn't terminate?
00:26:49 <numberten> incepterate f g a b = foldl (\acc@(a:_) pf -> (pf a):acc ) [a] . map (flip f) $ iterate g b
00:27:17 <numberten> obviously it returns an infinite list, but even trying to 'take 10 $ incepterate etc' doesn't terminate
00:27:29 <numberten> since the fold is creating a list lazily, shouldn't you be able to do that?
00:28:11 <int-e> numberten: well, it's not lazy, because of the left fold.
00:28:42 <numberten> i tried it with a right fold as well >.>
00:28:53 <numberten> that gave me a stack overflow
00:30:46 <int-e> @type scanl
00:30:47 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
00:31:28 <numberten> oh
00:32:45 <int-e> numberten: It's not clear to me what the function is supposed to do, but perhaps  scanl  is closer to what you need than foldl
00:33:11 <numberten> my function is like iterate but over two variables
00:33:49 <alv-r-> hi, I'm learning haskell and I'm having random thought about design here :P, suppose you want to achieve 'polymorphic behaviour' in a sense that some function foo receives a parameter 'bar' and inside of it calls func bar. Now, suppose I wanna have a base implementation of func, let's say "func = show". It's not possible to 'hook' a new pattern matching (ex: func FooType = returns other stuff), so how woul
00:33:55 <alv-r-> d I accomplish that? (What's the best way to do something like that design-wise in haskell?)
00:33:57 <numberten> so you have all the bs generated from 'iterate g b' and a binary function :: a -> b -> a where each b comes from that list of bs
00:34:28 <numberten> f a b1 : f (f a b1) b2 : etc
00:34:44 <numberten> where (b1:b2:_) = iterate g b
00:34:44 <alv-r-> Only thing I can think of is having "foo bar func = something" and passing the function as an argument I guess :P
00:34:53 <int-e> > scanl f a (iterate g b)
00:34:54 <lambdabot>  [a,f a b,f (f a b) (g b),f (f (f a b) (g b)) (g (g b)),f (f (f (f a b) (g b)...
00:35:30 <numberten> yeah...
00:35:49 <numberten> i had forgotten about that
00:35:51 <numberten> many thanks
00:39:50 --- mode: ChanServ set +o mauke
00:39:50 --- mode: mauke set -r
00:41:50 --- mode: mauke set -o mauke
00:44:26 <dedgrant> Hmm what happened to ClassP in template-haskell-2.10?
00:47:59 <dedgrant> nvm found it.. http://haskell.inf.elte.hu/docs/latest/html/libraries/template-haskell-2.10.0.0/Language-Haskell-TH.html#v:classP
01:22:22 <lesmon> Hi. As an absolute beginner, I was wasting my time on ghci, when I find out something weird.
01:22:28 <lesmon> I was playing with this: http://paste.progdupeu.pl/oJII
01:23:03 <lesmon> I am trying to do random stuff with untyped lambda calculus in Haskell, but GHC doesn't seem to like the `is' function
01:24:04 <lesmon> In fact, when I do `is false true "Yes" "No"', the output is "No", but when I do `is true false "Yes" "No"', I get an error
01:25:48 <lesmon> Types are crazy, but I really don't understand why it isn't working when I do `is true _'
01:28:04 <mariothemad> what's the error
01:29:08 <BillyIII> lesmon: add type annotations and see what happens
01:30:00 <lesmon> mariothemad: http://paste.progdupeu.pl/ewN4
01:30:41 <lesmon> BillyIII, I tried :° but any of my propositions are violently rejected by GHC.
01:31:08 <wilx_> Hi.
01:31:28 <wilx_> I am recently having some issues with Cabal installs.
01:31:39 <solatis> what is the fastest way to generate random data in haskell?
01:31:46 <wilx_> The symptom is 'cabal: /home/wilx/.cabal/logs/network-uri-2.6.0.1.log: does not exist'
01:31:52 <solatis> ehr
01:31:53 <wilx_> And with other packages as well.
01:31:59 <solatis> let me define "random" as "garbage"
01:32:09 <solatis> not necessarily properly random
01:32:41 <lesmon> solatis, 4.
01:32:49 <solatis> dammit
01:32:58 <solatis> i should've known that was coming
01:33:01 <zachstone> haha
01:33:02 <lesmon> :}
01:33:13 <wilx> When I check what is cabal doing with -v3, it seems like it might be connectivity issue with Hackage hosts... is there a way to set a different Hackage mirror?
01:33:18 <zachstone> Random bytes?
01:35:41 <numberten> is there a list interesction function that works on infinite lists?
01:36:52 <mariothemad> lesmon: what happens when you change the order of the 3rd and 4th arguments?
01:37:35 <lesmon> mariothemad: You mean `is true false "No" "Yes"' ? nothing I guess
01:37:36 <mariothemad> lesmon: for example...`"is false true "No" "Yes"'
01:38:05 <lesmon> Oh
01:38:44 <lesmon> Yes, actually `is' is working properly only when the first argument is `false'
01:38:49 <lesmon> No matter what's next
01:40:17 <mariothemad> would you mind giving me the definition for `is'?
01:40:31 <mariothemad> how you defined the function
01:40:44 <mariothemad> this is very strange
01:40:51 <lesmon> http://paste.progdupeu.pl/oJII
01:41:15 <lesmon> Last line
01:45:55 <Rufflewind> lesmon: I don't know how much of untyped LC is expected to work in a typed system though
01:47:24 <jesyspa> You can get pretty far if you have polymorphism, although unless you introduce fix, I think it'll be total.
01:47:36 <lesmon> Hm.
01:48:14 <jesyspa> (Because forall a. a -> a -> a ≡ Bool, up to bottom)
01:50:13 <Rufflewind> jesyspa: Here's what I got with Rank2Types: http://paste.progdupeu.pl/AgNP seems to work
01:50:30 <Rufflewind> lesmon: ^ see above because I messaged the wrong person :\
01:50:33 <jesyspa> Ah, good point, I suspect you do need those.
01:51:00 <lesmon> Rufflewind, sorry, I don't know the "forall" notation and so on yet.
01:51:04 <jesyspa> Why not is x y = x y (not y)
01:51:16 <Rufflewind> jesyspa:  that's the same thing
01:51:33 <Rufflewind> (y false true) == (not y)
01:51:43 <jesyspa> Yeah, true, I just find it clearer.
01:52:35 <Rufflewind> lesmon: you're going to need Rank2Types if you want to manipulate Church-encodings in a typed language like Haskell
01:53:13 <mariothemad> haskell schonfinkles from the right, right?
01:53:27 <mariothemad> like when I'm reading the type
01:53:42 <jesyspa> You mean, a -> b -> c is a -> (b -> c)?
01:53:46 <mariothemad> yes
01:53:49 <jesyspa> Yes.
01:53:49 <lesmon> Rufflewind, I'll check this out then.
01:54:00 <jesyspa> Expressions are the other way around, a b c is (a b) c
01:54:05 <Rufflewind> schonfinkles?
01:54:49 <mariothemad> currying but more russian
01:55:05 * jesyspa has no clue where the schanfinkles come from.
01:55:15 <Rufflewind> that's not really currying, that's just operator associativity
01:55:36 <jesyspa> mariothemad: What's the Russian term?
01:55:43 <mariothemad> so I shouldn't think of it in terms of functions a to functions from b to c
01:55:59 <mariothemad> *think of it in terms of functions from a to function from b to c
01:56:23 <Rufflewind> no I mean, associativity is just a syntactic feature, it's unrelated to the interpretation (semantics)
01:56:28 <mariothemad> ok
01:56:48 <mariothemad> I learned the lambda calculus in a european environment and we called it schonfinkling
01:56:52 <mariothemad> or schonfinklization
01:57:12 <mariothemad> Thanks Rufflewind
01:57:20 <Rufflewind> np
01:57:36 <lesmon> (not so) strangely, a way to fix this is to define `is' as `is x y = x (y true false) (y false true)'
01:57:51 <Rufflewind> lesmon: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
01:57:52 <jesyspa> Oh, huh, that's actually a common term for currying.  TIL
01:58:29 <lesmon> But the function (is smth smth) now takes two things of the same type
01:58:47 <Rufflewind> lesmon: that's why Rank 2 types are needed
01:59:02 <kadoban> I thought it was more of a joke name for currying than an actual used one...
01:59:17 <Rufflewind> lesmon: the point is when you do something like "x y (y false true), you are using "y" in two distinct ways that result in two separate type signatures
01:59:33 <lesmon> Huh
01:59:49 <Rufflewind> lesmon: a church-encoding of a boolean has a type of: forall a . a -> a -> a
01:59:56 <mariothemad> when its in a parentheses is it treated as a member of a tuple?
02:00:17 <Rufflewind> lesmon: in plain words, it's a function that takes two things of the same type, and then chooses one of them and gives it back
02:00:33 <kadoban> mariothemad: No, there the parens are just for precedence.
02:00:53 <mariothemad> kadoban: ah, ok...ty
02:01:26 <Rufflewind> lesmon: the key thing to notice is that it can choose *any two things* of type 'a', and if you want a Church boolean you need to preserve this property of being able to flexibly choose any 'a'
02:01:38 <lesmon> Hm, okay.
02:02:06 <Rufflewind> lesmon: that's what the "forall a." means, it means it must be able to accept any kind of "a" you give it
02:02:28 <Rufflewind> for various reasons it's not really possible to infer such type signatures in general, so you have to write them in manually
02:03:31 <lesmon> I get it I think. Thank you, Rufflewind.
02:06:40 <Rufflewind> lesmon: as an example, if you look at "x y (y false true)" and try to infer their types, you find that the first "y" must have type "b -> b -> b" whereas the second "y" must have type "(d -> d -> d) -> (c -> c -> c) -> (b -> b -> b)", so you see that the 'a' earlier needs to be "filled in" with different types in different parts of the expression
02:06:54 <AJ_> sorry, I'm a total IRC noob, how do I mute join notifications?
02:08:42 <AJ_> @ChanServ help
02:08:42 <lambdabot> Unknown command, try @list
02:08:48 <AJ_> @list
02:08:48 <lambdabot> What module?  Try @listmodules for some ideas.
02:08:53 <AJ_> @listmodules
02:08:54 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
02:09:14 <AJ_> @list irc
02:09:14 <lambdabot> irc has no visible commands
02:09:20 <AJ_> @irc help
02:09:20 <lambdabot> Maybe you meant: irc-connect irc-password src rc
02:09:31 <AJ_> @filter help
02:09:31 <lambdabot> Unknown command, try @list
02:09:33 <indiagreen> AJ_: it depends on your client
02:09:44 <indiagreen> don't torture lambdabot
02:09:53 <lesmon> @torture
02:09:54 <lambdabot> This fortune soaks up 47 times its own weight in excess memory.
02:09:58 <AJ_> oh jeeze, I just assumed that would be whispered to me
02:10:06 <AJ_> sorry!
02:10:11 <lesmon> damn, that worked.
02:19:26 <yakhin> hi new to haskell
02:19:58 * hackagebot parallel 3.2.0.6 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.6 (HerbertValerioRiedel)
02:21:22 <rhaps0dy> hello.
02:23:47 <orion> Hi. I have a beginner issue: http://lpaste.net/8173197703430275072 -- How do I associate a constant with a Suite such that the "create" function can access it?
02:26:34 <k00mi> orion: you make the constant a member of the class
02:27:37 <k00mi> orion: like mempty in Monoid
02:28:13 <smartpudding> Hi, I'm starting a new project (first time with cassandra) is "com.datastax.cassandra"  % "cassandra-driver-core" the driver to use or is there something better ?
02:33:04 <YAARASUNN> hi new to haskell
02:35:11 <dhrosa> YAARASUNN: hello
02:36:40 <yarasunn> how access newb logs for reference if any queries answered previously
02:36:42 <dhrosa> what's the practical difference between MaybeT (EitherT e IO) a and EitherT e (MaybeT IO) a, if there is one?
02:37:30 <dhrosa> yarasunn: here's a link I found: http://ircbrowse.net/browse/haskell
02:39:47 <sinelaw> yarasunn, also the title of the irc channel has them
02:40:40 <orion> k00mi: What if the constant is a String?
02:41:21 <yarasunn> dhrosa , noted with thank you
02:43:07 <k00mi> orion: then a typeclass is probably not the abstraction you want
02:43:19 <k00mi> orion: that is to say, it's not (easily) possible
02:45:08 <osa1> any ideas how expensive is async compared to forkIO? I'm wondering about both initialization costs and runtime costs(context switches etc.)
02:47:55 <k00mi> osa1: async uses forkIO, but the overhead is probably neglegible
02:54:20 <orion> k00mi: What kind of abstraction do you recommend?
02:54:38 <k00mi> dhrosa: the nesting of effects is different, in this case whether or not you have access to the 'e' if a Nothing happens
02:54:49 <k00mi> orion: depends on what you want to do
02:57:17 <orion> k00mi: In this case, a "Suite" is a cryptosuite. Each suite has a set of operations and constants associated with them.
02:57:38 <pavonia> @src zipWith
02:57:39 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
02:57:39 <lambdabot> zipWith _ _      _      = []
02:59:25 <trap_exit> anyone here have good libraries to control digital ocean / aws via haskell ?
03:00:06 <k00mi> orion: you can just make a record instead of a class
03:00:32 <k00mi> orion: also, I would recommend looking at the crypto-api package
03:12:29 <orion> k00mi: Records are annoying.
03:14:40 <orion> k00mi: How do you access a constant contained within a record when you don't have knowledge of what "kind of" record you're operating on?
03:15:46 <orion> I'll also point out that crypto-api uses classes for ciphers and hashes.
03:15:58 <k00mi> orion: there is only one kind of record you operate on
03:16:09 <k00mi> that's why I brought it up
03:16:26 <k00mi> orion: the fields of the record are the members you would have in your class
03:19:33 <osa1> in a thread I used takeMVar and without putMVar I got an async exception(interrupt). how do I make sure the mvars are restored when that happens? (e.g. I want to put old values when the thread is interrupted)
03:21:40 <k00mi> osa1: have a look at withMVar
03:22:10 <osa1> k00mi: but it says exception, does that means async exceptions included?
03:23:50 <orion> k00mi: Sure, but would the record be passed as an argument to the function?
03:29:53 <u-ou> > cycle "moo "
03:29:55 <lambdabot>  "moo moo moo moo moo moo moo moo moo moo moo moo moo moo moo moo moo moo moo...
03:30:43 <u-ou> moo
03:36:52 <solatis> u-ou: https://www.youtube.com/watch?v=FavUpD_IjVY
03:37:24 <u-ou> :>
03:37:39 <solatis> u-ou: https://www.youtube.com/watch?v=FavUpD_IjVY might be of interest to you
03:37:48 <matematikaadit> @hoogle Complex a => a -> a
03:37:50 <lambdabot> Warning: Unknown class Complex
03:37:50 <lambdabot> Prelude id :: a -> a
03:37:50 <lambdabot> Data.Function id :: a -> a
03:38:28 <matematikaadit> @hoogle Complex a -> Complex a
03:38:29 <lambdabot> Data.Complex conjugate :: RealFloat a => Complex a -> Complex a
03:38:29 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
03:38:29 <lambdabot> Data.Complex imagPart :: RealFloat a => Complex a -> a
03:38:46 <u-ou> solatis :>
03:39:25 <matematikaadit> :t 1 :+ 2
03:39:26 <lambdabot> Num a => Complex a
03:39:44 <matematikaadit> > (1 :+ 2) * (3 :+ 4)
03:39:46 <lambdabot>  (-5.0) :+ 10.0
03:52:19 <moop> :t :+
03:52:20 <lambdabot> parse error on input ‘:+’
03:52:24 <moop> D:
03:52:40 <moop> oh
03:53:21 <pavonia> :t (:+)
03:53:22 <lambdabot> a -> a -> Complex a
03:54:10 <moop> :t (>>=)
03:54:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:54:32 <moop> cool
04:07:54 <kaiyin> :t >>
04:07:55 <lambdabot> parse error on input ‘>>’
04:08:06 <kaiyin> :t (>>)
04:08:07 <lambdabot> Monad m => m a -> m b -> m b
04:08:14 <kaiyin> Nothing >> Just 3
04:08:21 <kaiyin> > Nothing >> Just 3
04:08:22 <lambdabot>  Nothing
04:08:39 <kaiyin> Why does this return Nothing? Shouldn't it be Just 3?
04:09:04 <kaiyin> since m >> n = m >>= \_ -> n ?
04:09:08 <Iceland_jack> kaiyin: It short-circuits the computation if there is a failure
04:09:14 <Iceland_jack> @src Maybe (>>=)
04:09:14 <lambdabot> (Just x) >>= k = k x
04:09:14 <lambdabot> Nothing  >>= _ = Nothing
04:09:35 <Iceland_jack> This means that:
04:09:35 <Iceland_jack>     Nothing >> _ = Nothing
04:10:00 <kaiyin> Iceland_jack, cool, thanks.
04:10:12 <dhrosa> does placing a language extension in your .cabal file enable it for all your modules?
04:10:27 <kaiyin> @src Maybe
04:10:27 <lambdabot> data Maybe a = Nothing | Just a
04:10:30 <dhrosa> because I still get an error from the compiler suggesting that I use FlexibleInstances, even though I listed it in my .cabal under extensions
04:10:36 <kaiyin> @src Maybe (>>=)
04:10:36 <lambdabot> (Just x) >>= k = k x
04:10:36 <lambdabot> Nothing  >>= _ = Nothing
04:10:39 <kaiyin> @src Maybe (>>)
04:10:39 <lambdabot> (Just _) >>  k = k
04:10:39 <lambdabot> Nothing  >>  _ = Nothing
04:13:59 <dhrosa> nevermind.. it was in other-extensions
04:15:24 <k00mi> osa1: yes, that includes all kinds of exceptions
04:16:10 <k00mi> orion: "op" would be part of the record, all other functions take the record as an argument
04:22:25 <orion> k00mi: Isn't that reinventing typeclasses?
04:23:51 <jle`> can't we get rid of Complex
04:24:03 <jle`> and just write the same Num instance for tuplies
04:24:05 <jle`> tuples
04:24:11 <jle`> instance Num a => Num (a, a) where ...
04:25:21 <k00mi> orion: no, typeclasses are implemented this way, but explicit records are vastly more flexible
04:25:43 <kaiyin> Is it possible to use src in ghci?
04:25:51 <kaiyin> @src Maybe
04:25:52 <lambdabot> data Maybe a = Nothing | Just a
04:25:55 <jle`> kaiyin: @src is just a CTRL+F on a text file
04:26:04 <jle`> so you could just download the text file and then do a search on it
04:26:12 <jle`> it's a text file on lambdabot's server
04:26:21 <jle`> it's not actually tied to the actual sources
04:27:20 <kaiyin> ok. but it would be much nicer to have a similar interface on ghci. downloading a file and then search in it is a tedious process.
04:27:54 <jle`> what kind of interface?
04:27:59 <jle`> searching the actual text file?
04:28:01 <jle`> er
04:28:03 <jle`> searching the actual source?
04:28:07 <kaiyin> yeah
04:28:36 <kaiyin> for example, search definition of any type or typeclass
04:29:15 <kaiyin> search the implementation of any function in all installed packages
04:31:44 <dhrosa> I tni k there's a nice way to tie lambabot commands into ghci
04:39:02 <haasn> kaiyin: You can already display the definitions of types and typeclasses, since those are exported by the interface file
04:39:20 <haasn> kaiyin: (Otherwise you wouldn't be able to use its constructors/methods) It's :info in GHCi (:i for short)
04:39:46 <haasn> There's no way to view source code of functions, though. Libraries could be closed source.
04:39:53 <haasn> All GHC sees is the interface file, which only defines the API
05:03:30 <quchen> How general is the concept of an indexed monad? The standard instances seem to be State and Cont, but would it make sense to have e.g. an indexed Either or something of the like?
05:04:53 <Aruro> hi all, im trying to install lambdabot and keep getting no <pcre.h> error, i tried to install regexp-pcre-builtin but no change :(
05:06:21 * kaiyin is away: auto-away
05:06:52 <Aruro> hi all, im trying to install lambdabot and keep getting no <pcre.h> error, i tried to install regexp-pcre-builtin but no change :(
05:14:23 * kaiyin is back (gone 00:08:02)
05:16:56 <ski> kaiyin : you may want to consider turning that off, since some people are bothered by it
05:17:57 <ski> quchen : hm .. perhaps for a condition monad with restarts
05:18:30 <tsani> How can I stop a conduit from another thread?
05:22:19 <dhrosa> I have an interesting compiler warning
05:22:52 <dhrosa> so I have a record that isn't exported by my module, so the compiler says that the records are declared but not used
05:23:14 <dhrosa> however, they are actually needed by how I'm using Aeson with Generics
05:23:21 <tsani> oh hm. Maybe something to do with ResumableSource
05:23:42 <dhrosa> how can I inform the compiler that record names are actually being used?
05:24:33 * kaiyin is away: auto-away
05:36:23 <moop> i wonder what client is doing that
05:36:40 <moop> or is it a plugin to announce how long you were away for
06:02:26 <osa1> is there a way to make main thread wait until all other threads terminate? (without having references of other threads?)
06:02:36 <osa1> and without using mvars or something like that
06:04:49 <Saizan> nope
06:05:04 <k00mi> osa1: no, the other thread must signal to the main thread when they terminate
06:05:27 <k00mi> osa1: this can easily be done with a semaphore
06:06:03 <osa1> k00mi: I know, I just wanted to do it by using some kind of RTS support instead of solving it in program level.
06:08:13 <McManiaC> dhrosa: you could turn off the warning, but I don't think you can explicitly tell GHC that something like that is actually used
06:08:24 <McManiaC> dhrosa: sounds like a bug to me tbh
06:08:36 <McManiaC> GHC bug
06:08:50 <dhrosa> McManiaC: I learned that if you prefix record fields with a _, the warning is suppressed for those fields
06:09:09 <dhrosa> luckily the way I was using the field names I could do that
06:09:45 <McManiaC> ah right yah that works if you can do that
06:10:10 <bennofs> McManiaC: probably easier to fix at the aeson level, by generating code that actually uses those field accessors instead of constructing the record directly
06:10:48 <McManiaC> it took me a while to realize that you can actually use record fields prefixed with a _
06:10:50 <dhrosa> if I have something like instance (Num a) => TypeClass (F a) where ..., can I override it with specializations, like instances of TypeClass (F Int) ?
06:11:56 <dhrosa> urrrgh, I don't like that I can't mix monadic code into parseJSON
06:14:19 <McManiaC> dhrosa: not directly I think
06:14:48 <McManiaC> You could do some tricks with type families but
06:14:52 <McManiaC> hmm
06:15:10 <maybefbi> what is the meaning of: forall a.
06:16:03 <srhb> maybefbi: Depends on the extensions enabled.
06:16:16 <srhb> maybefbi: In general there are implicit foralls in front of every function signature.
06:16:30 <srhb> maybefbi: And in this case, they really do mean for ANY type a
06:16:38 <srhb> :t id -- as in this case
06:16:39 <lambdabot> a -> a
06:16:49 <maybefbi> whats the deal with the . after a
06:17:19 <srhb> maybefbi: Nothing special, it could have been a colon instead. Traditionally it's a dot though.
06:17:28 <shachaf> ven non-function signatures.
06:17:33 <srhb> Right.
06:17:58 <maybefbi> what are ven non-function signatures
06:18:03 <srhb> 1 :: Int
06:18:03 <shachaf> Even
06:18:04 <maybefbi> or should i google it
06:18:16 <maybefbi> oh ok
06:18:29 <srhb> Non-function signatures would be signatures without (->) in them, (unless you have a type synonym to hide the (->))
06:18:34 <shachaf> Nothing :: forall a. Maybe a
06:18:57 <maybefbi> my IDE complains that . shouldnt be there
06:19:17 <maybefbi> all i have done is hide implicit prelude and import classy prelude
06:19:19 <srhb> maybefbi: forall a. probably should not be there unless you're using some language extension like RankNTypes or ScopedTypeVariables
06:19:31 <srhb> maybefbi: What is the signature in question?
06:19:55 <maybefbi> :: forall a. (Num a, Eq a) => a -> Int -> Maybe String
06:20:10 <srhb> That forall a. is already implicit
06:20:23 <srhb> Unless you're doing something fun with scoping the a's inside where clauses or something
06:20:30 <srhb> So indeed, it should not be there.
06:21:40 <dhrosa> how do people normally do this? the way I parse JSON in my objects needs to depend on some state
06:21:57 <maybefbi> srhb, i will understand RankNTypes later
06:22:01 <dhrosa> and I can't mix my State monad into parseJSON function of the FromJSON typeclass
06:23:58 <dhrosa> more specifically: the JSON API I'm working with associates user IDs with messages, instead of usernames. I'd like to transparently map the username to the user ID when I parse the message object
06:24:13 <flaggy> What's USE_REPORT_PRELUDE I see often on ghc's code?
06:24:22 <dhrosa> so that the message object has a User object instead of a userId string
06:24:36 <srhb> flaggy: A flag to actually use the prelude from the report (with all its errors)
06:24:45 <shachaf> Errors?
06:24:50 <flaggy> hm, haskell98 report?
06:25:01 <srhb> 2010, etc
06:25:15 <dhrosa> the way I'm currently handling this is that I have a MessageRaw object that has a userId string, and I have a String -> M User which converts the user id to a user in my monad
06:25:30 <srhb> shachaf: There are a bunch of recursive functions that build up thunks even though they should not, afair
06:25:35 <shachaf> What sort of errors could the Report have?
06:25:42 <dhrosa> and I use that to create a M Message. The problem is that I have to expose MessageRaw out of my API
06:26:01 <shachaf> Oh. Those aren't errors, they're a specification.
06:26:16 <sveit> is write yourself a scheme considered "good" haskell?
06:27:00 <srhb> shachaf: I suppose. Using them would almost always be an error, though.
06:27:11 <srhb> sveit: It's quite outdated, afair. Someone's writing up a new one.
06:27:34 <flaggy> Hm, I didn't know the specification actually had haskell code in it
06:27:36 <flaggy> interesting
06:27:38 <shachaf> base is shared between more than one Haskell implementation, isn't it?
06:27:48 <srhb> I don't know.
06:28:14 <shachaf> Anyway the point is that those implementations are GHC-specific
06:28:33 <srhb> Right, but that's basically what Haskell is now. GHC-Haskell.
06:29:03 <srhb> I think they're also an error in almost every other of the dead implementations though.
06:29:11 <flaggy> I suppose it defines sortBy cmp = foldr (insertBy cmp) [] not because sort should have O(N^2) performance, but the specified result should match implemented result exactly, right?
06:29:13 <srhb> But sure, you made your point. :)
06:29:33 <flaggy> it's not a specification on function complexity, I supppose
06:31:42 <sveit> thanks. in particular, is "hacking" heterogeneous lists with existential types considered good practice?
06:32:14 <srhb> Isn't that how HList does it?
06:32:47 <Saizan> HList actually keeps all the types visible
06:32:51 <srhb> Oh.
06:33:11 <srhb> I've never actually used it, so I should probably shut up. :-)
06:33:50 <dfeuer> shachaf, I believe base was shared by GHC, NHC98, and Hugs. I don't know if it was shared by HBC, JHC, or others. I believe it's currently GHC-only, because no one knows what the next significant implementation will need from it.
06:34:10 <Saizan> sveit: it's fine if you don't care about the specific type anymore
06:34:27 <McManiaC> dhrosa: http://puu.sh/dMw5N/b7feee49f8.png this would work
06:34:28 <McManiaC> :D
06:34:38 <McManiaC> requires TypeFamilies and some other
06:34:58 <flaggy> When I started with haskell I used to like hugs. It loaded much faster than ghc :P
06:35:09 * hackagebot hakyll 4.6.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.3.0 (JasperVanDerJeugt)
06:36:17 <shachaf> srhb: HList is just masking "lists" like (Int,(Char, (Bool, ())))
06:36:23 <srhb> I see.
06:36:29 <srhb> That's not at all what I thought it was.
06:36:55 <dfeuer> flaggy, you want to pick up Hugs development? I'm sure no one will complain.
06:37:19 <dfeuer> srhb, my understanding is that it's more about flexible record-like things than really "lists".
06:37:25 <srhb> Aye.
06:37:53 <dramforever> Weird: now I'm even using ghci to debug C programs
06:37:57 <flaggy> dfeuer: hehe I'm not that enthusiastic about it :P
06:38:34 <McManiaC> dramforever: how that
06:38:41 <dramforever> McManiaC: FFI
06:39:01 <dramforever> foreign import, and use the func
06:39:04 <rhaps0dy> dramforever: is that better than gcc?
06:39:10 <rhaps0dy> oh
06:39:12 <rhaps0dy> to use a single func
06:39:17 <rhaps0dy> ya ghci must be better
06:39:26 <dramforever> oh, maybe I was vague
06:39:41 <McManiaC> dramforever: you mean to interactively use a C function?
06:39:59 <dramforever> McManiaC: yep
06:40:02 <McManiaC> ah okay
06:40:03 <flaggy> Now that I come to thing about it, I don't recall making an heterogenous list in any language. I wonder what's the use case sveit has
06:40:03 <McManiaC> :D
06:40:29 <dramforever> interaction is more flexible than gdb
06:40:45 <rhaps0dy> flaggy: the typical polymorphic object in oop
06:40:57 <rhaps0dy> you have a list of those and you loop thru it
06:41:08 <dramforever> It's really tiresome to write a main() just to test one func, and you have to make it interactive enough
06:41:32 <rhaps0dy> one use case would be a raytracer, you have spheres, meshes, NURBS and whatnot
06:42:09 <dramforever> ruby programmers sometimes use arrays like tuples
06:42:49 <dramforever> like, a rack web application returns [statusCode, responseHeaders, responseBody]
06:42:54 <rhaps0dy> lol
06:43:11 <McManiaC> rhaps0dy: you could do that in haskell too
06:43:27 <flaggy> In that case I think I'd end up having a superclass for all those different types. After all, after adding things to a list, you usually want to take them out of the list and you need to know what methods to call on the elements you retrieve.
06:43:41 <rhaps0dy> McManiaC: of course you can
06:43:46 <rhaps0dy> I didn't say you can't
06:43:49 <rhaps0dy> but it's a use case
06:43:56 <rhaps0dy> what would be your solution? we didn't come to a satisfactory one
06:44:02 <dramforever> hetergenous lists cannot be used list-ly, for example foldl, foldr, etc.
06:44:13 <ddellacosta> so...how do I pass linker options for FFI to cabal repl?
06:44:17 <rhaps0dy> dramforever: in the raytracer case you can
06:44:20 <dramforever> or at least it's really hard
06:44:28 <dramforever> you must take care of all cases
06:45:05 <dramforever> ddellacosta: I don't know, but "ghci foo.o" works
06:45:06 <flaggy> dramforever: yeah, I have done that. I didn't think about it.
06:45:16 <rhaps0dy> in the case of OOP, if all objects have a method with the same signature, it's not that hard
06:45:19 <rhaps0dy> still
06:45:22 <dramforever> yep
06:45:29 <rhaps0dy> heterogeneous lists are not evil
06:45:30 <ddellacosta> dramforever: yeah, that's not what I need in this case, I can get that much working
06:45:32 <rhaps0dy> :(
06:45:41 <dramforever> ddellacosta: :(
06:45:48 <ddellacosta> dramforever: thanks though. ;-)
06:46:05 <rhaps0dy> McManiaC: do you have a cleaner solution than data Object = Sphere | Mesh | NURBS | Whatever ?
06:48:15 <McManiaC> rhaps0dy: i'd probably use GADTs: http://puu.sh/dMwJ9/102ba6ba1a.png
06:48:46 <McManiaC> stores the type class context
06:49:30 <rhaps0dy> type class context?
06:49:39 <rhaps0dy> so basically apply the function to every object manually when writing
06:49:40 <McManiaC> the "Show a =>" part
06:49:49 <rhaps0dy> hmm
06:50:07 <rhaps0dy> that's not very useful if you have a list of all objects in a scene and you must render them
06:50:17 <rhaps0dy> you could solve it by having a list for every type of object too...
06:50:44 <McManiaC> with a typical "newtype L = L (forall a. Show a => a)" you'll lose the "instance definition context", which will result in errors like "couldn't match type a with a0" or something like that
06:51:00 <McManiaC> GADTs will "remember" the context of the type class
06:51:05 <flaggy> McManiaC: hm, that's interesting. All you really need is to call show on elements of the list, I haven't thought of that
06:51:41 <McManiaC> rhaps0dy: it's useful as long as every type is instance of some type class
06:51:50 <ski> McManiaC : i'd `instance Show L where showsPrec p (L a) = showParen (p > 10) $ showsPrec 11 a'
06:52:13 <rhaps0dy> ski, what
06:52:14 <ski> (that way a `Maybe L' will also display properly)
06:52:18 <rhaps0dy> oh
06:52:41 <McManiaC> ski: yeah, the Show instance is just 'proof of concept'
06:52:42 <McManiaC> :D
06:53:03 <rhaps0dy> McManiaC: you have to apply the function to every object individually before adding it to the list
06:53:11 <ski> i know, and i'm reacting to defining `show' instead of `showsPrec', in a `Show' instance
06:53:20 <rhaps0dy> which because of purity and laziness ain't much of a problem tbh
06:53:22 <McManiaC> ski: fair enough
06:53:28 <rhaps0dy> I think the best design would be to avoid this entirely
06:53:42 <McManiaC> rhaps0dy: thats usually the best decision yea
06:53:43 <McManiaC> :D
06:53:54 <McManiaC> avoid everything that adds complexity
06:54:10 <rhaps0dy> if I ever write a raytracer in Haskell, I'll revisit the problem
06:54:13 * ski isn't quite sure what rhaps0dy want to capture here
06:54:14 <rhaps0dy> McManiaC: yeah lol
06:54:30 <rhaps0dy> ski you're writing a raytracer, and you have a scene
06:54:41 * ski . o O ( "make it as simple as possible, but not any simpler than that" )
06:55:05 <rhaps0dy> in that scene there are several objects, including spheres and elipses, NURB splines, meshes
06:55:52 <rhaps0dy> and during the pass you ahve to render them all, a good way of doing this would be to store them all in a list and then fold over that list with an empty render image
06:55:58 <rhaps0dy> but it's heterogeneous
06:56:07 <ski> so you need a common interface that all of those kinds of objects support, that you can use to render them
06:56:07 <rhaps0dy> McManiaC has an ok solution
06:56:08 <hodapp> I might write a raytracer in Haskell... or maybe a distance-estimating sphere tracer. Dunno.
06:56:15 <McManiaC> rhaps0dy: oh, and re: not useful… it would be better in that type classes are "open" while data types like "data = Sphere | Mesh | ..." are not
06:56:31 <ski> so using existentials would be one approach to this
06:56:42 <McManiaC> ie. you can add more data types to the list even if you did not initially plan for it
06:56:50 <rhaps0dy> McManiaC: yeah, yours is better than the data = solution
06:57:03 <dfeuer> But that's an odd way to use existentials.
06:57:08 <ski> .. in some cases, one could partially-apply the objects to the operations, and instead pass a record of those (possibly recursively defined)
06:57:27 <rhaps0dy> ski: existentials?
06:57:28 <ski> dfeuer : why ?
06:57:34 * dfeuer offers ski a platter of smoked fish and some hot chocolate.
06:58:00 <dfeuer> ski, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
06:58:00 <ski> rhaps0dy : something like `[exists a. Rendable a *> a]', possibly
06:58:06 <ski> dfeuer : *nod*
06:58:15 <ski> @where existential-antipattern
06:58:15 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
06:58:30 <McManiaC> ski: that won't work unfortunately
06:58:37 <ski> rhaps0dy : you should probably read that one, if you haven't yet
06:58:43 <ski> McManiaC : ok ?
06:58:46 <rhaps0dy> ski, the blog post?
06:58:48 <ski> yes
06:58:53 <rhaps0dy> on my way
06:59:15 <McManiaC> ski: you can create and store elements in the list, but you cannot use the Renderable instance anymore
06:59:25 <ski> why not ?
06:59:35 <McManiaC> GHC will complain about "expected type a, got type a0" or something like that
07:00:08 <ddellacosta> hmm, is there a way to put a dummy value in place for a data constructor before you're ready to implement, as a placeholder, but let your code compile?
07:00:40 <ski> GHC will accept `[AnyRenderable]' where `data AnyRenderable where WrapRenderable :: Renderable a => a -> AnyRenderable' (or, using the old syntax, `data AnyRenderable = forall a. Renderable a => WrapRenderable a')
07:00:40 <ddellacosta> oh, nevermind, I'm a dummy
07:01:01 <ski> McManiaC : so i'm curious if you still see some problem here
07:01:05 <McManiaC> ski: jup, that'S GADTs :)
07:01:12 <ski> that's just existentials :)
07:01:12 <McManiaC> not plain existentials
07:01:19 <McManiaC> hmhm
07:01:19 <McManiaC> :D
07:01:27 <maybefbi> > Data.Foldable.msum [Just "a", Just"b", Just "c"]
07:01:28 <lambdabot>  Not in scope: ‘Data.Foldable.msum’
07:01:28 <lambdabot>  Perhaps you meant ‘Data.Foldable.fold’ (imported from Data.Foldable)
07:01:32 <McManiaC> ski: anyway, that's what i suggested earlier :>
07:01:40 <kaiyin> Is ghc totally writeen haskell itself?
07:01:41 * hodapp mumbles something about existential quandaries
07:01:53 <ski> expressed using the GADT syntax, and alternatively expressed using the ADT syntax, with `forall' before the data constructor
07:02:39 <kaiyin> some people say it's a self-hosted compiler, but wikipedia says it's written in haskell and c.
07:02:53 <ski> mostly Haskell
07:04:02 <maybefbi> > msum [Just "a", Just"b", Just "c"]
07:04:03 <lambdabot>  Just "a"
07:04:15 <maybefbi> why is that?
07:04:25 <maybefbi> shouldnt it be Just "abc"
07:04:27 <Iceland_jack> @src msum
07:04:27 <lambdabot> msum = foldr mplus mzero
07:04:34 <Iceland_jack> No, that would be sequence
07:04:36 <McManiaC> kaiyin: the "main" compiler (parser, typechecker, optimization etc) is written in haskell
07:04:49 <Iceland_jack> maybefbi: Or close enough:
07:04:49 <Iceland_jack> > sequence [Just "a", Just"b", Just "c"]
07:04:50 <lambdabot>  Just ["a","b","c"]
07:04:59 <Iceland_jack> maybefbi: Or close enough:
07:04:59 <Iceland_jack> > sequence [Just 'a', Just 'b', Just 'c']
07:05:00 <lambdabot>  Just "abc"
07:05:10 <maybefbi> Iceland_jack, wow
07:05:29 <ski> maybefbi probably would like `instance SemiGroup a => Monoid (Maybe a)'
07:05:35 <rhaps0dy> ski, that may be a better solution
07:05:41 <kaiyin> McManiaC, what part is written c then?
07:05:54 <McManiaC> kaiyin: i'm not too sure :>
07:05:56 <rhaps0dy> I'm afraid I'm not proficient enough to fully appreciate this yet, but I see how it goes more or less
07:06:03 <McManiaC> kaiyin: you need gcc to compile ghc though
07:06:13 <McManiaC> kaiyin: maybe some system calls
07:06:16 <McManiaC> not sure
07:06:29 <kaiyin> ok
07:06:52 <flaggy> > msum [Nothing, Just "a", Just "b"]
07:06:53 <lambdabot>  Just "a"
07:06:53 <geekosaur> any garbage-collected language must have its garbage collector written in either a non-garbage-collected subset of the language or in another language
07:07:34 <geekosaur> haskell has no non-garbage-collected subset; ghc's specific implementation might, but I'm not aware of one
07:07:35 <CyberAce> Hi
07:07:42 <ski> hello, CyberAce
07:08:05 <ski> geekosaur : there's PreScheme for Scheme48
07:08:16 <McManiaC> kaiyin: looks like the RTS is mostly C: https://github.com/ghc/ghc/tree/master/rts
07:08:45 <kaiyin> what is rts?
07:08:50 <geekosaur> runtime system
07:09:24 <geekosaur> garbage collector, graph reduction/evaluation, implementation of primitive types in terms of hardware types
07:09:50 <maybefbi> Iceland_jack, i used:
07:09:57 <maybefbi> > concat <$> sequence [Just "a", Just"b", Just "c"]
07:09:58 <lambdabot>  Just "abc"
07:10:14 <maybefbi> ClassyPrelude.concat
07:11:00 <maybefbi> it is like a tub full of lego blocks.
07:11:16 <maybefbi> wonder why minecraft folks arent here
07:11:53 <ski> maybefbi : what behaviour do you want with `Nothing's in the list ? should they get ignored ? (unless there's only `Nothing's in the list, perhaps ?) or should at least one `Nothing' in the list cause the answer to be `Nothing' ?
07:12:23 <maybefbi> ski, ideally there shouldnt be any nothings
07:12:41 <maybefbi> if one is nothing all should be nothing
07:12:45 <Iceland_jack> @src catMaybes
07:12:45 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:12:48 <Iceland_jack> @ty catMaybes
07:12:49 <lambdabot> [Maybe a] -> [a]
07:13:18 <Iceland_jack> > concat (catMaybes [Just "a", Just "b", Just "c"])
07:13:19 <lambdabot>  "abc"
07:13:28 <maybefbi> Iceland_jack, ok but that is more monomorphic. (i guess that is the word)
07:13:52 <maybefbi> Iceland_jack, i want to learn the abstract way to do things. one level more abstract
07:13:57 <ski> > catMaybes [Just "a",Nothing,Just "c"]
07:13:58 <lambdabot>  ["a","c"]
07:13:59 <Iceland_jack> It's different, if you use sequence it will fal if there is a single Nothing
07:14:00 <ski> > sequence [Just "a",Nothing,Just "c"]
07:14:01 <flaggy> geekosaur: I think what you said is true in practice, but it's not necessarily true. If we think of a simple reference counter GC, a compiler could easily generate code for increasing and decreasing (and freeing memory) a counter at each object creation and function return. It wouldn't need to be written in a different language in order to do that.
07:14:02 <lambdabot>  Nothing
07:14:11 <ski> maybefbi : so something like `sequence', then
07:14:16 <Iceland_jack> *it will fail, (as ski pointed out)
07:14:30 <maybefbi> ski, yeah. i want it to fail when there is a single Nothing
07:14:54 <maybefbi> because im concat-ing array lookup values from atMay-s
07:15:13 <ski> `atMay' ?
07:15:16 <maybefbi> Safe.atMay
07:15:22 * ski . o O ( `atJune' )
07:15:57 <maybefbi> ski, im trying to be Safe
07:16:02 <ski> i suppose `atMay :: Integral i => [a] -> (i -> Maybe a)' ?
07:16:10 <maybefbi> ski, oui
07:16:37 <maybefbi> ski, if one of those atMay-s is a Nothing, i dont want the concat to work
07:16:44 <ski> maybefbi : possibly you could use `mapM' or `forM' instead of `sequence'
07:16:51 <ski> (as a shorthand)
07:18:07 <ski> if you say `sequence (map (\x -> atMay...) xs)', then that could be abbreviated to `mapM (\x -> atMay...) xs' or `forM xs $ \xs -> atMay...'
07:18:26 <ski> (also if you're using list comprehension syntax instead of calling `map')
07:18:36 <ski> @src mapM
07:18:36 <lambdabot> mapM f as = sequence (map f as)
07:18:45 <maybefbi> ski, im doing this http://lpaste.net/6444058421409873920
07:18:46 <ski> @src forM
07:18:46 <lambdabot> forM = flip mapM
07:20:09 <ski> i see
07:20:33 <ski> an alternative would be to use `MaybeT [] Char' (instead of `Maybe String')
07:20:53 <maybefbi> ski, hmm interesting
07:21:19 <maybefbi> ski, gotta learn to think interms of transformers
07:22:49 <McManiaC> > concat <$> sequence [ Just "a", Just "b" ]
07:22:50 <lambdabot>  Just "ab"
07:22:51 <McManiaC> > concat <$> sequence [ Just "a", Just "b", Nothing ]
07:22:52 <lambdabot>  Nothing
07:22:55 <McManiaC> ?
07:23:53 <maybefbi> McManiaC, das ist the behavior i desire
07:24:17 <danilo2> Hello! Can we using TemplateHaskell find all instances of a given typeclass somehow?
07:24:29 <McManiaC> maybefbi: whats the issue then
07:24:29 <McManiaC> :D
07:25:48 <maybefbi> McManiaC, issue has been solved. that is the solution.
07:26:28 <maybefbi> McManiaC, i was trying to use  msum [Just "a", Just"b", Just "c"]
07:26:35 <McManiaC> o k
07:26:44 <danilo2> Oh, there it is! reifyInstances, sorry I misslooked it :)
07:26:56 <Enzoray> 1. Implement a function
07:26:56 <Enzoray> occurs :: Eq a => a -> [a] -> Int
07:26:56 <Enzoray> that given an x and a list xs, finds out how often x occurs in the list.
07:27:13 <Enzoray> Any tips how to solve this? I was thinking splitting the list and then go though with guards.
07:27:34 <isomorphic> If I wanted to make a new function, callable from ghci, that had the effect of creating a new data declaration, how would I do it.   eg:  how do I write a function that has the same effect as typing "data Foo = Bar | Baz" into ghci?
07:28:33 <freeman42> There is at least one case where I seen GHC complain about overlapping patterns. Looking at the following function: last :: [a] -> a; last [x] = x; last (_ : xs) = last xs it appears that the pattern is overlapped since (_ : xs) would match anything [x] could match and more. Yet GHC does not complain about the function having overlapping patterns. Am I misunderstanding what overlapping means? Or is GH
07:28:33 <freeman42> C not complaining about overlapping which exists there? If I revert the order of the pattern matches the GHC does complain about overlapping. So it seems that as long as all the patterns have cases when they can be matched they are not considered as overlapping - regardless if they can match common things or not. (disclaimer: this is homework)
07:29:21 <McManiaC> isomorphic: not possible unfortunatel
07:29:22 <McManiaC> y
07:29:28 <geekosaur> isomorphic, that's mixing levels. you can "do" it but not simply as a function; there is instead a mechanism where you can write a function that outputs a ghci "meta command" as a string which ghci evaluates
07:29:29 <ski> Enzoray : one approach would be to select the elements of `xs' that are equal to `x', and count them
07:29:30 <quchen> Enzoray: What have you tried? Can you write the pseudocode of your idea?
07:30:10 <ski> isomorphic : what are you wanting that for ?
07:30:28 <Enzoray> I simple tried to splitt the list (x:xs) and I want to look though every single element, and for each element == n, + 1
07:30:37 <Iceland_jack> isomorphic: You can define a GHCi command that does that
07:30:55 <isomorphic> ski:  I'm thinking for numerical work. Imagine taking a CSV file and then automatically generating a structure that can be traversed over in ghci
07:31:01 <ski> Enzoray : ok. sounds reasonable. can we take a look at your code attempt ?
07:31:04 <ski> @paste
07:31:04 <lambdabot> Haskell pastebin: http://lpaste.net/
07:31:20 <Enzoray> occurs :: Eq a => a -> [a] -> Int
07:31:21 <Enzoray> occurs a (x:xs)
07:31:21 <Enzoray> 		| a == x = 1
07:31:21 <Enzoray> 		| otherwise = occurs a xs + 1
07:31:39 <Enzoray> This gives me where the "a" occurs in the list.
07:31:44 <Enzoray> So not exacly what I wanted.
07:31:55 <Enzoray> But, it's something.. :D
07:32:04 <ski> you need a base case for your recursion
07:32:28 <isomorphic> eg:  CSV file has 'id', 'first_name', 'last_name' columns - a csv reading function would create a data record Rec { id :: string, first_name :: string, last_name :: string } and also create a new variable containing (say) a lazy list of recs
07:32:29 <ski> what should happen if (when) an empty list is passed to `occurs' ?
07:32:52 <isomorphic> ski: Make sense?
07:33:11 <Iceland_jack> isomorphic: For that you'd use Template Haskell
07:33:11 <Enzoray> occurs [] = 0
07:33:15 <Enzoray> Sounds good? :P
07:33:16 <isomorphic> geekosaur, Iceland_jack : Thanks.  What would be the command
07:33:18 <Iceland_jack> but here is how you'd do it using ':def'
07:33:19 <Iceland_jack> ghci> :def foo (\_ -> return "data Foo = A | B")
07:33:19 <Iceland_jack> ghci> :foo
07:33:19 <Iceland_jack> ghci> :t A
07:33:22 <Iceland_jack> A :: Foo
07:33:25 <ski> isomorphic : one approach would be to use a `Map' from field names to values
07:33:59 <ski> Enzoray : ok. now, there's still problems with your definition
07:34:06 <ski> Enzoray : can you spot them ?
07:34:33 <ski> isomorphic : do you want to create the structure programmatically, or only manually ?
07:34:38 <Enzoray> No, I can't.. please enlighten me?... :P
07:35:06 <ski> Enzoray : try evaluating `occurs 0 [0,1,0]'
07:35:36 <isomorphic> ski:  I think 'manually' is the right answer - I figure it would be useful to emulate the behaviour of tools like R for things like iHaskell
07:35:53 <McManiaC> Enzoray: you're counting the wrong thing
07:36:04 <Enzoray> McManiaC, yeah.. I know
07:36:09 <isomorphic> automatic definition of the appropriate types *seems* like the right hammer, since I could provide default show instances, etc
07:36:09 <McManiaC> think about what your implementation is actually counting
07:36:21 <ski> isomorphic : then it may be that `:def' is what you want. Template Haskell could be an alternative, perhaps
07:36:33 <isomorphic> It's sort of an attempt at emulating a data.frame in a more haskell-ish way
07:36:45 <isomorphic> (if you know R or pandas)
07:36:47 <ski> Enzoray : what can you say about the answer computed for `occurs 0 [0,1,0]' ?
07:37:12 <isomorphic> ski:  Actually, I'll take back my answer - I think I mean automatically
07:37:16 * ski doesn't know much about arr or pandas
07:37:18 <ski> @arr
07:37:18 <lambdabot> Yeh scurvy dog...
07:37:24 <Enzoray> It occurs at position 0, returns 1.
07:37:33 <Enzoray> Yet, I'm still calculating the wrong thing.
07:37:39 <isomorphic> the goal would be to write a function readCSV which defines the appropriate types
07:37:45 <Enzoray> I need to know how many times 0 occurs in the list.
07:37:50 <ski> Enzoray : is the answer the right one, or not ?
07:37:55 <Enzoray> Not right.
07:37:59 <ski> why is that ?
07:38:20 <ski> any idea ?
07:38:25 <Enzoray> Because there is something wrong in the code? probably +1
07:38:28 <Enzoray> In otherwise.
07:38:48 <JagaJaga> Why does CPS transform matter? Why and what for should we use it?
07:38:49 <linus_> Hey guys, I have a really basic question. I'm working through Programming in Haskell, and I'm trying to do one of the first exercises. I'm fairly certain I've got it right, but GHCI throws an error whenever I try to run my function
07:38:53 <ski> perhaps we can try tracing a reduction sequence
07:38:54 <linus_> mylast xs = xs!!(length xs - 1)
07:39:15 <linus_> *Main> mylast [1,2,3,4,5]
07:39:17 <linus_> <interactive>:3:1: No instance for (Num [t0]) arising from a use of ‘it’ In a stmt of an interactive GHCi command: print it
07:39:19 <ski> Enzoray : first, remember that `[0,1,0]' is syntactic sugar for `0:1:0:[]'
07:39:56 <ski>      occurs 0 (0:1:0:[])
07:40:58 <mrordinaire> linus_: umm I don't see the problem. it works for me.
07:40:58 <ski>   =  1   -- here `a = 0; x = 0; xs = 1:0:[]', so since the guard `a == x' is `0 == 0' is `True', we use the definiens `1' of the first guard to replace the function call to `occurs' with
07:41:05 <ski> Enzoray : do you understand ?
07:41:08 <mrordinaire> let mylast xs = xs!!(length xs - 1)
07:41:10 <isomorphic> ski, Iceland_jack, geekosaur :  Is there a way to get that :def effect into a function - eg: so I could import a module, then call foo to create the type?
07:41:29 <mrordinaire> and `mylast [1,2,3,4]` returns 4
07:41:36 <ski> isomorphic : `:def' can only be used interactively, and from GHCi scripts
07:41:41 <Iceland_jack> isomorphic: No, it's not meant to be used like that
07:41:47 <linus_> That's weird... Why would my GHCI throw such an error then??
07:41:53 <ski> isomorphic : Template Haskell could be used programatically
07:42:00 <Iceland_jack> That's a use case for Template Haskell
07:42:00 <mrordinaire> linus_: what did you type in?
07:42:03 <Enzoray> Not really, I know what the syntetic sugar part means, also the [x,y,z] == (x:y:z:[])
07:42:11 <Enzoray> Which is, the sugar.. :P
07:42:24 <isomorphic> ski, Iceland_jack : Thanks :)
07:42:28 <linus_> exactly what I copied above:
07:42:39 <linus_> mylast [1,2,3,4,5]
07:42:53 <linus_> which gives me: No instance for (Num [t0]) arising from a use of ‘it’ In a stmt of an  interactive GHCi command: print it
07:42:55 <ski> JagaJaga : CPS can be useful sometimes to improve efficiency, or to be able to express (more or less) exotic control transfers (e.g. it's easy to build cooperative concurrency on top of continuations)
07:43:00 <Enzoray> Oh, yeah. I think I understand now ski.
07:43:47 <ski> JagaJaga : CPS can also be used to specify an execution order (A-normal form, and monadic style also does this)
07:44:00 <mrordinaire> linus_: can you try entering this again?
07:44:01 <ski> Enzoray : so .. what do you need to do, then ?
07:44:12 <mrordinaire> linus_: let mylast xs = xs!!(length xs - 1)
07:44:29 <mrordinaire> linus_: and then `mylast [1,2,3,4,5]`
07:45:11 * hackagebot lifted-async 0.3.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.3.0 (MitsutoshiAoe)
07:45:21 <Enzoray> I need to create a loop, which loops x == a, x goes +1, if it's true. Add +1 to result
07:45:30 <JagaJaga> ski: thx, but that's obvious, that's like general words. Some more reallife examples or smth...?
07:46:05 <ski> JagaJaga : the `CoDensity' monad ?
07:46:45 <ski> JagaJaga : staging a regular-expression matcher into a regular-expression compiler ?
07:47:00 <flaggy> linus_: it looks like you have a different definition of mylast which is what's being called. Have you reloaded the file where you defined mylast?
07:48:05 <Enzoray> ski, how do I do that?.. :S
07:48:18 <JagaJaga> ski: oh, wow, gonna google it :)
07:48:24 <maybefbi> would it be wise to add `atMay` into Traversable? I just want a safe version of `at` for everything that is like a List e.g. Vector
07:48:27 <danilo2> Hello! :) TemplateHaskell has a method "reifyInstances" that takes name of tpye class and a list of types and returns instance definition. But am I able to get all instances no matter what are the types? just all instances that are defined. I was trying to put "forall a. a" as a type in TH, but no luck so far. Interesting is the signature of reifyInstances, because it returns list of instance declarations - but so far I do not see a
07:48:47 <flaggy> linus_: also try :t mylast and tell us what it prints
07:49:31 <ski> Enzoray : the problem in the (very short) trace i showed you is that it replaces `occurs 0 (0:1:0:[])' by `1', completely ignoring the rest of the list `1:0:[]', after checking that the head matches the sought item
07:49:51 <ski> Enzoray : so, wouldn't you say that the solution then must be to make this case *not* ignore the rest of the list (called `xs' in your code) ?
07:50:19 <Enzoray> Yeah, but can't I simply just write like.. result + 1?
07:50:53 <Enzoray> like, if (a == x = (result + 1))
07:51:03 <ski> JagaJaga : the staging part is related to partial evaluation (distinct from, but related to, partial application)
07:51:16 <Enzoray> And then check the elements one by one.
07:51:20 <Enzoray> in the list.
07:51:26 <Enzoray> It would be so much simpler.
07:52:02 <ski> JagaJaga : to express backtracking in the matching, one can use continuations. but when they are stages, one no longer has plain CPS, but rather nqCPS (not-quite Continuation-Passing Style)
07:52:22 <ski> Enzoray : how is `result' to be defined, then ?
07:52:32 <ski> result of what ?
07:52:38 <Enzoray> it can't, this is why haskell sucks.. :P
07:52:47 <ski> (your answer probably should involve "the rest of the list")
07:52:59 <ski> Enzoray : well, it can work, if you add more code explaining what `result' is to be
07:53:18 <ski> consider
07:53:27 <ski>   occurs 0 [0,1,0,2,0,1,0]
07:53:29 <ski> which is sugar for
07:53:40 <ski>   occurs 0 (0:1:0:2:0:1:0:[])
07:54:10 <flaggy> what should occurs return?
07:54:15 <ski> in the initial call, this will become matched with the "head" (the definiendum, then thing being defined) in your definition of `occurrs'
07:54:22 <ski>   occurs a (x:xs)
07:54:29 <ski> so that we will get local bindings
07:54:32 <ski>   a = 0
07:54:35 <ski>   x = 0
07:54:42 <ski>   xs = 1:0:2:0:1:0:[]
07:55:05 <ski> now, since the first element `x' is equal to `a', we want to count that element in the final result
07:55:25 <ski> but how to get the number of times `x' occurs in the rest of the list, `xs' ?
07:55:32 <ski> Enzoray : any suggestion ?
07:56:26 <Enzoray> x + 1?
07:57:01 <JagaJaga> ski: thx, a lot for you explanation :)
07:57:11 <ski> JagaJaga : i could elaborate more ..
07:57:21 <Enzoray> occurs x + 1, maybe.
07:57:24 <ski> well, `x' is an element of the list, which is not necessrily a number
07:57:54 <ski> in the example, the list contained numbers, but it could just as well have contained strings, or some other kind of thing that can't be added together using `+'
07:58:24 <ski> Enzoray : how well would you say you understand recursion ?
07:58:39 <Enzoray> 1 out of 5.
07:58:45 <ski> ok
07:59:14 <ski> the main thing with recursion is to be able to spot a smaller instance of "the same kind of problem" that you're already trying to solve
07:59:44 <ski> e.g., if you want to count the number of elements of a list : (a) well, if the list is empty `[]', then the answer is `0'
08:00:12 <ski> and (b) if the list is non-empty, say `x:xs', then we should get at least `1'
08:00:39 <ski> but if the list `x:xs' has `m' elements, then `xs' must have `m-1' elements, since it's missing the front `x'
08:01:29 <ski> so, since we're trying to compute `length (x:xs)', then `length xs' (if `length' works correctly) will return this `m-1', and so `length xs + 1' will compute the desired answer `m'
08:01:33 <ski> summarizing :
08:01:36 <ski>   length [    ] = 0
08:01:47 <ski>   length (x:xs) = length xs + 1
08:01:54 <ski> Enzoray : can you follow that ?
08:01:57 <Enzoray> Yes.
08:02:33 <ski> so, usually when writing a function that needs to inspect a list, we have two cases, one for empty list `[]', and one for non-empty list `x:xs'
08:03:05 <Enzoray> Hmm, ok.
08:03:26 <ski> and usually the non-empty case will be defined in *terms* of a recursive call to `myFunction xs', and then some extra stuff to explain how to get from answer from this smaller problem to an answer to the "full" problem `myFunction (x:xs)'
08:03:47 <ski> so, in your `occurs' case, probably you'll need to use `occurs a xs' in the recursive case
08:04:08 <ski> *if* the recursive call works all right, then that will count the number of times `a' occurs in the list `xs'
08:04:41 <Enzoray> I see, but I don't quite understand; What if it's a string then?
08:04:42 <freeman42> wrote a SO question for what I asked above: http://stackoverflow.com/q/27678078/750216
08:04:46 <ddellacosta> so, if I clone a repo and install it am I going to pollute my global cabal lib cache (or whatever I should call it)?  I've been trying to be religious about testing out libs only via sandboxes, but I'm not sure what's going to happen if I install something in this way (trying to install https://github.com/jwiegley/c2hsc)
08:05:00 <ski> your job now is only to explain how to turn a given answer for that problem into an answer to the problem `occurs a (x:xs)', iow how many times does `a' occurs in the list `x:xs', i.e. `xs' extended with a front element `x'
08:05:29 <ski> Enzoray : it doesn't matter if the elements are numbers or strings or lions, all that matters is that we can compare them for equality
08:05:36 <ski> Enzoray : did you understand the above ?
08:05:40 <Enzoray> yes.
08:05:47 <Enzoray> BUT, I still have one problem
08:06:01 <ski> ok ?
08:06:12 <Enzoray> occurs a xs is a valid statement, how does haskell comprehend "occurs a xs"
08:06:28 <Enzoray> For me, it doesn't make any sense at all, since we don't even have an operator
08:07:02 <ski> `occurs' is a function, it is being passed two arguments/parameters, `a' and `xs'
08:07:15 <ski> so `occurs a xs' is a call to that function, with those two parameters
08:07:41 <ski> i'm not sure why you're talking about operators
08:07:54 <ski> if we wanted to, we could define this function using operator syntax
08:08:22 <ski> Enzoray : are you familiar with any other programming languages ? (which ?)
08:08:24 <Enzoray> Hm, ok. It just looks pretty weird to me.
08:08:36 <Enzoray> Java/C#, which is like.. not like haskell at all.
08:08:47 <Enzoray> This is madness to me.
08:09:07 <ski> `occurs a xs' is just the idiomatic way to express in Haskell what would in (e.g.) Java idiomatically be expressed as `occurs(a,xs)'
08:09:14 <ski> it's just slightly different syntax
08:09:19 <Enzoray> Yeah, I see that now.
08:09:40 <Enzoray> It's still crazy. :P
08:09:50 <ski> if you really want to, you could in Haskell write `occurs (a,xs)' (passing a pair of an element and a list, instead of passing them separately)
08:10:22 <ski> Enzoray : hehe, i could claim that the Java syntax is crazy ;) .. it's just a matter of different conventions (well, mostly, at least)
08:10:38 <ski> Enzoray : anyway, going back to the example
08:11:05 <ski> Enzoray : i assume you agree that in the `occurs a (x:xs)' case, then answer has got to depend on whether `a == x' holds or not, correct ?
08:11:13 <ski> s/then answer/the answer/
08:11:16 <Enzoray> Yes.
08:11:31 <yitz> Enzoray: haskell syntax for a function of multiple variables uses a trick that is kind of analagous to the trick C uses for an array of multiple dimensions
08:11:39 <ski> ok. and one reasonable way to take case of that is to split in two cases, like you did with guards
08:11:51 <ski> so, our current definition template will look like
08:12:06 <ski>   occurs a [    ] = 0
08:12:12 <ski>   occurs a (x:xs)
08:12:32 <ski>     | a == x      = ...
08:12:39 <ski>     | otherwise   = ...
08:12:49 <ski> where your job is to fill in the dots
08:12:56 <ski> Enzoray : agree, so far ?
08:13:00 <Enzoray> Yeah.
08:13:23 <ski> now, we can expect that we will probably need to use recursive calls `occurs a xs' in there
08:13:27 <ski> now, let's consider
08:13:35 <ski>      occurs 0 [0,1,0,2,0,1,0]
08:13:41 <ski> which is short for
08:13:45 <Enzoray> I know.
08:13:52 <ski>      occurs 0 (0:1:0:2:0:1:0:[])
08:13:58 <ski> and so we get
08:14:03 <ddellacosta> argh, it appears the answer to my question before was "yes..." *sigh*
08:14:03 <ski>   a = 0
08:14:05 <ski>   x = 0
08:14:08 <ski>   xs = 1:0:2:0:1:0:[]
08:14:37 <Enzoray> I was thinking something like a == x = xs
08:14:43 <ski> Enzoray : now, first, what is the expected/desired answer to the main call `occurs 0 (0:1:0:2:0:1:0:[])' ?
08:14:48 <Enzoray> True
08:14:54 <Enzoray> 0 == 0 = True
08:14:56 <ski> the answer should be a number
08:15:07 <Enzoray> Oh, 1
08:15:09 <ski>   occurs :: Eq a => a -> [a] -> Int
08:15:28 <Enzoray> I lied, I mean 4
08:15:34 <ski> Enzoray : what is the expected answer to "How many times does `0' occur in the list `[0,1,0,2,0,1,0]' ?" ?
08:15:37 <ski> right
08:15:39 <ski> next
08:15:48 <ski> what about `occurs a xs' ?
08:16:04 <Enzoray> 3?
08:16:04 <ski> in our case, that means `occurs 0 (1:0:2:0:1:0:[])'
08:16:06 <ski> yes
08:16:30 <ski> so, how do we get from this sub-problem answer `3' to the desired overall answer `4' ?
08:17:18 <ski> what arithmetic do we need to use to turn `3' into `4' ?
08:17:47 <Enzoray> Great, a bunch of words I don't know.. + 1?
08:17:56 <ski> sounds like a plan :)
08:18:13 <ski> so, can you express that, in terms of the recursive call `occurs a xs' ?
08:18:27 <ddellacosta> how does one avoid installing dependencies when attempting to install a haskell binary from a source repository?
08:18:40 <ddellacosta> installing dependencies globally vs. in a sandbox, I mean
08:18:43 <ddellacosta> is it possible?
08:18:59 <Enzoray> occurs a xs + 1?
08:19:03 <yitz> ddellacosta: install it in a sandbox?
08:19:08 <ski> Enzoray : sounds great :)
08:19:12 <barrucadu> ddellacosta: You could build it in a sandbox and then move the binary to wherever you usually store user binaries
08:19:19 <ski> so, we have the first case
08:19:28 <ski>     | a == x      = occurs a xs + 1
08:19:35 <ddellacosta> yitz, barrucadu: so, that's what I apparently don't know how to do--I tried cabal init sandbox but that just overwrote the previous cabal config
08:19:37 <yitz> ddellacosta: you'll find the finished binary in .cabal-sandbox/bin
08:19:38 <ski> we also need to flesh out the second case
08:19:42 <ski>     | otherwise   = ...
08:19:48 <Enzoray> ski, that's what I had in my otherwise case.. lol. :P
08:19:51 <ski> possibly also this in terms of `occurs a xs'
08:20:03 <yitz> ddellacosta: what previous cabal config do you mean?
08:20:06 <barrucadu> ddellacosta: It's `cabal sandbox init`
08:20:12 <ski> Enzoray : any suggestion already for what to place in this second case ? or shall we look at a motivating example first ?
08:20:26 <ddellacosta> barrucadu: *sob*
08:20:35 <ddellacosta> now I realize...argh
08:20:37 <ddellacosta> no wonder
08:21:01 <ddellacosta> *sigh*...thanks barrucadu
08:21:05 <Enzoray> Something that make it check thought every single element.. (list - 1) until list = []
08:21:06 <barrucadu> heh
08:21:18 <Enzoray> idk, I forgot how that whole thing worked.. :S
08:21:19 <yitz> barrucadu: good eye!
08:21:34 <ddellacosta> yeesh, I guess I need to just wipe my cabal install now?  Not sure how to backtrack from here
08:21:44 <ski> Enzoray : let's consider now the call
08:21:51 <ski>      occurs 0 (0:1:0:2:0:1:0:[])
08:22:01 <ski> for *this* call, we will get local bindings
08:22:05 <ski>   a = 0
08:22:09 <ski>   x = 1
08:22:15 <ski>   xs = 0:2:0:1:0:[]
08:22:33 <ski> Enzoray : and so `a == x', iow `0 == 1', will evaluate to `False' here, so we get to the `otherwise' case
08:22:44 <yitz> ddellacosta: you can delete your ghc user package db if you want. or just re-install hp or ghc, which isn't as bad as it sounds.
08:22:59 <ski> Enzoray : first question : what is the desired answer to the overall query `occurs 0 (0:1:0:2:0:1:0:[])' ?
08:23:14 <Enzoray> 4?
08:23:29 <ddellacosta> yitz: yeah, I'm not too afraid of that, whatever makes more sense.  Not using haskell platform so maybe it's best to just wipe the package db
08:23:33 <ddellacosta> yitz: thanks
08:23:34 <ski> Enzoray : oops, i just realized i mistyped. sorry
08:23:41 <xauth> Typo. occurs 0 (0:1:0:2:0:1:0:[]) should be occurs 0 (1:0:2:0:1:0:[])
08:23:43 <ski> the call i'm considering here is actually
08:23:50 <ski>      occurs 0 (1:0:2:0:1:0:[])
08:24:01 <ski> Enzoray : with the first `0' removed. sorry about that
08:24:03 <Enzoray> 3, then.
08:24:07 <ski> Enzoray : so, same question
08:24:08 <yitz> ddellacosta: yeah, it's just one directory to recursively remove. (make sure to hit the right one though :))
08:24:09 <ski> yes
08:24:19 <Enzoray> Oh, I think I've got it...
08:24:19 <ski> Enzoray : second question : what is the expected answer to the recursive call `occurs a xs' here ?
08:24:40 <ski> xauth : mea maxima culpa
08:24:45 <Enzoray> Still, 3
08:24:47 <ski> yes
08:24:49 <yitz> ddellacosta: run ghc-pkg list to verify what directory to delete. also a good way to check the status of things.
08:25:07 <ski> Enzoray : so, how to get from the given sub-problem answer `3' to the desired overall answer `3' ?
08:26:04 <Enzoray> xs == the list? :P
08:26:16 <ski> `xs' is the list `0:2:0:1:0:[]', here
08:26:38 <Enzoray> I'm sorry, I don't think I quite was able to comprehend your question..
08:26:59 <ddellacosta> yitz: so, what's going to happen if I just wipe that sucker out?  Is it safer to simply re-install ghc?
08:27:24 <yitz> ddellacosta: it's fine, ghc will just recreate a new empty one next time you run it
08:27:34 <ski> Enzoray : the main part of writing recursion is to bridge the gap between the answer that the recursive call computes, to the desired overall answer
08:27:50 <Enzoray> Could you demonstrate?
08:27:52 <ski> Enzoray : in the previous case, the answer to this was "add one"
08:28:00 <ddellacosta> yitz: okay, thanks
08:28:09 <ski> so i'm asking what the answer is in this case (where `a' is not equal to `x')
08:28:28 <dfeuer> case a/=x of True -> ?
08:28:35 <ski> dfeuer : guards
08:28:56 <dfeuer> ski, I'm in a silly mood. I was taking that totally out of context.
08:29:12 <Enzoray> Oh, split again, removing x, trying the above case again
08:29:15 * ski suspects that the problem here for Enzoray is that this is soo easy that it becomes hard
08:29:28 <dfeuer> But ski, if you have any thoughts on the sequence-zipping question I just sent to haskell-cafe, I'd really love to hear them.
08:29:49 <ski> Enzoray : yes, the recursive call does the "trying the above case again", for the remainder of the list, `xs'
08:29:54 <dfeuer> Enzoray, what's the problem again?
08:30:04 <ski> Enzoray : the question is what to add to the answer that the recursive call computes, if anything
08:30:13 * hackagebot flock 0.3.1.8 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.8 (ErikHesselink)
08:30:13 <dfeuer> ski, I suspect some lpaste may help keep track of where things are.
08:30:16 <ski> dfeuer : count occurances of an element in a list
08:30:30 <dfeuer> ski, a particular element, or all of them?
08:30:41 <ski> dfeuer : this being an example of learning how to loop with recursion
08:30:54 <ddellacosta> yitz, barrucadu, thanks for your help--user-local package repo wiped out and I think I'm back on track with the sandbox install!
08:30:55 <ski>   occurs :: Eq a => a -> [a] -> Int
08:31:02 <dfeuer> Ah.
08:31:27 <Enzoray> ski, mind helping me out on this one?.. :S
08:31:38 <ski> Enzoray : let's write a tentative solution as
08:31:39 <dfeuer> Enzoray, I personally tend to reach the best understanding of Haskell when I *don't* think of things as "loops".
08:31:52 <dfeuer> Start by setting up a pattern match.
08:32:02 <ski>     | otherwise   = ..(occurs a xs)..
08:32:11 <dfeuer> And if there are significant conditions, then guards
08:32:15 <dfeuer> And try to fill in the blanks.
08:32:37 <ski> Enzoray : since we probably will need to use `occurs a xs' in there, but we don't know exactly what more, if anything, we need
08:32:40 <ski> Enzoray : ok ?
08:32:50 <Enzoray> ok.
08:32:58 <ski> so, summarizing what we've go so far :
08:33:11 <ski>   occurs a [    ] = 0
08:33:17 <ski>   occurs a (x:xs)
08:33:21 <ski>     | a == x      = occurs a xs + 1
08:33:27 <ski>     | otherwise   = ..(occurs a xs)..
08:33:35 <ski> s/go/got/
08:33:55 <ski> let's consider our example, again
08:34:05 <ski>      occurs 0 (1:0:2:0:1:0:[])
08:34:43 <ski>   =  ..(occurs 0 (0:2:0:1:0:[]))..  -- because `0 == 1' is `False', we use the last case
08:35:25 <ski>   =  ..3..  -- *assuming* that the recursive call here will work correctly, `3' is the answer that we expect for it
08:35:49 <ski> so, the recursive call counts the number of times `0' occurs in the tail list `0:2:0:1:0:[]'
08:36:09 <ski> but we want the number of times `0' occurs in the whole given list `1:0:2:0:1:0:[]'
08:36:15 <ski> Enzoray : ok ?
08:36:30 <Enzoray> Yeah, but that's what xs + 1 does, retrieving the whole list?
08:36:32 <ski> how to compute the latter from the former ?
08:36:42 <ski> there's no `xs + 1'
08:36:52 <ski> `occurs a xs + 1' means `(occurs a xs) + 1'
08:37:00 <ski> (in Java notation, it would be `occurs(a,xs) + 1')
08:37:04 <wei2912> Enzoray: assuming xs is a list, you can't add a list and a number
08:37:40 <Enzoray> Can we add + x?
08:37:55 <ski> `x' isn't necessarily a number, it could be a string
08:37:58 <ski> or something else
08:38:47 <ski> Enzoray : we know : the first element `x' is not equal to `a', the number of times `a' occurs in `xs' (here `0:2:0:1:0:[]') is some number, say `m' (here `3')
08:39:18 <ski> Enzoray : we want : the number of times `a' occurs in `x:xs' (here `1:0:2:0:1:0:[]') -- how to express this in terms of `m' ?
08:39:40 <ski> Enzoray : if `0' occurs three times in `0:2:0:1:0:[]', how many times does `0' occur in `1:0:2:0:1:0:[]' ?
08:39:54 <Enzoray> The same amount of times.
08:39:56 <ski> yes
08:39:57 <ski> why ?
08:40:22 <Enzoray> Depending on the value of x. Because in this case a /= x
08:40:26 <ski> correct
08:40:31 <Enzoray> But, what if it is?
08:40:52 <Enzoray> So, simply.. Otherwise
08:41:00 <Enzoray> Case 1 = if x is true
08:41:07 <iElectric> is it possible to do type instances with partial application? if not, what's the alternative?
08:41:07 <Enzoray> otherwise = if x is false
08:41:12 <ski> so, the answer to the overall query `occurs a (x:xs)' is, in *this* case (where `a' is not equal to `x') the *same* as the answer to the recursive query `occurs a xs'
08:41:21 <Enzoray> Is that how you see this?
08:41:38 <ski> well, `x' is an element, not necessarily a boolean
08:41:48 <ski> `a == x' is a boolean, that can be `True' or `False'
08:42:11 <ski> but i'm basically seeing these two cases here, yes. as i assume you're also seeing them ?
08:42:19 <Enzoray> Yes.
08:42:22 <ski> Enzoray : so, how to fill in the dots in
08:42:26 <ski>     | otherwise   = ..(occurs a xs)..
08:42:27 <ski> ?
08:42:43 <ski> <Enzoray> The same amount of times.
08:42:51 <ski> is the answer, but how to express that in code ?
08:43:39 <Enzoray> Well.. Mind giving me a blue?
08:44:02 <Enzoray> clue*
08:44:03 <Enzoray> :P
08:44:11 <ski> well, since the overall answer is the same amount of times as the recursive answer, you need *nothing* more than the recursive call
08:44:14 <ski> so
08:44:14 <ski>     | otherwise   = ..(occurs a xs)..
08:44:16 <ski> becomes just
08:44:17 <ddellacosta> damn, I had a really nice aquamarine ready to go
08:44:19 <ski>     | otherwise   = occurs a xs
08:44:20 <Enzoray> occurs a xs?
08:44:22 <ski> right
08:44:27 <kadoban> ddellacosta: XD
08:44:28 <Enzoray> You tricked me.. :P
08:45:14 <ski> Enzoray : i wanted you to recognize the general situation, and also to realize that sometimes some dots can amount to nothing more to add
08:45:23 <ski> so, our complete definition is
08:45:28 <ski>   occurs :: Eq a => a -> [a] -> Int
08:45:31 <ski>   occurs a [    ] = 0
08:45:34 <ski>   occurs a (x:xs)
08:45:37 <ski>     | a == x      = occurs a xs + 1
08:45:43 <ski>     | otherwise   = occurs a xs
08:45:43 <yitz> dfeuer: cool stuff in Seq, thanks!
08:45:55 <yitz> dfeuer: so you
08:45:59 <Enzoray> It's so simple, yet I can't figure it out.. :P
08:46:23 <ski> Enzoray : so, in *both* the latter two cases do we call `occurs a xs' to compute the number of times the sought element `a' occurs in the tail list `xs'
08:46:37 <ddellacosta> Enzoray: that's kind of Haskell in a nutshell, in the beginning at least...give it time
08:46:38 <yitz> dfeuer: so you're trying to think of a way to exploit that we know it's not just any old sequence of splits, to remove the exponent on the log, right?
08:46:50 <ski> Enzoray : if `a' is equal to the head element, we add one to that answer, otherwise we do nothing more to that answer
08:47:26 <ski> Enzoray : what i'm trying to show you is how to begin to think recursively, so that after a little practice, all this will come naturally to you, so that you can write the above code immediately, in a few seconds
08:47:28 <Enzoray> That's what I wanted to do at first, by saying = 1
08:47:38 <ski> Enzoray : .. and similarly for more complicated cases of recursion
08:47:54 <vanila> why not occurences = length . filter (==x) ?
08:47:57 <ski> Enzoray : i know, but you forgot to also count the number of times `a' occured in the tail list `xs' there
08:48:13 <ski> vanila : because we're practicing recursion :)
08:48:19 <vanila> okay
08:48:33 <Enzoray> I think I see what you see, a bit more now.
08:48:47 <Enzoray> I always forget what the variables mean, which cause some trouble for me.. :P
08:48:51 <ski> Enzoray : to round off, i'd like to show a short full reduction trace of our example
08:49:41 <ski>      occurs 0 (0:1:0:2:0:1:0:[])
08:50:02 <ski>   =  occurs 0 (1:0:2:0:1:0:[]) + 1  -- because `0 == 0' holds
08:50:16 <ski>   =  occurs 0 (0:2:0:1:0:[]) + 1  -- because `0 == 1' doesn't hold
08:50:31 <ski>   =  (occurs 0 (2:0:1:0:[]) + 1) + 1  -- because `0 == 0' holds
08:50:46 <ski>   =  (occurs 0 (0:1:0:[]) + 1) + 1  -- because `0 == 2' doesn't hold
08:51:02 <ski>   =  ((occurs 0 (1:0:[]) + 1) + 1) + 1  -- because `0 == 0' holds
08:51:14 <ski>   =  ((occurs 0 (0:[]) + 1) + 1) + 1  -- because `0 == 1' doesn't hold
08:51:15 <flaggy> a nice way to write that function is occurs x = length . filter (==x)
08:51:33 <ski>   =  (((occurs 0 [] + 1) + 1) + 1) + 1  -- because `0 == 0' holds
08:51:52 <ski>   =  (((0 + 1) + 1) + 1) + 1  -- finally using the base case, when we reach the end of the list (the empty list)
08:52:03 <ski>   =  ((1 + 1) + 1) + 1  -- some arithmetic
08:52:08 <ski>   =  (2 + 1) + 1  -- some arithmetic
08:52:12 <ski>   =  3 + 1  -- some arithmetic
08:52:15 <ski>   =  4  -- some arithmetic
08:52:28 <narfinger> hiho, quick question: i have defined a data type and want to use deriving for almost all of the values for show but for one i have to do it extra, do i have to implement the whole show function or can i save somewhere?
08:52:30 <Enzoray> So wait.. It's just comparing true and false the whole time..if true = 1, false = 0
08:52:33 <ski> Enzoray : try to see exactly which part of the definition is used in each step
08:52:56 <Enzoray> My .... = 1 didn't mean anything for it AS A RESULT?
08:53:08 <Enzoray> It was a instruction.. right?
08:53:16 <ski> Enzoray : i don't understand your question
08:53:40 <yitz> narfinger: one trick is to wrap the value of the problematic constructor in a separate data or newtype and write the manual Show instance for that.
08:53:44 <Enzoray> You're just comparing a with x, if a == x (true), it gives result 1.
08:54:01 <ski> narfinger : afaik, you have to implement it manually. please be aware of `showsPrec',`showParen',`showString',`showChar',`shows'
08:54:13 <Enzoray> I thought I was the one to give the result, not to lead it's way to it.
08:54:28 <ski> Enzoray : "if a == x (true), it gives result 1" -- no, in that case it's *adding* `1' to the recursive result
08:54:32 <narfinger> mhhh ok thanks
08:55:04 <ski> Enzoray : the recursion handles all the rest of the elements, you just have to tell whether to add anything more to it, in each step
08:55:17 <Enzoray> By simply putting a == x = 1, I thought when ex. 'a' = a:s:a:[] (a) = gives the answer 1, as in + 1 to the result.
08:55:27 <Enzoray> Yeah, I see now.
08:55:43 <ski> narfinger : if you paste your datatype, and describe how you want your special case to work, i could try to show how to code it manually
08:56:27 <ski> Enzoray : right, if you don't make a recursive call, here `occurs a xs', then you don't use the "recursive result", you're just ignoring the remaining elements `xs'
08:56:31 <Enzoray> You're giving it instuctions to find the result, the result is determined of how many cases of them are true, based on a == x = ... (... being the instruction to find the amount of truth)
08:56:55 <ski> Enzoray : ok, if that helps you to understand it, that's fine :)
08:57:07 <Enzoray> It makes more sense to me that way.
08:57:14 <ski> to each their own :)
08:57:40 <Enzoray> On the otherhand, I'm not really that logical. This probably is java for you.
08:58:16 <ski> nah, didn't sound very Javaish to me
08:58:41 <Enzoray> Java being syntax madness, sorry to ruin the joke. :P
08:59:11 <dfeuer> yitz, something. It would have to split differently somehow.
08:59:43 <ski> Enzoray : now, you need more practice writing recursions
08:59:45 <Enzoray> I must say, you sure know how to explain stuff. Thanks for helping me out, you made this a lot more clear for me. :P
08:59:53 * ski bows
09:00:00 <Enzoray> Yeah, but I have quite a lot to practice on. :P
09:00:08 <dfeuer> Ah, yitz = Yitzchak Gale. If anyone can do it, he probably can.
09:00:16 <Enzoray> I've tried 99 problems, I got stuck at.. exercise 8 or something.
09:00:46 <Enzoray> Perhaps it's too hard for me, still. Are there any other exercises out there regarding haskell?
09:00:52 <Enzoray> For beginners of course. :P
09:01:04 <ski> hm, iirc LYAH includes exercises ?
09:02:23 <kadoban> Enzoray: Have you read any of the haskell beginner stuff? This site has a /lot/ of options https://github.com/bitemyapp/learnhaskell
09:02:29 <ski> Enzoray : one function which you could perhaps try to define is `myIndex' where `myIndex xs n' is supposed to return the `n'th element of the list `xs' (starting to count from `0')
09:03:19 <kadoban> Enzoray: The tl;dr version is, start with: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:03:19 <ski> Enzoray : if you want to consider kadoban's suggestion, you could possibly also join #haskell-beginners
09:04:01 <Enzoray> I don't know if I have time for that.
09:04:51 <ski> ok, np
09:06:14 <MrOrdinaire> kadoban: thanks for the pointer
09:07:10 <Enzoray> The exam-time is soon here.
09:07:15 <Enzoray> Then I have to be prepared.
09:07:34 * ski nods
09:07:42 <MrOrdinaire> does Haskell support anything like the planned value types for the JVM?
09:07:53 <MrOrdinaire> like here http://cr.openjdk.java.net/~jrose/values/values-0.html
09:07:58 <ski> Enzoray : if we don't see you here again before the exam, good luck !
09:08:46 <Enzoray> ski, trust me.. you will..! :P
09:09:46 <Enzoray> How do I define myIndex?
09:10:00 <Enzoray> myIndex :: a -> [a] -> a
09:10:02 <MrOrdinaire> hmm, that should be a detail of the implementation... Okay, rephrase, does GHC support user defined value types?
09:10:03 <Enzoray> Is that it?
09:10:31 <MrOrdinaire> Enzoray: that's just a type annotation, not the declaration for the function.
09:10:48 <MrOrdinaire> and it should be something like
09:10:51 <statusfailed> Is there an article on how Djinn works/
09:10:56 <MrOrdinaire> myIndex :: Int -> [a] -> a
09:11:02 <bennofs> MrOrdinaire: not quite sure, but I think using unboxed, strict fields may work
09:11:19 <MrOrdinaire> as the index must be an Int (?)
09:11:41 <ski> let's say `Int', to not make it more complicated
09:11:49 <Enzoray> (18:00:52) (ski) Enzoray : one function which you could perhaps try to define is `myIndex' where `myIndex xs n' is supposed to return the `n'th element of the list `xs' (starting to count from `0')
09:11:59 * ski had the arguments in the other order, though
09:12:06 <MrOrdinaire> then it should be
09:12:14 <ski> (it doesn't matter much, as long as you stick to your choice)
09:12:17 <MrOrdinaire> myIndex :: [a] -> Int -> a
09:12:34 <MrOrdinaire> the array, the index then the result
09:13:07 <ski> (.. in case you need to implement some functions for someone else, and they requested a specific ordering, then you should of course conform to that, unless there's compelling reasons to try to negotiate a change)
09:13:16 <ski> MrOrdinaire : not an array, a list :)
09:13:26 <ski> (there are arrays as well in Haskell)
09:13:31 <kadoban> MrOrdinaire: I didn't really read all of that, but the parts I did sound a lot like unboxed types, which are really just an implementation detail/optimization. GHC has them.
09:13:38 <MrOrdinaire> ski: ah, sorry for the confusion
09:14:22 <ski> > let anArray = listArray (0,9) [i^2 | i <- [0 .. 9]] in anArray ! 3
09:14:24 <lambdabot>  9
09:14:33 <MrOrdinaire> kadoban: this one? https://hackage.haskell.org/package/vector-0.7.0.1/docs/Data-Vector-Unboxed.html
09:14:36 <ski> > let aList = [i^2 | i <- [0 .. 9]] in aList ! 3
09:14:38 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array i0 e’
09:14:38 <lambdabot>              with actual type ‘[t0]’Could not deduce (GHC.Real.Integral b0)
09:14:38 <lambdabot>    arising from a use of ‘GHC.Real.^’
09:14:48 <ski> > let aList = [i^2 | i <- [0 .. 9]] in aList !! 3  -- correction
09:14:49 <lambdabot>  9
09:15:28 <ski> so, i'm basically asking Enzoray to reimplement `(!!)', but renaming `xs !! n' to `myIndex xs n', to not clash with the standard name
09:16:43 <kadoban> MrOrdinaire: Yes. But that's just one thing that uses them, they're more general than just that. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html  I'm no expert really, I rarely/never get down to tuning that far in haskell yet (just throwing that out there).
09:17:05 <ski> Enzoray : here's a couple more suggestions : `reverse xs' should compute the reversal of the list `xs'. `evens xs' should skip every odd-indexed element, so that `evens "goodbye"' evaluates to `"gobe"'
09:18:38 <ski> Enzoray : `remberuptolast a xs' should return a list of all the elements of `xs', from the start, up to (and including) the *last* occurance of `a' in `xs' -- if there's no `a' in `xs', it should return the whole of `xs'
09:18:52 <MrOrdinaire> kadoban: thanks for the link. I'll do some reading of that.
09:18:58 <ski> (perhaps rename that to `remberUpToLast', to make it more readable)
09:19:35 <MrOrdinaire> ski: those are some nice challenges :)
09:20:01 * ski grins
09:21:12 <Enzoray> myIndex :: Eq a => a -> [a] -> Int
09:21:12 <Enzoray> myIndex a (x:xs)
09:21:12 <Enzoray> 		| x == a = 0
09:21:12 <Enzoray> 		| otherwise = 1 + myIndex a xs
09:22:04 <ski> that doesn't conform to MrOrdinaire's suggested type signature for `myIndex' above (either of them)
09:22:20 <Enzoray> I know, I thought they looked strange
09:22:34 <ski> this one computes some kind of number
09:22:38 <Enzoray> So, I used one granted from my friend.
09:23:00 <ski> the `myIndex' i suggested would return an element of the list (not necessarily containing numbers)
09:23:56 <ski> this one (assuming a call `myIndex a theList') appears to count the number of elements *before* the first occurance of `a' in `theList',
09:24:05 <ski> Enzoray : is that what you intended to code ?
09:24:29 <ski> (also, since it doesn't handle the empty list case, it will not work in case `theList' doesn't contain `a')
09:24:36 <Enzoray> Erm, kind of..
09:25:15 * hackagebot haskell-updater 1.2.4 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.4 (SergeiTrofimovich)
09:25:28 <ski> @let myStery :: Eq a => a -> [a] -> Int; myStery a (x:xs) | x == a = 0 | otherwise = 1 + myStery a xs
09:25:30 <lambdabot>  Defined.
09:25:55 <ski> > myStery 'p' "Pauper"
09:25:56 <lambdabot>  3
09:26:10 <exio4> what would be the easiest way to learn Haskell if you only know the very basics of IP (in C++.. for that matter)? (mostly just "what loops are", "what an if does", "what a variable is")
09:26:24 <ski> > myStery False [True,True,True,False,False,True,False]
09:26:25 <lambdabot>  3
09:26:59 <ski> exio4 : perhaps a tutorial or a textbook ?
09:27:07 <ski> or the wikibook
09:27:43 <ski> exio4 : having someone in person in front of you, explaining concepts, and walking you through things can also help
09:28:49 <exio4> it is for a friend, I'll try to explain concepts and what not, but I would like to find some resources that don't need so much "background" that I could use
09:28:52 <ski> Enzoray : just in case you don't know, it's good practice to test one's functions out with simple examples in the interactor (like GHCi, e.g.)
09:29:33 <flebron> Hey folks. Can a Data.ByteString.Char8 ByteString be randomly read? I can't find (!) in https://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Char8.html
09:29:54 <Enzoray> ski, I see.
09:30:42 <Enzoray> A friend showed me how to solve this, this question was on a previous exam.
09:30:54 * ski nods
09:31:01 <Enzoray> So, I kind of know how to solve it.. by memorizing the solution
09:31:18 <Enzoray> I know what it does in words, but I don't really understand the whole picture in code.
09:31:44 <ski> it's better to memorize (and practice) a more general solution method (for attempting to determine what code to write)
09:32:20 <ski> Enzoray : so .. would you like trying to code one of the auxilary challenges i suggested ?
09:32:26 <Enzoray> yes
09:32:36 <ski> how about `myIndex xs n', then ?
09:32:45 <Enzoray> what about it?
09:33:01 <flebron> Hrmph. Seems there's no O(1) random access to a ByteString O.o
09:33:01 <ski> well, you didn't solve it according to my specifications :)
09:33:11 <RchrdB> flebron: the function is index :: ByteString -> Int -> Char
09:33:14 <Enzoray> Oh yeah.. :P
09:33:21 <ski> <ski> Enzoray : one function which you could perhaps try to define is `myIndex' where `myIndex xs n' is supposed to return the `n'th element of the list `xs' (starting to count from `0')
09:33:22 <flebron> Oh! Weird name. Thanks!
09:33:25 <ski> e.g.
09:33:38 <ski>   myIndex "catfood" 3
09:33:39 <Enzoray> myIndex :: [a] -> Int -> a, right?
09:33:44 <RchrdB> flebron: you can't O(1) index a lazy byte string
09:33:50 <ski> is supposed to evaluate to the character `f'
09:33:56 <ski> Enzoray : right
09:35:03 <flebron> RchrdB: This is a Data.ByteString.Char8, is that by default lazy?
09:35:03 <ski> Enzoray : it's often easiest to start with base case(s)
09:35:06 <RchrdB> but a strict byte string is iirc a vector of Word8s plus a length and offset, so heck yes you should be able to index that in constant time. :)
09:35:23 <Enzoray> myIndex [] n = []
09:35:27 <flebron> (Also, is there a way to create a bytestring that is a "slice" (contiguous substring) of another?)
09:35:46 <Enzoray> myIndex [] n = error "404: list not found"
09:35:52 <prophile> wild speculation: Conal's continuous time FRP stuff comes from an idea of using functions from the reals rather than functions from the naturals for "streams", what would be the implications of using functions from the rationals?
09:35:54 <ski> Enzoray : that can't work, since the function is supposed to return an element of the list, not a new list
09:35:54 <Enzoray> Looks better and.. phunnier. :D
09:36:00 <ski> Enzoray : yes, using `error' can work :)
09:36:04 <RchrdB> flebron: D.B.Char8 operates on the same data structure as D.B, it just gives you Chars instead of Word8s
09:36:24 <ski> Enzoray : since if the list is empty, then it has no elements, so in particular no element at index `n' to return
09:36:36 <RchrdB> So the data structures are the same, just the functions are different
09:36:44 <ski> (so obviously the function can't return any sensible result in this case)
09:37:03 <flebron> Ah OK, I can use O(1) drop and take :)
09:37:30 <ski> flebron : `splitAt' ?
09:37:53 <flebron> Well that'd not give me arbitrary (i, j)
09:38:03 <flebron> I'd have to do two of them, at which point I may as well just drop and take :)
09:38:13 <ski> prophile : well, it'd depend on what you mean by "reals" :)
09:38:22 <ski> flebron : i see :)
09:38:38 <Enzoray> By that you mean I can't use error all of a sudden?.. :/
09:38:47 <prophile> ski: true! "Rational" vs "Double" then, for concreteness
09:38:54 <ski> Enzoray : of course you can use `error', if there's no sensible result to return
09:39:12 <ski> prophile : well, `Rational' is arbitrary precision
09:39:13 <RchrdB> flebron: yeah, drop and take are O(1), you can define substr. :)
09:39:18 <Enzoray> That's what I thought as well.
09:39:27 <Enzoray> You just sounds so alarmed. :P
09:39:37 <Enzoray> And don't even bother to ask me how you sound then, :D
09:39:54 <ski> hehe, i didn't feel a bit alarmed, even ;)
09:40:22 <ski> (well, perhaps you're talking about my response to `myIndex [] n = []')
09:40:30 <RchrdB> It's nicer to never use error, though. e.g. if a computation might fail, have it return Maybe X instead of X...
09:40:31 <prophile> ski: indeed, thought it doesn't have sensible definitions for sine/cosine/whatnot
09:41:13 <RchrdB> > asin (1 / w :: Rational)
09:41:14 <lambdabot>  Couldn't match type ‘Debug.SimpleReflect.Expr.Expr’
09:41:14 <lambdabot>                with ‘GHC.Real.Ratio GHC.Integer.Type.Integer’
09:41:14 <lambdabot>  Expected type: GHC.Real.Rational
09:41:34 <kadoban> prophile: Are there sensible definitions even possible in Rational for those?
09:41:38 <RchrdB> Oops, typo
09:41:49 <Enzoray> ski, this is a lot harder than I thought.. Without Eq a, I'm not allowed to use a == x, right?
09:41:57 <RchrdB> > asin (1/2::Rational)
09:41:58 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
09:41:58 <lambdabot>    arising from a use of ‘GHC.Float.asin’
09:41:59 <Enzoray> Nothing with ==, actually.. :P
09:42:00 <prophile> kadoban: yes, if you play a bit fast and loose with the types
09:42:10 <kadoban> Hmm
09:42:19 <prophile> as in it's sensible for them to have rationals as the domains, just not the codomains
09:43:07 <ski> Enzoray : you can always use `==' for `Int's, since we already know `Eq Int', iow that `Int' is in the `Eq' type class, iow that `Int's can be compared for equality using `(==)' and `(/=)')
09:46:38 <kadoban> prophile: Ah, yes true.
09:48:09 <Enzoray> I don't see how that will help me right now, could you explain the question for me in plain english?
09:48:25 <ski> Enzoray : what if `n' is zero ?
09:48:30 <Enzoray> I believe it would help me to understand the question a bit further.
09:48:51 <ski> (or which question did you mean ?)
09:48:51 <Enzoray> Oh...
09:48:54 <Enzoray> You mean like that..
09:49:27 <Zekka> > fix(([1,1]++).(zipWith(+)<*>tail))
09:49:28 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:49:32 <Zekka> Anyone think they can golf this further?
09:50:27 * ski would start with `0', out of principle
09:51:29 <vanila> 1:1: instead of [1,1]++
09:51:39 <vanila> or does that not section right? :/
09:51:45 <vanila> :t (1:1:)
09:51:46 <lambdabot>     The operator ‘:’ [infixr 5] of a section
09:51:46 <lambdabot>         must have lower precedence than that of the operand,
09:51:46 <lambdabot>           namely ‘:’ [infixr 5]
09:51:49 <vanila> oh well
09:52:04 <indiagreen> > fix(\x->1:1:(zipWith(+)<*>tail)x)
09:52:16 <vanila> ah nice one
09:52:25 <indiagreen> it saves 1 character
09:52:41 <Zekka> indiagreen: Not bad!
09:52:43 <vanila> :t zip`ap`tail
09:52:43 <lambdabot> [b] -> [(b, b)]
09:53:04 <vanila> > (length "map(+).zip`ap`tail", length "zipWith(+)<*>tail")
09:53:05 <lambdabot>  (18,17)
09:53:12 <vanila> that just makes it worse then
09:53:33 <Enzoray> myIndex :: [a] -> Int -> a
09:53:33 <Enzoray> myIndex [] n = error "404: list not found"
09:53:33 <Enzoray> myIndex (x:xs) n
09:53:33 <Enzoray> 		| n == 0 = 0
09:53:33 <Enzoray> 		| otherwise =
09:53:34 <lpaste> shaykha pasted “Why does my code compile?” at http://lpaste.net/117379
09:53:38 <Enzoray> This is what I have atm, ski.
09:53:57 <shaykha> cancel that it apparently only compiles on my machine
09:53:57 <ski> Enzoray : ok
09:54:11 <khyperia> > ap(++)show"ap(++)show" -- completely unrelated note to fibs, but this is my favorite code golf quine I've ever seen
09:54:12 <lambdabot>  "ap(++)show\"ap(++)show\""
09:54:24 <ski> Enzoray : what should `myIndex ["the","small","cat"] 0' return ?
09:55:15 <ski> @where quine
09:55:15 <lambdabot> ap (++) show "ap (++) show "
09:55:19 <Enzoray> I see.
09:55:24 <khyperia> oh, heh, ski
09:55:30 <Enzoray> I'm missing a condition, right?
09:55:43 <ski> Enzoray : just answer the question ? :)
09:55:43 <Enzoray> Where n /= element in list
09:55:53 <Enzoray> I don't know, my brain melted by watching it.
09:56:14 <ski> Enzoray : what should `myIndex theList n' return, in words ?
09:56:38 <Enzoray> The position n occurs in theList
09:56:44 <Enzoray> But, since it doesn't occur. Nothing
09:57:41 <Enzoray> But I don't have that condition in my code.
09:57:44 <ski> well, perhaps `n = 2' and `theList = [2,3,5,7]
09:57:46 <ski> '
09:57:55 <Enzoray> Then it would return 0.
09:58:06 <ski> with your current definition, yes
09:58:14 <ski> but now according to my specification :)
09:58:30 <ski> <ski> Enzoray : one function which you could perhaps try to define is `myIndex' where `myIndex xs n' is supposed to return the `n'th element of the list `xs' (starting to count from `0')
09:59:05 <ski> so, since the `2'nd element of `[2,3,5,7]' (counting from zero) is `5', then `myIndex [2,3,5,7] 2' ought to return `5'
09:59:21 <ski> well
09:59:30 <ski> `myIndex [2,3,5,7] 0' ought to return `2'
09:59:37 <ski> Enzoray : do you agree ?
10:00:04 <Enzoray> I don't know what to believe anymore, you just shattered my reality. :P
10:00:22 <indiagreen> aha
10:00:27 <Enzoray> How can it return nothing that is not stated in the list?
10:00:33 <indiagreen> > fix(\s->1:zipWith(+)s(1:s))
10:00:34 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
10:00:43 <indiagreen> Zekka: ^
10:00:47 <Enzoray> Oh, now I see.
10:00:48 <ski> Enzoray : `2' is stated as the initial element in the given list `[2,3,5,7]'
10:00:53 <ski> the `0'th element
10:01:00 <Enzoray> I've missunderstod the question all along.. :S
10:01:08 <ski> ok
10:01:15 <Enzoray> Yeah, I'm with you now.
10:01:21 <ski> (sorry if i was unclear)
10:01:39 <Enzoray> No, I was just thinking of another task, which made me mix them uå
10:01:41 <Enzoray> up*
10:01:41 <lpaste> shaykha pasted “Why does my code compile?” at http://lpaste.net/680155273012183040
10:01:44 <ski> ok
10:02:11 <Enzoray> | n == 0 = x
10:02:18 <Enzoray> That makes more sense then.
10:02:25 <indiagreen> ouch, I lost a “1”
10:02:27 <indiagreen> nevermind
10:02:29 <ski> shaykha : it doesn't
10:02:35 <ski> Enzoray : great
10:02:45 <ski> Enzoray : now for the recursive case
10:03:00 <indiagreen> no, not nevermind, even with “1:” before “fix” it's still shorter
10:03:12 <Enzoray> So basicly, recursive functions is about figuring out how to solve x, then repeat to solve xs
10:03:16 <ski> shaykha : syntax error at line `19'
10:03:26 <lpaste> shaykha pasted “Why does my code compile?” at http://lpaste.net/6575938896926867456
10:03:41 <shaykha> alright now it works
10:04:18 <ski> Enzoray : recursion is about solving each problem in a "class" of problems, where, for all but the simplest problem instances, the solution of the problem is expressed in terms of solutions to "easier" problems
10:04:38 <ski> Enzoray : for lists, *usually* (but not always), the "simpler problem" involves the tail of the list
10:05:02 <shaykha> but yes, my question is with regards to how it interacts with the IO monad, specifically in the getRots function
10:05:10 <shaykha> and main
10:05:26 <ski> Enzoray : for non-negative integers, "simpler problems" could be ones involving non-negative integers that are less than the given one. e.g. one less than it
10:05:58 <kadoban> Enzoray: If you remember induction from math...it's induction for coders.
10:06:14 <Enzoray> I'm not quite fond of these sort of stuff.. it's so simple once you see the whole thing as one. But I never manage to see it through.. :S
10:06:25 <ski> shaykha : instead of `getRots', i'd use a `let' in the `do'
10:06:28 <Enzoray> induction?
10:06:38 <ski> yes, it's related to induction
10:06:42 <kadoban> Enzoray: Well, it seems like you've seen through this one decently enough :)
10:07:09 <ski> kadoban : still working on the recursive case here, though :)
10:07:13 <Enzoray> I suck so hard at inductions, it's embarassing.. :P
10:07:37 <ski> with practice, recursion becomes easier
10:07:37 <shaykha> in main, rots should be of type IO Int, since that is what getRots returns...in the rotate function, which is having the rots passed, type Int is expected, but passing what I think is an IO Int isn't giving me an error
10:08:10 <Enzoray> ski, I sure hope so.. :P
10:08:15 <ski> shaykha : `getRots $ args !! 1' is of type `IO Int', but `rots' is of type `Int'
10:08:53 <shaykha> :t (<-)
10:08:54 <lambdabot> parse error on input ‘<-’
10:09:00 <ski> shaykha : `foo <- bar', will execute `bar', of type `IO Blah' say, and bind `foo' to the result of type `Blah'
10:09:24 <ski> shaykha : `<-' is syntax belonging to the `do'-block. it's not an ordinary operator
10:09:50 <shaykha> thank you, I think I get it now
10:10:32 * ski would also personally remove the `$'s here, using brackets instead
10:11:21 <ski> shaykha : but instead of (effectively) `rots <- return (read (args !! 1) `mod` 26)', i'd prefer `let rots = read (args !! 1) `mod` 26'
10:12:15 <Enzoray> myIndex :: [a] -> Int -> a
10:12:15 <Enzoray> myIndex [] n = error "404: list not found"
10:12:15 <Enzoray> myIndex (x:xs) n
10:12:15 <Enzoray> 		| n == 0 = x
10:12:15 <Enzoray> 		| otherwise = myIndex xs (n + 1)
10:12:21 <ski> shaykha : and instead of `args <- getArgs', you could say `arg0:arg1:arg2:_ <- getArgs', and then instead use `arg1' and `arg2' in place of `args !! 1' and `args !! 2'
10:12:23 <Enzoray> Compiles, doesn't work though.
10:12:49 <ski> Enzoray : ok, let's see what happens here
10:13:08 <ski>      myIndex (2:3:5:7) 2
10:13:19 <Enzoray> = 0
10:13:34 <ski>   =  myIndex (3:5:7) (2 + 1)  -- since `2 == 0' doesn't hold
10:13:47 <Enzoray> I see that now. But how can I adjust the terms?
10:13:59 <ski>   =  myIndex (3:5:7) 3  -- arithmetic, since we need to check `2 + 1 == 0'
10:14:01 <Enzoray> There is obviosly something wrong with the otherwise.
10:14:27 <ski>   =  myIndex (5:7) (3 + 1)  -- since `2 + 1 == 0', iow `3 == 0', doesn't hold
10:14:37 <ski> (sorry, i'm missing a `:[]' at the end of the list)
10:14:57 <ski> Enzoray : so .. you keep adding one to the integer argument .. not getting any closer to zero (your base case)
10:15:17 * hackagebot haskell-updater 1.2.5 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.5 (SergeiTrofimovich)
10:15:28 * ski keeps watch for any light above Enzoray's head
10:15:59 <Enzoray> So, my goal is to get to the base case?
10:16:29 <Enzoray> lim basecase, we need to go negative
10:16:57 <Enzoray> We need to reduce the list, until 0.
10:17:01 <Enzoray> [] that being.
10:17:18 <Enzoray> No, I lied again.
10:18:11 <Enzoray> I don't know. Mind lending me a helping hand?
10:18:28 <ski> Enzoray : yes, you need to get closer to the base case in each recursive step
10:18:35 <ski> otherwise you'll never finish
10:18:50 <ski> consider
10:19:00 <Enzoray> | otherwise = myIndex xs (n - 1) didn't work.
10:19:06 <ski>   myIndex ["zero","one","two","three"] 2
10:19:23 <ski> Enzoray : are you sure ?
10:19:27 <Enzoray> Yeah.
10:19:45 <Enzoray> It compiles, doesn't work though.. :S
10:20:07 <ski> @let myIndex :: [a] -> Int -> a; myIndex [] n = error "404: list not found"; myIndex (x:xs) n | n == 0 = x | otherwise = myIndex xs (n - 1)
10:20:08 <lambdabot>  Defined.
10:20:10 <ski> > myIndex ["zero","one","two","three"] 2
10:20:11 <lambdabot>  "two"
10:20:14 <ski> works here
10:20:16 <Enzoray> I wrote "lolface" 'o'
10:20:18 <Enzoray> Didn't wrok
10:20:26 <Enzoray> with myIndex ofc, before.
10:20:29 <ski>   'o'  -- isn't a number, an index
10:20:50 <Enzoray> I tried with numbers too.
10:20:57 <Enzoray> wait a minute...
10:20:58 <Enzoray> ........
10:20:59 <Enzoray> ...........
10:21:01 <Enzoray> ..................
10:21:04 <ski> `myIndex' is supposed to be passed a list, and a number that specifies which element to extract
10:21:10 <Enzoray> '2'.... is a string
10:21:14 <Enzoray> .....................................
10:21:37 <ski> perhaps you're confusing this with another function that takes a list, and an element, and returns a number specifying (say the first) place the element occurs in the list ?
10:21:57 <Enzoray> That is exacly what I'm confusing it with.
10:21:58 * ski idly wonders what arithmetical sequence Enzoray's dots express
10:22:12 <Enzoray> writing '2', makes 2 a string
10:22:17 <ski> > map length ["........","...........","..................","....................................."]
10:22:19 <lambdabot>  [8,11,18,37]
10:22:21 <Enzoray> which is why it didn't work.
10:22:27 <ski> @oeis 8 11 18 37
10:22:27 <lambdabot>  Sequence not found.
10:22:28 <zwer> :t '2'
10:22:29 <lambdabot> Char
10:22:35 <Enzoray> char then.
10:22:39 <ski> yes
10:23:02 <Enzoray> string = list of chars. I know
10:23:30 <Enzoray> ok, it works now.
10:23:38 <Enzoray> myIndex xs (n - 1)
10:23:44 <ski> good
10:23:54 <Enzoray> xs (n-1) = x
10:23:58 <Enzoray> or?
10:24:02 <ski> so, often with recursion with integers, you count down by `1'
10:24:20 <ski> Enzoray : i'm not sure what you're asking
10:24:40 <ski> Enzoray : .. an alternative would have been to count up from `0' to `n', instead of counting down
10:24:46 <ski> both works
10:24:55 <ski> sometimes one is nicer than the other
10:25:03 <Enzoray> How do I view (x:xs)? Let me explain. If I were to put out a scale of temprature it would be like -1 | 0 | 1
10:25:11 <Enzoray> How do I.. scale out x and xs.
10:25:19 <Enzoray> Or... simply, you just don't?
10:25:22 <ski> `x:xs' means : the list that you get when you place the element `x' in front of the list `xs'
10:25:44 <Enzoray> Like, 1 | 2,3,4
10:25:46 <ski> i'm not quite sure what you're after with "scale" here
10:26:37 <EvanR> > -1 : 0 : 1 : []
10:26:37 <Enzoray> Let's just say that the list looks like this after (x:xs) [1] : [2,3,4,5]
10:26:38 <lambdabot>  [-1,0,1]
10:26:51 <EvanR> > [1] ++ [2,3,4,56]
10:26:52 <lambdabot>  [1,2,3,4,56]
10:27:02 <ski> > "don't" : ["be","afraid"]
10:27:03 <lambdabot>  ["don't","be","afraid"]
10:27:15 <Enzoray> if I wrote xs (n-1). n = 1;
10:27:17 <ski> so, you can use `:' to make a list that is one element longer
10:27:19 <Enzoray> Where would it land?
10:27:44 <ski> you can also use `:' in *patterns* to the left of `=' in a definition, to *destructure* a list into its head element, and its tail list (the remaining elements)
10:27:52 <charlie> > [-1, 0, 1] + [1, 0 -1]
10:27:53 <lambdabot>  No instance for (GHC.Show.Show t0)
10:27:53 <lambdabot>    arising from a use of ‘M25182109688726874742573.show_M25182109688726874742...
10:27:53 <lambdabot>  The type variable ‘t0’ is ambiguous
10:27:56 <charlie> heh
10:28:06 <Enzoray> I guess my question is more, how can I determine the result "myIndex xs (n-1)?
10:28:06 <ski> Enzoray : do you mean `myIndex xs (n-1)', where `n = 1' ?
10:28:09 <Enzoray> Yeah.
10:28:16 <EvanR> > [1, 2] + [2, 1] :: [Int]
10:28:17 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
10:28:17 <lambdabot>    arising from a use of ‘GHC.Num.+’
10:28:25 <charlie> i think i have hugs installed...
10:28:33 <shaykha> module Rot where
10:28:33 <shaykha> import System.Environment
10:28:33 <Enzoray> and does xs start from 0?
10:28:34 <shaykha> import Data.List
10:28:34 <shaykha> import Data.Maybe
10:28:35 <shaykha> import Data.Char
10:28:42 <shaykha> alphabet :: String
10:28:42 <shaykha> alphabet = "abcdefghijklmnopqrstuvwxyz"
10:28:45 <shaykha> main :: IO ()
10:28:50 <shaykha> main = do args <- getArgs
10:28:53 <shaykha>           rots   <- getRots $ args !! 1
10:28:56 <shaykha>           inFile <- readFile $ args !! 2
10:28:58 <ski> Enzoray : well, because `myIndex' is defined in terms of the possible shapes of `xs' (empty list or non-empty list), you first need to determine whether the given `xs' is empty or not
10:29:05 <shaykha>           putStrLn (rotate rots inFile)
10:29:08 <charlie> lol shaykha please
10:29:10 <shaykha> getRots :: String ->IO Int
10:29:13 <shaykha> getRots r = return $ read r `mod` 26
10:29:14 <charlie> why
10:29:15 <EvanR> ...
10:29:16 <shaykha> rotate :: Int -> String -> String
10:29:19 <shaykha> rotate r = map $ rotateLetter r
10:29:20 --- mode: ChanServ set +q *!*@unaffiliated/shaykha
10:30:17 * hackagebot numericpeano 0.1.0.0 - Peano numbers with attendant bells and whistles.  http://hackage.haskell.org/package/numericpeano-0.1.0.0 (jtapolczai)
10:31:09 --- mode: ChanServ set -q *!*@unaffiliated/shaykha
10:32:19 <Enzoray> I mean, words don't have any assigned value for me.
10:32:49 <EvanR> > let words = "value" in words
10:32:50 <lambdabot>  "value"
10:33:04 <ski> Enzoray : "and does xs start from 0?" -- if you mean "does index counting start from `0' ?", then yes, that's the *convention* for lists, in Haskell
10:33:20 <Enzoray> then it's two lists?.. :S
10:33:24 <Enzoray> But still one.
10:33:39 <Enzoray> It counts as one, but has two starting points.
10:33:45 <Enzoray> Being x = 0; xs = 0
10:33:49 <EvanR> :t indexOf
10:33:50 <lambdabot>     Not in scope: ‘indexOf’
10:33:50 <lambdabot>     Perhaps you meant one of these:
10:33:50 <lambdabot>       ‘Control.Lens.index’ (imported from Control.Lens),
10:33:57 <ski> `"value"' is one list (of characters), `words' is defined by EvanR there to be another name for this list
10:34:29 <ski> Enzoray : or are you talking about another example now ?
10:35:21 <Enzoray> No, I'm talking about (x:xs) having two start points, according to you.
10:35:32 <Enzoray> x = 0; xs = 0;
10:35:47 <EvanR> xs is one list, (x:xs) is another
10:36:02 <ski> wb shaykha
10:36:11 <shaykha> thanks, emacs accident
10:36:18 <zwer> > 1 : (2 : (3 : []))
10:36:20 <lambdabot>  [1,2,3]
10:36:49 <Enzoray> I've been told that (x:xs) is one list, splitted into elements, one containing the head, the rest tail.
10:37:25 <Enzoray> If I was to type the value, it would be [0] : [1,2,3,4]
10:37:27 <vanila> thats true
10:37:31 <ski> Enzoray : a non-empty list has a head element, and a tail list. since the tail list is a list, it also has a head and a tail, and so on, until we reach an empty list (which we can think of as the end of all the previous lists. the empty list has no head and no tail)
10:37:39 <EvanR> > [0] : [1,2,3,4]
10:37:39 <Enzoray> Not, [0] : [0,1,2,3]
10:37:40 <lambdabot>  No instance for (GHC.Show.Show t0)
10:37:40 <lambdabot>    arising from a use of ‘M56275479480878809832764.show_M56275479480878809832...
10:37:40 <lambdabot>  The type variable ‘t0’ is ambiguous
10:37:45 <EvanR> type error
10:37:55 <ski> Enzoray : `0 : [1,2,3,4]', not `[0] : [1,2,3,4]'
10:38:06 <zwer> constructor (in the case of a list that is ':') can be used in pattern matching to deconstruct data
10:38:14 <ski> Enzoray : `:' adds a *single* element in front of a list. if you want to add multiple elements (in a list), use `++'
10:38:30 <ski> > [] ++ [1,2,3,4]
10:38:32 <lambdabot>  [1,2,3,4]
10:38:32 <ski> > [0] ++ [1,2,3,4]
10:38:34 <lambdabot>  [0,1,2,3,4]
10:38:38 <ski> > [0,496] ++ [1,2,3,4]
10:38:39 <lambdabot>  [0,496,1,2,3,4]
10:39:51 <Enzoray> My list wasn't an actual list, it was an expression for value of the positions in a list.
10:41:24 <ski> Enzoray : ok. nonetheless, the position corresponding to `x' in `x : xs' is `0'. not `[0]'
10:41:37 <Enzoray> I see.
10:41:44 <EvanR> > [0..]
10:41:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:41:50 <Enzoray> But both x:xs includes 0?
10:42:00 <EvanR> the lists dont include any indexes
10:42:05 <EvanR> they are just lists
10:42:15 <ski> Enzoray : the element at position `0' in `x:xs' is `x'
10:42:30 <Enzoray> I know.
10:42:32 <ski> Enzoray : the element at position `0' in the tail of `x:xs', iow `xs' is the head of `xs'
10:42:32 <vanila> let (x:xs) = [5,2,1,3] in x
10:42:33 <vanila> let (x:xs) = [5,2,1,3] in xs
10:42:35 <Enzoray> But what is 0 in xs?
10:42:39 <vanila> here are two examples to try
10:42:41 <Enzoray> don't say x + 1
10:42:48 <ski> Enzoray : for which `xs' list ?
10:43:00 <Enzoray> if you were to define the first position in xs.
10:43:00 <EvanR> > [3, 4, 5] !! 0
10:43:01 <lambdabot>  3
10:43:04 <Enzoray> How would you do it?
10:43:08 <EvanR> > (tail [3, 4, 5]) !! 0
10:43:09 <lambdabot>  4
10:43:32 <ski> Enzoray : the head of `xs', as an element of `xs', is at position `0'
10:43:38 <ski> Enzoray : the head of `xs', as an element of `x:xs', is at position `1'
10:43:42 <ski> Enzoray : the head of `xs', as an element of `x:y:xs', is at position `2'
10:43:51 <ski> Enzoray : it all depends from which list you start counting
10:44:05 <Enzoray> Ofc, but you didn't answer me.. :P
10:44:33 <Enzoray> Or wait a minute, you did but. still not
10:44:39 <Enzoray> Would you mind typing that in code?
10:44:41 <ski> Enzoray : i'm not quite sure what you mean by "define the first position in xs" -- define how ?
10:44:57 <Enzoray> I see, I've been asking you the wrong questions.
10:45:21 <Enzoray> Write the piece of code which give me the first position in xs, in (x:xs)
10:46:00 <ski> what is "the first position in xs" ?
10:46:05 <ski> an integer ?
10:46:07 <ski> a list element ?
10:46:17 <Enzoray> Let's say an element, to make it harder.
10:46:20 <ski> a selection function ?
10:46:24 <Enzoray> stirng
10:46:26 <Enzoray> string
10:46:27 <Enzoray> *
10:46:29 <EvanR> > let xs = [] in head xs
10:46:30 <lambdabot>  *Exception: Prelude.head: empty list
10:46:33 <ski> well, you can define
10:46:49 <ski>   head [    ] = error "sorry, empty lists have no head"
10:46:55 <ski>   head (x:xs) = x
10:47:09 <ski> then `head xs' will compute the head of `xs' (if any)
10:47:26 * ski isn't sure Enzoray is satisfied with this
10:47:38 <Enzoray> You didn't use function :: ....
10:47:45 <ski>   head :: [a] -> a
10:47:48 <ski> there
10:48:01 <Enzoray> I'll just try it out then.
10:48:12 <sirodoht> hello there
10:48:19 <vanila> hi
10:48:26 <ski> (nitpick, `::' isn't a function (nor an operator). it's syntax used to declare the type of things. here called a "type signature")
10:49:09 <charlie> http://paste.debian.net/138395/ it’s been a while since i’ve done any haskell; kind of trivial program but i’m glad to see i’m still able to figure things out :P
10:49:13 <sirodoht> i've got a question from the learnyouahaskell tut (which maybe the same you guys are talking now, judging from the names you use)
10:49:36 <Enzoray> Didn't work.
10:50:34 <vanila> whats yup
10:50:37 <sirodoht> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
10:50:44 <Enzoray> It returns x, ski
10:51:03 <ski> Enzoray : "It" being ?
10:51:05 <vanila> @let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
10:51:06 <lambdabot>  Defined.
10:51:07 <BrianHV> charlie: that's cool! but just so you know, it looks like addWith = zipWith (+)
10:51:09 <Enzoray> My question was to return the element AFTER x, which is the first element in xs
10:51:10 <vanila> > boomBangs [1,2,3,4,5]
10:51:12 <lambdabot>  ["BOOM!","BOOM!","BOOM!"]
10:51:14 <lericson> ski: i think the point was "you didn't use ``function :: …''"
10:51:21 <Enzoray> Your function
10:51:25 <lericson> ski: i.e. referring to the grammatical production
10:51:35 <marchelzo_> Is there a function like "any", but for 2-tuples. Like "any' (>5) (0,12) == True"? Maybe in lens or something?
10:51:38 <EvanR> Enzoray: head xs
10:51:52 <kadoban> :t odd
10:51:53 <lambdabot> Integral a => a -> Bool
10:51:56 <EvanR> which may crash
10:51:56 <ski> lericson : i don't see what this has to do with grammar productions
10:52:08 <sirodoht> this is a list comprehesion, but it says that x<-xs while this is where it's defined, so how can it get a value?
10:52:24 <Enzoray> For the first, it gives me "ambigious occurence"
10:52:34 <Enzoray> Replace "head" with.. something else?
10:52:42 <EvanR> no, its head xs
10:52:48 <alpounet> marchelzo_: yeah, lens lets you do that easily i think
10:53:01 <alpounet> :t anyOf both (>5)
10:53:01 <lambdabot> (Data.Bitraversable.Bitraversable r, Ord a, Num a) => r a a -> Bool
10:53:06 <Enzoray> I don't think you understod my question. So I'll explain what I wanted.
10:53:08 <lericson> ski: i think you do, and i think you understood what i said ;)
10:53:09 <ski> Enzoray : try renaming it to `myHead'
10:53:19 <alpounet> > anyOf both (>5) (0, 12)
10:53:20 <lambdabot>  True
10:53:27 * ski is confused by lericson
10:53:43 <marchelzo_> alpounet, awesome. I have a lot to learn when it comes to lens :)
10:53:45 <marchelzo_> thanks
10:54:25 <Enzoray> myHead "lol" > 'l'
10:54:28 <Enzoray> Ok?
10:54:31 <Enzoray> Which is wrong.
10:54:32 <lericson> ski: i guess never mind, i was trying to help you understand what Enzoray meant
10:54:32 <ski> ok
10:54:36 <ski> Enzoray : why ?
10:54:41 <Enzoray> Because l == x
10:54:49 <Enzoray> I wanted xs, which is the element after x
10:55:09 <EvanR> Enzoray: then use head (tail "lol")
10:55:18 <EvanR> or let (x:xs) = "lol" in head xs
10:55:18 * hackagebot functor-monadic 0.1.0.0 - Monad-style combinators for functors.  http://hackage.haskell.org/package/functor-monadic-0.1.0.0 (jtapolczai)
10:55:35 <ski> EvanR : or `let x:xs = "lol" in head xs'
10:55:48 <EvanR> oh really
10:56:03 <ski> yes
10:56:20 <Enzoray> ski, mind give it another go?
10:58:08 <thebnq> might as well let _:x:_ = "lol" in x
10:58:28 <thebnq> sad face :x:
10:58:45 <EvanR> > "lol" !! 1
10:58:46 <lambdabot>  'o'
10:58:58 <HeladoDeBrownie> i was sort of curious what that package description could mean, but it has no docs and its repo url gives a 404
10:59:19 <k00mi> HeladoDeBrownie: http://hackage.haskell.org/package/functor-monadic-0.1.0.0/src/Data/Functor/Monadic.hs
10:59:23 --- mode: ChanServ set +o geekosaur
10:59:48 <HeladoDeBrownie> ah, thanks
11:00:08 <HeladoDeBrownie> didn't realize there was a browse link, i never used it before
11:00:22 --- mode: geekosaur set -b ssj4mo!*@*$##fix_your_connection
11:00:27 --- mode: geekosaur set -b maxcan!*@*$##fixyourconnection
11:00:49 --- mode: geekosaur set -b G*!~textual@c-98-210-157-141.hsd1.ca.comcast.net$##fix_your_connection
11:00:51 <Enzoray> EvanR, could you explain this for me?
11:00:58 <ski> Enzoray : hm, i'm currently a bit confused about what your current question is
11:01:07 <Enzoray> How to return the first element in xs
11:01:07 --- mode: geekosaur set -b *!~aerlinger@*$##fixyourconnection
11:01:26 <EvanR> Enzoray: use (!! 1)
11:01:34 <EvanR> > "abcd" !! 1
11:01:35 <lambdabot>  'b'
11:01:43 <ski> Enzoray : by "first", do you mean "at index `1'" ?
11:02:00 <Enzoray> Yes, for index (x:xs) it's at position 1.
11:02:00 <EvanR> (hes been asking what is the first element in the tail of a list)
11:02:16 <Enzoray> I need this inside a function.
11:02:24 --- mode: geekosaur set -b mrsolo!*@*$##fix_your_connection
11:02:31 <EvanR> you got it
11:03:14 --- mode: geekosaur set -b stuntaneous*!*@*$##fix_your_connection
11:04:33 --- mode: geekosaur set -b neutrino!*@*$#haskell-ops
11:04:58 <godel> Enzoray: you can do a safe version, too
11:05:16 <Enzoray> What?..
11:05:43 <EvanR> > [] !! 1
11:05:44 <lambdabot>  *Exception: Prelude.(!!): index too large
11:05:58 <brainacid> hello all
11:06:04 --- mode: geekosaur set -o geekosaur
11:06:13 <brainacid> watching the Meijer lectures on Haskell
11:06:14 <brainacid> ;)
11:06:44 <godel> brainacid: do you like them?
11:08:05 <vin-ivar> hey, is this an okay place to ask absolutely shitty questions?
11:08:23 <ryantrinkle> vin-ivar: yep :)
11:08:25 <godel> vin-ivar: ask the question
11:08:26 <Enzoray> vin-ivar: You just haven't seen my questions then, lel :D
11:08:36 <thebnq> if it pertains to haskell :)
11:08:46 <vin-ivar> haha
11:08:48 <vin-ivar> okay, so
11:09:08 <brainacid> godel, im a hobby programmer with very little experience... so yes i do
11:09:13 <vin-ivar> this is something I have no idea how I do functionally
11:10:14 <Enzoray> EvanR, your solution doesn't use xs at all?
11:10:28 <vin-ivar> wait
11:10:29 <EvanR> Enzoray: if you wanted to use xs, you can do head xs
11:10:33 <vin-ivar> holy shit, I think I solved it
11:10:35 <vin-ivar> hang on
11:10:35 <EvanR> or xs !! 0
11:10:46 <godel> head.tail
11:11:07 <Enzoray> EvanR, you just gave the solution... Seriously, how was it so hard to comprehend the question? I thought it was crystal clear.
11:11:10 <gazay> brainacid: I really like his style, he looks like he really enjoy what he doing:)
11:11:50 <Enzoray> I mean, you made it look like I was asking you to reply for the most complex question in the world.. ^^
11:11:51 <EvanR> Enzoray: have been giving this solution for a while now
11:11:52 <godel> Enzoray: I think nobody understood the question, seriously
11:12:10 <Enzoray> EvanR, you have. Yes.
11:12:19 <brainacid> gazay, Im so lucky to be watching them... He is awesome guys
11:12:41 <godel> brainacid: are them introductory or somewhat advanced?
11:12:42 <EvanR> Enzoray: was this some sort of test?
11:13:28 <Enzoray> EvanR, no. Not really. I'm just new and I have some questions. The terms you used explaining this was not making this easier.
11:13:41 <EvanR> which terms
11:13:53 <Bush> Hello, I never used IRC and I learn Haskell. Can I ask questions here? I appologize for my bad English.
11:14:09 <Enzoray> Types, functions etc.
11:14:20 <EvanR> i didnt say any of those
11:14:23 <kadoban> Bush: Yes.
11:14:27 <brainacid> godel, they are both, he spends time talking about the references to F# and C#
11:14:27 <Enzoray> ski did. :P
11:14:44 <brainacid> Hi Bush
11:15:19 * hackagebot functor-monadic 0.1.0.1 - Monad-style combinators for functors.  http://hackage.haskell.org/package/functor-monadic-0.1.0.1 (jtapolczai)
11:15:21 * hackagebot relational-query 0.3.0.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.3.0.0 (KeiHibino)
11:15:39 <vin-ivar> well, this is awkward
11:15:48 <Enzoray> But, you used head xs, right? How do you retrieve it looking from x's perspective you said?
11:15:50 <vin-ivar> I figured out how to do what I wanted
11:15:54 * vin-ivar grins sheepishly
11:16:19 <vin-ivar> for reference, I wanted to get the first element in a range that fulfills a condition
11:16:27 <ski> Enzoray : which of them do you want explained ?
11:16:30 <vin-ivar> I put the condition in the comprehension, and got the head of the list, so it ran lazily
11:16:39 <Bush> Hello, all. I posted my question with the screens here yesterday: http://stackoverflow.com/questions/27667023/ghci-incorrect-text-output-despite-the-right-font-and-codepage
11:16:41 <vin-ivar> lazy evaluation is awesome :D
11:16:51 * ski pours vin-ivar a cup
11:16:54 <Aruro> hi all, im trying to install lambdabot and keep getting no <pcre.h> error, i tried to install regexp-pcre-builtin but no change :(
11:17:04 <Aruro> im on mac
11:17:17 <monochrom> beware of the case when none of the elements fulfills the condition.
11:17:34 <Enzoray> ski, I believe EvanR just gave me the answer I needed.
11:17:56 <geekosaur> Aruro, pcre is a C library. you probably want to get it from something like macports or homebrew
11:18:23 <Aruro> so without it no lambda bot?
11:18:28 <ski> Enzoray : if you say so
11:18:33 <vin-ivar> ah good point monochrom, i'll keep that in mind
11:18:42 <Aruro> there is library called reg-exp-pcre-included
11:18:50 <Aruro> looks like it should have pcre.h
11:18:55 <godel> Bush: have you tried any russian programming forums?
11:18:59 <Enzoray> ski, where do I find the rest of the exercises?
11:19:10 <ski> Enzoray : which exercises ?
11:19:15 <ski> Enzoray : the ones i suggested ?
11:19:17 <Enzoray> ues
11:19:28 <ski> you could check the backlog of this channel
11:19:33 <ski> .. or i could repeat them
11:19:43 <monochrom> +1 backlog
11:20:02 <geekosaur> you will probably need to figure out how to point to it, though. usually the C-libs-included ones are for Windows and using them on other platforms requires a bit more work
11:20:19 <Bush> godel: I can't find goodRussian forum about Haskell.
11:20:23 <Enzoray> No.
11:20:29 <Enzoray> You never stated them I believe.
11:20:45 <Enzoray> You said there was a bunch of exercises, only mentioning two of them.
11:21:13 <agibiansky> Bush: If you're looking for some russian Haskell resources, have you seen this? http://ohaskell.ru/get/ohaskell.pdf (just remembered it now, don't have any other useful links)
11:21:26 <brainacid> Bush, now you can learn English and Haskell...I would love to learn Russian ;)
11:22:03 <Enzoray> brainacid, try playing cs:go for a week and concider it done. :P
11:22:08 <ski> <ski> Enzoray : here's a couple more suggestions : `reverse xs' should compute the reversal of the list `xs'. `evens xs' should skip every odd-indexed element, so that `evens "goodbye"' evaluates to `"gobe"'
11:22:08 <Bush> brainacid: ok :) what about my question? :)
11:22:16 <ski> <ski> Enzoray : `remberuptolast a xs' should return a list of all the elements of `xs', from the start, up to (and including) the *last* occurance of `a' in `xs' -- if there's no `a' in `xs', it should return the whole of `xs'
11:22:20 <ski>     <ski> (perhaps rename that to `remberUpToLast', to make it more readable)
11:22:22 <ski> Enzoray : a "couple" can be two
11:23:09 <ski> (and that's three above)
11:23:13 <brainacid> Bush I wish I could help bud... Im very much clueless at this point in my Haskell programming...
11:23:53 <Enzoray> So, you want me to define already defined standard-haskell functions?
11:24:19 <ski> Enzoray : `evens' isn't a standard function, nor is `remberUpToLast'
11:24:34 <Enzoray> Yeah, except them.
11:24:55 <ski> reimplementing some standard functions can be good practice
11:25:09 <Enzoray> I need to be able how to use them.
11:25:16 <Enzoray> Not, reimplementing htem again. :P
11:25:45 <Bush> agibiansky: yes I see it and start read it in the past, but then I have bought the book M.Lipovacha and read it now.
11:26:07 <ski> Enzoray : here's another : given two lists, a "pattern" and a "text", find a way to "match" the pattern with the text, with a minimal "edit"
11:26:37 <ski> Enzoray : first, when matching, you may freely skip any prefix and suffix of the text, focusing on a contiguous slice of it
11:26:51 <agibiansky> Bush: Is there a russian translation of Learn You a Haskell?
11:27:29 <Enzoray> Could you give me an example of a "pattern" and a "text"?
11:27:31 <ski> Enzoray : second, you need to match each element of the pattern with the corresponding element of the slice (they need to be equal). in case you need to swap the order of two adjacent elements of the pattern to make it match, you pay a "cost" of `1'
11:27:37 <Bush> agibiansky: Yes I read it now.
11:28:01 <ski> Enzoray : in case you need to insert an extra element in the pattern to make it match, you pay `1'. in case you need to remove an element of the pattern to make it match, you pay `1'
11:28:21 <agibiansky> Bush: spasibo, i didn't know, i will look around and maybe get it too
11:29:04 <ski> Enzoray : `match "casket" "The eggs are in the basket."' would match, with a cost of `2' (removing `c', inserting instead a `b')
11:29:39 <ski> in this case ignoring the prefix `"The eggs are in the "', and the suffix `"."'
11:30:02 <HeladoDeBrownie> Bush, while I don't know anything about most of the Haskell channels beyond what's on this page, this may be useful: https://www.haskell.org/haskellwiki/IRC_channel Search for the word "Russian" on that page.
11:30:10 <dfeuer> There doesn't seem to be anyone active in #haskell-infrastructure. Anyone here know if there's an estimate available for when the wiki will really be usable again?
11:30:37 <ski> Enzoray : so, you should compute the starting and ending index of the slice in the text that matches the pattern (with a minimal cost). and if you want, you can return the cost as well
11:30:43 <Enzoray> So, it's supposed to modify either the beginning or the end of the text?
11:30:55 <ski> Enzoray : if you prefer, in case there are several minimal solutions, you can return all of them in a list
11:30:57 <Enzoray> Each modifying step results in one cost.
11:31:16 <Bush> It is now difficult for me to be guided in IRC. I never used it and got used to use Skype. I hope that I manage to read all messages. :)
11:31:26 <gazay> I'm beginner and I was terrified by process fkk
11:31:26 <gazay> Dkk
11:31:27 <ski> Enzoray : modify the pattern, either at the beginning, or at the end, or in the middle somewhere, to make it match some slice of the text
11:31:27 <gazay> k
11:31:37 <gazay> Sorry. A cat
11:31:44 <HeladoDeBrownie> Bush, the page i linked you mentions some russian speakers organize over jabber too
11:31:54 <ski> Enzoray : .. something like this matching process can be used for DNA processing
11:32:35 <MrOrdinaire> hi, I run into this error when installing ghc-mod-5.2.1.1 on MacOSX Yosemite
11:32:37 <Bush> HeladoDeBrownie: Thank you. I will try.
11:32:46 <Enzoray> You have to be joking with me, this is way to advanced?.. :S
11:32:55 <MrOrdinaire> https://gist.github.com/anonymous/5784dde34bc0795c545f
11:33:26 <MrOrdinaire> can anyone help me with this?
11:33:46 <ski> Enzoray : it's just an example of a more advanced problem, in case you wanted a taste of one
11:34:03 <ski> Enzoray : this one could possibly be a whole laboration in a functional programming course
11:34:13 <MrOrdinaire> it's a fresh `cabal install ghc-mod-5.2.1.1` after running `cabal install happy alex`
11:34:26 <ski> Enzoray : but it's slightly more "real world"
11:34:39 <Enzoray> In java, that might not have been such advance problem, but in haskell.. don't even get me started.
11:35:04 <ski> Enzoray : a simpler one would be to write a function that given a list, returns a list of all permutations of it
11:35:29 <ski> Enzoray : or, given a list, returns a list of all the lists you can get by removing zero or more elements from it
11:35:37 <Enzoray> ski, that kind of problem is for like working on a MSWord or something.
11:35:46 <ski> perhaps
11:36:01 <EvanR> all permutations can be useful
11:36:30 <EvanR> though it will be hard to produce them for lists more than a few elements big
11:36:45 <Enzoray> If you would just add one more bit, including where it validates where the least step is taken for a word. It would be like, exacly as a MSWord function.
11:36:56 <Enzoray> steps are taken.*
11:37:06 <ski> Enzoray : or, given two numbers, say `k' and `n', where `0 =< k =< n', generate a list of all possible (sorted) lists, each containing `k' numbers between `0' (inclusive) and `n' (exclusive)
11:37:23 <gazay> So. I was terrified by process of building and uploading libraries to hackage from official tutorial on Haskell.org. and now I making small ala CLI utility on Haskell which will do 2 commands - build (find cabal file, configure, init sandbox, install into sandbox, build dist) and push (cabal upload dist, curl upload docs of last version if there any). How do you think - it would be helpful for anybody? Anyhow i've learned about system calls...
11:38:22 <ski> Enzoray : sorry, each list should have no duplicates
11:38:36 <ski> Enzoray : so, e.g. `combs 2 4' should return `[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]' (or perhaps in some other order, it doesn't matter much)
11:38:44 <EvanR> are ScopedTypeVariables useful, recommended?
11:38:52 <EvanR> or discouraged
11:38:53 <ski> EvanR : yes
11:38:57 <ski> useful
11:39:13 <gazay> I was terrified because I'm rubyist, there is rubygems with push and build
11:39:22 <EvanR> this lets you for instance use a type variable from the function signature in some subexpression type annotation?
11:39:47 <ski> Enzoray : you can think of this as generating all the possible ways to select two persons (or whatever) out of four
11:39:52 <bergmark> EvanR: useful
11:40:20 * hackagebot scotty-session 0.0.4 - Adding session functionality to scotty  http://hackage.haskell.org/package/scotty-session-0.0.4 (AlexanderThiemann)
11:40:25 <Enzoray> ski, the pattern you just used is called what. I recognized it.
11:40:36 <ski> EvanR : yes
11:40:39 <EvanR> sweet
11:40:43 <Aruro> why pcre.h does not come together with reg-exp-pcre??
11:40:51 <Enzoray> There is a mathematical apporach of the whole pattern you just used.
11:41:24 <ski> Enzoray : yes. usually one just counts the *number* of combinations. here i asked about generating the combinations themselves (in some representation. here using indices)
11:42:05 <Enzoray> n^2 gives the right amount of combination, or something.. :S
11:42:18 <Enzoray> 2^n, maybe.. hm
11:42:23 * ski wrote a (non-recursive) solution for `combs' in C, using `goto's in and out of a `for' loop. it was fun :)
11:42:34 <rhaps0dy> combs?
11:42:41 <ski> see above
11:42:45 <MrOrdinaire> nvm, fixed with `cabal install ghc-mod-5.2.1.1 monad-control-0.3.3.0`, according to https://github.com/kazu-yamamoto/ghc-mod/issues/421
11:42:54 <brainacid> Enzoray, never heard of cs:go ... gonna look it up. Just once again telling my dad that I dont need to go to school to learn to program. He thinks Im wasting my time. :(
11:42:54 <ski> rhaps0dy : generate combinations
11:43:05 <rhaps0dy> no scrollback :(
11:43:07 <rhaps0dy> oh
11:43:09 <rhaps0dy> ty
11:43:18 <rhaps0dy> curiosity satisfied, ty
11:44:32 <ski> Enzoray : well, `n! / (k! * (n-k)!)'
11:44:45 <Enzoray> ski, how many years do you have in programming? You seem to know everything about programming...
11:44:55 <ski> hum ..
11:45:04 * ski started programming around age 6.5
11:45:38 <ski> (and i certainly don't know everything about it ..)
11:45:43 <Enzoray> I need point B to calculate the rest.. :P
11:47:48 <SharpGAF> Some of the best programmers I know started when they were 18 or older
11:47:57 * ski got a programmable pocket calculator (with 544 bytes of RAM available for programs) at age 6.5
11:48:00 <SharpGAF> Though experience helps.
11:48:03 <ski> yes
11:48:23 <ski> afaik, it's never too late to start
11:48:52 <exio4> "afaik"?
11:48:58 <SharpGAF> "As far as I know."
11:48:58 <exio4> :P
11:49:13 <exio4> I know SharpGAF, it is just that it sounds "funny" in that phrase
11:49:18 <SharpGAF> Haha, fair.
11:49:37 <EvanR> starting when youre 18 (now a days) might mean skipping C
11:49:40 <SharpGAF> FWIW I find hanging out in good IRC channels (like #haskell is reputed to be) can accelerate the learning process, which is one reason I'm here now :)
11:49:44 <EvanR> though you might be starting with java instead..
11:50:02 <EvanR> as long as you skip c++ you might get a head start
11:50:21 <rhaps0dy> yeah, do that
11:50:24 <rhaps0dy> skip C++
11:50:24 <SharpGAF> If you're going to do C it's best to do it when you're very young IMO, since you have time and leeway to make mistakes on non mission critical software
11:50:30 <SharpGAF> But IMO there is little point to doing C or C++ these days
11:50:40 <rhaps0dy> unless you want to into infosec
11:50:54 <SharpGAF> Even infosec has to spend a lot of its time in assembly to avoid optimizing compilers
11:51:01 <Aruro> c is ugly, could not figure out space identation :D
11:51:06 <Aruro> lame
11:51:11 <rhaps0dy> SharpGAF, to avoid optimizing compilers?
11:51:21 <SharpGAF> rhaps0dy: Constant time isn't constant time when LLVM gets its hands on something.
11:51:45 <rhaps0dy> for what I've experienced, knowing C helps with assembly, and viceversa
11:52:00 <rhaps0dy> SharpGAF: really?
11:52:03 <vin-ivar> eh, what's a better alternative to c/c++ for learning how memory works?
11:52:03 <SharpGAF> Yes
11:52:07 <monochrom> learn everything
11:52:20 <vin-ivar> outside of assembly
11:52:20 <SharpGAF> There was just a presentation on it actually, in the context of Rust (which also uses LLVM as its backend)
11:52:28 <SharpGAF> How the naive "constant time" code was definitely not.
11:52:52 <rhaps0dy> SharpGAF: LLVM made it to be linear or what?
11:52:55 <rhaps0dy> that sucks :|
11:53:04 <SharpGAF> It introduced branching and stuff to make it faster
11:53:06 <rhaps0dy> vin-ivar: I do not know
11:53:11 <rhaps0dy> SharpGAF: but it actually wasn't
11:53:12 <rhaps0dy> ?
11:53:14 <brainacid> im on pattern matching and lambda expressions
11:53:15 <SharpGAF> C/C++ aren't that accurate a model of the real machine anymore, either.  They don't really capture NUMA at all and have an artificial distinction between a heap and a stack (which Haskell exposes as particularly silly)
11:53:15 <Aruro> dont learn how memory works
11:53:21 <Aruro> learn theory
11:53:23 <brainacid> the real basics
11:53:34 <SharpGAF> rhaps0dy: Right
11:53:34 <Aruro> far all we know this model of memory maybe rust in 20 years
11:53:59 <rhaps0dy> yeah. ^
11:54:03 <vin-ivar> it sucks being surrounded by purists, I have no idea why learning C is *not* a good idea
11:54:06 <kadoban> vin-ivar: C is probably okay for that. C++ I'd avoid if that's your goal. /Just/ learing C isn't going to teach you all that much about system architecture though, at best it'd be kind of a little practical side-trip.
11:54:07 <rhaps0dy> although grammar is not very clear
11:54:40 <Aruro> why you dont learn assembly then?
11:54:42 <rhaps0dy> kadoban, it does help to see it in action
11:54:44 <Aruro> it can be more useful
11:54:51 <Aruro> you will hack some real stuff
11:54:51 <kadoban> vin-ivar: There's very little that I'd say is actually bad to learn. Using C for general purpose programs, today, is a mistake IMO. Learning the language is a different story.
11:55:07 <vin-ivar> that, I agree with
11:55:12 <SharpGAF> I learned a lot about the real machine memory model when I learned assembly, but I did about 10 or 11 years of C/C++ before that and didn't really understand it
11:55:23 <SharpGAF> That's why I find the claims that learning C helps you understand the computer to be pretty overwrought
11:55:33 <SharpGAF> In the hands of the right teacher it probably can.
11:55:35 <vin-ivar> that's true as well, SharpGAF, learning assembly taught me everything loads faster
11:55:46 <rhaps0dy> SharpGAF: hm
11:55:53 <rhaps0dy> maybe I only understood it after learning asm
11:56:06 <rhaps0dy> and then saw it reflected in the way one writes C
11:56:11 <rhaps0dy> so it's actually not useful
11:56:11 <SharpGAF> I think a lot of people did their systems courses in C so they associate C with these concepts, but really C is just the delivery mechanism
11:56:24 <kadoban> Yeah, that sounds right.
11:56:40 <brainacid> can you do itFunctnX = map (\x -> x*9 + 1) [0..n-1]
11:56:58 <kadoban> Mine used MIPS assembly and C I guess, then I used C for some practical OS stuff which was pretty fun, so it's all mixed up together.
11:57:17 <vin-ivar> what is n, brainacid?
11:57:20 <brainacid> **itFunctnX n = map (\x -> x*9 + 1) [0..n-1]
11:57:24 <vin-ivar> oh
11:57:27 <SharpGAF> The most practical reason to learn C is if you're doing embedded systems, since a lot of architectures literally have C compilers and nothing else.
11:57:27 <brainacid> vin-ivar, sorry
11:57:28 <vin-ivar> yeah, I think so
11:57:34 <SharpGAF> But that's not a good pedagogical reason.
11:58:05 <Aruro> you can do it brainacid
11:58:16 <vin-ivar> you can, yep
11:58:18 <SharpGAF> And a lot of them don't really implement the full C standard properly anyway, so people have to hack around things like inaccurate dependencies between registers on the relevant systems
11:58:22 <Aruro> list generator can be parametrised with argument
11:58:26 <EvanR> @hoogle Map k a -> [a]
11:58:27 <brainacid> and also itFunctnX' n = map (\x (1+) (*2) x) [0..n-1]
11:58:28 <lambdabot> Data.Map.Lazy elems :: Map k a -> [a]
11:58:28 <lambdabot> Data.Map.Strict elems :: Map k a -> [a]
11:58:28 <lambdabot> Data.Map.Lazy keys :: Map k a -> [k]
11:58:30 <brainacid> ???
11:58:32 <EvanR> noice
11:58:47 <brainacid> im confused
11:58:49 <Aruro> you forgot arrow
11:59:00 <Aruro> for lambda function
11:59:00 <monochrom> it is interesting to learn C and see for yourself, rather than believe anyone who says "C is high-level assembly"
11:59:21 <brainacid> are they saying that a lambda expression is the section operator
11:59:26 <Aruro> you dont need to learn C, learn to USE it
11:59:36 <monochrom> C does not let you access the carry flag. C does not let you access the stack. that is how "assembly" it is.
11:59:37 <Aruro> you need to learn real inforamation, hence THEORY
11:59:45 <SharpGAF> It's very hard to use C properly if you don't understand all its undefined behavior
11:59:46 <brainacid> so I cant replace the lambda exp with parenthesis functions?
11:59:52 <SharpGAF> Which empirically a lot of C programmers don't :|
11:59:52 <brainacid> maybe im not understanding
12:00:15 <Aruro> lambda is always  \x -> something
12:00:26 <Aruro> what did you want to do with it?
12:00:32 <Aruro> get rid of what?
12:00:42 <MrOrdinaire> toDigits :: Integer -> [Integer]
12:00:42 <MrOrdinaire> toDigits = go []
12:00:42 <MrOrdinaire>   where go acc i | i <= 0 = acc
12:00:43 <MrOrdinaire>                  | otherwise = let (d, m) = i `divMod` 10
12:00:45 <MrOrdinaire>                                in go (m : acc) d
12:00:47 <MrOrdinaire> ski: can you please help me shorten this function?
12:00:54 <Aruro> actually it is \ x -> something
12:01:11 <SharpGAF> http://blog.regehr.org/archives/213 has a great writeup on that (he has also proposed a variant of C without undefined behavior, or as he puts it "the C that people think exists anyway")
12:01:23 <SharpGAF> At least without the most common pitfalls.
12:02:07 <SharpGAF> Well… without the most common pitfalls that people don't really think about.  Everyone thinks about dangling pointers, not so much stuff like overlong bitshifts.
12:04:06 <kadoban> MrOrdinaire: toDigits x | x >= 0 = map (read . (:[])) . show $ x
12:05:50 <MrOrdinaire> kadoban: is conversion to string and back slow?
12:06:03 <kadoban> MrOrdinaire: Yes.
12:06:27 * ski pasted “ordered selection (combinations), Prolog solution, from 2012-12-16” at <http://lpaste.net/117380>
12:06:30 * ski annotated “ordered selection (combinations), Prolog solution, from 2012-12-16” with “ordered selection (combinations), C solution, from 2013-03-22” at <http://lpaste.net/117380#a117381>
12:06:38 <ski> rhaps0dy ^
12:07:29 <MrOrdinaire> is there any other way to do that without the performance penalty?
12:11:24 <rhaps0dy> thanks, ski
12:13:04 <ski> rhaps0dy : the C solution is meant to mimic the backtracking in the Prolog one (albeit with one or two more minor optimizations, because, well, this is C)
12:13:26 <rhaps0dy> I can't read prolog tho
12:13:35 <rhaps0dy> but I'll try a little :)
12:13:50 <kadoban> MrOrdinaire: Sure, probably several. You could use unfoldr, or explicit recursion at least. You could also probably do my way but speed it up just a bit by not using read at least, I'm not sure how slow the "show" actually is. I'd probably just use my version unless it proved too slow for whatever I'm doing.
12:14:39 <MrOrdinaire> kadoban: as the input is not a list, how does `unfoldr` apply?
12:15:01 <kadoban> :t unfoldr
12:15:02 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:15:06 <ski> rhaps0dy : everything after `ordered_select' in the Prolog one can be considered utility predicates (including the large commented out chunk at the end, that's just included for comparision)
12:15:25 <kadoban> MrOrdinaire: unfoldr doesn't require a list as input. It builds one from what you tell it.
12:15:57 <MrOrdinaire> kadoban: apologies. I mistook foldr for unfoldr.
12:16:04 <kadoban> Yeah, no worries.
12:16:11 <ReinH> MrOrdinaire: Here's how the digits package does it: http://hackage.haskell.org/package/digits-0.2/docs/src/Data-Digits.html#digits
12:16:29 <brainacid> myOdds n = map (\x y z -> x*10 -> y*x*2 -> z*y*3) [45..n-5]
12:16:41 <brainacid> incorrect?
12:17:17 <brainacid> (\x -> x * 10, \y -> y*x*2) [45..n-5]
12:17:22 <brainacid> Hello pavonia
12:17:40 * ski idly wonders what brainacid is trying to do
12:17:58 <pavonia> Hi!
12:18:16 <kadoban> ReinH: That's surprisingly direct and simple. I'd assumed there was some psycho way to speed that up that I wasn't considering.
12:18:22 <MrOrdinaire> ReinH: thanks
12:18:44 <brainacid> ski, Hello...Im tryin to learn just poking around, would that produce a list [450, 900, 2700, 500, 1000..
12:18:48 <quchen> ReinH: Heh, I would have thought there was a smarter solution than reversing the digits. I've been wondering about that ever since I wrote my Project Euler utilities module.
12:19:12 <brainacid> given n was 300
12:19:21 <ReinH> quchen: heh :) reversing the digits is generally cheap
12:19:37 <brainacid> the compiler already said it was wrong ski
12:19:37 <ReinH> kadoban: It doesn't need to be sped up.
12:19:38 <brainacid> lol
12:19:42 <quchen> ReinH: But `reverse` sooo often means you've used the wrong kind of fold as a beginner :-D
12:19:52 <ski> brainacid : i don't follow what you want it to compute
12:20:18 <ReinH> quchen: true enough
12:20:37 <kadoban> ReinH: Sure. Most things I end up looking at the source for do something way more clever than I would have been though. It's surprising when they're not :)
12:20:42 <EvanR> so uh
12:21:12 <benzrf> why isnt ghci as good as idris
12:21:17 <EvanR> so i have <<loop>> and im surprised that after stepping through with ghci that i eventually get a freeze
12:21:25 <benzrf> cmon guys
12:21:30 <quchen> benzrf: Patches welcome
12:21:44 <agibiansky> benzrf: What is better about Idris? (I have never used it, so legitimately curious as to what you're missing :) )
12:21:51 <benzrf> agibiansky: ever used irb and pry?
12:21:56 <larocca> _
12:21:57 <benzrf> or python and b/ipython
12:22:07 <benzrf> larocca: ghci has "it"
12:22:14 <agibiansky> benzrf: I have used ipython, yeah
12:22:16 <EvanR> colors, shows unevaluated computations (rather than NO SHOW INSTANCE MUTHAFUCKA)
12:22:22 <larocca> ;)
12:22:27 <benzrf> also it has a :doc command
12:22:50 <benzrf> it's kind of generally classier (for the most part)
12:22:59 <agibiansky> Ah, okay
12:23:07 <benzrf> it quits on ^C though :(
12:23:10 <EvanR> that kind of thing is probably a big deal for catching on to new users
12:23:20 <EvanR> like the julia console
12:23:36 <agibiansky> benzrf: If you want a better console, IPython might be a good way to go
12:23:50 <brainacid> ski, forgive me i was absorbed in my other screen
12:23:55 <agibiansky> IHaskell has been mostly focused on the notebook aspect of it, but it's an easy way to get a good console too
12:24:37 <brainacid> ski, no worries mate, im just dable'n ... not really sure whats going on..lol
12:25:07 <EvanR> so ghci can freeze during breakpoint stepping?
12:25:23 <EvanR> or is this a bug
12:26:46 <Aruro> Lambdabot/Command.hs:60:5: Wrong category of family instance; declaration was for a type synonym
12:26:46 <Aruro>     In the newtype instance declaration for ‘StT’
12:26:47 <Aruro>     In the instance declaration for ‘MonadTransControl Cmd’
12:26:58 <Aruro> what should be the cause of problem?
12:27:02 <Aruro> trying to compile lambdabot
12:35:22 * hackagebot folds-common 0.1.1.0 - A playground of common folds for folds  http://hackage.haskell.org/package/folds-common-0.1.1.0 (jozefg)
12:37:52 <benzrf> Aruro: weird
12:38:06 <Aruro> yes :(
12:38:16 <danilo2> Hello! Is there a generalization in Haskell of zip? I mean I've got datatype instances (A a) and (A b) and I want to create (A (a,b))
12:38:24 <hiptobecubic> this thing is crazy http://jozefg.bitbucket.org/posts/2014-12-27-folds.html
12:38:25 <Aruro> i was struggling to compile reg exp first
12:38:34 <Aruro> then i made it and now this :(
12:38:54 * Pamela Sala de chat para todos Los Latinos Los esperamos ahy chikos y chicas libre de expresion :* http://www.redlatina.net/ o /server irc.redlatina.net
12:39:04 <k00mi> Aruro: an update to monad-control is the cause for that
12:39:19 <Aruro> what should i do?
12:39:31 <Aruro> install earlier version of it?
12:39:52 <k00mi> Aruro: either add an upper bound to the dependency or fix the code
12:40:01 <klarrt> Does anyone have an opinion of Real World Haskell?
12:40:28 <Hijiri> danilo2: zipWith
12:40:31 <Hijiri> @src
12:40:31 <lambdabot> src <id>. Display the implementation of a standard function
12:40:35 <Hijiri> @src zip
12:40:35 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:40:35 <lambdabot> zip _      _      = []
12:40:40 <Hijiri> oh, that's not what I meant
12:40:43 <k00mi> klarrt: it's an excellent book, though sadly rather outdated
12:40:44 <Hijiri> zip = zipWith (,)
12:40:48 <Hijiri> @src zipWith
12:40:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:40:48 <lambdabot> zipWith _ _      _      = []
12:41:00 <Procian> danilo2: liftA2 (,) generalises zip.
12:41:08 <Aruro> which version of monad-control should be fine?
12:41:09 <danilo2> Procian: right!
12:41:21 <Aruro> k00mi
12:41:22 <danilo2> Procian: I just found it also in Data.Zip (cc. Hijiri )
12:41:23 <k00mi> Aruro: < 1.0.0.0
12:41:28 <danilo2> Procian: thank you!
12:41:39 <Procian> No worries.
12:42:12 <Zekka> Procian: Although it emphatically doesn't do what zip does for bare lists
12:42:18 <klarrt> k00mi: ok, i'm learning from it now. It's kind of hard, and quite theoretical so it takes a while to process everything i read and the examples
12:42:20 <Zekka> (ZipList does the right thing)
12:42:20 <Procian> ZipList does.
12:42:25 <larocca> has anyone worked with zmq?
12:42:32 <Aruro> can i just install it above newer version of monad-control , or i better unistall the new one first?
12:42:33 <EvanR> liftA2 Ctor2 generalizes further, any binary data constructor
12:43:01 <k00mi> klarrt: IMO learn you a haskell is better for learning the basics of the language
12:43:30 <k00mi> klarrt: also, the comments on the online version sometimes explain what has changed
12:43:37 <Hijiri> klarrt: https://github.com/bitemyapp/learnhaskell is good too
12:43:57 <benzrf> k00mi: i second bitemyapp/learnhaskell and im a real pro
12:44:29 <klarrt> thanks people
12:44:39 <benzrf> klarrt: to be precise it recommends CIS194 which is a course from penn whose resources are available online
12:44:44 <brainacid> hey im trying to split an even list
12:44:49 <benzrf> it is p excellent for actually grasping the stuff
12:44:55 <brainacid> is there a better way than using guards?
12:44:59 <agibiansky> larocca: I've worked with zmq a bunch, why?
12:45:28 <agibiansky> larocca: Not an expert but have used it via haskell bindings
12:45:35 <larocca> im just getting into it & wondering how I should structure messages
12:45:53 <benzrf> ømq is the shit
12:45:53 <larocca> like if there's a standard or something
12:46:01 <benzrf> brainacid: explaoin
12:46:16 <benzrf> brainacid: i would do something like take the length and halve it
12:46:38 <agibiansky> larocca: Uh... I'm not sure. I think the answer is no – it's a pretty structure agnostic communication library
12:46:38 <brainacid> take a list of at least 2 elem -> ([elem1],[elem2])
12:46:39 <klarrt> as long as it's semi-good (and not teaching complete factual errors as some c++ books) i'm okay with it... as you dive deeper into a language you make new distinctions and can see for yourself what works and what doesn't.
12:46:45 <brainacid> if its even split it in half
12:46:48 <EvanR> :t splitAt
12:46:49 <lambdabot> Int -> [a] -> ([a], [a])
12:46:58 <agibiansky> larocca: Can't really give that much info there, but if you want an example of an extensive protocol, take a look at ipython's (it's what ive used it for): http://ipython.org/ipython-doc/dev/development/messaging.html
12:47:07 <brainacid> Im trying to learn how to make my own EvanR
12:47:17 <klarrt> but thanks for the input. I'm going for the Real World Haskell and then looking into the other things you mentioned
12:47:25 <brainacid> its an exercise
12:47:26 <agibiansky> EvanR is probably hard to duplicate, strong AI and whatnot being a challenge...
12:47:41 <EvanR> agibiansky: huh
12:47:50 * ski annotated “ordered selection (combinations), Prolog solution, from 2012-12-16” with “power loops” at <http://lpaste.net/117380#a117382>
12:48:07 <Hijiri> brainacid: I remember there being a method where you walk the list twice in parallel, with one walk being by twos
12:48:18 <Hijiri> and then when the faster one gets to the end, the slower one is in the middle
12:48:19 <larocca> ah yes, this is sort of what i had imagined
12:48:21 <larocca> thanks!
12:48:27 <Zemyla> Okay, question.
12:48:42 <danilo2> I've got one more small question to you guys :) Is there any document / tutorial describing the current state of the art of compiling and loading shared libraries in Haskell?
12:49:08 <Hijiri> oh, but I guess that doesn't check if it's even
12:49:10 <Zemyla> If fst were a method of the Firstable class, and thus defined for all tuples, should lists be Firstable too?
12:49:28 <brainacid> ok Hijiri
12:49:30 <agibiansky> Zemyla: Can you always take the first element of a list?
12:49:35 <Hijiri> you could do that too though, by discriminating how far off the end of the list you went
12:49:46 <EvanR> Zemyla: non-empty lists, yes
12:49:58 <EvanR> fst (a, [a]) = a
12:50:08 <EvanR> fst (x, xs) = x
12:50:12 <brainacid> knHalf [1,2] -> ([1], [2])
12:50:25 <brainacid> knHalf [1,2,4,5] -> ([1,2], [4,5])
12:50:42 <Zemyla> agibiansky: Well, there's two ways to do it.
12:51:14 <Zemyla> First is to say that fst ls returns Maybe a.
12:51:26 <EvanR> always being able to take something out is the start of Comonad
12:51:30 <Zemyla> The other is to just say it's an error like head.
12:51:58 <danilo2> I've heard that nowadays we should use some GHC Api to create shared library based plugin system. Did anyone have more information about this topic? :)
12:52:19 <EvanR> or f a -> a by itself could be called Algebra
12:53:02 <EvanR> evaluations of expressions over a are closed in a
12:53:22 <bgamari> danilo2, what are you trying to do?
12:53:59 <danilo2> bgamari: Just create a plugin system in Haskell. Be able to compile some files as libraries and then load them in runtime from a folder and call a function "register" from each plugin
12:54:19 <quchen> Hijiri, brainacid: You're probably thinking about the clever "zipWith const" solution. Search for "half ::" here: https://github.com/quchen/articles/blob/master/useful_techniques.md
12:54:41 <bgamari> danilo2, I see
12:54:44 <agibiansky> danilo2: Do you necessarily need them to be libraries?
12:55:05 <agibiansky> e.g. do you need the performance of compiled code, or is interpreting an acceptable overhead?
12:55:06 <bgamari> danilo2, doing this at runtime will definitely complicate things
12:55:07 <EvanR> Zemyla: list stream sequence and array dont really follow the same laws, tuples even less so, but by reducing the require to f a -> a, you could take non empty lists, non empty sets, and many things as instances
12:55:44 <danilo2> agibiansky: Hmm, no. I want to be able to create some "binaries" and load them in runtime from a folder in the best possible way. Then I want to call osme functions from these plugins, as they are just in one haslkell program. They of course should have a common api
12:56:11 <danilo2> bgamari: I want to load these plugins from a folder on disk. And users can just put the "plugins" there
12:56:34 <danilo2> bgamari: This is kind of standard way with dealing with plugins, isnt it? For example clang - works this way
12:56:35 <Zemyla> Also, I'm not sure if I should have separate Firstable, Secondable, etc. instances, or if they should be a Gettable loc tuple class.
12:56:52 <Aruro> is it a common philosophy not to include third party libraries like pcre?
12:57:00 <Zemyla> Where loc is one of the singleton classes One, Two, Three, etc.
12:57:03 <Aruro> forcing a poor user pain and sufferings?
12:57:16 <EvanR> Zemyla: Gettable is a common attempt to make a generic interface, but its really not very generic
12:57:24 <bgamari> danilo2, sure, it is indeed pretty common
12:57:27 <agibiansky> danilo2: You can use GHC API in an interpreting/compiling sort of sense via the InteractiveEval module, or you can just compile to a dynamic library (*.so/*.dylib/*.dll) and load that dynamically as you would in other languages; via the second route you don't need the GHC API since you're not doing any compiling or interpreting
12:57:30 <bgamari> danilo2, that's not to say that it's easy ;)
12:57:52 <bgamari> danilo2, you may want to see the old `plugins` package to see one way that this can be done: http://hackage.haskell.org/package/plugins-1.5.4.0/docs/src/System-Plugins-Load.html#load
12:58:05 <agibiansky> danilo2: If you want to go the 2nd route (that's how most uses of this pattern go), you can take a look at mietek's example repo: https://github.com/mietek/haskell-so-example
12:58:20 * mietek appears
12:58:33 <danilo2> agibiansky: I'm interested in the second way I think. I  want it to work as fast as possible - without interpretation or compiling stuff - just loading the things in runtime. How can this be done ?
12:58:47 <danilo2> agibiansky: Oh!
12:59:00 <Zemyla> Well, I would still have to write the boilerplate for each of the tuples for each of the elements it would be getting, but that way I wouldn't have to come up with fifteen different three-letter abbreviations for the getters for the various places. :P
12:59:16 <bgamari> danilo2, nowadays dynamic linking is default anyways, although this may not be the case for much longer, https://ghc.haskell.org/trac/ghc/wiki/DynamicLinkingDebate
12:59:27 <danilo2> bgamari: I was looking into the "od" plugins package but it does not ocmpile now. I will dig inside it of course - I just wnated to aks if there is right now any standard way. I think the "plugins" package need an update
12:59:35 <EvanR> Zemyla: just using Data.Map saves a lot of trouble here. or you could go all the way and do Data.Data
12:59:38 <jeremyjh> danilo2: take a look at http://hackage.haskell.org/package/plugins-auto
12:59:41 <bgamari> danilo2, indeed it does
12:59:47 <mietek> agibiansky: My example is for calling Haskell from other languages, like C, not from Haskell itself.
13:00:03 <mietek> I believe calling Haskell plugins from Haskell should be simpler.
13:00:15 <Aruro> ok i give up, mac and goa just do not work :D
13:00:15 <Zemyla> Well, most people don't go through and define Data for the types in the tuples.
13:00:19 <mietek> I have not prepared an example for that, though.
13:00:21 <danilo2> agibiansky: The example (2nd route) you linked is a C code loading the libs, not Haskell one :(
13:00:27 <quchen> Zemyla: There are two ways to tackle the problem of generically adressing n-tuples. One is to use lens, and I think it's nontrivial to create getters/setters that work on tuples of all sizes. The other one is using TH, which I would consider a semi-weird hack. If you ask me, anything larger than a 2-tuple is questionable, and anything above 4 is wrong. Use a custom ADT for those.
13:00:31 <Aruro> lambda bot just does not want to compile
13:00:37 <mietek> danilo2: you could do the same thing from Haskell, using the FFI.
13:00:44 <mietek> But that is probably not optimal.
13:00:48 <danilo2> bgamari: What do you mean by "although this may not be the case for much longer" ?
13:01:07 <danilo2> mietek: ugh, should I use FFI to load library written in Haskell into haskell? Oo
13:01:12 <Aruro> why not to include it in haskell platform is beyond my understanding of marketing
13:01:16 <bgamari> danilo2, there is some debate whether switching to dynamic linking by default was the right thing to do
13:01:27 <agibiansky> danilo2: As mietek says, there's probably a simpler way to do it if its haskell -> haskell, though I am sure you could pretend Haskell is just C :P Anyway, mietek knows more than I do about this, I'm already a bit out of my depth, so good luck :)
13:01:27 <mietek> danilo2: I did not say you should do so.
13:01:35 <bgamari> danilo2, it's not as clear of a win as we originally thought it would be
13:01:38 <EvanR> quchen: and HList
13:01:45 <mietek> danilo2: I am saying you could do so, and it should work.
13:01:52 <danilo2> jeremyjh: It will not work, it bases on "plugins which is broken
13:02:02 <mietek> danilo2: I do not know what is the optimal way to do Haskell plugins for Haskell today.
13:02:34 <quchen> EvanR: HList's types make me run away, quickly
13:02:45 <jeremyjh> danilo2: yes, i just noticed it has not been updated since 2011 and will not compile with template haskell from 7.63
13:02:56 <mietek> danilo2: however, calling via FFI does meet your criteria of having as little done at runtime as possible.
13:02:58 <danilo2> mietek: Ok, that is good sign, that I can do this this way, thank you. Anyway I will look for better way for now also!
13:03:17 <mietek> danilo2: let me know if you find out.  I am here or in #haskell-deployment.
13:03:24 <danilo2> mietek: right! It is still a little bit ugly, you know :(
13:03:32 <danilo2> mietek: ok!
13:03:32 <bgamari> danilo2, look up Simon Marlow's lightening talk at HIW last year foor more details
13:03:34 <agibiansky> What's a good package with very few dependencies that's quick to install?
13:03:37 <mietek> Yes, but unfortunately, Haskell is not Lisp.
13:03:42 <agibiansky> Just any package :) need a test package
13:03:43 <quchen> agibiansky: dlist
13:03:45 <bgamari> agibiansky, highlight-versions
13:03:45 <Zemyla> quchen: Yes, but I find it strange that not even 3-tuples are usable with fst or uncurry.
13:03:48 <agibiansky> thanks
13:03:53 <mietek> I do recall there was some recent work in this area, done at Facebook, I think?
13:04:16 <jeremyjh> mtl is quick, only has one dependency
13:04:41 <EvanR> Zemyla: what do you have that uses 3tuples?
13:04:45 <danilo2> agibiansky, bgamari, mietek: Ok, but could you guys hjust give me some hints what would be *theoreticaly* the best way of doing it (the best in term - the most performant) ? I undestand I should not use GHC api - just not to compile / interpret stuff ,right?
13:05:00 <quchen> Zemyla: I'm not a friend of tuples (as they suffer from tuple/either/whatever blindness), so I'm not terribly concerned about the lack of deconstructors
13:05:09 <bgamari> danilo2, right, GHC API definitely won't be the fastest
13:05:23 <bgamari> danilo2, you would want to load a static or dynamic object
13:05:32 <EvanR> its hard to read ex python or javascript that numerically indexes arrays to get who-knows-what in this section of code
13:05:45 <EvanR> pattern matching is great
13:06:05 <danilo2> bgamari: It does not matter right now for me. The only things that are important are 1) performance 2) that plugins can be just put into a folder
13:06:23 <mietek> bgamari: presumably there is already some glue somewhere in GHC/GHCi which calls dlopen/dlsym and could be reused?
13:06:25 <danilo2> bgamari: *and loaded in runtime
13:06:53 <danilo2> I think this is a good question for #ghc. I will ask there
13:06:55 <jeremyjh> danilo2: I got auto-plugins to compile...it was importing a module it didn't use
13:07:17 <agibiansky> danilo2: GHC API is used for compiling or interpreting things. You *can* use GHC API to compile the plugin at runtime, and pay an upfront cost, for the code to run quickly later; but if you want the entire thing to be fast, then use dynamically linked libraries. Then, to build a dynamically linked library, you just invoke ghc with -dynamic, or cabal with --enable-shared (see more
13:07:17 <agibiansky> https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/using-shared-libs.html). Then a simple option is to just use the raw dlopen API on these plugins and just use Haskell as if it were C when loadingt the library. Probably not the best option though, asking #ghc is a good idea
13:07:19 <jeremyjh> danilo2: if you remove import Language.Haskell.TH.Syntax.Internals it will compile
13:07:24 <danilo2> jeremyjh: Did you compile the plugins packager?
13:07:43 <jeremyjh> danilo2: it compiled the plugins package dependency if thats what you mean
13:08:05 <danilo2> agibiansky: Ok, so I want dynamic libraries. The question is - how can I load them in runtime from haskell ?
13:08:11 <jeremyjh> danilo2: the way to work with this would be use  a cabal sandbox with cabal sandbox add-source ..path/to/modified/auto-plugins
13:08:13 <bgamari> mietek, GHC doesn't expose much of the object loader as far as I know
13:08:22 <bgamari> danilo2, that is really the question of the hour
13:08:45 <bgamari> danilo2, I'm not sure that we provide a good way to do this at the moment
13:08:59 <danilo2> jeremyjh: interesting, I'll take a look a t it in a second. In meantime I will ask at #ghc also
13:09:06 <jeremyjh> i love packages that have no issue tracker
13:09:27 <mietek> Clearly they have no issues.
13:09:40 <agibiansky> danilo2: I am not sure. I suspect that one way would be to use dlopen, dlsym, etc, e.g. https://hackage.haskell.org/package/unix-2.4.0.2/docs/System-Posix-DynamicLinker.html. I'm not sure how you call the FunPtr once you get it, though, it's probably possible? Then use some unsafe casts or Dynamic to jump around the type system.
13:10:22 <jeremyjh> danilo2: which version of ghc are you using?
13:10:24 <bgamari> danilo2, sadly agibiansky's suggestion is likely the best you'll be able to to
13:10:43 <bgamari> danilo2, unfortunately it may not be terribly cross-platform
13:10:55 <danilo2> jeremyjh: my custom one. Modified 7.8.3
13:11:11 <agibiansky> bgamari: What platforms will this fail on? (genuinely curious) Just windows, or will there be other issues?
13:11:18 <danilo2> agibiansky: that is an interesting point!
13:11:21 <agibiansky> (windows b/c unix package doesn't exist there afaik)
13:11:27 <mietek> Should be POSIX.
13:11:27 <zq> what are the requirements for using my own datatype as an argument to an ffi call?
13:11:56 <danilo2> bgamari: Ouch. but this is just terrible. Why such langiuage as Haskell cannot just load shared libraries ....
13:11:58 <zq> i'm getting 'unacceptable argument type' errors despite having already defined a Storable instance
13:12:12 <EvanR> :t poke
13:12:13 <lambdabot> Not in scope: ‘poke’
13:12:25 <bgamari> agibiansky, that's a good question; I just know that on some older UNIXes dynamic linking is terribly quirky
13:12:34 <agibiansky> fair 'nuf
13:12:45 <ski> @type Foreign.Storable.poke
13:12:46 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
13:12:59 <zq> yes i defined that for my instance
13:13:10 <bgamari> danilo2, we've only recently really started even supporting shared libraries
13:13:25 <bgamari> danilo2, they are trickier than you'd think
13:14:01 <jeremyjh> danilo2: did you rule out plugins meeting your needs? it appears to be maintained pretty well
13:14:13 <danilo2> bgamari: Ok, could you tell me who is responsible for them in GHC team? I'm asking just to talk with him/her and maybe create a new "plugins" library
13:14:13 <bgamari> danilo2, especially in a language that has such an unusual execution model
13:14:29 <danilo2> jeremyjh: give me few seconds
13:14:40 <bgamari> danilo2, If I were you I would send a message to ghc-devs
13:15:04 <bgamari> danilo2, Simon Marlow would certainly be helpful, but he's been quite busy recently
13:15:22 <danilo2> jeremyjh: The plugins was updated 2 years ago - last time it did not compile (I dont know why it compiles now) - but anyway I would love to use shared libraries, which it does not support as far as I see
13:16:11 <danilo2> bgamari: I will send the mail
13:16:23 <jeremyjh> danilo2: it was updated like 14 months ago , and hydra is building it successfully on 7.8.4
13:16:31 <bgamari> danilo2, It will be interesting to see what folks say
13:16:37 <Aruro> > cos pi
13:16:38 <lambdabot>  -1.0
13:16:45 <Aruro> > sin pi
13:16:46 <lambdabot>  1.2246467991473532e-16
13:16:55 <jeremyjh> it has a very easy to use api
13:16:59 <Aruro> interesting ...
13:17:06 <danilo2> jeremyjh: Interesting. I'm testing it at the moment
13:17:09 <jeremyjh> http://hackage.haskell.org/package/plugins-1.5.4.0/docs/System-Plugins-Load.html
13:17:13 <Taneb> > sin pi :: Float
13:17:14 <lambdabot>  -8.742278e-8
13:17:18 <Taneb> > sin pi :: CReal
13:17:19 <lambdabot>  0.0
13:17:30 <Aruro> it is float
13:17:35 <Aruro> i think
13:17:54 <Aruro> still it is wrong answer
13:18:00 <Aruro> > cos pi
13:18:01 <lambdabot>  -1.0
13:18:02 <Taneb> It's veeery close
13:18:08 <EvanR> > cos pi :: CReal
13:18:09 <Aruro> :)
13:18:10 <lambdabot>  -1.0
13:18:16 <Aruro> u see
13:18:17 <Taneb> > cos (2*pi)
13:18:17 <shaykha> How does ghci compute trigonometric functions like that?
13:18:18 <lambdabot>  1.0
13:18:31 <Taneb> shaykha, same way any other language does it, I presume...
13:18:33 <Aruro> it is bug
13:18:42 <Aruro> not a very small number
13:18:46 <Aruro> it should be zero
13:18:48 <quchen> No.
13:18:51 <EvanR> Aruro: its not exactly pi in the first place, thats the bug
13:18:51 <Aruro> same way as cos is 1.0
13:19:09 <Aruro> yep :)
13:19:12 <quchen> The bug is misunderstanding how floating point operations work.
13:19:22 <Aruro> and how does that work?
13:19:29 <ski> > sin pi :: CReal
13:19:29 <bgamari> Aruro, luck
13:19:30 <lambdabot>  0.0
13:19:39 <Aruro> fyi  cos pi is also floating point
13:19:39 <ski> @where floating-point
13:19:39 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
13:19:41 <benzrf> lambdabot: nice emote
13:19:44 <danilo2> jeremyjh: Ah! I know! Last time I tried to install the plugins package from repository, all the test failed. I was writing about it here on IRC and somebody told me it is obsolete
13:19:50 <quchen> It's complicated, and it's out best shot at approximating real numbers using finite memory.
13:19:53 <danilo2> jeremyjh: anyway I'm testing it right now
13:20:00 <bgamari> Aruro, Pi is irrational; it can't be represented in floating point
13:20:10 <Aruro> it is not about that
13:20:11 <EvanR> Aruro: use CReal for improve accuracy ;)
13:20:16 <Taneb> Aruro, it's a bug with floating point, not with Haskell
13:20:21 <benzrf> quchen: nah man lots of reals can be represented in finte memory
13:20:25 <benzrf> just use cauchy sequences ( ͡° ͜ʖ ͡°)
13:20:26 <Aruro> pi is special for trigonometry i can be implemented with care :)
13:20:31 <Aruro> it*
13:20:32 <quchen> > 0.1 + 0.2 -- also not a bug.
13:20:33 <lambdabot>  0.30000000000000004
13:20:49 <jeremyjh> danilo2: please let me know how it turns out for you. I haven't used it yet but its on my roadmap to support this eventually
13:20:53 <EvanR> Aruro: good luck with that
13:21:08 <Aruro> why using than outdated floating point?
13:21:09 <quchen> benzrf: I say "you can't represent all reals in finite memory so you have to approximate", I don't think "hey here's an example of a real that you can do this for" is a good answer.
13:21:16 <Aruro> when even layman can see it is buggy
13:21:20 <danilo2> jeremyjh: I'm trying it right now. If youve got little time, you can help me if you want - just try to create a minimal working example
13:21:25 <danilo2> jeremyjh: what do you think? :)
13:21:31 <quchen> Your expectation is buggy, not floating point operations.
13:21:39 <ski> Aruro : you should read the above links
13:21:40 <Aruro> tell me more
13:21:42 <bgamari> Aruro, http://floating-point-gui.de/
13:21:48 <benzrf> quchen: oh, /all reals/
13:22:10 <bgamari> as lambdabot said
13:22:14 <ski> benzrf : (computable) non-algorithmic ones may perhaps be problematic
13:22:15 <bgamari> and I missed ;)
13:22:17 <Aruro> i did not have expectations
13:22:25 <Aruro> i entered second grade math expression
13:22:32 <Aruro> and computer showed me finger
13:22:34 <Aruro> that is all
13:22:48 <Aruro> if he would hide finger i would be quiet
13:22:51 <jeremyjh> danilo2: sure I'll try it
13:23:00 <bgamari> Aruro, well, it gave you an answer that was correct to the precision that the machine is able to represent
13:23:04 <quchen> You expected that 0.2 stands for 2/10, and that (+) stands for addition of real numbers. That is an expectation not met by floats.
13:23:05 <EvanR> floating point includes special values for middle finger: NaN
13:23:13 <Aruro> than there should be no pi
13:23:21 <Aruro> since it is not a real thing :)
13:23:29 <EvanR> pi is a real
13:23:29 <Aruro> just type by hand 3.14
13:23:32 <quchen> EvanR: I don't agree. Two middle fingers can be equal after all. :-D
13:23:33 <Aruro> and there u go
13:23:36 <bgamari> Aruro, The machine doesn't encode floating point in base-10
13:24:02 <EvanR> even if it was in base pi, youd have trouble
13:24:05 <Aruro> pi is not a real thing in terms of floating point, it should not have symbol in system then
13:24:07 <bgamari> Aruro, so while 0.2 has a nice representation in our base-10 numerical representation, to the computer it's something much less clean
13:24:36 <bgamari> Aruro, the variable `pi` is approximately the value that you know as pi
13:24:45 <Aruro> yes
13:24:51 <Aruro> that is clear :)
13:24:54 <EvanR> Aruro: pi isnt a method of the floating point class, its a method of the Floating class
13:24:56 <bgamari> Aruro, the same way any floating point arithmetic is approximate
13:25:01 <Aruro> what is not clear why i need it, if > sin pi
13:25:35 <Aruro> > sin pi
13:25:36 <lambdabot>  1.2246467991473532e-16
13:25:44 <Aruro> i like looking at it
13:25:50 <sinelaw> that's a phone number
13:25:58 <Aruro> it should give correct answer
13:26:02 <quchen> It does.
13:26:02 <Aruro> regardless of problems
13:26:11 <sinelaw> Aruro, is that not correct?
13:26:22 <Aruro> 0.0
13:26:25 <Aruro> is the right answer
13:26:30 <Aruro> > cos pi
13:26:31 <sinelaw> but not for this question
13:26:33 <lambdabot>  -1.0
13:26:36 <Aruro> like this
13:26:37 <larocca> how does the lambdabot handle infinite loops?
13:26:40 <Aruro> ^
13:26:44 <EvanR> > let x = x in x
13:26:47 <lambdabot>  mueval-core: Time limit exceeded
13:26:50 <quchen> Talking to a wall feels silly, I'm out
13:26:51 <larocca> channel hangs? ;)
13:26:52 <sinelaw> > pi
13:26:53 <lambdabot>  3.141592653589793
13:27:05 <sinelaw> Aruro, does that look like the math "pi" to you?
13:27:08 <Aruro> it has to be done
13:27:10 <MP2E> larocca: there's an evaluation time limit
13:27:13 <larocca> ah
13:27:15 <Aruro> throught lazy infinite loop
13:27:18 <bgamari> Aruro, `abs (sin pi)` is less than the precision of the type; it gives the right answer
13:27:23 <Aruro> pi has to be implemented lazily infinite
13:27:28 <danilo2> jeremyjh: something is wrong with these plugins package - the tests inlcuded inside does not run, because thw code inside them want to create instances of Typeable and now the Typeable looks different than in GHC 7.4
13:27:43 <EvanR> > pi :: CReal
13:27:44 <lambdabot>  3.1415926535897932384626433832795028841972
13:27:45 <bgamari> Aruro, no, Float is just a typical 32-bit floating point number, the same as C's `float` type
13:27:47 <ski> > 0x3.243f6a8885a3000
13:27:48 <lambdabot>  Not in scope: ‘f6a8885a3000’
13:27:48 <sinelaw> Aruro, how will you ever compute anything?
13:28:03 <sinelaw> that terminates
13:28:10 <sinelaw> you'll truncate it
13:28:13 <sinelaw> anyway
13:28:18 <jeremyjh> danilo2: yes Typeable instances changed in 7.8; I only had 7.6.3 on this machine so installing 7.8.4 now to try it
13:28:19 <bgamari> Aruro, If you want arbitrary precision arithmetic then you need to use an arbitrary precision arithmetic library
13:28:20 <ski> @help run
13:28:20 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
13:28:26 <Aruro> ok
13:28:27 <ski> larocca ^
13:28:33 <Aruro> how did you compute cos pi?
13:28:33 <sinelaw> Aruro, there are symbolic mathematical systems also
13:28:34 <danilo2> jeremyjh: Ok, I've got minimal example running and .... loadDyn returns undefined :(
13:28:39 <Aruro> it should not be 1.0 either then :D
13:28:45 <sinelaw> Aruro, including in haskell (but I can't find it on hackage)
13:28:52 <EvanR> > cos pi :: CReal
13:28:52 <Aruro> pleasefind
13:28:53 <lambdabot>  -1.0
13:28:57 <Aruro> i dont get this anarchisms
13:29:06 <Aruro> yes why it is 1?
13:29:12 <Aruro> it should be 0.9999
13:29:14 <Aruro> puzzle
13:29:19 <Aruro> is it*
13:29:20 <bgamari> Aruro, luck
13:29:24 <Aruro> -0.999
13:29:25 <sinelaw> heh
13:29:34 <Aruro> no luck
13:29:35 <Aruro> just mistake
13:29:54 <EvanR> display of floating points in base 10 is another matter
13:30:01 <Aruro> it is important
13:30:04 <EvanR> you dont see the full number
13:30:06 <Aruro> for perception of language
13:30:11 <MP2E> This is not a Haskell thing
13:30:12 <EvanR> its just close enough to identify
13:30:14 <MP2E> This is a computer science thing
13:30:18 <bgamari> Aruro, It is important which is why you should just read http://floating-point-gui.de/
13:30:21 <MP2E> it's a limit of the way Floating point numbers are represented
13:30:39 <bgamari> Aruro, your questions will be answered by that document
13:30:47 <danilo2> jeremyjh: wait! I made it working. It returns undefiend if it cannot find the plugin file ....
13:30:58 <danilo2> jeremyjh: anyway its working here!
13:30:59 <quchen> bgamari: That's a nice website.
13:31:06 <bgamari> Aruro, indeed you will find that any other language using floating point arithmetic will exhibit these same issues
13:31:06 <Aruro> ty
13:31:10 <Aruro> bgamari
13:31:24 <quchen> bgamari: I wouldn't vouch for PHP, but yeah
13:31:25 <jeremyjh> danilo2: ok cool :) that wasn't too bad. so you think its just the test will not compile on 7.8?
13:31:26 <Aruro> it should be thrown
13:31:30 <Aruro> and realized through lists
13:31:32 <EvanR> people thought/think excel doesnt know how to add numbers because of this
13:31:41 <Aruro> if you want to compute plug the library
13:31:44 <danilo2> jeremyjh: no way - the tests are broken
13:31:47 <Aruro> why do i need floating point from start?
13:31:48 <bgamari> Aruro, feel free to implement such a scheme
13:31:57 <danilo2> jeremyjh: I will made a minimal example on my github, in 10 minutes
13:32:00 <bgamari> Aruro, because it's easy to implement in hardware
13:32:05 <EvanR> Aruro: you dont have to use it, Float and Double or only two instances of the Floating type, there are others
13:32:23 <bgamari> Aruro, but as EvanR said, you don't need to use it
13:32:40 <EvanR> and youll get a performance hit, or freezes because you cant generally check that two computable numbers are equal
13:32:42 <Aruro> ok that is helpful
13:32:53 <Aruro> so by default it is float ?
13:32:58 <EvanR> speed
13:33:02 <bgamari> Aruro, Right
13:33:03 <Aruro> if not applying :: ?
13:33:06 <danilo2> jeremyjh: anyway the thing with undefined has to be changed . I will patch the plugin package. Additional question - if it happens that a mainainer is not accessibl - is iit a way to just update package without him ?
13:33:29 <ski> > let (m,e) = decodeFloat 3 in printf "%x , %d" m e :: String
13:33:30 <lambdabot>  "18000000000000 , -51"
13:33:39 <ski> > let (m,e) = decodeFloat (0.5) in printf "%x , %d" m e :: String
13:33:40 <lambdabot>  "10000000000000 , -53"
13:33:45 <bgamari> Aruro, correct, this is known as defaulting
13:33:49 <ski> > let (m,e) = decodeFloat (0.1) in printf "%x , %d" m e :: String
13:33:51 <lambdabot>  "1999999999999a , -56"
13:34:00 <EvanR> > 0.1
13:34:02 <lambdabot>  0.1
13:34:09 <EvanR> close enough
13:34:30 <jeremyjh> danilo2: in extreme cases perhaps but usually you have to get the original maintain to update the package or add you as maintainer
13:34:35 <jeremyjh> danilo2: but Jeremy Shaw is still active
13:34:44 <bgamari> Aruro, literals lacking a type annotation will given a default type
13:34:53 <bgamari> > :type 0.1
13:34:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:35:03 <Aruro> ok im reading the floating point guide
13:35:11 <Aruro> and guy already has all right answers :D
13:35:13 <dario> :t 0.1
13:35:13 <lambdabot> Fractional a => a
13:35:15 <Aruro> symbolic computation :)
13:35:23 <bgamari> dario, yeah, my bad
13:35:34 <Aruro> http://floating-point-gui.de/formats/exact/
13:35:45 <quchen> I think defaulting only kicks in on "no instance blabla" errors.
13:35:53 <danilo2> jeremyjh: Ok, ok, that was a question connected to other library
13:36:06 <danilo2> jeremyjh: Anyway, it does not work as nice as I was thinking... :(
13:36:22 <danilo2> jeremyjh: so It does from "runhaskell" but does not after compiling with ghc
13:36:26 <Aruro> somebody was mentioning symbolic library on hackage?
13:36:34 <quchen> Note that Lambdabot has extended defaulting rules, so demonstrating defaulting on this channel isn't always not-working as intended.
13:36:55 <Aruro> he is in agreement with ghci though
13:36:59 <quchen> > Nothing -- no instance Show error in GHCi
13:37:00 <lambdabot>  Nothing
13:37:03 <jeremyjh> danilo2: can you post a gist of your example?
13:37:03 <ski> Aruro : <https://en.wikipedia.org/wiki/Numerical_analysis> may also be interesting
13:37:04 <Aruro> at least in terms of float fun
13:37:11 <danilo2> jeremyjh: sure, brb
13:37:17 <bgamari> Aruro, http://hackage.haskell.org/package/numbers
13:37:20 <bgamari> Aruro, I think
13:37:32 <bgamari> should have something interesting to you at least
13:37:40 <Aruro> ty!
13:38:14 <Aruro> oo yes :)
13:38:18 <Aruro> very nice package
13:38:21 <bgamari> Aruro, no worries!
13:38:23 <Aruro> it has symbolic numbers :)
13:38:29 <Aruro> im going to look at it now
13:38:36 <bgamari> good luck!
13:41:47 <danilo2> jeremyjh: https://github.com/wdanilo/haskell-plugins
13:42:00 <danilo2> jeremyjh: the Plugin.hs compile with -dynamic -iapi
13:42:13 <danilo2> and the Main runhaskell -i../api Main.hs
13:42:44 <jeremyjh> ok
13:45:34 <Aruro> > 1/0
13:45:36 <lambdabot>  Infinity
13:45:46 <Aruro> thats what im talking about :)
13:45:51 <Aruro> beautiful :)
13:45:59 <Aruro> > 1/0
13:46:00 <lambdabot>  Infinity
13:46:05 <EvanR> > 0/0
13:46:07 <lambdabot>  NaN
13:46:09 <EvanR> beautiful
13:46:22 <ski> > product [1.0 .. 100000]
13:46:23 <lambdabot>  Infinity
13:46:25 <ski> beautiful
13:46:51 <Aruro> yes it is
13:46:56 <Aruro> indeed
13:46:59 <Aruro> > div 1 0
13:47:00 <lambdabot>  *Exception: divide by zero
13:47:09 <Aruro> how 1/0 is realized?
13:47:16 <EvanR> > 1/0 :: CReal
13:47:20 <lambdabot>  mueval-core: Time limit exceeded
13:47:23 <ski> > let (m,e) = decodeFloat (1/0) in printf "%x , %d" m e :: String
13:47:24 <lambdabot>  "10000000000000 , 972"
13:47:25 <danilo2> jeremyjh: wtf ... look - running runhaskell - loads the plugins every time. But If you compile the Main with ghc and run it - it breaks the shared library! after you clean the Prog directory and again run runhaskell, it fails with different error unless you rebuild the .o file
13:47:32 <ski> > let (m,e) = decodeFloat (-1/0) in printf "%x , %d" m e :: String
13:47:33 <lambdabot>  "*Exception: printf: bad argument
13:47:39 <ski> hrm
13:48:03 <Aruro> so 1/0 is not represented as CReal?
13:48:09 <ski> > decodeFloat (-1/0)
13:48:10 <lambdabot>  (-4503599627370496,972)
13:48:13 <Aruro> which type shouts out Infinity?
13:48:14 <ski> oh, i see
13:48:17 <jeremyjh> I don't think I have the right  Main.hs
13:48:19 <EvanR> Aruro: Double and Float
13:48:20 <jeremyjh> did you commit it?
13:48:23 <ski> Aruro : floating-point ones
13:48:31 <EvanR> Aruro: its in that floating point site
13:48:33 <jeremyjh> danilo2: the Main.hs only has a print statement in it
13:48:44 <Aruro> oh i did not read it all yet
13:48:53 <ski> > gcd 0 0
13:48:54 <lambdabot>  0
13:48:55 <ski> beautiful
13:49:01 <Aruro> yes :)
13:49:03 <danilo2> jeremyjh: errr, no
13:49:08 <Aruro> things like that and more :)
13:49:10 <danilo2> jeremyjh: https://github.com/wdanilo/haskell-plugins/blob/master/Prog/Main.hs
13:49:50 <danilo2> jeremyjh: ah, sorry - that main is to delete. I was trying to do it as fast aas possible and just leave it by mistake
13:49:50 <jeremyjh> oh Prog/Main.hs, sorry
13:52:16 <ski> @let infixl 7 mod'',divMod''; mod'' :: Integral a => a -> a -> a; n `mod''` 0 = n; n `mod''` d = n `mod` d; divMod'' :: Integral a => a -> a -> (a,a); n `divMod''` 0 = (error "divide by zero",n); n `divMod''` d = n `divMod` d
13:52:16 <lambdabot>  Parse failed: Parse error: mod''
13:53:06 <EvanR> > gcd 3 0
13:53:07 <lambdabot>  3
13:53:21 <EvanR> > gcd (-1) (-1)
13:53:23 <lambdabot>  1
13:54:02 <jeremyjh> danilo2: yes I see the same thing I think, it seg faults after the first execution
13:54:12 <danilo2> jeremyjh: yes
13:54:18 <ski> > let infixl 7 `mod''`,`divMod''`; mod'' :: Integral a => a -> a -> a; n `mod''` 0 = n; n `mod''` d = n `mod` d; divMod'' :: Integral a => a -> a -> (a,a); n `divMod''` 0 = (error "divide by zero",n); n `divMod''` d = n `divMod` d in ()
13:54:19 <lambdabot>  ()
13:54:22 <jeremyjh> danilo2: this may be a library caching issue
13:54:24 <ski> @let infixl 7 `mod''`,`divMod''`; mod'' :: Integral a => a -> a -> a; n `mod''` 0 = n; n `mod''` d = n `mod` d; divMod'' :: Integral a => a -> a -> (a,a); n `divMod''` 0 = (error "divide by zero",n); n `divMod''` d = n `divMod` d
13:54:25 <lambdabot>  Defined.
13:54:37 <danilo2> jeremyjh: It could not find a symbol with a mangled name
13:54:39 <ski> > 15 `mod''` 0
13:54:40 <lambdabot>  15
13:55:42 <Aruro> in line of this , how great looks this definition of factorial : let factorial n = product [1..n]
13:55:51 <Aruro> best and shortest i guess
13:56:17 <HeladoDeBrownie> Aruro, looks good to me
13:56:48 <Aruro> there is one more technical : let fact = foldr (*) 1
13:56:54 <Aruro> but i like first one for being closest to the definition of what factorial is
13:57:16 <EvanR> http://www.willamette.edu/~fruehr/haskell/evolution.html
13:57:18 <HeladoDeBrownie> Aruro, note that it doesn't give the correct answer for all inputs though
13:57:31 <Aruro> > let fact = foldr (*) 1
13:57:31 <benzrf> EvanR: :)
13:57:32 <lambdabot>  not an expression: ‘let fact = foldr (*) 1’
13:58:18 <danilo2> jeremyjh: Ok, I've got small progress here
13:58:44 <Aruro> haah
13:59:01 <Aruro> so im point free haskell programmer who studied at Oxford
13:59:16 <Aruro> always knew there is something aristocratic to it :D
13:59:28 <danilo2> jeremyjh: look - compile the Prog and THEN the plugin. After such process, the prog does NOT load the plugin (segfault) but no matter how many times I execute Main, runhaskell suceed. So ... it seems tht compiling Main, changes the .hi (or sthg) file of API!
13:59:51 <EvanR> @src fact
13:59:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:00:52 <Aruro> >let frl = foldr (*) 1
14:01:34 <jeremyjh> danilo2: trying something
14:01:36 <Aruro> damn hotel internet
14:01:45 <Aruro> >let frl = foldr (*) 1
14:01:50 <danilo2> jeremyjh: confirmed, this is the issue
14:02:07 <Aruro> > let frl = foldr (*) 1
14:02:08 <lambdabot>  not an expression: ‘let frl = foldr (*) 1’
14:02:13 <Aruro> hm
14:02:19 <danilo2> jeremyjh: I just took write provileges and compilation of Prog fails because it needs to modify the .hi file!
14:02:55 <Aruro> @let frl = foldr (*) 1
14:02:56 <lambdabot>  Defined.
14:03:13 <Aruro> > frl [1..20]
14:03:15 <lambdabot>  2432902008176640000
14:03:21 <Aruro> this IS beautiful
14:03:21 <danilo2> jeremyjh: a small progress - compiling Prog with flag -dynamic does not affect the .hi
14:04:01 <jeremyjh> danilo2: I am not sure that is how to make a shared object...Plugin.o I think is just an object file
14:04:19 <benzrf> EvanR: omg
14:04:19 <jeremyjh> danilo2: but I get the same result using the "load" function, which is designed for plain object files
14:04:33 <danilo2> jeremyjh: but with runhaskell it works - loads the "plugin" a nd prints "hello from the plugin"
14:04:34 <benzrf> EvanR: i legit understand about 65% of the cata one
14:04:46 <benzrf> postdoc i mean
14:05:06 <jeremyjh> danilo2: yes, it may some flags needed either in compile or runtime
14:05:37 <greymalkin> by the way -- thank you haskell for forcing me to think about Int vs Integer... I just saved myself from some very mysterious behavior
14:05:38 <Aruro> > pl x*x
14:05:39 <lambdabot>  Not in scope: ‘pl’
14:05:39 <lambdabot>  Perhaps you meant one of these:
14:05:39 <lambdabot>    ‘pi’ (imported from Prelude),
14:05:51 <benzrf> @pl x*x
14:05:51 <lambdabot> x * x
14:05:57 <benzrf> Aruro: kek
14:06:04 <benzrf> Aruro: perhaps u meant:
14:06:10 <benzrf> :t join (*)
14:06:11 <lambdabot> Num a => a -> a
14:06:17 <benzrf> or just
14:06:18 <benzrf> :t (^)
14:06:19 <lambdabot> (Num a, Integral b) => a -> b -> a
14:06:25 <Aruro> yes point less
14:06:25 <benzrf> er, wait
14:06:26 <benzrf> :t (^2)
14:06:27 <lambdabot> Num a => a -> a
14:06:41 <HeladoDeBrownie> Aruro, x * x already has no points. Did you mean \x -> x * x ?
14:06:46 <HeladoDeBrownie> @pl \x -> x * x
14:06:46 <lambdabot> join (*)
14:06:54 <Aruro> yes
14:07:08 <Aruro> somebody please explain me how is it monad :D
14:07:14 <danilo2> jeremyjh: somebody on the top of this conversation told that ocmpiling with -dynamic makes the shared libraries as .o
14:07:32 <Zekka> @src Monad (->)
14:07:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:07:34 <Aruro> i mean which type of monad (*) is
14:07:41 <HeladoDeBrownie> instance Monad ((->) e)
14:07:53 <Zekka> HeladoDeBrownie: Do you know the incantation for this?
14:07:57 <HeladoDeBrownie> no
14:08:06 <HeladoDeBrownie> @src  Monad ((-> e)
14:08:06 <lambdabot> Source not found. It can only be attributed to human error.
14:08:08 <benzrf> @src Monad ((->) e)
14:08:08 <lambdabot> Source not found.
14:08:10 <benzrf> oh
14:08:15 <HeladoDeBrownie> let me find it online
14:08:16 <benzrf> @src Monad ((->) r)
14:08:16 <lambdabot> Source not found. Whoa.
14:08:19 <quchen> Lambdabot @src database: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
14:08:24 <Aruro> so which type of monad the -> is?
14:08:24 <benzrf> thx quchen
14:08:26 <Zekka> I remember it being slightly wrong for form-fitting reasons
14:08:38 <jeremyjh> danilo2: no it means it should use dynamic libraries for is dependencies I think
14:08:40 <Zekka> Aruro: It's not, mbut ((->) r) is
14:08:52 <jeremyjh> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/flag-reference.html
14:09:07 <HeladoDeBrownie> instance Monad ((->) r) where { return = const ; f >>= k = \ r -> k (f r) r }
14:09:11 <Zekka> @src (->) Monad
14:09:11 <lambdabot> Source not found. Are you on drugs?
14:09:17 <Zekka> @src (->) (>>=)
14:09:18 <lambdabot> f >>= k = \ r -> k (f r) r
14:09:18 <HeladoDeBrownie> according to http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Monad
14:09:20 <Zekka> @src (->) return
14:09:20 <lambdabot> return = const
14:09:24 <Zekka> there you are!
14:09:34 <Zekka> Aruro: Does that help? If not I can try to exlain
14:09:39 <jeremyjh> danilo2: if I include -dynamic-too i get a Plugin.dyn_o
14:09:40 <danilo2> jeremyjh: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/using-shared-libs.html
14:09:41 <quchen> That's premium non-understandable notation though :-\
14:09:46 <Aruro> please explain
14:09:51 <Aruro> i like all versions
14:10:00 <Zekka> Aruro: Do you understand how ((->) r) is a functor?
14:10:08 <danilo2> jeremyjh: where did you get this "dynamic-too" ? I did not know that flag
14:10:14 <Aruro> mm because i can transform r?
14:10:19 <jeremyjh> danilo2: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/flag-reference.html
14:10:23 <quchen> How I picture Reader. https://github.com/quchen/articles/blob/master/reader_instance_derived.md#bind
14:10:26 <Aruro> let us see it
14:10:31 <Aruro> can we use fmap on it?
14:10:33 <Zekka> Aruro: That's pretty vague, also not really sure it's correct
14:10:55 <danilo2> jeremyjh: Anyway I do not think that the plugins package support loading .dyn_o files - I hope I;m wrong, but I feel I'm not
14:10:56 <Zekka> Reading quchen's article, it might be bhetter than I can do
14:11:25 <Zekka> Probably the easiest way to look at it is to figure out what it takes to satisfy the types
14:11:38 <Zekka> :t join `asAppliedTo` (undefined :: (r -> (r -> a)))
14:11:39 <lambdabot> (r -> r -> a) -> r -> a
14:11:47 <jeremyjh> danilo2: i get the same error using it
14:11:47 <Aruro> can i say let b = (->r) ?
14:11:50 <Zekka> :t fmap `asAppliedTo` (undefined :: (r -> a))
14:11:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:12:00 <Zekka> Aruro: No, (-> r) isn't a value
14:12:05 <Aruro> m
14:12:06 <Zekka> :t return `asAppliedTo` (undefined :: (r -> a))
14:12:06 <lambdabot> Monad m => (r -> a) -> m (r -> a)
14:12:14 <danilo2> jeremyjh: Oh I got it working ....
14:12:17 <Aruro> then how can it be a functor?
14:12:18 <Zekka> er, that wasn't right
14:12:23 <Aruro> i want a value of that type
14:12:24 <danilo2> jeremyjh: just ocmpile the prog ALSO with flag -dynamic
14:12:29 <Zekka> Aruro: I  don't thikn you quite understand what a functor is
14:12:33 <Zekka> do you want me to try to explain?
14:12:38 <Aruro> functor is typeclass
14:12:42 <Zekka> well, a capital-F Functor, to be precise
14:12:44 <Aruro> thus there is always value
14:12:45 <HeladoDeBrownie> Aruro, Functor instances aren't defined over concrete types, they're defined over types that accept a concrete type as an argument and produce a concrete type
14:12:51 <HeladoDeBrownie> Aruro, it's only concrete types that have values
14:13:18 <Aruro> ok
14:13:25 <Aruro> then how the join accepts (*)
14:13:29 <danilo2> jeremyjh: anyway it works terribly slow. Loading of this plugin takes (compiled with -O2) 0.3 s
14:13:30 <HeladoDeBrownie> instance Functor Maybe where … -- not! instance Functor (Maybe a) where …
14:13:30 <ReinH> Where "concrete types" are types of kind *
14:13:37 <Zekka> Aruro: Do you want a typeclasses talk first?
14:13:38 <Aruro> then (*) is a value of a monadic type
14:13:38 <jeremyjh> danilo2: ouch
14:13:44 <Zekka> It sounds like you'e a little unclear
14:13:49 <Aruro> yes i want all good talks
14:14:01 <Zekka> Aruro: Correct, (*) is m (m a) for some m
14:14:06 <Aruro> lets talk typeclasses first if its needed for join (*) case
14:14:23 <ReinH> Aruro: join is a function, functions take values, values are of kind *
14:14:24 <Aruro> so what is a then?
14:14:47 <ReinH> values are inhabitants of types of kind *
14:14:55 <Aruro> ok
14:15:03 <Aruro> in our case we have join (*)
14:15:09 <Aruro> who is M and who is a?
14:15:10 <ReinH> What does that mean?
14:15:18 <ReinH> :t join
14:15:19 <lambdabot> Monad m => m (m a) -> m a
14:15:21 <Aruro> join (*) == x*x
14:15:22 <Zekka> Aruro: So, join is generally m (m a) -> M a
14:15:22 <ReinH> That is the type of join
14:15:24 <Zekka> m a*
14:15:31 <HeladoDeBrownie> Aruro, let's assume (*) :: Int -> Int -> Int as a simplification. Do you know how to rewrite this prefix instead of infix?
14:15:34 <Zekka> So (*) is somehow m (m a) and will somehow be turned into m a
14:15:52 <ReinH> What does "join (*) == x*x" mean?
14:16:04 <ReinH> Let's stick to well defined notation, please
14:16:06 <Aruro> u know it:D
14:16:14 <ReinH> Aruro: No. I do not.
14:16:21 <Aruro> but i dont know how to rewrite (*) infix that is true
14:16:22 <Zekka> ReinH: join (*) == \x -> x * x (sorry for pedantry!)
14:16:28 <jeremyjh> danilo2: yes I get the same result
14:16:37 <Aruro> ty Zekka
14:16:42 <Aruro> im sure he knew it
14:16:45 <Aruro> he wanted more clarity
14:16:49 <Zekka> Aruro: I'm just not sure if you did!
14:17:01 <Aruro> me of course not :D
14:17:07 <Aruro> i just know that it works
14:17:09 <Zekka> Aruro: Maybe this will help. Can you rewrite (*) as a lambda instead of a section?
14:17:10 <Aruro> and i want to SEE it
14:17:14 <ReinH> Aruro: I actually had no idea what you meant.
14:17:28 <danilo2> jeremyjh: update
14:17:39 <danilo2> jeremyjh: loading 5 plugins takes the same time as 1
14:17:44 <ReinH> Zekka: ( (*) is not a section)
14:17:53 <Zekka> ReinH: What's the better name?
14:17:58 <jeremyjh> danilo2: yes I was just going to suggest that, there may be some overhead
14:18:08 <jeremyjh> danilo2: upfront I mean
14:18:18 <danilo2> jeremyjh: but this overhead is big.
14:18:27 <Aruro> mm (*) == \ x y -> x*y ; lets assume this for simplicity
14:18:35 <danilo2> jeremyjh: too big. You know - loading shared libs in c++ is almost 0-time
14:18:42 <quchen> Zekka: (*) is a name.
14:19:06 <Zekka> Aruro: So, based on what we established, join (\x y -> x * y) == \x -> x * x ?
14:19:20 <Aruro> mm yes
14:19:24 <quchen> A section is the special parenthesized infix expression where one operand is missing.
14:19:25 <Aruro> good point
14:19:35 <Zekka> quchen: Sure, I think I understand
14:19:35 <danilo2> jeremyjh: anyway it is a good starting point. I will write aobut it on mailing list
14:19:57 <Aruro> so join eliminated one argument
14:19:59 <Zekka> Aruro: OK, can yo think of a more general rule that converts things of hte first form to the second one?
14:20:01 <ReinH> Zekka: (*) is an expression. Sections are only of the form (op e) or (e op) , where op is a binary operator and e is an expression.
14:20:27 <Aruro> let me seee
14:20:30 <jeremyjh> danilo2: great, glad it works at least
14:20:36 <Zekka> Aruro: So, the rule takes things that have two arguments and results in things that take one argument, which is passed as both
14:21:15 <quchen> > case "hello" of (*) -> (*) ++ " world" -- (*) is a name like "length" and "filter" and "warrgarbl".
14:21:16 <lambdabot>  "hello world"
14:21:25 <Aruro> join (a-> b->c) == a->a->c
14:21:38 <Zekka> Aruro: Those things are types, not values!
14:21:40 <Aruro> value wise not type wise :)
14:21:45 <Aruro> yes yes :D
14:21:53 <Aruro> join (a-> b->c) == a->c
14:22:10 <Aruro> like this in first approx
14:22:11 <Zekka> Aruro: Can you write it on values? I can get to types in a little bit
14:22:26 <Aruro> in values
14:22:38 <Zekka> join f = ???
14:22:48 <Zemyla> Six-element tuples should be called "chameleons".
14:23:06 <Aruro> join (f) == f a a
14:23:12 <Zemyla> (,,,,,) = chameleon.
14:23:23 <Aruro> join (f a b) == f a a
14:23:40 <Zekka> Aruro: Those are not valid Haskell! Your first one was close
14:23:49 <danilo2> jeremyjh: Thank you :) I'm glad we both managed to do that. I've got to go now. Bye! :)
14:23:55 <Aruro> join (f b) == f
14:24:12 <Aruro> or wait no
14:24:14 <Zekka> Aruro: I'm not really sure what to say: I can give you the answer but I think you need to brush up on your basic Haskell
14:24:16 <Aruro> it does not throw
14:25:17 <Zekka> I can keep walking you through it if you want but I think you might need to fight the compiler a little bit until you know the rules
14:25:25 <Zekka> because I can't reliably tell what you mean
14:25:57 <Aruro> @src join
14:25:57 <lambdabot> join x = x >>= id
14:26:00 <ReinH> Aruro: I'd recommend opening up ghci and trying to convince it that your definition of join is correct
14:26:15 <Aruro> mine is not correct :)
14:26:18 <Aruro> mine was naive
14:26:18 <Zekka> The easiest way might actually just be to write the monad instance yourself
14:26:23 <ReinH> Haskell, like other languages, requires you to be precise.
14:26:25 <Aruro> throught the look of functions
14:26:29 <Zekka> Aruro: That's a generic definition of join in terms of bind
14:26:56 <Zekka> I'll write you a template
14:26:59 <Aruro> > :t >>=
14:27:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:27:16 <ReinH> We're only concerned with join for functions: join :: (a -> a -> b) -> a -> b
14:28:02 <ReinH> Aruro: :t gives you the type of expressions, but operators like >>=  are not expressions. (>>=) is an expression.
14:28:10 <Aruro> yes
14:28:41 <Aruro> so bind would be m a-> (id)->m b
14:28:50 <ReinH> Aruro: That doesn't make sense.
14:28:53 <Aruro> sorry join
14:28:54 <ReinH> id is not a type
14:29:05 <ReinH> Aruro: You can't just mix up values and types.
14:29:13 <Aruro> so bind would be m a-> (a-> m a)->m b
14:29:16 <Aruro> join*
14:29:19 <Zekka> Yeah, what do you think this is, Agda?
14:29:39 <Aruro> im just following definition of join
14:29:42 <Aruro> and >>=
14:29:48 <Aruro> @src join
14:29:48 <lambdabot> join x = x >>= id
14:29:53 <Zekka> Aruro: Have fun! http://lpaste.net/117385
14:30:03 <ReinH> Aruro: Again, you can't just mix up types and values together
14:30:23 <ReinH> Aruro: You should spend some time with ghci. Try to write things that make sense to the compiler. You must be precise
14:30:27 * hackagebot amazonka-core 0.1.2 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.1.2 (BrendanHay)
14:30:29 * hackagebot amazonka 0.1.2 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.1.2 (BrendanHay)
14:30:31 * hackagebot amazonka-autoscaling 0.1.2 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.1.2 (BrendanHay)
14:30:33 * hackagebot amazonka-cloudformation 0.1.2 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.1.2 (BrendanHay)
14:30:35 * hackagebot amazonka-cloudfront 0.1.2 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.1.2 (BrendanHay)
14:30:43 <Aruro> ty guys
14:30:47 <Aruro> so all and all
14:30:52 <Aruro> -> is a thing :D
14:30:54 <Aruro> it turns out
14:31:11 <Zekka> Feel free to mess with the arguments lists and eta to your heart's content -- afaik those types are right and if you can satisfy them without circular definitions (don't define join in terms of (>>=)) you should get a working Reader monad!
14:31:34 <Zekka> (more generally, without nontermination)
14:31:34 <Aruro> :)
14:31:37 <Aruro> ty
14:31:45 <Zekka> Or you might get cancer. I can't make any promises!
14:31:51 <Aruro> haah :D
14:31:53 <Aruro> no
14:32:41 <ReinH> Open up a haskell file, write join :: (a -> a -> b) -> a -> b, then try to define join in a way that type checks. Then we can talk about whether your definition is correct.
14:33:11 <Zekka> ReinH: Check my paste, I gave him a whole load of homework
14:33:24 <Zekka> although in retrospect it migiht have been best to make him just do that, because now I'm worried he'll define join in terms of bind
14:33:42 <Aruro> ha no :)
14:33:42 <ReinH> Zekka: Do you need to indent the where clauses?
14:33:45 <Aruro> how can i do that
14:33:51 <Zekka> ReinH: I didn't think you did. Am I wrong?
14:33:59 <Zekka> @src join
14:33:59 <lambdabot> join x = x >>= id
14:34:07 <Zekka> Aruro: That is how you would do that, but that definition won't help you
14:34:08 <ReinH> Zekka: I'm not sure, I've never not indented them.
14:34:09 <Aruro> i knew that already
14:34:13 <Zekka> @src (>>=)
14:34:13 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
14:34:17 <Zekka> @src >>=
14:34:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:34:19 <Zekka> hm
14:34:33 <ReinH> >>= doesn't have a default definition
14:34:35 <Zekka> Aruro: Well, (>>=) can be defined in terms of join, and if you don't define it that's what you'll get
14:34:47 <Zekka> ReinH: I thought it was defined in terms of join by default! I'll throw it in
14:35:09 <Aruro> i can get the type of (->r)
14:35:14 <Aruro> how can i write a functor for it :)
14:35:18 <ReinH> Zekka: join is not a method in the Monad typeclass
14:35:19 <Aruro> dumb i know but here we are :D
14:35:25 <Zekka> ReinH: Woe is me.
14:35:29 <Aruro> i cant*
14:35:37 * hackagebot amazonka-cloudsearch 0.1.2 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.1.2 (BrendanHay)
14:35:39 * hackagebot amazonka-cloudsearch-domains 0.1.2 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.1.2 (BrendanHay)
14:35:41 * hackagebot amazonka-cloudtrail 0.1.2 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.1.2 (BrendanHay)
14:35:43 * hackagebot amazonka-cloudwatch 0.1.2 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.1.2 (BrendanHay)
14:35:44 <ReinH> You certainly *can* define (>>=) in terms of join (and fmap), ofc
14:35:45 * hackagebot amazonka-cloudwatch-logs 0.1.2 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.1.2 (BrendanHay)
14:35:47 <Aruro> i want to type :t (->) in ghci
14:35:51 <Aruro> and believe my eyes
14:35:54 <Zekka> Aruro: It's not a value
14:35:58 <Aruro> or something similar
14:36:00 <ReinH> Aruro: (->) is not a value. It does not have a type.
14:36:09 <spoog> :t 1
14:36:10 <lambdabot> Num a => a
14:36:11 <ReinH> Aruro: Once again, you need to stop mixing up types and values. That is your number one source of confusion.
14:36:22 <Aruro> than what is Functor ((->) r)
14:36:37 <Aruro> i like confusion :)
14:36:38 <Zekka> Aruro: A Constraint. (I think.)
14:36:41 <Aruro> but im already losing it
14:36:45 <n4x> typeclasses don't take values
14:36:49 <Zekka> ReinH: How is this? http://lpaste.net/117385
14:36:58 <ReinH> Aruro: That's a syntax error.
14:37:00 <pavonia> Aruro: Maybe you should get used to basic Haskell syntax before trying to get more advanced stuff working
14:37:24 <ReinH> Aruro: It could be part of a typeclass instance delaration: instance Functor ((->) r) where ...
14:37:31 <ReinH> Which is a type level construction
14:37:35 <Aruro> no i like big picture
14:37:41 <Zekka> ReinH: I think you can also put it on the left side of an =>, although it's not useful to do
14:37:49 <Aruro> no need of advanced stuff yet
14:37:58 <Zekka> (because without polymorphism you already know whether it's true or not at time of writing it)
14:37:58 <Aruro> so i can not get the type of ((->) r)
14:38:07 <ReinH> Zekka: Can you?
14:38:08 <Aruro> how am i expect to understand it then?
14:38:25 <Zekka> ReinH: I'll check, one sec
14:38:28 <EvanR> are there two kinds of loops, one which "loops hard" like let x = x in x, and never produces any "steps", and something softer which repeats the same steps but never reducing to whnf
14:38:32 <ReinH> Aruro: Once gain, it is not a value, it does not have a type.
14:38:32 <EvanR> ?
14:38:41 <ReinH> Aruro: You can't get the type of things that are not values.
14:38:52 <Zekka> Aruro: This is like asking "what color is addition?"
14:39:08 <Aruro> how can i play with this object ((->) r)
14:39:15 <Zekka> @letlpaste 117390
14:39:16 <lambdabot>  Defined.
14:39:20 <Zekka> > id2 1
14:39:21 <lambdabot>  1
14:39:42 <Zekka> Aruro: You can put it in the head of an instance declaration
14:39:49 <Aruro> ok everything boils down to what ((->)r) really is
14:39:53 <Zekka> You can feed it to anything expecting a (* -> *)
14:40:03 <Zekka> Aruro: It's an (* -> *) -- that's its kind
14:40:07 <Aruro> so its a function?
14:40:12 <pavonia> Aruro: It's a type constructor
14:40:15 <ReinH> Aruro: functions are values.
14:40:16 <Zekka> It's like a function on the type level
14:40:24 <Aruro> aha
14:40:27 <Aruro> finally:)
14:40:27 <n4x> but it is NOT a function
14:40:28 <Zekka> It wants to eat one more type (*) so it can become a type (*)
14:40:32 <Aruro> after hours of torture
14:40:40 <Zekka> er, to be clear, * is not an operator in this context but a name
14:40:47 * hackagebot amazonka-codedeploy 0.1.2 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.1.2 (BrendanHay)
14:40:48 <Zekka> it doesn't need the parens, although they don't make things wrong
14:40:49 * hackagebot amazonka-cognito-identity 0.1.2 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.1.2 (BrendanHay)
14:40:51 * hackagebot amazonka-cognito-sync 0.1.2 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.1.2 (BrendanHay)
14:40:53 * hackagebot amazonka-config 0.1.2 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.1.2 (BrendanHay)
14:40:55 * hackagebot amazonka-datapipeline 0.1.2 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.1.2 (BrendanHay)
14:40:56 <ReinH> oh no
14:41:33 <Aruro> so the only real manifistation to the real man from kinds is join (*) ?
14:41:45 <Aruro> any other examples for the simpltons ?
14:41:48 <ReinH> Aruro: What?
14:41:54 <ReinH> That doesn't make any sense at all
14:41:59 <Aruro> haah :D
14:42:00 <Aruro> think
14:42:03 <Zekka> Aruro: This * has no connection to (*) the value
14:42:14 <Zekka> This * is a kind, (*) the value is a value
14:42:15 <neuroserpens> Hey... I'm curious... Do you guys use case expressions much? I'm reading RHW and LYAH and this construct seems kinda useless since you can just pattern match in function definitions. Is there an advantage I haven't seen yet or anything?
14:42:19 <ReinH> Aruro: Your question is not sensical.
14:42:21 <Aruro> it has connection to the "function" u described
14:42:27 <HeladoDeBrownie> neuroserpens, i use case all the time
14:42:44 <shock_one> Is there a tool like stylish-haskell that's able to insert two lines between functions?
14:42:45 <ReinH> neuroserpens: You don't need a new name for a case statement
14:42:50 <HeladoDeBrownie> neuroserpens, one advantage is it means you don't have to rewrite the binding name over and over. also, there isn't necessarily a binding involved, it could be deeper inside something
14:42:51 <Aruro> typeconstructor
14:42:56 <Zekka> @letlpaste 117390
14:42:56 <lambdabot>  .L.hs:165:1:
14:42:57 <lambdabot>      Duplicate type signatures for ‘id2’
14:42:57 <lambdabot>      at .L.hs:162:1-3
14:43:02 <Zekka> @undefine
14:43:02 <lambdabot> Undefined.
14:43:03 <Zekka> @letlpaste 117390
14:43:04 <lambdabot>  Defined.
14:43:07 <Aruro> that is what we are talking about if im not wrong
14:43:08 <neuroserpens> ReinH HeladoDeBrownie Oh. Yes, indeed.
14:43:11 <Zekka> Wait, really? It let me do that?
14:43:14 <Zekka> > id3 1
14:43:15 <lambdabot>  Could not deduce (GHC.Base.Functor L.PearlyWhite)
14:43:15 <lambdabot>    arising from a use of ‘L.id3’
14:43:15 <lambdabot>  from the context (GHC.Num.Num a)
14:43:16 <HeladoDeBrownie> neuroserpens, especially nice, in my opinion, is lambda case, enabled with the LambdaCase extension in ghc
14:43:19 <Zekka> Oh, there
14:43:35 <neuroserpens> HeladoDeBrownie: That I don't know yet, so you lost me :p
14:43:41 <ReinH> Aruro: Let's be clear here. There is a function named (*). This has absolutely nothing to do with the * you see here:
14:43:43 <ReinH> :k forall r. ((->) r)
14:43:44 <lambdabot> * -> *
14:43:52 <ReinH> These two * are completely unrelated
14:43:56 <neuroserpens> ReinH HeladoDeBrownie thanks for clarifying it
14:43:57 <Zekka> Let's talk about join (+) instead of join (*)
14:44:04 <Zekka> join (+) == \x -> x + x
14:44:04 <ReinH> Seems good.
14:44:11 <Aruro> ReinH i understood it long time ago
14:44:22 <Aruro> we can use join (+) example for clarity
14:44:33 <Aruro> > join (+) 5
14:44:34 <lambdabot>  10
14:44:39 <HeladoDeBrownie> neuroserpens, https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase
14:44:51 <EvanR> :t join (+)
14:44:52 <lambdabot> Num a => a -> a
14:44:55 <EvanR> :t join
14:44:56 <lambdabot> Monad m => m (m a) -> m a
14:44:59 <Zekka> ReinH: By the way, see the updated lpaste, the behavior of constraints like that is a little more interesting than If igured
14:45:00 <EvanR> what
14:45:00 <Aruro> yes
14:45:12 <ReinH> Zekka: which lpaste?
14:45:18 <Zekka> ReinH: http://lpaste.net/117390
14:45:20 <Aruro> Zekka
14:45:21 <Zekka> I already loaded it
14:45:24 <Zekka> > id2 1
14:45:26 <lambdabot>  1
14:45:27 <Zekka> > id3 1
14:45:28 <lambdabot>  Could not deduce (GHC.Base.Functor L.PearlyWhite)
14:45:28 <lambdabot>    arising from a use of ‘L.id3’
14:45:28 <lambdabot>  from the context (GHC.Num.Num a)
14:45:28 <HeladoDeBrownie> neuroserpens, i may even be weird but i often actively avoid using multiple clauses of a declaration in favor of case
14:45:28 <Aruro> tell truth no need ot lpaste
14:45:45 <Aruro> join (+)  is very simple
14:45:48 <Aruro> and type is easy
14:45:54 <Aruro> no need of struggle
14:45:57 <ReinH> Zekka: interesting
14:45:57 * hackagebot amazonka-directconnect 0.1.2 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.1.2 (BrendanHay)
14:45:59 <quchen> neuroserpens: Pattern matching in function definitions is translated to case expressions by the compiler. Also, case expressions allow you to match only on a subset of a function's variables, like in http://lpaste.net/117392, which is much less noisy.
14:45:59 * hackagebot amazonka-dynamodb 0.1.2 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.1.2 (BrendanHay)
14:46:01 <Aruro> where is m in (+)
14:46:01 * hackagebot amazonka-emr 0.1.2 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.1.2 (BrendanHay)
14:46:03 * hackagebot amazonka-iam 0.1.2 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.1.2 (BrendanHay)
14:46:05 * hackagebot amazonka-importexport 0.1.2 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.1.2 (BrendanHay)
14:46:11 <ReinH> Aruro: There is no m in (+)
14:46:13 <Zekka> ReinH: So it compiles, the constraint check just  fails every time you call it
14:46:24 <Zekka> Aruro: Look at the type of (+)
14:46:25 <Zekka> :t (+)
14:46:26 <ReinH> Zekka: fair enough
14:46:26 <Aruro> so how join works on it then?
14:46:26 <lambdabot> Num a => a -> a -> a
14:46:48 <Zekka> That's ((->) a ((->) a a))
14:46:56 <ReinH> Aruro: functions are values of type a -> b
14:47:10 <Zekka> So it has two ((->) a)s on top of it: the m is ((->) a)
14:47:14 <ReinH> Aruro: Another way of saying this is that they are values of type ((->) a b)
14:47:36 <ReinH> ((->) a) is an instance of Monad
14:47:49 <Aruro> man
14:47:52 <Aruro> i did it :)
14:47:57 <Aruro> finally i got it out of you :D
14:48:00 <ReinH> So functions are an instance of Monad
14:48:01 <Zekka> (the boilerplate part of the Monad definition having been given here for you: http://lpaste.net/117385 )
14:48:10 <Aruro> so m is ((->) a)
14:48:19 <ReinH> Aruro: Right.
14:49:17 <Aruro> so a->a is ((->) a ) a ?
14:49:25 <Aruro> something like this?
14:49:26 <Zekka> Aruro: Yeah
14:49:30 <Aruro> ufff
14:49:36 <ReinH> so join :: m (m b) -> m b, and for functions you replace m with ((->) a)
14:49:51 <Aruro> ooook
14:49:59 <Aruro> sounds good
14:50:43 <ReinH> so m (m a) -> m b ~ ((->) a ((->) a) b) -> ((->) a b), which can be written in infix as (a -> a -> b) -> (a -> b)
14:50:55 <ReinH> er, m (m b) -> m b
14:51:01 <Aruro> yeah :)
14:51:07 * hackagebot amazonka-kinesis 0.1.2 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.1.2 (BrendanHay)
14:51:09 * hackagebot amazonka-kms 0.1.2 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.1.2 (BrendanHay)
14:51:11 * hackagebot amazonka-lambda 0.1.2 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.1.2 (BrendanHay)
14:51:12 <Aruro> i was typing that monster :)
14:51:13 * hackagebot amazonka-opsworks 0.1.2 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.1.2 (BrendanHay)
14:51:15 * hackagebot amazonka-rds 0.1.2 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.1.2 (BrendanHay)
14:51:37 <Aruro> so there is prefix form of a->b->c
14:51:39 <ReinH> And in fact there is only one defined inhabitant of that type, which is the definition of join:
14:51:39 <Aruro> interesting
14:51:44 <ReinH> @djin (a -> a -> b) -> (a -> b)
14:51:44 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
14:51:49 <ReinH> @djinn (a -> a -> b) -> (a -> b)
14:51:49 <lambdabot> f a b = a b b
14:52:03 <ReinH> the definition of join for the ((->) a) instance, that is
14:52:32 <Aruro> so in a sense join operates on types?
14:52:36 <Aruro> not values?
14:52:39 <Zekka> Aruro: No, it operates on values
14:52:40 <Zekka> it's a function
14:52:48 <Aruro> hm
14:52:58 <Aruro> im close to see it right
14:52:58 <ReinH> The join function operates on values.
14:53:16 <Aruro> so when ((->) a) becomes value?
14:53:25 <ReinH> Aruro: It never becomes a value.
14:53:27 <Zekka> It doesn't, that's a part of its type
14:53:47 <Aruro> and we are back square one :D
14:53:58 <ReinH> Types don't "become values".
14:54:11 <ReinH> Types may be inhabited by values
14:54:12 <catery> So I am trying to understand the point of continuations, is there like an article that explain why parsers really need coroutines so that would give a strong reason for using continuations
14:55:09 <bennofs> catery: one reason is iirc that continuations are compiled to fairly efficient code by GHC
14:55:20 <Aruro> in case of join (+) 2
14:55:29 <Aruro> (+) is a value
14:55:31 <Aruro> we agreed on that
14:55:36 <Zekka> (+) is always a value
14:55:36 <Aruro> yes?
14:55:40 <Aruro> ok
14:55:41 <catery> but when do you actuallyt need continuations?
14:55:44 <Aruro> so it has type ma
14:55:49 <Aruro> or m m a
14:55:51 <Zekka> No, it has type m (m a)
14:55:55 <Aruro> yes
14:56:00 <Aruro> what is a?
14:56:12 <Zekka> It's some numeric type
14:56:18 * hackagebot amazonka-redshift 0.1.2 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.1.2 (BrendanHay)
14:56:20 * hackagebot amazonka-route53 0.1.2 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.1.2 (BrendanHay)
14:56:20 <Aruro> we understood that m is ((->) a)
14:56:22 * hackagebot amazonka-route53-domains 0.1.2 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.1.2 (BrendanHay)
14:56:24 * hackagebot amazonka-s3 0.1.2 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.1.2 (BrendanHay)
14:56:26 * hackagebot amazonka-sdb 0.1.2 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.1.2 (BrendanHay)
14:56:26 <Zekka> Num a => a
14:56:59 <Zekka> But that's not saying the whole story, of course, because we can't place the forall
14:57:04 <Zekka> But it's probably good enough for informal talk
14:58:24 <pavonia> Aruro: join works on all functions of type (a -> a -> b), no matter what a and b are
14:58:25 <Aruro> can we call  (->) a , TO a for simplicity?
14:58:43 <Aruro> yes that i know
14:58:48 <Zekka> Aruro: I don't see why it helps, but why not call it Reader if you insist on renaming it?
14:59:05 <Aruro> because i want to couple it to function
14:59:07 <Aruro> definition
14:59:08 <Zekka> Reader is a newtype over it
14:59:21 <Zekka> I guess we can use To if we don't have the newtype
14:59:36 <Aruro> so we have (a TO a)
14:59:43 <Zekka> Let's follow the rules of syntax. That makes type To a b = a -> b
14:59:44 <Aruro> where TO a is some sort of monad
14:59:49 <EvanR> a `TO` a
14:59:50 <Aruro> yyes
14:59:55 <Aruro> yes
14:59:59 <Aruro> easier totalk
15:00:21 <pavonia> It's not easier, it's just confusing even more
15:00:26 <Aruro> yes
15:00:31 <Aruro> actually you are right
15:00:36 <Aruro> what is easier?
15:00:44 <Zekka> Let's just use its actual name, (->)
15:00:45 <pavonia> Stick with Haskell syntax
15:00:51 <EvanR> a -> b is a type
15:01:22 <trap_exit> who invented parsec
15:01:24 <EvanR> (a ->) is the same as ((->) a) ?
15:01:28 * hackagebot amazonka-ses 0.1.2 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.1.2 (BrendanHay)
15:01:30 * hackagebot amazonka-sns 0.1.2 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.1.2 (BrendanHay)
15:01:32 * hackagebot amazonka-sqs 0.1.2 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.1.2 (BrendanHay)
15:01:34 * hackagebot amazonka-storagegateway 0.1.2 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.1.2 (BrendanHay)
15:01:34 <trap_exit> where does the theory for parsec come from?
15:01:36 * hackagebot amazonka-sts 0.1.2 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.1.2 (BrendanHay)
15:02:04 <simon> I'm sort of copy-pasting an example using the Scotty server, but it gives me: No instance for (ScottyError Text) arising from a use of ‘get’
15:02:07 <EvanR> trap_exit: aol keyword is monadic parser combinators
15:02:16 <Aruro> so i think now im confused between the type definition of function and its realization
15:02:30 <trap_exit> EvanR: tell me about the dinosaurs
15:02:37 <Zekka> Aruro: I think you've been confused about that this entire time and I don't know how to help
15:02:45 <Aruro> we have a->a->b for (+) but at the end it will get to the realization of (+)
15:02:57 <Zekka> Aruro: What does that mean?
15:03:00 <simon> https://gist.github.com/sshine/6441d212a152a608ebaa -- here is the (somewhat small) context
15:03:14 <Aruro> imthinking what does that mean
15:03:28 <Aruro> ok
15:03:34 <Aruro> join does not care about realization
15:03:43 <Aruro> so it will work on all two argument functions
15:03:50 <Zekka> join only knows that it gets an (a -> a -> b) and has to give you a (a -> b)
15:03:53 <Aruro> it means it operates on something else
15:03:59 <Aruro> on arguments themself
15:04:00 <Zekka> Aruro: All two-argument functions where the arguments have the same type
15:04:24 <Aruro> so arguments themself form a VALUE we can say
15:04:34 <Aruro> and that is what you called reader monad?
15:04:45 <Zekka> Aruro: ((a) ->) is the Reader monad minus newtype
15:04:50 <Zekka> Reader is a newtype for (->)
15:06:38 * hackagebot amazonka-support 0.1.2 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.1.2 (BrendanHay)
15:06:40 * hackagebot amazonka-swf 0.1.2 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.1.2 (BrendanHay)
15:06:42 * hackagebot ChasingBottoms 1.3.0.9 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.9 (NilsAndersDanielsson)
15:12:18 <Aruro> here http://www.reddit.com/r/haskell/comments/1olk04/the_magic_of_join/
15:12:25 <Aruro> something we talked about
15:13:44 <Zekka> Aruro: I don't know what has you confused but if I had to guess it probably has something to do with not knowing Haskell very well
15:13:59 <Zekka> I would really recommend filling out the definitions I gave you and referring to whatever reference you were learning it from (or possibly a different one)
15:14:32 <Aruro> well knowing haskell well is all we were trying to do :)
15:14:36 <Aruro> nothing more nothing less
15:14:46 <Zekka> Aruro: I mean that you have to crawl before you can walk
15:14:56 <Aruro> i can walk :)
15:14:58 <Zekka> I think it's likely you don't understand what types are very well
15:15:30 <Aruro> very well is very ambiguous statement
15:15:41 <Aruro> i undestand on the level which got me thinking
15:15:51 <Zekka> Aruro: You seem to think a function can operate on types as if they were values in Haskell, which it can't really do
15:15:51 <Aruro> about unnaturalness of join (+)
15:15:57 <Zekka> You also seem to confuse types with expressions
15:16:04 <Zekka> I don't know how I can make this clearer to you
15:16:21 <Aruro> u made quite clear
15:16:30 <Aruro> up to know i think i got it
15:16:41 <Aruro> now*
15:17:07 <matheus23> I have a small problem with Imports in haskell. does anyone know a quick solution to this problem? (while not renaming the functions "move" or "atop")? http://lpaste.net/117393
15:17:33 <barrucadu> matheus23: import qualified Foo as Foo
15:17:43 <barrucadu> Then refer to Foo.bar
15:18:35 <matheus23> barrucadu: ok thanks! Yes. That's what we've come up with: import qualified Foo as Foo and import Foo (Foo) (the type)
15:18:49 <barrucadu> Yeah, that's quite common
15:19:13 <Aruro> you say a->b can be written as  (->) a b
15:19:24 <Aruro> can u use it prefix to define something?
15:19:31 <Zekka> Aruro: Yeah, you can always use it prefix
15:20:29 * hackagebot constraints 0.4.1.2 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.4.1.2 (EdwardKmett)
15:22:39 * EvanR grumbles about infinite loops
15:24:34 <yitz> > fix ("grumble " ++)
15:24:35 <lambdabot>  "grumble grumble grumble grumble grumble grumble grumble grumble grumble gru...
15:24:47 <simon> oh gah.
15:27:17 <ReinH> Aruro: "to define something"?
15:29:15 <simon> it seems that scotty depends on text-1.1.1.3 and that I've got text-1.2.0.0. I'm not sure how cabal allowed that, but it seems I get these warnings about instances for Text match the wrong module version.
15:29:15 <orion> Is it possible to declare a type within a record?
15:29:46 <HeladoDeBrownie> orion, data/newtype declarations all must be top-level
15:29:54 <HeladoDeBrownie> type declarations are usually only top-level
15:30:29 * hackagebot tofromxml 0.1.0.0 - Reading/writing Haskell data from/to XML  http://hackage.haskell.org/package/tofromxml-0.1.0.0 (threetee)
15:30:41 <simon> I think one of the most complicated parts of working with haskell is figuring out why different packages are incompatible with each other and how to best deal with that.
15:32:05 <ReinH> simon: what sort of warning?
15:34:36 <ReinH> ocharles_: my god, 24 days of doge, I didn't even realize. Such wow.
15:34:54 <simon> ReinH, https://gist.github.com/sshine/95db296555be72693382
15:34:55 <ocharles_> ReinH: I was so happy when I first had to write the abbreviation
15:35:04 <ReinH> ocharles_: <3
15:35:06 <ocharles_> ReinH: "Today in 24 DO... OMG REALLY?"
15:35:30 <ReinH> simon: Are you using cabal?
15:35:33 <simon> ReinH, yes.
15:36:05 <ReinH> simon: huh
15:36:08 <simon> ReinH, it seems that the latest scotty server gladly accepts text (>=0.11.3.1 && <1.3) according to http://hackage.haskell.org/package/scotty , but then why this occurs, I don't know. I've got text-1.2.0.0 installed.
15:36:41 <flaggy> I've learned that if a guy named simon is having trouble with haskell, then it must be serious trouble.
15:36:48 <sshine> :)
15:37:26 <ReinH> That... shouldn't happen...
15:38:08 <sshine> oh god... I need new cooling paste if I need to recompile cabal packages from scratch once more.
15:38:37 <flaggy> simon: check if you have 1.1.1.3 installed as well
15:39:56 <flaggy> with cabal list --installed you can see all versions of a package which are installed. Maybe if you remove text 1.1.1.3 it will work
15:40:15 <sshine> flaggy, I have. how do I best remove it? simply relocating ~/.cabal/lib/x86_64-linux-ghc-7.8.3/text-1.1.1.3 does not seem sufficient.
15:41:24 <sshine> ghc-pkg unregister?
15:42:52 <sshine> ah, hrm... even though I have text-1.2.0.0, it seems that scotty depends on text-1.1.1.3. perhaps this is because I had the old one before installing scotty and then installed a new one.
15:43:04 <flaggy> yeah, try ghc-pkg unregister
15:43:12 <flaggy> hm
15:43:26 <sshine> ReinH, by "Are you using cabal?" I should probably say that my own project is not under cabal control.
15:43:43 <ReinH> sshine: Ah. You should probably do that.
15:43:55 <ReinH> Since it should prevent exactly this issue.
15:44:26 <flaggy> yeah, that'd be a good idea, instead of globally installing cabal package (even if only global for an user :P)
15:44:34 <sshine> because when I build it using my own foo.cabal file, it'll just grab whatever version I ask it to?
15:45:39 <flaggy> if you do cabal install in a directory with a .cabal file it should know what to do
15:45:56 <flaggy> then you can use cabal build and cabal run to run it
15:46:15 <dfeuer> Arright, anyone want to help shave a couple tenths of a microsecond off a benchmark time? I'm trying to make types nicer, but I don't want to mess up performance if I can avoid it.
15:46:18 <flaggy> a project.cabal file, that is
15:46:31 <dfeuer> There's also one function that's just UGLY.
15:47:00 <sshine> flaggy, ReinH: thanks for the tip.
15:49:08 <kaiyin> > map (+1) [1, 2, 3]
15:49:09 <lambdabot>  [2,3,4]
15:49:21 <kaiyin> > concat (map (+1) [1, 2, 3])
15:49:23 <lambdabot>  No instance for (GHC.Show.Show a0)
15:49:23 <lambdabot>    arising from a use of ‘M2326132150381171098596.show_M2326132150381171098596’
15:49:23 <lambdabot>  The type variable ‘a0’ is ambiguous
15:49:55 <kaiyin> The bind function of [] is implemented as this: The bind function    xs >>= f = concat (map f xs)
15:50:03 <kaiyin> and it clearly isn't working here?
15:50:11 <EvanR> concat takes a list of lists
15:50:39 <EvanR> in the monad, f returns a list
15:51:19 <kaiyin> oh, I see.
15:56:15 <kaiyin> > [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
15:56:16 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
15:56:42 <kaiyin> How does it remember that the first "a" is with 1 and the second "a" is with 2?
15:58:39 <sai^_^> what does the  HiddenServiceDir and  HiddenServicePort confi options actually do?
15:58:54 <sai^_^> like could i connect to my current TOR ip to reach my web server?
15:59:03 <sai^_^> shit wrong window
16:00:15 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch -> return [(n,ch)])
16:00:16 <lambdabot>  [[(1,'a')],[(1,'b')],[(2,'a')],[(2,'b')]]
16:02:24 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch -> return (n,ch))
16:02:25 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
16:03:00 <kaiyin> Why does this even work? \ch -> (n, ch) does not return a list.
16:03:47 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch -> return [n,ch])
16:03:48 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
16:03:49 <lambdabot>    arising from the literal ‘1’
16:04:11 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch ->  [n,ch])
16:04:12 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
16:04:12 <lambdabot>    arising from the literal ‘1’
16:04:43 <hegel> gen_id = lambda charset='abcdef0123456789': \
16:04:49 <hegel>         (lambda *_: ''.join(map(lambda x: ''.join(x), _)))(
16:04:55 <hegel>        *(lambda *_: map(lambda x: (x[0], x[1][0], x[1][1]), _))(
16:05:03 <hegel>        *(lambda seed, charset_ext: zip(seed, map(lambda idx: (charset_ext[idx], charset_ext[-idx]), map(int, seed))))(
16:05:09 <hegel>        *(datetime.now().strftime('%f'), charset+charset.upper()[::-1]))))
16:05:22 <yitz> kaiyin: but \ch -> return (n, ch) *does* return a list.
16:05:50 <kaiyin> yitz, yeah, now I see, return is  \a -> m a
16:06:00 <kaiyin> :t return
16:06:01 <lambdabot> Monad m => a -> m a
16:06:21 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch ->  [n,ch])
16:06:22 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
16:06:22 <lambdabot>    arising from the literal ‘1’
16:06:23 <kaiyin> W
16:06:39 <kaiyin> But the above should work the same way?
16:07:56 <yitz> kaiyin: n comes from a numeric literal, ch from a Char literal
16:08:15 <zq> lambdabot: @pl \n f v -> foldl' (>>=) (return v) $ replicate n f
16:08:15 <lambdabot> (flip (foldl' (>>=) . return) .) . replicate
16:08:26 <kaiyin> > [1,2] >>= \n -> (['a','b'] >>= \ch ->  [(n,ch)])
16:08:28 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
16:08:54 <kaiyin> yitz, I see, all elements of a list must be of the same type.
16:09:02 <yitz> yes
16:09:32 <Aruro> you can make multi type lists
16:09:41 <Aruro> if you incorporate them in a bigger type
16:09:53 <Aruro> this way it will be still one type
16:10:01 <Aruro> but it can have int string whatever you want
16:10:20 <Aruro> so the resulting list can have arbitrary amount of "different" information
16:12:30 <dhrosa> there's three ways I know of to have lists of "different" type elements. You could make a sum type (a single type with multiple constructors). You could use existential qualification to make a list of values from a certain typeclass, or there's also some magical heterogeneous list library that I don't understand
16:14:03 <Adeon> fourth way: you can have a list of Dynamics (Data.Dynamic) and then dynamically pull values out of it
16:14:59 <dhrosa> or if your list is of fixed length and you know a certain type will always be at a certain index... that's just a tuple :p
16:15:19 <EvanR> similar to the existential + typeclass, you can form a list of records of operations youd want to do over the different types, with the value itself closed over and hidden
16:17:27 <dfeuer> bitemyapp, I'm still having trouble. Take a look at the "rigidify" function in https://github.com/treeowl/containers/blob/apstupidtypes/Data/Sequence.hs and see what a horrible mess it is. It actually calls itself, but at most once, which is particularly disgusting.
16:17:52 <benzrf> @let newtype CatMon k a b = CatMon {unCM :: k a b}
16:17:54 <lambdabot>  Defined.
16:18:34 <benzrf> @let instance Category k => Monoid (k a a) where mempty = CatMon C.id; mappend (CatMon f) (CatMon g) = CatMon (f C.. g)
16:18:35 <lambdabot>  .L.hs:164:18:
16:18:35 <lambdabot>      Could not deduce (k2 ~ CatMon k0)
16:18:35 <lambdabot>      from the context (Category k2)
16:18:43 <benzrf> huh??
16:19:16 <benzrf> oh crud
16:19:21 <benzrf> @let instance Category k => Monoid (CatMon k a a) where mempty = CatMon C.id; mappend (CatMon f) (CatMon g) = CatMon (f C.. g)
16:19:22 <lambdabot>  Defined.
16:19:34 <benzrf> zq: now you can mconcat your kleisli arrows B)
16:20:05 <benzrf> foldMap (CatMon . Kleisli) someArrows
16:20:10 <benzrf> or uh something
16:20:17 <bitemyapp> dfeuer: hrm
16:20:31 * hackagebot shell-monad 0.6.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.0 (JoeyHess)
16:20:37 <bitemyapp> dfeuer: why do we need rigidification of finger trees?
16:21:51 <dfeuer> bitemyapp, because what I'm calling a "rigid" finger tree is a bona fide 2-3 finger tree, as opposed to one with extra flexibility. I can "zip up" a rigid tree to make a 2-3 tree.
16:22:03 <dfeuer> And that's pretty much essential to the algorithm.
16:22:18 <dfeuer> (zip up/squash down, whatever)
16:24:19 <joshcough> can anyone tell me how to control what is automatically imported when i run 'cabal repl'
16:24:34 <bitemyapp> dfeuer: what algorithm?
16:25:15 <dfeuer> bitemyapp, it's all for implementing <*>
16:25:28 <bitemyapp> dfeuer: for finger tree or something else?
16:25:52 <dfeuer> bitemyapp, for Data.Sequence.Seq, which is based on finger trees.
16:26:30 <bitemyapp> okay, I knew it was based on finger trees, just wasn't sure if it was the Seq stuff you were doing or not.
16:27:03 <kaiyin> > [1,2] >>= \x -> [3,4] >>= \y -> return x*y
16:27:05 <lambdabot>  No instance for (GHC.Show.Show b0)
16:27:05 <lambdabot>    arising from a use of ‘M12580402375786546949260.show_M12580402375786546949...
16:27:05 <lambdabot>  The type variable ‘b0’ is ambiguous
16:27:52 <kaiyin> Why doesn't this work?
16:29:27 <kaiyin> > [1,2] >>= \x -> [3,4] >>= \y -> return x+y
16:29:28 <lambdabot>  No instance for (GHC.Show.Show b0)
16:29:29 <lambdabot>    arising from a use of ‘M70089802003518957609313.show_M70089802003518957609...
16:29:29 <lambdabot>  The type variable ‘b0’ is ambiguous
16:29:51 <kaiyin> > [1,2] >>= \x -> [3,4] >>= \y -> return x+y :: [Int]
16:29:52 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
16:29:52 <lambdabot>    arising from the literal ‘3’
16:30:31 * hackagebot tofromxml 0.1.0.1 - Reading and writing Haskell data from and to XML  http://hackage.haskell.org/package/tofromxml-0.1.0.1 (threetee)
16:31:13 <ahihi> kaiyin: return x+y is parsed as (return x) + y, you want return (x+y)
16:31:36 <hexagoxel> joshcough: you can `cabal exec -- ghci -l stuff-that-i-want` or something in that direction
16:31:52 <kaiyin> > [1,2] >>= \x -> [3,4] >>= \y -> return (x+y)
16:31:54 <lambdabot>  [4,5,5,6]
16:32:01 <kaiyin> cool, thanks, ahihi
16:32:02 <hexagoxel> (presuming your repl is ghci)
16:32:35 <joshcough> hexagoxel: but, now way to set it by default in your cabal file? it seems to just pick a random module from my library to import by default right now
16:32:43 <joshcough> no*
16:33:42 <hexagoxel> hmm no, i don't know a way for that. you can specify the component to load though, iirc
16:34:55 <hexagoxel> joshcough: you just have one library in the package?
16:35:32 * hackagebot tofromxml 0.1.0.2 - Reading and writing Haskell data from and to XML  http://hackage.haskell.org/package/tofromxml-0.1.0.2 (threetee)
16:36:45 <joshcough> i think you can only have one library per cabal file, no? (but several executables), but, when i run cabal repl it picks a single module to import automatically, as if i ran :load X.Y.Module on it
16:39:01 <hiptobecubic> What's up with this crazy ass type signature that ghc-mod suggested, which doesn't even work without flexiblecontexts and kindsignatures and rankntypes and all manner of other dark portals? http://vpaste.net/lOHT0
16:40:46 <hexagoxel> joshcough: doesn't it pick the first by the order in the exposed-modules list (or other-modules, or something)?
16:41:25 <joshcough> hexagoxel: ah. that might be all it is. i'll tinker with that. thank you
16:41:59 <joshcough> i'm pretty sure you're correct. thank you.
16:42:00 <hexagoxel> joshcough: it seems to be first of exposed-modules; other-modules get ignored
16:42:04 <godel> If I have an Array, is there an O(1) way to get other Array with a value changed?
16:42:06 <joshcough> yes.
16:42:08 <godel> something like update
16:42:10 <hexagoxel> np
16:43:30 <EvanR> godel: using STArrays
16:43:31 <k00mi> godel: not with an immutable array
16:43:50 <godel> EvanR: is that in the standard library?
16:43:52 <EvanR> or mutable arrays in general
16:44:08 <EvanR> yes
16:45:06 <EvanR> heres all the arrays https://www.haskell.org/haskellwiki/Arrays
16:45:19 <godel> EvanR: they are not well documented
16:45:29 <godel> imo
16:46:46 <EvanR> yeah, theres another listing of the differences between arrays floating around..
16:47:18 <idnar> I have a question (mostly) about conduit, are there any combinators I could use to write http://lpaste.net/117394 more simply?
16:48:19 <idnar> oh, I guess I could have used forever instead of the loop construction
16:50:56 <EvanR> Comonad requires Functor, but what about Coapplicative?
16:51:01 <guesting> I'm a little confused on how to "loop" functions over monads. That is, I have two functions, (a -> m [b]) and (a -> m b) and I essentially want to connect the first with the second. That is, some form of result <- mapM (f1 . f2) xs, where xs = [stuff]. f2 xs returns IO ys and f1 should go over each element in ys and return some z, returning [[z]]. But the monad loops are confusing me on how to get it out of the IO monad
16:51:11 <benzrf> EvanR: im not sure coap is even a thing
16:51:33 <benzrf> guesting you can't compose those
16:52:00 <benzrf> guesting: a -> b and a -> [b] do not compose
16:52:13 <dhrosa> gienah: you never get stuff out of the IO monad
16:52:38 <dhrosa> guesting: perhaps you want (f1 =<< f2) instead of f1 . f2?
16:52:43 <dhrosa> f1 and f2 can't compose normally
16:52:54 <dhrosa> err both of those were meant for guesting
16:54:12 <dhrosa> I've become obsessed with =<< over >>= recently, probably becuse it's the same order as normal function composition
16:54:12 <guesting> hm
16:57:02 <guesting> dhrosa: Yes, closer, but I need to map over the list. f2 works on each element in f1
16:57:21 <guesting> dhrosa: Maybe I should use the opposite of sequence?
16:57:38 <EvanR> coap :: (f a -> f b) -> f (a -> b)
16:58:06 <guesting> dhrosa: sequenceA
16:59:18 <DSALNASS> My computer isn't finding my chromecast
16:59:39 <dhrosa> sounds like a #haskell problem alright
16:59:40 <guesting> dhrosa: Wait, not sequenceA as thats for applicatives obviously
17:00:01 <dhrosa> your chromecast wouldn't be lost if its position were a pure function
17:00:34 <Romefeller> Hey guys anyone knows this error: Could not find module `Control.Comonad'
17:01:08 <Romefeller> I want use Comonads, but im getting that error
17:01:15 <dhrosa> install the comonad package?
17:01:59 <Romefeller> its a package
17:02:02 <hexagoxel> add the comonad package to your Build-Depends?
17:02:02 <Romefeller> =\
17:02:08 <Romefeller> no
17:02:14 <Romefeller> i will do that thx
17:03:29 <manek> hi! Just a small question here: how would you name a module that delivers you the top-level monad your system is run with? Something like ghc monad
17:04:58 <pavonia> TopLevelMonad?
17:05:02 <dhrosa> the top-level monad?
17:06:59 <fizbin> Hey, I'm trying to solve a problem that's essentially like this: http://lpaste.net/117395 (I need to figure out computeInstructions). Any hints as to what the standard name of this kind of problem is?
17:07:12 <fizbin> I basically am unclear on what to Google...
17:07:18 <dhrosa> oo I wrote something extremely similar to that
17:07:28 <dhrosa> making an AVR (8-bit microocontroller simulator) in haskel
17:07:57 <dhrosa> fizbin: are you trying to read instructions from a "memory"?
17:08:05 <fizbin> Right, except I have to do the hard part, the part that figures out what instructions yield a desired end state.
17:08:58 <dhrosa> fizbin: what is computeInstructions supposed to do
17:09:06 <flebron> If I have an Int, is there a better way to xor all its bits together than (== 0) . (.&. 1) . popCount?
17:10:06 <dhrosa> could probably use its Bits instance to get a list of bits and fold over XOR
17:10:20 <fizbin> I'm trying to come up with something that, when you say "I want the stuff that's in memory slot 1 to go to memory slots 0 and 2, and I want the stuff that's in slot 0 to go into slot 1", figures out "first copy slot 1 to slot 2, then copy 0 to 1, then copy 2 to 0"
17:10:33 <EvanR> flebron: you can just use xor on the int
17:10:35 <EvanR> :t xor
17:10:36 <lambdabot> Bits a => a -> a -> a
17:10:56 <EvanR> > 123 `xor` 321
17:10:57 <dhrosa> he wants the bits XOR'd together I think, not to another in
17:10:57 <lambdabot>  314
17:11:07 <flebron> Yes, xor all the bits together.
17:11:07 <fizbin> flebron: For a specific bit size, there's a faster solution.
17:11:14 <EvanR> > let x = 123 in x `xor` x
17:11:16 <lambdabot>  0
17:12:03 <dhrosa> you guys are xoring an int with itself, he wants to xor the bits to eachother
17:12:10 <dhrosa> or she, or it
17:12:15 <zq> .msg lambdabot hi
17:12:45 <hexagoxel> > text "hi"
17:12:47 <lambdabot>  hi
17:13:41 <Zemyla> :t cast
17:13:42 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
17:13:50 <EvanR> xor all the bits together
17:13:58 <EvanR> isnt that a function of the number of 1 bits
17:14:36 <fizbin> flebron: So if you don't have an Int, but a Word8 you could do: let x1 x = 1 .&. (x `xor` (x `shift` -1)); x2 x = x1 $ (x `xor` (x `shift -2)); x4 x = x2 $ (x `xor` (x `shift` -4)) in x4
17:14:38 <flebron> EvanR: It's the parity of the number of 1 bits. That's what I wrote above.
17:14:51 <EvanR> yeah, theres fast ways to count the 1 bits
17:15:01 <fizbin> let x1 x = 1 .&. (x `xor` (x `shift` -1)); x2 x = x1 $ (x `xor` (x `shift -2)); x4 x = x2 $ (x `xor` (x `shift` -4)) in x4 (35 :: Word8)
17:15:14 <fizbin> > let x1 x = 1 .&. (x `xor` (x `shift` -1)); x2 x = x1 $ (x `xor` (x `shift -2)); x4 x = x2 $ (x `xor` (x `shift` -4)) in x4 (35 :: Word8)
17:15:16 <lambdabot>  <hint>:1:75: parse error on input ‘-’
17:15:41 <pavonia> fizbin: Do all these copy instructions in [Word16] have to happen at the same time?
17:15:42 <EvanR> https://graphics.stanford.edu/~seander/bithacks.html "counting bit sets"
17:16:16 <fizbin> pavonia: The point is that they don't happen at the same time - processInstructions processes them sequentially.
17:16:31 <fizbin> So the order of the list computeInstructions comes up with matters.
17:18:00 <Zemyla> Hmm. Constraint witnesses satisfy a monoid structure, right?
17:19:12 <benzrf> Zemyla: how so
17:19:20 <benzrf> Zemyla: you mean like (C, C)?
17:19:21 <benzrf> er
17:19:27 <benzrf> (C a, D b)
17:20:10 <joshcough> i have another ghci/cabal repl question. when i manually import a bunch of modules, my prompt gets really long (showing all those modules). is there any way to shrink it back down?
17:20:38 <pavonia> fizbin: But how do you know when you are able to overwrite a slot's value and when not? I'm asking because in your example you first have to safe the value from slot 0 to slot 2
17:20:54 <fizbin> > let x1 x = 1 .&. (x `xor` (x `shiftR` 1)); x2 x = x1 $ (x `xor` (x `shiftR` 2)); x4 x = x2 $ (x `xor` (x `shiftR` 4)) in x4 (32 :: Word8)
17:20:55 <lambdabot>  1
17:21:28 <fizbin> flebron: ^^^ That's a version that works for Word8. You should easily see how to extend it to Word16, 32, 64...
17:21:59 <flebron> fizbin: And that's likely to be faster than popcnt and &1?
17:23:02 <fizbin> pavonia: That's exactly my problem. I need to be able to figure that out. In my example, I'd feed computeInstructions [1, 0, 1] and it would conclude [Copy 1 2, Copy 0 1, Copy 2 0]
17:23:22 <dhrosa> which package uploads does the bot broadcast?
17:23:32 <fizbin> flebron: Slightly faster on Word8, much faster by the time you get to Word64.
17:24:28 <fizbin> flebron: Look at it this way: my solution does three xors and three shifts; popcnt on Word8 does eight shifts and eight xors.
17:25:04 <flebron> fizbin: Can't it just use the native popcnt instruction, at least on x86?
17:25:34 * hackagebot numericpeano 0.2.0.0 - Peano numbers with attendant bells and whistles.  http://hackage.haskell.org/package/numericpeano-0.2.0.0 (jtapolczai)
17:25:36 * hackagebot slack 0.1.0.0 - Haskell API for interacting with Slack  http://hackage.haskell.org/package/slack-0.1.0.0 (dhrosa)
17:25:39 <fizbin> Oh. Sure, if there's a native popCount.
17:25:53 <fizbin> Right, if you have popCount use that.
17:28:07 <fizbin> pavonia: See, as a human I can look at the list [1, 0, 1] and see "Ah, I'm going to step on slot 2 and need to use both 0 and 1, so let me do (Copy 1 2) first. Now, I need to get 0 to 1 and 1 to 0. I have this extra copy of 1 now hanging out in slot 2, so I can do (Copy 0 1) and then (Copy 2 0)"
17:28:22 <fizbin> pavonia: But I need to get the computer to have similar reasoning.
17:28:31 <fizbin> Or equivalent reasoning, I guess.
17:29:06 <pavonia> What does the encoding [1, 0, 1] mean?
17:29:32 <manek> pavonia, dhrosa : hmm, I was asking rather for module, not the monad name. And I'm sorry - I just provided to narrow information. The best name I just discovered is "Session". But thank you for your help! :))
17:30:11 <fizbin> pavonia: It means that when that sequence of instructions is finished, what was in slot "1" before the sequence is now in slots 0 and 2, and what was in slot "0" before the sequence is now in slot 1.
17:30:34 * hackagebot cassava-conduit 0.1.0 - Conduit interface for cassava package  http://hackage.haskell.org/package/cassava-conduit-0.1.0 (domdere)
17:31:10 <EvanR> flebron: your gpu may have a popcount ;)
17:31:19 <pavonia> fizbin: Okay, I thought it was a binary encoded list of instructions or so
17:31:58 <fizbin> pavonia: The specification for computeInstructions is basically "it passes testCI with any list of fewer than 100 items"
17:32:29 <fizbin> And, preferably, doesn't step on any memory it doesn't have to.
17:36:09 <pavonia> Hhm, tricky
17:36:48 <fizbin> Anyway, I'm really asking: what subfield of CS is this? Where do I even start looking for the kind of techniques that might tackle a problem like this?
17:37:19 <greymalkin> What tools are available to find infinite loops?
17:37:25 <fizbin> I get the feeling that people writing compilers must solve problems something like this, but what sub-field of compiler construction is thes?
17:37:55 <fizbin> greymalkin: Meaning, you suspect your program is going into an infinite loop but you don't know where?
17:38:14 <greymalkin> Yes.
17:40:05 <fizbin> greymalkin: I believe (but am not certain) that if you compile your program with -prof and hen run it with +RTS -xc, then when you press Ctrl-C you'll get something like a stack trace.
17:40:21 <pavonia> fizbin: I guess it's called scheduling
17:40:24 <EvanR> greymalkin: i am currently trying to understand an infinite loop by using ghci breakpoint and stepping
17:40:36 <EvanR> but im about to try profiling
17:41:04 <fizbin> Using the module Debug.Trace to spit stuff out while computing is also useful.
17:41:24 <SharpGAF> fizbin: Instruction scheduling, yeah.
17:42:57 <eyebloom> EvanR: I usually resort to just inserting trace statments.
17:43:38 <fizbin> Huh. I'm not sure that's the same thing. Instruction Scheduling seems mostly to involve identifying instruction chunks that can't be re-ordered, because they do stuff like touch the same memory.
17:44:10 <fizbin> But let me go read up on it and see if something tweaks.
17:44:27 <EvanR> so im getting a stack overflow, and the RTS -xc trick is telling me stack trace: Main.CAF
17:44:42 <EvanR> so if i have an infinite data structure as a caf, this is bad?
17:44:51 <SharpGAF> Well, register allocation tries to figure out an optimal way to use available slots
17:44:53 <EvanR> if i want to forget the parts as i go through it
17:44:56 <SharpGAF> That's basically graph coloring
17:45:15 <fizbin> EvanR: Only if something is accidentally trying to evaluate the whole structure.
17:45:42 <fizbin> But if you need chunks forgotten, a top-level CAF may not be what you want.
17:45:43 <SharpGAF> Instruction selection also usually involves doing per-architecture microoptimizations for recognized patterns (basically subgraph isomorphism)
17:45:57 <catery> Coroutines for streaming: what exactly does that mean and why are coroutines needed for that, trying to understand the big idea of these articles https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/coroutines-for-streaming
17:46:14 <SharpGAF> It's kinda hard to say "this subfield of compiler optimization" since it draws on a huge range of mathematics.
17:46:25 <Zemyla> Sorry, benzrf, back.
17:46:55 <EvanR> fizbin: yeah its like a stream
17:47:15 <EvanR> i moved the expression into a let binding inside main
17:47:31 <Zemyla> Like if I had data Witness a where { OrdW :: (Ord a) => Witness a; IdW :: Witness a }, then mempty = IdW, and OrdW `mappend` _ = OrdW, IdW `mappend` w = w.
17:47:32 <EvanR> and still got stack overflow: Main.CAF
17:48:48 <ski> Zemyla : interesting
17:49:19 <Zemyla> But actually, I had a different thought about monoids.
17:51:50 <Zemyla> sort ls = mconcat $ fmap Set.singleton ls, but the sort is only O(n log n) if the mconcat works a specific way.
17:55:19 <CoolGuyC> hey haskell. What is the tool stack you guys use? editor, IDE, compiler, testing suite, debugger. and all that stuff.
17:56:40 <Zemyla> CoolGuyC: (Just Vim, Nothing, Just GHC, Nothing, Just GHCi)
17:57:38 <n4x> quickcheck is nice
17:57:59 <sshine> CoolGuyC, (Either Vim Emacs, Nothing, Just GHC, Either HUnit QuickCheck, Just GHCi) :)
17:58:23 <CoolGuyC> woah. you guys don't use somethji glike Eclipse?
17:58:46 <n4x> Haskell doesn't really need a full IDE for being usable
17:59:04 <CoolGuyC> i use java
17:59:06 <sshine> yes, whenever I code Java. for Haskell I don't, although I've seen Eclipse and Haskell work somewhat nicely together.
17:59:56 <CoolGuyC> Java is object oriented. Does haskell have anything to keep up with Java's OOP?
18:02:11 <rhaps0dy> keep up with?
18:02:12 <rhaps0dy> lol
18:02:46 <eyebloom> CoolGuyC: Typeclasses and polymorphism.
18:02:53 <CoolGuyC> yeah. in java i can do Employee e = new Employee(); e.age = 19;  Can haskell do that?
18:02:57 <rhaps0dy> now that he kind of mentioned it
18:03:10 <rhaps0dy> does youcompleteme work with Haskell?
18:03:17 <sshine> CoolGuyC, well, I suppose Haskell has comonads. :) http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html -- this is a slightly trollish answer, though.
18:03:19 <eyebloom> CoolGuyC: yes
18:03:28 <bitonic> CoolGuyC: `let e = newEmployee in e{age = 19}'
18:03:31 <rhaps0dy> sshine: this is a totally troll question though
18:04:10 <sshine> oldmanmi1e, data Employee = Employee { age :: Int }  and newEmployee = Employee { age = 19 }
18:04:18 <CoolGuyC> bitonic: that looks weird. what is that apostrophe? `
18:04:33 <bitonic> CoolGuyC: ` and ' delimit the code that I type here
18:04:33 <EvanR> how does comonad satisfy this scenario
18:05:00 <sshine> EvanR, they don't. but they trollishly answer "Does Haskell have objects?"
18:05:23 <rhaps0dy> > I hope to show that you very likely already employ a comonadic programming style, although you probably prefer to call it "object-oriented programming".
18:05:24 <lambdabot>  <hint>:1:81: parse error on input ‘,’
18:06:13 <spopejoy> quick Lens ix q: how to access the LAST element? ie, view (ix 0) ["a","b","c"] returns "a"; any lensey way to get the last one ("c")?
18:06:13 <sshine> oldmanmi1e, whoops, sorry.
18:06:19 <eyebloom> CoolGuyC: It’s not a complete analog but haskell has record syntax which would allow you to assign a function to lookup a particular part of a data structure, an typeclasses that allow you to define functions that operate on various types of data.
18:06:29 <benzrf> spopejoy: probably ;)
18:06:33 <benzrf> :t _last
18:06:34 <lambdabot> (Snoc s s a a, Applicative f) => (a -> f a) -> s -> f s
18:06:35 <eyebloom> But starting with OOP ideas is not a good way to learn.
18:06:46 <benzrf> spopejoy: i cannot imagine that it is efficient
18:07:09 <benzrf> > [1, 2, 3] & _last%~(+1)
18:07:10 <spopejoy> yeah, but neither would my length calculation be
18:07:10 <lambdabot>  [1,2,4]
18:07:13 <EvanR> typeclasses shouldnt be confused with oop classes or oop
18:07:22 <CoolGuyC> eyebloom: i thought OOP was the modern way of programming? and functional was for old people doing fortran and C?  Why not learn OOP first?
18:07:49 <n4x> because we're all mathematicians that like to talk about weird concepts
18:07:50 <spopejoy> man Lens has a lot of modules. Where to look for this? it's in "Cons" which I've never seen b4.
18:08:04 <spopejoy> I looked in "At", "Traversal" etc
18:08:08 <spopejoy> oh well. thx
18:08:22 <eyebloom> CoolGuyC: I’d tend do disagree with your characterisation. I started in OOP and then moved to haskell.
18:08:23 <CoolGuyC> seems like haskell suffers from teh same problem of Visual Basic. It's not obejct oriented so when you hvae to use Employee object it way more complex than Java.
18:08:43 <sshine> CoolGuyC, but Haskell is object-oriented. it has comonads!
18:08:51 <CoolGuyC> i started out learning Basic in
18:09:03 <CoolGuyC> micrsoft VBA
18:09:04 <spopejoy> "Object Oriented" is the most bogus term to ever exist in "Computer Science"
18:09:20 <spopejoy> I mean, since when did engineers follow an "orientation"??
18:09:29 <spopejoy> I'm "oriented" NNW
18:09:36 <rhaps0dy> spopejoy, are you sure?
18:09:40 <rhaps0dy> have you checked with the compass?
18:09:41 * EvanR goes to google for this comonad-oop thing
18:09:52 <spopejoy> Well, brooklyn streets are pretty true. More like S.
18:09:54 <CoolGuyC> Haskell is like MIcrsoft VBA for Microsoft Word/Excel/Access.  They are both functional and not OOP.
18:10:02 <sshine> spopejoy, vectors have orientation - why shouldn't programming languages have that? ;)
18:10:04 <n4x> just like monads weren't enough
18:10:09 <EvanR> hopefully this isnt like the jquery is a monad from several years ago
18:10:15 <eyebloom> CoolGuyC: Are you an experienced OOP programmer? If so what language?
18:10:18 <rhaps0dy> ah but is jquery a monad?
18:10:25 <EvanR> no
18:10:35 <n4x> I bet it is a burrito rhaps0dy
18:10:36 <rhaps0dy> lol
18:10:41 <CoolGuyC> not experienced. I'm new to java but I can create Employees in Java. I can't seeem to create Employees in haskell or Basic
18:10:54 <rhaps0dy> n4x: most likley, it does seem to be edible
18:10:59 <EvanR> createEmployee :: IO Employee
18:11:01 <rhaps0dy> CoolGuyC: can you create me some Employees please?
18:11:04 <rhaps0dy> I have no money to pay them
18:11:10 <rhaps0dy> but if you create them maybe they work
18:11:17 <CoolGuyC> Employee e = new Employee();  e.Salary = 10000;
18:11:20 <spopejoy> The best thing about OO is how every object becomes a "thing" -- oh look at my cute "object". He's got fields, and behaviors!
18:11:31 <rhaps0dy> CoolGuyC: oh wow you make running a company so easy
18:11:57 <EvanR> #haskell-blah for oop
18:12:02 <eyebloom> CoolGuyC: In haskell we could create a struction data Employee = {employee_name :: String, employee_age::Int}
18:12:10 <sshine> yes please.
18:12:17 <kvitebjorn_> then use lenses to access its fields ^^
18:12:29 <CoolGuyC> i see 5 different ways to do Employee in haskell so far.  Java has 1 way cuz it's OOP
18:12:39 <sshine> hehe
18:12:48 <rhaps0dy> are you sure there's only one way?
18:12:54 <rhaps0dy> What if you encode the employee in a string?
18:13:02 <sshine> Java has several. public enum Employee { HOT, SLEEPING, FIRED }
18:13:23 <rhaps0dy> you can also do either a transparent struct-like object, or one with getters and setters
18:13:26 <spopejoy> Java has 1 way until you realize you need to refactor for testability, need an EmployeeFactoryBuilder, and plug in Spring
18:13:33 <eyebloom> CoolGuyC: Unfortunately I think you are starting at a very early stage in understanding and my best recommendation would be a good book on haskell such as “The Haskell School of Expression”
18:13:47 <eyebloom> or Learn You a Haskell
18:14:12 <spopejoy> Is THSoE a good one? I need to rec some books to coworkers
18:15:04 <spopejoy> i should probably look at LYaH. I started with Real World Haskell
18:15:09 <sshine> spopejoy, are coworkers anything like their categorical dual?
18:15:12 <rhaps0dy> I started with LYaH
18:15:16 <rhaps0dy> I think it's pretty good
18:15:30 <eyebloom> CoolGuyC: Generally haskell is a very different paradigm than OOP, so it’s unfair to really compare OOP features to haskell features as a haskell programmer will often choose a much different strategy.
18:15:48 <benzrf> spopejoy: rwh and lyah are pedagogically unsound!!!
18:15:58 <sshine> uh-huh.
18:16:09 <benzrf> CoolGuyC: have you heard of the blub paradox
18:16:16 <CoolGuyC> no
18:16:28 <sshine> actually, I was pretty sure LYAH was pedagogical, but then I realized it hides its lack of pedagogics behind kids' drawings.
18:16:35 <CoolGuyC> how come you guys still using functions? They bad no?  Why not use OOP?
18:16:37 <spopejoy> benzrf: unfortunately I agree. Which I can say without having looked at LYAH :)
18:16:53 <benzrf> CoolGuyC: because they are great
18:16:56 <benzrf> CoolGuyC: why are they bad?
18:16:57 <rhaps0dy> sshine, benzrf, spopejoy, care to elaborate a little on why is it not pedagogical?
18:17:06 <rhaps0dy> benzrf: because they are not objects!
18:17:08 <eyebloom> I think “The Haskell School of Expression” is really the best place to start.
18:17:09 <rhaps0dy> or burritos for that matter
18:17:24 <benzrf> rhaps0dy: it focuses on teaching features and less on teaching how to think
18:17:32 <benzrf> rhaps0dy: it's like
18:17:42 <benzrf> rhaps0dy: have you ever played a complicated game and then went through the tutorial
18:17:53 <benzrf> rhaps0dy: but then you have to spend a month playing it before you manage to internalize the controls
18:17:59 <benzrf> rhaps0dy: LYAH is like that tutorial
18:18:04 <benzrf> rhaps0dy: it's possible to do better
18:18:18 <eyebloom> CoolGuyC: It comes down to, functions are stateless, objects have implicit state. The less state a program can have the better… and then theirs types.
18:18:56 <spopejoy> benzrf: take a look at my first haskell tutorial sometime, next one's on types: http://slpopejoy.github.io/2014/11/27/FunctionApplicationDefinition/
18:19:07 <rhaps0dy> benzrf: ooh.
18:19:11 <rhaps0dy> Yeah, you're right.
18:19:29 <eyebloom> CoolGuyC: Functions in Haskell are also first class citizens, so we often pass them around like objects.
18:19:35 <rhaps0dy> it's like an overview of everything, a more accessible reference manual
18:19:46 <rhaps0dy> that's what I expected my start to be like tho
18:19:50 <spopejoy> my goal is to reach experienced devs, but the idea is more about thinking than doing, at least initally
18:19:51 <eyebloom> Or apply them partially
18:20:28 <rhaps0dy> okay guys
18:20:29 <benzrf> rhaps0dy: the real problem in explaining this to people is not that they don't agree with that sentiment
18:20:39 * hackagebot lifted-async 0.4.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.4.0 (MitsutoshiAoe)
18:20:40 <benzrf> rhaps0dy: it's that they don't expect it to be any better
18:20:55 <sshine> rhaps0dy, I had years of TA'ing an ML course before starting Haskell, so I experienced it as useful. but there are some jumps that I've experienced in certain lecture styles as well: the first chapter is on adding numbers and making basic functions, and after a few pages, we're literally doing list comprehensions and defining your own type classes.
18:21:00 <benzrf> rhaps0dy: from what i've seen of CIS194 it's considerably better at teaching how to understand
18:21:02 <rhaps0dy> in explaining that lyah is not pedagogic?
18:21:26 <benzrf> yeah
18:21:32 <benzrf> i didnt figure out that analogy until just not
18:21:33 <benzrf> *now
18:21:39 <benzrf> i think i'm gonna have to remember that one
18:21:44 <benzrf> it's nice and visceral
18:21:50 <rhaps0dy> The "it's like an accessible reference manual" ?
18:22:01 <benzrf> no, i've used that
18:22:03 <benzrf> it's less convincing
18:22:07 <benzrf> the game tutorial one
18:22:10 <rhaps0dy> oh.
18:22:16 <rhaps0dy> yeah, that was straight to the point
18:22:30 <rhaps0dy> I guess you can do better, yeah
18:22:36 <benzrf> the problem is that people tend to say "oh but it's hard to internalize, most PL books are like that"
18:22:48 <sshine> rhaps0dy, I think there are many non-Haskell books that are better cases for how to write a programming book.
18:22:58 <sshine> benzrf, internalize?
18:22:59 <benzrf> whereas if you allude to something that really captures the problem with it it's easier to say "and you can avoid this"
18:23:02 <benzrf> sshine: er, idk
18:23:31 <rhaps0dy> now I'm not understanding :\
18:23:46 <rhaps0dy> sshine, you meant in your lectures there was a huge jump from first to second lecture?
18:23:55 <heated> HASKELL IS DUMB
18:24:11 <rhaps0dy> easy there
18:24:16 <rhaps0dy> shouting is rude :<
18:24:20 <Zemyla> :t mconcat
18:24:21 <lambdabot> Monoid a => [a] -> a
18:24:34 <Zemyla> :t mconcat . (map return)
18:24:35 <lambdabot> (Monoid (m a), Monad m) => [a] -> m a
18:25:09 <sshine> rhaps0dy, I've experienced that in several lectures, yes. it's sort of like the mandatory chapter graduate math textbooks start with, defining sets and then whoops, you're halfway into something completely abstract.
18:25:15 <benzrf> Zemyla:
18:25:20 <benzrf> :t foldMap return
18:25:21 <lambdabot> (Monoid (m a), Foldable t, Monad m) => t a -> m a
18:25:55 <benzrf> sshine: sets are about as abstract as you can get
18:26:09 <benzrf> sshine: sets are essentially predicates
18:26:12 <sshine> benzrf, but their definition is graspable.
18:26:23 <benzrf> sshine: and that definition can lead to confusion :(
18:26:57 <benzrf> sshine: anyway, even if you talk about them as groups of things
18:27:05 <benzrf> sshine: they're still incredibly difficult to get used to
18:27:17 <sshine> benzrf, this seems to be a side-track. my point was that LYAH doesn't address a learning curve.
18:27:19 <benzrf> sshine: |ℤ| = |ℕ|?
18:27:24 <benzrf> k k
18:29:02 <sshine> I TA'ed a course in which Haskell was used, and the poorest segment of students were basically stuck defining recursive functions. this is not LYAH's fault, of course, but I think it does not apply well with these students.
18:29:02 <rhaps0dy> well, good night guys
18:29:06 <rhaps0dy> nice talking to ya
18:29:07 <sshine> night, rhaps0dy.
18:29:40 <benzrf> sshine: exactly
18:29:44 <benzrf> CIS194 focuses on that kind of thing
18:30:00 <benzrf> it gives assignments that are about forcing you to figure out how to think about things
18:30:03 <benzrf> and it explains concepts more
18:30:40 * hackagebot listsafe 0.1.0.0 - Safe wrappers for partial list functions, supporting MonadThrow.  http://hackage.haskell.org/package/listsafe-0.1.0.0 (jtapolczai)
18:34:09 <ski> benzrf : i think "sets are essentially predicates" is misleading
18:34:46 <benzrf> ski: sets are inclusion predicates
18:35:09 <ski> material sets may amount to that
18:35:14 <ski> structural sets, not so
18:35:17 <benzrf> explain?
18:35:44 <benzrf> what's a structural set
18:36:26 <ski> a material set is a set where it can make sense to *ask* whether something is an element of it
18:36:44 <benzrf> ski: i-isn't that the only kind of set
18:36:52 <benzrf> what else is there
18:37:23 <ski> a structural set is a set for which a value is *given* as an element of (and it doesn't make sense to ask whether any random value is an element of it)
18:37:53 <ski> it doesn't necessarily make sense to compare elements from different structural sets
18:38:21 <ski> e.g. the question whether `3' is equal to `{0,1,2}' is, on this view, ill-formed. it's a nonsense question
18:38:32 <benzrf> ski: oh you mean like types?
18:38:50 <benzrf> ski: i'm thinking in ZFC...
18:38:57 <ski> therefore it doesn't make sense to form intersection, union, difference of structural sets. however cartesian product, function space, disjoint union makes sense
18:39:02 <benzrf> really just naive classical set theory
18:39:13 <benzrf> ski: yes i can see that
18:39:19 <benzrf> ski: i mean sets classically
18:39:20 <ski> see "From Set Theory to Type Theory" by Mike Shulman in 2013-01-07 at <http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html> for more info
18:39:27 <benzrf> ski: :P
18:39:43 <ski> benzrf : objects in Category Theory correspond to structural sets
18:39:49 <benzrf> hmmm
18:40:17 <ski> there's a set theory, ETCS (Elementary Theory of the Category of Sets). it has only structural sets, no material sets
18:40:22 <ski> type theory has both
18:40:40 * hackagebot Spock 0.7.6.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.6.0 (AlexanderThiemann)
18:41:02 <heated> Hey guys why does none = not . any not work?
18:41:18 <ski> heated : you want `none = (not .) . any'
18:41:31 <ski> heated : short answer : because `any' takes two arguments
18:42:15 <monochrom> @type not . any
18:42:16 <lambdabot>     Couldn't match type ‘[a] -> Bool’ with ‘Bool’
18:42:16 <lambdabot>     Expected type: (a -> Bool) -> Bool
18:42:16 <lambdabot>       Actual type: (a -> Bool) -> [a] -> Bool
18:42:35 <monochrom> if it's a type error, then it makes no sense.
18:42:37 <heated> So? If I compose f with g it should take what g takes and return what f returns right?
18:42:55 <ski> heated : `any' takes a function, and returns a function
18:43:01 <tac_> @type any
18:43:02 <lambdabot> (a -> Bool) -> [a] -> Bool
18:43:09 <tac_> @type not
18:43:10 <lambdabot> Bool -> Bool
18:43:11 <ski> that means
18:43:21 <tac_> @type not . uncurry any
18:43:21 <lambdabot> (a -> Bool, [a]) -> Bool
18:43:23 <ski>   any :: (a -> Bool) -> ([a] -> Bool)
18:43:33 <tac_> @type curry (not . uncurry any)
18:43:34 <lambdabot> (a -> Bool) -> [a] -> Bool
18:44:11 <ski>   none p xs = not (any p xs)
18:44:18 <ski>             = not ((any p) xs)
18:44:25 <ski>             = (not . any p) xs
18:44:36 <ski>   none p = not . any p
18:44:50 <ski>          = (not .) (any p)
18:44:57 <ski>          = ((not .) . any) p
18:45:07 <ski>   none = (not .) . any
18:45:27 <EvanR> categorical set theory, having a hard time finding this
18:45:41 <EvanR> not that i put too much work in so far
18:45:42 <ski> EvanR : Lawvere started it
18:48:53 <EvanR> the definition of numbers as nestings of sets always annoyed me
18:49:51 <monochrom> it's why I take it as one style of implementation, not a definition.
18:50:05 <ski> the categorial approach emphasizes the external properties and relations of it, as opposed to some particular implementation
18:50:41 * hackagebot Spock-digestive 0.1.0.0 - Digestive functors support for Spock  http://hackage.haskell.org/package/Spock-digestive-0.1.0.0 (AlexanderThiemann)
18:51:08 <ski> (i suppose one could perhaps see some similarity there with the relational database model)
18:52:08 <EvanR> im wondering about ordinals though
18:52:30 <monochrom> it's also why I prefer axiomatization to definition. every time you ask for a definition, you risk getting unnecessary implementation details.
18:52:41 <danilo2> Hello! Is there in Haskell a generalization of a situation when we have a datatype with many constructors, but only one constructor provides the parametrized data and we want to execute something only when that constructor is selected? like for example whenJust :: (a -> m ()) -> Maybe a -> m ()  ?
18:54:03 <EvanR> danilo2: a case expression
18:54:26 <Zemyla> :t not .
18:54:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:54:27 <danilo2> EvanR: heh
18:54:34 <Zemyla> :t (not .)
18:54:35 <lambdabot> (a -> Bool) -> a -> Bool
18:54:38 <danilo2> EvanR: I think I found the answer! Foldable!
18:57:46 <EvanR> is there a category of categories?
18:59:26 <ezrakilty> https://en.wikipedia.org/wiki/Category_of_small_categories
18:59:46 <Zemyla> So for a normal list of singleton sets, folding over said sets with the normal fold takes way too long.
19:00:06 <Zemyla> Folding over them in a binary fashion, however, is much faster.
19:00:32 <EvanR> :t unions
19:00:32 <lambdabot>     Not in scope: ‘unions’
19:00:32 <lambdabot>     Perhaps you meant one of these:
19:00:32 <lambdabot>       ‘IM.unions’ (imported from Data.IntMap),
19:02:00 <mjrosenb> what is the best way to treat some ascii text as a bytestring, or vice versa?
19:02:13 <benzrf> mjrosenb: pack and unpack, probably
19:02:30 * benzrf does not know what he is talking about
19:03:18 <mjrosenb> benzrf: can't match type 'Char' with GHC.Word.Word8 :-(
19:03:34 <benzrf> mjrosenb: import pack from the right bs packagfe
19:03:35 <benzrf> *package
19:03:42 <benzrf> :t Data.ByteString.Word8.pack
19:03:43 <lambdabot> Not in scope: ‘Data.ByteString.Word8.pack’
19:03:47 <benzrf> augh
19:03:49 <geekosaur> you'd need the heinous Char8 versions. or maybe what you want is OverloadedStrings
19:03:51 <benzrf> :t Data.ByteString.Char.pack
19:03:52 <lambdabot> Not in scope: ‘Data.ByteString.Char.pack’
19:03:53 <monochrom> package? module?
19:03:53 <benzrf> :t Data.ByteString.Char8.pack
19:03:54 <lambdabot> String -> BSC.ByteString
19:03:54 <geekosaur> Char8
19:03:57 <benzrf> whatever!
19:05:07 <mjrosenb> but that still packs it into a "reasonable" ByteString?
19:05:58 <benzrf> heck if i know
19:06:01 <geekosaur> define reasonable
19:06:35 <mjrosenb> geekosaur: like, I can use all of the normal Data.Bytestring routines on them
19:06:44 <monochrom> Data.ByteString.Char8.pack maps ['A', 'B'] into a bytestring of the two bytes 0x41, 0x42. is that what you want?
19:06:48 <geekosaur> yes
19:07:14 <geekosaur> the unreasonable part of the Char8 versions is what it does with codepoints outside the range U+0000 ... U+00FF
19:07:40 <mjrosenb> geekosaur: thankfully, I don't actually care about those!
19:07:46 <mjrosenb> (yet)
19:08:10 <benzrf> mjrosenb: grose
19:08:36 <haasn> monochrom: Would it make sense to define numbers as a set/class/whatever of all isomorphisms between definitions of numbers?
19:08:44 <mjrosenb> benzrf: I want a bytestring containing "fLaC" to make sure I'm looking at something that looks like a flac file.
19:09:29 <monochrom> I wouldn't want to use that definition.
19:11:47 <Zemyla> :t (Endo .)
19:11:48 <lambdabot> (a -> a1 -> a1) -> a -> Endo a1
19:13:29 <Zemyla> :t (. length)
19:13:30 <lambdabot> (Int -> c) -> [a] -> c
19:14:14 <Zemyla> :t ($ 2)
19:14:15 <lambdabot> Num a => (a -> b) -> b
19:14:53 <monochrom> let me put it this way. suppose I want to use Haskell. then I only want to know the external specification (aka API semantics, aka axioms) of Haskell. every Haskell compiler implements that same external specification, and every Haskell compiler uses a different internal implementation style. but I ought not care about internal implementation styles, I should only need to know that they provide the same external specification.
19:15:14 <benzrf> ^
19:15:18 <benzrf> denotational semantics yo
19:15:28 <benzrf> ugh, why did i use a postfix yo
19:15:46 <monochrom> so the second last thing I want is "define Haskell by a particular Haskell compiler" aka definition
19:15:47 <Zemyla> What type is postfix yo?
19:16:06 <monochrom> and the last thing I want is "define Haskell by the collection of isomorphisms between Haskell compilers"
19:16:14 <benzrf> Zemyla: Normal -> Cringe
19:19:58 <Zemyla> Wait. If only foldMap is defined, then foldr uses foldMap to turn the foldable list of a's into a list of Endomorphisms on b, composes those together, and then applies z to the resulting function?
19:20:54 <gfixler> let main = putStrLn $ if tryGuess "17" then "Yes, 17, you win!" else "You lose."
19:21:14 <Zemyla> @pl \Just x -> Just (x*x)
19:21:14 <lambdabot> (. join (*))
19:21:38 <gfixler> sorry about that, but at least now I understand what vim-slime means by let main = putStrLn $ if tryGuess "17" then "Yes, 17, you win!" else "You lose."
19:21:43 <Zemyla> :type join
19:21:48 <Zemyla> :t join
19:21:49 <lambdabot> Monad m => m (m a) -> m a
19:21:56 <gfixler> sorry about that, but at least now I understand what vim-slime means by "target pane"
19:22:04 <gfixler> dangerous stuff, vim-slime
19:22:07 <monochrom> :)
19:22:08 <Zemyla> :t (. join (*))
19:22:08 <lambdabot> Num a => (a -> c) -> a -> c
19:22:21 <monochrom> fancy editors are dangerous indeed
19:22:31 <Zemyla> @pl \(Just x) -> Just (x*x)
19:22:32 <lambdabot> (line 1, column 8):
19:22:32 <lambdabot> unexpected "x"
19:22:32 <lambdabot> expecting operator or ")"
19:22:37 <gfixler> I was trying to target the right split, but irssi was in pane 1 - ah well
19:22:40 <monochrom> and by extrapolation, full blown IDEs are fatal
19:22:47 <gfixler> death by a thousand menus
19:23:22 <Zemyla> @pl x >>= (const x)
19:23:22 <lambdabot> x >> x
19:23:29 <monochrom> this is why when a complete stranger comes here to ask "why aren't you using full blown IDEs" I can't take it seriously :)
19:23:31 <benzrf> Zemyla: that's a hell of a partial function
19:23:48 <Zemyla> @pl \x -> x >>= (const x)
19:23:48 <lambdabot> ap (>>=) const
19:24:07 <monochrom> of course, this only applies to complete strangers, not familiar friends
19:27:52 <Zemyla> But anyways, I need to write an instance of Foldable that takes an ordinary Foldable and, when used with foldMap, folds the monoids in a binary fashion.
19:29:30 <lwm> hey guys, I have a function returning IO [Thing]. Type 'Thing' uses 'Record syntax' and I have a field that is 'firstPerson'. Now I want to use this field access function on the list of IO [Thing], but I don't know how to do that
19:30:20 <lwm> because :t of firstPerson is Thing -> Value
19:30:49 <lwm> if that makes sense :|
19:32:55 <gfixler> lwm: mapM?
19:33:17 <idnar> fmap (map firstPerson)
19:33:23 <n4x> :t \f -> fmap (fmap f)
19:33:23 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:33:31 <n4x> heh
19:33:46 <idnar> mapM would be [Thing] -> IO [something], but here we want IO [Thing] -> IO [something]
19:35:46 <lwm> idnar: oooh, nice
19:35:54 <lwm> that works great
19:36:05 <lwm> now to understand why ;)
19:36:38 <idnar> :t \f -> fmap (map f)
19:36:39 <lambdabot> Functor f => (a -> b) -> f [a] -> f [b]
19:36:55 <idnar> ^^^ that type might be easier to follow than the more general version n4x gave
19:37:23 <lwm> yeah, sure. I see it now, cool guys
19:37:25 <Zemyla> :t ap (*)
19:37:26 <lambdabot> Num a => (a -> a) -> a -> a
19:37:33 <gfixler> I'm actually following along here; feels good to be a gangster
19:37:45 <n4x> :t fmap . fmap :: (a -> b) -> IO [a] -> IO [b]
19:37:46 <lambdabot> (a -> b) -> IO [a] -> IO [b]
19:37:54 <Zemyla> :t ap (*) (1+)
19:37:55 <lambdabot> Num a => a -> a
19:38:14 <idnar> :t (.).(.)
19:38:15 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:38:20 <idnar> ah, no generalised (.)
19:38:46 <monochrom> @type fmap fmap fmap
19:38:47 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:39:17 <idnar> reminds me that I should really chat here more often
19:39:33 <Zemyla> :t ap
19:39:34 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:40:20 <Zemyla> :t \x y z -> x z (y z)
19:40:21 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
19:42:21 <manek> Hello! Could anybody tell me if is it possible / how - to write this code snippet using arrows? http://lpaste.net/117399
19:48:12 <Zemyla> Right. So the first problem I have is how to apply the folds in a binary tree fashion without trying to find the length of the Foldable first.
19:50:05 <Zemyla> :t foldMap (const $ Sum 1)
19:50:06 <lambdabot> (Foldable t, Num a1) => t a -> Sum a1
19:50:54 <Zemyla> :t getSum . foldMap (const $ Sum 1)
19:50:54 <lambdabot> (Foldable t, Num c) => t a -> c
19:52:17 <Zemyla> :t getSum . foldMap (const $ Sum (1::Int))
19:52:18 <lambdabot> Foldable t => t a -> Int
19:54:23 <Zemyla> So why isn't length in Foldable?
19:54:57 <EvanR> uhg the wiki is down again
19:55:18 <EvanR> im trying to find information about guarded recursion, tail recursion, ...
19:55:25 <EvanR> to avoid stackoverflow and loops
19:56:01 <lwm> Hmm ... another problem, I have a function that has a type signature of 'x -> y -> IO [z]', and I would prefer to have 'x -> y -> [z]'.
19:57:25 <Clint> that does sound like a problem
19:57:45 <EvanR> lwm: what does the IO do?
19:58:08 <lwm> It does a database lookup. I don't really want the user of the function to have to deal with an IO type
19:58:23 <lwm> I just want them to have a simple list of things.
19:59:25 <Zemyla> Well, the thing is, the database lookup comes from the outside world, and therefore it has to be in IO.
20:00:34 <EvanR> lwm: you could separate the action of getting the list from whatever the user is using with lists
20:02:33 <Zemyla> You know, it occurs to me that functions of the form (Monad m) => a -> m a are Monoids.
20:03:24 <lwm> EvanR: How do I seperate it? I have a function that does some IO action, and then?
20:03:31 <benzrf> Zemyla: well ,yes
20:03:39 <benzrf> Zemyla: any category forms a monoid when restricted to one object
20:03:50 <Zemyla> mempty is just return, and mappend f g a = (f a) >>= g.
20:04:11 <Zemyla> @pl \f g a -> (f a) >>= g
20:04:11 <lambdabot> flip . ((>>=) .)
20:04:17 <benzrf> Zemyla: you want (>=>)
20:04:21 <benzrf> :t (>=>)
20:04:22 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:04:27 <benzrf> alternatively,
20:04:29 <Zemyla> :type flip .
20:04:32 <benzrf> :t (<=<)
20:04:32 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
20:04:36 <Zemyla> :t flip .
20:04:37 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:04:46 <Zemyla> :t (flip .)
20:04:48 <lambdabot> (a -> a1 -> b -> c) -> a -> b -> a1 -> c
20:05:22 <EvanR> and this (.) from Category is the monoid operation if restricted to all the same type
20:05:32 <EvanR> id is the mempty
20:05:45 <benzrf> :t CatMon
20:05:46 <lambdabot> k2 a b -> CatMon k2 a b
20:05:52 <benzrf> Zemyla: i did this just earlier
20:06:08 <benzrf> @undef
20:06:09 <lambdabot> Undefined.
20:06:20 <t4nk870> :t fold
20:06:21 <lambdabot> (Monoid m, Foldable t) => t m -> m
20:06:31 <benzrf> @let CM k a b = CM {unCM :: k a b}
20:06:31 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
20:06:35 <benzrf> ah
20:06:38 <benzrf> @let newtype CM k a b = CM {unCM :: k a b}
20:06:40 <lambdabot>  Defined.
20:06:41 <EvanR> why does monoid come up so much and group doesnt
20:06:54 <benzrf> Zemyla: that's a newtype for monoids from categories
20:07:00 <benzrf> Zemyla: k should instantiate Category
20:07:16 <ski> every group is a monoid
20:07:36 <EvanR> most of our monoids arent groups
20:07:37 <benzrf> @let instance Category k => Monoid (CM k a a) where mempty = CM C.id; mappend (CM f) (CM g) = CM (f C.. g)
20:07:38 <lambdabot>  Defined.
20:07:39 <geekosaur> I think that's been discussed on libraries@, getting semigroups etc. into base is painful for some reason I don't recall of the top of my head?
20:08:00 <ski> the automorphisms over something form a group
20:08:07 <ski> the endomorphisms over it form a monoid
20:08:09 <benzrf> Zemyla: and now you have your monoid for free if you use CM (Kleisli m)
20:08:22 <ski> i suppose we more commonly use endomorphisms which aren't invertible ?
20:08:29 <geekosaur> so nobody bothers with them because they're not "standard"
20:08:38 <benzrf> Zemyla: er.
20:08:44 <benzrf> do you know about categories
20:08:50 <EvanR> semigroups show up all the time, for one thing because of all the monoids, but even ones that arent monoids
20:08:52 <Zemyla> Also, are there Group and Ring classes?
20:09:06 <EvanR> but groups seems rare
20:09:08 <Zemyla> benzrf: No, not yet.
20:09:13 * ski makes a plea for a `MoufangLoop' class
20:09:27 <benzrf> Zemyla: ah :|
20:09:39 <benzrf> Zemyla: they are essentially monoids where the elements have a source and target type
20:09:52 <benzrf> Zemyla: and there's an identity for each type
20:10:15 <benzrf> Zemyla: they generalize functions and types in the same way that groups generalize multiplication
20:10:26 <t4nk870> <Zemyla> I don't believe that Group is a class rather defined as a set of functions preserving homomorphisms
20:10:30 <benzrf> Zemyla: the standard class in haskell is:
20:10:35 <benzrf> class Category k where
20:10:40 <benzrf>   id :: k a a
20:10:40 <Zemyla> So class (Monoid g) => Group g where inverse :: g -> g?
20:10:52 <benzrf>   (.) :: k b c -> k a b -> k a c
20:11:00 <ski> s;(Monoid g);Monoid g;
20:11:07 <benzrf> Zemyla: so id is like mempty and (.) is like mappend, except that the values have source and target types
20:11:10 <EvanR> Zemyla: there are libraries for Group Ring etc but not really standard for anything
20:11:18 <benzrf> Zemyla: they line up with regular id and (.) for the (->) instance
20:12:20 <gfixler> :{
20:12:20 <gfixler> let main = putStrLn $ if tryGuess "17" then "Yes, 17, you win!" else "You lose." .
20:12:23 <gfixler> :}
20:12:29 <gfixler> dangit
20:13:48 <monochrom> :)
20:14:42 <gfixler> I can't get slime to stop sending that old line to this pane
20:14:49 <Cale> Groups aren't that rare. Obviously they're a little rarer than monoids if only because groups are monoids. If we had better support for groups and groupoids via higher inductive types, I can imagine that a lot of that structure in our programs would perhaps become more explicit.
20:14:51 <gfixler> now I'm afraid to use it
20:15:32 <monochrom> text editing operations probably form a group
20:15:55 <Cale> Yeah, in general a lot of "patch-like" operations form groups or at least groupoids.
20:16:11 <EvanR> ah
20:16:43 <EvanR> with commutative group, you can optimize the patches
20:16:50 <monochrom> Burnside's lemma applies
20:17:25 <Zemyla> Hmm. We really should just start with a class Magma m, and them define Semigroup, Monoid, and Quasigroup, Loop, and then have (Monoid g, Loop g) => Group g. :P
20:17:33 <Cale> Yeah, or often you wouldn't expect the whole group to be commutative, but commuting individual changes is an important thing to think about, because that's what you do when cherrypicking.
20:18:25 <EvanR> uhg class hierarchy
20:18:29 <fizbin> Anyone here any good at QuickCheck?
20:18:41 <Cale> Man, imagine how cool it would be to have a text editor which allowed cherrypicking undo?
20:18:52 <Cale> i.e. "undo the last change in this area"
20:19:10 <fizbin> I've never used QuickCheck before, and I want to probe this algorithm with a bunch of randomized test cases.
20:19:15 <gfixler> Cale: I've seen that before, but it only sorta sometimes worked
20:19:29 <Zemyla> I wish we could define a CommutativeMonoid, and then wish Haskell would let us pick different algorithms for operating on commutative and noncommutatove monoids.
20:19:43 <benzrf> Zemyla: i believe idris has things like this
20:19:47 <benzrf> it's strict though
20:19:52 <Cale> I bet if you had an editor which was really principled about all the little patches, you could do it well
20:20:14 <gfixler> Cale: git actually makes it easy, for undos of granular commits
20:20:18 <gfixler> I've done it in Vim
20:20:43 <gfixler> I can split the pane, hit a key to walk back the history of one side, diff both, and hit a key to pull a hunk over from the past
20:20:55 <EvanR> git is good, git is high performance, git is not well founded in math or easy to explain when things get hairy
20:21:12 <gfixler> EvanR: hmmm, howso?
20:21:25 <gfixler> it's a DAG of immutable members
20:22:13 <EvanR> you mean, its a collection of dags modified by various groups ;)
20:22:34 <gfixler> heh, well... people are changing my local objects and references
20:22:57 <gfixler> I've also use Vim's immutable undo tree with plugins to make it more visual
20:22:58 <EvanR> you end up with whole chunks of history duplicated through some mismanagement
20:23:17 <gfixler> I've gone to another branch of undo states, grabbed a piece, returned to the 'present' and pasted it over the new thing
20:23:20 <EvanR> and people solve it by "just merging master" and forgetting
20:23:31 <gfixler> EvanR: there's your problem: people
20:24:04 <gfixler> typo - I meant people *aren't* changing my local obs/refs
20:24:07 <EvanR> if it was just patches, that would be easier to understand maybe
20:24:19 <gfixler> it basically is, though
20:24:31 <EvanR> its conceptually snapshots
20:24:39 <gfixler> each commit is a whole state - no deltas (packfiles don't count/are an optimization)
20:24:54 <gfixler> things like cherry-pick and rebase are basically creating and applying diffs
20:25:03 <gfixler> live, from the snapshots
20:25:44 <Zemyla> Hmm, is there anything I need to keep in mind if I have a circular structure? Do circular structures get garbage collected?
20:25:45 <EvanR> its more than just content snapshot
20:26:55 <EvanR> Zemyla: if they are unreachable, yes
20:27:10 <gfixler> EvanR: howso?
20:27:12 <Zemyla> Okay. So it's not like refcounting.
20:27:17 <EvanR> god no
20:27:42 <EvanR> gfixler: two different commits may have no differents
20:27:48 <EvanR> difference
20:28:27 <EvanR> while, if you had a change to some code, that change conceptually should make sense when applied to various starting points
20:30:05 <gfixler> well, if 2 commits have the same contents, they'll refer to the same top-level tree
20:30:11 <ski> Zemyla : updates can be problematic with cyclic structures
20:30:43 <EvanR> gfixler: implementation stuff, in the user level git utility, its two different commits. two whole branches could be different and exactly the same
20:31:03 <gfixler> EvanR: is that bad?
20:31:30 <Zemyla> So I can have, for instance, a permutation that can be converted easily between standard amd cycle forms by saying let p = PermStd perm (PermCycle (cycleForm perm) p).
20:31:31 <gfixler> the duplication would just be small text files of metadata - the trees in each commit would be shared/stored once
20:31:37 <EvanR> really you want something to track what happened, rather than snapshots
20:32:00 <gfixler> EvanR: I'd need some convincing of that one
20:32:07 <EvanR> gfixler: youre still thinking about how somebody would implement a thing rather than how to use it for version control
20:32:21 <Zemyla> Also, due to laziness, (cycleForm perm) won't be called until it's needed.
20:32:39 <gfixler> I've used git for version control for about 1.5 years - I think it works really well
20:33:03 <gfixler> I do just see version control as stateful snapshots, thouhg
20:33:06 <EvanR> gfixler: in real life, explaining the entire implementation of git to someone so that the history will not get messed up is not feasible.. people dont care that much, so history gets messed up
20:33:23 <Zemyla> And then once it's needed, every access after the first takes place in constant time.
20:33:33 <gfixler> EvanR: "people don't care that much" - I hear that :(
20:33:50 <gfixler> EvanR: just force push and unmess it up :)
20:34:04 <EvanR> its very pragmantic system, is what im saying
20:34:15 <EvanR> its not necessarily easy to tell "wtf happened"
20:34:25 <gfixler> EvanR: I feel this way about Haskell - I can't get my coworkers to care about any of it, sadly
20:35:14 <gfixler> EvanR: do you know of a better system than git, or do you just feel the need for one?
20:35:15 <EvanR> a good abstraction for version control would be "heres what you did"
20:35:34 <gfixler> I feel like that's `git show <hash>`
20:35:45 <EvanR> thats a shapshot
20:35:52 <EvanR> i didnt write the entire project in that commit
20:35:53 <gfixler> ...of what you did
20:36:04 <gfixler> are you not making granular commits?
20:36:14 <gfixler> each of my commits is a single concern
20:36:21 <EvanR> nevermind, wrong command
20:36:22 <fizbin> Well, it's mega-ugly, but anyone who was around earlier looking at my compute-instructions problem, I have a solution that I think works at http://lpaste.net/117395
20:36:23 <gfixler> I often rearrange them, elide them, etc
20:36:53 <gfixler> the commit message will be, e.g. "Refactor all foo to bar in baz.ext"
20:37:01 <gfixler> and that's all that's in that commit
20:37:19 <gfixler> so a oneline git log literally is "what I did" - it's like a step-by-step prinout
20:37:28 <EvanR> good enough is the enemy of even better ;)
20:38:00 <gfixler> EvanR: I would agree that this is a discipline, which I follow, and others don't, but can't imagine how else to do it
20:38:12 <fizbin> (E.g. I know pavonia and SharpGAF were around when I was asking about that problem, and so might be interested in a solution)
20:38:27 <gfixler> save for not allowing typing - only allow coding my selection from menus, and it can generate "what you did" messages in that context
20:38:47 <EvanR> gfixler: youre lucky to work in a group with discipline. but in general we want tools that require less discipline to do the thing right
20:39:07 <gfixler> EvanR: I don't work in a group with this discipline, and I'm the only one using git
20:39:20 <EvanR> git for one-man things is great
20:39:26 <gfixler> indeed :)
20:39:39 <EvanR> git-annex is pretty cool looking
20:39:44 <gfixler> I'm just finally starting to work with a team, and it's a tad eye-opening
20:39:54 <gfixler> ocharles has a git annex with a ton of papers
20:39:59 <gfixler> on github
20:40:46 * hackagebot Logic 0.1.0.0 - Logic  http://hackage.haskell.org/package/Logic-0.1.0.0 (gogotanaka)
20:41:56 <EvanR> this is probably my issue right now ... i havent been using Logic
20:46:06 <lwm> \quit
20:47:08 <jrc12> How would you convert a String into Html (from Text.Blaze)
20:47:41 <jrc12> (String/Text/ByteString)
20:50:13 <chrisdotcode> jrc12: I'm fairly certain there are conversion methods.
20:50:17 <chrisdotcode> Have you checked the actual package doc?
20:51:17 <jrc12> chrisdotcode: Yep, tried hoogle as well. They dont seem to mention a way to parse strings to html
20:51:24 <EvanR> if theres a top level caf [1..], and im consume it somewhere, does it ever get reclaimed?
20:51:42 <EvanR> no right
20:53:53 <dhrosa> what alternatives are there to Show? Ithink I remember reading somewhere about some auto-magic pretty printing library
20:57:03 <chrisdotcode> dhrosa: http://hackage.haskell.org/package/pretty ?
20:58:42 <Zemyla> Hmm, there's no way for me to do something different when passed a function a -> a than when passed an a -> b, is there?
20:59:02 <fizbin> Ouch - not something you want to see after relying on default QuickCheck settings for lots of other stuff - "Failed! Falsifiable (after 6610 tests and 2 shrinks)"
20:59:11 <dhrosa> am I imagining things or isn't there a library that does fancy things with TH or generics or something?
20:59:20 <dhrosa> for pretty printing*
20:59:37 <dhrosa> Zemyla: with the same function name?
20:59:54 <dhrosa> Zemyla: you /could/ do it with a typeclass I suppose, what exactly are you trying to do?
21:00:09 <ski> Zemyla : optimization ?
21:05:18 <Zemyla> Well, suppose I have a data Witness a where { OrdW :: (Ord a) => Witness a; IdW :: Witness a }, and I want a function wcast :: Witness a -> Witness b that returns OrdW::Witness b iff b is the same as a and the argument was OrdW::Witness a.
21:05:39 <Zemyla> Otherwise, it returns IdW::Witness b.
21:06:46 <flexfit> How do I exit out of the GHC interactive mode?
21:06:46 <hiptobecubic> Is there a way to have `cabal test` always pass some options as if one had used the `--test-options` flag?
21:06:58 <Zemyla> flexfit: :quit
21:07:23 <flexfit> Zemyla: Thanks
21:07:34 <dhrosa> flexfit: or control + D
21:08:22 <flexfit> thanks dhrosa!
21:08:55 <ski> Zemyla : sounds hard
21:13:57 <Zemyla> And if I can do that, then I would as an advanced exercise want to convert, say OrdW::Witness a to OrdW::Witness [a], since Ord a => Ord [a].
21:14:43 <Draconis> hey guys, learning haskell, got a odd question. Looking at foldl and trying to figure out why the type signature for the Binary operator is shown as (b -> a -> b)  shouldn't it be just a -> a -> a?
21:15:15 <Draconis> and by odd I really mean beginner
21:17:14 <Welkin> it takes an element from the list and the accumulator and combines them in some way
21:17:24 <Welkin> since it is a left fold, the accumulator is on the left
21:17:35 <pavonia> :t foldl
21:17:35 <Welkin> (b -> a -> b)
21:17:36 <lambdabot> (b -> a -> b) -> b -> [a] -> b
21:18:02 <Draconis> so how I was reading it was the (b -> a -> b) is the binop
21:18:05 <c_wraith> Draconis: nah.  The result type doesn't need to be the same as the list element type
21:18:09 <zq> hm
21:18:10 <Draconis> the 2nd b is the accumulator
21:18:30 <zq> how do dynamic libraries pre-initialize their global structs and classes?
21:18:40 <chrisdotcode> Black magic is my guess.
21:18:56 <Welkin> foldl (\acc val -> val + acc) 0 [1..10]
21:19:12 <c_wraith> > foldl (\x out -> show x ++ " is before " ++ out) "" [1..10]
21:19:13 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
21:19:13 <lambdabot>    arising from the arithmetic sequence ‘1 .. 10’No instance for (GHC.Num.Num...
21:19:13 <lambdabot>    arising from the literal ‘1’
21:19:15 <Welkin> where (\acc val -> val + acc) :: b -> a -> b
21:19:16 <ski> > foldl (\acc val -> val + acc) 0 [1..10]  :: Expr
21:19:17 <lambdabot>  10 + (9 + (8 + (7 + (6 + (5 + (4 + (3 + (2 + (1 + 0)))))))))
21:20:06 <c_wraith> > foldl (\out x -> show x ++ " is before " ++ out) "" [1..10]
21:20:08 <lambdabot>  "10 is before 9 is before 8 is before 7 is before 6 is before 5 is before 4 ...
21:20:19 <c_wraith> lambdabot doesn't know match!
21:20:36 <c_wraith> Draconis: ^ that example.  The output type of the fold isn't the same as the element type
21:21:15 <Draconis> c_wraith: ok thanks. Thanks Welkin too I get it now. I was assuming the binop was simply addition, product etc
21:21:18 <ski> `out' is a string
21:21:19 <dhrosa> zq: what do you mean by dynamic, stateful?
21:21:19 <Draconis> I did not think about ++
21:21:32 <zq> holy shit wrong channel
21:21:36 <ski> @type foldl1
21:21:37 <lambdabot> (a -> a -> a) -> [a] -> a
21:21:38 <ski> @type foldl
21:21:39 <lambdabot> (b -> a -> b) -> b -> [a] -> b
21:21:44 <zq> dhrosa: sorry, that was a c++ question
21:22:17 <Zemyla> How does Coercible work?
21:23:57 <zq> dhrosa: for posterity, despite being hugely off-topic, cpp code undergoes a pre-main initialization state wherein the constructors of top levels are called
21:26:03 <dhrosa> yep
21:26:19 <dhrosa> I've always found the global scope... strange in C++
21:26:26 <dhrosa> there's no guaranteed order of the constructors firing right?
21:27:38 <Zemyla> :t (. (:[]))
21:27:39 <lambdabot> ([a] -> c) -> a -> c
21:28:30 <Zemyla> :t flip (,) 1
21:28:31 <lambdabot> Num b => a -> (a, b)
21:28:49 <dgomez> I learned more about category theory today but i am still unsure I know much else about Functors
21:28:55 <Zemyla> :t (:[]) . (flip (,) 1)
21:28:56 <lambdabot> Num b => a -> [(a, b)]
21:29:02 <SharpGAF> C has a funny thing going on where people keep adding functions that get called earlier and earlier in the initialization sequence :P
21:29:08 <SharpGAF> The whole thing is a disaster.
21:32:14 <benzrf> night
21:33:46 <Welkin> day
21:41:15 <dhrosa> dgomez: well, what /do/ you know about Functors?
21:45:49 * hackagebot lifted-async 0.5.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.5.0 (MitsutoshiAoe)
21:48:55 <dgomez> dhrosa : just the definition. And I'm not sure if its interpreted correctly but knowing if you have a functor F: C->D and you want to map object A in C to F(A) in D then you map a morphism f: A -> B in C to F(f): F(A) -> F(B) in D
21:49:38 <dgomez> but if a functor is just a tranformation between two categories or morphisms (or transcends them?) then I am still vague to its applicabilty.
21:49:50 <dgomez> or haskell syntax other than what I have seen on hackage
21:57:40 <dgomez> is this not correct at all?
21:58:02 <fresheyeball> hey out there
21:58:16 <fresheyeball> I just have a quick question
21:58:26 <fresheyeball> $ :: (a -> b) -> a -> b
21:58:33 <fresheyeball> where is the opposite?
21:58:46 <fresheyeball> what is :: a -> (a -> b) -> b ??
21:59:00 <fresheyeball> is there anything like that?
21:59:53 <Taneb> fresheyeball, there's none in base.
22:00:25 <Welkin> fresheyeball: flip $
22:00:31 <Welkin> :t flip ($)
22:00:32 <lambdabot> b -> (b -> c) -> c
22:00:38 <fresheyeball> oh sure
22:00:43 <fresheyeball> I know how to write it
22:00:44 <Taneb> Some libraries, like diagrams and lens, export their own (# and & respectively, although diagrams also exports lens's &) but they are a bit overkill to import just for one operator
22:00:51 <Taneb> If you need to define it, it's like one line
22:01:17 <fresheyeball> ok, so its not hiding in the prelude somewhere I just missed
22:01:22 <Taneb> http://hayoo.fh-wedel.de/?query=a+-%3E+%28a+-%3E+b%29+-%3E+b
22:01:29 <fresheyeball> it seems like its equally useful to $
22:02:04 <fresheyeball> hayoo, thats cool
22:02:11 <fresheyeball> better than hoogle?
22:03:00 <zq> i think
22:03:06 <dgomez> fresheyeball: so what is flip ($) referred to?
22:03:17 <zq> i just seriously kicked a cpp-equivalent's ass with my hs
22:03:19 <fresheyeball> what do you mean?
22:03:40 <fresheyeball> \dgomez what do you mean?
22:04:00 <Welkin> fresheyeball: hayoo is the same as hoogle, but it searches more packages than just base
22:04:01 <dgomez> well isn't it saying that flip ($) has type a -> (a -> b) -> b?
22:04:12 <dgomez> flip ($) :: *
22:04:14 <fresheyeball> right
22:04:14 <Welkin> hoogle only searches base, but you can seatch y type signature
22:04:28 <fresheyeball> ok thats cool
22:04:36 <fresheyeball> hayoo from now on
22:04:38 <fresheyeball> :)
22:04:44 <Welkin> search by*
22:04:57 <fresheyeball> :t flip ($)
22:04:58 <dgomez> fresheyeyeball: what is "flip ($) "
22:04:58 <lambdabot> b -> (b -> c) -> c
22:05:11 <fresheyeball> uh
22:05:11 <dgomez> oh nvm
22:05:20 <Welkin> dgomez: flipped function application
22:05:21 <fresheyeball> its $ flipped?
22:05:24 <fresheyeball> yes
22:05:32 <fresheyeball> so for example
22:07:01 <fresheyeball> let # = flip ($) in ((#) / ) <$> [1,2,3] <*> [3,4,5]
22:07:11 <n4x> I wouldn't use #
22:07:24 <fresheyeball> sure, its just an example
22:07:57 <fresheyeball> personally, I'm partial to something like this
22:08:16 <fresheyeball> let <@#$%^$%> = flip ($)
22:08:33 <fresheyeball> jk
22:09:39 <systemfault> Man... what were the yesod guys thinking when they decided to use Template Haskell...
22:09:39 <solatis> fresheyeball: now you're just cursing... :)
22:09:53 <solatis> TH can be nice
22:10:17 <systemfault> solatis: But I'm a Haskell noob... Yesod using TH makes it even more inaccessible to me.
22:10:38 <Welkin> systemfault: I use yesod just fine and I don't know much about TH
22:10:50 <solatis> is "being easy to use for noobs" a design goal of Yesod?
22:10:54 <Welkin> it "just works"
22:11:09 <systemfault> solatis: I guess not.
22:11:12 <solatis> (btw, i'm doing haskell for about 2 - 3 months now, I have no problems with yesod at all)
22:11:33 <solatis> i have far more problems with the fact that it has some rough edges
22:12:09 <systemfault> I'm still learning proof theory... category theory... more maths to get better at haskell...
22:12:14 <systemfault> I understand the basics.
22:12:22 <solatis> i suck at math but i can do haskell
22:12:32 <Welkin> building an application in yesod is what took me from doing project euler exercises and playing with openGL/SDL to feeling like I can build real applications in haskell
22:12:44 <solatis> it's a common misconception, imho, that you need to be good at math in order to be good at haskell
22:12:46 <Welkin> I'd suggest doing it to help you grow
22:12:49 <systemfault> Welkin: So i should really try Yesod then?
22:12:54 <falafel> and category theory is not needed to understand Haskell, I suppose it is useful to have a background, but I get by just fine with out it
22:13:41 <Welkin> systemfault: yes, just read the yesod book, available online for free
22:14:07 <Welkin> yesod is really more like a set of DSLs that is mixed in with plain haskell
22:14:39 <systemfault> Will do then... Was just scared of TH
22:14:46 <Welkin> it should help you become comfortable programming with monads and monad transformers
22:14:56 <Welkin> you won't be writing any template haskell though
22:14:58 <solatis> well it's similar like someone diving into c++ and starting out with boost.spirit
22:15:09 <solatis> you will be like, "wtf, this is not the c++ i know!"
22:15:26 <solatis> but in the end it makes up for a very nice API
22:15:36 <dgomez> falafel: how have you managed to "understand" Haskell then?
22:15:39 <systemfault> solatis: boost::spirit would literally KILL any C++ beginner ;)
22:16:09 <systemfault> solatis: (I have a C++ background...)
22:16:12 <solatis> systemfault: well, not really -- debugging the GCC error messages will, not spirit iself :)
22:16:39 <systemfault> Hehehe
22:16:41 <solatis> yeah me too, i have a quite good c++ background, and found the transition to haskell not too troublesome
22:16:50 <solatis> you already know category theory (c++ concepts)
22:17:02 <solatis> you already know a lot of FP concepts if you used boost.phoenix
22:17:03 <solatis> etc
22:17:21 <Welkin> category theory in c++?
22:17:35 <solatis> http://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29
22:17:40 <systemfault> solatis: Terminology was a big issue for me at first...
22:17:56 <solatis> systemfault: what do you mean, 'snoc' ?!
22:17:57 <solatis> :)
22:18:00 <falafel> dgomez, by relating the concepts to programming and applying them to other languages, I think the typeclassopedia does a pretty good job at explaining the core algebras from an academic point of view, and then I just look for tutorials that use real code
22:18:11 <systemfault> solatis: The classic: A monad is just a monoid in the category of endofunctors, what's the problem? :P
22:18:39 <systemfault> falafel: I soooo love typeclassopedia
22:18:40 <solatis> Welkin: it was proposed for c++11, but they killed it because they couldn't agree on *which* concepts (types) came out of the box
22:18:58 <solatis> systemfault: haha yeah, i learned monads by just googling for a javascript implementation of a monad
22:19:08 <solatis> and i was like, "ooohhhhh, that's actually really simple"
22:19:09 <systemfault> falafel: That single page filled a LOT of the blanks I had in my haskell knowledge
22:19:56 <Welkin> for me it was the essay "you could have invented monads, and you probably have"
22:19:56 <solatis> and just like implementing your own shared_ptr in c++ is a good learning excercise, implementing your own monad in haskell is too
22:20:09 <systemfault> solatis: I understood monad when I stopped caring about monads :P When you understand functor.... then applicative.... monad is just "obvious"
22:20:31 <solatis> i still don't understand applicative
22:20:43 <solatis> or at least, i think i understand, but i just am scared to actually use it
22:20:57 <solatis> i am already happy i finally understand functors/fmap
22:21:07 <Welkin> it's just a monad without the ability to chain computations together
22:22:41 <Welkin> I think the typeclassopedia explains the difference fairly well
22:22:52 <dhrosa> or more like, it's a Functor with a multi-argument map
22:22:56 <dhrosa> instead of just one with fmap
22:23:02 <solatis> i am quietly amused by the amount of "it's just X" explanations of complex concepts in haskell :)
22:23:14 <falafel> systemfault, I'm still a newbie anyway, I just play with Haskell, because it is fun
22:23:15 <Welkin> nothing is actually complex
22:23:19 <dhrosa> a monad is just a monoid in the category of endofuctors
22:23:22 <solatis> i know
22:23:24 <Welkin> it just seems complex when you don't understand it
22:23:51 <Welkin> I've learned to just look at the types for an explanation
22:23:54 <tac_> it's monoids all the way down
22:23:55 <solatis> yeah, like the famous "understanding monads, and the ability to explain them are mutually exclusive" quote :)
22:24:02 <dgomez> solatis: I guess, past the point that I have read this but i'm not doing great when it comes to pointing it out in a block of code
22:25:09 <systemfault> falafel: I am too, makes me remember that there's better than PHP, Java and JavaScript in this world :P
22:25:29 <solatis> systemfault: there are a lot of options in the middle
22:25:38 <solatis> for me it was c++ -> scala -> haskell
22:25:44 <solatis> i needed scala to grasp FP
22:25:50 * hackagebot Octree 0.5.4.2 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5.4.2 (MichalGajda)
22:25:51 <solatis> then i realised scala was crap
22:25:54 <solatis> and i moved on to haskell
22:26:09 <systemfault> solatis: I tried to like Scala...
22:26:20 <dhrosa> actionscript -> C++ -> python -> haskell -> scala for me
22:26:24 <solatis> nah, really, the monkey patching / duct typing in scala scares the hell out of me
22:26:37 <dhrosa> duct typing sounds like duct tape typing
22:26:38 <solatis> like, you can import ModuleFoo, which completely changes the behaviour of List
22:26:39 <systemfault> solatis: But for me, Scala is a statically-typed version of Perl.... A language that wants to do everything but without vision.
22:26:40 <dhrosa> which is almost accurate
22:27:36 <falafel> systemfault, PureScript seems to fit a sweet point for me, but I can't put it in production still, maybe next year
22:28:40 <solatis> for me too, i was doing node.js .. then i realised JS was too low-level, so i moved to coffeescript, when i realised that coffeescript's parser was CRAP (so many whitespace / indentation errors made me cry).. then i went on to purescript, and realised i was actually looking for haskell all the time
22:29:08 <Welkin> haskell seems to be closest to the ideal programming language
22:29:15 <systemfault> Haskell is my impossible dream.
22:29:25 <Welkin> declarative
22:29:35 <solatis> i would like a strict version of haskell, tho
22:29:39 <systemfault> I will never be able to use it in the "real world"(TM)
22:29:51 <solatis> oh i'm just building OSS libraries using haskell
22:29:59 <solatis> trying to contribute to the ecosystem
22:30:07 <Zemyla> Since comonads are the opposite of monads, are coworkers the opposite of workers?
22:30:08 <solatis> and hope that makes the move to haskell easier for other people
22:30:30 <solatis> Zemyla: that sounds like a question for /r/shittyaskhaskell
22:30:39 <systemfault> solatis: I'm not confident enough in my haskell skills to even consider contributing.
22:30:58 <solatis> systemfault: start your own project
22:31:06 <Welkin> systemfault: I contributed to some C library bindings after just a couple months with the language
22:31:08 <solatis> you don't need to contribute to existing projects
22:31:11 <solatis> do something yourself
22:31:18 <Welkin> and I didn't understand much beyond what I found in LYAH at the time
22:31:47 <Welkin> those are easy to make contrinutions to, though
22:31:57 <solatis> right now i'm building a distributed anonimity system in haskell
22:31:59 <falafel> systemfault, that's how I feel too most of the time. I have no experience with Haskell libraries other than Prelude so getting into production would be a lot of work, but PureScript, I already know a bunch of JS libraries
22:32:13 <solatis> the design probably sucks donkey arses, but i'll learn along the way
22:32:39 <systemfault> falafel: Ah cool :D
22:32:42 <Welkin> falafel: you have never imported Data.List? or Data.Map?
22:32:47 <dgomez> systemfault: solatis: I'm not confident enough in my haskell skills to even consider contributing. (Kind of how I feel atm...)
22:33:01 <solatis> heh
22:33:24 <chrisdotcode> Is semvar based on Haskell's PVP, or vice versa?
22:33:25 <falafel> Welkin, well, yes, I mean I have no experience with libraries like Yesod for the web
22:33:38 <Welkin> oh, well the only way to learn is to just do it
22:33:39 <systemfault> falafel: These days I'm really interested in FRP, even more since I listened to the last "Haskell Cast" with Conal Elliot
22:33:43 <solatis> https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md
22:33:49 <solatis> i think that haskell one is spot on
22:33:55 <Welkin> I had no idea what I was doing when I started using yesod
22:33:57 <solatis> haskell makes you *think* you know nothing
22:34:04 <Welkin> now it seems pretty straight forward (mostly)
22:34:12 <solatis> while in fact, you might already be making more stable/better systems than you would in c++
22:34:45 <falafel> Haskell makes me a better programmer in other languages, that's why it is fun, because once you understand a particular abstraction is so revealing
22:34:54 <Welkin> solatis: haskell is really easy for beginners
22:35:09 <solatis> well it's easy to make a fib implementation in ghci yes
22:35:22 <chrisdotcode> Haskell has ruined me for other languages.
22:35:26 <chrisdotcode> They all suck now.
22:35:27 <Welkin> unfortunately, imperative programmers believe it is "difficult for beginners" because they know programming only though the imperative paradigm
22:35:33 <MP2E> chrisdotcode: i have had a very similar experience
22:35:41 <Welkin> through*
22:35:45 <solatis> well i think a lot of people don't get past the "my brain hurts" phase
22:35:46 <MP2E> my C codebases I once maintained are no longer appealing :V
22:36:05 <chrisdotcode> MP2E: Yeah, global mutable state and callbacks literally almost give me headaches now.
22:36:06 <falafel> getting pas the "my brain hurts" when your brain is damaged by PHP is hard
22:36:15 <Welkin> assembly is still fun to write
22:36:19 <systemfault> Welkin: It's still easier to me to see a program as a list of "steps" than as a math equation.
22:36:26 <Welkin> I used to enjoy writing C and python, but not any more
22:36:32 <solatis> Welkin: oh god, i had to write a calculator in ASM back in college
22:36:34 <solatis> that was a nightmare
22:36:46 <chrisdotcode> Thankfully, Python has optional OOP. and functutils
22:36:49 <Welkin> I only used asm for firmware
22:36:49 <solatis> i think i would actually prefer C over C++ now
22:37:05 <chrisdotcode> *functools
22:37:19 <solatis> c++ has phoenix, which is just scare
22:37:20 <solatis> y
22:37:21 <Welkin> haskell made me see the true value of static typing
22:37:37 <Welkin> I thought it was pointless when I was using python
22:37:44 <solatis> lazy evaluation operators in c++ :o
22:37:50 <solatis> http://www.boost.org/doc/libs/1_57_0/libs/phoenix/doc/html/phoenix/starter_kit/lazy_operators.html
22:37:53 <Welkin> until I ran into all sorts of terrible errors, that is
22:37:57 <solatis> and that's just the 'starter kit'
22:38:33 <solatis> http://www.boost.org/doc/libs/1_57_0/libs/phoenix/doc/html/phoenix/examples/transforming_the_expression_tree.html
22:38:38 <solatis> you see, c++ can make your brain hurt too
22:38:56 <Welkin> I like to say that I use haskell because I am lazy
22:39:04 <Welkin> lazy programmers and lazy languages
22:39:20 <Welkin> I wan to type as little as possible
22:39:23 <Welkin> want*
22:40:52 * hackagebot hs-scrape 0.1.0.0 - Simple and easy web scraping and automation in Haskell.  http://hackage.haskell.org/package/hs-scrape-0.1.0.0 (codygman)
22:40:54 <solatis> personally i hate the "i want to type as little as possible" attitude
22:41:01 <solatis> it's like the inverse of measuring cock size
22:41:12 <Welkin> it has nothing to do with ego
22:41:16 <solatis> haha i know
22:41:21 <codygman> Woo, my first package :)
22:41:22 <solatis> but i mean, it is a bad measurement
22:41:25 <Welkin> it is because I don't want to spend all my time sitting at a computer
22:41:39 <solatis> perl can be extremely dense
22:41:45 <solatis> that doesn't make it a good language
22:41:55 <solatis> maintainability, and the ability to reason about code, is far more important imho
22:42:03 <Welkin> I meant, type as little as possible and have it work the first time
22:42:27 <solatis> so you don't use type signatures? ;)
22:42:30 <solatis> ehr
22:42:32 <solatis> function signatures
22:42:34 <Welkin> oh, of course I do
22:42:35 <dgomez> Welkin: even as a beginner I don't agree with your perspective...
22:42:37 <Welkin> that is what I begin with
22:42:46 <solatis> now then, you don't need those
22:42:51 <Welkin> but I do
22:43:11 <Welkin> they tell me how to write the function definition
22:43:16 <dgomez> Welkin: inherent to one's opinion :P
22:43:55 <solatis> that directly cnflicts with "write as little as possible and have it work the first time"
22:44:04 <solatis> you can have it work the first time without writing signatures
22:44:11 <solatis> so you're not writing as little as possible
22:44:22 <Welkin> but I cannot write the function without first writing the type signature
22:44:22 <falafel> I dont buy the type less is better argument, but I do like to type less, so it is a compromise
22:44:28 <dgomez> Are there lambda expressions anyone can offer an example as to their use in foldr?
22:44:43 <Welkin> dgomez: what do you mean?
22:44:49 <solatis> dgomez: github.com/search foldr ?
22:44:54 <Welkin> foldr is a right fold, so the accumulator is on the right side
22:44:59 <SharpGAF> Usually if you really want to type very little and write correct programs, your best bet is a DSL :)
22:45:00 <falafel> dgomez, folding an array of numbers for exmaple?
22:45:27 <dgomez> falafel: from the site I'm looking on, yes.
22:45:28 <Welkin> > foldr (\x acc -> x : acc) [] [1..10]
22:45:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:45:34 <SharpGAF> General purpose languages inherently have to compromise on conciseness for generality.
22:45:40 <falafel> > foldr (+) 0 [1,2,3]
22:45:41 <lambdabot>  6
22:46:25 <Welkin> SharpGAF: this is why I like yesod
22:48:59 <Welkin> anything that allows me to build software in the shortest amount of time is my preference
22:49:11 <falafel> but that's different to "writing less"
22:49:11 <Welkin> if I could just beam my thoughts into the computer, I would do that
22:49:44 <SharpGAF> Thoughts are so imprecise though :P
22:49:50 <Welkin> this has to take into account time spent debugging and being able to extend the software at a later time as well
22:49:52 <dgomez> > foldr (+) 5 [1,2,3,4]
22:49:53 <lambdabot>  15
22:50:02 <dgomez> so what is the operator (+)
22:50:12 <falafel> dgomez, it is a function
22:50:13 <Welkin> of course, no one wants to debug
22:50:22 <falafel> dgomez, the "plus" function
22:50:26 <Welkin> dgomez: it is an infix function
22:50:27 * SharpGAF doubts anyone but absolute beginner programmers are bottlenecked on typing speed.
22:50:43 <Welkin> SharpGAF: haha, that't not what I meant
22:51:01 <rwiggins> SharpGAF, you might be surprised; usually the thinking part happens separately of the typing, and then suddenly typing becomes the bottleneck. :)
22:51:28 <SharpGAF> rwiggins: That hasn't been my experience, except during some tedious search-replace stuff that a good IDE would resolve.
22:51:36 <SharpGAF> But yours may be different :)
22:51:37 <Welkin> I used to write my functions on paper and then later transfer them to a text editor
22:53:00 <dgomez> > (\ f x y −> f x y) (+) 3 4
22:53:01 <lambdabot>  <hint>:1:10: parse error on input ‘−>’
22:53:30 <dgomez> > (\ f x y) (+) 3 4
22:53:31 <lambdabot>  <hint>:1:9: parse error on input ‘)’
22:53:49 <Welkin> it is ->
22:54:04 <Welkin> the dash, next to the += key
22:54:31 <Clint> hyphen-minus
22:54:35 <mikeplus64> –->
22:54:39 <falafel> > (\x y -> x + y) 3 4
22:54:41 <lambdabot>  7
22:54:47 <falafel> dgomez, ^
22:55:47 <falafel> dgomez, so (+) = \x y -> x + y in (+) 3 4
22:56:07 <Welkin> @src (+)
22:56:07 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:56:19 <dgomez> falafel: man I feel dumb, thanks.
22:56:32 <pavonia> > let (−>) = flip ($) in 3 −> succ
22:56:33 <lambdabot>  4
22:58:22 <solatis> am i correct that Control.Concurrent.QSemN is Haskell's variant of the barrier pattern ?
22:58:44 <dgomez> > (\x y - > x * y) 5 6
22:58:45 <lambdabot>  <hint>:1:7: parse error on input ‘-’
22:58:49 <Welkin> let (©) = ($) in succ © 4
22:58:52 <Welkin> > let (©) = ($) in succ © 4
22:58:53 <lambdabot>  5
22:59:10 <Welkin> I wonder if anyone uses strange symbols like that in their programs
22:59:20 <falafel> :t
22:59:28 <Welkin> litter your codebase with copyright and trademark symbols
22:59:30 <Welkin> hah
22:59:32 <falafel> how do I check the type of things with the bot?
22:59:39 <falafel> >:t 2
22:59:40 <Welkin> :t ($)
22:59:41 <lambdabot> (a -> b) -> a -> b
22:59:43 <falafel> ah
22:59:49 <falafel> wut>
22:59:50 <Welkin> use "> " for evaluation
23:00:06 <falafel> :t 2
23:00:07 <lambdabot> Num a => a
23:00:11 <falafel> ah, got it
23:00:49 <solatis> is it generally better to write Num a => a instead of Int if you don't care about its type ?
23:00:52 <solatis> what is more idiomatic ?
23:01:01 <Welkin> > let ∑ = sum in ∑ [1..100]
23:01:02 <lambdabot>  <hint>:1:5: parse error on input ‘∑’
23:01:15 <Welkin> > let (∑) = sum in (∑) [1..100]
23:01:16 <lambdabot>  5050
23:01:20 <solatis> ewww
23:01:23 <Welkin> > let (∑) = sum in ∑ [1..100]
23:01:24 <lambdabot>  <hint>:1:18: parse error on input ‘∑’
23:01:47 <pavonia> > let Σ = sum in Σ [1..100]
23:01:47 <Welkin> solatis: that depends
23:01:48 <lambdabot>  Not in scope: data constructor ‘Σ’Not in scope: data constructor ‘Σ’
23:01:59 <pavonia> Ah, right
23:02:05 <Welkin> you won't be able to do any calculations unless you know it is integral or fractional
23:02:12 <Welkin> otherwise you need to convert it
23:02:33 <Welkin> :t (/)
23:02:34 <lambdabot> Fractional a => a -> a -> a
23:02:35 <solatis> right
23:02:37 <Welkin> :t (div)
23:02:38 <lambdabot> Integral a => a -> a -> a
23:02:57 <solatis> in my case, i only need to do (- 1), and pattern match on 0
23:03:08 <Welkin> :t (*)
23:03:09 <lambdabot> Num a => a -> a -> a
23:03:16 <solatis> :T (-)
23:03:16 <Welkin> :t (^^)
23:03:16 <lambdabot> (Integral b, Fractional a) => a -> b -> a
23:03:20 <Welkin> :t (**)
23:03:21 <lambdabot> Floating a => a -> a -> a
23:03:25 <solatis> :t (-)
23:03:25 <lambdabot> Num a => a -> a -> a
23:03:32 <solatis> right, so Num will suffice
23:03:33 <Welkin> (-) is just negate
23:03:35 <Welkin> :t negate
23:03:36 <lambdabot> Num a => a -> a
23:03:42 <Welkin> oh
23:03:48 <Welkin> I mean, if you want to take the negative
23:04:33 <solatis> no
23:04:44 <solatis> i want to call the function recursively N times
23:04:48 <Welkin> I see you want to subtract
23:05:01 <solatis> and after N has been reached, return the result
23:05:23 <Welkin> solatis: every expression produces a result
23:05:29 <solatis> in my case, i want a server to accept N sockets and then return a list with all the sockets
23:05:55 <solatis> so i have an acceptMany :: SockAddr -> Int -> [Socket] function
23:06:59 <solatis> i wonder if replacing the Int with Num a would be more idiomatic
23:07:44 <Taneb> solatis, why would you want to accept, eg, -2.6 sockets?
23:07:47 <Welkin> you could just use `take n . mkSocket`
23:08:18 <Welkin> mkSocket :: SocketAddr -> Handle
23:08:37 <Welkin> > take 2 []
23:08:39 <lambdabot>  []
23:08:46 <Welkin> it is safe as well
23:12:20 <solatis> Taneb: ehr, that makes sense :)
23:13:04 <solatis> Welkin: yeah that sounds reasonable
23:13:07 <Welkin> solatis: try not to write specific, one-time-use functions
23:13:14 <Welkin> write smaller, more general functions that you can compose
23:13:17 <Welkin> like I did above
23:13:23 <Welkin> it is more idiomatic
23:13:29 <Welkin> and better practice overall
23:13:36 <solatis> yeah i'm doing that already
23:13:51 <solatis> i have an acceptSocket and an acceptManySocket
23:14:13 <Welkin> acceptSocket is just `take 1 . mkSocket`
23:14:14 <solatis> acceptSocket just takes one, acceptManySocket executes that function N times
23:14:27 <Welkin> they are the same function
23:14:31 <solatis> i think acceptSocket = mkSocket
23:15:09 <Welkin> yes
23:15:12 <Welkin> you are correct
23:15:13 <solatis> why call it mkSocket by the way, when it requires a bound socket and only calls accept () on it ?
23:15:23 <solatis> mkSocket would imply creating a socket
23:15:34 <dgomez> > ( ‘div ‘ 3) . (+ 3) . (∗ 4)
23:15:35 <lambdabot>  <hint>:1:3: lexical error at character '\8216'
23:15:38 <solatis> while this obviously is *accepting* a connection (Socket) on an already-bound Socket :)
23:15:39 <Welkin> oh, I thought that is what you were doing
23:15:49 <solatis> no, i need to accept N sockets
23:15:58 <dgomez> ignore that...
23:16:16 <solatis> so create a new socket, bind it and then call accept N times :)
23:16:16 <Zemyla> Oh, someone on the Something Awful forums was explaining monads, and the person he was explaining to said, "all I see is types, where is the data? does it actually dosomething or just creates types?"
23:16:21 <Welkin> dgomez: are you having trouble with your keyboard?
23:16:53 <Zemyla> Someone else replied, "this is an open question about all haskell programs ever written"
23:17:00 <Welkin> `div` is the infix form of div, surrounded by backticks (same as the tilde key)
23:17:45 <Welkin> Zemyla: actually, most of my programs *are* just types and instance of typeclasses
23:17:55 <dgomez> > ( `div ` 3) . (+ 3) . (∗ 4)
23:17:56 <lambdabot>  Not in scope: ‘∗’
23:18:19 <dgomez> Welkin: thanks,.
23:18:26 <Welkin> dgomez: there is no space between the naked operators and the partially applied value
23:18:37 <Welkin> dgomez: have you read Learn You A Haskell?
23:18:59 <Welkin> I think it explains how to use these infix/partially applied infix functions
23:19:05 <falafel> >((`div` 3) . (+ 3) . (* 4)) 3
23:19:08 <dgomez> Welkin: yes I have been for the past 2 days.
23:19:10 <Welkin> :t (*4)
23:19:10 <lambdabot> Num a => a -> a
23:19:19 <dgomez> Welkin: but I'll keep referring to it.
23:19:25 <falafel> > ((`div` 3) . (+ 3) . (* 4)) 3
23:19:26 <lambdabot>  5
23:19:53 <falafel> dgomez, you seem to be typing the wrong characters
23:19:55 <Welkin> oh, I suppose the spaces don't matter than in that case
23:20:26 <Welkin> although, you must have a space after the > for lambdabot to evaluate your expression
23:20:49 <Welkin> dgomez: all of your problems stem from typing the wring characters or not including a space after the ">"
23:20:53 <Welkin> wrong*
23:23:34 <Zemyla> "I guess the hardest part to swallow is that there are languages where the statement separator is something that had to be discovered by pioneering researchers and formalized by mathematicians, and understanding it is a badge of honor"
23:24:33 <Welkin> Zemyla: I noticed active hostility toward people who choose to use functional languages -- particularly haskell
23:24:40 <SharpGAF> Monads are statement separators?  I'm confused
23:25:08 <Zemyla> They're kind of programmable semicolons.
23:25:12 <Welkin> a sort of anti-intellectualism
23:25:27 <rtpg> anyone know of a good emacs plugin to autoformat haskell code to get that nice "block" code style I see most people use (having your ::s aligned properly and the like)
23:25:38 <Welkin> "if you use haskell, then you think you are better than everyone else and are an asshole, so I would never work with you or hire you"
23:25:52 <Zemyla> And it's mostly a way of relieving cognitive dissonance.
23:25:53 * hackagebot hPDB 1.2.0.2 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0.2 (MichalGajda)
23:26:18 <SharpGAF> Zemyla: Monads are?
23:26:47 <Welkin> eh, I would say the sequence (>>) function is like a semicolon
23:26:52 <falafel> SharpGAF, it is the eternal Haskell question, and until you used them it is hard to udnerstand
23:27:03 <Zemyla> "I'm a smart person" + "I can't understand monads" = either "I'm not as smart as I think" or "Monads suck amd aren't important anyways",
23:27:06 <Welkin> perhaps >>= as well, since in imperative languages you can assign variables
23:27:22 <Zemyla> And most people really don't like the first option.
23:27:50 <SharpGAF> I dunno, I think that's a wrong way of looking at it
23:28:10 <Welkin> it makes sense when you think about do-notation
23:28:20 <Welkin> it's like an imperative code block
23:28:40 <SharpGAF> Kinda, except you can't really do the usual imperative control flow in it
23:28:41 <Welkin> just desugar it to find the "semicolons"
23:28:56 <SharpGAF> (Not that that's a bad thing)
23:29:24 <falafel> SharpGAF, monads enforce the order of computation, but analogies fall short
23:29:48 <Zemyla> They always do.
23:29:57 <SharpGAF> "All analogies fail eventually" - ancient proverb
23:30:58 <dgomez> SharpGAF: umm, that's kind of like saying there's an exception to every rule… :/
23:31:07 <dgomez> :( *
23:31:38 <SharpGAF> dgomez: To me, it's a reminder not to try to take analogies too far, because if they fit perfectly they're not actually analogies :P
23:31:59 <Welkin> you cannot explain everything using analogies
23:32:27 <fresheyeball> hey, another question
23:32:36 <fresheyeball> is there a way to do a cabal install globally
23:32:41 <fresheyeball> and have it build in a sandbox?
23:32:48 <HeladoDeBrownie> "Well you see, Monad is like a specific typeclass with the following methods and laws…"
23:32:59 <Welkin> that reminds me of the moronic google programmer who would not accept any answer from a guest speaker unless it was a programming analogy
23:33:27 <Welkin> the guest speaker looked at him as though he was either a fool or on drugs
23:33:37 <Welkin> the lecture was on neuroscience
23:33:45 <falafel> I think the closes analogy is "interface", because it still maintains the abstract concept
23:33:48 <falafel> *closest
23:34:13 <SharpGAF> Interface is an overloaded term that could be used to describe all typeclasses though.
23:35:02 <Welkin> I think interface describes typeclasses quite well
23:35:13 <Welkin> so a Functor is just an interface to a type
23:35:23 <Welkin> if it is defined for that type
23:35:32 <falafel> SharpGAF, well, all terms in programming are overloaded, think of "function", or "functor"
23:35:33 <fresheyeball> since typeclasses can have defaults
23:35:45 <fresheyeball> aren't they more akin to abstract classes than interfaces?
23:35:45 <SharpGAF> True enough
23:35:54 <SharpGAF> Languages tend to develop their own terminology for the same concepts, too
23:35:59 <Welkin> I don't know what an "abstract class" is
23:36:08 <Welkin> but "interface" is a common term
23:36:14 <SharpGAF> And often reuse words from unrelated concepts in another language
23:36:15 <Welkin> I am not referring to the java jargon
23:36:28 <dgomez> > map (\x y – > (x * x) + (y + y) ) [12 ,5 , 8]
23:36:29 <lambdabot>  <hint>:1:11: parse error on input ‘–’
23:36:36 <SharpGAF> Java interfaces can have defaults too, as of Java 8
23:36:50 <dgomez> forgive me but i am using the dash it just keeps shortening it when i press enter
23:36:53 <dgomez> -  vs –
23:36:58 <dgomez> –
23:37:00 <dgomez> -
23:37:04 <falafel> dgomez, must be your client doing weird things
23:37:05 <dgomez> see?
23:37:16 <falafel> dgomez, you should be able to turn it off
23:37:22 <fresheyeball> abstract class is a thing in java and c#
23:37:31 <fresheyeball> its basically like an interface
23:37:36 <fresheyeball> but you can have defaults
23:38:07 <dgomez> falafel: ok, ill look into it via faq/website of the client im using then.
23:38:51 <solatis> hmz, i see at the prelude docs that `replicate` is under "infinite lists"
23:39:10 <solatis> but replicate accepts an Int that determines the length of the list
23:39:19 <solatis> so isn't it by definition not-infinite ?
23:39:46 <glguy> Zemyla, that sounds like a pretty terrible place to read about programming
23:39:54 <HeladoDeBrownie> solatis, you're right, that sounds like an oversight
23:40:11 <falafel> solatis, well, `repeat` produces an infinite list
23:40:12 <solatis> i would personally put it under "building lists"
23:40:31 <glguy> Also, monads aren't any more about enforcing order of execution than functions are
23:40:31 <solatis> repeat != replicate
23:40:35 <solatis> repeat is indeed infinite
23:40:39 <solatis> but replicate is not
23:40:45 <solatis> so why is replicate under 'infinite lists' ?
23:40:57 <solatis> anyway, is this worthy of a bug report ?
23:40:59 <falafel> solatis, yeah, but `replicate n x = take n (repeat x)`
23:41:05 <HeladoDeBrownie> solatis, i'd say so
23:42:15 <solatis> falafel: i know, but head x = take 1 (repeat x) doesn't make head infinite...
23:42:23 <solatis> ehr
23:42:28 <solatis> that was a wrong example
23:42:30 <solatis> anyway
23:42:37 <solatis> i'll submit a smallish bug report
23:43:01 <falafel> solatis, anyway, do that, not sure why it's classified there, I was trying to find the motivation if any
23:44:47 <solatis> ehr
23:44:59 <solatis> looking at the haskell.org site for a while i cannot find a bug tracker or anything
23:45:06 <solatis> where do i submit bug reports ?
23:45:31 <HeladoDeBrownie> solatis, maintainer listed here http://hackage.haskell.org/package/base
23:45:39 <solatis> d'oh
23:45:42 <solatis> of course
23:46:39 <glguy> Send your bug to the bug tracker listed there rather than the mailing list
23:47:00 <HeladoDeBrownie> oh, good point, i missed that
23:50:39 <Zemyla> Ohhh, I understand MonadPlus now!
23:51:48 <Zemyla> Hold on, is mzero necessarily a right zero for bind?
23:52:00 <Welkin> it's like monoid
23:52:13 <Zemyla> Like, is m >>= (const mzero) always mzero as well?
23:52:40 <Welkin> :t mzero
23:52:41 <lambdabot> MonadPlus m => m a
23:52:43 <Welkin> :t mplus
23:52:43 <lambdabot> MonadPlus m => m a -> m a -> m a
23:52:59 <Welkin> mzero is the identity for mplus
23:53:04 <Zemyla> @pl \m -> m >>= (const mzero)
23:53:04 <lambdabot> (>> mzero)
23:53:06 <Taneb> Zemyla, I don't believe so
23:53:14 <Taneb> eg, MaybeT IO
23:53:48 <Zemyla> Welkin: Yes, but mzero >>= f == mzero always.
23:54:25 <Zemyla> :t IO
23:54:26 <lambdabot>     Not in scope: data constructor ‘IO’
23:54:26 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
23:54:45 <Welkin> I read that mzero used to be in the typeclass MonadZero
23:55:11 <Welkin> and do blocks were required to have a MonadZero constraint in case of failure
23:55:23 <Welkin> instead we got fail in the Monad typeclass
23:55:48 <dhrosa> Zemyla: m >>= (const x) would always be x wouldn't it? regardless of whether it's mzero or not
23:56:24 <dhrosa> wait nvm
23:56:45 <Zemyla> Yes, but fail isn't always mzero.
23:56:52 <Welkin> Zemyla: exactly
23:56:56 <dgomez> damn, i couldn't resolve my issue with the dash – - – –
23:57:08 <dgomez> > map (\x y − > (x * x)) [3, 5]
23:57:08 <lambdabot>  <hint>:1:11: parse error on input ‘−’
23:57:13 <Zemyla> > [1, 2, 3, 4, 5] >>= (const mzero)
23:57:14 <Welkin> dgomez: just install a client that doesn't suck
23:57:15 <lambdabot>  []
23:57:24 <Welkin> dgomez: use irssi, or x-chat, or something else
23:57:58 <Welkin> dgomez: plus, you are putting an extra space where there should not be one
23:58:04 <Welkin> it is ->
23:58:13 <Zemyla> > (Just 5) >>= (const mzero)
23:58:15 <lambdabot>  Nothing
23:59:14 <dgomez> Welkin: thats what ill do. and I see that. thanks.
23:59:37 <solatis> :t sequence
23:59:39 <lambdabot> Monad m => [m a] -> m [a]
