00:03:02 <SharpGAF> Anything that allocates isn't O(1), strictly speaking
00:03:11 <SharpGAF> Close enough though.
00:03:45 <xpika> SharpGAF: what's allocates ?
00:03:46 <EvanR> with infinite memory
00:03:59 <EvanR> dequeue from the free list
00:04:54 <stephen_> What's a good automated coding-style checker for Haskell that can be integrated easily in the build-cycle? We're using an embedded DSL for some things, so flexible rule configuraiton is a big plus.
00:04:54 <stephen_>  
00:05:05 <SharpGAF> Hard to reason about an architecture with infinite memory, if we're not throwing physics completely out the window I assume it would eventually be O(distance away of the memory you're fetching), but maybe if you accessed it linearly...
00:06:24 <SharpGAF> xpika: http://en.wikipedia.org/wiki/Memory_management#DYNAMIC (not sure if I am answering the question you asked)
00:08:40 <xpika> SharpGAF: do you know of a list structure in haskell that does not allocate on append ?
00:08:50 <trap_exit> am I allowed to define global functions which start with _, i.e. _add ... or are these reserved by haskell internals?
00:08:58 <trap_exit> I've tested it, and i appear to be able to define such functions
00:09:00 <trap_exit> but I want to make sure there is no clash
00:09:13 * hackagebot yesod-bin 1.4.3.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.2 (MichaelSnoyman)
00:09:13 * hackagebot hsebaysdk 0.3.0.0 - Haskell eBay SDK  http://hackage.haskell.org/package/hsebaysdk-0.3.0.0 (ChristopherReichert)
00:09:50 <EvanR> allocating boxes or thunks is something ghc programs are really fast at
00:10:07 <EvanR> so seems like the only problem with the o(1) is the occasional gc
00:10:08 <SharpGAF> xpika: I wouldn't worry about it too much, Haskell allocates all the time
00:11:49 <SharpGAF> EvanR: Yeah, basically you either pay with GC or your allocator is ultimately at best O(log n) where n is the size of the address space (though it can be a pretty small constant)
00:11:59 <EvanR> malloc by comparison could relatively kill your C programs performance
00:12:06 <SharpGAF> You can usually think of it as O(1) unless you have hard realtime requirements
00:12:15 <SharpGAF> Eh, jemalloc isn't bad
00:12:45 <matematikaadit> xpika: maybe something like data X a = X { headx :: a, listx :: DList a }, then do append and concatenation on listx x :: DList a (which is O(1)) and head on headx x :: a which of-course O(1)
00:13:20 <stephen_> trao_exit: I don't know for this case specifically, but my understanding is one of GHC's strengths is that nearly everthing is implemented within haskell itself, which might suggest against special character-restrictions in normal code. ( The following is a great read on the archecture decisions made in implementing the compiler: http://www.aosabook.org/en/ghc.html)
00:13:22 <SharpGAF> Also when you have multiple threads running GC allocators have to deal with a lot of the same issues as manual ones
00:13:29 <EvanR> whats the point of the extra head
00:13:55 <SharpGAF> Mostly GC just presents an opportunity to defragment
00:14:21 <matematikaadit> https://hackage.haskell.org/package/dlist-0.7.1/docs/Data-DList.html it says that head was O(n)
00:19:08 * hackagebot MuCheck 0.2.0.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.2.0.0 (RahulGopinath)
00:20:47 <glguy> By
00:24:08 * hackagebot MuCheck-QuickCheck 0.2.0.0 - Automated Mutation Testing for QuickCheck tests  http://hackage.haskell.org/package/MuCheck-QuickCheck-0.2.0.0 (RahulGopinath)
00:29:08 * hackagebot MuCheck-SmallCheck 0.2.0.0 - Automated Mutation Testing for SmallCheck tests  http://hackage.haskell.org/package/MuCheck-SmallCheck-0.2.0.0 (RahulGopinath)
00:29:10 * hackagebot MuCheck-HUnit 0.2.0.0 - Automated Mutation Testing for HUnit tests  http://hackage.haskell.org/package/MuCheck-HUnit-0.2.0.0 (RahulGopinath)
00:29:12 * hackagebot MuCheck-Hspec 0.2.0.0 - Automated Mutation Testing for Hspec tests  http://hackage.haskell.org/package/MuCheck-Hspec-0.2.0.0 (RahulGopinath)
00:38:56 <trap_exit> what is the fastest Double -> Text conversion in haskell ? it's not 'show' for sure
00:38:59 <trap_exit> what is the fastest Double -> Text conversion in haskell ? it's not 'show' for sure
00:39:00 <trap_exit> what is the fastest Double -> Text conversion in haskell ? it's not 'show' for sure
00:42:58 <kvanb> EvanR: Theres a really interesting paper I read
00:43:16 <kvanb> which proves mathematically that a perfect GC is faster than perfect stack allocation
00:43:31 <kvanb> I just don't know what it's called, sorry.
00:44:09 * hackagebot syb 0.4.3 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.4.3 (JosePedroMagalhaes)
00:51:23 <xpika> what does it mean if an operation is amortized?
00:53:14 <kvanb> it means if you repeat it infinity times, it'll normalise
00:53:54 <kvanb> amortised Ologn might mean it could be O(1) best case and O(n) worst case, but over time it's most likely to average Ologn
01:02:21 <quchen2> xpika: Simple example: Imagine you wanted a data structure with very efficient addition of elements, and reasonably fast lookup. ([a], Set a) would be a candidate for this: it consists of the "small cache" [a] which can easily be added to, and the (comparatively slow to add) Set database.
01:02:45 <quchen2> For a lookup "does this exist in my ([a], Set a), you would have to search both the [a] and the Set a.
01:03:14 <quchen2> When you're adding lots of elements to the [a] (which is very quick, since consing to lists is O(1)), that list grows a lot.
01:03:33 <quchen2> Lookup of lists is O(n), so lookups become slower and slower the more you add to your structure.
01:03:36 <solatis> does Set have very efficient addition of elements?
01:03:43 <solatis> i suppose only with a hash-based implementation?
01:03:47 <kvanb> uhh, no.
01:03:57 <kvanb> Not in an immutable language like Haskell
01:04:00 <quchen2> O(log n), which is somewhat slower than O(1). Set is very efficient, but that's not my point.
01:04:13 <solatis> O(log n) ? are you sure ?
01:04:22 <solatis> that's lookup ?
01:04:30 <quchen2> Sets are balanced binary trees.
01:04:36 <kvanb> quchen you should continue amoeba, it was super cool ^_^
01:04:39 <solatis> addition is a lot more expensive, and might involve rebalancing the entire tree
01:04:44 <quchen2> kvanb: :-)
01:04:56 <quchen2> Anyway, at some point you want to commit your [a] into the Set a, which is an O(length-of-the-list) operation.
01:05:20 <quchen2> But you have to do this operation only every couple of inserts, so on average you can still add with O(1), and lookup with O(log n).
01:05:34 <quchen2> That was a bit handwavy, but it's the gist of amortized times.
01:05:45 <quchen2> solatis: No, addition is also O(log n).
01:05:50 <solatis> hmz
01:05:58 <solatis> what about rebalancing?
01:06:09 <quchen2> Sets are always balanced. If an addition requires rebalancing, all you have to do is rebalance a single node.
01:06:19 <solatis> ok
01:06:23 <quchen2> It's not like you have to rebuild the entire Set.
01:06:27 <solatis> no i know
01:07:22 <quchen2> The price for this autobalance is having a label at every node that tells you the imbalance of the child trees.
01:07:59 <solatis> ah right
01:08:30 <quchen2> Here's how balancing works: http://hackage.haskell.org/package/containers-0.5.6.2/docs/src/Data-Set-Base.html#ratio
01:08:56 <quchen2> You may also want to have a look at the paper behind Set/Map, http://groups.csail.mit.edu/mac/users/adams/BB/
01:08:59 <solatis> eep
01:09:01 <solatis> that code..
01:09:06 <quchen2> They're not complicated to read
01:09:12 <quchen2> solatis: Read the comment before, not the code.
01:09:17 <solatis> yeah i know
01:09:25 <quchen2> The comment tells you the logic, the code is about efficiency :-)
01:09:54 <solatis> yeah i have to admit that i never looked much more into maps than my own tree-based map and set implementations in college
01:10:10 <solatis> i'm sure that's about as far detached from reality as it can be :)
01:10:57 <quchen2> From a user's perspective, Set is opaque. You know the cost of the operations from the docs and that's it. That it's implemented as a tree is an operational detail.
01:11:14 <solatis> yeah well
01:11:23 <quchen2> Set might also use unordered lists for storage for what it's worth.
01:11:28 <solatis> tell that to a c++ hashmap implementation i used
01:11:44 <solatis> and was the cause of occasional severe performance degradations
01:12:14 <solatis> "insert is O(1), woot!"
01:12:17 <solatis> "no it's not"
01:12:42 <solatis> insert at the wrong moment, and the entire table has to be resized & reallocated
01:12:55 <quchen2> Remember, Graham's Number is O(1) as well
01:13:04 <solatis> hehe
01:13:13 <quchen2> O(1) doesn't really mean much for runtime behaviour
01:13:22 <solatis> yeah good point
01:13:29 <solatis> O(1) can still take an enternity
01:13:33 <solatis> i guess Pi is O(1) too :)
01:13:52 <quchen2> Cracking AES-256 is O(1), Quicksort is O(n!) in the best case, etc etc
01:14:32 <solatis> yeah but my point was that the reallocations of that hashmap clearly was O(n), not O(1), yet they claimed inserts to be O(1)
01:14:45 <solatis> but in 99.99% of the cases it is O(1)
01:14:58 <quchen2> "Amortized O(1)"?
01:15:38 <solatis> ah
01:15:48 <solatis> http://www.cplusplus.com/reference/unordered_map/unordered_map/insert/ talks about average and worst case now
01:16:36 <solatis> but that is only part of the STL since c++11
01:25:39 <SharpGAF> solatis: Like I said earlier, O(1) is virtually always a lie for any insertion operation into an unbounded collection
01:26:51 <solatis> SharpGAF: i agree with you :)
01:28:16 <SharpGAF> Anyway the funnier thing about HashMaps is that depending on the size of your data, they can be slower than binary search :)
01:28:26 <SharpGAF> Despite O(1) access
01:30:06 <solatis> SharpGAF: didn't php use strlen() as hash function ?
01:30:32 <solatis> (in other words: also depending upon the implementation)
01:30:37 <SharpGAF> Haha, also depending on the hash function of course
01:30:45 <SharpGAF> I meant even with fast hashes like xxHash
01:30:57 <SharpGAF> Or even fairly weak (insecure) ones
01:31:01 <solatis> no what i mean is collissions
01:31:08 <SharpGAF> Er, sure
01:31:17 <solatis> in that case, lookup and insert is O(n)
01:31:28 <SharpGAF> Fast hashes are in (large) part determined by having good distribution though
01:46:54 <ChristianS> SharpGAF: indeed, Data.Map.Strict is generally faster for me than Data.HashMap, even for pretty large collections. but of course, HashMap isn't really a hash table either.
02:18:58 <Phillemann> I have a function that should work on lists as well as, for example, Set. It gets a list/set and returns one by adding elements to it. Is there a way to write this in a generic fashion? Both [] and Set are monoids, but a monoid has no "insert a single element" function. However, there is "[a]" and "singleton a" to embed an element.
02:20:01 <Phillemann> Is there another type class capturing "monoid plus return/pure"?
02:23:36 <indiagreen> Phillemann: well, there's Pointed
02:23:40 <indiagreen> @hackage pointed
02:23:40 <lambdabot> http://hackage.haskell.org/package/pointed
02:25:47 <Phillemann> Ah ok, so there's two type classes for that.
02:25:53 <Phillemann> Thanks :)
02:30:44 <dhrosa> Phillemann: if Pointed didn't exist, you could have also made your own typeclass that Set and List could have instances of
02:30:53 <Phillemann> Heh, there's actually sources mentioning "pointed monoids"
02:32:18 <geekosaur> edison package?
02:32:45 <geekosaur> (I don't know if that's even been kept up to date)
02:41:59 <dhrosa> so, Parsec has the ability to be part of a monad transformer stack, which lets you have context and side-effects while parsing. Aeson uses attoparsc, which doesn't implement this, meaning your parseJSON function can't have context
02:42:12 <dhrosa> does anyone know if there is a JSON parser that uses a Parsec-style thing?
02:44:00 <fread2282> how does GHC represent user-defined data tyes?
02:44:07 <fread2282> (in it's IR)
02:44:43 <fread2282> *types
02:54:14 * hackagebot objective 0.6.3.3 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.3.3 (FumiakiKinoshita)
02:54:51 <dhrosa> objective h!
03:46:06 <dhrosa> @pl runSlack tok = flip evalStateT (slackAuth tok) . runEitherT . runSlackInternal . (slackInit >>)
03:46:06 <lambdabot> runSlack = (. (runEitherT . runSlackInternal . (slackInit >>))) . flip evalStateT . slackAuth
03:46:16 <dhrosa> because that needed to look even grosser
03:50:43 <kvanb> dhrosa: I prefer (>> slackInit)
03:51:23 <kvanb> but that's not that ugly, really
03:51:38 <kvanb> see what it looks like by adding the missing argument and seperating with $'s or something
03:52:07 <dhrosa> kvanb: my brain gets confused by partially applied (.)
03:52:23 <dhrosa> kvanb: well, I can't have (>> slackInit), I need the slackInit to happen first
03:56:48 <kvanb> dhrosa: doh, well, <<
03:56:51 <kvanb> but I read that wrong, actually
03:57:03 <kvanb> I presumed (>> x) would be ((>>) x)
03:57:12 <dhrosa> nope :)
03:57:31 <kvanb> there should be runStateT'
03:57:35 <kvanb> which is flip runStateT
03:57:36 <kvanb> ;_;
03:57:49 <dhrosa> yeah I find it more intuitive in the flipped version
03:57:58 <kvanb> Im pretty sure there has been like 100 reddit threads on runStateT
03:58:08 <kvanb> :t runStateT
03:58:09 <lambdabot> StateT s m a -> s -> m (a, s)
03:58:37 <dhrosa> walkStateT
03:58:47 <kvanb> alternatively theres ..
03:58:53 <kvanb> :t (&)
03:58:54 <lambdabot> a -> (a -> b) -> b
03:59:13 <kvanb> > :t (runStateT &)
03:59:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:59:19 <kvanb> :t (runStateT &)
03:59:20 <lambdabot> ((StateT s m a -> s -> m (a, s)) -> b) -> b
03:59:46 <kvanb> interesting, I thought & was supposed to be flip from Data.Function
03:59:53 <kvanb> maybe I misread edwards post earlier today
04:00:03 <kvanb> lens flip is ??
04:00:13 <kvanb> :t (runStrateT ??)
04:00:13 <lambdabot>     Not in scope: ‘runStrateT’
04:00:14 <lambdabot>     Perhaps you meant one of these:
04:00:14 <lambdabot>       ‘runStateT’ (imported from Control.Monad.State),
04:00:14 <kvanb> :t (runStateT ??)
04:00:15 <lambdabot> s -> StateT s m a -> m (a, s)
04:02:29 <kvanb> > 3 & (+1) & (+2)
04:02:31 <lambdabot>  6
04:02:46 <kvanb> > (+2) $ (+1) $ 3
04:02:47 <lambdabot>  6
04:02:54 <kvanb> nailed it.
04:04:44 <zipper> What does ':.' mean?
04:05:06 <mmmm> :t (:.)
04:05:06 <lambdabot>     Not in scope: data constructor ‘:.’
04:05:07 <lambdabot>     Perhaps you meant one of these:
04:05:07 <lambdabot>       ‘:+’ (imported from Data.Complex),
04:05:54 <zipper> Used here ` data List t = Nil | t :. List t '
04:10:57 <EvilTerran> zipper, that line defines it
04:11:36 <EvilTerran> operators starting with a colon are constructors
04:11:57 <EvilTerran> "data List t = Nil | (:.) t (List t)" would be equivalent
04:12:29 <zipper> EvilTerran: I see. :)
04:12:47 <zipper> takes a value and the rest of the list which is another list
04:13:15 <jle`> yeah, same as something like data List t = Nil | Cons t (List t)
04:13:17 <EvilTerran> exactly. if that definition's in scope, then (:.) :: t -> List t -> List t.
04:31:14 <kvanb> happy new year from gmt+10
04:34:48 <zipper> kvanb: Wow dude.
04:34:56 <zipper> kvanb: Where exactly?
04:36:17 <kvanb> zipper: melbourne australia
04:36:28 <kvanb> actually like 20 minutes early, but screw it im going to bed.
04:36:34 <nkar> lol
04:36:40 <zipper> kvanb: nice
04:37:25 <zipper> kvanb: You write haskell there for a living? Many haskell jobs there?
04:38:02 <kvanb> I write javascript for a living
04:38:08 <kvanb> Haskell is who I cheat on.
04:38:42 <edwardk> i do kind of wish i'd taken (?) for lens's flip, but I bowed to pressure and its too late now ;)
04:38:56 <kvanb> ?? looks stupid
04:38:56 <lambdabot>  looks stupid
04:39:01 <kvanb> grr.
04:39:09 <kvanb> even lambdabot mocks it
04:39:18 * hackagebot websockets 0.9.2.2 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.2.2 (JasperVanDerJeugt)
04:39:34 <kvanb> edwardk: what about ><
04:39:55 <edwardk> what about it?
04:40:00 <edwardk> ?? at least looks like a placeholder
04:40:00 <lambdabot>  at least looks like a placeholder
04:40:23 <edwardk> foo ?? 1   -- becomes \x -> foo x 1
04:40:36 <edwardk> ? would have made it a little less noisy
04:40:52 <edwardk> but folks wanted to be able to use it for other things
04:40:55 <edwardk> so i left it alone
04:41:04 <kvanb> I wonder if it will ever become a ternary operator
04:41:14 <kvanb> foo ? bar $ qux
04:41:31 <edwardk> you can't bind it nicely enough to make that one go
04:41:39 <edwardk> you can use foo ? (bar, baz)
04:42:03 <kvanb> hey that'd be neat
04:42:13 <kvanb> if / then / else is really long
04:42:14 <nkar> edwardk: cannot you hide ? in lens, or are you trying to avoid conflicts?
04:42:31 <kvanb> the new bool even, is not as nice as C ternary
04:42:44 <kvanb> > bool True 1 2
04:42:45 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
04:42:45 <lambdabot>    arising from the literal ‘1’
04:43:53 <bennofs> @let a $: b :$ c = if a then b else c
04:43:54 <lambdabot>  Parse failed: Parse error in pattern:
04:45:16 <kvanb> bennofs: there as an implementation of that in my head
04:45:19 <kvanb> which is splendidly evil
04:45:39 <kvanb> in that $: returns undefined when !a
04:45:54 <bennofs> > True $: 3 :$ 5
04:45:55 <lambdabot>  3
04:46:21 <kvanb> bennofs: is that in a library already?
04:46:22 <quxbam`> when i have multiple forks which want to putStr, how can I ensure that they don't print at the same time?  With MVars or does there exist something more specific?
04:46:46 <bennofs> kvanb: data T a b = a :$ b   and  a $: (b :$ c) = if a then b else c    ;) (this is an old trick I think)
04:46:57 <bennofs> kvanb: not sure if it's in some library
04:47:17 <kvanb> oh gosh
04:47:52 <bennofs> It's like the tuple variant, just with nicer syntax for the tuple
04:50:20 <quxbam`> any ideas?
04:50:29 <kvanb> oh forgot to answer
04:50:44 <kvanb> so basically, you have a couple of options, one of which is an mvar
04:51:13 <kvanb> a better one is to fork a thread dedicated to printing and have it read from either an MVar or a TVar list (or Chan, or TQueue, or similar)
04:51:23 <kvanb> then to just push strings to it as you work from the other forked threads
04:52:01 <kvanb> that fork will wake up occasionally and flush the things to the console in the right order and without mixing them up
04:52:24 <kvanb> also means you can very easily silence the logging or whatever from one place
04:52:56 <quxbam`> ah ok
04:53:11 <quxbam`> and is this not costly if the strings are large?
04:53:18 <kvanb> nah its not
04:53:25 <kvanb> you're just storing a pointer
04:53:50 <quxbam`> thank you!
04:53:52 <kvanb> the way I'd personally do it, its a bit overkill, is pull in something like pipes-concurrency
04:54:13 <kvanb> and run a pipes consumer and yield strings up to it via a set sized buffer
04:54:26 <Saizan> having a lot of VOID in the biographical profiling is bad, right?
05:00:07 <kvanb> Saizan: might be better to ask that one on reddit or stack ovreflow if you're keen
05:00:20 <kvanb> finding people who know the profiler well is hard
05:01:05 <bennofs> Last time I tried biographical profiling my program segfaulted if I enabled it :P
05:01:28 <kvanb> admittedly profiling usually gives me bullshit results
05:02:07 <arianvp___> Any people from the haskell community going to Fosdem next year?
05:02:25 <arianvp___> It's next month. but next year sounds so much cooler in week 52 (or is it week 1. who knows)
05:02:49 <kvanb> what is fosdem
05:03:24 <tassmjau> arianvp___: www.vecka.nu always knows :)
05:03:45 <kvanb> anyway
05:03:48 <kvanb> happy new year for real
05:04:32 <kvanb> happy hacking the One True Language
05:04:35 <kvanb> lul, night
05:04:48 <arianvp___> tassmjau: Isn't it week 52 in the state though? depends which ISO standard you look at?
05:05:10 <arianvp___> s/state/States
05:06:54 <Saizan> bennofs: it depends on the options you add
05:08:03 <tassmjau> arianvp___: I don't know acutally, but that would be super weird :)
05:09:07 * EvilTerran prefers to do ternary ops as something like "p ?: x = guard p >> return x; (?!) = flip fromMaybe"
05:09:50 <EvilTerran> that way the two parts are actually kinda useful by themselves as well
05:12:11 <vin-ivar> hi
05:12:12 <EvilTerran> (equivalently, sans polymorphism: True ?: x = Just x; False ?: x = Nothing; Just x ?! y = x; Nothing ?! y = Nothing)
05:12:12 <vin-ivar> quick question
05:12:28 <vin-ivar> data Maybe a = Just a | Nothing
05:12:53 <vin-ivar> is an object-oriented analogy that 'Just' and 'Maybe' are templated classes? With 'a' being the data type?
05:13:01 <vin-ivar> or am I completely off?
05:13:50 <EvilTerran> that's sort of similar, yes
05:14:16 <EvilTerran> Scala uses that analogy for its version of algebraic data types
05:14:34 <vin-ivar> phew
05:14:36 <vin-ivar> thanks!
05:17:52 <joe9> https://hackage.haskell.org/package/http-client-0.4.6.1/docs/src/Network-HTTP-Client-Types.html#responseBody I get "Page not found"? I do not want to browse the source in github. Is there a better/later version of hackage anywhere else?
05:20:03 <EvilTerran> vin-ivar, I suppose the main simularity is that "sum types" (data ... = ... | ...) and subclassing are both ways of having different types of value under the same type
05:20:48 <edwardk> nkar: its about minimizing conflicts, we try to make sure that lens can be imported unqualified for the vast majority of users
05:21:24 <EvilTerran> vin-ivar, for instance, if you had something in haskell like "data Value = StrVal String | IntVal Int", that'd be roughly analogous to something like "interface Value { ... }; class StrVal implements Value { string val; ... }; class IntVal implements Value { int val; ... }"
05:21:36 <davidfetter> mornin', edwardk
05:21:45 <edwardk> mornin
05:21:55 <EvilTerran> vin-ivar, it's not a perfect analogy, but it's a good place to start
05:22:07 <edwardk> davidfetter: didn't make it out to the gsoc mentor summit this year, so i didn't get a chance to say hi
05:22:32 <davidfetter> edwardk, i didn't either.
05:22:38 <edwardk> ah then nothing lost =)
05:23:08 <davidfetter> edwardk, lemme know next time you're in the bay area. i don't think i'll be traveling much the next couple of years
05:23:14 <edwardk> fair nuff
05:23:28 <davidfetter> kid[3] is due in june. kid[0] turned 3 in august
05:23:33 <edwardk> i'm going to try to head out there for bayhac assuming it doesn't conflict with other travel
05:23:42 <davidfetter> :)
05:24:10 <edwardk> speaking of which i should ping jfischoff and figure out when that'll be
05:24:18 <davidfetter> w00t
05:24:29 * davidfetter really needs to figure out how to work haskell into $work
05:24:50 <Cale> vin-ivar: Though, if you want to do OOP in Haskell, probably the right way is not to use sum types, but rather, just make record types with the methods as fields, since functions and IO actions are first class.
05:25:18 <vin-ivar> cheers, EvilTerran, it's making sense now
05:25:32 <Cale> vin-ivar: You can then define a bunch of different "constructor" functions for building records of the same type, which behave a little bit like "subclasses", without actually involving subtyping.
05:25:35 <vin-ivar> Cale, I don't want to do OOP, I wanted some sort of analogy
05:25:48 <vin-ivar> yep, makes sense
05:26:22 <vin-ivar> it's just the "a" that didn't make sense initially. That's a stand-in for the type, right?
05:26:26 <vin-ivar> Just Int, etc
05:26:51 <Cale> The 'a' in  data Maybe a = Nothing | Just a does stand for a type, yes
05:27:17 <davidfetter> speaking of work, i need to head out. ah, the joys of commuting by public transit...
05:28:02 <vin-ivar> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
05:28:06 <vin-ivar> ^this is lovely :D
05:28:22 <Saizan> vin-ivar: you've to read the declaration a bit like a BNF grammar, if you are familiar with those
05:28:32 <Cale> Though be careful, the syntax of data declarations is a bit funny -- the first thing in each | separated group is the name of a data constructor, and it's followed by a sequence of space-separated types which are the types of its arguments. Normally, writing Just Int anywhere else in the language would be an error.
05:29:01 <Cale> (Because Just is a data constructor, so it lives in the world of values, while Int lives in the world of types)
05:29:30 <vin-ivar> yeah, that's what I thought as well, Saizan
05:29:50 <vin-ivar> thanks, Cale
05:29:56 <Cale> There's an alternate syntax for data declarations which would let you write it as:
05:30:00 <Cale> data Maybe a where
05:30:04 <Cale>   Nothing :: Maybe a
05:30:09 <Cale>   Just :: a -> Maybe a
05:30:11 <edwardk> davidfetter: later man
05:30:36 <vin-ivar> Nothing would construct a Maybe of what type, though?
05:30:43 <Cale> any type at all
05:30:48 <edwardk> vin-ivar: Maybe a -- any type you want
05:30:52 <vin-ivar> It takes no arguments, so what type is the resultant a?
05:30:54 <vin-ivar> I see
05:30:56 <vin-ivar> hang on
05:31:17 <vin-ivar> ah, it's a blank slate
05:31:36 <Cale> You can demand that it be any type that you want by adding an explicit type signature, or don't and it'll be generalised
05:31:39 <Cale> :t Nothing
05:31:40 <lambdabot> Maybe a
05:31:43 <Cale> :t Nothing :: Maybe String
05:31:44 <lambdabot> Maybe String
05:31:49 <Cale> :t Nothing :: Maybe Integer
05:31:49 <lambdabot> Maybe Integer
05:32:44 <vin-ivar> but what possible use case could that have? Why would I want a type signature on Nothing?
05:33:21 <Cale> Well, you usually wouldn't have to be explicit about this in particular, since usually the context would determine which type of Maybe you wanted.
05:33:40 <c_wraith> vin-ivar: sometimes inference is ambiguous and you need to clarify
05:33:54 <c_wraith> vin-ivar: usually when a type class is involved, but there are other cases.
05:36:02 <Cale> > let f m = case m of Nothing -> "there was nothing"; Just x -> "got: " ++ x in f Nothing -- here, it's able to deduce that the Nothing should be a Maybe String value, because we've applied f to it, and it infers that f :: Maybe String -> String
05:36:03 <lambdabot>  "there was nothing"
05:36:14 <Cale> > let f m = case m of Nothing -> "there was nothing"; Just x -> "got: " ++ x in f (Just "hello")
05:36:15 <lambdabot>  "got: hello"
05:36:45 <Cale> :t let f m = case m of Nothing -> "there was nothing"; Just x -> "got: " ++ x in f
05:36:45 <lambdabot> Maybe [Char] -> [Char]
05:37:32 <matematikaadit> :t Nothing `asTypeOf` Just "value"
05:37:32 <lambdabot> Maybe [Char]
05:38:50 <vin-ivar> I see
05:38:55 <vin-ivar> thanks
05:38:59 <vin-ivar> that sort of makes sense
05:39:03 <vin-ivar> I'll still need some time, haha
05:56:28 <favetelinguis> is a surjective function always an isomorphism?
05:58:02 <Saizan> nope
05:58:34 <Saizan> any function into () is surjective, but no function Bool -> () is an isomorphism
05:58:34 <danielduong> favetelinguis, exemple f:R->R+, f(x) = x^2 is a surjective
05:58:43 <danielduong> function
05:58:57 <favetelinguis> i need a bijective function for it to be an isomorphism?
05:59:25 <Saizan> yeah, that's what isomorphism of sets is
05:59:39 <exio4> isomorphisms are a generalization of bijective functions
06:01:15 <favetelinguis> is it correct to say that in the world of set theory isomorphisms does not exist but are called bijective functions, isomorphisms exist only in the world of chategories?
06:03:47 <Saizan> favetelinguis: the term was around before category theory
06:04:14 <Saizan> favetelinguis: it roughly meant "bijective homomorphism"
06:04:51 <danielduong> favetelinguis,  well a morphism has a notion of structure. Like a group or a vector space or whatever
06:06:55 <quxbam> is there a function, which takes a tuple and aplys the snd to the fst?
06:07:05 <exio4> (snd.fst)?
06:07:16 <quxbam> I searched on hoogle for (a -> b, a) -> b
06:07:21 <exio4> oh
06:07:37 <exio4> sounds like uncurry ($)
06:07:40 <exio4> :t uncurry ($)
06:07:41 <lambdabot> (b -> c, b) -> c
06:07:48 <quxbam> ahh
06:09:21 * hackagebot cblrepo 0.14.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.14.0 (MagnusTherning)
06:09:49 <quxbam> thank you
06:16:46 <quxbam`> i don't get my head around a problem with uncurry
06:17:06 <quxbam`> mapM_ (\(fun,l) -> forkIO $ putMVar printer $! fun l) xs
06:17:21 <quxbam`> i've got that one, and want to eta reduce the lambda
06:17:29 <quxbam`> mapM_ (forkIO . putMVar printer . uncurry ($!)) xs
06:17:40 <quxbam`> that type checks, but hangs my computer
06:18:51 <Saizan> mapM_ (forkIO . putMVar printer . uncurry ($!)) xs
06:19:08 <Saizan> quxbam`: mapM_ (forkIO . (putMVar printer $!) . uncurry) xs
06:19:23 <c_wraith> that looks better
06:19:39 <quxbam`> can you explain the difference, please?
06:19:42 <Saizan> uncurry ($!) (fun, l) = fun $! l
06:20:19 <Saizan> so you were forcing l before forcing (fun l), but nothing was forcing (fun l) there
06:22:03 <quxbam`> hm, at least in my situation, the type checker rejects it
06:23:16 <Saizan> ?type (forkIO . (putMVar ?printer $!) . uncurry)
06:23:17 <lambdabot> Not in scope: ‘forkIO’
06:23:17 <lambdabot>     Not in scope: ‘putMVar’
06:23:17 <lambdabot>     Perhaps you meant ‘putChar’ (imported from Prelude)
06:25:51 <Saizan> quxbam`: oh, sorry, uncurry ($)
06:25:51 <c_wraith> you need something like  mapM_ (forkIO . (putMVar printer $!) . uncurry id) xs
06:26:16 <quxbam`> i'll try
06:26:20 <c_wraith> uncurry id is slightly shorter to type!
06:26:26 <c_wraith> though functionally identical
06:26:40 <Saizan> harder to read!
06:26:54 <c_wraith> I've eventually learned that ($) is just id anyway. :)
06:27:17 <exio4> ($) is just the infix version of id
06:29:44 <quxbam`> hmm, this type checks, but also hangs my pc, propably spaning loads of forks
06:30:08 <quxbam`> and is only one char shorter than the original function, which works
06:30:20 <quxbam`> any clue why they behave different?
06:31:31 <Saizan> the should both spawn the same amount of forks
06:32:27 <Saizan> quxbam`: compiling with -O?
06:32:35 <quxbam`> with -O2
06:33:37 <quxbam`> xs is basically an infinite list, which gets constructed from user input, which gets parsed, if that matters
06:35:25 <Saizan> well, spawning infinite threads doesn't seem wise :)
06:36:10 <quxbam`> it is lazy, it spawns only one, if the user provided enough instructions to make a computation
06:36:17 <quxbam`> and the other function works
06:39:28 <fread2282> how can a trifecta parser of the form try a <|> pure b  fail?
06:46:05 <Saizan> quxbam`: are you producing xs lazily? with some unsafeInterleaveIO?
06:46:18 <quxbam`> with B.getContents
06:46:35 <quxbam`> which is consumed by a lazy parser iterator
06:46:47 <quxbam`> which returns a result list of parses
06:47:30 <Saizan> quxbam`: when you say "hangs" you mean it consumes a lot of memory/cpu or the program simply stops responding?
06:47:53 <quxbam`> it consums 100% of my 4gb ram and 100% of my cpu
06:48:20 <quxbam`> i assume, that somehow it spawns a fork, even if there is not a content for the list element
06:48:34 <quxbam`> and therefore spawning infinite many forks
06:48:40 <quxbam`> but not in the other case
06:49:27 <Saizan> there cna't be more calls to forkIO than cons cells in xs
06:51:42 <quxbam`> if you mind, the code is in http://github.com/knupfer/haskell-emacs
06:52:09 <quxbam`> i've added the alternative commented out into main
06:52:25 <quxbam`> if you compile and run it, it does idle waiting
06:52:58 <quxbam`> and if you uncomment the two lines and comment the two lines above, it hangs (at least with ghc7.8.4)
06:56:14 <Saizan> oh, xs is indeed infinite, because you use iterate
06:56:19 <quxbam`> yes
06:56:48 <quxbam`> but it is generated on the fly, it's like a little server for haskell functions, which can be called from emacs
06:58:04 <Saizan> no, i meant it's infinite from the start
06:58:23 <Saizan> you don't need user input to keep producing new cons cells, only the data inside
06:58:40 <Saizan> so yeah, the lambda was blocking on the tuple
06:59:03 <quxbam`> and why does the other version work?
06:59:23 * hackagebot crypto-numbers 0.2.6 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.6 (VincentHanquez)
06:59:24 <quxbam`> because the tuple wasn't already existent?
06:59:28 <Saizan> right
06:59:38 <quxbam`> quite tricky
06:59:50 <quxbam`> so the two functions are indeed different
07:00:16 <Saizan> yeah, you'd need to make forkIO's application strict as well
07:01:45 <quxbam`> so probably, the first function is the clearest
07:02:08 <quxbam`> i learned a lot, thank you Saizan
07:02:38 <deech> How do I maintain a constraint on a Maybe type? eg. `(Some-constraint a) => Maybe a` fails to typecheck if passed `Nothing`.
07:04:13 <c_wraith> deech: Nothing is a value of a type that unifies with your example, but that example can make inference fail
07:04:38 <c_wraith> deech: inference might fail in that case if there's no way to determine what type a is (in the program as a whole)
07:05:17 <Saizan> quxbam`: that iterate seems like a liability, i'd produce a cons cell only after the parse went through
07:05:22 <deech> c_wraith: Is the answer to not use Maybe?
07:05:44 <Saizan> quxbam`: or i suppose you could add a function that forces the tuples before returning the tail
07:05:45 <c_wraith> deech: no, the answer is to make sure that there's enough context to determine the type a eventually
07:06:11 <deech> c_wraith: I see, thanks!
07:06:37 <quxbam`> why is iterate in my case not advisable?
07:07:16 <Saizan> quxbam`: because of the subtleties we've just experienced
07:08:50 <quxbam`> how could i produce a cons only after a parse? this is more or less my first haskell programm, so I need a bit hand holding
07:09:18 <quxbam`> i tried it with many in the parser, but i didn't get that to work
07:11:14 <Saizan> well, you only need to modify nextParse
07:11:39 <fread2282> :t (Nothing :: Show a => Maybe a)
07:11:40 <lambdabot> Show a => Maybe a
07:12:11 <Saizan> or actually
07:12:33 <Saizan> just define force [] = []; force (x:xs) = x : x `seq` force xs
07:13:28 <quxbam`> interesting, i read about that in real world haskell
07:13:41 <Saizan> fullParse c = force . map snd . tail $ iterate nextParse (c,(const "",nil))
07:15:51 <quxbam`> ok, i understand
07:16:27 <quxbam`> so in this case, it would only be for clarity, because lambda has the function of the force function
07:16:34 <Saizan> yah
07:17:27 <quxbam`> and is this clarity good? Obviously, clarity seems to be a good idea, but it is as well in this case redundance, what do you think?
07:17:45 <quxbam`> redundant
07:17:48 <quxbam`> redundant
07:17:50 <quxbam`> :)
07:18:24 <Saizan> i guess you could also write a comment? or both? it's not going to cost much at runtime
07:19:37 <quxbam`> i think i'll stick with a comment, so i'm reminded how this language works
07:23:54 <quxbam`> happy new year saizan, i'm going for lunch
07:25:20 <Merlin`> hello. why does this happen?
07:25:29 <Merlin`> ghci> do done <- newMVar False; putMVar done True; takeMVar done
07:25:32 <Merlin`> *** Exception: thread blocked indefinitely in an MVar operation
07:26:27 <Saizan> quxbam`: cheers
07:26:57 <Saizan> Merlin`: putMVar blocks until the mvar gets empty
07:27:39 <Merlin`> ah right..
07:28:12 <Merlin`> I want to wait for threads to finish by the way. is MVar what I should be using?
07:29:25 * hackagebot crypto-pubkey 0.2.7 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.7 (VincentHanquez)
07:29:52 <pxqr> is it possible to run a haskell program on jvm?
07:29:53 <fread2282> how can a trifecta parser of the form try a <|> pure b  fail? I have no clue what's ahppening but it seems like a parser is
07:31:32 <pxqr> i can google some disscussion but it is interesting if there is some changes
07:31:38 <pxqr> *discussions
07:32:56 <meretrix> Is there a good way to install configuration files with cabal or should I just do that with my bash install script?
07:34:17 <EvilTerran> fread2282, that does look like it shouldn't fail. is it possible the failure's actually happening somewhere nearby? we'd have to see more of the surrounding code to tell
07:34:21 <luite> meretrix: where do you want them to go?
07:34:22 <Saizan> meretrix: you can specify data-files in the .cabal file
07:35:13 <EvilTerran> fread2282, also, have you seen trifecta's "option :: Alternative m => a -> m a -> m a"? it looks like "option b a" might do what you need
07:35:41 <EvilTerran> or possibly option b (try a)
07:36:18 <EvilTerran> ... oh hey, "option b (try a)" would be the same as "try a <|> pure b" anyway - https://hackage.haskell.org/package/parsers-0.12.1/docs/src/Text-Parser-Combinators.html#option
07:41:56 <meretrix> luite: Is there a standard location in the ~/.cabal directory?
07:42:53 <meretrix> Saizan: Thanks, I think that was for what I as was looking.
07:45:16 <eyebloom> Can you place a partially applied type synonym in a type declaration?
07:47:13 <_um> I have an idle question: Anyone know why the `module` takes its list of exported functions as a tuple instead of as a list?
07:47:14 <EvilTerran> eyebloom, I believe you can only partially-apply type synonyms if their decleration is also partially-applied
07:47:35 <EvilTerran> for instance "type Foo = Maybe; type Bar = Foo" is okay, but "type Foo a = Maybe a; type Bar = Foo" is not
07:47:46 <shachaf> _um: It isn't a tuple or a list, it's syntax.
07:48:00 <_um> Oh! Well that explains that.
07:49:11 <eyebloom> EvilTerran: boom! That just solved it, thanks so much.
07:49:20 <luite> meretrix: yeah data-files go into share, i'd probably use that for installing a default config file. use the generated Paths_packagename module to find the location of your in your program
07:49:26 * hackagebot socket-io 1.3.0 -   http://hackage.haskell.org/package/socket-io-1.3.0 (OliverCharles)
07:49:38 <eyebloom> On to the next type error! :)
07:49:57 <luite> meretrix: and then i'd probably use something like getAppUserDataDirectory to first look in ~/.appname/config , if that doesn't exist then read the one from data-files (or perhaps copy it)
07:54:26 * hackagebot quoridor-hs 0.1.0.0 - A Quoridor implementation in Haskell  http://hackage.haskell.org/package/quoridor-hs-0.1.0.0 (talw)
07:54:42 <quxbam`> _um: well, beside that it's syntax, a list wouldn't make sense, because your functions aren't of the same type
07:55:22 <shachaf> Well, it could be a list of names, or something. Or a list of exports. Certainly a list of functions isn't enough because you're exporting by name.
07:57:52 <_um>  quxbam`: oh yeah!  I'm still adjusting to this statically typed world. I'm most familiar with Racket and Prolog, both of which do exports with lists (I think that's true of Racket any how). So I just assumed. But it's easy for me to forget the depths and details of the affects of the static typing.
07:58:39 <_um> shachaf: oh that makes sense too... You don't export the functions themselves, but just the reference to them?
07:59:26 <shachaf> I don't know what a reference to a function is.
08:00:05 <shachaf> But a function as a value -- e.g. the sort of thing that you'd put in a list or tuple -- is a separate thing from its name.
08:00:22 <shachaf> If you write f = g, then f is really equal to g. That means you can't ask for the name of a function.
08:00:37 <shachaf> (Or a variable in general, of course.)
08:01:19 <_um> So it's improper to speak of a functions name as "referring to it"?
08:01:36 <_um> What's the term to describe the relation between a function and it's name?
08:02:58 <_um> (In the case that this evince a substantial gap in my understanding I'd welcome directions to documentation or, to some basic concepts I should read up on).
08:06:06 <narendraj9> I think functions are like lambda expressions bound to a name. The expression doesn't have to know the name. It probably can't know the name.
08:06:47 <EvilTerran> yeah, a function's just a value - names don't exist at runtime
08:09:33 <danem> What is the lens equivalent to "modify (first foo)"?
08:12:14 <shachaf> Perhaps: _1 %= foo
08:13:30 <_um> If i understand you correctly, narendraj9 and EvilTerran, it would mean every function call is inlined during compilation, right
08:13:32 <_um> ?
08:13:49 <danem> shachaf thanks
08:14:14 * EvanR-work wakes up, recursive calls cant be inlined as such
08:14:56 <_um> EvanR-work: right.
08:15:08 <_um> That what is written here too: https://ghc.haskell.org/trac/ghc/wiki/Inlining
08:15:34 <_um> So there must be some sort of "reference" to the function--or maybe another term?--that is used for recursive functions...
08:16:06 <n4x> I don't understand what you are saying, but I think you may be talking about fix
08:16:09 <n4x> :t fix
08:16:09 <lambdabot> (a -> a) -> a
08:16:45 <EvanR-work> _um: yeah term for this would be loop unrolling
08:16:51 <EvilTerran> _um, not everything is necessarily inlined, no
08:17:23 <shachaf> I think we're talking about different things.
08:17:27 <EvilTerran> I think so
08:17:39 <narendraj9> Yes, we aren't talking about fix.
08:17:57 <_um> I'm trying to puzzle out the relation between the name of a function and it's definition.
08:18:41 <_um> But maybe this is different than the function's "value", since the latter should be whatever the function actually evaluates to?
08:18:43 <tremon> _um: as I understand it, there is a symbol generated by ghc for each expression that is not inlined, but I don't think you can consider them "functions" in the sense C sense
08:19:01 <_um> (Sorry if I'm talking in circles.)
08:19:13 <EvilTerran> _um, you can think of (part of the process of) compilation as converting the source code into a directed graph representation
08:19:27 * hackagebot libsystemd-journal 1.3.0 - Haskell bindings to libsystemd-journal  http://hackage.haskell.org/package/libsystemd-journal-1.3.0 (OliverCharles)
08:20:54 <Saizan> _um: the module system is not based on the reflection capabilities/macro system like in prolog
08:21:05 <EvilTerran> for example, if you had "ones = 1 : ones", that's the same as "ones = ((:) 1) ones", which would result in a graph with three nodes - two function applications, and a constant 1
08:21:10 <EvilTerran> (I'm oversimplifying, but you get the idea)
08:21:45 <shachaf> I think the question is at a higher level than "what does the generated code look like".
08:21:55 <_um> Saizan: I think I understand that. The discussion of "what if it were a list" sparked this new curiosity. But I might still be conflating things because of thinking in terms of macros...
08:22:24 <Saizan> _um: so names are mostly just things in the source code, they don't get manipulated by programs (until you start using TemplateHaskell i guess!)
08:22:33 <_um> EvilTerran: Yes I follow.
08:22:49 --- mode: ChanServ set +o shachaf
08:23:01 <EvilTerran> _um, note that the graph would be cyclic, because of the recursive definition
08:23:06 --- mode: shachaf set +b *!*porkys@84.78.20.*
08:23:06 --- kick: porkys was kicked by shachaf (porkys)
08:23:12 --- mode: shachaf set -o shachaf
08:23:22 <Cale> oh, that idiot again?
08:23:47 <EvilTerran> the names all disappear - the repeated use of a name turns into edges pointing to the same node
08:23:48 --- mode: ChanServ set +o shachaf
08:24:18 <_um> EvilTerran: When you say "the names all disappear" you mean the human readable terms we use in writing the code, right?
08:24:47 --- mode: shachaf set -b+b-o *!*porkys@84.78.20.* *!*porkys@* shachaf
08:24:47 <_um> But those get replaced with, as you say, "edges", which are a sort of link or reference to the node, which is a function call or value?
08:25:04 <EvilTerran> _um, yes, the human-readable names are just our way of indicating cross-references in the data structures we're describing
08:25:30 <_um> EvilTerran: Right. I follow that. I assumed so.
08:25:49 <EvilTerran> so they're only needed at the compilation stage, when the source code is being converted into a graph
08:26:16 <_um> OKay, so the cross-references, what do we say they refer to?
08:26:30 <EvilTerran> values
08:26:34 <EvilTerran> I suppose
08:27:02 <_um> They refer *from* a step in the evaluation of one function, and to...
08:27:06 <EvilTerran> following "f x y = ...", "f" is a name for the value "\x y -> ..."
08:27:58 <EvilTerran> so any future references to the name "f" in the source code become edges in the graph pointing to the node that represents "\x y -> ..."
08:28:10 <_um> okay, they refer to values, which can also be a function definition...
08:28:16 <EvilTerran> yup, functions are values
08:28:21 <_um> yeah.
08:28:41 <_um> So there is a sort "reference to functions" that is part of the compiled code...
08:28:43 <_um> it seems?
08:29:04 <EvilTerran> ...sort of. are you at all familiar with graph reduction machines?
08:29:28 <EvilTerran> that's what does the work at run-time, at least conceptually
08:29:38 <_um> Nope! But if that's where I should look to get a better sense of this stuff, I'll definitely research it a bit.
08:29:55 <_um> Okay, cool. I'll spend some time following up that lead.
08:30:10 <EvilTerran> the GHC runtime is something called a "spineless, tagless G-machine", which is a specific type of graph reduction machine
08:31:35 <_um> EvilTerran: Great. Thanks a lot for helping walk me through that. Thanks also to others!
08:31:49 <_um> I think I have a decent sense of where to look to fill in my lacking understanding now.
08:32:04 <EvilTerran> _um, sounds like a plan. if you can get your head around how graph reduction machines work at run-time, that should make it clearer to you why names aren't as important as they may first appear
08:32:07 <EvilTerran> happy to help :)
08:34:08 <deech> If I have a type like `(a (b (c ())))` at the type level is there some way to write Haddock docs for each component?
08:34:28 * hackagebot hsdev 0.1.3.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.3.0 (AlexandrRuchkin)
08:37:38 <quchen> You can write Haddock docs for each constructor. Finer granularity isn't possible.
08:37:59 <Fuuzetsu> patches to GHC welcome
08:38:21 <quchen> You can name your type variables though, e.g. "data Either' err a = Left' err | Right' a", to suggest usage.
08:38:23 <dhrosa> can we patch GHC to use brainfck as an intermediate representation
08:38:40 <Fuuzetsu> WONTFIX INVALID
08:38:55 <dhrosa> lambda calculus brainfck
08:40:12 <EvilTerran> jot?
08:40:12 <monochrom> you can. I won't.
08:40:55 <EvilTerran> (http://esolangs.org/wiki/Jot)
08:41:34 <quchen> You can make the grammar much easier by using a unary representation of programs here.
08:42:46 <hodapp> Is there some cleaner way to represent: (Foo a0, Foo a1, Foo a2...) => a0 -> a1 -> a2... ?
08:44:28 * hackagebot text-ldap 0.1.1.3 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.3 (KeiHibino)
08:44:30 * hackagebot crypto-numbers 0.2.7 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.2.7 (VincentHanquez)
08:44:32 * hackagebot hasktags 0.69.1 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.69.1 (MarcWeber)
08:45:08 <Hafydd> Simply typed brainfuck.
08:46:45 <EvilTerran> hodapp, are they all allowed to be different instances of Foo? if so, then I think that's the best you can do, at least without black magic.
08:46:47 <dhrosa> it should be web 3.0 grade, stringly typed
08:47:14 <hodapp> EvilTerran: fair enough.
08:47:39 <hodapp> What I would like to do eventually is make a function that does the variable-argument magic like Text.Printf does
08:48:00 <hodapp> "The PrintfType class provides the variable argument magic for printf. Its implementation is intentionally not visible from this module."
08:48:20 <quchen> hodapp: Is that what you want to do, or what you think is the best solution to your problem?
08:48:30 <brainacid> hello everyone
08:48:47 <quchen> hodapp: Formatting is a typesafe version of printf that uses a different approach, http://hackage.haskell.org/package/formatting
08:49:01 <EvilTerran> variadic functions are easier than they used to be, I believe, thanks to type families - but still pretty hairy
08:49:19 <hodapp> quchen: This is for Ivory and ultimately it boils down to C code that is just a call to printf.
08:49:28 * hackagebot duplo 1.6.1 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.1 (kenhkan)
08:50:09 <hodapp> quchen: said C code runs on a microcontroller and printf is just about all I have available for formatting output.
08:50:23 <cdk> EvilTerran: can you show an example of variadic functions using type families? I've seen the type class approuch but not using type families
08:52:27 <lpaste> hodapp pasted “ivory printf” at http://lpaste.net/117526
08:52:44 <hodapp> quchen: what I just pasted there is what I'm starting from.
08:54:11 <hodapp> that's not awful, I guess. I suppose some TH magic could generate a lot of it for me.
08:58:42 <EvilTerran> cdk, well, you'd still need type classes, I think, I just recall it being cleaner to write with associated type families than MPTCs+fundeps
08:58:51 <EvilTerran> afraid I don't have an example to hand, though
08:59:16 <EvilTerran> and I may be talking through my hat
09:01:51 <hodapp> is talking through one's hat a more polite verrsion
09:01:54 <hodapp> ...ack
09:02:04 <hodapp> Is talking through one's hat a more polite version of talking out one's ass?
09:02:15 <geekosaur> yes
09:06:08 <hodapp> good to know.
09:08:10 <meretrix> Say I have a haskell source file with a value defined as 'foo = "bar" :: String'.  Is there a way, using maybe ghci, that I can print the value of foo to stdout for use in a shell script?
09:09:40 <hodapp> meretrix: cannot help but notice that your nick is Latin for "whore".
09:10:05 <hodapp> meretrix: Can you not just make a Main module that imports this first source file and prints 'foo'?
09:11:00 <shachaf> ghc file.hs -e 'putStrLn foo'
09:11:26 <hodapp> oooh.
09:11:30 * hodapp jots that one down
09:13:08 * narendraj9 makes a mental note of that too.
09:14:03 <lord_ceylon> Has anyone around here experience with parsing non-text files in Haskell? What's the best way to do that?
09:14:42 <alpounet> lord_ceylon: attoparsec works decently there
09:14:50 <meretrix> shachaf: Perfect, thanks!
09:16:38 <lord_ceylon> alpounet: thank you, will have a look at it
09:17:18 <alpounet> lord_ceylon: you shouldn't have too much trouble finding articles/docs/posts and what not, to learn how to use attoparsec. it's a quite central library in the ecosystem
09:18:09 <lord_ceylon> alpounet: I'm quite used to parsec, but didn't know attoparsec yet
09:19:24 <lord_ceylon> alpounet: any core differences to how ByteStrings are handled otherwise?
09:23:39 <alpounet> lord_ceylon: in a way, attoparsec is much simpler than parsec, so it shouldn't be hard for you to get started
09:26:23 <alpounet> lord_ceylon: nothing special wrt bytestrings & attoparsec. you'll most likely just need this module: http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html it's Word8 all over the place
09:27:28 <dhrosa> lord_ceylon: parsec can also work on non-text, you just have to provide a typeclass instance or two
09:28:30 <lord_ceylon> oookay
09:28:40 <acidjnk> hello
09:29:56 <Merlin`> how can I get some sort of id or a handle of the current thread? just for testing purposes (printint) to see what thread I am currently on
09:30:02 <Merlin`> printing*
09:31:30 <geekosaur> :t Control.Concurrent.myThreadId
09:31:31 <lambdabot> IO GHC.Conc.Sync.ThreadId
09:34:30 * hackagebot duplo 1.6.2 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.2 (kenhkan)
09:34:54 <Merlin`> is that a haskell thread or an OS thread?
09:35:39 <Fuuzetsu> Haskell
09:35:42 <Merlin`> haskell it seems.. I would like id of an OS thread
09:35:44 <geekosaur> haskell thread. I don't know if youy can get an OS thread
09:36:11 <Fuuzetsu> you get ThreadID when you forkOS
09:36:20 <Fuuzetsu> ThreadId *
09:37:07 <Fuuzetsu> myThreadId should work too I think
09:37:48 <Merlin`> I am using forkIO. actually I want to check how many OS threads is my code running on.. perhaps there is a better way
09:38:24 <Fuuzetsu> why not store the number of forked threads?
09:38:47 <Merlin`> from what I've read I have to use both -threaded during compile time and +RTS -N during the runtime to use as many OS threads as the number of cores my computer has.. and I want to check if I got that right
09:38:48 <Fuuzetsu> oh sorry
09:39:10 <c_wraith> then you want getNumCapabilities, or whatever it's called
09:39:38 <Fuuzetsu> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html#v:getNumCapabilities
09:39:39 <geekosaur> note that, as you have no control over how forkIO threads map to OS threads, the OS thread ID will change during the life of a Haskell thread and there aren't really any promises
09:40:26 <c_wraith> If you really want to view concurrent HEC use, use threadscope
09:40:36 <Merlin`> getNumCapabilities seems to be what i want
09:40:57 <Merlin`> it is.. thanks
10:16:20 <drdo> Hmm, is there any particular reason why IntSet doesn't have a foldM?
10:25:30 <BMeph> drdo: Because no Set can be a Monad member. :)
10:29:13 <HeladoDeBrownie> BMeph, that doesn't sound right, you can still accumulate an action from something that can be folded
10:29:32 <HeladoDeBrownie> drdo, anyway, there is a foldM of sorts for Set: it can be found in its instance list :) Set is Foldable
10:29:43 <danem> How do you export lenses generated by "makeLenses"?
10:30:10 <ReinH> danem: by name :)
10:30:17 <HeladoDeBrownie> danem, same way you'd export anything else. you can either write them explicitly in the exports list or write the current module's name there to export everything
10:30:30 <ReinH> HeladoDeBrownie: but not an instance of Monad because of the constraint
10:31:03 <danem> Hmm... well when I try to export with the generated name (eg: _foo -> foo) ghc complains that it can't find "foo"
10:31:08 <HeladoDeBrownie> ReinH, yes, i think that is what BMeph was getting at but accidentally overstepped and applied that logic to the apparent lack of a foldM, which is where it failed
10:31:18 <danem> i figured that this was because they were generated by TH
10:31:54 <drdo> HeladoDeBrownie: well i just wrote one using IntSet.foldl
10:32:19 <drdo> Just saying it would be nice if it was in there already
10:32:30 <HeladoDeBrownie> drdo, it is already there, did you see what i said?
10:32:45 <HeladoDeBrownie> drdo, it's not in Data.Set, you're right, but it's in Data.Foldable
10:32:55 <drdo> HeladoDeBrownie: IntSet isn't Set
10:33:04 <BMeph> drdo: There is a 'fold' for IntSet, but not a 'foldM' - catch the diff? :)
10:33:15 <johnw> IntSet isn't Foldable
10:33:26 <HeladoDeBrownie> drdo, my mistake, i misread
10:33:42 <drdo> BMeph: I know, my question is why isn't there both, foldlM for IntSet is one line using foldl
10:33:44 <BMeph> johnw: Wait, what? =:O
10:34:02 <johnw> not according to the Haddocks it isn't
10:34:50 <drdo> It is morally Foldable, but it doesn't have the right kind to be a Foldable instance
10:34:55 <ReinH> Well, IntSet isn't of kind * -> *
10:35:23 <ReinH> So it can't be Foldable, Functor, etc
10:35:24 <johnw> I guess it's probably a "MonoFoldable"
10:35:27 <ReinH> Yeah
10:39:33 * hackagebot abt 0.1.0.0 - Abstract binding trees for Haskell  http://hackage.haskell.org/package/abt-0.1.0.0 (JonSterling)
10:40:39 <quchen> I think it's simply missing from the API.
10:41:57 <ReinH> quchen: IntSet is of kind * though
10:42:03 <quchen> :t \f a xs -> foldl (>>=) (return a) (map f xs)
10:42:04 <lambdabot> Monad m => (a1 -> a -> m a) -> a -> [a1] -> m a
10:42:11 <quchen> ReinH: Sure, it would be a monomorphic foldM.
10:42:20 <quchen> (Just like foldl.)
10:43:55 <ReinH> so perhaps foldM k = fmap fromList . Monad.foldM k . toList ?
10:44:49 <quchen> Or what I wrote above.
10:45:05 <quchen> Not sure what would be more efficient. toList+fromList feels a bit hacky sometimes.
10:45:05 <drdo> IntSet.foldl (\mAcc x → mAcc >>= flip f x) (return z)
10:45:18 <drdo> this is how i implemented it
10:45:27 <quchen> Yes, that's equivalent
10:46:22 <quchen> Careful about the usual strictness concerns though
10:46:27 <quchen> (foldl etc)
10:46:37 <EvanR-work> toList fromList could be considered just as if you were looping through the structures
10:47:12 <EvanR-work> im not certain about the memory performance though, on all the unused extra list nodes
10:51:11 <Black-Heaven> Hi all, I'm trying to start a new project (https://github.com/blackheaven/smoothmail) with a rather simple file (https://github.com/blackheaven/smoothmail/blob/master/src/Data/Network/Imap.hs) that requires KindSignatures, I have activated it but I still have this issue http://pastebin.com/SxcmQBY3 In short ghci tells me to enable this extension although I already activated it. Have I missed a step?
10:51:17 <Black-Heaven> Thanks in advance for your help.
10:53:41 <monochrom> LANGUAGE pragmas must go before the "module" line
10:54:31 <Black-Heaven> oh :'(
10:54:34 <Black-Heaven> thanks
10:57:55 <Cale> There really ought to be a better warning or error message about that
10:59:22 <albeit> If I have an Int with only the last 8 bits possibly set, what is the best way to turn that into a list of either Boolean values?
10:59:37 <albeit> *Boolean, not "either Boolean"
11:00:13 <flebron> Hi. I'm getting a build error from conduit-extras-1.1.6 on ghc 7.8.3. The error is at http://lpaste.net/117544 . The package I'm trying to install is Hakyll. Can I do something about this?
11:00:53 <quchen> map (testBit n) [1..8] -- albeit
11:01:59 <lolking55> Is there anybodu out thereeeeeeeeeeeeeeeeeeeeeee
11:02:05 <lolking55> if u r plz fuck ur self
11:02:10 --- mode: ChanServ set +o geekosaur
11:02:12 <albeit> quchen: Thanks!
11:02:16 --- mode: geekosaur set +b *!*@gateway/web/freenode/ip.2.216.39.151
11:02:16 --- kick: lolking55 was kicked by geekosaur (lolking55)
11:02:54 <BMeph> geekosaur: Thanks!
11:03:07 <pavonio> > testBit 4
11:03:08 <barrucadu> flebron: monad-control had a backwards incompatible upgrade recently iirc, try adding a constraint for monad-control < 1
11:03:08 <lambdabot>  <Int -> Bool>
11:03:37 <flebron> barrucadu: To conduit-extras or to hakyll?
11:03:45 <danem> Is there a cleaner way of accessing "maybe data" with lens? For istance, I have a Map Char Foo and I want to access some property of Foo. The best I've managed is "myMap ^. at key ^? _Just . bar"
11:04:21 <barrucadu> flebron: To your cabal install command
11:04:46 <barrucadu> cabal install hakyll --constraint='monad-control < 1'
11:05:23 <flebron> Same error, it seems.
11:05:43 <barrucadu> Hmm, no ideas then
11:06:28 <flebron> ( http://lpaste.net/117545 )
11:07:15 <ReinH> > M.fromList [('a', 1)] ^? ix 'a' . to succ -- danem
11:07:17 <lambdabot>  Just 2
11:08:10 <danem> hmm
11:08:11 <danem> ok
11:08:16 <danem> interesting..
11:08:33 <danem> Don't quite understand it yet, but I appreciate the tip :-)
11:08:45 <edwardk> danem: myMap^?ix key.bar
11:09:28 <edwardk> In general, ix key = at key . _Just = at key . traverse
11:09:48 <edwardk> you typically don't need to chain ^. or ^?'s that is the job of (.)
11:10:13 <flebron> barrucadu: Constraining to downgrade conduit-extra seems to have fixed it :)
11:10:14 <danem> Just to make sure I understand whats happening, if I wanted to access a property inside (bar) that was a maybe as well, I would need to use (^?) again
11:10:21 <danem> correct?
11:10:47 <alpounet> nope
11:10:59 <alpounet> you can just chain using the (.) operator
11:11:05 <danem> > M.fromList [('a',Just (1,2))] ^? ix 'a' . _1
11:11:06 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field1
11:11:06 <lambdabot>                      (Data.Maybe.Maybe (t0, t1)) (Data.Maybe.Maybe (t0, t1)) ...
11:11:06 <lambdabot>    arising from the ambiguity check for ‘e_1121’
11:11:24 <edwardk> > M.fromList [('a', (1,2))] ^? ix 'a' . _1
11:11:25 <lambdabot>  Just 1
11:11:48 <edwardk> > M.fromList [('a', (1,2))] ^. at 'a'
11:11:50 <lambdabot>  Just (1,2)
11:11:57 <edwardk> > M.fromList [('a', (1,2))] ^? at 'a'. traverse
11:11:58 <lambdabot>  Just (1,2)
11:12:02 <edwardk> > M.fromList [('a', (1,2))] ^? at 'b'. traverse
11:12:04 <lambdabot>  Nothing
11:12:05 <danem> Yeah, but is the Map as was of type Map Char (Maybe (Int,Int))
11:12:11 <danem> if the Map*
11:12:16 <edwardk> then put another traverse in the chain
11:12:32 <edwardk> > M.fromList [('a', Just (1,2))] ^? ix 'a' . traverse. _1
11:12:34 <lambdabot>  Just 1
11:12:44 <danem> Ah cool
11:12:48 <edwardk> what does the map pointing to Nothing mean here?
11:13:01 <danem> ?
11:13:36 <danem> You mean if I had ('a', Nothing)?
11:14:09 <ReinH> danem: Do you need to distinguish between Nothing and Just Nothing?
11:15:18 <danem> Hmm... I would think so... You need to distinguish between [[]] and [], no?
11:15:43 <ReinH> danem: Sometimes. The question is whether you, for your use case, need to.
11:15:49 <Merlin`> > join (Just Nothing)
11:15:49 <danem> oo
11:15:50 <lambdabot>  Nothing
11:16:05 <ReinH> What does Just Nothing mean?
11:16:19 <danem> In my particular usecase?
11:16:24 <ReinH> Yes
11:16:43 <ReinH> i.e. what does the presence of an absent value mean for you?
11:16:47 <spopejoy> Anyone using EitherT instead of exceptions/ErrorT/MonadCatchIO to propagate errors? I am b/c I want my own error type, specifically for throwing HTTP errors so I want (HTTPCode, message) as my type
11:16:51 <danem> Oh sorry to have confused you, I wouldn't have that issue, I'm just trying to understand how to use Lens
11:17:39 <spopejoy> I'm wondering if EitherT is confusing though, the other transformers make it clear you're handling errors.
11:18:04 <danem> I might have a type Foo with a field bar :: Maybe Int
11:18:08 <spopejoy> Also it seems like EitherT is a little underutilized (as opposed to MaybeT, say)
11:18:14 <danem> and a Map Key Foo
11:18:29 <johnw> spopejoy: if I'm in a monad transformer stack, I like to use MonadThrow; otherwise, I prefer just Either
11:18:44 <ReinH> spopejoy: The new hotness is ExceptT. Maybe edwardk can speak to why it exists now in mtl vs EitherT.
11:18:47 <johnw> (MonadThrow from the http://hackage.haskell.org/package/exceptions)
11:19:26 <edwardk> ReinH: EitherT was ported to transformers by Ross. He decided to recolor the bikeshed on the way in which means that while it is more consistent naming convention wise, users can't just change their imports
11:19:29 <spopejoy> Didn't edwardk write EitherT
11:19:29 <spopejoy> ?
11:19:49 <ReinH> Ah.
11:19:52 <edwardk> so now we have a large user base of either, a small user base of transformers 5 because transformers 5 doesn't ship with anything and is a ghc build package
11:19:54 <ReinH> Shame.
11:20:02 <edwardk> with 7.10 then transformers's ExceptT becomes a more viable option for folks
11:20:10 <edwardk> but then its missing some instances that some folks use already
11:20:13 <edwardk> so meh
11:20:25 <ReinH> :(
11:20:42 <spopejoy> I'
11:20:48 <spopejoy> I'm on 7.8.3 atm
11:20:53 <johnw> we've gotta leave something good for 7.12!
11:21:04 <johnw> the Grand EitherT Unification
11:21:10 <spopejoy> Why *not* use EitherT (from 'either' pkg)?
11:21:13 <edwardk> add to that that ErrorT was deprecated very very quickly and users don't have an effective way to upgrade because they can't use transformers if they need to use ghc-api, e.g. if they want doctests
11:21:22 <edwardk> spopejoy: thats what i still do
11:21:33 <edwardk> spopejoy: alternately you can use transformers-compat and use ExceptT that way
11:21:37 <spopejoy> I have a Java-background horror at using excceptions
11:21:48 <edwardk> i haven't deprecated EitherT because I still have a lot of users who rather like it
11:22:00 <edwardk> and I don't have a good story for ExceptT migration for everyone
11:22:53 <edwardk> anyways that is the muddled mess of the history behind ExceptT and why EitherT isn't deprecated.
11:23:06 <johnw> meh
11:23:10 <spopejoy> What's so great about exceptions anyway? EitherT seems to get the job done, if you want to handle them that is. I feel like "real" errors shouldn't be caught.
11:23:12 <edwardk> when we have a better transformers 0.5 distribution story i'm happy to entertain encouraging folks to move
11:23:21 <edwardk> spopejoy: ExceptT = EitherT with a new name
11:23:36 <spopejoy> Ah.
11:23:54 <edwardk> spopejoy: its just named differently so that Except e = ExceptT e Identity
11:23:57 <spopejoy> I saw "exception" in the docs but failed to see it doesn't require that to be of any particular type. Phew
11:24:06 <edwardk> whereas Either e is unrelated to EitherT e Identity
11:24:19 <edwardk> on the other hand MaybeT exists
11:24:28 <edwardk> but Ross didn't want to carry that pattern forward
11:24:33 <edwardk> hence randomly renaming EitherT
11:24:35 * hackagebot shelly 1.5.7 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.7 (GregWeber)
11:25:22 <quchen> johnw: Didn't someone say there would be a major release after 7.10? :-)
11:25:30 <spopejoy> OK so no reason *not* to use EitherT for now, it seems. I had to add some instances to Snap, is that worth a PR to snap folks?
11:25:48 <benzrf> damn
11:25:48 <benzrf> a major release :O
11:25:52 <edwardk> EitherT is fine for now
11:26:39 <spopejoy> Right, I had to EitherT snap, AND MonadCatchIO EitherT
11:26:53 <johnw> spopejoy: does Snap already have a dependency on 'either'?
11:26:59 <spopejoy> no
11:27:04 <johnw> then they may not like it
11:27:06 <spopejoy> yeah
11:27:15 <johnw> but can't hurt to try
11:27:35 <spopejoy> Should I PR adding MonadCatchIO to 'either'?
11:27:41 <spopejoy> (needed it for snap)
11:28:12 <benzrf> so ive been thinking
11:28:23 <benzrf> there are some neat things you can do by
11:28:42 <benzrf> instead of defining new wrapper types for monad transformers
11:28:58 <quchen> Alright, 8 oclock in Europe. See you next year, everyone!
11:29:24 <benzrf> defining: class (Monad u, Monad m, Monad n) => Transform u m n where joinT :: m (n a) -> u a
11:30:47 <benzrf> (i came up with this while thinking about local state in pipes)
11:31:04 <benzrf> like you can do instance (State (s, t)) (State s) (State t)
11:31:17 <benzrf> crap, gotta go
11:31:34 <Taneb> benzrf, you can do something like that with lens's Zoom, I think
11:36:37 <johnw> MonadCatchIO = bleh
11:36:50 <spopejoy> ooh have another lens question. I made a function to assemble a bunch of transforms on an Aeson object, and in doing so I needed to accept a bare lens like (key "foo" . key "bar"). The only type I could figure out that works for this is  Monoid m => (Value -> Const m Value) -> Value -> Const m Value.
11:38:12 <spopejoy> I called it "JSONGetter", as in type JSONGetter = Monoid m => (Value -> Const m Value) -> Value -> Const m Value
11:38:42 <xcss> I'm trying to use attoparsec-binary with io-streams and I'm having trouble since they both depend on different versions of bytestring. Any way to find versions that are compatible?
11:39:12 <Taneb> spopejoy, I think you can use ATraversal' Value Value
11:39:38 <edwardk> you can pick a particular concrete 'm'
11:39:54 <edwardk> or you can cloneLens or cloneGetter or whatever your way through the problem
11:40:06 <spopejoy> Taneb: doesn't work with firstOf
11:40:33 <Taneb> spopejoy, cloneTraversal it
11:41:19 <spopejoy> Taneb: that works
11:41:20 <Taneb> Or, alternatively, do what you did but for a fixed m, probably Leftmost Value
11:41:25 <refried_> is there a function in the standard library that is like (.) but with args reversed?
11:41:33 <refried_> (a->b) -> (b->c) -> (a->c)
11:41:37 <spopejoy> Leftmost has the opposite problem if you want to use it with toListOf
11:41:45 <spopejoy> whereas my type works for both
11:41:59 <refried_> maybe that would be like flip (.) ?
11:42:01 <spopejoy> but I wasn't aware of clone
11:42:27 <Taneb> edwardk, there seems to be a distinctive lack of AFold/AGetter?
11:42:47 <edwardk> :t cloneGetter
11:42:48 <lambdabot>     Not in scope: ‘cloneGetter’
11:42:48 <lambdabot>     Perhaps you meant ‘cloneSetter’ (imported from Control.Lens)
11:42:50 <edwardk> hrmm
11:42:54 <edwardk> :t cloneFold
11:42:55 <lambdabot> Not in scope: ‘cloneFold’
11:42:58 <edwardk> interesting
11:43:17 <edwardk> you can of course always convert them to and from a function to a list
11:43:28 <edwardk> and we have ReifiedFold and ReifiedGetter
11:43:48 <edwardk> :t view
11:43:49 <lambdabot> MonadReader s m => Getting a s a -> m a
11:43:51 <edwardk> :t to
11:43:52 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
11:43:55 <edwardk> :t to . view
11:43:56 <lambdabot> (Contravariant f, Conjoined p, Functor f) => Getting a s a -> p a (f a) -> p s (f s)
11:43:59 <edwardk> :t view . to
11:44:00 <lambdabot> MonadReader s m => (s -> a) -> m a
11:44:08 <edwardk> ^- inverses
11:44:21 <fread2282> refried_: filp (.) works, but there's no function in base for that
11:44:27 <fread2282> :t flip (.)
11:44:28 <refried_> fread2282: thanks
11:44:28 <lambdabot> (a -> b) -> (b -> c) -> a -> c
11:44:35 <edwardk> :t (Control.Category.>>>)
11:44:35 * hackagebot git-annex 5.20141231 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141231 (JoeyHess)
11:44:36 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
11:44:46 <edwardk> ^- flip (.)
11:46:08 <edwardk> :t (Control.Category.>>>) `asTypeOf` flip (.)
11:46:09 <lambdabot> (a -> b) -> (b -> c) -> a -> c
11:46:29 <fread2282> refried_: ^
11:47:15 <refried_> thanks
11:49:13 <untseac> Haskell is awesome (started leaning a month ago)! Happy new year!
11:51:00 <untseac> New resolution is to contribute to the Haskell community. What's the best project to start?
11:51:06 <spopejoy> edwardk: so for max comprehensibility: a) my type with concrete (Leftmost?) + some kind of clone; b) ATraversal' Value Value with cloneTraversal (firstOf is my main case but that may change)? Alternately, c) my type as-is, which I guess I'd have to clone anyway if I ended up using the same value in different contexts.
11:51:08 <johnw> whatever interests you most
11:51:18 <Zemyla> :t asTypePf
11:51:19 <lambdabot>     Not in scope: ‘asTypePf’
11:51:19 <lambdabot>     Perhaps you meant one of these:
11:51:19 <lambdabot>       ‘asTypeOf’ (imported from Prelude), ‘asTypeIn’ (line 157)
11:51:24 <Zemyla> :t asTypeOf
11:51:25 <lambdabot> a -> a -> a
11:51:37 <edwardk> spopejoy: i tend not to take rank-n types in as arguments because they infer poorly
11:51:48 <untseac> I heard the GUI kind of sucks maybe I'll start there
11:52:30 <edwardk> spopejoy: i find that if i just let it generate the type it wants then use that i'm generally okay. and if i need to use something at two types then i can clone
11:52:33 * spopejoy resolves for new year to finally study rank-n types
11:52:57 <spopejoy> edwardk: thing is I needed a type for my assembler fun.
11:53:06 <johnw> spopejoy: this one is pretty clear: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
11:53:18 <edwardk> Zemyla: asTypeOf is 'const' with a more restricted type, that lets you check to see if one argument and the other argument have types that can unify
11:53:35 <johnw> you're used to functions as values; rank-n lets polymorphic functions be values
11:53:39 <edwardk> :t firstOf
11:53:39 <lambdabot> Getting (Leftmost a) s a -> s -> Maybe a
11:54:28 <spopejoy> I of course have had to enable RankNTypes for precisely that, but I still get dizzy
11:57:01 <spopejoy> So my fun type is "fieldTxAs :: ValueTx -> JSONGetter -> Text  -> FieldTx", and ValueTx :: Value -> MaybeValue; FieldTx :: Value -> Maybe Pair. I assemble a bunch of these to take one Aeson object and make another. Thus I needed a type for just the 'key "foo"' part, so I arrived at JSONGetter as above.
11:59:00 <spopejoy> ATraversal' looks better, but it's just kinda funny b/c my main use case atm is `firstOf'
11:59:52 <eacameron1> one of the pitfalls of GC is hard-to-understand resource management. C++'s ctor and dtor pattern is very nice for this reason. What are some ways Haskell devs solve for prompt and composable resource management like this?
12:00:43 <johnw> eacameron: in cases where I need that, the "with" pattern
12:00:46 <aoeu> Partial application is a hack.
12:00:50 <johnw> withFile "foo" $ \h -> ...
12:01:00 <johnw> (need a ReadMode in there)
12:01:22 <johnw> Tekmo's Acquire construct generalizes this
12:01:58 <aoeu> Why do parameter order matters in partial function application?
12:02:22 <johnw> aoeu: do you know how partial application works?
12:02:47 <spopejoy> aoeu: parameter order is encoded in the type. order is therefore part of the type, it's not a map a-la python or something.
12:02:53 <aoeu> I know how it's used. Not how it works.
12:03:31 <johnw> calling it a hack is possibly premature then
12:03:41 <spopejoy> if you want to reorder, make a lambda, or use 'flip'
12:04:42 <aoeu> spopejoy: What if I have a method "substract a b = a - b". I want to partially apply it: "subtractFrom10 x = subtract 10". Would that work?
12:05:34 <aoeu> (ignore the x)
12:05:54 <spopejoy> aoeu: that would result in applying the 'a' argument as 10.
12:06:04 <kazagistar> aoeu: try it out in ghci :)
12:06:06 <spopejoy> so you'd end up with (10 -).
12:06:28 <spopejoy> which by the way, you can just write (10 -) :)
12:06:45 <aoeu> spopejoy: What if I want to substract 10 from x?
12:06:55 <spopejoy> (subtract 10)
12:07:00 <carter> spopejoy: whats this about either/except t?
12:07:13 <aoeu> "subtract10 x = subtract x 10" <- this?
12:07:29 <carter> spopejoy: i general use transformers-compat so i can work with either transformers
12:07:36 <aoeu> partial application only works if I want to change what is subtracted.
12:07:51 <kazagistar> yes and "flip subtract 10" would also work
12:08:15 <spopejoy> aoeu: that works. you can also do 'flip subtract 10'
12:08:22 <osa1> do we have this in gtk3 library: https://developer.gnome.org/gtk3/3.14/GtkHeaderBar.html ?
12:08:33 <spopejoy> carter: I'm using 'either' package
12:08:47 <pavonio> or (`subtract` 10)
12:10:22 <carter> ah
12:10:50 <spopejoy> carter: was really wondering if using EitherT was 'idiomatic', really, since MonadThrow or something else is more 'obviously' about errors. Thing is, I don't like using exceptions, would rather use my own type.
12:11:07 <untseac> eacameron: what's a ctor dtor pattern?
12:11:22 <carter> hrmm
12:11:50 <spopejoy> my java background leads me to want to avoid anything that looks like "checked exceptions"
12:12:27 <johnw> untseac: he means: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
12:12:37 <johnw> aka "Constructor Acquires, Destructor Releases"
12:13:18 <untseac> Thanks
12:13:48 <johnw> Haskell can do explicit scoping of resources too
12:13:57 <johnw> it's just not what everything does
12:13:58 <spopejoy> Are ctors and dtors really such a great way to deal with resources? Haskell has bracket, seems fine. Dunno how GC fits into that discussion.
12:14:16 <johnw> and there are things like SafeT
12:14:19 <carter> hrmm
12:14:26 <johnw> there are lots of ways to define a determinstic boundary for resource allocation
12:14:31 <carter> finalizers fire on the next GC
12:15:23 <spopejoy> I haven't done a ton of hardcore IO, but if I close a handle, isn't it gone?
12:15:39 <carter> yes
12:16:05 <spopejoy> so .... what does GC have to do with it?
12:16:21 <johnw> if you open the handle but don't close it, it should close on finalization
12:17:21 <untseac> JVM has the "with" pattern from 7 onwards. Isn't that how you do it with GC?
12:17:22 <spopejoy> C++ RAII fans seem to think it's so great but if your object graph is big and complex it gets chaotic when things fire. So RAII isn't some kind of magic bullet.
12:18:03 <eacameron> johnw: but that doesn't compose well, AFAIK; for example std::vector<file> allows you to have many files that all close together but the callers don't need to know that
12:18:36 <johnw> eacameron: well, I like that doing that with SafeT tells me via the type that many things may happen at the end of the block
12:18:39 <eacameron> untseac: constructor/destructor pattern: "open" on construction, "close" on destruction, close happens when the object goes out of scope
12:20:50 --- mode: geekosaur set -o geekosaur
12:21:02 <spopejoy> RAII is very OO it seems to me, with all of the brain-fogging that goes with that.
12:21:47 <carter> i dont understand RAII, OO, or ACRONYM
12:22:13 <spopejoy> ACRONYM: all cool radical operators need your money
12:22:21 <carter> oo
12:23:02 <untseac> Isn't that the definition of buzzword?
12:23:14 <eacameron> johnw: I figured there was a monad transformer for such things....
12:23:19 <eacameron> never heard of SafeT
12:24:05 <spopejoy> carter: OO - object oriented, RAII - "resource allocation is initialization", C++ lore
12:24:37 * hackagebot mvc 1.0.3 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.3 (GabrielGonzalez)
12:24:41 <eacameron> "lore" haha...seems to be running on many processors near you
12:26:01 <spopejoy> Actually, I mostly see "better C" C++ these days. Honestly if you're using smart pointers and such you might as well use Java. Which means you really should be switching to Haskell about now :P
12:26:28 <carter> heh
12:26:36 <spopejoy> except of course Java FFI is horrible, so back to C++
12:26:45 <carter> spopejoy: ttuegel  and i have been mulling how to do a "low level haskell"
12:26:59 <carter> its a few exa-yaks away from being reality though
12:27:12 <eacameron> spopejoy: too true; if you learned C, then all you need to do is run "g++ mycode.c" and slap "C++" to your resume
12:27:22 <carter> damn
12:27:25 <carter> i've been doing it wrong
12:27:38 <carter> clearly i need to get into the lucrative world of legacy C++ engineering
12:27:42 <ttuegel> carter: i'm not so sure i want low level haskell anymore. i may just want "language-fortran-inline"
12:27:54 <carter> ttuegel: ahh
12:28:07 <ttuegel> but, i'm a heretic :)
12:28:14 <carter> ttuegel: ooo, btw, luite  suggested a type of specialization that might remove the need to rub inline everywhere
12:28:23 <ttuegel> oh?
12:29:37 * hackagebot pipes-bytestring 2.1.1 - ByteString support for pipes  http://hackage.haskell.org/package/pipes-bytestring-2.1.1 (GabrielGonzalez)
12:30:41 <spopejoy> What are the real usecases these days where GC would be such a problem? High-frequency trading, but that's moved to FPGA largely. Personally I don't ever want to deal with explicit allocation again. GC ftw
12:30:59 <johnw> real-time computing
12:31:03 <johnw> games
12:31:19 <johnw> anything where latency is significant
12:31:34 <johnw> absording a 50ms pause at unexpected moments can be intolerable
12:31:36 <spopejoy> Sigh. Games in particular are where a better language would be nice. C++ is just too primitive.
12:31:43 <carter> johnw: spopejoy  theres ways to drive down latency in ghc though
12:31:48 <carter> but yeah
12:32:01 <johnw> sure, but then you increase the technical debt, and it stops being such an attractive technology
12:32:05 <carter> theres an RTS flag that lets you say "switch threads at every heap check"
12:32:16 <johnw> GC is awesome in that it abstracts away so much messy detail
12:32:58 <carter> theres ways to get lower latency GC, but you really dont want it by default
12:33:05 <spopejoy> I mean, java with commerical jvms like Azul have GC beat, assuming you've enough heap
12:33:16 <spopejoy> and can handle 1-2ms pausing.
12:33:23 <spopejoy> say, every 2s
12:33:43 <johnw> and there are real-time JDKs
12:33:54 <johnw> so if industry cares enough, I'm sure they'll find ways
12:33:54 <spopejoy> when people say "RT" are they really 1ms-sensitive?
12:34:07 <johnw> depends on the application, spopejoy
12:34:08 <eacameron> is this where the "low-level haskell" discussion came from?
12:34:23 <spopejoy> sure. RT audio would suck with 1ms pauses.
12:34:24 <johnw> spopejoy: for music processing, it could very well matter
12:34:27 <carter> spopejoy: i spoke with some folks who tried out azule for ad tech stufff, they said they didnt see any real perf boost
12:34:31 <carter> eacameron: nope, numerical computing
12:34:42 <carter> which is totally throughput bound
12:34:50 <untseac> Games can do with GC. There's jmonkeyengine. Of course you don't know when you're getting a full GC but I don't see that has a big issue.
12:35:10 <spopejoy> carter: azul killed for algo trading. went from 10-20ms pauses to 1-2ms, with 30-40G heaps
12:35:20 <carter> ahhhh
12:35:22 <carter> ok,
12:35:31 <spopejoy> adtech guys may not have good heuristics.
12:35:38 <carter> spopejoy: so when missing a single response === expensive
12:35:57 <carter> in ad tech, missing a opportunity isn't expensive as long as its rare
12:36:11 <spopejoy> azul won't do much if you don't have good reall-short-term + really-long-lived objects, with no in-between
12:36:17 <zomg> carter: "ad tech stuff"? Curious as I'm in the same industry atm
12:36:25 <carter> zomg: RTB?
12:36:39 <carter> g2g put my laundry in the dryer, i'll brb
12:36:42 <carter> zomg: where you based?
12:36:53 <zomg> We're building an HTML5 responsive ad platform
12:37:06 <zomg> so it includes a variety of stuff
12:37:42 <spopejoy> RT is where I see "Better C" C++. For instance, supercollider. It's basically written in C but uses nice C++ sugar.
12:37:53 <spopejoy> Nobody uses smart pointers in RT.
12:38:10 <spopejoy> (supercollider music synth btw)
12:38:54 <spopejoy> I forget. Does C have strongly-typed function pointers? Or is it just a void*?
12:39:40 <awesomo4000> scanl (++) "_" ["a".."z"]                # can someone tell me why this doesn't work
12:39:53 <benzrf> spopejoy: c doesn't have strongly-typed anything :p
12:40:01 <benzrf> spopejoy: but i think it has statically-typed func ptrs
12:40:14 <spopejoy> > ['a'..'z']
12:40:15 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
12:40:22 <benzrf> awesomo4000: it's cause string doesnt have an enum instance
12:40:25 <spopejoy> > ["a".."z"]
12:40:26 <benzrf> > ["a".."z"]
12:40:26 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
12:40:26 <lambdabot>    arising from the arithmetic sequence ‘"a" .. "z"’
12:40:27 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
12:40:27 <lambdabot>    arising from the arithmetic sequence ‘"a" .. "z"’
12:40:35 <awesomo4000> sorry.. i meant single quotes
12:40:41 <berto> hello all
12:40:52 <benzrf> awesomo4000: because the types are wrong
12:40:55 <benzrf> :t scanl
12:40:56 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
12:41:18 <untseac> I was checking RAII and it doesn't seem like a big deal to me :s
12:41:28 <benzrf> awesomo4000: applying scanl to (++) "_" instantiates both a and b to String
12:41:33 <awesomo4000> so then i check (++)  :  ghci> :t (++)
12:41:33 <awesomo4000> (++) :: [a] -> [a] -> [a]
12:41:45 <untseac> What's so great about RAII?
12:41:48 <benzrf> awesomo4000: so a is [t] and b is also [t]
12:42:10 <benzrf> awesomo4000: but your 2nd argument is [Char] and your 3rd argument is [Char]
12:42:17 <benzrf> awesomo4000: when they should be [Char] and [[Char]]
12:42:25 <benzrf> because a and [b]
12:42:39 <spopejoy> untseac: it's necessary for C++'ers to brainwash themselves with RAII so they don't get core dumps :P
12:43:52 <untseac> So basically it's just a way to not forget about closing a resource. Nothing else?
12:44:24 <awesomo4000> ok. cool. it works but not what i expect.
12:44:38 * hackagebot json-autotype 0.2.5.4 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.4 (MichalGajda)
12:45:18 <eacameron> johnw: where is SafeT?
12:45:45 <johnw> http://hackage.haskell.org/package/pipes-safe
12:46:37 <spopejoy> untseac: it's part of a whole methodology for memory-management too, not just IO resources.
12:46:59 <spopejoy> but don't ask me. I avoid C++
12:47:04 <awesomo4000> so this is the analogy i'm trying to make:
12:47:04 <awesomo4000> ghci> scanl (+) 0 [ 0..5 ]
12:47:04 <awesomo4000> [0,0,1,3,6,10,15]
12:47:04 <awesomo4000> ghci> scanl (++) "" [ ['a'..'e'] ]
12:47:04 <awesomo4000> ["","abcde"]
12:47:15 <untseac> I avoid it as well
12:47:26 <untseac> But there could be some advantage
12:47:28 <awesomo4000> the string version doesn't act like the int version
12:47:31 <untseac> I just don't see it
12:47:39 <untseac> Have to go see ya
12:47:39 <carter> spopejoy: one approach i'd like to explore some time is basically using LLVM-General as a macro language / EDSL for writing low level code
12:47:49 <carter> i think Enigmagic's llvm-general-typed lib kinda does that i guess
12:47:55 <n4x> > scanl (++) "_" . map pure $ ['a'..'e']
12:47:56 <carter> Enigmagic: whats left before its safe for hackage?
12:47:56 <lambdabot>  ["_","_a","_ab","_abc","_abcd","_abcde"]
12:47:57 <carter> :)
12:48:02 <int-e> untseac: It works in the presence of arbitrary exceptions. It's similar in spirit to Haskell's  bracket  idiom abnd plenty of  withFoo  functions built on top of it; the destructor of an object acts as the cleanup action.
12:48:07 <eacameron> johnw: ah pipes. have you found you like them better than conduit? I'm still debating in my head, but haven't used pipes at all
12:48:30 <awesomo4000> thanks n4x
12:48:39 <johnw> eacameron: I do prefer them to conduit; they require a bit more learning, but the types are more informative because the core abstraction doesn't combine too many concepts
12:48:44 <awesomo4000> i'm still finishing my cup of koolaid with haskell
12:48:47 <spopejoy> man if somebody could just make the call on pipes v conduit v iteratees that'd be awesome
12:48:57 <awesomo4000> i've gone full xmonad. now i'm working my way through LYAH
12:49:00 <johnw> I'm in the process of converting all my conduit-based stuff to pipes
12:49:04 <spopejoy> seems like you have to learn all three to make an eduycated decision
12:49:07 * awesomo4000 <- newb
12:49:26 <carter> spopejoy: machines obvs
12:49:29 <zomg> I tried Xmonad for a while in one of my VMs
12:49:29 <carter> or pipes
12:49:30 * berto <-newb as well
12:49:36 <zomg> I'm just too used to my mouse-based goodness :p
12:49:38 <eacameron> spopejoy: such is the case with many debates ;)
12:49:45 <carter> zomg: do youre on the ad nework side?
12:49:49 <zomg> though I do like the fact I can navigate windows with the keyboard
12:50:10 <johnw> my opinion is that conduit leans toward favoring human intuition, whereas pipes leans toward the mathematical abstractions.  It depends on how you think, which you'll prefer to work with
12:50:13 <berto> zomg: im on xmonad now
12:50:18 <zomg> carter: yeah or more like publisher, you'd use our tool to build an ad that you can deploy to networks
12:50:26 <spopejoy> actually, my suspicion is "learn all three, pick one, look longingly at the things the other ones do better"
12:50:35 <eacameron> johnw: speaking of converting, are you gonna finish the haskell port of ledger?
12:50:39 <zomg> carter: we may have our own networking option in the future but that's still just a concept
12:50:42 <johnw> I don't think iteratees is a real contender anymore
12:50:46 <johnw> eacameron: probably not
12:51:02 <johnw> I'll let hledger move along, and work with others on solidifying the C++ version
12:51:11 <zomg> carter: but we run some heavy crunching to collect analytics etc.
12:51:11 <spopejoy> snap's still built on iteratees no? any performance diff between the 3?
12:51:17 <TallerGhostWalt> carter: machines seems so much less developed
12:51:29 <carter> TallerGhostWalt: trueeee
12:51:30 <awesomo4000> so this is my first exposure to "pure"
12:51:32 <carter> spopejoy: snap 1.0 uses io-streams
12:51:37 <zipper> How does one do stuff like --> length [0..] and handle the exception without getting into the IO monad?
12:51:39 <eacameron> johnw: yeah, you'd lose core contributors I'd imagine
12:51:40 <awesomo4000> i don't have it in scope
12:51:50 <n4x> zipper: which exception?
12:51:56 <johnw> I think pipes is a bit faster -- it's less complex, so that's no surprise.  In order for conduit to be really performant, it has to give up a lot of its intuitive niceties
12:52:03 <carter> TallerGhostWalt: my agenda is to promote it a wee bit so it gets mor work
12:52:21 <johnw> see the recent posts on using conduit vector builders, for example
12:52:22 <zipper> n4x: Stack overflow
12:52:25 <spopejoy> zipper: why would you want to handle that?
12:52:35 <TallerGhostWalt> carter: yeah it is nice.
12:52:40 <spopejoy> zipper: seems like a bug, not something to handle at runtime.
12:52:48 <deech> How do I load a statically linked archive (blah.a) into ghci? I tried `ghci -lblah` and it looks for `libblah.so`.
12:53:18 <pavonio> awesomo4000: It's part of the Applicative class in Control.Applicative
12:53:54 <awesomo4000> ok. so now i've jumped into something completely new .
12:53:58 <pavonio> awesomo4000: Nothe that here it's equivalent to return or (: [])
12:54:03 <pavonio> *Note
12:54:08 <zipper> spopejoy: I want a function that checks whether a list has more then four elements
12:54:12 <carter> zomg: i've been planning to write a wee adtech framwork in haskell for a while, not because i like adtech at alll, but rather because i've not been happy with any of the enginering i've seen inthat space
12:54:14 <TallerGhostWalt> carter: Is there a pipes-concurrent analog for machines?
12:54:15 <spopejoy> awesomo4000: 'pure' just makes a list. You can also use 'return' or (:[])
12:54:16 <zipper> spopejoy: So I wrote it as (> 4) . length
12:54:21 <carter> TallerGhostWalt: pipes-concurrent is busted
12:54:24 <carter> dontcha know
12:54:35 <zipper> spopejoy: Should work but fails on infinite lists.
12:54:37 <TallerGhostWalt> carter: what is wrong with it?
12:54:39 <carter> like, fundamentally, certain patterns dont work on 7.8 and newer
12:54:46 <carter> because of how the GC tracking STM stuff changed
12:55:06 <zipper> How to stop --> `(> 4) . length` from failing on infinite lists?
12:55:22 <zomg> carter: oh :) our stack is built on node (I wasn't the original designer), but I managed to sneak in a little bit of haskell for some custom coding we did for a campaign we ran with mastercard and mashable
12:55:25 <carter> https://github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/issues/29
12:55:40 <carter> zomg: i know people who've done node adtech
12:55:45 <n4x> zipper: you could drop n elements and and see what you get
12:55:46 <TallerGhostWalt> carter: ooh
12:55:47 <carter> it was nerve wracking to write patches for
12:56:04 <zipper> :t take
12:56:04 <lambdabot> Int -> [a] -> [a]
12:56:08 <zomg> yes that's quite true.. the code isn't exactly top notch, so I'm trying to fix it and it's a bit of a pain
12:56:23 <zomg> especially as we have some customers who are using the tool and thus we can't exactly deploy something broken
12:56:29 <zipper> > take 4 [1,2,3]
12:56:30 <lambdabot>  [1,2,3]
12:56:37 <carter> take 5!
12:56:39 <spopejoy> > drop 4 [1,2,3]
12:56:41 <lambdabot>  []
12:56:50 <eacameron> is io-streams a competitor to the conduit/pipes battle?
12:56:50 <spopejoy> > drop 4 [1,2,3,4,5]
12:56:52 <lambdabot>  [5]
12:56:54 <carter> eacameron: its simpler
12:56:58 <zipper> spopejoy: I didn't know about stop
12:57:03 <zipper> spopejoy: *drop
12:57:06 <spopejoy> > drop 4 [1..]
12:57:07 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
12:57:08 <awesomo4000> what's the syntax with :([])
12:57:11 <spopejoy> oops
12:57:13 <carter> eacameron: if you only care about being incremntal on the IO, and not on the inside
12:57:27 <geekosaur> you mean the section (:[]) ?
12:57:31 <awesomo4000> :yes.
12:57:33 <spopejoy> awesomeo4000: creates a list
12:57:37 <johnw> eacameron: not really
12:57:38 <eacameron> carter: I don't understand; incremental on the io?
12:57:41 <spopejoy> > (1:[1,2,3])
12:57:42 <lambdabot>  [1,1,2,3]
12:57:42 <n4x> awesomo4000: (:[]) is the equivalent to (\x -> x:[]), which is also, (\x -> [x])
12:57:51 <awesomo4000> > '':['a'..'z']
12:57:52 <lambdabot>  <hint>:1:3: parse error on input ‘:’
12:57:55 <zomg> carter: this is us if you're curious (the site is getting an overhaul in the near future :P ) www.responsiveads.com
12:57:58 <spopejoy> > (1:) $ [1,2,3]
12:57:59 <lambdabot>  [1,1,2,3]
12:58:04 <n4x> just like [a,b,c] is a:b:c:[]
12:58:11 <spopejoy> > (:[]) 1 [1,2,3]
12:58:12 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[a0]’
12:58:19 <johnw> eacameron: http://hackage.haskell.org/package/simple-conduit is a competitor, since it covers a large majority of what conduit does, only far simpler and generally faster
12:58:21 <spopejoy> oops
12:58:21 <carter> zomg: are you based in nyc?
12:58:39 <spopejoy> > (1:[])
12:58:40 <lambdabot>  [1]
12:58:47 <spopejoy> > (:[]) 1
12:58:48 <lambdabot>  [1]
12:58:58 <spopejoy> awesomo4000: ^^
12:59:02 <awesomo4000> > ('a':"bcd")
12:59:04 <lambdabot>  "abcd"
12:59:21 <zomg> carter: yeah, we have some people in NYC, couple devs including myself in Finland, two in Slovenia
12:59:26 <awesomo4000> ('_':['a'..'e'])
12:59:34 <carter> cool
12:59:38 <awesomo4000> > ('_':['a'..'e'])
12:59:39 <lambdabot>  "_abcde"
12:59:52 <carter> zomg: i'm going to regret writing an OSS adtech framwork in haskell
12:59:55 <carter> but i htink it'd be good for adoption
13:00:14 <zomg> yeah there's a lot of movement in the space lately I think
13:00:18 <zomg> so would definitely be interesting
13:00:27 <spopejoy> my god, the world really needs haskell.
13:00:57 <spopejoy> when i see the code my coworkers are dealing with in java ... the pathos.
13:01:08 <mjo> zipper: if the "4" is fixed in your application, you might try pattern matching against the list. Something like: let len_gt4 (_:_:_:_:_:_) = True; len_gt4 _ = False
13:02:03 <spopejoy> mjo, zipper: but isn't this just a bug? why should the code be resilient?
13:02:23 <spopejoy> i mean, fix the bug (don't use an inf. list) and move on.
13:02:29 <spopejoy> no?
13:02:45 <spopejoy> overly-heroic code is an antipattern.
13:02:58 <mjo> There are plenty of situations where you wind up with a list that might be infinite, and want to know how long it is
13:03:15 <eacameron> carter: why the regret?
13:03:18 <spopejoy> maybe in a library. in application code?? sounds like bad code.
13:03:23 <ReinH> > null . drop 4 $ [1..] -- zipper
13:03:24 <lambdabot>  False
13:03:35 <mjo> How about, Is A*x == b solvable? Compute the solutions, and stick them in a list. How many solutions do you have? One, or more than one? It can be infinite.
13:03:52 <spopejoy> mjo: heh. I guess you get to write apps like that. :)
13:04:00 <zipper> mjo: Why would pattern matching help?
13:04:05 <awesomo4000> ok. i definitely can't figure this out.   what's the equivalent of  scanl (++) "_" . map return $ ['a'..'e']    using  (:[])  syntax
13:04:15 <awesomo4000> ( no return )
13:04:17 <mjo> No I'm just the asshole who offers math examples when I'm sure there are simple ones =)
13:04:21 <zipper> mjo: Isn't that way better? We're checking if it's greated than 4
13:04:23 <spopejoy> haha
13:04:29 <benzrf> awesomo4000: do you understand what map return does
13:04:32 <ReinH> zipper: You can use mine.
13:04:37 <awesomo4000> i couldn't get it to print
13:04:47 <awesomo4000> and the type included something called Monad when i did :t
13:04:49 <awesomo4000> on return
13:04:54 <mjo> zipper: Either way works. I like pattern matching because you know at compile-time that the function won't crash.
13:04:54 <zipper>   WEECHAT SAYS  -- Thu, 01 Jan 2015 --
13:05:05 <awesomo4000> > :t return
13:05:06 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:05:12 <zipper> YAAAAYYYYYYYY 2015 from UTC + 3
13:05:18 <benzrf> :t return
13:05:19 <lambdabot> Monad m => a -> m a
13:05:19 <n4x> :t return
13:05:20 <lambdabot> Monad m => a -> m a
13:05:33 <zipper> mjo: And the others might fail at compile time?
13:05:41 <awesomo4000> where does one get a "Monad"
13:05:43 <n4x> :t return :: a -> [a] -- this is what we're actually using
13:05:43 <lambdabot> a -> [a]
13:05:47 <spopejoy> > scanl (++) "_" . map return $ ['a'..'e']
13:05:48 <lambdabot>  ["_","_a","_ab","_abc","_abcd","_abcde"]
13:05:51 <benzrf> awesomo4000: [] is a Monad
13:05:59 <benzrf> awesomo4000: therefore return mmay have type a -> [] a
13:06:05 <benzrf> aka a -> [a]
13:06:07 <spopejoy> > scanl (++) "_" . map (:[]) $ ['a'..'e']
13:06:08 <lambdabot>  ["_","_a","_ab","_abc","_abcd","_abcde"]
13:06:09 <mjo> It depends. Obviously, computing the length and seeing if it's bigger than 4 will crash. Some of the others work, but you have to convince yourself of it.
13:06:15 <awesomo4000> :t []
13:06:16 <lambdabot> [t]
13:06:25 <Cale> awesomo4000: Monads are type constructors for which there are implementations of return and (>>=)
13:06:38 <johnw> Cale: nicely said
13:06:40 <Cale> awesomo4000: That's actually the wrong []
13:06:41 <spopejoy> awesomo4000: [] is a monad (return), Applicative (pure), plus you can just call (:[])
13:06:56 <awesomo4000> oh. i haven't gotten to return and >>= yet.
13:06:56 <Cale> awesomo4000: There's [] the empty list (which is a value)
13:07:07 <Cale> and then there's [] the type constructor
13:07:16 <ReinH> zipper: length_gt n = null . drop n -- is sufficiently non-strict.
13:07:20 <awesomo4000> :t  :[]
13:07:20 <lambdabot> parse error on input ‘:’
13:07:24 <Cale> When you see a type like [String], it's also possible to write that as [] String
13:07:25 <mjo> For example, computing the length of "take 5" should do it. But you need to know what length and "take 5" do to know that they're safe. You need to keep more conditions in your head.
13:07:29 <awesomo4000> :t (:[])
13:07:30 <lambdabot> a -> [a]
13:07:36 <awesomo4000> that one ?
13:07:41 <Cale> If that helps at all
13:07:51 <Cale> (:[]) is also a value
13:08:12 <zipper> ReinH: Yeah I didn't know about null thanks
13:08:12 <Cale> But there's a [] which lives over in the world of types on the right hand side of the ::
13:08:26 <ReinH> zipper: This is what Richard Bird recommends iirc
13:08:27 <Cale> [a] and [] a mean the same thing
13:08:34 <Cale> (as types)
13:08:50 <zipper> ReinH: Thanks
13:08:55 <ReinH> zipper: np
13:09:02 <spopejoy> null is good, and makes your code look like lisp, which we all want.
13:09:05 <Cale> This is all just to help line up the type of return with what you're seeing
13:09:12 <ReinH> spopejoy: ;)
13:09:13 <Cale> :t return
13:09:14 <lambdabot> Monad m => a -> m a
13:09:18 <awesomo4000> :t (:[])
13:09:19 <lambdabot> a -> [a]
13:09:22 <awesomo4000> that's not it ?
13:09:35 <Cale> If we pick m = [], then this is a -> [] a or a -> [a]
13:09:47 <Cale> and yeah, it is (:[]) in this case
13:09:58 <spopejoy> awesomo4000: (:[]) is a function
13:10:00 <Cale> Or you could just write  return v = [v]
13:10:09 <Cale> :t (>>=)
13:10:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:10:14 <awesomo4000> is a type constructor a function
13:10:17 <Cale> In the case that m = [], that becomes
13:10:23 <Cale> [a] -> (a -> [b]) -> [b]
13:10:24 <spopejoy> awesomo4000: yes
13:10:32 <Cale> It's a sort of function at the type level
13:10:32 <ReinH> spopejoy: no
13:10:37 <spopejoy> No?
13:10:44 <Cale> Not the sort of function which exists at runtime
13:10:44 <spopejoy> but you can use it where a function is called fo.
13:10:46 <spopejoy> for.
13:10:52 <Cale> spopejoy: huh?
13:10:54 <spopejoy> :t Just
13:10:54 <lambdabot> a -> Maybe a
13:10:59 <ReinH> spopejoy: No. You are thinking of data constructors
13:11:00 <Cale> Just is not a type constructor
13:11:03 <ReinH> data constructors are functions
13:11:09 <spopejoy> oops
13:11:13 <Cale> Maybe is a type constructor
13:11:25 <ReinH> fsvo function, a type constructor is a function, but that just confuses the issue when we are trying to distinguish value level from type level
13:11:28 <spopejoy> Sorry, I meant just plain "constructor"
13:11:28 <awesomo4000> i haven't really studied the Monad yet, but it appeared to me like some sort of tag that gets put on return values
13:11:40 <awesomo4000> like marking a result dirty or something
13:11:43 <Cale> awesomo4000: No, that's not really a good way to think of them
13:11:48 <spopejoy> which prob. means data constructor
13:12:02 <spopejoy> and data constructors are functions.
13:12:13 <Cale> awesomo4000: A monad is a data structure which is parameterised over a choice of data type, and which supports certain operations (return and (>>=))
13:12:31 <awesomo4000> :t (>>=)
13:12:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:12:32 <spopejoy> I don't even want to talk about type functions. Type-level programming gives me vertigo.
13:12:45 <Cale> awesomo4000: Are you familiar with data declarations yet?
13:12:58 <awesomo4000> i read about them yes.
13:13:08 <Cale> Consider this one:  data Tree a = Leaf a | Branch (Tree a) (Tree a)
13:13:08 <spopejoy> Man it's possible to burn HOURS on #haskell. Too entertaining. Back to work/.
13:13:15 <johnw> spopejoy: Either is a type function taking two arguments.  Either Int is a partially applied type function taking one argument.  Many of your intuitions about functions transfer over directly.
13:13:31 <Cale> We can make this Tree type constructor into a Monad, as it turns out:
13:13:37 <Cale> instance Monad Tree where
13:13:37 <spopejoy> The other day I was trying to use HOccurs and my brain exploded.
13:13:40 <awesomo4000> what's the | in that do
13:13:45 <Cale> Oh, okay
13:14:01 <awesomo4000> i saw | in guards for functions
13:14:14 <Cale> So, this says that for any type a, the type Tree a consists of values which are either of the form Leaf applied to a value of type a
13:14:27 <Cale> Or of the form Branch applied to two values of type Tree a
13:14:30 <spopejoy> Not to mention, Oleg's examples of conditionals w/ HOccurs, etc don't compile in 7.8.3 :(
13:14:39 * hackagebot pipes-group 1.0.2 - Group streams into substreams  http://hackage.haskell.org/package/pipes-group-1.0.2 (GabrielGonzalez)
13:14:42 <Cale> This is a different use of | as punctuations
13:14:44 <Cale> -s
13:14:55 <gridaphobe> does anyone know of a way to get the path the the defining module from a template-haskell Name?
13:15:01 <Cale> Here it separates the data constructors
13:15:10 <Cale> We could define an enumerated data type like:
13:15:26 <Cale> data Colour = Red | Yellow | Green | Blue | Purple
13:15:30 <ReinH> johnw: FYI the docs for conduit-simple are a bit o_O on hackage, for example linking to things like http://hackage.haskell.org/package/simple-conduit-0.5.1/docs/Source%20homomorphism.html which don't exist
13:15:52 <awesomo4000> ok. so for data | is like "or"
13:15:56 <Cale> yeah
13:16:02 <awesomo4000> that makes sense.
13:16:06 <johnw> ReinH: thanks for the heads up; this is going to be deprecated and reworked very soon.  Tekmo coded the thing I'd been waiting for today.
13:16:15 <ReinH> johnw: oh really?
13:16:18 <johnw> yep!
13:16:19 <Cale> But data constructors may also have arguments, for instance, we might have something like  data FancyColour = RGB Word8 Word8 Word8 | CMYK Float Float Float Float
13:16:21 <ReinH> What thing?
13:16:41 <johnw> two interface functions for translating pipes to/from Boehm-Berarducci encoding forms, like what simple-conduit does
13:16:54 <Cale> Which gives us things like  RGB 245 128 0 :: FancyColour
13:16:57 <ReinH> johnw: oh, so you can express simple-conduit in pipes now
13:17:05 <johnw> i'll rewrite it as pipes-simple, but yeah
13:17:14 <ReinH> johnw: neat
13:17:27 <Cale> and CMYK 0 0.2 0.5 0.1 :: FancyColour
13:17:28 <johnw> it will mean core pipes support for translating between the representations
13:17:35 <ReinH> johnw: the one issue with simple-conduit for me is the lack of ecosystem. If it's core pipes compatible that's a big win.
13:17:36 <Cale> awesomo4000: Make sense so far?
13:17:40 <awesomo4000> how do you describe     the "::"  after constructing a RGB or CMYK
13:17:46 <Cale> "has type"
13:17:53 <awesomo4000> ok. is that necessary ?
13:17:54 <johnw> ReinH: yes, that's the hope; I want to borrow in as much ecosystem as possible, to avoid bifurcation
13:18:00 <Cale> It's not necessary
13:18:02 <ReinH> joneshf-laptop: indeed!
13:18:07 <Cale> I'm just expressing what type these things have
13:18:14 <Cale> The type can be inferred
13:18:43 <ReinH> johnw: I really like the design of simple-conduit
13:18:44 <Cale> Types can also have type arguments
13:18:48 <awesomo4000> is there a time when '::' is required during construction
13:19:04 <awesomo4000> is it called object construction in Haskell ?
13:19:09 <Cale> It may be used to avoid ambiguities
13:19:13 <johnw> ReinH: thanks!
13:19:30 <ReinH> johnw: the more final encoding more directly maps onto denotation, which is actually nice for reasoning about how pipes/conduit work in general
13:19:56 <johnw> as long as you bear in mind the push/pull role switch
13:20:08 <ReinH> "Oh, a conduit is a source homomorphism", etc
13:20:12 <johnw> yeah
13:20:34 <Cale> If the compiler can't infer some type because there's more than one possibility and something specific must be chosen (this happens when using type classes in certain cases), then giving an explicit type annotation can help it decide
13:20:35 <kazagistar> awesomo4000: "show . (+1) . read"
13:20:38 <johnw> ok, you make me excited to work on it now, but I have other work to  do :)
13:20:45 <Cale> right, like kazagistar's example
13:21:01 <Cale> Which type does read need to parse? Double? Integer?
13:21:03 <awesomo4000> > show .(+1). read
13:21:04 <lambdabot>  <[Char] -> [Char]>
13:21:08 <ReinH> johnw: So is a sink a Source-algebra?
13:21:21 <ReinH> johnw: heh :)
13:21:42 <Cale> Aggressive defaulting will make it pick Integer, but if that weren't turned on, you'd get an ambiguous type error
13:21:51 <johnw> ReinH: I don't know what you call a higher-order algebra
13:22:04 <johnw> instead of f a -> a, it's t m a -> m a
13:22:09 <ReinH> johnw: well luckily we have a Cale here, although he is otherwise engaged
13:22:13 <johnw> so it's an algebra for 't' in the category of endofunctors
13:22:16 <Cale> (and in any case, it may default to something you didn't want it to)
13:22:35 <awesomo4000> :t show
13:22:36 <lambdabot> Show a => a -> String
13:22:39 <ReinH> johnw: well, f ~ t, a ~ m a, and Robert is your father's brother?
13:22:40 <Cale> :t read
13:22:41 <lambdabot> Read a => String -> a
13:22:53 <awesomo4000> :t (+1)
13:22:54 <johnw> ReinH: except that t m a is (t m) a, and not t (m a)
13:22:54 <lambdabot> Num a => a -> a
13:22:56 <spopejoy> wtf is ~.
13:23:04 <awesomo4000> :t ~
13:23:05 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:23:07 <ReinH> johnw: oh, but something something naturality?
13:23:11 <johnw> haha
13:23:15 <spopejoy> when I see that in GHC errors I reach for my revolver.
13:23:18 <ReinH> johnw: heh
13:23:20 <johnw> categorical hand-waving? :)
13:23:27 <pavonio> :k (~)
13:23:28 <lambdabot> k -> k -> Constraint
13:23:29 <ReinH> (I'm kind of serous?)
13:23:32 <ReinH> *serious
13:23:43 <geekosaur> ~ is type equality
13:23:56 <Cale> awesomo4000: So anyway, back to data declarations, we can do things like this tree type
13:24:09 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
13:24:15 <johnw> right, being in the category of endofunctors, the "algebra" morphism is a natural transformation
13:24:24 <johnw> I just don't know what the right terminology here is
13:24:26 <Cale> This says that a tree of values of type a, is either a Leaf applied to some value of type a
13:24:33 <ReinH> johnw: me neither
13:24:38 <Cale> Or it's a Branch applied to two subtrees of values of type a
13:25:01 <spopejoy> ~ is equality, as in "the same type"? Not polymorphic?
13:25:11 <Cale> So, for example,  Branch (Branch (Leaf 1) (Leaf 2)) (Leaf 3) :: Tree Integer
13:25:28 <johnw> an algebrad
13:25:29 <johnw> haha
13:25:38 <ReinH> johnw: is that a thing?
13:25:40 <spopejoy> algebrangelina
13:25:43 <johnw> no, just kidding
13:25:44 <kazagistar> awesomo4000: so, we know that what is in the middle is (Num a, Read a, Show a), but it could be whatever implements those, so you want to give it a type, like "show . (+ (1::Int)) . read" because there is no way to annotate that externally
13:25:45 <ReinH> heh
13:25:47 <Cale> and,  Branch (Leaf "hello") (Branch (Leaf "there") (Leaf "world")) :: Tree String
13:26:07 <spopejoy> Is any (set + operations) an algebra?
13:27:00 <benzrf> is there a tool for converting html to hamlet or something
13:27:03 <ReinH> spopejoy: pretty much
13:27:08 <Cale> awesomo4000: still here?
13:27:11 <awesomo4000> yeah.
13:27:23 <Cale> awesomo4000: Okay, so does that Tree type make sense?
13:27:24 <johnw> well, I found a paper titled "Higher-order Algebras and Coalgebras from Parameterized Endofunctors", so maybe HO algebra is the right name
13:27:32 <ReinH> johnw: heh
13:27:39 <ReinH> Seems relevant...
13:27:50 <spopejoy> ReinH: so an ADT is ... what, inhabitants of the type, plus the constructors as the operators?
13:28:28 <Cale> awesomo4000: Here, Tree is what we'd call a type constructor (of one type parameter) -- it accepts a type argument, and produces a type, e.g. Tree String, Tree Integer, and Tree (Tree Double) are all types
13:28:46 <Cale> awesomo4000: A monad is first and foremost, a type constructor
13:28:59 <ReinH> spopejoy: ADTs have sums (data Thing = One | Another) and products (data Things = Things One Another) and these operations form an algebra
13:29:09 <benzrf> Cale: pfft
13:29:11 <Cale> awesomo4000: but it's not just any type constructor, it's one for which a specific couple of functions have been defined
13:29:23 <benzrf> ReinH: what sort of algebra do you mean
13:29:36 <spopejoy> ReinH: so the algebra is in the type domain
13:29:44 <johnw> spopejoy: exactly
13:29:52 <johnw> spopejoy: well, not quite exactly
13:29:53 <ReinH> benzrf: the algebra of sums and products
13:29:57 <johnw> it's not a type function, but a polymorphic one
13:30:01 <johnw> forall x. t m x -> m x
13:30:01 <Cale> awesomo4000: following? Feel free to ask questions if I don't make sense :)
13:30:05 <johnw> instead of m x -> x
13:31:14 <benzrf> ReinH: i mean
13:31:17 <spopejoy> But the "set" in the algebra of an ADT are the inhabitants as expressed in the sums and products, yes?
13:31:18 <ReinH> spopejoy: For more info, you might enjoy http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
13:31:20 <benzrf> ReinH: what is "an algebra" in this context
13:31:26 <benzrf> an f-algebr?
13:31:29 <johnw> yes
13:31:34 <ReinH> benzrf: an algebraic structure.
13:31:41 <benzrf> oh
13:31:49 <johnw> Functor f => f a -> a, where 'f' defines our set of operations and laws
13:32:15 <benzrf> johnw: actually that implies universal quantification
13:32:24 <benzrf> johnw: you should probably existentially quantify to be clear :y
13:32:24 <johnw> how do you mean?
13:32:32 <awesomo4000> ok. so this Tree being a type constructor
13:32:59 <johnw> if anyone wants to carry on the algebra discussion, let's go to #haskell-overflowh
13:33:06 <johnw> so that we don't swamp Cale and awesomo4000
13:33:15 <awesomo4000> > data Tree a = Leaf a | Branch (Tree a) (Tree a)
13:33:16 <lambdabot>  <hint>:1:1: parse error on input ‘data’
13:33:18 <spopejoy> let's all go to the lobby, and have ourselves a snack
13:34:00 <awesomo4000> lambdabot is not ghci it appears
13:34:02 <Cale> @let data MyTree a = Leaf a | Branch (MyTree a) (MyTree a)
13:34:04 <lambdabot>  Defined.
13:34:09 <Cale> :t Leaf
13:34:09 <lambdabot> a -> MyTree a
13:34:12 <Cale> :t Branch
13:34:13 <lambdabot> MyTree a -> MyTree a -> MyTree a
13:34:31 <Cale> > Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))
13:34:32 <lambdabot>  No instance for (GHC.Show.Show (L.MyTree a0))
13:34:32 <lambdabot>    arising from a use of ‘M557337988169061233119789.show_M5573379881690612331...
13:34:32 <lambdabot>  The type variable ‘a0’ is ambiguous
13:34:35 <Cale> oh, right :P
13:34:41 <ReinH> heh
13:34:45 <Cale> @undefine
13:34:46 <lambdabot> Undefined.
13:34:59 <Cale> @let data MyTree a = Leaf a | Branch (MyTree a) (MyTree a) deriving (Eq, Ord, Show, Read)
13:35:01 <lambdabot>  Defined.
13:35:12 <Cale> > Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))
13:35:14 <lambdabot>  Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))
13:35:18 <Cale> :t Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))
13:35:19 <lambdabot> Num a => MyTree a
13:35:31 <Cale> :t Branch (Leaf 1) (Branch (Leaf 2) (Leaf (3 :: Integer)))
13:35:32 <lambdabot> MyTree Integer
13:36:16 <int-e> @let data Foo = Bar
13:36:17 <lambdabot>  Defined.
13:36:27 <int-e> @let deriving instance Show Foo
13:36:28 <lambdabot>  Defined.
13:36:34 <int-e> > Bart
13:36:35 <lambdabot>  Not in scope: data constructor ‘Bart’
13:36:35 <lambdabot>  Perhaps you meant ‘Bar’ (line 157)
13:36:36 <int-e> > Bar
13:36:38 <lambdabot>  Bar
13:36:38 <Cale> Oh, that's a good point, could have used that :)
13:36:48 <Cale> I still forget that feature exists
13:37:14 <benzrf> @let data Simpson = Homer | Marge | Lisa | Bart | Maggie
13:37:15 <lambdabot>  Defined.
13:37:17 <benzrf> there, now u have Bart
13:37:24 <awesomo4000> :t Bart
13:37:25 <lambdabot> Simpson
13:37:30 <awesomo4000> :t Simpson
13:37:31 <lambdabot> Not in scope: data constructor ‘Simpson’
13:37:35 <Cale> :k Simpson
13:37:36 <lambdabot> *
13:37:39 <Cale> :k Tree
13:37:40 <lambdabot> * -> *
13:37:46 <awesomo4000> ahh ha. that's the problem i was having.
13:37:46 <Cale> :k Tree Simpson
13:37:47 <lambdabot> *
13:37:54 <awesomo4000> what's :k then
13:38:04 <Cale> It shows the kinds of type level things
13:38:07 <awesomo4000> :t is "show type of"
13:38:08 <lambdabot>     Not in scope: ‘is’
13:38:08 <lambdabot>     Perhaps you meant one of these:
13:38:08 <lambdabot>       ‘id’ (imported from Data.Function),
13:38:18 <awesomo4000> :k is "show kind of"
13:38:19 <lambdabot> Not in scope: type variable ‘is’
13:38:19 <Cale> kinds classify things at the type level the same way that types classify things at the value level
13:38:27 <Cale> yeah
13:38:34 <awesomo4000> Value isa Type isa Kind ?
13:38:44 <Cale> values are not types
13:38:49 <Cale> and types are not kinds
13:39:09 <awesomo4000> "has type of"  ?
13:39:15 <Cale> But every value has a type, and every type has a kind
13:39:31 <awesomo4000> ok. good.  i like to know the exact language to use.
13:39:40 * hackagebot repl-toolkit 0.1.0.0 - Toolkit for quickly whipping up command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.1.0.0 (jtapolczai)
13:40:03 <benzrf> awesomo4000: if u use coq or idris then all types are values and all values have types
13:40:06 <benzrf> :D
13:40:16 <Cale> In order to be a type with ordinary values, the kind should be *
13:40:20 <Cale> :k Integer
13:40:21 <lambdabot> *
13:40:36 <awesomo4000> i'm familiar with python metaclass programming .. this seems like that a little
13:40:37 <Cale> :k Maybe
13:40:37 <lambdabot> * -> *
13:40:40 <Cale> :k Maybe Integer
13:40:41 <lambdabot> *
13:40:53 <awesomo4000> except more well defined
13:41:50 <Cale> All monads have kind * -> *
13:42:00 <Cale> :k MyTree
13:42:01 <lambdabot> * -> *
13:42:20 <Cale> So one thing we might ask is whether there's a way to make MyTree into a monad
13:42:50 <awesomo4000> is there anything above Kind
13:43:19 <Cale> Usually if there is, it's called "sort"
13:43:51 <Cale> But not really in Haskell
13:44:00 <awesomo4000> What sort of kind of type is that value
13:45:26 <Cale> and then dependently typed languages typically introduce an infinite hierarchy here, but they tend to just call everything Type and subscript with natural numbers for the levels :)
13:45:42 <Cale> So that  Type n :: Type (n+1)
13:45:46 <awesomo4000> sounds like a class hierarchy
13:46:02 <Cale> and then e.g.  String :: Type 0
13:48:49 <Cale> So in order to make MyTree into a monad, we need to define
13:48:54 <Cale> return :: a -> MyTree a
13:48:55 <Cale> and
13:49:07 <Cale> (>>=) :: MyTree a -> (a -> MyTree b) -> MyTree b
13:49:47 <Cale> (and these are actually supposed to satisfy some laws, but I won't be picky about that for now)
13:49:58 <Cale> It turns out we can do this as follows:
13:50:02 <Cale> return v = Leaf v
13:50:13 <Cale> Leaf v >>= f = f v
13:50:34 <Cale> (Branch l r) >>= f = Branch (l >>= f) (r >>= f)
13:51:05 <Cale> return takes a value, and makes the simplest possible tree from it, giving just the leaf with that one value
13:51:58 <Cale> and (>>=) performs a kind of substitution, applying the function to the values of type a in the leaves of the given tree, getting trees of values of type b which get spliced in at each point
13:52:03 <chrisdone> Cale: might wanna check the pulse, the patient might be flatlining
13:52:32 <Cale> Anyway, the point isn't to really understand this particular monad here, it's sort of a funny example of one anyway
13:52:38 <awesomo4000> return makes anything into a MyTree
13:52:49 <monochrom> need to electrocute^W defibrate the patient :)
13:52:51 <awesomo4000> according to however you want to do it
13:52:58 <Cale> But just to understand what stuff you need to supply to make something into a monad
13:53:51 <Cale> Many of the monads we actually care about have a sort of "computational" flavour to them, so that there will be some type M t of "computations whose result will have type t when they're executed"
13:54:13 <Cale> and then return :: t -> M t will be a function which makes a "do nothing" computation that has the given value as its result
13:54:56 <awesomo4000> so if i wanted to do something side-effecty, i kind of wander out into monad land, then come back into non-monad land
13:55:26 <Cale> Well, the data type that you use to describe which effects you want to have occur might be an instance of Monad
13:55:38 <EvanR-work> it turns anything into a tree, but it must do so by following the monad laws, which constrains you somewhat
13:55:42 <Cale> which would mean that it supports these return and (>>=) operations
13:56:04 <Cale> and which in turn, gets you a library full of useful stuff that'll work with any instance of Monad at all
13:56:31 <EvanR-work> tree can also be a comonad, but you dont get a very big library of stuff automatically
13:56:56 <Cale> like sequence :: (Monad m) => [m a] -> m [a], which you might think of as taking a list of computations whose results have type a, and producing a computation whose result is a list of values of type a (by running them all and collecting the results)
13:58:06 <awesomo4000> :k Monad
13:58:07 <lambdabot> (* -> *) -> Constraint
13:58:18 <awesomo4000> :k Constraint
13:58:19 <EvanR-work> im not sure side effect is the right word for using a tree monad
13:58:19 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
13:58:20 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
13:58:27 <Cale> Yeah, there's this interesting Constraint kind
13:58:39 <Cale> Constraints are the things which go before the => in types
13:58:51 <Cale> and which serve to restrict the types over which type variables range
13:59:02 <Cale> A simpler example would be something like Eq
13:59:22 <awesomo4000> Eq means implements a boolean test for equality, right ?
13:59:31 <Cale> class Eq a where (==) :: a -> a -> Bool  (and some other stuff including (/=))
13:59:35 <Cale> yeah
13:59:50 <awesomo4000> "able to tell if a==a"
14:00:10 <awesomo4000> so with Monad, that [m a] syntax
14:00:24 <awesomo4000> is m type
14:00:30 <EvanR-work> in case of Eq, you should probably strive to implement an equivalence class, despite the fact that this isnt written down anywhere
14:00:43 <Cale> m :: * -> *
14:00:45 <Cale> a :: *
14:00:57 <Cale> m is our monad here
14:01:02 <monochrom> "it's best to answer in kind"
14:01:07 <chrisdone> lol
14:01:23 <Enigmagic> carter: hmm?
14:01:32 <awesomo4000> Monad is a kind
14:01:36 <carter> Enigmagic: llvm-general-typeable
14:01:39 <carter> *typed
14:01:58 <Enigmagic> carter: i was looking at it a little earlier... the main design issue i've been having is with call/invoke
14:02:09 <Cale> awesomo4000: Not technically, but monads are certain type constructors of kind * -> *
14:02:42 <Cale> You could imagine if we had subkinds of some sort that Monad would be a subkind of * -> *, but that's not how type classes actually work
14:02:43 <Enigmagic> carter: trying to make a uniform way to invoke functions where the parameters can either be mutable or constant
14:03:06 <carter> huh
14:04:41 * hackagebot vinyl 0.5 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.5 (JonSterling)
14:04:52 <Cale> awesomo4000: Monad m is a constraint which can be applied to a variable type constructor m to insist that it be an instance of the Monad type class
14:05:21 <Cale> awesomo4000: In the same way that we can use an Eq a constraint to insist that a be some type for which equality testing is defined
14:05:54 <Enigmagic> carter: so... llvm has two different types of values... constants and not-constants
14:06:00 <carter> yeahhh
14:06:03 <carter> you told me about that
14:06:04 <Enigmagic> carter: in llvm-general he has split them up into two data types
14:06:21 <carter> ahh
14:06:25 <carter> BUT?
14:06:40 <Enigmagic> carter: so i have a unified Value type that is parameterized by it's constant status (either constant or not)
14:06:52 <carter> yeah
14:07:30 <Enigmagic> carter: so the question is: should 'call' take Mutable values? the function being called doesn't really care if it's getting constants or not.
14:07:56 <carter> and it doesnt impact code gen?
14:08:17 <awesomo4000> this was the syntax from before that worked:
14:08:17 <awesomo4000> tail $ scanl (++) [] $ map (:[]) ['a'..'c']
14:08:25 <carter> Enigmagic: i mean, per se llvm variables are always pure
14:08:35 <awesomo4000> no return, no pure
14:08:37 <Cale> oh, right, I missed the initial bit of the conversation :)
14:08:50 <Enigmagic> carter: no. in terms of llvm-general a constant has to be converted into an operand to be passed to a function.
14:09:04 <Cale> yeah, someone just took advantage of the fact that return for the list monad is the same function as (:[])
14:09:25 <Enigmagic> carter: i just think a high level dsl shouldn't require manual conversion of constants to operands in order to be passed to a function..
14:09:36 <awesomo4000> that's the part i didn't fully understand
14:09:42 <awesomo4000> :t (:[])
14:09:43 <lambdabot> a -> [a]
14:09:45 <awesomo4000> :t return
14:09:46 <lambdabot> Monad m => a -> m a
14:09:49 <carter> Enigmagic: yeah
14:10:00 <carter> i guessyou're right
14:10:01 <awesomo4000> :[]  seems simpler
14:10:08 <carter> so is it about having a "operand lifting" trick now?
14:10:18 <Cale> sure
14:10:27 <carter> call :: OperandLiftable a => a - > ...
14:10:28 <Cale> There's nothing wrong with using (:[]) here
14:10:30 <awesomo4000> it has the least amount of surprise to me since there's no introduction of new words :)
14:10:34 <Enigmagic> carter: anyhow, i will be doing more work on it soon. if i can get that sorted out it's pretty much ready to go, needs better tests tho.
14:10:48 <carter> sweet
14:11:00 <carter> so its AOK aside from UX questions around that piece?
14:11:07 <Enigmagic> yeah
14:11:29 <carter> Enigmagic: did you see the transformers >= 0.3 fixup that hapepned?
14:11:39 <Enigmagic> carter: yeah
14:11:40 <Cale> Sometimes it really can help to recognise that you're using list monad operations, because in some cases it's possible to generalise the list monad to another monad, and give your programs interesting new features. But here I don't think it makes much difference whatsoever.
14:12:03 <carter> Enigmagic: i'm really happy about that
14:12:23 <awesomo4000> is there advantage to using return vs. (:[])
14:12:33 <Cale> return might be a little bit worse :P
14:12:50 <Cale> (but really, no, they ought to compile to the same thing in the end, at least if optimisations are turned on)
14:12:54 <bernalex> in general: return is more polymorphic. here: no.
14:13:17 <Cale> Yeah, return is more polymorphic, and to support that polymorphism, there's some hidden parameter passing going on
14:13:39 <Cale> (which may have a runtime cost in general)
14:13:47 <Cale> (but usually a trivial one)
14:14:27 <Luke> guys what are the core ways tasty and hspec differ?
14:14:40 <Luke> not just superficial differences but design differences etc
14:14:43 <Luke> the objectives
14:14:56 <bernalex> what's tasty? I might be interested in knowing how it's different from hspec since I use hspec heh
14:15:02 <awesomo4000> so this thing  - it returns all the prefixes for a list
14:15:19 <awesomo4000> of characters in a string
14:15:29 <Luke> bernalex: it's just another test framework
14:15:37 <Luke> bernalex: I think it might even be a fork of test-framework
14:16:02 <Luke> bernalex: http://documentup.com/feuerbach/tasty
14:16:18 <glguy> Is this what you guys are discussing?
14:16:19 <glguy> > tail (inits "abc")
14:16:21 <lambdabot>  ["a","ab","abc"]
14:16:50 <awesomo4000> it appears we were, yes.
14:17:24 <awesomo4000> how do i find out where inits comes from
14:17:59 <Cale> It comes from Data.List
14:18:05 <Cale> Hmm, there was once a command
14:18:09 <Cale> :index inits
14:18:09 <glguy> You can use /msg lambdabot ?index inits
14:18:12 <Cale> er
14:18:13 <pavonio> :hoogle inits
14:18:14 <Cale> @index inits
14:18:15 <lambdabot> Data.List
14:18:20 <glguy> Or search with Hoogle
14:18:21 <Cale> @hoogle inits
14:18:23 <lambdabot> Data.List inits :: [a] -> [[a]]
14:18:23 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
14:18:23 <lambdabot> Data.ByteString.Char8 inits :: ByteString -> [ByteString]
14:18:27 <Cale> yeah, that's a better answer
14:18:44 <Cale> I don't even know how @index does its thing
14:19:05 <bernalex> is it only for base?
14:19:09 <bernalex> @index (&)
14:19:10 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive
14:19:18 <Cale> It might even be for a horribly old version of base
14:19:22 <bernalex> interesting.
14:19:29 <Cale> I'm not sure
14:19:52 <Cale> (though that's clearly from fgl, so I dunno)
14:20:05 <awesomo4000> so originally i was just wondering why i needed to jump through hoops to use scanl with a list of Char as opposed to a list of Int
14:20:26 <Cale> Well... this would "work"
14:20:30 <awesomo4000> > scanl (+) 0 [0,1,2]
14:20:32 <lambdabot>  [0,0,1,3]
14:20:40 <Cale> > scanl (flip (:)) [] [1,2,3]
14:20:41 <lambdabot>  [[],[1],[2,1],[3,2,1]]
14:20:46 <awesomo4000> scanl (++) [] $ map (:[]) "ABC"
14:20:54 <Cale> but that gets them in the reverse order
14:20:57 <awesomo4000> > scanl (++) [] $ map (:[]) "ABC"
14:20:58 <lambdabot>  ["","A","AB","ABC"]
14:21:16 <Cale> > scanl (\xs x -> xs ++ [x]) [] [1,2,3]
14:21:17 <lambdabot>  [[],[1],[1,2],[1,2,3]]
14:21:27 <glguy> You don't have to jump through hoops, you just have to have something that makes sense
14:21:37 <glguy> (++) appends two lists, so you're going to need a list of lists
14:21:52 <glguy> Ah, and I guess that's what the long discussion was about :)
14:21:57 <Cale> Something to note: Performance-wise, this is a horrible way to use (++) -- you never want to be appending little things to the end of a list over and over
14:22:22 <awesomo4000> right.  how would this look with :
14:22:28 <Cale> This is because xs ++ ys must take O(length xs) time as it walks down xs
14:22:46 <monochrom> (+) for Int is not analogous to (++) for Char
14:23:25 <monochrom> > scanl (\x y -> chr (ord x + ord y)) ' ' ['A', 'B', 'C']
14:23:27 <lambdabot>  " a\163\230"
14:23:37 <Cale> @src inits
14:23:37 <lambdabot> inits []     = [[]]
14:23:37 <lambdabot> inits (x:xs) = [[]] ++ map (x:) (inits xs)
14:24:12 * awesomo4000 googles disable emoticons
14:24:32 <Cale> > foldr (\x xs -> [[]] ++ map (x:) xs) [[]] [1,2,3]
14:24:33 <lambdabot>  [[],[1],[1,2],[1,2,3]]
14:24:40 <monochrom> > scanl (\x y -> chr (ord x + ord y)) '\0' ['\1', '\2', '\3']
14:24:41 <lambdabot>  "\NUL\SOH\ETX\ACK"
14:24:46 <Cale> heh
14:25:30 <Cale> awesomo4000: Is it at least displaying (:[]) as a robot monkey like it ought to? :)
14:26:39 <monochrom> oh, an irc client that mucks up text behind your back?
14:26:53 <monochrom> I guess it was intended for non-programmers.
14:27:23 <Zemyla> There's no way to get at the address of a boxed object, is there?
14:27:53 <monochrom> that depends on how you will operate on the address.
14:29:35 <benzrf> awesomo4000: eeww
14:29:39 <glguy> Zemyla: Generally you shouldn't want/need to. What're you trying to do?
14:29:42 * hackagebot abt 0.1.0.1 - Abstract binding trees for Haskell  http://hackage.haskell.org/package/abt-0.1.0.1 (JonSterling)
14:30:21 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/System-Mem-StableName.html might be useful
14:31:03 <Zemyla> glguy: Just out of curiosity.
14:31:38 <awesomo4000> (:[])
14:31:43 <awesomo4000> nope. that's text.
14:32:37 <marchelzo_> Can anyone help me understand why this isn't working? http://lpaste.net/6995417752747900928
14:32:52 <marchelzo_> It returns Nothing when I really expect it to return (Just [1])
14:33:59 <monochrom> f [1] 1 = go [1] [] 0, with k=1
14:35:07 <marchelzo_> That seems correct
14:35:19 * glguy puts the envelope to his temple
14:35:25 <monochrom> go (1 : []) [] 0 = do { a <- go [] (1 : []) (0 + 1); b <- go [] (negate 1 : []) (0 - 1); return (a <|> b) }
14:35:27 <lpaste> glguy annotated “No title” with “Do I win?” at http://lpaste.net/6995417752747900928#a117551
14:35:29 <Cale> Zemyla: The problem with getting addresses of stuff is that by the time you can actually use that address for anything, the thing it was the address of might have moved
14:35:56 <glguy> marchelzo_: You should tell us things like what the function is supposed to do
14:36:27 <Cale> Zemyla: at least, for anything which is managed by the garbage collector
14:37:02 <marchelzo_> monochrom, so a should return (Just [1]), b should return Nothing and a <|> b should be (Just [1]), no?
14:37:14 <Zemyla> Cale: Even if it's evaluated to WHNF?
14:37:18 <monochrom> I don't know yet.
14:37:20 <Cale> yeah
14:37:34 <glguy> marchelzo_: No,  do  a <- Just [1]; b <- Nothing; ...
14:37:36 <glguy> is Nothing
14:37:50 <marchelzo_> glguy, ?
14:38:13 <marchelzo_> wait, is there an Alternative instance for [] a?
14:38:32 <glguy> marchelzo_: Nothing >>= _   is Nothing
14:38:42 <pavonio> > do a <- Just [1]; b <- Nothing; return (a, b)
14:38:43 <lambdabot>  Nothing
14:38:53 <glguy> b <- Nothing; ... means:    Nothing >>= \b -> ...
14:39:14 <marchelzo_> in my code, a <|> b, has nothing to do with the Maybe instance for alternative, does it?
14:39:42 <glguy> In your code <|> is operating on lists, but you're using the Maybe Monad instance in your do-notation
14:39:42 * hackagebot ghc-mod 5.2.1.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.2.1.2 (DanielG)
14:39:55 <marchelzo_> glguy, yeah I see that now... it's not what I meant to do
14:40:12 <glguy> marchelzo_: I pasted an annotation to your paste
14:40:15 <marchelzo_> It should be "let a = .... b = ... in a <|> b"
14:40:24 <khyperia> let's see if ghc-mod actually builds now...
14:40:32 <pavonio> > [1,2,3] <|> [4,5,6]
14:40:33 <lambdabot>  [1,2,3,4,5,6]
14:40:39 <danem> Hi I asked a similar question here a little while ago, but I didn't quite get things figured out. http://lpaste.net/4135286158600962048 What I'm looking to do is modify a value that may be present in a Map with lenses
14:41:10 <marchelzo_> monochrom, glguy, thanks.
14:41:12 <glguy> danem: What problem are you having.
14:41:37 <khyperia> yes, ghc-mod does build! Woo!
14:42:06 <danem> The example doesn't compile, and I can't quite figure out where I'm going wrong issue.
14:42:21 <danem> test1 and test2 are my attempts
14:42:27 <glguy> danem: What did you expect test1 to do?
14:42:38 <Cale> Zemyla: at any point in time, the copy collector might run, and when it does, pretty much everything moves.
14:43:39 <danem> grab "_foo" from State, grab "dict" from TypeA, select the value with the key '1', and if it exists grab the first item from the tuple
14:44:10 <danem> giving me back a Maybe Int
14:44:44 <glguy> test1 :: State -> Maybe Int
14:44:44 <glguy> test1 = preview (foo . dict . ix 1 . _1)
14:44:57 <glguy> There are a couple of things going on
14:45:34 <glguy> preview is just the name for the ^? operator. You had half your optics on one side of it and the other half on the other side
14:45:44 <glguy> You want to compose the thing into a single value
14:46:39 <danem> hmm, won't 'ix' do something different than 'at'?
14:46:40 <glguy> at and ix are similar, and you could use at with an extra step, but the difference is that    at 1 :: Lens' (Map Int (Int,String)) (Maybe (Int,String))
14:46:57 <glguy> while ix 1 :: Traversal' (Map Int (Int,String)) (Int,String)
14:47:13 <glguy> so if you want to use at you need to deal with the extra Maybe
14:47:17 <glguy> ix is just more direct
14:47:31 <danem> ah
14:48:06 <danem> i just assumed that it would throw an exception in the case of the key not being in the map
14:48:36 <danem> kind like a fromJust
14:48:57 <glguy> That wouldn't help you get a "Nothing" like you seemed to want when you picked ^?
14:50:34 <danem> Sorry, i don't follow. I chose ^? because I saw that it would return a Maybe
14:50:59 <danem> and wrapping it in preview accomplishes the same
14:51:03 <danem> i seee
14:52:41 <danem> and "use" is essential "gets"
14:52:46 <danem> correct?
14:52:50 <danem> essentially
14:53:06 <glguy> Yeah, very similar
14:53:10 <glguy> use = gets . view
14:53:19 <carter> wee, the netsplit is gone
14:55:57 <benzrf> :t use
14:55:58 <lambdabot> MonadState s m => Getting a s a -> m a
14:56:00 <benzrf> :t preview
14:56:01 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
14:56:04 <benzrf> :t preuse
14:56:05 <lambdabot> MonadState s m => Getting (First a) s a -> m (Maybe a)
14:56:25 <danem> hmm
14:56:58 <danem> so the difference is that I can modify state with preuse
14:57:06 <danem> while I can only read with preview
14:57:10 <danem> ?
14:57:15 <benzrf> well no you cannot modify
14:57:20 <benzrf> the return type is what is different
14:57:28 <benzrf> if you use the standard types instead of the classes, that looks like
14:57:38 <benzrf> (er, and specialize to prisms)
14:58:00 <benzrf> preview :: Prism s t a b -> Reader s (Maybe a)
14:58:14 <benzrf> wait... 1 sec
14:58:16 <benzrf> :t view
14:58:16 <lambdabot> MonadReader s m => Getting a s a -> m a
14:58:18 <benzrf> ok neaat
14:58:26 <benzrf> danem: here's the types, screwed-with a bit:
14:58:42 <benzrf> view :: Lens s t a b -> Reader s a
14:58:51 <benzrf> preview :: Prism s t a b -> Reader s (Maybe a)
14:58:58 <benzrf> use :: Lens s t a b -> State s a
14:59:08 <benzrf> preuse :: Prism s t a b -> State s (Maybe a)
14:59:18 <benzrf> danem: they're more general than that, but that's the basic idea
14:59:36 <benzrf> none of them modify, but some of them give non-modifying State actions
15:01:30 <danem> so i couldnt do something like "preuse (foo <%= bar)"
15:01:33 <danem> ?
15:02:55 <benzrf> no
15:03:03 <benzrf> preuse is preview but in State
15:03:17 <benzrf> i'm pretty sure you just want foo <%= bar
15:03:21 <benzrf> :t (<%=)
15:03:22 <lambdabot> (MonadState s m, Profunctor p) => Over p ((,) b) s s a b -> p a b -> m b
15:03:32 <benzrf> i see
15:03:39 <benzrf> how convenient :-o
15:03:42 <danem> ?
15:03:44 <danem> ha
15:03:56 <benzrf> i guessed that was what it did but
15:04:01 <danem> i wish I could appreciate the types as you do
15:04:03 <benzrf> :t (%<=)
15:04:04 <danem> : P
15:04:04 <lambdabot>     Not in scope: ‘%<=’
15:04:04 <lambdabot>     Perhaps you meant one of these:
15:04:04 <lambdabot>       ‘<=’ (imported from Data.Ord), ‘%%=’ (imported from Control.Lens),
15:04:06 <benzrf> danem: i dont, really
15:04:10 <benzrf> danem: i kinda glossed over it
15:04:20 <benzrf> danem: glanced at the significant looking bits :p
15:04:44 <benzrf> danem: i can't parse the Over, but the final result is an m b, and it takes a `p a b' which is probably an `a -> b' in practice
15:04:57 <benzrf> so i can kinda work out what it does, since i already figured it probably did that
15:05:22 <danem> well I'm not looking for an operator in particular, im just trying to wrap my head around how all of this works. to me, the type of preuse returns a State action. I don't know what a Prism is, so Ill ignore that,
15:05:31 <benzrf> oh
15:05:37 <danem> and isnt foo <%= bar a state action?
15:05:40 <benzrf> yes
15:06:16 <danem> but it wants a prism, not a state action as its first argument
15:06:39 <benzrf> no, it wants a lens
15:06:54 <benzrf> (<%=) is like (%=) except the action's result is the new value
15:06:59 <danem> o
15:07:00 <danem> right
15:07:05 <benzrf> er, wait...
15:07:07 <danem> i was looking at your translated types
15:07:14 <benzrf> :t (%=)
15:07:15 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
15:07:18 <benzrf> hmmm
15:07:30 * benzrf checks what Over desugars to
15:07:34 <benzrf> er, not desugar
15:07:35 <benzrf> w/e
15:08:45 <benzrf> oooohh
15:08:52 <danem> ?
15:08:59 <benzrf> ng
15:09:11 <danem> huh?
15:09:16 <benzrf> sorry, typo
15:09:24 <benzrf> yeah it's basically what i said
15:09:34 <benzrf> the Over seems unnecessary tbh
15:09:51 <benzrf> danem: do you know about profunctors
15:29:13 <danem> benzrf sorry i lost connection
15:29:34 <danem> Unfortunately I have to go, thanks for the help though : )
15:29:38 <danem> happpy new years
15:29:47 <danem> year
15:30:50 <benzrf> night
15:33:11 <matematikaadit> @where lyag
15:33:11 <lambdabot> I know nothing about lyag.
15:35:58 <matematikaadit> @where lysa
15:35:58 <lambdabot> https://learnmath.github.io/lysa
15:36:38 <hiptobecubic> `cabal install --only-dependencies -j` fails but without `-j` it doesn't. Logs are all empty. What's up with that?
15:38:02 <benzrf> argh
15:38:20 <Welkin> hiptobecubic: try putting -j before --only-dependencies ?
15:38:28 <benzrf> is there something like hamlet but for plain text and it doesnt do tags or anything, just the special commands and interpolation.
15:39:00 <hiptobecubic> Welkin, nope :(
15:40:39 <Welkin> benzrf: printf
15:41:18 <benzrf> Welkin: ewwwww
15:41:24 <benzrf> Welkin: anyway that doesnt allow for loops
15:41:58 <Welkin> you can convert html to plain text I think
15:42:02 <Welkin> or at least to markdown
15:42:04 <Welkin> use pandoc
15:42:24 <Welkin> markdown is very readable by itself
15:43:11 <Welkin> actually, you could use hamlet for plain text
15:43:16 <Welkin> just don't include any tags
15:51:19 <alkoma> is it possible to turn off -Werror on a package install with cabal?
15:53:46 <pingu> alkoma: I don't think so.
15:53:52 <pingu> I've wanted to do the same thing.
15:54:20 <pingu> Oh, do you mean -Werror on someone elses package? No. Workaround would be:
15:54:30 <pingu> cabal unpack the-package
15:54:37 <pingu> cd the-package && cabal install
15:54:48 <pingu> oh, and edit the package cabal ;)
15:55:15 <alkoma> pingu: yes, I think I will try that.  thanks!
15:55:41 <pingu> and obviously report it to the author as highly annoying, authors should not release packages with -Werror
15:56:40 <arrdem> iirc newbie questions are directed to #learn-haskell, right?
15:57:13 <pingu> I've not heard of that.
15:57:41 <pavonio> What does -Werror do exactly?
15:57:53 <simukis_> turn warnings into errors
15:57:53 <pingu> Anything that would be a warning causes build failure.
15:57:54 <alkoma> treat all warning as error
15:58:22 <int-e> #haskell-beginners has been recommmended
15:58:42 <arrdem> int-e: thanks
15:59:29 <pavonio> Hhm, shouldn't a package maintainer have checked if warnings occur on compilation if he's using -Werror?
15:59:49 <carter> pingu: ewww,
16:00:02 <carter> someone set -werror in a release build
16:00:04 <carter> ewww
16:00:07 <glguy> Things change when you build with different versions of libraries and ghc
16:00:22 <carter> glguy: yeah
16:00:32 <carter> glguy: i only get it set in travis
16:00:37 <carter> but i do leave -wall on
16:00:38 <alkoma> usually when the package were release, all were well and good.  But then along the way, some dependencies got updated/deprecated
16:00:56 <alkoma> then now the build got some warning that some package deprecated.
16:02:04 <pavonio> I see
16:02:08 <alkoma> the package I am trying to build is idris-0.9.15.1 actually.
16:02:26 <pingu> hmmn. I wouldn't have expected that.
16:03:01 <pingu> alkoma: idris looks fine to me at that version
16:03:10 <pingu> no mention of -Werror and cabal check is almost happy with it
16:03:32 <Zemyla> How does Data.Constraints work? Are there any tutorials?
16:04:46 * hackagebot liquid-fixpoint 0.2.1.1 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.1.1 (EricSeidel)
16:05:29 <pingu> Zemyla: someone might know in #haskell-lens if you don't get an answer here.
16:13:05 <cmo> i'm having an issue with renameDirectory. it says the directory doesnt exist when it actually does
16:13:16 <cmo> why might this happen?
16:13:30 <shachaf> Maybe it doesn't exist.
16:13:53 <cmo> like i said it does exist
16:14:34 <cmo> i check for existence first and if it does i call renameDirectory
16:14:50 <pingu> maybe it's not a directory.
16:14:50 <cmo> doesDirectoryExist acts as it should but not renameDir
16:15:00 <pingu> cmo: try stracing it
16:15:13 <pingu> maybe you can pin it down to a relative/absolute difference
16:15:57 <pingu> cmo: you'll be looking for stat and open in the strace
16:16:55 <awesomo4000> is there any way to use haskell functions in a manner similar to a shell pipeline
16:17:39 <pavonio> You can chain them with (.)
16:18:04 <pavonio> > ((*2) . succ . head) [1,2,3]
16:18:05 <lambdabot>  4
16:18:29 <pavonio> Except that it's backwards
16:18:48 <awesomo4000> yeah. i was hoping to go from left to right
16:19:01 <pingu> let (|) = flip (.)
16:19:04 <pingu> done!
16:19:31 <indiagreen> pingu: not done
16:19:37 <matematikaadit> cmo: could you give a stripped down example of your code that isn't working?
16:19:47 <indiagreen> “|” can't be an operator name
16:19:57 <pingu> semantics
16:20:06 <indiagreen> ah okay
16:20:21 <matematikaadit> but |> can
16:20:23 <indiagreen> awesomo4000: you can use “>>>” in Control.Arrow (I think it's there)
16:20:23 <awesomo4000> how could i put a parameter first
16:20:38 <awesomo4000> [ 1,2,3 ] | filter (>2) | max
16:20:59 <xpika> I'm looking for a data type with O(1) ++ and O(1) head. Does anyone know such a data type?
16:21:04 <pavonio> > let (#) = flip ($) in [1,2,3] # head # succ # (*2)
16:21:05 <lambdabot>  <hint>:1:7: parse error on input ‘)’
16:21:30 <pingu> awesomo4000: or you could decide to do it how most haskellers do
16:21:39 <pavonio> > let (!) = flip ($) in [1,2,3] ! head ! succ ! (*2)
16:21:40 <lambdabot>  4
16:21:41 <pingu> and just call your function f = max . filter (>2)
16:21:52 <pingu> and everyone else will understand, and you will be happy.
16:21:53 <matematikaadit> > let (|>) = flip ($) in [1,2,3] |> filter (>2) |> maximum
16:21:54 <lambdabot>  3
16:21:58 <indiagreen> or you could wait for (&), which should be in the next version of base
16:22:03 <pavonio> I'm sure (#) used to work in my code
16:22:06 <indiagreen> (&) = flip ($)
16:22:14 <indiagreen> and then maybe everyone will stop reinventing this one
16:22:37 <pingu> pavonio: I wouldn't use #, it's preview or review from lens
16:22:41 <pingu> (I forgot which)
16:23:00 <pavonio> I don't use lens
16:23:01 <matematikaadit> > let (<|) = ($) in maximum <| filter (>2) <| [1,2,3]
16:23:03 <lambdabot>  Couldn't match expected type ‘[[t0] -> b]’
16:23:03 <lambdabot>              with actual type ‘[a0] -> [a0]’
16:24:05 <pavonio> > let x = (#1, 2#) in x
16:24:06 <lambdabot>  <hint>:1:16: parse error on input ‘)’
16:24:18 <pingu> yeah, and it gets confusing with unboxed things
16:25:35 <athan> In attoparsec, if I have some composite data type, with `Parser`'s for them, can I just applicative-functor the components together into the larger data type, like how optparse-applicative handles parser construction?
16:25:59 <pingu> athan: yes
16:26:00 <Clint> athan: yes
16:26:13 <pingu> athan: you can use neat things like Alternative too
16:26:25 <athan> pingu wins! Clint, thank you also :)
16:26:55 <athan> pingu: Alternative gives us multiple parse expressons in one, right?
16:27:01 <athan> like a light cascade?
16:27:08 <athan> > Just 1 <|> Just 2
16:27:10 <lambdabot>  Just 1
16:27:14 <pingu> athan: yes
16:27:23 <pingu> you also get certain other primitives for "free" from just that
16:27:26 <athan> :t (<|>)
16:27:26 <lambdabot> Alternative f => f a -> f a -> f a
16:27:29 <pingu> being able to try one and then the other gives yo uthings like
16:27:31 <pingu> :t many
16:27:32 <lambdabot> Alternative f => f a -> f [a]
16:27:33 <athan> ahh, so they need the same parser type
16:27:38 <pingu> :t some
16:27:39 <lambdabot> Alternative f => f a -> f [a]
16:28:01 <athan> ahh man, that's awesome
16:28:05 <pingu> (the "thing" has to provide an alternative instance, though)
16:28:08 <pingu> parsers usually do
16:28:25 <athan> thanks pingu :)
16:28:28 <pavonio> > many $ Just 1
16:28:30 <pingu> no problem
16:28:32 <lambdabot>  mueval-core: Time limit exceeded
16:28:53 <pavonio> > some $ Just 1
16:28:56 <lambdabot>  mueval-core: Time limit exceeded
16:29:04 <athan> I wonder if there;s a dummy reader monad for a parser...
16:29:10 <pavonio> What's that for Maybe?
16:29:19 <pingu> pavonio: alternative? mplus, I think
16:29:35 <pavonio> some and many I mean
16:29:44 <athan> pavonio: I guess those two functions are meant to model functional alternative instances, or ones that do processing
16:29:57 <athan> I think there's an instance of alternative for `(a -> [a])`
16:30:03 <pingu> pavonio: it's nothing in particular
16:30:06 <benzrf> > 2^24
16:30:07 <pingu> alternative only needs <|> defined
16:30:07 <lambdabot>  16777216
16:30:10 <benzrf> dang
16:30:13 <pingu> some,many,etc are defined in terms of that
16:30:20 <pingu> the fact that it diverges is a little nasty...
16:31:00 <athan> Muahaha! MonadPlus is an instance!
16:33:37 <glguy> Cmo: if the source directory definitely exists then that probably means the target doesn't exist
16:35:41 <cmo> ok after struggling with it for an hour i finally figured it out. one of the directories in the middle of my filepaths needs to be created before moving the file
16:35:55 <cmo> why didnt i think of that earlier?
16:36:26 <matematikaadit> something like mkdir -p in bash?
16:36:35 <cmo> yeah
16:38:05 <pingu> cmo: there's one of those.
16:38:13 <pingu> createDirectoryIfMissing True
16:38:27 <cmo> thanks
16:38:27 <pingu> in the directory package
16:38:34 <Tekmo_> `optional` is a really nice `Alternative` utility
16:38:36 <Tekmo_> :t optional
16:38:37 <lambdabot> Alternative f => f a -> f (Maybe a)
16:43:34 <dfeuer> Tekmo_, do you have a nice clean way to concatMap a list of lists while simultaneously producing a list of lengths of the elements?
16:44:16 <dfeuer> That is, I want  fooThing xss = (concatMap xss, map length xss)
16:44:24 <dfeuer> But I don't want to do it in two passes.
16:44:42 <dfeuer> I'm sure I can work something out, but I'm also sure it will be ugly.
16:44:47 <Tekmo_> dfeuer: Yes, probably
16:44:57 <Tekmo_> dfeuer: Give me just a second
16:45:02 <dfeuer> er ... concatMap f xss
16:45:08 <dfeuer> Cooooool
16:45:19 <Tekmo_> A list of the lists before or after the concatMap?
16:45:24 <Tekmo_> *A list of the lengths
16:45:37 <dfeuer> Oh, sorry,
16:45:41 <dfeuer> I wrote that wrong, didn't I?
16:45:45 <dfeuer> 1 sec.
16:46:02 <neuroserpens> :t concatMap
16:46:03 <lambdabot> (a -> [b]) -> [a] -> [b]
16:46:49 <pingu> dfeuer: it's \f -> concat . map f
16:47:04 <pingu> *correction, neuroserpens: it's that ^^
16:47:07 <dfeuer> Tekmo_, don't worry so much about the map; the concat is the key bit there, I'd say.
16:47:11 <athan> Everyone, I'm thinking about making a Sass implementation for haskell web servers. Yay or Boo?
16:48:18 <dfeuer> Sorry, I'm looking at code I just wrote that's in a style I'm not yet accustomed to, so my brain is going a bit slowly.
16:51:36 <pavonio> :t \f ->  first concat . unzip . map (\x -> (f x, length x))
16:51:36 <lambdabot> ([a1] -> [a]) -> [[a1]] -> ([a], [Int])
16:51:58 <dfeuer> pavonio, no, wrong way 'round.
16:52:06 <dfeuer> Also, inefficient.
16:52:23 <pavonio> Wrong way?
16:52:38 <dfeuer> pavonio, you're taking the length of x and applying f to x.
16:52:55 <dfeuer> I want to apply f to x, take the length of the result, and also be concatenating the result to other stuff.
16:53:45 <pavonio> What's the inefficent part here, unzip?
16:53:49 <dfeuer> So I end up with something equivalent to  let mapped = map f xs in (concat mapped, map length mapped)
16:54:12 <dfeuer> pavonio, no, the big problem is length. That makes its own separate pass.
16:54:33 <dfeuer> pavonio, you have to weave the concatenation with the length calculation to make it efficient.
16:54:50 <dfeuer> My question for Tekmo_ was whether he knows a reasonably *clean* way to do that.
16:55:02 <pavonio> Hhm, okay
16:55:20 <dfeuer> Or if I just have to get down and dirty with yuckiness.
16:55:35 <Tekmo_> I think there is an *okay* way.  Just give me a second
16:55:47 <dfeuer> :-)
16:55:49 <matematikaadit> :t \xs -> let mapped = map f xs in (concat mapped, map length mapped)
16:55:50 <lambdabot> (FromExpr [a1], Show a) => [a] -> ([a1], [Int])
16:56:10 <matematikaadit> :t \xs f> let mapped = map f xs in (concat mapped, map length mapped)
16:56:11 <lambdabot> parse error on input ‘>’
16:56:17 <matematikaadit> :t \xs f -> let mapped = map f xs in (concat mapped, map length mapped)
16:56:18 <lambdabot> [a] -> (a -> [a1]) -> ([a1], [Int])
16:56:31 <dfeuer> I should mention that this is for an experimental change to Data.Tree, which means that it can depend on ... base, and probably nothing else.
16:57:03 <athan> Why isn't Builder a higher-kinded type?
16:57:31 <dfeuer> athan, what is Builder?
16:58:09 <athan> dfeuer: blaze-builder, I think it's mainly used for text concatenation, but I'm not sure
16:58:17 <athan> it just seems like an opposite-parser to me
16:58:27 <athan> I might be looking at it wrong, though
16:58:32 <dfeuer> Sorry, over my head.
16:58:50 <athan> :)
16:59:07 <MagneticDuck> the first message on #haskell in 2015: "pavonio: I see"
16:59:15 <MagneticDuck> great start to the new year
16:59:29 <vjsok> how are indentation-based languages like haskell parsed? Does anyone know of a good tutorial/example using something like parsec?
16:59:31 <pavonio> :D
17:00:04 <MagneticDuck> vjsok: they are parsed with indentation
17:00:10 <dfeuer> vjsok, it sounds like pavonio knows something about parsers!
17:00:29 <MagneticDuck> as for the parsec tutorial, you'll find a good one on RWH I believe
17:00:44 <yac> vjsok: space is a token as everything else
17:01:19 <vjsok> what specifically im talking about is keeping track of nested blocks
17:01:22 <vjsok> based on indentation
17:01:52 <vjsok> How can I parse something like this and know which blocks are parents and which are chilren? Can this be done with parsec?
17:02:40 <monochrom> it can be done but needs a clever, non-obvious way. and I haven't figured it all out yet.
17:02:40 <Tekmo_> dfeuer: Here you go: http://lpaste.net/117553
17:02:44 <athan> I think you could do some kinda monady stuff
17:03:27 <dfeuer> Tekmo_, thanks, but Control.Foldl is a no-go. If I want it I'll need to copy it.
17:03:31 <dfeuer> (blech)
17:03:35 <monochrom> but yeah part of it is you now have to consider spaces and newlines as tokens.
17:03:52 <dfeuer> Tekmo_, this is for Data.Tree which isn't allowed to depend on such things.
17:04:00 <Tekmo_> dfeuer: Oh, I see
17:04:13 <dfeuer> I assume premap is something from foldl?
17:04:29 <Tekmo_> dfeuer: Yes
17:04:36 <matematikaadit> :t foldr (\x (xss,lss) -> let xs = f x in (xs:xss, length xs : lss)) ([],[])
17:04:38 <lambdabot> (FromExpr [a1], Show a) => [a] -> ([[a1]], [Int])
17:04:38 <dfeuer> Whoa, wait, what? There's a concat *and* a concatMap?
17:04:42 <dfeuer> :t premap?
17:04:43 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:04:44 <dfeuer> :t premap
17:04:45 <lambdabot>     Not in scope: ‘premap’
17:04:45 <lambdabot>     Perhaps you meant ‘rmap’ (imported from Control.Lens)
17:04:50 <dfeuer> :t Control.Foldl.premap
17:04:51 <lambdabot> Not in scope: ‘Control.Foldl.premap’
17:04:55 <dfeuer> BRR
17:04:56 <matematikaadit> :t \xs f -> foldr (\x (xss,lss) -> let xs = f x in (xs:xss, length xs : lss)) ([],[]) xs
17:04:56 <lambdabot> [a] -> (a -> [a1]) -> ([[a1]], [Int])
17:05:24 <Tekmo_> matematikaadit: You may want to use a lazy pattern match for that
17:05:41 <matematikaadit> ah, it's wrong though
17:05:42 <vjsok> monochrom: 'tokens' are more of a lexer thing from my understanding, whereas parsec parses data straight into a structure
17:05:59 <dfeuer> Tekmo_, how do you end up with a concat *and* a concatMap there?
17:06:42 <Tekmo_> Think of `Fold a b` as sort of like `[a] -> b`
17:06:57 <dfeuer> OK....
17:07:05 <matematikaadit> :t \xs f -> foldr (\x (xss,lss) -> let xs = f x in (xs ++ xss, length xs : lss)) ([],[]) xs
17:07:06 <lambdabot> [a] -> (a -> [a1]) -> ([a1], [Int])
17:07:11 <Tekmo_> dfeuer: So the type of `list` is: Fold a [a]
17:07:21 <dfeuer> OK...
17:07:22 <Tekmo_> dfeuer: Which is analogous to `[a] -> [a]`
17:08:02 <Tekmo_> dfeuer: Now imagine that the `a`s are actually lists
17:08:13 <Tekmo_> dfeuer: i.e. `a = [x]`
17:08:19 <dfeuer> OK.
17:08:33 <dfeuer> I guess, but I'm still not there.
17:08:34 <Tekmo_> For simplicity, I'll just make `x` `a` to be consistent with the type signature
17:08:45 <Tekmo_> dfeuer: list :: Fold [a] [[a]]
17:09:09 <Tekmo_> dfeuer: When you apply `premap f`, that applies `f` to each incoming element
17:09:17 <Tekmo_> dfeuer: In this case, each incoming element is of type `a`
17:09:21 <Tekmo_> Oops
17:09:25 <Tekmo_> *is of type `[a]`
17:09:29 <Tekmo_> So:
17:10:17 <Tekmo_> \f -> premap (concatMap f) :: (a -> [b]) -> Fold [b] [[b]] -> Fold [a] [[b]]
17:10:47 <Tekmo_> The output type stays the same (`[[b]]` in this case), but the input type changes from `[b]` to `[a]`
17:11:01 <dfeuer> Zooom.... a bit over my head.
17:11:59 <dfeuer> Tekmo_, I also am very far from seeing how we avoid traversing each list once for concatMap and once for length; you're not using any sort of special versions of these!
17:12:19 <dfeuer> (even without understanding any of this machinery, I'd think I'd be able to see that part, I'd think.)
17:13:36 <Tekmo_> dfeuer: You're right.  That would require two successive applications of the trick
17:14:04 <Tekmo_> One for folding each inner list in a single pass and then one for folding the outer list in a single pass
17:14:15 <dfeuer> And this machinery is already over my head. I remember reading a bit about your foldl, but that was before I had even my current middling level of understanding of Applicative.
17:14:51 <dfeuer> So I guess I will write this out all by hand for right now and see where things go.
17:15:18 <Tekmo_> dfeuer: The general trick for writing it by hand is to translate it to a fold with a tuple accumulator
17:15:23 <dfeuer> If I get code that's correct and efficient but ugly, I'll ask for more help cleaning up.
17:15:29 <Tekmo_> dfeuer: If you want the fold to be lazy, you pattern match on the tuple lazily
17:15:39 <matematikaadit> dfeuer: another alternatives, fooThing ys f = foldr (\x (xss,lss) -> let xs = f x in (xs ++ xss, length xs : lss)) ([],[]) ys
17:16:10 <dfeuer> Tekmo_, unfortunately, while most of the containers package has QuickCheck and Criterion tests, Data.Tree has none. So I don't know if I'm right at all.
17:16:19 <dfeuer> matematikaadit, that's another thing that doesn't work.
17:16:40 <dfeuer> matematikaadit, there's absolutely no way to do what I'm trying to do while using Data.List.length.
17:17:08 <dfeuer> [short of hacking rewrite rules into the compiler]
17:17:09 <Tekmo_> dfeuer: Just take what he wrote and modify the step function to use yet another fold
17:17:50 <Tekmo_> dfeuer: You can compute the first and second element of that tuple in a single pass, too
17:18:22 <dfeuer> Tekmo_, I'll have to understand it first. There's almost certainly nothing gained, efficiency-wise, from writing this thing using foldr.
17:18:48 <dfeuer> [because it's processing something coming out of mapM]
17:19:08 <dfeuer> So whatever's most understandable will be the way to go.
17:19:39 <dfeuer> Tekmo_, ah, I understand now what you're saying.  xs++ and length xs go together nicely.
17:20:11 <Tekmo_> dfeuer: Also, note that you can simulate `foldl'` using `foldr`
17:20:29 <Tekmo_> dfeuer: If you are smart, you can compute the list lazily, but compute the length strictly
17:20:56 <Tekmo_> dfeuer: Actually, maybe not
17:21:06 <Tekmo_> dfeuer: ... because computing the length would require forcing the list anyway
17:21:25 <dfeuer> Tekmo_, ohhh
17:21:28 <dfeuer> but I *can*
17:21:36 <dfeuer> Because I don't actually need the length of the list, per se.
17:21:41 <dfeuer> That is smart!
17:21:49 <dfeuer> What I need is take (length xs) ys
17:21:59 <dfeuer> which *can* be done more betterly.
17:22:03 <Tekmo_> Yes
17:22:12 <Tekmo_> That's as simple as `zipWith const`
17:22:16 <dfeuer> This is getting more and more interestinger.
17:22:21 <dfeuer> Tekmo_, well, I lied.
17:22:29 <dfeuer> I actually need splitAt (length xs) ys
17:22:36 <dfeuer> So it's not quite that simple.
17:22:37 <Tekmo_> You can still do that lazily
17:22:38 <dfeuer> But it's still not bad.
17:22:40 <dfeuer> Yes.
17:24:01 <dfeuer> Tekmo_, in case you're interested, I'm trying to modify unfoldTreeM_BF and unfoldForestM_BF to use what Okasaki called a "level-oriented solution" in his note on breadth-first numbering.
17:24:50 * hackagebot target 0.1.0.0 - Generate test-suites from refinement types.  http://hackage.haskell.org/package/target-0.1.0.0 (EricSeidel)
17:25:02 <dfeuer> He was actually pushing a different approach there, involving a queue, but I think the level-oriented way is probably better here, and avoids the odd dependency of Data.Tree on Data.Sequenc.
17:25:09 <dfeuer> *Data.Sequence
17:26:20 <dfeuer> DUhhh
17:26:57 <dfeuer> er ...
17:27:00 <dfeuer> no, that doens't work.
17:27:16 <dfeuer> The zipppy thing is silly here.
17:27:20 <dfeuer> I think.
17:31:50 <EvanR-work> @src or
17:31:50 <lambdabot> or = foldr (||) False
17:32:50 <Tekmo_> Does anybody here know where there are good instructions for contributing to `base`?
17:34:18 <pingu> Tekmo_: No different to other libraries, I think, just more to consider:
17:34:23 <pingu> https://www.haskell.org/haskellwiki/Library_submissions
17:34:46 <lpaste> “[domi]” pasted “Pull Numbers out of String” at http://lpaste.net/117554
17:35:08 <Tekmo_> pingu: In this case it's implementing the `Monoid` instance for `IO` that I proposed earlier.  Would that be a modification to `ghc`?
17:35:23 <dfeuer> Tekmo_, base is managed through the GHC Trac and Phabricator.
17:35:39 <dfeuer> The normal process is to open a GHC Trac ticket,
17:35:51 <dfeuer> then submit a code review using Phabricator,
17:35:59 <dfeuer> make them point at each other, and all that.
17:36:05 <dfeuer> Have you ever used Phabricator?
17:36:11 <dfeuer> Or Arcanist?
17:37:11 <dfeuer> Actually that zip trick might be *necessary* to get maximal laziness. Hmmmm!
17:37:35 <dfeuer> But whether I need to is another question.
17:37:52 <pingu> Tekmo_: I think you may be best with an email to the libraries list.
17:37:58 <benzrf> dfeuer: those are in php >:o
17:38:00 <pingu> (to start with)
17:38:04 <Tekmo_> pingu: I already proposed it and they accepted it
17:38:09 <pingu> ah. okay.
17:38:29 <EvanR-work> is it possible to tail recursively traverse a tree
17:38:30 <dfeuer> Tekmo_, basically, you follow the instructions on the GHC Trac page for setting up Arcanist,\
17:38:47 <dfeuer> then you commit your change in some branch, and run "arc diff"
17:38:57 <dfeuer> And then BOOM it's on Phabricator and runs CI.
17:39:09 <Tekmo_> Alright
17:39:50 <pingu> Tekmo_: there's a "component" in track for core libraries, so you'd be submitting against that
17:40:45 <pingu> Tekmo_: from the HIW @ ICFP, if you like talks: https://www.youtube.com/watch?v=tq2Mo7NsO5w
17:41:08 <pingu> Camera work is pretty shoddy actually, maybe nevermind.
17:43:08 <pingu> It gets better by the end.
17:43:59 <pingu> I think I just looked at the few seconds it was getting fiddled with, good timing.
17:49:09 <kvanb_> Tekmo_: hello
17:49:33 <SaulHarris> pingu: how is the web scraping situation with haskell?
17:49:51 * hackagebot egison 3.5.2 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.2 (SatoshiEgi)
17:55:17 <pingu> SaulHarris: not sure, never done it. There's tagsoup and http libraries.
17:55:26 <pingu> And there's selenium things if you're into that.
18:03:42 <SaulHarris> oic
18:09:07 <jle`> is this the liftA2 mappend instance
18:09:32 <prophile> no you're the liftA2 mappend instance
18:09:38 <benzrf> oh snAP
18:09:51 <jle`> such burn :'(
18:09:58 <benzrf> >memeing
18:11:27 <dfeuer> Can someone have a peek at https://github.com/haskell/containers/pull/126/files ?
18:12:02 <prophile> dfeuer: it appears to be a diff
18:12:10 <dfeuer> Any guesses as to whether it's correct or fast?
18:12:39 <prophile> I'm sure it'll apply pretty quickly, it's only a few lines
18:12:44 <dfeuer> *sigh*
18:13:02 <dfeuer> That's not very helpful.
18:13:08 <prophile> sorry
18:13:51 <benzrf> prophile: lol
18:15:06 <dfeuer> benzrf, you are welcome to have a look! Maybe you will have an opinion!
18:16:10 <benzrf> dfeuer: ( ͡° ͜ʖ ͡°)
18:16:46 <dfeuer> benzrf, whazzat mean? I just realized I cited the wrong citation of the citation... gotta fix that. Ignore that aspect....
18:17:29 <prophile> dfeuer: with the caveat that I have drunk enough alcohol to have seriously questioned whether I may be a mince pie, surely its being fast is a matter for getting some profiling rather than code review?
18:18:07 <dfeuer> prophile, yes, to a point. I have no benchmarks for it, and I don't know who uses it how, so that will take some doing.
18:19:06 <prophile> not to sound like a sysadmin but if it's in low enough use to be asking that, is it worth making changes that risk making it incorrect?
18:20:28 <dfeuer> prophile, I have no *idea* how much it's used.
18:22:04 <dfeuer> There's actually bin some interest around it lately, with Yitzchak Gale and João Cristóvão talking about expanding its API.
18:22:08 <dfeuer> *been
18:22:18 <prophile> is there perhaps some way to search through hackage packages that depend *on* it?
18:22:25 <dfeuer> I don't know.
18:22:32 <prophile> that won't give a complete picture but might give some kind of a sample
18:22:43 <geekosaur> @where revdeps
18:22:43 <lambdabot> http://packdeps.haskellers.com/reverse
18:24:09 <dfeuer> geekosaur, not so helpful, because it's lumped in with containers. I proposed that containers should be split (Map,Set,IntMap,IntSet;  Data.Sequence;  Data.Tree;  Data.Graph)
18:24:16 <dfeuer> But there's not currently much interest.
18:25:37 <dfeuer> geekosaur, what I'd really want would be reverse deps by module, or even better by function.
18:28:50 <pingu> dfeuer: couldn't you just split it, then containers becomes a dummy package that re-exports the split ones?
18:29:02 <dfeuer> pingu, that's what I suggested, yes.
18:30:07 <pingu> ah, so you're looking for the packages that only want half. perhaps abusing deprecation warnings is an option there so that authors work it out themselves?
18:31:04 <pingu> dfeuer: alternately, take that list, cabal unpack the lot of them and go grepping through the cabal files ;)
18:31:20 <dfeuer> pingu, it's a very long list.
18:31:38 <pingu> yeah, containers is pretty universal
18:32:12 <pingu> dfeuer: you can just grab the .cabal file though
18:32:18 <pingu> e.g. https://hackage.haskell.org/package/roundtrip-0.2.0.3/roundtrip.cabal
18:32:27 <pingu> that shouldn't take much space/time
18:33:08 <pingu> ah, no, I am being silly, you need the sources.
18:33:15 <dfeuer> *sigh*
18:33:17 <dfeuer> Yeah.
18:33:27 <dfeuer> Also, that's too much tools for me.
18:33:34 * dfeuer hates how many damn tools he's expected to learn.
18:33:55 <pingu> a shell script? ;)
18:34:01 <pingu> you'll use that for the rest of your life
18:34:32 <benzrf> noot
18:34:45 <dfeuer> I'd rather learn to do system programming in Haskell (or Scheme, or, hey, maybe Prolog) than learn bash.
18:34:52 * hackagebot extensible 0.0 - Extensible ADTs  http://hackage.haskell.org/package/extensible-0.0 (FumiakiKinoshita)
18:40:25 <mariothemad> you're going to have to learn to use bash (or zsh or whatever) at some point
18:40:30 <mariothemad> it's hella useful
18:40:36 <mariothemad> You lose nothing. Other than time.
18:44:33 <hiptobecubic> dfeuer, futile. It's like saying you don't know want to know anything about javascript while you make your web app.
18:48:13 <Zer0Veritas> seems kind of backwards to learn java before bash imo
18:49:14 <dfeuer> Zer0Veritas, I know a lot more Java than I do bash.
18:50:26 <benzrf> eeew
18:50:33 <Zer0Veritas> yea, It just depends on your flavor of OS I guess. If your enviroment is mostly gui based then it I can definately see that
18:52:26 <Zer0Veritas> actually, it seems more common these days for people to learn oop languages before anything else
18:53:10 <nick_named> Is it possible to do something like this? http://lpaste.net/117555
18:55:58 <dfeuer> Zer0Veritas, I learned Logo, then BASIC, then Pascal, then C, then a tiny drop of C++, then more BASIC, then more Pascal, then some Perl, then some Haskell, Scheme, SML, and Java.
18:56:18 <dfeuer> In approximately that order.
18:57:26 <Zer0Veritas> ok I had to lookup what logo was ha
18:57:49 <dfeuer> Zer0Veritas, yeah, elementary school and middle school stuff :P
18:58:24 <Zer0Veritas> but I do remember BASIC ahh so much fun
18:58:34 <dfeuer> So disgusting.
18:58:39 <dfeuer> Perl reminded me of it very much.
19:05:45 <SharpGAF> dfeuer: Learning Java last can't have been pleasant.
19:06:09 <dfeuer> SharpGAF, no, not particularly, and it was a little before Generics came out, so even worse.
19:06:39 * SharpGAF spends most of his time in Java being frustrated.
19:07:06 <benzrf> SharpGAF: grose
19:07:29 <benzrf> generics sadden me
19:07:33 <benzrf> they're like
19:07:39 <benzrf> neutered parametric polymorphism
19:08:37 <prophile> I love the haskell community
19:08:38 <dfeuer> benzrf, that's better than *no* parametric polymorphism and casting everywhere!
19:08:45 <benzrf> ;-;
19:08:50 <benzrf> prophile: we love u too <3
19:08:52 <SharpGAF> dfeuer: People still write Java like that today.
19:08:53 <prophile> other groups would complain about java generics due to not "knowing the types" or not liking the syntax
19:09:04 <SharpGAF> Very recent libraries come out with no generics.
19:09:16 <prophile> but here it's because they don't generate free theorems
19:09:50 <nick_named> I'm trying to get an Arrow type in a type class to provide a default implementation, but I don't know how to do it, or if its possible.  Could anyone please help me?  A code snippet is at http://lpaste.net/117555
19:10:30 <dfeuer> prophile, well, they *sort of* do, if you squint hard enough.
19:10:47 <dfeuer> I believe.
19:11:00 <prophile> I fear if I squinted that hard at Java it would start to stare back at me
19:11:57 <dfeuer> @src liftM2
19:11:57 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:13:18 <dfeuer> No, I really cannot use liftM2 here, and for bleedin' obvious reasons. I need to turn off that bit of my brain.
19:17:40 <catery> Two aspects of continuations I don't understand that I hope someone can explain: (1) continuations are used in web frameworks  (despite http being stateless) for reasons I don't understand (2) continuations can give more performance
19:19:11 <brainacid> hello
19:19:20 <godel> hello brainacid
19:19:25 <brainacid> hi godel
19:19:38 <brainacid> man I really enjoy the process of learning Haskell
19:19:50 <brainacid> its changing my life
19:20:12 <brainacid> i really hope i get good karma cuz i want to be a ninja.. lol
19:22:03 <benzrf> "ninja.. lol" <- the mark of raANDom!11
19:22:59 <brainacid> benzrf, huh ... ;)
19:23:21 <benzrf> brainacid: http://realultimatepower.com/
19:23:33 <benzrf> er, wait
19:23:39 <brainacid> ok
19:23:40 <benzrf> sorry,
19:23:42 <benzrf> brainacid: http://realultimatepower.net/
19:23:47 <brainacid> its alright
19:24:17 <brainacid> lol
19:24:20 <brainacid> my name is Roberto
19:24:49 <Kaidelong> I am convinced that strict and non-strict stuff are the same in practice and that the paucity of types argument doesn't make sense
19:25:05 <Kaidelong> as in, you can mechanically translate one to the other, both ways
19:25:24 <kwf> Kaidelong: What do you mean by "strict and non-strict stuff"?
19:25:55 <Kaidelong> there is this argument that Haskell is inferior to ML because you can 'only' express data/codata mashups
19:25:59 <Kaidelong> you cannot separate the two
19:26:46 <Kaidelong> I think that if you mechanically translate ML to Haskell using GHC's strictness-introducing tools, this thing should disappear in practice
19:27:43 <Kaidelong> so the paucity of types argument is flawed. Pervasively working with lazy stuff is hard in ML
19:28:06 <Kaidelong> but it's not impossible to pervasively work with strict stuff in Haskell
19:28:31 <Kaidelong> if you do strict transformations on literally everything in your program, you end up with semantics like ML, so how can you claim a paucity of types?
19:29:33 <kwf> Kaidelong: That makes sense to me; AFAIK, ML makes it a lot harder to do laziness. Also, hard/impossible to be straightforwardly polymorphic over the strictness of your functions and values.
19:30:01 * hackagebot Deadpan-DDP 0.6.0.1 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.6.0.1 (LyndonMaydwell)
19:30:12 <Kaidelong> OTOH it's hard to not accidentally introduce unwanted non-strictness in Haskell
19:30:43 <kwf> Whereas in Haskell, we don't have to have two versions of, e.g. map, to accommodate a lazy and strict mappand.
19:30:52 <Kaidelong> but I think it's an issue of style, it's not something ML has that Haskell doesn't, you can do it in Haskell (maybe not Haskell 98?) it just isn't the default
19:31:09 <kwf> It's annoying in Haskell '98 because you don't have bang patterns.
19:31:13 <Kaidelong> the arguments that Haskell is less safe than ML I understand better
19:31:13 <Kaidelong> they are not very convincing, because it again does not really matter in practice
19:31:29 <kwf> Which arguments about safety are you talking about?
19:31:52 <Kaidelong> and there is SafeHaskell anyway
19:32:02 <lpaste> Zemyla pasted “Type equality failure” at http://lpaste.net/117561
19:32:37 <Kaidelong> but I understand why you might want to write in ML instead of you are really concerned about not wanting to subvert the type system
19:32:37 <Kaidelong> however the paucity of types argument doesn't make sense to me. Even if the haskell standard has that problem, actual haskell does not appear to
19:33:23 <kwf> Are you saying that the existence of unsafeCoerce and friends is used as an argument against Haskell?
19:34:05 <geekosaur> doesn't that instance want to be instance (c ~ HFalse) => Castable a b c where?
19:34:13 <Kaidelong> kwf: and things like bad typeable instances, which I understand don't work in the new GHC anymore anyway.
19:34:35 <geekosaur> otherwise c doesn't come into play in the instance head
19:34:43 <Kaidelong> This is how Harrop's posts usually read to me anyway
19:35:06 <kwf> Kaidelong: Indeed, they don't. And the old bug with GeneralizedNewtypeDeriving + GADTs = unsafeCoerce is fixed by type roles in newer GHC as well.
19:35:12 <Kaidelong> to me these "problems" seem like reasonable tradeoffs to be more expressive. C++ isn't very safe either, but it's useful
19:35:26 <Kaidelong> In some regards Haskell is more like C++ than it is like SML, and really, this is fine
19:35:31 <Kaidelong> different problem domains
19:36:13 <dfeuer> Kaidelong, no, Haskell is not more like C++ than like SML.
19:36:58 <dfeuer> Haskell makes you declare, right at the top of your module: "I really swear I know what I'm doing, and I won't shoot myself in the foot" in order to use horribly unsafe things.
19:37:31 <Kaidelong> yes, that's the other thing
19:37:33 <dfeuer> import GHC.Exts, import Unsafe.Coerce, etc.
19:37:37 <Kaidelong> Haskell lets you shoot yourself in the foot
19:37:42 <Kaidelong> but you have to make it very clear
19:37:44 <dfeuer> Kaidelong, so does ML.
19:37:57 <Kaidelong> "I am going to shoot myself in the foot"
19:37:58 <Kaidelong> which is much better than the situation with things like C++
19:38:20 <Kaidelong> that's true
19:38:34 <Kaidelong> you can turn off the type system in ML with a compiler flag, can't you?
19:38:38 <dfeuer> You can really shoot yourself in the foot in any language; C++ makes it hard *not* to.
19:38:47 <Kaidelong> so that you can use things like polymorphic recursion
19:38:53 <dfeuer> Kaidelong, I dunno. But you can certainly erase your filesystem!
19:39:16 <SharpGAF> dfeuer: Depends on the file system :)
19:39:17 <Kaidelong> so even in this case the argument doesn't make too much sense. There are ways to shoot yourself in the foot in Haskell, because having ways to shoot yourself in the foot is actually somewhat important
19:39:32 <dfeuer> Yep.
19:39:47 <Kaidelong> there are also different ways to shoot yourself in the foot in something like ML
19:40:09 <dfeuer> But Haskell keeps making it easier to avoid needing those features, with things like Data.Coerce, which is great!
19:40:45 <dfeuer> And easier to impose stricter discipline, with GADTs.
19:41:16 <kwf> Kaidelong: Which ML variant are you talking about which requires you to disable type-checking for polymorphic recursion?
19:45:19 <Zemyla> Jesus Christ, why can't I do anything with even type equality?
19:45:54 <benzrf> Zemyla: hhhhuh?
19:49:13 <godel> Zemyla: what do you mean?
19:49:45 <Zemyla> Never mind for now.
19:52:05 <hnfmr> a quick question about cabal install, if I install a lower version of an installed library, does the newer version get overriden?
19:52:47 <benzrf> probbly, hnfmr
19:53:10 <geekosaur> if not specified, the latest one will generally be used. cabal can override this via dependencies; and if you are also linking against libraries which were built against an older version, you really need to constrain to that older version or the compile will fail
19:53:16 <hnfmr> it seems there is cabal remove
19:53:18 <hnfmr> there is no
19:53:34 <Kaidelong> I'm using IntelliJ for Haskell now, is there any way to set up tooltips that show types and documentation?
19:53:37 <geekosaur> ghc-pkg unregister
19:53:48 <hnfmr> thanks geekosaur
19:59:41 <lpaste> “[domi]” revised “Pull Numbers out of String”: “TwoDigitFromString” at http://lpaste.net/117554
20:00:20 <[domi]> Ah. Didn't realize that automatically posted here. =o
20:25:36 <dfeuer> @hoogle Applicative f => (a -> f b) -> [[a]] -> f [[b]]
20:25:38 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:25:38 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
20:25:38 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
20:25:57 <dfeuer> @hoogle Monad f => (a -> f b) -> [[a]] -> f [[b]]
20:25:57 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:25:57 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:25:57 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
20:27:32 <dfeuer> No, not that.
20:27:46 <benzrf> dfeuer: did you mean:
20:27:48 <benzrf> traverse . traverse
20:27:52 <benzrf> :t traverse . traverse
20:27:53 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
20:28:26 <benzrf> > [[1, 2, 3, 4], [5, 6, 7], [8], [9]]^..traverse.traverse
20:28:27 <lambdabot>  [1,2,3,4,5,6,7,8,9]
20:28:46 <dfeuer> benzrf, I am not sure what I mean.
20:28:54 <dfeuer> Maybe.
20:29:09 <benzrf> > [["ay", "y ", "lm", "ao"], ["ay", "y ", "lm"], ["ao"], [":)"]]^.traverse.traverse
20:29:10 <lambdabot>  "ayy lmaoayy lmao:)"
20:29:22 <benzrf> dfeuer: what are you trying to do
20:29:26 <dfeuer> benzrf, I don't know what this ^. is.
20:29:30 <benzrf> dfeuer: lens view
20:29:31 <Welkin> :t (^.)
20:29:32 <lambdabot> s -> Getting a s a -> a
20:29:44 <Welkin> I still haven't learned lens
20:30:22 <dfeuer> benzrf, I'm trying to take a list of lists, perform an action based on each element, then put the results together with the original structure.
20:30:31 <dfeuer> At least, I think that's what I'm trying to do.
20:31:12 <benzrf> sounds like nested traversal
20:31:31 <benzrf> traversals and lenses compose dont they
20:31:37 <benzrf> :t mapM . mapM
20:31:38 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m [[b]]
20:31:42 <benzrf> ^that, even
20:31:52 <Welkin> traverse manintains structure
20:32:03 <benzrf> mapM is list traverse
20:32:09 <Welkin> yes
20:32:09 <benzrf> w/ monad instead of appl
20:32:30 <dfeuer> I think that might be what I want, but my head's spinning just a wee bit.
20:33:02 <dfeuer> (and no, I'm not drunk)
20:33:08 <dfeuer> (just Haskelling)
20:36:12 <dfeuer> benzrf, I'm lost. Maybe you can help. I'm trying to write an implementation of Data.Tree.unfoldForestM_BF that doesn't use a queue.
20:36:18 <dfeuer> I think I even have one.
20:36:32 <dfeuer> Based on a different implementation from Okasaki's same note.
20:36:48 <dfeuer> But one piece I used from his thing is uggggly
20:36:54 <dfeuer> and I don't know if I can get rid of it.
20:37:50 <dfeuer> But I really want to.
20:38:25 <benzrf> i dont know ude
20:38:29 <benzrf> *dude
20:38:36 <benzrf> i have 0 efficientcy knowledge
20:38:43 <dfeuer> benzrf, don't worry about efficiency!
20:39:09 <benzrf> im tired
20:39:10 <dfeuer> benzrf, my first goal here is to make it simple and clean.
20:39:14 <dfeuer> Yeah, me too.
20:39:14 <benzrf> aaaaaaa
20:39:31 <dfeuer> I have the feeling it will be efficient too, but simple and clean first.
20:52:02 <hiptobecubic> hsqml looks like a pretty "good enough" answer to gui programming
20:54:21 * hackagebot extensible 0.0 - Extensible ADTs  http://hackage.haskell.org/package/extensible-0.0 (FumiakiKinoshita)
20:54:21 * hackagebot Deadpan-DDP 0.6.0.1 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.6.0.1 (LyndonMaydwell)
21:03:28 <fugyk> What are endofunctors?
21:04:06 <shachaf> An endofoo is a foo from something to itself.
21:04:35 <shachaf> So an endofunctor is a functor from a category to itself.
21:05:33 <fugyk> I can find that by searching but what is mapping from category to itself.
21:06:15 <shachaf> OK, so you're asking what a functor is in general?
21:06:17 <fugyk> Everything maps from category to itself, right.
21:07:10 <zq> happy new year, #haskell
21:07:30 <notthemessiah> zq: it's only new years in one time zone you insensitive clod
21:08:55 <fugyk> shachaf: what is the difference between functor and endofunctor?
21:09:00 <zq> happy new year #haskell // notthemessiah
21:09:16 * hackagebot data-rev 0.1.0.0 - A typeclass for reversing order of contents.  http://hackage.haskell.org/package/data-rev-0.1.0.0 (jxv)
21:10:48 <shachaf> fugyk: A functor is from some category C to some category D.
21:11:10 <shachaf> If C is the same as D, it's called an endofunctor.
21:19:17 <Buttons840> is it code smell to have 10 data constructors in my type?
21:20:09 <Buttons840> data A = B Int Int  -- What is B called? a constructor?
21:20:41 <shachaf> Yes, B is a constructor.
21:21:23 <shachaf> It could be fine to have 10 of them for a sum type.
21:21:38 <Buttons840> what's a sum type?
21:24:37 <Buttons840> a google search suggests that a "sum type" is a type with more than one constructor?  obviously by definition it would be acceptable for a sum type to have more than one custructor then?
21:24:55 <thang1> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types
21:25:20 <thang1> I link this because it has cool things you can play with inside the 'tutorial' to see what sumtypes are more clearly
21:26:13 <thang1> Basically, bool is a sum type with two possible representations (true or false)
21:26:15 <Buttons840> that's where i got my definition from
21:26:32 <thang1> ah, right. I found it fairly clear to me by the time I kept reading down the page, myself
21:26:53 <Buttons840> representation == constructor ?
21:28:27 <shachaf> Scratch the words "for a sum type" from what I wrote if you want. I only meant to clarify.
21:29:50 <thang1> he disconnected lol
21:30:10 <matematikaadit> data Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday
21:30:29 <matematikaadit> that's 7 data constructor for type Day, and it's perfectly fine
21:33:10 <thang1> echoDay :: Day -> String ; echoDay d = case d of\n "Sunday" = "Monday" ; "Monday" = "Wednesday" ; "Tuesday = "Friday" ; default = "You're drunk and can't spell" ;
21:34:05 <thang1>  shit, %s/=/->/g
21:38:44 <Welkin> thang1: that is String -> String, not Day -> String
21:39:10 <Welkin> what is that supposed to do anyway?
21:39:13 <thang1> It was more of a joke than anything. I'm surprised it almost made sense, honestly
21:39:56 <thang1> If you requested "monday" from the program, you'd get back all the results for wednesday. If you requested Sunday you'd get all the results for Monday
21:40:03 <thang1> if you didn't request sunday, monday or tuesday, it'd throw an error
21:40:13 <Welkin> in a case expression, the "default" is denoted by _
21:40:24 <thang1> I wrote it really terribly because I didn't wanna think about it too hard, and I'm still learning haskell...
21:40:33 <Welkin> in pattern guards it is "otherwise"
21:41:55 <thang1> Ahh, right. I always get screwed up with that because I learned C first and C uses 'default' for switch/cases
21:42:39 <liyang> ('otherwise' is just another name for 'True'.)
21:44:07 <thang1> Makes sense, liyang. Didn't put 2 and 2 together
21:53:16 <hrumph_> hi
21:53:26 <hrumph_> in emacs what's the best kind of haskell indentation?
21:53:40 <thang1> hmm... I know this answer
21:54:53 <thang1> There are two large indentation packages for emacs right now, I believe. haskell-indentation and haskell-indent
21:55:09 <hrumph_> it says there is semi-atuomatic indentation, mark two by kristof bastianensen, semi-automatic endentation by guy lapalme, and simple dentation by graeme e moss and heribert schuetz
21:55:32 <hrumph_> thang1, so of the three which is the most suited to someone who knows fuck all about any of them and just wants to get shit done?
21:55:37 <hrumph_> pardon my language
21:56:44 <thang1> What packages for haskell do you have installed in emacs right now?
21:56:54 <hrumph_> i only installed haskell-mode
21:57:00 <hrumph_> so far
21:57:46 <thang1> check out flymake for syntax help
21:58:07 <thang1> Then there's structured-haskell-mode which will help you a lot with other stuff in haskell
21:58:38 <thang1> https://github.com/chrisdone/structured-haskell-mode here's some stuff it can do
21:59:09 <thang1> then there's something called "stylish-haskell" which basically prettifies haskell code for you by putting a "real" lambda inside the code, etc
21:59:16 <thang1> purely visual
21:59:18 <thang1> https://github.com/jaspervdj/stylish-haskell
22:01:52 <thang1> structured-haskell-mode should do everything you want as far as indenting goes, I think
22:17:09 <thang1> https://github.com/iquiw/company-ghc
22:17:12 <thang1> for autocompletion
22:34:35 <hrumph_> is there a class equivalent to the following?
22:34:39 <hrumph_> class Follows x where follows :: x -> x -> Bo
22:34:54 <hrumph_> sorry x->x -> Bool
22:35:14 <hrumph_> its just one binary predicate
22:35:29 <hrumph_> a binary predicate exists for the type
22:36:46 <marchelzo_> What about Eq?
22:37:06 <hrumph_> yes you are right now that i think of it....
22:37:33 <hrumph_> i don't think i should use it though because it might want to instantiate that one differently...
22:37:50 <hrumph_> and it would confuse the hell out of people if i used it in this case
22:37:57 <hrumph_> but you are right and i hadn't thought of that
22:38:18 <marchelzo_> Yeah, I don't know what exactly you mean by "follows", but maybe follows x y can return True even if x /= y.
22:38:54 <hrumph_> i don't know exactly what i mean either.. its like an alowable state...i.e. state2 follows state1 if i state 1 permits it
22:39:19 <marchelzo_> ah, yeah, don't use Eq, heh.
22:39:45 <thang1> Hmm... Sounds like you want more than one thing, almost
22:40:19 <hrumph_> i'm just making a slightly extended state monad
22:40:24 <thang1> Like objects will have a property of "being" state 1, and a property of "allowing" states 2, 3, ..., n to happen
22:40:37 <hrumph_> it'll default to a Nothing state when one state doesn't "follow" the previous one
22:40:58 <hrumph_> so the state monad will enforce some rules about what state transitions are permissible
22:41:02 <thang1> So shouldn't the objects be defined by which states they're allowed to have, and then keeping track of which state it's in by going "up" from zero and then going up to the next state if conditions permit?
22:42:14 <hrumph_> all states are possible...its can you go from a to b legally
22:42:26 <hrumph_> if you can't the state monad should go to the nothing state
22:42:36 <hrumph_> the extended state monad that i'm preparing now
22:42:52 <thang1> ooh okay
22:43:09 <thang1> Wasn't sure why you "wouldn't" be allowed to go into another state and misunderstood that part
22:45:39 <thang1> http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/ does this help at all?
22:47:47 <hrumph_> i already understand the state monad so it won't help me
22:48:08 <hrumph_> i know what i have to do but if i'm making a monad alread in hackage i'm wasting my time i admit
22:48:09 <Welkin> hm
22:48:40 <Welkin> is there a clean way to map a data constructor over a list of arguments to produce a concrete type?
22:49:20 <Welkin> data Attr a = Attr a a a a a
22:49:43 <Welkin> then construct Attr Int using just Attr and [1..5]
22:53:08 <hrumph_> thang1, the constructor for my datatype looks like this:
22:53:17 <hrumph_> data ProofState s a = ProofState { runProofState :: Maybe s -> (a, Maybe s) }
22:53:27 <thang1> oh okay
22:53:35 <hrumph_> so its a look like state but some maybes thrown in
22:53:51 <thang1> ergo, the extended state monad :p
22:54:29 <thang1> That's actually what I was thinking of when I saw the state tutorial, but not as solidifed as your actual example.
22:54:42 <thang1> So you want to convert it from a data type to a class?
22:54:57 <hrumph_> that's the class and now i'm making it an instance of monad
22:55:02 <hrumph_> that's the data type o mean
22:55:17 <hrumph_> now i'm making it an instance of monad defining the bind operator which is a little tricky but i know what it has to do
22:57:07 <thang1> So you have the constructor, do you have the return functions already done?
22:57:17 <thang1> or are you writing the bind first
22:57:20 <hrumph_> all i have to do now is making the bind function
22:57:27 <hrumph_> the return is identical to the one in state
22:57:39 <thang1> ahh, that's nice
22:57:43 <hrumph_> the bind function is a bit tricky even though i know what it must do
22:57:54 <thang1> bind functions are always terribly tricky for me
22:58:01 <thang1> probably because I've never written one before
22:59:21 * hackagebot data-rev 0.1.0.1 - A typeclass for reversing order of contents.  http://hackage.haskell.org/package/data-rev-0.1.0.1 (jxv)
22:59:22 * hackagebot codecov-haskell 0.3.0 - Codecov.io support for Haskell.  http://hackage.haskell.org/package/codecov-haskell-0.3.0 (killy971)
23:02:27 <thang1> (>>=) :: ProofState a -> (a -> ProofState b) -> ProofState b
23:02:45 <thang1> Which is the vanilla monad bind type, of course, and obviously doesn't help you any
23:04:32 <thang1> Honestly, this looks interesting
23:04:35 <thang1> http://en.wikibooks.org/wiki/Haskell/Understanding_monads
23:04:56 <thang1> The example they provide in there uses maybes in a way that's really similar to your state type, maybe that'll give you something to go off of?
23:19:20 <Welkin> no thoughts?
23:19:21 * hackagebot json-rpc-server 0.1.4.0 - JSON-RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.4.0 (grayjay)
23:29:22 * hackagebot hi 1.0.0.0 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.0.0.0 (DaisukeFujimura)
23:32:37 <hrumph_> shit i'm still struggling
23:32:45 <hrumph_> this is deeper than what i normally think about....
23:44:44 <thang1> You're telling me lol
23:44:53 <thang1> I've been out of my depth here almost the entire damn conversation
