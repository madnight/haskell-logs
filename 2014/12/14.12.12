00:00:03 <liyang> Oh. One of the mailing lists anyway. Probably a good thing I never got around to announcing any of mine.
00:00:58 <prinsen> Fuuzetsu: Already done
00:16:26 <prinsen> Im writing a makefile to build a FFI library. How do I get the include path of GHC (/usr/lib/ghc-7.8.3/include) and names for libraries i need to link against (-lHSrts-ghc7.8.3 -lHSbase-4.7.0.1-ghc7.8.3 -lHSinteger-gmp-0.5.1.0-ghc7.8.3 -lHSghc-prim-0.3.1.0-ghc7.8.3)?
00:16:42 <prinsen> should I write a configure script?
00:31:28 * hackagebot relational-query 0.0.1.6 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.6 (KeiHibino)
00:31:30 * hackagebot extensible-effects 1.9.0.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.9.0.1 (shergill)
00:32:41 <zerkms> guys, RWH is really mindblowing (saying that is the only reason I opened irc today)
00:36:05 <AshyIsMe> zerkms: which part?
00:36:42 <zerkms> AshyIsMe: I'm on chapter 8 in 5 days - so all [1..8] I suppose
00:38:02 <Iceland_jack> zerkms: Glad you enjoy it
00:38:53 <zerkms> from another hand - I'm surprised haskell is that much more complicated compared with clojure
00:39:08 <zerkms> I expected my clojure experience to be somewhat helpful, but it mostly not at all
00:40:23 <favetelinguis> zerkms: i would say that is because in Clojure you are only using a subset of what is possible in haksell, it is not as big a language as haskell
00:41:18 <bartavelle> zerkms, it probably is, I had to do a lot of mental gym to stop with the damn loops already
00:51:02 <quantum-mechanic> is it faster if i use _ in pattern matching ?
00:51:20 <shachaf> Faster than what?
00:51:30 * hackagebot concurrent-extra 0.7.0.9 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.9 (BasVanDijk)
00:51:43 <quantum-mechanic> faster than if i did assign it
00:51:44 <Iceland_jack> quantum-mechanic: no
00:51:51 <Iceland_jack> If it's unused it's the same
00:52:08 <shachaf> You have to press shift on my keyboard layout so it's probably a bit slower.
00:52:13 <Iceland_jack> :)
00:52:21 <quantum-mechanic> lol
00:52:26 <Iceland_jack> Writing a wildcard '_' instead of a pattern variable 'a' is only for readability
00:52:40 <quantum-mechanic> how about memory ?
00:52:42 <Iceland_jack> It tells the reader explicitly that the argument is not used
00:52:48 <Iceland_jack> quantum-mechanic: It's the same
00:52:54 <shachaf> It'll surely compile to the same code.
00:53:11 <quantum-mechanic> so just readability
00:53:22 <quantum-mechanic> well thats not a "just"
00:54:06 <Iceland_jack> Exactly, if you're thinking about the third argument of 'foo':
00:54:06 <Iceland_jack>     foo _ b _ = ...
00:54:06 <Iceland_jack> you don't even have to look at '...' to know exactly how it's used, when '...' could potentially be massive
00:55:19 <Iceland_jack> And if you have definitions like:
00:55:19 <Iceland_jack>     bool _ b True  = ...
00:55:19 <Iceland_jack>     bool a _ False = ...
00:55:19 <Iceland_jack> you see right away which order the arguments are returned
00:55:38 <Iceland_jack> > text (bool undefined "TRUE" True)
00:55:39 <lambdabot>  TRUE
00:56:02 <zerkms> will not actually compiler complain about unused symbol?
00:56:04 <Iceland_jack> *which argument corresponds to each branch
00:56:34 <Iceland_jack> It will if you enable -fwarn-unused-matches
00:56:38 <Iceland_jack> zerkms: ↑
00:57:10 <zerkms> do you guys not use it by default?
00:58:16 <Iceland_jack> no, but for serious stuff people often enable -Wall which implies -fwarn-unused-matches
00:59:04 <zerkms> okay, thanks
00:59:38 <Iceland_jack>     $ ghci -ignore-dot-ghci
00:59:38 <Iceland_jack>     ghci> let f a = ()
00:59:38 <Iceland_jack>     ghci> Prelude> :set -fwarn-unused-matches
00:59:38 <Iceland_jack> Prelude> let g a = ()
00:59:41 <Iceland_jack> <interactive>:4:7: Warning: Defined but not used: ‘a’
00:59:48 <Iceland_jack> oops.. formatting got messed up
01:00:13 <Iceland_jack>     $ ghci -ignore-dot-ghci
01:00:13 <Iceland_jack>     ghci> let f a = ()
01:00:13 <Iceland_jack>     ghci> :set -fwarn-unused-matches
01:00:13 <Iceland_jack>     ghci> let g a = ()
01:00:17 <Iceland_jack>     <interactive>:4:7: Warning: Defined but not used: ‘a’
01:00:20 <Iceland_jack> Just because I like cleaning things up and the channel is quiet...
01:02:51 <trap_exit> sup
01:02:51 <trap_exit> sup
01:03:04 <trap_exit> give me a list of the top 5 papers to read on implementing a prolog-like DSL within haskell
01:03:05 <trap_exit> sup
01:03:05 <trap_exit> ^^
01:03:50 <sivteck> nice question
01:08:39 <trap_exit> yes
01:08:43 <trap_exit> let's get a nice answer now
01:08:45 <trap_exit> perferably 5 nice answers
01:21:06 <jkarni1> http://okmij.org/ftp/papers/LogicT.pdf ?
01:41:12 <agocorona> hughs had a example implementation of prolog
01:41:47 <agocorona> It is quite nice and clean
01:46:03 <trap_exit> agocorona: where is it?
01:46:04 <phaskell> No symbol 'it' found anywhere.
01:46:25 <mauke> ABCT2XY
01:46:31 <mauke> ABC T2 XY
01:46:32 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
01:46:41 --- mode: ChanServ set +o mauke
01:46:41 --- mode: mauke set +b $a:phaskell
01:46:45 --- kick: phaskell was kicked by mauke (phaskell)
01:46:58 <d-snp> :P
01:48:45 --- mode: mauke set -o mauke
01:49:28 <mmmm> If people use the bounds bumping feature in cabal, does that break nix packages?
01:51:29 <favetelinguis> what is meant with orphan instance in the context of emacs haskell mode warning for an instance of Arbitrary
01:51:32 * hackagebot rncryptor 0.0.1.0 - Haskell implementation of the RNCryptor file format  http://hackage.haskell.org/package/rncryptor-0.0.1.0 (AlfredoDiNapoli)
01:51:55 <mmmm> favetelinguis: It means you have defined an instance in a seperate module to where you defined your data type
01:53:31 <favetelinguis> mmmm: ok is that bad practice?
01:54:43 <mmmm> yes
01:55:18 <mmmm> because instances are always imported when you import a module
01:56:47 <agocorona> trap_exit: hugs hughs?  is an interpreter that now is discontinued
01:58:22 <agocorona> https://www.haskell.org/hugs/pages/downloading.htm
01:58:38 <favetelinguis> mmmm: makes using QC cinda ugly then since you want the testlogic separate from the proect code, then i would need to import CQ and my test code into the module where i declare the datatype in the case of Arbitrary
02:01:50 <agocorona> trap_exit: the source: https://www.haskell.org/hugs/downloads/2006-09/hugs98-plus-Sep2006.tar.gz    in demos/prolog
02:06:33 * hackagebot activitystreams-aeson 0.2.0.0 - An interface to the ActivityStreams specification  http://hackage.haskell.org/package/activitystreams-aeson-0.2.0.0 (gdritter)
02:07:11 <Fuuzetsu> favetelinguis: you can use a newtype to make the warning go away
02:18:47 <favetelinguis> trying to send a click event with haste but noting is happening, is there anything obv wrong with my code? http://lpaste.net/116300
02:21:33 * hackagebot activitystreams-aeson 0.2.0.1 - An interface to the ActivityStreams specification  http://hackage.haskell.org/package/activitystreams-aeson-0.2.0.1 (gdritter)
02:24:22 <agocorona> favetelinguis: what is diff?
02:25:22 <favetelinguis> agocorona: a button
02:26:10 <agocorona> but how is it defined?
02:27:05 <favetelinguis> it is created using this function http://lpaste.net/116300
02:28:23 <agocorona> there isn´t any errors in the console?
02:29:12 <trap_exit_> is there any haskell program which can synthesize text in a rap way?
02:29:26 <trap_exit_> so osx has: say "hello world" ==> it says hello world
02:29:29 <trap_exit_> but i want to synthesize rap
02:30:39 <favetelinguis> agocorona: i dont know what happend but now it is working, odd
02:30:43 <favetelinguis> thanks anyways
02:48:23 <wei2912> foldl f a bs = foldr (\b -> \g -> (\a -> g (f a b))) id bs a
02:48:29 <wei2912> how does this piece of code even work? :P
02:50:29 <Fuuzetsu> exactly the way you just typed out, no magic
02:50:52 <Iceland_jack> wei2912: Try a simple example 'foldl (+) 0 [1..5]' and substituting
02:51:19 <Iceland_jack> wei2912: Recall the type signature of 'foldr'
02:51:20 <Iceland_jack> @ty foldr
02:51:22 <lambdabot> (a -> b -> b) -> b -> [a] -> b
02:51:27 <Iceland_jack> and notice that 'b' can be a function!
02:51:35 <wei2912> ohh
02:52:22 <wei2912> foldr (\b -> \g -> (\a -> g (a + b))) id [1, 2, 3, 4, 5] 0
02:54:00 <Iceland_jack> wei2912: then keep in mind that you "foldr f e" replaces every (:) with f, and every [] with e
02:54:38 <Iceland_jack> So:
02:54:39 <Iceland_jack>     foldr (\b g a -> g (a + b)) id [1,2,3,4,5]
02:54:39 <Iceland_jack> will replace every (:) in [1,2,3,4,5] with (\b g a -> g (a + b)) and every [] with id
02:54:51 <wei2912> i see
02:55:58 <Iceland_jack> wei2912: Does this make this more clear or less clear?
02:55:59 <Iceland_jack> > let (b *** g) a = g (a + b) in (1 *** (2 *** (3 *** (4 *** id)))) 0
02:56:01 <lambdabot>  10
02:56:55 <wei2912> let me try to reduce it
02:57:28 <Iceland_jack> Okay, (***) is equal to (\b -> \g -> (\a -> g (a + b)))
02:57:52 <Iceland_jack>     (***) = (\b -> \g -> (\a -> g (a + b)))
02:57:52 <Iceland_jack> same as:
02:57:52 <Iceland_jack>     (b *** g) a = g (a + b)
02:58:08 <wei2912> yeh
02:58:38 <Iceland_jack> and you can see how it pushes the 'left' b to the right of the addition
02:59:49 <wei2912> i think i got that
03:00:05 <Iceland_jack> Okay
03:00:35 <Iceland_jack> Then what you posted basically turns into:
03:00:35 <Iceland_jack>     (1***2***3***4***id) 0
03:00:35 <Iceland_jack> (assuming that (***) is right-associative)
03:00:38 <wei2912> so, foldr isn't being passed 4 parameters, but 3?
03:01:32 <Iceland_jack> It depends on what you call "foldr", maybe this example will clear things up: How many arguments does 'id' take?
03:01:34 <Iceland_jack> > id 'a'
03:01:35 <lambdabot>  'a'
03:01:41 <Iceland_jack> Just one right?
03:01:44 <wei2912> yep
03:01:47 <Iceland_jack> What about:
03:01:47 <Iceland_jack> > id id 'a'
03:01:49 <lambdabot>  'a'
03:02:07 <wei2912> id takes in id?
03:02:08 <Iceland_jack> Now 'id' appears to accept more than one argument!
03:02:09 <Iceland_jack> Yes
03:02:16 <agocorona> favetelinguis: good
03:02:21 <wei2912> i see
03:02:41 <Iceland_jack> But nothing has changed about 'id', both these types are valid:
03:02:41 <Iceland_jack>     id :: a -> a
03:02:41 <Iceland_jack>     id :: (b -> b) -> (b -> b)
03:02:48 <Iceland_jack> See my point?
03:03:14 <wei2912> i see.
03:03:26 <Iceland_jack> In the same way 'foldr' has the following type ("3 arguments"):
03:03:28 <Iceland_jack> @ty foldr
03:03:29 <lambdabot> (a -> b -> b) -> b -> [a] -> b
03:03:42 <Iceland_jack> But it also has this type ("4 arguments"):
03:03:42 <Iceland_jack> :t foldr :: (a -> (c -> c) -> (c -> c)) -> (c -> c) -> [a] -> (c -> c)
03:03:43 <lambdabot> (a -> (c -> c) -> c -> c) -> (c -> c) -> [a] -> c -> c
03:03:57 <wei2912> ahh.
03:04:09 <wei2912> thanks for your explanation, Iceland_jack :)
03:04:15 <Iceland_jack> No problem, hope it made sense
03:04:31 <wei2912> (also, thanks for your comprehensive review on reddit :))
03:04:41 <Iceland_jack> Oh right, no problem
03:05:04 <Iceland_jack> I realized that the initial draft was too focused on how *I* would write a review
03:05:13 <Iceland_jack> so I cut out a lot of the more personal comments
03:09:57 <Iceland_jack>                foldll (+) 0 [1..5]
03:09:57 <Iceland_jack> ={rewrite}     foldr (\b g a -> g (a + b)) id [1..4]       0
03:09:57 <Iceland_jack> ={list syntax} foldr (\b g a -> g (a + b)) id (1:2:3:4:[]) 0
03:09:57 <Iceland_jack> ={apply foldr} (1*2*3*4*id) 0 (where: (b*g)a = g (a + b))
03:10:38 <Iceland_jack> If all those steps make sense then it's a nice step reducing:
03:10:38 <Iceland_jack>     (1*(2*(3*(4*id)))) 0
03:13:30 <Iceland_jack> wei2912: Once you've rolled that up you may be interested in "implementing dropWhile using foldr" which is included in https://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
03:13:46 <wei2912> Iceland_jack: thanks :)
03:18:46 <wei2912> Iceland_jack: there're 4 weird implementations of foldl which i plan to try and prove
03:18:55 <wei2912> so it might be a while before i look at that pdf :)
03:33:53 <zenguine`> I've just finished reading "the essence of the iterator pattern" pretty thoroughly, and tohught it was really cool.
03:34:03 <zenguine`> does anyone have a recommendation for a follow up paper in a similar vein?
03:48:29 <Philonous> Should I be able to splice declarations inside a class declaration?
03:49:19 <Philonous> I can't seem to find any information about it (also nothing that seems to precude it), but ghc panics when I try to splice an associated data type declaration
03:51:42 <stillwater> Hi everyone
03:51:59 <stillwater> I am going through school of haskell tutorial
03:52:08 <stillwater> and I am not able to get my head around something
03:54:40 <stillwater> anyone there?
03:54:54 <Philonous> stillwater, Are you waiting for permission to ask your question? That's generally unnecessary ;)
03:55:09 <stillwater> oh hey hi
03:55:10 <stillwater> well
03:55:27 <stillwater> data FailableDouble = Failure                      | OK Double   deriving Show
03:55:47 <stillwater> I understand that failabledouble is a type
03:56:15 <stillwater> and the tutorial says the only values for the type failuredouble are "Failure" and "OK Double"
03:56:19 <stillwater> what does this exactly mean
03:56:20 <stillwater> ?
03:56:33 <vanila> Failure and OK are the constructors
03:56:43 <vanila> the valuse are Failure and OK 1.2, OK 5.62243, .. etc.
03:56:43 <mauke> what it says :-)
03:57:10 <mauke> but seriously, I can probably give a more useful answer when I understand better what's unclear
03:57:29 <mauke> are you familiar with 'data Bool = False | True'?
03:57:44 <stillwater> mauke.that cleared it up!
03:57:53 <stillwater> with the bool example
03:57:55 <stillwater> I get it
03:57:58 <stillwater> wow
03:58:15 <mauke> doge.jpg
03:58:37 <stillwater> thanks
03:58:45 <hpc> http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html -- better Bool :D
03:58:46 <mauke> you're welcome :-)
03:59:03 * mauke thwaps hpc 
04:01:19 <osa1> I'd give everything to be able to set breakpoints and inspect variables using GDB or something similar :F (I mean Haskell source-level variables/names, not RTS stuff)
04:01:37 <mauke> like ghci?
04:02:09 <osa1> hm can I do that in ghci?
04:02:21 <mauke> yeah, IIRC it has a few debugger commands
04:03:49 <osa1> well that doesn't work
04:04:01 <osa1> "cannot set breakpoint: blah blah is not interpreted"
04:04:07 <osa1> I guess I need to cabal clean, right?
04:04:29 <mauke> yeah, probably
04:04:55 <osa1> I'm still getting same error
04:05:07 <mauke> :-(
04:05:14 <osa1> to be clear: I loading executable to repl but this function is in lib part
04:05:19 <osa1> I run cabal clean though
04:05:26 <osa1> so lib part should also be interpreted
04:05:40 <mauke> is the executable interpreted?
04:05:50 <osa1> it should be, I just cleaned everything
04:06:41 <pnowak> Is is possible to specify the role of a type variable? something like "forall (f :: * -> *). Representational f => ..."
04:07:05 <osa1> lol, `isn't` is a valid Haskell identifier?
04:07:20 <mauke> osa1: yes!
04:07:27 <osa1> looks fun
04:07:56 <mauke> > let don't = const (return ()) in don't (print 42)
04:07:58 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
04:07:58 <lambdabot>    arising from a use of ‘M268316767229690096819759.show_M2683167672296900968...
04:07:58 <lambdabot>  The type variable ‘m0’ is ambiguous
04:08:03 <mauke> aww
04:08:10 <mauke> > let don't = const (return ()) in don't (print 42) :: [()
04:08:12 <lambdabot>  <hint>:1:57:
04:08:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:08:13 <mauke> > let don't = const (return ()) in don't (print 42) :: [()]
04:08:15 <lambdabot>  [()]
04:36:39 * hackagebot h-gpgme 0.2.0.0 -   http://hackage.haskell.org/package/h-gpgme-0.2.0.0 (rethab)
04:36:41 * hackagebot Spock-worker 0.2.1.2 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.2.1.2 (AlexanderThiemann)
04:52:29 <josteink> in FP terms, what would you call a operation with the following signature?
04:52:32 <josteink> List a -> (a-> List a) -> List a
04:52:40 <josteink> basically take a list, a transformation which acts on each item in the list and returning a new list, and combine that into a new list
04:52:45 <exio4> bind
04:53:20 <josteink> really? to me that sounds like monadish stuff, and to me this seems like basic list operations
04:53:26 <wei2912> a list is a monad
04:53:28 <josteink> maybe Im not looking at it generally enough :)
04:53:29 <exio4> :t (=<<)
04:53:30 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:53:38 <exio4> er
04:53:38 <Chath> Hah that's cool ,exact signature of bind
04:53:43 <exio4> :t (>>=)
04:53:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:53:57 <exio4> :t (>>=)  :: [a] -> (a -> [b]) → [b]
04:53:58 <lambdabot> [a] -> (a -> [b]) -> [b]
04:55:30 <josteink> exio4: nice. >>= is not a very idiomatic C# name though :)
04:56:03 <exio4> josteink, (>>=) is (flipped) concatMap for lists, I don't know the C# name though
04:56:24 <josteink> exio4: yeah. someone in #lisp just said concatmap too
04:56:42 <josteink> Ill go for that. beats my somewhat imprecise "Collate" which was the best I had so far :)
04:56:57 <wei2912> just admit that it's a monad and call it "bind" :)
04:57:21 <josteink> where I work, I got yelled at for using git
04:57:33 <josteink> trying to squeeze monads into the code will hardly make me any more popular :P
04:57:46 <Chath> ... I'm sorry for your loss
04:58:04 <Chath> josteink: It's called flatMap in other langauges
04:58:23 <Chath> I'm not 100% but I think C# has something like that operation
04:59:31 <Chath> Maybe I'm wrong actually, I thought I saw LINQ doing something like bind
04:59:31 <josteink> Chath: it has a reduce, which you can use to -implement- concatmap
04:59:34 <josteink> but thats hardly the same
04:59:50 <Chath> Yeah it's not... hmm
05:00:20 <josteink> might have been F#? F# supports "computational expressions" and can do more funky stuff
05:01:10 <Chath> josteink: I'm thinking of SelectMany I think
05:01:36 <josteink> oh right
05:01:41 <josteink> right you are!
05:02:39 <Chath> I think that kind of works for what you need, or does it?
05:02:48 <josteink> yeah
05:03:02 <josteink> saves me from adding another method to the EnumerableExtensions.cs file
05:03:05 <Chath> Reading all those articles for langauges I never use finally paid off, time to call my mom
05:03:05 <josteink> and that makes me happy
05:10:35 <vanila> I guess "computational expressions"is the same as monads, but the operators are backwards and the names are "easier"
05:10:48 <vanila> is that right? do people find it easier to learn and program with because of these things?
05:11:14 <ij> With monads?
05:12:33 <Chath> A lot of people are weird about the word Monad, I've seen discussion on Rust where they want the functionality but to avoid the name
05:12:59 <wei2912> Chath: heh
05:13:07 <pharpend> hi wei2912
05:13:14 <wei2912> Chath: probably because there're way too many monad tutorials? :)
05:13:18 <wei2912> hi ph
05:13:20 <wei2912> hi pharpend
05:13:47 <pharpend> did you see my latest project?
05:14:04 <wei2912> pharpend: no
05:14:09 <Chath> I couldn't really understand the reasoning, seemed political
05:14:10 <pharpend> Ive been on github for 3 years, and my project I started 4 hours ago containing absolutely nothing is now my most popular repo
05:14:21 <pharpend> https://pharpend.github.io/lysa/
05:14:32 * pharpend goes to evaluate his life
05:15:30 <wei2912> "The ancient Greeks were too dumb to understand what eight is, so every time someone brought it up, they would say "uh" immediately afterwords." O_O
05:15:56 <wei2912> "...is largely the reason for their current financial crisis." lmao
05:18:05 <wei2912> i need a horrible sounding name for an irc bot in haskell
05:18:06 <pharpend> So, anyway, the reason I came over here, I'm having trouble getting Haskell installed
05:18:09 <wei2912> preferably a horrible pun
05:18:19 <pharpend> I have desbot reserved
05:18:22 <pharpend> for #learnmath
05:18:25 <pharpend> I need to write a bot
05:18:28 <Iceland_jack> wei2912: BOTtom
05:18:37 <wei2912> Iceland_jack: holy shit
05:18:39 <pharpend> wei2912: powerBOTtom
05:18:40 <Iceland_jack>   [x] Horrible
05:18:40 <Iceland_jack>   [x] Pun
05:18:54 <wei2912> god
05:19:00 <pharpend> Iceland_jack: mine also adds vulgarity, which is arguably more important
05:19:14 <wei2912> ...
05:19:26 <Iceland_jack> If you're thinking of the specific bottom I'm thinking of it's plenty vulgar
05:19:37 <wei2912> okay
05:19:48 <wei2912> note to self: do not ask for a horrible pun in programming channels
05:19:52 <pharpend> I love that Haskell article about bottoms in Haskell
05:20:01 <pharpend> bottoms are things like undefined and error
05:20:06 <pharpend> they exist for every type
05:20:12 <Iceland_jack> Every lifted type
05:20:23 <Iceland_jack> No bottom for Int# or Float#
05:20:43 <wei2912> this is just
05:20:53 <wei2912> i can't describe the atrocity of that pun
05:20:57 <BoR0> :D
05:21:39 <wei2912> Iceland_jack: thanks for that pun, starting the project now
05:21:48 <wei2912> pharpend: perhaps we could jointly develop a bot :0
05:21:48 <pharpend> Now, personally, I wouldn't make my bot a joke about gay sex, but I can understand why one would want to do that.
05:21:58 <pharpend> wei2912: I'm writing one in idris
05:22:02 <pharpend> wei2912: or want to
05:22:03 <wei2912> pharpend: i see
05:22:12 <pharpend> wei2912: idris = haskell + some sexy stuff
05:22:18 <pharpend> wei2912: - speed
05:22:28 <Iceland_jack> wei2912: No problem, if you want to use pattern synonyms for bad things you can use this as well:
05:22:28 <Iceland_jack> abuse
05:22:32 <Iceland_jack> oops
05:22:33 <Chath> And weird syntax choices, as much as I love it
05:22:33 <Iceland_jack> @google irc pattern synonyms
05:22:33 <lambdabot> https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
05:22:50 <Chath> I can't handle the total keyword above a function def
05:22:50 <pharpend> Chath: tbf, Haskell has some weird syntax, too
05:22:53 <wei2912> what does idris have over haskell?
05:23:04 <wei2912> Iceland_jack: thanks
05:23:08 <pharpend> wei2912: dependent types. Basically strong typing taken to the absolute extreme
05:23:09 <Chath> Oh yeah everything does, I think total just creeps me out so much
05:23:12 <Iceland_jack> Idris is a research language
05:23:20 <pharpend> that's not really true
05:23:28 <Iceland_jack> ?
05:23:29 <pharpend> no more than haskell
05:23:36 <Iceland_jack> Well, yes it is
05:23:57 <Iceland_jack> If you ask on #idris whether you should use Idris in production they will generally say "no that is not our intention"
05:24:05 <pharpend> hmm
05:24:15 <Iceland_jack> While Haskell has an Industrial Haskell Group
05:24:25 <sivteck> and LiquidHaskell!
05:24:30 <vanila> pharpend, idris is a research language
05:24:33 <wei2912> pattern synonyms look good
05:24:50 <vanila> they are investigating making dependently typed programming practical
05:24:56 <Iceland_jack> Being a research language is not a bad thing
05:25:10 <pharpend> well the term gives off the impression that it's not useful
05:25:11 <vanila> its a good thing because they will make deptypes more useful!
05:25:12 <pharpend> when it can be
05:25:27 <Iceland_jack> pharpend: Well it is less useful while it's being developed
05:26:17 <Chath> Idris is a general purpose research language, best of both worlds
05:26:58 <Iceland_jack> pharpend: An example, they haven't added Rational numbers to the standard library
05:27:31 <Iceland_jack> because to properly support rational numbers something like quotient types would be real nice
05:27:42 <pharpend> Anyway, back on-topic, I'm having this error when I try to cabal install cabal-install -> http://www.idris-lang.org/
05:28:21 <wei2912> pharpend: idris is an error? D:
05:28:38 <pharpend> ack
05:28:42 <pharpend> http://ix.io/1Qe
05:28:45 <pharpend> there we go
05:28:45 <wei2912> syn
05:28:50 * pharpend curses at xclip
05:30:38 <wei2912> Iceland_jack: how'd you like to be linked in the credits file?
05:31:03 <pharpend> wei2912: I'm offended that you aren't choosing powerBOTtom as your nick
05:31:16 <wei2912> pharpend: haha
05:32:42 <Iceland_jack> wei2912: For coming up with BOTtom? I'd be delighted
05:32:59 <Iceland_jack> You can call it powerBOTtom as well, or BOTtom++
05:33:12 <wei2912> will reserve both for a fork
05:33:25 <wei2912> :P
05:33:35 <Iceland_jack> “In case of fork break glass, use puns.”
05:33:37 <pharpend> also
05:33:45 <pharpend> BOTtomXXX
05:33:55 <BoR0> that's way too explicit :)
05:35:34 <wei2912> lol
05:35:50 <wei2912> pharpend: Iceland_jack i'd like to keep it symbol though
05:35:55 <wei2912> *ducks*
05:36:40 <Iceland_jack> I'll have to come to terms with that
05:36:41 * hackagebot network-fancy 0.2.2 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.2.2 (TaruKarttunen)
05:39:56 <wei2912> Iceland_jack: should i link to your github?
05:40:04 <Iceland_jack> Nah that's fine
05:40:14 <wei2912> what'd be the preferred way?
05:41:28 <Iceland_jack> Citing the nick would be just fine thanks
05:41:34 <Iceland_jack> since it's a minor contribution
05:41:45 <wei2912> okay
05:51:42 * hackagebot takusen-oracle 0.9.2 - Database library with left-fold interface for Oracle.  http://hackage.haskell.org/package/takusen-oracle-0.9.2 (PavelRyzhov)
05:53:51 <wei2912> what alternatives are there to Parsec?
05:54:17 <pantsman> wei2912: depends on your use case
05:56:05 <wei2912> pantsman: i'm just looking to parse IRC protocol strings
05:56:13 <wei2912> which should be quite simple
05:56:13 <Iceland_jack> wei2912: there are libraries for that
05:56:44 <Iceland_jack> @hackage irc
05:56:44 <lambdabot> http://hackage.haskell.org/package/irc
05:57:11 <wei2912> i see, thanks
05:58:29 <Iceland_jack> wei2912: Off to lunch :) may BOTtom be a smash
05:58:50 <wei2912> Iceland_jack: haha
05:59:08 <wei2912> thanks :)
06:02:23 <pharpend> wei2912: what will your bot do?
06:03:17 <wei2912> pharpend: be dumb
06:03:33 <pharpend> see I don't see how that's out of the ordinary
06:03:38 <wei2912> haha
06:03:45 <wei2912> it's a learning experiment
06:03:55 <DblZ> it's all in the quotes...
06:04:38 <wei2912> i plan to make it such that modules can be written in any language, as long as you can execute them
06:09:38 <wei2912> strange, following https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot gives me no output
06:10:47 <sivteck> wei2912, why?
06:11:00 <wei2912> sivteck: no idea.
06:11:03 <sivteck> Error/Code pls
06:11:10 <wei2912> no error at all
06:11:20 <wei2912> it just hangs there
06:11:54 <sivteck> ok i will try to imagine without your code
06:11:58 <sivteck> Is your computer on?
06:12:06 <wei2912> "{
06:12:08 <wei2912> :P*
06:12:09 <wei2912> yes
06:12:20 <wei2912> sivteck: the code is in the tutorial btw
06:12:34 <wei2912> chapter 1
06:15:11 <sivteck> wei2912, http://fpaste.org/159112/83934651/raw/ <- Output!
06:15:28 <wei2912> sivteck: strange....
06:16:08 <wei2912> i copied the code exactly but it doesn't give me any output
06:20:02 <wei2912> interestingly, i haven't been able to run any other irc bots too
06:21:43 * hackagebot skein 1.0.9.2 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.9.2 (FelipeLessa)
06:23:15 <wei2912> if it may help, i'm using zsh
06:23:52 <Clint> you don't want to write an irc bot in zsh
06:24:51 <wei2912> lol
06:24:56 <wei2912> you're right about that
06:30:46 <purelazy> when compiling, I get a "parse error on input".  Is there a way to get a more elaborate explaination?
06:31:22 <wei2912> purelazy: post your code here
06:32:15 <geekosaur> @paste
06:32:15 <lambdabot> Haskell pastebin: http://lpaste.net/
06:32:43 <geekosaur> unfortunately, often times "parse error" is less than informative from ghc :/ often it means indentation problems though
06:33:44 <purelazy> http://lpaste.net/116306
06:34:56 <wei2912> purelazy: wordFile = ...
06:35:07 <wei2912> line 6
06:35:08 <purelazy> Yeah - I imagine it is. I would have expected more from a 24 year old language
06:35:28 <sivteck> it is old and cranky
06:35:41 <wei2912> you must expect a lot from COBOL :)
06:35:59 <purelazy> "parse error on input - probably indentation"  would have been nice
06:36:17 <purelazy> not hard to implement that fix
06:36:23 <vanila> purelazy, there's a project Simon Peyton Jones is doing to try to improve error messages, I think it will be able to do what you said
06:37:19 <purelazy> I expect COBOL has type-level programming way ahead of the rest by now
06:38:36 <vanila> :/
06:38:54 <vanila> this channel got so bad
06:39:09 <int-e> purelazy: u.hs:6:19: parse error on input ‘=’   seems to be about right. The = should be a <- , but there could be an arbitrary identifier in the same place, or an infix operator, without causing a syntax error, so it's hard for the compiler to make a correct suggestion.
06:39:32 <wei2912> that's actually quite a good error
06:39:56 <wei2912> it's better than telling you how "let" was missing or you wanted "<-" or some automagic suggestions
06:43:58 <dfeuer> vanila, what's bad about this channel?
06:44:22 <purelazy> I changed the = to <- and get hangman.hs:1:8: parse error
06:45:08 <int-e> purelazy: module names have to start with a capital letter
06:46:48 <purelazy> int-e: Thanks.
06:47:00 <purelazy> I should have remembered that
06:50:45 <purelazy> I also got Not in scope: `wordList'
06:51:09 <purelazy> So stuff in do is not in scope for the where?
06:51:54 <JonReed> Hi! What would be the way to read a named pipe with blocking in Haskell.  E.g. in linux if you do "mkfifo /tmp/hask" and then "cat /tmp/hask". The "cat" will block until you "echo 'something' > /tmp/hask". However, if you do readFile "tmp/hask" it will never block. It will just return "" immediately. What I could be doing wrong?
06:52:42 <JonReed> I want "readFile "/tmp/hask"  " to block intil  something gets written to a file
06:53:57 <amaru> JonReed: Maybe check System.IO?
06:56:44 * hackagebot stm-containers 0.2.5 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.5 (NikitaVolkov)
06:56:56 <int-e> purelazy: right.  in  foo x y z = <expression> where <bindings>, the bindings in the where block can only refer to names defined outside of the expression. (The 'where' keyword is part of the declaration syntax, not of the expression syntax)
06:59:13 <purelazy> int-e: Thanks for the confirmation. I'll try and sort it out
06:59:24 <int-e> @undo do a; let y = 42; x <- b; c x y -- whereas 'do' is part of the expression syntax
06:59:24 <lambdabot> <unknown>.hs: 1: 21:Parse error: <-
06:59:28 <int-e> ah
06:59:35 <int-e> @undo do a; let { y = 42 }; x <- b; c x y -- whereas 'do' is part of the expression syntax
06:59:35 <lambdabot> a >> let { y = 42} in b >>= \ x -> c x y
07:00:30 <int-e> I find that 'do' is less confusing with indentation than with explicit blocks... but lambdabot can't handle newlines.
07:06:42 <purelazy> int-e what is @undo ?
07:08:12 <int-e> @help undo
07:08:13 <lambdabot> undo <expr>
07:08:13 <lambdabot> Translate do notation to Monad operators.
07:08:16 <int-e> do blocks are implemented in terms of the infix operators >> and >>=; lambdabot's @undo takes a do block and shows the corresponding expression.
07:08:55 <int-e> You don't have to worry about it; the point is that do blocks are really just expressions.
07:13:24 <Philonous> Ah, strange, ghc crashes when I try to splice declarations in a class instance context. Is that disallowed?
07:14:15 <mauke> dunno but any crash is a ghc bug
07:14:32 <Philonous> I guess I'll file a report then
07:20:18 <bernalex> http://lpaste.net/2676477856267108352 can someone annotate this with a less staircase-y version? I don't see a nice way of doing it
07:20:52 <bergmark> bernalex: use MaybeT!
07:21:12 <bernalex> bergmark: is this one of those deduplication efforts where you end up with more code than you started out with? :-P
07:21:23 <bernalex> bergmark: I was considering it, but couldn't immediately see a neat way of doing that either
07:25:00 <Peaker> it seems ghc --make -fno-code actually does type-check everything really fast. If you try adding -fno-code to cabal, it fails to "cabal configure" though
07:25:38 <Peaker> I gotta have -fno-code working in my fly-check
07:25:47 <Denommus> hm
07:25:55 <bergmark> bernalex: i'm pretty sure you'll end up with less and more readable code
07:26:10 <bergmark> > runMaybeT $ do { liftIO (print 1); x <- return 2; return x }
07:26:11 <lambdabot>  Not in scope: ‘runMaybeT’
07:27:10 <Denommus> I wonder if there's a library for Haste in the lines of AngularJS's ui-router, but that controls the current state with FRP
07:27:28 <chpatrick> bernalex: can't you just do u <- MaybeT $ get t
07:28:13 <bernalex> chpatrick: hm. I'll try it out.
07:31:06 <chpatrick> bernalex: http://lpaste.net/6722263098352205824
07:31:12 <chpatrick> I didn't compile it, just a sketch
07:31:18 <bananagram> :t lookup
07:31:20 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
07:31:40 <bernalex> chpatrick: yeah I'm in the process of trying it out -- thanks
07:33:22 <chpatrick> p <- return $ timespanParent v should be p <- MaybeT $ return $ timespanParent v
07:34:06 <bernalex> chpatrick: I was just about to say, heh
07:34:27 <bernalex> chpatrick: but uh you're not using runMaybeT anywehre here
07:34:47 <chpatrick> chpatrick: yeah, before the do
07:35:19 <chpatrick> *bernalex: :)
07:35:19 <bernalex> chpatrick: oh durr
07:35:48 <bernalex> chpatrick: thanks! should work
07:35:52 <chpatrick> np
07:56:46 * hackagebot tdoc 0.4.5 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.5 (NicolasPouillard)
07:58:37 <nielsbusch> I'm trying to install SourceGraph but it fails because Pandoc failed to install. I have the latest Haskell platform, on OS X. Should I install Pandoc from source?
08:07:20 <magicman> @type MaybeT . return
08:07:21 <lambdabot> Not in scope: data constructor ‘MaybeT’
08:16:48 <ReinH> nielsbusch: Are you in a cabal sandbox?
08:17:01 <nielsbusch> I guess so.
08:17:19 <ReinH> nielsbusch: How do you know?
08:17:23 <nielsbusch> I don't really
08:17:36 <nielsbusch> How would I find out. Sorry, complete noob
08:17:46 <ReinH> nielsbusch: Ah. No worries.
08:18:02 <ReinH> I've found Pandoc to be pretty difficult to install due to its dependencies.
08:18:09 <nielsbusch> k
08:18:15 <ReinH> I would recommend trying in a cabal sandbox. Here's an introduction to sandboxes: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
08:18:21 <nielsbusch> Just trying to get syntaxhighlighting working in eclipsefp.
08:18:44 <ReinH> nielsbusch: What version of cabal are you using? cabal --version
08:18:44 <nielsbusch> Ok, thx. Will take a look.
08:18:59 <nielsbusch> 1.20.0.3
08:19:06 <ReinH> Good.
08:19:16 <ReinH> Then please try with a sandbox :)
08:19:22 <nielsbusch> k, will do.
08:19:25 <nielsbusch> thanks a lot.
08:19:31 <ReinH> Sure thing. Good luck.
08:33:39 <dfeuer> Ooooh, I just had an idea.
08:34:11 <purelazy> what
08:34:19 <dfeuer> I don't know if it was a good idea or not.
08:34:34 <purelazy> who cares
08:34:43 <purelazy> ideas are good anyway
08:34:50 <dfeuer> purelazy, I'm trying to make the <*> operation in Data.Sequence faster.
08:36:10 <dfeuer> purelazy: With some help from others (especially Carter Schonwald and Joachim Breitner) I've gotten the asymptotic bounds right when the result is used incrementally, but unfortunately the constant factors are still worse than the old monolithic implementation if the whole result is used.
08:36:20 <dfeuer> It's driving me a bit batty.
08:36:33 <carter> the good kind of batty though
08:36:50 <dfeuer> Ehh.
08:37:12 <purelazy> dfeuer I can't help. Sorry. Too noob
08:37:20 <dfeuer> carter, I've made some progress on the constant factors. They're just still not where they need to be.
08:37:47 <dfeuer> Unless the maintainers are willing to take the constant factor hit to get the asymptotics right.
08:37:52 <dfeuer> Which seems unlikely.
08:40:01 <dfeuer> carter, it is fun, though, to type  ((,) <$> replicate (10^7) 1 <*> replicate (10^7) 2) `index` (10^14 `div` 2)  and get a result immediately.
08:40:47 <carter> that is pretty snazzy
08:40:48 <carter> good job
08:40:57 <carter> it does suggest that it should be available though
08:41:29 <dfeuer> carter, yeah, I think so. Just needs a little more magic somewhere, hopefully.
08:42:38 <carter> unless its one of those darn fundamental tradeoffs
08:42:57 <dfeuer> Actually, it's possible that the constant factors are good enough to be accepted. It's up to Milan Straka ultimately, I think.
08:43:42 <dfeuer> Mine takes maybe 1/3 longer once the sequences get reasonably long. It's rather worse for a 20x20 though.
08:44:15 <dfeuer> Oh. Ohhhh. I had an idea.
08:44:26 <dfeuer> It might even be a good one, but I'm not sure.
08:44:46 <dfeuer> carter, what if I represent the second sequence as its sequence of tails?
08:44:50 <dfeuer> Will that help?
08:45:08 <dfeuer> tails is super-optimized by Wasserman.
08:45:13 <carter> idk
08:45:34 <dfeuer> I'm a-gonna look at that.
08:45:44 <carter> cool
08:47:35 <Denommus> seriously, I'm in doubt regarding yesod vs happstack. Which one would you guys use?
08:47:49 <carter> Denommus: snap?
08:48:01 <carter> Denommus: whats your dillemam
08:48:06 <carter> you can pick and choose the pices
08:48:09 <carter> *pieces
08:48:17 <carter> tehres a lot of choices these days
08:48:28 <Denommus> yesod seems rails-like in terms of usability, but happstack seems more powerful and extensible
08:48:51 <carter> Denommus: ask on each projects irc channel for their thoughts
08:48:58 <carter> Denommus: honestly, pick one, then if youre stuck, switch
08:49:09 <carter> my main gripe with yesod is that i'd then have to use sstackage
08:49:47 <Denommus> carter: is there a channel for happstack? I didn't find it
08:50:03 <carter> http://happstack.com/page/view-page-slug/4/community
08:50:07 <carter> says #happs
08:50:34 <Denommus> I'm using stackage anyway, because I tried to install ghc-mod and ghcjs at the same time
08:50:34 <Denommus> I ended up failing, nevertheless
08:50:36 <Denommus> I think I need to restart Emacs
08:50:56 <carter> Denommus: oh, the issue was transformers probably
08:51:07 <carter> Denommus: "rm ~/.ghc ; cabal install mtl-2.1.3.1 ; "
08:51:35 <ReinH> carter: You don't *have* to use Stackage.  Your other option is to be totally unable to install Yesod...
08:51:44 <carter> exactly
08:51:46 <carter> :)
08:51:48 <carter> shhhhh
08:52:03 <ReinH> I'm convinced Stackage exists to solve the yesod install problem...
08:52:11 <ReinH> Why else would you go to all that trouble?
08:52:15 <carter> fact
08:52:16 <carter> :)
08:52:18 <ReinH> :)
08:53:22 <Denommus> carter: no, it wasn't exactly an installation problem (I could get around it), but if I use ghcjs's cabal, ghc-mod breaks because of non-ASCII characters somehow
08:53:51 <michi7x7> you could go with _very_ old linux distribution packages
08:56:49 <Denommus> michi7x7: are they old in AUR?
08:57:08 <Denommus> whoa, 3.1.3, too old
09:00:57 <michi7x7> gentoo has 1.2.4
09:02:26 <michi7x7> hmm, the haskell overlay has 1.4.1
09:15:08 <mmachenry> Does anyone know if there is an "am I the root user" function? Would getRealUserID == 0  be reliable?
09:15:40 <Denommus> :t (+)
09:15:41 <lambdabot> Num a => a -> a -> a
09:16:56 <rofer> Hey, can someone help me understand why the code on line 38 isn't printing to stdout? http://lpaste.net/7606856594155896832
09:17:23 <rofer> I feel like I really don't understand what's going on with the types there and I'm a little lost as to how to figure it out
09:17:51 <Iceland_jack> rofer: You're returning the action
09:17:57 <Iceland_jack> you probably want to lift it instead
09:18:45 <Iceland_jack> Returning it is a no-op
09:19:25 <rofer> Ah, thanks. I'll need to read somewhere to get what's going on, but now I have some more direction.
09:19:37 <Iceland_jack>     return <what ever>
09:19:37 <Iceland_jack>     ...
09:19:37 <Iceland_jack> is the same as just:
09:19:37 <Iceland_jack>     ...
09:19:41 <Iceland_jack> No problem
09:19:43 <rofer> The whole Application type there has me a bit confused
09:20:27 <Iceland_jack> I'm not familiar with Middleware, but see if "liftIO (hPutStrLn stdout "Poke")" doesn't work
09:20:57 <chrisdone> is there a nubBy equivalent that applies the predicate to all elements but lets you decide which should be omited?
09:21:11 <chrisdone> e.g. nubThese :: (a -> a -> These a) -> [a] -> [a]
09:21:20 <Iceland_jack> rofer: no wait, never mind I seem to be misunderstanding Middleware
09:22:10 <Iceland_jack> chrisdone: Can you give a usage example? Do you mean applying it to the cartesian product of the list with itself?
09:22:32 <rofer> Iceland_jack: Yeah, already blindly tried liftIO. All I'm trying to do right now is make that function print something before running the input app
09:22:33 <chrisdone> right
09:22:55 <chrisdone> hmm. i might be able to achieve what i want with a simple sort + groupBy
09:23:11 <Iceland_jack> rofer: since Middleware seems to just be a function 'type Middleware = Application -> Application' you can't really do that
09:23:40 <rofer> Iceland_jack: I'm trying to return a new application which just prints some text then does what the input application does
09:24:10 <rofer> Which I thought was possible
09:24:53 <rofer> http://hackage.haskell.org/package/wai-extra-0.4.6/docs/src/Network-Wai-Middleware-RequestLogger.html#logStdout <- is doing something more complicated, but looking at it I can't see what I'm doing wrong
09:26:23 <pergamino> hi
09:26:30 <pergamino> is any1 here
09:27:38 <Iceland_jack> pergamino: Quite a few people
09:27:50 <detrumi> Well, there's 1503 people here
09:29:05 <pergamino> If we have the following functions :
09:29:07 <pergamino> 0 my_sum :: [Int] -> Int -- summation of an Int list
09:29:07 <pergamino> 1 my_sum [] = 0 -- s.1
09:29:07 <pergamino> 2 my_sum (x:xs) = x + (my_sum xs) -- s.2
09:29:24 <Iceland_jack> pergamino: use http://lpaste.net/new/haskell if you want to show code
09:29:47 <Iceland_jack> What about 'my_sum'?
09:29:57 <pergamino> hold on
09:32:59 <pergamino> If we have the following functions :
09:32:59 <pergamino> http://lpaste.net/4454742982809092096
09:33:22 <pergamino> Would this be the correct sequence of rewritings if lazy evaluation is used?
09:33:26 <pergamino> http://168.235.65.206/i.txt
09:35:03 <Iceland_jack> pergamino: Yeah looks good to me
09:35:29 <pergamino> k
09:36:32 <pergamino> But why is this wrong? http://168.235.65.206/j.txt
09:36:50 * hackagebot stm-containers 0.2.6 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.6 (NikitaVolkov)
09:36:58 <Iceland_jack> pergamino: Because nothing is forcing the result of my_take
09:37:08 <pergamino> k
09:37:28 <Iceland_jack> What if 'my_sum' only needed a single element, then you're doing more work than is needed
09:37:38 <sivteck> they left
09:37:45 <Iceland_jack> Oh well
09:44:27 <tolt> chrisdone: In Lucid you didn't export the constructor for Attribute. I'm trying to write an instance of Term for my own data type but I'm not able to deconstruct Attribute
09:47:41 <chrisdone> tolt: why do you want to deconstruct attributes?
09:49:08 <tolt> I have my own attribute type so when defining with :: VNode -> [Attribute] -> VNode I can't create my own Attribute from the given Attribute
09:50:07 <chrisdone> another virtual dom guy?
09:50:22 <tolt> Haha I've been working on it for a month or so
09:51:07 <chrisdone> you're presumably not using the HtmlT monad at all?
09:51:37 <tolt> I'm not currently.
09:51:46 <chrisdone> what *are* you using from lucid?
09:51:49 <tolt> I haven't tried that though. That might make sense
09:52:03 <tolt> I was starting with attempting to define a Term instance
09:53:06 <tolt> But now I realize that I don't need to do that....
09:53:54 <tolt> I'm sorry for the above. I wasn't thinking about the instances in the right way
09:54:14 <chrisdone> i think lucid's internal HtmlT would have to change to an ADT to be able to output to different things other than a Builder to make a virtual dom
09:55:16 <tolt> Ahhhh
09:56:01 <chrisdone> that would change the type of execHtmlT and runHtmlT
09:56:27 <chrisdone> but otherwise wouldn't really be an intrusive change, apart from a possible performance loss
09:57:02 <tolt> Yeah. The loss would be in the overhead of the ast right?
09:57:22 <tolt> adt*
09:57:22 <chrisdone> yeah
09:57:33 <chrisdone> i suppose you'd also want to be able to stick event handlers in element attributes
09:57:51 <chrisdone> if you're doing some reactjs-like thing
09:58:16 <tolt> Yeah.
09:58:50 <chrisdone> that part is tricker
09:59:28 <tolt> Yeah. Definitely.
10:00:14 <tolt> My plan was to use https://github.com/Raynos/vdom-event
10:01:51 * hackagebot brainfuck-monad 0.2.0 - BrainFuck monad  http://hackage.haskell.org/package/brainfuck-monad-0.2.0 (JoeyHess)
10:05:11 <tolt> chrisdone: Thanks for the help. Running to lunch
10:06:52 * hackagebot simple-smt 0.4.0 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.4.0 (IavorDiatchki)
10:16:52 * hackagebot hills 0.1.1.0 - Generate STL models from SRTM elevation data.  http://hackage.haskell.org/package/hills-0.1.1.0 (djf)
10:18:45 <shapr> we put the funk in funktional programmierung
10:39:19 <gedringer> Hey guys :]
10:41:16 <gedringer> I'm writing some code for a 2-3-4 tree and I've started writing my search method and I wonder if I could do something along the lines "if(currentNode == TwoNode) then if(x == y) return True else callSelf" (callSelf for recursion) because I need to check if the leaf is two node three node or four node cause each has different number of keys in it
10:42:37 <gedringer> So I have this at the moment: http://pastebin.com/XY9aAm2a
10:43:33 <shachaf> Sounds like you should pattern-match.
10:43:38 <shachaf> if is the enemy
10:44:16 <gedringer> And in the next step I want to write something like: SearchMyTree .... wait.. can't I just write searchMyTree key (twoNode a left right) |key==a = True... ?
10:44:46 <shachaf> You could write something like that, modulo the capitalization.
10:45:03 <shachaf> (Haskell is quite case-sensitive.)
10:45:17 <gedringer> thanks :P I solved my own problem lol? Talking to others really makes the difference
10:45:20 <gedringer> hehehe
10:45:21 <gedringer> :3
10:49:09 <sgillis> I'm having some issues with writing an Aeson JSON parser. I would like to parse a Text, but it should only succeed if there is model in the database with the given value. Is there any way to do this?
10:50:29 <glguy> You can parse the JSON into your type and then do a validation pass afterward which can have knowledge of the current constraint set
10:51:29 <sgillis> Okay, thanks glguy
10:51:45 <pharpend> http://ix.io/2dk
10:51:53 <pharpend> ^ I'm trying to cabal install cabal-install
10:51:59 <pharpend> would someone  mind helping me through that error
10:52:04 <pharpend> (that's the output of -v3)
10:52:09 <pharpend> s/of/with
11:04:53 <nuttycom> sgillis: sounds like you're wanting to conflate IO with parsing. Those should be separate steps, I think.
11:08:31 <monochrom> it has already been suggested "pure-parse first, IO-validate after". but I have the crazy idea of "IO-customize parser first, pure-parse after".
11:13:03 <asciiascetic> monochrom: let us hear more of this crazy idea ;)
11:14:25 <athan> monochrom: Lecture! Lecture!
11:15:21 <monochrom> I'll write an example. this will take a while.
11:25:47 <sgillis> monochrom: How would you do that?
11:26:10 <gedringer> Hey guys, I've just finished writing my 2-3-4 tree search function and starting to write my Insert function. But I have no Idea on how I could change a node in a tree, for example say if(currentNode.key==twoNode) currentNode = newThreeNode(key 1, newKey)
11:26:53 <gedringer> Say I do: let myTree = TwoNode 15 (FourNode 2 4 8 (TwoNode 1 Empty Empty)(TwoNode 3 Empty Empty)(TwoNode 6 Empty Empty)(TwoNode 9 Empty Empty ))(TwoNode 20 Empty (TwoNode 25 Empty Empty ))
11:27:03 <gedringer> this will store my tree as myTree
11:27:24 <gedringer> I want to make a function that when myTree is passed, the function will modify it
11:27:51 <agocorona> if tou communicate from haskell to haskell ,  believe me: you don´t need JSON
11:28:02 <gedringer> so if node of interest is twoNode then keep the value in it, and convert it into threeNode with old value and the new one
11:30:41 <forgottenone> is it possible to define scanl with folds?
11:31:08 <Dashkal> @type scanl
11:31:09 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
11:31:25 <Dashkal> I don't see why not.
11:32:23 <forgottenone> how?(sorry if it is a silly question)
11:32:36 <Dashkal> Not silly.
11:33:13 <Dashkal> Scan is just fold, but keeping the intermediate values returned by the function, right?
11:33:54 <Dashkal> If that's right, it's just a fold where your accumulator is a [b] and you just keep appending each time.  Room for optimization for scanl of course.
11:34:57 <saep> @type foldl
11:34:58 <lambdabot> (b -> a -> b) -> b -> [a] -> b
11:35:21 <forgottenone> what i couldn't figure out how can i change accumulator for every element  in foldl
11:35:21 <Cale> > let myscanl f z xs = foldr (\x xs -> x : map (f x) xs) [] (z:xs) in myscanl (+) 0 [1..5]
11:35:23 <lambdabot>  [0,1,3,6,10,15]
11:35:52 <Cale> Don't use foldl, it'll never have the right semantics anyhow because it can't deal with infinite lists
11:36:01 <Cale> (while scanl can)
11:36:33 <Dashkal> One of those arguments for abstracting finite and infinite collections differently...
11:36:54 <Cale> eh, foldl is just an unnatural operation on lists
11:37:03 <Dashkal> It'd be nice if foldl terminating was encoded in the type.
11:37:06 <forgottenone> Cale it's just for experiment, i've read(or at least tried) why functional programming matters paper so what i understand from it every function can be written as a fold, so that's what i am trying to do
11:37:17 <Cale> Did you see how I did it?
11:37:49 <Dashkal> For list, foldr is the natural operation
11:37:54 <forgottenone> oh sorry it appears i missed the code
11:38:49 <rofer> Anyone here able to help with a Data.X509.File readKeyFile problem? I'm generating a key file in the format it seems to expect, yet it keeps failing to read any keys
11:38:50 <Cale> er, actually, that code is probably wrong
11:38:53 <Dashkal> A common hangup with foldr is the "right to left" bit.  Let that go.  What foldr does is it lets you take a cons list, and replace all the :'s and the [] at the end with what you pass to foldr.
11:39:01 <Cale> yes, it is wrong
11:39:05 <Cale> one sec :)
11:40:25 <Cale> yeah, that's a bit awkward
11:41:45 <Cale> I think we need to accumulate a function that will eventually be applied to the z
11:43:02 <forgottenone> Dashkal you're right infact when i learned foldl(today) it seems a bit odd
11:43:05 <lpaste> monochrom pasted “IO-customize a parser” at http://lpaste.net/116324
11:43:31 <monochrom> sgillis, athan: http://lpaste.net/116324
11:43:32 <Cale> > let myscanl f z xs = foldr (\x xs q -> q : xs (f q x)) (\q -> [q]) xs z in myscanl (\x xs -> concat ["(f ", x, " ", xs, ")"]) "z" ["1","2","3"]
11:43:33 <lambdabot>  ["z","(f z 1)","(f (f z 1) 2)","(f (f (f z 1) 2) 3)"]
11:43:37 <Cale> yep, that's right
11:43:53 <Cale> forgottenone: ^^ :)
11:46:27 <sgillis> monochrom: thanks for the snippet!
11:47:15 <asciiascetic> monochrom: cool!
11:48:51 <athan> monochrom: Thank you :)
11:50:53 <Cale> Yeah, the 'r' in foldr stands for "right-associated" not "right-to-left". It is literally impossible to process a list right to left, as the only way to decompose a list is into its first element and tail.
11:51:50 <forgottenone> Cale, thanks for the code. Now i am trying to understand it :)
11:51:56 * hackagebot uhc-light 1.1.8.0 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.0 (AtzeDijkstra)
11:52:57 <Cale> forgottenone: The key is to think about what you'd like to produce in the case that the list is nonempty vs. the list is empty
11:54:23 <Cale> forgottenone: and if it's confusing that the arguments to foldr have an additional function parameter, that just means that the result of our foldr is a function (one which will be supplied the 'z' parameter)
11:55:03 <Cale> forgottenone: The key thing that this lets us do is to apply the function obtained by folding over the remainder of the list (which I called xs) to a new argument, namely (f q x)
11:56:05 <Cale> @src scanl
11:56:05 <lambdabot> scanl f q ls = q : case ls of
11:56:06 <lambdabot>     []   -> []
11:56:06 <lambdabot>     x:xs -> scanl f (f q x) xs
11:56:14 <Cale> ^^ might help to have this in view as well
11:57:00 <Cale> So in the nonempty case, we want the resulting list to begin with the q parameter, and continue with the scanl over the rest of the list, only with the q parameter replaced by (f q x)
11:57:13 <Cale> (\x xs q -> q : xs (f q x))
11:57:17 <Cale> ^^ so that's what this says
11:57:49 <Cale> and in the empty case, we want the list to again begin with q, and continue with the empty list, i.e. the result is just [q]
11:57:55 <Cale> (\q -> [q])
11:57:59 <Cale> and that's what that says
11:58:34 <Cale> and then we supply the list xs, and the initial value for the q parameter, which is z
11:59:47 <Cale> forgottenone: does that make any kind of sense?
11:59:55 <Cale> forgottenone: It may help to see simpler examples
12:00:35 <Cale> > foldr (\x xs q -> (x,q) : xs (q+1)) (\q -> []) "abcde" 0
12:00:36 <lambdabot>  [('a',0),('b',1),('c',2),('d',3),('e',4)]
12:01:02 <Cale> ^^ you can sort of use this as a way to keep track of additional "state" while folding over the list
12:01:07 <bitemyapp> Cale: do yer simple-reflect trick.
12:01:13 <kadoban> Is there a 'words' and 'lines' and stuff that works in ByteStrings somewhere that I'm missing, or should I just do them in terms of split?
12:01:56 * hackagebot lame-tester 1.1 - A strange and unnecessary selective test-running library  http://hackage.haskell.org/package/lame-tester-1.1 (TheBizzle)
12:01:58 * hackagebot pathfindingcore 1.1 - A toy pathfinding library  http://hackage.haskell.org/package/pathfindingcore-1.1 (TheBizzle)
12:02:22 <Cale> bitemyapp: That's a little bit tricky because the xs is a function...
12:02:30 <Cale> maybe possible...
12:02:32 <bitemyapp> hrm.
12:02:51 <bitemyapp> well, I meant just to demonstrate fold(l|r) vs. scan(l|r)
12:02:55 <bitemyapp> but yeah, that's a good point.
12:04:35 <JamesLens> Hello lovely people, any idea why this function doesnt work: http://lpaste.net/raw/116325 ?
12:05:24 <vanila> isPalindrome init(tail(xs)) is parsed as (isPalindrome init)(tail(xs))
12:05:30 <vanila> the space (function application) binds tightest
12:05:47 <kadoban> If I want to process an ASCII input file, which is a large (couple million) list of space-separated Ints, and output a few numbers, what should I be using? Data.Text ? Data.ByteString? Doesn't matter?
12:05:51 <vanila> you could write: isPalindrome (init (tail xs))
12:06:01 <vanila> or isPalindrome . init . tail $ xs
12:06:18 <vanila> A faster algorithm might be to just check if list == reverse list
12:06:28 <JamesLens> I see, thanks a lot :)
12:06:49 <JamesLens> the reverse list felt a bit like cheating haha
12:07:00 <vanila> its not cheating :)
12:07:19 <JamesLens> Coming from C++ it very much feels like it :P
12:07:34 <vanila> init is an expensive operation
12:07:43 <vanila> and you perform it repeatedly
12:07:54 <Cale> Moreover, xs == reverse xs is quite a bit faster than many would expect it to be, as not all of the reverse of the list need be computed in the case where it's not a palindrome.
12:07:54 <vanila> so the function will be very slow compared to just doing a reverse
12:08:12 <Cale> Yeah, and init is horrible :P
12:08:27 <Cale> init and last are generally things to be avoided if possible
12:08:35 <Cale> as well as !!
12:08:50 <forgottenone> Cale i couldn't  understand  xs (f q x) in (\x xs q -> q : xs (f q x)), so xs is a function in here?
12:08:55 <Cale> yes
12:08:56 <JamesLens> fair enough, thanks a lot guys :)
12:09:02 <albeit> If I have a nested datastructure of typeclass Show, what's the easiest way to pretty-print it, with one field a line, and nested structures indented?
12:09:06 <Cale> forgottenone: It's the function obtained by folding over the tail of the list
12:09:07 <Peaker> About IO in parsing (in my logs for the chan from 1 hour ago), I have #include directive support, is there a good idea how to handle that without conflating IO and parsing?
12:09:19 <Cale> forgottenone: which is why I called it "xs" schematically
12:09:29 <Cale> (even though it's not itself a list)
12:10:52 <spopejoy> does anyone know how to lift a Maybe into MaybeT?
12:11:33 <mmmm> Peaker: You can use a free monad?
12:11:38 <spopejoy> all I can figure out to do is "maybe (fail "bye") return someMaybe"
12:11:48 <mmmm> spopejoy: It's probably just return
12:11:55 <spopejoy> it's not
12:12:04 <mmmm> MaybeT . return?
12:12:06 <Peaker> spopejoy: MaybeT has a "m (Maybe a)" inside a "MaybeT" data constructor.  So if you have "Maybe a", first you have to lift it to "m (Maybe a)" and then you have to wrap that with the MaybeT constructor
12:12:11 <Cale> spopejoy: maybe mzero return
12:12:38 <Cale> Or indeed, you can  MaybeT . return
12:12:44 <Cale> which ought to be the same
12:13:02 <Peaker> mmmm: So instead of unrestricted IO I only have read-file?
12:13:22 <Peaker> mmmm: I already do that via a Monad subclass that allows me only to do a few of the IO operations I need
12:13:35 <Cale> (though the latter reveals more about the implementation of the monad you're using, and might need to be changed later, while  maybe mzero return  is rather more polymorphic)
12:14:01 <kadoban> How do I do Int -> ByteString? Like 'show', but for ByteString...
12:14:42 <Cale> kadoban: pack . show
12:14:57 <kadoban> Heh...oh. Yeah, thanks.
12:15:28 <Cale> Maybe someone's written a more efficient direct version, but it's not something I'd usually be too worried about
12:15:40 <spopejoy> Cale: MaybeT . return works, thanks. mzero . return is complaining isn't happy under MonadSnap ...
12:15:45 <Cale> (I'd be more concerned about using ByteString to represent text directly)
12:16:00 <Cale> spopejoy: mzero . return is not what I wrote
12:16:15 <Cale> spopejoy: I wrote   maybe mzero return
12:16:19 <Cale> :t maybe
12:16:20 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:16:25 <Cale> :t maybe mzero return
12:16:25 <lambdabot> MonadPlus m => Maybe a -> m a
12:16:30 <kadoban> Well, it's for a programming-competition-type usage. I was using String, but the input processing time was killing me. Not really sure how to do this right and fast.
12:16:37 <spopejoy> Haha
12:16:48 <spopejoy> I thought you were saying "maybe it's mzero return"
12:16:58 <chrisdone> kadoban: https://hackage.haskell.org/package/double-conversion-2.0.1.0/docs/Data-Double-Conversion-ByteString.html
12:17:03 <spopejoy> got it, that works too
12:17:32 <chrisdone> kadoban: note the header docs: Although about 15 times faster than plain show, these functions are slower than their Text counterparts, at roughly half the speed.
12:17:37 <forgottenone> Cale but where we define xs function?
12:17:51 <Cale> forgottenone: it's one of the parameters bound by the lambda
12:17:53 <kadoban> chrisdone: Hmm, interesting.
12:18:21 <Cale> forgottenone: remember, the first parameter to foldr is the thing we're replacing (:) with
12:18:22 <kadoban> I really know very little about this stuff, I've never bothered to look beyond String all that much....
12:18:51 <Cale> @src foldr
12:18:51 <lambdabot> foldr f z []     = z
12:18:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:19:20 <chrisdone> kadoban: if you're doing text, use Text. doing binary data, use ByteString
12:19:35 <chrisdone> kadoban: if you're doing a Haskell 98 freshman course, use String
12:19:39 <Cale> In the recursive case, f is applied to x and (foldr f z xs), i.e. the result of substituting (:) for f and [] for z throughout the rest of the list
12:20:05 <kadoban> chrisdone: I see. Yeah, I should probably be using Text then
12:20:39 <Cale> forgottenone: When we do this substitution, we're allowed to have the result be any type of thing at all.
12:20:51 <Cale> forgottenone: and in this case, we're cleverly having the result be a function
12:20:59 <Peaker> chrisdone: I just tested GHC head, it apparently supports -fno-code -fwrite-interface which should let flycheck fly, hopefully :)
12:21:05 <Cale> forgottenone: Which is where the extra q parameter comes from
12:21:23 <chrisdone> Peaker: with TH?
12:21:41 <Peaker> chrisdone: not sure, but I think I eliminated almost all the TH I had
12:21:57 <chrisdone> (￣ー￣)
12:22:00 <Cale> forgottenone: http://cale.yi.org/share/Folds.png might help a little to have this picture in mind :)
12:22:15 <forgottenone> Cale i can understand recrusive way but couldn't grasp foldr way,
12:22:27 <kadoban> Well, the BS version is plenty fast enough at least, let's see if I can figure out how to use Text.
12:22:47 <Cale> forgottenone: (ignore the diagram for scanl there for now, just look at the one for foldr)
12:23:28 <spindas> Which is more efficient -- building a HashSet and turning it into a list, or building a list and using nub to remove duplicates at the end?
12:23:44 <mmmm> the first almost certainly
12:23:47 <mmmm> nub is quadratic
12:23:50 <Cale> spindas: nub is pretty inefficient usually
12:24:10 <Cale> Because it doesn't use any additional information about the elements apart from the fact they can be compared for equality
12:24:22 <spindas> Thank you! So the overhead of building HashSets and union-ing them together is less than that of nub.
12:24:22 <Cale> If you know the elements are Ord, you can  map head . group . sort
12:24:28 <Cale> which is usually faster than building a Set
12:24:41 <Cale> Set.toList . Set.fromList  will work though
12:24:54 <spindas> Ah, I do know that they're Ord.
12:24:57 <Cale> I don't even want to think about HashSet
12:25:25 <Cale> Well, HashSet *might* be faster than Set some of the time.
12:25:39 <Cale> But it really depends on a lot of things, and a lot of the time, it'll be slower.
12:26:02 <spindas> Interesting.
12:26:06 <Cale> (because hashing the elements isn't free, and may add up to more work than computing the ordering relations)
12:27:03 <Cale> Set and Map are incredibly finely-tuned and are very frustrating datastructures to try to beat
12:27:32 <monochrom> frustrating to beat. hehe
12:27:49 <Cale> That's not saying they're always the best thing, but it's hard to write something which will dominate them in all cases.
12:27:52 * monochrom is frustating to prove wrong, too :)
12:27:54 <Peaker> If you don't need their persistence, they're easy to beat
12:28:30 <Peaker> (naive mutable hash table written in C would beat Map/Set relatively easily)
12:29:16 <Cale> Yeah, but then try using that in some recursive algorithm and start paying for extra removals/inserts to undo the work you did before the recursive call...
12:30:57 <monochrom> this is why the explicit assumption "if you don't need their persistence" was stated explicitly
12:31:04 <Cale> yes
12:31:57 * hackagebot doctest-discover-configurator 0.1.0.6 - Easy way to run doctests via cabal (no aeson dependency, uses configurator instead)  http://hackage.haskell.org/package/doctest-discover-configurator-0.1.0.6 (RickyElrod)
12:32:10 <Cale> There are a lot of cases where you can benefit from persistence that you might not be completely aware of if you're used to programming with mutable-everything.
12:32:55 <Peaker> It's nice for parallelism
12:33:53 <monochrom> it's also nice for backtracking search algorithms
12:34:12 <monochrom> by the very definition of "backtracking", you will have to revisit old states all the time
12:34:42 <Cale> Edward Kmett did a bunch of work implementing fancy cache-oblivious maps, and he managed to make one of {insert/lookup} faster than Map and the other slower.
12:34:55 <Cale> (I forget which way around it was)
12:35:02 <Cale> Probably lookup was faster
12:35:44 <Peaker> monochrom: I think undoing mutable changes might be faster than logN copies and a lot more indirections
12:36:28 <Cale> Peaker: But remember it's not copies of the entire structure...
12:36:33 <monochrom> yes. but it's annoying to code up.
12:36:46 <Cale> It *might* be faster
12:37:00 <Peaker> monochrom: not that bad, if you make it as a nice bracket
12:37:25 <monochrom> when I was young, I read and tried to follow a book on basic AI algorithms in C. I was really put of by the need to hand-code undo's and/or copying.
12:37:33 <Cale> Also, hashtable performance is really non-uniform with problem size...
12:37:42 <monochrom> some 20 years later, I found you guys. I was a happy man since then.
12:38:28 <Cale> You need to do all this extra trickery to get scaling performance that a lot of people are too lazy to do if they're implementing them by hand. Let alone choosing a good hash function which isn't exploitable will likely harm your performance a bit more.
12:38:48 <Peaker> monochrom: but if you write all the basic mutators as do/undo pairs, then it all composes nicely :)
12:39:12 <monochrom> even when you use mutable stuff and the technique of bracketting to make it obviously correct, Haskell still expresses it better than C.
12:39:46 <Peaker> unless performance considerations forces you to uglify the code :(
12:40:07 <ThreeOfEight> hm
12:40:19 <ThreeOfEight> JuicyPixels is suddenly giving me lots of errors about "No instance Storable for PixelRGB8"
12:40:22 <ThreeOfEight> what is that all about?
12:41:18 <dagle> Why doesn't haskell have a package manager?
12:41:20 <Cale> The real reason I dislike the fact that a lot of introductory texts list the asymptotic performance of hashtable lookup as O(1) isn't just that it's a lie, but also that it deceives people into thinking that it's going to be faster in the large cases than operations on other structures which are O(log n).
12:41:28 <chrisdone> ThreeOfEight: in GHCi?
12:41:44 <Cale> dagle: It kind of does, it just comes in two parts
12:41:58 * hackagebot base-prelude 0.1.7 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.7 (NikitaVolkov)
12:42:05 <Cale> dagle: There's cabal install for installing code, and then ghc-pkg for managing the packages after they're installed.
12:43:04 <dagle> And then sandboxing everything?
12:44:24 <d34dtest> Oh, by the way, how do you upgrade the packages?
12:44:35 <vanila> is stackage a solution to the cabal hell problem?
12:44:42 <sivteck> nope
12:44:45 <d34dtest> The spell I've come across on StackOverflow and the likes involves rebuilding all packages.
12:44:51 <chrisdone> depends what the cabal hell problem is
12:44:54 <d34dtest> Which is probably a way to go, but seems a bit like an overkill.
12:44:57 <vanila> I asked "why not have a cabal type thing that works" and someone recommended stackage
12:44:59 <Cale> dagle: You can sandbox as you like
12:45:16 <vanila> chrisdone, the issue is 'cabal install' will fail 99% of the time for me
12:45:26 <chrisdone> vanila: then stackage pretty much solves that
12:45:40 <sivteck> vanila, It solves for ~900 packages on hackage
12:45:44 <dagle> Cale: Well, maintain stuff with these "it's not a package manager" "package tools" tends to be horrible in the long run.
12:46:10 <Cale> dagle: Often if I know the dependencies of something are all stuff that I'm generally going to want anyway, I'll just install without the sandbox. I'm not going to say that it always works perfectly, but it's not that costly if you mess things up, because you can just blow away ~/.ghc in the worst case and get things back to a sane enough state :P
12:46:18 <monochrom> stackage is or is not a solution depending on which part of cabal hell you care about and whether stackage has all packages you want or not
12:46:35 <vanila> well all I really want is to be able to get some things done with haskell
12:46:49 <vanila> right now I actually cannot since cabal fails so often
12:47:07 <Cale> vanila: hm, what are you working with?
12:47:21 <Cale> I haven't run into *that* many issues installing packages with cabal
12:47:39 <chrisdone> Cale: … recently =3
12:47:52 <averell> installing lambdabot locally always does it for me
12:47:55 <dagle> Installing isn't a problem in most of the cases, maintaining and updating is the part where shit can go wrong.
12:47:57 <Cale> Even when it was much worse...
12:48:02 <chrisdone> lambdabot was never easy to install
12:48:04 <sivteck> lambdabot is broken -.-
12:48:09 <chrisdone> well, it was easy for me. but others complained
12:48:22 <sivteck> (in hackage)
12:48:47 <chrisdone> LTS haskell will be interesting
12:49:09 <ThreeOfEight> chrisdone: no, with GHC
12:49:14 <Cale> I think the trick to installing lambdabot was always just to make sure to unpack the source code to wherever you'd be running it out of, and then install the helper library from inside before lambdabot itself.
12:49:15 <monochrom> I don't upgrade really. it's probably why I don't have cabal problems.
12:49:26 <Cale> But I never actually used the hackage version.
12:49:35 <vanila> LTS sounds excellent
12:50:00 <monochrom> I just wait for a new GHC version. it implies rebuilding all libraries I need, which happens to be a good time to switch to new library versions as well.
12:50:15 <chrisdone> stackage will be renamed to "stackage nightly" and then LTS will be a package set that has backports for bugfixes and such for n months
12:50:20 <monochrom> in fact, I just wait for a new Haskell Platform version.
12:50:34 <chrisdone> monochrom: do you use haskell at work?
12:50:44 <monochrom> no
12:50:53 <averell> i just use archhaskell with the terrible xsounds mirror because i'm too lazy for anything else
12:51:03 <vanila> I would like to use other haskell compilers than GHC too, but doesn't seem really possible right now
12:51:05 <chrisdone> i don't know any haskell company that can run on the old packages in HP
12:51:25 <Cale> In almost all cases where I've used Haskell for work, I've eventually been on an older version of GHC than most of the community.
12:51:27 <sivteck> vanila, Nix has a nice collection of haskell compilers :^)
12:51:43 <chrisdone> Cale: that's where LTS support comes in =)
12:52:00 <Cale> Yeah, that's probably a good thing
12:52:05 <vanila> sivteck, Can I see a list of them?
12:52:14 <chrisdone> we were on ghc 7.4 for a while
12:52:23 <chrisdone> neil mitchell is still on ghc 7.2. poor guy
12:52:23 <Cale> Though it really isn't *that* much trouble in general to grab packages and maintain them yourself to some small extent.
12:52:35 <sivteck> vanila, https://github.com/NixOS/nixpkgs/tree/3d049938c872eb88c39afd7bdc952abfbb0eb3bd/pkgs/development/compilers (ghc,lhc,jhc,hugs...)
12:52:37 <monochrom> the way I understand companies, some companies have "freeze versions for 2 years" policies, and some others have "upgrade every week" policies.
12:52:48 <chrisdone> Cale: it's do-able but it is a burden
12:52:55 <Cale> I suppose if you're still on 7.2 at this point, life is probably kind of awful for you.
12:53:07 <monochrom> in fact, my alma mater CS department has just recently upgraded from ubuntu 12.04 to 14.04.
12:53:34 <chrisdone> that seems fine, 12.04 was an LTS
12:53:39 <vanila> sivteck, Thanks! I don't see UHC there
12:53:53 <chrisdone> i'm on ubuntu 13.04
12:54:00 <chrisdone> you know what happens if you don't update in time?
12:54:12 <chrisdone> the sources just become 404 one day and you're screwed =)
12:54:33 <monochrom> I only know what happens if I don't finish my thesis in time :)
12:54:37 <Cale> I think we didn't really have a very hard policy so much as we just didn't want to constantly be fixing issues. In the case of iPwn, there was fairly heavy GHC work that was required to switch to a new GHC version.
12:54:41 <pharpend> Who is lambdabot's maintainer?
12:54:50 <Cale> pharpend: Good question ;)
12:54:53 <pharpend> or rather, who decides what channels he joins?
12:55:04 <Cale> Yeah, that's a whole different person
12:55:07 <monochrom> then it's int-e
12:55:09 <Cale> That is int-e I think
12:55:10 <Cale> yes
12:55:10 <pharpend> There's another channel that could use lambdabot
12:55:12 <sivteck> vanila, should be easy to package (i think)
12:55:13 <pharpend> okay
12:55:19 <vanila> alright :)
12:55:20 <chrisdone> i don't imagine anyone's changed lambdabot for some months
12:55:30 <pharpend> well I see him cropping up in new channels a lot
12:55:32 <chrisdone> i noticed that faq changed
12:55:32 <chrisdone> @faq
12:55:32 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:55:42 <Cale> There was someone who came along and did a bunch of work on lambdabot
12:55:59 <chrisdone> > 1
12:56:00 <lambdabot>  1
12:56:01 <Cale> James Cook?
12:56:04 <chrisdone> my version was faster =p
12:56:18 <pharpend> chrisdone: do you have a bot for fay?
12:56:22 <chrisdone> nope
12:56:33 * pharpend nods at chrisdone in disappointment
12:56:39 <monochrom> chrisdone: on procratinating linux upgrades (as opposed to finishing a thesis), I used to keep using red hat for 2-3 years after it had become fedora.
12:57:07 <Cale> monochrom: And that would have been back when linux upgrades weren't always completely terrible
12:57:09 <chrisdone> pharpend: http://replygif.net/i/701.gif
12:57:20 <monochrom> i.e., I did not pay, I did not switch to fedora, I just kept using the final free red hat.
12:57:31 <Cale> oh, pay, lol
12:58:02 <chrisdone> yeah, i am a shameless upgrade procrastinator
12:58:04 <pharpend> @ask int-e would you mind adding #learnmath to lambdabot's channel list?
12:58:05 <lambdabot> Consider it noted.
12:58:16 <pharpend> I use Gentoo, so updating is somewhat of a PITA
12:58:24 <chrisdone> i never update my OS packages. i just wait until it's too late to do so after a couple years and then install a fresh distro
12:58:28 <monochrom> then someone was a very nice embassador of ubuntu, and I switched.
12:58:29 <pharpend> "You can recompile every single package on your system, right?"
12:58:40 <Cale> pharpend: What kind of math is #learnmath about?
12:58:47 <averell> i type pacman -Syu to keep my fingers busy dozens of times a day
12:59:07 <pharpend> Cale: pretty much anything. https://pharpend.github.io/lysa/ will give you some good information
12:59:08 <monochrom> eh? #learnmath?! that sounds nice
12:59:12 <chrisdone> ubuntu mess things up too much and i don't have the time to sift through bugfix patches versus unwelcome feature change patches
12:59:16 <monochrom> ah why am I so off-topic today
12:59:44 <chrisdone> the universal cry of the ubuntu upgrader: "but i was using that!"
12:59:50 <pharpend> meh, I don't think off-topic rules in this channel are a huge deal, as long as we don't distract from anyone trying to get help.
12:59:52 <pharpend> chrisdone: heh
13:00:24 <chrisdone> one of these weekends i'll install nixos and become a smug nix weenie
13:00:34 <SoupEvil> is it just my routing or is haskell.org (landing+wiki)currently really slow?
13:00:50 <chrisdone> SoupEvil: i'm unable to even resolve the domain
13:00:59 <chrisdone> but, italian internet
13:01:03 * chrisdone shrugs
13:01:51 <indiagreen> can resolve, but slow for me as well
13:02:07 <SoupEvil> im on the german. maybe a problem in eu routing? or maybe the server site?
13:02:13 <monochrom> hmm, some other Italian person was reporting a few days ago about being unable to get haskell.org.
13:02:33 <chrisdone> monochrom: i suspect it's to do with the use of cloudflare hosting
13:02:46 <pharpend> chrisdone: I tried nix, I have to say I was not impressed.
13:02:48 <chrisdone> possibly the ISP blocks some of the ip ranges due to spam or something
13:03:03 <pharpend> chrisdone: you would probably like Debian Stable, it's basically ubuntu, but it doesn't break nearly as often
13:03:05 <chrisdone> traceroute just gives up half way through
13:03:54 <chrisdone> well, the nice thing about nixos would be that if you upgrade and everything you once knew and loved has been soiled, you can just go back in time
13:04:20 <sivteck> and haskell binaries
13:04:35 <chrisdone> the lack of 'undo' is probably one of the worst things about almost all software
13:05:35 <monochrom> I read a book on GUI design. it laments that "do you want to save? do you really want to save?" is so common when going ahead to save and providing undo is better. I agree.
13:05:37 <mjo-work> Does anyone know who's in charge of the haskell-* mailing lists? I just realized things been real quiet, and it's because the ML server is blacklisted: http://mxtoolbox.com/SuperTool.aspx?action=blacklist%3a23.253.242.70
13:05:57 <chrisdone> monochrom: indeed
13:06:32 <sivteck> mjo-work, try #haskell-infrastructure
13:07:11 <monochrom> when I was young I was spoiled by VMS (the OS of VAX). it keeps old file versions. I miss that.
13:07:31 <monochrom> cabal hell would be so much tamer on VMS.
13:08:11 <mjo-work> sivteck: thanks, I just asked there, too
13:08:31 <forgottenone> Caleb thank you for explaining everything patiently step by step and sorry for being a headache, i guess i finally understand
13:10:40 <forgottenone> * Cale ^^
13:12:09 <Cale> forgottenone: No worries, did you see the example I did with the pairs?
13:12:48 <Cale> forgottenone: maybe I should show this first:
13:13:01 <Cale> > foldr (\x xs -> x : xs) [] "abcde"
13:13:02 <lambdabot>  "abcde"
13:13:23 <Cale> ^^ this is the identity function, now we'll add a state parameter...
13:13:39 <Cale> > foldr (\x xs q -> (x,q) : xs q) (\q -> []) "abcde" 0
13:13:40 <lambdabot>  [('a',0),('b',0),('c',0),('d',0),('e',0)]
13:13:50 <Cale> and update it as we go
13:13:55 <Cale> > foldr (\x xs q -> (x,q) : xs (q+1)) (\q -> []) "abcde" 0
13:13:56 <lambdabot>  [('a',0),('b',1),('c',2),('d',3),('e',4)]
13:14:20 <Cale> See how that works?
13:15:55 <Cale> > foldr (\x xs q -> q : xs (q+1)) (\q -> []) "abcde" 0 -- a slight adjustment to the above where we leave out the original elements of the list, and instead only give the state parameter
13:15:56 <lambdabot>  [0,1,2,3,4]
13:16:28 <Cale> > foldr (\x xs q -> q : xs (q+1)) (\q -> [q]) "abcde" 0 -- of course, we could produce the final state as well now, at the end
13:16:30 <lambdabot>  [0,1,2,3,4,5]
13:17:15 <Cale> > foldr (\x xs q -> q : xs (x + q)) (\q -> [q]) [1,2,3,4,5] 0 -- we can re-introduce the dependency on the actual list elements, by say, adding them to the current state instead
13:17:15 <mmachenry> Is there a way to find functions within a project that are exported from modules but never used anywhere else in the project in other modules?
13:17:16 <lambdabot>  [0,1,3,6,10,15]
13:17:24 <Cale> and now this is practically scanl
13:18:20 <Cale> just abstract addition to some arbitrary f and the 0 at the end to some arbitrary z
13:19:09 <forgottenone> ok it made it much clearer so the lambda function which takes three parameters , get additional function parameter which created before, and returns a new function right? and the first function is second parameter of foldr
13:19:37 <chrisdone> quoth i, upon debugging equality of Names. "hm, so what's in a name?"
13:19:38 <Cale> forgottenone: (\x y z -> ...) is the same thing as (\x y -> (\z -> ...))
13:20:54 <Cale> So maybe it would have been a little clearer if I'd written it like:
13:21:01 <Cale> > foldr (\x xs -> x : xs) [] "abcde"
13:21:02 <lambdabot>  "abcde"
13:21:03 <Cale> becomes
13:21:16 <Cale> > foldr (\x xs -> (\q -> (x,q) : xs q)) (\q -> []) "abcde" 0
13:21:18 <lambdabot>  [('a',0),('b',0),('c',0),('d',0),('e',0)]
13:21:56 <Cale> and/or maybe I should put a step in the middle where we don't even display the q
13:21:59 * hackagebot alea 0.3.1.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.3.1.0 (rnhmjoj)
13:22:02 <Cale> > foldr (\x xs -> (\q -> x : xs q)) (\q -> []) "abcde" 0
13:22:03 <lambdabot>  "abcde"
13:23:52 <Cale> > foldr (\x xs -> (\q -> q : xs (x:q))) (\q -> [q]) "abcde" []
13:23:54 <lambdabot>  ["","a","ba","cba","dcba","edcba"]
13:24:02 <Cale> lots of fun variations to try :)
13:24:49 <Cale> Here, the q parameter acts a bit like a stack and we push elements of the list onto it as we go.
13:25:29 <forgottenone> ok i really understood now, thank you. What was i really dont get it how this mechanism works to represent differents states in different cons and now i believe i really got it
13:26:02 <Cale> Yeah, it's a really good trick to know, but mind-bending the first time you see it :)
13:26:26 <forgottenone> yes especially if you're coming from the land of imperetivians :D
13:26:59 * hackagebot text 1.2.0.3 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.0.3 (BryanOSullivan)
13:28:34 <forgottenone> actually although i give a quick look functional paradigm before, i can say that i'm actually trying to learn for only one week.
13:29:22 <athan> forgottenone: Once you go Map, you never go back
13:31:13 <Cale> forgottenone: Yeah, I'm not sure how often you'd see a foldr like these ones in real production code, as often something like scanl or another function would do a better job of expressing the idea, but it does give a good idea for just how powerful foldr can be.
13:31:15 <forgottenone> athan actually i'm learning functional paradigm as a support not as a replacement, but i must admit that it changes how you look to the subject
13:31:45 <monochrom> once you go mad, you never go back :)
13:32:21 <forgottenone> monochrom: that's more appropiate :D
13:32:21 <Cale> also, just the idea of constructing functions which will eventually construct your result
13:32:39 <Cale> is a powerful one that can be applied to other higher order functions
13:33:22 <forgottenone> Cale you're right about fold in why functional programming matters paper all functions are defined from fold so it's pretty amazing
13:34:04 <Cale> Yeah, and even without this trick, foldr goes a very long way.
13:34:54 <Cale> and in general, the idea of replacing all the constructors of a data structure with other functions or values of appropriate types tends to be extremely useful
13:35:08 <Cale> For instance, I might define some binary tree datatype like:
13:35:26 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
13:35:28 <lambdabot>  Defined.
13:35:42 <athan> monochrom: Once you make incomplete ideas
13:35:51 <forgottenone> Cale by the way i'm learning from learn you a haskell, right now and plannig to use real world haskell also, do you suggest these sources, also any recomendation from additional sources?
13:36:05 <Cale> and then similar to foldr, we can define a function which given a function b and value t, goes through a BinTree, replacing each Branch with b and each Tip with t
13:36:38 <Cale> @let foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
13:36:39 <lambdabot>  Defined.
13:36:51 <Cale> and with this, we can do a lot of useful tree transformations
13:36:56 <Cale> for example...
13:37:15 <athan> forgottenone: Read access, write access, and mutable information can be represented as a nesting data structure :)
13:37:26 <Cale> > foldTree [] (\x l r -> l ++ [x] ++ r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:37:28 <lambdabot>  [2,1,3]
13:37:33 <Cale> ^^ an inorder traversal
13:37:47 <pharpend> I'm trying to build lambdabot, and this is happening -> http://ix.io/2eB
13:37:49 <Cale> > foldTree 0 (\x l r -> x + l + r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:37:51 <lambdabot>  6
13:37:53 <Cale> ^^ sum of elements
13:38:07 <Cale> > foldTree Tip (\x l r -> Branch x r l) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:38:08 <lambdabot>  No instance for (GHC.Show.Show (L.BinTree a0))
13:38:08 <lambdabot>    arising from a use of ‘M14641729677958821012855.show_M14641729677958821012...
13:38:08 <lambdabot>  The type variable ‘a0’ is ambiguous
13:38:16 <Cale> oh, dang
13:38:17 <Cale> lol
13:38:22 <Cale> @undefine
13:38:22 <lambdabot> Undefined.
13:38:32 <athan> Cale: *psst* does foldable have different overloadable behaviour, like applicative does with parallel vs. cartesian implementations?
13:38:38 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a) deriving (Eq, Ord, Read, Show)
13:38:40 <lambdabot>  Defined.
13:38:45 <Cale> @let foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
13:38:46 <athan> I'm thinking bredth-first vs. depth first foldables for trees :S
13:38:47 <lambdabot>  Defined.
13:38:51 <Cale> > foldTree Tip (\x l r -> Branch x r l) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:38:52 <lambdabot>  Branch 1 (Branch 3 Tip Tip) (Branch 2 Tip Tip)
13:39:04 <Cale> ^^ flip the tree over right to left :)
13:39:19 <Cale> forgottenone: btw, those sound like reasonable sources to me
13:39:38 <Cale> forgottenone: I remember someone recommending some numbered course...
13:39:51 <athan> cis193?
13:40:05 <Cale> forgottenone: (I learned Haskell way before most of the resources were available, so I'm not the best person to ask about them...)
13:40:13 <Cale> yeah, that sounds like it
13:40:40 <athan> you just gotta keep dabbling :)
13:40:42 <Cale> anyone have a link?
13:40:53 <athan> most of the critical things I've learned were from #haskell
13:40:53 <Cale> 194?
13:41:04 <athan> I'm not sure :/ I heard bitemyapp mention it
13:41:07 <Cale> http://www.seas.upenn.edu/~cis194/
13:41:10 <forgottenone> seems like they switch to c#  http://www.seas.upenn.edu/~cis193/
13:41:21 <sivteck> @where guide
13:41:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:41:33 <Cale> 193 is a C# course, but 194 seems to be about Haskell :)
13:41:45 <athan> Cale: You're right on the money
13:41:49 <athan> my mistake
13:41:50 <monochrom> professors agree: C# = Haskell - 1
13:41:53 <forgottenone> sivteck thank you
13:41:56 <Cale> and all the lectures are there
13:42:32 <athan> monochrom++
13:43:28 <busbus> Hi everyone :)
13:43:42 <Cale> Hello!
13:43:58 <forgottenone> when you understand you become a haskell programmer? when you read ++ as concatenation not incrementation
13:44:07 <Cale> Feel free to ask any questions you might have about Haskell :)
13:44:12 <Cale> forgottenone: hehe
13:44:27 <Cale> forgottenone: http://www.willamette.edu/~fruehr/haskell/evolution.html
13:44:27 <monochrom> naw, someone did it better the other day. he wrote "O 1" instead of "O(1)".
13:44:43 <chrisdone> heh
13:44:51 <pharpend> Any ideas on my lambdabot troubles
13:44:57 <chrisdone> sometimes i write "do" in javascript
13:45:29 <Cale> pharpend: Sorry, what troubles were you having?
13:45:35 <chrisdone> hmm
13:45:36 <Cale> oh, I see
13:45:38 <pharpend> Cale: I'm trying to build lambdabot, and this is happening -> http://ix.io/2eB
13:45:50 <chrisdone> the Name type in the ghc api is annoying
13:46:17 <Cale> pharpend: That's a really interesting problem, because there's no way that's compilable for anyone else.
13:46:19 <chrisdone> i have two names which refer to the same defined location but i can't manage to get any kind of equality comparison on them to work
13:46:30 <Cale> pharpend: Change the .hs-boot to match the declaration in the .hs file
13:46:47 <chrisdone> and the name is opaque so i can't simply inspect what's inside it to figure out where they differ
13:47:29 <pharpend> chrisdone: isn't the entire problem with the ghc api that there is no ghc api?
13:47:46 <chrisdone> partly that, and partly it's just icky
13:47:59 <pharpend> Cale: I'm not familiar with .hs-boot
13:48:03 <Cale> pharpend: The idea behind .hs-boot files is that they contain type signatures and data declarations which match the actual .hs files but make it possible to have circular module dependencies
13:48:04 <chrisdone> for functional programmers the people hacking on ghc make some nasty choices
13:48:46 <pharpend> Cale: okay, is there a file I edit?
13:48:47 <Cale> pharpend: i.e. just enough stuff so that GHC will be able to know about things needed to compile the things dependent on this module without having to compile the module itself.
13:49:01 <Cale> Yeah, src/Lambdabot/Monad.hs-boot
13:49:06 <pharpend> that sounds like bad practice
13:49:19 <chrisdone> using the ghc api is like lifting up rocks in a forest to find the data you want but instead of little insects under there, there are monsters waiting to gobble you up
13:49:31 <forgottenone> Cale: funny :D
13:49:34 <pharpend> okay, what should I put in it
13:49:35 <Cale> pharpend: It's sort of unfortunate that .hs-boot files have to exist at all.
13:49:57 <Cale> The Haskell Report has always demanded that circular module dependencies are just possible.
13:50:10 <pharpend> http://learnyousomeerlang.com/static/img/circular-dependencies.png
13:50:30 <chrisdone> heh
13:50:46 <chrisdone> i don't like circular dependencies either
13:51:55 <pharpend>    1 {-# LANGUAGE RankNTypes #-}
13:51:57 <pharpend>    2 module Lambdabot.Monad where
13:51:59 <pharpend>    3
13:52:01 <pharpend>    4 data LB a
13:52:03 <pharpend>    5 instance Monad LB
13:52:04 <chrisdone> stawp
13:52:05 <pharpend> Cale: ^
13:52:17 <pharpend> I thought pastespam was okay if it was <= 5 lines
13:52:43 <chrisdone> well it took 10 seconds to appear so i had no idea if it was ever going to stop =)
13:52:53 <pharpend> ah
13:53:07 <forgottenone> Cale why did i sense that best fac functions are the ones from newbies
13:53:16 <Cale> pharpend: Yeah, try changing that to newtype LB a
13:53:29 <Cale> forgottenone: That's sort of the joke
13:54:26 <pharpend> forgottenone: You would like https://www.gnu.org/fun/jokes/helloworld.html
13:54:28 <Cale> forgottenone: Many of the more complicated ones are largely from papers which used factorial as an example of some more general recursion scheme or approach to decomposing programs
13:54:30 <forgottenone> Cale: yeah i know, just kidding :D
13:54:49 <Cale> forgottenone: check out the Tenured Professor one at the end though :D
13:54:54 <Cale> It's probably the best of all
13:55:36 <forgottenone> lol i didn't even see it at first glance
13:56:12 <pharpend> Cale: http://ix.io/2gr
13:56:38 <Cale> wait, did you write  newtype LB a = LB a ?
13:56:42 <pharpend> yes
13:56:48 <pharpend> newtype LB gave me another error
13:56:52 <Cale> That's not what I said to write, was it?
13:57:08 <Cale> What does "newtype LB a" get you
13:57:09 <Cale> ?
13:57:20 <pharpend> that gave me a different error, one sec
13:57:37 <pharpend> http://ix.io/2gw
13:57:52 <Cale> oh, okay
13:58:05 <Cale> If it's going to complain like that, just copy the whole declaration over from the .hs file
13:58:11 <pharpend> okay
13:58:57 <pharpend> http://ix.io/2gx
13:59:17 <pharpend> alright, I believe I have to do some imports
14:00:47 <slyfox> Cale: hia! do you happen to admin lambdabot nowadays?
14:00:57 <pharpend> slyfox: int-e does
14:01:32 <forgottenone> thanks everybody for their help, good bye
14:01:33 <slyfox> pharpend: oh, i see. i wanted to have lambdabot on #haskell-by :)
14:01:57 <pharpend> slyfox: I'm currently trying to build a clone.
14:02:08 <pharpend> Cale: http://ix.io/2gz
14:02:24 <eXeC64> I just read SPJ's 1993 paper, imperative functional programming. What's a good next step on reading material? I'm a beginning haskeller who'd like a good grasp of the maths.
14:03:50 <ReinH> eXeC64: what would you like to learn more about?
14:03:52 <Cale> pharpend: Right, that's going to be fun, so if IRCRState and IRCRWState are declared in the same module, you'll have to move their declarations into the hs-boot now...
14:04:02 <Cale> pharpend: I wonder why this worked before and not now
14:04:02 <pharpend> heh
14:04:11 <Cale> s/move/copy/
14:04:19 <pharpend> I figured that out, Just givin you an update
14:04:27 <slyfox> there is a lambdabot fork on guthub. seemed to work last time i tried
14:04:59 <sivteck> @version
14:04:59 <lambdabot> lambdabot 5.0-int-e
14:04:59 <lambdabot> git clone git://github.com/int-e/lambdabot.git
14:05:05 <eXeC64> ReinH: I've been enjoying the type theory and algebra. Bit of category theory is nice too.
14:05:08 <Cale> eXeC64: like, how good a grasp of the maths? :)
14:05:13 <Cale> okay
14:05:22 <slyfox> @google lambdabot-4.3.0.1-ghc-7.8.patch
14:05:23 <lambdabot> https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/lambdabot/files/lambdabot-4.3.0.1-ghc-7.8.patch
14:05:26 <ReinH> eXeC64: Some books you might enjoy: reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
14:05:31 <ReinH> There are plenty of papers and things as well
14:05:32 <Cale> The usual book I recommend for category theory is Awodey's "Category Theory"
14:05:54 <eXeC64> Cale: I enjoy when the mathematics just click. Very satisfying when I get something.
14:06:05 <notdan> Basic Category Theory for Computer Scientists by B. Pierce is also a nice text
14:06:08 <pharpend> Cale: okay, cloned the new repo
14:06:18 <Cale> (sent you a link in privmsg)
14:06:26 <ReinH> I recommend Mac Lane and Birkhoff's "Algebra" and Awodey's "Category Theory"
14:07:00 <ReinH> Lawvere's Conceptual Mathematics is a very gentle introduction to CT that might be useful if you get stuck while reading Awodey
14:07:41 <Cale> eXeC64: You'll probably also like Benjamin Pierce's "Types and Programming Languages"
14:07:49 <ReinH> For type theory, Types and Programming Languages is...
14:07:54 <ReinH> Ok just listen to Cale
14:07:58 <Cale> haha
14:08:00 <notdan> everything by B. Pierce basically is good
14:08:02 <eXeC64> Cale: That does sound good
14:08:09 <ReinH> notdan: +1
14:08:11 <notdan> he is really good at writing clearly
14:09:03 <ReinH> (These and a few others are listed in my link as well)
14:09:37 <eXeC64> ReinH: Thanks
14:09:40 <eXeC64> bookmakred
14:10:32 <Denommus`> hm
14:11:18 <Denommus> do you think a front-end router (like ng-router or ui-router) using FRP on top of Haste + Reactive-banana would be possible/viable?
14:11:57 <ReinH> eXeC64: As far as papers, everything by Richard Bird, Graham Hutton, Jeremy Gibbons, Erik Meijer, Conor McBride, all of the Monad Readers...
14:12:20 <ReinH> Philip Wadler
14:13:17 <agocorona> better said: Monad Writers
14:14:59 <ReinH> agocorona: ?
14:15:15 <agocorona> Denommus: is a bad joke
14:15:49 <pharpend> Cale: got lambdabot compiled, this is happening - http://ix.io/2mc
14:15:51 <agocorona> Denommus: hplayground implement a front router in top of haskell
14:16:03 <agocorona> well not complete
14:16:16 <agocorona> on top of haste, sorry
14:16:16 <Denommus> agocorona: what is a bad joke?
14:16:42 <agocorona> they write monads, so they are monad writers. that is the bad joke
14:17:07 <vanila> > 76 + 48 + 32+79+3+2+13 + 42 + 22
14:17:08 <lambdabot>  317
14:17:09 <Cale> pharpend: In that case, I'd just remove the module, but I think that's likely an issue with the config for the module being truncated or something?
14:17:11 <vanila> that's a lot of papers
14:17:43 <averell> did you put the stuff from the State/ dir to the used state dir?
14:17:56 <pharpend> Cale: idk
14:18:32 <Denommus> agocorona: I was thinking more on the line of Arrows than Monads, actually
14:18:51 <Cale> pharpend: I'm not entirely sure, it's been a while since I ran lambdabot, and I never had exactly that issue. I don't think I ever had a problem with vixen, but I think I had a similar issue with something else.
14:19:07 <cads> hey guys is there a browser that uses haskell as its scripting engine?
14:19:21 <cads> if not I think there should be!
14:19:39 <pharpend> cads: I agree. Let us know how it went
14:19:47 <cads> I know, right?
14:19:56 <cads> it would be kind a difficult, I think
14:20:03 <pharpend> webkit is a royal PITA
14:20:04 <cads> the xmonad of browsers
14:20:08 <Denommus> cads: Chrome + PNaCl
14:20:11 <vanila> cads: There's a guy doing a browser engine in haskell
14:20:17 <vanila> could be a collab
14:20:20 <cads> nice
14:20:32 <pharpend> cads: read the title text https://xkcd.com/934/
14:20:41 <cads> there is something about haskell that makes me feel like it's not good for a scripting engine
14:20:47 <cads> it's too 'final'
14:20:48 <pharpend> really
14:20:53 <pharpend> have you ever tried xmonad
14:21:01 <pharpend> isn't the xmonad configuration wonderful and intuitive
14:21:04 <cads> I did
14:21:13 <cads> I never configged it
14:21:20 <Cale> pharpend: I can't tell whether or not that's sarcasm :D
14:21:27 <Cale> I love it
14:21:30 <cads> I switched to awesome, which uses a lua script to config the wm
14:21:38 <pharpend> actually, I could stand a browser that used nixlang for config
14:21:40 <cads> Cale, me neither :)
14:21:45 <averell> i switched from awesome to xmonad
14:21:53 <pharpend> I'm on i3wm
14:21:54 <averell> no builtin taskbar is a definite step back
14:22:03 <Denommus> awesome's lua confused the hell out of me
14:22:07 <cads> well, I don't really care what FP language it uses, it could use a handful of them for all I mind
14:22:19 <pharpend> fay would be nice
14:22:24 <cads> I just want it to be a good home for fp dev
14:22:26 <pharpend> that would seem like the ideal browser language
14:22:35 <pharpend> chrisdone: care to chime in?
14:22:36 <Denommus> I spent some time using stumpwm, and it was friggin' great, I could connect to the wm's swank from Emacs and make changes in real time
14:22:48 <Denommus> but it felt heavy
14:23:04 <cads> I can't decide whether it should be more like a browser, or more like the clr or jvm, only with really great app hosting capabilities
14:23:10 <Cale> I would use xmonad if someone went to the trouble of making it look and function almost exactly like Metacity as a default. I can't stand tiling. I'm annoyed enough by features which cause my WM to tile windows automatically when I get them close to an edge.
14:23:21 <Denommus> ... wait, I'm using KDE now, why am I complaining that stumpwm is heavy?
14:23:34 <hpc> Cale: you mean snapping?
14:23:36 <Cale> yeah
14:23:46 <cads> as in, you can push complex apps to the haskell browser, and those apps can be both mobile and desktop based
14:23:49 <Cale> I turned snapping off in Cinnamon
14:24:01 <hpc> i like "sticky" snapping, but hate "magnetic" snapping
14:24:19 <hpc> see if you can configure it to hold a window in place instead of sucking it towards the edge
14:24:25 <cads> it would have what could be the first haskell and FP app store
14:24:33 <Denommus> I wish cabal-install had some progress bar for downloads
14:24:45 <Denommus> I have no idea if the download of happstack-server stopped or not
14:25:01 <Cale> I like when windows have a little bit of a "tactile" response when you push them against each other or the edge of the screen, like a few pixels where they'll stop.
14:25:06 <averell> i have a bandwith meter in my taffybar... :)
14:25:12 <Denommus> cads: everybody always wants an operating system made in <favorite programming language>
14:25:13 <hpc> yeah, that
14:25:24 <Cale> But not the thing which reshapes your window to fill half the screen exactly when you put it too close to an edge
14:25:33 <Denommus> cads: I just wanted a friggin' mobile operating system that lets me write applications in any language I want :-/
14:25:37 <cads> our browser is self hosting
14:25:50 <vanila> Denommus, isn't that just a problem of lacking compilers?
14:25:59 <cads> and other problems
14:26:03 <cads> like vendor lockins
14:26:08 <vanila> assuming the phone can be programmed in assembly or C or something
14:26:08 <Denommus> vanila: no, it's a problem that iOS and Android are designed around their respective languages
14:26:21 <vanila> oh yes, the anti-user DRM stuff
14:26:34 <cads> vanila, you can absolutely morph android to more of a debian flavor
14:26:35 <Denommus> I don't want to program a whole OS from scratch, I'm not crazy
14:26:39 <Denommus> I just want an existing one
14:26:44 <Denommus> I guess it's possible to do that in Sailfish
14:27:43 <cads> android basically needs the command line with proper SUDO, and command line based package management, and it's happy
14:28:08 <cads> you can already setup a debootstrap and install debian packages
14:28:09 <averell> android command line is actually pretty common. and apkg exists
14:29:07 <cads> I can't for the life of me understand why someone hasn't already written a super smart predictive bash app that lets you pick likely command completions from your history
14:29:18 <cads> though that could be majorly dangerous
14:29:37 <Denommus> cads: isn't fish trying to do something like that?
14:30:20 <cads> I think the main reason the commandline doesn't exist with standard android is first that android is trying to be something other than a general purpose pc, so it hides the command line
14:30:47 <cads> and, I suspect, that the user-experience of a touchpad based console emulator is just absolutely horrible
14:30:47 <Denommus> Android even hides the file system, dude
14:30:51 <hpc> bash completion is a pretty ugly beast
14:31:00 <hpc> i wouldn't want to be the one to code it
14:31:31 <agocorona> Denommus:  cordova
14:31:51 <cads> hpc, why can't we through a markov chain at it and use touch to scroll through colorful boxes of context tailored command pieces?
14:32:19 <Denommus> agocorona: this is for JavaScript, isn't it?
14:32:50 <averell> is there any desktop UI toolkit that has proper mobile support?
14:33:08 <mietek> http://178.62.236.52 — is that a streaming Cabal build log...?
14:33:11 <cads> I figure if you analyze enough commandline text you can learn a lot about what someone is doing just by analyzing the syntaxtic content of their command stream so far
14:33:12 <Denommus> averell: Qt
14:34:14 <cads> vanila, is this the browser ? https://github.com/k0ral/hbro
14:35:20 <vanila> http://hrothen.github.io/ this is the one I knew about
14:42:05 <chrisdone> someone should do an experiment of filling programmers separated into sets of haskellers and pythoners with beer over an evening
14:42:34 <chrisdone> i would expect the haskellers not to have a finished product, but what is there works
14:42:44 <chrisdone> and the pythoners to have a near-finished product which does not work
14:42:46 <cads> A web browser is not a {window|bookmarks|history|download|passwords|package} manager, let alone an operating system. A web browser retrieves, renders and traverses web pages, period.
14:42:58 <cads> - from the hbro docs
14:43:04 <cads> well dayum
14:43:18 <hpc> browser is love
14:43:20 <hpc> browser is life
14:43:23 <Denommus> cads: nowadays that's just a rendering engine
14:43:36 <butyoudonot> package manager browser sounds usable
14:43:43 <SvenskFisk> Hey guys, I'm working on problem #15 on Project Euler (https://projecteuler.net/problem=15), my code (http://lpaste.net/116333) generates a tree that represents all the paths that could be taken, but I'm having trouble figuring out how I could figure out how many paths were taken from that. In Python I'd just initialize a global to 0, and increment it every time the function reaches the end, but obviou
14:43:43 <chrisdone> i think the essence of the modern browser is a safe sandbox for running programs
14:43:49 <SvenskFisk> sly that won't work here. Is there a simple way to either keep track of how many times the destination has been reached, or somehow write a function that takes the tree and returns how many paths were taken?
14:44:19 <cads> chrisdone, any component you add could be formally verified
14:44:36 <chrisdone> no other system has ever implemented such a trivial automatically downloaded and sandboxed running of programs in a popular setting like browsers have
14:44:39 <cads> or the framework coordinating the components can be
14:44:42 <cads> the "shim code"
14:44:43 <hpc> it's not that safe though :P
14:44:57 <chrisdone> hpc: do you disable javascript when you browse the web?
14:45:00 <hpc> browsers have raised everything up a level, protecting nothing
14:45:07 <hpc> i do, many do not
14:45:13 <chrisdone> many = everyone
14:45:19 <hpc> yeah
14:45:29 <chrisdone> https://www.youtube.com/watch?v=74BzSTQCl_c
14:45:37 <cads> hpc, you're part of, like, a nowhere dense subset of humanity
14:45:52 <hpc> chrisdone: :D
14:45:59 <chrisdone> =p
14:47:59 <cads> chrisdone, I wish the modern browser also interpreted, judged, and altered the content it executes
14:48:25 <hpc> SvenskFisk: you'd figure this out anyway, but a 20x20 grid has too many paths to brute-force the way you plan to
14:48:34 <geekosaur> firefox tried that, iirc
14:48:49 <geekosaur> btu the web's kinda useless when nothing renders >.>
14:49:10 <cads> well, like take an adblocker
14:49:20 <vanila> web grew too complex, so it's time to create a simpler standard for information interchange
14:49:31 <hpc> vanila: JSON!
14:49:39 <cads> it actually increases the user's security and is all around good for the user 99% of hte time
14:49:50 <vanila> JSON is just a data format but that would be fine to use, or s-expressions or XML or something else
14:50:05 <cads> I like json
14:50:20 <cads> also it looks like javascript has become the assembly language of the web
14:50:37 <vanila> yeah a virtual machine byte code should replcae javascript
14:50:38 <cads> or maybe its 'c'.
14:50:39 <hpc> SvenskFisk: a little bit of a hint, the answer is still going to be recursive, but you can calculate the number of options by what depth you are at
14:50:47 <vanila> then compilers will be able to target it more efficiently
14:50:52 <hpc> which prevents a lot of repetitive path calculation
14:50:55 <chrisdone> remember Wadler: So the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:51:03 <geekosaur> java was tried >.>
14:51:32 <cads> vanila, that's currently not nearly as crazy as it sounded ten years ago
14:51:34 <chrisdone> cads: i think C is a more accurate comparison
14:51:56 <cads> yeah, I meant C
14:52:16 <vanila> techniques like proof carrying code could be useful to make this secure
14:52:20 <cads> locked in by the market :)
14:52:20 <chrisdone> i think that's where java was done wrong
14:52:20 <hpc> SvenskFisk: (or you can think a bit harder and solve it algebraically, which is more in line with how PE problems are best solved at higher levels)
14:52:23 <chrisdone> applets were a dumb idea
14:52:32 <chrisdone> it should've been java manipulating the dom
14:52:47 <SvenskFisk> hpc: Yeah you're right, it takes a really long time doing 20x20. I'll see if I can do it algebraically, thanks for the help
14:52:58 <chrisdone> but, i'm not sure whether i would've preferred java or javascript
14:53:02 <vanila> java is extremely successful
14:53:11 <cads> vanila, I was thinking of PCC and also hoping for homomorphic encryption
14:53:18 <cads> is that the right term?
14:53:30 <vanila> I don't think you would want homomorphic encryption
14:53:54 <vanila> im not suggesting bytecode in order to obfuscate or hide the computations being done
14:54:06 <chrisdone> that's often touted as one of the reasons javascript succeeds
14:54:13 <chrisdone> because you can just read the plain source code
14:54:17 <hpc> is homomorphic encryption even practical for machine code yet?
14:54:30 <cads> no the last I read it runs hundreds of times slower
14:54:31 <hpc> last i heard, they barely have ring operations working smoothly
14:55:05 <chrisdone> homomorphic encryption is a hot research topic, but not much of practical use
14:55:13 <vanila> the most important thing is to have a web standard that can be implemented in a few weeks by a team of 3 or 4 people
14:55:14 <cads> I think it will find applications
14:55:26 <chrisdone> ime researchers try to find subsets of it for specific tasks
14:55:27 <hpc> malware applications, most likely
14:55:33 <cads> since vendors want to push data for clients to use and then throw away, without actually seeing the data
14:55:33 <vanila> currently it's only possible to implement a web browser if you are a world power, literally.. like microsoft, apple,..
14:55:37 <cojy> yea but the source code thing is gone with the the pervasive minification, and back again with sourcemaps, which can solve the problem for bytecode too
14:56:05 <vanila> this harms freedom, because any choices that the implementors make we are stuck with
14:56:12 <silasm_> vanila: and even the browsers developed by world powers at best implement ~75% of what is actually expected in terms of standards.
14:56:18 <monochrom> world powers will see to it that no web standard can be implemented in a few weeks by a team of 3 or 4 people.
14:56:27 <chrisdone> cojy: i think part of the gain of visible source is that as a newbie you can just view some page's source code and learn from it
14:56:34 <silasm_> the web is a terrifying place if you learn a thing or two about it.
14:56:41 <cads> I mean, can a team of people develop some good standards?
14:56:43 <chrisdone> cojy: this is not the case with byte-code, and source maps are a development-only initiative
14:56:54 <cads> and really the standards can be opened up to the community
14:57:11 <silasm_> (and I'm not even talking about the content, which is usually even worse)
14:57:11 <monochrom> the web is just a manifestation of human nature. humanity is the terrifying place.
14:57:36 <chrisdone> monochrom: unless the web is really a conspiracy project by aliens
14:57:52 <monochrom> oh, but if you're into that, humanity is too :)
14:57:55 <chrisdone> http://i.lvme.me/5o4mnkx.jpg
14:58:31 <cads> I would like to be able to see some kind of self entitled secure autonomous process, that can jump from system to system, doing things that only people with the right keys can understand.
14:59:20 <cads> but I have no idea how you'd work with an encrypted computing state
14:59:25 <chrisdone> that's the weird thing about web logins. whoever thought of doing a web form for a login should've been slapped on the head
14:59:51 <chrisdone> public keys authentication is where it's at
15:00:16 <averell> maybe if you have the proper implants
15:00:19 <chrisdone> i should type a password when i login to my computer and then ssh-agent manages the rest
15:01:03 <hpc> i just use the password "12345" everywhere
15:01:16 <vanila> you should use a more secure password like 123456
15:01:18 <averell> that's good, numbers are more secure than letters
15:01:53 <chrisdone> use 123645
15:01:54 <monochrom> Lt. Cmd. Data had the longest numeric password :)
15:01:56 <exio4> I would go for 123543
15:01:56 <chrisdone> that'll confuse the crackers!
15:02:21 <chrisdone> monochrom: when he impersonated Picard?
15:02:33 <monochrom> no. something else.
15:02:52 <monochrom> or rather, I don't actually know, I only saw a clip on youtube without context.
15:03:18 <hpc> https://www.youtube.com/watch?v=IPphyjkXnPc
15:03:29 <monochrom> yeah, that :)
15:04:20 <chrisdone> it seems that detecting piccard's voice is about as hard as that password =p
15:04:53 <chrisdone> how advanced is voice recognition these days? could it discern picard like that? securely? for control of a massive spaceship?
15:05:16 <KangaAkale> hello Team
15:05:42 <KangaAkale> please how can i handle exception in this http://lpaste.net/6706578002341265408
15:06:18 <Zekka> @hoogle catchError
15:06:19 <lambdabot> Control.Monad.Trans.Error catchError :: (Monad m, Error e) => ErrorT e m a -> (e -> ErrorT e m a) -> ErrorT e m a
15:06:19 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
15:06:19 <lambdabot> Control.Monad.Error catchError :: MonadError e m => m a -> (e -> m a) -> m a
15:06:32 <Zekka> Is there a version for IO? I should really know this
15:06:53 <Zekka> It looks like IO is a MonadError for IOException
15:07:58 <chrisdone> Zekka: "catch"?
15:08:04 <chrisdone> :t catch
15:08:05 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
15:08:10 <Zekka> chrisdone: That looks right!
15:08:15 <chrisdone> IOException is an instance of Exception
15:09:49 <KangaAkale> hello team
15:10:07 <KangaAkale> please how can i handle exception in this http://lpaste.net/6706578002341265408
15:10:08 <Axman6> hello, again
15:10:13 <Axman6> we've already told you
15:10:15 <Zekka> KangaAkale: We already replied to you, look up
15:10:56 <Zekka> If you have mtl you can use the version I found -- otherwise you can use chrisdone's
15:11:31 <Axman6> unless ErrorT is alreay being used, catchError isn't really a great suggestion.
15:11:49 <Zekka> Axman6: mtl provides MonadError for IO
15:12:02 <Zekka> It's not *necessary* but probably still works
15:15:21 <magicman> So... the consensus is "If you want to use Data.Array, use Data.Vector instead", right?
15:15:30 <ReinH> magicman: I don't think so?
15:16:11 <ReinH> Maybe you want Data.Array, maybe you want Data.Vector, maybe you want Data.Map, maybe you just want [] or Sequence. It depends on the use.
15:16:22 <monochrom> my consensus is "choose based on your task". but it's only me.
15:16:24 <Axman6> magicman: depends on what your needs are. if you need flexible indexing types, then Array is a better choice
15:17:04 * hackagebot diversity 0.3.4.1 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.3.4.1 (GregorySchwartz)
15:17:31 <Axman6> so, if you need to be able to define an array which is indexed by data RGB = Red | Green | Blue and Bool, then using Array will let you do that without effort
15:17:52 <magicman> Ahh, okay.
15:18:51 <magicman> So I'm starting with a sorted numbers :: [Integer], and now I want to find the greatest i such that numbers !! i < x, for quite a lot of x's.
15:19:12 <chrisdone> monochrom: i guess that's just a 'sensus' ;)
15:19:27 <ph88> hey guys, i try to get type of  >>= in ghci, but i get a parse error, is that normal ?
15:19:29 <ocharles> https://www.irccloud.com/pastebin/XkgJr7hh can anyone see how cabal is freaking out here?
15:19:33 <ph88> :t >>=
15:19:34 <lambdabot> parse error on input ‘>>=’
15:19:37 <ReinH> magicman: A list could do that well enough, I think.
15:19:39 <magicman> I can do that O(n) per x, but that sucks. So I'll incur a one-time O(n)-cost for conversion to Array or Vector, and then do lots of binary-search.
15:19:44 <Axman6> :t (>>=)
15:19:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:19:49 <Axman6> ph88: ^^
15:19:52 <ph88> i tried that too !
15:20:01 <ph88> oh no i didnt sorry
15:20:02 <Axman6> well, that definitely works in ghci too
15:20:02 <ReinH> You can do it in O(n) once if you sort xs first.
15:20:08 <ph88> i tried `>>=`
15:20:33 <monochrom> :t (`fmap`)
15:20:34 <lambdabot> parse error on input ‘)’
15:20:43 * monochrom thinks
15:21:00 <shachaf> monochrom: I've complained about this before.
15:21:00 <ReinH> monochrom: You can't convert `` infix notation back to an expression.
15:21:09 <shachaf> I think (`foo`) should work.
15:21:12 <magicman> Assume a sorted list of length n, and m points to check. With using linear search, it's O(n*m), Array/Vector and binary search is O(n + m*log n), IIRC.
15:21:12 <monochrom> heh, too bad
15:21:14 <ReinH> I don't believe so.
15:21:16 <ph88> i see >>= has some similarities to mapM .. for example they both seem to work on Monads
15:21:24 <ReinH> I remember checking this in the grammar.
15:21:29 <shachaf> By "should" I mean that the Report should be modified to make it work.
15:21:34 <ReinH> shachaf: Ah.
15:21:41 <shachaf> It's the right thing to do.
15:21:50 <ReinH> As in ought to work. Sure.
15:21:52 <Axman6> ph88: right, that's kind of the point =)
15:21:56 <Axman6> :t mapM
15:21:57 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:22:23 <Zekka> ph88: Are you looking for a monad explanation?
15:22:23 <ReinH> ph88: Compare ($) to (=<<) and map to mapM
15:22:32 <ReinH> :t map
15:22:33 <lambdabot> (a -> b) -> [a] -> [b]
15:22:34 <ReinH> :t mapM
15:22:35 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:22:42 <magicman> I can't pre-sort the points to check, as they're ordered in a specific way, which I'd like to keep.
15:22:49 <Zekka> Because if you understand functors and/or applicatives they're not too hard
15:23:07 <ReinH> magicman: then zip with [0..] first and you can recover their position later
15:23:23 <Axman6> beat me to it
15:23:27 <magicman> Ah, right.
15:23:31 <ph88> i still have the some text i have to read about monads, and im trying some functions
15:25:24 <Axman6> > mapM (\x -> [x,x]) [1,2,3]
15:25:26 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
15:25:53 <Axman6> hmm, that's an awful example
15:25:59 <ReinH> Agreed.
15:26:00 <Axman6> > mapM (\x -> [x,10*x]) [1,2,3]
15:26:01 <lambdabot>  [[1,2,3],[1,2,30],[1,20,3],[1,20,30],[10,2,3],[10,2,30],[10,20,3],[10,20,30]]
15:26:43 <ReinH> > mapM print [1,2,3]
15:26:45 <lambdabot>  <IO [()]>
15:26:51 <Zekka> (compare to:)
15:26:55 <Zekka> > map print [1, 2, 3]
15:26:56 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
15:27:12 <ph88> is there a shorthand notation in ghci to see a function body ?
15:27:17 <monochrom> no
15:27:40 <Zekka> ph88: Lambdabot provides @src, which returns a pedagogically-useful representation of a function's source code
15:27:43 <Zekka> @src mapM
15:27:44 <lambdabot> mapM f as = sequence (map f as)
15:27:52 <Zekka> @src sequence
15:27:52 <lambdabot> sequence []     = return []
15:27:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:27:53 <lambdabot> --OR
15:27:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:28:03 <Hafydd> For some limited number of functions.
15:28:19 <ph88> cool
15:28:20 <Zekka> So mapM will take a list of monadic actions and turn it intoa monadic action of the list of their results
15:28:34 <Zekka> :t sequence
15:28:35 <lambdabot> Monad m => [m a] -> m [a]
15:28:37 <Axman6> I'm sure I'm not the only person who'd like a tail recursive mapM
15:28:55 <shachaf> Axman6: How sure?
15:29:07 <Axman6> completely
15:29:14 <monochrom> what does "tail recursive mapM" mean?
15:29:22 <shachaf> That would be my next question.
15:30:42 <Axman6> mapM' f xs = go xs [] where go [] rs =  return $ reverse rs; go (x:xs) rs = f x >>= \y -> go xs (y:rs)
15:31:17 <monochrom> I think it means: to save Θ(n) stack space, spend instead Θ(n) heap space.
15:31:27 <Axman6> right
15:31:38 <monochrom> seeing that GHC "stack" is growable and, in fact, a subset of GHC heap...
15:31:39 <ReinH> That is not tail recursive though
15:31:41 <Axman6> but now I think about it it may not be particularly useful anyway
15:31:42 <mmmm> Are there any packages which provide concurrent priority queues?
15:31:58 <monochrom> I am sure that this is saying that you desire a placebo.
15:32:02 <ph88> this is probably gonna sound really stupid but ... is a monad always a function ?
15:32:05 * hackagebot hasql-postgres 0.8.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.8.0 (NikitaVolkov)
15:32:09 <Axman6> yes
15:32:19 <Zekka> ph88: It's not a function on values
15:32:25 <ReinH> ph88: depends on what you mean by "a monad"
15:32:30 <ReinH> Zekka: what? All functions are 'on values'.
15:32:38 <Zekka> A capital-m Monad is a kind of type that takes a type argument.
15:32:42 <Zekka> ReinH: * -> *
15:32:48 <ReinH> Is not a function.
15:32:56 <Axman6> ph88: monads are just things which you can define return and bind (or return and join along with fmap)
15:33:06 <Zekka> ReinH: I figured Axman6 was going to try to bring * -> * in to be pedantic
15:33:09 <shachaf> It's a type function, or at least that's not an unreasonable thing to call it.
15:33:10 <Zekka> and I wanted to head him off at the pass
15:33:20 <Axman6> Zekka: why me? :o
15:33:27 <Zekka> Axman6: Because you said yes to his question!
15:33:42 <shachaf> But that's probably not what ph88 meant. But you never know, so the best thing is to ask them what they meant, rather than guess.
15:33:51 <Axman6> oh, my yes was to a different comment, not ph88's
15:33:56 <ph88> Axman6: one thing i found with haskell is that lot of definitions can be explained as yet another set of definitions, which eventually seem to circle back to the first one.
15:34:20 <Zekka> ph88: It's the same as in math!
15:34:22 <ReinH> Haskell supports mutual recursion, yes ;)
15:34:51 <Axman6> ph88: I found this quite a good explanation of what the monad pattern is: http://codon.com/refactoring-ruby-with-monads
15:35:03 <ph88> thx
15:35:05 <Zekka> A monad is a type that takes another type as an argument (so, a type-level function to phrase it like shachaf did) that supports some extra operations
15:35:12 <Axman6> it doesn't use Haskell to explain it, which might be helpful
15:35:13 <shachaf> oh boy, full #haskell ahead
15:35:14 <ReinH> shachaf: if we're expanding the definition of function to take in type constructors of kind k -> j, let's also expand it to take in values of type a. ;)
15:35:17 <silasm_> they're burritos, right? :)
15:35:20 <Zekka> That's not very helpful right off the cuff but it at least puts you in the right domain
15:35:33 <shachaf> ReinH: A function is a thing :: a -> b for some a and b
15:35:35 <Zekka> (namely it doesn't tell you why we like those operations or what a monad is intuitively similar to)
15:35:52 <ReinH> where a and b are types, not kinds.
15:35:58 <shachaf> ReinH: But as much as you enjoy that argument, I don't, so let's don't.
15:36:10 <Zekka> Ooh, is (Profunctor p => p a b) a function?
15:36:43 <Axman6> Zekka: I believe it can be, but it can also be other things
15:36:56 <ph88> Axman6: nice article so far, especially "pragmatic" resonates here ^^
15:36:58 <Zekka> Axman6: I probably shouldn't invite the entertaining ppedantry
15:36:59 <ReinH> A function is a profunction. A profunctor is not a function.
15:37:00 <monochrom> (Profunctor p => p a b) looks like a type. is a type a function?
15:37:03 <ReinH> *profunctor
15:37:05 * hackagebot semi-iso 1.0.0.0 - Weakened partial isomorphisms, reversible computations.  http://hackage.haskell.org/package/semi-iso-1.0.0.0 (pawel834)
15:37:07 * hackagebot syntax 1.0.0.0 - Reversible parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-1.0.0.0 (pawel834)
15:37:09 * hackagebot syntax-attoparsec 1.0.0.0 - Syntax instances for Attoparsec.  http://hackage.haskell.org/package/syntax-attoparsec-1.0.0.0 (pawel834)
15:37:11 * hackagebot syntax-printer 1.0.0.0 - Text and ByteString printers for 'syntax'.  http://hackage.haskell.org/package/syntax-printer-1.0.0.0 (pawel834)
15:37:16 <Zekka> monochrom: Oh, the humanity!
15:37:17 <shachaf> Axman6: That Ruby thing seems to make the usual mistakes.
15:37:29 <Zekka> (fine, put a thing :: next to it)
15:37:54 <Axman6> shachaf: it's not perfect, but it's not bad at showing that the idea is quite simple and applicable to many different types
15:38:12 <Zekka> Operative intuition -- it specializes to (a -> b), but it specializes to things not taking the form (a -> b)
15:38:19 <monochrom> so it comes down to: if type p is an instance of Profunctor, is p a function type?
15:39:23 <monochrom> I don't know all of Profunctor's instances to answer that. but if you find a non-(->) instance, then you don't always have a function.
15:39:28 <Zekka> monochrom: p isn't a specific type -- it's more like thing :: forall p. Profunctor p => p a b
15:39:46 <Zekka> but if you already understood this and I misunderstood you then that was superfluous
15:39:48 <Axman6> Kleisli?
15:39:53 <shachaf> Axman6: I think it probably does more harm than good.
15:40:08 <Axman6> shachaf: why?
15:40:23 <shachaf> Zekka: Oh, then easy, that type is uninhabited.
15:40:27 <ReinH> Axman6: a newtype for functions of type a -> m b, a.k.a. "Kleisli arrows"
15:40:33 <Zekka> shachaf: Very practical.
15:40:36 <monochrom> then I don't know.
15:41:04 <shachaf> People should really learn about => vs. *> rather than just always say => whenever a type class is involved.
15:41:18 <shachaf> People should also learn about existentials.
15:41:28 <Axman6> ReinH: right, I was using it ac an example of a profunctor, but I must be tired because I forgot it's clearly also a function type
15:41:35 <hpc> that's a thing now?
15:41:38 <monochrom> err, what is *> ?
15:42:05 * hackagebot syntax-example 1.0.0.0 - Example application using syntax, a library for abstract syntax descriptions.  http://hackage.haskell.org/package/syntax-example-1.0.0.0 (pawel834)
15:42:07 * hackagebot syntax-example-json 1.0.0.0 - Example JSON parser/pretty-printer.  http://hackage.haskell.org/package/syntax-example-json-1.0.0.0 (pawel834)
15:42:09 * hackagebot sci-ratio 0.2.1.0 - Rational numbers in scientific notation.  http://hackage.haskell.org/package/sci-ratio-0.2.1.0 (Rufflewind)
15:42:29 <monochrom> but I agree about careful writing.
15:42:50 <Zekka> Axman6: data NotAFunction c a b = NotAFunction (a -> c) (c -> b) is a profunctor if you want one that's not a function type
15:42:55 <shachaf> monochrom: The dual to =>, like exists is dual to forall.
15:43:09 <shachaf> monochrom: E.g. (exists a. Show a *> a)
15:43:18 <ReinH> Many instances of Profunctor are some sort of function, but newtype Tagged s b = Tagged b is also a Profunctor
15:43:25 <ReinH> Axman6: ^
15:43:37 <shachaf> monochrom: People will say things like "I give you (Show a => a), and you can do ... with it", but that makes no sense.
15:43:54 <shachaf> If I give you (Show a => a), that means I demand a Show instance from you.
15:44:06 <shachaf> People write things like (exists a. Show a => a), too.
15:44:22 <monochrom> it icks me that some calculus students write like "x^2 = 2x -> x+x". they mean "the derivative of x^2 is 2x; 2x equals x+x". it icks me because the general trend is "use = for anything but equality, use anything but = for equality".
15:44:57 <hpc> ew
15:45:01 <shachaf> Yes, I don't understand that trend.
15:45:11 <Axman6> that's a strange trend
15:45:12 <ReinH> monochrom: Oh the humanity
15:45:22 <monochrom> it's like young people really like to be rebellious.
15:45:29 <hpc> i think how well someone can figure out the chain rule might be a good early test for programming skill
15:45:33 <josephle> they just need a d/dx in front
15:45:40 <hpc> because it's usually the first bit of recursion someone will encounter in a math class
15:46:13 <monochrom> yes, I like that very much, too
15:46:21 <Axman6> monochrom: clearly what they're really trying to say is x = 2
15:46:42 <hpc> maybe they mean \2 x -> x + x
15:47:13 <shachaf> monochrom: "=" is read as "is". There's an implicit "the derivative of" at the beginning of the sentence.
15:47:24 <shachaf> "[the derivative of] x^2 [is] 2x"
15:47:39 <hpc> shachaf: i don't think students are so sophisticated :P
15:47:57 <hpc> and that level of quietly leaving things out is pushing it even for mathematicians
15:48:16 <Zekka> It's harder to justify stuff like that when right adjacent you're probably doing algebra on equations where you really mean for = to mean 'equals'
15:48:19 <shachaf> Just like "x^2 + x + 1 = O(x^2)"
15:48:21 <Zekka> right adjacent to that*
15:48:22 <monochrom> you haven't explained "2x -> x+x"
15:48:35 <josephle> ok, that's just silly
15:48:37 <pharpend> Does lambdabot have something like !seen
15:48:39 <pharpend> ?
15:48:45 <shachaf> monochrom: It's a rewriting system, obviously.
15:48:50 <ReinH> monochrom: Well they had already used = to mean something other than "equals". It's only logical.
15:48:57 <shachaf> I don't know. I don't particularly want to be put in the position of defending this practice.
15:48:58 <monochrom> heh
15:49:25 <monochrom> no, the current lambdabot doesn't do !seen
15:49:28 <monochrom> !seen monochrom
15:49:30 <Axman6> pharpend: it used to, it leaked memory so it was removed. there was another bot that had it
15:49:32 <ReinH> monochrom: The irony is that it would make slightly more sense if it were written x^2 -> 2x = x+x
15:49:33 <hpc> preflex did
15:49:35 <shachaf> ciao
15:49:36 <shachaf> !list
15:49:36 <monochrom> shachaf: http://lpaste.net/browse
15:49:38 <ReinH> Which is to say, still not very much sense at all
15:49:40 <Axman6> that's the one
15:49:51 <Axman6> what happened to preflex
15:49:53 <Zekka> ReinH: I'm guilty of using similar delimiters to that in alternative to newlines
15:50:15 <shachaf> I think this is a bit off-topic at this point.
15:50:16 <pharpend> Axman6: supybots have it
15:50:33 <Axman6> I don't know what that is
15:50:42 <pharpend> the type of bot you see in most channels
15:50:49 <pharpend> responds to !command
15:50:53 <pharpend> has !tell x <something>
15:50:59 <pharpend> oh speaking of which
15:51:03 <Axman6> right, lambdabot has that
15:51:11 <pharpend> yes, I know
15:51:29 <pharpend> Axman6: what channels are you in beyond the Haskell channels?
15:51:53 <ReinH> pharpend: /whois will tell you that
15:51:59 <Axman6> you can easily check with /whois
15:52:00 <pharpend> oh, thanks ReinH
15:52:05 * hackagebot pointed 4.1.1 - Pointed and copointed data  http://hackage.haskell.org/package/pointed-4.1.1 (EricMertens)
15:52:40 <stephen_> Should I use a makefile for my package, or does cabal build; cabal install work as well as anything?
15:52:42 <pharpend> Axman6: well, it will tell me what channels we have in common
15:52:59 <pharpend> stephen_: I don't use makefiles, sometimes I will write a shell script around cabal though
15:53:06 <Axman6> I thought it told you all
15:53:07 <monochrom> shachaf: I think we have to take the concession that neither "exists" nor "*>" is Haskell syntax. but I agree that if one is writing the pseudocode "exists ..." then may as well be accurate and continue with "*>"
15:53:14 <Enigmagic> Axman6: depends on the channel mode
15:53:33 <shachaf> monochrom: I don't mind e.g. "I give you an A, where A is an instance of Show".
15:54:17 <shachaf> monochrom: But I mind "I give you a (Show a => a)".
15:54:23 <shachaf> English is fine.
15:56:44 <thang1> Hmm. Question related to what you're saying, monochrom: What exactly does "*>" mean, then? 'exists' is fairly self explanatory, but do you mean that "*>" is a synonom for it, or what?
15:57:15 <shachaf> It's like "data k *> a = k => Foo a"
15:58:25 <thang1> ooh, so it's placed before the type signature then?
16:02:15 <shachaf> If *> existed, then these would mean the same thing: "forall a. Show a => a -> String"; "forall a. (Show a *> a) -> String"
16:02:24 <shachaf> And also "(exists a. Show a *> a) -> String"
16:04:03 <stephen_> pharpend: do you have an example I could refer to?
16:06:20 <thang1> Interesting
16:06:35 <thang1> Haven't seen the *> syntax used before, which is why it threw me off
16:06:43 <shachaf> It's not real syntax. I think ski made it up.
16:06:49 <shachaf> I don't care about the syntax, but the concept is important.
16:06:55 <thang1> Either that or it's part of the lens library
16:06:57 <shachaf> => is like a function. *> is like a tuple.
16:07:15 <thang1> they probably use every single darn symbol on the ISO standard keyboard
16:08:47 <pharpend> shachaf: sure, one second
16:09:02 <shachaf> Huh?
16:09:13 <pharpend> stephen_: https://github.com/pharpend/puffytools/blob/develop/ptkbuild
16:09:57 <pharpend> ack
16:10:01 <pharpend> sorry shachaf i meant stephen_
16:10:42 <tolt> Is there a good stack implementation?
16:10:55 <tolt> I can't seem to find one.
16:11:51 <shachaf> What would you want it to do?
16:12:17 <tolt> A pure stack implementation
16:12:59 <shachaf> What would you want it to do?
16:13:03 <nkar> tolt: the state monad?
16:14:15 <tolt> I'm looking for something that has Stack a and then operations like push :: Stack a -> a -> Stack a, pop :: Stack a -> Maybe a
16:15:34 <stephen_> pharpend: Thanks! Also, you could just use shift,and ( while $# > 0 ) around your case statement to tidy things up.
16:16:25 <thang1> But why? Manually using a stack is usually something more low level languages do. I don't even know if there's a true "immutable" type of stack
16:17:08 <shachaf> tolt: OK, then maybe [] is the type you want.
16:17:10 <silasm_> tolt: from what you've said, you want `flip (:)' and listToMaybe. If you also want the stack to shrink when you pop you need to return the shrunk list in some fashion, e.g. using a state monad.
16:17:14 <kadoban> Can't you just trivially implement one on top of [] ?
16:17:20 <thang1> A stack can be thought of as a type of data structure... So it has to be mutable for any real performance, especially at the low level. I can't think of any reason to need to manipulate a stack manually in haskell off the top of my head...
16:17:25 <shachaf> tolt: cons is push, uncons is pop
16:17:38 <shachaf> Or what silasm_ said.
16:17:59 <pharpend> stephen_: if you have any ideas for improvement, feel free to PR =)
16:18:22 <kadoban> thang1: ? That sounds like you're saying that immutable data structures are useless?
16:18:37 <thang1> Pfh, of coure they're not
16:19:08 <thang1> A stack is most often used to keep track of push/pop operations so you can imperatively go through a list of commands
16:19:15 <thang1> without having to keep EVERYTHING in working memory
16:20:00 <thang1> Manual management of memory/resources/items is something Haskell isn't designed for. And copying an entire stack every time you push/pop completely defeats the purpose of a stack (so it would have to be mutable)
16:20:13 <exio4> you don't copy the entire stack
16:20:27 <exio4> if you use lists, that is!
16:20:40 <kadoban> thang1: But a stack built on a [] seems like it works completely fine. I'm not understanding what's wrong with it.
16:20:51 <silasm_> basically, if you just want a FIFO data structure, you can just use a list, since it fits the bill. But when programmers from an imperative background ask for a pop operation, then they're probably going to assume it's stateful. And there's nothing wrong with that if it makes sense for your application.
16:21:01 <thang1> If the list is immutable, don't you have to make a copy of the list to change any of it?
16:21:09 <tolt> It's not that I don't know how to implement a stack, it's that I was wondering if there was something already written and profiled already.
16:21:10 <shachaf> silasm_: I think you don't mean FIFO. :-)
16:21:27 <thang1> Stacks are LIFO :p
16:21:31 <silasm_> shachaf: whoops, s/FIFO/LIFO/
16:22:00 <thang1> all good. It's "fifo" to our head because "the last thing I put in is the first thing on my mind which is the first thing I got out" so it messes me up too sometimes
16:22:34 <silasm_> tolt: the LYAH introduction to the State monad uses a very simple stack implementation as its example.
16:22:36 <kadoban> thang1: Pushing onto a stack takes O(1) time and O(1) memory. Popping from a stack takes O(1) time and O(1) memory. There's not even any copies involved really, are there?
16:22:48 <kadoban> (This is on a [] based one)
16:23:03 <thang1> There should be if you're not working with a mutable one?
16:23:32 <kadoban> thang1: ...where?
16:23:59 <tolt> silasm_: I'm not an inexperienced haskeller. I understand that I can make one and I know how to make one but I was wondering why there isn't a pure implementation. I could make a tree implementation but I don't do that because other tree implementations exist that have already been created.
16:24:41 <shachaf> A pure implementation of what?
16:24:54 <tolt> a stack
16:25:01 <exio4> that is a list
16:27:15 <nkar> tolt: as others have said, because it's trivial: the datatypes and functions are already there
16:27:56 <nkar> you just need to provide a type synonym
16:28:07 <silasm_> tolt: pop : [a] -> (Maybe a,[a]); pop [] = (Nothing,[]; pop (x:xs) = (Just x,xs)
16:28:21 <thang1> https://www.haskell.org/pipermail/haskell-cafe/2010-February/072895.html
16:28:56 <thang1> "When you call 'push' on a stack, you get a new stack with the new element... and the original stac is left un-touched"
16:29:15 <thang1> All data structures are immutable in haskell. Copies are always involved, even for stacks
16:29:41 <nkar> thang1: that's false
16:29:45 <silasm_> well, you could use an STArray or something, but then it wouldn't be immutable.
16:29:50 <nkar> take a look at mutable vectors
16:30:22 <Haskellfant> there is a new stack being created but everything but the first element refers to the same memory (afaik)
16:30:25 <thang1> mutable vectors are purposely built into the language if I remember correctly, though
16:30:28 <Haskellfant> so it doesn't really matter in this case
16:30:34 <exio4> you'd still have O(1) pop/push, because sharing
16:30:39 <Haskellfant> exactly
16:30:50 <thang1> Haskellfant: I'm pretty sure that's becaues of optimizations in GHC rather than how immutable structures behave in a theoretical perspective
16:31:00 <silasm_> and you'd basically be doing the same thing assembly does at that point; maintaining a "stack pointer" (index) to where you currently are in the "buffer" (STArray).
16:32:07 * hackagebot hashtables 1.2.0.1 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.2.0.1 (GregoryCollins)
16:32:46 <Haskellfant> thang1: well I'm not sure I would consider that some crazy optimization that only ghc does. if you prepend something to a list, the rest of the list is still the same so it stays immutable even from a theoretical perspective so it's only logical to let the new list refer to that instead of copying everything around
16:32:48 <chrisdone> tolt: i think what has happened here is a fairly regular occurance on #haskell. you asked if a module for something existed and instead of "no/don't know" you received the answer "you can basically do it with something else". at this point i'd cut your losses and go look though stackage
16:33:02 <chrisdone> tolt: er, hackage
16:33:18 <bernalex> so I wrote this tweet: https://twitter.com/skramlife/status/543563189066428416 and I'm wondering, why *isn't* this in prelude? has there been some big discussion about it?
16:33:49 <shachaf> chrisdone: I think that's kind of unfair.
16:34:13 <k00mi> :t bool -- bernalex
16:34:14 <lambdabot> a -> a -> Bool -> a
16:34:20 <chrisdone> then at least two people in #haskell feel ill-treated =)
16:34:29 <silasm_> tolt: I'm kind of confused though. I'm wondering what you're expecting out of an implementation for something as simple as a stack. If you want to have a library of functions for using it defined I don't really know what you're expecting beyond push and pop, and if you want it to comply to code used in other libraries you can't do any better than lists.
16:34:42 <bernalex> k00mi: I don't know what you are arguing.
16:34:46 <shachaf> tolt asked "is there an implementation of X?". People asked "what would you want an X to do?", and told responded with some operations. Then people said "OK, yes, there is, and X is called Y and the operations are called f, g, ..."
16:34:58 <thang1> ^
16:35:14 <L8D> > mplus (Just "foo") (Just "bar")
16:35:16 <lambdabot>  Just "foo"
16:35:18 <shachaf> If that answer isn't satisfactory, that's fine, and it's a good opportunity to refine the question.
16:35:22 <L8D> > mplus Nothing (Just "bar")
16:35:23 <lambdabot>  Just "bar"
16:35:50 <thang1> Haskellfant: It's not a 'crazy' optimization, but it is still something that has to be directly implemented rather than having it implicit from the properties of a functional paradigm
16:35:52 <k00mi> bernalex: that's your "if" function with different argument order
16:36:07 <bernalex> k00mi: and?
16:36:09 <thang1> an immutable paradigm, rather**
16:36:18 <bernalex> k00mi: I'm sorry, but I'm not sure what your point is.
16:36:28 <exio4> > bool 42 1337 True
16:36:30 <lambdabot>  1337
16:36:30 <exio4> > bool 42 1337 False
16:36:31 <lambdabot>  42
16:36:38 <Haskellfant> thang1: fair enough but then your immutable paradigm is pretty useless if you can't even prepend to a list without copying evertyhing around
16:36:45 <k00mi> bernalex: my point is that it is indeed in the Prelude
16:36:48 <bernalex> I know what bool is and how bool works. I don't understand the point k00mi was making by making an opaque reference to it.
16:36:54 <bernalex> k00mi: bool is not in Prelude
16:37:03 <exio4> it is in Data.Bool, which is in base
16:37:04 <k00mi> ok, so it's in Data.Bool
16:37:12 <thang1> A mutable paradigm allows a naive stack because you can just modify the stack directly by adding/removing to it. An immutable paradigm doesn't get this behavior for "free", you have to implement it by using properties of immutability to find shortcuts and optimizations of how to implement the actual algorithm in the back end
16:37:14 <bernalex> exio4: which is not Prelude
16:37:17 <bernalex> k00mi: which is not Prelude
16:38:04 <Axman6> thang1: what sort of optimisations are necessary to implement a stack in Haskell?
16:38:21 <thang1> I still think it's important to keep things like that in mind. GHC is very, very good at optimizing its code by doing things like that, but there is a reason most mutable data structure should have a different/similar implementation in an immutable data structure
16:39:07 <Haskellfant> thang1: actually you rather need to implement copying it everytime instead of just using the same reference over and over, but anyway, I'm going to bed
16:39:11 <thang1> Axman6: A linked list is the "normal" way to implement a simple stack. If you treat the data structure as immutable, then the entire data structure can't be changed (which is correct), which requires that all of it is copied every time something is modified
16:39:39 <Haskellfant> if I use sharing the data structure still can't be changed
16:39:53 <Aruro> is chapter on Parsec in RWH up to date?
16:39:58 <Axman6> but when performing the usual stack operations, basically nothing needs to be copied
16:40:10 <thang1> Exactly. EVERYTHING but one item is the same
16:40:19 <Clint> Aruro: not even close
16:40:23 <thang1> So, in the background, GHC behaves like a mutable data structure
16:40:31 <Haskellfant> no it does not
16:40:32 <Axman6> thang1: no
16:40:33 <Aruro> so there is no point reading it?
16:40:41 <thang1> Clint: If you're assuming the only operations on a stack are push and pop on a linked list, then yes
16:40:49 <Clint> Aruro: i would say so
16:40:54 <exio4> lazyness is also "mutable" if you think it too much
16:40:54 <Axman6> Aruro: I wouldn't say no point, but some things have probably changed
16:40:58 <chrisdone> thang1: what things need to be copied in 1 : [2,3,4]?
16:41:00 <exio4> you are updating values in-place
16:41:16 <kadoban> thang1: Well, that's what a stack /is/. Those are the stack operations...
16:41:22 <Aruro> what is the best tutorial to put hands on parsec?
16:41:32 <Aruro> not best but nice
16:41:32 <Axman6> yeah, exactly, those pricisely define what a stack is
16:41:34 <thang1> chrisdone: The memory, for one thing. You can't just leave all the items in the same memory location if you want to say it's immutable without keeping some record of what you did
16:41:49 <Haskellfant> I can keep [2,3,4] in the same memory location
16:41:51 <Haskellfant> it's immutable
16:41:58 <Axman6> thang1: what?
16:42:03 <Haskellfant> and create a new list that points it's second element to [2,3,4]
16:42:14 <chrisdone> Aruro: maybe this one https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
16:42:25 <thang1> But the new list will take up the same size of memory as [1,2,3,4]
16:42:25 <ReinH> thang1: you might want to read Okasaki's book on functional data structures...
16:42:29 <chrisdone> thang1: "the memory"?
16:42:34 <thang1> and you still have [2,3,4] in memory as the original stack
16:42:41 <stephen_> pharpend: I don't use github, but herehttp://pastebin.com/50d9r869
16:42:44 <Haskellfant> right, but I never copied it
16:42:46 <chrisdone> thang1: ok, so what things are copied?
16:42:57 <thang1> All of it?
16:43:00 <stephen_> ** Here's my version
16:43:03 <chrisdone> no
16:43:06 <zwer_j> thang1 prepending to a singly linked list is O(1). just the new head is allocated
16:43:07 <Axman6> thang1: if I have xs = [2,3,4], 1:xs takes up the size of the (:) plus the size of the 1
16:43:09 <kadoban> thang1: You have one list that is [1..4], one list that is [2..4], but they share 75% of their memory
16:43:10 <pharpend> stephen_: could you put a space between the url and the word, I can't get at the url
16:43:18 <thang1> Write a list of numbers on a whiteboard and circle them with a box. Now add to the  list without changing the size of the box
16:43:21 <thang1> impossible
16:43:28 <thang1> You must write an entirely new set of numbers and then make a new box around them
16:43:35 <Axman6> no...
16:43:36 <kadoban> thang1: If you have a stack with 1000 things in it, and add 1 thing, they share 99.9% of their memory.
16:43:41 <Haskellfant> thang1: you're talking about arrays not about lists
16:43:41 <thang1> Now if you're smart you can erase one line of the box, add the one, and draw back that one line
16:43:41 <stephen_> pharpend: Sorry, pressed enter too soon. http://pastebin.com/50d9r869
16:43:42 <kadoban> thang1: No...very much no.
16:43:48 <ReinH> thang1: THat's great for numbers on a whiteboard. Not relevant here though.
16:43:57 <Haskellfant> there is no box around lists
16:43:57 <Axman6> thang1: you don't know what you're talking about
16:43:58 <k00mi> thang1: if you prepend an element to a list, one thing happens: a new cons cell is allocated that contains a pointer to the new element and a pointer to the next (already existing) cons cell
16:44:03 <zwer_j> thang1 draw a new box (new first element) then draw an arrow that points to the old box
16:44:05 <Axman6> a list is not an array
16:44:09 <monochrom> Aruro: https://github.com/JakeWheat/intro_to_parsing is a recent parsec tutorial
16:44:14 <pharpend> thanks stephen_
16:44:16 <k00mi> thang1: you do not have to change anything about the following cons cell to create the new one
16:44:17 <thang1> k00mi: That's how haskell implements it
16:44:29 <Haskellfant> that's the whole point of lists
16:44:31 <Aruro> ty guys!
16:44:33 <thang1> I get the feeling that you guys are referencing how haskell actually implements it
16:44:35 <k00mi> no, haskell doesn't implement things
16:44:35 <Axman6> so it's not a fixed size box, it's a a chain of cons objects pointing to values and the tail of the list
16:44:37 <ReinH> thang1: what actually are you trying to argue?
16:44:47 <thang1> and I'm trying to talk about how immutable data structures as a theoretical aspect actually work
16:44:54 <chrisdone> thang1: what is copied in this? 1 : [2..]
16:45:02 <kadoban> k00mi: That's the only sane way to implement it. If you wanted to make an implementation of haskell that purposefully sucked, I guess you could do that...but you can't say it's necessary.
16:45:11 <ReinH> thang1: But they don't *actually* work in that way, and Haskell is a counter-example.
16:45:15 <kadoban> Sorry, that was to the wrong person of course.
16:45:25 <Aruro> also it will be nice if they explain on side Control. Applicative so i can understand line times= (*) <$ char '*'
16:45:28 <ReinH> Okasaki's book depends on these structures *not* working in the way you describe
16:45:36 <k00mi> thang1: that's exactly the theory of how immutable data structures work, it's called "sharing" and it's an essential aspect
16:45:40 <chrisdone> data types in haskell are boxed by default. [] is one of these types. the elements are represented by pointers in GHC
16:45:49 <thang1> Sharing is an essential aspect to making them efficient
16:46:03 <thang1> not an essential aspect of the structure itself.
16:46:06 <chrisdone> you can't have repeat 1 :: [Int] without lists being boxed
16:46:08 <Haskellfant> ofc it is
16:46:13 <thang1> I know you guys are all right, and I know how the implementation actually works
16:46:20 <Haskellfant> o(1) prepend is an essential aspect of lists as a theoretical construct
16:46:25 <ReinH> thang1: So what are you actually arguing?
16:46:33 <Axman6> thang1: sharing is essential, it's not an optimisation
16:46:33 <thang1> I'm trying to argue something from an angle that everyone is missing because I'm coming across the wrong way, I guess
16:46:45 <ReinH> That lists "theoretically" don't offer O(1) cons? Because they absolutely do.
16:46:58 <chrisdone> therefore 1 : [2,3,4] creates a new constructor which has two pointers, one pointer to the 1 :: Int, and one pointer to the existing [2,3,4] thunk
16:47:04 <thang1> Sharing is essential. The implementation is what's optimized.
16:47:09 <monochrom> O(1) still does not tell you about boxing.
16:47:14 <Axman6> thang1: yes, you are not making your point well by saying things which are patently true are not in fact true
16:47:55 <ReinH> It honestly sounds like you're arguing that "inefficiently implemented functional data structures will be inefficient". I think we can all agree with this tautology.
16:48:01 <Axman6> GHC's "implementation of lists" is the obvious implementation
16:48:20 <shachaf> It seems to me that most of the noise comes from 20 people saying the same thing to thang1. One person would suffice.
16:48:36 <Axman6> it is equivalent to struct list_t { void * head; struct list_t * tail}
16:48:55 <thang1> ReinH: I suppose you could word it that way. I would say that the naive implementation of _immutable_ data structures will always be grossly inefficient, as long as the data structures are designed with the concept of sharing
16:49:01 <kadoban> shachaf: Well, since we don't have a dictator around to appoint a designator responder...
16:49:07 <thang1> Which is pretty much a requirement for a data structure anyway
16:49:13 <Axman6> shachaf: but someone is wrong on the internet!
16:49:17 <ReinH> thang1: You call that implementation naive. I would call it "incorrect".
16:49:19 <monochrom> each "x:y" in GHC takes 3 machine words, one for pointer to ":", one for pointer to x, one for pointer to y. a machine word is 4 bytes or 8 bytes depending on 32-bit vs 64-bit. therefore, in the worst case, "x:y" takes 24 bytes.
16:49:21 <y> the naive implementation of the fib function is O(2^n)!
16:49:22 <y> Axman6: duty calls
16:49:24 <k00mi> thang1: the implementation you have in mind is not naive, it's intentionally inefficient
16:49:27 <meiji11> I need mutable reference cells in IO and I'm noticing that IORef is pretty slow. is there anything faster?
16:49:38 <meiji11> I've looked at the arrayref package, but it seems old and broken.
16:50:03 <thang1> The implementation I have in mind is correct to the point of stupidity, yes, but not intentionally inefficient. It's inefficient from the nature of immutable data
16:50:07 <ReinH> meiji11: How do you know that the IORef is what is slow?
16:50:15 <chrisdone> meiji11: i don't know of anything faster
16:50:25 <thang1> or rather, perhaps 'pendatic' rather than 'correct to the point of stupidity'
16:50:31 <Axman6> meiji11: what are you doing with them? they're essentially just a pointer
16:50:39 <chrisdone> iorefs are pretty much the lowest thing you get before you drop out of haskell
16:50:43 <meiji11> ReinH: profiling reveals that my program spends most of its time there. of course, I'm also calling liftIO every time I use it, perhaps that's the culprit. :-/
16:51:04 <stephen_> pharpend: welcome :)
16:51:07 <ReinH> meiji11: Where, specifically?
16:51:21 <shachaf> IORef has all sorts of issues if you want fast code. Any code that uses it will almost certainly never be as fast as a C variable, say.
16:51:28 <thang1> It's like a math professor talking to someone about how derivatives work. "Oh it's easy, you have x^2 and you take the limit which involves these several steps and then evaluate everything out and bingo. Only half a page of writing"
16:51:53 <monochrom> naw. it's "x^2 = 2x -> x+x"
16:51:58 <zwer_j> thang1 did you ever implement a singly linked list in some language? how did you implement cons, or prepending an element to a list?
16:52:01 <ReinH> monochrom: callback humor
16:52:02 <meiji11> ReinH, as part of a language interpreter I've written. functions in this language can be defined, redefined later, etc.
16:52:03 <chrisdone> meiji11: it depends on the code, but a pitfall tends to be forgetting to force before you store in an ioref, leading to building up lots of thunks
16:52:08 <thang1> and the other person replies "but the efficient way to do it is the power rule", to which he's replied to "but, technically it works like this", and the other replies "but why the fuck would any sane person ever do it that way?"
16:52:14 <Axman6> monochrom: heh
16:52:34 <shachaf> "the IORef is boxed" might be pitfall enough, depending on what you compare it to.
16:52:36 <chrisdone> meiji11: have you elimited that kind of thing?
16:52:38 <thang1> zwer: I've implemented most common data structures by hand in C++ before, so yes I have
16:52:42 <meiji11> chrisdone, you mean forcing with seq, a bang pattern, etc?
16:52:45 <monochrom> (if you even changed the example to "x^3" I wouldn't be able to insert my joke :) )
16:52:50 <meiji11> chrisdone, I think I'm aware of how?
16:52:58 <chrisdone> meiji11: sure, although there is modifyIORef' which is handier
16:53:08 <kadoban> thang1: I don't understand your analogy at all. *shrug*
16:53:11 <meiji11> chrisdone, ok, thanks.
16:53:27 <meiji11> I know that excessively lifting is often a problem when using a stock monad transformer stack from mtl.. I haven't flattened it yet.
16:53:43 <meiji11> I wasn't sure what to attribute it to other than either liftIO, or IORef..
16:53:44 <k00mi> thang1: I don't see your point at all, and appearently noone else does
16:53:56 <chrisdone> right. definitely try it on a basic IO monad with a simplest case before benchmarking, if you want to specifically test IORef performance
16:54:07 <Axman6> kadoban: me either. afaict thang1's point is that the "obvious" to work with immutable data structures is every time you do anything with them, you make a copy
16:54:22 <kadoban> Axman6: Yeah, that's all I'm taking away as well...
16:54:23 <monochrom> not enough programmers have the scientific mind
16:54:25 <shachaf> I've benchmarked IORef performance a bit before, and it wasn't great.
16:54:46 <thang1> kadoban: It's fine, the analogy was semi terrible anyway. I'm just coming at the issue from too far out in theory, I guess. I'm purposely ignoring how one would "actually" implement a immutable data structure to argue that one, in order to implement them 'pendatically/correctly', would have to copy all the data to a new one in order to change it
16:54:54 <Axman6> of the whole structure. clearly that idiotic because things which cannot change will always be equal so you can always safely reference them from many places
16:54:58 <zwer> thamz what did allocations did you do for prepending an element to a list?
16:55:03 <monochrom> the scientific mind would think: to determine whether factor X is at play, the last thing you want is an experiment that contains factors X, Y, Z, A, B, C, and D.
16:55:03 <thang1> In reality, sharing and other optimizations and clarity of thinking are used so you don't have to do all that
16:55:11 <zwer> what allocations*
16:55:12 <ReinH> thang1: That doesn't follow at all, but ok.
16:55:25 <shachaf> I think this discussion would be better in #haskell-overflow now.
16:55:29 <Axman6> sharing is NOT AN OPTIMISATION!
16:55:30 <thang1> Think back to my whiteboard example from earlier
16:55:42 <Axman6> your example was terrible
16:56:00 <Axman6> because it tried to make lies about how things actually work
16:56:07 <thang1> I'm terrible at them, which is why I spared you my making a new one
16:56:19 <chrisdone> monochrom: indeed. although i'm not sure how much of it is a lack of scientific mind and how much of it is "jeez, i've already written all this, i really don't want to have to write *more* code to isolate this... ;_;"
16:56:26 <thang1> Anyway I have to get off for a bit to move back to the dorm, the lab is closing
16:56:49 <thang1> I'll be back in like 5 mins and I'll drop the subject since the discussion won't go anywhere useful
16:56:57 <exio4> http://en.wikipedia.org/wiki/Persistent_data_structure
16:57:09 <Axman6> thang1: they can go someone, as long as you learn =)
16:57:14 <Axman6> somewhere*
16:57:15 <exio4> >While persistence can be achieved by simple copying, this is inefficient in CPU and RAM usage, because most operations make only small changes to a data structure.
16:57:29 <monochrom> chrisdone: then we come to another point. programmers do not use subtraction thinking enough. in other words, programmers do not delete code enough. :)
16:58:04 <chrisdone> naively speaking, we should be at the best possible point in history for easy refactoring tooling
16:58:16 <chrisdone> in actuality, we're not much further than they were in the 70s
16:58:34 <monochrom> to isolate factor X, do this: git remove Y.hs Z.hs A.hs B.hs C.hs D.hs; git commit
16:58:38 <ReinH> thang1: I'll just leave you with one thought: it is not possible to copy an infinite list.
16:59:02 <chrisdone> ReinH: i said that above but it was lost in the noise
16:59:10 <ReinH> There is literally no possible way to implement 1 : [2..] using your operational semantics.
17:00:07 <exio4> someone has to link Okasaki's book
17:00:15 <ReinH> exio4: I mentioned it a few times.
17:00:20 <exio4> is it in lambdabot's database?
17:00:26 <exio4> oh, didn't see :P
17:00:27 <monochrom> I am not sure why anyone spent time arguing. I would simply say, "go ahead implement a compiler/interpreter your way".
17:00:36 <ReinH> His thesis is.
17:00:39 <ReinH> @where okasaki
17:00:39 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
17:00:50 <chrisdone> ReinH: http://ircbrowse.net/selection/haskell?title=Conversation&events=19646189,19646198,19646206,19646210,19646212,19646214,19646249
17:00:53 <ReinH> Which would be sufficient.
17:00:56 <chrisdone> ReinH: but i got no reply after that ;)
17:00:58 <shachaf> #haskell folks sure love winning arguments.
17:01:11 <monochrom> I love winning arguments too.
17:01:39 <monochrom> I just consider that when I say "go ahead implement it" and an implementation has not appeared in 5 minutes, then I win.
17:02:40 <KangaAkale> hi Team, please i need assistance on this http://lpaste.net/2086093502889852928
17:03:22 <ReinH> We are not your "Team".
17:03:59 <monochrom> you cannot have the line 2 "where".
17:06:04 <KangaAkale> ReinH: i just want to find out, must you always pick on me
17:06:57 <geekosaur> I'd be more inclined to believe that if you showed any signs of attempting to learn instead of asking the channel to be your interactive ghci+hlint
17:07:23 <Axman6> KangaAkale: you are not being a good channel citizen, so people are getting a bit annoyed. "Can someone help me, here's my code" is a relly bad way to get help
17:07:44 <geekosaur> and glib stuff like "Hi Team fix this for me" doesn't help
17:08:04 <Axman6> KangaAkale: at the very least, have conversations with people, just just say help me and then never say anything again until you have another problem
17:08:26 <mauke> "just just"
17:08:31 <Axman6> we're very happy to help, but we don't work for you, we work with you.
17:08:54 <Axman6> uh, I think that was supposed "don't just"
17:10:36 <geekosaur> this is a community, not an interactive debugger
17:11:00 <Axman6> KangaAkale: so, what would you like some help with?
17:11:03 <KangaAkale> Axman6 to be sincere with you I really appreciate the help the group has been rendering to me,  I will be an an ingrate if I am not
17:11:21 <chrisdone> geekosaur: a community implies a certain warm togetherness. i think it's more like a pub =p
17:11:49 <ReinH> When you said "pub" I immediately thought "public deathmatch server"
17:11:54 <chrisdone> IRC is like https://www.youtube.com/watch?v=gvO35MunzU0
17:11:59 <mauke> I thought pub/sub
17:12:09 <shachaf> KangaAkale: Appreciation is nice but not really sufficient in this case. You'll need to change how you ask for help and the sort of help you expect.
17:12:41 <Axman6> KangaAkale: you haven't even told us what your problem is
17:13:04 <monochrom> the problem is stated in the paste. there is a parse error.
17:13:24 <ReinH> Axman6: (and even so their problem has already been answered)
17:13:37 <Axman6> Oh I missed that while scrolling right
17:13:48 <ReinH> When someone answers your question it's polite to acknowledge it.
17:13:56 <KangaAkale> shachaf: noted, I will take a new leave
17:14:24 <ReinH> That way other people don't waste their time trying to answer it.
17:14:59 <monochrom> I am already used to nobody noticing what I answer!
17:16:47 <ReinH> KangaAkale: also please stop cutting off the error message. You are omitting important information like line and column numbers (which you could use to solve your own problems by the way).
17:17:17 <KangaAkale> monochrom thanks
17:18:35 <KangaAkale> ReinH OK, i will not omit it again
17:18:48 <chrisdone> =)
17:19:43 <ReinH> KangaAkale: Thanks.
17:26:39 <KangaAkale> monochrom Thank you, My issue has been resolved, I can now catch the exception
17:26:51 <chrisdone> ヽ (＾▽＾) ﾉ
17:50:22 <gnezdo> Hello, is it a known issue that ghc-pkg can consume gobs of RAM?
17:50:38 <thang1> What are you doing with it?
17:50:56 <gnezdo> I gave it a mere 1.4M spec file. It ate 8G.
17:51:33 <thang1> https://www.haskell.org/cabal/FAQ.html
17:51:37 <thang1> might help you
17:51:50 <Axman6> that sounds very unusual
17:52:02 <gnezdo> running 7.8.3
17:52:10 <ReinH> that faq is extremely out of date
17:52:17 <thang1> never mind then...
17:52:43 <ReinH> The answers refer to GHC 6.10, for example
17:53:07 <thang1> But if you gave it a spec file, perhaps ghc is going nuts trying to resolve tons of "unnecessary" dependencies which could cause it to eat up much more ram than necessary trying to trace them all down?
17:54:11 <gnezdo> Might be that, there's an enormous pile of native libraries in there
17:54:30 <gnezdo> The command I ran is something like this:
17:54:31 <gnezdo> ghc-pkg -f molecule.package_conf --force register molecule.package_spec
17:55:02 <thang1> Does it work if you don't --force it?
17:56:25 <Axman6> why are you registering packages using ghc_pkg anyway?
17:56:38 <gnezdo> --force is irrelevant
17:57:01 <gnezdo> Axman6: it's baked into a custom build system with particular requiremetns
17:57:11 * hackagebot brainfuck-monad 0.4.0 - BrainFuck monad  http://hackage.haskell.org/package/brainfuck-monad-0.4.0 (JoeyHess)
17:57:12 <Axman6> ew :(
17:57:45 <gnezdo> the spec file has 1.4M of ld-options, that's where all the space is
17:57:49 <gnezdo> ... in the input
17:58:13 <Axman6> wow...
17:58:22 <gnezdo> it's a big system
17:58:38 <Axman6> it sounds horrible
17:58:40 <thang1> That sounds like one of those things that's so terrible it's impressive
17:58:59 <gnezdo> yeah, real world is strange
17:59:34 <pharpend> bitemyapp: you around?
17:59:35 <gnezdo> so, nobody's tried this before, I take it :)
17:59:38 <Hafydd> Oh, yes, Brainfuck, a good example of a real-world programming language.
17:59:48 * pharpend nods
18:00:15 <thang1> Favorited by CEOs everywhere. "Look at all those plus signs! Plus means good, double plus good"
18:01:25 <Axman6> gnezdo: mind if I ask what the project is?
18:02:34 <Welkin> it's a cross
18:02:35 <gnezdo> it only takes something with 8K .o files and 24 .a files in deeply nested directories to get to 1.4M of ld-options
18:02:41 <Welkin> often used as a religious symbol
18:05:25 <gnezdo> Axman6: not my project, I'm just investigating the build systems failure for them.
18:05:39 <thang1> That many files? I didn't realize there were any haskell projects that large, yet
18:05:56 <gnezdo> it's all native stuff
18:05:58 <Axman6> there are plenty of large haskell projects out there
18:06:01 <tommd> yet??
18:06:10 <tommd> 20 years later?
18:06:48 <Axman6> closer to 25 isn't it?
18:07:12 <thang1> Axman6: I know there are plenty of large haskell projects out there
18:07:15 <tommd> Well some people count from 1.4  (/rationalization)
18:09:03 <Axman6> right, fair enough
18:09:27 <batchm> can
18:09:30 <batchm> can someo
18:09:33 <batchm> wtf
18:09:35 <bitemyapp> pharpend: no
18:10:51 <batchm> can someone recommend an open source gtk2hs program that is easy to follow and is well structured? my gtk2hs program is quickly turning into a mess
18:13:51 <pavonia> batchm: leksah maybe
18:15:06 <pharpend> bitemyapp: heh
18:15:31 <pharpend> bitemyapp: have you gotten into any trouble with FreeNode over your channel being called #haskell-beginners ?
18:15:45 <batchm> pavonia thanks i will take a look
18:20:58 <bitemyapp> pharpend: lol
18:21:41 <pharpend> they have these rules about naming single-hash channels, and apparently we violate them
18:23:18 <Axman6> they also don't care too much. #macosx isn't an offical channel or Mac OS X, but no one's ever complained
18:23:24 <pharpend> yeah
18:23:26 <pharpend> okay
18:23:45 <pavonia> What rule is violated by that channel?
18:36:41 <TallerGhostWalt> sometimes I like to import the types of things like this: http://lpaste.net/116338
18:37:07 <TallerGhostWalt> Other than being a little verbose, does anyone see anyting pathalogical about that?
18:37:27 <Iceland_jack> TallerGhostWalt: Nope that's fine
18:37:53 <kadoban> Nothing wrong with it. It's usually nicer for importing types and operators like that. Then you don't have to do stupid things like T.<*> which looks like butt.
18:38:05 <batchm> I do that often. T.Text rubs me the wrong way
18:38:14 <TallerGhostWalt> cool cool
18:38:16 <TallerGhostWalt> glad to hear!
18:38:24 <thang1> I believe single hash tag channels have to be "official" somehow
18:38:28 <Iceland_jack> kadoban: “looks like butt” in layman's terms, please
18:38:29 <TallerGhostWalt> kadoban: exactly!
18:38:34 <Iceland_jack> None of that academic language
18:38:39 <kadoban> XD
18:39:01 <Axman6> TallerGhostWalt: I added a macro to the sublime text haskell package to let you write that exactly
18:39:38 <Iceland_jack> TallerGhostWalt: If you look at documentation for Data.Map (https://hackage.haskell.org/package/containers-0.3.0.0/docs/Data-Map.html) or Data.Set you see exactly that recommended
18:39:50 <Iceland_jack>     Since many function names (but not the type name) clash with Prelude names, this module is usually imported qualified, e.g.
18:39:50 <Iceland_jack>       import Data.Map (Map)
18:39:50 <Iceland_jack>       import qualified Data.Map as Map
18:39:58 <mauke> thang1: "hash tag"? ಠ_ಠ
18:40:37 <thang1> mauke: it's 2014, grandpa.
18:41:08 <thang1> But in all seriousness, I usually say "hashtag" now just out of default because I'm not usually speaking to CS/technical people and I'm too lazy to change jargon for the same item
18:41:17 <TallerGhostWalt> Iceland_jack: well, that feels really official
18:41:55 <mauke> thang1: channel names are not tags
18:42:31 <Iceland_jack> Would you escape '# → \#' if you wanted a hashtag for #haskell? #\#haskell?
18:42:35 <thang1> It seems wrong to say "pound haskell", though.
18:42:37 <heatsink> Hashtag-haskell is hashtag-1 in my book.
18:42:38 <Axman6> TallerGhostWalt: https://github.com/SublimeHaskell/SublimeHaskell/blob/master/Snippets/DoubleImport.sublime-snippet
18:42:44 <mauke> thang1: so say "hash"
18:42:59 <Axman6> right, you'd say hash-haskell
18:43:17 <Axman6> that's how it's been said since long before twitter existed
18:43:17 <thang1> hash without the 'tag' part makes me feel like eating potatoes, or makes me think of encryption. I'm weird
18:43:29 <Axman6> yes
18:43:32 <Axman6> >_>
18:43:44 <mauke> well, and hash with the tag makes me think of tags
18:43:45 <Iceland_jack> Potatoes?
18:43:51 <Axman6> also, both are accurate ways to describe many IRC channels
18:43:53 <mauke> hash browns
18:44:00 <Iceland_jack> I see
18:44:28 <thang1> It's an american thing. Specifically "country" or south/southwestern, but fairly widespread at this point I'm sure
18:44:50 <mauke> I think it's a stupidity thing
18:44:55 <mauke> like calling a computer "CPU" or "modem"
18:44:56 <Iceland_jack> I think of something else
18:45:03 <thang1> hash browns?
18:45:15 <Axman6> are delicious
18:45:38 <thang1> mauke: I was referencing the hash browns when I said it's an american thing, not "hashtag", sorry if that confused you any
18:45:58 <Axman6> mauke: right, because computers are made of the computer and the hard drive. the computer is what shows you stuff
18:46:03 <mauke> woops
18:49:58 <TallerGhostWalt> Axman6: I need to make a Yasnippet like that!
18:51:02 <Axman6> yasnippet?
18:51:47 <TallerGhostWalt> Axman6: yeah the snippet engine I use in emacs
18:52:13 * hackagebot relational-query 0.0.1.7 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.7 (KeiHibino)
18:52:54 <Axman6> it's pretty simple so feel free to create a derivative, preferably with attribution =)
18:53:14 <thang1> Yasnippet is awesome. I wanna start using emacs, but I'm still stuck on vim until I have more free time this upcoming break
18:53:41 <TallerGhostWalt> Axman6: deal!
18:54:28 <TallerGhostWalt> thang1: I never used vim, but I know the transition one way or the other is hard... not a lot of killer-app kind of features in the move either way.
18:54:53 <TallerGhostWalt> I should say, I have never used vim for extended time.
19:01:58 <Kaidelong> http://qr.ae/qkJkB just wrote this, does anyone dispute my specific assertions? (as in, they're wrong, I totally expect many people to say they're not important)
19:02:06 <Kaidelong> I'm asking in part because I really hope I'm wrong
19:02:14 * hackagebot relational-query 0.0.1.5 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.5 (KeiHibino)
19:06:51 <gedringer> Could anyone help me with Insertion method for 2-3-4 tree?
19:07:58 <trap_exit> on osx, without brew / macports / ..., with just cabal + ghc + emacs, what's a good tool to format *.hs files for printing ?
19:08:30 <trap_exit> ANSWER ME :-)
19:09:15 <geekosaur> we've been through this before. there isn;t one
19:09:20 <trap_exit> :-(
19:09:55 <Kaidelong> trap_exit: if you're willing to put in the effort, lhs2tex is amazing
19:10:19 <trap_exit> what effort is required?
19:10:24 <trap_exit> is it not just lhs2tex + pdflatex ?
19:10:43 <Kaidelong> well you have to learn LaTeX and then how it interacts with literate haskell
19:10:50 <trap_exit> I know latex
19:10:56 <Kaidelong> then I'd recommend that
19:11:01 <trap_exit> what do you think I am, a MS-Word using newb? :-)
19:11:07 <Kaidelong> lhs2TeX is pretty good
19:11:34 <Kaidelong> MS-Word is actually decently good now, when last did you use it?
19:11:50 <Kaidelong> it walks you through the table of contents and references and everything
19:12:09 <gedringer> 2-3-4 tree Insertion method help anyone? (^-^)
19:12:22 <trap_exit> any reason you are not usinb red black tree?
19:12:29 <trap_exit> I just implemneted rbtree-insert in 10 lines of haskell
19:12:34 <trap_exit> and most of it was base cases, not the rotation cse
19:12:45 <Kaidelong> gedringer: why not paste what you have
19:12:50 <Kaidelong> don't ask to ask
19:12:54 <gedringer> oki doki :3
19:14:01 <trap_exit> and sleepy
19:14:01 <trap_exit> perhaps now is not good time to code haskell
19:15:44 <gedringer> http://pastebin.com/7wbuN5n7
19:16:34 <gedringer> I know this might work for conversion of the 2nodes to 3nodes etc
19:16:46 <gedringer> but then I'd assume I need an otherwise statement
19:17:10 <gedringer> to keep traversing the tree? dunno I'm literally stuck there
19:17:48 <thang1> TallerGhostWalt: The killer-app feature for vim would definitely have to be the modal editing paradigm
19:18:07 <gedringer> well duck.. I just advertised my name and surname on irc chat... mehh...
19:18:40 <gnezdo> Does trac login work somebody? I get a seemingly positive login response and then can't create a bug.
19:18:49 <thang1> Being able to type "caw" to change around a word, and then "cap" to change around a 'paragraph', "cas" for sentence, etc is really powerful. I just really enjoy the fact that I 'combine' small keybinds together to get what I want
19:19:17 <thang1> gedringer: Don't worry, none of us are serial killers, unless we're talking about I/O ports
19:19:32 <gedringer> lol hahaha
19:20:25 <Kaidelong> alright I don't quite know what a 2-3-4 tree is but that can be sorted out I guess, insertToTree is what you are writing, yes?
19:20:45 <Kaidelong> anyway I have to ask, you have "data TwoFourTree t" but never actually use that t anywhere
19:21:07 <Kaidelong> it doesn't look like you are using it as a phantom type the sake of the type system
19:21:15 <Kaidelong> shouldn't you just remove it?
19:21:49 <thang1> Maybe he wants a t for three, instead of a twoFourTree?
19:22:17 <gedringer> I think yeah
19:22:26 <gedringer> I thought I will use it but
19:22:31 <gedringer> never ended up using it
19:22:33 <gedringer> :P
19:22:41 <thang1> That pun was clever on so many levels, damn am I proud of myself for that :p
19:22:41 <Kaidelong> alright moving on with obvious stuff
19:23:04 <gedringer> lol haha
19:23:09 <Kaidelong> Mmm I guess that's it for now
19:23:14 <lpaste> gnezdo pasted “ghc-pkg devouring memory per ld-options item” at http://lpaste.net/116339
19:23:40 <gnezdo> If somebody can log in to trac and file this, I'd appreciate it
19:24:10 <thang1> It's interesting
19:24:24 <thang1> every time you echo the size, it grows perfectly by a power of 2
19:24:44 <gnezdo> yeah, to the tune of 400K per item in ld-options
19:24:53 <gnezdo> single character item, tha tis
19:25:01 <Kaidelong> gedringer: looking over it, your implementation seems correct, except I might replace that error with just returning the tree without modifying it
19:25:09 <Kaidelong> what is the problem you are having?
19:25:12 <thang1> Then crashes at exactly 32768, which is the max of a 32 bit integer
19:26:01 <gedringer> I need to reposition the tree and I don't know how to do this :/ I know from example how it should be done but don't really know how to do this in haskell
19:26:44 <gedringer> When adding to fournode which has 3 values I need to remove the middle one and add it to the parrent
19:26:49 <Kaidelong> oh I see, there is a kind of tree balancing you have to do?
19:26:57 <gedringer> etc it's a small rotation but still
19:26:58 <Kaidelong> gedringer, do you know about continuation passing style?
19:27:06 <gedringer> no :/
19:27:13 <Kaidelong> okay I will explain it in a nutshell
19:27:14 <Axman6> > maxBound :: Int32
19:27:15 <lambdabot>  2147483647
19:27:19 <gedringer> Like I'm pretty new to Haskell
19:27:20 <zq> RecordWildCards are no longer evil because oliver charles wrote about them
19:27:22 <Axman6> > maxBound :: Int16
19:27:24 <lambdabot>  32767
19:27:35 <thang1> hmm
19:27:39 <Kaidelong> there is a common pattern in functional programming where a recursive function passes along a function that it builds up using composition
19:27:48 <thang1> See this is something I knew, but my fingers lied to me...
19:27:50 <Kaidelong> this function getting passed around is called a continuation
19:28:09 <gedringer> isn't composition, using output of one function as input to another?
19:28:15 <Kaidelong> insertToTree can't rebalance your tree properly because it's not keeping track of how it traversed the tree
19:28:19 <thang1> It's the max size of a normal 'int' in C++ and I keep forgetting C++ defaults to 16bit integers instead of 32bit
19:28:19 <Kaidelong> yes that is what composition is
19:28:32 <Kaidelong> you want a definition like
19:28:42 <Kaidelong> insertToTree = insertToTree' id
19:29:09 <Kaidelong> where insertToTree' takes, as its first parameter, a function that rebalances the tree properly at each point, depending on what you discovered on your way down
19:29:20 <Kaidelong> at the base of that tree, that function is just id
19:29:32 <Kaidelong> (actually, in this case, it probably isn't, sorry)
19:29:48 <Kaidelong> (id would normally be the seed but in your case it'd be your rotation function)
19:30:10 <Kaidelong> what you should do is write some rotation functions that rotate the tree at a single node, could you do that first, gedringer?
19:30:10 <gedringer> why the apostrophe? I thought composition would look something like functionA.functionB
19:30:34 <Kaidelong> the apostrophe is just a haskell convention for describing something that's slightly different from the thing you're naming before
19:30:48 <gedringer> now that I know I need to do rotation I will do some research, I don't know how to do it but will dig something up
19:30:53 <Kaidelong> as in, instead of naming it insertToTree you name the thing that does the main work insertToTree'
19:31:03 <gedringer> oh
19:31:21 <gedringer> thank you :D
19:31:24 <Kaidelong> gedringer: all you have to do is write down all the rotation operations for now, like rotateTreeLeft, rotateTreeRight etc
19:31:44 <Kaidelong> when you're done with that, ask someone or me to show you how to use continuation passing style to call those rotations at the correct times
19:31:53 <Kaidelong> or just look it up yourself, now that you know the term
19:32:08 <gedringer> oki doki ^-^
19:32:11 <gedringer> thank you a lot!! :D
19:34:32 <Kaidelong> gedringer: https://cwuavltreedemo.codeplex.com/SourceControl/latest#Tree/AVLTree.fs <-- this should serve as a good reference for you, it's a different kind of tree, but it uses the strategy I am suggesting, and it's in a language very similar to haskell
19:35:18 <gedringer> I'll take a look now :D kind thank you ^-^
19:48:55 <gedringer> Kaidelong why do I have a feeling that my function for Insertion so far is not going to the lowest level of the tree?
19:49:26 <gedringer> I feel it only is checking the top node
19:50:08 <Kaidelong> let me look at your code again
19:50:41 <Kaidelong> indeed that's what you're doing
19:51:01 <Kaidelong> to insert deeper into the tree you need to call insertToTree recursively!
19:51:13 <Kaidelong> you covered recursion in class?
19:51:17 <gedringer> yes that's what I was thinking but can't figure out where to use it
19:51:23 <gedringer> yes
19:51:43 <gedringer> but I will need to check for base case if the next node is Empty
19:51:48 <gedringer> not to go into it
19:52:04 <gedringer> so I would land at the bottom node and stop there
19:52:34 <gedringer> so I would say if key is < a then addToTree a left
19:52:51 <gedringer> and oposite if greater than a
19:53:11 <Kaidelong> something like that! the problem is now you're just throwing away what you've traversed to this point
19:53:14 <gedringer> but I'm afraid I will go to the bottom of the tree and end up on an Empty node
19:53:28 <Kaidelong> oh well that's easy right? You have a case for that
19:53:35 <Kaidelong> insertToTree key Empty = twoNode key
19:53:51 <gedringer> yes but then won't that add a new node on the empty ndoe?
19:53:52 <Kaidelong> oooh
19:53:57 <Kaidelong> well
19:53:59 <gedringer> I need the tree to be ballanced
19:54:18 <Kaidelong> that you can do using a the continuation
19:54:23 <Kaidelong> basically think of it this way
19:54:36 <Kaidelong> each time you go down the tree, there is some housekeeping you have to do as you eventually go back up
19:54:44 <Kaidelong> you write down "when I go back up, I have to do this"
19:54:55 <Kaidelong> and then pass that TODO list further down the tree
19:55:02 <Kaidelong> then when you finally add your key you are like
19:55:19 <gedringer> that sounds like a plan :P
19:55:21 <Kaidelong> insertToTree todoList key Empty = todoList (twoNode key)
19:56:15 <Kaidelong> (in the intermediate steps you are like: insertToTree (todoList . thingIMustDoWhenIGetBack))
19:56:49 <gedringer> I think I know what you mean but can't visualize it
19:56:51 <Kaidelong> that TODO list is called a continuation
19:57:05 <Kaidelong> why don't I reimplement my AVL tree in Haskell quickly?
19:57:12 <Kaidelong> I will go do that
19:57:28 <gedringer> wow that would be helpful :P
20:07:28 <gamegoblin> You guys want to see a hilarious way to make it look like Haskell has object.method() syntax? http://lpaste.net/116340
20:08:11 <nitrix> Is there a on-disk k/v data structure package you'd recommend that I could easily hook into the filesystem IO () and replace that part to make it distributed instead?
20:08:28 <nitrix> I feel like I could save a bit of time this way. Otherwise, I'll rewrite my own.
20:10:38 <Axman6> not that I'm aware of. edwardk's structures package might have the makings of something useful there, the talk he gave at YOW! implied it would be efficient for disk based data too
20:14:51 <gamegoblin> @pl \f (x,y) -> (f x, y)
20:14:51 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
20:15:50 <Axman6> gamegoblin: also know as first
20:15:53 <Axman6> :t first
20:15:54 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:16:19 <gamegoblin> Axman6: always been meaning to getting around to learning arrow (I was hoping lambdabot would point me at the arrow function — sometimes it does)
20:16:45 <Axman6> yeah pl is pretty basic
20:16:50 <HeladoDe1rownie> gamegoblin, just pretend a ~ (->) most of the time. So, (b -> c) -> (b, d) -> (c, d)
20:21:21 <gedringer> Kaidelong: ping :3
20:22:32 <Kaidelong> still working on it
20:27:16 <gedringer> Kaidelong: oki ^-^ just checking if you're still there :3
21:03:33 <nitrix> Is a Functor simply something that can be fmap'ed ?
21:03:54 <batchm> yes
21:04:11 <Kaidelong> and some laws
21:04:14 <Kaidelong> fmap id == id
21:04:17 <kjgorman> as long as the fmapping doesn't affect the structure of the functor (i.e. conforms to the functor laws)
21:04:23 <Kaidelong> fmap (f . g) == fmap f . fmap g
21:04:32 <shachaf> That depends on what you mean by that question.
21:05:08 <nitrix> Why would you need a special type for it though?
21:05:22 <nitrix> Unless that's a typeclass? I didn't look at it yet.
21:05:22 <shachaf> A Functor is a type which is an instance of the class Functor, which means that you can define fmap for it that follows the laws.
21:05:33 <shachaf> You should look at it.
21:05:42 <shachaf> It's not complicated.
21:06:07 <nitrix> So it's both a type and a class? What prevents you from just using fmap without having that type/class exist?
21:06:18 <shachaf> No.
21:06:20 <geekosaur> it's a class
21:06:44 <geekosaur> and what prevents you from using fmap is that you get an error if it can't find an appropriate instance of the typeclass
21:06:56 <nitrix> Okay, so it gives you the possibility of making your types into Functors, which can then be used by fmap.
21:07:06 <HeladoDe1rownie> When you say type T "is a Functor", what you really mean is that there is an instance of Functor for type T.
21:07:17 <nitrix> Shall you instanciate it.
21:07:18 <batchm> nitrix yes
21:07:22 <nitrix> HeladoDe1rownie: Got it.
21:07:22 <kadoban> nitrix: Yep
21:07:34 <batchm> you can define a Functor instance for your own types
21:07:40 <nitrix> I'm surprised how tutorials make theses things way too complicated for nothing.
21:08:05 <kadoban> Which tutorial, out of curiosity?
21:09:11 <nitrix> LYAH is the last one I read on the subject and, while it was close enough, it's going way too deep into the subject when it could be explained very concisely.
21:09:13 * HeladoDe1rownie wonders what happened to the B in their nick
21:09:56 <kadoban> Yeah, LYAH isn't terribly concise, IIRC.
21:10:15 <nitrix> Beginner-friendly documents tends to distract me. I'm used to dry read, not even kiding.
21:10:59 <nitrix> Thanks for the help guys. Appreciated.
21:11:16 <kadoban> I was never in love with the tone it takes...but it did help me a more than bit when I was new.
21:11:47 <shachaf> I don't mind the tone but it seems that it says a lot of confusing or wrong things.
21:13:25 <gamegoblin> @pl \(a,b) -> f b a
21:13:25 <lambdabot> uncurry (flip f)
21:17:19 * hackagebot HDBC-session 0.0.1.1 - Bracketed connection for HDBC  http://hackage.haskell.org/package/HDBC-session-0.0.1.1 (KeiHibino)
21:17:21 * hackagebot names-th 0.0.1.1 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.0.1.1 (KeiHibino)
21:17:23 * hackagebot sql-words 0.0.1.1 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.0.1.1 (KeiHibino)
21:17:25 * hackagebot persistable-record 0.0.1.3 - Binding between SQL database values and haskell records.  http://hackage.haskell.org/package/persistable-record-0.0.1.3 (KeiHibino)
21:17:27 * hackagebot relational-query 0.0.1.8 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.0.1.8 (KeiHibino)
21:18:57 <nitrix> shachaf: Well you know, I'd rather just hear the technical term repeatedly so it eventually sticks in my head and call things by their proper names rather than making analogies and explaining it wrong to you and then correctly, when it could just skim the surface and mention that we'd get back at it later.
21:19:47 <nitrix> Terrible english there, but yeah. At least I'm slowly picking it up and that alone makes me happy :)
21:19:53 <Kaidelong> @ty foldr
21:19:54 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:20:05 <nitrix> One thing though, it really is relearning how to program.
21:20:18 <nitrix> I wish I went the functional way before the procedural one.
21:20:21 <kadoban> nitrix: Typeclassopedia will be your friend eventually. It's very low on analogies for that kind of thing.
21:21:47 <HeladoDeBrownie> Common traps: (1) Functors are containers. (2) Monads are about sequencing. (3) You should sprinkle your sentences with the word "monad" even when what you're talking about has nothing to do with Monad.
21:22:11 <HeladoDeBrownie> Even some more experienced Haskellers fall for that last one
21:22:18 <wei2912> heh
21:22:24 <wei2912> what exactly are functors?
21:22:29 * hackagebot relational-schemas 0.0.1.2 - RDBMSs' schema templates for relational-query  http://hackage.haskell.org/package/relational-schemas-0.0.1.2 (KeiHibino)
21:22:31 * hackagebot relational-query-HDBC 0.0.1.1 - HDBC instance of relational join and typed query for HDBC  http://hackage.haskell.org/package/relational-query-HDBC-0.0.1.1 (KeiHibino)
21:22:37 <HeladoDeBrownie> wei2912, things that implement fmap, subject to the given laws.
21:23:32 <wei2912> HeladoDeBrownie: well... i guess the abstract description helps a lot more than analogies
21:23:44 <wei2912> al these analogies are just confusing
21:23:57 <HeladoDeBrownie> The analogies are semanticless fluff, for the most part.
21:24:14 <HeladoDeBrownie> That's not to say they're useless. Having a good intuition can be helpful.
21:24:31 <HeladoDeBrownie> But I emphasize it ought to be a *good* intuition. :)
21:24:35 <dmj`> wei2912: writing the instance defintions helps "get it", then use them to develop the inuition
21:25:54 <kadoban> A good post on analogies and intuition https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
21:27:19 * hackagebot vk-posix-pty 0.2.1 - Pseudo terminal interaction with subprocesses.  http://hackage.haskell.org/package/vk-posix-pty-0.2.1 (VladimirKirillov)
21:29:03 <HeladoDeBrownie> wei2912, by the way, I should also note I answered your question in the context of Haskell. Outside of Haskell, there is a more general meaning of functor that inspired the Haskell one.
21:29:12 <gedringer> Kaidelong: hey ^-^ under no circumstance I want to be rude, but it's 5:25 am and my head is killing me :P Is it okay if I just stay here and text you later so that you could send me your tree implementation?
21:29:34 <wei2912> HeladoDeBrownie: i see, thanks
21:29:35 <Kaidelong> gedringer: I'm almost done! Could you manage another 30 minutes?
21:29:47 <gedringer> okay ^^
21:30:31 <gedringer> I'll roam the youtube a bit :P
21:30:57 * HeladoDeBrownie imagines gedringer as a deer prancing across a prairie of cat videos
21:31:29 <gedringer> ho'd you know O_O
21:31:56 <gedringer> mah identity!!! it's... over!!!! The cheese!! The burgers!!!!
21:32:23 <Kaidelong> ah nevermind
21:32:28 <Kaidelong> there are mistakes in it
21:32:35 <Kaidelong> I guess I could send you a PM
21:33:03 <gedringer> So you are going to finish it later?
21:33:33 <gedringer> Like I don't want you to do things wasting your precious time ^-^
21:33:39 <Kaidelong> I have some time now =p
21:33:47 <Kaidelong> it'll be a neat thing to do before I go to bed
21:34:11 <gedringer> Okay :P Cat videos it is :3
21:35:39 <gedringer> I'll leep my self up with the videos, if I won't respond means I'm sleeping lol :P No worries, I has your name in mah heart ^^ Will find you here in any case :P
21:43:52 <Kaidelong> Alright, this tree obviously is buggy, but it demonstrates the style well enough, even if the implementation is wrong =p
21:43:56 <Kaidelong> http://codepad.org/9EoWp3TW <- gedringer
21:44:16 <Kaidelong> maybe if you want another exercise, you could fix this broken tree code
21:44:23 <Kaidelong> but that demonstrates continuation passing style
21:45:14 <gedringer> yayyyyy!!!
21:45:15 <gedringer> :D
21:45:55 <gedringer> I will analyse the code tomorrow, looks like it's gonna be a major helping hand with my insertion method :D
21:46:58 <Kaidelong> it gives a sketch for the overall technique you might use
21:47:16 <Kaidelong> I guess the fact that it's wrong doesn't matter too much though because you're using a completely different kind of tree anyway
21:47:21 <gedringer> aren't I going to use the traverse function?
21:47:37 <Kaidelong> I just wrote that for the demo
21:47:48 <Kaidelong> which... right now demonstrates that this tree is implemented incorrectly =p
21:48:02 <gedringer> hihi lol ^^
21:48:28 <gedringer> that's nice though, I can see the syntax and the idea behind it
21:48:48 <gedringer> going to do some reading on continuation
21:48:51 <gedringer> technique
21:49:10 <gedringer> tomorrow and get a closer look at the code as some of the lines there scare me :P
21:49:20 <gedringer> but I know it has to do with continuation
21:49:59 <gedringer> thank you very much for sharing this with me :D If I have any questions you'll be here right?
21:50:10 <Kaidelong> I may be, sure
22:12:23 <dotsspwe> Hello, i'm trying to install scotty-0.4.4 but i get the error message Setup: At least the following dependencies are missing: [With a list of dependencies] Any way for install the dependencies automatically ?
22:12:39 <shachaf> How are you trying?
22:12:54 <dotsspwe> shachaf: just in runhaskell Setup configure
22:13:00 <shachaf> Oh.
22:13:03 <shachaf> Why?
22:13:09 <shachaf> You should probably be using cabal install.
22:13:27 <dotsspwe> um.. i just download the package from the repo
22:13:49 <dotsspwe> shachaf:  but thanks i will use cabal install instead
22:20:10 <dotsspwe> shachaf:  Damn it! I just love Haskell! :)
22:20:49 <dotsspwe> works well thnx again
22:50:51 <apakcbk263> @help djinn
22:50:51 <lambdabot> djinn <type>.
22:50:51 <lambdabot> Generates Haskell code from a type.
22:50:51 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
22:51:45 <glguy> ?djinn (a->b->c) -> b -> a -> c
22:51:46 <lambdabot> f a b c = a c b
22:56:11 <suls_> hello.
22:56:33 <dmj`> sup
22:56:46 <suls_> I am currently hosting a code-retreat and some pairs are using Haskell (great!)
22:57:39 <suls_> the problem is that a lot of the constraints are way too easy when using haskell http://coderetreat.org/facilitating/activity-catalog
22:58:20 <dmj`> what constraints?
22:58:40 <suls_> No naked primitives, Immutables only
22:59:14 <suls_> So I was wondering if "No conditionals:" would raise the game
22:59:39 <dmj`> suls_: are you corey haines?
22:59:54 <suls_> but then, I don't know myself how to encode this Haskell (yet)
23:00:07 <suls_> haha, no ;)
23:00:28 <suls_> https://twitter.com/suls
23:01:49 <dmj`> cool
23:02:12 <dmj`> why are you imposing constraints on programmers
23:02:16 <dmj`> :)
23:02:26 <dmj`> like "dont use functions"
23:02:36 <dmj`> that would make haskell quite challenging
23:03:06 <suls_> why? to bring them out of the comfort zone
23:03:31 <suls_> everyone first encodes dead/alive cells as booleans
23:03:51 <suls_> no primitives forces them to use types. a huge step for most java/ruby etc programmers
23:03:51 <dmj`> make a constraint "Only template haskell", so all code has to be generated to be used
23:04:15 <suls_> haha. well, that would send them googling for 45 minutes ;)
23:04:23 <dmj`> yea :)
23:04:26 <suls_> still fairly beginner level haskell
23:05:25 <jle`> no adt's
23:05:31 <jle`> only church encoded stuff
23:05:35 <jle`> no tuples either
23:05:44 <jle`> no lists
23:05:48 <jle`> etc :O
23:05:59 <dhrosa> lists are easy to create
23:06:08 <dhrosa> unless by no adts you mean you can't create your own at all
23:06:13 <jle`> yeah, no adt's of your own
23:06:16 <glguy> All functions all the time
23:06:27 <jle`> and no adt's from any libraries either
23:06:32 <jle`> and no tuples.
23:07:04 <dmj`> any monads you use, you have to write yourself
23:07:06 <jle`> no ints, either
23:07:09 <dmj`> no state monad w/o writing it
23:07:17 <suls_> jle`: cheers!
23:07:17 <dmj`> no packages
23:07:24 <Fuuzetsu> no items
23:07:26 <Fuuzetsu> final destination
23:07:37 <suls_> glguy: only functions?
23:07:39 <jle`> and also everyone trips
23:07:47 <dmj`> only CPS !
23:07:59 <dmj`> only FFI calls allowed
23:08:16 <shachaf> gotta implement (e ->) yourself
23:08:24 <Fuuzetsu> FFI into C which calls Haskell ;P
23:08:47 <jle`> i'm pretty sure most haskell can be usable with all the adt's and tuples and ints taken out and church encoding everything
23:10:01 <glguy> No typechecker help, -fdefer-type-errors
23:10:30 <glguy> level the playing field ^_^
23:10:50 <dmj`> {-# NoImplicitPrelude #-}
23:13:08 <glguy> suls_: If you get curious you can read a bit about http://en.wikipedia.org/wiki/Church_encoding regarding encoding data in functions
23:17:59 <suls_> glguy: cheers!
23:32:57 <trap_exit> is there some haskell extension which will let me capture the following type system: (Int a, Int b) => Matrix a b -> Vector a -> Vector b ?
23:33:34 <trap_exit> basically, I want to say: forall (implicit) Int a, Int b, given (explicity) Matrix a b, Vector a, I will return for you a Vector b
23:34:05 <uwap> hey, what is the best ui lib for haskell around?
23:37:36 <dmj`> trap_exit: what is the kind of int?
23:38:04 <trap_exit> dmj`: wtf ?
23:38:11 <trap_exit> dmj`: why is this relevant ?
23:38:24 <trap_exit> the goal is to capture matrix vector multiplication
23:38:31 <trap_exit> should I rephrase my question?
23:38:41 <trap_exit> i.e. I thikn your question is valid, but nitpicking an unimportnat aspect of it
23:38:52 <jle`> i think he's trying to understand what you are saying
23:38:55 <trap_exit> and instead of answering your question, I would like to learn how to repharse my question to avoid such pedantic followups
23:39:04 <dmj`> jle`: thank you
23:39:06 <trap_exit> so we have a matrix that is a x b
23:39:13 <trap_exit> and a vector that has dimension 'a'
23:39:18 <trap_exit> and it should output a vector of dimension 'b'
23:39:26 <trap_exit> basic matrix vector multiplication
23:39:38 <trap_exit> I don't understand 'what is the kind of int?'
23:39:48 <jle`> it it supposed to be a constraint?
23:39:50 <jle`> like a typeclass?
23:39:52 <jle`> etc.
23:40:01 <jle`> :k Monoid
23:40:02 <lambdabot> * -> Constraint
23:40:11 <trap_exit> yeah, we can multiply (Matrix 10 5) with (Vector 10)
23:40:16 <trap_exit> but we can not multiply (Matrix 10 5) with (Vector 7)
23:40:22 <trap_exit> since the dimsions do not match up
23:40:24 <jle`> he means kind as in the haskell sense
23:40:37 <jle`> you can probably capture the essense of this with type nats
23:41:12 <trap_exit> how can I do this with type nats ?
23:41:17 <trap_exit> teach me
23:43:33 <jle`> you could parameterize your matrix and vectors by type level nats
23:43:44 <jle`> hm
23:44:04 <jle`> let me make sure i'm getting the syntax right
23:45:47 <favetelinguis> im not an english speaker, can someone say what this means in simple english? "chategory is one of the most sterile intellectual pursuits for most student"
23:46:29 <trap_exit> I got a 790 / 800 on my GRE verbals, and I have no idea what that sentence means.
23:46:42 <jle`> i'm pretty sure you can just do mult :: Matrix a b -> Vector a -> Vector b
23:46:52 <jle`> and use GADT syntax to restrict the parameters of your matrix/vectors to be Nat
23:48:07 <favetelinguis> trap_exit: sorry it should say chategory theory, here is where i got this from http://math.stackexchange.com/questions/29152/motivation-and-use-for-category-theory
23:48:59 <trap_exit> the person is saying that it's a waste of time
23:50:52 <benzrf> favetelinguis: sterile means something that can't reproduce, but it can also mean something that doesn't produce any kind of result or new thing
23:51:19 <benzrf> favetelinguis: so a sterile intellectual pursuit is one that won't result in any real growth
23:52:16 <c_wraith> benzrf: sterile can also mean "free of life", which is what the intellectual meaning is more of an analogy to
23:52:19 <favetelinguis> strange, i thought he was saying that CT was extremely useful in many ares
23:53:15 <benzrf> c_wraith: ah yes
23:53:19 <benzrf> c_wraith: that didn't occur to me
23:58:20 <Cale> favetelinguis: Well, he was saying both
23:59:48 <Cale> favetelinguis: That some have used it very successfully, but that most students wouldn't produce much from it.
