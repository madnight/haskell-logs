00:03:07 <KangaAkale> pavonia: it works
00:10:14 * hackagebot elevator 0.1.3 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1.3 (FumiakiKinoshita)
00:10:14 * hackagebot cheapskate 0.1.0.2 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1.0.2 (JohnMacFarlane)
00:10:34 <pecanpy> i had cabal 1.18 and just did "cabal install cabal-install" after it installed 1.20, it still says i have 1.18? the timestamp on the file is right
00:11:47 <butyoudonot> call it from ~/.cabal/bin/cabal
00:12:30 <butyoudonot> these executables could be placed in a different paths, because one of them is installed by your system package manager and other by cabal
00:13:00 <pecanpy> good intuition. when i ran the exe in cabal it is indeed 1.20
00:13:20 <pecanpy> i just reinstalled haskell before this. but when i did the cabal update earlier today i didnt have this problem
00:14:06 <pecanpy> windows doesnt have a "which" command. how do i find out what exe it is using?
00:14:52 <srhb> pecanpy: Doesn't it have "where" though?
00:15:26 <pecanpy> awesome thanks.
00:15:34 <pecanpy> i guess its calling this one: C:\Haskell\2014.2.0.0\lib\extralibs\bin\cabal.exe
00:15:42 <srhb> Sounds right.
00:16:07 <pecanpy> but it should be using this one: C:\Users\M\AppData\Roaming\cabal\bin\cabal.exe
00:16:46 <butyoudonot> put it in the beginning of your $PATH env variable
00:17:44 <pecanpy> damn it!
00:18:13 <pecanpy> i just realized why. eclipsefp is running and installing a bunch of stuff
00:28:00 <prinsen> Im exposing an API of crypto functions that uses two crypto libraries underneath. One uses lazy bytestrings, and the other uses strict. Would you do 1. Mix lazy and strict bytestrings in my API, 2. only use strict or 3. only use lazy?
00:40:10 * hackagebot timestamp-subprocess-lines 0.1.0.3 - Run a command and timestamp its stdout/stderr lines  http://hackage.haskell.org/package/timestamp-subprocess-lines-0.1.0.3 (EyalLotem)
00:40:25 <pecanpy> butyoudont: just reinstalled hp and same 2 cabal problem. should i def be using the one in appdata/roaming/cabal?
00:41:11 <pecanpy> seems like the install added cabal to my user variables instead of system.
00:42:47 <pecanpy> http://trac.haskell.org/haskell-platform/ticket/146
00:46:26 <redtricycle> There is no "moveFile" in haskell?  do i just use copyFile and removeFile sequentially?
00:47:01 <tdammers> redtricycle: that's not the same thing
00:47:38 <tdammers> http://hackage.haskell.org/package/directory-1.2.1.0/docs/System-Directory.html#v:renameFile
00:47:43 <tdammers> this might be what you're looking for
00:47:57 <tdammers> specifically, moving a file is supposed to be atomic on many platforms
00:48:09 <lb5tr> any amqp experienced haskellers here?
00:48:13 <shachaf> redtricycle: renameFile
00:48:23 <lb5tr> I was wondering how to access global state (i.e. connection) from the callback
00:48:24 <redtricycle> ah, thanks
00:48:36 <lb5tr> I though of wraping it in State monad
00:48:46 <lb5tr> but I don't know how
00:49:01 <shachaf> What are the types involved?
00:49:13 <lb5tr> Connection
00:49:15 <shachaf> State is most likely not the right thing.
00:49:19 <lb5tr> shachaf: ok
00:49:21 <shachaf> The type State, I mean.
00:49:26 <shachaf> What's Connection?
00:49:31 <shachaf> What's the type of your callback?
00:49:36 <lb5tr> https://hackage.haskell.org/package/amqp-0.1/docs/Network-AMQP.html
00:49:52 <lb5tr> myCallback :: (Message,Envelope) -> IO ()
00:50:18 <shachaf> Ah, just pass it an argument, probably. Maybe an IORef.
00:50:36 <lb5tr> I'm not familiar with that
00:50:42 <lb5tr> I'll be back soon :)
00:50:43 <shachaf> Is it really varying state or just a value that's constant once you've started your program?
00:50:52 <lb5tr> oh
00:50:54 <lb5tr> ok
00:50:56 <lb5tr> that makes sense
00:51:04 <lb5tr> i can create 'global' connection function
00:51:29 <shachaf> main = do { c <- makeConnection; ; ...; consumeMsgs ... (myCallback c); ... }; myCallback :: Connection -> (Message,Envelope) -> IO (); myCallback = ...
00:51:36 <shachaf> s/; //
00:53:10 <lb5tr> shachaf: awwww
00:53:12 <lb5tr> sure
00:53:15 <lb5tr> currying
00:53:19 <lb5tr> forgot about it :)
00:53:34 <shachaf> You can call it currying if you want.
00:54:33 <lb5tr> isn't it currying examle?
00:54:35 <lb5tr> *example
00:54:48 <redtricycle> What does default (T.Text) do?  import Data.Text as T; default (T.Text).  Taken from Shelly boilerplate code
00:55:03 <shachaf> It's an extended defaulting thing.
00:55:10 <shachaf> Hoogle can tell you what the keyword "default" does.
00:55:36 <redtricycle> got it, thanks shachaf
01:03:17 <L0rdBrain> anyone know what manatee is... i'm trying to get a picture but the description says "Integrated Haskell Environment" and says "consider it is new environment mix of gnome and emacs"
01:03:41 <L0rdBrain> and then it links to a youtube video with no words, and it says it is not xmonad...
01:04:11 <L0rdBrain> https://www.haskell.org/haskellwiki/Manatee
01:05:07 <L0rdBrain> i wish this was a lot more concrete like, what specific problems does it help one solve, who is the intended audience who will find it useful etc.
01:05:14 <moop> looks like some kind of window manager?
01:05:52 <L0rdBrain> well if that is so, i wish they would actually use that word
01:05:59 <L0rdBrain> :/
01:06:19 <L0rdBrain> it is not just a windowing thing i think
01:06:39 <moop> i think the description is pretty good
01:06:42 <L0rdBrain> it is a sandbox of some sort too... but for who..
01:06:48 <L0rdBrain> ok, good
01:06:56 <L0rdBrain> so what is it?
01:07:32 <L0rdBrain> who are the people who might want to use it and make extensions for it?
01:07:44 <pavonia> I think it's more like a small OS in an OS, designed to be used for Haskell development
01:08:04 <L0rdBrain> so only haskell developers?
01:08:12 <L0rdBrain> a gui for haskell developers only?
01:08:36 <pavonia> Not only but mainly
01:09:37 <tdammers> afaik it's an IDE
01:10:58 <L0rdBrain> well, i hope it is a blend of an IDE and a windowing environment for users
01:11:04 <pavonia> But with a lots of festures like browser support, video player, etc. You usually don't need that for programming :)
01:11:09 <L0rdBrain> because honestly, that would be cool
01:11:38 <L0rdBrain> i mean if it got to be something where we could replace gnome, that would be cool.
01:11:48 <L0rdBrain> know what i mean?
01:13:33 <L0rdBrain> you know, it would be awesome if the environment actually assumed source available and let people "view source" on widgets and so on.
01:14:23 <tdammers> my $0.02 is that monolithic applications are bad
01:14:46 <tdammers> leave window management to the window manager, text editing to a text editor, compiling to a compiler, interactive coding to a REPL, etc.
01:14:58 <L0rdBrain> monolithic apps may be bad but they are what ghc generates by default
01:15:02 <Cale> Well, it's a whole collection of somewhat separate programs
01:15:12 <trap_exit> does haskell have a decent 'in-memory' db ?
01:15:17 <tdammers> L0rdBrain: ghc generates whatever you tell it to
01:15:24 <tdammers> trap_exit: acid-state?
01:15:35 <trap_exit> with a query language
01:15:38 <trap_exit> not necessairly SQL
01:15:41 <tdammers> trap_exit: or you could use sqlite bindings and use them to create an in-memory DB
01:15:45 <L0rdBrain> well thanks tdammers, maybe i should have wrote "by default" multiple times...
01:15:47 <Cale> trap_exit: http://hackage.haskell.org/package/acid-state
01:15:50 <tdammers> sqlite supports that out-of-the-box
01:16:00 <moop> basically manatee is a tiling window manager that has an integrated app launcher
01:16:17 <L0rdBrain> ah, now that makes a lot of sense moop, they should just put htat on the wiki
01:16:29 <tdammers> L0rdBrain: by "monolithic" I didn't mean "statically linked"; I meant "one large application that solves many orthogonal problems"
01:17:03 <redtricycle> reverse . take 3 . reverse $ "foobar"
01:17:06 <Cale> trap_exit: That often gets used along with  http://hackage.haskell.org/package/ixset
01:17:11 <redtricycle> ...there isn't a more idiomatic take to get the last 3?
01:17:13 <moop> L0rdBrain: you should message them on ##manatee i guess ;p
01:17:14 <redtricycle> "bar"
01:17:17 <redtricycle> that is from the cookbook
01:17:22 <L0rdBrain> there's no one in there moop
01:17:29 <tdammers> L0rdBrain: Word is monolithic; a markdown -> latex -> pdf toolchain is not
01:17:47 <trap_exit> Cale: I think that's what I want
01:17:51 <trap_exit> multiple indexes, and query
01:17:56 <altern> Hi all. Could anybody tell me what is wrong with my definition of toJSON function for a list of rosetrees?
01:17:59 <L0rdBrain> word has had support for com components and plugins since the late 90s
01:17:59 <lpaste> altern pasted “RoseTree toJSON” at http://lpaste.net/116064
01:18:10 <Cale> redtricycle: If getting the last three elements is an important operation, it means that lists are the wrong data structure.
01:18:21 <L0rdBrain> which are developed as separate apps
01:18:25 <tdammers> sure
01:18:28 <tdammers> but still
01:18:50 <tdammers> if you want to do search & replace on a word document, you have to do it in word
01:19:15 <redtricycle> I am trying to get the extension of a filename
01:19:24 <redtricycle> foobar.mp3
01:19:35 <redtricycle> after using getDirectoryContents
01:19:51 <Cale> redtricycle: http://hackage.haskell.org/package/filepath :)
01:20:14 <Cale> takeExtension :: FilePath -> String
01:20:23 <tdammers> > takeExtension "foobar.mp3"
01:20:25 <lambdabot>  Not in scope: ‘takeExtension’
01:20:28 <osfameron> tdammers: there are libraries to handle the various Word formats also (the Horrible Document Format stuff in Java, and something in Perl, probably others too)
01:20:29 <tdammers> pity
01:20:31 <redtricycle> ah...
01:20:54 <tdammers> osfameron: word is still conceptually monolithic
01:21:02 <L0rdBrain> well, no, you can write a program to process the .doc, although the format is proprietary, but if you don't want to do that, you can make an extension which operates on the opened file via some likely proprietary api.
01:21:23 <tdammers> osfameron: it doesn't "Do One Thing Right", it tries to "Do Everything You Could Possibly Want"
01:21:34 <osfameron> tdammers: yeah, your point stands, mostly.  I've not looked much at the new xml based format, but it didn't sound like it was much more open
01:22:27 <L0rdBrain> well, yes, there's a barrier to entry and you can argue it is too high
01:23:04 <osfameron> yeah, that's also true.  and by trying to do everything, ends up being confusing and hard to use (this isn't just Word, my dad has got himself into terrible messes with OSX's Pages.app, I wish he'd write in Markdown but it's a hard sell...)
01:23:07 <altern>  Hi all. Could anybody tell me what is wrong with my definition of toJSON function for a list of rosetrees? http://lpaste.net/116064
01:24:01 <tdammers> extensibility is an afterthought in Word; it is the *essence* of do-one-thing-right-style Unix programs
01:24:04 <Cale> redtricycle: As it happens, the way that splitExtension works is effectively reversing twice :)
01:24:42 <Cale> altern: It might help if you told us what trouble you were having, but it looks like you have an empty list at the end there where probably an empty list doesn't belong.
01:25:17 <Cale> Also, the indentation is missing -- the instance body should usually be indented
01:25:32 <altern> Cale, here is an error I am getting:    Multiple declarations of `toJSON'
01:25:32 <altern>    Declared at: RoseTree.hs:17:1
01:25:32 <altern>                 RoseTree.hs:21:1
01:25:44 <tdammers> reading the source code for some Data.List functions is really enlightening
01:25:49 <Cale> yeah, indent it.
01:25:59 <tdammers> dropWhileEnd, particularly
01:26:21 <tdammers> shows how to do stuff relative to the end of a list without reversing twice
01:27:16 <shachaf> @where sneaky is the best
01:27:16 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
01:27:42 <Cale> Well, dropWhileEnd is a bit of a special case because it's deleting it :P
01:28:05 <Cale> and the result is the stuff from the beginning of the list
01:28:54 <Cale> But yeah, there are all sorts of clever tricks you can use
01:29:06 <Cale> some of which work better than others
01:29:48 <Cale> another is to play games with zipWith const and drop
01:30:36 <shachaf> For example the function above.
01:30:58 <Cale> oh, indeed, I hadn't noticed :)
01:31:17 <shachaf> @where sneaky2 is also nice
01:31:18 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
01:31:29 <shachaf> Though slightly more suspicious.
01:32:02 <tdammers> that one doesn't really meet the "avoid using reverse" goal ;0
01:34:39 <moop> why do you hate reverse?
01:35:18 <wei2912> inefficient, perhaps?
01:38:05 <tdammers> yeah
01:38:53 <tdammers> also requires a lot of evaluation usually, and it doesn't work at all with infinite lists for obvious reasons
01:39:06 <tdammers> but then, taking stuff from the end of an infinite list doesn't work anyway
01:40:12 * hackagebot learning-hmm 0.3.0.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.0.0 (mnacamura)
01:46:43 <osa1> "No instance for (A.MArray A.IOUArray a IO)" wat
01:48:54 <lpaste> altern pasted “RoseTree toJSON” at http://lpaste.net/116066
01:49:14 <altern> Could somebody help me with this piece of code? http://lpaste.net/116066
01:49:34 <altern> I don't know what I am doing wrong
01:53:31 <lyxia> don't you need to indent the method definitions?
01:55:13 * hackagebot rank1dynamic 0.2.0.1 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  http://hackage.haskell.org/package/rank1dynamic-0.2.0.1 (TimWatson)
02:05:13 * hackagebot distributed-static 0.3.1.0 - Compositional, type-safe, polymorphic static values and closures  http://hackage.haskell.org/package/distributed-static-0.3.1.0 (TimWatson)
02:08:21 <intrados> Why is `pure 1` not ambiguous? What instance is Haskell using and how is it deciding?
02:09:28 <Kinnison> Depends when you use it
02:09:42 <intrados> Just at the ghci prompt
02:09:51 <Kinnison> pure 1 :: (Num a, Applicative f) => f a
02:10:00 <Kinnison> at the ghci prompt it will be evaluated in IO
02:10:57 <intrados> Ah, thanks
02:15:14 * hackagebot network-transport 0.4.1.0 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.4.1.0 (TimWatson)
02:18:06 <babak__> hello.
02:18:27 <babak__> how can i find a string has a data type structure or not?
02:21:28 <ChristianS> babak__: i don't understand your question
02:22:24 <babak__> function :: String -> mydatatype ->bool
02:23:29 <pavonia> What is mydatatype?
02:23:46 <Cale> babak__: function s x = False -- problem solved?
02:24:42 <babak__> mydatatype =MessageType Int String
02:25:28 <Cale> er, okay, what's MessageType?
02:25:29 <babak__> Messagetype= "a" | "b"
02:25:37 <Cale> That... isn't valid Haskell
02:25:47 <pavonia> You can use a paring library like Parsec to write a parser
02:25:55 <pavonia> *parsing
02:27:13 <babak__> so there is no built in function to do that?
02:27:24 <babak__> i must write it myself
02:27:24 <tdammers> babak__: I think you misunderstand the meaning of the word "type" here
02:27:26 <Cale> To do what?
02:27:36 <breadmonster> wei2912: Do you need as much math as Project Euler requires to do software development?
02:27:39 <Cale> I don't think anyone understands clearly what it is that you want to do
02:28:02 <tdammers> if all you want is check whether a given string matches one of two other strings, you can simpy compare them for equality
02:28:11 <babak__> ok
02:28:14 <wei2912> breadmonster: no
02:28:20 <wei2912> breadmonster: it is certainly interestsing though
02:28:21 <tdammers> e.g. if a == "a" || a == "b" ...
02:28:32 <tdammers> or maybe if a `elem` ["a", "b"]
02:28:58 <wei2912> breadmonster: solving some haskell puzzles is, too
02:29:16 <wei2912> breadmonster: but neither are required to do software development; they just give you a new perspective
02:29:31 <breadmonster> wei2912: So how do I start with software development in Haskell?
02:29:39 <breadmonster> Is there anything like Code Complete for Haskell?
02:30:04 <wei2912> breadmonster: learn to decompose large problems into small pieces
02:30:08 <wei2912> that will require practice
02:30:48 <breadmonster> So where do I get toy programming ideas?
02:30:53 <tdammers> breadmonster: not really... many of the things from Code Complete do transfer, especially the language/paradigm agnostic best practices
02:31:08 <tdammers> breadmonster: other than that, there are a few decent learning resources
02:31:12 <tdammers> @where lyah
02:31:13 <lambdabot> http://www.learnyouahaskell.com/
02:31:15 <tdammers> @where rwh
02:31:15 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:31:22 <tdammers> that kind of stuff
02:31:22 <breadmonster> tdammers: Read that already.
02:31:30 <tdammers> so what exactly do you miss?
02:31:37 <breadmonster> tdammers: My problem is simply this.
02:31:53 <breadmonster> tdammers: I know, say Spanish, but how do I start writing stories in Spanish?
02:32:18 <breadmonster> tdammers: I can read Haskell code, I just don't know how to take that to the next level.
02:32:19 <tdammers> you just do. the first couple dozen stories are gonna be crap, but you can learn from it
02:32:36 <tdammers> and eventually, you'll start pumping out stories that are worth reading
02:32:51 <breadmonster> tdammers: Also, where do I get ideas for like projects?
02:33:02 <tdammers> solve a real problem you have
02:33:14 <breadmonster> tdammers: Is there any list of toy projects that you guys learn to do?
02:33:29 <breadmonster> tdammers: Because I'm not a CS student.
02:33:39 <tdammers> idk, my problem is more that I tend to have too many ideas, rather than not enough
02:33:45 <tdammers> anyway, start simple
02:34:03 <tdammers> my first real haskell project was a sheet music writer a la lilypond
02:34:07 <tdammers> waaaaaaay too complex
02:34:15 <tdammers> still want to redo it some time
02:34:19 <tdammers> see how much better I can do now
02:34:25 <wei2912> ehhh
02:34:32 <wei2912> my first haskell project is generalized fizzbuzz
02:34:34 <nshepperd> the easier google code jam questions are good toy puzzles imo
02:34:47 <wei2912> the harder google code jam problems are good for bashing your heda
02:34:48 <wei2912> head*
02:34:53 <nshepperd> :)
02:35:02 <wei2912> i decided to look at the world finals
02:35:04 <tdammers> anyway, I'd say avoid GUI and web for your first project; those require learning a lot of concepts upfront
02:35:05 <breadmonster> nshepperd: Okay, that's a great idea.
02:35:07 <wei2912> mind got derped out
02:35:15 * hackagebot network-transport-tests 0.2.1.0 - Unit tests for Network.Transport implementations  http://hackage.haskell.org/package/network-transport-tests-0.2.1.0 (TimWatson)
02:35:16 <wei2912> tdammers++
02:35:21 <tdammers> something like a special-purpose calculator tools would be a good first project
02:35:36 <tdammers> e.g., suppose you're into RPG's
02:35:44 <tdammers> (pen-and-paper, that is)
02:35:57 <tdammers> you could write a tool that calculates probabilities for various dice rolls for you
02:36:07 <tdammers> that kind of thing
02:36:09 <wei2912> write a random number generator
02:36:11 <breadmonster> Hmm, okay.
02:36:12 <wei2912> mersenne twister
02:36:40 <breadmonster> I really like Haskell for some reason.
02:36:47 <tdammers> wei2912: I like things that are practically useful, so I can get them some immediate real-world exposure, even if I'm the only user
02:36:51 <breadmonster> It's a challenge to write stuff in it.
02:37:04 <tdammers> breadmonster: *every* language is challenging
02:37:10 <breadmonster> But it tells me upfront how much I don't get about the code.
02:37:21 <tdammers> most other languages put the difficult parts late in the process though
02:37:37 <breadmonster> tdammers: No, like what I mean is, there have been times when I've gotten some bit of rogue Python or C++ to work.
02:37:47 <breadmonster> tdammers: Without actually knowing why.
02:37:56 <breadmonster> Haskell will never let me do that :P
02:37:57 <tdammers> yeah, that's not gonna happen a lot with Haskell
02:38:06 <wei2912> tdammers: well that's practically useful :)
02:38:27 <tdammers> (and frankly, my stance is that your code isn't really working, you just happened to find a random configuration that produces some desirable results)
02:39:15 <tdammers> my point is that haskell moves the difficult parts to the early stages of the development cycle
02:39:21 <breadmonster> tdammers: Also, is there an IDE for Haskell?
02:39:35 <Plastefuchs> breadmonster: i have a few ideas for projects i'd love to tackle that happen to be connected with other hobbies of mine. Ever had that tingle 'i could try and do that better' when you touch some program? You could just try that.
02:39:36 <tdammers> there are a few, but I don't use any
02:39:44 <tdammers> most people seem to go with vim or emacs
02:39:53 <breadmonster> Plastefuchs: Mind sharing any?
02:39:57 <lsix> Hy, do I have a simple way to define a Int like type restricted to a given range ? In Ada I would do something like "subtype Positive is Integer range 1 .. Integer'Last;". Defining every possibility with a 'data' declaration seems quite inapropriate..
02:40:05 <breadmonster> I'm actually kinda hard pressed for innovation.
02:40:36 <shachaf> No simple way.
02:41:03 <tdammers> lsix: Haskell is kind of broken that way ;)
02:41:29 <shachaf> I assume you'd want checking for things "5 :: From1to3" to be a compile-time error.
02:42:02 <wei2912> breadmonster: write busybox
02:42:04 <tdammers> ("integer blindness")
02:42:14 <wei2912> breadmonster: you'll be busy writing busybox :)
02:42:18 <breadmonster> wei2912: Busybox?
02:42:40 <wei2912> a set of utilities bundled into a single executable
02:42:41 <tdammers> breadmonster: it's a tiny implementation of the usual Unix utilities
02:42:48 <wei2912> yeh
02:42:48 <Plastefuchs> breadmonster: I am a tabletop player, Warmachine to be specific. Each model has a card that has its stats and rules. The nice thing about the system is that a lot of things are shared (each model has a Speed stat, some models share the same rule because they are from the same faction). Those cards come with the model or you can buy an android/ios app and buy a virtual card pack. I'd love to a)
02:42:50 <Plastefuchs> figure out how to read out the card data (found out where it was stored on my phone), put all that info in a well structured DB and then go on from there
02:43:06 <lsix> it can't be compile-time. My purpose is more a declarative one to let know the API user that this type makes no sense ousite of some boudaries. I will express it with pre and post conditions to be verified
02:43:19 <Plastefuchs> breadmonster: like create an army builder website that follows the cards rules (certain models cannot be with other models), without coding that in by hand, but by reading out the info from the card
02:43:39 <Plastefuchs> breadmonster: see, rather specific :p
02:43:41 <shachaf> lsix: Are the boundaries known at compile-time?
02:43:43 <Plastefuchs> anyway, lunch time o/
02:43:49 <brianpWins> can someone give me an example of how to use the sequence function. I don’t know how to come up with a “Monadic Value” to try it.
02:44:11 <lsix> shachaf: yes
02:44:22 <shachaf> You could probably make a type with a smart constructor.
02:44:35 <breadmonster> wei2912: That's actually a brilliant idea.
02:44:35 <tdammers> > sequence [ putStrLn "Hello", putStrLn "world" ]
02:44:36 <lambdabot>  <IO [()]>
02:44:38 <shachaf> What sort of behavior do you want for converting to it, for (+), etc.?
02:45:01 <breadmonster> wei2912: I'll do that, thanks.
02:45:09 <tdammers> > sequence $ map putStrLn [ "Hello", "world" ] -- more useful example
02:45:11 <lambdabot>  <IO [()]>
02:45:23 <wei2912> breadmonster: i'll be willing to embark on it with you :)
02:45:30 <wei2912> it's a nice way to learn haskell
02:45:35 <sivteck> > sequence [Just 2, Just 32, Just 21]
02:45:35 <wei2912> and any language for that matter
02:45:37 <lambdabot>  Just [2,32,21]
02:46:11 <brianpWins> thanks!
02:46:27 <keko-2> > sequence [Just 2, Just 3, Nothing]
02:46:29 <lambdabot>  Nothing
02:46:38 <lsix> shachaf: I am 'just' specifiying a discretisation of a known domain (latitudes and longitudes) into cells. It is a convention to name a cell representing an area on the globe to exchange across multiple applications, so the boundaries are part of the 'spec'
02:47:00 <breadmonster> wei2912: That's awesome, thanks!
02:47:18 <wei2912> keko-2: interesting, i'd have thought that'd give Just [2, 3]
02:47:42 <shachaf> lsix: It might be better to just hand-write a specific type for that with a smart constructor.
02:47:50 <shachaf> wei2912: Nothing is like an exception.
02:48:02 <wei2912> shachaf: i see.
02:48:06 <shachaf> do { x <- Just 2; y <- Just 3; z <- Nothing; return [x,y,z] }
02:48:26 <CatKiller> Hi there! I'm trying to build git-annex on Ubuntu 13.10. I've apt-get install'ed dependencies and started building. However I'm getting a build error in haskell: Could not find module `Control.Monad.Catch' Perhaps you meant Control.Monad.CatchIO. It sounds like an incompatible Haskell version. I'm having a hard time figuring out whether my Haskell version is too new or too old here.
02:48:27 <shachaf> foo :: Maybe A is either a value of type A, or nothing.
02:48:51 <lsix> shachaf: Thanks, I'll look into this way
02:48:52 <CatKiller> Or maybe there's a way with cabal to install that "monad" library of the correct version
02:48:58 <shachaf> But it can *also* be thought of as a "computation"/"action" which either yields a value of type A or throws an exception.
02:49:51 <tdammers> Maybe is the simplest form of error handling
02:50:21 <tdammers> Just -> things went according to plan; Nothing -> something unspecified went wrong
02:51:20 <tdammers> but anyway, if you want to harvest all the Just values and discard the Nothings from a list of Maybes; catMaybes
02:51:30 <tdammers> > catMaybes [ Just 1, Just 2, Nothing ]
02:51:32 <lambdabot>  [1,2]
02:52:15 <tdammers> hmm, my gut feeling says there must be a more general function for that
02:53:18 <geekosaur> CatKiller, http://hackage.haskell.org/package/exceptions
02:54:07 <CatKiller> geekosaur: Thanks, going to try to install that
02:55:13 <CatKiller> geekosaur: Funny this isn't installed in the distribution package
03:04:22 <dmwit> > mconcat ((:[]) <$> [Just 1, Just 2, Nothing])
03:04:23 <lambdabot>  [Just 1,Just 2,Nothing]
03:04:52 <dmwit> > mconcat (fmap fmap fmap return [Just 1, Just 2, Nothing])
03:04:54 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
03:04:54 <lambdabot>    arising from a use of ‘M429759501323034256114322.show_M4297595013230342561...
03:04:54 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
03:04:54 <lambdabot>  Note: there are several potential instances:
03:04:54 <lambdabot>    instance [safe] GHC.Show.Show a =>
03:05:04 <dmwit> > mconcat (fmap fmap fmap return [Just 1, Just 2, Nothing]) :: Maybe [Integer]
03:05:05 <lambdabot>  Just [1,2]
03:05:27 <dmwit> :t mconcat . fmap fmap fmap return
03:05:28 <lambdabot> (Monoid (f (m a)), Functor f, Monad m) => [f a] -> f (m a)
03:06:46 <dmwit> :t traverse
03:06:47 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:11:06 <prinsen> Is there any simpe way of applying a monadic action a -> m b to a Map a and get a m (Map b)?
03:11:31 <prinsen> lol
03:11:40 <sbrg> I hope bos replies and lets us update the RWH examples
03:11:54 <blair1> Does anyone know if there is a RTS flag to redirect profiling information to a specific file? I can't find anything in the GHC manual.
03:13:07 <CatKiller> Is the haskell compiler quite memory hungry in general?
03:13:15 <CatKiller> I'm building a moderately small haskell project
03:13:21 <CatKiller> and the compile takes 4GiB of RAM
03:13:30 <CatKiller> actually more, 6GiB
03:13:35 <pavonia> prinsen: You'll probably find something in Data.Traversable
03:14:02 <geekosaur> CatKiller, it can be, although usually the most memory-hungry step is linking
03:14:35 <prinsen> dmwit: you are a psycic
03:14:46 <CatKiller> geekosaur: I'm at the "cabal configure" stage which is particularly intense ;)
03:14:47 <sbrg> Does it not just take as much RAM as it can to speed up the process? I have never in my entire time as a haskeller run into memory problems while compiling haskell projects.. not even the gigantic libraries. They've all worked on even my very shitty laptop
03:15:16 * hackagebot sfmt 0.1.0 - SIMD-oriented Fast Mersenne Twister(SFMT) binding.  http://hackage.haskell.org/package/sfmt-0.1.0 (HirotomoMoriwaki)
03:15:47 <geekosaur> you may be able to limit the heap size with the GHCRTS environment variable
03:15:53 <wei2912> is it possible to pattern match on a polymorphic type
03:15:59 <geekosaur> no
03:16:33 <CatKiller> geekosaur: Not so much an issue, just added swap, was more curious. Anyways tons more errors, I'm going to give up on the compile :) Too complicated
03:16:45 <sbrg> CatKiller: which project is this?
03:16:57 <CatKiller> sbrg: git-annex
03:17:07 <haasn> I've never seen a “moderately small haskell project” that takes 6 GiB RAM to error out during configuration
03:17:19 <sbrg> CatKiller: ah
03:17:32 <sbrg> is git-annix still actively maintained?
03:17:34 <sbrg> annex*
03:17:40 <sivteck> yes
03:17:45 <CatKiller> sbrg: With Ubuntu I already had to fix 3 or 4 compile errors with their Makefile. I think it'd probably work if I had a proper haskell environment
03:17:48 <CatKiller> Yes it is
03:18:00 <CatKiller> But I suppose I may have "wrong" versions of Haskell etc
03:18:07 <geekosaur> git-annex is not a small project
03:18:11 <sivteck> GHC*
03:18:14 <CatKiller> not huge either
03:19:20 <haasn> I just built git-annex. It took 1 minute and 5 seconds, and GHC consumed about 800 MiB in the process.
03:19:39 <CatKiller> haasn: It was the "cabal configure" that was really hurting
03:19:49 <CatKiller> my guess is that I'm missing a ton of libs
03:19:59 <CatKiller> which a "normal" haskell user would already have
03:20:08 <geekosaur> I imagine. just looking at the hackage page, I imagine it's giviing cabal's constraint solver a workout
03:20:15 <CatKiller> my haskell environment is fresh and came from "apt-get" so maybe not the best
03:20:49 <CatKiller> Should I have installed haskell from source actually, instead of Ubuntu's version? I know for Python it makes no difference
03:21:00 <CatKiller> since Python is fairly compatible between versions
03:21:04 <haasn> I don't think “cabal configure” would behave much differently if you're missing dependencies
03:21:19 <haasn> Doesn't the package for “git-annex” include its dependencies, though?
03:22:13 <haasn> CatKiller: Depends on the project. Most projects should be compatible with 7.8, 7.6 and 7.4. If your version is older than that, I'd expect issues
03:22:29 <CatKiller> haasn: Possible, let me check again what cabal was complaining about
03:22:32 <haasn> Although 7.4 is getting dated..
03:22:36 <intrados> CatKiller: There ought to be a way to install from Debian unstable into Ubuntu, right?
03:22:46 <CatKiller> intrados: yup
03:23:02 <CatKiller> How can I check the Haskell version? I could check the compiler version, is that it?
03:23:07 <haasn> ghc --version
03:24:01 <sivteck> there are PPAs for ubuntu: https://github.com/bitemyapp/learnhaskell#ubuntu
03:24:05 <CatKiller> 7.6.3, recent enough so
03:25:31 <CatKiller> Quick question, "cabal configure" complains that: package tls-1.1.2 requires mtl-2.1.2
03:25:36 <CatKiller> even though I do have this library
03:26:03 <CatKiller> cabal install mtl: All the requested packages are already installed: mtl-2.2.1
03:26:12 <CatKiller> oops I get it now
03:26:14 <CatKiller> 2.1.2
03:26:14 <calvinx> how can I type this in ghci as multiline code?  http://lpaste.net/116067
03:26:27 <tasker> hm did persistent change how keys work recently ?
03:27:07 <intrados> calvinx: :{ code \n code }:
03:27:09 <CatKiller> So it seems that my haskell install is full of old libraries
03:27:15 <calvinx> ok
03:28:15 <haasn> CatKiller: try cabal install --only-dependencies git-annex
03:28:50 <CatKiller> haasn: Trying now
03:28:51 <intrados> calvinx: Sorry :{\n code \n code \n:}
03:29:30 <CatKiller> haasn: Seems to be another dependency issue: https://bpaste.net/show/ded1c78250a8
03:29:32 <haasn> If you're planning on using cabal-install to build packages, it might be a good idea to learn about how to set up sandboxes to avoid version conflicts. cabal-install isn't very smart about having separate versions of the same thing installed.
03:29:55 <CatKiller> I'm thinking I might be better off installing a recent version of haskell after purging the existing one from Ubuntu
03:30:24 <calvinx> Ah ok… I couldn’t get out of the enclosed.
03:30:26 <haasn> That might also be a good idea. I wouldn't trust Ubuntu to get anything right.
03:30:42 <calvinx> It was “:}”, not “}:"
03:31:50 <haasn> CatKiller: I'm not 100% sure, but judging by the paste it does seem like Ubuntu's version of libraries is simply too old for this version of git-annex
03:32:10 <haasn> So either you need to downgrade git-annex or upgrade the rest of the world
03:32:30 <CatKiller> haasn: Seems to. Now ubuntu is not letting me remove haskell ;) I'm going to nuke Haskell from ubuntu and install a proper version
03:33:08 <haasn> For the best Haskell packaging experience(tm), try NixOS :)
03:33:17 <haasn> (Disclaimer: I haven't used NixOS)
03:34:50 <CatKiller> haasn: Sounds like the packaging tool is good, but I do like Python pip though...
03:37:02 <haasn> I'm using portage to handle my Haskell stuff personally, which has some issues but handles 90% of Haskell packages fine - and certainly better than the naive cabal-install
03:37:23 <agocorona> I´m testing a docker instance for development
03:37:25 <haasn> In my subjective experience things seem to work best if you just always make sure to stay on the latest version of everything
03:38:34 <sivteck> true
03:42:17 <agocorona> docker permits to leave to others to solve the cabal hell. Do I beed ghcjs installed? I just import an instance that has it.
03:43:32 <osa1> is there a --skip option in hspec? I can't see it in --help but just to make sure ...
03:43:52 <agocorona> the docker instance can compile and test my host code transparently by mapping folders of the host to another folder in the docker instance
03:44:03 <tasker_> has anyone got docker working with stuff like ghc-mod in emacs ?
03:45:27 <agocorona> you can do it by running emacs by redirecting the Xwindows display
03:45:53 <agocorona> emacs would run in the docker instance
03:47:38 <agocorona> there are examples: https://registry.hub.docker.com/u/rogaha/docker-desktop
03:48:59 <agocorona> the added advantage is that this makes possible remote graphical sessions trough ssh with docker instances in the cloud
03:49:28 <agocorona> I have tested the idea with leksah
03:50:55 <brianpWins> can i get another example. How to perform function x or function y if the item in a set it even or odd
03:51:15 <brianpWins> ie 1..5 evens get (+10) odds get (+100)
03:53:01 <CatKiller> Now that I've installed a recent version of haskell (binary for debian/Ubuntu found on the website) I get some interesting stuff
03:53:03 <CatKiller> https://bpaste.net/show/5972c4bc0315
03:53:29 <CatKiller> it's only asking me for a few libraries. Bit hard though to figure out their names, I have the errors but it won't tell me which libs are missing exactly
03:54:19 <tasker_> Could anyone point me to a good explanation of type families ?
03:55:13 <ddellacosta> working on a homework assignment, and I'm confused about what the answer should be.  It's asking about some characteristics of IO String, and two of the possibilities distinguish between side-effecting always vs. sometimes side-effecting (I've ruled out the other options).  It seems like one can't always assume that it would be side-effecting--am I mmistaken?
03:56:23 <ddellacosta> that is, is it implicit in anything with IO in the type signature that it would *always* be side-effecting?  Seems like you could simply...have it not produce side-effects.
03:56:26 <Kinnison> I think you have to always assume the possibility of side-effects
03:56:45 <sivteck> tasker_, http://dev.stephendiehl.com/hask/#type-families
03:56:59 <ddellacosta> right, but possibility is different from always, that's what I'm trying to wrap my head around (and what distinguishes the two answers)
03:57:12 <sivteck> (it's more of a reference though)
03:57:25 <speak> ddellacosta: You don't _have_ to have side-effects in your IO types
03:57:28 <tasker_> ddellacosta: I would have assumed that String is guarenteed not to have side effects, IO String is not
03:57:48 <ddellacosta> speak: that's my intuition about it too
03:57:58 <brianpWins> How does one check the time for something like: h g f = (f . g) $ f
03:58:00 <speak> ddellacosta: But if it never has side-effects, you can just remove the IO type (somebody correct me if I'm wrong)
03:58:09 <speak> I mean if you're making a type yourself
03:58:10 <Kinnison> ddellacosta: If the question is saying "Given something of type IO String, should you always assume side-effects?" then my gut response would be "Given no other mitigating factors, yes, always assume side effects"
03:58:36 <Kinnison> speak: not always possible without unsafePerformIO fr.ex.
03:58:39 <brianpWins> I just get parse error on input “="
03:58:48 <speak> Kinnison: Alright, thanks
03:58:51 <tasker_> sivteck: thanks for that
03:59:05 <ddellacosta> hmm, okay, thanks Kinnison and speak.  Unfortunately I'm still feeling pretty unsure about this answer. *sigh*
03:59:07 <k00mi> > return "foo" :: IO String -- no side-effects
03:59:15 <lambdabot>  <IO [Char]>
03:59:39 <Kinnison> ddellacosta: Pick one or the other, and then justify your answer -- that's got to be better than just picking one at random and hoping it's what your tutor expected.
03:59:44 <speak> ddellacosta: What are you ACTUALLY thinking about? Like why are you pondering about this? Are you making something or using something with an IO type?
04:00:02 <ddellacosta> Kinnison: unfortunately this is a simple yes or no multiple choice, and I'm having trouble getting at what the professor intended here
04:00:04 <brianpWins> ddellacosta: I see you’re doing FP101x as well.
04:00:08 <ddellacosta> brianpWins: yes. :-)
04:00:33 <ddellacosta> speak: yeah, it's just a (sneaky) multiple-choice question
04:00:33 <Kinnison> ddellacosta: Do you have an opportunity to take a more complete answer to your professor and use that as a lever to get them to explain enough for you to pick one or the other?
04:00:50 <ddellacosta> Kinnison: naw, we're just talking about a MOOC here. :-)
04:00:57 <Kinnison> I have no idea what a MOOC is :-(
04:01:10 <speak> ddellacosta: Maybe even type out the exact question here, since we can't be sure your interpetation of the question is correct
04:01:14 <ddellacosta> Kinnison: oh, online course.
04:01:57 <ddellacosta> speak: question: "An expression of type IO String denotes:" here are the two options I've narrowed it down to: "A computation that always causes side-effects" and "A possibly side-effecting computation that, if it terminates, produces a value of type String"  I'm leaning toward the latter.
04:02:41 <speak> ddellacosta: Okay NOW the answer is easy
04:02:43 <speak> The latter :P
04:02:44 <ddellacosta> it certainly will return a String, and, per what k00mi illustrated above, that it certainly may *not* have side-effects.
04:02:51 <ddellacosta> yeah okay, I'm probably overthinking it
04:02:54 <ddellacosta> let's see
04:03:05 <speak> Yes I think so, but now if you have specific questions, it'll be easier to answer them
04:03:08 <ddellacosta> and, there we go.  thanks speak. :-)
04:03:50 <ddellacosta> naw, I get it now, I guess my intuition was correct (and matches what folks said here, although I get what Kinnison was saying too--one cannot assume it *won't* have side effects, obviously, and should assume it *probably* does)
04:03:58 <speak> np :)
04:04:20 <speak> Well the whole point is that it CAN have side effects, it doesn't matter if it has a side effect 1% of the time or 99% of the time
04:04:31 <ddellacosta> right
04:04:33 <speak> How often it does is irrelevant to how you handle those types
04:04:41 <Kinnison> Also it misses a subtlety of lazy IO
04:04:51 <ddellacosta> Kinnison: can you elaborate?
04:05:06 <Kinnison> Consider getContents :: IO String
04:05:18 <Kinnison> the "computation completes" in that you can use the resulting string in further work
04:05:32 <Kinnison> but the content of the string is lazily acquired from the OS during consumption
04:05:52 <Kinnison> and it's possible that the overall program may terminate before the entire possible string was consumed
04:06:08 <ddellacosta> I see!  So the point about termination is a little suspect
04:06:38 <ddellacosta> thanks Kinnison
04:06:42 <Kinnison> No problem
04:08:55 <brianpWins> ddellacosta: how have you found the course overall?
04:13:58 <ddellacosta> brianpWins: sorry, eating.  I'm liking it--challenging for me, but I'm learning a lot.  Yourself?
04:14:15 <brianpWins> Truly not a fan at all.
04:14:30 <ddellacosta> d'oh
04:14:39 <brianpWins> The only places I’m learning anything is by going over the material with a co-worker who is a big haskell proponent.
04:14:43 <ddellacosta> what's your biggest frustration?
04:15:05 <brianpWins> I think the lectures are basicly useless. He glides over topics that you’re expected to know. No ephasis on anything.
04:15:14 <brianpWins> That and the eff’n trick question
04:15:18 <brianpWins> questions
04:15:46 <brianpWins> are driving me insane. You can’t expect people to learn when you’re literally trying ti trip them up on things. It’s super frustrating.
04:15:52 <ddellacosta> yeah, some of them are like that, and what I end up doing is typing them all out and testing them in ghci to get the right answer
04:16:01 <ddellacosta> I also have the benefit of working using a functional programming language daily
04:16:08 <ddellacosta> so some thing were not such a big stretch
04:16:19 <ddellacosta> but I can *totally* see that without my previous experience it would be a lot harder
04:16:31 <ddellacosta> if I'd tried it two years ago, probably would have been a lot tougher for me
04:16:36 <brianpWins> It’s not even just harder. Without the book it would be impossible.
04:16:53 <ddellacosta> the book is critical, yeah
04:17:05 <brianpWins> and as far as the lectures go it’s basicly “Programming in Haskell” by Graham Hutton narriated by Erik Meyjer
04:17:23 <ddellacosta> hahaha...yeah, not far off. :-)
04:17:27 <speak> Erik Meyjer sounds like a familiar name
04:17:44 <speak> Oh I see
04:17:45 <brianpWins> but he just kept saying you don’t need the book you can learn everything you need to know from the lectures. But then he just breezes over concepts
04:17:47 <speak> :D
04:17:47 <ddellacosta> speak: he's responsible for LINQ basically, I think
04:17:57 <brianpWins> it’s impossible without the book.
04:18:08 <ddellacosta> speak: also: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
04:18:38 <ddellacosta> brianpWins: yeah...I don't take him all that seriously.  I think that the lectures are a good supplement to the book, and I think you need both to do the homework.
04:19:49 <brianpWins> As far as teaching goes to. His response to almost all questions are “look harder”
04:20:07 <brianpWins> I’m sorry that’s not a response. When a student needs something explained stop and explain it.
04:20:23 <speak> Sounds like a shite teacher :P
04:21:08 <brianpWins> I understand he’s supposed to be a very smart guy and I don’t doubt that. but I think he’s to advanced to try and teach a 101 class. He’s to far from the problems people at a 101 level have.
04:21:12 <ddellacosta> I suspect that it would not be a good experience for someone not exposed to Haskell or functional languages at all
04:21:14 <brianpWins> So theres no empathy
04:21:16 <matson> these videos could support the course? https://www.youtube.com/watch?v=UIUlFQH4Cvo&list=PLTA0Ta9Qyspa5Nayx0VCHj5AHQJqp1clD  ("C9 Lectures: Dr. Erik Meijer - Functional Programming Fundamentals Chapter 1 of 13")
04:22:11 <ddellacosta> matson: those are not the same vids, but don't know if they cover different material or not...could be the same
04:22:30 <ddellacosta> it's fundamentally all based on Graham Hutton's (great, in my opinion) book
04:22:55 <brianpWins> ddellacosta: That’s pretty much the ship I was in. I had a high level overview of functional concepts. but this was my first dive in to both a pure fucntional language and functional program all at once.
04:23:07 <matson> oh ok, I think those videos are about the same book. Actually Graham Hutton is in one of them :)
04:23:08 <ddellacosta> brianpWins: I think there's also a big dose of Dutch-ness going on there too. ;-)
04:23:14 <ddellacosta> matson: ah
04:23:28 <bryanedds> Dutch-hater!
04:23:49 <ddellacosta> I like the Dutch!
04:23:57 <ddellacosta> but they are smartasses, damnit
04:24:02 <brianpWins> lol
04:24:26 <speak> brianpWins: I have been on a lot of university lectures where the lecturer is an expert on the subject, but FAR from an expert as a teacher :)
04:24:34 <bryanedds> https://www.youtube.com/watch?v=QJ882QYzr-M
04:24:40 <speak> In fact more often that not that is the case
04:25:07 <ddellacosta> bryanedds: heh
04:25:13 <ddellacosta> forgot about that one
04:25:30 <brianpWins> anywho. I need to turn in for the night. I feel like i’ve vented enough now. I didn’t finish the homework. I did the lab though. I’ll do one more lab next week. It’ll bump me over a passing grade then I’m giving up on the course. I think there will be better possible ways to pick up haskell.
04:25:31 <bryanedds> hehe
04:26:05 <ddellacosta> brianpWins: yeah, I spent about six months slowly going through Haskell on my own *before* the course
04:26:22 <ddellacosta> brianpWins: so don't get discouraged--you may enjoy it a lot more if you aren't going at that pace
04:27:20 <bryanedds> MOOCs are pretty much only for people who have an unbounded amount of time to teach it all to themselves anyway
04:27:27 <brianpWins> I think I’ll give http://learnyouahaskell.com/ a try after a sufficient “cool down” period from this.
04:27:37 <ddellacosta> bryanedds: I think they are hit and miss--really depends on where you're at
04:27:51 <brianpWins> unbounded is key there. The work I’m doing is on deadlines.
04:28:01 <brianpWins> s/I’m/we’re/
04:28:12 <ddellacosta> yeah, I do agree that it's tough to do a MOOC if you have much of a life
04:28:22 <ddellacosta> for some value of "a life." :-)
04:28:30 <brianpWins> heh
04:28:40 <brianpWins> but I really must go now it’s 4:30am and I work in the morning
04:28:47 <brianpWins> cheers
04:28:51 <ddellacosta> brianpWins: goodnight!
04:35:19 * hackagebot network-transport-tcp 0.4.1 - TCP instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.4.1 (TimWatson)
04:45:20 * hackagebot product-profunctors 0.6 - product-profunctors  http://hackage.haskell.org/package/product-profunctors-0.6 (tomjaguarpaw)
04:50:20 * hackagebot yesod-gitrepo 0.1.1.0 - Host content provided by a Git repo  http://hackage.haskell.org/package/yesod-gitrepo-0.1.1.0 (MichaelSnoyman)
04:55:20 * hackagebot distributed-process-tests 0.4.1 - Tests for distributed-process.  http://hackage.haskell.org/package/distributed-process-tests-0.4.1 (TimWatson)
04:55:22 * hackagebot distributed-process 0.5.2 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.2 (TimWatson)
05:00:20 * hackagebot distributed-process-simplelocalnet 0.2.2.0 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.2.0 (TimWatson)
05:15:21 * hackagebot snaplet-recaptcha 1.0 - A ReCAPTCHA verification snaplet with Heist integration and connection sharing.  http://hackage.haskell.org/package/snaplet-recaptcha-1.0 (LarsPetersen)
05:20:01 <troydm> is this the right definition of Monad in Java? http://lpaste.net/5270620150087811072
05:21:20 <troydm> also as I see it you can mix two different Monads right?
05:21:29 <wei2912> ... in Java?
05:21:34 <troydm> let's say bind Reader monad to Writer monad
05:21:40 <troydm> wei2912: yeah in Java
05:21:46 <wei2912> i'm scared now
05:21:57 <wei2912> well unfortunately no idea
05:22:00 <troydm> well that definition allows doing that but it needs to be handled in safe manner
05:22:03 <wei2912> but what're you trying to do?
05:22:12 <wei2912> and why ask in #haskell? :P
05:22:16 <troydm> write a functional programming library in Java
05:22:23 <troydm> inspired by Haskell
05:22:38 <troydm> well I've wrote all the major parts already
05:22:42 <troydm> now I'm filling the gaps
05:22:47 <troydm> writing the Reader monad
05:23:00 <troydm> and there is where I hit a type dillema
05:25:21 * hackagebot fpco-api 1.2.0.4 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.4 (ChrisDone)
05:28:10 <ThreeOfEight> I don't get it
05:28:19 <ThreeOfEight> <B> Monad<B> bind(final Function<A,Monad<B>> f);
05:28:38 <ThreeOfEight> shouldn't there be a Monad<A> somewhere in there?
05:28:59 <n4x> I guess it is supposed to be the "self" of the object or so
05:29:03 <ThreeOfEight> oh
05:29:24 <ThreeOfEight> Right. It has been a few years since I last did OO programming
05:29:32 <ThreeOfEight> But shouldn't return be static then?
05:29:46 <ThreeOfEight> and what does the first <B> in bind do?
05:30:13 <bennofs> ThreeOfEight: .bind's return type
05:32:24 <ThreeOfEight> bind's return type is Monad<B>, is it not?
05:33:04 <Chath> ThreeOfEight: It's just saying B is a type variable and not a concrete type, I think
05:33:06 <bennofs> oh, right. didn't see that <B> you meant. then idk, I don't know any scala :p
05:33:08 <Phillemann> I feel like ret should be static, but you can't define a static function in an interface.
05:33:33 <ThreeOfEight> brr
05:33:40 <wei2912> troydm: i see, good luck with it
05:33:46 <ThreeOfEight> I think Scala does this a lot more nicely
05:33:56 <ThreeOfEight> and I think that Scala is already kind of ugly
05:34:00 <tdammers> you can cheat and implement ret as a constructor
05:34:06 <ThreeOfEight> (although their implicits are pretty great)
05:34:33 <tdammers> but that wouldn't solve the issue that it should be part of the interface
05:34:34 <Chath> Scala is both very ugly and nice at the same time, for me
05:34:48 <Chath> Pity about inference
05:35:00 <agocorona> troydm you will never impress the Java people if you don't include at least a call like createMonadInstanceFactory or longer
05:35:39 <Phillemann> agocorona: Apparently, he doesn't even use Spring or Hibernate...
05:35:43 <wei2912> lol
05:35:50 <wei2912> i suggest that we keep the language bashing to a minimum :)
05:36:01 <agocorona> just kidding
05:36:51 <haasn> ThreeOfEight: That looks suspiciously like trying to embed monads into Java/C#; which sadly isn't fully possible
05:36:57 <nshepperd> you can't really express Monad in a language like java
05:37:20 <haasn> Even if you resort to passing dictionaries manually, you can't abstract over type constructors
05:37:34 <Chath> http://docs.spring.io/spring-framework/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
05:37:37 <Chath> No comment
05:37:38 <nshepperd> though it seems instructive to try to do so to see what's missing
05:37:42 <tdammers> you can, but it would probably amount to implementing a Haskell interpreter on top of Java
05:38:15 <haasn> http://hub.darcs.net/nand/csharp/browse/MonadDict/MonadDict.cs this is my closest attempt in C#
05:38:39 * speak still has no idea what Monads are
05:38:43 <agocorona> Chath lol   (sorry)
05:39:39 <haasn> http://hub.darcs.net/nand/csharp/browse/PureIO/PureIO.cs and here is an example of Haskell's IO monad ported to C#
05:41:21 <haasn> Chath: The best bit is the word “convenient” from the description
05:43:37 <Chath> haasn: Yeah I love that part, very convenient superclass. Now if only I could figure out what word actually described what it is...
05:45:12 <agocorona> at last Haskell is syntactic sugar over an horrific core language
05:45:22 * hackagebot nsis 0.2.4 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2.4 (NeilMitchell)
05:45:28 <agocorona> but this syntactic sugar is the right one
05:45:28 <srhb>  What, not horrific at all!
05:45:40 <agocorona> (dont count this as haskell bashing)
05:45:49 <nshepperd> that looks like the "free monad of FFI operations" construction in PureIO there
05:47:18 <nshepperd> too bad ghc actually uses that State# RealWorld# madness instead
05:47:20 <agocorona> srhb: horrific to program but way better atomatically generated c code
05:47:40 <haasn> agocorona: Haskell has not been syntax sugar for C for a long time!
05:47:41 <agocorona> way better -than-
05:47:50 <haasn> Haskell is sugar for Core, which is a beautiful core language
05:47:54 <haasn> “beautiful”
05:48:46 <agocorona> beatiful as a core language true, but not as a general programming language
05:49:20 <gansteed> is there a good indent vim script for haskell?
05:49:38 <sivteck> `https://github.com/raichoo/haskell-vim
05:49:43 <sivteck> gandr, ^
05:49:47 <haasn> agocorona: Sure. It doesn't even have a type system
05:49:52 <sivteck> erm gansteed *
05:49:57 <agocorona> What i mean is that whatever the language used, it never will implement  Monads and so on so beatifully and practically as Haskell
05:50:06 <haasn> But it's elegant in its simplicity, in a way similar to the lambda calculus
05:50:08 * raichoo hands sivteck his money
05:50:19 <haasn> Most of Haskell is really just syntax sugar for four basic concepts
05:50:26 <gansteed> sivteck: thanks, let me have a try
05:50:49 <sivteck> raichoo, i have recommended this for like the 10th time now ;D
05:50:55 <haasn> Namely applying functions, creating functions, applying constructors and matching on constructors
05:50:58 <raichoo> ^^
05:51:07 <haasn> That's literally all there is to Haskell core
05:55:18 <srhb> haasn: Huh, isn't System Fc explicitly typed?
05:55:23 <srhb> I thought that was one of the selling points
05:55:41 <haasn> srhb: Oh, duh; you're right
05:55:54 <srhb> Ah, good.
05:55:54 <haasn> What I meant is it has type casts!
05:55:56 <haasn> So it's not type safe
05:56:34 <shachaf> haasn: ?
05:56:39 <tdammers> type casts can be type safe, as long as they are well-defined
05:57:56 <shachaf> Core casts aren't just arbitrary, they take an evidence argument.
05:58:22 <shachaf> Of course you can get unsafeCoerce evidence, in which case anything goes.
05:58:28 <shachaf> But that's pretty much like Haskell.
05:58:58 <tdammers> yeah
05:59:02 <gansteed> sivteck: it seems that haskell-vim has a bug in guard ?
05:59:12 <gansteed> it can not indent
05:59:14 <haasn> Ah. I just remembered the abundance of `cast` in GHC-generated Core
05:59:16 <tdammers> I'd argue that Haskell has plenty of casts, they just aren't explicitly named as such
05:59:33 <shachaf> Notice that `cast` has a thing on the right, not just on the left. :-)
06:00:00 <sivteck> gansteed, why? it indents for me when i type |
06:00:21 <haasn> Interesting
06:04:18 <gansteed> ;-<
06:04:28 <sivteck> gansteed, did you read the readme?
06:04:44 <gansteed> actually, no
06:05:11 <sivteck> :[
06:09:12 <Geraldus> Hi friends! I'm on OS X Yosemite, I have removed old versions of GHC and installed latest Haskell Platform. Now, when I try to install `hdevtools` I have issue with `transformers-compat` > ld: library not found for -lHStransformers-compat-0.3.3.4-ghc7.8.3. How can I resolve this issue?
06:24:35 <dfeuer> Can someone make GHC faster please? I want all codes compiled in less than two seconds.
06:24:54 <haasn> dfeuer: Set the target language to Haskell
06:25:03 <dfeuer> haasn++
06:25:04 <tdammers> throw more hardware at it
06:25:08 <tdammers> seriously
06:25:25 <dfeuer> tdammers, that actually only helps a little if you're only compiling one module.
06:25:32 <dfeuer> Potentially very little.
06:26:01 <haasn> Probably easier to redefine the second at that point
06:26:04 <tdammers> one module takes more than 2 seconds to compile? that must be a monster
06:26:12 <dfeuer> tdammers, since I'm currently working on only one module (Data.Sequence) that isn't likely to help.
06:26:19 <dfeuer> tdammers, yes, it takes quite a while.
06:26:22 <tdammers> huh
06:26:29 <haasn> tdammers: template haskell can get you there easily
06:26:36 <tdammers> ah, right, hehe
06:26:46 <dfeuer> It has no template Haskell, but it does contain computer-generated code.
06:26:57 <haasn> Also, type-checking certain Haskell extensions ;)
06:26:59 <dfeuer> And lots of nested types.
06:27:01 <Geraldus> Does anybody faced issue with lHStransformers-compat-0.3.3.4-ghc7.8.3?
06:27:28 <dfeuer> Even type checking it takes a few seconds, I think.
06:27:30 <haasn> I remember when some of my 10 line module would take over a minute to type-check
06:27:52 <dfeuer> haasn, that sounds like Okasaki's RPN EDSL.
06:28:41 <haasn> My use case had computations in the type system involving rational numbers
06:28:44 <Kinnison> Geraldus: You're missing a library it thought it had installed
06:28:58 <dfeuer> haasn, that's proof that you're insane.
06:28:59 <Kinnison> Geraldus: try reinstalling transformers-compat using cabal
06:29:01 <haasn> Turns out computations get slow when you're missing a way to branch without computing both sides of the branch
06:29:21 <haasn> Especially if those branches involve finding least common multiples
06:29:21 <dfeuer> Oof.
06:29:50 <dfeuer> Least common multiples in some sort of Church encoding, I imagine?
06:29:51 <tdammers> and people call me crazy for running barefoot in the snow
06:29:52 <tdammers> sheesh
06:30:03 <Geraldus> Kinnison: I understand that, cabal says it will intstall new version of trnasformers (0.4.0.2), and I have 0.3.0.0 now. Is it OK?
06:30:08 <haasn> dfeuer: Church encoding is actually quite difficult when you don't have lambdas
06:30:11 <Kinnison> Geraldus: No idea :-(
06:30:20 <Kinnison> Geraldus: I'm not an OS X user, and I've never tried replacing my entire haskell platform
06:30:21 <n4x> at least it halts, right?
06:30:30 <haasn> dfeuer: but hand-rolled from peano nats nonetheless, yes
06:30:40 <dfeuer> tdammers, oh, you also like to go barefoot? How far can you get barefoot in the snow? (I'm wimpy--I'd run around the yard that way for a minute, but wouldn't try it for long.)
06:30:48 <Geraldus> Kinnison: I heared, that transformers is source of a lot of troubles (
06:30:51 <haasn> I decided to scrap it until we get a lazy type system or something.
06:30:53 <dfeuer> Oh right, haasn, that's what I meant, but it's early for me.
06:31:13 <dfeuer> Lazy ... type ... system ... Scary thought.
06:31:30 <Geraldus> Ok, let's see what will it give.
06:32:42 <Geraldus> Well, it helped for now. Hope this will not bring more troubles later. Thanks, Kinnison!
06:34:01 <tdammers> dfeuer: dunno, yesterday was the first snow since I started doing this... 12.5 km, but I've done up to 34 km in better weather
06:34:52 <dfeuer> Wow. Nice. Yeah, I've taken long hikes barefoot, but never in the snow.
06:35:08 <dfeuer> Now I'll try to stop the off-topicness.
06:35:14 <tdammers> oh right, this is #h
06:35:18 <tdammers> :x
06:38:32 <agocorona> Geraldus: probably you will have a lot of warnings and death threats but everithing will work fine
06:39:42 <Geraldus> Unfortunately, I still do not able to install `ghc-mod`
06:40:24 * hackagebot servant 0.2 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-0.2 (AlpMestanogullari)
06:40:26 * hackagebot servant-client 0.2 - automatical derivation of haskell functions that let you query servant webservices  http://hackage.haskell.org/package/servant-client-0.2 (AlpMestanogullari)
06:43:40 <Denommus> I wonder if I can use yesod only for a web service (without producing HTML), and having the HTML client a single-page application written in GHCJS
06:44:17 <Kinnison> Denommus: I imagine yesod would be quite prepared to be a json or xml web service without too much hassle :-)
06:44:46 <Denommus> Kinnison: so the main question would be the GHCJS part, right?
06:45:24 * hackagebot servant-docs 0.2 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.2 (AlpMestanogullari)
06:45:26 * hackagebot servant-jquery 0.2 - Automatically derive jquery-based javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.2 (AlpMestanogullari)
06:45:51 <Kinnison> Denommus: I'm afraid I have no experience with GHCJS :-(
06:46:51 <magthe> Is there something like Data.Conduit.Blaze.builderToByteString for Data.ByteString.Builder?
06:46:57 <agocorona> Denommus: there are examples of this using Fay instead of ghcjs
06:47:04 <luite> Denommus: michael snoyman gave a talk which included an example for typesafe routing and ghcjs
06:48:14 <Denommus> luite: I'll check it
06:48:28 <Geraldus> Denommus: hi, I'm currently writing single page web app, all javascript is written in Haskell using GHCJS
06:49:05 <Geraldus> I realy satisfied with GHCJS
06:49:29 <agocorona> what about the size of the JS code generated?
06:50:23 <Denommus> agocorona: it's somewhat big, but on a SPA it's just downloaded once
06:51:17 <Kinnison> is GHCJS' output compatible with asm.js ?
06:51:55 <Denommus> Kinnison: I don't think so, they're different projects. You'd better wait for the LLVM backend instead
06:52:03 <Geraldus> agocorona: well, my current script is about 3.5 MiBs, but this is because of RTS majorly. But it works fast
06:52:17 * Kinnison is confused, asm.js is about a subset of JavaScript which web browser JS engines can JIT more effectively
06:52:30 <Geraldus> Kinnison: I have never heared about asm.js :(
06:53:07 <luite> Denommus: i've been working on a new codegen that should do a better job on output size, but i had to put that on hold for a while to make ghcjs compatible with ghc 7.10 and get all the required upstream changes merged
06:53:14 <Kinnison> Geraldus: http://asmjs.org/
06:53:17 <agocorona> haste produces much smaller JS files but I´m afraid that it received much less attention
06:53:28 <luite> Kinnison: no it's not asm.js
06:54:28 <Geraldus> I've tried Fay before GHCJS, all I can say, GHCJS gives you almost unlimited freedom when you're writing JS code. This is so amazing!
06:54:57 <luite> Kinnison: the reason is that too much would have to be ported from the native rts for that, and it'd make interaction with the js environment more complicated
06:55:08 <Kinnison> luite: :-(
06:55:51 <luite> Kinnison: perhaps later, but it'd take a fair bit of effort
06:56:37 * Kinnison nods, better to have it working than to worry about asm.js for now
06:56:47 <luite> Kinnison: asm.js wouldn't magically be faster, it'd mean that you can't allocate js objects while running haskell code anymore, and you'd need to port/compile the whole storage manager to js
06:56:59 <Kinnison> I see
06:59:04 <agocorona> luite: are there room for improvement of ghcjs in terms of the sizeo of the generated JS code?
06:59:05 <luite> one reason it could be faster is that the js code often consists of lots of short functions. often functions are the boundary for type information and assumptions for (method) jit compilers, with statically checked argument types these could often be much cheaper
06:59:12 <sinelaw> haste gives nice output
06:59:38 <Kinnison> luite: OOI do you know if the output of ghcjs is compatible with duktape ?
06:59:49 <agocorona> sinelaw: yes
07:01:48 <agocorona> purescript is also a fantastic strict haskell . and generates readable javascript
07:01:50 <luite> agocorona: sure a lot. haste forks the libraries while ghcjs sticks witch small patches to support the node.js/browser platform, which makes the starting point much harder. additionally ghcjs does a different translation to js objects and does cps transformation of the code (for preemptive threads).
07:02:08 <Denommus> Kinnison: I mixed it up with emscripten, sorry
07:02:13 <Denommus> Kinnison: and then my connection dropped :P
07:02:46 <Kinnison> Denommus: :-)
07:03:07 <luite> agocorona: this gives much more predictable memory consumption, but unfortunatly it means that the code is bigger to start with, and the optimizer has to work harder. i found a few bugs in the optimizer earlier this year and had to disable some of the optimization rules
07:03:58 <luite> that's why i did a rewrite, which adds types to the intermdiate language, but it's not quite done yet. it also contains the infrastructure for source maps and minification in the prettyprinter
07:05:43 <agocorona> to have source maps would be very nice
07:06:47 <luite> agocorona: readable js is not really a goal for ghcjs, ghc does rather extensive transformations on the code already, at best you can make something that looks similar to the core (haste does this), but i found it too unpredictable in memory use, and you lose the ability to do heap profiling and implement preemptive threads efficiently
07:06:52 <agocorona> the closure compiler could help on that?
07:07:24 <luite> closure compiler does help, but to map the js code back to the haskell code, you need to supply it with a source map in the first place
07:08:03 <luite> ghc 7.8 doesn't keep enough information in the intermediate language for that, but there's a patch for 7.10 that should be enough
07:08:36 <luite> it'll probably get merged, but it's still being reviewed i think
07:08:57 <tdammers> if anything, I think it would be nice to somehow be able to extract original source position from error dumps
07:09:03 <vanila> to get readable output an interpreter might be better than a compiler
07:09:19 <tdammers> a bit like how gdb can throw you back into the original source while debugging a binary
07:09:40 <luite> tdammers: right, that's what GHC gets the infrastructure for, for DWARF metadata
07:09:57 <tdammers> hmm, that sounds promising
07:10:25 <luite> tdammers: for GHCJS it means that i can get source location annotations, and in the new codegen i keep them around until the end, in the prettyprinter, so i can produce a source map with the js
07:10:37 <tdammers> that's cool
07:10:42 <luite> even if the js is transformed and optimized in the middle
07:10:47 <tdammers> yeah
07:10:52 <luite> should a least give an approximate location
07:11:13 <tdammers> but then, the resulting JS isn't supposed to ever fail, right? :D
07:11:25 <luite> but the same goes for the DWARF info, with inlining, constant folding etc, not everything might have an exact location in the source anymore
07:11:28 <sinelaw> luite, that's awesome
07:11:47 <sinelaw> luite, does it work already?
07:12:22 <tdammers> yeah, obviously
07:12:46 <agocorona> that´s the goal.  good source maps.  a lazy language can never generate readable JS files.
07:12:48 <luite> sinelaw: nope, i've not pushed this stuff yet, had to get the other bits ready for 7.10 first
07:13:16 <sinelaw> luite, let the interwebz know when it does
07:13:28 <agocorona> purescript in the other side is strict. And I found how pretty JS can create, since the execution model is the one of JScript
07:13:30 <luite> agocorona: right, purescript being strict makes it much easier in this respect
07:14:12 <sinelaw> Brave new world, it is
07:14:41 <chrisdone> hmmm
07:14:46 <luite> yeah i think purescript fully curries everything still, doesn't it? rather than eval/apply (which would be more like check/apply since there's nothing to eval in a strict language)
07:14:50 <sinelaw> luite, does GHCJS produce code that uses JS dynamicity (e.g. assigning multiple types to the same variable throughout it's lifetime?)
07:15:01 <luite> that also makes a pretty big difference in readability
07:15:08 <agocorona> but purescript is not (exactly) haskell
07:15:19 <luite> oh i guess it doesn't have to though...
07:15:25 * hackagebot lambdacube-core 0.2.0 - LambdaCube 3D IR  http://hackage.haskell.org/package/lambdacube-core-0.2.0 (CsabaHruska)
07:15:28 * hackagebot lambdacube-edsl 0.2.0 - LambdaCube 3D EDSL definition  http://hackage.haskell.org/package/lambdacube-edsl-0.2.0 (CsabaHruska)
07:15:57 <vanila> would a haskell interpreter be efficient enough in the web browser?
07:16:29 <agocorona> vanila: there is a purescript compiler running in the browser, in a alfa state
07:16:39 <luite> sinelaw: in most cases the types will be the same for every call, to make inline caching as efficient as possible
07:16:43 <agocorona> it is more or less an interpreter
07:17:13 <sinelaw> luite, I'm working on a type checker for JS
07:17:15 <luite> sinelaw: but there are some optimizations where there's an unboxed representation for some constructors
07:17:22 <sinelaw> luite, would be interesting to run it on GHCJS output
07:17:40 <sinelaw> luite, do you have some sample output? Too lazy to bring up the toolchain here :)
07:17:43 <luite> sinelaw: do you do global dataflow analysis?
07:18:08 <luite> sinelaw: http://hdiff.luite.com/tmp/try-purescript.jsexe/
07:18:10 <sinelaw> luite, nope. I assume a subset of JS where some yucky stuff is not allowed, making "regular" inference possible
07:18:28 <sinelaw> luite, that's purescript or ghcjs?
07:18:37 <luite> sinelaw: it's the purescript compiler compiled to js, with ghcjs
07:18:57 <sinelaw> luite, so what I get on the RHS is purescript output, not GHCJS output, right?
07:19:01 <vanila> what's global dataflow analysis? is it related to CFA?
07:19:13 <luite> sinelaw: no look at the source code for that page :)
07:19:24 <luite> sinelaw: the right side is the compiled purescript code on the left
07:19:45 <sinelaw> I see
07:19:57 <sinelaw> luite, so it serves as an alternative compiler for purescript
07:20:49 <athan> Hey folks, `cabal haddock` is throwing an error, telling me it can't find a .hi file (or it's corrupt) in one of my local libraries that I `cabal sandbox add-source ~/dev/foo` included it. How would I go about fixing this?
07:21:04 <athan> `cabal install` doesn't give me any errors in either package
07:21:40 <luite> sinelaw: not an alternative, it's really just psc compiled with ghcjs (only difference is how it starts compiling, it's called directly with the code from the codemirror editor, rather than using the command line args to read a file)
07:21:53 <agocorona> I dream that some day the big people of industry would sit down to choose a second language for the browser and this is purescript. Haskell is too far from JScript
07:22:26 <sinelaw> luite, I'm confused. The purescript compiler, compiles purescript to JS. GHCJS compiles Haskell to JS. what does this page do?
07:22:51 <luite> sinelaw: the page translates purescript to js
07:23:12 <sinelaw> agocorona, unfortunately they are going for ATScript instead
07:24:12 <juanpablo_> What does the ~ symbol means in types? Google is not helping...
07:24:18 <luite> sinelaw: the all.min.js file is the one you should be looking at, that's psc compiled with ghcjs
07:24:45 <luite> sinelaw: i apologise for choosing a confusing example ;)
07:24:52 <sinelaw> luite, heh
07:24:55 <agocorona> sinelaw:  that is today. yesterday was dart, tomorrow who will know
07:24:56 <sinelaw> luite, link?
07:25:07 <luite> sinelaw: see the html source code for that page
07:25:26 * hackagebot lambdacube-gl 0.2.0 - OpenGL backend for LambdaCube graphics language (main package)  http://hackage.haskell.org/package/lambdacube-gl-0.2.0 (CsabaHruska)
07:25:28 * hackagebot lambdacube-samples 0.2.0 - Samples for LambdaCube 3D  http://hackage.haskell.org/package/lambdacube-samples-0.2.0 (CsabaHruska)
07:25:39 <Geraldus> juanpablo_: wait a second. I know but my English is too poor to explain, I'll try to provide you a link
07:25:42 <sinelaw> Holy Mother of Moses
07:25:47 <sinelaw> that's a big file.
07:25:53 <luite> sinelaw: psc is big :p
07:25:53 <juanpablo_> Geraldus: thanks :)
07:26:26 <sinelaw> luite, ooh. you use goog?
07:26:34 <sinelaw> or is that psc stuff
07:26:50 <luite> sinelaw: i'm doing some simple type inference in the new ghcjs too, can show you later, or ask you about better techniques possibly
07:27:06 <sinelaw> luite, cool. what for though?
07:27:15 <luite> sinelaw: foreign code imports
07:27:39 <luite> it keeps track of all types of the code it generates from haskell, this makes it a bit more complete
07:28:08 <sinelaw> luite, you mean importing foreign JS?
07:28:11 <sinelaw> or foreign HS?
07:28:16 <luite> sinelaw: foreign js
07:28:16 <sinelaw> (whatever that may mean)
07:28:36 <luite> https://github.com/ghcjs/ghcjs-examples/blob/master/try-purescript/Main.hs see for example this
07:28:39 <sinelaw> so you use it to check that your generated code interacts correctly with the ff-js?
07:29:14 <luite> the [js| ... |] things get spliced into the generated js
07:30:01 <luite> sinelaw: yes and to make the optimizer more effective on the boundaries
07:30:14 <sinelaw> luite, cool
07:30:37 <luite> sinelaw: in the future the plan is to make the link time optimizer use this for better deduplication of the code
07:30:40 <sinelaw> luite, the inference I'm buliding is strict - doesn't really accomodate dynamic-y  behaviors
07:30:52 <sinelaw> strict in the sense of type checking
07:30:57 <sinelaw> (not runtime evaluation)
07:31:09 <luite> if you dedupe one function that's syntactically the same as another, it can be less efficient if it uses different types
07:31:15 <agocorona> the javascript world is going at crazy speeds. In the time of this conversation three JavaScript solution for everithing have been created, imparted TED conferences and died
07:31:46 <sinelaw> ~js function(x) { return x; } return f
07:31:46 <annoyabot> :1:34: Error: Unbound variable: '"f"'
07:31:51 <sinelaw> ~js function f(x) { return x; } return f
07:31:51 <annoyabot> (a -> a)
07:31:55 <sinelaw> luite, ^^
07:32:33 <vanila> ~js function f(x) { return x(x); }
07:32:34 <annoyabot> :1:26: Error: Occurs check failed: c in (c -> e)
07:32:46 <Geraldus> juanpablo_: sometime compiler could not be certain about what type will be of expression, ~ says compiler that this *will* be exactly that type if I not mistaken. I'm still searching link.
07:32:53 <sinelaw> vanila, no infinite types (yet)
07:33:00 <tdammers> agocorona: I think the JS world is about as fast and productive as twitter
07:33:06 <tdammers> lots of noise
07:33:13 <luite> agocorona: meh as long as javascript solutions resemble random walks (the drunk man might not be a sailor this time) i'm not too worried ;)
07:33:14 <vanila> that's really cool sinelaw!
07:33:23 <sinelaw> thanks :)
07:33:40 <Geraldus> juanpablo_: I've read about it in GHC documentation, but it's really tricky to find a link
07:33:55 <sinelaw> luite, I've found the tricky part was to deal with mutability (surprise surprise)
07:33:58 <luite> sinelaw: ah that's cool. ghcjs has a relatively simple type lattice
07:34:00 <agocorona> tdammers:  everithing in less that 120 k racters
07:34:06 <agocorona> than
07:34:40 <sinelaw> luite, right now I have basic HM + row type polymorphism, plus some restrictions due to mutability
07:35:01 <luite> sinelaw: it only cares about some primitive types and special objects
07:35:08 <statusfailed> my ld has no -lgmp flag. how do i get cabal to compile stuff?
07:35:13 <luite> the other things are just 'some object'
07:35:16 <Benzi-Junior> hey does anyone know of a clever way to check the frequency of every element occuring in a list
07:35:23 <sinelaw> the row polymorphism is nice...
07:35:28 <c_wraith> Benzi-Junior: of course. :P
07:35:37 <sinelaw> ~js function f(obj) { return obj.length; } return f
07:35:38 <annoyabot> ({length: b, ...} -> b)
07:35:45 <sinelaw> luite, ^
07:35:59 <c_wraith> :t map (head &&& length) . group . sort
07:36:00 <lambdabot> Ord c => [c] -> [(c, Int)]
07:36:07 <c_wraith> Benzi-Junior: ^
07:36:10 <statusfailed> (actually i compiled a newer libgmp and want to use it but its in a nonstandard location)
07:36:23 <luite> sinelaw: i should get some work done now, but i might ask about this later. are you writing this in haskell by teh way?
07:36:24 <statusfailed> (and no root)
07:36:28 <Benzi-Junior> c_wraith: seriously
07:36:43 <sinelaw> luite, but of course. https://github.com/sinelaw/sjs
07:36:44 <Benzi-Junior> c_wraith: man you replied so fast I thought you were being sarcastic
07:36:59 <c_wraith> Benzi-Junior: it's kind of a classic one-liner (with enough imports)
07:37:12 <sinelaw> luite, using language-ecmascript pacakge to parse JS, and then it is translated to an internal core language based off of lambda calculus
07:37:40 <Benzi-Junior> c_wraith: what is &&&  ?
07:37:57 <luite> sinelaw: can you please improve language-ecmascript while you're at it ;)
07:38:09 <c_wraith> Benzi-Junior: it comes from Control.Arrow.  You can think of its type as (a -> b) -> (a -> c) -> (a -> (b, c))
07:38:23 <sinelaw> luite, heh yeah.... was just discussing that with the maintainer. he wants to complete a test suite to he can release the ES5 branch
07:38:25 <c_wraith> Benzi-Junior: its real type is a bit more abstract, but that's basically all that everyone ever treats it as.
07:38:26 <luite> sinelaw: i found it has some bugs parsing existing libs, and would like es5/6 support
07:38:50 <luite> sinelaw: cool, i just switched ghcjs to use language-ecmascript (from jmacro)
07:38:51 <speak> c_wraith: Damn that frequency function is cool :D
07:38:51 <athan> Is it possible to constrain the input of a data constructor to be an instance of a typeclass? (Or satisfy any general constraint?)
07:38:59 <athan> And is this possible with GADTs?
07:39:12 <luite> sinelaw: i use an imperative intermediate language though
07:39:13 <Adeon> yes, it is possible with GADTs
07:39:27 <sinelaw> luite, my core language is lambda + mutability. Kind of like ML
07:39:32 <c_wraith> athan: yes, GADTs can do that.  Be careful, though - it only saves work for some use cases.
07:39:53 <luite> sinelaw: with everything type annotated?
07:40:03 <sinelaw> luite, after type inference completes, then yes
07:40:16 <EvanR> @hoogle (a -> b) -> (a -> Maybe b)
07:40:17 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:40:17 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:40:17 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:40:35 <c_wraith> :t (Just .)
07:40:36 <lambdabot> (a -> b) -> a -> Maybe b
07:40:41 <athan> c_wraith: Thank you. What use cases would it not save?
07:41:07 <EvanR> :t lift
07:41:08 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
07:41:19 <EvanR> :t pure
07:41:20 <lambdabot> Applicative f => a -> f a
07:41:38 <EvanR> :t (pure .)
07:41:39 <lambdabot> Applicative f => (a -> b) -> a -> f b
07:41:39 <c_wraith> athan: in cases like where you want to store an Ord constraint (BST or something), for instance.  The constraint still ends up in tons of your functions, so it's not gaining much to pack it up in the data structure too
07:42:26 <athan> c_wraith: Ahh okay, I think mine is a good use case then
07:42:39 <athan> I'm modeling dependencies of libraries for web applications
07:42:40 <luite> sinelaw: do you use dataflow analysis? part of why my optimizer needs to do is remove the "a = f(x);" branch from this code: while(x) { .../* no breaks here */ }; if(x) { a = f(x); } else { a = y; }
07:43:05 <athan> Backbone looks like `Backbone :: UnderscoreLike a => JQuery -> a -> Backbone`
07:43:08 <sinelaw> luite, no, it doesn't do any dataflow analysis
07:43:16 <sinelaw> I see that as orthogonal to type checking
07:43:25 <athan> while JQueryUI looks like `JQueryUI :: JQueryLike a => a -> JQueryUI`
07:43:45 <athan> (because backbone doesn't work with zepto, but does work with lodash)
07:44:10 <luite> sinelaw: this example shows that it can be relevant. you could infer the type of a to be that of y, rather than the join of f(x) and y
07:44:42 <luite> sinelaw: and conversely knowing a type often helps you eliminate branches
07:44:44 <sinelaw> ~js function test(f,x,y) { var a = y; while(x) { /* no breaks here */ }; if(x) { a = f(x); } else { a = y; } return a; } return test
07:44:44 <annoyabot> (((TBoolean -> a), TBoolean, a) -> a)
07:45:21 <sinelaw> luite, you're assuming implicit type unions are ok, i'm not sure I want that
07:45:49 <luite> sinelaw: i do want that in ghcjs, since some adt's depend on sum types
07:46:15 <luite> most commonly SmallInteger|HeapObject
07:46:17 <sinelaw> luite, sum types are not the same as implicit unions
07:46:27 <luite> where HeapObject is non-nullable
07:46:47 <sinelaw> luite, do you want to allow this? var x = 2; x = '3';
07:46:58 <luite> sinelaw: they're implicitly tagged in the situatiosn where it matters :p
07:47:16 <luite> sinelaw: yeah that might be something i'd use in ghcjs
07:47:23 <luite> since you can distinguish them with typeof
07:47:31 <luite> where typeof is usually really fast
07:47:47 <luite> tagged-union-with-cheating ;)
07:47:50 <Benzi-Junior> c_wraith: ok so the head &&& length part says that this is returning (a,frequency of a)  joins equal elements but why sort ?
07:48:01 <sinelaw> luite, yea, I'm considering adding them but you'll be required to qualify the code block with typeof before accessing the value
07:48:07 <shachaf> Any ideas for clever ways to take the tail of an FMList? http://stackoverflow.com/a/27382987
07:48:52 <sinelaw> luite, e.g. var x = 2; x = 'bla'; if (typeof(x) === 'number') { /* here x :: number */ }  and here, outside the if, you can't treat x as a number OR string, it's "opaque"
07:49:20 <luite> sinelaw: another case for dataflow analysis!
07:49:53 <sinelaw> luite, that can be dealt with during type inference at the syntactic level
07:50:03 <sinelaw> e.g. require the explicit "typeof"
07:50:29 <c_wraith> Benzi-Junior: it's actually the (group . sort) part that joins equal elements. group combines adjacent equal elements.  getting all equal elements to be adjacent requires a sort
07:51:27 <c_wraith> Benzi-Junior: the (map (head &&& length)) part is about turning each sublist into a pair of representative element and number of elements from that list
07:51:56 <c_wraith> > group [1,1,2,1,3,3,3,1,1] -- Benzi-Junior
07:51:58 <lambdabot>  [[1,1],[2],[1],[3,3,3],[1,1]]
07:52:07 <c_wraith> > group .sort $ [1,1,2,1,3,3,3,1,1] -- Benzi-Junior
07:52:09 <lambdabot>  [[1,1,1,1,1],[2],[3,3,3]]
07:52:30 <sinelaw> luite, I also have to work some. talk later, sounds like a good case for cross-pollination
07:52:43 <luite> sinelaw: yeah, well for me the dataflow analysis is what matters most. ghcjs does its closure conversion in a way that doesn't use js closures, since they're opaque and hard to work with operationally. that means managing contexts takes up lots of the code, that dataflow stuff has to weed out
07:53:08 <Guybrush_T> Hi! I have defined my own data type: "data Verein = A | B | C deriving (Show,Eq,Ord)", if i want to have a x beeing a list of all possible values, how can i do that with haskell - i already tried let x = [ x | x <- Verein] but that didn't work
07:53:41 <Geraldus> juanpablo_: are you still here?
07:53:52 <EvanR> @hoogle (a -> b) -> (Maybe a -> Maybe b)
07:53:52 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:53:52 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
07:53:52 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
07:53:54 <juanpablo_> Geraldus: yes I'm here :)
07:53:55 <luite> sinelaw: right, at least we have a few projects using language-ecmascript, but there should be room for more. i'd definitely be open to better typechecking across the ffi boundary
07:54:19 <wei2912> Guybrush_T: not sure tbf
07:54:24 <luite> sinelaw: perhaps even make the ffi more flexible if we can get more guarantees from a js typechecker
07:54:34 <Geraldus> juanpablo_: I can't find exact link :(
07:54:38 <Guybrush_T> tbf?
07:54:42 <luite> sinelaw: need to do some work too
07:54:45 <geekosaur> Guybrush_T, you want to derive Bounded and use [minBound .. maxBound :: Verein]
07:54:47 <Geraldus> juanpablo_: look at this one https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/syntax-extns.html
07:54:47 <sinelaw> luite, k
07:54:50 <geekosaur> actually nto quite
07:54:54 <c_wraith> Guybrush_T: if you make it an instance of Enum and Bounded (which GHC can also auto-derive)...  then geekosaur's answer
07:54:55 <wei2912> Guybrush_T: to be frank
07:55:01 <wei2912> ^^
07:55:02 <geekosaur> Guybrush_T, you want to derive Bounded and use [minBound :: Verein .. maxBound]
07:55:06 <juanpablo_> Geraldus: I'll take a look. Thanks a lot
07:55:09 <sinelaw> ~leave
07:55:12 <c_wraith> geekosaur: need Enum too
07:55:18 <geekosaur> yeh
07:55:20 * wei2912 looks up Bounded and Enum
07:55:44 <DrTeggy> Guybrush_T: If you derive Enum, you can do [ x | x <- [A ..] ]
07:56:07 <Guybrush_T> hmm ok, but I'm not allow to change that i believe
07:56:13 <Guybrush_T> *allowed
07:56:45 <Guybrush_T> but still very helpful for the future
07:57:05 <Guybrush_T> maybe I'm just supposed to make tghe list manually anyway
07:57:22 <Guybrush_T> thanks though!
07:57:36 <Geraldus> juanpablo_: no, this is not what you are looking for.
07:59:25 <Geraldus> juanpablo_: I've read something about `forall` and there was explanation about ~ and when to use it
08:00:25 <athan> Hey guys, `cabal haddock` is telling me that it can't satisfy mtl... what do I do?
08:00:34 <EvanR> Geraldus: always use it!
08:00:48 <EvanR> if you need to
08:01:02 <EvanR> :t undefined
08:01:03 <lambdabot> a
08:01:22 <Geraldus> EvanR: can you point a documentation about ~?
08:01:27 <Geraldus> lambdabot: ~
08:01:34 <EvanR> no i cant
08:01:35 <athan> :k (~)
08:01:36 <lambdabot> k -> k -> Constraint
08:01:47 <athan> It's an equivalence constraint
08:01:48 <jvilla> juanpablo_: https://www.haskell.org/haskellwiki/Keywords#.7E
08:01:53 <c_wraith> ~ is a very special constraint, though.
08:02:00 <athan> :k (forall a. a ~ Foo)
08:02:01 <lambdabot> Constraint
08:02:06 <c_wraith> It's not satisfied by having an instance in scope.
08:02:19 <c_wraith> It's satisfied if the type checker can prove the two types are the same
08:02:25 <athan> c_wraith: I forgot!
08:02:41 <c_wraith> AFAIK, it's the only constraint that isn't satisfied by having an instance exist
08:02:45 <athan> they have to unify completely, right?
08:02:49 <c_wraith> athan: yes
08:02:59 <athan> :)
08:03:30 <juanpablo_> Geraldus: jvilla link is great. https://www.haskell.org/haskellwiki/Keywords#.7E
08:03:46 <juanpablo_> I meant the second explanation there
08:04:31 <Geraldus> great!
08:05:04 <Geraldus> now I can continue my quest with transformers-compat
08:07:36 <eXeC64> If "Maybe" is a type constructor, but "Just" isn't, what's "Just" called then?
08:08:02 <tdammers> Just is a constructor (or a "value constructor" if you like)
08:08:16 <tdammers> Just lives in the value namespace; Maybe lives in the type namespace
08:08:57 <EvanR> Nothing is also a constructor but not a function
08:09:17 <eXeC64> Okay. And of course you can apply value constructors to values, but obviously not type constructors to values.
08:09:27 <eXeC64> Was just wondering about the terminology.
08:09:54 <EvanR> you can apply type constructors to values if you had dependent types, which we dont
08:10:53 <eXeC64> "dependent types"? Is that a category thing that Haskell doesn't implement?
08:11:03 <eXeC64> s/category/category theory/
08:11:07 <EvanR> type theory
08:15:28 * hackagebot network-fancy 0.2.0 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.2.0 (TaruKarttunen)
08:17:09 <taruti> What are people using these days to automatically test Haskell libraries on various operating systems automatically?
08:17:34 <taruti> buildbot?
08:19:32 <recursion-ninja> taruti: QuickCheck, SmallCheck
08:19:53 <taruti> recursion-ninja: that helps very little for the "did I break Solaris again"
08:19:59 <recursion-ninja> taruti: or do you mean more integration/deployment testing?
08:20:35 <recursion-ninja> taruti: Ah, so not unit testing, I'm not sure
08:24:57 <recursion-ninja> taruti: An SQA team?
08:27:24 <hodapp> so, in GHCi I do "import Language.Atom hiding (compile)" and then ":t Language.Atom.Compile.compile" seems to work properly
08:27:49 <hodapp> if I put this in a Haskell module and :load it, suddenly that latter reference is "not in scope"
08:28:17 <geekosaur> hodapp: ghci breaks the rules a bit
08:28:34 <geekosaur> when you use the fully qualified name like that, it implicitly does a one-shot import
08:29:30 <hodapp> geekosaur: so, how exactly do I do this properly?
08:30:05 <RchrdB> hodapp: I think that a qualified import is what you want.
08:30:27 <geekosaur> I have no idea because I don't know what you are tryying to do. if you imported hiding compile then it hid compile. do you also import Language.Atom.Compile in any way, or were you relying on the other import to do it? (because that won't work if names are colliding)
08:30:29 * hackagebot sym 0.11.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.11.1 (AndersClaesson)
08:31:15 <hodapp> geekosaur: I was only importing Language.Atom and that was importing 'compile', but I guess that's indirect via Language.Atom.Compile; I am needing to hide 'compile' to avoid a conflict
08:31:25 <hodapp> RchrdB: as in 'import qualified'?
08:31:53 <ChristianS> hodapp: import qualified ... as
08:32:23 <RchrdB> "import qualified Language.Atom.Compile" will bring Language.Atom.Compile.compile into scope, but will not bring anything into scope *without* the qualification.
08:32:24 <taruti> recursion-ninja: basically CI supporting multiple operating systems for cabal packages
08:32:35 <hodapp> ChristianS: I don't want to have to use qualified names for every single thing.
08:33:15 <geekosaur> so do the unqualified+hiding import and then import qualified Language.Atom.Compile as C (compile)
08:33:26 <geekosaur> and now you have C.compile but everything else unqialified
08:33:40 <recursion-ninja> taruti: Luckily I've never had to deal with that. Have you experianced cased where the Haskell language doesn't abstract away the operation system differences?
08:33:41 <doomlord_1> is haskell any good for writing compilers
08:33:58 <ChristianS> doomlord_1: haskell is good for everything!
08:34:07 <taruti> recursion-ninja: yes, and it is even quite common :)
08:34:13 <hodapp> so when I do "import Language.Atom hiding (compile)" this hides 'compile' but does not make it accessible under any qualified name? Or what?
08:34:14 <doomlord_1> has anyone written a c++ compiler in haskell
08:34:22 * EvanR shudders
08:34:28 <hodapp> doomlord_1: why would you want to?
08:34:30 <tdammers> doomlord_1: maybe, could be, but why would one do that?
08:34:31 <recursion-ninja> taruti: Are you talking about stuff like, use /tmp on linux, AppData on Windows?
08:35:02 <vanila> doomlord_1, no one has done that
08:35:04 <tdammers> c++ is a complex monster, and existing implementations are pretty damn good... matching them would be a gargantuan task no matter what language you use
08:35:05 <doomlord_1> a test of its capability
08:35:13 <taruti> recursion-ninja: more like "libc works very very differently on linux, windows, os x, ..."
08:35:32 <recursion-ninja> taruti: what is the application domain?
08:35:35 <taruti> recursion-ninja: e.g. just uploaded a new version of network-fancy and the current testing system (manual) is a pain.
08:35:38 <hodapp> doomlord_1: That's not a test of its capability, it's a test of how much meth a person can survive.
08:35:38 <tdammers> doomlord_1: people use Haskell to solve problems, not to win e-penis contests ;)
08:35:43 <vanila> doomlord_1, I think haskell is good for writing compilers, so even though its not been done it probably could be if you were very skilled and worked hard
08:35:55 <doomlord_1> tdammers C++ is a problem :)
08:36:09 <EvanR> people use haskell to win contests
08:36:19 <hodapp> geekosaur: in other words - why does the import... hiding... not serve to bring in 'compile' into scope, but qualified?
08:36:29 <recursion-ninja> taruti: ah networking, that is pretty close to the OS
08:37:03 <doomlord_1> at the minute i'm writing a pet language... in c++ of course. (the spec is, it has to be able to do anything C++ can, and be capable of being fed a subset of C++ auto-translated)
08:37:04 <dfeuer> carter, the GADT/phantom type version of Sequence failed benchmarking. Milan Straka doesn't think doing that 2-3 leaf magic will necessarily fix it, because the pattern matching is more expensive, and on 32-bit architectures having more than 3 constructors prevents pointer tagging.
08:37:26 <taruti> recursion-ninja: yes, fun stuff, but testing on e.g. solaris these days is quite tedious :(
08:37:38 <hodapp> doomlord_1: does it require you to handle the formally undecidable part of the syntax?
08:37:53 <doomlord_1> hodapp thats why i say subset :)
08:38:04 <EvanR> to test stuff on solaris, they send their code to taruti who specializes in it ;)
08:38:10 <doomlord_1> my 'pet language' has a simpler syntax
08:38:16 <doomlord_1> copied from rust
08:38:31 <doomlord_1> (and before you ask.. Rust annoys me in other ways)
08:38:42 <EvanR> toy / new programming languages based on c++ ...
08:38:47 <EvanR> make it stop
08:39:12 <hodapp> Wow, it's like a model train that can still kill hundreds of people.
08:39:14 <doomlord_1> C++ is ubiquitous for good rasons
08:39:26 <ReinH> No. C++ is ubiquitous for bad reasons.
08:39:28 <doomlord_1> but we are cursed unecaserily with headers
08:39:30 <hodapp> doomlord_1:  C++ is certainly ubiquitous for... reasons.
08:39:32 <recursion-ninja> taruti: Use a previou working version to build a "client" and send data and see use the new version to build a "server" and see if the server correctly responds?
08:39:32 <geekosaur> hodapp, because it hides it, not qualifies it
08:39:33 <dfeuer> ReinH++
08:39:46 <geekosaur> hiding means hiding, not qualifying
08:39:50 <infandum> is there a way to upload to hackage by means of github? So whenever I push a commit, that gets uploaded to hackage?
08:39:54 <doomlord_1> i dont mind segfaults. i can fix them. I mind being tortured with these stupid split declaratinos
08:39:57 <recursion-ninja> taruti: I'm not sure of the interfaaces you would be testing so I'm not sure I can help
08:40:03 <doomlord_1> its completely pointless
08:40:11 <doomlord_1> its like someone is doing it deliberately
08:40:18 <recursion-ninja> taruti: I'm not sure of any automated testing suites...
08:40:20 <shachaf> C++ is a language that's appropriate for many uses that few other languages try for.
08:40:26 <doomlord_1> in 2014 there must be a solution to this
08:40:28 <shachaf> C++ bashing, on the other hand, is not appropriate for #haskell at all.
08:40:29 <taruti> seems like ghc uses buildbot too
08:40:32 <hodapp> doomlord_1: You can fix *some* segfaults, surely. The ones you can prove the existence of.
08:40:34 <dfeuer> doomlord_1, I don't mind segfaults either; I mind when I don't get lucky enough to get one.
08:40:46 <doomlord_1> hodapp i can fix enough to do what i want/need
08:40:53 <carter> dfeuer: urk
08:40:55 <carter> thats no good
08:41:07 <dfeuer> shachaf, aside from interfacing with certain libraries, what is C++ good for that nothing else is?
08:41:11 <vanila> doomlord_1, split declarations?
08:41:23 <hodapp> doomlord_1: Showing the presence of some segfaults should do little to convince one of their absence.
08:41:27 <doomlord_1> yes the way that functinos have to be declared and implemented slightly differently
08:41:36 <shachaf> dfeuer: That's not particularly on-topic here.
08:41:49 <dfeuer> No, carter, it's rather unfortunate. Do you have some brilliant workaround?
08:41:59 <vanila> doomlord_1, that wont be hard to fix!
08:42:17 <hodapp> geekosaur: ack, nevermind. I was misreading a wiki page.
08:42:23 <doomlord_1> one thing that keeps me in C++ is mature IDEs
08:42:26 <hodapp> geekosaur: thanks for the help.
08:42:39 <carter> dfeuer: whys it slower in the 64 bit case?
08:42:45 <hodapp> doomlord_1: Funny. A language that *needs* an IDE is a red flag by itself.
08:42:56 <carter> too many cases?
08:43:04 <carter> i guess:how does the core compare?
08:43:20 <doomlord_1> thats' one problem I had with rust - I've been in C++ IDE's for so long that i really do feel uncomfortable without one
08:43:26 <dfeuer> carter, I don't know all the reasons going on. Too many cases is a definite possible cause. Also, the tree is one deeper, as we discussed.
08:43:39 <doomlord_1> dot-autocomplete is like on the fly documentation searching
08:43:39 <carter> how big a perf gap?
08:43:42 <dfeuer> Oh, you're wondering about with 2-3 leaves. Those are not fun to implement.
08:43:46 <dfeuer> And I haven't finished.
08:43:47 <ReinH> doomlord_1: That's not a problem *with rust*. ;)
08:43:47 <shachaf> doomlord_1: This is pretty off-topic in here at this point too.
08:43:48 <carter> ahh
08:44:00 <carter> g2g
08:44:07 <dfeuer> OK.
08:44:17 <hodapp> doomlord_1: Yeah, and free crutches were a nice benefit of when I worked at a hospital.
08:44:20 <dfeuer> carter, not a huge gap, but meaningful.
08:44:46 <doomlord_1> hodapp its not crutches;  programs are big, remembering things is hard, the purpose of computers is to help humans with large amounts of information
08:44:56 <doomlord_1> and more of course
08:45:15 <ReinH> I like languages that don't require me to remember as much, like Haskell.
08:45:26 <hodapp> doomlord_1: Have you ever considered that maybe the reason people make programs big is because they insist on using a language that *has* to have big programs, and IDEs that encourage it?
08:45:29 <doomlord_1> OOP itself is stupid, the the editor searching on the fly is what makes OOP languages+IDEs useful I think.
08:45:48 <vanila> To C++ Haters: http://pgbovine.net/programmers-talking-to-beginners.htm
08:46:02 <EvanR> you rang?
08:46:04 <doomlord_1> hodapp now we get back on topic - would Haskell be better than C++ at writing a compiler
08:46:28 <vanila> EvanR, yes, please read this ..
08:46:28 <doomlord_1> vanila - i'm not hating C++ - i'm hating *header files* & the design of class syntax.
08:46:47 <vanila> doomlord_1, no its for the people who are telling you how bad C++ is
08:46:54 <vanila> I think that is not productive or helpful
08:47:06 <bennofs> I quite like C++ compared to other OOP languages. At least you have std::for_each and stuff
08:47:11 <vanila> And I have already answered your question but it got lost in the anti C++ speech
08:47:14 <vanila> I'll repeat
08:47:18 <vanila> doomlord_1, I think haskell is good for writing compilers, so even though its not been done it probably could be if you were very skilled and worked hard
08:48:07 <K1ra> doomlord_1: I would say there are a lot of features that make a language like Haskell nice for "compilers" (ADTs, for example)
08:48:18 <zwer> it has been done before, ghc is written mostly in haskell
08:48:50 <vanila> yeah you can build syntax trees with ADTs and pattern match on them easily, that is really useful in writing a compiler
08:48:51 <fresheyeball> hey folks
08:48:57 <K1ra> I am thinking about purescript too :P
08:49:06 <ReinH> We also have some nice tricks for handling bound variables
08:49:06 <fresheyeball> purescript rocks
08:49:07 <vanila> it's a different approach than object oriented 'visitor pattern' that compilers are written in using C++ and python
08:49:09 <saati_> what is purescript?
08:49:43 <doomlord_1> sort by function instead of sort by type perhaps
08:49:59 <K1ra> saati_: a functional language with haskellish syntax (but strict, and well, closer to JS, that compiles to JS
08:50:10 <vanila> doomlord_1, yes exactly
08:50:28 <saati_> K1ra: does it have features for interop with a haskell back-end?
08:50:35 <hodapp> fresheyeball: what are you doing with Purescript?
08:50:38 <vanila> doomlord_1, Although this still isn't perfect there are more advanced techniques to let you subdivide the problem much finer - but no need to get into that now
08:50:48 <EvanR> vanila: i understand the message in this blog post. also, if everyone on earth were to utter a critical remark about software development in php at the same time, i believe we might take a significant step toward world prosperity
08:51:03 <saati_> fuck php
08:51:06 <fresheyeball> so I wrote a function that I find to be useful
08:51:08 <saati_> i did my part :)
08:51:13 <hodapp> EvanR: PHP isn't that bad.
08:51:17 <fresheyeball> teq (x:xs) = foldr (&&) True ((==) x <$> xs)
08:51:19 <K1ra> saati_: I don't know, I haven't played much with it
08:51:20 <doomlord_1> this is one of the things that irritates me about C++ ... committing to 'sort by type' in the syntax
08:51:20 <hodapp> EvanR: I mean, except for programming.
08:51:21 <EvanR> saati_: it has to be everyone at the same time for it to work
08:51:34 <fresheyeball> basically this is a transitive ==
08:51:42 <saati_> i can get the others at the office to say it out loud
08:51:44 <doomlord_1> instead of being able to ,say, dynamically switch back and forth easily
08:52:01 <fresheyeball> is there something like this built in
08:52:16 <hodapp> fresheyeball: is the PureScript tooling to your liking? How much annoying JS interfacing needs to be done?
08:52:16 <vanila> doomlord_1, well you may be interested in attribute grammars then
08:52:27 <bennofs> fresheyeball: you can replace that with 'all (== x) xs'
08:52:30 <vanila> its an aspect oriented approach that lets you split things more finely
08:52:44 <bennofs> fresheyeball: see also hlint, which would suggest that I think
08:52:46 <bennofs> @hackage hlint
08:52:46 <lambdabot> http://hackage.haskell.org/package/hlint
08:52:47 <doomlord_1> that sounds interesting
08:54:00 <vanila> doomlord_1, its pretty cool! I haven't used them but I intend to at some point - there's a haskell compiler done with them though
08:54:47 <fresheyeball> I like purescript better than javascript, but the tools are still in progress
08:56:12 <fresheyeball> interesting
08:56:20 <fresheyeball> hlint looks more powerful than I realized
08:58:06 <fresheyeball> I am just wondering why such a thing is not in the prelude
08:59:28 <fresheyeball> I kind of suspect that it would be there
08:59:33 <indiagreen> fresheyeball: it's also “liftA2 (==) init tail”
09:00:06 <bennofs> fresheyeball: probably because it's not needed so often and also easy to write yourself (all (== x) xs is quite short)
09:03:51 <fresheyeball> ok interesting
09:06:38 <hodapp> fresheyeball: things-that-aren't-JavaScript-but-can-be-turned-into-it interest me a bit, but I've never written in any of them - just JavaScript
09:06:49 <hodapp> there were some interesting EDSL-ish ones, I think
09:07:54 <doomlord_1> could you gi
09:08:53 <doomlord_1> could you give a ballpark relative LOC for a compiler written in haskell vs a compiler written in C++, if you claim haskell is more expressive. I realise LOC is not necaserily a meaningful measure, but still..
09:09:05 <zomg> x -> JS compilers are getting more mature I think, but would still think twice unless you don't need to support any older browsers or mobile devices or such
09:09:18 <zomg> debugging without source maps for example can be really really hard :P
09:09:31 <EvanR> doomlord_1: any compiler?
09:09:45 <zomg> I've used CoffeeScript, Elm, Fay, TypeScript and ECMAScript 6, works alright
09:09:56 <doomlord_1> the specific question would be : a compiler for a C++ like language
09:09:56 <hodapp> zomg: still a pain to debug though?
09:10:24 <hodapp> doomlord_1: I don't think any answer to your question is actually meaningful in any way.
09:10:42 <EvanR> doomlord_1: aside from type systems and data structures and things... the presence of automatic memory management grossly cuts down on code size for a project or any sort
09:10:52 <doomlord_1> i realise LOC doesn't  necaserily correlate with 'maintainable', 'understandable', but still
09:10:52 <monochrom> I haven't wrote a whole compiler for a long time. but I can show you just the part about abstract syntax trees or parse trees.
09:11:02 <vanila> We would need to find a similar compiler written in each language
09:11:03 <fresheyeball> hodapp javascript is a terrible language if you are looking to build real application interface
09:11:20 <hodapp> fresheyeball: and in OTHER news, bears shit in the woods!
09:11:29 <ReinH> No one is going to have an accurate answer to that question.
09:11:30 <vanila> doomlord_1, its a reasonable question, even though I dont know a good example compiler to compare
09:11:32 <doomlord_1> EvanR i'm not sure a compiler needs to free much. build a data structure, traverse it and emit
09:11:35 <fresheyeball> CoffeeScript or LiveScript are good if you want to stay close to JS
09:11:42 <monochrom> Suppose the input language just has "Expr ::= Literal | Expr + Expr".
09:11:53 <zomg> hodapp: it's not so bad if you can use source maps, because then you can debug in the actual source rather than the compiled JS.. but yes it can still sometimes be a bit problematic
09:11:56 <vanila> yeah you can use the OS to reclaim all your processes memory at the end
09:12:05 <hodapp> zomg: source maps?
09:12:07 <zomg> oh right and ClojureScript was another which I used... pre-sourcemaps... and man that was so annoying to debug =)
09:12:09 <fresheyeball> but imho PureScript is the best option if you like functional purity and haskell syntax
09:12:32 <zomg> source map is basically a file the browser can look at to figure out the line of code in the original file vs. the code it's running in the compiled JS file
09:12:32 <fresheyeball> PureScript is still new and the community and toolkit are developing
09:12:53 <monochrom> in C++ it is probably: virtual class Expr {}; class Literal : Expr { int n; }; class Plus : Expr { Expr left, right; }
09:12:55 <EvanR> doomlord_1: interesting approach, this is how i recommend  alot of C code goes too, dont do any memory management. i never thought of trying this in c++
09:13:02 <fresheyeball> but it is the best option imho
09:13:11 <monochrom> in Haskell it's probably: data Expr = Literal Int | Plus Expr Expr
09:13:33 <vanila> monochrom++  very good examples :)
09:14:34 <doomlord_1> evanr what I can imagine a being wasteful is, 'build a datastructure with holes to fill in...'. that is perhaps where a 'more expressive language' could help. build a datastructure and refine it in passes..
09:14:44 <hodapp> zomg: ...wow, thanks for pointing out something that's been around since 2012 that I managed to miss despite reading 2 or 3 textbooks on HTML5
09:14:50 <monochrom> and yeah, processing an actual tree in the C++ version is going to be an elaborate exercise on Visitors. I've been there, too.
09:15:06 <hodapp> ugh, design patterns
09:15:11 <ReinH> hodapp: well, it isn't an html thing
09:15:18 <monochrom> processing an actual tree in the Haskell version is just a basic recursion
09:15:40 <hodapp> ReinH: when I say HTML5, I mean a lot of the associated stuff too
09:15:53 <hodapp> that is not properly HTML
09:16:15 <vanila> The web is awful since W3C became completely corrupt
09:16:23 <hodapp> x_X
09:21:04 <agumonke`> hello people
09:22:41 <zomg> hodapp: heh, source maps are a bit obscure :)
09:22:44 <agumonke`> I once saw a video talk (~30min) on haskell and adjunctions, from what I remember the speaker mentioned computing order of products without actually computing the product. Adjunction being, projection the operands onto some "digit length" domain to deduce ordering faster. Does that ring a bell to anyone ?
09:23:03 <agumonke`> I can't find the link
09:23:30 <hodapp> zomg: I don't know about that :P
09:25:30 * hackagebot seclib 1.0.0.0 - A simple library for static information-flow security in Haskell  http://hackage.haskell.org/package/seclib-1.0.0.0 (AlejandroRusso)
09:25:33 <EvanR> @hoogle [a -> b] -> (a -> [b])
09:25:34 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:25:34 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
09:25:34 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:26:59 <cojy> doomlord_1: I feel like the design of the compiler in c++ would have to be a completely different, haskell gives so many nice tools for writing compilers that I don't know if you could do in c++, so it's more than just comparing similar code from each lang
09:28:01 <timmy_tofu> I'm getting a cabal error "the given installed package instance does not exist", which I see defined here: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Configure.hs
09:28:11 <timmy_tofu> I've tried deleting and rebuilding the sandbox, but same story
09:34:43 <Jello_Raptor> hmm, is there a way to collapse different StateT monads together when you chain them, so that all their respective lenses work? i.e some way to have a "StateT Foo StateT Bar" with "data Foo = Foo { _a :: Int }" and "data Bar = Bar { _b :: Int }" such that I can use "b += 1" rather than "lift (b += 1)" ?
09:37:51 <bitonic> Jello_Raptor: no -- this is a problem with MonadState rather than with lenses.  it just pick the first one in the stack.  some people use things like extensible-effects to overcome that problem, but I think the "idiomatic" lens solution is to manually squash all the state in one big record.
09:41:12 <Jello_Raptor> bitonic: aww :(, is there a way to push the 'lift' into the lens, rather than have to apply it to entire monad?
09:41:51 <bitonic> Jello_Raptor: you mean something like `lift' b += 1'?
09:42:46 <Jello_Raptor> bitonic: err, maybe ? I was thinking '(`lift` b) += 1'
09:45:00 <athan> If you submit a package as a candidate to hackage, is there any way you can be involved in the approval process?
09:45:12 <bitonic> Jello_Raptor: anyhow, I don't think so, given the type of (+=)
09:46:03 <batchm> MonadRandom is pretty cool. you can write random functions that can be used both in pure code and in IO
09:46:21 <Jello_Raptor> bitonic: that makes sense. And right not, control.lens is built to be very convenient for users of mtl, rather than for users of extensible-effects?
09:46:35 <Jello_Raptor> now*
09:46:38 <bitonic> Jello_Raptor: yeah, I'd say that's fair
09:47:15 <athan> When linking sandboxes, `cabal repl` fails: http://lpaste.net/116096 :(
09:47:39 <bitonic> Jello_Raptor: Roman Cheplyaka has written about how he uses extensible-effects <http://ro-che.info/>
09:47:48 <bitonic> with comparisons with the lens-based approach
09:48:06 <athan> I've tried deleting and rebuilding the independent sandboxes a number of times. What would be causing linker errors!?
09:48:43 <bitonic> Jello_Raptor: actually, he doesn't use the extensible-effects library, but something he built in-house
09:49:30 <bitonic> I personally prefer to squash the state and go.  but if you change what your state looks like very often, maybe the type-directed approach is better
09:49:42 <batchm> how can I write a function that works with both UTCTime and ZonedTime?
09:49:45 <cdk> :t sequence `asTypeOf` (undefined :: [a -> b] -> (a -> [b]) -- EvanR
09:49:47 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:50:09 <fresheyeball> :t all
09:50:10 <lambdabot> (a -> Bool) -> [a] -> Bool
09:50:36 <EvanR> :t sequence
09:50:37 <lambdabot> Monad m => [m a] -> m [a]
09:50:54 <cdk> EvanR: ahh, that's not right. Try sequenceA
09:50:59 <EvanR> :t sequenceA
09:51:00 <lambdabot>     Not in scope: ‘sequenceA’
09:51:00 <lambdabot>     Perhaps you meant one of these:
09:51:01 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
09:51:04 <cdk> :t T.sequenceA
09:51:05 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:51:31 <EvanR> t is list, and f is function?
09:51:37 <cdk> yes :)
09:51:48 <batchm> f is applicative functor
09:52:04 <Jello_Raptor> bitonic: ahh, still it looks interesting. I'd prefer the type directed approach, because my particular program (a compiler) has large sections with shared global state, and then short sections with shared local state. Ideally we'd be able to nest the local state to arbitrary levels so i can i can transform code, without creating temporary values that simply say "this function needs to be transformed later."
09:52:09 <athan> EvanR: Are you familiar with `sequence`?
09:52:15 <EvanR> yes
09:52:20 <Jello_Raptor> bitonic: but that's unreasonable for a stack of reasons.
09:52:31 <athan> derp, didn't see that line up there ><
09:52:40 <bitonic> Jello_Raptor: well what you'd do is to compose the substates in a big record and then `zoom' into them
09:52:49 <EvanR> to review, i was looking for a function with type [a -> b] -> (a -> [b]), which apparently is a specialization of sequenceA
09:52:57 <bitonic> but it does require more upfront separation of the state components, which is good and bad
09:53:15 <monochrom> I wonder if "a stack of reasons" is a pun, since a stack of monad transformers is involved...
09:53:16 <athan> :t (<*>)
09:53:16 <hodapp> can I get GHCi to tell me the fully-qualified name of something?
09:53:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:53:50 <athan> @src T.sequenceA
09:53:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:53:54 <Jello_Raptor> bitonic: is there anything good about how to use 'zoom'?
09:54:01 <athan> @src Data.Traverse.sequenceA
09:54:02 <lambdabot> Source not found. Whoa.
09:54:02 <hodapp> trying to figure out which module defines something.
09:54:04 <athan> ><
09:54:17 <athan> hodapp: :i
09:54:19 <monochrom> EvanR: let f be "(->) a"
09:54:23 <athan> er... I think
09:54:27 <ThreeOfEight> Does anybody happen to know if one is allowed to change the roman maths font in the ACM SIGPLAN template?
09:54:35 <hodapp> athan: yes! thanks!
09:54:38 <athan> :)
09:54:51 <bitonic> Jello_Raptor: the only way I use `zoom' is to run a `StateT' action using a smaller state
09:55:17 <bitonic> so basically if you have state `s' and some lens `Lens s a', you can run a `State a' action in a `State s'
09:55:28 <bitonic> note that you plug back the resulting `a' using the lens
09:56:21 <benzrf> bitonic: isnt that all that zoom does
09:56:34 <benzrf> :t zoom
09:56:35 <lambdabot> (Zoom m n s t, Control.Lens.Internal.Zoom.Zoomed n ~ Control.Lens.Internal.Zoom.Zoomed m) => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
09:56:43 <benzrf> oh... oh wow
09:57:00 <bitonic> no, it also has some Monoid trickery to collect results and compose them
09:57:04 <bitonic> and Error trickery
09:57:28 <bitonic> I'd just pretend that what I described is all it does, at the beginning
09:59:46 <Jello_Raptor> bitonic: I'm still in that phase with most of Control.Lens :P it's very much a "fuck the *actual* type signatures, the 'simple' type signatures are the useful ones" phase for me .
09:59:51 <Jello_Raptor> I'll figure it out eventually
09:59:55 <Jello_Raptor> but in the meantime :V
10:02:34 <bitonic> I think the important types are worth figuring out.  stuff like Zoom, I don't know
10:12:30 <greymalkin> Are there any memory-locking calls in haskell? Specifically, I'm thinking of using haskell for some security-related software, but a typical need in security is to mark memory as non-pageable.
10:13:14 <cite-reader> There's the securemem library, but I can't comment on its quality.
10:15:09 <Guybrush_T> if i have this type: "newtype Kader = Kd (Verein -> [SpielerId])" , how can i invoke that function?
10:15:25 <Guybrush_T> tabelle :: Punkte -> Kader -> Verein -> (Nat,Verein,[SpielerId])
10:15:25 <Guybrush_T> tabelle p k v = ((p v),v, (k v))
10:15:45 <bitonic> Guybrush_T: either you pattern match on `Kd', or you defined an accessor, e.g. `newtype Kader = Kd {unKd :: ...}'
10:16:18 <Guybrush_T> ah ill try the pattern match
10:16:59 <bitonic> Guybrush_T: I'd say the accessor is more idiomatic
10:17:49 <Guybrush_T> i cannot change the datatypes though
10:18:47 <bitonic> that's unfortunate
10:19:39 <ReinH> You can write your own accessor
10:19:48 <ReinH> unKd (Kader f) = f
10:20:15 <ReinH> sorry, unKd (Kd f) = f
10:21:49 <athan> Anyone here use vinyl?
10:22:00 <Guybrush_T> ReinH, thanks for the hint
10:35:33 * hackagebot network-fancy 0.2.1 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.2.1 (TaruKarttunen)
10:47:05 <trap_exit> what is the shortest haskell program for taking a *.wav file, and increasing the pitch?
10:47:22 <trap_exit> I have the output of << say "Hello World" >> on OSX, but now I want to turn it into a squeaky voice
10:49:37 <dfeuer> trap_exit, isn't .wav some stupidly simple encoding? You could probably go up an octave by removing half the whatevers in it, right?
10:50:29 <pavonia> trap_exit: Call soundstretch from your Haskell program :p
10:50:34 * hackagebot fasta 0.5.1.3 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.5.1.3 (GregorySchwartz)
10:50:36 * hackagebot diversity 0.2.0.5 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.2.0.5 (GregorySchwartz)
10:50:38 * hackagebot ghc-srcspan-plugin 0.2.0.0 - Generic GHC Plugin for annotating Haskell code with source  location data.  http://hackage.haskell.org/package/ghc-srcspan-plugin-0.2.0.0 (EricSeidel)
10:53:57 <pecanpy> in a moment of weakness i did --force-install when cabal said it would break 2 packages. is there a way to see what potential damage ive done?
10:55:15 <pavonia> ghc-pkg check
10:56:09 <ReinH> greymalkin: I can comment on securemen's quality. My coworker wrote it and we use it in production.
10:56:48 <pecanpy> thanks. that gave me a lot of "/doc/...." and ".html" don't exist warnings
10:57:42 <L8D> Is there a good tool for generating static sites with Blaze+Clay ?
10:57:43 <pecanpy> all for haddock-html and haddock-interfaces. nothing other than that.
10:59:44 <L8D> I guess Hakyll works
11:00:03 <schell> hi all, i’m having some trouble with cabal sdist
11:00:06 <bitemyapp> L8D: you should be able to integrate Clay with Hakyll if you want.
11:00:21 <schell> the resulting tar.gz seems to be missing all source files except for Main.hs
11:00:33 <L8D> I'm thinking of building a tool that will handle full-asset optimization
11:00:34 * hackagebot diversity 0.3.0.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.3.0.0 (GregorySchwartz)
11:00:53 <chrisdone> bitemyapp: this section of aeson is mine: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#g:1 =3
11:01:01 <L8D> minification, bundling, and that thing that rails does with its asset pipeline
11:01:13 <chrisdone> sadly this is the only docs i've contributed to someone else's package
11:01:15 <schell> it’s an executable so i didn’t think i would have to list modules (exported or not)
11:01:20 <chrisdone> haddock is hell =)
11:01:37 <L8D> going over the preprocessers, it seems that blaze and clay are much more preferable to the mainstream ones
11:02:15 <L8D> although I need to devise a system for compiling Elm widgets
11:02:38 <bitemyapp> chrisdone: <3
11:02:44 <bitemyapp> chrisdone: stuff like that, helps a *lot*
11:02:48 <chrisdone> <3
11:03:25 <dfeuer> Does the standard say anything about whether the left or right operand of + is evaluated first?
11:03:34 <dfeuer> Or is that otherwise certain somehow?
11:03:43 <schell> do i have to list every module for which i’d like the source included (as in other-modules)?
11:03:46 <bitemyapp> chrisdone: that thread is going a lot better than I suspected.
11:03:52 <bitemyapp> chrisdone: I expected to get a lot of hate for it :(
11:04:25 <L8D> dfeuer: try running (trace "x" 1) + (trace "y" 2) in ghci
11:04:40 <L8D> it will print x first, so I assume that for most scenarios the left is evaluated first
11:05:07 <pecanpy> i looked up those warning and a SO thread said to do: mv ~/.cabal ~/.cabal.SAVE  and then "cabal update". What is the windows equivalent of ~/.cabal ?
11:06:13 <chrisdone> bitemyapp: it's definitely worth discussing
11:07:23 <chrisdone> bitemyapp: i can identify at least a few kind of people not documenting their libs; (1) the ones who just wrote something for themselves and decided to release it, don't care to dedicate anymore time to it. it'd be nice if they documented better, but at some pointed you have to just be thankful someone took the time to release something. it'll be harder to reach those people
11:07:59 <chrisdone> bitemyapp: (2) possibly some people just *don't know* that their library is not obvious, or how to explain themselves, and that needs some community feedback or some kind of guideline
11:08:36 <bitemyapp> chrisdone: yeah, this is a good bracketing of it.
11:08:37 <chrisdone> bitemyapp: i *think* (i don't know) that it's a very small minority who really thinks types always speak for themselves
11:08:43 <tnks> I think it would help if Cabal had a literate document as a first-class citizen for a tutorial.
11:08:57 <bitemyapp> chrisdone: I don't want to discourage (1) and won't bother them if that's their situation. If they merge PRs I don't mind too much.
11:09:01 <tnks> kind of like how R promotes "vignettes" (I think they call them)
11:09:06 <bitemyapp> tnks: kinda does. kinda.
11:09:16 <bitemyapp> Not "cabal" per se, just...you can write your code literately with haddocks.
11:09:24 <bitemyapp> you can also use doctests.
11:09:26 <chrisdone> bitemyapp: right, that's good news. people generally don't mind merging docs i expect
11:09:29 <tnks> bitemyapp: yeah, but I think it should be even more up-front.
11:09:35 <chrisdone> yeah, tomejaguar commented this
11:09:38 <bitemyapp> chrisdone: (2) just needs to be shown how hard things are for people.
11:09:38 <Xeironis> pecanpy: should be C:/Users/<Username>/Appdata/Roaming/cabal
11:09:38 <dfrey> dfeuer: Wouldn't the first argument of any curried function always be evaluated before the second?
11:09:42 <chrisdone> http://www.reddit.com/r/haskell/comments/2ory86/there_is_a_documentation_problem_stop_pretending/cmpy9b5
11:09:45 <tnks> it's not a techical problem, so much as a social one.
11:09:56 <tnks> people fill out things when they are fields.
11:10:05 <bitemyapp> tnks: maybe so, but not everybody likes literate stuff. I'm being convinced just because of the validation of documentation it offers.
11:10:15 <bitemyapp> tnks: I hate manually updating my README.md for Bloodhound and so do my contributors. It's a pain.
11:10:17 <dfeuer> dfrey, well... no.
11:10:23 <bitemyapp> but I do it anyway because we *need* the examples.
11:11:31 <tnks> bitemyapp: I think it's worth listening to the complaints about literate documents to see what the arguments are -- perhaps resolvable?
11:12:10 <bitemyapp> tnks: one problem is distinguishing whether you want literate code or literate tests or literate documentation.
11:12:15 <chrisdone> bitemyapp: hmm, me too. perhaps one could implement a tool that takes your README and extracts each haskell code fence with pandoc and compiles them. i don't like writing literate haskell much
11:12:20 <bitemyapp> tnks: those are 3 different things. #2 is kinda covered by doctest.
11:12:22 <chrisdone> there's also that tool that compiles your haddock examples. what was that?
11:12:28 <chrisdone> ah, doctest
11:12:29 <sinelaw> doctest
11:12:37 <sinelaw> shucks. I'm beat.
11:12:43 <chrisdone> :3
11:12:59 <sinelaw> or as annoyabot puts it, you problemed me
11:15:19 <bitemyapp> chrisdone: well, what I'm considering is generating the README from a literate examples file that gets compiled and tested.
11:15:29 <bitemyapp> the tests themselves are too messy to use directly.
11:18:31 <pecanpy> Xeironis: thanks. so you think its saying to delete the config file and then run "cabal update" to regenerate it?
11:19:13 <Xeironis> pecanpy: I would save it somewhere else before you delete it, just in case
11:19:21 <sinelaw> chrisdone, do you use language-ecmascript in fay
11:19:21 <sinelaw> ?
11:19:25 <sinelaw> (or otherwise?)
11:19:32 <chrisdone> yeah
11:19:52 <sinelaw> ES3 or the unreleased ES5?
11:20:49 <Xeironis> pecanpy: But yeah, I think that's what it's saying
11:21:40 <pecanpy> Xeironis: yea, that didn't work, lol. im still getting a ton of haddock missing file warning when i "ghc-pkg check". im giving up.
11:21:55 <Xeironis> ah, that sucks
11:23:35 <pecanpy> anyone know how to reinstall EclipseFP? I deleted the jars in /plugins and tried to reinstall and now its completely broken.
11:25:20 <chrisdone> sinelaw: huh?
11:25:35 * hackagebot urlpath 0.0.1 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.1 (athanclark)
11:25:37 * hackagebot steeloverseer 1.1.0.2 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-1.1.0.2 (SchellScivally)
11:25:47 <chrisdone> oh, i don't know. a very small portion of ecmascript, for the ffi declarations
11:26:25 <sinelaw> chrisdone, okey-dokey. The released version only supports ecmascript 3. There is a yet-to-be-released branch supporting ES5
11:27:17 <chrisdone> =)
11:30:07 <sinelaw> why does cabal install in a sandbox complain?
11:30:20 <sinelaw> (about reinstalls when the sandbox is empty)
11:30:32 <sinelaw> can't I have it ignore the globally installed packages?
11:31:40 <phaazon> god, reinstalling semigroups to upgrade from 0.15.3 to 0.16 breaks everything
11:31:50 <phaazon> I still wonder why things get broken
11:31:52 <batchm> how usable is reactive banana?
11:32:00 <sinelaw> please don't mention reinstalls at the moment.
11:32:05 * sinelaw sobs
11:32:19 <phaazon> ahah
11:32:23 <phaazon> sinelaw: it does
11:32:28 <phaazon> it does ignore globally installed
11:32:49 <sinelaw> phaazon, so why does it complain? the sandbox is empty. I just initialized it
11:32:49 <phaazon> something I don’t understand is the way package are installed
11:33:00 <phaazon> what do you get as error message?
11:33:34 <sinelaw> cabal: The following packages are likely to be broken by the reinstalls:
11:33:35 <sinelaw> unordered-containers-0.2.4.0
11:33:35 <sinelaw> case-insensitive-1.1.0.3
11:33:35 <sinelaw> Use --force-reinstalls if you want to install anyway.
11:34:08 <chrisdone> phaazon: why are you upgrading it?
11:34:08 <phaazon> are you sure the sandbox is empty?
11:34:23 <phaazon> chrisdone: because I’m working on a lib which is not released yet
11:34:33 <phaazon> I want to stick to fresh packages
11:34:43 <phaazon> furthermore, when a new version is out, I like to upgrade if I can
11:35:03 <zerokarmaleft> batchm: /whois phaazon
11:35:07 <zerokarmaleft> oops
11:35:24 <sinelaw> embarrassing.
11:35:24 <batchm> (:
11:35:31 <phaazon> ahah
11:35:39 <chrisdone> now kiss!
11:35:39 <zerokarmaleft> yep, stalking
11:35:47 <batchm> I thought his whois holds the answer to my question
11:35:58 <phaazon> which is?
11:36:03 <batchm> been asking it for a while now.. i guess few use reactive banana and just stick to gtk2hs
11:36:03 <vanila> Could there be a hackage like thing which has a consisent set of packages, so that installing from it would not break?
11:36:10 <batchm> how usable is reactive banana?
11:36:21 <sinelaw> vanila, stackage?
11:36:39 <dfrey> dfeuer: How would the second argument of (+) be evaluated before the second?   For example:  (+) 7 ((*) 3 5).  There is no need to evaluate ((*) 3 5) until the (+) 7 is evaluated to create a function :: (Num a) => a -> a.  Someone please correct me if I am wrong.
11:37:11 <dfrey> I meant to say "... be evaluated before the first? ..."
11:37:28 <chrisdone> vanila: sounds like the start of an ad for stackage =p
11:37:34 <phaazon> sinelaw: dry to recreate the sandbox?
11:37:35 <sinelaw> now seriously, how do I get this sandbox to run "cabal install"? if sandbox ignores the globally installed package, how can it fail on reinstalls when the sandbox has nothing in it yet?
11:37:48 <sinelaw> phaazon, just ran sandbox delete + init again
11:37:49 <batchm> dfrey that sounds right. outter-most function  ((+)  in this case) drives the evaluation
11:38:29 <batchm> dfrey oh, you are asking which argument is evaluated first? I don't think that is specified
11:38:30 <phaazon> sinelaw: do you still have an error?
11:38:36 <vanila> wow
11:38:38 <sinelaw> yes.
11:38:42 <vanila> im proud of myself
11:38:50 <phaazon> cabal sandbox delete
11:39:03 <phaazon> and look at files
11:39:06 <zplesivcak> can someone help me with the following code
11:39:09 <zplesivcak> http://lpaste.net/116105
11:39:20 <phaazon> cabal.sandbox.config
11:39:30 <sinelaw> phaazon, gone
11:39:38 <phaazon> it shouldn’t complain about global package
11:39:55 <sinelaw> phaazon, this is the thing I'm trying to build: https://github.com/achudnov/mozilla-js-parser-api
11:40:04 <zplesivcak> when commented-out line is like that, program doesn't write anything to STDOUT... when comment is removed, program writes content of "example.hs" two times
11:40:13 <zplesivcak> this seems like a buggy behavior to me
11:40:27 <batchm> (+) 7 does create a function, but that, by itself, won't evaluate 7
11:40:30 <phaazon> I’m gonna try sinelaw
11:40:30 <phaazon> wait
11:40:34 <sinelaw> phaazon, git@github.com:achudnov/mozilla-js-parser-api.git
11:40:56 <batchm> > (+) undefined `seq` 1
11:40:57 <lambdabot>  1
11:41:10 <phaazon> yeah yeah
11:41:12 <phaazon> building
11:41:34 <phaazon> git clone git@github.com:achudnov/mozilla-js-parser-api.git
11:41:40 <phaazon> cd mozilla-js-parser-api
11:41:44 <phaazon> cabal sandbox init
11:41:45 <sinelaw> phaazon, git clone... ; cabal sandbox init; cabal install  <---- this fails.
11:41:51 <phaazon> cabal install --only-dependencies
11:42:03 <phaazon> sinelaw: hm
11:42:06 <sinelaw> fails.
11:42:10 <sinelaw> FAILS.
11:42:18 <phaazon> that’s weird
11:42:27 <phaazon> where do you clone the project?
11:42:38 <sinelaw> in my /tmp now
11:42:43 <sinelaw> I think sandbox does NOT ignore global packages
11:42:48 <phaazon> so am I
11:43:05 <phaazon> I think it does
11:43:20 <phaazon> but there might be somekind of option to change that behavior somewhere
11:44:46 <phaazon> sinelaw: cabal --version please
11:45:00 <sinelaw> 1.20.0.3
11:45:07 <sinelaw> cabal lib version 1.20.0.2
11:45:35 <chrisdone> Fuuzetsu: poke
11:45:35 <phaazon> that’s weird
11:45:36 * hackagebot urlpath 0.0.2 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.2 (athanclark)
11:46:07 <creichert> sinelaw: it worked in a sandbox for me first time, i feel like you are running the same commands but I could past mine if that helps
11:46:26 <phaazon> sinelaw:
11:46:29 <phaazon> cabal sandbox delete
11:46:30 <creichert> maybe try it somewhere other than /tmp? not really sure
11:46:31 <phaazon> cabal sandbox init
11:46:31 <sinelaw> creichert, possibly you have different versions installed in your global scope
11:46:35 <phaazon> and past the config of the sandbox
11:46:39 <sinelaw> creichert, tried different places
11:46:47 <creichert> sinelaw: it only looks in the sandbox
11:46:49 <phaazon> creichert: I did it in /tmp as well
11:46:51 <phaazon> worked fine
11:47:21 <sinelaw> http://lpaste.net/116106
11:48:05 <phaazon> that’s all?
11:48:14 <phaazon> you miss a few lines
11:48:17 <creichert> sinelaw: anything above taht?
11:48:20 <creichert> yea
11:48:24 <phaazon> local-repo
11:48:25 <phaazon> and so on
11:48:45 <sinelaw> and here's the full set of commands (after git clone)
11:48:47 <sinelaw> http://lpaste.net/116107
11:48:53 <creichert> should all be pointing to that sandbox too
11:48:58 <sinelaw> phaazon, nope, don't have that
11:49:32 <phaazon> sinelaw: http://lpaste.net/116109
11:49:38 <phaazon> that’s really weird
11:49:45 <phaazon> might be a bug of your Cabal lib
11:49:56 <phaazon> I have 1.20.0.0 version
11:50:02 <sinelaw> oh oops.
11:50:04 <sinelaw> sorry.
11:50:18 <sinelaw> missed those lines.
11:50:31 <pecanpy> anyone here knowledgable about EclipseFP? getting it to work has been a nightmare. if i try to install scion-browser cabal says it will break buildwrapper. but EFP needs buildwrapper, which itself will break packages. :(
11:50:32 <sinelaw> http://lpaste.net/116110
11:50:36 * hackagebot urlpath 0.0.3 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.0.3 (athanclark)
11:50:38 * hackagebot ireal 0.1 - Real numbers and intervals with not so inefficient exact arithmetic.  http://hackage.haskell.org/package/ireal-0.1 (sydow)
11:50:49 <phaazon> ok we have the same file
11:50:53 <hodapp> URL combinators?
11:50:55 <hodapp> hmmmm
11:51:01 <pecanpy> how can it need 2 packages that don't like each other, lol
11:51:02 <phaazon> that’s weird
11:51:09 <sinelaw> phaazon, I diffed them, they're identical
11:51:16 <creichert> sinelaw: have you tried to upgrade cabal-install (not sure if that was asked)
11:51:29 <sinelaw> creichert, don't want to do that until I figure out what's going on
11:51:31 <creichert> i have 1.20.0.3 cabal-install and library version 1.20.0.2
11:51:37 <sinelaw> creichert, me too
11:51:39 <sinelaw> same same
11:51:42 <zplesivcak> http://lpaste.net/116105
11:51:45 <sinelaw> i'll strace it
11:51:49 <zplesivcak> when commented-out line is like that, program doesn't write anything to STDOUT... when comment is removed, program writes content of "example.hs" two times
11:51:51 <phaazon> hm
11:51:56 <phaazon> I installed the new cabal lib
11:52:01 <phaazon> but it doesn’t show up in cabal --version
11:52:03 <phaazon> weird :D
11:52:11 <phaazon> maybe I need some kind of reboot?
11:52:26 <javjarfer> Hi all! Anyone knows how is implemented polymorphism through dictionaries, or any papers about how it's done in Haskell?
11:52:39 <pecanpy> phaazon: i had the same problem yesterday
11:52:51 <phaazon> how do you solve it out?
11:52:51 <pecanpy> use which/where. youll see it in two locations
11:53:06 <pecanpy> i had to delete the one in haskell/..../extralibs/bin
11:53:07 <schell> javjarfer: you could check out http://www.reddit.com/r/haskell/comments/2kdb8k/caffeinated_times_the_easily_extensible_entity/
11:53:28 <batchm> zplesivcak try using hFlush
11:53:30 <schell> that may provide a certain kind of ad hoc “polymorphism”
11:53:32 <sinelaw> creichert, it's accessing "/usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/..."
11:53:37 <pecanpy> though i guess you could just move the other location first in the path
11:53:44 <sinelaw> creichert, can you strace cabal install in the sandbox and see if it also does?
11:53:58 <phaazon> pecanpy: huh
11:54:04 <phaazon> where cabal gives me just one location
11:54:18 <sinelaw> creichert, this line looks weird:
11:54:20 <sinelaw> 14032 execve("/usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/ghc-pkg", ["/usr/local/haskell/ghc-7.8.3-x86"..., "--global-package-db", "/usr/local/haskell/ghc-7.8.3-x86"..., "--version"], [/* 77 vars */]) = 0
11:54:28 <sinelaw> not sure it's supposed to be that way in a sandbox.
11:54:43 <pecanpy> phaazon: yea i found a bug report about it yesterday
11:54:45 <schell> is there any etiquette about using package tags on hackage?
11:54:54 <phaazon> pecanpy: I mean
11:55:00 <phaazon> what do you look for with the where command?
11:55:11 <pecanpy> the location of the "cabal" command
11:55:16 <phaazon> yeah, only one place to me
11:55:25 <phaazon> phaazon@illusion /usr/lib % where cabal
11:55:26 <phaazon> /usr/bin/cabal
11:55:26 <phaazon> phaazon@illusion /usr/lib % which cabal
11:55:26 <phaazon> /usr/bin/cabal
11:55:30 <pecanpy> you must not have users/_/appdata/roaming/cabal in your path then
11:55:41 <phaazon> oh, you’re on windowsç
11:55:44 <phaazon> -ç
11:55:53 <batchm> zplesivcak did that help?
11:56:06 <javjarfer> schell: thanks you, but i was wondering about Haskell internals, like the translation of "const :: a -> b -> a", to a callable function through that runtime polymorphism
11:56:18 <zplesivcak> batchm: sec, pls
11:56:21 <phaazon> phaazon@illusion ~/.cabal/lib/x86_64-linux-ghc-7.8.3/Cabal-1.20.0.2 %
11:56:23 <batchm> > hFlush stdout
11:56:23 <phaazon> the lib is there
11:56:24 <lambdabot>  Not in scope: ‘hFlush’Not in scope: ‘stdout’
11:56:30 <sinelaw> creichert, run: cabal -v install --only-dependencies
11:56:31 <schell> javjarfer: ah - sorry, can’t help you there :(
11:56:35 <sinelaw> creichert, please, and paste it
11:56:50 <batchm> why isn't lambdabot loading every module that was ever created?
11:57:02 <phaazon> it might be a simple issue with the version name in the source code?
11:57:11 <javjarfer> schell: no worries! thank you!
11:57:49 <pecanpy> phaazon: on windows it was definitely that it installed itself in a different place. i wouldnt be tempted to think they just didn't update the version number, lol
11:58:15 <zplesivcak> batchm: no... "hFlush stdout" at the end doesn't work
11:58:37 <zplesivcak> batchm: hFlush on file handler throws error
11:59:05 <pecanpy> find / -name '^cabal$'     ? (if i remembered that right)
11:59:30 <phaazon> pecanpy: looking in / is a bit to large
11:59:37 <phaazon> I’m gonna try in /usr first :D
12:00:02 <phaazon> /usr/share/bash-completion/completions/cabal
12:00:02 <phaazon> /usr/bin/cabal
12:00:09 <phaazon> that sounds okay to me
12:00:29 <athan> hodapp: It's not that cool :P
12:01:09 <pecanpy> are you using haskell platform? do you have a Haskell\2014.2.0.0\lib\extralibs\bin folder?
12:01:27 <phaazon> no
12:01:41 <phaazon> I only have ghc and cabal installed
12:01:44 <hodapp> athan: well, a lot of stuff in Haskell and in functional-language-land appears to more be "Um, this is just _how you solve stuff_. This isn't cool, this is just everyday stuff and has been for decades."
12:01:46 <phaazon> I cabal everything else I need
12:02:06 <pecanpy> http://trac.haskell.org/haskell-platform/ticket/146
12:02:15 <pecanpy> oh ok. well good luck
12:02:19 <phaazon> what’s not cool?
12:02:24 <phaazon> thanks pecanpy ;)
12:03:07 <arianvp__> What is the point of the either package?  ExceptT doesn't constrain e to Errors anymor IIRC
12:03:07 <athan> hodapp: It's true! Still, though, mine's just a phony ._.
12:03:09 <arianvp__> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
12:03:13 <sinelaw> phaazon, running cabal install -v3 shows this line:
12:03:14 <sinelaw> ("/usr/local/bin/ghc-pkg",["dump","--global","-v0"])
12:03:26 <arianvp__> oh wait it also has other utils. nvm
12:03:28 <sinelaw> phaazon, its reading the global paackage database
12:04:08 <zplesivcak> batchm: can you reproduce the error I'm getting?
12:04:18 <zplesivcak> batchm: does it make sense somehow?
12:04:23 <phaazon> sinelaw: that’s normal
12:04:29 <batchm> zplesivcak moment please, I'll try
12:04:31 <phaazon> oh
12:04:33 <phaazon> wait no
12:04:34 <phaazon> that’s not
12:04:37 <phaazon> you should have this:
12:04:46 <phaazon> ("/usr/bin/ghc-pkg",["dump","--package-db=/tmp/mozilla-js-parser-api/.cabal-sandbox/x86_64-linux-ghc-7.8.3-packages.conf.d","-v0"])
12:05:20 <sinelaw> phaazon, I have a line before that too
12:05:21 <phaazon> Reading installed packages...
12:05:21 <phaazon> ("/usr/bin/ghc-pkg",["dump","--global","-v0"])
12:05:26 <phaazon> I have that as well
12:05:45 <phaazon> it only finds me ghc-pkg and ghc
12:06:29 <supki_> arianvp__: ExceptT is only in the newest transformers and it being the boot package is non-trivial to upgrade
12:06:41 <supki_> arianvp__: the upgrade breaks doctest, etc
12:06:49 <creichert> i wonder if a ghc-pkg recache would help
12:06:54 <sinelaw> phaazon, full dump http://lpaste.net/116114
12:06:56 <arianvp__> supki_: ah
12:07:08 <creichert> sinelaw: i wonder if a ghc-pkg recache would help
12:07:15 <creichert> shot in the dark :)
12:07:44 <sinelaw> creichert, will try - but first to figure out what's wrong before modifying the system state
12:07:52 <Kaidelong> is forall s. LogicT (ST s) safe?
12:08:05 <sinelaw> phaazon, ok, ghc-pkg dump --global
12:08:14 <Kaidelong> could one potentially mess with the logic tree by using STVars?
12:08:44 <Kaidelong> is the idea that, even if you can, it doesn't matter because it's still deterministic?
12:09:00 <sinelaw> phaazon, gives a ton of packages for me.
12:09:09 <batchm> zplesivcak I am getting the same behavior.. weird!
12:09:09 <vanila> Kaidelong, I dno't think that it's safe
12:09:20 <vanila> I don't know the details
12:09:30 <sinelaw> phaazon, do you have anything installed globally at all?
12:09:58 <phaazon> sinelaw: wait
12:10:11 <sinelaw> apparently not. ghc-pkg dump --global should not be empty if you do.
12:10:31 <Kaidelong> mmm, I guess LogicT (ST s) could be considered unsafe if it behaves differently from LogicT (StateT s Identity)
12:10:44 <zplesivcak> batchm: thank you very much, I'll try to ask it on Haskell Mailing list\
12:10:49 <phaazon> I got a ton of stuff as well
12:10:52 <Kaidelong> which I can see how this might be possible, since you can reverse changes to state with StateT, but not with ST
12:11:10 <batchm> zplesivcak, I usually use readFile, and this works as expected:
12:11:13 <batchm> main = readFile "zplesivcak.hs" >>= putStr
12:11:25 <batchm> still, I am curious why you're getting that behavior
12:12:09 <sinelaw> phaazon, so you don't have my problem with those specific packages
12:12:19 <zplesivcak> batchm: I'm still learning Haskell... thanks
12:12:33 <batchm> zplesivcak we all are :)
12:12:42 <zplesivcak> batchm: :)
12:12:47 <phaazon> sinelaw: sounds I don’t
12:13:02 <batchm> zplesivcak try asking in #haskell-beginners too, less traffic there, so your question will stay visible longer
12:13:21 <rgrinberg> what's the channel for snap again?
12:13:29 <sivteck> #snapframework
12:13:40 <rgrinberg> thanks
12:14:10 <sinelaw> phaazon, $ cabal info case-insensitive |grep installed
12:14:10 <sinelaw>     Versions installed: 1.1.0.3
12:14:55 <sinelaw> phaazon, and: $ cabal info text |grep installed
12:14:56 <sinelaw>     Versions installed: 1.1.0.0
12:14:59 <zplesivcak> batchm: ok, I'll try first there
12:15:00 <sinelaw> can you check that?
12:15:06 <sinelaw> not inside the sandbox!
12:16:40 <phaazon> phaazon@illusion ~ % cabal info case-insensitive | grep installed Versions installed: 1.2.0.1
12:16:53 <phaazon> phaazon@illusion ~ % cabal info text | grep installed Versions installed: 1.1.1.3
12:17:03 <free_beard> hi guys, i stumbled accros some code which uses the operator ':->' on Data.Ix . Can you please enlighten me on what it means? is i :-> j shorthand for range (i, j) ?
12:17:04 <phaazon> sinelaw: ^
12:17:10 <sinelaw> thanks
12:17:29 <sinelaw> phaazon, ironically cabal install text inside the sandbox - works
12:18:19 <shachaf> free_beard: You have a big advantage here in figuring this out, since you have the code and no one else does.
12:18:56 <free_beard> shachaf: I was weary of showing this http://r6.ca/blog/20110808T035622Z.html not to be made fun of
12:19:14 <shachaf> He defines :-> on that page
12:19:30 <shachaf> So without that code people wouldn't be very able to help you.
12:19:42 <free_beard> shachaf: thanks, I must be blind!
12:20:36 <free_beard> shachaf: ah, it's an infix constructor, right?
12:20:44 <shachaf> Yes.
12:20:54 <free_beard> shachaf: that's how i missed it, thanks a lot!
12:25:57 <arianvp__> I've asked this question here a few times but it always ends up with silence
12:26:03 <arianvp__> Are mutually recursive F-algebra's possible?
12:26:19 <arianvp__> Like can I make a mutually recursive version of  Fix ?
12:26:24 <hodapp> Is there some existing idiom for 'map over something, and fold the results with (>>) in a monad'?
12:26:54 <hodapp> I guess it's easy enough to do with a fold but what I'm doing feels like something that would be common
12:27:15 <phaazon> sinelaw: your issue is pretty weird
12:27:24 <vanila> arianvp__, you could apply the normal fix to a GADT with an index that lets you select one of several types to simulate mutual recursion
12:27:51 * arianvp__ needs to investigate GADTs
12:28:01 <sinelaw> phaazon, #hackage folks say that cabal ignores user-installed ~/.cabal stuff, but doesn't install system-wide stuff, which I may have (checking)
12:28:10 <sinelaw> phaazon, when in a sandbox I mean
12:28:21 <arianvp__> vanila: how would I make an indexed GADT?
12:28:23 <kadoban> hodapp: mapM_ ?
12:28:32 <wyager> I have a function of type ExceptT String IO ByteString. What is the idiomatic way to run a pure function of type Either String ByteString inside the monad? That is, if the function returns Left "error", I want the ExceptT to also return a Left "error".
12:29:06 <hodapp> kadoban: FUUUUU-
12:29:13 <hodapp> kadoban: thanks, that should have been obvious.
12:29:24 <kadoban> :) 'welcome
12:29:48 <vanila> arianvp__, data Types i where C1 :: ... -> Types A ; C2 :: ... -> Types A ; K1 :: ... -> Types B ; ...
12:30:03 <Denommus> luite: the Michael Snoyman is really interesting
12:30:03 <vanila> then Types A is a data type with the C constructors, Types B is a data type with the K constuctors
12:30:10 <Denommus> luite: but I don't get how to share the types yet
12:30:17 <vanila> so its a bit like type data types in one, and you can pick which one you like
12:30:28 <vanila> like two *
12:30:38 * hackagebot combinat 0.2.7.0 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.7.0 (BalazsKomuves)
12:30:40 * hackagebot combinat-diagrams 0.1 - Graphical representations for various combinatorial objects  http://hackage.haskell.org/package/combinat-diagrams-0.1 (BalazsKomuves)
12:30:57 <arianvp__> vanila: ahh
12:31:59 <luite> Denommus: i think you can download the example project where some of the files are shared between the two parts
12:33:55 <Denommus> luite: this one, right? https://github.com/snoyberg/polyconf-2014-haskell-webapp
12:34:08 <platz_> kind of suprised someone put up an ocaml 'transit' implmentation before a haskell one exists.  https://github.com/cognitect/transit-format/wiki/Community-Implementations  I wonder how hard this would be to implement
12:34:24 <luite> Denommus: yeah i haven't used it myself yet though
12:34:29 <Denommus> luite: nevertheless, thanks a lot for your work. I wish I could contribute to it, but I'm not having a lot of time in my hands
12:35:28 <sinelaw> luite, I'm done with work. I wanted to ask how you're doing dataflow analysis - are you using some package? (hoopl perhaps?)
12:35:40 <hodapp> 'sequence' and 'sequence_' both say 'Evaluate each action in the sequence from left to right', and they seem to work for what I'm doing... I guess it's just vague to me how I would connect 'evaluate' in my head with (>>), as that's what it's basically doing, isn't it?
12:36:01 <luite> sinelaw: no, and it's the most horrible part of the current version and the part that's not finished in the new version yet
12:36:35 <sinelaw> luite, have you considered hoopl?
12:36:52 <luite> sinelaw: the reason is that i have to be able to translate things back to reasonable js, it's more or less an AST with all break/continue nodes annotatd with their targets
12:37:05 <luite> sinelaw: yes, but i don't think it buys me much
12:38:55 <arianvp__> vanila: something like this ? http://lpaste.net/116117
12:39:14 <sinelaw> luite, why the break/continue specifically?
12:40:04 <luite> sinelaw: those are the ones where it's not immediately obvious from the ast structure
12:40:26 <vanila> arianvp__, I think the recursion should be done like 'a D'
12:40:28 <luite> sinelaw: the analysis has special cases for all control flow constructs in js
12:40:30 <sinelaw> luite, and what do you use the dataflow for?
12:40:53 <luite> sinelaw: constant folding, dead code elimination, liveness analysis
12:41:25 <sinelaw> nice
12:41:31 <sinelaw> and type inference?
12:43:31 <arianvp__> vanila: but then a would need kind *->*
12:44:14 <wyager> What is a nice-looking way to use a value of type Either String ByteString with an ExceptT String IO ByteString?
12:44:44 <luite> sinelaw: the current version has no type inference, the new version only has it at the start, for external, user supplied code. ghcjs keeps track of all types it produces itself from haskell primitives, and it knows the types of the rts functions it calls
12:45:02 <luite> sinelaw: it uses this to determine the applicable rewrite rules
12:45:30 <sinelaw> luite, I see.
12:45:33 <luite> sinelaw: like (+) is commutative for small ints but not for strings
12:47:08 <luite> sinelaw: often it can then statically determine some branch conditions, eliminate code, or propagate the values further on
12:47:47 <sinelaw> luite, sounds quite different than just inferring types, and quite a bit more complicated
12:48:00 <luite> sinelaw: it keeps the earlier part of the code generator simpler
12:48:19 <luite> sinelaw: this is easier to test, since the code should always have the same result before and after rewrite
12:48:56 <sinelaw> luite, easier than what?
12:49:18 <luite> sinelaw: but it's currently most horrible part of ghcjs, hence the rewrite :)
12:50:40 <hexagoxel> wyager: hoistEither
12:51:05 <luite> sinelaw: well for example when pattern matching on a constructor i can copy all fields to local variables. then the optimizer will remove all unused local vars. a local var that's used only once can be inlined immediately, one that's used multiple times will still get a local var to save the field lookup
12:51:24 <wyager> hexagoxel: I don't think that works for ExceptTs
12:51:43 <hexagoxel> wyager: oh, sorry, i misread
12:51:49 <sinelaw> luite, cool stuff
12:51:51 <luite> sinelaw: although i can decide to change that if it's used multiple times but in such a way that the code encounters each case only once, like var tmp = y.z; if(x) { a = tmp+1; } else { a + tmp+2; }
12:52:32 <wyager> If ExceptT's "except" let the type of Identity be unbound, it would be perfect
12:53:02 <luite> sinelaw: that's a simple change in the liveness analysis, namely how to count var usages from multiple mutually exclusive branches
12:53:16 <luite> sinelaw: and it would affect tmp var allocation for everything
12:53:58 <luite> sinelaw: there is also some optimization for stack pointer manipulation and other rts specific stuff
12:54:28 <luite> sinelaw: but without types and some other ghcjs specific things, the analysis is far weaker than i want
12:54:53 <sinelaw> luite, but since this is code you generate yourself, you know the types (par ffi), no?
12:55:01 <luite> sinelaw: haskell objects are immutable (everything that's mutable goes through a special primitive, like Array#, MutVar# (IORef) or MVar#
12:56:05 <luite> sinelaw: but the current code on github doesn't keep track of types, so it has to guess as it goes, and it has to be conservative, since a mistake in the wrong direction means a wrong program, it misses lots of optimizations because of this
12:56:17 <hexagoxel> wyager: so, `ExceptT . return` ?
12:56:32 <luite> sinelaw: the new experimental stuff has types everywhere, so yes, much more better :)
12:56:58 * hexagoxel finds hackage rather slow atm
12:57:39 <sinelaw> luite, cool! so for FFI you want some extra inference, then?
12:57:50 <luite> sinelaw: i'd like to get faster/smaller code output, but for my own sanity, and future maintainability it's better to do that with a better rewrite engine (with types), rather than special cases in the codegen or more tricky when-can-i-apply-this-rewrite rules in the current untyped one
12:58:32 <luite> sinelaw: yep for ffi i just have some basic inference to add as much knowledge as possible
12:59:04 <arianvp__> vanila: http://lpaste.net/116117
12:59:15 <luite> sinelaw: when there's more info about external code, the info can be stronger, the optimizer might be able to do more, like move calls around, or remove things that it knows have no side effects
12:59:19 <arianvp__> kind of struggling with the Functor instance
12:59:27 <wyager> hexagoxel: That's what I'm using, but it's ugly.
12:59:46 <arianvp__> as TypesF :: * -> (* -> *) -> *
13:00:26 <sinelaw> luite, my inference may not be a good fit for that, because of how strict is expects the input code to be.
13:00:36 <sinelaw> but maybe I can add some optional weakening rules
13:00:58 <luite> sinelaw: yeah i'd just like to have some best effort inference
13:02:06 <xuinkrbin> When trying to create documentation with haddock and/or `cabal haddock`, it seems I need to add "> --" before comments in a literate Haskell file if I want them to be visible in the resultant documentation, yes?
13:02:24 <luite> sinelaw: worst case, things get the 'anything' type, which can be undefined, null etc, the optimizer just can't do as much, and the linter may warn a bit
13:02:53 <sinelaw> luite that's an interesting use case, haven't thought of weakening it for libraries to be able to do best-effort stuff
13:03:03 <sinelaw> luite, I only had in mind people checking that their code is sane.
13:03:16 <chrisdone> sinelaw: so you're making a typed JS like typed core?
13:04:37 <luite> sinelaw: it would be nice to be able to print warnings based on the type inference in foreign imports, at the moment i only have some rudimentary lint checks to let me know when i'm doing incredibly stupid stuff :)
13:04:56 <sinelaw> chrisdone, not sure how much it's like core, but yes
13:05:32 <chrisdone> sinelaw: does it have types for objects?
13:05:46 <sinelaw> chrisdone, yes, it supports row polymorphism
13:06:01 <sinelaw> ~js function f(obj) { return obj.length;} return f
13:06:03 <chrisdone> sinelaw: does it have effect types?
13:06:05 <sinelaw> oops.
13:06:11 <sinelaw> chrisdone, no
13:06:21 <sinelaw> chrisdone, I support ML-style mutability
13:06:46 <sinelaw> ~js function f(obj) { return obj.length;} return f
13:06:47 <annoyabot> ({length: b, ...} -> b)
13:06:52 <sinelaw> chrisdone, ^^^
13:06:53 <chrisdone> what does ML-style mutability say in the type system?
13:07:18 <sinelaw> chrisdone, normally it says that you have a magic type called "ref"
13:07:32 <chrisdone> parametric?
13:07:35 <sinelaw> chrisdone, yes
13:07:55 <sinelaw> and: (:=) :: ref a -> ()
13:08:05 <sinelaw> ! :: ref a -> a
13:08:14 <chrisdone> ~js function f(x){ x.p = 123; return null;} return f
13:08:15 <annoyabot> ({p: TNumber, ...} -> TNull)
13:08:37 <sinelaw> chrisdone, no extension of records.
13:08:38 <chrisdone> are objects a subtype of ref?
13:09:11 <sinelaw> chrisdone, I don't actually have a "ref", because variables in JS are directly modfiiable. in ML variables are immutable but the immutable var may be holding a "ref" cell.
13:09:28 <chrisdone> well, technically only objects and bindings are modifiable
13:09:46 <chrisdone> if you pass in '1' or a string, you can't modify those
13:09:48 <sinelaw> chrisdone, so all variables are inferred to be mutable if they are modified after var decl
13:10:04 <sinelaw> chrisdone, what I mean is a binding
13:10:07 <sinelaw> var = binding
13:10:11 <cerberusiscute> names
13:10:44 <chrisdone> hm, ok
13:10:55 <sinelaw> chrisdone, in ML languages, you then need something called "the value restriction" to prevent polymorphism from screwing up soundness when doing mutable operations
13:12:14 <sinelaw> ~js var old = []; function remember(x) { var prev = old; old = [x]; return prev[0]; } remember(2); return remember
13:12:14 <annoyabot> (TNumber -> TNumber)
13:12:15 <Kaidelong> you technically need that in Haskell too, the approach Haskell has taken is to just be unsound
13:12:44 <Kaidelong> the assumption is, if programmers use things like unsafePerformIO they understand that they can subvert the type system
13:12:45 <sinelaw> chrisdone, in that example the 'remebmer' function does mutable things. inferring a->a would be wrong.
13:13:11 <sinelaw> Kaidelong, haskell segregates that stuff into explicit corner APIs
13:13:20 <chrisdone> hm, ok
13:13:40 <vanila> sinelaw, are yuo going to do a writeup of all this? this is great stuff
13:13:50 <Kaidelong> basically when Harper complains about Haskell he tends to shoot himself in the foot using things known to be unsafe, assuming that they shouldn't be allowed at all
13:13:54 <chrisdone> it'd be nice to have purity and impurity distinguished
13:14:09 <sinelaw> chrisdone, I think that's what haskell folks realized a while back :)
13:14:18 <chrisdone> for different reasons
13:14:21 <Kaidelong> I guess there is an advantage to that, in ML, you can't even in principle be unsafe
13:14:25 <chrisdone> in JS, you can use it for minification
13:14:40 <Kaidelong> because of the value restriction
13:15:24 <sinelaw> Kaidelong, not sure what ML does in corner cases like FFI
13:15:40 <luite> in ghcjs i use it to determine what stuff can be safely reordered / removed, but i have no inference for it
13:15:51 <chrisdone> yeah, clojure does this
13:15:54 <chrisdone> er, closure
13:15:59 <sinelaw> vanila, sure as soon as I have some minimal syntax of JS handled. I still don't support +, for example.
13:16:57 <sinelaw> also, supporting all of the builtin API is a headache
13:17:39 <chrisdone> what built in api?
13:18:14 <chrisdone> regexes and such?
13:18:56 <sinelaw> yes, and all properties/methods of all bulitin types
13:19:01 <chrisdone> :t bind
13:19:01 <lambdabot>     Not in scope: ‘bind’
13:19:02 <lambdabot>     Perhaps you meant one of these:
13:19:02 <lambdabot>       ‘find’ (imported from Data.List),
13:19:04 <chrisdone> =(
13:19:11 <chrisdone> did anyone define bind anywhere in a library?
13:19:18 * chrisdone checks monad-extras
13:19:25 <chrisdone> yay
13:20:36 <luite> chrisdone: yeah, unfortunately closure's inference isn't terribly succesful on ghcjs' code, things often look like they have side effects or the order matters when they touch some global rts var or some haskell heap object, while in reality the object's fields are never modified or the rts var value would never be seen by anything anyway
13:20:38 <chrisdone> sinelaw: is that a case of listing type signatures and phantom types?
13:20:40 * hackagebot amazonka-core 0.0.8 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.0.8 (BrendanHay)
13:20:42 * hackagebot amazonka 0.0.8 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.8 (BrendanHay)
13:20:44 * hackagebot amazonka-autoscaling 0.0.8 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.8 (BrendanHay)
13:20:46 * hackagebot amazonka-cloudformation 0.0.8 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.8 (BrendanHay)
13:20:48 * hackagebot amazonka-cloudfront 0.0.8 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.8 (BrendanHay)
13:21:27 <sinelaw> chrisdone, what?
13:21:30 <sinelaw> :)
13:22:34 <luite> chrisdone: often code looks like: h$sp += 2; someNonHaskellFunction(); h$sp +=3; where h$sp is the global stack pointer (index) for the current thread. if the function throws or would read that var, combining the updates would be unsafe
13:23:21 <luite> chrisdone: but ghcjs knows that if anything throws at that point, the stack is irrelevant, the thread gets aborted anyway
13:25:50 * hackagebot amazonka-cloudsearch 0.0.8 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.8 (BrendanHay)
13:25:52 * hackagebot amazonka-cloudsearch-domains 0.0.8 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.8 (BrendanHay)
13:25:54 * hackagebot amazonka-cloudtrail 0.0.8 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.8 (BrendanHay)
13:25:56 * hackagebot amazonka-cloudwatch 0.0.8 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.8 (BrendanHay)
13:25:58 * hackagebot amazonka-cloudwatch-logs 0.0.8 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.8 (BrendanHay)
13:27:37 <chrisdone> luite: mmk =)
13:29:22 <chrisdone> ah, nice. join .: traverse makes a handy non-operator alternative to >>=
13:29:27 <chrisdone> :t join .: traverse
13:29:28 <lambdabot> (Traversable m, Applicative m, Monad m) => (a1 -> m a) -> m a1 -> m a
13:29:45 <chrisdone> > join (traverse (lookup 1) (Just [(1,"hi")]))
13:29:46 <lambdabot>  Just "hi"
13:30:53 <chrisdone> thinks bind = flip (>>=) should be in base somewhere
13:31:00 * hackagebot amazonka-codedeploy 0.0.8 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.8 (BrendanHay)
13:31:02 * hackagebot amazonka-elasticbeanstalk 0.0.8 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.8 (BrendanHay)
13:31:04 * hackagebot amazonka-elastictranscoder 0.0.8 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.8 (BrendanHay)
13:31:06 * hackagebot amazonka-elb 0.0.8 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.8 (BrendanHay)
13:31:08 * hackagebot amazonka-emr 0.0.8 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.8 (BrendanHay)
13:32:41 <tasker> I get an error "Cabal library version>=1.19.2 && >=1.8 but no suitable version is installed.", and indeed ghc-pkg list shows Cabal-1.18.1.3. However cabal --version shows "cabal-install version 1.20.0.3 using version 1.20.0.2 of the Cabal library". What am I doing wrong ?
13:34:29 <shachaf> javjarfer: Most explanations of how GHC implements type classes that I've seen have been as asides while explaining other things.
13:34:49 <shachaf> E.g. SPJ explains it in the SYB talk?
13:34:57 <shachaf> In fact he explains it every time he talks about type classes.
13:35:17 <hexagoxel> tasker: it is possible that cabal-install (the executable called `cabal`) was linked with a different version of the Cabal library than what you have installed in your package database.
13:35:18 <shachaf> And I explained it once as an aside while explaining reflection.
13:35:50 <tasker> hexagoxel: Okay. How could I fix this ?
13:36:10 * hackagebot amazonka-iam 0.0.8 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.8 (BrendanHay)
13:36:12 * hackagebot amazonka-importexport 0.0.8 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.8 (BrendanHay)
13:36:14 * hackagebot amazonka-kinesis 0.0.8 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.8 (BrendanHay)
13:36:16 * hackagebot amazonka-kms 0.0.8 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.8 (BrendanHay)
13:36:18 * hackagebot amazonka-lambda 0.0.8 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.8 (BrendanHay)
13:37:06 <hexagoxel> tasker: once stuff is linked, the executable is independent. you can even install the binary distribution (via your os distribution, for example). the executable in no way uses the local Cabal library
13:37:37 <tasker> so why am I getting the error when I try to install stuff ?
13:37:38 <hexagoxel> tasker: as Cabal is a boot library, i think the only proper way is to upgrade your ghc version
13:37:50 <hexagoxel> or the platform
13:38:28 <carter> ehhh
13:38:28 <luite> that's not really true. GHC 7.8 depends on Cabal, so you can only used the supplied Cabal lib for packages that also depend on the ghc library
13:38:28 <hexagoxel> wait.. what library depends on >1.19.2?
13:38:39 <luite> but you can upgrade the Cabal lib for other things
13:38:42 <carter> true
13:38:45 <tasker> I possibly don't understand. Why is it not possible to upgrade the Cabal library? I mean, my executable (~/.cabal/bin/cabal) is the correct version.
13:38:47 <carter> plus you can upgrade ghc
13:39:38 <tasker> "distributive-0.4.4 failed during the configure step. The exception was:
13:39:38 <tasker> user error (The package 'distributive' requires Cabal library version >=1.19.2
13:39:39 <tasker> && >=1.8 but no suitable version is installed.)"
13:39:53 <geekosaur> tasker: because the Cabal library is used at runtime by things like template haskell and runghc, which will break if you upgrade the library
13:40:01 <tasker> hm, okay.
13:40:25 <tasker> easiest way to get ghc-7.8.3 installed on ubuntu ?
13:40:48 <luite> geekosaur: template haskell doesn't use Cabal
13:40:49 <hexagoxel> wait, latest ghc comes with Cabal 1.18.1.3
13:41:02 <hexagoxel> so that would not even be sufficient
13:41:04 <tasker> ..
13:41:07 <tasker> okay
13:41:14 <sivteck> latest GHC?
13:41:19 <sivteck> 1.20
13:41:20 * hackagebot amazonka-opsworks 0.0.8 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.8 (BrendanHay)
13:41:21 <statusfailed> hexagoxel: it comes with the Cabal library but not cabal-install right?
13:41:22 * hackagebot amazonka-rds 0.0.8 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.8 (BrendanHay)
13:41:24 * hackagebot amazonka-redshift 0.0.8 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.8 (BrendanHay)
13:41:26 * hackagebot amazonka-route53 0.0.8 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.8 (BrendanHay)
13:41:28 * hackagebot amazonka-route53-domains 0.0.8 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.8 (BrendanHay)
13:41:32 <statusfailed> hexagoxel: (I was trying to figure this out earlier)
13:41:36 <luite> geekosaur: it's onyl a problem if you also depend on the ghc package
13:41:39 <tasker> i currently have 7.8.3, and it seems to have 1.18.1.3
13:41:56 <hexagoxel> statusfailed: yes
13:42:00 <statusfailed> tasker: is that the version of cabal-install maybe?
13:42:05 <luite> but you have to be careful to have the same Cabal lib as cabal-install executable or you'll run into trouble at times
13:42:13 <statusfailed> hexagoxel: cheers hehe
13:42:29 <tasker> "cabal --version" -> "cabal-install version 1.20.0.3 using version 1.20.0.2 of the Cabal library"
13:42:49 <luite> and some packages that depend on both ghc and Cabal get built with the older Cabal version
13:42:56 <tasker> "ghc-pkg list" -> "/usr/local/lib/ghc-7.8.3/package.conf.d ... Cabal-1.18.1.3"
13:42:59 <luite> this problem has been solved in GHC 7.10
13:43:46 <tasker> luite: I am obviously a noob in this regard. I just want stuff to work. Would GHC 7.10 be a good idea ?
13:43:59 <luite> tasker: no since i'ts unreleased :)
13:44:07 <tasker> luite: I presumed as much :)
13:44:11 <luite> tasker: but it's coming soon!
13:44:12 <hexagoxel> i'd say use a sandbox and install your stuff (including a newer Cabal) there
13:44:17 <statusfailed> ooh Feb 2015
13:44:19 <carter> no
13:44:25 <tasker> hexagoxel: I actually am using a sandbox ;s
13:44:30 <carter> hexagoxel: instaed, cabal install cabal
13:44:34 <carter> then ummmm
13:44:36 <carter> idk
13:44:38 <tasker> carter: globally ?
13:44:42 <tasker> or within the sandbox
13:44:44 <carter> no
13:44:45 <carter> neither
13:44:47 <tasker> ;s
13:44:54 <carter> you're never allowed ot use --global
13:45:03 <tasker> er by global i just mean in my home dir
13:45:08 <tasker> e.g. not globally
13:46:30 * hackagebot amazonka-s3 0.0.8 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.8 (BrendanHay)
13:46:32 * hackagebot amazonka-sdb 0.0.8 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.8 (BrendanHay)
13:46:34 * hackagebot amazonka-ses 0.0.8 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.8 (BrendanHay)
13:46:38 * hackagebot amazonka-sns 0.0.8 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.8 (BrendanHay)
13:46:38 * hackagebot amazonka-sqs 0.0.8 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.8 (BrendanHay)
13:50:56 <flyingfisch> how do I retrieve values of a triple?
13:51:04 <flyingfisch> like ("test", 1, 2)
13:51:15 <flyingfisch> fst and snd seem to only work with pairs
13:51:16 <geekosaur> pattern matching, or lens
13:51:16 <exio4> using pattern matching?
13:51:24 <flyingfisch> ah ok
13:51:26 <shachaf> chrisdone: I think it's worth considering that the origin of the word "bind" is that do { x <- m; ... } "binds" a value to x
13:51:35 <shachaf> chrisdone: At least I think that's the origin.
13:51:41 * hackagebot amazonka-storagegateway 0.0.8 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.8 (BrendanHay)
13:51:42 * hackagebot amazonka-sts 0.0.8 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.8 (BrendanHay)
13:51:43 <geekosaur> > (\(_,_,x) -> x) ("test",1,2)
13:51:44 * hackagebot amazonka-support 0.0.8 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.8 (BrendanHay)
13:51:45 <lambdabot>  2
13:51:45 <shachaf> But maybe the word has taken on a life of its own by now. Who knows.
13:51:46 * hackagebot amazonka-swf 0.0.8 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.8 (BrendanHay)
13:52:10 <Chath> flyingfisch: Usually when you start getting bigger than a 2-tuple a lightweight record might work better
13:53:03 <flyingfisch> Chath: well it isn't getting any bigger than a triple, and if I really had to i guess I could use a 2-tuple
13:53:59 <gaze__> How do I lower a typeclass to a record if I want to extract the thing the typeclass has parameterized on back out?
13:55:52 <geekosaur> I don't understand the question. example?
13:55:55 <gaze__> oh I guess it's just like class C a where fn :: a -> Int; data D a = C a => M a goes to data D a = C a Int
13:56:19 <chrisdone> shachaf: right, m >>= \x -> … binds m's "result" to x in …. this is how it's described in Wadler's original monads paper. similarly bind (\x -> …) m does the same
13:56:35 <geekosaur> note that if you've only got a typeclass as a "handle", the original type is *gone*
13:56:35 <geekosaur> unless you use something like Typeable
13:56:43 <shachaf> Eh... Maybe. I guess.
13:57:07 <gaze__> geekosaur: I don't understand...
13:57:48 <gaze__> if I have a function f :: C a => D1 a -> D2 a
13:57:57 <gaze__> f will get to use all the functions that C provides
13:58:09 <gaze__> and return back a structure D2 parameterized on a
13:58:14 <gaze__> I don't see how I've lost anything
13:58:17 <geekosaur> then all you know about a is C a
13:58:24 <geekosaur> you cannot know the actual type of a
13:58:36 <gaze__> yes definitely!
13:58:39 <gaze__> that's totally cool
13:59:14 <gaze__> but whoever is using f can provide a D1 Blap and get back a D2 Blap provided D2 is an instance of C
13:59:37 <chrisdone> Compute m, bind the result to a, compute n, bind the result to
13:59:37 <chrisdone> b, compute o. The order of parentheses in such a computation is irrelevant.
13:59:37 <chrisdone> m*(λa.n*λb.o) = (m*λa.n)*λb.o
13:59:42 <gaze__> and f may call the functions of C in deciding how to construct a D2
13:59:45 <chrisdone> shachaf: from the paper ^
13:59:45 <gaze__> yes?
14:00:19 <shachaf> chrisdone: Yes, that's what I was thinking.
14:00:38 <geekosaur> yes
14:00:57 <shachaf> I don't like that "bind" is pronounced the same as ">>=".
14:01:03 <shachaf> But I don't care all that much.
14:01:15 <chrisdone> yeah, join also "binds" things
14:01:45 <Chath> What would another name for >>= be?
14:01:45 <chrisdone> but we're already at the point where that pronunication is there
14:01:48 <Chath> Just out of interest
14:02:01 <chrisdone> "mappend" isn't great either
14:02:12 <shachaf> join is great
14:02:31 <Chath> oh, yeah
14:02:52 <Chath> That's good, our join would just be join id
14:03:37 <chrisdone> join id?
14:03:57 <Chath> as in m (m a) -> m a
14:04:03 <chrisdone> :t join
14:04:04 <lambdabot> Monad m => m (m a) -> m a
14:04:07 <Chath> which is m >>= id
14:04:17 <hexagoxel> gaze__: if your class is Comonad, then there is extract :: Comonad w => w a -> a
14:04:29 <chrisdone> oh, you mean if (>>=) was also named "join"
14:04:40 <Chath> Oh yeah, sorry
14:05:06 <chrisdone> yeah that would possibly have been nice
14:05:58 <Chath> I wonder what a Prelude designed from scratch would look like
14:07:48 <Chath> mappend is weird too, could you call that append or is a Monoid too general to straight up call it append?
14:08:07 <chrisdone> well it's just any old binary operation
14:08:35 <shachaf> associative binary operation within one type with an identity
14:08:36 <chrisdone> though assocBinOp doesn't have a nice ring to it
14:08:55 <hexagoxel> AMP will add some redundancy to the Prelude..
14:11:49 <chrisdone> although if there's "ap", you might as well have "op"
14:13:15 <chrisdone> i'm thinking about how to add type-directed completion to haskell-mode
14:14:34 <chrisdone> algoly OO syntax makes method/property completion super easy: x. ← the . lets your editor simply look at the expression behind it, do a lookup, then provide a choice
14:15:11 <chrisdone> and it chains nicely: person.family.parent.father you can write this and at each stage get a list of choices
14:16:18 <chrisdone> in haskell you tend to write
14:16:18 <chrisdone> person -- okay, what can i get out of this? uhhh… then you peruse APIs for a while or if you're lucky you hoogle, then you write:
14:16:18 <chrisdone> family person -- repeat until you have:
14:16:18 <chrisdone> father (parent (family person)))
14:16:37 <chrisdone> at each step you have to do some jiggery pokery and work backwards to add something further up the hierarchy
14:16:50 <chrisdone> (same goes for father . parent . family $ person)
14:17:59 <chrisdone> so i'm thinking, perhaps if you had a special keybinding, let's call it K, that would automatically jump you into parent function application position, you could also at the same time do a completion
14:18:54 <chrisdone> so you could type person K family K parent K father, which would yield these steps:
14:18:54 <chrisdone> family| person
14:18:54 <chrisdone> parent| (family person)
14:18:54 <chrisdone> father| (parent (family person))
14:19:25 <chrisdone> and then if you have type-based completion, you could potentially cut that down to: person K f K p K f TAB
14:19:36 <batchm> someone asked about this a while ago: http://lpaste.net/116105
14:19:56 <batchm> when --putStr res is commented nothing is printed, just an empty line
14:20:07 <batchm> when it is uncommented the content of the file is printed twice
14:20:12 <monochrom> that is correct behaviour.
14:20:14 <batchm> am I right that this is lazy IO at work?
14:20:17 <athan_> Is there a way to show curly braces in haddock?
14:20:18 <chrisdone> yup
14:20:26 <athan_> `@\{@` is just hiding it :(
14:20:31 <monochrom> yes and no. putStr is not lazy. hGetContents is.
14:20:33 <chrisdone> hGetContents reads until the handle is closed or eof is reached, iirc
14:20:44 <batchm> putStr forces evaluation of res, which forces reading from a file
14:20:46 <chrisdone> so withFile will close the handle, so hGetContents happily returns the empty string
14:20:53 <batchm> without it nothing is read, and withFile closes the file before anything is read
14:20:58 <batchm> yeah
14:21:10 <sinelaw> chrisdone, did you see what Peaker did in lamdu?
14:21:14 <chrisdone> putStr forces the string, which forces hGetContents to read some chars from the handle
14:21:23 <sinelaw> for completion
14:21:24 <batchm> yes
14:22:11 <batchm> plenty of pitfalls in lazy IO
14:22:50 <monochrom> this is why in my IO tutorial I simply skip it
14:23:10 <monochrom> you need a lazy evaluation expert to use lazy I/O correctly
14:23:29 <sinelaw> you mean lazy evaluation engineer
14:23:43 <sinelaw> but seriously, most tutorials / books don't even mention that it's a major pitfall
14:23:45 <monochrom> I mean what I write.
14:23:51 <sinelaw> and kind of gloss over it
14:24:06 <monochrom> it's convenient for toy programs
14:24:14 <brianpWins> I have a signature “funkyMap :: Integral a1 => (a1 -> a) -> (a1 -> a) -> [a1] -> [a]” and I’m trying to get it to the signature “funkyMap :: (a1 -> a) -> (a1 -> a) -> [a1] -> [a]” but i don’t know how.
14:24:22 <monochrom> but a hammer is also convenient
14:26:35 <brianpWins> So. how can I define that method without specifying the value needs to be an integral?
14:26:37 <RyanGlScott> Does Language.Haskell.TH have a utility for checking if a Name represents a tuple?
14:26:40 <chrisdone> sinelaw: yeah, in lamdu you would select "person" and hit SPC
14:26:43 <brianpWins> Integral*
14:26:50 <silasm_> brianpWins: how does ‘funkyMap f g’ decide between (or combine) the output of f or g?
14:27:16 <chrisdone> sinelaw: so it doesn't really solve this problem afaik
14:27:57 <brianpWins> silasm_: oh crap. “and applies f to all elements at even positions in xs and g to all elements at odd positions” I was doing it based of even and odd values. Not positions.
14:27:58 <sinelaw> chrisdone, so it takes into account both the outer scope type 'b' and the highlighted expression type 'a' and finds stuff that satifies both, i.e. a -> b
14:28:12 <brianpWins> if i do it with positions then the values can be anything removing the Intgral
14:28:16 <monochrom> brianpWins: are you, basically, debating with the compiler?
14:28:26 <silasm_> brianpWins: there you go, then :)
14:29:39 <chrisdone> sinelaw: yeah, and?
14:30:42 * hackagebot generic-lucid-scaffold 0.0.1 - General-purpose web page scaffold for Lucid.  http://hackage.haskell.org/package/generic-lucid-scaffold-0.0.1 (athanclark)
14:31:12 <sinelaw> I guess in your example there is no function that goes straight from the current expression to the expected type
14:31:56 * chrisdone frowns
14:32:36 <monochrom> use djinn. you will get such completion never seen in other languages
14:32:48 <monochrom> or rather, in other IDE
14:32:56 <chrisdone> heh
14:33:00 <sinelaw> chrisdone, are you able to tell types of the outer context and the type of the current expression?
14:33:04 <chrisdone> for a teeny tiny limited subset of haskell
14:33:05 <athan_> chrisdone: I'm watching you
14:33:12 <sinelaw> I mean what kind of information do you have at that point
14:33:14 <bitonic> monochrom: apart from Agda obviously :)
14:34:11 <trap_exit> linux greatness
14:34:32 <chrisdone> sinelaw: oh. i have the child expression easily, the parent would be trickier
14:35:08 <chrisdone> oh could replace the expression with undefined or a hole and extract the type, but it would have an on-demand overhead
14:35:15 <chrisdone> s/oh/one/
14:35:21 <sinelaw> chrisdone, so yeah I would go for a key that finds functions you can apply on the current expression
14:35:28 <sinelaw> was just thinking about undefined too
14:35:59 <sinelaw> anyway the current expr may be removed several applications away form the expected type
14:36:00 <chrisdone> yeah, in my emacs right now i can type C-M-<space> C-c C-t to get the type of the current expression
14:36:09 <sinelaw> so not knowing the expected type isn't so bad
14:36:16 <sinelaw> *from
14:36:26 <chrisdone> yeah, also if i'm changing the expected type, i don't want filtering restricted
14:36:35 <chrisdone> the expected type, imo, should be used for ordering, if anything
14:36:59 <sinelaw> right
14:37:09 <sinelaw> chrisdone, when I do that key I get: haskell-mode-enable-process-minor-mode: You tried to do an interaction command, but an interaction mode has not been enabled yet.
14:37:21 <batbird> sinelaw: derp
14:37:38 <sinelaw> likewise.
14:37:43 <chrisdone> sinelaw: eval and add (add-hook 'haskell-mode 'interactive-haskell-mode) to your .emacs
14:38:11 <chrisdone> fwiw i made an "out of the box" preconfigured haskell-mode here: https://github.com/chrisdone/emacs-haskell-config
14:38:26 <chrisdone> including cabal repl + ghci-ng support
14:38:42 <chrisdone> and hindent and haskell-docs, but those are optional
14:39:03 <chrisdone> sinelaw: anyway, i think that getting that information is a piece of cake. the hard part imho is how to make a nice user experience for this
14:39:38 <chrisdone> the "person." → "age, family, id, address" *picks family* "person.family." → "parents, cousins, children" etc.
14:39:54 <sinelaw> chrisdone, cool, will take a look
14:40:10 <chrisdone> that workflow is VERY cheap, the user literally has to just write "person.f.p." etc
14:40:19 <chrisdone> i want that exact cheap workflow for haskell, but for regular functions
14:40:28 <chrisdone> perhaps if the user types a double dot?
14:40:37 <trap_exit> anyone have a good resource on how to setup a surface pro3 for haskell dev ?
14:40:39 <chrisdone> or something
14:41:08 <cutuchiq1eno> quit
14:41:12 <chrisdone> never!
14:41:22 <MP2E> lol
14:41:26 <sinelaw> huh
14:41:30 <sinelaw> *hah
14:41:42 <monochrom> install some kind of ssh client on the surface pro3. use it to ssh into a linux server.
14:41:57 <chrisdone> monochrom: any ideas? =3
14:42:31 <chrisdone> if we solve this nicely it'll really level up the way you can write haskell
14:44:20 <mmmm> Is there a package to help bridge between ErrorT and ExceptT?
14:46:09 <monochrom> chrisdone, I mentioned djinn because of the following consideration. suppose you are pointing at an expression of type X, and somehow the computer knows that your final goal is of type Y. the computer also knows a bunch of available functions, "helper :: X -> Z", "aux :: Z -> G", "elf :: X -> K", "minion :: K -> Z -> Y", "follower :: Z -> G -> G"
14:46:56 <sinelaw> chrisdone are you considering using company-mode for this?
14:47:03 <monochrom> then you are effectively asking "is there a way to use a subset of these things, plus function application, to obtain a function of type X -> Y?"
14:47:13 <monochrom> this is a problem solved by djinn.
14:47:23 <chrisdone> sinelaw: haven't thought that far ahead, that's the boring part
14:47:49 <monochrom> djinn also does some other things, but this is the simplest kind of question djinn can answer.
14:47:57 <sinelaw> yeah, it is. but then you get the built in C-space and completion list, bla bla bla
14:48:24 <chrisdone> sinelaw: C-space in emacs is set-mark =p
14:48:28 <chrisdone> monochrom: right, that's true
14:48:55 <sinelaw> chrisdone, whatever company uses by default. Haven't used it in a while - kinda annoying
14:49:21 <chrisdone> monochrom: i think you would have to throw your whole codebase into djinn, and djinn doesn't know about things as simple as lists. presumably you mean "use djinn's idea, not djinn itself"
14:49:52 <monochrom> djinn does not grok recursion. that's all.
14:49:56 <chrisdone> sinelaw: in the past i used autocomplete.el. haven't tried company, people seem to like it /me shrugs
14:50:16 <sinelaw>  /me shrugs too
14:50:29 <sinelaw> too much other stuff to worry about
14:53:30 <pavonia> I'm still trying to build the curl package, and cabal configure and build seem to work fine (I pass the curl dev directories via --extra-include/lib-dirs), but the registering fails. Does anyone have an idea what could be the problem here? http://lpaste.net/115551
14:53:49 <v4n> >
15:06:50 <nuttycom> I've a question about Persistent. I'd like to be able to use it, but without using TH to generate the record types, and hopefully without writing a ton of boilerplate. The data types I want to use are in a library that shouldn't depend upon Persistent. Ideally I'd simply use a newtype in the library that depends upon Persistent, and then something to generate the PersistEntity instance for that newtype. Is there way to do this?
15:09:10 <pavonia> This is really stange, all the mentioned files are in the dist/build directory but apparently cabal can't find them
15:10:44 * hackagebot bet 0.1.2.0 - Betfair API bindings. Bet on sports on betting exchanges.  http://hackage.haskell.org/package/bet-0.1.2.0 (Adeon)
15:11:04 <sinelaw> luite, do you generate "for .. in .. " statements in ghcjs?
15:11:36 <nuttycom> Or does it make more sense to just define entirely new datatypes and an isomorphism just for Persistent?
15:21:38 <nuttycom> Anyone? :/
15:21:49 <ReinH> I would say that Haskell isn't unsound. unsafePerformIO is unsound, but unsafePerformIO also isn't Haskell per se.
15:22:02 <ReinH> Oh, that was an old conversation, never mind
15:27:29 <dfeuer> carter, I did have one crazy idea. Count nodes on the way down the fingertree spine, then unsafeCoerce all the way down to the 2-3 tree leaves.
15:29:23 <pecanpy> If I was working with functions that took and returned (a, StdGen) tuples. Would I use something like the State Monad to make life easier?
15:30:17 <batchm> pecanpy yes
15:30:25 <batchm> pecanpy or even better, MonadRandom
15:31:28 <pecanpy> batchm: thanks. ill take a look.
15:31:38 <batchm> that way you can use same random function with both pure code and with auto-updated seed when you're working in IO
15:33:59 <dkibi> bit of a beginners question, but my google foo failed me: suppose I have two functions t :: Maybe A and p :: A -> Maybe B then I could just write t >>=p to get a function of type Maybe B. But how do I ("idiomatic") proceed if t is of type IO (Maybe A) (to get a function of type IO (Maybe B)
15:34:22 <dfeuer> Maybe A is not a function type.
15:34:56 <dfeuer> dkibi, you should be able to use fmap.fmap, I think.
15:35:08 <dfeuer> Oh wait, wrong type.
15:35:13 <EvanR> and IO whatever is not a function type
15:35:33 <monochrom> I would simply replace "function" by "thingie"
15:35:42 <dfeuer> t >>= fmap p
15:35:57 <monochrom> is p still A -> Maybe B?
15:35:57 <dfeuer> monochrom, how 'bout "value"?
15:36:09 <monochrom> yes, "value" is good
15:36:30 <dkibi> oh thats new to me, I always thought of it as a constant function, do you have any link regarding the difference?
15:36:41 <dkibi> monochrom: yes
15:36:56 <dfeuer> dkibi, functions have -> in their types once all type synonyms are expanded.
15:36:56 <EvanR> functions have type a -> b, if theres no arrow, its not a function
15:37:35 <batchm> pecanpy take a look: http://lpaste.net/116131
15:37:40 <monochrom> "t >>= fmap p" may be still a type error
15:38:22 <monochrom> t >>= \x -> return (x >>= p)
15:38:53 <pecanpy> batchm: thats pretty close to how i wanted to use it to. just getting random elements from a list over and over
15:39:06 <pecanpy> i appreacite it!
15:39:31 <batchm> pecanpy you can call randomNick straight in IO, and it will use random*IO functions under the hood. or you can use evalRand and runRand with a manual generator, if you're not working in IO
15:39:41 <batchm> with a manual seed*
15:39:44 <batchm> welcome!
15:39:50 <dfeuer> :t t >>= fmap p
15:39:51 <lambdabot>     Couldn't match expected type ‘m (m a0)’ with actual type ‘Expr’
15:39:51 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘t’
15:39:51 <lambdabot>     In the expression: t >>= fmap p
15:40:01 <monochrom> t >>= fmap (>>= p)  but this is stretching it
15:40:07 <dfeuer> Hrrrrr
15:40:28 <monochrom> beware of free variables!
15:40:44 <dfeuer> monochrom, oh, I see.
15:42:55 <monochrom> t >>= fmap (>>= p) is wrong. it should be fmap (>>= p) t
15:44:01 <EvanR> >>= fmap p fmap >>= t (<*>)
15:44:06 <nuttycom> dkibi: I think a >>= return . (=<<) f is what you want
15:44:23 <ReinH> nuttycom: seems unlikely
15:45:20 <dkibi> is "t >>= \x -> return (x >>= p)" wrong, or just verbose? It seams correct to me
15:45:43 <monochrom> it is correct.
15:46:33 <dfeuer> Yes, monochrom.
15:47:12 <ReinH> You can apply the bind applicatively:
15:47:14 <ReinH> :t \k x -> (>>=) <$> k <*> x
15:47:15 <lambdabot> (Applicative f, Monad m) => f (m a) -> f (a -> m b) -> f (m b)
15:47:30 <ReinH> :t \k x -> (>>=) <$> pure k <*> x
15:47:31 <lambdabot> (Applicative f, Monad m) => m a -> f (a -> m b) -> f (m b)
15:47:35 <nuttycom> Oh, that's nice.
15:47:57 <ReinH> :t \x k -> (>>=) <$> x <*> pure k
15:47:58 <lambdabot> (Applicative f, Monad m) => f (m a) -> (a -> m b) -> f (m b)
15:48:56 <EvanR> @pl \x k -> (>>=) <$> x <*> pure k
15:48:56 <lambdabot> (((>>=) <$>) .) . (. pure) . (<*>)
15:49:19 <ReinH> @pl \x k -> liftA2 (>>=) x (pure k)
15:49:19 <lambdabot> (. pure) . liftA2 (>>=)
15:49:29 <ReinH> @pl \k -> liftA2 (>>=) x (pure k)
15:49:29 <lambdabot> liftA2 (>>=) x . pure
15:49:40 <ReinH> Not sure that pointfree is better here anyway
15:55:18 <nuttycom> :t \a p -> a >>= return . (=<<) p
15:55:19 <lambdabot> (Monad m1, Monad m) => m (m1 a) -> (a -> m1 b) -> m (m1 b)
15:57:33 <EvanR> at that rate, maybe do notation would be easier to read
15:58:19 <athan> :t (>>= return . (=<<))
15:58:20 <lambdabot> (Monad m1, Monad m) => m (a -> m1 b) -> m (m1 a -> m1 b)
15:58:30 <athan> poo
15:59:56 <Haskall> @pl grt l a = (>) l a
15:59:57 <lambdabot> grt = (>)
16:03:05 <dkibi> thx for your help! :)
16:07:37 <Geraldus> It seems I have somepackages installed with previous cabal version and others with newer one, and some packages seems to be broken, e.g. I have haskell-src-exts installed, but compiler can't find H.PNeg data type from it. When I try to reinstall it cabal says that this reinstall will break other packages. What is the best solution in this case? Delete all installed packages and reinstall everything with same cabal and cabal-install
16:20:05 <pavonia> Here is an updated version of my cabal register error, run with -v3: http://lpaste.net/116132  I still can't see why registration would fail
16:22:09 <pavonia> What makes me a liitle suspicious is that the cc-options and ld-options fields in curl.buildinfo are empty. I don't know if that's intended
16:24:12 <athan> pavonia: Are you meaning to use an old version of GHC?
16:24:53 <pavonia> Well, I just haven't updated for a long time
16:25:38 <athan> O_O
16:26:19 <pavonia> The problem is updating means building packages depending on c-libs which is simply a pain on Windows :(
16:26:46 <athan> I'm sorry, I wish I could help
16:27:42 <athan> ...why isn't it seeing that the folder (you're currently inside)... Why doesn't it see all those files exist?
16:27:45 <athan> that's nuts
16:29:11 <pavonia> Yeah, that's really weird
16:43:48 <Fuuzetsu> chrisdone: what's up
16:57:13 <batchm> is this a safe use of unsafePerformIO? (i keep forgetting when it is unsafe to use it). http://lpaste.net/116135
16:57:20 <batchm> sorry, unsafeInterleaveIO
16:59:05 <Geraldus> Does anybody knows, can I downgrade some packages if I use Stackage snapshot and there is higher version of packege in it?
17:04:58 <mietek> Geraldus: what are you trying to install?
17:05:44 <nshepperd> batchm: that should probably be called unsafeRepeatIO
17:05:55 <Geraldus> haskell-src-exts, I have 1.16.0.1 and there is breaking change since 1.15.0.1
17:06:21 <Geraldus> I want to make sublimehaskell plugin works correctly. https://github.com/SublimeHaskell/SublimeHaskell/issues/182
17:06:36 <nshepperd> batchm: if you used it on an action containing modifyIORef for example, you could have reference cells change under your feet depending on evaluation order
17:07:15 <Geraldus> But I'm trying to replace preinstalled plugin with another one from `hsdev` branch now.
17:10:48 * hackagebot learning-hmm 0.3.0.1 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.0.1 (mnacamura)
17:11:16 <ReinH> batchm: why would you want to use unsafePerformIO there? You're already writing an IO action
17:12:06 <Gurkenglas> How do I do e^(pi*i) in haskell?
17:12:56 <batchm> ReinH I corrected myself, I'm using unsafeInterleaveIO
17:13:07 <nshepperd> Gurkenglas: Data.Complex
17:13:08 <batchm> nshepperd hmm I see
17:15:31 <Gurkenglas> Oh, RealFloat a => Floating (Complex a). Makes sense now.
17:16:38 <tommd> I like that line.  It could be used sarcastically by a beginner and honestly even by people with relatively little exposure.
17:17:09 <nshepperd> batchm: I think unsafeInterleaveIO is generally only 'safe' on actions that have no observable effects you care about, like reading a file
17:20:46 <ReinH> batchm: Why do you need unsafeInterleaveIO?
17:21:03 <batchm> because I'll get infinite loop without it
17:21:11 <batchm> making the function useless
17:24:57 <batchm> well, not useless, but less useful at least
17:24:59 <glguy> I'd think at a minimum you'd want to rewrite that use of unsafeInterleaveIO to do it once at the top rather than to call unsafeInterleaveIO once for each recursive call
17:25:14 <batchm> it could not lazilly collect the results
17:25:49 * hackagebot peyotls 0.1.6.2 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.2 (YoshikuniJujo)
17:26:38 <batchm> glguy that worked too, but I am not sure I get what difference it makes
17:27:00 <glguy> well, right now you aren't lazy in the first element of the list, at a minimum
17:27:01 <batchm> glguy when we recursively call repeatIO unsafeInterleaveIO will be called again
17:27:16 <batchm> I see
17:28:00 <glguy> I'm just chatting about it, I haven't needed to write something like this before
17:35:50 <glguy> unsafeRepeatIO m = unsafeInterleaveIO (do x <- m; xs <- unsafeRepeatIO m; return (x:xs)) -- I don't know that it's a good idea, but it seems to work on small examples ^_^
17:38:56 <mmmm> Is there a package to help bridge between ErrorT and ExceptT?
17:42:53 <Gurkenglas> When I run https://www.fpcomplete.com/user/Gurkenglas/signalverarbeitung -> Fourierkoeffizienten, it sometimes outputs rows of complex numbers rounded to the 5th digit, and sometimes it rounds to integers. It seems to be random, and constant within a run. What gives?
17:44:17 <Gurkenglas> Ah, not that random. It seems to fail 0-2 times whenever I substitute the %.5f for a %.2f or vice versa
17:44:53 <Gurkenglas> (Smells like unsafePerformIO in the printf package)
17:45:21 <Gurkenglas> (dunno why, got a hunch; might be something else unsafe)
17:51:06 <batchm> what is that library called.. type safe version of printf?
17:51:46 <peddie> batchm: formatting
17:51:51 <peddie> @hackage formatting
17:51:51 <lambdabot> http://hackage.haskell.org/package/formatting
17:51:55 <batchm> thanks!
17:52:13 <thang1> I was gonna guess prints where the 's' stands for 'safe' and the 'f' stands for 'fuck it we'll do it in prod'
17:52:21 <thang1> But that works
17:55:50 * hackagebot gtk3 0.13.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.3 (HamishMackenzie)
18:00:50 * hackagebot gtk 0.13.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.3 (HamishMackenzie)
18:03:03 <akurilin> I could use some help: how do I filter the more verbose log messages with Control.Monad.Logger?
18:03:10 <akurilin> I can't find examples of that being done anywhere
18:03:28 <akurilin> e.g. in my case persistent logs a bunch of stuff at debug level and I'm trying to filter that out
18:09:24 <Haskall> @pl wh a = (a * 0) - 1
18:09:24 <lambdabot> wh = subtract 1 . (0 *)
18:10:40 <Axman6> pl needs more mathematical identities
18:11:40 <kirill_> Axman6: 0 * nan = nan /= 0
18:12:40 <kirill_> It would be really bad for pl to suggest inequivalent transformations.
18:13:05 <Axman6> IEEE-754 strikes again!
18:13:06 <shachaf> @pl a + (b + c)
18:13:07 <lambdabot> a + b + c
18:13:34 <kirill_> :i +
18:13:41 <shachaf> + is infixl
18:13:43 <shachaf> @pl (a + b) + c
18:13:43 <lambdabot> a + b + c
18:13:53 <shachaf> It does plenty of invalid things.
18:14:21 <kirill_> shachaf: Oh, interesting, never mind then.
18:16:28 <shachaf> I'm not saying it should.
18:16:36 <shachaf> Though probably "+ is associative" is pretty harmless.
18:17:15 <pecanpy> is there a high level network library that comes with HP? something like: tags = download "whatever.com"
18:17:41 <Welkin> like wget?
18:18:13 <batchm> @pl a - (b - c)
18:18:13 <lambdabot> a + b - c
18:18:59 <Axman6> wait...
18:19:04 <Axman6> what?
18:19:18 <batchm> I am puzzled too
18:19:26 <Haskall> lol
18:19:38 <Haskall> @pl (a - b) - c
18:19:38 <lambdabot> a - b - c
18:19:44 <Haskall> @pl - (a - b) - c
18:19:44 <lambdabot> (line 1, column 1):
18:19:44 <lambdabot> unexpected "-"
18:19:44 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:19:47 <shachaf> Good old @pl.
18:19:58 <kirill_> pecanpy: getResponseBody =<< simpleHTTP (getRequest "http://www.haskell.org/") using http://hackage.haskell.org/package/HTTP
18:19:59 <Haskall> @pl -(a - b) - c
18:19:59 <lambdabot> (line 1, column 1):
18:19:59 <lambdabot> unexpected "-"
18:19:59 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:20:15 <shachaf> Haskall: Please experiment with lambdabot in /msg.
18:21:04 <pecanpy> kirill_: is that the same as http-conduit?
18:21:55 <kirill_> pecanpy: No, I think it's a different package
18:22:22 <pecanpy> ok. i only asked cause i saw they both have a method "simpleHTTP". ill check that out. thanks
18:23:13 <kirill_> pecanpy: In https://hackage.haskell.org/package/http-conduit-2.1.5/docs/src/Network-HTTP-Conduit.html
18:23:23 <kirill_> it seems to have its own definition of simpleHttp
18:35:52 * hackagebot bindings-portaudio 0.1 - Low-level bindings to portaudio library  http://hackage.haskell.org/package/bindings-portaudio-0.1 (FumiakiKinoshita)
18:40:41 <kirill_> What is the status of gmp in ghc?
18:40:41 <kirill_> Do I still need to compile ghc myself with integer-simple if I want to use gmp or some library that uses it, like mpfr?
18:44:26 <pecanpy> parsing that html with tagsoup crashed ghci :/
18:44:44 <pecanpy> is there a way to catch the error so i can see what happened
18:47:02 <kirill_> Is it an internal ghci error?
18:49:10 <ReinH> kirill_: integer_simple is the one that *doesn't* use gmp
18:49:43 <ReinH> kirill_: are you saying the default integer impl with gmp conflicts somehow?
18:49:44 <pecanpy> the error was: Loading package text-1.2.0.0 ... GHCi runtime linker: fatal error: I found a duplicate definition for symbol
18:49:47 <pecanpy> _hs_text_memcpy
18:50:20 <pecanpy> whilst processing object file \AppData\Roaming\cabal\x86_64-windows-ghc-7.8.3\text-1.2.0.0\HStext-1.2.0.0.o
18:50:32 <pavonia> pecanpy: What does "ghc-pkg check" give you?
18:50:56 <kirill_> ReinH: It used to be that the version of gmp that implements Integer in integer-gmp used ghc's own allocation routines, so any other function that called a gmp function that tried to allocate anything might cause a crash.
18:51:24 <pecanpy> pavnia: all clear with --simple-output, otherwise a bunch of irrelevant warning about hackage docs
18:51:25 <kirill_> ReinH: So integer-simple is the version that allows me to use gmp not just in Integer, but in non-ghc libraries too.
18:52:24 <kirill_> ReinH: So is it still the case that I need to compile ghc *not* to use gmp, so that I *can* use gmp myself?
18:52:24 <merijn> kirill_: I think that's getting fixed Real Soon Now (TM) :)
18:52:51 <kirill_> merijn: That's not funny at all :)
18:52:53 <pavonia> pecanpy: Your installation of text seems to be messed up somehow
18:52:54 <merijn> kirill_: I think the solution is going into either 7.10 or is being implemented in 7.12, but ask in #ghc for details
18:53:12 <merijn> kirill_: No, I meant that in a "a design has been proposed and is planned to be implemented" sense
18:53:21 <merijn> kirill_: Not in a "never happening" sense
18:53:23 <pecanpy> pavonia: splendid? lol
18:53:41 <pecanpy> i just install the latest HP today. i can't imagine how much damage i could have done
18:54:32 <pavonia> Hhm, it should really work then
18:54:49 <merijn> kirill_: It's just that GHC is understaffed, so "proposed and planned" can take a while to materialise, depending on the time of the implementers. Of course, testers/help are always welcome ;)
18:55:01 <pecanpy> if i do "cabal install text" will it reinstall?
18:55:15 <Welkin> how large is the team working on ghc?
18:55:26 <merijn> Welkin: full time or part time?
18:55:33 <Welkin> does it still include any of the original members besides SPJ?
18:55:47 <merijn> I would say there's like 5 people being paid to hack GHC full time? Give or take a few
18:55:49 <pavonia> pecanpy: Oh well, it's not just you https://github.com/mvoidex/hsdev/issues/9
18:56:23 <merijn> More volunteers are always welcome ;)
18:57:37 <kirill_> merijn: Thank you; when I tried to implement a multiple precision fp mathematics on top of mpfr and haskell (like mpmath), I ran into that issue.
18:58:19 <merijn> kirill_: I think thoughtpolice and/or hvr are working on it, ask them about it
18:59:40 <pecanpy> between this, cabal issues and eclipsefp issues ive spent the last two days just trying to get things to work rather than coding. :/
19:00:15 <Welkin> pecanpy: just clean out everything and do a fresh install of the platform
19:00:32 <pecanpy> lol. i already did that this morning
19:01:07 <merijn> pecanpy: Out of curiosity, if you compile and run that same code does it work then?
19:01:12 <merijn> pecanpy: i.e. is it just ghci?
19:01:19 <pecanpy> ill try now. brb
19:02:04 <merijn> I know 2 things, the way linking is done in 7.8 has changed, ghci relies on dynamic linking and some linker issues exist on 64bit windows
19:02:21 <merijn> Or was it 32bit?
19:02:26 <merijn> Which windows are you using?
19:05:54 * hackagebot plot-lab 0.0.1.6 - A plotting tool with Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-lab-0.0.1.6 (sumitsahrawat)
19:06:25 <pecanpy> win 8, 64 bit
19:06:41 <Welkin> oh
19:06:43 <pecanpy> merijn: seems to compile and run ok
19:06:43 <Welkin> that is why
19:06:55 <Welkin> windows
19:06:58 <pecanpy> but... im not actually printing out the result
19:07:09 <pecanpy> how do i print type IO [Tag String]
19:07:14 <Welkin> pecanpy: another option is to just run gnu/linux
19:07:17 <pecanpy> mapM_ print ?
19:07:23 <Welkin> you can run it as a dual boot or spin up a vm
19:07:33 <merijn> pecanpy: ok, I expect it's dynamic linking on windows issue for ghci then. I recommend asking in #ghc as I *know* there's an issue, but it's probably to esoteric for people here to know the answer
19:07:36 <pecanpy> i do have a ubuntu dual boot
19:07:49 <Welkin> windows is not a good development platform
19:08:21 <benzrf> so dynamic event switching is sort of like a constrained monad instance for the reactive types
19:08:39 <merijn> pecanpy: If you're comfortable with working on linux, I'd recommend that in the short term.
19:11:16 <pecanpy> how do i fix this? the right is IO [Tag String]: main = fmap (mapM_ print) (fmap parseTags h)
19:11:58 <Welkin> mapM_ produces ()
19:12:04 <pecanpy> oh i think i get it. its returning IO (IO ())
19:12:06 <Welkin> if you want a result, use mapM
19:12:14 <ReinH> I'm not sure what you're doung, but you don't need to fmap
19:12:19 <ReinH> you probably want =<< instead
19:12:27 <exio4> look at the types of fmap, I bet you actually want >>= or =<<
19:12:28 <geekosaur> if I understand correctly, somethinglike: fmap parseTags h >>= mapM_ print
19:12:29 <pecanpy> just trying to print the IO [Tag String]
19:12:43 <ReinH> but mapM_ f . fmap g = mapM_ (f . g)
19:12:44 <Welkin> main typically has type IO ()
19:12:53 <Welkin> printing is just a side effect
19:12:56 <ReinH> so maybe you want mapM_ (print . parseTags) h ?
19:13:05 <ReinH>  what is the type of parseTags?
19:13:44 <pecanpy> parseTags :: Text.StringLike.StringLike str => str -> [Tag str]
19:15:26 <pecanpy> ReinH: mapM_ (print . parseTags) h did not work. Couldn't match expected type `[a0]' with actual type `IO String'
19:15:48 <Welkin> look at all the types and fir them together like a puzzle
19:15:51 <Welkin> fit*
19:16:36 <Welkin> use do notation where necessary to make it clear what you want to do
19:16:56 <Welkin> if you have an IO String, you can pull the String out using `<-` inside of a do block
19:17:11 <Welkin> h <- someIOString
19:17:21 <Welkin> then h :: String
19:18:13 <ReinH> peddie: so mapM_ print (parseTags h)
19:18:16 <ReinH> er pecanpy
19:18:37 <ReinH> what is h?
19:21:16 <pecanpy> got it: main = h >>= \x -> mapM_ print x
19:22:03 <pecanpy> and now to answer the original question, yea, i guess it just crashes in ghci because it runs
19:22:57 <merijn> \o/
19:23:22 <pecanpy> thats just h >>= mapM_ print though isnt it? baby steps.
19:23:27 <merijn> Yeah, this is an unfortunate issue with the whole 7.8 "switch to system linker" thing
19:23:30 <merijn> pecanpy: Correct
19:23:50 <merijn> Eta reduction is everyone's friend :>
19:25:27 <pecanpy> merijn: thanks. at least i know i didnt just mess something up, lol
19:25:47 <pecanpy> after only having it installed a few hours
19:27:39 <merijn> pecanpy: The switch to using the linker system solved a bunch of longstanding hard bugs, but caused some other problems. I think it should be possible to get it to work by building libraries "the proper way", but I dunno the details on windows. I would recommend the haskell-cafe or glasgow-haskell-users mailing list, larger audience so bigger chance of someone knowing the exact solution
19:28:04 <pecanpy> yup
19:30:11 <gcganley> has anyone that is very good with haskell been taking the fp101x, if so what do you think of the course?
19:30:44 <gcganley> there are some opinionated things such as using list or results instead of a maybe that i've questioned
19:31:11 <merijn> The Erik Meijer thing?
19:31:12 <ReinH> pecanpy: if you look at mapM_ print x and mapM_ print =<< x, you might see what the difference is
19:31:18 <gcganley> merijn: yes
19:31:44 <merijn> gcganley: Blind guess: The course is probably pretty solid, but in some ways opinionated about style in ways that don't follow haskell style
19:31:54 <merijn> i.e. I disagree with the "lists over maybe" thing
19:33:30 <pecanpy> lists over maybe? can't say i agree either. don't they say there are only 3 quantities in CS? 0, 1, and many. makes sense to have the type reflect its only 0|1
19:34:00 <gcganley> pecanpy: all we're working with is 0 or 1
19:35:38 <gcganley> > let x = [1,2,3]
19:35:40 <lambdabot>  not an expression: ‘let x = [1,2,3]’
19:43:14 <calvinx> what’s the difference between `cabal install` and `cabal install —only-depdencoes` ?
19:43:29 <calvinx> *—only-dependencies
19:43:31 <ReinH> calvinx: if your package has binaries, cabal install will install them
19:43:48 <ReinH> --only-dependencies... only installs dependencies
19:44:08 <ReinH> --only-dependencies prevents the package from being built as well
19:44:16 <calvinx> o, so it’s faster.
19:44:32 <calvinx> it’s faster with the —only-dependencies flag.
19:44:43 <ReinH> Well yes, but only beacuse it does a different thing
19:44:50 <calvinx> since it will grab the binaries if it can find it.
19:45:56 * hackagebot plot-lab 0.0.1.7 - A plotting tool with Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-lab-0.0.1.7 (sumitsahrawat)
19:47:41 <alkabetz> If I’m making a Cabal package, can I put Setup.hs in a different directory from mypackage.cabal?
20:00:31 <pavonia> I made some progress with installing the curl package. When I use that package from GHCi it work fine, i.e. loads the .dll file and runs the code. However, if I want to build an executable, I get loads of undefined references: http://lpaste.net/116136
20:00:46 <pavonia> Any ideas what could be the problem here?
20:03:27 <merijn> pavonia: Looks like it needs to be linked with openssl which you are (presumably) not doing?
20:04:05 <pavonia> Is there a way to exclude that from linking? Because I'm not using it
20:05:57 * hackagebot plot-lab 0.0.1.8 - A plotting tool with Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-lab-0.0.1.8 (sumitsahrawat)
20:06:12 <pavonia> I thought all this would already be included in libcurl.a
20:06:21 <Axman6> pavonia: any particular reason you need to use the curl library? there are pure / mostly haskell alternatives which will cause you less hassles, and probably have easier interfaces
20:06:52 <pavonia> Oh, which are these? I've already looked for alternatives
20:07:11 <Axman6> pavonia: what features do you need?
20:07:48 <pavonia> Basically http GET, HEAD and POST requests
20:08:20 <Axman6> and the HTTP library isn't good enough for that?>
20:08:25 <peddie> @hackage wreq
20:08:25 <lambdabot> http://hackage.haskell.org/package/wreq
20:09:08 <peddie> pavonia: see ^ and http://www.serpentine.com/wreq/tutorial.html
20:09:24 <Axman6> bos strikes again
20:10:26 <pavonia> I even have HTTP installed, why didn't I see that package O.O
20:11:20 <Axman6> HTTP might be a bit of a pain for some things, I can't remember how easy it would be to do HEAD requests, but GET and POST are pretty standard things any http package will give you
20:20:33 <pavonia> Holy cow, not enough space for cabal update ... I feel like in the late 90s on my machine >_>
20:21:32 <pavonia> Axman6: I have to update HTTP and check if it work, but it looks fine for now. Thanks for the hint!
20:22:14 <Axman6> you probably don't want to do that...
20:23:17 <Axman6> why do you feel you need to update HTTP? it's one of those packages that likes to break lots of other packages when it gets updated (though, really, updating anything in cabal is imo usually a bad idea, use sandboxes)
20:23:36 <bitemyapp> Has anyoen gotten the error: unrecognized option `--enable-library-stripping'  when building a package with a custom Setup file?
20:23:39 <bitemyapp> anyone*
20:24:33 <pavonia> Axman6: Because my version is outdated and doesn't provide headRequest
20:25:48 <Axman6> have a look to see if there's a function which lets you specify which verb to use; headRequest is probably jujst a convenience method (in face looking at the definition of headRequest might show you exactly which code you need)
20:25:57 * hackagebot hzulip 1.1.1.1 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.1.1 (yamadapc)
20:30:45 <roboguy_> hmm, why is it that in GHCi, if I have "let xs = "abcde"", :sprint tells me xs is an unevaluated thunk, but if I have "let xs = 'a' : 'b' : 'c' : 'd' : 'e' : 'f' : []", :sprint says it is fully evaluated?
20:32:45 <roboguy_> Also, if I do "let xs = [1, 2, 3] :: [Int]" and "let xs = 1 : 2 : 3 : []", :sprint says *both* of those are fully evaluated...
20:33:27 <roboguy_> (I have [Int] annotations on both)
20:33:53 <benzrf> roboguy_: who knows O_O
20:34:05 <benzrf> roboguy_: do you have overloadedstrings
20:34:15 <roboguy_> oh, that's a good point, let's see...
20:34:43 <roboguy_> nope
20:34:57 <roboguy_> I'm on GHCi 7.8.3
20:36:45 <benzrf> hmm
20:36:47 <benzrf> i get same thing
20:37:23 <Denommus> roboguy_, I would bet String has different optimizations from other types of list, which may include [Char], but I'm very likely wrong
20:38:27 <Denommus> roboguy_, have you tried annotating the first case with String and then [Char]?
20:39:29 <roboguy_> that shouldn't really affect anything since String is a type synonym for [Char], so they should be totally interchangable
20:39:29 <shachaf> The type String is the same type as [Char]. No difference.
20:39:46 <shachaf> But string literals are implemented differently from list literals of characters.
20:40:04 <Denommus> well, so I have no idea what's going on
20:40:14 <roboguy_> shachaf: would that cause those :sprint differences?
20:40:17 <Denommus> shachaf, oh
20:40:35 <glguy`> I bet that the string literal is still implemented as from string actualLiteral
20:40:45 <glguy`> Even with the extension off
20:41:00 <shachaf> glguy`: No, it's unpackCString# ...
20:41:08 <shachaf> Where the string is represented in memory as a C string.
20:41:10 <shachaf> Look at the Core for clues.
20:41:35 <glguy`> I,i My phone doesn't have GHC yet
20:41:45 <shachaf> I,i,ı
20:41:48 <Axman6> yeah I was going to say it's stored as a C string, but then wasn't sure if that was true in GHCi
20:42:03 <shachaf> The next question is how string literals that contain \0s are stored.
20:42:16 <shachaf> (Exercise for the reader.)
20:42:42 <glguy`> The capital I was part of the phone joke. I'd guess, again, as a 2 byte denormalized utf8 encoding
20:43:06 <shachaf> Yep.
20:43:24 <glguy`> This is fun; give me another!
20:43:36 <roboguy_> I can't seem to get :sprint to say that an [Int] list is evaluated...
20:43:41 <pavonia> Axman6: Installing HTTP worked without problems. Do you know how to actually get the response body? This is what I tried and the result: http://lpaste.net/116137
20:44:09 <Axman6> sorry, can't help, time for me to head home
20:44:21 <Denommus> this irc client sucks -.-
20:44:22 <roboguy_> I've tried just asking ghci for the value of xs itself first, xs !! 1, sum xs...
20:44:25 <Axman6> but I'm sure others here can help
20:44:29 <pavonia> Okay, thanks again for your help, though!
20:44:36 <roboguy_> and :sprint still says it xs = _
20:45:09 <roboguy_> oh, I forgot the :: [Int] annotation
20:45:58 * hackagebot plot-gtk3 0.1 - GTK3 plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk3-0.1 (VivianMcPhail)
20:48:50 <pavonia> Never mind, with a HEAD request there is no header, of course ...
20:49:00 <pavonia> s/header/body/
21:00:58 * hackagebot doctest-discover 0.1.0.5 - Easy way to run doctests via cabal  http://hackage.haskell.org/package/doctest-discover-0.1.0.5 (karun012)
21:02:52 <roboguy_> there's no way to convince :sprint to use the Show instance to show something, is there?
21:04:08 <srhb> I don't think so.
21:06:44 <roboguy_> there's probably a chance that could mess something up by evaluating some part of it too much. That's a shame though
21:32:01 <pecanpy> would someone like to judge me on my haskell? http://lpaste.net/116139
21:33:03 <glguy_> You'll get instant bonus points for using do-notation and naming your intermediate values instead of all the a,b,c,d,e point-free tuff
21:33:05 <glguy_> stuff*
21:33:18 <jfischoff> yeah
21:33:24 <shachaf> ==glguy_
21:33:33 <jfischoff> names would help there
21:34:13 <jfischoff> also no reason to do this: b = getResponseBody
21:35:34 <pecanpy> yea, it started off as a single line and when it got a little long i figured id keep it uniform a-e
21:36:19 <pecanpy> is (head . tail) better than (!! 1)?
21:36:34 <jfischoff> no
21:36:37 <shachaf> By what measure?
21:36:54 <jfischoff> bikeshed
21:36:56 <jfischoff> meh
21:37:18 <shachaf> It'll probably generate better code, but at the point that you care that much maybe you shouldn't be using lists in the first place.
21:37:28 <pecanpy> i only ask because in eclipsefp it told me to change (xs !! 0) to head. which i guess makes sense
21:37:33 <lpaste> glguy annotated “Terminal Dictionary” with “Terminal Dictionary (annotation)” at http://lpaste.net/116139#a116141
21:37:35 <jfischoff> yeah both are bad
21:37:37 <jfischoff> partial
21:37:55 <glguy_> pecanpy: There's a start (I didn't try type-checking it, I don't have the libraries installed)
21:38:09 <jfischoff> much better
21:38:23 <shachaf> glguy_: Aw, I saw the title and I thought it would be something more exciting.
21:39:17 <pecanpy> i like it. thanks man
22:08:41 <Geekingfrog> I get the error "catch: not in scope" even with "import System.IO.Error" (or without since it looks like it's also in the Prelude). Any idea?
22:13:26 <danclien> `import Control.Exception`?
22:16:20 <Geekingfrog> works! which leads me to: why does hoogle report "catch" in System.IO.Error?
22:16:54 <danclien> Not sure. I clicked on the package names in Hackage and couldn't find `catch` as a listed function though.
22:17:00 <glguy_> It's probably indexing older versions of the libraries
22:17:05 <danclien> Maybe it was removed from Prelude/System.IO.Error at some point?
22:17:39 <Geekingfrog> It seems so, but hoogle doesn't reflect the change apparently
22:17:53 <Geekingfrog> anyway, thanks for the help
22:18:19 <danclien> Sure thing. :) Glad I could help.
22:26:04 <jasonkuhrt> Hi, is modern haskell focused on using generators, iterators+iteratees, and streams, rather than laziness?
22:26:11 <jasonkuhrt> I was skimming this http://okmij.org/ftp/continuations/PPYield/index.html
22:33:15 <ReinH> They are certainly a part of modern haskell, but I wouldn't say modern haskell is focused on these things exclusively
22:33:34 <ReinH> And also these things are not at odds with laziness at all
22:33:57 <ReinH> Modern haskell is definitely still focused on laziness
22:45:17 <pharaun> but what about post-modern haskell? :)
22:51:35 <zzing> Are strict versions of foldl and foldr useful as distinct operations? If so, in what kinds of scenarios?
22:51:56 <Welkin> distinct operations?
22:51:59 <Welkin> what does that mean?
22:52:12 <jle`> zzing: the strict version of foldl is practically always preferred over the lazy version
22:52:23 <Welkin> you should always use a strict left fold (foldl') over a lazy left fold (foldl)
22:52:50 <Welkin> there really isn't a benefit to the lazy left foldl in most cases
22:53:37 <zzing> Reason why I ask is, I notice many languages take the fold and have one version. For example Javascript just has reduce - no left or right.  I notice the evaluation trees of right and left folds are different, and I am usually operating in strict languages, hence my question.
22:53:49 <jle`> hm
22:53:58 <Welkin> it depends on what you want to do
22:54:00 <jle`> yeah i guess there aren't any real reasons for both foldl's to exist
22:54:04 <Welkin> the right fold is the most natural
22:54:27 <Welkin> but it will not work on infinite structures
22:54:32 <jle`> people only ever use the strict foldl and the lazy foldr
22:54:39 <zzing> ok
22:54:52 <jle`> i think having a lazy foldl just might be for consistency
22:55:00 <jle`> or something historical idk.
22:55:02 <zzing> So basically there is no reason to have both a strict foldl and foldr?
22:55:09 <schell> wait - i’m supposed to be using foldl’ and not foldl?
22:55:13 <jle`> there's no real erason to have both a strict and non-strict foldl
22:55:22 <schell> shoot, first i’ve heard of this, haha
22:55:24 <jle`> for all intents and purposes you should always be using the strict foldl
22:55:50 <jle`> foldr makes more sense lazy
22:56:07 <jle`> so really people only use one foldl (the strict one), and one foldr (the lazy one)
22:56:31 <Welkin> > foldr f [] [1..3] :: [Expr]
22:56:32 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
22:56:33 <lambdabot>                     [Debug.SimpleReflect.Expr.Expr])
22:56:33 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
22:56:47 <zzing> Now if you were talking about converting a list to a string, and you wanted a string prepended, foldl could do that, and if you wanted it appended, foldr could do that if I produced the trees rigth
22:56:47 <Welkin> hm, how do you work with that kind of expression on lambdabot?
22:56:55 <Welkin> I haven't done it in a while
22:57:24 <jle`> what are you expecting to show up, Welkin?
22:57:48 <schell> zzing: you could prefix or suffix with either fold
22:57:57 <Welkin> > foldr (\x acc -> f x : acc) [] [1..3] :: [Expr]
22:57:59 <lambdabot>  [f 1,f 2,f 3]
22:58:02 <Welkin> there we go
22:58:09 <Welkin> hm
22:58:19 <schell> depending on the function you pass to the fold
22:58:23 <Welkin> how do you show the symbolic evaluation of a fold?
22:58:31 <Welkin> I remember there is a way to do this
22:58:34 <glguy_> > foldr f n [1..3]
22:58:35 <lambdabot>  f 1 (f 2 (f 3 n))
22:58:53 <Welkin> ah
22:58:59 <Welkin> I made it too complicated
22:59:12 <Welkin> I am used to seeing "f is not defined"
22:59:37 <zzing> >  foldr (\x acc -> (show x) ++ acc) "end" [1 2 3]
22:59:38 <lambdabot>  No instance for (GHC.Show.Show a0)
22:59:38 <lambdabot>    arising from a use of ‘GHC.Show.show’
22:59:38 <lambdabot>  The type variable ‘a0’ is ambiguous
23:00:08 <Welkin> zzing: why would you append the accumulator to the end?
23:00:14 <Welkin> that is slow
23:00:23 <Welkin> use Cons instead
23:00:38 <Welkin> x : acc
23:00:43 <Welkin> it does the same thing
23:00:44 <jle`> it's show
23:00:48 <jle`> so he has to (++) no matter what
23:00:50 <glguy_> No, show returns a String
23:00:58 <glguy_> and the acc was on the right side of the ++, so not so bad
23:01:04 * hackagebot invariant 0.1.1 - Haskell 98 invariant functors  http://hackage.haskell.org/package/invariant-0.1.1 (NicolasFrisby)
23:01:09 <zzing> I am rusty.
23:01:33 <zzing> Why cannot it figure out a0?
23:01:37 <glguy_> zzing: but you left out the commas in the list syntax
23:01:53 <zzing> >  foldr (\x acc -> (show x) ++ acc) "end" [1, 2, 3]
23:01:54 <lambdabot>  "123end"
23:01:57 <jle`> woo hoo
23:01:59 <zzing> there we go
23:02:19 <jle`> > foldr (++) "end" (map show [1,2,3])
23:02:20 <lambdabot>  "123end"
23:02:26 <zzing> >  foldl (\acc x -> acc ++ (show x)) "start " [1, 2, 3]
23:02:27 <lambdabot>  "start 123"
23:02:41 <schell> zzing: :)
23:03:20 <schell> but now one is “more natural” for either prefixing or suffixing
23:03:36 <zzing> How would you do a prefix version with foldr?
23:03:59 <Welkin> use Cons (:)
23:04:11 <jle`> zzing: thew same way you did it, just flip it :)
23:04:12 <Welkin> > foldr (:) [] [1..7]
23:04:13 <lambdabot>  [1,2,3,4,5,6,7]
23:04:21 <jle`> Welkin: cannot use cons, they are strings
23:04:25 <Welkin> ah
23:04:27 <zzing> >  foldr (\x acc -> acc ++ (show x)) "end" [1, 2, 3]
23:04:28 <lambdabot>  "end321"
23:04:29 <schell> there’s also…i forget the term…identity functions? with foldr? ^ yeah that’s it
23:04:34 <zzing> but it reverses the numbers
23:04:42 <schell> foldr (:) []
23:05:01 <glguy_> :t let myfoldl' f z = foldr (\x next acc -> next $! f acc x) id in myfoldl'
23:05:02 <lambdabot> (b -> a -> b) -> t -> [a] -> b -> b
23:05:27 <schell> :t ($!)
23:05:28 <lambdabot> (a -> b) -> a -> b
23:05:37 <schell> :t ($)
23:05:38 <lambdabot> (a -> b) -> a -> b
23:05:49 <Welkin> > foldr (flip ++) "end" [1..3]
23:05:50 <lambdabot>  Couldn't match expected type ‘[a0]’
23:05:50 <lambdabot>              with actual type ‘(a1 -> b0 -> c0) -> b0 -> a1 -> c0’Couldn't ma...
23:05:50 <lambdabot>                with ‘[GHC.Types.Char] -> [GHC.Types.Char]’
23:06:02 <Welkin> > foldr (flip ++ . show) "end" [1..3]
23:06:04 <lambdabot>  <hint>:1:16: parse error on input ‘.’
23:06:04 * hackagebot snaplet-recaptcha 1.0.1 - A ReCAPTCHA verification snaplet with Heist integration and connection sharing.  http://hackage.haskell.org/package/snaplet-recaptcha-1.0.1 (MikeLedger)
23:07:00 <zzing> I might have to get back into haskell over the holidays
23:07:16 <glguy_> You can write foldl in terms of foldr, so anything you can write with foldl you can write with foldr
23:07:20 <glguy_> (is why I pasted that)
23:08:31 <glguy_> oops
23:08:32 <glguy_> :t let myfoldl' f = foldr (\x next acc -> next $! f acc x) id in myfoldl'
23:08:32 <lambdabot> (b -> a -> b) -> [a] -> b -> b
23:09:20 <zzing> Haskell is deep
23:10:01 <brianpWins> I need two more examples of a monadic values then I can evaluate in sequence
23:10:20 <glguy_> Which example do you have so far?
23:10:38 <brianpWins> glguy: none. I lost my last one.
23:10:45 <jfischoff> heh
23:11:44 <jfischoff> should the output of the first get feed to the second?
23:13:33 <brianpWins> nope. I think i just put the monadic values in a list and run them in sequence “from left to right, collecting all (intermediate) results into a list?”
23:13:40 <brianpWins> defined as a question appearently
23:14:24 <dibblego> Monad f => [f a] -> f [a]
23:14:51 <brianpWins> I’ll pass them to a method i need to implement that looks like: sequence' :: Monad m => [m a] -> m [a]
23:15:16 <brianpWins> function*
23:19:18 <jfischoff> brianpWins: what happens if you get the empty list?
23:19:59 <brianpWins> “that takes a finite, non-partial, list of non-bottom, monadic values” empty list should be handled like an empty list and return no values i think
23:20:19 <jfischoff> how would you write that case?
23:20:44 <brianpWins> https://courses.edx.org/c4x/DelftX/FP101x/asset/chapter9_34.png
23:21:09 <brianpWins> potentially. I have to choose possible solutions this being one of the options
23:21:36 <brianpWins> but I need values to try it with and tbh I don’t fully know what a “Monadic value” is so don’t know how to define one myself
23:22:08 <dibblego> that solution uses explicit >>= and do-notation, which is weird  usually one or the other
23:22:30 <jfischoff> yeah
23:22:52 <brianpWins> I’m given 8 possible solutions and have to try and select the ones that work
23:22:56 <jfischoff> brianpWins: do you know the methods of the Monad typeclass?
23:22:59 <brianpWins> so that solution could be bad
23:23:28 <brianpWins> i do not
23:25:32 <Welkin> jfischoff> brianpWins: do you know the methods of the Monad typeclass? <-- this sounds like a line from a dramatic film
23:25:42 <Welkin> "let me show you the way of the Monad"
23:25:48 * jfischoff wonders what the soundtrack would be like
23:25:52 <jfischoff> ah
23:25:54 <jfischoff> :)
23:26:18 <brianpWins> lol. I understand some stuffs about the Monads and what they are and what some of the patterns are but I have no idea what they mean by Monadic Value
23:26:29 <brianpWins> and thus have no idea what is supposed to populate this list
23:26:31 <kvanb> that trumpet music where there's people running around crazy doing stupid stuff\
23:26:37 <Welkin> brianpWins: to understand the Monad, you must first become the Monad
23:26:47 <jfischoff> they mean: Monad m => m a
23:27:00 <jfischoff> you need to make something like that
23:27:12 <brianpWins> So that’s just a signature to me. I don’t know how to make that.
23:27:28 <jfischoff> you must look at the definition of Monad. You will find your answer there ;)
23:27:47 * jfischoff likes having an audience
23:28:33 <Welkin> instance Monad PathToEnlightenment of ...
23:28:35 <Welkin> er
23:28:42 <Welkin> instance Monad PathToEnlightenment where
23:30:52 <jfischoff> brianpWins: ignore fail and >>
23:31:04 <jfischoff> when  you look at the definition
23:32:16 <brianpWins> I still don’t get it
23:32:35 <brianpWins> by Monadic Value do they just mean a Monad?
23:32:42 <Welkin> brianpWins: https://www.haskell.org/haskellwiki/Monad
23:32:48 <brianpWins> becuase they could have just said that if that’s the case
23:33:15 <jfischoff> Monad is a typeclass
23:33:59 <jfischoff> There are specific types that implement the typeclass
23:34:29 <jfischoff> are you familiar with IO?
23:34:56 <brianpWins> yup
23:37:19 <Welkin> has anyone ever used this?
23:37:19 <Welkin> http://hackage.haskell.org/package/QIO
23:37:35 <Welkin> how would that even work on a non-quantum computer?
23:38:15 <calvinx> do haskell developers usually place their `.cabal-sandbox` in their project root directory? Or do they place it in a separate directory (like how python’s virtualenv does it) ? What’s the typically convention?
23:38:17 <pavonia> Very, very slowly
23:38:31 <calvinx> *typical convention
23:38:39 <jfischoff> brianpWins: is IO a monad?
23:39:05 <brianpWins> i’m not sure
23:39:25 <jfischoff> to be a monad you need to be able to implement two functions
23:39:31 <dibblego> type this at ghci, :info IO
23:39:46 <jfischoff> spoiler ;)
23:40:23 <Welkin> @info IO
23:40:23 <lambdabot> IO
23:40:39 <Welkin> lambdabot sure has al ot to say
23:40:39 <jfischoff> brianpWins: you should do what dibblego says
23:40:55 <jfischoff> it will list the instances
23:40:56 <Welkin> why does @info even exist on lambdabot?
23:41:00 <Welkin> it's always useless
23:41:07 <jfischoff> you can see if Monad shows up there
23:41:13 <dibblego> it doesn'
23:41:15 <Welkin> @info []
23:41:16 <lambdabot> []
23:41:35 <dibblego> lambdabot corrects your misspeliing of @undo
23:41:45 <Welkin> undo?
23:41:48 <Welkin> @undo []
23:41:48 <lambdabot> []
23:42:02 <Welkin> :info IO
23:42:03 <dibblego> info => undo has a levenshtein distance of 2
23:42:09 <Welkin> ?
23:42:22 <Welkin> so where is the info command?
23:42:38 <dibblego> ghci
23:42:45 <Welkin> I know
23:42:48 <jfischoff> @undo do { x <- m; f x; }
23:42:48 <dibblego> ok
23:42:48 <lambdabot> m >>= \ x -> f x
23:42:52 <Welkin> I meant in lambdabot
23:42:55 <jfischoff> huh
23:43:00 <dibblego> again, it's not there
23:43:19 <jfischoff> @info do { x <- m; f x; }
23:43:20 <lambdabot> m >>= \ x -> f x
23:43:36 <jfischoff> neat
23:43:54 <Welkin> it's the same case with @pf and @pl I presume
23:44:18 <Welkin> but everyone prefers @pl
23:45:21 <pavonia> @andy do Nothing
23:45:21 <lambdabot> Nothing
23:47:10 <Welkin> @pf concat $ tails
23:47:10 <lambdabot> Maybe you meant: pl bf
23:47:15 <Welkin> @pl concat $ tails
23:47:15 <lambdabot> join tails
23:47:22 <Welkin> eh?
23:47:37 <Welkin> I thought the original command was @pf (point-free)
23:47:44 <Welkin> what is bf?
23:47:47 <Welkin> @bf
23:47:47 <lambdabot>  Done.
23:47:55 <Welkin> @bf show
23:47:55 <lambdabot>  Done.
23:48:10 <pavonia> brainf*** I guess
23:48:22 <Welkin> @bf +++++
23:48:23 <lambdabot>  Done.
23:48:27 <Welkin> @help
23:48:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:48:30 <Welkin> @help bf
23:48:30 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
23:48:35 <Welkin> @help pl
23:48:36 <lambdabot> pointless <expr>. Play with pointfree code.
23:48:41 <Welkin> @help pf
23:48:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:48:52 <Welkin> @help list
23:48:52 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
23:49:27 <kqr> is there a flipped fold somewhere, that takes the function last?
23:49:38 <Welkin> :t flip
23:49:39 <lambdabot> (a -> b -> c) -> b -> a -> c
23:49:43 <Welkin> hm
23:49:45 <opqdonut> kqr: there's at least forM
23:49:47 <opqdonut> :t forM
23:49:48 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
23:50:04 <kqr> yeah, I'm aware of forM
23:50:21 <Welkin> kqr: you can always wrap a fold in your own function
23:50:32 <kqr> Welkin, yeah, I think I'll do that locally
23:50:34 <Welkin> to pass in the arguments in whatever order you wish
23:50:38 <kqr> because I can't find anything else
23:50:40 <kqr> thanks :)
