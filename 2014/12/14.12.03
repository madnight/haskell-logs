00:00:12 <Procian> Dia1337: You can bind to any C library, so yes, the question is whether there's any cool Haskelly way of doing CUDA. There's been a fair bit of research in that area.
00:00:35 <dmj`> pavonia: do you have curl installed?
00:01:03 <Hijiri> http://hackage.haskell.org/package/accelerate
00:01:13 <pavonia> dmj`: You mean the executable?
00:01:38 <Hijiri> never used this, but there is a back-end for this that can use the GPU
00:01:48 <Hijiri> (CUDA specifically)
00:02:04 <dmj`> yes, or the library.. libCurl I think
00:03:08 <dmj`> pavonia: you'll have best luck using Haskell on windows with Cygwin or MingGW
00:04:15 <pavonia> dmj`: I'm using MinGW. I downloaded the devel package for curl and added the include and libs paths to cabal configure
00:04:44 <pavonia> And it seemed to build fine but only the registration is failing
00:06:39 <torpet> How can I take two lists, one being shorter than the other
00:06:53 <torpet> and fill the longer list with the same values, but fill the "empty" fields with a placeholder value
00:07:12 <torpet> basicallyi want to stretch a list and fill the new fields with a fixed value
00:07:32 <tdammers> torpet: append an infinite list, then cut to size
00:08:55 <torpet> by cut you mean take?
00:09:37 * hackagebot statsd 0.1.0.1 - StatsD API.  http://hackage.haskell.org/package/statsd-0.1.0.1 (mitchellwrosen)
00:09:37 * hackagebot crypto-pubkey 0.2.5 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.5 (VincentHanquez)
00:10:11 <Procian> torpet: You could use a monoid instance.
00:11:45 <Procian> tdammers: You'd have to know in advance which of the two lists is shorter.
00:15:23 <tdammers> Procian: ah, yeah. Hmm.
00:16:14 <Procian> I've found myself defining this before: http://lpaste.net/115558
00:17:47 <Procian> It makes some sense in that you can imagine both lists being filled out so that they are the same length, but with "mzero" as the default value, and then they are zipped with mplus.
00:19:50 <Dia1337> My task is to create a pipeline for digital holography (huge number of calculations, imaginary number, working with images, ...).  ATM I use cycles (renderengine of blender) as a standalone to render this out, from the nodes I get from my artists in the team, but I really want speed, which is not something I am getting atm... You think CUDA-Haskell is better for speed than C++/C sharp with CUDA?
00:20:49 <Iceland_jack> Dia1337: You'll probably find the infrastructure and documentation better for C++/C
00:22:34 <Dia1337> people recommended haksell but I think it's yet underdevelopped?
00:23:01 <Iceland_jack> You can't say ‘people recommend Haskell’ without talking about to what end
00:23:51 <dmj`> Dia1337: if interested, here's some good documentation on haskell w/ gpu, http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
00:23:57 <Iceland_jack> Haskell is a great language for a lot of things, if you're interested in programming languages Haskell is perfect but for GPGPU programming it's not the best language there is.
00:26:18 <pavonia> dmj`: When it says "use --force to override", what will it actually do if I use --force?
00:26:45 <wei2912> pavonia: it'll override the force
00:26:51 <Iceland_jack> Dia1337: Haskell is very good at programming in parallel on a SMP (which dmj`'s book covers) and concurrency with multithreading however
00:26:54 <dmj`> pavonia: overwrite the entry in the package db
00:27:48 <pavonia> dmj`: So I could use --force and just copy the files by hand? Is that safe?
00:28:15 <dmj`> if you have to do it by hand, then you're probably doing it wrong. Is it a package conflict?
00:28:47 <Dia1337> dmj` thnx for this. i will try this out at some point...
00:28:58 <dmj`> Dia1337: cool
00:29:10 <pavonia> dmj`: No, it's still the curl library problem here http://lpaste.net/115551
00:29:15 <Dia1337> you are Simon Marlow?
00:29:41 <Iceland_jack> Sorry, the book dmj` linked
00:30:19 <Iceland_jack> It covers SMP/GPU parallelism as well as concurrency
00:30:29 <dmj`> I am not, no :P
00:31:14 * dmj` wakes up from dream
00:32:03 <Dia1337> 2 hands on the keyboard dmj` !
00:33:41 <dmj`> :P
00:36:20 <torpet> tdammers: I am trying to cut a lsit
00:36:31 <torpet> but the list does not consist of Integers, but of a custom rational number datatype
00:36:40 <torpet> meaning I cannot just do [1,1..]
00:36:43 <torpet> which is what I would need
00:36:47 <tdammers> :t repeat
00:36:48 <lambdabot> a -> [a]
00:37:01 <tdammers> repeat (1, "foobar")
00:37:09 <tdammers> > repeat (1, "foobar")
00:37:10 <lambdabot>  [(1,"foobar"),(1,"foobar"),(1,"foobar"),(1,"foobar"),(1,"foobar"),(1,"foobar...
00:37:21 <tdammers> you can use that function on anything you want
00:37:46 <tdammers> take 10 $ ["foo", "bar"] ++ repeat "baz"
00:37:51 <tdammers> > take 10 $ ["foo", "bar"] ++ repeat "baz"
00:37:52 <Hafydd> Also, if you define Num and Enum instances for your type, you can use [1,1..].
00:37:53 <lambdabot>  ["foo","bar","baz","baz","baz","baz","baz","baz","baz","baz"]
00:38:14 <tdammers> Hafydd: but if cutting by list length is all you need, there is no point in that, is there
00:39:36 <tdammers> another option is to just go with explicit recursion after all
00:39:46 <Hafydd> It seems like a rational number data type should at least have Num, anyway.
00:39:57 <tdammers> ah, yes, that's true
00:40:06 <tdammers> (on a side note, why not Data.Ratio?)
00:40:57 <Hafydd> But I suppose implementing Enum just for that syntactic sugar might be questionable.
00:44:32 * hackagebot Zora 1.1.19 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.19 (bgwines)
00:46:54 <Dia1337> know any good server/channel for ebooks?
01:00:41 <jle`> Hafydd: isn't that the point of the Double Enum instances? :P
01:04:07 <Darwin226> gfixler: Hey. Did you help me yesterday with my type equality through functional dependencies?
01:05:19 <Iceland_jack> Darwin226: It was glguy and me
01:05:22 <Iceland_jack> Maybe someone else
01:05:48 <Darwin226> Iceland_jack: Oh. Awkward... Anyways, it turned out to be possible after all
01:06:12 <Iceland_jack> How did you manage?
01:08:03 <Darwin226> Iceland_jack: I've stumbled on the solution by accident. It turns out that Equal x x True; Equal x y False doesn't work because I'm breaking the fun dep, BUT Equal x x True; Equal x y z does work. Now all I needed to do is use my Not type-level function to write this https://gist.github.com/f531edce0048a53a790e
01:08:42 <simon> if I have 'foo f a b = f a && f b' and I want this to work for "foo (const True) 5 'a'", I should use an existential type, right?
01:09:03 <Iceland_jack> simon: You should use rank-2 types
01:09:15 <Darwin226> Iceland_jack: I'm not sure why that works, but this somehow convinces it to try harder
01:10:59 <Iceland_jack> simon:
01:10:59 <Iceland_jack> > ((\f a b -> f a && f b) ∷ (∀t. t -> Bool) -> a -> b -> Bool) (const True) 5 'a'
01:11:00 <jkarni1> Darwin226: I'm missing some context, but if I understand what you're trying to do, take a look at Oleg's TypeEq
01:11:01 <lambdabot>  True
01:11:08 <jkarni1> http://okmij.org/ftp/Haskell/typeEQ.html
01:11:29 <Iceland_jack>     foo :: (forall t. t -> Bool) -> a -> b -> Bool
01:11:29 <Iceland_jack>     foo f a b = f a && f b
01:12:20 <Iceland_jack> That's not a very useful function since by parametricity it must ignore its second and third argument completely
01:12:27 <Iceland_jack> which 'const ...' does
01:12:34 <Iceland_jack> But there you go :-)
01:13:28 <simon> Iceland_jack, sure. this is a bastardization of another example I was thinking of in which you can pass an identity function as an argument without concretizing its type parameter... that must be bar :: (forall t. t -> t) -> ...
01:14:14 <Iceland_jack> Yes, but in those examples the input types usually appear in the result type:
01:14:14 <Iceland_jack>     :: (forall t. t -> t) -> (a, b) -> (a, b)
01:14:39 <Iceland_jack> Not terribly motivating
01:17:25 <Darwin226> jkarni1: This is actually exactly what I did. Except he used b ~ HFalse instead of Not True b
01:17:44 <Darwin226> jkarni1: I wish I knew about this yesterday :D
01:20:06 <jkarni1> Darwin226: yeah, the trick of putting an ~ constraint when faced with overlapping instances + fundeps is a nifty one that I've seen in Oleg's things a couple of times
01:29:33 * hackagebot chunky 0.1.0.0 - Human-readable storage of text/binary objects.  http://hackage.haskell.org/package/chunky-0.1.0.0 (PhilippHausmann)
01:32:39 <sgillis> preflex: list
01:32:43 <sgillis> ??
01:34:01 <shachaf> preflex hasn't been around for almost a year.
01:35:39 <sgillis> Ah, is there another bot now? Cause it's still listed on the documentation
01:35:54 <jle`> there will never be another ;_;
01:36:01 <jle`> not like preflex
01:36:04 * jle` cries silently
01:36:18 <shachaf> No.
01:44:34 * hackagebot gloss-juicy 0.2 - Load any image supported by Juicy.Pixels in your gloss application  http://hackage.haskell.org/package/gloss-juicy-0.2 (AlpMestanogullari)
01:53:01 <cluid> Hi
01:53:07 <Iceland_jack> Hey cluid
01:53:12 <cluid> :)
01:53:24 <cluid> could anyone recommend a library to write a parser with good error messages? and a tutorial on how to use it?
01:57:06 <ThreeOfEight> cluid: that sounds like you might want to write a parser monad with an ErrorT monad transformer or add a MonadError instance for your parser monad
01:57:53 <Iceland_jack> ThreeOfEight: That's a lot of mentions of the word 'monad' :)
01:57:53 <Iceland_jack> cluid: Check out "Parsec"
01:58:02 <cluid> okay, thank you
01:58:26 <ThreeOfEight> Yes, doing it the way Parsec does it is probably a good idea.
01:59:24 <Iceland_jack> cluid: I'm not sure what the best resource for Parsec is, there is "Write a Scheme in 48 Hours" that's a bit outdated by there are quite a few tutorials if you search for them
01:59:39 <Iceland_jack> Parsec provides a confortable way to report error messages
01:59:40 <ThreeOfEight> cluid: if you're trying to learn, it might be a good idea to start with something like newtype Parser a b = Parser ([a] -> [(b, [a])])
01:59:52 <ThreeOfEight> and then add the error handling once you're familiarised yourself with it
02:01:35 <Iceland_jack> cluid: An example from Real World Haskell:
02:01:36 <Iceland_jack> eol =   try (string "\n\r")
02:01:36 <Iceland_jack>     <|> try (string "\r\n")
02:01:39 <Iceland_jack>     <|> string "\n"
02:01:43 <Iceland_jack>     <|> string "\r"
02:01:46 <Iceland_jack>     <?> "end of line"
02:01:50 <Iceland_jack> The last string following (<?>) indicates an error message
02:01:58 <cluid> alright!
02:02:05 <cluid> i'll try this out
02:02:06 <Iceland_jack> If all the previous parsing attempts failed, is that what you're looking for?
02:02:14 <cluid> yeah, this looks perfect
02:03:31 <slomo> is there a way to "resize" (like with realloc) a pointer returned by mallocForeignPtrBytes? i want to make it smaller
02:04:01 <Iceland_jack> There is:
02:04:02 <Iceland_jack> @hoogle realloc
02:04:02 <lambdabot> Foreign.Marshal.Alloc realloc :: Storable b => Ptr a -> IO (Ptr b)
02:04:02 <lambdabot> Foreign.Marshal.Array reallocArray :: Storable a => Ptr a -> Int -> IO (Ptr a)
02:04:02 <lambdabot> Foreign.Marshal.Array reallocArray0 :: Storable a => Ptr a -> Int -> IO (Ptr a)
02:06:18 <slomo> Iceland_jack: but that must not be used together with mallocForeignPtrBytes according to the docs, and using Foreign.Marshal.Alloc.mallocBytes gives you normal malloc'd memory and not memory inside the GC heap
02:06:54 <Iceland_jack> Then I'm unsure, someone else probably knows
02:08:35 <slomo> Iceland_jack: i guess i should just look at what ByteString does internally :) thanks anyway
02:11:54 <ThreeOfEight> TIL about Data.Real.Constructible.
02:11:58 <ThreeOfEight> It made me happy.
02:12:10 <ThreeOfEight> Does anybody know if there is something similar, but for general algebraic real numbers?
02:12:18 <ThreeOfEight> constructible is still quite restricted.
02:18:37 <ClaudiusMaximus> ThreeOfEight: i looked around a bit, found an implementation in Coq but nothing Haskell so far http://perso.crans.org/cohen/papers/realalg.pdf
02:19:36 <ThreeOfEight> ClaudiusMaximus: ah, thanks.
02:19:49 <ThreeOfEight> Some people in Cambridge are working on an Isabelle implementationa tm
02:19:51 <ThreeOfEight> *atm
02:19:58 <ThreeOfEight> maybe I should hack something for Haskell
02:21:23 <ClaudiusMaximus> i didn't realize algebraic numbers had decidable equality until reading that
02:24:53 <ThreeOfEight> well the basic idea is that every real algebraic number is a root of some polynomial
02:25:19 <ClaudiusMaximus> yep, and you provide an interval that has the unique root you want inside
02:25:34 <ThreeOfEight> and you can uniquely identify a real algebraic number with a polynomial of which it is a root and an interval that uniquely identifies it
02:26:02 <ThreeOfEight> and things like addition, multiplication etc. can be done with resultant constructions and shrinking the intervals until they are unique again
02:37:51 <pharaun> good god, that was a pain in the butt, but i think i finally got a c++ thing to build and link
02:43:18 <torpet> is there a clean way to multiply two matrices?
02:43:32 <torpet> i was gonna use incides (!!), but thats not really functional
02:43:56 <torpet> the matrices are of type [[]] and the dimensions are matching
02:44:03 <torpet> *matching in terms of multiplyable
02:47:19 <indiagreen> torpet: probably something like this: [map (sum . zipWith (*) xs) (transpose b) | xs <- a]
02:47:44 <indiagreen> the order might be wrong, I haven't checked
02:48:27 <k00mi> representing matrices as [[a]] is horribly inefficient
02:48:42 <k00mi> you might want to look into hmatrix or repa
02:49:13 <ThreeOfEight> indiagreen: spot on :)
02:49:29 <ThreeOfEight> I was in the process to do something similar, but you were a lot faster.
02:49:51 <indiagreen> I actually wrote it as nested list comprehensions first and then simplified
02:54:04 <Black0range> In ghci are there any way to see what classes a data type is instance of?
02:54:22 <Iceland_jack> Black0range: :i
02:54:53 <shachaf> :i in ghci
02:55:01 <Black0range> thanks :)
02:55:01 <Iceland_jack>     ghci> :info Bool
02:55:01 <Iceland_jack>     ...
02:55:01 <Iceland_jack>     instance Eq Bool
02:55:02 <Iceland_jack>     instance Ord Bool
02:57:37 <ThreeOfEight> but, yes, one probably wants a data structure for matrices that provides constant-time access, fast transposition and fast cropping
02:57:46 <ThreeOfEight> a lot of matrix algorithms want that
02:59:37 * hackagebot ad 4.2.1.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2.1.1 (EdwardKmett)
03:00:07 <Black0range> If i want to see how a Data type is instanced into a class?
03:00:55 <Black0range> Oh figured it out nvm
03:02:09 <Black0range> Wait no i didn't, whats IO's "nothing" value?
03:03:28 <wei2912> ()?
03:04:13 <Black0range> I mean something that acts like:
03:04:27 <Black0range> Nothing >>= (\ x -> Just x)
03:05:00 <wei2912> wouldn't you use the Maybe monad for that? or am i missing something here?
03:05:03 <wei2912> what're you trying to do?
03:05:25 <Black0range> I'm pretty new ;) i'm trying to figure out if theres a nice way to fail an io
03:05:37 <ThreeOfEight> Black0range: well what do you want to return on failure?
03:05:51 <Black0range> a "Nothing"
03:06:11 <wei2912> what're you trying to do?
03:06:17 <wei2912> why do you need this?
03:07:10 <shachaf> IO doen't have a "Nothing" value. Nothing is a Maybe thing.
03:07:16 <Black0range> Nothing specific, but say i have an IO function and something failed, how do i tell that function to exit nicely?
03:07:21 <ThreeOfEight> Black0range: you probably mean an mzero
03:07:27 <ThreeOfEight> http://en.wikibooks.org/wiki/Haskell/MonadPlus
03:07:41 <ThreeOfEight> MonadPlus has an mzero (Nothing for Maybe, [] for lists)
03:07:46 <ThreeOfEight> IO doesn't.
03:07:50 <wei2912> ^^
03:07:54 <Black0range> damn :(
03:07:55 <hyPiRion> Black0range: By the return value of the IO function – IO (Maybe a)
03:07:55 <moop> Maybe IO?
03:08:10 <wei2912> or, you could just use "error"
03:08:16 <tdammers> return () -- could be considered a "no-op" in IO, or anything for that matter
03:08:19 <wei2912> good old hackish ways
03:08:24 <shachaf> But asking that question probably comes from a big misunderstanding of the whole "monad" thing, so you should take a step back rather than use MonadPlus.
03:08:28 <ThreeOfEight> You /can/ use fail in the monad
03:08:30 <tdammers> but it doesn't short-circuit like Nothing does in Maybe
03:08:30 <hyPiRion> wei2912: you forgot about the "exit nicely" part
03:08:46 <wei2912> hyPiRion: anything can exit nicely with a nice big fat verbose error message
03:08:49 <ThreeOfEight> but that will just raise an exception
03:08:51 <wei2912> hyPiRion: and loads of PLEASE
03:09:13 <wei2912> yeh
03:09:37 * hackagebot machines 0.4.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.4.1 (EdwardKmett)
03:09:39 * hackagebot bytes 0.14.1.2 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.1.2 (EdwardKmett)
03:09:49 <ThreeOfEight> You /can/ use the MaybeT monad transformer with the IO monad
03:10:08 <hyPiRion> Black0range: I used monad transformers for these kinds of things. ExceptT or MaybeT, but not sure how confident you are with monads yet
03:10:47 <Iceland_jack> Black0range: If you're just looking to catch exceptions you can use that
03:11:11 <Iceland_jack> :t catch getLine {- insert exception handler here -}
03:11:11 <lambdabot> Exception e => (e -> IO String) -> IO String
03:12:44 <pikaren> why didnt lisp rule the world as the hype predicted
03:13:01 <wei2912> the hype never predicts correctly
03:13:03 <moop> (because (lisp sucks))
03:13:17 * moop ((((((((((((()))))))))))))))
03:13:32 <Black0range> oh stop the cirkle jerk:P
03:13:42 <moop> :O
03:13:44 <wei2912> time to write a haiku in lisp
03:13:51 <tdammers> lisp sucks, but not because of ((((((((((((((((((ception
03:14:02 <shachaf> Please, no language bashing in here.
03:14:10 <Iceland_jack> Take it to another channel
03:14:11 <tdammers> :D you're right
03:14:43 <wei2912> )))))))))))))))))) damnit tdammers, i had to close them for you
03:14:56 <tdammers> #-blah?
03:14:57 <torpet> indiagreen: thanks that worked great :)
03:15:03 <torpet> it also works 2 with list comprehensions
03:15:06 <torpet> same thing probably
03:15:14 <torpet> how come lpaste says this is an error? https://www.dropbox.com/s/gnub8jfa3fwz5vb/Screenshot%202014-12-03%2012.12.01.png?dl=0
03:15:16 <torpet> it is not right?
03:15:21 <shachaf> No, #-blah isn't a good channel for language bashing either.
03:15:36 <tdammers> I wasn't actually trying to *bash* lisp, although the wording was inappropriate
03:15:58 <shachaf> pikaren: This argument thing applies to programming languages, editors, indentation style, all sorts of things. This isn't a good place for it.
03:16:26 <Iceland_jack> Most people here use other languages too and all these conversations have been done to death, I like reading about Haskell in #haskell :-)
03:16:38 <tdammers> maybe I should rephrase that as "if there is a problem with Lisps, parentheses are not it"
03:26:48 <Black0range> Here's a little rpn caclulator i did for learning puposes, however are there any better way to write the guards there? http://lpaste.net/115566
03:27:39 <shachaf> Yes, you should almost never use fromJust (and isJust for that purpose).
03:27:40 <Iceland_jack> Black0range: Yes, you want to be careful with using 'isJust'
03:27:41 <shachaf> Pattern-match instead.
03:27:44 <shachaf> @where crossroads
03:27:44 <lambdabot> I know nothing about crossroads.
03:27:50 <shachaf> @where crossroad
03:27:50 <lambdabot> http://www.vex.net/~trebla/haskell/crossroad.xhtml
03:27:51 <shachaf> That one.
03:27:53 <Iceland_jack> (and 'fromJust')
03:29:20 <Iceland_jack> Black0range: Same with calls to head and tail, and fst and snd: if you see yourself calling those functions pattern matching is probably better:
03:29:21 <Iceland_jack>     case lookup x operatorsRPN of
03:29:21 <Iceland_jack>       Nothing       -> ...
03:29:21 <Iceland_jack>       Just operator -> ...
03:29:38 * hackagebot half 0.2.0.1 - Half-precision floating-point  http://hackage.haskell.org/package/half-0.2.0.1 (EdwardKmett)
03:30:05 <Iceland_jack> Black0range: (result:[]) is also the same as [result]
03:31:29 <Black0range> (result:[]) makes sure the "stack" is empty :)
03:31:54 <Iceland_jack> I know, you can pattern match on [result] and it does the same
03:32:06 <Black0range> oh
03:32:23 <Iceland_jack> > let [x] = "U" in x
03:32:25 <lambdabot>  'U'
03:32:28 <Iceland_jack> > let x:[] = "U" in x
03:32:29 <lambdabot>  'U'
03:34:13 <slomo> Iceland_jack: it seems ByteString works around that... by first allocating N bytes of managed memory, and if less than N was filled it allocates that much and copies over the data. the copying is what i wanted to prevent ;)
03:35:16 <Iceland_jack> That may be the way to go
03:36:29 <slomo> Iceland_jack: seems weird that i can't just tell the GC that only the beginning of the memory is required, and next time it's compacting it just drops the unneeded end and frees some memory for other use
03:40:05 <moop> aww, #-blah doesn't exist :(
03:40:21 <moop> and here i was excited about joining some super secret blah community
03:40:36 <Iceland_jack> moop: Something like withForeignPtr (realloc <size>) wouldn't work?
03:41:46 <exio4> moop, #haskell-blah does,though
03:41:48 <slomo> Iceland_jack: the docs say that memory allocated by mallocForeignPtrBytes must not be passed to realloc, and the return value of realloc would be unmanaged memory again anyway
03:42:11 <slomo> Iceland_jack: i guess i just go with copying for now, my goal is to create a bytestring anyway and i just noticed i could simply wrap around Data.ByteString.Internal.createAndTrim. which seems to exist exactly for my use case :)
03:49:16 <moop> exio4: interesting, it looks like that place is dead
03:49:20 <moop> rip
03:49:39 * hackagebot yaml 0.8.10.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.10.1 (MichaelSnoyman)
03:53:19 <chpatrick> exio4: https://github.com/EXio4/ohbaby-repl imperial student? :)
03:53:59 <exio4> chpatrick, how? :P
03:54:22 <chpatrick> how what? :)
03:55:34 <exio4> chpatrick, #-blah?
03:55:59 <chpatrick> exio4, sorry?
03:56:31 <exio4> nah, nevermind, I don't get how that would make an "imperial student" (if you mean www3.imperial.ac.uk/students); also, I am not :P
03:56:39 <chpatrick> ah
03:56:47 <chpatrick> I studied there and we had a really charismatic guy teaching haskell
03:56:55 <chpatrick> every time he pointed out something cool he said oh baby
03:57:17 <bitonic> tony fields <4
03:57:19 <bitonic> <3.
03:57:22 <chpatrick> <3
03:57:24 <chpatrick> ka-ching
03:57:45 <bitonic> why don't they tape those lectures
03:57:50 <chpatrick> I know right
03:57:59 <chpatrick> everyone would learn haskell
03:58:19 <bitonic> it's just too entertaining
04:00:38 <chpatrick> bitonic: did you do any functional programming before tony?
04:00:55 <bitonic> no
04:01:02 <bitonic> I barely did any programming before tony
04:01:30 <bitonic> I'm a real example of "Haskell as a first language", sort of :P
04:01:34 <bitonic> first language I studied seriously anyway
04:01:47 <chpatrick> and now look at you
04:02:15 <bitonic> I kind of got stuck there.  anyway
04:02:37 <bitonic> jokes aside, I think it'd be a great resource if they had videos of those lectures
04:03:17 <bitonic> I don't know if there is any recorded series of Haskell lectures for complete beginners
04:03:25 <bitonic> programmers beginners
04:03:48 <chpatrick> I asked him about recording last year but I guess he couldn't be assed
04:04:47 <bitonic> yeah I guess you have to pay somebody to do it.  maybe if some students volunteered, I wonder what the legal implications would be
04:04:57 <chpatrick> nah they have a big camera in the back of 308
04:05:13 <chpatrick> but yeah
04:05:21 <chpatrick> I'll ask if he invited me to uta drinks
04:05:35 <a3gis> The inf1fp course from EdinburghU is recorded: http://www.inf.ed.ac.uk/teaching/courses/inf1/fp
04:05:40 <a3gis> very basic though
04:05:53 <a3gis> also Erik Meijer did some introductory stuffs
04:06:06 <chpatrick> tony field's is pretty basic too
04:06:21 <bitonic> a3gis: yeah, the syllabus looks similar!
04:06:23 <chpatrick> but there's an advanced course that runs in parallel and covers monads etc
04:07:08 <a3gis> https://www.edx.org/course/introduction-functional-programming-delftx-fp101x#.VH78VqSsXUc
04:07:16 <a3gis> I haven't followed it though
04:07:25 <bitonic> I think if you're a beginner that's a great way to start programming.  I mean for example I had done some very basic web programming but this was so different that I was completely unfettered by it :P
04:07:42 <chpatrick> yeah I think that's why they teach haskell
04:07:54 <a3gis> it confuses people very much
04:07:56 <a3gis> (in a good way)
04:08:02 <chpatrick> even if you have experience it's probably new to you
04:08:05 <chpatrick> and it's always good for you
04:08:49 <a3gis> One sad thing I have noticed is the amount of students who consider the type system as an hindrance
04:08:58 <a3gis> something you have to fight against (including myself sometimes)
04:09:03 <bitonic> I think that's only natural
04:09:16 <bitonic> it is frustrating at the beginning
04:09:17 <a3gis> I feel introductory courses should focus a bit more on explaining what kind of goodies types bring you
04:09:23 <bitonic> and it's a particular kind of frustration
04:09:26 <a3gis> e.g. some basic stuffs from Theorems for free!
04:09:50 <a3gis> I was tutoring inf1fp this year and 90% of the mistakes students make are type errors
04:09:54 <bitonic> I don't think that'd make it better.  I think you just have to have a really good lecturer, and good error messages
04:09:56 <a3gis> they simply don't think in terms of types
04:10:14 <bitonic> yeah that's totally my experience too
04:10:23 <bitonic> of counter intuitiveness
04:10:35 <a3gis> they'll ask things like "what should the base case for that function return? 0? []?"
04:10:36 <bitonic> well not so much me personally, but in general people are annoyed by it
04:11:42 <bitonic> I really think the only way to realise it's good it's by experience.  you have to make everything else as nice as possible and hope that people will eventually realise as they use Haskell/whatever
04:11:56 <a3gis> yeah fair enough
04:12:23 <a3gis> I only really god existed about type systems when I discovered haskell, and then idris/agda
04:12:38 <a3gis> got*
04:13:44 <a3gis> oh yeah those were pretty good too: http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
04:14:17 <nshepperd> well, in haskell, when you get a type error it's generally because you tried to do something nonsensical
04:14:59 <bitonic> nshepperd: people don't like to be told they're doing nonsensical stuff
04:15:20 <a3gis> ^
04:15:52 <nshepperd> well yeah, people ask about 'turning off' type errors frequently enough
04:16:02 <bitonic> a3gis: that looks good thanks
04:16:20 <tdammers> yeah, and then they flock to "easy" languages, where you won't get complaints for adding a network socket to a suspension bridge and dividing the result by a list of italian dishes
04:16:28 <nshepperd> but, I don't think there's any shortcut to writing code that makes sense
04:16:35 <nshepperd> that's "learning to program"
04:17:13 <tdammers> I like the argument that says "you're going to be dealing with types anyway; the question is just whether you want to do it explicitly and in a structured, formalized way that a compiler can check for you"
04:17:17 <a3gis> nshepperd: yep; at least type systems tell you when you're really not making any sense
04:18:43 <nshepperd> (actually, types can help sometimes, what with free theorems and such. "Oh, I need to return a value of type `a`, but there's only `x :: b` and `f :: b -> a` in scope? I'd better return `f x`.")
04:19:11 <tdammers> also, "types as documentation"
04:20:01 <hpc> you really don't appreciate types as documentation until you have to deal with someone else's code
04:20:16 <a3gis> tdammers: hoogle <3
04:20:17 <hpc> especially where you don't even know if the real documentation is correct
04:20:25 <tdammers> hpc: "someone else" being myself more often than not :D
04:20:51 <hpc> tdammers: seriously :P
04:21:08 <hpc> i can go back to code from 6 months ago and not even remember writing it
04:21:33 <hpc> fortunately everyone else forgets too, usually
04:21:43 <tdammers> yeah
04:21:45 <hpc> so when i ask everyone in the office "who wrote this crap" they usually don't remember
04:21:51 <tdammers> haha
04:21:57 <tdammers> I actually did that more than once
04:22:36 <tdammers> cursed the person who wrote "this crap", then checked the commit history and lowered my head in shame, for the commit history displayeth my own name
04:22:55 <bitonic> a3gis: that doesn't look for complete beginners though
04:23:07 <bitonic> it starts with a big discussion on where functional programming fits compared to OO and mutability and such
04:23:18 <bitonic> if I've never programmed, I really don't care
04:23:39 <tdammers> "deducation" for OO programmers
04:23:46 <bitonic> it looks like it is for existing programmers
04:25:46 <troydm> hows is monadic operators named in haskell
04:25:51 <troydm> e.g. >>= and >> ?
04:25:56 <hpc> (>>=) is bind
04:26:04 <troydm> and the second one?
04:26:10 <hpc> (>>) is usually also bind on the rare occasions it is spoken out loud
04:26:14 <hpc> join is join
04:26:21 <hpc> return is return (or sometimes pure)
04:26:24 <troydm> so it's join?
04:26:32 <troydm> >> == join ?
04:26:34 <hpc> no
04:27:07 <hpc> it's not said very often, but it's usually bind
04:27:29 <shachaf> It's often pronoucned something like "and then".
04:27:35 <shachaf> But it doesn't really matter.
04:27:47 <hpc> or that
04:31:27 <tdammers> ">>, the operator we rather not talk about"
04:32:16 <hpc> then there's fail, the operator we talk about how we'd rather not have
04:36:08 <dv-> poor fail
04:38:44 <moop> >>
04:44:19 <ski> GBrawl : re
04:45:16 <GBrawl> oh hey ski, I watched that video that someone linked here (don't know if it was you) and now I finally understand monads
04:45:54 <jackhill> GBrawl: oh cool. I might be interested in seeing that too.
04:46:28 <ski> GBrawl : which video ?
04:47:24 <GBrawl> here is the link: http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
04:47:33 <chpatrick> grats
04:47:49 <ski> ok
04:48:22 <ski> GBrawl : i wanted to reiterate and continue a little on the points i said yesterday. would now be a good time ?
04:48:34 <GBrawl> yes ski, would be great :D
04:48:37 <ski> (some of it may be covered also by that video, i don't know)
04:48:39 <ski> ok
04:49:49 <ski> well, let's assume `M' is a monad, and `T' is some type. then a value of type `M T' is sometimes known as an action (an `M'-action) (yielding a monadic result of type `T'), or an (effectful) "computation" (being a bit vague with what we mean exactly by that)
04:50:14 <ski> sometimes, `M' can also be seen as a type of collections, so that `M T' is then the type of collections with elements of type `T'
04:51:30 <GBrawl> I see, interesting
04:51:41 <ski> a value of type `M T' can roughly be thought of as : when "run"/"executed", possibly producing a value of type `T', perhaps also "doing" something else
04:52:06 <ski> the scare-quoted words here are words with special technical (though a bit vague) meaning
04:53:18 <chpatrick> here's some intuition for the other typeclasses you might find useful
04:53:20 <Black0range> guys in pattern matching are there any way to do an "or" ?
04:53:24 <ski> you should note that "run" or "execute" here is not the same as "evaluate" (you evaluate expressions to produce values. when writing formulae/expressions, we can *operationally* describe this in more detail by *reducing* the expression step-by-step, until it reaches "normal form", it can't be reduced anymore)
04:53:43 <chpatrick> let's call something of the form f a or m a a computation in some context
04:53:55 <chpatrick> then if f is a Functor, you can change the a with a pure function
04:54:03 <chpatrick> the result of the computation if you like
04:54:15 <chpatrick> if f is an Applicative, you can combine the results of multiple computations with a pure function
04:54:20 <ski> (nevertheless, a "value" is something abstract/ideal, while an expression in normal form is concrete. not all values can be represented as (normal-form) expressions. so, strictly speaking, evaluation is distinct from reduction)
04:54:36 <chpatrick> if it's a Monad, you can decide what computations to do based on the previous results
04:54:51 <ski> Black0range : you can use `||' in a guard, but unfortunately there's no disjunctive patterns in Haskell
04:55:08 <chpatrick> with Functor and Applicative the computations are set in stone, with Monad they can depend on what happens "earlier"
04:56:04 <GBrawl> ski: alright I get what you are saying
04:56:13 <ski> GBrawl : as chpatrick says, some of the ideas and terminology carries over to more general situations than monads (iow, "idioms" / applicative functors, and functors in general. there's also "arrows" and "caregories")
04:57:02 <chpatrick> the key thing about monads is really join :: m (m a) - > m a
04:57:15 <chpatrick> so a computation that makes a computation is a computation
04:57:35 <ski> GBrawl : another small note. if you have e.g. `getLine :: IO String', then `getLine' is not a "monad", anyone saying that is confused (at least as far as their terminology is concerned). `IO' is the monad. `IO String' might be said to be a monadic type. and `getLine' is an `IO'-action -- i mention this because newbies often confuse the terminology here
04:57:38 <chpatrick> you can define monads in terms of return and either (>>=) or join
04:58:35 <GBrawl> ow wow ski thanks for saying that, heard saying something like that yesterday
04:59:04 <ski> GBrawl : so, a value of type `M T' (for `M' a monad, or more generally an applicative functor, or just any functor) describes how to "compute" a value of type `T' and perhaps also "doing something more/else"
05:00:17 <audi> hello. is here anyone willing to discuss about "lazy" rendering of ... GUIs? (i.e. applying the lazy features of Haskell to GUIs rendering and/or embedded business logic)
05:00:49 <ski> GBrawl : for a particular action `act :: M T', it *could* be the case that it "does nothing but yield a result value (of type `T')" -- this is true for any monad `M' (and also true for any applicative functor)
05:01:15 <GBrawl> so for example I have a function f :: a -> m a
05:01:18 <HugoDaniel> audi: what would you like to discuss ?
05:01:19 <GBrawl> but the m does absolutly nothing?
05:01:48 <ski> GBrawl : note that i said "could"
05:02:10 <ski> the interesting case is when the above *doesn't* hold (that's the whole point of monads (and applicative functors))
05:02:18 <ski> GBrawl : we say that *any* deviation from `act' simply "computing a single result of type `T', doing nothing else" is an "effect"
05:02:59 <ski> GBrawl : so, *if* `act' "does nothing else than compute a (single) result value", then it can be called "effectfree". otherwise it is "effectful"
05:03:28 <GBrawl> is it possible to give an example of an effectful monad?
05:03:29 <ski> but it's important to realize that `act' being effectfree is an option (for monads and applicative functors. it's not an option for functors in general)
05:03:38 <ski> GBrawl : `Maybe' is a simple example
05:03:59 <ski> the "doing something else" here is simply "fail to compute a result of type `T'"
05:04:27 <GBrawl> so my maybe can be an "error" or simply the "value" right?
05:04:31 <ski> so what an action of type `Maybe T' does is : either compute a result of type `T', or fail to compute a result of type `T' (and you can tell which it is)
05:04:39 <ski> GBrawl : right
05:05:17 <ski> and because of how the `do'-notation and the `(>>=)' operation which results from desugaring the former works for `Maybe', you get short-circuiting "for free"
05:05:26 <jophish> Yo yo yo
05:05:40 <Black0range> Guys I'm going to ask the forbidden question! What kind of problems is Haskell not really suited for?
05:05:50 <jophish> What's the name for the property present in: map f . map g = map (f.g)
05:05:53 <GBrawl> So If i would implement the maybe monad myself it would be something like:
05:05:57 <jophish> something other than shape-preserving
05:06:04 <ski> the first (possibly) effectful component action that you perform that fails to compute a result will shortcircuit the whole compound action, making it also fail to compute a result
05:06:12 <indiagreen> jophish: parametricity?
05:06:13 <GBrawl> Result a >>= f = f a?
05:06:15 <jophish> is it holomorphism?
05:06:19 <HugoDaniel> Black0range: hard real time, but even there you can make a go for it in haskell
05:06:20 <opqdonut> jophish: map is a "lift"
05:06:31 <ski> that is, *unless* you explicitly use some "catching" construct that catches the failure of the first part and tries something else instead
05:06:51 <ski> GBrawl : yes
05:07:01 <ski> @src Maybe
05:07:01 <lambdabot> data Maybe a = Nothing | Just a
05:07:03 <ski> @src Maybe (>>=)
05:07:03 <lambdabot> (Just x) >>= k = k x
05:07:04 <lambdabot> Nothing  >>= _ = Nothing
05:07:20 <ski> (i'd simplify `(Just x)' there to `Just x', but whatever :)
05:07:43 <HugoDaniel> Black0range: like with atom: http://hackage.haskell.org/package/atom  still thats a vague question, you can do anything with anything, its software :P
05:07:55 <Black0range> HugoDaniel: Like video, audio chat?
05:07:56 <ski> Black0range : so, if the left part yields a value `a'/`x', we pass it to the right part, and let it decide whether to succeed or fail, given that value. otherwise we fail immediately
05:08:01 <ski> rt
05:08:02 <ski> er
05:08:15 <ski> GBrawl : see above. i send to Black0range by mistake
05:08:19 <tdammers> Black0range: realtime DSP is a good example
05:09:03 <tdammers> for example, if you code against JACK, your callback should not perform any I/O, and it shouldn't malloc or free either
05:09:05 <ski> GBrawl : ok ?
05:09:25 <tdammers> Haskell doesn't give you enough control over memory allocation to do that
05:09:33 <GBrawl> so we start from a monadic value ma and bind that to a function that takes an a and returns an ma for example?
05:09:44 <ski> jophish : functors preserve composition
05:09:51 <tdammers> the same obviously goes for every other memory-managed language
05:10:19 <tdammers> another thing I wouldn't Haskell for is tiny throwaway scripts
05:10:24 <ski> GBrawl : yes, or in general that function may return an action `mb :: m b', where the type `b' needn't be the same as the type `a' in `ma :: m a'
05:10:40 <tdammers> too much ceremony for a dozen lines of payload code
05:11:07 <ski> GBrawl : the monad `m' has to be the same, but the "monadic result type" (`a' vs. `b') needn't be the same, in the two arguments to `(>>=)'
05:12:31 <ski> @type (>>=)
05:12:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:12:33 <ski> @type (>>)
05:12:34 <lambdabot> Monad m => m a -> m b -> m b
05:12:36 <gp5st> could someone help me with this error.  I don't think I'm understanding it (and as such, how to fix it) http://dpaste.com/3BXNEA0
05:13:37 <jeltsch> @type mkUGraph
05:13:39 <lambdabot> Not in scope: ‘mkUGraph’
05:13:53 <jeltsch> @type Data.Graph.mkUGraph
05:13:54 <lambdabot> Not in scope: ‘Data.Graph.mkUGraph’
05:13:57 <jeltsch> Hmm.
05:14:18 <GBrawl> ski: do you have another example except for maybe, or is that getting too complex?
05:14:42 * hackagebot Spock 0.7.5.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.5.0 (AlexanderThiemann)
05:14:49 <gp5st> @type Data.Graph.Inductive.mkUGraph
05:14:50 <lambdabot> Not in scope: ‘Data.Graph.Inductive.mkUGraph’
05:15:20 <ski> gp5st : imho, those docs out to say `graph node edge' or `graph nodeAnnotation edgeAnnotation' or `gr n e' or `gr nAnn eAnn' or something like that, to suggest the *roles* that the two type arguments to `gr' play
05:15:47 <ski> GBrawl : sure, i'm just waiting for you to digest what i've said so far, and whether you had any more questions
05:16:21 <ski> (and i got a little busy formulating responses to jophish,gp5st)
05:17:01 <ski> GBrawl : so, a natural extension of `Maybe' is `Error E', where `E' is any type of "errors/exceptions/failures" you want to use in a particular situation
05:17:45 <GBrawl> so instead of nothing you write, Error e >>= _ = Error e?
05:17:50 <ski> GBrawl : the main difference is that now, if you have two "independent" sub-computations, it matters in which order you execute/run them, because both may fail, but in different ways, and you get the first failure
05:17:53 <GBrawl> so that whatever you do with it gives back an error?
05:18:34 <ski> for `Maybe', there's just one ("anonymous", if you like) kind of failure, so the ordering of "independente" subcomputations there doesn't matter, conceptually speaking
05:18:58 <ski> GBrawl : yes
05:19:01 <ski> @src Either
05:19:01 <lambdabot> Source not found. You untyped fool!
05:19:12 <ski>   data Either a b = Left a | Right b
05:19:16 <ski> @src Either (>>=)
05:19:16 <lambdabot> Left  l >>= _ = Left l
05:19:16 <lambdabot> Right r >>= k = k r
05:19:17 <gp5st> ski: no worries :)
05:19:43 * hackagebot cli 0.0.3 - Simple Command Line Interface Library  http://hackage.haskell.org/package/cli-0.0.3 (nicolasdp)
05:19:45 * hackagebot jsontsv 0.1.4.0 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.0 (DanielChoi)
05:19:54 <ski> GBrawl : now, *another* possible way to extend the idea of effects in `Maybe' is to move to `[]', lists
05:20:06 <ski> so, for `Maybe', you get zero or one result
05:20:12 <ski> for `[]', you get possibly more results
05:20:16 <gp5st> ski: jeltsch: http://hackage.haskell.org/package/fgl-5.5.0.1/docs/Data-Graph-Inductive-Graph.html lists it as mkUGraph :: Graph gr => [Node] -> [Edge] -> gr () ()
05:20:45 <ski> again, the "deviation from computing a single value" in this case is "computing zero values, or computing more than one value"
05:21:39 <ski> GBrawl : for `[]', `ma >>= amb' will repeatedly call `amb' for each value `a' in the list `ma', and then concatenate all the resulting lists of values (in order)
05:21:40 <gp5st> I thought that that matches the signature of what my function wants, but the error seems to imply it's returning a gr  no a gr () ()
05:22:24 <ski> > [1,2,3] >>= \x -> [100,211] >>= \y -> [x + y]
05:22:26 <lambdabot>  [101,212,102,213,103,214]
05:22:52 <ski> so, this acts like two nested loops, trying each possibility in turn
05:22:59 <ski> GBrawl : ok ?
05:23:29 <GBrawl> alright I think I get the hang of it
05:23:46 <ski> gp5st : there's also `mkGraph :: Graph gr => [LNode a] -> [LEdge b] -> gr a b' which gave me the hint needed to determine which argument was what
05:24:01 <ski> GBrawl : note that i used a singleton list at the end there
05:24:05 <ski> i could also have written
05:24:14 <ski> > [1,2,3] >>= \x -> [100,211] >>= \y -> return (x + y)
05:24:15 <lambdabot>  [101,212,102,213,103,214]
05:24:46 <ski> because `return x' is the "trivial" action, that "does nothing else but result in the value of `x'"
05:25:21 <ski> (for applicative functors, `return' is renamed (for historical reasons) to `pure')
05:26:08 <gp5st> ski they're the types of the label for the nodes and edges; i was just using the unlabled () version i thought
05:26:32 <gp5st> g2g 2 work brb
05:27:07 <ski> > [1 .. 20] >>= \z -> [1 .. z] >>= \y -> [1 .. y] >>= \x -> if x^2 + y^2 == z^2 then return (x,y,z) else []
05:27:08 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
05:27:18 <GBrawl> oh god so many binds
05:28:00 <ski> is an example of an exhaustive search (brute-force) that computes <https://en.wikipedia.org/wiki/Pythagorean_triples>
05:28:05 <Darwin226> Is there a way to turn HLint off for a part of my file?
05:28:39 <ski> GBrawl : note that in this case i use the value selected earlier to determine the bounds of the next selection. also at the end i use `[]' to represent failure
05:28:53 <ski> using `do'-notation the same would be written as
05:29:37 <ski> > do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)
05:29:38 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
05:29:58 <ski> where `guard' is a utility function that does the above condition checking
05:30:10 <ski> for the special case of lists, you can also use list comprehensions :
05:30:12 <joehillen> does anyone know how to fix this? https://gist.github.com/joehillen/235d3bdc637266bdde07
05:30:29 <ski> > [(x,y,z) | z <- [1 .. 20],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]
05:30:31 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
05:31:08 <ski> (there's also a language extension that allows you to use the list comprehension syntax for any monad, though it may look confusing if the monad isn't "collection-like" (which is more or less subjective))
05:31:19 <GBrawl> Okay I think I have enough information now
05:31:30 <GBrawl> thanks ski and chpatrick for the help
05:32:03 <ski> GBrawl : there's also the `State s' monad, which implicitly carries (threads) along a value of type `s', which you can set and update at any time
05:32:36 <GBrawl> can you tell me something more about that?
05:32:56 <tdammers> ski: one could argue that Haskell lists aren't even truly collection-like themselves...
05:33:04 <ski> GBrawl : and there's the `Reader rho' monad, which implicitly carries around a local "environment" (think "environment variables for OS processes"), that are propagated "down" in the computation, but not "up"
05:33:16 <ski> you can locally change the value for one sub-computation, but when it's done, the old value is automatically reverted to
05:34:27 <ski> GBrawl : and there's the output/logging monad `Writer w', which allows each subcomputation to emit some extra information, and all these information parts are "concatenated" (perhaps list concatenation, perhaps counts are summed, or some other variant)
05:35:29 <GBrawl> oh I got an exercise about Writer, let me search that so I can perhaps ask some questions
05:35:31 <ski> GBrawl : then there's the continuation monad `Cont o', which in some sense allows you to "go crazy with `GOTO's" -- it can be very powerful in some circumstances, but is also often hard to understand
05:36:47 <ski> GBrawl : and then there's more application-specific monads (often built on top of the above basic monadic idea), e.g. parsing monads, where an action `act :: Parse ParseResult' will try to consume input (perhaps trying different ways with backtracking, before succeeding), generating a result of type `ParseResult
05:37:49 <ski> GBrawl : anyway, some more general conceptual information : that a type is a monad (or applicative functor, or just a functor) is usually a relatively small part of its interface. you have to have *more* operations to be able to do anything *useful* with it
05:38:13 <ski> GBrawl : just knowing that something is a monad (or applicative functor, or functor), but nothing else, allows you to do *nothing* non-trivial with it
05:39:26 <ski> GBrawl : so the type classes `Monad',`Applicative' and `Functor' capture and abstract over *some* common parts of interfaces, but is by no means all that needs to be said about a particular type
05:39:33 <ski> just knowing that `IO' is a monad is pretty useless
05:40:16 <ski> and, it would be possible to achieve the same thing that `IO' does, with operations corresponding to most of the basic `IO' operations, without making `IO' a monad (or defining stand-alone operations corresponding to `return' and `(>>=)')
05:41:09 <ski> GBrawl : another piece to think about : in one sense, the most important part of monads (and applicative functors) is when you know you're *not* using them
05:42:28 <GBrawl> that's a deep one
05:42:32 <ski> in imperative programming languages, because the effects aren't explicitly kept track of, they are *side*-effects, and so you can't tell, just by looking at the interface of a library operation if it modifies (or depends on the current value of) some external mutable variable -- this hinders refactoring *lots*
05:43:50 <ski> so, either you have to delve deep into the implementation of the library to tell, or you have to assume the worst (and thus can't reason, refactor and maintain that effectively), or you assume more than you can logically expects, and so you (later, perhaps years after, when someone modifies the library to use external mutable state) get strange bugs
05:44:38 <GBrawl> so the purpose of monads is extensibility in a way?
05:45:01 <ski> Haskell forbids *side*-effects (to enable reasoning and refactoring), but to still be able to express *effects* we use monads and applicative functors (and arrows or categories, and to some extent functors)
05:45:41 <ski> well, in one sense, the purpose is just to factor out some commonly occuring patterns of code (i.e. boilerplate)
05:46:22 <ski> but, in another sense, monads (and applicative functors) are the means we've choosen by which we can avoid side-effects, but still have effects
05:46:57 <ski> so as to enable better reasoning and refactoring, but still allow the expressibility of effects
05:47:07 <ski> GBrawl : does that make sense ?
05:47:29 <GBrawl> yeah more or less
05:48:40 <ski> GBrawl : now, for `act :: State s a', this expresses a computation that may depend implicitly on (one) (current/previous) "state" value of type `s', and apart from computing a result of type `a' will also compute a (possibly new) next state value of type `s'
05:49:03 <ski> in essence, `act' is a function of type `s -> (a,s)', a "state transformer"
05:49:08 <GBrawl> oh I see
05:49:38 <GBrawl> just one last question, can you further explain the writer monad?
05:49:43 <ski>   newtype State s a = MkState (s -> (a,s))  -- is basically how it used to be implemented
05:49:54 <ski> (now it's slightly different, to allow for more generality)
05:51:09 <ski> GBrawl : ok, the output monad `Writer w'. an action `act :: Writer w a' will compute a result value of type `a', and also an additional "extra result" of type `w', that is implicit/hidden
05:51:42 <ski> furthermore, using `(>>=)' (or `(>>)') to combine several such acts, their corresponding extra values of type `w' will be "concatenated"
05:52:01 <ski> and if you use `return x', then you'll get a "trivial"/"empty" value of type `w' as the extra value
05:52:18 <ski> if `w' is the type `[t]', then this is just the empty list, and list concatenation
05:52:34 <ski> if `w' is the type `Sum n', then this is zero and addition on numbers
05:52:51 <ski> if `w' is the type `Prouct n' then this is one and multiplication on numbers
05:52:59 <ski> well, `Product n'
05:53:29 <ski> there's also `Any' and `All' which uses booleans, with `False',`(||)', alternatively `True',`(&&)'
05:53:49 <ski> `Writer w' requires the type `w' to satisfy the `Monoid' interface
05:53:50 <ski> @src Monoid
05:53:50 <lambdabot> class Monoid a where
05:53:50 <lambdabot>     mempty  :: a
05:53:50 <lambdabot>     mappend :: a -> a -> a
05:53:50 <lambdabot>     mconcat :: [a] -> a
05:54:16 <ski> and `return' and `(>>=)' for `Writer w' uses `mempty' and `mappend' from this class
05:54:29 <ski> (`mconcat' is just a handy shorthand for combining a list of values)
05:54:37 <ski> GBrawl : are you familiar with `Monoid' ?
05:54:50 <GBrawl> yes I know what that is
05:54:53 <ski> good
05:56:46 <ski> > execWriter (do tell (Sum 2,mempty); tell (mempty,"hello"); tell (Sum 3,mempty)) :: (Sum Integer,String)
05:56:48 <lambdabot>  (Sum {getSum = 5},"hello")
05:57:00 <ski> is a very simple example using `Writer (Sum Integer,String)'
05:57:56 <ski> (there is possibly, or at least ought to be, a way to avoid having to write `mempty' for the non-affected "fields" of the "logging". probably it can be done with the `lens' library)
05:58:17 <GBrawl> okay enough monads for today, my head is about to explode :D
05:58:58 <ski> tdammers : elaborate ?
05:59:07 <ski> GBrawl : ok :)
05:59:24 <ski> if you are wondering about anything more later, just ask
05:59:29 <GBrawl> thanks for the help I'll hit you up if I need more help :D
06:00:34 <tdammers> ski: current knowledge combined with newly-acquired knowledge through learning is also knowledge; adding ignorance (taken to mean "the absence of knowledge") to current knowledge is identity
06:01:02 <ski> tdammers : what was that re ?
06:01:08 <tdammers> -blah
06:01:15 * tdammers is a bit confused
06:01:18 <ski> (i was asking re what you said about collections, a bit above)
06:01:23 <tdammers> ah
06:01:29 <tdammers> lists in Haskell are lazy
06:01:35 <ski> (not that i'm implying that what you said didn't sound interesting)
06:01:41 <tdammers> :D
06:01:46 <tdammers> blah-material though
06:01:49 <tdammers> anyway
06:02:07 <tdammers> what I meant is that a Haskell list is just a cons cell, where both the head and the tail are lazy
06:02:40 <tdammers> so you can think of them as representing a traversal, or a continuation, or something like that
06:03:40 <ski> well, depending on my mood, i might accept thinking of any value of type `f a', for `f' a functor, as a collection
06:04:27 <c_wraith> Coyoneda IORef a?  Sure, that's a collection.  Sort of.  :)
06:04:48 <ski> (and certainly any value (in Haskell, or in general, e.g. in math) of type `i a', for `i' an applicative functor (or monad), as expressing an effectful computation)
06:05:00 <ski> c_wraith : *nods* ;)
06:05:57 <bernalex> ski: so getChar is a collection?
06:06:08 <orion> Is using TypeSynonymInstances bad?
06:06:16 <ski> bernalex : sure, depending on the current mood
06:06:17 <bernalex> orion: if you have to ask... :-P
06:06:18 <c_wraith> really, I suppose Coyoneda IORef a supports basically the same operations as Identity a, except for needing to be in IO to extract it.
06:06:48 <shachaf> c_wraith: Well, except that other people can change the value in the IORef.
06:07:00 <c_wraith> shachaf: oh, right.  that
06:07:08 <tdammers> details.
06:07:25 <c_wraith> orion: it's not bad, but..  It's not really good, either.  Usually if you're trying to use it, something else is going to blow up
06:07:31 <orion> hwchen: I am in a situation where I can't avoid using either an orphan instance or a TypeSynonymInstances.
06:07:41 <ski> orion : i don't think it's bad. perhaps it can be a little confusing to someone expecting that if (the head type constructor in) two instance heads look different, then they don't overlapp
06:07:42 <bernalex> orion: usually when you're using TypeSynonymInstances, in my experience, you already have way more sketchy stuff in there anyway. like MultiParamTypeclasses, FlexibleInstances, FlexibleContexts, TemplateHaskell etc.
06:08:43 <c_wraith> orion: I don't see how you can possibly avoid an orphan instance with that extension
06:08:49 <bernalex> orion: FWIW you can surpress the orphan instance warning for that specific file.
06:08:58 <c_wraith> orion: you might fool GHC's orphan instance checker, but the instance is still orphaned
06:08:58 <bernalex> and I agree. with c_wraith lol.
06:09:03 <ski> shachaf : but there is no problem of some part of `CoYoneda IORef a' possibly interleaving with such update .. apart from what is already the case with `IORef' and concurrency (or `unsafeInterleaveIO')
06:09:45 * hackagebot cli 0.0.4 - Simple Command Line Interface Library  http://hackage.haskell.org/package/cli-0.0.4 (nicolasdp)
06:09:58 <ski> bernalex : is there a partial ordering of the "safeness" of various extensions documented somewhere ?
06:10:00 <shachaf> ski: Sure, but do { foo; read v } can return a different value from do { read v }
06:10:24 <bernalex> ski: really doubt taht, since the safeness is usually very subjective.
06:10:29 <bernalex> s/ah/ha/
06:10:38 <ski> (obviously it will be an ordering that's at least as determined as that specified by which extensions imply which others)
06:10:43 <shachaf> I'm not sure whether this generalized form of "return" is useful or confusing.
06:10:48 <shachaf> Probably both.
06:10:57 <c_wraith> shachaf: it sounds like it has confused you
06:11:00 <bernalex> ski: it would be interesting to see an analysis though. like a wiki page or something.
06:11:09 <ski> bernalex : *nod*. so preferably each Hasse diagram edge described separately, with rationale
06:11:11 <shachaf> (For the (r ->) monad it turns into the regular sense of the word "return".)
06:11:31 <bernalex> ski: do it! hehe
06:11:58 <bernalex> or, rather, get it going! someone else will likely do the bulk of the work as long as you get it going.
06:17:35 <ski> shachaf : *nod*
06:17:59 <exio4> would it be possible to define some instance of a typeclass like "instance Monad m => Monoid (forall a b. a -> (m b)) where"?
06:18:55 <tdammers> my gut feeling says no
06:19:14 <tdammers> a -> m a, yes; a -> m b, no.
06:20:06 <exio4> a → m a works but is nearly useless
06:20:15 <exio4> (compared to that other fancy instance)
06:21:02 <tdammers> the problem as I see it is that <> would require both operands as well as the return value to be of the same type
06:21:57 <exio4> it also doesn't make much sense (the way I did), because it is _for all_
06:22:04 <tdammers> yes
06:22:26 <exio4> (Int -> m Bool) <> ([a] -> m Int) would typecheck
06:22:27 <tdammers> at best, that would mean you could make it typecheck, but you wouldn't be allowed to write <> in a meaningful way
06:22:39 <tdammers> yeah
06:23:14 <tdammers> it would typecheck, but I think the only thing it could do would be "ignore both arguments and fail" or something like that
06:23:52 <tdammers> instance Monad m => Monoid (forall a b. a -> (m b)) where a <> b = fail ""
06:27:00 <flyingfisch> I am reading this article: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
06:27:14 <flyingfisch> What does he mean by this? f,g :: Float -> Float
06:27:23 <wei2912> flyingfisch: it's a function signature for f and g
06:27:29 <exio4> that f and g have the types "Float -> Float"
06:27:31 <exio4> f :: Float -> Float
06:27:34 <exio4> g :: Float -> Float
06:27:38 <exio4> would be equivalent to that
06:27:48 <flyingfisch> you can declare the function signatures for two functions at the same time?
06:28:16 <shachaf> You can declare type signatures for two things at the same time, even when they aren't functions.
06:28:20 <shachaf> x, y :: Int
06:28:29 <flyingfisch> ok, must have missed that
06:28:30 <flyingfisch> thanks
06:30:28 <flyingfisch> is f' pronounced "f prime" in Haskell like in Math?
06:30:59 <bernalex> flyingfisch: you can pronounce it however you'd like, but that's how people generally pronounce it, yes.
06:31:02 <eXeC64> flyingfisch: Have to add a question of my own to that, how is f'' pronounced? "f sec"?
06:31:20 <flyingfisch> bernalex: k
06:31:30 <bernalex> eXeC64: I would just say "f double prime"
06:32:19 <eXeC64> bernalex: Oh, thanks. I always wondered, since I've seen it written but never pronounced.
06:32:38 <exio4> I wouldn't go over double prime, for what it is worth :P
06:33:10 <eXeC64> exio4: There's nothing wrong with `let var_4'''' = ...`
06:33:25 <eXeC64> ;)
06:33:28 <bernalex> it's not really a problem. you don't tend to read source code like prose.
06:33:51 <bernalex> variable names don't really matter in FP, because you want to keep your scope short.
06:35:03 <eXeC64> Apropros reading code: Is there a tip to remembering associativity of different operators? Like "bidmas/bodmas" in kids' math class. I find myself just adding $ until things work.
06:39:01 <Fuuzetsu> $ is easy, it's like adding parenthesis over everything to the right
06:39:24 <eXeC64> Well, yeah, but I mean the other operators
06:39:39 <eXeC64> I just use $ to fix associativity when it's wrong
06:39:40 <Fuuzetsu> you can use :i to find out fixity
06:40:01 <Fuuzetsu> but in most cases you just learn which can be used together easily
06:40:07 <eXeC64> Fuuzetsu: Thanks. I suppose it's just something you're naturally familiar with over time.
06:40:07 <Fuuzetsu> trust library author to make a reasonable choice
06:41:09 <tdammers> fixity of <$> and $ when used together get me all the time
06:41:17 <tdammers> $ and >>=, too
06:41:37 <exio4> I normally end abusing () around everything
06:41:47 <tdammers> same here
06:41:50 <Fuuzetsu> I don't see how you'd have problem with $ and anything
06:42:03 <tdammers> the problem is with me, not with $
06:42:04 <eXeC64> Oh, since I'm here. I've been reading/learning about the `newtype` keyword. As far as I can tell, it's identical in behaviour to `data`, except for its restriction on the types that can be created with it. Is that correct? And if so, why doesn't ghc merely use `newtype` internally when able, if the purpose is only performance related.
06:42:46 <Fuuzetsu> there's stuff like GeneralizedNewtypeDeriving &c which mess with things I believe
06:43:20 <tdammers> Fuuzetsu: GND would still work though... it's perfectly nonintrusive until you start actually deriving stuff on newtypes
06:43:24 <Fuuzetsu> http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
06:44:21 <tdammers> of course if we were to allow GeneralizedDataDeriving on data types that fit the bill (i.e., they would make valid newtypes if you changed the keyword from 'data' to 'newtype'), ...
06:44:28 <benzrf> idea for a cute notation:
06:44:35 <benzrf> expr as vars here
06:44:40 <benzrf>   stuff
06:44:43 <benzrf> becomes
06:44:48 <benzrf> expr $ \vars here -> do
06:44:50 <benzrf>   stuff
06:45:03 <tdammers> I wonder, though, if newtype vs. data has any practical implications when it comes to strictness
06:45:08 <Kaidelong> so I just want to make sure I understand the capabilities of LogicT correctly
06:45:19 <lisbeth> are there attempts in haskell to evalutate logical statments with more than two outcomes
06:45:22 <Kaidelong> it allows functions to be nondeterministic, and it does it more efficiently than []
06:45:32 <lisbeth> for example True || Possible = true
06:45:36 <lisbeth> Sorry I mean false
06:45:40 <Kaidelong> it does not do any narrowing or constraint resolution, and it does not create reversible relations
06:45:46 <Kaidelong> am I right interpreting it that way?
06:45:46 <Procian> My understanding is that it allows you to search infinite spaces.
06:46:16 <lisbeth> on wait
06:46:18 <lisbeth> definitely true
06:46:24 <Fuuzetsu> lisbeth: x || y will always return Bool which can only have two values, True or False (modulo ⊥)
06:46:28 <lisbeth> I apologize I am tired.
06:46:42 <Kaidelong> (I am trying to understand why functional logic systems like Curry cannot just be embedded in Haskell and require a wholly new language)
06:46:55 <lisbeth> I am talking about developing a set of functions that can be used as syntax
06:47:05 <eXeC64> Fuuzetsu: That SO question helped, thanks/
06:47:08 <lisbeth> lets say for arguments sake we use kleene's model of truth values
06:47:13 <lisbeth> true false and possible
06:47:33 <lisbeth> you could develop a function instead of || and call it something like kleene's_OR
06:47:48 <lisbeth> and use it like `kleene's_OR`
06:48:30 <lisbeth> My question is do you know of any attempts to do this?
06:49:06 <lisbeth> here's the logic tables for kleene's model if you are a bit lost: https://en.wikipedia.org/wiki/Many-valued_logic#Kleene_.28strong.29_K3_and_Priest_logic_P3
06:49:27 <lisbeth> including not or and conditinal and biconditional
06:50:30 <sbidin> Why isn't pointer equality referentially transparent?
06:50:38 <sbidin> In the context of Haskell?
06:50:40 <Procian> Kaidelong: Haven't looked at Curry. But I have wanted to use a monad to do non-deterministic search without the limitations of List.
06:52:29 <Fuuzetsu> lisbeth: if you're asking if there are existing libraries for this then ‘probably but I don't know of any off-hand’
06:53:11 <lisbeth> I am imagining an AI
06:53:25 <lisbeth> that learns mathmatical rules to help predict if an outcome is possible
06:54:11 <lisbeth> or even probable
06:54:36 <rom1504> sounds like http://en.wikipedia.org/wiki/Markov_logic_network
06:54:46 * hackagebot monad-par 0.3.4.7 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.7 (RyanNewton)
06:58:03 <luite> sbidin: for normal pointers it is, Ptr has an Eq instance, (==) is pure and referentially transparent.
06:58:03 <eXeC64> Huh, is <$> just an alias of fmap?
06:58:27 <Procian> eXeC64: Yeah.
06:58:27 <Kaidelong> yes
06:58:48 <Procian> eXeC64: It looks nice with applicative code.
06:59:09 <Procian> You write stuff like: f <$> x <*> y
06:59:35 <luite> sbidin: the unsafe comparisons come from comparing things that are not really pointers, but are represented by pointers in the runtime
06:59:37 <eXeC64> Procian: Huh, how does that associate?
06:59:45 <eXeC64> (f <$> x) <*> y?
07:00:00 <Procian> Yeah. Otherwise it wouldn't type.
07:00:59 <Procian> (You want f:a -> b -> c and x:F a and y:F b)
07:01:15 <SvenskFisk> Can anyone point me in the right direction for how to write a function that can do something like this : group 3 [1,2,3,4,5] = [[1,2,3][2,3,4][3,4,5]]? I can think of how to do it with a for loop, but I'm trying to avoid that
07:01:33 <eXeC64> Yeah, figuring it out from the types. You apply f over x, and then apply x to y.
07:02:03 <eXeC64> Does <*> allow its arguments to be reversed then?
07:02:36 <Procian> @type (<*>)
07:02:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:02:38 <eXeC64> Otherwise x needs to be a wrapped function
07:03:03 <Procian> > (,) <$> Just 1 <*> Just 2
07:03:05 <lambdabot>  Just (1,2)
07:03:38 <eXeC64> Okay, that hurts my head. Going to have to think about that
07:05:25 <byorgey> SvenskFisk: you might be interested in functions such as  tails, map, and take
07:05:37 <byorgey> > tails [1..5]
07:05:39 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
07:06:34 <jkarni1> SvenskFisk: you want to *drop* n, and then *take* 3, from the list
07:07:10 <jkarni1> SvenskFisk: where n is going to be a number from 0 to the length of the list minus 3
07:07:58 <jkarni1> SvenskFisk: so *map* that function (that does the taking and droping) over [1..length - 3]
07:08:23 <jkarni1> SvenskFisk: where I've used "*" to indicate function names you'll probably want to use
07:09:14 <jkarni1> SvenskFisk: alternatively, as byorgey suggested, *tails* could be used instead of drop - try both!
07:09:15 <flyingfisch> hmm, don't get this: bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)
07:09:35 <flyingfisch> how can (fx,fs) equal a function?
07:10:12 <benzrf> flyingfisch: it doesnt
07:10:19 <benzrf> flyingfisch: the parameters are flipped
07:10:29 <flyingfisch> hmm, I must not understand something
07:10:31 <benzrf> f' is the kleisli arrow here
07:10:36 <benzrf> :t flip (>>=)
07:10:37 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:10:48 <flyingfisch> let a = 5 in a + 1
07:11:05 <benzrf> > let a = 5 in a + 1
07:11:06 <lambdabot>  6
07:11:52 <flyingfisch> i don't get it...
07:12:07 <flyingfisch> how does this even work? let (fx,fs) = f' gx
07:12:49 <flyingfisch> ooooooh
07:12:52 <flyingfisch> wait
07:12:54 <flyingfisch> duh
07:13:34 <flyingfisch> i forgot that (fx,fs) does not equal f' gx, it equals the result of f' gx
07:13:38 <flyingfisch> right?
07:13:56 <flyingfisch> so f' gx returns (Float, String)
07:14:05 <flyingfisch> ok
07:14:07 <flyingfisch> now I get it
07:15:14 <benzrf> flyingfisch: hehe
07:18:08 <juri_> wow. even i understood that. ;)
07:18:50 <sbidin> luite: Thanks!
07:19:47 * hackagebot reroute 0.2.2.1 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.2.1 (AlexanderThiemann)
07:24:48 * hackagebot Spock 0.7.5.1 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.5.1 (AlexanderThiemann)
07:42:34 <moop> \o/
07:42:37 <moop> success
07:43:18 <bergey> What's the recommended way to read & modify .cabal files from Haskell code?  Is there anything more convenient than the Cabal package?
07:53:15 <bitonic> bergey: what do you need to do?  the `PackageDescription' modules in the `Cabal' package seem quite neat
07:53:40 <bitonic> in any case, I've never heard of a third-party library to manipulate cabal files
07:53:54 <chrisdone> reading cabal files is reliable
07:54:12 <chrisdone> modifying them automatically, you're likely to mess it up
07:54:25 <hiptobecubic> cabal syntax and error messages could certainly be better.
07:54:34 <bergey> bitonic: OK, that's helpful.  I just need to read & increment version numbers & package upper bounds.
07:55:01 <bitonic> bergey: I see.  have you tried <http://hackage.haskell.org/package/Cabal-1.20.0.2/docs/Distribution-PackageDescription-PrettyPrint.html>?
07:55:04 <bergey> chrisdone: And here I was reading the haskell-mode code to see what it does....
07:55:43 <bergey> bitonic: Thanks.
07:55:51 <chrisdone> it does a bunch of regexes and sacrifices some lambs
07:56:31 <bitonic> bergey: presumably that throws away all structure in the original cabal file.  which might be annoying :P
07:56:45 <bitonic> but if you're OK with working with files generated by that pretty-printing, it might work for you
07:56:47 <flyingfisch> is monad pronounced with a long or short o?
07:57:04 <shapr> moe-nad
07:57:10 <chrisdone> depends where you're from
07:57:19 <bergey> Fair enough.  I'm hoping to keep all my lambs, though. =)
07:57:20 <shapr> chrisdone: What's the Italian way to say it?
07:57:27 <bitonic> shapr: monade
07:57:32 <chrisdone> shapr: monad =p
07:57:34 <bitonic> don't know how to write that phonetically
07:57:49 <bitonic> chrisdone: monade!
07:57:51 <chrisdone> shapr: but you have to add a vague vowel at the end
07:58:01 <shapr> heh, I gotta hear this sometime
07:58:09 <bitonic> programmazione funzionale tipata
07:58:19 <chrisdone> “in askell they avuh the monaduh”
07:58:53 <bitonic> well but the fun part is that the cat. theory terms have all been translated right :P
07:59:00 <bitonic> certainly monad has
07:59:26 <shapr> chrisdone: ha, I like it!
07:59:56 <chrisdone> shapr: and php is pee-acka-pee =p
08:00:04 <shapr> huh, wild
08:00:26 <chrisdone> that's just how italians say 'h'. but it sounds funny to hear it
08:00:28 <shapr> pay hå pay in Swedish
08:00:36 <bitonic> italians don't say leading hs
08:00:50 <bitonic> italians have a complicated relationship with h
08:01:02 <bergmark> shapr: monader! monader!
08:01:06 <chrisdone> bitonic: my favourite is when italians *add* an h where there isn't one
08:01:48 <hiptobecubic> chrisdone, spanish also :)
08:01:51 <bitonic> we're irredeemable creatives
08:02:03 <exio4> I can add "h"s everywhere! (it is silent in spanish :P)
08:02:16 <hiptobecubic> exio4, which makes it even more confusing
08:02:21 <xea> i'm not sure what we're talking about but i love when spanish people add an extra 'e' in front of leading 's'
08:02:25 <hiptobecubic> maybe it's a 'j' :)
08:02:38 <xea> also hi
08:02:58 <hiptobecubic> "j'ok so.... vamanos?"
08:03:01 <sinelaw> in russia, they replace an "h" with a "g"
08:03:06 <sinelaw> just as confusing.
08:03:13 <HeladoDeBrownie> xea, in Spanish there's a phonetic rule forbidding a word from beginning with s and most other consonants
08:03:23 <xea> of course there is but it's still funny
08:03:28 <chrisdone> shapr: nice =)
08:03:48 <hiptobecubic> That seems like a pretty funny workaround
08:03:49 <exio4> if english was kinda regular in the pronunciation... duh :P
08:04:03 <hiptobecubic> "super" isn't allowed so we'll just add some vowels
08:04:03 <xea> we still laugh at poor japanese for their engrish though they've got their phonetic rules too
08:04:25 <xea> ekuseru shiito
08:04:26 <chrisdone> shapr: nothing yet beats portugese, ping pong → "pingy pongy"
08:04:37 <xea> (excel sheet)
08:04:42 <HeladoDeBrownie> Also the h in Haskell gets pronounced, but as Spanish j, the closest equivalent
08:04:56 <sinelaw> I wonder if in Russian it's Xaskell or Gaskell
08:04:58 <exio4> er, what rule? s + consonant isn't allowed, I think
08:05:11 <sinelaw> any russians around?
08:05:17 <exio4> HeladoDeBrownie, from where are you from, btw? :P
08:05:19 <HeladoDeBrownie> exio4, that's basically it
08:05:20 <chrisdone> there are always russians around. waiting
08:05:27 <sinelaw> lurking, rather
08:05:30 <hiptobecubic> xea, nice phonetic spelling. That sounded pretty good when I shouted it at my screen
08:05:31 <HeladoDeBrownie> exio4, Maryland :P
08:05:34 <xea> ハスケル　(hasukeru)
08:05:36 <chrisdone> watching
08:05:47 <ij> I was just thinking. All the method hierarchy structure of OOP and calling thing can be easily created in haskell(not speaking about mutation), it's just that no one does it, because it's a silly idea?
08:05:56 <xea> hiptobecubic: :D
08:06:08 <sinelaw> ij, a matter of opinion, but yes
08:06:18 <chrisdone> ij: i dunno about silly, just not necessary
08:06:18 <bitonic> ij: it's also more awkward to do -- OOP languages facilitate it
08:06:24 <sinelaw> ij, there are abstractions more natural to haskell programming
08:06:26 <ij> chrisdone, yeah, more like that
08:06:47 <chrisdone> OO languages but everything in objects
08:06:52 <chrisdone> functional languages but everything in modules
08:06:56 <sinelaw> put
08:07:02 <sinelaw> or butt
08:07:06 <ij> It took me quite a while to formulate and ask this question.
08:07:14 <benzrf> in practice in haskell there's little advantage to storing state and behavior side by side in a structure
08:07:15 <hiptobecubic> xea, I was shocked to discover that there's a japanese word for "text decoded with the incorrect codepage."
08:07:22 <chrisdone> sinelaw: butt, i think
08:07:28 <benzrf> usually it works better to have a closure of some sort or a state actionn
08:07:29 <hiptobecubic> I suppose necessity is the mother of invention :)
08:07:44 <xea> hiptobecubic: omaigoddo, what is that word?
08:08:35 <hiptobecubic> xea, 文字化け (Mojigake)
08:08:54 <hiptobecubic> google translates it as "garbled characters"
08:09:01 <xea> haha, awesome!
08:09:10 <sinelaw> heh
08:09:12 <sinelaw> confusing.
08:10:11 <chrisdone> i like it when one language has a single word for something another language doesn't
08:10:22 <chrisdone> makes for funny perspective differences
08:10:34 * bitonic likes schadenfreude
08:10:42 <hiptobecubic> bitonic, yes i'm pretty sure that wins
08:10:51 * xea likes hygge
08:10:55 <chrisdone> bitonic: i like 'toe' =p
08:11:03 <hiptobecubic> dutch has 'gezellig' and 'lekker'
08:11:29 <bitonic> chrisdone: we have that in Italian
08:11:47 <bitonic> ah no.  we don't.
08:11:51 <ij> Is lekker really considered to be untranslatable? I think the approximations are pretty good.
08:12:00 <bitonic> toe is "foot digit" rigth?  I was thinking of big digits.
08:12:05 <chrisdone> bitonic: dito del piede =p
08:12:09 <bitonic> right
08:12:12 <hiptobecubic> well the german version is only about food, really
08:12:19 <chrisdone> bitonic: but, you have ditone
08:12:28 <chrisdone> which we call "big toe"
08:12:30 <bitonic> chrisdone: and alluce/pollice
08:12:36 <bitonic> ditone is quite vague
08:12:42 <hiptobecubic> but in dutch it's used all over the place in ways that apparently make germans think is gross or inappropriate
08:12:52 <chrisdone> right
08:12:53 <hiptobecubic> according to my german exroommate
08:13:11 <chrisdone> bitonic: it always makes me giggle when an italian says talks about their fingers on their feet. i imagine the most amusing visuals
08:13:53 <hiptobecubic> when I was learning french i could never remember how to say toe so i'd always just say "foot fingers"
08:13:54 <bitonic> I clearly talk about toes less than you do
08:13:57 <xea> i'm also amused by how languages have different ways of expressing a 'runny nose'
08:14:14 <bitonic> anyway.  I'm starting to think this is not that relevant to Haskell :P
08:14:42 <chrisdone> xea: good point. even the phrase "runny nose" is totally odd. the nose is running, where?
08:14:43 <sinelaw> you mean Jaskell
08:14:54 <xea> yes
08:15:01 <bitonic> I mean 'askell
08:15:18 <xea> in hungarian we say 'my nose is flowing' what sounds also stupid
08:15:49 <chrisdone> xea: that's not too bad. you could say that in english, although it'd mean a lot was coming out…
08:15:58 <hiptobecubic> that makes me think of blood
08:16:21 <sinelaw> haskell-blah?
08:16:26 <hiptobecubic> chrisdone, i think 'runny' is by analogy with running faucet/water... which also is pretty figurative
08:16:33 <hiptobecubic> Also monads.
08:16:37 <chrisdone> sinelaw: do you have a haskell question?
08:16:52 <sinelaw> not at the moment, but I will.
08:17:01 <sinelaw> eventually
08:17:14 <chrisdone> sinelaw: so we better stop having fun in case you think of a haskell topic, i see ;)
08:17:22 <xea> oh, haskell, i almost forgot why i joined.
08:17:30 <sinelaw> chrisdone, not at all
08:18:11 <bitonic> in Italian we kinda say "your mucus'ing"
08:18:17 <bitonic> *you're
08:18:26 <bitonic> very precise
08:18:41 <sinelaw> is there a word for having a runny nose?
08:18:52 <sinelaw> I (have a runny nose)?
08:19:09 <bitonic> "sto smocciolando" lol
08:19:22 <chrisdone> not that i can think of
08:19:29 <chrisdone> similar: "falling asleep". that's a real weird one
08:19:40 <bitonic> chrisdone: "addormentarsi"
08:19:45 <chrisdone> i don't know of an actual verb in english for 'to fall asleep', other than that weird phrase
08:19:47 <bitonic> Italian's got you covered
08:20:11 <wei2912> how do i write a parser in parsec that consumes all input till it reaches a certain character, then consumes that character?
08:20:12 <HeladoDeBrownie> chrisdone, "crash" is colloquially used for "go to sleep" sometimes
08:20:21 <hiptobecubic> pass out also
08:20:21 <chrisdone> HeladoDeBrownie: true
08:20:22 <HeladoDeBrownie> @type manyUntil
08:20:23 <lambdabot> Not in scope: ‘manyUntil’
08:20:31 <chrisdone> :t manyTill
08:20:32 <lambdabot> Not in scope: ‘manyTill’
08:20:39 <chrisdone> :t Text.Parsec.manyTill
08:20:41 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m end -> Text.Parsec.Prim.ParsecT s u m [a]
08:20:48 <HeladoDeBrownie> wei2912, http://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec-Combinator.html#v:manyTill
08:21:05 <sinelaw> Hebrew is also quite dense. a single word often expands to 5 English words.
08:21:13 <chrisdone> bitonic: what tense is that in?
08:21:15 <bitonic> well, wei2912 wants `manyTill >> anyChar'
08:21:33 <HeladoDeBrownie> Not anyChar, but rather char something I guess
08:21:35 <wei2912> HeladoDeBrownie: thanks!
08:21:41 <wei2912> and yes, anyChar is what i want
08:21:50 <HeladoDeBrownie> Okay, cool
08:22:00 <chrisdone> bitonic: i don't know how to convert that to 'i fell asleep', 'i'm falling asleep', 'i/you will fall asleep', 'don't fall asleep' etc.
08:22:14 <sinelaw> chrisdone, the real reason to move to haskell-blah is that my chatbot learns from conversations there
08:22:25 <hiptobecubic> Dutch is pretty cute, I have to say.  "Ik heb een loopneus"
08:22:46 <bitonic> chrisdone: "mi sono addormentato" "mi sto addormentando" "mi addormenterò".  the infinitive is "addormentare"
08:22:55 <xivix> how can I immediately treat the result of input <- getLine as an Int, rather than doing ((read input) :: Int) when I want to use it
08:22:57 <HeladoDeBrownie> Seconding the request to move to -blah. That's what it's for
08:23:02 <bitonic> and embarassingly I have no idea what the "noun" form is called
08:23:09 <bitonic> xivix: read <$> getLine
08:23:28 <bitonic> xivix: if you need the annotation, `n :: Int <- read <$> getLine'
08:24:01 <chrisdone> bitonic: ahh. the verb is addormentare. that's easy then, i thought it was some combo
08:24:01 <xivix> bitonic, does the annotation need to be on that line, or can it infer what n should be when it's used on a later line?
08:24:21 <bitonic> xivix: yes, if you use `n' later it will use that information to infer what `read' should do.
08:24:34 <xivix> bitonic, thanks a lot!
08:24:36 <chrisdone> bitonic: i guess that actually is similar to 'a-sleep' 'ad-dormire'
08:24:55 <bitonic> chrisdone: it's exactly that
08:25:04 <bitonic> xivix: you're welcome :)
08:25:20 <xivix> bitonic, what module is <$> in?
08:25:26 <bitonic> xivix: Data.Functor
08:25:26 <HeladoDeBrownie> Control.Applicative
08:25:29 <HeladoDeBrownie> Oh, woops
08:25:30 <bitonic> it's an infix `fmap'
08:25:36 <HeladoDeBrownie> I always import it from there XD
08:25:37 <bitonic> HeladoDeBrownie: it's there too :)
08:25:41 <hiptobecubic> it's also in applicative
08:25:46 <HeladoDeBrownie> Well now I know
08:25:57 <sinelaw> chrisdone, the real reason to move to haskell-blah is that my chatbot learns from conversations there
08:26:03 <sinelaw> oops. wrong buffer!
08:27:16 <wei2912> in parsec, is there some sort of "not"?
08:27:27 <HeladoDeBrownie> notFollowedBy
08:27:29 <HeladoDeBrownie> same page as I linked
08:27:32 <wei2912> alright, thanks
08:27:33 <bitonic> wei2912: `satisfy ...'
08:27:37 <chrisdone> bitonic: either that or it is "to become mint" =p
08:27:56 <HeladoDeBrownie> Presumably, the reason it's not just called not is because there's already a not in the Prelude
08:29:33 <bitonic> chrisdone: eheh
08:29:33 <ski> exio4 : `forall a b. a -> (m b)' looks pretty useless to me
08:29:50 <exio4> ski, it is, that is why I said "something like" :P
08:29:59 <exio4> if you mean what I posted a few hours ago
08:30:41 <ski> gp5st : yes, but i was using the labelled version to determine the roles of `a' and `b' in `gr a b'
08:30:47 <ski> yes
08:30:59 <ski> exio4 : so, i'm curious about what you intended
08:31:04 <chrisdone> bitonic: i have a friend called paolo who also tries to make puns in english, i call him punlo =p
08:31:25 <exio4> ski, making a monoid with (>=>) and return
08:31:47 <gp5st> ski: I still don't understand the error message though :-\
08:32:05 <chrisdone> ski: i could maybe imagine such a type in the presence of continuations
08:32:28 <ski> exio4 : wouldn't you then want something like `instance Monad m => Monoid (a -> m a)' (or `instance Monad m => Monoid (Kleisli m a a)' or `instance Monad m => Category (Kleisli m)') ?
08:32:30 <chrisdone> continuations tend to make types like that where type variables don't go anywhere and other ones appear magically
08:32:50 <ski> chrisdone : you could only pass `undefined :: a' as input, no ?
08:33:17 <exio4> ski, a -> m a works, but something like (a -> m b) >=> (b -> m c) with b /= a, wouldn't compile
08:33:23 * ski thinks chrisdone is probably thinking about stuff like `callCC :: MonadCont o m => ((forall b. a -> m b) -> m a) -> m a'
08:33:32 <chrisdone> ski: exactly =p
08:33:49 <ski> gp5st : sorry, i missed the error message ?
08:34:09 <chrisdone> not exactly the same, but such types are magic to behold for the first time
08:34:13 <gp5st> ski np:) http://dpaste.com/3BXNEA0
08:34:19 <ski> chrisdone : .. or rather, turning continuations into functions tend to do that :)
08:34:46 <ski> (converting `not A' into `forall B. not (A /\ not B)')
08:35:29 <ski> gp5st : also, i can't stay very long atm. just so you know
08:35:32 <gp5st> ski: yeah, I think the recursive method is very clean
08:35:45 <gp5st> ski: np:) I very much appreciate the help
08:35:57 <benzrf> exio4: you want category i'm sure
08:36:11 <benzrf> exio4: unless you WANT to be restricted to Endo
08:36:30 <ski> gp5st : try adding `{-# LANGUAGE NoMonomorphismRestriction #-}' to the top of your file
08:36:34 * ski suspects the DMR
08:36:35 <exio4> yeah, that was the idea :P
08:37:28 <chrisdone> :t const Nothing :: a -> Maybe b
08:37:29 <lambdabot> a -> Maybe b
08:37:32 <ski> gp5st : alternatively, add a type signature for `graph'
08:37:36 <chrisdone> there's such a one
08:37:39 <ski> (and maybe also for `base_weight' ?)
08:37:48 <gp5st> ski: I thought I did that in cumulativeWeight
08:38:28 * ski would also align the `,'s inbetween the `[' and the `]' .. :)
08:39:39 <ski> gp5st : you also need to say somewhere which graph implementation you're using
08:40:01 <ski> gp5st : possibly this is <http://hackage.haskell.org/package/fgl-5.5.0.1/docs/Data-Graph-Inductive-PatriciaTree.html#t:Gr>
08:40:08 <gp5st> ski: I thought that was inherent in the import
08:40:50 <gp5st> how would I tell it my graphs are of a certain type? :-\ sorry
08:40:52 <bitonic> chrisdone: my dad's called Paolo and makes puns.  doesn't speak English though :P
08:41:08 <ski> gp5st : either where you call `cumulativeWeight', or where you call `mkUGraph' (possibly by adding a restricted type synonym on `graph')
08:41:22 <chrisdone> bitonic: haha xD
08:42:01 <ski> gp5st : i think this library allows multiple implementations of the `Graph' type class ("interface"), and most operations will work with any such implementation. and `Gr' above is one example of such an implementation (perhaps the default or currently only given one ?)
08:42:43 <ski> gp5st : if you wanted `cumulativeWeight' to only work on `Gr'-graphs, you could remove `Graph gr => ' from the signature, and replace `gr' by `Gr'
08:43:15 <gp5st> ski: I want it to work with any type, since they should all conform?
08:44:17 <ski> gp5st : or, instead of adding the type signature `graph :: Graph gr => gr () ()', you could add `graph :: Gr () ()'. or you could say `graph = mkUGraph nodes edges :: Gr () ()'. or you could say `print $ cumulativeWeight base_weight (graph :: Gr () ()) 4 4'
08:44:30 <ski> gp5st : all depending on at which exact point you want to fix the implementation
08:44:40 <wei2912> hmm
08:44:55 <wei2912> in my code, i have `manyTill anyChar (try $ char '<')`. however, it appears that the parser isn't backtracking before the <
08:45:03 <ski> (adding a type signature on `graph' respectively adding a type ascription to the body of `graph' does the same thing. it's just two different ways to express it)
08:45:10 <wei2912> how could i fix this?
08:45:20 <gp5st> i'm still not clear on why I have to cast the output of mkugraph, should that be defined by whichever graph type is being used?
08:45:47 <ski> first, it's not a cast, it's a (type) ascription
08:45:57 <ski> it doesn't change the type, it just pins it down more
08:46:20 <gp5st> ski: but if mkugraph were returning a patricia tree graph, wouldn't that cause an issue?
08:46:20 <ski> (resolving some ambiguity, which in some situations would be harmless or even desirable)
08:46:56 <ski> "should that be defined by whichever graph type is being used?" -- you should specify the actual graph implementation type you want to use, yes
08:47:07 <ski> gp5st : what kind of issue are you thinking about ?
08:47:24 <ski> gp5st : also, i'm not sure what you mean by "I want it to work with any type, since they should all conform?"
08:47:39 <gp5st> ski if I call it a Gr type and it's a patricia tree type isn't that an issue
08:48:00 <bitonic> wei2912: I don't understand the backtracking bit.  what's the behaviour you expect, and what are you getting?
08:48:04 <bitonic> btw, you don't need the `try' there
08:48:21 <gp5st> I guess I'm still not clear on where mkugraph is coming from, though, if it's just the only available one, why is there ambiquity?
08:48:27 <bitonic> because `char '<'' either suceeds or fails without consuming input
08:48:30 <ski> `Gr' is a specific implementation type. it's docs claim that it is "An efficient implementation of Graph using big-endian patricia tree (i.e. Data.IntMap)."
08:48:32 <gp5st> sorry, I'm probably overthinking this
08:49:19 <wei2912> bitonic: hmm.
08:49:29 <ski> gp5st : `mkUGraph' is polymorphic in the implementation type `gr', it will work for any such type that (correctly) is made an instance of the type class `Graph'
08:50:03 <gp5st> so by going :: Gr I'm essentially telling it which mkugraph to use?
08:50:06 <bitonic> wei2912: that expression you pasted will consume all the input up to `<', the consume `<', and return the consumed input (but not '<').
08:50:31 <ski> gp5st : someone (e.g. you) could add more (alternative) implementation types, making them instances of `Graph'. it is desirable for much code to still work on such (possibly future) alternative implementations/representations
08:50:36 <ski> gp5st : yes
08:50:49 <wei2912> bitonic: yeh, i'd like it to not consume '<' at the end
08:51:05 <bitonic> wei2912: use `lookAhead'
08:51:06 <gp5st> ski: this all makes much more sense
08:51:23 <wei2912> bitonic: thanks
08:51:28 <bitonic> wei2912: `manyTill anyChar (lookAhead (char '<'))'
08:51:35 <ski> gp5st : you're telling it which implementation of all the methods in the type class `Graph' to use (and, implicitly, which implementation all the other operations which have a `Graph gr' constraint should use, since those probably calls (directly or indirectly) the methods of the class)
08:51:55 <gp5st> I see
08:52:13 <ski> hth
08:53:07 <ski> gp5st : elaborate on the "I want it to work with any type, since they should all conform?" ?
08:54:12 <gp5st> ski: I didn't want to pin down which graph types I accepted in my function since all graph types should [be of the same type class?] and as such implement the same interface/contract/methods so I shouldn't care about the underlying implementations
08:54:29 <ski> yes, that's usually a good idea
08:54:42 <ski> but you have to specify *somewhere* which implementation to actually use
08:54:48 <wei2912> bitonic: how do i check if a character is something without consuming it?
08:55:23 <bitonic> wei2912: (char 'x' *> doSomething) <|> doSomethingElse
08:55:23 <ski> often, it's best to delay this decision as long as possible (until you know for sure. i don't think there's any point in delaying it after defining `graph' in `main', in this case)
08:55:35 <wei2912> right
08:55:40 <wei2912> i've forgotten how to use parsec :<
08:55:46 <wei2912> thanks bitonic
08:56:14 <xplat> bitonic: aren't you missing a 'try' or something?
08:56:18 <ski> in a language with an ML-like module system, the "main" program would probably consist of an (ML-) functor application, applying an-implementation-agnostic module "functor" to the chosen implementation module
08:56:27 <gp5st> ski: you mean the compiler can't do _everything_ for me? :-o :-p
08:56:38 * ski grins
08:56:47 <bitonic> xplat: if `char 'x'' fails, the char won't be consumed in `doSomethingElse', which I think is what wei2912 meant
08:56:53 <ski> gp5st : any last questions or comments, before i go ?
08:57:09 <bitonic> wei2912: if you don't want to have the char consumed in `doSomething', then you should use `lookAhead' in the left branch :)
08:57:10 <gp5st> ski: no, but thank you very much
08:57:25 <ski> yw
08:57:37 <wei2912> bitonic: hmm, i think i'm having a big problem here... wait a moment
08:57:40 <bitonic> wei2912: but that's not very idiomatic `parsec' usage, and I'd think about what I'm doing if I were you
08:58:03 <wei2912> true.
08:58:14 <xplat> bitonic: oh, so you would only need 'try' if you were looking for like 'xy' or something
08:59:00 <bitonic> xplat: right.  if you're consuming multiple tokens, yuo need try
08:59:12 <bitonic> which is why you should really lex first, in my opinion
08:59:27 <bitonic> or use that `lexeme' combinator, but that's uglier, I think.
08:59:35 <bitonic> then again I don't really like parsec :P
08:59:48 <bitonic> I prefer writing some grammar and getting a parser
08:59:58 <wei2912> basically, i need to parse something repeatedly till i hit '/' or '$'
09:00:50 <wei2912> i can just use `many`, but the problem is that i need to check if i hit '/' or '$', since the parser that i'm using will consume both
09:01:05 <wei2912> wait, nvm
09:01:16 <bitonic> wei2912: right.  there should be a combinator for that, I think
09:01:29 <bitonic> but I can see why you were tempted by `lookAhead'
09:01:40 <wei2912> bitonic: my problem was non-existant, since there're indications to where the stuff starts and ends
09:01:52 <xivix> is it more idiomatic to use [] or "" when dealing with String?
09:01:56 <wei2912> ""
09:01:58 <xivix> for pattern matching and stuff
09:01:59 <xivix> ok thanks
09:02:29 <xivix> "" is equivalent to ([] :: String) right?
09:02:40 <bitonic> xivix: debatable.  use what make sense there
09:02:50 <bitonic> if you're treating it as a list of chars [] makes more sense, I think
09:03:27 <wei2912> ^^
09:06:47 <lpaste> mbuf pasted “Example for before HSpec” at http://lpaste.net/115582
09:07:12 <mbuf> how do I test the 'before' function in Hspec
09:07:32 <xivix> what's the idiomatic way to name the variables in pattern-matched a@(b:c)
09:07:45 <xivix> x@(x0:xs)?
09:07:54 <kadoban> xss@(x:xs)
09:08:42 <Gurkenglas> Huh, I thought xss is for [[a]]
09:08:47 <bitonic> xivix: again, it depends.  in many situations I'd steer clear of one-variable names
09:09:00 <bitonic> xivix: I wouldn't say there is a general rule for the case you're saying
09:09:04 <Gurkenglas> one-character, you mean?
09:09:25 <bitonic> yes, one-character
09:09:46 <diprosopus> hmm. would haskell be good at cracking crypto?
09:09:51 <wei2912> okay... so now, i've come up with code that handles the first 2 cases in http://pastebin.com/ardYdV0A
09:10:02 <diprosopus> I wonder. Gonna write a few tools to see if I can crack subsitution ciphers
09:10:03 <wei2912> however, now i need to find out how to handle escapes
09:10:16 <diprosopus> and then more complex stuff :D
09:10:43 <bitonic> wei2912: gotta go, good luck!
09:10:46 <StoneCypher> diprosopus:  if you're asking that question, the problem will not be the language
09:10:59 <wei2912> bitonic: thanks
09:11:01 <wei2912> ;)
09:11:49 <knyon> What's the idea for getting multiple parts of a data type at once using Lenses? For example, can I make a Lens to get the 1st, 3rd, and 5th element of a 5-tuple and return a 3-tuple?
09:12:54 <simpson> knyon: Sure.
09:13:51 <glguy> knyon: What's currently missing is a combinator for building that 1/3/5 lens out of _1 _3 and _5
09:14:12 <simpson> knyon: Your general approach would be to find a lens of the form `(s -> f t) -> a -> f b`, where f is at least a Functor (up to Applicative), s and t are your "inner" values, and a and b are the "outer" values.
09:14:28 <wei2912> i'll start off with the simpler part first
09:14:44 <wei2912> when i see '*' in the input, i need to consume the rest of the input and return a blank string
09:14:49 <wei2912> otherwise, i consume the rest of the input
09:14:52 <wei2912> err, wait, nvm
09:14:55 <simpson> So you'd look for ((a, b, c) -> f (a', b', c')) -> (a, d, b, e, c) -> f (a', d, b', e, c')
09:15:06 <simpson> Which, as glguy points out, would be a lot easier with some combinators.
09:15:14 <knyon> hm, right
09:15:25 <glguy> :t (\f (a,b,c,d,e) -> fmap (\(a',c',e') -> (a',b,c',d,e')) (f (a,c,e))) :: Lens (a,b,c,d,e) (a',b,c',d,e') (a,c,e) (a',c',e')
09:15:27 <lambdabot> Functor f => ((a, c, e) -> f (a', c', e')) -> (a, b, c, d, e) -> f (a', b, c', d, e')
09:16:11 <simpson> glguy: Your typing skills are impressive. I was only halfway there. :3
09:17:10 <knyon> ok, interesting. I haven't delved into any of ways to create lenses that weren't "out of the box" or with template haskell
09:18:48 <natschil> Hi, I can't seem to find the term used to describe instances of parametrized types as opposed to base types (i.e. I'm looking for the word $foo, where Maybe a and List a are of $foo, but Int is not).... is there a good glossary of such terms anywhere?
09:19:09 <natschil> sorry, that description was bad. I mean that Maybe Int and List Int would be of $foo
09:19:18 <knyon> of course, what I actually need this for is not tuple manipulation, but for getting out multiple pieces of a product type of newtypes... so this might be a bit more complicated
09:19:52 * hackagebot messagepack 0.3.0 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.3.0 (rodrigosetti)
09:20:01 <simpson> knyon: I've written custom lenses like that. You merely need to line up the types in the right order and then incant <*> repeatedly.
09:20:39 <wei2912> 01:17 < wei2912> if i see '*', consume the rest of the input but return "". if i don't see '*', return the rest of the input
09:20:42 <wei2912> 01:17 < wei2912> how do i do this?
09:20:49 <wei2912> i decided that i couldn't do it
09:20:53 <wei2912> (in Parsec, btw)
09:21:36 <knyon> simpson: yeah, that was my gut instinct. I was curious if it was possible to compose lenses (or even use Folds?) to do that all for me.
09:23:32 <slomo> wei2912: that should be possible, but probably not by staying in Applicative... that probably needs the Monad instance of the parser
09:24:08 <simpson> knyon: It should be possible, but the laws haven't been worked out. #haskell-lens might be a better channel.
09:25:10 <knyon> simpson: good to know. thanks for your help!
09:27:47 <nille> is there a shorter way to write concat $ zipWith (\a -> \b -> [a,b]) "foo" "bar"?
09:28:25 <nille> err, \a b ->
09:28:42 <indiagreen> > concat $ transpose ["foo", "bar"]
09:28:44 <lambdabot>  "fboaor"
09:29:41 <nille> indiagreen: thanks :)
09:30:28 <wei2912> how do i write a version of `anyChar` for a string of characters that allow escaped characters?
09:31:03 <johnw> you can use "satisfy" as a more basic primitive
09:31:57 <indiagreen> wei2912: do you mean something like “(string "\\n" *> pure '\n') <|> ... <|> anyChar”?
09:32:15 <wei2912> indiagreen: something like that, wait a moment.
09:32:16 <Gurkenglas> Who here is proficient with fpcomplete?
09:32:59 <indiagreen> (you'll also need “try”, or to make a separate parser for escaped chars if you have several)
09:34:42 <wei2912> indiagreen: johnw i think i got something working: http://lpaste.net/115583
09:35:21 <wei2912> i made a mistake there, wait a moment
09:36:01 <wei2912> johnw: indiagreen i need to fail if the character is a symbol
09:36:09 <wei2912> should i use `fail` for this purpose?
09:36:26 <johnw> or the value "mzero"
09:37:21 <wei2912> johnw: sorry, i'm unfamiliar with MonadPlus
09:37:33 <wei2912> how'd i get that working?
09:37:55 <johnw> instead of "return foo" just say "mzero"
09:38:15 <wei2912> johnw: wouldn't i need to import something?
09:38:21 <johnw> maybe Control.Monad
09:38:24 <wei2912> ah, okay
09:41:15 <phaazon> hey, what’s the less constrainted extension for introducing existential along with ConstraintKinds?
09:41:18 <phaazon> like
09:41:33 <phaazon> type AnyReader m = forall r. (MonadReader r m)
09:42:13 <Gurkenglas> What's the conceptual difference between (Monoid a, Monad a) and (MonadPlus a)?
09:42:33 <johnw> MonadPlus has a different kind than Monoid
09:42:49 <Gurkenglas> Oh right.
09:42:57 <phaazon> I thought it’d have been ExistentialQuantification
09:43:18 <Gurkenglas> Surely there's gotta be another way to express that than introducing another typeclass...
09:43:34 <Gurkenglas> (Monoid m a, Monad m)?
09:43:41 <chrisdone> phaazon: RankNTypes?
09:43:48 <johnw> Gurkenglas: try it :)
09:44:47 <phaazon> chrisdone: yeah it’s that, but why?
09:44:53 * hackagebot atto-lisp 0.2.2 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.2.2 (ThomasSchilling)
09:45:18 <chrisdone> phaazon: your example isn't an existential
09:45:34 <phaazon> existential is for types only I guess?
09:45:46 <johnw> an existential would be if you had used a data wrapper
09:45:58 <phaazon> yeah I know
09:46:05 <wei2912> is there a haskell equivalent of `enumerate` in python?
09:46:05 <phaazon> I thought it could also be applied to constraints
09:46:13 <phaazon> wei2912: Enum?
09:46:21 <wei2912> [a, b, c] -> [(0, a), (1, b), (2, c)]
09:46:43 <simpson> > zip [0,1..] [a, b, c]
09:46:45 <lambdabot>  [(0,a),(1,b),(2,c)]
09:46:56 <wei2912> simpson: thanks
09:47:01 <wei2912> should have thought of that :P
09:47:06 <phaazon> > zip [0..] "wat"
09:47:09 <lambdabot>  [(0,'w'),(1,'a'),(2,'t')]
09:47:14 <sbrg> I'm looking for an elegant way to get all possible replacements of zeroes in a list like [2,2, 0, 0] with some number, say 4. So I'd want [2, 2, 4, 0] and [2, 2, 0, 4] but not [2, 2, 4, 4]. The latter is pretty easy using the list monad and an if expressoin, but I'm not sure about the first.
09:47:35 <Gurkenglas> Ah, (Monoid (m a), Monad m) is probably not enough because you want to say that (m a) is a Monoid for all a, not only the as you're using
09:49:39 <urtixyz> hello, I've just started learing Haskell, and I'm stuck at generating all possible dice pairs
09:49:55 <sbrg> urtixyz: Take a look at list comprehensions
09:49:57 <wei2912> urtixyz: want hits or a direct answer?
09:50:02 <urtixyz> and by 'started Haskell' I mean fiddling around that tryhaskell.org
09:50:06 <urtixyz> I'd prefer hints
09:50:18 <johnw> urtixyz:  Welcome to Haskell :-)
09:50:25 <urtixyz> thanks!
09:50:42 <sbrg> urtixyz: List comprehensions are probably the simplest way to do this and are really intuitive to understand
09:50:47 <a3gis> urtixyz: welcome! have you looked into list comprehensions already?
09:50:52 <fragamus> welcome to haskell yeah!
09:51:01 <urtixyz> okay, I'll look into it, thanks for the quick responses!
09:51:08 <mmachenry> I'm looking for a way to get time information into STM. I would like to have a record of when a particular piece of information was actually committed, just like doing now()::time in SQL. But since I can't read time in the STM, I need to read it in IO and pass it in, but an arbitrary amount of time can go by between the IO action and the commit. Is there a better way to do this?
09:51:10 <fragamus> send us your address and you get a free stripper-gram for joining
09:51:19 <sbrg> > (,) <$> [1..6] <*> [1..6]
09:51:21 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
09:51:24 <sbrg> <3 applicative
09:51:25 <urtixyz> a free what?
09:51:33 <fragamus> jk
09:51:39 <wei2912> urtixyz: after that, you'll want to concatenate the results :)
09:51:55 <fragamus> urtixyz: oh you didn't get yours
09:51:58 <wei2912> urtixyz: but don't worry about that, just show us your code first
09:52:01 <mmachenry> urtixyz: Everyone's favorite first book to recommend is Learn You a Haskell for Great Good and it's available for free on line.
09:52:14 <sbrg> @hoogle STM a -> IO a
09:52:16 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
09:52:17 <lambdabot> GHC.Conc atomically :: STM a -> IO a
09:52:17 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
09:52:17 <urtixyz> yeah, I've tried that, but I see it's mostly GHCi-oriented
09:52:24 <wei2912> > [1..6] >> [1..6]
09:52:27 <lambdabot>  [1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6]
09:52:32 <wei2912> what was i thinking
09:52:35 <urtixyz> I'm coming from a ANSI C background, so I kinda want my programs compiled
09:52:43 <mmachenry> sbrg: Is that for me?
09:52:56 <sbrg> hmm
09:52:59 <sbrg> i'm not sure
09:53:01 <sbrg> can't you lift?
09:53:11 <a3gis> urtixyz: ghci is great to fiddle around at first, then you can start writing your funciton in files and load them up in ghci to play
09:53:15 <sbrg> does stm even lift, bro?
09:53:19 <wei2912> lol
09:53:23 <johnw> urtixyz:  I'm also from a C background, so I can tell you that Haskell programs compile quite nicely
09:53:29 <mmachenry> I currently am doing do { t <- getTime; atomically (stmStuff t) }
09:53:36 <trap_exit> no, stm does not lift
09:53:44 <mmachenry> But if stmstuff retries for an hour, that time, t, is really incorrect.
09:54:15 <mmachenry> trap_exit: STM, bro, do you even liftM?
09:54:35 <wei2912> can you override an instance of Show for a `type`?
09:54:35 <sbrg> oh, yeah. I wanted the type signature other way around
09:54:39 <sbrg> @hoogle IO a -> STM a
09:54:39 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
09:54:39 <lambdabot> GHC.Conc unsafeIOToSTM :: IO a -> STM a
09:54:39 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
09:54:42 <johnw> trap_exit:  there is a package on Hackage that will give you a liftSTM function
09:54:45 <sbrg> well, that does not look okay.
09:55:03 <trap_exit> mmachenry, johnw: ah, was not aware of this :-)
09:55:22 <johnw> trap_exit: http://hackage.haskell.org/package/stm-lifted
09:55:30 <mmachenry> sbrg: Yeah, I suppose I could do unsafe stuff. :-\
09:55:40 <mmachenry> I had already though about unsafePerformIO
09:55:54 <mmachenry> I guess unsafeIOtoSTM is interesting.
09:56:11 <wei2912> > zip (replicate 6 [1..6]) ([1..6] >> [1..6])
09:56:14 <lambdabot>  [([1,2,3,4,5,6],1),([1,2,3,4,5,6],2),([1,2,3,4,5,6],3),([1,2,3,4,5,6],4),([1...
09:56:19 <wei2912> lol
09:56:27 <JagaJaga> Is there a way to do smth like `IO (IO a) -> IO a` ?
09:56:34 <exio4> join
09:56:36 <johnw> mmachenry:  if you use that function, be aware that effects can happen multiple times if the transaction is ever retried
09:56:36 <pablo|> join
09:56:49 <exio4> :t join
09:56:51 <lambdabot> Monad m => m (m a) -> m a
09:57:09 <wei2912> > zip ([1..6] >> [1..6]) ([1..6] >>= replicate 6)
09:57:11 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(1,2),(2,2),(3,2),(4,2),(5,2),(6,2),(1,...
09:57:11 <JagaJaga> oh! Forgot about that. Thanks.
09:57:32 <wei2912> here's shitty solution 3 for urtixyz
09:57:45 <wei2912> comes with monads
09:58:07 <urtixyz> I'm currently at [(i, j) | i <- [1..6], j <- [1..6]]
09:58:14 <urtixyz> which is readable, so I'm happy enough
09:58:29 <wei2912> yeh, you should go with that
09:58:29 <jkarni1> sbrg: I think something along these lines might work f (0:xs) = (1:xs):(fmap ((:) 0) (f xs))
09:58:51 <sbrg> You can't beat applicative for the dice
09:58:54 <jkarni1> sbrg: you also need the base case, and an id for when head is not 0
09:59:09 <jkarni1> sbrg: (this switches 0 to 1, not 4, of course)
09:59:12 <sbrg> > (,) <$> [1..6] <*> [1..6]
09:59:13 <wei2912> > do x <- [1..6]; y <- [1..6]; return (x, y)
09:59:14 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
09:59:15 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
09:59:17 <sbrg> jkarni1: hmm
10:00:10 <wei2912> urtixyz: future assignment for you: when you learn do notation, rewrite [(i, j) | i <- [1..6], j <- [1..6]]
10:00:10 <sbrg> jkarni1: I'll try that out -- thanks!
10:00:46 <urtixyz> wei2912: not sure I'm following
10:01:07 <wei2912> urtixyz: you shouldn't be
10:01:15 <wei2912> urtixyz: till you learn the do notation
10:01:24 <jkarni1> sbrg: the basic idea is: 'f' changes 0 once when it encounter it, and then calls itself recursively along the rest of the list without changing anything, and then concatenates the two paths
10:01:37 <urtixyz> I've thrown a do inside my main function, but that's because I'm following a bunch of tutorials at the same time
10:01:45 <urtixyz> I haven't got into theory yet
10:01:46 <jkarni1> sbrg: sorry, that explanation was more confusing than the code...
10:03:22 <wei2912> urtixyz: consider joining #haskell-beginners
10:03:41 <urtixyz> thanks for the advice!
10:04:15 <benzrf> ok so
10:04:35 <benzrf> can anybody explain to me ONCE MORE why pipes are related to the Cont monad
10:04:40 <benzrf> i-i never really grokked Cont
10:04:50 <wei2912> so here's another question: how do i manually set the line number of an error in parsec?
10:06:30 <johnw> benzrf: I can, but off-channel
10:06:35 <johnw> benzrf: #haskell-overflow?
10:12:40 <schell> what’s the library of choice for making sound in haskell (playing samples, synths, DSP)?
10:19:29 <gregnwosu> hi im trying to compile someone elses code and haskell doesnt recognise the *> operator , can anyone tell me where its from
10:19:32 <gregnwosu> is it attoparsec?
10:19:59 <kadoban> gregnwosu: Control.Applicative I believe
10:20:05 <gregnwosu> thanks
10:20:45 <indiagreen> it's from Control.Applicative
10:20:47 <indiagreen> http://hayoo.fh-wedel.de/?query=*%3E
10:21:48 <gregnwosu> ah i know of <*> but not *>
10:21:53 <gregnwosu> thansk
10:22:02 <gregnwosu> s/sk/ks
10:24:34 <sbrg> oh god, the joy of running cabal build -j on my desktop vs my laptop. eight effective cores vs 2.
10:26:02 <sbrg> @hoogle [a] -> a -> Int
10:26:03 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:26:03 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
10:26:03 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
10:28:53 <wei2912> is it possible to end a do clause?
10:29:03 <sbrg> wei2912: early exit?
10:29:13 <sbrg> like breaking out?
10:29:36 <wei2912> sbrg: no, i'm specifying some stuff in do to a function, but i need to specify some stuff after that do
10:29:53 <sbrg> I'm not sure what you mean
10:30:14 <wei2912> let's say we have a function that takes in 2 monads: f ma mb
10:30:29 <wei2912> so, `ma` is all the stuff i have in my do clause
10:30:34 <wei2912> but i need to specify `mb` too
10:30:51 <sbrg> you want to run mb after ma?
10:30:55 <wei2912> so, how do i "close" the do clause, then specify `mb`?
10:31:31 <wei2912> this is confusing, haha
10:31:39 <sbrg> maybe some code example?
10:32:45 <sbrg> sounds like you just want f ma mb = do { ma; mb } which is then equivalent to f ma mb = ma >> mb
10:33:23 <wei2912> sbrg: i figured out what i needed; wait a moment while i post the example
10:33:30 <wei2912> sbrg: http://lpaste.net/115595
10:34:09 <sbrg> wei2912: ah, I see. yes, I prefer to do that with indentatoin
10:34:39 <wei2912> sbrg: how'd you do that with indentation?
10:35:04 <sbrg> https://gist.github.com/27cbeeec7f061074519d
10:35:27 <sbrg> oh, you need an extra do
10:35:28 <exio4> that loop function looks like (:) <$> parseLattices <*> parseLattices though
10:35:36 <sbrg> https://gist.github.com/cb255adc2914758f7717
10:35:43 <wei2912> ah, i see
10:35:53 <sbrg> exio4: yep
10:36:11 <guesting> I have a cabal package that is an executable. However, there is a module in there that I want to access for another executable in another project. Should I be having that package be a library and an executable? If so, how?
10:36:44 <wei2912> sbrg: i'll keep that in mind, thanks!
10:37:05 <flyingfisch> anyone know of a good tutorial on how to use the Reader monad?
10:37:27 <flyingfisch> I think I understand the other types of monads, but this one is just not making sense
10:38:44 <slomo> flyingfisch: how to use it or when to use it? do you understand State?
10:39:00 <flyingfisch> slomo: how and when
10:39:06 <flyingfisch> I think I get state
10:39:28 <flyingfisch> State is like with random numbers right?
10:40:20 <slomo> flyingfisch: it's basically like State, you just can't change the state (except for sub-computations and then it reverts back to the old afterwards). you usually use Reader if you have some read-only environment that you want to pass around to everything. instead of having the same first parameter on every function and then threading that through all your code
10:40:38 <pikitgbhs> Hello everybody. I have a question, I have this basic function that divide two numbers a/b but i wanna know how i can return null if b == 0 ? I'm trying something like: let div x y = if y == 0 then null else x/y but when div 20 0 returns "<interactive>:28:9:     No instance for (Num ([a0] -> Bool)) arising from the literal `20'     Possible fix: add an instance declaration for (Num ([a0] -> Bool))     In the first argument of `d
10:41:06 <flyingfisch> slomo: ok I think the part I don't understand is this "environment" thing
10:41:14 <flyingfisch> what do you mean by that?
10:41:26 <Kaidelong> pikitgbhs: what you should do is return a "Maybe Int" instead, then you have "Nothing"
10:41:30 <flyingfisch> would that be like a "do"
10:41:35 <flyingfisch> ?
10:41:52 <Kaidelong> if you want to know the way the built in (/) does it, it's something like 'error "Divide by zero"'
10:41:52 <flyingfisch> or wait
10:41:53 <slomo> flyingfisch: some immutable thing you have available everywhere inside the monad via "ask"
10:42:03 <slomo> flyingfisch: as if you would pass that as a parameter to all your functions manually
10:42:03 <flyingfisch> ah
10:42:07 <pikitgbhs> Kaidelong: similar to > let dividir y x = if x == 0 then -1 else y/x ?
10:42:16 <Kaidelong> (for floating point it returns infinity or not-a-number)
10:42:17 <jmct> pikitgbhs: on top of what Kaidelong said: 'null' is a function and you are trying to use it as a value
10:43:02 <flyingfisch> slomo: so it makes it so now I don't have to actually pass the values to each function?
10:43:19 <flyingfisch> so like I get this set of variables that I can use anywhere in the program?
10:43:31 <slomo> flyingfisch: at least one value, yes. you can use it for example to have your programs configuration data structure available from everywhere
10:43:36 <flyingfisch> ok
10:43:38 <Kaidelong> @let safeDivide x y = if y == 0 then Nothing else Just (x/y)
10:43:41 <lambdabot>  Defined.
10:43:45 <flyingfisch> so now how do I implement it
10:43:48 <pikitgbhs> jmct: But how i return null or undefined if b == 0 ?
10:43:56 <Kaidelong> > safeDivide 5 2
10:44:00 <lambdabot>  Just 2.5
10:44:05 <flyingfisch> slomo: and how does reader differ from ReaderT?
10:44:06 <Kaidelong> > safeDivide 4 0
10:44:09 <lambdabot>  Nothing
10:44:54 <slomo> flyingfisch: the same way State differs from StateT. the latter is a transformer that can wrap another monad to "add" State monad functionality to it
10:45:14 <jmct> pikitgbhs: as Kaidelong is showing, the closest thing to 'null' is 'Nothing' from the Maybe type
10:45:22 <flyingfisch> slomo: ah ok
10:45:39 <Kaidelong> Haskell doesn't have a null in the way many other languages do by design
10:47:35 <slomo> flyingfisch: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#g:4 has some examples
10:47:36 <pikitgbhs> Kaidelong: when i try 10/0 the operation return Infinity. Infinity is a Haskell type ?
10:47:51 <exio4> it is a value
10:47:57 <exio4> > 10/0
10:47:59 <exio4> :t 10/0
10:48:01 <lambdabot>  Infinity
10:48:01 <Kaidelong> pikitgbhs: it's specified in an IEEE standard for floating point numbers
10:48:02 <lambdabot> Fractional a => a
10:48:13 <slomo> flyingfisch: also for the State monad here https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#g:4
10:48:14 <Kaidelong> it's not a haskell thing
10:48:16 <flyingfisch> slomo: thx
10:48:40 <Kaidelong> if you don't use floating point, it's not there
10:48:52 <Kaidelong> > 10 `div` 0
10:48:56 <lambdabot>  *Exception: divide by zero
10:49:57 <skippysan> any self-help books anyone here can recommend a new person ?
10:50:09 <pikitgbhs> Kaidelong: but thats two diferent responses 10/0 return Infinity but 10 `div` 0 returns *** Exception: divide by zero :/
10:50:16 <stephenjudkins> skippysan: http://learnyouahaskell.com/
10:50:21 <skippysan> any self-help books anyone here can recommend a new person ?
10:50:30 <jmct> :t div
10:50:30 <pikitgbhs> skippysan: +1
10:50:33 <lambdabot> Integral a => a -> a -> a
10:50:34 <skippysan> sorry didn't mean to repeat
10:50:40 <jmct> :t (/)
10:50:42 <lambdabot> Fractional a => a -> a -> a
10:51:22 <Kaidelong> pikitgbhs: one is the correct behavior for standard floating point values and the other is the "correct" value for things that are like integers
10:51:35 <skippysan> I want to get into this type programming but I'm totally new to it and would like to know if someone is holding a pdf or knows where I can self-teach or learn
10:51:44 <Kaidelong> (really, it should be something more like Int -> Int -> Maybe Int)
10:52:24 <Kaidelong> if you're used to Java or C# they go to huge lengths to coerce between different numeric types
10:52:30 <sinelaw> skippysan, lyah
10:52:31 <sinelaw> @where lyah
10:52:32 <lambdabot> http://www.learnyouahaskell.com/
10:52:54 <Kaidelong> OCaml would be on the other end, for example, you can't use * on both integers and floating points, if you want to multiply floating points you use .*.
10:53:08 <pikitgbhs> Kaidelong: oh i see
10:53:11 <pikitgbhs> Thanks
10:53:13 <Kaidelong> Haskell is somewhere inbetween because it has typeclasses to overload with but it doesn't do any kind of coercions
10:53:36 <Kaidelong> however because floating point and integer division are deeply different things, that's not just a matter of overloading
10:53:58 <Kaidelong> you're right that (/) and div behave differently, and that's why they have different names and types
10:54:34 <skippysan> well i was recommended to try this out if I want to be a programmer
10:54:36 <Kaidelong> :t (/)
10:54:39 <slomo> flyingfisch: in the first Reader example you can imagine calc_isCountCorrect as having the type "Bindings -> Bool", and ask just giving you the Bindings parameter (and asks doing the same, but then applying another function on it before giving you the value)
10:54:40 <lambdabot> Fractional a => a -> a -> a
10:54:41 <Kaidelong> :t div
10:54:45 <lambdabot> Integral a => a -> a -> a
10:54:46 <skippysan> I know about IRC only because of the Dreamcast days
10:54:51 <skippysan> and Dalnet
10:54:56 * hackagebot uhc-light 1.1.7.4 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.7.4 (AtzeDijkstra)
10:54:57 <kadoban> Heh
10:55:03 <sinelaw> skippysan, look at the link I gave you
10:55:06 <flyingfisch> slomo: k
10:55:10 <kadoban> Well if you're going to be learning haskell, this is a great place to be
10:55:21 <Kaidelong> also, they're still different in things like Java, but those have a feature called ad-hoc overloading that haskell (by design) does not have
10:55:46 <kadoban> ad-hoc overloading is what, generics?
10:55:47 <skippysan> Any help would be appreciated thanks. Just want to know where to start. I read the Haskel website but I'm sure there are better books than Wiki
10:56:05 <Kaidelong> standard haskell does not have, fine
10:56:19 <skippysan> Thanks Kadoban
10:56:21 <slomo> flyingfisch: and that's exactly what the Reader monad is in the end:
10:56:23 <slomo> @unmtl Reader Bindings Bool
10:56:25 <lambdabot> Bindings -> Bool
10:56:34 <sinelaw> skippysan, the Learn You A Haskell book is often recommended
10:56:36 <flyingfisch> hmm
10:56:37 <sinelaw> it's the link
10:56:42 <flyingfisch> soooo
10:56:53 <cschneid> skippysan: https://github.com/bitemyapp/learnhaskell is a good resource. Along with LYAH and Real World Haskell.  No one source is perfect.
10:57:01 <Kaidelong> does SYB really allow full ad-hoc overloading? I haven't used it
10:57:15 <flyingfisch> first of all, why do I keep getting "Reader is not in scope, perhaps you meant ReaderT"
10:57:16 <flyingfisch> ?
10:57:23 <flyingfisch> what module is Reader in?
10:57:39 <flyingfisch> apparently the type constructor is defined
10:57:44 <sinelaw> @hoogle Reader
10:57:46 <lambdabot> Control.Monad.Reader module Control.Monad.Reader
10:57:46 <lambdabot> Control.Monad.Trans.Reader module Control.Monad.Trans.Reader
10:57:46 <lambdabot> Data.Text.Lazy.Read type Reader a = Text -> Either String (a, Text)
10:57:53 <flyingfisch> strange
10:58:02 <slomo> flyingfisch: Control.Monad.Reader
10:58:07 <flyingfisch> I have Control.Monad.Reader imported
10:58:11 <SvenskFisk> How do I implement a function that generates an infinite list? Specifically, I have a function nextWord that takes a string and a markov chain, and returns the word to be added. I want to be able to do something like 'take 4 (infiniteGenerator chain)' to learn more about infinite lists in haskell, is there a way to do this?
10:58:16 <dreixel> Kaidelong: yep, through the |ext| set of functions
10:58:17 <flyingfisch> :t Reader
10:58:20 <lambdabot>     Not in scope: data constructor ‘Reader’
10:58:20 <lambdabot>     Perhaps you meant ‘ReaderT’ (imported from Control.Monad.Reader)
10:58:25 <flyingfisch> see?
10:58:31 <flyingfisch> oh wait
10:58:41 <flyingfisch> Reader is a type constructor right?
10:58:53 <jmct> :t reader
10:58:55 <Kaidelong> yes, there should be a Reader tycon
10:58:57 <lambdabot> MonadReader r m => (r -> a) -> m a
10:59:10 <Kaidelong> which is probably defined
10:59:17 <flyingfisch> waaait... why lowercase all of a sudden?
10:59:18 <Kaidelong> type Reader = ReaderT Identity
10:59:44 <jmct> it's a function that wraps what you want in ReaderT
10:59:50 <Kaidelong> flyingfisch: reader would be a method which yields any valid ReaderT stack
10:59:56 * hackagebot monoid-extras 0.3.3.5 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.3.3.5 (bergey)
10:59:58 <flyingfisch> hmm
11:00:19 <jmct> I was thrown by this too eventually, but they purposefully took out the Reader constructor
11:00:26 <capisce> SvenskFisk: the iterate function?
11:00:29 <jmct> so that it's unified under ReaderT
11:00:34 <flyingfisch> ok hmm
11:00:46 <flyingfisch> I am learning haskell with learn you a haskell...
11:01:00 <flyingfisch> and he never talks about monad transformers
11:01:02 <Kaidelong> the general pattern with the mtl is to have a typeclass that exposes the functionality of some monad, and then to have instances that allow those methods to be used even when your monad transformer is not the outer most
11:01:14 <jmct> yeah, when that was written Reader was its own constructor
11:01:20 <flyingfisch> i just double checked
11:01:25 <flyingfisch> so
11:01:31 <jmct> for your purposes you can always just replace it with the function 'reader'
11:01:36 <Kaidelong> ReaderT's constructor will only give you ways to make things that use ReaderT at the outermost point, while reader will work even if ReaderT is an inner monad transformer
11:01:48 <jmct> it'd be like having the function 'just x = Just x'
11:01:53 <flyingfisch> k
11:02:00 <Gurkenglas> How do I find libraries that contain instance declarations for a given typeclass?
11:02:16 <fragamus> guys I have a weird problem with my cabal setup: I get error 403 when i try cabal update using stackage's latest snapshot index, but I can download the file just fine with chrome
11:02:39 <fragamus> it fails with wget
11:02:42 <flyingfisch> so that would explain why Writer is not available either?
11:02:46 <fragamus> it works with chrome
11:02:46 <jmct> correct
11:03:00 <flyingfisch> k
11:03:27 <geekosaur> fragamus, that usually means there's a proxy somewhere that you need to tell wget etc. about
11:03:45 <geekosaur> browsers do proxy auto config, but that doesn't help anything else
11:04:00 <fragamus> oh wow ok
11:04:56 * hackagebot active 0.1.0.17 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.17 (bergey)
11:05:37 <wei2912> does haskell have a Counter class like python? basically you add in elements and it maintains a map of elements to frequency counts
11:06:08 <SvenskFisk> capisce: that's exactly what I was looking for, thank you!
11:06:42 <mmachenry> How bad would it be to call (unsafeIOtoSTM Data.Time.Clock.getCurrentTime) from within a STM transaction?
11:06:47 <Kaidelong> geekosaur: doesn't windows use the IE settings system wide?
11:06:50 <wei2912> for example
11:06:55 <hiptobecubic> wei2912, Probably not out of the box? It has Data.Map and Data.HashMap that you could wrap
11:06:59 <Kaidelong> might be worth checking if he is on windows first
11:07:03 <wei2912> ["a", "b", "a"] -> [("a", 2), ("b", 1)
11:07:04 <wei2912> ["a", "b", "a"] -> [("a", 2), ("b", 1)]
11:07:13 <fryguybob> mmachenry: I was just going to talk about your question from before.  It is an interesting STM use.
11:07:21 <hiptobecubic> wei2912, there is a function to count things if you don't need to update the counts
11:07:29 <wei2912> hiptobecubic: hmm. i'm hoping that someone has created a library for it, since i'm too lazy to
11:07:40 <geekosaur> Kaidelong, yes and no? I am not sure an msys or cygwin wget would pick up system settings. likewise there is a "systemwide" proxy config on OS X but stuff using the BSD API doesnt know about it
11:07:42 <wei2912> hiptobecubic: that might work, but i'll need to add it some weird counts
11:07:45 <wei2912> in*
11:07:48 <wei2912> fractional counts in fact
11:08:03 <fryguybob> mmachenry: The best support would require some direct runtime support, but using unsafeIOtoSTM can be ok here with some potential issues.
11:08:06 <Cale> wei2912: There's Data.Map, you can use insertWith (+) and/or fromListWith (+)
11:08:08 <Gurkenglas> How do I write the list of all chars? ([..] :: [Char])?
11:08:25 <Cale> > ['\0'..]
11:08:27 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:08:36 <fizbin> I have a haskell web service (snap framework based) that, for silly reasons, is getting sent dozens of requests near-simultaneously. I'd like to queue those requests and process only one at a time. What data structure/library am I looking for?
11:08:36 <geekosaur> > [minBound .. maxBound] :: [Char]
11:08:38 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
11:08:48 <hiptobecubic> @t insertWith
11:08:48 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:08:54 <hiptobecubic> @type insertWith
11:08:54 <lambdabot>     Not in scope: ‘insertWith’
11:08:55 <lambdabot>     Perhaps you meant one of these:
11:08:55 <lambdabot>       ‘IM.insertWith’ (imported from Data.IntMap),
11:08:58 <fryguybob> mmachenry: One thing that you will have to be very careful about is ensuring that your transaction does not block (execute `retry`) due to the information it gets from getCurrentTime.
11:09:02 <Cale> :t M.inserWith
11:09:03 <lambdabot>     Not in scope: ‘M.inserWith’
11:09:03 <lambdabot>     Perhaps you meant one of these:
11:09:03 <lambdabot>       ‘M.insertWith’ (imported from Data.Map),
11:09:05 <wei2912> Cale: yeh, there is. i could give it a try
11:09:06 <Cale> :t M.insertWith
11:09:07 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
11:09:09 <Cale> :t M.insertWith (+)
11:09:11 <lambdabot> (Ord k, Num a) => k -> a -> M.Map k a -> M.Map k a
11:09:18 <Cale> :t M.fromListWith (+)
11:09:19 <wei2912> i'll write up a small wrapper for my Counter class
11:09:20 <lambdabot> (Ord k, Num a) => [(k, a)] -> M.Map k a
11:09:23 <wei2912> err, data type
11:09:44 <hiptobecubic> Cale, does insertWith fail if the key isn't present? How does it get a default?
11:10:00 <Cale> It inserts the given value if the key is not present
11:10:07 <Cale> The function is used to deal with collisions
11:10:14 <hiptobecubic> ah. Sounds good then
11:10:19 <Cale> Also, you can use map (\x -> (head x, length x)) . group . sort  to do that computation
11:10:41 <Cale> Which if you import Control.Arrow can be abbreviated to map (head &&& length) . group . sort
11:10:53 <hiptobecubic> wei2912, all that's missing from that is wrapping your lookup func in `either 0 id`
11:10:56 <Cale> > map (head &&& length) . group . sort $ "mississippi"
11:10:57 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
11:11:19 <hiptobecubic> Control.Arrow always seemed strange to me
11:11:22 <wei2912> hiptobecubic: Cale sounds good to me. :)
11:11:27 <wei2912> thanks for your help
11:11:43 <fryguybob> mmachenry: Also getting a time this way won't help much for synchronizing if that is your goal for the time (I doubt that is your use).
11:11:48 <hiptobecubic> It just feels like a bag of convenience functions for working with tuples
11:13:18 <Cale> hiptobecubic: It's really an attempt at something much more general. The problem is that the details of how it's specified undermine a lot of its best potential use cases.
11:14:02 <flyingfisch> oooh yay I think I get it
11:14:12 <flyingfisch> so...
11:14:38 <hiptobecubic> Cale, what are the use cases for Arrow, theoretically? Other than working with tuples :)
11:15:30 <flyingfisch> if I do runReaderT  (ReaderT myMonad) myGlobalVar, myMonad can use myGlobalVar anywhere within the monad. right?
11:15:59 <Cale> hiptobecubic: Well, okay, so a problem that you might run into using Monad to describe computations is that there's very little that you can do to simplify the execution of a monadic computation before running it. The right hand argument to every (>>=) is going to be a function, and functions are essentially black boxes.
11:16:38 <Cale> hiptobecubic: However, with Arrow, your primitive means of composition is (>>>), and both its arguments are of a type that you specify and have some control over
11:17:04 <Gurkenglas> @hoogle (a->b) -> [a] -> M.Map b [a]
11:17:04 <lambdabot> Parse error:
11:17:04 <lambdabot>   (a->b) -> [a] -> M.Map b [a]
11:17:04 <lambdabot>                      ^
11:17:18 <Cale> So there's some hope of being able to analyse the computations before you run them, and do something to avoid wasteful computation
11:17:40 <hiptobecubic> interesting. Do you know of any examples of anyone doing this? With Control.Arrow or otherwise?
11:18:11 <iteratee> hipotbecubic: A good example would be haxl at facebook.
11:18:11 <Cale> Well, there were a few Arrow-based parsing libraries which took some advantage of it
11:18:27 <Cale> However, one of the unfortunately-important primitives in Arrow is 'arr'
11:18:31 <Cale> :t arr
11:18:32 <lambdabot> Arrow a => (b -> c) -> a b c
11:18:36 <Kaidelong> I was about to ask about that one
11:18:48 <Cale> It takes a function parameter, and so introduces black boxes into your computations
11:19:01 <Cale> that in practice undermine most of your opportunities to optimise things
11:19:22 <Cale> Especially if you're using the proc/do notation, which sticks an 'arr' in between every two lines of your do-block
11:20:16 <Cale> At iPwn, we ended up redoing Arrow, adding in a bunch of additional primitives for wiring computations together, so that arr could mostly be avoided (with certain exceptions that came up infrequently enough not to hurt optimisation so badly)
11:20:35 <Cale> and rewrote the proc/do notation processing as a preprocessor
11:20:57 <Cale> This made our game run about 4-6 times faster iirc. :P
11:21:27 <hiptobecubic> wow
11:21:32 <hiptobecubic> quite a difference
11:21:36 <Cale> (We were using an Arrow based FRP library that we'd written in-house)
11:23:57 <Cale> Yeah, the point of Arrow is to make explicit all the binding that's taking place
11:24:26 <Cale> The things we did to Arrow made it a lot more like the definition of a symmetric monoidal category
11:29:53 <nitrix> Hi, how do I use `read` :: Type notation in a lambda?
11:30:32 <nitrix> map (\x -> read $ head $ B.split '=' x :: Integer) (B.lines $ unPage p)
11:30:48 <nitrix> Gives an error, and so does any combinations with parenthesis I tried :(
11:31:57 <capisce> read "2" :: Integer
11:31:58 <bitonic> map (\x -> read (head (B.split '=' x)) :: Integer) (B.lines $ unPage p)
11:32:11 <S11001001> @ty \x -> read $ head $ x :: Integer
11:32:13 <lambdabot> [String] -> Integer
11:34:46 <fryguybob> mmachenry: Did what I say make sense? (my reply may have been lost in the other conversations going on)
11:34:57 * hackagebot hakyll-contrib-hyphenation 0.1.0.3 - automatic hyphenation for Hakyll  http://hackage.haskell.org/package/hakyll-contrib-hyphenation-0.1.0.3 (firegurafiku)
11:35:13 <Hodapp> hmm, trying to wrap my mind around the type argument of a monad changing in the middle of a 'do' block
11:35:39 <Hodapp> but I guess, given that the types of (>>) and (>>=) explicitly allow this, it's nothing all that out of the ordinary
11:36:03 <Procian> Hodapp: Definitely not out of the ordinary. It's the best bit.
11:36:12 <Hodapp> It's just a bit confusing to see in a 'do' block.
11:36:51 <Cale> Hodapp: Well, the results of various actions in the do block may be of different types
11:37:31 <ChristianS> nitrix: you must be a bit careful with $, since x $ y is essentially equivalent to (x) (y), with x and y extending as far to the left/right as possible, which can be quite wide.
11:37:49 <Cale> :: has lower precedence than any infix operator though
11:37:50 <Procian> Hodapp: It's pretty common in a do-block.
11:38:07 <Cale> It applies to the entire expression to its left, as far back as possible
11:38:17 <Cale> (doesn't matter whether it involves $)
11:38:29 <nitrix> Cale: Thanks.
11:38:48 <Hodapp> Procian: all for the best that I encounter it pretty early in my Haskell experience then, I guess.
11:38:55 <Cale> Hodapp: So, for instance, you might use getLine to get a line of text from the user, and then later use randomRIO (1,6) to get a die roll which is an Integer
11:39:10 <Hodapp> this is for Atom, which has okay docs on individual functions, but basically no "real" examples
11:39:10 <RGamma> I've asked this question a couple days ago but got no answer: Is there a canonical way of flipping function arguments. I.e. say you have f::a1->..->an->b (because that makes the most sense on its own), but for your purpose you need any permutation of (a1,..,an). Write a generic flip function and apply that everytime you call f, use where statements?
11:39:16 <nitrix> Just saying, maybeMaybe is absolutely brilliant.
11:39:23 <Cale> RGamma: Lambda
11:39:26 <L8D> O.O
11:39:32 <nitrix> mapMaybe*
11:39:35 <L8D> :t maybeMaybe
11:39:38 <lambdabot>     Not in scope: ‘maybeMaybe’
11:39:38 <lambdabot>     Perhaps you meant one of these:
11:39:38 <lambdabot>       ‘IM.mapMaybe’ (imported from Data.IntMap),
11:39:46 <L8D> ah
11:40:14 <Cale> RGamma: You can write things like (\a b c -> f b c a)
11:40:14 <nitrix> It's an idiom every languages should have. I love the Maybe monad <3
11:40:21 <L8D> me 2
11:40:26 <bitonic> :t msum . map
11:40:28 <lambdabot>     Couldn't match type ‘[a1] -> [b]’ with ‘[m a]’
11:40:28 <lambdabot>     Expected type: (a1 -> b) -> [m a]
11:40:28 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
11:40:31 <Cale> RGamma: which will be clearer than any amount of composing various flips
11:40:54 <bitonic> :t \f -> msum . map f
11:40:57 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
11:41:17 <bitonic> nitrix: a more general mapMaybe!
11:41:55 <bitonic> ah no.
11:42:07 <bitonic> that's not what mapMaybe does apparently :P
11:43:14 <Hodapp> guess I should do my part and put a decent Atom tutorial online if I ever figure it out.
11:43:24 <Procian> bitonic: Yeah. mapMaybe is special. It's like mapConcat but where the inner structure is Maybe.
11:43:25 <L8D> :t mapMaybe
11:43:27 <lambdabot> (a -> Maybe b) -> [a] -> [b]
11:43:30 <RGamma> Cale: So there's no short form like (in a call, exemplary syntax): f _ y z, with the semantics: Transform f, such that f :: b -> c -> a ->... and f y z :: a -> .. ?
11:43:41 <Cale> RGamma: That's what lambda is for
11:43:44 <Gurkenglas> RGamma, you can write things like (\a b c -> f c b a) and then ask lambdabot to pl it
11:43:45 <Procian> bitonic: I think the Scala folk have managed to abstract this one with a general concat.
11:43:47 <RGamma> f _ y z :: ... *
11:43:50 <L8D> isn't bind more powerful than a mapMaybe ?
11:43:50 <Gurkenglas> @pl (\a b c -> f c b a)
11:43:52 <lambdabot> flip (flip . flip f)
11:44:02 <bitonic> Procian: we managed that too, with Monoid
11:44:04 <Cale> RGamma: People have proposed things like that, but the specification is always awkward in a way which lambda solves perfectly
11:44:18 <bitonic> :t mappend :: Monoid a -> Maybe a -> Maybe a -> Maybe a
11:44:18 <Cale> RGamma: Like, what happens with expressions like  f _ (g _ _) ?
11:44:21 <lambdabot>     Expected a type, but ‘Monoid a’ has kind ‘Constraint’
11:44:21 <lambdabot>     In an expression type signature:
11:44:21 <lambdabot>       Monoid a -> Maybe a -> Maybe a -> Maybe a
11:44:24 <bitonic> :t mappend :: Monoid a => Maybe a -> Maybe a -> Maybe a
11:44:27 <lambdabot> Monoid a => Maybe a -> Maybe a -> Maybe a
11:44:32 <bitonic> > Just [1,2] <> Nothing
11:44:36 <lambdabot>  Just [1,2]
11:44:39 <bitonic> > Just [1,2] <> Just [3,4]
11:44:43 <lambdabot>  Just [1,2,3,4]
11:44:54 <Cale> RGamma: Is that (\x -> f x (\y z -> g y z)) or is it (\x y z -> f x (g y z))?
11:44:54 <L8D> > Nothing <> Just [1,2]
11:44:57 <lambdabot>  Just [1,2]
11:45:07 <bitonic> Procian: then we also managed to abstract traversals with Foldable/Traversable
11:45:12 <bitonic> > toList $ Just [1,2] <> Just [3,4]
11:45:15 <lambdabot>  Not in scope: ‘toList’
11:45:15 <lambdabot>  Perhaps you meant one of these:
11:45:15 <lambdabot>    ‘F.toList’ (imported from Data.Foldable),
11:45:15 <lambdabot>    ‘IS.toList’ (imported from Data.IntSet),
11:45:15 <lambdabot>    ‘S.toList’ (imported from Data.Set)
11:45:17 <RGamma> Cale: The second :P
11:45:20 <bitonic> > P.toList $ Just [1,2] <> Just [3,4]
11:45:22 <bitonic> > F.toList $ Just [1,2] <> Just [3,4]
11:45:23 <lambdabot>  Not in scope: ‘P.toList’
11:45:23 <lambdabot>  Perhaps you meant one of these:
11:45:23 <lambdabot>    ‘F.toList’ (imported from Data.Foldable),
11:45:23 <lambdabot>    ‘S.toList’ (imported from Data.Set),
11:45:25 <lambdabot>    ‘M.toList’ (imported from Data.Map)
11:45:27 <RGamma> Cale: Okay, that cleared that one up then, thanks
11:45:28 <lambdabot>  [[1,2,3,4]]
11:45:32 <bitonic> (sorry for the spam)
11:46:03 <Cale> RGamma: I think the second one is more confusing behaviour personally :)
11:46:11 <bitonic> oh wait.  that didn't work out.
11:46:15 <Gurkenglas> lambdabot should wait another n seconds before giving an output of more than 2 lines, during which a :nooo will abort it
11:46:20 * bitonic shouldn't type right now :P
11:47:10 <bitonic> > runWriter $ mapM tell (Just [1,2] <> Just [3,4])
11:47:12 <L8D> I think lambdabot should just have a one-line message that an error occured, and then show the error in a pm to the user who wrote it
11:47:13 <lambdabot>  Couldn't match expected type ‘[w]’
11:47:13 <lambdabot>              with actual type ‘Data.Maybe.Maybe [t0]’Couldn't match expected ...
11:47:13 <lambdabot>              with actual type ‘Data.Maybe.Maybe [t1]’
11:47:35 <L8D> and then you can explicitly tell lb to show the error, for when you need to
11:47:38 <Cale> RGamma: because it means that if you write something like  map (f _ c) xs, it means (\x -> map (f x c) xs), rather than map (\x -> f x c) xs
11:47:41 <Procian> bitonic: That's not quite what I was after.
11:47:42 <RGamma> Cale: Do you have a link to one of those proposals or do you know them just from hearsay?
11:47:44 <Gurkenglas> Hmmyes, unless you add a flag that has it output the error anyway
11:47:56 <Gurkenglas> Oh, you just said that. :nooo
11:48:02 <Cale> RGamma: I don't have a link handy, but it's shown up several times on the Haskell mailing list
11:48:22 <bitonic> Procian: in general when I need to work with Maybes pretty much every operation fills in the Monoid/MonadPlus/Foldable/Traversable instances
11:48:45 <Cale> RGamma: It's one of those things that someone thinks of every so often, and then when it comes down to actually specifying more clearly, it starts to become apparent that maybe it's not the best idea after all
11:48:47 <RGamma> Cale: Alright
11:48:58 <RGamma> Cale: I see
11:49:13 <Cale> RGamma: Also, it'd conflict with a recent extension to use _ as a hole
11:49:24 <RGamma> Cale: Well, I thought of it as syntactic sugar for a generic flip
11:49:51 <exio4> something like "??"?
11:49:54 <exio4> :t (??)
11:49:56 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:50:12 <flyingfisch> what does this line mean exactly? printReaderContent :: ReaderT String IO ()
11:50:21 <exio4> > ((-) ?? 3) 5
11:50:24 <flyingfisch> I thought ReaderT only took one arg
11:50:24 <lambdabot>  2
11:50:34 <flyingfisch> here it seems to take 2
11:50:38 <ion> @src ReaderT
11:50:39 <lambdabot> Source not found. Whoa.
11:50:41 <monochrom> in fact 3
11:50:59 <ion> @unmtl ReaderT String IO ()
11:51:01 <lambdabot> String -> IO ()
11:51:01 <flyingfisch> wait
11:51:13 <flyingfisch> this is so strange
11:51:31 <flyingfisch> ReaderT :: (r -> m a) -> ReaderT r m a
11:51:34 <ion> printReaderContent is just a function from String to IO () wrapped in the ReaderT newtype.
11:51:42 <bitonic> > execWriter $ T.mapM tell $ Just [1,2] <> Just [3,4]
11:51:46 <lambdabot>  [1,2,3,4]
11:51:46 <Cale> RGamma: Right now, if you put a _ in your code, you'll get an error message from GHC with lots of useful information about what the type of the thing is that should go in that position, and the types of relevant bindings which are in scope at that point.
11:51:56 <flyingfisch> wait let me think here
11:52:02 <flyingfisch> ok
11:52:02 <flyingfisch> so
11:52:03 <monochrom> you're looking at the wrong ReaderT
11:52:08 <flyingfisch> oh
11:52:14 <mmachenry> fryguybob: Yeah that makes sense. I'm making decisions based on it. I'm storing it in my STM for knowledge of when things happened.
11:52:21 <flyingfisch> how do I get the type of the type constructor?
11:52:22 <mmachenry> It's a "last modified" field.
11:52:26 <flyingfisch> monochrom: ^
11:52:41 <Gurkenglas> @src (??)
11:52:43 <lambdabot> Source not found. Maybe you made a typo?
11:52:45 <monochrom> a type constructor does not have a type, only a kind. use :kind for that.
11:52:56 <flyingfisch> monochrom: ok
11:53:06 <flyingfisch> wooo
11:53:15 <Black0range> Hey guys the recieveHTTP in Network.HTTP, how is it supposed to work?
11:53:17 <monochrom> for example Maybe does not have a type. Maybe does have a kind.
11:53:21 <fryguybob> mmachenry: I think that should be fine.
11:53:28 <RGamma> Cale: Fair enough
11:53:42 <sinelaw> ugh , cabal dependency hell
11:53:54 <flyingfisch> so it takes a concrete type and a function that returns a concrete type and another concrete type and returns a concrete type?
11:54:01 <mmachenry> fryguybob: What about performance? Hitting IO is more expensive than STM stuff. Any idea how much of a hit that would be? It's not hitting the disk, I guess.
11:54:06 <monochrom> yes.
11:54:10 <flyingfisch> ok
11:54:28 <flyingfisch> but...
11:54:30 <monochrom> for example IO's kind is *->* so it fits the second position.
11:54:32 <sinelaw> what exactly is cabal trying to tell me here? http://lpaste.net/115600
11:54:43 <flyingfisch> ah ok
11:54:53 <monochrom> for example String's kind is * so it fits the first position.
11:54:55 <flyingfisch> and then the last type is an empty tuple?
11:55:05 <monochrom> () has kind * too
11:55:10 <flyingfisch> just checked
11:55:11 <fryguybob> mmachenry: It shouldn't cost anything really.  It *would* cost something if GHC used hardware transactions, but it does not (yet).
11:55:16 <flyingfisch> ah ok got it
11:55:16 <sinelaw> reformatted: http://lpaste.net/115600
11:55:23 <monochrom> other examples are ReaderT Int Maybe Bool
11:55:49 <flyingfisch> so what does that mean exactly?
11:56:00 <dcoutts_> sinelaw: looks like it's saying that 'either' and 'random-shuffle' require different versions of MonadRandom
11:56:02 <monochrom> do you already know ReaderT?
11:56:11 <flyingfisch> that the result is going to be ReaderT, Int, Maybe, and Bool?
11:56:19 <monochrom> no
11:56:19 <ion> @unmtl ReaderT Int Maybe Bool
11:56:21 <lambdabot> Int -> Maybe Bool
11:56:38 <sinelaw> argh
11:56:44 <Cale> Black0range: So, you're meant to give it a HandleStream ty (where ty is either String or one of the two types of ByteString), and it gives you an IO action which you can run to read an HTTP request from that stream
11:56:58 <flyingfisch> wait
11:57:04 <flyingfisch> so what that means
11:57:24 <flyingfisch> is it is going to be type ReaderT Int Maybe Bool which is going to be a concrete type
11:57:27 <Gurkenglas> Okay, am I being stupid or something? How would you implement a (Functor f => f (a -> b) -> a -> f b)?
11:57:30 <flyingfisch> right?
11:57:34 <monochrom> yes
11:57:37 <sinelaw> dcoutts_, thanks. the message is not very clear.
11:57:40 <Cale> Black0range: The HStream class appears to define various ways to get hold of a HandleStream in the first place (all generalised over the buffer type), such as openStream and openSocketStream
11:57:41 <guesting> I have a library that requires text >=1.1 && <1.3, but I also have a library that depends on lens which depends on text >=0.11.3.1 && <1.3 in the same cabal file. When I install it, it rejects the library, saying that it conflicts with text==0.11.3.1, but lens says >=0.11.3.1, what is going on here?
11:58:06 <bitonic> Gurkenglas: you need Applicative, `f x -> f <*> pure x'
11:58:12 <bitonic> add a lambda in there
11:58:17 <flyingfisch> what would an example of a ReaderT Int Maybe Bool?
11:58:18 <ion> gurkenglas: foo fab a = something <$> a. Can you figure out the something?
11:58:21 <Black0range> Cale: so if i want to make a very simple HTTP server this isn't what i'm looking for?
11:58:31 <dcoutts_> sinelaw: the key bit there is: (conflict: either => MonadRandom==0.1.13/installed-c64..., random-shuffle => MonadRandom==0.3/installed-cc8...)
11:58:46 <Gurkenglas> Well with Applicative it's trivial. But lambdabot says it works without
11:58:49 <Gurkenglas> :t (??)
11:58:51 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:58:55 <nitrix> Given a list of numbers [...,2,4,8,10,13,...]  How would I pick the greatest number smallest than X ?
11:58:57 <Cale> Black0range: I've never used this part of the HTTP library before, I'm just reading the relevant portion of the Haddock documentation for it. It appears like you could use this if you wanted to implement an HTTP server a bit more manually than one usually would.
11:58:59 <ion> gurkenglas: Uh, sorry, ẇait
11:59:10 <monochrom> ReaderT (\n -> Just (even n)) :: ReaderT Int Maybe Bool
11:59:17 <ion> gurkenglas: foo fab a = something <$> fab
11:59:27 <L8D> @src (??)
11:59:30 <lambdabot> Source not found. That's something I cannot allow to happen.
11:59:36 <monochrom> (I force n :: Int)
11:59:37 <bitonic> Gurkenglas: ah, I see!
11:59:48 <flyingfisch> monochrom: oh, so would return True :: ReaderT Int Maybe Bool work too?
11:59:54 <sinelaw> dcoutts_, now that you've told me I figured that out myself - but it really isn't person-friendly
12:00:05 <monochrom> yes
12:00:10 <nitrix> Should I use a list comprehension? map? folds?
12:00:12 <L8D> f ?? x = fmap ($ x) f
12:00:39 <nitrix> s/smallest/smaller/
12:00:47 <Gurkenglas> L8D, brilliant!
12:01:04 <L8D> :t \f x -> fmap ($ x) f
12:01:07 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:01:24 <bitonic> Gurkenglas: if you put a type hole where ion put something, it becomes pretty clear!
12:01:30 <Cale> Black0range: There are a lot of web application libraries of various sorts on Hackage, at different levels of abstraction and complexity. What sort of program are you trying to write?
12:01:33 <L8D> it should be: Functor f => a -> f (a -> b) -> f b
12:01:35 <flyingfisch> ok bbiab, lunch
12:02:10 <Black0range> Cale: Just my own thing, pretty new to haskell trying to get a good understanding of how things work :)
12:02:21 <Gurkenglas> Oh, <$> is just fmap. I thought ion too was assuming Applicative.
12:04:07 <L8D> :t (<*>)
12:04:10 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:04:17 <L8D> :t (<&>)
12:04:21 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:04:29 <L8D> :t (<$>)
12:04:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:04:49 <L8D> :
12:05:00 <L8D> @pl flip (<*>)_
12:05:01 <lambdabot> (line 1, column 11):
12:05:01 <lambdabot> unexpected '_'
12:05:01 <lambdabot> expecting variable, "(", operator or end of input
12:05:02 <L8D> -.-
12:05:03 <L8D> @pl flip (<*>)
12:05:05 <lambdabot> flip (<*>)
12:05:12 <L8D> @pl flip (<$>)
12:05:13 <lambdabot> flip (<$>)
12:05:21 <L8D> U.U
12:05:33 <L8D> :t (<^>)
12:05:35 <lambdabot>     Not in scope: ‘<^>’
12:05:35 <lambdabot>     Perhaps you meant one of these:
12:05:35 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
12:05:43 <Cale> Black0range: The big three web frameworks in Haskell are happstack, snap, and yesod, and then there are lots of other smaller solutions like scotty, and various simpler libraries still.
12:05:54 <L8D> @let (<^>) = flip (<*>)
12:05:58 <lambdabot>  Defined.
12:06:12 <L8D> :t (<^>)
12:06:14 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
12:07:24 <Cale> Black0range: I have a bit of trouble pointing beginners at Yesod, even though I've known a few to have good experiences with it, just because it has all these little not-terribly-well-specified languages that it uses for various tasks that can be kind of mysterious (but possibly very convenient) even if you know Haskell already.
12:07:36 <saml> @hoogle a -> b -> (b a)
12:07:39 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
12:07:39 <lambdabot> Prelude const :: a -> b -> a
12:07:39 <lambdabot> Data.Function const :: a -> b -> a
12:08:09 <Black0range> Calse: thanks will have a look at it
12:08:24 <saml> g a f <==> f a       is there g?
12:08:28 <Hijiri> does anyone have experience implementing Glicko-1?
12:08:34 <Cale> But yeah, maybe something like happstack or snap would be good for you, depending :)
12:08:46 <Cale> They're pretty big as well
12:08:50 <saml> @hoogle a -> (a -> b) -> b
12:08:52 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:08:52 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:08:52 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:09:22 <saml> I want to swap two arguments to $
12:09:30 <L8D> :t flip ($)
12:09:35 <lambdabot> b -> (b -> c) -> c
12:09:35 <Black0range> by the way i just found out that threre are true state in haskell (like MVar) how are these implemented?
12:09:44 <Cale> Black0range: MVar is primitive
12:09:51 <L8D> Black0range: it's actually not state
12:09:51 <saml> thanks
12:10:05 <Hijiri> black oranges are delicious
12:10:13 <L8D> Black0range: The "state" is just held because the threads block until the handover finishes
12:10:22 <Hijiri> in high school, they were one of the only things in the cafeteria not bland
12:10:31 <L8D> Black0range: putMVar just goes into an infinite loop until some other thread does a takeMVar
12:10:36 <L8D> and vice versa
12:10:46 <Cale> Uh, it doesn't busy wait
12:10:53 <Black0range> waait so MVar creates a new thread that keeps a value?
12:10:53 <L8D> welll yes
12:11:03 <L8D> Black0range: it doesn't "keep" the value
12:11:09 <Black0range> is this new thread a green thread?
12:11:12 <Cale> MVar is used for thread communication
12:11:15 <L8D> Black0range: it just waits until something comes along to pass it on
12:11:31 <Cale> I think this level of detail is not what Black0range was asking about really
12:11:44 <Cale> But I'm not sure :)
12:11:47 <L8D> Black0range: you can't do: m <- emptyMVar; putMVar "my value"; v <- takeMVar; print v
12:12:01 <Cale> What?
12:12:03 <L8D> Black0range: MVar's don't store things to be used later
12:12:06 <Cale> Yes you can
12:12:10 <Cale> Yes they do
12:12:18 <zmbmartin> I have two MVars that I take from. Is there shorter more concise syntax for this -> http://lpaste.net/115602
12:12:22 <L8D> Cale: no, because the program would block forever on the first putMVar
12:12:27 <Cale> no it won't
12:12:36 <Cale> L8D: Have you tried this program?
12:12:45 <L8D> I am now
12:13:19 <Cale> ghci> do m <- newEmptyMVar; putMVar m "my value"; v <- takeMVar m; print v
12:13:19 <Cale> "my value"
12:13:41 <Hijiri> zmbmartin: (,) <$> takeMVar r <*> takeMVar m
12:13:45 <Cale> MVar really does allocate a memory location to storing the value
12:13:55 <Hijiri> or liftM2 (,) (takeMVar r) (takeMVar m)
12:13:58 <Hijiri> (or liftA2)
12:14:30 <Black0range> is MVar and IORef the same thing?
12:14:34 <Cale> no
12:14:40 <monochrom> you should test everything you say. and you should publish your test so other people see what you're really testing.
12:14:41 <L8D> Cale: sorry touche
12:14:47 <Cale> An MVar is a memory cell which may be empty or full
12:15:03 <Cale> Writing to a full MVar will block (waiting for it to become empty before succeeding)
12:15:05 <L8D> Cale: I'm thinking of the cases when an MVar is not empty, and the thread blocks until something clears it
12:15:13 <Cale> Reading from an empty MVar will block until it is filled
12:15:16 <L8D> yeah
12:15:20 <L8D> thanks
12:15:20 <Cale> (which will then empty it)
12:15:38 <L8D> so you couldn't do: m <- new
12:15:48 <Cale> An IORef by contrast always has a value, and reads and writes will never block
12:15:56 <L8D> so you couldn't do: m <- newMVar "foo"; putMVar m "bar"; v <- takeMVar m; ...
12:16:30 <Cale> Yes, writing to an already full MVar in a single threaded program is a good way to hang your program forever :)
12:16:46 <Black0range> But in the perspective in how it holds the actuall value? does it make a static memmory block?
12:16:49 <L8D> (also GHC's GC is so awesome that it will detect when there are no remaining references to an mvar when something starts to block and will throw and error
12:17:01 <Cale> Black0range: Both of them allocate a mutable memory location.
12:17:05 <L8D> Black0range: magic
12:17:14 <L8D> or at least, it might as well be magic
12:17:14 <Black0range> So it's an FFI thing?
12:17:22 <Cale> no
12:17:23 <L8D> it should stay as magic to you
12:17:29 <Cale> Neither are part of the FFI spec.
12:17:30 <Black0range> I dont like magic!
12:17:32 <bitemyapp> MVars are native to GHC's RTS. No FFI.
12:17:32 <Black0range> :)
12:17:34 <guesting> Oh wow, the order changes the results in the cabal file dependencies, that makes no sense. It should be easily solvable using recursion, why don't they do that?
12:17:35 <L8D> Haskell is about high-level programming though
12:17:51 <L8D> guesting: which order?
12:17:57 <bitemyapp> MVars are relatively high level as concurrency primitives go. They can be used to simulate queues, channels (a la Erlang), and locks.
12:18:05 <Cale> There's also Chan
12:18:22 <bitemyapp> although Chan is icky under contention. Usually instead of chan you'd use unagi-chan or TBQueue.
12:18:35 <L8D> there's also just Async
12:18:40 <guesting> L8D: I was having dependency issues with my program, but changing the order of the dependencies in the cabal file solved it. Makes no sense, it should be automatic
12:18:44 <johnw> now we're mixing in STM
12:18:46 <bitemyapp> MVars are fair, but they don't guarantee progress. If you want a guarantee that there won't be deadlocks or you want to compose transactions, you want STM.
12:18:55 <bitemyapp> johnw: hey you. Github.
12:19:06 <bitemyapp> johnw: it's really hard to tell which API endpoints are supported based on the docs / source.
12:19:27 <guesting> L8D: I could do it easily in one line of code--for each program just check all instances of it from the minimum and maximum, why doesn't it do that first before trying to install?
12:19:28 <bitemyapp> johnw: I'm trying to figure out if it supports the notifications & events stuff and I couldn't figure it out even after an hour of pilfering the source.
12:19:36 <Cale> A value of type Chan a is a reference to a "channel" of values of type a. Writing to a channel will always succeed, adding the element to a queue of elements to later be read. Reading from an empty channel will wait for the channel to have an entry in it before completing, and will remove the element.
12:19:36 <johnw>  are you talking about the library "github"?
12:19:45 <bitemyapp> johnw: yessir.
12:19:53 <Cale> Values are read in the same order in which they were inserted.
12:19:53 <L8D> guesting: becuase it *should*n't make a difference
12:19:56 <bitemyapp> johnw: it's on your account, even if you hadn't paid it heed lately.
12:19:58 <johnw> bitemyapp:  Log some issues for us then. I'm no longer the primary maintainer
12:20:13 <johnw>  there are two others have been giving a lot more attention than I have been
12:20:17 <guesting> L8D: Then...why did it?
12:20:21 <bitemyapp> johnw: I figured you might not be, thanks.
12:20:30 <Cale> You can think of an MVar as a Chan which is limited to at most one element at a time, blocking the writer whenever it tries to put a second element in too soon.
12:20:34 <L8D> guesting: because there's something wrong with the packages you're installing
12:20:39 <bitemyapp> johnw: I actually already filed one issue, no response.
12:20:42 <dcoutts_> guesting: did you try changing the --max-backjumps?
12:20:47 <guesting> L8D: Maybe.
12:20:53 <bitemyapp> johnw: I can't fix my issue without breaking API compat. Do you know if they'll take PRs that break stuff?
12:21:01 <L8D> guesting: what kind of error were you getting before?
12:21:03 <guesting> dcoutts_: No. Does that determine how many times it checks recursively?
12:21:05 <johnw> bitemyapp: Good question!  I'd try :)
12:21:28 <Cale> Black0range: anyway, there are lots of ways to manage mutable memory locations in Haskell.
12:21:36 <guesting> L8D: Just silly dependency errors. "Oh, you can't install text 1.1 because I'm trying to install text==0.13 because that's the minimum for lens"
12:21:50 <guesting> L8D: Weird stuff like that which makes no sense. It should try to bump it up.
12:21:51 <luite> bitemyapp: why "simulate queues" rather than "implement queues"?
12:21:58 <dcoutts_> guesting: the order can change what order the solver tries to solve things, which can change the solution it picks, or how many it considers, which if you're unlucky can push you over the default backjump limit
12:22:22 <dcoutts_> guesting: we recently increased the default max backjumps
12:22:24 <bitemyapp> luite: MVars are queues.
12:22:28 <dcoutts_> in a recent cabal-install release
12:22:31 <Black0range> Cale: Well thats sweet but i'm just wondering how it does it, since it breaks the philosophy
12:22:36 <bitemyapp> luite: but they're reified into the runtime in a way that is more efficient than most actual queue implementations could pull off.
12:22:45 <Cale> Black0range: Breaks what philosophy?
12:22:48 <bitemyapp> luite: it's just that they're synchronous queues.
12:23:05 <Cale> Black0range: Expression evaluation can never cause any of these things to be read or written.
12:23:06 <Black0range> Cale: stateless
12:23:08 <guesting> dcoutts_: So that must have been the issue. Why doesn't it keep trying until all instances of that package is exhausted? Time?
12:23:22 <bitemyapp> luite: if you want asynchronous unbounded or bounded queues that are competitive with MVar then you use unagi-chan.
12:23:23 <Cale> Black0range: Only execution of IO actions.
12:23:39 <dcoutts_> guesting: you can set max backjumps to -1 to do an exhaustive search, but that can take a long time in bad cases
12:23:45 <Cale> Black0range: Execution of IO actions does have effects, and it is stateful.
12:24:18 <Cale> (the whole point of IO actions is to represent effects to be carried out)
12:24:58 <guesting> dcoutts_: Does it even need to do that? Maybe I'm being naive, but I think it should: recursively get every package required and it's version numbers. For each package, get the maximum minimum it can be (x), and the minimum maximum it can be (y). If y > x, error, else install x.
12:24:59 * hackagebot post-mess-age 0.1.0.0 - Send messages to a Handle concurrently without getting them mixed.  http://hackage.haskell.org/package/post-mess-age-0.1.0.0 (DanielDiaz)
12:25:00 <Cale> But evaluating an IO action doesn't cause it to be executed, any more than opening an executable program in your hex editor would cause it to be run.
12:25:11 <bsdbeard> Guys, how long does it take to compile ghc7.6? It's been doing something for approximately an eternity and still not finished
12:25:21 <bsdbeard> I think it's mocking me
12:25:31 <Cale> bsdbeard: Long enough that you shouldn't do it yourself unless you have a really good reason.
12:25:42 <guesting> dcoutts_: Obviously it must be way more complex than that, but my way seems pretty simple (to me at least)
12:25:43 <bsdbeard> Cale, I had a reason :(
12:25:57 <mauke> a few hours, last time I tried it
12:26:06 <bsdbeard> damn
12:26:08 <Cale> bsdbeard: It depends on the performance of your computer, and you need a working binary GHC to do it in the first place, so it's a little bit silly.
12:26:15 <Cale> Unless you're hacking on it.
12:26:36 <bsdbeard> Cale, 7.6 is not in the repos of my system so I didn't really have a choice
12:26:46 <Cale> Do you really need 7.6 for some reason?
12:26:58 <Cale> Are you trying to run geordi, by any chance? :D
12:27:00 <bsdbeard> Yes, I want to work on geordi and it won't work with 7.4 it seems
12:27:02 <bsdbeard> yess
12:27:02 <Cale> lol
12:27:12 <bsdbeard> how did you know
12:27:13 <Cale> okay, so I've done this for like 3 or 4 people already
12:27:18 <luite> bitemyapp: hmm, i wouldn't say they are queues
12:27:32 <Cale> It's really super easy to update geordi so that a more recent GHC will compile it
12:27:45 <guesting> dcoutts_: Would my way work? I've never contributed to open source other than mine, so if it is viable and you guys don't have time to implement it, I can try
12:27:56 <dcoutts_> guesting: heh, it's far more complex than that. You can encode sudoku in package constraints. It's an NP complete problem.
12:28:00 <bsdbeard> Cale, I guess it's too late for that? it's probably going to finish compiling soon
12:28:24 * monochrom prefers minesweeper to sudoku
12:28:47 <Cale> Well, it's up to you
12:28:54 <Cale> But I think it's silly
12:28:54 <dcoutts_> guesting: don't be put off contributing to things, but the solver isn't a good place to start. We're already using a relatively sophisticated one (taken from some academic papers).
12:28:55 <guesting> dcoutts_: OK, I figured it's more complex. What is adding to the complexity, though? You can just get all required packages easily, and all versions those packages need, right? How is it so complex?
12:29:25 <monochrom> it is simple if you allow exponential time
12:29:29 <Cale> The changes required are like fixing bugs in 2 or 3 lines of code which flaws in the GHC 7.6 typechecker allowed through
12:29:30 <bsdbeard> Cale, If It still doesn't work after it finishes compiling could you explain how to patch geordi so it works with 7.4?
12:30:08 <bitemyapp> luite: they're not queues as you're accustomed to thinking about them no, but they serve the same purpose if you don't mind synchrony and blocking threads.
12:30:08 <guesting> dcoutts_: Oh, I guess each version has different dependencies, that would add a bunch of data unfortunately, I see.
12:30:16 <dcoutts_> guesting: suppose I'm deciding which version of package foo to pick, and I have foo-1.0 and 1.1. Each of those two choices can have different dependencies, and they can have different constraints on dependencies (including ones I might have picked already)
12:30:55 <dcoutts_> guesting: and then repeat that at all levels, and there's no simple way, you get a combinatorial explosion of possibilities to check
12:30:56 <guesting> dcoutts_: And that's where the backjumps or whatever they are called come into play? How deep you wish to go?
12:30:57 <Cale> bsdbeard: Okay, let me just grab the github package again so as to be able to remind myself of what needed doing.
12:31:14 <bsdbeard> :D
12:31:30 <dcoutts_> guesting: right, we're using a particular kind of constraint solver, and the backjumping is often called backtracking in other contexts.
12:31:35 <bsdbeard> Cale, Thanks :) I should have asked here before deciding to compile ghc
12:31:56 <dcoutts_> though we're using conflict-directed backjumping
12:32:06 <guesting> dcoutts_: OK. So my solution is naive as I thought haha. Well as long as I understand that I should be upping the backjumping it should be alright
12:35:16 <Cale> bsdbeard: Also, it's 7.8.3 which you'll want to install, if you'd rather do things the right way :)
12:36:00 <FofG> At the risk of starting a way, anyone have thoughts on Rust? ;)
12:36:13 <FofG> people swearing to me that its a pure FP language
12:36:19 <Cale> FofG: It's not
12:36:30 <FofG> i did not think so
12:36:38 <kadoban> Rust? No, it's really not... It seems like a decent alternative to C++ to me though.
12:37:06 <bsdbeard> Well it just finished compiling... it's 3.5 gigabytes
12:37:35 <kadoban> Woh, what's 3.5 gigs? That's a big program
12:38:13 <FofG> kadoban: bad lang for doing FP?
12:38:42 <bsdbeard> Cale, I'm a bit lost, what do I do now? install the .debs it generated? ghc_7.6.3-20_i386.deb and such? or do I need to remove ghc7.4 first?
12:38:48 <simpson> FofG: It qualifies as a functional programming language. This isn't the channel for language comparisons, though.
12:38:55 <kadoban> FofG: I'm not sure, I've really only used it a bit. It seems to have some nice features that you usually find in functional langagues that I like, so it might be fine
12:39:32 <sivteck> Only Haskell gets the Haskell Seal of Approval in #haskell.
12:39:32 <Cale> bsdbeard: It shouldn't be necessary to remove the old GHC first, though you might want to just to save space
12:40:23 <FofG> sivteck: hehe, 'course
12:40:28 <bsdbeard> It made a lot of .debs, I'm assuming I need all of this? ghc-prof ghc-doc,  ghc, haddock, ghc-dynamic, etcc
12:41:51 <zmbmartin> Hijiri: Is there an easy way to do the that in one line with the let (r, m) = v; (,) <$> takeMVar r <*> takeMVar m
12:43:20 <Cale> bsdbeard: yeah, for some reason the debian packages are really split up into tiny pieces which the normal binary distribution of GHC doesn't really have (though haddock is a separate thing)
12:43:54 <Cale> It's a bit silly, as leaving out any of those pieces will break very common assumptions about what a GHC install looks like :P
12:45:18 <Zemyla> Is it possible to get the numerator and denominator of a Rational?
12:45:25 <Cale> :t numerator
12:45:29 <lambdabot> Integral a => Ratio a -> a
12:45:33 <Cale> :t denominator
12:45:37 <lambdabot> Integral a => Ratio a -> a
12:45:50 <Cale> Rational is a synonym for Ratio Integer
12:45:52 <Zemyla> Okay, awesome.
12:46:00 <nitrix> Hello, I'm trying to compose a function that'd look like this:    fst . (<)
12:46:12 <bsdbeard> Cale, is this normal? http://termbin.com/yil4
12:46:25 <Cale> nitrix: The result of (<) will be a function producing a Bool...
12:46:46 <kadoban> nitrix: I don't think that makes sense. What's it supposed to do?
12:46:53 <nitrix> Oh crap.
12:46:58 <nitrix> So (<) . fst
12:47:04 <Cale> bsdbeard: argh
12:47:10 <kadoban> :t comparing
12:47:12 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
12:47:25 <kadoban> :t comparing fst
12:47:25 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
12:47:44 <nitrix> That's indeed what I'm doing, a bit more elaborated though.
12:47:47 <kadoban> Maybe that helps? There might be another one that's closer, I don't know it though.
12:48:02 <nitrix> comparing ((<) . fst) is what I have right now
12:48:06 <nitrix> :D
12:48:13 <flyingfisch> is there any way to use Reader vars in modules? I am probably asking that wrong, but basically, here is my module: https://github.com/flyingfisch/haskell-fischbot/blob/master/Irc/Write.hs
12:49:02 <flyingfisch> I am trying to get the socket
12:49:31 <flyingfisch> and it tells me socket is not in scope
12:49:50 <Cale> bsdbeard: I think the packages that it's complaining about are packages for 7.4, but I don't know why it's doing whatever it is that it's doing.
12:50:05 <bsdbeard> Cale, well it seems to work fine? ghc reports it's 7.6
12:50:06 <nitrix> Awww...
12:50:07 <Cale> bsdbeard: Did the install actually complete?
12:50:08 <nitrix> No instance for (Ord (Integer -> Bool)
12:50:18 <Cale> bsdbeard: Yeah, okay, run ghc-pkg check
12:50:40 <Cale> bsdbeard: and see if it reports similar errors
12:50:45 <Cale> if not, then you should be fine
12:50:45 <kadoban> :t (<) . fst
12:50:47 <lambdabot> Ord b => (b, b1) -> b -> Bool
12:50:57 <Cale> bsdbeard: I think it's just that something screwed up your 7.4 packages
12:51:01 <bsdbeard> Cale, ghc-pkg check outputs the same warnings that were in the previous paste
12:51:03 <kadoban> nitrix: So yeah, that doesn't quite fit.
12:51:04 <Cale> oh
12:51:04 <nitrix> I'll scratch the code and redo it, I think I got lost.
12:51:05 <Cale> hmm
12:51:09 <Cale> which ghc-pkg
12:51:22 <bsdbeard> /usr/bin/ghc-pkg
12:51:41 <bsdbeard> Cale, can't I just update the libraries it's complaining about?
12:51:50 <Cale> ls -l /usr/bin/ghc-pkg
12:52:02 <bsdbeard> │/usr/bin/ghc-pkg => ../lib/ghc/bin/ghc-pkg
12:52:11 <Cale> heh, no version number again?!
12:52:14 <Cale> wtf
12:52:18 <bsdbeard> :o
12:52:30 <bsdbeard> GHC package manager version 7.6.3
12:52:33 <bsdbeard> ghc-pkg --version
12:52:36 <sinelaw> why is head evil?
12:52:40 <sinelaw> why not [a] -> Maybe a?
12:53:09 <Cale> Yeah, the problem here is that usually everything is version numbered so that installing multiple GHCs won't cause a problem
12:53:43 <bsdbeard> hmm
12:53:49 <Cale> But somehow the GHC 7.4 probably had its libraries sitting in an un-versioned directory, and the new GHC is using the same location
12:53:51 <Zemyla> @pl \n d -> d == (denominator (n % d))
12:53:54 <Cale> and everything's messed up
12:53:55 <lambdabot> ap (==) . (denominator .) . (%)
12:54:22 <flyingfisch> so it isn't possible to get values from runReaderT in a module?
12:54:33 <flyingfisch> I have to directly pass them through the function arguments?
12:55:00 * hackagebot git-annex 5.20141203 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141203 (JoeyHess)
12:55:02 <Cale> bsdbeard: What I would do at this point is just to uninstall all these packages, and install the generic linux binary GHC 7.8.3 which can be obtained from the GHC website, that'll require no compiling, and will give you a non-screwy installation.
12:55:20 <bsdbeard> Cale, that one is for 64 bit linux, mine is 32 bit
12:55:24 <bsdbeard> =/
12:55:30 <Cale> There are both
12:55:35 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_3#x86linux
12:55:43 <bsdbeard> huh
12:55:52 <cerberusiscute> can someone explain type signatures to me? I get the point point of them, but I don't understand how to write one properly.
12:55:53 <Cale> Check which version of libgmp is on your system
12:55:55 <bsdbeard> oh I looked at haskell-platform.org I think
12:56:27 <Hafydd> jle`: yes, but some would say that's a mistake in the language, and there should be a separate class for arithmetic sequences -- because for certain number types, like Ratio Integer, it's impossible to establish a one-to-one correspondence between its elements and the integers while also respecting ordering.
12:56:34 <Cale> cerberusiscute: In a short while, I can give you a tutorial if you like.
12:56:57 <Hafydd> And even for cases like Double, it's so impractical that nobody would really do that.
12:57:00 <Cale> cerberusiscute: You might get more immediate help if you ask a more directed question than that -- there's a lot of stuff going on in type signatures.
12:57:01 <cerberusiscute> Cale: yes please. and thank you!
12:57:09 <bsdbeard> Cale, libgmp10 version 2:5.0.5+dfsg-2
12:57:46 <flyingfisch> nvr
12:57:48 <Cale> bsdbeard: Okay, so you'll want one of the second pair of downloads from that link I gave you, the ones which were built on the Debian 7 system.
12:57:56 <cerberusiscute> I just need something to get me started in writing them and designing a function that follows that type signature.
12:58:00 <Hafydd> But maybe "if the Haskell98 committee did it, I can do it too" is a good enough reason.
12:58:06 <flyingfisch> i just found a stackexchange answer telling me what i needed to know ;)
12:58:14 <Cale> (they're the same thing, just compressed with a different compressor)
12:58:32 <bsdbeard> Cale, thanks for all the help! I hope this works
12:59:16 <Cale> bsdbeard: and then once you have that installed, we'll do something to get you a new cabal-install if needs be, and then you should be set up nicely :)
12:59:45 <bsdbeard> and then I can pretend I know what I'm doing by mutilating the geordi source
12:59:59 <bsdbeard> >:-)
13:00:03 <Cale> okay, so interestingly, it seems that the changes that I made ended up being contributed back to the github repo
13:00:34 <Cale> So you'll just be able to build this version https://github.com/Eelis/geordi once that's done
13:00:40 <bsdbeard> someone contributed your changes under their own name?
13:01:16 <Cale> Yeah, I'm too lazy to do it myself, so I think I told them to get in touch with the author for me
13:01:28 <bsdbeard> he's here on IRC all the time
13:02:56 <Cale> Yep, https://github.com/Eelis/geordi/blob/master/src/ErrorFilters.hs#L75 the () on this line and the two subsequent lines are the fix that needed applying
13:03:18 <bsdbeard> it's that simple ? damn
13:03:43 <bsdbeard> looks like I've tried to solve a trivial problem with a rocket launcher
13:04:18 <monochrom> the characteristic of XY problems
13:04:33 <monochrom> and depth-first search
13:06:27 <Cale> monochrom: It's pretty funny, I recall seeing a StackOverflow answer about this where people just decided that staying with GHC 7.6 forever rather than fixing the bug in the code so that it would pass 7.8's typechecker was the best solution. (The instances in the code blatantly violated the functional dependency, but GHC 7.6 had a bug which allowed them)
13:07:16 <monochrom> one cannot stay with 7.6 forever.
13:07:27 <monochrom> however, one can stay with 7.6 for one lifetime.
13:07:42 <dfeuer> Cale, I'm struggling with some ... arithmetic, I guess, for Seq's <*>. For fs<*>xs, I want to represent a "segment" of the result that I can split up. edwardk suggests holding fs, xs, and some extra numbers, saying that's more efficient than the double fmap. But I keep banging into a wall with these calculations.
13:07:50 <dfeuer> Can you suggest a clean way to do it?
13:08:22 <dfeuer> [once fs is down to one element, everything changes, and xs starts splitting for real]
13:09:20 <Black-Heaven> Is there a way of 'Extract' the base type of the applications of types on a parametrized type? Thanks in advance for your help. (I think of something like that: http://lpaste.net/115604)
13:10:18 <bsdbeard> monochrom, jokes on you, I'm immortal.
13:13:05 <Cale> Black-Heaven: That sounds like maybe an XY problem to me. Is there really a good reason that you need to do this?
13:13:09 <chrisdone> perfect example of when a decent value inspector comes in handy: https://www.youtube.com/watch?v=3SLVp2U0dhI
13:13:12 <bsdbeard> Cale, is the .xz and .bz2 version the same?
13:13:17 <Cale> bsdbeard: Yes.
13:13:30 <Cale> bsdbeard: .xz is just way better at compressing source code
13:13:36 <dfeuer> Cale, you catch my question?
13:13:37 <Cale> er, binaries
13:13:42 <bsdbeard> I see
13:13:45 <Cale> dfeuer: yes, but I didn't understand what you were asking
13:13:50 <bsdbeard> impressive difference 60mb/120mb
13:13:53 <Cale> yeah
13:14:22 <Cale> dfeuer: Or perhaps you hadn't gotten to your question yet :)
13:15:02 <dfeuer> OK. Basically, I want to calculate fs <*> xs for sequences. So this looks something like [[f1 x1, f1 x2], [f2 x1, f2 x2],...]
13:15:04 <dfeuer> er ...
13:15:10 <dfeuer> sorry, the join of that.
13:15:55 <monochrom> bsdbeard: I am 160 years old. I supervised Church's thesis.
13:16:07 <dfeuer> The *concept* is to take that unjoined sequence and write a function that can split it.
13:16:10 * Hodapp grumbles about Atom having no damn documentatio
13:17:12 <dfeuer> So split 3 of that thing would be ([[f1 x1, f1 x2], [f2 x1]], [[f2 x2], [f3 x1, f3 x2]])
13:17:22 <dfeuer> See the drift, Cale?
13:17:27 <Cale> yeah
13:17:52 <dfeuer> But edwardk suggests representing this as  Thingy fs xs [somenumbers] instead of the actual thing to actually join.
13:18:11 <Cale> I think I also suggested something similar to that
13:18:13 <Cale> at one point
13:18:14 <dfeuer> But I'm really struggling to find a representation that leaves my sanity intact.
13:18:16 <dfeuer> Ah.
13:18:20 <dfeuer> I may have forgotten.
13:18:22 <bsdbeard> monochrom, but you didn't save turing!
13:18:36 <Cale> Yeah, the details are going to be obnoxious
13:18:40 <dfeuer> I keep writing completely unreadable code that's also wrong, which is a bad combo.
13:18:50 <Cale> If it were just left to me, I wouldn't even bother with this optimisation :P
13:19:07 <dfeuer> Well, I couldn't even get the *unoptimized* version working!
13:19:17 <Cale> Because really, how often do people even use the Applicative instance on Data.Sequence?
13:19:23 <dfeuer> No idea!
13:19:37 <Cale> Is there even one use in the wild? Maybe one or two, but it's pretty weird.
13:19:47 <dfeuer> Hmph.
13:20:17 <dfeuer> Even without that optimization, though, it is still not so easy for me to calculate.
13:20:18 <Cale> If people were using it, I think something like this would definitely be worth doing.
13:20:28 <Cale> Well, you're going to be doing a bunch of div and mod
13:20:35 <dfeuer> Yes, that part is clear.
13:20:46 <dfeuer> What's less clear is the details.
13:20:55 <dfeuer> So many details.
13:21:10 <Cale> Yeah, if you're doing cuts at both ends...
13:21:18 <dfeuer> Uh-huh.
13:21:35 <dfeuer> So do you hold how many are in the front and the back?
13:21:42 <dfeuer> Or how many have been cut from the front and back?
13:21:54 <dfeuer> Or where the thing starts at the front and where it ends at the back?
13:22:02 <dfeuer> Are any of these conducive to sanity?
13:22:03 <Cale> at least in the front: you could compute how many were in the back from the length and the step size
13:22:14 <Cale> well
13:22:25 <Cale> Yeah, you could also do them as offsets into the original list
13:22:50 <Cale> which would let you compute everything at the expense of maybe being a little awkward for the recursion
13:23:00 <dfeuer> Hmm?
13:23:31 <dfeuer> There is no recursion here.
13:23:37 <dfeuer> That's elsewhere.
13:24:12 <Cale> Oh, you're just focused on a single split for now?
13:24:33 <dfeuer> Yeah. Just how to make one split of the fs+xs+numbers representation.
13:24:33 <Cale> Well, you're still going to be traversing this structure, aren't you?
13:24:36 <Cale> Or...
13:24:40 <Cale> Well, I dunno
13:24:41 <dfeuer> splitAt
13:24:59 <dfeuer> Somebody else is traversing it for me.
13:27:15 <bsdbeard> Cale, I installed the binaries, but my cabal-install is 0.14.0, the website says it should be 1.18
13:28:20 <Cale> bsdbeard: Try  cabal install cabal-install  and see if that works. If it does, then make sure that ~/.cabal/bin is in your PATH and/or convert it into a symlink to ~/bin so that the newly installed cabal is the one which gets used
13:28:21 <carter> 0.14 and anything else before 0.16 was a painful erra
13:28:40 <Cale> If *not*, then we can grab a tarball of it off of Hackage to get you started.
13:28:52 <bsdbeard> looks like it's working, says it's getting cabal 1.20
13:28:57 <Cale> cool
13:29:09 <bsdbeard> (:
13:29:50 <carter> which version of BSD?
13:30:19 <schell> this may be a silly question - if my server is gnu/linux x86_64 (arch linux) and i compile my haskell binary on some other gnu/linux x86_64 OS - can i use that binary on both?
13:31:10 <bsdbeard> schell, this depends on a lot of factors, all the libraries must be compatible (i.e. same libc6)
13:31:11 <tasker> I keep hearing about boxed vs unboxed arrays. What does this mean? Can anyone point me to a summary ?
13:31:43 <schell> bsdbeard: i see - so really i should just build on the target OS
13:31:44 <bsdbeard> oh wait I miread that
13:31:52 <haasn> tasker: unboxed basically means that the value is stored in the array directly, rather than a pointer to the value
13:31:55 <bsdbeard> schell, no I misread your question, ignore me
13:32:03 <Black-Heaven> Cale: I want to change (D A B C) to (D, [A, B, C])
13:32:07 <fizbin> Anyone know anything like QSem or SafeSemaphore that provides a LIFO semaphore?
13:32:19 <Cale> tasker: In order to support both lazy evaluation, and polymorphism, all ordinary values in Haskell are "boxed" which means that they are essentially pointers (pointers to code, actually)
13:32:19 <haasn> tasker: eg. for an unboxed Int array you'd store [1,2,3,4,5] rather than [1p,2p,3p,4p,5p] with 1p -> 1; 2p -> 2; 3p -> 3; 4p -> 4; 5p -> 5;
13:33:04 <tasker> Cale, haasn: So presumably this has performance implications ?
13:33:08 <Cale> tasker: Or in general, that the implementation will package them up in some way so that they look the same in memory, and code can operate on them polymorphically. Only one version of 'map' is ever compiled for instance.
13:33:16 <tasker> Why would you ever not use a boxed array ?
13:33:28 <Cale> tasker: Yes, so that's another layer of indirection.
13:33:39 <ReinH> tasker: performance
13:33:52 <haasn> tasker: Dereferencing pointers takes time
13:33:58 <Cale> Having an array of pointers to code which when entered will return you an Int value, is way more expensive in terms of both time and space than an array of physical machine ints
13:34:04 <tasker> Hm, okay. Could you give me an example of when this would be useful?
13:34:05 <haasn> Iterating over [1,2,3,4,5,6,7,8,9,10] is very fast
13:34:09 <carter> schell: if libgmp has the same name on both servers, youre probably OK
13:34:27 <ReinH> Time and space :)
13:34:30 <haasn> Iterating over 10 points, dereferencing each one by one, running the code located behind it, updating the result and then jumping back into the loop, is slow :)
13:34:31 <tasker> It just seems like unboxed values must be of limited use :P
13:34:33 <haasn> Make sense?
13:34:40 <haasn> 10 pointers*
13:34:51 <ReinH> Also boxes take up space, so unboxed values are smaller
13:34:51 <tasker> haasn: Yeah, I see that!
13:35:03 <schell> cool, thanks carter
13:35:03 <ReinH> tasker: see also https://www.haskell.org/haskellwiki/Performance/GHC#Unboxed_types
13:35:05 <carter> haasn: btw, ttuegel  has given me some really neat ideas for how one might do a lazy flavored language that has more agressive unboxeing
13:35:06 <Cale> tasker: The advantage of the pointers being that 1) you can use circular recursive definitions to define the array elements, and they'll be computed on demand, and 2) you can use fully polymorphic operations on such arrays which will work regardless of the type of elements stored.
13:35:12 <carter> schell: basically , try it and see what happens
13:35:18 <carter> you'll get a linker error ow hateve
13:35:24 <schell> carter: that’s my next step, haha
13:35:27 <schell> just do it
13:35:40 <Cale> tasker: So unboxed arrays give up both of these features in order to have a more compact representation, specialised to the type of elements being stored
13:35:47 <haasn> tasker: The trade-off between strict and lazy, in the general sense, is that sometimes it takes less time to just compute the values and throw them away, then decide which values you actually need
13:36:04 <Cale> tasker: If you use an unboxed array of Bool values for instance, they actually get packed into contiguous bits
13:36:08 <haasn> tasker: For the former, you'd use strict/unboxed structures
13:36:32 <flyingfisch> @hoogle liftIO
13:36:33 <haasn> And by “sometimes” I mean “often enough to be of importance”
13:36:34 <tasker> Cale, haasn: Ahh, okay
13:36:37 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
13:36:37 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
13:36:37 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
13:36:39 <bsdbeard> Cale, it worked, cabal is now 1.20 and in my PATH, now I can compile geordi from the github source?
13:37:02 <tasker> So if you were every doing e.g. scientific computing, you would be using unboxed arrays of whatever appropriate numeric type ?
13:37:04 <Cale> bsdbeard: yep, just go to the src directory and run 'cabal install' and it should work
13:37:05 <haasn> tasker: Our modern machines are especially suited for iterating contiguous chunks of memory; rather than reducing graphs
13:37:21 <haasn> Iterating through an array is one of the fastest operations we have access to, faster than recursion, etc.
13:37:42 <Denommus> Cale: bsdbeard: I'd recommend running cabal sandbox init before running cabal install
13:38:16 <bsdbeard> Denommus, oh
13:38:29 <bsdbeard> Denommus, do I do that before cabal update?
13:38:48 <Denommus> bsdbeard: no, you may run cabal update outside of a sandbox, no problem
13:39:01 <bsdbeard> ok, it's updating :-)
13:39:11 <bsdbeard> Denommus, Hey I remember discussing FRP with you
13:39:14 <Denommus> bsdbeard: it's just that  without cabal sandbox you're always under a global environment, which is easier to fuck up when you're working on multiple projects
13:41:00 <Denommus> bsdbeard: speaking of which, if you want to use a local dependency for a library (say, you tried to add the library as a dependency, but while running cabal install its compilation failed), you may run somewhere cabal fetch <library>, make your changes, and then, in your project's directory, run cabal sandbox add-source <path-to-the-local-library>
13:41:04 <Cale> Denommus: uhhh
13:41:10 <Cale> Denommus: oh, yeah, okay
13:41:25 <hexagoxel> might be time to mention "require-sandbox: True" in .cabal/config
13:41:37 <hexagoxel> Denommus: s/cabal fetch/cabal get/ ?
13:41:58 <Denommus> hexagoxel: bsdbeard: oh, right! Sorry
13:43:55 <tasker> holy shit, unboxed arrays are incredibly fast
13:44:08 <StoneCypher> credibly*
13:44:54 <Cale> tasker: Yeah, it's a big difference, when it works :)
13:46:30 <bsdbeard> Denommus, So here's a question about sandboxes, it's currently installing 43 packages, if I ever need one of them in a different directory, will it re-download it or use the local version?
13:47:08 <c_wraith> bsdbeard: it may redownload, or use a cached download.  Doesn't really matter, because it'll always recompile, and that's the slow part.
13:47:16 <monochrom> bsdbeard: regarding saving Turing, at least I wrote this joke: https://plus.google.com/102208456519922110915/posts/RdfEqPNZgwT
13:48:13 <bsdbeard> monochrom, :)
13:50:02 * hackagebot groundhog-inspector 0.7.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-inspector-0.7.1 (BorisLykah)
13:50:04 * hackagebot hexpat-lens 0.1.2 - Lenses for Hexpat.  http://hackage.haskell.org/package/hexpat-lens-0.1.2 (JosephAbrahamson)
13:53:45 <bsdbeard> argh cabal: Error: some packages failed to install:
13:54:14 <bsdbeard> failed to install geordi :-(
13:57:28 <pgiarrusso> Hi all!
13:57:55 <pgiarrusso> I’m trying to understand the free theorem mentioned in this message: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/15382/focus=15384
13:58:29 <pgiarrusso> It says that if f is a Functor, and we have foo :: (a -> b) -> f a -> f b, then by the free theorem we get
13:58:30 <pgiarrusso> foo (g . f) = fmap g . foo f
14:01:10 <pgiarrusso> But why does fmap show up on the right-hand side?
14:06:39 <mauke> @free foo :: (a -> b) -> [a] -> [b]
14:06:39 <lambdabot> g . h = k . f => $map g . foo h = foo k . $map f
14:07:31 <mauke> with f = id:  g . h = k . id  =>  $map g . foo h = foo k . $map id
14:07:53 <mauke> g . h = k  =>  $map g . foo h = foo (g . h)
14:08:01 <mauke> er
14:08:12 <mauke> I already substituted k. I don't need the precondition
14:08:28 <mauke> this is all handwavy because I don't understand @free
14:12:32 <JagaJaga> Guys, do you use cps?
14:13:09 <johnw> JagaJaga: now and again
14:14:07 <JagaJaga> Continuation passing style. Cont, callCC etc
14:14:13 <johnw> yep
14:14:22 <JagaJaga> johnw: what for?
14:14:51 <johnw>  for lots of things; do you have a specific question in mind?
14:15:00 <monochrom> one could say, every time you use do-notation or >>=, you're doing CPS
14:15:00 <JagaJaga> I've read some docs, but can really get it's opportunities :(
14:15:00 <bsdbeard> Cale, did you have this problem when compiling geordi? "error: ‘ORIG_RAX’ undeclared"
14:15:16 <JagaJaga> s/can/can't
14:15:47 <Cale> bsdbeard: I only compiled the Haskell part of it
14:15:56 <johnw> CPS can be very handy for handing a resource to a function while maintaining the lifetime of that resource in the function doing the calling.   This pattern is very commonly given the name 'with*'
14:15:56 <Cale> bsdbeard: That looks like a C++ error?
14:16:23 <bsdbeard> Cale, says the error is in "Sys.hsc", never seen a .hsc file before
14:16:29 <Cale> bsdbeard: If you're getting that from running cabal install in the src directory, then I didn't get that one
14:16:36 <fugyk> I want to take part in gSoc. I am learning haskell and I am loving it but I haven't taken part in any haskell open source project. Where to start now?
14:16:38 <bsdbeard> yes I'm running cabal install
14:16:40 <monochrom> one could say, callback = continuation
14:17:05 <monochrom> so every time you author or use a library that insists on callbacks, you're doing CPS
14:17:07 <Cale> bsdbeard: ah, .hsc is foreign function interface stuff
14:17:40 <Cale> syscall_off = (#const ORIG_RAX) * 8 -- must come from this
14:17:40 <bsdbeard> hmm
14:17:56 <fugyk> I want to take part in gSoc. I am learning haskell and I am loving it but I haven't taken part in any haskell open source project. Where to start now?
14:18:38 <Cale> $ grep ORIG_RAX /usr/include/sys/reg.h
14:18:38 <Cale> # define ORIG_RAX 15
14:18:40 <Peaker> Can a type family be rankN? i.e:  type Family inst = forall a. a   ?
14:18:47 <mauke> Cale: that looks like ptrace kind of stuff
14:18:49 <monochrom> winter is coming. and you're already planning for gsoc :)
14:18:56 <Cale> bsdbeard: ^^
14:19:11 <JagaJaga> johnw: monochrom: well, I can get the cps in operation system programming and it's really handy there. Callbacks for example (as monochrom said). But somewhere else?
14:19:26 <bsdbeard> Cale, I don't even have /sys/
14:19:28 <fugyk> I want to take part in some open source haskell to learn more
14:19:29 <bsdbeard> heh
14:19:32 <bsdbeard> =(
14:19:35 <monochrom> watch the new season of Game of Thrones: the GSoC wars :)
14:20:09 <_2_kels_452> Will someone be my friend
14:20:17 <bsdbeard> Cale, /usr/include/i386-linux-gnu/sys/reg.h:# define ORIG_RAX 15
14:20:23 <Peaker> apparently not -- which makes MTPC's more powerful than type families
14:20:31 <koala_man> sigm
14:20:37 <koala_man> *coughs*
14:20:38 <mauke> bsdbeard: what OS is this?
14:20:40 <Cale> bsdbeard: Might work just to change the #include in the .hsc file
14:20:45 <bsdbeard> mauke, debian
14:21:00 <mauke> bsdbeard: do you have the package libc6-dev?
14:21:04 <bsdbeard> ofcourse
14:21:17 <mauke> :-(
14:21:20 <mauke> build-essential?
14:21:20 <Cale> _2_kels_452: If that friendship largely consists of answering your questions about the Haskell programming language, then you've come to the right place!
14:21:34 <johnw> Cale: great answer :)
14:21:40 <_2_kels_452> ok
14:22:23 <bsdbeard> *haskell* - brings people together (generic music playing in the background)
14:22:26 <Cale> Otherwise, if you're a Haskell programmer (or even if not) who wants to talk about offtopic stuff, maybe #haskell-blah would be more appropriate
14:24:09 <monochrom> JagaJaga: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
14:25:04 * hackagebot groundhog-inspector 0.7.1.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-inspector-0.7.1.1 (BorisLykah)
14:28:29 <pgiarrusso> mauke: thanks for your answer (just noticed)
14:28:53 <pgiarrusso> @free Functor f => (a -> b) -> (f a -> f b)
14:28:53 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
14:29:10 <pgiarrusso> @free (a -> b) -> (f a -> f b)
14:29:10 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
14:29:20 <mauke> yeah, I substituted [] for f because lambdabot is weird
14:30:04 * hackagebot wordpass 1.0.0.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-1.0.0.0 (MichalGajda)
14:31:19 <jfischoff> For some reason bracket is not calling my finalize action when the initialize action throws an exception, what could be going wrong?
14:32:17 <bitemyapp> jfischoff: mask?
14:32:18 <monochrom> that is intended.
14:32:51 <pgiarrusso> mauke: I see that… the 2 free theorem generators I’ve seen don’t support type constructors
14:33:00 <mauke> :t bracket
14:33:01 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:33:03 <jfischoff> is it possible that the initialize action could be unmasking exceptions?
14:33:15 <mauke> jfischoff: what
14:33:29 <mauke> the finalizer takes an 'a'. you don't have an 'a'
14:33:40 <monochrom> no, bracket simply won't call the finalizer for initializer exceptions
14:33:45 <pgiarrusso> mauke: going to take a look at http://dl.acm.org/citation.cfm?id=1596577. But thanks!
14:33:47 <jfischoff> ah
14:33:50 <jfischoff> there you go
14:34:00 <monochrom> and because of what mauke says
14:34:49 <shachaf> You can use any "concrete" (uppercase) type with @free, and it'll be assumed to be a functor.
14:35:15 <shachaf> Has there been a big regression in ghci startup time?
14:35:51 <shachaf> It takes ~2.5 seconds to start up now.
14:36:15 <mauke> @free foo :: (a -> b) -> F a -> F b
14:36:15 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
14:37:28 * shachaf looks at what people were originally trying to figure out.
14:38:27 <shachaf> Oh, that thing.
14:44:52 <JagaJaga> monochrom: thx. Nice example
14:45:25 <JagaJaga> monochrom: but it stills being specific for me :/
15:13:49 <mikeg__> Hi. I have a cabal sandbox, and I expected to see some docs in my .cabal-sandbox/share/doc/. However all the directories in there only contain licenses! Is there a way to download the haddock documentation for all the packages I've installed?
15:15:47 <kadoban> mikeg__: Do you have "documentation: True" in your cabal config?
15:17:01 <lifter> 24 days of GHC extensions == many days of refactoring
15:17:15 <mikeg__> kadoban: that was it, thanks very much!
15:17:33 <kadoban> 'welcome
15:23:27 <flyingfisch> I am getting this error and I can't figure out why... http://pastie.org/9759300
15:23:37 <flyingfisch> here is my code: https://github.com/flyingfisch/haskell-fischbot/blob/master/fischbot.hs
15:25:17 <flyingfisch> oh wait
15:25:21 <flyingfisch> i know now
15:25:23 <flyingfisch> nevermind
15:33:49 <dfsjdkljfls> @lambdabot help
15:33:49 <lambdabot> Unknown command, try @list
15:33:55 <dfsjdkljfls> @lambdabot @list
15:33:55 <lambdabot> Unknown command, try @list
15:34:30 <mauke> this isn't twitter
15:34:57 <dfsjdkljfls> @pointfree \x -> x + 2
15:34:57 <lambdabot> Unknown command, try @list
15:35:19 <mauke> @pointless \x -> x + 2
15:35:19 <lambdabot> (2 +)
16:06:52 <Malcolm> What do you think, guys? http://payripo.com/?share=7080 Is this real or just another bullshit?
16:07:06 <indiagreen> @where ops
16:07:06 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:07:11 <johnw> here
16:07:24 <glguy> bot already klined
16:11:19 <mgaut72> hey #haskell,  I am working on some linear algebra programs, and think I want dependently typed matrices and vectors.  is there an existing library for dependently typed things, or do people tend to roll their own depending on their applications?
16:12:28 <peddie> mgaut72: you might try http://hackage.haskell.org/package/hmatrix-0.16.0.6/docs/Numeric-LinearAlgebra-Static.html (sizes in types built on hmatrix)
16:12:35 <nitrix> Are modules able to call functions from their parents?
16:12:40 <peddie> mgaut72: but I have never used that and can't vouch for it :)
16:12:52 <mgaut72> thanks peddie, Ill check it out
16:13:16 <peddie> mgaut72: http://dis.um.es/~alberto/hmatrix/static.html seems to be a related tutorial, but I don't know whether it's up to date with the library
16:16:12 <hcore> is there a more efficient way to determine factors of a number than simple list comprehension? factors n = [x | x <- [(n-1),(n-2)..n], n `mod` x == 0]
16:16:38 <hcore> most of my searches show up efficient ways of doing prime factors but im trying to just find factors
16:19:29 <NemesisD> hey folks. I'm kind of curious why GCHi doesn't respond to ^C if you do something silly like length (repeat 0)
16:20:41 <hcore> NemesisD, it does on my machine
16:20:45 <Welkin> it does
16:20:55 <hcore> running the latest version of kubuntu and using their terminal
16:20:57 <ion> Just wait for a while, it’ll respond right after evaluating that.
16:22:07 <NemesisD> hmm, i'm running ghc 7.6.3
16:22:07 <ion> 7.8.3 on my computer doesn’t respond to ^C, ^\ or SIGTERM
16:22:24 <dmj`> same
16:23:14 <NemesisD> i wonder if its a threading thing, like ghci isn't using the threaded runtime?
16:23:45 <hcore> hrmm looks like it doesn't on the silly length (repeat 0)
16:24:32 <flyingfisch> @hoogle liftIO
16:24:32 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
16:24:32 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
16:24:32 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
16:25:15 <NemesisD> yay. i'm not crazy
16:26:55 <ion> FWIW, this evidence is not enough to draw that conclusion.
16:28:30 <NemesisD> hehe
16:36:35 <iteratee> Anyone else used a continuation based either before?
16:36:41 <iteratee> Something like this:
16:36:43 <iteratee> newtype ContEitherT m l r = ContEitherT { runContEitherT :: (forall z. (l -> m z) -> (r -> m z) -> m z) }
16:37:06 <monochrom> trifecta may be like that
16:37:19 <fread2282> is there any way I can get ghc to output post-inlining haskell? (or is inlining done on core? if then, can I disable inlining for module-external functions?)
16:38:07 <shachaf> Inlining is done on Core.
16:42:46 <fread2282> is there any way I can tell ghc to inline everything?
16:43:32 <fread2282> an argument that puts INLINE pragmas everywhere or something
16:44:52 <cdk> fread2282: I don't think you want to inline everything. In particular it's not a good idea to always inline recursive functions.
16:45:31 <shachaf> Well, GHC doesn't do that even when it is a good idea.
16:45:41 <lpaste> hcore pasted “prime” at http://lpaste.net/115612
16:45:54 <hcore> haha! i can now calculate primes in a reasonable time
16:46:02 <hcore> same with rhymes
16:47:41 <sipa> cdk: it's pretty much impossible to inline (all) recursive function calls without ending up with an infinitely-sized binary
16:48:05 <cdk> sipa: that's the point I was trying to make to fread2282
16:49:07 <shachaf> I'm pretty sure fread2282 didn't mean that by "inline everything".
16:56:00 <Zemyla> @pl \g -> g (:) []
16:56:01 <lambdabot> flip ($ (:)) []
16:56:59 <dmj`> :t flip ($ (:)) []
16:57:00 <lambdabot> ((a -> [a] -> [a]) -> [t] -> c) -> c
16:57:10 <tommd> I'm driving home soonish.  1) I'll be stuck for a bit on the Broadway bridge.  2) I live like 10 blocks from this week's beering so you could walk from my place if you'd like (0.8 miles, 15 minute walk).
16:57:36 <dmj`> tommd: good to know, thanks for keeping me in the loop
16:57:52 <tommd> dmj`: lol, wrong channel.
16:57:56 <dmj`> :P
16:58:13 <dmj`> tommd: I'll be there in 15
16:58:14 <tommd> Still, if you want a lift.
16:58:19 <dmj`> haha
17:10:11 * hackagebot load-env 0.1.0 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.1.0 (PatrickBrisbin)
17:15:11 * hackagebot jwt 0.5.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.5.0 (StefanSaasen)
17:39:40 <akurilin> quick question: do you guys know if it's possible to customize the log level of runStderrLoggingT?
17:40:32 <akurilin> Internally it appears to just call runLoggingT with defaultOutput
17:43:03 <flyingfisch> ok, I wrote a little function
17:43:05 <flyingfisch> http://lpaste.net/115614
17:43:26 <flyingfisch> is there a monad function that I can use to do the same thing?
17:43:26 <ion> fromMaybe 0
17:43:46 <ion> I don’t think the Maybe monad is very useful for this.
17:44:24 <flyingfisch> what do you mean? I have a result that is either Just Int or Nothing. I want to get rid of its Maybe "wrapper"
17:44:43 <dmj`> > fromMaybe 0 (Just 3)
17:44:44 <Clint> fromMaybe 0
17:44:45 <lambdabot>  3
17:44:54 <dmj`> > fromMaybe 0 Nothing
17:44:56 <lambdabot>  0
17:45:06 <flyingfisch> @hoogle fromMaybe
17:45:07 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
17:45:11 <dmj`> @src fromMaybe
17:45:11 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
17:45:11 <flyingfisch> ok
17:45:15 <flyingfisch> thanks
17:45:20 <ion> Maybe’s (>>=) just short-circuits the computation given a Nothing, you don’t get to say “i want to return a zero instead” using it.
17:45:41 <flyingfisch> ion: hmm
17:45:58 <mgaut72> flyingfisch: I think ion meant that thinking about Maybe as a monad isn't useful in this case, not that Maybe isn't what you want
17:46:06 <dmj`> flyingfisch: once you're in the monad, bind won't get you out
17:46:19 <flyingfisch> right...
17:46:38 <flyingfisch> so is my function considering Maybe to be a Monad?
17:46:45 <flyingfisch> i thought it was not
17:46:46 <ion> no
17:46:52 <flyingfisch> that's what I thought
17:46:57 <dmj`> no you're pattern matchin out of it safely
17:46:59 <ion> It doesn’t use return or (>>=).
17:47:04 <flyingfisch> right
17:47:20 <flyingfisch> so then my program does what I want and so does fromMaybe
17:48:03 <flyingfisch> :t fromMaybe
17:48:04 <lambdabot> a -> Maybe a -> a
17:48:14 <flyingfisch> fromMaybe is more versatile
17:48:30 <flyingfisch> > fromMaybe "" "String"
17:48:31 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe [GHC.Types.Char]’
17:48:31 <lambdabot>              with actual type ‘[GHC.Types.Char]’
17:48:46 <flyingfisch> > fromMaybe "some" "String"
17:48:47 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe [GHC.Types.Char]’
17:48:47 <lambdabot>              with actual type ‘[GHC.Types.Char]’
17:48:48 <dmj`> fromMaybe safely gets you out of the Monad, not like fromJust
17:48:55 <flyingfisch> hmm
17:49:09 <flyingfisch> how can i use it with a string?
17:49:12 <flyingfisch> oh
17:49:16 <flyingfisch> i forgot
17:49:32 <flyingfisch> > fromMaybe "" (Just "String")
17:49:34 <lambdabot>  "String"
17:49:38 <flyingfisch> there we go
17:50:51 <flyingfisch> > fromMaybe "default" (Nothing)
17:50:53 <lambdabot>  "default"
17:50:56 <flyingfisch> that is cool
17:51:14 <flyingfisch> so the first arg is what it should return if Nothing, and the second is the Maybe
17:51:27 <flyingfisch> hey
17:51:33 <flyingfisch> is that a way to do default values?
17:51:40 <flyingfisch> like for config and stuff?
17:52:41 <dmj`> yes exactly
17:53:38 <dmj`> for environment variables theres is lookupEnv, new as of 4.6 or 7 I think, which returns an IO (Maybe String), so you could fmap a fromMaybe over it.
17:53:44 <dmj`> :t lookupEnv
17:53:45 <lambdabot> Not in scope: ‘lookupEnv’
17:53:51 <dmj`> @hoogle lookupEnv
17:53:51 <lambdabot> No results found
17:54:14 <mgaut72> flyingfisch: one way I have also seen configuration with default values is in Parsec's lexer definitions.  https://hackage.haskell.org/package/parsec-3.1.7/docs/Text-ParserCombinators-Parsec-Language.html
17:54:19 <dmj`> lookupEnv :: String -> IO (Maybe String)
17:54:24 <flyingfisch> k
17:54:36 <mgaut72> you can start with a defaultDef, then modify record fields as necessary
17:54:45 <mgaut72> but thats more if you need a configurable value for something
17:54:51 <dmj`> @def lookupEnv :: String -> IO (Maybe String); lookupEnv = undefined
17:54:53 <lambdabot>  Defined.
17:55:25 <dmj`> :t fmap (fromMaybe "192.168.1.0") (lookupEnv "ipaddr")
17:55:26 <lambdabot> IO [Char]
17:57:29 <dmj`> for config, like in web apps I use configurator, but you could put config info in recipes for the servers you'll spin up, write it to env. variables.
18:10:29 <flyingfisch> @hoogle forever
18:10:29 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
18:13:33 <flyingfisch> will compiled haskell apps work on any computer?
18:13:41 <flyingfisch> i mean
18:13:45 <flyingfisch> with the same os
18:14:13 <flyingfisch> like, does the user of the compiled app need to have any special haskell stuff installed?
18:14:20 <dmwit> Well. The default is to statically link them to other Haskell libraries.
18:14:24 <mgaut72> flyingfisch: you don't have guarantees about librarys and the like
18:14:54 <dmwit> The other computer will need whatever non-Haskell libraries they link to, of course; and it will need to be the same architecture and OS.
18:14:55 <flyingfisch> if you only use haskell modules are you ok?
18:15:11 <flyingfisch> and if it is the same os and architecture?
18:15:13 * hackagebot tighttp 0.0.0.5 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.5 (YoshikuniJujo)
18:15:14 <dmwit> That depends what "only use Haskell modules" means. Many Haskell modules are bindings to non-Haskell libraries.
18:15:47 <dmwit> ldd will tell you what libraries are dynamically linked by an executable.
18:16:38 <dmwit> Haskell programs are generally pretty friendly to moving between machines.
18:17:06 <dmwit> You certainly don't need a complete compiler toolchain on the destination machine.
18:20:18 <dmwit> Some programs use the GHC API (or directly run the ghc executable). The latter will definitely need a compiler available. Not sure about the former.
18:22:33 <mgaut72> is there any way to get "comprehensions" over arbitrary containers?  Specifically I would like a set comprehension, but this seems like something that is pretty generalizable
18:23:44 <Cale> Well, do-notation sort of serves this purpose, except that Set can't directly be made a Monad due to the fact that it requires an instance of Ord on the elements.
18:24:02 <Cale> (well, the relevant operations do)
18:25:14 <mgaut72> is monad the only requirement for a comprehension?
18:25:47 <mgaut72> Data.Set required Ord only as an implemention detail (some sort of fancy tree, right?)
18:26:23 <Cale> Well, it's a pretty important implementation detail as far as asymptotic performance is concerned.
18:26:36 * damncabbage waves.
18:26:39 <ChadMiller-> binary search tree, right?
18:26:49 <Cale> Yeah, it's a binary tree of bounded balance
18:26:52 <damncabbage> Is there an alternate source for these things? http://www.macdecals.com/macbook-haskell
18:27:06 <damncabbage> The site is really, really buggy. (eg. http://i.imgur.com/Awy9MNe.png)
18:27:11 <damncabbage> I literally can't give them money.
18:27:15 <mgaut72> Cale, im not arguing its not important, just really annoying
18:27:44 <Cale> mgaut72: of course, to have anything like a Set at all, you need at least Eq
18:28:04 <mgaut72> yea, Eq makes sense
18:29:16 <mgaut72> for context, I am working on some computational group theory BS, and I have seen haskellformaths, and the author explicitly assumes a group is a list of elements, where the elements have the usual group operations.  I want to go set, as thats more "correct" but I end up having to go back and forth between set and list all the time
18:29:19 <Cale> https://hackage.haskell.org/package/rmonad-0.8.0.2/docs/Control-RMonad.html -- you can pull tricks like this
18:30:49 <mgaut72> seems like I would do well to just keep things as a list?
18:31:16 <Cale> Lists are the most natural representation if you're planning to iterate over the elements of something.
18:31:35 <Cale> You can pretty much think of them as loops which haven't happened yet.
18:32:05 <mgaut72> yea.  I keep getting hit with all my algorithms being imperitively defined and its just been awkward work-arounds left and right
18:32:57 <Cale> Well, it's not necessary to think of things acting on lists as imperative, even if you sort of consider them to be loops
18:33:53 <Cale> and even when they are, well, there are lots of decent ways to sort of start out encoding an imperative algorithm as a bunch of pure functions, and then start doing algebraic simplification
18:34:14 <solirc> How can I leave a message for somebody with lambdabot?
18:34:25 <Cale>  @tell <user> <message>
18:34:31 <solirc> Cale: thx
18:34:54 <frege> is scala designed based on haskell?
18:35:03 <gcganley> Cale: are you the cale they talked about on the Haskell Cast?
18:35:07 <Cale> You can naively translate an imperative program into a functional one by making all the mutable variables into function parameters, and each point of control (place where the program counter might be) with a function, and just have each function apply the next one to updated values for the variables.
18:35:15 <Cale> gcganley: Probably
18:35:18 <dmj`> frege: doubt it
18:35:18 <dmj`>  
18:35:36 <mgaut72> Cale, thats pretty much what I have been doing thus far
18:35:36 <Cale> gcganley: I didn't know they talked about me
18:35:43 <gcganley> Cale: they mentioned you were good with cat theory
18:36:08 <Cale> Maybe among the people who are doing a lot of Haskell programming :)
18:36:17 <dmj`> Cale: ocharles mentioned you in one episode
18:37:00 <Cale> gcganley: Did you have a category theory question?
18:37:16 <Cale> Or just asking because you noticed my name? :)
18:37:36 <gcganley> Cale: saw your name and thought "THATS HIM"
18:38:24 <Cale> mgaut72: Then once you do that, you can start replacing equals for equals, and simplifying everything
18:38:35 <solirc> @tell mbuf this works https://gist.github.com/sol/303d140d13bf962a9e03 (PRs for the docs are more than welcome;)
18:38:35 <lambdabot> Consider it noted.
18:38:40 <Cale> In the hopes of getting it down to maybe one or two functions that you can try to make sense of
18:39:52 <mgaut72> Cale: yea, thats where some domain specific knowledge is useful, and algebra is hard =P
18:40:25 <dmj`> solirc: read scares me :(
18:42:43 <solirc> dmj`: that is not from me, just modified his example to make it work
18:45:01 <dmj`> solirc: ah I see
18:57:39 <orion> I have a typeclass called "Suite". I would like to define instances of Suite such that each instance refers to a "suite" or family of different types.
19:00:24 <orion> For example, The "Secure" suite might refer to types named Curve25519, AES128, and SHA256.
19:00:46 <orion> Whereas the "HighlySecure" suite might refer to types named Goldilocks448, AES256, and SHA512.
19:01:05 <orion> How can I use the type system to express this?
19:07:28 <mgaut72> orion: perhaps instances of an empty typeclass?
19:08:08 <johnw> they could also just be values of a particular record type, Secure or HighlySecure; they don't necessarily need to be type-classes, especially if the set of members will be pretty fixed
19:09:53 <mgaut72> I'm not speaking from experience here, but it seems like it would be nice to have a function `foo :: Secure a => a -> b -> c` and `bar :: HighlySecure a => a -> b -> c`
19:10:07 <johnw> or just foo :: Secure -> b -> c
19:10:18 <mgaut72> ah I see
19:10:19 <johnw> in other words, you're not abstracting very much
19:10:32 <johnw> so regular functions may fit the bill more directly
19:10:47 <mgaut72> yea, I agree
19:13:19 <mgaut72> johnw: so would you do something like `data Encryption = Encryption {encrypt :: a -> b}`
19:13:36 <mgaut72> then `Data Secure = AES Encryption | SHA Encryption`
19:13:36 <mgaut72> ?
19:15:33 <johnw> that's one way, but why need to indentify AES and SHA?
19:15:41 <johnw> the functions implementing them are identification too
19:16:11 <nshepperd> class Suite a where { type AsymmetricCipher a; type SymmetricCipher a; type Hash a }; instance Suite Secure where { type AsymmetricCipher Secure = Curve25519; type SymmetricCipher Secure = AES128; type Hash Secure SHA256; }
19:16:28 <nshepperd> -XTypeFamilies etc etc
19:16:35 <orion> Oh, cool.
19:16:45 <orion> I never knew you could put type definitions within instances.
19:17:47 <shachaf> This is not sounding like a good approach for cryptography.
19:19:42 <nshepperd> I think in general there's no real reason to use anything less than the most secure primitives available
19:19:53 <nshepperd> so...
19:20:22 <orion> nshepperd: The most secure primitives available changes over time.
19:20:41 <orion> So, it is in my best interest to use protocols whose cryptosuites can be swapped out.
19:21:32 <orion> As a result, I feel that I should design my library in such a way that adding new cryptosuites is trivial.
19:21:44 <orion> This notion is TypeFamilies is new and intriguing to me.
19:22:52 <nshepperd> don't go crazy with it!
19:24:55 <orion> I often get frustrated with when it is appropriate and not appropriate to use certain extensions.
19:25:05 <fread2282> orion: one thing to note is that type families can only be resolved at compile time, not run time
19:25:42 <piskrist> you know
19:25:46 <piskrist> sometimes I
19:25:55 <piskrist> something, like pause,
19:25:56 <piskrist> in wonder
19:26:14 <piskrist> what can one drunk man with access to the internet do
19:26:31 <shachaf> piskrist: This isn't the channel for that.
19:26:52 <piskrist> yeah well, is there something like #haskell-social ?
19:26:54 <nshepperd> also, frequently, when you might use a typeclass you can generally get away with using a plain data structure instead
19:27:29 <piskrist> struct plain { char *yolo } plain;
19:27:31 <nshepperd> type Suite = (AsymmetricCipher, SymmetricCipher, HashFunction)
19:27:48 <nshepperd> and then just pass a Suite to all relevant functions
19:28:22 <Buttons840> is the function (a,b) = (b,a) already defined in some common function? what is it's name?
19:28:30 <fread2282> :t flip
19:28:31 <lambdabot> (a -> b -> c) -> b -> a -> c
19:28:37 <fread2282> :t swap
19:28:38 <lambdabot> (a, b) -> (b, a)
19:28:44 <xpilot> hello
19:28:45 <Buttons840> fread2282: ty ty
19:29:01 <orion> nshepperd: I originally used a record type, but I found that I was essentially doing by hand what typeclasses already provide.
19:29:02 <xpilot> I am getting some baffling parses by ghc
19:29:02 <shachaf> @where hoogle is a good place to ask questions like that
19:29:02 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
19:29:35 <xpilot> I'm using RankNTypes and FlexibleContexts
19:29:42 <shachaf> https://www.haskell.org/hoogle/?hoogle=(a,b)+->+(b,a)
19:29:58 <Buttons840> shachaf: your right, i forgot about that site
19:30:06 <xpilot> my type signature looks like this: savedToData :: (Datum s, Bounded (Agent s), Enum (Agent s)) => Heuristic s -> Saved s -> DataSet s
19:30:07 <orion> you're*
19:30:50 <Buttons840> your correction is correct orion :P
19:31:24 <xpilot> whoops nevermind :)
19:31:47 <xpilot> I had a funny type: Datum s = (...) => s
19:31:55 <xpilot> and forgot Datum was a type and not a class
19:32:11 <shachaf> You're not giving enough information for people to help you without doing a whole lot of guessing.
19:32:32 <shachaf> The best thing to do would be to put your entire code and the entire error message that confuses you on hpaste.org
19:32:44 <xpilot> well I've realized my mistake
19:32:51 <xpilot> halfway through describing it
19:33:05 <xpilot> but this is very interesting behavior
19:34:01 <shachaf> You're not describing the interesting behavior clearly enough, then. :-)
19:34:19 <xpilot> if I have some type F a = a, then ghc parses (F a) => x -> ... as F a -> x -> ...
19:34:32 <shachaf> No it doesn't.
19:34:33 <fread2282> (how) can I get GHC to optimize GHC.Generics 'away' (so that the Rep and funtions on it are inlined away, e.g. I do some ifs on the conName)?
19:34:45 <shachaf> But you might be thinking of an old bug that was fixed in 7.8, I think.
19:34:53 <xpilot> well I'm using 4.6
19:34:57 <xpilot> uh
19:35:00 <xpilot> 7.6
19:35:11 <xpilot> 4.6 is gcc :P
19:35:18 <jfischoff> what is the easiest way to write an app that plays a song with Haskell?
19:35:34 <xpilot> ubuntu 14.04 is stuck with 7.6 I'm afraid
19:35:49 <shachaf> Prelude> :t let foo :: (Int => Show ()) => Int; foo = undefined in foo
19:36:03 <shachaf> let foo :: (Int => Show ()) => Int; foo = undefined in foo :: (Int -> Show ()) -> Int
19:36:10 <shachaf> Anyway, it's fixed in the new GHC.
19:36:24 <shachaf> You can download your own GHC rather than use Ubuntu's package. Works well.
19:37:11 <xpilot> I'm afraid to do that because I remember having all sorts of problems before installing haskell-platform
19:37:19 <fread2282> there is also https://launchpad.net/~hvr/+archive/ubuntu/ghc (a PPA)
19:37:47 <shachaf> I have more problems from using haskell-platform than from not using it.
19:38:04 <xpilot> really? such as?
19:38:04 <shachaf> Anyway, multiple versions of GHC can coëxist, no problem.
19:38:15 <xpilot> hm
19:38:28 <fread2282> xpilot: if you're using cabal a lot, haskell platform causes old versions to be choosen
19:38:38 <shachaf> Not any that are relevant here. haskell-platform is mostly just pointless since you can get the same packages yourself.
19:38:59 <xpilot> fread2282: what do you mean? why?
19:39:21 <xpilot> iirc there is some way to specify in cabal which ghc to use, right?
19:39:48 <dcoutts> xpilot: when configuring a package you can use -w ghc-x.y
19:40:02 <dcoutts> or equivalently you can put that in the local cabal.config file
19:40:40 <xpilot> dcoutts: thanks
19:40:43 <dcoutts> -w is short form for --with-compiler, and the config file entry follows the long form, ie with-compiler:
19:41:27 <fread2282> xpilot: haskell-platform bundles packages which are therefore installed system-wide that normal ghc doesn't, and cabal can't directly upgrade those. it can override them, but it doesn't by default and I've ran into trouble there
19:41:51 <xpilot> dcoutts: cabal: Version mismatch between ghc and ghc-pkg: /usr/bin/ghc-7.8.3 is version 7.8.3 /usr/bin/ghc-pkg is version 7.6.3 :(
19:42:29 <dcoutts> xpilot: you can also specify the ghc-pkg to use
19:42:33 <xpilot> fread2282: on the flip side, I had to install haskell-platform to get certain packages (alex and happy, iirc) which cabal couldn't install
19:43:34 <xpilot> dcoutts: how do I do that? and I suppose I also have to tell it which ghci to use too?
19:43:44 <dcoutts> xpilot: though it ought to find it automatically if you've installed them with the usual names
19:43:56 <dcoutts> xpilot: see cabal configure --help
19:44:09 <fread2282> xpilot: what I do is cabal install happy alex hcolor haddock then rm -rf ~/.ghc then go
19:44:20 <fread2282> xpilot: you need to add ~/.cabal/bin to your path probably
19:44:47 <xpilot> fread2282: definitely have that, and I'm working in a sandbox anyways
19:45:19 <fread2282> xpilot: what problem did you run into then?
19:46:00 <xpilot> dcoutts: the ppa installed them to somewhere funny and I guess I forgot to symlink ghc-pkg along with ghc and ghci
19:46:18 <xpilot> fread2282: iirc cabal simply refused to install them at all
19:46:33 <xpilot> that was earlier this year
19:46:35 <fread2282> xpilot: :o
19:46:47 <dcoutts> xpilot: so you can tell cabal where they are, but it'd be less confusing to set up the symlinks
19:48:53 <xpilot> fread2282: just did cabal install happy alex and it worked, so I'm not sure what the problem was
19:49:38 <fread2282> xpilot: yay :)
19:53:06 <xpilot> aw crap I don't have the profiling packages for base
19:53:25 <xpilot> which I got from haskell-platform-prof
19:54:45 <xpilot> ah but the ppa has ghc-7.8.3-prof
19:56:08 <tsani> coi
19:56:22 <tsani> (mischan, sorry)
20:05:55 <mbuf> solirc, thanks for the https://gist.github.com/sol/303d140d13bf962a9e03; how do I use after? http://lpaste.net/115615
20:07:28 <dmwit> jfischoff: Like, an mp3, or, like, a computer-generated tune?
20:07:54 <jfischoff> like an mp3
20:07:56 <dmwit> For mp3's I'd be tempted to start an mplayer slave.
20:08:20 <dmwit> I think gtk has some nonsense for playing sounds?
20:08:37 <dmwit> There's Haskell bindings to gstreamer, at least.
20:08:43 <jfischoff> mplayer slave sounds fine
20:09:00 <jfischoff> if I can start it relatively quickly
20:09:17 <adarc> yo
20:09:20 <jfischoff> I would like to have some since of when the song started
20:09:23 <adarc> oops
20:09:25 <dmwit> Well, it's pretty quick. But the idea of having a slave is you started way before you need it.
20:09:33 <jfischoff> that works
20:09:43 <dmwit> mplayer's slave mode is like a repl for its command line.
20:09:43 <jfischoff> brb
20:11:49 <jfischoff> should I just google mplayer slave?
20:12:01 <jfischoff> is there a link I should look at
20:13:54 <jfischoff> dmwit: thanks this seems easy
20:14:01 <jfischoff> https://mplayerhq.hu/DOCS/tech/slave.txt
20:15:15 <mhall> hey guys, can someone recommend an article on making a haskell 'library', or what exactly that entails?
20:15:28 <mhall> i'm guessing i need to register my 'package' with ghci or something so i can load it
20:15:58 <dmwit> mhall: Yep, the wiki has a good overview. One second.
20:18:07 <dmwit> https://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
20:18:09 <dmwit> mhall:
20:18:10 <solirc> mbuf: https://gist.github.com/sol/e36404b9d3ed1a71cab8
20:19:04 <mhall> dmwit: thanks
20:43:06 <dmj`> anyone have experience with the UUID pkg?
20:43:40 <dmj`> nextUUID :: IO (Maybe UUID)
20:43:46 <dmj`> says it "Returns Nothing if you request UUIDs too quickly."
20:44:22 <dmj`> I need to generate a lot of UUIDs but in the source it reads, "Isn't system wide or thread safe, nor does it properly randomize"
20:44:52 <Feuerbach> dmj`: use nextRandom from V4 module
20:46:04 <dmj`> Feuerbach: thank you !
20:49:53 <Blizzy> think anyone could explain /=
20:50:18 <Koganei> it's not (!= in other languages)
20:50:52 <Koganei> Blizzy: 'not'
20:51:02 <Iceland_jack> Blizzy: Not equalt to, inequality
20:51:08 <Iceland_jack> *equal
20:51:14 <Iceland_jack> > 5 /= 5
20:51:15 <lambdabot>  False
20:51:16 <Koganei> ^
20:52:03 <Blizzy> oh ok.
20:52:11 <Blizzy> thank you, Iceland_jack and Koganei.
20:52:16 <Iceland_jack> You're welcome
20:52:21 <Koganei> you're welcome, Blizzy.
20:52:24 <shachaf> @where Hoogle is good for answering that sort of question.
20:52:24 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
20:52:24 <Iceland_jack> The definition is literally:
20:52:31 <Iceland_jack> Blizzy:
20:52:31 <Iceland_jack> @src (==)
20:52:31 <lambdabot> x == y = not (x /= y)
20:52:35 <Iceland_jack> @src (/=)
20:52:36 <lambdabot> x /= y = not (x == y)
20:52:45 <Koganei> ooh nice shachaf
20:54:30 <Koganei> so is Haskell ever used to do AI?
20:57:56 <Blizzy> if I had an array for say, [True, False, True, False], and passed it through filter id
20:58:15 <Blizzy> it would return [True,True], meaning filter id removes all 'False' from an array?
20:58:53 <Koganei> > filter id [True, False, True, False]
20:58:55 <lambdabot>  [True,True]
20:59:00 <HeladoDeBrownie> Blizzy, that's a list, not an array, but yeah
20:59:19 <Blizzy> well, list, sorry. I'm used to other languages,lol.
20:59:25 <Blizzy> thxs.
20:59:51 <HeladoDeBrownie> That's actually kind of clever, I never thought of using id like that before
21:00:18 <Blizzy> i'm viewing a challenge on CodeWars.
21:00:20 <Iceland_jack> It's the same as doing:
21:00:20 <Iceland_jack> > [ x | x <- [True, False, True, False], x ]
21:00:21 <lambdabot>  [True,True]
21:00:22 <Blizzy> and someone posted it.
21:00:39 <HeladoDeBrownie> Blizzy, also, to clarify, when you say "removes from the list", what you really mean is "produces a new list that's like the old one but with those removed"
21:00:45 <HeladoDeBrownie> Haskell values are immutable
21:00:48 <Blizzy> ok.
21:00:49 <Koganei> HeladoDeBrownie: yeah me neithre :)
21:00:51 <Blizzy> thanks again.
21:01:26 <dmj`> > > (zipWith ($) [(+1)] [1], zipWith id [(+1)] [1])
21:01:27 <lambdabot>  <hint>:1:1: parse error on input ‘>’
21:01:31 <dmj`>  > (zipWith ($) [(+1)] [1], zipWith id [(+1)] [1])
21:01:39 <dmj`> > (zipWith ($) [(+1)] [1], zipWith id [(+1)] [1])
21:01:40 <lambdabot>  ([2],[2])
21:20:06 <blizzy> could someone explain this:
21:20:17 <L8D> it's called a colon
21:20:23 <blizzy> foldr delete ['a'..'z'] "hello"
21:20:24 <blizzy> :L
21:20:39 <L8D> > foldr delete ['a'..'z'] "hello"
21:20:40 <lambdabot>  "abcdfgijkmnpqrstuvwxyz"
21:20:51 <L8D> :t delete
21:20:52 <lambdabot> Eq a => a -> [a] -> [a]
21:21:01 <Iceland_jack> > ['a'..'z'] \\ "hello"
21:21:03 <lambdabot>  "abcdfgijkmnpqrstuvwxyz"
21:21:24 <Iceland_jack> blizzy: ['a'..'z'] is "abcdefghijklmnopqrstuvwxyz"
21:21:50 <Iceland_jack> Then 'foldr' goes through "hello" and deletes elements of "hello" from ['a'..'z']
21:22:02 <L8D> blizzy: it loops through each letter in "hello", and deletes that letter from ['a'..'z']
21:22:38 <blizzy> so, basically, it's just delete ['a'..'z'] 'o', then 'l', etc.
21:22:51 <HeladoDeBrownie> foldr delete ['a'..'z'] "hello" = delete 'h' (delete 'e' (delete 'l' (delete 'l' (delete 'o' ['a'..'z']))))
21:23:03 <HeladoDeBrownie> > delete 'h' (delete 'e' (delete 'l' (delete 'l' (delete 'o' ['a'..'z']))))
21:23:04 <lambdabot>  "abcdfgijkmnpqrstuvwxyz"
21:23:08 <blizzy> ok then.
21:23:10 <dmj`> it's the difference
21:23:15 <blizzy> thanks everyone.
21:23:21 <L8D> > delete 'o' . delete 'l' . delete 'l' . delete 'e' . delete 'h' $ ['a'..'z']
21:23:24 <lambdabot>  "abcdfgijkmnpqrstuvwxyz"
21:24:10 <dmj`> > F.toList $ S.fromList ['a'..'z'] `S.difference` S.fromList "hello"
21:24:11 <lambdabot>  can't find file: L.hs
21:24:12 <Iceland_jack> > foldr (fun "delete") a [x,y,z,u]
21:24:13 <lambdabot>  delete x (delete y (delete z (delete u a)))
21:24:41 <L8D> :t fun
21:24:42 <lambdabot> FromExpr a => String -> a
21:24:53 <Iceland_jack> where "a" is the alphabet
21:25:09 <Iceland_jack> > foldr (fun "delete") ("alphabet") [x,y,z,u]
21:25:10 <L8D> foldr (fun "(+)") a [1, 2, 3, 4]
21:25:11 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr
21:25:11 <lambdabot>                     [GHC.Types.Char])
21:25:11 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Expr.fun’
21:25:15 <Iceland_jack> Oops.
21:25:15 <Iceland_jack> > foldr (fun "delete") (var "alphabet") [x,y,z,u]
21:25:17 <lambdabot>  delete x (delete y (delete z (delete u alphabet)))
21:25:18 <L8D> > foldr (fun "(+)") a [1, 2, 3, 4]
21:25:20 <lambdabot>  (+) 1 ((+) 2 ((+) 3 ((+) 4 a)))
21:25:42 <L8D> holy fuck what is this magical library?!?!
21:26:01 <HeladoDeBrownie> @hackage simple-reflect
21:26:02 <lambdabot> http://hackage.haskell.org/package/simple-reflect
21:26:12 <blizzy> k, so, foldr delete "foo" "bar": checks for "r" in "foo", then "a", then "b"
21:26:14 <blizzy> right?
21:26:44 <HeladoDeBrownie> blizzy, I wouldn't even say it checks.
21:26:52 <shachaf> There's no "then"
21:27:00 <HeladoDeBrownie> Because you don't necessarily evaluate as far as the call to delete
21:27:06 <shachaf> f (g x) isn't "g, then f", nor "f, then g"
21:27:12 <shachaf> But if anything it's closer to the latter.
21:27:23 <HeladoDeBrownie> What it does is replace every (:) in "bar" (i.e., 'b':'a':'r':[]) with delete, and the [] with "foo"
21:29:05 <Zekka> I'm undecided about whether that seems unnecessarily pedantic. It's pretty pedantic, I guess, but I think the distinction has a point.
21:29:14 <blizzy> I think I get it. foldr delete "foo" "bar" basically 'checks' for the letters 'foo' in the string 'bar', starting from 'r'.
21:29:22 <Cale> no, starting from b
21:29:27 <Cale> foldr delete "foo" "bar" -> delete 'b' (foldr delete "foo" "ar")
21:29:37 <blizzy> I thought foldr starts from the right?
21:29:50 <shachaf> foldr doesn't start from anywhere.
21:29:51 <Cale> and then delete 'b' is applied to foldr delete "foo" "ar"
21:29:52 <HeladoDeBrownie> Zekka, I guess I interpreted the question as "what does this do" rather than "what is the purpose of this"
21:29:59 <Zekka> and I think Cale's comments make it really apparent it's hard to talk about order here
21:30:00 <Cale> and it pattern matches on it
21:30:09 <Cale> Lazy evaluation is outermost first
21:30:12 * L8D sighs
21:30:23 <Zekka> I think there are cases where intuitions that have to do with order make sense, this is a case where it's hard to talk about
21:30:45 * HeladoDeBrownie removes themself from the conversation
21:30:56 <Zekka> If someone asks whether f or g happens first in f . g, I think they mean something pretty unambiguous
21:30:57 * L8D invites HeladoDeBrownie to the party
21:31:06 <Cale> While the compiler might decide to do things in an order which is a bit different from lazy evaluation, probably assuming it's lazy evaluation is better than assuming it's anything else.
21:31:08 <Zekka> they want to know whether it expands to \x -> f (g x) or \x -> g (f x)
21:31:27 <blizzy> if I type foldr (\x y -> x+y) [1,2,3,4] it wouldn't start from 4?
21:31:27 <shachaf> I think it's good to be able to talk about the semantics regarless of the implementation.
21:31:32 <shachaf> And there's no order there.
21:31:34 * HeladoDeBrownie joins L8D's party. Are we going on a raid to combat Haskell bugs?
21:31:34 <Zekka> And they probably don't care about how ghc, temporally, evaluates it
21:32:06 <Cale> foldr (\x y -> x + y) 0 [1,2,3,4] -> 1 + foldr (\x y -> x + y) 0 [2,3,4]
21:32:25 <Cale> -> 1 + (2 + foldr (\x y -> x + y) 0 [3,4])
21:32:33 <blizzy> um.
21:32:40 <Cale> -> 1 + (2 + (3 + foldr (\x y -> x + y) 0 [4]))
21:32:51 <Cale> -> 1 + (2 + (3 + (4 + foldr (\x y -> x + y) 0 [])))
21:33:00 <Cale> -> 1 + (2 + (3 + (4 + 0)))
21:33:03 <blizzy> from what I'm reading, foldr starts from the right of the list
21:33:17 <Zekka> blizzy: It's kind of hard to phrase what foldr does in those terms
21:33:18 <Cale> It's impossible for anything to start at the right of a list
21:33:37 <Zekka> I think it's easier to intuit it in terms of replacement
21:33:37 <Cale> The right edge of a list is inaccessible at the beginning, you have to traverse from left to right
21:33:46 <Zekka> [1, 2, 3, 4] = 1:2:3:4:[]
21:33:54 <Cale> Also, consider this:
21:33:54 <Zekka> foldr takes a rule to replace the : and a rule to replace the []
21:33:54 <blizzy> from the book I'm reading,
21:33:55 <blizzy> The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right.
21:34:01 <blizzy> sorry, I'm just confused
21:34:09 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
21:34:11 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
21:34:15 <Cale> ^^ how does that work?
21:34:28 <Zekka> So foldr (+) 0 is 1 + 2 + 3 + 4 + 0, because we replace the :s with +s and the [] with 0
21:34:30 <Cale> Note that the list is infinite, so it has no "right end"
21:34:41 <shachaf> blizzy: Can't trust that book too much.
21:34:41 <blizzy> it evals it only when it needs it.
21:34:52 <blizzy> thus, lazy evaluation.
21:34:54 <Cale> So if foldr started at the end of the list, this wouldn't work
21:35:02 <blizzy> so how does it work.
21:35:05 <nshepperd> 'starts from the right' makes sense if you think of it as imperatively constructing a value (ie. a loop)
21:35:06 <Zekka> And replacing :s requires you to start from the left and work towards the right anyway
21:35:10 <nshepperd> but it's not really accurate
21:35:19 <Cale> Okay, let's do the double demo :)
21:35:20 <Zekka> in the sense that you can't get to node 1 without unconsing node 0 first
21:35:26 <Zekka> (well, "uncons" is the wrong word)
21:35:31 <blizzy> when I think of starting from the right, [1,2,3,4], the right would be starting from 4
21:35:32 <nshepperd> it doesn't work for the infinite list case, yeah
21:35:37 <Cale> Consider this function: double x = x + x
21:35:43 <Zekka> > foldl f x [x, y, z]
21:35:43 <Cale> and the expression double (double 5)
21:35:44 <lambdabot>  f (f (f x x) y) z
21:35:53 <Zekka> > foldl f x [y, z, w]
21:35:54 <lambdabot>  f (f (f x y) z) w
21:35:55 <Cale> Under strict evaluation, we evaluate innermost-first
21:35:56 <Zekka> > foldr f x [y, z, w]
21:35:58 <lambdabot>  f y (f z (f w x))
21:35:58 <shachaf> You're probably best off listening to Cale here.
21:36:11 <Zekka> (visual aid)
21:36:16 <Cale> That is, with strict evaluation, the reduction would look like this:
21:36:20 <Cale> double (double 5)
21:36:25 <Cale> -> double (5 + 5)
21:36:28 <Cale> -> double 10
21:36:30 <Cale> -> 10 + 10
21:36:31 <Cale> -> 20
21:37:30 <Cale> But this isn't the only order in which we can choose to evaluate things. There are lots of others. One is that we could choose to always evaluate the outermost reducible subexpression
21:37:47 <Cale> Under that order, if we're being naive about it, the reduction might look like this:
21:37:50 <Cale> double (double 5)
21:37:55 <Cale> -> (double 5) + (double 5)
21:38:02 <Cale> -> (5 + 5) + (double 5)
21:38:12 <Cale> -> 10 + (double 5)
21:38:15 <Cale> -> 10 + (5 + 5)
21:38:19 <Cale> -> 10 + 10
21:38:20 <Cale> -> 20
21:38:35 <Cale> But as you can see, we took more steps this way because we repeated work.
21:39:15 <Cale> So lazy evaluation tweaks this a little
21:39:56 <Cale> The reason we duplicated work was that the x in double x = x + x occurred twice in the body of the function
21:40:37 <Cale> Lazy evaluation makes it so that bound variables are evaluated at most once, and the result of that evaluation is shared between the occurrences
21:41:17 <blizzy> > scanr (\x y -> x+y) 0 [1,2,3,4]
21:41:19 <lambdabot>  [10,9,7,4,0]
21:41:23 <Cale> We can represent that sharing textually by using a let expression (though in the implementation it'll typically just be a result of multiple pointers to the same place in memory)
21:41:35 <Cale> So under lazy evaluation, it would look like this:
21:41:39 <Cale> double (double 5)
21:41:52 <Cale> -> let x = double 5 in x + x -- note that this is still outermost-first
21:41:58 <Cale> -> let x = 5 + 5 in x + x
21:42:04 <Cale> -> let x = 10 in x + x
21:42:06 <Cale> -> 10 + 10
21:42:07 <Cale> -> 20
21:42:33 <blizzy> ok.
21:43:10 <Cale> Under innermost-first evaluation, each argument to a function is evaluated exactly once. Under outermost-first evaluation, function arguments are evaluated zero or more times. Under lazy evaluation, you get the best of both worlds: arguments are evaluated zero or one times.
21:43:31 <blizzy> hopefully I learn more about this in college.
21:44:06 <Cale> Okay, so let's look at how foldl and foldr work in some simple cases
21:44:06 <Zekka> Doesn't Marlow's concurrency book have a pretty good section on lazy evaluation in more detail?
21:44:11 <Cale> yes
21:44:23 <Zekka> (don't want to steal Cale's thunder, this is a good talk so far)
21:44:25 <Cale> @src foldl
21:44:26 <lambdabot> foldl f z []     = z
21:44:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:45:14 <Cale> We can see that in the recursive case, foldl somewhat greedily applies itself to different arguments. So control will never go anywhere else until foldl reaches the end of the list
21:45:18 <Cale> e.g.
21:45:23 <Cale> foldl (+) 0 [1,2,3]
21:45:24 <sgronblo> https://hackhands.com/lazy-evaluation-works-haskell/ this one was pretty good too
21:45:30 <Cale> -> foldl (+) (0 + 1) [2,3]
21:45:36 * hackagebot tighttp 0.0.0.5 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.5 (YoshikuniJujo)
21:45:36 * hackagebot Redmine 0.0.1 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.1 (cstpierre)
21:45:36 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
21:45:45 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
21:45:51 <Cale> -> ((0 + 1) + 2) + 3
21:46:01 <blizzy> uh.
21:46:03 <blizzy> ok.
21:46:07 <Cale> and then finally (...) + 3 gets evaluated
21:46:13 <Zekka> (meaning that Haskell has to evaluate foldl all the way hrough before ever getting the chance to evaluate anything else)
21:46:49 <Cale> and that outermost (+) needs to pattern match on its left argument, so it'll wait on the pattern matching stack while the ((0 + 1) + 2) is evaluated
21:48:03 <Cale> and then (...) + 2 will pattern match its left argument, that pattern match will wait on the stack while (0 + 1) is evaluated, which will finish immediately, producing 1, and then 1 + 2 will evaluate to 3, and 3 + 3 will evaluate to 6, as we come back up the stack
21:48:53 <Cale> (the foldl might also use the stack a bit in general, but just to pattern match on the list argument, and in this case, our list was already in evaluated form)
21:49:08 <blizzy> ok, I get it now. thank you, Cale.
21:49:16 <Cale> So, foldr
21:49:18 <Cale> @src foldr
21:49:19 <lambdabot> foldr f z []     = z
21:49:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:49:28 <Cale> foldr by contrast immediately passes control to f
21:49:56 <Cale> only if/when the second argument to f is evaluated will the control come back to foldr
21:50:30 * hackagebot hackage-server 0.5.0 - The Hackage web server  http://hackage.haskell.org/package/hackage-server-0.5.0 (DuncanCoutts)
21:51:08 <Zekka> (f is even allowed to not use the result over the rest of the list, if it doesn't feel like it.)
21:51:14 <Cale> With foldr (+) 0 [1,2,3], we also end up using the pattern match stack a bunch, but in a different way (and if (+) were something different, we might avoid it)
21:51:26 <Cale> foldr (+) 0 [1,2,3]
21:51:33 <Cale> -> 1 + foldr (+) 0 [2,3]
21:51:45 <Cale> and then (+) ends up pattern matching on its second argument
21:52:01 <Cale> and that pattern match waits on the stack for foldr (+) 0 [2,3] to get evaluated
21:53:00 <L8D> @check \xs -> sort xs == (sort . sort) (xs :: [Int])
21:53:02 <lambdabot>  +++ OK, passed 100 tests.
21:53:17 <Cale> But in cases like the one I gave earlier with the infinite list:
21:53:32 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
21:53:34 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
21:53:37 <Zekka> L8D: What were you expecting?
21:53:42 <Cale> Here we see
21:53:47 <Cale> foldr (\x xs -> x : x : xs) [] [1..]
21:53:54 <L8D> Zekka: I was just checking the lambdabot usage
21:54:00 <Cale> -> (\x xs -> x : x : xs) 1 (foldr (\x xs -> x : x : xs) [] [2..]
21:54:03 <Cale> oops, )
21:54:15 <L8D> wait..
21:54:16 <Cale> but yeah, then we have:
21:54:17 <L8D> I didn't
21:54:21 <L8D> @check sort xs == (sort . sort) (xs :: [Int])
21:54:23 <lambdabot>  Not in scope: ‘xs’
21:54:23 <lambdabot>  Perhaps you meant one of these: ‘x’ (imported from Debug.SimpleReflect), ‘s’...
21:54:29 <Cale> -> 1 : 1 : (foldr (\x xs -> x : x : xs) [] [2..])
21:54:31 <L8D> ^ is what I was looking for
21:54:48 <Cale> and something which is pattern matching on this against a pattern like (x:xs) would be satisfied now
21:54:56 <Cale> So we could start printing the list, for instance
21:55:30 <Cale> and the foldr needn't continue until we've printed the two 1's, and the comma or whatever following them
21:56:23 <nshepperd> > foldr (const 7) 3 [1..]
21:56:24 <lambdabot>  No instance for (GHC.Show.Show a0)
21:56:24 <lambdabot>    arising from a use of ‘M80354276748016266019373.show_M80354276748016266019...
21:56:24 <lambdabot>  The type variable ‘a0’ is ambiguous
21:56:24 <lambdabot>  Note: there are several potential instances:
21:56:24 <lambdabot>    instance [safe] GHC.Show.Show
21:57:16 * nshepperd scrawls 'defaulting' on lambdabot's forehead
21:57:25 <merijn> nshepperd: Nothing to do with defaulting
21:57:31 <merijn> nshepperd: "const 7" takes one argument
21:57:37 <merijn> foldr wants a two argument function
21:57:56 <Zekka> > foldr (const) 7 [1..]
21:57:57 <lambdabot>  1
21:58:06 <nshepperd> oh, so it does
21:58:11 <dibblego> all haskell functions take one argument
21:58:14 <Zekka> (it never gets to the end of the list to put a seven there, nor does it care)
21:58:29 <merijn> dibblego: Technically correct, but practically useless in this context
21:58:32 <nshepperd> I guess I wanted some kind of magical const2
21:58:33 <Iceland_jack> dibblego: Nothing wrong with talking about two argument functions in Haskell
21:58:41 <dibblego> merijn: I argue, highly relevant to this
21:58:51 <dibblego> Iceland_jack: there is when it causes confusion, like here
22:00:03 <nshepperd> you could say that foldr wants a function that returns a function, but that's exactly what's meant by 'two argument function' here
22:00:09 <Iceland_jack> What would you prefer instead, foldr wants a function that returns a function?
22:00:38 <HeladoDeBrownie> The contentious statement is "const 7 takes one argument"
22:01:04 <dibblego> I would prefer making the statement of fact (all haskell  functions accept one argument, always). Then, use terminology such as "takes two arguments" on the understanding that it is an approximation and, if that approximation ever causes confusion, to retract it and go back to the statement of fact.
22:02:04 <nshepperd> seeing as it didn't cause any confusion, you've only succeeded at derailing what we were talking about
22:02:50 <dibblego> hmm yes sure, bye
22:03:46 <nshepperd> > let const2 = const . const in foldr (const2 7) 0 (cycle ['a'..'z'])
22:03:47 <lambdabot>  7
22:04:14 <blizzy> not to prove anyone wrong, yet according to http://stackoverflow.com/questions/1757740/how-foldr-works, foldr starts from the right.
22:04:29 <blizzy> I kind of got confused on what Cale said. :L
22:05:00 <HeladoDeBrownie> blizzy, phrasing it that way is kind of vague and doesn't tell you what actually happens as well as actually evaluating it does
22:05:11 <dibblego> blizzy: no, it associates to the right. It doesn't "start" anywhere. http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
22:05:26 <HeladoDeBrownie> Actually evaluating is what Cale was explaining
22:05:44 <Ralith> > foldr f x [y, z]
22:05:45 <HeladoDeBrownie> although it's possible you need to start with simpler examples of how evaluation works
22:05:46 <lambdabot>  f y (f z x)
22:06:03 <blizzy> > scanr (\x y -> x + y) 0 [1,2,3,4]
22:06:05 <lambdabot>  [10,9,7,4,0]
22:06:28 <Cale> blizzy: No function can ever start on the right end of a list
22:06:29 <dibblego> blizzy: foldr does constructor replacement. The expression (foldr f z list) will replace, in list, every occurrence of (:) with (f) and [] with (z).
22:06:42 <Cale> blizzy: because you always pattern match against (x:xs) or []
22:06:59 <blizzy> so, couldn't you say that it reverses the list and then applies foldl?
22:07:00 <Cale> So if you're matching the right end of a list, it means you matched the empty list, basically
22:07:06 <Cale> nope!
22:07:29 <Cale> > foldl (\xs x -> x : x : xs) [] (reverse [1..])
22:07:33 <Cale> ^^ this doesn't work!
22:07:34 <nshepperd> you con't reverse an infinite list!
22:07:34 <lambdabot>  mueval: ExitFailure 1
22:08:33 <Cale> However, you could explain foldl that way
22:08:55 <Cale> foldl f z xs = foldr (flip f) z (reverse xs)
22:09:30 <Apocalisp> or you could explain reverse that way :)
22:09:58 <jle`> Hafydd: was that dircted at me?
22:12:22 <blizzy> so foldr (\x y->x+y) 0 [1,2,3,4] is (+1(+2(+3(0+4))))
22:13:40 <Cale> (1 + (2 + (3 + (4 + 0))))
22:14:32 <Cale> and it starts at the beginning, so the first step of evaluation gets us to  1 + foldr (\x y -> x + y) 0 [2,3,4]
22:14:45 <Cale> and then the (+) evaluates
22:14:54 <Cale> (and can't finish without evaluating the foldr)
22:16:43 <Hafydd> jle`: yes, continuing a conversation from about 24 hours ago.
22:17:03 <blizzy> so, it begins at the left, yet returns the array as if it began from the right?
22:17:07 <blizzy> *list.
22:19:11 <lifter> Is it possible to define a pattern synonym that has a view pattern in such a way that the function to be applied in its view pattern is "passed in" to the pattern synonym (instead of baked into the synonym)?
22:23:30 <blizzy> foldr (\x y->x+y) 0 [1,2,3] is
22:23:44 <blizzy> 1 + foldr (\x y->x+y 0 [2,3]
22:23:48 <blizzy> then etc.
22:23:52 <blizzy> forgot the )
22:23:54 <blizzy> yet yeah.
22:25:15 <jle`> foldr (+) 0 (1:(2:(3:(4:[])))) is 0+(1+(2+(3+(4+0))))
22:25:31 <jle`> but yeah, you can expand it that way too.  that's the beauty of haskell evaluation :)
22:26:39 <blizzy> foldr (\x y->x+y) 0 [1,2,3] ----> 1 + foldr (\x y->x+y) 0 [2,3] ---> foldr (\x y-> x+y 0 [3] etc.
22:26:43 <blizzy> *)
22:26:47 <wz1000> Do polymorphic types exist at runtime?
22:27:16 <srhb> wz1000: Types don't even exist at runtime.
22:29:03 <wz1000> So, the version of a polymorphic function that is used is determined at compile time?
22:29:14 <shachaf> Whether types exist at runtime depends on your perspectives.
22:29:21 <shachaf> There are some types that only exist at runtime.
22:29:24 <blizzy> well, I have more questions tomorrow. thanks for the help everyone. bye, lol.
22:29:49 <dkbrk> srhb: what about someting like type Foo = forall x. Show x => [x]
22:30:15 <shachaf> For typical complication strategies, there's only one version of a polymorphic function.
22:30:27 <shachaf> dkbrk: The only non-_|_ value of that type is the empty list.
22:31:15 <wz1000> If I have (+) :: Num a -> a -> a -> , whether +_Int or +_Double is used is determined at compile time? Is it so for all polymorphic functions?
22:31:39 <shachaf> If you have what?
22:31:52 <Zekka> I think dkbrk means something like data Showable = forall x. Show x => Showable; [Showable]
22:32:17 <wz1000> * (+) :: Num a => a -> a -> a
22:33:00 <shachaf> (+) is slightly special because it's a method of Num (though a bit less special than you might think).
22:33:20 <shachaf> Well, I should start by saying that there are lots of ways to compile type classes.
22:33:28 <shachaf> I guess you're probably asking what GHC does.
22:33:41 <zq> jle`: i don't think that's correct. where'd the leftmost 0+ come from?
22:34:04 <zq> jle`: drop the 0+ and it'd be right
22:42:03 <shachaf> http://stackoverflow.com/a/17794883 has a partial explanation of how type classes are implemented in GHC.
22:42:10 <shachaf> But it's probably not the best resource for that.
22:47:44 <srhb> Oleg has a page iirc where he translates typeclassy Haskell into OCaml to demystify it
22:48:00 <srhb> Not sure if that corresponds entirely to what GHC does, but I think it's pretty close.
22:48:51 <sgronblo> the video i just started rewatching today with SPJ does a nice job too i think https://www.youtube.com/watch?v=6COvD8oynmI
22:49:06 <srhb> Oh joy, comic sans!
22:49:11 <srhb> Everything is easy with comic sans.
22:49:19 <sgronblo> I remember being confused by it around two years ago though
22:49:30 <merijn> Also, Tekmo's Scrap Your Typeclasses is pretty straightforward
22:49:41 <sgronblo> yeah comic sans plus fluffy something for monads, who wouldnt wanna use haskell now?
22:49:57 <merijn> srhb: Must be a PL thing, because Sweeney's POPL keynote a few years ago was in comic sans too :p
22:51:43 <shachaf> merijn: It doesn't have particularly good advice.
22:51:52 <srhb> merijn: Bizarre! Though at my uni the PL people are indistinguishable, it's all Computer Modern.
22:53:21 <sgronblo> If I ever present something I'll be sure to rip off SPJ's color theme and comic sans
22:53:28 <sgronblo> I won't use windows though
22:53:28 <ab9rf> at least it's not papyrus
22:53:37 <MP2E> hahah
22:53:54 <MP2E> http://xkcd.com/590/
22:56:17 <jle`> zq: ah yes, thanks
22:56:21 <jle`> :|
22:56:25 <jle`> not sure how that got there...
23:10:00 <wei2912> i'm planning to write up a Data.Counter module, similar to python's Counter object
23:10:08 <wei2912> which basically counts the frequency of objects
23:10:19 <wei2912> does anyone have suggestions for how i could start?
23:12:58 <shachaf> What is the difficulty?
23:13:00 <Cale> wz1000: Depending on what's meant by "known" it's not always known at compile time. Haskell has polymorphic recursion, so for example, you can write things like...
23:13:54 <Cale> > let f :: (Show x) => x -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f 0) [1..]
23:13:56 <lambdabot>  ["(0,0)","((0,0),(0,0))","(((0,0),(0,0)),((0,0),(0,0)))","((((0,0),(0,0)),((...
23:14:02 <shachaf> Yes, polymorphic recursion is another thing.
23:14:22 <kvanb> gosh thats scary from a compiler POV
23:14:22 <Cale> This uses more and more instances of show, which are computed at runtime
23:14:35 <shachaf> The type ((Integer,Integer),(Integer,Integer)) doesn't exist at compile time.
23:14:46 <shachaf> Does it exist at runtime? That depends on what you mean.
23:15:16 <wei2912> shachaf: were you speaking to me?
23:15:18 <kvanb> http://cdn.memegenerator.net/instances/250x250/51311855.jpg
23:15:23 <shachaf> Certainly a value of that type exists at runtime. In GHC's implementation, a Show dictionary for that type is created at runtime.
23:15:24 * kvanb ducks
23:15:32 <shachaf> wei2912: Yes.
23:16:28 <wei2912> shachaf: i'm not certain of that yet; i just started writing the code. i have an idea in mind which makes use of Data.Map.
23:20:47 <osa1> I can't use pattern synonyms in export lists, right?
23:21:53 <srhb> osa1: like module Foo (pattern Bar) where ... ?
23:22:27 <osa1> srhb: I have no ideas, I'm trying to understand how to export/import patterns
23:23:02 <osa1> also, do pattern synonyms show up in haddock?
23:25:02 <srhb> osa1: Well, like that then. As you would import/export anything else, but prefix pattern to it
23:25:07 <srhb> "pattern " that is
23:25:28 <osa1> srhb: yup, thanks
23:28:33 <gamegoblin> @pl \x y -> f x (g y)
23:28:33 <lambdabot> (. g) . f
23:28:53 <osa1> so how do they show up in haddock?
23:37:03 <wei2912> i've come up with a `update` method which updates a counter with a key and count, as well as a `count` method which takes in a list of keys and returns a counter with a map of keys to frequencies
23:37:10 <wei2912> now, how do i come up with an `union` function?
23:37:57 <wei2912> my idea was to convert the map back to a list, then map the `update` method, but is there a better way?
23:39:22 <jle`> wei2912: types pls
23:39:30 <jle`> write your functions with types
23:39:32 <jle`> :)
23:39:44 <wei2912> type Count = Int
23:39:45 <wei2912> type Counter k = M.Map k Count
23:39:52 <wei2912> merge :: Ord k => Counter k -> Counter k -> Counter k
23:40:04 <wei2912> hmm
23:41:24 <jle`> well, what are update, count, and union :P
23:41:52 <wei2912> sorry, merge is supposed to be union
23:41:58 <wei2912> update :: Ord k => k -> Int -> Counter k -> Counter k
23:42:03 <wei2912> count :: Ord k => [k] -> Counter k
23:43:09 <SoupE> there is an unionWith in Data.Map
23:43:34 <SoupE> if your are using Data.Map
23:43:35 <dreixel> fread2282: http://dreixel.net/research/pdf/ogpi.pdf
23:44:12 <wei2912> SoupE: oh, thanks!
23:44:16 <mbuf> sorry, I missed the message reply for my question,  how do I use after correctly with Hspec? http://lpaste.net/115615
23:44:22 <wei2912> i was looking for that
23:44:49 <SoupE> wei2912: np =)
23:45:24 <wei2912> thanks for your help jle` and shachaf too
23:45:36 <jle`> np!
23:45:38 <jle`> follow the types :)
23:46:15 <jle`> also, if you have a hard time phrasing a question, just saying the types always helps out a whole bunch
23:46:32 <mbuf> found it, http://tunes.org/~nef/logs/haskell/14.12.03 thanks solirc
23:46:45 <wei2912> alright, i'll take note of that
23:50:35 * hackagebot steeloverseer 1.1.0.0 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-1.1.0.0 (SchellScivally)
23:50:37 * hackagebot steeloverseer 1.1.0.1 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-1.1.0.1 (SchellScivally)
23:51:18 <gamegoblin> @pl \x -> (minimum x, maximum x)
23:51:18 <lambdabot> liftM2 (,) minimum maximum
23:54:19 <fread2282> dreixel: yep, I've done everything there short of duplicating into lots of RULES, does GHC do INLINE for derived Constructor (or even Generic) instances?
23:57:56 <jle`> i should look into ways to patch pointless to start using liftA2 instead of liftM2
23:59:13 <wei2912> how could i setup `cabal test`?
