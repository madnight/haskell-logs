00:00:12 <jle`> most terminals don't print anything out until they get a newline
00:00:20 <jle`> or it is explicitly flushed
00:01:07 <arrowdodger> But still, anything in my_test.hs is out of scope ._.
00:01:26 <jle`> arrowdodger: how about import Main ?
00:01:39 <jle`> or just `main`
00:01:44 <jle`> Main.main
00:01:56 <arrowdodger> jle`: Nope, i've tried all of this.
00:01:59 <prinsen> jle`: Thanks
00:04:44 <ChristianS> :t Data.Text.split
00:04:45 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
00:04:56 <trap_exit> hmm, is there somethin glike Mesos (http://mesos.apache.org/) for for Haskell ?
00:04:57 <ChristianS> pecanpy: ^^ your docs must be wrong
00:05:27 <pecanpy> yea. it was one of the top google results for Data.Text.
00:05:32 <pecanpy> its splitOn now
00:06:10 <pecanpy> how do i see what version of a package i have? "ghc-pkg list" ?
00:06:11 <ChristianS> pecanpy: yeah, google is not good for api docs, hayoo or hoogle is better
00:07:25 <calvinx> for ghci in multiline mode, is there a way to traverse back to the previous line if I accidentally hit return (before I was finished with a line)?
00:12:36 <redtricycle> "cabal freeze" creates a cabal.config.  can I fore my sandbox build-depends to use this cabal.config file?  How?
00:12:42 <redtricycle> or is that a correct way to do it?
00:12:46 <jle`> bitemyapp: yeah, it's acme, heh
00:12:52 <redtricycle> force*
00:12:53 <jle`> but i'd rather believe it was serious
00:13:04 <dcoutts_> redtricycle: it's used automatically
00:13:24 <dcoutts_> redtricycle: the local cabal.config is always used, it is the local cabal config file
00:14:03 <dcoutts_> redtricycle: you can put anything in there that you can put in the ~/.cabal/config, or that you can use on the cabal command line
00:14:46 <redtricycle> Ah, I have a question on best-practices then
00:14:52 <redtricycle> When building a package
00:15:02 <redtricycle> should I use really strict versioning in my build-depends? ( have a cabal sandbox)
00:15:08 <redtricycle> or should I use cabal freeze
00:15:16 <redtricycle> and then carry that cabal.config to another system?
00:18:00 <dcoutts_> redtricycle: my advice would be to use the widest range of versions that work in the .cabal file, since your users may need to pick different versions from you. But it's also reasonable during development (especially if you have a team working on the one thing) for you to pick fixed versions using cabal freeze and to share that between all devs by checking it into source control
00:18:48 <tdammers> yeah, I'd say it depends on what you building and what your ecosystem is
00:20:30 <pecanpy> does anyone use the FP Complete browser ide? I clicked a link and randomly ended up in an empty project, but I don't see a link from their site for starting a project
00:21:00 <pecanpy> (a link from a different site into an anonymous project)
00:22:41 <arrowdodger> pecanpy: You need to register to create your own projects.
00:23:06 <pecanpy> arrowdodger: great. thanks
00:34:51 <prinsen> Two questions, what is the template haskell Lift class, and is there any way to automatically derive it?
00:35:04 <pecanpy> is Data.Random included in the haskell platform? I see "random-1.0.1.1" in my ghc-pkg list, but when I import in ghci is says "could not find module"
00:36:36 <pecanpy> nvm. i must be new to life. the package name is in the url as "random fu".
00:46:00 <redtricycle> Shelly... domv <- run "mv" ["-v","*.mp3","~/mp3"] fails with "cannot find file"
00:46:10 <redtricycle> i also tried with no wildcards
00:46:23 <redtricycle> why can't shelly move files?
00:47:19 <redtricycle> nevermind....full paths
00:47:22 <redtricycle> no ~/mp3 -_-
00:47:55 <redtricycle> and wildcards dont work
00:49:23 <trap_exit> mesos for haskell
00:49:26 <trap_exit> haskell for mesos
00:49:27 <trap_exit> we need this
00:50:46 <bitemyapp> trap_exit: yis
00:51:11 <trap_exit> bitemyapp: we need a name better than mesosphere
00:53:14 <bitemyapp> trap_exit: yis
00:53:40 <trap_exit> bitemyapp: if you were a VC, I'd be laughing to the bank right now
00:54:14 <angerman> did anyone else have issues with haskell-font-lock-symbols not working?
01:18:40 <superlinux-hp> hi. I cannot `cabal install Cabal` to the latest version. it's stubborn and stays on Cabal-1.18.1.3. what should I do?
01:23:45 <srhb> redtricycle: That's a feature, not a bug.
01:24:05 <Feuerbach> superlinux-hp: show us the logs
01:24:53 <srhb> superlinux-hp: Just to make sure, are you sure you mean to upgrade cabal and not cabal-install?
01:24:58 <superlinux-hp> Feuerbach, i was able to run `cabal fetch 'Cabal>1.20'
01:25:04 <superlinux-hp> so I did download it.
01:25:15 <superlinux-hp> so I need now to add it to the build
01:25:59 <Feuerbach> superlinux-hp: just show the output of 'cabal install Cabal'
01:26:11 <superlinux-hp> ok
01:26:37 <superlinux-hp> Resolving dependencies...
01:26:38 <superlinux-hp> All the requested packages are already installed:
01:26:38 <superlinux-hp> Cabal-1.18.1.3
01:26:38 <superlinux-hp> Use --reinstall if you want to reinstall anyway.
01:26:50 <superlinux-hp> Feuerbach, here you go
01:27:19 <superlinux-hp> srhb, I did run `cabal update` so many times
01:27:43 <srhb> superlinux-hp: I meant, is it Cabal the library you want to upgrade and not cabal the command?
01:27:51 <Feuerbach> superlinux-hp: how about cabal install Cabal --constraint 'Cabal>1.20'
01:28:00 <Feuerbach> also, please use lpaste
01:28:02 <Feuerbach> @paste
01:28:02 <lambdabot> Haskell pastebin: http://lpaste.net/
01:29:07 <superlinux-hp> Feuerbach, it's rejecting versions over 1.18
01:29:36 <Feuerbach> @paste
01:29:36 <lambdabot> Haskell pastebin: http://lpaste.net/
01:29:40 <superlinux-hp> ok
01:30:40 <superlinux-hp> Feuerbach, http://lpaste.net/5453551620497342464
01:31:42 <Feuerbach> ok, so you're in a sandbox and you've already installed another version
01:32:03 <Feuerbach> cabal sandbox hc-pkg unregister Cabal -- --force
01:32:08 <Feuerbach> then try again with cabal install
01:32:36 <superlinux-hp> ok
01:32:38 <Feuerbach> or just recreate the sandbox
01:32:47 <superlinux-hp> ok
01:33:56 <KangaAkale> hi
01:34:36 <KangaAkale> please i got a little challenge with haskell I am a newbie
01:34:55 <KangaAkale> any one to assist
01:35:05 <speak> KangaAkale: Just ask your question
01:36:09 <KangaAkale> i am trying to write a function that reads a csv file and returns acustom datatype
01:36:38 <Feuerbach> @hackage cassava
01:36:38 <lambdabot> http://hackage.haskell.org/package/cassava
01:36:49 <Feuerbach> KangaAkale: take a look at that library ^^
01:38:05 <KangaAkale> here is my function http://lpaste.net/8494122921122332672
01:38:43 <KangaAkale> i am getting this error  Couldn't match type ‘IO ()’ with ‘MatchDay’
01:39:16 <KangaAkale> Feuerbach:I actually used that
01:39:22 <Feuerbach> ok
01:39:30 <Feuerbach> why do you have V.forM_ v there?
01:39:59 <srhb> also since the do block starts with BL.readFile, return whatever will yield an IO Something, not MatchDay
01:41:20 <srhb> Oh, it's actually V.forM_ v return $ v -- are you aware of that?
01:46:34 * hackagebot learning-hmm 0.2.1.0 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.2.1.0 (mnacamura)
01:53:30 <favetelinguis> why is this extremely simple code giving me this error? http://lpaste.net/115959
01:55:16 <Athas> Is there a monadic variant of mapAccumL somewhere in the standard library?
01:55:29 <malllle> it does not know which type m0 should have, so give it a hint
01:56:56 <malllle> Athas: there is one in Traversable, mazbe it is enough
01:57:21 <malllle> it has an Traversable constraint though
01:57:36 <matematikaadit> favetelinguis: try adding "main :: IO ()"
01:58:04 <favetelinguis> malllle: matematikaadit: jupp that worked
01:58:06 <Athas> malllle: it does not seem to permit the traversal function to be monadic.
01:58:40 <Athas> I'm really looking for something of type 'Monad m => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, [y])'.  I can write it easily enough myself, of course.
01:59:30 <jle`> anything in monad-loops ?
02:00:19 <Athas> Doesn't seem like it.
02:06:35 * hackagebot hakyll 4.6.1.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.1.1 (JasperVanDerJeugt)
02:07:37 <superlinux-hp> I cannot `cabal install yesod-bin` .  please see it's results: http://lpaste.net/115960
02:08:27 <superlinux-hp> I reconstructed my sandbox.
02:08:50 <superlinux-hp> I was able to install Cabal 1.20 and alex and happy and yesod
02:09:00 <superlinux-hp> now i need yesod-bin
02:15:55 <superlinux-hp> Feuerbach, there?
02:16:17 <superlinux-hp> Feuerbach, like you told me, I reconstructed the sandbox
02:17:15 <BigBud> haskell is fookin SHITE
02:17:18 <BigBud> MOTHERFFUCKERS
02:17:25 <BigBud> BITCH FAGS HASKELS
02:17:27 <bitemyapp> lol
02:17:29 <Kinnison> Delightful
02:17:30 <superlinux-hp> BigBud, yep! it's
02:17:34 <capisce> what is your specific concern with Haskell?
02:17:37 <bitemyapp> aw he left.
02:17:39 <superlinux-hp> it wasted allot of my time
02:18:18 <superlinux-hp> bitemyapp, would you please help?
02:20:22 <bitemyapp> superlinux-hp: it's 0417. I shouldn't even be awake.
02:20:38 <superlinux-hp> ah sorry.
02:20:45 <superlinux-hp> It's midday here.
02:20:54 <superlinux-hp> bitemyapp, go sleep. thanks.
02:22:12 <bitemyapp> superlinux-hp: thank you.
02:48:02 <eXeC64> I'm a bit confused about (*>) from Control.Applicative. Its type `f a -> f b -> f b` would suggest that `f a` is never evaluated, as it's never used/needed. What stops it from just never happening, with regards to laziness? I'm thinking about it in the context of parsers / parsec. `string "[" *> ... <* string "]"`, for example.
02:49:21 <srhb> eXeC64: Even if the value isn't used, the action can still be sequenced
02:49:26 <srhb> Think of >> for instance
02:49:41 <eXeC64> srhb: How does that get enforced?
02:50:26 <eXeC64> My intuition is of building an expression, and discarding parts that don't need to be evaluated.
02:51:41 <nkar> eXeC64: it's eval'd, just discarded.
02:51:47 <nkar> > error "foo" >> return 42 >> return 100
02:51:49 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
02:51:49 <lambdabot>    arising from a use of ‘M401046565992299337824326.show_M4010465659922993378...
02:51:49 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
02:51:49 <lambdabot>  Note: there are several potential instances:
02:51:49 <lambdabot>    instance [safe] GHC.Show.Show a =>
02:51:56 <nkar> damn
02:52:19 <nkar> > error "foo" >> return 42 >> return 100 :: IO Int
02:52:21 <lambdabot>  <IO Int>
02:52:23 <eXeC64> Oh, wait. Does `f a` get evaluated for it to be passed in to the function? i.e. `a` is evaluated to construct `f a`
02:53:26 <nkar> 'f a' is evaluated.  the above snippet fails with an error while return 10 >> return 42 >> return 100 returns 100
02:56:07 <AlecTaylor> hi
02:56:09 <eXeC64> I'm just failing to understand why it's evaluated. It feels like the evaulation should simply be optimised out.
02:56:59 <AlecTaylor> How do I pass through a multiply function, like so?: (\(x,y,f) -> f x,y)(*, 5, 6)
02:57:14 <AlecTaylor> How do I pass through a multiply function, like so?: (\(f,x,y) -> f x,y)(*, 5, 6)
02:57:22 <wei2912> what?
02:57:36 <nkar> (*, 5, 6) is not valid
02:57:46 <AlecTaylor> nkar: Correct. What is the syntax?
02:58:17 <wei2912> > \ (f, x, y) -> f x y) ((*), 5, 6)
02:58:18 <lambdabot>  <hint>:1:21: parse error on input ‘)’
02:58:29 <wei2912> > (\ (f, x, y) -> f x y) ((*), 5, 6)
02:58:30 <lambdabot>  30
02:58:31 <nkar> I don't understand the question.  could you provide an example, e.g., input and output
02:58:39 <wei2912> i think this is what AlecTaylor wanted
02:58:43 <AlecTaylor> THanks wei2912
02:58:44 <eXeC64> nkar: I think he's trying to implement $
02:58:54 <wei2912> hmmm
03:01:52 <Athas> eXeC64: it might help to look at how a concrete implementation of *> is evaluated.
03:02:08 <Athas> Try looking at the one for Maybe (which is probably defined in terms of >>=.)
03:02:16 <nkar> eXeC64: sorry, my example is sloppy (you asked about *>, not sure why I decided to explain >>)
03:02:25 <nkar> Athas: it's defined via liftA2 and onst
03:02:26 <nkar> const
03:03:15 <nkar> eXeC64: yeah, that's the only way to understand it.  check the definition and inspect the types of the involved functions
03:04:41 <eXeC64> See, const also looks like it should just optimise out the second parameter. `const x _ = x`
03:04:55 <eXeC64> Or is it the first
03:05:20 <superlinux-hp> I cannot `cabal install yesod-bin` without errors .  please see it's results: http://lpaste.net/115960
03:05:20 <eXeC64> I just can't see at what point the evaluation becomes mandatory for GHC
03:05:26 <superlinux-hp> please help
03:07:16 <eXeC64> It still seems like it could be kept as a thunk and discarded unevaluated.
03:08:08 <Athas> eXeC64: if you look at the implementation of *> for Maybe, you will see that it does a case analysis to see whether the constructor of the result is Just or Nothing, thus forcing evaluation.
03:11:46 <eXeC64> Ah, so when `string "["` is passed to `*>` if it *were* a Maybe, it'd need to be evaluated to see if it were Just or Nothing. In the parsec example, the parsec monad holds the state of whether it evaluated successfully or not. Okay, I'm grokking this now.
03:11:55 <eXeC64> Thanks.
03:12:57 <eXeC64> I was thinking of it as `data Box a = Box a`, assuming that the state was entirely contained within a, making it lazy.
03:13:37 <HaskellNewb> hello
03:14:22 <HaskellNewb> Can somebody tell me how I can remove some parenthesis from my code: https://bpaste.net/show/c88986043b51 I can only use the $ sign for the last argument right?
03:20:02 <calvinx> ?src map
03:20:02 <lambdabot> map _ []     = []
03:20:02 <lambdabot> map f (x:xs) = f x : map f xs
03:21:14 <calvinx> how would I read “map :: (a -> b) -> [a] -> [b]” ?
03:21:27 <srhb> calvinx: Given a function from a to b, you can transform a list of as to a list of bs
03:21:59 <srhb> or map :: A function of two arguments. 1) function from a to b. 2) a list of a. Returns a list of b
03:22:08 <superlinux-hp> srhb,
03:22:10 <superlinux-hp> I cannot `cabal install yesod-bin` without errors .  please see it's results: http://lpaste.net/115960
03:22:20 <calvinx> srhb: thanks!
03:22:38 <srhb> superlinux-hp: I don't know anything about building yesod.
03:22:43 <superlinux-hp> ok.
03:22:46 <superlinux-hp> thanks
03:22:55 <bitemyapp> superlinux-hp: there's a yesod channel.
03:23:03 <superlinux-hp> i know.
03:23:09 <superlinux-hp> thank you
03:23:13 <bitemyapp> superlinux-hp: delete the sandbox, re-attempt.
03:23:22 <superlinux-hp> ok
03:24:01 <sivteck> maybe with Stackage™
03:24:04 <bitemyapp> superlinux-hp: if that doesn't work...well...part of the problem is the Yesod ecosystem doesn't use upper bounds.
03:24:12 <superlinux-hp> ok.
03:24:29 <calvinx> how do I know which “->” is where a return is indicated?
03:24:30 <bitemyapp> superlinux-hp: you'll need to start affixing specific versions to dependencies...partly so the solver has a smaller search space.
03:24:50 <calvinx> map accepts two arguments: (a->b) and [a]
03:25:00 <calvinx> but they are also delimited by “->"
03:25:05 <srhb> calvinx: The last one
03:25:19 <srhb> foo :: arg -> arg -> arg -> result
03:25:22 <calvinx> a function cannot possibly return two resuls?
03:25:25 <bitemyapp> ehhhhhh.
03:25:26 <srhb> calvinx: Nope
03:25:28 <calvinx> *two or more results
03:25:35 <bitemyapp> ehhhhhhhhhhhh
03:25:53 <bitemyapp> first off, (->) associates from the right
03:26:09 <bitemyapp> secondly, (->) has only two type arguments, an argument type and a return type.
03:26:25 <srhb> Doesn't make anything I said wrong. :-)
03:26:28 <bitemyapp> functions only ever accept one argument. Currying is why it seems like you can accept more than one argument.
03:26:35 <srhb> As long as you don't alias (->) to something funny.
03:26:40 <bitemyapp> a -> b -> c    is really    a -> (b -> c)
03:26:43 <calvinx> right, that’s what chapter 4 learnyouahaskell says/
03:26:48 <bitemyapp> ie, a function that returns another function
03:26:51 <bitemyapp> calvinx: don't use LYAH.
03:26:55 <bitemyapp> calvinx: https://github.com/bitemyapp/learnhaskell
03:27:01 <calvinx> all functions only accept one argument. they appear to be accepting more because of “currying".
03:27:01 * srhb thinks LYAH is great
03:27:08 <Haskellfant> lyah is completely fine
03:27:09 * srhb also thinks bitemyapp is being anal :-)
03:27:59 <calvinx> ok, thanks for the tip. and for clarifying how to read “->".
03:28:16 <tdammers> Haskellfant: lyah is not completely fine, but I believe that "completely fine" is an impossible goal for learning material
03:28:20 <superlinux-hp> srhb, tell bitemyapp to go sleep ☺
03:28:27 <Haskellfant> tdammers: fair enough
03:28:39 <tdammers> in short, lyah dumbs haskell down a bit to make for a digestible learning curve
03:28:47 <bitemyapp> LYAH doesn't teach Haskell
03:28:51 <calvinx> lyah is very friendly. :D
03:29:04 <calvinx> cute elephants and pictures and what not.
03:29:11 <calvinx> makes me feel like I am 5 years old again :D
03:29:15 <srhb> calvinx: Everyone will agree that Haskell functions have one argument and one result if really pressed.
03:29:21 <tdammers> bitemyapp: LYAH doesn't teach *all* of Haskell
03:29:22 <srhb> calvinx: But you can think of them as taking multiple arguments just fine.
03:29:24 <srhb> Because of currying.
03:29:28 <superlinux-hp> cute elephants that fly ☺
03:29:30 <calvinx> got it.
03:29:32 <tdammers> bitemyapp: and it tells a few white lies
03:29:57 <bitemyapp> "a few"
03:30:08 <tdammers> yeah
03:30:11 <tdammers> a few
03:30:28 <tdammers> just like we lie to first-graders when we explain numbers
03:30:34 <bitemyapp> benzrf is never here when I need him.
03:31:02 <tdammers> which is acceptable when first-graders are the target audience
03:31:19 <bitemyapp> tdammers: LYAH has made it harder, not easier, for me to teach people Haskell with one notable exception.
03:31:34 <tdammers> bitemyapp: I believe you
03:31:37 <bitemyapp> tdammers: I'd rather they never had looked at it at all.
03:31:53 <bitemyapp> part of the problem is it tricks them into thinking they understand things they *do not* undestand
03:32:02 <bitemyapp> then you have to beg them to backtrack and unfuck their broken intuitions
03:32:06 <bitemyapp> which of course, is always an ordeal.
03:32:08 <tdammers> hmm, yes, I get your complaint
03:32:10 <bitemyapp> because nobody will take your word for it.
03:32:19 <srhb> I have the exact opposite experience
03:32:54 <tdammers> OTOH, most people require somewhat broken intuitions in order to bootstrap a cycle of forming intuitions, discovering how they are inappropriate, refining them, and forming new ones
03:32:55 <srhb> as long as I hand-hold a bit and throw in a few "strictly speaking, this is not true, but ..."
03:33:02 <tdammers> that's a very valid way of learning things
03:33:07 <srhb> Seems to be the fastest and most effective way of teaching for me.
03:33:09 <bitemyapp> tdammers: no.
03:33:18 <bitemyapp> tdammers: not at all. that's broken pedagogy. You can do better.
03:33:21 <srhb> bitemyapp: Don't oppress my teachings! :-)
03:33:32 <bitemyapp> elision, not forcing unnecessary thunks out of order - yes. Lies - never.
03:33:49 <bitemyapp> tdammers: you need *exercises*!
03:34:17 <tdammers> in all my own learning endeavors, I have skipped over any and all exercises, pretty consistently
03:34:22 <bitemyapp> intuition is grown from experience, but even that isn't enough - you need cogent explanations that quotient out internal mythologies.
03:34:36 <bitemyapp> you also need to design exercises that will excise bad intuitions.
03:34:41 <speak> http://www.seas.upenn.edu/~cis194/spring13/index.html << This was linked in the bitemyapp/learnhaskell   Problem with something like this, sorry to say, it took me a long time even figure out how get to the actual course!
03:34:52 <speak> Actually, I'm still not sure
03:34:56 <pawnda> I came here to ask a question and on that exact moment you linked that github repository with all that haskell stuff - lucky
03:35:00 <tdammers> bitemyapp: I don't subscribe to the active role you ascribe to a teacher here
03:35:20 <srhb> speak: lectures and assignments in the top?
03:35:23 <bitemyapp> tdammers: the material can perform the tasks outlined.
03:35:23 <tdammers> bitemyapp: maybe I'm biased because I'm so thoroughly self-taught in everything I deem important
03:35:34 <bitemyapp> speak: http://www.seas.upenn.edu/~cis194/spring13/lectures.html read lesson, then do homework is the pattern.
03:35:43 <bitemyapp> tdammers: that's great, the rest of us need material.
03:35:50 <tdammers> material is fine
03:35:54 <tdammers> and lies are to be avoided
03:35:58 <bitemyapp> tdammers: what do you think I'm describing?
03:36:02 <speak> srhb: Gotcha. That looked like some top site navigation that would've taken me away from this particular course, didn't even think to click on it
03:36:08 <bitemyapp> I'm describing how to convert direct teaching experience into scalable material.
03:36:11 <srhb> speak: I did a double take, too
03:36:23 <tdammers> ah, OK
03:36:39 <bitemyapp> tdammers: I am writing a book based on my experiences teaching people Haskell directly.
03:36:49 <tdammers> yes, that part I am aware of
03:36:52 <calvinx> Brent Yorgey - okay bitemyapp.
03:37:09 <bitemyapp> calvinx: I am not Brent Yorgey.
03:37:15 <tdammers> and actually, I think I mostly agree with you
03:37:25 <srhb> byorgey is Brent Yorgey.
03:37:27 <calvinx> ya, just saying that I noted the reference in your github link
03:37:31 <bitemyapp> srhb: but not bergey.
03:37:34 <calvinx> Aha. Nice :)
03:37:35 <srhb> gasp!
03:37:37 <tdammers> teachers should not lie
03:37:51 <bitemyapp> tdammers: not lying is a pretty low bar to clear.
03:38:01 <bitemyapp> tdammers: I outlined a lot of other things that are needed to do a good job conveying knowledge.
03:38:19 <bitemyapp> tdammers: I guess it's a commonplace thing to do in programming.
03:38:33 <tdammers> I don't think it's a low bar at all
03:38:58 <tdammers> at least if you consider allowing the student to form a wrong intuition and go with it despite knowing how it's wrong lying
03:40:46 <tdammers> anyway, any particular examples of lies LYAH tells?
03:41:59 <bitemyapp> tdammers: nope it's 0538 and I haven't slept yet.
03:42:01 <bitemyapp> I'm out.
03:42:07 <eXeC64> To be fair, science at school is more or less taught like, "Okay, everything we taught you up til now is not quite true. THIS is how it really is"
03:42:09 <calvinx> why does “let x = 4; let x = 3” work in ghci ?
03:42:10 <eXeC64> as they get more complex
03:42:23 <calvinx> I thought x, once assigned, is immutable?
03:42:46 <Haskellfant> calvinx: those are not the same x, the second one just hides the first one
03:42:53 <calvinx> I see.
03:43:11 <calvinx> In multiline mode, let x = 4; x = 3 does give an error.
03:43:24 <tdammers> bitemyapp: fair enough. pretty fried myself too.
03:43:25 <calvinx> I guess “let” locally scopes the assignment.
03:43:36 <srhb> calvinx: ghci is a special beast anyway
03:43:55 <srhb> calvinx: You could not do it in a source file (but then again, there are no top level lets in a hs file)
03:44:02 <eXeC64> If you did `let y = x` between the two lets you'll see that the original x stays at 4
03:44:08 <eXeC64> by looking at y
03:44:21 <calvinx> aha
03:44:40 <calvinx> makes sense.
03:46:41 * hackagebot koofr-client 0.1.0.0 - Client to Koofr API  http://hackage.haskell.org/package/koofr-client-0.1.0.0 (edofic)
03:54:54 <speak> bitemyapp: Re: the cis194 lectures, a lot of people (including me) have a visceral gut reaction upon seeing words like "home work", "assignments", "semester", etc. It would help a lot if this lecture would be reformatted by someone to appear differently to someone looking for a good Haskell tutorial
03:56:02 <speak> bitemyapp: I've had mostly horrible experiences with university lectures, and hence if I don't know any better, I will more likely choose another Haskell tutorial that looks more appealing (like Learn You a Haskell), than a dry looking university lecture
03:56:53 <shachaf> I've had bad experiences with things that call themselves "tutorials".
03:57:05 <shachaf> I try to avoid things that go by that name.
03:57:11 <shachaf> (There are exceptions, of course.)
03:57:16 <shachaf> What can you do?
03:57:16 <tdammers> fwiw, if you can look past the lecture / homework format, it looks like a decent learning resource
03:57:27 <speak> shachaf: Yes me too, I really meant an "online book", like Learn You a Haskell
03:57:34 <tdammers> maybe a little bit too "guided", but that's a matter of learning style, really
03:57:40 <eXeC64> How does Real World Haskell compared to LYAH?
03:58:21 <tdammers> eXeC64: if used with caution, it's a good kickstarter for people who are already experienced in other languages
03:58:56 <tdammers> eXeC64: the cautionary note being that it's somewhat dated, and so many of the libraries it covers are superseded by better things, including the programming practices they use
03:59:05 <Haskellfant> I used rwh more to lookup specific stuff than reading it from the start to the end
03:59:13 <tdammers> oh, yes, absolutely
03:59:56 <tdammers> it kind of fills the gap between "what is this Haskell thing and how do I get started" and API documentation a la Haddock
04:00:05 <nkar> eXeC64: rwh contains lots of errors because the libs changed since than.
04:00:20 <eXeC64> Ah, good to know.
04:00:49 <Haskellfant> most of the time it's not too hard to figure out how it has changed
04:01:37 <tdammers> I used RWH a lot to look up "how do I do X in Haskell" kind of questions
04:01:48 <Haskellfant> yeah exactly
04:02:17 <nkar> yeah, I also use it as a reference
04:02:25 <nkar> never read from the whole thing at once
04:02:38 <nkar> s/from//
04:05:33 <eXeC64> What fixity does standard function application " " have?
04:05:53 <eXeC64> Oh, wait. It's dependent on the function, right?
04:06:04 <ibid> it has no fixity
04:06:30 <shachaf> It is the stickiest except for three small exceptions.
04:07:36 <ibid> eXeC64: it's basically fixity 10 except there is no such thing
04:08:12 <nkar> shachaf: which exceptions?
04:08:54 <shachaf> I don't remember.
04:09:01 <nkar> lol
04:09:06 <shachaf> But one or two of them are record syntax.
04:09:11 <shachaf> f x{...}
04:09:30 <nkar> shachaf: is it in the report?
04:09:49 <ibid> nkar: yes
04:10:25 <eXeC64> What fixity does a type constructor have then?
04:10:27 <eXeC64> i.e. Just
04:10:44 <shachaf> nkar: It might be that bang patterns is the third one.
04:11:05 <nkar> okay, I'll look it up.  no hurry, just curious
04:11:15 <ibid> eXeC64: only infix things have fixity
04:11:32 <ibid> eXeC64: and Just is not a type constructor
04:12:07 <eXeC64> Do non-infix functions always take precedence over infix ones then?
04:12:35 <ibid> eXeC64: function application does
04:12:41 <shachaf> Function application (juxtaposition) is stickier than any infix operator.
04:13:15 <eXeC64> `f g x y` seems ambiguous to me
04:13:29 <ibid> eXeC64: that's not valid syntax
04:13:56 <eXeC64> So in that case brackets would always be required, or $?
04:14:14 <shachaf> What case?
04:14:16 <ibid> eXeC64: `...` can only be applied to variables or constructors, not expressions
04:14:35 <ibid> eXeC64: but if you means f g x y without the backticks, it's unambiguous
04:14:39 <ibid> *mean
04:14:56 <eXeC64> The backticks were just quoting, yeah
04:15:01 <eXeC64> not part of the snippet
04:15:42 <shachaf> You should say a bit more. Clearly it's not ambiguous enough that GHC has a problem with it, so you should point out what the problem is rather than just say it's ambiguous.
04:16:04 <nkar> eXeC64: try to define f x y z = undefined and use :t in ghci to check the type when using the infix form
04:16:06 <ibid> eXeC64: in f g x y, the f is the function and the g x y are its three arguments
04:16:29 <shachaf> Alternatively, ((f g) x) is the function and y is its argument.
04:16:40 <ibid> shachaf: yeah
04:16:45 <dramforever> @let somethingf x y z = undefined
04:16:47 <lambdabot>  Defined.
04:16:52 <dramforever> @type somethingf
04:16:52 <lambdabot> t -> t1 -> t2 -> t3
04:17:04 <eXeC64> See, I was thinking more: f (g x) y
04:17:08 <shachaf> Also, use /msg lambdabot unless you're demonstrating something to everybody in the channel.
04:17:09 <dramforever> eXeC64: No, why?
04:17:22 <ibid> eXeC64: then write it that way
04:17:28 <shachaf> eXeC64: So you should've said so!
04:17:34 <dramforever> shachaf: are you talking to me?
04:17:37 <shachaf> Function application is defined to associate to the left.
04:17:40 <eXeC64> Ah, sorry. So the leftmost function always takes precedence?
04:17:43 <dramforever> yep
04:18:14 <eXeC64> And f $ g x y would be invalid, since y would still be in the wrong place, correct?
04:18:23 <ibid> eXeC64: other way to say it is that function application is a left-associative binary operator
04:18:31 <shachaf> "f $ g x y" is the same as "($) f (g x y)"
04:18:35 <shachaf> Not invalid, just means something else.
04:18:41 <ibid> eXeC64: incorrect, as a matter of syntax. it may be a type error though
04:18:44 <dramforever> type invalid
04:18:57 <shachaf> No one said anything about types.
04:18:58 <dramforever> syntax okay
04:19:05 <eXeC64> Yeah, assuming g takes one argument and returns a single argument, and f takes two arguments
04:19:09 <eXeC64> parameters, rather
04:19:37 <dramforever> eXeC64: are you new to haskell?
04:19:42 <shachaf> > let { f = id; g = id; x = id } in (f g x y, f $ g x y)
04:19:43 <lambdabot>  (y,y)
04:19:49 <ibid> eXeC64: it may be a type error.  it's perfectly okay as syntax
04:20:00 <dramforever> > id id id id id id id id id id id 1
04:20:01 <lambdabot>  1
04:20:48 <eXeC64> dramforever: Relatively. I'm just trying to seal any leaks in my understanding of associativity.
04:20:54 <osfameron> > let na = id in na na na na na na na na "batman"
04:20:56 <lambdabot>  "batman"
04:21:04 <dramforever> lol
04:21:06 <dramforever> > na
04:21:06 <eXeC64> lol
04:21:07 <lambdabot>  Not in scope: ‘na’
04:21:07 <lambdabot>  Perhaps you meant one of these:
04:21:07 <lambdabot>    ‘a’ (imported from Debug.SimpleReflect),
04:21:07 <lambdabot>    ‘n’ (imported from Debug.SimpleReflect)
04:21:18 <dramforever> maybe let's @define na = id
04:31:33 <dramforever> Does anyone know about a good tutorial of grapefruit?
04:44:55 <dramforever> maybe I should ask again?
04:45:02 <dramforever> Does anyone know about a good tutorial of grapefruit?
04:48:08 <osfameron> generally, it's worth waiting longer than 10 minutes before asking again :-)
04:51:30 <ericelliott> Where can I find a good list of the various kinds of functions in fp? For instance, those that iterate over lists like map, and predicates that take a list and return a bool like filter? A definitive reference with a good functional programming glossary would be great. =)
04:53:21 <peddie> ericelliott: you could look at the documentation for Data.List if you want to know a bunch of functions for working with lists
04:53:33 <osfameron> ericelliott: https://www.haskell.org/hoogle/ might help
04:56:09 <ericelliott> osfameron, peddie: Thanks! Great resources.
05:24:27 <Darwin226> Why do functions like withStorableArray take a (Ptr e -> IO a) instead of just returning IO (Ptr e)?
05:24:40 <Darwin226> I mean, if I'm in IO, why the extra forced scoping?
05:26:09 <Saizan> Darwin226: they do some cleanup when you are done
05:26:11 <ClaudiusMaximus> Darwin226: guessing that the Ptr e is only valid within the callback, and will be freed automatically
05:27:39 <Darwin226> Saizan: ClaudiusMaximus So you're saying that if I do "ptr <- withStorableArray (\ptr -> return ptr)" i won't be able to use it?
05:27:53 <ClaudiusMaximus> Darwin226: yeah, it might even crash
05:28:14 <ClaudiusMaximus> @hoogle mallocArray
05:28:15 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
05:28:15 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
05:28:16 <lambdabot> Foreign.Marshal.Pool pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
05:28:35 <ClaudiusMaximus> that is an alternative, though you need to free it manually
05:29:04 <ClaudiusMaximus> and you'll need to fill the Ptr with data yourself
05:29:16 <Darwin226> Ok, that does make sense. Thanks guys
05:29:29 <ClaudiusMaximus> @hoogle pokeArray
05:29:30 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
05:29:30 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
05:29:46 <ClaudiusMaximus> @hoogle free
05:29:46 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
05:29:46 <lambdabot> package free
05:29:47 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
05:31:47 * hackagebot blaze 0.0.2 - None  http://hackage.haskell.org/package/blaze-0.0.2 (ChrisDone)
05:31:49 * hackagebot bools 0.1.1 - None  http://hackage.haskell.org/package/bools-0.1.1 (ChrisDone)
05:32:14 <calvinx> How do I colorise ghci so that whatever I am typing has syntax-aware colors?
05:33:33 <recursion-ninja> calvinx: https://www.haskell.org/haskellwiki/GHCi_in_colour
05:33:40 <bernalex> what should I use to get a for-loop that I can break out of?
05:33:46 <bernalex> monadplus stuff?
05:34:34 <bernalex> basically a user can specify let's say 10 levels, but then after 2 levels there might not be anything to do, so we need to break out.
05:34:45 <recursion-ninja> calvinx: essentially it's just ghci --colour
05:35:01 <recursion-ninja> calvinx: note the british version of the word colour
05:35:11 <bernalex> might just use explicit recursion
05:36:25 <calvinx> :( ghc: unrecognised flag: --colour
05:36:47 * hackagebot css 0.2 - Minimal monadic CSS DSL.  http://hackage.haskell.org/package/css-0.2 (ChrisDone)
05:36:49 * hackagebot data-extra 2.5.5 - None  http://hackage.haskell.org/package/data-extra-2.5.5 (ChrisDone)
05:38:08 <recursion-ninja> calvinx: Well that article is a year an a half old (26 June 2013), maybe it doesn't work any more :(
05:38:40 <calvinx> Probably.  In any case, I am using the GHC from here - https://www.haskell.org/platform/mac.html
05:40:22 <srhb> bernalex: unfolds or stuff from Control.Monad.Loops maybe
05:40:32 <srhb> (Or explicit recursion indeed)
05:41:47 * hackagebot eithers 0.2.0 - None  http://hackage.haskell.org/package/eithers-0.2.0 (ChrisDone)
05:41:49 * hackagebot ghc-server 1.2 - None  http://hackage.haskell.org/package/ghc-server-1.2 (ChrisDone)
05:42:33 <calvinx> It doesn’t say that there’s a —colour option in the docs either. Reference: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html#interactive-mode-options
05:42:52 <benzrf> calvinx: nice dashdash-to-emdash input method
05:43:03 <benzrf> calvinx: does it also correct quotes to smart quotes
05:43:24 <ClaudiusMaximus> calvinx: i think the article expresses a wish, rather than actual state of affairs
05:43:51 <calvinx> benzrf: don’t think so, I am using colloquy as my irc client
05:44:25 <calvinx> ClaudiusMaximus: ok, so there’s no easy way to have coloured syntax in ghci at the moment.
05:44:49 <ClaudiusMaximus> calvinx: right, the article describes some hacks
05:46:48 * hackagebot holey-format 2.1.0 - None  http://hackage.haskell.org/package/holey-format-2.1.0 (ChrisDone)
05:46:50 * hackagebot ircbouncer 0.2.0 - None  http://hackage.haskell.org/package/ircbouncer-0.2.0 (ChrisDone)
05:51:48 * hackagebot kibro 0.5.0 - None  http://hackage.haskell.org/package/kibro-0.5.0 (ChrisDone)
05:51:50 * hackagebot nums 1.2.0 - None  http://hackage.haskell.org/package/nums-1.2.0 (ChrisDone)
05:53:12 <ski> bernalex : exception monad ?
05:56:49 * hackagebot senza 0.1 - None  http://hackage.haskell.org/package/senza-0.1 (ChrisDone)
05:56:51 * hackagebot snap-app 0.7.0 - None  http://hackage.haskell.org/package/snap-app-0.7.0 (ChrisDone)
05:56:53 * hackagebot string 0.4.0 - None  http://hackage.haskell.org/package/string-0.4.0 (ChrisDone)
05:58:27 <calvinx> http://lpaste.net/115971  what does “it” mean? it’s an acronym for?
05:59:02 <maukel> it's english
05:59:52 <bergey> calvinx: ghci always lets you refer to the last expression evaluated as `it`.
06:00:11 <calvinx> O. as in “it” in “it is” ?
06:00:29 <mitu> and then you can do print it :)
06:01:22 <calvinx> O! That’s cool :D
06:01:37 <calvinx> So it refers only to the last expression.
06:01:43 <calvinx> “it” is the last expression.
06:01:49 * hackagebot texts 0.4.0 - None  http://hackage.haskell.org/package/texts-0.4.0 (ChrisDone)
06:01:51 * hackagebot wordcloud 0.1 - None  http://hackage.haskell.org/package/wordcloud-0.1 (ChrisDone)
06:01:53 * hackagebot validate 0.2.0 - None  http://hackage.haskell.org/package/validate-0.2.0 (ChrisDone)
06:01:55 * hackagebot validate 2.0.0 - None  http://hackage.haskell.org/package/validate-2.0.0 (ChrisDone)
06:05:40 <chrisdone> i'm finished deleting my deprecated packages. sorry for the spam
06:06:49 * hackagebot throttle 3.0.0 - None  http://hackage.haskell.org/package/throttle-3.0.0 (ChrisDone)
06:06:51 * hackagebot GeBoP 1.7.4 - Several games  http://hackage.haskell.org/package/GeBoP-1.7.4 (HenkJanVanTuyl)
06:12:33 <athan> If I have a monad transformer `Foo`, and I have two values `Foo Bar a` and `Foo Baz a`, with Bar and Baz being monads themselves, how do I run both in the same expression?
06:12:47 <athan> Do I have to do some `lift` magic?
06:13:21 <maukel> in general, you don't
06:13:55 <athan> maukel: Is there a way to coerce `Foo Bar a` into `Foo Baz a`, cleanly?
06:14:07 <maukel> in general, no
06:14:20 <bitonic> athan: not in general, you need some machinery a-la `mapStateT'
06:14:22 <maukel> that would give you unsafePerformIO
06:14:23 <bitonic> :t mapStateT
06:14:24 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
06:14:31 <bitonic> many transformers define such functions
06:14:32 <chrisdone> monad morphisms!
06:15:23 <athan> o.O? Thank you!
06:19:01 <blair1> Does anyone know if there is an issue using LD_LIBRARY_PATH with ghc7.8.3? If I us -L to pass my path then it works but seems to ignore the env var.
06:21:50 * hackagebot hpqtypes 1.2.4 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.2.4 (arybczak)
06:23:05 <altern> Hi all. I have problem loading module in ghci in ubuntu even though it works in windows with default configuration. Error message is following: Prelude> :l test/VersionTest.hs
06:23:05 <altern> test/VersionTest.hs:11:8:
06:23:05 <altern>     Could not find module `Test.AssertError'
06:23:05 <altern>     Use -v to see a list of the files searched for.
06:23:05 <altern> Failed, modules loaded: none.
06:24:06 <ClaudiusMaximus> altern: guessing case sensitive filesystem - try renaming test to Test
06:24:06 <altern> What should I do in ubuntu in order for test/VersionTest.hs to load automatically when I run ghci from project dir?
06:25:13 <altern> ClaudiusMaximus: you're right. it works after renaming test dir
06:25:17 <altern> thanks@
06:25:19 <altern> !
06:25:42 <ClaudiusMaximus> :)
06:37:11 <plow_brent> k
06:37:16 <plow_brent> ls
06:41:51 * hackagebot growler 0.4.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.4.0 (IanDuncan)
06:54:34 <dramforever> Hello, does anyone know if HTk is too old to use?
06:56:54 * hackagebot monad-resumption 0.1.1.4 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.1.4 (IanGraves)
06:57:07 <fugyk> Where should I go after finishing LYAH?
06:59:15 <tasker> Is there any particular tutorial anyone could recommend for repa ?
07:00:47 <mmachenry> fugyk: Real World Haskell is a great book and also Parallel and Concurrent Programming in Haskell is excellent.
07:02:34 <mmachenry> tasker: Parallel and Concurrent Programming in Haskell has a chapter on Repa
07:02:45 <tasker> mmachenry: Cool, thanks.
07:03:08 <mmachenry> fugyk: Also the typeclassopedia is a great read for right after LYAH
07:07:27 <dfeuer> Lennart Augustsson and Roman Cheplyaka commented on a Stack Overflow question in 2013 suggesting that GHC's definition of splitAt is not necessarily, or at least not always, better than the Report definition. Roman wrote he was considering writing a piece on this, but I can't see any indication of such.
07:07:32 <dfeuer> Does anyone know what the deal is?
07:09:49 * osfameron remembers he bought a copy of parallel haskell, wonders "where" he put it
07:09:59 <osfameron> (e.g. an book, direct from o'reilly...)
07:55:41 <tromp_> > 2**3
07:55:43 <lambdabot>  8.0
07:56:11 <tromp_> > 2**(256/66.0)
07:56:13 <lambdabot>  14.710637656406787
07:56:35 <tromp_> > 2**(256/62.0)
07:56:37 <lambdabot>  17.496958540137772
07:57:03 <hodapp> graaaaah, I cannot stand it when a package's only piece of example code doesn't work
08:05:40 <eXeC64> If non-infix functions are used in an infix way using backticks, i.e. `mappend`, what fixity are they given?
08:05:55 <maukel> same as operators, I hope
08:06:22 <eXeC64> Well, precedence I mean.
08:06:50 <exio4> I don't know the default, but you can change it with the normal infix/infixr/infixl commands
08:07:32 <eXeC64> I suppose it's trivial to test it
08:08:06 <tasker> Why can't stencils in repa be represented as a square array ?
08:08:09 <c_wraith> it defaults to infixl 9
08:08:15 <maukel> default is infixl 9 ... what he said
08:08:17 <c_wraith> the same as any other infix operator
08:08:53 <maukel> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2
08:09:17 <eXeC64> Ah, thanks
08:11:46 <eXeC64> Hmm, does haskell support unicode symbols as function / variable names?
08:12:02 <maukel> yes
08:12:22 <maukel> and there's an extension that enables unicode aliases for built in syntax
08:12:42 <eXeC64> maukel: Nice. Any idea what it's called?
08:13:10 <maukel> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#unicode-syntax
08:14:21 <geekosaur> note that they must be symbols; this is why you can't define lambda as an operator (it's a Greek letter, not a symbol)
08:15:03 <maukel> people who prefer λ over \ are wrong
08:15:34 <eXeC64> Hmm, can't use Σ as a function name it seems. "Not in scope: data constructor `Σ'"
08:15:41 <maukel> it's uppercase
08:16:06 <maukel> > S
08:16:07 <lambdabot>  Not in scope: data constructor ‘S’
08:17:37 <eXeC64> Oh, functions can't be uppercase?
08:17:44 <eXeC64> I never realised that
08:17:56 <maukel> uppercase is for constants, lowercase for variables
08:18:17 <maukel> (this requires a particular definition of "constants" and "variables" to work :-)
08:18:28 <eXeC64> Heh
08:18:45 <eXeC64> Shame. I was having fun defining Σ as a homegrown summation function.
08:22:07 <bananagram> :t (\)
08:22:08 <lambdabot> parse error on input ‘)’
08:22:18 <maukel> \ is syntax, not an operator
08:23:32 <orbital> I really wish people would stay away from characters that can't be easily entered using trivial means
08:24:46 <Xeironis> Am I right in assuming that you can't use tail-recursion on infinite lists?
08:24:48 <eXeC64> orbital: Not a fan of APL I take it ;)
08:25:47 <maukel> Xeironis: that might be right
08:26:01 <maukel> at least you can't do it foldl-style
08:26:05 <Xeironis> ok
08:26:12 <maukel> (foldl doesn't terminate on infinite lists)
08:26:17 <Xeironis> right
08:26:34 <orbital> eXeC64: had to look it up :) nah, that's fine, it has hardware compatibility
08:29:14 <eXeC64> orbital: Check out "implementing a sudoku solver in apl" on youtube if you want to be intimidated by some hardcore functional programming
08:29:25 <eXeC64> I can't follow it for the life of me
08:35:01 <orbital> eXeC64: brainfuck is more lighthearted
08:35:41 <eXeC64> Heh, yeah.
08:35:44 <orbital> imho :) and thus more amenable as a source of intimidation
08:35:58 <eXeC64> I used brainfuck for a university assignment once. Only a trivial one though.
08:36:19 <eXeC64> We were supposed to use C, so I wrote a brainfuck interpretter in C, then wrote the actual logic in brainfuck.
08:36:19 <Chathurga> Jesus christ it's hard to write brainfuck
08:36:34 <eXeC64> I was a little too bored at the time.
08:36:56 <Chathurga> I really want to finish a program in it, I worked out what I have to do but writing it...
08:37:04 <Chathurga> Keeping track of all those slots
08:37:24 <tdammers> Chathurga: write a Haskell program to do it for you
08:37:52 <indiagreen> tdammers: did you know there is a Haskell→Brainfuck compiler
08:38:01 <Chathurga> Hah, defeats the purpose for me in this case
08:38:52 <benzrf> i should try writing some kind of virtual machine in brainfuck some day
08:38:55 <benzrf> o3o
08:39:19 <tdammers> indiagreen: yeah. point-in-cheek and all that
08:39:34 <tromp_> try write a BLC interpreter in brainfuck
08:39:42 <benzrf> WHOA
08:39:47 <benzrf> tromp_: are you the guy who made the ioccc tromp
08:39:54 <tromp_> yep
08:40:10 <benzrf> o=
08:41:00 <benzrf> thats probably my 2nd favorite ioccc entry ever behind just the raytracer
08:41:16 <benzrf> of course i havent browsed /all/ of them but
08:41:31 <tromp_> are you including non-winning entries:-?
08:47:24 <mads-> What is BLC?
08:47:37 <apo_> Bacon, lettuce, caramel
08:48:23 <hamid> apo_, I'm not sure about the Bacon :/
08:48:36 <eXeC64> Eww
08:48:41 <eXeC64> Bacon Lettuce and Cereal ftw
08:48:50 <eXeC64> Or chicken
08:49:57 <maukel> mads-: binary lambda calculus
08:51:04 <mads-> mauke: thanks
08:51:33 <mads-> I guess it wouldn't be a stretch to believe the others - people name their stuff the weirdest these days
08:51:39 <ericelliott> I would love feedback on this (unpublished) article: https://medium.com/@_ericelliott/a63aa53a41a4
08:58:22 <lifter> Just read the 24 days of GHC extensions post on rebindable syntax. Wow...!
09:04:45 <pecanpy> if I have two IO String and I have a function (string -> string -> IO result). how would I use them? it's like bind but with 2 monad inputs
09:05:28 <pecanpy> i searched hoogle for: (a -> b -> c) -> m a -> mb -> mc
09:05:51 <c_wraith> pecanpy: in do notation, do x <- a1 ; y <- a2 ; f x y
09:06:06 <c_wraith> pecanpy: it's just chaining binds together
09:06:34 <Chathurga> I think liftM2 and join would work
09:06:50 <pecanpy> c_wraith: thanks.
09:06:50 <c_wraith> they would, but that's really kind of awkward. :P
09:08:08 <adamse> :t \f -> f <$> return "" <*> return ""
09:08:09 <lambdabot> (Applicative f, Monad f) => ([Char] -> [Char] -> b) -> f b
09:08:25 <Chathurga> Seems cleaner here, he'll still have to join the result of the do
09:08:29 <adamse> :t \f -> f <*> return "" <*> return ""
09:08:30 <lambdabot> (Applicative f, Monad f) => f ([Char] -> [Char] -> b) -> f b
09:08:43 <Chathurga> join (liftM2 f a1 a2)
09:09:18 <pecanpy> i appreciate the alternatives. i like to see how to do things without
09:09:22 <pecanpy> without "do"
09:09:48 <c_wraith> All of them are essentially different wrappers around a1 >>= \x -> a2 >>= \y -> f x y
09:10:36 <Chathurga> pecanpy: liftM2 will bring f from String -> String -> IO Result to IO String -> IO String -> IO (IO Result)
09:10:43 <Chathurga> then we join to get rid of the nested IO
09:12:37 <pecanpy> But in general though, maybe I messed up more fundamentally? If you want to load in X files and work with them would that always necessitate a do with X   __ <- ___ ? Or is there a nicer way
09:14:32 <pecanpy> I thought about doing something like [IO __] to IO [_] , but the ___s are not all the same type
09:16:51 <Chathurga> pecanpy: map over a list of filenames?
09:17:03 * hackagebot nerf 0.5.3 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.5.3 (JakubWaszczuk)
09:21:06 <pecanpy> Chathurga: yea I guess that works for now. I can load the Strings and then transform them later. Im still curious how i'd do it, if they weren't the same type though
09:21:33 <hodapp> gah, yet another example that doesn't work, this time in language-c
09:24:05 <Chathurga> pecanpy: Usually what I do is use liftMs: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#g:7 if I understand you correctly
09:26:34 <shapr> GOOD MORNING
09:26:39 <hodapp> >_<
09:27:08 <shapr> hodapp: How's code?
09:28:37 * shapr hops cheerfully
09:28:41 <shapr> Is it time for code yet?
09:28:51 <hodapp> shapr: Meh. I'm trying to figure out how to use language-c and some of their examples are not working.
09:29:13 <shapr> oh, I tried it at first release, it had some problems... but it mostly worked.
09:29:14 <hodapp> there are little corners that c-dsl missed, like storage specifiers (easy) and function declarations (???)
09:29:34 <shapr> hodapp: think you'll send 'em some patches?
09:29:47 <hodapp> shapr: maybe.
09:30:00 <hodapp> shapr: trying to figure out function declarations when I don't know how to make language-c do it.
09:30:14 <shapr> sounds challenging
09:30:36 <hodapp> I looked at SBV, and it looks really nice and well-supported, but it's too far outside of what I'm trying to accomplish
09:30:56 <hodapp> which is some sort of bastard-combination of Atom with some other C generation functionality
09:31:13 <shapr> ah, connected to copilot?
09:31:47 <hodapp> haven't used copilot yet, partly because copilot-core is broken to install for me, and partly because I don't need a monitor which seems to be what copilot is geared towards
09:32:11 <shapr> hodapp: I want to generate Arduino code from Haskell, what would you recommend?
09:32:32 <hodapp> shapr: what is the code supposed to accomplish?
09:32:58 <shapr> I'd like to replace all my arduino sketches
09:33:14 <shapr> But mostly I've done much Arduino the past coupla years, but no Haskell...
09:33:41 <shapr> So I'd like to try mixing them together.
09:34:02 <hodapp> shapr: have you looked at Ivory? I haven't used it but it sounds a little more suited.
09:34:08 * shapr looks
09:34:13 <hodapp> haven't used it because I can't install it - some installation issue I've not felt like fixing.
09:34:27 <shapr> oh, that does looks like a good option
09:34:51 <hodapp> Ivory was the one I couldn't install because it depended on old base
09:35:05 <hodapp> wonder how hard that'd be to get around.
09:35:10 <hodapp> because c-dsl and language-c are getting me down a bit
09:35:23 <shapr> yay quickcheck support is included!
09:35:42 <hodapp> and afaik, what I *need* is what Ivory does, provided I can make it interface nicely with Atom.
09:35:53 <shapr> What does Atom do that Ivory doesn't?
09:35:59 <glguy> hodapp: The github version is updated for new base
09:36:05 <hodapp> glguy: oh!
09:36:16 <glguy> hodapp: There was some dependency issue that was holding up a hackage release
09:36:24 <hodapp> glguy: you have some connection to Ivory?
09:36:43 <glguy> My connection is that I can see one of the main devs right now and I asked him
09:37:07 <shapr> heh, smart
09:37:09 <hodapp> glguy: can see him?!
09:37:16 <shapr> glguy: so, Lee is across the room from you? ;-)
09:37:23 <dmj`> anyone know a more elegant way to express: (a -> m ()) -> (b -> m ()) -> (a -> b -> m ())
09:37:33 <glguy> It needs a custom version of language-c-quote and they're working with that maintainer to get them integrated, but they can't do a hackage release against the custom changes
09:37:43 <glguy> I needed support for comment generation, i think
09:37:52 <dmj`> than,  fun f g k = f $ \x -> g $ \y -> k x y
09:38:03 <glguy> Lee is further across. I can hit him with a nerf shot on a good day
09:38:07 <shapr> heh, ok
09:38:10 <suvash> hi folks. is there some trickey involved in installing hindent on osx. (cabal install hindent i mean)
09:38:15 <suvash> trickery*
09:38:16 <hodapp> glguy: Are you at Galois or something?
09:38:45 <glguy> I am
09:39:29 <suvash> basicall `cabal install hindent` fails at installing dependencies, haskell-src-exts-1.16.0.1 to be specific
09:39:56 <hodapp> glguy: Oh, awesome.
09:40:24 * hodapp ponders Paypal'ing glguy some cash to buy a beer and/or coffee for Lee...
09:40:47 <glguy> Send Chipotle gift cards ;-)
09:40:49 <shapr> haha
09:41:04 <Adeon> does hackage build docs by itself yet
09:41:06 <hodapp> glguy: Ummm, I'm considering it, because I've been using a bunch of Lee's work :)
09:41:09 <dmj`> Adeon: yea
09:41:15 <Adeon> ah, excellent
09:41:15 <dmj`> Adeon: usually
09:41:23 <Adeon> I noticed that source links are missing from user-uploaded docs
09:41:27 <hodapp> had some trouble finding good Atom documentation, but what I could find seemed nice.
09:41:28 <Adeon> and I like to look at them
09:41:35 <Adeon> so I'd prefer if hackage made the docs
09:41:45 <glguy> Adeon: They are only missing if the uploaded neglected to build the docs for the dependencies
09:41:49 <dmj`> Adeon: sometimes hackage doesn't, if it doesn't, I'd recommend checking out glguys hackage script in the lens repo
09:41:51 <glguy> uploader*
09:41:56 <Adeon> ah, I see
09:42:54 * glguy is too impatient to sit around and wait for hackage to generate the docs even when it does ^_^
09:43:02 <hodapp> glguy: hmm, so, the github version if Ivory presently relies on some custom stuff that is also not in hackage?
09:43:18 <shapr> glguy: is there a Galois-recommended set of tools/libs for generating Arduino code from Haskell?
09:43:53 <hodapp> shapr: well, I can tell you that there were some pages online specifically about generating code for Arduino from Atom
09:44:07 <hodapp> they're at archive.org now though
09:44:21 <hodapp> shapr: https://web.archive.org/web/20110812162216/http://blog.sw17ch.com/wordpress/?p=84
09:44:32 <shapr> :-(
09:44:43 <hodapp> you can still view them
09:44:49 <hodapp> and they still were useful to me
09:44:57 <shapr> ah, so not much bitrot?
09:45:35 <hodapp> APIs have changed a little but the examples didn't seem to be that out of date
09:45:53 <shapr> that's good, I'll throw some of my spare time at getting this all working for me.
09:45:58 <hodapp> I really should write up a blog post of my experiences with Atom - it looks very robust and well-written but there is a lack of good documentation on it
09:46:02 <hodapp> at least, documentation I can find
09:46:08 <shapr> hodapp: yes please!
09:46:40 <glguy> shapr: I'll have to ask Lee what the current state of the art is... I don't do much of this stuff
09:46:47 <shapr> should I just email him?
09:47:06 <glguy> I can't imagine he'd mind ^_^
09:47:12 <shapr> ok, will do
09:48:20 <hodapp> glguy: is this custom language-c-quote anyplace I can get at it, if I need it to get Ivory working?
09:51:09 <shapr> glguy: ok, hopefully he'll have time to respond
09:51:41 <glguy> hodapp: standby :)
09:52:05 <hodapp> glguy: thanks
09:54:16 <glguy> hodapp: New story, the changes are already on hackage and I was wrong earlier
09:54:26 <glguy> so, the github ivory ought to work
09:55:49 <hodapp> glguy: awesome, thanks
09:57:06 * hackagebot haskanoid 0.1.3 - A breakout game written in Yampa using SDL  http://hackage.haskell.org/package/haskanoid-0.1.3 (IvanPerez)
10:01:16 * hodapp learns about cabal sandboxes...
10:03:25 <hodapp> oh, Ivory comes with a Makefile which can generate a sandbox for me and install itself into it. That's pretty slick.
10:03:36 <hodapp> or maybe every package already does this and I've just not noticed
10:04:27 <hodapp> shapr: you might be interested in knowing that too, since Ivory is likely closer to what you need
10:05:30 <bryanedds> > 5
10:05:32 <lambdabot>  5
10:11:09 <bryanedds> Can someone help me with this -
10:11:11 <bryanedds> > data M a b s = M of Either (a, s) ((a, s) -> M b ??? s)
10:11:13 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:11:21 <bryanedds> why does it keep giving me a parse error?
10:11:55 <rom1504> is ??? really a thing ?
10:11:59 <bryanedds> no
10:12:00 <glguy> It looks like you're writing the wrong language
10:12:12 <glguy> there's no Constructor "of" thing
10:12:21 <bryanedds> oh
10:12:30 <bryanedds> > data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:12:32 <lambdabot>  <hint>:1:1: parse error on input ‘data’
10:12:40 <rom1504> 19:09 < rom1504> is ??? really a thing ?
10:12:40 <rom1504> 19:09 < bryanedds> no
10:12:49 <bryanedds> still, the parser should go further than character 1
10:12:57 <glguy> now you just need to fix the question marks
10:13:06 <RchrdB> lambdabot doesn't parse data definitions
10:13:10 <RchrdB> (ghci does)
10:13:27 <bryanedds> ah
10:13:50 <bryanedds> So now that I actually have valid Haskell, I can ask my question -
10:14:30 <bryanedds> I'm trying to build a type M that returns either (a, s) or a function from (a,s) to M
10:14:44 <bryanedds> the problem is that I can't type it
10:14:53 <bryanedds> due to the question mark position
10:14:56 <bryanedds> data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:15:32 <bryanedds> I could add a c type parameter, but that leads to an infinite cycle of adding type parameters
10:16:19 <kwantam> bryanedd, 'b' does not seem meaningful in that type
10:16:29 <bryanedds> I'm not sure how to get a well-typed version of what I want
10:16:47 <kwantam> aren't 'a' and 's' sufficient type parameters?
10:17:40 <kwantam> seems as if the type you've described is Either (a, s) ((a, s) -> M a s)
10:18:26 <bryanedds> Well, I don't think that's sufficient because I want the type of a to vary
10:18:45 <bryanedds> for example, I want M to be able to represent this function -
10:19:04 <bryanedds> (a, s) -> (b, s)
10:19:21 <bryanedds> and (b, s) -> (c, s)
10:19:23 <bryanedds> and so on
10:20:08 <levicc00123> bryanedds: If you have the function written, load it into GHCi and ask it for the type signature
10:20:31 <bryanedds> I don't - I'm trying to model the concept
10:20:52 <kwantam> but it seems like you're fundamentally trying to not decide on the types ahead of time
10:21:21 <glguy_> bryanedds: you probably need something like: data M a s = Done (a,s) | forall b. Step ((a,s) -> M b s)
10:21:58 <glguy_> I'm not sure that that exact type is 1) what you need 2) going to be useful, but you'll have to store the intermediate types somewhere
10:22:35 <bryanedds> hm, maybe I should give a more general explanation as to what I'm trying to do
10:23:38 <bryanedds> I'm trying to build a monad M that represents a chain of operations (with state s threaded throughout) that can each be invoked at a later time.
10:24:11 <shapr> hodapp: yeah, that does look useful
10:24:48 <bryanedds> am I approaching that wrong?
10:25:02 <mmachenry> bryanedds: Can you use the state monad?
10:25:42 <bryanedds> not directly - each operation in the chains needs to be accessible sequentially
10:25:46 --- mode: Cale set -o Cale
10:26:15 <bryanedds> I need to be able to invoke each chained operation in a discrete step
10:26:28 <hodapp> shapr: I'm building it now (or trying to)
10:26:32 <bryanedds> (EG - as determined by a global tick event callback)
10:26:55 <bryanedds> so, each tick does one step in the operation
10:27:04 <shapr> hodapp: I won't have time to try it for several days... but if you're doing embedded dev, drop by on #haskell-embedded :-)
10:27:40 <bryanedds> with the state monad, I don't have access to each step, I have only either no results, or the result of all steps
10:27:51 <bryanedds> does this make sense?
10:28:52 <Cale> There are a bunch of things like you want, varying in levels of complexity
10:29:38 <bryanedds> in my case, the simplest solution would probably be the best place to start
10:30:44 <Cale> https://www.haskell.org/haskellwiki/ListT_done_right
10:31:38 <bryanedds> oh, and btw, Haskell-specific things probalby won't help me as I'm working in another language
10:32:05 <Cale> Well, you could possibly translate this to another language, depending on what language.
10:32:13 <bryanedds> *looks at link
10:32:39 <bryanedds> as long as its translatable to a strict functional language like ML
10:32:44 <Cale> The key thing is just the two lines near the top
10:32:55 <Cale> where MList gets defined
10:33:16 <Cale> The m parameter stands in for any other monad
10:33:21 <Cale> and the a parameter is the result type
10:34:34 <bryanedds> I doubt this will be much help to me, specifically
10:34:55 <bryanedds> Could we turn back to what I was trying and you could tell me where it's gone wrong?
10:35:37 <Cale> This is just a sort of trick to allow for partially evaluating a computation up to the point at which it can produce a single result
10:36:29 <hugomg> Hi, I am writing a compiler in Ocaml and use global mutable state to generate usnique identifiers (for various uses). What would be the haskell way to generate these unique identifiers without sideeffects?
10:37:10 <Cale> hugomg: Well, there are a bunch of strategies. There are pure splittable supplies
10:38:02 <bryanedds> Cale, could we look how to fix this approach - data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:38:23 <Cale> hugomg: You might like: http://hackage.haskell.org/package/value-supply
10:38:44 <KangaAkale> hello please i am getting this error
10:38:53 <bryanedds> Would we want to use this approach - data M a s = Done (a,s) | forall b. Step ((a,s) -> M b s)
10:38:56 <KangaAkale> Not in scope: ‘forM_’     Perhaps you meant one of these:       ‘V.forM_’ (imported from Data.Vector),       ‘V.forM’ (imported from Data.Vector)
10:39:25 <Cale> bryanedds: I don't understand why you want the existential.
10:39:35 <KangaAkale> and i already imporimport qualified Data.Vector as V
10:39:42 <KangaAkale> import qualified Data.Vector as V
10:39:47 <Cale> bryanedds: That's going to make the values of that type pretty useless when you finally get them, because you won't know what type they are.
10:39:49 <geekosaur> yes, you imported it qualified
10:39:55 <geekosaur> so you need to say V.forM_
10:39:59 <bryanedds> Well, the previous approach results in an infinite number of type parameters I think?
10:40:07 <hugomg> cale: looks like newSupply runs in the IO monad. How evil would it be to use unsafePerformIO to avoid needing to put my whole compiler inside IO?
10:40:13 <Cale> KangaAkale: You want V.forM_
10:40:32 <bryanedds> So let's go back to - data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:40:47 <ReinH> hugomg: Why not create the supply and then pass it in as an argument?
10:40:55 <ReinH> hugomg: Or as part of the state
10:40:57 <Cale> hugomg: Nah, the point of this is that you only need to newSupply once at the top level, and pass the resulting supply in
10:41:02 <bryanedds> Could we find a way to complete that definition and capture my intent?
10:41:10 <KangaAkale> getting this error stioll
10:41:12 <KangaAkale>  Couldn't match expected type ‘V.Vector T.Text’                 with actual type ‘[Int -> MatchDay]’     In the first argument of ‘V.forM_’, namely ‘matchT’     In the expression: V.forM_ matchT
10:41:26 <Cale> hugomg: Once you have a supply, there are pure operations to split it into more
10:41:42 <ReinH> KangaAkale: then you should fix that type error.
10:41:51 <Cale> hugomg: and to extract a value
10:42:29 <ReinH> KangaAkale: What is the type of V.forM_?
10:43:16 <Cale> hugomg: So you just take a supply as a parameter. The fact that you can only get one initially in IO is an implementation detail (which is hopefully not too onerous, because you can call newSupply once from main and then never again)
10:43:38 <hugomg> hmm, in the Ocaml version of my program I don't need to pass it as a parameter because its all global
10:43:50 <ReinH> hugomg: But in Haskell you do.
10:43:54 <hugomg> but I guess passing the supply as a parameter is not bad :)
10:43:59 <Cale> Yeah, well, probably there's a bunch of other configuration which you're already passing around
10:44:07 <ReinH> One common solution is to put the supply in a state monad.
10:44:12 <Cale> and it can just be a field in those records
10:44:45 <Cale> If you're going to use a State monad, you don't need this library though.
10:45:04 <hugomg> do you think a state monad is ideal if you have 3+ Supply values that you need to pass around in your configuration?
10:45:13 <ReinH> Ah. "without the need to thread state." Heh.
10:45:17 <hugomg> I figure I don't need to edit my configuration once I create it...
10:45:34 <Cale> http://hackage.haskell.org/package/concurrent-supply -- here's one with an even purer API
10:45:38 <ReinH> If you need a name supply, [1..] is a good one. ;)
10:45:47 <Cale> er, no, nevermind, I misread, it's the same :)
10:46:07 <ReinH> If you need 3 name supplies, ([1..],[1..],[1..]) is a good choice. ;)
10:46:40 <geekosaur> (ob lens :p )
10:49:10 <ReinH> geekosaur: ob lens?
10:49:48 <bryanedds> I'm still looking for help I can put into action - I've been stuck on this for quite a while.
10:50:00 <ReinH> bryanedds: what's the issue?
10:50:46 <Cale> bryanedds: Perhaps you could explain what a and b are meant to represent?
10:50:52 <bryanedds> I'm trying to build a monad M that represents a chain of operations (with state s threaded throughout) that can each be invoked at a later time.
10:51:00 <Cale> bryanedds: Presumably s is some sort of state type?
10:51:19 <hugomg> I have another question. IN the Ocaml program I wrote, a common thing I have to do is do a fold on a tree to generate some primary value and also generate some extra results on the side. What I would end up doing is create some mutable queues/maps that I populated with data during my fold. Whats the haskell way to do that? I figure some kind of state monad but I'm not really sure how to make that work if I have multiple bits of state...
10:51:21 <bryanedds> Currently I have this not complete declaration - data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:51:45 <bryanedds> Cale, a and b are _not_ state actually
10:51:48 <bryanedds> s is the state
10:52:09 <bryanedds> a and b are the monadically bound variables
10:52:25 <ReinH> hugomg: Trees can be folded and traversed. What sort of "extra results" need to be produced?
10:52:31 <bryanedds> does that make sense?
10:52:37 <Cale> data M s p a = Done (s -> (s, a)) | Partial (s -> (s, p, M s p a))
10:52:43 <Cale> You could do something like that
10:52:54 <Cale> I don't know what "monadically bound" means
10:53:08 <bryanedds> bound via monadic binding
10:53:09 <hugomg> for example, I am doing a fold on a tree but I also need to generate "on the side" a list with some info for every Declaration node I visit
10:53:31 <ReinH> bryanedds: What does it mean for a type variable to be "bound via monadic binding"?
10:53:48 <Cale> bryanedds: Abstractly a monad has only one result type parameter
10:54:10 <ReinH> hugomg: You can produce a tuple as the result of your fold, (a,[b]), where a is your result type and b is your info type.
10:54:16 <Cale> bind has type  M a -> (a -> M b) -> M b -- each M is only associated with a single type of result
10:54:35 <bryanedds> right, that's why i need a and b
10:54:44 <Cale> hm?
10:54:45 <bryanedds> but I also need to thread through state s
10:54:54 <bryanedds> which is unrelated to a or b
10:54:56 <Cale> There's really only one parameter there though
10:55:02 <ReinH> hugomg: Alternatively, you could use a monadic fold to add to the list using a Writer monad, but that doesn't seem to have any advantages.
10:55:18 <hugomg> reinh: but I don't want to thread lots of tuples around. Its a lot of boilerplate... It also doesn't scale well - soon enough you might end up with a 3+ element tuple...
10:55:21 <Cale> There are two type variables which indicate the two types of results involved in a bind operation
10:55:29 <Cale> But it's the same parameter in the type definition
10:55:54 <bryanedds> oh
10:56:20 <bryanedds> hmm
10:56:40 <bryanedds> then maybe my defintion could be simplified from - data M a b s = M (Either (a, s) ((a, s) -> M b ??? s))
10:56:42 <Cale> You might have a different type of final result from the type of partial results which are emitted as the program executes
10:56:45 <Cale> How does this look?  data M s p a = Done (s -> (s, a)) | Partial (s -> (s, p, M s p a))
10:57:06 <bryanedds> hold on; parsing :)
10:57:08 <ReinH> hugomg: What alternative would you propose?
10:57:26 <bryanedds> could you say what p is here?
10:57:28 <hugomg> well, I don't konw. thats why Im asking how to do it :D
10:57:38 <Cale> So, a computation of type M s p a is either going to produce no partial results (i.e. it's done from that perspective), and will take the initial state, producing a final state and final result pair
10:57:57 <hugomg> its just that in Ocaml its very easy to just use more mutable state (although thats impure, which comes with its own downsides)
10:58:20 <Cale> Or, it will produce partial results, and will take the initial state and produce a triple, consisting of a partial result, a new state, and a computation with which to proceed afterward.
10:58:49 <Cale> (sorry, swapped the order around there, the value of type p is the partial result, the value of type s is the new state
10:58:49 <Cale> )
10:58:52 * johnw wonders if there is a Functor-based equivalent to mapAccumL
10:59:19 <Cale> p is the type of the partial results produced as the whole computation runs
10:59:22 <bryanedds> By partial result, do you mean the intermediate results?
10:59:25 <Cale> yes
10:59:32 <bryanedds> ah okay
10:59:37 <ReinH> hugomg: In Haskell there are basically two alternatives: carry things around in parameters, or carry things around in types that allow you to maintain some sort of context.
10:59:42 <bryanedds> and p is what is bound by bind, right?
10:59:44 <Cale> no
10:59:57 <Cale> a is
10:59:59 <ReinH> hugomg: The former should be obvious, the latter is exemplified by the monad typeclass
11:00:13 <bryanedds> oh, right
11:00:21 <Cale> (it's always the last type parameter)
11:00:26 <Cale> So, we'd have:
11:01:02 <ReinH> For example, Reader is a type that contains an immutable context that you can read from. Reader a r is isomorphic to (a -> r), the type of functions that take an a and provide an r. This is a direct translation of argument passing to monadic style.
11:01:25 <ReinH> Rather than pass a parameter around, you use a type that provides a monadic interface to manage some sort of context.
11:01:43 <ReinH> (Not all monads are for managing "context', though, so don't take this explanation to be fully general)
11:01:50 <Cale> runM :: M s p a -> s -> Either (s,a) (s,p,a) -- note, this could work as well...
11:02:01 <johnw> ReinH: nice caveat :)
11:02:10 <ReinH> johnw: :)
11:02:13 <juanpablo_> Does (<*>) have an actual name? How do you pronounce it when talking aloud?
11:02:18 <ReinH> juanpablo_: "ap"
11:02:22 <hugomg> my problem is that I never felt very comfortable using monad transformers  to add a bunch of monads together though
11:02:30 <Cale> er, sorry, no that's not right
11:02:37 <ReinH> hugomg: I prefer passing arguments for many cases
11:02:40 <johnw> juanpablo_: or "apply"
11:02:59 <Cale> Let's call it:  stepM :: M s p a -> s -> Either (s, a) (s, p, M s p a)
11:03:09 <hugomg> yeah, I figure that must be simpler
11:03:20 <bryanedds> ya, step sounds better
11:03:58 <bryanedds> as a matter of taste, would you personally use Either, or would you use the full custom type definition?
11:04:03 <Cale> Oh, also, just for reasons, I want to flip that over
11:04:10 <hugomg> but just one thing, I know that there is mutiple kinds of state monad you can use (State, ST, etc) how do you choose which one to use?
11:04:18 <Cale> stepM :: M s p a -> s -> Either (s, p, M s p a) (s, a)
11:04:26 <johnw> hugomg: it depends on the behavior you want
11:04:28 <Cale> The partial case is sort of the "exceptional" one
11:04:30 <juanpablo_> I think I'm going with `ap`.
11:04:37 <Cale> So it should be Left :)
11:04:48 <bryanedds> hehe, no prob :)
11:04:53 <hugomg> what I want is to accumulate some data "on the side" while I am doing some other computations
11:04:56 <Ankhers> I have a string that looks like "1 2 3\n4 5 6". How could I convert that into [[Int]]
11:05:24 <mauke> hugomg: ST is very different
11:05:31 <bryanedds> as far as implementing bind is concenered, would I pattern it after Either's bind, or just do it from first-principles?
11:05:40 <mauke> hugomg: what you're describing sounds more like State or Writer
11:05:47 <Cale> I'd just do it from scratch
11:05:51 <bryanedds> ok
11:06:24 <bryanedds> oh, you mean the bind impl, or the type definition?
11:06:30 <Cale> bind implementation
11:06:32 <hugomg> can use use Writer even if you want to have more than one "log" on the side?
11:06:48 <bryanedds> If I were to make this a haskell lib, would it be considered generally useful?
11:06:57 <johnw> hugomg: sure you can
11:07:01 <bryanedds> or should I just take it as a one-off thing in my code base?
11:07:16 <ReinH> hugomg: Yes. You can use ([],[]), for example.
11:07:22 <johnw> hugomg: a Writer just contains a monoid, so you can use a tuple of lists to accumulate to either or both lists with each "tell"
11:07:43 <ReinH> Writer uses a monoid and products of monoids, like ([],[]), are monoids:
11:07:58 <ReinH> > ([],[]) <> ([1],[])
11:08:00 <lambdabot>  ([1],[])
11:08:02 <hugomg> Using ([], []) makes it more annoying to update only one of the fields though. I guess lenses might make it not suck though...
11:08:24 <Cale> bryanedds: Well, there are lots of similar Haskell libraries
11:08:31 <ReinH> hugomg: You don't even need lenses, just write a little function to wrap up a value in the correct size of the tuple
11:08:51 <Cale> bryanedds: Among the more sophisticated is pipes
11:08:54 <ReinH> hugomg: Let's say you want to log foos and bars, so you write logFoo foo = tell ([foo],[]) and logBar bar = tell ([],[bar])
11:09:14 <bryanedds> ah, so I'd have to get to know them all
11:09:20 <hugomg> hmm, didn't know about that. Kind of relies on monoid magic though :)
11:09:30 <ReinH> hugomg: Writer relies on monoid "magic".
11:09:37 <ezrios> Hello, I am trying to use HSpec to test a Parsec parser
11:09:49 <ezrios> but I am unsure how to write my expectation; currently I have
11:09:54 <hugomg> Does this still work if its not a loits though. FOr example, what if I want one of the lists to be an integer counter instead of a list?
11:10:06 <ezrios> parseTranscript fixture `shouldBe` (Right expectedTranscript)
11:10:29 <Cale> bryanedds: also that ListT done right thing is basically this... I think I might've messed up slightly, I'm not awake yet, but ListT applied to a State monad is more or less what you really want
11:10:30 <ezrios> however, parseTranscript is just a partially applied "parse", which returns Either ParseError Transcript
11:10:34 <S11001001> @pl \l r -> x `f` l `f` r
11:10:35 <lambdabot> f . (x `f`)
11:10:46 <Cale> bryanedds: In fact, let's do it that way
11:10:47 <ezrios> and I get     No instance for (Eq Text.Parsec.Error.ParseError)
11:11:04 <mauke> > (Sum 41, Product 5) <> (Sum 1, mempty)
11:11:05 <lambdabot>  (Sum {getSum = 42},Product {getProduct = 5})
11:11:15 <Cale> bryanedds: We'll just apply MList to the State s monad, and apply a hammer to it and see what we get
11:11:25 <mauke> > (Sum 41, "hello") <> (Sum 1, mempty)
11:11:27 <lambdabot>  (Sum {getSum = 42},"hello")
11:11:30 <bryanedds> ok
11:13:15 <ReinH> hugomg: Sure
11:13:28 <ReinH> > ([],Sum 0) <> ([],Sum 1)
11:13:30 <lambdabot>  ([],Sum {getSum = 1})
11:13:33 <ReinH> hugomg: all products of monoids are monoids :)
11:13:55 <ReinH> hugomg: you can also write your own data type and make it an instance of monoid
11:14:33 <Geraldus> Hi, friends! I have strange error when building GHC 7.8.3: ghc-cabal: LICENSE: does not exist. I'm on Debian 7. Can someone help with this?
11:14:36 <hugomg> ah yes, I forgot the FP answer to all problems is more datatypes :)
11:15:15 <ReinH> data MyInfo = MyInfo [String] Int; instance Monoid MyInfo where mempty = MyInfo mempty 0; MyInfo xs i `mappend` MyInfo ys j = MyInfo (mappend xs ys) (i + j)
11:15:41 <ReinH> then you can say MyInfo [] 0 <> MyInfo [] 1 and so on
11:15:46 <Cale> bryanedds: Oh, I just realised something
11:16:17 <ReinH> hugomg: All problems can be solved by adding more layers of abstraction ;)
11:16:19 <Cale> bryanedds: This ListT uses the intermediate results in bind
11:16:41 <KangaAkale> please i have this error Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]
11:16:53 <bryanedds> hm
11:16:55 <KangaAkale> cant figure where it could be from
11:16:55 <Cale> KangaAkale: Sounds like you forgot to supply a function parameter
11:17:04 <mauke> KangaAkale: it tells you where it's from
11:17:13 <mauke> including the exact file and line
11:17:14 <Cale> KangaAkale: The line number should be right before the message you pasted
11:17:31 <Geraldus> you missed something, actually, when building your list, I guess you forgot 1 attribute
11:17:50 <lpaste> Cale pasted “smashing ListT a bit” at http://lpaste.net/116002
11:17:59 <Cale> bryanedds: ^^ have a look there
11:18:03 <bryanedds> Did we not want the a and b in bind here is going to be p, no?
11:18:16 <Cale> Yeah, this is actually a different approach now, we don't have p
11:18:39 <Cale> We could put in a final result as well... but I think it would change how the computation proceeded through binds
11:18:46 <lifter> When using the "RebindableSyntax", is it possible to import the default "if .. then .. else" behavior from Prelude?
11:18:59 <KangaAkale> yes i know but here is the snipett http://lpaste.net/7175881283409543168
11:19:26 <bryanedds> wow, why where you able to make p disappear?
11:19:39 <mauke> KangaAkale: but what's the error message?
11:19:51 <lpaste> Cale revised “smashing ListT a bit”: “No title” at http://lpaste.net/116002
11:20:19 <Cale> bryanedds: Well, because ListT uses partial results of type a, and when binding, it captures them all
11:20:53 <KangaAkale> mauke Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]
11:20:58 <Cale> bryanedds: So, they're not emitted separately, each one of them is used as a parameter to the rest of the computation in bind
11:21:01 <athan> If you wanted to pack system files into a haskell program at compile time, how would you do it?
11:21:16 <mauke> KangaAkale: no, the actual, complete error message
11:21:46 <KangaAkale> mauke Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]     In the first argument of ‘return’, namely ‘matches’     In a stmt of a 'do' block: return matches
11:21:58 <mauke> KangaAkale: no, the actual, complete error message
11:22:00 <bryanedds> Since I'm in another language, I wonder if I should try to get rid of p too
11:22:35 <Cale> bryanedds: Really, the best way to structure this probably depends on how you're using this... there are a lot of variations and similar monads in this design space
11:22:40 <bryanedds> or just consider that an artifact of this haskell implemetation technique
11:22:47 <bryanedds> ah ok
11:22:51 <KangaAkale> that is the actual error message
11:23:00 <mauke> KangaAkale: no, it's not
11:23:03 <Cale> bryanedds: These monads also likely work very differently
11:23:08 <mauke> KangaAkale: for one, it's missing the file and line number
11:23:25 <bryanedds> ya
11:23:38 <KangaAkale> ok: i have added the file name and line number MatchDB.hs:65:30:     Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]     In the first argument of ‘return’, namely ‘matches’     In a stmt of a 'do' block: return matches
11:23:46 <bryanedds> well, that's definitely a great start
11:23:51 <Cale> (apart from the fact that you can run them partially)
11:24:04 <bryanedds> I'd like to thank you once again for your time and patience, Cale :)
11:24:44 <KangaAkale> mauke: MatchDB.hs:65:30:     Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]     In the first argument of ‘return’, namely ‘matches’     In a stmt of a 'do' block: return matches
11:24:47 <bryanedds> I will probably be back with more questions when I start trying to define bind :P
11:24:50 <Cale> bryanedds: The key idea is that if you want to be able to pause the computation and produce partial results, you have a case in the representation of your computations with a field that has the remaining computation
11:24:55 <Cale> along with whatever other stuff
11:25:04 <bryanedds> ya
11:25:14 <hugomg> just wondering: If I use the List monoid to accumulate data in a Writer monad, will that have bad performance due to "left associative" concatenations?
11:25:33 <bryanedds> and presumably I'll be able to write getState and putState for this too
11:25:40 <Cale> Depending on whether that "other stuff" has a value of the final result type or not, you'll end up with binds which operate very differently
11:26:17 <Cale> If it does, then you get a kind of nondeterminism (in the sense of nondeterministic Turing machines, taking multiple paths)
11:26:21 <mauke> KangaAkale: is quickQuery' from Database.HDBC?
11:26:50 <KangaAkale> yes
11:26:54 <bryanedds> you know what would be a great article for haskell experts to write for haskell noobs?
11:27:11 <Cale> If not, then you have no choice about how to proceed when you hit one of these partials -- you get some intermediate results, and a computation that you need to continue with unconditionally if you ever want your final result.
11:27:14 <bryanedds> A nice general tutorial on deriving various definitions for bind
11:27:30 <bryanedds> writing bind is one of the hardest things I've come across in FP
11:27:53 <Cale> Well, I've done some live tutorials for specific monads for people in the past
11:28:18 <bryanedds> I wonder if that could be generalized to writing binds for most any case
11:28:22 <ReinH> KangaAkale: It looks like you didn't fully apply the MatchDay constructor
11:28:26 <Cale> The thing isn't so much that bind itself is tricky -- for some monads, bind is really easy to write
11:28:27 <mauke> KangaAkale: what happens if you give toMatch a type signature?
11:28:42 <bryanedds> there must be some general principle to approaching it
11:29:00 <ReinH> So you have a list of functions Int -> MatchDay, which represent the a function of the final missing argument to MatchDay
11:29:04 <Cale> For the monads which involve functions in their definitions though, that I think is what gets beginners confused
11:29:09 <bryanedds> well, that also includes writinf join and fmap when implenting bind in terms of those is simpler :)
11:29:10 <ReinH> s/the a/a
11:29:31 <bryanedds> Cale, ya, those tend to blow up my brain
11:29:40 <Cale> Well, it's sort of the same as what ought to be your approach to anything: looking carefully at what types of things you have, and what type of thing you need to produce at each step.
11:29:47 <Cale> Let's do the state monad as an illustration
11:30:02 <bryanedds> well, the problem is this -
11:30:06 <ajcoppa> the NICTA course is fantastic for that btw (implementing bind for different monads)
11:30:07 <ReinH> The nice thing about writing them is that there's usually a very small set of possible implementations. You just have to find one and see if it's the right one. ;)
11:30:20 <bryanedds> we also don't often know our monad's type is correct, too
11:30:39 <ReinH> bryanedds: Best way to find that out is to see if the laws hold up
11:30:42 <bryanedds> so usually we're defining both the type and bind sort of at the same time
11:30:48 <ReinH> Then you'll at least have *a* monad.
11:30:54 <Cale> bryanedds: When we're doing experimental stuff like this, sure. This is actually sort of the wrong approach we're taking.
11:31:04 <bryanedds> and then there's the question, is this the *right* monad :)
11:31:11 <ReinH> bryanedds: I never want to define a function's type and definition at the same time
11:31:21 <ReinH> That way lies madness
11:31:26 <Cale> bryanedds: What we ought to be doing is writing down all the operations on the sort of computations we need, and not worry about whether what we're going to end up with is a monad.
11:31:52 <Cale> At least, not be especially worried -- maybe an operation like bind is exactly what we want, in which case we probably do.
11:32:03 <bryanedds> that's true in principal, but sometimes you know you need one or your API is worthless
11:32:04 <KangaAkale> mauke: what wil that be
11:32:10 <bryanedds> EG - the monad is the point of the API
11:32:20 <chrisdone> bryanedds: if you think writing >>= is hard, you're gonna have a fun time when you encounter monad-control
11:32:23 <Cale> Well, no, it's never the central focus
11:32:35 <Cale> Knowing that something is a monad tells you almost nothing of use.
11:32:40 <mauke> KangaAkale: [SqlValue] -> MatchDay
11:32:41 <ReinH> KangaAkale: Did you read what I said? I answered your question.
11:32:52 <Cale> It's the other operations which really give it the character of being a useful library
11:32:58 <bryanedds> it can inform you whether you have a good API, no?
11:33:06 <mauke> and yeah, ReinH is likely right
11:33:17 <Cale> Knowing that it's a monad just gives you some control-structure-like operations which are nice to have without needing to write them because they're defined in Control.Monad
11:34:11 <bryanedds> That's interesting ReinH, we usually define both fn impl and signature literally at the same time in MLs
11:34:15 <Cale> But giving up on having a monad is not the end of the world. It's just one possible flavour of combinator library which frequently comes up.
11:34:25 <chrisdone> aha! i knew it!
11:34:41 <ReinH> bryanedds: If you read Richard Bird's new book on Haskell, the second rule is to figure out the types first. ;)
11:34:43 <chrisdone> i have this theory that haskell separates types and implementation better than ML and F#
11:34:52 <ReinH> chrisdone: huh :)
11:35:00 <Cale> ReinH: Oh, Bird has a *new* book on Haskell?
11:35:07 <chrisdone> due to the magical invention of the invicino separate type signature declaration
11:35:15 <bryanedds> ya, I hope it's a lot more readable than his first...
11:35:23 <monochrom> Cale, "thinking functionally with Haskell"
11:35:24 <ReinH> Cale: Yep! It's a rewrite of Intro to FP using H called Thinking Functionally with Haskell
11:35:28 <bryanedds> my god I couldn't finish a single chapter in the first one...
11:35:28 <chrisdone> foo :: X -> (P -> F a) -> Z a
11:35:28 <chrisdone> foo = undefined
11:35:29 <Cale> cool
11:35:30 <chrisdone> ^ that's magic
11:35:39 <ReinH> bryanedds: That's a shame. It's the best book on FP I've ever read.
11:35:48 <bryanedds> it is
11:35:54 <bryanedds> pissed me off so much...
11:35:58 <chrisdone> in ML and ATS you have to write some of the code while writing out your type
11:36:12 <pecanpy> what command do i use in ghci to fix "interact"? one page said to use ":load
11:36:14 <Cale> "The best book on FP you've never read" -- good byline text
11:36:30 <ReinH> Cale: hahaha
11:36:32 <pecanpy> but that results in hGetContents: invalid argument (Bad file descriptor)
11:36:46 <bryanedds> "The best book on FP you tried to read but couldn't because you either suck or the prose is too opaques, hard to say."
11:37:07 <ReinH> bryanedds: the new one has plenty of exercises with answers, which is great
11:37:11 <ReinH> But it is dense, I agree
11:37:23 <mauke> pecanpy: I wouldn't use interact in ghci
11:37:26 <Cale> bryanedds: But let's define the state monad step by step so that I can show you interactively how to think about these things
11:37:31 <bryanedds> ok
11:37:33 <mauke> nothing good can come from it
11:37:43 <RyanGlScott> Is it possible to use -XRebindableSyntax to change how GHCi prints things?
11:37:43 <pecanpy> mauke: fair enough
11:37:53 <Cale> bryanedds: So, we want a way to represent computations which manipulate a state value of type s while producing some result of type a
11:38:06 <bryanedds> ya
11:38:41 <Cale> bryanedds: We could come up with some sort of syntax trees involving operations on the state and whatnot, but since we're working in a functional language, a particularly natural representation is just to use a function
11:38:58 <Cale> More specifically, a function from the initial state to a pair consisting of the final state and result
11:39:10 <Cale> Thus we'll have:
11:39:18 <Cale> newtype State s a = S (s -> (s,a))
11:39:40 <chrisdone> re the type decl, Conor McBride commented similar sentiments on reddit: “I was glad to see "bidirectional" in there, as good practice making types informative (for humans and for instance inference, etc) is to be explicit about top-level types, then propagate them.”
11:40:03 <Cale> Here, s is the state type, and a is the result type. I'm using a different name for the data constructor (S) than for the type constructor (State) just to keep the distinction clear on irc :)
11:40:11 <bryanedds> what threw me earlier is that I though the a and b from bind needed to be in the type of State
11:40:22 <chrisdone> in practice i tend to just write code and then let ghci insert the type for me. but on the occasion i don't know what to write, i write out the type and incrementally build up the code with undefineds
11:40:48 <johnw> chrisdone: o/
11:40:58 <chrisdone> \o
11:41:10 <Cale> So, we get from this the data constructor   S :: (s -> (s,a)) -> State s a   which will be our primitive way to construct computations at first, but eventually we're going to define enough operations to avoid ever needing to use S directly.
11:41:56 <Cale> Normally, I might start with get and put, but since the discussion is especially about the monad structure, let's start with return and (>>=)
11:42:13 * hackagebot aws-dynamodb-streams 0.1.0.0 - Haskell bindings for Amazon DynamoDB Streams  http://hackage.haskell.org/package/aws-dynamodb-streams-0.1.0.0 (JonSterling)
11:42:15 * hackagebot ffmpeg-light 0.8.1 - Minimal bindings to the FFmpeg library.  http://hackage.haskell.org/package/ffmpeg-light-0.8.1 (AnthonyCowley)
11:42:33 <Cale> So, return :: a -> State s a  is going to be a function that takes a value, and produces a computation which "does nothing" except to produce that value as its result
11:42:52 <Cale> return v = ...
11:43:21 <bryanedds> Return can be used as a continuation, and a substiture for f in bind, right?
11:43:22 <Cale> We know we want to produce a computation of type State s a, and we don't have many ways to do that yet apart from using S, so let's use it:
11:43:24 <Cale> return v = S ...
11:43:54 <Cale> It can, though it's a very boring one
11:44:08 <Cale> One of the monad laws is that x >>= return is the same as x
11:44:19 <S11001001> Is there the function somewhere Monad m => m a -> (a -> m b) -> m a [sic]?
11:44:20 <codygman-> I'm trying to print out a directory, go up a level, print that, etc... all the way to the root. I've got "foldM (const takeDirectory)" so far, but I'm really not sure what the Char should be it's asking for: foldM (const takeDirectory) :: Char -> [FilePath] -> [Char]
11:44:22 <Cale> So using return there makes using bind at all somewhat pointless
11:44:47 <Cale> so, now S takes a parameter of type (s -> (s,a))
11:45:04 <Cale> Since we're supplying a function, we might as well make it a lambda
11:45:09 <Cale> return v = S (\s -> ...)
11:45:14 <bryanedds> right
11:45:18 <Cale> Now we have the initial state s
11:45:24 <chrisdone> codygman-: compare with the type of foldM
11:45:26 <chrisdone> :t foldM
11:45:27 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:45:29 <Cale> and we need to produce a final state and result of type (s, a)
11:45:51 <Cale> the point was to "do nothing", which in this context probably means to leave the initial state unaffected in the result
11:45:55 <Cale> return v = S (\s -> (s,...))
11:46:10 <bryanedds> right
11:46:11 <chrisdone> codygman-: you have ([Char] -> FilePath -> [Char]) -> Char -> [FilePath] -> [Char]
11:46:27 <Cale> and then we need a result of type a, and the only thing handy is this v, which thankfully agrees with what we said return v was going to do
11:46:32 <Cale> return v = S (\s -> (s, v))
11:46:34 <chrisdone> codygman-: so presumably takeDirectory has type FilePath -> [Char]
11:46:40 <Cale> Okay, so now bind :)
11:46:48 <Cale> actually, before bind, let's write one more thing:
11:46:58 <codygman-> chrisdone: Yes
11:47:00 <Cale> runState :: State s a -> s -> (s,a)
11:47:12 <bryanedds> ya, herre's a question
11:47:26 <chrisdone> codygman-: ah, alteration: you have (Char -> FilePath -> [Char])
11:47:27 <bryanedds> do you typically write the runner before you write bind?
11:47:29 <Cale> Depending on our representation of State s a, this function might be some sort of interpreter
11:47:32 <Cale> yes, usually
11:47:35 <bryanedds> ah
11:47:44 <bryanedds> I bet that makes things easier
11:47:48 <Cale> (and you'll see why in a moment)
11:47:54 <chrisdone> codygman-: because foldM has to run in some monad, so given that you're returning [a], which is a monad, then the 'm a' is [a]
11:48:08 <Cale> In this case, runState is totally trivial to write though, because of our chosen implementation for State s a
11:48:11 <chrisdone> so it just infers that the 'a' must be Char
11:48:18 <Cale> runState (S f) s = f s
11:48:35 <Cale> We just unpack the function and apply it to the given initial state, and that gives us the final state and result
11:48:56 <Cale> We could even skip this definition using Haskell's record syntax:
11:49:10 <Cale> newtype State s a = S { runState :: s -> (s,a) }
11:49:13 <chrisdone> > foldM (\c xs -> return c) 'p' ['a','b','c'] :: Char
11:49:15 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
11:49:15 <lambdabot>              with actual type ‘m0 GHC.Types.Char’
11:49:23 <Cale> would automatically define the same thing for us
11:49:24 <chrisdone> oops
11:49:32 <chrisdone> > foldM (\c xs -> return c) 'p' ['a','b','c'] :: [Char]
11:49:33 <lambdabot>  "p"
11:49:46 <Cale> (i.e. runState would be the "field extractor")
11:49:55 <Cale> cool?
11:50:12 <shapr> @quote
11:50:12 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
11:50:35 <Cale> Actually, for the next part, maybe I should move things to #haskell-overflow just because any other people talking will probably make it harder to follow
11:51:06 <bryanedds> I might not be the only one here benefitting from this, tho :)
11:51:22 <Cale> yeah, that was also a message for anyone lurking to come along :)
11:51:22 <johnw> heya shapr!
11:51:34 <bryanedds> ah
11:51:40 <chrisdone> :t foldM (const (take 5)) :: Char -> [[Char]] -> [Char]
11:51:41 <lambdabot> Char -> [[Char]] -> [Char]
11:51:53 <johnw> chrisdone: doesn't foldM need your base value to be an action?
11:51:55 <shapr> johnw: howdy! How you doin?
11:52:02 <shapr> johnw: awesome code?
11:52:05 <johnw> shapr: doing well, hanging out in Sacramento today
11:52:26 <shapr> johnw: ooh, nifty... passing through southeast USA anytime soon?
11:52:34 <chrisdone> johnw: nope just the action
11:52:44 <chrisdone> :t foldM
11:52:45 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:52:45 <johnw> shapr: almost never, no
11:52:51 <johnw> chrisdone: ah, got it
11:52:56 <shapr> johnw: aw, too bad... I hope I get to meet you someday
11:52:59 <JagaJaga> Guys! I'm trying to find all subsequences in a given string. Wrote this
11:53:01 <JagaJaga> countBlocks :: (Ord a, Eq a) => Int -> [a] -> [([a], Int)]
11:53:03 <JagaJaga> countBlocks n = map (head &&& length) . group . sort . filter (\a -> length a == n) . concatMap inits . tails
11:53:11 <chrisdone> codygman-: so what do you actually want to achieve?
11:53:13 <shapr> JagaJaga: powerset?
11:53:37 <johnw> shapr: me too!  I thought we'd meet at Ed's house for Boston hackathon
11:53:40 <codygman-> chrisdone: foldM (\c xs -> return c) 'p' ['a','b','c'] :: [Char]... my goal would be 'abc', 'ab', 'a' for each iteration of the fold
11:53:49 <shapr> johnw: yeah, sorry about that
11:53:51 <chrisdone> aha
11:53:58 <codygman-> chrisdone: I'm trying to list a directory, then its parent... recursively
11:54:07 <codygman-> and thought I coudl take advantage of fold
11:54:15 <codygman-> reducing each time with takeDirectory
11:54:23 <JagaJaga> But it works very long... How to write it better? :(
11:54:29 <chrisdone> codygman-: oh, you can, yeah. so you need a print call in there, don't you?
11:54:45 <codygman-> chrisdone: Yes, but I got confused so tried to make everything as simple as possible.
11:54:47 <JagaJaga> shapr: no, just all subseq of a given length
11:55:44 <glguy_> JagaJaga: Check out the "subsequencesN" function in this paste: http://lpaste.net/114838
11:55:53 <glguy_> It might be relevant
11:56:13 <chrisdone> codygman-: maybe you could do unfoldr to produce a list of names? and then just mapM over that?
11:57:11 <JagaJaga> glguy_: nice! thx man.
11:57:52 <codygman-> chrisdone: Okay I'll try that. Thanks.
12:01:00 <chrisdone> @let takeParent = fmap (reverse . dropWhile (/='/') . reverse) . stripSuffix "/"
12:01:02 <lambdabot>  Defined.
12:01:10 <chrisdone> > unfoldr (fmap (id &&& id) . takeParent) "/home/chris/Projects/lucid/src/"
12:01:11 <lambdabot>  ["/home/chris/Projects/lucid/","/home/chris/Projects/","/home/chris/","/home...
12:01:35 <KangaAkale> mauke i still could not resole it
12:01:36 <chrisdone> codygman-: something like that ^
12:01:52 <KangaAkale> mauke i still could not resolve it
12:02:33 <chrisdone> codygman-: but preferably your filepath library will have a takeParent that's smarter than dumb list manipulation =)
12:04:03 <KangaAkale> hi please i do not know how to fix this error   Couldn't match type ‘Int -> MatchDay’ with ‘MatchDay’     Expected type: [MatchDay]       Actual type: [Int -> MatchDay]     In the first argument of ‘return’, namely ‘matches’     In a stmt of a 'do' block: return matches
12:04:21 <codygman-> chrisdone: whoa, wtf... and thanks! nice use of &&&... I'm pretty sure I wouldn't have thought of that
12:04:23 <chrisdone> KangaAkale: i think you're missing an argument
12:04:24 <ReinH> shapr: Yeah, bit of a shame that :(
12:04:30 <KangaAkale> here is my snipett http://lpaste.net/7175881283409543168
12:04:37 <ReinH> KangaAkale: You are missing an argument to the MatchDay constructor.
12:04:50 <ReinH> I think KangaAkale is ignoring me.
12:04:50 <JagaJaga> glguy_: anyway, it's slowly then I need to get the length of the output list
12:04:52 * ReinH shrugs
12:04:53 <chrisdone> codygman-: welcome =)
12:04:56 <shapr> ReinH: you were there too?
12:05:15 <shapr> ReinH: why would they do that?
12:05:40 <KangaAkale> chrisdone  please can you lead me the right path
12:05:52 <chrisdone> lol
12:06:02 <chrisdone> dat page width
12:06:34 <lpaste> chrisdone revised “No title”: “Formatted with hindent” at http://lpaste.net/7175881283409543168
12:06:36 <ReinH> shapr: Because they're a help vampire and I told them they need to do their own work and not use #haskell as an interactive debugger
12:06:36 <shapr> KangaAkale: is that homework for a class?
12:06:54 <shapr> ReinH: well, I hope that person improves
12:07:02 <ReinH> Me too.
12:07:30 <chrisdone> ReinH: http://www.staffordshirearts.co.uk/wp-content/uploads/2013/12/Count-Von-Count-from-Sesame-Street.jpg
12:07:37 <chrisdone> ReinH: “Von assignment, doo assignments!"
12:07:39 <shapr> haha
12:07:40 <ReinH> chrisdone: yes, pretty much
12:08:39 <ReinH> I am not interested in telling you exactly what to do so you can report the next error message to me (incorrectly) and then ask me to tell you exactly what to do again until you finally solve your problem.
12:08:41 <chrisdone> KangaAkale: i would comment out the body of your toMatch function, and replace it with `undefined'. does that type-check?
12:08:47 <KangaAkale> shapr no it is a project
12:08:48 <ReinH> Which is what they have been doing so far.
12:09:08 <shapr> ouch
12:09:31 <mauke> KangaAkale: did you see what ReinH said?
12:09:35 <chrisdone> KangaAkale: oh, also comment out retrieveMatches's type signature
12:10:02 <ReinH> We are spending entirely too much time on this.
12:10:12 <lifter> KangaAkale: take some time to do some reading, start with Learn You A Haskell perhaps. There's no getting around it.
12:10:30 <ReinH> This has been going on for days.
12:10:52 <mjboa> anyone up for a bit of liquid haskell? I'm trying to verify an AVL tree type but `insert` won't typecheck: https://gist.github.com/michaelbeaumont/f820b2fae9b6d55ab827
12:11:08 <chrisdone> @quote xeyes
12:11:08 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
12:11:20 <chrisdone> KangaAkale: if all else fails, you can try the above rule ;-p
12:12:22 <lifter> KangaAkale: You're not going to learn by osmosis as others debug your compile errors for you
12:13:49 <codygman-> chrisdone: I ended up doing this because unfoldr made my head hurt and I'm at work... I left your code in a comment though and I'll try to do it that way later :)  http://lpaste.net/116007
12:14:24 <chrisdone> codygman-: splitPath sounds nicer anyway
12:15:06 <chrisdone> codygman-: with splitPath i think you could do the foldr approach :3
12:15:40 <chrisdone> or maybe scan*
12:15:59 <codygman-> chrisdone: yeah, because what I wrote will throw an exception on "".
12:16:00 <chrisdone> yeahhhh, scan*!
12:16:30 <chrisdone> > splitOn "/" $ "/home/chris/Projects/lucid/src/"
12:16:31 <lambdabot>  ["","home","chris","Projects","lucid","src",""]
12:16:42 <blonde> I want to find an element in a list using foldl. I wrote this:    foldl (\(index, b) x -> if i == index then (index, x) else (index + 1, b) ) (0, head xs) xs       But it 'then' still gives me the last element of the list. Help please :-)
12:17:10 <blonde> Where i is the index that I want the element from
12:17:15 * hackagebot streaming-commons 0.1.7 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.7 (MichaelSnoyman)
12:17:30 <tasker> I want to use repa to calculate the sum of a window that slides along the diagonal of a 2d array. Is there any way I can specify a convolution stencil that only operates on certain elements ?
12:18:02 <bitemyapp> So is this abandoned? Anybody know anything about it? http://hackage.haskell.org/package/mmtl
12:18:49 <chrisdone> > scanl (\a b -> a ++ "/" ++ b) "/" . filter (not . null) . splitOn "/" $ "/home/chris/Projects/lucid/src/"
12:18:51 <lambdabot>  ["/","//home","//home/chris","//home/chris/Projects","//home/chris/Projects/...
12:19:11 <KangaAkale> chrisdone: retrieves  now]
12:19:13 <chrisdone> codygman-: your filepath lib's version of ++ (</>) would take care of the duplicate /'s, i think
12:19:15 <KangaAkale> no error
12:19:33 <chrisdone> KangaAkale: paste what you have now?
12:20:37 <codygman-> chrisdone: Alright, noted.
12:21:05 <gaze__> Hey folks. Say I have some data structure data A a = ... which I want to transform into a data B a where "a" refers to the same type, and I promise that I will provide a function a -> something which provides information on how to structure the B data structure. This to me almost certainly calls for type classes, but can I do it without?
12:21:13 <chrisdone> codygmam-: the various scans and folds and unfolds are handy beasts once you get to know them =)
12:21:48 <gaze__> all anti-typeclass arguments seem to hinge on being able to just provide the A something
12:22:01 <gaze__> but in this case I want to retain the "a"
12:22:24 <gaze__> how do I work around this? is it worth it?
12:22:53 <chrisdone> gaze__: you want a function from f a -> g a?
12:23:15 * hodapp pokes Fuco
12:23:36 <chrisdone> hodapp: what's with all these #emacsers in my #haskell =p
12:23:47 * hodapp shrugs
12:23:53 <gaze__> in typeclass lingo I'd say I want a "blah a => A a -> B a"
12:24:11 <hodapp> I just need a way to run 'cabal repl' instead of 'ghci' in Emacs haskell-mode
12:24:13 <gaze__> where blah a guarantees the implementation of a -> something
12:24:21 <hodapp> and https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md seems to be getting me nowhere
12:24:37 <chrisdone> hodapp: ohhh. i have a handy link
12:24:59 <chrisdone> hodapp: https://github.com/chrisdone/emacs-haskell-config → https://github.com/chrisdone/emacs-haskell-config/blob/master/config/haskell.el#L121-123
12:25:15 <chrisdone> hodapp: oh, well, you don't need the ghci-ng part. just change haskell-process-type to 'cabal-repl
12:25:48 <chrisdone> see also https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup#ghci-process-type
12:26:08 <hodapp> I did (custom-set-variables '(haskell-process-type 'cabal-repl)) and it did not seem to accomplish anything
12:26:37 <hodapp> particularly, I was using a cabal sandbox and I launched from what appeared to be the right directory, but it is unable to find stuff in the sandbox
12:27:13 <gaze__> chrisdone: I guess yes I do want a f a -> g a
12:27:38 <hodapp> perhaps C-c C-z doesn't act how I want...
12:27:41 <chrisdone> hodapp: does enabling the log and restarting yield anything? https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-REPL#troubleshooting
12:28:08 <chrisdone> hodapp: the *haskell-process-log* buffer *should* say "running cabal repl …", if it doesn't then the customization variable isn't working
12:28:45 <KangaAkale> chrisdone retrieveMatches  = do conn <- connectSqlite3 "results.db"                       r <- quickQuery' conn "SELECT * FROM matchTable" []                         return r
12:31:10 <hodapp> chrisdone: yeah, I'm trying to stumble through these, and I'm not sure what command I should even be using to start the REPL
12:31:40 <hodapp> C-c C-z is what I normally use, and while I set haskell-process-log to 1 there is no *haskell-process-log* buffer that appeared
12:31:58 <chrisdone> hodapp: if your session's already started, use M-x haskell-process-restart to restart it
12:32:23 <chrisdone> it'll restart the inferior process, but re-use the "session" and the repl buffer
12:32:31 <chrisdone> KangaAkale: try something simpler. e.g. "SELECT 123 FROM matchTable" and then "return (map (\[int] -> fromSql int :: Int) r)"
12:33:31 <codygman-> How can I compile for redhat from ubuntu?
12:33:53 <ReinH> blonde: you are checking if the index matches, not if the element matches
12:34:44 <blonde> ReinH: I'm only given an index. With that index I need to find the element in a list at that index
12:35:00 <ReinH> blonde:  is this homework?
12:35:10 <hodapp> chrisdone: ahh, haskell-process-restart did the trick. For some reason that behaves differently from C-c C-z
12:35:58 <blonde> ReinH: yes, I just want to know where I'm wrong, so I can figure it out. Does it have to do with that x is still bound to the last value of x?
12:37:26 <ReinH> blonde: no, it has to do with the fact that you are updating the tuple whether or not the index matches the given value
12:37:56 <monochrom> C-c C-z only brings up the buffer, no restart.
12:38:10 <blonde> ReinH: ok, thanks! I'm going to get further :)
12:38:11 <chrisdone> hodapp: right, -switch only brings open the buffer
12:38:14 <ReinH> blonde: were you asked to do this with foldl?
12:38:39 <blonde> ReinH: yes :-) Thanks for the tip.
12:39:00 <KangaAkale> chrisdone it compile well
12:39:20 <KangaAkale> but when i try to display it it gives this error MatchDB.hs:66:36-63: Non-exhaustive patterns in lambda
12:39:32 <chrisdone> KangaAkale: that's okay, that's just a warning
12:40:25 <hodapp> monochrom, chrisdone: but I've been repeatedly killing the process and the buffer.
12:40:44 <chrisdone> KangaAkale: hmm, does this work? "SELECT 123,456 FROM matchTable" and then return (map (\(x,y) -> (fromSql x,fromSql y) :: (Int,Int)) r)
12:41:28 <hodapp> monochrom: if I do C-c C-z and I've already started a buffer that happens to be working just fine, it appears to replace that buffer with one that now does not work.
12:41:29 <chrisdone> hodapp: right, if you kill the session then trying to switch to it will start a new one, but subsequent switches to an existing session just shows the buffer
12:41:49 <chrisdone> probably due to the session function which is like "get existing session or otherwise prompt to start one"
12:42:01 <chrisdone> huh?
12:42:25 <chrisdone> C-c C-z with a working session works fine here…
12:42:34 <chrisdone> it just takes me to the REPL
12:42:54 <KangaAkale> chrisdone: no it gives an error
12:42:56 <KangaAkale> Couldn't match type ‘[SqlValue]’ with ‘(SqlValue, SqlValue)’     Expected type: [(SqlValue, SqlValue)]       Actual type: [[SqlValue]]     In the second argument of ‘map’, namely ‘r’     In the first argument of ‘return’, namely       ‘(map (\ (x, y) -> (fromSql x, fromSql y) :: (Int, Int)) r)’
12:43:23 <chrisdone> kangaakale: ah, okay, so then the row has to be a list of values
12:43:33 <hodapp> chrisdone: when I do it here, it takes me to the REPL... but I see GHCi initialization messages, like it has restarted it.
12:43:45 <ReinH> chrisdone: did you check if it was a missing argument to the constructor?
12:43:48 <chrisdone> hodapp: that doesn't sound too healthy
12:44:20 <hodapp> chrisdone: yes.
12:44:25 <chrisdone> ReinH: i *know* it was a missing argument, but Kangaakale seems to need baby steps =)
12:44:30 <ReinH> Indeed.
12:44:58 <chrisdone> hodapp: i'd just kill the session and start a fresh one. C-x k on the REPL window, answer yes to kill the session, no to killing all associated buffers
12:45:05 <chrisdone> hodapp: maybe all the dabbling confused it
12:45:08 <hodapp> chrisdone: this is what I have been doing, literally the whole time i've been asking.
12:45:13 <chrisdone> hmm
12:45:20 <chrisdone> you're on latest git master?
12:45:31 <hodapp> chrisdone: when I said "but I've been repeatedly killing the process and the buffer." that's what I meant.
12:45:37 <hodapp> chrisdone: no, I'm not
12:45:42 <chrisdone> what version?
12:46:37 <hodapp> what version of what specifically?
12:46:42 <chrisdone> haskell-mode
12:46:56 <chrisdone> i ask because this not normal behaviour nor a normal issue. it just sounds wack
12:47:07 <chrisdone> so maybe the version is super old and buggy
12:47:52 <chrisdone> oh we can maybe check something actually, this reminds me of some old bug
12:47:56 <hodapp> bleah, M-x haskell-version just gave me "haskell-mode version  ( @ /usr/share/emacs/site-lisp/haskell-mode/)"
12:48:10 <chrisdone> what's in your (mapcar #'haskell-session-name haskell-sessions)?
12:48:57 <hodapp> ("haskell")
12:49:53 <chrisdone> hm, that seems okay… no duplicates. although the name implies it's the default string and didn't come from detecting a cabal file. if your cabal file is foo.cabal your project should be *foo*
12:50:51 <chrisdone> s/projet/session, i tend to use these terms interchangeably
12:51:01 <hodapp> I don't have a Cabal project. I am just trying to run some example code and start 'cabal repl' in the right location for the cabal sandbox
12:51:14 <KangaAkale> chrisdone: where will i have to implement that change
12:51:38 <chrisdone> hodapp: does cabal repl work in the terminal in that project dir?
12:51:42 <hodapp> chrisdone: yes.
12:51:51 <hodapp> chrisdone: haskell-process-restart also appears to.
12:51:52 <chrisdone> hodapp: and does it actually run inside emacs?
12:52:01 <chrisdone> okay, at least there's that
12:52:30 <chrisdone> perhaps there's a bug when there's no .cabal file. people don't really use it without one. let me try
12:52:56 <chrisdone> eh, it works
12:53:15 <hodapp> I'm just trying to figure out what a sane workflow here is when initially all I want to do is mess with the example files (which were installed in the cabal sandbox along with everything else), not just run them
12:54:30 <chrisdone> the normal workflow is you just open a file and C-c C-z or C-c C-l it to start a session, or do some command which demands a session. then it launches ghci and away you go
12:54:57 <hodapp> If I do that from an example file, then I'm not in the appropriate directory for the sandbox.
12:54:58 <chrisdone> what your experiencing is some lovecraftian workflow that isn't supposed be happening =p
12:55:23 <hodapp> If I do it from the right directory from the sandbox, then I have to figure out how to get to the examples, as they are several directories away.
12:55:24 <chrisdone> right, but when the session starts you're prompted for the cabal directory
12:56:19 <chrisdone> and the current directory
12:56:33 <chrisdone> hodapp: for the source files you can just :set -ifoo/bar
12:56:51 <chrisdone> normally your cabal file tells cabal repl where all the files are
12:56:58 <hodapp> with C-c C-z I am not prompted
12:57:48 <chrisdone> not if your session is already started
12:57:56 <chrisdone> didn't you get a prompt when you started the session?
12:58:03 <hodapp> No.
12:58:29 <chrisdone> Start a new project named “haskell”? (y or n)  y
12:58:29 <chrisdone> Cabal dir: ~/Projects/blah/ RET
12:58:29 <chrisdone> Set current dir: ~/Projects/blah/ RET
12:58:38 <hodapp> none of those things appear.
12:58:38 <chrisdone> that's what i get when i delete the session and run C-c C-z
12:58:50 <hodapp> I may need to restart Emacs or something, I don't know
12:59:37 <hodapp> I suppose there is already a cabal file for the examples, but I'm not clear on how it will interact with the fact that they were already compiled and installed
13:01:03 <chrisdone> it should just load the ones in your load path, which is the current dir and anything specified with :set -ifoo
13:01:31 <KangaAkale> chrisdone: i am here]
13:02:15 <chrisdone> KangaAkale: what is your native language?
13:02:40 <hodapp> okay, just restarted Emacs, C-c C-z still does not prompt for anything
13:03:13 <KangaAkale> i dont understand what u mean by native language
13:04:27 <chrisdone> hodapp: mmk. i just tried it with emacs -Q and haskell-mode and C-c C-z prompts to start "haskell". i *suspect* whatever version you have may have some logic about "guessing" your project instead of prompting, and it's somehow skipping the questioning part
13:04:47 <hodapp> tried to point it to the cabal file for ivory-examples, "exited abnormally with code 1"... looking in *haskell-process-log*
13:04:47 <chrisdone> hodapp: and must be buggy and old
13:05:03 <hodapp> "Package has never been configured. Configuring with default flags. If this
13:05:05 <hodapp> fails, please run configure manually."
13:05:38 <chrisdone> that message is finew
13:05:38 <hodapp> stuck in a restart loop now.
13:06:05 <chrisdone> get the git or melpa version
13:06:18 <chrisdone> no point debugging old software that's probably been fixed by now
13:06:57 <hodapp> how do I determine my version?
13:07:10 <chrisdone> M-x haskell-version
13:07:14 <stephen_> Can anyone with relevant experience compare the feature-completeness and overall niceness of Galois' Ivory compared to Feldspar?
13:07:49 <chrisdone> hodapp: what does it output?
13:07:49 <hodapp> chrisdone: oh, I thought I did that wrong since I did it earlier and only got "haskell-mode version  ( @ /usr/share/emacs/site-lisp/haskell-mode/)"
13:07:57 <hodapp> I thought you saw when I said that
13:08:24 <chrisdone> ah, mine prints: haskell-mode version 13.10 (13.10-278-gc3a44b6 @ /home/chris/Emacs/packages/haskell-mode/)
13:08:35 <chrisdone> there seems to be all manner of effedupness to your haskell-mode
13:09:07 <chrisdone> of course, my version is the git version, we just haven't made an official release for a while
13:09:32 <hodapp> alright, I should just work from the commandline for a bit instead
13:09:53 <chrisdone> hodapp: fwiw this repo is emacs -Q'able https://github.com/chrisdone/emacs-haskell-config#running
13:10:50 <chrisdone> hodapp: i'd recommend that repo as a starting point for haskell in general… being an emacs guru you can crib the bits you like and the bits you don't afterwards
13:10:56 <hodapp> I'll give it a try later, I really have a lot more to do than debug an environment
13:11:41 <chrisdone> don't we all =)
13:12:39 <hodapp> and if I do it now, it will just be button-pushing where I have no idea what I'm actually doing because I'm just trying to get to a working configuration so I can go do the work that actually matters
13:15:42 <monochrom> I use melpa for haskell-mode
13:15:54 <hodapp> chrisdone: what does emacs -Q'able even mean?
13:16:27 <monochrom> oh, apparently it means "you can use 'emacs -Q'"
13:16:29 <chrisdone> hodapp: meaning you can run the setup without it interferring with your own emacs setup, so it's a "clean" test
13:16:43 <hodapp> I see what the manpage says about it but I don't know how I go about using this to run what is in that github
13:17:00 <chrisdone> i wrote in the link i sent you…
13:17:04 <monochrom> "emacs sandbox" may come to mind...
13:17:11 <chrisdone> Running
13:17:11 <chrisdone> In the repo directory, run this:
13:17:11 <chrisdone> $ emacs -Q -l init.el
13:17:20 <chrisdone> monochrom: =)
13:17:52 <lpaste> cdk pasted “Unsaturated type synonym in instance declaration” at http://lpaste.net/116009
13:17:58 <hodapp> oh, didn't realize -l was involved also
13:17:59 <chrisdone> of course, there are prerequisites, but the point of the link was to show you don't have to mess around with your own .emacs just to try out a "prebaked" setup
13:18:23 <benzrf> yo does anybody here know netwire
13:18:25 <chrisdone> i liken it to those old lisp-in-a-box thingies. i liked those when i first started with CL
13:18:30 <cdk> I've posted a question with code context at http://lpaste.net/116009
13:19:25 <hodapp> chrisdone: but, for instance, do I still have to install the various cabal dependencies too?
13:19:28 <cdk> It has to do with using an unsaturated type synonym in an instance declaration. I'm not sure if what I want is possible, but I'd appreciate any thoughts on the matter
13:20:53 <stepkut> I'm trying to compile a file with GHC, and it is taking several minutes. The CPU load is going over 1.00, but the ghc process is only showing 2-5% CPU usage.. any thoughts?
13:22:15 <stepkut> if I remove all the 'deriving' clauses it compiles in a sensible amount of time
13:22:33 <chrisdone> hodapp: you don't have to, but then some lines should be commented out. specifically, the ones in config/haskell.el that reference ghci-ng or structured-haskell-mode
13:23:20 <hodapp> hrmph, can't :load these examples anyway for whatever reason... getting "File name does not match module name:"
13:23:36 <chrisdone> haha
13:23:42 <chrisdone> endless pain =)
13:24:06 <JagaJaga> Anyway, I can't fastly count subsequences.. http://pastebin.com/wwEzBw33 The first is a func from smth like rust code, and it counts in seconds. Haskell imp work veeeery slowly.
13:24:24 <hodapp> chrisdone: oh well, at least it's not Visual Studio.
13:26:38 <hodapp> https://github.com/GaloisInc/ivory/blob/master/ivory-examples/examples/FibTutorial.hs it's complaining about line 1 column 1 here... it boggles my mind a little that it could have found an error that early...
13:27:36 <hodapp> file name does not match module name, saw "Main", expected "FibTutorial"...
13:28:09 <hodapp> trying to figure out what this error message is even trying to say.
13:28:30 <geekosaur> it believes it is compiling a module and not a main program
13:28:36 <chrisdone> hodapp: yes, that's a terrible error message. when you don't have a "module X where" in your file, ghc assumes "module Main where"
13:29:15 <chrisdone> hodapp: so either your file is FibTutorial.hs and you have no module header, so you need to add "module FibTutorial where" to the top, or…
13:29:46 <hodapp> I didn't write this file, I don't know what the intention of it is... perhaps it was meant to be run standalone rather than imported
13:29:54 <chrisdone> but it's weird that :load says something like that; it doesn't usually care. unless this is something cabal repl brings to the table
13:30:03 <chrisdone> oh, how are you importing it?
13:30:24 <hodapp> :load
13:30:49 <geekosaur> it has a main, so it is intended standalone
13:31:36 <chrisdone> hodapp: are you doing :load FibTutorial.hs or :load FibTutorial? i wonder whether that difference causes it
13:32:01 <hodapp> the latter
13:32:03 <chrisdone> this is an education. watching a newbie struggle with the simplest of tasks says a lot about tooling
13:32:14 <chrisdone> how does :load FibTutorial.hs fare?
13:32:23 <hodapp> It says it cannot find the file.
13:33:01 <chrisdone> i guess it needs the whole path?
13:33:04 * chrisdone frowns
13:33:13 <hodapp> I don't know. I've always done :load ModuleName
13:35:26 <chrisdone> so it seems either you do
13:35:26 <hodapp> How I've been dealing with examples in various other packages is to :load them in GHCi, poke around, and repeat, and so far this is the only package I've found whose examples did not want to load that way.
13:36:03 <chrisdone> 1) :l /path/to/X.hs
13:36:03 <chrisdone> 2) rename X.hs to Main.hs
13:36:03 <chrisdone> 3) add "module X where" to the top of X.hs
13:36:09 <chrisdone> preferably (1)
13:36:12 <JagaJaga> Guys, please help me with optimizing, really can't do a thing better :(
13:36:22 <hodapp> but the Atom example, for instance, put module Language.Atom.Example
13:36:44 <chrisdone> where was this repo from again?
13:36:59 <hodapp> http://github.com/GaloisInc/ivory
13:37:44 <thang1> jaggajagga, why are you trying to countBlocks?
13:37:54 <thang1> JagaJaga*
13:38:00 <Geraldus> Hi. friends! I have failed GHC 7.8.3 installation, now I have fixed symlinks in `/usr/local/bin` to GHC v7.8.2 (which works), but when I try to intstall XMonad error occurs because of `/usr/local/lib/ghc-7.8.3/bin/hsc2hs`. So I assume there are more symlinks to be fixed. Who can help with this?
13:38:33 <thang1> nuke everything with fire and clean slate it?
13:38:39 <monochrom> "ls -l /usr/local/bin" should reveal all symlinks
13:38:45 <thang1> that's my goto solution for anything related to haskell and windows
13:39:03 <thang1> "oh, firefox update failed? reinstall windows"  "oh, can't make this one package work in haskell? Reinstall everything"
13:39:04 <hodapp> thang1: ...I will have to remember that, if I find myself stuck on Windows again.
13:39:12 <monochrom> but if you're going to nuke, remember to also wash with bleach.
13:39:28 <hodapp> thang1: Though, having had to develop professionally on it, I guess I'd try that first anyway.
13:39:32 <lifter> before you reboot your windows machine, it's always best to reboot it
13:39:35 <monochrom> followed by rubbing alcohol and hydrogen peroxide
13:39:37 <thang1> In IT, we keep iso images of windows with everything already installed and configured, so nobody ever has to do anything after you install the iso
13:39:51 <thang1> So literally every time something goes wrong and we can't fix it in 5 minutes? Wipe and reinstall
13:40:06 * monochrom now wonders what happens when mixing bleach, rubbing alcohol, and hydrogen peroxide
13:40:20 <lifter> monochrom: Cabal explodes
13:40:33 <thang1> Windows just fucks up so hard, for so many different ways, that it's just impossible to fix 200 computers individually. Better to wipe computers as necessary and keep them running the same experience on all of them
13:40:33 <Dashkal> I need to investigate cabal's sandboxing.  Wonder if that'll give me a sane way to start over.
13:40:39 <JagaJaga> thang1: counting entropy of a file
13:40:41 <hodapp> Dashkal: it's working alright for me.
13:40:47 <thang1> cabal's sandboxing is a pretty good method to sanitize your life
13:41:00 <hodapp> thang1: Windows does have some of the most ridiculous fuckups I have ever seen.
13:41:01 <thang1> There are more extreme solutions like vagrant, docker, and NixOS as well
13:41:14 <hodapp> thang1: the registry alone could accomplish that.
13:41:14 <Dashkal> NixOS is on my radar.
13:41:19 <Dashkal> Vagrant annoys me
13:41:25 <JagaJaga> Dashkal: nixos is awesome ;)
13:41:47 <thang1> nixos is awesome but I could never get comfortable with it
13:41:53 <hodapp> I've never used nixOS, hmmm
13:41:54 <JagaJaga> thang1: why?
13:41:55 <Dashkal> Next time I have downtime that isn't being consumed by 1m cubes or orcs I'm going to throw that on a VM and play for a day.
13:42:01 <thang1> the package manager is just so fucking annoying to use after you get used to Arch's pacman
13:42:18 <thang1> the only thing you ever need to learn is sudo pacman -S (package)
13:42:18 <JagaJaga> thang1: it isn't indeed
13:42:35 <thang1> or sudo pacur -S (package)
13:42:37 <JagaJaga> thang1: the only thing you have to know is `nix-env -i pkgname`
13:42:45 <Geraldus> I also have strange GHC upgrade fail reason: LICENSE not found during `make install`. Can someone help with upgrading from 7.8.2 to 7.8.3 (I'm on Debian 7)
13:43:11 <monochrom> I am wary of anything of the sort "you ever need to learn one command"
13:43:15 <JagaJaga> thang1: but some ideas to optimize counting of subseqs? :(
13:43:15 <thang1> When I search for a vim package I get like 80 different options, all with esoteric and obscure file names... idk
13:43:44 <thang1> Well there are quite a few things you can do with pacman, but it's a testament to the fact that 99.997% of the time the default works perfectly which makes it my favorite
13:43:54 <thang1> the fact that you can bend it to dark and evil twisted methods as well is even better
13:43:59 <monochrom> computer algorithms have not been developed to the point that I only need one command.
13:44:14 <thang1> JagaJaga: your haskell looks like prettified C code
13:44:36 <JagaJaga> thang1: emmm
13:44:50 <thang1> just at first glance
13:44:51 <JagaJaga> thang1: the are 2 source in paste i've submitted
13:45:00 <thang1> Well yes, I saw the second one lol
13:45:27 <JagaJaga> thang1: well, ok, help me to write it fasted and better? :(
13:45:41 <thang1> You're using a hash map in the first implementation, so it's going to be fairly fast
13:46:05 <thang1> In haskell you use default data types, safe strings and fromListWidth and a few other slower functions
13:46:30 <thang1> Even if your functional algorithm is flawless it'll run much slower because you're not using faster functions
13:46:52 <JagaJaga> thang1: so that's my question - what to use? :)
13:47:25 <thang1> the subsequences are you're trying to count subsequences divisible by an e.g. 'K', right?
13:47:56 <glguy_> JagaJaga: Does the subsequencesN function in Haskell do the same thing as the substring method in your Rust code?
13:48:39 <JagaJaga> glguy_: no, it doesn't
13:48:51 <glguy_> JagaJaga: Then that'll certainly slow down things
13:49:07 <ChristianS> JagaJaga: also, Data.Text is generally much faster than String
13:49:14 <JagaJaga> glguy_: the rust't one just gives me a piece of a string
13:49:27 <glguy_> one contiguous piece?
13:49:36 <JagaJaga> ChristianS: thx.
13:49:45 <apo_> JagaJaga: Jaga?
13:50:00 <apo_> ah
13:50:04 <apo_> not Finnish
13:50:09 <apo_> Never mind, I don't know you :p
13:50:23 <thang1> Am I the only one confused with what exactly you're trying to do with the subsequences in the first place? Are you finding all substrings in one string that match each other?
13:50:24 <JagaJaga> glguy_: abcd >>= subseq (1,2) >>= bc
13:50:44 <glguy_> OK, then the subsequencesN function isn't what you want
13:50:58 <pecanpy> is there a way to run some ":command" options at the start of ever ghci session. in a config file or something? the default prompt gets very long and im tired of doing ":set prompt whatever" all the time.
13:50:58 <piskrist> Longest Common SUbstring
13:51:00 <piskrist> ?
13:51:07 <JagaJaga> thang1: yes, i'm finding them and counting how much are there such in code
13:51:17 <piskrist> s/substring/subsequence/
13:51:42 <JagaJaga> piskrist: no :( Just counting how many subseqs of a given length in code
13:52:25 <JagaJaga> glguy_: so what func to I need?
13:54:45 <supki_> pecanpy: yes, you can put GHCi commands in ~/.ghci
13:55:02 <monochrom> I don't understand subsequencesN, and not going to bother. I'm just going to replace it by faithful code (as opposed to creative code). f n xs = map (take n (take (length xs - n + 1) (tails xs))
13:55:04 <supki_> pecanpy: it will also load .ghci from the current directory if it exists
13:55:33 <eacameron> is there some standard definition of a "whileM", like sequence, but accepts an "a -> Bool" to determine when to stop?
13:55:43 <pecanpy> supki_: nice. thanks. ill track it down
13:55:48 <monochrom> > let f n xs = map (take n (take (length xs - n + 1) (tails xs)) in f 2 "abcdefg"
13:55:49 <lambdabot>  <hint>:1:64: parse error on input ‘in’
13:55:57 <joe9> I am having trouble understanding the "functions are functors" concept here: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html Any other material that can help me understand it, please?
13:56:06 <monochrom> > let f n xs = map (take n (take (length xs - n + 1) (tails xs))) in f 2 "abcdefg"
13:56:07 <lambdabot>  Couldn't match expected type ‘a1 -> b1’ with actual type ‘[[a2]]’
13:56:07 <lambdabot>  Relevant bindings include
13:56:07 <lambdabot>    xs :: [a2] (bound at <interactive>:1:9)
13:56:07 <lambdabot>    f :: GHC.Types.Int -> [a2] -> [a1] -> [b1]
13:56:07 <lambdabot>      (bound at <interactive>:1:5)
13:56:14 <JagaJaga> monochrom: I had such
13:56:14 <monochrom> aww
13:56:45 <monochrom> oh, I see, f n xs = map (take n) (take (length xs - n + 1) (tails xs))
13:56:46 <JagaJaga> > let f n = map (\xs@(x:_) -> (x, length xs)) . group . sort . filter (\a -> length a == n) . concatMap inits . tails in f 2 "abcthththt"
13:56:47 <thang1> Data.Text provides a count function, JagaJaga
13:56:48 <lambdabot>  [("ab",1),("bc",1),("ct",1),("ht",3),("th",3)]
13:56:59 <JagaJaga> monochrom: but it works slowly
13:57:12 <JagaJaga> thang1: what is it?
13:57:38 <dinnye> > let a:b:x="12345" in b:reverse (a:x)
13:57:39 <lambdabot>  "25431"
13:57:55 <dinnye> let a:b:x="SPINE" in b:reverse (a:x)
13:58:31 <thang1> the count function?
13:58:47 <monochrom> (filter (\a -> length a == n) . concatMap inits . tails in f 2 "abcthththt") is not quite in the ballpark of my f.
13:59:00 <thang1> http://stackoverflow.com/questions/9711328/how-would-you-count-occurences-of-a-string-within-a-string-haskell
13:59:22 <monochrom> just by doing both inits and tails, you're into quadratic-time land
13:59:30 <thang1> Yeah, unfortunately
13:59:37 <joe9>  http://codepad.org/HtTUZftI is the functor instance for a function. but, when I try > :t (->)
13:59:44 <joe9> it does not work at the repl.
14:00:23 <JagaJaga> thang1: going to test the speed, thx.
14:00:50 <pecanpy> is the ghci.conf file not created by deault on windows or am i looking in the wrong place? C:\Users\me\AppData\Roaming\ghc
14:00:56 <josephle> :k (->) -- In haskell, the type of a type is a kind
14:00:57 <lambdabot> * -> * -> *
14:01:09 <thang1> This is gonna be what you want, probably: http://hackage.haskell.org/package/stringsearch-0.3.3/docs/Data-ByteString-Search.html
14:02:22 * hackagebot mustache-haskell 0.1.0.0 - straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.0 (DanielChoi)
14:02:24 * hackagebot caramia 0.4.0.0 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.4.0.0 (Adeon)
14:02:26 * hackagebot mustache-haskell 0.1.0.1 - Straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.1 (DanielChoi)
14:02:55 <thang1> wukay there, hackage. Nice boy, calm down now...
14:03:52 <mmachenry> Does anyone have opinions on the best Hackage libraries for having simple config files? I have a daemon that I want to store just a database name, host name, port, and maybe a couple of other things in.
14:09:12 --- mode: ChanServ set +o dolio
14:11:06 --- mode: dolio set +b *!~neneng@32.217.*
14:11:16 --- mode: ChanServ set -o dolio
14:13:20 <JagaJaga> thang1: that wasn't a solution. Indeed it still counting for more than a minute what was done previously in 12 secs.. So the question is: I have a list of a, they Eq => a, so I need to do smth like: "pick an object, put in in a box of the same objects and count the "weigh" of each box". :/
14:17:10 <sfs> @pl (\x -> snd x < v)
14:17:11 <lambdabot> (< v) . snd
14:17:22 * hackagebot mustache-haskell 0.1.0.2 - Straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.2 (DanielChoi)
14:17:24 <thang1> Is the 12 second solution on rust or your first haskell?
14:17:34 <sfs> @pl filter ((\x -> snd x < v)
14:17:34 <lambdabot> (line 1, column 26):
14:17:34 <lambdabot> unexpected end of input
14:17:34 <lambdabot> expecting variable, "(", operator or ")"
14:17:47 <sfs> @pl (filter ((\x -> snd x < v))
14:17:48 <lambdabot> (line 1, column 28):
14:17:48 <lambdabot> unexpected end of input
14:17:48 <lambdabot> expecting variable, "(", operator or ")"
14:18:13 <geekosaur> you have too many (s not too few
14:18:14 <dinnye> :t True
14:18:16 <lambdabot> Bool
14:18:25 <dinnye> :t not otherwise
14:18:26 <lambdabot> Bool
14:18:41 <JagaJaga> thang1: for first haskell (the one from paste) with subseq of n = 2, but if n = 3, it computes for more than 10 minutes :( Rust runs for 10 sec for n = [1..4]
14:18:50 <JagaJaga> ~10 sec.
14:19:06 <sfs> @pl filter (\x -> snd x < v)
14:19:06 <lambdabot> filter ((< v) . snd)
14:22:13 <sfs> @pl t2 v l = filter (\x -> snd x < v) (zip [0..] l)
14:22:13 <lambdabot> t2 = (. zip [0..]) . filter . flip ((<) . snd)
14:24:23 --- mode: ChanServ set +o dolio
14:25:15 <thang1> mmm... and the second one runs in like a minute ish?
14:25:25 <JagaJaga> sfs: use can use "/query lambdabot" to ask lb privately :)
14:25:53 --- mode: dolio set -b *!~neneng@32.217.*
14:25:56 <sfs> ok, thanks
14:26:00 --- mode: dolio set +b *!~neneng@31.217.*
14:26:05 <JagaJaga> thang1: yeah. Tha last link you've send (stackoverflow) hadn't ended in 5 minutes for n = 2...
14:26:36 --- mode: ChanServ set -o dolio
14:27:18 <JagaJaga> thang1: n = 2, my solution from paste: (14.89 secs, 9501256480 bytes)
14:28:00 <monochrom> if there is a big jump from n=2 to n=3, you're using an expoential-time algorithm
14:28:37 <monochrom> if there is a small jump but still not as small as you like, you're using a quadratic-time or worse algorithm
14:30:33 <monochrom> the orignal non-Haskell code is pretty much linear time. and the same task can be done in Haskell in linear time, too.
14:31:05 <JagaJaga> monochrom: I can't, need your help :(
14:31:08 <thang1> the algorithm he's using is quadratic time complexity I believe
14:31:19 <monochrom> I respect "change String to Text is faster", but if you're looking at a poorly written exponential-time algorithm, that is not a priority.
14:32:09 <monochrom> the original algorithm is linear in n and linear in string length. one may say, it's "quadratic", in the sense of O(n * length)
14:32:32 <monochrom> the problem is, if you do "inits . tails", you're looking at O(n * length^2)
14:33:02 <JagaJaga> monochrom: I'm using algo from the paste I've submitted http://pastebin.com/wwEzBw33
14:33:25 <JagaJaga> monochrom: there is no inits . tails
14:33:38 <thang1> it was just an example, I believe
14:34:05 <bananagram> what was that?
14:34:41 <mmachenry> Does anyone have a command-line argument parsing library they recommend? What's the most popular?
14:35:19 <dolio> optparse-applicative generally gets the best reviews, I think.
14:36:51 <monochrom> the cost of subsequencesN satisfies the recurrence "cost n length = cost (n-1) (length-1) + cost n (length-1)"
14:37:12 <monochrom> this feels like obviously exponential, think fibonacci
14:38:14 <monochrom> this cannot possibly be a similar algorithm as the non-Haskell code, which is just "for i = 0 to length-n { for j = i to i+n"
14:38:48 <thang1> could you not use an entirely different algorithm which uses the properties of a functional language to your advantage?
14:39:43 <monochrom> I have long suggested f n xs = map (take n) (take (length xs - n + 1) (tails xs)) which is a faithful translation and of the same complexity as the original Haskell code. it has long been dismissed.
14:40:29 <monochrom> there is likely yet a slicker way and is still O(n * length)
14:41:58 <thang1> who dismissed it? Sounds legit
14:43:01 <monochrom> I said that code 50 minutes ago. did anyone see it? if no one saw it, then everyone dismissed it.
14:43:11 <int-e> monochrom: I'd dismiss it as not being lazy enough.
14:43:57 <int-e> (I want  f 2 [1..] to produce [1,2]:[2,3]:[3,4]:...)
14:44:42 <monochrom> yeah I dont like counting on length either, but it was a quick and dumb first attempt. and it already beat exponential time
14:45:07 <Hijiri> Are there any rating systems designed especially for situations where you might not know that a match has occurred until several rating periods later?
14:46:57 <monochrom> there is a slick and lazy way to "discard the last n items of a list". we just need that to boot. the rest is easy.
14:47:12 <int-e> monochrom: modulo off-by-one errors I'd use  map (take n) $ zipWith const (tails xs) (drop n xs)
14:47:47 <monochrom> yeah, like that
14:50:08 <monochrom> > let xs = "abcdefg" in map (take n) $ zipWith const (tails xs) (drop n xs)
14:50:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
14:50:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
14:50:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
14:50:24 <monochrom> oh, heh, n is free
14:50:28 <monochrom> > let xs = "abcdefg" in map (take 3) $ zipWith const (tails xs) (drop n xs)
14:50:30 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
14:50:30 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
14:50:40 <monochrom> yikes, one more n
14:50:43 <monochrom> > let xs = "abcdefg" in map (take 3) $ zipWith const (tails xs) (drop 3 xs)
14:50:44 <lambdabot>  ["abc","bcd","cde","def"]
14:51:05 <monochrom> ooo, as you predicted, off by one, efg is missing :)
14:52:24 * hackagebot text-utf7 0.1.0.0 - UTF-7 encoding/decoding for Data.Text  http://hackage.haskell.org/package/text-utf7-0.1.0.0 (DanielWright)
14:52:42 <monochrom> tails xs = ["abcdefg", ... , "efg", "fg", "f", ""]. that last "" confounds you. probably you want drop (n-1) xs
15:00:55 <cdk> I've posted a question with code context at http://lpaste.net/116009 . It has to do with using an unsaturated type synonym in an instance declaration. I'm not sure if what I want is possible, but I'd appreciate any thoughts on the matter
15:01:16 <vanila> you must fully apply type synonyms
15:01:24 <monochrom> GHC does not allow unsaturated type synonym for instances.
15:01:26 <vanila> if you want to partially apply something it will involve packing and unpacking a newtype
15:03:40 <cdk> I know I can't use partially applied type synonyms with instances (GHC has already told me so). I'm wondering if in my particular case there's another way to acheive the same effect.
15:04:12 <cdk> using a newtype instead presents its own set of problems
15:04:34 <monochrom> mmachenry: my https://github.com/treblacy/random-read is a real example of using optparse-applicative
15:05:15 <mmachenry> monochrom: Thanks.
15:10:08 <matematikaadit> > let f n xs = [ take n x | x <- tails xs, length x >= n ] in f 3 "abcdefg"
15:10:10 <lambdabot>  ["abc","bcd","cde","def","efg"]
15:10:35 <glguy_> cdk: If your goal is to just reuse the method "foo" in lots of ways you could do something like this http://lpaste.net/116009 but you'll probably need to go into more detail what it is you're trying to do
15:14:51 <JagaJaga> monochrom: int-e: was afk, sorry. I'll check this now.
15:17:57 <joe9> http://codepad.org/d49OkQ2q I am trying to play around with the behaviour of ((->) r) so I can do the exercises of typeclassopedia. Any suggestions on what I am missing, please?
15:18:30 <monochrom> you are mixing the type level and the value level
15:18:37 <geekosaur> (->) is a type constructor
15:18:50 <monochrom> you are writing the equivalent of "fmap sin Maybe"
15:19:22 <joe9> monochrom: thanks for the response. http://codepad.org/sLiHwJzq doing the same with (,) I was able to get result out.
15:19:38 <joe9> monochrom: I figure the (->) follows similar lines.
15:19:48 <monochrom> that is only because "(,) 10" is a value
15:20:02 <joe9> monochrom: got it, thanks.
15:20:06 <joe9> geekosaur: got it, thanks.
15:20:24 <joe9> makes perfect sense now.
15:20:30 <joe9> sorry for the bother.
15:20:51 <joe9> > :t (+10)
15:20:52 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:21:00 <joe9> is the value for ((-> follows similar lines.))
15:21:01 <joe9> monochrom: got it, thanks.
15:21:02 <joe9> geekosaur: got it, thanks.
15:21:02 <joe9> makes perfect sense now.
15:21:03 <joe9> sorry for the bother.
15:21:07 <joe9> > :t (+10)
15:21:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:21:23 <joe9> is the value for ((->) r) , correct?
15:21:23 <matematikaadit> :t (+10)
15:21:24 <lambdabot> Num a => a -> a
15:22:21 <cdk> @pl \a -> f . f (g a)
15:22:21 <lambdabot> (f .) . f . g
15:22:25 * hackagebot eventstore 0.1.0.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.1.0.0 (YorickLaupa)
15:22:40 <joe9> actually, it should be (+10) 20
15:27:26 * hackagebot mustache-haskell 0.1.0.3 - Straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.3 (DanielChoi)
15:32:41 <JagaJaga> monochrom: int-e: matematikaadit: works super fast. Sorry monochrom that I've missed your answer.
15:39:49 <Luke> is "cabal run myApp -- +RTS -N" the right way to use cabal run to run a multithreaded app?
15:39:54 <Chathurga> Could sequence be defined only requiring Applicative and still be equivilent to the Monad version?
15:40:20 <Chathurga> As in: sequence = foldr (liftA2 (:)) (pure [])
15:40:46 <glguy> :t T.sequenceA
15:40:48 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:41:23 <Chathurga> Oh cool, yeah so that generalizes it but yeah it works
15:41:25 <Chathurga> glguy: Thanks
15:50:39 <Darwin226> What could be a possible reason for "cabal repl" to throw "parse error" when just oppening the file in ghci doesn't?
15:51:27 <geekosaur> cabal file enables an extension which steals syntax used by the file? (there aren't many such but they do exist)
15:51:57 <Darwin226> My .cabal file doesn't specify any extensions
15:52:18 <Darwin226> and the only one I use is in the file itself
15:52:21 <Darwin226> overloadedstrings
15:52:27 * hackagebot mustache-haskell 0.1.0.4 - Straight implementation of mustache templates  http://hackage.haskell.org/package/mustache-haskell-0.1.0.4 (DanielChoi)
15:55:52 <Darwin226> http://lpaste.net/116020
15:55:54 <Darwin226> line 38
15:55:57 <Darwin226> Anything suspicious?
15:58:44 <sportanova> What's the best way to add concurrency to haskell web framework routes / requests (scotty in particular, but also happstack / snap / yesod )? Is it baked in, or do you need to explicitly use forkIO? I'm familiar with Scala's actor system, but just getting started with haskell
15:58:57 <shachaf> Darwin226: It would be useful if you said what the error was.
15:59:07 <shachaf> I assume GHC says more than "parse error"
15:59:41 <agocorona> sportanova: each request creates his own thread.
16:00:03 <Darwin226> shachaf: Yes. It also says "possibly incorrect indentation or mismatched brackets"
16:00:13 <shachaf> That doesn't sound like a full error message either.
16:00:17 <jfischoff> sportanova: have you heard of STM?
16:00:38 <shachaf> A full error message has a file name and line number, and is several lines long (so you might hpaste it rather than paste it here).
16:01:01 <sportanova> agocorona: automagically? what does it use under the hood? jfischoff: heard of it but never used it - is that what they use?
16:01:52 <agocorona> sportanova: yes. your request handler run in his own haskell thread
16:02:03 <Darwin226> shachaf: http://lpaste.net/116021 here. Everything it says
16:02:22 <jfischoff> sportanova: to get an idea of how a Haskell http server works, look at the serveSocket function here: https://hackage.haskell.org/package/acme-http-0.2.2/docs/src/Acme-Serve.html#serveSocket
16:02:28 <sportanova> agocorona: very cool
16:02:40 <peddie> does anyone know whether there's a way to collapse all "instances" boxes at once in haddock pages?
16:02:43 <Darwin226> shachaf: Ignore past line 36
16:03:13 <sportanova> jfischoff: thanks - i'll check it out!
16:03:39 <jfischoff> it is only 5 lines btw
16:05:21 <sportanova> in "serveSocket listenSocket app" and forkIO i'm guessing
16:06:13 <jfischoff> yeah the server loop is very simple
16:06:31 <jfischoff> pretty much the design of all the HTTP servers I think
16:07:05 <sportanova> that's awesome!
16:07:21 <nshepperd> Darwin226: I don't know why plain ghci would be okay with it, but it seems wrong to have the contents of the do block be at the same indentation as the surrounding "let" definitions
16:07:50 <jfischoff> sportanova: One of the best Haskell books is related to your question: http://chimera.labs.oreilly.com/books/1230000000929/index.html
16:08:17 <Darwin226> nshepperd: What do you mean?
16:08:24 <jfischoff> sportanova: the author is one of the main contributors to GHC
16:08:48 <jfischoff> one of the “Two Simons”
16:09:07 <Darwin226> nshepperd: Oh. I indented the inner do block more and it works now
16:09:19 <sportanova> and it's free - you haskellers are just too good to me
16:09:42 <Darwin226> nshepperd: I can see how that works. Not yet sure if I like it
16:10:39 <jfischoff> :)
16:12:06 <sadgit> What should I do while Lens is installing?
16:12:30 <jfischoff> write code I guess
16:12:51 <sadgit> Good idea
16:13:08 <nshepperd> Darwin226: every block has to have more indentation than its surrounding block iirc, to avoid ambiguity
16:13:35 * jfischoff should follow his own advice
16:13:47 <Darwin226> nshepperd: I get that. It's just that in other languages what I did WOULD be considered more indented
16:14:12 <Darwin226> nshepperd: Here I have to indent past the name of the binding, not just past the let keyword
16:14:48 <nshepperd> Darwin226: yes, because those 'let' statements themselves introduce a block
16:15:05 <nshepperd> because you can define multiple names with a single 'let'
16:15:16 <Darwin226> nshepperd: Right. That does make sense
16:16:05 <tromp_> > 64 * ln (32/17)
16:16:06 <lambdabot>  Not in scope: ‘ln’
16:16:07 <lambdabot>  Perhaps you meant one of these:
16:16:07 <lambdabot>    ‘n’ (imported from Debug.SimpleReflect),
16:16:07 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect),
16:16:07 <lambdabot>    ‘un’ (imported from Control.Lens)
16:16:18 <hexagoxel> in those cases i tend to add a newline after `let`, to reduce the added indentation
16:16:46 <tromp_> > 64 * log (32/17)
16:16:47 <lambdabot>  40.48144375958467
16:18:07 <tromp_> > 64 * exp (-38/64)
16:18:09 <lambdabot>  35.344156810433304
16:19:16 <tromp_> > 64 * exp (-42/64)
16:19:17 <lambdabot>  33.20276260184892
16:35:00 <benzrf> does anybody here know netwire
16:35:51 <Luke> is "cabal run myApp -- +RTS -N" the right way to use cabal run to run a multithreaded app?
16:39:11 <dmj`> benzrf: jle`
16:40:00 <benzrf> he doesnt appear to be here >.>
16:44:55 <pharpend> what is it with people and ` s
16:47:31 <bryanedds> Cale: Ya, I'm back
16:47:44 <bryanedds> and like I figured, I'm having trouble writing bind :)
16:47:59 <bryanedds> http://lpaste.net/116022
16:48:33 <bryanedds> I've got the types right I think, but this can't possibly be the fully correct definition of bind
16:49:41 <Cale> bryanedds: Yeah, if m is Complete, then the result should potentially be Complete as well
16:49:44 <bryanedds> I feel like the Complete case might be right
16:50:01 <bryanedds> oh
16:50:02 <bryanedds> heh
16:50:08 <bryanedds> so then none of it's right :)
16:50:47 <Cale> and yeah, there's the question about what to do with the p's
16:51:24 <Cale> You get one value of type p from executing the partial computation, but then more from executing the continuation
16:51:30 <Cale> So perhaps there ought to be a list
16:51:44 <Cale> (so that the results could be concatenated)
16:52:05 <bryanedds> a list in the data type M?
16:52:09 <Cale> (Or of course, it could be an arbitrary monoid)
16:52:37 <bryanedds> the result should be computed as the monad is evaluated, no?
16:52:59 <Cale> I mean like: data M s p a = Partial (s -> (s, [p], M s p a)) | Complete (s -> (s, a))
16:53:04 <bryanedds> why would we need to explicitly track that intermediate reults?
16:53:29 <bryanedds> hmmm
16:53:30 <Cale> Well, the p's are intended as partial output which can be obtained before the computation is done
16:53:38 <Cale> separate from the result
16:54:03 <bryanedds> so, I don't think I'm trying to compute any particular result
16:54:15 <Cale> another option is that the result of bind on a partial will just do very little and just recursively bind to the continuation
16:54:23 <bryanedds> the end state of s is the only thing that will be useful after the monad is run
16:54:37 <Cale> oh, okay
16:54:48 <bryanedds> I think the only reason p is useful is so that it can be passed to the next computation
16:55:01 <Cale> Maybe you should say something more about the computation you're really writing
16:55:08 <Cale> Like, what all this is for
16:55:22 <Cale> Because I think we're complicating things with features you don't need :)
16:55:43 <bryanedds> ok
16:55:54 <bryanedds> I have a purely functional event system for a game in F#
16:57:04 <bryanedds> the point of this monad is to be able to write sequential looking code where each step gets executed for each time an event is raised
16:58:04 <bryanedds> Because the event system is purely functional, the world state (here s) has to be threaded through all its handlers
16:58:18 <bryanedds> So we know we need 2 things -
16:58:49 <bryanedds> 1) a monadic interface to allow the user to write sequential-looking code without resorting to pure combinators
16:59:05 <bryanedds> 2) state (as in the state monad)
16:59:54 <bryanedds> does this make any sense?
17:00:41 <bryanedds> I feel like I can acheive this if I can just get the bind definition going
17:01:07 <Cale> Okay, so what happens when an event occurs? We run some of the code up to a point, and either the computation is completely done, and stops handling events(?), or it becomes ready to receive another event and pauses?
17:01:38 <Cale> Do the events themselves carry values?
17:01:43 <bryanedds> right, one of the two depending on whether the last runs yields partial or complete
17:01:57 <bryanedds> Yes, they do, but things are already complicated enough
17:02:25 <Cale> Okay, so let's ditch the p's altogether
17:02:25 <bryanedds> they also return an additional value determining rather the event should cascade to other handlers, but again, this stuff is already complicated
17:03:22 <bryanedds> however, we also need something like the p's because we need to be able to pull values out of the computation and bind them in the middle of executing the monad
17:04:00 <bryanedds> otherwise our sequential-looking code won't be able to do very much
17:05:06 <bryanedds> or maybe not
17:05:25 <benzrf> sounds a bit like pipes to me
17:05:26 <bryanedds> maybe we don't need them, and can get our values out of the state with getState
17:05:32 <benzrf> or at least a generator type
17:05:52 <bryanedds> so yes, maybe we don't need the p's :)
17:06:00 <benzrf> yield an event downstream, get back an effect
17:06:10 <benzrf> er, a response
17:06:13 <bryanedds> I don't know much for sure; I am very confused by it all
17:06:15 <benzrf> independently stateful
17:06:23 <benzrf> hmm
17:07:14 <bryanedds> it's like a state monad who operations can be independently stepped through by another process
17:07:22 <bryanedds> (in this case, my pure functional event system)
17:07:59 <bryanedds> it would also be nice to get it to play well with my event system somehow, but my god it's so complicated for me already
17:08:50 <Cale> benzrf: Yes, pipes is the logical conclusion of this
17:09:00 <Cale> benzrf: But only after adding a fuckton of complexity
17:09:02 <Cale> :)
17:09:37 <bryanedds> Cale, I wouldn't describe it as 'pausing', it simply sits in its current state, bound to the world until the next event fires, then the next step is taken
17:10:06 <bryanedds> (I won't go into detail about how that happens, but it's pretty straightforward within the mechanisms of my pure fn game engine)
17:10:53 <benzrf> bryanedds: wait, so
17:11:21 <benzrf> oh wait
17:11:47 <benzrf> DAMN i just realized that generators are objects
17:12:09 <benzrf> oh... wait no that's stupid
17:15:21 <bryanedds> Here is the code after removing the p's - http://lpaste.net/116022
17:16:06 <bryanedds> bind's Partial case is definitely not right because m goes unused (see comment)
17:18:22 <lpaste> bryanedds revised “Please help with defining bind”: “No title” at http://lpaste.net/116022
17:19:02 <bryanedds> I think I maybe fixed the Complete case in bind here, but the issue with the Partial case remains
17:20:37 <bryanedds> or not
17:20:39 <bryanedds> I have no idea
17:22:32 <Cale> (Partial f) >>= cont has to be Partial, but (Complete f) >>= cont might or might not be Complete, right?
17:23:21 <Cale> The Complete means that the first part of the computation ran to completion without hitting a point where it wanted to wait for another event to occur.
17:23:31 <Cale> But the second part of the computation might wait, or might not.
17:23:57 <bryanedds> as far as the monad is concerned, the computation will always wait on Partial
17:24:25 <bryanedds> the use could abandon the process by unsubscribing, but that won't be the monad's concern in any way
17:24:36 <bryanedds> that's all in the existing event system
17:24:47 <Cale> Yeah, well, if we have a Partial (a computation which waits at least once), and we follow it up with any other computation, the result is something which waits.
17:25:19 <benzrf> this seems wrong...
17:25:20 <bryanedds> yes, though perhaps 'suspend' is a better way to put it
17:25:23 <benzrf> why do you need to see the State
17:25:26 <benzrf> er, the s
17:25:27 <Cale> If we have a Complete (a computation which doesn't wait), and we follow it up with some other computation (based on the result of the first), the result is something which may or may not wait.
17:26:18 <Cale> benzrf: We could actually do without the explicit s I think.
17:26:20 <bryanedds> Complete is never followed by anything - it's the end of the computations
17:26:41 <Cale> Well, we could take it as a parameter in the Partial case
17:27:12 <Cale> and let the resulting M s a just be a different computation, rather than producing a final state yet
17:27:22 <Cale> However, I think that's farther from what bryanedds wants here
17:27:34 <bryanedds> a 3 step computation is Partial => Partial => Complete
17:27:38 <Cale> because he wants to get an updated game world state after each partial step
17:27:43 <benzrf> w-what DOES he want
17:28:02 <benzrf> bryanedds: why not just use state then
17:28:11 <benzrf> bryanedds: you know you can do vertical composition, right?
17:28:22 <Cale> benzrf: Because runState can't run partially
17:28:25 <bryanedds> state doesn't have the ability to be stepped through by a separate process
17:28:32 <benzrf> then why not put the game inside the State
17:28:40 <Cale> uhhhh
17:28:41 <benzrf> that seems natural to me!
17:29:31 <Cale> benzrf: The point is to represent computations that can pause after doing some work to the state, and then be continued later.
17:29:57 <bryanedds> so Cale, are totally on the wrong track with what we have so far, or should we continue with the bit of code I've got?
17:30:08 <benzrf> Cale: who pauses?
17:30:14 <benzrf> the computation, or the outside force?
17:30:34 <bryanedds> each step in the monad is run when an associated event is raised
17:30:36 <benzrf> hmm well i guess it inherently has to be the computation doing the pausing
17:30:49 <Cale> bryanedds: I think this is an okay path
17:30:53 <bryanedds> it allows you to write sequential-looking code that executes based on event callbacks
17:30:58 <benzrf> bryanedds: at this point why not just manually use State kleisli arrows without the newtyp
17:31:00 <Cale> bryanedds: We could take very different approaches to this
17:31:08 <benzrf> it doesnt sound like you're using the monad interface at all
17:31:12 <Cale> But let's see this one through at least until it works
17:31:18 <Cale> benzrf: Trust me, this is a monad
17:31:21 * benzrf backs away
17:31:31 <Cale> benzrf: It's ListT done right applied to State s essentially.
17:31:38 <Cale> er...
17:31:39 <benzrf> huh...
17:31:45 <benzrf> that doesnt seem right
17:31:45 <Cale> no, it's actually a little different from that :)
17:31:55 <bryanedds> hehe
17:31:59 <Cale> OR IS IT?
17:32:05 <bryanedds> I'm glad I'm not the only one confused :)
17:32:25 <Cale> Yeah, not quite the same thing
17:32:37 <Cale> That one has nondeterminism that this doesn't have
17:33:02 <bryanedds> I think it is a sensible thing, which is why I've spent five days on it so far :)
17:33:16 <bryanedds> my intuition tells me its totally possible and totally worth it
17:33:32 <bryanedds> suck burning 50 hours on 'little' thing tho
17:33:36 <bryanedds> *sucks
17:33:50 <Cale> Okay, let's start bindM over, and think the cases through carefully
17:34:00 <bryanedds> It took me maybe 3 days to even figure out what I wanted
17:34:17 <bryanedds> to the point I ask an intelligible question in here
17:34:18 <bryanedds> ok
17:34:40 <bryanedds> ya, both my cases in bind are totally wrong - happy to set this train cart on fire
17:35:03 <benzrf> hmm
17:35:08 <benzrf> where do i submit GHC feature requests
17:35:24 <MP2E> GHC bug tracker, I'd imagine
17:35:28 <MP2E> or mailing list
17:35:34 <benzrf> i want to request a "NO FUCK YOU" pragma that enables NoMonomorphismRestriction
17:35:36 <MP2E> mailing list would proabbly be better at first
17:37:03 <bryanedds> so, we have an m value and a continuation cont
17:38:04 <bryanedds> and we're trying to get to M of another type
17:38:11 <Cale> bryanedds: OH
17:38:17 <Cale> bryanedds: This is a bit off :)
17:38:31 <Cale> Attempting to write bindM for Complete immediately gets us into trouble :)
17:38:51 <bryanedds> oh no
17:38:55 <Hermit> How should I go around implementing a very efficient server process (should I use forkIO or something else for handling requests?) and a client command that can communicate with it to update some data? I thought of using a named pipe, a unix socket, and tcp, but is there another way? how could I make it work with haskell?
17:39:10 <Cale> Because we need to know whether our result is Partial or Complete before we can capture the initial state with a lambda
17:39:31 <Cale> and we won't know that until we have the initial state
17:39:42 <jmcarthur> ignoring bottoms, this type is equivalent:   newtype M s a = M (s -> (s, Either a (M s a)))
17:39:44 <bryanedds> are you sure? I thought the only way to get a Complete state is via return
17:39:46 <Cale> So we need to move the s parameter out
17:40:06 <Cale> bryanedds: Not necessarily!
17:40:19 <Cale> bryanedds: In particular, probably the operations to get and set the state will be Complete
17:40:36 <bryanedds> oh hm
17:40:45 <bryanedds> right
17:40:52 <jmcarthur> it is not immediately obvious to me that this is a monad at all
17:40:54 <bryanedds> ya, I was thinking aobut that when I tried writing them
17:41:39 <bryanedds> wasn't sure how to implement them
17:42:05 <bryanedds> however, don't we know where all Complete come from a priori?
17:42:18 <L8D> what happened to hugs?
17:42:18 <jmcarthur> i take it back. i do not know that that type is equivalent, and in fact it is likely not to be
17:42:20 <Cale> Actually, no, we can probably do this without changing things
17:42:55 * bryanedds is having panic attacks
17:42:56 <Cale> It's just a little more awkward than it perhaps could be
17:43:05 <jmcarthur> yup, completely ignore me, please
17:43:39 <Cale> Let's change it to jmcarthur's type though, because that's just going to be so much better
17:43:40 <L8D> is there something I can be using in place of hugs?
17:43:46 <Cale> L8D: ghci
17:43:47 <merijn> L8D: ghci?
17:43:58 <Cale> and not only could you be using ghci, but you should
17:44:01 <L8D> I'm looking for an interpreter, not really a REPL
17:44:08 <L8D> or can I use ghci as an interpreter?
17:44:09 <Cale> Still ghci
17:44:11 <Cale> yes
17:44:13 <L8D> how?!
17:44:16 <merijn> ghci/runhaskell
17:44:29 <L8D> nonono that's not an interpreter though
17:44:34 <L8D> it still goes to GHC to compile everything
17:44:36 <Cale> What is an interpreter to you?
17:44:45 <bryanedds> um, I'm not sure what the F# equivalent is for newtype
17:44:51 <L8D> something that doesn't have an intermediate compilation step in order to run
17:44:55 <Cale> It doesn't necessarily compile the code all the way to machine code
17:45:14 <L8D> the speed runghc/cabal really takes a toll on productivity when it comes to running tests
17:45:21 <L8D> the speed of*
17:45:22 <Cale> GHCi also includes a bytecode interpreter which will get used unless there are .o/.hi files hanging around
17:46:04 <L8D> if I understand correctly, hugs was a Haskell interpreter which didn't use intermediate compiled representations to run on its VM
17:46:17 <L8D> so you can run stuff like you would run ruby or python scripts
17:46:29 <bitemyapp> L8D: slow down
17:46:33 <Cale> hugs is a very old implementation of Haskell in C
17:46:33 <L8D> except, because it's an interpreter, it would have a runtime speed far slower than GHC
17:46:39 <bitemyapp> L8D: for one thing, you can run tests in GHCi which is an interpreter.
17:46:58 <bitemyapp> L8D: if you have a project, you just call `cabal repl` if you have a test stanza, `cabal repl tests` or whatever the stanza name is.
17:46:58 <L8D> it still has the same compilation time as just using `cabal test`
17:47:06 <Cale> It hasn't been maintained in quite a while, and you probably shouldn't really use it, apart from testing to see how standards-compliant your code is.
17:47:10 <bitemyapp> L8D: that hasn't been my experience.
17:47:20 <jmcarthur> ah, my type is a monad
17:47:30 <Cale> jmcarthur: Yes
17:47:34 <bitemyapp> L8D: reloading and re-running tests in my GHCi has been much faster than `cabal test`
17:47:41 <Cale> jmcarthur: and the instance is much less of a hassle to write :)
17:47:46 <jmcarthur> yup
17:47:55 <L8D> oh, you're keeping a live instance of GHCi and reloading modules when you run your tests?
17:48:12 <Cale> (you can still write the instance for the type we were using originally, it's just a bit awful)
17:48:16 <jmcarthur> it's   type M s = FreeT Identity (State s)
17:48:20 <bitemyapp> L8D: ...yes
17:48:24 <bitemyapp> L8D: that's how lispers usually work.
17:48:29 <L8D> Like what all the Clojure people do to get around Java's startup time
17:48:31 <bitemyapp> L8D: persistent do-it-all REPL
17:48:40 <bitemyapp> L8D: I came to this language *from* Clojure and CL before that.
17:48:41 <L8D> hm...
17:48:52 <bitemyapp> L8D: it happens to be an excellent idea no matter what your language is.
17:49:02 <Cale> bryanedds: So let's do this:  data M s a = M (s -> (s, Either (M s a) a))
17:49:09 <jmcarthur> ah, i haven't convinced myself of the original type being a monad yet. guess i'll do that now
17:49:10 <bryanedds> ok
17:50:02 <L8D> holy shit that's quick
17:50:19 <Cale> returnM v = M (\s -> (s, Right v))
17:51:06 <L8D> bitemyapp: :reload in ghci is only reloading my test suites
17:51:31 <bryanedds> oh
17:51:42 <Cale> step (M f) s = f s
17:53:32 <bryanedds> ok
17:53:36 <jmcarthur> hmm. intuitively, this original type is a monad. it looks like a funky statified version of Free Identity. however, i can't think of a way to *construct* this type using stuff like Free, FreeT, Iter, etc.
17:53:59 <jmcarthur> maybe i can't
17:54:03 <bryanedds> ah, I just thank gawd I have a mona
17:54:04 <bryanedds> d
17:54:44 <Cale> bindM m k = M (\s -> case step m s of (s', Left m') -> (s', Left (bindM m' k)); (s', Right v) -> step (k v) s')
17:54:50 <Cale> I believe that's right
17:55:20 <Hermit> How should I go around implementing a very efficient server process (should I use forkIO or something else for handling requests?) and a client command that can communicate with it to update some data? I thought of using a named pipe, a unix socket, and tcp, but is there another way? how could I make it work without pulling my hair?
17:56:38 <Cale> and then  run m s = case step m s of (s', Left m') -> run m' s'; (s', Right v) -> (s', v)
17:56:49 <Polarina> Hermit, forkIO and networking scales very well.
17:57:12 <Polarina> Hermit, it's unlikely you'll find anything more efficient.
17:57:15 <Cale> jmcarthur: I think there ought to be *some* way :)
17:57:26 <Cale> jmcarthur: But I'm not sure exactly what the right way is either :)
17:57:41 <Hermit> Polarina: thanks, I'll go with it then. I'm thinking of using some mutable hashtable or something for keeping the data in the main process
17:57:48 <Cale> jmcarthur: It's possible this is just StateT of something
17:57:50 <Cale> like Iter
17:58:00 <Hermit> Polarina: or should I go with bare Map?
17:58:11 <benzrf> Cale: from what i'm hearing it sounds a lot like a generator
17:58:26 <Polarina> Hermit, immutable types typically experience better GC behaviour.
17:58:36 <bryanedds> I have a lot of errors from that
17:58:44 <jmcarthur> hmm
17:59:25 <lpaste> bryanedds pasted “No title” at http://lpaste.net/116027
17:59:45 <bryanedds> is that all what you meant?
17:59:52 <Cale> yeah
18:00:13 <Hermit> Polarina: thanks for the advice, that should do it. Now I need to get cracking
18:00:30 * Hermit opens a bunch of hackage pages
18:00:43 <Cale> Note that you can avoid having to write step at all by just making it the name of the field, but seeing as you're translating this to F# I don't know :)
18:01:16 <bryanedds> I can't get the translated version to compile either
18:01:17 <Cale> step m = case m of M f -> f
18:01:19 <Cale> will also work
18:01:22 <Cale> oh
18:01:29 <Cale> I'll try :)
18:01:40 <bryanedds> oh shit
18:01:48 <bryanedds> I think I got the monad's type wrong
18:01:55 <Cale> oh!
18:01:56 <Cale> yes
18:02:13 <Cale> yeah, that's all
18:02:18 <Cale> It compiles after that
18:02:20 <bryanedds> I forgot the tuple in the data type
18:02:57 <Cale> So, we can add stuff to this...
18:03:22 <Cale> get = M (\s -> (s, Right s))
18:03:37 <bryanedds> ok, now I've got stuff compling
18:03:39 <Cale> put s' = M (\s -> (s', Right ()))
18:04:11 <Cale> wait k = M (\s -> (s, Left k))
18:05:26 <jmcarthur> Cale: actually, i'm back to thinking the original is not a monad again
18:05:26 <Cale> Exercise: write type signatures for these :)
18:05:43 <Cale> jmcarthur: hmm
18:05:49 <bryanedds> hehe ok :)
18:05:52 <bryanedds> that's the easy part :)
18:06:17 <bryanedds> well, maybe not in haskell, but I will certainly be my their types explicit in F#
18:07:07 <Cale> bryanedds: We could add an extra function parameter to the Left branch of the Either (currently there are none) in order to handle an "event type"
18:07:28 <bryanedds> ok
18:07:43 <Cale> (and on the outside, along with the initial s)
18:09:05 <pecanpy> what library can i use for 2d drawing on windows - that comes with haskell platform? i just tried Graphics.UI.GLUT but its saying its missing glut32.dll, so im guessing it needs additional installs.
18:09:31 <Cale> errrr
18:09:39 <Cale> no, not on the outside :)
18:09:41 <Cale> one or the other
18:10:07 <bryanedds> the ; is confusing me; not sure how that translates to ML
18:10:09 <solirc> ezrios: I consider this a "bug" in parsec, you can solve this by mapping the error to e.g. () in your tests.
18:10:22 <Cale> bryanedds: It just separates the branches of the case
18:10:29 <solirc> ezrios: I just opened an issue https://github.com/aslatter/parsec/issues/16
18:10:29 <jmcarthur> Cale: http://lpaste.net/116028
18:10:42 <Cale> it would've been a line break if this weren't IRC
18:10:49 <bryanedds> ah
18:11:10 <Cale> jmcarthur: yeah, that seems reasonable
18:11:46 <bryanedds> oh no
18:11:52 <bryanedds> is our new one a monad, tho/
18:11:58 <jmcarthur> yes, it is
18:12:03 <bryanedds> ah thank god
18:12:07 <bryanedds> almost cried
18:12:30 <bryanedds> I'm still translating all this to F#, btw
18:12:34 <bryanedds> could take a moment
18:16:10 <jmcarthur> lol, it's a monad after all. i just thought of it. however, it loses a lot of interesting structure in bind, and it's complicated. let me try to write it
18:16:38 <bryanedds> hehe
18:21:16 <Cale> jmcarthur: I had this fight in my head and didn't really think about it clearly enough before concluding that it was a silly way to represent things anyhow
18:22:37 * hackagebot yesod-worker 0.0.1 - Drop-in(ish) background worker system for Yesod apps  http://hackage.haskell.org/package/yesod-worker-0.0.1 (jdabbs)
18:23:45 <jmcarthur> Cale: i think if there is a monad lurking here, it looks more like this:   http://lpaste.net/116036
18:24:59 <lpaste> Cale pasted “With event values now” at http://lpaste.net/116038
18:25:06 <Cale> bryanedds: ^^
18:25:23 <Cale> The type of run is getting a little hairy. Some custom data types would help
18:25:40 <Cale> (using tuples and either directly kind of sucks for readability)
18:25:46 <bryanedds> ah cool :)
18:26:09 <Cale> Note that the main thing which has changed now is the type of wait
18:26:16 <Cale> wait :: (e -> M e s a) -> M e s a
18:26:34 <Cale> It means we can arbitrarily decide to wait for another value of type e to come.
18:26:36 <bryanedds> awesome stuff :)
18:27:02 <jmcarthur> ah, the type changed since i last looked...   FreeT ((->) e) (State s)
18:27:20 <Cale> Yeah, that seems right :)
18:27:58 <Cale> jmcarthur: If that's the case, then before it was FreeT Identity (State s)
18:28:08 <jmcarthur> Cale: correct. i said that earlier ;)
18:28:16 <Cale> ah, okay
18:29:22 <bryanedds> I think I see a bit of the State monad in here
18:29:30 <Cale> black :: M e s a -- Half-life 3 confirmed
18:30:05 <Cale> bryanedds: You sure can
18:31:28 <Cale> jmcarthur: Do you have a fancy way to write 'run' with FreeT? :)
18:31:45 <Cale> I haven't used FreeT very much to know what exists surrounding it
18:32:15 <jmcarthur> a few ways
18:32:35 <jmcarthur> iterT :: (Functor f, Monad m) => (f (m a) -> m a) -> FreeT f m a -> m a   -- probably my most common? i don't know really
18:33:00 <benzrf> anybody here handy with reactive banana
18:33:12 <Cale> I mean the run that I wrote which does a bunch of steps at once
18:33:20 <jmcarthur> ah, let me look
18:33:38 <Cale> I suspect it'll still be a little bit of work
18:34:17 <jmcarthur> i'll give it a shot
18:34:34 <Cale> I probably shouldn't fiddle with the type so much, let's fix that...
18:35:16 <bryanedds> ah, I thikn your version with events is a bit off
18:35:31 <bryanedds> each step needs its own event value
18:35:35 <lpaste> Cale revised “With event values now”: “No title” at http://lpaste.net/116038
18:35:49 <Cale> Each step *does* have its own event value
18:35:57 <Cale> Each step as defined by wait
18:36:13 <bryanedds> run won't have all the event values up front
18:36:28 <Cale> yes, which is why it can stop after supplying finitely many
18:36:40 <Cale> you can just use step if you want to put in one at a time
18:36:57 <bryanedds> but step doesn't have a parameter for the event value?
18:37:11 <Cale> Right, but it'll (maybe) get you something which does
18:37:29 <Cale> Or else, it'll finish, in which case there's nowhere for the event to go because the computation is done.
18:37:38 <bryanedds> event values have to come from an external source
18:38:00 <bryanedds> (or maybe I just don't understand how it works yet)
18:38:31 <bryanedds> I think I'll try to get the non-event value version working first
18:38:43 <Cale> We could pull the e outward
18:39:05 <Cale> If you wanted to always have access to the current event when running one of these things
18:39:14 <Cale> I sort of have it set up the other way around
18:39:35 <Cale> so that running one of these computations can result in waiting for an event of type e
18:39:47 <Cale> but you might not have an event of type e handy to begin with
18:40:01 <bryanedds> I'm also not sure what wait is for
18:40:08 <Cale> It's the whole point :)
18:40:18 <bryanedds> each step is waited for automatically
18:40:28 <Cale> wait is how you express steps
18:40:32 <bryanedds> the user never specifies when to wait
18:40:35 <Geekingfrog> In the process of learning haskell I often encounter new functions names. I can go on Hoogle to look up these, but how can I reverse the process: "I want to do xxx, is there any built-in function to do that?" Any good resources about that?
18:40:35 <Cale> wait $ \e -> do ...
18:40:38 <bryanedds> each bind is a wait
18:40:42 <Cale> no!
18:40:49 <Cale> That's not true :)
18:40:58 <bryanedds> that's what I wanted, anyway
18:41:07 <Cale> That won't result in a monad
18:41:16 <Cale> Because you *must* have that x >>= return = x
18:41:21 <Cale> in order to satisfy the monad laws
18:41:30 <Cale> as well as  return v >>= f = f v
18:41:53 <Cale> So some binds need to be invisible
18:41:57 <mauke> Geekingfrog: you can hoogle type signatures
18:42:01 <benzrf> who here knows their FRP
18:42:11 <benzrf> x_x
18:42:19 <Geekingfrog> mauke, thanks, I'll try that next time
18:42:20 <Cale> You can't "count" the number of binds, that's not a well-defined operation on a monad
18:42:21 <jmcarthur> Cale: yeah, i don't see a way to write that run function using common FreeT folds or something
18:42:25 <benzrf> i am havings some trouble
18:42:48 <Cale> bryanedds: But by making it into an explicit operation, we sidestep that
18:42:50 <bryanedds> hm, I suppose I could try it a different way
18:43:06 <bryanedds> maybe have a liftM that automatically has a wait
18:43:16 <Cale> bryanedds: So we can, at any point, say,  wait $ \e -> do stuff
18:43:46 <Cale> bryanedds: and that will cause the computation to pause until an event of type e is made available, and continue with the body of the lambda once it is :)
18:43:53 <bryanedds> ok
18:44:10 <Cale> At least, from our perspective inside here
18:44:17 <bryanedds> it seems like more of a burden on the user
18:44:28 <Cale> Shouldn't be too bad, I think
18:44:39 <bryanedds> but if it's impossible to get around it  and still have a monad
18:44:41 <Cale> We could, via some contortion, turn this around
18:44:44 <jmcarthur> wrap the whole thing in ContT and wait can just be a simple command instead of something needing an explicit continuation.
18:44:48 <Cale> right
18:44:58 <Cale> So you'd have e <- wait instead
18:45:05 <Cale> But it would still be explicit
18:45:58 <bryanedds> ya, but that seems a better usage
18:46:18 <Cale> Yeah, at the cost of making the implementation more mind-bending :)
18:46:39 <jmcarthur> it has ups and downs. the more effects you add to a monad, the more effects you have to think about.
18:46:39 <bryanedds> hmm... perhaps I should see if I can make this one satisficing first then
18:46:56 <benzrf> simplified version of my problem: I have `updates :: Event t ([Int] -> [Int])' and `printReqs :: Event t ()'
18:47:20 <Cale> benzrf: This is with banana?
18:47:22 <benzrf> yeah
18:47:23 <jmcarthur> ContT, in particular, is a pretty powerful and mind-bending effect
18:47:24 <benzrf> i want to maintain an [Int] in a Behavior or Event or something that gets each event in updates applied to it
18:47:25 <bryanedds> so how would you use the current one in do form?
18:47:36 <benzrf> and i want to print off the last element each time printReqs fires
18:47:38 <benzrf> this is easy
18:47:40 <benzrf> heres the hard part:
18:47:57 <benzrf> pop the last element of the list when printReqs fires in addition to printing
18:50:59 <benzrf> the simple solution is to take a union of `updates' with `tail <$ printReqs', then create a Behavior by accumulating those functions, then make an event of the last element with `(head <$> thatBehavior) <@ printReqs'
18:51:18 <benzrf> but then im worried about race conditions and stuff between that last event firing and the behavior updating
18:51:23 <benzrf> since both are a function of printReqs
18:52:22 <benzrf> printReqs alone with mapAccum does something close to what i want, but then i cant add my updates
18:52:25 <benzrf> afaict
18:52:55 <benzrf> should i give up and just write a loop
18:54:03 <Cale> bryanedds: Well, you could write a series of waits
18:54:31 <Cale> do wait $ \e -> do { ... } ; wait $ \e -> do { ... }
18:54:43 <Cale> bryanedds: each one would get a single event
18:55:09 <bryanedds> hm
18:55:14 <bryanedds> it's probably okay as it
18:55:28 <Cale> ghci> let (es, (s, v)) = run (do wait (\e -> put e); wait (\e -> put (e + 1))) [10,20] 0
18:55:29 <Cale> ghci> s
18:55:29 <Cale> 21
18:55:56 <Cale> ghci> let (es, (s, v)) = run (do wait (\e -> put e); wait (\e -> put (e + 1))) [10] 0
18:55:56 <Cale> ghci> s
18:55:56 <Cale> 10
18:56:30 <Cale> and note that I get back the computation each time here
18:56:39 <Cale> so I could have done that example in two steps...
18:56:55 <wally777> .
18:56:57 <agocorona> do not know the context, but for events and monads:  https://www.fpcomplete.com/user/agocorona/monad-reactive-programming-2
18:59:59 <benzrf> Cale: y-you know FRP, right?
19:00:43 <Cale> Sort of, but I don't quite understand your question. The use of the word "print" here is foreign to me.
19:01:17 <Cale> benzrf: Is printReqs like an event on the occurrences of which the driver is meant to print something?
19:01:17 <benzrf> Cale: ok here's some simple cod
19:01:21 <benzrf> Cale: ah yes
19:01:31 <benzrf> something like
19:01:32 <lifter> I've noticed that the compiler sometimes infers the types of my functions such that the signatures have a "forall" in them. I think this is bcus I enabled RankNTypes, which, admittedly, I don't understand - I did it at some point bcus the compiler suggested I do to make something work. Should I keep the "forall"s in my function signatures? They still seem to work if I remove the "forall"...
19:01:48 <benzrf> reactimate (print <$> eventOfHead)
19:02:36 <Cale> lifter: Yes, the explicit forall is an extension. You can put it in or leave it out as it suits you. If you leave it out, Haskell will implicitly quantify all the free type variables at the top level of each type signature
19:02:48 <jmcarthur> i love thinking of Free as a kind of list, but then common list functions turn out looking weird...     zip :: Functor f => (forall a b. f (a -> b) -> g a -> h b) -> Free f a -> Free g a -> Free h a
19:03:07 <benzrf> jmcarthur: of course it's a lis
19:03:07 <benzrf> t
19:03:13 <lifter> Cale: So it's just a question of being explicit or implicit
19:03:17 <benzrf> jmcarthur: all free monoids look similar
19:03:37 <jmcarthur> benzrf: yeah, but that was just buildup to the type, not the point
19:03:37 <Cale> lifter: The advantage of making forall explicit is that you can, for instance, have it in the argument type of a function type.
19:03:48 <jmcarthur> benzrf: the point is that the list functions adapted to Free look weird
19:04:08 <lifter> Cale: Yeah, I guess I better do more reading on it at some point. Thanks.
19:04:09 <Cale> (forall a. [a] -> Int) -> Int  for instance is a type of functions which demand that their argument be polymorphic
19:04:19 <Cale> for example, you can write:
19:04:26 <Cale> foo :: (forall a. [a] -> Int) -> Int
19:04:36 <Cale> foo f = f [1,2,3] + f "Hello"
19:04:37 <jmcarthur> ah i can get rid of the Functor constaint...
19:05:01 <jmcarthur> zipF :: (forall a b c. (a -> b -> c) -> f a -> g b -> h c) -> Free f a -> Free g a -> Free h a
19:05:01 <lifter> Cale: I didn't know there are circumstances in which a type variable would not be polymorphic when there are no typeclass restrictions on it
19:05:15 <Cale> lifter: If you try to give that foo a type like   foo :: ([a] -> Int) -> Int
19:06:44 <Cale> then that means the 'a' type gets chosen by the user of 'foo'
19:07:04 <lifter> ok, right
19:07:07 <Cale> and no matter which type they choose, foo won't know that it's certainly Integer or certainly Char
19:07:25 <Cale> and so won't be able to apply the given function at a specific type of list
19:07:49 <lifter> oh I have seen ghci barf on me due to that
19:07:56 <lifter> I think
19:08:05 <Cale> quite possibly :)
19:08:08 <dmj`> jle`: ping
19:08:44 <benzrf> :t ($"foo")
19:08:45 <lambdabot> ([Char] -> b) -> b
19:08:48 <lifter> earlier today I tried to pass a function "[1..10]" and to shut up ghci I had to give it a type annotation like "([1..10] :: [Int])"... not sure if this is related
19:08:53 <benzrf> :t ($"foo") :: ([a] -> b) -> b
19:08:54 <lambdabot>     Couldn't match type ‘a1’ with ‘Char’
19:08:54 <lambdabot>       ‘a1’ is a rigid type variable bound by
19:08:54 <lambdabot>            an expression type signature: ([a1] -> b1) -> b1
19:08:59 <benzrf> :t ($"foo") :: (forall a. [a] -> b) -> b
19:09:00 <lambdabot>     Couldn't match type ‘[Char] -> b1’ with ‘forall a. [a] -> b1’
19:09:00 <lambdabot>     Expected type: (forall a. [a] -> b1) -> b1
19:09:00 <lambdabot>       Actual type: ([Char] -> b1) -> b1
19:09:07 <benzrf> hmm... wha?
19:09:49 <geekosaur> be nice if you'd experiment in query, but yes, this is the usual problem
19:10:06 <geekosaur> your type sig says the caller chooses the type, but the epxression sets the typer to Char
19:10:34 <Cale> lifter: uhhh, for that one, probably not directly, but there are cases where a type is ambiguous
19:10:46 <lifter> Cale: yeah
19:15:51 <benzrf> dammit how i do this shit
19:16:07 <benzrf> geekosaur: i was trying to illustrate that
19:16:19 <benzrf> geekosaur: i was confused as to why the 3rd input failed
19:16:54 <bryanedds> Cale, could you give an example of how do use this thing?
19:17:03 <bryanedds> with the do syntax?
19:17:29 <Cale> Oh, well, we need to make it a proper instance of Monad to use the do-syntax
19:17:38 <Cale> Is that what you're having trouble with?
19:17:56 <Cale> instance Monad (M e s) where return = returnM; (>>=) = bindM
19:18:36 <bryanedds> sorry, no
19:18:40 <athan> What's a good way to get type-coerced behaviour without the entire type of the stuff you're working in to coerce? Here's my idea so far, the only issue is the type needs to coerce down through the whole expression: http://lpaste.net/116045
19:18:45 <bryanedds> I think I just figured it out tho
19:18:50 <athan> (sorry if this code won't work)
19:19:06 <bryanedds> this seems strange to me - wait takes a, not s?
19:20:39 <bryanedds> I'm not sure what I need s for, now
19:21:39 <athan> bryanedds: What is it you're trying to do?
19:24:06 <athan> I feel like I'm monkey patching typeclasses ><
19:27:38 <benzrf> auughurgh
19:27:45 <benzrf> why wont this work q_q
19:28:21 * benzrf contemplates the potential advantages of just using a goddamn loop
19:30:32 <bryanedds> sry, back
19:30:44 <bryanedds> last message at 22:18
19:31:03 <bryanedds> okay, so I see the use of s, but now I wonder if I need a
19:33:19 <benzrf> is apfelmus ever online x.x
19:33:29 <bryanedds> if I took out 'a', would I still have a monad?
19:41:59 <bryanedds> test
19:46:36 <jmcarthur> bryanedds: if you take out the a it's going to just be a monoid instead of a monad
19:47:05 <bryanedds> do you think doing so would defeat my goals?
19:47:13 <jmcarthur> bryanedds: it's not bad just because it's not a monad though. being a monad doesn't mean it's better
19:47:26 <jmcarthur> i don't really know what your goals are
19:48:07 <bryanedds> ah heh
19:48:07 <bryanedds> I want to be the pretty pretty princess
19:48:31 <benzrf> :t foldMap . foldMap
19:48:32 <lambdabot> (Monoid m, Foldable t1, Foldable t) => (a -> m) -> t (t1 a) -> m
19:48:42 <benzrf> hey, is there a good function for mapping but at the same time folding
19:48:57 <bryanedds> I think it will be fine as a monoid since F#'s computation expr syntax will work with just a monoid
19:49:06 <bryanedds> I think
19:49:07 <jmcarthur> benzrf: what type are you looking for?
19:49:18 <benzrf> jmcarthur: something like
19:49:45 <benzrf> uh
19:50:17 <jmcarthur> benzrf: the main reason i ask is because technically folding subsumes mapping already
19:50:26 <benzrf> (a -> b -> b) -> (x -> (y, a)) -> b -> [x] -> ([y], b)
19:50:29 <benzrf> ^ something like tat
19:50:40 <benzrf> (actually the specific structure i wanna work with is a map)
19:50:50 <benzrf> i was thinking maybe traversable but
19:51:10 <jmcarthur> @djinn (a -> b -> b) -> (x -> (y, a)) -> b -> [x] -> ([y], b)
19:51:10 <lambdabot> Error: Undefined type []
19:51:14 <benzrf> oh waaait
19:51:17 <jmcarthur> meh
19:51:21 <benzrf> heheh i see
19:51:23 <benzrf> 1 sec
19:52:10 <benzrf> :t let f :: x -> (y, z); f = undefined; in traverse f
19:52:11 <lambdabot> (Monoid y, Traversable t) => t a -> (y, t b)
19:52:46 <benzrf> wait, what?
19:52:57 <benzrf> :t let f :: Int -> (String, Bool); f = undefined; in traverse f
19:52:58 <lambdabot> Traversable t => t Int -> (String, t Bool)
19:53:01 <benzrf> kk
19:53:12 <benzrf> not a fully general fold but it werks!
19:53:29 <benzrf> i was thinking "this is what a traversal does but itd have to both be Const AND Identity" and then i thought "oh wait im an idiot"
19:53:47 <jmcarthur> :t foldMapDefault
19:53:48 <lambdabot>     Not in scope: ‘foldMapDefault’
19:53:48 <lambdabot>     Perhaps you meant one of these:
19:53:48 <lambdabot>       ‘T.foldMapDefault’ (imported from Data.Traversable),
19:53:52 <jmcarthur> :t T.foldMapDefault
19:53:53 <lambdabot> (Monoid m, Traversable t) => (a -> m) -> t a -> m
19:55:09 <bryanedds> I can't seem to get the a out and preserve the behavior
19:56:27 <Fuuzetsu> is there an operator that combines fmap and composition? Say, ‘fmap foo . bar’ should turn into ‘foo ??? bar’
19:57:03 <benzrf> Fuuzetsu: i've whined about such an operator before
19:57:05 <benzrf> the answer is no
19:57:09 <Fuuzetsu> ok
19:57:25 <benzrf> anybody know if there's a list destructor function
19:57:33 <Fuuzetsu> head
19:58:02 <benzrf> i mean destructor like
19:58:05 <benzrf> :t either
19:58:06 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
19:58:19 <liyang> fold!
19:58:27 <benzrf> liyang: that's a fold
19:58:29 <benzrf> i just want a destructor
19:58:34 <benzrf> like
19:58:56 <benzrf> @let list f z (h:t) = f h t; list f z [] = z
19:58:57 <lambdabot>  Defined.
19:59:33 <Fuuzetsu> :t list
19:59:34 <lambdabot> (t1 -> [t1] -> t) -> t -> [t1] -> t
20:00:02 <benzrf> nonrecursive, u see
20:00:35 <liyang> :-/
20:04:19 <joneshf-laptop_> :t list const (error "empty list") -- head ?
20:04:20 <lambdabot> [t] -> t
20:04:44 <joneshf-laptop_> in all its partial glory
20:05:27 <joneshf-laptop_> > list const (error "empty list") [1]
20:05:29 <lambdabot>  1
20:05:30 <joneshf-laptop_> > list const (error "empty list") []
20:05:32 <lambdabot>  *Exception: empty list
20:18:26 <bryanedds> Cale: you still about?
20:18:55 <Cale> hi
20:19:04 <bryanedds> step seems to run the whole series
20:19:16 <Cale> bryanedds: hmm, it didn't seem that way to me
20:19:21 <bryanedds> never stops for wait
20:19:35 <Cale> It literally can't continue if it hits a wait
20:19:42 <Cale> because there's no value of type e that you've given
20:19:56 <bryanedds> oh, I'm using the version without the event type
20:20:14 <Cale> In that case, it still shouldn't...
20:21:32 <bryanedds> ah shit, wait uses a Right conr rather than Left...
20:21:41 <bryanedds> (in my translated F# code...)
20:22:19 <bryanedds> sorry, will try again
20:23:07 <bryanedds> okay, that certainly changes how I call wait...
20:23:38 <bryanedds> so, um, how do I call wait in the do expression please :)
20:24:00 <Cale> wait (do ...something more...)
20:24:09 <Cale> Or you can use $ of course
20:24:36 <bryanedds> well, I mean, I don't know what expression I can actually fill in
20:24:46 <bryanedds> it's expecting an M s a type
20:25:04 <Cale> Well, try  wait (do s <- get; put (s+1))
20:26:32 <bryanedds> okay, so I have a function from s -> s that I want to call
20:26:45 <bryanedds> do I put that inside the wait expression?
20:27:25 <bryanedds> I guess I should write a lifter for it
20:28:30 <bryanedds> ok, that works :)
20:30:00 <bryanedds> hmm... how could I do nothing inside of a way?
20:30:07 <bryanedds> *wait
20:30:43 <bryanedds> I guess returnM something
20:31:10 <bryanedds> unit!
20:31:13 <bryanedds> returnM ()
20:32:03 <bryanedds> okay, now I still wonder if I need 'a' in the M data type...
20:34:02 <pavonia> :t returnM
20:34:03 <lambdabot>     Not in scope: ‘returnM’
20:34:04 <lambdabot>     Perhaps you meant one of these:
20:34:04 <lambdabot>       ‘return’ (imported from Control.Monad.Writer),
20:37:44 * hackagebot witherable 0.1 - Generalization of catMaybes  http://hackage.haskell.org/package/witherable-0.1 (FumiakiKinoshita)
20:42:44 * hackagebot unagi-streams 0.1.0.0 - Unagi Chan IO-Streams  http://hackage.haskell.org/package/unagi-streams-0.1.0.0 (LukeHoersten)
20:43:14 <calvinx> question about zipWith.  “zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]” - why is (a -> b -> c) being read as an argument that is a function?
20:43:45 <shachaf> Because that's how Haskell works. What else would you expect it to be read as?
20:44:02 <shachaf> (That sort of question is difficult to answer without knowing what's going on in your head.)
20:44:08 <calvinx> So I can generalise “(a -> b -> c)” to be read as a function in a signature?
20:44:26 <shachaf> A type of the form "x -> y" is always the type of a function.
20:44:37 <shachaf> That's what that arrow means. "a function from ... to ..."
20:44:40 <calvinx> Aha, that’s the answer I am looking for.
20:44:41 <calvinx> Thanks.
20:45:02 <bryanedds> okay, I think I got it working now :)
20:45:36 <shachaf> (In this case, x=a, and y=(b -> c).)
20:45:37 <calvinx> And as a follow up question, why does zipWith’s function argument represented with (a -> b -> c) and not simply (a -> b) ?
20:46:17 <calvinx> is there a reason why there’s a, b, c with two arrows and not just a, b with one arrow?
20:46:31 <shachaf> Because it takes two arguments, one of type a and one of type b.
20:46:53 <calvinx> ok
20:47:24 <shachaf> (In Haskell, that means that it takes one argument of type a, and returns a function that takes an argument of type b and returns a value of type c.
20:47:44 * hackagebot propellor 1.2.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-1.2.0 (JoeyHess)
20:48:01 <bryanedds> Cale, I'm going to try to remove the
20:48:08 <bryanedds> 'a' type and see if it still works
20:48:21 <bryanedds> I don't think I need the 'a' type after all
20:48:38 <bryanedds> (I can't see how it's useful in my scenario, anways)
20:48:40 <Cale> bryanedds: in that case you no longer have a monad, but perhaps you have something which is still useful :)
20:48:55 <calvinx> I see.  So for instance, “(+)” has a signature of  “a -> a -> a”
20:49:03 <bryanedds> yes, I think F#'s computation exprs also work for plain monoids as well
20:49:20 <calvinx> and (+) can be given to zipWith like “zipWith (+) [1,2] [3,4]"
20:49:50 <shachaf> Yes.
20:51:05 <calvinx> makes sense.
20:51:09 <calvinx> thanks shachaf.
20:52:15 <bryanedds> urgh, I don't know how to remove 'a' while preserving behavior
20:53:48 <bryanedds> Cale, should this change my implementation code, or just the types?
20:54:37 <shachaf> It'd hopefully change the implementation.
20:55:42 <bryanedds> hmm
20:57:05 <bryanedds> I can't figure out how
20:57:17 <shachaf> Is this Haskell or F#?
20:57:52 <AncientPC> I have cabal version v1.20 but the latest ghc-mod only supports cabal < 1.17 (https://hackage.haskell.org/package/ghc-mod)
20:58:11 <AncientPC> Is there no incentive to update the upper bound of the cabal requirement?
20:58:25 <bryanedds> I have a version in Haskell and in F#
20:58:26 <AncientPC> I can't be the only run who's having issues with ghc-mod, it's a pretty popular package...
20:59:26 <goglosh> Anyone care to point me to a decent tutorial on the library system for ghc?
21:00:28 <AncientPC> oh, it only uses newer cabal if ghc is relatively new: https://github.com/kazu-yamamoto/ghc-mod/blob/master/ghc-mod.cabal#L232
21:02:50 <goglosh> hum mine is 7.6
21:03:04 <goglosh> it's the one that comes with apt-get
21:03:34 <bryanedds> so let me ask this -
21:03:57 <bryanedds> The State monad is only concerned with one type s
21:04:07 <bryanedds> Why does it also have a type parameter 'a'?
21:05:25 <bryanedds> boiled down further, why does the State monad have two type parameters rather than one?
21:05:46 <bryanedds> er, type variables, however y'all say it
21:06:08 <HeladoDeBrownie> bryanedds, the a is the result of the state computation. State s a is equivalent to s -> (a, s)
21:06:23 <bryanedds> what is a state computation?
21:06:33 <HeladoDeBrownie> A function of the type I just mentioned
21:06:48 <bryanedds> yes, but what does it mean?
21:06:51 <dmj`> > flip runState 1 $ modify (+1)
21:06:52 <HeladoDeBrownie> Intuitively, s -> (a, s) takes in a beginning state and gives a result as well as an ending state
21:06:53 <lambdabot>  ((),2)
21:07:14 <HeladoDeBrownie> This can be composed with other such functions, threading the state through them all and either using or discarding the results
21:07:26 <HeladoDeBrownie> That's just what the Monad instance does
21:07:32 <bryanedds> so what is a used for, say, when it's not unit?
21:07:45 <srhb> bryanedds: Implementing the State monad is quite enlightening.
21:08:03 <HeladoDeBrownie> One semi-trivial example
21:08:05 <HeladoDeBrownie> @type get
21:08:06 <lambdabot> MonadState s m => m s
21:08:08 <HeladoDeBrownie> Wrong one
21:08:10 <HeladoDeBrownie> get :: State s s
21:08:21 <jmcarthur> bryanedds: State s a is a state transition that also gives an a with the new state. that's basically all there is to say. it's hard to say anything really deep about a type like. s -> (a, s)
21:08:23 <HeladoDeBrownie> That's equivalent to the function \x -> (x, x)
21:09:12 <bryanedds> ya, I am so lost without being able to assign some sort of meaning to 'a'
21:09:27 <HeladoDeBrownie> It's really general, there is no meaning but how you use it
21:09:39 <bryanedds> but my issue is, I don't seem to use it
21:09:50 <bryanedds> so do I try to take the type parameter out?
21:09:53 <HeladoDeBrownie> And that's fine. State s a is not a terribly useful type in many circumstances
21:10:00 <bryanedds> (at least, if I use it, I'm not aware of it)
21:10:23 <HeladoDeBrownie> If you take out the a, you no longer have a Monad, but you might have a type useful for other things with a different useful interface
21:10:30 <bryanedds> Can 'a' just be there for 'bookkeeping' reasons
21:10:38 <jmcarthur> bryanedds: if you take the a out of (State s a), you get (Endo s)
21:10:48 <jmcarthur> bryanedds: Endo lives in Data.Monoid
21:10:55 <bryanedds> HeladoDeBrownie: I try to remove a, but I can't make my implementation still work without it
21:12:22 <bryanedds> test
21:12:23 <dmj`> bryanedds: 'a' is necessary, since it creates the kind * -> *, to be a monad the kind of the type you need is * -> *
21:12:23 <HeladoDeBrownie> bryanedds, I think srhb had a good suggestion for understanding State, and also looking at what jmcarthur suggested could be interesting
21:13:05 <dmwit> bryanedds: You want to implement an interpreter for a language. You decide a good way would be to keep track of a mapping from variables to their values.
21:13:20 <dmwit> bryanedds: Eventually, you will produce some "answer" which is the value computed by the program you're interpreting.
21:13:41 <dmwit> bryanedds: In this setup, you have some state (a mapping from variables to values) and a result type you're interested in.
21:13:47 <dmwit> bryanedds: So there are two fundamental types involved.
21:14:15 <bryanedds> In my case, I don't seem to have a result type, just the state
21:14:24 <shachaf> > "blah \    \blue\    \ red -- \        \unread" -- lifter:
21:14:25 <dmwit> That's fine, and in some cases that happens.
21:14:26 <lambdabot>  "blah blue red -- unread"
21:14:48 <shachaf> lifter: You can have any sort of whitespace between the backslashes, spaces or newlines or whatever, and it'll get removed.
21:14:53 <lifter> shachaf: Oh yes to continue a string over line breaks?
21:14:56 <shachaf> So you can make multiline strings this way.
21:15:26 <bryanedds> so maybe it's okay to leave 'a' in this implementation - http://lpaste.net/116027
21:15:49 <lifter> shachaf: I'm not sure why you are pointing it out to me tho
21:15:56 <bryanedds> I just want to make sure that leaving it in doesn't make other things I might do with the type too complicated
21:16:12 <dmwit> I'm not sure what that's supposed to do.
21:16:17 <dmwit> But that returnM doesn't look well typed to me.
21:16:19 <lifter> anyhow, for anyone interested, I discovered a neat use of RebindableSyntax w/ the Formatting library: http://lpaste.net/116049
21:16:29 <jmcarthur> take the parameter out of Maybe and you get Bool. take the parameter out of State and you get Endo. take the parameter out of [] and you get natural numbers. take the parameter out of Writer and you get just the monoid itself. take the parameter out of Identity and you get ().
21:16:40 <shachaf> lifter: Oh, now I see what you were doing. I thought you were just concatenating the strings, not adding things in between.
21:16:50 <jmcarthur> usually, dropping that last type parameter from a monad gives you some sort of a monoid, although it's not *always* obvious what that monoid looks like
21:16:56 <lifter> shachaf: no just some tricks w/ rebinding (>>)
21:17:25 <lifter> for a "format" w/ lots of "% text %" or whatever, this is kinda nice
21:17:47 * hackagebot witherable 0.1.1 - Generalization of catMaybes  http://hackage.haskell.org/package/witherable-0.1.1 (FumiakiKinoshita)
21:18:29 <jmcarthur> bryanedds: another way to think of the type parameter is that it's the type of substitution points in your monad. that is, if you imagine your computation as forming some sort of syntax tree, the occurrences of values of that type are the places that bind will *substitute* into.
21:19:11 <bryanedds> that makes sense
21:19:54 <jmcarthur> in other words, it's a hole with some data
21:25:45 <bryanedds> ok, I guess I will leave it in for now as I don't know how to take it out
21:25:53 <bryanedds> or if I even could
21:25:55 <bryanedds> or should
21:39:05 <xuinkrbin> Given http://lpaste.net/116052, I run `haddock -o htest -v 3 fib.lhs` and receive `fib.lhs:18:7: Illegal literal in type (use DataKinds to enable): 0`. I do not understand what I am doing wrong.
21:49:35 <pavonia> xuinkrbin: {code} specifies parts of the source code, that is of your module, but you're using it for code usage examples
21:50:25 <xuinkrbin> pavonia: Curious I was told by bitemyapp to use `{code}`; what should I have used?
21:50:40 <pavonia> {spec}, IIRC
21:52:49 * hackagebot witherable 0.1.1.1 - Generalization of catMaybes  http://hackage.haskell.org/package/witherable-0.1.1.1 (FumiakiKinoshita)
21:53:11 <xuinkrbin> pavonia: That looks like it did the trick, thanks. I don't suppose there is a way to write the literate Haskell without using LaTeX, no?
21:54:02 <pavonia> I just read you can use < as well
21:55:19 <xuinkrbin> pavonia: Sweet! Where did You read this?
21:55:36 <pavonia> https://www.haskell.org/haskellwiki/Literate_programming#Hiding_code_from_Haskell
21:59:13 <zq> "I might get to intermediate level in a few years then. Good to know.
21:59:14 <zq> "
21:59:17 <zq> lol
21:59:28 <xuinkrbin> pavonia: Very nice, thanks. Shame it doesn't work with doctest but oh well.
22:03:15 <jfischoff> Is there a way to set the file lock status on a System.IO.Handle?
22:09:07 <glguy> jfischoff: Without using hClose?
22:09:25 <jfischoff> anyway
22:11:56 <srhb> jfischoff: I don't think handles even have a concept of locking.
22:12:32 <srhb> Locks are on files, not handles or file descriptors.
22:12:56 <glguy> Oh, I thought you meant in the runtime system
22:13:17 <jfischoff> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#g:8
22:14:01 <srhb> Yes, exactly.
22:14:03 <glguy> For that you just have to close the open handles on the file
22:15:01 <jfischoff> how do I set the file lock directly?
22:15:12 <jfischoff> if not with an fd or Handle?
22:15:21 <srhb> With a FilePath and a different package.
22:15:30 <jfischoff> which package?
22:15:33 <jfischoff> posix?
22:15:38 <jfischoff> unix I mean
22:15:45 <srhb> flock is portable, afaik.
22:15:59 <srhb> Wait, no
22:16:05 <srhb> filelock is.
22:16:27 <jfischoff> https://hackage.haskell.org/package/filelock-0.1.0.0
22:16:33 <srhb> Yeah, that one.
22:16:50 <jfischoff> I see, it include windows support
22:17:11 <jfischoff> thanks
22:17:45 <glguy> This is independent of the locking you linked to earlier
22:17:47 <jfischoff> oh wait
22:17:51 <jfischoff> it extends unix
22:18:06 <jfischoff> oh
22:18:17 <glguy> Either unix OR win32
22:18:32 <jfischoff> glguy: that is not based on file system locking?
22:18:43 <glguy> That's just the runtime system
22:18:45 <jfischoff> ah
22:18:46 <jfischoff> thanks
22:18:52 <glguy> afaik, at least
22:19:12 <srhb> Indeed.
22:19:13 <jfischoff> makes sense, handles are for things besides files
22:20:50 <glguy> I'm probably just guessing at this point (I've cracked open the ghc sources... trying to track it down)
22:22:08 <glguy> the actual locking stuff seems to be in ghc/rts/FileLock.c : lockFile()
22:24:02 <glguy> It doesn't appear to do anything to the OS, just manages a hashtable
22:24:14 <jfischoff> thanks
22:47:28 <zq> :t \f v xs -> foldr (flip f) v (reverse xs)
22:47:29 <lambdabot> (b -> a -> b) -> b -> [a] -> b
22:47:30 <zq> @pl \f v xs -> foldr (flip f) v (reverse xs)
22:47:30 <lambdabot> flip flip reverse . ((.) .) . foldr . flip
22:47:35 <zq> aww shame on you
22:47:42 <zq> :t \f v xs -> foldr (flip f) v (reverse xs)
22:47:43 <lambdabot> (b -> a -> b) -> b -> [a] -> b
22:47:45 <zq> :t foldl
22:47:46 <lambdabot> (b -> a -> b) -> b -> [a] -> b
22:47:48 <wei2912> challenge for everyone
22:47:54 <wei2912> can you make @pl produce (.) (.)?
22:50:16 <isd> Hey all. I've got a (lazy ByteString) that I want to format in hexidecimal. There must be a handy function somewhere that just does this, but I'm not finding it -- any pointers?
22:50:36 <isd> (err, that was indented to be (lazy) ByteString...)
22:52:52 * hackagebot language-python 0.4.1 - Parsing and pretty printing of Python code.  http://hackage.haskell.org/package/language-python-0.4.1 (BerniePope)
22:53:04 <glguy> isd: This might be close enough http://hackage.haskell.org/package/pretty-hex-1.0/docs/Hexdump.html
22:53:55 <isd> No, this needs to be just the digits; it's for machine consumption
22:54:30 <zq> isd: you mean the equivalent of %02X-ing your way through the bytestring?
22:54:38 <isd> yeah.
22:55:00 <zq> base16-bytestring
22:55:13 <zq> isd: das: https://hackage.haskell.org/package/base16-bytestring
22:55:42 <isd> zq: perfect, thanks.
22:57:52 * hackagebot react-haskell 1.2.0.0 - Haskell React bindings  http://hackage.haskell.org/package/react-haskell-1.2.0.0 (joelb)
23:10:15 <pecanpy> anyone here use eclipsefp? i just installed it and am not getting any syntax highlighting. when i go to the prefs, it shows the colors chosen for each category, its just not using them.
23:16:08 <KangaAkale> is it possible to insert into sqllite database from a subquery
23:16:39 <KangaAkale> I mean Sqlite
23:18:11 <pecanpy> seems like its having problems installing the build wrapper. im getting the message: "cabal.exe: The following packages are likely to be broken by the reinstalls:" followed by a list of a bunch of packages. Is there a way to install without breaking anything?
23:20:14 <pikitgbhs> Hello buddys. I have a question, how i can read two numbers from IO and add(+) them. http://lpaste.net/116056 i need set the v1 v2 variables similar to global variables or something ? thanks
23:21:52 <Peaker> pikitgbhs: just put your "let c = .." in the right scope, where v1 and v2 exist
23:22:04 <KangaAkale> like this INSERT INTO TABLEA (idm) select id from TABLEB
23:22:15 <Peaker> pikitgbhs: also, add v1 v2  is the right syntax,  add (v1 v2)  is wrong: It says: "Apply v1 function with v2 arg, and feed that to 'add'"
23:22:38 <pikitgbhs> Peaker: oh thanks dude
23:22:47 <pikitgbhs> let me see
23:24:42 <KangaAkale> hello
23:25:20 <KangaAkale> please i will like to find out if i can insert into a table using a subquery ex: INSERT INTO TABLEA (idm) select id from TABLEB
23:25:41 <KangaAkale> is this possible in haskell sqlitedb
23:26:48 <pecanpy> pikitgbhs: let f = fmap (read :: (String -> Float)) getLine    followed by: do { a <- f; b <- f; return (a + b) }
23:27:02 <pavonia> KangaAkale: Is this already the corrct SQL syntax?
23:27:20 <KangaAkale> no
23:27:27 <KangaAkale> it is just a sample
23:27:37 <pikitgbhs> Peaker: Thanks man works now. But i move the add function to the top level file, Haskell don't recognize the Add Function somewhere in the file ? this is the current code: http://lpaste.net/116058
23:27:53 * hackagebot elevator 0.1.3 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1.3 (FumiakiKinoshita)
23:27:55 <pavonia> KangaAkale: The try with the correct syntax?
23:28:14 <KangaAkale> pavonia: but i guess it should look like that
23:28:18 <pikitgbhs> pecanpy: Thanks ;) i'm just in my baby steps
23:28:45 <KangaAkale> pavonia: ok, i will try and give u a feedback
23:30:10 <pecanpy> pikitgbhs: yw :)
23:36:43 <Peaker> I'm trying to profile why "./Setup build" takes full seconds to decide to do nothing
23:37:07 <Peaker> but the profile output, even when "Cabal" library is compiled with -auto-all -caf-all -- is that "main" takes 100% cpu, end of story :(
23:37:29 <Peaker> I guess maybe it's using the installed "Cabal" rather than the one I just built. I should reinstall it, probably
23:37:54 * hackagebot cheapskate 0.1.0.2 - Experimental markdown processor.  http://hackage.haskell.org/package/cheapskate-0.1.0.2 (JohnMacFarlane)
23:40:07 <Peaker> If "cabal build" was fast, and "ghc -fno-code" was usable on the entire project (generated intermediate files good enough for type checking), my Haskell development cycle would be so much more efficient!
