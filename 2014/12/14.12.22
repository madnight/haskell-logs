00:00:04 <ReinH> sets are not categories, so sets A and B do not have a homset{A,B}
00:00:37 <ReinH> or rather, homsets are collections of morphisms in a category
00:03:11 <ReinH> I suppose you mean that A and B are objects in Set
00:09:58 <RayNbow`TU> hmm, is there a specific term for the property f(a*b) = f b * f a?
00:10:28 <ReinH> RayNbow`TU: depends on what * is
00:10:56 <ReinH> RayNbow`TU: you might say that f distributes over *. It might be some sort of homomorphism.
00:10:58 <RayNbow`TU> ReinH: well, an example would be f=reverse and (*)=(++)
00:11:12 <ReinH> ahhh
00:11:19 <ReinH> f(a*b) = f b * f a, not f a * f b
00:11:29 <RayNbow`TU> I'm just looking for how this property is called, if there's any term like that
00:11:49 <RayNbow`TU> ReinH: I did type that, didn't I?
00:11:55 <ReinH> RayNbow`TU: Yes, and I misread it.
00:13:07 <ReinH> It reminds of a basic theorem from group theory -- (a*b)^-1 = b^-1 * a^-1 -- but I'm not sure if it has a name.
00:16:45 <RayNbow`TU> ReinH: hmm, thanks, at least I have some more info to continue my search :)
01:04:08 * hackagebot sai-shape-syb 0.3.3 - Obtain homogeneous values from arbitrary values, transforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.3.3 (AndrewSeniuk)
01:04:10 * hackagebot deepseq-bounded 0.5.5 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.5.5 (AndrewSeniuk)
01:04:12 * hackagebot seqaid 0.1.7.0 - Dynamic strictness control, including space leak repair  http://hackage.haskell.org/package/seqaid-0.1.7.0 (AndrewSeniuk)
01:04:14 * hackagebot leaky 0.1.7.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.1.7.0 (AndrewSeniuk)
01:14:08 * hackagebot stackage 0.2.1.3 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.2.1.3 (MichaelSnoyman)
01:22:19 <zhulikas> sup fellas
01:54:10 * hackagebot cassava 0.4.2.1 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.2.1 (JohanTibell)
02:13:26 <jle`> it also reminds me of linearity of * is addition
02:14:15 <jle`> oh nvm, the correction
02:15:05 <jle`> in terms of matrices, (A B)' = B' A'
02:15:07 <jle`> ' being transposition
02:31:19 * eazar001 coughs
02:59:12 * hackagebot containers 0.5.6.2 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.6.2 (MilanStraka)
03:08:14 <Flonk> Is there a particular reason why `Data.Monoid` resides in `Data` but `Control.Applicative` is in `Control`?
03:08:37 <tdammers> historic
03:08:48 <merijn> Flonk: Hysterical raisins >.>
03:08:59 <Flonk> tdammers, merijn: Okay, I figured
03:09:00 <tdammers> Data. and Control. is pretty much an arbitrary distinction
03:09:00 <merijn> The whole Control/Data distinction is rather silly, tbh
03:09:04 <bennofs> Flonk: In general, the separation between Control/Data is not that clear
03:09:20 <merijn> I advocate avoiding it for new libraries, except for backwards compatibility reasons
03:09:42 <tdammers> I'd even argue that part of the point of Haskell, or FP in general, is to get rid of the duality between data structures and functions
03:09:58 <merijn> I disagree
03:10:13 <merijn> data structures and functions are clearly different, even though they're both VALUES
03:10:26 <merijn> I prefer the term "value oriented programming" over functional :p
03:10:35 <tdammers> haha well ok
03:10:49 <Cale> Data. and Control. are both pretty silly prefixes
03:11:05 <tdammers> my philosophy is that a function (in the pure FP sense) is a special kind of data structure
03:11:05 <merijn> tdammers: pretending there's no difference between data structures and functions reeks of "everything's a function"
03:11:06 <Cale> We might as well have made it Miscellaneous.
03:11:20 <merijn> Cale: We have that, it's called ACME ;)
03:11:20 <dfeuer> merijn, in https://gist.github.com/merijn/c01405e6c5a78a1c4ccb "simplicities'" should be "simplicity's".
03:11:55 <merijn> dfeuer: Pull requests welcome? :p
03:11:58 <dfeuer> Cale, Bertram simplified my <*> code some, and it's now been merged into containers master.
03:12:22 <dfeuer> merijn, that seems a bit of a bother for one word.
03:12:32 <merijn> dfeuer: I'll fix it
03:13:08 <tdammers> we've seen one-word pull requests trigger fireworks of e-mutilation before
03:14:08 <tdammers> "pull request: change 'he' to 'they' in comment" -> "rejected: minor change, not enough for a pull request" -> "you're sexist" ->  (shenanigans ensue) -> (everyone gets fired)
03:39:14 * hackagebot async 2.0.2 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.2 (SimonMarlow)
04:13:19 <evincar> Would anyone here be interested in podcast versions of famous CS papers?
04:15:17 <evincar> For highly technical papers it wouldn't make much sense, because the notation would be lost.
04:15:26 <evincar> But for conceptual papers, it might be an easier format to consume.
04:16:13 <alpounet> evincar: if you add some value, yeah. like commenting/explaining along
04:16:48 <frawgie_> evincar: do you have any examples of papers that could be presented? :)
04:16:49 <alpounet> unless the paper does it really well all by itself
04:17:39 <evincar> alpounet: That's sort of what I was thinking. Taking a paper and reading it with commentary.
04:19:13 <frawgie_> evincar: what about making it a screen cast instead?
04:19:45 <evincar> frawgie_: I'm not ready to commit to specific papers, really.
04:19:55 <evincar> I'm just reading through various early FP papers
04:19:59 <evincar> and thinking about how they contain a lot of valuable information, but they're not very accessible.
04:20:13 <alpounet> evincar: i know that jekor's "code deconstructed" screencasts have been very successful
04:20:31 <alpounet> so if you do something "similar" for papers, yeah, that'd definitely be appreciated by the community I think
04:20:36 <evincar> A screencast could definitely work. Particularly for highlighting and explaining notations.
04:20:40 <alpounet> yeah
04:20:44 <alpounet> and you could show some types
04:20:49 <alpounet> or definitions
04:20:50 <alpounet> and what not
04:20:59 <evincar> Because a lot of papers consist of constructing a system, then conducting some proofs in that system.
04:21:09 <evincar> And the proofs are algorithms.
04:21:32 <evincar> Like, define a program logic in which you can prove useful properties of programs.
04:21:36 <alpounet> yeah, being able to display code, extracts, pictures/diagrams and things like that is a big + IMO
04:21:44 <evincar> (E.g., doesn't crash under such-and-such circumstances.)
04:22:00 <evincar> Then show that the logic admits an efficient algorithm for checking/inferring those properties.
04:22:07 <alpounet> bah that's a much heavier job to do
04:22:45 <evincar> Hmm? Videos are heavier than podcasts, you mean?
04:22:54 <frawgie_> probably, yea
04:23:10 <frawgie_> otoh, one show per month can be enough if the content is good :)
04:23:15 <alpounet> evincar: no, i mean it's more work
04:23:42 <evincar> I don't mind doing videos. I used to vlog.
04:23:45 <evincar> It is definitely more work, but also more rewarding.
04:23:48 <evincar> And probably more valuable.
04:25:48 <evincar> Thing is, you can consume audio concurrently with something else.
04:26:08 <evincar> It's easy to put on a podcast and idly tune in and out while doing other things.
04:26:58 <evincar> Whereas a video demands more attention.
04:27:19 <frawgie_> but can you really consume information about technical papers in parallell to something else? i know i can't. but maybe im just slow
04:27:47 <evincar> Again, depends on the nature of the paper.
04:28:11 <evincar> If it's more conceptual, or about CS psychology, then it requires less focus because the material is less dense.
04:28:31 <frawgie_> yup, thats why i asked for some example.
04:28:56 <frawgie_> anyway, it's worth trying.
04:31:56 <evincar> frawgie_: "Why Functional Programming Matters" and "Can Programming be Liberated from the Von Neumann Style?"
04:32:05 <evincar> would be two of my favourites on the notation-heavy side.
04:32:38 <evincar> Those would probably be better in video format.
04:33:53 <evincar> Also "A Theory of Type Polymorphism in Programming".
04:35:31 <frawgie_> evincar: yep, i suppose you can pick either way and see what people say
04:35:47 <frawgie_> i never heard about a podcast/screencast like it so there is a void to fill
04:39:40 <evincar> frawgie_: Exactly, if we can make these classic papers more accessible, then they can be useful to more people.
04:44:44 <Heather> hi
04:45:04 <Heather> cabal install stuck in configurating Cabal
04:45:07 <Heather> on windows
04:45:28 <batchm> in parsec is there something like manyTill that leaves the "Till" part unconsumed?
04:46:10 <Heather> last node I can see in cabal log is : [60 of 76] Compiling Distribution.Simple.GHC ( C:\Users\PUKHLI~1\AppData\Local\Temp\Cabal-1.2
04:46:55 <Heather> strange but I never met such problem before
04:46:59 <merijn> batchm: You only need "manyTill" if Till overlaps with your "many" parser, no?
04:47:16 <batchm> yes. and it does
04:47:20 <merijn> Ah
04:47:44 <merijn> Might have to handwrite it, then
04:48:00 <merijn> at least, I'm not immediately aware of any combinator that does what you want
04:48:47 <batchm> maybe something like this? if I do x <- anyChar; lookAhead (string "<stop>"). will x consume until "<stop>" ?
04:48:59 <batchm> and stop at it
04:49:17 * hackagebot digestive-functors 0.7.1.2 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.2 (JasperVanDerJeugt)
04:49:24 <batchm> x <- many anyChar
04:49:27 <merijn> batchm: That doesn't repeat, you need to make it recursive
04:49:41 <merijn> batchm: I recommend looking at the source of manyTill and changing that a little
04:50:12 <batchm> ok. by the way is there something like parse that lets me see what is left unconsumed?
04:52:08 <merijn> Probably, but it's been awhile since i used parsec
04:52:14 <batchm> yeah this did not work.. "expecting stop".   parse (do x <- many anyChar; lookAhead (string "<stop>"); return x) "{source}" "consume all of this<stop>"
04:52:33 <batchm> what do you use?
04:53:13 <merijn> I've mostly been dealing with binary protocols, so binary and/or attoparsec
04:53:26 <Chathurga> I'm not sure what you mean by "see", would doing anything with that data not just be parsing it?
04:53:40 <Chathurga> Oh sorry for partial parsing or something
04:53:44 <merijn> Chathurga: To test his parser, presumably
04:53:55 <merijn> Chathurga: like "did this consume what I expected?"
04:54:01 <Chathurga> You just many anyChar I suppose
04:54:11 <Chathurga> *You could use, brain fart
04:54:12 <maukem> many (notFollowedBy (string "<stop>") >> anyChar)
04:54:14 <batchm> yes I am a bit lost at how much is being consumed.
04:54:25 <batchm> maukem that looks good..
04:54:46 <maukem> (?:(?!<stop>).)*
04:57:22 <batchm> that worked.. great
05:03:06 <Heather> issue with updating cabal on windows : http://stackoverflow.com/questions/27603255/cabal-instulls-stucks-during-installing-cabal
05:07:17 <vamega> Hi, I'm trying to understand whether a recrusive I wrote function will get optimized to a loop, or if it will do a lot of stack allocation.
05:07:54 <slomo> http://lpaste.net/117000  why is the additional pattern match or extraction necessary here? and can it be written different than with the pattern match to unwrap the Maybe directly?
05:08:25 <vamega> The function is basically f x = liftA2 (:) val (f (x `div` 2))
05:08:39 <vamega> I hope that didn't come out as a smiley face to everyone looking at it.
05:08:55 <vamega> The function is basically f x = liftA2 ( : ) val (f (x `div` 2))
05:10:38 <batchm> is there something like this in parsec? tryParser :: ParsecT s u m a -> ParsecT s u m (Maybe a)
05:14:26 <batchm> there is "try :: ParsecT s u m a -> ParsecT s u m a", but I have no way to check if parsing succeeded or not
05:15:47 <maukem> batchm: optionMaybe?
05:24:19 * hackagebot hledger-diff 0.2.0.1 - Compares the transactions in two ledger files.  http://hackage.haskell.org/package/hledger-diff-0.2.0.1 (gebner)
05:24:22 <zipper> Can anyone help me with the following functions? I can't seem to make them work in the repl.
05:24:24 <batchm> that looks like it should work but it doesn't. perhaps I am using it wrong.
05:24:29 <batchm> I'll paste what I have
05:24:32 <zipper> readMaybe "we"
05:24:38 <zipper> > readMaybe "we"
05:24:40 <lambdabot>  Not in scope: ‘readMaybe’
05:24:51 <maukem>  Nothing
05:25:00 <zipper> readMaybe and stripPrefix
05:25:04 <batchm> I am parsing a very messy text file that contains questions and answers
05:25:18 <zipper> maukem: Why so? I'd expect it to give me a Just "we"
05:25:26 <maukem> zipper: why?!
05:25:58 <zipper> maukem: I can't find it in hoogle and I don't see what it's for. I assume it wraps a string with a maybe
05:26:13 <maukem> no, that would be Just
05:26:29 <maukem> zipper: http://hayoo.fh-wedel.de/?query=readMaybe
05:27:29 <magicman> batchm: `optionMaybe p` will only return `Nothing` when running `p` does not consume any input. I'm guessing it's implemented as `fmap Just p <|> pure Nothing`.
05:27:42 <danilo2> Hello! I've got here a funny, small example, where I try to use unsafecoerce to convert a type to more general, but I got compilation error here. Would somebody be so nice and take a look at it? I want to do it because I want to create a "pass manager" - user defined list of functions, that process data parametrized with different types. Here is the code: http://lpaste.net/117002
05:27:47 <zipper> maukem: Example usage that yields a Maybe String
05:28:02 <maukem> zipper: readMaybe "" :: Maybe String
05:28:10 <magicman> batchm: `fmap Just (try p) <|> pure Nothing` may work?
05:28:23 <maukem> magicman: optionMaybe (try p)?
05:28:48 <batchm> here is what I have. I am using optionMaybe on line 24, so I suspect this is where the problem lies. http://lpaste.net/117003
05:28:55 <magicman> maukem: Aye!
05:29:42 <batchm> magicman it does not have any effect. i get the same error if I don't use optionMaybe
05:29:49 <zipper> maukem: That gives me nothing a few warnings in the repl
05:30:09 <maukem> zipper: what?
05:30:09 <zipper> maukem: Basically every string gives me warnings regarding the type
05:30:14 <maukem> what warning?
05:30:46 <zipper> Defaulting the following constraint(s) to type ‘()’
05:30:57 <zipper> (Show a0) arising from a use of ‘print’ at <interactive>:7:1-12
05:31:08 <zipper> (Show a0) arising from a use of ‘print’ at <interactive>:7:1-12
05:31:12 <batchm> oh wow, I deleted   lookAhead (ordinalNumber (n+1)) that I left by accident and now it works
05:31:18 <maukem> zipper: for what code?
05:31:29 <zipper> maukem: readMaybe ""
05:31:36 <maukem> zipper: that's not what I gave you
05:31:45 <zipper> How do I load a module in lambdabot
05:31:50 <maukem> import Foo
05:31:55 <maukem> er
05:32:08 <zipper> > import Text.Read
05:32:09 <lambdabot>  <hint>:1:1: parse error on input ‘import’
05:32:11 <batchm> so if you have any comments on how to make the code cleaner please do tell. thanks for help by the way, maukem, magicman
05:32:16 <maukem> > readMaybe
05:32:18 <lambdabot>  Not in scope: ‘readMaybe’
05:32:38 <maukem> > readMaybe
05:32:39 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:32:39 <lambdabot>    arising from a use of ‘M152119487845912593625580.show_M1521194878459125936...
05:32:39 <lambdabot>  The type variable ‘a0’ is ambiguous
05:32:42 <maukem> there we go
05:32:50 <maukem> > readMaybe "" :: Maybe String
05:32:51 <lambdabot>  Nothing
05:33:37 <BoR0> what's an easy web framework to start with that has some kind of session mechanism? I checked at both happstack and snap but they don't have enough examples according to google. what's the standard one to use for production?
05:33:44 <zipper> maukem: how will it give me a Just "string" ? even when I use a non empty string it still gives me nothing
05:35:18 <danilo2> Hello! I've got here a funny, small example, where I try to use unsafecoerce to convert a type to more general, but I got compilation error here. Would somebody be so nice and take a look at it? I want to do it because I want to create a "pass manager" - user defined list of functions, that process data parametrized with different types. Here is the code: http://lpaste.net/117002
05:36:20 <gspr> May the runtime migrate an FFI call between threads *while* it is running? I know that two consecutive FFI calls can happen on different threads...
05:43:07 <lmm> is there any way to get ghc to tell me what the link flags (e.g. package libraries) should be, so that I can link my haskell .o files using gcc?
05:44:09 <jkarni1> > readMaybe "\"\"" :: Maybe String
05:44:10 <lambdabot>  Just ""
05:44:20 * hackagebot monad-journal 0.6.0.2 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.6.0.2 (DimitriSabadie)
05:44:23 <jkarni1> maukem: ^^^
05:44:52 <merijn> gspr: No, because that doesn;t make sense
05:46:16 <merijn> lmm: Why exactly are you trying to do that?
05:46:19 <gspr> merijn: Thanks. I suspected as much... so it should be safe to use thread-local storage *during* the call, right? I mean, if its state at the beginning of the call is not relied upon, and its state at the end of the call is irrelevant.
05:46:29 <merijn> gspr: Yeah
05:46:47 <gspr> Hmm, now that I spelled that out, it's pretty obvious. Otherwise you couldn't really do anything :)
05:46:50 <gspr> thanks :)
05:46:52 <merijn> gspr: btw, it's possible to force a haskell thread to ALWAYS execute on the same OS thread (for TLS, for example)
05:47:01 <merijn> See forkOS
05:47:21 <gspr> merijn: Right, I know, but I won't need to :)
05:48:23 <lmm> merijn: trying to link some haskell code to another language that can call into C, via the C FFI. Other language wants to build in its own way, but is happy to be passed object files and libraries
05:49:05 <merijn> lmm: You probably want to either have GHC link your C code (probably easier) or just create a library of your haskell code and link that?
05:49:51 <merijn> lmm: I have a minimal example of how to call haskell from a C main function here, maybe that's helpful? https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
05:49:52 <lmm> merijn: it's not actually C, I tried doing it that way and that was harder. Library approach might work, how do I do that?
05:50:08 * lmm discovers -staticlib, then discovers it only works on a mac :/
05:51:05 <lmm> merijn: I've already looked at something like that, it was helpful, but I can't find any examples that don't use ghc for linking
05:52:54 <merijn> lmm: http://www.vex.net/~trebla/haskell/so.xhtml
05:54:31 <merijn> lmm: And then just skip the step that links the so into C code instead of whatever you want to link against
05:56:52 * lmm tries
05:59:20 * hackagebot swish 0.9.1.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.1.1 (DouglasBurke)
06:00:00 <lmm> merijn: Might be other things I'm doing, but I'm getting errors like /usr/lib64/ghc-7.8.3/unix-2.7.0.1/libHSunix-2.7.0.1-ghc7.8.3.so: undefined reference to `nocldstop'
06:00:22 <lmm> which is progress from where I was, but seems to suggest I'm still missing some link flags?
06:05:10 <athan> Does anyone have a simple example of making a custom Gen value for QuickCheck?
06:06:56 <mikeplus64> hm... is there a devious way to get ghc to "rewrite" a term into a compile-time error?
06:07:31 <batchm> @hoogle Either a b -> b
06:07:34 <lambdabot> Data.Either rights :: [Either a b] -> [b]
06:07:34 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
06:07:34 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
06:07:41 <batchm> no fromRight?
06:09:16 <bergmark> batchm: that would be partial, you can use `either' to get `Either a b -> Maybe b' instead
06:09:30 <maukem> :t \(Right x) -> x
06:09:31 <lambdabot> Either t t1 -> t1
06:09:33 <batchm> I want it partial
06:09:55 <exio4> :t \(Left x) -> Right x
06:09:56 <lambdabot> Either b t -> Either a b
06:10:12 <maukem> :t either (error "this ain't right") id
06:10:13 <lambdabot> Either a c -> c
06:10:28 <mikeplus64> > let fromRight = foldMap Just in (fromRight (Left "asdf"), fromRight (Right "fdsa"))
06:10:29 <lambdabot>  (Nothing,Just "fdsa")
06:11:05 <batchm> I know.. just slightly annoyed that we have fromJust but no fromRight
06:11:55 <batchm> mikeplus not sure what's that.. heh
06:12:29 <maukem> fromJust shouldn't exist either
06:12:50 <bergmark> i'm very annoyed that we have fromJust :-)
06:12:55 <batchm> why not?
06:12:57 <batchm> why?
06:13:21 <bergmark> because it's partial and will crash your program
06:13:26 <mikeplus64> batchm: it's using Foldable's foldMap :: (Foldable f, Monoid m) => (a -> m) -> f a -> m
06:13:36 <mikeplus64> probably abusing rather :)
06:14:08 <batchm> it is your own fault if you call fromJust when you aren't sure that you have a value, or when you care not to carsh
06:14:33 <bergmark> batchm: better to let the typechecker verify that for you
06:15:04 <batchm> bergmark it already does do that, when it yells "You're using Maybe a as a". and you use fromJust when you want to shut it up
06:15:28 <batchm> at that point you're taking responsibility that it really contains a value
06:15:34 <bergmark> batchm: if you just have a Maybe a you have not verified that it contains a value
06:16:20 <batchm> bergmark that depends on the code
06:17:02 <batchm> and sometimes you don't care if you crash (like when trying things out in repl)
06:17:51 <sivteck> fromMaybe
06:18:28 <sivteck> > fromMaybe "You are worth Nothing" Nothing
06:18:30 <lambdabot>  "You are worth Nothing"
06:19:17 <mikeplus64> batchm: remember you can pattern match as well, e.g. "Just a <- thing" or "let Just a = thing"
06:19:26 <mikeplus64> Right a <- thing
06:22:17 <batchm> I know, but I prefer to have a long chain of functions when testing in the repl, so I can easily repeat the call in a single command after compiling.. anyway it is not a big deal, it is a one liner to define it
06:22:28 <batchm> after recompiling*
06:23:49 <sivteck> > either id id (Right "woah") -- (not sure whether thats helpful)
06:23:50 <lambdabot>  "woah"
06:25:15 <zwer> > either id id (Left "woah")
06:25:17 <lambdabot>  "woah"
06:25:41 <zwer> not sure if that is desired
06:25:58 <hodapp> ahh, now I am stuck with the age-old problem of "how do I represent printf sanely in Haskell?"
06:26:04 <hodapp> sort of, since I'm writing for Ivory
06:26:18 <sivteck> > either (cont "I am hungry") id (Left "woah")
06:26:20 <lambdabot>  Couldn't match type ‘Control.Monad.Trans.Cont.ContT
06:26:20 <lambdabot>                         r0 Data.Functor.Identity.Identity a0’
06:26:20 <lambdabot>                with ‘[GHC.Types.Char] -> c’
06:26:27 <sivteck> oops s/cont/const
06:26:54 <hodapp> I need to grok continuations a bit better.
06:27:04 <maukem> $(printf "hi %s") "world"
06:27:23 <hodapp> maukem: it has to model it in such a manner that Ivory's call mechanism can grok it
06:27:33 <maukem> but I don't know Ivory
06:28:37 <maukem> wait, Ivory is a library?
06:28:41 <hodapp> yes
06:29:08 <hodapp> so it's not Haskell calling printf, it's Haskell representing a call to printf which Ivory will translate somehow
06:30:22 <hodapp> luckily I was able to do... printf2 :: IvoryType s => Def ('[IString,s] :-> Sint32)
06:30:31 <hodapp> for 2-argument printf
06:43:59 <trap_exit> hmm
06:44:01 <trap_exit> living in a city
06:44:04 <trap_exit> garbage not being collected
06:44:07 <trap_exit> this is going to be 'fun'
06:47:01 <Javran> :t _3
06:47:02 <lambdabot> (Field3 s t a b, Functor f) => (a -> f b) -> s -> f t
06:49:22 * hackagebot digestive-functors 0.7.1.3 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.3 (JasperVanDerJeugt)
06:54:08 <Javran> :t view _3
06:54:09 <lambdabot> (Field3 s s a a, MonadReader s m) => m a
07:09:23 * hackagebot amazonka-core 0.1.1 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.1.1 (BrendanHay)
07:09:25 * hackagebot amazonka 0.1.1 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.1.1 (BrendanHay)
07:09:27 * hackagebot amazonka-autoscaling 0.1.1 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.1.1 (BrendanHay)
07:09:29 * hackagebot amazonka-cloudformation 0.1.1 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.1.1 (BrendanHay)
07:09:31 * hackagebot amazonka-cloudfront 0.1.1 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.1.1 (BrendanHay)
07:14:33 * hackagebot amazonka-cloudsearch 0.1.1 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.1.1 (BrendanHay)
07:14:36 * hackagebot amazonka-cloudsearch-domains 0.1.1 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.1.1 (BrendanHay)
07:14:38 * hackagebot amazonka-cloudtrail 0.1.1 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.1.1 (BrendanHay)
07:14:40 * hackagebot amazonka-cloudwatch 0.1.1 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.1.1 (BrendanHay)
07:14:42 * hackagebot amazonka-cloudwatch-logs 0.1.1 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.1.1 (BrendanHay)
07:19:44 * hackagebot amazonka-codedeploy 0.1.1 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.1.1 (BrendanHay)
07:19:46 * hackagebot amazonka-cognito-identity 0.1.1 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.1.1 (BrendanHay)
07:19:48 * hackagebot amazonka-cognito-sync 0.1.1 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.1.1 (BrendanHay)
07:19:50 * hackagebot amazonka-elb 0.1.1 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.1.1 (BrendanHay)
07:19:52 * hackagebot amazonka-emr 0.1.1 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.1.1 (BrendanHay)
07:24:54 * hackagebot amazonka-iam 0.1.1 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.1.1 (BrendanHay)
07:24:56 * hackagebot amazonka-importexport 0.1.1 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.1.1 (BrendanHay)
07:24:58 * hackagebot amazonka-kinesis 0.1.1 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.1.1 (BrendanHay)
07:25:00 * hackagebot amazonka-kms 0.1.1 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.1.1 (BrendanHay)
07:25:02 * hackagebot amazonka-lambda 0.1.1 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.1.1 (BrendanHay)
07:28:56 <witt3rd> hi - i'm trying to cabal install ghc-mod on OSX and it is failing to compile. http://lpaste.net/117013
07:30:04 * hackagebot amazonka-opsworks 0.1.1 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.1.1 (BrendanHay)
07:30:06 * hackagebot amazonka-rds 0.1.1 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.1.1 (BrendanHay)
07:30:08 * hackagebot amazonka-redshift 0.1.1 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.1.1 (BrendanHay)
07:30:10 * hackagebot amazonka-route53 0.1.1 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.1.1 (BrendanHay)
07:30:12 * hackagebot amazonka-route53-domains 0.1.1 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.1.1 (BrendanHay)
07:33:05 <ChristianS> uh oh, hackagebot spam...
07:33:21 <maukem> oh hay
07:33:43 <wei2912> ChristianS: time to shout at BrendanHay
07:33:55 <barrucadu> That's a lot of Amazon
07:35:14 * hackagebot amazonka-s3 0.1.1 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.1.1 (BrendanHay)
07:35:16 * hackagebot amazonka-sdb 0.1.1 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.1.1 (BrendanHay)
07:35:18 * hackagebot amazonka-ses 0.1.1 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.1.1 (BrendanHay)
07:35:20 * hackagebot amazonka-sns 0.1.1 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.1.1 (BrendanHay)
07:35:22 * hackagebot amazonka-sqs 0.1.1 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.1.1 (BrendanHay)
07:38:41 <witt3rd> Seems like i'm hitting this (https://github.com/phaazon/monad-journal/issues/12) issue but for ghc-mod.
07:40:24 * hackagebot amazonka-storagegateway 0.1.1 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.1.1 (BrendanHay)
07:40:26 * hackagebot amazonka-sts 0.1.1 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.1.1 (BrendanHay)
07:40:28 * hackagebot amazonka-support 0.1.1 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.1.1 (BrendanHay)
07:40:30 * hackagebot amazonka-swf 0.1.1 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.1.1 (BrendanHay)
07:40:32 * hackagebot urlpath 0.2 - Painfully simple URL writing combinators  http://hackage.haskell.org/package/urlpath-0.2 (athanclark)
07:49:25 * hackagebot rest-client 0.4.0.2 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4.0.2 (ErikHesselink)
07:49:27 * hackagebot rest-example 0.1.2.1 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.2.1 (ErikHesselink)
07:56:08 <SuperHotFire> I'm trying to create some lines of code which basically return the extention of a file name, why doesn't it work?
07:56:16 <SuperHotFire> extension :: String -> String
07:56:16 <SuperHotFire> extension a = '.' : reverse (takeWhile(/='.') reverse a)
07:56:28 <maukem> takeWhile only takes 2 args
07:56:37 <maukem> you're giving it 3: (/= '.'), reverse, a
07:57:07 <SuperHotFire> Oh, ok. The thing is I have complete this task only using two arguments.
07:57:17 <maukem> ???
07:57:35 <SuperHotFire> String -> String.
07:57:51 <maukem> I don't understand what you're trying to tell me
07:58:11 <Chathurga> SuperHotFire: (reverse a)
07:58:19 <SuperHotFire> Really?..
07:58:39 <Chathurga> Function application has priority
07:59:18 <Chathurga> it'll always try to apply arguments when it can, it looks like reverse is the 3rd arg and a is the 4th. You want (reverse a) as the 3rd arg
07:59:45 <maukem> 2nd
07:59:59 <Chathurga> Sorry yeah, take 1 from each of those
08:00:08 <maukem> "function application has priority" is insufficient because this is an apply/apply conflict
08:00:20 <maukem> the important bit is that it's left associative
08:00:30 <SuperHotFire> Thanks a lot. :)
08:00:31 <maukem> a b c parses as ((a b) c), not (a (b c))
08:01:10 <maukem> similarly, 'takeWhile (/= '.') reverse a' parses as '((takeWhile (/= '.')) reverse) a'
08:02:35 <SuperHotFire> Well, now you seem to know what's going on.. -.-
08:04:58 <thomie> SuperHotFire: use System.FilePath.takeExtension, it handles edge cases better
08:05:31 <SuperHotFire> Thanks a lot, but I have no idea what you're talking about. (newbie)
08:06:16 <thomie> SuperHotFire: see http://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath-Windows.html#v:takeExtension
08:06:52 <SuperHotFire> Hmm, well. The catch with this was to use String -> String.
08:07:07 <SuperHotFire> With a already predefined "function :: String -> String"
08:07:08 <SuperHotFire> :P
08:07:13 <SuperHotFire> Thanks anyways.
08:07:19 <maukem> type FilePath = String
08:07:34 <maukem> > takeExtension ".emacs"
08:07:35 <lambdabot>  Not in scope: ‘takeExtension’
08:07:43 <maukem> @let import System.FilePath
08:07:46 <lambdabot>  Defined.
08:07:48 <maukem> > takeExtension ".emacs"
08:07:49 <lambdabot>  ".emacs"
08:07:53 <maukem> sweet
08:09:26 * hackagebot hashable 1.2.3.1 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.3.1 (JohanTibell)
08:13:50 <SuperHotFire> data Store
08:13:50 <SuperHotFire> = Empty
08:13:50 <SuperHotFire> | Join Int Store Store
08:14:09 <SuperHotFire> If I were to define; size :: Store -> Int
08:14:24 <SuperHotFire> How would I be able to check how many integers stored?
08:14:32 <vanila> size Empty = 0 ; size (Join i x y) = 1 + size x + size y
08:15:36 <maukem> basically, you recurse on the shape of the data structure
08:22:24 <lericson> inductive data structures \o/
08:22:34 <flebron> Hey folks. I have a type Tree which can be either Nil or a Branch with 3 attributes and two branches. Can I use record notation, if I have two ctors? What's the cleanest thing I could do here?
08:23:17 <triliyn> flebron: you can use record notation normally, but if you use their accessors as functions they'll crash if called on Nil
08:23:31 <flebron> Oh that's great :D That's what I want.
08:23:39 <triliyn> But you can still use the record pattern matching syntax safely
08:23:56 <flebron> So it'd be data Tree = Nil | Tree { foo :: Foo, bar :: Bar, ... }?
08:24:06 <triliyn> Yeah
08:24:07 <flebron> err, that should be Branch, not Tree
08:24:13 <flebron> Cool, thanks :)
08:24:22 <triliyn> :)
08:30:49 <flebron> Another question. If I have a newtype X' = X' T, and an f :: T -> T, is there a canoical way to lift f onto X', without adding and removing the ctor myself?
08:31:51 <maukem> there's a newtype package but that might be overkill
08:32:29 <flebron> (The use is to be able to say as close to "(* x)" as possible, when I've wrapped an Integer around in a newtype, to give it a Monoid instance.)
08:32:51 <maukem> oh, which Monoid is this?
08:33:02 <flebron> Lowest common multiple
08:33:21 <maukem> maybe deriving Num would be easiest
08:33:35 <flebron> Hrm? Integer is already a Num
08:33:44 <flebron> Oh you mean make my newtype derive Num
08:33:47 <maukem> yeah
08:33:48 <flebron> with NewtypeDeriving?
08:33:52 <maukem> right
08:38:29 <n00b> Guys.
08:38:43 <n00b> Umm, can someone explain what the difference between String and [Char] is?
08:39:07 <n00b> > :t (map toUpper) . putStrLn
08:39:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:39:33 <solarus> :t (map toUpper) . putStrLn
08:39:34 <lambdabot>     Couldn't match type ‘IO ()’ with ‘[Char]’
08:39:34 <lambdabot>     Expected type: String -> [Char]
08:39:34 <lambdabot>       Actual type: String -> IO ()
08:39:36 <solarus> is enough
08:39:40 <kadoban> n00b: They're synonomous. Specifically String is an alias for [Char] (type String = [Char])
08:39:51 <geekosaur> n00b: no difference
08:40:00 <n00b> Cool, thanks.
08:40:01 <crobbins> @src String
08:40:01 <lambdabot> type String = [Char]
08:40:52 <athan> n00b: that's what the `type ...` keyword does
08:41:10 <crobbins> hey geekosaur, btw, i found out that ghci *will* reload TH code
08:41:10 <athan> makes an alias for a type constructor
08:41:38 <crobbins> you just have to specifically :load the module
08:42:20 <geekosaur> I saw, yes
08:43:38 <crobbins> ok cool, that makes developing with yesod waaaaaaaayy nicer
08:43:52 <crobbins> much faster to just :l DevelMain than use yesod devel
08:53:29 <crobbins> i think i'm experiencing a lazy IO bug, but i'm not sure. are there any caveats to runInteractiveCommand?
08:53:48 <crobbins> for instance, the good and good' functions work fine, but the bad function hangs forever: https://gist.github.com/carymrobbins/426756910f39020a5b63
08:57:19 <crobbins> i think it has to do with using bind, but it could be a problem with how i'm handling ReaderT and IO
08:59:52 <geekosaur> there's a caveat, lanhguage-independent, whenever you pipe both into and out of another process without putting them in separate threads
09:00:52 <geekosaur> if the pipe fills up in either direction, you can end up with both ends blocked on write because the other side is blocked on write instead of reading
09:01:46 <NemesisD> does anyone know if persistent's migration system supports indexes (not just unique)
09:02:37 <crobbins> NemesisD: it does
09:02:47 <crobbins> well...actually...not sure about that
09:02:52 <crobbins> sorry, you said "not just unique"
09:03:43 <crobbins> NemesisD: you might want to ask in #yesod
09:04:28 * hackagebot MetaHDBC 0.1.4 - Statically checked database access  http://hackage.haskell.org/package/MetaHDBC-0.1.4 (MadsLindstroem)
09:11:16 <crobbins> geekosaur: thanks, but one thing i'm still confused about... why doesn't fmap cause an issue but >>= does?
09:11:47 <crobbins> also, it looks like Data.Conduit.Process may be a good fit for what i'm after
09:13:33 <geekosaur> I was not asserting that that was the answer, just noting that your code *could* trigger that (on Linux it requires 4KB of buffered data, IIRC)
09:14:04 <crobbins> ahh ok
09:14:29 <geekosaur> that said, bind is more or less fmap + join
09:14:51 <crobbins> right, so it's odd to me that >>= poses an issue here
09:15:02 <crobbins> i think it's revealing a problem that's already there, just not sure what it is exactly
09:15:39 <lpaste> altern pasted “RoseTree JSON” at http://lpaste.net/117023
09:15:49 <altern> How could I use specifi FromJSON implementation for the JSON string that I want to parse? For example, I want to parse json with RoseTree implementation: http://lpaste.net/117023
09:16:29 <altern> FromJSON "{children: [], value: 2}" doesn't work
09:19:11 <bam365> altern: FromJSON is the name of the typeclass, I think what you want is decode
09:19:23 <bam365> decode "{children: [], value: 2
09:19:40 <bam365> }" :: Maybe RoseTree2
09:21:01 <altern> bam365, if I do "decode $ jsonString", I get " Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString with actual type `RoseTree2'"
09:21:26 <altern> oh, I missed :: Maybe RoseTree2
09:28:11 <trap_exit> GAH
09:28:26 <trap_exit> why is there no typesafe way to do PROJECT, CROSS PRODUCT, ... i.e. the sql ops ?
09:28:30 <trap_exit> we cna already do select/filter easily
09:28:41 <trap_exit> but I want to do PROEJCT, RENAME, JOIN ... in a type safe manner
09:38:12 <n00b> Umm, can someone explain why I get a type error with this?
09:38:31 <n00b> > :t concat . zipWith (\x y -> [x,y])
09:38:32 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:38:57 <n00b> :t concat . zipWith (\x y -> [x,y])
09:38:58 <lambdabot>     Couldn't match type ‘[t] -> [[t]]’ with ‘[[a]]’
09:38:58 <lambdabot>     Expected type: [t] -> [[a]]
09:38:58 <lambdabot>       Actual type: [t] -> [t] -> [[t]]
09:40:01 <lpaste> eyeBloom pasted “Toy Case over Constants” at http://lpaste.net/117029
09:40:28 <lpaste> eyeBloom pasted “Toy Case over Constants” at http://lpaste.net/117030
09:40:51 <trap_exit> in haskell, is there a way to get named tuples ?
09:41:12 <eyebloom> Hi, I’m curious about using case statements to select values. I’m finding it’s problematic if you use constant functions as your selector. See this toy example:  http://lpaste.net/117030
09:41:12 <trap_exit> i.e. I wnt a tuple, where instead of (Int, Int, Int) and referring it to first, second, third, I'd like to give it names, like foo/bar/apple
09:41:20 <kadoban> :t zipWith (\x y -> [x, y])
09:41:21 <lambdabot> [t] -> [t] -> [[t]]
09:41:29 <kadoban> :t concat
09:41:29 <lambdabot> [[a]] -> [a]
09:41:34 <kadoban> :t (.)
09:41:35 <bam365> trap_exit: it's called record syntax
09:41:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:41:44 <eyebloom> Is there a way to tell haskell that a case statement is not creating a variable but refering to a function?
09:41:54 <trap_exit> bam365: now, I record doesn't work, I want to do project/cross product in sql
09:42:01 <eyebloom> Or a better method to do what I’m trying to do.
09:42:05 <trap_exit> bam365: record forces me to declare all types upfront
09:42:07 <quchen> eyebloom: You cannot use expressions on the left of "->" in case expressions, only patterns.
09:42:10 <n00b> kadoban: Thanks.
09:42:35 <kadoban> n00b: Because those don't interact well.   (.) composes one-argument functions, which means the ([t] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=t) part is trying to match up with the... http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a part, which doesn't fit.
09:42:36 <eyebloom> quchen: Isn’t there an exception for literals
09:42:36 <n00b> f
09:42:46 <n00b> kadoban: Yeah, got it.
09:42:48 <eyebloom> Or is it just that literals can be patterns
09:42:49 <n00b> Thanks a lot (:
09:42:50 <kadoban> Err, wtf..no diea what my client did there, sorry.
09:43:01 <eyebloom> (Sorry thinking out loud)
09:43:08 <quchen> eyebloom: There are special cases for Num and String literals.
09:43:17 <quchen> eyebloom: A value holding a literal is not a literal though.
09:43:44 <eyebloom> I see, I’m basically just hoping to alias Num literals
09:43:58 <trap_exit> http://research.microsoft.com/en-us/um/people/simonpj/Papers/records.htm <-- is this in GHC ?
09:44:07 <eyebloom> So I can define constants earlier in my code.
09:44:09 <kadoban> Huh, apparently my client has wacky-ass regex autoreplaces set up by default. Fun.
09:44:20 <quchen> eyebloom: You can't, and should not, do that. Haskell has sum types that spare you the C-style "int constant" mangling.
09:44:48 <monochrom> eyebloom: you cannot use pattern matching to determine "which function am I given?"
09:45:04 <monochrom> in fact, nothing determines that.
09:45:29 <lpaste> quchen annotated “Toy Case over Constants” with “Toy Case over Constants (annotation) -- eyebloom” at http://lpaste.net/117029#a117031
09:45:39 <eyebloom> Right understood. Unfortunately I need the integerness of these constants… I understand it’s bad form but I’m defining a DSL.
09:45:48 <eyebloom> I think there is a way around it.
09:45:51 <eyebloom> Thanks.
09:45:58 <monochrom> well, almost nothing. there is a topology trick to determine some functions.
09:46:31 <quchen> Needing the integerness of these constants is a design mistake.
09:46:42 <hodapp> okay, it's boggling my mind a little how ambiguity in types is causing "No instance for ... arising from use of ..." type errors; that is, I can *add* code and make those errors disappear
09:47:54 <merijn> hodapp: What's confusing about that?
09:48:09 <merijn> hodapp: If the added code fixes/constrains the type that was problematic, the issue goes away
09:49:51 <hodapp> merijn: I get that that can happen in theory.
09:50:09 <hodapp> merijn: I'm trying to figure out why I'm having so much damn trouble initializing an array in Ivory.
09:51:02 <hodapp> they're using type-level naturals and crap...
09:51:21 <shiona> btw has there been any drama about the class Num in haskell? Haskell is commonly seen as very mathematically strict language, but minimal definition for Num doesn't feel like a watertight definition to any number system
09:52:08 <k_bx> In lens, if I have a list/vector of something, how do I fmap a getter to each element? Current version is `clients'' ^. to (fmap (^. uuid))`. Is there a better way to «get uuid out of each elem»? Thanks!
09:52:15 <shiona> Just an idea, I'm going to keep a short talk about typeclasses and I thought Num might be interesting one to mention. I thought I could try to dig a little
09:53:04 <kadoban> shiona: It's commonly seen as that, except it's really not, as far as I understand. Mostly it just draws some inspiration from category theory for some typeclasses, and people equate that with being mathematical. That and declarative programming sticking a bit closer to the math meaning of '=' and such.
09:53:40 <merijn> Num is widely regarded as an ugly wart
09:53:43 <merijn> BUT
09:54:09 <merijn> No one has come up with a hierarchy that is better but doesn't require everyone to implement a million tiny typeclasses
09:54:30 * hackagebot multiarg 0.30.0.0 - Command lines for options that take multiple arguments  http://hackage.haskell.org/package/multiarg-0.30.0.0 (OmariNorman)
09:54:40 <shiona> ok, I was expecting something like that
09:55:30 <merijn> So in the end Num is the way it is because it's good enough to be useful and not bad enough to easily find a better implementation
09:56:02 <shiona> sounds reasonable
09:56:05 <quchen> Num is the recurrent laryngeal nerve of Haskell. It's there and it does useful stuff, but it's historically grown and nobody knows how to make a Haskell without it.
09:58:27 <EvanR> seems like convenient "number" interface for programming languages doesnt fall into anything mathematically familiar
09:59:02 <quchen> EvanR: Probably because Float doesn't fall into anything mathematically familiar
09:59:24 <EvanR> you could pick something common like Integer and say its N. then you exclude other things that you want to use + and * with
09:59:59 <EvanR> including floats because of whatever reasons
10:00:11 <hodapp> if I've a signature like (IvoryArea area, KnownNat len) => [Init area] -> Init ('Array len area) how would I go about removing the ambiguity in 'len' explicitly?
10:01:15 <EvanR> quchen: or the type of rational numbers restricted to finite decimal expansions
10:01:30 <hodapp> can I let it figure out 'area' on its own, but specify just 'len' somehow?
10:02:41 <hodapp> Or, if I'm doing it explicitly, must I specify both?
10:02:43 <skeuomorf> bah, cabal and ghc are conspiring against me
10:02:54 * skeuomorf flips table
10:03:02 <skeuomorf> ghc-pkg*
10:03:07 <hodapp> I am not sure even what I'd search to look this question up...
10:03:13 <EvanR> if it wasnt for double schenanigans maybe Num is a semiring?
10:03:46 <quchen> EvanR: Num has negate, so you have additive inverses
10:05:12 <EvanR> maybe "RNG" for not necessarily having identities
10:13:11 <glguy> Hodapp: you can always specify ambiguous types with proxy arguments if nothing else. (Assuming that type signature is for something you wrote)
10:13:17 <bennofs> hodapp: specifiy the return type explicitely (like     theFunction initValues :: Init ('Array <your len> <your area type>))
10:14:23 <hodapp> glguy: I didn't specify the type signature, no.
10:14:48 <hodapp> bennofs: So there is no way I can specify 'len' explicitly, but leave 'area' to be inferred?
10:15:34 <bennofs> hodapp: not with current GHC afaik. There is some work in progress to have a "PartialTypeSignatures" extension, but that is not in any release GHC yet
10:15:59 <hodapp> alrighty
10:16:19 <hodapp> a type signature specified this way can never be polymorphic?
10:16:25 <mmmm> How can one build an intuition for lenses?
10:17:31 <bennofs> hodapp: but wait, I think you could do this: have a function withLen :: Proxy len -> Init ('Array len area) -> Init ('Array len area); withLen _ = id; and then use withLen (Proxy :: Proxy <yourLen) $ yourFunction yourInitValues
10:18:13 <bennofs> (Proxy is from Data.Proxy)
10:18:20 <hodapp> I haven't really used Proxy at all; what is the purpose, just a dummy argument that exists to narrow down some type/kind?
10:18:27 <bennofs> hodapp: yes, it is
10:18:33 <bennofs> data Proxy a = Proxy
10:18:48 <hodapp> ahh, okay
10:18:57 <hodapp> this makes sense
10:19:01 <bennofs> Really just an awkward way to pass "types" explictly
10:20:54 <hodapp> what does (Proxy :: Proxy <yourLen>) mean there?
10:21:03 <hodapp> is that giving a signature for Proxy?
10:21:06 <bennofs> hodapp: yes
10:21:14 <bennofs> :t Proxy :: Proxy 3
10:21:15 <lambdabot> Proxy 3
10:22:01 <hodapp> huh, just looks strange to me, having basically type constructors on each side
10:22:05 <hodapp> of different kinds
10:22:26 <bennofs> hodapp: Proxy is a also a value constructor
10:22:45 <bennofs> > let a :: Proxy 3; a = Proxy in a   -- a is a value of type Proxy 3
10:22:47 <lambdabot>  Proxy
10:23:19 <hodapp> huh...
10:23:42 <HeladoDeBrownie> It basically just lets you specify a type without having to witness that type or doing hacky stuff like (undefined :: MyType)
10:24:04 <hodapp> bennofs: so in this case, you've the value constructor on the left, type constructor on the right?
10:24:49 <bennofs> hodapp: yeah. If it was data ProxyType a = ProxyVal, then I would have to write ProxyVal :: ProxyType 3
10:25:27 <hodapp> oh. data makes a type constructor *and* value constructor. Derp, I knew that.
10:25:41 <hodapp> that makes sense.
10:26:17 <benzrf> Proxy ~ Const ()
10:26:24 <hodapp> what's what mean?
10:26:29 <HeladoDeBrownie> In a proper dependently typed language you'd just pass the type directly, but Haskell isn't dependently typed
10:26:38 <benzrf> Proxy is isomorphic to Const ()
10:26:45 <bernalex> HeladoDeBrownie: not yet, anyway
10:26:53 <HeladoDeBrownie> f : (t : Type) -> whatever
10:27:22 <bennofs> HeladoDeBrownie: 'data Const r a = Const r', so if r = (), then that's the same as Proxy
10:27:33 <HeladoDeBrownie> bennofs, was that meant for hodapp?
10:27:37 <bennofs> yes
10:28:12 <HeladoDeBrownie> They say you shouldn't have two main characters whose names start with the same letter in a play, I guess that applies to IRC too
10:28:24 <bennofs> :)
10:28:36 <hodapp> So... channels should have at most 26ish people? :P
10:28:40 <chrisdone> common use cases include resolving class instances
10:28:48 <HeladoDeBrownie> hodapp, you're not thinking with unicode :)
10:28:59 <chrisdone> and forcing unification of type-variables
10:29:11 <hodapp> HeladoDeBrownie: I was thinking of Unicode - and how I've not exactly been able to use Unicode nicks in IRC
10:29:24 <HeladoDeBrownie> hodapp, touche :P
10:29:24 <chrisdone> my irc server supports unicode nicks :3
10:29:25 <bennofs> hodapp: also, it only says that there may only be 26 people in a discussion at any given time, not that there may not be more people listening and not saying anything
10:29:50 <hodapp> bennofs: For the sake of tab-completion, a lot of clients don't look much to who's talking
10:30:38 <hodapp> HeladoDeBrownie: Maybe I need to go look at my Coq notes for something like you describe - passing the type directly
10:30:56 <HeladoDeBrownie> Sounds like something Coq would be capable of, although I don't know Coq
10:31:40 <bennofs> yes, coq can do that
10:32:12 <hodapp> I've not worked in SF in awhile... I need to keep working through it.
10:32:26 <vanila> where are you in it?
10:33:10 <hodapp> I forget >_>
10:36:44 <benzrf> christ
10:36:53 <chrisdone> you rang?
10:37:04 <benzrf> one of these years im going to understand enough math to read a single page of nlab
10:38:35 <hodapp> lol
10:38:50 <exio4> I think you are asking for the impossible benzrf
10:40:16 <josephle> benzrf: and just when you think you know enough, some new type theory will come out and add a new section to 50% of the pages in nlab
10:40:39 <eXeC64> How do I get lambdabot to give me a function in pointless form?
10:40:47 <josephle> corollary: the type theory will have analogies to a field of math that you have no knowledge about
10:40:57 <benzrf> josephle: Q_Q
10:40:58 <eXeC64> I tried "pointless f x = 2 * x" in query
10:40:59 <chrisdone> @pl \x -> x
10:40:59 <lambdabot> id
10:41:13 <hodapp> Math is too hard. Let's use JavaScript.
10:41:16 <eXeC64> thanks
10:41:24 <benzrf> @remember hodapp Math is too hard. Let's use JavaScript.
10:41:25 <lambdabot> It is stored.
10:41:32 <chrisdone> math is hard, let's use maths
10:41:35 <parc> @hoogle STRef s a -> STRef s a -> Bool
10:41:37 <lambdabot> Data.Graph.Inductive.Graph equal :: (Eq a, Eq b, Graph gr) => gr a b -> gr a b -> Bool
10:41:58 <benzrf> nice
10:42:00 <chrisdone> parc: that's exactly what you wanted, right?
10:42:09 <benzrf> ayy lmao
10:42:34 <parc> well i was wondering if there was an STref/IOref-based solution, but basically yeah
10:44:01 <parc> other than tagging the STRefs with ids explicitly
10:48:08 <jdiez> @pl f x = x / cos x
10:48:08 <lambdabot> f = ap (/) cos
10:51:09 <JonReed> Hi! What is the prover way to import a module so that it will override standart prelude functions? E.g. if I want to use "Data.ByteString"s functions like "tail", "head" instead of the ones in prelude
10:51:14 <mmachenry> Anyone know why I might be getting a space leak in this program? It is not freeing up database cursors. Cursors should be cleared when data is read. I'm doing only actions which give no data. http://lpaste.net/117033
10:51:16 <trap_exit> laziness is so fucking awesome; I can create infinite data values
10:51:38 <crobbins> JonReed: {-# LANGUAGE NoImplicitPrelude #-}
10:51:48 <crobbins> import Prelude hiding (tail, head)
10:52:00 <clrnd> import DataByteString as B
10:52:05 <clrnd> :P
10:52:13 <crobbins> yeah, clrnd's is good as well
10:52:16 <crobbins> that's what i usually do
10:52:20 <JonReed> crobbins: Thx!
10:52:31 <bernalex> import qualified Data.ByteString as B
10:52:33 <crobbins> i am really liking ClassyPrelude also
10:53:07 <crobbins> you get generalized tail and head functions, albeit, requires non-empty lists in the form of MinLen
10:54:10 <clrnd> how does it compare to safe?
10:54:35 <crobbins> not sure, although, i think classy-prelude uses safe
10:54:50 <crobbins> oh, nope, nevermind
10:55:03 <chrisdone> oh huh. i just found a use for Profunctor
10:55:11 <chrisdone> i'd previously thought it useless =)
10:55:55 <trap_exit> laziness is awesome
10:55:57 <clrnd> something actualy useful or something like comonad-useful?
10:56:08 * chrisdone checks the laws pass
10:57:30 <mdmkolbe-web> Hi all, for a research project I'm just starting, I'm looking for examples of popular libraries and domain-specific embedded languages that could benefit from domain specific optimizations.  Any suggestions or suggested places to look for ideas?
10:57:34 <alphonse23_> hey
10:57:39 <bennofs> The nice thing about profunctors is that combined with lens, you can "lift" it using an Isomorphism. So if you have x :: p Int Int (where p is your profunctor), and an Iso i :: Iso SomeIntNewtype Int, then you can do i x :: p SomeIntNewtype SomeIntNewtype
10:58:01 <lpaste> chrisdone pasted “Exercise” at http://lpaste.net/117035
10:58:21 <chrisdone> clrnd: this is for a kind of formlet that generates questions and validates the answers
10:58:32 <alphonse23_> would anybody be nice enough to read a blog post I wrote on Haskell and give me some feed back? it's meant to be submitted to another blog, where, i guess if the owner like it, it will go up...
10:58:51 <clrnd> sounds real life useful to me
10:58:57 <clrnd> alphonse23_, just paste it mate
10:59:02 <chrisdone> it's for teaching haskell =)
10:59:05 <alphonse23_> yes
10:59:09 <alphonse23_> if you're interested
10:59:14 <chrisdone> trivial example: http://lpaste.net/116955
10:59:17 <alphonse23_> I'll send the link to you privately
10:59:39 <chrisdone> i'm not sure that it's an arrow, but also not sure whether i care
10:59:53 <chrisdone> spend time proving arrow laws? http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1345661034056.gif
11:00:50 <clrnd> lol
11:01:01 <clrnd> alphonse23_, ok, or just paste it mate
11:02:01 <alphonse23_> ok fine: https://github.com/seanwestfall/templatehaskell/blob/master/README.md
11:04:33 * hackagebot hasql-postgres 0.9.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.9.1 (NikitaVolkov)
11:07:08 <gfixler> alphonse23_: this writeup seems really useful for my meetup group
11:07:16 <gfixler> we're looking at template haskell early in the new year
11:07:18 <clrnd> alphonse23_, seems like one of the best TH guides I've seen so far, congrats !
11:07:28 <alphonse23_> ahh thanks
11:07:54 <gfixler> alphonse23_: you have the word 'prentices' in there
11:08:00 <gfixler> I think it's supposed to be 'parentheses'
11:08:10 <alphonse23_> ahh thanks for finding that
11:09:48 <gfixler> alphonse23_: one more - "TH is functional more similar" (should be functionally)
11:10:29 <alphonse23_> damn adverbs
11:10:34 <alphonse23_> thanks again
11:11:45 <gfixler> alphonse23_: will this repo persist?
11:11:57 <alphonse23_> yes probably
11:12:08 <alphonse23_> though, it's meant to go an another person blog
11:12:18 <alphonse23_> *to go on another
11:12:27 <alphonse23_> person's
11:12:29 <gfixler> maybe you could add a notice at the top if/when that happens
11:13:50 <alphonse23_> the repo will stay there
11:13:58 <alphonse23_> I'm just saying it'll also be somewhere else on the internet
11:14:05 <alphonse23_> and i might get edited there
11:15:53 <clrnd> yeah just link to it when that happens :D
11:34:21 <mmachenry> Does anyone know if the Database Enumerator library requires one to explicitly clean up cursors when using execDML? I can't see how I would, yet I am a "max cursors" error in a very short program.
11:34:30 <bernalex> so what's The Right Thing to use for a map of k->v with unique ks when I want as fast lookup on k as possible, and fast-ish insertion of new k-vs?
11:35:19 <monochrom> I would try Map and HashMap depending on whether binary search or hashing is faster.
11:35:58 <bernalex> Map was my initial gut reaction
11:36:11 <monochrom> perhaps HashMap is faster because of read-many, write-few.
11:36:28 <monochrom> or rather read-often, write-seldom
11:36:53 <monochrom> err, nevermind, I confused HashMap with hash tables!
11:37:08 <bernalex> I will read often and write semi-seldom. but very rarely do I care about the vs (except when inserting them)
11:38:20 <chrisdone> the judy library might also be an option if you want super fast lookup
11:38:52 <bernalex> "super fast" is probably overengineering (like I always do)
11:38:56 <bernalex> I mean it's an IRC bot lol
11:39:29 <chrisdone> oh, if it's just a bot who cares =p
11:39:34 * hackagebot github-backup 1.20141222 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20141222 (JoeyHess)
11:39:35 <chrisdone> a list of pairs would be fast enough
11:39:42 <bernalex> prooobably yeah
11:39:50 <chrisdone> but Map is better typed =)
11:40:04 <bernalex> yeah
11:45:05 <merijn> I'd try IntMap over Map where you want speed
11:46:57 <MrGlass> Hello, I'm new to haskell, and I'm havign a bit of trouble with lists. If I want to access the nth element of a list (EG, the equivalent of list[n] in C) it sems like there is no predifined function. Am I supposed to build my own? Or am I jsut stupidly missing something?
11:47:30 <exio4> > [2..] !! 24
11:47:31 <lambdabot>  26
11:47:51 <exio4> you can use !! for indexing, but if you are really using it, a list is probably the wrong data structure
11:48:33 <MrGlass> exio4: what data structure shoudl I use, in that case?
11:49:02 <chrisdone> a vector, probably
11:49:40 <MrGlass> thanks
11:49:40 <chrisdone> there's also lookup
11:49:44 <mauke> or an array
11:49:55 <chrisdone> > lookup 3 $ zip [0..] $ [1..5]
11:49:56 <lambdabot>  Just 4
11:49:56 <opensourcegeek> Does haskell scales out of the box as claimed here? https://www.fpcomplete.com/wp-content/uploads/Bump-case-study.pdf
11:50:17 <exio4> but what are you actually doing? because you may find a map or a persistent datatype more useful
11:50:23 <opensourcegeek> or does it require other extensions or any libraries?
11:50:36 <monochrom> I basically believe all claims on fpcomplete, so I'm biased.
11:50:37 <chrisdone> it's likely anything claimed with the word "scale" is overblown
11:50:40 <mauke> haskell scales right out of all the boxes
11:50:48 <opensourcegeek> ha ha
11:50:55 <exio4> it has boxed values too
11:51:46 <opensourcegeek> ok that was a honest question, if it's not a honest claim I'm happy to take that as an answer
11:52:14 <monochrom> "likely anything claimed with the word 'scale' is overscaled"
11:52:47 <dnkndnts> i just installed the new haskell platform (default binary build) on a fresh mint 17, and i'm having cabal issues. cabal tells me to do "cabal install cabal-install", which claims to succeed installing 1.20.0.4, but when i then do cabal --version, it says it's 1.18.x
11:52:52 <bernalex> is there some package that comes with safeHead/safeTail? I don't feel like implementing them
11:53:06 <dnkndnts> has anyone else experienced this?
11:53:34 <vamega> dnkndnts: The version cabal installs isn't on your path
11:54:33 <vamega> You're going to need to to add $HOME/.cabal/bin to the front of your PATH variable
11:54:45 <dnkndnts> vamega: hmm, ok i'll try that, one sec.
11:54:49 <monochrom> bernalex: on hackage the package "safe" may help
11:55:17 <vamega> Let me know if you need help with adding that to the PATH variable.
11:55:24 <bernalex> monochrom: I don't think it has safe head/tail
11:55:36 <monochrom> it has tailMaybe
11:55:40 <dnkndnts> vamega: ok, yup, that works! thanks!
11:55:45 <vamega> monochrom: I asked this a few days ago.
11:55:52 <vamega> Turns out there isn't a safe version of head available.
11:55:59 <vamega> I ended up just writing my own version
11:56:13 <bernalex> monochrom: oh I somehow managed to ignore the top level module itself. sorry. thanks.
11:56:50 <monochrom> err, tailMay
11:56:57 <monochrom> and headMay
11:57:12 <chrisdone> opensourcegeek: it's not unreasonable to say that haskell code can be easier to write multi-threaded, simply because pure code doesn't write to memory and the impure code in haskell still makes it inconvenient to do mutation, requiring explicit variables which aids in limiting the WTFs per minute
11:57:16 <monochrom> this is going to look like pig latin :)
11:57:27 <dnkndnts> the Vect type in idris has safe heads and tails -- it's extremely cool to play around with. "head $ head $ with Vect [1]" will fail to compile, but "head $ with Vect [1]" will work :O
11:57:34 <dnkndnts> super cool
11:57:37 <vamega> monochrom: Oops I was looking for a safe version of (!!)
11:57:58 <monochrom> that's atMay
11:58:54 <monochrom> I now officially declare this package to be Pig Agda :)
11:58:56 <chrisdone> opensourcegeek: and ghc haskell just has an easy to use but powerful threading library. compared to other languages it has a lot more
12:00:28 <bernalex> can anyone figure out a nicer way to write this: '(tailMay =<<) . headMay . splitOn "!"' ?
12:01:27 <chrisdone> use bind =p
12:01:31 <chrisdone> @let bind = (=<<)
12:01:32 <lambdabot>  Defined.
12:01:40 <bernalex> chrisdone: I agree that it's hardly *unreasonable* to conjecture that a parallel language is easier to parallelise than an imperative language, heh.
12:01:41 <chrisdone> bind tailMay . headMay . splitOn "!"
12:01:44 <chrisdone> much nicer =p
12:02:12 <chrisdone> bernalex: what's a parallel language?
12:02:36 <bernalex> chrisdone: that's not bind. bind is (>>=).
12:02:48 <chrisdone> bernalex: bind is what i says is bind, boy
12:02:56 <bernalex> chrisdone: oh ok then :-P
12:02:59 <crobbins> bahahaha chrisdone
12:03:46 <bernalex> chrisdone: with lazy evaluation, evaluation is not defined/imperative. we often say that lazy languages are inherently parallel. indeed you may hear SPJ ranting on about the virtues of this if you watch his talks about parallelism in haskell.
12:04:05 <chrisdone> "we often say"? =p
12:04:09 <chrisdone> who's we?
12:04:30 <bernalex> chrisdone: us fp theory geeks.
12:05:00 <chrisdone> why are lazy languages inherently parallel?
12:05:05 <bernalex> and as with other generalisations ("Norwegians like brunost"), I do not mean that everyone say it. :-]
12:05:46 <chrisdone> "we" is a way of saying "a group you're not a member of"
12:05:51 <sivteck> Atheir parents were parallel
12:05:58 <sivteck> their*
12:06:45 <monochrom> that's not what mathematicians mean when writing "we now prove this theorem"
12:06:48 <chrisdone> sivteck: i suppose they'd have to have been parallel at some point =p
12:06:51 <crobbins> chrisdone: although, grammatically "we" could refer to "you and I"
12:06:56 <ReinH> chrisdone: It's also a way of saying "I" ;)
12:07:09 <sivteck> :p
12:07:26 <chrisdone> sure if you're writing a paper you can use we
12:07:36 <monochrom> and textbook, not just paper
12:07:45 <chrisdone> if you're writing something to be published
12:08:12 <chrisdone> if you're conversing with a human being, eh, not so much
12:08:14 <ReinH> Or if you're attempting to lend credence to your idea by claiming that other unspecified people also believe it ;)
12:08:26 <chrisdone> ReinH: ;)
12:10:16 <bernalex> chrisdone: it is not imperative by default. without data dependency between expressions, there is nothing preventing you from running them in parallel. the FP model greatly encourages this, and haskell in particular. this gives us some neat code which is sort of "parallel by default" rather than "imperative by default". of course, if you write an inherently anti-paralell algorithm, then using haskell won't
12:10:18 <bernalex> magically make it embarrassingly parallel.
12:10:43 <bernalex> but you seem to be much more occupied with my choice of the pronoun "we" than anything else, so I'll leave you to it & get back to my programming :-]
12:11:01 <chrisdone> WE? https://www.youtube.com/watch?v=bbJ-4vuffhI&t=0m40s
12:11:09 <sinelaw> oui
12:12:00 <monochrom> oui too
12:17:05 <athan> Can we do nested `let` statements? For some reason, this isn't compiling: https://github.com/athanclark/hi-basic-web-server/blob/master/package-name/src/Main.hs.template#L52
12:17:18 <athan> (this is using template, so just ignore the `$$` and turn them into `$`)
12:18:06 <dfeuer> @tell int-e I missed something, and you did too, I think :-/.  liftA2 does not get optimized so well. The trick, I think, is generalizing the type of aptyMiddle, so it takes a FingerTree of Elem a, rather than of Elem(a->b), and so it takes a more general map23.
12:18:06 <lambdabot> Consider it noted.
12:18:13 <johnw> indent by double indentation
12:18:48 <mauke> athan: remove 'in'
12:18:56 <chrisdone> bernalex: because haskell is pure?
12:18:57 <johnw> ah
12:18:58 <ReinH> athan: in a do block you just use let, not let/in.
12:19:13 <athan> ReinH & mauke: Ahh, wow okay, thank you :)
12:19:53 <bernalex> chrisdone: yes. pure expressions are inherently parallel because there is no data dependencies. haskell is also nice for concurrency for the same reason.
12:20:05 <chrisdone> bernalex: where does laziness enter into it?
12:20:36 <bernalex> chrisdone: in an imperative language, execution order is defined. it is not in a lazy language. so "it might as well be parallel".
12:20:59 <bernalex> it is an admittedly tongue-in-cheek statement.
12:22:09 <platz> parallel or concurrent?  I thought paralellism usually required something explicit to get things to run across multiple cores
12:22:37 <johnw> bernalex: saying imperative vs. lazy feels wrong
12:22:38 <bernalex> platz: concurrency is something that needs to run at the same time logically, parallelism is making some algorithm or whatever run in parallel for performance reasons.
12:23:44 <chrisdone> johnw: yeah, it feels like a category error
12:25:12 <chrisdone> parallel map support in haskell seems to require deepseq to indicate that you need to run two things in parallel
12:25:29 <chrisdone> so laziness hinders this case, because laziness means you don't know when something should be evaluated, if ever
12:26:13 <chrisdone> purity seems amenable to implicit parallelism, especially if total
12:27:15 <johnw> right, when evaluating a pure function, it shouldn't matter if things are evaluated which shouldn't have been (due to laziness) or not -- so long as the answer is right
12:27:38 <johnw> so there is a great deal of operational freedom, which I think was the original point being made
12:28:07 <athan> That "re-engineering the IO monad" paper was awesome for this kind of stuff
12:28:16 <athan> (not really sure if _really_ applicable here)
12:29:59 <opensourcegeek> athan, do you have a link to that paper please?
12:33:16 <athan> opensourcegeek: On one condition - you say "awwww yeaaaaa!" before trying to read it, and every time you reference it: https://www.haskell.org/haskellwiki/IO_inside
12:37:56 <NightRa> I have a question about lazyness:
12:38:30 <NightRa> The paper "Why Functional Programming Matters",http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf, talks about the adventages of HOF's and lazyness.
12:38:32 <bobbytables> i'M AN EXPERT ON BEING LAZY!
12:39:09 <znst> really picked up on that enthusiasm after the apostrophe
12:39:13 <Hijiri> high tables
12:39:13 <Hijiri> hi tables*
12:39:14 <Hijiri> are you from ps
12:39:39 <NightRa> But would it behave as described in section 5, page 19:
12:39:43 <Hijiri> or did you just read the same xkcd comic
12:39:56 <NightRa> (With lazy trees)
12:40:17 <NightRa> Does the garbage collector clean subtrees after inspecting them?
12:40:36 <NightRa> But still inspecting other subtrees under the same root?
12:40:54 <Hijiri> do you mean in one go?
12:41:05 <Hijiri> because it seems like the subtrees would be out of references if their parent died
12:41:11 <Hijiri> (and nothing else had references to them)
12:41:45 <NightRa> But their parent did not die, and still had references to the subtree, but we would inspect other subtrees never returning to the earlier ones
12:41:52 <bobbytables> Sorry about the CAPSLock, you can blame shapr for me being here.
12:42:45 <NightRa> That's what confused me.
12:44:02 <NightRa> (That's a really nice and light weight paper, I'd suggest a read for everyone :) )
12:46:49 <shapr> oh hai bobbytables! How you doin?
12:47:19 <shapr> bobbytables is teaching me crochet, and I'm trying to get him to write lots of Haskell code!
12:47:25 <shapr> bobbytables: you may also enjoy #haskell-beginners
12:48:25 <bobbytables> #haskell-beginners is probably more my speed at this point.
12:48:53 <ecem> http://www.youtube.com/watch?v=tHoaeAWJy2s&feature=youtu.be
12:49:55 <shapr> bobbytables: written any Haskell code?
12:50:24 <johnw> he specializes in SQL
12:50:36 <shapr> johnw: who does?
12:50:41 <johnw> little Bobby tables
12:50:42 <shapr> OH RIGHT
12:50:42 <shapr> duh
12:50:45 * shapr feels silly
12:50:56 <shapr> I call bobbytables that in person as well, so I forgot about the joke :-P
12:51:27 <bobbytables> shapr: Not yet. Maybe over the break.
12:51:47 <shapr> fair enough
12:53:19 <NightRa> So would it be possible to model a tree & a traversal on the tree such that it won't store anything other than the path to the root on the call stack?
12:54:41 <mauke> >call stack
12:56:24 <dfeuer> carter, the fromListN in IsList really wants to take a size-tagged list, doesn't it?
12:57:43 <carter> dfeuer: islist is just full of design problems
12:57:58 <dfeuer> Yes, like the fact that it includes its own toList.
12:58:40 <carter> dfeuer: notice how it only works for not indexed things?
12:58:54 <dfeuer> carter, with size-tagged ones, would you be able to make [a,b,c,d] turn into a tree at compile time?
12:59:07 <carter> dfeuer: MAYBE?
12:59:12 <dfeuer> Not indexed things?
12:59:18 <carter> why not?
12:59:24 <athan> Is there an... anti-liftIO? :: m b -> IO b?
12:59:25 <carter> explain your bigger picture question plz
12:59:29 <carter> athan: run?
12:59:34 <carter> extract?
12:59:37 <athan> carter: o.o
12:59:40 <athan> :t run
12:59:41 <lambdabot>     Not in scope: ‘run’
12:59:41 <lambdabot>     Perhaps you meant one of these:
12:59:41 <lambdabot>       ‘un’ (imported from Control.Lens),
12:59:44 <carter> athan: depends on the monad
12:59:50 <athan> carter: It's with warp / scotty :s
12:59:54 <carter> hah
12:59:56 <athan> :(
13:00:17 <dfeuer> carter, what's wrong with "indexed" things, whatever that means?
13:00:27 <carter> dfeuer: sized lists are indexed
13:00:34 <athan> carter: What is this `run` you speak of?
13:00:42 <carter> newtype ScottyT e m a = ScottyT { runS :: StateT (ScottyState e m) m a }
13:01:06 <carter> running a monad stack tends to be "all the way"
13:01:13 <carter> or not, depends
13:01:17 <johnw> athan: there is, in fact
13:01:21 <johnw> athan: http://hackage.haskell.org/package/monad-control
13:01:33 <johnw> it can't work for all monads, though
13:02:06 <athan> johnw: Woah! Thank you!
13:02:46 <athan> carter: Thanks man, I'll... uhhh... stare at it o_o
13:02:58 <carter> :t runState
13:02:59 <lambdabot> State s a -> s -> (a, s)
13:03:04 <bennofs> :t traverse `asTypeOf` concatMap
13:03:05 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ [b]
13:03:05 <lambdabot>     Expected type: (a -> [b]) -> [a] -> [[b]]
13:03:05 <lambdabot>       Actual type: (a -> [b]) -> [a] -> [b]
13:09:48 <athan> carter: Staring worked!!!
13:10:27 <eacameron> does anyone have any experience using shake in a "modular" way, i.e. small build scripts per module that get run by an overarching build system?
13:10:38 <jdiez> @pl queryRedis db r = io $ runRedis db r
13:10:38 <lambdabot> queryRedis = (io .) . runRedis
13:10:46 <jdiez> that's fkn clever, lambdabot
13:21:26 <sinelaw> ok. why is this ok?
13:21:28 <sinelaw> > 1/0
13:21:29 <lambdabot>  Infinity
13:22:02 <carter> i think dagit has eacameron
13:22:19 <carter> eacameron: what does modular mean here though?
13:22:29 <carter> i mean, per se you have a global registry in shake right?
13:22:44 <eacameron> carter: global registry?
13:22:58 <clrnd> sinelaw, that's just how it's defined ...
13:23:15 <eacameron> carter: I'm thinking of something like Visual Studio projects, composable hunks of buildable things
13:23:17 <carter> eacameron: build rules interact and form a deps graph
13:23:17 <tolt> When using pipes, adding an await causes the cpu usage to spike to incredibly high amounts... http://lpaste.net/334097848029151232
13:23:21 <tolt> any suggestions?
13:23:31 <carter> right?
13:23:51 <eacameron> carter: right, so define haskell modules for rules and import them into a base build script?
13:23:58 <carter> sure
13:24:04 <carter> eacameron: at the very least, start with that
13:24:12 <sinelaw> clrnd, why does it make sense?
13:24:20 <eacameron> doesn't that limit my folder structure to abide by haskell naming standards?
13:24:23 <sinelaw> clrnd, does 0*n tend towards 1 when n grows?
13:24:46 <carter> eacameron: ..... says who?
13:24:48 <clrnd> :t (/)
13:24:49 <lambdabot> Fractional a => a -> a -> a
13:25:09 <eacameron> carter: I thought haskell modules had to have certain folder hierarchy
13:25:30 <carter> depends on how you do it :)
13:25:39 <eacameron> carter: elaborate...
13:26:03 <carter> eacameron: explain what you WANT
13:26:21 <carter> and i'll try to answer THAT
13:26:22 <bennofs> carter: 1/n tends to 0 as n -> infinity, no?
13:26:26 <clrnd> sinelaw, what should it return?
13:26:36 <bennofs> meant sinelaw, not carter
13:26:44 <carter> bennofs: yes... but the sum -> infiintiy
13:26:50 <carter> same diff
13:27:10 <statusfailed> can fgl express every possible graph, or is it a subset?
13:27:22 <carter> its a graph lib
13:27:35 <eacameron> carter: so, for example: Build.hs at the root. then <root>/db/Rules.hs (defines how to build this chunk of code); then <root>/web/Rules.hs...etc
13:28:02 <carter> ghc ./Build.hs ./db/Rules.hs ./web/rules.hs
13:28:09 <carter> etc
13:28:17 <sinelaw> bennofs, in the limit, yes
13:28:30 <eacameron> how does Build.hs know about the rules in those other files?
13:28:30 <carter> eacameron: you may want to give the modules distinct names of course
13:28:31 <bennofs> eh, ignore what I said. it doesn't make much sense
13:28:32 <sinelaw> but / is not a limiting operator in haskell
13:28:40 <carter> eacameron: importing them by name
13:28:41 <sinelaw> it's just /
13:28:50 <statusfailed> carter: sure- can type "Graph" as defined in fgl express every possible graph?
13:29:01 <bennofs> > ((-1)/0, 0/0)
13:29:02 <lambdabot>  (-Infinity,NaN)
13:29:05 <carter> statusfailed: if you find a finite graph it cant, file a bug report
13:29:06 <sinelaw> ideally. / :: Fractional a -> a -> a -> Maybe a
13:29:08 <tolt> Does anyone know why an await inside of a pipe would cause the cpu usage for an application to spike?
13:29:13 <carter> eacameron: you can also have more than one source dir in a cabal file
13:29:45 <eacameron> carter: interesting, I'll mess around with that
13:29:47 <eacameron> thanks
13:30:31 <carter> eacameron: you know how cabal init at the end asks if you wanna have those helpful comments?
13:30:44 <carter> it puts a source dirs / src-dirs field in there
13:30:45 <bennofs> tolt: await means that the producer needs to run. Maybe the producer causes a lot of cpu usage while producing the next value (the return value of await)?
13:30:53 <carter> you can have more than one source dir!
13:31:19 <carter> eacameron: but you can only have one module with each name!
13:31:21 <eacameron> carter: that might be what's needed; shake by default does not use cabal so that would be a first step
13:31:43 <carter> eacameron: or just have a top level script that invokes ghc + then calls the binary
13:31:48 <carter> that might be simplers
13:31:57 <eacameron> carter: that's what it has now
13:32:09 <carter> use your own judgement :)
13:32:39 <eacameron> carter: so ghc Build.hs db/Db.hs web/Web.hs ?
13:32:44 <carter> sure
13:32:45 <carter> why not
13:32:54 <carter> eacameron: cmoputers are cheap, try shit and see what hapens
13:33:24 <eacameron> carter: that's my job ;) just wanted to know if someone else already did that
13:33:38 <eacameron> eacameron: which is also my job
13:36:41 <lpp> can I somehow export everything in a module but specific function (e.g. Data constructor)
13:54:07 <quchen> You can't export "hiding" something I'm afraid
14:03:40 <pavonia> lpp: You can create an internal module that exports everything, and in your module you only import this internal module qualified hiding the constructor and then re-export the qualified module
14:04:41 <bergmark> lpp: import Foo hiding (bar) and export Foo
14:06:10 <jdiez> @pl prefix p m = if p `isPrefixOf` m then Just (drop (length p) m) else Nothing
14:06:10 <lambdabot> prefix = flip flip Nothing . ap (ap . (if' .) . isPrefixOf) ((Just .) . drop . length)
14:07:09 <pavonia> > stripPrefix "foo" "foobar"  -- jdiez
14:07:10 <lambdabot>  Just "bar"
14:07:32 <jdiez> > stripPrefix "foo" "bla"
14:07:33 <lambdabot>  Nothing
14:07:38 <jdiez> pavonia: perfect. thanks
14:09:45 <arianvp___> YEHHHHH. I got servant to work in the browser.
14:10:00 <arianvp___> Type-safe web APIs? AND writing clientisde code yin haskell? . dreams came true toda
14:10:44 <tolt> arianvp___: with ghcjs?
14:10:51 <arianvp___> tolt: yes :)
14:10:59 <arianvp___> tolt: Totally ignoring any form of error handling though
14:11:13 <tolt> arianvp___: that's hilarious. We were just talking about doing that at lunch
14:11:17 <arianvp___> and doing some nasty stuff like converting   LBS to BS to String
14:11:52 <arianvp___> I'll try pushing the cleaned up version tonight to https://github.com/arianvp/ghcjs-servant-client if you wanna mess around with it
14:12:36 <Luke> arianvp___: awesome
14:19:22 <sinelaw> >1/0*1
14:24:41 * hackagebot leveldb-haskell-fork 0.3.4.4 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-fork-0.3.4.4 (ifesdjeen)
14:25:15 <tolt> > 1/0*1
14:25:16 <lambdabot>  Infinity
14:27:16 <bananagram> > 0/0
14:27:18 <lambdabot>  NaN
14:27:18 <xyh> hi friends :) is the problem number 29 in the number 9 section of the book <to mock a mockingbird> fully solved ? is the shortest expression been proven ?
14:28:55 <Denommus> this guy must be trolling: http://www.reddit.com/r/haskell/comments/2q3y7m/serious_i_understand_haskell_is_awesome_but_what/]
14:29:24 <Denommus> will Monad extend Arrow in the new GHC?
14:31:01 <Peaker> class Arr a => Monad (a i) where ??
14:31:06 <MP2E> no, what I think you're thinking of is the Functor-Applicative-Monad proposal. https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
14:31:26 <Denommus> forget it -.-
14:31:55 <Denommus> I think I've read something wrong about Monads being Arrows
14:32:02 <Clint> Kleisli?
14:32:58 <MP2E> You can make a Monad using an Arrow, but it's generally more useful to do it via Functor => Applicative => Monad. Arrow offers few specialized usecases over Category+Applicative and a lot of complication IMO
14:33:32 <quchen> I'd be interested in seeing the code for how to make the State monad out of a State arrow.
14:33:35 <Peaker> Arrow <=> (Category, Applicative)
14:34:04 <Peaker> ArrowApply <=> (Category, Monad)  (not sure if Category is needed on the right side here)
14:36:22 <Denommus> going home
14:36:25 <arianvp___> is there a way to enable CORS in WARP?
14:51:31 <benzrf> Peaker: interesting
14:52:29 <benzrf> Peaker: arrowapply gives "a b (a c d) -> a (b, c) d"?
14:52:33 <benzrf> or something like that i guess
14:53:18 <MP2E> seems i had it reversed :v
14:53:30 <MP2E> ah well, reading more about arrows now
14:53:38 <Peaker> benzrf: something like that, akin to join, yeah
14:54:31 <benzrf> i thought it gave something like "a (b, a b c) c"
14:54:53 <benzrf> oh wait i guess that's pretty similar to what i just said if you compose it
14:55:07 <sinelaw> so arrowapply ~ uncurry?
14:55:26 <benzrf> "a r (b, a b c) -> a r c"
15:11:29 <Peaker> sinelaw: ArrowApply gives you something like "join" -- an arrow with a result value that is itself an arrow can be connected into the main arrow
15:24:42 <danilo2> edwardk: Hello Edward! I've got one question to you about Ermine (about this code here: https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Term.hs). Would you be so nice and tell me more If I get this correctly? I'm talking about : "[...] | Lam [Pattern t] !(Scope PatternPath (Term t) a)" So it means that If a variable is bounded then we got "Ter t PatternPath" ? If yes, what would mean such term when it would evaluate 
15:26:42 <brainacid> Hello everyone!
15:26:55 <brainacid> Happy Holidays, I guess..
15:28:08 <zipper> How do I create values of type `type Rand g = RandT g Identity` where RandT is  defined like `data RandT g m a` because even after importing Control.Random.Monad and Control.Random.Monad.Class
15:29:02 <zipper> Ok also what on earth are monad transformers? I would like a link maybe.
15:30:06 <zipper> Found Wikipedia anyway the first question stands
15:31:06 <johnw> zipper: they are compositions of some specific monad with another monad
15:31:07 <johnw> since only certain combinations can form monads
15:32:30 <zipper> johnw: I am reading a wikipedia article on that. Can you help me make values of type Rand from http://hackage.haskell.org/package/MonadRandom-0.3/docs/Control-Monad-Random.html#t:Rand
15:34:04 <johnw> making values of that type involves calling getRandom or getRandomR
15:35:06 <zipper> johnw: I can also make values of type StdGen with mkStdGen
15:35:14 <dfeuer> Happy Chanukah, brainacid.
15:35:16 <zipper> :t getRandomR
15:35:17 <lambdabot> Not in scope: ‘getRandomR’
15:36:04 <zipper> johnw: I can do it. I don't see why I have to wrap the StdGen in IO though
15:36:29 <johnw> hmm?  what do you mean by wrapping it in IO?  Remember that I'm not seeing what you are
15:37:09 <zipper> johnw: I thought getRandom was getStdGen
15:37:15 <zipper> johnw: Let me look for that type
15:43:02 <batchm> what is a not combinator in Parsec?  (notcomb digit) should match everything but digit
15:44:41 <Hijiri> satisfy (/= digit)? Or maybe something like noneOf "a" (where 'a' is your digit)
15:44:43 * hackagebot apis 0.0.1 - A Template Haskell library for generating type safe API calls  http://hackage.haskell.org/package/apis-0.0.1 (FabianBergmark)
15:45:24 <simon> batchm, I don't know, where do you read this?
15:45:54 <simon> batchm, is notcomb :: Parsec Char -> Parsec Char?
15:46:30 <Hijiri> I think batchm wants Char -> Parsec Char
15:46:37 <Hijiri> but I don't know
15:47:13 <Hijiri> I don't see how you would sensibly invert a Parsec a
15:48:03 <batchm> simon it should be more general
15:48:15 <batchm> Parsec a -> Parsec a
15:48:26 <simon> batchm, that hardly makes sense.
15:48:26 <batchm> Hijiri why not?
15:48:47 <Hijiri> what would it parse to?
15:49:12 <simon> batchm, well, let's say we have notcomb :: Parsec a -> Parsec a and you do "notcomb (char 'a')". what is its type?
15:49:46 <simon> batchm, if it can match *anything* (not just single chars), how do you fit that into a return value? what would the type of that return value be?
15:49:47 <batchm> Parsec Char. but I see your point now
15:50:51 <batchm> to give an actual example, I wanted a nicer way of parsing a line: many (noneOf "\n")
15:51:21 <simon> many (satisfy (/= '\n'))? :)
15:51:40 <batchm> can't we make use of newline parser?
15:51:59 <zipper> johnw: Ok I think I've read up on getRandom and getRandomR, so how I can I get values of type Rand g ?
15:52:01 <batchm> with this approach we have to redefine all the combinators manually, newline, digit, lower, etc
15:52:13 <simon> sure, even better. you could make a newline parser that is agnostic to the file format (\n|\r\n)
15:52:18 <Hijiri> many (noneOf "\r\n") *> newLineParser ?
15:52:37 <Hijiri> <*
15:52:40 <Hijiri> rather
15:53:05 <sleepomeno> manyTill anyChar newLineParser
15:53:16 <Zol_> Anyone got a good example of how to better write code that is very UI & user IO-dependent, text related? I've implemented some kind of state machine but I think it is beyond ugly: https://github.com/Zolomon/PokemonArena/blob/master/src/Server.hs#L78-137
15:53:16 <batchm> to clarify, I want to use newline :: Stream s m Char => ParsecT s u m Char
15:53:31 <batchm> instead of writing newline with string literal
15:53:51 <arianvp____> I usually do something like this
15:54:00 <Zol_> (The password thing will be replaced by a secure implementation in case it ever gets that far)
15:54:05 <brainacid> hey dfeuer thnks!!
15:54:11 <johnw> zipper: 'Rand g' is the type of an action that produces random values
15:54:17 <dfeuer> You're welcome.
15:54:22 <johnw> what is it that you actually want to be doing?
15:55:03 <batchm> consumeUntil newline ? anything like that
15:55:45 <brainacid> hey all what about EclipseFP?
15:55:51 <dfeuer> What about it?
15:55:54 <Crimlo> huh
15:55:56 <Crimlo> what
15:55:57 <brainacid> Im more of  minimalist
15:55:58 <Crimlo> who
15:56:01 <Crimlo> why?
15:56:07 <brainacid> dont know very much of Eclipse
15:56:23 <dfeuer> Eclipse seems complicated. I don't know if it works right for Haskell or not.
15:56:24 <Axman6> then don't use it if you already have something that works
15:56:25 <zipper> johnw: In exercise 3 of type StdRand = Rand StdGen we have a type synonym defined like this `type StdRand = Rand StdGen` and we should write a function `dieRoll :: StdRand DieRoll` but I don't know how to make values of type StdRand
15:56:40 <brainacid> just curious , honestly Im just started out and Im happy with gedit and terminal with ghci
15:56:44 <dfeuer> I wish I actually could deal with Emacs, but it seems to break my brain most o f the time.
15:57:05 <johnw> zipper: the docs on Rand show how to write a die-rolling function
15:57:09 <brainacid> i have question, when i :l myModule.hs and prompt Main:> how do I exit back to Prelude> prompt??
15:57:13 <johnw> it will be very similar to that
15:57:28 <zipper> johnw: They do? I haven't seen that
15:57:43 <johnw> you linked me to it, look at the bottom of the page
15:57:46 <johnw> http://hackage.haskell.org/package/MonadRandom-0.3/docs/Control-Monad-Random.html#t:Rand
15:57:58 <zipper> Oh under example
15:58:22 <Bor0> with HDBC/MySQL, how can I get the last inserted ID?
15:59:08 <batchm> this is the best I could dp. manyTill anyChar newline
15:59:13 <batchm> do*
16:00:33 <zipper> Ok one last question. How can we make a type `StdRand DieRoll` if `type StdRand = Rand StdGen` and DieRoll is `type DieRoll = Int` note StdRand is ok Kind *
16:00:37 <zipper> johnw: ^
16:01:45 <zipper> johnw: Is reading this docs futile if I don't know monad transformers?
16:07:03 <fabian_> Anyone tried out the apis package?
16:13:20 <prinsen> When does new packages show up on hayoo?
16:13:35 <trap_exit> wtf what is the state of the art of haskell row types?
16:13:45 <trap_exit> https://www.haskell.org/haskellwiki/Extensible_record
16:13:49 <trap_exit> what should I actually use ?
16:16:03 <bitemyapp> no response in #yesod, figured I'd ask here: getting "There was no response, you should make a request" for a yesod test in this code: http://lpaste.net/6013916991448940544
16:16:10 <bitemyapp> any ideas what I'm doing wrong?
16:16:38 <zipper> How can we make a type `StdRand DieRoll` if `type StdRand = Rand StdGen` and DieRoll is `type DieRoll = Int` note as far as I see StdRand is ok Kind *
16:17:28 <zipper> bitemyapp: Do you have any article on monad transformers?
16:18:00 <zipper> Ignore question about StdRand
16:18:46 <trap_exit> what's a good tutorial on Data.HList ?
16:19:24 <bitemyapp> trap_exit: ouf.
16:19:35 <bitemyapp> trap_exit: I don't know of any, I've only looked at code that uses it.
16:19:46 <bitemyapp> zipper: well. I did a talk on monad transformers, it's not perfect, but have you seen that?
16:20:01 <zipper> bitemyapp: No
16:20:07 <zipper> bitemyapp: Youtube?
16:20:11 <trap_exit> bitemyapp: waht does ouf mean ?
16:20:22 <zipper> bitemyapp: I can't remember your you tube
16:22:51 <bitemyapp> zipper: getting the link, uno momento.
16:23:03 <bitemyapp> zipper: apologies for the bad video: https://www.youtube.com/watch?v=Go-RR_2I9CU
16:23:11 <bitemyapp> trap_exit: it's uh. Hrm. How to explain.
16:23:17 <bitemyapp> trap_exit: it's like the french "uf" I think?
16:23:31 <trap_exit> bitemyapp: I don't know french
16:23:33 <bitemyapp> trap_exit: in this situation it meant, "oh man, that's tough. I don't know if I have anything"
16:23:45 <bitemyapp> it's a reaction to difficulty, impossibility, uh...
16:23:49 <trap_exit> bitemyapp: is "ouf" like "shut the fuck up, read the fucking docs, and if you don't have the docs, google the fucking docs" ?
16:23:58 <bitemyapp> no :\
16:24:04 <trap_exit> lol, I like my translation more
16:24:05 <bitemyapp> it just means I feel bad for not having a good answer.
16:24:21 <bitemyapp> because I'd like a nice HList tutorial too. I think Diehl might have a little example for it, h/o
16:24:23 <trap_exit> there's this research paper: http://web.archive.org/web/20120328173520/http://homepages.cwi.nl/~ralf/HList/paper.pdf
16:24:43 <trap_exit> and there's a short stack exchange answer; and that's about all I have
16:24:46 <bitemyapp> http://dev.stephendiehl.com/hask/#hlists
16:25:01 <bitemyapp> the example there at least gets you into the realm of working code you can play with.
16:25:09 <bitemyapp> and it has explanations for the pragmas it uses.
16:27:26 <trap_exit> bitemyapp: nice, thanks!
16:28:03 <bitemyapp> trap_exit: np
16:28:16 <zipper> bitemyapp: Thanks
16:29:45 * hackagebot shake-language-c 0.6.3 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.6.3 (StefanKersten)
16:32:15 <zipper> johnw: Ok I read the docs and got the answer to exercise 3. However, I see `type StdRand =  Rand StdGen` and type `DieRoll = Int` So how can StdRand take another type yet it seems to be of kind *.
16:32:42 <batchm> is there a shorter way of writing this? ParsecT String u Identity [Char
16:33:16 <zipper> johnw: The signature of that function is `StdRand DieRoll`
16:35:04 <trap_exit> dude
16:35:07 <trap_exit> wtf does https://gist.github.com/anonymous/39f7463cccdaf352ca4a even mena ?
16:35:13 <trap_exit> wtf does :: [*] mean ?
16:37:42 <c_wraith> trap_exit: it's from the DataKinds extension - it means a list of types of kind *
16:37:46 <HeladoDeBrownie> trap_exit, presumably, "list of concrete types"
16:38:00 <HeladoDeBrownie> ninja'd
16:38:03 <trap_exit> I have no idea what either of you said means
16:38:17 <trap_exit> ELI5: what does :: [*] mean ?
16:38:33 <c_wraith> trap_exit: oh god, where are your parents?
16:38:33 <trap_exit> where are your parents, and why are you learning HList in haskell ?
16:38:38 <HeladoDeBrownie> XD
16:38:48 <trap_exit> at some type theory conference
16:38:53 <c_wraith> trap_exit: now, if you actually want to learn, read the original source.  It's a good paper: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
16:39:06 <c_wraith> byorgey is a good author
16:39:32 <trap_exit> c_wraith: that is an interesting way to say stfu
16:39:36 <trap_exit> printing paper now
16:39:52 <c_wraith> trap_exit: well, it's...  rather complicated for a couple quick lines in IRC
16:39:56 <trap_exit> actually, I just want to ahve row types / be able to projection/join in a type safe manner
16:40:06 <c_wraith> trap_exit: are you familiar with the kind system in general?
16:40:22 <trap_exit> I heard about it, in te context of COq.
16:40:25 <trap_exit> then I buried my head in the sand.
16:40:32 <c_wraith> trap_exit: the vinyl package may be a better choice for that
16:41:03 <trap_exit> c_wraith: you ean watfh http://vimeo.com/102785458 ?
16:41:16 <RyanGlScott> I found out recently one of my packages doesn't compile with GHCJS because it uses a different version of base than GHC does. Are there Haddock pages for GHCJS's base?
16:41:27 <c_wraith> trap_exit: that's the package
16:42:22 <Axman6> trap_exit: you understand the difference between Maybe and Maybe Int?
16:42:48 <trap_exit> (Maybe Int) is a concrete type
16:42:54 <trap_exit> Maybe is :: a -> Type
16:43:12 <Axman6> which means that Maybe Int has kind *, and Maybe has kind * -> *
16:43:16 <trap_exit> it's like (+1) vs 10
16:43:25 <trap_exit> Axman6: okay, got it
16:43:34 <Axman6> Maybe needs another type before it can become a concrete type
16:43:35 <c_wraith> trap_exit: it's important to note that * isn't a wildcard.  It's actually the kind of concrete types
16:43:47 <Axman6> so [*] means a list of concrete types
16:44:15 <Axman6> so it could be [Bool, Maybe Int, Either String ()]
16:44:29 <Axman6> but not [Maybe, Either, []]
16:44:39 <c_wraith> But [*] is...  a kind, not a type.  That's what DataKinds is about.  It lets you use types as kinds and values as types
16:44:46 <trap_exit> [Bool, Maybe Int] <-- this is a list of 2 elements?
16:44:52 <trap_exit> isn't [*] just a tuple then?
16:45:07 <hamishmack> RyanGlScott: base is patched for ghcjs, but it should be compaitble
16:45:18 <nshepperd> a thing of kind [*] isn't a concrete type
16:45:22 <Axman6> you can add Int to the front of that lsit and  get [Int, Bool, Maybe Int]
16:45:25 <nshepperd> it doesn't have any values
16:45:34 <brainacid> i have question, when i :l myModule.hs and prompt Main:> how do I exit back to Prelude> prompt??
16:45:44 <RyanGlScott> hamishmack: Sorry, I meant as in it doesn't export certain GHC modules (e.g., GHC.Event).
16:45:45 <brainacid> thanks
16:47:28 <hamishmack> RyanGlScott: Ah yes that might not be emplemented for ghcjs.  The patch is here https://github.com/ghcjs/ghcjs-boot/blob/master/patches/base.patch
16:48:30 <nshepperd> trap_exit: consider [Maybe, Either 5, IO] :: [* -> *]
16:48:48 <trap_exit> considred
16:48:56 <RyanGlScott> hamishmack: That's super-helpful, thanks!
16:49:45 <RyanGlScott> hamishmack: BTW, on a totally unrelated note, is the Haskell glade package still actively maintained?
16:50:32 <nick_named> Does anyone know why `deep (isElem >>> hasName "form")` doesn't work for selecting an HTML form using HXT
16:50:36 <RyanGlScott> hamishmack: I ask since there's some packages I'm trying to build that depend on it, but glade's documentation implies that it's been superseded by functionality in gtk+ itself.
16:50:59 <hamishmack> RyanGlScott: libglade is depricated (not glade the app) you should migrate to GtkBuilder if possible
16:52:08 <hamishmack> RyanGlScott: https://github.com/gtk2hs/gtk2hs/tree/master/gtk/demo/gtkbuilder
16:52:51 <RyanGlScott> hamishmack: In that case, is it wise to migrate away from Graphics.UI.Gtk.Glade and use Graphics.UI.Gtk instead?
16:56:20 <hamishmack> I have not used GtkBuilder myslef.  I like to have the UI definition in Haskell.  In the future I want to make more use of something ghcjs based (perhaps built on ghcjs-dom)
16:57:10 <hamishmack> then the native code version can use WebKitGTK+
16:57:58 <RyanGlScott> hamishmack: I'm not really planning on using it myself, just to fix the YampaSynth package, whose dependencies (including glade) have rotted.
16:58:42 <hamishmack> I think there is a tool to convert old glade definitions to GtkBuilder
16:59:15 <hamishmack> or perhaps you can just load it in glade and save it back out in the new format
17:00:43 <RyanGlScott> Is this the tool you're talking about? https://developer.gnome.org/gtk2/stable/gtk-builder-convert.html
17:01:37 <hamishmack> yes that is it
17:02:48 <RyanGlScott> That should help then. I never thought I'd be debugging glade files when trying to play WAV files with FRP :)
17:08:30 <nitnelave> Hey everyone! I'm trying to have a shared module in haskell, similarly to a .so, how would I do that?
17:14:24 <nitnelave> Anyone?
17:15:56 <nitnelave> Damn, I've got to go, I'll be back later. I'll try to backlog if there is any information
17:22:43 <athan> Do yesod-routes live on top of wai, facilitating the routes?
17:22:53 <athan> s/routes/routing
17:24:29 <trap_exit> how do I read an entire file as a Text string ?
17:25:04 <c_wraith> trap_exit: Data.Text.IO.readFile
17:25:14 <arnoblalam> Hi all
17:25:26 <arnoblalam> question regarding simplifying a HAskell function
17:25:34 <c_wraith> arnoblalam: ask away!
17:25:45 <trap_exit> c_wraith: nice, thanks!
17:26:02 <trap_exit> so I have this haskell function, which exhaustively solves 3SAT instances
17:26:08 <trap_exit> I need to simplify it to run in polynomial time
17:26:32 <c_wraith> trap_exit: you would win some awards by doing that. :P
17:27:01 <arnoblalam> I have a bunch of functions that look like this
17:27:02 <arnoblalam> http://pastebin.com/4vtchJZw
17:27:21 <arnoblalam> as you can see, the functions are basically the same
17:27:28 <arnoblalam> however the things they return are slightly different
17:27:42 <arnoblalam> one returns a IO (Response Queue)
17:27:54 <arnoblalam> and another returns a IO (Response [QueueSummary])
17:28:13 <arnoblalam> is there some way to fator out the common part of this function
17:28:14 <arnoblalam> ?
17:29:08 <lpaste> arnoblalam pasted “Simplifying functions” at http://lpaste.net/117045
17:29:20 <c_wraith> arnoblalam: is that using wreq?
17:29:29 <arnoblalam> yes
17:30:09 <arnoblalam> I feel this code is incredibly messy by the way… there’s probably a more concise way of expressing what I am trying to do
17:31:50 <c_wraith> arnoblalam: I'm installing wreq right now so I can actually see if things typecheck. :)
17:32:12 <arnoblalam> oh
17:32:23 <arnoblalam> you might need some other types I have defined earlier...
17:32:44 <c_wraith> arnoblalam: Eh, I think I can get what I need anyway.
17:32:56 <arnoblalam> ok
17:33:22 <lpaste> arnoblalam pasted “full code” at http://lpaste.net/117047
17:33:33 <arnoblalam> there’s the full code for the library btw
17:37:56 <lpaste> c_wraith pasted “wreq stuff (guess)” at http://lpaste.net/117048
17:38:21 <c_wraith> arnoblalam: ^ I didn't actually test that - but it's most of the common code, and in a form that... should be near working, at least
17:41:14 <arnoblalam> haha… I don’t have GHC in ym system so can’t actually test it :-)
17:41:46 <c_wraith> arnoblalam: well, how comfortable are you with haskell's type system?
17:42:22 <arnoblalam> still learning it… have a lot of problem figuring out which monad layer I am in
17:42:32 <arnoblalam> well, should have GHC installed shortly
17:42:33 <c_wraith> arnoblalam: well, fortunately you don't need that here. :)
17:42:39 <arnoblalam> so this shouldn’t be an issue
17:43:42 <c_wraith> arnoblalam: the important part is that it's using polymorphism over the FromJSON class to determine how to parse the data depending on the type you use the return value as
17:43:53 <arnoblalam> I see
17:44:11 <arnoblalam> ah, is there a reason it needs to be (IO a)?
17:44:21 <arnoblalam> is that because getWith is an IO action?
17:44:55 <c_wraith> yes.  It doesn't need to be as specific as IO, though - I just assumed that's what you were using anyway
17:45:03 <c_wraith> It could be more polymorphic
17:45:28 <arnoblalam> I believe I was having issues with GHC doing type inference
17:45:47 <arnoblalam> but I am trying to write a generalized client library for this service
17:46:11 <c_wraith> arnoblalam: I'm sure some of those issues were the result of using OverloadedStrings - it makes a few things have issues.
17:46:12 <trap_exit> https://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-Text.html <-- is there something here which encodes [a-zA-Z] ?
17:46:51 <arnoblalam> I think I can explicitly type annotate if necessary
17:47:08 <arnoblalam> I think any monad that can throw errors should be fine for this library?
17:47:16 <arnoblalam> not sure if that’s the right terminology
17:47:25 <arnoblalam> ok… haskell platform finished downloading
17:47:29 <arnoblalam> time to test it out
17:47:42 <c_wraith> arnoblalam: oh, that actually does require IO, due to the type of getWith
17:49:25 <dfeuer> Is reactive Conal Elliot's latest FRP package? It has comments at the top saying it's very buggy, but it hasn't been updated in several years.
17:54:50 <liyang> dfeuer: I think he hasn't done anything in that direction since he started working again…
17:55:44 <liyang> (Or much Haskell hacking at all, really.)
17:55:52 <dfeuer> liyang, he stopped working for a while? Has anyone else taken up the FRP reins?
17:56:58 <johnw> liyang: he's being doing a lot of Haskell hacking, just not open source yet
17:57:43 <liyang> dfeuer: after MSR I believe he was just living in the woods (no, literally) and pursuing his own research interests. Few years ago he started working again for Tabula.
17:57:53 <SrPx> Does anyone know an elegant function that returns the nth prime? No need for efficiency
17:58:07 <SrPx> Does anyone know an elegant function that returns the nth prime? No need for efficiency
17:58:14 <liyang> johnw: I wasn't sure exactly what Tabula hired him for… ^^;;
17:59:08 <johnw> he's using Haskell to describe circuitry
17:59:58 <liyang> Now I know. I wonder if their dev tools are written in Haskell…
18:01:38 <liyang> (Not likely, judging by their jobs page.)
18:01:42 <dfeuer> liyang, MSR?
18:01:51 <liyang> dfeuer: Microsoft Research
18:02:02 <dfeuer> Mrrrr.
18:03:29 <endiruna1> hi I have a basic question: i am confused about the data types. What does    data Stack w = mkStk [w] [w]   do. to constract a data type Stack one uses the constructor mkStk and gives to it two lists
18:03:49 <liyang> johnw: do you know more specifics?
18:04:13 <endiruna1> why there is 3 times  w
18:04:16 <indiagreen> endiruna1: did you mean “MkStk”?
18:05:17 <endiruna1> is there a difference? i thought that mkStk is a name one gives to the constructor
18:05:32 <indiagreen> yes, but constructor names have to start from capitals
18:05:42 <endiruna1> sorry
18:05:51 <nshepperd> endiruna1: that means that MkStk takes two [w] lists and returns a 'Stack w'
18:06:25 <SrPx> also, I guess I asked it before, but there are so many of them I'm not sure... what is the structure I'm supposed to use where I would use a C array? That is, fast random write/read?
18:06:55 <endiruna1> nshepperd: so the type is 'Stack w'. it is not defining Stack data type but
18:07:00 <nshepperd> endiruna1: eg. MkStk [1, 2] [3, 4] :: Stack Int
18:07:00 <endiruna1> 'Stack w'
18:07:01 <tsani> SrPx: Vector ?
18:07:20 <endiruna1> oh i see
18:07:37 <endiruna1> nshepperd: so this way you define Stack for every thing
18:07:49 <endiruna1> Int Float and whatever
18:08:02 <nshepperd> endiruna1: yes. "Stack of w" where w can be anything
18:08:16 <endiruna1> that is a clever syntax :)
18:08:20 <endiruna1> thanks!
18:09:03 <SrPx> tsani: seems like it is O(N) write /:
18:09:50 <endiruna1> another stupid question. what is the equivalent of scanf and printf? i guess print is the equivalent of printf. what about scanf?
18:14:49 <nshepperd> I
18:14:54 <hiptobecubic> I'm trying to understand the significance of type families, having read the relevant post on 24 days of ghc extensions. It seems like multiparam type classes handle the example case much more clearly. What am I missing? http://lpaste.net/117049
18:15:16 <brianpWins> I’m not sure I understand how to get the Action out of a data type “data Concurrent a = Concurrent ((a -> Action) -> Action)"
18:15:17 <nshepperd> i'm not sure there's a direct equivalence, but you can use 'read :: (Read a) => String -> a'
18:15:53 <nshepperd> > read "Just 4" :: Maybe Int
18:15:55 <lambdabot>  Just 4
18:15:58 <nshepperd> endiruna1: ^
18:16:39 <endiruna1> thanks!
18:19:23 <brianpWins> So yeah any ideas how to extract from that data structure?
18:19:40 <tsani> SrPx: I believe that if you use MVector, you get O(1) write, since the data structure won't be persistent.
18:19:58 <ski> > (reads :: ReadS (Maybe Int)) "Just 4"
18:20:00 <lambdabot>  [(Just 4,"")]
18:20:00 <pnielsen> endiruna1: There's a printf in Text.Printf which is basically equivalent to sprintf/printf
18:20:10 <ski> > (reads :: ReadS (Maybe Int)) "Just 4,more stuff"
18:20:11 <lambdabot>  [(Just 4,",more stuff")]
18:20:20 <ski> > (reads :: ReadS (Maybe Int)) "4,more stuff"
18:20:21 <lambdabot>  []
18:20:35 <endiruna1> how do i read the next say 10 lines? i tried [ x <- read| _ <- [1..10]]
18:20:39 <endiruna1> but does not work
18:21:05 <ski> endiruna1 : `replicateM 21 readLn" ?
18:21:25 <ski> or `getLine' instead of `readLn', if you just want to get the lines into strings
18:21:26 <endiruna1> do you know why the above is incorrect
18:21:51 <ski> endiruna1 : `[x <- read | ...]' is incorrect syntax
18:22:09 <ski> you can't use `<-' to the left of `|' in a list comprehension
18:23:24 <SrPx> tsani: I see, it needs the IO monad though, I meant to ask "what is the purely functional structure that I'm supposed to use in place of JS arrays"?
18:23:37 <SrPx> tsani: that is, I'm expecting something with log(N) write/reads
18:23:42 <ski> if you had said `[read | _ <- [1 .. 10]]' (which is equal to `replicate 10 read'), then you'd get a list with ten (unapplied) functions, all of them being the `read :: String -> a' function, for some appropriate type `a' that is readable
18:24:21 <ski> but that wouldn't *use* those functions (yet, at least)
18:24:23 <pnielsen> SrPx: Vector or Sequence (look at the complexity notation for the functions in each to get an idea what's right for you)
18:25:05 <ski> endiruna1 : it would be possible to use that list of reading functions to parse input lines (previously or interleavably read)
18:25:14 <ski> endiruna1 : does that help ?
18:25:57 <endiruna1> thanks ski. how would i apply it?
18:26:43 <endiruna1> that way i constructed a function say that makes 10 read and puts them in an array
18:26:49 <ski> endiruna1 : you would have to first read the lines, e.g. using `getLine', or `getContents' (or `readFile' or `hGetContents' to get a list of strings, or a string, with the input to parse
18:26:57 <brianpWins> I really don’t understand at all: How do you take a value from a data type? I need to get the Action out of: data Concurrent a = Concurrent ((a -> Action) -> Action)
18:27:32 <Welkin> pattern match on it
18:27:33 <tsani> SrPx: Sequence gives logarithmic writes
18:27:36 <Welkin> or give it a record name
18:27:56 <ski> endiruna1 : just a small point here. the `[...]' notation in Haskell is syntax for (single-linked) lists, not arrays. it probably doesn't matter much here, but it can perhaps be useful to keep in mind for later
18:28:08 <SrPx> seems like that is what I want, indeed, tsani and pnielsen ! (:
18:28:27 <Welkin> brianpWins: data Concurrent a = Concurrent { runConcurrent :: (a -> Action) -> Action }
18:28:39 <endiruna1> ski: oh so read is the unapplied abstract read instead readline waits for a read to happen, right?
18:28:57 <monochrom> there is no readline.
18:29:07 <ski> brianpWins : an alternative is to define `runConcurrent (Concurrent x) = x'
18:29:23 <simon> I'm trying to install a package through cabal using 'cpulimit', but it seems that doing 'cpulimit -l $N cabal install $PKG' does not actually enforce this limit. can anyone recommend a way to do this?
18:29:33 <monochrom> x will have type (a -> Action) -> Action rather than Action.
18:29:49 <ski> endiruna1 : `read' is just a function that can be applied to any string whatsoever, which may perhaps come from user input of the process, or from some other source
18:29:56 <simon> (the reason I'm doing this is because my CPU needs new cooling paste, and before I buy this, overheating it will restart the computer.)
18:30:11 <brianpWins> Welkin, ski thanks that gives me a place to start!
18:30:26 <endiruna1> thanks a lot ski! that is really clarifying!
18:30:42 <monochrom> a place to start is like an execution of a program
18:30:54 <ski> endiruna1 : `getLine' is an `IO'-action that, when executed (*not* evaluated), will get a line of input from standard input, and yield that string as result (and then you could later use `read' or `reads' on that)
18:31:53 <flebron> Hi. I have a file with >= 3 lines. I run my program as ./foo < file. What could cause the first two first getLines to succeed, and the third one to fail sayingthe handle is closed?
18:32:35 <ski> endiruna1 : `readLn' is an `IO'-action that roughly combines `getLine' and `read', but which generates an exception when executed, in case of parse failure (if you're not careful about using `read', then you'll get an error/exception first when the string is *used*, some time later (or never))
18:33:08 <hiptobecubic> Oh nevermind. it looks like he does exactly that in the multi param typeclass post
18:33:42 <flebron> Ah, wait, I may be doing something dumb. print <$> getLine likely doesn't do what I want.
18:34:28 <monochrom> @type print <$> getLine
18:34:29 <lambdabot> IO (IO ())
18:34:44 <ski> endiruna1 : if you have a list of `IO'-actions (not necessarily executed yet, or maybe executed multiple times already), you can build a new `IO'-action, that, when (later) executed, will execute the given `IO'-actions in the list, in order, and finally yield a list of all the individual results
18:35:42 <simon> can anyone recommend a way to get the most recent GHC on Debian without compiling it and without messing up package dependencies within apt?
18:35:48 <ski> endiruna1 : so, if you say `replicate 10 getLine', that is a list of ten `IO'-actions, all describing that action to read an input line (so all list elements are equal)
18:36:21 <batchm> flebron you want =<<, not <$>
18:36:29 <monochrom> simon: simply obtain from https://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux
18:36:37 <simon> monochrom, great!
18:36:49 <ski> endiruna1 : if we now call `sequence :: [IO a] -> IO [a]' on this, iow, `sequence (replicate 10 getLine)', we get an `IO'-action that, when executed, will read ten lines of input (and yield a list of them, as result)
18:37:01 <ski> @src replicateM
18:37:01 <lambdabot> replicateM n x = sequence (replicate n x)
18:37:21 <ski> endiruna1 : `replicateM' is just a convenient short-hand for this combination of `sequence' and `replicate
18:37:25 <ski> '
18:37:25 <simon> monochrom, I wonder why the .xz file is so much smaller than the .bz2 file.
18:37:29 <batchm> flebron  just for learning purpose, you could have collapsed nested IOs with join
18:37:32 <ski> endiruna1 : does that make sense ?
18:37:40 <batchm> > join (print <$> getLine)
18:37:41 <lambdabot>  <IO ()>
18:38:44 <monochrom> xz is a more successful compression
18:39:09 <simon> monochrom, that's what I'm amazed about. I thought bz2 was pretty much the best, but that's a large margin.
18:39:37 <monochrom> even before xz came about, in those days when bz2 was hip, I already found that bz2 wasted much more CPU than gz for little gain, and ditched it.
18:41:26 <simon> monochrom, I agree.
18:41:37 <simon> monochrom, that was also my experience.
18:41:38 <endiruna1> ski: i am a bit confused. i am trying to make sense of what you wrote but i can not really. so getLine is the action that is executed to get input from the user. it returns what the user had input right?
18:41:48 <monochrom> a monad law says that join (print <$> getLine) = getLine >>= print
18:43:02 <ski> endiruna1 : yes
18:43:22 <endiruna1> what is the role of read then?
18:43:38 <monochrom> read is a parser.
18:43:49 <ski> `read' converts a string representation of a value into the value itself
18:44:02 <Welkin> join (liftM k x) is x >>= k
18:44:08 <ski> executing `getLine' only gets you a string
18:44:11 <monochrom> it is also a pure function. it doesn't do I/O. it doesn't talk or listen.
18:44:43 <endiruna1> ok I see. but how do i get it to execute
18:44:53 <monochrom> types are more reliable than names when guessing what a thing does.
18:44:54 <ski> you make it part of the `main' action
18:46:27 <endiruna1> so if i wante to get only the list of the strings that the user has input i would do    main = [ getLine | _ <- [1..10]]
18:46:36 <simon> monochrom, when I install this binary package and try to run a remotely-compiled program under GHC of equivalent version, I get "error while loading shared libraries: libffi.so.6: cannot open shared object file".
18:46:59 <ski> (apart from testing/debugging in GHCi and such things), the only way to execute an `IO'-action is to make it a part of the `main' action, which is the starting point for executing (and hence evaluating) a program
18:47:40 <brianpWins> I’m clearly forgetting everything about everything I can’t make sense of the next step after getting a value from Concurrent. Given a return value of ((a -> Action) -> Action) I don’t know again how to execute that method. Pass it an action and return the very action I pass?
18:47:50 <ski> endiruna1 : it's a good first try, but `[ getLine | _ <- [1..10]]' is a *list* `IO'-actions, it's not an `IO'-action
18:48:26 <ski> endiruna1 : if you put `sequence' in front of that list (comprehension), that will convert it from a list of actions to an action (yielding a list), then it will execute
18:48:28 <Axman6> endiruna1: I'm pretty sure that dopesn't do what you want at all
18:48:40 <Axman6> :t [getLine | _ <- [1..10]]
18:48:41 <lambdabot> [IO String]
18:48:49 <Axman6> you want IO [String]
18:49:25 <simon> ah - it seems libffi isn't a Haskell package.
18:49:41 <ski> endiruna1 : .. then, to do anything more useful, you'll need to do something with that list (currently it's just discarded. there's no implicit printing of stuff in `main')
18:50:07 <monochrom> simon: different builds of GHC make different assumptions. the build from GHC's website does not involve libffi at all. but some other builds may. get libffi from your linux distro.
18:50:51 <ski> endiruna1 : .. and to do that, you'd either use the `do'-notation, or the basic `(>>=)' (read "(monadic) bind") that that notation desugars into
18:51:03 <simon> monochrom, argh! so currently my own system has libffi6 and this debian wheezy has only libffi5. :)
18:51:04 <monochrom> GHC's source code has an option of "use libffi or not" and some people may turn it on.
18:51:16 <monochrom> yeah, and that.
18:51:49 <simon> lovely. I'll have to play with this REST-thing for my Tor hidden service later. time to correct assignments.
18:52:10 <monochrom> I dread grading the most.
18:52:48 <simon> this is a "get-admitted-to-exam-or-not" type of assignment, so I suspect that everyone has made the effort or at least cheated sufficiently.
18:52:55 <monochrom> I will be grading about 90 students of computability and NP-hard homework next term.
18:53:03 <monochrom> I will be insane.
18:53:53 <simon> ugh. at least these compilers will either compile or not. I'm happy I never corrected proof-heavy coursework.
18:55:32 <endiruna1> i have to say a bit difficult in the beginning but makes a lot of sense now! thanks a lot!
18:57:03 <SrPx> Is GHC specially optimized against official data-structures on hackage?
18:58:18 <ski> endiruna1 : one way to view the business with `IO' in Haskell is that it enforced (to some extent) a separation between interface code (that will need to do Input/Output), and internal computation code (that won't)
18:59:16 <ski> endiruna1 : one traditional defence of this idea is to more easily be able to replace the interface with an alternative interface, without having to touch the internal computation machinery much (ideally, not at all)
19:01:32 <ski> endiruna1 : now, another point here (that is also present more generally in ideas about program design and engineering, not just in Haskell), is that this often makes the internal computation machinery easier to express
19:01:38 <carter> SrPx: more like the other way around
19:01:57 <carter> SrPx: in some respects, dfeuer  is now an expert, he can speak to that I think
19:02:08 <SrPx> you... just... well, thanks carter
19:02:20 <SrPx> hum okay
19:02:33 <carter> SrPx: people write code that they think GHC will compile well
19:02:47 <SrPx> yes
19:02:55 <ski> endiruna1 : so. in Haskell, you can only do Input/Output as part of an `IO'-action. iow if your return type doesn't involve `IO' (perhaps hidden behind some type definition), then it can't do I/O
19:02:58 <godel> How can I make ghci prompt suck less? Something like pretty printing, highlighting
19:03:03 <carter> ghc devs DO benchmark ghc compiled programs against code in the wild to evaluate if optimizations improve perf of course
19:03:58 <ski> endiruna1 : however. it still *is* possible to do all of the (conceptually) internal computation in `IO'-actions. but the recommended stance is to try to strive for the opposite, if there aren't other compelling reasons
19:04:59 <volgoda> > map (+9) [9..19]
19:05:01 <lambdabot>  [18,19,20,21,22,23,24,25,26,27,28]
19:05:36 <brianpWins> So given that value of type ((a -> Action) -> Action) how exactly do I execute it to get the Action?
19:05:48 <volgoda> > map (\x-> if x > 14 then x+1 else x*7) [9..19]
19:05:50 <lambdabot>  [63,70,77,84,91,98,16,17,18,19,20]
19:05:55 <ski> brianpWins : pass an argument of type `a -> Action' ?
19:06:34 <batchm> can I use template haskell to run this at compile time? space =  filter isSpace [minBound .. ]
19:06:38 <ski> > [if x > 14 then x+1 else x*7 | x <- [9 .. 19]]
19:06:39 <lambdabot>  [63,70,77,84,91,98,16,17,18,19,20]
19:07:02 <volgoda> > let actionExecutor f x = f x in actionExeutor (+1) 4
19:07:03 <lambdabot>  Not in scope: ‘actionExeutor’
19:07:03 <lambdabot>  Perhaps you meant ‘actionExecutor’ (line 1)
19:07:09 <volgoda> > let actionExecutor f x = f x in actionExecutor (+1) 4
19:07:11 <lambdabot>  5
19:07:39 <HeladoDeBrownie> brianpWins, that's an odd type, are you sure that's the whole thing?
19:07:45 <brianpWins> ski:I don’t think I have access to the argument. Considering the whole thing was stored in that concurrent wrapper.
19:07:54 <HeladoDeBrownie> Oh, of course, the a can't be used.
19:08:01 <brianpWins> HeladoDeBrownie: data Concurrent a = Concurrent ((a -> Action) -> Action) was the full type
19:08:09 <HeladoDeBrownie> brianpWins, ah! That makes *much* more sense
19:08:13 <brianpWins> oh
19:08:23 <volgoda> can you extend haskell syntax?
19:08:29 <simon> yes.
19:08:32 <brianpWins> I’m just trying to make a method that takes a Concurrent value and returns the action
19:09:23 <ski> brianpWins : inside a value of typr `Concurrent a' is stored a function of type `(a -> Action) -> Action'. this function accepts a callback of type `a -> Action', and will produce a result of type `Action', when passed such a callback function
19:09:31 <HeladoDeBrownie> brianpWins, well, a Concurrent value doesn't really have an Action to get out of it.
19:10:06 <brianpWins> ski: I understand the highlevel view of what needs to happen. I just have no clue how to implement that
19:10:13 <HeladoDeBrownie> brianpWins, it's actually the opposite, you need some way to compute an action. Concurrent a is closer to containing an a than anything.
19:10:27 <HeladoDeBrownie> (But it doesn't strictly do that either)
19:10:50 <ski> brianpWins : .. so, you need to figure out which callback functtion you want to pass
19:11:53 <brianpWins> I feel like i’m forgetting to tell you something. So that’s the data structure. The method I’m writing and why I’m saying I’m trying to “get the Action out” is because I’m attempting to implement: action :: Concurrent a -> Action
19:11:59 <hiptobecubic> At the bottom of the post he says "another equally valid instance would be..." but when I try to implement it I get `Illegal instance declaration..`  https://ocharles.org.uk/blog/posts/2014-12-13-multi-param-type-classes.html
19:12:17 <hiptobecubic> Is it a valid instance declaration or not?
19:12:39 <HeladoDeBrownie> brianpWins, well, considering Concurrent a doesn't contain an Action in any sense, it really matters what you want to do with the a. How is Action defined, incidentally?
19:12:50 <ski> brianpWins : as a member of a type class ? as some internal definition ? as a top-level module definition ?
19:13:32 <brianpWins> data Action; = Atom (IO Action); | Fork Action Action; | Stop (where semilcolor in a properlly indented line break)
19:13:40 <HeladoDeBrownie> brianpWins, what you can do is this: action (Concurrent f) = f someWayToGenerateAnActionFromAnA
19:13:55 <ski> brianpWins : if you want to define `action' on the top-level of a module, then (since it is polymorphic in the type `a'), it can't know what the type `a' actually is, and so can't inspect any values of that type
19:14:17 <Cale> brianpWins: You can leave out all the linebreaks there and it's valid
19:14:45 <Cale> (totally not important, just thought it might be good to mention)
19:14:52 <ski> brianpWins : so, one possibility would be `action (Concurrent wantsCallback) = wantsCallback (\a -> Stop)'
19:16:12 <hiptobecubic> Here is the example code. I don't see why it fails :(  http://lpaste.net/117050
19:18:25 <brianpWins> I’m not sure I follow that at all. so wantsCallback is external function that is takeing a lambda with Stop?
19:18:41 <HeladoDeBrownie> brianpWins, it's not external, it's the result of deconstructing Concurrent
19:18:46 <HeladoDeBrownie> brianpWins, notice the left side of the =
19:18:53 <brianpWins> snap yeah
19:19:07 <HeladoDeBrownie> Does "snap" mean "I just got that"?
19:19:16 <brianpWins> I see that part, overisght
19:19:19 <HeladoDeBrownie> Okay good :)
19:19:19 <ski> brianpWins : `wantsCallback' is the function that is contained in the argument to `action', of type `Concurrent a'
19:19:24 <brianpWins> I still don’t udnerstand the labmda and the Stop
19:19:51 <ski> brianpWins : `\a -> Stop' has type `a -> Action', ok ?
19:19:56 <brianpWins> yup
19:20:11 <brianpWins> but it Stop is hardcoded in the function what good is the function?
19:20:16 <HeladoDeBrownie> Good question
19:20:22 <HeladoDeBrownie> What good is this action function you're defining?
19:20:27 <HeladoDeBrownie> What *should* it do?
19:20:43 <ski> brianpWins : so, assuming `wantsCallback' has type `(a -> Action) -> Action', then `wantsCallback (\a -> Stop)' has type `Action', ok ?
19:21:17 <brianpWins> ski: ahh I see. I follow that.
19:21:58 <ski> brianpWins : as HeladoDeBrownie says, it may be more or less useful, depending on what you want to do. but anyway, even if you only use `Stop' in the callback passed to `wantsCallback', `wantsCallback' itself could also use other data constructors of `Action', to compute its rsult value
19:22:50 <ski> brianpWins : (cont.) so then `Concurrent wantsCallback' has type `Concurrent a'. and so `action' takes an input of that type, and returns an output of type `Action'. iow `action :: Concurrent a -> Action'
19:23:21 <brianpWins> ski: I /think/ I follow that.
19:23:36 <HeladoDeBrownie> Whatever parts you may not follow, feel free to ask for clarification
19:25:11 <HeladoDeBrownie> It does still seem to me you're under a mistaken impression of what this Concurrent is all about, so it'd be best if we could bring that to light so you can figure out what you're after
19:25:35 <SrPx> What is the fastest way to take an Int and get its log2 (rounded down)?
19:25:43 <HeladoDeBrownie> floor . logBase 2
19:25:47 <HeladoDeBrownie> Er
19:25:48 <HeladoDeBrownie> Yeah
19:25:58 <Axman6> :t logBase
19:25:58 <ski> brianpWins : let's define `liftIO :: IO a -> Concurrent a' as `liftIO act = Concurrent (\callback -> Atom (do res <- act; callback res))'
19:25:59 <lambdabot> Floating a => a -> a -> a
19:26:14 <HeladoDeBrownie> Oh of course
19:26:17 <Axman6> :t floor . logBase 2 . fromIntegral
19:26:18 <lambdabot> (Integral a, Integral c) => a -> c
19:26:25 <HeladoDeBrownie> SrPx, Axman6 got it :)
19:26:36 <Axman6> possibly not the best implementation though
19:26:44 <SrPx> thanks, but is that the fastest though?
19:26:58 <ski> brianpWins : the callback here conceptually describes what to do after executing the given `IO' action
19:27:08 <HeladoDeBrownie> SrPx, is the bulk of your code going to be doing that operation?
19:27:20 <SrPx> yes it is
19:27:30 <SrPx> in fact it is the only operation inside a tight loop
19:27:55 <HeladoDeBrownie> Cool, passes the "needs to be fast" check :) It's entirely possible you could get faster but usually it comes down to trial and error
19:28:11 <ski> brianpWins : so, we build an `Action' recipe, that tells the interpreter that we at this point want to execute an `IO'-action, namely one that starts by executing the argument `act', and then continue executing the callback (passing on the result from `act' to it)
19:28:35 <ski> brianpWins : sorry, `callback res' should be `return (callback res)' there
19:28:47 <ski> brianpWins : does this make sense ?
19:28:55 <Luke> What's the diff between IORef and MVar? What are the tradeoffs of each?
19:29:06 * HeladoDeBrownie tries to think of how to approach optimizing that
19:29:11 <ski> brianpWins : also .. are you reading Koen Claessen's "Poor Man's Concurrency Monad" ?
19:29:16 <Axman6> SrPx: you might be able to modify http://www.java2s.com/Tutorial/Java/0120__Development/Calculatethefloorofthelogbase2.htm
19:29:55 <Axman6> hmm, that's a pretty obvious algorithm, a bit boring
19:29:59 <brianpWins> ski I don’t follow anymore, Completly lost. Although I think we may have gone further then I need atm. I’m not reading that but I wouldn’t be surprised if it’s based off that.
19:30:06 <Axman6> I wish I had my copy of hacker's delight here
19:30:09 <HeladoDeBrownie> Hmm, relies on Java bitshifting behavior, which may or may not be optimized in Haskell
19:30:17 <ski> Luke : an `MVar' can be empty. attempting to read an empty one blocks. attempting to put a value in a full one blocks. `MVar's automatically work fine with concurrency (built-in mutex locks)
19:30:24 <HeladoDeBrownie> Axman6, I have that book, do you know what chapter?
19:30:33 <Axman6> HeladoDeBrownie: no
19:30:40 <HeladoDeBrownie> I'll glance through it
19:30:46 <Axman6> but it should have an index, just look for log
19:30:48 <ski> brianpWins : ok, it's fine. you possibly need more time to play with it (and perhaps sleep on it)
19:31:32 <HeladoDeBrownie> Axman6, SrPx, oh cool, Hacker's Delight does indeed have something for exactly this
19:31:42 <HeladoDeBrownie> Reading now
19:31:45 <Axman6> thought it would
19:32:01 <ski> Luke : an `IORef' can't be empty. you can use `atomicallyModifyIORef' to safely use it concurrently (probably more efficient than `MVar's), but `MVar's are more flexible
19:32:43 <SrPx> hacker's delight? Axman6 thanks
19:32:51 <brianpWins> ski: Thanks, Yeah I need to play with it a bit. Which I will now. I’ll probably be back with more questions once I get a little bit more about it
19:32:53 <SrPx> not sure how I can translate that efficiently, though, but I will try (:
19:33:06 <ski> brianpWins : ok
19:33:10 * ski will go to sleep soon
19:33:17 <HeladoDeBrownie> SrPx, Axman6, its algorithm relies on using an n-bit binary representation, and then you simply subtract the number of leading zeroes from one less than the number of bits.
19:33:36 <Axman6> sounds good to me
19:34:01 <SrPx> isn't there an asm op for "the number of leading zeroes"
19:34:17 <Axman6> possibly
19:34:22 <Axman6> depends on your CPU
19:34:47 <SrPx> interesting
19:36:02 <HeladoDeBrownie> SrPx, woops, forgot to specifiy *unsigned*
19:36:07 <HeladoDeBrownie> specify*
19:36:10 <Luke> ski: thanks a lot
19:36:24 <SrPx> we know!
19:36:26 <Axman6> x86 seems to have lzcnt
19:36:37 <HeladoDeBrownie> Okay, just wanted to clarify just in case
19:37:00 <Axman6> http://en.wikipedia.org/wiki/Find_first_set
19:37:02 <johnchang> I have a large list (~20000 entries) I’d like to include as data in a Haskell program. How can include I it without it dominating the rest of the file? Save it in a separate .hs file and import it?
19:37:14 <Luke> ski: that was a great overview. I was looking for the essence of when to use what and you nailed it. thanks a lot
19:37:39 <HeladoDeBrownie> johnchang, you could do that, or else possibly parse it from an external file. They involve different tradeoffs.
19:38:35 <HeladoDeBrownie> johnchang, for example, in your proposed solution it would become part of the binary.
19:38:53 <HeladoDeBrownie> Whereas with what I said, you'd need to include it with the program when distributed if applicable.
19:39:03 <HeladoDeBrownie> Or else have some other way to obtain it.
19:42:07 <johnchang> I think I’ll just import it; less hassle to distribute. Not having done this before, are there namespace issues? If the filename is say database.hs, and the list is called db, will I have to import database, then call the list database.db?
19:43:05 <SrPx> Okay guys, I made this tail-recursive so it doesn't build a stack but I'm not sure Haskell actually cares for this... how can I compare both versions for performance ? http://lpaste.net/117052
19:43:23 <HeladoDeBrownie> johnchang, usually file naming and hierarchy follows module naming and hierarchy. So, a module named Foo will be in a file named Foo.hs.
19:43:42 <HeladoDeBrownie> johnchang, this is actually enforced to a degree by GHC, and usually isn't worth working around.
19:43:59 <HeladoDeBrownie> johnchang, module names are upper case, so so should the file name be.
19:44:49 <HeladoDeBrownie> johnchang, to import it, either "import Database" and then just refer to db or "import Database (db)" and do the same. There are some other ways but those will probably be fine.
19:44:53 * hackagebot egison 3.5.0 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.5.0 (SatoshiEgi)
19:45:30 <luite> SrPx: that will actually still stack overflow with a big enough input (bigger than fits in an Int admittedly), you've replaced one leak with another
19:45:39 <Axman6> SrPx: seems like a reasonable start to me
19:45:40 <johnchang> So then the database file will start with “module Database where” and be named Database.hs.
19:45:54 <HeladoDeBrownie> johnchang, correct.
19:46:11 <johnchang> Great! Thank you HeladoDeBrownie.
19:46:15 <HeladoDeBrownie> No problem
19:46:25 <Axman6> HeladoDeBrownie: can you have a look at chapter 5 of HD and see if it has a nice count leading zeros implementation? or a nice log_2 implementation? you said you found something
19:46:43 <SrPx> luite: hm that is okay? I'm not trying to avoid the stack for this, but for performance
19:46:45 <HeladoDeBrownie> Axman6, kay
19:47:11 <Axman6> SrPx: you probably want to add a bang pattern to n in your function to make sure it's not making a (64 element) large funk
19:47:36 <SrPx> a (64 element) large funk?
19:47:42 <luite> SrPx: you're never forcing the 'n' argument, so it will keep building a thunk: ((((((-1) + 1) + 1) + 1) + 1) + 1) etc
19:47:43 <Axman6> so go 0 n -> go 0 !n and add {-# LANGUAGE BangPatterns #-}
19:47:50 <Axman6> thunk even
19:48:08 <luite> SrPx: when ghc force that, it will use stack for that
19:48:28 <luite> just as much as your original function probably
19:48:56 <SrPx> oh that happens?
19:48:57 <SrPx> okay
19:49:24 <luite> SrPx: this is probably worse for performance, heap allocation is more expensive, this first expands the thunk on the heap, then later uses stack when forcing it
19:49:58 <Axman6> yes, n is a value that isn't evaluated until after log2 returns, and before it is evaluated it sits in memory as basically an expression tree
19:50:03 <Axman6> (sort of)
19:50:16 <Axman6> adding bang patterns will fix that though
19:50:18 <SrPx> just a quick stop, how can I benchmark it?
19:50:34 <luite> SrPx: but if you're lucky, ghc will see that the 'n' is always demanded (with optimization), and it'd be able to get rid of the intermediate allocation and stack
19:50:46 <HeladoDeBrownie> Axman6, SrPx, I transcribed one of the algorithms from HD: http://lpaste.net/117054
19:50:49 <Axman6> criterion is the obvious choice if you really case about accurate benchmarking (it's not that hard to use)
19:51:14 <SrPx> that one seems easier to get right
19:51:20 <luite> SrPx: but to be safe, follow Axman6's advice and make it force n every step
19:51:35 <SrPx> sure I will, but how do I test it guys...
19:51:56 <Axman6> criterion...
19:52:11 <SrPx> woops
19:52:12 <brianpWins> ski: So it is the poor mans concurrency model. And the Lift you gave me was the next step
19:52:16 <brianpWins> so i’m looking at it now
19:52:16 <SrPx> Axman6: sorry, thank you
19:53:39 <Axman6> HeladoDeBrownie: that seems longer that I'd expect from HD, especially given how much branching it has. it doesn't go on to improve on that?
19:54:01 <HeladoDeBrownie> Axman6, it has some other variations but doesn't note them specifically as improvements
19:54:17 <Axman6> anything with less branching?
19:54:34 <HeladoDeBrownie> Checking
19:55:06 <HeladoDeBrownie> Ah, you're right, it has a branch-free one
19:55:10 <HeladoDeBrownie> I'll add that to the lpaste
19:57:37 <ski> brianpWins : .. you can write I/O programs directly in terms of `Action' .. but every such program is a complete program, that either continues indefinitely, or ends with a `Stop' (for some or all forked "threads")
19:58:31 <ski> brianpWins : so, it is hard to write *composable* programs here. e.g. you can say `putStrLn :: String -> Action -> Action', so that `putStrLn' takes a callback action (what to do after outputting the string=
19:58:41 <ski> s/=/\)/
19:59:11 <brianpWins> Most the input being thrown at it is stuff like: action . atom . putStrLn $ "Haskell"
19:59:40 <HeladoDeBrownie> Axman6, SrPx, updated http://lpaste.net/117054
19:59:55 <ski> brianpWins : in the case of `getLine', you can use `(String -> Action) -> Action'. .. so one way to view the `Concurrency' data type is as a thin wrapper over this "callback-passing" (really continuation-passing) *style* of using `Action'
20:00:20 * SrPx is amusing himself with criterion, brb HeladoDeBrownie 
20:00:27 <Axman6> HeladoDeBrownie: HD also includes branchless implementation of pop =)
20:00:29 <HeladoDeBrownie> Axman6, SrPx, hmm, that's not the best pop it gives actually. I am skimming too much I think :P
20:00:38 <Axman6> yes :P
20:00:50 <Axman6> the _best_ pop is using popcnt, but that's not portable
20:01:16 <HeladoDeBrownie> It has one with a hard-coded lookup table
20:01:22 <HeladoDeBrownie> Oh, and one better
20:01:31 <HeladoDeBrownie> Okay I'll replace it
20:01:54 <Axman6> it can easily be written using log2(b) steps, where b is the number of bits
20:02:41 <HeladoDeBrownie> Axman6, SrPx, updated again http://lpaste.net/117054
20:03:00 <HeladoDeBrownie> This is black magic
20:03:11 <Axman6> yes
20:03:43 <SrPx> (this is the result of the benchmark though, seems like the bithack recursive function isn't as good as converting to floats who'd guess)
20:04:14 <SrPx> HeladoDeBrownie: I'm lost at this point
20:04:21 <HeladoDeBrownie> SrPx, you're not alone
20:04:36 <HeladoDeBrownie> SrPx, do you know C? That's a requirement to understand that code
20:05:37 <SrPx> yea
20:06:11 <Axman6> HeladoDeBrownie: that code looks wrong, it assigns y twice so the first assignment is lost
20:06:30 <HeladoDeBrownie> Axman6, each assignment to y after the first relies on the previous y
20:06:42 <SrPx> I just don't get, there are two versions of nlz... the second one is supposed to be better? I don't know why they are equivalent
20:06:48 <HeladoDeBrownie> Axman6, oh I see which you mean
20:06:49 <SrPx> which is pointless to say as I don't even know why they work
20:06:51 <Axman6> HeladoDeBrownie: also, that code won't work for 64 bit Int
20:06:53 <HeladoDeBrownie> I must have mistyped
20:07:29 <SrPx> there it is: viclib.com/Haskell/aff.html
20:07:39 <SrPx> damn. http://viclib.com/Haskell/aff.html
20:07:50 <HeladoDeBrownie> Fixed. I wrote x when I meant y. http://lpaste.net/117054
20:07:58 <SrPx> oh wait
20:08:05 <SrPx> I read it wrong, my version is actually better yay
20:08:23 <HeladoDeBrownie> Axman6, SrPx, yeah, it won't work as-is for Haskell Int, you'd need some of the Word types
20:08:34 <HeladoDeBrownie> From Data.Word
20:08:49 <HeladoDeBrownie> Alternatively you can drop down to C and use these functions directly
20:10:12 <HeladoDeBrownie> SrPx, you can use Data.Word.Word32 and Data.Word.Word64 along with methods of the Bits typeclass to implement these in Haskell.
20:11:25 <HeladoDeBrownie> SrPx, the first version of nlz I included first, the second one is an improvement. I can remove the worse one from the paste if it makes things less confusing
20:12:30 <HeladoDeBrownie> I'm not going to reproduce the bulk of the text in that paste, if you want to go through the steps I advise you to find a copy of Hacker's Delight
20:13:06 <SrPx> I guess I will
20:13:20 <SrPx> I didn't know of that existence
20:13:30 <brianpWins> HeladoDeBrownie: Not sure How I’m supposed to get do fork :: Concurrent a -> Concurrent () . getting a return of Concurrent () doesn’t make sense to me where the datatype is already defined.
20:13:51 <Axman6> SrPx: it's a fantastic book
20:13:55 <HeladoDeBrownie> brianpWins, hmm, sorry, I lost track of where you were on this problem, let me read the scrollback
20:14:14 <HeladoDeBrownie> brianpWins, maybe ask ski who is more up to date since they were helping you more recently
20:14:18 <brianpWins> np
20:14:51 <SrPx> just wondering guys, what is the exactly translaction of the sequence of assignments to x inside the nlz? Should I just use a recursive let binding like that? "let x0 = ...; x1 = ..."?
20:14:59 <SrPx> the exact translation *
20:15:07 <HeladoDeBrownie> SrPx, seems reasonable
20:15:15 <SrPx> okay
20:16:32 <HeladoDeBrownie> brianpWins, hmm, so what is your fork function supposed to do?
20:17:11 <brianpWins> “In order to access Fork, we need to define two operations. The first, called fork :: Concurrent a -> Concurrent (), forks its argument by turning it into an action and continues by passing () as the input to the continuation”
20:18:48 <HeladoDeBrownie> brianpWins, not quite sure what the context of that quote is, but I think I get what it's after. So you've got the Fork constructor, right? What does it represent?
20:19:20 <brianpWins> Fork Action Action
20:19:22 <brianpWins> ?
20:19:42 <HeladoDeBrownie> Right. What does it represent?
20:20:10 <HeladoDeBrownie> (I'm asking so you can think through the solution)
20:21:17 <brianpWins> ohhh. Um a divergence in execution? I’m not sure tbh
20:21:23 <HeladoDeBrownie> Sure, sounds right
20:21:30 <HeladoDeBrownie> What are the two Actions provided to the constructor?
20:22:38 <brianpWins> action (fork (atom (putStr "Hacker")))
20:22:49 <HeladoDeBrownie> No, I mean what are they for?
20:23:05 <HeladoDeBrownie> What does the first Action represent and what does the second one represent?
20:23:20 <brianpWins> oh uhhhh. One for later execution and one to halt the current line of execution?
20:23:22 <SrPx> guess I'm doing something wrong, it didn't work :( http://lpaste.net/117064
20:23:31 <arnoblalam> Hi all
20:23:38 <arnoblalam> an Aeson question for you
20:23:41 <SrPx> (I gave up on trying to implement the second version)
20:23:46 <HeladoDeBrownie> brianpWins, I don't think it's quite that, or possibly you're thinking at too low a level of abstraction
20:23:53 <arnoblalam> I have a JSON object of the type
20:24:22 <HeladoDeBrownie> brianpWins, so most thread models have this fork operation where you say what the new thread should execute, and then the current thread continues executing
20:24:41 <HeladoDeBrownie> brianpWins, so in that case what do you need two Actions for?
20:24:50 <arnoblalam> {“name”: “queue name”, “push_status”: {“retries_remaining” : 10}}
20:25:13 <SrPx> ah forgot a line but still nope
20:25:22 <HeladoDeBrownie> SrPx, use Word types, not Int
20:25:24 <brianpWins> first says what the new thread should do while the second says what to continue doing?
20:25:27 <arnoblalam> however, sometimes, I will have an object like so: {“name”: “queue name”, “push_status”: {}}
20:25:32 <HeladoDeBrownie> SrPx, Word32 is equivalent to C's unsigned
20:25:37 <HeladoDeBrownie> brianpWins, yep!
20:26:08 <HeladoDeBrownie> brianpWins, so, your fork function accepts a Concurrent a. What is that going to be?
20:26:18 <SrPx> still nothing http://lpaste.net/117064
20:26:32 <SrPx> I'm seeing all blurry at this point of night tho guess I need to rest (:
20:26:37 <brianpWins> oh, it should by a Fork Action with two actions inside it
20:26:42 <brianpWins> by = be
20:26:49 <arnoblalam> how can I get aeson to return Queue {name = “queue name”, push_status” = PushStatus {retires_remaining = 10}} in the first case
20:27:00 <HeladoDeBrownie> brianpWins, the argument? It could be any Concurrent a whatsoever
20:27:08 <arnoblalam> and Queue {name = “queue name”, push_status” = Nothing} in the second case?
20:27:22 <HeladoDeBrownie> SrPx, might be a good idea, these algorithms are somewhat mind-bending. I suggest reading the book they're from and working through them.
20:27:41 <SrPx> fair enough
20:27:46 <SrPx> good night, thanks guys ! (:
20:27:49 <HeladoDeBrownie> SrPx, have fun
20:27:50 <SrPx> that was fun
20:27:51 <SrPx> cya
20:28:38 <HeladoDeBrownie> brianpWins, hmm, can you make an lpaste with a list of the operations you're implementing? Might make it easier for me to point things out to you
20:28:53 <brianpWins> yup 1 minute
20:29:54 * hackagebot serial-test-generators 0.1.3 - Test your 'Aeson' 'Serialize' and 'Binary' instances for stability over time  http://hackage.haskell.org/package/serial-test-generators-0.1.3 (scottmurphy09)
20:30:43 <HeladoDeBrownie> Although I need to go soon, I'm getting up at a reasonable hour tomorrow morning :P
20:31:09 <brianpWins> HeladoDeBrownie: http://lpaste.net/117066
20:31:17 <brianpWins> HeladoDeBrownie: anny of these could be expected to fail though
20:31:40 <HeladoDeBrownie> brianpWins, I'm not sure what to do with those. I mean the types of things like fork and action and whatever other operations are permitted all in one convenient place
20:32:54 <brianpWins> HeladoDeBrownie: updated
20:33:12 <HeladoDeBrownie> brianpWins, okay cool
20:33:45 <HeladoDeBrownie> brianpWins, so, you already know a few things about fork
20:33:58 <HeladoDeBrownie> For one thing, its body will be: Concurrent … for some …
20:34:24 <HeladoDeBrownie> What else do you know about it?
20:34:44 <brianpWins> I have some feeling it’s go to do with IO as thats the only time I see the () return value
20:35:21 <HeladoDeBrownie> It's actually quite general, not IO-specific
20:35:23 <batchm> :t deepseq
20:35:24 <lambdabot> Not in scope: ‘deepseq’
20:35:43 <HeladoDeBrownie> So you know the Fork constructor will be involved, right?
20:35:46 <batchm> rnf :: NFData a => a -> ()
20:35:58 <batchm> ^^ returns (), doesn't have anything to do with IO
20:36:09 <HeladoDeBrownie> batchm, that's black magic :P
20:36:34 <brianpWins> HeladoDeBrownie: Yup but I’m not totally sure how. I’ll likely take whatever was passed in Conccurent and move in into the first param for the Form constructor
20:37:20 <HeladoDeBrownie> brianpWins, you already have a binding that's similar to this one that you can take a cue from, do you see which one?
20:37:51 <brianpWins> Nope. You lost me
20:38:06 <HeladoDeBrownie> brianpWins, you have another function returning a Concurrent value, what is it?
20:38:20 <brianpWins> stop and atom
20:38:26 <HeladoDeBrownie> stop is not a function
20:38:29 <HeladoDeBrownie> atom! That looks useful
20:38:34 <HeladoDeBrownie> Let's copy some of the structure from that
20:38:40 <brianpWins> stop is a function
20:38:49 <brianpWins> stop :: Concurrent a
20:38:50 <brianpWins> stop = Concurrent (\x -> Stop)
20:38:53 <HeladoDeBrownie> It's not, functions are values constructed with (->)
20:39:04 <HeladoDeBrownie> It's a piece of data containing a function though
20:39:18 <brianpWins> oh
20:39:22 <HeladoDeBrownie> Anyway my point was we can write something looking like atom
20:39:36 <HeladoDeBrownie> Go ahead and sketch that out in the lpaste and leave ... where the rest needs to go
20:39:48 <HeladoDeBrownie> In other words, use only the structure from atom that also applies to this one
20:39:54 <HeladoDeBrownie> Does that make sense?
20:40:46 <brianpWins> No, only because I can’t seem to create a Concurrent that has only () as it’s value.
20:40:52 <Fare> any frege users around?
20:41:11 <HeladoDeBrownie> We're not even worrying about the () part yet
20:41:14 <arnoblalam> ?
20:41:36 <flebron> Hi. When profiling, what does the column "entries" in the .prof file mean?
20:42:30 <HeladoDeBrownie> brianpWins, do you need more of a nudge?
20:43:03 <brianpWins> yeah
20:43:19 <brianpWins> I tried
20:43:19 <brianpWins> fork (Concurrent a) = Concurrent (\callback -> Fork a Stop)
20:43:36 <HeladoDeBrownie> brianpWins, you actually got past the step I wanted you to get to :)
20:43:55 <HeladoDeBrownie> brianpWins, I was hoping you'd get at least this far: fork c = Concurrent (\callback -> ...)
20:44:05 <HeladoDeBrownie> But okay
20:44:28 <HeladoDeBrownie> So yeah, the part you're stuck on then is the second argument to Fork
20:44:34 <HeladoDeBrownie> The rest looks right to me
20:44:51 <Axman6> flebron: probably the number of times it was seen in the call stack
20:45:02 <HeladoDeBrownie> Um, one sec, I'm actually slightly stumped myself
20:45:05 <Axman6> or, the number of itmes it was seen anyway
20:45:19 <bms1> Fare: I used Frege briefly several months ago
20:45:37 <HeladoDeBrownie> brianpWins, were you provided the Action type as-is?
20:45:45 <brianpWins> yup
20:46:11 <HeladoDeBrownie> brianpWins, oh of course, I've got it now
20:46:37 <HeladoDeBrownie> brianpWins, so, you actually know the type of that callback variable. What is it?
20:46:52 <brianpWins> Action
20:47:15 <HeladoDeBrownie> brianpWins, not quite. The parameter of the lambda. Look again at the definition of Concurrent, it will tell you.
20:47:32 <HeladoDeBrownie> Keep in mind that you are constructing a Concurrent () in this function
20:48:01 <brianpWins> Oh wait is the () return type just saying it needs a fucntion returned ?
20:48:27 <HeladoDeBrownie> No, () is the unit type. It's the type with exactly one constructor, ().
20:48:29 <Zemyla> Oh, hey, this thing is exactly what I've been looking for for so long. http://hsenag.livejournal.com/11803.html
20:48:49 <Zemyla> It's a way to make type-restricted monads.
20:48:51 <brianpWins> so I got it to work but i really don’t know how/why
20:48:53 <brianpWins> fork a = Concurrent (\callback -> Fork (action a) Stop)
20:49:11 <HeladoDeBrownie> brianpWins, that doesn't look to have the right semantics
20:49:46 <Zemyla> For instance, monads that require them to implement Ord.
20:50:08 <HeladoDeBrownie> brianpWins, actually I'm still confused about this action function for that matter.
20:50:31 <glguy> Where's the fork/action/stop exercise from? I've seen it come through here before
20:50:32 <roboguy_> Zemyla: there's a library for that https://hackage.haskell.org/package/rmonad
20:51:26 <HeladoDeBrownie> brianpWins, unfortunately I need to go. Hopefully someone else can help you further. I'll leave you with a hint: you know, ahead of time, exactly what value needs to be applied to callback, because it is the only value that can be.
20:51:43 <HeladoDeBrownie> brianpWins, furthermore, you *need* to use callback in the body of the lambda.
20:51:51 <brianpWins> kk, Thanks HeladoDeBrownie !
20:51:52 <HeladoDeBrownie> brianpWins, so where/how can you use it?
20:51:57 <HeladoDeBrownie> Anyway, good night~
20:54:09 <Fare> I would like to build a python-y syntax on top Frege. What tools exist for that? Do haskell meta-programming tools work with Frege?
20:54:19 <Fare> how different is Frege from Haskell?
20:55:16 <recursion-ninja> Hey Guys, I wrote an algorithm which I assumed to be very lazy, lazy enough that it should use constant to pseudo-linear memory. Upon execution on some sample data set (not even stress-test sets) the algorithm ballooned memory to over a GB (unreasonable). Is there a good profiling technique to note what "objects" where are consuming all this space?
20:55:30 <benzrf> night
20:56:08 <roboguy_> Fare: hmm, python-y in what way? If it's a lot like Haskell, it's hard for me to imagine it having a syntax layer over it that is much like Python
20:56:49 <roboguy_> recursion-ninja: ghc comes with a builtin profiling tool. You can enable it with -prof -auto-all
20:57:32 <Fare> also, if some functional compiler experts are around, there's one pass of my compiler where I'm stuck, after analyzing which variables are used, where they come from and where they're going to, I have to transform the pseudo-imperative code in functional code, if possible using the minimum monad for each statement, and I'm not sure exactly how to do that
20:57:51 <roboguy_> recursion-ninja: there's some info on it here http://stackoverflow.com/questions/3276240/tools-for-analyzing-performance-of-a-haskell-program
20:57:55 <Fare> roboguy_, I don't see any problem with a python syntax, that I'm almost done "functionalizing"
20:58:31 <recursion-ninja> roboguy_: I tried `cabal configure --enable-executable-profiling` butt when I run `./progName +RTS p` I get a wrong compilation error
20:58:41 <roboguy_> Fare: well, it's just that Haskell already has the whitespace sensitive "off to the side" rule like Python and all the other features I can think of seem like they'd be tricky to directly translate to Haskell (or Haskell-like) code
20:59:08 <roboguy_> recursion-ninja: try ./progName +RTS -p
20:59:57 <Fare> I was a bit worried that the thing ought to still work if you don't declare types, but I'm hoping that haskell will let me translate def's into let's with properly alpha-converted variables
21:00:03 <recursion-ninja> roboguy_: I did but I get `the flag -p requires the program to be built with -prof`
21:00:43 <recursion-ninja> I've tried this several times on different platforms and have troubles profiling programs built with cabal
21:00:45 <roboguy_> recursion-ninja: I've never been able to get profiling to work with cabal in that way, for some reason. It works if I add -prof -auto-all to the GHC options in the cabal file (it gives a warning which makes me think there's another way, but I haven't found it so far)
21:00:50 <Zemyla> roboguy_: Yeah, but I didn't find it until today.
21:01:03 <Fare> roboguy: I have a python parser; I have (most of) the transformation of this pure python dialect into a functional program (currently targetting clojure), but the same program could emit haskell ASTs instead of clojure SEXPs.
21:01:17 <recursion-ninja> roboguy_: GRRR! why does cabal even have that ption then?
21:01:32 <roboguy_> recursion-ninja: I'm sure it works *some* how, but I don't know how
21:02:07 <roboguy_> Fare: hmm, which pass is the one that's giving you trouble?
21:03:16 <roboguy_> also, what do you have in mind with the minimum monad usage thing?
21:03:56 <Fare> roboguy: the monadization.
21:04:07 <nshepperd> Zemyla: http://okmij.org/ftp/Haskell/set-monad.html describes a few other ways of making a set monad
21:04:16 <recursion-ninja> roboguy_: well, putting the dirrect GHC options in seems to work
21:04:40 <roboguy_> recursion-ninja: some day I need to find out what the right way is, haha
21:05:06 <recursion-ninja> roboguy_: thanks for vindicating my perpetual frustraion by sharing it doesn't work for you either
21:05:11 <roboguy_> Fare: hmm, I might be able to help some. Which part in particular are you stuck at?
21:05:29 <roboguy_> recursion-ninja: haha, certainly!
21:05:33 <Fare> basically a if foo: a=1; b=2\nelse: b=1; c=3 must be translated into let (a,b,c) = if foo (1,2,c) else (a,1,3) --- except that the body itself might be in a monad
21:06:05 <Fare> I suppose I haven't figured out the state of my tree-transformation monad
21:06:16 <roboguy_> Does this language have full mutation?
21:06:42 <nshepperd> Zemyla: the final example, the continuation passing style with (reflect . reify) seems most applicable to arbitrary restricted-monads
21:06:57 <Fare> no, not at all. "mutation" is just shadowing and SSA unification
21:07:20 <Fare> no mutation outside the current scope, where it's translated into shadowing and choice
21:08:26 <roboguy_> Fare: if it's in a monad what about something like: (a, b, c) <- if foo then ... (1,2,c) else ... (a,1,3)?
21:08:26 <Fare> I have all the analyses I need, which variable is defined where and used where, and which effects happen in which expressions of blocks.
21:08:47 <Fare> roboguy: yes, except that I'm trying to make it the "least monad"
21:09:03 <roboguy_> what is the least monad?
21:09:49 <Fare> some expressions throw exceptions, or do a local return, or catch exceptions, or do I/O, etc.
21:10:11 <Fare> I want to find the least monad in each case
21:10:53 <Fare> for higher-order functions, I might have to make an optimistic or pessimistic hypothesis on the monad of the argument, unless explicitly overridden
21:11:42 <roboguy_> I'm not sure I understand... wouldn't that only come into play if you are trying to write out the type signature, not in the actual body?
21:13:35 <Fare> actually, the current python subset I'm trying to extend into a haskell-with-python-syntax doesn't have exceptions, just a global error monad, so I could make assumptions to that effect on functions. Most of them don't have any side-effect either, though some accumulate write-only data (from the function's point of view... it's read by the consumer after the program is done)
21:14:38 <brianpWins> I need help currying.
21:14:50 <brianpWins> trying to write something like: par :: Concurrent a -> Concurrent a -> Concurrent a
21:14:52 <Fare> roboguy: if I want to compose "python-y functions", I must know which monad the two "functions" actually live in, and unify in the least common super monad
21:15:07 <brianpWins> and just can’t seem to get the types right, I keep returning Concurrent a0 instead of a.
21:15:17 <Zemyla> nshepperd: The next-to-last one actually looks like it would work well for my probability distribution monad.
21:16:16 <Fare> it's that "least common super monad" I'm not fully sure yet how to implement. Maybe I need a more bottom up approach where I start all the functions that make sense, until I get a hang of how to reach the goal
21:16:20 <roboguy_> Fare: couldn't you use lift for most of those things, and build up a monad transformer stack?
21:16:34 <Fare> instead of trying to engineer the goal top-down from a few examples of the result
21:17:41 <Fare> roboguy: yes, that's about what I'm trying to do, but if function f uses stack M O and function g uses stack M N, I'd like the notional f o g to use stack M N O.
21:17:53 <Zemyla> brianpWins: You probably need either parentheses around one of your arguments or a $ on your last argument.
21:18:16 <Fare> assuming the transformers in my stack have a canonical order.
21:18:42 <Fare> and I'm cherry-picking those I need for the function (or code block) at hand
21:19:14 <Fare> it's something I've wanted to do for the longest time
21:19:25 <Myrl> brianpWins: ...
21:19:45 <Myrl> brianpWins: You're doing that concurrency monad?
21:19:50 <brianpWins> yeah
21:19:53 <Fare> and now I'm almost there... although each time I thought I was almost there, I realized I needed to add a new pass to the compiler
21:20:14 <brianpWins> well. I /think/ I’ve just been following along the assignment and other peoplehave recongized it
21:20:39 <Fare> for instance, I know that I'll have to do A-normal form at some point, but I've been trying to procrastinate on it
21:21:51 <Fare> but if I want "macros" to expand to arbitrary code with potential side-effects, I kind of need to already have done A-normal form by now.
21:22:18 <Fare> yet even assuming A-normal code, I'm not sure how to do the least-monad thing
21:22:54 <brianpWins> Oh i think i got it
21:23:04 <bms1> Fare: to answer a question you asked a long time ago, Haskell meta-programming tools do not work with Frege
21:23:50 <Fare> bms1: thanks for the answer. Does Frege have any metaprogramming tools? I suppose at worst, it's always possible to open the implementation and frob bits, but knowing that someone else did it would be reassuring
21:24:37 <Fare> I already have to battle with colleagues to tell them to not reinvent a (bad) typed lazy pure functional language when there is a good one, and that if they want python syntax, they can have it
21:24:48 <bms1> Fare: not that I know of, but I'm not terribly familiar with Frege
21:24:59 <bms1> Is there a reason not to write your compiler in Haskell? Do you need the JVM?
21:25:12 * Fare makes a note to ask on the Frege mailing-list
21:25:46 <roboguy_> Fare: Have you looked into monad transformers before?
21:25:54 <Fare> roboguy: I know the theory
21:26:01 <Fare> I admit I have little practice
21:26:46 <roboguy_> Fare: Maybe you could give me a concrete example of something that would have this problem? Unless I'm misunderstanding (which is very possible), it seems like transformers would take care of majority of the issues (assuming Frege has them)
21:26:54 <Fare> roboguy: of course, it's exactly what I want, except that I need the code generator to generate the exact combination required by unpeeling the stack and re-peeling it.
21:27:29 <roboguy_> Fare: I feel like the lift method would take care of most of that, but I might not be completely understanding
21:27:34 <Fare> roboguy: yes, monad transformers are the exact thing I need. But from the idea to the implementation... I suppose I just have to dig further into the code.
21:27:41 <roboguy_> :t lift
21:27:42 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
21:28:13 <Fare> so yes, plenty of lifting ahead
21:28:17 <bms1> I will admit that I didn't end up using Frege for long because its performance was much worse than GHC (which is obviously understandable, but something to keep in mind)
21:28:27 <roboguy_> Fare: also, I feel like the monad morphism library would help: http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html
21:28:40 <Fare> roboguy_: thanks
21:28:48 <roboguy_> np!
21:29:14 <bms1> If you want to compile to a lazy functional language, I would strongly suggest Haskell over Frege
21:29:39 <Fare> I suppose one of my issues was that I was using clojure initially, with my own monads, and such
21:31:51 <Fare> roboguy: my problem is more something like (MonadTrans t1, MonadTrans t2, MonadTrans t3, Monad m) => t1 t3 m a -> (a -> t2 t3 m b) -> t1 t2 t3 m b
21:32:27 <Fare> except automatically generating all the variants for a stack of length N
21:32:39 <jle`> does the kleisli cokleisli arrow bug anyone else for some reason
21:32:56 <jle`> (Monad m, Comonad w) => w a -> m b
21:33:08 <jle`> it's like a cokleisli arrow, except the function returns `m b` instead of b
21:33:14 <jle`> so it's a kleisli cokleisli arrow
21:33:23 <jle`> it's like a cokleisli arrow with monadic effects
21:33:42 <jle`> it's just weeeiiiiiird ok ;_;
21:34:33 <Fare> actually, the t3 can be factored away, so I only have a series of common t_i, common lack of t_i, and cases with just t1 and t2 one way or the other
21:35:15 <Fare> the generation of the lifts should thus be relatively straightforward (though somewhat painful)
21:36:02 <Fare> thanks for letting me bounce my ideas on you
21:36:02 <flebron> If I have a bang-pattern in a where declaration, so f x = g where !y = ..., is y going to be evaluated before g?
21:36:08 <Zemyla> What is a comonad?
21:36:30 <flebron> Zemyla: It's what you get when you invert the arrows in the categorical definition of a monad.
21:36:44 <simon> Zemyla, http://stackoverflow.com/questions/8428554/what-is-the-comonad-typeclass-in-haskell
21:36:49 <jle`> um for the sake of this discussion you can think of...if Monad functions are based around composing a -> m b's, Comonad functions are based around composing w a -> b's
21:37:05 <flebron> A monad has a natural transformation I^2 -> I, and 1 -> I. A comonad has natural transformations I -> I^2, I -> 1.
21:37:21 <jle`> if you have a lot of (a -> m b)'s you want to compose in a meaningful way, then you use Monad
21:37:32 <jle`> a -> Maybe b with a b -> Maybe c, for example
21:37:45 <jle`> if you have a lot of (w a -> b)'s that you want to compose in a meaningful way, you use Comonad
21:38:01 <bms1> Fare: Is there a reason you don't want to have just one big datatype for your target language within Haskell, rather than mess with monad transformer stacks?
21:38:18 <bms1> It just means you have to be disciplined as a compiler writer
21:38:39 <bms1> But you can still make your pythonic language work as you wish
21:39:01 <Fare> that's my first real compiler, and I admit I wholly lack discipline :-/
21:39:04 <Fare> trying to learn it
21:39:57 <Fare> bms1: maybe I should just "always use the biggest monad, and let the backend optimize away", but that feels gross, and not really what I want
21:40:10 <Fare> I really want side-effect control, hence least-monad
21:40:28 <Fare> the whole point of using a mostly-pure language is side-effect control.
21:41:06 <bms1> Fare: My point (though perhaps heretical on #haskell) is that it may be easier for you to not have these restrictions on your target language
21:41:16 <bms1> You can still offer side-effect control in your pythonic language
21:41:31 <roboguy_> that's what I would suggest too
21:42:10 <roboguy_> that's why code generators usually generate code in a low-level language (including ghc)
21:42:11 <Fare> or maybe it's enough to infer the least monad, but always implement for the most monad and just use the inferred monad for the sake of side-effect constraint enforcement.
21:42:36 <Fare> bms1: in this case, the restrictions are the entire point of the exercise
21:42:53 <bms1> Fare: Exactly - you can implement a sort of typed effect system in the pythonic language
21:42:56 <roboguy_> Fare: you can't just type check in your language?
21:43:09 <roboguy_> before code generation
21:43:25 <Fare> we want to be able to say "this function is pure", or "this function can output-only this kind of stuff", or "this function can input this kind of stuff and output that kind of stuff, and that's all".
21:43:29 <bms1> Fare: by the way, you might want to draw inspiration from the Koka language http://research.microsoft.com/en-us/projects/koka/
21:44:11 <Fare> roboguy: *my* point is to convince my colleagues to NOT reinvent their own bad, incoherent type system, but lift the haskell type-system from a syntactic transformation.
21:44:34 <Fare> type-systems are not something for the amateur to design.
21:45:20 <Fare> except I'm stuck at the part of the syntactic transformation that deals with monads.
21:45:33 <Fare> and I'd rather not punt
21:46:00 <bms1> Also, perhaps you can take the extensible-effects strategy
21:46:05 <Fare> actually the not-punting on the least-monad thing is an old ambition of mine that pre-dates this issue, and that was the trigger
21:46:18 <Fare> what's the "extensible-effects" strategy?
21:46:26 <bms1> https://hackage.haskell.org/package/extensible-effects
21:46:32 <jle`> bms1: i think the idea was to make your own custom type
21:46:41 <jle`> that incorporates just the effects you want, and nothing more
21:46:46 <jle`> without using transformers
21:48:23 <jle`> transformers are kind of a silly way of incorporating effects imo
21:48:57 <roboguy_> Fare: What kind of errors would it prevent if you used this approach instead of the one-big-monad approach?
21:49:09 <Fare> bms1: thanks
21:49:23 <roboguy_> It sounds like you want things to be able to be pretty mixed together either way
21:50:26 <roboguy_> You could probably implement a pretty small monad type consistency checker and then compile to one big monad. That sounds quite a bit easier to me and you could use the rest of Haskell's type system without having to reimplement it
21:50:41 <Fare> roboguy: ideally, I'd like to be able to apply the principle to arbitrary monad stacks, whereas a "there's a big monad and here are the effects" looks like a less modular way of doing things
21:50:58 <Fare> maybe the two approaches are isomorphic, or maybe not
21:51:14 <Fare> that would be an interesting thing to find out, but I don't have the time for that :-/
21:51:58 <bms1> Fare: The vast majority of compilers are have weak guarantees of correctness
21:52:28 <roboguy_> Fare: usually you don't worry about modularity in the /generated/ code...
21:52:40 <bms1> Those that do are big, involved research projects
21:52:41 <roboguy_> most code generators generate assembly or C, regardless of how high level the language is
21:53:00 <roboguy_> (or something similar to those two)
21:53:08 <Fare> roboguy: I want the modularity in the *generating* code.
21:53:14 <bms1> (Compcert, TAL, Cyclone,...)
21:53:21 <roboguy_> Fare: right, so why does the *generated* code need to be modular?
21:54:00 <roboguy_> the generating code can be modular completely independently of the language of the generated code, let alone the style of the generated code
21:54:29 <roboguy_> ghc has several different backends for instance
21:54:47 <Fare> I'm not sure it actually needs to be. Coming from a dynamic language background, I had the idea that this could be determined at runtime, in which case you need to maintain the information in the generated code
21:54:58 * hackagebot twitch 0.1.5.0 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.5.0 (JonathanFischoff)
21:55:53 <roboguy_> Fare: I thought that was what you were advocating though. What I'm saying is, I can't see how generating one big monad would affect the modularity of the code generator...
21:56:25 <Fare> "here is a function with effects from monad transformers A, B, D, E" and "here is another function with effects from monad transformers B, C, E", and "here is an order in which to stack transformers, compatible with the two former" --- compose these functions
21:57:55 <roboguy_> Fare: Maybe were talking about different things here. By one big monad, I mean a monad that incorporates all possible effects in your language. In that case, you wouldn't have any mismatches
21:58:09 <roboguy_> It's not uncommon to make such a monad when making a DSL, actually
21:58:43 <roboguy_> actually, that's probably the most popular way to make an embedded DSL in Haskell
21:58:59 <bms1> Fare: What I am advocating (and I think roboguy_ as well) is making a sort of typed-effect system in your pythonic language
21:59:12 <roboguy_> yeah
21:59:27 <Fare> yes, I understand that
21:59:33 <Fare> but I was more ambitious
21:59:41 <Fare> I wanted to have a family of languages
21:59:43 <Fare> gotta go
21:59:58 * hackagebot twitch 0.1.5.1 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.5.1 (JonathanFischoff)
22:20:04 <solatis> is there a haskell channel dedicated to haddock questions, or am i free to ask them here ?
22:20:28 <sivteck> #haddock
22:20:44 <sivteck> (you can also ask here)
22:21:39 <solatis> well, i have two questions actually, one about cabal/ghc and one about haddock, and they are related
22:21:55 <solatis> my problem: i have some MyLib.Internal.Log module that has logging helper functions
22:22:07 <solatis> I need to expose that module in order to use it from a Test-Suite
22:22:27 <solatis> I either would like to hide that module entirely, or make haddock skip documenting it
22:22:40 <solatis> so my question is: is there any way to achieve this?
22:23:42 <flebron> Hi. If I profile with -p, I'm told a very large amount of time is spent in main, but everything else has very (~1%) time usage, which doesn't add up to even 10% of the total runtime of the program. How can I get a better estimate on how much time was spent evaluating which things?
22:23:56 <solatis> or rather: what is the best practice for sharing code between a library and test-suite, without exposing that to the rest of the world?
22:24:59 * hackagebot elm-package 0.2.1 - Package manager for Elm libraries  http://hackage.haskell.org/package/elm-package-0.2.1 (MaxNew)
22:25:36 <solatis> or is it a signal of bad design if my test suite needs internal modules ?
22:28:34 <solatis> ok, now that we are talking about the subject anyway: how the hell am i supposed to choose a logging package for a library?
22:28:58 <solatis> it seems there is no real free choice about it, other than building with debug flags ?
22:38:16 <solatis> guess i'll just look how other major frameworks like Snap handle it and follow their practices..
22:39:12 <toblerone> solatis: I'd try asking again tomorrow
22:39:19 <toblerone> doesn't look like many people are one
22:39:22 <toblerone> on
22:39:42 <toblerone> or, rather in 9 or so hours
22:44:24 <solatis> yeah i know, i'm in the wrong timezone
22:49:59 * hackagebot conduit-combinators 0.3.0.5 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.5 (MichaelSnoyman)
22:52:01 <solatis> ah, looks like maybe the -eventlog flag might be something i need
22:52:48 <solatis> bah, no
22:59:30 <pavonia> solatis: What has the choice of the logging library to do with build flags? Or maybe I'm misunderstanding the problem
22:59:56 <solatis> well, i want to allow people to optionally build with a -debug flag
23:00:10 <solatis> but i don't want to force a logging library upon them
23:00:15 <solatis> but maybe i should...
23:02:57 <solatis> how do other people develop libraries, with easy debugging statements, without forcing a debugging library upon the users?
23:04:32 <pavonia> Writing their own logging module, I guess
23:05:29 <pavonia> What's the problem with forcing a logging library? You do that with other libraries too
23:06:21 <c_wraith> pavonia: what if two different dependencies force different logging libraries?
23:06:27 <solatis> .. or versions
23:06:30 <c_wraith> I think the problem is the lack of a common logging interface
23:07:29 <solatis> if one application developer has decided upon hslogger, and i use MonadLog, i don't want him to get annoyed
23:07:43 <solatis> besides, for a library, simple printf-like logging suffices
23:07:44 <pavonia> c_wraith: Right, but that problem exists with other parts too, like parsing libraries
23:07:57 <c_wraith> snap just uses a logging function.  It doesn't care where the function comes from.
23:08:10 <solatis> that's a good aproach
23:08:13 <c_wraith> It has a default, but you can provide others.  It's part of the server configuration
23:08:40 <solatis> and the logging function is just String -> IO () ?
23:09:09 <c_wraith> ByteString -> IO (), actually
23:09:22 <solatis> otoh, that requires me to pass the logging function to *all* functions that want to use logging
23:09:28 <solatis> which is exactly the type of thing i would like to avoid
23:09:31 <solatis> *sigh*
23:11:25 <solatis> guess i'll just a -debug flag, disabled by default, make an .Internal.Debug function, which aliases to Debug.Trace or a no-op depending upon the -debug flag
23:14:52 <toblerone> hi i'm playing around with Network.Sockets and I want to support simultaneous persistent connections that a server read from and right to. My approach doesn't seem to work, and I'm probably going about it completely wrong. Here is my attempt: http://lpaste.net/117073
23:16:06 <toblerone> My general approach is to keep a TChan and add new connections with each accept, and then to increment a connection counter
23:18:49 <solatis> let me look
23:19:57 <toblerone> i realized there was a mistake in my code, still doesnt work though, but the updated version is http://lpaste.net/117073
23:20:53 <solatis> let me just ask you some questions so i understand your problem
23:21:23 <solatis> you are forking a new thread for each connection, right ?
23:21:24 <toblerone> ok :-)
23:21:31 <toblerone> correct
23:21:41 <toblerone> i fixed that in the new version
23:22:01 <toblerone> err
23:22:05 <toblerone> actually one sec
23:22:16 <solatis> yeah i'm going to do the ask-questions approach instead of looking too much at the code
23:22:22 <toblerone> before i was forking before my call to "accept"
23:22:49 <solatis> i recently had a web crawler that had to use N threads for crawling and i needed to feed urls, so i think our problems are similar
23:23:01 <solatis> *had to write
23:23:54 <solatis> ok, so you want to limit the simultaneous number of threads that are active?
23:24:24 <solatis> or you just want to keep track of the # connections for monitoring purposes?
23:27:01 <toblerone> err kinda. really I just want to be able to have a persistent connection that I can read from and write to... I'm not all that familiar with the Socket API, but it seems like if I keep a reference to the socket returned by accept it would allow me to handle multiple connections
23:27:21 <solatis> it sounds like you are looking for a connection manager / pool ?
23:27:38 <toblerone> yeah, that sounds about right
23:27:51 <solatis> haskell's http client uses a Manager
23:27:52 <solatis> holdon
23:27:55 <solatis> looking for the code
23:28:27 <solatis> https://hackage.haskell.org/package/http-conduit-1.2.0/docs/Network-HTTP-Conduit.html#t:Manager
23:28:34 <solatis> that might be something to look at
23:29:25 <toblerone> thanks a lot, ill see how they've done it
23:29:28 <toblerone> thanks!
23:47:29 <solatis> toblerone: yw, it's written by someone with a lot of clue, so while risking an ad hominem, it's pretty safe to assume his approach is solid
23:49:23 <bob123> hey all
23:50:19 <bob123> could someone explain to me what the best way would be to create a list function that halves the list into two.
23:50:24 <bob123> for example
23:50:29 <SrPx> I am trying to create a mutable unboxed vector. Why this won't work? mvec_empty :: ST s (MVec.MVector s Int); mvec_empty = MVec.new size; main = print (runST mvec_empty)
23:50:41 <bob123> [1, 2, 3, 4) into [1, 2] [3, 4]
23:52:38 <pavonia> bob123: You can check for the length of the list and split the list at its half using splitAt
23:52:42 <pavonia> :t splitAt
23:52:43 <lambdabot> Int -> [a] -> ([a], [a])
23:53:46 <bob123> ok cool.
23:54:24 <bob123> so the function would be as follows
23:54:36 <bob123> Int -> [a] ([a], [a])
23:55:02 * hackagebot cndict 0.4.7 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.4.7 (DavidHimmelstrup)
23:56:18 <bob123> is there any reason that I have to put a list into a tuple binding? e.g. ([a], [a])
23:56:38 <bob123> sorry with the , inbetween
23:57:08 <pavonia> You want to have two result lists, so that's the return type
23:57:38 <bob123> ahh so it's not a list per say but a return
23:57:45 <maukem> *per se
23:57:57 <pavonia> It's a pair of lists
23:58:02 <bob123> thanks for the correction
23:58:06 <bob123> appreciate that.
23:58:10 <bob123> ok
23:58:40 <pavonia> What would the type of your splitting function look like?
23:58:51 <bob123> what I have so far.
23:59:12 <pavonia> Which is?
23:59:17 <bob123> I'll pop it into the paste section
23:59:42 <lpaste> bob123 pasted “split list” at http://lpaste.net/117077
23:59:51 <bob123> ^^
