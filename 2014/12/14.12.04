00:00:12 <wei2912> i found https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites but i'm not certain on what interface i should use
00:00:29 <fread2282> is there a way to tell ghc to inline a function's callees?
00:00:38 <fread2282> i think that's what I need
00:02:37 <Peaker> fread2282: you have to annotate the callees, I think
00:03:16 <fread2282> Peaker: :|
00:03:33 <Peaker> I hope Haskell eventually breaks backwards compatibility (as it has in AMP, Num superclasses, etc) to make Seq a type-class
00:03:46 <Peaker> So that we can have unlifted products and functions (which can have no instance of Seq)
00:03:55 <Peaker> So that GHC can optimize (foo . id) into foo
00:04:17 <Peaker> It's quite frustrating that many many "obvious" optimizations are not possible because of seq and lifted products :(
00:04:23 <fread2282> how can I figure out what's taking GHC so long?
00:04:41 <fread2282> multiple minutes on a fairly small module :(
00:05:16 <Peaker> fread2282: IME that is caused by: A) many deriving clauses on relatively large data-types (e.g: records with many fields).  B) TH hell  C) newtype'd Y-combinator which can just hang GHC :)
00:05:29 <Peaker> fread2282: You can try to use -O1 instead of -O2, perhaps
00:06:03 <fread2282> Peaker: yep, lots of deriving and INLINE, but it's just Generic and Show
00:06:17 <Peaker> fread2282: ooh, right, I had a really bad module compile time because of tons of INLINE's
00:06:36 <Peaker> fread2282: INLINE blows up the units that GHC looks at for optimization/simplification
00:06:57 <Peaker> (in my case, it was totally worth it.. About a 100% performance increase for about 1500% compile time increase)
00:07:06 <sinelaw> heh
00:07:26 <sinelaw> Peaker, you actually need to use INLINE?
00:07:37 <fread2282> Peaker: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Exts.html#v:inline
00:07:45 <sinelaw> the human optimizer...that sucks.
00:07:48 <fread2282> :)
00:08:01 <Peaker> sinelaw: In buildsome
00:08:25 <sinelaw> but isn't GHC a compiler? ;)
00:08:31 <fread2282> but it's not working :(
00:08:32 <Peaker> sinelaw: The Makefile parser is very very slow, especially once I added parameteric monad for the parsing.  By INLINE'ing everything, the 100% performance impact of the monad parameter disappeared
00:09:12 <Peaker> sinelaw: It also caused GHC to panic and crash :) I had to add a cmdline flag to tell it to do many more simplification passes
00:09:30 <sinelaw> what caused the crash
00:09:47 <Peaker> GHC failed to reach a fixed point after the maximum number of simplification passes
00:09:51 <Peaker> it panics when that happens
00:10:14 <sinelaw> can't it pick the last result?
00:10:29 <fread2282> someone should mark elem INLINABLE
00:10:34 <Peaker> probably. But I like that it paniced and told me to increase the number of simplification passes
00:11:40 <dreixel> fread2282: nope, it doesn't.
00:11:50 <dreixel> to neitehr of those.
00:12:09 <dreixel> I've never made it do it because I was afraid it would lead to code blow-up in some cases
00:12:12 <fread2282> dreixel: do you know if the inline special id would work here?
00:12:21 <dreixel> fread2282: what's that?
00:12:32 <fread2282> dreixel: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Exts.html#v:inline
00:12:50 <fread2282> dreixel: inline it's arg if possible
00:12:52 <dreixel> ah, not sure.
00:12:55 <dreixel> where do you want to place it?
00:13:34 <dreixel> my experience with these things is to compile the code with -O1 -ddump-simpl and have a look at whether it worked or not :P
00:15:38 <fread2282> dreixel: i'll try that :)
00:15:56 <wei2912> i'm using cabal's detailed-0.9 interface. is there a good tutorial on integrating it with QuickCheck? :)
00:18:02 <dreixel> fread2282: please let me know if it works!
00:18:18 <dreixel> fread2282: also, you can try to convince me that we really need INLINE pragmas on from/to
00:35:37 * hackagebot sci-ratio 0.2.0.1 - Rational numbers in scientific notation.  http://hackage.haskell.org/package/sci-ratio-0.2.0.1 (Rufflewind)
00:40:37 * hackagebot hmatrix 0.16.1.0 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.1.0 (AlbertoRuiz)
00:43:08 <fread2282> dreixel: conIsOperator would be really nice, do you think a trac bug is a good place for a request
00:43:09 <fread2282> ?
00:44:38 <dreixel> fread2282: can't you do that by looking at its name?
00:46:35 <fread2282> dreixel: yes, but I can't seem to get GHC to inline that away
00:48:28 <dreixel> fread2282: well, it's more likely that we'd add INLINE pragmas than conIsOperator, I think
00:48:38 <dreixel> because the latter can be derived from what's there already
00:49:01 <dreixel> but could you check (with handwritten Generic instances with INLINE pragmas) whether you can get a conIsOperator to be inlined nicely?
00:50:46 <fread2282> dreixel: sure
00:55:42 <sivteck> 1/ping
00:56:46 <bryanedds> I have a deterministic sequence of things I want to happen in my game over a period of ticks. I'm wondering if I should define these inside of something like a continuation monad?
00:57:35 <bryanedds> say like, on tick 0, enemy 0 moves, on tick 1, enemy 1 moves, and on tick 2, player moves (or some contrivance like that)
01:05:08 <shachaf> What sort of thing do you have in mind?
01:05:49 <bryanedds> well, in F# it might look like this -
01:05:50 <bryanedds> tick { do! moveEnemy 0; do! moveEnemy 1; do! movePlayer () }
01:06:04 <bryanedds> In Haskell, I suppose it'd be -
01:06:27 <bryanedds> do { moveEnemy 0; moveEnemy 1; movePlayer () }
01:06:53 <bryanedds> also there would seem to need to be some state threaded through
01:07:15 <bryanedds> so maybe more like -
01:07:42 <bryanedds> do { moveEnemy 0 $ getWorld (); moveEnemy 1 $ getWorld (); movePlayer $ getWorld () }
01:07:49 <bryanedds> do { moveEnemy 0 $ getWorld (); moveEnemy 1 $ getWorld (); return movePlayer $ getWorld () }
01:07:53 <bryanedds> I mean
01:08:17 <bryanedds> Does that even make sense up to this point?
01:08:34 <shachaf> Well, some sort of monad could probably do something like that.
01:08:57 <bryanedds> any idea which ones I might refer to?
01:08:58 <shachaf> I'm not sure what getWorld is here, or whether this is more than (possibly Writer of) a monoid.
01:09:22 <Kaidelong> well my first thought it, if you're just talking about a events happening in sequence, perhaps a start should be to work from the data side first and then worry about how to interpret the data either
01:09:33 <Kaidelong> you could use a list in which case your interpreter is a right fold over it
01:10:00 <Kaidelong> no need to worry about continuations or monads or anything that way
01:10:18 <tdammers> I'd go about this by building a suitable monad stack first
01:10:28 <tdammers> idk, StateT WorldState IO
01:10:42 <shachaf> That doesn't sound like a good first step.
01:10:48 <bryanedds> I deinitely would not need IO
01:10:51 <Kaidelong> I would define a few type synonyms that expose my desired functionality
01:10:58 <bryanedds> my code is purely functional
01:11:05 <tdammers> ah, then not IO
01:11:06 <Kaidelong> do a brain dead inefficient implementation first with something like a list
01:11:16 <Kaidelong> and then later on refactor the code by changing the type synonyms
01:11:44 <tdammers> shachaf: why not?
01:11:47 <shachaf> I think more of what bryanedds is doing is reasonable.
01:11:53 <shachaf> Figuring out what you want to be able to express.
01:12:39 <tdammers> sure
01:12:53 <Kaidelong> based on your pseudocode I think you're trying to implement an interpreter with threaded state
01:12:55 <Kaidelong> am I right?
01:13:25 <tdammers> my train of thought was that 1) what we saw so far looks pretty monadic, and 2) there's some state involved
01:13:44 <Kaidelong> actually to me it looks more like a monoid
01:13:49 <bryanedds> there is certainly state threaded, yes, but the other major concern is that it must fire each bind on a tick
01:14:07 <Kaidelong> he's not using any <- or let!
01:14:13 <tdammers> point in case
01:14:15 <bryanedds> where a tick originates from a low-level SDL event
01:14:35 <bryanedds> (also, please note that I barely know haskell, so my syntax is probably wrong)
01:14:39 <Kaidelong> mmm well the format of that seems to be Tick -> Action
01:14:42 <bryanedds> (I'm doing all this in F#)
01:14:56 <bryanedds> nah, it's more World -> World
01:15:03 <bryanedds> World in, World out
01:15:11 <Kaidelong> Well since you are handling SDL ticks
01:15:16 <tdammers> so the syntax could actually be more something like [ movePlayer 0, movePlayer 1, doSomethingElse 5, movePlayer 10 ]
01:15:20 <Kaidelong> it's something like Tick -> (World -> World)
01:15:34 <Kaidelong> which is indeed a monad because (World -> World) is an endofunctor monoid
01:15:38 * hackagebot counter 0.1.0.0 - An object frequency counter.  http://hackage.haskell.org/package/counter-0.1.0.0 (wei2912)
01:15:40 * hackagebot c2hs 0.20.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.20.1 (IanRoss)
01:15:56 <bryanedds> I think, yes
01:16:07 <shachaf> Oh, I remember you.
01:16:10 <Kaidelong> however I guess your actual instructions are (World -> World)
01:16:21 <shachaf> The person who kept coming to #haskell to ask questions about F# for some reason.
01:16:38 <bryanedds> mostly because we don't have the same depth of knowledge in the F# community
01:16:46 <bryanedds> (apologies)
01:16:51 <Kaidelong> shachaf: ##fsharp is pretty dead and the two languages are extremely similar so I don't really see why this should be such a bad idea
01:17:03 <Kaidelong> F# is probably more like Haskell than it is like OCaml in most ways
01:17:54 <bryanedds> Kaidelong:, ya
01:17:55 <Kaidelong> anyway my recommendation would be
01:18:28 <Kaidelong> make an explicit data type like type Instruction arg = Foo | Bar arg | Baz arg
01:19:28 <Kaidelong> then use Instruction seq as your basic data type
01:19:39 <Kaidelong> seq is the free monoid so you get the monoid pattern automatically
01:19:57 <Kaidelong> then you just need an interpreter function Instruction seq -> (World -> World)
01:20:17 <tdammers> interesting... I would have gone with (World -> World) directly
01:20:24 <wei2912> is there a way to use Data.Map with the key being an instance of Ord?
01:20:30 <wei2912> without*
01:20:36 <shachaf> Make it an instance of Ord.
01:20:55 <wei2912> Ord doesn't make much sense for the type though
01:20:58 <shachaf> Or make a wrapper around the key with an instance of Ord.
01:20:59 <wei2912> oh wait, it's a tuple
01:21:05 <wei2912> i guess that settles it
01:21:10 <bryanedds> Ok, thanks once again haskell friends :)
01:22:20 <Kaidelong> you might eventually want to use (World -> World) directly instead via some kind of continuation passing style if you have performance problems with the interpreter but the interpreter might help with debugging since you can inspect what instructions are actually being generated
01:22:27 <Kaidelong> wheras (World -> World) is a black box
01:22:35 <tdammers> true
01:23:13 <tdammers> I'm tempted to separate the tick counting part from the actual instructions btw
01:36:02 <bryanedds> Is there any Haskell IDE where I can mouse hover over a term and have its type pop up like a tool tip?
01:36:33 <Kaidelong> emacs and vim can both do that using ghc-mod
01:36:39 <Kaidelong> but it takes a bit of setup
01:36:53 <Kaidelong> eclipse also can do this, supposedly
01:37:10 <Kaidelong> I use vim, the problem with ghc-mod though is that it has trouble guessing types without being able to compile your whole file
01:37:36 <bryanedds> hrm
01:37:42 <Kaidelong> so it's much, much less nice than the situation with F# where Visual Studio can report these things even if your code won't compile
01:37:49 <srhb> Yes.
01:37:53 <bryanedds> ya
01:38:58 <eXeC64> How is F#, as a language? I had it pitched to me by a Microsoft stall years ago, before I knew Haskell.
01:39:28 <fread2282> dreixel: conIsOperator is hard to get to inline nicely because isSymbol calls out to c
01:39:58 <bryanedds> F# is very good at enabling modular and pure functional programming on .NET
01:40:28 <Kaidelong> eXeC64: it's similar to Haskell. It does have better (but still poor) tool support and it's a little less unfamiliar because of its strict and impure semantics, but the two are very similar.
01:40:37 <bryanedds> However, it doesn't have the level of type generality that Haskell has that makes much Haskell code nearly correct-by-construction.
01:40:54 <Kaidelong> bryanedds: have you looked at F*?
01:41:00 <Kaidelong> that adds refinement types to F#
01:41:15 <Kaidelong> you can also use System.Diagnostics.Contracts to statically check lots of things that the F# type system cannot
01:41:23 <bryanedds> Yes. I don't think it's ever going to be first-classed.
01:41:47 <bryanedds> F* is sadly fading away from a product standpoint.
01:42:10 <Kaidelong> well the same thing happened with C-omega and SPEC# but in the end both of them ended up becoming part of C#
01:42:21 <Kaidelong> it's very possible a future version of F# will have many of the features of F*
01:43:48 <bryanedds> I would like to see Don Syme come up with an elegant way to add Haskell-style type generality to F#, but I think the closest we'll end up with is Scala-style implicits / traits
01:44:29 <Kaidelong> Don Syme's F# was quite different from the one that ended up as a product (I used it)
01:44:39 <bryanedds> The problem I think is how dependent we are on the expectations we have of the type inferencer
01:44:48 <Kaidelong> it had some crazy features like inline MSIL
01:45:15 <bryanedds> With Scala, they have more flexibility since they don't put as much burden on the inferencer
01:45:22 <Kaidelong> and many of the things that were later relegated to PowerToys were part of the FSharp base libraries
01:45:52 <Kaidelong> basically don syme designed it with financial and numerical applications in mind but microsoft decided that the support surface of the result was too big
01:45:55 <Kaidelong> so they simplified it
01:46:09 <bryanedds> I don't even know how implicits will interact with F#'s inference system (will we have to annotate all types that will be used in an implicit conversion??)
01:47:19 <bryanedds> Lots of open questions that likely only Don knows much about right now.
01:47:53 <Kaidelong> he's likely working on his own stuff at MSR Cambridge
01:48:04 <Kaidelong> F# is in the hands of the visual studio team now
01:48:21 <bryanedds> Didn't know that.
01:48:29 <bryanedds> When did that take place?
01:49:02 <Kaidelong> Mmm, I don't remember exactly, I think it was with the release of VS2012?
01:49:13 <Kaidelong> it was when F# became a default language that shipped with Visual Studio
01:49:27 <Kaidelong> it was dramatically changed from the original version out of cambridge in the process
01:50:47 <bryanedds> lots of things I wasn't aware of, then
01:55:01 <eXeC64> Heh, it was in Cambridge where I was pitched F#
01:55:19 <eXeC64> Back in 2011ish
01:59:03 <bryanedds> what did you think back then?
02:01:19 <Welkin> why would anyone use a proprietary language?
02:01:25 <Kaidelong> F# is open source
02:01:46 <eXeC64> bryanedds: I'm afraid I didn't pay too much attention. They were demoing it by showing off 3D graphs coded functionally, and talking about lambdas.
02:01:47 <Kaidelong> always was, I think
02:02:08 <Welkin> it's just microsoft's version of ocaml
02:03:06 <bryanedds> The major value proposition seems to be enabling pure functional programming on .NET
02:03:08 <Kaidelong> it's probably more similar to Haskell than to OCaml, its syntax and heritage is from OCaml, but it's very different from OCaml. Early versions of F# had interoperability with OCaml as an objective in hopes that financial institutions would adopt F# as an easy transition
02:03:26 <Kaidelong> but this was abandoned as a priority even when F# was still a research prototype, I think
02:04:13 <zwer_c> what makes it more similar to haskell? It is IIRC strict and impure
02:04:36 <bryanedds> I don't think bootstrapping off of any ML is a bad idea
02:05:00 <Kaidelong> the libraries and programming style (head strict "lists" are the main sequencing data type in F#, for example, and pipelining style dominates with higher order combinators like haskell's $ and .)
02:05:21 <bryanedds> Programming languages are so huge that choosing to not bootstrap off one is a massive hurdle / risk
02:05:47 <tdammers> depends what your goals are
02:05:55 <Kaidelong> also F# has do syntax and makes heavy use of the monad and monoid patterns
02:06:02 <bryanedds> F#'rs do love our combinators, but we're not nearly as monad centric
02:06:13 <Kaidelong> you just call them "computational workflows"
02:06:21 <Kaidelong> but they are monads
02:06:22 <tdammers> but almost always, one would want to either take an existing language's syntax as a starting point, or implement a radically new syntax on top of an existing runtime system
02:06:34 <fread2282> desugaring question: http://lpaste.net/115632
02:06:38 <bryanedds> actually, comp exprs are much more powerful than monads
02:06:52 <Kaidelong> yeah comp exprs also include other haskell typeclasses like MonadPlus
02:07:01 <bryanedds> and even more than that
02:07:06 <Kaidelong> and the syntax is better for working with those
02:07:17 <Kaidelong> I think there was an effort to port the syntax to haskell, but I can't remember offhand
02:07:28 <bryanedds> you can define your own computational... well, _expressions_
02:07:32 <Kaidelong> however if you enable all the list comprehension extensions haskell list comprehensions are pretty similar
02:07:42 <Kaidelong> well they're more similar to C#'s LINQ
02:07:49 <Kaidelong> but they allow the use of other typeclasses
02:10:38 <dreixel> fread2282: what c?
02:11:26 <fread2282> dreixel: wgencat
02:12:18 <fread2282> sorry, u_gencat
02:16:51 <Procian> No monad libraries in F# though.
02:17:48 <fread2282> dreixel: defined in https://github.com/ghc/packages-base/blob/master/cbits/WCsubst.c
02:17:54 <Kaidelong> F# lacks something important that prevents those things from working
02:18:07 <Kaidelong> because it is tied to the .NET type system, that is not going to change
02:19:10 <Kaidelong> you can't have monad libraries like F# because you have no ability to be polymorphic over the monad the way you can in haskell with things like sequence
02:19:33 <Kaidelong> the "solution" is that those just become methods that you have to implement as well
02:21:05 <bryanedds> Actually there are several monad libraries in F#
02:21:51 <bryanedds> I believe they leverage the language's structural typing feature to work
02:22:37 <Kaidelong> I don't think (modern) F# is really structurally typed anymore
02:22:58 <bryanedds> However, few people actually use them as 1) they're not idiomatic and 2) they're honestly not that useful in the context of F#
02:23:18 <bryanedds> It depends on how you mean it.
02:23:35 * sivteck yawns
02:23:40 <Kaidelong> structural typing is what OCaml had to do to regain type inference in the context of object hierarchies
02:23:57 <Kaidelong> you infer types that just specify an anonymous interface about the final form of data
02:24:32 <bryanedds> that's problaby not what I mean when I talk about its current structural typing feature
02:24:35 <Kaidelong> but this puts restrictions on how you can create objects and what kinds of mutable state they allow (like, they can't, at runtime, change what methods are available0
02:24:47 <Kaidelong> in OCaml, objects really can't do that, so that's fine
02:25:02 <Kaidelong> .NET allowes you to introduce new types *at run time* and other crazy things like that
02:26:14 <bryanedds> yep - a function from 'a -> () can literally do anything in F#
02:26:20 <bryanedds> or hell, () -> ()
02:26:51 <osa1> http://lpaste.net/115633 <- is this expected? I'd expect list to end/terminate in this case.
02:29:35 <dreixel> fread2282: wait, what? why am I looking at C code? I'm confused.
02:30:09 <fread2282> dreixel: Data.Char.isSymbol calls that
02:31:25 <tasker> what does it mean to inline a function ?
02:32:14 <tdammers> tasker: it means that instead of compiling the function into a separate symbol in the executable and inserting jumps or calls where it gets called, the compiler injects the function body itself
02:32:33 <tasker> if this is a good thing, why would you not always do it ?
02:32:40 <tdammers> it's a tradeoff
02:33:04 <tdammers> for every call, the inlined function body is copied
02:33:15 <tasker> hmm
02:33:31 <tdammers> which means that if it's a large function, you'll generate a huge executable, and your cache performance will suffer
02:33:38 <tasker> ahh, okay, I see
02:33:50 <tdammers> OTOH, for small functions, the call overhead is significant, so it makes sense to inline those
02:33:55 <tasker> so it might be a good idea to inline the function used by a map?
02:34:00 <tdammers> depends
02:34:19 <tasker> hehe, I thought you might say that :p
02:34:29 <tdammers> if you really want to know, profile
02:34:34 <tasker> hm, okay
02:35:04 <bryanedds> is it just me, or are both math and programming both fundamentally about structure in the mathematical sense?
02:35:32 <chrisdone> it's just you!
02:35:34 <moop> programming is all about objects
02:35:35 <ClaudiusMaximus> osa1: it doesn't know that nothing will ever write to the chan again, so it blocks forever waiting for the next item - lazy io is weird/unsafe - maybe use Chan (Maybe Int) and write a Nothing to signal end of contents and  catMaybes . takeWhile isJust  on the reading side
02:35:44 <moop> objects here, objects there
02:36:13 <bryanedds> but it's ultimately the structure of our objects that we're concerned about, no?
02:36:31 <chrisdone> no!
02:36:42 <bryanedds> ztrike two!
02:36:56 <bryanedds> ilike cake.
02:36:56 <moop> objects every f*cking where
02:37:50 <bryanedds> I don't know, I just feel there is a deep connectino between programming, math, and mathematical structure
02:38:03 <bryanedds> i have no proofs
02:38:14 <jle`> well math has a deep connection with everything
02:38:16 <jle`> by construction :)
02:38:25 <trap_exit> does haskell have a decent abstraction for: "the entireity of your EC2 nodes as a monad" ?
02:39:19 <ChristianS> is there a name for types that have kind 0 (e.g.  Text  as opposed to  Maybe Text  or  [Text] )?
02:40:03 <jle`> just don't call it "concrete" :P
02:40:07 <bryanedds> well, bedtime
02:40:14 <bryanedds> and tomorrow, I fuck up a monad!
02:40:33 <jle`> ChristianS: "kind-*" works
02:40:36 <jle`> oh wait
02:40:43 <jle`> um
02:40:50 <jle`> what do you mean by kind 0
02:41:02 <jle`> Text and (Maybe Text) have the same kind
02:41:07 <jle`> and so does [Text]
02:41:21 <tasker> When should one use repa vs Data.Array ?
02:41:57 <Procian> ChristianS: Atomic?
02:42:13 <ChristianS> jle`: right, but ... (Maybe Text) involves a kind-1 constructor/type while Text doesn't
02:42:32 <wei2912> in Parsec, how do i check if something meets the conditions, then parse it; otherwise, consume a char?
02:42:33 <Procian> Yeah, ChristianS doesn't mean kind-0. But I assume you mean non-type applications.
02:42:35 <chrisdone> tasker: if your array's key is int, you could use vector, as it's faster than array
02:42:38 <ChristianS> Procian: yes, i thought about "atomic" too...
02:43:04 <jle`> hm.  would (Maybe Text) mean anything different than newtype MaybeText = MaybeText (Maybe Text) ?
02:43:04 <chrisdone> wei2912: try p <|> char
02:43:11 <jle`> Maybe Text vs MaybeText ?
02:43:13 <tasker> chrisdone: Hm, okay. Is vector always prefereable to repa in this case?
02:43:22 <chrisdone> tasker: couldn't say, haven't used repa
02:43:26 <mbuf> solirc, ping
02:43:28 <tasker> chrisdone: Fair enough :)
02:43:35 <jle`> ChristianS: would you count one and not the other?
02:43:41 <wei2912> chrisdone: thanks
02:43:43 <mbuf> solirc, how do I just use afterPrint in https://gist.github.com/sol/e36404b9d3ed1a71cab8 ?
02:45:01 <ChristianS> jle`: no i would consider newtype MaybeText as non-atomic (or however it should be called) as well, but i see your point
02:45:13 <jle`> because i don't think Text is "atomic" either
02:45:20 <chrisdone> wei2912: here's a simple program that was benchmarked on Data.Array and Data.Vector http://chrisdone.com/posts/twitter-problem-loeb#fastest
02:45:28 <jle`> if you don't count MaybeText
02:45:32 <jle`> then you can't count Text either
02:45:33 <solirc> mbuf: You can ask in #hspec, too ;)
02:45:34 <ClaudiusMaximus> repa has more combinators than array, which might make some things simpler.  but repa indexes are Int per dimension iirc, so Array is a bit more flexible (you could use Ordering as index, or whatever else Ix)
02:45:50 <chrisdone> wei2912: source here: http://lpaste.net/95686#line93
02:46:18 <tasker> ClaudiusMaximus: I'm only going to be using Ints anyway, so I guess that doesn't matter for me
02:46:32 <wei2912> chrisdone: thanks for that too!
02:46:33 <solirc> mbuf: Your action needs to be of type (IO ()), then you can use after_
02:46:37 <chrisdone> wei2912: welcome =)
02:46:41 <ChristianS> Procian: wikipedia seems to call it "primitive type" ( http://en.wikipedia.org/wiki/Kind_%28type_theory%29 ), but that doesn't sound so good. i guess i'll stick with atomic.
02:47:06 <Procian> ChristianS: "Elementary" has also been used.
02:47:18 <Procian> They all pretty much mean the same thing: doesn't decompose.
02:47:26 <ChristianS> jle`: granted, but with Text that's a kind of implementation detail that's hidden away in another module
02:47:31 <mbuf> solirc, I was able to use after_; just that after alone is a bit confusing
02:47:34 <jle`> ChristianS: well, so would MaybeText be
02:47:37 <jle`> if i just exported that
02:47:48 <ChristianS> Procian: yeah, that doesn't sound bad
02:48:30 <lpaste> mbuf pasted “'before' works” at http://lpaste.net/115634
02:48:38 <jle`> if you don't count MaybeText (without an exported constructor), then you can't count Text either
02:48:42 <jle`> you can't even count Int :P
02:49:03 <chrisdone> tasker: oh, i meant you instead of wei2912, above
02:49:04 <mbuf> solirc, I had used before with readLn http://lpaste.net/115634, slightly different from your solution
02:50:01 <lpaste> mbuf pasted “Just 'after'” at http://lpaste.net/115635
02:50:15 <ChristianS> jle`: the distinction is clear enough for me in practice, even if it isn't in theory
02:50:23 <mbuf> solirc, this is with just using 'after' http://lpaste.net/115635; I didn't understand by (IO ())
02:50:36 <tasker> chrisdone: Ah, cool!
02:50:43 <jle`> what does it mean in practice, then?
02:55:47 <sleepomeno> how can I get the extQ functionality of syb in uniplate? in uniplate's syb compatibility layer data.generics.syb I only see 'mkQ' and 'everything' but I don't see how to 'extend the query'
02:56:25 <ChristianS> jle`: correcting myself, i would probably consider your MaybeText as elementary as well if it's a newtype, but not if it's just a type synonym
02:56:58 <jle`> ah that would make sense :)
02:58:04 <jle`> where does this become a difference practice?
02:58:06 <jle`> just curious
02:58:23 <jle`> what can you do with an elementary type or a value of that type that you can't do with a nonelementary one?
02:59:22 <solirc> mbuf: https://gist.github.com/sol/ff41d82ab45893845dff
03:00:13 <mbuf> solirc, no no; I got after_ working fine; was curious to know how to test after
03:00:17 <ChristianS> jle`: nothing, just developing my own style preference about when to annotate definitions in where clauses with type signatures
03:00:31 <jle`> ah i see :)
03:00:46 <solirc> mbuf: What do you mean with "test"?
03:01:08 <solirc> if you want to use `after` you also need a `before`
03:01:25 <mbuf> solirc, I see
03:01:27 <solirc> otherwise there is no `a` that `after` could possibly access
03:01:35 <jle`> how about non-parameterized
03:01:42 <mbuf> solirc, I will work how the types match with the function signature
03:01:45 <mbuf> solirc, thansk for your help
03:01:48 <jle`> hm
03:01:52 <mbuf> *thanks
03:02:04 <solirc> mbuf: you are welcome
03:02:16 <jle`> i guess Maybe Text could be considered Maybe parameterized by Text. hm.
03:02:38 <jle`> but i'm not sure if that's a meaningful definition of parmeterized
03:02:41 <ChristianS> jle`: my current rule of thumb is, if a definition involves a non-elementary type or if it takes more than 1 argument, it should get a type sig
03:03:43 <jle`> oh i was suggesting "non-parameterized" as a name. but i'm not sure if it works...
03:18:09 <tasker> If i'm trying to represent an n by n matrix with Data.Vector, is there much overhead with the indexing ? E.g. it looks like I have to do theVector ! 1 ! 2
03:18:26 <ChristianS> jle`: "elementary" doesn't sound so bad, i think
03:19:00 <shachaf> A Vector of Vectors may not be the best representation of a matrix.
03:19:15 <lericson_> hm, i have a program that i want to read from stdin character by character and apply some transformation of the current state
03:19:34 <lericson_> i'm not quite sure how to make that work well in haskell
03:20:05 <lericson_> in python for example, i would reduce the state transition function over the standard input byte stream
03:20:46 <lericson_> trans (trans (trans initial_state next_byte()) next_byte()
03:20:47 <lericson_> etc
03:20:52 <remdezx> Hello! How can I abort action running under uninterruptibleMask?
03:21:18 <shirt> Hello, I upgraded some libraries I was using, and now my program is crashing with Segmentation fault (core dumped). Here is the full backtrace when I run through gdb:
03:21:20 <shirt> http://lpaste.net/115639
03:21:37 <shachaf> lericson_: Perhaps interact + mapAccumL would be one way of putting it.
03:21:45 <tasker> shachaf: I was getting this impression, given the lack of support for indexing :s
03:22:04 <shachaf> You could write a plain old imperative program with getChar to do it however you like.
03:22:34 <lericson_> @hoogle interact
03:22:36 <lambdabot> Prelude interact :: (String -> String) -> IO ()
03:22:36 <lambdabot> System.IO interact :: (String -> String) -> IO ()
03:22:36 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
03:22:39 <shachaf> shirt: That is probably not enough information for anyone to help you.
03:23:30 <shirt> shachaf: what can i do to get more information? which tool can i run?
03:23:51 <shachaf> What library is it?
03:23:55 <shachaf> Ah, multiple libraries.
03:24:22 <lericson_> foldl is the quick one right? as it takes the head of the list
03:24:41 <shachaf> There is no quick and slow.
03:24:47 <shachaf> Maybe you can figure out what those addresses are. Or get versions with debugging symbols.
03:26:36 <ChristianS> lericson_: i usually use foldl' instead of foldl, since it's strict
03:26:56 <shachaf> If you use foldl, you should almost always use foldl' instead.
03:27:15 <shachaf> But there's no such quick answer for foldl vs. foldr.
03:27:32 <shachaf> You'll need to actually think about your situation.
03:27:36 <lericson_>     Not in scope: ‘foldl'’
03:28:07 <Gurkenglas_> Would a good analogy be to ask whether we are faster using a queue or a stack?
03:29:07 <mauketwork> @index foldl'
03:29:07 <lambdabot> Data.List
03:29:12 <shachaf> lericson_: You've already demonstrated that you're aware of the existence of Hoogle. :-)
03:29:20 <shachaf> (It has a website, not just a lambdabot service.)
03:29:32 <shachaf> In your situation it's not unlikely that foldr will be better.
03:29:41 <shachaf> But I won't comment because I don't know what you're doing.
03:29:46 <lericson_> ¬unlikely = ¬¬likely = likely?
03:30:20 <lericson_> how come foldr has a different type?
03:30:21 <shachaf> It's possible, at any rate. Don't rule out foldr because you once heard someone say that foldl is fast.
03:30:33 <shachaf> Because it does a different thing.
03:31:12 <shachaf> shirt: You might look in e.g. /proc/pid/maps to figure out where those addresses are from.
03:31:16 <shachaf> Oh, shirt is gone.
03:31:22 <lericson_> put it back on then
03:52:34 <favetelinguis> is there a time difference between foldr and foldl? i thought is was only a spece issue since foldl utilies tail recursion?
03:52:48 <BoR0> mainly, associativity
03:53:07 <BoR0> 1 - (2 - 3) is different from (1 -  2) - 3
03:53:34 <favetelinguis> yes but it takes the same time to compute?
03:55:43 <favetelinguis> or actually to get the space savings you would need to use foldl' since foldl and foldr is the same because of haskells lazyness so wont give you any difference in time or space?
03:56:13 <favetelinguis> not sure if what im saying is correct so would be nice if someone could correct me if im wrong?
03:56:48 <saep> > foldr (||) False $ True : repeat False
03:56:49 <lambdabot>  True
03:56:55 <saep> > foldl (||) False $ True : repeat False
03:57:00 <lambdabot>  mueval: ExitFailure 1
03:58:02 <bernalex> ReinH: watching the haskell cast with byorgey. interesting stuff! I've been wanting to figure out how to marry my knowledge of category theory with denotational semantics like conal talks about.
03:58:17 <bernalex> ReinH: make more haskell cast! you should interview conal. :-]
03:59:04 <saep> favetelinguis: It entirely depends on the function you use a fold on.
04:00:17 <favetelinguis> bernalex: which episode was that?
04:00:26 <bernalex> favetelinguis: 5
04:00:42 <gilligan_> does anyone here follow the FP101 course on edx.org by any chance ?
04:01:05 <favetelinguis> gilligan_: yes i am
04:01:44 <gilligan_> favetelinguis, how far in are you?
04:02:13 <favetelinguis> gilligan_: going to start with lazy eval
04:02:42 <gilligan_> favetelinguis, ah ok.. stuck with the lab for that right now
04:03:17 <favetelinguis> ok i have not started the hw yes so cant help out there
04:11:59 <novns> orion launch in minutes http://www.ustream.tv/nasahdtv
04:15:15 <shirt> @seen aristid
04:15:15 <lambdabot> 4RiSTID
04:17:15 <saep> @hoogle (f a, f b) -> f (a, b)
04:17:17 <lambdabot> No results found
04:18:23 <prophile> :t mzip
04:18:24 <lambdabot>     Not in scope: ‘mzip’
04:18:24 <lambdabot>     Perhaps you meant one of these:
04:18:24 <lambdabot>       ‘zip’ (imported from Data.List),
04:18:53 <chpatrick> @pl (\( x, y ) -> (,) <$> x <*> y)
04:18:53 <lambdabot> uncurry ((((,) <$>) .) . (<*>))
04:19:04 <prophile> bah
04:19:11 <prophile> saep: it looks a lot like mzip from Control.Monad.Zip
04:19:16 <prophile> or like liftA2 (,)
04:19:19 <prophile> :t liftA2 (,)
04:19:20 <lambdabot> Applicative f => f a -> f b -> f (a, b)
04:19:37 <prophile> :t uncurry (liftA2 (,))
04:19:38 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
04:20:15 <saep> prophile: Thanks for the help!
04:20:25 <prophile> np
04:20:37 <Grisha> Hello everyone. I've got a stupid beginner problem: I intend to map a list through (+intercept) . (*slope) where slope and intercept are both results of assoc list lookups
04:21:00 <Grisha> both being Maybe Double
04:21:08 <osa1> is this function considered `safe` http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception.html#v:throw ?
04:22:05 <prophile> osa1: to my knowledge, yes
04:22:12 <prophile> Grisha: righty, what's the trouble?
04:22:12 <Grisha> once I've fetched them from the assoc list, how do I combine then into (+intercept) . (*slope) function?
04:22:26 <prophile> are you familiar with do-notation?
04:22:30 <Grisha> yes
04:22:39 <Grisha> i've got something like
04:22:46 <Grisha> model pars time = do
04:22:55 <Grisha> slope <- lookup "slope" pars
04:23:03 <Grisha> intercept <- lookup "intercept" pars
04:23:16 <Grisha> now comes the point which I would naively write as
04:23:37 <Grisha> return $ map ((+intercept) . (*slope)) time
04:23:58 <prophile> looks entirely sensible
04:24:10 <prophile> what's the difficulty?
04:24:43 <Grisha> hm
04:24:46 <Grisha> now it's working
04:24:55 <Grisha> probably was a typo before
04:25:02 <prophile> hah, sucks when that happens
04:25:45 <Grisha> do I understand correctly that inside the do-notation, those slope and intercept can be thought of as non-monadic values?
04:25:58 <Grisha> I'm too lazy to de-sugar it ;)
04:26:20 <prophile> yup
04:26:39 <prophile> do x <- y; z becomes y >>= (\x -> do z)
04:26:48 <Grisha> thank you
04:26:56 <prophile> np
04:27:11 <Grisha> I saw it a million times, but I still get confused by those
04:27:17 <jle`> @undo do x < y; z
04:27:17 <lambdabot> x < y >> z
04:27:21 <jle`> oops
04:27:23 <jle`> @undo do x <- y; z
04:27:23 <lambdabot> y >>= \ x -> z
04:27:27 <fr33domlover> Hello! Q: Could haskell be a good impl. language for a triplestore or SQL database?
04:28:15 <prophile> fr33domlover: that's a very subjective question to be honest
04:28:37 <prophile> I would say so, though I confess to never haven written an SQL database
04:28:46 <prophile> *having
04:29:00 <tdammers> fr33domlover: could be, at least for large parts of it
04:29:03 <Grisha> prophile may I bother you once again?
04:29:07 <prophile> Grisha: by all means
04:29:20 <tdammers> fr33domlover: the thing is, writing a complete industry-strength DBMS from scratch is a gargantuan task
04:29:45 <Grisha> prophile: the thing is that I have to supply the output of that function (being Maybe [Double]) to an external library that expects just [Double]
04:29:57 <prophile> :t fromMaybe
04:29:58 <lambdabot> a -> Maybe a -> a
04:30:07 <Grisha> ok I see
04:30:13 <tdammers> fr33domlover: so using an existing project and forking it is almost a better option
04:30:15 <Grisha> is it a good style to to unwrap it?
04:30:23 <prophile> if you have a sensible default, yes
04:30:55 <Grisha> prophile, thanks a lot
04:31:03 <prophile> no worries
04:33:48 <Grisha> one more syntactic thing
04:33:54 <fr33domlover> tdammers, I know, I have a special use case and existing code to be based on
04:33:55 <Grisha> if I write something like
04:33:58 <fr33domlover> So it's really mostly reuse
04:34:02 <Grisha> return $ map f time
04:34:12 <Grisha> where f = (+intercept) . (*slope)
04:34:26 <Grisha> both intercept and slope are not in scope in the where line
04:34:38 <prophile> in a do-block I'd just use a let
04:34:42 <fr33domlover> tdammers, thanks. I was worried about memory access etc. but I see there are things like STM so maybe it will be fine
04:34:46 <prophile> let f = (+intercept) . (*scope)
04:34:52 <prophile> return (map f time)
04:35:03 <Grisha> I see
04:35:17 <Grisha> it's really great to have a direct feedback from you
04:45:02 <tdammers> fr33domlover: Haskell is conceptually and practically garbage-collected, so you won't get a lot of control over memory allocation, if that's what you're asking
04:45:46 * hackagebot present 2.0 - Make presentations for data types.  http://hackage.haskell.org/package/present-2.0 (ChrisDone)
04:47:41 <RchrdB> tdammers: fr33domlover: raw pointers are available in the C FFI if you really want to work with data outside the GC'd heap.
04:48:24 <RchrdB> Naturally this is not safe from segfaults or undefined behaviour.
04:49:31 <fr33domlover> tdammers, RchrdB, thanks. I was thinking maybe I can use the STM modules
04:49:56 <fr33domlover> to get part of the memory management "for free"
04:50:40 <fr33domlover> since it's a desktop database I'm not sure what I ca optimize compared to server-targeted ones
04:50:42 <tdammers> fr33domlover: Haskell gives you *all* the memory management for free, more or less
04:50:46 * hackagebot present 2.1 - Make presentations for data types.  http://hackage.haskell.org/package/present-2.1 (ChrisDone)
04:51:06 <tdammers> fr33domlover: STM solves the issue of *concurrent* memory access, not that of tracking and managing allocation
04:52:19 <fr33domlover> tdammers, I guess I'll have to study this carefully and see. Is there another functional language that could be better for this? I'm hoping pure functional style can be good for the task
04:53:01 <tdammers> it really, really depends on the kind of priorities you have
04:53:13 <tdammers> if you need 100% C performance, then you need to use C, or maybe C++
04:53:28 <tdammers> (same for when you need C-like levels of control over memory allocation and such)
04:53:38 <tdammers> but I don't think you actuallky need that
04:58:55 <Kaidelong> fr33domlover: you could look at Rust and Disciple
05:00:03 <Kaidelong> purely functional languages do have some thereotical advantages on constraining memory allocation in deterministic ways but Haskell is not really built to take advantage of that at all (although supposedly some libraries can achieve something like this, I think netwire was supposedly one)
05:00:03 <tdammers> I was thinking OCaml could work, possibly with some C code mixed in for the close-to-the-metal parts
05:00:25 <bernalex> IME I would not recommend using a language that isn't even stable, like e.g. rust.
05:00:41 <tdammers> or, hey, use Haskell to generate C code :P
05:00:51 <Kaidelong> oh right, there is that pattern
05:01:03 <Kaidelong> accelerate is a library that generates CUDA from Haskell, for example
05:01:21 <Kaidelong> you could make a haskell DSL that compiles to C or FORTRAN when you are very concerned about memory use
05:01:28 <bernalex> tdammers: haskell generates machine code and machine code is the closest to the metal you can get so haskell is the fastest language possible QED
05:01:37 <tdammers> bernalex: mwahaha
05:01:39 <bjz> bernalex: Rust will be stable by the end of the year, for the 1.0 release candidate
05:01:41 <Kaidelong> to be fair this is basically what Haskell is already, but you will have full control over your memory model
05:01:59 <bernalex> bjz: thanks for the info.
05:02:04 <bjz> bernalex: but it is understandable to hold off
05:02:14 <tdammers> but anyway, what I meant is not write Haskell and compile it to C, but write a Haskell program which, when run, will produce the desired C code
05:02:36 <tdammers> basically you'd be inventing a DSL for programming a DBMS
05:02:37 <Kaidelong> well what you're basically doing is writing a compiler
05:02:39 <tdammers> yeah
05:02:45 <bernalex> bjz: it's likely not going to be as big a PITA as when I used Dart from the first week it was publicly available.
05:02:51 <bjz> bernalex: there is still churn in the APIs as we get final, critical PRs merged and implemented. The semantics won't change much - mainly APIs
05:02:52 <tdammers> a special-purpose compiler for DBMS development
05:03:17 <Kaidelong> does GHC have any support for partial evaluation and specialization?
05:03:31 <bernalex> tdammers: yeah I know what you meant. I was trolling, I guess.
05:03:36 <Kaidelong> if it did you could perhaps use this as a way to extend the compiler
05:03:38 <bjz> bernalex: yeah, thankfully we have had a ton of dogfooding that should make the RC pretty battle hardened
05:03:52 <Kaidelong> write your own compiler in haskell, have GHC partially evaluate your code
05:04:17 <Kaidelong> generate Core or C as an output for GCC to put into its own output
05:04:22 <Kaidelong> GHC*
05:04:25 <bjz> bernalex: it's just resisting the urge to keep fixing stuff... you have to ship sometime :(
05:04:55 <gmarrow> Anyone familiar with lhs2Tex? How can one use separate \perform{} blocks to insert into the doc various stats over some data extracted from a file without re-reading the external file for every \perform{}?
05:04:59 <bernalex> bjz: as a researcher that make things that other people actually want to use at some point -- I can relate to how you feel.
05:06:32 <bjz> bernalex: less me - more the core team. luckily they have Dave Herman leading Mozilla Research. He has heard it all in the ecmascript standards committee, and is helping the team battle through it.
05:08:46 <fr33domlover> thanks all, I'll consider all the options
05:09:54 <tdammers> fr33domlover: personally, I'd go with the language that is most suitable on the human side
05:10:08 <tdammers> i.e., the one that makes it the easiest to express your code in syntax
05:10:19 <tdammers> and then optimize for performance as needed
05:10:35 <tdammers> worst case, once you have something working, rewrite the performance critical parts in C
05:10:41 <bernalex> personally, I'd go with the language with safe types and effects that has the best ecosystem. that leaves very little choice today. :-]
05:10:47 * hackagebot present 2.2 - Make presentations for data types.  http://hackage.haskell.org/package/present-2.2 (ChrisDone)
05:10:57 <tdammers> bernalex: that's pretty much what I said, on some level ;)
05:11:04 <bernalex> premature optimisation is the root of all evil, and using C or C++ is premature optimisation.
05:11:12 <tdammers> my point.
05:11:21 <tdammers> make it work, then make it right, then make it fast
05:11:24 <tdammers> not the other way around
05:11:35 <bernalex> hm. I make it right first, then make it work.
05:11:39 <exio4> most of the time, a factor of 3-4x of C code is actually too good for the problem
05:11:45 <bjz> bernalex: it helps to have your code in a form that is amenable to optimization though
05:12:04 <bjz> depending on the use case though
05:12:26 <tdammers> bernalex: by "right", I mean things like "sufficiently generalized and DRY"
05:12:38 <bernalex> bjz: yeah. not sure I'd write pacemaker software in agda, heh.
05:12:49 <tdammers> bernalex: what you are talking about, I guess, is more in the realm of "correct", which I consider part of "work"
05:13:01 <bernalex> tdammers: yep, I see what you mean.
05:13:06 <bernalex> and you see what I mean
05:13:09 * bernalex hifives tdammers
05:13:10 <tdammers> yes
05:13:15 <tdammers> awesomeballs
05:13:27 <bernalex> *end credits with stillshot of jump hifive*
05:13:53 <bjz> bernalex: or a high performance game. or browser :)
05:14:00 <bernalex> bjz: aaaaaaaaactually
05:14:24 <bernalex> bjz: for a high performance game, I would write everything in haskell. but make it *extremely* modular, so that sensitive components might be replaced with C code.
05:15:00 <bjz> bernalex: That is definitely one way. Hopefully replace it with Rust in the future :)
05:15:04 <bernalex> that's something I believe quite firmly *could work*. a lot of the reason games need C++ performance is because, well, they are poorly programmed. if we can express algorithms and structure code cleanly, less performance is needed because there is less overhead.
05:15:07 <bjz> as in, the C part
05:15:13 <bernalex> I'd love to replace C with rust for this use case, yes.
05:15:39 <tdammers> for a high performance game, I would use C++ and a small army of underpaid junior devs and testers whom I lured in with prospects of fame and glory and a dream job
05:15:53 <tdammers> and I'd just have them do crunch time for six months straight
05:15:57 <bernalex> I really hope someone can extend my master thesis on haskell game programming with "haskell + C [or rust!] game programming", which I alluded to in my future work section.
05:16:18 <bernalex> tdammers: that's how it generally works today, yes lol
05:16:55 <bjz> bernalex: the worry I have with haskell is how predictable performance is... and how easy execution is to reason about
05:17:05 <bjz> bernalex: how have you found it?
05:17:36 <bjz> bernalex: the laziness seems to obfuscate it, in my limited experience
05:17:47 <bernalex> bjz: *most* of the time it a) doesn't matter, b) profiling rocks! the problem is generally getting an intuition for "should this be lazy or should it be strict"? the good thing about haskell v. e.g. python is that you can look at the intermediate language as well as even the llvm.
05:18:37 <bernalex> typically you want strict primitives (bool, int, double, etc), and lazy containers. a lazy tuple of strict ints is good, a lazy tuple of lazy ints is bad. a strict list of doubles is also bad. usually.
05:19:24 <bernalex> but you're right -- the problem is knowing in advance "should I make this strict?", because reasoning with time and space usage is kind of difficult at times. but then again... most of the time it thankfully doesn't matter.
05:19:49 <bernalex> I would *love* to see what problems would pop up at, say, the Assassin's Creed 4 scale though.
05:20:23 <bjz> thanks for the info!
05:21:24 <d-snp> bernalex: where can I find your thesis?
05:21:24 <bernalex> my thesis doesn't deal with perf at all though, and neither do any of the other haskell game theses I have read. so really someone needs to go ahead and write the "Haskell games performance" thesis. that would be very cool.
05:21:35 <bjz> yeah, it's a challenge to figure out... and it's gonna be a big risk to try a AAA game in haskell to experiment :)
05:22:14 <d-snp> AAA games are seldomly in a single language
05:22:16 <bjz> Carmack seems to be positive about it
05:22:20 <bernalex> d-snp: it's on github. it's not very good actually! you have been warned. at the uni I went to, there is this policy that you need to write something that's understandable to someone at your level. i.e. I needed to spend most of my time figuring out "how do I explain basic programming language theory stuff" lol.
05:22:30 <bernalex> d-snp: https://github.com/alexander-b/master-thesis should be it
05:22:53 <bjz> bernalex: 'master-thesis' is not a great name :)
05:23:15 <bernalex> bjz: well I don't plan on writing another master thesis, so I think it's OK to use that namespace on my github lol
05:23:30 <bjz> googlability?
05:23:32 <bjz> :)
05:23:41 <fr33domlover> bernalex, tdammers - the reason I'm moving from C/C++ is exactly the optimization issue... I prefer less code and less erorrs
05:23:44 <d-snp> :D
05:23:45 <bjz> you want your work found right?
05:24:02 <fr33domlover> it's a desktop DB so optimization ma be unnecessary eventually
05:24:11 <bernalex> bjz: oh it's quite bad I don't really want anyone to read it. I want to clean it up and extrapolate the great stuff and write a good paper instead. maybe I'll start that this month.
05:24:46 <bjz> fr33domlover: that's exactly why I like Rust :) easy to reason about perf, but the haskell-ish confidence that comes with a good type system
05:25:09 <bjz> bernalex: oh ok - still, it's great you are publishing code
05:25:21 <bjz> bernalex: doesn't happen enough in acedemia
05:25:36 <bernalex> bjz: I ended up quite disappointed with it, needing to spend so much time on explaining all the background. which I'm not even able to do very well, because it would far outweigh the actual work! hah. so I'll try to make a good paper with the actual gist of it, which was what SPJ advised me to do.
05:26:11 <bernalex> bjz: yes, I think I'm the first one to refuse to publish my master thesis at our uni because they would not publish it using CC-BY-SA. so I put it on github along with the code.
05:26:34 <d-snp> bernalex: maybe you go in deeper, but modern games are no longer built in OOP style
05:26:52 <bernalex> d-snp: no, I realise that a lot of people are moving towards CES.
05:27:18 <d-snp> even further, one of the lead engineers at ubisoft recently said that there's no reason they use c++ other than to interface with 3rd party libraries that are written in c++ :P
05:27:28 <d-snp> he said that at cppcon, which made it that much more awesome
05:27:36 <hyPiRion> bernalex: Woah, really? I would be surprised if I wasn't allowed to get my own work out as CC-BY-SA
05:27:59 <bernalex> hyPiRion: academia is weird and all about paywalls and stripping you of your rights
05:28:08 <d-snp> awesome action bernalex
05:28:17 <bernalex> that's the primary reason I'm not pursuing a phd/scd
05:29:29 <bernalex> my bachelor thesis is also not published for the same reason. we made an impulse-based physics engine (well, really, we were trying to make a *game*, but) in C++.
05:29:32 <d-snp> haha, you implemented two pretty big systems, why did you choose to implement the c++ part yourself?
05:29:56 <bernalex> d-snp: to limit the number of dependent variables to one: myself.
05:30:04 <d-snp> haha ok
05:30:21 <hyPiRion> bernalex: Well, I used CC-BY-SA on my thesis and didn't even consider that it might not be okay for them
05:30:28 <bernalex> in hindsight I should probably have made twice a big a system, and trick someone else into making the C++ part.
05:30:40 <wei2912> hyPiRion: don't you technically own the copyright or something
05:30:42 <tdammers> fr33domlover: in that case, haskell is a pretty good candidate
05:30:55 <d-snp> I made a similar mistake, my bach thesis was comparing two I/O styles in Haskell (Monadic and stream-based) by implementing a network protocol in both styles
05:30:56 <hyPiRion> wei2912: That's what I thought, unless you sign an NDA with some corp
05:31:03 <wei2912> hyPiRion: argh
05:31:06 <hyPiRion> And I didn't
05:31:06 <d-snp> I ended up implementing SCTP twice, which was a shit load of work
05:31:12 <bernalex> wei2912: yes. so what a lot of academics do is license schools and publications with the limited licence they require, then they just publish it on their Website anyway.
05:31:23 <wei2912> bernalex: haha
05:31:25 <d-snp> in the end, I didn't have enough time to make a proper comparison and the whole thesis sucked
05:31:40 <tdammers> bernalex: except that some unis in some countries make students sign over the copyright
05:31:41 <bernalex> wei2912: this voids the ToS/whatever for the publication, which means they can remove the paper. but that's all they can do. and if the paper is popular enough... they won't remove it.
05:31:52 <bernalex> tdammers: that's not possible in any country I know
05:32:08 <bernalex> tdammers: the law is a bit more complicated. you have ideal/author rights in addition to distribution rights.
05:32:21 <wei2912> ehh
05:32:27 <wei2912> hope the future uni i study at won't do that
05:32:54 <bernalex> d-snp: what is SCTP?
05:33:04 <d-snp> wei2912: fat chance, copyright is very important to universities
05:33:09 <bernalex> d-snp: oh right never mind! I found it in the back of my brain
05:33:19 <d-snp> bernalex: a transport level protocol, should've been successor to TCP back in 2003 :P
05:33:44 <d-snp> the protocol is awesome
05:34:01 <bernalex> yeah it's the noe that has some TCP features and also some UDP features. I don't know it well, I just vaguely remember it from uni.
05:34:02 <hyPiRion> Hrm, seems like I got lucky or just made a good unconscious decision, because it's apparently cool for me.
05:34:06 <bernalex> s/noe/one
05:34:30 <d-snp> bernalex: yes, it's also much cleaner than TCP and properly avoids some security concerns
05:34:44 <bernalex> hyPiRion: well, here you have to sign a copyright form in order to get it published.
05:35:06 <d-snp> it's actually part of the HTML5 spec now, it's the protocol they use layered over UDP to implement their datachannels for p2p stuff and mediastreams
05:35:09 <bernalex> and by copyright I mean distribution right, because "copyright" is an Anglo-American thing that doesn't really exist in most countries.
05:36:38 <d-snp> wei2912: anything you do at a university, you'll have to ask permission to the university to be able to do anything with it, you usually sign away much of your authorship rights when you sign for the tuition
05:36:40 <bjz> d-snp: didn't the ubisoft guy say he'd rather be working in C though?
05:36:46 <d-snp> bjz: yes
05:37:11 <wei2912> d-snp: ehh.
05:37:31 <bernalex> d-snp: thankfully we don't have that in Norway. everything you make is yours. professors have to sign away everything like that though.
05:37:34 <d-snp> wei2912: at my university, I just asked if my works could be opensourced under the MIT/BSD license, and they say yes
05:37:43 <d-snp> it's not a really big problem
05:38:14 <wei2912> d-snp: i see
05:38:36 <bjz> d-snp: I am glad the data oriented approach is now king in high performance game dev
05:39:02 <d-snp> bjz: he talked about the coding guidelines, and how many of C++ features were banned at ubisoft, and an audience member asked why use C++ at all with those restrictions
05:39:15 <bjz> d-snp: just a shame that the languages are so horrible
05:39:16 <d-snp> and he answered that he would've rather used C :P
05:39:22 <d-snp> bjz: yeah definitely
05:39:33 <d-snp> hopefully rust changes something, but we'll have to see
05:39:54 <d-snp> I have the feeling he might have something bad to say about rust as well :D
05:39:56 <bernalex> there's wayward tide being written in haskell. that's neat.
05:41:01 <d-snp> nice
05:41:22 <bjz> bernalex: yeah, that is exciting
05:41:45 <bernalex> I need to finish https://github.com/plaimi/bweakfwu
05:42:29 <hyPiRion> bernalex: I don't think NTNU even bothers with publishing theses, except if the author really wants to
05:42:32 <bernalex> make a good game out that thing. then beg artists to make it pretty. then add some juicing.
05:42:57 <bjz> bernalex: pushing the boundaries of what the hardware can do is nowhere near the norm for most independent games. it would be really nice to see Haskell used more there.
05:42:58 <hyPiRion> Like, except at their digital archiving system (which is public)
05:43:34 <d-snp> my university, or at least the section I was in, only publishes the thesis on their website, and if your thesis is good enough they ask you to produce an article for publication
05:43:46 <d-snp> and they do that to sucker you into becoming a phd :P
05:44:35 <bernalex> hyPiRion: do you mean NTNU as in Trondheim?
05:45:22 <bjz> d-snp: sounds like a nice way
05:45:40 <d-snp> yes, it works too, my company lost 2 employees that way :(
05:46:07 <wei2912> does anyone mind taking a quick code review of this: http://lpaste.net/115645 ? :)
05:46:19 <wei2912> i can explain the program if required
05:46:44 <hyPiRion> bernalex: yes
05:46:59 <d-snp> looks pretty readable to me wei2912 :)
05:47:33 <RchrdB> -->: -->
05:47:38 <wei2912> d-snp: thanks :)
05:47:47 <RchrdB> Whoops, wrong button.
05:47:51 <d-snp> wei2912: it's both a lexer and a parser though right?
05:47:51 <bernalex> bjz: I think we can do nice things with smaller games too. I want to finish my tiny breakout+pong clone, and rewrite my IRC quiz bot in haskell (it's in python). then I want to move onto a bigger game project. I want to make something that's sort of addictive and multiplayer... but simple.
05:48:01 <d-snp> RchrdB: ah the -->: --> button, a common typo
05:48:13 <bernalex> bjz: I have some big ideas too (table tennis simulation, JRPG for teaching Japanese, and so on and so on), but I want to get a middle-sized thing off the ground first.
05:48:16 <wei2912> d-snp: what's a lexer? (sorry, i'm not used to parsing)
05:48:27 <bernalex> hyPiRion: nice to meet a fellow Norwegian haskeller!
05:49:07 <d-snp> wei2912: well a lexer tokenizes a string, i.e. usually it groups a text into objects that contain single words or symbols (usually dropping blank spaces)
05:49:17 <d-snp> and then the parser works on the token stream
05:49:22 <hyPiRion> bernalex: I doesn't seem to be that many out there, so it's good to know others exist :)
05:49:31 <hyPiRion> *There
05:49:40 <wei2912> d-snp: i see. i think it's both
05:49:45 <bjz> bernalex: I had an idea for a gamey thing where you explore a world map filling in the details... instead of having a separate map view you'd just keep zooming out
05:49:48 <bernalex> hyPiRion: I know a few. I attend the oslo-haskell meetups. I'm also in a Norwegian haskell development company. :-]
05:49:50 <d-snp> wei2912: it's not obligatory to do it that way, but if your language gets very complex, it's neat to separate them :)
05:50:05 <wei2912> d-snp: fortunately what i'm parsing isn't very complex
05:50:21 <d-snp> yeah, when I look at your code I don't see a reason to do so
05:50:33 <wei2912> there're some weird parts though
05:50:35 <wei2912> like a nested do
05:50:49 * hackagebot egison 3.3.17 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.17 (SatoshiEgi)
05:50:50 <bernalex> hyPiRion: I'm moving to Trondheim next year -- let's grab a beer! I'm planning on starting a trondheim-haskell meetup unless someone preempts me. maybe I'll trick you into giving a talk. ;-)
05:50:50 <wei2912> i'm also finding myself using quite a lot of `lookAhead`
05:51:37 <d-snp> wei2912: yes, parsers tend to do that a lot, often the meaning of a rule depends on what comes next
05:51:41 <hyPiRion> bernalex: I moved down to Oslo after I finished my thesis, heh
05:51:55 <bernalex> hyPiRion: ah. are you at the oslo-haskell meetups?
05:51:56 <hyPiRion> bernalex: Was supposed to get to the last meetup, but something came up =(
05:52:18 <d-snp> for example, an identifier could be a variable reference or a function call, it depends on wether its followed by the '(', in c-like languages
05:52:18 <wei2912> d-snp: i see. thanks for the feedback
05:52:37 <bernalex> hyPiRion: it was the same day as the MONO concert. that was neat. didn't have to go to Oslo two days in the same week.
05:52:38 <muzzle> when i put a project in cabal, is there a way to tell it to search all subdirectories of a directory recursively for source files ?
05:53:18 <d-snp> wei2912: a lexer would look at the next char to see if it's a non-letter character to decide if it's the end of a word, so it can emit its token and go work on the next
05:53:45 <hyPiRion> bernalex: Guessing it saved you a bit of money on train tickets?
05:54:28 <bernalex> hyPiRion: yes! Gjøvik is ridiculous. you know these kr199 mini price tickets that are nation wide? well, Gjøvikbanen is *an exception*. so a friend coming from Trondheim had cheaper train tickets than me, haha.
05:54:29 <d-snp> wei2912: in the science, a proper context free grammar (a good designed programming language) can be parsed by an LLR(1) parser, that's a parser that only has to look ahead 1 token
05:54:38 <wei2912> d-snp: i see.
05:54:46 <d-snp> or, at least not an arbitrary amount of tokens
05:54:59 <hyPiRion> bernalex: wat. That's amazingly stupid
05:55:17 <bernalex> hyPiRion: BTW do you get to use haskell at work? the guys I know in Oslo that like Haskell generally don't. =/
05:55:22 <wei2912> d-snp: i'm planning to use Parsec to implement scheme without looking at WYASI24H
05:55:45 <wei2912> (though i learnt parsec from the book)
05:56:15 <d-snp> wei2912: that all said, I've never worked with parsec or made any parser in Haskell, so perhaps there's smarter ways of doing it :)
05:56:46 <d-snp> maybe you can look at the source of a parser made with parsec, like Language.C or something
05:56:47 <hyPiRion> bernalex: Fortunately yes :) I'm writing a Haskell compiler for a turing complete modelling language (construction industry is 30 years behind in tech...)
05:57:06 <bernalex> hyPiRion: awesome!
05:57:25 <wei2912> d-snp: i see, thanks
05:57:26 <bernalex> ehamberg: trick this guy ^ into talking at oslo haskell
05:58:02 <hyPiRion> bernalex: This was how I introduced my company to Haskell: https://twitter.com/hyPiRion/status/487509062847053824
05:58:33 <wei2912> hyPiRion: lmao
05:58:39 <bernalex> hyPiRion: ROFL
05:59:06 <gcganley> hyPiRion: omg...
05:59:10 <hyPiRion> It worked surprisingly well, I was 1.5 months in before people noticed.
05:59:13 <wei2912> hyPiRion: that's risky as hell
05:59:17 <wei2912> wow
05:59:27 <wei2912> what was the result?
06:00:02 <hyPiRion> wei2912: The goal is Haskell in production by new year's eve
06:00:12 <wei2912> hyPiRion: do the other developers know haskell?
06:00:19 <wei2912> well
06:00:28 <wei2912> as in, not just know how to write hello world
06:00:54 <hyPiRion> wei2912: Well no, I'm still doing the compiler thing myself, but if we need to expand the newcomers have to learn/know Haskell
06:01:14 <wei2912> hyPiRion: ah, i see
06:01:20 <wei2912> you sound quite productive
06:01:22 <hyPiRion> (That wouldn't have changed regardless of language)
06:01:31 <wei2912> heh
06:01:45 <wei2912> also, how does haskell compare to idris? just curious
06:01:55 <gcganley> hyPiRion: they will assimilate
06:02:01 <hyPiRion> wei2912: I wouldn't necessarily call myself productive. I mean, I'm at work now :p
06:02:06 <ehamberg> hyPiRion: come to Osλo Haskell! we've run a beginners workshop this autumn but want to do more talks next year.
06:02:18 <hyPiRion> "working"
06:02:22 <tdammers> hyPiRion: if you get fired over this, half of me will weep, and the other half will think that you had it coming
06:02:24 <gcganley> ehamberg: thats a creative ass name
06:02:41 <ehamberg> gcganley: thank you. our pr firm worked on it for months.
06:02:52 <ehamberg> hyPiRion: let's grab a beer some day. :-)
06:03:36 <hyPiRion> ehamberg: I'm going to go to the next meetups at least :)
06:03:47 <hyPiRion> (and I'm almost always up for beer)
06:04:37 <gcganley> ehamberg: and also isnt it always winter in oslo?
06:04:44 <ehamberg> cool. what about next week? always fun to meet more haskellers in Oslo :)
06:05:13 <ehamberg> gcganley: come visit us in the summer ;)
06:05:33 <gcganley> ehamberg: im 17 and in boston, may be a while
06:06:03 <bernalex> ehamberg: maaaybe there should be one last basics talk that introduces functor-monad-applicatives. or at least the former two.
06:06:04 <ehamberg> not sure Oslo is colder than Boston, actually, but then again I've only been to Boston in October and November.
06:06:41 <ehamberg> bernalex: yep! :)
06:06:55 <gcganley> ehamberg: im near it, and it gets to about -5 C
06:06:58 <bernalex> ehamberg: I guess that's not a basics talk as much as a "introduction to advanced stuff". just for an overview.
06:07:17 <bernalex> gcganley: Gjøvik gets -30 C
06:07:20 <hyPiRion> tdammers: Our CTO was cool with it, actually, but that's what I suspected. I wouldn't have dared it if I didn't knew them well enough to know that it was okay
06:07:25 <gcganley> sometimes lower depending on the winter
06:07:47 <ehamberg> gcganley: sounds pretty much like what we get here.
06:08:29 <gcganley> when does it get dark in oslo? like 4:30ish?
06:08:30 <bernalex> maybe we should have a "why haskell sucks" rant/talk about the bad things in haskell
06:08:57 <gcganley> bernalex: i liked the "why linux sucks" talk alot
06:08:59 <tdammers> hyPiRion: in that case, I'll go with "half of me envies you, the other half hates you"
06:09:17 <tdammers> bernalex: I like talking about the good stuff better
06:09:19 <ehamberg> gcganley: yeah, or maybe even earlier. all I know is that it's dark when I get to work and dark when I leave work. :|
06:09:26 <d-snp> haskell sucks because of the vagueness about which I/O stream library to use
06:09:36 <tdammers> bernalex: all programming languages suck, but some have better good parts than others
06:09:38 <bernalex> tdammers: I like identifying the sucky stuff and motivating people to improve them.
06:09:57 <tdammers> bernalex: yes, but the sucky stuff is not a good argument for or against a given language
06:10:00 <hyPiRion> ehamberg: sure thing! I'm available all days next week except early Tuesday
06:10:07 <hyPiRion> tdammers: I can live with that :p
06:10:10 <bernalex> ehamberg: snobs. in the north we get 24h darkness for 2 months. (and 2 months of 24h sun during Summer but.)
06:10:14 <d-snp> tdammers: I don't think anyones argueing against haskell at a haskell cafe :P
06:10:30 <d-snp> the idea of a haskell sucks talk is not to discourage people from using haskell
06:10:33 <tdammers> d-snp: that would be kind of pointless, yeah
06:10:36 <gcganley> bernalex: people arent supposed to live there 0.o
06:10:38 <tdammers> and yeah, I get it
06:10:42 <bernalex> tdammers: I didn't want to argue for or against haskell. I just wanted to rant about things that are broken so that we can fix them.
06:10:49 * hackagebot process-listlike 1.0 - Process extras  http://hackage.haskell.org/package/process-listlike-1.0 (DavidFox)
06:10:55 <tdammers> right
06:11:16 <tdammers> one of the nice things about Haskell is how ranting about the bad parts usually leads to people tackling them eventually
06:11:49 <bernalex> another nice thing is that the problem space is so huuuuge that there are plenty of low-hanging fruits all around.
06:11:51 <hyPiRion> bernalex, ehamberg: when I studied in Trh and went home for the winter holidays, I was surprised at how much sun there was in Oslo
06:13:00 <bernalex> hyPiRion: students from the Phillipines are confused by -30 degrees instead of uh +30 degrees winters (Gjøvik). students from Marocco were confused by WHERE IS THE SUN IS THIS THE END (Narvik).
06:13:15 <ehamberg> hyPiRion: wednesday at crowbar? around 18? (“#haskell – connecting people!”)
06:13:24 <hyPiRion> bernalex: hahah
06:13:44 <bernalex> ehamberg: you need to decide what you're going to wear to identify yourselves. might I suggest a golden chain necklace with a lambda?
06:13:55 <bjornars1> mmm, crowbar, delicious beer
06:14:05 <ehamberg> bjornars1: come join us :)
06:14:18 <bernalex> now I want beer too@
06:14:48 <myme> ehamberg: Next Wed?
06:15:03 <ehamberg> I was thinking 10 Dec
06:15:13 <hyPiRion> ehamberg: sounds good to me :)
06:15:16 <ehamberg> “next” means different things to different people :)
06:15:16 <myme> After one of those Haskell beginners meetups?
06:15:22 <tdammers> bernalex: the fruit is low hanging on a high level though
06:15:28 <ehamberg> this time it'll only be beer
06:15:32 <myme> AH.
06:15:49 <bjornars1> 'oh no!'
06:15:50 * myme haven't gone to any of those workshops
06:15:53 <ehamberg> but we could announce it. would be fun to simply meet and have some good beer. :)
06:16:08 <bernalex> ehamberg: julebord!
06:16:13 <ehamberg> haha, yes!
06:16:43 <tdammers> bernalex: you could say that haskell sucks in very sophisticated ways
06:17:08 <wei2912> haha
06:17:50 <bernalex> tdammers: "even the bad stuff about this language is too complicated to properly explain!"
06:18:16 <ehamberg> hyPiRion: awesome. it's now in my calendar. other haskellers: feel free to join (Crowbar, Oslo, 10 Dec @ ~18:00)
06:18:58 <bernalex> ehamberg: I'll consider it at least. it's a bit late to go to Oslo and meet up at 18 and go run for the train at 21. so I'll have to figure out if someone wants to hang out before that.
06:19:33 <bernalex> ehamberg: put it up on meetup as a julebord lol. might as well.
06:20:32 <tdammers> bernalex: yeah. Normal languages struggle with problems like "concatenating arrays doesn't work reliably" or "we need 60 different functions to work with arrays, none of them work on anything *but* arrays, and we still lack about 75% of commonly requested functionality"
06:21:27 <tdammers> bernalex: and meanwhile, we're complaining how Monad and Functor aren't superclassed like they should be, or how our type system isn't powerful enough yet
06:22:16 <bernalex> tdammers: and the ridiculous thing is, *we* are the ones that actually *address* the problems. (AMP proposal and -XDependentTypes etc.)
06:22:20 <gcganley> tdammers: have you used clojure before? i know thats not totally mainstream but the seq abstraction makes writing general functions a breaze
06:23:23 <hyPiRion> ehamberg: nice – written down here as well
06:24:24 <gcganley> tdammers: any function that uses the seq abstraction works over any of the 4 clojrue collections (set, list, array, map)
06:26:41 <bernalex> hyPiRion: hm. do you know emilhf by any chance? I just noticed you were a clojure guy. and uh ntnu/trondheim so.
06:26:49 <juanpablo_> jvilla:
06:27:22 <lpaste> fizbin pasted “One-at-a-time LIFO mutex” at http://lpaste.net/115647
06:27:46 <fizbin> Anyone with concurrency experience care to take a look at that paste?
06:28:16 <fizbin> I *think* it's good, but since concurrency is always so hard to get right I need a few more pairs of eyes.
06:31:22 <hyPiRion> bernalex: yup, I know him
06:31:35 <bernalex> hyPiRion: I'm trying to trick him into working at my company.
06:32:00 <bernalex> hyPiRion: I'm slowly but surely tricking him into using haskell instead of clojure for stuff.
06:32:21 <tdammers> gcganley: haven't used clojure for more than a few hours, no
06:32:34 <wei2912> bernalex: you could do it the way hyPiRion did it
06:32:39 <muzzle1> i use ghc-mod in emacs for haskell development, and i'm wondering when i have a source file in a subdirectory in a cabal project, how can i load it in ghci inside emacs  ?
06:32:44 <tdammers> gcganley: and clojure was absolutely not the language I had in mind
06:32:52 <bernalex> wei2912: I'm not sure how that's applicable to this?
06:33:32 <Procian> muzzle1: C-C C-l?
06:33:35 <wei2912> bernalex: convert his code into haskell
06:33:44 <wei2912> bernalex: then surely and slowly "rm -rf /"
06:33:55 <muzzle1> Procain: doesn't work because dependencies are in other directories
06:33:57 <wei2912> "oh hi, i had a copy of your code in haskell"
06:34:00 <muzzle1> cabal finds them in build
06:34:01 <wei2912> tada
06:34:05 <wei2912> $$$
06:34:10 <muzzle1> but ghci can't find them
06:34:11 <wei2912> or something, i guess
06:34:14 <bernalex> wei2912: I *am* going to visit him during the Summer... so good idea.
06:34:18 <hyPiRion> bernalex: oh, cool. :) Does he seem interested in working at your company?
06:34:18 <gcganley> tdammers: yeah they have an abstraction called 'seq' for sequence that is used to build general functions that work over any collection that implements seq. they have an amazing standard library for working with seq's
06:34:20 <Procian> muzzle1: Hmm...I don't seem to have any problems. You should be running cabal repl, though.
06:34:46 <Procian> That'll load the whole project.
06:34:59 <tdammers> gcganley: so roughly what Haskell does with typeclasses like Monoid, Functor, Traversable, Foldable, etc.?
06:35:19 <bernalex> hyPiRion: yeah. he does have sort of a standing offer from prismatic after he wrote the array tools stuff that they adopted though, and he's a fairly brilliant guy so he can work wherever. that's true with everyone I try to trick into working with me though. anyway, he might be doing a summer job for us next year to try it out.
06:35:33 <tdammers> gcganley: and what Python and friends "solve" with duck typing and magic methods?
06:36:09 <gcganley>  tdammers: clojure doesnt have any types perse
06:36:36 <gcganley> s/perse/per\ se/g
06:36:55 <gcganley> would i have to escape the space for that?
06:36:57 <tdammers> gcganley: I know, but those collections are still different beasts... "dynamic types"
06:37:17 <mauketwork> gcganley: no
06:37:25 <ehamberg> gcganley: not in any regex dialect I know :)
06:37:26 <tdammers> and escaping rules differ in perverse ways between regex dialects
06:37:41 <tdammers> almost none require escaping spaces though
06:37:43 <mauketwork> this has nothing to do with regex dialects
06:37:58 <mauketwork> the RHS of a substitution is not a regex
06:38:00 <gcganley> ok, i've never used regex
06:38:06 <tdammers> oh right, hehe
06:38:23 <tdammers> rhs is a simpler thing
06:38:38 <gcganley> rhs? to goold
06:38:40 <tdammers> still have to escape *some* things though
06:38:42 <gcganley> s/goold/google
06:38:46 <gcganley> im on a roll
06:38:47 <tdammers> right hand side
06:39:18 <hyPiRion> bernalex: oh, neat. Yeah, after doing the "hip-hip array!" macro library with Prismatic, he told me about the offer. But isn't that overseas? For some (e.g. me) that's actually a big deal and sometimes an issue.
06:39:21 <Procian> muzzle1: Do you call (interactive-haskell-mode) in your mode hook?
06:39:37 <bernalex> hyPiRion: San Francisco IIRC
06:39:54 <gcganley> Procian: just saying if you have any emacs-haskell questions i belive there is a channel for that
06:40:21 <Procian> gcganley: I'm trying to answer one! :)
06:40:31 <biinui> hi :), do backticks do some flipping? example, (elem 1) is [[t]] -> Bool and (`elem` [1]) is a -> Bool
06:40:35 <gcganley> oh lol
06:40:52 <tdammers> biinui: flipping, no, but they turn a function into an operator
06:40:59 <Procian> biinui: That's a slice there.
06:41:01 <gcganley> didnt see anything in the previous conversation
06:41:02 <tdammers> f a b == a `f` b
06:41:10 <muzzle1> Procian: no, but I solved it by appending these two lines to my emacs.el:
06:41:12 <muzzle1> (setq haskell-program-name "cabal repl")
06:41:12 <muzzle1> (setq haskell-ghci-program-name "cabal repl")
06:41:21 <muzzle1> but thx
06:41:22 <tdammers> using parentheses, you can partially apply operators
06:41:31 <tdammers> so (+ 1) == \x -> x + 1
06:41:32 <Procian> Cool stuff.
06:41:33 <muzzle1> the tip with cabal repl was really good
06:41:42 <tdammers> so (1 +) == \x -> 1 + x
06:41:48 <tdammers> combine the two, and you get:
06:42:08 <tdammers> (`elem` [1]) == \x -> x `elem` [1] == \x -> elem x [1]
06:42:08 <gcganley> biinui: theres a really good article on desugaring haskell code by the guy that did the pipes library
06:42:08 <muzzle1> this is totally awesome and will probably get me to abandon vim :P
06:42:20 <gcganley> let me find it
06:43:01 <tdammers> which, incidentally, is equivalent to flip elem [1]
06:43:13 <tdammers> :t (`elem` [1])
06:43:14 <lambdabot> (Num a, Eq a) => a -> Bool
06:43:19 <tdammers> :t flip elem [1]
06:43:20 <lambdabot> (Num a, Eq a) => a -> Bool
06:43:27 <Procian> biinui: Sorry, not "slice". I meant "section."
06:43:30 <tdammers> :t \x -> elem x [1]
06:43:31 <lambdabot> (Num a, Eq a) => a -> Bool
06:44:01 <gcganley> biinui: le1> the tip with cabal repl was really good
06:44:01 <gcganley> ERC> biinui: http://www.haskellforall.com/2014/10/ho-to-desugar-haskell-code.html
06:44:13 <gcganley> woops erc freaked out
06:44:21 <biinui> tdammers: nice examples, thanks!
06:44:28 <Procian> muzzle1: It's pretty good. I'm hoping that we'll be able to query types in our code without having to compile the whole file at some point.
06:44:35 <Procian> Ocaml and Scala are ahead of us there.
06:45:16 <biinui> Procian: i'll look up section. thanks!
06:45:25 <muzzle1> Procian: is there a good way to jump to the definition of a function ?
06:45:42 <muzzle1> i already read that there is a way to do it with hasktags
06:46:00 <tdammers> muzzle1: yeah. hasktags -c ., and then in vim C-]
06:46:39 <gcganley> hey ocharls' blog doesnt have the new advent calender up... i was just reading it and now i cant find it
06:46:50 <biinui> gcganley: thanks for finding it. i'll look into it. thanks!
06:47:23 <Procian> And M-. in Emacs.
06:48:07 <tdammers> plus you need a slightly different option to hasktags to make it generate an emacs tags file instead of a vi one
06:50:02 <gcganley> @tell ocharles your ocharles.org.uk/blog/ doesnt display 24 days of ghc extenstions on my desktop but does on my ipad
06:50:02 <lambdabot> Consider it noted.
06:50:20 <ocharles> gcganley: ack
06:50:28 <ocharles> gcganley: tried a force refresh?
06:50:30 <muzzle1> also works like a charm with 'M-x haskell-process-generate-tags'
06:50:33 <orion> Why are typeclasses frowned upon as opposed to record types?
06:50:34 <ocharles> I have bad caching settings on my site?
06:50:35 <nkar> Procian: is there a way to jump back?
06:50:40 <ocharles> -?
06:50:41 <nkar> after M-.
06:50:42 <gcganley> ocharles: yes im going to clear cache next one sec
06:51:16 <chrisdone> if you install ghci-ng you can have goto definition M-. in emacs be reliable
06:51:24 <chrisdone> instead of tags based
06:51:25 <Procian> nkar: Yeah. Just pop your mark.
06:51:35 <Procian> C-c SPC
06:51:49 <gcganley> ocharles: cleared cache and it worked
06:52:05 <chrisdone> also type info of sub-expressions via C-c C-t =)
06:52:05 <gcganley> ocharles: weird it had it up on my desktop yesterday...
06:52:07 <ocharles> gcganley: cool. I should get those settings fixed
06:52:08 <nkar> Procian: hmm, it's undefined.  perhaps I need to updated.
06:52:11 <nkar> te*
06:52:13 <Procian> Might have to be the global mark. So that's C-x C-@
06:52:23 <Procian> Check for "pop-global-mark"
06:52:25 <chrisdone> C-u M-. should jump back in emacs mode
06:52:45 <gcganley> ocharles: what are you using? snap?
06:52:53 <ocharles> gcganley: html files :)
06:52:58 <ocharles> I use hakyll
06:53:00 <nkar> chrisdone: it jumps to the end of the file
06:53:06 <gcganley> ocharles: oh ok
06:53:08 <nkar> "back to the end of the file"
06:54:44 <chrisdone> nkar: must be buggy
06:55:19 <chrisdone> nkar: but purcell
06:55:20 <Procian> chrisdone: Will definitely check out ghci-ng.
06:55:30 <Procian> nkar: Try M-*.
06:55:34 <nkar> I'm using an outdated version.  I'll update in a couple of days and report any issues.
06:55:58 <nkar> Procian: Yes!
06:56:02 <nkar> it works, ty
06:56:44 <nkar> would be cool to remap it to M-. or M-, at least
06:56:49 <ocharles> chrisdone: are you using ghci-ng in production?
06:56:50 <ocharles> err
06:56:56 <ocharles> where production means day-to-day usage
06:57:05 <ocharles> i'm too used to typing "in production" at work :P
06:57:20 <chrisdone> yup
06:57:57 <chrisdone> works very well indeed
06:58:04 <ocharles> I should probably check it out. I basically act like chris done to enter text, and edwardk to write code
06:58:09 <ocharles> haskell is much easier if you just pretend to be other people
06:58:10 <chrisdone> here's a little page i whipped up: https://github.com/haskell/haskell-mode/wiki/Using-GHCi-ng
06:58:18 <chrisdone> Procian: ^
06:58:37 <chrisdone> oh also the ghci-ng page itself has info on how to use it with haskell-mode
06:58:54 <chrisdone> https://github.com/chrisdone/ghci-ng#using-with-haskell-mode
06:59:03 <Procian> Sweet.
06:59:09 <isBEKaml> ocharles: easier? so you think things like this? "I'm edwardk, I won't write code like this!"
07:01:13 <chrisdone> it works nicely with shm
07:01:16 <gcganley> whats the motivation behind ghci-ng?
07:01:26 <chrisdone> gcganley: being ghci plus features ghci should have
07:02:05 <chrisdone> they'll be merged into ghci mainline at some point
07:02:12 <chrisdone> but probably not for a while
07:02:19 <Procian> chrisdone: I take it all these source locations are recorded and accessible via the GHC API?
07:02:24 <gcganley> chrisdone: it says its 7.6.3, does it have an issue with the 7.8.3 features or are they added in
07:02:56 <chrisdone> Procian: yeah. i load the module, get all the source spans, and keep them in memory for later access
07:03:03 <Procian> (firing up haddock in a browser by doing a keystroke on a sequence would be pretty cool too)
07:03:09 <chrisdone> gcganley: where does it say 7.6.3?
07:03:26 <gcganley> chrisdone: yes
07:03:36 <gcganley> chrisdone: .cabal
07:03:42 <Procian> Not sure there'd be a robust way to do that.
07:03:50 <gcganley> and yes i read your question wrong
07:04:42 <gcganley> chrisdone: https://github.com/hvr/ghci-ng/blob/master/ghci-ng.cabal#L2
07:04:42 <phaskell> L2 Developer Certificate of Origin - https://phabricator.haskell.org/L2
07:04:51 <chrisdone> gcganley: that's not the right repo
07:04:54 <chrisdone> https://github.com/chrisdone/ghci-ng
07:05:07 <gcganley> chrisdone: thats awkward
07:05:11 <gcganley> chrisdone: thanks
07:05:11 <chrisdone> Procian: the info is there, so you could implement that
07:05:38 <chrisdone> Procian: i suppose all you need is the package name, module name and identifier
07:05:47 <chrisdone> Procian: personally, i open haddock docs inside emacs with w3m =p
07:07:05 <nkar> chrisdone: I'd like to try hell.  do you use it on a daily basis?  any known issues?
07:07:29 <Procian> chrisdone: I do too. I've got '(browse-url-browser-function (quote w3m-browse-url)) in my custom-set-variables.
07:07:40 <Procian> So by "open a browser", I just mean "open w3m." :)
07:09:20 <chrisdone> nkar: nah i don't use it very often yet
07:09:40 <chrisdone> Procian: ah, but i have special hooks that format haddocks speshul =p
07:10:40 <chrisdone> Procian: anyhoo if you want to implement that, you could just modify :find-loc in ghci-ng to reeturn something structured instead of "No locally loaded module for GHC.Base. It's in this package: base"
07:11:47 <chrisdone> bbl
07:15:57 * hackagebot jsontsv 0.1.4.1 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.1 (DanielChoi)
07:15:59 * hackagebot dual-tree 0.2.0.5 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.5 (bergey)
07:18:46 <jeltsch> I want to create an array without initializing its elements, so that array allocation takes constant time (modulo heap management).
07:18:56 <jeltsch> What are possible approaches for this?
07:19:24 <jeltsch> I thought about using IOUArray with newArray_. Is this guaranteed to not do any initialization? Are there other ways?
07:21:39 <carter> jeltsch: use vector instead of array
07:22:07 <carter> jeltsch: have yoiu measrued the relative perf?
07:22:27 <carter> unless you have some pretty exotic stuff going on,that shouldnt be a measurable perf difference
07:23:26 <jeltsch> carter: I want to implement an algorithm that shall run in O(1) time.
07:23:40 <carter> which one
07:23:56 <jeltsch> carter: An algorithm for order maintenance.
07:24:06 <carter> explain more
07:24:25 <carter> plz
07:24:26 <jeltsch> I cannot explain the algorithm in short (too complicated).
07:24:30 <jeltsch> But the problem.
07:24:38 <jeltsch> You want to maintain a total order.
07:24:59 <jergason> hello haskell friends
07:25:03 <jeltsch> You basically have a list of elements, where elements are not something you choose, but some sort of tags that the algorithm chooses.
07:25:08 <mmmm> Is there a way to set associativity of type operators?
07:25:08 <jergason> i just want an infinite list of the string " "
07:25:18 <jergason> is there a function to just create an infinite list of a single element?
07:25:29 <jeltsch> carter: You can create an element just before or after an existing element.
07:25:29 <mmmm> jergason: repeat ' ' ?
07:25:44 <jeltsch> carter: And you can check whether one element comes before or after another.
07:25:46 <jergason> mmmm: looks like that is it, thanks!
07:25:54 <carter> jeltsch: sounds like you want to do incremental sorting?
07:26:06 <jeltsch> carter: This is indeed what I want to do.
07:26:15 <carter> jeltsch: have you seen the
07:26:19 <jeltsch> carter: Have you looked at this as well?
07:26:22 <carter> @hackage vector-algorithms package
07:26:22 <lambdabot> http://hackage.haskell.org/package/vector-algorithms package
07:26:37 <carter> its by dolio  and has a lot of good stuff there
07:26:58 <jeltsch> carter: And it contains incremental sorting?
07:27:14 <carter> i dont think so, but it may give you some ideas for doing that
07:27:31 <carter> bubble sort is pretty good for certain classes of incremental sorting
07:27:52 <jeltsch> carter: Do you have pointers to libraries or articles on incremental sorting?
07:27:53 <carter> othewise in generall you need to do some sort of resize + memmove thing?
07:28:01 <carter> none! you'll have to google
07:28:10 <carter> how big is the thing?
07:28:22 <jeltsch> carter: I did use Google. :-)  Haven’t found much.
07:28:27 <jeltsch> carter: What thing?
07:28:38 <carter> the problem you actdually wanna solve
07:29:00 <jeltsch> carter: You mean number of element?
07:29:04 <carter> no
07:29:06 <carter> what is the goal
07:29:09 <carter> big picture
07:29:10 <carter> contex
07:29:12 <carter> t
07:29:17 <carter> "why i am solving it"
07:30:04 <jeltsch> My actual motivation is implementing FRP with incremental updates when signals change.
07:30:22 <carter> ok
07:30:26 <jeltsch> But I want to do the incremental computing stuff properly. That is, I want to come up with a library that is also usable in other contexts.
07:30:35 <carter> ok
07:30:39 <carter> thats harder :)
07:30:52 <carter> have you spoken wiht other people who work on that stuff?
07:30:57 <carter> a few of them hangout on #haskell-game
07:31:13 <jeltsch> In the FRP applications I have in mind, the lists will not be that large, but I want to do the incremental stuff such that it also works with “big data”.
07:31:24 <carter> how big
07:31:47 <jeltsch> carter: As big as you want (modulo memory restrictions).
07:32:20 <carter> ooooo, wanna help make GHC's RTS scale better on >= 100gb heaps?
07:32:29 <carter> no ones doing that
07:32:32 <carter> maybe you should 1
07:32:43 <jeltsch> carter: Regarding FRP: I am involved in FRP research and know about the state of the art regarding research output.
07:32:55 <carter> cool!
07:33:08 <carter> have you spoken with the folks doing indy frp work on #haskell-game
07:33:12 <carter> theres a few folks doing stuff like
07:33:16 <carter> like mm_freak
07:33:17 <jeltsch> carter: I have to take a closer look on some of the concrete FRP libraries. I do not know all of them.
07:33:25 <carter> theres quite a few!
07:34:05 <jeltsch> carter: But I wonder to what degree they solve certain core issues of FRP. There are some tricky things.
07:34:14 <carter> go on
07:34:25 <carter> i'm somewhat familiar, but happy to hear your take
07:35:19 <jeltsch> carter: Creating a behavior/signal/event stream at one time and using it at another one may lead to semantical surprises or time and space leaks.
07:35:32 <carter> time travel !
07:35:36 <carter> time leaks etc
07:35:46 <carter> neelk has some cool theory work on that stuff
07:36:01 <jeltsch> There are solutions to this, but the ones I know involve advanced type system stuff or restrict FRP to just continuous stuff.
07:36:34 <carter> yeah, i think you'll have fun talking with folks on #haskell-game
07:36:38 <jeltsch> carter: I know about neelk’s work. It is trickier though to implement such ideas in Haskell such that programming with the resulting library still feels natural.
07:36:57 <jeltsch> Yes, I should join #haskell-game. Thank you for this hint.
07:37:04 <carter> glad to repeate it :)
07:37:28 <carter> its secretely the union of hypotheticall #haskell-opengl and #haskell-frp
07:37:44 <jeltsch> Sounds interesting!
07:39:00 <carter> i just lurk there :)
07:39:15 <alpounet> that's indeed a quite accurate description!
07:39:26 <carter> alpounet: yes
07:39:27 <carter> :)
07:39:49 <carter> alpounet: huh, phrased that way, its just #haskell-jmcarthur
07:40:30 <alpounet> it kind of used to be, at least that's how I saw it, until a year or two ago. i've learned the various flavors of FRP there with him :)
07:40:51 <carter> it is a bigger channel now
07:40:56 <carter> and he's busy with his stuff
07:40:58 * hackagebot diagrams-core 1.2.0.4 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.4 (bergey)
07:50:58 * hackagebot diagrams-lib 1.2.0.6 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.6 (bergey)
07:53:22 <mmachenry> How can there be type a like "type Application m = http://hackage.haskell.org/package/network-conduit-1.0.4/docs/Data-Conduit-Network.html#t:AppData m -> m ()" ? Can some one explain what it means to have, for example, and (AppData IO). IO is not instantiated to a specific type.
07:53:36 <mmachenry> Oops, sorry, cut and paste fail.
07:54:01 <mmachenry> type Application m = AppData m -> m ()
07:59:18 <nkar> mmachenry: do you know what 'type' means?  it's just a synonym for the right hand side.
07:59:45 <angerman> If I have a function  f :: (Monad m1, Monad m2) => b -> m1 (m2 c), and I have another function g :: (Monad m1, Monad m2) => a -> m1 (m2 b), where m1 and m2 are identical to both functions, what is the >>= equivalent? e.g. >>=' :: (Monad m1, Monad m2) => m1 (m2 a) -> (a -> m1 (m2 b) -> m1 (m2 b) ?
08:00:59 * hackagebot diagrams-contrib 1.1.2.4 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.4 (bergey)
08:01:01 * hackagebot diagrams-postscript 1.1.0.3 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1.0.3 (bergey)
08:02:04 <mmachenry> nkar: Yeah, I guess I didn't realize it could represent a partially applied type constructor.
08:04:50 <nkar> mmachenry: a good way to understand such things is to fire up ghci and use :t.  you can use undefined instead of actual values.
08:17:04 <fizz_ed> I'm getting a "cabal: Codec.Compression.Zlib: premature end of compressed stream" on 'cabal install --only-dependencies' in a sandboxed environment. The only package involved is 'chatter'. Not sure what to do next?
08:17:45 <fizz_ed> I also noticed that an older version of chatter (0.2.0.1) is being installed instead of the latest (0.5.0.0).
08:17:57 <dcoutts_> fizz_ed: those are independent issues
08:18:12 <dcoutts_> fizz_ed: it'll be a truncated download, you can delete the cached copy and try again
08:19:40 <fizz_ed> dcoutts: I tried `rm ~/.ghc` and `rm .cabal-sandbox`, reinitialized the sandbox, and tried again. Is there another place where it might be cached?
08:19:58 <fizz_ed> dcoutts `rm -r .cabal-sandbox` *
08:20:10 <dcoutts_> fizz_ed: the downloaded package tarballs are kept in ~/.cabal/packages/$server/
08:20:23 <fizz_ed> dcoutts: ahh thank you.
08:20:38 <dcoutts_> this location is specified in your ~/.cabal/config file
08:22:14 <fizz_ed> dcoutts: Much obliged. I'm less than three weeks with haskell, I appreciate the education.
08:22:59 <fizz_ed> dcoutts_: (tab completion wasn't finding the _)
08:23:27 <mauketwork> that's because both dcoutts and dcoutts_ are here
08:23:38 <mauketwork> (had to hit tab twice for that)
08:24:22 <fizz_ed> mauketwork: hardcore.
08:24:52 <TallerGhostWalt> is there a here interpolator for text?
08:38:51 <prophile> ☃
08:41:01 * hackagebot github-backup 1.20141204 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20141204 (JoeyHess)
08:44:45 <mmachenry1> Does anyone know of any code snippets or tutorials that I can look at that use Conduit with a threaded element in the pipeline?
08:51:25 <L8D> why do people rely on code examples and tutorials so much?
08:51:45 <L8D> :s/people/many programmers/
08:53:18 <texasmynsted> anybody know when the next haskellcast will be?
08:53:30 <nkar> ReinH: ^
08:53:35 <sivteck> ReinH, ReinH ReinH! ! !
08:53:41 <texasmynsted> :-)
08:53:52 <L8D> where should I ask my question?
08:54:05 <josephle> L8D: #haskell-blah?
08:54:17 <L8D> I guess I'll go to stackoverflow
08:54:43 <texasmynsted> L8D because abstract concepts can be difficult to explain.  An example can often "show" rather than "tell" somebody about the concept.
08:54:58 <Taneb> texasmynsted, I believe I heard somewhere the next one will be January sometime
08:55:15 <L8D> well, I'm also talking about times when people want to learn how to use a framework or library, not just overcome some abstract concept
08:55:18 <texasmynsted> :-(  That is a long time from now
08:55:31 <L8D> it's as if they never heard of API documentation
08:56:05 <texasmynsted> L8D api documentation serves a slightly different need
08:56:34 <L8D> but that's all I've ever needed to become familiar with libraries and frameworks
08:56:43 <L8D> "how do I do this?"
08:56:48 <Ferdirand> some may say a good api is self-documenting
08:56:49 <L8D> "IT'S IN THE DOCS"
08:57:00 <mmachenry1> texasmynsted: It's been recorded.
08:57:14 <L8D> wait.... I guess I've never taken a library seriously when it doesn't have good API docs
08:58:10 <texasmynsted> mmachenry: Cool!
08:59:01 <texasmynsted> L8D: What is the problem?
08:59:29 <L8D> texasmynsted: problem with? my question? the library?
09:01:45 <texasmynsted> yes, I guess I missed some scrollback
09:01:58 <L8D> yes as in my question or the library?
09:02:04 <L8D> both?
09:03:39 <texasmynsted> I suppose either.  Did you have a question?  Otherwise #pointlesscomplaining is a useful channel as well.
09:04:25 <L8D> I'm genuinely curios as to why other people aren't satified with just API documentation
09:04:38 <L8D> curious*
09:04:47 <L8D> satisfied*
09:05:00 <L8D> I'm asking the question on stackoverflow-meta
09:06:34 * texasmynsted shrugs 
09:06:37 <texasmynsted> ok
09:12:30 <L8D> texasmynsted: https://meta.stackoverflow.com/questions/278462/why-do-so-many-programmers-rely-solely-on-tutorials-and-code-examples-to-learn
09:17:15 <L8D> derp
09:18:58 <samba1> After seeing someone ask about clock arithmetic on the beginners mailing list, a colleague suggested I try doing a clock monoid as I'm learning Haskell
09:19:00 <bergey> L8D: I'd rather have API docs and tutorials.  If I have to pick, I'll take API docs, but it doesn't surprise me that some people have the opposite preference.
09:19:03 <samba1> http://lpaste.net/115659
09:19:07 <samba1> There are comments and questions inline - I'd be interested in any answers or other feedback from experts.
09:21:53 <bergey> In particular, I prefer tutorials when I want to do the simple, obvious, most common thing with the library.  Eg, "I already know how to write regexen, I want to replace every occurance of REGEX with STRING, how do I do this?"  Maybe I'll eventually want to learn the whole API, maybe not.
09:22:28 <bergey> I wish more medium-size Haskell libraries led with "you probably want to start by looking at SOMEFUNCTION".
09:22:29 <wei2912> bergey++
09:28:09 <dfeuer> Cale, I think I might understand something you told me yesterday, and that it is correct. That is, holding the start and end indices relative to the entire original may make calculations saner.
09:28:52 <wakalabis> Hey, guys. I seems that older versions Control.Monad.Trans.Cont used to have functions `reset` and `shift`. I can’t find them now (v0.4.2.0). Am I missing something?
09:28:59 <wakalabis> *it seems
09:29:22 <dfeuer> @google Control.Monad.Trans.Cont
09:29:23 <lambdabot> https://hackage.haskell.org/package/transformers-0.1.4.0/docs/Control-Monad-Trans-Cont.html
09:30:21 <wakalabis> @dfeuer, It seems to me older versions had shift and reset and newer ones don’t
09:30:21 <lambdabot> Unknown command, try @list
09:30:43 <sivteck> 0.1.4.0 is from 2009 ;p
09:31:45 <benzrf> is it possible to define generators simply using Cont or do you have to do so much work that you might as well do it from scratch?
09:32:14 <dfeuer> wakalabis, you are wrong.
09:32:22 <sivteck> wakalabis, http://hackage.haskell.org/package/transformers-0.4.2.0/docs/src/Control-Monad-Trans-Cont.html#reset
09:32:33 <dfeuer> Old versions don't have it; new ones do.
09:32:35 <wakalabis> right!
09:33:00 <dfeuer> You said the opposite.
09:33:00 <wakalabis> I’ve got to check my cabal sandboxes
09:33:12 <wakalabis> dfeuer: you’re right
09:33:16 <wakalabis> thanks
09:33:18 <dfeuer> Ah, okay.
09:39:17 <benzrf> @check \v -> v / sqrt v == sqrt v
09:39:19 <lambdabot>  *** Failed! Falsifiable (after 1 test):
09:39:19 <lambdabot>  0.0
09:39:23 <benzrf> mfw
09:41:19 <dmead> ?yow
09:41:19 <lambdabot> My face is new, my license is expired, and I'm under a doctor's care!!!!
09:41:48 * glguy_ wonders how long it has been since that command was last used
09:43:08 <benzrf> glguy_: not very
09:43:10 <benzrf> @yow
09:43:10 <lambdabot> Yow!  Are we laid back yet?
09:49:07 <Grisha> Hello
09:49:24 <red__> do i need to do anything special to use template haskell functionality? the head of my file has a {-# LANGUAGE stuff -#} line
09:49:30 <Grisha> do I understand it correctly that Data.Vector.Storable are just 1D?
09:49:44 <red__> i compile and i get a "perhaps you meant to use template haskell" error
09:49:52 <red__> *try to compile
09:50:16 <gcganley> grisha: hello
09:50:20 <Denommus> red__: {-# LANGUAGE TemplateHaskell -#} or something
09:50:38 <red__> {-# LANGUAGE TypeFamilies, QuasiQuotes #-}
09:50:39 <gcganley> red__: lpaste it
09:50:57 <Grisha> gcganley: hi
09:51:21 <Denommus> red__: no, I mean that you need to add TemplateHaskell (or maybe Template)
09:52:00 <Hijiri> It's TemplateHaskell
09:52:09 <Hijiri> or is there a separate Template extension
09:52:25 <creichert> TemplateHaskell is the language extension
09:52:32 <creichert> LANGUAGE TemplateHaskell
09:53:09 <red__> thanks
09:53:10 <red__> {-# LANGUAGE TemplateHaskell, TypeFamilies, QuasiQuotes #-}
09:53:11 <red__> works
09:53:13 <creichert> nice
09:53:18 <red__> now a new host of problems
09:53:32 <creichert> on the compiole output, you see a [TH] at the end on files which have it enabled
09:54:56 <creichert> red__: is it a cabal project?
09:58:17 <red__> a yesod project .. which initialize all that cabal stuff for me.
09:58:19 <red__> so, yes?
10:00:11 <creichert> yes
10:00:43 <creichert> is it a new scaffold site? Are you building with the "cabal" command?
10:00:51 <creichert> (I can help out in #yesod as well)
10:05:21 <athan> Is there a function to pack/unpack between Data.Text.Text and Data.Text.Lazy.Text?
10:06:45 <glguy_> :t (Data.Text.Lazy.toStrict, Data.Text.Lazy.fromStrict)
10:06:46 <lambdabot> (Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text, Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text)
10:07:13 <gcganley> glguy_: that looks like it forms a category...
10:07:53 <glguy_> How do you mean?
10:08:15 <Hijiri> what is the romanization of the name of the greek letter that looks like an 'n'?
10:08:16 <gcganley> well thats bidirectional and a product type
10:08:59 <gcganley> Hijiri: send a link to the charecter or type in the unicode version
10:08:59 <HeladoDeBrownie> Hijiri, what, eta?
10:09:00 <glguy_> Hijiri: Do you mean "eta"?
10:09:15 <Hijiri> thanks HeladoDeBrownie glguy_
10:09:29 <Hijiri> oh, maybe I can copy-paste it to be sure
10:09:37 <Hijiri> η
10:09:39 <HeladoDeBrownie> eta
10:09:39 <gcganley> eta
10:09:42 <HeladoDeBrownie> jinx
10:09:46 <Hijiri> alright, thanks
10:09:48 <benzrf> η
10:09:59 <benzrf> ηβπ
10:10:02 <gcganley> benzrf: thats eta ill have yo know
10:10:38 <mikia> Hi
10:10:44 <HeladoDeBrownie> benzrf, ate a bit of pie?
10:10:45 <gcganley> mikia: hello
10:10:48 <kadoban> Hijiri: Just fyi: you can usually google for weird symbols, if you have them in text format. Mostly the wikipedia page comes up :)
10:11:01 <gcganley> HeladoDeBrownie: that hurt me...
10:11:09 <glguy_> gcganley: Categories have an identity element and an associative operator. I don't think that this one fits in
10:11:23 <mikia> How would I find the most significant bit of an Integer? Or the highest power of two that fits in the Integer, if that's easier?
10:11:37 <gcganley> glguy_: i always thought they had objects and arrows
10:11:39 <mikia> I'm terrible with bit shifts :(
10:11:49 <glguy_> gcganley: Yup, those too
10:12:01 <HeladoDeBrownie> mikia, logBase 2
10:12:04 <kadoban> mikia: That's highly related to the base-2 logarithm, that might be a good place to start, unless you're trying to do it by hand for whatever reason.
10:12:08 <HeladoDeBrownie> > logBase2 128
10:12:10 <lambdabot>  Not in scope: ‘logBase2’
10:12:10 <lambdabot>  Perhaps you meant ‘logBase’ (imported from Prelude)
10:12:13 <HeladoDeBrownie> > logBase 2 128
10:12:15 <lambdabot>  7.0
10:12:16 <HeladoDeBrownie> > logBase 2 129
10:12:18 <lambdabot>  7.011227255423254
10:12:25 <mikia> Oh :O
10:12:44 <mikia> I guess I'd need to round/floor/ceil it though.
10:12:47 <HeladoDeBrownie> Yep
10:13:01 <kadoban> Floor probably, yeah.
10:13:05 <mikia> I'll try that. Very appreciated :)
10:13:16 <HeladoDeBrownie> I hope that wasn't an exercise I just gave away :X
10:13:25 <mikia> Nah, don't worry :)
10:13:28 <kadoban> Hehe
10:13:34 <gcganley> glguy_: i remeber hearing about how serialization and deserialization forms a cat
10:14:19 <glguy_> gcganley: Maybe you're thinking of "isomorphism"?
10:14:42 <gcganley> glguy_: sounds like an iso, ill look up what i heard it from
10:15:00 <gcganley> glguy_ i heard it while watching the haskell cast
10:15:02 <HeladoDeBrownie> glguy_, gcganley, there isn't a single identity "element" for a given category, but every object in a category has an identity arrow from itself to itself
10:15:53 <HeladoDeBrownie> Maybe what you're thinking of is how we seem to have this single id function in Haskell, but actually that's several id functions, each one specialized to a specific type (object)
10:16:12 <flyingfisch> @hoogle forever
10:16:13 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
10:16:55 <HeladoDeBrownie> In other words, id :: forall a. a -> a is not an arrow in our (imaginary) category Hask; however, id :: Bool -> Bool is
10:17:28 <hiptobecubic> > forever (return 0) :: [Int]
10:17:32 <lambdabot>  mueval-core: Time limit exceeded
10:22:17 <int-e> > snd (runWriter (forever (tell [0])))
10:22:18 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:23:25 <meme> so much joining and quitting, so I am writing this to see how regular messages look like
10:23:43 <eXeC64> > forever (Just True)
10:23:47 <lambdabot>  mueval-core: Time limit exceeded
10:24:04 <Hijiri> > fix (\thing -> (:) <$> pure 0 <*> thing) :: [Int]
10:24:05 <lambdabot>  Couldn't match type ‘[a0]’ with ‘GHC.Types.Int’
10:24:05 <lambdabot>  Expected type: a0 -> [a0] -> GHC.Types.Int
10:24:05 <lambdabot>    Actual type: a0 -> [a0] -> [a0]Couldn't match type ‘GHC.Types.Int’ with ‘[...
10:24:05 <lambdabot>  Expected type: [[a0]]
10:24:05 <lambdabot>    Actual type: [GHC.Types.Int]
10:24:12 <meme> 1 + 1
10:24:27 <meme> how do you do that?
10:24:41 <HeladoDeBrownie> Prefix with "> "
10:24:47 <Hijiri> > fix (\thing -> (0:) <$> thing) :: [Int]
10:24:48 <lambdabot>  Couldn't match type ‘[a0]’ with ‘GHC.Types.Int’
10:24:48 <lambdabot>  Expected type: [a0] -> GHC.Types.Int
10:24:48 <lambdabot>    Actual type: [a0] -> [a0]Couldn't match type ‘GHC.Types.Int’ with ‘[a0]’
10:24:48 <lambdabot>  Expected type: [[a0]]
10:24:48 <lambdabot>    Actual type: [GHC.Types.Int]
10:24:56 <HeladoDeBrownie> Although, it's preferred to keep most lambdabot chatter in PM unless demonstrating
10:25:01 <meme> @HeladoDeBrownie, thx!
10:25:01 <lambdabot> Unknown command, try @list
10:25:05 <meme> > 1 + 1
10:25:06 <lambdabot>  2
10:25:20 <HeladoDeBrownie> Also best avoid prefixing things that aren't lambdabot commands with @ :)
10:25:24 <eXeC64> forever makes sense for a list monad, but what does it give for Maybe?
10:25:35 <eXeC64> Does it just continuously wrap in Just?
10:25:41 <HeladoDeBrownie> @src forever
10:25:42 <lambdabot> Source not found. Sorry.
10:25:58 <meme> HeladoDeBrownie, for example?
10:26:03 <HeladoDeBrownie> forever a   = let a' = a >> a' in a'
10:26:12 <meme> > [1..]
10:26:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:26:21 <flyingfisch> ok, was experimenting to see if I could do mutable stuff in do, and I get the output "main: <<loop>>" http://lpaste.net/115668
10:26:23 <mettekou> undefined
10:26:25 <flyingfisch> why?
10:26:28 <HeladoDeBrownie> meme, well, lambdabot responded to you starting a line with @HeladoDeBrownie. Usually on IRC we don't use @ that way
10:26:35 <meme> > product [1..] !! 100
10:26:36 <lambdabot>  No instance for (GHC.Show.Show a0)
10:26:36 <lambdabot>    arising from a use of ‘M11872318751606664881954.show_M11872318751606664881...
10:26:37 <lambdabot>  The type variable ‘a0’ is ambiguous
10:26:37 <lambdabot>  Note: there are several potential instances:
10:26:37 <lambdabot>    instance [safe] GHC.Show.Show
10:26:45 <meme> oops
10:26:45 <eXeC64> Also, is there a way in ghci to see the definition of of a function?
10:26:52 <HeladoDeBrownie> eXeC64, forever (Just True) = let a' = Just True >> a' in a'
10:26:59 <Cale> eXeC64: forever doesn't make much sense with the list monad
10:26:59 <int-e> eXeC64: It really doesn't make much sense for List nor Maybe. For Maybe, forever Nothing = Nothing, forever (Just _) is bottom; for List, forever [] = [], forever (_:_) = bottom.
10:27:21 <HeladoDeBrownie> eXeC64, = Just True >> Just True >> Just True >> …
10:27:22 <Hijiri> flyingfisch: you're defining x = x + 1
10:27:30 <Hijiri> that expands to x = (x + 1) + 1
10:27:45 <Hijiri> and ((x + 1) + 1) + 1
10:27:45 <eXeC64> How does that fit the type?
10:27:47 <Hijiri> and so on
10:27:50 <flyingfisch> hmm
10:27:55 <eXeC64> Oh, it's an infinite expression ending in that type?
10:27:58 <Hijiri> you can't do mutability that way
10:28:05 <int-e> eXeC64: that's why I used the Writer monad above, which I believe is the simplest monad that allows actions' side effects to be observed before the whole computation has finished.
10:28:06 <flyingfisch> do that have something to do with the hidden structure of the do loop?
10:28:10 <flyingfisch> *does
10:28:22 <eXeC64> int-e: I figured as much, about writer. I was reading about it yesterday.
10:28:24 <Hijiri> no, it has to do with "x = x + 1" recursing forever
10:28:41 <flyingfisch> oh wait ok
10:28:42 <flyingfisch> i get it
10:28:45 <Hijiri> why should you be able to do mutability in any do block?
10:28:54 <Hijiri> you can't have mutable variables for monads in general
10:28:58 <HeladoDeBrownie> eXeC64, yeah. Some "infinite" expressions terminate, but it happens that with the specialization of (>>) to Maybe, this one doesn't ever
10:29:26 <Hijiri> From a do block, "let x = y; ..." desugars to "let x = y in ..."
10:29:45 <Hijiri> It's just a normal let statement with the rest of the block in an implicit "in"
10:30:03 <flyingfisch> Hijiri: well... I was trying to figure out how I could use a variable to store the last time an event happened in my do block
10:30:19 <flyingfisch> do I need to use WriterT?
10:30:28 <Hijiri> If it's IO, you can use IORefs, or just use recursion
10:30:40 <Hijiri> use a helper function instead of putting everything in main
10:30:50 <Hijiri> and then you can pass the last time in as a parameter
10:31:10 * hackagebot haddocset 0.3.1 - Generate docset of Dash by Haddock haskell documentation tool  http://hackage.haskell.org/package/haddocset-0.3.1 (HirotomoMoriwaki)
10:31:18 <flyingfisch> Hijiri: I was just trying to get a minimal case
10:31:19 <int-e> flyingfisch: That sounds more like a state to me, which would point at StateT.
10:31:34 <flyingfisch> int-e: ok
10:31:42 <Hijiri> something this simple doesn't look like a good fit for State
10:31:55 <flyingfisch> well
10:31:57 <Hijiri> If you were doing something more complicated then maybe
10:32:05 <flyingfisch> it gets a little more complicated in my actual program
10:33:48 <flyingfisch> I am building an IRC bot as a learning project, and I want to know when the last command was done, and retrieve it with another command. The way I would do it in python is store the timestamp when the command I want to track is run, and then retrieve current time minus the timestamp to get the time since the operation
10:33:56 <flyingfisch> this is my code so far: https://github.com/flyingfisch/haskell-fischbot/tree/master
10:34:22 <flyingfisch> right now I use runReaderT to take care of my Read-Only globals
10:34:58 <flyingfisch> but I also want to be able to store mutable variables
10:35:06 <orion> Why are typeclasses frowned upon as opposed to record types?
10:36:11 <Hijiri> Do you know what kind of variables they will be in advance?
10:36:17 <gcganley> flyingfisch: StateT?
10:36:52 <Hijiri> I would recommend something like RWST, so you don't have to deal with multiple transformer layers
10:37:01 <flyingfisch> RWST?
10:37:10 <Hijiri> Reader Writer State T
10:37:15 <flyingfisch> ah ok
10:37:17 <flyingfisch> hmm
10:37:18 <Hijiri> There might be  a just RST, I don't know
10:37:47 <flyingfisch> i think i will read up on Writer and State and come back in a bit ;)
10:37:52 <Hijiri> it implements MonadState and MonadReader, so you can just use get/ask etc
10:38:16 <Hijiri> "implements"
10:38:20 <Hijiri> has instances for
10:38:34 <Hijiri> I must cleanse myself of anything reminiscent of java
10:38:39 <flyingfisch> hmm
10:38:45 <flyingfisch> so
10:38:53 <flyingfisch> would I still use runReaderT?
10:39:13 <Hijiri> no
10:39:17 <HeladoDeBrownie> runRWST
10:39:34 <HeladoDeBrownie> which in addition to supplying the reader environment supplies the state and writer ones too
10:39:55 <HeladoDeBrownie> Er, returns the Writer environment, rather
10:40:07 <HeladoDeBrownie> @type runRWST
10:40:08 <lambdabot> RWST r w s m a -> r -> s -> m (a, s, w)
10:40:09 <flyingfisch> woah
10:40:20 <flyingfisch> so then I can use all those different types?
10:40:49 <HeladoDeBrownie> So you've got r, your reader environment, s, your initial state, and it returns a, your computed value, s, your final state, and w, your writer output
10:41:04 <HeladoDeBrownie> It's really just a mashing together of those three things, so yeah
10:41:31 <HeladoDeBrownie> You can even ignore one or more by setting the type to ()
10:41:36 <flyingfisch> k
10:41:41 <FofG> If I've added a dependency in my cabal file, I can just run cabal install --only-dependencies again and it'll just install the new dependencies?
10:41:43 <HeladoDeBrownie> Say you only care about reader and state, you can set w ~ ()
10:42:24 <dcoutts_> FofG: yep, if you want to see what it'd do, add the --dry-run flag
10:42:30 <flyingfisch> is r () () the same as runReaderT?
10:42:35 <FofG> cool, thanks dcoutts_
10:42:56 <HeladoDeBrownie> flyingfisch, yep
10:43:01 <HeladoDeBrownie> flyingfisch, well, er, same as ReaderT
10:43:07 <HeladoDeBrownie> RWST r () ()
10:43:08 <flyingfisch> oh yeah
10:43:12 <flyingfisch> right
10:43:17 <FofG> Also, a general question: what do people generally do for config files for apps? I'm looking at "ConfigFile" in Hackage, but wasn't sure how people generally handle this type of thing in Haskell projects.
10:43:45 <HeladoDeBrownie> flyingfisch, it's not the same *on the nose* as it happens, but it's got the same capabilities, and using the MonadReader typeclass it's effectively the same
10:44:11 <HeladoDeBrownie> They're still distinct types according to the type system, because it doesn't recognize that they're really just the same thing
10:44:12 <flyingfisch> hmm, is there a good tutorial or example of how it works?
10:45:02 <HeladoDeBrownie> Well are you familiar with reader, writer, and state already?
10:45:44 <HeladoDeBrownie> Reader* Writer* State*
10:45:45 <flyingfisch> only reader and a little bit of writer
10:46:00 <flyingfisch> I mean, I think I get how they work, just not how to use them
10:46:10 <flyingfisch> i do know how to use Reader though
10:46:29 <HeladoDeBrownie> flyingfisch, read the appropriate sections after this heading https://www.haskell.org/haskellwiki/All_About_Monads#Introduction_2
10:46:41 <flyingfisch> ok thank you
10:47:06 <HeladoDeBrownie> "How to use them" is deceptively hard, because all of them are pretty simple
10:47:23 <HeladoDeBrownie> I mean, I think they *sound* harder to use than they are
10:47:44 <HeladoDeBrownie> And/or may sound more useful than they are :P
10:48:01 <RyanGlScott> Can someone explain to me why Whole was removed in nats-1?
10:48:31 <HeladoDeBrownie> I mean I don't think I've ever used State (i.e., StateT Identity) in an actual program I wrote, however I've used StateT in a larger stack of transformers
10:49:07 <flyingfisch> HeladoDeBrownie: yeah, if they are all as easy as Reader I think I won't have a big problem figuring them out
10:49:20 <flyingfisch> just need to have some time to experiment with ghci is all ;)
10:49:32 <HeladoDeBrownie> I think the most advantage of these is (a) after you figure out how to use the transformer versions; and (2) composing and lifting together stacks of different types
10:49:59 <benzrf> monad transformers are just a way to let you manipulate nested monads without all the manual repetition doing it by hand entials
10:50:02 <benzrf> *entails
10:50:39 <mjboa> can someone point in the direction of an explanation of how exactly the type checker works alongside type inference in ghc? im familiar with HM, just not sure when exactly user defined types are compared with inferred ones
10:57:43 <flyingfisch> liftIO basically gets rid of any other monad types a function might have and just gives it the IO type, right?
10:58:01 <bennofs> :t liftIO
10:58:02 <lambdabot> MonadIO m => IO a -> m a
10:58:20 <HeladoDeBrownie> The opposite, really; it embeds an IO action in an appropriate non-IO Monad
10:58:21 <slomo_> fling: the other way around, it lifts some IO action into the monad you're currently in
10:58:37 <flyingfisch> HeladoDeBrownie: oh ok
10:58:41 <flyingfisch> so like
10:58:57 <flyingfisch> it could make IO String become ReaderT IO String?
10:59:08 <HeladoDeBrownie> (Not necessarily non-IO, even; the IO specialization of liftIO is id)
10:59:09 <HeladoDeBrownie> flyingfisch, yep
10:59:32 <HeladoDeBrownie> Er, you're missing a type to apply to ReaderT, but you get the idea
11:00:07 <HeladoDeBrownie> IO String -> ReaderT Environment IO String
11:00:25 <flyingfisch> > liftIO (print "test") :: ReaderT () IO String
11:00:27 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
11:00:27 <lambdabot>  Expected type: GHC.Types.IO GHC.Base.String
11:00:27 <lambdabot>    Actual type: GHC.Types.IO ()
11:00:36 <HeladoDeBrownie> print returns ()
11:00:38 <HeladoDeBrownie> not String
11:00:41 <flyingfisch> oh yea
11:00:44 <flyingfisch> i forgot
11:00:49 <flyingfisch> > liftIO (print "test") :: ReaderT () IO ()
11:00:50 <lambdabot>  No instance for (GHC.Show.Show
11:00:50 <lambdabot>                     (Control.Monad.Trans.Reader.ReaderT () GHC.Types.IO ()))
11:00:50 <lambdabot>    arising from a use of ‘M37616378594115155202458.show_M37616378594115155202...
11:00:55 <HeladoDeBrownie> Yep, you got it
11:01:01 <flyingfisch> ok so it worked, it just can't show it
11:01:03 <flyingfisch> right?
11:01:05 <HeladoDeBrownie> Right
11:01:16 <flyingfisch> :t liftIO (print "test") :: ReaderT () IO ()
11:01:17 <lambdabot> ReaderT () IO ()
11:01:18 <HeladoDeBrownie> Try it in ghci, lambdabot just doesn't execute arbitrary IO
11:01:23 <flyingfisch> cooool
11:01:33 <flyingfisch> i think i am getting this :)
11:01:36 <HeladoDeBrownie> \o/
11:02:32 <flyingfisch> hmm
11:02:32 <flyingfisch> so
11:03:31 <flyingfisch> oh never mind
11:04:45 <flyingfisch> @hoogle throwError
11:04:45 <lambdabot> Control.Monad.Trans.Error throwError :: (Monad m, Error e) => e -> ErrorT e m a
11:04:45 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
11:04:45 <lambdabot> Control.Monad.Error throwError :: MonadError e m => e -> m a
11:07:57 <flyingfisch> hmm
11:08:03 <flyingfisch> shouldn't this work?
11:08:23 <flyingfisch> > throwError "error" :: MonadError String Maybe
11:08:24 <lambdabot>  Expected a type,
11:08:24 <lambdabot>    but ‘Control.Monad.Error.Class.MonadError GHC.Base.String Data.Maybe.Maybe...
11:08:53 <geekosaur> Maybe is not a tyoe
11:08:56 <geekosaur> *type
11:09:03 <geekosaur> hm, wait
11:09:09 <geekosaur> it should be a monad... derp
11:09:12 <flyingfisch> > throwError "error" :: MonadError Int Maybe
11:09:14 <lambdabot>  Expected a type,
11:09:14 <lambdabot>    but ‘Control.Monad.Error.Class.MonadError GHC.Types.Int Data.Maybe.Maybe’ ...
11:09:22 <geekosaur> :k MonadError
11:09:23 <lambdabot> * -> (* -> *) -> Constraint
11:09:35 <geekosaur> ah
11:09:44 <HeladoDeBrownie> MonadError is a typeclass, not a type
11:09:45 <geekosaur> MonadError is a class
11:09:48 <geekosaur> yes
11:09:49 <flyingfisch> oh
11:10:03 <flyingfisch> so what did I do wrong?
11:10:23 <HeladoDeBrownie> You tried to say a value's type was a Constraint, rather than a concrete type (*)
11:10:23 <geekosaur> you can't instantiate a typeclass directly like that
11:10:32 <flyingfisch> hmm ok
11:10:42 <flyingfisch> so how would I use throwError?
11:10:50 <geekosaur> likewise you can't claim that something is of "type" Fractional, because Fractional is not a type, it's a typeclass
11:11:04 <hexagoxel> mjboa: http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html probably contains the answer, but i admit it is long and focuses on the whole implementation
11:11:13 <flyingfisch> oooooh
11:11:14 <geekosaur> use a monad which has a MonadError instance
11:11:24 <flyingfisch> ok
11:11:35 <geekosaur> @instances MonadError
11:11:35 <flyingfisch> :t throwError
11:11:35 <lambdabot> e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
11:11:36 <lambdabot> MonadError e m => e -> m a
11:12:08 <flyingfisch> > throwError "error" :: e (String Maybe)
11:12:09 <lambdabot>  ‘GHC.Base.String’ is applied to too many type arguments
11:12:18 <HeladoDeBrownie> Try Either for now
11:12:21 <HeladoDeBrownie> That's a simple one
11:12:27 <flyingfisch> > throwError "error" :: Either (String Maybe)
11:12:28 <lambdabot>  ‘GHC.Base.String’ is applied to too many type arguments
11:12:37 <HeladoDeBrownie> Take out the parens
11:12:43 <flyingfisch> > throwError "error" :: Either String Maybe
11:12:44 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
11:12:45 <lambdabot>  The second argument of ‘Data.Either.Either’ should have kind ‘*’,
11:12:45 <lambdabot>    but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
11:12:51 <flyingfisch> > throwError "error" :: Either String Maybe String
11:12:52 <lambdabot>  ‘Data.Either.Either’ is applied to too many type arguments
11:12:57 <HeladoDeBrownie> Take out the Maybe
11:13:01 <flyingfisch> > throwError "error" :: Either String
11:13:02 <lambdabot>  Expecting one more argument to ‘Data.Either.Either GHC.Base.String’
11:13:02 <lambdabot>  Expected a type,
11:13:02 <lambdabot>    but ‘Data.Either.Either GHC.Base.String’ has kind ‘* -> *’
11:13:06 <Hijiri> or parens around Maybe Sting
11:13:06 <HeladoDeBrownie> Either takes two args
11:13:07 <Hijiri> String
11:13:09 <flyingfisch> :k Either
11:13:10 <lambdabot> * -> * -> *
11:13:16 <flyingfisch> > throwError "error" :: Either String Int
11:13:18 <lambdabot>  Left "error"
11:13:20 <HeladoDeBrownie> There you go
11:13:29 <flyingfisch> > throwError "error" :: Either Int String
11:13:30 <lambdabot>  No instance for (Control.Monad.Error.Class.MonadError
11:13:30 <lambdabot>                     [GHC.Types.Char] (Data.Either.Either GHC.Types.Int))
11:13:31 <lambdabot>    arising from a use of ‘Control.Monad.Error.Class.throwError’
11:13:40 <HeladoDeBrownie> Now you're giving it the wrong error type
11:13:46 <HeladoDeBrownie> It wants Int, you give it String
11:13:47 <flyingfisch> hmm
11:13:52 <flyingfisch> > throwError "error" :: Either String Int
11:13:54 <lambdabot>  Left "error"
11:13:56 <HeladoDeBrownie> > throwError 10 :: Either Int String
11:13:57 <lambdabot>  Left 10
11:14:14 <HeladoDeBrownie> > throwError () :: Maybe String
11:14:16 <lambdabot>  No instance for (Control.Monad.Error.Class.MonadError
11:14:16 <lambdabot>                     () Data.Maybe.Maybe)
11:14:16 <lambdabot>    arising from a use of ‘Control.Monad.Error.Class.throwError’
11:14:18 <HeladoDeBrownie> Woop
11:14:28 <HeladoDeBrownie> Heheh, that's not an instance
11:14:31 <flyingfisch> so what is throwError used for?
11:14:42 <HeladoDeBrownie> It's just a generic way of signaling an error
11:14:56 <HeladoDeBrownie> What the error does or means depends on the underlying Monad in question
11:15:03 <flyingfisch> oh
11:15:08 <flyingfisch> sort of like Maybe?
11:15:25 <flyingfisch> like Maybe can either give us just a value, or Nothing?
11:15:39 <flyingfisch> but it is up to us to figure out what that means?
11:15:42 <HeladoDeBrownie> Yeah, although as it happens Maybe doesn't have an instance, but MaybeT does
11:15:52 <flyingfisch> or actually to decide what it means
11:15:53 <flyingfisch> so
11:15:59 <HeladoDeBrownie> Although that one just forwards the error to what MaybeT is parameterized on
11:16:19 <flyingfisch> ok
11:17:21 <flyingfisch> so throwError doesn't actually stop program execution or anything?
11:17:27 <HeladoDeBrownie> throwError can be handy when you want to write to a specific interface rather than a specific type, then you can just say that the type the user provides must have an instance of MonadError available. You could also use it when it's more convenient than other ways of signaling errors for a given type
11:18:05 <flyingfisch> ah ok
11:22:37 <TallerGhostWalt> arm64 llvm target can't get here soon enough
11:27:18 <dfeuer> Cale, I need a remedial class in modular arithmetic :-/
11:27:30 <dfeuer> I keep goofing this up.
11:27:57 <dfeuer> Fortunately, I *have* managed to figure out how to test little bits of it one at a time!
11:31:29 <flyingfisch> can I get rid of the name of the program that gets displayed when I use error?
11:35:28 <monochrom> modify the compiler
11:36:04 <bennofs> flyingfisch: why would you want that?
11:36:33 <flyingfisch> bennofs: never mind, I was using it as a way to display a help message but now I am using catch
11:37:27 <monochrom> error is not meant for help message
11:38:55 <flyingfisch> monochrom: how can I stop the program execution then?
11:39:08 <flyingfisch> I have seen some people do a seg fault in C programs
11:39:25 <bennofs> flyingfisch: import System.Exit and use exitFailure :: IO a
11:39:27 <bennofs> :t exitFailure
11:39:28 <lambdabot>     Not in scope: ‘exitFailure’
11:39:29 <lambdabot>     Perhaps you meant ‘expectFailure’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
11:39:34 <bennofs> @hoogle exitFailure
11:39:34 <lambdabot> System.Exit exitFailure :: IO a
11:39:34 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
11:39:40 <flyingfisch> ok
11:39:53 <monochrom> I give up
11:40:09 <flyingfisch> monochrom: what do you mean you give up?
11:40:53 <monochrom> the correct answer is long and context-dependent, but you prefer one short answers that fits all sizes. we are irreconcilable.
11:41:11 * hackagebot keystore 0.7.0.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.7.0.1 (ChrisDornan)
11:41:13 * hackagebot blink1 0.4 - Control library for blink(1) LED from ThingM  http://hackage.haskell.org/package/blink1-0.4 (DylanSimon)
11:41:15 <flyingfisch> monochrom: not necessarily
11:41:16 * hackagebot apiary 1.2.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.2.0 (HirotomoMoriwaki)
11:41:18 * hackagebot apiary-logger 1.2.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.2.0 (HirotomoMoriwaki)
11:41:20 * hackagebot apiary-persistent 1.2.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.2.0 (HirotomoMoriwaki)
11:41:24 <lpaste> Luke pasted “http-streams 502 Bad Gateway” at http://lpaste.net/115680
11:41:44 <flyingfisch> monochrom: tell me the "proper" way to do it. I am open to it. ;)
11:41:46 <Luke> ^^ Can someone help me out with a 502 bad gateway issue?
11:41:53 <Luke>  http://lpaste.net/115680
11:41:59 <Luke> I'm not sure what I'm doing wrong
11:42:11 <monochrom> plus if you admire those who use segfaults just for exiting a program, I am inclined to play along and suggest "unplug the computer"
11:42:11 <Luke> going to the page in the browser works fine
11:43:06 <monochrom> how to exit a program depends on why you're exiting the program and other things about the overall structure of the program.
11:43:07 <flyingfisch> monochrom: I don't admire them. I just saw it and thought that was the way you did it.
11:43:36 <geekosaur> Luke: in general, if something orks in the browser and produces odd errors elsewhere, that means there is a proxy involved and you need to tell something about the proxy (and make sure it supports proxies)
11:43:37 <monochrom> you can't seriously mean literally the way I do it. you don't even know me.
11:44:09 <flyingfisch> monochrom: idiomatic expression.
11:44:12 <Luke> geekosaur: hmm yeah - do I need to do something more to support that?
11:45:16 <flyingfisch> anyway, I think I came up with another way. Check if the --help flag is in the args, if so, print help message and return (), else run the program run function
11:45:31 <flyingfisch> monochrom: would that be a good way to do it? ^
11:45:33 <monochrom> one example is my http://lpaste.net/52480 . it is a small game. it is a loop, expressed as recursion. therefore, to exit the program, simply exit the loop; to exit the loop, simply don't recurse.
11:45:47 <monochrom> yes.
11:46:01 <flyingfisch> ok
11:46:07 <flyingfisch> i'll do it that way then
11:46:22 * hackagebot apiary-websockets 1.2.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-1.2.0 (HirotomoMoriwaki)
11:46:24 * hackagebot apiary-cookie 1.2.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.2.0 (HirotomoMoriwaki)
11:46:26 * hackagebot apiary-session 1.2.0 - session support for apiary web framework.  http://hackage.haskell.org/package/apiary-session-1.2.0 (HirotomoMoriwaki)
11:46:28 * hackagebot apiary-clientsession 1.2.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-1.2.0 (HirotomoMoriwaki)
11:46:30 * hackagebot apiary-authenticate 1.2.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.2.0 (HirotomoMoriwaki)
11:47:06 <geekosaur> hm. I don't knwo if http-streams supports proxies; if it does, it robably uses the http_proxy environment variable. (Browsers can also use that but more often use proxy auto-confug, which requires Javascript)
11:50:39 <samba1> After seeing someone ask about clock arithmetic on the beginners mailing list, a colleague suggested I try doing a clock monoid as I'm learning Haskell
11:50:42 <samba1> http://lpaste.net/115659
11:50:44 <samba1> There are comments and questions inline - I'd be interested in any answers or other feedback from experts.
11:51:32 * hackagebot apiary-eventsource 1.2.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-1.2.0 (HirotomoMoriwaki)
11:51:34 * hackagebot apiary-purescript 1.2.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.2.0 (HirotomoMoriwaki)
11:51:36 * hackagebot apiary-mongoDB 1.2.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.2.0 (HirotomoMoriwaki)
11:51:38 * hackagebot apiary-memcached 1.2.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.2.0 (HirotomoMoriwaki)
11:51:40 * hackagebot apiary-helics 1.2.0 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.2.0 (HirotomoMoriwaki)
11:51:55 <mmachenry> What is the simplest way to fix this issue? Both libraries are lower (but not upper) bounded on the Attoparsec version they need. http://lpaste.net/115681
11:52:08 <Procian> samba1: Looks pretty cool.
11:54:20 <samba1> it seems like a lot of ceremony, though
11:54:49 <mmachenry> I think perhaps if I uninstall conduit-extras (which uses attoparsec > 10) and reinstall it it will use the default version which is 12?
11:55:32 <Luke> geekosaur: figured it out. they check for hardcoded user agents
11:55:36 <Luke> geekosaur: just spoofing it works
11:56:42 * hackagebot verilog 0.0.9 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.9 (TomHawkins)
12:04:54 <lpaste> joyfulmantis pasted “No title” at http://lpaste.net/115683
12:04:59 <mmachenry> Is there a way to tell a package I'm cabal installing to use a particular version of a package it depends on? It's not using the default version but instead an older one.
12:05:39 <joyfulmantis> I am wondering why the second function does not work in the above paste
12:06:19 <stolaruk> Can anything be "passed in" to a pattern synonym? For example, is there any way to do something like "pattern x <- ..." where "x" is not referenced to the left of the "<-", but instead "passed in"?
12:07:11 <benzrf> stolaruk: wat
12:07:23 <benzrf> oic
12:07:59 <stolaruk> benzrf: for example let's say "x" is actually a function that I want to apply in a view pattern inside the pattern synonym
12:08:27 <stolaruk> benzrf: and this "x" is a "parameter" to the pattern synonym
12:08:39 <stolaruk> I'd like to be able to do somethnig like that
12:08:42 <stolaruk> if that makes sense...
12:08:54 <Iceland_jack> stolaruk: Good question!
12:09:06 <Iceland_jack> I proposed an extension to PatternSynonyms that does exactly that
12:09:14 <stolaruk> oh yeah?
12:09:22 <stolaruk> ok, so there is no way to do it now?
12:09:26 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/9671
12:09:35 <Iceland_jack> If I understand you then no
12:12:25 <mightybyte> Is there a function like System.IO.getLine that has proper support for backspace?
12:13:49 <sinelaw> mightybyte, I think you need something a la curses for that?
12:14:34 <mightybyte> I'm looking at the ncurses package right now, but nothing has jumped out at me yet.
12:14:53 <stolaruk> Iceland_jack: yeah I think what you are proposing is a bit like what I have in mind.
12:14:59 <stolaruk> mightybyte: You could try Haskelline
12:15:01 <mightybyte> It seems like this should be an already existing abstraction
12:15:02 <tdammers> readline something something?
12:15:13 <lpaste> joyfulmantis revised “No title”: “fmap crazyness” at http://lpaste.net/115683
12:15:14 <sinelaw> what tdammers said
12:15:14 <tdammers> haskeline, yeah, try that
12:15:27 <mightybyte> tdammers: readline sounded like the right thing, but I'm having trouble installing it due to the C dependencies.
12:15:37 <mightybyte> stolaruk: Ooh, Haskelline sounds promising.
12:15:40 <flyingfisch> can I hijack Ctrl-C in haskell?
12:16:31 <sinelaw> mightybyte, btw how are you? we met in NYC Haskell group a couple of times (I did the talk on cv-combinators)
12:17:08 <mightybyte> sinelaw: Keeping busy. :)
12:17:46 <sinelaw> mightybyte, sounds right. ;)
12:18:10 <stolaruk> Iceland_jack: I'd like to be able to write "pattern MyPattern f <- MyType (f -> 123)" where "f" is NOT a top-level definition but something specified when "MyPattern" is used.
12:18:14 <athan> Is there a Text function for checking if substrings exist? I know MissingH has one for lists, but I'm not sure about text :S
12:18:37 <johnw> I'm pretty sure there is a Text.isInfixOf
12:18:38 <stolaruk> flyingfisch: You can catch the exception thrown on Ctrl-C
12:18:56 <athan> johnw: You're my life saver :) thank you!
12:20:31 <flyingfisch> stolaruk: ok
12:20:55 <texasmynsted> iirc there is a line that I can add to the top of my source file to make the compiler -WALL etc.  Anybody have a link to this?  I think it is in { or something….  Anybody use a template of some kind for their haskell files?
12:21:02 <mightybyte> stolaruk: It looks like haskeline does the trick.  Thanks.
12:21:08 <stolaruk> sure
12:21:16 <johnw> texasmynsted: {-# OPTIONS_GHC -Wall -fno-warn-unused-binds -Werror #-}
12:21:35 <texasmynsted> :-)  That' it!  Thank you
12:22:51 <texasmynsted> anybody use any kind of template for haskell files, like to add that or other comments?
12:23:12 <mmachenry> Why wouldn't a package that requires attoparsec (>=0.10) link against 0.12.1.2 (the default available version on my system) even though I also have 0.10.4.0 installed. Is there a way to force this?
12:25:58 <luite> mmachenry: use --upgrade-dependencies
12:26:24 <S11001001> mmachenry: maybe something else deps attoparsec < 0.12.1.2?
12:26:45 <monochrom> no, use --constraint="attoparsec installed"
12:27:04 <monochrom> normally cabal annoyingly brings in new versions
12:27:17 <luite> oh i was apparently reading mmachenry's request upside down
12:27:20 <monochrom> the main source of all future problems
12:27:44 <monochrom> file:///home/trebla/public_html/haskell/cabal-cabal.xhtml#lockdown
12:27:47 <monochrom> err
12:28:01 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
12:28:59 <texasmynsted> http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/
12:29:51 <mmachenry> luite: S11001001: The program I'm writing depends only on aeson, conduit, conduit-extras. It's a two-line test.
12:30:24 <mmachenry> Other things on my system do depend on attoparsec-10 (most notably haskell platform) so I can't seem to really uninstall it.
12:32:00 <luite> mmachenry: oh my suggestion was not what you asked for anyway, it makes cabal prefer the latest version for everything, rather than installed
12:32:25 <flyingfisch> > ["test"] :: IO [String]
12:32:27 <lambdabot>  Couldn't match expected type ‘GHC.Types.IO [GHC.Base.String]’
12:32:27 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
12:32:30 <flyingfisch> hmm
12:32:46 <flyingfisch> how can I convert [String] to IO [String]?
12:32:53 <flyingfisch> liftIO won't do it
12:32:54 <Iceland_jack> > return ["test"] :: IO [String]
12:32:55 <lambdabot>  <IO [[Char]]>
12:33:01 <flyingfisch> ohohoh
12:33:09 <flyingfisch> i forgot about that
12:33:11 <flyingfisch> thank you
12:33:11 <Iceland_jack> :t return :: a -> IO a
12:33:12 <lambdabot> a -> IO a
12:33:16 <Iceland_jack> No problem
12:33:51 <mmachenry> monochrom: Trying your idea but getting some "warning likely breaking " errors.
12:34:34 <luite> mmachenry: has your aeson lib been compiled against a different attoparsec?
12:35:18 <mmachenry> The aeson lib is compiled agains the one that I want.
12:35:31 <mmachenry> When I later install conduit-extra it compiles against the older one.
12:35:43 <Guest2710> Anal sex http://www.youtube.com/watch?v=Odsgr2ekg8U
12:39:29 <athan> Hey guys, I've got a weird issue
12:39:51 <athan> I'm trying to pull a variable from a monadic computation, but the variable keeps getting coerced to `()`
12:39:57 <mmachenry> monochrom: Sadly it did not work. It kept uninstalling my package with force reinstalls.
12:40:09 <athan> is there a way to side-step this? Maybe with a GHC extension?
12:40:26 <flyingfisch> is the haskell logo a fancy >>=?
12:40:36 <MP2E> it's a lambda combined with bind, yes
12:40:47 <flyingfisch> is that what >>= is?
12:41:03 <athan> > (return "yes) >>= print
12:41:04 <lambdabot>  <hint>:1:24:
12:41:05 <lambdabot>      lexical error in string/character literal at end of input
12:41:07 <athan> derp
12:41:12 <athan> > (return "yes") >>= print
12:41:13 <lambdabot>  <IO ()>
12:41:13 * hackagebot snaplet-persistent 0.4.1 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.4.1 (DougBeardsley)
12:41:21 <athan> :D?
12:41:26 <flyingfisch> um
12:41:34 <stolaruk> athan: bcus the type of print
12:41:35 <MP2E> >>= is bind
12:41:41 <flyingfisch> yes i know
12:41:45 <flyingfisch> oh wit
12:41:48 <flyingfisch> *wait
12:42:00 <flyingfisch> so the haskell logo is a fictional symbol
12:42:01 <stolaruk> :t print
12:42:01 <lambdabot> Show a => a -> IO ()
12:42:05 <kadoban> athan: lambdabot doesn't actually do IO, afaik. You have to give it something that it can print itself.
12:42:10 <wakalabis> Is it common to solve a problem by “follwing the types” and come up with a solution that works, and at first you don’t know exactly how?
12:42:15 <athan> stolaruk: d:
12:42:15 <flyingfisch> it is >>= and lambda combined right?
12:42:27 <stolaruk> flyingfisch: yes
12:42:32 <flyingfisch> ok
12:42:33 <athan> kabodan: Makes sense haha
12:42:41 <flyingfisch> oh that's what you said up there
12:42:43 <wakalabis> That happens to me all the time.
12:42:44 <flyingfisch> ok sorry
12:42:47 <bernalex> flyingfisch: https://secure.plaimi.net/images/typos.svg my company's logo lol
12:42:50 <moop> > putStrLn "I love big butts"
12:42:51 <lambdabot>  <IO ()>
12:42:57 <moop> aww
12:43:03 <flyingfisch> actually MP2E said it
12:43:05 <kadoban> > "and I cannot lie"
12:43:07 <lambdabot>  "and I cannot lie"
12:43:12 <moop> oooh
12:43:26 <kadoban> bernalex: That's pretty cool looking.
12:43:36 <xeno> tdammers: why would you want "100% C Performance"?
12:43:42 <xeno> ah shit
12:44:02 <xeno> that's what happens when I fail to scroll the channel view to the bottom... :/
12:44:07 <bernalex> kadoban: it's kind of neat because nobody can tell what it is, so a t-shirt with it is a nice conversation starter and excuse for people to tell people about the company ;-)
12:44:14 <athan> > do {foo <- return "foo"; return foo} :: Identity String
12:44:16 <lambdabot>  Identity {runIdentity = "foo"}
12:44:21 <flyingfisch> bernalex: so.... the haskell logo, and a ! and a degree sign and a !?
12:44:36 <athan> > do {foo <- (return "foo" >> return); return foo} :: Identity String
12:44:37 <lambdabot>  Couldn't match expected type ‘Data.Functor.Identity.Identity
12:44:37 <lambdabot>                                  GHC.Base.String’
12:44:37 <lambdabot>              with actual type ‘a0 -> m0 a0’
12:44:44 <tdammers> xeno: hah, but np
12:44:48 <obb> i want to build a curried function divides n = [true if n mod the other value == 0]. how do i do this
12:45:08 <tdammers> xeno: the question was whether Haskell would be a suitable language for a local database engine
12:45:25 <bernalex> flyingfisch: I don't even remember the reasoning for the · any longer. it was mainly just made to read "plaimi" in a clever way.
12:45:29 <mauke> obb: divides x y = x `mod` y == 0
12:45:33 <tdammers> and the main concern was how you might not get enough control over memory allocation and disk access and such
12:45:42 <tdammers> and that the performance might not be ideal because of this
12:45:52 <tdammers> anyway, that was the context
12:45:57 <athan> > (\n x -> n `mod` x) -- obb
12:45:59 <lambdabot>  <Integer -> Integer -> Integer>
12:46:09 <athan> > (\n x -> n `mod` x) 8 2 -- obb
12:46:10 <lambdabot>  0
12:46:14 <athan> derp
12:46:14 <xeno> tdammers: yeah, but C performance is a silly term, and C has also some non-performance properties...
12:46:20 <athan> > (\n x -> n `mod` x == 0) 8 2 -- obb
12:46:21 <lambdabot>  True
12:46:23 <athan> :D
12:46:29 <flyingfisch> bernalex: ah ok i see. pretty sweet looking :)
12:46:45 <athan> > do {foo <- (return "foo" >> return "baz"); return foo} :: Identity String
12:46:46 <lambdabot>  Identity {runIdentity = "baz"}
12:46:53 <athan> > do {foo <- (return "foo" >> return ()); return foo} :: Identity String
12:46:54 <lambdabot>  Couldn't match type ‘()’ with ‘[GHC.Types.Char]’
12:46:54 <lambdabot>  Expected type: GHC.Base.String
12:46:54 <lambdabot>    Actual type: ()
12:47:05 <athan> ^ This is the error I keep running into :(
12:47:11 <athan> particularly with Scotty ><
12:47:30 <obb> thanks athan
12:47:31 <athan> (where foo is some GET parameter or something)
12:47:36 <athan> obb: No prob :)
12:47:49 <Hijiri> > const 5 a
12:47:50 <lambdabot>  5
12:47:58 <obb> would it be possible without a lambda expression?
12:48:06 <athan> obb: I usually shortcut it as `(%=)`. Are you trying to enumerate factors?
12:48:18 <athan> hmm
12:48:19 <athan> no
12:48:24 <obb> nah checking if something is prime
12:48:26 <athan> erll
12:48:38 <athan> @pl (\x y -> x `mod` y == 0)
12:48:39 <lambdabot> flip flip 0 . ((==) .) . mod
12:48:44 <athan> obb &
12:48:48 <Hijiri> athan: the problem is that (return "foo" >> return ()) is type Identity ()
12:49:11 <Hijiri> so foo <- ... binds () to foo
12:49:13 <athan> Hijiri: I understand that :/ I'm just... glooming about it :P
12:49:17 <Hijiri> oh
12:49:20 <Hijiri> maybe I should read
12:49:30 <athan> I'm not sure how to fix the issue with scotty
12:49:45 <Hijiri> what are you trying to do?
12:49:46 <athan> for _every_ route handler, they instantiate it to `ActionM ()`
12:49:57 <athan> I'm just wondering if I really have to use transformers :/
12:50:12 <athan> Hijiri: Just trying to rescue a failing parameter lookup
12:50:20 <wyager> Hey all. I wrote a pretty fast, highly concurrent network key/value store in 175 lines of Haskell. Thought you might want to take a look :) https://github.com/wyager/KVStore
12:50:27 <athan> Hijiri: usually, rescues look like this: http://stackoverflow.com/questions/27233509/scotty-and-post-params/27234652#27234652
12:50:31 <athan> (check out the answer)
12:51:03 <tdammers> xeno: obviously. people still use it for a rough estimate of how performant a language implementation *can* be, and C, being close to the metal, is as good a reference as it gets
12:51:11 <athan> but, if you want to rescue it with an `ActionM ()` (ie: an actually useful response), you're dead in the waters
12:52:12 <Hijiri> what's the type of rescue?
12:53:06 <athan> Hijiri: `rescue :: ActionM a -> (Text -> ActionM a) -> ActionM a
12:53:21 <athan> I just wish it was ActionM a -> (Text -> ActionM b) -> ActionM b
12:53:27 <athan> ...or something
12:53:36 <sinelaw> wyager, looks interesting if I ever need something like that, i'll check
12:54:00 <sinelaw> wyager, but I know people are in favor of leveldb nowadays
12:54:04 <sinelaw> for actual performance
12:54:08 <Hijiri> I thought the point was to generate a backup value
12:54:11 <sinelaw> but it isn't concurrent
12:54:26 <wyager> sinelaw: Yeah, this is mostly just an example of how to write small, concurrent software in Haskell
12:54:38 <Hijiri> like you have ActionM a, but it might fail, so you create a recovery that gives you an a in case the first one fails
12:54:38 <wyager> one advantage is that it's so simple you can change behavior to whatever you want pretty easily
12:55:11 <athan> Hijiri: The only ActionM's that would fail are when you can't find a parameter, or if you call `raise` :/
12:55:16 <Hijiri> What happens if ActionM a doesn't fail? Where do you get the ActionM b from?
12:55:31 <athan> That's a good point
12:55:38 <athan> Hmm
12:55:56 <athan> Maybe they should just be polymorphic monads
12:55:59 <Hijiri> In the case of parameters, the function in the middle is a backup parameter
12:56:05 <Hijiri> or gives one, I mean
12:56:08 <athan> erm, you know what I mean
12:56:21 <athan> Hijiri: That's correct
12:56:36 <athan> but if the middle function is `Text -> ActionM ()`
12:56:40 <Hijiri> doesn't it make sense that it needs to be the same type as the one you were trying to get originally?
12:56:47 <athan> then the parameter you're trying to draw needs to have a type `()`
12:57:02 <Hijiri> you can't replace something that's not () with ()
12:57:37 * athan sets fire to project
12:57:58 <Hijiri> Your Identity example earlier, you could do do {foo <- return "foo"; return (); return foo}
12:59:01 <Hijiri> not sure how that directly maps to the ActionM issue, I'm still not sure what you're trying to do by having a different type parameter
12:59:36 <athan> No, you don't quite understand, I have no option for ActionM's inner type
12:59:44 <athan> It will always be `ActionM ()`
13:00:21 <Hijiri> why not?
13:00:43 <athan> Because Scotty demands it
13:00:46 <Hijiri> couldn't you just have blah >> return <something of type a
13:00:48 <FofG> How do I add multiple ghc-options? just -Wall, -XDeriveGeneric separated by comas?
13:00:48 <athan> they DEMAND it!
13:00:51 <FofG> commas*
13:01:06 <Hijiri> It's not demanded in the parameter for rescue
13:01:32 <athan> ...right, but if I use something from Scotty as the parameter, then it does
13:01:53 <Hijiri> could you be more specific?
13:02:26 <linman32> hi, i am confused about a continuation passing style example
13:02:27 <linman32> https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
13:02:30 <Hijiri> or at least give types for the things you are putting in rescue
13:02:46 <linman32> how does this function work? pythagoras_cps
13:02:48 <athan> FofG: I think there's a cabal pragma :)
13:02:56 <athan> ghc-options:
13:03:05 <FofG> athan: yeah figured it out
13:03:11 <FofG> just separate lines it seems...
13:03:12 <athan> Hijiri: I do, they're declared
13:03:20 * athan shrugs
13:03:26 <Hijiri> I mean give me the types
13:04:19 <athan> Hijiri: So, any response from scotty has a type ActionM ()
13:04:40 <athan> pulling a parameter has a type ActionM Text
13:04:47 <athan> they don't unify
13:04:48 <Hijiri> okay
13:04:50 <Hijiri> so do this
13:04:59 <Hijiri> actionFromScotty >> return "backup text"
13:05:11 <FofG> where does Generic come from? as in deriving (Generic)
13:05:34 <FofG> besides for -XDeriveGeneric, what might I need to import if anything?
13:05:37 <Hijiri> @let aaa = Just ()
13:05:39 <lambdabot>  Defined.
13:05:41 <Hijiri> :t aaa
13:05:42 <lambdabot> Maybe ()
13:05:45 <Hijiri> :t aaa >> return 5
13:05:46 <lambdabot> Num b => Maybe b
13:05:53 <athan> Hijiri: You're a magician :)
13:06:01 <Hijiri> you could have done this in a do block too
13:06:03 <athan> Thank you
13:06:12 <Hijiri> do {someScottyThing; return "backup"}
13:07:24 <linman32> here is the question condensed further: http://lpaste.net/115687
13:08:58 <Hijiri> athan, have you learned the Monad typeclass yet?
13:09:18 <athan> Hijiri: Yes, somewhat. Now I realize how I can work with multiple internal types freely :)
13:09:28 <linman32> in the link, it looks like an expression returns a function, but is passed in as an integer
13:11:29 <mmachenry> Sanity check: If conduit-extra-1.1.4.2 depends on attoparsec (>= 0.10) and aeson-0.8.0.2 depends on attoparsec (>=0.11.3.4), it should be possible to use them together, right? There's not some reason conduit-extra won't go up about the major version 10 for interface reasons?
13:12:20 <Hijiri> maybe it just works with 0.10.* 0.11.*?
13:12:26 <Hijiri> just both works with*
13:12:34 <Hijiri> works with both
13:13:00 <bennofs> mmachenry: except if conduit-extra has an upper bound on attoparsec < 0.11
13:13:27 <mmachenry> bennofs: They don't but I have sandboxed this and they will not link against the same attoparsec
13:13:37 <Hijiri> sorry, misread your question a bi
13:13:39 <mmachenry> Perhaps I don't understand cabal enough.
13:13:40 <Hijiri> t
13:14:04 <kadoban> mmachenry: Just based on that, sounds possible sure.
13:14:25 <mmachenry> kadoban: Sounds possible that they would bot be able to be built together?
13:14:37 <kadoban> Yes
13:14:50 <kadoban> But I'm not cabal, it can give a more definitive answer...what happens when you try?
13:15:03 <mmachenry> Damn. Is there a way to tell from the libraries?
13:15:20 <mmachenry> Well… it's a lengthy answer…
13:16:17 <mmachenry> I have done a sandbox init and installed the two newest versions of cabal-extra and aeson with specific version qualifiers.
13:17:17 <athan> How do I get the literal request URL from a WAI application?
13:23:42 <lukenels> @help
13:23:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:23:48 <lukenels> @pf
13:23:48 <lambdabot> Maybe you meant: pl bf
13:23:52 <lukenels> @pl
13:23:52 <lambdabot> (line 1, column 1):
13:23:52 <lambdabot> unexpected end of input
13:23:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:24:00 <lukenels> @pl foo x y z = (x + y) - z
13:24:00 <lambdabot> foo = ((-) .) . (+)
13:25:30 <FofG> im using a function which is f :: Text -> Whatever and f "hello" works. How's that possible if it expected Text?
13:25:50 <bitonic> FofG: you have OverloadedStrings enabled
13:26:07 <FofG> thaaaats it, right
13:26:08 <FofG> thanks
13:26:09 <FofG> !
13:26:45 <L8D> I need a good quote from someone notable about why state can lead to harmful things
13:27:13 <L8D> I'm already using the one from dijkstra about changes over time
13:27:18 <tdammers> L8D: "shared mutable state is the root of all evil"?
13:27:30 <L8D> tdammers: is there a name I can put on that?
13:28:07 <tdammers> L8D: probably, but forgot who said it
13:37:04 <lifter> Boo! Looks like I can't do this: "data MyType = MyType Int Int; pattern MyPattern (a, b) = MyType a b"
13:37:29 <L8D> tdammers: Martin Odersky, the creator of Scala
13:37:29 <lifter> GHC doesn't like the tuple, it seems.
13:37:54 <L8D> lifter: because you didn't declare it as a tuple
13:38:13 <L8D> lifter: you need to do "type MyType = (Int, Int)"
13:38:30 <L8D> lifter: or "pattern (MyType a b) = MyType a b"
13:38:50 <L8D> lifter: wait... what are you trying to match?
13:39:22 <shachaf> lifter wants to declare https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms that look like an existing pattern
13:39:38 <shachaf> Certainly not to declare a type synonym, or to define a function called pattern.
13:39:51 <lifter> Yes I'm using pattern synonyms
13:40:03 <L8D> are there any other pattern synonyms than the one between records and products?
13:40:11 <L8D> oh the language extensions
13:40:23 <lifter> My actual line of code, which works, is this:
13:40:24 <lifter> pattern SorryIndexed x p <- (Indexed { index = (showText -> x), entRes = Left p }, Nothing)
13:40:40 <lifter> but I want to do "pattern SorryIndexed (x, p)  ..."
13:40:53 <L8D> yeah that's possible
13:40:56 <L8D> or at least shouldn't be
13:41:09 <lifter> huh?
13:41:11 <shachaf> What are you even saying?
13:41:29 <L8D> shachaf: he wants: SorryIndexed (x, p) == SorryIndex x p
13:41:44 <L8D> whoops
13:41:47 <L8D> that's not possible*
13:41:52 <L8D> lifter: ^
13:41:54 <lifter> ok
13:41:54 <shachaf> L8D: I was addressing you.
13:42:42 <lifter> Well, I wish it was possible; tho I can see why it's not
13:43:09 <L8D> yeah it would break the semantics of the language
13:43:26 <L8D> because there's no way to know that 'x' will never be a tuple itself
13:43:50 <L8D> and other reasons...
13:43:52 <shachaf> I don't think it's possible but I'm not sure I'd take the advice of someone who wasn't aware of the existence of this extension when you asked your question...
13:44:08 <L8D> I said it *shouldn't* be possible
13:45:25 <shachaf> What you're saying isn't really making sense. What does x being a tuple have to do with it?
13:46:22 <shachaf> Oh well.
13:48:29 <lifter> Ok, so let's so I have "data MyType = MyType Int Int; pattern MyPattern a b = MyType a b "... This works... Now, is there some way to take both parameters "a" and "b" in the pattern synonym and apply them both to one view pattern, like this: "pattern MyPattern c@(\a b -> a + b) = MyType a b"? (This doesn't work...)
13:48:49 <mitu> I have a function doIt that forkIOs the "meat" of the procedure, and I'd like subsequent calls to doIt to have no effect of the forkIO'd thread is running, otherwise it should just forkIO it again. I have a few prototypes scrapped where I used Pipe.Concurrent but stranded because I cannot check wether a Buffer is empty or not.
13:49:09 <mitu> s/effect of the/effect if the/
13:50:21 <L8D> mitu: you can fill an MVar and check if it is empty or not
13:50:22 <mitu> Is my description clear?
13:50:52 <Iceland_jack> lifter: pattern MySum c <- ((\(MyType a b) -> a + b) -> c)
13:51:30 <obb> Hey, could somebody decrypt these interpreter complaints for me? i don't get what i am doing wrong :( http://pastebin.com/5Y2Fs8NC
13:51:38 <Iceland_jack> For clarity you can write:
13:51:38 <Iceland_jack>     typeSum :: MyType -> Int
13:51:39 <Iceland_jack>     typeSum (MyType a b) = a + b
13:51:39 <Iceland_jack>     pattern MySum c <- (typeSum -> c)
13:51:43 <lifter> Iceland_jack: woaaah!
13:51:58 <lifter> Sweet
13:52:01 <lifter> thanks
13:52:05 <L8D> mitu: as part of the operation of the forked thread it fills the MVar, so you can check if the MVar is empty with isEmptyMVar and decide to fork from there
13:52:22 <lifter> mitu: If you keep track of your thread IDs, you can get their status (running, finished), no?
13:52:23 <shachaf> "check if an MVar is empty" sounds like a race condition.
13:52:34 <Iceland_jack> lifter: For further information you can check out https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
13:52:53 <lifter> Iceland_jack: Yeah I've been looking at that, that's the best tutorial I've found so far
13:52:56 <shachaf> obb: You might have better luck if you give everything a type signature.
13:53:05 <Iceland_jack> ocharles also published https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html for Christmas :)
13:53:25 <lifter> Iceland_jack: As you can probably tell, I'm still learning the intuition for pattern synonyms. View patterns I got down. :)
13:53:27 <Iceland_jack> I appreciate the feedback lifter, tell me if you see any issues with it
13:53:40 <lifter> k
13:54:10 <lifter> Iceland_jack: The 24 days blog is where I first learned about this extension.
13:54:29 <lifter> But I found that blog post rather hard to understand.
13:54:39 <ocharles> Iceland_jack: are you icelandj?
13:54:49 <Iceland_jack> Yes
13:54:55 <ocharles> I love that post!
13:54:55 <mitu> L8D: Thanks for the pointers. What about using TVar considering shachafs comment?
13:55:05 <ocharles> i was "whaaaating" all the way through it
13:55:09 <flyingfisch> how do I remove an element from an assocList?
13:55:13 <flyingfisch> so like
13:55:26 <L8D> mitu: yes
13:55:33 <flyingfisch> > let test = [("test", "test1")]
13:55:34 <lambdabot>  not an expression: ‘let test = [("test", "test1")]’
13:55:41 <Iceland_jack> Thank you ocharles, I was thinking of offering to write a guest post on PatternSynonyms but when I read your first post I know what was coming :)
13:55:45 <lifter> flyingfisch: filter it, or turn it into a map and use delete
13:56:01 <ocharles> Iceland_jack: hehe. unfortunately i also stepped on matt pickering's toes too
13:56:03 <flyingfisch> there isn't a command to delete by key?
13:56:05 <ocharles> it's a popular extension :)
13:56:37 <mitu> lifter: Yes, I could but I'd rather not in this particular corner I'm hacking on
13:57:24 <lifter> flyingfisch: Unless it's just some one-off thing, I'd make it a Map
13:57:31 <lifter> then you have a lot of functions you can use
13:57:35 <flyingfisch> ok
13:58:25 <serses> what the hell was the command to fast compile and execute a haskell file?
13:58:39 <mitu> serses: runhaskell?
13:58:40 <lifter> runhaskell, runghc
13:59:01 <serses> ok thanks
14:01:05 <jle`> ocharles: can i write the guest post on TupleSections
14:01:22 <Iceland_jack> ocharles: Popularising PatternSynonyms is jolly good!
14:01:39 <jle`> i would like to spread awareness for TupleSections
14:01:49 <Iceland_jack> I once had a patch ready for ListSections, I wonder why I never submitted that
14:02:00 <jle`> i remember you mentioning that Iceland_jack
14:02:04 <jle`> i still lament
14:02:12 <n4x> "list sections"?
14:02:29 <Iceland_jack> so many things to do, maybe if^Wafter I finish my thesis
14:02:31 <n4x> [1,,2]?
14:02:34 <Iceland_jack> n4x: Exactly
14:05:08 <athan> Is there a haskell library for working with URL paths? Like a monad reader for the root path, and some OverloadedStrings stuff with potential GET request appending?
14:08:16 <dredozubov> is it possible to provide default arguments/parameters for `cabal repl` somehow?
14:08:17 <flyingfisch> @hoogle fromMaybe
14:08:17 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
14:12:39 <ionum> hi
14:12:43 <ionum> is
14:13:03 <ionum> is it possible that the function ord gives me a wrong  ascii value?
14:13:26 <ionum> http://lpaste.net/115692
14:14:15 <ionum> it tells me that my binary version of '%' begins with 1 which it should not
14:14:44 <jle`> every once in a while it does
14:14:52 <jle`> you just need to run it again after blowing on the pins
14:15:23 <jle`> > ord '%'
14:15:25 <lambdabot>  37
14:15:32 <jle`> looks right to me
14:15:38 <jle`> :)
14:15:56 <koala_man> ionum: all binary numbers greater than 0 start with 1 unless you pad them with 0s
14:16:23 <ionum> ow
14:17:59 <ionum> http://www.codingame.com/ide/fileservlet?id=373646875558
14:18:06 <ionum> so how is this possible
14:18:20 <ionum> and here my output
14:18:23 <ionum> 0 0 00 00 0 0 00 0 0 0
14:18:43 <jle`> have you considered that it is not `ord` that is giving your problems?
14:19:23 <ionum> well i see i need a zero there at the beginning 00 0
14:19:50 <jle`> > showIntAtBase 2 intToDigit 37 ""
14:19:51 <lambdabot>  "100101"
14:19:54 <ionum> but as koala_man said, if i do not pad, there should not be a zero
14:20:12 <jle`> that def looks like the correct binary form of 37
14:20:28 <jle`> :)
14:21:32 <ionum> the puzzle i do does not say i need to pad, and if i did, the previous tests would fail
14:23:18 <koala_man> ionum: what is it supposed to do?
14:23:55 <ionum> http://lpaste.net/115693
14:24:28 <shock_one> Why does it give me the defaulting constraints warning even though I explicitly specified the types? https://gist.github.com/shockone/0c2f7e825bb71e4274d2
14:24:40 <tasker> Does anyone know the function in Chart that allows you to force axis dimensions ?
14:26:11 <ionum> and one test is for '%' which should be 00 0 0 0 00 00 0 0 00 0 0 0 but i get 0 0 00 00 0 0 00 0 0 0
14:26:13 <athan> How do I make a polymorphic data value (like `data Foo = Foo a`) hold general constraints? I'd really like `data Foo = IsString a => Foo a`
14:26:15 <athan> (or something)
14:26:34 <obb> root :: Integral n => n -> n
14:26:35 <obb> root n = floor $ sqrt n
14:26:35 <obb>  why is the compiler complaining when i do something like this?
14:26:38 <koala_man> ionum: you have to pad. your code just happens to work for letters because letters all have ascii values over 64
14:26:46 <athan> obb: do this
14:26:58 <athan> `intSqrt = floor . sqrt . fromIntegral`
14:27:15 <ionum> so i have to pad to 7 bit
14:27:19 <koala_man> yes
14:27:28 <obb> thank you athan
14:27:34 <athan> :)
14:29:58 <ionum> it works
14:30:03 <ionum> thanks koala_man
14:30:09 <monochrom> athan: for a combination of reasons, you are better off with just "newtype Foo a = Foo a" and leave IsString to functions that actually need it
14:31:01 <ionum> http://lpaste.net/115694
14:31:32 <ionum> lpaste gives some good hints
14:32:00 <athan> monochrom: I think I'm starting to understand :P I keep thinking "how to I provide support for OverloadedStrings?!" .... by not worrying about it xD
14:36:57 <SvenskFi1k> Hey guys, I'm trying to use the hnn library to mess around with neural networks, but haskell keeps giving me this error when I try to run the sample code : http://lpaste.net/115695, any help appreciated
14:39:05 <Welkin> SvenskFi1k: look at the type of createNetwork
14:39:11 <Welkin> you'll find your answer there
14:39:54 <SvenskFi1k> I'll check it out, thanks
14:40:47 <sinelaw> Why does 'f' have an infinite type?
14:40:48 <sinelaw> f x = let bla = [x!!0, \z -> f [z]]  in x
14:41:08 <sinelaw> is 'f' in the recursion polymorphic?
14:41:41 <johnw> or its type may depend on its type
14:41:53 <johnw> like a function that returns a function that returns a function....
14:41:55 <shock_one> How would I make this function point free without monadic functions?
14:41:56 <shock_one> concatenatedContent x = lines . concat <$> mapM readFile x
14:42:15 <johnw> @pl \x -> lines . concat <$> mapM readFile x
14:42:16 <lambdabot> (lines . join <$>) . mapM readFile
14:42:26 <sinelaw> @pl f x = let bla = [x!!0, \z -> f [z]]  in x
14:42:26 <lambdabot> f = id
14:42:39 <sinelaw> O_o
14:43:04 <patsourakos> Hello sorry for this link http://i.imgur.com/trgo9YF.jpg
14:43:04 <johnw> well, you're not using bla
14:43:10 <johnw> so you've just written f x = x
14:43:24 <johnw> patsourakos: ?
14:43:32 <indiagreen> kick nem
14:43:36 <indiagreen> it's gore
14:43:39 --- mode: ChanServ set +o johnw
14:43:39 --- mode: johnw set +b *!~asdd@athedsl-4506465.home.otenet.gr
14:43:39 --- kick: patsourakos was kicked by johnw (spam)
14:43:39 --- mode: johnw set -o johnw
14:44:08 <shock_one> Thank you, johnw.
14:44:27 <sinelaw> johnw, I can see that
14:44:30 <sinelaw> but type checking is strict
14:44:34 <Welkin> there seems to be a lot of spammers here lately
14:44:54 <ij> One of the largest channels around.
14:44:59 <johnw> Welkin:  they come and they go
14:45:22 <alanoth`> I'm just a beginner man. Sorry if I made you hate the channel.
14:45:29 <sinelaw> johnw, looks like f is monomorphically restricted in the recursion
14:45:32 <johnw>  sometimes we get people who keep randomizing their login, and flood the channel each time with rude messages; those of the worst ones that I have seen so far
14:45:53 <sinelaw> oh wait
14:45:55 <mmachenry> alanoth: This channel is very friendly to beginners.
14:46:25 <shock_one> Is there a utility like this @pl thing?
14:46:29 <alanoth`> mmachenry: Yeah, I've been here occasionally. It's a fun place to be
14:46:29 <sinelaw> nvm
14:46:31 <dnkndnts> i don't think they're complaining about beginners, they're complaining about that imgur link
14:46:41 <Welkin> yes
14:46:42 <dnkndnts> which is pretty damn gross
14:46:45 <Welkin> I enjoy helping beginners
14:46:57 <Welkin> I came here as a beginner
14:47:02 <alanoth`> Oh, i got disconnected. Sorry but I couldn't get the whole conversation
14:47:07 <mmachenry> dnkndnts: Ah, I wasn't paying attention. Didn't see it.
14:47:58 <pertl> #join sqlserver
14:48:04 <pertl> oops sorry
14:48:25 <butyoudonot> jfischoff: why so old optparse-applicative? https://github.com/jfischoff/twitch/blob/master/twitch.cabal#L66
14:48:44 <butyoudonot> and why there are so much upper bounds also?
14:49:15 <monochrom> probably jfischoff is caught between a rock, a hard place, and a busy life :)
14:50:01 <monochrom> the rock is "if no or loose upper bound, there is risk of real incompatibility"
14:50:21 <monochrom> the hard place is "if tight upper bound, there is risk of real compatibility"
14:50:39 <monochrom> and the busy life is "haven't got around to update things"
14:50:49 <butyoudonot> fear of Real Compatibility
14:50:52 <alanoth> I'm looking to participate in the Google Summer of Code 2015, anyone have some advice for me?
14:51:08 <monochrom> one cannot please everyone
14:51:56 <alanoth> As of now I'm reading the haskell wikibook. Can someone recommend any project for a beginner?
14:52:13 <hiptobecubic> alanoth, I didn't know it was a thing until it was too late, but apparently the best you can do is to pretend like it's already here and start writing code. They *strongly* prefer projects that have a chance of producing something and people who have already produced things are the safest choice.
14:52:31 <monochrom> optparse-applicative did go through significant API changes and took me a while to adapt. I wouldn't impose it on other people.
14:52:45 <johnw>  I am really unhappy with a lot of the changes that that library made
14:52:56 <johnw>  I have decided in a lot of my projects to just fix at an older version that did what I needed
14:53:35 <alanoth> hiptobecubic: Yeah, I thought that would be the case. So I already began work on a project I was interested in. I'm cloning mathematica's dynamic plotting abilities. Take a look at github.com/sumitsahrawat/plot-lab.git
14:53:55 <alanoth> hiptobecubic: Thanks for the advice anyway :)
14:54:39 <sm> +1 hiptobecubic, alanoth
14:54:58 <jfischoff> butyoudonot: no idea, I didn’t speed any time tweaking the deps
14:55:02 <alanoth> hiptobecubic: I'm looking for large projects that are accessible to beginners like me. Most large projects require good knowledge of monads. I'm hoping to mend that, but till then, I would like to have something to do.
14:55:13 <jfischoff> butyoudonot: feel free to make a pr ;)
14:56:12 <butyoudonot> jfischoff: got you
14:56:21 * hackagebot conduit-iconv 0.1.1.0 - Conduit for character encoding conversion.  http://hackage.haskell.org/package/conduit-iconv-0.1.1.0 (slomo)
14:59:49 <alanoth`> hiptobecubic: Did you take a look?
14:59:49 <malllle> alanoth: maybe http://comments.gmane.org/gmane.comp.lang.haskell.cafe/113365 helps a bit
15:00:30 <hiptobecubic> alanoth`, cloning...
15:00:35 <alanoth`> malllle: Thanks
15:00:53 <alanoth`> hiptobecubic: Thanks man, I was looking for some external opinion
15:02:51 <sm> alanoth, in case you're interested hledger, darcsden and the hackage server are practical apps used by a bunch of people, with simple, medium and sophisticated code respectively
15:03:11 <hiptobecubic> a bunch of people use darcsden?
15:03:20 <sm> at hub.darcs.net
15:04:12 <sm> I don't know who they are, but we're up to 700+ users
15:05:09 <sm> wait.. 600+
15:05:51 <dfrey> Is it considered good practice to prefix type constructors with their type?  For example I am defining a type LogLevel which has constructors Debug, MinorEvent, MinorError, etc, but now I am wondering whether SeverityDebug, SeverityMinorEvent, SeverityMinorError, etc would be better because it doesn't clutter up the global namespace so much
15:07:25 <dfrey> I just realized I mixed "Severity" and "LogLevel" in my question.  I am considering calling the type Severity instead of LogLevel, but that isn't really the root of my question.
15:08:23 <malllle> alanoth``: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/113591 another thread
15:19:01 <fread2282> desugaring question: http://lpaste.net/115632
15:25:36 <monochrom> fread2282: I'm going to ask the compiler for real
15:25:44 <yunxing> hi, noob question: I thought the expression `filter f.map g` won't work since (.) has the highest priority, the expression would be interpreted as `filter (f.map) g`. However in reality it works as `(filter f).(map g)`.. Anyone knows why?
15:26:03 <indiagreen> function application has higher priority than any operators
15:26:14 <dibblego> yunxing: space has even higher priority
15:27:46 <yunxing> dibblego: indiagreen: now i understand, thanks!
15:36:00 <athan> Why can't I make a class declaration that has a method that doesn't mention any class variables?
15:36:16 <athan> I'd really like for my users to declare an instance by just populating it with a flat value
15:36:22 <athan> ...something phantom-ey
15:38:50 <haasn> dfrey: One common-ish alternative is to put types into their own modules, so you can import them qualified and use Severity.MinorError etc.
15:39:00 <haasn> (Or S.MinorError if you hate typing)
15:39:19 <haasn> Disclaimer: I don't actually know how common it is
15:39:32 <haasn> Personally, I just try to find constructors that don't overlap in the first place
15:39:41 <lpaste> monochrom annotated “big core size” with “An experiment and its result” at http://lpaste.net/115632#a115699
15:40:09 <fread2282> monochrom: huh?
15:40:13 <monochrom> fread2282: http://lpaste.net/115632#a115699 shows a hilarious result. I think you have nothing to worry about :)
15:48:04 <dfrey> haasn: Interesting idea.  I might give that a try.
15:51:57 <ReinH> bernalex: so fun story.
15:52:19 <ReinH> bernalex: We interviewed Conal before the holiday and are editing now.
15:52:38 <ReinH> mrb_bk: hi! checking
15:56:55 <obb> divides' [] dividend = True
15:56:55 <obb> divides' (x:xs) dividend = x `divides` dividend && divides' xs dividend
15:56:55 <obb>  will the compiler be intelligent enough to stop calculations after the first 'False'?
15:57:08 <Iceland_jack> yes
15:57:11 <obb> nice :D
15:57:41 <Iceland_jack> It's not a matter of intelligence even in the sense that it's not something that needs to be checked for, it's built into the evaluation model
15:57:44 <shachaf> It's not really a matter of the compiler being intelligent.
15:58:14 <obb> how is it incorporated in the evaluation model?
15:58:25 <carter> its how && is defined
15:58:28 <Iceland_jack> obb: should be the same as 'all (`divides` dividend)'
15:58:33 <Iceland_jack> @src all
15:58:33 <lambdabot> all p = and . map p
15:58:39 <carter> @source (&&)
15:58:39 <lambdabot> Unknown command, try @list
15:58:43 <carter> @src (&&)
15:58:43 <lambdabot> True  && x = x
15:58:44 <lambdabot> False && _ = False
15:58:50 <shachaf> By the way, you can write it as "all (`divides` dividend) l"
15:59:33 <obb> and this will be equally fast?
15:59:56 <obb> nice work with the lambdabot btw
16:00:14 <ski> well be equally fast as what ?
16:00:20 <obb> using &&
16:00:23 <L8D> obb: "equally fast" ?
16:00:38 <shachaf> sigh
16:00:42 <gcganley> what is the process of getting a package onto stackage? i want chrisdone 's Lucid library for fpcomplete
16:00:42 <ski> your function already uses `(&&)'
16:00:55 <ski> .. and `all' uses `and' which uses `True' and `(&&)' ..
16:01:18 <L8D> @src and
16:01:18 <lambdabot> and  = foldr (&&) True
16:01:31 <ski> obb : if you're worrying, why not try (measure, possibly profile) and see ?
16:01:59 <ski> or you could try something similar to what monochrom did at <http://lpaste.net/115632>
16:02:38 <obb> sorry didn't mean to bug you
16:03:49 <ReinH> > foldr (&&) True (repeat False) -- (&&) is non-strict in its second argument, so foldr can evaluate False && (foldr (&&) True (repeat False) without evaluating the right hand side of the (&&)
16:03:51 <lambdabot>  False
16:03:59 <ReinH> > False && undefined
16:04:00 <lambdabot>  False
16:04:09 <creichert> gcganley: https://github.com/fpco/stackage, read Get You Package Included
16:04:17 <creichert> Also see here: https://github.com/fpco/stackage/wiki/Maintainers-Agreement
16:04:33 <ReinH> more precisely, (&&) is non-strict when the first argument is False, strict when the first argument is True
16:04:42 <L8D> isn't there a rule for [x] ++ xs ?
16:04:43 <ReinH> > True && undefined
16:04:44 <lambdabot>  *Exception: Prelude.undefined
16:04:54 <L8D> > False && undefined
16:04:54 <shachaf> If you're going to say "more precisely", you should say something more precise.
16:04:55 <lambdabot>  False
16:05:06 <ReinH> shachaf: again with this?
16:05:16 <ReinH> shachaf: tell me why it was not precise and maybe I'll listen to you
16:05:20 <shachaf> Like "(&&) True is strict, and (&&) False isn't", or talk about "non-strict in its second argument"
16:05:22 <haasn> L8D: I don't think you even need a rule for that.
16:05:29 * ReinH sighs
16:05:41 <ReinH> Fair enough.
16:05:43 <shachaf> ReinH: You could let me finish typing my second line.
16:06:05 * shachaf sighs too
16:06:19 <L8D> > seq undefined "foo"
16:06:20 <lambdabot>  "*Exception: Prelude.undefined
16:06:30 <L8D> > seq "not undefined" "foo"
16:06:32 <lambdabot>  "foo"
16:06:51 <ReinH> L8D: [x] ++ xs = x : xs follows from the definition of (++)
16:07:10 <L8D> @src (++)
16:07:10 <lambdabot> []     ++ ys = ys
16:07:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:07:10 <lambdabot> -- OR
16:07:10 <lambdabot> xs ++ ys = foldr (:) ys xs
16:07:10 <haasn> L8D: GHC will automatically do its best to inline small enough functions, and reduce stuff like (case C x of C y -> g) into “g”
16:07:25 <shachaf> But that's kind of a strange thing to say, because "(&&) True" is id, and "(&&) False" is const False.
16:07:34 <shachaf> Which isn't a very interesting way for a function to be non-strict.
16:07:37 <L8D> haasn: I assumed, but thanks
16:07:46 <ReinH> [x] ++ xs = x : ([] ++ ys) { (++) 2 }
16:08:05 <ReinH> x : ([] ++ xs) = x : xs { (++) 1 }
16:08:09 <shachaf> Well, maybe it's moderately interesting.
16:08:20 <ReinH> s/ys/xs above, sorry
16:08:49 <haasn> “non-strict” basically just means “not strict”, right? Is there a strict opposite of “strict”, as in “never strict”?
16:08:59 <haasn> Well, as in “ignores its parameter”
16:09:05 <ski> obb : no need to apologize, i don't think you bugged anyone
16:09:06 <shachaf> "constant"?
16:09:20 <ReinH> haasn: a function is strict of f _|_ = _|_, and non-strict otherwise
16:09:21 <shachaf> "not strict" already means "never strict"
16:09:41 <haasn> shachaf: Yes, “constant” is what I was looking for
16:09:43 <shachaf> But a function that ignores its argument is called a constant function.
16:09:45 <shachaf> Yes.
16:10:07 <shachaf> If it doesn't ignore its parameter, it's called -- relevant?
16:10:16 <shachaf> Maybe.
16:10:19 <ReinH> heh
16:10:23 <ski> is `id :: Void -> Void' constant ?
16:10:50 <shachaf> Relevant as in relevant types.
16:11:10 <ski> (.. and relevant/relevance logic)
16:11:14 <shachaf> Yes.
16:11:16 <haasn> Hmm, actually a function is always either strict or constant.
16:11:18 <shachaf> And relevant transformations.
16:11:25 <shachaf> haasn: ?
16:11:42 <haasn> shachaf: If f _|_ = _|_, the function is strict; if f _|_ = x; the function is constant
16:11:47 <shachaf> (1:) is neither strict nor constant
16:11:59 <shachaf> Maybe you're thinking of a strict language.
16:12:15 <wayne> does anyone know of a programming language with first-class types that's not epigram?
16:12:29 <ski> what does "first-class types" mean ?
16:12:34 <HeladoDeBrownie> I think Agda and Idris count
16:12:40 <haasn> Oh, you're right - there's a third case, for stuff like  f _|_ = C _|_
16:12:42 <wayne> you can assign types to variables without mangling
16:12:57 * ski doesn't understand
16:13:23 <shachaf> haasn: Typically when people use "fix" they don't pass it a constant function. :-)
16:13:25 <wayne> for example, i might want to say something like intType := int
16:13:31 <wayne> and intValue := 4
16:13:31 <acowley> Proxy::Proxy t is the height of elegance
16:13:55 <wayne> where the type of intValue is int, while the type of intType is "type" or something
16:13:57 <haasn> There's also a fourth case, for f _|_ = \x -> ....
16:14:14 <wayne> HeladoDeBrownie: thanks, i'll check out both of those
16:14:28 <shachaf> haasn: That's a fourth case?
16:14:40 <shachaf> I guess it depends on what you mean by C.
16:16:32 <haasn> In the same sense, I should have written “f _|_ = C ...”. Meaning that “f _|_ = C (something else that could have been on the right hand side of f _|_ =)”. But at that point we've basically already defined functions themselves
16:16:42 <ski> wayne : so Agda,Idris,Coq,Twelf,Cayenne,... maybe ATS as well ?
16:16:47 <haasn> Where C is a constructor
16:16:49 <haasn> In the proper sense
16:17:41 <wayne> ski: yeah i think "dependent types" describes what i'm looking for better
16:17:42 <wayne> thanks
16:18:23 <haasn> I think F* counts?
16:18:42 <ski> wayne : i think NuPRL,AUTOMATH, and possibly Isabelle as well ?
16:18:54 <haasn> And if I recall correctly, Ur
16:19:06 <ski> possibly
16:19:11 <wayne> thanks for the lists
16:19:13 <ski> ("F*" ?)
16:19:18 <haasn> Microsoft F*
16:19:39 <haasn> ski: http://research.microsoft.com/en-us/projects/fstar/
16:19:51 <ski> wayne : and possibly HOL ?
16:20:24 <Iceland_jack> F* and LiquidHaskell
16:21:03 <wayne> it seems that many of these are used for proofing
16:21:08 <wayne> i guess that makes sense.
16:21:52 <haasn> That seems to be one of the driving forces behind wanting dependent types
16:21:59 <ski> yes
16:22:10 <ski> another is to get more powerful checking for programs
16:22:15 <ski> (and these intersect)
16:23:05 <haasn> Type systems in the general sense exist to ensure program correctness. Every type system can only prove so much, though; dependent types just take this further
16:23:39 <ski> (e.g., if you want to express that you have a struct with one integer, and two arrays (or pointers to arrays) (of something) having that integer as length, you need some (subset) of dependent types)
16:23:53 <haasn> One thing that irks me about that statement though is the fact that Haskell uses types for ad-hoc overloading of functions
16:24:21 <ski> (see ATS for some work on bringing ideas from dependent types into systems programming languages)
16:24:23 <haasn> Which doesn't really have anything to do with program correctness. But I think that's just a convenience thing
16:34:38 --- mode: ChanServ set +o glguy_
16:34:56 --- mode: glguy_ set -o glguy
16:35:23 --- mode: ChanServ set +o glguy_
16:39:49 --- mode: glguy_ set -o glguy_
17:02:32 <marchdown> What is the right way to pass a function a list of arguments when it has been defined to take a bunch of separate arguments, not a list?
17:03:13 <shachaf> case l of [x,y,z] -> f x y z; _ -> ...
17:04:20 <marchdown> Thanks.
17:19:13 <Hijiri> what is the idiomatic way to have a timer thread that does something at the top of every hour?
17:20:05 <Iceland_jack> Hijiri: Just fork a thread (forkIO) that sleeps for an hour (threadDelay) before performing the action
17:20:09 <ReinH> Hijiri: Um. I don't like to depend on processes for that, Haskell or otherwise, but presumably just an IO thread with threadDelay
17:20:26 <ReinH> (you would want to threadDelay after the action so you can sleep the appropriate amount taking the action duration into account)
17:20:35 <Iceland_jack> If you don't want the action to block you simply fork another thread or use 'async'
17:20:42 <ReinH> or that
17:21:04 <Hijiri> alright
17:21:19 <Hijiri> how accurate is threadDelay for the period of an hour?
17:21:55 <Hijiri> I guess that's handled by the RTS
17:22:34 <Iceland_jack> Hijiri: It doesn't really make any guarantees but for a lot of tasks it's good enough. If you need more precision you can sleep for less than an hour and synchronize against some fixed time
17:22:54 <Hijiri> It's fine if it's within a minute, I think
17:23:03 <ReinH> the accuracy of threadDelay isn't the problem
17:23:15 <ReinH> The problem is recovering from process failure
17:23:16 <Hijiri> blocking due to processing in other threads?
17:23:18 <Hijiri> oh
17:23:25 <ReinH> cron exists for a reason
17:23:54 <ReinH> I would never make "a long-running thread in my haskell process" my first choice for "do something every hour"
17:24:03 <Hijiri> would it make sense to make a separate executable and write a cron job for it?
17:24:10 <ReinH> Absolutely.
17:24:23 <Iceland_jack> Or you can use libraries for that
17:24:24 <Hijiri> and now I have to switch from local acid-state to remote
17:24:26 <Iceland_jack> @hackage cron
17:24:26 <lambdabot> http://hackage.haskell.org/package/cron
17:24:27 <Iceland_jack> https://hackage.haskell.org/package/cron-0.2.2/docs/System-Cron.html
17:24:41 <Iceland_jack> It really depends on that application
17:25:07 <ReinH> My same caveat applies to the cron package, and to any other form of in-process cron emulation ;)
17:25:20 <ReinH> there really is a good reason for cron to exist
17:25:20 <Iceland_jack> Yes absolutely
17:25:45 <Iceland_jack> But cron needs an executable, and sometimes that's a big jump for small gains
17:26:02 <ReinH> Hijiri: does your whatever it is have an API or some other means of inter-process communication?
17:26:14 <ReinH> cron can just send it a signal somehow
17:26:31 <Hijiri> It's a web app, so definitely
17:26:47 <ReinH> create an internal API endpoint for cron signaling ;)
17:27:00 <ReinH> then your cron task is implemented with curl ;)
17:27:04 <Hijiri> ok, I'll try that
17:27:14 <ReinH> maybe not the best option, but probably more reliable than a cron thread
17:29:36 <ReinH> I would go the "switch from local acid-state to remote" anyway. But then again, I don't think acid-state is production-ready anyway.
17:30:02 <ReinH> Largely due to the scaling concerns exemplified here ;)
17:31:26 <Hijiri> I've been putting it off, but being able to query the db in ghci would be nice
17:32:37 <ReinH> Also I said "anyway" too many times. Awkward.
17:51:48 <obb> how can i get the index of an element in a list?
17:52:03 <indiagreen> :t findIndex
17:52:04 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
17:52:08 <indiagreen> :t elemIndex
17:52:09 <lambdabot> Eq a => a -> [a] -> Maybe Int
17:52:10 <obb> thx
18:25:07 <torpet_> How would I use a function "func A -> doesnt matter" with this kind of data structure
18:25:08 <torpet_> http://lpaste.net/4256403673707446272
18:25:24 <torpet_> type C and type D should read "newtype"
18:26:07 <HeladoDeBrownie> torpet_, I don't understand the question.
18:26:42 <torpet_> func A = ...
18:27:05 <torpet_> or func [(C, D)]
18:27:18 <torpet_> or do i have to move until I have a data type with a constructor?
18:28:38 <CyberZ> Noob Question: Is the SQL language different in MySql than on Oracle sql database?
18:29:08 <HeladoDeBrownie> torpet_, I'm still having trouble understanding your question; are you trying to apply some function of type A -> Whatever for some type Whatever?
18:29:37 <torpet_> I am trying to access A in a function
18:29:41 <marchelzo_> Can someone explain to me why this functions isn't working? I must be missing something really stupid. http://lpaste.net/963088275155714048
18:29:44 <torpet_> but I am not really sure how I should do it
18:30:01 <Iceland_jack> torpet_: I think I understand, you want to match on the constructor of A
18:30:18 <HeladoDeBrownie> torpet_, ah, so you want to know what's contained inside the A. Well then, your outermost pattern would match lists, since A is the same thing as a list of B
18:30:19 <Iceland_jack>     newtype A = MkA ...
18:30:19 <Iceland_jack>     f :: A -> ...
18:30:19 <Iceland_jack>     f (MkA a) = ...
18:30:22 <CyberZ> can someone answer my noob question please? :)
18:30:31 <HeladoDeBrownie> torpet_, f [] = ... ; f (x:xs) = ...
18:30:39 <torpet_> HeladoDeBrownie: OK thanks thats pretty useful
18:30:49 <marchelzo_> CyberZ: How does that relate to Haskell?
18:30:50 <geekosaur> CyberZ, consider asking it in an SQL channel instead of a Haskell channel?
18:31:08 <HeladoDeBrownie> torpet_, if you wanted to further matchin inside those lists, the next step is a pair, so, e.g., f ((c, d):xs) = ...
18:31:20 <CyberZ> Oh sorry my bad forgot this is haskell :P
18:31:31 <HeladoDeBrownie> torpet_, and to match the C and D types, you need to match on their constructors that you provided, so, e.g., f ((C c, D d):xs) = ...
18:32:13 <HeladoDeBrownie> torpet_, so then you'll have in scope c :: E -> F, d :: G -> H, and xs :: [B]
18:32:38 <HeladoDeBrownie> And since B is just a type synonym, you could instead have written xs :: [(C, D)]
18:33:00 <HeladoDeBrownie> torpet_, make sense?
18:33:24 <HeladoDeBrownie> Sometimes I'm bad at explaining things and if this is such a time please let me know :)
18:38:31 <Zemyla_> @pl \x y = 4 * x + 5 * y
18:38:32 <lambdabot> (line 1, column 6):
18:38:32 <lambdabot> unexpected "="
18:38:32 <lambdabot> expecting pattern or "->"
18:38:38 <Zemyla_> @pl \x y -> 4 * x + 5 * y
18:38:39 <lambdabot> (. (5 *)) . (+) . (4 *)
18:40:48 <torpet_> HeladoDeBrownie: Yeah, thanks a lot :)
18:42:04 <HeladoDeBrownie> Glad to help
18:57:20 <LordBrain> the cabal asks for a Category when i init, I usually leave blank, but I wonder if System makes sense if i am making a user land tool like ls to list files?
18:59:22 <LordBrain> Are these the same categories as listed in (Packages by category)[https://hackage.haskell.org/packages/] ?
18:59:42 <LordBrain> oops, inverted my markdown brackets, but you get the idea
19:01:13 <athan> Fudge... is there an easy work around for overlapping instances...? My class looks like `class IsText a t | a -> t where...` and I have an `instance IsText Text Text`... newtypes...?
19:01:32 * hackagebot congruence-relation 0.1.0.0 - Decidable congruence relations for Haskell: up to you whether this is a joke  http://hackage.haskell.org/package/congruence-relation-0.1.0.0 (JonSterling)
19:02:56 <roboguy_> athan: hmm what does IsText do?
19:04:33 <athan> roboguy_: I'm actually not sure yet. I've been trying to make a "global constant" in type classes...
19:05:02 <roboguy_> athan: what do you mean by global constant?
19:05:08 <athan> Side question - if I have functional dependency `a -> t`, then `a` needs to occour in every method's type signature, right?
19:07:00 <roboguy_> I don't think so
19:08:58 <roboguy_> it seems strange to me to have a multiparameter class called Is... usually those are one parameter
19:09:56 <Iceland_jack> roboguy_: Funny you should say that because there is a typeclass used in a paper that you're describing
19:10:37 <roboguy_> Iceland_jack: hmm, what do you mean?
19:10:49 <Iceland_jack> There was a paper that defined 'class Is a b where'
19:11:24 <roboguy_> oh, I'm not surprised. I mean "Is blank". Like IsText
19:11:33 * hackagebot hmeap 0.15 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.15 (RohanDrape)
19:11:44 <roboguy_> I assume that stands for either equality or isomorphism of some kind
19:11:47 <Iceland_jack> Ah I misunderstood
19:12:17 <Iceland_jack> No it didn't actually, it was some time since I read the paper but I recall that it stood for something somewhat more interesting
19:13:22 <Iceland_jack> Ah I found it http://semantic.org/stuff/Open-Witnesses.pdf
19:14:11 <Iceland_jack>     class Is rep a where
19:14:11 <Iceland_jack>       representative :: rep a
19:14:38 <Iceland_jack> Ah, it's representative type classes for things where same type implies same value
19:14:57 <roboguy_> like singletons?
19:15:08 <Iceland_jack> Yes, this is basically the relational version of singletons
19:15:45 <roboguy_> huh, that's interesting
19:15:59 <Iceland_jack> If you have a data type:
19:15:59 <Iceland_jack>     data CharOrInt a where
19:15:59 <Iceland_jack>       C :: CharOrInt Char
19:15:59 <Iceland_jack>       I :: CharOrInt Int
19:16:02 <Iceland_jack> then if you have an instance of:
19:16:06 <Iceland_jack>     instance Is CharOrInt Char
19:16:14 <Iceland_jack> that the representative value for that multi-typeclass has to be "C"
19:16:47 <Iceland_jack>     (representative :: Is CharOrInt Char) == C
19:16:47 <Iceland_jack>     (representative :: Is CharOrInt Int)  == I
19:17:31 <marchelzo_> Can you use composite functions in infix, like "x `not . elem` xs"?
19:17:42 <Welkin> try it
19:17:45 <Iceland_jack> marchelzo_: You'll have to use parentheses
19:17:45 <Welkin> I doubt so
19:17:45 <marchelzo_> I did
19:17:56 <Iceland_jack> oh no sorry (misread), that won't work
19:18:06 <Welkin> > 3 `not . elem` [2,3]
19:18:08 <lambdabot>  <hint>:1:8: parse error on input ‘.’
19:18:13 <marchelzo_> Is there a GHC extension or anything, though?
19:18:13 <indiagreen> nope, you can only use backticks on single identifiers
19:18:20 <Iceland_jack> marchelzo_: no
19:18:20 <indiagreen> not to my knowledge
19:18:29 <marchelzo_> cool, thanks
19:18:36 <Welkin> > not $ 3 `elem` [2,3]
19:18:37 <lambdabot>  False
19:18:54 <Iceland_jack> > 3 `notElem` [2,3]
19:18:55 <lambdabot>  False
19:18:56 <Hijiri> you could do it in agda
19:19:00 <Iceland_jack> No extension needed ;)
19:19:20 <Welkin> I keep hearing about agda
19:19:26 <Iceland_jack>     _`_`_ : ...
19:19:26 <Iceland_jack>     x ` f` y = f x y
19:19:26 <Welkin> it makes me want to learn it
19:19:29 <Welkin> along with idris
19:19:30 <Welkin> actually
19:19:32 <Hijiri> but instead of backticks it would be some unicode symbol you need the input method to input
19:19:34 <Welkin> idris or agda?
19:19:36 <MP2E> that's my issue, is that i don't know which one to commit to
19:19:38 <MP2E> idris or agda
19:19:42 <MP2E> i've learned a bit of both
19:19:43 <Welkin> haha
19:19:47 <Iceland_jack> ↑ that's how you could implement it in AGda
19:19:48 <Iceland_jack> *Agda
19:19:53 <Hijiri> agda isn't general purpose, for one thing
19:20:11 <Hijiri> so if you want to write applications idris would be a better choice (although it has a lot less libraries than haskell)
19:20:19 <Welkin> oh, so agda is more like coq
19:20:21 <Hijiri> yeah
19:21:56 <Hijiri> The interactive function-writing/proposition-proving is neat
19:22:04 <Hijiri> I don't know much agda yet, though
19:28:11 <Ralith> is haskell-src-exts unbuildable for anyone else?
19:28:32 <nkar> does 'memo' from the uglymemo package use unsafePerfromIO in a safe way?
19:36:46 <Koganei> reading http://learnyouahaskell.com/modules, they do map (\l@(x:xs) -> (x, length l))
19:36:49 <Koganei> what is this @?
19:36:53 <Koganei> they haven't mentioned it before
19:37:06 <Ralith> nvm, got it, my happy was old
19:37:30 <Iceland_jack> Koganei: 'as pattern'
19:37:39 <nkar> Koganei: it's like a 'let'
19:37:41 <marchelzo_> Koganei: l referse to the whole pattern, i.e. (x:xs), while x is (head l) and xs is (tail l)
19:37:44 <Iceland_jack> It just binds: l = x:xs
19:37:57 <Koganei> otherwise
19:38:08 <marchelzo_> s/referse/refers/
19:38:09 <Iceland_jack> It's basically the same as doing:
19:38:09 <Iceland_jack>     map (\(x:xs) -> (x, length (x:xs)))
19:38:24 <Iceland_jack> Or:
19:38:24 <Iceland_jack>     map (\l -> (head l, length l))
19:38:28 <HeladoDeBrownie> Except it reuses the original list
19:38:32 <Iceland_jack> Exactly.
19:38:39 <Koganei> ooh okay I see
19:38:44 <ReinH> (and the head version evaluates less)
19:38:44 <Koganei> thanks!
19:38:55 <Iceland_jack> Yes, ReinH but it's not relevant to the idea of as patterns
19:39:01 <Koganei> Do you guys work with haskell professionally?
19:39:13 <Iceland_jack> Hence 'basically'
19:41:06 <Koganei> guess not :o
19:41:31 <HeladoDeBrownie> Some here do
19:41:46 <HeladoDeBrownie> Not a small number, afaict
19:42:29 <indiagreen> some of us even get paid for working with Haskell, I think
19:42:38 <Koganei> hehe
19:43:53 <indiagreen> have you got a question which doesn't depend on the vague meaning of the word “professionally”?
19:44:25 <CrazyM4n> Paid? Huh, I'd do it for free
19:44:27 <Koganei> not really
19:44:36 <Koganei> just exploring the haskell world
19:44:41 <CrazyM4n> Assuming I had a stable source of income of course :P
19:44:58 <Iceland_jack> So not for free then :-)
19:46:10 <ReinH> There are plenty of things that I would do for free if I didn't need money...
19:46:31 <MP2E> same here
19:46:39 <CrazyM4n> Everyone knows how costly of a hobby haskell is
19:46:40 <MP2E> work on community projects forever :D
19:47:21 <Iceland_jack> My Emacs Professional version bleeds me
19:47:45 <CrazyM4n> Emacs... professional version?
19:47:53 <Iceland_jack> Yes. Crazy expensive
19:47:57 <Iceland_jack> rms got greedy
19:48:04 <MP2E> lol
19:48:12 <indiagreen> is there some kind of a “preferred language vs. used language” survey out there? Like, “Java programmers would code mostly in Scala if they didn't have to worry about money”, etc.
19:48:14 <HeladoDeBrownie> It's written in Java instead of Lisp</facetious>
19:48:18 <Iceland_jack> With ELisp 2014 integration, concurrency
19:48:24 <HeladoDeBrownie> or that :P
19:48:34 <Iceland_jack> No Java is better :)
19:48:36 <MP2E> indiagreen: not as far as i know, but i'd be interested in seeing something like that
19:49:23 <HeladoDeBrownie> I think ultimately I will be fine never torturing myself with Java to get more money, because I intend to live a minimalist lifestyle anyway :P
19:50:05 <indiagreen> like this but for languages instead of countries: http://peoplemov.in/
19:50:07 <CrazyM4n> Top two languages to make money would be Java and Scala or Python, and top two languages as a hobby would probably be Haskell and Ruby
19:50:10 <CrazyM4n> imho
19:50:23 <HeladoDeBrownie> CrazyM4n, forgetting C++ for the former?
19:50:37 <marchelzo_> C# too
19:50:48 <CrazyM4n> C#? Is that still a thing?
19:50:53 <HeladoDeBrownie> Oh yes
19:50:54 <marchelzo_> Uhh yeah
19:50:58 <CrazyM4n> Huh
19:51:03 <exio4> a nice middle lang is F#
19:51:12 <HeladoDeBrownie> Honestly if Python were as far up as you say I'd even be happy
19:51:15 <CrazyM4n> I know that F# is getting popular
19:51:22 <HeladoDeBrownie> Python isn't so bad as far as imperative languages go
19:51:25 <exio4> it can run in a mainstream runtime and is kinda functional
19:51:38 <CrazyM4n> I like ruby for my functionalish thingies
19:51:48 <CrazyM4n> Except for the fact that it's kinda slow
19:51:58 <exio4> I don't find Ruby that functional
19:52:23 <Iceland_jack> Let's not have that conversation
19:52:34 <exio4> >:D
19:52:37 <marchelzo_> It has map / filter / fold so it's a function programming language /s
19:52:42 <marchelzo_> functional*
19:52:46 <CrazyM4n> pft
19:52:55 <HeladoDeBrownie> If we are going to have the conversation, we should first peg down what "functional" means. Not that it matters much, no one agrees on it in general anyway
19:53:02 <Iceland_jack> Yes, exactly
19:53:17 <Iceland_jack> Haskellers think that nothing ‘below’ Haskell is functional
19:53:23 <CrazyM4n> Eh, it's terse and treats functions as things, so it's pretty good for me :P
19:53:31 <HeladoDeBrownie> whereas others will say Lisp is the embodiment of functional
19:53:35 <Iceland_jack> Yes
19:53:41 <Iceland_jack> A lot of them Lisp users :)
19:53:47 <exio4> which lisp though
19:53:49 <HeladoDeBrownie> Any
19:54:00 <HeladoDeBrownie> I like Racket in particular of those I've tried
19:54:07 <merijn> I never heard a haskeller argue F#/ocaml/SML/etc aren't functional, not PURELY functional, sure, but still functional
19:54:08 <Iceland_jack> Haskellers will make "powerful type system" as a controversial requirement
19:54:09 <CrazyM4n> Speaking of Lisp, is Clojure worth it to learn? I've wanted to for a while
19:54:34 <taktoa> clojure is pretty good
19:54:42 <taktoa> not great, but good
19:54:54 <Iceland_jack> merijn: F# got called "kinda functional"
19:55:09 <ReinH> Iceland_jack: for a definition of "powerful" that is at least strong enough to exclude whatever other language is being discussed ;)
19:55:13 <Iceland_jack> There is definitely a pecking order tied to the word functional
19:55:17 <taktoa> if you have an investment in the JVM / want to use java libraries, and you want something with racket/python semantics, clojure is nice
19:55:20 <exio4> it is functional as long as you don't get into the "OOP zone for having to work with the .NET libraries"
19:55:21 <Iceland_jack> ReinH: hah!
19:55:26 <exio4> now Iceland_jack?
19:55:41 <ReinH> Iceland_jack: or, in the case of more powerful type systems, we like to refer to Haskell's relative flexability and simplicity ofc
19:55:44 <HeladoDeBrownie> ReinH, pfft, all anyone should care about is Turing completeness. All TC languages are equally powerful, after all</facetious>
19:55:50 <MP2E> I wouldn't say a strong type system is a requirement to being purely functional, I will say it's 'kinda the point' though ;)
19:56:04 <CrazyM4n> HeladoDeBrownie: So, unlambda then?
19:56:07 <MP2E> that's of course it's own controversial argument!
19:56:08 <merijn> MP2E: I would, how do you enforce purity without strong type system?
19:56:19 <ReinH> "Sure, you could use a language with dependent types, but you probably don't need to"
19:56:20 <Iceland_jack> Exactly :) this conversation has been had kind of often, we can take it to #haskell-blah if people are interested
19:56:23 <MP2E> hmm.. I've never considered that before merijn
19:56:26 <CrazyM4n> Obviously Unlambda is the very best functional language
19:56:41 <HeladoDeBrownie> CrazyM4n, sure, let's start a movement to move the industry to that. I bet it'd create a lot of jobs too! (More people standing around scratching their heads to figure out what someone else wrote)
19:56:47 <L8D> HeladoDeBrownie: I understand you're joking, but all TC languages are not equally powerful
19:56:54 <CrazyM4n> It'll be great!
19:57:05 <HeladoDeBrownie> L8D, sure
19:57:08 <ski> Iceland_jack : (imo) Erlang and Scheme are also conventionally functional
19:57:27 <ski> (and Racket is a Scheme)
19:57:35 <CrazyM4n> Erlang is in such a weird spot
19:57:39 <HeladoDeBrownie> L8D, although partly I think it helps if you're clear what "powerful" you mean if you discuss power
19:58:49 <L8D> @pl \l -> f (g l) (h l)
19:58:49 <lambdabot> liftM2 f g h
19:59:08 <L8D> @where liftM2
19:59:08 <lambdabot> I know nothing about liftm2.
19:59:14 <L8D> @hoogle liftM2
19:59:15 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:59:42 <ski> merijn : it would be possible to have an opaque abstract type of `IO'-actions in a dynamically typed language. however, there'd still be the possibility of run-time type^Htag errors (just like there's the possibility of run-time partiality in Haskell)
19:59:58 <ski> @index liftM2
19:59:58 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:00:17 <L8D> :t liftM2
20:00:18 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:00:29 <L8D> oooh.... Identity
20:01:04 <Iceland_jack> It's not using the Identity instance by the way
20:01:13 <Iceland_jack> but the instance Monad ((->) r)
20:02:07 <Iceland_jack> replace every 'm' with ((->) r):
20:02:07 <Iceland_jack> :t liftM2
20:02:08 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:02:29 <ski> @type \f ma mb x -> liftM2 f ma mb x
20:02:30 <lambdabot> (a1 -> a2 -> r) -> (t -> a1) -> (t -> a2) -> t -> r
20:02:45 <Iceland_jack> and you'll get
20:02:45 <Iceland_jack> :t liftM2 :: (a -> b -> c) -> (r -> a) -> (r -> b) -> (r -> c)
20:02:46 <lambdabot> (a -> b -> c) -> (r -> a) -> (r -> b) -> r -> c
20:03:21 <Iceland_jack> effectively defined as:
20:03:21 <Iceland_jack>     liftM2 f ra rb r = f (ra r) (rb r)
20:03:38 <ReinH> CrazyM4n: Erlang is in a weird spot by design. It is not a general purpose language.
20:03:48 <CrazyM4n> I realize that
20:04:09 <CrazyM4n> But sometimes people talk about it as such
20:08:06 <L8D> we really could use a general purpose version of erlang
20:08:30 <L8D> and replace ruby with it
20:09:10 <CrazyM4n> Not my ruby :c
20:09:35 <L8D> CrazyM4n: have you seen Elixir?
20:09:48 <L8D> CrazyM4n: you like mutable data structures?
20:09:57 <L8D> CrazyM4n: you like OOP
20:10:08 <L8D> A?<esc>
20:10:16 <CrazyM4n> No and no
20:10:38 <CrazyM4n> My ruby looks like haskell and my python looks like lisp
20:10:52 <L8D> CrazyM4n: if you like Erlang and Ruby you really should go here: http://elixir-lang.org/
20:10:59 <CrazyM4n> I'm looking at it
20:11:05 <Zemyla_> :type (%)
20:11:15 <Zemyla_> :t (%)
20:11:15 <lambdabot> Integral a => a -> a -> Ratio a
20:11:17 <CrazyM4n> I don't have an opinion on erlang, never used it or looked into it past the webpage
20:11:22 <ReinH> Zemyla_: :t or @type :)
20:11:28 <torpet_> Given a function x :: Input -> Integer
20:11:35 <torpet_> How do I find the input with the max output?
20:12:05 <Iceland_jack> torpet_: What is Input?
20:12:14 <torpet_> Just a datatype
20:12:18 <Iceland_jack> Well it depends
20:12:20 <torpet_> It could be an Integer as well
20:12:29 <Iceland_jack> if the datatype is small then you could do: maximum [minBound..maxBound]
20:12:45 <Iceland_jack> sorry, maximum (map x [minBound..maxBound])
20:13:03 <Iceland_jack> If it's an Integer you need to give more information
20:13:19 <Iceland_jack> Do you know anything about the function? Is it monotonic?
20:13:43 <ski> i recall hearing that you can use a variable after a branching construct in Elixir, defining/instantiating it in the branching construct, even if you don't do that in every branch (in that case setting the variable to something silly or other like `nil')
20:14:37 <L8D> ski: what>
20:15:19 <L8D> ski: you can use a variable after a branching construct in any reasonable language
20:15:27 <L8D> or am I missing something
20:15:45 <L8D> "defining/instantiating it in the branching construct"
20:15:53 <nshepperd> i think ski is talking about a variable defined in one of the branches
20:16:03 <L8D> you cannot use a variable outside of it's lexical scope
20:16:11 <nshepperd> normally a variable defined that way is lexically scoped to the branch
20:16:19 <torpet_> Iceland_jack: Its actually just a datatype with 6 possible values
20:16:21 <L8D> it has the same semantics as Erlang
20:16:25 <torpet_> Actually football teams :D
20:16:42 <L8D> torpet_: you should learn about Logic Programming
20:16:55 <L8D> very useful when doing statistical calculations
20:18:10 <ski> L8D : in Erlang, if you define/instantiate the variable in every branch, then you can use it after the branching construct. but not if there's a branch in which you don't define/instantiate it
20:18:36 <ski> in Elixir, i'm told the latter caveat was scrapped. i dunno why they thought that would be a good idea
20:19:01 <L8D> well that sounds pretty weird, even for erlang
20:19:06 <L8D> but ok
20:19:18 <ski> (logic programming is cool. there's ##prolog and #mercury here on FreeNode, at least)
20:19:21 <L8D> I guess I'm not surprised that Elixir changes that
20:19:34 <ski> L8D : that erlang behaviour is basically inherited from Prolog
20:19:35 <L8D> aren't there a couple LP constructs in Haskell?
20:20:43 <ski> (while adding the static check because the compiler must know at each point which variables are instantiated, and doesn't allow partially instantiated structures, in Erlang (and also in Mercury), but not in Prolog (because it is dynamically moded))
20:20:57 <ski> L8D : i wouldn't really say so ?
20:21:02 <ski> which did you have in mind ?
20:21:19 <ski> list comprehensions / list monad ?
20:21:23 <L8D> https://www.haskell.org/haskellwiki/Logic_programming_example
20:21:30 <ski> (which gives a kind of backtracking)
20:22:26 <ski> well, the main problem here is that this doesn't give us logic variables, only backtracking
20:22:52 <ski> you can build libraries to implement logic variables (i've made a simple prototype myself), though
20:23:56 <L8D> are there any modern options for logic programming?
20:24:06 <ski> Mercury is pretty modern ?
20:24:15 <L8D> I'm a little scared to dive head first into mercury or prolog
20:24:21 <CrazyM4n> What's the benefit to logic programming anyway?
20:24:26 <CrazyM4n> Seems like a pain
20:24:39 <L8D> CrazyM4n: it's a domain-specific paradigm
20:24:45 <CrazyM4n> Ah
20:24:55 <L8D> useful for computing statistics, board games and AIs
20:25:06 <ski> it has a static type system, a static mode and instanstiation system, a static determinism system. parametric types, universal polymorphism, type classes (multi-parameter, with FDs, but only for concrete types)
20:25:17 <ski> and a reasonable module system
20:25:43 <ski> it also has existential types, and some other interesting things
20:26:16 <ski> L8D : since most of the literature is on Prolog (or various variants/extensions), i would recommend learning basic Prolog first
20:26:40 <ski> also so that you'll better appreciate the static mode, inst and determinism system of Mercury ;)
20:26:56 <L8D> hm.....ok thanks
20:27:31 <ski> there's also Oz (and Gödel, and Curry and Escher, but i'm not sure whether those are actively developed atm)
20:28:02 <L8D> holy shit that's an awesome name for a programming language
20:28:34 <ski> L8D : you might be interested in reading "Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-09 at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html> and in 2006-10-10 at <http://www.mercurylang.org/list-archives/users/2006-October/004011.html>
20:29:13 <CrazyM4n> I wish J caught on a little more
20:29:21 <L8D> where should I start learning Prolog?
20:29:29 <L8D> here? https://en.wikibooks.org/wiki/Prolog/Introduction
20:32:15 <L8D> :q
20:32:19 <ski> L8D : "Learn Prolog Now!" by Patrick Blackburn,Johan Bos,Kristina Striegnitz at <http://www.learnprolognow.org/>,<http://cs.union.edu/~striegnk/learn-prolog-now/html/prolog-notes.pdf>
20:33:12 <ski> "Programming in Prolog" by Clocksin,Mellish is a traditional choice of a starting book
20:33:48 <ski> "Prolog: Programming for Artificial Intelligence" by Ivan Bratko is also good
20:33:59 <ski> and "The Art of Prolog" by Sterling,Shapiro
20:34:14 <L8D> ski: are you a prolog enthusiast?
20:34:20 <ski> "The Craft of Prolog" by Richard A. O'Keefe is more advanced
20:34:57 <L8D> I just /whois'd you so nvm
20:35:09 <MP2E> lol
20:35:14 <MP2E> he's a prologician!
20:35:14 <ski> <http://web.student.chalmers.se/~md9slj/logic_programming_resources> is a list of a few resources
20:35:31 <ski> (some links may be broken, i haven't checked it in a while)
20:36:14 <ski> L8D : iirc, there's a "seven languages in seven weeks" book (or named something like that, at least), that has Mercury in one chapter
20:37:13 <ski> L8D : for Oz, see <http://www.mozart-oz.org/>
20:38:02 <L8D> I thought 7li7w had prolog
20:38:08 <ski> oh, and you should also read CTM at some point
20:38:14 <ski> @where CTM
20:38:14 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
20:38:34 <ski> L8D : it's a new/followup or something, not sure if it's come out yet
20:38:40 <L8D> ski: you would make, like, the best programming mentor ever
20:38:51 <L8D> you should give a presentation or two
20:38:54 <ski> (i've seen a preview version of the chapter)
20:38:57 <L8D> anyways thanks
20:38:59 <ski> yw
20:40:22 <ski> anyway, instead of allowing rebinding of variables as in Elixir, i would prefer something like the state-variable notation in Mercury <http://www.mozart-oz.org/>
20:40:40 <ski> where you can clearly see in the syntax at which point you "update" a variable
20:41:19 <bryanedds> I wonder if it's often easier or even simpler to build a custom monad from scratch rather than compose it with transformers?
20:41:20 <ski> (and it desugars to ordinary "no reassignment" logic programming code, by introducing a new variable for each span between two changes)
20:41:48 <L8D> bryanedds: if you want a custom monad for the sake of a glorified State monad or a DSL, then probably yes
20:41:59 <bryanedds> ya
20:43:00 <ski> L8D : anyway, i reiterate reading those two O'Keefe posts. i think they're really useful
20:43:34 <L8D> ski: now or later?
20:43:41 <ski> at your option
20:43:48 <ski> as long as you read them ;)
20:43:52 <L8D> after I have the basics down or before?
20:43:57 <ski> before is fine
20:44:05 <L8D> :D
20:44:35 <ski> (they're about a more general topic than Mercury vs. Prolog)
20:44:58 <L8D> ah
20:46:01 <bryanedds> I need a synonym for asynchronous.
20:46:04 <ski> (e.g. i think parts of it would carry over to e.g. Haskell)
20:46:13 <L8D> bryanedds: out-of-sync
20:46:15 <L8D> no
20:46:26 <L8D> nonsynchronous
20:46:34 <MP2E> strong, independent thread?
20:46:37 <L8D> out-of-order
20:46:37 <MP2E> [/badjoke]
20:46:46 <bryanedds> hmm
20:46:51 <L8D> [/crappierjoke]
20:47:02 <ski> @wn intermittent
20:47:03 <lambdabot> *** "intermittent" wn "WordNet (r) 3.0 (2006)"
20:47:04 <lambdabot> intermittent
20:47:04 <lambdabot>     adj 1: stopping and starting at irregular intervals;
20:47:04 <lambdabot>            "intermittent rain showers"
20:47:10 <ski> maybe ?
20:47:14 <bryanedds> hmmmm
20:47:32 <L8D> "callbacks-based" like a total coding snob
20:47:44 <ski> ("The area has many intermittent lakes and streams.")
20:47:54 <bryanedds> callaback_girl
20:48:07 <MP2E> haha
20:48:28 <L8D> paperback writer?
20:48:45 <bryanedds> but seriously, this is a hard one - async is already used in my context
20:48:47 <L8D> no one? okay. I'll stop while I'm ahead
20:49:35 <ski> bryanedds : and you mean it somehow in a different sense ?
20:49:59 <L8D> wait... is prolog even turing complete?
20:50:00 <bryanedds> ya, the one in my context is a general async possible involving IO
20:50:16 <bryanedds> mine is based on a series of callbacks from pure functional events
20:50:18 * ski hasn't checked out the Prolog WikiBook, btw
20:50:29 <bryanedds> IE - mine is awesome, other is lamezz
20:50:59 <L8D> bryanedds: "stateless" ?
20:51:15 <bryanedds> but I can't completely replace the name as there are still some legit uses of the existing one
20:51:29 <bryanedds> and it would simply be confusing
20:51:42 <bryanedds> Right now, I think nonsync is winning
20:52:04 <ski> L8D : oh, i forgot to say. it's probably easiest to start with SWI (or maybe GNU) Prolog. if you are comfortable with working with a non-GUI interface, you could also try Yap (Yet Another Prolog)
20:52:25 <bryanedds> even that's innaccurate tho -
20:52:30 <bryanedds> @wn nonsynchronous
20:52:31 <lambdabot> *** "nonsynchronous" wn "WordNet (r) 3.0 (2006)"
20:52:31 <lambdabot> nonsynchronous
20:52:31 <lambdabot>     adj 1: not occurring together [syn: {nonsynchronous},
20:52:31 <lambdabot>            {unsynchronized}, {unsynchronised}, {unsynchronous}]
20:52:38 <bryanedds> oh
20:52:42 <ski> L8D : "is prolog even turing complete?" -- yes
20:52:48 <bryanedds> wait, maybe it is fine
20:52:54 <L8D> ski: it's not deterministic?
20:53:27 <ski> Prolog employs angelic nondeterminism, to explore all possible ways to solve a (sub)query/goal
20:53:48 <L8D> bryanedds: http://www.thesaurus.com/browse/asynchronous
20:53:59 <L8D> uncontemporaneous
20:54:15 <ski> if you ask the question `append([0,1,2],[3,4],Xs)', then you get the answer `Xs = [0,1,2,3,4]'
20:54:16 <bryanedds> lol heh :)
20:54:27 <L8D> apparently "concurrent" is an antonym of async
20:54:33 <bryanedds> ya, I already went there
20:54:38 <ski> if you ask the question `append([0,1,2],[3,4],[0,1,2,3,4])', then you get the answer `yes'/`true'
20:54:47 <ski> if you ask the question `append([0,1,2],[3,4],[0,1,5,3,4])', then you get the answer `no'/`false'
20:55:03 <ski> if you ask the question `append([0,1,2],Suffix,[0,1,2,3,4])', then you get the answer `Suffix = [3,4]'
20:55:14 <ski> if you ask the question `append([0,1,2],Suffix,[0,1,5,3,4])', then you get the answer `no'/`false'
20:55:30 <bryanedds> I nominate uncontemporaneous for word of the day on #haskell
20:55:37 <L8D> ^^^
20:55:45 <ski> if you ask the question `append(Prefix,Suffix,[0,1,2])', then there's four possible answers, which you can get Prolog to enumerate for you :
20:55:53 <ski>   Prefix = [],Suffix = [0,1,2]
20:55:57 <ski>   Prefix = [0],Suffix = [1,2]
20:56:01 <ski>   Prefix = [0,1],Suffix = [2]
20:56:05 <ski>   Prefix = [0,1,2],Suffix = []
20:56:29 <ski> so the same append/3 predicate does the same job as several different functions
20:56:32 <L8D> but what if there's an infinite solution (sorry my naiveness)
20:56:57 <L8D> like if I did: add(X, Y) = 1
20:57:06 <ski> and it's a single piece of code that does all these different behaviours (called "modes" of the predicate). two or three lines, depending on how you indent it
20:57:23 <Axman6> how is append defined?
20:57:58 <rcook> Hi! Does anybody here know about installing packages via cabal on Windows?
20:58:05 <ski> if you ask `append(Prefix,Suffix,List)', then you'll get an infinity of solutions enumerated
20:58:07 <L8D> rcook: no
20:58:16 <ski>   Prefix = [],List = Suffix
20:58:28 <ski>   Prefix = [_A],List = [_A | Suffix]
20:58:36 <ski>   Prefix = [_A,_B],List = [_A,_B | Suffix]
20:58:43 <ski>   Prefix = [_A,_B,_C],List = [_A,_B,_C | Suffix]
20:58:44 <ski> &c.
20:58:49 <rcook> <L8D> Thanks!
20:58:56 <L8D> rcook: sorry
20:59:06 <torpet_> Why is foldr slowert than foldl for concat lists?
20:59:11 <L8D> maybe some of the F# guys know
20:59:22 <torpet_> Oh, I meant foldl is slower than foldr
20:59:31 <rcook> L8D: OK, thanks.
20:59:31 <L8D> torpet_: because of the order of the arguments to (:)
20:59:38 <ski> but usually it's a bad idea to use a predicate in a mode where it yields a (countably) infinite number of solutions, since it's very easy to get into a "deadlock" / infinite loop then, if you add a further guard that eventually fails on every generated solution
20:59:38 <L8D> oh
20:59:42 <ski> a bit like
20:59:45 <L8D> torpet_: because foldl starts at the left
20:59:59 <L8D> torpet_: foldr means you have to traverse to the end of the list to start
21:00:01 <ski> > filter odd ([0 .. 9] ++ [10,12 ..])
21:00:05 <lambdabot>  mueval-core: Time limit exceeded
21:00:13 <ski> > take 5 (filter odd ([0 .. 9] ++ [10,12 ..]))
21:00:15 <lambdabot>  [1,3,5,7,9]
21:00:17 <ski> > take 6 (filter odd ([0 .. 9] ++ [10,12 ..]))
21:00:20 <lambdabot>  mueval-core: Time limit exceeded
21:00:34 <L8D> ah
21:00:55 <ski> torpet_ : you want to associate nested calls to `(++)' to the right, not to the left
21:01:15 <ski> Axman6 : append/3 is defined like :
21:01:33 <ski>   append([    ],Bs,     Bs ).
21:01:44 <ski>   append([A|As],Bs,[A|AsBs]) :-
21:01:51 <ski>     append(As,Bs,AsBs).
21:02:09 <ski> you can think of this as saying something like
21:02:17 <L8D> woah
21:02:29 <ski>   [    ] ++ bs = bs
21:02:31 <L8D> that's just... awesome.
21:02:37 <ski>   (a:as) ++ bs = a:asbs
21:02:39 <ski>     where
21:02:40 <L8D> I get it now.
21:02:44 <torpet_> https://www.dropbox.com/s/qoc5nikby7gpv5u/Screenshot%202014-12-05%2005.59.54.png?dl=0
21:02:45 <ski>     asbs = as ++ bs
21:03:07 <ski> except that instead of only being able to give `as' and `bs' as input, computing `as ++ bs'
21:03:22 <torpet_> ski: Hm I dont really get why ++ is slower from l to r
21:03:22 <ski> you can also given `as ++ bs' and `as' as input, computing `bs'
21:03:37 <ski> or give `as ++ bs' only as input, and compute possible `as',`bs' pairs
21:03:59 <Zekka> 21:57 [           L8D] : torpet_: because foldl starts at the left
21:04:00 <Zekka> 21:57 [           L8D] : torpet_: foldr means you have to traverse to the end of the list to start
21:04:02 <Axman6> torpet_: you mean a ++ (b ++ c) compares to (a ++ b) ++ c?
21:04:08 <Zekka> L8D: Did you catch Cale's talk about this yesterday?
21:04:10 <Axman6> compared*
21:04:16 <torpet_> Zekka: Because I have to travers it is faster??
21:04:19 <L8D> Zekka: logic programming?
21:04:20 <ski> torpet_ : `as ++ bs' will run down and copy the spine of `as'. so `(as ++ bs) ++ cs' will effectively run down copy the spine of `as' twice
21:04:22 <Zekka> It was super comprehensive and I can probably dig it out of the logs
21:04:38 <L8D> Zekka: talk about what?
21:04:38 <ski> torpet_ : and for `((as ++ bs) ++ cs) ++ ds', thrice, &c.
21:05:12 <L8D> oh
21:05:13 <Zekka> L8D: Why "foldl starts at the left" is a hard statement to make
21:05:24 <L8D> Zekka: because of lazy evaluation?
21:05:42 <Zekka> Yeah, what he had to say had to do with lazy evaluation
21:06:03 <ski> `foldl' is tail-recursive, and therefore bulky, rather than incremental as `foldr' may be (depending on the function passed to it)
21:06:13 <L8D> yeah I keep forgetting that
21:06:15 <Zekka> The short version is that both start from the left becacuse you can't unccons the list another way
21:06:24 <L8D> I always think about scanl vs scanr
21:06:58 <ski> the tail-recursiveness behaves as we're "blocking on seeing the end of the list"
21:07:04 <ski> s/as/as if/
21:07:31 <Zekka> I'm reluctant to summarize because I don't think I can summarize better than he did just by expanding foldr and foldl
21:07:46 <L8D> I get it, it's been explained to me before
21:07:48 <L8D> I just forgot
21:07:56 <Zekka> ski's comments also address the performance concern though
21:08:05 <L8D> now, the real question is, how much does this matter?
21:08:44 <Zekka> L8D: Quite a lot if you have an associative operation (or operation with foldl and foldr-compatible versions) and want to write code that uses folds!
21:09:04 <L8D> I mean in terms of performance
21:09:07 <ski> L8D : anyway, erratic nondeterminism is when the computer will arbitrarily pick one out of many possible solutions for you (think sources of random bits, indeterminacy of interleaving (race conditions) in concurrency, and library (and language) specifications not pinning down the semantics of some operation/construct completely)
21:09:16 <Zekka> foldl keeps more of the stack and it's likely to be less performant, and foldl will always try to consume the whole list
21:09:47 <ski> L8D : demonic nondeterminism is (roughly) when the computer will pick the solution that will most likely make your program hang or fail
21:09:58 <L8D> nonono, the real question is how much does this kind of performance fault matter
21:10:03 <Zekka> @src foldl
21:10:03 <lambdabot> foldl f z []     = z
21:10:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:10:14 <L8D> ski: when does that come into accound?
21:10:23 <L8D> account*
21:10:25 <Zekka> L8D: What do you mean? Do you want a quantitative measure of the difference in performance?
21:10:31 <L8D> "demonic nondeterminism"
21:10:42 <ski> Zekka : angelic nondeterminism is when the computer will pick the "best" solution for you (the one making further computation succeed and continue), commonly implemented by trying each alternative until one works, backtracking when one fails
21:10:48 <ski> er
21:10:50 <ski> L8D : ^
21:10:53 <L8D> Zekka: I want a qualitative measure of how often the difference in performance matters
21:11:52 <ski> L8D : aiui, demonic nondeterminism would mostly be useful for testing/debugging purposes, and as a theoretical construct to use in semantics
21:11:56 <Zekka> Isn't it the same as always -- it matters if your code is slow, uses too much memory, or hangs on infinite input when it could have not done?
21:12:07 <Zekka> (or needs to consume the whole input to produce the answer)
21:14:19 <L8D> Zekka: why does it matter that my code is slow?
21:14:29 <L8D> that's my question
21:14:37 <Zekka> L8D: That depends on the usecase
21:14:44 <L8D> why does this virtually tiny difference in performance matter so much
21:14:48 <torpet_> ski: got it, thanks
21:14:51 <Zekka> I wrote a program that needed to return a response in 1.5secs, no matter what, or how large the input size is
21:14:58 <torpet_> basically foldr (++) is just copying the result once
21:15:04 <Zekka> I implemented a core algorithm badly and it took too long to return a lot of the time
21:15:05 <torpet_> where foldr is copying each result inb etween
21:15:30 <Zekka> So I had to rewrite it or else the system it interfaced with would hang and die
21:15:43 <Zekka> er, hang up*, not hang
21:15:47 <ski> Zekka : starting at 18:31:16 at <http://tunes.org/~nef/logs/haskell/14.12.03> ? or earlier ?
21:16:18 <Zekka> ski: I don't remember reading that conversation
21:17:01 <Zekka> Oh wait, should I be looking for Cale's talk?
21:17:13 <ski> Zekka : ok, perhaps 21:20:06, then ?
21:17:13 <Zekka> just saw that you had a timestamp
21:17:18 <torpet_> So given data Team = A | B | C deriving deriving (Eq,Ord,Show)
21:17:29 <ski> you should search for the given timestamp, yes
21:17:31 <torpet_> How would I apply a function on A, B, and C and find the max?
21:17:42 <Zekka> The one I saw was 21:20:06 and on
21:17:45 <ski> ok, ty
21:18:01 <torpet_> I cannot derive Bounded
21:18:16 <Zekka> L8D: Oftentimes you're in a situation where performance doesn't matter in the sense that your code no longer does the correct thing if it's too slow
21:18:31 <Zekka> But I personally tend to get bored when my code takes too long to run so I generally write fast code over slow code
21:18:52 <Zekka> But there are a lot of cases where I don't care because the code isn't executed very often, so I write slow code if it's easier
21:19:13 <Zekka> This is pretty much how you optimize in any situation, AFAIK
21:21:28 <Zekka> L8D: Does that help at all? I'm worried I'm being condescending
21:22:02 <piskrist> How are lists loops?
21:22:38 <Zekka> piskrist: You can write a lot of code in terms of lists that you would write in terms of loops otherwise
21:23:00 <piskrist> loops as in iterations that would be executed for each element?
21:23:08 <Zekka> they're flexible enough to express loops even though the most natural way to express a thing in lists isn't always one-to-one corresponding to the most natural way to do it for lists
21:23:22 <Zekka> piskrist: foreach is one of the things that's easy to express in terms of lists.
21:23:37 <piskrist> well map f xs
21:23:39 <Zekka> piskrist: You can also write c-style for though in terms of iterate and takeUntil
21:23:43 <Zekka> :t takeUntil
21:23:44 <lambdabot> Not in scope: ‘takeUntil’
21:23:49 <Zekka> hm, did I get that name wrong?
21:23:59 <Zekka> Oh, takeWhile, my mistake
21:24:11 <Zekka> :t iterate
21:24:11 <lambdabot> (a -> a) -> a -> [a]
21:24:13 <Zekka> :t takeWhile
21:24:14 <lambdabot> (a -> Bool) -> [a] -> [a]
21:24:25 <piskrist> well, are you talking about taking `for x in xs: foo(xs)` and making it `map f xs`?
21:24:52 <Zekka> takeWhile (<10) $ iterate (+1) 0
21:24:58 <Zekka> er, oops
21:25:00 <Zekka> > takeWhile (<10) $ iterate (+1) 0
21:25:02 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
21:25:21 <Zekka> piskrist: That's how you do foreach, but you can also express other loops in terms of list operations
21:26:20 <sgronblo> out of curiosity: does anyone here happen to be in tokyo?
21:26:59 <Zekka> let cFor init cond incr body = forM (takeWhile cond $ iterate incr init) body
21:27:03 <Zekka> @let cFor init cond incr body = forM (takeWhile cond $ iterate incr init) body
21:27:04 <lambdabot>  Defined.
21:27:40 <Zekka> > cFor 0 (< 10) (+1) \i -> putStrLn $ "I am number " ++ show i
21:27:41 <lambdabot>  <hint>:1:20: parse error on input ‘\’
21:27:48 <Zekka> > cFor 0 (< 10) (+1) $ \i -> putStrLn $ "I am number " ++ show i
21:27:48 <piskrist> hrm, ok. I think I get this but still not sure about "lists are loops"
21:27:50 <lambdabot>  <IO [()]>
21:27:55 <Zekka> oh, how silly of me
21:28:05 <Zekka> piskrist: I don't think I would make a statement as strong as "lists are loops"
21:28:07 <piskrist> does that mean that every lists eventually leads to a loop?
21:28:16 <Zekka> I'd say "recursion is loops"
21:28:28 <piskrist> well, Cale said "lists are loops that haven't happened yet"
21:28:57 <Zekka> piskrist: Lists are good at describing a notion of progress towards an end-condition, I guess
21:29:00 <johnw> piskrist:  perhaps a better term to use instead of loop would be a "fold"
21:29:03 <piskrist> so I'm thinking, every list implies a loop happening somewhere down the execution path, because what is the list good for if it doesnt?
21:29:04 <ski> > execWriter . cFor 0 (< 10) (+ 1) $ \i -> tell ["I am number " ++ show i]
21:29:06 <lambdabot>  ["I am number 0","I am number 1","I am number 2","I am number 3","I am numbe...
21:29:19 <Zekka> Folding over a list is then similart to making that progress to an end condition
21:29:22 <Zekka> ski: Thanks!
21:29:29 <Cale> piskrist: I mean this in the sense that just like a loop will either not happen because its precondition isn't met, or else consist of an iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
21:29:50 <ski> piskrist : is `head' a loop ?
21:30:32 <Zekka> piskrist: You can represent each list as a partially-applied fold
21:30:39 <Zekka> Which is a very literal sense of "loop that hasn't happened yet"
21:30:45 <Cale> ski: Maybe a very degenerate one, lol :)
21:31:08 <Zekka> :t foldr
21:31:09 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:31:09 <piskrist> ski: depends on wheter Cale originally really meant "loop" and not "iteration"
21:31:31 <Zekka> @let oneTwoThree = \f x -> foldr f x [1, 2, 3]
21:31:33 <lambdabot>  Defined.
21:31:40 <Zekka> :t oneTwoThree
21:31:41 <lambdabot> Num a => (a -> b -> b) -> b -> b
21:31:51 <ski> piskrist : in the sense of "loop" being more general than "iteration"
21:31:57 <Cale> Applying take 1 is kind of like adding a conditional to the loop body which will break out when it's hit on the first iteration.
21:32:28 <ski> (anyway, my `head' query was just to make you consider and think about the case, not to make a specific answer pop out)
21:32:48 <Welkin> whenever I want to use head, I don't
21:32:52 <ski> piskrist : sorry, forgot the "?" at the end of my penultimate message
21:32:56 <Welkin> but I don't jave easy access to headMaybe
21:33:02 <Welkin> or maybeHead
21:33:04 <Welkin> whatever it is called
21:33:07 <piskrist> well, what is a loop? To me a loop is all the iterations - that is a function, condition and an input list
21:33:13 <ski> @type listToMaybe  -- Welkin
21:33:14 <lambdabot> [a] -> Maybe a
21:33:22 <Zekka> You can recover the original list using the oneTwoThree representation, so you can represent any operation on lists in terms of operations on oneTwoThree
21:33:26 <ski> @index listToMaybe
21:33:26 <lambdabot> Data.Maybe
21:33:36 <Zekka> Even though the type of oneTwoThree indicates it's a strategy to fold over the list
21:33:45 <Zekka> > oneTwoThree (:) []
21:33:46 <lambdabot>  [1,2,3]
21:34:04 * ski awaits Zekka mentioning `build'
21:34:33 <Zekka> So you can turn any oneTwoThree into a list an you can (using a version of my original definition) turn any list into a oneTwoThree
21:34:40 <Zekka> ski: I don't know what you're getting at! Maybe you should mention it.
21:35:14 <ski> @type GHC.Exts.build
21:35:14 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
21:35:22 <ski>   build builder = builder (:) []
21:35:28 <brent_plow> chrisdone: Could I ask you a ? about setting up ircbrowse?
21:35:31 <Zekka> I didn't even know that was defined! Yes, that is my function.
21:35:44 <piskrist> ski: I thought you used head as a counterexample
21:36:03 <Zekka> piskrist: Anyway, based on what I just wrote you can see that each list is isomorphic to a function that folds over that list
21:36:10 <ski> `foldr'/`build' fusion amounts to `forall cons,nil,builder. foldr cons nil (build builder) = builder cons nil'
21:36:25 <ski> piskrist : i used it as an interesting case to consider
21:36:43 <piskrist> so I thought that it just pops one element so it can be thought of as an iteration but not loop since there is only one
21:36:55 <torpet> Offtopic: What Linux distro has the most up to date haskell packages? Or what would you prefer if you used cabal?
21:37:10 <piskrist> but reflecting upon how I defined loop previously, the fact that it takes only one element doesn't matter
21:37:13 <ski> Zekka : so if you can express your list consumers in terms of `foldr' on the list, and your list producers in terms of `build', you can use `foldr'/`build' fusion to avoid the intermediate lists
21:38:02 <piskrist> so actually yeah, head is a loop
21:38:08 <ski> piskrist : "To me a loop is all the iterations" -- sometimes by "iteration", we mean the whole sequential process of repeating more or less the same thing over and over in a sequence
21:38:32 <ski> e.g. "iterative process" vs. "recursive process"
21:39:02 <piskrist> Interesting. I have never seen such perception
21:39:21 <piskrist> but I realize I don't really know what iterations is to me now
21:39:32 <ski> tail-recursion yields an iterative process, in case we have proper tail-calls (misnomer is "proper tail-recursion"), which means that the language guarantees that we may have an unbounded number of active tail-calls in bounded memory
21:39:43 <piskrist> I guess it would be one application of the function to one element
21:40:22 <ski> an incremental function can also sometimes be used in a way which forms an iterative process
21:41:05 <piskrist> which I guess doesn't make sense when talking about haskell code unless the context is specificaly about following the code execution
21:41:30 <ski> (e.g.  (foldl' (+) 0 . filter odd . map (\x -> x * (x + 1) `div` 2)) [0 ..]  )
21:42:22 <piskrist> what is an iterative function?
21:42:27 <ski> (or, you could say "iteration" vs. "recursion", if you like)
21:42:28 <piskrist> doh
21:42:34 <piskrist> incremental function
21:42:48 <ski> `map' is one
21:42:52 <nolrai66> So I have a value that can vary from 1-16. Whats the best way of making/using a type for it? Should I make an data type with constuctors One Two Three ect?
21:42:57 <ski> `foldr' may be one, depending on the function argument
21:43:03 <ski> @src map
21:43:03 <lambdabot> map _ []     = []
21:43:03 <lambdabot> map f (x:xs) = f x : map f xs
21:43:05 <piskrist> so that would be any highr order function?
21:43:16 <piskrist> oh, ok
21:43:30 <ski> in the recursive case, we only perform the recursive call if and when someone wants to look at the tail of the output list
21:43:37 <ski> so we generate one element at a time
21:43:46 <ski> @src foldr
21:43:46 <lambdabot> foldr f z []     = z
21:43:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:44:11 <thsutton> Is it possible to get cabal to install executables into the libexec directory?
21:44:16 <ski> if `f' is non-strict in its second argument, then the recursive call to `foldr' will similarly also be delayed
21:44:24 <ski> @src foldl
21:44:24 <lambdabot> foldl f z []     = z
21:44:24 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:44:26 <thsutton> Google and grepping the source don't seem to suggest anything.
21:45:00 <piskrist> ski: yeah sure. But I don't see the point here. Looks like we are getting on a tangent
21:45:03 <ski> here as soon as we make an initial call to `foldl', we continue immediately with the (tail-)recursion, until (if) we reach the end of the input list. this is not incremental, it's bulky
21:45:20 <johnw> nolrai66: maybe you'd like http://hackage.haskell.org/package/data-fin
21:45:35 <ski> piskrist : you asked about "incremental" ?
21:46:23 <piskrist> oh ok but I still fail to see the difference
21:46:53 <ski> a bulky operation runs to the end before yielding back control
21:47:27 <ski> an incremental operation will run in small increments, yielding back control after each
21:47:59 <piskrist> depends on the behaviour of f in the foldl, doesn't it?
21:48:15 <piskrist> I think I get it now
21:48:18 <Zekka> piskrist: Nah, look closely at the definition of foldl
21:48:49 <Zekka> Each recursive step just brings up another foldl until reaching the end of the list
21:48:59 <piskrist> yeah, right
21:49:04 <Zekka> Granted, f doesn't necessarily have to use it
21:49:16 <Zekka> but unlike with foldr the whole list will be consumed before we start producing output
21:49:26 <ski> so generators (in e.g. Python) would fall under incremental operations
21:49:26 <piskrist> I see. So the point is you can map f over an infinite list but not foldl
21:49:53 <ski> (but one could make an incremental operation, e.g. over a tree, in Haskell, that would be difficult (impossible ?) to do with generators)
21:50:09 <ski> piskrist : that's one way to see it, yes
21:50:16 <piskrist> or rather that's another effect of the difference between incremental and bulky function
21:51:12 <piskrist> right, cool stuff
21:51:23 <ski> cheers
21:52:34 <piskrist> so tail-recursive process is iterative?
21:52:34 <platz__> so when haskell evals 1+(2+(3+0)) it will reduce as -> 1+2+(3+0) -> 3+(3+0) -> 3+3 -> 6 ? otherwise can't see how 'take 4 foldr f 0 (infinite)' works
21:53:14 <Zekka> platz__: I don't think I see the relationship between the first thing you asked and the second thing
21:53:21 <ski> piskrist : a tail-recursive function (or predicate, in logic programming, or procedure, in imperative programming) yields an iterative process, yes
21:53:43 <piskrist> riiight.
21:53:50 <piskrist> I just had 3 three aha moments
21:53:53 <piskrist> thanks ski
21:53:54 <ski> (definite and indefinite looping constructs in imperative programming also yields iterative processes)
21:54:07 <ski> np
21:55:20 <ski> platz__ : "if `f' is non-strict in its second argument, then the recursive call to `foldr' will similarly also be delayed" -- `(+)' (on e.g. `Integer' or `Int' or `Double') is strict in its second argument (even in both)
21:55:20 <platz__> Zekka: well, to give some intermediate results, we can't eval all the way to the last element, but when foldr is described, often we talk of the parens as giving the result with the right end evaluated "first"
21:55:59 <ski> > take 4 (foldr (+) 0 [0 ..])  -- hangs
21:56:00 <lambdabot>  No instance for (GHC.Show.Show a0)
21:56:01 <lambdabot>    arising from a use of ‘M326466885057246640614528.show_M3264668850572466406...
21:56:01 <lambdabot>  The type variable ‘a0’ is ambiguous
21:56:01 <lambdabot>  Note: there are several potential instances:
21:56:01 <lambdabot>    instance [safe] GHC.Show.Show
21:56:12 <ski> er, scrap the `take'
21:56:18 <ski> > foldr (+) 0 [0 ..]  -- hangs
21:56:18 <Zekka> platz__: To be clear, in 1+(2+(3+0)), the first + is expanded first
21:56:23 <lambdabot>  mueval-core: Time limit exceeded
21:56:23 <lambdabot>  mueval: ExitFailure 1
21:56:42 <Zekka> So if (+) x y = x, then 1+(2+(3+0)) is immediately expanded to 1
21:56:43 <ski> > take 4 (scanr (+) 0 [0 ..])  -- otoh works, since `scanr' is (unconditionally) incremental
21:56:48 <lambdabot>  mueval: ExitFailure 1
21:56:59 <platz__> Zekka: right, it just looks funny because most people would mentally expand the innermost parens first
21:57:09 <platz__> but that's not how haskell doe sit
21:57:26 <Zekka> It only expands as much as it needs to!
21:57:36 <ski> sorry, that doesn't work. it works with `scanl'
21:57:47 <ski> > take 4 (scanl (+) 0 [0 ..])
21:57:49 <lambdabot>  [0,0,1,3]
21:57:58 <Zekka> It won't expand the inner parts until, while evaluating the outer parts, it determines it needed to evaluate the inner ones to
21:58:30 <Zekka> too*
21:58:35 <platz__> I think it makes sense to me more thinking carefully about what kind of 'f' is given to foldr
21:58:47 <platz__> i.e. if it's strict in both args or not
21:58:55 <ski> > (take 4 . map (take 4)) (scanr (:) [] [0 ..])  -- otoh works fine, since `(:)' is non-strict in its second argument
21:58:56 <lambdabot>  [[0,1,2,3],[1,2,3,4],[2,3,4,5],[3,4,5,6]]
22:01:42 * hackagebot persistent-redis 0.3.0 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.3.0 (PavelRyzhov)
22:02:21 <platz__> then it seems if 'f' is strict in both args, there is no real advantage of foldr over foldl
22:02:47 <platz__> just see a lot of examples/libs preferring foldr
22:02:54 <ski> > (null . take 4) (scanr (+) 0 [0 ..])  -- also works. it's just that the elements are undefined
22:02:55 <lambdabot>  False
22:03:26 <platz__> perhaps to take advantage if there are gains due to laziness, but can't think of any others
22:04:13 <nolrai66> Well, no. Then you want foldl' maybe. But not foldl. iiuc.
22:04:39 <ski> platz__ : as long as you `flip' when you switch (unless you know your operation is associative, and has both a left and a right neutral eleement), it should be fine .. depending  foldl'  (or even stricter) may be preferable
22:04:41 <platz__> foldl'/foldl yeah
22:05:41 <ski> (since  foldl'  only forces the head, you have to insert more forcing if you have something compound, e.g. a tuple, that you'd like to be strict in each component of)
22:06:17 <ski> .. but sometimes you want to be less strict, to make stuff work
22:06:21 <ski> @src partition
22:06:22 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
22:06:22 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
22:06:22 <lambdabot>                               | otherwise = (ts, x:fs)
22:06:39 <ski> > (take 4 *** take 4) (partition even [0 ..])
22:06:41 <lambdabot>  ([0,2,4,6],[1,3,5,7])
22:07:01 <ski> that wouldn't work, if it wasn't for the `~' in the pattern in the definition of `select' above
22:12:26 <platz__> its interesting because it's only the accumulator, yet if the accumulator is strict then it demands the rest of the input
22:13:24 <platz__> i guess it's the 'take' that actually demands the input and the strict accumulators would need to be evaluated to the end
22:16:43 <platz__> actually thinking about it, for foldr, the accumulator kind of represents the remaining input considering the left-to-right evaluation and the definition of foldr
22:17:21 <platz__> foldr uses a more intuitive notion of an 'accumulator'
22:17:30 <platz__> er, i mean foldl
22:19:11 <platz__> @src take
22:19:11 <lambdabot> take n _      | n <= 0 = []
22:19:11 <lambdabot> take _ []              = []
22:19:11 <lambdabot> take n (x:xs)          = x : take (n-1) xs
22:20:28 <Zemyla_> @pl \n -> (n, 0)
22:20:28 <lambdabot> flip (,) 0
22:20:36 <platz__> so take inserts it's own [], and the initial ([],[]) from partition is never reached
22:21:25 <trap_exit> does haskell have anything like datacenter as a monad?
22:21:36 <trap_exit> i.e. I wite one haskell program, I specify strategies (like ParMonad) for how to compute stuff
22:21:47 <trap_exit> and I can use monads to encode strategies on how to distribute computation over a cluster
22:22:35 <Iceland_jack> CloudHaskell is not what you're asking but close
22:22:53 <trap_exit> yeah
22:22:53 <Iceland_jack> and GHC 7.10 will include a shim for the full version that comes in 7.12
22:22:59 <piskrist> CloudMonadsOnRails
22:23:00 <trap_exit> hmm
22:23:04 <Iceland_jack> sorry, for static function pointers
22:23:11 <Iceland_jack> that's the feature that will be included in 7.10
22:23:14 <piskrist> sounds catchy
22:23:14 <trap_exit> MonadsonClouds
22:23:27 <trap_exit> HaskellOnHeorin
22:23:30 <trap_exit> I'd use that.
22:23:32 <MP2E> hahaha
22:23:39 <piskrist> trap_exit: nice
22:24:09 <trap_exit> but you know, given purity + monads for impure stuff,
22:24:22 <trap_exit> I'd love to be able to encode parallelization strategies / distribution / concurrenty strategies as a monad of some sort
22:24:29 <trap_exit> (ala Simon's distributed+concurernt haskell book)
22:24:37 <trap_exit> and then just code on the cluster as a single computer
22:24:57 <piskrist> I think I saw some language designed specificaly for this recently
22:25:13 <trap_exit> it'd be kind of badass to do things like
22:26:19 <ski> piskrist : for `foldr', as you indicate, it's not really an accumulator in an ordinary sense. perhaps you could call it an "backwards accumulator", if you wished
22:26:22 <ski> er
22:26:23 <piskrist> I like MonadsOnClouds
22:26:24 <ski> platz__ ^
22:26:50 <MP2E> Monads On Mopeds
22:26:59 <trap_exit_> y = f x // local comptation; y <- get_new_machine $ f x // fires computation on remote machine, sends back answer
22:27:07 <trap_exit_> this would be so badass
22:27:10 <platz__> I wonder how far you could get building a different backend for Control.Concurrent but with the same api
22:27:24 <ski> Iceland_jack : "static function pointers" ?
22:27:29 <trap_exit_> I think, for decent performance, one has to do something better
22:27:55 <ski> trap_exit_ : s/impure/effectful/ :)
22:28:18 <trap_exit__> damn, haskel is goign to be my favorite langauge
22:28:19 <ski> <ski> trap_exit_ : s/impure/effectful/ :)
22:28:29 <trap_exit__> if we can build these primitives
22:28:41 <trap_exit__> I want AWS monads + Digital Ocean mondas
22:28:48 <Iceland_jack> ski: https://ghc.haskell.org/trac/ghc/wiki/StaticPointers
22:29:14 <ski> trap_exit_ : you might perhaps be interested to see how one can do distribution in Alice ML
22:29:25 <piskrist> trap_exit__: sounds cool
22:30:06 <Iceland_jack> ski: "function" was not a part of the name apparently
22:30:22 <trap_exit__> Iceland_jack : are you from Iceland ?
22:30:27 <Iceland_jack> yes I am
22:30:27 <trap_exit__> are you named Jack ?
22:30:27 <ski> Iceland_jack : ty, interesting
22:30:33 <Iceland_jack> I'm not named Jack :)
22:30:46 <ski> Iceland_jack is called Jack
22:30:49 <Iceland_jack> I got the name in Japan oddly enough
22:30:55 <ski> .. or perhaps their name is called Jack
22:31:06 <trap_exit__> ski: do you ski ?
22:31:13 * ski doesn't ski
22:31:29 <Iceland_jack> Do you trap anything these days trap_exit__? :-)
22:31:29 <trap_exit__> #haskell ... what a bunch of weirdos
22:31:39 <trap_exit__> no, but I stopped using erlang
22:31:50 <ski> trap_exit__ : it's not related to snow or ice. it's related to combinatory logic :)
22:32:17 <ski> (<http://en.wikipedia.org/wiki/SKI_combinator_calculus>)
22:32:36 <ski> (though it's not really a calculus, it's just an algebra)
22:33:02 <trap_exit__> untyped heretic!
22:33:03 <ski> (a calculus has bound variables)
22:33:04 * trap_exit__ points at ski
22:33:14 <platz__> snow/ice may just turn out to have such properties
22:33:22 <ski> combinators can be typed
22:34:31 <ski> in Haskell, one can type the combinators as `ap',`return' (or `const') and `id'
22:34:33 <trap_exit__> who here still codes > 12 hours a day ?
22:35:13 <trap_exit__> i guess no one
22:35:18 <trap_exit__> since such ppl, by definition, are not on irc
22:35:24 <Iceland_jack> This is the second time this has happened on this channel today
22:35:40 <Iceland_jack> <Koganei> Do you guys work with haskell professionally?
22:35:40 <Iceland_jack> <Koganei> guess not :o
22:36:12 <trap_exit__> well
22:36:16 <trap_exit__> I think the ahrd part is 12 hours / day, not haskell
22:36:28 <ski> (and `B' (bluebird) is `(.)', while `C' (cardinal) is `flip'. and `W' (warbler) is `join')
22:36:29 <platz__> I suspect this '12 hours' of coding does not include bathroom breaks or feeding oneself
22:36:38 <Iceland_jack> I wasn't really commenting on your claim in particular
22:36:59 <piskrist> trap_exit__: I do sometimes
22:37:59 <trap_exit__> gentlemen, work calls
22:41:53 <zzo38> Are there preprocessors or TH or whatever to implement label types in a convenient way?
22:43:00 <bryanedds> could someone give an example of using the cont monad in the do syntax?
22:43:56 <bryanedds> or, if you're willing to translate a little F#...
22:44:10 <bryanedds> could you translate this to the do syntax? -         let proc = bind (bind { Operation = pass; OptNext = None } incUserStateTwice) incUserState
22:45:00 <bryanedds> I cannot figure out how bind relates to this type of usage in either Haskell or F#'s sugar
22:45:08 <zzo38> bryanedds: I don't know F# stuff much, sorry
22:45:33 <zzo38> (Nor do I understand what it has to do with continuation monads?)
22:45:48 <bryanedds> er, well, I *think* it's related
22:45:57 <bryanedds> who knows - I'm just a kid!
22:46:14 <zzo38> Well, I don't know, because I don't know F# (if I did know, then I might know if it is related)
22:46:42 <bryanedds> no prob
22:47:22 <zzo38> What I do know is that an alternative to the "callCC" operation is "lemCC" which at least to me is a bit easier to understand; I don't know if other people do or not.
22:47:45 <bryanedds> okay, I'll take a look at that
22:49:17 <bryanedds> when I was coding > 12 hr / day, I was on IRC a lot
22:49:37 <bryanedds> mostly because I was too burnt out to actually get anything done and wasted most of my time in IRC!
22:52:13 <zzo38> Do you know about the law of excluded middle and Peirce's law?
22:52:28 <zzo38> lemCC = law of excluded middle; callCC = Peirce's law
22:52:43 <bryanedds> Okay, here's maybe an easier way to ask the question -
22:53:15 <bryanedds> In Haskell, how would I `do` sugar this - (>>=) { Operation = incUserStateTwice; OptNext = None } incUserState
22:53:30 <bryanedds> (assuming the second epxression just built a record)
22:54:05 <sinelaw> Peaker, yo
22:54:25 <sinelaw> got an annoying bug in recursive let inference
22:54:39 <zzo38> { Operation = incUserStateTwice; OptNext = None } isn't a valid value in Haskell, although if it was, it would look like this:  do { x <- { Operation = incUserStateTwice; OptNext = None }; incUserState x; }
22:56:40 <zzo38> bryanedds: Does that answer your question?
22:57:00 <bryanedds> that's so weird, becuase incUserState won't take x as a parameter
22:57:40 <bryanedds> so ya, the types are not working out that way
22:57:52 <zzo38> What exactly is the type of incUserState?
22:58:20 <bryanedds> well, would you mind if I busted out some F# code?
22:58:58 <bryanedds> hmm... may not work
22:59:27 <bryanedds> well the type of incUserState is the type of the function member in the monad
22:59:43 <bryanedds> nowhere would it take or return an actual monad value
23:00:12 <sinelaw> Peaker, bug in polymorphic recursive lets
23:00:15 <zzo38> What is "the type of the function member in the monad"? Can you show its type explicitly?
23:01:00 <bryanedds> If I were using the Cont monad directly, I think it'd be (a -> b)
23:01:19 <bryanedds> but here its ('d Event -> World -> EventHandling * World)
23:01:32 <bryanedds> (since I'm using a custom 'monad')
23:02:10 <bryanedds> the type of the monad is -
23:02:11 <bryanedds>     type [<NoEquality; NoComparison>] 'd Desync = { Operation : ('d Event -> World -> EventHandling * World); OptNext : 'd Desync option }
23:02:23 <bryanedds> but that's F#, so hard to say if it will be understood
23:02:33 <zzo38> Like I said I don't know F#
23:04:13 <zzo38> In Haskell you have to specify explicitly that it does have equality and comparison, rather than explicitly specifying that it doesn't like your example does.
23:05:14 <bryanedds> Hey, wait
23:05:20 <bryanedds> maybe the types do work out...
23:06:25 <bryanedds> nah
23:06:29 <bryanedds> god, I have no idea
23:06:37 <bryanedds> sorry, this may be a lost cause over here right now
23:06:43 * hackagebot scientific 0.3.3.3 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.3 (BasVanDijk)
23:06:45 * hackagebot egison 3.4.0 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.4.0 (SatoshiEgi)
23:08:05 <zzo38> If the monad is M and incUserState is of type (x -> M y) and whatever is to the right of "x <-" is of type (M x) then that would work. Is this understandable?
23:08:21 <zzo38> (It hasn't to do specifically with Cont monads; it is general to any monads.)
23:09:25 <bryanedds> ya, I just don't seem to understand why the types don't seem to work out for me
23:10:05 <zzo38> Well, that's F# so if you have the example exactly that you are using in Haskell, then I can see it better.
23:14:27 <zzo38> I like the ideas of the new NullaryTypeClasses and EmptyCase extensions, and MINIMAL pragma.
23:15:17 <zzo38> I also like "Template Haskell declarations, types, patterns, and untyped expressions are no longer typechecked at all."
23:15:49 <zzo38> O, and now Data.Bool.bool; that's good too.
23:16:50 <Zemyla_> Since in Haskell you can tell a pure function from an impure function, could pure functions be theoretically memoized by the compiler?
23:17:21 <zzo38> Zemyla_: I believe so.
23:17:38 <jfischoff> Yes but garbage collection is an issue
23:17:47 <zzo38> (However, there aren't actually impure functions in Haskell other than unsafe ones.)
23:17:48 <MP2E> Zemyla_: pure functions *are* generally memoized :P http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell for more info
23:17:59 <c_wraith> Zemyla_: they could be, but it's usually a pessimization
23:18:13 <c_wraith> MP2E: that's not really true.  Usually it hurts performance, so it isn't done
23:19:28 <Kaidelong> http://okmij.org/ftp/Haskell/#memo-off
23:19:42 <Kaidelong> "Preventing memoization in (AI) search problems"
23:22:30 <ReinH> MP2E: Erm. The very first thing that the top rated answer (by a GHC developer) says is "GHC does not memoize functions."
23:23:04 <MP2E> oh oops
23:23:07 <MP2E> heh
23:23:50 <Kaidelong> a kind of memoization does happen
23:24:14 <Kaidelong> if you have a thunk, it gets turned into its evaluated form in place, and may be kept around for a long time
23:26:59 <Kaidelong> I'm not sure that is any different from a strict language in the implications though unless haskell is clever enough to transform g (f x) (f x) into let y = f x in g y y
23:28:03 <Kaidelong> basically the solution that Oleg comes up with is to add an extra () as a parameter so that it is treated as a function, and not a value, and thus not "implicitly" memoized
23:28:45 <zzo38> That doesn't looks very mathematically elegant to me.
23:29:01 <thebnq> thats essentially how you make thunks in strict fp
23:29:06 <zzo38> It looks to me like using pragmas might be a better way to implement such things into the system?
23:29:52 <Kaidelong> anyway although haskell doesn't automatically memoize functions lazy evaluation confounds the issues because it will memoize values that you are actually using like functions, and may not want memoized
23:30:32 <Kaidelong> explicitly turning them back into functions prevents this
23:32:49 <bryanedds> Can anyone tell me the definition on Cont's >>= or where to find it?
23:33:03 <bryanedds> I can't find the source for it.
23:33:17 <Kaidelong> @src ContT.(>>=)
23:33:17 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
23:33:30 <Kaidelong> okay well off to hackage
23:33:37 <Iceland_jack> Or are you?
23:33:38 <Iceland_jack> @src ContT (>>=)
23:33:38 <lambdabot> m >>= k = ContT $ \c -> runContT m (\a -> runContT (k a) c)
23:33:40 <Kaidelong> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
23:34:14 <bryanedds> @src Cont.runContT
23:34:14 <lambdabot> Source not found. I feel much better now.
23:34:19 <bryanedds> heh
23:34:26 <bryanedds> @src Cont runContT
23:34:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:34:45 <Kaidelong> it's probably just a newtype accessor
23:34:50 <Iceland_jack> Yes
23:34:52 <Kaidelong> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
23:38:32 <piki339> Hello friends, i'm new in hkll, i wanna ask, when i define a function like --    ( my_add a b = a + b ) i get this error ( <interactive>:73:9: parse error on input `=' ) but when i write ( let my_add a b = a + b ) i don't get the error. Some help please ?
23:39:10 <Iceland_jack> piki339: You can use "let"
23:39:12 <Kaidelong> GHCi needs you to put "let" in front of that
23:39:22 <Iceland_jack>     ghci> let my_add a b = a + b
23:39:22 <Iceland_jack>     ghci> my_add 15 3
23:39:22 <Iceland_jack>     18
23:39:25 <Kaidelong> GHCi is analogous to being inside of the IO monad, so you need the same syntax
23:39:33 <Kaidelong> (not exactly the same, but close)
23:39:45 <Iceland_jack> If they don't know how to define things in GHCi that may not help :-)
23:40:21 <piki339> but when i'm trying to define this (  my_add :: [Num] -> [Num]    )
23:40:24 <piki339> i get an error
23:40:41 <piki339> and if i write let my_add :: [Num] -> [Num]   i get an error too
23:40:42 <piki339> :(
23:40:55 <Iceland_jack> piki339: You can do:
23:40:55 <Iceland_jack>     ghci> let my_add :: [Int] -> [Int]; my_add a b = a + b
23:41:05 <Iceland_jack> or alternatively define it in a file and load that file with GHCi
23:41:35 <Iceland_jack> Make a file /tmp/test.hs that contains:
23:41:35 <Iceland_jack>     my_add :: [Int] -> [Int]
23:41:35 <Iceland_jack>     my_add a b = a + b
23:41:35 <Iceland_jack> and load it in GHCi with ':load /tmp/test.hs'
23:41:50 <piki339> Oh I see
23:41:50 <Iceland_jack>     ghci> :load /tmp/test.hs
23:41:50 <Iceland_jack>     ghci> my_add 20 5
23:41:50 <Iceland_jack>     25
23:41:54 <piki339> thanks dude!
23:42:00 <Iceland_jack> You're welcome
23:45:29 <Zemyla> What is !!!?
