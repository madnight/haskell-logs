00:08:36 * hackagebot hspec-test-sandbox 0.1.0 - Hspec convenience functions for use with test-sandbox  http://hackage.haskell.org/package/hspec-test-sandbox-0.1.0 (junjihashimoto)
00:08:36 * hackagebot stackage 0.3.0.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.3.0.1 (MichaelSnoyman)
01:41:36 <rhaps0dy> d'aaw
01:41:38 <rhaps0dy> thank you lambdabot
01:41:42 <rhaps0dy> merry christmas everyone!
01:42:16 <jiang42> aha, merry christmas~
01:43:39 <zq> (:
01:43:52 <zq> wait till you see how i did it, hah
01:46:06 <MagneticDuck> > 'M':'e':'r':'r':'y':' ':'C':'h':'r':'i':'s':'t':'m':'a':'s':[]
01:46:07 <lambdabot>  "Merry Christmas"
01:46:34 <rhaps0dy> elaborate
01:46:50 <MagneticDuck> > let f = (intercalate ":" . (++["[]"]) . map show) in putStrLn . f . f $ "Merry Christmas"
01:46:51 <lambdabot>  <IO ()>
01:46:57 <MagneticDuck> > let f = (intercalate ":" . (++["[]"]) . map show) in f . f $ "Merry Christmas"
01:46:59 <lambdabot>  "'\\'':'M':'\\'':':':'\\'':'e':'\\'':':':'\\'':'r':'\\'':':':'\\'':'r':'\\''...
01:47:15 <MagneticDuck> goooo haskell
01:47:50 <yonoid> I could use a hand with some functional programming basics here
01:48:33 <MagneticDuck> sadly all we do here is talk about lambda calculus
01:48:50 <MagneticDuck> and haskell sometimes
01:49:09 <Cale> lol, what?
01:49:11 <Cale> heh
01:49:18 <yonoid> That's pretty interesting, but I would like to get my XMonad working first
01:49:21 <yonoid> screenWorkspace :: ScreenId -> X (Maybe WorkspaceId)
01:49:21 <Cale> yonoid: Well, what do you need help with?
01:49:25 <Cale> okay
01:49:48 <yonoid> SUppose I use (screenWorkspace 1)
01:50:01 <MagneticDuck> then you have a X (Maybe WorkspaceId)
01:50:05 <yonoid> I'm trying to convert the expression to just the workspaceId
01:50:22 <MagneticDuck> right, but your problem is: you have it encapsulated in an X and in a Maybe
01:50:33 <MagneticDuck> both of those things mean you can't just take the workspace id from it cleanly
01:50:41 <yonoid> No eh?
01:50:47 <Cale> So, you'll want to, inside a do block for some other X action, write something like  mWID <- screenWorkspace 1
01:50:48 <MagneticDuck> just look at the Maybe
01:50:54 <MagneticDuck> the Maybe means that it may or may not exist
01:51:07 <Cale> which means "run the X action (screenWorkspace 1) and call its result mWID"
01:51:31 <MagneticDuck> and then you need to cover two cases: mWID being Just <your value> or Nothing
01:51:32 <Cale> and then you want to inspect the Maybe WorkspaceId value you got, which you might do with a case expression:
01:51:36 <Cale> case mWID of
01:51:36 <yonoid> I see, I gotta use the Maybe
01:51:40 <Cale>   Nothing -> ...
01:51:45 <rhaps0dy> > (map snd . sort) [(1,'M'),(2,'e'),(3,'r'),(4,'r'),(5,'y'),(6,' '),(7,'C'),(8,'h'),(9,'r'),(10,'i'),(11,'s'),(12,'t'),(13,'m'),(14,'a'),(15,'s'),(16,'!')]
01:51:46 <lambdabot>  "Merry Christmas!"
01:51:46 <Cale>   Just wid -> ...
01:51:46 <yonoid> Let me try that
01:52:07 <MagneticDuck> rhaps0dy: oooh it's on
01:52:23 <rhaps0dy> MagneticDuck: :)
01:52:26 <MagneticDuck> hm, if we had two lambdabots here....
01:52:34 <rhaps0dy> hello MagneticDuck
01:52:37 <rhaps0dy> mmmm *
01:52:40 <MagneticDuck> wait, darn, lambdabot adds a space to its result
01:52:41 <rhaps0dy> goddamnit m<tab>
01:52:48 <MagneticDuck> presumably so the result isn't interpreted by another bot
01:52:50 <rhaps0dy> MagneticDuck: wait, really
01:52:59 <rhaps0dy> you mean to make a bot fight?
01:53:06 <MagneticDuck> you know, you can do amazing things with two bots where one supports evaluation of a turing-complete language
01:53:08 <Cale> yonoid: the idea being that you'll get Nothing in the case that for some reason no workspace is visible on screen 1.
01:53:15 <rhaps0dy> that is ILLEGAL in freenode
01:53:15 <MagneticDuck> you can use quines to make... dun dun dun... infinite bot conversations
01:53:17 <rhaps0dy> but it's cool
01:53:20 <rhaps0dy> MagneticDuck: wow.
01:53:24 <MagneticDuck> I did it once
01:53:30 <rhaps0dy> I used something much simpler
01:53:44 <rhaps0dy> in another channel I was in, there were two bots
01:53:55 <rhaps0dy> one posted the HTML title every time an HTTP link was posted
01:54:01 <Cale> yonoid: If you want a convenient way to "do nothing" there, you can use the X action return (), which is a no-op action which always returns () as its result when executed.
01:54:12 <rhaps0dy> and the other repeated words when you said @doge <something>
01:54:22 <rhaps0dy> it said something along the lines of "much something, wow"
01:54:33 <rhaps0dy> so if you posted an http link that had as title @doge <the link>
01:54:35 <Cale> (similarly, return v is the action which does nothing except to, well, return v)
01:54:35 <MagneticDuck> lol Cale's efforts to answer a question pertinant to #haskell is eclipsed by us talking about infinite bot quines
01:54:41 <MagneticDuck> #haskell-blah gogo
01:54:46 <rhaps0dy> s-sorry
01:54:50 <Cale> yeah, thanks :)
01:56:42 <Cale> yonoid: Are you generally fairly clear on how do-notation works? I know that configuring xmonad is sometimes people's first exposure to Haskell, so it can be a bit daunting to really understand what's going on there.
01:58:25 <MagneticDuck> as nobody never said, the best way to jump into haskell is via trying to code yourself a window manager configuration in a huge daunting library written by experienced haskellers
02:00:22 <rhaps0dy> you're not serious are you?
02:01:06 <yonoid> Yeah, not the best way to get started with such a specific librar0
02:01:16 <yonoid> buy I want XMonad now
02:02:07 <rhaps0dy> configuration too bothersome
02:02:15 <rhaps0dy> I have no idea, if you get it working maybe you could share :)
02:02:22 <yonoid> Well, today i read ch 01-03 of Real World Haskell, go me
02:02:33 <rhaps0dy> good :)
02:02:45 <yonoid> Here is the expression I tried
02:02:51 <yonoid> appendFile "/tmp/myxmonad.log" (sw <- screenWorkspace 1)
02:03:01 <yonoid> Not what you guys had in mind I guess
02:05:11 <yonoid> Guys, anyone know what brain distortion I'm suffering from in the appendFile above?
02:07:02 <rhaps0dy> yonoid, no, sorry, I have no idea how to use xmonad ;-;
02:08:05 <yonoid> No worries, #xmonad is sleeping so I'm poking ppl here
02:08:40 <yonoid> Cale that's some good info, maybe I should continue the book
02:09:29 <Cale> yonoid: do sw <- screenWorkspace 1; appendFile "/tmp/myxmonad.log" (show sw)
02:11:37 <Cale> yonoid: The type of screenWorkspace 1 is X (Maybe WorkspaceId). A value of type (X t) for some type t is like a program which if you were to run it, would produce a value of type t as its result. You can only run X actions inside other X actions (not quite true, but true enough for an xmonad user, I'm pretty sure), and to compose longer X actions, you can use do notation
02:12:40 <Cale> yonoid: So, inside of a do-block, something of the form  v <- x  means "execute the action X, and whatever its result is, call that v", and just x on its own on a line (semicolon separated if you don't put them on multiple lines) will mean to execute x and discard the result
02:13:18 <Cale> The do-block as a whole becomes an X action, and the result of that action is the result of the action on the last line.
02:14:23 <Cale> So, a value of type X String for instance isn't usable as a String, any more than /bin/ls is usable as a list of files -- you have to run it first to get the result, and then use that in a subsequent action somehow.
02:15:29 <Cale> v <- x  means "execute the action x, and whatever its result is, call that v"
02:15:37 <Cale> sorry about the typo above, capitalisation error
02:16:55 <Cale> yonoid: In this case, we have screenWorkspace 1 :: X (Maybe WorkspaceId), and so in the do-block:  do sw <- screenWorkspace 1; ...  we'll have sw :: Maybe WorkspaceId
02:17:38 <Cale> and the do-block as a whole will have type (X t) for some t
02:17:47 <yonoid> Thanks it's starting to making sense
02:18:04 <Cale> I don't know if there's an appendFile for the X monad, let me check. I'm pretty sure we could use the one for IO, but I'll have to look...
02:18:11 <Cale> (I'm not an xmonad user)
02:18:16 <yonoid> It's the one from IO
02:18:44 <Cale> Right, so there's this function provided:  io :: IO a -> X a
02:18:59 <Cale> which will let you turn an IO action into an X action
02:19:19 <Cale> do sw <- screenWorkspace 1; io (appendFile "/tmp/myxmonad.log" (show sw))
02:19:46 <Cale> so probably something like that will work, and the whole do-block will have type  X ()
02:20:22 <yonoid> What I'm trying, almost in full, is
02:20:35 <yonoid> ((modMask x, xK_space), liftIO (do sw <- screenWorkspace 1; appendFile "/tmp/myxmonad.log" (show sw)))
02:20:46 <Cale> oh, okay, you don't want the liftIO there
02:21:01 <Cale> you want the liftIO to go just on the appendFile
02:21:05 <yonoid> Where the type is
02:21:07 <yonoid> keys :: !(XConfig Layout -> Map (ButtonMask, KeySym) (X ()))
02:21:19 <yonoid> Yeah
02:21:29 <yonoid> My home made debugger hahaha
02:21:31 <rhaps0dy> yonoid: if you have any luck, please share your configuration :)
02:21:35 <Cale> (io is another name for liftIO)
02:24:52 <Cale> The difference between X and IO is that X actions have implicit access to the configuration and state of xmonad, and there's a library of X actions for manipulating that stuff, while IO actions don't.
02:25:35 <Cale> yonoid: Still having trouble? If you want, you can paste the file and the error you're currently getting on lpaste.net and I'll have a closer look
02:26:41 <yonoid> Awesome!!! It works, I get Just "1", Just "2", and Nothing on 0,1,2
02:26:50 <Cale> cool
02:26:52 <yonoid> Thanks Cale
02:27:00 <yonoid> that was very educational
02:27:18 <yonoid> The key for me is definitely what you said about /bin/ls
02:27:23 <Cale> yeah
02:27:26 <yonoid> and do-notation
02:28:28 <yonoid> rhaps0dy, right now my config is just from http://www.nepherte.be/step-by-step-configuration-of-xmonad/
02:29:06 <yonoid> But now I know how to output API results to a log file
02:29:30 <yonoid> Should be easy to troubleshoot what I'm thinking now
02:29:53 <yonoid> This was a huge step, thanks again Cale!!
02:31:08 <yonoid> This is the binding that worked for me
02:31:10 <yonoid> ((modMask x, xK_space), do sw <- screenWorkspace 2; liftIO (appendFile "/tmp/myxmonad.log" (show sw)))
02:33:36 * hackagebot cantor 0.4 - Application for analysis of java source code  http://hackage.haskell.org/package/cantor-0.4 (klangner)
02:34:30 <brainacid> Good morning
02:34:33 <brainacid> merry xmas
02:34:50 <Cale> yonoid: Yeah, it's really cool how these actions are values, so that you can stash them in data structures and pass them around between functions without worrying about whether they execute before you want them to.
02:35:08 <Cale> yonoid: and that's what the keymapping you have going there is doing as well
02:36:41 <Cale> yonoid: If there weren't a distinction between an X action and its result, then your keybinding might fire at the time that xmonad was starting up and then never again or something, but since there is, it can carefully pull these X action values out later and execute them when needed.
02:40:05 <yonoid> Very cool!  I can go to sleep finally... Merry xmas everybody! Haev a good one Cale, will save your comments!
02:41:06 <brainacid> Hey Cale
02:54:46 <Black-Heaven> Hi all, is there a way to parameterize a datatype with a Constraint kind? I have tried this but it fails to compile: http://lpaste.net/117215 Thanks in advance for your help.
02:59:09 <Cale> brainacid: Oh, hi :)
02:59:56 <Cale> Black-Heaven: What's the error message you get?
03:00:07 <Cale> Do you need to turn on GADTs?
03:01:31 <brainacid> Hey Cale see you helped me plenty
03:02:14 <lpaste> brainacid revised “ExerciseCalc”: “v1.5” at http://lpaste.net/117190
03:08:57 <Black-Heaven> Cale: constraint.hs:12:57: Not in scope: type variable ‘c’
03:31:36 <kqr> hey awesome people! name an operator that is not infixl/infixr please
03:32:08 <_um> -
03:32:41 <_um> Or I guess that is also infix...
03:32:58 <kqr> infix is okay
03:33:00 <_um> How about ()
03:33:01 <kqr> just not infixr/infixl
03:33:04 <MP2E> (->) (=>) ?
03:33:14 <_um> I'm just looking here: http://www.imada.sdu.dk/~rolf/Edu/DM22/F06/haskell-operatorer.pdf
03:33:19 <MP2E> question mark at the end isn't an operator more 'are these operators?'
03:33:44 <kqr> those are type-level operators in some sense, I guess, but (->) is infixr or whatever it is
03:33:46 <kqr> so does not qualify
03:33:49 <MP2E> ah
03:33:58 <kqr> i'm looking for an expression where a * b * c will yield a syntax error
03:35:01 <supki> kqr: ==
03:35:26 <kqr> supki, thanks! i'm silly. it even arose in a discussion about == :D
03:53:39 * hackagebot hydrogen-cli-args 0.10 - Hydrogen Command Line Arguments Parser  http://hackage.haskell.org/package/hydrogen-cli-args-0.10 (JulianFleischer)
04:18:40 * hackagebot hydrogen-syntax 0.10 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.10 (JulianFleischer)
04:18:42 * hackagebot hydrogen-data 0.10 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.10 (JulianFleischer)
04:19:20 <alephnull> I'm in trouble with lambda calculus pls help me: is n f x= f(f(...f x...))(composed n times) is really lambda term?
04:20:10 <Hafydd> Are you asking whether n f x = f^n(x), or if f^n(x) is a lambda term?
04:20:59 <Hafydd> If n is a Church numeral, then the answer to both questions is "yes".
04:21:30 <Arcaedox> Hi there , can I have some help ?
04:24:11 <Hafydd> Of course, "f^n(x)" isn't strictly a sentence from the grammar of lambda-terms, but for each natural n it does represent one: f^0(x) represents "x", f^1(x) represents (f x), f^2(x) represents (f (f x)), etc.
04:25:08 <alephnull> Thx
04:26:24 <bennofs> Arcaedox: sure, just ask your question / describe your problem :)
04:39:32 <osa1> are we going to have this in next GHC https://ghc.haskell.org/trac/ghc/ticket/9224 ?
04:47:44 <Taneb> osa1, I believe so
04:50:24 <Merlin`> hello
04:50:41 <Merlin`> http://lpaste.net/117225
04:51:04 <Merlin`> I would like to handle inner parenthesis as well.. so parse text "" "(hello (hello) world)"  should give me "hello (hello) world"
04:51:05 <brainacid> hi Merlin`
04:51:09 <Merlin`> how would I do that?
04:51:23 <Merlin`> hi brainacid
04:52:44 <brainacid> oops
04:52:57 <zipper> Say I wanted to contribute some simple and straightforward fix to haddock on which branch should I create a pull request?
04:54:48 <brainacid> so you want to remove the () Merlin`
04:55:10 <Merlin`> I want to parse text inside (), but I want it to handle inner parenthesis as well
04:56:35 <Merlin`> "(hello (hello) world)" should be parsed as "hello (hello) world" not "hello (hello"
04:57:54 <Merlin`> in this case just removing outter () would work yeah, but this is part of a more complex parser. so I need Parsec solution
04:59:05 <moop> > let map fizzbuzz [1..10] in fizzbuzz a = | a `mod` 3 == 0 = "fizz" | a `mod` 5 == 0 = "buzz" | a `mod` 3 == 0 && a `mod` 5 == 0 = "fizzbuzz | otherwise = show a
04:59:07 <lambdabot>  <hint>:1:26: parse error on input ‘in’
04:59:27 <moop> hmhm
04:59:40 <moop> > let map fizzbuzz [1..10] in fizzbuzz a = | a `mod` 3 == 0 = "fizz" | a `mod` 5 == 0 = "buzz" | a `mod` 3 == 0 && a `mod` 5 == 0 = "fizzbuzz" | otherwise = show a
04:59:42 <lambdabot>  <hint>:1:26: parse error on input ‘in’
05:05:47 <BillyIII> it should be let fizzbuzz=.. in map fizzbuzz
05:06:43 <moop> oh, i see
05:07:08 <exio4> also, you don't use "=" and "|"
05:08:36 <exio4> and, the "a && b" clause won't ever run, because of the order of the operations
05:08:47 <moop> yeah, need to do it first
05:11:38 <jiang42> is there any more elegant way to do fizzbuzz in Haskell?
05:13:37 <Merlin`> not sure about more elegant, but defining divBy function first makes fizzbuzz cleaner and more concise
05:13:58 <Merlin`> divBy d x = mod x d == 0
05:14:48 <BillyIII> hayoo and hoogle dont know about such function oO
05:15:11 <Merlin`> which is why I defined it above :)
05:15:46 <BillyIII> ah, sorry
05:15:54 <moop> what is exactly the problem here? http://ideone.com/V26Hgd
05:15:56 <Merlin`> that's ok
05:16:27 <moop> :t map
05:16:28 <lambdabot> (a -> b) -> [a] -> [b]
05:16:44 <moop> :t unlines
05:16:45 <lambdabot> [String] -> String
05:17:21 <Merlin`> type :t map fizzbuzz  in ghci
05:17:35 <Merlin`> oh no
05:17:58 <Merlin`> use $ instead of .
05:18:17 <Merlin`> or:  main = (putStrLn . unlines . map fizzbuzz) [1..10]
05:18:31 <moop> http://ideone.com/FWogw7
05:18:34 <moop> ooh i see
05:18:48 <moop> putStrLn . unlines $ map fizzbuzz [1..10]
05:18:50 <Merlin`> or I guess main = putStrLn . unlines . map fizzbuzz $ [1..10]
05:18:55 <Merlin`> if you dislike parenthesis
05:18:57 <Merlin`> that works too
05:19:17 <Merlin`> and use [1..] instead of [1..10] for extra fun
05:19:31 <moop> don't want infinities
05:19:38 <moop> they're scary
05:19:39 <Merlin`> :(
05:19:47 <exio4> they aren't!
05:20:18 <exio4> they are a beautiful!
05:21:56 <sinelaw> > [1..3]          :: [Data.Fixed.Fixed E12]
05:21:57 <lambdabot>  [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004,...
05:22:42 <moop> wheee
05:22:49 <BillyIII> > "test"
05:22:49 <jiang42> they are beautiful with take, aha
05:22:50 <lambdabot>  "test"
05:23:05 <moop> > "rm -rf /"
05:23:06 <lambdabot>  "rm -rf /"
05:23:09 <moop> rip lambdabot
05:23:55 <BillyIII> > System.IO.Unsafe.unsafePerformIO $ print 1
05:23:57 <lambdabot>  Not in scope: ‘System.IO.Unsafe.unsafePerformIO’
05:24:11 <BillyIII> > unsafePerformIO $ print 1
05:24:13 <lambdabot>  Not in scope: ‘unsafePerformIO’
05:24:15 <BillyIII> :(
05:24:31 <jiang42> in fact, I think parenthesis are also beautiful, make program easy to read
05:24:37 <kaiyin> What is the path for haskell packages on OS X? LEKSAH is asking for it.
05:24:50 <Merlin`> BillyIII not that easy to break it :)
05:24:56 <sinelaw> > take 2 [1..3]          :: [Data.Fixed.Fixed E12]
05:24:58 <lambdabot>  [1.000000000000,1.000000000001]
05:25:03 <sinelaw> not what you expect! :)
05:25:24 <jiang42> "/Library/Haskell/"
05:25:48 <kaiyin> thanks
05:25:56 <jiang42> and ~/Library/Haskell/
05:27:45 <kaiyin> > take 3 [1..]
05:27:46 <lambdabot>  [1,2,3]
05:27:53 <kaiyin> > take 3 [1..3]
05:27:54 <lambdabot>  [1,2,3]
05:28:31 <jiang42> kaiyin shows how to use infinity the right way :)
05:29:14 <kaiyin> lambdabot looks awesome. :)
05:30:12 <moop> > "<?php echo \"Look at me, I'm php!\"; ?>"
05:30:13 <lambdabot>  "<?php echo \"Look at me, I'm php!\"; ?>"
05:30:24 <moop> eh eh eh
05:31:32 <jiang42> where is the user guide of lambdabot? it looks pretty good!
05:32:04 <jiang42> and i want to learn more about it
05:33:13 <srhb> jiang42: There isn't really a good user guide. Best bet is probably to read the source.
05:34:42 <jiang42> can u give me a link to the source?
05:35:09 <sivteck> @version
05:35:09 <lambdabot> lambdabot 5.0-int-e
05:35:09 <lambdabot> git clone git://github.com/int-e/lambdabot.git
05:35:20 <jiang42> thx
05:37:51 <BillyIII> @list
05:37:51 <lambdabot> What module?  Try @listmodules for some ideas.
05:37:56 <BillyIII> @listmodules
05:37:56 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:44:20 <BillyIII> src print
05:44:26 <BillyIII> @src print
05:44:27 <lambdabot> print x = putStrLn (show x)
05:45:18 <Merlin`> @pl print x = putStrLn (show x)
05:45:18 <lambdabot> print = putStrLn . show
05:46:24 <Merlin`> there is a cool lambdabot feature, that attempts to write code based on the function signature. but I forgot how it works
05:46:48 <matematikaadit> Merlin`: @djinn
05:47:08 <Merlin`> @djinn (a, b) -> a
05:47:09 <BillyIII> @free a -> a
05:47:09 <lambdabot> f (a, _) = a
05:47:09 <lambdabot> Extra stuff at end of line
05:47:10 <matematikaadit> @@ Merlin` @djinn f :: a -> a
05:47:10 <lambdabot>  Merlin` Cannot parse command
05:47:28 <matematikaadit> @djinn a -> a
05:47:28 <lambdabot> f a = a
05:47:29 <Merlin`> @djinn (a, b) -> a
05:47:29 <lambdabot> f (a, _) = a
05:48:18 <BillyIII> @djinn (Show a) => a -> String
05:48:18 <lambdabot> Error: Undefined type String
05:48:25 <BillyIII> @djinn (Show a) => a -> [Char]
05:48:26 <lambdabot> Error: Undefined type []
05:49:42 <Merlin`> it supports a subset of haskell types, to avoid ambiguity
05:49:44 <hexagoxel> :exf Show a => a -> String
05:49:44 <exferenceBot> show
05:50:34 <Merlin`> ignoring bottom a function with type  (a, b) -> a   can only do one thing
05:51:48 <supki> :t \(a, b) -> b `seq` a
05:51:49 <lambdabot> (t, t1) -> t
05:52:10 <kish> what does that do
05:53:03 <Merlin`> only one /reasonable/ thing
05:54:01 <indiagreen> supki's thing seems reasonable
05:54:21 <Merlin`> I don't see how strictness is reasonable for fst
05:54:32 <Merlin`> strictness for the second tuple element
05:54:55 <indiagreen> it's just uncurried “seq”
05:55:15 <indiagreen> maybe supki is writing a version of standard library where all functions are uncurried
05:56:29 <Merlin`> no, he (and you) are being a pedantic asshats
05:56:35 <Merlin`> that's all
05:57:16 <indiagreen> to be honest, I'm only doing this 'cause previously I was sure that “ignoring bottom” was pretty asshat-proof
05:57:27 <indiagreen> and now supki showed a nice counterexample
05:57:41 <exio4> if you ignore bottom, you've got a total programming language, haven't you?
05:58:06 <Procian> Merlin`: djinn.
05:58:19 <exio4> and if you have a total PL, then it wouldn't matter if you evaluate using strict or lazy evaluation?
05:58:22 <Procian> Merlin`: Alternatively, it's a theorem prover for intuitionistic propositional logic.
05:58:36 <wei2912> lol
05:59:58 <indiagreen> exio4: okay, but betcha many people would argue “can only do one thing” isn't the same as “can only return one possible result”
06:00:29 <indiagreen> not even “argue”, actually, but straightforwardly assume
06:01:25 <Procian> fst is the best definition of (a,b) -> a.
06:02:17 <jesyspa> Isn't \(a, b) -> b `seq` a equal to \(a, _) -> a up to bottom, anyway?
06:03:02 <exio4> if we ignore bottoms, haskell is lovely, if you don't, then you can't do anything with it
06:06:24 <johnnny> is applicative is just like a functor except it can apply function in a context to a value in a context?
06:06:44 <johnnny> whereas a functor can only apply a function to a boxed value
06:12:24 <kaiyin> Anyone knows how to comment out selected code in FP haskell centre?
06:15:54 <matematikaadit> johnnny: well, that would be 'yes'
06:18:39 <johnnny> doesnt seem vey useful
06:18:55 <johnnny> especially when we already had Monad
06:23:39 <jesyspa> johnnny: Monad is strictly more powerful than Applicative, but not every applicative can be made into a monad, and IIRC, there is some static analysis you can do on applicatives that you can't do on monads.
06:23:46 <jesyspa> (Precisely because applicatives are less powerful.)
06:27:32 <johnnny>  what is an example of applicative that isnt a monad?
06:27:38 <sinelaw> jesyspa, I think you can find parallelism, no?
06:28:12 <sinelaw> never mind.
06:28:19 <jesyspa> sinelaw: That could be; I don't remember exactly, just that there were parsing libraries that were intentionally only Applicative.
06:29:40 <jesyspa> johnnny: http://stackoverflow.com/a/7220548/559931
06:31:27 <jesyspa> Oh, although I like the answer by pigworker more.
06:32:59 <Procian> johnnny: ZipList is a common example of an applicative.
06:33:24 <Procian> zipWith is liftA2.
06:33:38 <Procian> (after wrapping)
06:35:53 <mewab> I read that the dollar hint of hlint is really popular here
06:36:09 <mewab> Can anyone explain why is a $ b $ c d
06:36:12 <mewab> better than
06:36:26 <mewab> a . b $ c d
06:37:01 <mewab> I would've compared 'a $ b $ c $ d' with 'a . b . c $ d' but I see no reason why to add unneccessary chars
06:37:03 <dutchie> uniformity makes it easier to read imo
06:37:19 <mewab> doesn't the option with only $ signs more uniform than the one with both . and $ signs?
06:37:23 <ab9rf> i think it depends on what a and b are
06:37:38 <dutchie> yes, that's what I meant
06:37:39 <exio4> I prefer (.) when you can use it
06:37:53 <johnnny> does anyone feel all these abstractions are the functional equivalent of OOP lassagna code?
06:38:09 <mewab> I want to prefer the . over $, but I really prefer the $ as it's more uniform
06:38:10 <ab9rf> johnnny: but i like melted cheese
06:38:29 <mewab> why is a . b . c . d . e $ f g
06:38:36 <mewab> better than a $ b $ c $ d $ e $ f g
06:38:46 * hackagebot hydrogen-version 1.3 - Hydrogen Version Type  http://hackage.haskell.org/package/hydrogen-version-1.3 (JulianFleischer)
06:39:04 <voidzero> "better"?
06:39:11 <CindyLinz> I like a $ b $ c $ d $ e $ f g more than a . b . c . d . e $ f g
06:39:13 <Procian> johnnny: Which ones?
06:39:14 <mewab> I'm not looking to argue, I want to be convinced that the dot notation is better because that's why I see is used more often
06:39:32 <mewab> that's *what* I see is used more often
06:39:44 <mewab> I think like CindyLinz and dutchie
06:39:45 <johnnny> Procian: functor, applicative, monad, arrows..
06:39:47 <exio4> (.) has nicer properties, like associativity and is easier to factor out, too
06:40:09 <mewab> That's an interesting thought exio4, didn't think of that
06:40:41 <exio4> if you have f = a . b . c; you can get a g = b . c and then do f = a . g; and what not
06:40:47 <mewab> But I can always move to dot notation when I'm factoring out
06:41:18 <mewab> You're right exio4
06:41:37 <Procian> johnnny: Ah, probably not then. I'm not sure why I'd compare those to lasagna code.
06:42:59 <johnnny> Procian: just seems like a lot of needless abstractions to me
06:43:06 <ij> Then don't use them.
06:43:17 <johnnny> that does not work
06:43:38 <Procian> johnnny: It cuts down on duplication.
06:44:19 <Procian> Admittedly, it's a bit too late in the game now for some functions now.
06:44:27 <Procian> Too many nows.
06:44:37 <johnnny> Procian: but is all that complexity worth it just to have a generic sequence and other functions? I mean a lot of people gave up on haskell because they couldnt grook monads
06:44:47 <exio4> johnnny, you can write most of your code without using those abstractions, but you'll end with lots of needless boilerplate
06:45:17 <Procian> Most languages have abstract libraries for dealing with collections.
06:47:15 <Procian> johnnny: I don't see abstraction in this case as about introducing complexity, though. This sort of abstraction simplifies, because now my brain doesn't need to contain as many specific ideas.
06:48:15 <exio4> and you also can have functions like mapM, which are really useful
06:48:18 <exio4> @type mapM
06:48:19 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:48:29 <exio4> @type T.mapM
06:48:30 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:51:22 <Procian> exio4: I'd say those functions are the point of the abstraction.
06:52:08 <Procian> It's why I'm sceptical of talking about them in something like F#.
06:52:19 <nkar> are there any libs besides dataenc and mime-string for working with quoted-printable?
06:53:23 <johnnny> Procian: F# has those abstractions, but without generic functions like sequence?
06:54:22 <exio4> but functions like those are the ones that make the abstraction powerful!
06:57:21 <Procian> johnnny: I'd rather say that it doesn't have the abstractions at all, precisely because it doesn't have those generic functions.
06:58:47 * hackagebot diagrams-cairo 1.2.0.5 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.5 (bergey)
07:00:17 <Procian> johnnny: But some Fsharpers still talk as if they've got monads.
07:00:46 <Procian> Same thing happens in Ocaml, which is perfectly capable of providing all those generic functions, but they tend not to be used.
07:01:47 <Procian> Instead, you have libraries like lwt talking about providing a monad but defining all these functions for that one specific monad (and sometimes butchering the definition, because it's harder when you're stuck in specifics).
07:03:00 <johnnny> i am not even sure i want monads for things other than IO
07:03:51 <johnnny> for example i would rather use concatMap than >>= for lists. or list comprehensions instead of do
07:04:00 <BasDirks> That's like saying you don't want coke for things other than party's
07:04:23 <Procian> johnnny: When you're messing with do-notation for lists, you're thinking about writing non-deterministic programs.
07:04:30 <johnnny> who drinks coke at s party?
07:04:32 <Procian> And sometimes, that's exactly what you want.
07:05:05 <ReinH> johnnny: Do you plan on parsing anything?
07:05:16 <johnnny> Procian: dont know..
07:05:18 <ReinH> Or managing state?
07:05:54 <johnnny> ReinH: yes
07:06:10 <ReinH> johnnny: Then you'll want to use monads
07:06:59 <ReinH> The Monad typeclass is not hard to use. It consists of two methods.
07:07:07 <johnnny> only because those libraries offer monadic interface
07:07:18 <ReinH> johnnny: Why do you think they offer monadic interfaces?
07:07:43 <ReinH> It's not like they just picked Monad at random
07:07:55 <sinelaw> Gone through all the Haskell Casts. any recommendations for similar stuff?
07:08:11 <ReinH> sinelaw: my coworker is doing a type theory podcast
07:08:21 <ReinH> sinelaw: I hope you enjoyed the haskell cast :)
07:08:27 <johnnny> for the same reason OOP programmers use classes for everything..
07:08:36 <sinelaw> ReinH, I loved it. Are you involved in that?
07:08:41 <ReinH> sinelaw: Yes.
07:08:45 <ReinH> I'm one of the hosts
07:08:52 <ReinH> And yay :)
07:09:06 <sinelaw> oh wow, I didn't realize!
07:09:16 <ReinH> johnnny: which is?
07:09:17 <sinelaw> ReinH, thanks for doing it! keep going :)
07:09:22 <ReinH> sinelaw: thanks :)
07:09:59 <johnnny> ReinH: every problem looks like a nail
07:10:02 <sinelaw> ReinH, where's the type theory podcast?
07:10:44 <Procian> johnnny: It's not quite so trivial as a class. In OOP, everything is a class. Even in Haskell, monads are pretty rare.
07:10:47 <ReinH> johnnny: It's almost as if reasoning about the sequencing of "effects" or "computations" is an important part of computer science...
07:11:26 <yonoid> exit
07:11:28 <ReinH> When your hammer is "a powerful way to reason about computation", then I suppose lots of things in computer science *do* look like nails
07:21:15 <sinelaw> ReinH, is it this? http://typetheorypodcast.com/
07:21:35 <ReinH> sinelaw: Oh. Yes, sorry.
07:21:52 <sinelaw> No worries
07:22:05 <brainacid> Hello all
07:22:10 <brainacid> I feel so good
07:22:26 <brainacid> Im learning Haskell...Im just enjoying the process so much
07:23:09 <brainacid> i read you guys convo and so many things i dunno yet lol... and since i run xmonad its such a bright future lol
07:23:47 <brainacid> just wish I could see workspace number and title of focused window in my xmobar
07:24:31 <obiwahn> How about brainpower oder brainpowder:P
07:24:40 <obiwahn> or
07:24:46 <simon> brainacid, I thought xmonad did that by default. I'm sure you can find the config snippets to make that happen. :)
07:24:56 <simon> brainacid, err, s/xmonad/xmobar/
07:25:12 <brainacid> simon, I have searched the net pretty deep for it
07:25:36 <brainacid> I read the manual at hackage yet I cant get it to work
07:27:53 <simon> brainacid, so the second xmonad image on google images seems to reflect this: https://static.charlieharvey.org.uk/graphics/geekery/xmonad-1.png
07:28:10 <brainacid> let me see it simon ...
07:28:14 * brainacid clicks link
07:28:57 <brainacid> nice
07:42:22 <Enzoray> Hello there, I was wondering if someone was able to explain what problem 7 really wants me to do, (99problems, haskell)
07:42:47 <Enzoray> https://www.haskell.org/haskellwiki/99_questions/1_to_10
07:43:44 <sveit> I know that "fail :: (Monad m) => String -> m a" is supposed to be a "bad" function, so I was wondering how else are you supposed to do something like have a Parsec parser fail?
07:44:35 <exio4> a new typeclass, MonadFail(?), for places where it makes sense
07:45:26 <sveit> OK, but as of this moment, with what exists, it is still "best-practice" to use "fail" to fail a parser?
07:45:49 <shiona> Enzoray: to write a function that takes arbitrarily nested NestedList and returns it flattened
07:46:19 <Enzoray> shinoa, thanks for replying. You mean like 'concat'?
07:46:38 <lpaste> sveit pasted “Example parser” at http://lpaste.net/27846944449626112
07:47:05 <shiona> in a way yes, but you should understand that the normal list in haskell is homogenous. In this case it means every element in a list must be nested equally deep
07:47:05 <k00mi> sveit: there's nothing wrong with using "fail" from a concrete Monad instance
07:47:33 <shiona> and the NestedList is a different type that allows different depths for elements
07:47:39 <sveit> for example, when going through Write Yourself a Scheme, I had the parser I pasted here: http://lpaste.net/27846944449626112 (11 lines, short example). is that a bad wy to write that?
07:48:00 <sveit> k00mi: ok, the problem is just its inclusion in the typeclass?
07:48:09 <shiona> but otherwise yes, your job is to write a kind of concat for this different type of list
07:48:31 <Enzoray> And check it recursivly, wow.. this sounds hard.. :S
07:48:41 <k00mi> sveit: yes, the problem is that the concept of a monad does not contain anything like fail
07:48:52 <k00mi> it's bolted on because it seemed useful
07:49:40 <Enzoray> I just read chapter 8 before; it was about data types etc.
07:50:17 <sveit> k00mi: ok, thanks! would you mind taking a quick look at the code in the link just to assure me I'm understanding what you are saying, and that what I am doinng there is OK?
07:53:04 <k00mi> sveit: looks good to me
07:54:17 <sveit> Thanks!
08:03:50 * hackagebot blazeMarker 0.1.0.0 - ...  http://hackage.haskell.org/package/blazeMarker-0.1.0.0 (faleidel)
08:13:50 * hackagebot shell-monad 0.0.3 - shell monad  http://hackage.haskell.org/package/shell-monad-0.0.3 (JoeyHess)
08:20:07 <monochrom> I'm shocked. someone actually sells a monad tutorial: http://www.amazon.com/Simple-IO-Monad-Transformers-ebook/dp/B00KN6XZ1M/
08:23:55 <Chathurga> That front cover
08:24:41 <Chathurga> There's nothing more monadic than an open field
08:30:43 <ReinH> sveit: Write yourself a scheme is very out of date btw :(
09:08:04 <mseeks> hey guys, i'm doing this exercise to write a function isHappy :: Int -> Bool
09:08:43 <mseeks> basically `isHappy x` examines the sequence `iterate sumSq x` where sumSq = sum . map (^2) . map digitToInt . show
09:08:52 * hackagebot shell-monad 0.1.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.1.0 (JoeyHess)
09:09:23 <mseeks> so if this sequence ever repeats, isHappy == False and if it reaches 1, True
09:09:59 <mseeks> I thought about writing my own monad, MaybeState s a, which has runState :: s -> (a, Maybe s)
09:11:07 <mseeks> so basically keep (Maybe (Set Int)) as the state
09:12:23 <mseeks> so the point is that for each element of the sequence `x`: if x ==1 then terminate and return True; if (Just set) <- get and set contains x, `put Nothing`; else `put (insert x set)`
09:12:30 <mseeks> not sure if this is clear
09:12:56 <mseeks> has anyone done this problem in a similar way?
09:22:48 <simon> mseeks, type MaybeState s a = State (Maybe s) a, done.
09:23:54 <mseeks> simon: I thought about it a bit more and I think I need runMaybeState :: s -> Maybe (a, s)
09:24:29 <simon> mseeks, this is sort of useful, yes. MaybeT (State s) :)
09:24:49 <mseeks> simon: yeah, I wanted to try to roll my own monad before going onto monad transformers though
09:25:00 <mseeks> just to understand things better
09:25:47 <mseeks> the reason I wanted s -> Maybe (a, s) is because for each element in the sequence, you want to either 1. continue looking, 2. return True, 3. return False
09:26:15 <mseeks> i was going to encode this as 1. Just (False, s); 2. Just (True, s); 3. Nothing
09:27:07 <dts|pokeball> so did you guys know LYAH was about haskell?
09:27:37 <monochrom> I have always known from its name.
09:28:05 <dts|pokeball> but, but, but
09:28:55 <monochrom> I don't think you should worry about this
09:29:22 <dts|pokeball> im thrown for loop
09:41:24 <Denommus> hi
09:43:30 <Denommus> hi
09:45:08 <Enzoray> Denommus, spill it :D
09:46:09 <Denommus> Enzoray: I'm just wondering when cabal 1.22 will hit hackage (not that it's difficult to install it, but I wonder if ghcjs will be easier to setup)
09:48:04 <Enzoray> Installing questions.. hmm. I use ghci, it's quite simple. And I combind that with 'gedit' as text editor. Thus I'm quite a n00b in haskell
09:48:23 <Denommus> Enzoray: ghcjs is a Haskell to JavaScript compiler
09:48:51 <Enzoray> Denommus, as I stated I'm a n00b. I have no idea. :D
09:49:04 <Enzoray> Ask some of the pr0s here, I'm sure you can find one, they helped me. :P
09:49:10 <Enzoray> Cale, is one of them.
09:49:18 <Denommus> Enzoray: I'm researching on how to use Haskell for both backend and front-end programming. ;-)
09:49:27 <Enzoray> Sounds advanced.
09:49:46 <Denommus> probably not that much
09:54:01 <nick_named> Could someone please help me with a HXL snippet?  I can't figure out why the form isn't found in this code (https://gist.github.com/terrelln/7c31a559947f9ab4e0bc).
10:03:33 <zzing> If I have a function a -> ()   and a Maybe a, what was the method of applying the Maybe a to a -> () such that it does something if we Just have a, and nothing if we have Nothing?
10:03:43 <johnw> fmap
10:03:51 <johnw> will take a Maybe a to a Maybe ()
10:04:07 <benzrf> a Maybe () is just a Bool
10:04:11 <johnw> yep
10:04:24 <johnw> so maybe you just want isJust
10:04:52 <zzing> hmm
10:04:55 <benzrf> zzing: no function a -> () does anything
10:05:12 <zzing> benzrf, I am just illustrating
10:05:18 <zzing> Maybe the best way is to just say it is an a -> IO ()
10:05:41 <benzrf> ha
10:06:12 <johnw> ahh
10:06:21 <exio4> if you want a -> IO (), then we've got a different type
10:06:30 <monochrom> I prefer the original question. it's so much simpler.
10:06:36 <exio4> because, with fmap, you'd have got a Maybe (IO ())
10:06:47 <johnw> yes, he'd want traverse then
10:06:49 <exio4> we all did monochrom, we all did! ;P
10:07:01 <benzrf> johnw: do you know  that zzing is male
10:07:06 <johnw> :t traverse (Just 10) :: IO (Maybe Int)
10:07:07 <lambdabot>     Couldn't match expected type ‘IO (Maybe Int)’
10:07:07 <lambdabot>                 with actual type ‘t0 a0 -> f0 (t0 b0)’
10:07:07 <lambdabot>     Probable cause: ‘traverse’ is applied to too few arguments
10:07:14 <zzing> hmm, I don't think I have ever used traverse
10:07:23 <johnw> traverse is a more general form of mapM
10:07:41 <johnw> here's an example of something I do that sounds like what you want to do:
10:07:49 <t4nk079> I'm new to haskell and I'm having a little problem
10:07:54 <johnw> forM_ <some 'Maybe a'> $ \a -> <a bunch of IO actions>
10:08:01 <johnw> this forM_ is from Data.Foldable
10:08:15 <t4nk079> The following program is not working and I don't know why:
10:08:15 <benzrf> t4nk079: go on...
10:08:16 <johnw> the block will only execute if the Maybe a is not Nothing
10:08:16 <t4nk079> sumaMult n a = a * (asd*(asd+1)) * (1/2) 	where asd = truncate (n/a)
10:08:35 <t4nk079> It's supposed to sum the multiple of a number
10:08:38 <johnw> benzrf: I am in the habit of using 'he' as a gender neutral pronoun, so sometimes I slip and do not think about how others perceive it
10:08:39 <monochrom> what is "not working"?
10:08:48 <benzrf> johnw: :\
10:09:25 <t4nk079> It loads, but when I try to use it gives me an error
10:09:36 <benzrf> t4nk079: is it about ints not being fractional
10:09:42 <monochrom> should I load and get the error message myself?
10:09:53 <t4nk079> How do you do it?
10:10:08 <t4nk079> I'm having many problems with the types
10:10:13 <t4nk079> of the numbers
10:10:22 <benzrf> t4nk079: yes, they can be a pain
10:10:29 <benzrf> t4nk079:
10:10:30 <benzrf> :t (/)
10:10:32 <lambdabot> Fractional a => a -> a -> a
10:10:46 <benzrf> t4nk079: if you give your function an Int it won't work because Ints arent fractional
10:10:51 <benzrf> t4nk079: are you giving your function an Int :p
10:11:04 <t4nk079> I think so
10:11:10 <t4nk079> sumaMult 10 3
10:11:13 <Denommus> I never use number types directly
10:11:13 <benzrf> oh
10:11:15 <Denommus> I just use typeclasses
10:11:21 <benzrf> no, that should be fine
10:11:29 <benzrf> 10 can be a float
10:11:36 <benzrf> (or rational, or whatever)
10:11:41 <benzrf> t4nk079: what error do you get exactly
10:11:41 <johnw> zzing: be cautious about using that forM_ in the presence of recursion, as it never tail-optimizes; in that case, just 'case' is better
10:12:03 <johnw> case x of Nothing -> return (); Just a -> <a bunch of IO actions>
10:12:23 <monochrom> well, forM_ for Maybe doesn't really recurse either :)
10:12:29 <t4nk079> benzfr: No instance for (RealFrac a0) arising from a use of `sumaMult'
10:12:34 <johnw> monochrom: I mean, in a function where you loop at the end
10:12:39 <benzrf> t4nk079: aha
10:12:42 <t4nk079> It's larger, but I don't want to feel all the chat
10:12:43 <benzrf> t4nk079: it's not sure what type you want
10:12:45 <monochrom> oh! I see.
10:12:53 <benzrf> t4nk079: try "sumaMult 10 3 :: Float"
10:13:35 <t4nk079> benzfr: No instance for (Integral Float) arising from a use of `sumaMult'     Possible fix: add an instance declaration for (Integral Float)     In the expression: sumaMult 10 3 :: Float     In an equation for `it': it = sumaMult 10 3 :: Float
10:15:17 <benzrf> oh wait/.
10:15:20 <benzrf> :t truncate
10:15:21 <lambdabot> (RealFrac a, Integral b) => a -> b
10:15:25 <benzrf> aw.
10:15:45 <benzrf> well there's the problem
10:15:59 <benzrf> you can't mix integrals with fractionals or you get weird stuff going on
10:16:16 <benzrf> :t floor
10:16:17 <lambdabot> (RealFrac a, Integral b) => a -> b
10:16:20 <benzrf> :|
10:16:34 <benzrf> t4nk079: you may have to explicitly convert back
10:16:36 <benzrf> t4nk079: try
10:16:39 <t4nk079> But when i make n/a , I get a Fraction
10:16:43 <benzrf> where asd = fromIntegral (...)
10:17:01 <benzrf> t4nk079: yeah
10:17:05 <t4nk079> and truncate takes a fraction and gives an integer
10:17:08 <benzrf> t4nk079: but asd some kind of Integral
10:17:15 <monochrom> I wonder if you are better off with asd = n `quot` a
10:17:18 <benzrf> t4nk079: which you're then multiplying by your fractional input
10:17:32 <benzrf> t4nk079: and there's no type in base that's both integral and fractional
10:17:38 <t4nk079> i cannot multiply an Integral and a fractional?
10:17:41 <benzrf> t4nk079: so ghc can't infer a reasonable default
10:17:44 <benzrf> t4nk079: no, look
10:17:46 <benzrf> :t (*)
10:17:48 <lambdabot> Num a => a -> a -> a
10:17:49 <t4nk079> i see
10:17:51 <benzrf> t4nk079: has to be the same type, and
10:17:54 <t4nk079> oh
10:17:56 <benzrf> 01:16 < benzrf> t4nk079: and there's no type in base that's both integral and fractional
10:17:58 <t4nk079> that really helps
10:18:10 <kaiyin> Could anyone give me an example of using this Functor?  http://lpaste.net/117243
10:18:18 <benzrf> if you had a type that was both integral and fractional you could use it here
10:18:24 <benzrf> but i feel like such a type would be poorly behaved
10:18:30 <zzing> johnw, I will keep that in mind
10:18:40 <t4nk079> So i should convert two things to the same type before using *
10:18:56 <benzrf> t4nk079: ideally conversion should never be a problem
10:18:57 <t4nk079> I'll try, thanks
10:18:59 <benzrf> t4nk079: but if it is, yes
10:19:10 <benzrf> er
10:19:13 <benzrf> that was a bit tautological
10:19:22 <monochrom> ;)
10:20:14 <monochrom> merry christmas to you. if you're having a merry christmas.
10:20:22 <benzrf> kaiyin: hey
10:20:34 <benzrf> monochrom: i'm having a merry jewish christmas
10:20:39 <kaiyin> benzrf, hello.
10:20:59 <benzrf> monochrom: that's where you dont get presents and then you go eat chinese food and maybe watch a movie
10:21:05 <kaiyin> Merry Christmas, everyone.
10:21:06 <benzrf> monochrom: except my family is allergic to chinese food so indian
10:21:15 <benzrf> kaiyin: ok, your functor
10:21:33 <benzrf> kaiyin: a lot of the time an Either is used to represent a value that is either something you want or an error
10:21:50 <monochrom> movie is good. today several fun movies are released
10:22:16 <benzrf> kaiyin: like `Either String Int' could be the result of a calculation that might fail with a message
10:22:25 <luite> <- programming haskell under the mistletoe
10:22:44 <benzrf> kaiyin: so fmap in this case allows you to modify the theoretical result, or just leave an error
10:22:47 <benzrf> kaiyin: like Maybe
10:23:13 <benzrf> kaiyin: Either Error is often used in place of Maybe, where Error is some type used to indicate an error
10:23:21 <kaiyin> benzrf, could you feed some example to lambdabot ?
10:23:24 <HeladoDeBrownie> Haskell and luite, sitting in a tree, d-e-v-e-l-o-p… ing
10:23:50 <t4nk079> How do you use the lmbdabot?
10:23:55 <EvanR> im trying to understand a category of types and functions between types. i understand how functions can be considered arrows of a category, but they are also included in the objects?
10:24:02 <HeladoDeBrownie> > "Hi t4nk079" ++ "!"
10:24:04 <lambdabot>  "Hi t4nk079!"
10:24:12 <HeladoDeBrownie> @type "Hi t4nk079" ++ "!"
10:24:13 <lambdabot> [Char]
10:24:13 <kaiyin> > sum [1, 2, 3]
10:24:15 <lambdabot>  6
10:24:20 <ab9rf> Maybe a is functionally quite similar to Either () a
10:24:38 <benzrf> kaiyin:
10:24:41 <t4nk079> sum [1,2]
10:24:48 <t4nk079> > sum [1,2]
10:24:50 <lambdabot>  3
10:24:54 <t4nk079> ther, tahnks+
10:25:05 <t4nk079> *there, thanks
10:25:05 <EvanR> i.e. Int -> Bool is an arrow, and (Int -> Bool) -> String is an arrow between the object (Int -> Bool) and String?
10:25:08 <benzrf> @let safeDivide x y = if y == 0 then Left "u wot m8" else Right (x / y)
10:25:11 <lambdabot>  Defined.
10:25:14 <benzrf> EvanR: no
10:25:18 <benzrf> EvanR: even is a morphism
10:25:23 <benzrf> EvanR: Int -> Bool is an object
10:25:40 <EvanR> oh, values
10:25:45 <monochrom> EvanR: a cartesian-closed category supports converting between arrows and some objects (called exponent objects). this is useful for lambda calculi because they do it all the time.
10:25:47 <benzrf> kaiyin:
10:26:01 <benzrf> > fmap (+1) (safeDivide 1 2)
10:26:03 <lambdabot>  Right 1.5
10:26:08 <benzrf> > fmap (+1) (safeDivide 1 0)
10:26:09 <lambdabot>  Left "u wot m8"
10:26:23 <benzrf> kaiyin: just like Maybe, but with a nice error message!
10:26:45 <monochrom> exponent objects stand for function types
10:26:51 <EvanR> im getting that
10:26:57 <benzrf> EvanR: categories are just monoids where the elements have a function-like type
10:27:05 <EvanR> right
10:27:11 <benzrf> EvanR: objects in turn are just types
10:27:20 <EvanR> except you cant monoid-append any arbitrary two
10:27:21 <benzrf> EvanR: Hask is the category that's like the Endo a monoid but covering all types
10:28:09 <EvanR> yeah, rethinking in terms of types as objects and function implementations as arrows
10:28:15 <kaiyin> benzrf, how can the function (+1) be applied to a string?
10:28:38 <fm75> benzrf: quick question... So fmap defined for either has a particular semantincs, fmap on Maybe another one, fmap on [PutYourFunctorHere] yet another one... I wonder where these are documented.
10:28:38 <benzrf> kaiyin: look again at the implementation
10:28:54 <kaiyin> oh, i see.
10:28:54 <benzrf> fm75: poorly at best
10:28:56 * hackagebot MuCheck 0.1.0.1 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.0.1 (RahulGopinath)
10:28:58 <EvanR> so Maybe is set of morphisms for each type, and there is exactly one for each a -> Maybe a
10:29:14 <benzrf> fm75: but it tends to be pretty obvious what it does given the type and laws
10:29:26 <benzrf> EvanR: no, Maybe is a function from objects to objects
10:29:35 <kaiyin> When it's Left, f is ignored. Great. Thanks benzrf !
10:29:45 <benzrf> it's not a morphism because Hask morphisms are haskell values
10:29:47 <EvanR> er i meant to somehow write the signature for Maybe as a function between tyesp
10:29:48 <benzrf> kaiyin: np
10:29:57 <EvanR> * -> *
10:30:04 <dfeuer> johnw, I finally came up with a test that actually works, and it verifies that the fromArrayMonolithic code I wrote actually does what I want with regard to GC.
10:30:04 <fm75> benzrf: so the best way to understand what fmap does on a Functor is to read the code
10:30:06 <EvanR> thats not included?
10:30:07 <benzrf> EvanR: you can make a category out of the types too
10:30:10 <benzrf> er, kinds
10:30:18 <benzrf> fm75: well
10:30:31 <benzrf> fm75: like i said, given the types and laws, it's almost always blatantly obvious what fmap does
10:30:44 <benzrf> fm75: in fact, any given type can only have 1 valid functor instance
10:30:50 <benzrf> fm75: ghc actually has an extension for deriving Functor
10:31:30 <monochrom> I wouldn't make it "almost always blatantly" but it's certainly derivable in easy cases.
10:31:31 <benzrf> EvanR: * -> * isnt a type, its a kind
10:31:35 <Denommus> oh, great
10:31:40 <Denommus> I can't install ghcjs nor haste
10:32:19 <LordBrain> you could make an instance of functor which acts on the first element of a pair, or one that acts on the second element and leaves the first... they'd both be valid
10:32:19 <EvanR> benzrf: ok, i guess they cant be considered together in the same category, in haskell
10:32:29 <benzrf> yeh
10:32:38 <benzrf> LordBrain: no
10:32:42 <LordBrain> unless there is a meaning of valid i am missing
10:32:46 <dfeuer> Nope.
10:32:53 <benzrf> LordBrain: one that acts on the 1st element is ill-typed
10:32:56 <benzrf> LordBrain:
10:33:04 <benzrf> :t \f (x, y) -> (f x, y)
10:33:04 <LordBrain> oh i see
10:33:05 <lambdabot> (t -> t1) -> (t, t2) -> (t1, t2)
10:33:10 <dfeuer> a Functor has kind *->*
10:33:34 <monochrom> you should bear in mind parametricity. that is, for example, if I am to write a total function of type "(a -> b) -> Maybe a -> Maybe b", I am very constrained by the fact that I cannot even ask, during run time, "what are a and b this time?"
10:34:18 <benzrf> you cant even compare your a's because there's not necessarily an Eq instance
10:34:34 <EvanR> stableNames ;)
10:35:00 <LordBrain> it bothers me a bit that not all functors are valid Functors, and not all monads are valid Monads... maybe its just a linguistic hangup here.
10:35:08 <monochrom> so here it goes. given parameters "f" and "Just x", I cannot return "Nothing". "Nothing" would break a functor law.
10:35:50 <monochrom> so I must return "Just _____". the blank there has to have type "b". and I cannot even ask, "what is b this time? if Int, then I can make it 0".
10:36:05 <LordBrain> you can define a monad that is valid in  terms of hte haskell types but invalid in terms of the math, and vice versa, and i guess when you were talking about valid earlier i thought you meant math.
10:36:10 <Procian> b could even be uninhabited.
10:36:22 <Procian> And f might be a "proof by contradiction."
10:36:26 <monochrom> the only thing I have in my possession to produce a thing of type "b" is "f x". so the answer is "Just (f x)".
10:36:44 <benzrf> LordBrain: i mean both
10:36:52 <monochrom> this is fully derived and there has been no choice along the way.
10:37:14 <monochrom> at every step exactly one door was open.
10:37:34 <benzrf> Procian: proof by negation, you mean
10:37:52 <monochrom> now for other types this is not as easy, but you get the idea.
10:37:55 <Procian> benzrf: I don't think I mean either, actually.
10:38:04 <Procian> benzrf: f might just be the negation of b.
10:39:06 <LordBrain> hmmm no you don't, not when you say a functor acting on the first element is invalid, you mean the types there... the mathematical definition of functor  doesn't care about the order used in your notation
10:40:19 <Procian> LordBrain: It's not just an order though. The type (a,b) is the type constructor (,) applied to a, then applied to b.
10:40:24 <LordBrain> remember, mathematically speaking, functor doesnt come from lamda calculus, it comes from category theory, there's nothing about currying or order of parameters or what not.
10:40:39 <Procian> If you want a functor which works on the first element, you need a different type constructor.
10:41:09 <LordBrain> There are no type constructors strictly speaking as a fundamental concept in category theory
10:41:27 <Procian> But when we're talking about functors in Haskell, we're talking about functors in Hask.
10:42:00 <LordBrain> well that was the point i made earlier Procian, but benzrf claimed he was talking about the math as well
10:42:14 <Procian> Oh.
10:42:42 <Procian> A friend of mine thinks we're mostly a cargo-cult with this cat theory stuff, since we're only interested in the one category.
10:43:18 <LordBrain> hmmm
10:43:27 <cbaines> Can anyone help me with Diagrams.ThreeD.Types? How do I add two R3 vectors?
10:44:16 <monochrom> I am interested in this category: http://www.vex.net/~trebla/photo/unorganized/IO-String.png :)
10:44:21 <LordBrain> that's not quite true Procian, we are interested in sub categories of the category you have in mind as well
10:44:52 <Procian> LordBrain: I think I might agree. What sort of example?
10:45:25 <EvanR> cbaines: its an instance of VectorSpace
10:45:34 <EvanR> so it has the method ^+^ from AdditiveGroup
10:45:58 <tac_> Procian: I also feel it's largely a cargo cult.
10:46:20 <LordBrain> Procian, well the Functor type in haskell, it maps from category hask and a subcategory of hask. Any return type you can get out of fmap, is a subcategory of hask
10:46:30 <Procian> tac_: For the same reason?
10:46:56 <tac_> For instance, as far as I've seen in the 7 years I've been doing haskell, no one has ever formally defined what "Hask" is supposed to be.
10:46:57 <Procian> LordBrain: Yeah, but can we write code that talks about, say, functors in that subcategory?
10:47:29 <EvanR> i was just reading the wiki, you first need to drop bottoms and infinite datastructures to make any sense
10:47:48 <monochrom> which one is better? A. no one has defined Hask; B. two persons have defined Hask, differently.
10:47:50 <fm75> benzrf: I took pencil and paper, wrote some type annotations... and now I see what you meant by " it tends to be pretty obvious what it does given the type and laws" about Functors :)
10:47:57 <kaiyin> safeDivide :: (Fractional a, Eq a) => a -> a -> Either String a
10:47:58 <LordBrain> well you mean like fmap between them Procian ?  we could but we need a new type because Functor really means endofunctor
10:48:12 <monochrom> note that mathematicians usually do B to natural numbers, 0^0, etc.
10:48:17 <kaiyin> safeDivide :: (Fractional a, Eq a, Either b) => a -> a -> b
10:48:41 <kaiyin> @ let safeDivide :: (Fractional a, Eq a) => a -> a -> Either String a
10:48:45 <cbaines> EvanR, Thanks :)
10:48:53 <monochrom> and denotational semantics people do B to "domain". but I guess denotational semantics people are also mathematicians.
10:49:02 <kaiyin> @safeDivide :: (Fractional a, Eq a, Either b) => a -> a -> b
10:49:02 <lambdabot> Unknown command, try @list
10:49:08 <kaiyin> > safeDivide :: (Fractional a, Eq a, Either b) => a -> a -> b
10:49:10 <lambdabot>  Expecting one more argument to ‘Data.Either.Either b’
10:49:10 <lambdabot>  Expected a constraint, but ‘Data.Either.Either b’ has kind ‘* -> *’
10:49:23 <Procian> LordBrain: I mean defining the class of functors in the category of list types, and then using that to build a library of such functors.
10:50:00 <kaiyin> What was wrong about that line I fed to lambdabot ?
10:50:27 <kaiyin> Why can't Either be used the same way as Fractional or Eq?
10:50:50 <LordBrain> i think some how we must have thought it would keep our types simpler if we just assumed the pre-image is always all of hask, but i think we are somewhat paying a price because of the terminology now becoming somewhat ambiguous
10:50:51 <EvanR> Either isnt a type class
10:50:57 <monochrom> fortunately, denotational semantics people do agree on a unique definition of "O-category". all existing, differing definitions of "domain" satisfy the requirements of O-category.
10:51:23 <LordBrain> sorry for all the somewhats, the editing on irc is poor
10:51:32 <monochrom> this is good news, because if you prove a theorem of O-categories, then the theorem holds no matter what your favourite definition of "domain" is.
10:51:40 <tac_> Category theory is a great tool for denotational semantics.
10:51:44 <monochrom> for example, the theorem that says "recursive data types exist".
10:52:00 <tac_> I just think it's a pretty pointless tool for programmers, beyond understanding the Haskell lingo.
10:52:39 <monochrom> so this is possibly why denotational semantics people use category theory. if not for it, they could not persist their status quo of "same but different"
10:52:43 <EvanR> im using my limited understanding of denotational semantics to keep things straight at my job
10:52:56 <EvanR> in medical objects
10:53:56 * hackagebot stackage 0.3.1 - "Stable Hackage," tools for creating a vetted set of packages from Hackage.  http://hackage.haskell.org/package/stackage-0.3.1 (MichaelSnoyman)
10:54:02 <tac_> Denotational semantics has a definite feeling of functoriality to it. You map objects in a "natural way" between a syntax and a semantics. So category theory makes sense
10:54:48 <tac_> However, programmers work in a rather neutered logic. You can't express subtypes or pullbacks in Haskell, for instance.
10:54:56 <LordBrain> tac_, the haskell lingo is actually different a bit different from the math lingo. But i disagree that understanding the math lingo or concepts is not useful, because actually math is sort of the original source code
10:55:18 <tac_> I am not dismissing the value of the mathematics. I love the stuff :)
10:55:43 <EvanR> haskell is the gateway drug to real math
10:55:51 <tac_> (indeed EvanR)
10:56:19 <LordBrain> i actually think in terms of a computer language, i actually value more the category influence than the lambda calculus one.
10:56:20 <tac_> But think of how many times you've heard someone talk about "monoids"... but how few you've heard about monoid homomorphisms, quotient monoids, monoid actions
10:56:47 <tac_> (but that might just be a matter of Haskell and the programming community coming to realize the value of mathematical tools)
10:57:06 <EvanR> a lot of times only the semigroup matters
10:58:07 <LordBrain> the idea of currying and every function having one input and one output is not something i am particularly attached to in practice, its more like this is one way to do things that has been developed and had its kinks worked out.
11:00:16 <EvanR> uncurried functions are ok (not in haskell) but i really hate functions with random-ass signatures like arg 2 and 4 may be omitted and arg 3 may be a bool or an int depending on the combination of omissions, and the phase of the moon
11:00:20 <LordBrain> there's a sort of elegance to it, but i mean in practice...
11:00:20 <ab9rf> it has the merits of being much easier to reason about
11:00:40 <kaiyin> http://lpaste.net/117245 From learn you a haskell. How can the author assume that `a` is a concrete type?
11:01:26 <tac_> kaiyin: I think it means something slightly different than that
11:01:33 <LordBrain> where as monads and functors and so forth, feel to me like real meaty stuff that is actually relevant to a programmer in any language
11:01:35 <tac_> kaiyin: It means that a concrete type *takes the place* of a.
11:01:38 <EvanR> i would be currying a lot of functions if the default multiarg domain was a product
11:01:48 <EvanR> explicitly
11:02:11 <kaiyin> tac_ , ok, why can't it be `* -> *`?
11:02:38 <flebron> Hey. Is there a more idiomatic way of saying (f <$>) . g?
11:02:40 <tac_> kaiyin: your variable a has kind * and j has kind * -> *
11:03:16 <Chathurga> flebron: Maybe: fmap f . g
11:03:26 <flebron> Chathurga: But that's just rewriting <$> :p
11:03:31 <ab9rf> heh
11:03:43 <Chathurga> Yeah that's more idiomatic to me
11:03:45 <ab9rf> (f <$>) is just fmap f
11:03:58 <kaiyin> tac_, I am not sure about it. Alternative: a has kind (*->*) and j has kind ((*->*) -> *)
11:04:16 <flebron> Yeah I know what <$> is, I wondered if there was some operator that was used for this operation of composition followed by application inside the functor.
11:04:32 <kaiyin> tac_, the possibilities seem limitless.
11:04:49 <tac_> I'm pretty sure the possibilities are infinite but well-behaved in this instance
11:04:57 <tac_> but maybe I don't understand your question :)
11:05:52 <benzrf> flebron: people periodically request such an opeator
11:05:55 <benzrf> sadly none exists
11:06:43 <EvanR> f <$.> g
11:07:14 <flebron> Alright. The use here is to idiomatically read space-separated Ints from a Data.ByteString.Char8 ByteString, in this way: readInts = unfoldr ((second C.tail <$>) . C.readInt)
11:07:40 <EvanR> use attoparsec
11:08:10 <flebron> I likely won't have that in this programming competition, and it seems that'd be more of a hassle to use.
11:08:19 <EvanR> nah
11:08:25 <EvanR> but if its a contest
11:10:07 <EvanR> the parser itself would be something like int `sepBy` spaces
11:10:13 <kaiyin> tac_ , in the "learn you a haskell" tutorial, the author assumed a to be concrete, while I think that's a questionable assumption.
11:10:25 <EvanR> with the actual library names for these filled in, and then the bytestring provided to it
11:10:42 <flebron> Also, I'd like to voice a complaint about ByteString: tail on an empty bytestring should be the identity, not throw an error.
11:10:44 <tac_> kaiyin: could you link to the page?
11:10:59 <EvanR> tail on empty sequence of anything doesnt make sense
11:11:08 <Procian> flebron: Drop 1 instead.
11:11:08 <kaiyin> tac_ http://learnyouahaskell.com/making-our-own-types-and-typeclasses#derived-instances
11:11:14 <flebron> Oh, wait, tail works like that in lists. Nevermind.
11:11:29 <kaiyin> tac_ Just search for "We assume * for a"
11:13:57 <kaiyin> Is it possible to have a local declaration in haskell, like {} in c++?
11:14:21 <benzrf> kaiyin: hm?
11:14:25 <rhaps0dy> let
11:14:35 <rhaps0dy> let declaration = 3
11:15:13 <ab9rf> kaiyin: that's what let does.
11:15:24 <kaiyin> benzrf, in c++ you can do something like int x = 10; {char x = 'a';} ++x;
11:15:35 <ab9rf> let a = .., b = ... in ...
11:16:27 <kaiyin> great, thanks guys.
11:17:18 <ab9rf> "guys"?
11:17:27 <EvanR> > let x = 10, x = 'a' in x
11:17:28 <lambdabot>  <hint>:1:11: parse error on input ‘,’
11:17:42 <EvanR> > let{x = 10; x = 'a'} in x
11:17:43 <lambdabot>  Conflicting definitions for ‘x’
11:17:43 <lambdabot>  Bound at: <interactive>:1:5
11:17:43 <lambdabot>            <interactive>:1:13
11:17:47 <ab9rf> you need { ; } for that, i suppose
11:18:00 <ab9rf> i only got three hours of sleep last night
11:18:02 <EvanR> lets are recursive?
11:18:20 <Procian> EvanR: Yeah.
11:18:33 <Procian> No "letrec."
11:18:44 <EvanR> > let x = 10 in let x = 'a' in x
11:18:46 <lambdabot>  'a'
11:18:52 <EvanR> ok, c++ recovered
11:18:57 * hackagebot pregame 0.1.4.2 - Prelude counterpart  http://hackage.haskell.org/package/pregame-0.1.4.2 (jxv)
11:27:30 <camm> Hi there. I'm learning Haskell and I have a question. May you help me?
11:27:31 <rhaps0dy> c++ recovered?
11:27:35 <rhaps0dy> camm: sure, ask away
11:27:45 <rhaps0dy> I'm not much of an expert but other people here are :)
11:27:59 <camm> Thanks.
11:28:59 <rhaps0dy> what is your question?
11:29:01 <camm> What is the meaning of this expression: take :: Int -> [a] -> [a]?
11:29:20 <rhaps0dy> take is a function that takes an Int, a list of something, and returns a list of something
11:29:32 <rhaps0dy> (if you don't take currying into effect, but that's enough for now)
11:29:47 <rhaps0dy> camm: the two "something" are of the same type, but may be any type
11:30:05 <EvanR> same as take :: Int -> ([a] -> [a])
11:30:41 <rhaps0dy> yeah that's currying
11:32:32 <camm> Thank you.
11:33:37 <zipper> Is it okay for people to create a new branch named after the fix one has made for haskell projects? In this case haddock.
11:41:30 <kqr> hi! i've just learned that an application I want to install would benefit from a compile-time flag (in this case, "with_xft"). can I set this when installing with cabal?
11:48:32 <Denommus> managed to install ghcjs, but not haste. Funny
11:48:51 <kqr> got it. cabal install <thing> --flags="with_xft"
11:48:58 * hackagebot hledger-lib 0.24 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.24 (SimonMichael)
11:49:00 * hackagebot hledger 0.24 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.24 (SimonMichael)
11:49:02 * hackagebot hledger-web 0.24 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.24 (SimonMichael)
11:50:08 <dfeuer> carter as discussed: https://github.com/haskell/containers/pull/115/files
11:50:57 <carter> dfeuer: whats the question
11:51:18 <dfeuer> carter, that's the magic unlifted unary tuple trick.
11:51:35 <carter> dfeuer: what line
11:51:37 <dfeuer> I thought I'd let you know I tried it out.
11:51:38 <carter> i dont see it
11:51:55 <dfeuer> PA.indexArrayM
11:52:07 <carter> oh, it does it itnernally?
11:52:30 <dfeuer> Yeah, Data.Primitive.Array.indexArrayM does that for any Monad.
11:52:59 <dfeuer> I tried it with ST and with Data.Sequence's own private version of State, and the latter gave better numbers.
11:54:45 <dfeuer> Bye!
12:01:26 <ij> Does uncurry3 exist somewhere?
12:06:21 <nkar> ij: have you tried searching by the type signature?
12:06:58 <EvanR> :t uncurry3
12:06:59 <lambdabot>     Not in scope: ‘uncurry3’
12:06:59 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
12:07:28 <EvanR> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
12:07:30 <lambdabot> No results found
12:08:22 <nkar> ij: fpcomplete.com/hoogle finds it by the type
12:08:30 <nkar> in the 'ghc' package
12:13:37 <Denommus> EvanR: just create it
12:13:47 <kqr> hey! System.Process, System.Cmd or something else? what's the recommended way to get the result of a command?
12:13:52 <Denommus> EvanR: uncurry3 f (x, y, z) = f x y z
12:14:08 <Denommus> :t let uncurry3 f (x, y, z) = f x y z in uncurry3
12:14:09 <lambdabot> (t1 -> t2 -> t3 -> t) -> (t1, t2, t3) -> t
12:15:33 <kqr> ah system.process seems popular
12:15:49 <EvanR> yes but tell that to ij
12:16:25 <nkar> kqr: System.Cmd is deprecated
12:16:32 <kqr> nkar, ah
12:17:02 <Denommus> ij: ^see my previous messages
12:17:24 <EvanR> > (Just 2) `(pure (+))` (Just 2)
12:17:25 <lambdabot>  <hint>:1:11: parse error on input ‘(’
12:18:15 <EvanR> liftA2 rather
12:18:47 <EvanR> alas syntax error
12:19:00 * hackagebot eventstore 0.1.1.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.1.1.0 (YorickLaupa)
12:19:07 <Denommus> :t pure (+)
12:19:08 <lambdabot> (Applicative f, Num a) => f (a -> a -> a)
12:19:29 <EvanR> :t liftA2 (+)
12:19:30 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
12:29:31 <tsani> I'm trying to wrap my head around Conduit. I've got a source in (ResourceT IO) and a sink in plain old IO; is there some way to connect them?
12:31:07 <tsani> (at this point in the code, I'm in the ResourceT IO monad.)
12:40:24 <enthropy> @type lift
12:40:25 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:41:10 <neuroserpens> Could anyone tell me a list of the best microcontrollers out there to use with haskell? I know arduino and raspberry are the most commonly used, but there are so many I'd like feedback if possible on the best choices for haskell.
12:41:56 <tsani> enthropy: yeah, I know about lift. It turns out to not really seem to solve this problem, at least not in the naive way I'm trying.
12:42:01 <neuroserpens> Or maybe the best general purpose one instead of a list.
12:43:24 <chipbuster_> neuroserpens: I've heard good things about the Beaglebone series: they tend to have quite a bit more lifting power than the RPi or arduinos, but they cost a decent bit
12:43:31 <chipbuster_> haven't played with one myself yet, of course
12:44:39 <enthropy> tsani: I see a  transPipe :: Monad m => (forall a. m a -> n a) -> ConduitM i o m r -> ConduitM i o n r
12:44:53 <neuroserpens> chipbuster_: Very good to know. Thanks for the great input man.
12:44:59 <neuroserpens> chipbuster_: I'll look for it right now.
12:45:20 <enthropy> so you can have   transPipe lift :: ConduitM i o IO r -> ConduitM i o (ResourceT IO) r
12:46:08 <orion> Do most people use 2 spaces for indentation, or 4?
12:46:18 <tsani> enthropy: aha !
12:46:59 <tsani> enthropy: amazing, thanks! I'll try this out then.
12:47:06 <enthropy> I don't think I've used that one before
12:47:13 <neuroserpens> orion: Real men always write one liners. No indentation.
12:47:18 <neuroserpens> orion: xdd
12:47:20 <shiona> orion: what about fibonacci number of the indentation level
12:47:24 <neuroserpens> orion: Okay. I use 4.
12:47:49 <neuroserpens> shiona: That's interesting haha.
12:47:54 <enthropy> probably I just used lift before converting the (a -> IO ()) to a sink
12:48:13 <shiona> neuroserpens: I'm pretty sure someone has written vim/emacs plugins for that
12:48:33 <neuroserpens> shiona: That would enforce less blocks of code. A quite interesting approach indeed.
12:49:13 <shiona> what? is there actually some reasoning for such stupid idea?
12:49:35 <tsani> enthropy: I don't really have a choice here, sadly. I'm using a library that provides be with the sink to IO.
12:49:37 <shiona> I just threw it out there to douse any possible tab-space trolling
12:49:55 <tsani> Otherwise I would have tried to make the types match up more nicely a priori.
12:50:15 <chipbuster_> I use whatever the emacs plugin generates, but it breaks on pattern guards so I have to manually hit the space bar like 50x to get what I want :(
12:50:37 <ReinH> chipbuster_: you might try hindent
12:50:46 <ReinH> Also there are multiple indentation modes
12:51:15 <neuroserpens> shiona: Yes. Because if you think about it you'll be forced to a maximum indentation level.
12:51:26 <tsani> enthropy: well it compiles ! :)
12:51:28 <neuroserpens> shiona: The more you indent, the more you'll fuck up your code lmao
12:51:47 <shiona> wel.. yea :D
12:51:49 <chipbuster_> both haskell-indent and haskell-indentation break, unfortunately :(
12:52:21 <chipbuster_> and I'm not quite willing to switch to haskell-simple-indent because I just came from vim and I'm trying to enjoy the intelligent indentation features xD
12:55:05 <orion> I wish the vim2hs plugin allowed me to change the indentation level.
12:55:16 <ReinH> chipbuster_: Well, I use structured-haskell-mode and hindent, so I don't have this problem
12:55:29 <chipbuster_> ahh, maybe I should try that out
12:55:30 <ReinH> orion: it doesn't?
12:56:31 <orion> ReinH: I don't think so. I have ts/sw set to 2.
12:56:41 <ReinH> sts?
12:56:46 <sinelaw> ReinH, did you change the default key bindings for shm?
12:57:02 <orion> ReinH: sts=0
12:57:44 <ReinH> sts should probably be 2 as well, although I'm not sure it will help
12:57:49 <ReinH> sinelaw: nope
12:58:02 <ReinH> sinelaw: well, I use chrisdone's, so maybe
12:59:09 <sinelaw> ok
13:01:18 <kaiyin> is there something similar to python's pass statement in haskell?
13:03:39 <indiagreen> kaiyin: could you tell briefly what Python's pass statement does?
13:04:00 <kaiyin> It means "do nothing"
13:04:44 <kaiyin> # for example
13:04:44 <kaiyin> def f(a):
13:04:44 <kaiyin>     if a is None:
13:04:44 <kaiyin>         pass
13:04:44 <kaiyin>     else:
13:04:45 <kaiyin>         print(a)
13:04:49 <Cale> kaiyin: return ()
13:05:16 <indiagreen> is “pass; print something” equivalent to “pass” or “print something”?
13:05:37 <Cale> kaiyin: In general, return v is an action which does nothing except to have v as its result when you execute it.
13:06:02 <indiagreen> and just in case, it doesn't “abort” the function as “return” in C does
13:06:11 <Cale> right
13:07:02 <kaiyin> ok, I see. But return () still give back an empty tuple.
13:07:18 <Cale> Yes, every IO action must have some result value.
13:08:12 <ReinH> The empty tuple is commonly used in places you might see `void' in other languages
13:08:40 <sinelaw> Trying again here question from earlier: how do you implement equi-recursive type inference without going into an infinite loop?
13:09:01 <sinelaw> in mutable algorithms you can create a self-referencing pointer
13:09:24 <sinelaw> but with pure substitution...
13:14:28 <freeman42vm> anyone could help me with this... ahem, Haskell related question? been trying to find a way for quite some time http://stackoverflow.com/q/27650702/750216
13:15:05 <ReinH> That is... ahem... not a Haskell question
13:16:13 <freeman42vm> ReinH, if you make it high level enough, it is :) EclipseFP is a Haskell IDE, probably one of the best
13:16:27 <nkar> ReinH: well, it's about a haskell plugin for eclipse
13:17:07 <hugomg> freeman42vm: environment variables for GUI programs is an annoying problem but it depends a lot on what distro you use and whats your desktop manager
13:17:44 <hugomg> basically, your bashrc is not being sourced in the shell used by the window manager so its not adding cabal/bin to PATH
13:18:03 <freeman42vm> hugomg, Ubuntu 14.04, Cinnamon
13:18:06 <hugomg> you are going to  need to set the PATH in another file instead of your bashrc
13:18:23 <freeman42vm> hugomg, I tried setting it in etc/environment file, and it still did not work
13:19:28 <freeman42vm> hugomg, from what I understood that should apply the setting to the entire system, but it is not working
13:19:29 <hugomg> /etc/environment would be a weird place to put your stuff anyway bc thats a system file but cabal/bin is just for your user
13:20:46 <freeman42vm> hugomg, so where should I place the setting? :-?? that was the recommended place for global environment variables, unless I misunderstood something
13:24:03 * hackagebot apiary 1.2.2 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.2.2 (HirotomoMoriwaki)
13:24:47 <Rufflewind> seems to be an open bug for cinnamon: https://github.com/linuxmint/cinnamon-session/issues/15   workaround is to use whatever is provided by the login manager
13:27:43 <_2_Anna> hey:)
13:28:10 <freeman42vm> Rufflewind, thank you, that seems to be the problem, I'll try the solution mentioned there
13:28:24 <_2_Anna> ;)
13:28:33 <nkar> @ops
13:28:33 <lambdabot> Maybe you meant: pl oeis docs
13:29:11 <indiagreen> _2_Anna: have you got any questions related to Haskell
13:29:16 <jfischoff> is there a way to parse an array of arguments with optparse-applicative, by listing the same argument many times? E.g. --directory=foo --directory=bar ..
13:29:22 <nkar> indiagreen: it's a bot
13:29:27 <indiagreen> why are you so sure
13:29:28 <nkar> check whois
13:29:38 <indiagreen> oops, haven't thought of it
13:29:41 <indiagreen> @where ops
13:29:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:30:06 --- mode: ChanServ set +o monochrom
13:30:15 --- mode: monochrom set +b *!*@ip-109-43-8-94.web.vodafone.de
13:30:15 --- kick: _2_Anna was kicked by monochrom (_2_Anna)
13:30:33 <indiagreen> thanks, going to be checking whois in future
13:30:50 --- mode: monochrom set -o monochrom
13:31:11 <nkar> np
14:03:29 <elfeck> one question regarding lazy-eval:
14:03:29 <elfeck> if I have a bool statement like this: null [x | x <- xs, y <- xs, myFun x y]
14:03:29 <elfeck> does every combination x, y gets checked?
14:05:04 <indiagreen> no, it'll stop after the 1st found pair
14:05:12 <exio4> the answer is "it may"
14:05:25 <exio4> if myFun returns false for all values, it will check all combinations
14:05:34 <exio4> but if not, then, it'll stop there!
14:06:05 <elfeck> exio4 I don't understand that
14:06:17 <elfeck> aha
14:06:38 <elfeck> null [x | x <- xs, y <- xs, not $ myFun x y]
14:06:38 <agibiansky> Hey all, does anyone have any experience using custom config files and package databases with cabal?
14:07:14 <agibiansky> I am getting the following error: $HOME/.cabal/setup-exe-cache: createDirectory: does not exist (No such file or directory). How can I tell cabal which directory to use instead of $HOME/.cabal?
14:07:22 <elfeck> [x | x <- xs, y <- xs, myFun x y] will this "iterate" over all (x, y)?
14:07:25 <agibiansky> I've changed prefix and everything else I can find in my config file.
14:09:05 * hackagebot hydrogen-prelude 0.11 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.11 (JulianFleischer)
14:09:23 <santacadu> elfeck: It'll check as many 'y's for each 'x' until 'myFun x y' is true.
14:11:39 <elfeck> once myFun x y is true it will "discard" the remaining y's of one x and continue with the next x?
14:12:17 <elfeck> or more precise: does this comprehension give me all x for which {myFun x y for all y} is true?
14:12:38 <santacadu> It gives you {myFun x y for some y} is true
14:13:02 <santacadu> all x for which there is some y where myFun x y is true
14:13:09 <elfeck> okay
14:13:42 <elfeck> but no duplicate x's for different y1 y2?
14:13:57 <Cale> absolutely duplicate x's
14:14:09 <Cale> It'll give you an x for each such y
14:14:59 <Cale> [x | x <- xs, y <- xs, myFun x y]  will give the same result as  map fst [(x,y) | x <- xs, y <- xs, myFun x y]
14:15:20 <elfeck> okay
14:16:44 <elfeck> null [x | x <- set, y <- set, not $ binOp x y `elem` set] is a correct way of checking that binOp is closed in set?
14:26:16 <EvanR> elfeck: more directly maybe, all (`elem` set) [x `binOp` y | x <- set, y <- set]
14:39:06 * hackagebot reflection-without-remorse 0.9.4 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9.4 (AtzeVanDerPloeg)
14:39:47 <teurastaja> got a "cabal install cabal-install" error on windows but cant copy/paste it. basically it says: Cabal-1.20.0.3 depends on process-1.2.1.0 which failed to install
14:40:12 <teurastaja> sorry for using such a bad operating system guys...
14:40:58 <pavonia> Why can't you copy the error?
14:41:21 <teurastaja> the error message is the most descriptive ive ever seen: ExitFailure1
14:42:00 <teurastaja> i dont know... the MSYS interface doesnt allow selecting buffers on windows
14:44:29 <teurastaja> already did "ghc-pkg unregister --user process-1.2.1.0" and various others
14:44:37 <pavonia> You should be able to select the console output with the mouse and right-click to copy, IIRC
14:45:05 <pavonia> Have you tried building process separately?
14:45:17 <teurastaja> no i cant... the gui properties for the shell dont have anything enabling buffer selection
14:45:42 <teurastaja> no... im not familiar with shell emulation on windows
14:46:41 <pavonia> You can use the standard Windows shell and run "cabal install process-1.2.1.0"
14:47:04 <pavonia> Maybe add "--dry-run" to see what will happen
14:52:00 <teurastaja> what does --dry-run do?
14:53:06 <teurastaja> avast soooo does not like it
14:53:10 <recursion-ninja> any pro tips for debugging a <<loop>> exception?
14:53:31 <EvanR> printf
14:53:33 <pavonia> teurastaja: It doesn't actually install the package but tells you what would be done
14:53:40 <EvanR> (Debug.trace)
14:53:47 <teurastaja> oh ok
14:54:13 <recursion-ninja> I think my <<loop>> exception was some how related to using many StdGen instances
14:55:24 <EvanR> recursion-ninja: <<loop>> is caused by executing an infinite loop, like let x = x in x.
14:55:53 <pavonia> > let x = x in x
14:55:57 <lambdabot>  mueval-core: Time limit exceeded
14:56:03 <EvanR> it only works when compiled
14:56:48 <teurastaja> System\Process\Internals.hs:148:9: Not in scope `mkWeakMVar'
14:57:25 <recursion-ninja> EvanR i get that, I've had <<loop>> errors before but usually the cause was obvious
14:57:53 <EvanR> im just saying using many rngs doesnt sound like a cause for that
14:58:34 <teurastaja> the "`'" may not be the same but i had to type it by hand
14:58:51 <EvanR> only exiting a loop if a probability zero event occurs, that might be an infinite loop, though not sure if it could be recognized by the rts
14:58:58 <pavonia> teurastaja: What GHC version do you use?
14:58:59 <recursion-ninja> EvanR: I din't think so either but that's where the .prof file was point to the exception
14:59:18 <teurastaja> 7.4.1
14:59:24 <teurastaja> may be old is it?
14:59:58 <teurastaja> im new to haskell and actually im learning it with "write yourself a scheme in 48 hours"
15:00:48 <pavonia> teurastaja: You GHC seems to use base-4.5 but 4.6 is necessary to build that certain process version
15:01:16 <pavonia> Do you really have to update your cabal-install version?
15:01:27 <recursion-ninja> EvanR: http://lpaste.net/117249
15:01:29 <teurastaja> installing parsec
15:01:53 <teurastaja> its recommended in the manual and please let me think that windows can accomplish a simple update
15:01:58 <recursion-ninja> EvanR: The error seems to be coming from the System.Random.Shuffle.shuffle' function?
15:02:34 <teurastaja> how do i fix the base package?
15:02:40 <EvanR> did you write a RandomGen instance for something
15:03:10 <recursion-ninja> EvanR: Nope... I'll post the context
15:04:33 <teurastaja> ghc-pkg update base-4.5?
15:04:44 <indiagreen> nonono
15:04:47 <indiagreen> don't touch base
15:05:06 <teurastaja> then how do i update it?
15:05:13 <indiagreen> only by updating GHC
15:05:18 <indiagreen> base is tied to GHC
15:05:46 <teurastaja> is there a command for this on windows?
15:06:09 <arianvp____> Can someone explain how Text.Printf can have variable-argument functions?
15:06:11 <indiagreen> no, you have to download a newer version of GHC (or preferably Haskell Platform) and install it
15:06:26 <teurastaja> damn windows grrraaawrr!
15:06:41 <luite> arianvp____: yeah a typeclass with an instance for functions
15:07:06 <luite> arianvp____: you could do it more nicely nowadays with a closed type family
15:07:24 <pavonia> teurastaja: Why are you trying to update cabal-install?
15:07:32 <HeladoDeBrownie> arianvp____, part of the key lies in realizing that every function actually has exactly one parameter. So then you can have a function return a value that is polymorphic in some typeclass, which can in turn be a function, which is how that works.
15:07:41 <teurastaja> to install parsec
15:07:58 <pavonia> What happens with your current version if you try?
15:08:21 <teurastaja> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
15:08:25 <lpaste> recursion-ninja pasted “Select Cyclic Arrangement” at http://lpaste.net/117250
15:08:25 <arianvp____> OH so like:  if  r is instance.   Then a -> r is an instance for some matching a
15:08:29 <arianvp____> andd then you're done
15:08:45 <recursion-ninja> EvanR: Here's the context of the error: http://lpaste.net/117250
15:08:53 <teurastaja> is parsec installed by default?
15:09:05 <indiagreen> teurastaja: are you aware that “cabal” is actually “cabal-install”
15:09:15 <teurastaja> yes
15:09:21 <teurastaja> obviously
15:09:33 <indiagreen> okay, good
15:09:37 <pavonia> teurastaja: It says "cabal install parsec", not "cabal install cabal-install"
15:10:14 <teurastaja> Now, let's try writing a very simple parser. We'll be using the Parsec library (Install parsec if you haven't already installed it, either by itself or through the Haskell Platform. Consult your distribution's repository to find the correct package or port or build. On Ubuntu sudo apt-get install cabal-install;cabal update;cabal install parsec)
15:10:37 <indiagreen> “sudo apt-get install cabal-install” ← it's needed when you don't have cabal-install yet
15:10:45 <teurastaja> cabal update says run cabal install cabal-install
15:10:58 <pavonia> Ignore that
15:11:09 <indiagreen> no, it probably says “newer version is available; blah blah run blah blah”
15:11:19 <indiagreen> it's available, okay, but you don't need it
15:11:56 <teurastaja> anyways im reinstalling manually
15:12:18 <Pamelloes> Is there a way to make a Data.Map map equivalent keys to the same value?
15:13:02 <pavonia> Equivalent in what way?
15:13:31 <Pamelloes> Equivalent where (==) between the two keys returns true.
15:13:55 <teurastaja> by the way whats the difference between a closure and a monad?
15:14:02 <pavonia> Pamelloes: That's what it does by default
15:14:40 <HeladoDeBrownie> arianvp____, you've also gotta have a base case (like String or IO ()), but yeah, you get the idea
15:14:59 <Pamelloes> pavonia: I have two keys a and b. They are different but are defined equal through Eq. Data.Map gives them separate values.
15:15:35 <indiagreen> Pamelloes: what does “compare a b” give?
15:15:46 <Pamelloes> LT
15:15:55 <indiagreen> that's some weird type
15:16:02 <Pamelloes> hm....
15:16:08 <pavonia> Yeah
15:16:27 <indiagreen> well, you can wrap it into a newtype which would have “compare” defined as EQ when “a == b”
15:16:32 <teurastaja> im sorry for another question on monads but at least i know about closures and they seem like theyre the same thing, but obviously theyre not. so whats the difference?
15:16:52 <Pamelloes> Well I guess that's my issue, I'll go redefine compare. Thanks!
15:17:36 <EvanR> teurastaja: two different things
15:17:48 <teurastaja> are they related?
15:17:58 <EvanR> not really
15:18:45 <teurastaja> is it that a closure carries its environment and a monad carries "something" else?
15:18:51 <EvanR> monad is the more straightforward to explain properly, its a typeclass in haskell
15:22:19 <johnw> there's a replicateA in Data.Sequence, but is only for Seq's
15:22:21 <EvanR> teurastaja: consider these two examples... heres a monad in use: Just 2 >>= \x -> Just (x+1)
15:23:11 <recursion-ninja> EvanR: Did you have any thoughts on my <<loop>> exception? (http://lpaste.net/117250)
15:24:39 <EvanR> teurastaja: heres a use of closure, ones = 1 : ones
15:26:10 <EvanR> recursion-ninja: which expression triggers the exception
15:26:31 <recursion-ninja> EvanR: System.Random.Shuffle.CAF
15:26:44 <EvanR> in your code
15:27:15 <recursion-ninja> EvanR: That's what the +RTS -xc option says
15:27:29 <EvanR> >_>
15:27:31 <teurastaja> you represent a closure as a cons with car being 1 and cdr evaluated lazily as itself so an infinite improper list of 1s?
15:27:32 <johnw> which regexp library is the "lightest weight" in terms of dependencies?
15:27:34 <recursion-ninja> EvanR: On one run it referenced branches'
15:27:46 <EvanR> did you try to put printfs to find out where its happening in your code
15:28:46 <indiagreen> johnw: pcre-light
15:28:48 <recursion-ninja> EvanR: I guess I could be given the recursive nature, I'm not sure it would help narrow it down much
15:28:49 <EvanR> teurastaja: improper? in other languages closures are a thing because you often have mutable variables in scope of some anonymous function. since you dont have that in haskell, its more helpful to think of your code as expressions
15:29:02 <indiagreen> only base and bytestring
15:29:13 <johnw> indiagreen: but also libpcre
15:29:30 <indiagreen> hm, I thought it was bundled
15:29:39 <EvanR> recursion-ninja: no, loop happens when your code encounters an unproductive loop, its not always looping by virtue of using recursion
15:30:00 <indiagreen> right, it's not
15:30:06 <EvanR> some line of your code triggers the bug, after identifying that, you can figure out where the bug really is
15:30:27 <recursion-ninja> EvanR: Can you elaborate on that?
15:31:20 <EvanR> "put Debug.Trace.trace on random lines of your function and adjust until you found the last expression in your code before it crashes"
15:32:13 <EvanR> teurastaja: in the monad example, youll see it doesnt have much to do with the idea of closures
15:33:00 <Aruro> why does simple program which uses getLine crashes on mac with error : hGetLine: end of file ??
15:33:21 <EvanR> hGetLine simply throws an error if EOF
15:33:37 <EvanR> because EOF is not a value
15:33:55 <Aruro> a <- getLine ; print a does not compile
15:33:59 <Aruro> im wondering why
15:34:14 <indiagreen> johnw: regex-tre, regex-posix, or regex-pcre-builtin, then
15:34:42 <indiagreen> I looked at all regex-* libraries and all others had parsec as a dependency, I think
15:35:05 <EvanR> :t hGetLine
15:35:06 <lambdabot>     Not in scope: ‘hGetLine’
15:35:06 <lambdabot>     Perhaps you meant one of these:
15:35:06 <lambdabot>       ‘BSC.hGetLine’ (imported from Data.ByteString.Char8),
15:35:21 <EvanR> Aruro: hGetLine's type is IO String ?
15:35:24 <Aruro> why it should throw error?
15:35:27 <Aruro> yes
15:35:33 <Aruro> it should wait input no?
15:35:35 <EvanR> well, EOF isnt a string
15:35:44 <EvanR> no, EOF, there will never be any more input
15:36:01 <indiagreen> johnw: I can't say anything about their quality, unfortunately, because I only used text-icu, but there's a comparison table for regex-* libraries on Haskellwiki
15:36:15 <johnw> indiagreen: thanks!
15:36:56 <Aruro> how do i read a line and print it then?
15:37:02 <Aruro> this is example from wiki
15:37:05 <EvanR> from stdin?
15:37:10 <Aruro> and it does not compile on mac
15:37:11 <Aruro> yes
15:37:15 <Aruro> terminal
15:37:16 <EvanR> try getLine
15:37:21 <Aruro> same error
15:37:30 <EvanR> im on mac, ill try it
15:37:37 <Aruro> try
15:37:50 <Aruro> just a<-getLine ; print a
15:38:33 <Aruro> on a side note, should installing haskell-src-exts take like forever?
15:38:35 <EvanR> ok, it worked
15:38:39 <Aruro> hm
15:38:45 <Aruro> what is code?
15:39:22 <EvanR> http://lpaste.net/117251
15:40:32 <Aruro> ok i get same error
15:40:41 <EvanR> paste your code and the error
15:40:44 <Aruro> can the problem be with Sublime Text 2?
15:41:03 <Aruro> test.hs: <stdin>: hGetLine: end of file
15:41:03 <Aruro> [Finished in 0.6s with exit code 1]
15:41:17 <EvanR> lpaste the code too
15:41:23 <Aruro> same as yours
15:41:25 <Aruro> i copied it
15:41:30 <EvanR> i didnt use hGetLine
15:41:33 <EvanR> so its not the same
15:41:55 <Aruro> it uses hGetLine it seems
15:41:57 <Aruro> inside
15:41:58 <EvanR> oh, right
15:42:01 <Aruro> getLine
15:42:22 <EvanR> ghc Test.hs
15:42:24 <EvanR> ./Test ?
15:42:35 <Aruro> ok let me try
15:45:35 <Aruro> it did compile
15:45:37 <Aruro> it seems
15:45:50 <Aruro> how to i run it? just type test in terminal?
15:45:56 <Aruro> nothing happens if so :)
15:46:10 <EvanR> its supposed to freeze until you type a line of text
15:46:15 <Aruro> ghc test.hs -> then i run test
15:46:19 <Aruro> and it just quits
15:47:16 <EvanR> just to be sure rename the file Main.hs with a capital M
15:47:39 <srhb> Aruro: ./test ?
15:47:45 <EvanR> ah right
15:47:46 * srhb didn't read conversation
15:47:51 <srhb> Just a guess.
15:47:59 <Aruro> yes
15:48:03 <Aruro> it worked
15:48:04 <Aruro> ty
15:48:05 <EvanR> also remember to use ./ in front, especially if you name your program test, always a bad idea
15:48:23 <Aruro> why didnt sublime text did not build it?
15:48:40 <Aruro> it was building more simple programs like just print stuff
15:48:51 <EvanR> more like why did it build something that ran and has EOF on stdin
15:49:06 <Aruro> :)
15:49:09 * hackagebot Octree 0.5.4.1 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.5.4.1 (MichalGajda)
15:49:11 * hackagebot hPDB 1.2.0.1 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0.1 (MichalGajda)
15:49:13 * hackagebot hPDB-examples 1.2.0.1 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.2.0.1 (MichalGajda)
15:49:19 <EvanR> hashtag IDEProblems
15:49:33 <Aruro> i just installed hoogle packege
15:49:43 <Aruro> package , but it seems to be not in path
15:50:01 <Aruro> how can i add it to path?
15:50:40 <EvanR> never used sublime text dunno
15:51:02 <srhb> On Linux it's generally ~/.cabal/bin that you want to prepend to your PATH
15:51:16 <srhb> (Well, $HOME/.cabal/bin)
15:51:16 <Aruro> ty
15:51:26 <Aruro> i willtry now
15:51:30 <Aruro> im new to mac terminal
15:51:37 <Aruro> its not in library/haskell
15:51:37 <EvanR> use iterm2 its better
15:51:43 <Aruro> so should be in cabal
15:51:54 <Aruro> iterm2 is a part of system?
15:51:59 <EvanR> no
15:52:32 <Welkin> iterm2 is third party
15:52:45 <Aruro> i can not find cabal in library/haskell
15:52:55 <Aruro> should it be in user directory?
15:52:56 <Welkin> try ~/.cabal
15:53:03 <srhb> Aruro: I'm sure Google knows a bit about cabals paths on Mac
15:53:12 <Aruro> :D
15:53:25 <Aruro> true statement
15:53:51 <Welkin> google knows nothing, it's just a collection of links, not an AI
15:54:08 <srhb> Welkin: Thanks for that.
15:55:29 <srhb> Aruro: An easier solution might be to find / -name cabal 2> /dev/null
15:55:31 <EvanR> google is an AI, for some definition of artificial ;)
15:56:13 <Aruro> how the ~ symbol is called ? :)
15:56:17 <Welkin> on mac, cabal is in ~/.cabal/bin
15:56:18 <Aruro> can not find it on mac :D
15:56:19 <srhb> Aruro: Tilde?
15:56:25 <srhb> I think.
15:56:31 <Aruro> tilde he thinks above letters
15:56:33 <EvanR> dont try to pronounce it, youll hurt yourself
15:56:33 <Aruro> i mean google
15:56:42 <srhb> Right, it's usually the same button though
15:56:53 <srhb> Sometimes you need to press it twice for it to appear on its own
15:56:56 <arianvp____> curly dash?
15:56:59 <Welkin> or Library/Haskell/bin
15:57:04 <Welkin> it depends on how you installed it
15:57:10 <arianvp____> oh tilde
15:57:39 <EvanR> you might not be able to use literally ~ in PATH
15:57:49 <srhb> You should use $HOME, generally
15:57:54 <Aruro> it worked as copied
15:58:10 <arianvp____> $HOME usually works as well
15:58:19 <Welkin> you can use either
15:58:38 <EvanR> not in ubuntu's dash shell
15:58:38 <srhb> You should use $HOME, they don't always expand following the same rules.
15:58:45 <srhb> In fact, they generally don't.
15:59:38 <arianvp____> I refuse to learn (ba)sh scriptin
15:59:42 <arianvp____> or awk or sed
15:59:46 <arianvp____> unix people hate me
15:59:50 <EvanR> all you need is ed
16:01:11 <Welkin> awk, sed, and bash are all terrible
16:01:21 <Welkin> they have their uses
16:01:41 <srhb> But that's a discussion for another channel. :)
16:01:47 <Welkin> but anything more complex than one line should be done in somehting better, like haskell
16:01:48 <int-e> recursion-ninja: congratulations, you have uncovered a bug in random-shuffle. shuffle' [] 0 (undefined :: StdGen)  loops forever.
16:02:12 <int-e> (in ghci)
16:02:52 <ReinH> int-e: wrong bottom? :p
16:03:38 <int-e> ReinH: Nope. In compiled code, it throws <<loop>>.
16:03:52 <ReinH> huh
16:04:56 <EvanR> it does fix growLevel on []
16:05:01 <int-e> More precisely, buildTree here loops if given an empty list: https://hackage.haskell.org/package/random-shuffle-0.0.3/docs/src/System-Random-Shuffle.html   shuffleM checks for this, but the check should really be in shuffle.
16:05:22 <EvanR> where growLevel self l = self $ inner l
16:05:27 <EvanR> inner [] = []
16:05:31 <EvanR> it infinitely nests
16:05:41 <int-e> (why one would *actually* use fix to define a recursive function is beyond me, btw.)
16:06:26 <jesyspa> int-e: Maybe a function had already been defined and you think "Oh, the fixed point of this is exactly what I need!"
16:06:33 <int-e> I mean, growLevel l = growLevel $ inner l  would be more readable.
16:07:01 <EvanR> right... growLevel is already named
16:07:21 <int-e> There's another oddity further down in shuffle': rseq' builds a list of pairs, and the only caller only unzips the list...
16:09:55 <EvanR> its using the pair for state
16:10:01 <EvanR> s -> (a, s)
16:10:15 <EvanR> the fst . unzip is dropping the state
16:15:40 <int-e> EvanR: yes, but instead it could just omit the generator in the produced list
16:16:00 <int-e> rseq' i gen = j : rseq' (i - 1) gen' -- as simple as this
16:16:13 <EvanR> oh
16:16:29 <EvanR> the generator isnt being used at all in the list
16:16:32 <int-e> anyway, that's no big deal, just a bit strange.
16:19:07 <int-e> Anyway, my leading question was "why is there a CAF in that code" and it turns out that it's the  Tree a  value that's produced for the empty list; ghc pushes the empty list case all the way to the top level.
16:19:16 <int-e> (that Tree a value is, of course, bottom)
16:21:03 <Aruro> does hoogle rely on wget?
16:21:13 <Aruro> i just ran hoogle data
16:21:29 <Aruro> and it complained a couple of times about wget but did not stop
16:21:44 <Aruro> im wondering now if something got missing
16:22:21 <Aruro> it had tons of dependencies and at the end it relies on wget, im a bit sad
16:24:54 <int-e> Oh actually  shuffle  seems fine, because it's specified in such a way that the first list has exactly one more element than the second one; the empty list test should be in shuffle'. But shuffle could handle this error better.
16:34:11 * hackagebot shell-monad 0.2.0 - shell monad  http://hackage.haskell.org/package/shell-monad-0.2.0 (JoeyHess)
16:38:01 <Aruro> hoogle should be a part of haskell platform
16:38:04 <Aruro> imho
16:38:15 <Aruro> readily integrated in ghci
16:39:30 <EvanR> something like it yeah
16:54:11 * hackagebot indices 1.6.2 - Multi-dimensional statically bounded indices.  http://hackage.haskell.org/package/indices-1.6.2 (MikeLedger)
16:58:39 <benzrf> is gloss any good for interactive stuff
16:59:10 <agibiansky> benzrf: It depends on what you want to do, but it does have a 'play' function which lets you handle key and mouse events
16:59:18 <benzrf> hmm
16:59:21 <agibiansky> I have used it to implement simples games, e.g. pong and such, and it was quite easy and nice
16:59:33 <benzrf> im thinking about something involving basic mouse-based stuff
16:59:40 <benzrf> so like being able to click and drag objects
16:59:44 <benzrf> draw shapes, maybe
17:00:15 <c_wraith> benzrf: should handle that fine
17:00:16 <agibiansky> benzrf: Take a look at the Game modules: http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss-Interface-IO-Game.html
17:00:22 <benzrf> cool thanks :)
17:03:07 <benzrf> https://hackage.haskell.org/package/gloss-banana-0.1.0.0/docs/Graphics-Gloss-Interface-FRP-ReactiveBanana.html oooh
17:03:11 <benzrf> now that's just handy
17:03:36 <bananagram> ooh, cool
17:03:52 <Aruro> how to find ghci current directory?
17:05:19 <c_wraith> Aruro: I know there's something...
17:06:01 <bennofs> Aruro: :show paths
17:06:30 <matematikaadit> Aruro: :!pwd
17:06:39 <matematikaadit> if you're in unix
17:07:09 <Aruro> this would be the path ghci is working in?
17:07:23 <Aruro> it shows desktop on :! pwd
17:07:38 <c_wraith> the :show paths thing lists the current directory in first part of its output
17:08:06 <Aruro> ty it works too :)
17:08:25 <Aruro> how to set different default path?
17:09:01 <Aruro> i find it wierd there are no INghci commands to change default behaviour :)
17:09:11 <Aruro> like update default config file
17:09:40 <Aruro> if you dont take into account that its possible to do that through :! cheat :)
17:11:52 <matematikaadit> Aruro: well, you could put ":cd /your/default/path" in your ~/.ghc/ghci.conf file
17:12:17 <Aruro> ty
17:14:28 <Aruro> ghci does not seem to search inside folders which are present in a current folder?
17:17:05 <matematikaadit> Aruro: what do you mean?
17:17:32 <ReinH> Aruro: I'd recommend using cabal to organize things complex enough to have multiple haskell files in multiple directories
17:18:31 <Aruro> i mean it does not recursively search inside
17:18:42 <Aruro> of a folders present in its working folder
17:18:45 <Aruro> when using :l
17:18:47 <Aruro> command
17:20:54 <Aruro> ty ReinH i will look into cabal
17:22:19 <kaiyin> instance Functor (r ->) where
17:22:20 <kaiyin>     fmap f g = (\x -> f (g x))
17:22:39 <kaiyin> Isn't this functor exactly the same as composition?
17:23:19 <matematikaadit> Aruro: I think it does. ":l <module>" command will load modules and their dependents.
17:26:28 <pavonia> kaiyin: It is
17:27:03 <matematikaadit> :t fmap
17:27:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:27:31 <matematikaadit> :t fmap `asAppliedTo` (undefined :: (r -> a))
17:27:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:28:11 <pavonia> :t (.)
17:28:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:28:32 <pavonia> I think (.) once was defined as fmap in lambdabot
17:29:13 * hackagebot caramia 0.6.0.0 - Less painful OpenGL 3.3 rendering  http://hackage.haskell.org/package/caramia-0.6.0.0 (Adeon)
17:29:25 <kaiyin> pavonia, it isn't any more?
17:29:53 <EvanR> :t Category.(.)
17:29:54 <lambdabot> Not in scope: data constructor ‘Category’
17:30:00 <pavonia> Apparently not
17:30:05 <EvanR> :t Control.Category.(.)
17:30:06 <lambdabot>     Not in scope: data constructor ‘Control.Category’
17:30:51 <pavonia> :t (Data.Category..)
17:30:52 <lambdabot> Not in scope: ‘Data.Category..’
17:34:19 <matematikaadit> @let import Data.Category ((.))
17:34:20 <lambdabot>  .L.hs:72:1:
17:34:20 <lambdabot>      Failed to load interface for ‘Data.Category’
17:34:20 <lambdabot>      Use -v to see a list of the files searched for.
17:34:32 <EvanR> its Control.Category
17:34:54 <matematikaadit> @let import Control.Category ((.))
17:34:54 <lambdabot>  .L.hs:162:19:
17:34:55 <lambdabot>      Ambiguous occurrence ‘.’
17:34:55 <lambdabot>      It could refer to either ‘Data.Function..’,
17:35:02 <EvanR> raw haw haw
17:35:05 <pavonia> :t (Control.Category..)
17:35:06 <matematikaadit> @let import qualified Control.Category ((.))
17:35:06 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
17:35:09 <lambdabot>  Defined.
17:39:32 <matematikaadit> I'm wondering, what made some module fall in a Control and also what made some others out of it?
17:40:14 <matematikaadit> like Functor was in Data.Functor, although Monad and Applicative was in Control
17:42:12 <EvanR> the top level module names Data and Control dont mean much
17:45:53 <ReinH> matematikaadit: historical accident
17:56:25 <eyebloom> Can string literals be used as patterns in a case statement?
17:56:42 <Welkin> yes
17:57:58 <eyebloom> How does the compiler match strings in this scenario?
18:04:01 <int-e> eyebloom: just normal pattern matching: "abc" is ['a','b','c']
18:04:56 <int-e> which is 'a':'b':'c':[]
18:26:28 <darkroom> does anyone know what the $= operator does?
18:26:54 <agibiansky> darkroom: It's used in the opengl package and similar to assign mutable variables (see the StateVar package, I think)
18:26:55 <geekosaur> which one?
18:27:17 <geekosaur> conduit and other enumerator packages also define it
18:27:20 <darkroom> agibiansky: thanks i am reading through OpenGL and i am like
18:27:25 <darkroom> agibiansky: the fuck
18:27:54 <agibiansky> Yeah, OpenGL stores a lot of internal mutable state. $= takes a variable on the left and a value on the right and tells openGl to assign the value to that variable, which is why it has to be in IO
18:33:19 <EvanR> it doesnt actually NEED to be in IO in order to have that functionality, but for whatever reason its necessary to have opengl work
18:33:55 <agibiansky> EvanR: How would it work outside of IO?
18:34:28 <agibiansky> I think it does have to be IO, since it's internally either an IORef or something similar
18:34:33 <EvanR> for example STRef
18:34:47 <EvanR> or a pure version
18:34:53 <agibiansky> Using State?
18:34:56 <agibiansky> Fair enough
18:35:02 <EvanR> something
18:35:13 <agibiansky> StateVar requires IO, though perhaps that's something that might be nicer if changed
18:35:34 <EvanR> StateVar seems to be a very basic wrapper around IORefs
18:36:38 <agibiansky> I don't think StateVar itself uses IORefs, does it? I thought it just provided the interface
18:36:48 <EvanR> guess not
18:36:50 <agibiansky> So, for example, in OpenGL the settable and gettable vars are implemented with opengl calls
18:37:22 <EvanR> the mutable array interface for instance doesnt require IO, but some monad
18:37:51 <EvanR> IO and ST being the only sane choice for that purpose
19:22:58 <agibiansky> luite: Thanks for all the help today! https://github.com/haskell/cabal/pull/2303 – first attempt at a PR is up, done for today... :)
19:24:08 <LABurn> I've never used a sandbox before
19:24:19 <LABurn> Can someone tell me if I did this right
19:25:01 <LABurn> I performed the init
19:25:17 <LABurn> then I simply told cabal to install my packages with "cabal install [package]"
19:25:33 <LABurn> Will this keep the packages inside the sandbox or did I mess up?
19:26:32 <agibiansky> LABurn: that should be right, as long as you run the cabal install from within the sandbox dir
19:26:45 <agibiansky> In fact, you can check – the first line or so of your cabal install output shoulud say "using sandbox ..." or something like that
19:28:08 <ij> Just noticed a repa has a !? function for "safe" !, along the lines of [a] -> Int -> Maybe a. That's pretty neat!
19:36:36 <joe9> need some design advice, please? I am writing a program with 4 sequential (mostly) processing steps. The processing step determines what the next step will be. I am thinking of a simple function with type: process :: NextStep -> IO NextStep, and recurse through with this function.
19:37:03 <joe9> Just wanted to check if there is a design pattern for this kind of processing and if there is any other functionality that can help with this processing.
19:39:16 <lilred> Hi friends
19:39:21 <lilred> Merry christmas
19:40:01 <benzrf> marry christmas
19:40:02 <SoupEvil> joe9: uhm not sure if i understand you correctly, with (>>=) you can pipe one monadic result into the next monadic action
19:40:25 <benzrf> joe9: can you be a little more specific?
19:40:40 <joe9> SoupEvil: no, not that. I am thinking more in terms of the Free monad or such like that.
19:40:42 <SoupEvil> and every process can do it's stuff completly on it's own
19:41:49 <benzrf> joe9: what are you doing exactly
19:41:56 <joe9> benzrf: The step 1 checks if a ticker is valid. If it is, download some last price history for the ticker. If the download is good, then get a specific option price for that ticker. If the download is not good, then do not do anything.
19:41:58 <SoupEvil> your example is to abstract to give a specific answer, when it's not a monadic pipe case
19:42:28 <joe9> If the specific option price does not meet some criteria, then download a different option price.
19:42:40 <joe9> if the last price history is not available, then abort further processing.
19:43:01 <SoupEvil> whats "do not anything" what should the next process do? nothing at all? then its an error case
19:43:03 <joe9> In some instances, I already have the last price history, then do not download.
19:43:09 <benzrf> joe9: sounds a little like something pipes might handle
19:43:19 <benzrf> joe9: if what you're looking for is effectful streaming
19:43:21 <SoupEvil> use the cached result, than its local state
19:43:24 <lilred> Design question! I want to write a parser that is "bidirecitonal"
19:43:29 <benzrf> lilred: interesting
19:43:43 <benzrf> lilred: parsers tend to be noninjective by nature...
19:43:44 <joe9> benzrf: ok, thanks.
19:44:24 <lilred> "bidirectional" insofar as errors found on the AST can be reported with respect to the position of the relevant terms in the text
19:44:30 <benzrf> oh
19:44:35 <lilred> so not a bijection
19:44:40 <benzrf> lilred: you mean you want to save information info
19:44:45 <benzrf> onto the AST
19:44:47 <lilred> more like a lens
19:44:48 <benzrf> that's kind of a different thing
19:45:47 <lilred> basically I want to be able to reframe error messages
19:46:32 <lilred> from the perspective of the source code rather than the internal representation
19:46:40 <lilred> and I'm wondering if lens are the right tool for this
19:48:48 <lilred> benzrf: some variants of parsing are mostly bijective though! Think binary serialization protocols and such
19:52:38 <benzrf> h,m
19:57:55 <Pamelloes> What are my options for processing command line arguments?
19:58:12 <agibiansky> Pamelloes: optparse-applicative is popular
19:58:23 <lilred> Pamelloes: I really like optparse-applicative
19:58:54 <Pamelloes> Thanks! I'll go check it out :)
19:59:33 <lilred> It took me a while to wrap my head around, but it's nice and powerful and dead simple once you've got the hang of it
20:04:01 <lilred> I feel like it would be nice to have a stateful incremental parser hooked into the text editor, that way you're really having a dialogue with the compiler
20:04:05 <zzing> Is there a short form (operator version) of traverse?
20:04:54 <agibiansky> lilred: That'd be very cool, but kinda hard. How would you re-parse once changes were made?
20:05:18 <agibiansky> Changing a single character would have to trigger a reparse of everything past a certain point
20:06:21 <agibiansky> If you were using a parser-combinator approach (e.g. ListT  + StateT String, or something like that), you'd could store all the intermediate parses, and when something is changed, restart from there
20:06:48 <lilred> agibiansky: store everything as a rope, with a zipper on the cursor location
20:07:01 <lilred> the rope is also an AST
20:07:21 <lilred> with a special case for syntactically malformed segments
20:07:32 <agibiansky> "the rope is also an AST"?
20:08:01 <lilred> A rope is a tree structure for representing text, you could force an AST structure on it
20:08:16 <agibiansky> How would you add the AST bit, I mean?
20:08:46 <lilred> basically, ropes are parametric on the strategy used to structure the tree
20:09:13 <lilred> I'd just structure it like an AST
20:09:34 <agibiansky> How is that different from just storing the AST with an annotation corresponding to the original SrcSpan (effectively)?
20:10:21 <agibiansky> I guess the key would be having a cursor into the AST?
20:10:38 <lilred> with a zipper on an AST you're only modifying the innermost node at any given point, so parsing errors would be a lot more local (and depend on previous actions)
20:10:49 <lilred> yeah, a cursor is the same thing as a zipper
20:11:30 <lilred> this entire enterprise is in the context of a search for better IDE error reporting
20:11:38 <agibiansky> I imagine the difficulty would then be reacting properly to changes in the AST, as small changes would lead to large restructurings
20:11:46 <agibiansky> Would be a fun thing to experiment with
20:11:53 <lilred> I think I'll write it before NYE
20:12:01 <lilred> trying to figure out my approach
20:12:30 <agibiansky> lilred: if you throw it up on github ping me, im interested in seeing how that works out
20:12:39 <lilred> small changes wouldn't usually lead to large restructurings! That's the entire point of it
20:12:52 <agibiansky> lilred: delete the 'a' from 'case'
20:13:42 <agibiansky> Or other things that make things no longer syntactically valid
20:14:02 <agibiansky> I guess a bigger problem would be, go the other way – add in the 'a' from a previously unparseable state
20:14:15 <agibiansky> In general I feel like parsers are very bad with errors
20:14:30 <lilred> basically if you break the parse (by removing a character or similar), that part of the AST gets turned into a text blob, loses all structure
20:14:40 <lilred> but at least it's localized
20:14:54 <lilred> like removing the a from case wouldn't give you errors in the branches
20:14:57 <lilred> just the case part
20:15:57 <lilred> "derp, this was a case statement but the AST node that says 'case' is now a text blob that says 'cse', do you want to fix this?"
20:16:05 <agibiansky> hmm
20:16:07 <agibiansky> how about this
20:16:10 <agibiansky> f x =
20:16:10 <agibiansky>   case x of
20:16:11 <agibiansky>     1 -> 2
20:16:12 <agibiansky>     z -> y
20:16:15 <agibiansky> remove the "-" from the z -> y
20:16:28 <agibiansky> you now have a valid parse
20:16:40 <lilred> is it?
20:16:43 <agibiansky> Yeah
20:16:44 <agibiansky> f x =
20:16:45 <agibiansky>   case x of
20:16:46 <agibiansky>     1 -> 2 z > y
20:17:07 <agibiansky> and if Num (a -> b)
20:17:18 <agibiansky> where :t z == a and :t y == b
20:17:23 <lilred> that actually makes a lot of sense
20:17:31 <lilred> so within my system this would be considered invalid
20:17:38 <lilred> even though it's good
20:17:42 <agibiansky> which might be a good thing
20:17:50 <lilred> yeah, I think it
20:17:59 <lilred> it's not a showstopper, but I might have to provide a "refresh" command
20:18:14 <lilred> which kind of complicates the UI a bunch]
20:18:24 <agibiansky> It would be very nice for syntax highlighting
20:18:46 <agibiansky> Hmm, I also wonder whether changing the zipper focus as you move your text cursor will be hard
20:19:01 <agibiansky> Probably doable
20:19:20 * hackagebot distributed-process-monad-control 0.5.1 - Orphan instances for MonadBase and MonadBaseControl.  http://hackage.haskell.org/package/distributed-process-monad-control-0.5.1 (jeremyjh)
20:19:34 <lilred> I don't think it should be, if every node stores its range over the source (characters x to y) then it's more or less a binary search
20:19:59 <agibiansky> Yeah, probably even better, since most movements are very local
20:20:17 <lilred> damn this is really shaping up
20:20:18 <agibiansky> A left or a right is probably approximately O(1)
20:20:33 <agibiansky> Switching lines would require you to move a few levels up the AST and back down sometimes
20:20:43 <agibiansky> But I bet it would be effectively O(1) "amortized"
20:20:51 <lilred> I'm honestly not too worried about big O for this, considering the largest case is ~2000 lines
20:21:10 <lilred> I just need to make it fast for the local case
20:21:38 <lilred> and if I'm not stupid it should scale pretty well
20:22:17 <lilred> intuitively I think it'd be O(log n), where n is the distance between the two sites
20:22:23 <lilred> nothing to lose sleep over
20:22:26 <agibiansky> Yup, something like that
20:22:56 <lilred> I'll try a proof of concept over the lambda calculus
20:23:02 <agibiansky> You could wrap this in a nice library and be AST-agnostic pretty easily
20:23:32 <lilred> That sounds tough!
20:23:58 <lilred> Like what sort of AST definition format would I demand?
20:24:27 <agibiansky> Anything that stores its SrcSpan and can be converted to/from a zipper
20:24:42 <lilred> hmm you're right
20:24:49 <lilred> I don't need to do much of the heavy lifting :3
20:25:06 <agibiansky> And then the zipper need to have a few operations, namely, "up", "down", and "children"
20:25:59 <lilred> that doesn't sound too bad actually
20:26:30 <lilred> I'll try a PoC and then see if I can factor out the AST
20:26:47 <agibiansky> lilred: sweet :)
20:26:49 <benzrf> mfw i read that as "person of color"
20:27:17 <lilred> benzrf: kinky.
20:28:00 <benzrf> what
20:29:48 <lilred> agibiansky: https://github.com/lilred/stateful-parse you might want to star this repo, I'll start working on it tomorrow or the day after
20:30:30 <agibiansky> lilred: ok. I've never actually used repo starring before, exciting new experiences
20:33:39 <lilred> agibiansky: well, this is going to be my second Haskell program ever, so exciting new experiences indeed.
20:33:57 <lilred> >that feel when I've been studying the language for three years but have only ever written about fifty lines of code
20:34:28 <agibiansky> lilred: Hahah, how'd you manage that
20:35:22 <lilred> I mostly code in F#, with a bit of C# and Ocaml here and there. Haskell is interesting, but it's scary as hell, so I always find myself going back to the things I know
20:35:32 <agibiansky> Ah, I see
20:36:01 <lilred> I come to Haskell for my fix of theory, most of the stuff I can't port back but it's still interesting
20:36:34 <lilred> I've also been picking up Coq but the user story is an absolute mess
20:36:39 <agibiansky> I keep meaning to get back to Ocaml a bit, I started out FP with Ocaml a few years back and haven't gone back after moving to Haskell, but it l seems like Ocaml has evolved a lost since then
20:36:48 <agibiansky> Yeah, I tried out Coq very briefly but... didn't get very far
20:36:50 <ij> How do I handle juicypixel's dynamicimage? I know for a fact that my image has 42bit pixels(it's a png).
20:37:33 <lilred> Ocaml's nice, but I really like F#. It's basically a more enterprisey Ocaml with Haskell-ish features.
20:37:47 <lilred> Type system plugins, special syntax for monads, monoids, and other DSLs. It's amazeballs.
20:37:59 <lilred> units of measure are really cool too.
20:38:37 <agibiansky> ij: Can you pattern match on the DynamicImage type?
20:38:58 <greymalkin> If I want to build several executables from the same code (changing only the main file) is there a way to specify the dependencies only once and/or make a library which exports all its packages without specifying them by hand?.
20:39:06 <agibiansky> lilred: Yeah, I've heard nice things about it. I don't do Windows very much though, which keeps me away from it, though I hear C# at least is now a bit more cross-platform lately
20:39:15 <lilred> Syntax- and tooling-wise, I feel like F# is the best functional language. It's hurt quite a lot by the lack of modules, typeclasses, GADTs though.
20:39:19 <ij> agibiansky, Oh, right I can. Thanks!
20:40:06 <agibiansky> greymalkin: In the cabal file you can have a `library` section and then have several `executable` sections which depend on that `library` section. You would need to have the `library` export everything you need, though
20:40:11 <aavogt> greymalkin: yeah you make a library in the cabal file, then lots of executables which are just files of something like    import TheLib; main = main1
20:40:30 <lilred> Yeah, I don't do Windows very much either. It's funny too, because I'm an intern dev at Microsoft working on Windows.
20:40:45 <agibiansky> lilred: Do you do F# on non-windows?
20:41:29 <lilred> agibiansky: I can't bring myself to give up Visual Studio, so the development has to happen on Windows. I develop some cross-platform stuff though. Still looking into having a remote debugger that goes between Mono and VS.
20:41:52 <lilred> Might be my capstone project at school actually!
20:46:14 <lilred> Jesus... The Haskell Platform installer doesn't work on the most recent version of OS X
20:46:44 <agibiansky> lilred: What happens?
20:47:37 <lilred> The operation couldn’t be completed. (com.apple.installer.pagecontroller error -1.) Couldn't open "Haskell Platform 2014.2.0.0 64bit.signed.pkg".
20:47:59 <agibiansky> yuck
20:48:48 <Pamelloes> I don't always install Haskell, but when I do, I make sure to do it /before/ upgrading OS X.
20:48:56 <agibiansky> Hahahah
20:48:58 <agibiansky> Homebrew perhaps?
20:49:19 <lilred> Yeah that's what I'm going for now
20:49:28 <lilred> I'm a recent Mac convert - ~2 weeks
20:49:28 <Pamelloes> I prefer MacPorts personally, but that's probably your best bet.
20:49:35 <glguy> You can install GHC directly from haskell.org or from that relocatable bundle that some people use
20:49:43 <agibiansky> Oh, yeah, ghc-dot-app is great
20:50:03 <agibiansky> Highly recommend it, actually
20:50:05 <glguy> I prefer just getting it direct from haskell.org/ghc , but lots of people swear by the app
20:50:08 <Pamelloes> ghc-dot-app? :O
20:50:25 <agibiansky> Pamelloes: https://github.com/ghcformacosx/ghc-dot-app
20:50:28 <agibiansky> movable ghc
20:50:37 <agibiansky> stick it wherever you want, update your $PATH, and done
20:50:57 <Pamelloes> I'm too much a die-hard shell user to consider using an app.
20:51:05 <lilred> ^
20:51:10 <glguy> You still use it from the shell
20:51:13 <agibiansky> It's just a directory that has ghc bundled
20:51:27 <Pamelloes> Huh. What a concept.
20:51:32 <glguy> so you don't have to worry about scratching your die-hard sticker
20:51:32 <agibiansky> You stick it wherever you want and set $PATH to ghc.app/Contents/MacOS/bin or something
20:51:40 <trap_exit> what light do you guys use when programming? I want something that lets me (1) not get glare on mbp and (2) able to see pad of paper + pen which I write with
20:52:00 <benzrf> trap_exit: i use my bed's covers as a shield from light
20:52:04 <Pamelloes> I'll look into it next time I install ghc at school.
20:52:09 * benzrf is under em right now
20:52:29 <trap_exit> i was thinking something like an overhead led
20:52:49 <lilred> trap_exit: have you considered sunlight
20:53:01 <Pamelloes> I use my room's overhead light. It has a relatively low color temperature though so I have a very white desk light I turn on when writing on paper.
20:53:01 <agibiansky> lilred: what's wrong with you that's terrifying
20:53:34 <Pamelloes> lilred: For some of us, sunset is 4:25 pm. Not very helpful :P
20:53:42 <Rufflewind> someone more familiar with FRP might know this: is there a fundamental difference between libraries like reactive-banana/sodium vs libraries like netwire?  is there something that one can do the other can't?  which one is better for modeling event-driven applications?
20:53:45 <lilred> yeah, here too. YAY CANADA
20:54:19 <lilred> question for my Mac-using friends - how do I set up SSH profiles? Like, I want to be able to connect to my VPS with minimal effort, how would you do that?
20:54:40 <BillyIII> ~/.ssh/config ?
20:55:00 <Pamelloes> What do you mean by ssh profiles?
20:55:26 <trap_exit> http://www.amazon.com/Koncept-AR5000-C-SIL-FLR-Z-Bar-Floor-Silver/dp/B00608TQV0 what are these lamps
20:55:29 <trap_exit> and why are they so expensive?
20:55:44 <trap_exit> lilred: you do it over sunlight
20:55:46 <Pamelloes> lilred: Settings->Sharing->Remote Login lets you configure your local ssh server. Not sure if that's what you're looking for.
20:55:48 <benzrf> Rufflewind: i've only taken a cursory look at netwire
20:55:51 <lilred> Pamelloes: basically, having a shortcut to starting a session with certain specific settings. Should I just write a bash script?
20:55:55 <trap_exit> lilred: you ssh into the sun , then you gounce into your mac
20:56:08 <benzrf> Rufflewind: but it's more focused on "functions of behaviors" and their composition than on the behaviors themselves
20:56:10 <trap_exit> it requires both the client and the server to have line of sight with the sun though
20:56:17 <Pamelloes> lilred: Write a bash script and give it the extension ".command"
20:56:26 <Pamelloes> Then you can double click it like an app.
20:56:47 <Rufflewind> benzrf: I see!
20:56:54 <lilred> so there's like no application that's basically an SSH phonebook
20:57:06 <benzrf> Rufflewind: the central type in netwire has a denotation of something like
20:57:15 <benzrf> Wire a b = Behavior a -> Behavior b
20:57:25 <BillyIII> Youhttps://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/ssh_config.5.html
20:57:25 <benzrf> obviously considerably more complex in practice
20:57:30 <benzrf> but that's the basic type of thing you work with
20:57:37 <Pamelloes> lilred: There might be, but not bundled with the OS.
20:57:42 <Rufflewind> benzrf: Ah
20:57:52 <benzrf> Rufflewind: actually it can also be to or from Events and you can have like Event a -> Behavior b
20:57:55 <lilred> alright, thanks Pamelloes.
20:57:56 <lilred> I
20:57:56 <benzrf> but that's not the main point
20:58:01 <lilred> I'm going to bed, night yall!
20:58:21 <Pamelloes> Night.
20:59:16 <Pamelloes> Are there any techniques for isolating I/O?
20:59:47 <agibiansky> Pamelloes: free monads can be used for that. You write an ADT representing your allowed operations, make a free monad out of that, then write an interpreter that converts your ADT to IO
21:00:04 <agibiansky> Are you familiar with the approach? I can find some resources if you would like
21:00:17 <Pamelloes> Not particularly, a resource would be appreciated :)
21:00:21 <agibiansky> ok, one sec
21:01:16 <Rufflewind> benzrf: I guess I'll understand more of what you said when I actually study it more :)
21:01:20 <agibiansky> googling 'free monads' gets a lot of good ones, actually, but here's an answer that talks about the pattern im refering to: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
21:01:58 <agibiansky> also good is http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html and http://stackoverflow.com/questions/13352205/what-are-free-monads
21:02:11 <agibiansky> it's somewhat of a tricky approach so reading a few takes on it helps, but it's a very beautiful pattern once it clicks
21:02:15 <Pamelloes> Thanks
21:02:19 <Pamelloes> I'll check it out :)
21:02:29 <benzrf> Rufflewind: familiar with the idea of denotational semantics?
21:14:22 * hackagebot Zora 1.1.20 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.20 (bgwines)
21:22:20 <zq> lol holy shit
21:22:32 <zq> i finally get that case exprs are strict in core
21:30:54 <ij> I've got http://i.imgur.com/0pmlFCd.png as input and http://i.imgur.com/1lew4Tr.png as output from http://sprunge.us/TOPN . Any ideas why does the output transform like that? Even without looking at the code, what is happening?
21:32:21 <benzrf> ij: it looks like you rotated and tiled a few of that shape
21:33:03 <agibiansky> ij: May have something to do with encodings. Are you using JPG or PNG or something? They may be interlaced line by line
21:33:40 <ij> it's a png
21:34:51 <agibiansky> ij: Does it do the same if you skip the numerify?
21:35:52 <ij> Types won't match then, but numerify is essential for what I'm going to do next.
21:42:03 <agibiansky> ij: I don't think it has anything to do with encodings, nvm what I said before
21:42:51 <Pamelloes> How do I import the Free Monad?
21:43:17 <agibiansky> The `free` package offers a bunch of convenience stuff for making free monads out of functors
21:43:27 <agibiansky> But you can also implement that pattern without using a package
21:43:32 <Pamelloes> Oh I see, it's not part of the standard library.
21:43:36 <agibiansky> No, it isn't
21:43:48 <Pamelloes> Well, that's what I was missing :)
21:43:59 <agibiansky> If you are doing this as an educational thing, I would recommend implementing it without the free package first
21:49:28 <agibiansky> ij: Did you figure it out? If not I may have an answer
21:50:57 <agibiansky> ij: http://lpaste.net/117259 – seems to work, I just fiddled with swapping the width and height in a bunch of places. What was happening was that somewhere they were off in order (probably in imageShape) and since you were converting to a list intermediately it was "wrapping" very weirdly
22:00:05 <ij> I was trying switching too, but in the wrong places. Yeah, imageShape's the problem. It seems that the Z data constr. wants y first.
22:20:57 <ij> Okay, no trying to make pde solvers at 8 AM.
22:21:01 <ij> night night!
22:21:15 <ij> or rather.. sleepy morning!
22:46:09 <magthe> what's the easiest way to see whether my attempts to "strict-ify" my code has any effect?
22:46:38 <zq> ghc coar
22:46:38 <agibiansky> magthe: What sort of effect are you looking for?
22:46:41 <agibiansky> Performance?
22:47:01 <agibiansky> If so, benchmark with criterion or similar might help? or the ghc profiling mode
22:48:47 <magthe> agibiansky: no, just some indication that my switch from using a lazy data type (a tuple), to one with bang-patterns, has some effect, whether it's speed or space doesn't really matter
22:49:32 <agibiansky> magthe: Erm, hard to say exactly, but you could put 'trace' calls in your code and see when they print?
22:49:58 <agibiansky> That might be tricky though, not sure I know of another general solution though
22:50:10 <agibiansky> (I am definitely not an expert on these sort of things though)
22:50:36 <magthe> agibiansky: I was hoping that the lack of thunks would be observable in some way
22:51:55 <agibiansky> You can definitely observe it indirectly via looking at allocations or performance; you can observe it by having the thunk evaluation have a real side effect (printing things) via trace or unsafePerformIO. You can also look at the number of thunks allocated directly via GHC's profiling mode, I don't remember what the exact flags are but it can output a graph indicating # of thunks allocated and on the heap and such
22:53:07 <enthropy> > Just undefined
22:53:08 <lambdabot>  Just *Exception: Prelude.undefined
22:53:13 <enthropy> > Just $! undefined
22:53:14 <lambdabot>  *Exception: Prelude.undefined
22:58:43 <magthe> agibiansky: I'm looking at the output of '+RTS -s' but don't really know what to look for
22:58:51 <benzrf> > const 3 $ undefined
22:58:52 <lambdabot>  3
22:58:54 <benzrf> > const 3 $! undefined
22:58:55 <lambdabot>  *Exception: Prelude.undefined
22:59:57 <agibiansky> magthe: Maybe this will help? http://stackoverflow.com/questions/5306717/how-should-i-interpret-the-output-of-the-ghc-heap-profiler
23:00:32 <agibiansky> hp2ps seems like it might give you a graph with a THUNK output
23:04:27 * hackagebot MuCheck 0.1.1.0 - Automated Mutation Testing  http://hackage.haskell.org/package/MuCheck-0.1.1.0 (RahulGopinath)
23:08:38 <Geekingfrog> Question: I have a list of tuple like [("foo", 1), ("bar", 0)] and I want the minimum (with respect to the second part of the tuple). I have something working with `minimumBy (\a b -> compare (snd a) (snd b)) list` but I was wondering if there was a way to write that point free?
23:09:04 <Geekingfrog> That is, somehow be able to compose `compare` with `snd`
23:09:10 * Geekingfrog is not very advanced
23:09:27 * hackagebot cassava-conduit 0.0.1 - Conduit interface for cassava package  http://hackage.haskell.org/package/cassava-conduit-0.0.1 (domdere)
23:09:29 <benzrf> Geekingfrog: yes indeed!
23:09:39 <benzrf> Geekingfrog: there's a delightful function called "comparing" which does this:
23:09:41 <benzrf> :t comparing
23:09:42 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:09:44 <magthe> agibiansky: thanks!
23:09:52 <agibiansky> Geekingfrog: Also check out `on`
23:09:54 <agibiansky> :t on
23:09:55 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
23:10:06 <agibiansky> I often use things like "compare `on` snd"
23:10:14 <benzrf> agibiansky: comparing snd is more concise
23:10:20 <benzrf> @src comparing
23:10:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:10:23 <benzrf> pfft
23:10:38 <agibiansky> benzrf: Good point, that's not a good example as comparing exists
23:10:41 <benzrf> Geekingfrog: comparing f x y = compare (f x) (f y)
23:11:51 <agibiansky> Is there an equivalent of `comparing` for ==? I always hate writing (==) `on` f as it yields very ugly code
23:12:46 <agibiansky> "((==) `on` (unLoc . ideclName)) decl imp" yuck
23:14:02 <Geekingfrog> thanks benzrf and agibiansky
23:14:32 <benzrf> agibiansky: strictly speaking you can do comparing
23:14:34 <benzrf> then check for Eq
23:15:15 <agibiansky> Yeah, that's not much nicer though. You get (== EQ) . comparing f instead of (==) `on` f
23:15:48 <agibiansky> hoogle for "Eq a => (b -> a) -> b -> b -> Bool" does not yield anything
23:15:49 <agibiansky> oh well
23:17:25 <enthropy> @let equating f = on (==) f
23:17:28 <lambdabot>  Defined.
23:17:39 <agibiansky> :)
23:18:08 <jle`> :t equating id
23:18:09 <lambdabot> Eq b => b -> b -> Bool
23:18:27 <jle`> > equating abs 10 (-10)
23:18:28 <lambdabot>  True
23:25:46 <ij> How do I iterate my "a -> m a" to yield m [a]? Doesn't replicateM just copy them?
23:27:22 <agibiansky> ij: I thought you were asleep :) and yeah, replicateM just copies them.
23:27:34 <agibiansky> perhaps something with `iterate` and `join` might work, though doubt it
23:27:44 <ij> I couldn't give up.
23:27:58 <agibiansky> Actually, the idea of iterateM is problematic
23:28:10 <sivteck> traverse?
23:28:13 <sivteck> :t traverse
23:28:14 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:28:15 <benzrf> agibiansky: like hell it is
23:28:28 <agibiansky> A little bit, anyways
23:28:46 <benzrf> oh wait
23:28:51 <agibiansky> Things like IO and ST do not place nicely with iterateM
23:28:51 <benzrf> sorry i thought you mean repeatM
23:28:58 <agibiansky> since they would just be infinite
23:29:05 <benzrf> hmm
23:29:15 <benzrf> :t iterate
23:29:16 <lambdabot> (a -> a) -> a -> [a]
23:29:23 <benzrf> @src iterate
23:29:24 <lambdabot> iterate f x = x : iterate f (f x)
23:29:27 <agibiansky> I imagine it might make sense for lazier monads, though
23:30:01 <agibiansky> ij: What context do you want iterateM in?
23:30:33 <ij> I've something like diffuse :: Array -> IO Array. I want to diffuse multiple times, accumulate results.
23:30:41 <agibiansky> Perhaps something else in Control.Monad.Loops would work?
23:31:08 <agibiansky> there's iterateUntilM I think
23:32:42 <benzrf> iterateA :: (a -> f a) -> a -> f [a]; iterateA f x = fmap (x:) (iterateA f >>= (f x))
23:32:45 <benzrf> @let iterateA :: (a -> f a) -> a -> f [a]; iterateA f x = fmap (x:) (iterateA f >>= (f x))
23:32:46 <lambdabot>  .L.hs:191:12:
23:32:47 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
23:32:47 <lambdabot>      from the context (Num b, Enum b)
23:32:52 <benzrf> bwah
23:32:53 <agibiansky> Alternatively if you want to iterate a fixed number of times, you can foldl (>>=) (return initValue) $ replicate numTimes myOperation
23:33:00 <benzrf> @let iterateA :: (a -> f a) -> a -> f [a]; iterateA f x = fmap (x:) (iterateA f =<< (f x))
23:33:01 <lambdabot>  .L.hs:255:16:
23:33:01 <lambdabot>      No instance for (Functor f) arising from a use of ‘fmap’
23:33:01 <lambdabot>      Possible fix:
23:33:15 <benzrf> @let iterateA :: (Functor f, Monad f) => (a -> f a) -> a -> f [a]; iterateA f x = fmap (x:) (iterateA f =<< (f x))
23:33:17 <lambdabot>  Defined.
23:33:34 <benzrf> try eet
23:33:42 <ij> Something really didn't work there, I tried to stitch something up with iterate.
23:34:06 * ij tries.
23:34:43 <benzrf> :t repeatM
23:34:44 <lambdabot>     Not in scope: ‘repeatM’
23:34:44 <lambdabot>     Perhaps you meant one of these:
23:34:44 <lambdabot>       ‘repeat’ (imported from Data.List),
23:34:50 <benzrf> @let repeatM = sequence . repeat
23:34:52 <lambdabot>  Defined.
23:35:00 <benzrf> @let cantor = repeatM [True, False]
23:35:02 <lambdabot>  Defined.
23:35:09 <benzrf> > cantor !! 23
23:35:14 <lambdabot>  mueval: ExitFailure 1
23:35:18 <benzrf> wait.
23:35:21 <shiona> would it be somehow possible to build a version of the function "on", that wouldn't require the two value parameters to be of the exactly same type, but possibly only of a same class?
23:35:32 <benzrf> :t cantor
23:35:33 <lambdabot> [[Bool]]
23:35:37 <benzrf> hold on a second.
23:35:40 <agibiansky> shiona: What do you mean? How would you use it?
23:35:45 <benzrf> > cantor
23:35:48 <ij> Works!
23:35:50 <lambdabot>  mueval: ExitFailure 1
23:35:59 <benzrf> i just confused myself
23:36:01 <agibiansky> ij: What was your final solution?
23:36:06 <ij> benzrf's solution
23:36:11 <shiona> something like  on (\a  b -> a == (floor b)) abs 1 (-1.2)
23:36:14 <agibiansky> iterateA?
23:36:26 <ij> Yes.
23:36:43 <shiona> where 1 would be an Int and (-1.2) a Float
23:36:45 <agibiansky> How come that doesn't take an infinite amount of time?
23:36:54 <ij> It does.
23:37:11 * ij tries to limit it.
23:37:24 <agibiansky> ij: Oh, you just have intermediate results being output. I see. If that's what you want, there's iterateM_ in Control.Monad.Loops?
23:38:08 <ij> I so hate it when I accidentally open up docs on hackage, but for an ancient version of the pkg.
23:38:53 <agibiansky> shiona: Perhaps something using existentials/rank n types? Hmm...
23:40:13 <benzrf> @let repeatL = transpose . repeat
23:40:15 <lambdabot>  Defined.
23:40:22 <benzrf> @let notCantor = repeatL [True, False]
23:40:24 <lambdabot>  Defined.
23:40:28 <benzrf> > notCantor
23:40:30 <lambdabot>  [[True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
23:40:33 <benzrf> > notCantor !! 234
23:40:34 <shiona> agibiansky: do you think it might be useful at all
23:40:38 <lambdabot>  mueval: ExitFailure 1
23:40:42 <benzrf> > notCantor !! 2
23:40:47 <lambdabot>  mueval: ExitFailure 1
23:40:49 <benzrf> welp
23:41:22 <benzrf> oh wait i'm dumbbbb
23:41:29 <benzrf> oh well it doesnt matter
23:41:37 <agibiansky> shiona: I'm not sure how to make it work, actually
23:41:58 <agibiansky> you would have something like on' :: (b -> b -> c) -> (??? -> b) -> a -> a' -> c
23:42:05 <agibiansky> and you want to specify that ??? could be a or a'
23:42:42 <shiona> actually the first function can't be (b -> b -> c) either, if you go by my example
23:42:53 <agibiansky> Oh, good point
23:43:28 <agibiansky> b -> b' -> c
23:43:36 <agibiansky> where the 2nd function maps a -> b and a' -> b'
23:43:41 <shiona> yeah
23:44:51 <agibiansky> yeah, i don't know how you would specify that in the type system. that is type trickery beyond my abilities...
23:45:12 <magthe> agibiansky: so, now I do know what to look for... and I do see a big change in memory use when using a stricter datatype (a type annotated with !)
23:45:59 <magthe> then I tried to switch back, auto derive NFData and use `deepseq`, and none of my thinking works again, haha
23:46:38 <agibiansky> magthe: Are you auto deriving it with template Haskell? Or how? And what do you mean by doesn't work?
23:47:32 <agibiansky> Be careful with deepseq, btw – it can make your program very slow it you use it a lot. A deepseq requires a full traversal of your data structure usually, so if you do it a lot it will make many traversals and slow things down
23:48:25 <magthe> I'm deriving it via `GenericDerive`
23:48:36 <agibiansky> Ah, okay
23:48:40 <magthe> oups, mean `DeriveGeneric`
23:48:55 <agibiansky> Do you mean that your memory usage goes back up?
23:49:43 <ij> agibiansky, All the loops are almost promising. i'll have to change it a bit, because iterateM_ saves only the last one.
23:50:40 <agibiansky> ij: By save the last one, do you mean that it only depends on the last thing generated?
23:51:20 <agibiansky> Or that it outputs the last thing? Because unlike `iterate` which outputs a list `iterateM_` doesn't output anything, since it loops forever (note how the return type is `m b` even though there is no `b` mentioned elsewhere!)
23:51:21 <magthe> agibiansky: yupp... the original, non-strict-ified version used something like 600M, switch to strict data type and it went remarkably... then switch back to using tuples, and derive `NFData` for the "wrapper type" and put a `deepseq` in the place I thought was where thunks were built; back to 600M
23:52:43 <agibiansky> Hmm
23:52:58 <agibiansky> Sounds confusing, I don't know. Perhaps the `deepseq` is actually too late?
23:54:16 <agibiansky> And by the time `deepseq` rolls around you've accumulated 600M worth of thunks (which is strange, means they are not all one thunk but somehow you have semi-strictness that creates lots of little thunks), then deepdseq spends time evaluating it?
23:54:24 <agibiansky> What is the data structure storing all these thunks?
23:55:52 <ij> oh, you're right
23:55:56 <ij> it loops forever
23:56:27 <ij> Well, I can do with that too.
23:56:32 <agibiansky> ij: Yeah, it has to. IO doesn't permit laziness like pure values do
23:59:51 <ij> Third time getting really excited by this, the result is near!
