00:08:05 <Zemyla> Sweet Jesus, I'm looking at printf, and the fact that it has freaking varargs in a strongly typed language, it's like frigging space magic.
00:09:10 <bernalex> ReinH: that's a very pleasant coincidence. :-]
00:09:49 * hackagebot scientific 0.3.3.3 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.3 (BasVanDijk)
00:09:49 * hackagebot egison 3.4.0 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.4.0 (SatoshiEgi)
00:18:25 <ReinH> bernalex: :)
00:23:32 <DblZ> is there a way to at runtime compile haskell scripts into my c++/c sharp application
00:24:51 <torpet> why does the maximum find the last occurence in a list if there are 2 equal values?
00:25:33 <Hafydd> > maximumBy (const (const EQ)) [1, 2]
00:25:34 <lambdabot>  2
00:28:32 <Hafydd> It just defaults to the last element, by an implementation detail, I suppose.
00:28:48 <Hafydd> I think the specification would even admit an implementation with different behaviour.
00:28:54 <Hafydd> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.1/src/Data-List.html#maximumBy
00:32:03 <Zemyla> @pl \a b -> 1
00:32:04 <lambdabot> const (const 1)
00:32:34 <DblZ> is there a way to at runtime compile haskell scripts into my c++/c sharp application
00:32:54 <torpet> I am having a list like [("Team A", 5), ("Team B", 8)] etc
00:32:59 <torpet> 5 and 8 are the points
00:33:19 <simpson> DblZ: It's possible to make shared libraries in Haskell which export C symbols.
00:33:35 <Raydiation> regarding the maybe monad: could you simplify it into: function maybe($value, $callback) {
00:33:35 <Raydiation>     if ($value !== null)
00:33:35 <Raydiation>         $callback($value);
00:33:35 <Raydiation> }
00:33:40 <torpet> now given the points, how do I replace the points with the position
00:33:46 <torpet> eg the team with 8 points would have rank 1
00:34:03 <Raydiation> if null is your Nothing type
00:36:59 <shachaf> Raydiation: No.
00:37:17 <Hafydd> > let l = [("Team A", 5), ("Team B", 8)] in zipWith (\r (t,_) -> (t,r)) [1..] (sort l)
00:37:18 <lambdabot>  [("Team A",1),("Team B",2)]
00:37:20 <shachaf> Well, the question doesn't make sense in the first place, since the thing you're talking about is a functin, not a monad.
00:37:36 <Hafydd> Well, that should be (reverse (sort l)) instead.
00:37:42 <shachaf> But the distinction between e.g. Nothing and Just Nothing is a very important one, and "null" loses that.
00:37:57 <Raydiation> shachaf: yeah, just saw a different post that makes sense http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html
00:38:11 <shachaf> That title isn't promising...
00:39:15 <Hafydd> Or indeed (sortBy (flip compare) l).
00:39:54 <shachaf> Nope, that person doesn't seem to know what they're talking about.
00:40:01 <Raydiation> i see :)
00:40:01 <Hafydd> Uh, (flip (compare `on` snd)).
00:40:16 <Zemyla> shachaf: The only thing that could hold Just Nothing is Maybe (Maybe a), which is two layers of indirection.
00:40:34 <Zemyla> It'd be like an object that holds null.
00:40:50 <shachaf> Zemyla: Yes?
00:40:58 <Zemyla> In Perl parlance, \(undef).
00:41:14 <shachaf> Not really.
00:41:28 <shachaf> Anyway, you'll note that join :: Maybe (Maybe a) -> Maybe a
00:42:19 <Raydiation> shachaf: you mean that null has so many meanings that sometimes it can not be considered to be the same as Nothing?
00:42:34 <Raydiation> i mean Nothing is just a type right?
00:42:49 <shachaf> Nothing isn't a type.
00:42:57 <Zemyla> Nothing is an object, of type Maybe a.
00:43:09 <Zemyla> :t Nothing
00:43:10 <lambdabot> Maybe a
00:43:16 <Zemyla> :t Just Nothing
00:43:17 <Raydiation> ah right, otherwise you couldnt bind stuff to it
00:43:17 <lambdabot> Maybe (Maybe a)
00:43:51 <shachaf> You don't "bind stuff" to a value :: Maybe A
00:44:10 <shachaf> The thing that's being bound to is the argument to the function, if anything. It's a slightly confusing name so I recommend ignoring it.
00:51:43 <moop> i wonder what bind has to say to all this highlighting he's constantly getting from this channel
00:52:27 <shachaf> he?
00:52:45 <thebnq> the nick :P
00:54:05 <shachaf> I understood that.
00:54:21 <eXeC64> I used to treat "exec" as a highlight keyword for myself, but I had to disable it when I spent time in the Qt channel
00:54:30 <eXeC64> waaay to many people saying "foo.exec()"
00:55:58 <moop> good thing i only get random highlights when people reference seinfeld or south park
00:57:50 <Zemyla> I get random highlights when people say "eczema" and "amazement".
00:58:02 <torpet> how do i map V in [((V, N), I)]?
00:58:19 <torpet> map fst $ map fst?
00:58:29 <shachaf> That's a type error.
00:58:55 <shachaf> You'll need a function to map over the first element of a tuple.
00:59:31 <shachaf> If that function is called first, then something like (map . first . first).
00:59:41 <moop> can't it be done with pattern matching?
01:00:15 <moop> map' ((v, _), _)
01:00:51 <shachaf> You can write map (\((x,y),z) -> ((x',y),z)) if you want.
01:00:56 <shachaf> What you wrote doesn't make sense.
01:04:19 <rjsalts> Are there any haskell dns libraries that support TSIG? I can only see https://github.com/kazu-yamamoto/dns in hackage
01:13:27 <capisce> torpet: you can use Control.Lens: map (_1 . _1 %~ (+1)) [((1,2),0), ((2,2),0)]
01:14:26 <shachaf> capisce: Why use map in that case?
01:14:32 <capisce> or Control.Arrow: map (first (first (+1))) [((1,2),0), ((2,2),0)]
01:14:34 <torpet> HmI got it to work with map fst $ map fst
01:14:35 <shachaf> over (mapped . _1 . _1) (+1) ...
01:14:48 <capisce> alternatively: map (((+1) *** id) *** id) [((1,2),0), ((2,2),0)]
01:14:54 <shachaf> Wait, maybe you're not even talking about what it sounded like you were talking about.
01:14:57 <shachaf> I assumed too much again.
01:15:09 <shachaf> sigh
01:15:49 <torpet> :D
01:15:57 <thebnq> torpet: often its helpful to have a type sig first :)
01:16:11 <torpet> yeah im sorry :/
01:16:18 <thebnq> for both the learnee and the learned :3
01:16:18 <torpet> my question was a bit vague
01:16:19 <capisce> can still use Control.Lens then: map (^. _1 . _1)
01:16:45 <moop> lens scare me
01:16:45 <shachaf> map (fst . fst)
01:16:47 <moop> :(
01:17:03 <shachaf> You're allowed to use functions even if you import Control.Lens
01:17:07 <capisce> or what shachaf said
01:21:00 <hunt> haskell if ur bored come help please
01:21:01 <hunt> http://cursors.io/
01:37:47 <erikd> hunt: how is that related to haskell?
01:37:58 <hunt> its not
01:38:02 <hunt> its a haskell blah comment
01:38:07 <hunt> but i couldnt find haskell blah
01:39:22 <sivteck> #==~~ #haskell-blah ~~==#
01:41:23 <moop> hunt: that game pissed me off so much i had to close it
01:41:44 <moop> :(
02:15:17 <bryanedds> Is (M a -> (a -> M a) -> M a) still a monad?
02:15:37 <shachaf> No, it's a type.
02:16:01 <bryanedds> is it a functor?
02:16:07 <bryanedds> I mean, applicative
02:16:10 <shachaf> It's the type of a function.
02:16:16 <bryanedds> ah shit
02:16:19 <bryanedds> I mean
02:17:00 <bryanedds> would a monad that requires a bind of this increased restriction still a monad?
02:17:28 <shachaf> No.
02:17:37 <bryanedds> hm
02:17:55 <bryanedds> could it still use the do syntax?
02:18:21 <shachaf> I feel like you're not asking your real question.
02:18:33 <BoR0> what's "increased restriction" in this context?
02:18:44 <shachaf> I'll go with "no" (but with a GHC extension you could make do mean whatever you want it to).
02:18:47 <bryanedds> My real question is in F#, so I doubt it will mean much
02:19:22 <shachaf> F# again
02:19:25 <BoR0> the type of (M a -> (a -> M a) -> M a) with a constraint Monad M matches that of bind
02:19:48 * hackagebot linear-opengl 0.2.0.4 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.4 (BenGamari)
02:19:51 * hackagebot cgrep 6.4.9 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.9 (NicolaBonelli)
02:20:38 <bryanedds> Maybe the question better asked is -
02:21:25 <bryanedds> If I can only define bind in terms of M a -> (a -> M a) -> M a for a given type, can that type still qualify as a monad?
02:22:22 <shachaf> bind is complicated. Simpler with join/fmap/return
02:22:28 <shachaf> You need fmap :: (a -> b) -> M a -> M b
02:22:43 <shachaf> (I already asked the question you asked.)
02:23:34 <bryanedds> I guess I could try defining join or fmap instead since bind can be defined in terms of those?
02:26:37 <bryanedds> hm, same issue
02:27:27 <bryanedds> always end up constraining b to a
02:27:39 --- mode: ChanServ set +o shachaf
02:28:01 <bryanedds> the problem must be with the type
02:28:50 --- mode: shachaf set +bb maxcan!*@*$##fixyourconnection kvieta!*@*$##fixyourconnection
02:28:53 --- mode: shachaf set -o shachaf
02:29:09 <bryanedds>     type 'a Desync = { Operation : 'a; OptNext : 'a Desync option }
02:29:13 <angerman> so, ghc complains that I did not provide a typesignature, and offers one. When I copy'n'paste the signature, ghc complains that I it's ambigurous?
02:29:15 <angerman> great.
02:29:35 <bryanedds> dunno if that's legible, can try to convert to haskell
02:29:41 <Iceland_jack> angerman: Which signature did it suggest? That may be a bug
02:30:13 <shachaf> It isn't legible. You might try #fsharp for F# code.
02:30:22 <angerman> Iceland_jack: hmm... let me try something, maybe I was just stupid.
02:31:18 <angerman> Iceland_jack: ohh yes I was. I used a type alias instead of the full blown type signature ghc suggested.  And thereby I introduced an abiguity. Ouch.
02:32:56 <bryanedds> data Desync a = { operation :: a; optNext :: Maybe Desync a }
02:33:12 <bryanedds> there, I think
02:33:43 <bryanedds> F# room is dead, and if it weren't there's never anyone in there that I can talk to about such things
02:33:53 <shachaf> That's a kind error.
02:34:02 <shachaf> Well, if you fix the syntax error.
02:34:34 <shachaf> Not being an F# place, people here don't know what Desync is.
02:34:46 <bryanedds> It's a data type I made up
02:34:50 <bryanedds> has nothing to do with F#
02:34:57 <shachaf> Oh, I did misread that.
02:35:11 <shachaf> OK. Well, you can implement fmap for that.
02:35:30 <Iceland_jack> I guess it would be:
02:35:31 <Iceland_jack>     data Desync a = MkDesync { operation :: a, optNext :: Maybe (Desync a) }
02:35:31 <Iceland_jack> in Haskell
02:35:33 <shachaf> That's just the type of non-empty lists.
02:36:04 <Iceland_jack> GHC can derive a Functor instance for that automatically
02:38:48 <bryanedds> I can't seem to get fmap to type check
02:39:11 <Iceland_jack> bryanedds: the type of fmap should be (a -> b) -> Desync a -> Desync b
02:39:23 <bryanedds> right
02:39:24 <Iceland_jack> and you need to use the Functor instance for Option/Maybe there
02:39:31 <bryanedds> but the impl won't type check
02:39:34 <bryanedds> I'll try to translate
02:39:58 <Iceland_jack> This is the instance generated by GHC (via -ddump-deriv):
02:39:58 <Iceland_jack> instance Functor Desync where
02:39:58 <Iceland_jack>   fmap f_ab0O (MkDesync a1_ab0P a2_ab0Q) = MkDesync (f_ab0O a1_ab0P) (fmap (fmap f_ab0O) a2_ab0Q)
02:40:46 <Iceland_jack> Cleaned up version:
02:40:46 <Iceland_jack>   instance Functor Desync where
02:40:46 <Iceland_jack>     fmap f (MkDesync operation next) = MkDesync (f operation) (fmap (fmap f) next)
02:41:47 <bryanedds> let fmap f m = let n = f $ operation m in mkDesync (operation n) (Just n)
02:41:48 <Iceland_jack> Or:
02:41:48 <Iceland_jack>   instance Functor Desync where
02:41:48 <Iceland_jack>     fmap f (MkDesync operation Nothing)     = MkDesync (f operation) Nothing
02:41:48 <Iceland_jack>     fmap f (MkDesync operation (Just next)) = MkDesync (f operation) (Just (fmap f next))
02:41:50 <bryanedds> *compares the two*
02:42:26 <bryanedds> ugh, that destructuring in the 2nd param makes it hard for me to read
02:43:41 <bryanedds> hm, in your fmap is called recursively
02:44:08 <Peaker> MissingH is such a silly package, aggregating arbitrary/random stuff without any sensibility
02:44:12 <Iceland_jack> Yes, one of the fmap's belongs to Desync, the other belongs to Maybe
02:44:54 <Iceland_jack> Recall that 'fmap' has both these types, among others:
02:44:54 <Iceland_jack>     fmap :: (a -> b) -> Desync a -> Desync b
02:44:54 <Iceland_jack>     fmap :: (a -> b) -> Maybe  a -> Maybe  b
02:47:00 <bryanedds> well I'll be dipped!
02:47:04 <bryanedds> It type checks!
02:47:09 <bryanedds> god I'm retarded
02:47:20 <Iceland_jack> no need for that language
02:47:43 <bryanedds> atheist?
02:48:21 <bryanedds> now I just have to implement bind in terms of fmap, ya?
02:48:29 <breadmonster> Guys, does anyone use Windows here?
02:48:39 <Iceland_jack> we avoid using "retarded" here
02:48:57 <Iceland_jack> bryanedds: You can't implement bind using fmap alone
02:49:37 <bryanedds> ah crap, really?
02:50:04 <pavonia> breadmonster: Why do you ask?
02:50:09 <bryanedds> ah, I have to define join too?
02:50:28 <bryanedds> god, that one's as hard as bind!
02:51:02 <Iceland_jack> You can define join in terms of bind:
02:51:03 <Iceland_jack> @src join
02:51:03 <lambdabot> join x = x >>= id
02:51:23 <bryanedds> ya, but bind is what I can't define because I'm an idiot
02:51:25 <Iceland_jack> Where (>>=) is bind and 'id' is the identity function 'id x = x'
02:51:49 <prophile> x >>= f = join (fmap f x)
02:52:11 <Iceland_jack> Yes and as prophile mentioned you can do the reverse: define bind in terms of join + fmap
02:52:11 <bryanedds> I guess I'll try to define join tho it seems hard to do
02:52:18 <Iceland_jack> so whatever seems simpler
02:52:45 <Iceland_jack> Do you understand 'join' on other monads?
02:52:57 <bryanedds> I understand it on Maybe
02:53:04 <bryanedds> but Maybe is simple
02:53:04 <Iceland_jack> like 'join :: [[a]] -> [a]':
02:53:04 <Iceland_jack> > join ["for ", "list", " ", "monad"]
02:53:06 <lambdabot>  "for list monad"
02:53:29 <bryanedds> > join (Just 1) None
02:53:30 <lambdabot>  Not in scope: data constructor ‘None’
02:53:31 <lambdabot>  Perhaps you meant one of these:
02:53:31 <lambdabot>    ‘Node’ (imported from Data.Tree),
02:53:31 <lambdabot>    ‘Nonn’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
02:53:37 <bryanedds> > join (Just 1) Nothing
02:53:37 <Iceland_jack>     join :: [[a]]           -> [a]
02:53:37 <Iceland_jack>     join :: Maybe (Maybe a) -> Maybe a
02:53:38 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1 -> t’
02:53:38 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
02:53:43 <Iceland_jack> > join (Just Nothing)
02:53:44 <lambdabot>  Nothing
02:53:46 <Iceland_jack> > join (Just (Just 10))
02:53:48 <lambdabot>  Just 10
02:54:09 <bryanedds> > join (Just 1) Nothing
02:54:10 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1 -> t’
02:54:11 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
02:54:22 <bryanedds> weird
02:54:27 <sgronblo> not weird
02:54:31 <prophile> join only takes one argument
02:54:34 <bryanedds> oh wait
02:54:34 <Iceland_jack> bryanedds: As you can see from the type, join only takes a single argument of type 'Maybe (Maybe a)'
02:54:40 <bryanedds> so then yes, I do not understand join
02:54:53 <bryanedds> M M a -> M a
02:54:55 <chrisdotcode> Does Either not have a fail implementation? I don't see one on https://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Either.html#Either
02:54:56 <Iceland_jack> It's quite simple to define :) it collapses the Maybe
02:55:12 <sgronblo> yeah that type says it all
02:55:34 <Iceland_jack>     join :: Maybe (Maybe a) -> Maybe a
02:55:34 <Iceland_jack>     join Nothing         = Nothing
02:55:34 <Iceland_jack>     join Just Nothing    = Nothing
02:55:34 <Iceland_jack>     join (Just (Just x)) = Just x
02:55:35 <Peaker> bryanedds: In Haskell syntax, it is: M (M a) -> M a
02:55:42 <prophile> chrisdotcode: no, it doesn't - you'd need to be able to construct a from String in Either a b which isn't possible in general
02:55:58 <sgronblo> your attempted usage has the type incorrectJoin :: Ma -> Ma -> Mystery
02:55:59 <chrisdotcode> prophile: Well that's unfortunate. Thank you.
02:56:34 <Iceland_jack> bryanedds: Try looking at that definition of join and run some examples to verify your intuition
02:57:03 <bryanedds> I understand its semantics, but not how they apply to my type
02:57:13 <prophile> what is your type?
02:57:18 <bryanedds> to me, M (M a) on my type has no meaning to me
02:57:50 <prophile> if M (M a) is meaningless then there may not be a Monad instance :)
02:57:56 <bryanedds> data Desync a = { operation :: a; optNext :: Maybe (Desync a) }
02:58:17 <bryanedds> oh, I'm sure it has meaning, but it's entirely opaque to me
02:58:23 <prophile> ah
02:58:30 <bryanedds> (not sure if that's correct syntax, BTW)
02:58:39 <prophile> so Desync is actually a non-empty list right
02:58:46 <torpet> i have 2 lists, how can i filter out elements of of list2 in list1
02:58:52 <torpet> basically i want  a set difference
02:58:54 <Iceland_jack> torpet: (\\)
02:58:56 <prophile> join flattens two levels of non-empty lists into one
02:58:58 <torpet> thx
02:59:02 <bryanedds> It sort of acts like a list, I suppose?
02:59:15 <Iceland_jack> > "abcd" \\ "ab"
02:59:16 <lambdabot>  "cd"
02:59:31 <Iceland_jack> It won't deal with duplicates torpet, for that you want (Data.Set.\\)
02:59:53 <Iceland_jack> > S.fromList "aabbccddcc" S.\\ S.fromList "ab"
02:59:55 <lambdabot>  fromList "cd"
03:00:05 <prophile> bryanedds: if you can convert between two things losslessly, they're effectively the same thing
03:00:22 <prophile> in this case you can convert between Desync a and a non-empty list of a losslessly
03:00:28 <bryanedds> But the problem is that while a list of lists has meaning to me, a Desync of Desync doesn't
03:00:46 <bryanedds> I just have no intuition for this stuff
03:00:47 <prophile> well, it's not necessarily a sensible monad
03:01:02 <torpet> Iceland_jack: actually i want remove duplicates so thats a good thing
03:01:04 <torpet> :)
03:01:05 <bryanedds> I have to assume it is to move forward
03:01:32 <bryanedds> join for a lot of monads make no sense to me
03:01:45 <prophile> well, for which others does it not make sense?
03:01:48 <prophile> we can try to explain
03:01:49 <bryanedds> monads in general make little sense to me
03:02:01 <Iceland_jack> torpet: If you want to remove duplicates then I suspect you don't care about other things like ordering in which case you should just go with Data.Set :)
03:02:07 <prophile> they're just monoids in the category of endofunctors on Hask, what's the problem? /s
03:02:20 <bryanedds> Reader, Writer, State, Cont
03:02:33 <bryanedds> I think the only ones that do make sense are List and Maybe
03:03:02 <prophile> Cont is just confusing anyway
03:03:12 <bryanedds> Interp
03:03:20 <bryanedds> ya, pretty much all be those two :)
03:03:24 <bryanedds> *but
03:03:26 <prophile> to look at the others, what a monad does in some sense is lets you always go to one level of structure
03:03:36 <prophile> "return" goes from zero levels to one, and "join" goes from two to one
03:03:52 <prophile> so no matter how many levels of structure you have, you can always collapse it down to one
03:04:06 <prophile> with lists, for instance, no matter how deeply nested they are you can always join it down to one flat list
03:04:08 <prophile> right?
03:04:20 <bryanedds> right, and I understand that in general
03:04:27 <prophile> okay, so
03:04:32 <prophile> to look at reader
03:04:52 <prophile> two levels of (->) r means you have an r -> r -> a
03:04:56 <prophile> three would be r -> r -> r -> a
03:05:10 <prophile> how can you collapse a function that takes n values of type r to one that only takes one value of type r?
03:05:18 <prophile> you pass in the same value to every argument
03:05:19 <chrisdotcode> prophile: quick 10 seconds question
03:05:32 <prophile> chrisdotcode: yeah?
03:05:37 <chrisdotcode> Is it more preferable to make make code use Either, or a data type with a built in failure? So:
03:05:37 <chrisdotcode> Either FailureType Success or
03:05:37 <chrisdotcode> data Value = FailureType | Success ?
03:06:04 <bryanedds> on a type level that makes sense, but that doesn't give any semantics to inform my intution is the problem
03:06:33 <prophile> bryanedds: so join f takes f which accepts two argument, and gives you a function which accepts one then uses it twice
03:06:39 <Iceland_jack> chrisdotcode: The latter, but it depends
03:06:40 <prophile> so join f = \x -> f x x
03:07:02 <tnks> chrisdotcode: i prefer Either because it plays with EitherT directly.
03:07:09 <Iceland_jack> chrisdotcode: Can you be more specific with your failure? I often do something like:
03:07:09 <Iceland_jack>     data ServiceStatus = ServiceUp
03:07:09 <Iceland_jack>                        | ServiceDown
03:07:14 <tasker> don't suppose anyone knows of a tool to take a load of image frames, and turn them into a gif ?
03:07:17 <bryanedds> :t join
03:07:18 <lambdabot> Monad m => m (m a) -> m a
03:07:29 <tasker> (I am aware this is not a haskell question.. but the images were generated with haskell!)
03:07:48 <bryanedds> hmm... okay, I will try sometting
03:07:59 <chrisdotcode> Iceland_jack, tnks: Returning information from an API. The API could either have semantic failure information (the failure type), or the successful return value
03:09:06 <bryanedds> sorry, no, I don't get it
03:09:23 <chrisdotcode> I'm basically deciding if my type signatures are going to look like this:
03:09:24 <chrisdotcode> IO (Either Failure Success) or
03:09:24 <chrisdotcode> IO (FailureOrSuccessType)
03:09:32 <bryanedds> I don't know where you get x?
03:10:09 <tnks> chrisdotcode: you're going to have to use your best judgement with respect to consumption.
03:10:14 <prophile> bryanedds: it's just the name in the lambda expression
03:10:21 <prophile> we can look at writer instead, that might be simpler?
03:10:28 <prophile> are you familiar with Monoid?
03:10:29 <bryanedds> I know, bit I don't know what it means
03:10:32 <bryanedds> maybe we should concentrate on the type in front of me?
03:10:46 <bryanedds> If I can figure that out, I can study it later
03:10:48 <prophile> perhaps, but join is quite a bit more complicated for that type
03:10:49 <chrisdotcode> I'm veering towards Either. It seems currently the most simplistic to work with, tnks.
03:11:15 <bryanedds> would you mind tho?
03:11:26 <sgronblo> I think Haskell should have made Either an Either and have a different type for Success/Failure
03:11:26 <bryanedds> I think I can get it with a few hints
03:11:29 <tnks> if I'm using EitherT's a lot internally, I'm not sure of it's hostile to just pass them along.
03:12:04 <bitonic> sgronblo: there's this <http://hackage.haskell.org/package/either-4.3.2/docs/Data-Either-Validation.html>
03:12:11 <bitonic> with a very useful Monoid instances
03:12:12 <bitonic> *instance
03:12:18 <bryanedds> ok, type again is - data Desync a = { operation :: a; optNext :: Maybe (Desync a) }
03:12:26 <prophile> bryanedds: okay, the major hint is to implement (++) for Desync
03:13:01 <bryanedds> ya, actually that part already made sense :)
03:13:20 <bryanedds> :t join
03:13:21 <lambdabot> Monad m => m (m a) -> m a
03:13:38 <bryanedds> join only has one parameter, but it can be split in two
03:14:20 <prophile> if you write join x = <implementation here>, x is a Desync (Desync a)
03:14:35 <prophile> with operation :: Desync a and optNext :: Maybe (Desync (Desync a))
03:14:41 <bryanedds> when split in two, there are two operations but only one next
03:15:10 <bryanedds> well, maybe not
03:15:26 <bryanedds> actually there's an unbounded number of operations
03:15:41 <bryanedds> but there's alway one more operation than there are nexts?
03:15:53 <prophile> off the top of my head I think the implementation is something like join x = case optNext x of { Just y -> operation x ++ join y; Nothing -> operation x;
03:17:04 <bryanedds> ya, there def seems like there would be a pattern match on maybe in there
03:18:52 <HaskellNewb> Hello everybody
03:19:16 <prophile> HaskellNewb: aight
03:19:31 <HaskellNewb> I am a Haskell newbie and I need to  "remake" the !! function with foldl: https://bpaste.net/show/b02d7d634a97
03:19:51 * hackagebot language-fortran 0.2.7 - Fortran lexer and parser, language support, and extensions.  http://hackage.haskell.org/package/language-fortran-0.2.7 (DominicOrchard)
03:20:14 <HaskellNewb> I am probably thinking too much like an imperative programmer but how do I know via foldl what index of the list it is?
03:20:35 <prophile> you don't, the only information you have in foldr is what you have in the accumulator
03:21:07 <prophile> so you'll need to decide on what goes in your accumulator
03:22:21 <HaskellNewb> prophile Ah
03:22:22 <Peaker> HaskellNewb: foldl always goes over the entire list. Makes no sense for (!!)
03:22:59 <prophile> Peaker: it's perfectly possible to implement (!!) in terms of foldl
03:23:25 <bryanedds> prophile: in your definition, ++ is _not_ recursive, right?
03:23:26 <Peaker> I didn't say it's impossible, I said it makes no sense :)
03:23:35 <Peaker> also, it is actually impossible, because part of (!!) is its termination/laziness properties
03:23:47 <Peaker> > [1..] !! 2
03:23:49 <lambdabot>  3
03:23:53 <prophile> bryanedds: I'd imagine it is recursive
03:24:02 <HaskellNewb> Peaker, I understand it makes no sense but its an exercise.
03:24:04 <bryanedds> ah
03:24:14 <HaskellNewb> to practice
03:24:16 <torpet_> does anyone know why i get this error message? http://lpaste.net/8012722684276244480
03:24:38 <prophile> Peaker: allow me to withdraw and rephrase as "it's perfectly possible to implement as an exercise for learning haskell and functional programming" :)
03:24:54 <Peaker> prophile: can you make (!!) with foldl that does that ^^ ?
03:24:54 <Peaker> HaskellNewb: the exercise says to use "foldl" and not "foldr" ?
03:25:05 <bryanedds> so the function has n^2 complexity?
03:25:36 <prophile> Peaker: it's OK to ignore infinite lists in an exercise
03:25:37 <Peaker> it's probably not a good idea to practice bad practices, unless the point is to show that they are bad practices
03:26:00 <prophile> if we were focusing on bad practice I'd also mention to use foldl'
03:26:36 <Peaker> prophile: I agree that for learning, foldl vs foldl' is insignificant. But the deeper strictness issues are significant
03:26:40 <bryanedds> :t (++)
03:26:41 <lambdabot> [a] -> [a] -> [a]
03:29:16 <HaskellNewb> Sorry for the late reply, The chat window doesnt scroll itself down..
03:29:54 <HaskellNewb> Peaker, it says foldl
03:31:43 <bryanedds> well, I wrote (++) for lists...
03:31:46 <HaskellNewb> The problem is I dont understand how you can see the index of an element.
03:32:05 <bryanedds> I think I can figure out the Nothing case now
03:32:13 <prophile> bryanedds: lovely
03:32:15 <HaskellNewb> bryenedds, Yes I also needed to rewrite ++ using foldr
03:32:21 <Peaker> > foldl f 0 [a,b,c]
03:32:23 <lambdabot>  No instance for (GHC.Show.Show a0)
03:32:23 <lambdabot>    arising from a use of ‘M698454146812515925719658.show_M6984541468125159257...
03:32:23 <lambdabot>  The type variable ‘a0’ is ambiguous
03:32:23 <lambdabot>  Note: there are several potential instances:
03:32:23 <lambdabot>    instance [safe] GHC.Show.Show
03:32:42 <Peaker> > foldl f z [a,b,c]
03:32:43 <lambdabot>  f (f (f z a) b) c
03:33:08 <bryanedds> maybe if I can make my (++) follow the structure of the lists definition...
03:33:27 <Peaker> HaskellNewb: if we use "**" instead of "f", you can see that it is: (((z**a)**b)**c)
03:33:57 <Peaker> HaskellNewb: so you just need to use a (**) which "keeps track" of how deep it went into the list and when it went deep enough, takes the element
03:34:33 <HaskellNewb> Peaker, ah thanks I will take look at the **
03:34:42 <Peaker> HaskellNewb: ** is just a name I invented now :)
03:35:04 <HaskellNewb> Ow haha
03:35:23 <Peaker> HaskellNewb: basically, you can think of foldl as a reduction with an accumulator. That is: You give foldl the initial state of your accumulator, and each "iteration" it feeds another element of the list to your function which updates the accumulator
03:35:28 <bryanedds> prophile: now I just have to figure out what cons means in this context
03:35:58 <bryanedds> I'm guessing its application of an operation, but I don't know for sure...
03:35:58 <prophile> cons is just the Desync constructor
03:36:12 <bryanedds> oh?
03:36:27 <Peaker> HaskellNewb: So you need an accumulator that: A) helps you establish the index of the element you're looking at. B) Once the correct element has been chosen, you need the accumulator to hold that element and keep it around for the rest of the accumulation (ignore the extra elements being fed)
03:36:27 <prophile> cons x y = Desync { operation = x, optNext = Just y }
03:37:07 <HaskellNewb> I see and for lists like [0..10] it is very easy but what if you have a list like ['a'..'z']
03:37:34 <Peaker> HaskellNewb: have your accumulator count how many accumulations had happened so far
03:38:01 <torpet_> im evaluating a recursive function in another function
03:38:06 <torpet_> something like
03:38:16 <HaskellNewb> Oh I think i understand it
03:38:27 <torpet_> func a ++ (func b \\ func a)
03:38:31 <torpet_> where func a= ...
03:38:37 <HaskellNewb> I also created a length function using foldr maybe I can use that to create the !! function
03:38:38 <torpet_> does haskell evaluate func a only once
03:38:38 <torpet_> ?
03:38:51 <HaskellNewb> (
03:39:04 <opqdonut> torpet_: no
03:39:12 <torpet_> ok then my code sucks
03:39:12 <prophile> torpet_: not 100% sure but I'm pretty confident that's an implementation detail
03:39:16 <prophile> so it might do or it might not
03:39:24 <prophile> depending on the mood of the optimiser
03:39:29 <bryanedds> urggghhh
03:39:32 <bryanedds> *POP*
03:39:33 <opqdonut> GHC does very little CSE (common subexpression elimination)
03:39:36 <prophile> but if you want to be sure it's sensible to do let x = func a in ...
03:39:37 <opqdonut> because it affects sharing
03:39:50 <bryanedds> it type checks! and it feels like I just gave birth!
03:39:59 <prophile> bryanedds: \o/
03:40:02 <prophile> ^5
03:40:41 <bryanedds> I'll show you the code if you don't mind seeing F# :)
03:40:44 <HaskellNewb> (\ acc _ ->  if index \= acc;(acc + 1) ) 0 a
03:40:50 <opqdonut> (consider something like "let xs = [1..10000000] in last xs + sum xs" vs. "last [1..10000000] + sum [1..10000000]")
03:41:05 <prophile> ah, burn the F# user :)
03:41:48 <bryanedds> i thought you knew I was doing half-assed translations to haskell this whole time!
03:42:24 <HaskellNewb> Peaker: Something like this: I know it isnt a good practice to use if statements in Haskell but for now: (\ acc _ ->  if index \= acc;(acc + 1) ) 0 a
03:43:25 <bryanedds> now I can just define bind in terms of fmap and join!
03:45:14 <bryanedds> now to see if the tests still pass :)
03:47:04 <bryanedds> and it's all broken...
03:47:18 <bryanedds> @#$@#$@%
03:47:19 <lambdabot> Unknown command, try @list
03:47:31 <prophile> \D:/
03:48:09 <Peaker> HaskellNewb: your "if" is a syntax error. If you fix it you'll also move further towards a correct conceptual solution
03:50:09 <bryanedds> lol
03:50:17 <bryanedds> hopefully it's just some silly typo
03:55:16 <torpet> what could possible be wrong in that line? http://lpaste.net/5320181315314647040
03:56:33 <torpet> the funny thing is that the function returns the same datatype
03:56:59 <torpet> yet i have this error message http://lpaste.net/6269863219423084544
03:59:51 <bitonic> you're not showing us the full story, the problem is that that expression is not a function
04:00:55 <bitonic> or so it seems anyway.  can you give a bit more context?
04:02:24 --- mode: ChanServ set +o shachaf
04:02:37 --- mode: shachaf set -bo kvieta!*@*$##fixyourconnection shachaf
04:19:54 * hackagebot persistent-redis 0.3.1 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.3.1 (PavelRyzhov)
04:58:40 <adamse> torpet_: my guess: you want to use \\ as an operator, remove the () around \\
04:59:43 <Iceland_jack> torpet_: You use it like this:
04:59:44 <Iceland_jack> > [1,2,3,4,5] \\ [2,3]
04:59:45 <lambdabot>  [1,4,5]
04:59:46 <Iceland_jack> It's an operator
05:00:44 <Iceland_jack> From that limited snippet of code spielerHistorie should return a Set, not a list
05:01:30 <Iceland_jack> Working with it is as simple as:
05:01:30 <Iceland_jack> > S.fromList [1,1,2,1,2,1,2] S.\\ S.fromList [1]
05:01:32 <lambdabot>  fromList [2]
05:01:44 <Iceland_jack> > nub [1,1,2,1,2,1,2] \\ nub [1]
05:01:46 <lambdabot>  [2]
05:03:34 <pyed> entering this line will freeze ghci and it won't respond to Ctrl-C: http://lpaste.net/115718
05:03:47 <pyed> is this a known problem ?
05:04:20 <Iceland_jack> Try running: $ ghci -ignore-dot-ghci
05:04:39 <Iceland_jack> and then entering that line, Control-C shouldn't be a problem
05:05:06 <mmachenry> pyed it's trying to calculate the length of an infinite list.
05:05:18 <mmachenry> pyed: So it's going to think forever and never get the answer.
05:05:28 <torpet_> Does it not work with sets?
05:05:37 <pyed> mmachenry, it's not that same as (length [0..])
05:05:49 <torpet_> I made it work with \\ instead of (\\). Facepalm moment
05:05:54 <pyed> the latter will respond to Ctrl-C
05:06:08 <Iceland_jack> torpet_: Does what not work wwith sets?
05:06:10 <Iceland_jack> *with
05:06:21 <torpet_> \\
05:06:43 <Iceland_jack> No, (\\) has type:
05:06:43 <Iceland_jack> @ty (\\)
05:06:45 <lambdabot> Eq a => [a] -> [a] -> [a]
05:06:52 <Iceland_jack> So it's defined over lists
05:07:05 <Iceland_jack> (\\) from Data.Set however:
05:07:05 <Iceland_jack> @ty (S.\\)
05:07:06 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
05:07:17 <pyed> Iceland_jack, still the same even with '-ignore-dot-ghci' flag
05:07:35 <centrinia> :t (\\)
05:07:37 <lambdabot> Eq a => [a] -> [a] -> [a]
05:08:28 <pyed> you'll endup with ghc instance that's using 100%
05:08:40 <pyed> you have to kill it yourself
05:11:06 <int-e> pyed: probably an instance of https://ghc.haskell.org/trac/ghc/ticket/367
05:12:10 <int-e> (And one where -fno-omit-yields will not easily help because 'length' is part of the base library.)
05:19:57 * hackagebot generics-sop 0.1.0.3 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.0.3 (AndresLoeh)
05:45:50 <ChristianS> how can i lift  Maybe x  to Maybe [x] ?
05:46:14 <maukey> :t fmap pure
05:46:15 <lambdabot> (Applicative f1, Functor f) => f a -> f (f1 a)
05:46:35 <maukey> :t fmap repeat
05:46:36 <lambdabot> Functor f => f a -> f [a]
05:46:36 <Iceland_jack> ChristianS: You'd use fmap, the actual action would depend on what you want to do
05:46:53 <ChristianS> ah, thanks, i'll try
05:46:55 <Iceland_jack> like maukey suggests, pure or repeat (or 'replicate 100' or ..)
05:52:34 <int-e> pyed: I got curious and recompiled ghc with the libraries (in particular the base library) compiled with -fno-omit-yields, and the  length (let x = 0:x in x)  evaluation can now be interrupted.
06:06:24 <athan> How do I run a newtype, general monad (like the Reader monad) inside a monad transformer?
06:06:34 <athan> Where do I put `runReader`?
06:08:34 <torpet> why does maximum find the "rightmost" max value?
06:09:03 <torpet> eg when i use maximumBy (comparing snd) and there are two tupels (A, 2) and (X,2), (X,2) wins over A
06:11:32 <maukey> @src maximumBy
06:11:32 <lambdabot> Source not found.
06:12:14 <maukey> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#maximumBy
06:15:51 <hexagoxel> athan: what is "inside"? can you express the question in types?
06:17:08 <athan> hexagoxel: Sorry, this is pretty difficult to explain. I'm using the scotty web server, with scottyT, trying to add a reader monad in it's stack
06:17:54 <int-e> torpet: The Haskell'98 report defined it that way. (As a left fold, but a right-biased maximum operation). The Haskell 2010 is less informative; it allows the code to assume a total order, and  comparing snd  is not a total order.
06:19:29 <int-e> @free maximumBy :: (a -> a -> Ordering) -> [a] -> a
06:19:29 <lambdabot> (forall x. g x = h (f x) . f) => f . maximumBy g = maximumBy h . $map f
06:19:39 <athan> hexagoxel: This is basically what I'm trying to accomplish: http://lpaste.net/115719
06:20:00 * hackagebot websockets 0.9.2.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.2.0 (JasperVanDerJeugt)
06:20:05 <athan> O_O
06:24:51 <lericson_> what is a good way to model this problem: given a list L, i want to find all possible replacements of the sublist x with y in L
06:24:56 <osa1> uh... gtk3 module hierarchy is confusing. how do I hide a window? I can't see the property to set
06:25:16 <chrisdone> osa1: i Ctrl-f in the index page
06:25:37 <chrisdone> http://hackage.haskell.org/package/gtk-0.13.1/docs/doc-index-All.html
06:26:02 <lericson_> for example, let L = "hello hella", x = "ell", y = "eel" then the replacements i seek are "heelo hella" and "hello heela"
06:26:23 <lericson_> what you essentially want to do is search and replace with backtracking
06:26:32 <eXeC64> What on earth is ($map)?
06:26:34 <osa1> good idea
06:26:44 <lericson_> in prolog this is very easy to model and i was wondering if such an approach is possible in haskell
06:26:49 <lericson_> i understand monads are pretty important for this
06:26:49 <eXeC64> is it just a partially applied $?
06:27:02 <lericson_> :t ($map)
06:27:03 <lambdabot> (((a -> b1) -> [a] -> [b1]) -> b) -> b
06:27:07 <lericson_> seems like it, eXeC64
06:27:28 <eXeC64> :t ($) map
06:27:29 <lambdabot> (a -> b) -> [a] -> [b]
06:27:36 <eXeC64> So why's that different?
06:27:45 <lericson_> because $ does nothing
06:27:46 <lericson_> :t $
06:27:47 <chrisdone> i think haddock's current output is not that helpful
06:27:47 <lambdabot>     parse error on input ‘$’
06:27:48 <lambdabot>     Perhaps you intended to use TemplateHaskell
06:27:51 <lericson_> :t ($)
06:27:52 <lambdabot> (a -> b) -> a -> b
06:28:14 <lericson_> it is the difference between (+1) and (+) 1
06:28:33 <eXeC64> They have the same type signature though
06:28:38 <ParahSailin> would there be any benefit of making runtime compilation easy to do?
06:28:39 <indiagreen> “(+) 1” is “(1+)”
06:28:40 <eXeC64> ($map)'s is rather complex
06:29:15 <lericson_> :t (flip ($)) map
06:29:16 <lambdabot> (((a -> b) -> [a] -> [b]) -> c) -> c
06:29:23 <lericson_> seem familiar?
06:29:33 <maukey> eXeC64: $map is map in that case
06:29:34 <eXeC64> ;t (map$)
06:29:37 <eXeC64> :t (map$)
06:29:38 <lambdabot> (a -> b) -> [a] -> [b]
06:29:42 <eXeC64> Ah, I see
06:29:50 <maukey> it's the canonical map for []
06:30:06 <eXeC64> I still think the signature of ($map) is very difficult to read/interpret though
06:30:23 <maukey> @free fromMaybe
06:30:24 <ParahSailin> you can compile string expressions to HValue as an IO action, but it should be possible to compile TH splices for instance into values as a pure action, no?
06:30:24 <lambdabot> f . fromMaybe x = fromMaybe (f x) . $map_Maybe f
06:30:39 <chrisdone> why does it lack parentheses?
06:30:48 <maukey> what?
06:30:48 <chrisdone> $foo is template-haskell syntax
06:30:56 <maukey> and @free syntax
06:31:09 <lericson_> it is huh
06:31:14 <chrisdone> oh it's some haskell-ish language?
06:31:37 <lericson_> did you, by any chance, use to hang out in #php on quakenet, chrisdone?
06:32:03 <chrisdone> mm i don't think so
06:33:07 <chrisdone> i did idle on some other channels on quakenet, though
06:33:57 <eXeC64> So, by using either `(f x)` or `(f) x` where f is an infix function, you can provide the parameters to an infix function out of order?
06:34:18 <eXeC64> Is that just syntactic sugar for flip?
06:34:36 <eXeC64> Hmm, no. It'd just be language built-in, wouldn't it?
06:35:38 <lericson_> chrisdone: ah hm, the visual basic channel?
06:35:45 <lericson_> python?
06:36:14 <mmachenry> I'm interested in creating a pair of channels to communicate a running process. My strategy is to read the output channel and then write to the input channel, at which point the output channel should get some data. But this isn't thread safe without another lock to make sure no one else writes their input first.
06:36:40 <mmachenry> Is there a library that encapsulates this? I'm basically doing an actor model.
06:36:45 <maukey> eXeC64: a + b means (+) a b
06:36:51 <chrisdone> lericson_: nope
06:37:10 <maukey> eXeC64: (a +) means \x -> (+) a x (or just (+) a with an extension, I think)
06:37:16 <maukey> (+ b) means \x -> (+) x b
06:37:36 <eXeC64> maukey: I understand that much. I had just assumed because of type signatures and currying, that parameters could only be provided in the order given by the type, unless using glue like flip.
06:38:04 <eXeC64> Didn't expect (a (+ b)) and ((a +) b) to be valid, I suppose
06:38:18 <eXeC64> Oh, it's not
06:38:20 <eXeC64> heh
06:38:20 <Iceland_jack> eXeC64: The first one isn't valid
06:38:24 <Iceland_jack> but the second one is
06:38:35 <lericson_> :t \b (+ b)
06:38:36 <lambdabot> Parse error in pattern: + b
06:38:37 <lericson_> oh sh
06:38:40 <lericson_> :t \b -> (+ b)
06:38:41 <lambdabot> Num a => a -> a -> a
06:38:41 <Iceland_jack> (5 +) or (+ 42) are called operator sections and they're very handy
06:38:47 <Iceland_jack> > map (+ 42) [1..10]
06:38:48 <lambdabot>  [43,44,45,46,47,48,49,50,51,52]
06:38:58 <Iceland_jack> Same as:
06:38:58 <Iceland_jack> > map (\x -> x + 42) [1..10]
06:39:00 <lambdabot>  [43,44,45,46,47,48,49,50,51,52]
06:39:24 <eXeC64> Oh, so operator sections are just syntactic sugar for lambdas similar to flip?
06:39:25 <lericson_> > [v+42 | <- [1..10]]
06:39:26 <lambdabot>  <hint>:1:9: parse error on input ‘<-’
06:39:32 <lericson_> > [v + 42 | v <- [1..10]]
06:39:34 <lambdabot>  [43,44,45,46,47,48,49,50,51,52]
06:39:37 <chrisdone> eXeC64: yeah
06:39:46 <eXeC64> Ah, that makes sense now. Thanks.
06:40:07 <eXeC64> And currying always happens in the order the type specifies, as I originally thought.
06:40:37 <Iceland_jack> eXeC64: Yes in the sense that 'flip' lets you write 'flip f' rather than '\x y -> f y x'
06:40:57 <Iceland_jack> When you work a lot with functions you start to appreciate conveniences like that
06:42:07 <lericson_> k
06:42:10 <lericson_> ops sorry
06:43:52 <lericson_> i don't quite understand how monads can do backtracking
06:44:01 <lericson_> by "quite" i mean not at all
06:44:41 <maukey> you don't have to backtrack if you take all branches at once
06:45:27 <lericson_> can i repost the original question?
06:47:11 <lericson_> what is a good way to model this problem: given a list L, i want to find all possible replacements of the sublist x with y in L
06:50:16 <lericson_> i think i have an idea
06:50:37 <lericson_> it's not efficient, but iterate over the list L and break it up in segments of the same length as x
06:54:35 <maukey> > let cut [] = ([], []); cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in cut "abc"
06:54:37 <lambdabot>  Couldn't match expected type ‘([t2], [t3])’
06:54:37 <lambdabot>              with actual type ‘[([t4], [t4])]’
06:54:37 <lambdabot>  Relevant bindings include
06:54:37 <lambdabot>    xs :: [t4] (bound at <interactive>:1:36)
06:54:37 <lambdabot>    x :: t4 (bound at <interactive>:1:32)
06:54:50 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in cut "abc"
06:54:52 <lambdabot>  [("","abc"),("a","bc"),("ab","c"),("abc","")]
06:55:20 <lericson_> i need three parts
06:55:27 <lericson_> and also i have no idea what that syntax means
06:56:45 <lericson_> *Main> segments 3 "hello wold" []
06:56:45 <lericson_> [("","hel","lo wold"),("h","ell","o wold"),("eh","llo"," wold"),("leh","lo ","wold"),("lleh","o w","old"),("olleh"," wo","ld"),(" olleh","wol","d"),("w olleh","old",""),("ow olleh","ld",""),("low olleh","d","")]
06:57:00 <lericson_> not sure what happens at the end there... i'm sure it's all good
06:57:21 <lericson_> ah
06:57:22 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in (\x y l -> [ (p, y, r) | (p, q) <- cut l, let Just r = stripPrefix x q ]) "l" "X" "hello world"
06:57:24 <lambdabot>  [("","X","*Exception: <interactive>:3:141-164: Irrefutable pattern failed fo...
06:57:36 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in (\x y l -> [ (p, y, r) | (p, q) <- cut l, Just r <- [stripPrefix x q] ]) "l" "X" "hello world"
06:57:38 <lambdabot>  [("he","X","lo world"),("hel","X","o world"),("hello wor","X","d")]
06:58:08 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in (\x y l -> [ (p, y, r) | (p, q) <- cut l, Just r <- [stripPrefix x q] ]) "ana" "X" "banana"
06:58:09 <lambdabot>  [("b","X","na"),("ban","X","")]
06:58:36 <lericson_> see you when i figure this one out by late 2016
06:58:52 <maukey> it's a pretty simple brute force search
06:59:15 <maukey> it splits the input string in two at every possible position
06:59:21 <maukey> ('cut')
06:59:30 <lericson_> ahhh, a@(b:c) is the same as both a and (b:c)
06:59:31 <lericson_> genius!
06:59:42 <Iceland_jack> lericson_: it binds 'a = b:c'
06:59:43 <maukey> then it tries to remove the search string x from the tail of each split
06:59:46 <Iceland_jack> basically
06:59:57 <flyingfisch> is there a hashing library with sha256 for haskell?
06:59:59 <maukey> well, from the beginning of the second half
07:00:00 <flyingfisch> or bcrypt
07:00:04 <Iceland_jack> flyingfisch: yes
07:00:08 <flyingfisch> bcrypt would be even better
07:00:11 <maukey> if that succeeds, we've found a replacement point
07:00:32 <flyingfisch> Iceland_jack: is it included in haskell-platform?
07:00:57 <lericson_> ah stripPrefix
07:01:02 <Iceland_jack> No, but you can get packages like cryptohash
07:01:09 <Iceland_jack> @hackage cryptohash
07:01:09 <lambdabot> http://hackage.haskell.org/package/cryptohash
07:01:17 <Iceland_jack> or bcrypt:
07:01:17 <Iceland_jack> @hackage bcrypt
07:01:17 <lambdabot> http://hackage.haskell.org/package/bcrypt
07:01:50 <flyingfisch> Iceland_jack: can I install them locally to my project?
07:02:04 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in (\x l -> [ (p, q) | (p, (stripPrefix x -> Just q) <- cut l ]) "ana" "banana"
07:02:05 <lambdabot>  <hint>:1:145: parse error on input ‘<-’
07:02:10 <maukey> > let cut [] = [([], [])]; cut zs@(x : xs) = ([], zs) : map (\(p, q) -> (x : p, q)) (cut xs) in (\x l -> [ (p, q) | (p, (stripPrefix x -> Just q)) <- cut l ]) "ana" "banana"
07:02:12 <lambdabot>  [("b","na"),("ban","")]
07:02:18 <maukey> nice
07:03:41 <lericson_> that is very elegant
07:03:54 <lericson_> well
07:04:00 <lericson_> clever at least
07:05:59 <chrisdone> i made some gifs for ghci-ng + emacs: https://github.com/chrisdone/ghci-ng/blob/master/README.md#go-to-definition
07:06:01 <chrisdone> =3
07:10:14 <lericson_> @hoogle stripPrefix
07:10:15 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:10:15 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
07:10:16 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
07:10:17 <hvr> chrisdone: neat
07:11:06 <hvr> chrisdone: ...can we get those features merged back to GHCi for GHC 7.12? :)
07:11:27 <hvr> (as the window for  GHC 7.10  is rather missed)
07:12:14 <chrisdone> hvr: that seems more likely =)
07:12:44 <hvr> chrisdone: benefit is, it gives you more time to let them mature
07:18:05 <jackhill> [6~[6~
07:18:05 <jackhill> 
07:18:26 <acsharper> noob question - Can I create a typed 'context' monad that accumulates type parameters -- I will try to clarify below...
07:19:46 <chrisdone> hvr: i've been using these two for about a month now, pretty reliable… my ghc/ repo did build in the end, from last time we spoke about it
07:20:02 <Cale> acsharper: Not with the usual Monad class.
07:20:04 * hackagebot sbv 3.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.3 (LeventErkok)
07:20:06 * hackagebot rest-gen 0.16.1.3 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.3 (AdamBergmark)
07:20:07 <bartavelle> is there a real difference between binary and cereal ?
07:20:12 <chrisdone> laziness
07:20:12 <acsharper> I have 'blocks' that produce results of type a which then gets fed into a running context<a>, and then gets fed into a block that produces b -- can I have a structure that then knows the context should be context<a * b>?
07:20:36 <Cale> acsharper: The monad in question stays the same throughout a computation, including any additional type parameters to it aside from the result type.
07:20:40 <chrisdone> bartavelle: binary parses lazily
07:20:45 <bartavelle> chrisdone, thanks
07:20:50 <Cale> acsharper: But you might be able to do something with indexed monads.
07:21:06 <acsharper> Cale -- is there something that can do that ?
07:21:22 <acsharper> what are indexed monads?
07:21:34 <Cale> http://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed.html
07:22:04 <acsharper> thanks! (this is my first time here -- so thanks for making it so easy!
07:23:05 <Cale> But I would recommend at first perhaps not trying to squish your library into any particular abstraction, but instead just to write the combining functions that will let you put computations together, and then examine the types of them and see if they fit any pattern.
07:26:46 <bartavelle> acsharper, to expand a bit on what Cale said, you might declare "data MyThingie a b c", where (a,b) is your "context" and c some type, then declare a few combinators that you expect you might need (with no implementation). Then try to use this API by writing part of your program. You'll see if it "fits", or if you miss a type parameter, one the combinators is not useful, etc.
07:27:11 <bartavelle> once this is done you can ask yourself what "MyThingie" is like
07:27:24 <bartavelle> and (try to) write the combinators
07:27:49 <ziggystar> Hi. I'm trying to build a cabal project with unit tests. My tests require reading some files. Now I placed them under `test/res/`. Do I have to reference them with this path, or can I declare this directory containing resources for the tests so I can get at the files differently when running `cabal test` ?
07:30:02 <acsharper> Cale, thanks for the advice. I have been wrestling with the types for a while know -- it seems a lot like a I need to create a new tuple at each stage and add a new value to it.
07:31:01 <acsharper> bartavelle -- thanks. I am going to go try to build a working prototype and see where it goes
07:33:29 <thebnq> ziggystar: you can declare data-files in the .cabal
07:36:29 <ziggystar> So I can have `data-files` in my test-suite section?
07:37:21 <thebnq> i suppose, you still have to have to reference them with the path "test/res"
07:37:47 <thebnq> but its platform independent, if thats what you wanted
07:38:55 <flyingfisch> is a socket a special "file" like stdio?
07:39:22 <ziggystar> So data-files is only meant for final deployment, I assume?
07:40:35 <maukey> flyingfisch: what's a stdio?
07:41:19 <flyingfisch> maukey: sorry, I meant to say stdin
07:42:19 <maukey> ok, then I don't understand the question
07:42:44 <bartavelle> acsharper, the tuple in a tuple in a tuple thingie is used in http://okmij.org/ftp/tagless-final/course/lecture.pdf or http://ropas.snu.ac.kr/~bruno/papers/ASGDSL.pdf , perhaps this will match parts of what you might be doing
07:43:29 <bartavelle> I *think* it's also used, but for a different purpose in http://hackage.haskell.org/package/bound-1.0.4/docs/Bound.html
07:44:17 <flyingfisch> maukey: stdio is like a special file that contains input to the program from the command line, or data piped to the program
07:44:27 <flyingfisch> so I was wondering if sockets were the same way
07:45:02 <flyingfisch> since you use hGetContents just like with other "real" files
07:45:29 <maukey> ok, so by "file" you mean file handle?
07:45:45 <maukey> also, stdin is not the command line
07:45:47 <maukey> that's getArgs
07:46:45 <flyingfisch> maukey: I know, its the stuff you input after running the program
07:51:40 <michaelt> ziggystar: I think data-files pertains to an executable that cabal will finally install; the files will end up in ~/.cabal/share or whatever; for a test suite, you would just name files in the test executable, no?
07:52:59 <ziggystar> @michalt Maybe you're right. I use to load resources for unit-tests via the resource-loader in Java/Scala. Indeed cannot see a problem with specifying the path.
07:52:59 <lambdabot> Unknown command, try @list
07:54:47 <michaelt> ziggystar: maybe theres some further complication, but that's what I've done.  The relevant directory for relative paths, though, would be the one you call cabal test from .  but maybe my experience is only of simple cases
07:56:28 <ziggystar> I'm currently trying EclipseFP, maybe I was wondering how the tests will be run. But it seems to be working now (at least the third time I try EclipseFP, and definately the first time I was able to run tests with it).
07:58:16 <michaelt> Oh I see, it may have bells and whistles. Still you'd think that when you ask it to test, it just calls 'cabal test' from the main directory of the package.
08:00:22 <michaelt> ziggystar: which in turn means cabal calls dist/../testexecutable from the project directory
08:00:28 <hsk88> Haskell seems to rely on a lot of compiler magic to make sure that, e.g., copying is not really copying. With this in mind, is it even possible to do functional programing in other languages like C?
08:01:10 <mmachenry> hsk88: http://www.amazon.com/Functional-International-Computer-Science-Series/dp/0201419505
08:01:26 <mmachenry> Though I don't think, really, that C supports this well.
08:01:31 <ziggystar> michaelt: Yeah, I figured that out somehow. It's rather tricky to get unit tests working with Haskell.
08:01:41 <maukey> C relies on a lot of "compiler magic" because most CPUs can't run C natively
08:02:15 <hsk88> thanks ok
08:03:05 <bartavelle> anybody knows if there already is a package that implements convertion between Float/Double and their IEEE-754 binary representation (a ByteString)
08:04:09 <Iceland_jack> @hackage data-binary-ieee754
08:04:09 <lambdabot> http://hackage.haskell.org/package/data-binary-ieee754
08:04:15 <bartavelle> cool thanks !
08:04:18 <Iceland_jack> np!
08:04:32 <michaelt> ziggystar:  yes, I always end up following the example of some reliable person's package and slowly reasoning from there what was going on ...
08:04:45 <bartavelle> searching for 754 on hackage would have been simpler than asking on irc :/
08:05:06 <Iceland_jack> bartavelle: Nah you got me to do that for you :)
08:05:19 <bartavelle> haha, thanks again
08:07:47 <bartavelle> bon je dois faire ma liste de noel
08:07:54 <bartavelle> quelles sont les bonnes confs  part recon ?
08:08:44 <maukey> wie bitte?
08:08:52 <bartavelle> argh
08:08:54 <bartavelle> wrong channel
08:08:57 <bartavelle> sorry
08:09:17 <maukey> or "canal de mal", as translate.google.com says
08:09:26 <bartavelle> mauvais canal ;)
08:09:39 <michaelt> oh, I was trying to analyze "les bonnes confs à part recon" as complicated computer jargon
08:09:56 <HeladoDeBrownie> "Which are the good…"
08:10:18 <HeladoDeBrownie> I don't know French but it seems similar to Spanish
08:10:18 <bartavelle> well if you have suggestions about good infosec conferences, please pm ;)
08:10:24 <isBEKaml> "What's a good conf for recon?"
08:10:32 <maukey> "what the right hand entrusted to recon"
08:10:43 <HeladoDeBrownie> maukey, I think Google Translate is failing you.
08:10:51 <maukey> s/failing/entertaining/
08:10:56 <bartavelle> oh god, I'll end this right now : "what are the good conferences, except recon ?"
08:10:57 <HeladoDeBrownie> Yes, that.
08:11:20 <eacameron> anyone ever considered porting the nix package manager to haskell?
08:12:15 <sivteck> we have cabal!
08:12:18 <michaelt>  ah, bonne conferences
08:12:28 <isBEKaml> It's only on IRC that I can find a german response to a question in french
08:12:37 <HeladoDeBrownie> The response was basically "What?" though
08:12:54 <isBEKaml> although, it's that - yes
08:15:09 * michaelt was, on reflection, getting interference from autoconf vs. autoreconf
08:20:16 <platz> I thought nix was written in haskell
08:20:58 <athan> ...how do I translate between Data.Text.Lazy and Data.Text..? (T.pack . LT.unpack)? :S
08:21:57 <michaelt> athan: that lazy module has functions
08:22:16 <athan> michaelt: Thank you :)
08:22:35 <michaelt> fromChunks toChunks, not the explicit list
08:22:51 <michaelt> sorry, I meant, note the explicit list
08:23:16 <athan> oh wow, that's not so hard to understand!
08:23:30 <athan> I've always been intimidated by these major libraries
08:23:56 <Swat-xt> http://www.indiedb.com/games/dexterity-ball-3d/downloads/dexterty-ball-3d-version-089
08:24:10 <michaelt> oh I forgot, now there's fromStrict :: Text -> Text etc.
08:24:39 <michaelt> athan: note that toStrict will concatenate the chunks
08:25:08 <michaelt> athan: a lazy text can be infinitely long, so this might or might not be a good idea...
08:25:28 <Swat-xt> ''  http://www.indiedb.com/games/dexterity-ball-3d/downloads/dexterty-ball-3d-version-089  ìì
08:27:32 <athan> michaelt: But, if we're coming fromStrict, we'll be okay :) (right?)
08:28:01 <michaelt> yes exactly; then it's basically just swapping one constructor
08:28:43 <acsharper> bartavelle -- thanks. Both papers and Bound look relevant.
08:28:58 <athan> michaelt: Thank you :) What are you working on atm?
08:29:20 <bartavelle> acsharper, happy reading then ;)
08:29:30 <michaelt> athan: pipes nonsense ...
08:32:49 <ziggystar> I was defining these function (sequence tuple entries). Can I find them in some library? Monad m => (m a,b) -> m (a,b)
08:33:47 <ion> foo (fa, b) = (,b) <$> fa
08:35:24 <ziggystar> Yes. They are simple to define, I was just wondering whether they do already exist.
08:36:16 <chrisdone> ziggystar: might be able to add them to monad-extras
08:36:20 <Swat-xt> jesus is coming back?
08:38:17 <hammerhead> one day, he is. no one knows the day or hour though...
08:38:36 <michi7x7> jesus who?
08:38:38 <Phillemann> Hm, there is no function for computing the median of a list in Haskell.
08:38:56 <Phillemann> The thing from the statistics package needs Floating on the elements.
08:39:39 <prophile> Phillemann: the median of [x, y] isn't well defined unless you have some way of going half way between x and y
08:39:46 <michaelt> it also needs a vector, presumably Phillemann
08:40:14 <Phillemann> So this really has theoretical reasons.
08:40:37 <prophile> also the median of [] is completely undefined
08:40:38 <prophile> :)
08:40:40 <michi7x7> Phillemann: "not defined for even length" is rather practical, no?
08:40:41 <prophile> partial functions woo
08:41:06 <Phillemann> prophile: I could live with safeMedian :: Ord a => [a] -> Maybe a though.
08:41:25 <Iceland_jack> Phillemann: What do you want that function for?
08:41:52 <michi7x7> Phillemann: how about median :: Ord a => [a] -> [a]
08:42:10 <Phillemann> Apparently I was a bit naive and thought the median was just "sort xs !! (length xs `div` 2)
08:44:01 <michaelt> Phillemann: see for example http://hackage.haskell.org/package/distribution-1.0.0.0/docs/src/Data-Distribution-Measure.html where the result is a Maybe
08:44:28 <michaelt> Phillemann: hah, here's the definition you were going to write ... https://hackage.haskell.org/package/dsp-0.2.3/docs/src/Numeric-Statistics-Median.html#median
08:44:50 <michaelt> not that you want a digital sound processing dependency ...
08:45:12 <Phillemann> Hehe, good find! :)
08:45:21 <magicman> Hey, let's sort x twice.
08:45:24 <Phillemann> It's suboptimal regarding big oh complexity, though.
08:48:59 <lpaste> michi7x7 pasted “median” at http://lpaste.net/115737
08:49:04 <zaquest_> :t mapM_
08:49:05 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:49:25 <fizz_ed> anybody recommend a good heap implementation?
08:49:56 <fizz_ed> (I see a couple, wondered if any favorites existed)
08:51:23 <michi7x7> Phillemann: returning [a] allows to use a different strategy for the median head, last, avg that's what I would use
08:53:11 <michi7x7> hmm... I'm not able to write parseable sentences anymore
08:54:22 <Phillemann> michi7x7: I see, that makes sense.
08:56:45 <Cale> fizz_ed: I dunno. For most things of that sort, I usually just use PSQueue. It's probably not the most efficient possible thing, but it's convenient, as it has lots of potentially useful operations. There are lots of other implementations of priority queues and heaps though.
08:58:05 <Cale> fizz_ed: The "heaps" package is by Ed Kmett, so it is almost certainly of high quality.
08:58:19 <fizz_ed> Cale: thanks for the tip. I just picked the module in the fgl package, kind of at random. Seems to be working out.
08:58:28 <zaquest> :t mapM_
08:58:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
09:00:06 <fizz_ed> Cale: Oh yes. Thats exactly right. (I'm a new so I don't know any big community names yet).
09:09:50 <zaquest> :t liftIO
09:09:51 <lambdabot> MonadIO m => IO a -> m a
09:35:10 * hackagebot lucid 2.5 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.5 (ChrisDone)
09:35:22 <NemesisD> chrisdone: are you around?
09:42:14 <RyanGlScott> Is there a library that exports the Whole typeclass, now that it's been removed from nats?
10:14:07 <peppe1234> list
10:20:12 * hackagebot cabal2nix 1.72 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.72 (PeterSimons)
10:20:14 * hackagebot flamethrower 0.0.5.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.5.0 (charmander)
10:37:47 <carter> @tell johnw I'm trying out using Apple text to speech and it's pretty darn awesome thanks
10:37:47 <lambdabot> Consider it noted.
10:40:24 <Hodapp> Is there a clean way of expressing a bunch of constants (their values are all specific 8-bit numbers) in  Haskell?
10:40:59 <carter> writing them down?
10:41:48 <Hodapp> I suppose I could just give names to a bunch of values, but it would seem like there's a solution that takes more advantage of static typing, as I will have some functions where the only thing that makes sense to use for certain arguments is one of these constants
10:43:09 <Hodapp> carter: well, the constants mean nothing on their own.
10:43:27 <carter> Hodapp: newtypes and dont expose the constructor?
10:43:51 <carter> Of course it be easier if I understood what you're trying to solve
10:43:55 <abg> Hodapp: Another solution https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
10:44:24 <rhllor> is there a function that returns a list of all permutations of the list?
10:44:40 <rhllor> permutations :: [a] -> [[a]]
10:45:05 <kadoban> :t Data.List.permutations
10:45:06 <lambdabot> [a] -> [[a]]
10:45:23 <Hodapp> carter: The constants are opcodes for some board. The opcodes are only meaningful in that they need to be the correct opcodes; they have more human-readable names that I'd like to use.
10:45:24 <chrisdone> carter: are you using that text-to-speech right now? ;-)
10:45:40 <carter> Yes
10:45:48 <chrisdone> i couldn't tell ;-)
10:45:56 <carter> Well it works pretty well and the typos are easy fix
10:46:14 <carter> And it seems to integrate pretty seamlessly with everything
10:46:21 <Hodapp> carter: so, basically a C enum, but it might be nice to have some actual type-checking atop that.
10:46:26 <carter> Hodapp: newyptes
10:46:28 <rhllor> kadoban: gracias
10:46:34 <carter> Hodapp: look at the patterns synonm article
10:46:35 <kadoban> de nada
10:46:43 <Hodapp> carter: alright
10:48:12 <carter> Chris basically the way the Apple speech to text tool is meant t be used is to get the skeleton of the writing done and then you do little fix up pass
10:48:19 <carter> I'm enjoying a little too much right now
10:48:28 <carter> also the OS X integration is pretty nice
10:50:53 <rhllor> carter: Apple does has great speech recognision software
10:51:34 <carter> rhllor: it even works in my text editor
10:51:36 <carter> which is CRAZY
10:52:01 <rhllor> yeah, it is
10:52:12 <johnw> carter: nice
10:52:15 <johnw> carter: I'm actually using the Dragon Dictate program for Mac, with a special microphone for dictation
10:52:18 <johnw>  so the accuracy I'm getting is very close to 99%
10:52:23 <johnw> in what I just said above, I corrected nothing
10:52:27 <johnw> (and that's with a noisy fan going in my room right now toO)
11:03:21 <rhllor> @map (print) [1,2,3]
11:03:22 <lambdabot> Maybe you meant: slap msg faq
11:03:35 <fresheyeball> hello folks
11:03:39 <michi7x7> > mapM print [1,2,3]
11:03:40 <michi7x7> ?
11:03:41 <lambdabot>  <IO [()]>
11:03:57 <rhllor> why doesn't that work though?
11:04:05 <Haskellfant> > mapM_ print [1,2,3]
11:04:05 <fresheyeball> does anyone have any advice as to dependency management in haskell?
11:04:06 <lambdabot>  <IO ()>
11:04:09 <Haskellfant> hm
11:04:14 <Haskellfant> no idea why lambdabot does that
11:04:15 <fresheyeball> cabal is horribly confusing to work with imho
11:04:24 <Haskellfant> mapM_ (putStrLn . show) [1,2,3]
11:04:28 <michi7x7> Haskellfant: because this doesn't return anything
11:04:30 <Haskellfant> > mapM_ (putStrLn . show) [1,2,3]
11:04:32 <kadoban> lambdabot doesn't actually perform IO. You have to give it something it can print.
11:04:32 <lambdabot>  <IO ()>
11:04:41 <kadoban> > "hi"
11:04:43 <lambdabot>  "hi"
11:04:47 <Haskellfant> hm ok, I didn't remember it correcty then
11:04:52 <rhllor> michi7x7: ohh
11:05:00 <michi7x7> Haskellfant: no you're right. It's just lambdabot
11:05:30 <Haskellfant> michi7x7: no I'm not I thought lambdabot did that :)
11:05:59 <S11001001> fresheyeball: Perhaps you will enjoy nix.  But it and cabal are your choices, IIRC.
11:06:23 <fresheyeball> ok
11:06:24 <michi7x7> Haskellfant: well... you can't suppose it would open files or sockets
11:06:30 <fresheyeball> so for example
11:06:46 <fresheyeball> I am trying to compile a file that uses Network.HTTP.Conduit
11:06:58 <fresheyeball> so I made a directory
11:07:05 <fresheyeball> ran cabal sandbox init
11:07:21 <fresheyeball> and then ran cabal install http-conduit
11:07:30 <Haskellfant> michi7x7: I thought there was a special case for printing :)
11:07:31 <fresheyeball> it seemed to install successfully
11:07:33 <rhllor> is there a way to print out the contents of a list on the smae line seperated by one spcae
11:07:38 <rhllor> *space
11:07:39 <rhllor> ?
11:07:47 <fresheyeball> but when I compile I get Could not find module `Network.HTTP.Conduit'
11:08:02 <fresheyeball> so I tried to install it again
11:08:03 <S11001001> rhllor: map show, then intercalate
11:08:09 <fresheyeball> and it says its already installed
11:08:13 <fresheyeball> any ideas?
11:08:15 <Haskellfant> > unwords . map show $ [1,2,3]
11:08:17 <lambdabot>  "1 2 3"
11:08:26 <michi7x7> > concatMap ((' ' :) . show) [1,2,3]
11:08:28 <lambdabot>  " 1 2 3"
11:08:28 <fresheyeball> it feels like every time I try to get a dependency I'm in for a problem
11:08:41 <S11001001> fresheyeball: what's in your cabal file?
11:09:35 <fresheyeball> I don't have a .cabal file
11:09:38 <S11001001> fresheyeball: I use https://github.com/joshcough/HaskellStarter#cabal and its included cabal file as a cheatsheet for defining my own.
11:09:47 <fresheyeball> but I do have a cabal.sandbox.config
11:10:13 <rhllor> is there a function for printing in human readable form, e.g. minus the "", like lisps princ function?
11:10:16 <S11001001> fresheyeball: I don't think ghci looks in your sandbox.  Try cabal repl.
11:10:36 <fresheyeball> I am just running `ghc myfile.hs`
11:10:45 <Haskellfant> that won't work with sandboxes
11:10:51 <fresheyeball> ok
11:10:52 <rhllor> The data needs to be in a specific format for a program to understand
11:10:52 <Haskellfant> use cabal exec ghc -- myfile.hs
11:11:10 <S11001001> fresheyeball: It's better to define a cabal file for your code than ad hoc installing them, because you can wipe and re-solve everything when you like.
11:11:31 <fresheyeball> ok interesting
11:11:34 <Haskellfant> well a cabal file for just playing around with a single file is a bit of an overkill imho
11:11:39 <fresheyeball> can I generate such a file from the command line?
11:11:43 <S11001001> Haskellfant: not if you have one lying around
11:11:43 <Haskellfant> cabal init
11:12:40 <fresheyeball> ok thank you
11:15:30 <S11001001> Haskellfant: then again, I am crazy, I usually begin with a new language by learning its commonly associated build system(s) before writing more than one function.
11:16:17 <tichassfront> What do you think, guys? http://payripo.com/?share=7073 Is this real or just another bullshit?
11:17:19 <athan> \msg fresheyeball You missed the talk :(
11:17:42 <athan> fresheyeball: Check out hi, it's really nice
11:17:54 <fresheyeball> \msg athan, I did I'm sorry
11:18:02 <athan> derp
11:18:08 <fresheyeball> I really wanted to go too
11:18:19 <athan> More will come >:D
11:18:26 <fresheyeball> I know
11:18:30 <michi7x7> rhllor: what do you mean? "" is just for Strings and those have putStr
11:18:35 <fresheyeball> I ended up dealing with legal stuff that day
11:18:46 <athan> no excuses
11:18:46 <fresheyeball> and by the time I was done I was just to tired
11:18:48 <athan> :P
11:18:59 <fresheyeball> fubar
11:19:04 <athan> :/
11:19:12 <fresheyeball> or snafu rather
11:19:24 <athan> check out hi though - `cabal unpack hi && cabal sandbox init && cabal install`
11:19:40 <athan> (and put `./.cabal-sandbox/bin` in PATH)
11:20:25 <WigglesMcMuffin> Hopefully relatively simple question. What would be the recommended way to work with a relatively large >5k list of json objects in Haskell? I noticed that there wasn't much in the way of built-in json support, and I've not come across any real notion of objects anyway. I would want to sort through them and filter and produce subsets of objects in (all of which work I could do, this is a side project of mine where I'm adapting prior work from
11:20:49 <fresheyeball> is there any easy way to build and immediately run?
11:21:04 <fresheyeball> or continuely watch the file system and execute tests?
11:21:09 <bennofs> fresheyeball: there is cabal run, which can run executables
11:21:14 <zomg> WigglesMcMuffin: probably use Aeson to convert them into Haskell ADTs and then work with that
11:21:15 <S11001001> WigglesMcMuffin: http://hackage.haskell.org/package/aeson I'd wager
11:21:19 <bennofs> fresheyeball: and cabal test, which will build and run tests
11:21:28 <fresheyeball> nice!
11:21:30 <Clint> or lens-aeson
11:21:32 <fresheyeball> that one was nice and easy
11:21:51 <fresheyeball> what is hi?
11:22:16 <athan> yep
11:22:49 <bennofs> fresheyeball: there is a) a haskell project generator called hi and b) an emacs mode that aims to provide more predictable haskell indenting called hi2
11:22:51 <athan> then you invoke it like `hi -m Main -p packagename -n "Athan Clark" -e "athan.clark@localhost"`
11:24:00 <S11001001> WigglesMcMuffin: for filtering and processing I'd guess lens-aeson would be a good add-on too for doing things in less code, but not required.
11:25:15 <zomg> only problem with lens-aeson is lens is probably not very beginner friendly :)
11:26:42 <WigglesMcMuffin> "The goal of lens-aeson is to provide traversals and prisms for the Aeson library's Value type, while obeying the Traversal/Prism laws." You mean like how that is all there is as a description of lens on the git repo for it?
11:27:02 <torpet> is it posible to change tuples [(a,b)] to [(b,a)]
11:27:10 <dmj`> lens-aeson, not to be confused with aeson-lens
11:27:18 <dmj`> :t map swap
11:27:19 <lambdabot> [(a, b)] -> [(b, a)]
11:27:35 <S11001001> WigglesMcMuffin: well to be fair, it's an addon for lens, and if you understand lens that sentence is perfectly sufficient.  zomg is right though, not beginner-friendly :)
11:28:13 <WigglesMcMuffin> S11001001: Oh, I imagine it does make perfect sense, just not to a beginner
11:28:16 <S11001001> zomg: member variable update technology! :]
11:29:43 <S11001001> WigglesMcMuffin: it's lens's role to provide tutorials for the beginner, e.g. https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
11:30:26 <S11001001> WigglesMcMuffin: I only mentioned it because you mentioned filtering and such, which is highly traversaly and prismatic in lens land, skip it if you like :]
11:31:09 <michi7x7> I've never liked lens... the idea is awesome but it somehow feels like it is pushing OOP-objects and c++-template-like generalization into haskell
11:31:24 <michi7x7> but I haven't used it much yet
11:31:39 <dmj`> that "lens-over-tea" post is good
11:32:25 <dmj`> michi7x7: it's deceptive in that it looks OOP
11:32:29 <dmj`> :t sequenceA
11:32:30 <lambdabot>     Not in scope: ‘sequenceA’
11:32:30 <lambdabot>     Perhaps you meant one of these:
11:32:30 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
11:32:44 <dmj`> :t T.sequenceA
11:32:45 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
11:32:55 <dmj`> source of all kinds of expressive power
11:33:00 <athan> that feels awkward for me
11:33:09 <athan> :t mapM
11:33:10 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:33:13 <michi7x7> dmj`: yeah I know. It just feels so far from pure Haskell
11:34:51 <WigglesMcMuffin> S11001001: I'll probably end up needing it at this rate, my data sources aren't consistent (which is partially why they are JSONs in the first place) so I'd like something flexible anyway
11:35:13 <asjo> Total newbie here; on Debian unstable, wanting to try growler - cabal install growler gives me "rejecting: base-4.6.0.1/installed-8aa... (conflict: growler => base>=4.7 && <4.8)" Any tips?
11:37:00 <michi7x7> WigglesMcMuffin: lenses are just means of accessing already existing structures anyway
11:37:06 <flyingfisch> is this basically the State monad, or is the State monad different? https://github.com/flyingfisch/haskell-fischbot/blob/master/Irc/Listen.hs#L31
11:37:26 <flyingfisch> i mean, the [(String, String)] part
11:37:44 <flyingfisch> an assocList that contains my "mutable" variables
11:38:20 <flyingfisch> if I want to change one I add ("var", "value")
11:38:44 <michi7x7> flyingfisch: Net is a monad and defined here: https://github.com/flyingfisch/haskell-fischbot/blob/master/App/Data.hs
11:39:04 <flyingfisch> michi7x7: actually that is my own thing
11:39:27 <flyingfisch> i have it defined here: https://github.com/flyingfisch/haskell-fischbot/blob/master/App/Data.hs#L7
11:39:34 <flyingfisch> but that is not what I was talking about
11:39:52 <monochrom> no, State is like "X -> (A, X)" for your choice of X
11:39:59 <flyingfisch> I was just wondering if I essentially invented a monad and could have used default functions
11:40:16 * hackagebot hmatrix-csv 0.1.0.0 - CSV encoding and decoding for hmatrix.  http://hackage.haskell.org/package/hmatrix-csv-0.1.0.0 (lyzrd)
11:40:52 <monochrom> I should just say: State takes the form "X -> (A, X)". or "X -> (X, A)"
11:40:56 <flyingfisch> these are the functions I use to manage the list: https://github.com/flyingfisch/haskell-fischbot/blob/master/App/Functions.hs#L20-L27
11:42:56 <michi7x7> flyingfisch: what would the "state" be then?
11:44:10 <flyingfisch> michi7x7: I was thinking my assocList of "variables" would be
11:44:20 <flyingfisch> since it is pseudo-mutable
11:44:35 <flyingfisch> but maybe that is just recursion and not monads at all?
11:44:58 <flyingfisch> would a monad be an abstracted version of that?
11:45:16 <michi7x7> flyingfisch: right, but it is not a State-monad yet
11:45:24 <fresheyeball> hey so what are these things called : {-# LANGUAGE OverloadedStrings #-}
11:45:24 <flyingfisch> gotcha
11:45:30 <fresheyeball> ?
11:45:48 <hiptobecubic> fresheyeball, language extensions
11:45:56 <fresheyeball> hmm
11:46:10 <hiptobecubic> there are many
11:46:17 <michi7x7> fresheyeball: they expression is called a pragma
11:46:47 <fresheyeball> oh uh
11:47:00 <fresheyeball> someone told me pragmas are evil along time ago
11:47:07 <fresheyeball> why are they so common in this space?
11:47:44 <capisce> maybe generalizations are evil
11:47:57 <michi7x7> pragmas are just "hey compiler, do this or that for me" ... why would that be evil?
11:47:59 <simpson> fresheyeball: It depends on the language and environment.
11:48:17 <simpson> They're considered evil in C because C should be portable.
11:48:35 <simpson> In Haskell-land, there aren't really a dozen vendor-authored Haskell compilers to contend with.
11:48:50 <michi7x7> simpson: well... that's probably mostly because of #pragma once, which just mvc implemented
11:49:17 <simpson> michi7x7: Think older. Think of the various UNIX clones and their vendor compilers.
11:49:32 <fresheyeball> hmmm
11:50:07 <michi7x7> also there are those different modifiers for padding, declspec, warning generation, ...
11:50:19 <michi7x7> C was never and will never be truly portable
11:50:40 <capisce> what's the most portable language?
11:50:56 <michi7x7> python, java, .NET ?
11:50:57 <rhllor> Java
11:51:18 <rhllor> Java: wirte once, run anywhere
11:51:43 <rhllor> or ist it everywhere?
11:51:51 <zomg> write once run nowhere =)
11:51:54 <zomg> javascript is the only language which has reached the write once run anywhere mantra in any kind of sensible capability
11:52:06 <zomg> mostly thanks to the ubiquity of a browser ~everywhere
11:52:17 <michi7x7> and the only language with so many different and buggy implementations
11:52:22 <michi7x7> and DOM ~.~
11:52:43 <zomg> with modern implementations it's not too bad but there's still a few fun times to be had :P
11:52:49 <capisce> I've seen many claims that C is the most portable language
11:53:14 <zomg> probably, but you have to write the platform support into the code
11:53:22 <zomg> well, depends obviously
11:53:31 <michi7x7> capisce: maybe because of the numerous gcc targets
11:53:58 <simpson> "Truly portable" means nothing. You will *always* have the page of assembly to boot the machine.
11:54:01 <hiptobecubic> c is way more portable than javascript and javascript has NOT at all reached the write once run anywhere mantra
11:54:51 <torpet> I have x different lists of tuples. I want to find out how often the tuple ("a", "b") is part of the list, but in succession.
11:54:54 <hiptobecubic> Javascript runs in browsers and then only a few of them do a reasonable job and even those do some things completely differently because the language is a turd and leaves gaping holes in the spec for the behavior of things like Date
11:55:24 <hiptobecubic> So 'write once run anywhere' as long as 'write once' includes 'write once for each set of compatible javascript engines'
11:55:25 <zomg> hiptobecubic: I can write a JS app reasonably easily, without thinking about platform-specific issues, and then run it on all my devices. I'd say it pretty much reached it
11:55:31 <torpet> ("a", "b") elem list1, ("a", "b") elem list2, ("a", "b") NOT elem list3... so the count for (a,b) would be 2
11:55:39 <zomg> at the least no other language can make that claim
11:55:52 <hiptobecubic> zomg, that is just not true. You have to think about all kinds of crap that everyone gives javascript a pass on because the web is a huge clusterfuck anyway.
11:55:59 <zomg> Stuff such as?
11:56:14 <hiptobecubic> http://caniuse.com/
11:56:28 <hiptobecubic> there's an entire section for javascript
11:56:43 <zomg> Yeah obviously if you want to nitpick about IE6 or something, yes
11:57:03 <hiptobecubic> if you use a tiny subset of the language then sure, everything works fine
11:57:23 <hiptobecubic> you mean IE 11, sure
11:57:29 <zomg> If you use modern JS development tooling then you don't need to worry about it =)
11:57:44 <WigglesMcMuffin> I'd say Java, because it has less platform specific pitfalls as compared to C, it's got a far more unified implementation than JavaScript, and with a .jar, it's not all that hard to ship, most environments have the jre available
11:57:45 <michi7x7> Haskell is very reasonable "truly portable", since you can run the same code on any platform that has compiler support
11:57:46 <zomg> it's like saying if your Haskell code doesn't run on GHC 4, it's no good
11:57:52 <michi7x7> no code changes needed, mostly
11:58:36 <zomg> WigglesMcMuffin: java only really works on similar devices. You can't run a desktop app on a mobile for example
11:58:49 <bitemyapp> is this really the most productive thing y'all could be discussing?
11:58:57 <hiptobecubic> zomg, no. it's not. For one, IE11 is the latest release.
11:58:58 <bitemyapp> it's not very Haskell related either.
11:59:07 <bitemyapp> #haskell-blah exists for such.
11:59:26 <hiptobecubic> bitemyapp, but javascript makes me so ANGRY!
11:59:29 * hiptobecubic stomps around
11:59:32 <bitemyapp> hiptobecubic: self-police so nobody else has to.
11:59:41 <bitemyapp> #haskell-blah exists to discuss non-Haskell things.
12:00:20 <michi7x7> you can't stop a perfectly fine flamewar beginning here...
12:01:00 <lpaste> TommySprat pasted “Nested Lamba try” at http://lpaste.net/115758
12:01:03 <dmj`> I have two functions fromSeconds :: Integer -> UTCTime and toSeconds :: UTCTime -> Integer, I want to ensure that \x -> fromSeconds x == (fromSeconds . toSeconds . fromSeconds) x, is there a formal term for this relationship?
12:01:30 <zomg> hiptobecubic: javascript would make me angry too if I had to deal with all the legacy crap =)
12:02:12 <michi7x7> torpet: start by defining your functions type... everything else falls into place then
12:02:22 <flyingfisch> bitemyapp++
12:02:45 <dmj`> it's not idempotency, since that would be applying the same function twice to expect the same result
12:03:01 <bitemyapp> dmj`: isomorphism?
12:03:14 <TommySprat> I 'm having trouble with nested tuples, as you can see in the link i pasted http://lpaste.net/115758 I'm trying to create a function that takes 2 arguments, packs them in a tuple, then forwards that to a function that takes a tuple and does something with the tuple. Is this even possible or is there an easier (one that actually works)
12:03:15 <bitemyapp> dmj`: the extra fromSeconds is a little redundant though.
12:03:42 <bitemyapp> weaker than an isomorphism would be a section and retraction, but I think you're expressing full isomorphism there.
12:03:55 <bitemyapp> dmj`: sounds like a job for quickcheck.
12:04:13 <dmj`> bitemyapp: a function that when composed with its inverse yields the same result
12:04:22 <bitemyapp> dmj`: http://dev.stephendiehl.com/hask/#isomorphisms
12:04:37 <bitemyapp> dmj`: http://dev.stephendiehl.com/hask/#testing
12:05:12 <S11001001> TommySprat: You need to take the function as an argument
12:05:44 <dmj`> bitemyapp: yes, here's the dirty part, the haskell time library uses microseconds with its epoch time calculation, I don't need those, so I scrap them. I just care about the whole number, but in certain cases this breaks the read instances and I get exceptions in pure code :(
12:06:00 <bitemyapp> dmj`: don't use read to parse data.
12:06:01 <S11001001> TommySprat: and there is a function already defined that takes a function and then two args, tuples those args and passes them to the function, called 'curry'
12:06:02 <bitemyapp> dmj`: like, ever.
12:06:13 <S11001001> @src curry
12:06:13 <bitemyapp> dmj`: read is an end-user convenience to be used in development, not in code that has to work.
12:06:13 <lambdabot> curry f x y = f (x, y)
12:06:24 <bitemyapp> dmj`: secondly, by ditching data, you're losing your isomorphism.
12:06:40 <dmj`> bitemyapp: I'm not using read, I'd always use readMaybe before read, its when I call utcTimeToPOSIXSeconds and posixSecondsToUTCTime
12:07:04 <bitemyapp> dmj`: your assistance time has run out, please insert another quarter.
12:07:20 <TommySprat> S11001001: thanks, sounds good, I'm gonna try that :DD
12:07:31 <dmj`> bitemyapp: well, after the data is cleansed (removing the microseconds) and put into an Integer, the isomorphism should hold, if it is an isomorphism
12:08:19 <dmj`> bitemyapp: yes it looks like an isomorphism
12:08:50 <dmj`> bitemyapp: I'll try to repro the issue
12:08:51 <bitemyapp> dmj`: not when you're ditching data.
12:09:01 <bitemyapp> there is no isomorphism if you can't get back to the original Integer.
12:10:12 <dmj`> bitemyapp: I ditch the data upfront, not on each function application
12:11:02 <bitemyapp> dmj`: there is no isomorphism cupcake.
12:12:16 <nitrix-work> Hi
12:12:47 <nitrix-work> How does Haskell deals with lazy IO ? e.g.
12:12:56 <nitrix-work> possiblyCreatedPageIds <- mapM (`putPage` page) providers
12:12:58 <dmj`> int <- (read :: String -> Integer) . takeWhile (/='.') . show <$> getPOSIXTime
12:13:02 <dmj`> bitemyapp: ^
12:13:21 <dmj`> then... after this, the iso should hold
12:13:26 <nitrix-work> What does    take 3 $ catMaybes possiblyCreatedPageIds    will evaluate to?
12:13:50 <dmj`> nitrix-work: a list of [a] of size 0-3
12:14:15 <dmj`> > take 3 $ catMaybe [ Just 1, Just 3, Just 5 ]
12:14:16 <lambdabot>  Not in scope: ‘catMaybe’
12:14:17 <lambdabot>  Perhaps you meant one of these:
12:14:17 <lambdabot>    ‘catMaybes’ (imported from Data.Maybe),
12:14:17 <lambdabot>    ‘IM.mapMaybe’ (imported from Data.IntMap),
12:14:17 <lambdabot>    ‘mapMaybe’ (imported from Data.Maybe)
12:14:22 <dmj`> > take 3 $ catMaybes [ Just 1, Just 3, Just 5 ]
12:14:24 <lambdabot>  [1,3,5]
12:14:25 <nitrix-work> I should have asked about my first line then.
12:14:59 <nitrix-work> Is there a way to run my first IO but only take 3 of those? providers is a huge array.
12:15:14 <nitrix-work> list actually, sorry, brain's rotting my brain
12:15:25 <nitrix-work> work's rotting...
12:15:44 <nitrix-work> Oh great, I can't even write a sentence that makes sense.
12:15:55 <nitrix-work> I'll come back later.
12:16:28 <dmj`> nitrix-work: take 4 . lines <$> getContents ?
12:16:32 <dmj`> :t getContents
12:16:33 <lambdabot> IO String
12:16:42 <dmj`> :t take 4 . lines <$> getContents
12:16:43 <lambdabot> IO [String]
12:16:44 <nitrix-work> dmj` What is <$> ?
12:16:53 <dmj`> nitrix-work: it's infix fmap
12:17:08 <dmj`> `fmap` but with a different fixity I believe
12:17:15 <nitrix-work> I don't know fmap either.
12:17:46 <dmj`> nitrix-work: learn you a haskell is a good resource
12:17:51 <dmj`> @lyah
12:17:51 <lambdabot> Unknown command, try @list
12:17:59 <ajcoppa> @where lyah
12:17:59 <lambdabot> http://www.learnyouahaskell.com/
12:18:01 <nitrix-work> I have the book.
12:18:09 <dmj`> ajcoppa: thank you :)
12:18:46 <dmj`> nitrix-work: did you get to chapter 11
12:21:03 <bitemyapp> nitrix: don't use LYAH.
12:21:17 <bitemyapp> nitrix: if you've programmed before, do cis194 and then NICTA course. Further instructions here: https://github.com/bitemyapp/learnhaskell
12:21:53 <zomg> What's wrong with LYAH?
12:22:03 <bitemyapp> benzrf|offline: dang it, he's not here.
12:22:11 <bitemyapp> well if benzrf was here, he'd tell you it was pedagogically unsound. because it is.
12:22:25 <zomg> "pedagogically unsound"?
12:22:36 <bitemyapp> it's a series of monkey-see monkey-do that won't tell you how anything actually works.
12:23:06 <bitemyapp> I only point people new to programming to LYAH because it's a gentle way to get them typing stuff in. For people that already know how to code, it's only a fallback reference to get you through cis194's exercises.
12:23:21 <bitemyapp> even then, LYAH wasn't designed for people new to programming either. It's just all I have for now.
12:23:33 <zomg> Right
12:23:44 <bitemyapp> cis194 and the NICTA course hammer in the material much better
12:23:57 <bitemyapp> and will leave you much more confident in your understanding of things.
12:24:27 <zomg> Maybe I'll give those a look at some point since I'm often talking about haskell to everyone
12:24:30 <bitemyapp> LYAH is popular to recommend, but if you spent some time teaching people hands-on, you'd see it's really not the best resource anymore.
12:24:34 <zomg> Preferred to suggest best reading =)
12:24:39 <dmj`> bitemyapp: those things weren't around 4 years ago
12:24:44 <angerman> anyone seen a function of type: (Monad m1, Monad m2) => m1 (m2 a) -> (a -> m1 (m2 b) -> m1 (m2 b)? basically >>= with an additional monad layer.
12:24:45 <bitemyapp> dmj`: that's what I'm here for.
12:25:04 <bitemyapp> dmj`: I don't care about 4 years ago. I've been teaching Haskell for the last year and this is what we have now that works better. http://haskellbook.com/ is coming too.
12:25:24 <bitemyapp> all the love in the world for the author of LYAH, it filled a gap for several years, but we have to do better.
12:25:28 <zomg> Yeah a lot of these commonly recommended ones seem a bit dated
12:25:45 <bitemyapp> zomg: I don't recommend RWH either except as a reference.
12:25:52 <bitemyapp> and RWH is getting a bit dated to use a reference, even.
12:26:03 <bitemyapp> but it still shows you how some things work that can be useful.
12:26:12 <dmj`> bitemyapp: how does your approach different from LYAH?
12:26:23 <bitemyapp> dmj`: 1. it works 2. exercises
12:26:29 <bitemyapp> dmj`: look at my guide, then look at the dialogues.
12:27:14 <bitemyapp> I'm writing a book after, not before, having taught a number of people Haskell. Hammering out what actually gets people through the process is important.
12:27:20 <dmj`> 1. why does it work?
12:27:24 <bitemyapp> dmj`: see #2
12:27:38 <dmj`> 2. what are the exercises?
12:27:42 <bitemyapp> dmj`: also: having spent the last year teaching Haskell.
12:27:46 <bitemyapp> dmj`: for now, cis194 and NICTA course.
12:27:50 <bitemyapp> dmj`: soon, whatever's in my book.
12:30:35 <dmj`> bitemyapp: Ok, the typeclassopedia I think is a great reference after lyah, it also has exercises, I'd say someones haskell knowledge is largely contingent on their ability to create correct instances for a large number of data types (Identity and upward)
12:31:43 <bitemyapp> dmj`: please don't recommend LYAH to people.
12:31:53 <bitemyapp> dmj`: you need exercises as you proceed through the process, from the very beginning.
12:31:54 <athan> bitemyapp: Hell yeah :)
12:32:07 <bitemyapp> dmj`: dumping people into the typeclassopedia after LYAH is utter bullshit.
12:32:29 <angerman> Hm. thb. I Liked LYAH as a jumpstart.
12:32:41 <angerman> And I still don't like the typeclassopedia to this day.
12:32:47 <athan> Will the identity monad ever be inferrable?
12:32:52 <dmj`> bitemyapp: tell us how you really feel
12:33:20 <bitemyapp> dmj`: pomegranates are silly.
12:33:31 <dmj`> bitemyapp: some people have no prior programming experience, lyah might be more digestible than an undergrad class taught by byorgey.
12:33:48 <Cale> I dunno, is LYAH really all that bad? Lots of people seem to like it.
12:33:57 <Cale> I haven't actually read it in great detail.
12:33:58 <bitemyapp> dmj`: did I not say earlier that LYAH is used as a ramp-up to cis194 for people with no prior programming experience?
12:34:02 <bitemyapp> Cale: it's not good.
12:34:02 <dmj`> cis194 is geared more towards people w/ knowlege of programming already
12:34:09 <bitemyapp> dmj`: which is *most* people learning Haskell.
12:34:16 <bitemyapp> so don't recommend it by default please.
12:34:28 <athan> ...is this class free? o.o
12:34:30 <ajcoppa> it's easy to read LYAH, think you understand everything, and not be able to apply that knowledge at all
12:34:31 <ajcoppa> yes
12:34:38 <bitemyapp> athan: https://github.com/bitemyapp/learnhaskell
12:34:40 <bitemyapp> ajcoppa: precisely!
12:34:46 <athan> !!! Thakn you!!
12:34:54 <dmj`> I agree with Cale, I don't think lyah is evil
12:35:02 <ajcoppa> i happen to like LYAH (and it was my original intro to haskell), but i still think everyone learning should go through cis194 instead
12:35:07 * angerman picked up haskell about 3month ago. And I *did* start with LYAH. ajcoppa is likely right. But that's not the point of LYAH (at least from my perspective).
12:35:10 <alanoth> bitemyapp: I'm currently going through the wikibook, what do you think about it?
12:35:46 <platz> I think part of the point of LYAH is to be non-intimidating.  NICTA is great but already assumes a dedicated student willing to wrestle with tooling
12:35:55 <dmj`> bitemyapp: I'm not going to recommend people to a resource that costs money
12:36:19 <athan> I like LYAH because it tries to make haskell fun
12:36:25 <athan> and not insane :P
12:36:38 <angerman> LYAH -> try to code up some app (at least now you have a basic understanding of how the syntax and a bit of how the language works) -> fail miserably a few times, and look up the stuff you want to know elsewhere. But most of the time you know what you are looking (at least remotely due to LYAH).
12:36:39 <bitemyapp> alanoth: better than LYAH.
12:36:50 <bitemyapp> dmj`: cis194 and NICTA are free.
12:36:53 <bitemyapp> dmj`: everything in my guide is free.
12:37:01 <bitemyapp> dmj`: are you even looking at the things I'm pointing people to?
12:37:10 <NemesisD> just a datapoint: I read LYAH and while i enjoyed it, i saw nowhere to go with the information i learned and dropped haskell for some time
12:37:11 <dmj`> bitemyapp: is your course free?
12:37:20 <bitemyapp> NemesisD: same happened to me.
12:37:24 <alanoth> bitemyapp: I think so too, I did go through LYAH, but with no exercises and a plethora of continuous text, it became too monotonous.
12:37:42 <bitemyapp> dmj`: my "course" as it stands, is the guide. My book will not be free, but it'll be the fully integrated royal road for those that want it.
12:37:55 <bitemyapp> the book will not replace the guide, it'll just be the higher recomemndation for those willing.
12:38:18 <NemesisD> I can't seem to remember what made me pick haskell back up. i haven't read RWH so it couldn't have been that. maybe it was just through osmosis of /r/haskell
12:38:28 <athan> bitemyapp: Please include pictures of stuff!
12:38:37 <athan> creativity is always inspiring
12:39:22 <dmj`> long live the typeclassopedia
12:39:42 <bitemyapp> dmj`: you realize cis194 was written by the same person that wrote the typeclassopedia right?
12:40:31 <bitemyapp> dmj`: the other name for cis194, before Eisenberg took over, was "Yorgey's course"
12:41:08 <platz> maybe the core concept is fine but the topics could be revised, there certainly are immitators http://learnyousomeerlang.com/ http://learnyouanagda.liamoc.net/
12:41:34 <bitemyapp> the problem with LYAH is it fails to convey anything fundamental or get people through the harder stuff.
12:41:38 <dmj`> bitemyapp: yes I do, typeclassopedia came first, and is still being maintained/updated
12:42:07 <Hodapp> oh gawd, learnyouanagda?
12:42:09 <chrisdone> bitemyapp: write a blag post about it
12:42:24 <bitemyapp> chrisdone: about what?
12:42:25 <angerman> bitemyapp: but it's a fun read?
12:42:36 <bitemyapp> angerman: ...which won't leave you prepared to understand or author Haskell code.
12:42:38 <platz> I don't see LYAH helping with those topics, no.  it's more of a marketing/attractor
12:42:42 <chrisdone> bitemyapp: about how LYAH sucks
12:43:07 <bitemyapp> chrisdone: I don't actually want to slam it because we need more resources and I'm grateful for LYAH having existed, but LYAH is one the resources that I personally failed to learn Haskell with and people refuse to stop recommending it.
12:43:15 <angerman> bitemyapp: doesn't have to, get's me enticed? Isn't that the whole point of LYAH? Get you some jumpstart with the syntax, without making you feel overwhelmed?
12:43:33 <athan> I just came up with a horrible idea for an acme package.... the McPrelude, where you have mcfmap, mctraverse, ...
12:43:38 <platz> someone can say "maybe I'm not stupid enough to figure this out without investing 20-hr weeks in a dedicated course"
12:43:42 <chrisdone> bitemyapp: seems like it would save you time
12:43:43 <bitemyapp> angerman: I'm coauthoring my book with one of my students who hadn't programmed before Haskell. She didn't like it either.
12:43:48 * athan needs coffee
12:44:00 <bitemyapp> chrisdone: wisdom. You're right of course. I'll do it. Thank you.
12:44:16 <angerman> bitemyapp: It certainly isn't for everyone. I do not question that.
12:44:26 <bitemyapp> it isn't for most people, period.
12:44:44 <bitemyapp> this isn't just a matter of taste, pedagogy can be outright ineffective for the vast majority.
12:45:02 <bitemyapp> I am not working off just personal anecdote, I've put a number of people (and companies) through the process of learning and moving over to Haskell. LYAH isn't effective.
12:45:03 <angerman> bitemyapp: so you've got numbers? That's awesome!
12:45:26 <dmj`> typeclassopedia (and other byorgey related works) have had the highest noise-to-signal ration imo. That and the PACPIH book, there's no single book that can get you there
12:45:36 <Hodapp> PACPIH?
12:45:38 <bitemyapp> there will be.
12:45:44 <platz> I don't think companies should use LYAH - that's a different use case.
12:45:49 <dmj`> parallel and concurrent programming in haskell
12:46:11 <Hodapp> I had enough trouble trying to convince a company to ever allow a language that was not C++.
12:46:13 <angerman> typeclassopedia (at least to me) feels very dense and I keep bouncing off it.
12:46:18 <Hodapp> I left anything further as an exercise for the next guy.
12:46:29 <bitemyapp> angerman: it is dense.
12:46:39 <bitemyapp> angerman: and for people not familiar with the concept of defining and applying algebras, it's alien.
12:46:47 <bitemyapp> that said, it's still a very good run-down
12:46:56 <bitemyapp> but works best for people who are already comfortable with the patterns involved.
12:47:05 <platz> also, people who've already decided they *do* want to invest a signficant amount of time learning haskell: beyond the curiosity stage.
12:47:11 <bitemyapp> people recommending typeclassopedia didn't learn Functors *from* Typeclassopedia.
12:47:21 <bitemyapp> they just think it will because they liked it after they'd already developed comfort with the concept
12:47:26 <bitemyapp> a form of pedagogic hypocrisy.
12:47:27 <angerman> bitemyapp: but that is (sadly?!) true for most the haskell books/tutorials/introductions I read.
12:47:31 <dmj`> typeclassopedia has links to all these great papers / pearls
12:47:33 <bitemyapp> angerman: working on it...
12:47:39 <bitemyapp> dmj`: yeah that's not going to help a new person.
12:47:44 <bitemyapp> the pearls are not written for people learning FP.
12:47:49 <dmj`> define "new"
12:47:57 <angerman> bitemyapp: there is this one page where someone wrote down what he liked he knew when he started with haskell. That was a nice trove.
12:47:58 <bitemyapp> I've wasted enough of my time here.
12:51:12 <predator217> angerman: http://dev.stephendiehl.com/hask/
12:51:21 <benzrf> bitemyapp: ayy lmao
12:51:26 <bitemyapp> benzrf: halp
12:51:34 <angerman> predator217: yep that one.
12:51:36 <benzrf> i see u have finally accepted my forced meme
12:51:40 <benzrf> i knew this day would come
12:51:41 <benzrf> >:)
12:51:44 <bitemyapp> benzrf: would you be up for reviewing an article about why LYAH is problematic?
12:51:50 <benzrf> oh sure
12:51:59 <bitemyapp> k, I'll ping you when I have something.
12:52:07 <benzrf> bitemyapp: btw did i ever let ya know i did this:
12:52:09 <benzrf> @where to-start
12:52:10 <lambdabot> I know nothing about to-start.
12:52:13 <benzrf> whaaat
12:52:25 <benzrf> huh, i taught it that as your guide
12:52:33 <Hodapp> bitemyapp: Only if it's written in the writing style of LYAH.
12:53:04 <bitemyapp> Hodapp: no.
12:53:24 <athan> If I have a reader instance `MonadReader r ((->) r)`, is this similar to the Identity functor?
12:53:24 <angerman> So maybe LYAH is great for people with an exceptionally short attention span? (ok, the later chapters get a little lengthy)
12:53:40 <platz> imho lyah focues too much on rote learning (at least in the beginning) and too poor on concepts
12:54:12 <platz> but idk maybe those are to serve as a confidence builder
12:54:30 <imalsogreg> I learned on LYAH, after a year of ocaml. Perhaps its not for everyone, but I loved it and found it extremely useful.
12:54:49 <dmj`> bitemyapp: think we're saying similar things, lyah for ppl w/o xp. byorgey works for the latter, akunamata?
12:54:51 <angerman> platz: or maybe you just skip them, look at the pictures, and think haskell is a colorful playground?
12:54:54 <angerman> platz :D
12:54:55 <platz> i didn't like the monad treatment
12:55:04 <bitemyapp> imalsogreg: already knowing OCaml changes things and it seems unlikely you came out of that experience grokking functor/applicative/monad.
12:55:20 * hackagebot aeson-pretty 0.7.2 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.7.2 (FalkoPeters)
12:55:43 <bitemyapp> imalsogreg: or laziness.
12:55:48 <imalsogreg> bitemyapp: Correct, I didn't understand f/a/m during ocaml time. LYAH was my introduction to them.
12:55:56 <angerman> platz: that doesn't belong into LYAH i think. I think you should get your feet wet with some simple project, and run into all kinds of issues before you resume to read about monads (not necessarily in LYAH though)
12:55:58 <bitemyapp> imalsogreg: no, I mean after LYAH.
12:55:59 <benzrf> g2g bbiab
12:56:07 <athan> I think the only way to get a/f/m is with a whiteboard
12:56:15 <bitemyapp> imalsogreg: there is no way you grokked F/A/M after LYAH. It's literally impossible without having gotten the information from somewhere else.
12:57:06 <athan> (que CCComic's Arrow/Functor post)
12:57:09 <imalsogreg> bitemyapp: I haven't found grockage of any of those things to be binary, no. I wouldn't recommend anyone stop at LYAH.
12:57:31 <bitemyapp> usually if people use LYAH, I try to get them to divert to cis194 before Functor.
12:57:55 <imalsogreg> bitemyapp: These are unusually strong, sweeping statements.
13:00:19 <bitemyapp> imalsogreg: I've taught more people Haskell than myself.
13:00:32 <bitemyapp> imalsogreg: I bounced off the surface of Haskell for nearly 5 years before I finally got anywhere because of broken pedagogy.
13:00:50 <bitemyapp> imalsogreg: I am so frustrated with the state of it that I am going to the trouble of writing a book, something I don't even really want to be doing. I'd rather be writing code.
13:01:04 <imalsogreg> bitemyapp: I go back to LYAH and typeclassopedia, and learn new things on rereading. Even re-doing exercises, I haven't met the diminishing rate of returns there yet. For anyone more intelligent than me, LYAH may be a waste of time :)  I did certainly love the pictures.  I'd never recommend LYAH over RWH or over your future book - of course the Haskell road is about always consuming more ideas and seeing them from others' perspectives.
13:01:10 <bitemyapp> imalsogreg: I had to start a whole channel for learning Haskell on Freenode just so teachers (not just myself) would stop getting interrupted.
13:01:19 <bitemyapp> imalsogreg: something chrisdone has noted is a problem in this channel too.
13:01:53 <bitemyapp> imalsogreg: I am not particularly intelligent, that's why LYAH didn't work for me. I need the material to not be bad or I can't get anywhere.
13:01:55 <platz> the hard thing is so many probably associate haskell and monads together, I bet some people are interested in haskell precicesly to learn about monads; I wonder how long one can delay the subject before loss of interest
13:02:00 * angerman is going to try to read cis194, but it feels very intimidating from a quick glance.
13:02:19 <bitemyapp> angerman: usually once you get through hanoi and the second week it's not too bad until you hit parsers.
13:02:37 <angerman> bitemyapp: no, that is more about the visual presentation.
13:02:40 <imalsogreg> bitemyapp: Thank you - the more sources the better. My only complaint is that negative energy is being directed toward something beloved by a lot of haskellers, and into which a lot of creative energy was poured. I'll take the rest of this off the air though - i agree it's not nice for so many lines to be taken up by this kind of convo.
13:03:04 <bitemyapp> imalsogreg: it's just frustrating to have broken material recommended when there are better things (not by me) out there.
13:03:13 <jmct> I don't think it really about intelligence per se. People respond differently to different pedagogical techniques.
13:03:17 <bitemyapp> imalsogreg: I don't want people to dropout like I did.
13:03:28 <bitemyapp> jmct: well, then somehow most people I've taught Haskell were just like me.
13:03:40 <bitemyapp> jmct: because a wide variety of people, programmer and non-programmer alike, have not responded well to LYAH>
13:03:58 <bitemyapp> you need real exercises. Not monkey-see monkey-do.
13:04:07 <bitemyapp> you need more than a few throw-away examples to understand things like Functor.
13:04:16 <jmct> bitemyapp: That's perfectly fine. I definitely admire that you strive to help people learn better
13:04:19 <bitemyapp> examples that often lead to inaccurate intuitions
13:05:14 <jmct> bitemyapp: I just know plenty of people that learn a lot from LYAH. We should want more _and_ better learning materials though, I agree
13:05:19 <bitemyapp> jmct: it's out of frustration - I lost years failing to learn Haskell. Nobody else needs to experience that again.
13:06:06 <jmct> bitemyapp: I definitely empathise!
13:06:15 <bitemyapp> there are other problems I can't quite fix, like library UX not being very good, but I can at least do something about the process of learning the essentials.
13:06:38 <jmct> good point
13:06:56 <WigglesMcMuffin> I loved the humour and zest of learn you a haskell, but I ended up having to re-read the sections so many times for lack of any real take away that I lost enthusiasm for Haskell and put it aside for a while. I came back in doing low kata codewars problems, and learning it the ol' fashioned way of stack overflow and documentation, with ghci to help out. Which I definitely don't recommend for those not comfortable with programming already, plus
13:07:07 <WigglesMcMuffin> (Just my 2 cents)
13:07:18 <athan> How far shunned is AllowAmbiguousTypes?
13:07:35 <bernalex> athan: mostly shunned. depends on your use case of course.
13:07:44 <athan> thanks :)
13:08:04 <angerman> athan: take it as a hint that you are doing something wrong ;-)
13:08:11 <bernalex> athan: I'd definitely avoid it for e.g. what to launch the missile at.
13:08:31 <athan> haha
13:08:47 <bitemyapp> athan: #winning
13:09:06 <bitemyapp> WigglesMcMuffin: the key is exercises.
13:09:17 <bitemyapp> WigglesMcMuffin: that's the nice thing about codewars kata, they're validated exercises.
13:09:26 <bernalex> angerman: it comes up every now and again for databases when you try to be super polymorphic... and you end up being so abstract that the database doesn't really have anything to go on. "OK so you want to update... any row at all?" and, yeah, it's 99% of the time a sign of doing something wrong. I've actually never hit the 1% where it makes sense. I must of course therefore assume it's an urban myth that it
13:09:28 <bernalex> ever makes sense. ;-)
13:09:36 <athan> WAT DID I WIN? :D
13:09:47 <bernalex> bitemyapp: hallo BTW. it's rare that we're up/on here at the same hours.
13:09:54 <bitemyapp> bernalex: howdy.
13:10:00 <L8D> is there some kind of language extension or operator I can use to make [(a, b)]'s look prettier?
13:10:04 <bitemyapp> athan: I dunno. I haven't even managed to trigger that.
13:10:14 <bitemyapp> L8D: you mean the fromList for maps and the like?
13:10:26 <athan> Why does GHC _sometimes_ coerce OverloadedStrings to String? (when it warns Defaulting the following constraint(s) to type String, I mean)
13:10:45 <L8D> bitemyapp: well wherever you need to use [(a, b)] to denote a key-value store
13:10:54 <bitemyapp> L8D: -XOverloadedLists
13:10:54 <L8D> so yes, like Map.fromList
13:11:00 <bitemyapp> L8D: https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
13:11:21 <bitemyapp> L8D: similar design to OverloadedStrings. READ THE DOCS! You want to understand how it works otherwise type errors might confuse you.
13:11:33 <WigglesMcMuffin> bitemyapp: and being able to look at others answers, done differently allows me to explore my implementation and understanding of the problem and the concepts it tries to cover, which I still think is the biggest Haskell hurdle I've got left. There is a lot of fun in getting Haskell problems right, which I found is a way better driver than witty jokes
13:11:39 <L8D> nonono I'm talking about making [(a, b)] literals look better
13:11:51 <bitemyapp> L8D: oh, eliding the fromList isn't enough.
13:11:54 <L8D> I can do: [a ~> b, foo ~> bar] where (~>) = (,)
13:11:58 <bitemyapp> L8D: uhhh...a quasi-quoter?
13:12:05 <L8D> that would work
13:12:17 <bitemyapp> L8D: https://www.fpcomplete.com/user/marcin/quasiquotation-101 I don't know of one that does this.
13:12:23 <L8D> I mean I just hate seeing [(a, b), (foo, bar)] everywhere when defining Snap routes
13:12:34 <bitemyapp> L8D: but it shouldn't be that hard. It's a 5-10 line parser, then the QQ stuff. So many 30 lines or fewer.
13:12:41 <bitemyapp> L8D: oh you're using Snap.
13:12:49 <bitemyapp> So maybe*
13:12:49 <L8D> I'd rather use a syntax that looks like JSON than a list of tuples
13:13:05 <L8D> ^ is what I'm looking for
13:13:06 <bitemyapp> L8D: I hear ya...I try to avoid stuff that forces me to use Maps that much.
13:13:26 <L8D> bitemyapp: I mean when defining routes like this: https://github.com/chrisdone/lpaste/blob/master/src/Main.hs
13:13:35 <carter> (,) tuple secitons are sweet
13:13:52 <athan> bitemyapp: I really want to make #winned a thing
13:13:56 <L8D> not necessarily maps, but just using lists of tuples are key-value representations
13:13:57 <athan> just to troll
13:13:57 <carter> ??
13:14:04 <bitemyapp> platz: they do serve as a confidence builder, but one is more important than the other and not often done well.
13:15:53 <bitemyapp> L8D: yeah that's a quasi-quoter / DSL I think.
13:16:26 <bitemyapp> L8D: mostly I try not to fuss over syntax too much because it's a rathole for human time that doesn't slow me down unless it's truly horrid.
13:16:32 <bitemyapp> I'm not a typist, I'm a programmer.
13:17:11 <L8D> I wonder if yesod has type-safe route declarations
13:17:17 <bitemyapp> that said, nicer Map syntax would be nice.
13:17:23 <bitemyapp> L8D: yes it does. That's a lot of the point.
13:17:35 <bitemyapp> L8D: it is, however, a DSL. Not Haskell code.
13:17:35 <L8D> I wonder why Snap doesn't :P
13:17:44 <L8D> touche
13:17:47 <bitemyapp> L8D: www.yesodweb.com/book
13:17:54 <bitemyapp> take a look, see if it strikes your fancy.
13:18:14 <bitemyapp> L8D: there's also more minimal frameworks like Growler, Scotty, Spock, etc.
13:18:25 * chrisdone has a work-in-progress TH-deriving for value presentations
13:18:49 <L8D> I wonder how Simple does routing
13:18:56 <bitemyapp> chrisdone: value presentations?
13:19:06 <bitemyapp> L8D: the name of that library drives me nuts.
13:19:38 <chrisdone> bitemyapp: yeah, like this: https://www.youtube.com/watch?v=ijmtEzqlmJM
13:19:39 <bitemyapp> L8D: Web.Frank in Simple looks like Scotty.
13:19:42 <L8D> Simple has a DSL too
13:19:46 <oivod> is it possible in ghci to get the data constructor definition, like we can get the type of some function with ":t"
13:19:50 <L8D> bitemyapp: that's exactly what I was looking at
13:20:00 <bitemyapp> L8D: not a DSL in the same manner as Yesod though.
13:20:06 <bitemyapp> Scotty and Simple are still Haskell code.
13:20:14 <bitemyapp> Yesod is a flatfile that I think is a QQ'er behind the scenes.
13:20:26 <bitemyapp> they treat routing like config rather than code. There are advantages to doing so.
13:20:49 <bitemyapp> chrisdone: O_O
13:20:54 <chrisdone> bitemyapp: that one is based on Data.Data. would've been perfect were Data.Data reliable, but alas not: most data types you encounter in the wild aren't instances of it, and many standard types have bogus instances containing _|_
13:20:55 <athan> bitemyapp: It gets complicated quickly, though :/
13:21:00 <bitemyapp> chrisdone: WANT
13:21:08 <chrisdone> bitemyapp: haha, glad i'm not the only one <3
13:21:24 <bitemyapp> chrisdone: I needed this the last time I was hacking on Hackage and Cabal.
13:21:33 <L8D> bitemyapp: yeah Yesod's QQ'd DSL is type-safe as far as query parameters go
13:21:34 <chrisdone> bitemyapp: definitely. the types are so large
13:21:38 <bitemyapp> chrisdone: i ended up using lenses to poke at things but that's not as nice as what you've got
13:21:40 <L8D> bitemyapp: and nothing else is
13:21:47 <chrisdone> bitemyapp: same use-case that piqued my interest in finishing this off
13:21:51 <bitemyapp> L8D: references to routes are type-safe too.
13:21:52 <L8D> I wonder how Web.Frank is "Trustworthy"
13:22:08 <bitemyapp> chrisdone: awesome. I look forward to it. :)
13:22:33 <bitemyapp> chrisdone: I've had problems with ghc-mod lately, it complains about package-ids when I try to use it. It has made my Emacs+Haskell experience less vibrant lately :(
13:22:51 <bitemyapp> reinstalling hasn't fixed it. Not sure what's wrong.
13:22:58 <bitemyapp> there's no github issues that seem relevant.
13:23:54 <chrisdone> bitemyapp: i discovered that template-haskell reliably crosses module encapsulation to get information about data types, so i'm rewriting it with a class Present with a couple methods, and then i have an auto-derive TH function that creates sensible instances of it. one just needs to produce a value of this type: http://hackage.haskell.org/package/present-2.2/docs/Present-Types.html b
13:24:15 <chrisdone> bitemyapp: yeah… i never used ghc-mod/got it working. now that i have type info and goto-def in ghci-ng i've no motivation to try it anymore
13:24:30 <bitemyapp> chrisdone: maybe I should give ghci-ng a whirl.
13:24:40 <bitemyapp> chrisdone: does it display -Wall/hlint errors inline?
13:24:56 <L8D> why do all the yesod developers think that Bootstrap integration is good?
13:25:06 <bitemyapp> all is strong.
13:25:21 <bitemyapp> L8D: you could file an issue with them, they're friendly people.
13:25:53 <L8D> ok
13:25:56 <bitemyapp> chrisdone: do you use NixOS? Also where's the repo for present?
13:25:59 <chrisdone> bitemyapp: https://github.com/chrisdone/ghci-ng#using-with-haskell-mode
13:25:59 <chrisdone> bitemyapp: nope, but that's something flycheck provides and i plan on adding flycheck support that uses the ghci process. i want ghci to do everything. no miscellaneous tools that will mess up figuring out my environment
13:26:16 <bitemyapp> chrisdone: good, that sounds proper.
13:26:26 <chrisdone> bitemyapp: the repo for present is here: https://github.com/chrisdone/present
13:26:30 <bitemyapp> danke
13:26:47 <chrisdone> i haven't pushed my TH stuff yet, it's still only the Data-based gubbins on master
13:26:52 <bitemyapp> Understood.
13:27:33 <bitemyapp> chrisdone: since there's goto definition, what about the opposite direction? How hard would find occurrences be?
13:27:57 <chrisdone> bitemyapp: next on my todo for ghci-ng is find-uses
13:28:11 <stephenmac7> How would I use type variables for type synonyms?
13:28:20 <stephenmac7> type Clause a = [Literal a] doesn't seem to work
13:28:30 <bitemyapp> chrisdone: !!!
13:28:44 <bitemyapp> chrisdone: this already looks better than cider + clojure...that's going to be killer :)
13:29:03 <chrisdone> bitemyapp: it's not that hard, i planned an implementation for it while in the shower. should work for either local definitions or global ones
13:29:04 <L8D> ghci-ng sounds like angular
13:29:11 <chrisdone> bitemyapp: =)
13:29:25 <bergmark> stephenmac7: that should work... is Literal a data type and not a constructor?
13:29:37 <bitemyapp> chrisdone: that would make me so happy ;_;
13:29:46 <bitemyapp> chrisdone: I need goto definition and find occurrences for Hackage and Cabal really badly.
13:30:00 <stephenmac7> bergmark: Nevermind, I figured it out. There was another type synonym that used the previous type synonym that wasn't updated
13:30:03 <bitemyapp> and present...
13:30:07 <bitemyapp> so many wonderful things :D
13:30:28 <chrisdone> ^__^
13:30:57 <chrisdone> bitemyapp: fwiw if you're on haskell-mode there's a convenience hacky function that's basically "grep only .hs files within this project", if you're interested
13:31:18 <chrisdone> M-x haskell-who-calls
13:31:38 * bitemyapp nod
13:31:48 <chrisdone> oh, that's in my personal emacs. heheh
13:32:02 <chrisdone> https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el#L67..L88
13:32:12 <chrisdone> it's just a hack but i can't work without it
13:32:36 <chrisdone> tweak the cond if you don't have ag.el
13:33:03 <flyingfisch> does anyone here use vim with haskell and know how to modify a color scheme so that things like >>= are colored?
13:33:13 <mauke> chrisdone: I'd use 'ack --haskell' for that
13:33:42 <chrisdone> mauke: i used to use ack, but ag is faster
13:34:06 <HeladoDeBrownie> flyingfisch, more specific? I have that colored when the file I'm on is using Haskell syntax
13:34:20 <flyingfisch> some color schemes color it and others don't
13:34:24 <flyingfisch> not sure
13:34:28 <HeladoDeBrownie> Oh, you're right
13:34:29 <chrisdone> mauke: fwiw https://github.com/ggreer/the_silver_searcher#whats-so-great-about-ag
13:34:31 <flyingfisch> like Tommorow-Night colors it
13:34:52 <flyingfisch> but none of the base16- colorschemes do
13:35:13 <flyingfisch> and I really like the base16 family except for that one thing
13:35:27 <flyingfisch> so if I could just add a line or something it would be great
13:36:03 <HeladoDeBrownie> flyingfisch, I tried several colorschemes, including defaults, and all I tried colored it. Are you sure you have syntax on and ft=Haskell?
13:36:12 <mauke> chrisdone: pcre :-/
13:36:16 <HeladoDeBrownie> flyingfisch, also, are you using vim or gvim, because that also matters
13:36:34 <flyingfisch> gvim
13:36:54 <flyingfisch> do you have jellybeans (the colorscheme)
13:36:56 <chrisdone> mauke: *shrug* i only ever search identifier names with it
13:37:04 <HeladoDeBrownie> No, the one I use most is called obsidian
13:37:15 <chrisdone> obsidian is a cool name
13:37:30 <flyingfisch> do you have any base16 ones?
13:37:42 <HeladoDeBrownie> No, not sure what you mean by base16 ones
13:38:22 <flyingfisch> base16-3024, base16-atelierheath
13:38:25 <flyingfisch> etc
13:38:45 <HeladoDeBrownie> It could be that those particular colorschemes are missing Haskell support or something. I forget exactly how it works
13:39:31 <flyingfisch> HeladoDeBrownie: i think it has to do with something across the board because they also don't color = or => in PHP
13:39:38 <HeladoDeBrownie> Yeah, you're right
13:39:46 <HeladoDeBrownie> I'd suggest trying other colorschemes
13:40:48 <flyingfisch> HeladoDeBrownie: i did, seemed like the ones i liked all had problems... however, i just took a look at a screenie of obsidian and it looks nice. trying it out right now
13:44:35 <gfixler> I don't get why fix concludes when the value stops changing
13:45:52 <chrisdone> gfixler: there's usually a base case that decides not to use its self-referential argument
13:45:53 <ReinH> gfixler: Do you mean why the Haskell definition of fix has that behavior, or why it's true of fixed points in general?
13:45:54 <Hodapp> so if http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Expressions.html#t:Expr lists Word8 (for instance) as being an instance of Expr, and Word8 has no constructors...
13:46:04 <athan> Do seams between modules ever mess up typeclass instance matching?
13:46:20 <Hodapp> and if 'array' is "Expr a => Name -> [a] -> Atom (A a)"... then I'm really annoyed at the lack of any way to actually call 'array'
13:46:29 <gfixler> ReinH: that's what I'm not sure about - is it implementation, or a general thing?
13:46:48 <gfixler> chrisdone: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion <- looking at the fix const "hello" example
13:47:20 <chrisdone> use of the y combinator in lambda-calculus is similar
13:47:28 <chrisdone> if you prefer to consider a simpler language
13:48:14 <ReinH> gfixler: Well, in terms of fixed points in general, that's the definition of a fixed point: x is a fixed point of f if and only if f(x) = x
13:48:17 <gfixler> I don't think it's the language so much as the concept
13:48:28 <gfixler> ReinH: ah, that begins to explain it
13:48:28 <ReinH> So it's true because it's defined that way
13:49:13 <gfixler> I hadn't made the connections to fixed points, i.e. on a graph
13:50:15 <ReinH> Then there are the concepts of least and greatest fixed point, where you have a way of comparing the elements that the function ranges over. (Specifically, they form a poset). So x is a least fixed point of f iff f(x) = x and x <= y for all fixed points y
13:50:17 <ReinH> )
13:50:23 * hackagebot flamethrower 0.0.5.1 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.5.1 (charmander)
13:51:11 <ReinH> In Haskell, we use "definedness" as our comparison, so _|_ <= a for all values a.
13:51:34 <ReinH> (This notion of "definedness" is formalized by denotational semantics)
13:51:57 <ReinH> This is a good read on denotational semantics: for
13:52:02 <ReinH> woops
13:52:04 <chrisdone> newton's method of computing square roots is based on a fix point calculation
13:52:05 <ReinH> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
13:52:25 <gfixler> ReinH: been looking to understand what denotational semantics are - thanks
13:52:48 <gfixler> chrisdone: that actually makes some sense to me
13:53:20 <gfixler> Haskell is becoming my entry point to mathematics, which I've sorely lacked all my life
13:53:27 <ReinH> gfixler: The wikibooks page is a start. The link at the bottom to Schmidt will take you further down the rabbit hole.
13:53:47 <ReinH> gfixler: Also Richard Bird's new book covers denotational semantics a bit (but doesn't name it as such)
13:53:47 <gfixler> Haskell is all rabbit holes :)
13:54:42 <platz> more denotaional stuff: http://people.cis.ksu.edu/~schmidt/text/densem.html http://conal.net/talks/lambdajam-2014.pdf
13:54:52 <platz> but i'm not sure how people use it in industry
13:54:56 <ReinH> platz: that's the Schmidt I referenced ;)
13:54:59 <platz> ahh
13:55:12 * gfixler adds to pile
13:55:15 <ReinH> platz: denotational design uses one form of denotational semantics :) We just talked to Conal about that a bit...
13:55:20 <zq> what's the language pragma that lets me use kind sigs with type family decls
13:55:27 <zq> interrogation point
13:55:31 <ReinH> johnw has some experience with denotational design as well and seemed to be pretty impressed.
13:55:49 <ReinH> zq: heh
13:56:13 <platz> i haven't read all the resources yet, but the "meaning function" i.e. mu is hard to grokk sometimes
13:56:22 <ReinH> platz: I've used it in a gestural sense when designing systems and it's been helpful. I haven't given it the rigour it deserves though.
13:56:43 <gfixler> I have to get back to work, but thanks all for the info and links
13:57:10 <ReinH> denotational design helped me to realize that the command and control system I'm building is a FRP system, for example.
13:57:23 <conal> ReinH: :)
13:58:00 <conal> I think functional programmers use the style of denotational semantics all the time without noticing it: recursively defined functions over an algebraic data type.
13:58:04 <platz> ReinH: cool to hear it helped you.  Did your implementations look identical to the meanings?  I know it's probably they will look similar, but I don't think thats the point
13:59:08 <conal> ... where the range of said function is some math type (products, sums, functions, but not IO).
13:59:53 <carter> conal: amusingly when I tell people that style of definition is valid denotational semantics they sometime disagree
14:00:02 <carter> (which is them being wrong afaict)
14:00:34 <chrisdone> @let avg x y = (x + y) / 2
14:00:36 <lambdabot>  Defined.
14:00:37 <chrisdone> > fix (\iter guess x -> if abs ((guess*guess) - x) < 0.1 then guess else iter (avg guess (x / guess)) x) 1.0 9
14:00:39 <lambdabot>  3.00009155413138
14:00:53 <chrisdone> gfixler: ^ square root by successive averaging
14:00:59 <conal> carter: we could look at such an example sometime to find out.
14:01:15 <johnw> ReinH: yes, denotational design has influenced me pretty deeply now
14:02:10 <johnw> conal: hello!
14:02:19 <johnw> nice to see you on IRC
14:02:25 <conal> johnw: howdy! :)
14:03:03 <johnw> conal: I have been spreading the good word of denotational design to many an ear
14:03:21 <johnw> so far it has been one of the more compelling ways of intersecting mathematical and computational design
14:03:56 <conal> johnw: glad to hear. keep preaching the gospel, brother!
14:04:01 <johnw> most conversation start with, "Let's see what this looks like if we don't think about how we might implement it"
14:04:35 <t4nk468> Hey, can someone help me with this error. I just started learning Haskell and I dont know why I get this error: https://bpaste.net/show/35c4ea218cb2
14:04:36 <johnw> yes, very freeing.  you zoom out until it's all purity and thought, and then zoom in when you have an understanding of how the parts truly relate with the whole
14:04:39 <conal> johnw: indeed. start by getting clear on what the *question* is.
14:05:24 <johnw> conal: I really want your video from Lambda Jam to refer people to
14:05:36 <ericbutters> hello, i try to comile a c application that uses hs_init and hs_exit with gcc -o test main.c -L/usr/lib/ghc/ -lHSrts-ghc7.4.1 -I/usr/lib/ghc/include/ but i got linker errors: http://paste.ubuntu.com/9387859/
14:05:38 <johnw> the pacing in that one was very good, and much more in depth than the BayHac version
14:05:40 * gfixler wants to watch conal's video
14:05:41 <conal> johnw: me, too. i don't know what's holding it up.
14:08:08 <jmct> conal: do you have any recommended background reading for what you consider denotational design?
14:08:34 <conal> jmct: http://conal.net/papers/type-class-morphisms/
14:09:37 <princess_crazyca> Do you guys ever joke?
14:09:39 <conal> jmct: and http://conal.net/papers/push-pull-frp/ as a focused application of the technique.
14:09:45 <johnw> princess_crazyca: from time to time
14:09:55 <jmct> conal: Sweet, thanks!
14:10:31 <johnw> princess_crazyca: there is a lot of fun-spirited banter on #haskell-blah usually
14:10:31 <conal> jmct: You bet. Also, http://conal.net/blog/tag/denotational-design and http://conal.net/blog/tag/type-class-morphism . Enjoy!
14:10:41 <jmct> conal: I really appreciate that you push for thsi stuff. My supervisor is similar but he's less involved in the community these days
14:10:41 <johnw> in this channel, we like to dig into Haskell and its concepts mainly
14:11:15 <princess_crazyca> Johnw: ohhh :) I actually joined to group out of random...
14:11:34 <conal> jmct: thanks. :)
14:11:44 <princess_crazyca> What's haskell? A programming language?
14:11:49 <johnw> princess_crazyca: yes, exactly
14:12:14 <johnw> a general purpose, functional programming language with an emphasis on types as an expressive way of communicating intent in your source code
14:12:16 <princess_crazyca> How many programming languages do you guys know?
14:12:47 <fizz_ed> princess_crazyca: you first?
14:12:50 <butyoudonot> define 'know'
14:12:52 <Peaker> princess_crazyca: depends on how deep "know" means
14:13:05 <conal> i'm happy to see some interest in denotational thinking. i sometimes get discouraged by the high proportion of haskell usage as a power tool for imperative programming.
14:13:13 <johnw> most programming languages are not nearly as difficult to know as being effective at using the libraries they offer
14:13:37 <princess_crazyca> I know, markup langauge.. Html/css.. learning java and python... ( Self teaching myself)
14:13:47 <zq> "use of haskell as a power tool for imperative programming" <-- care to elaborate?
14:13:47 <johnw> conal: if I can ever help to spread the word, just let me know; I think you're onto something important, and it needs to be heard in more places
14:14:11 <conal> johnw: :)
14:14:17 <princess_crazyca> you guys?
14:14:27 <jmct> What's the 'famous' Runciman quote? "In the age of monadic enlightenment nobody writes lazy functional programs anymore."
14:14:29 <jmct> something like that
14:14:31 <hpc> in fairness, haskell is a really good power tool for imperative programming
14:15:12 <johnw> princess_crazyca: I use a few main programming languages regularly, and know quite a lot of smaller, special purpose languages (like bash, LaTeX, css, etc)
14:15:24 * hackagebot websockets 0.9.2.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.2.1 (JasperVanDerJeugt)
14:16:07 <johnw> Haskell really is my favorite imperative language; it has the clarity of C (the "principle of least surprise"), with the abstraction power of higher-level languages
14:16:11 <princess_crazyca> Johnw: Do you know lisp, That's like the hardest language to learn, if you do i'm proud of you
14:16:13 <conal> zq: i mean the IO type, which represents imperative computations and doesn't have a denotation. it inherits the fundamental semantic problems of imperative programming as discussed e.g. in john backus's turing award paper.
14:16:25 <ericbutters> anyone linked c against libHSrts-ghc7.4.1 ?
14:16:27 <johnw> princess_crazyca: yes, I know and use Lisp as one of my main languages
14:16:31 <fizz_ed> princess_crazyca: done real work in python, scala, erlang, javascript, haxe, scheme, and haskell. Played around with about a dozen more.
14:17:32 <princess_crazyca> I'm going to cry, cause I know so little near you guys. I envy you people.... :9 Is 17 late?
14:18:08 <johnw> princess_crazyca: I cry every day for the same reason; you'll never know enough, that you won't find a group of people who make you feel that way
14:18:35 <jmct> princess_crazyca: Don't be so hard on yourself, no one knows these things from birth. And 17 is most definitely not late.
14:18:57 <capisce> I'm not sure Lisp is the hardest language to learn
14:19:00 * josephle didn't learn his laundry list of languages until university
14:19:15 <capisce> I found it harder to wrap my head about many Haskell concepts
14:19:16 <fizz_ed> johnw: ++
14:19:19 <bitemyapp> princess_crazyca: just keep learning. There's always a bigger fish, let that encourage, not dismay, you.
14:19:20 <jmct> I didn't learn _any_ language until University
14:19:26 <bitemyapp> @karma+ johnw
14:19:26 <lambdabot> johnw's karma raised to 17.
14:19:28 <princess_crazyca> jmct: thanks but it probably take 10 years to know what you guys know
14:19:28 * johnw didn't start learning Haskell or mathematics until 40, so 17 feels like an eternity to learn and experiment
14:19:41 <Cale> princess_crazyca: 10 years goes by pretty quickly
14:19:45 <simpson> princess_crazyca: 17 is not too late. You can do it. Take things slow and move at your own pace.
14:19:47 <josephle> johnw++
14:19:53 <johnw> bitemyapp: :)
14:19:57 <geekosaur> I started learning Haskell at 42
14:20:23 <johnw> geekosaur: yay, my brother!
14:20:25 <princess_crazyca> Really? Omg, you guys are so encouraging :)
14:20:27 <Cale> I started learning Haskell back in 2001 or so
14:20:29 <geekosaur> also my university experience ended with undergrad
14:20:35 <hpc> princess_crazyca: the main thing to realize is that many of the people here have PhDs and teaching jobs
14:20:38 <mauke> princess_crazyca: I got my first computer when I was 18
14:20:55 <geekosaur> so, not like you need a math Ph.D to figure this stuff out
14:21:09 <bitemyapp> princess_crazyca: It took me 5 years to get anywhere with Haskell.
14:21:13 <fizz_ed> princess_crazyca: I learned C at 17, kind of hated it, I'm 33 now.  Programming isn't the hard part. Understanding the world (or some part of it) well enough to model it in terms of problems that computers can help you solve is way harder.
14:21:31 <bitemyapp> princess_crazyca: nobody I've helped learn Haskell has taken anywhere near that long. You're going to be okay.
14:21:41 <johnw> princess_crazyca: I tried to learn Haskell 3 separate times, and gave up the first two; so we are all human.  Just follow your interest and don't give up, and you'll get to wherever it is you want to go
14:22:11 <jmct> princess_crazyca: what johnw said! And ask lots of questions :)
14:22:13 <bitemyapp> princess_crazyca: I gave up learning Haskell several times as well.
14:22:31 <ReinH> johnw: I always forget how old you are...
14:22:39 <ReinH> :p
14:22:43 <johnw> ReinH: I try to keep a youthful perspective :)
14:23:05 <monochrom> people exaggerate how much academic and impregnable Haskell is, just because there were some PhD theses on Haskell.
14:23:09 <princess_crazyca> Thank- you guys for your lovely informative response, i feel better  knowing we are all human, :) thank you every one :)
14:23:46 <monochrom> they quickly forgot that the while-loop was also first pioneered by an obscure prof and there were PhD theses to follow it up
14:24:25 <monochrom> those who have learned from history are bound to helplessly watch other people repeat it.
14:24:44 <monochrom> the history of fearmongering
14:25:15 <bitemyapp> @karma+ monochrom
14:25:15 <lambdabot> monochrom's karma raised to 91.
14:26:31 <monochrom> more recently, OOP also first appeared in academic papers and PhD theses, and is still studied thusly.
14:27:39 <monochrom> goes a long way to show how (# of hypocritic programmers)/(# of programmers) = (# of hypocritic humans)/(# humans) > 0.99
14:28:21 <johnw> I wonder: is there anyone looking for a small toy project, who is also interested in delving into pipes?  If so, I have an idea for you
14:29:13 <shachaf> @remember monochrom those who have learned from history are bound to helplessly watch other people repeat it.
14:29:13 <lambdabot> It is forever etched in my memory.
14:29:41 <fizz_ed> johnw: drowning in projects already, otherwise,....
14:30:01 <ReinH> johnw: I almost certainly don't have time for it, but I'm interested in what the idea is.
14:30:30 <zq> johnw: gimme
14:30:40 <johnw> it's fairly basic: implement the Tk/Expect interface as a monad, then turn it into a library which takes an input pipe and an output pipe, and thus gives you an expect-like interface to interacting with a data stream
14:32:24 <johnw> this way you could do what expect does, and interact very easily with textual protocols over sockets, with command-line utilities over stdin/stdout pipes, etc.
14:37:33 <dnkndnts> are there any major haskell libs that have something like foldp from elm?
14:37:34 <ericbutters> anyone used haskell from c/c++? ;)
14:37:56 <platz> because the current limitation with expect is that is doesn't handle streams?
14:38:20 <johnw> well, expect uses Tcl at the moment
14:38:28 <johnw> i'd like something I can make use of inside any Haskell application
14:39:03 <johnw> so, rather than a binary which reads files in a Tcl-based DSL, I'd have access to a nice EDSL inside Haskell
14:39:21 <johnw> it could be especially nice for automated testing
14:40:03 <platz> makes sense.  It seems very close to something i can't put my finger on though... actually, why not just use pipes directly
14:40:29 <johnw> you'd end up writing the "expect blocks" by hand enough times that you'd want it abstracted, is my assumption :)
14:40:31 <monochrom> ericbutters: my http://www.vex.net/~trebla/haskell/so.xhtml may help you use Haskell for a *.so, then use it from C
14:40:39 <dfeuer> @src unzip
14:40:39 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
14:41:29 <platz> yeah there's something to this; pretty good idea
14:42:31 <johnw> another idea that ReinH and I had a few months ago was to give http://hackage.haskell.org/package/pcap a streaming interface, and then wrap a REPL interface around it to allow you to both examine and construct packets on the wire, in the way that scapy (http://www.secdev.org/projects/scapy/) does for Python, with nice formatting, coloring, and drilling-down capabilities
14:42:58 * dfeuer offers orange juice and English muffins to anyone who helps him with the Data.Sequence <*> arithmetic problem.
14:43:14 <lf94> What's a good IRC bot framework?
14:43:23 <lf94> SimpleIRC seems to be the most correct looking
14:43:53 <Clint> lf94: elysiabot isn't terrible
14:43:57 <jfischoff> johnw: that would be cool
14:44:47 <johnw> there's nothing quite like the experience of crafting an entire TCP conversation by hand, to learn what's happening behind the scenes :)
14:45:09 <Peaker> interactively? Without timing out? You're a fast typist! :)
14:45:27 <lf94> Clint: heh, it's by the same guy :)
14:45:28 <lf94> Thanks!
14:45:30 <johnw> Peaker: you end up scripting it to get the timing right
14:46:17 <monochrom> connect your brain to computer by USB, then you can skip typing.
14:46:34 <k00mi> lf94: I found simpleIRC to be really unreliable, it does barely any error handling
14:46:35 <monochrom> now you will ponder on crafting an entire USB conversation by brain...
14:46:48 <lf94> k00mi: what do you recommend
14:47:17 <Clint> mm_freak is going to fix fastirc any century now
14:47:27 <johnw> Peaker: here is the scapy version: https://github.com/jwiegley/notes/blob/master/tcpworkshop
14:47:53 <Peaker> johnw: short
14:48:06 <dfeuer> When's FORTRAN's hundredth birthday?
14:48:09 <torpet> Is there anything that's inherently terrible in that code: http://lpaste.net/6998664103778582528
14:48:36 <k00mi> lf94: I don't know, there is ircbot, which looks complex and yet not very flexible (I haven't used it though), and recently I found irc-conduit, which looks decent but I also haven't tested
14:48:56 <dfeuer> torpet, I don't speak that language, which makes things hard, but what are you taking the nub of?
14:49:25 <torpet> dfeuer: removes dupliates
14:49:30 <torpet> *duplicates
14:49:37 <dfeuer> torpet, I know what it does. I also know it's O(n^2).
14:49:43 <lf94> k00mi: yeah ircbot looks extremely complex
14:49:46 <Zemyla> Is it possible to use type families to have a function which does one thing for a -> a, and another thing for (Eq a) => a -> a?
14:49:57 <dfeuer> So if your list is long, or your equality test is expensive, nub is bady.
14:49:58 <dfeuer> bad.
14:50:10 <dfeuer> Zemyla, no.
14:50:13 <torpet> oh yeah i know, but the list has mostly 100 entries
14:50:27 <Zemyla> That sucks.
14:50:31 <k00mi> lf94: my gripe with irc-conduit is that I think you have to build basic irc functionality like responding to PINGs yourself
14:50:40 <torpet> are there better algos for removing duplicates? there shouldn't be right?
14:50:53 <johnw> torpet: yes, there are
14:51:00 <dfeuer> torpet, if you only have Eq, no. If you have (or can get) Ord or Hashable, then yes.
14:51:02 <johnw> but they have stricter requirements than nub
14:51:03 <torpet> what are the names of the algos?
14:51:21 <dfeuer> torpet, they're not in the Prelude.
14:51:26 <dfeuer> I don't know if they have names.
14:51:27 <johnw> torpet: example: https://github.com/jwiegley/notes/blob/master/FastNub.hs
14:51:31 <Zemyla> Why shouldn't it be possible? I mean, the type is determined at compile time, so it can tell whether it is an Eq and choose the proper function then, right?
14:51:37 <lf94> k00mi: ok well that sucks too
14:51:43 <lf94> ElysiaBot seems good enough
14:51:44 <torpet> johnw: thank you
14:52:12 <Peaker> Zemyla: it shouldn't be possible because of parametricity. `a -> a`  by definition doesn't know anything about "a", whether it's Eq or not
14:52:28 <torpet> i asked this yesterday already but no one replied: what os are most of you on? which linux distro has most up2date packages for haskell?
14:52:35 <johnw> OS X
14:52:38 <torpet> I am on Mac OS X at the moment, using ghcformacosx
14:52:42 <Clint> Debian
14:52:52 <johnw> I use Nixpkgs on OS X, which has very up2date packages for haskell
14:53:01 <Peaker> Zemyla: maybe you want something that's different for: Eq a => ..   vs.   !Eq a => ..  but !Eq is not a feature, so you can't even express that, and it's probably also a bad idea
14:53:10 <sebastianrkg> Is it possible to easily change a single field in a Record?
14:53:16 <johnw> sebastianrkg: yes
14:53:23 <johnw> sebastianrkg: recordvalue { field = newvalue }
14:53:23 <Peaker> sebastianrkg: foo { singleField = 5 }
14:53:28 <sebastianrkg> shit, really?
14:53:32 <sebastianrkg> so simple!
14:53:36 <sebastianrkg> thanks guys!
14:53:38 <johnw> it's called record update syntax :)
14:53:48 <Peaker> if you want to apply a function on it, for example, add 1, then it's more cumbersome. Then you can use one of the lens libraries to do it nicely
14:54:10 <torpet> johnw: Cool, any specific reason why you don't use Brew, MacPorts or Fink?
14:54:16 <sebastianrkg> I feel like Haskell has everything I could possibly want, it's just that all the info is not easily findable on Google
14:54:29 <johnw> torpet: lots of reasons, which I'd be happy to answer in #nixos
14:55:07 <Zemyla> Basically, I was wanting a function possiblyRemoveDuplicates, which removes duplicates from a list [a] if and only if a is an instance of Eq. And it shouldn't be any harder than having type polymorphism on Int vs Float.
14:56:15 <Peaker> Zemyla: as in: bestEffortRemoveDuplicates?   As an optimization?
14:56:27 <Peaker> Zemyla: you could have a new class for that
14:56:41 <Zemyla> Yeah, that's what I'm looking for.
14:57:21 <stephenmac7> I have this code here: http://lpaste.net/115767#line24 I would like to check whether the 'a' value is already in the map
14:57:33 <stephenmac7> If so, I don't want to insert a new one
14:57:58 <fread2282> is there any I can tell ghc to not inline external functions?
14:58:03 <Peaker> Zemyla: it's not that you care whether there's Eq. You care whether there's a cheap-enough Eq you could do for optimization purposes, which is a different class from Eq anyway
14:58:38 <stephenmac7> So, how would I check whether a value is a member of a map?
14:59:14 <Welkin> eh?
14:59:18 <Welkin> you mean a Map?
14:59:32 <Welkin> there should be an elem function for Map
14:59:53 <glguy> There's always: M.member for keys and Data.Foldable.elem for values
15:00:36 <Welkin> or you can just lookup in the Map
15:00:47 <stephenmac7> Data.Foldable.elem?
15:00:59 <L8D> is there a template Haskell thing or a reflection thing I can use for generating ToJSON instances for a user-defined Record?
15:01:07 <Zemyla> Peaker: Actually, I do care whether or not there's an Eq in general.
15:01:09 <Peaker> given that Foldable.elem is implemented as a function, and not a method -- will it perform well on something like a Set?
15:01:14 <Eduard_Munteanu> There are left-biased unions for them, so that's pretty much the same as checking yourself.
15:01:18 <Peaker> Zemyla: why?
15:01:30 <jfischoff> How can I include the line number and source file with exceptions?
15:01:32 <jfischoff> easily
15:01:55 <stephenmac7> > elem 5 (Data.Map.fromList [(5, 6)])
15:01:57 <lambdabot>  Not in scope: ‘Data.Map.fromList’
15:02:10 <Eduard_Munteanu> jfischoff, monad-logger has something like that, IIRC
15:02:13 <mauke> :t M.fromList
15:02:14 <lambdabot> Ord k => [(k, a)] -> M.Map k a
15:02:21 <Zemyla> Well, if such a thing were possible, I could implement a probabilyt monad and automatically fold together probability instances that have the same value.
15:02:22 <stephenmac7> > elem 5 (MfromList [(5, 6)])
15:02:24 <lambdabot>  Not in scope: data constructor ‘MfromList’
15:02:25 <mauke> jfischoff: template haskell?
15:02:26 <stephenmac7> > elem 5 (M.fromList [(5, 6)])
15:02:28 <lambdabot>  Couldn't match expected type ‘[a0]’
15:02:28 <lambdabot>              with actual type ‘Data.Map.Base.Map k0 a1’
15:02:49 <jfischoff> mauke: yeah, is there something on hackage to do that?
15:02:54 <stephenmac7> > Data.Foldable.elem 5 (M.fromList [(5, 6)])
15:02:55 <Peaker> I think instead of M.fromList, Data.Map should have had (==>) = singleton, and then you'd build a map like: mconcat [1 ==> "Hello", 2 ==> "Good bye"]
15:02:56 <lambdabot>  Not in scope: ‘Data.Foldable.elem’
15:02:56 <lambdabot>  Perhaps you meant ‘Data.Foldable.fold’ (imported from Data.Foldable)
15:03:03 <lf94> How do I even compile Elysiabot
15:03:27 <Peaker> Zemyla: Comparing them for the same value might be more expensive than the saving
15:03:41 <Eduard_Munteanu> :t F.elem
15:03:42 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
15:03:57 <stephenmac7> > F.elem 5 (M.fromList [(5, 6)])
15:03:58 <lambdabot>  False
15:04:04 <stephenmac7> > F.elem 5 (M.fromList [(9, 5)])
15:04:05 <lambdabot>  True
15:04:09 <stephenmac7> Eduard_Munteanu: Thank you
15:04:22 <Peaker> Zemyla: if you rely on Eq for correctness, then it's not possible that you allow for lack of Eq to be OK. If you don't rely on it for correctness, it means you want something that's "best effort" and that's not what Eq is about
15:05:02 <Zemyla> Does it matter why I'm asking for it? All I want to know is, is it possible?
15:05:04 <Peaker> Zemyla: You want BestEffortEq, not Eq
15:05:16 <Eduard_Munteanu> Zemyla, likely with OverlappingInstances
15:05:26 <jfischoff> lock-th looks pretty good https://hackage.haskell.org/package/loch-th-0.2.1/docs/Debug-Trace-LocationTH.html
15:05:26 <Peaker> Zemyla: it's not possible directly, but approximations are possible (via: New classes, [closed] type families, etc)
15:05:42 <NikolajK> Challenge time, for those interested. Part 1. Consider {-1, 1}, {-2, 0, 2}, {-4, 0, 4}, {-16, -8, 0, 8, 16}. What's the pattern?
15:06:16 <NikolajK> its, for the first four n in N, the possible results of Det(A), where A is an n times n matrix with entries either +1 or -1.
15:06:26 <NikolajK> code and compute :)
15:07:40 <Zemyla> Eduard_Munteanu: Thank you. OverlappingInstances is exactly what I was looking for.
15:07:42 <glguy> Peaker: elem is written (eventually) in terms of foldMap, which takes advantage of the tree structure of Set, so it should be fine
15:08:02 <lf94> How do I find these: Could not find module `Text.JSON.Types'
15:08:04 <glguy> actually
15:08:10 <lf94> I do cabal list text.json.types and nothing appears
15:08:11 <Peaker> glguy: doesn't foldMap just go over them in arbitrary order?
15:08:12 <glguy> it probably doesn't get to use the fact that the set is ordere
15:08:25 <glguy> Peaker: it would go smallest to largest
15:08:37 <Peaker> glguy: elem should probably be inside the class - or Set could export a REWRITE rule
15:08:42 <Peaker> for elem on Set
15:08:50 <chrisdone> lf94: that's from the `json' package
15:08:54 <chrisdone> @package json
15:08:54 <lambdabot> http://hackage.haskell.org/package/json
15:09:06 <Eduard_Munteanu> @hoogle Text.JSON.Types
15:09:08 <glguy> Peaker: The original question was for Map
15:09:08 <lambdabot> package typesafe-endian
15:09:08 <lambdabot> package typescript-docs
15:09:08 <lambdabot> package asn1-types
15:09:24 <glguy> Peaker: in that case there's no structure to leverage (which is the question I was answering)
15:09:53 <Peaker> glguy: Yeah, I understand
15:10:02 <Peaker> glguy: I was wondering about the implication of having Foldable.elem in general
15:10:46 <glguy> Peaker: I think that that change to foldable has already occured
15:10:56 <glguy> see https://github.com/haskell/containers/blob/master/Data/Set/Base.hs
15:11:59 <stephenmac7> Hm. Seems I also need the key
15:12:07 <Peaker> glguy: ah cool
15:13:16 <stephenmac7> So, something like v -> Map k v -> k
15:13:20 <stephenmac7> :t M.lookup
15:13:21 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
15:13:33 <stephenmac7> Actually v -> Map k v -> Maybe v
15:13:47 <stephenmac7> Actually v -> Map k v -> Maybe k :P
15:14:16 <Peaker> stephenmac7: so you want to do a reverse-lookup on your map?
15:14:22 <stephenmac7> Peaker: Yes
15:14:31 <Peaker> stephenmac7: then you need a bidirectional Map, not a Map
15:14:42 <Peaker> or just manually hold maintain Maps
15:14:45 <Peaker> maintain 2 Maps that is
15:15:25 <stephenmac7> Peaker: So, that bimap package?
15:15:47 <Welkin> reverse lookup?
15:15:55 <Welkin> why not just use a database at that point?
15:16:30 <stephenmac7> All I'm trying to do is use https://hackage.haskell.org/package/incremental-sat-solver with any data type as a variable
15:16:31 <Peaker> stephenmac7: apparently, perhaps you want one that's ManyToOne
15:16:45 <stephenmac7> Instead of just an int
15:16:50 <stephenmac7> *Int
15:16:50 <Peaker> Welkin: as soon as you need more than a Map you go to a database? :)
15:17:22 <Welkin> once you reach a certain point of complexity, use a different tool
15:17:34 <Welkin> or rework your design
15:18:10 <stephenmac7> All I'm doing is storing a mapping of incrementing ints to values so that when I run the solver, I can map back to the values
15:18:12 <johnw> Peaker: edwardk's "tables" package allows for some very powerful lookups without needing a full-on database
15:19:07 <lpaste> chrisdone pasted “Presentations” at http://lpaste.net/115771
15:19:12 <stephenmac7> So, it might be easier to just write an SAT solver instead of trying to extend this one
15:19:56 <stephenmac7> No suggestions?
15:19:56 <chrisdone> ^ WIP presentations based on template-haskell instead of Data.Data =3
15:19:58 <Peaker> johnw: to me going full-on database sounds like a heavy move - I would much prefer not to persist in an external database if a simple in-RAM structure can work
15:20:26 <stephenmac7> Bidirectional map is will have to be, then.
15:20:29 <stephenmac7> *it
15:20:47 <johnw> Peaker: then you might really like http://hackage.haskell.org/package/tables, it has a lot of flexbility
15:21:06 <johnw> and it uses lens as a rather elegant interface
15:21:08 <Peaker> stephenmac7: if you don't mind an O(N) elem lookup on the map, you can get the keys, just toList the map and then find the tuple you want
15:21:31 <Peaker> johnw: cool. I love edwardk's lens-based interfaces
15:21:50 <Peaker> (I love how the "at" and "contains" lenses can replace more than a dozen APIs, each)
15:22:10 <johnw> yes, lens makes even Data.Map much nicer to use
15:23:59 <flyingfisch> is there something like unwords but instead of adding spaces between list entries it adds an arbitrary character?
15:24:18 <johnw> intersperse?
15:24:23 <zq> flyingfisch: intercalate
15:24:32 <johnw> > intercalate ' ' ["Foo"]
15:24:33 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
15:24:33 <lambdabot>              with actual type ‘GHC.Types.Char’
15:24:39 <johnw> > intersperse ' ' ["Foo"]
15:24:39 <Peaker> > intercalate ", " ["Foo", "bar", "Baz"]
15:24:40 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
15:24:40 <lambdabot>              with actual type ‘[GHC.Types.Char]’
15:24:40 <lambdabot>  can't find file: L.hs
15:24:42 <chrisdone> off with his head!
15:24:45 <zq> :t intercalate
15:24:46 <lambdabot> [a] -> [[a]] -> [a]
15:24:50 <zq> :t intersperse
15:24:51 <lambdabot> a -> [a] -> [a]
15:24:57 <zq> yeh it's intercalate you want :p
15:24:58 <Peaker> > intercalate ", " ["Foo", "bar", "Baz"]
15:24:58 <johnw> > intersperse ' '' "Foo"
15:24:59 <lambdabot>  "Foo, bar, Baz"
15:24:59 <lambdabot>  can't find file: L.hs
15:25:06 <johnw> > intersperse ' ' "Foo"
15:25:07 <flyingfisch> @hoogle intersperse
15:25:07 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:25:07 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
15:25:07 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
15:25:07 <lambdabot>  "F o o"
15:25:18 <chrisdone> the fail is strong at this moment
15:25:24 <flyingfisch> @hoogle intercalcate
15:25:24 <lambdabot> No results found
15:25:26 * chrisdone checks the midichlorian count
15:25:30 <Peaker> lambdabot is a bit broken
15:25:38 <flyingfisch> @hoogle intercalate
15:25:38 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:25:38 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
15:25:38 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
15:25:43 <chrisdone> it's just mueval
15:25:53 <chrisdone> it doesn't play well in parallel
15:26:21 <flyingfisch> yeah i need intercalate
15:26:42 <chrisdone> mueval 1: create file, use file
15:26:42 <chrisdone> mueval 2: create file,
15:26:43 <chrisdone> mueval 1: finish using file, delete file
15:26:43 <chrisdone> mueval 2: hey where's my file guise
15:30:42 <obb> is it possible to declare helper functions as private in haskell?
15:30:53 <simpson> obb: It's possible to avoid exporting them from your module.
15:31:16 <obb> similar to the static keyword in c?
15:31:39 <Peaker> obb: you can put them in a "where" clause local to where you use them
15:31:51 <Peaker> obb: and what simpson said is the direct equivalent to "static"
15:32:17 <simpson> Where you explicitly declare the exports you *do* want to expose in your module declaration, and then have everything else be implicitly unexported.
15:32:19 <obb> thanks for the hint
15:33:17 <obb> i'll look into it when i write my first module
15:34:54 <pecanpy> why is: map . map :: (a -> b) -> [[a]] -> [[b]] ? Since both maps need 2 inputs, why isnt it now a function of 3 inputs?
15:35:20 <hiptobecubic> @type map
15:35:21 <lambdabot> (a -> b) -> [a] -> [b]
15:35:32 <hiptobecubic> Because of that and beacuse of (.)
15:35:35 <hiptobecubic> @type (.)
15:35:36 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:35:37 <shachaf> Do you believe map (map f) xss?
15:35:53 <shachaf> map a function that maps a function
15:36:02 <shachaf> The same thing is going on here.
15:36:20 <mauke> (.) doesn't add inputs
15:36:33 <shachaf> (map . map) f = map (map f) by the definition of (.)
15:37:14 <shachaf> Also what mauke said. :-)
15:39:13 <pecanpy> thanks! im just taking a minute to think this through
15:43:45 <Welkin> > (fmap . fmap) (+4) [[1,2,3],[4,5,6]]
15:43:46 <lambdabot>  [[5,6,7],[8,9,10]]
15:44:13 <pecanpy> oh man. still not getting it. i thought (.) only worked for functions of one input. since map takes 2, map . map makes as much sense to me as add . add
15:44:33 <Welkin> all of the functions take one input, technically
15:44:40 <pecanpy> bc of currying. yea
15:45:33 <mauke> the only problem with add . add is that (add . add) x == add (add x) and add x is a function but add doesn't accept a function
15:45:50 <mauke> map x is also a function but that's fine because map accepts a function
15:46:11 <glguy> pecanpy: Currying a different, all functions take one input because functions that appear to take two inputs are actually functions that take one input and return a function (that takes one input and returns something else)
15:46:30 <glguy> map :: (a -> b) -> ([a] -> [b])
15:47:34 <pecanpy> glguy: how is that different from currying. wiki - "currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument"
15:47:54 <glguy> a curried map would be:    map  (a -> b, [a]) -> [b]
15:48:03 <glguy> where it actually only takes a single tuple argument
15:48:16 <jeltsch> glguy: This would be an uncurried map.
15:48:29 <jeltsch> Haskell’s map is the curried one.
15:48:46 <glguy> OK, sure, but the point is that its one thing to write it in terms of a single argument
15:49:03 <glguy> and that's different than the fact that all functions in haskell take exactly one argument
15:49:10 <jeltsch> pecanpy: I would not describe currying in terms of evaluation. Currying is just a technique of representing a multiple-argument function as a single-argument one.
15:49:29 <jeltsch> glguy: True.
15:50:14 <Welkin> pecanpy: the term you are looking for is partial application
15:50:30 <jeltsch> pecanpy: The curried version of a two-argument function f is the function that when applied to an argument x yields another function that when applied to an argument y yields f (x, y).
15:51:18 <jeltsch> Applying the curried version of f to one argument is like partially applying the original function f to only this one argument and leaving the other one open.
15:51:35 <jeltsch> add 1 = succ
15:51:39 <jeltsch> add 0 = const
15:51:47 <jeltsch> add 2 = succ . succ
15:52:22 <pecanpy> earlier Welkin said "all functions take one input technically" and I responded, ~"yea they are curried
15:52:29 <pecanpy> from haskell wiki: "In Haskell, all functions are considered curried"
15:52:42 <jeltsch> This is a strange statement.
15:53:12 <jeltsch> You can define an add of type Int -> Int -> Int and another one of type (Int,Int) -> Int.
15:53:25 <jeltsch> The first uses currying, the second doesn’t.
15:53:26 <pecanpy> https://www.haskell.org/haskellwiki/Currying
15:53:30 <Xeironis> :t uncurry (+)
15:53:31 <lambdabot> Num c => (c, c) -> c
15:54:40 <jeltsch> pecanpy: There is just the convention to use currying when using Haskell. And there is one place in the language as such where currying is chosen instead of non-currying: data constructors with multiple arguments are curried functions.
15:54:59 <jeltsch> data T = C int Bool
15:55:08 <jeltsch> ⇒ C :: Int -> Bool -> T
15:55:22 <jeltsch> not (Int,Bool) -> T
15:55:24 <Peaker> jeltsch: there's also all the sugar around currying
15:55:39 <Peaker> foo x y = \z w -> ...
15:55:48 <jeltsch> Peaker: Yes.
15:55:54 <Peaker> also the left-associativity of application: foo bar baz bam
15:56:07 <Peaker> currying does have a special place in Haskell
15:56:12 <zq> :info (.)
15:56:18 <zq> :i (.)
15:56:23 <jeltsch> Well, the associativity of function application just supports currying. It doesn’t enforce it.
15:56:27 <zq> @info (.)
15:56:28 <lambdabot> (.)
15:57:01 <glguy> I think that the confusion is between thinking of currying as meaning "functions that return functions" and it meaning "a transformation on functions with a tuple argument to a function of functions"
15:57:25 <jeltsch> Yes, I think “currying” refers to the latter.
15:57:42 <Peaker> jeltsch: I agree the associativity is a weak argument, but the sugars are strong arguments
15:58:18 <jeltsch> Yes, currying is somehow specially supported by Haskell.
15:58:27 <jeltsch> I am very glad that the Haskell designers chose to do so.
15:58:42 <jeltsch> The situation in F#, for example, is annoying.d
15:58:55 <jeltsch> You do not have curried data constructors there
15:58:58 <jeltsch> .
16:00:49 <pecanpy> it took long enough, but i get the map . map thing. thanks everyone
16:01:16 <jeltsch> pecanpy: Another way to look at map is to look at it as a lifting of functions to functions on lists.
16:01:30 <jeltsch> map :: (a -> b) -> ([a] -> [b])
16:01:43 <jeltsch> written with explicit parentheses at the end
16:01:46 <Welkin> why not just explain fmap?
16:01:49 <Welkin> @src fmap
16:01:49 <lambdabot> Source not found. Where did you learn to type?
16:02:15 <jeltsch> pecanpy: One map turns a function of type a -> b into one of type [a] -> [b].
16:02:45 <jeltsch> A second map then takes the function of type [a] -> [b] to one of type [[a]] -> [[b]].
16:02:50 <jeltsch> @type map . map
16:02:50 <pecanpy> the next, [a] -> [b]  into [[a]] -> [[b]]
16:02:51 <lambdabot> (a -> b) -> [[a]] -> [[b]]
16:02:51 <pecanpy> yea
16:03:34 <Welkin> map _ []     = []
16:03:35 <Welkin> map f (x:xs) = f x : map f xs
16:04:11 <pharpend> What's the minimal way of achieving a function of the type :: Monad f => (b -> c) -> (a -> f b) -> f a -> f c
16:05:16 <jeltsch> @type \ f g -> liftM f . (>>= g)
16:05:18 <lambdabot> Monad m => (a1 -> r) -> (a -> m a1) -> m a -> m r
16:05:19 <exio4> \g f → fmap g . (>>= f)?
16:05:47 <zenguine> @pl \g f -> fmap g . (>>= f)
16:05:47 <lambdabot> (. (=<<)) . (.) . fmap
16:05:53 <zenguine> ha
16:06:04 <zenguine> gotta love (.) sections
16:06:35 <pharpend> :t liftA
16:06:36 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:06:42 <pharpend> that's just fmap
16:06:45 <pharpend> :t liftM
16:06:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:06:56 <pharpend> well that's also fmap
16:06:59 <zenguine> yep.
16:07:00 <jeltsch> Yes.
16:07:13 <jeltsch> The problem is that for now, Functor is not a superclass of Monad.
16:07:31 <jeltsch> So if you only have a Monad constraint, you have to use liftM instead of fmap.
16:07:45 <pharpend> @source Monad
16:07:45 <lambdabot> Unknown command, try @list
16:07:48 <jeltsch> In the future, Functor will be a Monad superclass.
16:07:48 <pharpend> @src Monad
16:07:49 <lambdabot> class  Monad m  where
16:07:49 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
16:07:49 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
16:07:49 <lambdabot>     return :: a -> m a
16:07:49 <lambdabot>     fail   :: String -> m a
16:07:52 <exio4> @source liftM
16:07:52 <lambdabot> Unknown command, try @list
16:07:57 <exio4> @src liftM
16:07:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:07:59 <pharpend> huh, I thought functor was a superclass
16:08:15 <pharpend> :t (<=<)
16:08:15 <exio4> it will be
16:08:16 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:08:20 <jeltsch> pharpend: It should be, as every Monad is a Functor (since liftM is a proper fmap).
16:08:49 <zenguine> :t ((fmap .) .)
16:08:50 <lambdabot> Functor f => (a -> a1 -> a2 -> b) -> a -> a1 -> f a2 -> f b
16:09:32 <Xeironis> Shouldn't Applicative be the superclass?
16:09:46 <exio4> functor => applicative => monad
16:09:50 <jeltsch> Xeironis: Yes, Applicative will be the direct superclass.
16:09:50 <Peaker> Hey, I'm trying to use ugly-memo package to do memoization on inputs that come from IO actions
16:09:52 <Peaker> http://lpaste.net/115774
16:09:54 <Xeironis> okay
16:10:05 <Peaker> Unfortunately, it seems that GHC foregoes my memo :(
16:10:10 <Peaker> and recomputes every time
16:10:30 * hackagebot estimator 1.0.0 - State-space estimation algorithms such as Kalman Filters  http://hackage.haskell.org/package/estimator-1.0.0 (JameySharp)
16:10:34 <Peaker> "Hello" is printed more than once :( why?
16:11:23 <johnw> maybe you want http://hackage.haskell.org/package/io-memoize?
16:11:24 <jeltsch> :'(
16:12:02 <Peaker> johnw: I'm memoizing only pure computations, though, it's just that those pure computations depend on IO actions
16:12:05 <pharpend> Is there a non-infix version of (>>=)
16:12:15 <Peaker> (or rather, their input comes frmo IO actions at runtime)
16:12:27 <jeltsch> pharpend: AFAIK, no.
16:13:00 <jeltsch> pharpend: Well, (>>=) is prefix. Only >>= is infix. :-)
16:13:11 <Peaker> johnw: Basically, I have a "load & infer types" function, that does an IO-based "load" of the types of free variables. And then it does a completely pure "infer" step that is expensive, based on the loaded types
16:13:30 <Peaker> johnw: so I want to have a "loadMemoInfer" that memoizes the pure inference via standard pure-function-memoization
16:15:37 <johnw> ah, hmm
16:16:36 <Peaker> http://lpaste.net/115774#a115777
16:16:54 <Peaker> The "succeeds" case shows it is entirely possible to have the function declare the "memo" inside it, even nested in lambdas, and it memoizes correctly
16:20:42 <Peaker> memo $ \x -> memo $ \y -> ... <-- works fine
16:21:24 <Peaker> memo $ \x -> let  m = memo $ \y -> ..  in  ioAction >>= m   <-- "m" is somehow recomputed each time, despite the body of the \x lambda being computed just once!
16:21:45 <Peaker> what is GHC doing there?
16:29:25 <lf94> Module `System.IO.Error' does not export `try' (or catch), what the heck?
16:29:41 <lf94> Is my ghc version too old?
16:30:44 <michaelt> lf94: the usual try and catch are in Control.Exception
16:31:29 <lf94> michaelt: ah, ok
16:31:44 <lf94> I'm trying to compile ElysiaBot and it's not as straight forward as it should be...
16:32:31 <michaelt> lf94: right, some old code need repair. I had it mentally automated a year or so ago but can't remember the typical expedients...
16:32:47 <michaelt> some old code needed repair at the time, I meant
16:33:05 <lf94> Oh yeah...this is a year old...
16:33:07 <lf94> still!
16:33:38 <michaelt> It's not going to be as bad as the next ghc. ...
16:33:52 <michaelt> mconcat, exported by the Prelude, etc
16:33:54 <zq> let { f :: Either a b -> (); f _ = return (); }  -- i just proved the excluded middle
16:34:02 <lf94> isEOFError, is that in Control.Exception?
16:34:25 <lf94> is there a quick way to check these things?
16:34:38 <lf94> I am not good in ghci...
16:34:54 <michaelt> https://www.fpcomplete.com/hoogle?q=isEOFError&env=ghc-7.8-stable-14.09
16:34:59 <zq> blah
16:35:07 <zq> without "return"
16:35:42 <flyingfisch> getLine gets input until an EOF or ^D right?
16:35:56 <flyingfisch> how can I do it only until <enter>
16:37:10 <pharpend> Is there a way to do package signing
16:37:15 <pharpend> on hackage?
16:37:45 <pharpend> Because not doing package signing seems like a bit of a security risk
16:37:54 <Peaker> A top-level definition is called a "CAF" right?
16:38:09 <zq> flyingfisch: getLine returns on eol
16:38:13 <zq> already
16:38:29 <flyingfisch> but how can I quit the do block as soon as I get that
16:38:36 <flyingfisch> that eol
16:38:51 <lf94>  No instance for (mtl-2.1.2:Control.Monad.Error.Class.MonadError
16:38:58 <lf94> Ok this is flipping frustrating
16:39:26 <lf94> I am too stupid to update haskell code
16:39:43 <exio4> flyingfisch, there is no answer to that, the "proper" way could be stop recursing, or something like that
16:39:50 <flyingfisch> ok
16:40:32 * hackagebot puffytools 0.0.0.1 - A CLI assistant  http://hackage.haskell.org/package/puffytools-0.0.0.1 (pharpend)
16:41:57 <lf94> ;_;
16:42:03 <lf94> Could not find module `Control.Monad.Error.Class.MonadError'
16:42:08 <lf94> Isn't this standard?
16:45:00 <lf94> ok guys, what's an irc bot framework that works with latest ghc
16:45:09 <lf94> because this is madness and my brain cant handle it
16:45:29 <Hijiri> lambdabot?
16:45:35 <lf94> know what I'll pay someone to make this compile
16:45:50 <lf94> https://github.com/dom96/ElysiaBot
16:45:53 <lf94> please
16:46:07 <Hijiri> well I mean, lambdabot is a bot that compiles
16:46:16 <Hijiri> you can add plugins, not sure if that counts as a framework
16:46:29 <lf94> I thought it had a bunch of cruft
16:46:40 <lf94> (for running other things)
16:46:40 <Hijiri> I haven't looked at the code much
16:46:44 <lf94> I guess those are the plugins though
16:46:47 <lf94> I'll give it a shot!
16:47:00 <Hijiri> you can decide not to use some plugins
16:47:10 <lf94> yeah exactly :)
16:51:25 <lf94> Ok lambdabot looks a little complex but I think I can handle it
16:59:44 <Peaker> Ok, I finally understand my problem, whew:
17:00:05 <Peaker> foo = memo $ \x -> ...    works as expected iff foo is not typeclass-constrained
17:00:21 <Peaker> Got bitten by the bug the DMR is supposed to prevent - and I get bitten by the DMR all the time! Worst of both worlds
17:01:51 <Peaker> so to memoize a class-polymorphic function, I must first instantiate it to a monomorphic type.
17:02:08 <Peaker> IOW: It's not possible to purely memoize class-polymorphic functions.. interesting!
17:03:45 <alrunner4> you can't memo something that hasn't been computed, right?
17:04:06 <Peaker> what do you mean? you memoize like:  memo $ \x -> ... x ...
17:05:12 <alrunner4> but the actual value that's memoized (in memory) doesn't exist until it's concretely typed and computed
17:06:18 <Peaker> oh, of course the memoization will eventually happen on a mono-type
17:06:32 <Peaker> the question is whether you can put the call to "memo" in a place where the mono type is not yet known
17:11:02 <Peaker> does -O0 ignore INLINE pragmas?
17:12:42 <shachaf> I know GHC ignores {-# UNPACK #-} with -O0, even when it's explicitly specified.
17:13:00 <shachaf> Not sure about INLINE.
17:34:11 <Irbur> Good Day (or evening). I'm working on a Haskell project, and I made some functions which, i think, may already exist on other libraries.
17:34:13 <Irbur> i.e. a function that given an element and a list returns in which position the element is.
17:34:45 <Irbur> Does anyone know a fuction that does that?
17:35:06 <keko-2> Irbur: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#g:13
17:35:50 <schell> Irbur: you can use hoogle or hayoo to search by type signature
17:35:53 <keko-2> or wait, should have linked to this http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#g:16
17:36:11 <Irbur> i searched, couldn't find anything.
17:36:30 <keko-2> "The elemIndex function returns the index of the first element in the given list which is equal (by ==) to the query element, or Nothing if there is no such element."
17:36:55 <fizz_ed> there's also findIndex, which is like elemIndex except that == can be any predicate
17:37:04 <schell> http://duckduckgo.com/?q=!hoogle+a+-%3E+%5Ba%5D+-%3E+Maybe+Int
17:37:44 <schell> duckduckgo.com is my favorite search engine - esp. for haskell, you can search !hoogle {type signature}
17:37:54 <Irbur> Thank you!
17:38:05 <fizz_ed> schell: waoh! I've been using ddg since its infancy and I didn't know that!
17:38:12 <schell> but it’s also good for programming in general
17:38:15 <schell> yeah!
17:38:35 <schell> you can also do !mdn for mozilla dev network (javascript/html/css) search
17:38:36 <Peaker> OK, so you *can* write your memo in a class-polymorphic context, as long as you instantiate it to a monomorphic type before repeated use
17:38:43 <fizz_ed> I do rather like its "bang" redirection
17:38:54 <Irbur> Guess i'll start using duckduckgo more often!
17:38:59 <Peaker> (rather than instantiating it at every repetition)
17:39:08 <fizz_ed> I mostly use !w, a!, and !wa (which doesn't seem to work anymore...)
17:39:09 <rgrinberg> is MissingH recommended to use? It has some useful thing I need but i have my doubts...
17:39:18 <schell> i set it to my default in chrome, so i can search through the address bar
17:39:41 <schell> fizz_ed: i’ve never used those, what are they?
17:39:45 <fizz_ed> aye, I use FF for my main browser but me too.
17:40:04 <schell> ah - wikipedia
17:40:05 <fizz_ed> schell: amazon, wikipedia, and wolframalpha respectively
17:40:22 <Clint> rgrinberg: many things in there can be found elsewhere
17:40:32 <fizz_ed> so cool... !
17:41:39 <michaelt> lf94: did you solve ElysiaBot?  It seems to use missing-h which is reason enough not to revive it I feel ...
17:41:55 <lf94> michaelt: nope!
17:42:03 <lf94> Going to attempt to use lambdabot
17:42:25 <lf94> Someone should attempt to create a nice clean irc bot framework :D
17:42:36 <lf94> Because I'm too inexperienced to :(
17:43:01 <fizz_ed> lf94: clean is hard in a messy world
17:43:05 <Irbur> I also need a function that works like the delete function from Data.List, but will delete strings inside the string.
17:43:07 <Irbur> i.e. deleteString "in" "inflammable"
17:43:09 <Irbur> flammable
17:43:13 <lf94> fizz_ed: it is beautiful when it is done though
17:43:23 <lf94> fizz_ed: that is why I love haskell
17:43:58 <fizz_ed> lf94: I'm just starting out, and I don't have a sense for how the language picks up momentum yet.
17:44:11 <Peaker> hmm. if I have f x = g x ;  g = memo $ \x -> ...     then even if I fully instantiate "f", "g" will still be repeatedly instantiated, arrg
17:44:13 <fizz_ed> lf94: ordinarily I can tell when I'm about to hit a stride and power trough
17:44:26 <simpson> lf94: It sounds like you want a Nice Thing.
17:44:26 <lf94> what do you mean by that
17:44:33 <fizz_ed> lf94: but with haskell... it comes and goes.
17:44:33 <lf94> simpson: YES
17:44:53 <fizz_ed> through*
17:45:16 <lf94> you have to believe in yourself, and believe in haskell
17:45:23 <fizz_ed> lf94: I guess what I mean is that haskell resists brutality
17:45:35 <fizz_ed> lf94: I can't just hammer through. I have to pause and think at each step.
17:45:40 <lf94> ...resists? I'm sure haskell has a ton of brutality.
17:45:51 <lf94> yes because you are not used to the paradigm
17:46:02 <lf94> that's how it is for most people
17:46:05 <lf94> that's how it is for me :)
17:46:25 <fizz_ed> lf94: its true. the only statically typed language I have much experience with is Haxe.
17:46:41 <lf94> you sound like a hobbyist
17:46:42 <fizz_ed> er.. and c, but its type system is so impoverished that I don't really count it.
17:46:53 <simpson> lf94: Well, we can't have Nice Things.
17:47:03 <lf94> simpson: there are many Nice Things in Haskell already
17:47:13 <lf94> SimpleIRC looked like a nice thing
17:47:18 <simpson> lf94: Optical illusions, I assure you.
17:47:27 <lf94> hahaha
17:47:40 <lf94> simpson why are you using haskell then if it offers nothing nice?
17:47:45 <fizz_ed> lf94: haha. not at all!
17:47:51 <fizz_ed> lf94: just new to haskell.
17:47:59 <lf94> aight, me too :)
17:48:12 <lf94> I've looked into Haxe but doesnt look like a good investment of time
17:48:13 <simpson> lf94: Well, you're assuming that I use Haskell, and that I was referring exclusively to Haskell when stating that Nice Things cannot be had.
17:48:34 <lf94> We are in #haskelll you know
17:49:03 <fizz_ed> lf94: its fine for making games across every conceivable platform. Its written in ocaml.
17:49:03 <lf94> simpson: quit trolling more coding
17:49:08 <simpson> Sure. We're currently on IRC, which is not a Nice Thing, and we're talking about programming, which is also not a Nice Thing.
17:49:22 <lf94> simpson: I think IRC is quite nice
17:49:31 <lf94> It is a protocol that has stood the test of time
17:50:16 <simpson> lf94: But it is a truly horrid thing for anybody hoping to implement or interact with it.
17:51:17 <simpson> But don't take my word for it. Dig into RFC 1459, or RFC 2810-2813, or any other document purporting to standardize and document IRC.
17:51:24 <michaelt> lf94: https://github.com/michaelt/ElysiaBot
17:51:40 <lf94> :o
17:51:51 <lf94> where do I send the money michealt
17:52:15 <michaelt> lf94: thanks to the miracle of git, you can inspect the changes which are all mechanical and dumb
17:52:27 <lf94> doing exactly that :D
17:52:46 <lf94> thanks a ton michaelt
17:53:13 <michaelt> lf94: they're worth looking at since you bump into them from time to time
17:53:39 <RyanGlScott> Is it possible to use Data.Aeson.TH's deriveJSON function with data instances?
17:54:55 <lf94> michaelt: why did you change the \_ ?
17:55:24 <michaelt> lf94: the new exceptions need to know the type
17:56:11 <michaelt> but when the information isn't being used you just replace it with (\(SomeException _ ) ->
17:56:31 <k00mi> michaelt: did you test if reconnecting works?
17:56:37 <michaelt> haha, no!
17:57:08 <michaelt> lf94 said he'd pay if compiled, not if it worked...
17:57:12 <lf94> hehe
17:57:14 <lf94> yep
17:57:24 <lf94> michaelt I'll give you $5, pm paypal email or something
17:57:48 <michaelt> it's okay Haskell is its own reward.
17:58:07 <lf94> ok i expected that B)
17:58:10 <lf94> you are a good man
17:58:21 <lf94> So SomeException is a real Exception?
18:00:42 <k00mi> I wonder if the original author did any testing at all
18:01:34 <k00mi> simpleirc doesn't do any exception handling whatsoever, there is no way it could work
18:04:34 <michaelt> lf94: SomeException is one of these wacky existential types, something like data SomeException = SomeExceptions (Exception e => e)
18:05:01 <lf94> so this is just a quick hack to get it to compile?
18:05:43 <shachaf> michaelt: That doesn't make sense. data SomeException = forall e. Exception e => SomeException e, with the => on the outside.
18:05:45 <michaelt> lf94: no, it was the standard thing to do for that kind of case. Nothing was being used about the exception except the show instance
18:05:53 <michaelt> shachaf: right
18:06:34 <michaelt> data SomeException where SomeException :: Exception e => e -> SomeException
18:06:40 <shachaf> You could write data SomeException = forall e. SomeException (Exception e *> e) or data SomeException = SomeException (exists e. Exception e *> e) as equivalent types if GHC supported exists and *> , but it doesn't.
18:06:49 <michaelt> is what I would write, since then I don't get confused
18:09:03 <k00mi> you probably want to catch IOExceptions only, not any type of Exception
18:10:13 <michaelt> k00mi: I think that's right, but the program is in fact not using anything distinctive of any particular kind of exception type, only that it can be shown.
18:11:50 <k00mi> it's a blocking operation, you don't want to ignore async exceptions
18:12:52 <michaelt> Was it a bad program when it was written?
18:14:44 <michaelt> hm, the author is mostly writing in 'nimrod' these days ...
18:14:52 <lf94> maybe i'm better off using lambabot
18:14:53 <lf94> :s
18:16:01 <k00mi> I haven't really looked at ElysiaBot, but I did look at SimpleIRC, which was written by the same author, and it's quite bad
18:17:41 <michaelt> ah, I see. Is there a better library that's like SimpleIrc?
18:19:19 <k00mi> I couldn't find one, but I did try to fix the issues with SimpleIRC
18:19:36 <k00mi> https://github.com/k00mi/Simpleirc
18:19:44 <michaelt> Ah, I see now it's the same character.
18:19:57 <lf94> yeah...
18:20:05 <lf94> I liked his API though
18:20:10 <lf94> but if it's bad then eh
18:20:17 <lf94> like I said, I'll go with lambdabot
18:20:24 <lf94> unless k00mi's is actually good :D
18:20:43 <michaelt> k00mi: oh now I see what you meant, asking about reconnecting.
18:20:49 <k00mi> it's still not very reliable
18:21:57 <k00mi> michaelt: there are actually several problems
18:22:35 <k00mi> for one, he tries to reconnect only once after he detects a disconnect, which will almost certainly fail
18:23:07 <michaelt> k00mi: I see, this is why you haven't made a pull request; the troubles keep piling up...
18:23:11 <k00mi> the other problems is that in practice the thread reading messages from the server will die and no disconnect will be detected
18:23:17 <k00mi> yes
18:23:44 <k00mi> once I get to a state I'm happy with I will make a pull request
18:24:20 <k00mi> the "parser" doesn't even do any error handling
18:24:30 <k00mi> it just dies if a single malformed message arrives
18:30:44 <nitrix> fpcomplete is genious.
18:31:19 <nitrix> The tips are the greatest thing since sliced bread. I learned about mapM instead of sequence . map and more:P
18:38:07 <Zemyla> @pl \(a, _) (b, _) -> a == b
18:38:07 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
18:43:35 <michaelt> @type (==) `on` fst
18:43:36 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
18:44:44 <michaelt> I guess that's a narrower type than Zemyla was looking for
18:45:00 <Zemyla> :type on
18:45:05 <Zemyla> :t on
18:45:06 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:45:26 <Zemyla> Where is on defined?
18:45:31 <exio4> Data.Function
18:46:05 <exio4> @hoogle on
18:46:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:46:06 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
18:46:06 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
18:46:15 <michaelt> on comp f  x y = comp (f x) (f y)
18:46:53 <exio4> with rank2types an on function could have a less restricted type, I guess
18:50:53 <nitrix> What is the idiomatic way of expressing a successful or not succcessful IO computation?
18:51:02 <nitrix> inodeInsert :: InodeId -> Page -> [Provider] -> IO Bool   ?
18:51:08 <nitrix> I'm curious about IO Bool.
18:51:23 <nitrix> Certainly there's something better :/
18:54:45 <princearthur> ¡€#¡œ˙éé®íú\\íó¢§ˆ¶¨ªº…æ˛¯˜˘¸ˇœ€ªœ˙8721783284367wyuwoisa
18:58:45 <apo_> don't swear
19:02:33 <Welkin> does anyone have experience using angel? https://hackage.haskell.org/package/angel-0.5.0
19:02:53 <Welkin> the child process that spawns will not recognize my environment variables
19:16:18 <carter> Welkin: ask NemesisD , he wrote it afaik
19:16:27 <carter> well, he maintains it
19:17:03 <NemesisD> Welkin: what's your question
19:18:03 <carter> i'm a wizzard
19:18:07 <carter> shhh
19:18:24 <benzrf> *whizzar
19:18:25 <benzrf> d
19:18:42 <benzrf> http://gunshowcomic.com/471
19:28:58 <Welkin> NemesisD: I am trying to run yesod through angel
19:29:17 <Welkin> NemesisD: but it won't recognize any of my environment variables that are required for it to run porperly
19:29:20 <Welkin> properly*
19:30:57 <NemesisD> Welkin: have you tried coming up with a minimal repro case, like a shell script?
19:31:09 <Welkin> repro?
19:31:54 <NemesisD> Reproduction
19:32:01 <Welkin> although I have another question that is bothering me -- if I am using angel to manage yesod, what is managing angel, and how I do run angel properly as a background process?
19:33:35 <Welkin> NemesisD: I don't know what you mean by that -- it works, but the environment variables set in my bash profile do not load
19:33:37 <NemesisD> i'd probably recommend using upstart or an init script to run angel, although in that case it may be a smart idea to just run everything with that
19:35:42 <NemesisD> Welkin: as far as I remember angel doesn't copy your environment or anything, are you passing an env in the config?
19:35:42 * hackagebot text-show 0.3.0.0 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.3.0.0 (ryanglscott)
19:36:30 <Welkin> no
19:36:36 <Welkin> sorry, I don't know how all of this works
19:36:45 <Welkin> I'm just trying to get yesod up and running on a server
19:37:44 <NemesisD> Welkin: this could be a bug, angel is more or less a layer over https://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html AFAIK it will not take your shell's environment and inherit it to the child process, it will pass in the environment you give it
19:38:27 <NemesisD> maybe it should always inherit. you could file an issue on it, and in the mean time try in your config specifying an env with the variables you need for yesod
19:38:57 <NemesisD> tbh i started rewriting angel because its implementation is really crufty but I couldn't get anyone to help me test out the rewrite so it kind of lost steam
19:39:24 <Welkin> I tried passing them in through the env parameter
19:39:29 <Welkin> but that just gave me errors
19:40:00 <NemesisD> Welkin: i've got to run pretty soon but could you please put together the details of those errors and submit them as an issue on the github page for angel?
19:40:56 <Zemyla> @pl \a b -> exp (a + b)
19:40:56 <lambdabot> (exp .) . (+)
19:41:01 <NemesisD> as far as I know the env config feature of angel should work
19:41:15 <Welkin> there are no commas, correct?
19:41:41 <NemesisD> Welkin: i'm not sure what you mean by commas, here's an example: https://github.com/michaelxavier/angel#configuration-and-usage-example
19:42:11 <nitrix> Is it possible to write a tuple application?
19:42:31 <nitrix> ((`getName`), (`putPage`)) provider
19:42:40 <NemesisD> nitrix: like a section?
19:42:49 <NemesisD> oh wait nm
19:42:59 <nitrix> NemesisD: I think, I'm getting errors about sections, so we're probably close.
19:43:00 <NemesisD> you can do that with arrows i think
19:43:06 <nitrix> Let me word it differently.
19:43:10 <NemesisD> there is LANGUAGE TupleSections
19:43:37 <nitrix> I want to use map on a list, where the function would return a tuple, but I can't figure out how to write that function
19:43:50 <NemesisD> show &&& (+5) $ 13
19:44:06 <NemesisD> that will return ("13", 18)
19:44:14 <nitrix> Since it used to be (`putPage` page)  a partially applied function
19:44:49 <nitrix> So I need a function that returns a tuple, where one of the members is the result of a partially applied function. It's getting nasty right x] ?
19:45:03 <nitrix> NemesisD: &&& ?
19:45:09 <NemesisD> nitrix: from Control.Arrow
19:45:30 <NemesisD> i'm sure arrows are cool and all but I only use them for Stupid Tuple Tricks
19:45:36 <nitrix> How god. Today I had my first Applicative Functor <$> and now &&& an arroe ahah.
19:45:49 <NemesisD> lol cheers
19:47:23 <Zemyla> @pl \(a, p) -> (length a, p)
19:47:23 <lambdabot> first length
19:47:34 <Zemyla> :t first
19:47:35 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:48:22 <Welkin> NemesisD: it seems to work now
19:48:33 <Welkin> I misread the syntax
19:48:39 <ReinH> :t first `asAppliedTo` (undefined :: a -> b)
19:48:40 <lambdabot> (a -> b) -> (a, d) -> (b, d)
19:57:51 <nitrix> One more thing, let's say I have a newtype that is a tuple, and a list of tuples that are compatible, how would a create a list of such that type?
19:58:01 <nitrix> map TypeConstructor theList ?
19:58:24 <nitrix> Or is there a nicer way?
19:58:34 <HeladoDeBrownie> Sounds like what you just said is what you want
19:58:49 <nitrix> Alright. I just find that I'm using map for way too many things.
19:58:58 <HeladoDeBrownie> map is handy
19:59:04 <nitrix> I has to be doing something wrong for sure, it's everywhere now x]
20:06:04 <Zemyla> @pl \a b -> map a (reverse b)
20:06:04 <lambdabot> (. reverse) . map
20:08:18 <stevejb> Hello, quick question on the usage of WriterT. I am quite inexperienced with monad transformers and I would like to (temporarily) add some logging to my code. However, this code needs to be performance intensive and I have read that WriterT can sometimes be slow. The functions that I want to log currently run inside RandT (which is really a StateT), so I suppose I would make a monad transformer stack of RandT and StateT. Is this the
20:08:19 <stevejb> right approach? Also, when I disable the logging, what is the easiest way to go about doing that so that I can retain optimal performance.
20:09:01 <johnw> stevejb: are you writing an application, or a library?
20:09:38 <stevejb> johnw: a library for a research project, so probably only myself and my advisor will ever use it.
20:10:23 <stevejb> johnw: it solves a certain class of problems, and I have a few programs that call this library.
20:10:32 <johnw> Then another option that you have is to use a library like my logging library, which simply provide you some logging facilities in IO
20:10:53 <johnw> it's designed to make it very easy for application writers to add logging to their applications without having to deal with a monad transformer stack
20:11:18 <stevejb> johnw: that would be great. What is it called?
20:11:22 <johnw> http://hackage.haskell.org/package/logging
20:11:27 <merijn> http://www.theonion.com/video/judge-rules-white-girl-will-be-tried-as-black-adul,18896/
20:11:37 <stevejb> johwn: thank you!
20:11:40 <merijn> oh, whoops, wrong channel >.>
20:11:45 <stevejb> johnw: thank you!
20:11:55 <recursion-ninja> I have a (Map k v) and a function (f :: v -> v -> Ordering). I want to get the minimal Key/Value from the map satisfying `f`. I know I can use `minimumBy f` but that just gets me the value, I want the Key/Value pair. Is there an efficient way to do this without reverting the Map to a List?
20:12:11 <recursion-ninja> merijn: Nice, one of my favorite articles
20:12:35 <merijn> recursion-ninja: Might as well go through list, shouldn't cost you much
20:12:43 <merijn> recursion-ninja: You need to scan all data anyway
20:12:56 <merijn> And the intermediate list is likely to fuse away
20:13:10 <recursion-ninja> merijn: Alright, it just doesn't look as pretty
20:13:22 <merijn> recursion-ninja: Use more local definitions :p
20:13:58 <recursion-ninja> merijn: And it will be applied recusively so and I didn't want to transfer back & forth between data types at each recursive step
20:14:30 <recursion-ninja> merijn: I'll just transfer once at the beginning of the recursion, and once after it completes
20:15:08 <stephenmac7> How would I go about dealing with a package that has 0 documentation besides the generated stuff?
20:16:03 <merijn> stephenmac7: Guessing, meditating on the types for hours and looking at the source?
20:16:31 <stephenmac7> merijn: If only people took the few minutes it takes to write commentary...
20:16:32 <recursion-ninja> stephenmac7: Find a similar package with better documentation?
20:16:46 <stephenmac7> It's a large package and I can't find another like it
20:16:50 <stephenmac7> https://hackage.haskell.org/package/satchmo
20:16:51 <merijn> stephenmac7: Not everyone has the time/motivation
20:17:21 <merijn> stephenmac7: Sometimes you hack something together quickly for your own stuff and think "well, this might be useful to SOMEONE" and upload it to hackage, just in case
20:17:46 <stephenmac7> Possibly. I doesn't even have a readme, so that may  be the case
20:18:03 <recursion-ninja> stephenmac7: At least they generated the type data for you, I've seen a package missing that IIRC...
20:18:21 <merijn> recursion-ninja: That's just a matter of the package build failing on hackage
20:18:27 <stephenmac7> For some reason there are many packages where they are missing
20:18:35 <merijn> recursion-ninja: There's dedicated docs build machines now, so that should be fixed now
20:18:52 <recursion-ninja> merijn: That was 6-9 months ago...
20:18:55 <merijn> If you find a package missing docs, report it so that can be fixed on the machines
20:19:08 <stephenmac7> Data.Text was the one that bothered me the most when it didn't have docs
20:19:23 <merijn> recursion-ninja: What was 6-9 months ago?
20:19:46 <recursion-ninja> merijn: When I saw some packages with missing docs
20:20:46 * hackagebot monad-parallel 0.7.1.3 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.7.1.3 (MarioBlazevic)
20:21:33 <stephenmac7> That one there is missing docs (reported by hackagebot)
20:21:47 <stephenmac7> Probably because they haven't been built yet though
20:21:51 <johnw> stephenmac7:  sometimes it takes several hours for hackage to catch up
20:23:49 <stephenmac7> I've been looking for something like this for days and whenever I find a package, I can't understand how to use it
20:24:14 <aspidites> not really a haskell question, but for those that code for a living, how do you stay motivated to work on your personal projects?
20:24:51 <johnw> aspidites:  Because they're fun
20:24:53 <stephenmac7> aspidites: I don't, but I think it's probably because the work is very different
20:25:12 <aspidites> I like Haskell better than what I use at work, but the learning investment is such that I've been stuck in this sort of feed back loop that never progresses
20:25:37 <stephenmac7> aspidites: I can't seem to be able to get past "lower intermediate" in haskell
20:25:43 <stephenmac7> Seems to be a common thing
20:25:54 <stephenmac7> It doesn't agree with my brain
20:25:59 <merijn> aspidites: I think the problem is not "lack of motivation"
20:26:15 <merijn> aspidites: The problem is "after a full day of coding, your brain is worn out and to tired to code"
20:26:33 <aspidites> yeah, i've seen the sentiments accross the web, though i have yet to see anyone come up with any concrete (annotated) solutions
20:26:37 <aspidites> merijn: you're probably right
20:26:50 <merijn> Hell, even my "fun" projects lose motivation frequently and I leave them untouched for weeks
20:26:54 <hodapp> ooh, I could use Haskell to generate better C code!
20:27:00 <nisstyre> aspidites: drink diet coke
20:27:05 <ReinH> merijn: can confirm. source: my brain
20:27:05 <johnw> hodapp: check out Ivory if you want to go that route
20:27:07 <nisstyre> that's what John Carmack does
20:27:10 <aspidites> lol
20:27:11 <nisstyre> seems to work well for him
20:27:16 <merijn> Just go play a video game or do something else until you feel motivated again
20:27:29 <aspidites> merijn: problem with that is that i don't stop the games, lol
20:27:44 <hodapp> johnw: I'm looking at Atom right now and maybe language-c
20:27:45 <nisstyre> aspidites: go talk to someone?
20:27:56 <aspidites> i worked 8 hours, played 2 hours of killing floor, finished my finals for the semester in 2 hours and now I'm here, lol
20:28:07 <johnw> hodapp: I've used language-c quite a bit
20:28:24 <hodapp> Ivory looks nice too... what I've seen so far
20:28:26 * aspidites googles language-c
20:28:41 <aspidites> ReinH: so what do you do about the brain issue?
20:28:50 <ReinH> take breaks
20:28:59 <nisstyre> go talk to someone
20:29:01 <ReinH> try to get good sleep
20:29:19 <merijn> aspidites: How's that a problem? Nowadays I only get something done on my projects on the weekend due to being to tired during the week
20:29:22 <nisstyre> curl up into a ball
20:29:30 <merijn> aspidites: Also, work out more, it's relaxing for your brain
20:29:35 <johnw> also, do avoid TV
20:29:43 <johnw> it sucks up minutes here and there that add up
20:29:47 <nisstyre> hug someone
20:29:59 <stephenmac7> http://hackage.haskell.org/package/sat-micro-hs seems to not have haddock generated
20:30:08 <stephenmac7> It's pretty old too
20:30:11 <aspidites> I haven't owned a tv for almost 2 years now
20:30:20 <aspidites> and i just started working out monday (focus T25)
20:30:20 <johnw> stephenmac7: maybe you should bring this up in #hackage?
20:30:21 <phaskell> T25: Add LLVM configuration to Harbormaster - https://phabricator.haskell.org/T25
20:30:26 <aspidites> so i guess i'm starting to get onto the right track
20:30:30 <stephenmac7> johnw: That's a channel?
20:30:33 <johnw> yep
20:31:09 <aspidites> sleep...i've been averaging 7 hours the last few months, compared to 4 from my last job + sleeping 12 hours the day after the work week
20:31:39 <aspidites> i know the diet coke thing was a joke, but you might be on to something -- too much caffeine then crashing after a long day probably means something
20:32:20 <aspidites> thanks merijn ReinH nisstyre ,etc
20:32:57 <hodapp> johnw: I could see this being very useful for what I need, if I can make it play nice with Atom
20:33:23 <aspidites> #haskell - from functional programming to functional living -- get the advice you need
20:33:37 <hodapp> johnw: I was only going to be using language-c for generating C more efficiently but it looks like Ivory may fit the bill better
20:35:24 <aspidites> ooh. language c even has trac docs
20:36:38 <aspidites> @remember
20:36:38 <lambdabot> Incorrect arguments to quote
20:40:47 * hackagebot witherable 0.0 - Generalization of catMaybes  http://hackage.haskell.org/package/witherable-0.0 (FumiakiKinoshita)
20:41:35 <dfeuer> Zemyla, that's disgusting.
20:41:46 <dfeuer> Oh wait, that was hours ago.
20:42:07 <Zemyla> What was disgusting?
20:42:55 <dfeuer> Zemyla, some @pl thing you did.
20:43:05 <Zemyla> Which one was it?
20:43:48 <dfeuer> Dunno. It's up beyond my scrollback, and I don't want to dig through logs.
20:47:53 <prinsen> Im 'done' with my ECMA-262 interpreter. What is the normal proceduere to release it to the community?
20:48:27 <dfeuer> prinsen, that sounds like a Hackage thingum. Are there instructions on Hackage for getting your package added?
20:49:50 <prinsen> Also, as this is my first try at a haskell library, code review would be awesome
20:50:17 <dfeuer> prinsen, where is your liiiibrary?
20:50:28 <dfeuer> Also, I have no idea what ECMA-262 is.
20:50:54 <dfeuer> Oh, it's that.
20:51:34 <dfeuer> prinsen, I think it's funny that we have a couple Haskell-to-ECMAscript compilers, and you've produced an interpreter going the other way.
20:51:35 <prinsen> dfeuer: at my computer. Going to separate the code into its own git repo
20:51:38 <carter> prinsen: put it on github
20:51:47 <carter> and then ask for feedback on reddit or cafe
20:51:47 <dfeuer> Yes, github is a good first step!
20:52:08 <carter> also getting some code review before putting on hackage would be good too
20:52:53 <prinsen> cool, would also need someone to help me implement the gazillions of spec functions. Im done with the core language and its about 5 k lines
20:53:22 <prinsen> guessing the remaining functions is going to o be another 4 k
20:53:28 <dfeuer> carter, Milan said yes to exporting the splitTraverse thing, but only with the Splittable class scrubbed out. It's a bit yucky, but he's obviously right that Data.Sequence shouldn't export such a class, and it probably doesn't belong anywhere in containers.
20:54:08 <carter> cool
20:54:17 <dfeuer> Also said yes to the fromArray thing, but not the assoc thing or the Ix thing.
20:54:27 <dfeuer> Reasonable, I think.
20:55:02 <dfeuer> And splitTraverse will also be used to implement your fromVectorLike, which is renamed to fromFunction,
20:55:11 <dfeuer> and also used for mapWithIndex.
20:55:39 <dfeuer> And in fact fromVectorLike and mapWithIndex get to share a specialized copy of it with the same splitter function, which is good for code size.
20:57:43 <carter> cool!
20:57:51 <gcganley> @pl (== x)
20:57:51 <lambdabot> (x ==)
20:58:02 <carter> dfeuer: wait, does current containers dep on array?
20:58:02 <gcganley> @pl sat (== x)
20:58:03 <lambdabot> sat (x ==)
20:58:08 <gcganley> :(
20:58:15 <carter> oh it does
20:58:26 <gcganley> how do i use @pl without looking like a moron
21:00:27 <carter> @pl fold (+) . map (substract 7)
21:00:27 <lambdabot> fold (+) . map (substract 7)
21:00:31 <carter> derp
21:00:49 <carter> @pl (\(x,y) -> x + y)
21:00:50 <lambdabot> uncurry (+)
21:01:26 <dfeuer> carter, yes it does, and it doesn't matter.
21:01:37 <carter> true
21:01:45 <dfeuer> Because everything we need is in GHC.Arr.
21:01:56 <wei2912> @pl \ x y -> x + y / y - x * y * x + y / x / y * x
21:01:56 <lambdabot> ap (ap . ((+) .) . ap (ap . ((-) .) . (. join (/)) . (+)) (flip =<< ((*) .) . (*))) (flip =<< ((*) .) . join . ((/) .) . flip (/))
21:02:00 <wei2912> wheeeeeee
21:02:02 <wei2912> point free hell
21:02:15 <dfeuer> So for GHC, I import GHC.Arr, and for anything else I import Data.Array.
21:02:23 <recursion-ninja> wei2912: put that into production & SHIP IT!
21:02:38 <carter> dfeuer: containers deps on array
21:02:43 <wei2912> recursion-ninja: lol
21:02:57 <dfeuer> carter, Data.Array isn't good enough to do it efficiently, as we discussed.
21:03:09 <carter> oh? why was that again?
21:03:12 <dfeuer> Because there is no Int indexing in Data.Array.
21:03:37 <carter> oh yeah
21:03:46 <carter> wait
21:03:48 <carter> really?
21:03:57 <dfeuer> Really!
21:03:58 <carter> should that get fixed?
21:04:11 <dfeuer> HMMMMM
21:04:18 <dfeuer> Good question.
21:04:30 <dfeuer> I don't know.
21:04:58 <dfeuer> Since Array's limitations have made it less than relevant, I think some fixup to let it regain relevance might be in order....
21:06:21 <dfeuer> carter, I just realized why my idea of sharing a specialized version for those functions I mentioned might not work like I wanted. Let's see.....
21:06:21 <carter> that might be a little late for 7.10 though
21:06:27 <recursion-ninja> Any plauers in here doing the Putnam Challenge tomorrow?
21:06:28 <dfeuer> Yes.
21:06:38 <carter> i never did that while in school sadly
21:06:42 <dfeuer> I think it probably is, carter.
21:06:53 <dfeuer> I don't know what a Putnam Challenge is.
21:07:00 <carter> @google putnam competition
21:07:02 <recursion-ninja> Undergrad math competition
21:07:02 <lambdabot> http://www.maa.org/programs/maa-awards/putnam-competition-individual-and-team-winners
21:07:02 <lambdabot> Title: Putnam Competition Individual and Team Winners | Mathematical Association of ...
21:07:04 <dfeuer> But it sounds like I mightn't be eligible.
21:07:11 <dfeuer> If you have to be in school.
21:07:15 <carter> you can take it 3 times in undergrad
21:07:17 <dfeuer> Which I'm not at the moment.
21:07:26 <carter> i should try to work through them sometime
21:07:30 <dfeuer> But hopefully next semester?
21:07:35 <carter> dfeuer: its once a year
21:07:43 <dfeuer> Yes, you're a fish.
21:07:51 <carter> eh?
21:07:52 <recursion-ninja> The First Saturday of December each year
21:08:22 <dfeuer> They should do it on Christmas Eve, to give us non-Christians an edge.
21:08:23 <carter> http://kskedlaya.org/putnam-archive/
21:08:52 <recursion-ninja> dfeuer: I doubt they would get many participants that way...
21:09:00 <carter> http://kskedlaya.org/putnam-archive/
21:09:24 <recursion-ninja> dfeuer: My math department is pushing hard for undergrads to participate. They can't seem to stir up intrest
21:09:49 <dfeuer> recursion-ninja, most people aren't Christians.
21:10:56 <recursion-ninja> dfeuer: I'm just saying they want to try and get as many people to take it as possible, alining it with a holiday isn't a good way to go...
21:11:27 <dfeuer> True, recursion-ninja. True.
21:12:08 <dfeuer> Oh, this does actually work, well enough anyway. Hmmmm
21:12:33 <recursion-ninja> I gotta go get my 8 hours sleep before the challenge, night playaz!
21:13:00 <dfeuer> Zie went out like a ninja.
21:14:20 <dfeuer> carter, I get a warning "<Typeable.h> is obsolete and will be removed in GHC 7.10"
21:14:27 <carter> wtf
21:14:37 <dfeuer> That's in 7.9.
21:14:39 <dfeuer> HMMM
21:14:45 <yyttr3> I have a data type that has kind Constraint for some reason.  Data Prim = Num Int | Str String | Chr Char,   If I type :k Num Int I get Constraint?
21:14:48 <carter> whys there a typeable .h
21:14:53 <dfeuer> Now I am a couple weeks behind, but I'm guessing someone forgot to remove it.
21:15:11 <carter> https://github.com/haskell/containers/blob/master/include/Typeable.h
21:15:19 <carter> dfeuer: even worse, containers has a copy
21:15:23 <dfeuer> o.O
21:15:37 <johnw>  Does anyone know of any libraries that they would consider specifically related to privacy and Haskell? I'm not looking for anything in particular, just to survey the field of what has been done relating to privacy in Haskell
21:15:38 <dfeuer> What for? Fat whore.
21:15:51 <carter> johnw: information flow stuff
21:15:58 <johnw> yeah, besides that :)
21:16:01 <dfeuer> Ooh, that sounds interesting and hard.
21:16:12 <Zemyla> What program do I read .hi profiling documents with?
21:16:25 <dfeuer> Zemyla, what is a .hi profiling document?
21:16:35 <dfeuer> .hi is an interface file.
21:17:03 <carter> dfeuer: .... that file is bad for containers right?
21:17:14 <carter> ooooo
21:17:15 <carter> ooooo
21:17:23 <dfeuer> carter, I don't know nothing about that file except I get a warning every time I compile Data.Sequence.
21:17:28 <carter> #define INSTANCE_TYPEABLE1(tycon,tcname,str) deriving instance Typeable1 tycon
21:17:36 <carter> those are oldtypedable instances right?
21:17:49 <dfeuer> I don't know nothing about no Typable neither.
21:17:55 <carter> #define INSTANCE_TYPEABLE1(tycon,tcname,str) deriving instance Typeable1 tycon
21:18:00 <carter> https://github.com/haskell/containers/blob/master/Data/Sequence.hs#L301
21:18:04 <carter> #include "Typeable.h"
21:18:04 <carter> INSTANCE_TYPEABLE1(Seq,seqTc,"Seq")
21:18:33 <dfeuer> Clearly it's good that it's "deriving" rather than something else, because something else would *certainly* be a big problem. But I don't know nothing about none of this jazz.
21:18:37 <yyttr3> Does anyone know why a data declaration would contain anything with kind other than *?
21:18:45 <carter> yyttr3: when you want it to
21:18:53 <dfeuer> Pretty much.
21:21:10 <dfeuer> carter, it is a reasonable question, though. Such things can be awfully confusing.
21:21:14 <yyttr3> So in what case would it have kind Constraint? I have two data declarations that look almost the same, but one constructor (K) has kin * -> * while the other has * -> Constraint
21:21:25 * dfeuer remembers that ww-fusion time drain....
21:22:13 <carter> .....
21:22:35 <yyttr3> I don't know if I worded it right, i'll make a gist
21:22:50 <michaelt> yyttr3: data X c a where X :: c a => a -> X c a or whatever
21:23:14 <dfeuer> carter, it had weird types in it with type variables of kind *->* and stuff.
21:23:35 <dfeuer> And that gave it just enough flexibility to be utterly confusing.
21:24:07 <michaelt> yyttr3: that should make sense, unless I've gummed things up : you construct an X with a class (i.e. a * -> Constraint), and an element of a type it coverss
21:24:28 <carter> yeah you cant have a data constructor end in Constraint currently
21:25:25 <yyttr3> carter: This is what i'm talking about : https://gist.github.com/yyttr3/9bdf00d33dc364781cca
21:25:38 <carter> num is type class
21:25:46 <carter> Constraint is the "kind"
21:25:52 <carter> for fully applied type classes
21:26:30 <yyttr3> carter: sorry I still messed it up. I should have said :k K instead of :k T.
21:26:36 <michaelt> yyttr3: yes, that seems right though, no?
21:26:53 <carter> you can :t T
21:26:57 <carter> :k idk
21:26:58 <lambdabot> Not in scope: type variable ‘idk’
21:27:02 <carter> haha
21:27:07 <yyttr3> Why is Num of kind * -> Constraint, Should't it be k  * -> *?
21:27:10 <carter> no
21:27:18 <carter> yyttr3: do you know what Num is
21:27:22 <carter> :t 1
21:27:23 <lambdabot> Num a => a
21:27:31 <yyttr3> A type constructor I assume.
21:27:33 <carter> :t (+)
21:27:34 <lambdabot> Num a => a -> a -> a
21:27:39 <carter> whats Num look like
21:27:45 <carter> yyttr3: ... do you know what a type class is?
21:27:45 <michaelt> No, Num there is just the haskell class
21:27:46 <dfeuer> :k Num
21:27:47 <lambdabot> * -> Constraint
21:27:58 <carter> i'll let these folks take over
21:28:06 <yyttr3> I know what a type class is I just don't see how they relate.
21:28:50 <dfeuer> :k Num a
21:28:51 <lambdabot> Not in scope: type variable ‘a’
21:28:54 <dfeuer> :k Num Int
21:28:55 <lambdabot> Constraint
21:29:01 <michaelt> yyttr3: the constraint business integrates them with the fancy kinds system now going.
21:29:02 <dfeuer> That's weird stuff.
21:29:35 <michaelt> the choice of the word "Constraint" is a little strange, but good luck thinking up something better
21:30:02 <dfeuer> ECMAscript = Eckma's crypt.
21:30:08 <yyttr3> michaelt: So why is it that in my gist K Int doesn't have kind Constraint?
21:30:10 <dfeuer> I really, really should go to sleep. Good night, carter!
21:30:16 <carter> sleep well
21:30:19 <dfeuer> YOU TOO.
21:31:21 <yyttr3> :t K = Int -> T,  which is what you expect,
21:31:22 <lambdabot> parse error on input ‘=’
21:31:34 <michaelt> yyttr3: well T is just a regular concrete Haskell type  so it's *
21:31:56 <michaelt> yyttr3: yes, K is a value level function from an Int to a T.
21:33:06 <dfeuer> carter, I hope tomorrow you'll be able to help me with that monolithic "read it all right now" version of fromFunction.
21:33:18 <dfeuer> And/or the horrible <*> arithmetic.
21:33:22 <carter> oh, the one that might use the (##) trick?
21:33:26 <dfeuer> Yeah.
21:33:45 <dfeuer> Also a figuring out how to actually test that :-)
21:34:02 <yyttr3> michaelt: I'm sorry. I can't explain myself well. Num has kind * -> Constraint. When I ask for the kind of K in GHCI I get " Not in scope: type constructor or class ‘K’".
21:34:20 <carter> dfeuer: if you can generalized fromFucntion to  be (Int -> m a)
21:34:23 <carter> with m a monad
21:34:24 <carter> we're set
21:34:34 <dfeuer> carter, to do *what*?
21:34:36 <carter> fromAction
21:34:38 <carter> or something
21:34:48 <carter> because then we know the read happened
21:34:50 <dfeuer> . . .
21:35:07 <carter> runIdenity
21:35:08 <carter> or whatever
21:35:18 <dfeuer> Tomorrow. I don't understand you at all. Tomorrow.
21:35:21 <carter> ok
21:35:59 <michaelt> yyttr3: right, K isn't a type or a type-morpher or the like here.
21:36:30 <dfeuer> carter, the fromFunction is a single line:
21:36:31 <dfeuer> fromFunction len f = splitTraverseCountup (\i _ -> f i) 0 (replicate len ())
21:36:42 <yyttr3> michaelt : What is the difference between K and Num.
21:36:43 <michaelt> yyttr3: where are Num is: it takes a type and returns a claim about it, so to say
21:36:47 <dfeuer> Where  splitTraverseCountup = splitTraverse (\n i -> (i, i+n))
21:36:57 <dfeuer> And that's used also to define mapWithIndex.
21:36:59 <carter> splitTraverseCountup what the type there again?
21:37:10 <dfeuer> splitTraverseCountup :: (Int -> a -> b) -> Int -> Seq a -> Seq b
21:37:28 <dfeuer> Sharing that between the functions cuts code size.
21:37:45 <carter> could we do  Monad m => (Int -> a -> m b) -> Int -> Seq a -> m (Seq b)
21:37:49 <carter> or applicative
21:37:53 <michaelt> yyttr3: the argument that K takes is an individual Int, that's whats registerd in the type signature K :: Int -> T
21:38:12 <yyttr3> michaelt: But they have literally the exact same syntax?  https://gist.github.com/yyttr3/9bdf00d33dc364781cca
21:38:13 <dfeuer> Unfortunately, Ints are boxed, and I don't think there's a way to fix that without code blowup everywhere.
21:38:14 <michaelt> yyttr3: the "argument" that Num takes is a type, for example Int itself.
21:38:27 <dfeuer> I don't know, carter, because that's all mysterious to me.
21:38:30 <dfeuer> TOMORROW.
21:38:38 <johnw> carter: I'm pretty sure you'd need Traversable for that
21:39:05 <yyttr3> michaelt: No! Num also has type Int -> Primitive, but it ALSO has kind * -> Constriant. That is what ghci says.
21:39:08 <carter> johnw: were writingn someting tahts a bit stronger than travser
21:39:09 <michaelt> yyttr3: right,the -> business is recycled from type signatures for kind signatures
21:39:48 <michaelt> yyttr3: oh, I don't know what this Int -> Primitive is
21:39:59 <carter> johnw: to get the right complexity we need to do some crazy shit with respect to do a recursive splitting process and assertive stateless traverse
21:40:02 <yyttr3> michaelt:  https://gist.github.com/yyttr3/9bdf00d33dc364781cca !
21:40:10 <haasn> yyttr3: Whoa there, your Num has absolutely nothing to do with the Num the rest of us are talking about
21:40:11 <michaelt> yyttr3: is this in a data declaration   data Primitive = Num Int | ...
21:40:23 <carter> JohnW so it's a teeny bit different
21:40:32 <haasn> Nor your GHCi, apparently. It's talking about Prelude.Num
21:40:32 <dfeuer> carter, we can actually get the right complexity for the monolithic thing easy.
21:40:34 <haasn> Not your Num
21:40:37 <michaelt> bah, i totally missed that Num constructor you're using!
21:40:45 <dfeuer> But it might be a little sluggish.
21:40:51 <carter> ahhh
21:40:53 <dfeuer> Unless we do it right.
21:40:54 <carter> Sweet
21:40:54 <michaelt> it's becoming clearer now
21:41:02 <dfeuer> ?
21:41:08 <yyttr3> So i'm using another Num and ghci didn't bitch at me? wth
21:41:19 <michaelt> yyttr3: when you type :k Num in the ghci, it didn't think you meant the constructor
21:41:21 <dfeuer> carter, I just mean it's really truly O(n) monolithic, and that's what it's gonna be.
21:41:32 <carter> well yeah
21:41:41 <carter> thats the preice of space safety?
21:41:52 <yyttr3> michaelt: It all makes sense now. I didn't know there was another Num. I'm just upset there wasn't an error thrown now xD
21:41:56 <yyttr3> thank you.
21:42:23 <dfeuer> carter, you have to actually copy all the pointers out of the Array# and into the finger tree!
21:42:32 <dfeuer> If you care.
21:42:34 <carter> yeah
21:42:59 <michaelt> yyttr3: I think if you had one of the kind system extensions on, there would have been trouble, since then (your) Num could also exist 'at the type level', or would have a sort of lifted replica
21:43:01 <dfeuer> BYE BYE BYE BYE
21:43:03 <yyttr3> haasn: Thank you also lol
21:43:51 <haasn> yyttr3: Your Num doesn't have a Kind
21:44:12 <haasn> yyttr3: constructors don't have kinds in Haskell. They are values, they have types
21:44:14 <haasn> Try :t Num
21:44:14 <yyttr3> michaelt: I don't have any extensions on right now. You can define types whose name conflicts with a type class and ghc not throw an error?
21:44:28 <haasn> yyttr3: Values and types live in separate namespaces
21:44:45 <haasn> Your types are called T and Primitive
21:46:00 <ReinH> Just to clarify, *data constructors* don't have kinds. Type constructors do.
21:46:17 <michaelt> yyttr3: like haasn says, you're in a different name space.
21:46:26 <ReinH> Maybe is a type constructor of kind * -> *, Just is a data constructor of type a -> Maybe a
21:48:02 <carter> data constructors have kind *
21:49:34 <haasn> michaelt: It's also not a problem, since by definition they can't conflict - this is why ' is used to distinguish
21:49:48 <ReinH> carter: touché
21:49:54 <ReinH> like all values, they have kind *
21:50:57 <johnw> with DataKinds enabled, the kind of Just is: Just :: k -> Maybe k
21:52:28 <carter> but thats a different namespace
21:52:35 <carter> thats not the same as term just
21:52:39 <carter> we just pretend it is
21:52:43 <johnw> ah, true
21:52:45 <johnw> good point carter
21:53:00 <johnw> I was looking at the kind of the "lifted" entity
21:53:20 <haasn> johnw: Unless you define a type named Just.
21:53:30 <haasn> That one takes precedence
21:53:31 <johnw> which is what DataKinds ought to be doing, right?
21:53:33 <michaelt> haasn: yes, I was going to explain about '
21:57:31 <michaelt> yyttr3: here's some curious ghci with -XDataKinds https://gist.github.com/michaelt/fa2c8ceb9fb8ddbe1538
22:00:09 <michaelt> yyttr3: I scrapped some stuff from Primitive to make it a 'promotable type'
22:05:09 <haasn> I don't think this is relevant to yyttr3. Who has incidentally left the channel
22:07:26 <michaelt> haasn: I don't think there's any disagreement
22:12:34 <ddellacosta> holy crap, fmap is an analogue for 'apply' isn't it
22:12:46 * ddellacosta realizes the simplicity of the thing he's been staring at for months
22:14:11 <haasn> ‘apply’?
22:14:19 <haasn> When I think ‘apply’ I think (a -> b, a) -> b
22:14:41 <michaelt> ddellacosta: you mean ($) , by 'apply'?
22:14:41 <ddellacosta> haasn: sorry, I was connecting it to my experience with lisp, I should have qualified that
22:14:55 <haasn> Ah. I don't know lisp
22:14:58 <michaelt> oh ...
22:14:59 <ddellacosta> and I realize it's not perfect, as fmap is working within a context
22:15:22 <ddellacosta> which is why I say analogue...but there is something there that helped me to finally "get" it
22:16:55 <ddellacosta> more to the point, it's kind of incredible how I've been staring at all these concepts for months and when I finally start getting them I realize that they are actually just very simple
22:17:03 <ddellacosta> it's almost like they are too simple
22:17:09 <Dashkal> :P
22:17:15 <johnw> ddellacosta:  I find that to be a pretty common experience with concepts of this type
22:17:17 <Dashkal> Yep, I had the same trouble
22:17:30 <johnw>  they are almost disappointingly simple after the work it takes to finally see them
22:17:57 <ddellacosta> ha, right, but I guess that's the key--they would maybe not be as powerful if they were not?  but their abstract qualities are hard to see the implications of, I suppose
22:18:05 <j201> ddellacosta: it's more like `map`, since you're transforming each element of a data structure with a function rather than giving all of the elements to a function
22:19:10 <ddellacosta> j201: see, that's how I was thinking of it at first.  But I guess the specific analogous point with fmap and apply that I'm connecting is the idea of "apply"-ing one thing to another in a rather explicit fashion
22:19:28 <ddellacosta> sorry, that may not be explaining it well enough, and it may be a personal interpretation
22:19:37 <ddellacosta> it just seemed to click all of a sudden for me
22:19:53 <ddellacosta> (was reading this for context: http://www.cs.nott.ac.uk/~gmh/monads)
22:20:20 <ddellacosta> I mean, he goes so far as to call it apply there so it's not really a stretch
22:20:54 <platz> 3[A
22:20:58 <CrazyM4n> I love those moments when nothing makes sense
22:21:03 <CrazyM4n> Then someone puts it in a way
22:21:06 <haasn> “apply :: (a -> Maybe b) -> Maybe a -> Maybe b” This one?
22:21:18 <CrazyM4n> And suddenly, pop, it's all easy
22:21:24 <ddellacosta> haasn: yeah
22:21:31 <ddellacosta> CrazyM4n: yeah, exactly...haha
22:21:32 <haasn> That's not really that much like ‘fmap’
22:21:49 <haasn> fmap would be apply :: (a -> b) -> Maybe a -> Maybe b
22:22:46 <j201> yeah, that's (=<<), not fmap
22:23:30 <j201> which is `flip (>>=)`
22:23:40 <ddellacosta> hmm, I guess I was thinking more of the definition--is it not consistent with one way to define fmap?
22:23:58 <ddellacosta> but good point, I'll have to think on that, which may lead to more realizations
22:24:25 <haasn> ddellacosta: Write me a (legal) definition of ‘fmap’ for Maybe
22:25:23 <ddellacosta> haasn: I'll be lazy and point you to the one here: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
22:25:31 <ddellacosta> haasn: but I realize my mistake--it's not re-wrapping it
22:25:38 <j201> ddellacosta: with fmap, you're dealing with an a -> b function and transforming the value inside the Maybe with that function, whereas with (>>=), you're dealing with an a -> Maybe b function and transforming the value inside the Maybe, then 'unwrapping' one Maybe, since you'd end up with a Maybe (Maybe b)
22:25:57 <ddellacosta> j201: right ^
22:26:35 <ddellacosta> although I have to think on the distinction between the two now, they seem quite similar
22:26:45 <ddellacosta> so I guess my epiphany was not so valuable anyways...haha
22:26:59 <ddellacosta> but still, all of your corrections have been helpful
22:27:05 * ddellacosta bows to helpful #haskell folks
22:27:06 <HeladoDeBrownie> I think it's worth pointing out that not all instances can be thought of in terms of unwrapping. IO can't, for example.
22:27:10 <haasn> The most crass distinction is between :: (a -> b) -> IO a -> IO b   and :: (a -> IO b) -> IO a -> IO b
22:27:32 <ddellacosta> ah, hmm
22:27:53 <haasn> (When you understand why, you will most likely have understood IO and monads)
22:28:21 <platz> or Cont or other kind of 'workflowy' monads
22:29:02 <ddellacosta> haasn the first is the type sig for fmap, the second is for bind (>>=) ?
22:29:13 <ddellacosta> no, that's not bind is it
22:29:18 <ddellacosta> hrm
22:29:24 <haasn> :t (>>=)
22:29:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:29:27 <haasn> It's almost the same
22:29:29 <haasn> :t flip (>>=)
22:29:30 <lambdabot> Monad m => (a -> m b) -> m a -> m b
22:29:46 <haasn> But that's not the difference I was talking about. They're different functions, that's for sure
22:30:07 <ddellacosta> ah okay, I don't yet get why you'd do flip (>>=)
22:30:28 <obb> can anybody give me a hint why the compiler is complaining when i do this: pivot = list !! (floor . (/2) . length list)
22:30:46 <srhb> :t (/) -- obb
22:30:47 <lambdabot> Fractional a => a -> a -> a
22:30:53 <srhb> :t length
22:30:54 <lambdabot> [a] -> Int
22:30:57 <haasn> obb: ‘length list’ is an Int
22:31:02 <j201> ddellacosta: convenience for how you order the expressions in your code
22:31:04 <srhb> Int is not a member of Fractional
22:31:12 <ddellacosta> j201: ah, okay
22:31:14 <haasn> obb: (.) takes two functions
22:31:18 <obb> :'((
22:31:26 <srhb> obb: You can just fromIntegral the length
22:31:59 <kadoban> That's a pretty bad suggestion, hehe. Look at what he's doing...  it's just integer division
22:32:32 <srhb> kadoban: Hrmpf, if I can't fix it by the types alone, it's obviously not worth fixing. :-)
22:32:41 <kadoban> :)
22:32:59 <kadoban> obb: floor . (/2)   ----> (`div`2)
22:33:00 <haasn> There's a function for integer division and it's called ‘div’
22:33:13 <j201> ddellacosta: (.) and fmap both take the function that operates last on the value as their first argument, so some people prefer (=<<) for consistency
22:33:15 <srhb> But yes, and it gets worse since (!!) also takes an Int
22:33:22 <srhb> Oh wait, there's a floor in there
22:33:24 <haasn> That said, changing the code to pivot = list !! ((`div`2) . length list) won't improve the situation
22:33:33 <ddellacosta> j201: I see!  That's helpful, thanks
22:34:08 <ddellacosta> j201: I wasn't sure if it represented a separate concept or not, so good to know
22:34:18 <obb> :t div
22:34:19 <lambdabot> Integral a => a -> a -> a
22:34:32 <obb> i wont get an integral by dividing by 2
22:34:45 <srhb> You will with div
22:34:46 <obb> at least for uneven list lengths
22:35:02 <haasn> The type of ‘div’ just told you you will
22:35:09 <srhb> > 3 `div` 2
22:35:10 <lambdabot>  1
22:35:36 <obb> ok :D
22:35:36 <obb> so its taking the floor autom.
22:35:39 <obb> very good
22:35:52 <obb> exactly what i was looking for in the first place
22:36:19 <srhb> > [1,2,3] !! ((`div` 2) . length) list
22:36:21 <lambdabot>  Not in scope: ‘list’
22:36:21 <lambdabot>  Perhaps you meant one of these:
22:36:21 <lambdabot>    ‘last’ (imported from Data.List),
22:36:21 <lambdabot>    ‘BSC.last’ (imported from Data.ByteString.Char8),
22:36:21 <lambdabot>    ‘BSLC.last’ (imported from Data.ByteString.Lazy.Char8)
22:36:23 <srhb> Woops
22:36:48 <srhb> Anyway you got the gist.
22:37:26 <haasn> This operation seems bad either way.
22:37:36 <haasn> Maybe you wanted to use a vector, not a list.
22:37:42 <kadoban> Yeah, once you get it working, time to figure out a better way to sort.
22:38:39 <ddellacosta> haasn, what were you saying re: (a -> b) -> IO a -> IO b   and :: (a -> IO b) -> IO a -> IO b  ?  I see now that the one expects the function passed in to handle the "re-wrapping" back to IO b, whereas the other sig implies it will happen within the fn itself, is there more to it than that?
22:38:56 <haasn> ddellacosta: Yes.
22:39:12 <ddellacosta> haasn: clue? ;-)
22:39:44 <ddellacosta> I mean, can you give me a clue of what you were getting at, if there's more to it than that
22:39:45 <haasn> Hmm. Maybe you could try thinking about rand :: IO Int  and launchMissiles :: IO ()
22:39:53 <ddellacosta> ha, okay
22:40:08 <ddellacosta> is launchMissiles standard?  I want to find that lib...
22:40:19 <haasn> It's in acme-launchmissiles
22:40:27 <ddellacosta> hahaha
22:40:36 <haasn> Sorry, acme-missiles
22:40:37 <ddellacosta> holy crap, that's hilarious
22:40:50 <ddellacosta> one more reason to love Haskell
22:41:10 <haasn> (Be warned, it causes serious international side effects)
22:41:17 <ddellacosta> hah, brilliant
22:41:45 <ddellacosta> thanks haasn, both for help w/thinking about these things as well as cluing me into the existence of that lib
23:23:52 <Phagus> What's a good newbie resource for Haskell?
23:24:00 <Hijiri> https://github.com/bitemyapp/learnhaskell
23:25:07 <Phagus> Merci.
23:58:33 <torpet> EVen though I asked this yesterday. Could someone tell me why foldr concat is more efficient? https://www.dropbox.com/s/gikcmfh91aygjk1/Screenshot%202014-12-06%2008.55.29.png?dl=0
23:59:01 <torpet> Looking at the explanation, that is the same to me. Except with foldl I start at the "right" side after the recursion ended
23:59:26 <pids-bk-at-08utc>         
